{"name":"Set.encard_univ_coe","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq Set.univ.encard s.encard","decl":"@[simp] theorem encard_univ_coe (s : Set α) : encard (univ : Set s) = encard s := by\n  rw [encard, encard, ENat.card_congr (Equiv.Set.univ ↑s)]\n\n"}
{"name":"Set.encard_univ","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_3\n⊢ Eq Set.univ.encard (ENat.card α)","decl":"theorem encard_univ (α : Type*) :\n    encard (univ : Set α) = ENat.card α := by\n  rw [encard, ENat.card_congr (Equiv.Set.univ α)]\n\n"}
{"name":"Set.Finite.encard_eq_coe_toFinset_card","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : s.Finite\n⊢ Eq s.encard ↑h.toFinset.card","decl":"theorem Finite.encard_eq_coe_toFinset_card (h : s.Finite) : s.encard = h.toFinset.card := by\n  have := h.fintype\n  rw [encard, ENat.card_eq_coe_fintype_card, toFinite_toFinset, toFinset_card]\n\n"}
{"name":"Set.encard_eq_coe_toFinset_card","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq s.encard ↑s.toFinset.card","decl":"theorem encard_eq_coe_toFinset_card (s : Set α) [Fintype s] : encard s = s.toFinset.card := by\n  have h := toFinite s\n  rw [h.encard_eq_coe_toFinset_card, toFinite_toFinset]\n\n"}
{"name":"Set.encard_coe_eq_coe_finsetCard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (↑s).encard ↑s.card","decl":"@[simp, norm_cast] theorem encard_coe_eq_coe_finsetCard (s : Finset α) :\n    encard (s : Set α) = s.card := by\n  rw [Finite.encard_eq_coe_toFinset_card (Finset.finite_toSet s)]; simp\n\n"}
{"name":"Set.Infinite.encard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : s.Infinite\n⊢ Eq s.encard Top.top","decl":"theorem Infinite.encard_eq {s : Set α} (h : s.Infinite) : s.encard = ⊤ := by\n  have := h.to_subtype\n  rw [encard, ENat.card_eq_top_of_infinite]\n\n"}
{"name":"Set.encard_eq_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.encard 0) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] theorem encard_eq_zero : s.encard = 0 ↔ s = ∅ := by\n  rw [encard, ENat.card_eq_zero_iff_empty, isEmpty_subtype, eq_empty_iff_forall_not_mem]\n\n"}
{"name":"Set.encard_empty","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.encard 0","decl":"@[simp] theorem encard_empty : (∅ : Set α).encard = 0 := by\n  rw [encard_eq_zero]\n\n"}
{"name":"Set.nonempty_of_encard_ne_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : Ne s.encard 0\n⊢ s.Nonempty","decl":"theorem nonempty_of_encard_ne_zero (h : s.encard ≠ 0) : s.Nonempty := by\n  rwa [nonempty_iff_ne_empty, Ne, ← encard_eq_zero]\n\n"}
{"name":"Set.encard_ne_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Ne s.encard 0) s.Nonempty","decl":"theorem encard_ne_zero : s.encard ≠ 0 ↔ s.Nonempty := by\n  rw [ne_eq, encard_eq_zero, nonempty_iff_ne_empty]\n\n"}
{"name":"Set.encard_pos","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LT.lt 0 s.encard) s.Nonempty","decl":"@[simp] theorem encard_pos : 0 < s.encard ↔ s.Nonempty := by\n  rw [pos_iff_ne_zero, encard_ne_zero]\n\n"}
{"name":"Set.Nonempty.encard_pos","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na✝ : s.Nonempty\n⊢ LT.lt 0 s.encard","decl":"protected alias ⟨_, Nonempty.encard_pos⟩ := encard_pos\n\n"}
{"name":"Set.encard_singleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ne : α\n⊢ Eq (Singleton.singleton e).encard 1","decl":"@[simp] theorem encard_singleton (e : α) : ({e} : Set α).encard = 1 := by\n  rw [encard, ENat.card_eq_coe_fintype_card, Fintype.card_ofSubsingleton, Nat.cast_one]\n\n"}
{"name":"Set.encard_union_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\n⊢ Eq (Union.union s t).encard (HAdd.hAdd s.encard t.encard)","decl":"theorem encard_union_eq (h : Disjoint s t) : (s ∪ t).encard = s.encard + t.encard := by\n  classical\n  simp [encard, ENat.card_congr (Equiv.Set.union h)]\n\n"}
{"name":"Set.encard_insert_of_not_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nhas : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a s).encard (HAdd.hAdd s.encard 1)","decl":"theorem encard_insert_of_not_mem {a : α} (has : a ∉ s) : (insert a s).encard = s.encard + 1 := by\n  rw [← union_singleton, encard_union_eq (by simpa), encard_singleton]\n\n"}
{"name":"Set.Finite.encard_lt_top","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : s.Finite\n⊢ LT.lt s.encard Top.top","decl":"theorem Finite.encard_lt_top (h : s.Finite) : s.encard < ⊤ := by\n  refine h.induction_on _ (by simp) ?_\n  rintro a t hat _ ht'\n  rw [encard_insert_of_not_mem hat]\n  exact lt_tsub_iff_right.1 ht'\n\n"}
{"name":"Set.Finite.encard_eq_coe","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : s.Finite\n⊢ Eq s.encard ↑s.encard.toNat","decl":"theorem Finite.encard_eq_coe (h : s.Finite) : s.encard = ENat.toNat s.encard :=\n  (ENat.coe_toNat h.encard_lt_top.ne).symm\n\n"}
{"name":"Set.Finite.exists_encard_eq_coe","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : s.Finite\n⊢ Exists fun n => Eq s.encard ↑n","decl":"theorem Finite.exists_encard_eq_coe (h : s.Finite) : ∃ (n : ℕ), s.encard = n :=\n  ⟨_, h.encard_eq_coe⟩\n\n"}
{"name":"Set.encard_lt_top_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LT.lt s.encard Top.top) s.Finite","decl":"@[simp] theorem encard_lt_top_iff : s.encard < ⊤ ↔ s.Finite :=\n  ⟨fun h ↦ by_contra fun h' ↦ h.ne (Infinite.encard_eq h'), Finite.encard_lt_top⟩\n\n"}
{"name":"Set.encard_eq_top_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.encard Top.top) s.Infinite","decl":"@[simp] theorem encard_eq_top_iff : s.encard = ⊤ ↔ s.Infinite := by\n  rw [← not_iff_not, ← Ne, ← lt_top_iff_ne_top, encard_lt_top_iff, not_infinite]\n\n"}
{"name":"Set.encard_eq_top","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na✝ : s.Infinite\n⊢ Eq s.encard Top.top","decl":"alias ⟨_, encard_eq_top⟩ := encard_eq_top_iff\n\n"}
{"name":"Set.encard_ne_top_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Ne s.encard Top.top) s.Finite","decl":"theorem encard_ne_top_iff : s.encard ≠ ⊤ ↔ s.Finite := by\n  simp\n\n"}
{"name":"Set.finite_of_encard_le_coe","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : Nat\nh : LE.le s.encard ↑k\n⊢ s.Finite","decl":"theorem finite_of_encard_le_coe {k : ℕ} (h : s.encard ≤ k) : s.Finite := by\n  rw [← encard_lt_top_iff]; exact h.trans_lt (WithTop.coe_lt_top _)\n\n"}
{"name":"Set.finite_of_encard_eq_coe","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : Nat\nh : Eq s.encard ↑k\n⊢ s.Finite","decl":"theorem finite_of_encard_eq_coe {k : ℕ} (h : s.encard = k) : s.Finite :=\n  finite_of_encard_le_coe h.le\n\n"}
{"name":"Set.encard_le_coe_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : Nat\n⊢ Iff (LE.le s.encard ↑k) (And s.Finite (Exists fun n₀ => And (Eq s.encard ↑n₀) (LE.le n₀ k)))","decl":"theorem encard_le_coe_iff {k : ℕ} : s.encard ≤ k ↔ s.Finite ∧ ∃ (n₀ : ℕ), s.encard = n₀ ∧ n₀ ≤ k :=\n  ⟨fun h ↦ ⟨finite_of_encard_le_coe h, by rwa [ENat.le_coe_iff] at h⟩,\n    fun ⟨_,⟨n₀,hs, hle⟩⟩ ↦ by rwa [hs, Nat.cast_le]⟩\n\n"}
{"name":"Set.encard_le_card","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le s.encard t.encard","decl":"theorem encard_le_card (h : s ⊆ t) : s.encard ≤ t.encard := by\n  rw [← union_diff_cancel h, encard_union_eq disjoint_sdiff_right]; exact le_self_add\n\n"}
{"name":"Set.encard_mono","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_3\n⊢ Monotone Set.encard","decl":"theorem encard_mono {α : Type*} : Monotone (encard : Set α → ℕ∞) :=\n  fun _ _ ↦ encard_le_card\n\n"}
{"name":"Set.encard_diff_add_encard_of_subset","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\n⊢ Eq (HAdd.hAdd (SDiff.sdiff t s).encard s.encard) t.encard","decl":"theorem encard_diff_add_encard_of_subset (h : s ⊆ t) : (t \\ s).encard + s.encard = t.encard := by\n  rw [← encard_union_eq disjoint_sdiff_left, diff_union_self, union_eq_self_of_subset_right h]\n\n"}
{"name":"Set.one_le_encard_iff_nonempty","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LE.le 1 s.encard) s.Nonempty","decl":"@[simp] theorem one_le_encard_iff_nonempty : 1 ≤ s.encard ↔ s.Nonempty := by\n  rw [nonempty_iff_ne_empty, Ne, ← encard_eq_zero, ENat.one_le_iff_ne_zero]\n\n"}
{"name":"Set.encard_diff_add_encard_inter","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s t).encard (Inter.inter s t).encard) s.encard","decl":"theorem encard_diff_add_encard_inter (s t : Set α) :\n    (s \\ t).encard + (s ∩ t).encard = s.encard := by\n  rw [← encard_union_eq (disjoint_of_subset_right inter_subset_right disjoint_sdiff_left),\n    diff_union_inter]\n\n"}
{"name":"Set.encard_union_add_encard_inter","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (HAdd.hAdd (Union.union s t).encard (Inter.inter s t).encard) (HAdd.hAdd s.encard t.encard)","decl":"theorem encard_union_add_encard_inter (s t : Set α) :\n    (s ∪ t).encard + (s ∩ t).encard = s.encard + t.encard := by\n  rw [← diff_union_self, encard_union_eq disjoint_sdiff_left, add_right_comm,\n    encard_diff_add_encard_inter]\n\n"}
{"name":"Set.encard_eq_encard_iff_encard_diff_eq_encard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : (Inter.inter s t).Finite\n⊢ Iff (Eq s.encard t.encard) (Eq (SDiff.sdiff s t).encard (SDiff.sdiff t s).encard)","decl":"theorem encard_eq_encard_iff_encard_diff_eq_encard_diff (h : (s ∩ t).Finite) :\n    s.encard = t.encard ↔ (s \\ t).encard = (t \\ s).encard := by\n  rw [← encard_diff_add_encard_inter s t, ← encard_diff_add_encard_inter t s, inter_comm t s,\n    WithTop.add_right_cancel_iff h.encard_lt_top.ne]\n\n"}
{"name":"Set.encard_le_encard_iff_encard_diff_le_encard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : (Inter.inter s t).Finite\n⊢ Iff (LE.le s.encard t.encard) (LE.le (SDiff.sdiff s t).encard (SDiff.sdiff t s).encard)","decl":"theorem encard_le_encard_iff_encard_diff_le_encard_diff (h : (s ∩ t).Finite) :\n    s.encard ≤ t.encard ↔ (s \\ t).encard ≤ (t \\ s).encard := by\n  rw [← encard_diff_add_encard_inter s t, ← encard_diff_add_encard_inter t s, inter_comm t s,\n    WithTop.add_le_add_iff_right h.encard_lt_top.ne]\n\n"}
{"name":"Set.encard_lt_encard_iff_encard_diff_lt_encard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : (Inter.inter s t).Finite\n⊢ Iff (LT.lt s.encard t.encard) (LT.lt (SDiff.sdiff s t).encard (SDiff.sdiff t s).encard)","decl":"theorem encard_lt_encard_iff_encard_diff_lt_encard_diff (h : (s ∩ t).Finite) :\n    s.encard < t.encard ↔ (s \\ t).encard < (t \\ s).encard := by\n  rw [← encard_diff_add_encard_inter s t, ← encard_diff_add_encard_inter t s, inter_comm t s,\n    WithTop.add_lt_add_iff_right h.encard_lt_top.ne]\n\n"}
{"name":"Set.encard_union_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ LE.le (Union.union s t).encard (HAdd.hAdd s.encard t.encard)","decl":"theorem encard_union_le (s t : Set α) : (s ∪ t).encard ≤ s.encard + t.encard := by\n  rw [← encard_union_add_encard_inter]; exact le_self_add\n\n"}
{"name":"Set.finite_iff_finite_of_encard_eq_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : Eq s.encard t.encard\n⊢ Iff s.Finite t.Finite","decl":"theorem finite_iff_finite_of_encard_eq_encard (h : s.encard = t.encard) : s.Finite ↔ t.Finite := by\n  rw [← encard_lt_top_iff, ← encard_lt_top_iff, h]\n\n"}
{"name":"Set.infinite_iff_infinite_of_encard_eq_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : Eq s.encard t.encard\n⊢ Iff s.Infinite t.Infinite","decl":"theorem infinite_iff_infinite_of_encard_eq_encard (h : s.encard = t.encard) :\n    s.Infinite ↔ t.Infinite := by rw [← encard_eq_top_iff, h, encard_eq_top_iff]\n\n"}
{"name":"Set.Finite.finite_of_encard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhs : s.Finite\nh : LE.le t.encard s.encard\n⊢ t.Finite","decl":"theorem Finite.finite_of_encard_le {s : Set α} {t : Set β} (hs : s.Finite)\n    (h : t.encard ≤ s.encard) : t.Finite :=\n  encard_lt_top_iff.1 (h.trans_lt hs.encard_lt_top)\n\n"}
{"name":"Set.Finite.eq_of_subset_of_encard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Finite\nhst : HasSubset.Subset s t\nhts : LE.le t.encard s.encard\n⊢ Eq s t","decl":"theorem Finite.eq_of_subset_of_encard_le (ht : t.Finite) (hst : s ⊆ t) (hts : t.encard ≤ s.encard) :\n    s = t := by\n  rw [← zero_add (a := encard s), ← encard_diff_add_encard_of_subset hst] at hts\n  have hdiff := WithTop.le_of_add_le_add_right (ht.subset hst).encard_lt_top.ne hts\n  rw [nonpos_iff_eq_zero, encard_eq_zero, diff_eq_empty] at hdiff\n  exact hst.antisymm hdiff\n\n"}
{"name":"Set.Finite.eq_of_subset_of_encard_le'","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : s.Finite\nhst : HasSubset.Subset s t\nhts : LE.le t.encard s.encard\n⊢ Eq s t","decl":"theorem Finite.eq_of_subset_of_encard_le' (hs : s.Finite) (hst : s ⊆ t)\n    (hts : t.encard ≤ s.encard) : s = t :=\n  (hs.finite_of_encard_le hts).eq_of_subset_of_encard_le hst hts\n\n"}
{"name":"Set.Finite.encard_lt_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Finite\nh : HasSSubset.SSubset s t\n⊢ LT.lt s.encard t.encard","decl":"theorem Finite.encard_lt_encard (ht : t.Finite) (h : s ⊂ t) : s.encard < t.encard :=\n  (encard_mono h.subset).lt_of_ne (fun he ↦ h.ne (ht.eq_of_subset_of_encard_le h.subset he.symm.le))\n\n"}
{"name":"Set.encard_strictMono","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ StrictMono Set.encard","decl":"theorem encard_strictMono [Finite α] : StrictMono (encard : Set α → ℕ∞) :=\n  fun _ _ h ↦ (toFinite _).encard_lt_encard h\n\n"}
{"name":"Set.encard_diff_add_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s t).encard t.encard) (Union.union s t).encard","decl":"theorem encard_diff_add_encard (s t : Set α) : (s \\ t).encard + t.encard = (s ∪ t).encard := by\n  rw [← encard_union_eq disjoint_sdiff_left, diff_union_self]\n\n"}
{"name":"Set.encard_le_encard_diff_add_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ LE.le s.encard (HAdd.hAdd (SDiff.sdiff s t).encard t.encard)","decl":"theorem encard_le_encard_diff_add_encard (s t : Set α) : s.encard ≤ (s \\ t).encard + t.encard :=\n  (encard_mono subset_union_left).trans_eq (encard_diff_add_encard _ _).symm\n\n"}
{"name":"Set.tsub_encard_le_encard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ LE.le (HSub.hSub s.encard t.encard) (SDiff.sdiff s t).encard","decl":"theorem tsub_encard_le_encard_diff (s t : Set α) : s.encard - t.encard ≤ (s \\ t).encard := by\n  rw [tsub_le_iff_left, add_comm]; apply encard_le_encard_diff_add_encard\n\n"}
{"name":"Set.encard_add_encard_compl","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (HAdd.hAdd s.encard (HasCompl.compl s).encard) Set.univ.encard","decl":"theorem encard_add_encard_compl (s : Set α) : s.encard + sᶜ.encard = (univ : Set α).encard := by\n  rw [← encard_union_eq disjoint_compl_right, union_compl_self]\n\n"}
{"name":"Set.encard_insert_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nx : α\n⊢ LE.le (Insert.insert x s).encard (HAdd.hAdd s.encard 1)","decl":"theorem encard_insert_le (s : Set α) (x : α) : (insert x s).encard ≤ s.encard + 1 := by\n  rw [← union_singleton, ← encard_singleton x]; apply encard_union_le\n\n"}
{"name":"Set.encard_singleton_inter","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nx : α\n⊢ LE.le (Inter.inter (Singleton.singleton x) s).encard 1","decl":"theorem encard_singleton_inter (s : Set α) (x : α) : ({x} ∩ s).encard ≤ 1 := by\n  rw [← encard_singleton x]; exact encard_le_card inter_subset_left\n\n"}
{"name":"Set.encard_diff_singleton_add_one","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s (Singleton.singleton a)).encard 1) s.encard","decl":"theorem encard_diff_singleton_add_one (h : a ∈ s) :\n    (s \\ {a}).encard + 1 = s.encard := by\n  rw [← encard_insert_of_not_mem (fun h ↦ h.2 rfl), insert_diff_singleton, insert_eq_of_mem h]\n\n"}
{"name":"Set.encard_diff_singleton_of_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\n⊢ Eq (SDiff.sdiff s (Singleton.singleton a)).encard (HSub.hSub s.encard 1)","decl":"theorem encard_diff_singleton_of_mem (h : a ∈ s) :\n    (s \\ {a}).encard = s.encard - 1 := by\n  rw [← encard_diff_singleton_add_one h, ← WithTop.add_right_cancel_iff WithTop.one_ne_top,\n    tsub_add_cancel_of_le (self_le_add_left _ _)]\n\n"}
{"name":"Set.encard_tsub_one_le_encard_diff_singleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nx : α\n⊢ LE.le (HSub.hSub s.encard 1) (SDiff.sdiff s (Singleton.singleton x)).encard","decl":"theorem encard_tsub_one_le_encard_diff_singleton (s : Set α) (x : α) :\n    s.encard - 1 ≤ (s \\ {x}).encard := by\n  rw [← encard_singleton x]; apply tsub_encard_le_encard_diff\n\n"}
{"name":"Set.encard_exchange","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na b : α\nha : Not (Membership.mem s a)\nhb : Membership.mem s b\n⊢ Eq (Insert.insert a (SDiff.sdiff s (Singleton.singleton b))).encard s.encard","decl":"theorem encard_exchange (ha : a ∉ s) (hb : b ∈ s) : (insert a (s \\ {b})).encard = s.encard := by\n  rw [encard_insert_of_not_mem, encard_diff_singleton_add_one hb]\n  simp_all only [not_true, mem_diff, mem_singleton_iff, false_and, not_false_eq_true]\n\n"}
{"name":"Set.encard_exchange'","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na b : α\nha : Not (Membership.mem s a)\nhb : Membership.mem s b\n⊢ Eq (SDiff.sdiff (Insert.insert a s) (Singleton.singleton b)).encard s.encard","decl":"theorem encard_exchange' (ha : a ∉ s) (hb : b ∈ s) : (insert a s \\ {b}).encard = s.encard := by\n  rw [← insert_diff_singleton_comm (by rintro rfl; exact ha hb), encard_exchange ha hb]\n\n"}
{"name":"Set.encard_eq_add_one_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : ENat\n⊢ Iff (Eq s.encard (HAdd.hAdd k 1)) (Exists fun a => Exists fun t => And (Not (Membership.mem t a)) (And (Eq (Insert.insert a t) s) (Eq t.encard k)))","decl":"theorem encard_eq_add_one_iff {k : ℕ∞} :\n    s.encard = k + 1 ↔ (∃ a t, ¬a ∈ t ∧ insert a t = s ∧ t.encard = k) := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · obtain ⟨a, ha⟩ := nonempty_of_encard_ne_zero (s := s) (by simp [h])\n    refine ⟨a, s \\ {a}, fun h ↦ h.2 rfl, by rwa [insert_diff_singleton, insert_eq_of_mem], ?_⟩\n    rw [← WithTop.add_right_cancel_iff WithTop.one_ne_top, ← h,\n      encard_diff_singleton_add_one ha]\n  rintro ⟨a, t, h, rfl, rfl⟩\n  rw [encard_insert_of_not_mem h]\n\n"}
{"name":"Set.eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Or (Eq s EmptyCollection.emptyCollection) (Or (Eq s.encard Top.top) (Exists fun a => And (Membership.mem s a) (LT.lt (SDiff.sdiff s (Singleton.singleton a)).encard s.encard)))","decl":"/-- Every set is either empty, infinite, or can have its `encard` reduced by a removal. Intended\n  for well-founded induction on the value of `encard`. -/\ntheorem eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt (s : Set α) :\n    s = ∅ ∨ s.encard = ⊤ ∨ ∃ a ∈ s, (s \\ {a}).encard < s.encard := by\n  refine s.eq_empty_or_nonempty.elim Or.inl (Or.inr ∘ fun ⟨a,ha⟩ ↦\n    (s.finite_or_infinite.elim (fun hfin ↦ Or.inr ⟨a, ha, ?_⟩) (Or.inl ∘ Infinite.encard_eq)))\n  rw [← encard_diff_singleton_add_one ha]; nth_rw 1 [← add_zero (encard _)]\n  exact WithTop.add_lt_add_left hfin.diff.encard_lt_top.ne zero_lt_one\n\n"}
{"name":"Set.encard_pair","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nx y : α\nhne : Ne x y\n⊢ Eq (Insert.insert x (Singleton.singleton y)).encard 2","decl":"theorem encard_pair {x y : α} (hne : x ≠ y) : ({x, y} : Set α).encard = 2 := by\n  rw [encard_insert_of_not_mem (by simpa), ← one_add_one_eq_two,\n    WithTop.add_right_cancel_iff WithTop.one_ne_top, encard_singleton]\n\n"}
{"name":"Set.encard_eq_one","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.encard 1) (Exists fun x => Eq s (Singleton.singleton x))","decl":"theorem encard_eq_one : s.encard = 1 ↔ ∃ x, s = {x} := by\n  refine ⟨fun h ↦ ?_, fun ⟨x, hx⟩ ↦ by rw [hx, encard_singleton]⟩\n  obtain ⟨x, hx⟩ := nonempty_of_encard_ne_zero (s := s) (by rw [h]; simp)\n  exact ⟨x, ((finite_singleton x).eq_of_subset_of_encard_le' (by simpa) (by simp [h])).symm⟩\n\n"}
{"name":"Set.encard_le_one_iff_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LE.le s.encard 1) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun x => Eq s (Singleton.singleton x)))","decl":"theorem encard_le_one_iff_eq : s.encard ≤ 1 ↔ s = ∅ ∨ ∃ x, s = {x} := by\n  rw [le_iff_lt_or_eq, lt_iff_not_le, ENat.one_le_iff_ne_zero, not_not, encard_eq_zero,\n    encard_eq_one]\n\n"}
{"name":"Set.encard_le_one_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LE.le s.encard 1) (∀ (a b : α), Membership.mem s a → Membership.mem s b → Eq a b)","decl":"theorem encard_le_one_iff : s.encard ≤ 1 ↔ ∀ a b, a ∈ s → b ∈ s → a = b := by\n  rw [encard_le_one_iff_eq, or_iff_not_imp_left, ← Ne, ← nonempty_iff_ne_empty]\n  refine ⟨fun h a b has hbs ↦ ?_,\n    fun h ⟨x, hx⟩ ↦ ⟨x, ((singleton_subset_iff.2 hx).antisymm' (fun y hy ↦ h _ _ hy hx))⟩⟩\n  obtain ⟨x, rfl⟩ := h ⟨_, has⟩\n  rw [(has : a = x), (hbs : b = x)]\n\n"}
{"name":"Set.one_lt_encard_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (LT.lt 1 s.encard) (Exists fun a => Exists fun b => And (Membership.mem s a) (And (Membership.mem s b) (Ne a b)))","decl":"theorem one_lt_encard_iff : 1 < s.encard ↔ ∃ a b, a ∈ s ∧ b ∈ s ∧ a ≠ b := by\n  rw [← not_iff_not, not_exists, not_lt, encard_le_one_iff]; aesop\n\n"}
{"name":"Set.exists_ne_of_one_lt_encard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nh : LT.lt 1 s.encard\na : α\n⊢ Exists fun b => And (Membership.mem s b) (Ne b a)","decl":"theorem exists_ne_of_one_lt_encard (h : 1 < s.encard) (a : α) : ∃ b ∈ s, b ≠ a := by\n  by_contra! h'\n  obtain ⟨b, b', hb, hb', hne⟩ := one_lt_encard_iff.1 h\n  apply hne\n  rw [h' b hb, h' b' hb']\n\n"}
{"name":"Set.encard_eq_two","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.encard 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq s (Insert.insert x (Singleton.singleton y))))","decl":"theorem encard_eq_two : s.encard = 2 ↔ ∃ x y, x ≠ y ∧ s = {x, y} := by\n  refine ⟨fun h ↦ ?_, fun ⟨x, y, hne, hs⟩ ↦ by rw [hs, encard_pair hne]⟩\n  obtain ⟨x, hx⟩ := nonempty_of_encard_ne_zero (s := s) (by rw [h]; simp)\n  rw [← insert_eq_of_mem hx, ← insert_diff_singleton, encard_insert_of_not_mem (fun h ↦ h.2 rfl),\n    ← one_add_one_eq_two, WithTop.add_right_cancel_iff (WithTop.one_ne_top), encard_eq_one] at h\n  obtain ⟨y, h⟩ := h\n  refine ⟨x, y, by rintro rfl; exact (h.symm.subset rfl).2 rfl, ?_⟩\n  rw [← h, insert_diff_singleton, insert_eq_of_mem hx]\n\n"}
{"name":"Set.encard_eq_three","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.encard 3) (Exists fun x => Exists fun y => Exists fun z => And (Ne x y) (And (Ne x z) (And (Ne y z) (Eq s (Insert.insert x (Insert.insert y (Singleton.singleton z)))))))","decl":"theorem encard_eq_three {α : Type u_1} {s : Set α} :\n    encard s = 3 ↔ ∃ x y z, x ≠ y ∧ x ≠ z ∧ y ≠ z ∧ s = {x, y, z} := by\n  refine ⟨fun h ↦ ?_, fun ⟨x, y, z, hxy, hyz, hxz, hs⟩ ↦ ?_⟩\n  · obtain ⟨x, hx⟩ := nonempty_of_encard_ne_zero (s := s) (by rw [h]; simp)\n    rw [← insert_eq_of_mem hx, ← insert_diff_singleton,\n      encard_insert_of_not_mem (fun h ↦ h.2 rfl), (by exact rfl : (3 : ℕ∞) = 2 + 1),\n      WithTop.add_right_cancel_iff WithTop.one_ne_top, encard_eq_two] at h\n    obtain ⟨y, z, hne, hs⟩ := h\n    refine ⟨x, y, z, ?_, ?_, hne, ?_⟩\n    · rintro rfl; exact (hs.symm.subset (Or.inl rfl)).2 rfl\n    · rintro rfl; exact (hs.symm.subset (Or.inr rfl)).2 rfl\n    rw [← hs, insert_diff_singleton, insert_eq_of_mem hx]\n  rw [hs, encard_insert_of_not_mem, encard_insert_of_not_mem, encard_singleton] <;> aesop\n\n"}
{"name":"Set.Nat.encard_range","module":"Mathlib.Data.Set.Card","initialProofState":"k : Nat\n⊢ Eq (setOf fun i => LT.lt i k).encard ↑k","decl":"theorem Nat.encard_range (k : ℕ) : {i | i < k}.encard = k := by\n  convert encard_coe_eq_coe_finsetCard (Finset.range k) using 1\n  · rw [Finset.coe_range, Iio_def]\n  rw [Finset.card_range]\n\n"}
{"name":"Set.Finite.eq_insert_of_subset_of_encard_eq_succ","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : s.Finite\nh : HasSubset.Subset s t\nhst : Eq t.encard (HAdd.hAdd s.encard 1)\n⊢ Exists fun a => Eq t (Insert.insert a s)","decl":"theorem Finite.eq_insert_of_subset_of_encard_eq_succ (hs : s.Finite) (h : s ⊆ t)\n    (hst : t.encard = s.encard + 1) : ∃ a, t = insert a s := by\n  rw [← encard_diff_add_encard_of_subset h, add_comm,\n    WithTop.add_left_cancel_iff hs.encard_lt_top.ne, encard_eq_one] at hst\n  obtain ⟨x, hx⟩ := hst; use x; rw [← diff_union_of_subset h, hx, singleton_union]\n\n"}
{"name":"Set.exists_subset_encard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : ENat\nhk : LE.le k s.encard\n⊢ Exists fun t => And (HasSubset.Subset t s) (Eq t.encard k)","decl":"theorem exists_subset_encard_eq {k : ℕ∞} (hk : k ≤ s.encard) : ∃ t, t ⊆ s ∧ t.encard = k := by\n  revert hk\n  refine ENat.nat_induction k (fun _ ↦ ⟨∅, empty_subset _, by simp⟩) (fun n IH hle ↦ ?_) ?_\n  · obtain ⟨t₀, ht₀s, ht₀⟩ := IH (le_trans (by simp) hle)\n    simp only [Nat.cast_succ] at *\n    have hne : t₀ ≠ s := by\n      rintro rfl; rw [ht₀, ← Nat.cast_one, ← Nat.cast_add, Nat.cast_le] at hle; simp at hle\n    obtain ⟨x, hx⟩ := exists_of_ssubset (ht₀s.ssubset_of_ne hne)\n    exact ⟨insert x t₀, insert_subset hx.1 ht₀s, by rw [encard_insert_of_not_mem hx.2, ht₀]⟩\n  simp only [top_le_iff, encard_eq_top_iff]\n  exact fun _ hi ↦ ⟨s, Subset.rfl, hi⟩\n\n"}
{"name":"Set.exists_superset_subset_encard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nk : ENat\nhst : HasSubset.Subset s t\nhsk : LE.le s.encard k\nhkt : LE.le k t.encard\n⊢ Exists fun r => And (HasSubset.Subset s r) (And (HasSubset.Subset r t) (Eq r.encard k))","decl":"theorem exists_superset_subset_encard_eq {k : ℕ∞}\n    (hst : s ⊆ t) (hsk : s.encard ≤ k) (hkt : k ≤ t.encard) :\n    ∃ r, s ⊆ r ∧ r ⊆ t ∧ r.encard = k := by\n  obtain (hs | hs) := eq_or_ne s.encard ⊤\n  · rw [hs, top_le_iff] at hsk; subst hsk; exact ⟨s, Subset.rfl, hst, hs⟩\n  obtain ⟨k, rfl⟩ := exists_add_of_le hsk\n  obtain ⟨k', hk'⟩ := exists_add_of_le hkt\n  have hk : k ≤ encard (t \\ s) := by\n    rw [← encard_diff_add_encard_of_subset hst, add_comm] at hkt\n    exact WithTop.le_of_add_le_add_right hs hkt\n  obtain ⟨r', hr', rfl⟩ := exists_subset_encard_eq hk\n  refine ⟨s ∪ r', subset_union_left, union_subset hst (hr'.trans diff_subset), ?_⟩\n  rw [encard_union_eq (disjoint_of_subset_right hr' disjoint_sdiff_right)]\n\n"}
{"name":"Set.InjOn.encard_image","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nh : Set.InjOn f s\n⊢ Eq (Set.image f s).encard s.encard","decl":"theorem InjOn.encard_image (h : InjOn f s) : (f '' s).encard = s.encard := by\n  rw [encard, ENat.card_image_of_injOn h, encard]\n\n"}
{"name":"Set.encard_congr","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ne : Equiv ↑s ↑t\n⊢ Eq s.encard t.encard","decl":"theorem encard_congr (e : s ≃ t) : s.encard = t.encard := by\n  rw [← encard_univ_coe, ← encard_univ_coe t, encard_univ, encard_univ, ENat.card_congr e]\n\n"}
{"name":"Function.Injective.encard_image","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\ns : Set α\n⊢ Eq (Set.image f s).encard s.encard","decl":"theorem _root_.Function.Injective.encard_image (hf : f.Injective) (s : Set α) :\n    (f '' s).encard = s.encard :=\n  hf.injOn.encard_image\n\n"}
{"name":"Function.Embedding.encard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ne : Function.Embedding ↑s ↑t\n⊢ LE.le s.encard t.encard","decl":"theorem _root_.Function.Embedding.encard_le (e : s ↪ t) : s.encard ≤ t.encard := by\n  rw [← encard_univ_coe, ← e.injective.encard_image, ← Subtype.coe_injective.encard_image]\n  exact encard_mono (by simp)\n\n"}
{"name":"Set.encard_image_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\n⊢ LE.le (Set.image f s).encard s.encard","decl":"theorem encard_image_le (f : α → β) (s : Set α) : (f '' s).encard ≤ s.encard := by\n  obtain (h | h) := isEmpty_or_nonempty α\n  · rw [s.eq_empty_of_isEmpty]; simp\n  rw [← (f.invFunOn_injOn_image s).encard_image]\n  apply encard_le_card\n  exact f.invFunOn_image_image_subset s\n\n"}
{"name":"Set.Finite.injOn_of_encard_image_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : s.Finite\nh : Eq (Set.image f s).encard s.encard\n⊢ Set.InjOn f s","decl":"theorem Finite.injOn_of_encard_image_eq (hs : s.Finite) (h : (f '' s).encard = s.encard) :\n    InjOn f s := by\n  obtain (h' | hne) := isEmpty_or_nonempty α\n  · rw [s.eq_empty_of_isEmpty]; simp\n  rw [← (f.invFunOn_injOn_image s).encard_image] at h\n  rw [injOn_iff_invFunOn_image_image_eq_self]\n  exact hs.eq_of_subset_of_encard_le (f.invFunOn_image_image_subset s) h.symm.le\n\n"}
{"name":"Set.encard_preimage_of_injective_subset_range","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : α → β\nhf : Function.Injective f\nht : HasSubset.Subset t (Set.range f)\n⊢ Eq (Set.preimage f t).encard t.encard","decl":"theorem encard_preimage_of_injective_subset_range (hf : f.Injective) (ht : t ⊆ range f) :\n    (f ⁻¹' t).encard = t.encard := by\n  rw [← hf.encard_image, image_preimage_eq_inter_range, inter_eq_self_of_subset_left ht]\n\n"}
{"name":"Set.encard_le_encard_of_injOn","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nhf : Set.MapsTo f s t\nf_inj : Set.InjOn f s\n⊢ LE.le s.encard t.encard","decl":"theorem encard_le_encard_of_injOn (hf : MapsTo f s t) (f_inj : InjOn f s) :\n    s.encard ≤ t.encard := by\n  rw [← f_inj.encard_image]; apply encard_le_card; rintro _ ⟨x, hx, rfl⟩; exact hf hx\n\n"}
{"name":"Set.Finite.exists_injOn_of_encard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nonempty β\ns : Set α\nt : Set β\nhs : s.Finite\nhle : LE.le s.encard t.encard\n⊢ Exists fun f => And (HasSubset.Subset s (Set.preimage f t)) (Set.InjOn f s)","decl":"theorem Finite.exists_injOn_of_encard_le [Nonempty β] {s : Set α} {t : Set β} (hs : s.Finite)\n    (hle : s.encard ≤ t.encard) : ∃ (f : α → β), s ⊆ f ⁻¹' t ∧ InjOn f s := by\n  classical\n  obtain (rfl | h | ⟨a, has, -⟩) := s.eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt\n  · simp\n  · exact (encard_ne_top_iff.mpr hs h).elim\n  obtain ⟨b, hbt⟩ := encard_pos.1 ((encard_pos.2 ⟨_, has⟩).trans_le hle)\n  have hle' : (s \\ {a}).encard ≤ (t \\ {b}).encard := by\n    rwa [← WithTop.add_le_add_iff_right WithTop.one_ne_top,\n    encard_diff_singleton_add_one has, encard_diff_singleton_add_one hbt]\n\n  obtain ⟨f₀, hf₀s, hinj⟩ := exists_injOn_of_encard_le hs.diff hle'\n  simp only [preimage_diff, subset_def, mem_diff, mem_singleton_iff, mem_preimage, and_imp] at hf₀s\n\n  use Function.update f₀ a b\n  rw [← insert_eq_of_mem has, ← insert_diff_singleton, injOn_insert (fun h ↦ h.2 rfl)]\n  simp only [mem_diff, mem_singleton_iff, not_true, and_false, insert_diff_singleton, subset_def,\n    mem_insert_iff, mem_preimage, ne_eq, Function.update_apply, forall_eq_or_imp, ite_true, and_imp,\n    mem_image, ite_eq_left_iff, not_exists, not_and, not_forall, exists_prop, and_iff_right hbt]\n\n  refine ⟨?_, ?_, fun x hxs hxa ↦ ⟨hxa, (hf₀s x hxs hxa).2⟩⟩\n  · rintro x hx; split_ifs with h\n    · assumption\n    · exact (hf₀s x hx h).1\n  exact InjOn.congr hinj (fun x ⟨_, hxa⟩ ↦ by rwa [Function.update_of_ne])\ntermination_by encard s\n\n"}
{"name":"Set.Finite.exists_bijOn_of_encard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝ : Nonempty β\nhs : s.Finite\nh : Eq s.encard t.encard\n⊢ Exists fun f => Set.BijOn f s t","decl":"theorem Finite.exists_bijOn_of_encard_eq [Nonempty β] (hs : s.Finite) (h : s.encard = t.encard) :\n    ∃ (f : α → β), BijOn f s t := by\n  obtain ⟨f, hf, hinj⟩ := hs.exists_injOn_of_encard_le h.le; use f\n  convert hinj.bijOn_image\n  rw [(hs.image f).eq_of_subset_of_encard_le' (image_subset_iff.mpr hf)\n    (h.symm.trans hinj.encard_image.symm).le]\n\n"}
{"name":"Set.ncard_def","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq s.ncard s.encard.toNat","decl":"theorem ncard_def (s : Set α) : s.ncard = ENat.toNat s.encard := rfl\n\n"}
{"name":"Set.Finite.cast_ncard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\n⊢ Eq (↑s.ncard) s.encard","decl":"theorem Finite.cast_ncard_eq (hs : s.Finite) : s.ncard = s.encard := by\n  rwa [ncard, ENat.coe_toNat_eq_self, ne_eq, encard_eq_top_iff, Set.Infinite, not_not]\n\n"}
{"name":"Set.Nat.card_coe_set_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (Nat.card ↑s) s.ncard","decl":"theorem Nat.card_coe_set_eq (s : Set α) : Nat.card s = s.ncard := by\n  obtain (h | h) := s.finite_or_infinite\n  · have := h.fintype\n    rw [ncard, h.encard_eq_coe_toFinset_card, Nat.card_eq_fintype_card,\n      toFinite_toFinset, toFinset_card, ENat.toNat_coe]\n  have := infinite_coe_iff.2 h\n  rw [ncard, h.encard_eq, Nat.card_eq_zero_of_infinite, ENat.toNat_top]\n\n"}
{"name":"Set.ncard_eq_toFinset_card","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Eq s.ncard (Set.Finite.toFinset hs).card","decl":"theorem ncard_eq_toFinset_card (s : Set α) (hs : s.Finite := by toFinite_tac) :\n    s.ncard = hs.toFinset.card := by\n  rw [← Nat.card_coe_set_eq, @Nat.card_eq_fintype_card _ hs.fintype,\n    @Finite.card_toFinset _ _ hs.fintype hs]\n\n"}
{"name":"Set.ncard_eq_toFinset_card'","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq s.ncard s.toFinset.card","decl":"theorem ncard_eq_toFinset_card' (s : Set α) [Fintype s] :\n    s.ncard = s.toFinset.card := by\n  simp [← Nat.card_coe_set_eq, Nat.card_eq_fintype_card]\n\n"}
{"name":"Set.cast_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\n⊢ Eq (↑s.ncard) (Cardinal.mk ↑s)","decl":"lemma cast_ncard {s : Set α} (hs : s.Finite) :\n    (s.ncard : Cardinal) = Cardinal.mk s := @Nat.cast_card _ hs\n\n"}
{"name":"Set.encard_le_coe_iff_finite_ncard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nk : Nat\n⊢ Iff (LE.le s.encard ↑k) (And s.Finite (LE.le s.ncard k))","decl":"theorem encard_le_coe_iff_finite_ncard_le {k : ℕ} : s.encard ≤ k ↔ s.Finite ∧ s.ncard ≤ k := by\n  rw [encard_le_coe_iff, and_congr_right_iff]\n  exact fun hfin ↦ ⟨fun ⟨n₀, hn₀, hle⟩ ↦ by rwa [ncard_def, hn₀, ENat.toNat_coe],\n    fun h ↦ ⟨s.ncard, by rw [hfin.cast_ncard_eq], h⟩⟩\n\n"}
{"name":"Set.Infinite.ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Infinite\n⊢ Eq s.ncard 0","decl":"theorem Infinite.ncard (hs : s.Infinite) : s.ncard = 0 := by\n  rw [← Nat.card_coe_set_eq, @Nat.card_eq_zero_of_infinite _ hs.to_subtype]\n\n"}
{"name":"Set.ncard_le_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhst : HasSubset.Subset s t\nht : autoParam t.Finite _auto✝\n⊢ LE.le s.ncard t.ncard","decl":"@[gcongr]\ntheorem ncard_le_ncard (hst : s ⊆ t) (ht : t.Finite := by toFinite_tac) :\n    s.ncard ≤ t.ncard := by\n  rw [← Nat.cast_le (α := ℕ∞), ht.cast_ncard_eq, (ht.subset hst).cast_ncard_eq]\n  exact encard_mono hst\n\n"}
{"name":"Set.ncard_mono","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ Monotone Set.ncard","decl":"theorem ncard_mono [Finite α] : @Monotone (Set α) _ _ _ ncard := fun _ _ ↦ ncard_le_ncard\n\n"}
{"name":"Set.ncard_eq_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (Eq s.ncard 0) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] theorem ncard_eq_zero (hs : s.Finite := by toFinite_tac) :\n    s.ncard = 0 ↔ s = ∅ := by\n  rw [← Nat.cast_inj (R := ℕ∞), hs.cast_ncard_eq, Nat.cast_zero, encard_eq_zero]\n\n"}
{"name":"Set.ncard_coe_Finset","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (↑s).ncard s.card","decl":"@[simp, norm_cast] theorem ncard_coe_Finset (s : Finset α) : (s : Set α).ncard = s.card := by\n  rw [ncard_eq_toFinset_card _, Finset.finite_toSet_toFinset]\n\n"}
{"name":"Set.ncard_univ","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_3\n⊢ Eq Set.univ.ncard (Nat.card α)","decl":"theorem ncard_univ (α : Type*) : (univ : Set α).ncard = Nat.card α := by\n  cases' finite_or_infinite α with h h\n  · have hft := Fintype.ofFinite α\n    rw [ncard_eq_toFinset_card, Finite.toFinset_univ, Finset.card_univ, Nat.card_eq_fintype_card]\n  rw [Nat.card_eq_zero_of_infinite, Infinite.ncard]\n  exact infinite_univ\n\n"}
{"name":"Set.ncard_empty","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_3\n⊢ Eq EmptyCollection.emptyCollection.ncard 0","decl":"@[simp] theorem ncard_empty (α : Type*) : (∅ : Set α).ncard = 0 := by\n  rw [ncard_eq_zero]\n\n"}
{"name":"Set.ncard_pos","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LT.lt 0 s.ncard) s.Nonempty","decl":"theorem ncard_pos (hs : s.Finite := by toFinite_tac) : 0 < s.ncard ↔ s.Nonempty := by\n  rw [pos_iff_ne_zero, Ne, ncard_eq_zero hs, nonempty_iff_ne_empty]\n\n"}
{"name":"Set.Nonempty.ncard_pos","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\na✝ : s.Nonempty\n⊢ LT.lt 0 s.ncard","decl":"protected alias ⟨_, Nonempty.ncard_pos⟩ := ncard_pos\n\n"}
{"name":"Set.ncard_ne_zero_of_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\nhs : autoParam s.Finite _auto✝\n⊢ Ne s.ncard 0","decl":"theorem ncard_ne_zero_of_mem {a : α} (h : a ∈ s) (hs : s.Finite := by toFinite_tac) : s.ncard ≠ 0 :=\n  ((ncard_pos hs).mpr ⟨a, h⟩).ne.symm\n\n"}
{"name":"Set.finite_of_ncard_ne_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : Ne s.ncard 0\n⊢ s.Finite","decl":"theorem finite_of_ncard_ne_zero (hs : s.ncard ≠ 0) : s.Finite :=\n  s.finite_or_infinite.elim id fun h ↦ (hs h.ncard).elim\n\n"}
{"name":"Set.finite_of_ncard_pos","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : LT.lt 0 s.ncard\n⊢ s.Finite","decl":"theorem finite_of_ncard_pos (hs : 0 < s.ncard) : s.Finite :=\n  finite_of_ncard_ne_zero hs.ne.symm\n\n"}
{"name":"Set.nonempty_of_ncard_ne_zero","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : Ne s.ncard 0\n⊢ s.Nonempty","decl":"theorem nonempty_of_ncard_ne_zero (hs : s.ncard ≠ 0) : s.Nonempty := by\n  rw [nonempty_iff_ne_empty]; rintro rfl; simp at hs\n\n"}
{"name":"Set.ncard_singleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).ncard 1","decl":"@[simp] theorem ncard_singleton (a : α) : ({a} : Set α).ncard = 1 := by\n  simp [ncard]\n\n"}
{"name":"Set.ncard_singleton_inter","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\na : α\ns : Set α\n⊢ LE.le (Inter.inter (Singleton.singleton a) s).ncard 1","decl":"theorem ncard_singleton_inter (a : α) (s : Set α) : ({a} ∩ s).ncard ≤ 1 := by\n  rw [← Nat.cast_le (α := ℕ∞), (toFinite _).cast_ncard_eq, Nat.cast_one]\n  apply encard_singleton_inter\n"}
{"name":"Set.ncard_insert_of_not_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Not (Membership.mem s a)\nhs : autoParam s.Finite _auto✝\n⊢ Eq (Insert.insert a s).ncard (HAdd.hAdd s.ncard 1)","decl":"@[simp] theorem ncard_insert_of_not_mem {a : α} (h : a ∉ s) (hs : s.Finite := by toFinite_tac) :\n    (insert a s).ncard = s.ncard + 1 := by\n  rw [← Nat.cast_inj (R := ℕ∞), (hs.insert a).cast_ncard_eq, Nat.cast_add, Nat.cast_one,\n    hs.cast_ncard_eq, encard_insert_of_not_mem h]\n\n"}
{"name":"Set.ncard_insert_of_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\n⊢ Eq (Insert.insert a s).ncard s.ncard","decl":"theorem ncard_insert_of_mem {a : α} (h : a ∈ s) : ncard (insert a s) = s.ncard := by\n  rw [insert_eq_of_mem h]\n\n"}
{"name":"Set.ncard_insert_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\na : α\ns : Set α\n⊢ LE.le (Insert.insert a s).ncard (HAdd.hAdd s.ncard 1)","decl":"theorem ncard_insert_le (a : α) (s : Set α) : (insert a s).ncard ≤ s.ncard + 1 := by\n  obtain hs | hs := s.finite_or_infinite\n  · to_encard_tac; rw [hs.cast_ncard_eq, (hs.insert _).cast_ncard_eq]; apply encard_insert_le\n  rw [(hs.mono (subset_insert a s)).ncard]\n  exact Nat.zero_le _\n\n"}
{"name":"Set.ncard_insert_eq_ite","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\ninst✝ : Decidable (Membership.mem s a)\nhs : autoParam s.Finite _auto✝\n⊢ Eq (Insert.insert a s).ncard (ite (Membership.mem s a) s.ncard (HAdd.hAdd s.ncard 1))","decl":"theorem ncard_insert_eq_ite {a : α} [Decidable (a ∈ s)] (hs : s.Finite := by toFinite_tac) :\n    ncard (insert a s) = if a ∈ s then s.ncard else s.ncard + 1 := by\n  by_cases h : a ∈ s\n  · rw [ncard_insert_of_mem h, if_pos h]\n  · rw [ncard_insert_of_not_mem h hs, if_neg h]\n\n"}
{"name":"Set.ncard_le_ncard_insert","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\na : α\ns : Set α\n⊢ LE.le s.ncard (Insert.insert a s).ncard","decl":"theorem ncard_le_ncard_insert (a : α) (s : Set α) : s.ncard ≤ (insert a s).ncard := by\n  classical\n  refine\n    s.finite_or_infinite.elim (fun h ↦ ?_) (fun h ↦ by (rw [h.ncard]; exact Nat.zero_le _))\n  rw [ncard_insert_eq_ite h]; split_ifs <;> simp\n\n"}
{"name":"Set.ncard_pair","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\na b : α\nh : Ne a b\n⊢ Eq (Insert.insert a (Singleton.singleton b)).ncard 2","decl":"@[simp] theorem ncard_pair {a b : α} (h : a ≠ b) : ({a, b} : Set α).ncard = 2 := by\n  rw [ncard_insert_of_not_mem, ncard_singleton]; simpa\n\n"}
{"name":"Set.ncard_diff_singleton_add_one","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\nhs : autoParam s.Finite _auto✝\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s (Singleton.singleton a)).ncard 1) s.ncard","decl":"@[simp] theorem ncard_diff_singleton_add_one {a : α} (h : a ∈ s)\n    (hs : s.Finite := by toFinite_tac) : (s \\ {a}).ncard + 1 = s.ncard := by\n  to_encard_tac; rw [hs.cast_ncard_eq, hs.diff.cast_ncard_eq,\n    encard_diff_singleton_add_one h]\n\n"}
{"name":"Set.ncard_diff_singleton_of_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\nhs : autoParam s.Finite _auto✝\n⊢ Eq (SDiff.sdiff s (Singleton.singleton a)).ncard (HSub.hSub s.ncard 1)","decl":"@[simp] theorem ncard_diff_singleton_of_mem {a : α} (h : a ∈ s) (hs : s.Finite := by toFinite_tac) :\n    (s \\ {a}).ncard = s.ncard - 1 :=\n  eq_tsub_of_add_eq (ncard_diff_singleton_add_one h hs)\n\n"}
{"name":"Set.ncard_diff_singleton_lt_of_mem","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nh : Membership.mem s a\nhs : autoParam s.Finite _auto✝\n⊢ LT.lt (SDiff.sdiff s (Singleton.singleton a)).ncard s.ncard","decl":"theorem ncard_diff_singleton_lt_of_mem {a : α} (h : a ∈ s) (hs : s.Finite := by toFinite_tac) :\n    (s \\ {a}).ncard < s.ncard := by\n  rw [← ncard_diff_singleton_add_one h hs]; apply lt_add_one\n\n"}
{"name":"Set.ncard_diff_singleton_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\n⊢ LE.le (SDiff.sdiff s (Singleton.singleton a)).ncard s.ncard","decl":"theorem ncard_diff_singleton_le (s : Set α) (a : α) : (s \\ {a}).ncard ≤ s.ncard := by\n  obtain hs | hs := s.finite_or_infinite\n  · apply ncard_le_ncard diff_subset hs\n  convert zero_le (α := ℕ) _\n  exact (hs.diff (by simp : Set.Finite {a})).ncard\n\n"}
{"name":"Set.pred_ncard_le_ncard_diff_singleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\n⊢ LE.le (HSub.hSub s.ncard 1) (SDiff.sdiff s (Singleton.singleton a)).ncard","decl":"theorem pred_ncard_le_ncard_diff_singleton (s : Set α) (a : α) : s.ncard - 1 ≤ (s \\ {a}).ncard := by\n  cases' s.finite_or_infinite with hs hs\n  · by_cases h : a ∈ s\n    · rw [ncard_diff_singleton_of_mem h hs]\n    rw [diff_singleton_eq_self h]\n    apply Nat.pred_le\n  convert Nat.zero_le _\n  rw [hs.ncard]\n\n"}
{"name":"Set.ncard_exchange","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na b : α\nha : Not (Membership.mem s a)\nhb : Membership.mem s b\n⊢ Eq (Insert.insert a (SDiff.sdiff s (Singleton.singleton b))).ncard s.ncard","decl":"theorem ncard_exchange {a b : α} (ha : a ∉ s) (hb : b ∈ s) : (insert a (s \\ {b})).ncard = s.ncard :=\n  congr_arg ENat.toNat <| encard_exchange ha hb\n\n"}
{"name":"Set.ncard_exchange'","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na b : α\nha : Not (Membership.mem s a)\nhb : Membership.mem s b\n⊢ Eq (SDiff.sdiff (Insert.insert a s) (Singleton.singleton b)).ncard s.ncard","decl":"theorem ncard_exchange' {a b : α} (ha : a ∉ s) (hb : b ∈ s) :\n    (insert a s \\ {b}).ncard = s.ncard := by\n  rw [← ncard_exchange ha hb, ← singleton_union, ← singleton_union, union_diff_distrib,\n    @diff_singleton_eq_self _ b {a} fun h ↦ ha (by rwa [← mem_singleton_iff.mp h])]\n\n"}
{"name":"Set.odd_card_insert_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nhs : autoParam s.Finite _auto✝\nha : Not (Membership.mem s a)\n⊢ Iff (Odd (Insert.insert a s).ncard) (Even s.ncard)","decl":"lemma odd_card_insert_iff {a : α} (hs : s.Finite := by toFinite_tac) (ha : a ∉ s) :\n    Odd (insert a s).ncard ↔ Even s.ncard := by\n  rw [ncard_insert_of_not_mem ha hs, Nat.odd_add]\n  simp only [Nat.odd_add, ← Nat.not_even_iff_odd, Nat.not_even_one, iff_false, Decidable.not_not]\n\n"}
{"name":"Set.even_card_insert_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nhs : autoParam s.Finite _auto✝\nha : Not (Membership.mem s a)\n⊢ Iff (Even (Insert.insert a s).ncard) (Odd s.ncard)","decl":"lemma even_card_insert_iff {a : α} (hs : s.Finite := by toFinite_tac) (ha : a ∉ s) :\n    Even (insert a s).ncard ↔ Odd s.ncard := by\n  rw [ncard_insert_of_not_mem ha hs, Nat.even_add_one, Nat.not_even_iff_odd]\n\n"}
{"name":"Set.ncard_image_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : autoParam s.Finite _auto✝\n⊢ LE.le (Set.image f s).ncard s.ncard","decl":"theorem ncard_image_le (hs : s.Finite := by toFinite_tac) : (f '' s).ncard ≤ s.ncard := by\n  to_encard_tac; rw [hs.cast_ncard_eq, (hs.image _).cast_ncard_eq]; apply encard_image_le\n\n"}
{"name":"Set.ncard_image_of_injOn","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nH : Set.InjOn f s\n⊢ Eq (Set.image f s).ncard s.ncard","decl":"theorem ncard_image_of_injOn (H : Set.InjOn f s) : (f '' s).ncard = s.ncard :=\n  congr_arg ENat.toNat <| H.encard_image\n\n"}
{"name":"Set.injOn_of_ncard_image_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nh : Eq (Set.image f s).ncard s.ncard\nhs : autoParam s.Finite _auto✝\n⊢ Set.InjOn f s","decl":"theorem injOn_of_ncard_image_eq (h : (f '' s).ncard = s.ncard) (hs : s.Finite := by toFinite_tac) :\n    Set.InjOn f s := by\n  rw [← Nat.cast_inj (R := ℕ∞), hs.cast_ncard_eq, (hs.image _).cast_ncard_eq] at h\n  exact hs.injOn_of_encard_image_eq h\n\n"}
{"name":"Set.ncard_image_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\nhs : autoParam s.Finite _auto✝\n⊢ Iff (Eq (Set.image f s).ncard s.ncard) (Set.InjOn f s)","decl":"theorem ncard_image_iff (hs : s.Finite := by toFinite_tac) :\n    (f '' s).ncard = s.ncard ↔ Set.InjOn f s :=\n  ⟨fun h ↦ injOn_of_ncard_image_eq h hs, ncard_image_of_injOn⟩\n\n"}
{"name":"Set.ncard_image_of_injective","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Injective f\n⊢ Eq (Set.image f s).ncard s.ncard","decl":"theorem ncard_image_of_injective (s : Set α) (H : f.Injective) : (f '' s).ncard = s.ncard :=\n  ncard_image_of_injOn fun _ _ _ _ h ↦ H h\n\n"}
{"name":"Set.ncard_preimage_of_injective_subset_range","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set β\nH : Function.Injective f\nhs : HasSubset.Subset s (Set.range f)\n⊢ Eq (Set.preimage f s).ncard s.ncard","decl":"theorem ncard_preimage_of_injective_subset_range {s : Set β} (H : f.Injective)\n    (hs : s ⊆ Set.range f) :\n    (f ⁻¹' s).ncard = s.ncard := by\n  rw [← ncard_image_of_injective _ H, image_preimage_eq_iff.mpr hs]\n\n"}
{"name":"Set.fiber_ncard_ne_zero_iff_mem_image","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\ny : β\nhs : autoParam s.Finite _auto✝\n⊢ Iff (Ne (setOf fun x => And (Membership.mem s x) (Eq (f x) y)).ncard 0) (Membership.mem (Set.image f s) y)","decl":"theorem fiber_ncard_ne_zero_iff_mem_image {y : β} (hs : s.Finite := by toFinite_tac) :\n    { x ∈ s | f x = y }.ncard ≠ 0 ↔ y ∈ f '' s := by\n  refine ⟨nonempty_of_ncard_ne_zero, ?_⟩\n  rintro ⟨z, hz, rfl⟩\n  exact @ncard_ne_zero_of_mem _ ({ x ∈ s | f x = f z }) z (mem_sep hz rfl)\n    (hs.subset (sep_subset _ _))\n\n"}
{"name":"Set.ncard_map","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : Function.Embedding α β\n⊢ Eq (Set.image (⇑f) s).ncard s.ncard","decl":"@[simp] theorem ncard_map (f : α ↪ β) : (f '' s).ncard = s.ncard :=\n  ncard_image_of_injective _ f.inj'\n\n"}
{"name":"Set.ncard_subtype","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nP : α → Prop\ns : Set α\n⊢ Eq (setOf fun x => Membership.mem s ↑x).ncard (Inter.inter s (setOf P)).ncard","decl":"@[simp] theorem ncard_subtype (P : α → Prop) (s : Set α) :\n    { x : Subtype P | (x : α) ∈ s }.ncard = (s ∩ setOf P).ncard := by\n  convert (ncard_image_of_injective _ (@Subtype.coe_injective _ P)).symm\n  ext x\n  simp [← and_assoc, exists_eq_right]\n\n"}
{"name":"Set.ncard_inter_le_ncard_left","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\n⊢ LE.le (Inter.inter s t).ncard s.ncard","decl":"theorem ncard_inter_le_ncard_left (s t : Set α) (hs : s.Finite := by toFinite_tac) :\n    (s ∩ t).ncard ≤ s.ncard :=\n  ncard_le_ncard inter_subset_left hs\n\n"}
{"name":"Set.ncard_inter_le_ncard_right","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : autoParam t.Finite _auto✝\n⊢ LE.le (Inter.inter s t).ncard t.ncard","decl":"theorem ncard_inter_le_ncard_right (s t : Set α) (ht : t.Finite := by toFinite_tac) :\n    (s ∩ t).ncard ≤ t.ncard :=\n  ncard_le_ncard inter_subset_right ht\n\n"}
{"name":"Set.eq_of_subset_of_ncard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nh' : LE.le t.ncard s.ncard\nht : autoParam t.Finite _auto✝\n⊢ Eq s t","decl":"theorem eq_of_subset_of_ncard_le (h : s ⊆ t) (h' : t.ncard ≤ s.ncard)\n    (ht : t.Finite := by toFinite_tac) : s = t :=\n  ht.eq_of_subset_of_encard_le h\n    (by rwa [← Nat.cast_le (α := ℕ∞), ht.cast_ncard_eq, (ht.subset h).cast_ncard_eq] at h')\n\n"}
{"name":"Set.subset_iff_eq_of_ncard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : LE.le t.ncard s.ncard\nht : autoParam t.Finite _auto✝\n⊢ Iff (HasSubset.Subset s t) (Eq s t)","decl":"theorem subset_iff_eq_of_ncard_le (h : t.ncard ≤ s.ncard) (ht : t.Finite := by toFinite_tac) :\n    s ⊆ t ↔ s = t :=\n  ⟨fun hst ↦ eq_of_subset_of_ncard_le hst h ht, Eq.subset'⟩\n\n"}
{"name":"Set.map_eq_of_subset","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nf : Function.Embedding α α\nh : HasSubset.Subset (Set.image (⇑f) s) s\nhs : autoParam s.Finite _auto✝\n⊢ Eq (Set.image (⇑f) s) s","decl":"theorem map_eq_of_subset {f : α ↪ α} (h : f '' s ⊆ s) (hs : s.Finite := by toFinite_tac) :\n    f '' s = s :=\n  eq_of_subset_of_ncard_le h (ncard_map _).ge hs\n\n"}
{"name":"Set.sep_of_ncard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\na : α\nP : α → Prop\nh : Eq (setOf fun x => And (Membership.mem s x) (P x)).ncard s.ncard\nha : Membership.mem s a\nhs : autoParam s.Finite _auto✝\n⊢ P a","decl":"theorem sep_of_ncard_eq {a : α} {P : α → Prop} (h : { x ∈ s | P x }.ncard = s.ncard) (ha : a ∈ s)\n    (hs : s.Finite := by toFinite_tac) : P a :=\n  sep_eq_self_iff_mem_true.mp (eq_of_subset_of_ncard_le (by simp) h.symm.le hs) _ ha\n\n"}
{"name":"Set.ncard_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSSubset.SSubset s t\nht : autoParam t.Finite _auto✝\n⊢ LT.lt s.ncard t.ncard","decl":"theorem ncard_lt_ncard (h : s ⊂ t) (ht : t.Finite := by toFinite_tac) :\n    s.ncard < t.ncard := by\n  rw [← Nat.cast_lt (α := ℕ∞), ht.cast_ncard_eq, (ht.subset h.subset).cast_ncard_eq]\n  exact ht.encard_lt_encard h\n\n"}
{"name":"Set.ncard_strictMono","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\n⊢ StrictMono Set.ncard","decl":"theorem ncard_strictMono [Finite α] : @StrictMono (Set α) _ _ _ ncard :=\n  fun _ _ h ↦ ncard_lt_ncard h\n\n"}
{"name":"Set.ncard_eq_of_bijective","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\nf : (i : Nat) → LT.lt i n → α\nhf : ∀ (a : α), Membership.mem s a → Exists fun i => Exists fun h => Eq (f i h) a\nhf' : ∀ (i : Nat) (h : LT.lt i n), Membership.mem s (f i h)\nf_inj : ∀ (i j : Nat) (hi : LT.lt i n) (hj : LT.lt j n), Eq (f i hi) (f j hj) → Eq i j\n⊢ Eq s.ncard n","decl":"theorem ncard_eq_of_bijective {n : ℕ} (f : ∀ i, i < n → α)\n    (hf : ∀ a ∈ s, ∃ i, ∃ h : i < n, f i h = a) (hf' : ∀ (i) (h : i < n), f i h ∈ s)\n    (f_inj : ∀ (i j) (hi : i < n) (hj : j < n), f i hi = f j hj → i = j) : s.ncard = n := by\n  let f' : Fin n → α := fun i ↦ f i.val i.is_lt\n  suffices himage : s = f' '' Set.univ by\n    rw [← Fintype.card_fin n, ← Nat.card_eq_fintype_card, ← Set.ncard_univ, himage]\n    exact ncard_image_of_injOn <| fun i _hi j _hj h ↦ Fin.ext <| f_inj i.val j.val i.is_lt j.is_lt h\n  ext x\n  simp only [image_univ, mem_range]\n  refine ⟨fun hx ↦ ?_, fun ⟨⟨i, hi⟩, hx⟩ ↦ hx ▸ hf' i hi⟩\n  obtain ⟨i, hi, rfl⟩ := hf x hx\n  use ⟨i, hi⟩\n\n"}
{"name":"Set.ncard_congr","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : (a : α) → Membership.mem s a → β\nh₁ : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (f a ha)\nh₂ : ∀ (a b : α) (ha : Membership.mem s a) (hb : Membership.mem s b), Eq (f a ha) (f b hb) → Eq a b\nh₃ : ∀ (b : β), Membership.mem t b → Exists fun a => Exists fun ha => Eq (f a ha) b\n⊢ Eq s.ncard t.ncard","decl":"theorem ncard_congr {t : Set β} (f : ∀ a ∈ s, β) (h₁ : ∀ a ha, f a ha ∈ t)\n    (h₂ : ∀ a b ha hb, f a ha = f b hb → a = b) (h₃ : ∀ b ∈ t, ∃ a ha, f a ha = b) :\n    s.ncard = t.ncard := by\n  set f' : s → t := fun x ↦ ⟨f x.1 x.2, h₁ _ _⟩\n  have hbij : f'.Bijective := by\n    constructor\n    · rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n      simp only [f', Subtype.mk.injEq] at hxy ⊢\n      exact h₂ _ _ hx hy hxy\n    rintro ⟨y, hy⟩\n    obtain ⟨a, ha, rfl⟩ := h₃ y hy\n    simp only [Subtype.mk.injEq, Subtype.exists]\n    exact ⟨_, ha, rfl⟩\n  simp_rw [← Nat.card_coe_set_eq]\n  exact Nat.card_congr (Equiv.ofBijective f' hbij)\n\n"}
{"name":"Set.ncard_le_ncard_of_injOn","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : α → β\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nf_inj : Set.InjOn f s\nht : autoParam t.Finite _auto✝\n⊢ LE.le s.ncard t.ncard","decl":"theorem ncard_le_ncard_of_injOn {t : Set β} (f : α → β) (hf : ∀ a ∈ s, f a ∈ t) (f_inj : InjOn f s)\n    (ht : t.Finite := by toFinite_tac) :\n    s.ncard ≤ t.ncard := by\n  have hle := encard_le_encard_of_injOn hf f_inj\n  to_encard_tac; rwa [ht.cast_ncard_eq, (ht.finite_of_encard_le hle).cast_ncard_eq]\n\n"}
{"name":"Set.exists_ne_map_eq_of_ncard_lt_of_maps_to","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nhc : LT.lt t.ncard s.ncard\nf : α → β\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : autoParam t.Finite _auto✝\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq (f x) (f y))))","decl":"theorem exists_ne_map_eq_of_ncard_lt_of_maps_to {t : Set β} (hc : t.ncard < s.ncard) {f : α → β}\n    (hf : ∀ a ∈ s, f a ∈ t) (ht : t.Finite := by toFinite_tac) :\n    ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ f x = f y := by\n  by_contra h'\n  simp only [Ne, exists_prop, not_exists, not_and, not_imp_not] at h'\n  exact (ncard_le_ncard_of_injOn f hf h' ht).not_lt hc\n\n"}
{"name":"Set.le_ncard_of_inj_on_range","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\nf : Nat → α\nhf : ∀ (i : Nat), LT.lt i n → Membership.mem s (f i)\nf_inj : ∀ (i : Nat), LT.lt i n → ∀ (j : Nat), LT.lt j n → Eq (f i) (f j) → Eq i j\nhs : autoParam s.Finite _auto✝\n⊢ LE.le n s.ncard","decl":"theorem le_ncard_of_inj_on_range {n : ℕ} (f : ℕ → α) (hf : ∀ i < n, f i ∈ s)\n    (f_inj : ∀ i < n, ∀ j < n, f i = f j → i = j) (hs : s.Finite := by toFinite_tac) :\n    n ≤ s.ncard := by\n  rw [ncard_eq_toFinset_card _ hs]\n  apply Finset.le_card_of_inj_on_range <;> simpa\n\n"}
{"name":"Set.surj_on_of_inj_on_of_ncard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : (a : α) → Membership.mem s a → β\nhf : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (f a ha)\nhinj : ∀ (a₁ a₂ : α) (ha₁ : Membership.mem s a₁) (ha₂ : Membership.mem s a₂), Eq (f a₁ ha₁) (f a₂ ha₂) → Eq a₁ a₂\nhst : LE.le t.ncard s.ncard\nht : autoParam t.Finite _auto✝\nb : β\na✝ : Membership.mem t b\n⊢ Exists fun a => Exists fun ha => Eq b (f a ha)","decl":"theorem surj_on_of_inj_on_of_ncard_le {t : Set β} (f : ∀ a ∈ s, β) (hf : ∀ a ha, f a ha ∈ t)\n    (hinj : ∀ a₁ a₂ ha₁ ha₂, f a₁ ha₁ = f a₂ ha₂ → a₁ = a₂) (hst : t.ncard ≤ s.ncard)\n    (ht : t.Finite := by toFinite_tac) :\n    ∀ b ∈ t, ∃ a ha, b = f a ha := by\n  intro b hb\n  set f' : s → t := fun x ↦ ⟨f x.1 x.2, hf _ _⟩\n  have finj : f'.Injective := by\n    rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n    simp only [f', Subtype.mk.injEq] at hxy ⊢\n    apply hinj _ _ hx hy hxy\n  have hft := ht.fintype\n  have hft' := Fintype.ofInjective f' finj\n  set f'' : ∀ a, a ∈ s.toFinset → β := fun a h ↦ f a (by simpa using h)\n  convert @Finset.surj_on_of_inj_on_of_card_le _ _ _ t.toFinset f'' _ _ _ _ (by simpa) using 1\n  · simp [f'']\n  · simp [f'', hf]\n  · intros a₁ a₂ ha₁ ha₂ h\n    rw [mem_toFinset] at ha₁ ha₂\n    exact hinj _ _ ha₁ ha₂ h\n  rwa [← ncard_eq_toFinset_card', ← ncard_eq_toFinset_card']\n\n"}
{"name":"Set.inj_on_of_surj_on_of_ncard_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : (a : α) → Membership.mem s a → β\nhf : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (f a ha)\nhsurj : ∀ (b : β), Membership.mem t b → Exists fun a => Exists fun ha => Eq (f a ha) b\nhst : LE.le s.ncard t.ncard\na₁ : α\nha₁ : Membership.mem s a₁\na₂ : α\nha₂ : Membership.mem s a₂\nha₁a₂ : Eq (f a₁ ha₁) (f a₂ ha₂)\nhs : autoParam s.Finite _auto✝\n⊢ Eq a₁ a₂","decl":"theorem inj_on_of_surj_on_of_ncard_le {t : Set β} (f : ∀ a ∈ s, β) (hf : ∀ a ha, f a ha ∈ t)\n    (hsurj : ∀ b ∈ t, ∃ a ha, f a ha = b) (hst : s.ncard ≤ t.ncard) ⦃a₁⦄ (ha₁ : a₁ ∈ s) ⦃a₂⦄\n    (ha₂ : a₂ ∈ s) (ha₁a₂ : f a₁ ha₁ = f a₂ ha₂) (hs : s.Finite := by toFinite_tac) :\n    a₁ = a₂ := by\n  classical\n  set f' : s → t := fun x ↦ ⟨f x.1 x.2, hf _ _⟩\n  have hsurj : f'.Surjective := by\n    rintro ⟨y, hy⟩\n    obtain ⟨a, ha, rfl⟩ := hsurj y hy\n    simp only [Subtype.mk.injEq, Subtype.exists]\n    exact ⟨_, ha, rfl⟩\n  haveI := hs.fintype\n  haveI := Fintype.ofSurjective _ hsurj\n  set f'' : ∀ a, a ∈ s.toFinset → β := fun a h ↦ f a (by simpa using h)\n  exact\n    @Finset.inj_on_of_surj_on_of_card_le _ _ _ t.toFinset f''\n      (fun a ha ↦ by { rw [mem_toFinset] at ha ⊢; exact hf a ha }) (by simpa)\n      (by { rwa [← ncard_eq_toFinset_card', ← ncard_eq_toFinset_card'] }) a₁\n      (by simpa) a₂ (by simpa) (by simpa)\n\n"}
{"name":"Set.ncard_graphOn","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : α → β\n⊢ Eq (Set.graphOn f s).ncard s.ncard","decl":"@[simp] lemma ncard_graphOn (s : Set α) (f : α → β) : (s.graphOn f).ncard = s.ncard := by\n  rw [← ncard_image_of_injOn fst_injOn_graph, image_fst_graphOn]\n\n"}
{"name":"Set.ncard_union_add_ncard_inter","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Eq (HAdd.hAdd (Union.union s t).ncard (Inter.inter s t).ncard) (HAdd.hAdd s.ncard t.ncard)","decl":"theorem ncard_union_add_ncard_inter (s t : Set α) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s ∪ t).ncard + (s ∩ t).ncard = s.ncard + t.ncard := by\n  to_encard_tac; rw [hs.cast_ncard_eq, ht.cast_ncard_eq, (hs.union ht).cast_ncard_eq,\n    (hs.subset inter_subset_left).cast_ncard_eq, encard_union_add_encard_inter]\n\n"}
{"name":"Set.ncard_inter_add_ncard_union","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Eq (HAdd.hAdd (Inter.inter s t).ncard (Union.union s t).ncard) (HAdd.hAdd s.ncard t.ncard)","decl":"theorem ncard_inter_add_ncard_union (s t : Set α) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s ∩ t).ncard + (s ∪ t).ncard = s.ncard + t.ncard := by\n  rw [add_comm, ncard_union_add_ncard_inter _ _ hs ht]\n\n"}
{"name":"Set.ncard_union_le","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\n⊢ LE.le (Union.union s t).ncard (HAdd.hAdd s.ncard t.ncard)","decl":"theorem ncard_union_le (s t : Set α) : (s ∪ t).ncard ≤ s.ncard + t.ncard := by\n  obtain (h | h) := (s ∪ t).finite_or_infinite\n  · to_encard_tac\n    rw [h.cast_ncard_eq, (h.subset subset_union_left).cast_ncard_eq,\n      (h.subset subset_union_right).cast_ncard_eq]\n    apply encard_union_le\n  rw [h.ncard]\n  apply zero_le\n\n"}
{"name":"Set.ncard_union_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : Disjoint s t\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Eq (Union.union s t).ncard (HAdd.hAdd s.ncard t.ncard)","decl":"theorem ncard_union_eq (h : Disjoint s t) (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : (s ∪ t).ncard = s.ncard + t.ncard := by\n  to_encard_tac\n  rw [hs.cast_ncard_eq, ht.cast_ncard_eq, (hs.union ht).cast_ncard_eq, encard_union_eq h]\n\n"}
{"name":"Set.ncard_diff_add_ncard_of_subset","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\nht : autoParam t.Finite _auto✝\n⊢ Eq (HAdd.hAdd (SDiff.sdiff t s).ncard s.ncard) t.ncard","decl":"theorem ncard_diff_add_ncard_of_subset (h : s ⊆ t) (ht : t.Finite := by toFinite_tac) :\n    (t \\ s).ncard + s.ncard = t.ncard := by\n  to_encard_tac\n  rw [ht.cast_ncard_eq, (ht.subset h).cast_ncard_eq, ht.diff.cast_ncard_eq,\n    encard_diff_add_encard_of_subset h]\n\n"}
{"name":"Set.ncard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhst : HasSubset.Subset s t\nhs : autoParam s.Finite _auto✝\n⊢ Eq (SDiff.sdiff t s).ncard (HSub.hSub t.ncard s.ncard)","decl":"theorem ncard_diff (hst : s ⊆ t) (hs : s.Finite := by toFinite_tac) :\n    (t \\ s).ncard = t.ncard - s.ncard := by\n  obtain ht | ht := t.finite_or_infinite\n  · rw [← ncard_diff_add_ncard_of_subset hst ht, add_tsub_cancel_right]\n  · rw [ht.ncard, Nat.zero_sub, (ht.diff hs).ncard]\n\n"}
{"name":"Set.cast_ncard_sdiff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nR : Type u_3\ninst✝ : AddGroupWithOne R\nhst : HasSubset.Subset s t\nht : t.Finite\n⊢ Eq (↑(SDiff.sdiff t s).ncard) (HSub.hSub ↑t.ncard ↑s.ncard)","decl":"lemma cast_ncard_sdiff {R : Type*} [AddGroupWithOne R] (hst : s ⊆ t) (ht : t.Finite) :\n    ((t \\ s).ncard : R) = t.ncard - s.ncard := by\n  rw [ncard_diff hst (ht.subset hst), Nat.cast_sub (ncard_le_ncard hst ht)]\n\n"}
{"name":"Set.ncard_le_ncard_diff_add_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : autoParam t.Finite _auto✝\n⊢ LE.le s.ncard (HAdd.hAdd (SDiff.sdiff s t).ncard t.ncard)","decl":"theorem ncard_le_ncard_diff_add_ncard (s t : Set α) (ht : t.Finite := by toFinite_tac) :\n    s.ncard ≤ (s \\ t).ncard + t.ncard := by\n  cases' s.finite_or_infinite with hs hs\n  · to_encard_tac\n    rw [ht.cast_ncard_eq, hs.cast_ncard_eq, hs.diff.cast_ncard_eq]\n    apply encard_le_encard_diff_add_encard\n  convert Nat.zero_le _\n  rw [hs.ncard]\n\n"}
{"name":"Set.le_ncard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\n⊢ LE.le (HSub.hSub t.ncard s.ncard) (SDiff.sdiff t s).ncard","decl":"theorem le_ncard_diff (s t : Set α) (hs : s.Finite := by toFinite_tac) :\n    t.ncard - s.ncard ≤ (t \\ s).ncard :=\n  tsub_le_iff_left.mpr (by rw [add_comm]; apply ncard_le_ncard_diff_add_ncard _ _ hs)\n\n"}
{"name":"Set.ncard_diff_add_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s t).ncard t.ncard) (Union.union s t).ncard","decl":"theorem ncard_diff_add_ncard (s t : Set α) (hs : s.Finite := by toFinite_tac)\n  (ht : t.Finite := by toFinite_tac) :\n    (s \\ t).ncard + t.ncard = (s ∪ t).ncard := by\n  rw [← ncard_union_eq disjoint_sdiff_left hs.diff ht, diff_union_self]\n\n"}
{"name":"Set.diff_nonempty_of_ncard_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : LT.lt s.ncard t.ncard\nhs : autoParam s.Finite _auto✝\n⊢ (SDiff.sdiff t s).Nonempty","decl":"theorem diff_nonempty_of_ncard_lt_ncard (h : s.ncard < t.ncard) (hs : s.Finite := by toFinite_tac) :\n    (t \\ s).Nonempty := by\n  rw [Set.nonempty_iff_ne_empty, Ne, diff_eq_empty]\n  exact fun h' ↦ h.not_le (ncard_le_ncard h' hs)\n\n"}
{"name":"Set.exists_mem_not_mem_of_ncard_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nh : LT.lt s.ncard t.ncard\nhs : autoParam s.Finite _auto✝\n⊢ Exists fun e => And (Membership.mem t e) (Not (Membership.mem s e))","decl":"theorem exists_mem_not_mem_of_ncard_lt_ncard (h : s.ncard < t.ncard)\n    (hs : s.Finite := by toFinite_tac) : ∃ e, e ∈ t ∧ e ∉ s :=\n  diff_nonempty_of_ncard_lt_ncard h hs\n\n"}
{"name":"Set.ncard_inter_add_ncard_diff_eq_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Eq (HAdd.hAdd (Inter.inter s t).ncard (SDiff.sdiff s t).ncard) s.ncard","decl":"@[simp] theorem ncard_inter_add_ncard_diff_eq_ncard (s t : Set α)\n    (hs : s.Finite := by toFinite_tac) : (s ∩ t).ncard + (s \\ t).ncard = s.ncard := by\n  rw [← ncard_union_eq (disjoint_of_subset_left inter_subset_right disjoint_sdiff_right)\n    (hs.inter_of_left _) hs.diff, union_comm, diff_union_inter]\n\n"}
{"name":"Set.ncard_eq_ncard_iff_ncard_diff_eq_ncard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Iff (Eq s.ncard t.ncard) (Eq (SDiff.sdiff s t).ncard (SDiff.sdiff t s).ncard)","decl":"theorem ncard_eq_ncard_iff_ncard_diff_eq_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard = t.ncard ↔ (s \\ t).ncard = (t \\ s).ncard := by\n  rw [← ncard_inter_add_ncard_diff_eq_ncard s t hs, ← ncard_inter_add_ncard_diff_eq_ncard t s ht,\n    inter_comm, add_right_inj]\n\n"}
{"name":"Set.ncard_le_ncard_iff_ncard_diff_le_ncard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Iff (LE.le s.ncard t.ncard) (LE.le (SDiff.sdiff s t).ncard (SDiff.sdiff t s).ncard)","decl":"theorem ncard_le_ncard_iff_ncard_diff_le_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard ≤ t.ncard ↔ (s \\ t).ncard ≤ (t \\ s).ncard := by\n  rw [← ncard_inter_add_ncard_diff_eq_ncard s t hs, ← ncard_inter_add_ncard_diff_eq_ncard t s ht,\n    inter_comm, add_le_add_iff_left]\n\n"}
{"name":"Set.ncard_lt_ncard_iff_ncard_diff_lt_ncard_diff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\nht : autoParam t.Finite _auto✝\n⊢ Iff (LT.lt s.ncard t.ncard) (LT.lt (SDiff.sdiff s t).ncard (SDiff.sdiff t s).ncard)","decl":"theorem ncard_lt_ncard_iff_ncard_diff_lt_ncard_diff (hs : s.Finite := by toFinite_tac)\n    (ht : t.Finite := by toFinite_tac) : s.ncard < t.ncard ↔ (s \\ t).ncard < (t \\ s).ncard := by\n  rw [← ncard_inter_add_ncard_diff_eq_ncard s t hs, ← ncard_inter_add_ncard_diff_eq_ncard t s ht,\n    inter_comm, add_lt_add_iff_left]\n\n"}
{"name":"Set.ncard_add_ncard_compl","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\nhsc : autoParam (HasCompl.compl s).Finite _auto✝\n⊢ Eq (HAdd.hAdd s.ncard (HasCompl.compl s).ncard) (Nat.card α)","decl":"theorem ncard_add_ncard_compl (s : Set α) (hs : s.Finite := by toFinite_tac)\n    (hsc : sᶜ.Finite := by toFinite_tac) : s.ncard + sᶜ.ncard = Nat.card α := by\n  rw [← ncard_univ, ← ncard_union_eq (@disjoint_compl_right _ _ s) hs hsc, union_compl_self]\n\n"}
{"name":"Set.exists_subsuperset_card_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nn : Nat\nhst : HasSubset.Subset s t\nhsn : LE.le s.ncard n\nhnt : LE.le n t.ncard\n⊢ Exists fun u => And (HasSubset.Subset s u) (And (HasSubset.Subset u t) (Eq u.ncard n))","decl":"/-- Given a subset `s` of a set `t`, of sizes at most and at least `n` respectively, there exists a\nset `u` of size `n` which is both a superset of `s` and a subset of `t`. -/\nlemma exists_subsuperset_card_eq {n : ℕ} (hst : s ⊆ t) (hsn : s.ncard ≤ n) (hnt : n ≤ t.ncard) :\n    ∃ u, s ⊆ u ∧ u ⊆ t ∧ u.ncard = n := by\n  obtain ht | ht := t.infinite_or_finite\n  · rw [ht.ncard, Nat.le_zero, ← ht.ncard] at hnt\n    exact ⟨t, hst, Subset.rfl, hnt.symm⟩\n  lift s to Finset α using ht.subset hst\n  lift t to Finset α using ht\n  obtain ⟨u, hsu, hut, hu⟩ := Finset.exists_subsuperset_card_eq (mod_cast hst) (by simpa using hsn)\n    (mod_cast hnt)\n  exact ⟨u, mod_cast hsu, mod_cast hut, mod_cast hu⟩\n\n"}
{"name":"Set.exists_subset_card_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\nhns : LE.le n s.ncard\n⊢ Exists fun t => And (HasSubset.Subset t s) (Eq t.ncard n)","decl":"/-- We can shrink a set to any smaller size. -/\nlemma exists_subset_card_eq {n : ℕ} (hns : n ≤ s.ncard) : ∃ t ⊆ s, t.ncard = n := by\n  simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns\n\n"}
{"name":"Set.Infinite.exists_subset_ncard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Infinite\nk : Nat\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (Eq t.ncard k))","decl":"theorem Infinite.exists_subset_ncard_eq {s : Set α} (hs : s.Infinite) (k : ℕ) :\n    ∃ t, t ⊆ s ∧ t.Finite ∧ t.ncard = k := by\n  have := hs.to_subtype\n  obtain ⟨t', -, rfl⟩ := @Infinite.exists_subset_card_eq s univ infinite_univ k\n  refine ⟨Subtype.val '' (t' : Set s), by simp, Finite.image _ (by simp), ?_⟩\n  rw [ncard_image_of_injective _ Subtype.coe_injective]\n  simp\n\n"}
{"name":"Set.Infinite.exists_superset_ncard_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nht : t.Infinite\nhst : HasSubset.Subset s t\nhs : s.Finite\nk : Nat\nhsk : LE.le s.ncard k\n⊢ Exists fun s' => And (HasSubset.Subset s s') (And (HasSubset.Subset s' t) (Eq s'.ncard k))","decl":"theorem Infinite.exists_superset_ncard_eq {s t : Set α} (ht : t.Infinite) (hst : s ⊆ t)\n    (hs : s.Finite) {k : ℕ} (hsk : s.ncard ≤ k) : ∃ s', s ⊆ s' ∧ s' ⊆ t ∧ s'.ncard = k := by\n  obtain ⟨s₁, hs₁, hs₁fin, hs₁card⟩ := (ht.diff hs).exists_subset_ncard_eq (k - s.ncard)\n  refine ⟨s ∪ s₁, subset_union_left, union_subset hst (hs₁.trans diff_subset), ?_⟩\n  rwa [ncard_union_eq (disjoint_of_subset_right hs₁ disjoint_sdiff_right) hs hs₁fin, hs₁card,\n    add_tsub_cancel_of_le]\n\n"}
{"name":"Set.exists_subset_or_subset_of_two_mul_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nn : Nat\nhst : LT.lt (HMul.hMul 2 n) (Union.union s t).ncard\n⊢ Exists fun r => And (LT.lt n r.ncard) (Or (HasSubset.Subset r s) (HasSubset.Subset r t))","decl":"theorem exists_subset_or_subset_of_two_mul_lt_ncard {n : ℕ} (hst : 2 * n < (s ∪ t).ncard) :\n    ∃ r : Set α, n < r.ncard ∧ (r ⊆ s ∨ r ⊆ t) := by\n  classical\n  have hu := finite_of_ncard_ne_zero ((Nat.zero_le _).trans_lt hst).ne.symm\n  rw [ncard_eq_toFinset_card _ hu,\n    Finite.toFinset_union (hu.subset subset_union_left)\n      (hu.subset subset_union_right)] at hst\n  obtain ⟨r', hnr', hr'⟩ := Finset.exists_subset_or_subset_of_two_mul_lt_card hst\n  exact ⟨r', by simpa, by simpa using hr'⟩\n\n"}
{"name":"Set.ncard_eq_one","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.ncard 1) (Exists fun a => Eq s (Singleton.singleton a))","decl":"@[simp] theorem ncard_eq_one : s.ncard = 1 ↔ ∃ a, s = {a} := by\n  refine ⟨fun h ↦ ?_, by rintro ⟨a, rfl⟩; rw [ncard_singleton]⟩\n  have hft := (finite_of_ncard_ne_zero (ne_zero_of_eq_one h)).fintype\n  simp_rw [ncard_eq_toFinset_card', @Finset.card_eq_one _ (toFinset s)] at h\n  refine h.imp fun a ha ↦ ?_\n  simp_rw [Set.ext_iff, mem_singleton_iff]\n  simp only [Finset.ext_iff, mem_toFinset, Finset.mem_singleton] at ha\n  exact ha\n\n"}
{"name":"Set.exists_eq_insert_iff_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns t : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)) (And (HasSubset.Subset s t) (Eq (HAdd.hAdd s.ncard 1) t.ncard))","decl":"theorem exists_eq_insert_iff_ncard (hs : s.Finite := by toFinite_tac) :\n    (∃ a ∉ s, insert a s = t) ↔ s ⊆ t ∧ s.ncard + 1 = t.ncard := by\n  classical\n  cases' t.finite_or_infinite with ht ht\n  · rw [ncard_eq_toFinset_card _ hs, ncard_eq_toFinset_card _ ht,\n      ← @Finite.toFinset_subset_toFinset _ _ _ hs ht, ← Finset.exists_eq_insert_iff]\n    convert Iff.rfl using 2; simp only [Finite.mem_toFinset]\n    ext x\n    simp [Finset.ext_iff, Set.ext_iff]\n  simp only [ht.ncard, exists_prop, add_eq_zero, and_false, iff_false, not_exists, not_and,\n    reduceCtorEq]\n  rintro x - rfl\n  exact ht (hs.insert x)\n\n"}
{"name":"Set.ncard_le_one","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LE.le s.ncard 1) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → Eq a b)","decl":"theorem ncard_le_one (hs : s.Finite := by toFinite_tac) :\n    s.ncard ≤ 1 ↔ ∀ a ∈ s, ∀ b ∈ s, a = b := by\n  simp_rw [ncard_eq_toFinset_card _ hs, Finset.card_le_one, Finite.mem_toFinset]\n\n"}
{"name":"Set.ncard_le_one_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LE.le s.ncard 1) (∀ {a b : α}, Membership.mem s a → Membership.mem s b → Eq a b)","decl":"theorem ncard_le_one_iff (hs : s.Finite := by toFinite_tac) :\n    s.ncard ≤ 1 ↔ ∀ {a b}, a ∈ s → b ∈ s → a = b := by\n  rw [ncard_le_one hs]\n  tauto\n\n"}
{"name":"Set.ncard_le_one_iff_eq","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LE.le s.ncard 1) (Or (Eq s EmptyCollection.emptyCollection) (Exists fun a => Eq s (Singleton.singleton a)))","decl":"theorem ncard_le_one_iff_eq (hs : s.Finite := by toFinite_tac) :\n    s.ncard ≤ 1 ↔ s = ∅ ∨ ∃ a, s = {a} := by\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · exact iff_of_true (by simp) (Or.inl rfl)\n  rw [ncard_le_one_iff hs]\n  refine ⟨fun h ↦ Or.inr ⟨x, (singleton_subset_iff.mpr hx).antisymm' fun y hy ↦ h hy hx⟩, ?_⟩\n  rintro (rfl | ⟨a, rfl⟩)\n  · exact (not_mem_empty _ hx).elim\n  simp_rw [mem_singleton_iff] at hx ⊢; subst hx\n  simp only [forall_eq_apply_imp_iff, imp_self, implies_true]\n\n"}
{"name":"Set.ncard_le_one_iff_subset_singleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Nonempty α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LE.le s.ncard 1) (Exists fun x => HasSubset.Subset s (Singleton.singleton x))","decl":"theorem ncard_le_one_iff_subset_singleton [Nonempty α]\n    (hs : s.Finite := by toFinite_tac) :\n    s.ncard ≤ 1 ↔ ∃ x : α, s ⊆ {x} := by\n  simp_rw [ncard_eq_toFinset_card _ hs, Finset.card_le_one_iff_subset_singleton,\n    Finite.toFinset_subset, Finset.coe_singleton]\n\n"}
{"name":"Set.ncard_le_one_of_subsingleton","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\ns : Set α\n⊢ LE.le s.ncard 1","decl":"/-- A `Set` of a subsingleton type has cardinality at most one. -/\ntheorem ncard_le_one_of_subsingleton [Subsingleton α] (s : Set α) : s.ncard ≤ 1 := by\n  rw [ncard_eq_toFinset_card]\n  exact Finset.card_le_one_of_subsingleton _\n\n"}
{"name":"Set.one_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LT.lt 1 s.ncard) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Ne a b)))","decl":"theorem one_lt_ncard (hs : s.Finite := by toFinite_tac) :\n    1 < s.ncard ↔ ∃ a ∈ s, ∃ b ∈ s, a ≠ b := by\n  simp_rw [ncard_eq_toFinset_card _ hs, Finset.one_lt_card, Finite.mem_toFinset]\n\n"}
{"name":"Set.one_lt_ncard_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LT.lt 1 s.ncard) (Exists fun a => Exists fun b => And (Membership.mem s a) (And (Membership.mem s b) (Ne a b)))","decl":"theorem one_lt_ncard_iff (hs : s.Finite := by toFinite_tac) :\n    1 < s.ncard ↔ ∃ a b, a ∈ s ∧ b ∈ s ∧ a ≠ b := by\n  rw [one_lt_ncard hs]\n  simp only [exists_prop, exists_and_left]\n\n"}
{"name":"Set.one_lt_ncard_of_nonempty_of_even","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : s.Finite\nhn : autoParam s.Nonempty _auto✝\nhe : Even s.ncard\n⊢ LT.lt 1 s.ncard","decl":"lemma one_lt_ncard_of_nonempty_of_even (hs : Set.Finite s) (hn : Set.Nonempty s := by toFinite_tac)\n    (he : Even (s.ncard)) : 1 < s.ncard := by\n  rw [← Set.ncard_pos hs] at hn\n  have : s.ncard ≠ 1 := fun h ↦ by simp [h] at he\n  omega\n\n"}
{"name":"Set.two_lt_ncard_iff","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LT.lt 2 s.ncard) (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem s a) (And (Membership.mem s b) (And (Membership.mem s c) (And (Ne a b) (And (Ne a c) (Ne b c))))))","decl":"theorem two_lt_ncard_iff (hs : s.Finite := by toFinite_tac) :\n    2 < s.ncard ↔ ∃ a b c, a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  simp_rw [ncard_eq_toFinset_card _ hs, Finset.two_lt_card_iff, Finite.mem_toFinset]\n\n"}
{"name":"Set.two_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : autoParam s.Finite _auto✝\n⊢ Iff (LT.lt 2 s.ncard) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem s c) (And (Ne a b) (And (Ne a c) (Ne b c))))))","decl":"theorem two_lt_ncard (hs : s.Finite := by toFinite_tac) :\n    2 < s.ncard ↔ ∃ a ∈ s, ∃ b ∈ s, ∃ c ∈ s, a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  simp only [two_lt_ncard_iff hs, exists_and_left, exists_prop]\n\n"}
{"name":"Set.exists_ne_of_one_lt_ncard","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : LT.lt 1 s.ncard\na : α\n⊢ Exists fun b => And (Membership.mem s b) (Ne b a)","decl":"theorem exists_ne_of_one_lt_ncard (hs : 1 < s.ncard) (a : α) : ∃ b, b ∈ s ∧ b ≠ a := by\n  have hsf := finite_of_ncard_ne_zero (zero_lt_one.trans hs).ne.symm\n  rw [ncard_eq_toFinset_card _ hsf] at hs\n  simpa only [Finite.mem_toFinset] using Finset.exists_ne_of_one_lt_card hs a\n\n"}
{"name":"Set.eq_insert_of_ncard_eq_succ","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\nh : Eq s.ncard (HAdd.hAdd n 1)\n⊢ Exists fun a => Exists fun t => And (Not (Membership.mem t a)) (And (Eq (Insert.insert a t) s) (Eq t.ncard n))","decl":"theorem eq_insert_of_ncard_eq_succ {n : ℕ} (h : s.ncard = n + 1) :\n    ∃ a t, a ∉ t ∧ insert a t = s ∧ t.ncard = n := by\n  classical\n  have hsf := finite_of_ncard_pos (n.zero_lt_succ.trans_eq h.symm)\n  rw [ncard_eq_toFinset_card _ hsf, Finset.card_eq_succ] at h\n  obtain ⟨a, t, hat, hts, rfl⟩ := h\n  simp only [Finset.ext_iff, Finset.mem_insert, Finite.mem_toFinset] at hts\n  refine ⟨a, t, hat, ?_, ?_⟩\n  · simp [Set.ext_iff, hts]\n  · simp\n\n"}
{"name":"Set.ncard_eq_succ","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\nn : Nat\nhs : autoParam s.Finite _auto✝\n⊢ Iff (Eq s.ncard (HAdd.hAdd n 1)) (Exists fun a => Exists fun t => And (Not (Membership.mem t a)) (And (Eq (Insert.insert a t) s) (Eq t.ncard n)))","decl":"theorem ncard_eq_succ {n : ℕ} (hs : s.Finite := by toFinite_tac) :\n    s.ncard = n + 1 ↔ ∃ a t, a ∉ t ∧ insert a t = s ∧ t.ncard = n := by\n  refine ⟨eq_insert_of_ncard_eq_succ, ?_⟩\n  rintro ⟨a, t, hat, h, rfl⟩\n  rw [← h, ncard_insert_of_not_mem hat (hs.subset ((subset_insert a t).trans_eq h))]\n\n"}
{"name":"Set.ncard_eq_two","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.ncard 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq s (Insert.insert x (Singleton.singleton y))))","decl":"theorem ncard_eq_two : s.ncard = 2 ↔ ∃ x y, x ≠ y ∧ s = {x, y} := by\n  rw [← encard_eq_two, ncard_def, ← Nat.cast_inj (R := ℕ∞), Nat.cast_ofNat]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rwa [ENat.coe_toNat] at h; rintro h'; simp [h'] at h\n  simp [h]\n\n"}
{"name":"Set.ncard_eq_three","module":"Mathlib.Data.Set.Card","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (Eq s.ncard 3) (Exists fun x => Exists fun y => Exists fun z => And (Ne x y) (And (Ne x z) (And (Ne y z) (Eq s (Insert.insert x (Insert.insert y (Singleton.singleton z)))))))","decl":"theorem ncard_eq_three : s.ncard = 3 ↔ ∃ x y z, x ≠ y ∧ x ≠ z ∧ y ≠ z ∧ s = {x, y, z} := by\n  rw [← encard_eq_three, ncard_def, ← Nat.cast_inj (R := ℕ∞), Nat.cast_ofNat]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rwa [ENat.coe_toNat] at h; rintro h'; simp [h'] at h\n  simp [h]\n\n"}
