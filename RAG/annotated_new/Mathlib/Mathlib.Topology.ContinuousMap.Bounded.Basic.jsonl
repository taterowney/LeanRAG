{"name":"BoundedContinuousFunction.mk.sizeOf_spec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : SizeOf Î±\ninstâœ : SizeOf Î²\ntoContinuousMap : ContinuousMap Î± Î²\nmap_bounded' : Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\nâŠ¢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap)) (SizeOf.sizeOf map_bounded'))","decl":"/-- `Î± â†’áµ‡ Î²` is the type of bounded continuous functions `Î± â†’ Î²` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : Î± â†’áµ‡ Î²)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (Î± : Type u) (Î² : Type v) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] extends ContinuousMap Î± Î² : Type max u v where\n  map_bounded' : âˆƒ C, âˆ€ x y, dist (toFun x) (toFun y) â‰¤ C\n\n"}
{"name":"BoundedContinuousFunction.map_bounded'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nself : BoundedContinuousFunction Î± Î²\nâŠ¢ Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (self.toFun x) (self.toFun y)) C","decl":"/-- `Î± â†’áµ‡ Î²` is the type of bounded continuous functions `Î± â†’ Î²` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : Î± â†’áµ‡ Î²)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (Î± : Type u) (Î² : Type v) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] extends ContinuousMap Î± Î² : Type max u v where\n  map_bounded' : âˆƒ C, âˆ€ x y, dist (toFun x) (toFun y) â‰¤ C\n\n"}
{"name":"BoundedContinuousFunction.mk.injEq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\ntoContinuousMapâœ : ContinuousMap Î± Î²\nmap_bounded'âœ : Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (toContinuousMapâœ.toFun x) (toContinuousMapâœ.toFun y)) C\ntoContinuousMap : ContinuousMap Î± Î²\nmap_bounded' : Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\nâŠ¢ Eq (Eq { toContinuousMap := toContinuousMapâœ, map_bounded' := map_bounded'âœ } { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }) (Eq toContinuousMapâœ toContinuousMap)","decl":"/-- `Î± â†’áµ‡ Î²` is the type of bounded continuous functions `Î± â†’ Î²` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : Î± â†’áµ‡ Î²)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (Î± : Type u) (Î² : Type v) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] extends ContinuousMap Î± Î² : Type max u v where\n  map_bounded' : âˆƒ C, âˆ€ x y, dist (toFun x) (toFun y) â‰¤ C\n\n"}
{"name":"BoundedContinuousFunction.mk.inj","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\ntoContinuousMapâœ : ContinuousMap Î± Î²\nmap_bounded'âœ : Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (toContinuousMapâœ.toFun x) (toContinuousMapâœ.toFun y)) C\ntoContinuousMap : ContinuousMap Î± Î²\nmap_bounded' : Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\nxâœ : Eq { toContinuousMap := toContinuousMapâœ, map_bounded' := map_bounded'âœ } { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }\nâŠ¢ Eq toContinuousMapâœ toContinuousMap","decl":"/-- `Î± â†’áµ‡ Î²` is the type of bounded continuous functions `Î± â†’ Î²` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : Î± â†’áµ‡ Î²)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F Î± Î²] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (Î± : Type u) (Î² : Type v) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] extends ContinuousMap Î± Î² : Type max u v where\n  map_bounded' : âˆƒ C, âˆ€ x y, dist (toFun x) (toFun y) â‰¤ C\n\n"}
{"name":"BoundedContinuousMapClass.toContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"F : Type u_2\nÎ± : outParam (Type u_3)\nÎ² : outParam (Type u_4)\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : FunLike F Î± Î²\nself : BoundedContinuousMapClass F Î± Î²\nâŠ¢ ContinuousMapClass F Î± Î²","decl":"/-- `BoundedContinuousMapClass F Î± Î²` states that `F` is a type of bounded continuous maps.\n\nYou should also extend this typeclass when you extend `BoundedContinuousFunction`. -/\nclass BoundedContinuousMapClass (F : Type*) (Î± Î² : outParam Type*) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] [FunLike F Î± Î²] extends ContinuousMapClass F Î± Î² : Prop where\n  map_bounded (f : F) : âˆƒ C, âˆ€ x y, dist (f x) (f y) â‰¤ C\n\n"}
{"name":"BoundedContinuousMapClass.map_bounded","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"F : Type u_2\nÎ± : outParam (Type u_3)\nÎ² : outParam (Type u_4)\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : FunLike F Î± Î²\nself : BoundedContinuousMapClass F Î± Î²\nf : F\nâŠ¢ Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (f x) (f y)) C","decl":"/-- `BoundedContinuousMapClass F Î± Î²` states that `F` is a type of bounded continuous maps.\n\nYou should also extend this typeclass when you extend `BoundedContinuousFunction`. -/\nclass BoundedContinuousMapClass (F : Type*) (Î± Î² : outParam Type*) [TopologicalSpace Î±]\n    [PseudoMetricSpace Î²] [FunLike F Î± Î²] extends ContinuousMapClass F Î± Î² : Prop where\n  map_bounded (f : F) : âˆƒ C, âˆ€ x y, dist (f x) (f y) â‰¤ C\n\n"}
{"name":"BoundedContinuousFunction.instBoundedContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ BoundedContinuousMapClass (BoundedContinuousFunction Î± Î²) Î± Î²","decl":"instance instBoundedContinuousMapClass : BoundedContinuousMapClass (Î± â†’áµ‡ Î²) Î± Î² where\n  map_continuous f := f.continuous_toFun\n  map_bounded f := f.map_bounded'\n\n"}
{"name":"BoundedContinuousFunction.coe_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq â‡‘f.toContinuousMap â‡‘f","decl":"@[simp]\ntheorem coe_toContinuousMap (f : Î± â†’áµ‡ Î²) : (f.toContinuousMap : Î± â†’ Î²) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_to_continuous_fun","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq â‡‘f.toContinuousMap â‡‘f","decl":"@[deprecated (since := \"2024-11-23\")] alias coe_to_continuous_fun := coe_toContinuousMap\n\n"}
{"name":"BoundedContinuousFunction.bounded","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Exists fun C => âˆ€ (x y : Î±), LE.le (Dist.dist (f x) (f y)) C","decl":"protected theorem bounded (f : Î± â†’áµ‡ Î²) : âˆƒ C, âˆ€ x y : Î±, dist (f x) (f y) â‰¤ C :=\n  f.map_bounded'\n\n"}
{"name":"BoundedContinuousFunction.continuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Continuous â‡‘f","decl":"protected theorem continuous (f : Î± â†’áµ‡ Î²) : Continuous f :=\n  f.toContinuousMap.continuous\n\n"}
{"name":"BoundedContinuousFunction.ext_iff","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Iff (Eq f g) (âˆ€ (x : Î±), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext (h : âˆ€ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"BoundedContinuousFunction.ext","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nh : âˆ€ (x : Î±), Eq (f x) (g x)\nâŠ¢ Eq f g","decl":"@[ext]\ntheorem ext (h : âˆ€ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"BoundedContinuousFunction.isBounded_range","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Bornology.IsBounded (Set.range â‡‘f)","decl":"theorem isBounded_range (f : Î± â†’áµ‡ Î²) : IsBounded (range f) :=\n  isBounded_range_iff.2 f.bounded\n\n"}
{"name":"BoundedContinuousFunction.isBounded_image","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\ns : Set Î±\nâŠ¢ Bornology.IsBounded (Set.image (â‡‘f) s)","decl":"theorem isBounded_image (f : Î± â†’áµ‡ Î²) (s : Set Î±) : IsBounded (f '' s) :=\n  f.isBounded_range.subset <| image_subset_range _ _\n\n"}
{"name":"BoundedContinuousFunction.eq_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nh : IsEmpty Î±\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq f g","decl":"theorem eq_of_empty [h : IsEmpty Î±] (f g : Î± â†’áµ‡ Î²) : f = g :=\n  ext <| h.elim\n\n"}
{"name":"BoundedContinuousFunction.mkOfBound_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : ContinuousMap Î± Î²\nC : Real\nh : âˆ€ (x y : Î±), LE.le (Dist.dist (f x) (f y)) C\nâŠ¢ Eq â‡‘(BoundedContinuousFunction.mkOfBound f C h) â‡‘f","decl":"@[simp]\ntheorem mkOfBound_coe {f} {C} {h} : (mkOfBound f C h : Î± â†’ Î²) = (f : Î± â†’ Î²) := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : CompactSpace Î±\nf : ContinuousMap Î± Î²\na : Î±\nâŠ¢ Eq ((BoundedContinuousFunction.mkOfCompact f) a) (f a)","decl":"@[simp]\ntheorem mkOfCompact_apply [CompactSpace Î±] (f : C(Î±, Î²)) (a : Î±) : mkOfCompact f a = f a := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfDiscrete_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : DiscreteTopology Î±\nf : Î± â†’ Î²\nC : Real\nh : âˆ€ (x y : Î±), LE.le (Dist.dist (f x) (f y)) C\naâœ : Î±\nâŠ¢ Eq ((BoundedContinuousFunction.mkOfDiscrete f C h) aâœ) (f aâœ)","decl":"/-- If a function is bounded on a discrete space, it is automatically continuous,\nand therefore gives rise to an element of the type of bounded continuous functions. -/\n@[simps]\ndef mkOfDiscrete [DiscreteTopology Î±] (f : Î± â†’ Î²) (C : â„) (h : âˆ€ x y : Î±, dist (f x) (f y) â‰¤ C) :\n    Î± â†’áµ‡ Î² :=\n  âŸ¨âŸ¨f, continuous_of_discreteTopologyâŸ©, âŸ¨C, hâŸ©âŸ©\n\n"}
{"name":"BoundedContinuousFunction.dist_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Dist.dist f g) (InfSet.sInf (setOf fun C => And (LE.le 0 C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)))","decl":"theorem dist_eq : dist f g = sInf { C | 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C } := rfl\n\n"}
{"name":"BoundedContinuousFunction.dist_set_exists","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Exists fun C => And (LE.le 0 C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_set_exists : âˆƒ C, 0 â‰¤ C âˆ§ âˆ€ x : Î±, dist (f x) (g x) â‰¤ C := by\n  rcases isBounded_iff.1 (f.isBounded_range.union g.isBounded_range) with âŸ¨C, hCâŸ©\n  refine âŸ¨max 0 C, le_max_left _ _, fun x => (hC ?_ ?_).trans (le_max_right _ _)âŸ©\n    <;> [left; right]\n    <;> apply mem_range_self\n\n"}
{"name":"BoundedContinuousFunction.dist_coe_le_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ LE.le (Dist.dist (f x) (g x)) (Dist.dist f g)","decl":"/-- The pointwise distance is controlled by the distance between functions, by definition. -/\ntheorem dist_coe_le_dist (x : Î±) : dist (f x) (g x) â‰¤ dist f g :=\n  le_csInf dist_set_exists fun _ hb => hb.2 x\n\n/- This lemma will be needed in the proof of the metric space instance, but it will become\nuseless afterwards as it will be superseded by the general result that the distance is nonnegative\nin metric spaces. -/\n"}
{"name":"BoundedContinuousFunction.dist_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nC : Real\nC0 : LE.le 0 C\nâŠ¢ Iff (LE.le (Dist.dist f g) C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)","decl":"/-- The distance between two functions is controlled by the supremum of the pointwise distances. -/\ntheorem dist_le (C0 : (0 : â„) â‰¤ C) : dist f g â‰¤ C â†” âˆ€ x : Î±, dist (f x) (g x) â‰¤ C :=\n  âŸ¨fun h x => le_trans (dist_coe_le_dist x) h, fun H => csInf_le âŸ¨0, fun _ => And.leftâŸ© âŸ¨C0, HâŸ©âŸ©\n\n"}
{"name":"BoundedContinuousFunction.dist_le_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nC : Real\ninstâœ : Nonempty Î±\nâŠ¢ Iff (LE.le (Dist.dist f g) C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_le_iff_of_nonempty [Nonempty Î±] : dist f g â‰¤ C â†” âˆ€ x, dist (f x) (g x) â‰¤ C :=\n  âŸ¨fun h x => le_trans (dist_coe_le_dist x) h,\n    fun w => (dist_le (le_trans dist_nonneg (w (Nonempty.some â€¹_â€º)))).mpr wâŸ©\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nC : Real\ninstâœÂ¹ : Nonempty Î±\ninstâœ : CompactSpace Î±\nw : âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C\nâŠ¢ LT.lt (Dist.dist f g) C","decl":"theorem dist_lt_of_nonempty_compact [Nonempty Î±] [CompactSpace Î±]\n    (w : âˆ€ x : Î±, dist (f x) (g x) < C) : dist f g < C := by\n  have c : Continuous fun x => dist (f x) (g x) := by continuity\n  obtain âŸ¨x, -, leâŸ© :=\n    IsCompact.exists_isMaxOn isCompact_univ Set.univ_nonempty (Continuous.continuousOn c)\n  exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr fun y => le trivial) (w x)\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_iff_of_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nC : Real\ninstâœ : CompactSpace Î±\nC0 : LT.lt 0 C\nâŠ¢ Iff (LT.lt (Dist.dist f g) C) (âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_compact [CompactSpace Î±] (C0 : (0 : â„) < C) :\n    dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C := by\n  fconstructor\n  Â· intro w x\n    exact lt_of_le_of_lt (dist_coe_le_dist x) w\n  Â· by_cases h : Nonempty Î±\n    Â· exact dist_lt_of_nonempty_compact\n    Â· rintro -\n      convert C0\n      apply le_antisymm _ dist_nonneg'\n      rw [dist_eq]\n      exact csInf_le âŸ¨0, fun C => And.leftâŸ© âŸ¨le_rfl, fun x => False.elim (h (Nonempty.intro x))âŸ©\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_iff_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nC : Real\ninstâœÂ¹ : Nonempty Î±\ninstâœ : CompactSpace Î±\nâŠ¢ Iff (LT.lt (Dist.dist f g) C) (âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_nonempty_compact [Nonempty Î±] [CompactSpace Î±] :\n    dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C :=\n  âŸ¨fun w x => lt_of_le_of_lt (dist_coe_le_dist x) w, dist_lt_of_nonempty_compactâŸ©\n\n"}
{"name":"BoundedContinuousFunction.nndist_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (NNDist.nndist f g) (InfSet.sInf (setOf fun C => âˆ€ (x : Î±), LE.le (NNDist.nndist (f x) (g x)) C))","decl":"theorem nndist_eq : nndist f g = sInf { C | âˆ€ x : Î±, nndist (f x) (g x) â‰¤ C } :=\n  Subtype.ext <| dist_eq.trans <| by\n    rw [val_eq_coe, coe_sInf, coe_image]\n    simp_rw [mem_setOf_eq, â† NNReal.coe_le_coe, coe_mk, exists_prop, coe_nndist]\n\n"}
{"name":"BoundedContinuousFunction.nndist_set_exists","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Exists fun C => âˆ€ (x : Î±), LE.le (NNDist.nndist (f x) (g x)) C","decl":"theorem nndist_set_exists : âˆƒ C, âˆ€ x : Î±, nndist (f x) (g x) â‰¤ C :=\n  Subtype.exists.mpr <| dist_set_exists.imp fun _ âŸ¨ha, hâŸ© => âŸ¨ha, hâŸ©\n\n"}
{"name":"BoundedContinuousFunction.nndist_coe_le_nndist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ LE.le (NNDist.nndist (f x) (g x)) (NNDist.nndist f g)","decl":"theorem nndist_coe_le_nndist (x : Î±) : nndist (f x) (g x) â‰¤ nndist f g :=\n  dist_coe_le_dist x\n\n"}
{"name":"BoundedContinuousFunction.dist_zero_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\ninstâœ : IsEmpty Î±\nâŠ¢ Eq (Dist.dist f g) 0","decl":"/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem dist_zero_of_empty [IsEmpty Î±] : dist f g = 0 := by\n  rw [(ext isEmptyElim : f = g), dist_self]\n\n"}
{"name":"BoundedContinuousFunction.dist_eq_iSup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Dist.dist f g) (iSup fun x => Dist.dist (f x) (g x))","decl":"theorem dist_eq_iSup : dist f g = â¨† x : Î±, dist (f x) (g x) := by\n  cases isEmpty_or_nonempty Î±\n  Â· rw [iSup_of_empty', Real.sSup_empty, dist_zero_of_empty]\n  refine (dist_le_iff_of_nonempty.mpr <| le_ciSup ?_).antisymm (ciSup_le dist_coe_le_dist)\n  exact dist_set_exists.imp fun C hC => forall_mem_range.2 hC.2\n\n"}
{"name":"BoundedContinuousFunction.nndist_eq_iSup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (NNDist.nndist f g) (iSup fun x => NNDist.nndist (f x) (g x))","decl":"theorem nndist_eq_iSup : nndist f g = â¨† x : Î±, nndist (f x) (g x) :=\n  Subtype.ext <| dist_eq_iSup.trans <| by simp_rw [val_eq_coe, coe_iSup, coe_nndist]\n\n"}
{"name":"BoundedContinuousFunction.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nÎ¹ : Type u_2\nF : Î¹ â†’ BoundedContinuousFunction Î± Î²\nf : BoundedContinuousFunction Î± Î²\nl : Filter Î¹\nâŠ¢ Iff (Filter.Tendsto F l (nhds f)) (TendstoUniformly (fun i => â‡‘(F i)) (â‡‘f) l)","decl":"theorem tendsto_iff_tendstoUniformly {Î¹ : Type*} {F : Î¹ â†’ Î± â†’áµ‡ Î²} {f : Î± â†’áµ‡ Î²} {l : Filter Î¹} :\n    Tendsto F l (ğ“ f) â†” TendstoUniformly (fun i => F i) f l :=\n  Iff.intro\n    (fun h =>\n      tendstoUniformly_iff.2 fun Îµ Îµ0 =>\n        (Metric.tendsto_nhds.mp h Îµ Îµ0).mp\n          (Eventually.of_forall fun n hn x =>\n            lt_of_le_of_lt (dist_coe_le_dist x) (dist_comm (F n) f â–¸ hn)))\n    fun h =>\n    Metric.tendsto_nhds.mpr fun _ Îµ_pos =>\n      (h _ (dist_mem_uniformity <| half_pos Îµ_pos)).mp\n        (Eventually.of_forall fun n hn =>\n          lt_of_le_of_lt\n            ((dist_le (half_pos Îµ_pos).le).mpr fun x => dist_comm (f x) (F n x) â–¸ le_of_lt (hn x))\n            (half_lt_self Îµ_pos))\n\n"}
{"name":"BoundedContinuousFunction.isInducing_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Topology.IsInducing (Function.comp (â‡‘UniformFun.ofFun) DFunLike.coe)","decl":"/-- The topology on `Î± â†’áµ‡ Î²` is exactly the topology induced by the natural map to `Î± â†’áµ¤ Î²`. -/\ntheorem isInducing_coeFn : IsInducing (UniformFun.ofFun âˆ˜ (â‡‘) : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ¤ Î²) := by\n  rw [isInducing_iff_nhds]\n  refine fun f => eq_of_forall_le_iff fun l => ?_\n  rw [â† tendsto_iff_comap, â† tendsto_id', tendsto_iff_tendstoUniformly,\n    UniformFun.tendsto_iff_tendstoUniformly]\n  simp [comp_def]\n\n"}
{"name":"BoundedContinuousFunction.inducing_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Topology.IsInducing (Function.comp (â‡‘UniformFun.ofFun) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_coeFn := isInducing_coeFn\n\n-- TODO: upgrade to `IsUniformEmbedding`\n"}
{"name":"BoundedContinuousFunction.isEmbedding_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Topology.IsEmbedding (Function.comp (â‡‘UniformFun.ofFun) DFunLike.coe)","decl":"theorem isEmbedding_coeFn : IsEmbedding (UniformFun.ofFun âˆ˜ (â‡‘) : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ¤ Î²) :=\n  âŸ¨isInducing_coeFn, fun _ _ h => ext fun x => congr_fun h xâŸ©\n\n"}
{"name":"BoundedContinuousFunction.embedding_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Topology.IsEmbedding (Function.comp (â‡‘UniformFun.ofFun) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coeFn := isEmbedding_coeFn\n\n"}
{"name":"BoundedContinuousFunction.const_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nb : Î²\nâŠ¢ Eq â‡‘(BoundedContinuousFunction.const Î± b) fun x => b","decl":"/-- Constant as a continuous bounded function. -/\n@[simps! (config := .asFn)]\ndef const (b : Î²) : Î± â†’áµ‡ Î² :=\n  âŸ¨ContinuousMap.const Î± b, 0, by simpâŸ©\n\n"}
{"name":"BoundedContinuousFunction.const_apply'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\na : Î±\nb : Î²\nâŠ¢ Eq ((BoundedContinuousFunction.const Î± b) a) b","decl":"theorem const_apply' (a : Î±) (b : Î²) : (const Î± b : Î± â†’ Î²) a = b := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_evalx","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nx : Î±\nâŠ¢ LipschitzWith 1 fun f => f x","decl":"theorem lipschitz_evalx (x : Î±) : LipschitzWith 1 fun f : Î± â†’áµ‡ Î² => f x :=\n  LipschitzWith.mk_one fun _ _ => dist_coe_le_dist x\n\n"}
{"name":"BoundedContinuousFunction.uniformContinuous_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ UniformContinuous DFunLike.coe","decl":"theorem uniformContinuous_coe : @UniformContinuous (Î± â†’áµ‡ Î²) (Î± â†’ Î²) _ _ (â‡‘) :=\n  uniformContinuous_pi.2 fun x => (lipschitz_evalx x).uniformContinuous\n\n"}
{"name":"BoundedContinuousFunction.continuous_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Continuous fun f x => f x","decl":"theorem continuous_coe : Continuous fun (f : Î± â†’áµ‡ Î²) x => f x :=\n  UniformContinuous.continuous uniformContinuous_coe\n\n"}
{"name":"BoundedContinuousFunction.continuous_eval_const","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nx : Î±\nâŠ¢ Continuous fun f => f x","decl":"/-- When `x` is fixed, `(f : Î± â†’áµ‡ Î²) â†¦ f x` is continuous. -/\n@[continuity]\ntheorem continuous_eval_const {x : Î±} : Continuous fun f : Î± â†’áµ‡ Î² => f x :=\n  (continuous_apply x).comp continuous_coe\n\n"}
{"name":"BoundedContinuousFunction.continuous_eval","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Continuous fun p => p.1 p.2","decl":"/-- The evaluation map is continuous, as a joint function of `u` and `x`. -/\n@[continuity]\ntheorem continuous_eval : Continuous fun p : (Î± â†’áµ‡ Î²) Ã— Î± => p.1 p.2 :=\n  (continuous_prod_of_continuous_lipschitzWith _ 1 fun f => f.continuous) <| lipschitz_evalx\n\n"}
{"name":"BoundedContinuousFunction.instCompleteSpace","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : CompleteSpace Î²\nâŠ¢ CompleteSpace (BoundedContinuousFunction Î± Î²)","decl":"/-- Bounded continuous functions taking values in a complete space form a complete space. -/\ninstance instCompleteSpace [CompleteSpace Î²] : CompleteSpace (Î± â†’áµ‡ Î²) :=\n  complete_of_cauchySeq_tendsto fun (f : â„• â†’ Î± â†’áµ‡ Î²) (hf : CauchySeq f) => by\n    /- We have to show that `f n` converges to a bounded continuous function.\n      For this, we prove pointwise convergence to define the limit, then check\n      it is a continuous bounded function, and then check the norm convergence. -/\n    rcases cauchySeq_iff_le_tendsto_0.1 hf with âŸ¨b, b0, b_bound, b_limâŸ©\n    have f_bdd := fun x n m N hn hm => le_trans (dist_coe_le_dist x) (b_bound n m N hn hm)\n    have fx_cau : âˆ€ x, CauchySeq fun n => f n x :=\n      fun x => cauchySeq_iff_le_tendsto_0.2 âŸ¨b, b0, f_bdd x, b_limâŸ©\n    choose F hF using fun x => cauchySeq_tendsto_of_complete (fx_cau x)\n    /- `F : Î± â†’ Î²`, `hF : âˆ€ (x : Î±), Tendsto (fun n â†¦ â†‘(f n) x) atTop (ğ“ (F x))`\n      `F` is the desired limit function. Check that it is uniformly approximated by `f N`. -/\n    have fF_bdd : âˆ€ x N, dist (f N x) (F x) â‰¤ b N :=\n      fun x N => le_of_tendsto (tendsto_const_nhds.dist (hF x))\n        (Filter.eventually_atTop.2 âŸ¨N, fun n hn => f_bdd x N n N (le_refl N) hnâŸ©)\n    refine âŸ¨âŸ¨âŸ¨F, ?_âŸ©, ?_âŸ©, ?_âŸ©\n    Â· -- Check that `F` is continuous, as a uniform limit of continuous functions\n      have : TendstoUniformly (fun n x => f n x) F atTop := by\n        refine Metric.tendstoUniformly_iff.2 fun Îµ Îµ0 => ?_\n        refine ((tendsto_order.1 b_lim).2 Îµ Îµ0).mono fun n hn x => ?_\n        rw [dist_comm]\n        exact lt_of_le_of_lt (fF_bdd x n) hn\n      exact this.continuous (Eventually.of_forall fun N => (f N).continuous)\n    Â· -- Check that `F` is bounded\n      rcases (f 0).bounded with âŸ¨C, hCâŸ©\n      refine âŸ¨C + (b 0 + b 0), fun x y => ?_âŸ©\n      calc\n        dist (F x) (F y) â‰¤ dist (f 0 x) (f 0 y) + (dist (f 0 x) (F x) + dist (f 0 y) (F y)) :=\n          dist_triangle4_left _ _ _ _\n        _ â‰¤ C + (b 0 + b 0) := by mono\n    Â· -- Check that `F` is close to `f N` in distance terms\n      refine tendsto_iff_dist_tendsto_zero.2 (squeeze_zero (fun _ => dist_nonneg) ?_ b_lim)\n      exact fun N => (dist_le (b0 _)).2 fun x => fF_bdd x N\n\n"}
{"name":"BoundedContinuousFunction.coe_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœ : TopologicalSpace Î´\nf : BoundedContinuousFunction Î± Î²\ng : ContinuousMap Î´ Î±\nâŠ¢ Eq (â‡‘(f.compContinuous g)) (Function.comp â‡‘f â‡‘g)","decl":"@[simp]\ntheorem coe_compContinuous {Î´ : Type*} [TopologicalSpace Î´] (f : Î± â†’áµ‡ Î²) (g : C(Î´, Î±)) :\n    â‡‘(f.compContinuous g) = f âˆ˜ g := rfl\n\n"}
{"name":"BoundedContinuousFunction.compContinuous_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœ : TopologicalSpace Î´\nf : BoundedContinuousFunction Î± Î²\ng : ContinuousMap Î´ Î±\nx : Î´\nâŠ¢ Eq ((f.compContinuous g) x) (f (g x))","decl":"@[simp]\ntheorem compContinuous_apply {Î´ : Type*} [TopologicalSpace Î´] (f : Î± â†’áµ‡ Î²) (g : C(Î´, Î±)) (x : Î´) :\n    f.compContinuous g x = f (g x) := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœ : TopologicalSpace Î´\ng : ContinuousMap Î´ Î±\nâŠ¢ LipschitzWith 1 fun f => f.compContinuous g","decl":"theorem lipschitz_compContinuous {Î´ : Type*} [TopologicalSpace Î´] (g : C(Î´, Î±)) :\n    LipschitzWith 1 fun f : Î± â†’áµ‡ Î² => f.compContinuous g :=\n  LipschitzWith.mk_one fun _ _ => (dist_le dist_nonneg).2 fun x => dist_coe_le_dist (g x)\n\n"}
{"name":"BoundedContinuousFunction.continuous_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœ : TopologicalSpace Î´\ng : ContinuousMap Î´ Î±\nâŠ¢ Continuous fun f => f.compContinuous g","decl":"theorem continuous_compContinuous {Î´ : Type*} [TopologicalSpace Î´] (g : C(Î´, Î±)) :\n    Continuous fun f : Î± â†’áµ‡ Î² => f.compContinuous g :=\n  (lipschitz_compContinuous g).continuous\n\n"}
{"name":"BoundedContinuousFunction.coe_restrict","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\ns : Set Î±\nâŠ¢ Eq (â‡‘(f.restrict s)) (Function.comp (â‡‘f) Subtype.val)","decl":"@[simp]\ntheorem coe_restrict (f : Î± â†’áµ‡ Î²) (s : Set Î±) : â‡‘(f.restrict s) = f âˆ˜ (â†‘) := rfl\n\n"}
{"name":"BoundedContinuousFunction.restrict_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : BoundedContinuousFunction Î± Î²\ns : Set Î±\nx : â†‘s\nâŠ¢ Eq ((f.restrict s) x) (f â†‘x)","decl":"@[simp]\ntheorem restrict_apply (f : Î± â†’áµ‡ Î²) (s : Set Î±) (x : s) : f.restrict s x = f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : PseudoMetricSpace Î³\nG : Î² â†’ Î³\nC : NNReal\nH : LipschitzWith C G\nâŠ¢ LipschitzWith C (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is Lipschitz. -/\ntheorem lipschitz_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : LipschitzWith C G) :\n    LipschitzWith C (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=\n  LipschitzWith.of_dist_le_mul fun f g =>\n    (dist_le (mul_nonneg C.2 dist_nonneg)).2 fun x =>\n      calc\n        dist (G (f x)) (G (g x)) â‰¤ C * dist (f x) (g x) := H.dist_le_mul _ _\n        _ â‰¤ C * dist f g := by gcongr; apply dist_coe_le_dist\n\n"}
{"name":"BoundedContinuousFunction.uniformContinuous_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : PseudoMetricSpace Î³\nG : Î² â†’ Î³\nC : NNReal\nH : LipschitzWith C G\nâŠ¢ UniformContinuous (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous. -/\ntheorem uniformContinuous_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : LipschitzWith C G) :\n    UniformContinuous (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=\n  (lipschitz_comp H).uniformContinuous\n\n"}
{"name":"BoundedContinuousFunction.continuous_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : PseudoMetricSpace Î³\nG : Î² â†’ Î³\nC : NNReal\nH : LipschitzWith C G\nâŠ¢ Continuous (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is continuous. -/\ntheorem continuous_comp {G : Î² â†’ Î³} {C : â„â‰¥0} (H : LipschitzWith C G) :\n    Continuous (comp G H : (Î± â†’áµ‡ Î²) â†’ Î± â†’áµ‡ Î³) :=\n  (lipschitz_comp H).continuous\n\n"}
{"name":"BoundedContinuousFunction.extend_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : DiscreteTopology Î´\nf : Function.Embedding Î± Î´\ng : BoundedContinuousFunction Î± Î²\nh : BoundedContinuousFunction Î´ Î²\nx : Î±\nâŠ¢ Eq ((BoundedContinuousFunction.extend f g h) (f x)) (g x)","decl":"@[simp]\ntheorem extend_apply (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) (x : Î±) : extend f g h (f x) = g x :=\n  f.injective.extend_apply _ _ _\n\n"}
{"name":"BoundedContinuousFunction.extend_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : DiscreteTopology Î´\nf : Function.Embedding Î± Î´\ng : BoundedContinuousFunction Î± Î²\nh : BoundedContinuousFunction Î´ Î²\nâŠ¢ Eq (Function.comp â‡‘(BoundedContinuousFunction.extend f g h) â‡‘f) â‡‘g","decl":"@[simp]\nnonrec theorem extend_comp (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) : extend f g h âˆ˜ f = g :=\n  extend_comp f.injective _ _\n\n"}
{"name":"BoundedContinuousFunction.extend_apply'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : DiscreteTopology Î´\nf : Function.Embedding Î± Î´\nx : Î´\nhx : Not (Membership.mem (Set.range â‡‘f) x)\ng : BoundedContinuousFunction Î± Î²\nh : BoundedContinuousFunction Î´ Î²\nâŠ¢ Eq ((BoundedContinuousFunction.extend f g h) x) (h x)","decl":"nonrec theorem extend_apply' {f : Î± â†ª Î´} {x : Î´} (hx : x âˆ‰ range f) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) :\n    extend f g h x = h x :=\n  extend_apply' _ _ _ hx\n\n"}
{"name":"BoundedContinuousFunction.extend_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ² : TopologicalSpace Î´\ninstâœÂ¹ : DiscreteTopology Î´\ninstâœ : IsEmpty Î±\nf : Function.Embedding Î± Î´\ng : BoundedContinuousFunction Î± Î²\nh : BoundedContinuousFunction Î´ Î²\nâŠ¢ Eq (BoundedContinuousFunction.extend f g h) h","decl":"theorem extend_of_empty [IsEmpty Î±] (f : Î± â†ª Î´) (g : Î± â†’áµ‡ Î²) (h : Î´ â†’áµ‡ Î²) : extend f g h = h :=\n  DFunLike.coe_injective <| Function.extend_of_isEmpty f g h\n\n"}
{"name":"BoundedContinuousFunction.dist_extend_extend","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : DiscreteTopology Î´\nf : Function.Embedding Î± Î´\ngâ‚ gâ‚‚ : BoundedContinuousFunction Î± Î²\nhâ‚ hâ‚‚ : BoundedContinuousFunction Î´ Î²\nâŠ¢ Eq (Dist.dist (BoundedContinuousFunction.extend f gâ‚ hâ‚) (BoundedContinuousFunction.extend f gâ‚‚ hâ‚‚)) (Max.max (Dist.dist gâ‚ gâ‚‚) (Dist.dist (hâ‚.restrict (HasCompl.compl (Set.range â‡‘f))) (hâ‚‚.restrict (HasCompl.compl (Set.range â‡‘f)))))","decl":"@[simp]\ntheorem dist_extend_extend (f : Î± â†ª Î´) (gâ‚ gâ‚‚ : Î± â†’áµ‡ Î²) (hâ‚ hâ‚‚ : Î´ â†’áµ‡ Î²) :\n    dist (gâ‚.extend f hâ‚) (gâ‚‚.extend f hâ‚‚) =\n      max (dist gâ‚ gâ‚‚) (dist (hâ‚.restrict (range f)á¶œ) (hâ‚‚.restrict (range f)á¶œ)) := by\n  refine le_antisymm ((dist_le <| le_max_iff.2 <| Or.inl dist_nonneg).2 fun x => ?_) (max_le ?_ ?_)\n  Â· rcases em (âˆƒ y, f y = x) with (âŸ¨x, rflâŸ© | hx)\n    Â· simp only [extend_apply]\n      exact (dist_coe_le_dist x).trans (le_max_left _ _)\n    Â· simp only [extend_apply' hx]\n      lift x to ((range f)á¶œ : Set Î´) using hx\n      calc\n        dist (hâ‚ x) (hâ‚‚ x) = dist (hâ‚.restrict (range f)á¶œ x) (hâ‚‚.restrict (range f)á¶œ x) := rfl\n        _ â‰¤ dist (hâ‚.restrict (range f)á¶œ) (hâ‚‚.restrict (range f)á¶œ) := dist_coe_le_dist x\n        _ â‰¤ _ := le_max_right _ _\n  Â· refine (dist_le dist_nonneg).2 fun x => ?_\n    rw [â† extend_apply f gâ‚ hâ‚, â† extend_apply f gâ‚‚ hâ‚‚]\n    exact dist_coe_le_dist _\n  Â· refine (dist_le dist_nonneg).2 fun x => ?_\n    calc\n      dist (hâ‚ x) (hâ‚‚ x) = dist (extend f gâ‚ hâ‚ x) (extend f gâ‚‚ hâ‚‚ x) := by\n        rw [extend_apply' x.coe_prop, extend_apply' x.coe_prop]\n      _ â‰¤ _ := dist_coe_le_dist _\n\n"}
{"name":"BoundedContinuousFunction.isometry_extend","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\nÎ´ : Type u_2\ninstâœÂ¹ : TopologicalSpace Î´\ninstâœ : DiscreteTopology Î´\nf : Function.Embedding Î± Î´\nh : BoundedContinuousFunction Î´ Î²\nâŠ¢ Isometry fun g => BoundedContinuousFunction.extend f g h","decl":"theorem isometry_extend (f : Î± â†ª Î´) (h : Î´ â†’áµ‡ Î²) : Isometry fun g : Î± â†’áµ‡ Î² => extend f g h :=\n  Isometry.of_dist_eq fun gâ‚ gâ‚‚ => by simp [dist_nonneg]\n\n"}
{"name":"BoundedContinuousFunction.indicator_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\ns : Set Î±\nhs : IsClopen s\nx : Î±\nâŠ¢ Eq ((BoundedContinuousFunction.indicator s hs) x) (s.indicator 1 x)","decl":"/-- The indicator function of a clopen set, as a bounded continuous function. -/\n@[simps]\nnoncomputable def indicator (s : Set Î±) (hs : IsClopen s) : BoundedContinuousFunction Î± â„ where\n  toFun := s.indicator 1\n  continuous_toFun := continuous_indicator (by simp [hs]) <| continuous_const.continuousOn\n  map_bounded' := âŸ¨1, fun x y â†¦ by by_cases hx : x âˆˆ s <;> by_cases hy : y âˆˆ s <;> simp [hx, hy]âŸ©\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoliâ‚","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : CompactSpace Î²\nA : Set (BoundedContinuousFunction Î± Î²)\nclosed : IsClosed A\nH : Equicontinuous fun x => â‡‘â†‘x\nâŠ¢ IsCompact A","decl":"/-- First version, with pointwise equicontinuity and range in a compact space. -/\ntheorem arzela_ascoliâ‚ [CompactSpace Î²] (A : Set (Î± â†’áµ‡ Î²)) (closed : IsClosed A)\n    (H : Equicontinuous ((â†‘) : A â†’ Î± â†’ Î²)) : IsCompact A := by\n  simp_rw [Equicontinuous, Metric.equicontinuousAt_iff_pair] at H\n  refine isCompact_of_totallyBounded_isClosed ?_ closed\n  refine totallyBounded_of_finite_discretization fun Îµ Îµ0 => ?_\n  rcases exists_between Îµ0 with âŸ¨Îµâ‚, Îµâ‚0, ÎµÎµâ‚âŸ©\n  let Îµâ‚‚ := Îµâ‚ / 2 / 2\n  /- We have to find a finite discretization of `u`, i.e., finite information\n    that is sufficient to reconstruct `u` up to `Îµ`. This information will be\n    provided by the values of `u` on a sufficiently dense set `tÎ±`,\n    slightly translated to fit in a finite `Îµâ‚‚`-dense set `tÎ²` in the image. Such\n    sets exist by compactness of the source and range. Then, to check that these\n    data determine the function up to `Îµ`, one uses the control on the modulus of\n    continuity to extend the closeness on tÎ± to closeness everywhere. -/\n  have Îµâ‚‚0 : Îµâ‚‚ > 0 := half_pos (half_pos Îµâ‚0)\n  have : âˆ€ x : Î±, âˆƒ U, x âˆˆ U âˆ§ IsOpen U âˆ§\n      âˆ€ y âˆˆ U, âˆ€ z âˆˆ U, âˆ€ {f : Î± â†’áµ‡ Î²}, f âˆˆ A â†’ dist (f y) (f z) < Îµâ‚‚ := fun x =>\n    let âŸ¨U, nhdsU, hUâŸ© := H x _ Îµâ‚‚0\n    let âŸ¨V, VU, openV, xVâŸ© := _root_.mem_nhds_iff.1 nhdsU\n    âŸ¨V, xV, openV, fun y hy z hz f hf => hU y (VU hy) z (VU hz) âŸ¨f, hfâŸ©âŸ©\n  choose U hU using this\n  /- For all `x`, the set `hU x` is an open set containing `x` on which the elements of `A`\n    fluctuate by at most `Îµâ‚‚`.\n    We extract finitely many of these sets that cover the whole space, by compactness. -/\n  obtain âŸ¨tÎ± : Set Î±, _, hfin, htÎ± : univ âŠ† â‹ƒ x âˆˆ tÎ±, U xâŸ© :=\n    isCompact_univ.elim_finite_subcover_image (fun x _ => (hU x).2.1) fun x _ =>\n      mem_biUnion (mem_univ _) (hU x).1\n  rcases hfin.nonempty_fintype with âŸ¨_âŸ©\n  obtain âŸ¨tÎ² : Set Î², _, hfin, htÎ² : univ âŠ† â‹ƒy âˆˆ tÎ², ball y Îµâ‚‚âŸ© :=\n    @finite_cover_balls_of_compact Î² _ _ isCompact_univ _ Îµâ‚‚0\n  rcases hfin.nonempty_fintype with âŸ¨_âŸ©\n  -- Associate to every point `y` in the space a nearby point `F y` in `tÎ²`\n  choose F hF using fun y => show âˆƒ z âˆˆ tÎ², dist y z < Îµâ‚‚ by simpa using htÎ² (mem_univ y)\n  -- `F : Î² â†’ Î²`, `hF : âˆ€ (y : Î²), F y âˆˆ tÎ² âˆ§ dist y (F y) < Îµâ‚‚`\n  /- Associate to every function a discrete approximation, mapping each point in `tÎ±`\n    to a point in `tÎ²` close to its true image by the function. -/\n  classical\n  refine âŸ¨tÎ± â†’ tÎ², by infer_instance, fun f a => âŸ¨F (f.1 a), (hF (f.1 a)).1âŸ©, ?_âŸ©\n  rintro âŸ¨f, hfâŸ© âŸ¨g, hgâŸ© f_eq_g\n  -- If two functions have the same approximation, then they are within distance `Îµ`\n  refine lt_of_le_of_lt ((dist_le <| le_of_lt Îµâ‚0).2 fun x => ?_) ÎµÎµâ‚\n  obtain âŸ¨x', x'tÎ±, hx'âŸ© := mem_iUnionâ‚‚.1 (htÎ± (mem_univ x))\n  calc\n    dist (f x) (g x) â‰¤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') :=\n      dist_triangle4_right _ _ _ _\n    _ â‰¤ Îµâ‚‚ + Îµâ‚‚ + Îµâ‚ / 2 := by\n      refine le_of_lt (add_lt_add (add_lt_add ?_ ?_) ?_)\n      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hf\n      Â· exact (hU x').2.2 _ hx' _ (hU x').1 hg\n      Â· have F_f_g : F (f x') = F (g x') :=\n          (congr_arg (fun f : tÎ± â†’ tÎ² => (f âŸ¨x', x'tÎ±âŸ© : Î²)) f_eq_g :)\n        calc\n          dist (f x') (g x') â‰¤ dist (f x') (F (f x')) + dist (g x') (F (f x')) :=\n            dist_triangle_right _ _ _\n          _ = dist (f x') (F (f x')) + dist (g x') (F (g x')) := by rw [F_f_g]\n          _ < Îµâ‚‚ + Îµâ‚‚ := (add_lt_add (hF (f x')).2 (hF (g x')).2)\n          _ = Îµâ‚ / 2 := add_halves _\n    _ = Îµâ‚ := by rw [add_halves, add_halves]\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoliâ‚‚","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\ns : Set Î²\nhs : IsCompact s\nA : Set (BoundedContinuousFunction Î± Î²)\nclosed : IsClosed A\nin_s : âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), Membership.mem A f â†’ Membership.mem s (f x)\nH : Equicontinuous fun x => â‡‘â†‘x\nâŠ¢ IsCompact A","decl":"/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem arzela_ascoliâ‚‚ (s : Set Î²) (hs : IsCompact s) (A : Set (Î± â†’áµ‡ Î²)) (closed : IsClosed A)\n    (in_s : âˆ€ (f : Î± â†’áµ‡ Î²) (x : Î±), f âˆˆ A â†’ f x âˆˆ s) (H : Equicontinuous ((â†‘) : A â†’ Î± â†’ Î²)) :\n    IsCompact A := by\n  /- This version is deduced from the previous one by restricting to the compact type in the target,\n  using compactness there and then lifting everything to the original space. -/\n  have M : LipschitzWith 1 Subtype.val := LipschitzWith.subtype_val s\n  let F : (Î± â†’áµ‡ s) â†’ Î± â†’áµ‡ Î² := comp (â†‘) M\n  refine IsCompact.of_isClosed_subset ((?_ : IsCompact (F â»Â¹' A)).image (continuous_comp M)) closed\n      fun f hf => ?_\n  Â· haveI : CompactSpace s := isCompact_iff_compactSpace.1 hs\n    refine arzela_ascoliâ‚ _ (continuous_iff_isClosed.1 (continuous_comp M) _ closed) ?_\n    rw [isUniformEmbedding_subtype_val.isUniformInducing.equicontinuous_iff]\n    exact H.comp (A.restrictPreimage F)\n  Â· let g := codRestrict s f fun x => in_s f x hf\n    rw [show f = F g by ext; rfl] at hf âŠ¢\n    exact âŸ¨g, hf, rflâŸ©\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoli","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : T2Space Î²\ns : Set Î²\nhs : IsCompact s\nA : Set (BoundedContinuousFunction Î± Î²)\nin_s : âˆ€ (f : BoundedContinuousFunction Î± Î²) (x : Î±), Membership.mem A f â†’ Membership.mem s (f x)\nH : Equicontinuous fun x => â‡‘â†‘x\nâŠ¢ IsCompact (closure A)","decl":"/-- Third (main) version, with pointwise equicontinuity and range in a compact subset, but\nwithout closedness. The closure is then compact. -/\ntheorem arzela_ascoli [T2Space Î²] (s : Set Î²) (hs : IsCompact s) (A : Set (Î± â†’áµ‡ Î²))\n    (in_s : âˆ€ (f : Î± â†’áµ‡ Î²) (x : Î±), f âˆˆ A â†’ f x âˆˆ s) (H : Equicontinuous ((â†‘) : A â†’ Î± â†’ Î²)) :\n    IsCompact (closure A) :=\n  /- This version is deduced from the previous one by checking that the closure of `A`, in\n  addition to being closed, still satisfies the properties of compact range and equicontinuity. -/\n  arzela_ascoliâ‚‚ s hs (closure A) isClosed_closure\n    (fun _ x hf =>\n      (mem_of_closed' hs.isClosed).2 fun Îµ Îµ0 =>\n        let âŸ¨g, gA, dist_fgâŸ© := Metric.mem_closure_iff.1 hf Îµ Îµ0\n        âŸ¨g x, in_s g x gA, lt_of_le_of_lt (dist_coe_le_dist _) dist_fgâŸ©)\n    (H.closure' continuous_coe)\n\n"}
{"name":"BoundedContinuousFunction.coe_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : Zero Î²\nâŠ¢ Eq (â‡‘0) 0","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : Î± â†’áµ‡ Î²) : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : One Î²\nâŠ¢ Eq (â‡‘1) 1","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : Î± â†’áµ‡ Î²) : Î± â†’ Î²) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : Zero Î²\ninstâœ : CompactSpace Î±\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem mkOfCompact_one [CompactSpace Î±] : mkOfCompact (1 : C(Î±, Î²)) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : One Î²\ninstâœ : CompactSpace Î±\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem mkOfCompact_one [CompactSpace Î±] : mkOfCompact (1 : C(Î±, Î²)) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.forall_coe_one_iff_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : One Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Iff (âˆ€ (x : Î±), Eq (f x) 1) (Eq f 1)","decl":"@[to_additive]\ntheorem forall_coe_one_iff_one (f : Î± â†’áµ‡ Î²) : (âˆ€ x, f x = 1) â†” f = 1 :=\n  (@DFunLike.ext_iff _ _ _ _ f 1).symm\n\n"}
{"name":"BoundedContinuousFunction.forall_coe_zero_iff_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : Zero Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Iff (âˆ€ (x : Î±), Eq (f x) 0) (Eq f 0)","decl":"@[to_additive]\ntheorem forall_coe_one_iff_one (f : Î± â†’áµ‡ Î²) : (âˆ€ x, f x = 1) â†” f = 1 :=\n  (@DFunLike.ext_iff _ _ _ _ f 1).symm\n\n"}
{"name":"BoundedContinuousFunction.one_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : One Î²\ninstâœ : TopologicalSpace Î³\nf : ContinuousMap Î³ Î±\nâŠ¢ Eq (BoundedContinuousFunction.compContinuous 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_compContinuous [TopologicalSpace Î³] (f : C(Î³, Î±)) : (1 : Î± â†’áµ‡ Î²).compContinuous f = 1 :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.zero_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î³\nf : ContinuousMap Î³ Î±\nâŠ¢ Eq (BoundedContinuousFunction.compContinuous 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_compContinuous [TopologicalSpace Î³] (f : C(Î³, Î±)) : (1 : Î± â†’áµ‡ Î²).compContinuous f = 1 :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_add","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(HAdd.hAdd f g)) (HAdd.hAdd â‡‘f â‡‘g)","decl":"@[simp]\ntheorem coe_add : â‡‘(f + g) = f + g := rfl\n\n"}
{"name":"BoundedContinuousFunction.add_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nf g : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"theorem add_apply : (f + g) x = f x + g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_add","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : PseudoMetricSpace Î²\ninstâœÂ³ : AddMonoid Î²\ninstâœÂ² : BoundedAdd Î²\ninstâœÂ¹ : ContinuousAdd Î²\ninstâœ : CompactSpace Î±\nf g : ContinuousMap Î± Î²\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact (HAdd.hAdd f g)) (HAdd.hAdd (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g))","decl":"@[simp]\ntheorem mkOfCompact_add [CompactSpace Î±] (f g : C(Î±, Î²)) :\n    mkOfCompact (f + g) = mkOfCompact f + mkOfCompact g := rfl\n\n"}
{"name":"BoundedContinuousFunction.add_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : PseudoMetricSpace Î²\ninstâœÂ³ : AddMonoid Î²\ninstâœÂ² : BoundedAdd Î²\ninstâœÂ¹ : ContinuousAdd Î²\nf g : BoundedContinuousFunction Î± Î²\ninstâœ : TopologicalSpace Î³\nh : ContinuousMap Î³ Î±\nâŠ¢ Eq ((HAdd.hAdd g f).compContinuous h) (HAdd.hAdd (g.compContinuous h) (f.compContinuous h))","decl":"theorem add_compContinuous [TopologicalSpace Î³] (h : C(Î³, Î±)) :\n    (g + f).compContinuous h = g.compContinuous h + f.compContinuous h := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_nsmulRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nf : BoundedContinuousFunction Î± Î²\nn : Nat\nâŠ¢ Eq (â‡‘(nsmulRec n f)) (HSMul.hSMul n â‡‘f)","decl":"@[simp]\ntheorem coe_nsmulRec : âˆ€ n, â‡‘(nsmulRec n f) = n â€¢ â‡‘f\n  | 0 => by rw [nsmulRec, zero_smul, coe_zero]\n  | n + 1 => by rw [nsmulRec, succ_nsmul, coe_add, coe_nsmulRec n]\n\n"}
{"name":"BoundedContinuousFunction.coe_nsmul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nr : Nat\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(HSMul.hSMul r f)) (HSMul.hSMul r â‡‘f)","decl":"@[simp]\ntheorem coe_nsmul (r : â„•) (f : Î± â†’áµ‡ Î²) : â‡‘(r â€¢ f) = r â€¢ â‡‘f := rfl\n\n"}
{"name":"BoundedContinuousFunction.nsmul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nr : Nat\nf : BoundedContinuousFunction Î± Î²\nv : Î±\nâŠ¢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem nsmul_apply (r : â„•) (f : Î± â†’áµ‡ Î²) (v : Î±) : (r â€¢ f) v = r â€¢ f v := rfl\n\n"}
{"name":"BoundedContinuousFunction.coeFnAddHom_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\naâœ : BoundedContinuousFunction Î± Î²\na : Î±\nâŠ¢ Eq (BoundedContinuousFunction.coeFnAddHom aâœ a) (aâœ a)","decl":"/-- Coercion of a `NormedAddGroupHom` is an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`. -/\n@[simps]\ndef coeFnAddHom : (Î± â†’áµ‡ Î²) â†’+ Î± â†’ Î² where\n  toFun := (â‡‘)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"BoundedContinuousFunction.toContinuousMapAddHom_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nself : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq ((BoundedContinuousFunction.toContinuousMapAddHom Î± Î²) self) self.toContinuousMap","decl":"/-- The additive map forgetting that a bounded continuous function is bounded. -/\n@[simps]\ndef toContinuousMapAddHom : (Î± â†’áµ‡ Î²) â†’+ C(Î±, Î²) where\n  toFun := toContinuousMap\n  map_zero' := rfl\n  map_add' := by\n    intros\n    ext\n    simp\n\n"}
{"name":"BoundedContinuousFunction.coe_sum","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddCommMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nÎ¹ : Type u_2\ns : Finset Î¹\nf : Î¹ â†’ BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(s.sum fun i => f i)) (s.sum fun i => â‡‘(f i))","decl":"@[simp]\ntheorem coe_sum {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ Î± â†’áµ‡ Î²) :\n    â‡‘(âˆ‘ i âˆˆ s, f i) = âˆ‘ i âˆˆ s, (f i : Î± â†’ Î²) :=\n  map_sum coeFnAddHom f s\n\n"}
{"name":"BoundedContinuousFunction.sum_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : PseudoMetricSpace Î²\ninstâœÂ² : AddCommMonoid Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nÎ¹ : Type u_2\ns : Finset Î¹\nf : Î¹ â†’ BoundedContinuousFunction Î± Î²\na : Î±\nâŠ¢ Eq ((s.sum fun i => f i) a) (s.sum fun i => (f i) a)","decl":"theorem sum_apply {Î¹ : Type*} (s : Finset Î¹) (f : Î¹ â†’ Î± â†’áµ‡ Î²) (a : Î±) :\n    (âˆ‘ i âˆˆ s, f i) a = âˆ‘ i âˆˆ s, f i a := by simp\n\n"}
{"name":"BoundedContinuousFunction.instLipschitzAdd","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : LipschitzAdd Î²\nâŠ¢ LipschitzAdd (BoundedContinuousFunction Î± Î²)","decl":"instance instLipschitzAdd : LipschitzAdd (Î± â†’áµ‡ Î²) where\n  lipschitz_add :=\n    âŸ¨LipschitzAdd.C Î², by\n      have C_nonneg := (LipschitzAdd.C Î²).coe_nonneg\n      rw [lipschitzWith_iff_dist_le_mul]\n      rintro âŸ¨fâ‚, gâ‚âŸ© âŸ¨fâ‚‚, gâ‚‚âŸ©\n      rw [dist_le (mul_nonneg C_nonneg dist_nonneg)]\n      intro x\n      refine le_trans (lipschitz_with_lipschitz_const_add âŸ¨fâ‚ x, gâ‚ xâŸ© âŸ¨fâ‚‚ x, gâ‚‚ xâŸ©) ?_\n      refine mul_le_mul_of_nonneg_left ?_ C_nonneg\n      apply max_le_max <;> exact dist_coe_le_dist xâŸ©\n\n"}
{"name":"BoundedContinuousFunction.sub_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Sub R\ninstâœÂ¹ : BoundedSub R\ninstâœ : ContinuousSub R\nf g : BoundedContinuousFunction Î± R\nx : Î±\nâŠ¢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"theorem sub_apply {x : Î±} : (f - g) x = f x - g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_sub","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Sub R\ninstâœÂ¹ : BoundedSub R\ninstâœ : ContinuousSub R\nf g : BoundedContinuousFunction Î± R\nâŠ¢ Eq (â‡‘(HSub.hSub f g)) (HSub.hSub â‡‘f â‡‘g)","decl":"@[simp]\ntheorem coe_sub : â‡‘(f - g) = f - g := rfl\n\n"}
{"name":"BoundedContinuousFunction.natCast_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\nÎ² : Type u_2\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : NatCast Î²\nn : Nat\nx : Î±\nâŠ¢ Eq (â†‘n x) â†‘n","decl":"@[simp]\ntheorem natCast_apply [NatCast Î²] (n : â„•) (x : Î±) : (n : Î± â†’áµ‡ Î²) x = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.intCast_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\nÎ² : Type u_2\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : IntCast Î²\nm : Int\nx : Î±\nâŠ¢ Eq (â†‘m x) â†‘m","decl":"@[simp]\ntheorem intCast_apply [IntCast Î²] (m : â„¤) (x : Î±) : (m : Î± â†’áµ‡ Î²) x = m := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_mul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Mul R\ninstâœÂ¹ : BoundedMul R\ninstâœ : ContinuousMul R\nf g : BoundedContinuousFunction Î± R\nâŠ¢ Eq (â‡‘(HMul.hMul f g)) (HMul.hMul â‡‘f â‡‘g)","decl":"@[simp]\ntheorem coe_mul [Mul R] [BoundedMul R] [ContinuousMul R] (f g : Î± â†’áµ‡ R) : â‡‘(f * g) = f * g := rfl\n\n"}
{"name":"BoundedContinuousFunction.mul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Mul R\ninstâœÂ¹ : BoundedMul R\ninstâœ : ContinuousMul R\nf g : BoundedContinuousFunction Î± R\nx : Î±\nâŠ¢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"theorem mul_apply [Mul R] [BoundedMul R] [ContinuousMul R] (f g : Î± â†’áµ‡ R) (x : Î±) :\n    (f * g) x = f x * g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_pow","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Monoid R\ninstâœÂ¹ : BoundedMul R\ninstâœ : ContinuousMul R\nn : Nat\nf : BoundedContinuousFunction Î± R\nâŠ¢ Eq (â‡‘(HPow.hPow f n)) (HPow.hPow (â‡‘f) n)","decl":"theorem coe_pow [Monoid R] [BoundedMul R] [ContinuousMul R] (n : â„•) (f : Î± â†’áµ‡ R) :\n    â‡‘(f ^ n) = (â‡‘f) ^ n := rfl\n\n"}
{"name":"BoundedContinuousFunction.pow_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœâ´ : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ³ : PseudoMetricSpace R\ninstâœÂ² : Monoid R\ninstâœÂ¹ : BoundedMul R\ninstâœ : ContinuousMul R\nn : Nat\nf : BoundedContinuousFunction Î± R\nx : Î±\nâŠ¢ Eq ((HPow.hPow f n) x) (HPow.hPow (f x) n)","decl":"@[simp]\ntheorem pow_apply [Monoid R] [BoundedMul R] [ContinuousMul R] (n : â„•) (f : Î± â†’áµ‡ R) (x : Î±) :\n    (f ^ n) x = f x ^ n := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_def","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Norm.norm f) (Dist.dist f 0)","decl":"theorem norm_def : â€–fâ€– = dist f 0 := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Norm.norm f) (InfSet.sInf (setOf fun C => And (LE.le 0 C) (âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C)))","decl":"/-- The norm of a bounded continuous function is the supremum of `â€–f xâ€–`.\nWe use `sInf` to ensure that the definition works if `Î±` has no elements. -/\ntheorem norm_eq (f : Î± â†’áµ‡ Î²) : â€–fâ€– = sInf { C : â„ | 0 â‰¤ C âˆ§ âˆ€ x : Î±, â€–f xâ€– â‰¤ C } := by\n  simp [norm_def, BoundedContinuousFunction.dist_eq]\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nh : Nonempty Î±\nâŠ¢ Eq (Norm.norm f) (InfSet.sInf (setOf fun C => âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C))","decl":"/-- When the domain is non-empty, we do not need the `0 â‰¤ C` condition in the formula for `â€–fâ€–` as a\n`sInf`. -/\ntheorem norm_eq_of_nonempty [h : Nonempty Î±] : â€–fâ€– = sInf { C : â„ | âˆ€ x : Î±, â€–f xâ€– â‰¤ C } := by\n  obtain âŸ¨aâŸ© := h\n  rw [norm_eq]\n  congr\n  ext\n  simp only [mem_setOf_eq, and_iff_right_iff_imp]\n  exact fun h' => le_trans (norm_nonneg (f a)) (h' a)\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_zero_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\ninstâœ : IsEmpty Î±\nâŠ¢ Eq (Norm.norm f) 0","decl":"@[simp]\ntheorem norm_eq_zero_of_empty [IsEmpty Î±] : â€–fâ€– = 0 :=\n  dist_zero_of_empty\n\n"}
{"name":"BoundedContinuousFunction.norm_coe_le_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"theorem norm_coe_le_norm (x : Î±) : â€–f xâ€– â‰¤ â€–fâ€– :=\n  calc\n    â€–f xâ€– = dist (f x) ((0 : Î± â†’áµ‡ Î²) x) := by simp [dist_zero_right]\n    _ â‰¤ â€–fâ€– := dist_coe_le_dist _\n\n"}
{"name":"BoundedContinuousFunction.neg_norm_le_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nx : Î±\nâŠ¢ LE.le (Neg.neg (Norm.norm f)) (f x)","decl":"lemma neg_norm_le_apply (f : Î± â†’áµ‡ â„) (x : Î±) :\n    -â€–fâ€– â‰¤ f x := (abs_le.mp (norm_coe_le_norm f x)).1\n\n"}
{"name":"BoundedContinuousFunction.apply_le_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nx : Î±\nâŠ¢ LE.le (f x) (Norm.norm f)","decl":"lemma apply_le_norm (f : Î± â†’áµ‡ â„) (x : Î±) :\n    f x â‰¤ â€–fâ€– := (abs_le.mp (norm_coe_le_norm f x)).2\n\n"}
{"name":"BoundedContinuousFunction.dist_le_two_norm'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î² : Type v\nÎ³ : Type w\ninstâœ : SeminormedAddCommGroup Î²\nf : Î³ â†’ Î²\nC : Real\nhC : âˆ€ (x : Î³), LE.le (Norm.norm (f x)) C\nx y : Î³\nâŠ¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 C)","decl":"theorem dist_le_two_norm' {f : Î³ â†’ Î²} {C : â„} (hC : âˆ€ x, â€–f xâ€– â‰¤ C) (x y : Î³) :\n    dist (f x) (f y) â‰¤ 2 * C :=\n  calc\n    dist (f x) (f y) â‰¤ â€–f xâ€– + â€–f yâ€– := dist_le_norm_add_norm _ _\n    _ â‰¤ C + C := add_le_add (hC x) (hC y)\n    _ = 2 * C := (two_mul _).symm\n\n"}
{"name":"BoundedContinuousFunction.dist_le_two_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nx y : Î±\nâŠ¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 (Norm.norm f))","decl":"/-- Distance between the images of any two points is at most twice the norm of the function. -/\ntheorem dist_le_two_norm (x y : Î±) : dist (f x) (f y) â‰¤ 2 * â€–fâ€– :=\n  dist_le_two_norm' f.norm_coe_le_norm x y\n\n"}
{"name":"BoundedContinuousFunction.norm_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nC : Real\nC0 : LE.le 0 C\nâŠ¢ Iff (LE.le (Norm.norm f) C) (âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C)","decl":"/-- The norm of a function is controlled by the supremum of the pointwise norms. -/\ntheorem norm_le (C0 : (0 : â„) â‰¤ C) : â€–fâ€– â‰¤ C â†” âˆ€ x : Î±, â€–f xâ€– â‰¤ C := by\n  simpa using @dist_le _ _ _ _ f 0 _ C0\n\n"}
{"name":"BoundedContinuousFunction.norm_le_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : Nonempty Î±\nf : BoundedContinuousFunction Î± Î²\nM : Real\nâŠ¢ Iff (LE.le (Norm.norm f) M) (âˆ€ (x : Î±), LE.le (Norm.norm (f x)) M)","decl":"theorem norm_le_of_nonempty [Nonempty Î±] {f : Î± â†’áµ‡ Î²} {M : â„} : â€–fâ€– â‰¤ M â†” âˆ€ x, â€–f xâ€– â‰¤ M := by\n  simp_rw [norm_def, â† dist_zero_right]\n  exact dist_le_iff_of_nonempty\n\n"}
{"name":"BoundedContinuousFunction.norm_lt_iff_of_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : CompactSpace Î±\nf : BoundedContinuousFunction Î± Î²\nM : Real\nM0 : LT.lt 0 M\nâŠ¢ Iff (LT.lt (Norm.norm f) M) (âˆ€ (x : Î±), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_compact [CompactSpace Î±] {f : Î± â†’áµ‡ Î²} {M : â„} (M0 : 0 < M) :\n    â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M := by\n  simp_rw [norm_def, â† dist_zero_right]\n  exact dist_lt_iff_of_compact M0\n\n"}
{"name":"BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : SeminormedAddCommGroup Î²\ninstâœÂ¹ : Nonempty Î±\ninstâœ : CompactSpace Î±\nf : BoundedContinuousFunction Î± Î²\nM : Real\nâŠ¢ Iff (LT.lt (Norm.norm f) M) (âˆ€ (x : Î±), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_nonempty_compact [Nonempty Î±] [CompactSpace Î±] {f : Î± â†’áµ‡ Î²} {M : â„} :\n    â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M := by\n  simp_rw [norm_def, â† dist_zero_right]\n  exact dist_lt_iff_of_nonempty_compact\n\n"}
{"name":"BoundedContinuousFunction.norm_const_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nb : Î²\nâŠ¢ LE.le (Norm.norm (BoundedContinuousFunction.const Î± b)) (Norm.norm b)","decl":"/-- Norm of `const Î± b` is less than or equal to `â€–bâ€–`. If `Î±` is nonempty,\nthen it is equal to `â€–bâ€–`. -/\ntheorem norm_const_le (b : Î²) : â€–const Î± bâ€– â‰¤ â€–bâ€– :=\n  (norm_le (norm_nonneg b)).2 fun _ => le_rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_const_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nh : Nonempty Î±\nb : Î²\nâŠ¢ Eq (Norm.norm (BoundedContinuousFunction.const Î± b)) (Norm.norm b)","decl":"@[simp]\ntheorem norm_const_eq [h : Nonempty Î±] (b : Î²) : â€–const Î± bâ€– = â€–bâ€– :=\n  le_antisymm (norm_const_le b) <| h.elim fun x => (const Î± b).norm_coe_le_norm x\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNormedAddCommGroup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nHf : Continuous f\nC : Real\nH : âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C\nâŠ¢ Eq (â‡‘(BoundedContinuousFunction.ofNormedAddCommGroup f Hf C H)) f","decl":"@[simp]\ntheorem coe_ofNormedAddCommGroup {Î± : Type u} {Î² : Type v} [TopologicalSpace Î±]\n    [SeminormedAddCommGroup Î²] (f : Î± â†’ Î²) (Hf : Continuous f) (C : â„) (H : âˆ€ x, â€–f xâ€– â‰¤ C) :\n    (ofNormedAddCommGroup f Hf C H : Î± â†’ Î²) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_ofNormedAddCommGroup_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nhfc : Continuous f\nC : Real\nhC : LE.le 0 C\nhfC : âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C\nâŠ¢ LE.le (Norm.norm (BoundedContinuousFunction.ofNormedAddCommGroup f hfc C hfC)) C","decl":"theorem norm_ofNormedAddCommGroup_le {f : Î± â†’ Î²} (hfc : Continuous f) {C : â„} (hC : 0 â‰¤ C)\n    (hfC : âˆ€ x, â€–f xâ€– â‰¤ C) : â€–ofNormedAddCommGroup f hfc C hfCâ€– â‰¤ C :=\n  (norm_le hC).2 hfC\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscrete","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : DiscreteTopology Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : Î± â†’ Î²\nC : Real\nH : âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C\nâŠ¢ Eq (â‡‘(BoundedContinuousFunction.ofNormedAddCommGroupDiscrete f C H)) f","decl":"@[simp]\ntheorem coe_ofNormedAddCommGroupDiscrete {Î± : Type u} {Î² : Type v} [TopologicalSpace Î±]\n    [DiscreteTopology Î±] [SeminormedAddCommGroup Î²] (f : Î± â†’ Î²) (C : â„) (H : âˆ€ x, â€–f xâ€– â‰¤ C) :\n    (ofNormedAddCommGroupDiscrete f C H : Î± â†’ Î²) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_normComp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘f.normComp) (Function.comp Norm.norm â‡‘f)","decl":"@[simp]\ntheorem coe_normComp : (f.normComp : Î± â†’ â„) = norm âˆ˜ f := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_normComp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Norm.norm f.normComp) (Norm.norm f)","decl":"@[simp]\ntheorem norm_normComp : â€–f.normCompâ€– = â€–fâ€– := by\n  simp only [norm_eq, coe_normComp, norm_norm, Function.comp]\n\n"}
{"name":"BoundedContinuousFunction.bddAbove_range_norm_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ BddAbove (Set.range (Function.comp Norm.norm â‡‘f))","decl":"theorem bddAbove_range_norm_comp : BddAbove <| Set.range <| norm âˆ˜ f :=\n  (@isBounded_range _ _ _ _ f.normComp).bddAbove\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_iSup_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Norm.norm f) (iSup fun x => Norm.norm (f x))","decl":"theorem norm_eq_iSup_norm : â€–fâ€– = â¨† x : Î±, â€–f xâ€– := by\n  simp_rw [norm_def, dist_eq_iSup, coe_zero, Pi.zero_apply, dist_zero_right]\n\n"}
{"name":"BoundedContinuousFunction.instNormOneClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : Nonempty Î±\ninstâœÂ¹ : One Î²\ninstâœ : NormOneClass Î²\nâŠ¢ NormOneClass (BoundedContinuousFunction Î± Î²)","decl":"/-- If `â€–(1 : Î²)â€– = 1`, then `â€–(1 : Î± â†’áµ‡ Î²)â€– = 1` if `Î±` is nonempty. -/\ninstance instNormOneClass [Nonempty Î±] [One Î²] [NormOneClass Î²] : NormOneClass (Î± â†’áµ‡ Î²) where\n  norm_one := by simp only [norm_eq_iSup_norm, coe_one, Pi.one_apply, norm_one, ciSup_const]\n\n"}
{"name":"BoundedContinuousFunction.coe_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(Neg.neg f)) (Neg.neg â‡‘f)","decl":"@[simp]\ntheorem coe_neg : â‡‘(-f) = -f := rfl\n\n"}
{"name":"BoundedContinuousFunction.neg_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"theorem neg_apply : (-f) x = -f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : CompactSpace Î±\nf : ContinuousMap Î± Î²\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact (Neg.neg f)) (Neg.neg (BoundedContinuousFunction.mkOfCompact f))","decl":"@[simp]\ntheorem mkOfCompact_neg [CompactSpace Î±] (f : C(Î±, Î²)) : mkOfCompact (-f) = -mkOfCompact f := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_sub","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : CompactSpace Î±\nf g : ContinuousMap Î± Î²\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact (HSub.hSub f g)) (HSub.hSub (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g))","decl":"@[simp]\ntheorem mkOfCompact_sub [CompactSpace Î±] (f g : C(Î±, Î²)) :\n    mkOfCompact (f - g) = mkOfCompact f - mkOfCompact g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_zsmulRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nz : Int\nâŠ¢ Eq (â‡‘(zsmulRec (fun x1 x2 => HSMul.hSMul x1 x2) z f)) (HSMul.hSMul z â‡‘f)","decl":"@[simp]\ntheorem coe_zsmulRec : âˆ€ z, â‡‘(zsmulRec (Â· â€¢ Â·) z f) = z â€¢ â‡‘f\n  | Int.ofNat n => by rw [zsmulRec, Int.ofNat_eq_coe, coe_nsmul, natCast_zsmul]\n  | Int.negSucc n => by rw [zsmulRec, negSucc_zsmul, coe_neg, coe_nsmul]\n\n"}
{"name":"BoundedContinuousFunction.coe_zsmul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nr : Int\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(HSMul.hSMul r f)) (HSMul.hSMul r â‡‘f)","decl":"@[simp]\ntheorem coe_zsmul (r : â„¤) (f : Î± â†’áµ‡ Î²) : â‡‘(r â€¢ f) = r â€¢ â‡‘f := rfl\n\n"}
{"name":"BoundedContinuousFunction.zsmul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nr : Int\nf : BoundedContinuousFunction Î± Î²\nv : Î±\nâŠ¢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem zsmul_apply (r : â„¤) (f : Î± â†’áµ‡ Î²) (v : Î±) : (r â€¢ f) v = r â€¢ f v := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_def","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (NNNorm.nnnorm f) (NNDist.nndist f 0)","decl":"theorem nnnorm_def : â€–fâ€–â‚Š = nndist f 0 := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_coe_le_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm f)","decl":"theorem nnnorm_coe_le_nnnorm (x : Î±) : â€–f xâ€–â‚Š â‰¤ â€–fâ€–â‚Š :=\n  norm_coe_le_norm _ _\n\n"}
{"name":"BoundedContinuousFunction.nndist_le_two_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nx y : Î±\nâŠ¢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul 2 (NNNorm.nnnorm f))","decl":"theorem nndist_le_two_nnnorm (x y : Î±) : nndist (f x) (f y) â‰¤ 2 * â€–fâ€–â‚Š :=\n  dist_le_two_norm _ _ _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nC : NNReal\nâŠ¢ Iff (LE.le (NNNorm.nnnorm f) C) (âˆ€ (x : Î±), LE.le (NNNorm.nnnorm (f x)) C)","decl":"/-- The `nnnorm` of a function is controlled by the supremum of the pointwise `nnnorm`s. -/\ntheorem nnnorm_le (C : â„â‰¥0) : â€–fâ€–â‚Š â‰¤ C â†” âˆ€ x : Î±, â€–f xâ€–â‚Š â‰¤ C :=\n  norm_le C.prop\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_const_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nb : Î²\nâŠ¢ LE.le (NNNorm.nnnorm (BoundedContinuousFunction.const Î± b)) (NNNorm.nnnorm b)","decl":"theorem nnnorm_const_le (b : Î²) : â€–const Î± bâ€–â‚Š â‰¤ â€–bâ€–â‚Š :=\n  norm_const_le _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_const_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : Nonempty Î±\nb : Î²\nâŠ¢ Eq (NNNorm.nnnorm (BoundedContinuousFunction.const Î± b)) (NNNorm.nnnorm b)","decl":"@[simp]\ntheorem nnnorm_const_eq [Nonempty Î±] (b : Î²) : â€–const Î± bâ€–â‚Š = â€–bâ€–â‚Š :=\n  Subtype.ext <| norm_const_eq _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_eq_iSup_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (NNNorm.nnnorm f) (iSup fun x => NNNorm.nnnorm (f x))","decl":"theorem nnnorm_eq_iSup_nnnorm : â€–fâ€–â‚Š = â¨† x : Î±, â€–f xâ€–â‚Š :=\n  Subtype.ext <| (norm_eq_iSup_norm f).trans <| by simp_rw [val_eq_coe, NNReal.coe_iSup, coe_nnnorm]\n\n"}
{"name":"BoundedContinuousFunction.abs_diff_coe_le_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : SeminormedAddCommGroup Î²\nf g : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ LE.le (Norm.norm (HSub.hSub (f x) (g x))) (Dist.dist f g)","decl":"theorem abs_diff_coe_le_dist : â€–f x - g xâ€– â‰¤ dist f g := by\n  rw [dist_eq_norm]\n  exact (f - g).norm_coe_le_norm x\n\n"}
{"name":"BoundedContinuousFunction.coe_le_coe_add_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nx : Î±\nf g : BoundedContinuousFunction Î± Real\nâŠ¢ LE.le (f x) (HAdd.hAdd (g x) (Dist.dist f g))","decl":"theorem coe_le_coe_add_dist {f g : Î± â†’áµ‡ â„} : f x â‰¤ g x + dist f g :=\n  sub_le_iff_le_add'.1 <| (abs_le.1 <| @dist_coe_le_dist _ _ _ _ f g x).2\n\n"}
{"name":"BoundedContinuousFunction.norm_compContinuous_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : TopologicalSpace Î³\nf : BoundedContinuousFunction Î± Î²\ng : ContinuousMap Î³ Î±\nâŠ¢ LE.le (Norm.norm (f.compContinuous g)) (Norm.norm f)","decl":"theorem norm_compContinuous_le [TopologicalSpace Î³] (f : Î± â†’áµ‡ Î²) (g : C(Î³, Î±)) :\n    â€–f.compContinuous gâ€– â‰¤ â€–fâ€– :=\n  ((lipschitz_compContinuous g).dist_le_mul f 0).trans <| by\n    rw [NNReal.coe_one, one_mul, dist_zero_right]\n\n"}
{"name":"BoundedContinuousFunction.coe_smul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : PseudoMetricSpace Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq â‡‘(HSMul.hSMul c f) fun x => HSMul.hSMul c (f x)","decl":"@[simp]\ntheorem coe_smul (c : ğ•œ) (f : Î± â†’áµ‡ Î²) : â‡‘(c â€¢ f) = fun x => c â€¢ f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.smul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : PseudoMetricSpace Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nf : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ Eq ((HSMul.hSMul c f) x) (HSMul.hSMul c (f x))","decl":"theorem smul_apply (c : ğ•œ) (f : Î± â†’áµ‡ Î²) (x : Î±) : (c â€¢ f) x = c â€¢ f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.instIsScalarTower","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœÂ¹Â² : PseudoMetricSpace ğ•œ\ninstâœÂ¹Â¹ : TopologicalSpace Î±\ninstâœÂ¹â° : PseudoMetricSpace Î²\ninstâœâ¹ : Zero ğ•œ\ninstâœâ¸ : Zero Î²\ninstâœâ· : SMul ğ•œ Î²\ninstâœâ¶ : BoundedSMul ğ•œ Î²\nğ•œ' : Type u_3\ninstâœâµ : PseudoMetricSpace ğ•œ'\ninstâœâ´ : Zero ğ•œ'\ninstâœÂ³ : SMul ğ•œ' Î²\ninstâœÂ² : BoundedSMul ğ•œ' Î²\ninstâœÂ¹ : SMul ğ•œ' ğ•œ\ninstâœ : IsScalarTower ğ•œ' ğ•œ Î²\nâŠ¢ IsScalarTower ğ•œ' ğ•œ (BoundedContinuousFunction Î± Î²)","decl":"instance instIsScalarTower {ğ•œ' : Type*} [PseudoMetricSpace ğ•œ'] [Zero ğ•œ'] [SMul ğ•œ' Î²]\n    [BoundedSMul ğ•œ' Î²] [SMul ğ•œ' ğ•œ] [IsScalarTower ğ•œ' ğ•œ Î²] :\n    IsScalarTower ğ•œ' ğ•œ (Î± â†’áµ‡ Î²) where\n  smul_assoc _ _ _ := ext fun _ â†¦ smul_assoc ..\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœÂ¹Â¹ : PseudoMetricSpace ğ•œ\ninstâœÂ¹â° : TopologicalSpace Î±\ninstâœâ¹ : PseudoMetricSpace Î²\ninstâœâ¸ : Zero ğ•œ\ninstâœâ· : Zero Î²\ninstâœâ¶ : SMul ğ•œ Î²\ninstâœâµ : BoundedSMul ğ•œ Î²\nğ•œ' : Type u_3\ninstâœâ´ : PseudoMetricSpace ğ•œ'\ninstâœÂ³ : Zero ğ•œ'\ninstâœÂ² : SMul ğ•œ' Î²\ninstâœÂ¹ : BoundedSMul ğ•œ' Î²\ninstâœ : SMulCommClass ğ•œ' ğ•œ Î²\nâŠ¢ SMulCommClass ğ•œ' ğ•œ (BoundedContinuousFunction Î± Î²)","decl":"instance instSMulCommClass {ğ•œ' : Type*} [PseudoMetricSpace ğ•œ'] [Zero ğ•œ'] [SMul ğ•œ' Î²]\n    [BoundedSMul ğ•œ' Î²] [SMulCommClass ğ•œ' ğ•œ Î²] :\n    SMulCommClass ğ•œ' ğ•œ (Î± â†’áµ‡ Î²) where\n  smul_comm _ _ _ := ext fun _ â†¦ smul_comm ..\n\n"}
{"name":"BoundedContinuousFunction.instIsCentralScalar","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¸ : PseudoMetricSpace ğ•œ\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : PseudoMetricSpace Î²\ninstâœâµ : Zero ğ•œ\ninstâœâ´ : Zero Î²\ninstâœÂ³ : SMul ğ•œ Î²\ninstâœÂ² : BoundedSMul ğ•œ Î²\ninstâœÂ¹ : SMul (MulOpposite ğ•œ) Î²\ninstâœ : IsCentralScalar ğ•œ Î²\nâŠ¢ IsCentralScalar ğ•œ (BoundedContinuousFunction Î± Î²)","decl":"instance instIsCentralScalar [SMul ğ•œáµáµ’áµ– Î²] [IsCentralScalar ğ•œ Î²] : IsCentralScalar ğ•œ (Î± â†’áµ‡ Î²) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"BoundedContinuousFunction.instBoundedSMul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : PseudoMetricSpace Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SMul ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nâŠ¢ BoundedSMul ğ•œ (BoundedContinuousFunction Î± Î²)","decl":"instance instBoundedSMul : BoundedSMul ğ•œ (Î± â†’áµ‡ Î²) where\n  dist_smul_pair' c fâ‚ fâ‚‚ := by\n    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]\n    intro x\n    refine (dist_smul_pair c (fâ‚ x) (fâ‚‚ x)).trans ?_\n    exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg\n  dist_pair_smul' câ‚ câ‚‚ f := by\n    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]\n    intro x\n    refine (dist_pair_smul câ‚ câ‚‚ (f x)).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ dist_nonneg\n    convert dist_coe_le_dist (Î² := Î²) x\n    simp\n\n"}
{"name":"BoundedContinuousFunction.evalCLM_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¸ : PseudoMetricSpace ğ•œ\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : PseudoMetricSpace Î²\ninstâœâµ : Semiring ğ•œ\ninstâœâ´ : AddCommMonoid Î²\ninstâœÂ³ : Module ğ•œ Î²\ninstâœÂ² : BoundedSMul ğ•œ Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nx : Î±\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq ((BoundedContinuousFunction.evalCLM ğ•œ x) f) (f x)","decl":"/-- The evaluation at a point, as a continuous linear map from `Î± â†’áµ‡ Î²` to `Î²`. -/\n@[simps]\ndef evalCLM (x : Î±) : (Î± â†’áµ‡ Î²) â†’L[ğ•œ] Î² where\n  toFun f := f x\n  map_add' _ _ := add_apply _ _\n  map_smul' _ _ := smul_apply _ _ _\n\n"}
{"name":"BoundedContinuousFunction.toContinuousMapLinearMap_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¸ : PseudoMetricSpace ğ•œ\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : PseudoMetricSpace Î²\ninstâœâµ : Semiring ğ•œ\ninstâœâ´ : AddCommMonoid Î²\ninstâœÂ³ : Module ğ•œ Î²\ninstâœÂ² : BoundedSMul ğ•œ Î²\ninstâœÂ¹ : BoundedAdd Î²\ninstâœ : ContinuousAdd Î²\nself : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq ((BoundedContinuousFunction.toContinuousMapLinearMap Î± Î² ğ•œ) self) self.toContinuousMap","decl":"/-- The linear map forgetting that a bounded continuous function is bounded. -/\n@[simps]\ndef toContinuousMapLinearMap : (Î± â†’áµ‡ Î²) â†’â‚—[ğ•œ] C(Î±, Î²) where\n  toFun := toContinuousMap\n  map_smul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ContinuousLinearMap.compLeftContinuousBounded_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nÎ³ : Type w\nğ•œ : Type u_2\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : SeminormedAddCommGroup Î²\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ Î²\ninstâœÂ¹ : SeminormedAddCommGroup Î³\ninstâœ : NormedSpace ğ•œ Î³\ng : ContinuousLinearMap (RingHom.id ğ•œ) Î² Î³\nf : BoundedContinuousFunction Î± Î²\nx : Î±\nâŠ¢ Eq (((ContinuousLinearMap.compLeftContinuousBounded Î± g) f) x) (g (f x))","decl":"@[simp]\ntheorem _root_.ContinuousLinearMap.compLeftContinuousBounded_apply (g : Î² â†’L[ğ•œ] Î³) (f : Î± â†’áµ‡ Î²)\n    (x : Î±) : (g.compLeftContinuousBounded Î± f) x = g (f x) := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_npowRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\nR : Type u_2\ninstâœ : SeminormedRing R\nf : BoundedContinuousFunction Î± R\nn : Nat\nâŠ¢ Eq (â‡‘(npowRec n f)) (HPow.hPow (â‡‘f) n)","decl":"@[simp]\ntheorem coe_npowRec (f : Î± â†’áµ‡ R) : âˆ€ n, â‡‘(npowRec n f) = (â‡‘f) ^ n\n  | 0 => by rw [npowRec, pow_zero, coe_one]\n  | n + 1 => by rw [npowRec, pow_succ, coe_mul, coe_npowRec f n]\n\n"}
{"name":"BoundedContinuousFunction.coe_natCast","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\nR : Type u_2\ninstâœ : SeminormedRing R\nn : Nat\nâŠ¢ Eq â‡‘â†‘n â†‘n","decl":"@[simp, norm_cast]\ntheorem coe_natCast (n : â„•) : ((n : Î± â†’áµ‡ R) : Î± â†’ R) = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNat","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ² : TopologicalSpace Î±\nR : Type u_2\ninstâœÂ¹ : SeminormedRing R\nn : Nat\ninstâœ : n.AtLeastTwo\nâŠ¢ Eq (â‡‘(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem coe_ofNat (n : â„•) [n.AtLeastTwo] :\n    ((ofNat(n) : Î± â†’áµ‡ R) : Î± â†’ R) = ofNat(n) :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_intCast","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœÂ¹ : TopologicalSpace Î±\nR : Type u_2\ninstâœ : SeminormedRing R\nn : Int\nâŠ¢ Eq â‡‘â†‘n â†‘n","decl":"@[simp, norm_cast]\ntheorem coe_intCast (n : â„¤) : ((n : Î± â†’áµ‡ R) : Î± â†’ R) = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.instIsScalarTower_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : NonUnitalSeminormedRing Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : SMul ğ•œ Î²\ninstâœÂ¹ : BoundedSMul ğ•œ Î²\ninstâœ : IsScalarTower ğ•œ Î² Î²\nâŠ¢ IsScalarTower ğ•œ (BoundedContinuousFunction Î± Î²) (BoundedContinuousFunction Î± Î²)","decl":"instance [IsScalarTower ğ•œ Î² Î²] : IsScalarTower ğ•œ (Î± â†’áµ‡ Î²) (Î± â†’áµ‡ Î²) where\n  smul_assoc _ _ _ := ext fun _ â†¦ smul_mul_assoc ..\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : NonUnitalSeminormedRing Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : SMul ğ•œ Î²\ninstâœÂ¹ : BoundedSMul ğ•œ Î²\ninstâœ : SMulCommClass ğ•œ Î² Î²\nâŠ¢ SMulCommClass ğ•œ (BoundedContinuousFunction Î± Î²) (BoundedContinuousFunction Î± Î²)","decl":"instance [SMulCommClass ğ•œ Î² Î²] : SMulCommClass ğ•œ (Î± â†’áµ‡ Î²) (Î± â†’áµ‡ Î²) where\n  smul_comm _ _ _ := ext fun _ â†¦ (mul_smul_comm ..).symm\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass_2","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœâ¶ : PseudoMetricSpace ğ•œ\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : NonUnitalSeminormedRing Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : SMul ğ•œ Î²\ninstâœÂ¹ : BoundedSMul ğ•œ Î²\ninstâœ : SMulCommClass ğ•œ Î² Î²\nâŠ¢ SMulCommClass (BoundedContinuousFunction Î± Î²) ğ•œ (BoundedContinuousFunction Î± Î²)","decl":"instance [SMulCommClass ğ•œ Î² Î²] : SMulCommClass (Î± â†’áµ‡ Î²) ğ•œ (Î± â†’áµ‡ Î²) where\n  smul_comm _ _ _ := ext fun _ â†¦ mul_smul_comm ..\n\n"}
{"name":"BoundedContinuousFunction.algebraMap_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ³ : Type w\nğ•œ : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : NormedRing Î³\ninstâœ : NormedAlgebra ğ•œ Î³\nk : ğ•œ\na : Î±\nâŠ¢ Eq (((algebraMap ğ•œ (BoundedContinuousFunction Î± Î³)) k) a) (HSMul.hSMul k 1)","decl":"@[simp]\ntheorem algebraMap_apply (k : ğ•œ) (a : Î±) : algebraMap ğ•œ (Î± â†’áµ‡ Î³) k a = k â€¢ (1 : Î³) := by\n  simp only [Algebra.algebraMap_eq_smul_one, coe_smul, coe_one, Pi.one_apply]\n\n"}
{"name":"BoundedContinuousFunction.instBoundedSMul_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\nğ•œ : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup Î²\ninstâœ : NormedSpace ğ•œ Î²\nâŠ¢ BoundedSMul (BoundedContinuousFunction Î± ğ•œ) (BoundedContinuousFunction Î± Î²)","decl":"instance : BoundedSMul (Î± â†’áµ‡ ğ•œ) (Î± â†’áµ‡ Î²) :=\n  BoundedSMul.of_norm_smul_le fun _ _ =>\n    norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _\n\n"}
{"name":"BoundedContinuousFunction.NNReal.upper_bound","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± NNReal\nx : Î±\nâŠ¢ LE.le (f x) (NNDist.nndist f 0)","decl":"theorem NNReal.upper_bound {Î± : Type*} [TopologicalSpace Î±] (f : Î± â†’áµ‡ â„â‰¥0) (x : Î±) :\n    f x â‰¤ nndist f 0 := by\n  have key : nndist (f x) ((0 : Î± â†’áµ‡ â„â‰¥0) x) â‰¤ nndist f 0 := @dist_coe_le_dist Î± â„â‰¥0 _ _ f 0 x\n  simp only [coe_zero, Pi.zero_apply] at key\n  rwa [NNReal.nndist_zero_eq_val' (f x)] at key\n\n"}
{"name":"BoundedContinuousFunction.coe_sup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : NormedLatticeAddCommGroup Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(Max.max f g)) (Max.max â‡‘f â‡‘g)","decl":"@[simp, norm_cast] lemma coe_sup (f g : Î± â†’áµ‡ Î²) : â‡‘(f âŠ” g) = â‡‘f âŠ” â‡‘g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_inf","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : NormedLatticeAddCommGroup Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(Min.min f g)) (Min.min â‡‘f â‡‘g)","decl":"@[simp, norm_cast] lemma coe_inf (f g : Î± â†’áµ‡ Î²) : â‡‘(f âŠ“ g) = â‡‘f âŠ“ â‡‘g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_abs","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : NormedLatticeAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(abs f)) (abs â‡‘f)","decl":"@[simp, norm_cast] lemma coe_abs (f : Î± â†’áµ‡ Î²) : â‡‘|f| = |â‡‘f| := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_posPart","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : NormedLatticeAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(PosPart.posPart f)) (PosPart.posPart â‡‘f)","decl":"@[simp, norm_cast] lemma coe_posPart (f : Î± â†’áµ‡ Î²) : â‡‘fâº = (â‡‘f)âº := rfl\n"}
{"name":"BoundedContinuousFunction.coe_negPart","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\nÎ² : Type v\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : NormedLatticeAddCommGroup Î²\nf : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (â‡‘(NegPart.negPart f)) (NegPart.negPart â‡‘f)","decl":"@[simp, norm_cast] lemma coe_negPart (f : Î± â†’áµ‡ Î²) : â‡‘fâ» = (â‡‘f)â» := rfl\n\n\n"}
{"name":"BoundedContinuousFunction.nnrealPart_coeFn_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ Eq (â‡‘f.nnrealPart) (Function.comp Real.toNNReal â‡‘f)","decl":"@[simp]\ntheorem nnrealPart_coeFn_eq (f : Î± â†’áµ‡ â„) : â‡‘f.nnrealPart = Real.toNNReal âˆ˜ â‡‘f := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_coeFn_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ Eq (â‡‘f.nnnorm) (Function.comp NNNorm.nnnorm â‡‘f)","decl":"@[simp]\ntheorem nnnorm_coeFn_eq (f : Î± â†’áµ‡ â„) : â‡‘f.nnnorm = NNNorm.nnnorm âˆ˜ â‡‘f := rfl\n\n-- TODO: Use `posPart` and `negPart` here\n"}
{"name":"BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ Eq (â‡‘f) (HSub.hSub (Function.comp NNReal.toReal â‡‘f.nnrealPart) (Function.comp NNReal.toReal â‡‘(Neg.neg f).nnrealPart))","decl":"/-- Decompose a bounded continuous function to its positive and negative parts. -/\ntheorem self_eq_nnrealPart_sub_nnrealPart_neg (f : Î± â†’áµ‡ â„) :\n    â‡‘f = (â†‘) âˆ˜ f.nnrealPart - (â†‘) âˆ˜ (-f).nnrealPart := by\n  funext x\n  dsimp\n  simp only [max_zero_sub_max_neg_zero_eq_self]\n\n"}
{"name":"BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ Eq (Function.comp abs â‡‘f) (HAdd.hAdd (Function.comp NNReal.toReal â‡‘f.nnrealPart) (Function.comp NNReal.toReal â‡‘(Neg.neg f).nnrealPart))","decl":"/-- Express the absolute value of a bounded continuous function in terms of its\npositive and negative parts. -/\ntheorem abs_self_eq_nnrealPart_add_nnrealPart_neg (f : Î± â†’áµ‡ â„) :\n    abs âˆ˜ â‡‘f = (â†‘) âˆ˜ f.nnrealPart + (â†‘) âˆ˜ (-f).nnrealPart := by\n  funext x\n  dsimp\n  simp only [max_zero_add_max_neg_zero_eq_abs_self]\n\n"}
{"name":"BoundedContinuousFunction.add_norm_nonneg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ LE.le 0 (HAdd.hAdd f (BoundedContinuousFunction.const Î± (Norm.norm f)))","decl":"lemma add_norm_nonneg (f : Î± â†’áµ‡ â„) :\n    0 â‰¤ f + const _ â€–fâ€– := by\n  intro x\n  simp only [ContinuousMap.toFun_eq_coe, coe_toContinuousMap, coe_zero, Pi.zero_apply, coe_add,\n    const_apply, Pi.add_apply]\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).1]\n\n"}
{"name":"BoundedContinuousFunction.norm_sub_nonneg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"Î± : Type u_2\ninstâœ : TopologicalSpace Î±\nf : BoundedContinuousFunction Î± Real\nâŠ¢ LE.le 0 (HSub.hSub (BoundedContinuousFunction.const Î± (Norm.norm f)) f)","decl":"lemma norm_sub_nonneg (f : Î± â†’áµ‡ â„) :\n    0 â‰¤ const _ â€–fâ€– - f := by\n  intro x\n  simp only [ContinuousMap.toFun_eq_coe, coe_toContinuousMap, coe_zero, Pi.zero_apply, coe_sub,\n    const_apply, Pi.sub_apply, sub_nonneg]\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).2]\n\n"}
