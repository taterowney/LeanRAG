{"name":"BoundedContinuousFunction.mk.sizeOf_spec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoContinuousMap : ContinuousMap α β\nmap_bounded' : Exists fun C => ∀ (x y : α), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\n⊢ Eq (SizeOf.sizeOf { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toContinuousMap)) (SizeOf.sizeOf map_bounded'))","decl":"/-- `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : α →ᵇ β)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (α : Type u) (β : Type v) [TopologicalSpace α]\n    [PseudoMetricSpace β] extends ContinuousMap α β : Type max u v where\n  map_bounded' : ∃ C, ∀ x y, dist (toFun x) (toFun y) ≤ C\n\n"}
{"name":"BoundedContinuousFunction.map_bounded'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nself : BoundedContinuousFunction α β\n⊢ Exists fun C => ∀ (x y : α), LE.le (Dist.dist (self.toFun x) (self.toFun y)) C","decl":"/-- `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : α →ᵇ β)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (α : Type u) (β : Type v) [TopologicalSpace α]\n    [PseudoMetricSpace β] extends ContinuousMap α β : Type max u v where\n  map_bounded' : ∃ C, ∀ x y, dist (toFun x) (toFun y) ≤ C\n\n"}
{"name":"BoundedContinuousFunction.mk.injEq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\ntoContinuousMap✝ : ContinuousMap α β\nmap_bounded'✝ : Exists fun C => ∀ (x y : α), LE.le (Dist.dist (toContinuousMap✝.toFun x) (toContinuousMap✝.toFun y)) C\ntoContinuousMap : ContinuousMap α β\nmap_bounded' : Exists fun C => ∀ (x y : α), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\n⊢ Eq (Eq { toContinuousMap := toContinuousMap✝, map_bounded' := map_bounded'✝ } { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }) (Eq toContinuousMap✝ toContinuousMap)","decl":"/-- `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : α →ᵇ β)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (α : Type u) (β : Type v) [TopologicalSpace α]\n    [PseudoMetricSpace β] extends ContinuousMap α β : Type max u v where\n  map_bounded' : ∃ C, ∀ x y, dist (toFun x) (toFun y) ≤ C\n\n"}
{"name":"BoundedContinuousFunction.mk.inj","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\ntoContinuousMap✝ : ContinuousMap α β\nmap_bounded'✝ : Exists fun C => ∀ (x y : α), LE.le (Dist.dist (toContinuousMap✝.toFun x) (toContinuousMap✝.toFun y)) C\ntoContinuousMap : ContinuousMap α β\nmap_bounded' : Exists fun C => ∀ (x y : α), LE.le (Dist.dist (toContinuousMap.toFun x) (toContinuousMap.toFun y)) C\nx✝ : Eq { toContinuousMap := toContinuousMap✝, map_bounded' := map_bounded'✝ } { toContinuousMap := toContinuousMap, map_bounded' := map_bounded' }\n⊢ Eq toContinuousMap✝ toContinuousMap","decl":"/-- `α →ᵇ β` is the type of bounded continuous functions `α → β` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : α →ᵇ β)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. -/\nstructure BoundedContinuousFunction (α : Type u) (β : Type v) [TopologicalSpace α]\n    [PseudoMetricSpace β] extends ContinuousMap α β : Type max u v where\n  map_bounded' : ∃ C, ∀ x y, dist (toFun x) (toFun y) ≤ C\n\n"}
{"name":"BoundedContinuousMapClass.toContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"F : Type u_2\nα : outParam (Type u_3)\nβ : outParam (Type u_4)\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : FunLike F α β\nself : BoundedContinuousMapClass F α β\n⊢ ContinuousMapClass F α β","decl":"/-- `BoundedContinuousMapClass F α β` states that `F` is a type of bounded continuous maps.\n\nYou should also extend this typeclass when you extend `BoundedContinuousFunction`. -/\nclass BoundedContinuousMapClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α]\n    [PseudoMetricSpace β] [FunLike F α β] extends ContinuousMapClass F α β : Prop where\n  map_bounded (f : F) : ∃ C, ∀ x y, dist (f x) (f y) ≤ C\n\n"}
{"name":"BoundedContinuousMapClass.map_bounded","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"F : Type u_2\nα : outParam (Type u_3)\nβ : outParam (Type u_4)\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : FunLike F α β\nself : BoundedContinuousMapClass F α β\nf : F\n⊢ Exists fun C => ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) C","decl":"/-- `BoundedContinuousMapClass F α β` states that `F` is a type of bounded continuous maps.\n\nYou should also extend this typeclass when you extend `BoundedContinuousFunction`. -/\nclass BoundedContinuousMapClass (F : Type*) (α β : outParam Type*) [TopologicalSpace α]\n    [PseudoMetricSpace β] [FunLike F α β] extends ContinuousMapClass F α β : Prop where\n  map_bounded (f : F) : ∃ C, ∀ x y, dist (f x) (f y) ≤ C\n\n"}
{"name":"BoundedContinuousFunction.instBoundedContinuousMapClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ BoundedContinuousMapClass (BoundedContinuousFunction α β) α β","decl":"instance instBoundedContinuousMapClass : BoundedContinuousMapClass (α →ᵇ β) α β where\n  map_continuous f := f.continuous_toFun\n  map_bounded f := f.map_bounded'\n\n"}
{"name":"BoundedContinuousFunction.coe_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\n⊢ Eq ⇑f.toContinuousMap ⇑f","decl":"@[simp]\ntheorem coe_toContinuousMap (f : α →ᵇ β) : (f.toContinuousMap : α → β) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_to_continuous_fun","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\n⊢ Eq ⇑f.toContinuousMap ⇑f","decl":"@[deprecated (since := \"2024-11-23\")] alias coe_to_continuous_fun := coe_toContinuousMap\n\n"}
{"name":"BoundedContinuousFunction.bounded","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\n⊢ Exists fun C => ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) C","decl":"protected theorem bounded (f : α →ᵇ β) : ∃ C, ∀ x y : α, dist (f x) (f y) ≤ C :=\n  f.map_bounded'\n\n"}
{"name":"BoundedContinuousFunction.continuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\n⊢ Continuous ⇑f","decl":"protected theorem continuous (f : α →ᵇ β) : Continuous f :=\n  f.toContinuousMap.continuous\n\n"}
{"name":"BoundedContinuousFunction.ext_iff","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"BoundedContinuousFunction.ext","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"BoundedContinuousFunction.isBounded_range","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\n⊢ Bornology.IsBounded (Set.range ⇑f)","decl":"theorem isBounded_range (f : α →ᵇ β) : IsBounded (range f) :=\n  isBounded_range_iff.2 f.bounded\n\n"}
{"name":"BoundedContinuousFunction.isBounded_image","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\ns : Set α\n⊢ Bornology.IsBounded (Set.image (⇑f) s)","decl":"theorem isBounded_image (f : α →ᵇ β) (s : Set α) : IsBounded (f '' s) :=\n  f.isBounded_range.subset <| image_subset_range _ _\n\n"}
{"name":"BoundedContinuousFunction.eq_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nh : IsEmpty α\nf g : BoundedContinuousFunction α β\n⊢ Eq f g","decl":"theorem eq_of_empty [h : IsEmpty α] (f g : α →ᵇ β) : f = g :=\n  ext <| h.elim\n\n"}
{"name":"BoundedContinuousFunction.mkOfBound_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : ContinuousMap α β\nC : Real\nh : ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) C\n⊢ Eq ⇑(BoundedContinuousFunction.mkOfBound f C h) ⇑f","decl":"@[simp]\ntheorem mkOfBound_coe {f} {C} {h} : (mkOfBound f C h : α → β) = (f : α → β) := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : CompactSpace α\nf : ContinuousMap α β\na : α\n⊢ Eq ((BoundedContinuousFunction.mkOfCompact f) a) (f a)","decl":"@[simp]\ntheorem mkOfCompact_apply [CompactSpace α] (f : C(α, β)) (a : α) : mkOfCompact f a = f a := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfDiscrete_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : DiscreteTopology α\nf : α → β\nC : Real\nh : ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) C\na✝ : α\n⊢ Eq ((BoundedContinuousFunction.mkOfDiscrete f C h) a✝) (f a✝)","decl":"/-- If a function is bounded on a discrete space, it is automatically continuous,\nand therefore gives rise to an element of the type of bounded continuous functions. -/\n@[simps]\ndef mkOfDiscrete [DiscreteTopology α] (f : α → β) (C : ℝ) (h : ∀ x y : α, dist (f x) (f y) ≤ C) :\n    α →ᵇ β :=\n  ⟨⟨f, continuous_of_discreteTopology⟩, ⟨C, h⟩⟩\n\n"}
{"name":"BoundedContinuousFunction.dist_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Eq (Dist.dist f g) (InfSet.sInf (setOf fun C => And (LE.le 0 C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)))","decl":"theorem dist_eq : dist f g = sInf { C | 0 ≤ C ∧ ∀ x : α, dist (f x) (g x) ≤ C } := rfl\n\n"}
{"name":"BoundedContinuousFunction.dist_set_exists","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Exists fun C => And (LE.le 0 C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_set_exists : ∃ C, 0 ≤ C ∧ ∀ x : α, dist (f x) (g x) ≤ C := by\n  rcases isBounded_iff.1 (f.isBounded_range.union g.isBounded_range) with ⟨C, hC⟩\n  refine ⟨max 0 C, le_max_left _ _, fun x => (hC ?_ ?_).trans (le_max_right _ _)⟩\n    <;> [left; right]\n    <;> apply mem_range_self\n\n"}
{"name":"BoundedContinuousFunction.dist_coe_le_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nx : α\n⊢ LE.le (Dist.dist (f x) (g x)) (Dist.dist f g)","decl":"/-- The pointwise distance is controlled by the distance between functions, by definition. -/\ntheorem dist_coe_le_dist (x : α) : dist (f x) (g x) ≤ dist f g :=\n  le_csInf dist_set_exists fun _ hb => hb.2 x\n\n/- This lemma will be needed in the proof of the metric space instance, but it will become\nuseless afterwards as it will be superseded by the general result that the distance is nonnegative\nin metric spaces. -/\n"}
{"name":"BoundedContinuousFunction.dist_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nC : Real\nC0 : LE.le 0 C\n⊢ Iff (LE.le (Dist.dist f g) C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)","decl":"/-- The distance between two functions is controlled by the supremum of the pointwise distances. -/\ntheorem dist_le (C0 : (0 : ℝ) ≤ C) : dist f g ≤ C ↔ ∀ x : α, dist (f x) (g x) ≤ C :=\n  ⟨fun h x => le_trans (dist_coe_le_dist x) h, fun H => csInf_le ⟨0, fun _ => And.left⟩ ⟨C0, H⟩⟩\n\n"}
{"name":"BoundedContinuousFunction.dist_le_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nC : Real\ninst✝ : Nonempty α\n⊢ Iff (LE.le (Dist.dist f g) C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_le_iff_of_nonempty [Nonempty α] : dist f g ≤ C ↔ ∀ x, dist (f x) (g x) ≤ C :=\n  ⟨fun h x => le_trans (dist_coe_le_dist x) h,\n    fun w => (dist_le (le_trans dist_nonneg (w (Nonempty.some ‹_›)))).mpr w⟩\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nC : Real\ninst✝¹ : Nonempty α\ninst✝ : CompactSpace α\nw : ∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C\n⊢ LT.lt (Dist.dist f g) C","decl":"theorem dist_lt_of_nonempty_compact [Nonempty α] [CompactSpace α]\n    (w : ∀ x : α, dist (f x) (g x) < C) : dist f g < C := by\n  have c : Continuous fun x => dist (f x) (g x) := by continuity\n  obtain ⟨x, -, le⟩ :=\n    IsCompact.exists_isMaxOn isCompact_univ Set.univ_nonempty (Continuous.continuousOn c)\n  exact lt_of_le_of_lt (dist_le_iff_of_nonempty.mpr fun y => le trivial) (w x)\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_iff_of_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nC : Real\ninst✝ : CompactSpace α\nC0 : LT.lt 0 C\n⊢ Iff (LT.lt (Dist.dist f g) C) (∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_compact [CompactSpace α] (C0 : (0 : ℝ) < C) :\n    dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C := by\n  fconstructor\n  · intro w x\n    exact lt_of_le_of_lt (dist_coe_le_dist x) w\n  · by_cases h : Nonempty α\n    · exact dist_lt_of_nonempty_compact\n    · rintro -\n      convert C0\n      apply le_antisymm _ dist_nonneg'\n      rw [dist_eq]\n      exact csInf_le ⟨0, fun C => And.left⟩ ⟨le_rfl, fun x => False.elim (h (Nonempty.intro x))⟩\n\n"}
{"name":"BoundedContinuousFunction.dist_lt_iff_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nC : Real\ninst✝¹ : Nonempty α\ninst✝ : CompactSpace α\n⊢ Iff (LT.lt (Dist.dist f g) C) (∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_nonempty_compact [Nonempty α] [CompactSpace α] :\n    dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C :=\n  ⟨fun w x => lt_of_le_of_lt (dist_coe_le_dist x) w, dist_lt_of_nonempty_compact⟩\n\n"}
{"name":"BoundedContinuousFunction.nndist_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Eq (NNDist.nndist f g) (InfSet.sInf (setOf fun C => ∀ (x : α), LE.le (NNDist.nndist (f x) (g x)) C))","decl":"theorem nndist_eq : nndist f g = sInf { C | ∀ x : α, nndist (f x) (g x) ≤ C } :=\n  Subtype.ext <| dist_eq.trans <| by\n    rw [val_eq_coe, coe_sInf, coe_image]\n    simp_rw [mem_setOf_eq, ← NNReal.coe_le_coe, coe_mk, exists_prop, coe_nndist]\n\n"}
{"name":"BoundedContinuousFunction.nndist_set_exists","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Exists fun C => ∀ (x : α), LE.le (NNDist.nndist (f x) (g x)) C","decl":"theorem nndist_set_exists : ∃ C, ∀ x : α, nndist (f x) (g x) ≤ C :=\n  Subtype.exists.mpr <| dist_set_exists.imp fun _ ⟨ha, h⟩ => ⟨ha, h⟩\n\n"}
{"name":"BoundedContinuousFunction.nndist_coe_le_nndist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\nx : α\n⊢ LE.le (NNDist.nndist (f x) (g x)) (NNDist.nndist f g)","decl":"theorem nndist_coe_le_nndist (x : α) : nndist (f x) (g x) ≤ nndist f g :=\n  dist_coe_le_dist x\n\n"}
{"name":"BoundedContinuousFunction.dist_zero_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\ninst✝ : IsEmpty α\n⊢ Eq (Dist.dist f g) 0","decl":"/-- On an empty space, bounded continuous functions are at distance 0. -/\ntheorem dist_zero_of_empty [IsEmpty α] : dist f g = 0 := by\n  rw [(ext isEmptyElim : f = g), dist_self]\n\n"}
{"name":"BoundedContinuousFunction.dist_eq_iSup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Eq (Dist.dist f g) (iSup fun x => Dist.dist (f x) (g x))","decl":"theorem dist_eq_iSup : dist f g = ⨆ x : α, dist (f x) (g x) := by\n  cases isEmpty_or_nonempty α\n  · rw [iSup_of_empty', Real.sSup_empty, dist_zero_of_empty]\n  refine (dist_le_iff_of_nonempty.mpr <| le_ciSup ?_).antisymm (ciSup_le dist_coe_le_dist)\n  exact dist_set_exists.imp fun C hC => forall_mem_range.2 hC.2\n\n"}
{"name":"BoundedContinuousFunction.nndist_eq_iSup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Eq (NNDist.nndist f g) (iSup fun x => NNDist.nndist (f x) (g x))","decl":"theorem nndist_eq_iSup : nndist f g = ⨆ x : α, nndist (f x) (g x) :=\n  Subtype.ext <| dist_eq_iSup.trans <| by simp_rw [val_eq_coe, coe_iSup, coe_nndist]\n\n"}
{"name":"BoundedContinuousFunction.tendsto_iff_tendstoUniformly","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nι : Type u_2\nF : ι → BoundedContinuousFunction α β\nf : BoundedContinuousFunction α β\nl : Filter ι\n⊢ Iff (Filter.Tendsto F l (nhds f)) (TendstoUniformly (fun i => ⇑(F i)) (⇑f) l)","decl":"theorem tendsto_iff_tendstoUniformly {ι : Type*} {F : ι → α →ᵇ β} {f : α →ᵇ β} {l : Filter ι} :\n    Tendsto F l (𝓝 f) ↔ TendstoUniformly (fun i => F i) f l :=\n  Iff.intro\n    (fun h =>\n      tendstoUniformly_iff.2 fun ε ε0 =>\n        (Metric.tendsto_nhds.mp h ε ε0).mp\n          (Eventually.of_forall fun n hn x =>\n            lt_of_le_of_lt (dist_coe_le_dist x) (dist_comm (F n) f ▸ hn)))\n    fun h =>\n    Metric.tendsto_nhds.mpr fun _ ε_pos =>\n      (h _ (dist_mem_uniformity <| half_pos ε_pos)).mp\n        (Eventually.of_forall fun n hn =>\n          lt_of_le_of_lt\n            ((dist_le (half_pos ε_pos).le).mpr fun x => dist_comm (f x) (F n x) ▸ le_of_lt (hn x))\n            (half_lt_self ε_pos))\n\n"}
{"name":"BoundedContinuousFunction.isInducing_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Topology.IsInducing (Function.comp (⇑UniformFun.ofFun) DFunLike.coe)","decl":"/-- The topology on `α →ᵇ β` is exactly the topology induced by the natural map to `α →ᵤ β`. -/\ntheorem isInducing_coeFn : IsInducing (UniformFun.ofFun ∘ (⇑) : (α →ᵇ β) → α →ᵤ β) := by\n  rw [isInducing_iff_nhds]\n  refine fun f => eq_of_forall_le_iff fun l => ?_\n  rw [← tendsto_iff_comap, ← tendsto_id', tendsto_iff_tendstoUniformly,\n    UniformFun.tendsto_iff_tendstoUniformly]\n  simp [comp_def]\n\n"}
{"name":"BoundedContinuousFunction.inducing_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Topology.IsInducing (Function.comp (⇑UniformFun.ofFun) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_coeFn := isInducing_coeFn\n\n-- TODO: upgrade to `IsUniformEmbedding`\n"}
{"name":"BoundedContinuousFunction.isEmbedding_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Topology.IsEmbedding (Function.comp (⇑UniformFun.ofFun) DFunLike.coe)","decl":"theorem isEmbedding_coeFn : IsEmbedding (UniformFun.ofFun ∘ (⇑) : (α →ᵇ β) → α →ᵤ β) :=\n  ⟨isInducing_coeFn, fun _ _ h => ext fun x => congr_fun h x⟩\n\n"}
{"name":"BoundedContinuousFunction.embedding_coeFn","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Topology.IsEmbedding (Function.comp (⇑UniformFun.ofFun) DFunLike.coe)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coeFn := isEmbedding_coeFn\n\n"}
{"name":"BoundedContinuousFunction.const_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nb : β\n⊢ Eq ⇑(BoundedContinuousFunction.const α b) fun x => b","decl":"/-- Constant as a continuous bounded function. -/\n@[simps! (config := .asFn)]\ndef const (b : β) : α →ᵇ β :=\n  ⟨ContinuousMap.const α b, 0, by simp⟩\n\n"}
{"name":"BoundedContinuousFunction.const_apply'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\na : α\nb : β\n⊢ Eq ((BoundedContinuousFunction.const α b) a) b","decl":"theorem const_apply' (a : α) (b : β) : (const α b : α → β) a = b := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_evalx","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nx : α\n⊢ LipschitzWith 1 fun f => f x","decl":"theorem lipschitz_evalx (x : α) : LipschitzWith 1 fun f : α →ᵇ β => f x :=\n  LipschitzWith.mk_one fun _ _ => dist_coe_le_dist x\n\n"}
{"name":"BoundedContinuousFunction.uniformContinuous_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ UniformContinuous DFunLike.coe","decl":"theorem uniformContinuous_coe : @UniformContinuous (α →ᵇ β) (α → β) _ _ (⇑) :=\n  uniformContinuous_pi.2 fun x => (lipschitz_evalx x).uniformContinuous\n\n"}
{"name":"BoundedContinuousFunction.continuous_coe","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Continuous fun f x => f x","decl":"theorem continuous_coe : Continuous fun (f : α →ᵇ β) x => f x :=\n  UniformContinuous.continuous uniformContinuous_coe\n\n"}
{"name":"BoundedContinuousFunction.continuous_eval_const","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nx : α\n⊢ Continuous fun f => f x","decl":"/-- When `x` is fixed, `(f : α →ᵇ β) ↦ f x` is continuous. -/\n@[continuity]\ntheorem continuous_eval_const {x : α} : Continuous fun f : α →ᵇ β => f x :=\n  (continuous_apply x).comp continuous_coe\n\n"}
{"name":"BoundedContinuousFunction.continuous_eval","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Continuous fun p => p.1 p.2","decl":"/-- The evaluation map is continuous, as a joint function of `u` and `x`. -/\n@[continuity]\ntheorem continuous_eval : Continuous fun p : (α →ᵇ β) × α => p.1 p.2 :=\n  (continuous_prod_of_continuous_lipschitzWith _ 1 fun f => f.continuous) <| lipschitz_evalx\n\n"}
{"name":"BoundedContinuousFunction.instCompleteSpace","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : CompleteSpace β\n⊢ CompleteSpace (BoundedContinuousFunction α β)","decl":"/-- Bounded continuous functions taking values in a complete space form a complete space. -/\ninstance instCompleteSpace [CompleteSpace β] : CompleteSpace (α →ᵇ β) :=\n  complete_of_cauchySeq_tendsto fun (f : ℕ → α →ᵇ β) (hf : CauchySeq f) => by\n    /- We have to show that `f n` converges to a bounded continuous function.\n      For this, we prove pointwise convergence to define the limit, then check\n      it is a continuous bounded function, and then check the norm convergence. -/\n    rcases cauchySeq_iff_le_tendsto_0.1 hf with ⟨b, b0, b_bound, b_lim⟩\n    have f_bdd := fun x n m N hn hm => le_trans (dist_coe_le_dist x) (b_bound n m N hn hm)\n    have fx_cau : ∀ x, CauchySeq fun n => f n x :=\n      fun x => cauchySeq_iff_le_tendsto_0.2 ⟨b, b0, f_bdd x, b_lim⟩\n    choose F hF using fun x => cauchySeq_tendsto_of_complete (fx_cau x)\n    /- `F : α → β`, `hF : ∀ (x : α), Tendsto (fun n ↦ ↑(f n) x) atTop (𝓝 (F x))`\n      `F` is the desired limit function. Check that it is uniformly approximated by `f N`. -/\n    have fF_bdd : ∀ x N, dist (f N x) (F x) ≤ b N :=\n      fun x N => le_of_tendsto (tendsto_const_nhds.dist (hF x))\n        (Filter.eventually_atTop.2 ⟨N, fun n hn => f_bdd x N n N (le_refl N) hn⟩)\n    refine ⟨⟨⟨F, ?_⟩, ?_⟩, ?_⟩\n    · -- Check that `F` is continuous, as a uniform limit of continuous functions\n      have : TendstoUniformly (fun n x => f n x) F atTop := by\n        refine Metric.tendstoUniformly_iff.2 fun ε ε0 => ?_\n        refine ((tendsto_order.1 b_lim).2 ε ε0).mono fun n hn x => ?_\n        rw [dist_comm]\n        exact lt_of_le_of_lt (fF_bdd x n) hn\n      exact this.continuous (Eventually.of_forall fun N => (f N).continuous)\n    · -- Check that `F` is bounded\n      rcases (f 0).bounded with ⟨C, hC⟩\n      refine ⟨C + (b 0 + b 0), fun x y => ?_⟩\n      calc\n        dist (F x) (F y) ≤ dist (f 0 x) (f 0 y) + (dist (f 0 x) (F x) + dist (f 0 y) (F y)) :=\n          dist_triangle4_left _ _ _ _\n        _ ≤ C + (b 0 + b 0) := by mono\n    · -- Check that `F` is close to `f N` in distance terms\n      refine tendsto_iff_dist_tendsto_zero.2 (squeeze_zero (fun _ => dist_nonneg) ?_ b_lim)\n      exact fun N => (dist_le (b0 _)).2 fun x => fF_bdd x N\n\n"}
{"name":"BoundedContinuousFunction.coe_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nδ : Type u_2\ninst✝ : TopologicalSpace δ\nf : BoundedContinuousFunction α β\ng : ContinuousMap δ α\n⊢ Eq (⇑(f.compContinuous g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_compContinuous {δ : Type*} [TopologicalSpace δ] (f : α →ᵇ β) (g : C(δ, α)) :\n    ⇑(f.compContinuous g) = f ∘ g := rfl\n\n"}
{"name":"BoundedContinuousFunction.compContinuous_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nδ : Type u_2\ninst✝ : TopologicalSpace δ\nf : BoundedContinuousFunction α β\ng : ContinuousMap δ α\nx : δ\n⊢ Eq ((f.compContinuous g) x) (f (g x))","decl":"@[simp]\ntheorem compContinuous_apply {δ : Type*} [TopologicalSpace δ] (f : α →ᵇ β) (g : C(δ, α)) (x : δ) :\n    f.compContinuous g x = f (g x) := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nδ : Type u_2\ninst✝ : TopologicalSpace δ\ng : ContinuousMap δ α\n⊢ LipschitzWith 1 fun f => f.compContinuous g","decl":"theorem lipschitz_compContinuous {δ : Type*} [TopologicalSpace δ] (g : C(δ, α)) :\n    LipschitzWith 1 fun f : α →ᵇ β => f.compContinuous g :=\n  LipschitzWith.mk_one fun _ _ => (dist_le dist_nonneg).2 fun x => dist_coe_le_dist (g x)\n\n"}
{"name":"BoundedContinuousFunction.continuous_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\nδ : Type u_2\ninst✝ : TopologicalSpace δ\ng : ContinuousMap δ α\n⊢ Continuous fun f => f.compContinuous g","decl":"theorem continuous_compContinuous {δ : Type*} [TopologicalSpace δ] (g : C(δ, α)) :\n    Continuous fun f : α →ᵇ β => f.compContinuous g :=\n  (lipschitz_compContinuous g).continuous\n\n"}
{"name":"BoundedContinuousFunction.coe_restrict","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\ns : Set α\n⊢ Eq (⇑(f.restrict s)) (Function.comp (⇑f) Subtype.val)","decl":"@[simp]\ntheorem coe_restrict (f : α →ᵇ β) (s : Set α) : ⇑(f.restrict s) = f ∘ (↑) := rfl\n\n"}
{"name":"BoundedContinuousFunction.restrict_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : PseudoMetricSpace β\nf : BoundedContinuousFunction α β\ns : Set α\nx : ↑s\n⊢ Eq ((f.restrict s) x) (f ↑x)","decl":"@[simp]\ntheorem restrict_apply (f : α →ᵇ β) (s : Set α) (x : s) : f.restrict s x = f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.lipschitz_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : PseudoMetricSpace γ\nG : β → γ\nC : NNReal\nH : LipschitzWith C G\n⊢ LipschitzWith C (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is Lipschitz. -/\ntheorem lipschitz_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :\n    LipschitzWith C (comp G H : (α →ᵇ β) → α →ᵇ γ) :=\n  LipschitzWith.of_dist_le_mul fun f g =>\n    (dist_le (mul_nonneg C.2 dist_nonneg)).2 fun x =>\n      calc\n        dist (G (f x)) (G (g x)) ≤ C * dist (f x) (g x) := H.dist_le_mul _ _\n        _ ≤ C * dist f g := by gcongr; apply dist_coe_le_dist\n\n"}
{"name":"BoundedContinuousFunction.uniformContinuous_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : PseudoMetricSpace γ\nG : β → γ\nC : NNReal\nH : LipschitzWith C G\n⊢ UniformContinuous (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is uniformly continuous. -/\ntheorem uniformContinuous_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :\n    UniformContinuous (comp G H : (α →ᵇ β) → α →ᵇ γ) :=\n  (lipschitz_comp H).uniformContinuous\n\n"}
{"name":"BoundedContinuousFunction.continuous_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : PseudoMetricSpace γ\nG : β → γ\nC : NNReal\nH : LipschitzWith C G\n⊢ Continuous (BoundedContinuousFunction.comp G H)","decl":"/-- The composition operator (in the target) with a Lipschitz map is continuous. -/\ntheorem continuous_comp {G : β → γ} {C : ℝ≥0} (H : LipschitzWith C G) :\n    Continuous (comp G H : (α →ᵇ β) → α →ᵇ γ) :=\n  (lipschitz_comp H).continuous\n\n"}
{"name":"BoundedContinuousFunction.extend_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nδ : Type u_2\ninst✝¹ : TopologicalSpace δ\ninst✝ : DiscreteTopology δ\nf : Function.Embedding α δ\ng : BoundedContinuousFunction α β\nh : BoundedContinuousFunction δ β\nx : α\n⊢ Eq ((BoundedContinuousFunction.extend f g h) (f x)) (g x)","decl":"@[simp]\ntheorem extend_apply (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) (x : α) : extend f g h (f x) = g x :=\n  f.injective.extend_apply _ _ _\n\n"}
{"name":"BoundedContinuousFunction.extend_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nδ : Type u_2\ninst✝¹ : TopologicalSpace δ\ninst✝ : DiscreteTopology δ\nf : Function.Embedding α δ\ng : BoundedContinuousFunction α β\nh : BoundedContinuousFunction δ β\n⊢ Eq (Function.comp ⇑(BoundedContinuousFunction.extend f g h) ⇑f) ⇑g","decl":"@[simp]\nnonrec theorem extend_comp (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) : extend f g h ∘ f = g :=\n  extend_comp f.injective _ _\n\n"}
{"name":"BoundedContinuousFunction.extend_apply'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nδ : Type u_2\ninst✝¹ : TopologicalSpace δ\ninst✝ : DiscreteTopology δ\nf : Function.Embedding α δ\nx : δ\nhx : Not (Membership.mem (Set.range ⇑f) x)\ng : BoundedContinuousFunction α β\nh : BoundedContinuousFunction δ β\n⊢ Eq ((BoundedContinuousFunction.extend f g h) x) (h x)","decl":"nonrec theorem extend_apply' {f : α ↪ δ} {x : δ} (hx : x ∉ range f) (g : α →ᵇ β) (h : δ →ᵇ β) :\n    extend f g h x = h x :=\n  extend_apply' _ _ _ hx\n\n"}
{"name":"BoundedContinuousFunction.extend_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\nδ : Type u_2\ninst✝² : TopologicalSpace δ\ninst✝¹ : DiscreteTopology δ\ninst✝ : IsEmpty α\nf : Function.Embedding α δ\ng : BoundedContinuousFunction α β\nh : BoundedContinuousFunction δ β\n⊢ Eq (BoundedContinuousFunction.extend f g h) h","decl":"theorem extend_of_empty [IsEmpty α] (f : α ↪ δ) (g : α →ᵇ β) (h : δ →ᵇ β) : extend f g h = h :=\n  DFunLike.coe_injective <| Function.extend_of_isEmpty f g h\n\n"}
{"name":"BoundedContinuousFunction.dist_extend_extend","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nδ : Type u_2\ninst✝¹ : TopologicalSpace δ\ninst✝ : DiscreteTopology δ\nf : Function.Embedding α δ\ng₁ g₂ : BoundedContinuousFunction α β\nh₁ h₂ : BoundedContinuousFunction δ β\n⊢ Eq (Dist.dist (BoundedContinuousFunction.extend f g₁ h₁) (BoundedContinuousFunction.extend f g₂ h₂)) (Max.max (Dist.dist g₁ g₂) (Dist.dist (h₁.restrict (HasCompl.compl (Set.range ⇑f))) (h₂.restrict (HasCompl.compl (Set.range ⇑f)))))","decl":"@[simp]\ntheorem dist_extend_extend (f : α ↪ δ) (g₁ g₂ : α →ᵇ β) (h₁ h₂ : δ →ᵇ β) :\n    dist (g₁.extend f h₁) (g₂.extend f h₂) =\n      max (dist g₁ g₂) (dist (h₁.restrict (range f)ᶜ) (h₂.restrict (range f)ᶜ)) := by\n  refine le_antisymm ((dist_le <| le_max_iff.2 <| Or.inl dist_nonneg).2 fun x => ?_) (max_le ?_ ?_)\n  · rcases em (∃ y, f y = x) with (⟨x, rfl⟩ | hx)\n    · simp only [extend_apply]\n      exact (dist_coe_le_dist x).trans (le_max_left _ _)\n    · simp only [extend_apply' hx]\n      lift x to ((range f)ᶜ : Set δ) using hx\n      calc\n        dist (h₁ x) (h₂ x) = dist (h₁.restrict (range f)ᶜ x) (h₂.restrict (range f)ᶜ x) := rfl\n        _ ≤ dist (h₁.restrict (range f)ᶜ) (h₂.restrict (range f)ᶜ) := dist_coe_le_dist x\n        _ ≤ _ := le_max_right _ _\n  · refine (dist_le dist_nonneg).2 fun x => ?_\n    rw [← extend_apply f g₁ h₁, ← extend_apply f g₂ h₂]\n    exact dist_coe_le_dist _\n  · refine (dist_le dist_nonneg).2 fun x => ?_\n    calc\n      dist (h₁ x) (h₂ x) = dist (extend f g₁ h₁ x) (extend f g₂ h₂ x) := by\n        rw [extend_apply' x.coe_prop, extend_apply' x.coe_prop]\n      _ ≤ _ := dist_coe_le_dist _\n\n"}
{"name":"BoundedContinuousFunction.isometry_extend","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\nδ : Type u_2\ninst✝¹ : TopologicalSpace δ\ninst✝ : DiscreteTopology δ\nf : Function.Embedding α δ\nh : BoundedContinuousFunction δ β\n⊢ Isometry fun g => BoundedContinuousFunction.extend f g h","decl":"theorem isometry_extend (f : α ↪ δ) (h : δ →ᵇ β) : Isometry fun g : α →ᵇ β => extend f g h :=\n  Isometry.of_dist_eq fun g₁ g₂ => by simp [dist_nonneg]\n\n"}
{"name":"BoundedContinuousFunction.indicator_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\ns : Set α\nhs : IsClopen s\nx : α\n⊢ Eq ((BoundedContinuousFunction.indicator s hs) x) (s.indicator 1 x)","decl":"/-- The indicator function of a clopen set, as a bounded continuous function. -/\n@[simps]\nnoncomputable def indicator (s : Set α) (hs : IsClopen s) : BoundedContinuousFunction α ℝ where\n  toFun := s.indicator 1\n  continuous_toFun := continuous_indicator (by simp [hs]) <| continuous_const.continuousOn\n  map_bounded' := ⟨1, fun x y ↦ by by_cases hx : x ∈ s <;> by_cases hy : y ∈ s <;> simp [hx, hy]⟩\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoli₁","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : CompactSpace β\nA : Set (BoundedContinuousFunction α β)\nclosed : IsClosed A\nH : Equicontinuous fun x => ⇑↑x\n⊢ IsCompact A","decl":"/-- First version, with pointwise equicontinuity and range in a compact space. -/\ntheorem arzela_ascoli₁ [CompactSpace β] (A : Set (α →ᵇ β)) (closed : IsClosed A)\n    (H : Equicontinuous ((↑) : A → α → β)) : IsCompact A := by\n  simp_rw [Equicontinuous, Metric.equicontinuousAt_iff_pair] at H\n  refine isCompact_of_totallyBounded_isClosed ?_ closed\n  refine totallyBounded_of_finite_discretization fun ε ε0 => ?_\n  rcases exists_between ε0 with ⟨ε₁, ε₁0, εε₁⟩\n  let ε₂ := ε₁ / 2 / 2\n  /- We have to find a finite discretization of `u`, i.e., finite information\n    that is sufficient to reconstruct `u` up to `ε`. This information will be\n    provided by the values of `u` on a sufficiently dense set `tα`,\n    slightly translated to fit in a finite `ε₂`-dense set `tβ` in the image. Such\n    sets exist by compactness of the source and range. Then, to check that these\n    data determine the function up to `ε`, one uses the control on the modulus of\n    continuity to extend the closeness on tα to closeness everywhere. -/\n  have ε₂0 : ε₂ > 0 := half_pos (half_pos ε₁0)\n  have : ∀ x : α, ∃ U, x ∈ U ∧ IsOpen U ∧\n      ∀ y ∈ U, ∀ z ∈ U, ∀ {f : α →ᵇ β}, f ∈ A → dist (f y) (f z) < ε₂ := fun x =>\n    let ⟨U, nhdsU, hU⟩ := H x _ ε₂0\n    let ⟨V, VU, openV, xV⟩ := _root_.mem_nhds_iff.1 nhdsU\n    ⟨V, xV, openV, fun y hy z hz f hf => hU y (VU hy) z (VU hz) ⟨f, hf⟩⟩\n  choose U hU using this\n  /- For all `x`, the set `hU x` is an open set containing `x` on which the elements of `A`\n    fluctuate by at most `ε₂`.\n    We extract finitely many of these sets that cover the whole space, by compactness. -/\n  obtain ⟨tα : Set α, _, hfin, htα : univ ⊆ ⋃ x ∈ tα, U x⟩ :=\n    isCompact_univ.elim_finite_subcover_image (fun x _ => (hU x).2.1) fun x _ =>\n      mem_biUnion (mem_univ _) (hU x).1\n  rcases hfin.nonempty_fintype with ⟨_⟩\n  obtain ⟨tβ : Set β, _, hfin, htβ : univ ⊆ ⋃y ∈ tβ, ball y ε₂⟩ :=\n    @finite_cover_balls_of_compact β _ _ isCompact_univ _ ε₂0\n  rcases hfin.nonempty_fintype with ⟨_⟩\n  -- Associate to every point `y` in the space a nearby point `F y` in `tβ`\n  choose F hF using fun y => show ∃ z ∈ tβ, dist y z < ε₂ by simpa using htβ (mem_univ y)\n  -- `F : β → β`, `hF : ∀ (y : β), F y ∈ tβ ∧ dist y (F y) < ε₂`\n  /- Associate to every function a discrete approximation, mapping each point in `tα`\n    to a point in `tβ` close to its true image by the function. -/\n  classical\n  refine ⟨tα → tβ, by infer_instance, fun f a => ⟨F (f.1 a), (hF (f.1 a)).1⟩, ?_⟩\n  rintro ⟨f, hf⟩ ⟨g, hg⟩ f_eq_g\n  -- If two functions have the same approximation, then they are within distance `ε`\n  refine lt_of_le_of_lt ((dist_le <| le_of_lt ε₁0).2 fun x => ?_) εε₁\n  obtain ⟨x', x'tα, hx'⟩ := mem_iUnion₂.1 (htα (mem_univ x))\n  calc\n    dist (f x) (g x) ≤ dist (f x) (f x') + dist (g x) (g x') + dist (f x') (g x') :=\n      dist_triangle4_right _ _ _ _\n    _ ≤ ε₂ + ε₂ + ε₁ / 2 := by\n      refine le_of_lt (add_lt_add (add_lt_add ?_ ?_) ?_)\n      · exact (hU x').2.2 _ hx' _ (hU x').1 hf\n      · exact (hU x').2.2 _ hx' _ (hU x').1 hg\n      · have F_f_g : F (f x') = F (g x') :=\n          (congr_arg (fun f : tα → tβ => (f ⟨x', x'tα⟩ : β)) f_eq_g :)\n        calc\n          dist (f x') (g x') ≤ dist (f x') (F (f x')) + dist (g x') (F (f x')) :=\n            dist_triangle_right _ _ _\n          _ = dist (f x') (F (f x')) + dist (g x') (F (g x')) := by rw [F_f_g]\n          _ < ε₂ + ε₂ := (add_lt_add (hF (f x')).2 (hF (g x')).2)\n          _ = ε₁ / 2 := add_halves _\n    _ = ε₁ := by rw [add_halves, add_halves]\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoli₂","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\ns : Set β\nhs : IsCompact s\nA : Set (BoundedContinuousFunction α β)\nclosed : IsClosed A\nin_s : ∀ (f : BoundedContinuousFunction α β) (x : α), Membership.mem A f → Membership.mem s (f x)\nH : Equicontinuous fun x => ⇑↑x\n⊢ IsCompact A","decl":"/-- Second version, with pointwise equicontinuity and range in a compact subset. -/\ntheorem arzela_ascoli₂ (s : Set β) (hs : IsCompact s) (A : Set (α →ᵇ β)) (closed : IsClosed A)\n    (in_s : ∀ (f : α →ᵇ β) (x : α), f ∈ A → f x ∈ s) (H : Equicontinuous ((↑) : A → α → β)) :\n    IsCompact A := by\n  /- This version is deduced from the previous one by restricting to the compact type in the target,\n  using compactness there and then lifting everything to the original space. -/\n  have M : LipschitzWith 1 Subtype.val := LipschitzWith.subtype_val s\n  let F : (α →ᵇ s) → α →ᵇ β := comp (↑) M\n  refine IsCompact.of_isClosed_subset ((?_ : IsCompact (F ⁻¹' A)).image (continuous_comp M)) closed\n      fun f hf => ?_\n  · haveI : CompactSpace s := isCompact_iff_compactSpace.1 hs\n    refine arzela_ascoli₁ _ (continuous_iff_isClosed.1 (continuous_comp M) _ closed) ?_\n    rw [isUniformEmbedding_subtype_val.isUniformInducing.equicontinuous_iff]\n    exact H.comp (A.restrictPreimage F)\n  · let g := codRestrict s f fun x => in_s f x hf\n    rw [show f = F g by ext; rfl] at hf ⊢\n    exact ⟨g, hf, rfl⟩\n\n"}
{"name":"BoundedContinuousFunction.arzela_ascoli","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : T2Space β\ns : Set β\nhs : IsCompact s\nA : Set (BoundedContinuousFunction α β)\nin_s : ∀ (f : BoundedContinuousFunction α β) (x : α), Membership.mem A f → Membership.mem s (f x)\nH : Equicontinuous fun x => ⇑↑x\n⊢ IsCompact (closure A)","decl":"/-- Third (main) version, with pointwise equicontinuity and range in a compact subset, but\nwithout closedness. The closure is then compact. -/\ntheorem arzela_ascoli [T2Space β] (s : Set β) (hs : IsCompact s) (A : Set (α →ᵇ β))\n    (in_s : ∀ (f : α →ᵇ β) (x : α), f ∈ A → f x ∈ s) (H : Equicontinuous ((↑) : A → α → β)) :\n    IsCompact (closure A) :=\n  /- This version is deduced from the previous one by checking that the closure of `A`, in\n  addition to being closed, still satisfies the properties of compact range and equicontinuity. -/\n  arzela_ascoli₂ s hs (closure A) isClosed_closure\n    (fun _ x hf =>\n      (mem_of_closed' hs.isClosed).2 fun ε ε0 =>\n        let ⟨g, gA, dist_fg⟩ := Metric.mem_closure_iff.1 hf ε ε0\n        ⟨g x, in_s g x gA, lt_of_le_of_lt (dist_coe_le_dist _) dist_fg⟩)\n    (H.closure' continuous_coe)\n\n"}
{"name":"BoundedContinuousFunction.coe_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : Zero β\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : α →ᵇ β) : α → β) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : One β\n⊢ Eq (⇑1) 1","decl":"@[to_additive (attr := simp)]\ntheorem coe_one : ((1 : α →ᵇ β) : α → β) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Zero β\ninst✝ : CompactSpace α\n⊢ Eq (BoundedContinuousFunction.mkOfCompact 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem mkOfCompact_one [CompactSpace α] : mkOfCompact (1 : C(α, β)) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : One β\ninst✝ : CompactSpace α\n⊢ Eq (BoundedContinuousFunction.mkOfCompact 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem mkOfCompact_one [CompactSpace α] : mkOfCompact (1 : C(α, β)) = 1 := rfl\n\n"}
{"name":"BoundedContinuousFunction.forall_coe_one_iff_one","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : One β\nf : BoundedContinuousFunction α β\n⊢ Iff (∀ (x : α), Eq (f x) 1) (Eq f 1)","decl":"@[to_additive]\ntheorem forall_coe_one_iff_one (f : α →ᵇ β) : (∀ x, f x = 1) ↔ f = 1 :=\n  (@DFunLike.ext_iff _ _ _ _ f 1).symm\n\n"}
{"name":"BoundedContinuousFunction.forall_coe_zero_iff_zero","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : Zero β\nf : BoundedContinuousFunction α β\n⊢ Iff (∀ (x : α), Eq (f x) 0) (Eq f 0)","decl":"@[to_additive]\ntheorem forall_coe_one_iff_one (f : α →ᵇ β) : (∀ x, f x = 1) ↔ f = 1 :=\n  (@DFunLike.ext_iff _ _ _ _ f 1).symm\n\n"}
{"name":"BoundedContinuousFunction.one_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : One β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap γ α\n⊢ Eq (BoundedContinuousFunction.compContinuous 1 f) 1","decl":"@[to_additive (attr := simp)]\ntheorem one_compContinuous [TopologicalSpace γ] (f : C(γ, α)) : (1 : α →ᵇ β).compContinuous f = 1 :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.zero_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Zero β\ninst✝ : TopologicalSpace γ\nf : ContinuousMap γ α\n⊢ Eq (BoundedContinuousFunction.compContinuous 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem one_compContinuous [TopologicalSpace γ] (f : C(γ, α)) : (1 : α →ᵇ β).compContinuous f = 1 :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_add","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nf g : BoundedContinuousFunction α β\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_add : ⇑(f + g) = f + g := rfl\n\n"}
{"name":"BoundedContinuousFunction.add_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nf g : BoundedContinuousFunction α β\nx : α\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"theorem add_apply : (f + g) x = f x + g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_add","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : AddMonoid β\ninst✝² : BoundedAdd β\ninst✝¹ : ContinuousAdd β\ninst✝ : CompactSpace α\nf g : ContinuousMap α β\n⊢ Eq (BoundedContinuousFunction.mkOfCompact (HAdd.hAdd f g)) (HAdd.hAdd (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g))","decl":"@[simp]\ntheorem mkOfCompact_add [CompactSpace α] (f g : C(α, β)) :\n    mkOfCompact (f + g) = mkOfCompact f + mkOfCompact g := rfl\n\n"}
{"name":"BoundedContinuousFunction.add_compContinuous","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : AddMonoid β\ninst✝² : BoundedAdd β\ninst✝¹ : ContinuousAdd β\nf g : BoundedContinuousFunction α β\ninst✝ : TopologicalSpace γ\nh : ContinuousMap γ α\n⊢ Eq ((HAdd.hAdd g f).compContinuous h) (HAdd.hAdd (g.compContinuous h) (f.compContinuous h))","decl":"theorem add_compContinuous [TopologicalSpace γ] (h : C(γ, α)) :\n    (g + f).compContinuous h = g.compContinuous h + f.compContinuous h := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_nsmulRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nf : BoundedContinuousFunction α β\nn : Nat\n⊢ Eq (⇑(nsmulRec n f)) (HSMul.hSMul n ⇑f)","decl":"@[simp]\ntheorem coe_nsmulRec : ∀ n, ⇑(nsmulRec n f) = n • ⇑f\n  | 0 => by rw [nsmulRec, zero_smul, coe_zero]\n  | n + 1 => by rw [nsmulRec, succ_nsmul, coe_add, coe_nsmulRec n]\n\n"}
{"name":"BoundedContinuousFunction.coe_nsmul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nr : Nat\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(HSMul.hSMul r f)) (HSMul.hSMul r ⇑f)","decl":"@[simp]\ntheorem coe_nsmul (r : ℕ) (f : α →ᵇ β) : ⇑(r • f) = r • ⇑f := rfl\n\n"}
{"name":"BoundedContinuousFunction.nsmul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nr : Nat\nf : BoundedContinuousFunction α β\nv : α\n⊢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem nsmul_apply (r : ℕ) (f : α →ᵇ β) (v : α) : (r • f) v = r • f v := rfl\n\n"}
{"name":"BoundedContinuousFunction.coeFnAddHom_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\na✝ : BoundedContinuousFunction α β\na : α\n⊢ Eq (BoundedContinuousFunction.coeFnAddHom a✝ a) (a✝ a)","decl":"/-- Coercion of a `NormedAddGroupHom` is an `AddMonoidHom`. Similar to `AddMonoidHom.coeFn`. -/\n@[simps]\ndef coeFnAddHom : (α →ᵇ β) →+ α → β where\n  toFun := (⇑)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"BoundedContinuousFunction.toContinuousMapAddHom_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nself : BoundedContinuousFunction α β\n⊢ Eq ((BoundedContinuousFunction.toContinuousMapAddHom α β) self) self.toContinuousMap","decl":"/-- The additive map forgetting that a bounded continuous function is bounded. -/\n@[simps]\ndef toContinuousMapAddHom : (α →ᵇ β) →+ C(α, β) where\n  toFun := toContinuousMap\n  map_zero' := rfl\n  map_add' := by\n    intros\n    ext\n    simp\n\n"}
{"name":"BoundedContinuousFunction.coe_sum","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddCommMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nι : Type u_2\ns : Finset ι\nf : ι → BoundedContinuousFunction α β\n⊢ Eq (⇑(s.sum fun i => f i)) (s.sum fun i => ⇑(f i))","decl":"@[simp]\ntheorem coe_sum {ι : Type*} (s : Finset ι) (f : ι → α →ᵇ β) :\n    ⇑(∑ i ∈ s, f i) = ∑ i ∈ s, (f i : α → β) :=\n  map_sum coeFnAddHom f s\n\n"}
{"name":"BoundedContinuousFunction.sum_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : AddCommMonoid β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nι : Type u_2\ns : Finset ι\nf : ι → BoundedContinuousFunction α β\na : α\n⊢ Eq ((s.sum fun i => f i) a) (s.sum fun i => (f i) a)","decl":"theorem sum_apply {ι : Type*} (s : Finset ι) (f : ι → α →ᵇ β) (a : α) :\n    (∑ i ∈ s, f i) a = ∑ i ∈ s, f i a := by simp\n\n"}
{"name":"BoundedContinuousFunction.instLipschitzAdd","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\n⊢ LipschitzAdd (BoundedContinuousFunction α β)","decl":"instance instLipschitzAdd : LipschitzAdd (α →ᵇ β) where\n  lipschitz_add :=\n    ⟨LipschitzAdd.C β, by\n      have C_nonneg := (LipschitzAdd.C β).coe_nonneg\n      rw [lipschitzWith_iff_dist_le_mul]\n      rintro ⟨f₁, g₁⟩ ⟨f₂, g₂⟩\n      rw [dist_le (mul_nonneg C_nonneg dist_nonneg)]\n      intro x\n      refine le_trans (lipschitz_with_lipschitz_const_add ⟨f₁ x, g₁ x⟩ ⟨f₂ x, g₂ x⟩) ?_\n      refine mul_le_mul_of_nonneg_left ?_ C_nonneg\n      apply max_le_max <;> exact dist_coe_le_dist x⟩\n\n"}
{"name":"BoundedContinuousFunction.sub_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Sub R\ninst✝¹ : BoundedSub R\ninst✝ : ContinuousSub R\nf g : BoundedContinuousFunction α R\nx : α\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"theorem sub_apply {x : α} : (f - g) x = f x - g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_sub","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Sub R\ninst✝¹ : BoundedSub R\ninst✝ : ContinuousSub R\nf g : BoundedContinuousFunction α R\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_sub : ⇑(f - g) = f - g := rfl\n\n"}
{"name":"BoundedContinuousFunction.natCast_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nβ : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : NatCast β\nn : Nat\nx : α\n⊢ Eq (↑n x) ↑n","decl":"@[simp]\ntheorem natCast_apply [NatCast β] (n : ℕ) (x : α) : (n : α →ᵇ β) x = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.intCast_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nβ : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : IntCast β\nm : Int\nx : α\n⊢ Eq (↑m x) ↑m","decl":"@[simp]\ntheorem intCast_apply [IntCast β] (m : ℤ) (x : α) : (m : α →ᵇ β) x = m := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_mul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Mul R\ninst✝¹ : BoundedMul R\ninst✝ : ContinuousMul R\nf g : BoundedContinuousFunction α R\n⊢ Eq (⇑(HMul.hMul f g)) (HMul.hMul ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul [Mul R] [BoundedMul R] [ContinuousMul R] (f g : α →ᵇ R) : ⇑(f * g) = f * g := rfl\n\n"}
{"name":"BoundedContinuousFunction.mul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Mul R\ninst✝¹ : BoundedMul R\ninst✝ : ContinuousMul R\nf g : BoundedContinuousFunction α R\nx : α\n⊢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"theorem mul_apply [Mul R] [BoundedMul R] [ContinuousMul R] (f g : α →ᵇ R) (x : α) :\n    (f * g) x = f x * g x := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_pow","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Monoid R\ninst✝¹ : BoundedMul R\ninst✝ : ContinuousMul R\nn : Nat\nf : BoundedContinuousFunction α R\n⊢ Eq (⇑(HPow.hPow f n)) (HPow.hPow (⇑f) n)","decl":"theorem coe_pow [Monoid R] [BoundedMul R] [ContinuousMul R] (n : ℕ) (f : α →ᵇ R) :\n    ⇑(f ^ n) = (⇑f) ^ n := rfl\n\n"}
{"name":"BoundedContinuousFunction.pow_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝⁴ : TopologicalSpace α\nR : Type u_2\ninst✝³ : PseudoMetricSpace R\ninst✝² : Monoid R\ninst✝¹ : BoundedMul R\ninst✝ : ContinuousMul R\nn : Nat\nf : BoundedContinuousFunction α R\nx : α\n⊢ Eq ((HPow.hPow f n) x) (HPow.hPow (f x) n)","decl":"@[simp]\ntheorem pow_apply [Monoid R] [BoundedMul R] [ContinuousMul R] (n : ℕ) (f : α →ᵇ R) (x : α) :\n    (f ^ n) x = f x ^ n := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_def","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (Norm.norm f) (Dist.dist f 0)","decl":"theorem norm_def : ‖f‖ = dist f 0 := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (Norm.norm f) (InfSet.sInf (setOf fun C => And (LE.le 0 C) (∀ (x : α), LE.le (Norm.norm (f x)) C)))","decl":"/-- The norm of a bounded continuous function is the supremum of `‖f x‖`.\nWe use `sInf` to ensure that the definition works if `α` has no elements. -/\ntheorem norm_eq (f : α →ᵇ β) : ‖f‖ = sInf { C : ℝ | 0 ≤ C ∧ ∀ x : α, ‖f x‖ ≤ C } := by\n  simp [norm_def, BoundedContinuousFunction.dist_eq]\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nh : Nonempty α\n⊢ Eq (Norm.norm f) (InfSet.sInf (setOf fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C))","decl":"/-- When the domain is non-empty, we do not need the `0 ≤ C` condition in the formula for `‖f‖` as a\n`sInf`. -/\ntheorem norm_eq_of_nonempty [h : Nonempty α] : ‖f‖ = sInf { C : ℝ | ∀ x : α, ‖f x‖ ≤ C } := by\n  obtain ⟨a⟩ := h\n  rw [norm_eq]\n  congr\n  ext\n  simp only [mem_setOf_eq, and_iff_right_iff_imp]\n  exact fun h' => le_trans (norm_nonneg (f a)) (h' a)\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_zero_of_empty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\ninst✝ : IsEmpty α\n⊢ Eq (Norm.norm f) 0","decl":"@[simp]\ntheorem norm_eq_zero_of_empty [IsEmpty α] : ‖f‖ = 0 :=\n  dist_zero_of_empty\n\n"}
{"name":"BoundedContinuousFunction.norm_coe_le_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nx : α\n⊢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"theorem norm_coe_le_norm (x : α) : ‖f x‖ ≤ ‖f‖ :=\n  calc\n    ‖f x‖ = dist (f x) ((0 : α →ᵇ β) x) := by simp [dist_zero_right]\n    _ ≤ ‖f‖ := dist_coe_le_dist _\n\n"}
{"name":"BoundedContinuousFunction.neg_norm_le_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\nx : α\n⊢ LE.le (Neg.neg (Norm.norm f)) (f x)","decl":"lemma neg_norm_le_apply (f : α →ᵇ ℝ) (x : α) :\n    -‖f‖ ≤ f x := (abs_le.mp (norm_coe_le_norm f x)).1\n\n"}
{"name":"BoundedContinuousFunction.apply_le_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\nx : α\n⊢ LE.le (f x) (Norm.norm f)","decl":"lemma apply_le_norm (f : α →ᵇ ℝ) (x : α) :\n    f x ≤ ‖f‖ := (abs_le.mp (norm_coe_le_norm f x)).2\n\n"}
{"name":"BoundedContinuousFunction.dist_le_two_norm'","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"β : Type v\nγ : Type w\ninst✝ : SeminormedAddCommGroup β\nf : γ → β\nC : Real\nhC : ∀ (x : γ), LE.le (Norm.norm (f x)) C\nx y : γ\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 C)","decl":"theorem dist_le_two_norm' {f : γ → β} {C : ℝ} (hC : ∀ x, ‖f x‖ ≤ C) (x y : γ) :\n    dist (f x) (f y) ≤ 2 * C :=\n  calc\n    dist (f x) (f y) ≤ ‖f x‖ + ‖f y‖ := dist_le_norm_add_norm _ _\n    _ ≤ C + C := add_le_add (hC x) (hC y)\n    _ = 2 * C := (two_mul _).symm\n\n"}
{"name":"BoundedContinuousFunction.dist_le_two_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nx y : α\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 (Norm.norm f))","decl":"/-- Distance between the images of any two points is at most twice the norm of the function. -/\ntheorem dist_le_two_norm (x y : α) : dist (f x) (f y) ≤ 2 * ‖f‖ :=\n  dist_le_two_norm' f.norm_coe_le_norm x y\n\n"}
{"name":"BoundedContinuousFunction.norm_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nC : Real\nC0 : LE.le 0 C\n⊢ Iff (LE.le (Norm.norm f) C) (∀ (x : α), LE.le (Norm.norm (f x)) C)","decl":"/-- The norm of a function is controlled by the supremum of the pointwise norms. -/\ntheorem norm_le (C0 : (0 : ℝ) ≤ C) : ‖f‖ ≤ C ↔ ∀ x : α, ‖f x‖ ≤ C := by\n  simpa using @dist_le _ _ _ _ f 0 _ C0\n\n"}
{"name":"BoundedContinuousFunction.norm_le_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : Nonempty α\nf : BoundedContinuousFunction α β\nM : Real\n⊢ Iff (LE.le (Norm.norm f) M) (∀ (x : α), LE.le (Norm.norm (f x)) M)","decl":"theorem norm_le_of_nonempty [Nonempty α] {f : α →ᵇ β} {M : ℝ} : ‖f‖ ≤ M ↔ ∀ x, ‖f x‖ ≤ M := by\n  simp_rw [norm_def, ← dist_zero_right]\n  exact dist_le_iff_of_nonempty\n\n"}
{"name":"BoundedContinuousFunction.norm_lt_iff_of_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : CompactSpace α\nf : BoundedContinuousFunction α β\nM : Real\nM0 : LT.lt 0 M\n⊢ Iff (LT.lt (Norm.norm f) M) (∀ (x : α), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_compact [CompactSpace α] {f : α →ᵇ β} {M : ℝ} (M0 : 0 < M) :\n    ‖f‖ < M ↔ ∀ x, ‖f x‖ < M := by\n  simp_rw [norm_def, ← dist_zero_right]\n  exact dist_lt_iff_of_compact M0\n\n"}
{"name":"BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : TopologicalSpace α\ninst✝² : SeminormedAddCommGroup β\ninst✝¹ : Nonempty α\ninst✝ : CompactSpace α\nf : BoundedContinuousFunction α β\nM : Real\n⊢ Iff (LT.lt (Norm.norm f) M) (∀ (x : α), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_nonempty_compact [Nonempty α] [CompactSpace α] {f : α →ᵇ β} {M : ℝ} :\n    ‖f‖ < M ↔ ∀ x, ‖f x‖ < M := by\n  simp_rw [norm_def, ← dist_zero_right]\n  exact dist_lt_iff_of_nonempty_compact\n\n"}
{"name":"BoundedContinuousFunction.norm_const_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nb : β\n⊢ LE.le (Norm.norm (BoundedContinuousFunction.const α b)) (Norm.norm b)","decl":"/-- Norm of `const α b` is less than or equal to `‖b‖`. If `α` is nonempty,\nthen it is equal to `‖b‖`. -/\ntheorem norm_const_le (b : β) : ‖const α b‖ ≤ ‖b‖ :=\n  (norm_le (norm_nonneg b)).2 fun _ => le_rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_const_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nh : Nonempty α\nb : β\n⊢ Eq (Norm.norm (BoundedContinuousFunction.const α b)) (Norm.norm b)","decl":"@[simp]\ntheorem norm_const_eq [h : Nonempty α] (b : β) : ‖const α b‖ = ‖b‖ :=\n  le_antisymm (norm_const_le b) <| h.elim fun x => (const α b).norm_coe_le_norm x\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNormedAddCommGroup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nHf : Continuous f\nC : Real\nH : ∀ (x : α), LE.le (Norm.norm (f x)) C\n⊢ Eq (⇑(BoundedContinuousFunction.ofNormedAddCommGroup f Hf C H)) f","decl":"@[simp]\ntheorem coe_ofNormedAddCommGroup {α : Type u} {β : Type v} [TopologicalSpace α]\n    [SeminormedAddCommGroup β] (f : α → β) (Hf : Continuous f) (C : ℝ) (H : ∀ x, ‖f x‖ ≤ C) :\n    (ofNormedAddCommGroup f Hf C H : α → β) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_ofNormedAddCommGroup_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nhfc : Continuous f\nC : Real\nhC : LE.le 0 C\nhfC : ∀ (x : α), LE.le (Norm.norm (f x)) C\n⊢ LE.le (Norm.norm (BoundedContinuousFunction.ofNormedAddCommGroup f hfc C hfC)) C","decl":"theorem norm_ofNormedAddCommGroup_le {f : α → β} (hfc : Continuous f) {C : ℝ} (hC : 0 ≤ C)\n    (hfC : ∀ x, ‖f x‖ ≤ C) : ‖ofNormedAddCommGroup f hfc C hfC‖ ≤ C :=\n  (norm_le hC).2 hfC\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNormedAddCommGroupDiscrete","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : DiscreteTopology α\ninst✝ : SeminormedAddCommGroup β\nf : α → β\nC : Real\nH : ∀ (x : α), LE.le (Norm.norm (f x)) C\n⊢ Eq (⇑(BoundedContinuousFunction.ofNormedAddCommGroupDiscrete f C H)) f","decl":"@[simp]\ntheorem coe_ofNormedAddCommGroupDiscrete {α : Type u} {β : Type v} [TopologicalSpace α]\n    [DiscreteTopology α] [SeminormedAddCommGroup β] (f : α → β) (C : ℝ) (H : ∀ x, ‖f x‖ ≤ C) :\n    (ofNormedAddCommGroupDiscrete f C H : α → β) = f := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_normComp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑f.normComp) (Function.comp Norm.norm ⇑f)","decl":"@[simp]\ntheorem coe_normComp : (f.normComp : α → ℝ) = norm ∘ f := rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_normComp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (Norm.norm f.normComp) (Norm.norm f)","decl":"@[simp]\ntheorem norm_normComp : ‖f.normComp‖ = ‖f‖ := by\n  simp only [norm_eq, coe_normComp, norm_norm, Function.comp]\n\n"}
{"name":"BoundedContinuousFunction.bddAbove_range_norm_comp","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ BddAbove (Set.range (Function.comp Norm.norm ⇑f))","decl":"theorem bddAbove_range_norm_comp : BddAbove <| Set.range <| norm ∘ f :=\n  (@isBounded_range _ _ _ _ f.normComp).bddAbove\n\n"}
{"name":"BoundedContinuousFunction.norm_eq_iSup_norm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (Norm.norm f) (iSup fun x => Norm.norm (f x))","decl":"theorem norm_eq_iSup_norm : ‖f‖ = ⨆ x : α, ‖f x‖ := by\n  simp_rw [norm_def, dist_eq_iSup, coe_zero, Pi.zero_apply, dist_zero_right]\n\n"}
{"name":"BoundedContinuousFunction.instNormOneClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝⁴ : TopologicalSpace α\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : Nonempty α\ninst✝¹ : One β\ninst✝ : NormOneClass β\n⊢ NormOneClass (BoundedContinuousFunction α β)","decl":"/-- If `‖(1 : β)‖ = 1`, then `‖(1 : α →ᵇ β)‖ = 1` if `α` is nonempty. -/\ninstance instNormOneClass [Nonempty α] [One β] [NormOneClass β] : NormOneClass (α →ᵇ β) where\n  norm_one := by simp only [norm_eq_iSup_norm, coe_one, Pi.one_apply, norm_one, ciSup_const]\n\n"}
{"name":"BoundedContinuousFunction.coe_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp]\ntheorem coe_neg : ⇑(-f) = -f := rfl\n\n"}
{"name":"BoundedContinuousFunction.neg_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nx : α\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"theorem neg_apply : (-f) x = -f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : CompactSpace α\nf : ContinuousMap α β\n⊢ Eq (BoundedContinuousFunction.mkOfCompact (Neg.neg f)) (Neg.neg (BoundedContinuousFunction.mkOfCompact f))","decl":"@[simp]\ntheorem mkOfCompact_neg [CompactSpace α] (f : C(α, β)) : mkOfCompact (-f) = -mkOfCompact f := rfl\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_sub","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : CompactSpace α\nf g : ContinuousMap α β\n⊢ Eq (BoundedContinuousFunction.mkOfCompact (HSub.hSub f g)) (HSub.hSub (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g))","decl":"@[simp]\ntheorem mkOfCompact_sub [CompactSpace α] (f g : C(α, β)) :\n    mkOfCompact (f - g) = mkOfCompact f - mkOfCompact g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_zsmulRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nz : Int\n⊢ Eq (⇑(zsmulRec (fun x1 x2 => HSMul.hSMul x1 x2) z f)) (HSMul.hSMul z ⇑f)","decl":"@[simp]\ntheorem coe_zsmulRec : ∀ z, ⇑(zsmulRec (· • ·) z f) = z • ⇑f\n  | Int.ofNat n => by rw [zsmulRec, Int.ofNat_eq_coe, coe_nsmul, natCast_zsmul]\n  | Int.negSucc n => by rw [zsmulRec, negSucc_zsmul, coe_neg, coe_nsmul]\n\n"}
{"name":"BoundedContinuousFunction.coe_zsmul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nr : Int\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(HSMul.hSMul r f)) (HSMul.hSMul r ⇑f)","decl":"@[simp]\ntheorem coe_zsmul (r : ℤ) (f : α →ᵇ β) : ⇑(r • f) = r • ⇑f := rfl\n\n"}
{"name":"BoundedContinuousFunction.zsmul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nr : Int\nf : BoundedContinuousFunction α β\nv : α\n⊢ Eq ((HSMul.hSMul r f) v) (HSMul.hSMul r (f v))","decl":"@[simp]\ntheorem zsmul_apply (r : ℤ) (f : α →ᵇ β) (v : α) : (r • f) v = r • f v := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_def","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (NNNorm.nnnorm f) (NNDist.nndist f 0)","decl":"theorem nnnorm_def : ‖f‖₊ = nndist f 0 := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_coe_le_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nx : α\n⊢ LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm f)","decl":"theorem nnnorm_coe_le_nnnorm (x : α) : ‖f x‖₊ ≤ ‖f‖₊ :=\n  norm_coe_le_norm _ _\n\n"}
{"name":"BoundedContinuousFunction.nndist_le_two_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nx y : α\n⊢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul 2 (NNNorm.nnnorm f))","decl":"theorem nndist_le_two_nnnorm (x y : α) : nndist (f x) (f y) ≤ 2 * ‖f‖₊ :=\n  dist_le_two_norm _ _ _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\nC : NNReal\n⊢ Iff (LE.le (NNNorm.nnnorm f) C) (∀ (x : α), LE.le (NNNorm.nnnorm (f x)) C)","decl":"/-- The `nnnorm` of a function is controlled by the supremum of the pointwise `nnnorm`s. -/\ntheorem nnnorm_le (C : ℝ≥0) : ‖f‖₊ ≤ C ↔ ∀ x : α, ‖f x‖₊ ≤ C :=\n  norm_le C.prop\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_const_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nb : β\n⊢ LE.le (NNNorm.nnnorm (BoundedContinuousFunction.const α b)) (NNNorm.nnnorm b)","decl":"theorem nnnorm_const_le (b : β) : ‖const α b‖₊ ≤ ‖b‖₊ :=\n  norm_const_le _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_const_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : Nonempty α\nb : β\n⊢ Eq (NNNorm.nnnorm (BoundedContinuousFunction.const α b)) (NNNorm.nnnorm b)","decl":"@[simp]\ntheorem nnnorm_const_eq [Nonempty α] (b : β) : ‖const α b‖₊ = ‖b‖₊ :=\n  Subtype.ext <| norm_const_eq _\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_eq_iSup_nnnorm","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (NNNorm.nnnorm f) (iSup fun x => NNNorm.nnnorm (f x))","decl":"theorem nnnorm_eq_iSup_nnnorm : ‖f‖₊ = ⨆ x : α, ‖f x‖₊ :=\n  Subtype.ext <| (norm_eq_iSup_norm f).trans <| by simp_rw [val_eq_coe, NNReal.coe_iSup, coe_nnnorm]\n\n"}
{"name":"BoundedContinuousFunction.abs_diff_coe_le_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : SeminormedAddCommGroup β\nf g : BoundedContinuousFunction α β\nx : α\n⊢ LE.le (Norm.norm (HSub.hSub (f x) (g x))) (Dist.dist f g)","decl":"theorem abs_diff_coe_le_dist : ‖f x - g x‖ ≤ dist f g := by\n  rw [dist_eq_norm]\n  exact (f - g).norm_coe_le_norm x\n\n"}
{"name":"BoundedContinuousFunction.coe_le_coe_add_dist","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nx : α\nf g : BoundedContinuousFunction α Real\n⊢ LE.le (f x) (HAdd.hAdd (g x) (Dist.dist f g))","decl":"theorem coe_le_coe_add_dist {f g : α →ᵇ ℝ} : f x ≤ g x + dist f g :=\n  sub_le_iff_le_add'.1 <| (abs_le.1 <| @dist_coe_le_dist _ _ _ _ f g x).2\n\n"}
{"name":"BoundedContinuousFunction.norm_compContinuous_le","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : TopologicalSpace γ\nf : BoundedContinuousFunction α β\ng : ContinuousMap γ α\n⊢ LE.le (Norm.norm (f.compContinuous g)) (Norm.norm f)","decl":"theorem norm_compContinuous_le [TopologicalSpace γ] (f : α →ᵇ β) (g : C(γ, α)) :\n    ‖f.compContinuous g‖ ≤ ‖f‖ :=\n  ((lipschitz_compContinuous g).dist_le_mul f 0).trans <| by\n    rw [NNReal.coe_one, one_mul, dist_zero_right]\n\n"}
{"name":"BoundedContinuousFunction.coe_smul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero 𝕜\ninst✝² : Zero β\ninst✝¹ : SMul 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nc : 𝕜\nf : BoundedContinuousFunction α β\n⊢ Eq ⇑(HSMul.hSMul c f) fun x => HSMul.hSMul c (f x)","decl":"@[simp]\ntheorem coe_smul (c : 𝕜) (f : α →ᵇ β) : ⇑(c • f) = fun x => c • f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.smul_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero 𝕜\ninst✝² : Zero β\ninst✝¹ : SMul 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nc : 𝕜\nf : BoundedContinuousFunction α β\nx : α\n⊢ Eq ((HSMul.hSMul c f) x) (HSMul.hSMul c (f x))","decl":"theorem smul_apply (c : 𝕜) (f : α →ᵇ β) (x : α) : (c • f) x = c • f x := rfl\n\n"}
{"name":"BoundedContinuousFunction.instIsScalarTower","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝¹² : PseudoMetricSpace 𝕜\ninst✝¹¹ : TopologicalSpace α\ninst✝¹⁰ : PseudoMetricSpace β\ninst✝⁹ : Zero 𝕜\ninst✝⁸ : Zero β\ninst✝⁷ : SMul 𝕜 β\ninst✝⁶ : BoundedSMul 𝕜 β\n𝕜' : Type u_3\ninst✝⁵ : PseudoMetricSpace 𝕜'\ninst✝⁴ : Zero 𝕜'\ninst✝³ : SMul 𝕜' β\ninst✝² : BoundedSMul 𝕜' β\ninst✝¹ : SMul 𝕜' 𝕜\ninst✝ : IsScalarTower 𝕜' 𝕜 β\n⊢ IsScalarTower 𝕜' 𝕜 (BoundedContinuousFunction α β)","decl":"instance instIsScalarTower {𝕜' : Type*} [PseudoMetricSpace 𝕜'] [Zero 𝕜'] [SMul 𝕜' β]\n    [BoundedSMul 𝕜' β] [SMul 𝕜' 𝕜] [IsScalarTower 𝕜' 𝕜 β] :\n    IsScalarTower 𝕜' 𝕜 (α →ᵇ β) where\n  smul_assoc _ _ _ := ext fun _ ↦ smul_assoc ..\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝¹¹ : PseudoMetricSpace 𝕜\ninst✝¹⁰ : TopologicalSpace α\ninst✝⁹ : PseudoMetricSpace β\ninst✝⁸ : Zero 𝕜\ninst✝⁷ : Zero β\ninst✝⁶ : SMul 𝕜 β\ninst✝⁵ : BoundedSMul 𝕜 β\n𝕜' : Type u_3\ninst✝⁴ : PseudoMetricSpace 𝕜'\ninst✝³ : Zero 𝕜'\ninst✝² : SMul 𝕜' β\ninst✝¹ : BoundedSMul 𝕜' β\ninst✝ : SMulCommClass 𝕜' 𝕜 β\n⊢ SMulCommClass 𝕜' 𝕜 (BoundedContinuousFunction α β)","decl":"instance instSMulCommClass {𝕜' : Type*} [PseudoMetricSpace 𝕜'] [Zero 𝕜'] [SMul 𝕜' β]\n    [BoundedSMul 𝕜' β] [SMulCommClass 𝕜' 𝕜 β] :\n    SMulCommClass 𝕜' 𝕜 (α →ᵇ β) where\n  smul_comm _ _ _ := ext fun _ ↦ smul_comm ..\n\n"}
{"name":"BoundedContinuousFunction.instIsCentralScalar","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁸ : PseudoMetricSpace 𝕜\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : PseudoMetricSpace β\ninst✝⁵ : Zero 𝕜\ninst✝⁴ : Zero β\ninst✝³ : SMul 𝕜 β\ninst✝² : BoundedSMul 𝕜 β\ninst✝¹ : SMul (MulOpposite 𝕜) β\ninst✝ : IsCentralScalar 𝕜 β\n⊢ IsCentralScalar 𝕜 (BoundedContinuousFunction α β)","decl":"instance instIsCentralScalar [SMul 𝕜ᵐᵒᵖ β] [IsCentralScalar 𝕜 β] : IsCentralScalar 𝕜 (α →ᵇ β) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"BoundedContinuousFunction.instBoundedSMul","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero 𝕜\ninst✝² : Zero β\ninst✝¹ : SMul 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\n⊢ BoundedSMul 𝕜 (BoundedContinuousFunction α β)","decl":"instance instBoundedSMul : BoundedSMul 𝕜 (α →ᵇ β) where\n  dist_smul_pair' c f₁ f₂ := by\n    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]\n    intro x\n    refine (dist_smul_pair c (f₁ x) (f₂ x)).trans ?_\n    exact mul_le_mul_of_nonneg_left (dist_coe_le_dist x) dist_nonneg\n  dist_pair_smul' c₁ c₂ f := by\n    rw [dist_le (mul_nonneg dist_nonneg dist_nonneg)]\n    intro x\n    refine (dist_pair_smul c₁ c₂ (f x)).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ dist_nonneg\n    convert dist_coe_le_dist (β := β) x\n    simp\n\n"}
{"name":"BoundedContinuousFunction.evalCLM_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁸ : PseudoMetricSpace 𝕜\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : PseudoMetricSpace β\ninst✝⁵ : Semiring 𝕜\ninst✝⁴ : AddCommMonoid β\ninst✝³ : Module 𝕜 β\ninst✝² : BoundedSMul 𝕜 β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nx : α\nf : BoundedContinuousFunction α β\n⊢ Eq ((BoundedContinuousFunction.evalCLM 𝕜 x) f) (f x)","decl":"/-- The evaluation at a point, as a continuous linear map from `α →ᵇ β` to `β`. -/\n@[simps]\ndef evalCLM (x : α) : (α →ᵇ β) →L[𝕜] β where\n  toFun f := f x\n  map_add' _ _ := add_apply _ _\n  map_smul' _ _ := smul_apply _ _ _\n\n"}
{"name":"BoundedContinuousFunction.toContinuousMapLinearMap_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁸ : PseudoMetricSpace 𝕜\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : PseudoMetricSpace β\ninst✝⁵ : Semiring 𝕜\ninst✝⁴ : AddCommMonoid β\ninst✝³ : Module 𝕜 β\ninst✝² : BoundedSMul 𝕜 β\ninst✝¹ : BoundedAdd β\ninst✝ : ContinuousAdd β\nself : BoundedContinuousFunction α β\n⊢ Eq ((BoundedContinuousFunction.toContinuousMapLinearMap α β 𝕜) self) self.toContinuousMap","decl":"/-- The linear map forgetting that a bounded continuous function is bounded. -/\n@[simps]\ndef toContinuousMapLinearMap : (α →ᵇ β) →ₗ[𝕜] C(α, β) where\n  toFun := toContinuousMap\n  map_smul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ContinuousLinearMap.compLeftContinuousBounded_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\n𝕜 : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : SeminormedAddCommGroup β\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 β\ninst✝¹ : SeminormedAddCommGroup γ\ninst✝ : NormedSpace 𝕜 γ\ng : ContinuousLinearMap (RingHom.id 𝕜) β γ\nf : BoundedContinuousFunction α β\nx : α\n⊢ Eq (((ContinuousLinearMap.compLeftContinuousBounded α g) f) x) (g (f x))","decl":"@[simp]\ntheorem _root_.ContinuousLinearMap.compLeftContinuousBounded_apply (g : β →L[𝕜] γ) (f : α →ᵇ β)\n    (x : α) : (g.compLeftContinuousBounded α f) x = g (f x) := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_npowRec","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\nR : Type u_2\ninst✝ : SeminormedRing R\nf : BoundedContinuousFunction α R\nn : Nat\n⊢ Eq (⇑(npowRec n f)) (HPow.hPow (⇑f) n)","decl":"@[simp]\ntheorem coe_npowRec (f : α →ᵇ R) : ∀ n, ⇑(npowRec n f) = (⇑f) ^ n\n  | 0 => by rw [npowRec, pow_zero, coe_one]\n  | n + 1 => by rw [npowRec, pow_succ, coe_mul, coe_npowRec f n]\n\n"}
{"name":"BoundedContinuousFunction.coe_natCast","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\nR : Type u_2\ninst✝ : SeminormedRing R\nn : Nat\n⊢ Eq ⇑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_natCast (n : ℕ) : ((n : α →ᵇ R) : α → R) = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_ofNat","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝² : TopologicalSpace α\nR : Type u_2\ninst✝¹ : SeminormedRing R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (⇑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem coe_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : α →ᵇ R) : α → R) = ofNat(n) :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_intCast","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝¹ : TopologicalSpace α\nR : Type u_2\ninst✝ : SeminormedRing R\nn : Int\n⊢ Eq ⇑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_intCast (n : ℤ) : ((n : α →ᵇ R) : α → R) = n := rfl\n\n"}
{"name":"BoundedContinuousFunction.instIsScalarTower_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : NonUnitalSeminormedRing β\ninst✝³ : Zero 𝕜\ninst✝² : SMul 𝕜 β\ninst✝¹ : BoundedSMul 𝕜 β\ninst✝ : IsScalarTower 𝕜 β β\n⊢ IsScalarTower 𝕜 (BoundedContinuousFunction α β) (BoundedContinuousFunction α β)","decl":"instance [IsScalarTower 𝕜 β β] : IsScalarTower 𝕜 (α →ᵇ β) (α →ᵇ β) where\n  smul_assoc _ _ _ := ext fun _ ↦ smul_mul_assoc ..\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : NonUnitalSeminormedRing β\ninst✝³ : Zero 𝕜\ninst✝² : SMul 𝕜 β\ninst✝¹ : BoundedSMul 𝕜 β\ninst✝ : SMulCommClass 𝕜 β β\n⊢ SMulCommClass 𝕜 (BoundedContinuousFunction α β) (BoundedContinuousFunction α β)","decl":"instance [SMulCommClass 𝕜 β β] : SMulCommClass 𝕜 (α →ᵇ β) (α →ᵇ β) where\n  smul_comm _ _ _ := ext fun _ ↦ (mul_smul_comm ..).symm\n\n"}
{"name":"BoundedContinuousFunction.instSMulCommClass_2","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝⁶ : PseudoMetricSpace 𝕜\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : NonUnitalSeminormedRing β\ninst✝³ : Zero 𝕜\ninst✝² : SMul 𝕜 β\ninst✝¹ : BoundedSMul 𝕜 β\ninst✝ : SMulCommClass 𝕜 β β\n⊢ SMulCommClass (BoundedContinuousFunction α β) 𝕜 (BoundedContinuousFunction α β)","decl":"instance [SMulCommClass 𝕜 β β] : SMulCommClass (α →ᵇ β) 𝕜 (α →ᵇ β) where\n  smul_comm _ _ _ := ext fun _ ↦ mul_smul_comm ..\n\n"}
{"name":"BoundedContinuousFunction.algebraMap_apply","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nγ : Type w\n𝕜 : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : TopologicalSpace α\ninst✝¹ : NormedRing γ\ninst✝ : NormedAlgebra 𝕜 γ\nk : 𝕜\na : α\n⊢ Eq (((algebraMap 𝕜 (BoundedContinuousFunction α γ)) k) a) (HSMul.hSMul k 1)","decl":"@[simp]\ntheorem algebraMap_apply (k : 𝕜) (a : α) : algebraMap 𝕜 (α →ᵇ γ) k a = k • (1 : γ) := by\n  simp only [Algebra.algebraMap_eq_smul_one, coe_smul, coe_one, Pi.one_apply]\n\n"}
{"name":"BoundedContinuousFunction.instBoundedSMul_1","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\n𝕜 : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : TopologicalSpace α\ninst✝¹ : SeminormedAddCommGroup β\ninst✝ : NormedSpace 𝕜 β\n⊢ BoundedSMul (BoundedContinuousFunction α 𝕜) (BoundedContinuousFunction α β)","decl":"instance : BoundedSMul (α →ᵇ 𝕜) (α →ᵇ β) :=\n  BoundedSMul.of_norm_smul_le fun _ _ =>\n    norm_ofNormedAddCommGroup_le _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) _\n\n"}
{"name":"BoundedContinuousFunction.NNReal.upper_bound","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α NNReal\nx : α\n⊢ LE.le (f x) (NNDist.nndist f 0)","decl":"theorem NNReal.upper_bound {α : Type*} [TopologicalSpace α] (f : α →ᵇ ℝ≥0) (x : α) :\n    f x ≤ nndist f 0 := by\n  have key : nndist (f x) ((0 : α →ᵇ ℝ≥0) x) ≤ nndist f 0 := @dist_coe_le_dist α ℝ≥0 _ _ f 0 x\n  simp only [coe_zero, Pi.zero_apply] at key\n  rwa [NNReal.nndist_zero_eq_val' (f x)] at key\n\n"}
{"name":"BoundedContinuousFunction.coe_sup","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : NormedLatticeAddCommGroup β\nf g : BoundedContinuousFunction α β\n⊢ Eq (⇑(Max.max f g)) (Max.max ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_sup (f g : α →ᵇ β) : ⇑(f ⊔ g) = ⇑f ⊔ ⇑g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_inf","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : NormedLatticeAddCommGroup β\nf g : BoundedContinuousFunction α β\n⊢ Eq (⇑(Min.min f g)) (Min.min ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_inf (f g : α →ᵇ β) : ⇑(f ⊓ g) = ⇑f ⊓ ⇑g := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_abs","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : NormedLatticeAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(abs f)) (abs ⇑f)","decl":"@[simp, norm_cast] lemma coe_abs (f : α →ᵇ β) : ⇑|f| = |⇑f| := rfl\n\n"}
{"name":"BoundedContinuousFunction.coe_posPart","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : NormedLatticeAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(PosPart.posPart f)) (PosPart.posPart ⇑f)","decl":"@[simp, norm_cast] lemma coe_posPart (f : α →ᵇ β) : ⇑f⁺ = (⇑f)⁺ := rfl\n"}
{"name":"BoundedContinuousFunction.coe_negPart","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : TopologicalSpace α\ninst✝ : NormedLatticeAddCommGroup β\nf : BoundedContinuousFunction α β\n⊢ Eq (⇑(NegPart.negPart f)) (NegPart.negPart ⇑f)","decl":"@[simp, norm_cast] lemma coe_negPart (f : α →ᵇ β) : ⇑f⁻ = (⇑f)⁻ := rfl\n\n\n"}
{"name":"BoundedContinuousFunction.nnrealPart_coeFn_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ Eq (⇑f.nnrealPart) (Function.comp Real.toNNReal ⇑f)","decl":"@[simp]\ntheorem nnrealPart_coeFn_eq (f : α →ᵇ ℝ) : ⇑f.nnrealPart = Real.toNNReal ∘ ⇑f := rfl\n\n"}
{"name":"BoundedContinuousFunction.nnnorm_coeFn_eq","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ Eq (⇑f.nnnorm) (Function.comp NNNorm.nnnorm ⇑f)","decl":"@[simp]\ntheorem nnnorm_coeFn_eq (f : α →ᵇ ℝ) : ⇑f.nnnorm = NNNorm.nnnorm ∘ ⇑f := rfl\n\n-- TODO: Use `posPart` and `negPart` here\n"}
{"name":"BoundedContinuousFunction.self_eq_nnrealPart_sub_nnrealPart_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ Eq (⇑f) (HSub.hSub (Function.comp NNReal.toReal ⇑f.nnrealPart) (Function.comp NNReal.toReal ⇑(Neg.neg f).nnrealPart))","decl":"/-- Decompose a bounded continuous function to its positive and negative parts. -/\ntheorem self_eq_nnrealPart_sub_nnrealPart_neg (f : α →ᵇ ℝ) :\n    ⇑f = (↑) ∘ f.nnrealPart - (↑) ∘ (-f).nnrealPart := by\n  funext x\n  dsimp\n  simp only [max_zero_sub_max_neg_zero_eq_self]\n\n"}
{"name":"BoundedContinuousFunction.abs_self_eq_nnrealPart_add_nnrealPart_neg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ Eq (Function.comp abs ⇑f) (HAdd.hAdd (Function.comp NNReal.toReal ⇑f.nnrealPart) (Function.comp NNReal.toReal ⇑(Neg.neg f).nnrealPart))","decl":"/-- Express the absolute value of a bounded continuous function in terms of its\npositive and negative parts. -/\ntheorem abs_self_eq_nnrealPart_add_nnrealPart_neg (f : α →ᵇ ℝ) :\n    abs ∘ ⇑f = (↑) ∘ f.nnrealPart + (↑) ∘ (-f).nnrealPart := by\n  funext x\n  dsimp\n  simp only [max_zero_add_max_neg_zero_eq_abs_self]\n\n"}
{"name":"BoundedContinuousFunction.add_norm_nonneg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ LE.le 0 (HAdd.hAdd f (BoundedContinuousFunction.const α (Norm.norm f)))","decl":"lemma add_norm_nonneg (f : α →ᵇ ℝ) :\n    0 ≤ f + const _ ‖f‖ := by\n  intro x\n  simp only [ContinuousMap.toFun_eq_coe, coe_toContinuousMap, coe_zero, Pi.zero_apply, coe_add,\n    const_apply, Pi.add_apply]\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).1]\n\n"}
{"name":"BoundedContinuousFunction.norm_sub_nonneg","module":"Mathlib.Topology.ContinuousMap.Bounded.Basic","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : BoundedContinuousFunction α Real\n⊢ LE.le 0 (HSub.hSub (BoundedContinuousFunction.const α (Norm.norm f)) f)","decl":"lemma norm_sub_nonneg (f : α →ᵇ ℝ) :\n    0 ≤ const _ ‖f‖ - f := by\n  intro x\n  simp only [ContinuousMap.toFun_eq_coe, coe_toContinuousMap, coe_zero, Pi.zero_apply, coe_sub,\n    const_apply, Pi.sub_apply, sub_nonneg]\n  linarith [(abs_le.mp (norm_coe_le_norm f x)).2]\n\n"}
