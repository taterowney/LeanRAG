{"name":"Function.semiconj_iff_comp_eq","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\n⊢ Iff (Function.Semiconj f ga gb) (Eq (Function.comp f ga) (Function.comp gb f))","decl":"/-- Definition of `Function.Semiconj` in terms of functional equality. -/\nlemma _root_.Function.semiconj_iff_comp_eq : Semiconj f ga gb ↔ f ∘ ga = gb ∘ f := funext_iff.symm\n\n"}
{"name":"Function.Semiconj.comp_eq","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\na✝ : Function.Semiconj f ga gb\n⊢ Eq (Function.comp f ga) (Function.comp gb f)","decl":"protected alias ⟨comp_eq, _⟩ := semiconj_iff_comp_eq\n\n"}
{"name":"Function.Semiconj.eq","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\nx : α\n⊢ Eq (f (ga x)) (gb (f x))","decl":"protected theorem eq (h : Semiconj f ga gb) (x : α) : f (ga x) = gb (f x) :=\n  h x\n\n"}
{"name":"Function.Semiconj.comp_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga ga' : α → α\ngb gb' : β → β\nh : Function.Semiconj f ga gb\nh' : Function.Semiconj f ga' gb'\n⊢ Function.Semiconj f (Function.comp ga ga') (Function.comp gb gb')","decl":"/-- If `f` semiconjugates `ga` to `gb` and `ga'` to `gb'`,\nthen it semiconjugates `ga ∘ ga'` to `gb ∘ gb'`. -/\ntheorem comp_right (h : Semiconj f ga gb) (h' : Semiconj f ga' gb') :\n    Semiconj f (ga ∘ ga') (gb ∘ gb') := fun x ↦ by\n  simp only [comp_apply, h.eq, h'.eq]\n\n"}
{"name":"Function.Semiconj.trans","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nfab : α → β\nfbc : β → γ\nga : α → α\ngb : β → β\ngc : γ → γ\nhab : Function.Semiconj fab ga gb\nhbc : Function.Semiconj fbc gb gc\n⊢ Function.Semiconj (Function.comp fbc fab) ga gc","decl":"/-- If `fab : α → β` semiconjugates `ga` to `gb` and `fbc : β → γ` semiconjugates `gb` to `gc`,\nthen `fbc ∘ fab` semiconjugates `ga` to `gc`.\n\nSee also `Function.Semiconj.comp_left` for a version with reversed arguments. -/\nprotected theorem trans (hab : Semiconj fab ga gb) (hbc : Semiconj fbc gb gc) :\n    Semiconj (fbc ∘ fab) ga gc := fun x ↦ by\n  simp only [comp_apply, hab.eq, hbc.eq]\n\n"}
{"name":"Function.Semiconj.comp_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nfab : α → β\nfbc : β → γ\nga : α → α\ngb : β → β\ngc : γ → γ\nhbc : Function.Semiconj fbc gb gc\nhab : Function.Semiconj fab ga gb\n⊢ Function.Semiconj (Function.comp fbc fab) ga gc","decl":"/-- If `fbc : β → γ` semiconjugates `gb` to `gc` and `fab : α → β` semiconjugates `ga` to `gb`,\nthen `fbc ∘ fab` semiconjugates `ga` to `gc`.\n\nSee also `Function.Semiconj.trans` for a version with reversed arguments.\n\n**Backward compatibility note:** before 2024-01-13,\nthis lemma used to have the same order of arguments that `Function.Semiconj.trans` has now. -/\ntheorem comp_left (hbc : Semiconj fbc gb gc) (hab : Semiconj fab ga gb) :\n    Semiconj (fbc ∘ fab) ga gc :=\n  hab.trans hbc\n\n"}
{"name":"Function.Semiconj.id_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\n⊢ Function.Semiconj f id id","decl":"/-- Any function semiconjugates the identity function to the identity function. -/\ntheorem id_right : Semiconj f id id := fun _ ↦ rfl\n\n"}
{"name":"Function.Semiconj.id_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nga : α → α\n⊢ Function.Semiconj id ga ga","decl":"/-- The identity function semiconjugates any function to itself. -/\ntheorem id_left : Semiconj id ga ga := fun _ ↦ rfl\n\n"}
{"name":"Function.Semiconj.inverses_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga ga' : α → α\ngb gb' : β → β\nh : Function.Semiconj f ga gb\nha : Function.RightInverse ga' ga\nhb : Function.LeftInverse gb' gb\n⊢ Function.Semiconj f ga' gb'","decl":"/-- If `f : α → β` semiconjugates `ga : α → α` to `gb : β → β`,\n`ga'` is a right inverse of `ga`, and `gb'` is a left inverse of `gb`,\nthen `f` semiconjugates `ga'` to `gb'` as well. -/\ntheorem inverses_right (h : Semiconj f ga gb) (ha : RightInverse ga' ga) (hb : LeftInverse gb' gb) :\n    Semiconj f ga' gb' := fun x ↦ by\n  rw [← hb (f (ga' x)), ← h.eq, ha x]\n\n"}
{"name":"Function.Semiconj.inverse_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\nf' : β → α\nh : Function.Semiconj f ga gb\nhf₁ : Function.LeftInverse f' f\nhf₂ : Function.RightInverse f' f\n⊢ Function.Semiconj f' gb ga","decl":"/-- If `f` semiconjugates `ga` to `gb` and `f'` is both a left and a right inverse of `f`,\nthen `f'` semiconjugates `gb` to `ga`. -/\nlemma inverse_left {f' : β → α} (h : Semiconj f ga gb)\n    (hf₁ : LeftInverse f' f) (hf₂ : RightInverse f' f) : Semiconj f' gb ga := fun x ↦ by\n  rw [← hf₁.injective.eq_iff, h, hf₂, hf₂]\n\n"}
{"name":"Function.Semiconj.option_map","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\n⊢ Function.Semiconj (Option.map f) (Option.map ga) (Option.map gb)","decl":"/-- If `f : α → β` semiconjugates `ga : α → α` to `gb : β → β`,\nthen `Option.map f` semiconjugates `Option.map ga` to `Option.map gb`. -/\ntheorem option_map {f : α → β} {ga : α → α} {gb : β → β} (h : Semiconj f ga gb) :\n    Semiconj (Option.map f) (Option.map ga) (Option.map gb)\n  | none => rfl\n  | some _ => congr_arg some <| h _\n\n"}
{"name":"Function.Semiconj.commute","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf g : α → α\nh : Function.Semiconj f g g\n⊢ Function.Commute f g","decl":"/-- Reinterpret `Function.Semiconj f g g` as `Function.Commute f g`. These two predicates are\ndefinitionally equal but have different dot-notation lemmas. -/\ntheorem Semiconj.commute {f g : α → α} (h : Semiconj f g g) : Commute f g := h\n\n"}
{"name":"Function.Commute.semiconj","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Semiconj f g g","decl":"/-- Reinterpret `Function.Commute f g` as `Function.Semiconj f g g`. These two predicates are\ndefinitionally equal but have different dot-notation lemmas. -/\ntheorem semiconj (h : Commute f g) : Semiconj f g g := h\n\n"}
{"name":"Function.Commute.refl","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf : α → α\n⊢ Function.Commute f f","decl":"@[refl]\ntheorem refl (f : α → α) : Commute f f := fun _ ↦ Eq.refl _\n\n"}
{"name":"Function.Commute.symm","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute g f","decl":"@[symm]\ntheorem symm (h : Commute f g) : Commute g f := fun x ↦ (h x).symm\n\n"}
{"name":"Function.Commute.comp_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf g g' : α → α\nh : Function.Commute f g\nh' : Function.Commute f g'\n⊢ Function.Commute f (Function.comp g g')","decl":"/-- If `f` commutes with `g` and `g'`, then it commutes with `g ∘ g'`. -/\ntheorem comp_right (h : Commute f g) (h' : Commute f g') : Commute f (g ∘ g') :=\n  Semiconj.comp_right h h'\n\n"}
{"name":"Function.Commute.comp_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf f' g : α → α\nh : Function.Commute f g\nh' : Function.Commute f' g\n⊢ Function.Commute (Function.comp f f') g","decl":"/-- If `f` and `f'` commute with `g`, then `f ∘ f'` commutes with `g` as well. -/\nnonrec theorem comp_left (h : Commute f g) (h' : Commute f' g) : Commute (f ∘ f') g :=\n  h.comp_left h'\n\n"}
{"name":"Function.Commute.id_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf : α → α\n⊢ Function.Commute f id","decl":"/-- Any self-map commutes with the identity map. -/\ntheorem id_right : Commute f id := Semiconj.id_right\n\n"}
{"name":"Function.Commute.id_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf : α → α\n⊢ Function.Commute id f","decl":"/-- The identity map commutes with any self-map. -/\ntheorem id_left : Commute id f :=\n  Semiconj.id_left\n\n"}
{"name":"Function.Commute.option_map","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nf g : α → α\nh : Function.Commute f g\n⊢ Function.Commute (Option.map f) (Option.map g)","decl":"/-- If `f` commutes with `g`, then `Option.map f` commutes with `Option.map g`. -/\nnonrec theorem option_map {f g : α → α} (h : Commute f g) : Commute (Option.map f) (Option.map g) :=\n  h.option_map\n\n"}
{"name":"Function.Semiconj₂.eq","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\nh : Function.Semiconj₂ f ga gb\nx y : α\n⊢ Eq (f (ga x y)) (gb (f x) (f y))","decl":"protected theorem eq (h : Semiconj₂ f ga gb) (x y : α) : f (ga x y) = gb (f x) (f y) :=\n  h x y\n\n"}
{"name":"Function.Semiconj₂.comp_eq","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\nh : Function.Semiconj₂ f ga gb\n⊢ Eq (Function.bicompr f ga) (Function.bicompl gb f f)","decl":"protected theorem comp_eq (h : Semiconj₂ f ga gb) : bicompr f ga = bicompl gb f f :=\n  funext fun x ↦ funext <| h x\n\n"}
{"name":"Function.Semiconj₂.id_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nop : α → α → α\n⊢ Function.Semiconj₂ id op op","decl":"theorem id_left (op : α → α → α) : Semiconj₂ id op op := fun _ _ ↦ rfl\n\n"}
{"name":"Function.Semiconj₂.comp","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nga : α → α → α\ngb : β → β → β\nf' : β → γ\ngc : γ → γ → γ\nhf' : Function.Semiconj₂ f' gb gc\nhf : Function.Semiconj₂ f ga gb\n⊢ Function.Semiconj₂ (Function.comp f' f) ga gc","decl":"theorem comp {f' : β → γ} {gc : γ → γ → γ} (hf' : Semiconj₂ f' gb gc) (hf : Semiconj₂ f ga gb) :\n    Semiconj₂ (f' ∘ f) ga gc := fun x y ↦ by simp only [hf'.eq, hf.eq, comp_apply]\n\n"}
{"name":"Function.Semiconj₂.isAssociative_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\ninst✝ : Std.Associative ga\nh : Function.Semiconj₂ f ga gb\nh_surj : Function.Surjective f\n⊢ Std.Associative gb","decl":"theorem isAssociative_right [Std.Associative ga] (h : Semiconj₂ f ga gb) (h_surj : Surjective f) :\n    Std.Associative gb :=\n  ⟨h_surj.forall₃.2 fun x₁ x₂ x₃ ↦ by simp only [← h.eq, Std.Associative.assoc (op := ga)]⟩\n\n"}
{"name":"Function.Semiconj₂.isAssociative_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\ninst✝ : Std.Associative gb\nh : Function.Semiconj₂ f ga gb\nh_inj : Function.Injective f\n⊢ Std.Associative ga","decl":"theorem isAssociative_left [Std.Associative gb] (h : Semiconj₂ f ga gb) (h_inj : Injective f) :\n    Std.Associative ga :=\n  ⟨fun x₁ x₂ x₃ ↦ h_inj <| by simp only [h.eq, Std.Associative.assoc (op := gb)]⟩\n\n"}
{"name":"Function.Semiconj₂.isIdempotent_right","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\ninst✝ : Std.IdempotentOp ga\nh : Function.Semiconj₂ f ga gb\nh_surj : Function.Surjective f\n⊢ Std.IdempotentOp gb","decl":"theorem isIdempotent_right [Std.IdempotentOp ga] (h : Semiconj₂ f ga gb) (h_surj : Surjective f) :\n    Std.IdempotentOp gb :=\n  ⟨h_surj.forall.2 fun x ↦ by simp only [← h.eq, Std.IdempotentOp.idempotent (op := ga)]⟩\n\n"}
{"name":"Function.Semiconj₂.isIdempotent_left","module":"Mathlib.Logic.Function.Conjugate","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nga : α → α → α\ngb : β → β → β\ninst✝ : Std.IdempotentOp gb\nh : Function.Semiconj₂ f ga gb\nh_inj : Function.Injective f\n⊢ Std.IdempotentOp ga","decl":"theorem isIdempotent_left [Std.IdempotentOp gb] (h : Semiconj₂ f ga gb) (h_inj : Injective f) :\n    Std.IdempotentOp ga :=\n  ⟨fun x ↦ h_inj <| by rw [h.eq, Std.IdempotentOp.idempotent (op := gb)]⟩\n\n"}
