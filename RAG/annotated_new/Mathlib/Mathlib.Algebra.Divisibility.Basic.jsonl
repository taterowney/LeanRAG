{"name":"Dvd.intro","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b c : α\nh : Eq (HMul.hMul a c) b\n⊢ Dvd.dvd a b","decl":"theorem Dvd.intro (c : α) (h : a * c = b) : a ∣ b :=\n  Exists.intro c h.symm\n\n"}
{"name":"dvd_of_mul_right_eq","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b c : α\nh : Eq (HMul.hMul a c) b\n⊢ Dvd.dvd a b","decl":"alias dvd_of_mul_right_eq := Dvd.intro\n\n"}
{"name":"exists_eq_mul_right_of_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\nh : Dvd.dvd a b\n⊢ Exists fun c => Eq b (HMul.hMul a c)","decl":"theorem exists_eq_mul_right_of_dvd (h : a ∣ b) : ∃ c, b = a * c :=\n  h\n\n"}
{"name":"dvd_def","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\n⊢ Iff (Dvd.dvd a b) (Exists fun c => Eq b (HMul.hMul a c))","decl":"theorem dvd_def : a ∣ b ↔ ∃ c, b = a * c :=\n  Iff.rfl\n\n"}
{"name":"dvd_iff_exists_eq_mul_right","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\n⊢ Iff (Dvd.dvd a b) (Exists fun c => Eq b (HMul.hMul a c))","decl":"alias dvd_iff_exists_eq_mul_right := dvd_def\n\n"}
{"name":"Dvd.elim","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\nP : Prop\na b : α\nH₁ : Dvd.dvd a b\nH₂ : ∀ (c : α), Eq b (HMul.hMul a c) → P\n⊢ P","decl":"theorem Dvd.elim {P : Prop} {a b : α} (H₁ : a ∣ b) (H₂ : ∀ c, b = a * c → P) : P :=\n  Exists.elim H₁ H₂\n\n"}
{"name":"dvd_trans","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b c : α\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b c\n⊢ Dvd.dvd a c","decl":"@[trans]\ntheorem dvd_trans : a ∣ b → b ∣ c → a ∣ c\n  | ⟨d, h₁⟩, ⟨e, h₂⟩ => ⟨d * e, h₁ ▸ h₂.trans <| mul_assoc a d e⟩\n\n"}
{"name":"Dvd.dvd.trans","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b c : α\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd b c\n⊢ Dvd.dvd a c","decl":"alias Dvd.dvd.trans := dvd_trans\n\n"}
{"name":"instIsTransDvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\n⊢ IsTrans α Dvd.dvd","decl":"/-- Transitivity of `|` for use in `calc` blocks. -/\ninstance : IsTrans α Dvd.dvd :=\n  ⟨fun _ _ _ => dvd_trans⟩\n\n"}
{"name":"dvd_mul_right","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\n⊢ Dvd.dvd a (HMul.hMul a b)","decl":"@[simp]\ntheorem dvd_mul_right (a b : α) : a ∣ a * b :=\n  Dvd.intro b rfl\n\n"}
{"name":"dvd_mul_of_dvd_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\nh : Dvd.dvd a b\nc : α\n⊢ Dvd.dvd a (HMul.hMul b c)","decl":"theorem dvd_mul_of_dvd_left (h : a ∣ b) (c : α) : a ∣ b * c :=\n  h.trans (dvd_mul_right b c)\n\n"}
{"name":"Dvd.dvd.mul_right","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b : α\nh : Dvd.dvd a b\nc : α\n⊢ Dvd.dvd a (HMul.hMul b c)","decl":"alias Dvd.dvd.mul_right := dvd_mul_of_dvd_left\n\n"}
{"name":"dvd_of_mul_right_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\na b c : α\nh : Dvd.dvd (HMul.hMul a b) c\n⊢ Dvd.dvd a c","decl":"theorem dvd_of_mul_right_dvd (h : a * b ∣ c) : a ∣ c :=\n  (dvd_mul_right a b).trans h\n\n"}
{"name":"decompositionMonoid_iff","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\n⊢ Iff (DecompositionMonoid α) (∀ (a : α), IsPrimal a)","decl":"variable (α) in\n/-- A monoid is a decomposition monoid if every element is primal. An integral domain whose\nmultiplicative monoid is a decomposition monoid, is called a pre-Schreier domain; it is a\nSchreier domain if it is moreover integrally closed. -/\n@[mk_iff] class DecompositionMonoid : Prop where\n  primal (a : α) : IsPrimal a\n\n"}
{"name":"DecompositionMonoid.primal","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\nself : DecompositionMonoid α\na : α\n⊢ IsPrimal a","decl":"variable (α) in\n/-- A monoid is a decomposition monoid if every element is primal. An integral domain whose\nmultiplicative monoid is a decomposition monoid, is called a pre-Schreier domain; it is a\nSchreier domain if it is moreover integrally closed. -/\n@[mk_iff] class DecompositionMonoid : Prop where\n  primal (a : α) : IsPrimal a\n\n"}
{"name":"exists_dvd_and_dvd_of_dvd_mul","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : DecompositionMonoid α\nb c a : α\nH : Dvd.dvd a (HMul.hMul b c)\n⊢ Exists fun a₁ => Exists fun a₂ => And (Dvd.dvd a₁ b) (And (Dvd.dvd a₂ c) (Eq a (HMul.hMul a₁ a₂)))","decl":"theorem exists_dvd_and_dvd_of_dvd_mul [DecompositionMonoid α] {b c a : α} (H : a ∣ b * c) :\n    ∃ a₁ a₂, a₁ ∣ b ∧ a₂ ∣ c ∧ a = a₁ * a₂ := DecompositionMonoid.primal a H\n\n"}
{"name":"dvd_refl","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\n⊢ Dvd.dvd a a","decl":"@[refl, simp]\ntheorem dvd_refl (a : α) : a ∣ a :=\n  Dvd.intro 1 (mul_one a)\n\n"}
{"name":"dvd_rfl","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\n⊢ Dvd.dvd a a","decl":"theorem dvd_rfl : ∀ {a : α}, a ∣ a := fun {a} => dvd_refl a\n\n"}
{"name":"instIsReflDvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\n⊢ IsRefl α fun x1 x2 => Dvd.dvd x1 x2","decl":"instance : IsRefl α (· ∣ ·) :=\n  ⟨dvd_refl⟩\n\n"}
{"name":"one_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\n⊢ Dvd.dvd 1 a","decl":"theorem one_dvd (a : α) : 1 ∣ a :=\n  Dvd.intro a (one_mul a)\n\n"}
{"name":"dvd_of_eq","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : Eq a b\n⊢ Dvd.dvd a b","decl":"theorem dvd_of_eq (h : a = b) : a ∣ b := by rw [h]\n\n"}
{"name":"Eq.dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nh : Eq a b\n⊢ Dvd.dvd a b","decl":"alias Eq.dvd := dvd_of_eq\n\n"}
{"name":"pow_dvd_pow","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nm n : Nat\na : α\nh : LE.le m n\n⊢ Dvd.dvd (HPow.hPow a m) (HPow.hPow a n)","decl":"lemma pow_dvd_pow (a : α) (h : m ≤ n) : a ^ m ∣ a ^ n :=\n  ⟨a ^ (n - m), by rw [← pow_add, Nat.add_comm, Nat.sub_add_cancel h]⟩\n\n"}
{"name":"dvd_pow","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhab : Dvd.dvd a b\nn : Nat\nx✝ : Ne n 0\n⊢ Dvd.dvd a (HPow.hPow b n)","decl":"lemma dvd_pow (hab : a ∣ b) : ∀ {n : ℕ} (_ : n ≠ 0), a ∣ b ^ n\n  | 0,     hn => (hn rfl).elim\n  | n + 1, _  => by rw [pow_succ']; exact hab.mul_right _\n\n"}
{"name":"Dvd.dvd.pow","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na b : α\nhab : Dvd.dvd a b\nn : Nat\nx✝ : Ne n 0\n⊢ Dvd.dvd a (HPow.hPow b n)","decl":"alias Dvd.dvd.pow := dvd_pow\n\n"}
{"name":"dvd_pow_self","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\na : α\nn : Nat\nhn : Ne n 0\n⊢ Dvd.dvd a (HPow.hPow a n)","decl":"lemma dvd_pow_self (a : α) {n : ℕ} (hn : n ≠ 0) : a ∣ a ^ n := dvd_rfl.pow hn\n\n"}
{"name":"mul_dvd_mul_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nb c a : α\nh : Dvd.dvd b c\n⊢ Dvd.dvd (HMul.hMul a b) (HMul.hMul a c)","decl":"theorem mul_dvd_mul_left (a : α) (h : b ∣ c) : a * b ∣ a * c := by\n  obtain ⟨d, rfl⟩ := h\n  use d\n  rw [mul_assoc]\n\n"}
{"name":"Dvd.intro_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b c : α\nh : Eq (HMul.hMul c a) b\n⊢ Dvd.dvd a b","decl":"theorem Dvd.intro_left (c : α) (h : c * a = b) : a ∣ b :=\n  Dvd.intro c (by rw [mul_comm] at h; apply h)\n\n"}
{"name":"dvd_of_mul_left_eq","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b c : α\nh : Eq (HMul.hMul c a) b\n⊢ Dvd.dvd a b","decl":"alias dvd_of_mul_left_eq := Dvd.intro_left\n\n"}
{"name":"exists_eq_mul_left_of_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\nh : Dvd.dvd a b\n⊢ Exists fun c => Eq b (HMul.hMul c a)","decl":"theorem exists_eq_mul_left_of_dvd (h : a ∣ b) : ∃ c, b = c * a :=\n  Dvd.elim h fun c => fun H1 : b = a * c => Exists.intro c (Eq.trans H1 (mul_comm a c))\n\n"}
{"name":"dvd_iff_exists_eq_mul_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\n⊢ Iff (Dvd.dvd a b) (Exists fun c => Eq b (HMul.hMul c a))","decl":"theorem dvd_iff_exists_eq_mul_left : a ∣ b ↔ ∃ c, b = c * a :=\n  ⟨exists_eq_mul_left_of_dvd, by\n    rintro ⟨c, rfl⟩\n    exact ⟨c, mul_comm _ _⟩⟩\n\n"}
{"name":"Dvd.elim_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\nP : Prop\nh₁ : Dvd.dvd a b\nh₂ : ∀ (c : α), Eq b (HMul.hMul c a) → P\n⊢ P","decl":"theorem Dvd.elim_left {P : Prop} (h₁ : a ∣ b) (h₂ : ∀ c, b = c * a → P) : P :=\n  Exists.elim (exists_eq_mul_left_of_dvd h₁) fun c => fun h₃ : b = c * a => h₂ c h₃\n\n"}
{"name":"dvd_mul_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\n⊢ Dvd.dvd a (HMul.hMul b a)","decl":"@[simp]\ntheorem dvd_mul_left (a b : α) : a ∣ b * a :=\n  Dvd.intro b (mul_comm a b)\n\n"}
{"name":"dvd_mul_of_dvd_right","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\nh : Dvd.dvd a b\nc : α\n⊢ Dvd.dvd a (HMul.hMul c b)","decl":"theorem dvd_mul_of_dvd_right (h : a ∣ b) (c : α) : a ∣ c * b := by\n  rw [mul_comm]; exact h.mul_right _\n\n"}
{"name":"Dvd.dvd.mul_left","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b : α\nh : Dvd.dvd a b\nc : α\n⊢ Dvd.dvd a (HMul.hMul c b)","decl":"alias Dvd.dvd.mul_left := dvd_mul_of_dvd_right\n\n"}
{"name":"mul_dvd_mul","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b c d : α\na✝¹ : Dvd.dvd a b\na✝ : Dvd.dvd c d\n⊢ Dvd.dvd (HMul.hMul a c) (HMul.hMul b d)","decl":"theorem mul_dvd_mul : ∀ {a b c d : α}, a ∣ b → c ∣ d → a * c ∣ b * d\n  | a, _, c, _, ⟨e, rfl⟩, ⟨f, rfl⟩ => ⟨e * f, by simp⟩\n\n"}
{"name":"dvd_of_mul_left_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommSemigroup α\na b c : α\nh : Dvd.dvd (HMul.hMul a b) c\n⊢ Dvd.dvd b c","decl":"theorem dvd_of_mul_left_dvd (h : a * b ∣ c) : b ∣ c :=\n  Dvd.elim h fun d ceq => Dvd.intro (a * d) (by simp [ceq])\n\n"}
{"name":"dvd_mul","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CommSemigroup α\ninst✝ : DecompositionMonoid α\nk m n : α\n⊢ Iff (Dvd.dvd k (HMul.hMul m n)) (Exists fun d₁ => Exists fun d₂ => And (Dvd.dvd d₁ m) (And (Dvd.dvd d₂ n) (Eq k (HMul.hMul d₁ d₂))))","decl":"theorem dvd_mul [DecompositionMonoid α] {k m n : α} :\n    k ∣ m * n ↔ ∃ d₁ d₂, d₁ ∣ m ∧ d₂ ∣ n ∧ k = d₁ * d₂ := by\n  refine ⟨exists_dvd_and_dvd_of_dvd_mul, ?_⟩\n  rintro ⟨d₁, d₂, hy, hz, rfl⟩\n  exact mul_dvd_mul hy hz\n\n"}
{"name":"mul_dvd_mul_right","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\nh : Dvd.dvd a b\nc : α\n⊢ Dvd.dvd (HMul.hMul a c) (HMul.hMul b c)","decl":"theorem mul_dvd_mul_right (h : a ∣ b) (c : α) : a * c ∣ b * c :=\n  mul_dvd_mul h (dvd_refl c)\n\n"}
{"name":"pow_dvd_pow_of_dvd","module":"Mathlib.Algebra.Divisibility.Basic","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\nh : Dvd.dvd a b\nn : Nat\n⊢ Dvd.dvd (HPow.hPow a n) (HPow.hPow b n)","decl":"theorem pow_dvd_pow_of_dvd (h : a ∣ b) : ∀ n : ℕ, a ^ n ∣ b ^ n\n  | 0 => by rw [pow_zero, pow_zero]\n  | n + 1 => by\n    rw [pow_succ, pow_succ]\n    exact mul_dvd_mul (pow_dvd_pow_of_dvd h n) h\n\n"}
