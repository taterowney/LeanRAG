{"name":"IsOrderedVAdd.vadd_le_vadd_right","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : VAdd G P\nself : IsOrderedVAdd G P\nc d : G\na✝ : LE.le c d\na : P\n⊢ LE.le (HVAdd.hVAdd c a) (HVAdd.hVAdd d a)","decl":"/-- An ordered vector addition is a bi-monotone vector addition. -/\nclass IsOrderedVAdd (G P : Type*) [LE G] [LE P] [VAdd G P] : Prop where\n  protected vadd_le_vadd_left : ∀ a b : P, a ≤ b → ∀ c : G, c +ᵥ a ≤ c +ᵥ b\n  protected vadd_le_vadd_right : ∀ c d : G, c ≤ d → ∀ a : P, c +ᵥ a ≤ d +ᵥ a\n\n"}
{"name":"IsOrderedVAdd.vadd_le_vadd_left","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : VAdd G P\nself : IsOrderedVAdd G P\na b : P\na✝ : LE.le a b\nc : G\n⊢ LE.le (HVAdd.hVAdd c a) (HVAdd.hVAdd c b)","decl":"/-- An ordered vector addition is a bi-monotone vector addition. -/\nclass IsOrderedVAdd (G P : Type*) [LE G] [LE P] [VAdd G P] : Prop where\n  protected vadd_le_vadd_left : ∀ a b : P, a ≤ b → ∀ c : G, c +ᵥ a ≤ c +ᵥ b\n  protected vadd_le_vadd_right : ∀ c d : G, c ≤ d → ∀ a : P, c +ᵥ a ≤ d +ᵥ a\n\n"}
{"name":"IsOrderedSMul.smul_le_smul_left","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : SMul G P\nself : IsOrderedSMul G P\na b : P\na✝ : LE.le a b\nc : G\n⊢ LE.le (HSMul.hSMul c a) (HSMul.hSMul c b)","decl":"/-- An ordered scalar multiplication is a bi-monotone scalar multiplication. Note that this is\ndifferent from `OrderedSMul`, which uses strict inequality, requires `G` to be a semiring, and the\ndefining conditions are restricted to positive elements of `G`. -/\n@[to_additive]\nclass IsOrderedSMul (G P : Type*) [LE G] [LE P] [SMul G P] : Prop where\n  protected smul_le_smul_left : ∀ a b : P, a ≤ b → ∀ c : G, c • a ≤ c • b\n  protected smul_le_smul_right : ∀ c d : G, c ≤ d → ∀ a : P, c • a ≤ d • a\n\n"}
{"name":"IsOrderedSMul.smul_le_smul_right","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : SMul G P\nself : IsOrderedSMul G P\nc d : G\na✝ : LE.le c d\na : P\n⊢ LE.le (HSMul.hSMul c a) (HSMul.hSMul d a)","decl":"/-- An ordered scalar multiplication is a bi-monotone scalar multiplication. Note that this is\ndifferent from `OrderedSMul`, which uses strict inequality, requires `G` to be a semiring, and the\ndefining conditions are restricted to positive elements of `G`. -/\n@[to_additive]\nclass IsOrderedSMul (G P : Type*) [LE G] [LE P] [SMul G P] : Prop where\n  protected smul_le_smul_left : ∀ a b : P, a ≤ b → ∀ c : G, c • a ≤ c • b\n  protected smul_le_smul_right : ∀ c d : G, c ≤ d → ∀ a : P, c • a ≤ d • a\n\n"}
{"name":"instCovariantClassHSMulLeOfIsOrderedSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : LE P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedSMul G P\n⊢ CovariantClass G P (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance [LE G] [LE P] [SMul G P] [IsOrderedSMul G P] : CovariantClass G P (· • ·) (· ≤ ·) where\n  elim := fun a _ _ bc ↦ IsOrderedSMul.smul_le_smul_left _ _ bc a\n\n"}
{"name":"instCovariantClassHVAddLeOfIsOrderedVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : LE P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedVAdd G P\n⊢ CovariantClass G P (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance [LE G] [LE P] [SMul G P] [IsOrderedSMul G P] : CovariantClass G P (· • ·) (· ≤ ·) where\n  elim := fun a _ _ bc ↦ IsOrderedSMul.smul_le_smul_left _ _ bc a\n\n"}
{"name":"instIsOrderedSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\ninst✝ : OrderedCommMonoid G\n⊢ IsOrderedSMul G G","decl":"@[to_additive]\ninstance [OrderedCommMonoid G] : IsOrderedSMul G G where\n  smul_le_smul_left _ _ := mul_le_mul_left'\n  smul_le_smul_right _ _ := mul_le_mul_right'\n\n"}
{"name":"instIsOrderedVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\ninst✝ : OrderedAddCommMonoid G\n⊢ IsOrderedVAdd G G","decl":"@[to_additive]\ninstance [OrderedCommMonoid G] : IsOrderedSMul G G where\n  smul_le_smul_left _ _ := mul_le_mul_left'\n  smul_le_smul_right _ _ := mul_le_mul_right'\n\n"}
{"name":"IsOrderedVAdd.vadd_le_vadd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : Preorder G\ninst✝² : Preorder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedVAdd G P\na b : G\nc d : P\nhab : LE.le a b\nhcd : LE.le c d\n⊢ LE.le (HVAdd.hVAdd a c) (HVAdd.hVAdd b d)","decl":"@[to_additive]\ntheorem IsOrderedSMul.smul_le_smul [Preorder G] [Preorder P] [SMul G P] [IsOrderedSMul G P]\n    {a b : G} {c d : P} (hab : a ≤ b) (hcd : c ≤ d) : a • c ≤ b • d :=\n  (IsOrderedSMul.smul_le_smul_left _ _ hcd _).trans (IsOrderedSMul.smul_le_smul_right _ _ hab _)\n\n"}
{"name":"IsOrderedSMul.smul_le_smul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : Preorder G\ninst✝² : Preorder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedSMul G P\na b : G\nc d : P\nhab : LE.le a b\nhcd : LE.le c d\n⊢ LE.le (HSMul.hSMul a c) (HSMul.hSMul b d)","decl":"@[to_additive]\ntheorem IsOrderedSMul.smul_le_smul [Preorder G] [Preorder P] [SMul G P] [IsOrderedSMul G P]\n    {a b : G} {c d : P} (hab : a ≤ b) (hcd : c ≤ d) : a • c ≤ b • d :=\n  (IsOrderedSMul.smul_le_smul_left _ _ hcd _).trans (IsOrderedSMul.smul_le_smul_right _ _ hab _)\n\n"}
{"name":"Monotone.smul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\nγ : Type u_3\ninst✝⁴ : Preorder G\ninst✝³ : Preorder P\ninst✝² : Preorder γ\ninst✝¹ : SMul G P\ninst✝ : IsOrderedSMul G P\nf : γ → G\ng : γ → P\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive]\ntheorem Monotone.smul {γ : Type*} [Preorder G] [Preorder P] [Preorder γ] [SMul G P]\n    [IsOrderedSMul G P] {f : γ → G} {g : γ → P} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x • g x :=\n  fun _ _ hab => (IsOrderedSMul.smul_le_smul_left _ _ (hg hab) _).trans\n    (IsOrderedSMul.smul_le_smul_right _ _ (hf hab) _)\n\n"}
{"name":"Monotone.vadd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\nγ : Type u_3\ninst✝⁴ : Preorder G\ninst✝³ : Preorder P\ninst✝² : Preorder γ\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedVAdd G P\nf : γ → G\ng : γ → P\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive]\ntheorem Monotone.smul {γ : Type*} [Preorder G] [Preorder P] [Preorder γ] [SMul G P]\n    [IsOrderedSMul G P] {f : γ → G} {g : γ → P} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x • g x :=\n  fun _ _ hab => (IsOrderedSMul.smul_le_smul_left _ _ (hg hab) _).trans\n    (IsOrderedSMul.smul_le_smul_right _ _ (hf hab) _)\n\n"}
{"name":"IsCancelVAdd.right_cancel","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝ : VAdd G P\nself : IsCancelVAdd G P\na b : G\nc : P\na✝ : Eq (HVAdd.hVAdd a c) (HVAdd.hVAdd b c)\n⊢ Eq a b","decl":"/-- A vector addition is cancellative if it is pointwise injective on the left and right. -/\nclass IsCancelVAdd (G P : Type*) [VAdd G P] : Prop where\n  protected left_cancel : ∀ (a : G) (b c : P), a +ᵥ b = a +ᵥ c → b = c\n  protected right_cancel : ∀ (a b : G) (c : P), a +ᵥ c = b +ᵥ c → a = b\n\n"}
{"name":"IsCancelVAdd.left_cancel","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝ : VAdd G P\nself : IsCancelVAdd G P\na : G\nb c : P\na✝ : Eq (HVAdd.hVAdd a b) (HVAdd.hVAdd a c)\n⊢ Eq b c","decl":"/-- A vector addition is cancellative if it is pointwise injective on the left and right. -/\nclass IsCancelVAdd (G P : Type*) [VAdd G P] : Prop where\n  protected left_cancel : ∀ (a : G) (b c : P), a +ᵥ b = a +ᵥ c → b = c\n  protected right_cancel : ∀ (a b : G) (c : P), a +ᵥ c = b +ᵥ c → a = b\n\n"}
{"name":"IsCancelSMul.right_cancel","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝ : SMul G P\nself : IsCancelSMul G P\na b : G\nc : P\na✝ : Eq (HSMul.hSMul a c) (HSMul.hSMul b c)\n⊢ Eq a b","decl":"/-- A scalar multiplication is cancellative if it is pointwise injective on the left and right. -/\n@[to_additive]\nclass IsCancelSMul (G P : Type*) [SMul G P] : Prop where\n  protected left_cancel : ∀ (a : G) (b c : P), a • b = a • c → b = c\n  protected right_cancel : ∀ (a b : G) (c : P), a • c = b • c → a = b\n\n"}
{"name":"IsCancelSMul.left_cancel","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝ : SMul G P\nself : IsCancelSMul G P\na : G\nb c : P\na✝ : Eq (HSMul.hSMul a b) (HSMul.hSMul a c)\n⊢ Eq b c","decl":"/-- A scalar multiplication is cancellative if it is pointwise injective on the left and right. -/\n@[to_additive]\nclass IsCancelSMul (G P : Type*) [SMul G P] : Prop where\n  protected left_cancel : ∀ (a : G) (b c : P), a • b = a • c → b = c\n  protected right_cancel : ∀ (a b : G) (c : P), a • c = b • c → a = b\n\n"}
{"name":"IsOrderedCancelVAdd.le_of_vadd_le_vadd_right","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : VAdd G P\nself : IsOrderedCancelVAdd G P\na b : G\nc : P\na✝ : LE.le (HVAdd.hVAdd a c) (HVAdd.hVAdd b c)\n⊢ LE.le a b","decl":"/-- An ordered cancellative vector addition is an ordered vector addition that is cancellative. -/\nclass IsOrderedCancelVAdd (G P : Type*) [LE G] [LE P] [VAdd G P] extends\n    IsOrderedVAdd G P : Prop where\n  protected le_of_vadd_le_vadd_left : ∀ (a : G) (b c : P), a +ᵥ b ≤ a +ᵥ c → b ≤ c\n  protected le_of_vadd_le_vadd_right : ∀ (a b : G) (c : P), a +ᵥ c ≤ b +ᵥ c → a ≤ b\n\n"}
{"name":"IsOrderedCancelVAdd.le_of_vadd_le_vadd_left","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : VAdd G P\nself : IsOrderedCancelVAdd G P\na : G\nb c : P\na✝ : LE.le (HVAdd.hVAdd a b) (HVAdd.hVAdd a c)\n⊢ LE.le b c","decl":"/-- An ordered cancellative vector addition is an ordered vector addition that is cancellative. -/\nclass IsOrderedCancelVAdd (G P : Type*) [LE G] [LE P] [VAdd G P] extends\n    IsOrderedVAdd G P : Prop where\n  protected le_of_vadd_le_vadd_left : ∀ (a : G) (b c : P), a +ᵥ b ≤ a +ᵥ c → b ≤ c\n  protected le_of_vadd_le_vadd_right : ∀ (a b : G) (c : P), a +ᵥ c ≤ b +ᵥ c → a ≤ b\n\n"}
{"name":"IsOrderedCancelVAdd.toIsOrderedVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : VAdd G P\nself : IsOrderedCancelVAdd G P\n⊢ IsOrderedVAdd G P","decl":"/-- An ordered cancellative vector addition is an ordered vector addition that is cancellative. -/\nclass IsOrderedCancelVAdd (G P : Type*) [LE G] [LE P] [VAdd G P] extends\n    IsOrderedVAdd G P : Prop where\n  protected le_of_vadd_le_vadd_left : ∀ (a : G) (b c : P), a +ᵥ b ≤ a +ᵥ c → b ≤ c\n  protected le_of_vadd_le_vadd_right : ∀ (a b : G) (c : P), a +ᵥ c ≤ b +ᵥ c → a ≤ b\n\n"}
{"name":"IsOrderedCancelSMul.le_of_smul_le_smul_right","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : SMul G P\nself : IsOrderedCancelSMul G P\na b : G\nc : P\na✝ : LE.le (HSMul.hSMul a c) (HSMul.hSMul b c)\n⊢ LE.le a b","decl":"/-- An ordered cancellative scalar multiplication is an ordered scalar multiplication that is\n  cancellative. -/\n@[to_additive]\nclass IsOrderedCancelSMul (G P : Type*) [LE G] [LE P] [SMul G P] extends\n    IsOrderedSMul G P : Prop where\n  protected le_of_smul_le_smul_left : ∀ (a : G) (b c : P), a • b ≤ a • c → b ≤ c\n  protected le_of_smul_le_smul_right : ∀ (a b : G) (c : P), a • c ≤ b • c → a ≤ b\n\n"}
{"name":"IsOrderedCancelSMul.le_of_smul_le_smul_left","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : SMul G P\nself : IsOrderedCancelSMul G P\na : G\nb c : P\na✝ : LE.le (HSMul.hSMul a b) (HSMul.hSMul a c)\n⊢ LE.le b c","decl":"/-- An ordered cancellative scalar multiplication is an ordered scalar multiplication that is\n  cancellative. -/\n@[to_additive]\nclass IsOrderedCancelSMul (G P : Type*) [LE G] [LE P] [SMul G P] extends\n    IsOrderedSMul G P : Prop where\n  protected le_of_smul_le_smul_left : ∀ (a : G) (b c : P), a • b ≤ a • c → b ≤ c\n  protected le_of_smul_le_smul_right : ∀ (a b : G) (c : P), a • c ≤ b • c → a ≤ b\n\n"}
{"name":"IsOrderedCancelSMul.toIsOrderedSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_3\nP : Type u_4\ninst✝² : LE G\ninst✝¹ : LE P\ninst✝ : SMul G P\nself : IsOrderedCancelSMul G P\n⊢ IsOrderedSMul G P","decl":"/-- An ordered cancellative scalar multiplication is an ordered scalar multiplication that is\n  cancellative. -/\n@[to_additive]\nclass IsOrderedCancelSMul (G P : Type*) [LE G] [LE P] [SMul G P] extends\n    IsOrderedSMul G P : Prop where\n  protected le_of_smul_le_smul_left : ∀ (a : G) (b c : P), a • b ≤ a • c → b ≤ c\n  protected le_of_smul_le_smul_right : ∀ (a b : G) (c : P), a • c ≤ b • c → a ≤ b\n\n"}
{"name":"instIsCancelVAddOfIsOrderedCancelVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\n⊢ IsCancelVAdd G P","decl":"@[to_additive]\ninstance [PartialOrder G] [PartialOrder P] [SMul G P] [IsOrderedCancelSMul G P] :\n    IsCancelSMul G P where\n  left_cancel a b c h := (IsOrderedCancelSMul.le_of_smul_le_smul_left a b c h.le).antisymm\n    (IsOrderedCancelSMul.le_of_smul_le_smul_left a c b h.ge)\n  right_cancel a b c h := (IsOrderedCancelSMul.le_of_smul_le_smul_right a b c h.le).antisymm\n    (IsOrderedCancelSMul.le_of_smul_le_smul_right b a c h.ge)\n\n"}
{"name":"instIsCancelSMulOfIsOrderedCancelSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : PartialOrder G\ninst✝² : PartialOrder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\n⊢ IsCancelSMul G P","decl":"@[to_additive]\ninstance [PartialOrder G] [PartialOrder P] [SMul G P] [IsOrderedCancelSMul G P] :\n    IsCancelSMul G P where\n  left_cancel a b c h := (IsOrderedCancelSMul.le_of_smul_le_smul_left a b c h.le).antisymm\n    (IsOrderedCancelSMul.le_of_smul_le_smul_left a c b h.ge)\n  right_cancel a b c h := (IsOrderedCancelSMul.le_of_smul_le_smul_right a b c h.le).antisymm\n    (IsOrderedCancelSMul.le_of_smul_le_smul_right b a c h.ge)\n\n"}
{"name":"instIsOrderedCancelVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\ninst✝ : OrderedCancelAddCommMonoid G\n⊢ IsOrderedCancelVAdd G G","decl":"@[to_additive]\ninstance [OrderedCancelCommMonoid G] : IsOrderedCancelSMul G G where\n  le_of_smul_le_smul_left _ _ _ := le_of_mul_le_mul_left'\n  le_of_smul_le_smul_right _ _ _ := le_of_mul_le_mul_right'\n\n"}
{"name":"instIsOrderedCancelSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\ninst✝ : OrderedCancelCommMonoid G\n⊢ IsOrderedCancelSMul G G","decl":"@[to_additive]\ninstance [OrderedCancelCommMonoid G] : IsOrderedCancelSMul G G where\n  le_of_smul_le_smul_left _ _ _ := le_of_mul_le_mul_left'\n  le_of_smul_le_smul_right _ _ _ := le_of_mul_le_mul_right'\n\n"}
{"name":"instContravariantClassHSMulLeOfIsOrderedCancelSMul","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : LE P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\n⊢ ContravariantClass G P (fun x1 x2 => HSMul.hSMul x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance (priority := 200) [LE G] [LE P] [SMul G P] [IsOrderedCancelSMul G P] :\n    ContravariantClass G P (· • ·) (· ≤ ·) :=\n  ⟨IsOrderedCancelSMul.le_of_smul_le_smul_left⟩\n\n"}
{"name":"instContravariantClassHVAddLeOfIsOrderedCancelVAdd","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : LE P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\n⊢ ContravariantClass G P (fun x1 x2 => HVAdd.hVAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"@[to_additive]\ninstance (priority := 200) [LE G] [LE P] [SMul G P] [IsOrderedCancelSMul G P] :\n    ContravariantClass G P (· • ·) (· ≤ ·) :=\n  ⟨IsOrderedCancelSMul.le_of_smul_le_smul_left⟩\n\n"}
{"name":"SMul.smul_lt_smul_of_le_of_lt","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : Preorder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\na b : G\nc d : P\nh₁ : LE.le a b\nh₂ : LT.lt c d\n⊢ LT.lt (HSMul.hSMul a c) (HSMul.hSMul b d)","decl":"@[to_additive]\ntheorem smul_lt_smul_of_le_of_lt [LE G] [Preorder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {a b : G} {c d : P} (h₁ : a ≤ b) (h₂ : c < d) :\n  a • c < b • d := by\n  refine lt_of_le_of_lt (IsOrderedSMul.smul_le_smul_right a b h₁ c) ?_\n  refine lt_of_le_not_le (IsOrderedSMul.smul_le_smul_left c d (le_of_lt h₂) b) ?_\n  by_contra hbdc\n  have h : d ≤ c := IsOrderedCancelSMul.le_of_smul_le_smul_left b d c hbdc\n  rw [@lt_iff_le_not_le] at h₂\n  simp_all only [not_true_eq_false, and_false]\n\n"}
{"name":"VAdd.vadd_lt_vadd_of_le_of_lt","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : LE G\ninst✝² : Preorder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\na b : G\nc d : P\nh₁ : LE.le a b\nh₂ : LT.lt c d\n⊢ LT.lt (HVAdd.hVAdd a c) (HVAdd.hVAdd b d)","decl":"@[to_additive]\ntheorem smul_lt_smul_of_le_of_lt [LE G] [Preorder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {a b : G} {c d : P} (h₁ : a ≤ b) (h₂ : c < d) :\n  a • c < b • d := by\n  refine lt_of_le_of_lt (IsOrderedSMul.smul_le_smul_right a b h₁ c) ?_\n  refine lt_of_le_not_le (IsOrderedSMul.smul_le_smul_left c d (le_of_lt h₂) b) ?_\n  by_contra hbdc\n  have h : d ≤ c := IsOrderedCancelSMul.le_of_smul_le_smul_left b d c hbdc\n  rw [@lt_iff_le_not_le] at h₂\n  simp_all only [not_true_eq_false, and_false]\n\n"}
{"name":"VAdd.vadd_lt_vadd_of_lt_of_le","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : Preorder G\ninst✝² : Preorder P\ninst✝¹ : VAdd G P\ninst✝ : IsOrderedCancelVAdd G P\na b : G\nc d : P\nh₁ : LT.lt a b\nh₂ : LE.le c d\n⊢ LT.lt (HVAdd.hVAdd a c) (HVAdd.hVAdd b d)","decl":"@[to_additive]\ntheorem smul_lt_smul_of_lt_of_le [Preorder G] [Preorder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {a b : G} {c d : P} (h₁ : a < b) (h₂ : c ≤ d) : a • c < b • d := by\n  refine lt_of_le_of_lt (IsOrderedSMul.smul_le_smul_left c d h₂ a) ?_\n  refine lt_of_le_not_le (IsOrderedSMul.smul_le_smul_right a b (le_of_lt h₁) d) ?_\n  by_contra hbad\n  have h : b ≤ a := IsOrderedCancelSMul.le_of_smul_le_smul_right b a d hbad\n  rw [@lt_iff_le_not_le] at h₁\n  simp_all only [not_true_eq_false, and_false]\n\n"}
{"name":"SMul.smul_lt_smul_of_lt_of_le","module":"Mathlib.Algebra.Order.AddTorsor","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝³ : Preorder G\ninst✝² : Preorder P\ninst✝¹ : SMul G P\ninst✝ : IsOrderedCancelSMul G P\na b : G\nc d : P\nh₁ : LT.lt a b\nh₂ : LE.le c d\n⊢ LT.lt (HSMul.hSMul a c) (HSMul.hSMul b d)","decl":"@[to_additive]\ntheorem smul_lt_smul_of_lt_of_le [Preorder G] [Preorder P] [SMul G P] [IsOrderedCancelSMul G P]\n    {a b : G} {c d : P} (h₁ : a < b) (h₂ : c ≤ d) : a • c < b • d := by\n  refine lt_of_le_of_lt (IsOrderedSMul.smul_le_smul_left c d h₂ a) ?_\n  refine lt_of_le_not_le (IsOrderedSMul.smul_le_smul_right a b (le_of_lt h₁) d) ?_\n  by_contra hbad\n  have h : b ≤ a := IsOrderedCancelSMul.le_of_smul_le_smul_right b a d hbad\n  rw [@lt_iff_le_not_le] at h₁\n  simp_all only [not_true_eq_false, and_false]\n\n"}
