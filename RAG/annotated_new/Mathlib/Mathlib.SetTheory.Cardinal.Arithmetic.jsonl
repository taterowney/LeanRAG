{"name":"Cardinal.mul_eq_self","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (HMul.hMul c c) c","decl":"/-- If `α` is an infinite type, then `α × α` and `α` have the same cardinality. -/\ntheorem mul_eq_self {c : Cardinal} (h : ℵ₀ ≤ c) : c * c = c := by\n  refine le_antisymm ?_ (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans h) c)\n  -- the only nontrivial part is `c * c ≤ c`. We prove it inductively.\n  refine Acc.recOn (Cardinal.lt_wf.apply c) (fun c _ => Cardinal.inductionOn c fun α IH ol => ?_) h\n  -- consider the minimal well-order `r` on `α` (a type with cardinality `c`).\n  rcases ord_eq α with ⟨r, wo, e⟩\n  classical\n  letI := linearOrderOfSTO r\n  haveI : IsWellOrder α (· < ·) := wo\n  -- Define an order `s` on `α × α` by writing `(a, b) < (c, d)` if `max a b < max c d`, or\n  -- the max are equal and `a < c`, or the max are equal and `a = c` and `b < d`.\n  let g : α × α → α := fun p => max p.1 p.2\n  let f : α × α ↪ Ordinal × α × α :=\n    ⟨fun p : α × α => (typein (· < ·) (g p), p), fun p q => congr_arg Prod.snd⟩\n  let s := f ⁻¹'o Prod.Lex (· < ·) (Prod.Lex (· < ·) (· < ·))\n  -- this is a well order on `α × α`.\n  haveI : IsWellOrder _ s := (RelEmbedding.preimage _ _).isWellOrder\n  /- it suffices to show that this well order is smaller than `r`\n       if it were larger, then `r` would be a strict prefix of `s`. It would be contained in\n      `β × β` for some `β` of cardinality `< c`. By the inductive assumption, this set has the\n      same cardinality as `β` (or it is finite if `β` is finite), so it is `< c`, which is a\n      contradiction. -/\n  suffices type s ≤ type r by exact card_le_card this\n  refine le_of_forall_lt fun o h => ?_\n  rcases typein_surj s h with ⟨p, rfl⟩\n  rw [← e, lt_ord]\n  refine lt_of_le_of_lt\n    (?_ : _ ≤ card (succ (typein (· < ·) (g p))) * card (succ (typein (· < ·) (g p)))) ?_\n  · have : { q | s q p } ⊆ insert (g p) { x | x < g p } ×ˢ insert (g p) { x | x < g p } := by\n      intro q h\n      simp only [s, f, Preimage, Embedding.coeFn_mk, Prod.lex_def, typein_lt_typein,\n        typein_inj, mem_setOf_eq] at h\n      exact max_le_iff.1 (le_iff_lt_or_eq.2 <| h.imp_right And.left)\n    suffices H : (insert (g p) { x | r x (g p) } : Set α) ≃ { x | r x (g p) } ⊕ PUnit from\n      ⟨(Set.embeddingOfSubset _ _ this).trans\n        ((Equiv.Set.prod _ _).trans (H.prodCongr H)).toEmbedding⟩\n    refine (Equiv.Set.insert ?_).trans ((Equiv.refl _).sumCongr punitEquivPUnit)\n    apply @irrefl _ r\n  cases' lt_or_le (card (succ (typein (· < ·) (g p)))) ℵ₀ with qo qo\n  · exact (mul_lt_aleph0 qo qo).trans_le ol\n  · suffices (succ (typein LT.lt (g p))).card < #α from (IH _ this qo).trans_lt this\n    rw [← lt_ord]\n    apply (isLimit_ord ol).succ_lt\n    rw [e]\n    apply typein_lt_type\n\n"}
{"name":"Cardinal.mul_eq_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\nhb : LE.le Cardinal.aleph0 b\n⊢ Eq (HMul.hMul a b) (Max.max a b)","decl":"/-- If `α` and `β` are infinite types, then the cardinality of `α × β` is the maximum\nof the cardinalities of `α` and `β`. -/\ntheorem mul_eq_max {a b : Cardinal} (ha : ℵ₀ ≤ a) (hb : ℵ₀ ≤ b) : a * b = max a b :=\n  le_antisymm\n      (mul_eq_self (ha.trans (le_max_left a b)) ▸\n        mul_le_mul' (le_max_left _ _) (le_max_right _ _)) <|\n    max_le (by simpa only [mul_one] using mul_le_mul_left' (one_le_aleph0.trans hb) a)\n      (by simpa only [one_mul] using mul_le_mul_right' (one_le_aleph0.trans ha) b)\n\n"}
{"name":"Cardinal.mul_mk_eq_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝¹ : Infinite α\ninst✝ : Infinite β\n⊢ Eq (HMul.hMul (Cardinal.mk α) (Cardinal.mk β)) (Max.max (Cardinal.mk α) (Cardinal.mk β))","decl":"@[simp]\ntheorem mul_mk_eq_max {α β : Type u} [Infinite α] [Infinite β] : #α * #β = max #α #β :=\n  mul_eq_max (aleph0_le_mk α) (aleph0_le_mk β)\n\n"}
{"name":"Cardinal.aleph_mul_aleph","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (HMul.hMul (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (Cardinal.aleph (Max.max o₁ o₂))","decl":"@[simp]\ntheorem aleph_mul_aleph (o₁ o₂ : Ordinal) : ℵ_ o₁ * ℵ_ o₂ = ℵ_ (max o₁ o₂) := by\n  rw [Cardinal.mul_eq_max (aleph0_le_aleph o₁) (aleph0_le_aleph o₂), aleph_max]\n\n"}
{"name":"Cardinal.aleph0_mul_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HMul.hMul Cardinal.aleph0 a) a","decl":"@[simp]\ntheorem aleph0_mul_eq {a : Cardinal} (ha : ℵ₀ ≤ a) : ℵ₀ * a = a :=\n  (mul_eq_max le_rfl ha).trans (max_eq_right ha)\n\n"}
{"name":"Cardinal.mul_aleph0_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HMul.hMul a Cardinal.aleph0) a","decl":"@[simp]\ntheorem mul_aleph0_eq {a : Cardinal} (ha : ℵ₀ ≤ a) : a * ℵ₀ = a :=\n  (mul_eq_max ha le_rfl).trans (max_eq_left ha)\n\n"}
{"name":"Cardinal.aleph0_mul_mk_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (HMul.hMul Cardinal.aleph0 (Cardinal.mk α)) (Cardinal.mk α)","decl":"theorem aleph0_mul_mk_eq {α : Type*} [Infinite α] : ℵ₀ * #α = #α :=\n  aleph0_mul_eq (aleph0_le_mk α)\n\n"}
{"name":"Cardinal.mk_mul_aleph0_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (HMul.hMul (Cardinal.mk α) Cardinal.aleph0) (Cardinal.mk α)","decl":"theorem mk_mul_aleph0_eq {α : Type*} [Infinite α] : #α * ℵ₀ = #α :=\n  mul_aleph0_eq (aleph0_le_mk α)\n\n"}
{"name":"Cardinal.aleph0_mul_aleph","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (HMul.hMul Cardinal.aleph0 (Cardinal.aleph o)) (Cardinal.aleph o)","decl":"@[simp]\ntheorem aleph0_mul_aleph (o : Ordinal) : ℵ₀ * ℵ_ o = ℵ_ o :=\n  aleph0_mul_eq (aleph0_le_aleph o)\n\n"}
{"name":"Cardinal.aleph_mul_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (HMul.hMul (Cardinal.aleph o) Cardinal.aleph0) (Cardinal.aleph o)","decl":"@[simp]\ntheorem aleph_mul_aleph0 (o : Ordinal) : ℵ_ o * ℵ₀ = ℵ_ o :=\n  mul_aleph0_eq (aleph0_le_aleph o)\n\n"}
{"name":"Cardinal.mul_lt_of_lt","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\nh1 : LT.lt a c\nh2 : LT.lt b c\n⊢ LT.lt (HMul.hMul a b) c","decl":"theorem mul_lt_of_lt {a b c : Cardinal} (hc : ℵ₀ ≤ c) (h1 : a < c) (h2 : b < c) : a * b < c :=\n  (mul_le_mul' (le_max_left a b) (le_max_right a b)).trans_lt <|\n    (lt_or_le (max a b) ℵ₀).elim (fun h => (mul_lt_aleph0 h h).trans_le hc) fun h => by\n      rw [mul_eq_self h]\n      exact max_lt h1 h2\n\n"}
{"name":"Cardinal.mul_le_max_of_aleph0_le_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 a\n⊢ LE.le (HMul.hMul a b) (Max.max a b)","decl":"theorem mul_le_max_of_aleph0_le_left {a b : Cardinal} (h : ℵ₀ ≤ a) : a * b ≤ max a b := by\n  convert mul_le_mul' (le_max_left a b) (le_max_right a b) using 1\n  rw [mul_eq_self]\n  exact h.trans (le_max_left a b)\n\n"}
{"name":"Cardinal.mul_eq_max_of_aleph0_le_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 a\nh' : Ne b 0\n⊢ Eq (HMul.hMul a b) (Max.max a b)","decl":"theorem mul_eq_max_of_aleph0_le_left {a b : Cardinal} (h : ℵ₀ ≤ a) (h' : b ≠ 0) :\n    a * b = max a b := by\n  rcases le_or_lt ℵ₀ b with hb | hb\n  · exact mul_eq_max h hb\n  refine (mul_le_max_of_aleph0_le_left h).antisymm ?_\n  have : b ≤ a := hb.le.trans h\n  rw [max_eq_left this]\n  convert mul_le_mul_left' (one_le_iff_ne_zero.mpr h') a\n  rw [mul_one]\n\n"}
{"name":"Cardinal.mul_le_max_of_aleph0_le_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 b\n⊢ LE.le (HMul.hMul a b) (Max.max a b)","decl":"theorem mul_le_max_of_aleph0_le_right {a b : Cardinal} (h : ℵ₀ ≤ b) : a * b ≤ max a b := by\n  simpa only [mul_comm b, max_comm b] using mul_le_max_of_aleph0_le_left h\n\n"}
{"name":"Cardinal.mul_eq_max_of_aleph0_le_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh' : Ne a 0\nh : LE.le Cardinal.aleph0 b\n⊢ Eq (HMul.hMul a b) (Max.max a b)","decl":"theorem mul_eq_max_of_aleph0_le_right {a b : Cardinal} (h' : a ≠ 0) (h : ℵ₀ ≤ b) :\n    a * b = max a b := by\n  rw [mul_comm, max_comm]\n  exact mul_eq_max_of_aleph0_le_left h h'\n\n"}
{"name":"Cardinal.mul_eq_max'","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 (HMul.hMul a b)\n⊢ Eq (HMul.hMul a b) (Max.max a b)","decl":"theorem mul_eq_max' {a b : Cardinal} (h : ℵ₀ ≤ a * b) : a * b = max a b := by\n  rcases aleph0_le_mul_iff.mp h with ⟨ha, hb, ha' | hb'⟩\n  · exact mul_eq_max_of_aleph0_le_left ha' hb\n  · exact mul_eq_max_of_aleph0_le_right ha hb'\n\n"}
{"name":"Cardinal.mul_le_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\n⊢ LE.le (HMul.hMul a b) (Max.max (Max.max a b) Cardinal.aleph0)","decl":"theorem mul_le_max (a b : Cardinal) : a * b ≤ max (max a b) ℵ₀ := by\n  rcases eq_or_ne a 0 with (rfl | ha0); · simp\n  rcases eq_or_ne b 0 with (rfl | hb0); · simp\n  rcases le_or_lt ℵ₀ a with ha | ha\n  · rw [mul_eq_max_of_aleph0_le_left ha hb0]\n    exact le_max_left _ _\n  · rcases le_or_lt ℵ₀ b with hb | hb\n    · rw [mul_comm, mul_eq_max_of_aleph0_le_left hb ha0, max_comm]\n      exact le_max_left _ _\n    · exact le_max_of_le_right (mul_lt_aleph0 ha hb).le\n\n"}
{"name":"Cardinal.mul_eq_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\nhb : LE.le b a\nhb' : Ne b 0\n⊢ Eq (HMul.hMul a b) a","decl":"theorem mul_eq_left {a b : Cardinal} (ha : ℵ₀ ≤ a) (hb : b ≤ a) (hb' : b ≠ 0) : a * b = a := by\n  rw [mul_eq_max_of_aleph0_le_left ha hb', max_eq_left hb]\n\n"}
{"name":"Cardinal.mul_eq_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nhb : LE.le Cardinal.aleph0 b\nha : LE.le a b\nha' : Ne a 0\n⊢ Eq (HMul.hMul a b) b","decl":"theorem mul_eq_right {a b : Cardinal} (hb : ℵ₀ ≤ b) (ha : a ≤ b) (ha' : a ≠ 0) : a * b = b := by\n  rw [mul_comm, mul_eq_left hb ha ha']\n\n"}
{"name":"Cardinal.le_mul_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : Ne b 0\n⊢ LE.le a (HMul.hMul b a)","decl":"theorem le_mul_left {a b : Cardinal} (h : b ≠ 0) : a ≤ b * a := by\n  convert mul_le_mul_right' (one_le_iff_ne_zero.mpr h) a\n  rw [one_mul]\n\n"}
{"name":"Cardinal.le_mul_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nh : Ne b 0\n⊢ LE.le a (HMul.hMul a b)","decl":"theorem le_mul_right {a b : Cardinal} (h : b ≠ 0) : a ≤ a * b := by\n  rw [mul_comm]\n  exact le_mul_left h\n\n"}
{"name":"Cardinal.mul_eq_left_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (Eq (HMul.hMul a b) a) (Or (And (LE.le (Max.max Cardinal.aleph0 b) a) (Ne b 0)) (Or (Eq b 1) (Eq a 0)))","decl":"theorem mul_eq_left_iff {a b : Cardinal} : a * b = a ↔ max ℵ₀ b ≤ a ∧ b ≠ 0 ∨ b = 1 ∨ a = 0 := by\n  rw [max_le_iff]\n  refine ⟨fun h => ?_, ?_⟩\n  · rcases le_or_lt ℵ₀ a with ha | ha\n    · have : a ≠ 0 := by\n        rintro rfl\n        exact ha.not_lt aleph0_pos\n      left\n      rw [and_assoc]\n      use ha\n      constructor\n      · rw [← not_lt]\n        exact fun hb => ne_of_gt (hb.trans_le (le_mul_left this)) h\n      · rintro rfl\n        apply this\n        rw [mul_zero] at h\n        exact h.symm\n    right\n    by_cases h2a : a = 0\n    · exact Or.inr h2a\n    have hb : b ≠ 0 := by\n      rintro rfl\n      apply h2a\n      rw [mul_zero] at h\n      exact h.symm\n    left\n    rw [← h, mul_lt_aleph0_iff, lt_aleph0, lt_aleph0] at ha\n    rcases ha with (rfl | rfl | ⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩)\n    · contradiction\n    · contradiction\n    rw [← Ne] at h2a\n    rw [← one_le_iff_ne_zero] at h2a hb\n    norm_cast at h2a hb h ⊢\n    apply le_antisymm _ hb\n    rw [← not_lt]\n    apply fun h2b => ne_of_gt _ h\n    conv_rhs => left; rw [← mul_one n]\n    rw [Nat.mul_lt_mul_left]\n    · exact id\n    apply Nat.lt_of_succ_le h2a\n  · rintro (⟨⟨ha, hab⟩, hb⟩ | rfl | rfl)\n    · rw [mul_eq_max_of_aleph0_le_left ha hb, max_eq_left hab]\n    all_goals simp\n\n"}
{"name":"Cardinal.add_eq_self","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (HAdd.hAdd c c) c","decl":"/-- If `α` is an infinite type, then `α ⊕ α` and `α` have the same cardinality. -/\ntheorem add_eq_self {c : Cardinal} (h : ℵ₀ ≤ c) : c + c = c :=\n  le_antisymm\n    (by\n      convert mul_le_mul_right' ((nat_lt_aleph0 2).le.trans h) c using 1\n      <;> simp [two_mul, mul_eq_self h])\n    (self_le_add_left c c)\n\n"}
{"name":"Cardinal.add_eq_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HAdd.hAdd a b) (Max.max a b)","decl":"/-- If `α` is an infinite type, then the cardinality of `α ⊕ β` is the maximum\nof the cardinalities of `α` and `β`. -/\ntheorem add_eq_max {a b : Cardinal} (ha : ℵ₀ ≤ a) : a + b = max a b :=\n  le_antisymm\n      (add_eq_self (ha.trans (le_max_left a b)) ▸\n        add_le_add (le_max_left _ _) (le_max_right _ _)) <|\n    max_le (self_le_add_right _ _) (self_le_add_left _ _)\n\n"}
{"name":"Cardinal.add_eq_max'","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 b\n⊢ Eq (HAdd.hAdd a b) (Max.max a b)","decl":"theorem add_eq_max' {a b : Cardinal} (ha : ℵ₀ ≤ b) : a + b = max a b := by\n  rw [add_comm, max_comm, add_eq_max ha]\n\n"}
{"name":"Cardinal.add_mk_eq_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite α\n⊢ Eq (HAdd.hAdd (Cardinal.mk α) (Cardinal.mk β)) (Max.max (Cardinal.mk α) (Cardinal.mk β))","decl":"@[simp]\ntheorem add_mk_eq_max {α β : Type u} [Infinite α] : #α + #β = max #α #β :=\n  add_eq_max (aleph0_le_mk α)\n\n"}
{"name":"Cardinal.add_mk_eq_max'","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite β\n⊢ Eq (HAdd.hAdd (Cardinal.mk α) (Cardinal.mk β)) (Max.max (Cardinal.mk α) (Cardinal.mk β))","decl":"@[simp]\ntheorem add_mk_eq_max' {α β : Type u} [Infinite β] : #α + #β = max #α #β :=\n  add_eq_max' (aleph0_le_mk β)\n\n"}
{"name":"Cardinal.add_mk_eq_self","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (HAdd.hAdd (Cardinal.mk α) (Cardinal.mk α)) (Cardinal.mk α)","decl":"theorem add_mk_eq_self {α : Type*} [Infinite α] : #α + #α = #α := by\n  simp\n\n"}
{"name":"Cardinal.add_le_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\n⊢ LE.le (HAdd.hAdd a b) (Max.max (Max.max a b) Cardinal.aleph0)","decl":"theorem add_le_max (a b : Cardinal) : a + b ≤ max (max a b) ℵ₀ := by\n  rcases le_or_lt ℵ₀ a with ha | ha\n  · rw [add_eq_max ha]\n    exact le_max_left _ _\n  · rcases le_or_lt ℵ₀ b with hb | hb\n    · rw [add_comm, add_eq_max hb, max_comm]\n      exact le_max_left _ _\n    · exact le_max_of_le_right (add_lt_aleph0 ha hb).le\n\n"}
{"name":"Cardinal.add_le_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\nh1 : LE.le a c\nh2 : LE.le b c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"theorem add_le_of_le {a b c : Cardinal} (hc : ℵ₀ ≤ c) (h1 : a ≤ c) (h2 : b ≤ c) : a + b ≤ c :=\n  (add_le_add h1 h2).trans <| le_of_eq <| add_eq_self hc\n\n"}
{"name":"Cardinal.add_lt_of_lt","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\nh1 : LT.lt a c\nh2 : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) c","decl":"theorem add_lt_of_lt {a b c : Cardinal} (hc : ℵ₀ ≤ c) (h1 : a < c) (h2 : b < c) : a + b < c :=\n  (add_le_add (le_max_left a b) (le_max_right a b)).trans_lt <|\n    (lt_or_le (max a b) ℵ₀).elim (fun h => (add_lt_aleph0 h h).trans_le hc) fun h => by\n      rw [add_eq_self h]; exact max_lt h1 h2\n\n"}
{"name":"Cardinal.eq_of_add_eq_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nh : Eq (HAdd.hAdd a b) c\nha : LT.lt a c\nhc : LE.le Cardinal.aleph0 c\n⊢ Eq b c","decl":"theorem eq_of_add_eq_of_aleph0_le {a b c : Cardinal} (h : a + b = c) (ha : a < c) (hc : ℵ₀ ≤ c) :\n    b = c := by\n  apply le_antisymm\n  · rw [← h]\n    apply self_le_add_left\n  rw [← not_lt]; intro hb\n  have : a + b < c := add_lt_of_lt hc ha hb\n  simp [h, lt_irrefl] at this\n\n"}
{"name":"Cardinal.add_eq_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\nhb : LE.le b a\n⊢ Eq (HAdd.hAdd a b) a","decl":"theorem add_eq_left {a b : Cardinal} (ha : ℵ₀ ≤ a) (hb : b ≤ a) : a + b = a := by\n  rw [add_eq_max ha, max_eq_left hb]\n\n"}
{"name":"Cardinal.add_eq_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\nhb : LE.le Cardinal.aleph0 b\nha : LE.le a b\n⊢ Eq (HAdd.hAdd a b) b","decl":"theorem add_eq_right {a b : Cardinal} (hb : ℵ₀ ≤ b) (ha : a ≤ b) : a + b = b := by\n  rw [add_comm, add_eq_left hb ha]\n\n"}
{"name":"Cardinal.add_eq_left_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (Eq (HAdd.hAdd a b) a) (Or (LE.le (Max.max Cardinal.aleph0 b) a) (Eq b 0))","decl":"theorem add_eq_left_iff {a b : Cardinal} : a + b = a ↔ max ℵ₀ b ≤ a ∨ b = 0 := by\n  rw [max_le_iff]\n  refine ⟨fun h => ?_, ?_⟩\n  · rcases le_or_lt ℵ₀ a with ha | ha\n    · left\n      use ha\n      rw [← not_lt]\n      apply fun hb => ne_of_gt _ h\n      intro hb\n      exact hb.trans_le (self_le_add_left b a)\n    right\n    rw [← h, add_lt_aleph0_iff, lt_aleph0, lt_aleph0] at ha\n    rcases ha with ⟨⟨n, rfl⟩, ⟨m, rfl⟩⟩\n    norm_cast at h ⊢\n    rw [← add_right_inj, h, add_zero]\n  · rintro (⟨h1, h2⟩ | h3)\n    · rw [add_eq_max h1, max_eq_left h2]\n    · rw [h3, add_zero]\n\n"}
{"name":"Cardinal.add_eq_right_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u_1}\n⊢ Iff (Eq (HAdd.hAdd a b) b) (Or (LE.le (Max.max Cardinal.aleph0 a) b) (Eq a 0))","decl":"theorem add_eq_right_iff {a b : Cardinal} : a + b = b ↔ max ℵ₀ a ≤ b ∨ a = 0 := by\n  rw [add_comm, add_eq_left_iff]\n\n"}
{"name":"Cardinal.add_nat_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Cardinal.{u_1}\nn : Nat\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HAdd.hAdd a ↑n) a","decl":"theorem add_nat_eq {a : Cardinal} (n : ℕ) (ha : ℵ₀ ≤ a) : a + n = a :=\n  add_eq_left ha ((nat_lt_aleph0 _).le.trans ha)\n\n"}
{"name":"Cardinal.nat_add_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Cardinal.{u_1}\nn : Nat\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HAdd.hAdd (↑n) a) a","decl":"theorem nat_add_eq {a : Cardinal} (n : ℕ) (ha : ℵ₀ ≤ a) : n + a = a := by\n  rw [add_comm, add_nat_eq n ha]\n\n"}
{"name":"Cardinal.add_one_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Cardinal.{u_1}\nha : LE.le Cardinal.aleph0 a\n⊢ Eq (HAdd.hAdd a 1) a","decl":"theorem add_one_eq {a : Cardinal} (ha : ℵ₀ ≤ a) : a + 1 = a :=\n  add_one_of_aleph0_le ha\n\n"}
{"name":"Cardinal.mk_add_one_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Eq (HAdd.hAdd (Cardinal.mk α) 1) (Cardinal.mk α)","decl":"theorem mk_add_one_eq {α : Type*} [Infinite α] : #α + 1 = #α :=\n  add_one_eq (aleph0_le_mk α)\n\n"}
{"name":"Cardinal.eq_of_add_eq_add_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\nha : LT.lt a Cardinal.aleph0\n⊢ Eq b c","decl":"protected theorem eq_of_add_eq_add_left {a b c : Cardinal} (h : a + b = a + c) (ha : a < ℵ₀) :\n    b = c := by\n  rcases le_or_lt ℵ₀ b with hb | hb\n  · have : a < b := ha.trans_le hb\n    rw [add_eq_right hb this.le, eq_comm] at h\n    rw [eq_of_add_eq_of_aleph0_le h this hb]\n  · have hc : c < ℵ₀ := by\n      rw [← not_le]\n      intro hc\n      apply lt_irrefl ℵ₀\n      apply (hc.trans (self_le_add_left _ a)).trans_lt\n      rw [← h]\n      apply add_lt_aleph0 ha hb\n    rw [lt_aleph0] at *\n    rcases ha with ⟨n, rfl⟩\n    rcases hb with ⟨m, rfl⟩\n    rcases hc with ⟨k, rfl⟩\n    norm_cast at h ⊢\n    apply add_left_cancel h\n\n"}
{"name":"Cardinal.eq_of_add_eq_add_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b c : Cardinal.{u_1}\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\nhb : LT.lt b Cardinal.aleph0\n⊢ Eq a c","decl":"protected theorem eq_of_add_eq_add_right {a b c : Cardinal} (h : a + b = c + b) (hb : b < ℵ₀) :\n    a = c := by\n  rw [add_comm a b, add_comm c b] at h\n  exact Cardinal.eq_of_add_eq_add_left h hb\n\n"}
{"name":"Cardinal.ciSup_add","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\ninst✝ : Nonempty ι\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\n⊢ Eq (HAdd.hAdd (iSup fun i => f i) c) (iSup fun i => HAdd.hAdd (f i) c)","decl":"protected theorem ciSup_add (hf : BddAbove (range f)) (c : Cardinal.{v}) :\n    (⨆ i, f i) + c = ⨆ i, f i + c := by\n  have : ∀ i, f i + c ≤ (⨆ i, f i) + c := fun i ↦ add_le_add_right (le_ciSup hf i) c\n  refine le_antisymm ?_ (ciSup_le' this)\n  have bdd : BddAbove (range (f · + c)) := ⟨_, forall_mem_range.mpr this⟩\n  obtain hs | hs := lt_or_le (⨆ i, f i) ℵ₀\n  · obtain ⟨i, hi⟩ := exists_eq_of_iSup_eq_of_not_isSuccLimit\n      f hf (not_isSuccLimit_of_lt_aleph0 hs) rfl\n    exact hi ▸ le_ciSup bdd i\n  rw [add_eq_max hs, max_le_iff]\n  exact ⟨ciSup_mono bdd fun i ↦ self_le_add_right _ c,\n    (self_le_add_left _ _).trans (le_ciSup bdd <| Classical.arbitrary ι)⟩\n\n"}
{"name":"Cardinal.add_ciSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\ninst✝ : Nonempty ι\nhf : BddAbove (Set.range f)\nc : Cardinal.{v}\n⊢ Eq (HAdd.hAdd c (iSup fun i => f i)) (iSup fun i => HAdd.hAdd c (f i))","decl":"protected theorem add_ciSup (hf : BddAbove (range f)) (c : Cardinal.{v}) :\n    c + (⨆ i, f i) = ⨆ i, c + f i := by\n  rw [add_comm, Cardinal.ciSup_add f hf]; simp_rw [add_comm]\n\n"}
{"name":"Cardinal.ciSup_add_ciSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type w\nf : ι → Cardinal.{v}\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty ι'\nhf : BddAbove (Set.range f)\ng : ι' → Cardinal.{v}\nhg : BddAbove (Set.range g)\n⊢ Eq (HAdd.hAdd (iSup fun i => f i) (iSup fun j => g j)) (iSup fun i => iSup fun j => HAdd.hAdd (f i) (g j))","decl":"protected theorem ciSup_add_ciSup (hf : BddAbove (range f)) (g : ι' → Cardinal.{v})\n    (hg : BddAbove (range g)) :\n    (⨆ i, f i) + (⨆ j, g j) = ⨆ (i) (j), f i + g j := by\n  simp_rw [Cardinal.ciSup_add f hf, Cardinal.add_ciSup g hg]\n\n"}
{"name":"Cardinal.ciSup_mul","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\nc : Cardinal.{v}\n⊢ Eq (HMul.hMul (iSup fun i => f i) c) (iSup fun i => HMul.hMul (f i) c)","decl":"protected theorem ciSup_mul (c : Cardinal.{v}) : (⨆ i, f i) * c = ⨆ i, f i * c := by\n  cases isEmpty_or_nonempty ι; · simp\n  obtain rfl | h0 := eq_or_ne c 0; · simp\n  by_cases hf : BddAbove (range f); swap\n  · have hfc : ¬ BddAbove (range (f · * c)) := fun bdd ↦ hf\n      ⟨⨆ i, f i * c, forall_mem_range.mpr fun i ↦ (le_mul_right h0).trans (le_ciSup bdd i)⟩\n    simp [iSup, csSup_of_not_bddAbove, hf, hfc]\n  have : ∀ i, f i * c ≤ (⨆ i, f i) * c := fun i ↦ mul_le_mul_right' (le_ciSup hf i) c\n  refine le_antisymm ?_ (ciSup_le' this)\n  have bdd : BddAbove (range (f · * c)) := ⟨_, forall_mem_range.mpr this⟩\n  obtain hs | hs := lt_or_le (⨆ i, f i) ℵ₀\n  · obtain ⟨i, hi⟩ := exists_eq_of_iSup_eq_of_not_isSuccLimit\n      f hf (not_isSuccLimit_of_lt_aleph0 hs) rfl\n    exact hi ▸ le_ciSup bdd i\n  rw [mul_eq_max_of_aleph0_le_left hs h0, max_le_iff]\n  obtain ⟨i, hi⟩ := exists_lt_of_lt_ciSup' (one_lt_aleph0.trans_le hs)\n  exact ⟨ciSup_mono bdd fun i ↦ le_mul_right h0,\n    (le_mul_left (zero_lt_one.trans hi).ne').trans (le_ciSup bdd i)⟩\n\n"}
{"name":"Cardinal.mul_ciSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{v}\nc : Cardinal.{v}\n⊢ Eq (HMul.hMul c (iSup fun i => f i)) (iSup fun i => HMul.hMul c (f i))","decl":"protected theorem mul_ciSup (c : Cardinal.{v}) : c * (⨆ i, f i) = ⨆ i, c * f i := by\n  rw [mul_comm, Cardinal.ciSup_mul f]; simp_rw [mul_comm]\n\n"}
{"name":"Cardinal.ciSup_mul_ciSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type w\nf : ι → Cardinal.{v}\ng : ι' → Cardinal.{v}\n⊢ Eq (HMul.hMul (iSup fun i => f i) (iSup fun j => g j)) (iSup fun i => iSup fun j => HMul.hMul (f i) (g j))","decl":"protected theorem ciSup_mul_ciSup (g : ι' → Cardinal.{v}) :\n    (⨆ i, f i) * (⨆ j, g j) = ⨆ (i) (j), f i * g j := by\n  simp_rw [Cardinal.ciSup_mul f, Cardinal.mul_ciSup g]\n\n"}
{"name":"Cardinal.sum_eq_iSup_lift","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{max u v}\nhι : LE.le Cardinal.aleph0 (Cardinal.mk ι)\nh : LE.le (Cardinal.lift.{v, u} (Cardinal.mk ι)) (iSup f)\n⊢ Eq (Cardinal.sum f) (iSup f)","decl":"theorem sum_eq_iSup_lift {f : ι → Cardinal.{max u v}} (hι : ℵ₀ ≤ #ι)\n    (h : lift.{v} #ι ≤ iSup f) : sum f = iSup f := by\n  apply (iSup_le_sum f).antisymm'\n  convert sum_le_iSup_lift f\n  rw [mul_eq_max (aleph0_le_lift.mpr hι) ((aleph0_le_lift.mpr hι).trans h), max_eq_right h]\n\n"}
{"name":"Cardinal.sum_eq_iSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Cardinal.{u}\nhι : LE.le Cardinal.aleph0 (Cardinal.mk ι)\nh : LE.le (Cardinal.mk ι) (iSup f)\n⊢ Eq (Cardinal.sum f) (iSup f)","decl":"theorem sum_eq_iSup {f : ι → Cardinal.{u}} (hι : ℵ₀ ≤ #ι) (h : #ι ≤ iSup f) : sum f = iSup f :=\n  sum_eq_iSup_lift hι ((lift_id #ι).symm ▸ h)\n\n"}
{"name":"Cardinal.aleph_add_aleph","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o₁ o₂ : Ordinal.{u_1}\n⊢ Eq (HAdd.hAdd (Cardinal.aleph o₁) (Cardinal.aleph o₂)) (Cardinal.aleph (Max.max o₁ o₂))","decl":"@[simp]\ntheorem aleph_add_aleph (o₁ o₂ : Ordinal) : ℵ_ o₁ + ℵ_ o₂ = ℵ_ (max o₁ o₂) := by\n  rw [Cardinal.add_eq_max (aleph0_le_aleph o₁), aleph_max]\n\n"}
{"name":"Cardinal.add_right_inj_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β γ : Cardinal.{u_1}\nγ₀ : LT.lt γ Cardinal.aleph0\n⊢ Iff (Eq (HAdd.hAdd α γ) (HAdd.hAdd β γ)) (Eq α β)","decl":"theorem add_right_inj_of_lt_aleph0 {α β γ : Cardinal} (γ₀ : γ < aleph0) : α + γ = β + γ ↔ α = β :=\n  ⟨fun h => Cardinal.eq_of_add_eq_add_right h γ₀, fun h => congr_arg (· + γ) h⟩\n\n"}
{"name":"Cardinal.add_nat_inj","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Cardinal.{u_1}\nn : Nat\n⊢ Iff (Eq (HAdd.hAdd α ↑n) (HAdd.hAdd β ↑n)) (Eq α β)","decl":"@[simp]\ntheorem add_nat_inj {α β : Cardinal} (n : ℕ) : α + n = β + n ↔ α = β :=\n  add_right_inj_of_lt_aleph0 (nat_lt_aleph0 _)\n\n"}
{"name":"Cardinal.add_one_inj","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Cardinal.{u_1}\n⊢ Iff (Eq (HAdd.hAdd α 1) (HAdd.hAdd β 1)) (Eq α β)","decl":"@[simp]\ntheorem add_one_inj {α β : Cardinal} : α + 1 = β + 1 ↔ α = β :=\n  add_right_inj_of_lt_aleph0 one_lt_aleph0\n\n"}
{"name":"Cardinal.add_le_add_iff_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β γ : Cardinal.{u_1}\nγ₀ : LT.lt γ Cardinal.aleph0\n⊢ Iff (LE.le (HAdd.hAdd α γ) (HAdd.hAdd β γ)) (LE.le α β)","decl":"theorem add_le_add_iff_of_lt_aleph0 {α β γ : Cardinal} (γ₀ : γ < ℵ₀) :\n    α + γ ≤ β + γ ↔ α ≤ β := by\n  refine ⟨fun h => ?_, fun h => add_le_add_right h γ⟩\n  contrapose h\n  rw [not_le, lt_iff_le_and_ne, Ne] at h ⊢\n  exact ⟨add_le_add_right h.1 γ, mt (add_right_inj_of_lt_aleph0 γ₀).1 h.2⟩\n\n"}
{"name":"Cardinal.add_nat_le_add_nat_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Cardinal.{u_1}\nn : Nat\n⊢ Iff (LE.le (HAdd.hAdd α ↑n) (HAdd.hAdd β ↑n)) (LE.le α β)","decl":"@[simp]\ntheorem add_nat_le_add_nat_iff {α β : Cardinal} (n : ℕ) : α + n ≤ β + n ↔ α ≤ β :=\n  add_le_add_iff_of_lt_aleph0 (nat_lt_aleph0 n)\n\n"}
{"name":"Cardinal.add_one_le_add_one_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Cardinal.{u_1}\n⊢ Iff (LE.le (HAdd.hAdd α 1) (HAdd.hAdd β 1)) (LE.le α β)","decl":"@[simp]\ntheorem add_one_le_add_one_iff {α β : Cardinal} : α + 1 ≤ β + 1 ↔ α ≤ β :=\n  add_le_add_iff_of_lt_aleph0 one_lt_aleph0\n\n"}
{"name":"Cardinal.pow_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"κ μ : Cardinal.{u}\nH1 : LE.le Cardinal.aleph0 κ\nH2 : LT.lt μ Cardinal.aleph0\n⊢ LE.le (HPow.hPow κ μ) κ","decl":"theorem pow_le {κ μ : Cardinal.{u}} (H1 : ℵ₀ ≤ κ) (H2 : μ < ℵ₀) : κ ^ μ ≤ κ :=\n  let ⟨n, H3⟩ := lt_aleph0.1 H2\n  H3.symm ▸\n    Quotient.inductionOn κ\n      (fun α H1 =>\n        Nat.recOn n\n          (lt_of_lt_of_le\n              (by\n                rw [Nat.cast_zero, power_zero]\n                exact one_lt_aleph0)\n              H1).le\n          fun n ih =>\n          le_of_le_of_eq\n            (by\n              rw [Nat.cast_succ, power_add, power_one]\n              exact mul_le_mul_right' ih _)\n            (mul_eq_self H1))\n      H1\n\n"}
{"name":"Cardinal.pow_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"κ μ : Cardinal.{u}\nH1 : LE.le Cardinal.aleph0 κ\nH2 : LE.le 1 μ\nH3 : LT.lt μ Cardinal.aleph0\n⊢ Eq (HPow.hPow κ μ) κ","decl":"theorem pow_eq {κ μ : Cardinal.{u}} (H1 : ℵ₀ ≤ κ) (H2 : 1 ≤ μ) (H3 : μ < ℵ₀) : κ ^ μ = κ :=\n  (pow_le H1 H3).antisymm <| self_le_power κ H2\n\n"}
{"name":"Cardinal.power_self_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (HPow.hPow c c) (HPow.hPow 2 c)","decl":"theorem power_self_eq {c : Cardinal} (h : ℵ₀ ≤ c) : c ^ c = 2 ^ c := by\n  apply ((power_le_power_right <| (cantor c).le).trans _).antisymm\n  · exact power_le_power_right ((nat_lt_aleph0 2).le.trans h)\n  · rw [← power_mul, mul_eq_self h]\n\n"}
{"name":"Cardinal.prod_eq_two_power","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\ninst✝ : Infinite ι\nc : ι → Cardinal.{v}\nh₁ : ∀ (i : ι), LE.le 2 (c i)\nh₂ : ∀ (i : ι), LE.le (Cardinal.lift.{u, v} (c i)) (Cardinal.lift.{v, u} (Cardinal.mk ι))\n⊢ Eq (Cardinal.prod c) (HPow.hPow 2 (Cardinal.lift.{v, u} (Cardinal.mk ι)))","decl":"theorem prod_eq_two_power {ι : Type u} [Infinite ι] {c : ι → Cardinal.{v}} (h₁ : ∀ i, 2 ≤ c i)\n    (h₂ : ∀ i, lift.{u} (c i) ≤ lift.{v} #ι) : prod c = 2 ^ lift.{v} #ι := by\n  rw [← lift_id'.{u, v} (prod.{u, v} c), lift_prod, ← lift_two_power]\n  apply le_antisymm\n  · refine (prod_le_prod _ _ h₂).trans_eq ?_\n    rw [prod_const, lift_lift, ← lift_power, power_self_eq (aleph0_le_mk ι), lift_umax.{u, v}]\n  · rw [← prod_const', lift_prod]\n    refine prod_le_prod _ _ fun i => ?_\n    rw [lift_two, ← lift_two.{u, v}, lift_le]\n    exact h₁ i\n\n"}
{"name":"Cardinal.power_eq_two_power","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c₁ c₂ : Cardinal.{u_1}\nh₁ : LE.le Cardinal.aleph0 c₁\nh₂ : LE.le 2 c₂\nh₂' : LE.le c₂ c₁\n⊢ Eq (HPow.hPow c₂ c₁) (HPow.hPow 2 c₁)","decl":"theorem power_eq_two_power {c₁ c₂ : Cardinal} (h₁ : ℵ₀ ≤ c₁) (h₂ : 2 ≤ c₂) (h₂' : c₂ ≤ c₁) :\n    c₂ ^ c₁ = 2 ^ c₁ :=\n  le_antisymm (power_self_eq h₁ ▸ power_le_power_right h₂') (power_le_power_right h₂)\n\n"}
{"name":"Cardinal.nat_power_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u}\nh : LE.le Cardinal.aleph0 c\nn : Nat\nhn : LE.le 2 n\n⊢ Eq (HPow.hPow (↑n) c) (HPow.hPow 2 c)","decl":"theorem nat_power_eq {c : Cardinal.{u}} (h : ℵ₀ ≤ c) {n : ℕ} (hn : 2 ≤ n) :\n    (n : Cardinal.{u}) ^ c = 2 ^ c :=\n  power_eq_two_power h (by assumption_mod_cast) ((nat_lt_aleph0 n).le.trans h)\n\n"}
{"name":"Cardinal.power_nat_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u}\nn : Nat\nh : LE.le Cardinal.aleph0 c\n⊢ LE.le (HPow.hPow c n) c","decl":"theorem power_nat_le {c : Cardinal.{u}} {n : ℕ} (h : ℵ₀ ≤ c) : c ^ n ≤ c :=\n  pow_le h (nat_lt_aleph0 n)\n\n"}
{"name":"Cardinal.power_nat_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u}\nn : Nat\nh1 : LE.le Cardinal.aleph0 c\nh2 : LE.le 1 n\n⊢ Eq (HPow.hPow c n) c","decl":"theorem power_nat_eq {c : Cardinal.{u}} {n : ℕ} (h1 : ℵ₀ ≤ c) (h2 : 1 ≤ n) : c ^ n = c :=\n  pow_eq h1 (mod_cast h2) (nat_lt_aleph0 n)\n\n"}
{"name":"Cardinal.power_nat_le_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u}\nn : Nat\n⊢ LE.le (HPow.hPow c ↑n) (Max.max c Cardinal.aleph0)","decl":"theorem power_nat_le_max {c : Cardinal.{u}} {n : ℕ} : c ^ (n : Cardinal.{u}) ≤ max c ℵ₀ := by\n  rcases le_or_lt ℵ₀ c with hc | hc\n  · exact le_max_of_le_left (power_nat_le hc)\n  · exact le_max_of_le_right (power_lt_aleph0 hc (nat_lt_aleph0 _)).le\n\n"}
{"name":"Cardinal.power_le_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Cardinal.{u}\nha : LE.le a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n⊢ LE.le (HPow.hPow a b) Cardinal.aleph0","decl":"lemma power_le_aleph0 {a b : Cardinal.{u}} (ha : a ≤ ℵ₀) (hb : b < ℵ₀) : a ^ b ≤ ℵ₀ := by\n  lift b to ℕ using hb; simpa [ha] using power_nat_le_max (c := a)\n\n"}
{"name":"Cardinal.powerlt_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (c.powerlt Cardinal.aleph0) c","decl":"theorem powerlt_aleph0 {c : Cardinal} (h : ℵ₀ ≤ c) : c ^< ℵ₀ = c := by\n  apply le_antisymm\n  · rw [powerlt_le]\n    intro c'\n    rw [lt_aleph0]\n    rintro ⟨n, rfl⟩\n    apply power_nat_le h\n  convert le_powerlt c one_lt_aleph0; rw [power_one]\n\n"}
{"name":"Cardinal.powerlt_aleph0_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\n⊢ LE.le (c.powerlt Cardinal.aleph0) (Max.max c Cardinal.aleph0)","decl":"theorem powerlt_aleph0_le (c : Cardinal) : c ^< ℵ₀ ≤ max c ℵ₀ := by\n  rcases le_or_lt ℵ₀ c with h | h\n  · rw [powerlt_aleph0 h]\n    apply le_max_left\n  rw [powerlt_le]\n  exact fun c' hc' => (power_lt_aleph0 h hc').le.trans (le_max_right _ _)\n\n"}
{"name":"Cardinal.mk_equiv_eq_zero_iff_lift_ne","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ Iff (Eq (Cardinal.mk (Equiv α β')) 0) (Ne (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β')))","decl":"theorem mk_equiv_eq_zero_iff_lift_ne : #(α ≃ β') = 0 ↔ lift.{v} #α ≠ lift.{u} #β' := by\n  rw [mk_eq_zero_iff, ← not_nonempty_iff, ← lift_mk_eq']\n\n"}
{"name":"Cardinal.mk_equiv_eq_zero_iff_ne","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\n⊢ Iff (Eq (Cardinal.mk (Equiv α β)) 0) (Ne (Cardinal.mk α) (Cardinal.mk β))","decl":"theorem mk_equiv_eq_zero_iff_ne : #(α ≃ β) = 0 ↔ #α ≠ #β := by\n  rw [mk_equiv_eq_zero_iff_lift_ne, lift_id, lift_id]\n\n"}
{"name":"Cardinal.mk_equiv_comm","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ Eq (Cardinal.mk (Equiv α β')) (Cardinal.mk (Equiv β' α))","decl":"/-- This lemma makes lemmas assuming `Infinite α` applicable to the situation where we have\n  `Infinite β` instead. -/\ntheorem mk_equiv_comm : #(α ≃ β') = #(β' ≃ α) :=\n  (ofBijective _ symm_bijective).cardinal_eq\n\n"}
{"name":"Cardinal.mk_embedding_eq_zero_iff_lift_lt","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ Iff (Eq (Cardinal.mk (Function.Embedding α β')) 0) (LT.lt (Cardinal.lift.{u, v} (Cardinal.mk β')) (Cardinal.lift.{v, u} (Cardinal.mk α)))","decl":"theorem mk_embedding_eq_zero_iff_lift_lt : #(α ↪ β') = 0 ↔ lift.{u} #β' < lift.{v} #α := by\n  rw [mk_eq_zero_iff, ← not_nonempty_iff, ← lift_mk_le', not_le]\n\n"}
{"name":"Cardinal.mk_embedding_eq_zero_iff_lt","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\n⊢ Iff (Eq (Cardinal.mk (Function.Embedding α β)) 0) (LT.lt (Cardinal.mk β) (Cardinal.mk α))","decl":"theorem mk_embedding_eq_zero_iff_lt : #(α ↪ β) = 0 ↔ #β < #α := by\n  rw [mk_embedding_eq_zero_iff_lift_lt, lift_lt]\n\n"}
{"name":"Cardinal.mk_arrow_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ Iff (Eq (Cardinal.mk (α → β')) 0) (And (Ne (Cardinal.mk α) 0) (Eq (Cardinal.mk β') 0))","decl":"theorem mk_arrow_eq_zero_iff : #(α → β') = 0 ↔ #α ≠ 0 ∧ #β' = 0 := by\n  simp_rw [mk_eq_zero_iff, mk_ne_zero_iff, isEmpty_fun]\n\n"}
{"name":"Cardinal.mk_surjective_eq_zero_iff_lift","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ Iff (Eq (Cardinal.mk ↑(setOf fun f => Function.Surjective f)) 0) (Or (LT.lt (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β'))) (And (Ne (Cardinal.mk α) 0) (Eq (Cardinal.mk β') 0)))","decl":"theorem mk_surjective_eq_zero_iff_lift :\n    #{f : α → β' | Surjective f} = 0 ↔ lift.{v} #α < lift.{u} #β' ∨ (#α ≠ 0 ∧ #β' = 0) := by\n  rw [← not_iff_not, not_or, not_lt, lift_mk_le', ← Ne, not_and_or, not_ne_iff, and_comm]\n  simp_rw [mk_ne_zero_iff, mk_eq_zero_iff, nonempty_coe_sort,\n    Set.Nonempty, mem_setOf, exists_surjective_iff, nonempty_fun]\n\n"}
{"name":"Cardinal.mk_surjective_eq_zero_iff","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\n⊢ Iff (Eq (Cardinal.mk ↑(setOf fun f => Function.Surjective f)) 0) (Or (LT.lt (Cardinal.mk α) (Cardinal.mk β)) (And (Ne (Cardinal.mk α) 0) (Eq (Cardinal.mk β) 0)))","decl":"theorem mk_surjective_eq_zero_iff :\n    #{f : α → β | Surjective f} = 0 ↔ #α < #β ∨ (#α ≠ 0 ∧ #β = 0) := by\n  rw [mk_surjective_eq_zero_iff_lift, lift_lt]\n\n"}
{"name":"Cardinal.mk_equiv_le_embedding","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ LE.le (Cardinal.mk (Equiv α β')) (Cardinal.mk (Function.Embedding α β'))","decl":"theorem mk_equiv_le_embedding : #(α ≃ β') ≤ #(α ↪ β') := ⟨⟨_, Equiv.toEmbedding_injective⟩⟩\n\n"}
{"name":"Cardinal.mk_embedding_le_arrow","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\n⊢ LE.le (Cardinal.mk (Function.Embedding α β')) (Cardinal.mk (α → β'))","decl":"theorem mk_embedding_le_arrow : #(α ↪ β') ≤ #(α → β') := ⟨⟨_, DFunLike.coe_injective⟩⟩\n\n"}
{"name":"Cardinal.mk_perm_eq_self_power","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ Eq (Cardinal.mk (Equiv.Perm α)) (HPow.hPow (Cardinal.mk α) (Cardinal.mk α))","decl":"theorem mk_perm_eq_self_power : #(Equiv.Perm α) = #α ^ #α :=\n  ((mk_equiv_le_embedding α α).trans (mk_embedding_le_arrow α α)).antisymm <| by\n    suffices Nonempty ((α → Bool) ↪ Equiv.Perm (α × Bool)) by\n      obtain ⟨e⟩ : Nonempty (α ≃ α × Bool) := by\n        erw [← Cardinal.eq, mk_prod, lift_uzero, mk_bool,\n          lift_natCast, mul_two, add_eq_self (aleph0_le_mk α)]\n      erw [← le_def, mk_arrow, lift_uzero, mk_bool, lift_natCast 2] at this\n      rwa [← power_def, power_self_eq (aleph0_le_mk α), e.permCongr.cardinal_eq]\n    refine ⟨⟨fun f ↦ Involutive.toPerm (fun x ↦ ⟨x.1, xor (f x.1) x.2⟩) fun x ↦ ?_, fun f g h ↦ ?_⟩⟩\n    · simp_rw [← Bool.xor_assoc, Bool.xor_self, Bool.false_xor]\n    · ext a; rw [← (f a).xor_false, ← (g a).xor_false]; exact congr(($h ⟨a, false⟩).2)\n\n"}
{"name":"Cardinal.mk_perm_eq_two_power","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ Eq (Cardinal.mk (Equiv.Perm α)) (HPow.hPow 2 (Cardinal.mk α))","decl":"theorem mk_perm_eq_two_power : #(Equiv.Perm α) = 2 ^ #α := by\n  rw [mk_perm_eq_self_power, power_self_eq (aleph0_le_mk α)]\n\n"}
{"name":"Cardinal.mk_equiv_eq_arrow_of_lift_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\ninst✝ : Infinite α\nleq : Eq (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β'))\n⊢ Eq (Cardinal.mk (Equiv α β')) (Cardinal.mk (α → β'))","decl":"theorem mk_equiv_eq_arrow_of_lift_eq (leq : lift.{v} #α = lift.{u} #β') :\n    #(α ≃ β') = #(α → β') := by\n  obtain ⟨e⟩ := lift_mk_eq'.mp leq\n  have e₁ := lift_mk_eq'.mpr ⟨.equivCongr (.refl α) e⟩\n  have e₂ := lift_mk_eq'.mpr ⟨.arrowCongr (.refl α) e⟩\n  rw [lift_id'.{u,v}] at e₁ e₂\n  rw [← e₁, ← e₂, lift_inj, mk_perm_eq_self_power, power_def]\n\n"}
{"name":"Cardinal.mk_equiv_eq_arrow_of_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite α\neq : Eq (Cardinal.mk α) (Cardinal.mk β)\n⊢ Eq (Cardinal.mk (Equiv α β)) (Cardinal.mk (α → β))","decl":"theorem mk_equiv_eq_arrow_of_eq (eq : #α = #β) : #(α ≃ β) = #(α → β) :=\n  mk_equiv_eq_arrow_of_lift_eq congr(lift $eq)\n\n"}
{"name":"Cardinal.mk_equiv_of_lift_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\ninst✝ : Infinite α\nleq : Eq (Cardinal.lift.{v, u} (Cardinal.mk α)) (Cardinal.lift.{u, v} (Cardinal.mk β'))\n⊢ Eq (Cardinal.mk (Equiv α β')) (HPow.hPow 2 (Cardinal.lift.{v, u} (Cardinal.mk α)))","decl":"theorem mk_equiv_of_lift_eq (leq : lift.{v} #α = lift.{u} #β') : #(α ≃ β') = 2 ^ lift.{v} #α := by\n  erw [← (lift_mk_eq'.2 ⟨.equivCongr (.refl α) (lift_mk_eq'.1 leq).some⟩).trans (lift_id'.{u,v} _),\n    lift_umax.{u,v}, mk_perm_eq_two_power, lift_power, lift_natCast]; rfl\n\n"}
{"name":"Cardinal.mk_equiv_of_eq","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite α\neq : Eq (Cardinal.mk α) (Cardinal.mk β)\n⊢ Eq (Cardinal.mk (Equiv α β)) (HPow.hPow 2 (Cardinal.mk α))","decl":"theorem mk_equiv_of_eq (eq : #α = #β) : #(α ≃ β) = 2 ^ #α := by\n  rw [mk_equiv_of_lift_eq (lift_inj.mpr eq), lift_id]\n\n"}
{"name":"Cardinal.mk_embedding_eq_arrow_of_lift_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\ninst✝ : Infinite α\nlle : LE.le (Cardinal.lift.{u, v} (Cardinal.mk β')) (Cardinal.lift.{v, u} (Cardinal.mk α))\n⊢ Eq (Cardinal.mk (Function.Embedding β' α)) (Cardinal.mk (β' → α))","decl":"theorem mk_embedding_eq_arrow_of_lift_le (lle : lift.{u} #β' ≤ lift.{v} #α) :\n    #(β' ↪ α) = #(β' → α) :=\n  (mk_embedding_le_arrow _ _).antisymm <| by\n    conv_rhs => rw [← (Equiv.embeddingCongr (.refl _)\n      (Cardinal.eq.mp <| mul_eq_self <| aleph0_le_mk α).some).cardinal_eq]\n    obtain ⟨e⟩ := lift_mk_le'.mp lle\n    exact ⟨⟨fun f ↦ ⟨fun b ↦ ⟨e b, f b⟩, fun _ _ h ↦ e.injective congr(Prod.fst $h)⟩,\n      fun f g h ↦ funext fun b ↦ congr(Prod.snd <| $h b)⟩⟩\n\n"}
{"name":"Cardinal.mk_embedding_eq_arrow_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite α\nle : LE.le (Cardinal.mk β) (Cardinal.mk α)\n⊢ Eq (Cardinal.mk (Function.Embedding β α)) (Cardinal.mk (β → α))","decl":"theorem mk_embedding_eq_arrow_of_le (le : #β ≤ #α) : #(β ↪ α) = #(β → α) :=\n  mk_embedding_eq_arrow_of_lift_le (lift_le.mpr le)\n\n"}
{"name":"Cardinal.mk_surjective_eq_arrow_of_lift_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ' : Type v\ninst✝ : Infinite α\nlle : LE.le (Cardinal.lift.{u, v} (Cardinal.mk β')) (Cardinal.lift.{v, u} (Cardinal.mk α))\n⊢ Eq (Cardinal.mk ↑(setOf fun f => Function.Surjective f)) (Cardinal.mk (α → β'))","decl":"theorem mk_surjective_eq_arrow_of_lift_le (lle : lift.{u} #β' ≤ lift.{v} #α) :\n    #{f : α → β' | Surjective f} = #(α → β') :=\n  (mk_set_le _).antisymm <|\n    have ⟨e⟩ : Nonempty (α ≃ α ⊕ β') := by\n      simp_rw [← lift_mk_eq', mk_sum, lift_add, lift_lift]; rw [lift_umax.{u,v}, eq_comm]\n      exact add_eq_left (aleph0_le_lift.mpr <| aleph0_le_mk α) lle\n    ⟨⟨fun f ↦ ⟨fun a ↦ (e a).elim f id, fun b ↦ ⟨e.symm (.inr b), congr_arg _ (e.right_inv _)⟩⟩,\n      fun f g h ↦ funext fun a ↦ by\n        simpa only [e.apply_symm_apply] using congr_fun (Subtype.ext_iff.mp h) (e.symm <| .inl a)⟩⟩\n\n"}
{"name":"Cardinal.mk_surjective_eq_arrow_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Infinite α\nle : LE.le (Cardinal.mk β) (Cardinal.mk α)\n⊢ Eq (Cardinal.mk ↑(setOf fun f => Function.Surjective f)) (Cardinal.mk (α → β))","decl":"theorem mk_surjective_eq_arrow_of_le (le : #β ≤ #α) : #{f : α → β | Surjective f} = #(α → β) :=\n  mk_surjective_eq_arrow_of_lift_le (lift_le.mpr le)\n\n"}
{"name":"Cardinal.mk_list_eq_mk","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ Eq (Cardinal.mk (List α)) (Cardinal.mk α)","decl":"@[simp]\ntheorem mk_list_eq_mk (α : Type u) [Infinite α] : #(List α) = #α :=\n  have H1 : ℵ₀ ≤ #α := aleph0_le_mk α\n  Eq.symm <|\n    le_antisymm ((le_def _ _).2 ⟨⟨fun a => [a], fun _ => by simp⟩⟩) <|\n      calc\n        #(List α) = sum fun n : ℕ => #α ^ (n : Cardinal.{u}) := mk_list_eq_sum_pow α\n        _ ≤ sum fun _ : ℕ => #α := sum_le_sum _ _ fun n => pow_le H1 <| nat_lt_aleph0 n\n        _ = #α := by simp [H1]\n\n"}
{"name":"Cardinal.mk_list_eq_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝¹ : Countable α\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (List α)) Cardinal.aleph0","decl":"theorem mk_list_eq_aleph0 (α : Type u) [Countable α] [Nonempty α] : #(List α) = ℵ₀ :=\n  mk_le_aleph0.antisymm (aleph0_le_mk _)\n\n"}
{"name":"Cardinal.mk_list_eq_max_mk_aleph0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (List α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"theorem mk_list_eq_max_mk_aleph0 (α : Type u) [Nonempty α] : #(List α) = max #α ℵ₀ := by\n  cases finite_or_infinite α\n  · rw [mk_list_eq_aleph0, eq_comm, max_eq_right]\n    exact mk_le_aleph0\n  · rw [mk_list_eq_mk, eq_comm, max_eq_left]\n    exact aleph0_le_mk α\n\n"}
{"name":"Cardinal.mk_list_le_max","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\n⊢ LE.le (Cardinal.mk (List α)) (Max.max Cardinal.aleph0 (Cardinal.mk α))","decl":"theorem mk_list_le_max (α : Type u) : #(List α) ≤ max ℵ₀ #α := by\n  cases finite_or_infinite α\n  · exact mk_le_aleph0.trans (le_max_left _ _)\n  · rw [mk_list_eq_mk]\n    apply le_max_right\n\n"}
{"name":"Cardinal.mk_finset_of_infinite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Infinite α\n⊢ Eq (Cardinal.mk (Finset α)) (Cardinal.mk α)","decl":"@[simp]\ntheorem mk_finset_of_infinite (α : Type u) [Infinite α] : #(Finset α) = #α := by\n  classical\n  exact Eq.symm <|\n    le_antisymm (mk_le_of_injective fun _ _ => Finset.singleton_inj.1) <|\n      calc\n        #(Finset α) ≤ #(List α) := mk_le_of_surjective List.toFinset_surjective\n        _ = #α := mk_list_eq_mk α\n\n"}
{"name":"Cardinal.mk_bounded_set_le_of_infinite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Infinite α\nc : Cardinal.{u}\n⊢ LE.le (Cardinal.mk (Subtype fun t => LE.le (Cardinal.mk ↑t) c)) (HPow.hPow (Cardinal.mk α) c)","decl":"theorem mk_bounded_set_le_of_infinite (α : Type u) [Infinite α] (c : Cardinal) :\n    #{ t : Set α // #t ≤ c } ≤ #α ^ c := by\n  refine le_trans ?_ (by rw [← add_one_eq (aleph0_le_mk α)])\n  induction' c using Cardinal.inductionOn with β\n  fapply mk_le_of_surjective\n  · intro f\n    use Sum.inl ⁻¹' range f\n    refine le_trans (mk_preimage_of_injective _ _ fun x y => Sum.inl.inj) ?_\n    apply mk_range_le\n  rintro ⟨s, ⟨g⟩⟩\n  classical\n  use fun y => if h : ∃ x : s, g x = y then Sum.inl (Classical.choose h).val\n               else Sum.inr (ULift.up 0)\n  apply Subtype.eq; ext x\n  constructor\n  · rintro ⟨y, h⟩\n    dsimp only at h\n    by_cases h' : ∃ z : s, g z = y\n    · rw [dif_pos h'] at h\n      cases Sum.inl.inj h\n      exact (Classical.choose h').2\n    · rw [dif_neg h'] at h\n      cases h\n  · intro h\n    have : ∃ z : s, g z = g ⟨x, h⟩ := ⟨⟨x, h⟩, rfl⟩\n    use g ⟨x, h⟩\n    dsimp only\n    rw [dif_pos this]\n    congr\n    suffices Classical.choose this = ⟨x, h⟩ from congr_arg Subtype.val this\n    apply g.2\n    exact Classical.choose_spec this\n\n"}
{"name":"Cardinal.mk_bounded_set_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nc : Cardinal.{u}\n⊢ LE.le (Cardinal.mk (Subtype fun t => LE.le (Cardinal.mk ↑t) c)) (HPow.hPow (Max.max (Cardinal.mk α) Cardinal.aleph0) c)","decl":"theorem mk_bounded_set_le (α : Type u) (c : Cardinal) :\n    #{ t : Set α // #t ≤ c } ≤ max #α ℵ₀ ^ c := by\n  trans #{ t : Set ((ULift.{u} ℕ) ⊕ α) // #t ≤ c }\n  · refine ⟨Embedding.subtypeMap ?_ ?_⟩\n    · apply Embedding.image\n      use Sum.inr\n      apply Sum.inr.inj\n    intro s hs\n    exact mk_image_le.trans hs\n  apply (mk_bounded_set_le_of_infinite ((ULift.{u} ℕ) ⊕ α) c).trans\n  rw [max_comm, ← add_eq_max] <;> rfl\n\n"}
{"name":"Cardinal.mk_bounded_subset_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ns : Set α\nc : Cardinal.{u}\n⊢ LE.le (Cardinal.mk (Subtype fun t => And (HasSubset.Subset t s) (LE.le (Cardinal.mk ↑t) c))) (HPow.hPow (Max.max (Cardinal.mk ↑s) Cardinal.aleph0) c)","decl":"theorem mk_bounded_subset_le {α : Type u} (s : Set α) (c : Cardinal.{u}) :\n    #{ t : Set α // t ⊆ s ∧ #t ≤ c } ≤ max #s ℵ₀ ^ c := by\n  refine le_trans ?_ (mk_bounded_set_le s c)\n  refine ⟨Embedding.codRestrict _ ?_ ?_⟩\n  · use fun t => (↑) ⁻¹' t.1\n    rintro ⟨t, ht1, ht2⟩ ⟨t', h1t', h2t'⟩ h\n    apply Subtype.eq\n    dsimp only at h ⊢\n    refine (preimage_eq_preimage' ?_ ?_).1 h <;> rw [Subtype.range_coe] <;> assumption\n  rintro ⟨t, _, h2t⟩; exact (mk_preimage_of_injective _ _ Subtype.val_injective).trans h2t\n\n"}
{"name":"Cardinal.mk_compl_of_infinite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\ns : Set α\nh2 : LT.lt (Cardinal.mk ↑s) (Cardinal.mk α)\n⊢ Eq (Cardinal.mk ↑(HasCompl.compl s)) (Cardinal.mk α)","decl":"theorem mk_compl_of_infinite {α : Type*} [Infinite α] (s : Set α) (h2 : #s < #α) :\n    #(sᶜ : Set α) = #α := by\n  refine eq_of_add_eq_of_aleph0_le ?_ h2 (aleph0_le_mk α)\n  exact mk_sum_compl s\n\n"}
{"name":"Cardinal.mk_compl_finset_of_infinite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\ns : Finset α\n⊢ Eq (Cardinal.mk ↑(HasCompl.compl ↑s)) (Cardinal.mk α)","decl":"theorem mk_compl_finset_of_infinite {α : Type*} [Infinite α] (s : Finset α) :\n    #((↑s)ᶜ : Set α) = #α := by\n  apply mk_compl_of_infinite\n  exact (finset_card_lt_aleph0 s).trans_le (aleph0_le_mk α)\n\n"}
{"name":"Cardinal.mk_compl_eq_mk_compl_infinite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\ninst✝ : Infinite α\ns t : Set α\nhs : LT.lt (Cardinal.mk ↑s) (Cardinal.mk α)\nht : LT.lt (Cardinal.mk ↑t) (Cardinal.mk α)\n⊢ Eq (Cardinal.mk ↑(HasCompl.compl s)) (Cardinal.mk ↑(HasCompl.compl t))","decl":"theorem mk_compl_eq_mk_compl_infinite {α : Type*} [Infinite α] {s t : Set α} (hs : #s < #α)\n    (ht : #t < #α) : #(sᶜ : Set α) = #(tᶜ : Set α) := by\n  rw [mk_compl_of_infinite s hs, mk_compl_of_infinite t ht]\n\n"}
{"name":"Cardinal.mk_compl_eq_mk_compl_finite_lift","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Finite α\ns : Set α\nt : Set β\nh1 : Eq (Cardinal.lift.{max v w, u} (Cardinal.mk α)) (Cardinal.lift.{max u w, v} (Cardinal.mk β))\nh2 : Eq (Cardinal.lift.{max v w, u} (Cardinal.mk ↑s)) (Cardinal.lift.{max u w, v} (Cardinal.mk ↑t))\n⊢ Eq (Cardinal.lift.{max v w, u} (Cardinal.mk ↑(HasCompl.compl s))) (Cardinal.lift.{max u w, v} (Cardinal.mk ↑(HasCompl.compl t)))","decl":"theorem mk_compl_eq_mk_compl_finite_lift {α : Type u} {β : Type v} [Finite α] {s : Set α}\n    {t : Set β} (h1 : (lift.{max v w, u} #α) = (lift.{max u w, v} #β))\n    (h2 : lift.{max v w, u} #s = lift.{max u w, v} #t) :\n    lift.{max v w} #(sᶜ : Set α) = lift.{max u w} #(tᶜ : Set β) := by\n  cases nonempty_fintype α\n  rcases lift_mk_eq.{u, v, w}.1 h1 with ⟨e⟩; letI : Fintype β := Fintype.ofEquiv α e\n  replace h1 : Fintype.card α = Fintype.card β := (Fintype.ofEquiv_card _).symm\n  classical\n    lift s to Finset α using s.toFinite\n    lift t to Finset β using t.toFinite\n    simp only [Finset.coe_sort_coe, mk_fintype, Fintype.card_coe, lift_natCast, Nat.cast_inj] at h2\n    simp only [← Finset.coe_compl, Finset.coe_sort_coe, mk_coe_finset, Finset.card_compl,\n      lift_natCast, Nat.cast_inj, h1, h2]\n\n"}
{"name":"Cardinal.mk_compl_eq_mk_compl_finite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α β : Type u\ninst✝ : Finite α\ns : Set α\nt : Set β\nh1 : Eq (Cardinal.mk α) (Cardinal.mk β)\nh : Eq (Cardinal.mk ↑s) (Cardinal.mk ↑t)\n⊢ Eq (Cardinal.mk ↑(HasCompl.compl s)) (Cardinal.mk ↑(HasCompl.compl t))","decl":"theorem mk_compl_eq_mk_compl_finite {α β : Type u} [Finite α] {s : Set α} {t : Set β}\n    (h1 : #α = #β) (h : #s = #t) : #(sᶜ : Set α) = #(tᶜ : Set β) := by\n  rw [← lift_inj.{u, u}]\n  apply mk_compl_eq_mk_compl_finite_lift.{u, u, u}\n  <;> rwa [lift_inj]\n\n"}
{"name":"Cardinal.mk_compl_eq_mk_compl_finite_same","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\ninst✝ : Finite α\ns t : Set α\nh : Eq (Cardinal.mk ↑s) (Cardinal.mk ↑t)\n⊢ Eq (Cardinal.mk ↑(HasCompl.compl s)) (Cardinal.mk ↑(HasCompl.compl t))","decl":"theorem mk_compl_eq_mk_compl_finite_same {α : Type u} [Finite α] {s t : Set α} (h : #s = #t) :\n    #(sᶜ : Set α) = #(tᶜ : Set α) :=\n  mk_compl_eq_mk_compl_finite.{u} rfl h\n\n"}
{"name":"Cardinal.extend_function","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : Function.Embedding (↑s) β\nh : Nonempty (Equiv ↑(HasCompl.compl s) ↑(HasCompl.compl (Set.range ⇑f)))\n⊢ Exists fun g => ∀ (x : ↑s), Eq (g ↑x) (f x)","decl":"theorem extend_function {α β : Type*} {s : Set α} (f : s ↪ β)\n    (h : Nonempty ((sᶜ : Set α) ≃ ((range f)ᶜ : Set β))) : ∃ g : α ≃ β, ∀ x : s, g x = f x := by\n  classical\n  have := h; cases' this with g\n  let h : α ≃ β :=\n    (Set.sumCompl (s : Set α)).symm.trans\n      ((sumCongr (Equiv.ofInjective f f.2) g).trans (Set.sumCompl (range f)))\n  refine ⟨h, ?_⟩; rintro ⟨x, hx⟩; simp [h, Set.sumCompl_symm_apply_of_mem, hx]\n\n"}
{"name":"Cardinal.extend_function_finite","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Finite α\ns : Set α\nf : Function.Embedding (↑s) β\nh : Nonempty (Equiv α β)\n⊢ Exists fun g => ∀ (x : ↑s), Eq (g ↑x) (f x)","decl":"theorem extend_function_finite {α : Type u} {β : Type v} [Finite α] {s : Set α} (f : s ↪ β)\n    (h : Nonempty (α ≃ β)) : ∃ g : α ≃ β, ∀ x : s, g x = f x := by\n  apply extend_function.{u, v} f\n  cases' id h with g\n  rw [← lift_mk_eq.{u, v, max u v}] at h\n  rw [← lift_mk_eq.{u, v, max u v}, mk_compl_eq_mk_compl_finite_lift.{u, v, max u v} h]\n  rw [mk_range_eq_lift.{u, v, max u v}]; exact f.2\n\n"}
{"name":"Cardinal.extend_function_of_lt","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nf : Function.Embedding (↑s) β\nhs : LT.lt (Cardinal.mk ↑s) (Cardinal.mk α)\nh : Nonempty (Equiv α β)\n⊢ Exists fun g => ∀ (x : ↑s), Eq (g ↑x) (f x)","decl":"theorem extend_function_of_lt {α β : Type*} {s : Set α} (f : s ↪ β) (hs : #s < #α)\n    (h : Nonempty (α ≃ β)) : ∃ g : α ≃ β, ∀ x : s, g x = f x := by\n  cases fintypeOrInfinite α\n  · exact extend_function_finite f h\n  · apply extend_function f\n    cases' id h with g\n    haveI := Infinite.of_injective _ g.injective\n    rw [← lift_mk_eq'] at h ⊢\n    rwa [mk_compl_of_infinite s hs, mk_compl_of_infinite]\n    rwa [← lift_lt, mk_range_eq_of_injective f.injective, ← h, lift_lt]\n\n"}
{"name":"Cardinal.mk_iUnion_Ordinal_lift_le_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"β : Type v\no : Ordinal.{u}\nc : Cardinal.{v}\nho : LE.le (Cardinal.lift.{v, u} o.card) (Cardinal.lift.{u, v} c)\nhc : LE.le Cardinal.aleph0 c\nA : Ordinal.{u} → Set β\nhA : ∀ (j : Ordinal.{u}), LT.lt j o → LE.le (Cardinal.mk ↑(A j)) c\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun j => Set.iUnion fun h => A j)) c","decl":"/-- Bounds the cardinal of an ordinal-indexed union of sets. -/\nlemma mk_iUnion_Ordinal_lift_le_of_le {β : Type v} {o : Ordinal.{u}} {c : Cardinal.{v}}\n    (ho : lift.{v} o.card ≤ lift.{u} c) (hc : ℵ₀ ≤ c) (A : Ordinal → Set β)\n    (hA : ∀ j < o, #(A j) ≤ c) : #(⋃ j < o, A j) ≤ c := by\n  simp_rw [← mem_Iio, biUnion_eq_iUnion, iUnion, iSup, ← o.enumIsoToType.symm.surjective.range_comp]\n  rw [← lift_le.{u}]\n  apply ((mk_iUnion_le_lift _).trans _).trans_eq (mul_eq_self (aleph0_le_lift.2 hc))\n  rw [mk_toType]\n  refine mul_le_mul' ho (ciSup_le' ?_)\n  intro i\n  simpa using hA _ (o.enumIsoToType.symm i).2\n\n"}
{"name":"Cardinal.mk_iUnion_Ordinal_le_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"β : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : LE.le o.card c\nhc : LE.le Cardinal.aleph0 c\nA : Ordinal.{u_1} → Set β\nhA : ∀ (j : Ordinal.{u_1}), LT.lt j o → LE.le (Cardinal.mk ↑(A j)) c\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun j => Set.iUnion fun h => A j)) c","decl":"lemma mk_iUnion_Ordinal_le_of_le {β : Type*} {o : Ordinal} {c : Cardinal}\n    (ho : o.card ≤ c) (hc : ℵ₀ ≤ c) (A : Ordinal → Set β)\n    (hA : ∀ j < o, #(A j) ≤ c) : #(⋃ j < o, A j) ≤ c := by\n  apply mk_iUnion_Ordinal_lift_le_of_le _ hc A hA\n  rwa [Cardinal.lift_le]\n\n"}
{"name":"Ordinal.Cardinal.mk_iUnion_Ordinal_le_of_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"β : Type u_1\no : Ordinal.{u_1}\nc : Cardinal.{u_1}\nho : LE.le o.card c\nhc : LE.le Cardinal.aleph0 c\nA : Ordinal.{u_1} → Set β\nhA : ∀ (j : Ordinal.{u_1}), LT.lt j o → LE.le (Cardinal.mk ↑(A j)) c\n⊢ LE.le (Cardinal.mk ↑(Set.iUnion fun j => Set.iUnion fun h => A j)) c","decl":"@[deprecated mk_iUnion_Ordinal_le_of_le (since := \"2024-11-02\")]\nalias Ordinal.Cardinal.mk_iUnion_Ordinal_le_of_le := mk_iUnion_Ordinal_le_of_le\n\n"}
{"name":"Ordinal.lift_card_iSup_le_sum_card","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\ninst✝ : Small.{v, u} ι\nf : ι → Ordinal.{v}\n⊢ LE.le (Cardinal.lift.{u, v} (iSup fun i => f i).card) (Cardinal.sum fun i => (f i).card)","decl":"theorem lift_card_iSup_le_sum_card {ι : Type u} [Small.{v} ι] (f : ι → Ordinal.{v}) :\n    Cardinal.lift.{u} (⨆ i, f i).card ≤ Cardinal.sum fun i ↦ (f i).card := by\n  simp_rw [← mk_toType]\n  rw [← mk_sigma, ← Cardinal.lift_id'.{v} #(Σ _, _), ← Cardinal.lift_umax.{v, u}]\n  apply lift_mk_le_lift_mk_of_surjective (f := enumIsoToType _ ∘ (⟨(enumIsoToType _).symm ·.2,\n    (mem_Iio.mp ((enumIsoToType _).symm _).2).trans_le (Ordinal.le_iSup _ _)⟩))\n  rw [EquivLike.comp_surjective]\n  rintro ⟨x, hx⟩\n  obtain ⟨i, hi⟩ := Ordinal.lt_iSup_iff.mp hx\n  exact ⟨⟨i, enumIsoToType _ ⟨x, hi⟩⟩, by simp⟩\n\n"}
{"name":"Ordinal.card_iSup_le_sum_card","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (iSup fun i => f i).card (Cardinal.sum fun i => (f i).card)","decl":"theorem card_iSup_le_sum_card {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    (⨆ i, f i).card ≤ Cardinal.sum (fun i ↦ (f i).card) := by\n  have := lift_card_iSup_le_sum_card f\n  rwa [Cardinal.lift_id'] at this\n\n"}
{"name":"Ordinal.card_iSup_Iio_le_sum_card","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : ↑(Set.Iio o) → Ordinal.{max u v}\n⊢ LE.le (iSup fun a => f a).card (Cardinal.sum fun i => (f (o.enumIsoToType.symm i)).card)","decl":"theorem card_iSup_Iio_le_sum_card {o : Ordinal.{u}} (f : Iio o → Ordinal.{max u v}) :\n    (⨆ a : Iio o, f a).card ≤ Cardinal.sum fun i ↦ (f ((enumIsoToType o).symm i)).card := by\n  apply le_of_eq_of_le (congr_arg _ _).symm (card_iSup_le_sum_card _)\n  simpa using (enumIsoToType o).symm.iSup_comp (g := fun x ↦ f x)\n\n"}
{"name":"Ordinal.card_iSup_Iio_le_card_mul_iSup","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : ↑(Set.Iio o) → Ordinal.{max u v}\n⊢ LE.le (iSup fun a => f a).card (HMul.hMul (Cardinal.lift.{v, u} o.card) (iSup fun a => (f a).card))","decl":"theorem card_iSup_Iio_le_card_mul_iSup {o : Ordinal.{u}} (f : Iio o → Ordinal.{max u v}) :\n    (⨆ a : Iio o, f a).card ≤ Cardinal.lift.{v} o.card * ⨆ a : Iio o, (f a).card := by\n  apply (card_iSup_Iio_le_sum_card f).trans\n  convert ← sum_le_iSup_lift _\n  · exact mk_toType o\n  · exact (enumIsoToType o).symm.iSup_comp (g := fun x ↦ (f x).card)\n\n"}
{"name":"Ordinal.card_opow_le_of_omega0_le_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\nha : LE.le Ordinal.omega0 a\nb : Ordinal.{u_1}\n⊢ LE.le (HPow.hPow a b).card (Max.max a.card b.card)","decl":"theorem card_opow_le_of_omega0_le_left {a : Ordinal} (ha : ω ≤ a) (b : Ordinal) :\n    (a ^ b).card ≤ max a.card b.card := by\n  refine limitRecOn b ?_ ?_ ?_\n  · simpa using one_lt_omega0.le.trans ha\n  · intro b IH\n    rw [opow_succ, card_mul, card_succ, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]\n    · apply (max_le_max_left _ IH).trans\n      rw [← max_assoc, max_self]\n      exact max_le_max_left _ le_self_add\n    · rw [ne_eq, card_eq_zero, opow_eq_zero]\n      rintro ⟨rfl, -⟩\n      cases omega0_pos.not_le ha\n    · rwa [aleph0_le_card]\n  · intro b hb IH\n    rw [(isNormal_opow (one_lt_omega0.trans_le ha)).apply_of_isLimit hb]\n    apply (card_iSup_Iio_le_card_mul_iSup _).trans\n    rw [Cardinal.lift_id, Cardinal.mul_eq_max_of_aleph0_le_right, max_comm]\n    · apply max_le _ (le_max_right _ _)\n      apply ciSup_le'\n      intro c\n      exact (IH c.1 c.2).trans (max_le_max_left _ (card_le_card c.2.le))\n    · simpa using hb.pos.ne'\n    · refine le_ciSup_of_le ?_ ⟨1, one_lt_omega0.trans_le <| omega0_le_of_isLimit hb⟩ ?_\n      · exact Cardinal.bddAbove_of_small _\n      · simpa\n\n"}
{"name":"Ordinal.card_opow_le_of_omega0_le_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Ordinal.{u_1}\nhb : LE.le Ordinal.omega0 b\n⊢ LE.le (HPow.hPow a b).card (Max.max a.card b.card)","decl":"theorem card_opow_le_of_omega0_le_right (a : Ordinal) {b : Ordinal} (hb : ω ≤ b) :\n    (a ^ b).card ≤ max a.card b.card := by\n  obtain ⟨n, rfl⟩ | ha := eq_nat_or_omega0_le a\n  · apply (card_le_card <| opow_le_opow_left b (nat_lt_omega0 n).le).trans\n    apply (card_opow_le_of_omega0_le_left le_rfl _).trans\n    simp [hb]\n  · exact card_opow_le_of_omega0_le_left ha b\n\n"}
{"name":"Ordinal.card_opow_le","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Ordinal.{u_1}\n⊢ LE.le (HPow.hPow a b).card (Max.max Cardinal.aleph0 (Max.max a.card b.card))","decl":"theorem card_opow_le (a b : Ordinal) : (a ^ b).card ≤ max ℵ₀ (max a.card b.card) := by\n  obtain ⟨n, rfl⟩ | ha := eq_nat_or_omega0_le a\n  · obtain ⟨m, rfl⟩ | hb := eq_nat_or_omega0_le b\n    · rw [← natCast_opow, card_nat]\n      exact le_max_of_le_left (nat_lt_aleph0 _).le\n    · exact (card_opow_le_of_omega0_le_right _ hb).trans (le_max_right _ _)\n  · exact (card_opow_le_of_omega0_le_left ha _).trans (le_max_right _ _)\n\n"}
{"name":"Ordinal.card_opow_eq_of_omega0_le_left","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Ordinal.{u_1}\nha : LE.le Ordinal.omega0 a\nhb : LT.lt 0 b\n⊢ Eq (HPow.hPow a b).card (Max.max a.card b.card)","decl":"theorem card_opow_eq_of_omega0_le_left {a b : Ordinal} (ha : ω ≤ a) (hb : 0 < b) :\n    (a ^ b).card = max a.card b.card := by\n  apply (card_opow_le_of_omega0_le_left ha b).antisymm (max_le _ _) <;> apply card_le_card\n  · exact left_le_opow a hb\n  · exact right_le_opow b (one_lt_omega0.trans_le ha)\n\n"}
{"name":"Ordinal.card_opow_eq_of_omega0_le_right","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a b : Ordinal.{u_1}\nha : LT.lt 1 a\nhb : LE.le Ordinal.omega0 b\n⊢ Eq (HPow.hPow a b).card (Max.max a.card b.card)","decl":"theorem card_opow_eq_of_omega0_le_right {a b : Ordinal} (ha : 1 < a) (hb : ω ≤ b) :\n    (a ^ b).card = max a.card b.card := by\n  apply (card_opow_le_of_omega0_le_right a hb).antisymm (max_le _ _) <;> apply card_le_card\n  · exact left_le_opow a (omega0_pos.trans_le hb)\n  · exact right_le_opow b ha\n\n"}
{"name":"Ordinal.card_omega0_opow","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\nh : Ne a 0\n⊢ Eq (HPow.hPow Ordinal.omega0 a).card (Max.max Cardinal.aleph0 a.card)","decl":"theorem card_omega0_opow {a : Ordinal} (h : a ≠ 0) : card (ω ^ a) = max ℵ₀ a.card := by\n  rw [card_opow_eq_of_omega0_le_left le_rfl h.bot_lt, card_omega0]\n\n"}
{"name":"Ordinal.card_opow_omega0","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\nh : LT.lt 1 a\n⊢ Eq (HPow.hPow a Ordinal.omega0).card (Max.max Cardinal.aleph0 a.card)","decl":"theorem card_opow_omega0 {a : Ordinal} (h : 1 < a) : card (a ^ ω) = max ℵ₀ a.card := by\n  rw [card_opow_eq_of_omega0_le_right h le_rfl, card_omega0, max_comm]\n\n"}
{"name":"Ordinal.principal_opow_omega","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HPow.hPow x1 x2) (Ordinal.omega o)","decl":"theorem principal_opow_omega (o : Ordinal) : Principal (· ^ ·) (ω_ o) := by\n  obtain rfl | ho := Ordinal.eq_zero_or_pos o\n  · rw [omega_zero]\n    exact principal_opow_omega0\n  · intro a b ha hb\n    rw [lt_omega_iff_card_lt] at ha hb ⊢\n    apply (card_opow_le a b).trans_lt (max_lt _ (max_lt ha hb))\n    rwa [← aleph_zero, aleph_lt_aleph]\n\n"}
{"name":"Ordinal.IsInitial.principal_opow","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsInitial\nho : LE.le Ordinal.omega0 o\n⊢ Ordinal.Principal (fun x1 x2 => HPow.hPow x1 x2) o","decl":"theorem IsInitial.principal_opow {o : Ordinal} (h : IsInitial o) (ho : ω ≤ o) :\n    Principal (· ^ ·) o := by\n  obtain ⟨a, rfl⟩ := mem_range_omega_iff.2 ⟨ho, h⟩\n  exact principal_opow_omega a\n\n"}
{"name":"Ordinal.principal_opow_ord","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\n⊢ Ordinal.Principal (fun x1 x2 => HPow.hPow x1 x2) c.ord","decl":"theorem principal_opow_ord {c : Cardinal} (hc : ℵ₀ ≤ c) : Principal (· ^ ·) c.ord := by\n  apply (isInitial_ord c).principal_opow\n  rwa [omega0_le_ord]\n\n"}
{"name":"Ordinal.principal_add_ord","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) c.ord","decl":"theorem principal_add_ord {c : Cardinal} (hc : ℵ₀ ≤ c) : Principal (· + ·) c.ord := by\n  intro a b ha hb\n  rw [lt_ord, card_add] at *\n  exact add_lt_of_lt hc ha hb\n\n"}
{"name":"Ordinal.IsInitial.principal_add","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsInitial\nho : LE.le Ordinal.omega0 o\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o","decl":"theorem IsInitial.principal_add {o : Ordinal} (h : IsInitial o) (ho : ω ≤ o) :\n    Principal (· + ·) o := by\n  rw [← h.ord_card]\n  apply principal_add_ord\n  rwa [aleph0_le_card]\n\n"}
{"name":"Ordinal.principal_add_omega","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (Ordinal.omega o)","decl":"theorem principal_add_omega (o : Ordinal) : Principal (· + ·) (ω_ o) :=\n  (isInitial_omega o).principal_add (omega0_le_omega o)\n\n"}
{"name":"Ordinal.principal_mul_ord","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nhc : LE.le Cardinal.aleph0 c\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) c.ord","decl":"theorem principal_mul_ord {c : Cardinal} (hc : ℵ₀ ≤ c) : Principal (· * ·) c.ord := by\n  intro a b ha hb\n  rw [lt_ord, card_mul] at *\n  exact mul_lt_of_lt hc ha hb\n\n"}
{"name":"Ordinal.IsInitial.principal_mul","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsInitial\nho : LE.le Ordinal.omega0 o\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o","decl":"theorem IsInitial.principal_mul {o : Ordinal} (h : IsInitial o) (ho : ω ≤ o) :\n    Principal (· * ·) o := by\n  rw [← h.ord_card]\n  apply principal_mul_ord\n  rwa [aleph0_le_card]\n\n"}
{"name":"Ordinal.principal_mul_omega","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) (Ordinal.omega o)","decl":"theorem principal_mul_omega (o : Ordinal) : Principal (· * ·) (ω_ o) :=\n  (isInitial_omega o).principal_mul (omega0_le_omega o)\n\n"}
{"name":"Cardinal.principal_add_aleph","module":"Mathlib.SetTheory.Cardinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (Cardinal.aleph o).ord","decl":"@[deprecated principal_add_omega (since := \"2024-11-08\")]\ntheorem _root_.Cardinal.principal_add_aleph (o : Ordinal) : Principal (· + ·) (ℵ_ o).ord :=\n  principal_add_ord <| aleph0_le_aleph o\n\n"}
