{"name":"CategoryTheory.Limits.FintypeCat.instFiniteObjCompFintypeCatIncl","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"J : Type\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J FintypeCat\nj : J\n⊢ Finite ((K.comp FintypeCat.incl).obj j)","decl":"instance {J : Type} [SmallCategory J] (K : J ⥤ FintypeCat.{u}) (j : J) :\n    Finite ((K ⋙ FintypeCat.incl.{u}).obj j) := by\n  simp only [comp_obj, FintypeCat.incl_obj]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.instHasLimitsOfShapeFintypeCatOfFinCategory","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"J : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J FintypeCat","decl":"instance {J : Type} [SmallCategory J] [FinCategory J] : HasLimitsOfShape J FintypeCat.{u} where\n  has_limit F := hasLimit_of_created F FintypeCat.incl\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.hasFiniteLimits","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.HasFiniteLimits FintypeCat","decl":"instance hasFiniteLimits : HasFiniteLimits FintypeCat.{u} where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.inclusion_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.PreservesFiniteLimits FintypeCat.incl","decl":"noncomputable instance inclusion_preservesFiniteLimits :\n    PreservesFiniteLimits FintypeCat.incl.{u} where\n  preservesFiniteLimits _ :=\n    preservesLimitOfShape_of_createsLimitsOfShape_and_hasLimitsOfShape FintypeCat.incl\n\n/- Help typeclass inference to infer preservation of finite limits for the forgtful functor. -/\n"}
{"name":"CategoryTheory.Limits.FintypeCat.instPreservesFiniteLimitsFintypeCatForget","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.forget FintypeCat)","decl":"noncomputable instance : PreservesFiniteLimits (forget FintypeCat) :=\n  FintypeCat.inclusion_preservesFiniteLimits\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.productEquiv_apply","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nX : ι → FintypeCat\nx : ↑(CategoryTheory.Limits.piObj X)\ni : ι\n⊢ Eq ((CategoryTheory.Limits.FintypeCat.productEquiv X) x i) (CategoryTheory.Limits.Pi.π X i x)","decl":"@[simp]\nlemma productEquiv_apply {ι : Type*} [Finite ι] (X : ι → FintypeCat.{u})\n    (x : (∏ᶜ X : FintypeCat)) (i : ι) : productEquiv X x i = Pi.π X i x := by\n  simpa [productEquiv] using (elementwise_of% piComparison_comp_π FintypeCat.incl X i) x\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.productEquiv_symm_comp_π_apply","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nX : ι → FintypeCat\nx : (i : ι) → ↑(X i)\ni : ι\n⊢ Eq (CategoryTheory.Limits.Pi.π X i ((CategoryTheory.Limits.FintypeCat.productEquiv X).symm x)) (x i)","decl":"@[simp]\nlemma productEquiv_symm_comp_π_apply {ι : Type*} [Finite ι] (X : ι → FintypeCat.{u})\n    (x : ∀ i, X i) (i : ι) : Pi.π X i ((productEquiv X).symm x) = x i := by\n  rw [← productEquiv_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.nonempty_pi_of_nonempty","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"ι : Type u_1\ninst✝¹ : Finite ι\nX : ι → FintypeCat\ninst✝ : ∀ (i : ι), Nonempty ↑(X i)\n⊢ Nonempty ↑(CategoryTheory.Limits.piObj X)","decl":"instance nonempty_pi_of_nonempty {ι : Type*} [Finite ι] (X : ι → FintypeCat.{u})\n    [∀ i, Nonempty (X i)] : Nonempty (∏ᶜ X : FintypeCat.{u}) :=\n  (Equiv.nonempty_congr <| productEquiv X).mpr inferInstance\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.instHasColimitsOfShapeFintypeCatOfFinCategory","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"J : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J FintypeCat","decl":"instance {J : Type} [SmallCategory J] [FinCategory J] : HasColimitsOfShape J FintypeCat.{u} where\n  has_colimit F := hasColimit_of_created F FintypeCat.incl\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.hasFiniteColimits","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.HasFiniteColimits FintypeCat","decl":"instance hasFiniteColimits : HasFiniteColimits FintypeCat.{u} where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.inclusion_preservesFiniteColimits","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.PreservesFiniteColimits FintypeCat.incl","decl":"noncomputable instance inclusion_preservesFiniteColimits :\n    PreservesFiniteColimits FintypeCat.incl.{u} where\n  preservesFiniteColimits _ :=\n    preservesColimitOfShape_of_createsColimitsOfShape_and_hasColimitsOfShape FintypeCat.incl\n\n/- Help typeclass inference to infer preservation of finite colimits for the forgtful functor. -/\n"}
{"name":"CategoryTheory.Limits.FintypeCat.instPreservesFiniteColimitsFintypeCatForget","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"⊢ CategoryTheory.Limits.PreservesFiniteColimits (CategoryTheory.forget FintypeCat)","decl":"noncomputable instance : PreservesFiniteColimits (forget FintypeCat) :=\n  FintypeCat.inclusion_preservesFiniteColimits\n\n"}
{"name":"CategoryTheory.Limits.FintypeCat.jointly_surjective","module":"Mathlib.CategoryTheory.Limits.FintypeCat","initialProofState":"J : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_1, u_1} J\ninst✝ : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor J FintypeCat\nt : CategoryTheory.Limits.Cocone F\nh : CategoryTheory.Limits.IsColimit t\nx : ↑t.pt\n⊢ Exists fun j => Exists fun y => Eq (t.ι.app j y) x","decl":"lemma jointly_surjective {J : Type*} [Category J] [FinCategory J]\n    (F : J ⥤ FintypeCat.{u}) (t : Cocone F) (h : IsColimit t) (x : t.pt) :\n    ∃ j y, t.ι.app j y = x :=\n  let hs := isColimitOfPreserves FintypeCat.incl.{u} h\n  Types.jointly_surjective (F ⋙ FintypeCat.incl) hs x\n\n"}
