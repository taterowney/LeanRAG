{"name":"integralClosure.mem_lifts_of_monic_of_dvd_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra R K\nf : Polynomial R\nhf : f.Monic\ng : Polynomial K\nhg : g.Monic\nhd : Dvd.dvd g (Polynomial.map (algebraMap R K) f)\n⊢ Membership.mem (Polynomial.lifts (algebraMap (Subtype fun x => Membership.mem (integralClosure R K) x) K)) g","decl":"theorem integralClosure.mem_lifts_of_monic_of_dvd_map {f : R[X]} (hf : f.Monic) {g : K[X]}\n    (hg : g.Monic) (hd : g ∣ f.map (algebraMap R K)) :\n    g ∈ lifts (algebraMap (integralClosure R K) K) := by\n  have := mem_lift_of_splits_of_roots_mem_range (integralClosure R g.SplittingField)\n    ((splits_id_iff_splits _).2 <| SplittingField.splits g) (hg.map _) fun a ha =>\n      (SetLike.ext_iff.mp (integralClosure R g.SplittingField).range_algebraMap _).mpr <|\n        roots_mem_integralClosure hf ?_\n  · rw [lifts_iff_coeff_lifts, ← RingHom.coe_range, Subalgebra.range_algebraMap] at this\n    refine (lifts_iff_coeff_lifts _).2 fun n => ?_\n    rw [← RingHom.coe_range, Subalgebra.range_algebraMap]\n    obtain ⟨p, hp, he⟩ := SetLike.mem_coe.mp (this n); use p, hp\n    rw [IsScalarTower.algebraMap_eq R K, coeff_map, ← eval₂_map, eval₂_at_apply] at he\n    rw [eval₂_eq_eval_map]; apply (injective_iff_map_eq_zero _).1 _ _ he\n    apply RingHom.injective\n  rw [aroots_def, IsScalarTower.algebraMap_eq R K _, ← map_map]\n  refine Multiset.mem_of_le (roots.le_of_dvd ((hf.map _).map _).ne_zero ?_) ha\n  exact map_dvd (algebraMap K g.SplittingField) hd\n\n"}
{"name":"IsIntegrallyClosed.eq_map_mul_C_of_dvd","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\nf : Polynomial R\nhf : f.Monic\ng : Polynomial K\nhg : Dvd.dvd g (Polynomial.map (algebraMap R K) f)\n⊢ Exists fun g' => Eq (HMul.hMul (Polynomial.map (algebraMap R K) g') (Polynomial.C g.leadingCoeff)) g","decl":"/-- If `K = Frac(R)` and `g : K[X]` divides a monic polynomial with coefficients in `R`, then\n    `g * (C g.leadingCoeff⁻¹)` has coefficients in `R` -/\ntheorem IsIntegrallyClosed.eq_map_mul_C_of_dvd [IsIntegrallyClosed R] {f : R[X]} (hf : f.Monic)\n    {g : K[X]} (hg : g ∣ f.map (algebraMap R K)) :\n    ∃ g' : R[X], g'.map (algebraMap R K) * (C <| leadingCoeff g) = g := by\n  have g_ne_0 : g ≠ 0 := ne_zero_of_dvd_ne_zero (Monic.ne_zero <| hf.map (algebraMap R K)) hg\n  suffices lem : ∃ g' : R[X], g'.map (algebraMap R K) = g * C g.leadingCoeff⁻¹ by\n    obtain ⟨g', hg'⟩ := lem\n    use g'\n    rw [hg', mul_assoc, ← C_mul, inv_mul_cancel₀ (leadingCoeff_ne_zero.mpr g_ne_0), C_1, mul_one]\n  have g_mul_dvd : g * C g.leadingCoeff⁻¹ ∣ f.map (algebraMap R K) := by\n    rwa [Associated.dvd_iff_dvd_left (show Associated (g * C g.leadingCoeff⁻¹) g from _)]\n    rw [associated_mul_isUnit_left_iff]\n    exact isUnit_C.mpr (inv_ne_zero <| leadingCoeff_ne_zero.mpr g_ne_0).isUnit\n  let algeq :=\n    (Subalgebra.equivOfEq _ _ <| integralClosure_eq_bot R _).trans\n      (Algebra.botEquivOfInjective <| IsFractionRing.injective R <| K)\n  have :\n    (algebraMap R _).comp algeq.toAlgHom.toRingHom = (integralClosure R _).toSubring.subtype := by\n    ext x; (conv_rhs => rw [← algeq.symm_apply_apply x]); rfl\n  have H :=\n    (mem_lifts _).1\n      (integralClosure.mem_lifts_of_monic_of_dvd_map K hf (monic_mul_leadingCoeff_inv g_ne_0)\n        g_mul_dvd)\n  refine ⟨map algeq.toAlgHom.toRingHom ?_, ?_⟩\n  · use! Classical.choose H\n  · rw [map_map, this]\n    exact Classical.choose_spec H\n\n"}
{"name":"Polynomial.IsPrimitive.isUnit_iff_isUnit_map_of_injective","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nφ : RingHom R S\nhinj : Function.Injective ⇑φ\nf : Polynomial R\nhf : f.IsPrimitive\n⊢ Iff (IsUnit f) (IsUnit (Polynomial.map φ f))","decl":"theorem IsPrimitive.isUnit_iff_isUnit_map_of_injective : IsUnit f ↔ IsUnit (map φ f) := by\n  refine ⟨(mapRingHom φ).isUnit_map, fun h => ?_⟩\n  rcases isUnit_iff.1 h with ⟨_, ⟨u, rfl⟩, hu⟩\n  have hdeg := degree_C u.ne_zero\n  rw [hu, degree_map_eq_of_injective hinj] at hdeg\n  rw [eq_C_of_degree_eq_zero hdeg] at hf ⊢\n  exact isUnit_C.mpr (isPrimitive_iff_isUnit_of_C_dvd.mp hf (f.coeff 0) dvd_rfl)\n\n"}
{"name":"Polynomial.IsPrimitive.irreducible_of_irreducible_map_of_injective","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nS : Type u_2\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nφ : RingHom R S\nhinj : Function.Injective ⇑φ\nf : Polynomial R\nhf : f.IsPrimitive\nh_irr : Irreducible (Polynomial.map φ f)\n⊢ Irreducible f","decl":"theorem IsPrimitive.irreducible_of_irreducible_map_of_injective (h_irr : Irreducible (map φ f)) :\n    Irreducible f := by\n  refine\n    ⟨fun h => h_irr.not_unit (IsUnit.map (mapRingHom φ) h), fun a b h =>\n      (h_irr.isUnit_or_isUnit <| by rw [h, Polynomial.map_mul]).imp ?_ ?_⟩\n  all_goals apply ((isPrimitive_of_dvd hf _).isUnit_iff_isUnit_map_of_injective hinj).mpr\n  exacts [Dvd.intro _ h.symm, Dvd.intro_left _ h.symm]\n\n"}
{"name":"Polynomial.IsPrimitive.isUnit_iff_isUnit_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_2\ninst✝² : Field K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\np : Polynomial R\nhp : p.IsPrimitive\n⊢ Iff (IsUnit p) (IsUnit (Polynomial.map (algebraMap R K) p))","decl":"theorem IsPrimitive.isUnit_iff_isUnit_map {p : R[X]} (hp : p.IsPrimitive) :\n    IsUnit p ↔ IsUnit (p.map (algebraMap R K)) :=\n  hp.isUnit_iff_isUnit_map_of_injective (IsFractionRing.injective _ _)\n\n"}
{"name":"Polynomial.Monic.irreducible_iff_irreducible_map_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\np : Polynomial R\nh : p.Monic\n⊢ Iff (Irreducible p) (Irreducible (Polynomial.map (algebraMap R K) p))","decl":"/-- **Gauss's Lemma** for integrally closed domains states that a monic polynomial is irreducible\n  iff it is irreducible in the fraction field. -/\ntheorem Monic.irreducible_iff_irreducible_map_fraction_map [IsIntegrallyClosed R] {p : R[X]}\n    (h : p.Monic) : Irreducible p ↔ Irreducible (p.map <| algebraMap R K) := by\n  /- The ← direction follows from `IsPrimitive.irreducible_of_irreducible_map_of_injective`.\n       For the → direction, it is enough to show that if `(p.map <| algebraMap R K) = a * b` and\n       `a` is not a unit then `b` is a unit -/\n  refine\n    ⟨fun hp =>\n      irreducible_iff.mpr\n        ⟨hp.not_unit.imp h.isPrimitive.isUnit_iff_isUnit_map.mpr, fun a b H =>\n          or_iff_not_imp_left.mpr fun hₐ => ?_⟩,\n      fun hp =>\n      h.isPrimitive.irreducible_of_irreducible_map_of_injective (IsFractionRing.injective R K) hp⟩\n  obtain ⟨a', ha⟩ := eq_map_mul_C_of_dvd K h (dvd_of_mul_right_eq b H.symm)\n  obtain ⟨b', hb⟩ := eq_map_mul_C_of_dvd K h (dvd_of_mul_left_eq a H.symm)\n  have : a.leadingCoeff * b.leadingCoeff = 1 := by\n    rw [← leadingCoeff_mul, ← H, Monic.leadingCoeff (h.map <| algebraMap R K)]\n  rw [← ha, ← hb, mul_comm _ (C b.leadingCoeff), mul_assoc, ← mul_assoc (C a.leadingCoeff), ←\n    C_mul, this, C_1, one_mul, ← Polynomial.map_mul] at H\n  rw [← hb, ← Polynomial.coe_mapRingHom]\n  refine\n    IsUnit.mul (IsUnit.map _ (Or.resolve_left (hp.isUnit_or_isUnit ?_) (show ¬IsUnit a' from ?_)))\n      (isUnit_iff_exists_inv'.mpr\n        -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5073): was `rwa`\n        (Exists.intro (C a.leadingCoeff) <| by rw [← C_mul, this, C_1]))\n  · exact Polynomial.map_injective _ (IsFractionRing.injective R K) H\n  · by_contra h_contra\n    refine hₐ ?_\n    rw [← ha, ← Polynomial.coe_mapRingHom]\n    exact\n      IsUnit.mul (IsUnit.map _ h_contra)\n        (isUnit_iff_exists_inv.mpr\n          -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5073): was `rwa`\n          (Exists.intro (C b.leadingCoeff) <| by rw [← C_mul, this, C_1]))\n\n"}
{"name":"Polynomial.isIntegrallyClosed_iff'","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsDomain R\n⊢ Iff (IsIntegrallyClosed R) (∀ (p : Polynomial R), p.Monic → Iff (Irreducible p) (Irreducible (Polynomial.map (algebraMap R K) p)))","decl":"/-- Integrally closed domains are precisely the domains for in which Gauss's lemma holds\n    for monic polynomials -/\ntheorem isIntegrallyClosed_iff' [IsDomain R] :\n    IsIntegrallyClosed R ↔\n      ∀ p : R[X], p.Monic → (Irreducible p ↔ Irreducible (p.map <| algebraMap R K)) := by\n  constructor\n  · intro hR p hp; exact Monic.irreducible_iff_irreducible_map_fraction_map hp\n  · intro H\n    refine\n      (isIntegrallyClosed_iff K).mpr fun {x} hx =>\n        RingHom.mem_range.mp <| minpoly.mem_range_of_degree_eq_one R x ?_\n    rw [← Monic.degree_map (minpoly.monic hx) (algebraMap R K)]\n    apply\n      degree_eq_one_of_irreducible_of_root ((H _ <| minpoly.monic hx).mp (minpoly.irreducible hx))\n    rw [IsRoot, eval_map, ← aeval_def, minpoly.aeval R x]\n\n"}
{"name":"Polynomial.Monic.dvd_of_fraction_map_dvd_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\nh : Dvd.dvd (Polynomial.map (algebraMap R K) q) (Polynomial.map (algebraMap R K) p)\n⊢ Dvd.dvd q p","decl":"theorem Monic.dvd_of_fraction_map_dvd_fraction_map [IsIntegrallyClosed R] {p q : R[X]}\n    (hp : p.Monic) (hq : q.Monic)\n    (h : q.map (algebraMap R K) ∣ p.map (algebraMap R K)) : q ∣ p := by\n  obtain ⟨r, hr⟩ := h\n  obtain ⟨d', hr'⟩ := IsIntegrallyClosed.eq_map_mul_C_of_dvd K hp (dvd_of_mul_left_eq _ hr.symm)\n  rw [Monic.leadingCoeff, C_1, mul_one] at hr'\n  · rw [← hr', ← Polynomial.map_mul] at hr\n    exact dvd_of_mul_right_eq _ (Polynomial.map_injective _ (IsFractionRing.injective R K) hr.symm)\n  · exact Monic.of_mul_monic_left (hq.map (algebraMap R K)) (by simpa [← hr] using hp.map _)\n\n"}
{"name":"Polynomial.Monic.dvd_iff_fraction_map_dvd_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_2\ninst✝³ : Field K\ninst✝² : Algebra R K\ninst✝¹ : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\np q : Polynomial R\nhp : p.Monic\nhq : q.Monic\n⊢ Iff (Dvd.dvd (Polynomial.map (algebraMap R K) q) (Polynomial.map (algebraMap R K) p)) (Dvd.dvd q p)","decl":"theorem Monic.dvd_iff_fraction_map_dvd_fraction_map [IsIntegrallyClosed R] {p q : R[X]}\n    (hp : p.Monic) (hq : q.Monic) : q.map (algebraMap R K) ∣ p.map (algebraMap R K) ↔ q ∣ p :=\n  ⟨fun h => hp.dvd_of_fraction_map_dvd_fraction_map hq h, fun ⟨a, b⟩ =>\n    ⟨a.map (algebraMap R K), b.symm ▸ Polynomial.map_mul (algebraMap R K)⟩⟩\n\n"}
{"name":"Polynomial.isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial K\nh0 : Ne p 0\nh : IsUnit (IsLocalization.integerNormalization (nonZeroDivisors R) p).primPart\n⊢ IsUnit p","decl":"theorem isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart {p : K[X]} (h0 : p ≠ 0)\n    (h : IsUnit (integerNormalization R⁰ p).primPart) : IsUnit p := by\n  rcases isUnit_iff.1 h with ⟨_, ⟨u, rfl⟩, hu⟩\n  obtain ⟨⟨c, c0⟩, hc⟩ := integerNormalization_map_to_map R⁰ p\n  rw [Subtype.coe_mk, Algebra.smul_def, algebraMap_apply] at hc\n  apply isUnit_of_mul_isUnit_right\n  rw [← hc, (integerNormalization R⁰ p).eq_C_content_mul_primPart, ← hu, ← RingHom.map_mul,\n    isUnit_iff]\n  refine\n    ⟨algebraMap R K ((integerNormalization R⁰ p).content * ↑u), isUnit_iff_ne_zero.2 fun con => ?_,\n      by simp⟩\n  replace con := (injective_iff_map_eq_zero (algebraMap R K)).1 (IsFractionRing.injective _ _) _ con\n  rw [mul_eq_zero, content_eq_zero_iff, IsFractionRing.integerNormalization_eq_zero_iff] at con\n  rcases con with (con | con)\n  · apply h0 con\n  · apply Units.ne_zero _ con\n\n"}
{"name":"Polynomial.IsPrimitive.irreducible_iff_irreducible_map_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nhp : p.IsPrimitive\n⊢ Iff (Irreducible p) (Irreducible (Polynomial.map (algebraMap R K) p))","decl":"/-- **Gauss's Lemma** for GCD domains states that a primitive polynomial is irreducible iff it is\n  irreducible in the fraction field. -/\ntheorem IsPrimitive.irreducible_iff_irreducible_map_fraction_map {p : R[X]} (hp : p.IsPrimitive) :\n    Irreducible p ↔ Irreducible (p.map (algebraMap R K)) := by\n  -- Porting note: was `(IsFractionRing.injective _ _)`\n  refine\n    ⟨fun hi => ⟨fun h => hi.not_unit (hp.isUnit_iff_isUnit_map.2 h), fun a b hab => ?_⟩,\n      hp.irreducible_of_irreducible_map_of_injective (IsFractionRing.injective R K)⟩\n  obtain ⟨⟨c, c0⟩, hc⟩ := integerNormalization_map_to_map R⁰ a\n  obtain ⟨⟨d, d0⟩, hd⟩ := integerNormalization_map_to_map R⁰ b\n  rw [Algebra.smul_def, algebraMap_apply, Subtype.coe_mk] at hc hd\n  rw [mem_nonZeroDivisors_iff_ne_zero] at c0 d0\n  have hcd0 : c * d ≠ 0 := mul_ne_zero c0 d0\n  rw [Ne, ← C_eq_zero] at hcd0\n  have h1 : C c * C d * p = integerNormalization R⁰ a * integerNormalization R⁰ b := by\n    apply map_injective (algebraMap R K) (IsFractionRing.injective _ _) _\n    rw [Polynomial.map_mul, Polynomial.map_mul, Polynomial.map_mul, hc, hd, map_C, map_C, hab]\n    ring\n  obtain ⟨u, hu⟩ :\n    Associated (c * d)\n      (content (integerNormalization R⁰ a) * content (integerNormalization R⁰ b)) := by\n    rw [← dvd_dvd_iff_associated, ← normalize_eq_normalize_iff, normalize.map_mul,\n      normalize.map_mul, normalize_content, normalize_content, ←\n      mul_one (normalize c * normalize d), ← hp.content_eq_one, ← content_C, ← content_C, ←\n      content_mul, ← content_mul, ← content_mul, h1]\n  rw [← RingHom.map_mul, eq_comm, (integerNormalization R⁰ a).eq_C_content_mul_primPart,\n    (integerNormalization R⁰ b).eq_C_content_mul_primPart, mul_assoc, mul_comm _ (C _ * _), ←\n    mul_assoc, ← mul_assoc, ← RingHom.map_mul, ← hu, RingHom.map_mul, mul_assoc, mul_assoc, ←\n    mul_assoc (C (u : R))] at h1\n  have h0 : a ≠ 0 ∧ b ≠ 0 := by\n    classical\n    rw [Ne, Ne, ← not_or, ← mul_eq_zero, ← hab]\n    intro con\n    apply hp.ne_zero (map_injective (algebraMap R K) (IsFractionRing.injective _ _) _)\n    simp [con]\n  rcases hi.isUnit_or_isUnit (mul_left_cancel₀ hcd0 h1).symm with (h | h)\n  · right\n    apply\n      isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart h0.2\n        (isUnit_of_mul_isUnit_right h)\n  · left\n    apply isUnit_or_eq_zero_of_isUnit_integerNormalization_primPart h0.1 h\n\n"}
{"name":"Polynomial.IsPrimitive.dvd_of_fraction_map_dvd_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : q.IsPrimitive\nh_dvd : Dvd.dvd (Polynomial.map (algebraMap R K) p) (Polynomial.map (algebraMap R K) q)\n⊢ Dvd.dvd p q","decl":"theorem IsPrimitive.dvd_of_fraction_map_dvd_fraction_map {p q : R[X]} (hp : p.IsPrimitive)\n    (hq : q.IsPrimitive) (h_dvd : p.map (algebraMap R K) ∣ q.map (algebraMap R K)) : p ∣ q := by\n  rcases h_dvd with ⟨r, hr⟩\n  obtain ⟨⟨s, s0⟩, hs⟩ := integerNormalization_map_to_map R⁰ r\n  rw [Subtype.coe_mk, Algebra.smul_def, algebraMap_apply] at hs\n  have h : p ∣ q * C s := by\n    use integerNormalization R⁰ r\n    apply map_injective (algebraMap R K) (IsFractionRing.injective _ _)\n    rw [Polynomial.map_mul, Polynomial.map_mul, hs, hr, mul_assoc, mul_comm r]\n    simp\n  rw [← hp.dvd_primPart_iff_dvd, primPart_mul, hq.primPart_eq, Associated.dvd_iff_dvd_right] at h\n  · exact h\n  · symm\n    rcases isUnit_primPart_C s with ⟨u, hu⟩\n    use u\n    rw [hu]\n  iterate 2\n    apply mul_ne_zero hq.ne_zero\n    rw [Ne, C_eq_zero]\n    contrapose! s0\n    simp [s0, mem_nonZeroDivisors_iff_ne_zero]\n\n"}
{"name":"Polynomial.IsPrimitive.dvd_iff_fraction_map_dvd_fraction_map","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nK : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Algebra R K\ninst✝² : IsFractionRing R K\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : q.IsPrimitive\n⊢ Iff (Dvd.dvd p q) (Dvd.dvd (Polynomial.map (algebraMap R K) p) (Polynomial.map (algebraMap R K) q))","decl":"theorem IsPrimitive.dvd_iff_fraction_map_dvd_fraction_map {p q : R[X]} (hp : p.IsPrimitive)\n    (hq : q.IsPrimitive) : p ∣ q ↔ p.map (algebraMap R K) ∣ q.map (algebraMap R K) :=\n  ⟨fun ⟨a, b⟩ => ⟨a.map (algebraMap R K), b.symm ▸ Polynomial.map_mul (algebraMap R K)⟩, fun h =>\n    hp.dvd_of_fraction_map_dvd_fraction_map hq h⟩\n\n"}
{"name":"Polynomial.IsPrimitive.Int.irreducible_iff_irreducible_map_cast","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"p : Polynomial Int\nhp : p.IsPrimitive\n⊢ Iff (Irreducible p) (Irreducible (Polynomial.map (Int.castRingHom Rat) p))","decl":"/-- **Gauss's Lemma** for `ℤ` states that a primitive integer polynomial is irreducible iff it is\n  irreducible over `ℚ`. -/\ntheorem IsPrimitive.Int.irreducible_iff_irreducible_map_cast {p : ℤ[X]} (hp : p.IsPrimitive) :\n    Irreducible p ↔ Irreducible (p.map (Int.castRingHom ℚ)) :=\n  hp.irreducible_iff_irreducible_map_fraction_map\n\n"}
{"name":"Polynomial.IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast","module":"Mathlib.RingTheory.Polynomial.GaussLemma","initialProofState":"p q : Polynomial Int\nhp : p.IsPrimitive\nhq : q.IsPrimitive\n⊢ Iff (Dvd.dvd p q) (Dvd.dvd (Polynomial.map (Int.castRingHom Rat) p) (Polynomial.map (Int.castRingHom Rat) q))","decl":"theorem IsPrimitive.Int.dvd_iff_map_cast_dvd_map_cast (p q : ℤ[X]) (hp : p.IsPrimitive)\n    (hq : q.IsPrimitive) : p ∣ q ↔ p.map (Int.castRingHom ℚ) ∣ q.map (Int.castRingHom ℚ) :=\n  hp.dvd_iff_fraction_map_dvd_fraction_map ℚ hq\n\n"}
