{"name":"CategoryTheory.HasExactColimitsOfShape.preservesFiniteLimits","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nself : CategoryTheory.HasExactColimitsOfShape J C\n⊢ CategoryTheory.Limits.PreservesFiniteLimits CategoryTheory.Limits.colim","decl":"/--\nA category `C` is said to have exact colimits of shape `J` provided that colimits of shape `J`\nexist and are exact (in the sense that they preserve finite limits).\n-/\nclass HasExactColimitsOfShape (J : Type u') [Category.{v'} J] (C : Type u) [Category.{v} C]\n    [HasColimitsOfShape J C]  where\n  /-- Exactness of `J`-shaped colimits stated as `colim : (J ⥤ C) ⥤ C` preserving finite limits. -/\n  preservesFiniteLimits : PreservesFiniteLimits (colim (J := J) (C := C))\n\n"}
{"name":"CategoryTheory.HasExactLimitsOfShape.preservesFiniteColimits","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"J : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nself : CategoryTheory.HasExactLimitsOfShape J C\n⊢ CategoryTheory.Limits.PreservesFiniteColimits CategoryTheory.Limits.lim","decl":"/--\nA category `C` is said to have exact limits of shape `J` provided that limits of shape `J`\nexist and are exact (in the sense that they preserve finite colimits).\n-/\nclass HasExactLimitsOfShape (J : Type u') [Category.{v'} J] (C : Type u) [Category.{v} C]\n    [HasLimitsOfShape J C] where\n  /-- Exactness of `J`-shaped limits stated as `lim : (J ⥤ C) ⥤ C` preserving finite colimits. -/\n  preservesFiniteColimits : PreservesFiniteColimits (lim (J := J) (C := C))\n\n"}
{"name":"CategoryTheory.HasExactColimitsOfShape.domain_of_functor","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nJ : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_2} J\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} D\ninst✝⁶ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝⁵ : CategoryTheory.Limits.HasColimitsOfShape J D\ninst✝⁴ : CategoryTheory.HasExactColimitsOfShape J D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.PreservesFiniteLimits F\ninst✝² : CategoryTheory.Limits.ReflectsFiniteLimits F\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfShape J F\n⊢ CategoryTheory.HasExactColimitsOfShape J C","decl":"variable {C} in\n/--\nPull back a `HasExactColimitsOfShape J` along a functor which preserves and reflects finite limits\nand preserves colimits of shape `J`\n-/\nlemma HasExactColimitsOfShape.domain_of_functor {D : Type*} (J : Type*) [Category J] [Category D]\n    [HasColimitsOfShape J C] [HasColimitsOfShape J D] [HasExactColimitsOfShape J D]\n    (F : C ⥤ D) [PreservesFiniteLimits F] [ReflectsFiniteLimits F] [HasFiniteLimits C]\n    [PreservesColimitsOfShape J F] : HasExactColimitsOfShape J C where\n  preservesFiniteLimits := { preservesFiniteLimits I := { preservesLimit {G} := {\n    preserves {c} hc := by\n      constructor\n      apply isLimitOfReflects F\n      refine (IsLimit.equivOfNatIsoOfIso (isoWhiskerLeft G (preservesColimitNatIso F).symm)\n        ((_ ⋙ colim).mapCone c) _ ?_) (isLimitOfPreserves _ hc)\n      exact Cones.ext ((preservesColimitNatIso F).symm.app _)\n        fun i ↦ (preservesColimitNatIso F).inv.naturality _ } } }\n\n"}
{"name":"CategoryTheory.HasExactLimitsOfShape.domain_of_functor","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nJ : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} D\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} J\ninst✝⁶ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝⁵ : CategoryTheory.Limits.HasLimitsOfShape J D\ninst✝⁴ : CategoryTheory.HasExactLimitsOfShape J D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.PreservesFiniteColimits F\ninst✝² : CategoryTheory.Limits.ReflectsFiniteColimits F\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape J F\n⊢ CategoryTheory.HasExactLimitsOfShape J C","decl":"variable {C} in\n/--\nPull back a `HasExactLimitsOfShape J` along a functor which preserves and reflects finite colimits\nand preserves limits of shape `J`\n-/\nlemma HasExactLimitsOfShape.domain_of_functor {D : Type*} (J : Type*) [Category D] [Category J]\n    [HasLimitsOfShape J C] [HasLimitsOfShape J D] [HasExactLimitsOfShape J D]\n    (F : C ⥤ D) [PreservesFiniteColimits F] [ReflectsFiniteColimits F] [HasFiniteColimits C]\n    [PreservesLimitsOfShape J F] : HasExactLimitsOfShape J C where\n  preservesFiniteColimits := { preservesFiniteColimits I := { preservesColimit {G} := {\n    preserves {c} hc := by\n      constructor\n      apply isColimitOfReflects F\n      refine (IsColimit.equivOfNatIsoOfIso (isoWhiskerLeft G (preservesLimitNatIso F).symm)\n        ((_ ⋙ lim).mapCocone c) _ ?_) (isColimitOfPreserves _ hc)\n      refine Cocones.ext ((preservesLimitNatIso F).symm.app _) fun i ↦ ?_\n      simp only [Functor.comp_obj, lim_obj, Functor.mapCocone_pt, isoWhiskerLeft_inv, Iso.symm_inv,\n        Cocones.precompose_obj_pt, whiskeringRight_obj_obj, Functor.const_obj_obj,\n        Cocones.precompose_obj_ι, NatTrans.comp_app, whiskerLeft_app, preservesLimitNatIso_hom_app,\n        Functor.mapCocone_ι_app, Functor.comp_map, whiskeringRight_obj_map, lim_map, Iso.app_hom,\n        Iso.symm_hom, preservesLimitNatIso_inv_app, Category.assoc]\n      rw [← Iso.eq_inv_comp]\n      exact (preservesLimitNatIso F).inv.naturality _ } } }\n\n"}
{"name":"CategoryTheory.HasExactColimitsOfShape.of_domain_equivalence","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nJ' : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} J\ninst✝² : CategoryTheory.Category.{u_4, u_2} J'\ne : CategoryTheory.Equivalence J J'\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.HasExactColimitsOfShape J C\n⊢ CategoryTheory.HasExactColimitsOfShape J' C","decl":"/--\nTransport a `HasExactColimitsOfShape` along an equivalence of the shape.\n\nNote: When `C` has finite limits, this lemma holds with the equivalence replaced by a final\nfunctor, see `hasExactColimitsOfShape_of_final` below.\n-/\nlemma HasExactColimitsOfShape.of_domain_equivalence {J J' : Type*} [Category J] [Category J']\n    (e : J ≌ J') [HasColimitsOfShape J C] [HasExactColimitsOfShape J C] :\n    haveI : HasColimitsOfShape J' C := hasColimitsOfShape_of_equivalence e\n    HasExactColimitsOfShape J' C :=\n  haveI : HasColimitsOfShape J' C := hasColimitsOfShape_of_equivalence e\n  ⟨preservesFiniteLimits_of_natIso (Functor.Final.colimIso e.functor)⟩\n\n"}
{"name":"CategoryTheory.HasExactColimitsOfShape.of_codomain_equivalence","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} J\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ne : CategoryTheory.Equivalence C D\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.HasExactColimitsOfShape J C\n⊢ CategoryTheory.HasExactColimitsOfShape J D","decl":"variable {C} in\nlemma HasExactColimitsOfShape.of_codomain_equivalence (J : Type*) [Category J] {D : Type*}\n    [Category D] (e : C ≌ D) [HasColimitsOfShape J C] [HasExactColimitsOfShape J C] :\n    haveI : HasColimitsOfShape J D := Adjunction.hasColimitsOfShape_of_equivalence e.inverse\n    HasExactColimitsOfShape J D := by\n  haveI : HasColimitsOfShape J D := Adjunction.hasColimitsOfShape_of_equivalence e.inverse\n  refine ⟨⟨fun _ _ _ => ⟨@fun K => ?_⟩⟩⟩\n  refine preservesLimit_of_natIso K (?_ : e.congrRight.inverse ⋙ colim ⋙ e.functor ≅ colim)\n  apply e.symm.congrRight.fullyFaithfulFunctor.preimageIso\n  exact isoWhiskerLeft (_ ⋙ colim) e.unitIso.symm ≪≫ (preservesColimitNatIso e.inverse).symm\n\n"}
{"name":"CategoryTheory.HasExactLimitsOfShape.of_domain_equivalence","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\nJ' : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} J\ninst✝² : CategoryTheory.Category.{u_4, u_2} J'\ne : CategoryTheory.Equivalence J J'\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.HasExactLimitsOfShape J C\n⊢ CategoryTheory.HasExactLimitsOfShape J' C","decl":"/--\nTransport a `HasExactLimitsOfShape` along an equivalence of the shape.\n\nNote: When `C` has finite colimits, this lemma holds with the equivalence replaced by a initial\nfunctor, see `hasExactLimitsOfShape_of_initial` below.\n-/\nlemma HasExactLimitsOfShape.of_domain_equivalence {J J' : Type*} [Category J] [Category J']\n    (e : J ≌ J') [HasLimitsOfShape J C] [HasExactLimitsOfShape J C] :\n    haveI : HasLimitsOfShape J' C := hasLimitsOfShape_of_equivalence e\n    HasExactLimitsOfShape J' C :=\n  haveI : HasLimitsOfShape J' C := hasLimitsOfShape_of_equivalence e\n  ⟨preservesFiniteColimits_of_natIso (Functor.Initial.limIso e.functor)⟩\n\n"}
{"name":"CategoryTheory.HasExactLimitsOfShape.of_codomain_equivalence","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nJ : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} J\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ne : CategoryTheory.Equivalence C D\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.HasExactLimitsOfShape J C\n⊢ CategoryTheory.HasExactLimitsOfShape J D","decl":"variable {C} in\nlemma HasExactLimitsOfShape.of_codomain_equivalence (J : Type*) [Category J] {D : Type*}\n    [Category D] (e : C ≌ D) [HasLimitsOfShape J C] [HasExactLimitsOfShape J C] :\n    haveI : HasLimitsOfShape J D := Adjunction.hasLimitsOfShape_of_equivalence e.inverse\n    HasExactLimitsOfShape J D := by\n  haveI : HasLimitsOfShape J D := Adjunction.hasLimitsOfShape_of_equivalence e.inverse\n  refine ⟨⟨fun _ _ _ => ⟨@fun K => ?_⟩⟩⟩\n  refine preservesColimit_of_natIso K (?_ : e.congrRight.inverse ⋙ lim ⋙ e.functor ≅ lim)\n  apply e.symm.congrRight.fullyFaithfulFunctor.preimageIso\n  exact isoWhiskerLeft (_ ⋙ lim) e.unitIso.symm ≪≫ (preservesLimitNatIso e.inverse).symm\n\n"}
{"name":"CategoryTheory.Adjunction.hasExactColimitsOfShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝⁸ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝⁷ : G.Full\ninst✝⁶ : G.Faithful\nJ : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} J\ninst✝⁴ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J D\ninst✝² : CategoryTheory.HasExactColimitsOfShape J C\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits D\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ CategoryTheory.HasExactColimitsOfShape J D","decl":"/-- Let `adj : F ⊣ G` be an adjunction, with `G : D ⥤ C` reflective.\nAssume that `D` has finite limits and `F` commutes to them.\nIf `C` has exact colimits of shape `J`, then `D` also has exact colimits of shape `J`. -/\nlemma hasExactColimitsOfShape (adj : F ⊣ G) [G.Full] [G.Faithful]\n    (J : Type u') [Category.{v'} J] [HasColimitsOfShape J C] [HasColimitsOfShape J D]\n    [HasExactColimitsOfShape J C] [HasFiniteLimits D] [PreservesFiniteLimits F] :\n    HasExactColimitsOfShape J D where\n  preservesFiniteLimits := ⟨fun K _ _ ↦ ⟨fun {H} ↦ by\n    have : PreservesLimitsOfSize.{0, 0} G := adj.rightAdjoint_preservesLimits\n    have : PreservesColimitsOfSize.{v', u'} F := adj.leftAdjoint_preservesColimits\n    let e : (whiskeringRight J D C).obj G ⋙ colim ⋙ F ≅ colim :=\n      isoWhiskerLeft _ (preservesColimitNatIso F) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (whiskeringRightObjCompIso G F) _ ≪≫\n        isoWhiskerRight ((whiskeringRight J D D).mapIso (asIso adj.counit)) _ ≪≫\n        isoWhiskerRight wiskeringRightObjIdIso _ ≪≫ colim.leftUnitor\n    exact preservesLimit_of_natIso _ e⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.hasExactLimitsOfShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁹ : CategoryTheory.Category.{v, u} C\nD : Type u''\ninst✝⁸ : CategoryTheory.Category.{v'', u''} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝⁷ : F.Full\ninst✝⁶ : F.Faithful\nJ : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} J\ninst✝⁴ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J D\ninst✝² : CategoryTheory.HasExactLimitsOfShape J D\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits G\n⊢ CategoryTheory.HasExactLimitsOfShape J C","decl":"/-- Let `adj : F ⊣ G` be an adjunction, with `F : C ⥤ D` coreflective.\nAssume that `C` has finite colimits and `G` commutes to them.\nIf `D` has exact limits of shape `J`, then `C` also has exact limits of shape `J`. -/\nlemma hasExactLimitsOfShape (adj : F ⊣ G) [F.Full] [F.Faithful]\n    (J : Type u') [Category.{v'} J] [HasLimitsOfShape J C] [HasLimitsOfShape J D]\n    [HasExactLimitsOfShape J D] [HasFiniteColimits C] [PreservesFiniteColimits G] :\n    HasExactLimitsOfShape J C where\n  preservesFiniteColimits:= ⟨fun K _ _ ↦ ⟨fun {H} ↦ by\n    have : PreservesLimitsOfSize.{v', u'} G := adj.rightAdjoint_preservesLimits\n    have : PreservesColimitsOfSize.{0, 0} F := adj.leftAdjoint_preservesColimits\n    let e : (whiskeringRight J _ _).obj F ⋙ lim ⋙ G ≅ lim :=\n      isoWhiskerLeft _ (preservesLimitNatIso G) ≪≫\n        (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (whiskeringRightObjCompIso F G) _ ≪≫\n        isoWhiskerRight ((whiskeringRight J C C).mapIso (asIso adj.unit).symm) _ ≪≫\n        isoWhiskerRight wiskeringRightObjIdIso _ ≪≫ lim.leftUnitor\n    exact preservesColimit_of_natIso _ e⟩⟩\n\n"}
{"name":"CategoryTheory.AB4OfSize.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\nself : CategoryTheory.AB4OfSize.{w, v, u} C\nα : Type w\n⊢ CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete α) C","decl":"/--\nA category `C` which has coproducts is said to have `AB4` of size `w` provided that\ncoproducts of size `w` are exact.\n-/\n@[pp_with_univ]\nclass AB4OfSize [HasCoproducts.{w} C] where\n  ofShape (α : Type w) : HasExactColimitsOfShape (Discrete α) C\n\n"}
{"name":"CategoryTheory.AB4OfSize_shrink","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCoproducts C\ninst✝ : CategoryTheory.AB4OfSize.{max w w', v, u} C\n⊢ CategoryTheory.AB4OfSize.{w, v, u} C","decl":"lemma AB4OfSize_shrink [HasCoproducts.{max w w'} C] [AB4OfSize.{max w w'} C] :\n    haveI : HasCoproducts.{w} C := hasCoproducts_shrink.{w, w'}\n    AB4OfSize.{w} C :=\n  haveI := hasCoproducts_shrink.{w, w'} (C := C)\n  ⟨fun J ↦ HasExactColimitsOfShape.of_domain_equivalence C\n    (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) ≌ _)⟩\n\n"}
{"name":"CategoryTheory.instAB4OfSize","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCoproducts C\ninst✝ : CategoryTheory.AB4OfSize.{w, v, u} C\n⊢ CategoryTheory.AB4OfSize.{0, v, u} C","decl":"instance (priority := 100) [HasCoproducts.{w} C] [AB4OfSize.{w} C] :\n    haveI : HasCoproducts.{0} C := hasCoproducts_shrink\n    AB4OfSize.{0} C := AB4OfSize_shrink C\n\n"}
{"name":"CategoryTheory.AB4StarOfSize.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nself : CategoryTheory.AB4StarOfSize.{w, v, u} C\nα : Type w\n⊢ CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete α) C","decl":"/-- A category `C` which has products is said to have `AB4Star` (in literature `AB4*`)\nprovided that products are exact. -/\n@[pp_with_univ, stacks 079B]\nclass AB4StarOfSize [HasProducts.{w} C] where\n  ofShape (α : Type w) : HasExactLimitsOfShape (Discrete α) C\n\n"}
{"name":"CategoryTheory.AB4StarOfSize_shrink","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasProducts C\ninst✝ : CategoryTheory.AB4StarOfSize.{max w w', v, u} C\n⊢ CategoryTheory.AB4StarOfSize.{w, v, u} C","decl":"lemma AB4StarOfSize_shrink [HasProducts.{max w w'} C] [AB4StarOfSize.{max w w'} C] :\n    haveI : HasProducts.{w} C := hasProducts_shrink.{w, w'}\n    AB4StarOfSize.{w} C :=\n  haveI := hasProducts_shrink.{w, w'} (C := C)\n  ⟨fun J ↦ HasExactLimitsOfShape.of_domain_equivalence C\n    (Discrete.equivalence Equiv.ulift : Discrete (ULift.{w'} J) ≌ _)⟩\n\n"}
{"name":"CategoryTheory.instAB4StarOfSize","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasProducts C\ninst✝ : CategoryTheory.AB4StarOfSize.{w, v, u} C\n⊢ CategoryTheory.AB4StarOfSize.{0, v, u} C","decl":"instance (priority := 100) [HasProducts.{w} C] [AB4StarOfSize.{w} C] :\n    haveI : HasProducts.{0} C := hasProducts_shrink\n    AB4StarOfSize.{0} C := AB4StarOfSize_shrink C\n\n"}
{"name":"CategoryTheory.CountableAB4.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCountableCoproducts C\nself : CategoryTheory.CountableAB4 C\nα : Type\ninst✝ : Countable α\n⊢ CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete α) C","decl":"/--\nA category `C` which has countable coproducts is said to have countable `AB4` provided that\ncountable coproducts are exact.\n-/\nclass CountableAB4 [HasCountableCoproducts C] where\n  ofShape (α : Type) [Countable α] : HasExactColimitsOfShape (Discrete α) C\n\n"}
{"name":"CategoryTheory.instCountableAB4OfAB4OfSize","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCoproducts C\ninst✝ : CategoryTheory.AB4OfSize.{0, v, u} C\n⊢ CategoryTheory.CountableAB4 C","decl":"instance (priority := 100) [HasCoproducts.{0} C] [AB4OfSize.{0} C] : CountableAB4 C :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.CountableAB4Star.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCountableProducts C\nself : CategoryTheory.CountableAB4Star C\nα : Type\ninst✝ : Countable α\n⊢ CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete α) C","decl":"/--\nA category `C` which has countable coproducts is said to have countable `AB4Star` provided that\ncountable products are exact.\n-/\nclass CountableAB4Star [HasCountableProducts C] where\n  ofShape (α : Type) [Countable α] : HasExactLimitsOfShape (Discrete α) C\n\n"}
{"name":"CategoryTheory.instCountableAB4StarOfAB4StarOfSize","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasProducts C\ninst✝ : CategoryTheory.AB4StarOfSize.{0, v, u} C\n⊢ CategoryTheory.CountableAB4Star C","decl":"instance (priority := 100) [HasProducts.{0} C] [AB4StarOfSize.{0} C] : CountableAB4Star C :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.AB5OfSize.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w', v, u} C\nself : CategoryTheory.AB5OfSize.{w, w', v, u} C\nJ : Type w'\ninst✝¹ : CategoryTheory.Category.{w, w'} J\ninst✝ : CategoryTheory.IsFiltered J\n⊢ CategoryTheory.HasExactColimitsOfShape J C","decl":"/--\nA category `C` which has filtered colimits of a given size is said to have `AB5` of that size\nprovided that these filtered colimits are exact.\n\n`AB5OfSize.{w, w'} C` means that `C` has exact colimits of shape `J : Type w'` with\n`Category.{w} J` such that `J` is filtered.\n-/\n@[pp_with_univ]\nclass AB5OfSize [HasFilteredColimitsOfSize.{w, w'} C] where\n  ofShape (J : Type w') [Category.{w} J] [IsFiltered J] : HasExactColimitsOfShape J C\n\n"}
{"name":"CategoryTheory.AB5OfSize_of_univLE","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w₂, w₂', v, u} C\ninst✝² : UnivLE.{w, w₂}\ninst✝¹ : UnivLE.{w', w₂'}\ninst✝ : CategoryTheory.AB5OfSize.{w₂, w₂', v, u} C\n⊢ CategoryTheory.AB5OfSize.{w, w', v, u} C","decl":"lemma AB5OfSize_of_univLE [HasFilteredColimitsOfSize.{w₂, w₂'} C] [UnivLE.{w, w₂}]\n    [UnivLE.{w', w₂'}] [AB5OfSize.{w₂, w₂'} C] :\n    haveI : HasFilteredColimitsOfSize.{w, w'} C := hasFilteredColimitsOfSize_of_univLE.{w}\n    AB5OfSize.{w, w'} C := by\n  haveI : HasFilteredColimitsOfSize.{w, w'} C := hasFilteredColimitsOfSize_of_univLE.{w}\n  constructor\n  intro J _ _\n  haveI := IsFiltered.of_equivalence ((ShrinkHoms.equivalence.{w₂} J).trans <|\n    Shrink.equivalence.{w₂'} (ShrinkHoms.{w'} J))\n  exact HasExactColimitsOfShape.of_domain_equivalence _ ((ShrinkHoms.equivalence.{w₂} J).trans <|\n    Shrink.equivalence.{w₂'} (ShrinkHoms.{w'} J)).symm\n\n"}
{"name":"CategoryTheory.AB5OfSize_shrink","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{max w w₂, max w' w₂', v, u} C\ninst✝ : CategoryTheory.AB5OfSize.{max w w₂, max w' w₂', v, u} C\n⊢ CategoryTheory.AB5OfSize.{w, w', v, u} C","decl":"lemma AB5OfSize_shrink [HasFilteredColimitsOfSize.{max w w₂, max w' w₂'} C]\n    [AB5OfSize.{max w w₂, max w' w₂'} C] :\n    haveI : HasFilteredColimitsOfSize.{w, w'} C := hasFilteredColimitsOfSize_shrink\n    AB5OfSize.{w, w'} C :=\n  AB5OfSize_of_univLE C\n\n"}
{"name":"CategoryTheory.AB5StarOfSize.ofShape","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w, w', v, u} C\nself : CategoryTheory.AB5StarOfSize.{w, w', v, u} C\nJ : Type w'\ninst✝¹ : CategoryTheory.Category.{w, w'} J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ CategoryTheory.HasExactLimitsOfShape J C","decl":"/--\nA category `C` which has cofiltered limits is said to have `AB5Star` (in literature `AB5*`)\nprovided that cofiltered limits are exact.\n-/\n@[pp_with_univ, stacks 079B]\nclass AB5StarOfSize [HasCofilteredLimitsOfSize.{w, w'} C] where\n  ofShape (J : Type w') [Category.{w} J] [IsCofiltered J] : HasExactLimitsOfShape J C\n\n"}
{"name":"CategoryTheory.AB5StarOfSize_of_univLE","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w₂, w₂', v, u} C\ninst✝² : UnivLE.{w, w₂}\ninst✝¹ : UnivLE.{w', w₂'}\ninst✝ : CategoryTheory.AB5StarOfSize.{w₂, w₂', v, u} C\n⊢ CategoryTheory.AB5StarOfSize.{w, w', v, u} C","decl":"lemma AB5StarOfSize_of_univLE [HasCofilteredLimitsOfSize.{w₂, w₂'} C] [UnivLE.{w, w₂}]\n    [UnivLE.{w', w₂'}] [AB5StarOfSize.{w₂, w₂'} C] :\n    haveI : HasCofilteredLimitsOfSize.{w, w'} C := hasCofilteredLimitsOfSize_of_univLE.{w}\n    AB5StarOfSize.{w, w'} C := by\n  haveI : HasCofilteredLimitsOfSize.{w, w'} C := hasCofilteredLimitsOfSize_of_univLE.{w}\n  constructor\n  intro J _ _\n  haveI := IsCofiltered.of_equivalence ((ShrinkHoms.equivalence.{w₂} J).trans <|\n    Shrink.equivalence.{w₂'} (ShrinkHoms.{w'} J))\n  exact HasExactLimitsOfShape.of_domain_equivalence _ ((ShrinkHoms.equivalence.{w₂} J).trans <|\n    Shrink.equivalence.{w₂'} (ShrinkHoms.{w'} J)).symm\n\n"}
{"name":"CategoryTheory.AB5StarOfSize_shrink","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{max w w₂, max w' w₂', v, u} C\ninst✝ : CategoryTheory.AB5StarOfSize.{max w w₂, max w' w₂', v, u} C\n⊢ CategoryTheory.AB5StarOfSize.{w, w', v, u} C","decl":"lemma AB5StarOfSize_shrink [HasCofilteredLimitsOfSize.{max w w₂, max w' w₂'} C]\n    [AB5StarOfSize.{max w w₂, max w' w₂'} C] :\n    haveI : HasCofilteredLimitsOfSize.{w, w'} C := hasCofilteredLimitsOfSize_shrink\n    AB5StarOfSize.{w, w'} C :=\n  AB5StarOfSize_of_univLE C\n\n"}
{"name":"CategoryTheory.hasExactColimitsOfShape_of_final","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\ninst✝⁶ : CategoryTheory.Limits.HasFiniteLimits C\nJ : Type u_1\nJ' : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} J'\nF : CategoryTheory.Functor J J'\ninst✝³ : F.Final\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape J' C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.HasExactColimitsOfShape J C\n⊢ CategoryTheory.HasExactColimitsOfShape J' C","decl":"/-- `HasExactColimitsOfShape` can be \"pushed forward\" along final functors -/\nlemma hasExactColimitsOfShape_of_final [HasFiniteLimits C] {J J' : Type*} [Category J] [Category J']\n    (F : J ⥤ J') [F.Final] [HasColimitsOfShape J' C] [HasColimitsOfShape J C]\n    [HasExactColimitsOfShape J C] : HasExactColimitsOfShape J' C where\n  preservesFiniteLimits :=\n    letI : PreservesFiniteLimits ((whiskeringLeft J J' C).obj F) := ⟨fun _ ↦ inferInstance⟩\n    letI := comp_preservesFiniteLimits ((whiskeringLeft J J' C).obj F) colim\n    preservesFiniteLimits_of_natIso (Functor.Final.colimIso F)\n\n"}
{"name":"CategoryTheory.hasExactLimitsOfShape_of_initial","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\ninst✝⁶ : CategoryTheory.Limits.HasFiniteColimits C\nJ : Type u_1\nJ' : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_4, u_2} J'\nF : CategoryTheory.Functor J J'\ninst✝³ : F.Initial\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape J' C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.HasExactLimitsOfShape J C\n⊢ CategoryTheory.HasExactLimitsOfShape J' C","decl":"/-- `HasExactLimitsOfShape` can be \"pushed forward\" along initial functors -/\nlemma hasExactLimitsOfShape_of_initial [HasFiniteColimits C] {J J' : Type*} [Category J]\n    [Category J'] (F : J ⥤ J') [F.Initial]  [HasLimitsOfShape J' C] [HasLimitsOfShape J C]\n    [HasExactLimitsOfShape J C] : HasExactLimitsOfShape J' C where\n  preservesFiniteColimits :=\n    letI : PreservesFiniteColimits ((whiskeringLeft J J' C).obj F) := ⟨fun _ ↦ inferInstance⟩\n    letI := comp_preservesFiniteColimits ((whiskeringLeft J J' C).obj F) lim\n    preservesFiniteColimits_of_natIso (Functor.Initial.limIso F)\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_liftToFinset","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : CategoryTheory.Limits.HasFiniteLimits C\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.Limits.CoproductsFromFiniteFiltered.liftToFinset C α)","decl":"instance preservesFiniteLimits_liftToFinset : PreservesFiniteLimits (liftToFinset C α) :=\n  preservesFiniteLimits_of_evaluation _ fun I =>\n    letI : PreservesFiniteLimits (colim (J := Discrete I) (C := C)) :=\n      preservesFiniteLimits_of_natIso HasBiproductsOfShape.colimIsoLim.symm\n    letI : PreservesFiniteLimits ((whiskeringLeft (Discrete I) (Discrete α) C).obj\n        (Discrete.functor fun x ↦ ↑x)) :=\n      ⟨fun J _ _ => whiskeringLeft_preservesLimitsOfShape J _⟩\n    letI : PreservesFiniteLimits ((whiskeringLeft (Discrete I) (Discrete α) C).obj\n        (Discrete.functor (·.val)) ⋙ colim) :=\n      comp_preservesFiniteLimits _ _\n    preservesFiniteLimits_of_natIso (liftToFinsetEvaluationIso I).symm\n\n"}
{"name":"CategoryTheory.hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝³ : CategoryTheory.Limits.HasFiniteLimits C\nJ : Type u_1\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete J) C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Finset (CategoryTheory.Discrete J)) C\ninst✝ : CategoryTheory.HasExactColimitsOfShape (Finset (CategoryTheory.Discrete J)) C\n⊢ CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete J) C","decl":"/--\n`HasExactColimitsOfShape (Finset (Discrete J)) C` implies `HasExactColimitsOfShape (Discrete J) C`\n-/\nlemma hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete\n    [HasColimitsOfShape (Discrete J) C] [HasColimitsOfShape (Finset (Discrete J)) C]\n    [HasExactColimitsOfShape (Finset (Discrete J)) C] : HasExactColimitsOfShape (Discrete J) C where\n  preservesFiniteLimits :=\n    letI : PreservesFiniteLimits (liftToFinset C J ⋙ colim) :=\n      comp_preservesFiniteLimits _ _\n    preservesFiniteLimits_of_natIso (liftToFinsetColimIso)\n\n"}
{"name":"CategoryTheory.AB4.of_AB5","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝² : CategoryTheory.Limits.HasFiniteLimits C\ninst✝¹ : CategoryTheory.Limits.HasFilteredColimitsOfSize.{w, w, v, u} C\ninst✝ : CategoryTheory.AB5OfSize.{w, w, v, u} C\n⊢ CategoryTheory.AB4OfSize.{w, v, u} C","decl":"attribute [local instance] hasCoproducts_of_finite_and_filtered in\n/-- A category with finite biproducts and finite limits is AB4 if it is AB5. -/\nlemma AB4.of_AB5 [HasFilteredColimitsOfSize.{w, w} C]\n    [AB5OfSize.{w, w} C] : AB4OfSize.{w} C where\n  ofShape _ := hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete _ _\n\n"}
{"name":"CategoryTheory.CountableAB4.of_countableAB5","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝³ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape Nat C\ninst✝¹ : CategoryTheory.HasExactColimitsOfShape Nat C\ninst✝ : CategoryTheory.Limits.HasCountableCoproducts C\n⊢ CategoryTheory.CountableAB4 C","decl":"/--\nA category with finite biproducts and finite limits has countable AB4 if sequential colimits are\nexact.\n-/\nlemma CountableAB4.of_countableAB5 [HasColimitsOfShape ℕ C] [HasExactColimitsOfShape ℕ C]\n    [HasCountableCoproducts C] : CountableAB4 C where\n  ofShape J :=\n    have : HasColimitsOfShape (Finset (Discrete J)) C :=\n      Functor.Final.hasColimitsOfShape_of_final\n        (IsFiltered.sequentialFunctor (Finset (Discrete J)))\n    have := hasExactColimitsOfShape_of_final C (IsFiltered.sequentialFunctor (Finset (Discrete J)))\n    hasExactColimitsOfShape_discrete_of_hasExactColimitsOfShape_finset_discrete _ _\n\n"}
{"name":"CategoryTheory.preservesFiniteColimits_liftToFinset","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nα : Type w\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\n⊢ CategoryTheory.Limits.PreservesFiniteColimits (CategoryTheory.Limits.ProductsFromFiniteCofiltered.liftToFinset C α)","decl":"instance preservesFiniteColimits_liftToFinset : PreservesFiniteColimits (liftToFinset C α) :=\n  preservesFiniteColimits_of_evaluation _ fun ⟨I⟩ =>\n    letI : PreservesFiniteColimits (lim (J := Discrete I) (C := C)) :=\n      preservesFiniteColimits_of_natIso HasBiproductsOfShape.colimIsoLim\n    letI : PreservesFiniteColimits ((whiskeringLeft (Discrete I) (Discrete α) C).obj\n        (Discrete.functor fun x ↦ ↑x)) := ⟨fun _ _ _ => inferInstance⟩\n    letI : PreservesFiniteColimits ((whiskeringLeft (Discrete I) (Discrete α) C).obj\n        (Discrete.functor (·.val)) ⋙ lim) :=\n      comp_preservesFiniteColimits _ _\n    preservesFiniteColimits_of_natIso (liftToFinsetEvaluationIso _ _ I).symm\n\n"}
{"name":"CategoryTheory.hasExactLimitsOfShape_discrete_of_hasExactLimitsOfShape_finset_discrete_op","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝³ : CategoryTheory.Limits.HasFiniteColimits C\nJ : Type u_1\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Discrete J) C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (Opposite (Finset (CategoryTheory.Discrete J))) C\ninst✝ : CategoryTheory.HasExactLimitsOfShape (Opposite (Finset (CategoryTheory.Discrete J))) C\n⊢ CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete J) C","decl":"/--\n`HasExactLimitsOfShape (Finset (Discrete J))ᵒᵖ C` implies  `HasExactLimitsOfShape (Discrete J) C`\n-/\nlemma hasExactLimitsOfShape_discrete_of_hasExactLimitsOfShape_finset_discrete_op\n    [HasLimitsOfShape (Discrete J) C] [HasLimitsOfShape (Finset (Discrete J))ᵒᵖ C]\n    [HasExactLimitsOfShape (Finset (Discrete J))ᵒᵖ C] :\n    HasExactLimitsOfShape (Discrete J) C where\n  preservesFiniteColimits :=\n    letI : PreservesFiniteColimits (ProductsFromFiniteCofiltered.liftToFinset C J ⋙ lim) :=\n      comp_preservesFiniteColimits _ _\n    preservesFiniteColimits_of_natIso (ProductsFromFiniteCofiltered.liftToFinsetLimIso _ _)\n\n"}
{"name":"CategoryTheory.AB4Star.of_AB5Star","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝² : CategoryTheory.Limits.HasFiniteColimits C\ninst✝¹ : CategoryTheory.Limits.HasCofilteredLimitsOfSize.{w, w, v, u} C\ninst✝ : CategoryTheory.AB5StarOfSize.{w, w, v, u} C\n⊢ CategoryTheory.AB4StarOfSize.{w, v, u} C","decl":"attribute [local instance] hasProducts_of_finite_and_cofiltered in\n/-- A category with finite biproducts and finite limits is AB4 if it is AB5. -/\nlemma AB4Star.of_AB5Star [HasCofilteredLimitsOfSize.{w, w} C] [AB5StarOfSize.{w, w} C] :\n    AB4StarOfSize.{w} C where\n  ofShape _ := hasExactLimitsOfShape_discrete_of_hasExactLimitsOfShape_finset_discrete_op _ _\n\n"}
{"name":"CategoryTheory.CountableAB4Star.of_countableAB5Star","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝³ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (Opposite Nat) C\ninst✝¹ : CategoryTheory.HasExactLimitsOfShape (Opposite Nat) C\ninst✝ : CategoryTheory.Limits.HasCountableProducts C\n⊢ CategoryTheory.CountableAB4Star C","decl":"/--\nA category with finite biproducts and finite limits has countable AB4* if sequential limits are\nexact.\n-/\nlemma CountableAB4Star.of_countableAB5Star [HasLimitsOfShape ℕᵒᵖ C] [HasExactLimitsOfShape ℕᵒᵖ C]\n    [HasCountableProducts C] : CountableAB4Star C where\n  ofShape J :=\n    have : HasLimitsOfShape (Finset (Discrete J))ᵒᵖ C :=\n      Functor.Initial.hasLimitsOfShape_of_initial\n        (IsFiltered.sequentialFunctor (Finset (Discrete J))).op\n    have := hasExactLimitsOfShape_of_initial C\n      (IsFiltered.sequentialFunctor (Finset (Discrete J))).op\n    hasExactLimitsOfShape_discrete_of_hasExactLimitsOfShape_finset_discrete_op _ _\n\n"}
{"name":"CategoryTheory.CountableAB4.of_hasExactColimitsOfShape_nat_and_finite","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasCountableCoproducts C\ninst✝² : CategoryTheory.Limits.HasFiniteLimits C\ninst✝¹ : ∀ (J : Type) [inst : Finite J], CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete J) C\ninst✝ : CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete Nat) C\n⊢ CategoryTheory.CountableAB4 C","decl":"/--\nChecking exactness of colimits of shape `Discrete ℕ` and `Discrete J` for finite `J` is enough for\ncountable AB4.\n-/\nlemma CountableAB4.of_hasExactColimitsOfShape_nat_and_finite [HasCountableCoproducts C]\n    [HasFiniteLimits C] [∀ (J : Type) [Finite J], HasExactColimitsOfShape (Discrete J) C]\n    [HasExactColimitsOfShape (Discrete ℕ) C] :\n    CountableAB4 C where\n  ofShape J := by\n    by_cases h : Finite J\n    · infer_instance\n    · have : Infinite J := ⟨h⟩\n      let _ := Encodable.ofCountable J\n      let _ := Denumerable.ofEncodableOfInfinite J\n      exact hasExactColimitsOfShape_of_final C (Discrete.equivalence (Denumerable.eqv J)).inverse\n\n"}
{"name":"CategoryTheory.CountableAB4Star.of_hasExactLimitsOfShape_nat_and_finite","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasCountableProducts C\ninst✝² : CategoryTheory.Limits.HasFiniteColimits C\ninst✝¹ : ∀ (J : Type) [inst : Finite J], CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete J) C\ninst✝ : CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete Nat) C\n⊢ CategoryTheory.CountableAB4Star C","decl":"/--\nChecking exactness of limits of shape `Discrete ℕ` and `Discrete J` for finite `J` is enough for\ncountable AB4*.\n-/\nlemma CountableAB4Star.of_hasExactLimitsOfShape_nat_and_finite [HasCountableProducts C]\n    [HasFiniteColimits C] [∀ (J : Type) [Finite J], HasExactLimitsOfShape (Discrete J) C]\n    [HasExactLimitsOfShape (Discrete ℕ) C] :\n    CountableAB4Star C where\n  ofShape J := by\n    by_cases h : Finite J\n    · infer_instance\n    · have : Infinite J := ⟨h⟩\n      let _ := Encodable.ofCountable J\n      let _ := Denumerable.ofEncodableOfInfinite J\n      exact hasExactLimitsOfShape_of_initial C (Discrete.equivalence (Denumerable.eqv J)).inverse\n\n"}
{"name":"CategoryTheory.hasExactColimitsOfShape_discrete_finite","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type u_1\ninst✝ : Finite J\n⊢ CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete J) C","decl":"noncomputable instance hasExactColimitsOfShape_discrete_finite (J : Type*) [Finite J] :\n    HasExactColimitsOfShape (Discrete J) C where\n  preservesFiniteLimits := preservesFiniteLimits_of_natIso HasBiproductsOfShape.colimIsoLim.symm\n\n"}
{"name":"CategoryTheory.hasExactLimitsOfShape_discrete_finite","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type u_1\ninst✝ : Finite J\n⊢ CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete J) C","decl":"noncomputable instance hasExactLimitsOfShape_discrete_finite {J : Type*} [Finite J] :\n    HasExactLimitsOfShape (Discrete J) C where\n  preservesFiniteColimits := preservesFiniteColimits_of_natIso HasBiproductsOfShape.colimIsoLim\n\n"}
{"name":"CategoryTheory.CountableAB4.of_hasExactColimitsOfShape_nat","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝² : CategoryTheory.Limits.HasFiniteLimits C\ninst✝¹ : CategoryTheory.Limits.HasCountableCoproducts C\ninst✝ : CategoryTheory.HasExactColimitsOfShape (CategoryTheory.Discrete Nat) C\n⊢ CategoryTheory.CountableAB4 C","decl":"/--\nChecking AB of shape `Discrete ℕ` is enough for countable AB4, provided that the category has\nfinite biproducts and finite limits.\n-/\nlemma CountableAB4.of_hasExactColimitsOfShape_nat [HasFiniteLimits C] [HasCountableCoproducts C]\n    [HasExactColimitsOfShape (Discrete ℕ) C] : CountableAB4 C := by\n  apply (config := { allowSynthFailures := true })\n      CountableAB4.of_hasExactColimitsOfShape_nat_and_finite\n  exact fun _ ↦ inferInstance\n\n"}
{"name":"CategoryTheory.CountableAB4Star.of_hasExactLimitsOfShape_nat","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝² : CategoryTheory.Limits.HasFiniteColimits C\ninst✝¹ : CategoryTheory.Limits.HasCountableProducts C\ninst✝ : CategoryTheory.HasExactLimitsOfShape (CategoryTheory.Discrete Nat) C\n⊢ CategoryTheory.CountableAB4Star C","decl":"/--\nChecking AB* of shape `Discrete ℕ` is enough for countable AB4*, provided that the category has\nfinite biproducts and finite colimits.\n-/\nlemma CountableAB4Star.of_hasExactLimitsOfShape_nat [HasFiniteColimits C]\n    [HasCountableProducts C] [HasExactLimitsOfShape (Discrete ℕ) C] : CountableAB4Star C := by\n  apply (config := { allowSynthFailures := true })\n      CountableAB4Star.of_hasExactLimitsOfShape_nat_and_finite\n  exact fun _ ↦ inferInstance\n\n"}
{"name":"CategoryTheory.hasExactColimitsOfShape_of_preservesMono","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Abelian C\nJ : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝ : CategoryTheory.Limits.colim.PreservesMonomorphisms\n⊢ CategoryTheory.HasExactColimitsOfShape J C","decl":"/--\nIf `colim` of shape `J` into an abelian category `C` preserves monomorphisms, then `C` has AB of\nshape `J`.\n-/\nlemma hasExactColimitsOfShape_of_preservesMono [HasColimitsOfShape J C]\n    [PreservesMonomorphisms (colim (J := J) (C := C))] : HasExactColimitsOfShape J C where\n  preservesFiniteLimits := by\n    apply (config := { allowSynthFailures := true }) preservesFiniteLimits_of_preservesHomology\n    · exact preservesHomology_of_preservesMonos_and_cokernels _\n    · exact additive_of_preservesBinaryBiproducts _\n\n"}
{"name":"CategoryTheory.hasExactLimitsOfShape_of_preservesEpi","module":"Mathlib.CategoryTheory.Abelian.GrothendieckAxioms.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Abelian C\nJ : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} J\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝ : CategoryTheory.Limits.lim.PreservesEpimorphisms\n⊢ CategoryTheory.HasExactLimitsOfShape J C","decl":"/--\nIf `lim` of shape `J` into an abelian category `C` preserves epimorphisms, then `C` has AB* of\nshape `J`.\n-/\nlemma hasExactLimitsOfShape_of_preservesEpi [HasLimitsOfShape J C]\n    [PreservesEpimorphisms (lim (J := J) (C := C))] : HasExactLimitsOfShape J C where\n  preservesFiniteColimits := by\n    apply (config := { allowSynthFailures := true }) preservesFiniteColimits_of_preservesHomology\n    · exact preservesHomology_of_preservesEpis_and_kernels _\n    · exact additive_of_preservesBinaryBiproducts _\n\n"}
