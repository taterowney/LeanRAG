{"name":"Algebra.discr_def","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nι : Type w\ninst✝⁴ : DecidableEq ι\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Fintype ι\nb : ι → B\n⊢ Eq (Algebra.discr A b) (Algebra.traceMatrix A b).det","decl":"theorem discr_def [Fintype ι] (b : ι → B) : discr A b = (traceMatrix A b).det := rfl\n\n"}
{"name":"Algebra.discr_eq_discr_of_algEquiv","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nC : Type z\nι : Type w\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra A B\ninst✝² : CommRing C\ninst✝¹ : Algebra A C\ninst✝ : Fintype ι\nb : ι → B\nf : AlgEquiv A B C\n⊢ Eq (Algebra.discr A b) (Algebra.discr A (Function.comp (⇑f) b))","decl":"variable {A C} in\n/-- Mapping a family of vectors along an `AlgEquiv` preserves the discriminant. -/\ntheorem discr_eq_discr_of_algEquiv [Fintype ι] (b : ι → B) (f : B ≃ₐ[A] C) :\n    Algebra.discr A b = Algebra.discr A (f ∘ b) := by\n  rw [discr_def]; congr; ext\n  simp_rw [traceMatrix_apply, traceForm_apply, Function.comp, ← map_mul f, trace_eq_of_algEquiv]\n\n"}
{"name":"Algebra.discr_reindex","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nι : Type w\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra A B\nι' : Type u_1\ninst✝² : Fintype ι'\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι'\nb : Basis ι A B\nf : Equiv ι ι'\n⊢ Eq (Algebra.discr A (Function.comp ⇑b ⇑f.symm)) (Algebra.discr A ⇑b)","decl":"@[simp]\ntheorem discr_reindex (b : Basis ι A B) (f : ι ≃ ι') : discr A (b ∘ ⇑f.symm) = discr A b := by\n  classical rw [← Basis.coe_reindex, discr_def, traceMatrix_reindex, det_reindex_self, ← discr_def]\n\n"}
{"name":"Algebra.discr_zero_of_not_linearIndependent","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nι : Type w\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Fintype ι\ninst✝ : IsDomain A\nb : ι → B\nhli : Not (LinearIndependent A b)\n⊢ Eq (Algebra.discr A b) 0","decl":"/-- If `b` is not linear independent, then `Algebra.discr A b = 0`. -/\ntheorem discr_zero_of_not_linearIndependent [IsDomain A] {b : ι → B}\n    (hli : ¬LinearIndependent A b) : discr A b = 0 := by\n  classical\n  obtain ⟨g, hg, i, hi⟩ := Fintype.not_linearIndependent_iff.1 hli\n  have : (traceMatrix A b) *ᵥ g = 0 := by\n    ext i\n    have : ∀ j, (trace A B) (b i * b j) * g j = (trace A B) (g j • b j * b i) := by\n      intro j\n      simp [mul_comm]\n    simp only [mulVec, dotProduct, traceMatrix_apply, Pi.zero_apply, traceForm_apply, fun j =>\n      this j, ← map_sum, ← sum_mul, hg, zero_mul, LinearMap.map_zero]\n  by_contra h\n  rw [discr_def] at h\n  simp [Matrix.eq_zero_of_mulVec_eq_zero h this] at hi\n\n"}
{"name":"Algebra.discr_of_matrix_vecMul","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nι : Type w\ninst✝⁴ : DecidableEq ι\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Fintype ι\nb : ι → B\nP : Matrix ι ι A\n⊢ Eq (Algebra.discr A (Matrix.vecMul b (P.map ⇑(algebraMap A B)))) (HMul.hMul (HPow.hPow P.det 2) (Algebra.discr A b))","decl":"/-- Relation between `Algebra.discr A ι b` and\n`Algebra.discr A (b ᵥ* P.map (algebraMap A B))`. -/\ntheorem discr_of_matrix_vecMul (b : ι → B) (P : Matrix ι ι A) :\n    discr A (b ᵥ* P.map (algebraMap A B)) = P.det ^ 2 * discr A b := by\n  rw [discr_def, traceMatrix_of_matrix_vecMul, det_mul, det_mul, det_transpose, mul_comm, ←\n    mul_assoc, discr_def, pow_two]\n\n"}
{"name":"Algebra.discr_of_matrix_mulVec","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nB : Type v\nι : Type w\ninst✝⁴ : DecidableEq ι\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Fintype ι\nb : ι → B\nP : Matrix ι ι A\n⊢ Eq (Algebra.discr A ((P.map ⇑(algebraMap A B)).mulVec b)) (HMul.hMul (HPow.hPow P.det 2) (Algebra.discr A b))","decl":"/-- Relation between `Algebra.discr A ι b` and\n`Algebra.discr A ((P.map (algebraMap A B)) *ᵥ b)`. -/\ntheorem discr_of_matrix_mulVec (b : ι → B) (P : Matrix ι ι A) :\n    discr A (P.map (algebraMap A B) *ᵥ b) = P.det ^ 2 * discr A b := by\n  rw [discr_def, traceMatrix_of_matrix_mulVec, det_mul, det_mul, det_transpose, mul_comm, ←\n    mul_assoc, discr_def, pow_two]\n\n"}
{"name":"Algebra.discr_not_zero_of_basis","module":"Mathlib.RingTheory.Discriminant","initialProofState":"ι : Type w\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\nK : Type u\nL : Type v\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Module.Finite K L\ninst✝ : Algebra.IsSeparable K L\nb : Basis ι K L\n⊢ Ne (Algebra.discr K ⇑b) 0","decl":"/-- If `b` is a basis of a finite separable field extension `L/K`, then `Algebra.discr K b ≠ 0`. -/\ntheorem discr_not_zero_of_basis [Algebra.IsSeparable K L] (b : Basis ι K L) :\n    discr K b ≠ 0 := by\n  rw [discr_def, traceMatrix_of_basis, ← LinearMap.BilinForm.nondegenerate_iff_det_ne_zero]\n  exact traceForm_nondegenerate _ _\n\n"}
{"name":"Algebra.discr_isUnit_of_basis","module":"Mathlib.RingTheory.Discriminant","initialProofState":"ι : Type w\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Fintype ι\nK : Type u\nL : Type v\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Module.Finite K L\ninst✝ : Algebra.IsSeparable K L\nb : Basis ι K L\n⊢ IsUnit (Algebra.discr K ⇑b)","decl":"/-- If `b` is a basis of a finite separable field extension `L/K`,\n  then `Algebra.discr K b` is a unit. -/\ntheorem discr_isUnit_of_basis [Algebra.IsSeparable K L] (b : Basis ι K L) : IsUnit (discr K b) :=\n  IsUnit.mk0 _ (discr_not_zero_of_basis _ _)\n\n"}
{"name":"Algebra.discr_eq_det_embeddingsMatrixReindex_pow_two","module":"Mathlib.RingTheory.Discriminant","initialProofState":"ι : Type w\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : Fintype ι\nK : Type u\nL : Type v\nE : Type z\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Field E\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra K E\ninst✝² : Module.Finite K L\ninst✝¹ : IsAlgClosed E\nb : ι → L\ninst✝ : Algebra.IsSeparable K L\ne : Equiv ι (AlgHom K L E)\n⊢ Eq ((algebraMap K E) (Algebra.discr K b)) (HPow.hPow (Algebra.embeddingsMatrixReindex K E b e).det 2)","decl":"/-- If `L/K` is a field extension and `b : ι → L`, then `discr K b` is the square of the\ndeterminant of the matrix whose `(i, j)` coefficient is `σⱼ (b i)`, where `σⱼ : L →ₐ[K] E` is the\nembedding in an algebraically closed field `E` corresponding to `j : ι` via a bijection\n`e : ι ≃ (L →ₐ[K] E)`. -/\ntheorem discr_eq_det_embeddingsMatrixReindex_pow_two\n    [Algebra.IsSeparable K L] (e : ι ≃ (L →ₐ[K] E)) :\n    algebraMap K E (discr K b) = (embeddingsMatrixReindex K E b e).det ^ 2 := by\n  rw [discr_def, RingHom.map_det, RingHom.mapMatrix_apply,\n    traceMatrix_eq_embeddingsMatrixReindex_mul_trans, det_mul, det_transpose, pow_two]\n\n"}
{"name":"Algebra.discr_powerBasis_eq_prod","module":"Mathlib.RingTheory.Discriminant","initialProofState":"K : Type u\nL : Type v\nE : Type z\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Field E\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra K E\ninst✝² : Module.Finite K L\ninst✝¹ : IsAlgClosed E\npb : PowerBasis K L\ne : Equiv (Fin pb.dim) (AlgHom K L E)\ninst✝ : Algebra.IsSeparable K L\n⊢ Eq ((algebraMap K E) (Algebra.discr K ⇑pb.basis)) (Finset.univ.prod fun i => (Finset.Ioi i).prod fun j => HPow.hPow (HSub.hSub ((e j) pb.gen) ((e i) pb.gen)) 2)","decl":"/-- The discriminant of a power basis. -/\ntheorem discr_powerBasis_eq_prod (e : Fin pb.dim ≃ (L →ₐ[K] E)) [Algebra.IsSeparable K L] :\n    algebraMap K E (discr K pb.basis) =\n      ∏ i : Fin pb.dim, ∏ j ∈ Ioi i, (e j pb.gen - e i pb.gen) ^ 2 := by\n  rw [discr_eq_det_embeddingsMatrixReindex_pow_two K E pb.basis e,\n    embeddingsMatrixReindex_eq_vandermonde, det_transpose, det_vandermonde, ← prod_pow]\n  congr; ext i\n  rw [← prod_pow]\n\n"}
{"name":"Algebra.discr_powerBasis_eq_prod'","module":"Mathlib.RingTheory.Discriminant","initialProofState":"K : Type u\nL : Type v\nE : Type z\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Field E\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra K E\ninst✝² : Module.Finite K L\ninst✝¹ : IsAlgClosed E\npb : PowerBasis K L\ninst✝ : Algebra.IsSeparable K L\ne : Equiv (Fin pb.dim) (AlgHom K L E)\n⊢ Eq ((algebraMap K E) (Algebra.discr K ⇑pb.basis)) (Finset.univ.prod fun i => (Finset.Ioi i).prod fun j => Neg.neg (HMul.hMul (HSub.hSub ((e j) pb.gen) ((e i) pb.gen)) (HSub.hSub ((e i) pb.gen) ((e j) pb.gen))))","decl":"/-- A variation of `Algebra.discr_powerBasis_eq_prod`. -/\ntheorem discr_powerBasis_eq_prod' [Algebra.IsSeparable K L] (e : Fin pb.dim ≃ (L →ₐ[K] E)) :\n    algebraMap K E (discr K pb.basis) =\n      ∏ i : Fin pb.dim, ∏ j ∈ Ioi i, -((e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen)) := by\n  rw [discr_powerBasis_eq_prod _ _ _ e]\n  congr; ext i; congr; ext j\n  ring\n\n"}
{"name":"Algebra.discr_powerBasis_eq_prod''","module":"Mathlib.RingTheory.Discriminant","initialProofState":"K : Type u\nL : Type v\nE : Type z\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Field E\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra K E\ninst✝² : Module.Finite K L\ninst✝¹ : IsAlgClosed E\npb : PowerBasis K L\ninst✝ : Algebra.IsSeparable K L\ne : Equiv (Fin pb.dim) (AlgHom K L E)\n⊢ Eq ((algebraMap K E) (Algebra.discr K ⇑pb.basis)) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HMul.hMul (Module.finrank K L) (HSub.hSub (Module.finrank K L) 1)) 2)) (Finset.univ.prod fun i => (Finset.Ioi i).prod fun j => HMul.hMul (HSub.hSub ((e j) pb.gen) ((e i) pb.gen)) (HSub.hSub ((e i) pb.gen) ((e j) pb.gen))))","decl":"/-- A variation of `Algebra.discr_powerBasis_eq_prod`. -/\ntheorem discr_powerBasis_eq_prod'' [Algebra.IsSeparable K L] (e : Fin pb.dim ≃ (L →ₐ[K] E)) :\n    algebraMap K E (discr K pb.basis) =\n      (-1) ^ (n * (n - 1) / 2) *\n        ∏ i : Fin pb.dim, ∏ j ∈ Ioi i, (e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen) := by\n  rw [discr_powerBasis_eq_prod' _ _ _ e]\n  simp_rw [fun i j => neg_eq_neg_one_mul ((e j pb.gen - e i pb.gen) * (e i pb.gen - e j pb.gen)),\n    prod_mul_distrib]\n  congr\n  simp only [prod_pow_eq_pow_sum, prod_const]\n  congr\n  rw [← @Nat.cast_inj ℚ, Nat.cast_sum]\n  have : ∀ x : Fin pb.dim, ↑x + 1 ≤ pb.dim := by simp [Nat.succ_le_iff, Fin.is_lt]\n  simp_rw [Fin.card_Ioi, Nat.sub_sub, add_comm 1]\n  simp only [Nat.cast_sub, this, Finset.card_fin, nsmul_eq_mul, sum_const, sum_sub_distrib,\n    Nat.cast_add, Nat.cast_one, sum_add_distrib, mul_one]\n  rw [← Nat.cast_sum, ← @Finset.sum_range ℕ _ pb.dim fun i => i, sum_range_id]\n  have hn : n = pb.dim := by\n    rw [← AlgHom.card K L E, ← Fintype.card_fin pb.dim]\n    -- FIXME: Without the `Fintype` namespace, why does it complain about `Finset.card_congr` being\n    -- deprecated?\n    exact Fintype.card_congr e.symm\n  have h₂ : 2 ∣ pb.dim * (pb.dim - 1) := pb.dim.even_mul_pred_self.two_dvd\n  have hne : ((2 : ℕ) : ℚ) ≠ 0 := by simp\n  have hle : 1 ≤ pb.dim := by\n    rw [← hn, Nat.one_le_iff_ne_zero, ← zero_lt_iff, Module.finrank_pos_iff]\n    infer_instance\n  rw [hn, Nat.cast_div h₂ hne, Nat.cast_mul, Nat.cast_sub hle]\n  field_simp\n  ring\n\n"}
{"name":"Algebra.discr_powerBasis_eq_norm","module":"Mathlib.RingTheory.Discriminant","initialProofState":"K : Type u\nL : Type v\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Module.Finite K L\npb : PowerBasis K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Eq (Algebra.discr K ⇑pb.basis) (HMul.hMul (HPow.hPow (-1) (HDiv.hDiv (HMul.hMul (Module.finrank K L) (HSub.hSub (Module.finrank K L) 1)) 2)) ((Algebra.norm K) ((Polynomial.aeval pb.gen) (Polynomial.derivative (minpoly K pb.gen)))))","decl":"/-- Formula for the discriminant of a power basis using the norm of the field extension. -/\n-- Porting note: `(minpoly K pb.gen).derivative` does not work anymore.\ntheorem discr_powerBasis_eq_norm [Algebra.IsSeparable K L] :\n    discr K pb.basis =\n      (-1) ^ (n * (n - 1) / 2) *\n      norm K (aeval pb.gen (derivative (R := K) (minpoly K pb.gen))) := by\n  let E := AlgebraicClosure L\n  letI := fun a b : E => Classical.propDecidable (Eq a b)\n  have e : Fin pb.dim ≃ (L →ₐ[K] E) := by\n    refine equivOfCardEq ?_\n    rw [Fintype.card_fin, AlgHom.card]\n    exact (PowerBasis.finrank pb).symm\n  have hnodup : ((minpoly K pb.gen).aroots E).Nodup :=\n    nodup_roots (Separable.map (Algebra.IsSeparable.isSeparable K pb.gen))\n  have hroots : ∀ σ : L →ₐ[K] E, σ pb.gen ∈ (minpoly K pb.gen).aroots E := by\n    intro σ\n    rw [mem_roots, IsRoot.def, eval_map, ← aeval_def, aeval_algHom_apply]\n    repeat' simp [minpoly.ne_zero (Algebra.IsSeparable.isIntegral K pb.gen)]\n  apply (algebraMap K E).injective\n  rw [RingHom.map_mul, RingHom.map_pow, RingHom.map_neg, RingHom.map_one,\n    discr_powerBasis_eq_prod'' _ _ _ e]\n  congr\n  rw [norm_eq_prod_embeddings, prod_prod_Ioi_mul_eq_prod_prod_off_diag]\n  conv_rhs =>\n    congr\n    rfl\n    ext σ\n    rw [← aeval_algHom_apply,\n      aeval_root_derivative_of_splits (minpoly.monic (Algebra.IsSeparable.isIntegral K pb.gen))\n        (IsAlgClosed.splits_codomain _) (hroots σ),\n      ← Finset.prod_mk _ (hnodup.erase _)]\n  rw [prod_sigma', prod_sigma']\n  refine prod_bij' (fun i _ ↦ ⟨e i.2, e i.1 pb.gen⟩)\n    (fun σ hσ ↦ ⟨e.symm (PowerBasis.lift pb σ.2 ?_), e.symm σ.1⟩) ?_ ?_ ?_ ?_ (fun i _ ↦ by simp)\n  -- Porting note: `@mem_compl` was not necessary.\n    <;> simp only [mem_sigma, mem_univ, Finset.mem_mk, hnodup.mem_erase_iff, IsRoot.def,\n      mem_roots', minpoly.ne_zero (Algebra.IsSeparable.isIntegral K pb.gen), not_false_eq_true,\n      mem_singleton, true_and, @mem_compl _ _ _ (_), Sigma.forall, Equiv.apply_symm_apply,\n      PowerBasis.lift_gen, and_imp, implies_true, forall_const, Equiv.symm_apply_apply,\n      Sigma.ext_iff, Equiv.symm_apply_eq, heq_eq_eq, and_true] at *\n  · simpa only [aeval_def, eval₂_eq_eval_map] using hσ.2.2\n  · exact fun a b hba ↦ ⟨fun h ↦ hba <| e.injective <| pb.algHom_ext h.symm, hroots _⟩\n  · rintro a b hba ha\n    rw [ha, PowerBasis.lift_gen] at hba\n    exact hba.1 rfl\n  · exact fun a b _ ↦ pb.algHom_ext <| pb.lift_gen _ _\n\n"}
{"name":"Algebra.discr_isIntegral","module":"Mathlib.RingTheory.Discriminant","initialProofState":"ι : Type w\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : Fintype ι\nK : Type u\nL : Type v\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Module.Finite K L\nR : Type z\ninst✝³ : CommRing R\ninst✝² : Algebra R K\ninst✝¹ : Algebra R L\ninst✝ : IsScalarTower R K L\nb : ι → L\nh : ∀ (i : ι), IsIntegral R (b i)\n⊢ IsIntegral R (Algebra.discr K b)","decl":"/-- If `K` and `L` are fields and `IsScalarTower R K L`, and `b : ι → L` satisfies\n` ∀ i, IsIntegral R (b i)`, then `IsIntegral R (discr K b)`. -/\ntheorem discr_isIntegral {b : ι → L} (h : ∀ i, IsIntegral R (b i)) : IsIntegral R (discr K b) := by\n  classical\n  rw [discr_def]\n  exact IsIntegral.det fun i j ↦ isIntegral_trace ((h i).mul (h j))\n\n"}
{"name":"Algebra.discr_mul_isIntegral_mem_adjoin","module":"Mathlib.RingTheory.Discriminant","initialProofState":"K : Type u\nL : Type v\ninst✝¹⁰ : Field K\ninst✝⁹ : Field L\ninst✝⁸ : Algebra K L\ninst✝⁷ : Module.Finite K L\nR : Type z\ninst✝⁶ : CommRing R\ninst✝⁵ : Algebra R K\ninst✝⁴ : Algebra R L\ninst✝³ : IsScalarTower R K L\ninst✝² : Algebra.IsSeparable K L\ninst✝¹ : IsIntegrallyClosed R\ninst✝ : IsFractionRing R K\nB : PowerBasis K L\nhint : IsIntegral R B.gen\nz : L\nhz : IsIntegral R z\n⊢ Membership.mem (Algebra.adjoin R (Singleton.singleton B.gen)) (HSMul.hSMul (Algebra.discr K ⇑B.basis) z)","decl":"/-- Let `K` be the fraction field of an integrally closed domain `R` and let `L` be a finite\nseparable extension of `K`. Let `B : PowerBasis K L` be such that `IsIntegral R B.gen`.\nThen for all, `z : L` that are integral over `R`, we have\n`(discr K B.basis) • z ∈ adjoin R ({B.gen} : Set L)`. -/\ntheorem discr_mul_isIntegral_mem_adjoin [Algebra.IsSeparable K L] [IsIntegrallyClosed R]\n    [IsFractionRing R K] {B : PowerBasis K L} (hint : IsIntegral R B.gen) {z : L}\n    (hz : IsIntegral R z) : discr K B.basis • z ∈ adjoin R ({B.gen} : Set L) := by\n  have hinv : IsUnit (traceMatrix K B.basis).det := by\n    simpa [← discr_def] using discr_isUnit_of_basis _ B.basis\n  have H :\n    (traceMatrix K B.basis).det • (traceMatrix K B.basis) *ᵥ (B.basis.equivFun z) =\n      (traceMatrix K B.basis).det • fun i => trace K L (z * B.basis i) := by\n    congr; exact traceMatrix_of_basis_mulVec _ _\n  have cramer := mulVec_cramer (traceMatrix K B.basis) fun i => trace K L (z * B.basis i)\n  suffices ∀ i, ((traceMatrix K B.basis).det • B.basis.equivFun z) i ∈ (⊥ : Subalgebra R K) by\n    rw [← B.basis.sum_repr z, Finset.smul_sum]\n    refine Subalgebra.sum_mem _ fun i _ => ?_\n    replace this := this i\n    rw [← discr_def, Pi.smul_apply, mem_bot] at this\n    obtain ⟨r, hr⟩ := this\n    rw [Basis.equivFun_apply] at hr\n    rw [← smul_assoc, ← hr, algebraMap_smul]\n    refine Subalgebra.smul_mem _ ?_ _\n    rw [B.basis_eq_pow i]\n    exact Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _\n  intro i\n  rw [← H, ← mulVec_smul] at cramer\n  replace cramer := congr_arg (mulVec (traceMatrix K B.basis)⁻¹) cramer\n  rw [mulVec_mulVec, nonsing_inv_mul _ hinv, mulVec_mulVec, nonsing_inv_mul _ hinv, one_mulVec,\n    one_mulVec] at cramer\n  rw [← congr_fun cramer i, cramer_apply, det_apply]\n  refine\n    Subalgebra.sum_mem _ fun σ _ => Subalgebra.zsmul_mem _ (Subalgebra.prod_mem _ fun j _ => ?_) _\n  by_cases hji : j = i\n  · simp only [updateCol_apply, hji, eq_self_iff_true, PowerBasis.coe_basis]\n    exact mem_bot.2 (IsIntegrallyClosed.isIntegral_iff.1 <| isIntegral_trace (hz.mul <| hint.pow _))\n  · simp only [updateCol_apply, hji, PowerBasis.coe_basis]\n    exact mem_bot.2\n      (IsIntegrallyClosed.isIntegral_iff.1 <| isIntegral_trace <| (hint.pow _).mul (hint.pow _))\n\n"}
{"name":"Algebra.discr_eq_discr","module":"Mathlib.RingTheory.Discriminant","initialProofState":"A : Type u\nι : Type w\ninst✝² : DecidableEq ι\ninst✝¹ : CommRing A\ninst✝ : Fintype ι\nb b' : Basis ι Int A\n⊢ Eq (Algebra.discr Int ⇑b) (Algebra.discr Int ⇑b')","decl":"/-- Two (finite) ℤ-bases have the same discriminant. -/\ntheorem discr_eq_discr (b : Basis ι ℤ A) (b' : Basis ι ℤ A) :\n    Algebra.discr ℤ b = Algebra.discr ℤ b' := by\n  convert Algebra.discr_of_matrix_vecMul b' (b'.toMatrix b)\n  · rw [Basis.toMatrix_map_vecMul]\n  · suffices IsUnit (b'.toMatrix b).det by\n      rw [Int.isUnit_iff, ← sq_eq_one_iff] at this\n      rw [this, one_mul]\n    rw [← LinearMap.toMatrix_id_eq_basis_toMatrix b b']\n    exact LinearEquiv.isUnit_det (LinearEquiv.refl ℤ A) b b'\n\n"}
