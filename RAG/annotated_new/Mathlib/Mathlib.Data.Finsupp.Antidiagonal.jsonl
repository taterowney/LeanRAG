{"name":"Finsupp.antidiagonal_zero","module":"Mathlib.Data.Finsupp.Antidiagonal","initialProofState":"α : Type u\ninst✝ : DecidableEq α\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal 0) (Singleton.singleton { fst := 0, snd := 0 })","decl":"@[simp]\ntheorem antidiagonal_zero : antidiagonal (0 : α →₀ ℕ) = singleton (0, 0) := rfl\n\n"}
{"name":"Finsupp.sum_antidiagonal_swap","module":"Mathlib.Data.Finsupp.Antidiagonal","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\nM : Type u_1\ninst✝ : AddCommMonoid M\nn : Finsupp α Nat\nf : Finsupp α Nat → Finsupp α Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p.1 p.2) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p.2 p.1)","decl":"@[to_additive]\ntheorem prod_antidiagonal_swap {M : Type*} [CommMonoid M] (n : α →₀ ℕ)\n    (f : (α →₀ ℕ) → (α →₀ ℕ) → M) :\n    ∏ p ∈ antidiagonal n, f p.1 p.2 = ∏ p ∈ antidiagonal n, f p.2 p.1 :=\n  prod_equiv (Equiv.prodComm _ _) (by simp [add_comm]) (by simp)\n\n"}
{"name":"Finsupp.prod_antidiagonal_swap","module":"Mathlib.Data.Finsupp.Antidiagonal","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\nM : Type u_1\ninst✝ : CommMonoid M\nn : Finsupp α Nat\nf : Finsupp α Nat → Finsupp α Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p.1 p.2) ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p.2 p.1)","decl":"@[to_additive]\ntheorem prod_antidiagonal_swap {M : Type*} [CommMonoid M] (n : α →₀ ℕ)\n    (f : (α →₀ ℕ) → (α →₀ ℕ) → M) :\n    ∏ p ∈ antidiagonal n, f p.1 p.2 = ∏ p ∈ antidiagonal n, f p.2 p.1 :=\n  prod_equiv (Equiv.prodComm _ _) (by simp [add_comm]) (by simp)\n\n"}
{"name":"Finsupp.antidiagonal_single","module":"Mathlib.Data.Finsupp.Antidiagonal","initialProofState":"α : Type u\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal (Finsupp.single a n)) (Finset.map ({ toFun := Finsupp.single a, inj' := ⋯ }.prodMap { toFun := Finsupp.single a, inj' := ⋯ }) (Finset.HasAntidiagonal.antidiagonal n))","decl":"@[simp]\ntheorem antidiagonal_single (a : α) (n : ℕ) :\n    antidiagonal (single a n) = (antidiagonal n).map\n      (Function.Embedding.prodMap ⟨_, single_injective a⟩ ⟨_, single_injective a⟩) := by\n  ext ⟨x, y⟩\n  simp only [mem_antidiagonal, mem_map, mem_antidiagonal, Function.Embedding.coe_prodMap,\n    Function.Embedding.coeFn_mk, Prod.map_apply, Prod.mk.injEq, Prod.exists]\n  constructor\n  · intro h\n    refine ⟨x a, y a, DFunLike.congr_fun h a |>.trans single_eq_same, ?_⟩\n    simp_rw [DFunLike.ext_iff, ← forall_and]\n    intro i\n    replace h := DFunLike.congr_fun h i\n    simp_rw [single_apply, Finsupp.add_apply] at h ⊢\n    obtain rfl | hai := Decidable.eq_or_ne a i\n    · exact ⟨if_pos rfl, if_pos rfl⟩\n    · simp_rw [if_neg hai, add_eq_zero] at h ⊢\n      exact h.imp Eq.symm Eq.symm\n  · rintro ⟨a, b, rfl, rfl, rfl⟩\n    exact (single_add _ _ _).symm\n\n"}
