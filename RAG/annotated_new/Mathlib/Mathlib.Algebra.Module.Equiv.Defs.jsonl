{"name":"LinearEquiv.right_inv","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_12\nS : Type u_13\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁵ : RingHomInvPair σ σ'\ninst✝⁴ : RingHomInvPair σ' σ\nM : Type u_14\nM₂ : Type u_15\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nself : LinearEquiv σ M M₂\n⊢ Function.RightInverse self.invFun self.toFun","decl":"/-- A linear equivalence is an invertible linear map. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO @[nolint has_nonempty_instance]\nstructure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (σ : R →+* S)\n  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type*) (M₂ : Type*)\n  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂\n\n"}
{"name":"LinearEquiv.left_inv","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_12\nS : Type u_13\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁵ : RingHomInvPair σ σ'\ninst✝⁴ : RingHomInvPair σ' σ\nM : Type u_14\nM₂ : Type u_15\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\nself : LinearEquiv σ M M₂\n⊢ Function.LeftInverse self.invFun self.toFun","decl":"/-- A linear equivalence is an invertible linear map. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO @[nolint has_nonempty_instance]\nstructure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (σ : R →+* S)\n  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type*) (M₂ : Type*)\n  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂\n\n"}
{"name":"LinearEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_12\nS : Type u_13\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁹ : RingHomInvPair σ σ'\ninst✝⁸ : RingHomInvPair σ' σ\nM : Type u_14\nM₂ : Type u_15\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module S M₂\ninst✝³ : SizeOf R\ninst✝² : SizeOf S\ninst✝¹ : SizeOf M\ninst✝ : SizeOf M₂\ntoLinearMap : LinearMap σ M M₂\ninvFun : M₂ → M\nleft_inv : Function.LeftInverse invFun toLinearMap.toFun\nright_inv : Function.RightInverse invFun toLinearMap.toFun\n⊢ Eq (SizeOf.sizeOf { toLinearMap := toLinearMap, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (HAdd.hAdd 1 (SizeOf.sizeOf toLinearMap))","decl":"/-- A linear equivalence is an invertible linear map. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO @[nolint has_nonempty_instance]\nstructure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (σ : R →+* S)\n  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type*) (M₂ : Type*)\n  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂\n\n"}
{"name":"LinearEquiv.mk.inj","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_12\nS : Type u_13\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁵ : RingHomInvPair σ σ'\ninst✝⁴ : RingHomInvPair σ' σ\nM : Type u_14\nM₂ : Type u_15\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ntoLinearMap✝ : LinearMap σ M M₂\ninvFun✝ : M₂ → M\nleft_inv✝ : Function.LeftInverse invFun✝ toLinearMap✝.toFun\nright_inv✝ : Function.RightInverse invFun✝ toLinearMap✝.toFun\ntoLinearMap : LinearMap σ M M₂\ninvFun : M₂ → M\nleft_inv : Function.LeftInverse invFun toLinearMap.toFun\nright_inv : Function.RightInverse invFun toLinearMap.toFun\nx✝ : Eq { toLinearMap := toLinearMap✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLinearMap := toLinearMap, invFun := invFun, left_inv := left_inv, right_inv := right_inv }\n⊢ And (Eq toLinearMap✝ toLinearMap) (Eq invFun✝ invFun)","decl":"/-- A linear equivalence is an invertible linear map. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO @[nolint has_nonempty_instance]\nstructure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (σ : R →+* S)\n  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type*) (M₂ : Type*)\n  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂\n\n"}
{"name":"LinearEquiv.mk.injEq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_12\nS : Type u_13\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\nσ : RingHom R S\nσ' : RingHom S R\ninst✝⁵ : RingHomInvPair σ σ'\ninst✝⁴ : RingHomInvPair σ' σ\nM : Type u_14\nM₂ : Type u_15\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ntoLinearMap✝ : LinearMap σ M M₂\ninvFun✝ : M₂ → M\nleft_inv✝ : Function.LeftInverse invFun✝ toLinearMap✝.toFun\nright_inv✝ : Function.RightInverse invFun✝ toLinearMap✝.toFun\ntoLinearMap : LinearMap σ M M₂\ninvFun : M₂ → M\nleft_inv : Function.LeftInverse invFun toLinearMap.toFun\nright_inv : Function.RightInverse invFun toLinearMap.toFun\n⊢ Eq (Eq { toLinearMap := toLinearMap✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toLinearMap := toLinearMap, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (And (Eq toLinearMap✝ toLinearMap) (Eq invFun✝ invFun))","decl":"/-- A linear equivalence is an invertible linear map. -/\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO @[nolint has_nonempty_instance]\nstructure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (σ : R →+* S)\n  {σ' : S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ] (M : Type*) (M₂ : Type*)\n  [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂] extends LinearMap σ M M₂, M ≃+ M₂\n\n"}
{"name":"SemilinearEquivClass.toAddEquivClass","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"F : Type u_12\nR : outParam (Type u_13)\nS : outParam (Type u_14)\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\nσ : outParam (RingHom R S)\nσ' : outParam (RingHom S R)\ninst✝⁶ : RingHomInvPair σ σ'\ninst✝⁵ : RingHomInvPair σ' σ\nM : outParam (Type u_15)\nM₂ : outParam (Type u_16)\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\ninst✝ : EquivLike F M M₂\nself : SemilinearEquivClass F σ M M₂\n⊢ AddEquivClass F M M₂","decl":"/-- `SemilinearEquivClass F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear equivs\n`M → M₂`.\n\nSee also `LinearEquivClass F R M M₂` for the case where `σ` is the identity map on `R`.\n\nA map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. -/\nclass SemilinearEquivClass (F : Type*) {R S : outParam Type*} [Semiring R] [Semiring S]\n  (σ : outParam <| R →+* S) {σ' : outParam <| S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]\n  (M M₂ : outParam Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂]\n  [EquivLike F M M₂]\n  extends AddEquivClass F M M₂ : Prop where\n  /-- Applying a semilinear equivalence `f` over `σ` to `r • x` equals `σ r • f x`. -/\n  map_smulₛₗ : ∀ (f : F) (r : R) (x : M), f (r • x) = σ r • f x\n\n-- `R, S, σ, σ'` become metavars, but it's OK since they are outparams.\n\n"}
{"name":"SemilinearEquivClass.map_smulₛₗ","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"F : Type u_12\nR : outParam (Type u_13)\nS : outParam (Type u_14)\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\nσ : outParam (RingHom R S)\nσ' : outParam (RingHom S R)\ninst✝⁶ : RingHomInvPair σ σ'\ninst✝⁵ : RingHomInvPair σ' σ\nM : outParam (Type u_15)\nM₂ : outParam (Type u_16)\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M\ninst✝¹ : Module S M₂\ninst✝ : EquivLike F M M₂\nself : SemilinearEquivClass F σ M M₂\nf : F\nr : R\nx : M\n⊢ Eq (f (HSMul.hSMul r x)) (HSMul.hSMul (σ r) (f x))","decl":"/-- `SemilinearEquivClass F σ M M₂` asserts `F` is a type of bundled `σ`-semilinear equivs\n`M → M₂`.\n\nSee also `LinearEquivClass F R M M₂` for the case where `σ` is the identity map on `R`.\n\nA map `f` between an `R`-module and an `S`-module over a ring homomorphism `σ : R →+* S`\nis semilinear if it satisfies the two properties `f (x + y) = f x + f y` and\n`f (c • x) = (σ c) • f x`. -/\nclass SemilinearEquivClass (F : Type*) {R S : outParam Type*} [Semiring R] [Semiring S]\n  (σ : outParam <| R →+* S) {σ' : outParam <| S →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]\n  (M M₂ : outParam Type*) [AddCommMonoid M] [AddCommMonoid M₂] [Module R M] [Module S M₂]\n  [EquivLike F M M₂]\n  extends AddEquivClass F M M₂ : Prop where\n  /-- Applying a semilinear equivalence `f` over `σ` to `r • x` equals `σ r • f x`. -/\n  map_smulₛₗ : ∀ (f : F) (r : R) (x : M), f (r • x) = σ r • f x\n\n-- `R, S, σ, σ'` become metavars, but it's OK since they are outparams.\n\n"}
{"name":"SemilinearEquivClass.instSemilinearMapClass","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\nF : Type u_12\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝² : RingHomInvPair σ σ'\ninst✝¹ : RingHomInvPair σ' σ\ninst✝ : EquivLike F M M₂\ns : SemilinearEquivClass F σ M M₂\n⊢ SemilinearMapClass F σ M M₂","decl":"instance (priority := 100) [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]\n  [EquivLike F M M₂] [s : SemilinearEquivClass F σ M M₂] : SemilinearMapClass F σ M M₂ :=\n  { s with }\n\n"}
{"name":"LinearEquiv.toEquiv_injective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\n⊢ Function.Injective LinearEquiv.toEquiv","decl":"theorem toEquiv_injective : Function.Injective (toEquiv : (M ≃ₛₗ[σ] M₂) → M ≃ M₂) :=\n  fun ⟨⟨⟨_, _⟩, _⟩, _, _, _⟩ ⟨⟨⟨_, _⟩, _⟩, _, _, _⟩ h ↦\n    (LinearEquiv.mk.injEq _ _ _ _ _ _ _ _).mpr\n      ⟨LinearMap.ext (congr_fun (Equiv.mk.inj h).1), (Equiv.mk.inj h).2⟩\n\n"}
{"name":"LinearEquiv.toEquiv_inj","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\ne₁ e₂ : LinearEquiv σ M M₂\n⊢ Iff (Eq e₁.toEquiv e₂.toEquiv) (Eq e₁ e₂)","decl":"@[simp]\ntheorem toEquiv_inj {e₁ e₂ : M ≃ₛₗ[σ] M₂} : e₁.toEquiv = e₂.toEquiv ↔ e₁ = e₂ :=\n  toEquiv_injective.eq_iff\n\n"}
{"name":"LinearEquiv.toLinearMap_injective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\n⊢ Function.Injective LinearEquiv.toLinearMap","decl":"theorem toLinearMap_injective : Injective (toLinearMap : (M ≃ₛₗ[σ] M₂) → M →ₛₗ[σ] M₂) :=\n  fun _ _ H ↦ toEquiv_injective <| Equiv.ext <| LinearMap.congr_fun H\n\n"}
{"name":"LinearEquiv.toLinearMap_inj","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\ne₁ e₂ : LinearEquiv σ M M₂\n⊢ Iff (Eq ↑e₁ ↑e₂) (Eq e₁ e₂)","decl":"@[simp, norm_cast]\ntheorem toLinearMap_inj {e₁ e₂ : M ≃ₛₗ[σ] M₂} : (↑e₁ : M →ₛₗ[σ] M₂) = e₂ ↔ e₁ = e₂ :=\n  toLinearMap_injective.eq_iff\n\n"}
{"name":"LinearEquiv.instSemilinearEquivClass","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\n⊢ SemilinearEquivClass (LinearEquiv σ M M₂) σ M M₂","decl":"instance : SemilinearEquivClass (M ≃ₛₗ[σ] M₂) σ M M₂ where\n  map_add := (·.map_add') --map_add' Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO why did I need to change this?\n  map_smulₛₗ := (·.map_smul') --map_smul' Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO why did I need to change this?\n\n-- Porting note: moved to a lower line since there is no shortcut `CoeFun` instance any more\n"}
{"name":"LinearEquiv.coe_mk","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\nto_fun : M → M₂\ninv_fun : M₂ → M\nmap_add : ∀ (x y : M), Eq (to_fun (HAdd.hAdd x y)) (HAdd.hAdd (to_fun x) (to_fun y))\nmap_smul : ∀ (m : R) (x : M), Eq ({ toFun := to_fun, map_add' := map_add }.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) ({ toFun := to_fun, map_add' := map_add }.toFun x))\nleft_inv : Function.LeftInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun\nright_inv : Function.RightInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun\n⊢ Eq (⇑{ toFun := to_fun, map_add' := map_add, map_smul' := map_smul, invFun := inv_fun, left_inv := left_inv, right_inv := right_inv }) to_fun","decl":"@[simp]\ntheorem coe_mk {to_fun inv_fun map_add map_smul left_inv right_inv} :\n    (⟨⟨⟨to_fun, map_add⟩, map_smul⟩, inv_fun, left_inv, right_inv⟩ : M ≃ₛₗ[σ] M₂) = to_fun := rfl\n\n"}
{"name":"LinearEquiv.coe_injective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\n⊢ Function.Injective CoeFun.coe","decl":"theorem coe_injective : @Injective (M ≃ₛₗ[σ] M₂) (M → M₂) CoeFun.coe :=\n  DFunLike.coe_injective\n\n"}
{"name":"LinearEquiv.coe_coe","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq ⇑↑e ⇑e","decl":"@[simp, norm_cast]\ntheorem coe_coe : ⇑(e : M →ₛₗ[σ] M₂) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toEquiv","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq ⇑e.toEquiv ⇑e","decl":"@[simp]\ntheorem coe_toEquiv : ⇑(e.toEquiv) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toLinearMap","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq ⇑↑e ⇑e","decl":"@[simp]\ntheorem coe_toLinearMap : ⇑e.toLinearMap = e :=\n  rfl\n\n-- Porting note: no longer a `simp`\n"}
{"name":"LinearEquiv.toFun_eq_coe","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq (↑e).toFun ⇑e","decl":"theorem toFun_eq_coe : e.toFun = e := rfl\n\n"}
{"name":"LinearEquiv.ext","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne e' : LinearEquiv σ M M₂\nh : ∀ (x : M), Eq (e x) (e' x)\n⊢ Eq e e'","decl":"@[ext]\ntheorem ext (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"LinearEquiv.ext_iff","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne e' : LinearEquiv σ M M₂\n⊢ Iff (Eq e e') (∀ (x : M), Eq (e x) (e' x))","decl":"@[ext]\ntheorem ext (h : ∀ x, e x = e' x) : e = e' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"LinearEquiv.congr_arg","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nx x' : M\na✝ : Eq x x'\n⊢ Eq (e x) (e x')","decl":"protected theorem congr_arg {x x'} : x = x' → e x = e x' :=\n  DFunLike.congr_arg e\n\n"}
{"name":"LinearEquiv.congr_fun","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne e' : LinearEquiv σ M M₂\nh : Eq e e'\nx : M\n⊢ Eq (e x) (e' x)","decl":"protected theorem congr_fun (h : e = e') (x : M) : e x = e' x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"LinearEquiv.refl_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq ((LinearEquiv.refl R M) x) x","decl":"@[simp]\ntheorem refl_apply [Module R M] (x : M) : refl R M x = x :=\n  rfl\n\n"}
{"name":"LinearEquiv.invFun_eq_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq e.invFun ⇑e.symm","decl":"@[simp]\ntheorem invFun_eq_symm : e.invFun = e.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toEquiv_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq e.toEquiv.symm ↑e.symm","decl":"@[simp]\ntheorem coe_toEquiv_symm : e.toEquiv.symm = e.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toAddEquiv","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq e.toAddEquiv ↑e","decl":"@[simp]\ntheorem coe_toAddEquiv : e.toAddEquiv = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.toAddMonoidHom_commutes","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq (↑e).toAddMonoidHom e.toAddEquiv.toAddMonoidHom","decl":"/-- The two paths coercion can take to an `AddMonoidHom` are equivalent -/\ntheorem toAddMonoidHom_commutes : e.toLinearMap.toAddMonoidHom = e.toAddEquiv.toAddMonoidHom :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toAddEquiv_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\n⊢ Eq (↑e₁₂.symm) (↑e₁₂).symm","decl":"lemma coe_toAddEquiv_symm : (e₁₂.symm : M₂ ≃+ M₁) = (e₁₂ : M₁ ≃+ M₂).symm := by\n  rfl\n\n"}
{"name":"LinearEquiv.trans_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₃ : RingHomInvPair σ₂₃ σ₃₂\ninst✝¹ : RingHomInvPair σ₁₃ σ₃₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nre₃₂ : RingHomInvPair σ₃₂ σ₂₃\ninst✝ : RingHomInvPair σ₃₁ σ₁₃\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ne₂₃ : LinearEquiv σ₂₃ M₂ M₃\nc : M₁\n⊢ Eq ((e₁₂.trans e₂₃) c) (e₂₃ (e₁₂ c))","decl":"@[simp]\ntheorem trans_apply (c : M₁) : (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃) c = e₂₃ (e₁₂ c) :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_trans","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₃ : RingHomInvPair σ₂₃ σ₃₂\ninst✝¹ : RingHomInvPair σ₁₃ σ₃₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nre₃₂ : RingHomInvPair σ₃₂ σ₂₃\ninst✝ : RingHomInvPair σ₃₁ σ₁₃\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ne₂₃ : LinearEquiv σ₂₃ M₂ M₃\n⊢ Eq (↑(e₁₂.trans e₂₃)) ((↑e₂₃).comp ↑e₁₂)","decl":"theorem coe_trans :\n    (e₁₂.trans e₂₃ : M₁ →ₛₗ[σ₁₃] M₃) = (e₂₃ : M₂ →ₛₗ[σ₂₃] M₃).comp (e₁₂ : M₁ →ₛₗ[σ₁₂] M₂) :=\n  rfl\n\n"}
{"name":"LinearEquiv.apply_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nc : M₂\n⊢ Eq (e (e.symm c)) c","decl":"@[simp]\ntheorem apply_symm_apply (c : M₂) : e (e.symm c) = c :=\n  e.right_inv c\n\n"}
{"name":"LinearEquiv.symm_apply_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nb : M\n⊢ Eq (e.symm (e b)) b","decl":"@[simp]\ntheorem symm_apply_apply (b : M) : e.symm (e b) = b :=\n  e.left_inv b\n\n"}
{"name":"LinearEquiv.trans_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₃ : RingHomInvPair σ₂₃ σ₃₂\ninst✝¹ : RingHomInvPair σ₁₃ σ₃₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nre₃₂ : RingHomInvPair σ₃₂ σ₂₃\ninst✝ : RingHomInvPair σ₃₁ σ₁₃\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ne₂₃ : LinearEquiv σ₂₃ M₂ M₃\n⊢ Eq (e₁₂.trans e₂₃).symm (e₂₃.symm.trans e₁₂.symm)","decl":"@[simp]\ntheorem trans_symm : (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃).symm = e₂₃.symm.trans e₁₂.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.symm_trans_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁹ : Semiring R₁\ninst✝⁸ : Semiring R₂\ninst✝⁷ : Semiring R₃\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₃ : RingHomInvPair σ₂₃ σ₃₂\ninst✝¹ : RingHomInvPair σ₁₃ σ₃₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nre₃₂ : RingHomInvPair σ₃₂ σ₂₃\ninst✝ : RingHomInvPair σ₃₁ σ₁₃\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ne₂₃ : LinearEquiv σ₂₃ M₂ M₃\nc : M₃\n⊢ Eq ((e₁₂.trans e₂₃).symm c) (e₁₂.symm (e₂₃.symm c))","decl":"theorem symm_trans_apply (c : M₃) :\n    (e₁₂.trans e₂₃ : M₁ ≃ₛₗ[σ₁₃] M₃).symm c = e₁₂.symm (e₂₃.symm c) :=\n  rfl\n\n"}
{"name":"LinearEquiv.trans_refl","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq (e.trans (LinearEquiv.refl S M₂)) e","decl":"@[simp]\ntheorem trans_refl : e.trans (refl S M₂) = e :=\n  toEquiv_injective e.toEquiv.trans_refl\n\n"}
{"name":"LinearEquiv.refl_trans","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq ((LinearEquiv.refl R M).trans e) e","decl":"@[simp]\ntheorem refl_trans : (refl R M).trans e = e :=\n  toEquiv_injective e.toEquiv.refl_trans\n\n"}
{"name":"LinearEquiv.symm_apply_eq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nx : M₂\ny : M\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"theorem symm_apply_eq {x y} : e.symm x = y ↔ x = e y :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"LinearEquiv.eq_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nx : M₂\ny : M\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"theorem eq_symm_apply {x y} : y = e.symm x ↔ e y = x :=\n  e.toEquiv.eq_symm_apply\n\n"}
{"name":"LinearEquiv.eq_comp_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\nα : Type u_12\nf : M₂ → α\ng : M₁ → α\n⊢ Iff (Eq f (Function.comp g ⇑e₁₂.symm)) (Eq (Function.comp f ⇑e₁₂) g)","decl":"theorem eq_comp_symm {α : Type*} (f : M₂ → α) (g : M₁ → α) : f = g ∘ e₁₂.symm ↔ f ∘ e₁₂ = g :=\n  e₁₂.toEquiv.eq_comp_symm f g\n\n"}
{"name":"LinearEquiv.comp_symm_eq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\nα : Type u_12\nf : M₂ → α\ng : M₁ → α\n⊢ Iff (Eq (Function.comp g ⇑e₁₂.symm) f) (Eq g (Function.comp f ⇑e₁₂))","decl":"theorem comp_symm_eq {α : Type*} (f : M₂ → α) (g : M₁ → α) : g ∘ e₁₂.symm = f ↔ g = f ∘ e₁₂ :=\n  e₁₂.toEquiv.comp_symm_eq f g\n\n"}
{"name":"LinearEquiv.eq_symm_comp","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\nα : Type u_12\nf : α → M₁\ng : α → M₂\n⊢ Iff (Eq f (Function.comp (⇑e₁₂.symm) g)) (Eq (Function.comp (⇑e₁₂) f) g)","decl":"theorem eq_symm_comp {α : Type*} (f : α → M₁) (g : α → M₂) : f = e₁₂.symm ∘ g ↔ e₁₂ ∘ f = g :=\n  e₁₂.toEquiv.eq_symm_comp f g\n\n"}
{"name":"LinearEquiv.symm_comp_eq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\nα : Type u_12\nf : α → M₁\ng : α → M₂\n⊢ Iff (Eq (Function.comp (⇑e₁₂.symm) g) f) (Eq g (Function.comp (⇑e₁₂) f))","decl":"theorem symm_comp_eq {α : Type*} (f : α → M₁) (g : α → M₂) : e₁₂.symm ∘ g = f ↔ g = e₁₂ ∘ f :=\n  e₁₂.toEquiv.symm_comp_eq f g\n\n"}
{"name":"LinearEquiv.eq_comp_toLinearMap_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\ninst✝¹ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₂₁ σ₁₃ σ₂₃\nf : LinearMap σ₂₃ M₂ M₃\ng : LinearMap σ₁₃ M₁ M₃\n⊢ Iff (Eq f (g.comp ↑e₁₂.symm)) (Eq (f.comp ↑e₁₂) g)","decl":"theorem eq_comp_toLinearMap_symm (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₃] M₃) :\n    f = g.comp e₁₂.symm.toLinearMap ↔ f.comp e₁₂.toLinearMap = g := by\n  constructor <;> intro H <;> ext\n  · simp [H, e₁₂.toEquiv.eq_comp_symm f g]\n  · simp [← H, ← e₁₂.toEquiv.eq_comp_symm f g]\n\n"}
{"name":"LinearEquiv.comp_toLinearMap_symm_eq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\ninst✝¹ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₂₁ σ₁₃ σ₂₃\nf : LinearMap σ₂₃ M₂ M₃\ng : LinearMap σ₁₃ M₁ M₃\n⊢ Iff (Eq (g.comp ↑e₁₂.symm) f) (Eq g (f.comp ↑e₁₂))","decl":"theorem comp_toLinearMap_symm_eq (f : M₂ →ₛₗ[σ₂₃] M₃) (g : M₁ →ₛₗ[σ₁₃] M₃) :\n    g.comp e₁₂.symm.toLinearMap = f ↔ g = f.comp e₁₂.toLinearMap := by\n  constructor <;> intro H <;> ext\n  · simp [← H, ← e₁₂.toEquiv.comp_symm_eq f g]\n  · simp [H, e₁₂.toEquiv.comp_symm_eq f g]\n\n"}
{"name":"LinearEquiv.eq_toLinearMap_symm_comp","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝¹ : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₃₁ σ₁₂ σ₃₂\nf : LinearMap σ₃₁ M₃ M₁\ng : LinearMap σ₃₂ M₃ M₂\n⊢ Iff (Eq f ((↑e₁₂.symm).comp g)) (Eq ((↑e₁₂).comp f) g)","decl":"theorem eq_toLinearMap_symm_comp (f : M₃ →ₛₗ[σ₃₁] M₁) (g : M₃ →ₛₗ[σ₃₂] M₂) :\n    f = e₁₂.symm.toLinearMap.comp g ↔ e₁₂.toLinearMap.comp f = g := by\n  constructor <;> intro H <;> ext\n  · simp [H, e₁₂.toEquiv.eq_symm_comp f g]\n  · simp [← H, ← e₁₂.toEquiv.eq_symm_comp f g]\n\n"}
{"name":"LinearEquiv.toLinearMap_symm_comp_eq","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝¹ : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₃₁ σ₁₂ σ₃₂\nf : LinearMap σ₃₁ M₃ M₁\ng : LinearMap σ₃₂ M₃ M₂\n⊢ Iff (Eq ((↑e₁₂.symm).comp g) f) (Eq g ((↑e₁₂).comp f))","decl":"theorem toLinearMap_symm_comp_eq (f : M₃ →ₛₗ[σ₃₁] M₁) (g : M₃ →ₛₗ[σ₃₂] M₂) :\n    e₁₂.symm.toLinearMap.comp g = f ↔ g = e₁₂.toLinearMap.comp f := by\n  constructor <;> intro H <;> ext\n  · simp [← H, ← e₁₂.toEquiv.symm_comp_eq f g]\n  · simp [H, e₁₂.toEquiv.symm_comp_eq f g]\n\n"}
{"name":"LinearEquiv.comp_toLinearMap_eq_iff","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nσ₃₂ : RingHom R₃ R₂\nσ₃₁ : RingHom R₃ R₁\ninst✝¹ : RingHomCompTriple σ₃₂ σ₂₁ σ₃₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₃₁ σ₁₂ σ₃₂\nf g : LinearMap σ₃₁ M₃ M₁\n⊢ Iff (Eq ((↑e₁₂).comp f) ((↑e₁₂).comp g)) (Eq f g)","decl":"@[simp]\ntheorem comp_toLinearMap_eq_iff (f g : M₃ →ₛₗ[σ₃₁] M₁) :\n    e₁₂.toLinearMap.comp f = e₁₂.toLinearMap.comp g ↔ f = g := by\n  refine ⟨fun h => ?_, congrArg e₁₂.comp⟩\n  rw [← (toLinearMap_symm_comp_eq g (e₁₂.toLinearMap.comp f)).mpr h, eq_toLinearMap_symm_comp]\n\n"}
{"name":"LinearEquiv.eq_comp_toLinearMap_iff","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nR₃ : Type u_4\nM₁ : Type u_7\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁷ : Semiring R₁\ninst✝⁶ : Semiring R₂\ninst✝⁵ : Semiring R₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R₁ R₂\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R₁ R₃\nσ₂₁ : RingHom R₂ R₁\ninst✝¹ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne₁₂ : LinearEquiv σ₁₂ M₁ M₂\ninst✝ : RingHomCompTriple σ₂₁ σ₁₃ σ₂₃\nf g : LinearMap σ₂₃ M₂ M₃\n⊢ Iff (Eq (f.comp ↑e₁₂) (g.comp ↑e₁₂)) (Eq f g)","decl":"@[simp]\ntheorem eq_comp_toLinearMap_iff (f g : M₂ →ₛₗ[σ₂₃] M₃) :\n    f.comp e₁₂.toLinearMap = g.comp e₁₂.toLinearMap ↔ f = g := by\n  refine ⟨fun h => ?_, fun a ↦ congrFun (congrArg LinearMap.comp a) e₁₂.toLinearMap⟩\n  rw [(eq_comp_toLinearMap_symm g (f.comp e₁₂.toLinearMap)).mpr h.symm, eq_comp_toLinearMap_symm]\n\n"}
{"name":"LinearEquiv.refl_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearEquiv.refl R M).symm (LinearEquiv.refl R M)","decl":"@[simp]\ntheorem refl_symm [Module R M] : (refl R M).symm = LinearEquiv.refl R M :=\n  rfl\n\n"}
{"name":"LinearEquiv.self_trans_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearEquiv σ₁₂ M₁ M₂\n⊢ Eq (f.trans f.symm) (LinearEquiv.refl R₁ M₁)","decl":"@[simp]\ntheorem self_trans_symm (f : M₁ ≃ₛₗ[σ₁₂] M₂) : f.trans f.symm = LinearEquiv.refl R₁ M₁ := by\n  ext x\n  simp\n\n"}
{"name":"LinearEquiv.symm_trans_self","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nR₂ : Type u_3\nM₁ : Type u_7\nM₂ : Type u_8\ninst✝³ : Semiring R₁\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M₁\ninst✝ : AddCommMonoid M₂\nmodule_M₁ : Module R₁ M₁\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R₁ R₂\nσ₂₁ : RingHom R₂ R₁\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearEquiv σ₁₂ M₁ M₂\n⊢ Eq (f.symm.trans f) (LinearEquiv.refl R₂ M₂)","decl":"@[simp]\ntheorem symm_trans_self (f : M₁ ≃ₛₗ[σ₁₂] M₂) : f.symm.trans f = LinearEquiv.refl R₂ M₂ := by\n  ext x\n  simp\n\n"}
{"name":"LinearEquiv.refl_toLinearMap","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (↑(LinearEquiv.refl R M)) LinearMap.id","decl":"@[simp]  -- Porting note: norm_cast\ntheorem refl_toLinearMap [Module R M] : (LinearEquiv.refl R M : M →ₗ[R] M) = LinearMap.id :=\n  rfl\n\n"}
{"name":"LinearEquiv.comp_coe","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\nM₂ : Type u_8\nM₃ : Type u_9\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearEquiv (RingHom.id R) M M₂\nf' : LinearEquiv (RingHom.id R) M₂ M₃\n⊢ Eq ((↑f').comp ↑f) ↑(f.trans f')","decl":"@[simp]  -- Porting note: norm_cast\ntheorem comp_coe [Module R M] [Module R M₂] [Module R M₃] (f : M ≃ₗ[R] M₂) (f' : M₂ ≃ₗ[R] M₃) :\n    (f' : M₂ →ₗ[R] M₃).comp (f : M →ₗ[R] M₂) = (f.trans f' : M ≃ₗ[R] M₃) :=\n  rfl\n\n"}
{"name":"LinearEquiv.mk_coe","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nf : M₂ → M\nh₁ : Function.LeftInverse f (↑e).toFun\nh₂ : Function.RightInverse f (↑e).toFun\n⊢ Eq { toLinearMap := ↑e, invFun := f, left_inv := h₁, right_inv := h₂ } e","decl":"@[simp]\ntheorem mk_coe (f h₁ h₂) : (LinearEquiv.mk e f h₁ h₂ : M ≃ₛₗ[σ] M₂) = e :=\n  ext fun _ ↦ rfl\n\n"}
{"name":"LinearEquiv.map_add","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\na b : M\n⊢ Eq (e (HAdd.hAdd a b)) (HAdd.hAdd (e a) (e b))","decl":"protected theorem map_add (a b : M) : e (a + b) = e a + e b :=\n  map_add e a b\n\n"}
{"name":"LinearEquiv.map_zero","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq (e 0) 0","decl":"protected theorem map_zero : e 0 = 0 :=\n  map_zero e\n\n"}
{"name":"LinearEquiv.map_smulₛₗ","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nc : R\nx : M\n⊢ Eq (e (HSMul.hSMul c x)) (HSMul.hSMul (σ c) (e x))","decl":"protected theorem map_smulₛₗ (c : R) (x : M) : e (c • x) = (σ : R → S) c • e x :=\n  e.map_smul' c x\n\n"}
{"name":"LinearEquiv.map_smul","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R₁ : Type u_2\nN₁ : Type u_10\nN₂ : Type u_11\ninst✝² : Semiring R₁\ninst✝¹ : AddCommMonoid N₁\ninst✝ : AddCommMonoid N₂\nmodule_N₁ : Module R₁ N₁\nmodule_N₂ : Module R₁ N₂\ne : LinearEquiv (RingHom.id R₁) N₁ N₂\nc : R₁\nx : N₁\n⊢ Eq (e (HSMul.hSMul c x)) (HSMul.hSMul c (e x))","decl":"theorem map_smul (e : N₁ ≃ₗ[R₁] N₂) (c : R₁) (x : N₁) : e (c • x) = c • e x :=\n  map_smulₛₗ e c x\n\n"}
{"name":"LinearEquiv.map_eq_zero_iff","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nx : M\n⊢ Iff (Eq (e x) 0) (Eq x 0)","decl":"theorem map_eq_zero_iff {x : M} : e x = 0 ↔ x = 0 :=\n  e.toAddEquiv.map_eq_zero_iff\n\n"}
{"name":"LinearEquiv.map_ne_zero_iff","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nx : M\n⊢ Iff (Ne (e x) 0) (Ne x 0)","decl":"theorem map_ne_zero_iff {x : M} : e x ≠ 0 ↔ x ≠ 0 :=\n  e.toAddEquiv.map_ne_zero_iff\n\n"}
{"name":"LinearEquiv.symm_symm","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : M ≃ₛₗ[σ] M₂) : e.symm.symm = e := rfl\n\n"}
{"name":"LinearEquiv.symm_bijective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝³ : Module R M\ninst✝² : Module S M₂\ninst✝¹ : RingHomInvPair σ' σ\ninst✝ : RingHomInvPair σ σ'\n⊢ Function.Bijective LinearEquiv.symm","decl":"theorem symm_bijective [Module R M] [Module S M₂] [RingHomInvPair σ' σ] [RingHomInvPair σ σ'] :\n    Function.Bijective (symm : (M ≃ₛₗ[σ] M₂) → M₂ ≃ₛₗ[σ'] M) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"LinearEquiv.mk_coe'","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nf : M₂ → M\nh₁ : ∀ (x y : M₂), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh₂ : ∀ (m : S) (x : M₂), Eq ({ toFun := f, map_add' := h₁ }.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ' m) ({ toFun := f, map_add' := h₁ }.toFun x))\nh₃ : Function.LeftInverse ⇑e { toFun := f, map_add' := h₁, map_smul' := h₂ }.toFun\nh₄ : Function.RightInverse ⇑e { toFun := f, map_add' := h₁, map_smul' := h₂ }.toFun\n⊢ Eq { toFun := f, map_add' := h₁, map_smul' := h₂, invFun := ⇑e, left_inv := h₃, right_inv := h₄ } e.symm","decl":"@[simp]\ntheorem mk_coe' (f h₁ h₂ h₃ h₄) :\n    (LinearEquiv.mk ⟨⟨f, h₁⟩, h₂⟩ (⇑e) h₃ h₄ : M₂ ≃ₛₗ[σ'] M) = e.symm :=\n  symm_bijective.injective <| ext fun _ ↦ rfl\n\n"}
{"name":"LinearEquiv.symm_mk","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nf : M₂ → M\nh₁ : ∀ (x y : M), Eq (e (HAdd.hAdd x y)) (HAdd.hAdd (e x) (e y))\nh₂ : ∀ (m : R) (x : M), Eq ({ toFun := ⇑e, map_add' := h₁ }.toFun (HSMul.hSMul m x)) (HSMul.hSMul (σ m) ({ toFun := ⇑e, map_add' := h₁ }.toFun x))\nh₃ : Function.LeftInverse f { toFun := ⇑e, map_add' := h₁, map_smul' := h₂ }.toFun\nh₄ : Function.RightInverse f { toFun := ⇑e, map_add' := h₁, map_smul' := h₂ }.toFun\n⊢ Eq { toFun := ⇑e, map_add' := h₁, map_smul' := h₂, invFun := f, left_inv := h₃, right_inv := h₄ }.symm\n    (let __src := LinearEquiv.symm_mk.aux e f h₁ h₂ h₃ h₄;\n    { toFun := f, map_add' := ⋯, map_smul' := ⋯, invFun := ⇑e, left_inv := ⋯, right_inv := ⋯ })","decl":"@[simp]\ntheorem symm_mk (f h₁ h₂ h₃ h₄) :\n    (⟨⟨⟨e, h₁⟩, h₂⟩, f, h₃, h₄⟩ : M ≃ₛₗ[σ] M₂).symm =\n      { symm_mk.aux e f h₁ h₂ h₃ h₄ with\n        toFun := f\n        invFun := e } :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_symm_mk","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\nM₂ : Type u_8\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nto_fun : M → M₂\ninv_fun : M₂ → M\nmap_add : ∀ (x y : M), Eq (to_fun (HAdd.hAdd x y)) (HAdd.hAdd (to_fun x) (to_fun y))\nmap_smul : ∀ (m : R) (x : M), Eq ({ toFun := to_fun, map_add' := map_add }.toFun (HSMul.hSMul m x)) (HSMul.hSMul ((RingHom.id R) m) ({ toFun := to_fun, map_add' := map_add }.toFun x))\nleft_inv : Function.LeftInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun\nright_inv : Function.RightInverse inv_fun { toFun := to_fun, map_add' := map_add, map_smul' := map_smul }.toFun\n⊢ Eq (⇑{ toFun := to_fun, map_add' := map_add, map_smul' := map_smul, invFun := inv_fun, left_inv := left_inv, right_inv := right_inv }.symm) inv_fun","decl":"@[simp]\ntheorem coe_symm_mk [Module R M] [Module R M₂]\n    {to_fun inv_fun map_add map_smul left_inv right_inv} :\n    ⇑(⟨⟨⟨to_fun, map_add⟩, map_smul⟩, inv_fun, left_inv, right_inv⟩ : M ≃ₗ[R] M₂).symm = inv_fun :=\n  rfl\n\n"}
{"name":"LinearEquiv.bijective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective : Function.Bijective e :=\n  e.toEquiv.bijective\n\n"}
{"name":"LinearEquiv.injective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Function.Injective ⇑e","decl":"protected theorem injective : Function.Injective e :=\n  e.toEquiv.injective\n\n"}
{"name":"LinearEquiv.surjective","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective : Function.Surjective e :=\n  e.toEquiv.surjective\n\n"}
{"name":"LinearEquiv.image_eq_preimage","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\ns : Set M\n⊢ Eq (Set.image (⇑e) s) (Set.preimage (⇑e.symm) s)","decl":"protected theorem image_eq_preimage (s : Set M) : e '' s = e.symm ⁻¹' s :=\n  e.toEquiv.image_eq_preimage s\n\n"}
{"name":"LinearEquiv.image_symm_eq_preimage","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\nM : Type u_6\nM₂ : Type u_8\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_S_M₂ : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\nre₁ : RingHomInvPair σ σ'\nre₂ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\ns : Set M₂\n⊢ Eq (Set.image (⇑e.symm) s) (Set.preimage (⇑e) s)","decl":"protected theorem image_symm_eq_preimage (s : Set M₂) : e.symm '' s = e ⁻¹' s :=\n  e.toEquiv.symm.image_eq_preimage s\n\n"}
{"name":"RingEquiv.toSemilinearEquiv_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingEquiv R S\na✝ : S\n⊢ Eq (f.toSemilinearEquiv.symm a✝) (f.invFun a✝)","decl":"/-- Interpret a `RingEquiv` `f` as an `f`-semilinear equiv. -/\n@[simps]\ndef _root_.RingEquiv.toSemilinearEquiv (f : R ≃+* S) :\n    haveI := RingHomInvPair.of_ringEquiv f\n    haveI := RingHomInvPair.symm (↑f : R →+* S) (f.symm : S →+* R)\n    R ≃ₛₗ[(↑f : R →+* S)] S :=\n  haveI := RingHomInvPair.of_ringEquiv f\n  haveI := RingHomInvPair.symm (↑f : R →+* S) (f.symm : S →+* R)\n  { f with\n    toFun := f\n    map_smul' := f.map_mul }\n\n"}
{"name":"RingEquiv.toSemilinearEquiv_apply","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nS : Type u_5\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingEquiv R S\na : R\n⊢ Eq (f.toSemilinearEquiv a) (f a)","decl":"/-- Interpret a `RingEquiv` `f` as an `f`-semilinear equiv. -/\n@[simps]\ndef _root_.RingEquiv.toSemilinearEquiv (f : R ≃+* S) :\n    haveI := RingHomInvPair.of_ringEquiv f\n    haveI := RingHomInvPair.symm (↑f : R →+* S) (f.symm : S →+* R)\n    R ≃ₛₗ[(↑f : R →+* S)] S :=\n  haveI := RingHomInvPair.of_ringEquiv f\n  haveI := RingHomInvPair.symm (↑f : R →+* S) (f.symm : S →+* R)\n  { f with\n    toFun := f\n    map_smul' := f.map_mul }\n\n"}
{"name":"LinearEquiv.coe_ofInvolutive","module":"Mathlib.Algebra.Module.Equiv.Defs","initialProofState":"R : Type u_1\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\nσ σ' : RingHom R R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\nx✝ : Module R M\nf : LinearMap σ M M\nhf : Function.Involutive ⇑f\n⊢ Eq ⇑(LinearEquiv.ofInvolutive f hf) ⇑f","decl":"@[simp]\ntheorem coe_ofInvolutive {σ σ' : R →+* R} [RingHomInvPair σ σ'] [RingHomInvPair σ' σ]\n    {_ : Module R M} (f : M →ₛₗ[σ] M) (hf : Involutive f) : ⇑(ofInvolutive f hf) = f :=\n  rfl\n\n"}
