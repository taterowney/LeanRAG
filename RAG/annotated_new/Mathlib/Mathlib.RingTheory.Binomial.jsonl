{"name":"BinomialRing.nsmul_right_injective","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Pow R Nat\nself : BinomialRing R\nn : Nat\nh : Ne n 0\n⊢ Function.Injective fun x => HSMul.hSMul n x","decl":"/-- A binomial ring is a ring for which ascending Pochhammer evaluations are uniquely divisible by\nsuitable factorials. We define this notion as a mixin for additive commutative monoids with natural\nnumber powers, but retain the ring name. We introduce `Ring.multichoose` as the uniquely defined\nquotient. -/\nclass BinomialRing (R : Type*) [AddCommMonoid R] [Pow R ℕ] where\n  /-- Scalar multiplication by positive integers is injective -/\n  nsmul_right_injective {n : ℕ} (h : n ≠ 0) : Injective (n • · : R → R)\n  /-- A multichoose function, giving the quotient of Pochhammer evaluations by factorials. -/\n  multichoose : R → ℕ → R\n  /-- The `n`th ascending Pochhammer polynomial evaluated at any element is divisible by `n!` -/\n  factorial_nsmul_multichoose (r : R) (n : ℕ) :\n    n.factorial • multichoose r n = (ascPochhammer ℕ n).smeval r\n\n"}
{"name":"BinomialRing.factorial_nsmul_multichoose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : Pow R Nat\nself : BinomialRing R\nr : R\nn : Nat\n⊢ Eq (HSMul.hSMul n.factorial (BinomialRing.multichoose r n)) ((ascPochhammer Nat n).smeval r)","decl":"/-- A binomial ring is a ring for which ascending Pochhammer evaluations are uniquely divisible by\nsuitable factorials. We define this notion as a mixin for additive commutative monoids with natural\nnumber powers, but retain the ring name. We introduce `Ring.multichoose` as the uniquely defined\nquotient. -/\nclass BinomialRing (R : Type*) [AddCommMonoid R] [Pow R ℕ] where\n  /-- Scalar multiplication by positive integers is injective -/\n  nsmul_right_injective {n : ℕ} (h : n ≠ 0) : Injective (n • · : R → R)\n  /-- A multichoose function, giving the quotient of Pochhammer evaluations by factorials. -/\n  multichoose : R → ℕ → R\n  /-- The `n`th ascending Pochhammer polynomial evaluated at any element is divisible by `n!` -/\n  factorial_nsmul_multichoose (r : R) (n : ℕ) :\n    n.factorial • multichoose r n = (ascPochhammer ℕ n).smeval r\n\n"}
{"name":"Ring.nsmul_right_injective","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nn : Nat\nh : Ne n 0\n⊢ Function.Injective fun x => HSMul.hSMul n x","decl":"theorem nsmul_right_injective {n : ℕ} (h : n ≠ 0) :\n    Injective (n • · : R → R) := BinomialRing.nsmul_right_injective h\n\n"}
{"name":"Ring.nsmul_right_inj","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nn : Nat\nh : Ne n 0\na b : R\n⊢ Iff (Eq (HSMul.hSMul n a) (HSMul.hSMul n b)) (Eq a b)","decl":"theorem nsmul_right_inj {n : ℕ} (h : n ≠ 0) {a b : R} : n • a = n • b ↔ a = b :=\n  (nsmul_right_injective h).eq_iff\n\n"}
{"name":"Ring.multichoose_eq_multichoose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\nn : Nat\n⊢ Eq (BinomialRing.multichoose r n) (Ring.multichoose r n)","decl":"@[simp]\ntheorem multichoose_eq_multichoose (r : R) (n : ℕ) :\n    BinomialRing.multichoose r n = multichoose r n := rfl\n\n"}
{"name":"Ring.factorial_nsmul_multichoose_eq_ascPochhammer","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\nn : Nat\n⊢ Eq (HSMul.hSMul n.factorial (Ring.multichoose r n)) ((ascPochhammer Nat n).smeval r)","decl":"theorem factorial_nsmul_multichoose_eq_ascPochhammer (r : R) (n : ℕ) :\n    n.factorial • multichoose r n = (ascPochhammer ℕ n).smeval r :=\n  BinomialRing.factorial_nsmul_multichoose r n\n\n"}
{"name":"Ring.multichoose_zero_right'","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\n⊢ Eq (Ring.multichoose r 0) (HPow.hPow r 0)","decl":"@[simp]\ntheorem multichoose_zero_right' (r : R) : multichoose r 0 = r ^ 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero 0),\n    factorial_nsmul_multichoose_eq_ascPochhammer, ascPochhammer_zero, smeval_one, Nat.factorial]\n\n"}
{"name":"Ring.multichoose_zero_right","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommMonoid R\ninst✝³ : Pow R Nat\ninst✝² : BinomialRing R\ninst✝¹ : MulOneClass R\ninst✝ : NatPowAssoc R\nr : R\n⊢ Eq (Ring.multichoose r 0) 1","decl":"theorem multichoose_zero_right [MulOneClass R] [NatPowAssoc R]\n    (r : R) : multichoose r 0 = 1 := by\n  rw [multichoose_zero_right', npow_zero]\n\n"}
{"name":"Ring.multichoose_one_right'","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : AddCommMonoid R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\n⊢ Eq (Ring.multichoose r 1) (HPow.hPow r 1)","decl":"@[simp]\ntheorem multichoose_one_right' (r : R) : multichoose r 1 = r ^ 1 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero 1),\n    factorial_nsmul_multichoose_eq_ascPochhammer, ascPochhammer_one, smeval_X, Nat.factorial_one,\n    one_smul]\n\n"}
{"name":"Ring.multichoose_one_right","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝⁴ : AddCommMonoid R\ninst✝³ : Pow R Nat\ninst✝² : BinomialRing R\ninst✝¹ : MulOneClass R\ninst✝ : NatPowAssoc R\nr : R\n⊢ Eq (Ring.multichoose r 1) r","decl":"theorem multichoose_one_right [MulOneClass R] [NatPowAssoc R] (r : R) : multichoose r 1 = r := by\n  rw [multichoose_one_right', npow_one]\n\n"}
{"name":"Ring.multichoose_zero_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocSemiring R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nk : Nat\n⊢ Eq (Ring.multichoose 0 (HAdd.hAdd k 1)) 0","decl":"@[simp]\ntheorem multichoose_zero_succ (k : ℕ) : multichoose (0 : R) (k + 1) = 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero (k + 1)),\n    factorial_nsmul_multichoose_eq_ascPochhammer, smul_zero, ascPochhammer_succ_left,\n    smeval_X_mul, zero_mul]\n\n"}
{"name":"Ring.ascPochhammer_succ_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocSemiring R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nr : R\nk : Nat\n⊢ Eq ((ascPochhammer Nat (HAdd.hAdd k 1)).smeval (HAdd.hAdd r 1)) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd k 1).factorial (Ring.multichoose (HAdd.hAdd r 1) k)) ((ascPochhammer Nat (HAdd.hAdd k 1)).smeval r))","decl":"theorem ascPochhammer_succ_succ (r : R) (k : ℕ) :\n    smeval (ascPochhammer ℕ (k + 1)) (r + 1) = Nat.factorial (k + 1) • multichoose (r + 1) k +\n    smeval (ascPochhammer ℕ (k + 1)) r := by\n  nth_rw 1 [ascPochhammer_succ_right, ascPochhammer_succ_left, mul_comm (ascPochhammer ℕ k)]\n  simp only [smeval_mul, smeval_comp, smeval_add, smeval_X]\n  rw [Nat.factorial, mul_smul, factorial_nsmul_multichoose_eq_ascPochhammer]\n  simp only [smeval_one, npow_one, npow_zero, one_smul]\n  rw [← C_eq_natCast, smeval_C, npow_zero, add_assoc, add_mul, add_comm 1, @nsmul_one, add_mul]\n  rw [← @nsmul_eq_mul, @add_rotate', @succ_nsmul, add_assoc]\n  simp_all only [Nat.cast_id, nsmul_eq_mul, one_mul]\n\n"}
{"name":"Ring.multichoose_succ_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocSemiring R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nr : R\nk : Nat\n⊢ Eq (Ring.multichoose (HAdd.hAdd r 1) (HAdd.hAdd k 1)) (HAdd.hAdd (Ring.multichoose r (HAdd.hAdd k 1)) (Ring.multichoose (HAdd.hAdd r 1) k))","decl":"theorem multichoose_succ_succ (r : R) (k : ℕ) :\n    multichoose (r + 1) (k + 1) = multichoose r (k + 1) + multichoose (r + 1) k := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero (k + 1))]\n  simp only [factorial_nsmul_multichoose_eq_ascPochhammer, smul_add]\n  rw [add_comm (smeval (ascPochhammer ℕ (k+1)) r), ascPochhammer_succ_succ r k]\n\n"}
{"name":"Ring.multichoose_one","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocSemiring R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nk : Nat\n⊢ Eq (Ring.multichoose 1 k) 1","decl":"@[simp]\ntheorem multichoose_one (k : ℕ) : multichoose (1 : R) k = 1 := by\n  induction k with\n  | zero => exact multichoose_zero_right 1\n  | succ n ih =>\n    rw [show (1 : R) = 0 + 1 by exact (@zero_add R _ 1).symm, multichoose_succ_succ,\n      multichoose_zero_succ, zero_add, zero_add, ih]\n\n"}
{"name":"Ring.multichoose_two","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocSemiring R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nk : Nat\n⊢ Eq (Ring.multichoose 2 k) (HAdd.hAdd (↑k) 1)","decl":"theorem multichoose_two (k : ℕ) : multichoose (2 : R) k = k + 1 := by\n  induction k with\n  | zero =>\n    rw [multichoose_zero_right, Nat.cast_zero, zero_add]\n  | succ n ih =>\n    rw [one_add_one_eq_two.symm, multichoose_succ_succ, multichoose_one, one_add_one_eq_two, ih,\n      Nat.cast_succ, add_comm]\n\n"}
{"name":"Polynomial.ascPochhammer_smeval_cast","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nS : Type u_2\ninst✝⁴ : NonAssocSemiring S\ninst✝³ : Pow S Nat\ninst✝² : Module R S\ninst✝¹ : IsScalarTower R S S\ninst✝ : NatPowAssoc S\nx : S\nn : Nat\n⊢ Eq ((ascPochhammer R n).smeval x) ((ascPochhammer Nat n).smeval x)","decl":"@[simp]\ntheorem ascPochhammer_smeval_cast (R : Type*) [Semiring R] {S : Type*} [NonAssocSemiring S]\n    [Pow S ℕ] [Module R S] [IsScalarTower R S S] [NatPowAssoc S]\n    (x : S) (n : ℕ) : (ascPochhammer R n).smeval x = (ascPochhammer ℕ n).smeval x := by\n  induction n with\n  | zero => simp only [ascPochhammer_zero, smeval_one, one_smul]\n  | succ n hn =>\n    simp only [ascPochhammer_succ_right, mul_add, smeval_add, smeval_mul_X, ← Nat.cast_comm]\n    simp only [← C_eq_natCast, smeval_C_mul, hn, Nat.cast_smul_eq_nsmul R n]\n    simp only [nsmul_eq_mul, Nat.cast_id]\n\n"}
{"name":"Polynomial.ascPochhammer_smeval_eq_eval","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nn : Nat\n⊢ Eq ((ascPochhammer Nat n).smeval r) (Polynomial.eval r (ascPochhammer R n))","decl":"theorem ascPochhammer_smeval_eq_eval [Semiring R] (r : R) (n : ℕ) :\n    (ascPochhammer ℕ n).smeval r = (ascPochhammer R n).eval r := by\n  rw [eval_eq_smeval, ascPochhammer_smeval_cast R]\n\n"}
{"name":"Polynomial.descPochhammer_smeval_eq_ascPochhammer","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nr : R\nn : Nat\n⊢ Eq ((descPochhammer Int n).smeval r) ((ascPochhammer Nat n).smeval (HAdd.hAdd (HSub.hSub r ↑n) 1))","decl":"theorem descPochhammer_smeval_eq_ascPochhammer (r : R) (n : ℕ) :\n    (descPochhammer ℤ n).smeval r = (ascPochhammer ℕ n).smeval (r - n + 1) := by\n  induction n with\n  | zero => simp only [descPochhammer_zero, ascPochhammer_zero, smeval_one, npow_zero]\n  | succ n ih =>\n    rw [Nat.cast_succ, sub_add, add_sub_cancel_right, descPochhammer_succ_right, smeval_mul, ih,\n      ascPochhammer_succ_left, X_mul, smeval_mul_X, smeval_comp, smeval_sub, ← C_eq_natCast,\n      smeval_add, smeval_one, smeval_C]\n    simp only [smeval_X, npow_one, npow_zero, zsmul_one, Int.cast_natCast, one_smul]\n\n"}
{"name":"Polynomial.descPochhammer_smeval_eq_descFactorial","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nn k : Nat\n⊢ Eq ((descPochhammer Int k).smeval ↑n) ↑(n.descFactorial k)","decl":"theorem descPochhammer_smeval_eq_descFactorial (n k : ℕ) :\n    (descPochhammer ℤ k).smeval (n : R) = n.descFactorial k := by\n  induction k with\n  | zero =>\n    rw [descPochhammer_zero, Nat.descFactorial_zero, Nat.cast_one, smeval_one, npow_zero, one_smul]\n  | succ k ih =>\n    rw [descPochhammer_succ_right, Nat.descFactorial_succ, smeval_mul, ih, mul_comm, Nat.cast_mul,\n      smeval_sub, smeval_X, smeval_natCast, npow_one, npow_zero, nsmul_one]\n    by_cases h : n < k\n    · simp only [Nat.descFactorial_eq_zero_iff_lt.mpr h, Nat.cast_zero, zero_mul]\n    · rw [Nat.cast_sub <| not_lt.mp h]\n\n"}
{"name":"Polynomial.ascPochhammer_smeval_neg_eq_descPochhammer","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nr : R\nk : Nat\n⊢ Eq ((ascPochhammer Nat k).smeval (Neg.neg r)) (HSMul.hSMul (↑k).negOnePow ((descPochhammer Int k).smeval r))","decl":"theorem ascPochhammer_smeval_neg_eq_descPochhammer (r : R) (k : ℕ) :\n    (ascPochhammer ℕ k).smeval (-r) = Int.negOnePow k • (descPochhammer ℤ k).smeval r := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    simp only [ascPochhammer_succ_right, smeval_mul, ih, descPochhammer_succ_right, sub_eq_add_neg]\n    have h : (X + (k : ℕ[X])).smeval (-r) = - (X + (-k : ℤ[X])).smeval r := by\n      simp [smeval_natCast, add_comm]\n    rw [h, ← neg_mul_comm, Int.natCast_add, Int.natCast_one, Int.negOnePow_succ, Units.neg_smul,\n      Units.smul_def, Units.smul_def, ← smul_mul_assoc, neg_mul]\n\n"}
{"name":"Ring.smeval_ascPochhammer_self_neg","module":"Mathlib.RingTheory.Binomial","initialProofState":"n : Nat\n⊢ Eq ((ascPochhammer Nat n).smeval (Neg.neg ↑n)) (HMul.hMul (HPow.hPow (-1) n) ↑n.factorial)","decl":"@[simp]\ntheorem smeval_ascPochhammer_self_neg : ∀ n : ℕ,\n    smeval (ascPochhammer ℕ n) (-n : ℤ) = (-1)^n * n.factorial\n  | 0 => by\n    rw [Nat.cast_zero, neg_zero, ascPochhammer_zero, Nat.factorial_zero, smeval_one, pow_zero,\n      one_smul, pow_zero, Nat.cast_one, one_mul]\n  | n + 1 => by\n    rw [ascPochhammer_succ_left, smeval_X_mul, smeval_comp, smeval_add, smeval_X, smeval_one,\n      pow_zero, pow_one, one_smul, Nat.cast_add, Nat.cast_one, neg_add_rev, neg_add_cancel_comm,\n      smeval_ascPochhammer_self_neg n, ← mul_assoc, mul_comm _ ((-1) ^ n),\n      show (-1 + -↑n = (-1 : ℤ) * (n + 1)) by omega, ← mul_assoc, pow_add, pow_one,\n      Nat.factorial, Nat.cast_mul, ← mul_assoc, Nat.cast_succ]\n\n"}
{"name":"Ring.smeval_ascPochhammer_succ_neg","module":"Mathlib.RingTheory.Binomial","initialProofState":"n : Nat\n⊢ Eq ((ascPochhammer Nat (HAdd.hAdd n 1)).smeval (Neg.neg ↑n)) 0","decl":"@[simp]\ntheorem smeval_ascPochhammer_succ_neg (n : ℕ) :\n    smeval (ascPochhammer ℕ (n + 1)) (-n : ℤ) = 0 := by\n  rw [ascPochhammer_succ_right, smeval_mul, smeval_add, smeval_X, ← C_eq_natCast, smeval_C,\n    pow_zero, pow_one, Nat.cast_id, nsmul_eq_mul, mul_one, neg_add_cancel, mul_zero]\n\n"}
{"name":"Ring.smeval_ascPochhammer_neg_add","module":"Mathlib.RingTheory.Binomial","initialProofState":"n k : Nat\n⊢ Eq ((ascPochhammer Nat (HAdd.hAdd (HAdd.hAdd n k) 1)).smeval (Neg.neg ↑n)) 0","decl":"theorem smeval_ascPochhammer_neg_add (n : ℕ) : ∀ k : ℕ,\n    smeval (ascPochhammer ℕ (n + k + 1)) (-n : ℤ) = 0\n  | 0 => by\n    rw [add_zero, smeval_ascPochhammer_succ_neg]\n  | k + 1 => by\n    rw [ascPochhammer_succ_right, smeval_mul, ← add_assoc, smeval_ascPochhammer_neg_add n k,\n      zero_mul]\n\n"}
{"name":"Ring.smeval_ascPochhammer_neg_of_lt","module":"Mathlib.RingTheory.Binomial","initialProofState":"n k : Nat\nh : LT.lt n k\n⊢ Eq ((ascPochhammer Nat k).smeval (Neg.neg ↑n)) 0","decl":"@[simp]\ntheorem smeval_ascPochhammer_neg_of_lt {n k : ℕ} (h : n < k) :\n    smeval (ascPochhammer ℕ k) (-n : ℤ) = 0 := by\n  rw [show k = n + (k - n - 1) + 1 by omega, smeval_ascPochhammer_neg_add]\n\n"}
{"name":"Ring.smeval_ascPochhammer_nat_cast","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nn k : Nat\n⊢ Eq ((ascPochhammer Nat k).smeval ↑n) ↑((ascPochhammer Nat k).smeval n)","decl":"theorem smeval_ascPochhammer_nat_cast {R} [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R] (n k : ℕ) :\n    smeval (ascPochhammer ℕ k) (n : R) = smeval (ascPochhammer ℕ k) n := by\n  rw [smeval_at_natCast (ascPochhammer ℕ k) n]\n\n"}
{"name":"Ring.multichoose_neg_self","module":"Mathlib.RingTheory.Binomial","initialProofState":"n : Nat\n⊢ Eq (Ring.multichoose (Neg.neg ↑n) n) (HPow.hPow (-1) n)","decl":"theorem multichoose_neg_self (n : ℕ) : multichoose (-n : ℤ) n = (-1)^n := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero _),\n    factorial_nsmul_multichoose_eq_ascPochhammer, smeval_ascPochhammer_self_neg, nsmul_eq_mul,\n    Nat.cast_comm]\n\n"}
{"name":"Ring.multichoose_neg_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"n : Nat\n⊢ Eq (Ring.multichoose (Neg.neg ↑n) (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem multichoose_neg_succ (n : ℕ) : multichoose (-n : ℤ) (n + 1) = 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero _),\n    factorial_nsmul_multichoose_eq_ascPochhammer, smeval_ascPochhammer_succ_neg, smul_zero]\n\n"}
{"name":"Ring.multichoose_neg_add","module":"Mathlib.RingTheory.Binomial","initialProofState":"n k : Nat\n⊢ Eq (Ring.multichoose (Neg.neg ↑n) (HAdd.hAdd (HAdd.hAdd n k) 1)) 0","decl":"theorem multichoose_neg_add (n k : ℕ) : multichoose (-n : ℤ) (n + k + 1) = 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero (n + k + 1)),\n    factorial_nsmul_multichoose_eq_ascPochhammer, smeval_ascPochhammer_neg_add, smul_zero]\n\n"}
{"name":"Ring.multichoose_neg_of_lt","module":"Mathlib.RingTheory.Binomial","initialProofState":"n k : Nat\nh : LT.lt n k\n⊢ Eq (Ring.multichoose (Neg.neg ↑n) k) 0","decl":"@[simp]\ntheorem multichoose_neg_of_lt (n k : ℕ) (h : n < k) : multichoose (-n : ℤ) k = 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero k),\n    factorial_nsmul_multichoose_eq_ascPochhammer, smeval_ascPochhammer_neg_of_lt h, smul_zero]\n\n"}
{"name":"Ring.multichoose_succ_neg_natCast","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nn : Nat\n⊢ Eq (Ring.multichoose (Neg.neg ↑n) (HAdd.hAdd n 1)) 0","decl":"theorem multichoose_succ_neg_natCast [NatPowAssoc R] (n : ℕ) :\n    multichoose (-n : R) (n + 1) = 0 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero (n + 1)), smul_zero,\n    factorial_nsmul_multichoose_eq_ascPochhammer, smeval_neg_nat,\n    smeval_ascPochhammer_succ_neg n, Int.cast_zero]\n\n"}
{"name":"Ring.smeval_ascPochhammer_int_ofNat","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nr : R\nn : Nat\n⊢ Eq ((ascPochhammer Int n).smeval r) ((ascPochhammer Nat n).smeval r)","decl":"theorem smeval_ascPochhammer_int_ofNat {R} [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R] (r : R) :\n    ∀ n : ℕ, smeval (ascPochhammer ℤ n) r = smeval (ascPochhammer ℕ n) r\n  | 0 => by\n    simp only [ascPochhammer_zero, smeval_one]\n  | n + 1 => by\n    simp only [ascPochhammer_succ_right, smeval_mul]\n    rw [smeval_ascPochhammer_int_ofNat r n]\n    simp only [smeval_add, smeval_X, ← C_eq_natCast, smeval_C, natCast_zsmul, nsmul_eq_mul,\n      Nat.cast_id]\n\n"}
{"name":"Ring.descPochhammer_eq_factorial_smul_choose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\nn : Nat\n⊢ Eq ((descPochhammer Int n).smeval r) (HSMul.hSMul n.factorial (Ring.choose r n))","decl":"theorem descPochhammer_eq_factorial_smul_choose [NatPowAssoc R] (r : R) (n : ℕ) :\n    (descPochhammer ℤ n).smeval r = n.factorial • choose r n := by\n  rw [choose, factorial_nsmul_multichoose_eq_ascPochhammer, descPochhammer_eq_ascPochhammer,\n    smeval_comp, add_comm_sub, smeval_add, smeval_X, npow_one]\n  have h : smeval (1 - n : Polynomial ℤ) r = 1 - n := by\n    rw [← C_eq_natCast, ← C_1, ← C_sub, smeval_C]\n    simp only [npow_zero, zsmul_one, Int.cast_sub, Int.cast_one, Int.cast_natCast]\n  rw [h, ascPochhammer_smeval_cast, add_comm_sub]\n\n"}
{"name":"Ring.choose_natCast","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nn k : Nat\n⊢ Eq (Ring.choose (↑n) k) ↑(n.choose k)","decl":"theorem choose_natCast [NatPowAssoc R] (n k : ℕ) : choose (n : R) k = Nat.choose n k := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero k),\n    ← descPochhammer_eq_factorial_smul_choose, nsmul_eq_mul, ← Nat.cast_mul,\n    ← Nat.descFactorial_eq_factorial_mul_choose, ← descPochhammer_smeval_eq_descFactorial]\n\n"}
{"name":"Ring.choose_zero_right'","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\n⊢ Eq (Ring.choose r 0) (HPow.hPow (HAdd.hAdd r 1) 0)","decl":"@[simp]\ntheorem choose_zero_right' (r : R) : choose r 0 = (r + 1) ^ 0 := by\n  dsimp only [choose]\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero 0)]\n  simp [factorial_nsmul_multichoose_eq_ascPochhammer]\n\n"}
{"name":"Ring.choose_zero_right","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\n⊢ Eq (Ring.choose r 0) 1","decl":"theorem choose_zero_right [NatPowAssoc R] (r : R) : choose r 0 = 1 := by\n  rw [choose_zero_right', npow_zero]\n\n"}
{"name":"Ring.choose_zero_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nn : Nat\n⊢ Eq (Ring.choose 0 (HAdd.hAdd n 1)) 0","decl":"@[simp]\ntheorem choose_zero_succ (R) [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R] [BinomialRing R]\n    (n : ℕ) : choose (0 : R) (n + 1) = 0 := by\n  rw [choose, Nat.cast_succ, zero_sub, neg_add, neg_add_cancel_right, multichoose_succ_neg_natCast]\n\n"}
{"name":"Ring.choose_zero_pos","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nk : Nat\nh_pos : LT.lt 0 k\n⊢ Eq (Ring.choose 0 k) 0","decl":"theorem choose_zero_pos (R) [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R] [BinomialRing R]\n    {k : ℕ} (h_pos: 0 < k) : choose (0 : R) k = 0 := by\n  rw [← Nat.succ_pred_eq_of_pos h_pos, choose_zero_succ]\n\n"}
{"name":"Ring.choose_zero_ite","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : NatPowAssoc R\ninst✝ : BinomialRing R\nk : Nat\n⊢ Eq (Ring.choose 0 k) (ite (Eq k 0) 1 0)","decl":"theorem choose_zero_ite (R) [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R] [BinomialRing R]\n    (k : ℕ) : choose (0 : R) k = if k = 0 then 1 else 0 := by\n  split_ifs with hk\n  · rw [hk, choose_zero_right]\n  · rw [choose_zero_pos R <| Nat.pos_of_ne_zero hk]\n\n"}
{"name":"Ring.choose_one_right'","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : BinomialRing R\nr : R\n⊢ Eq (Ring.choose r 1) (HPow.hPow r 1)","decl":"@[simp]\ntheorem choose_one_right' (r : R) : choose r 1 = r ^ 1 := by\n  rw [choose, Nat.cast_one, sub_add_cancel, multichoose_one_right']\n\n"}
{"name":"Ring.choose_one_right","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\n⊢ Eq (Ring.choose r 1) r","decl":"theorem choose_one_right [NatPowAssoc R] (r : R) : choose r 1 = r := by\n  rw [choose_one_right', npow_one]\n\n"}
{"name":"Ring.choose_neg","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\nn : Nat\n⊢ Eq (Ring.choose (Neg.neg r) n) (HSMul.hSMul (↑n).negOnePow (Ring.choose (HSub.hSub (HAdd.hAdd r ↑n) 1) n))","decl":"theorem choose_neg [NatPowAssoc R] (r : R) (n : ℕ) :\n    choose (-r) n = Int.negOnePow n • choose (r + n - 1) n := by\n  apply (nsmul_right_inj (Nat.factorial_ne_zero n)).mp\n  rw [← descPochhammer_eq_factorial_smul_choose, smul_comm,\n    ← descPochhammer_eq_factorial_smul_choose, descPochhammer_smeval_eq_ascPochhammer,\n    show (-r - n + 1) = -(r + n - 1) by abel, ascPochhammer_smeval_neg_eq_descPochhammer]\n\n"}
{"name":"Ring.descPochhammer_succ_succ_smeval","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_2\ninst✝² : NonAssocRing R\ninst✝¹ : Pow R Nat\ninst✝ : NatPowAssoc R\nr : R\nk : Nat\n⊢ Eq ((descPochhammer Int (HAdd.hAdd k 1)).smeval (HAdd.hAdd r 1)) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd k 1) ((descPochhammer Int k).smeval r)) ((descPochhammer Int (HAdd.hAdd k 1)).smeval r))","decl":"theorem descPochhammer_succ_succ_smeval {R} [NonAssocRing R] [Pow R ℕ] [NatPowAssoc R]\n    (r : R) (k : ℕ) : smeval (descPochhammer ℤ (k + 1)) (r + 1) =\n    (k + 1) • smeval (descPochhammer ℤ k) r + smeval (descPochhammer ℤ (k + 1)) r := by\n  nth_rw 1 [descPochhammer_succ_left]\n  rw [descPochhammer_succ_right, mul_comm (descPochhammer ℤ k)]\n  simp only [smeval_comp, smeval_sub, smeval_add, smeval_mul, smeval_X, smeval_one, npow_one,\n    npow_zero, one_smul, add_sub_cancel_right, sub_mul, add_mul, add_smul, one_mul]\n  rw [← C_eq_natCast, smeval_C, npow_zero, add_comm (k • smeval (descPochhammer ℤ k) r) _,\n    add_assoc, add_comm (k • smeval (descPochhammer ℤ k) r) _, ← add_assoc,  ← add_sub_assoc,\n    nsmul_eq_mul, zsmul_one, Int.cast_natCast, sub_add_cancel, add_comm]\n\n"}
{"name":"Ring.choose_succ_succ","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\nk : Nat\n⊢ Eq (Ring.choose (HAdd.hAdd r 1) (HAdd.hAdd k 1)) (HAdd.hAdd (Ring.choose r k) (Ring.choose r (HAdd.hAdd k 1)))","decl":"theorem choose_succ_succ [NatPowAssoc R] (r : R) (k : ℕ) :\n    choose (r + 1) (k + 1) = choose r k + choose r (k + 1) := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero (k + 1))]\n  simp only [smul_add, ← descPochhammer_eq_factorial_smul_choose]\n  rw [Nat.factorial_succ, mul_smul,\n    ← descPochhammer_eq_factorial_smul_choose r, descPochhammer_succ_succ_smeval r k]\n\n"}
{"name":"Ring.choose_eq_nat_choose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nn k : Nat\n⊢ Eq (Ring.choose (↑n) k) ↑(n.choose k)","decl":"theorem choose_eq_nat_choose [NatPowAssoc R] (n k : ℕ) : choose (n : R) k = Nat.choose n k := by\n  induction n generalizing k with\n  | zero => cases k with\n    | zero => rw [choose_zero_right, Nat.choose_zero_right, Nat.cast_one]\n    | succ k => rw [Nat.cast_zero, choose_zero_succ, Nat.choose_zero_succ, Nat.cast_zero]\n  | succ n ih => cases k with\n    | zero => rw [choose_zero_right, Nat.choose_zero_right, Nat.cast_one]\n    | succ k => rw [Nat.cast_succ, choose_succ_succ, ih, ih, Nat.choose_succ_succ, Nat.cast_add]\n\n"}
{"name":"Ring.choose_smul_choose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\nn k : Nat\nhkn : LE.le k n\n⊢ Eq (HSMul.hSMul (n.choose k) (Ring.choose r n)) (HMul.hMul (Ring.choose r k) (Ring.choose (HSub.hSub r ↑k) (HSub.hSub n k)))","decl":"theorem choose_smul_choose [NatPowAssoc R] (r : R) {n k : ℕ} (hkn : k ≤ n) :\n    (Nat.choose n k) • choose r n = choose r k * choose (r - k) (n - k) := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero n),\n    nsmul_left_comm, ← descPochhammer_eq_factorial_smul_choose,\n    ← Nat.choose_mul_factorial_mul_factorial hkn, ← smul_mul_smul_comm,\n    ← descPochhammer_eq_factorial_smul_choose, mul_nsmul',\n    ← descPochhammer_eq_factorial_smul_choose, smul_mul_assoc]\n  nth_rw 2 [← Nat.sub_add_cancel hkn]\n  rw [add_comm, ← descPochhammer_mul, smeval_mul, smeval_comp, smeval_sub, smeval_X,\n    ← C_eq_natCast, smeval_C, npow_one, npow_zero, zsmul_one, Int.cast_natCast, nsmul_eq_mul]\n\n"}
{"name":"Ring.choose_add_smul_choose","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝³ : NonAssocRing R\ninst✝² : Pow R Nat\ninst✝¹ : BinomialRing R\ninst✝ : NatPowAssoc R\nr : R\nn k : Nat\n⊢ Eq (HSMul.hSMul ((HAdd.hAdd n k).choose k) (Ring.choose (HAdd.hAdd r ↑k) (HAdd.hAdd n k))) (HMul.hMul (Ring.choose (HAdd.hAdd r ↑k) k) (Ring.choose r n))","decl":"theorem choose_add_smul_choose [NatPowAssoc R] (r : R) (n k : ℕ) :\n    (Nat.choose (n + k) k) • choose (r + k) (n + k) = choose (r + k) k * choose r n := by\n  rw [choose_smul_choose (r + k) (Nat.le_add_left k n), Nat.add_sub_cancel,\n    add_sub_cancel_right]\n\n"}
{"name":"Ring.descPochhammer_smeval_add","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr s : R\nk : Nat\nh : Commute r s\n⊢ Eq ((descPochhammer Int k).smeval (HAdd.hAdd r s)) ((Finset.HasAntidiagonal.antidiagonal k).sum fun ij => HMul.hMul (↑(k.choose ij.1)) (HMul.hMul ((descPochhammer Int ij.1).smeval r) ((descPochhammer Int ij.2).smeval s)))","decl":"/-- Pochhammer version of Chu-Vandermonde identity -/\ntheorem descPochhammer_smeval_add [Ring R] {r s : R} (k : ℕ) (h: Commute r s) :\n    (descPochhammer ℤ k).smeval (r + s) = ∑ ij ∈ antidiagonal k,\n    Nat.choose k ij.1 * ((descPochhammer ℤ ij.1).smeval r * (descPochhammer ℤ ij.2).smeval s) := by\n  induction k with\n  | zero => simp\n  | succ k ih =>\n    rw [descPochhammer_succ_right, mul_comm, smeval_mul, sum_antidiagonal_choose_succ_mul\n      fun i j => ((descPochhammer ℤ i).smeval r * (descPochhammer ℤ j).smeval s),\n      ← sum_add_distrib, smeval_sub, smeval_X, smeval_natCast, pow_zero, pow_one, ih, mul_sum]\n    refine sum_congr rfl ?_\n    intro ij hij -- try to move descPochhammers to right, gather multipliers.\n    have hdx : (descPochhammer ℤ ij.1).smeval r * (X - (ij.2 : ℤ[X])).smeval s =\n        (X - (ij.2 : ℤ[X])).smeval s * (descPochhammer ℤ ij.1).smeval r := by\n      refine (commute_iff_eq ((descPochhammer ℤ ij.1).smeval r)\n        ((X - (ij.2 : ℤ[X])).smeval s)).mp ?_\n      exact smeval_commute ℤ (descPochhammer ℤ ij.1) (X - (ij.2 : ℤ[X])) h\n    rw [descPochhammer_succ_right, mul_comm, smeval_mul, descPochhammer_succ_right, mul_comm,\n      smeval_mul, ← mul_assoc ((descPochhammer ℤ ij.1).smeval r), hdx]\n    simp only [mul_assoc _ ((descPochhammer ℤ ij.1).smeval r) _,\n      ← mul_assoc _ _ (((descPochhammer ℤ ij.1).smeval r) * _)]\n    have hl : (r + s - k • 1) * (k.choose ij.1) = (k.choose ij.1) * (X - (ij.2 : ℤ[X])).smeval s +\n        ↑(k.choose ij.2) * (X - (ij.1 : ℤ[X])).smeval r := by\n      simp only [smeval_sub, smeval_X, pow_one, smeval_natCast, pow_zero, ← mul_sub]\n      rw [← Nat.choose_symm_of_eq_add (List.Nat.mem_antidiagonal.mp hij).symm,\n        (List.Nat.mem_antidiagonal.mp hij).symm, ← mul_add, Nat.cast_comm, add_smul]\n      abel_nf\n    rw [hl, ← add_mul]\n\n"}
{"name":"Ring.add_choose_eq","module":"Mathlib.RingTheory.Binomial","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : BinomialRing R\nr s : R\nk : Nat\nh : Commute r s\n⊢ Eq (Ring.choose (HAdd.hAdd r s) k) ((Finset.HasAntidiagonal.antidiagonal k).sum fun ij => HMul.hMul (Ring.choose r ij.1) (Ring.choose s ij.2))","decl":"/-- The Chu-Vandermonde identity for binomial rings -/\ntheorem add_choose_eq [Ring R] [BinomialRing R] {r s : R} (k : ℕ) (h : Commute r s) :\n    choose (r + s) k =\n      ∑ ij ∈ antidiagonal k, choose r ij.1 * choose s ij.2 := by\n  rw [← nsmul_right_inj (Nat.factorial_ne_zero k),\n    ← descPochhammer_eq_factorial_smul_choose, smul_sum, descPochhammer_smeval_add _ h]\n  refine sum_congr rfl ?_\n  intro x hx\n  rw [← Nat.choose_mul_factorial_mul_factorial (antidiagonal.fst_le hx),\n    tsub_eq_of_eq_add_rev (List.Nat.mem_antidiagonal.mp hx).symm, mul_assoc, nsmul_eq_mul,\n    Nat.cast_mul, Nat.cast_mul, ← mul_assoc _ (x.1.factorial : R), mul_assoc _ (x.2.factorial : R),\n    ← mul_assoc (x.2.factorial : R), Nat.cast_commute x.2.factorial,\n    mul_assoc _ (x.2.factorial : R), ← nsmul_eq_mul x.2.factorial]\n  simp [mul_assoc, descPochhammer_eq_factorial_smul_choose]\n\n"}
