{"name":"ContinuousLinearMap.NonlinearRightInverse.bound'","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nself : f.NonlinearRightInverse\ny : F\n‚ä¢ LE.le (Norm.norm (self.toFun y)) (HMul.hMul (‚Üëself.nnnorm) (Norm.norm y))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `‚Äñinverse x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F ‚Üí E\n  nnnorm : ‚Ñù‚â•0\n  bound' : ‚àÄ y, ‚ÄñtoFun y‚Äñ ‚â§ nnnorm * ‚Äñy‚Äñ\n  right_inv' : ‚àÄ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.inj","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\ntoFun‚úù : F ‚Üí E\nnnnorm‚úù : NNReal\nbound'‚úù : ‚àÄ (y : F), LE.le (Norm.norm (toFun‚úù y)) (HMul.hMul (‚Üënnnorm‚úù) (Norm.norm y))\nright_inv'‚úù : ‚àÄ (y : F), Eq (f (toFun‚úù y)) y\ntoFun : F ‚Üí E\nnnnorm : NNReal\nbound' : ‚àÄ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (‚Üënnnorm) (Norm.norm y))\nright_inv' : ‚àÄ (y : F), Eq (f (toFun y)) y\nx‚úù : Eq { toFun := toFun‚úù, nnnorm := nnnorm‚úù, bound' := bound'‚úù, right_inv' := right_inv'‚úù } { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }\n‚ä¢ And (Eq toFun‚úù toFun) (Eq nnnorm‚úù nnnorm)","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `‚Äñinverse x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F ‚Üí E\n  nnnorm : ‚Ñù‚â•0\n  bound' : ‚àÄ y, ‚ÄñtoFun y‚Äñ ‚â§ nnnorm * ‚Äñy‚Äñ\n  right_inv' : ‚àÄ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åπ : NontriviallyNormedField ùïú\ninst‚úù‚Å∏ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\ninst‚úù¬≥ : SizeOf ùïú\ninst‚úù¬≤ : SizeOf ùïú'\ninst‚úù¬π : SizeOf E\ninst‚úù : SizeOf F\ntoFun : F ‚Üí E\nnnnorm : NNReal\nbound' : ‚àÄ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (‚Üënnnorm) (Norm.norm y))\nright_inv' : ‚àÄ (y : F), Eq (f (toFun y)) y\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }) (HAdd.hAdd 1 (SizeOf.sizeOf nnnorm))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `‚Äñinverse x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F ‚Üí E\n  nnnorm : ‚Ñù‚â•0\n  bound' : ‚àÄ y, ‚ÄñtoFun y‚Äñ ‚â§ nnnorm * ‚Äñy‚Äñ\n  right_inv' : ‚àÄ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.right_inv'","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nself : f.NonlinearRightInverse\ny : F\n‚ä¢ Eq (f (self.toFun y)) y","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `‚Äñinverse x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F ‚Üí E\n  nnnorm : ‚Ñù‚â•0\n  bound' : ‚àÄ y, ‚ÄñtoFun y‚Äñ ‚â§ nnnorm * ‚Äñy‚Äñ\n  right_inv' : ‚àÄ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.injEq","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\ntoFun‚úù : F ‚Üí E\nnnnorm‚úù : NNReal\nbound'‚úù : ‚àÄ (y : F), LE.le (Norm.norm (toFun‚úù y)) (HMul.hMul (‚Üënnnorm‚úù) (Norm.norm y))\nright_inv'‚úù : ‚àÄ (y : F), Eq (f (toFun‚úù y)) y\ntoFun : F ‚Üí E\nnnnorm : NNReal\nbound' : ‚àÄ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (‚Üënnnorm) (Norm.norm y))\nright_inv' : ‚àÄ (y : F), Eq (f (toFun y)) y\n‚ä¢ Eq (Eq { toFun := toFun‚úù, nnnorm := nnnorm‚úù, bound' := bound'‚úù, right_inv' := right_inv'‚úù } { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }) (And (Eq toFun‚úù toFun) (Eq nnnorm‚úù nnnorm))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `‚Äñinverse x‚Äñ ‚â§ C * ‚Äñx‚Äñ`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F ‚Üí E\n  nnnorm : ‚Ñù‚â•0\n  bound' : ‚àÄ y, ‚ÄñtoFun y‚Äñ ‚â§ nnnorm * ‚Äñy‚Äñ\n  right_inv' : ‚àÄ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.right_inv","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nfsymm : f.NonlinearRightInverse\ny : F\n‚ä¢ Eq (f (fsymm.toFun y)) y","decl":"@[simp]\ntheorem NonlinearRightInverse.right_inv {f : E ‚ÜíSL[œÉ] F} (fsymm : NonlinearRightInverse f) (y : F) :\n    f (fsymm y) = y :=\n  fsymm.right_inv' y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.bound","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åµ : NontriviallyNormedField ùïú\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nfsymm : f.NonlinearRightInverse\ny : F\n‚ä¢ LE.le (Norm.norm (fsymm.toFun y)) (HMul.hMul (‚Üëfsymm.nnnorm) (Norm.norm y))","decl":"theorem NonlinearRightInverse.bound {f : E ‚ÜíSL[œÉ] F} (fsymm : NonlinearRightInverse f) (y : F) :\n    ‚Äñfsymm y‚Äñ ‚â§ fsymm.nnnorm * ‚Äñy‚Äñ :=\n  fsymm.bound' y\n\n"}
{"name":"ContinuousLinearMap.exists_approx_preimage_norm_le","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Åπ : NontriviallyNormedField ùïú\ninst‚úù‚Å∏ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù¬≥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≤ : RingHomIsometric œÉ\ninst‚úù¬π : RingHomIsometric œÉ'\ninst‚úù : CompleteSpace F\nsurj : Function.Surjective ‚áëf\n‚ä¢ Exists fun C => And (GE.ge C 0) (‚àÄ (y : F), Exists fun x => And (LE.le (Dist.dist (f x) y) (HMul.hMul (1 / 2) (Norm.norm y))) (LE.le (Norm.norm x) (HMul.hMul C (Norm.norm y))))","decl":"include œÉ' in\n/-- First step of the proof of the Banach open mapping theorem (using completeness of `F`):\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\nRescaling everything, it follows that any `y ‚àà F` is arbitrarily well approached by\nimages of elements of norm at most `C * ‚Äñy‚Äñ`.\nFor further use, we will only need such an element whose image\nis within distance `‚Äñy‚Äñ/2` of `y`, to apply an iterative process. -/\ntheorem exists_approx_preimage_norm_le (surj : Surjective f) :\n    ‚àÉ C ‚â• 0, ‚àÄ y, ‚àÉ x, dist (f x) y ‚â§ 1 / 2 * ‚Äñy‚Äñ ‚àß ‚Äñx‚Äñ ‚â§ C * ‚Äñy‚Äñ := by\n  have A : ‚ãÉ n : ‚Ñï, closure (f '' ball 0 n) = Set.univ := by\n    refine Subset.antisymm (subset_univ _) fun y _ => ?_\n    rcases surj y with ‚ü®x, hx‚ü©\n    rcases exists_nat_gt ‚Äñx‚Äñ with ‚ü®n, hn‚ü©\n    refine mem_iUnion.2 ‚ü®n, subset_closure ?_‚ü©\n    refine (mem_image _ _ _).2 ‚ü®x, ‚ü®?_, hx‚ü©‚ü©\n    rwa [mem_ball, dist_eq_norm, sub_zero]\n  have : ‚àÉ (n : ‚Ñï) (x : _), x ‚àà interior (closure (f '' ball 0 n)) :=\n    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A\n  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this\n  rcases this with ‚ü®n, a, Œµ, ‚ü®Œµpos, H‚ü©‚ü©\n  rcases NormedField.exists_one_lt_norm ùïú with ‚ü®c, hc‚ü©\n  refine ‚ü®(Œµ / 2)‚Åª¬π * ‚Äñc‚Äñ * 2 * n, by positivity, fun y => ?_‚ü©\n  rcases eq_or_ne y 0 with rfl | hy\n  ¬∑ use 0\n    simp\n  ¬∑ have hc' : 1 < ‚ÄñœÉ c‚Äñ := by simp only [RingHomIsometric.is_iso, hc]\n    rcases rescale_to_shell hc' (half_pos Œµpos) hy with ‚ü®d, hd, ydlt, -, dinv‚ü©\n    let Œ¥ := ‚Äñd‚Äñ * ‚Äñy‚Äñ / 4\n    have Œ¥pos : 0 < Œ¥ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)\n    have : a + d ‚Ä¢ y ‚àà ball a Œµ := by\n      simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Œµpos)]\n    rcases Metric.mem_closure_iff.1 (H this) _ Œ¥pos with ‚ü®z‚ÇÅ, z‚ÇÅim, h‚ÇÅ‚ü©\n    rcases (mem_image _ _ _).1 z‚ÇÅim with ‚ü®x‚ÇÅ, hx‚ÇÅ, xz‚ÇÅ‚ü©\n    rw [‚Üê xz‚ÇÅ] at h‚ÇÅ\n    rw [mem_ball, dist_eq_norm, sub_zero] at hx‚ÇÅ\n    have : a ‚àà ball a Œµ := by\n      simp only [mem_ball, dist_self]\n      exact Œµpos\n    rcases Metric.mem_closure_iff.1 (H this) _ Œ¥pos with ‚ü®z‚ÇÇ, z‚ÇÇim, h‚ÇÇ‚ü©\n    rcases (mem_image _ _ _).1 z‚ÇÇim with ‚ü®x‚ÇÇ, hx‚ÇÇ, xz‚ÇÇ‚ü©\n    rw [‚Üê xz‚ÇÇ] at h‚ÇÇ\n    rw [mem_ball, dist_eq_norm, sub_zero] at hx‚ÇÇ\n    let x := x‚ÇÅ - x‚ÇÇ\n    have I : ‚Äñf x - d ‚Ä¢ y‚Äñ ‚â§ 2 * Œ¥ :=\n      calc\n        ‚Äñf x - d ‚Ä¢ y‚Äñ = ‚Äñf x‚ÇÅ - (a + d ‚Ä¢ y) - (f x‚ÇÇ - a)‚Äñ := by\n          congr 1\n          simp only [x, f.map_sub]\n          abel\n        _ ‚â§ ‚Äñf x‚ÇÅ - (a + d ‚Ä¢ y)‚Äñ + ‚Äñf x‚ÇÇ - a‚Äñ := norm_sub_le _ _\n        _ ‚â§ Œ¥ + Œ¥ := by rw [dist_eq_norm'] at h‚ÇÅ h‚ÇÇ; gcongr\n        _ = 2 * Œ¥ := (two_mul _).symm\n    have J : ‚Äñf (œÉ' d‚Åª¬π ‚Ä¢ x) - y‚Äñ ‚â§ 1 / 2 * ‚Äñy‚Äñ :=\n      calc\n        ‚Äñf (œÉ' d‚Åª¬π ‚Ä¢ x) - y‚Äñ = ‚Äñd‚Åª¬π ‚Ä¢ f x - (d‚Åª¬π * d) ‚Ä¢ y‚Äñ := by\n          rwa [f.map_smul‚Çõ‚Çó _, inv_mul_cancel‚ÇÄ, one_smul, map_inv‚ÇÄ, map_inv‚ÇÄ,\n            RingHomCompTriple.comp_apply, RingHom.id_apply]\n        _ = ‚Äñd‚Åª¬π ‚Ä¢ (f x - d ‚Ä¢ y)‚Äñ := by rw [mul_smul, smul_sub]\n        _ = ‚Äñd‚Äñ‚Åª¬π * ‚Äñf x - d ‚Ä¢ y‚Äñ := by rw [norm_smul, norm_inv]\n        _ ‚â§ ‚Äñd‚Äñ‚Åª¬π * (2 * Œ¥) := by gcongr\n        _ = ‚Äñd‚Äñ‚Åª¬π * ‚Äñd‚Äñ * ‚Äñy‚Äñ / 2 := by\n          simp only [Œ¥]\n          ring\n        _ = ‚Äñy‚Äñ / 2 := by\n          rw [inv_mul_cancel‚ÇÄ, one_mul]\n          simp [norm_eq_zero, hd]\n        _ = 1 / 2 * ‚Äñy‚Äñ := by ring\n    rw [‚Üê dist_eq_norm] at J\n    have K : ‚ÄñœÉ' d‚Åª¬π ‚Ä¢ x‚Äñ ‚â§ (Œµ / 2)‚Åª¬π * ‚Äñc‚Äñ * 2 * ‚Üën * ‚Äñy‚Äñ :=\n      calc\n        ‚ÄñœÉ' d‚Åª¬π ‚Ä¢ x‚Äñ = ‚Äñd‚Äñ‚Åª¬π * ‚Äñx‚ÇÅ - x‚ÇÇ‚Äñ := by rw [norm_smul, RingHomIsometric.is_iso, norm_inv]\n        _ ‚â§ (Œµ / 2)‚Åª¬π * ‚Äñc‚Äñ * ‚Äñy‚Äñ * (n + n) := by\n          gcongr\n          ¬∑ simpa using dinv\n          ¬∑ exact le_trans (norm_sub_le _ _) (by gcongr)\n        _ = (Œµ / 2)‚Åª¬π * ‚Äñc‚Äñ * 2 * ‚Üën * ‚Äñy‚Äñ := by ring\n    exact ‚ü®œÉ' d‚Åª¬π ‚Ä¢ x, J, K‚ü©\n\n"}
{"name":"ContinuousLinearMap.exists_preimage_norm_le","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nsurj : Function.Surjective ‚áëf\n‚ä¢ Exists fun C => And (GT.gt C 0) (‚àÄ (y : F), Exists fun x => And (Eq (f x) y) (LE.le (Norm.norm x) (HMul.hMul C (Norm.norm y))))","decl":"/-- The Banach open mapping theorem: if a bounded linear map between Banach spaces is onto, then\nany point has a preimage with controlled norm. -/\ntheorem exists_preimage_norm_le (surj : Surjective f) :\n    ‚àÉ C > 0, ‚àÄ y, ‚àÉ x, f x = y ‚àß ‚Äñx‚Äñ ‚â§ C * ‚Äñy‚Äñ := by\n  obtain ‚ü®C, C0, hC‚ü© := exists_approx_preimage_norm_le f surj\n  /- Second step of the proof: starting from `y`, we want an exact preimage of `y`. Let `g y` be\n    the approximate preimage of `y` given by the first step, and `h y = y - f(g y)` the part that\n    has no preimage yet. We will iterate this process, taking the approximate preimage of `h y`,\n    leaving only `h^2 y` without preimage yet, and so on. Let `u n` be the approximate preimage\n    of `h^n y`. Then `u` is a converging series, and by design the sum of the series is a\n    preimage of `y`. This uses completeness of `E`. -/\n  choose g hg using hC\n  let h y := y - f (g y)\n  have hle : ‚àÄ y, ‚Äñh y‚Äñ ‚â§ 1 / 2 * ‚Äñy‚Äñ := by\n    intro y\n    rw [‚Üê dist_eq_norm, dist_comm]\n    exact (hg y).1\n  refine ‚ü®2 * C + 1, by linarith, fun y => ?_‚ü©\n  have hnle : ‚àÄ n : ‚Ñï, ‚Äñh^[n] y‚Äñ ‚â§ (1 / 2) ^ n * ‚Äñy‚Äñ := by\n    intro n\n    induction n with\n    | zero => simp only [one_div, one_mul, iterate_zero_apply, pow_zero, le_rfl]\n    | succ n IH =>\n      rw [iterate_succ']\n      apply le_trans (hle _) _\n      rw [pow_succ', mul_assoc]\n      gcongr\n  let u n := g (h^[n] y)\n  have ule : ‚àÄ n, ‚Äñu n‚Äñ ‚â§ (1 / 2) ^ n * (C * ‚Äñy‚Äñ) := fun n ‚Ü¶ by\n    apply le_trans (hg _).2\n    calc\n      C * ‚Äñh^[n] y‚Äñ ‚â§ C * ((1 / 2) ^ n * ‚Äñy‚Äñ) := mul_le_mul_of_nonneg_left (hnle n) C0\n      _ = (1 / 2) ^ n * (C * ‚Äñy‚Äñ) := by ring\n  have sNu : Summable fun n => ‚Äñu n‚Äñ := by\n    refine .of_nonneg_of_le (fun n => norm_nonneg _) ule ?_\n    exact Summable.mul_right _ (summable_geometric_of_lt_one (by norm_num) (by norm_num))\n  have su : Summable u := sNu.of_norm\n  let x := tsum u\n  have x_ineq : ‚Äñx‚Äñ ‚â§ (2 * C + 1) * ‚Äñy‚Äñ :=\n    calc\n      ‚Äñx‚Äñ ‚â§ ‚àë' n, ‚Äñu n‚Äñ := norm_tsum_le_tsum_norm sNu\n      _ ‚â§ ‚àë' n, (1 / 2) ^ n * (C * ‚Äñy‚Äñ) :=\n        tsum_le_tsum ule sNu (Summable.mul_right _ summable_geometric_two)\n      _ = (‚àë' n, (1 / 2) ^ n) * (C * ‚Äñy‚Äñ) := tsum_mul_right\n      _ = 2 * C * ‚Äñy‚Äñ := by rw [tsum_geometric_two, mul_assoc]\n      _ ‚â§ 2 * C * ‚Äñy‚Äñ + ‚Äñy‚Äñ := le_add_of_nonneg_right (norm_nonneg y)\n      _ = (2 * C + 1) * ‚Äñy‚Äñ := by ring\n  have fsumeq : ‚àÄ n : ‚Ñï, f (‚àë i ‚àà Finset.range n, u i) = y - h^[n] y := by\n    intro n\n    induction n with\n    | zero => simp [f.map_zero]\n    | succ n IH => rw [sum_range_succ, f.map_add, IH, iterate_succ_apply', sub_add]\n  have : Tendsto (fun n => ‚àë i ‚àà Finset.range n, u i) atTop (ùìù x) := su.hasSum.tendsto_sum_nat\n  have L‚ÇÅ : Tendsto (fun n => f (‚àë i ‚àà Finset.range n, u i)) atTop (ùìù (f x)) :=\n    (f.continuous.tendsto _).comp this\n  simp only [fsumeq] at L‚ÇÅ\n  have L‚ÇÇ : Tendsto (fun n => y - h^[n] y) atTop (ùìù (y - 0)) := by\n    refine tendsto_const_nhds.sub ?_\n    rw [tendsto_iff_norm_sub_tendsto_zero]\n    simp only [sub_zero]\n    refine squeeze_zero (fun _ => norm_nonneg _) hnle ?_\n    rw [‚Üê zero_mul ‚Äñy‚Äñ]\n    refine (_root_.tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num\n  have feq : f x = y - 0 := tendsto_nhds_unique L‚ÇÅ L‚ÇÇ\n  rw [sub_zero] at feq\n  exact ‚ü®x, feq, x_ineq‚ü©\n\n"}
{"name":"ContinuousLinearMap.isOpenMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nsurj : Function.Surjective ‚áëf\n‚ä¢ IsOpenMap ‚áëf","decl":"/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\nprotected theorem isOpenMap (surj : Surjective f) : IsOpenMap f := by\n  intro s hs\n  rcases exists_preimage_norm_le f surj with ‚ü®C, Cpos, hC‚ü©\n  refine isOpen_iff.2 fun y yfs => ?_\n  rcases yfs with ‚ü®x, xs, fxy‚ü©\n  rcases isOpen_iff.1 hs x xs with ‚ü®Œµ, Œµpos, hŒµ‚ü©\n  refine ‚ü®Œµ / C, div_pos Œµpos Cpos, fun z hz => ?_‚ü©\n  rcases hC (z - y) with ‚ü®w, wim, wnorm‚ü©\n  have : f (x + w) = z := by rw [f.map_add, wim, fxy, add_sub_cancel]\n  rw [‚Üê this]\n  have : x + w ‚àà ball x Œµ :=\n    calc\n      dist (x + w) x = ‚Äñw‚Äñ := by\n        rw [dist_eq_norm]\n        simp\n      _ ‚â§ C * ‚Äñz - y‚Äñ := wnorm\n      _ < C * (Œµ / C) := by\n        apply mul_lt_mul_of_pos_left _ Cpos\n        rwa [mem_ball, dist_eq_norm] at hz\n      _ = Œµ := mul_div_cancel‚ÇÄ _ (ne_of_gt Cpos)\n\n  exact Set.mem_image_of_mem _ (hŒµ this)\n\n"}
{"name":"ContinuousLinearMap.isQuotientMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nsurj : Function.Surjective ‚áëf\n‚ä¢ Topology.IsQuotientMap ‚áëf","decl":"theorem isQuotientMap (surj : Surjective f) : IsQuotientMap f :=\n  (f.isOpenMap surj).isQuotientMap f.continuous surj\n\n"}
{"name":"ContinuousLinearMap.quotientMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nsurj : Function.Surjective ‚áëf\n‚ä¢ Topology.IsQuotientMap ‚áëf","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap := isQuotientMap\n\n"}
{"name":"AffineMap.isOpenMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\ninst‚úù‚Å∑ : CompleteSpace E\nF : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú F\ninst‚úù‚Å¥ : CompleteSpace F\nP : Type u_6\nQ : Type u_7\ninst‚úù¬≥ : MetricSpace P\ninst‚úù¬≤ : NormedAddTorsor E P\ninst‚úù¬π : MetricSpace Q\ninst‚úù : NormedAddTorsor F Q\nf : AffineMap ùïú P Q\nhf : Continuous ‚áëf\nsurj : Function.Surjective ‚áëf\n‚ä¢ IsOpenMap ‚áëf","decl":"theorem _root_.AffineMap.isOpenMap {F : Type*} [NormedAddCommGroup F] [NormedSpace ùïú F]\n    [CompleteSpace F] {P Q : Type*} [MetricSpace P] [NormedAddTorsor E P] [MetricSpace Q]\n    [NormedAddTorsor F Q] (f : P ‚Üí·µÉ[ùïú] Q) (hf : Continuous f) (surj : Surjective f) :\n    IsOpenMap f :=\n  AffineMap.isOpenMap_linear_iff.mp <|\n    ContinuousLinearMap.isOpenMap { f.linear with cont := AffineMap.continuous_linear_iff.mpr hf }\n      (f.linear_surjective_iff.mpr surj)\n\n"}
{"name":"ContinuousLinearMap.interior_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nhsurj : Function.Surjective ‚áëf\ns : Set F\n‚ä¢ Eq (interior (Set.preimage (‚áëf) s)) (Set.preimage (‚áëf) (interior s))","decl":"theorem interior_preimage (hsurj : Surjective f) (s : Set F) :\n    interior (f ‚Åª¬π' s) = f ‚Åª¬π' interior s :=\n  ((f.isOpenMap hsurj).preimage_interior_eq_interior_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.closure_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nhsurj : Function.Surjective ‚áëf\ns : Set F\n‚ä¢ Eq (closure (Set.preimage (‚áëf) s)) (Set.preimage (‚áëf) (closure s))","decl":"theorem closure_preimage (hsurj : Surjective f) (s : Set F) : closure (f ‚Åª¬π' s) = f ‚Åª¬π' closure s :=\n  ((f.isOpenMap hsurj).preimage_closure_eq_closure_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.frontier_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nf : ContinuousLinearMap œÉ E F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nhsurj : Function.Surjective ‚áëf\ns : Set F\n‚ä¢ Eq (frontier (Set.preimage (‚áëf) s)) (Set.preimage (‚áëf) (frontier s))","decl":"theorem frontier_preimage (hsurj : Surjective f) (s : Set F) :\n    frontier (f ‚Åª¬π' s) = f ‚Åª¬π' frontier s :=\n  ((f.isOpenMap hsurj).preimage_frontier_eq_frontier_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.exists_nonlinearRightInverse_of_surjective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nf : ContinuousLinearMap œÉ E F\nhsurj : Eq (LinearMap.range f) Top.top\n‚ä¢ Exists fun fsymm => LT.lt 0 fsymm.nnnorm","decl":"theorem exists_nonlinearRightInverse_of_surjective (f : E ‚ÜíSL[œÉ] F)\n    (hsurj : LinearMap.range f = ‚ä§) :\n    ‚àÉ fsymm : NonlinearRightInverse f, 0 < fsymm.nnnorm := by\n  choose C hC fsymm h using\n    exists_preimage_norm_le _ (LinearMap.range_eq_top.1 hsurj)\n  use {\n      toFun := fsymm\n      nnnorm := ‚ü®C, hC.lt.le‚ü©\n      bound' := fun y => (h y).2\n      right_inv' := fun y => (h y).1 }\n  exact hC\n\n"}
{"name":"ContinuousLinearMap.nonlinearRightInverseOfSurjective_def","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_5\nùïú' : Type u_6\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_7\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_8\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nf : ContinuousLinearMap œÉ E F\nhsurj : Eq (LinearMap.range f) Top.top\n‚ä¢ Eq (f.nonlinearRightInverseOfSurjective hsurj) (Classical.choose ‚ãØ)","decl":"/-- A surjective continuous linear map between Banach spaces admits a (possibly nonlinear)\ncontrolled right inverse. In general, it is not possible to ensure that such a right inverse\nis linear (take for instance the map from `E` to `E/F` where `F` is a closed subspace of `E`\nwithout a closed complement. Then it doesn't have a continuous linear right inverse.) -/\nnoncomputable irreducible_def nonlinearRightInverseOfSurjective (f : E ‚ÜíSL[œÉ] F)\n  (hsurj : LinearMap.range f = ‚ä§) : NonlinearRightInverse f :=\n  Classical.choose (exists_nonlinearRightInverse_of_surjective f hsurj)\n\n"}
{"name":"ContinuousLinearMap.nonlinearRightInverseOfSurjective_nnnorm_pos","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú\ninst‚úù‚Åπ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\ninst‚úù¬≥ : RingHomIsometric œÉ\ninst‚úù¬≤ : RingHomIsometric œÉ'\ninst‚úù¬π : CompleteSpace F\ninst‚úù : CompleteSpace E\nf : ContinuousLinearMap œÉ E F\nhsurj : Eq (LinearMap.range f) Top.top\n‚ä¢ LT.lt 0 (f.nonlinearRightInverseOfSurjective hsurj).nnnorm","decl":"theorem nonlinearRightInverseOfSurjective_nnnorm_pos (f : E ‚ÜíSL[œÉ] F)\n    (hsurj : LinearMap.range f = ‚ä§) : 0 < (nonlinearRightInverseOfSurjective f hsurj).nnnorm := by\n  rw [nonlinearRightInverseOfSurjective]\n  exact Classical.choose_spec (exists_nonlinearRightInverse_of_surjective f hsurj)\n\n"}
{"name":"LinearEquiv.continuous_symm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\ne : LinearEquiv œÉ E F\nh : Continuous ‚áëe\n‚ä¢ Continuous ‚áëe.symm","decl":"/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\n@[continuity]\ntheorem continuous_symm (e : E ‚âÉ‚Çõ‚Çó[œÉ] F) (h : Continuous e) : Continuous e.symm := by\n  rw [continuous_def]\n  intro s hs\n  rw [‚Üê e.image_eq_preimage]\n  rw [‚Üê e.coe_coe] at h ‚ä¢\n  exact ContinuousLinearMap.isOpenMap (œÉ := œÉ) ‚ü®_, h‚ü© e.surjective s hs\n\n"}
{"name":"LinearEquiv.coeFn_toContinuousLinearEquivOfContinuous","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\ne : LinearEquiv œÉ E F\nh : Continuous ‚áëe\n‚ä¢ Eq ‚áë(e.toContinuousLinearEquivOfContinuous h) ‚áëe","decl":"@[simp]\ntheorem coeFn_toContinuousLinearEquivOfContinuous (e : E ‚âÉ‚Çõ‚Çó[œÉ] F) (h : Continuous e) :\n    ‚áë(e.toContinuousLinearEquivOfContinuous h) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coeFn_toContinuousLinearEquivOfContinuous_symm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\ne : LinearEquiv œÉ E F\nh : Continuous ‚áëe\n‚ä¢ Eq ‚áë(e.toContinuousLinearEquivOfContinuous h).symm ‚áëe.symm","decl":"@[simp]\ntheorem coeFn_toContinuousLinearEquivOfContinuous_symm (e : E ‚âÉ‚Çõ‚Çó[œÉ] F) (h : Continuous e) :\n    ‚áë(e.toContinuousLinearEquivOfContinuous h).symm = e.symm :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_linearMap_equivRange","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Function.Injective ‚áëf\nhclo : IsClosed (Set.range ‚áëf)\n‚ä¢ Eq (‚Üë(f.equivRange hinj hclo)) f.rangeRestrict","decl":"@[simp]\ntheorem coe_linearMap_equivRange (f : E ‚ÜíSL[œÉ] F) (hinj : Injective f) (hclo : IsClosed (range f)) :\n    f.equivRange hinj hclo = f.rangeRestrict :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_equivRange","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Function.Injective ‚áëf\nhclo : IsClosed (Set.range ‚áëf)\n‚ä¢ Eq ‚áë(f.equivRange hinj hclo) ‚áëf.rangeRestrict","decl":"@[simp]\ntheorem coe_equivRange (f : E ‚ÜíSL[œÉ] F) (hinj : Injective f) (hclo : IsClosed (range f)) :\n    (f.equivRange hinj hclo : E ‚Üí LinearMap.range f) = f.rangeRestrict :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.coeFn_ofBijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\n‚ä¢ Eq ‚áë(ContinuousLinearEquiv.ofBijective f hinj hsurj) ‚áëf","decl":"@[simp]\ntheorem coeFn_ofBijective (f : E ‚ÜíSL[œÉ] F) (hinj : ker f = ‚ä•) (hsurj : LinearMap.range f = ‚ä§) :\n    ‚áë(ofBijective f hinj hsurj) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.coe_ofBijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\n‚ä¢ Eq (‚Üë(ContinuousLinearEquiv.ofBijective f hinj hsurj)) f","decl":"theorem coe_ofBijective (f : E ‚ÜíSL[œÉ] F) (hinj : ker f = ‚ä•) (hsurj : LinearMap.range f = ‚ä§) :\n    ‚Üë(ofBijective f hinj hsurj) = f := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.ofBijective_symm_apply_apply","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\nx : E\n‚ä¢ Eq ((ContinuousLinearEquiv.ofBijective f hinj hsurj).symm (f x)) x","decl":"@[simp]\ntheorem ofBijective_symm_apply_apply (f : E ‚ÜíSL[œÉ] F) (hinj : ker f = ‚ä•)\n    (hsurj : LinearMap.range f = ‚ä§) (x : E) : (ofBijective f hinj hsurj).symm (f x) = x :=\n  (ofBijective f hinj hsurj).symm_apply_apply x\n\n"}
{"name":"ContinuousLinearEquiv.ofBijective_apply_symm_apply","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nœÉ : RingHom ùïú ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nF : Type u_4\ninst‚úù‚Å∑ : NormedAddCommGroup F\ninst‚úù‚Å∂ : NormedSpace ùïú' F\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Åµ : RingHomInvPair œÉ œÉ'\ninst‚úù‚Å¥ : RingHomIsometric œÉ\ninst‚úù¬≥ : RingHomIsometric œÉ'\ninst‚úù¬≤ : CompleteSpace F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : RingHomInvPair œÉ' œÉ\nf : ContinuousLinearMap œÉ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\ny : F\n‚ä¢ Eq (f ((ContinuousLinearEquiv.ofBijective f hinj hsurj).symm y)) y","decl":"@[simp]\ntheorem ofBijective_apply_symm_apply (f : E ‚ÜíSL[œÉ] F) (hinj : ker f = ‚ä•)\n    (hsurj : LinearMap.range f = ‚ä§) (y : F) : f ((ofBijective f hinj hsurj).symm y) = y :=\n  (ofBijective f hinj hsurj).apply_symm_apply y\n\n"}
{"name":"ContinuousLinearMap.isUnit_iff_bijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù¬≥ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id ùïú) E E\n‚ä¢ Iff (IsUnit f) (Function.Bijective ‚áëf)","decl":"lemma _root_.ContinuousLinearMap.isUnit_iff_bijective {f : E ‚ÜíL[ùïú] E} :\n    IsUnit f ‚Üî Bijective f := by\n  constructor\n  ¬∑ rintro ‚ü®f, rfl‚ü©\n    exact ofUnit f |>.bijective\n  ¬∑ refine fun h ‚Ü¶ ‚ü®toUnit <| .ofBijective f ?_ ?_, rfl‚ü© <;>\n    simp only [LinearMap.range_eq_top, LinearMapClass.ker_eq_bot, h.1, h.2]\n\n"}
{"name":"ContinuousLinearMap.range_eq_map_coprodSubtypeLEquivOfIsCompl","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∑ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace ùïú E\ninst‚úù‚Å¥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú F\ninst‚úù¬π : CompleteSpace F\nf : ContinuousLinearMap (RingHom.id ùïú) E F\nG : Submodule ùïú F\nh : IsCompl (LinearMap.range f) G\ninst‚úù : CompleteSpace (Subtype fun x => Membership.mem G x)\nhker : Eq (LinearMap.ker f) Bot.bot\n‚ä¢ Eq (LinearMap.range f) (Submodule.map (‚Üë‚Üë(f.coprodSubtypeLEquivOfIsCompl h hker)) (Top.top.prod Bot.bot))","decl":"theorem range_eq_map_coprodSubtypeLEquivOfIsCompl {F : Type*} [NormedAddCommGroup F]\n    [NormedSpace ùïú F] [CompleteSpace F] (f : E ‚ÜíL[ùïú] F) {G : Submodule ùïú F}\n    (h : IsCompl (LinearMap.range f) G) [CompleteSpace G] (hker : ker f = ‚ä•) :\n    LinearMap.range f =\n      ((‚ä§ : Submodule ùïú E).prod (‚ä• : Submodule ùïú G)).map\n        (f.coprodSubtypeLEquivOfIsCompl h hker : E √ó G ‚Üí‚Çó[ùïú] F) := by\n  rw [coprodSubtypeLEquivOfIsCompl, ContinuousLinearEquiv.coe_ofBijective,\n    coe_coprod, LinearMap.coprod_map_prod, Submodule.map_bot, sup_bot_eq, Submodule.map_top]\n  rfl\n\n/- TODO: remove the assumption `f.ker = ‚ä•` in the next lemma, by using the map induced by `f` on\n`E / f.ker`, once we have quotient normed spaces. -/\n"}
{"name":"ContinuousLinearMap.closed_complemented_range_of_isCompl_of_ker_eq_bot","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\nf : ContinuousLinearMap (RingHom.id ùïú) E F\nG : Submodule ùïú F\nh : IsCompl (LinearMap.range f) G\nhG : IsClosed ‚ÜëG\nhker : Eq (LinearMap.ker f) Bot.bot\n‚ä¢ IsClosed ‚Üë(LinearMap.range f)","decl":"theorem closed_complemented_range_of_isCompl_of_ker_eq_bot {F : Type*} [NormedAddCommGroup F]\n    [NormedSpace ùïú F] [CompleteSpace F] (f : E ‚ÜíL[ùïú] F) (G : Submodule ùïú F)\n    (h : IsCompl (LinearMap.range f) G) (hG : IsClosed (G : Set F)) (hker : ker f = ‚ä•) :\n    IsClosed (LinearMap.range f : Set F) := by\n  haveI : CompleteSpace G := hG.completeSpace_coe\n  let g := coprodSubtypeLEquivOfIsCompl f h hker\n  -- Porting note: was `rw [congr_arg coe ...]`\n  rw [range_eq_map_coprodSubtypeLEquivOfIsCompl f h hker]\n  apply g.toHomeomorph.isClosed_image.2\n  exact isClosed_univ.prod isClosed_singleton\n\n"}
{"name":"LinearMap.continuous_of_isClosed_graph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : IsClosed ‚Üëg.graph\n‚ä¢ Continuous ‚áëg","decl":"/-- The **closed graph theorem** : a linear map between two Banach spaces whose graph is closed\nis continuous. -/\ntheorem LinearMap.continuous_of_isClosed_graph (hg : IsClosed (g.graph : Set <| E √ó F)) :\n    Continuous g := by\n  letI : CompleteSpace g.graph := completeSpace_coe_iff_isComplete.mpr hg.isComplete\n  let œÜ‚ÇÄ : E ‚Üí‚Çó[ùïú] E √ó F := LinearMap.id.prod g\n  have : Function.LeftInverse Prod.fst œÜ‚ÇÄ := fun x => rfl\n  let œÜ : E ‚âÉ‚Çó[ùïú] g.graph :=\n    (LinearEquiv.ofLeftInverse this).trans (LinearEquiv.ofEq _ _ g.graph_eq_range_prod.symm)\n  let œà : g.graph ‚âÉL[ùïú] E :=\n    œÜ.symm.toContinuousLinearEquivOfContinuous continuous_subtype_val.fst\n  exact (continuous_subtype_val.comp œà.symm.continuous).snd\n\n"}
{"name":"LinearMap.continuous_of_seq_closed_graph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : ‚àÄ (u : Nat ‚Üí E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) ‚Üí Filter.Tendsto (Function.comp (‚áëg) u) Filter.atTop (nhds y) ‚Üí Eq y (g x)\n‚ä¢ Continuous ‚áëg","decl":"/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`u‚Çô ‚ü∂ x`, if `f(u‚Çô) ‚ü∂ y` then `y = f(x)`. -/\ntheorem LinearMap.continuous_of_seq_closed_graph\n    (hg : ‚àÄ (u : ‚Ñï ‚Üí E) (x y), Tendsto u atTop (ùìù x) ‚Üí Tendsto (g ‚àò u) atTop (ùìù y) ‚Üí y = g x) :\n    Continuous g := by\n  refine g.continuous_of_isClosed_graph (IsSeqClosed.isClosed ?_)\n  rintro œÜ ‚ü®x, y‚ü© hœÜg hœÜ\n  refine hg (Prod.fst ‚àò œÜ) x y ((continuous_fst.tendsto _).comp hœÜ) ?_\n  have : g ‚àò Prod.fst ‚àò œÜ = Prod.snd ‚àò œÜ := by\n    ext n\n    exact (hœÜg n).symm\n  rw [this]\n  exact (continuous_snd.tendsto _).comp hœÜ\n\n"}
{"name":"ContinuousLinearMap.coeFn_ofIsClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : IsClosed ‚Üëg.graph\n‚ä¢ Eq ‚áë(ContinuousLinearMap.ofIsClosedGraph hg) ‚áëg","decl":"@[simp]\ntheorem coeFn_ofIsClosedGraph (hg : IsClosed (g.graph : Set <| E √ó F)) :\n    ‚áë(ContinuousLinearMap.ofIsClosedGraph hg) = g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_ofIsClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : IsClosed ‚Üëg.graph\n‚ä¢ Eq (‚Üë(ContinuousLinearMap.ofIsClosedGraph hg)) g","decl":"theorem coe_ofIsClosedGraph (hg : IsClosed (g.graph : Set <| E √ó F)) :\n    ‚Üë(ContinuousLinearMap.ofIsClosedGraph hg) = g := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coeFn_ofSeqClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : ‚àÄ (u : Nat ‚Üí E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) ‚Üí Filter.Tendsto (Function.comp (‚áëg) u) Filter.atTop (nhds y) ‚Üí Eq y (g x)\n‚ä¢ Eq ‚áë(ContinuousLinearMap.ofSeqClosedGraph hg) ‚áëg","decl":"@[simp]\ntheorem coeFn_ofSeqClosedGraph\n    (hg : ‚àÄ (u : ‚Ñï ‚Üí E) (x y), Tendsto u atTop (ùìù x) ‚Üí Tendsto (g ‚àò u) atTop (ùìù y) ‚Üí y = g x) :\n    ‚áë(ContinuousLinearMap.ofSeqClosedGraph hg) = g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_ofSeqClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\ninst‚úù¬≥ : CompleteSpace E\nF : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : CompleteSpace F\ng : LinearMap (RingHom.id ùïú) E F\nhg : ‚àÄ (u : Nat ‚Üí E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) ‚Üí Filter.Tendsto (Function.comp (‚áëg) u) Filter.atTop (nhds y) ‚Üí Eq y (g x)\n‚ä¢ Eq (‚Üë(ContinuousLinearMap.ofSeqClosedGraph hg)) g","decl":"theorem coe_ofSeqClosedGraph\n    (hg : ‚àÄ (u : ‚Ñï ‚Üí E) (x y), Tendsto u atTop (ùìù x) ‚Üí Tendsto (g ‚àò u) atTop (ùìù y) ‚Üí y = g x) :\n    ‚Üë(ContinuousLinearMap.ofSeqClosedGraph hg) = g := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.closed_range_of_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Å∑ : NontriviallyNormedField ùïú\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú'\nE : Type u_3\ninst‚úù‚Åµ : NormedAddCommGroup E\ninst‚úù‚Å¥ : NormedSpace ùïú E\nœÉ : RingHom ùïú ùïú'\nœÉ' : RingHom ùïú' ùïú\ninst‚úù¬≥ : RingHomInvPair œÉ œÉ'\nF : Type u_4\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace ùïú' F\ninst‚úù : CompleteSpace E\nf : ContinuousLinearMap œÉ E F\nc : NNReal\nhf : AntilipschitzWith c ‚áëf\n‚ä¢ Eq (LinearMap.range f).topologicalClosure (LinearMap.range f)","decl":"lemma closed_range_of_antilipschitz {f : E ‚ÜíSL[œÉ] F} {c : ‚Ñù‚â•0} (hf : AntilipschitzWith c f) :\n    (LinearMap.range f).topologicalClosure = LinearMap.range f :=\n  SetLike.ext'_iff.mpr <| (hf.isClosed_range f.uniformContinuous).closure_eq\n\n"}
{"name":"AntilipschitzWith.completeSpace_range_clm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù‚Å∏ : NontriviallyNormedField ùïú\ninst‚úù‚Å∑ : NontriviallyNormedField ùïú'\nE : Type u_3\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : NormedSpace ùïú E\nœÉ : RingHom ùïú ùïú'\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å¥ : RingHomInvPair œÉ œÉ'\nF : Type u_4\ninst‚úù¬≥ : NormedAddCommGroup F\ninst‚úù¬≤ : NormedSpace ùïú' F\ninst‚úù¬π : CompleteSpace E\ninst‚úù : CompleteSpace F\nf : ContinuousLinearMap œÉ E F\nc : NNReal\nhf : AntilipschitzWith c ‚áëf\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"lemma _root_.AntilipschitzWith.completeSpace_range_clm {f : E ‚ÜíSL[œÉ] F} {c : ‚Ñù‚â•0}\n    (hf : AntilipschitzWith c f) : CompleteSpace (LinearMap.range f) :=\n  IsClosed.completeSpace_coe <| hf.isClosed_range f.uniformContinuous\n\n"}
{"name":"ContinuousLinearMap.bijective_iff_dense_range_and_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ùïú : Type u_1\nùïú' : Type u_2\ninst‚úù¬π¬π : NontriviallyNormedField ùïú\ninst‚úù¬π‚Å∞ : NontriviallyNormedField ùïú'\nE : Type u_3\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace ùïú E\nœÉ : RingHom ùïú ùïú'\nœÉ' : RingHom ùïú' ùïú\ninst‚úù‚Å∑ : RingHomInvPair œÉ œÉ'\nF : Type u_4\ninst‚úù‚Å∂ : NormedAddCommGroup F\ninst‚úù‚Åµ : NormedSpace ùïú' F\ninst‚úù‚Å¥ : CompleteSpace E\ninst‚úù¬≥ : CompleteSpace F\ninst‚úù¬≤ : RingHomInvPair œÉ' œÉ\ninst‚úù¬π : RingHomIsometric œÉ\ninst‚úù : RingHomIsometric œÉ'\nf : ContinuousLinearMap œÉ E F\n‚ä¢ Iff (Function.Bijective ‚áëf) (And (Eq (LinearMap.range f).topologicalClosure Top.top) (Exists fun c => AntilipschitzWith c ‚áëf))","decl":"lemma bijective_iff_dense_range_and_antilipschitz (f : E ‚ÜíSL[œÉ] F) :\n    Bijective f ‚Üî (LinearMap.range f).topologicalClosure = ‚ä§ ‚àß ‚àÉ c, AntilipschitzWith c f := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®?eq_top, ?anti‚ü©, fun ‚ü®hd, c, hf‚ü© ‚Ü¶ ‚ü®hf.injective, ?surj‚ü©‚ü©\n  case eq_top => simpa [SetLike.ext'_iff] using h.2.denseRange.closure_eq\n  case anti =>\n    refine ‚ü®_, ContinuousLinearEquiv.ofBijective f ?_ ?_ |>.antilipschitz‚ü© <;>\n    simp only [LinearMap.range_eq_top, LinearMapClass.ker_eq_bot, h.1, h.2]\n  case surj => rwa [‚Üê LinearMap.range_eq_top, ‚Üê closed_range_of_antilipschitz hf]\n\n"}
