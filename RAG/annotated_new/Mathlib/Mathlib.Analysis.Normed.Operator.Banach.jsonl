{"name":"ContinuousLinearMap.NonlinearRightInverse.bound'","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nself : f.NonlinearRightInverse\ny : F\nâŠ¢ LE.le (Norm.norm (self.toFun y)) (HMul.hMul (â†‘self.nnnorm) (Norm.norm y))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `â€–inverse xâ€– â‰¤ C * â€–xâ€–`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F â†’ E\n  nnnorm : â„â‰¥0\n  bound' : âˆ€ y, â€–toFun yâ€– â‰¤ nnnorm * â€–yâ€–\n  right_inv' : âˆ€ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.inj","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\ntoFunâœ : F â†’ E\nnnnormâœ : NNReal\nbound'âœ : âˆ€ (y : F), LE.le (Norm.norm (toFunâœ y)) (HMul.hMul (â†‘nnnormâœ) (Norm.norm y))\nright_inv'âœ : âˆ€ (y : F), Eq (f (toFunâœ y)) y\ntoFun : F â†’ E\nnnnorm : NNReal\nbound' : âˆ€ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (â†‘nnnorm) (Norm.norm y))\nright_inv' : âˆ€ (y : F), Eq (f (toFun y)) y\nxâœ : Eq { toFun := toFunâœ, nnnorm := nnnormâœ, bound' := bound'âœ, right_inv' := right_inv'âœ } { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }\nâŠ¢ And (Eq toFunâœ toFun) (Eq nnnormâœ nnnorm)","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `â€–inverse xâ€– â‰¤ C * â€–xâ€–`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F â†’ E\n  nnnorm : â„â‰¥0\n  bound' : âˆ€ y, â€–toFun yâ€– â‰¤ nnnorm * â€–yâ€–\n  right_inv' : âˆ€ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\ninstâœÂ³ : SizeOf ğ•œ\ninstâœÂ² : SizeOf ğ•œ'\ninstâœÂ¹ : SizeOf E\ninstâœ : SizeOf F\ntoFun : F â†’ E\nnnnorm : NNReal\nbound' : âˆ€ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (â†‘nnnorm) (Norm.norm y))\nright_inv' : âˆ€ (y : F), Eq (f (toFun y)) y\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }) (HAdd.hAdd 1 (SizeOf.sizeOf nnnorm))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `â€–inverse xâ€– â‰¤ C * â€–xâ€–`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F â†’ E\n  nnnorm : â„â‰¥0\n  bound' : âˆ€ y, â€–toFun yâ€– â‰¤ nnnorm * â€–yâ€–\n  right_inv' : âˆ€ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.right_inv'","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nself : f.NonlinearRightInverse\ny : F\nâŠ¢ Eq (f (self.toFun y)) y","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `â€–inverse xâ€– â‰¤ C * â€–xâ€–`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F â†’ E\n  nnnorm : â„â‰¥0\n  bound' : âˆ€ y, â€–toFun yâ€– â‰¤ nnnorm * â€–yâ€–\n  right_inv' : âˆ€ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.mk.injEq","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\ntoFunâœ : F â†’ E\nnnnormâœ : NNReal\nbound'âœ : âˆ€ (y : F), LE.le (Norm.norm (toFunâœ y)) (HMul.hMul (â†‘nnnormâœ) (Norm.norm y))\nright_inv'âœ : âˆ€ (y : F), Eq (f (toFunâœ y)) y\ntoFun : F â†’ E\nnnnorm : NNReal\nbound' : âˆ€ (y : F), LE.le (Norm.norm (toFun y)) (HMul.hMul (â†‘nnnorm) (Norm.norm y))\nright_inv' : âˆ€ (y : F), Eq (f (toFun y)) y\nâŠ¢ Eq (Eq { toFun := toFunâœ, nnnorm := nnnormâœ, bound' := bound'âœ, right_inv' := right_inv'âœ } { toFun := toFun, nnnorm := nnnorm, bound' := bound', right_inv' := right_inv' }) (And (Eq toFunâœ toFun) (Eq nnnormâœ nnnorm))","decl":"/-- A (possibly nonlinear) right inverse to a continuous linear map, which doesn't have to be\nlinear itself but which satisfies a bound `â€–inverse xâ€– â‰¤ C * â€–xâ€–`. A surjective continuous linear\nmap doesn't always have a continuous linear right inverse, but it always has a nonlinear inverse\nin this sense, by Banach's open mapping theorem. -/\nstructure NonlinearRightInverse where\n  toFun : F â†’ E\n  nnnorm : â„â‰¥0\n  bound' : âˆ€ y, â€–toFun yâ€– â‰¤ nnnorm * â€–yâ€–\n  right_inv' : âˆ€ y, f (toFun y) = y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.right_inv","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nfsymm : f.NonlinearRightInverse\ny : F\nâŠ¢ Eq (f (fsymm.toFun y)) y","decl":"@[simp]\ntheorem NonlinearRightInverse.right_inv {f : E â†’SL[Ïƒ] F} (fsymm : NonlinearRightInverse f) (y : F) :\n    f (fsymm y) = y :=\n  fsymm.right_inv' y\n\n"}
{"name":"ContinuousLinearMap.NonlinearRightInverse.bound","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nfsymm : f.NonlinearRightInverse\ny : F\nâŠ¢ LE.le (Norm.norm (fsymm.toFun y)) (HMul.hMul (â†‘fsymm.nnnorm) (Norm.norm y))","decl":"theorem NonlinearRightInverse.bound {f : E â†’SL[Ïƒ] F} (fsymm : NonlinearRightInverse f) (y : F) :\n    â€–fsymm yâ€– â‰¤ fsymm.nnnorm * â€–yâ€– :=\n  fsymm.bound' y\n\n"}
{"name":"ContinuousLinearMap.exists_approx_preimage_norm_le","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœÂ³ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ² : RingHomIsometric Ïƒ\ninstâœÂ¹ : RingHomIsometric Ïƒ'\ninstâœ : CompleteSpace F\nsurj : Function.Surjective â‡‘f\nâŠ¢ Exists fun C => And (GE.ge C 0) (âˆ€ (y : F), Exists fun x => And (LE.le (Dist.dist (f x) y) (HMul.hMul (1 / 2) (Norm.norm y))) (LE.le (Norm.norm x) (HMul.hMul C (Norm.norm y))))","decl":"include Ïƒ' in\n/-- First step of the proof of the Banach open mapping theorem (using completeness of `F`):\nby Baire's theorem, there exists a ball in `E` whose image closure has nonempty interior.\nRescaling everything, it follows that any `y âˆˆ F` is arbitrarily well approached by\nimages of elements of norm at most `C * â€–yâ€–`.\nFor further use, we will only need such an element whose image\nis within distance `â€–yâ€–/2` of `y`, to apply an iterative process. -/\ntheorem exists_approx_preimage_norm_le (surj : Surjective f) :\n    âˆƒ C â‰¥ 0, âˆ€ y, âˆƒ x, dist (f x) y â‰¤ 1 / 2 * â€–yâ€– âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– := by\n  have A : â‹ƒ n : â„•, closure (f '' ball 0 n) = Set.univ := by\n    refine Subset.antisymm (subset_univ _) fun y _ => ?_\n    rcases surj y with âŸ¨x, hxâŸ©\n    rcases exists_nat_gt â€–xâ€– with âŸ¨n, hnâŸ©\n    refine mem_iUnion.2 âŸ¨n, subset_closure ?_âŸ©\n    refine (mem_image _ _ _).2 âŸ¨x, âŸ¨?_, hxâŸ©âŸ©\n    rwa [mem_ball, dist_eq_norm, sub_zero]\n  have : âˆƒ (n : â„•) (x : _), x âˆˆ interior (closure (f '' ball 0 n)) :=\n    nonempty_interior_of_iUnion_of_closed (fun n => isClosed_closure) A\n  simp only [mem_interior_iff_mem_nhds, Metric.mem_nhds_iff] at this\n  rcases this with âŸ¨n, a, Îµ, âŸ¨Îµpos, HâŸ©âŸ©\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  refine âŸ¨(Îµ / 2)â»Â¹ * â€–câ€– * 2 * n, by positivity, fun y => ?_âŸ©\n  rcases eq_or_ne y 0 with rfl | hy\n  Â· use 0\n    simp\n  Â· have hc' : 1 < â€–Ïƒ câ€– := by simp only [RingHomIsometric.is_iso, hc]\n    rcases rescale_to_shell hc' (half_pos Îµpos) hy with âŸ¨d, hd, ydlt, -, dinvâŸ©\n    let Î´ := â€–dâ€– * â€–yâ€– / 4\n    have Î´pos : 0 < Î´ := div_pos (mul_pos (norm_pos_iff.2 hd) (norm_pos_iff.2 hy)) (by norm_num)\n    have : a + d â€¢ y âˆˆ ball a Îµ := by\n      simp [dist_eq_norm, lt_of_le_of_lt ydlt.le (half_lt_self Îµpos)]\n    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚, zâ‚im, hâ‚âŸ©\n    rcases (mem_image _ _ _).1 zâ‚im with âŸ¨xâ‚, hxâ‚, xzâ‚âŸ©\n    rw [â† xzâ‚] at hâ‚\n    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚\n    have : a âˆˆ ball a Îµ := by\n      simp only [mem_ball, dist_self]\n      exact Îµpos\n    rcases Metric.mem_closure_iff.1 (H this) _ Î´pos with âŸ¨zâ‚‚, zâ‚‚im, hâ‚‚âŸ©\n    rcases (mem_image _ _ _).1 zâ‚‚im with âŸ¨xâ‚‚, hxâ‚‚, xzâ‚‚âŸ©\n    rw [â† xzâ‚‚] at hâ‚‚\n    rw [mem_ball, dist_eq_norm, sub_zero] at hxâ‚‚\n    let x := xâ‚ - xâ‚‚\n    have I : â€–f x - d â€¢ yâ€– â‰¤ 2 * Î´ :=\n      calc\n        â€–f x - d â€¢ yâ€– = â€–f xâ‚ - (a + d â€¢ y) - (f xâ‚‚ - a)â€– := by\n          congr 1\n          simp only [x, f.map_sub]\n          abel\n        _ â‰¤ â€–f xâ‚ - (a + d â€¢ y)â€– + â€–f xâ‚‚ - aâ€– := norm_sub_le _ _\n        _ â‰¤ Î´ + Î´ := by rw [dist_eq_norm'] at hâ‚ hâ‚‚; gcongr\n        _ = 2 * Î´ := (two_mul _).symm\n    have J : â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– â‰¤ 1 / 2 * â€–yâ€– :=\n      calc\n        â€–f (Ïƒ' dâ»Â¹ â€¢ x) - yâ€– = â€–dâ»Â¹ â€¢ f x - (dâ»Â¹ * d) â€¢ yâ€– := by\n          rwa [f.map_smulâ‚›â‚— _, inv_mul_cancelâ‚€, one_smul, map_invâ‚€, map_invâ‚€,\n            RingHomCompTriple.comp_apply, RingHom.id_apply]\n        _ = â€–dâ»Â¹ â€¢ (f x - d â€¢ y)â€– := by rw [mul_smul, smul_sub]\n        _ = â€–dâ€–â»Â¹ * â€–f x - d â€¢ yâ€– := by rw [norm_smul, norm_inv]\n        _ â‰¤ â€–dâ€–â»Â¹ * (2 * Î´) := by gcongr\n        _ = â€–dâ€–â»Â¹ * â€–dâ€– * â€–yâ€– / 2 := by\n          simp only [Î´]\n          ring\n        _ = â€–yâ€– / 2 := by\n          rw [inv_mul_cancelâ‚€, one_mul]\n          simp [norm_eq_zero, hd]\n        _ = 1 / 2 * â€–yâ€– := by ring\n    rw [â† dist_eq_norm] at J\n    have K : â€–Ïƒ' dâ»Â¹ â€¢ xâ€– â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– :=\n      calc\n        â€–Ïƒ' dâ»Â¹ â€¢ xâ€– = â€–dâ€–â»Â¹ * â€–xâ‚ - xâ‚‚â€– := by rw [norm_smul, RingHomIsometric.is_iso, norm_inv]\n        _ â‰¤ (Îµ / 2)â»Â¹ * â€–câ€– * â€–yâ€– * (n + n) := by\n          gcongr\n          Â· simpa using dinv\n          Â· exact le_trans (norm_sub_le _ _) (by gcongr)\n        _ = (Îµ / 2)â»Â¹ * â€–câ€– * 2 * â†‘n * â€–yâ€– := by ring\n    exact âŸ¨Ïƒ' dâ»Â¹ â€¢ x, J, KâŸ©\n\n"}
{"name":"ContinuousLinearMap.exists_preimage_norm_le","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nsurj : Function.Surjective â‡‘f\nâŠ¢ Exists fun C => And (GT.gt C 0) (âˆ€ (y : F), Exists fun x => And (Eq (f x) y) (LE.le (Norm.norm x) (HMul.hMul C (Norm.norm y))))","decl":"/-- The Banach open mapping theorem: if a bounded linear map between Banach spaces is onto, then\nany point has a preimage with controlled norm. -/\ntheorem exists_preimage_norm_le (surj : Surjective f) :\n    âˆƒ C > 0, âˆ€ y, âˆƒ x, f x = y âˆ§ â€–xâ€– â‰¤ C * â€–yâ€– := by\n  obtain âŸ¨C, C0, hCâŸ© := exists_approx_preimage_norm_le f surj\n  /- Second step of the proof: starting from `y`, we want an exact preimage of `y`. Let `g y` be\n    the approximate preimage of `y` given by the first step, and `h y = y - f(g y)` the part that\n    has no preimage yet. We will iterate this process, taking the approximate preimage of `h y`,\n    leaving only `h^2 y` without preimage yet, and so on. Let `u n` be the approximate preimage\n    of `h^n y`. Then `u` is a converging series, and by design the sum of the series is a\n    preimage of `y`. This uses completeness of `E`. -/\n  choose g hg using hC\n  let h y := y - f (g y)\n  have hle : âˆ€ y, â€–h yâ€– â‰¤ 1 / 2 * â€–yâ€– := by\n    intro y\n    rw [â† dist_eq_norm, dist_comm]\n    exact (hg y).1\n  refine âŸ¨2 * C + 1, by linarith, fun y => ?_âŸ©\n  have hnle : âˆ€ n : â„•, â€–h^[n] yâ€– â‰¤ (1 / 2) ^ n * â€–yâ€– := by\n    intro n\n    induction n with\n    | zero => simp only [one_div, one_mul, iterate_zero_apply, pow_zero, le_rfl]\n    | succ n IH =>\n      rw [iterate_succ']\n      apply le_trans (hle _) _\n      rw [pow_succ', mul_assoc]\n      gcongr\n  let u n := g (h^[n] y)\n  have ule : âˆ€ n, â€–u nâ€– â‰¤ (1 / 2) ^ n * (C * â€–yâ€–) := fun n â†¦ by\n    apply le_trans (hg _).2\n    calc\n      C * â€–h^[n] yâ€– â‰¤ C * ((1 / 2) ^ n * â€–yâ€–) := mul_le_mul_of_nonneg_left (hnle n) C0\n      _ = (1 / 2) ^ n * (C * â€–yâ€–) := by ring\n  have sNu : Summable fun n => â€–u nâ€– := by\n    refine .of_nonneg_of_le (fun n => norm_nonneg _) ule ?_\n    exact Summable.mul_right _ (summable_geometric_of_lt_one (by norm_num) (by norm_num))\n  have su : Summable u := sNu.of_norm\n  let x := tsum u\n  have x_ineq : â€–xâ€– â‰¤ (2 * C + 1) * â€–yâ€– :=\n    calc\n      â€–xâ€– â‰¤ âˆ‘' n, â€–u nâ€– := norm_tsum_le_tsum_norm sNu\n      _ â‰¤ âˆ‘' n, (1 / 2) ^ n * (C * â€–yâ€–) :=\n        tsum_le_tsum ule sNu (Summable.mul_right _ summable_geometric_two)\n      _ = (âˆ‘' n, (1 / 2) ^ n) * (C * â€–yâ€–) := tsum_mul_right\n      _ = 2 * C * â€–yâ€– := by rw [tsum_geometric_two, mul_assoc]\n      _ â‰¤ 2 * C * â€–yâ€– + â€–yâ€– := le_add_of_nonneg_right (norm_nonneg y)\n      _ = (2 * C + 1) * â€–yâ€– := by ring\n  have fsumeq : âˆ€ n : â„•, f (âˆ‘ i âˆˆ Finset.range n, u i) = y - h^[n] y := by\n    intro n\n    induction n with\n    | zero => simp [f.map_zero]\n    | succ n IH => rw [sum_range_succ, f.map_add, IH, iterate_succ_apply', sub_add]\n  have : Tendsto (fun n => âˆ‘ i âˆˆ Finset.range n, u i) atTop (ğ“ x) := su.hasSum.tendsto_sum_nat\n  have Lâ‚ : Tendsto (fun n => f (âˆ‘ i âˆˆ Finset.range n, u i)) atTop (ğ“ (f x)) :=\n    (f.continuous.tendsto _).comp this\n  simp only [fsumeq] at Lâ‚\n  have Lâ‚‚ : Tendsto (fun n => y - h^[n] y) atTop (ğ“ (y - 0)) := by\n    refine tendsto_const_nhds.sub ?_\n    rw [tendsto_iff_norm_sub_tendsto_zero]\n    simp only [sub_zero]\n    refine squeeze_zero (fun _ => norm_nonneg _) hnle ?_\n    rw [â† zero_mul â€–yâ€–]\n    refine (_root_.tendsto_pow_atTop_nhds_zero_of_lt_one ?_ ?_).mul tendsto_const_nhds <;> norm_num\n  have feq : f x = y - 0 := tendsto_nhds_unique Lâ‚ Lâ‚‚\n  rw [sub_zero] at feq\n  exact âŸ¨x, feq, x_ineqâŸ©\n\n"}
{"name":"ContinuousLinearMap.isOpenMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nsurj : Function.Surjective â‡‘f\nâŠ¢ IsOpenMap â‡‘f","decl":"/-- The Banach open mapping theorem: a surjective bounded linear map between Banach spaces is\nopen. -/\nprotected theorem isOpenMap (surj : Surjective f) : IsOpenMap f := by\n  intro s hs\n  rcases exists_preimage_norm_le f surj with âŸ¨C, Cpos, hCâŸ©\n  refine isOpen_iff.2 fun y yfs => ?_\n  rcases yfs with âŸ¨x, xs, fxyâŸ©\n  rcases isOpen_iff.1 hs x xs with âŸ¨Îµ, Îµpos, hÎµâŸ©\n  refine âŸ¨Îµ / C, div_pos Îµpos Cpos, fun z hz => ?_âŸ©\n  rcases hC (z - y) with âŸ¨w, wim, wnormâŸ©\n  have : f (x + w) = z := by rw [f.map_add, wim, fxy, add_sub_cancel]\n  rw [â† this]\n  have : x + w âˆˆ ball x Îµ :=\n    calc\n      dist (x + w) x = â€–wâ€– := by\n        rw [dist_eq_norm]\n        simp\n      _ â‰¤ C * â€–z - yâ€– := wnorm\n      _ < C * (Îµ / C) := by\n        apply mul_lt_mul_of_pos_left _ Cpos\n        rwa [mem_ball, dist_eq_norm] at hz\n      _ = Îµ := mul_div_cancelâ‚€ _ (ne_of_gt Cpos)\n\n  exact Set.mem_image_of_mem _ (hÎµ this)\n\n"}
{"name":"ContinuousLinearMap.isQuotientMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nsurj : Function.Surjective â‡‘f\nâŠ¢ Topology.IsQuotientMap â‡‘f","decl":"theorem isQuotientMap (surj : Surjective f) : IsQuotientMap f :=\n  (f.isOpenMap surj).isQuotientMap f.continuous surj\n\n"}
{"name":"ContinuousLinearMap.quotientMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nsurj : Function.Surjective â‡‘f\nâŠ¢ Topology.IsQuotientMap â‡‘f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap := isQuotientMap\n\n"}
{"name":"AffineMap.isOpenMap","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\ninstâœâ· : CompleteSpace E\nF : Type u_5\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ F\ninstâœâ´ : CompleteSpace F\nP : Type u_6\nQ : Type u_7\ninstâœÂ³ : MetricSpace P\ninstâœÂ² : NormedAddTorsor E P\ninstâœÂ¹ : MetricSpace Q\ninstâœ : NormedAddTorsor F Q\nf : AffineMap ğ•œ P Q\nhf : Continuous â‡‘f\nsurj : Function.Surjective â‡‘f\nâŠ¢ IsOpenMap â‡‘f","decl":"theorem _root_.AffineMap.isOpenMap {F : Type*} [NormedAddCommGroup F] [NormedSpace ğ•œ F]\n    [CompleteSpace F] {P Q : Type*} [MetricSpace P] [NormedAddTorsor E P] [MetricSpace Q]\n    [NormedAddTorsor F Q] (f : P â†’áµƒ[ğ•œ] Q) (hf : Continuous f) (surj : Surjective f) :\n    IsOpenMap f :=\n  AffineMap.isOpenMap_linear_iff.mp <|\n    ContinuousLinearMap.isOpenMap { f.linear with cont := AffineMap.continuous_linear_iff.mpr hf }\n      (f.linear_surjective_iff.mpr surj)\n\n"}
{"name":"ContinuousLinearMap.interior_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nhsurj : Function.Surjective â‡‘f\ns : Set F\nâŠ¢ Eq (interior (Set.preimage (â‡‘f) s)) (Set.preimage (â‡‘f) (interior s))","decl":"theorem interior_preimage (hsurj : Surjective f) (s : Set F) :\n    interior (f â»Â¹' s) = f â»Â¹' interior s :=\n  ((f.isOpenMap hsurj).preimage_interior_eq_interior_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.closure_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nhsurj : Function.Surjective â‡‘f\ns : Set F\nâŠ¢ Eq (closure (Set.preimage (â‡‘f) s)) (Set.preimage (â‡‘f) (closure s))","decl":"theorem closure_preimage (hsurj : Surjective f) (s : Set F) : closure (f â»Â¹' s) = f â»Â¹' closure s :=\n  ((f.isOpenMap hsurj).preimage_closure_eq_closure_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.frontier_preimage","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nf : ContinuousLinearMap Ïƒ E F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nhsurj : Function.Surjective â‡‘f\ns : Set F\nâŠ¢ Eq (frontier (Set.preimage (â‡‘f) s)) (Set.preimage (â‡‘f) (frontier s))","decl":"theorem frontier_preimage (hsurj : Surjective f) (s : Set F) :\n    frontier (f â»Â¹' s) = f â»Â¹' frontier s :=\n  ((f.isOpenMap hsurj).preimage_frontier_eq_frontier_preimage f.continuous s).symm\n\n"}
{"name":"ContinuousLinearMap.exists_nonlinearRightInverse_of_surjective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap Ïƒ E F\nhsurj : Eq (LinearMap.range f) Top.top\nâŠ¢ Exists fun fsymm => LT.lt 0 fsymm.nnnorm","decl":"theorem exists_nonlinearRightInverse_of_surjective (f : E â†’SL[Ïƒ] F)\n    (hsurj : LinearMap.range f = âŠ¤) :\n    âˆƒ fsymm : NonlinearRightInverse f, 0 < fsymm.nnnorm := by\n  choose C hC fsymm h using\n    exists_preimage_norm_le _ (LinearMap.range_eq_top.1 hsurj)\n  use {\n      toFun := fsymm\n      nnnorm := âŸ¨C, hC.lt.leâŸ©\n      bound' := fun y => (h y).2\n      right_inv' := fun y => (h y).1 }\n  exact hC\n\n"}
{"name":"ContinuousLinearMap.nonlinearRightInverseOfSurjective_def","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_5\nğ•œ' : Type u_6\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_7\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_8\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap Ïƒ E F\nhsurj : Eq (LinearMap.range f) Top.top\nâŠ¢ Eq (f.nonlinearRightInverseOfSurjective hsurj) (Classical.choose â‹¯)","decl":"/-- A surjective continuous linear map between Banach spaces admits a (possibly nonlinear)\ncontrolled right inverse. In general, it is not possible to ensure that such a right inverse\nis linear (take for instance the map from `E` to `E/F` where `F` is a closed subspace of `E`\nwithout a closed complement. Then it doesn't have a continuous linear right inverse.) -/\nnoncomputable irreducible_def nonlinearRightInverseOfSurjective (f : E â†’SL[Ïƒ] F)\n  (hsurj : LinearMap.range f = âŠ¤) : NonlinearRightInverse f :=\n  Classical.choose (exists_nonlinearRightInverse_of_surjective f hsurj)\n\n"}
{"name":"ContinuousLinearMap.nonlinearRightInverseOfSurjective_nnnorm_pos","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\ninstâœÂ³ : RingHomIsometric Ïƒ\ninstâœÂ² : RingHomIsometric Ïƒ'\ninstâœÂ¹ : CompleteSpace F\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap Ïƒ E F\nhsurj : Eq (LinearMap.range f) Top.top\nâŠ¢ LT.lt 0 (f.nonlinearRightInverseOfSurjective hsurj).nnnorm","decl":"theorem nonlinearRightInverseOfSurjective_nnnorm_pos (f : E â†’SL[Ïƒ] F)\n    (hsurj : LinearMap.range f = âŠ¤) : 0 < (nonlinearRightInverseOfSurjective f hsurj).nnnorm := by\n  rw [nonlinearRightInverseOfSurjective]\n  exact Classical.choose_spec (exists_nonlinearRightInverse_of_surjective f hsurj)\n\n"}
{"name":"LinearEquiv.continuous_symm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\ne : LinearEquiv Ïƒ E F\nh : Continuous â‡‘e\nâŠ¢ Continuous â‡‘e.symm","decl":"/-- If a bounded linear map is a bijection, then its inverse is also a bounded linear map. -/\n@[continuity]\ntheorem continuous_symm (e : E â‰ƒâ‚›â‚—[Ïƒ] F) (h : Continuous e) : Continuous e.symm := by\n  rw [continuous_def]\n  intro s hs\n  rw [â† e.image_eq_preimage]\n  rw [â† e.coe_coe] at h âŠ¢\n  exact ContinuousLinearMap.isOpenMap (Ïƒ := Ïƒ) âŸ¨_, hâŸ© e.surjective s hs\n\n"}
{"name":"LinearEquiv.coeFn_toContinuousLinearEquivOfContinuous","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\ne : LinearEquiv Ïƒ E F\nh : Continuous â‡‘e\nâŠ¢ Eq â‡‘(e.toContinuousLinearEquivOfContinuous h) â‡‘e","decl":"@[simp]\ntheorem coeFn_toContinuousLinearEquivOfContinuous (e : E â‰ƒâ‚›â‚—[Ïƒ] F) (h : Continuous e) :\n    â‡‘(e.toContinuousLinearEquivOfContinuous h) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coeFn_toContinuousLinearEquivOfContinuous_symm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\ne : LinearEquiv Ïƒ E F\nh : Continuous â‡‘e\nâŠ¢ Eq â‡‘(e.toContinuousLinearEquivOfContinuous h).symm â‡‘e.symm","decl":"@[simp]\ntheorem coeFn_toContinuousLinearEquivOfContinuous_symm (e : E â‰ƒâ‚›â‚—[Ïƒ] F) (h : Continuous e) :\n    â‡‘(e.toContinuousLinearEquivOfContinuous h).symm = e.symm :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_linearMap_equivRange","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Function.Injective â‡‘f\nhclo : IsClosed (Set.range â‡‘f)\nâŠ¢ Eq (â†‘(f.equivRange hinj hclo)) f.rangeRestrict","decl":"@[simp]\ntheorem coe_linearMap_equivRange (f : E â†’SL[Ïƒ] F) (hinj : Injective f) (hclo : IsClosed (range f)) :\n    f.equivRange hinj hclo = f.rangeRestrict :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_equivRange","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Function.Injective â‡‘f\nhclo : IsClosed (Set.range â‡‘f)\nâŠ¢ Eq â‡‘(f.equivRange hinj hclo) â‡‘f.rangeRestrict","decl":"@[simp]\ntheorem coe_equivRange (f : E â†’SL[Ïƒ] F) (hinj : Injective f) (hclo : IsClosed (range f)) :\n    (f.equivRange hinj hclo : E â†’ LinearMap.range f) = f.rangeRestrict :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.coeFn_ofBijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\nâŠ¢ Eq â‡‘(ContinuousLinearEquiv.ofBijective f hinj hsurj) â‡‘f","decl":"@[simp]\ntheorem coeFn_ofBijective (f : E â†’SL[Ïƒ] F) (hinj : ker f = âŠ¥) (hsurj : LinearMap.range f = âŠ¤) :\n    â‡‘(ofBijective f hinj hsurj) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.coe_ofBijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\nâŠ¢ Eq (â†‘(ContinuousLinearEquiv.ofBijective f hinj hsurj)) f","decl":"theorem coe_ofBijective (f : E â†’SL[Ïƒ] F) (hinj : ker f = âŠ¥) (hsurj : LinearMap.range f = âŠ¤) :\n    â†‘(ofBijective f hinj hsurj) = f := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearEquiv.ofBijective_symm_apply_apply","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\nx : E\nâŠ¢ Eq ((ContinuousLinearEquiv.ofBijective f hinj hsurj).symm (f x)) x","decl":"@[simp]\ntheorem ofBijective_symm_apply_apply (f : E â†’SL[Ïƒ] F) (hinj : ker f = âŠ¥)\n    (hsurj : LinearMap.range f = âŠ¤) (x : E) : (ofBijective f hinj hsurj).symm (f x) = x :=\n  (ofBijective f hinj hsurj).symm_apply_apply x\n\n"}
{"name":"ContinuousLinearEquiv.ofBijective_apply_symm_apply","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nÏƒ : RingHom ğ•œ ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type u_4\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ' F\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâµ : RingHomInvPair Ïƒ Ïƒ'\ninstâœâ´ : RingHomIsometric Ïƒ\ninstâœÂ³ : RingHomIsometric Ïƒ'\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : RingHomInvPair Ïƒ' Ïƒ\nf : ContinuousLinearMap Ïƒ E F\nhinj : Eq (LinearMap.ker f) Bot.bot\nhsurj : Eq (LinearMap.range f) Top.top\ny : F\nâŠ¢ Eq (f ((ContinuousLinearEquiv.ofBijective f hinj hsurj).symm y)) y","decl":"@[simp]\ntheorem ofBijective_apply_symm_apply (f : E â†’SL[Ïƒ] F) (hinj : ker f = âŠ¥)\n    (hsurj : LinearMap.range f = âŠ¤) (y : F) : f ((ofBijective f hinj hsurj).symm y) = y :=\n  (ofBijective f hinj hsurj).apply_symm_apply y\n\n"}
{"name":"ContinuousLinearMap.isUnit_iff_bijective","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Iff (IsUnit f) (Function.Bijective â‡‘f)","decl":"lemma _root_.ContinuousLinearMap.isUnit_iff_bijective {f : E â†’L[ğ•œ] E} :\n    IsUnit f â†” Bijective f := by\n  constructor\n  Â· rintro âŸ¨f, rflâŸ©\n    exact ofUnit f |>.bijective\n  Â· refine fun h â†¦ âŸ¨toUnit <| .ofBijective f ?_ ?_, rflâŸ© <;>\n    simp only [LinearMap.range_eq_top, LinearMapClass.ker_eq_bot, h.1, h.2]\n\n"}
{"name":"ContinuousLinearMap.range_eq_map_coprodSubtypeLEquivOfIsCompl","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ· : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : CompleteSpace E\nF : Type u_5\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace F\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nG : Submodule ğ•œ F\nh : IsCompl (LinearMap.range f) G\ninstâœ : CompleteSpace (Subtype fun x => Membership.mem G x)\nhker : Eq (LinearMap.ker f) Bot.bot\nâŠ¢ Eq (LinearMap.range f) (Submodule.map (â†‘â†‘(f.coprodSubtypeLEquivOfIsCompl h hker)) (Top.top.prod Bot.bot))","decl":"theorem range_eq_map_coprodSubtypeLEquivOfIsCompl {F : Type*} [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (f : E â†’L[ğ•œ] F) {G : Submodule ğ•œ F}\n    (h : IsCompl (LinearMap.range f) G) [CompleteSpace G] (hker : ker f = âŠ¥) :\n    LinearMap.range f =\n      ((âŠ¤ : Submodule ğ•œ E).prod (âŠ¥ : Submodule ğ•œ G)).map\n        (f.coprodSubtypeLEquivOfIsCompl h hker : E Ã— G â†’â‚—[ğ•œ] F) := by\n  rw [coprodSubtypeLEquivOfIsCompl, ContinuousLinearEquiv.coe_ofBijective,\n    coe_coprod, LinearMap.coprod_map_prod, Submodule.map_bot, sup_bot_eq, Submodule.map_top]\n  rfl\n\n/- TODO: remove the assumption `f.ker = âŠ¥` in the next lemma, by using the map induced by `f` on\n`E / f.ker`, once we have quotient normed spaces. -/\n"}
{"name":"ContinuousLinearMap.closed_complemented_range_of_isCompl_of_ker_eq_bot","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nG : Submodule ğ•œ F\nh : IsCompl (LinearMap.range f) G\nhG : IsClosed â†‘G\nhker : Eq (LinearMap.ker f) Bot.bot\nâŠ¢ IsClosed â†‘(LinearMap.range f)","decl":"theorem closed_complemented_range_of_isCompl_of_ker_eq_bot {F : Type*} [NormedAddCommGroup F]\n    [NormedSpace ğ•œ F] [CompleteSpace F] (f : E â†’L[ğ•œ] F) (G : Submodule ğ•œ F)\n    (h : IsCompl (LinearMap.range f) G) (hG : IsClosed (G : Set F)) (hker : ker f = âŠ¥) :\n    IsClosed (LinearMap.range f : Set F) := by\n  haveI : CompleteSpace G := hG.completeSpace_coe\n  let g := coprodSubtypeLEquivOfIsCompl f h hker\n  -- Porting note: was `rw [congr_arg coe ...]`\n  rw [range_eq_map_coprodSubtypeLEquivOfIsCompl f h hker]\n  apply g.toHomeomorph.isClosed_image.2\n  exact isClosed_univ.prod isClosed_singleton\n\n"}
{"name":"LinearMap.continuous_of_isClosed_graph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : IsClosed â†‘g.graph\nâŠ¢ Continuous â‡‘g","decl":"/-- The **closed graph theorem** : a linear map between two Banach spaces whose graph is closed\nis continuous. -/\ntheorem LinearMap.continuous_of_isClosed_graph (hg : IsClosed (g.graph : Set <| E Ã— F)) :\n    Continuous g := by\n  letI : CompleteSpace g.graph := completeSpace_coe_iff_isComplete.mpr hg.isComplete\n  let Ï†â‚€ : E â†’â‚—[ğ•œ] E Ã— F := LinearMap.id.prod g\n  have : Function.LeftInverse Prod.fst Ï†â‚€ := fun x => rfl\n  let Ï† : E â‰ƒâ‚—[ğ•œ] g.graph :=\n    (LinearEquiv.ofLeftInverse this).trans (LinearEquiv.ofEq _ _ g.graph_eq_range_prod.symm)\n  let Ïˆ : g.graph â‰ƒL[ğ•œ] E :=\n    Ï†.symm.toContinuousLinearEquivOfContinuous continuous_subtype_val.fst\n  exact (continuous_subtype_val.comp Ïˆ.symm.continuous).snd\n\n"}
{"name":"LinearMap.continuous_of_seq_closed_graph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : âˆ€ (u : Nat â†’ E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (Function.comp (â‡‘g) u) Filter.atTop (nhds y) â†’ Eq y (g x)\nâŠ¢ Continuous â‡‘g","decl":"/-- A useful form of the **closed graph theorem** : let `f` be a linear map between two Banach\nspaces. To show that `f` is continuous, it suffices to show that for any convergent sequence\n`uâ‚™ âŸ¶ x`, if `f(uâ‚™) âŸ¶ y` then `y = f(x)`. -/\ntheorem LinearMap.continuous_of_seq_closed_graph\n    (hg : âˆ€ (u : â„• â†’ E) (x y), Tendsto u atTop (ğ“ x) â†’ Tendsto (g âˆ˜ u) atTop (ğ“ y) â†’ y = g x) :\n    Continuous g := by\n  refine g.continuous_of_isClosed_graph (IsSeqClosed.isClosed ?_)\n  rintro Ï† âŸ¨x, yâŸ© hÏ†g hÏ†\n  refine hg (Prod.fst âˆ˜ Ï†) x y ((continuous_fst.tendsto _).comp hÏ†) ?_\n  have : g âˆ˜ Prod.fst âˆ˜ Ï† = Prod.snd âˆ˜ Ï† := by\n    ext n\n    exact (hÏ†g n).symm\n  rw [this]\n  exact (continuous_snd.tendsto _).comp hÏ†\n\n"}
{"name":"ContinuousLinearMap.coeFn_ofIsClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : IsClosed â†‘g.graph\nâŠ¢ Eq â‡‘(ContinuousLinearMap.ofIsClosedGraph hg) â‡‘g","decl":"@[simp]\ntheorem coeFn_ofIsClosedGraph (hg : IsClosed (g.graph : Set <| E Ã— F)) :\n    â‡‘(ContinuousLinearMap.ofIsClosedGraph hg) = g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_ofIsClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : IsClosed â†‘g.graph\nâŠ¢ Eq (â†‘(ContinuousLinearMap.ofIsClosedGraph hg)) g","decl":"theorem coe_ofIsClosedGraph (hg : IsClosed (g.graph : Set <| E Ã— F)) :\n    â†‘(ContinuousLinearMap.ofIsClosedGraph hg) = g := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coeFn_ofSeqClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : âˆ€ (u : Nat â†’ E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (Function.comp (â‡‘g) u) Filter.atTop (nhds y) â†’ Eq y (g x)\nâŠ¢ Eq â‡‘(ContinuousLinearMap.ofSeqClosedGraph hg) â‡‘g","decl":"@[simp]\ntheorem coeFn_ofSeqClosedGraph\n    (hg : âˆ€ (u : â„• â†’ E) (x y), Tendsto u atTop (ğ“ x) â†’ Tendsto (g âˆ˜ u) atTop (ğ“ y) â†’ y = g x) :\n    â‡‘(ContinuousLinearMap.ofSeqClosedGraph hg) = g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_ofSeqClosedGraph","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : CompleteSpace E\nF : Type u_5\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\ng : LinearMap (RingHom.id ğ•œ) E F\nhg : âˆ€ (u : Nat â†’ E) (x : E) (y : F), Filter.Tendsto u Filter.atTop (nhds x) â†’ Filter.Tendsto (Function.comp (â‡‘g) u) Filter.atTop (nhds y) â†’ Eq y (g x)\nâŠ¢ Eq (â†‘(ContinuousLinearMap.ofSeqClosedGraph hg)) g","decl":"theorem coe_ofSeqClosedGraph\n    (hg : âˆ€ (u : â„• â†’ E) (x y), Tendsto u atTop (ğ“ x) â†’ Tendsto (g âˆ˜ u) atTop (ğ“ y) â†’ y = g x) :\n    â†‘(ContinuousLinearMap.ofSeqClosedGraph hg) = g := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.closed_range_of_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œ'\nE : Type u_3\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nÏƒ : RingHom ğ•œ ğ•œ'\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœÂ³ : RingHomInvPair Ïƒ Ïƒ'\nF : Type u_4\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : CompleteSpace E\nf : ContinuousLinearMap Ïƒ E F\nc : NNReal\nhf : AntilipschitzWith c â‡‘f\nâŠ¢ Eq (LinearMap.range f).topologicalClosure (LinearMap.range f)","decl":"lemma closed_range_of_antilipschitz {f : E â†’SL[Ïƒ] F} {c : â„â‰¥0} (hf : AntilipschitzWith c f) :\n    (LinearMap.range f).topologicalClosure = LinearMap.range f :=\n  SetLike.ext'_iff.mpr <| (hf.isClosed_range f.uniformContinuous).closure_eq\n\n"}
{"name":"AntilipschitzWith.completeSpace_range_clm","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œ'\nE : Type u_3\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ğ•œ E\nÏƒ : RingHom ğ•œ ğ•œ'\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ´ : RingHomInvPair Ïƒ Ïƒ'\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ' F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nf : ContinuousLinearMap Ïƒ E F\nc : NNReal\nhf : AntilipschitzWith c â‡‘f\nâŠ¢ CompleteSpace (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"lemma _root_.AntilipschitzWith.completeSpace_range_clm {f : E â†’SL[Ïƒ] F} {c : â„â‰¥0}\n    (hf : AntilipschitzWith c f) : CompleteSpace (LinearMap.range f) :=\n  IsClosed.completeSpace_coe <| hf.isClosed_range f.uniformContinuous\n\n"}
{"name":"ContinuousLinearMap.bijective_iff_dense_range_and_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.Banach","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œ\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\nE : Type u_3\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nÏƒ : RingHom ğ•œ ğ•œ'\nÏƒ' : RingHom ğ•œ' ğ•œ\ninstâœâ· : RingHomInvPair Ïƒ Ïƒ'\nF : Type u_4\ninstâœâ¶ : NormedAddCommGroup F\ninstâœâµ : NormedSpace ğ•œ' F\ninstâœâ´ : CompleteSpace E\ninstâœÂ³ : CompleteSpace F\ninstâœÂ² : RingHomInvPair Ïƒ' Ïƒ\ninstâœÂ¹ : RingHomIsometric Ïƒ\ninstâœ : RingHomIsometric Ïƒ'\nf : ContinuousLinearMap Ïƒ E F\nâŠ¢ Iff (Function.Bijective â‡‘f) (And (Eq (LinearMap.range f).topologicalClosure Top.top) (Exists fun c => AntilipschitzWith c â‡‘f))","decl":"lemma bijective_iff_dense_range_and_antilipschitz (f : E â†’SL[Ïƒ] F) :\n    Bijective f â†” (LinearMap.range f).topologicalClosure = âŠ¤ âˆ§ âˆƒ c, AntilipschitzWith c f := by\n  refine âŸ¨fun h â†¦ âŸ¨?eq_top, ?antiâŸ©, fun âŸ¨hd, c, hfâŸ© â†¦ âŸ¨hf.injective, ?surjâŸ©âŸ©\n  case eq_top => simpa [SetLike.ext'_iff] using h.2.denseRange.closure_eq\n  case anti =>\n    refine âŸ¨_, ContinuousLinearEquiv.ofBijective f ?_ ?_ |>.antilipschitzâŸ© <;>\n    simp only [LinearMap.range_eq_top, LinearMapClass.ker_eq_bot, h.1, h.2]\n  case surj => rwa [â† LinearMap.range_eq_top, â† closed_range_of_antilipschitz hf]\n\n"}
