{"name":"CategoryTheory.Pseudofunctor.Grothendieck.ext","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nx y : F.Grothendieck\nbase : Eq x.base y.base\nfiber : HEq x.fiber y.fiber\nâŠ¢ Eq x y","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®áµ’áµ–) Cat.{vâ‚‚, uâ‚‚}) where\n  /-- The underlying object in the base category. -/\n  base : ğ’®\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj âŸ¨op baseâŸ©\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\ninstâœ : SizeOf ğ’®\nbase : ğ’®\nfiber : â†‘(F.obj { as := { unop := base } })\nâŠ¢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®áµ’áµ–) Cat.{vâ‚‚, uâ‚‚}) where\n  /-- The underlying object in the base category. -/\n  base : ğ’®\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj âŸ¨op baseâŸ©\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nx y : F.Grothendieck\nâŠ¢ Iff (Eq x y) (And (Eq x.base y.base) (HEq x.fiber y.fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®áµ’áµ–) Cat.{vâ‚‚, uâ‚‚}) where\n  /-- The underlying object in the base category. -/\n  base : ğ’®\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj âŸ¨op baseâŸ©\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nbaseâœ : ğ’®\nfiberâœ : â†‘(F.obj { as := { unop := baseâœ } })\nbase : ğ’®\nfiber : â†‘(F.obj { as := { unop := base } })\nxâœ : Eq { base := baseâœ, fiber := fiberâœ } { base := base, fiber := fiber }\nâŠ¢ And (Eq baseâœ base) (HEq fiberâœ fiber)","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®áµ’áµ–) Cat.{vâ‚‚, uâ‚‚}) where\n  /-- The underlying object in the base category. -/\n  base : ğ’®\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj âŸ¨op baseâŸ©\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nbaseâœ : ğ’®\nfiberâœ : â†‘(F.obj { as := { unop := baseâœ } })\nbase : ğ’®\nfiber : â†‘(F.obj { as := { unop := base } })\nâŠ¢ Eq (Eq { base := baseâœ, fiber := fiberâœ } { base := base, fiber := fiber }) (And (Eq baseâœ base) (HEq fiberâœ fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete ğ’®áµ’áµ–) Cat.{vâ‚‚, uâ‚‚}) where\n  /-- The underlying object in the base category. -/\n  base : ğ’®\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj âŸ¨op baseâŸ©\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX Y : F.Grothendieck\ninstâœ : SizeOf ğ’®\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\nâŠ¢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/-- A morphism in the Grothendieck category `F : C â¥¤ Cat` consists of\n`base : X.base âŸ¶ Y.base` and `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`.\n-/\nstructure Hom (X Y : âˆ« F) where\n  /-- The morphism between base objects. -/\n  base : X.base âŸ¶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber âŸ¶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX Y : F.Grothendieck\nbaseâœ : Quiver.Hom X.base Y.base\nfiberâœ : Quiver.Hom X.fiber ((F.map baseâœ.op.toLoc).obj Y.fiber)\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\nxâœ : Eq { base := baseâœ, fiber := fiberâœ } { base := base, fiber := fiber }\nâŠ¢ And (Eq baseâœ base) (HEq fiberâœ fiber)","decl":"/-- A morphism in the Grothendieck category `F : C â¥¤ Cat` consists of\n`base : X.base âŸ¶ Y.base` and `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`.\n-/\nstructure Hom (X Y : âˆ« F) where\n  /-- The morphism between base objects. -/\n  base : X.base âŸ¶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber âŸ¶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX Y : F.Grothendieck\nbaseâœ : Quiver.Hom X.base Y.base\nfiberâœ : Quiver.Hom X.fiber ((F.map baseâœ.op.toLoc).obj Y.fiber)\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\nâŠ¢ Eq (Eq { base := baseâœ, fiber := fiberâœ } { base := base, fiber := fiber }) (And (Eq baseâœ base) (HEq fiberâœ fiber))","decl":"/-- A morphism in the Grothendieck category `F : C â¥¤ Cat` consists of\n`base : X.base âŸ¶ Y.base` and `f.fiber : (F.map base).obj X.fiber âŸ¶ Y.fiber`.\n-/\nstructure Hom (X Y : âˆ« F) where\n  /-- The morphism between base objects. -/\n  base : X.base âŸ¶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber âŸ¶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_id_base","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX : F.Grothendieck\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).base (CategoryTheory.CategoryStruct.id X.base)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (âˆ« F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := ğŸ™ X.base\n    fiber := (F.mapId âŸ¨op X.baseâŸ©).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base â‰« g.base\n    fiber := f.fiber â‰« (F.map f.base.op.toLoc).map g.fiber â‰«\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_comp_base","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nxâœÂ¹ xâœ Z : F.Grothendieck\nf : Quiver.Hom xâœÂ¹ xâœ\ng : Quiver.Hom xâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (âˆ« F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := ğŸ™ X.base\n    fiber := (F.mapId âŸ¨op X.baseâŸ©).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base â‰« g.base\n    fiber := f.fiber â‰« (F.map f.base.op.toLoc).map g.fiber â‰«\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_Hom","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX Y : F.Grothendieck\nâŠ¢ Eq (Quiver.Hom X Y) (X.Hom Y)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (âˆ« F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := ğŸ™ X.base\n    fiber := (F.mapId âŸ¨op X.baseâŸ©).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base â‰« g.base\n    fiber := f.fiber â‰« (F.map f.base.op.toLoc).map g.fiber â‰«\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_id_fiber","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX : F.Grothendieck\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X).fiber ((F.mapId { as := { unop := X.base } }).inv.app X.fiber)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (âˆ« F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := ğŸ™ X.base\n    fiber := (F.mapId âŸ¨op X.baseâŸ©).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base â‰« g.base\n    fiber := f.fiber â‰« (F.map f.base.op.toLoc).map g.fiber â‰«\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_comp_fiber","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nxâœÂ¹ xâœ Z : F.Grothendieck\nf : Quiver.Hom xâœÂ¹ xâœ\ng : Quiver.Hom xâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).fiber (CategoryTheory.CategoryStruct.comp f.fiber (CategoryTheory.CategoryStruct.comp ((F.map f.base.op.toLoc).map g.fiber) ((F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber)))","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (âˆ« F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := ğŸ™ X.base\n    fiber := (F.mapId âŸ¨op X.baseâŸ©).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base â‰« g.base\n    fiber := f.fiber â‰« (F.map f.base.op.toLoc).map g.fiber â‰«\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.ext","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\nhfgâ‚ : Eq f.base g.base\nhfgâ‚‚ : Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom â‹¯))\nâŠ¢ Eq f g","decl":"@[ext (iff := false)]\nlemma Hom.ext (f g : a âŸ¶ b) (hfgâ‚ : f.base = g.base)\n    (hfgâ‚‚ : f.fiber = g.fiber â‰« eqToHom (hfgâ‚ â–¸ rfl)) : f = g := by\n  cases f; cases g\n  congr\n  dsimp at hfgâ‚\n  rw [â† conj_eqToHom_iff_heq _ _ rfl (hfgâ‚ â–¸ rfl)]\n  simpa only [eqToHom_refl, id_comp] using hfgâ‚‚\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\nâŠ¢ Iff (Eq f g) (Exists fun hfg => Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom â‹¯)))","decl":"lemma Hom.ext_iff (f g : a âŸ¶ b) :\n    f = g â†” âˆƒ (hfg : f.base = g.base), f.fiber = g.fiber â‰« eqToHom (hfg â–¸ rfl) where\n  mp hfg := âŸ¨by rw [hfg], by simp [hfg]âŸ©\n  mpr := fun âŸ¨hfgâ‚, hfgâ‚‚âŸ© => Hom.ext f g hfgâ‚ hfgâ‚‚\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.congr","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\nh : Eq f g\nâŠ¢ Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom â‹¯))","decl":"lemma Hom.congr {a b : âˆ« F} {f g : a âŸ¶ b} (h : f = g) :\n    f.fiber = g.fiber â‰« eqToHom (h â–¸ rfl) := by\n  simp [h]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.forget_obj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nX : F.Grothendieck\nâŠ¢ Eq ((CategoryTheory.Pseudofunctor.Grothendieck.forget F).obj X) X.base","decl":"/-- The projection `âˆ« F â¥¤ ğ’®` given by projecting both objects and homs to the first\nfactor. -/\n@[simps]\ndef forget : âˆ« F â¥¤ ğ’® where\n  obj X := X.base\n  map f := f.base\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.forget_map","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite ğ’®)) CategoryTheory.Cat\nXâœ Yâœ : F.Grothendieck\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.Pseudofunctor.Grothendieck.forget F).map f) f.base","decl":"/-- The projection `âˆ« F â¥¤ ğ’®` given by projecting both objects and homs to the first\nfactor. -/\n@[simps]\ndef forget : âˆ« F â¥¤ ğ’® where\n  obj X := X.base\n  map f := f.base\n\n"}
