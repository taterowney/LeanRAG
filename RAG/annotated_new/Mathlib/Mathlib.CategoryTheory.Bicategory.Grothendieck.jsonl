{"name":"CategoryTheory.Pseudofunctor.Grothendieck.ext","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nx y : F.Grothendieck\nbase : Eq x.base y.base\nfiber : HEq x.fiber y.fiber\n⊢ Eq x y","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete 𝒮ᵒᵖ) Cat.{v₂, u₂}) where\n  /-- The underlying object in the base category. -/\n  base : 𝒮\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj ⟨op base⟩\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\ninst✝ : SizeOf 𝒮\nbase : 𝒮\nfiber : ↑(F.obj { as := { unop := base } })\n⊢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete 𝒮ᵒᵖ) Cat.{v₂, u₂}) where\n  /-- The underlying object in the base category. -/\n  base : 𝒮\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj ⟨op base⟩\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nx y : F.Grothendieck\n⊢ Iff (Eq x y) (And (Eq x.base y.base) (HEq x.fiber y.fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete 𝒮ᵒᵖ) Cat.{v₂, u₂}) where\n  /-- The underlying object in the base category. -/\n  base : 𝒮\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj ⟨op base⟩\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nbase✝ : 𝒮\nfiber✝ : ↑(F.obj { as := { unop := base✝ } })\nbase : 𝒮\nfiber : ↑(F.obj { as := { unop := base } })\nx✝ : Eq { base := base✝, fiber := fiber✝ } { base := base, fiber := fiber }\n⊢ And (Eq base✝ base) (HEq fiber✝ fiber)","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete 𝒮ᵒᵖ) Cat.{v₂, u₂}) where\n  /-- The underlying object in the base category. -/\n  base : 𝒮\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj ⟨op base⟩\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nbase✝ : 𝒮\nfiber✝ : ↑(F.obj { as := { unop := base✝ } })\nbase : 𝒮\nfiber : ↑(F.obj { as := { unop := base } })\n⊢ Eq (Eq { base := base✝, fiber := fiber✝ } { base := base, fiber := fiber }) (And (Eq base✝ base) (HEq fiber✝ fiber))","decl":"/-- The type of objects in the fibered category associated to a presheaf valued in types. -/\n@[ext]\nstructure Pseudofunctor.Grothendieck (F : Pseudofunctor (LocallyDiscrete 𝒮ᵒᵖ) Cat.{v₂, u₂}) where\n  /-- The underlying object in the base category. -/\n  base : 𝒮\n  /-- The object in the fiber of the base object. -/\n  fiber : F.obj ⟨op base⟩\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX Y : F.Grothendieck\ninst✝ : SizeOf 𝒮\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\n⊢ Eq (SizeOf.sizeOf { base := base, fiber := fiber }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf fiber))","decl":"/-- A morphism in the Grothendieck category `F : C ⥤ Cat` consists of\n`base : X.base ⟶ Y.base` and `f.fiber : (F.map base).obj X.fiber ⟶ Y.fiber`.\n-/\nstructure Hom (X Y : ∫ F) where\n  /-- The morphism between base objects. -/\n  base : X.base ⟶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber ⟶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX Y : F.Grothendieck\nbase✝ : Quiver.Hom X.base Y.base\nfiber✝ : Quiver.Hom X.fiber ((F.map base✝.op.toLoc).obj Y.fiber)\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\nx✝ : Eq { base := base✝, fiber := fiber✝ } { base := base, fiber := fiber }\n⊢ And (Eq base✝ base) (HEq fiber✝ fiber)","decl":"/-- A morphism in the Grothendieck category `F : C ⥤ Cat` consists of\n`base : X.base ⟶ Y.base` and `f.fiber : (F.map base).obj X.fiber ⟶ Y.fiber`.\n-/\nstructure Hom (X Y : ∫ F) where\n  /-- The morphism between base objects. -/\n  base : X.base ⟶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber ⟶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX Y : F.Grothendieck\nbase✝ : Quiver.Hom X.base Y.base\nfiber✝ : Quiver.Hom X.fiber ((F.map base✝.op.toLoc).obj Y.fiber)\nbase : Quiver.Hom X.base Y.base\nfiber : Quiver.Hom X.fiber ((F.map base.op.toLoc).obj Y.fiber)\n⊢ Eq (Eq { base := base✝, fiber := fiber✝ } { base := base, fiber := fiber }) (And (Eq base✝ base) (HEq fiber✝ fiber))","decl":"/-- A morphism in the Grothendieck category `F : C ⥤ Cat` consists of\n`base : X.base ⟶ Y.base` and `f.fiber : (F.map base).obj X.fiber ⟶ Y.fiber`.\n-/\nstructure Hom (X Y : ∫ F) where\n  /-- The morphism between base objects. -/\n  base : X.base ⟶ Y.base\n  /-- The morphism in the fiber over the domain. -/\n  fiber : X.fiber ⟶ (F.map base.op.toLoc).obj Y.fiber\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_id_base","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX : F.Grothendieck\n⊢ Eq (CategoryTheory.CategoryStruct.id X).base (CategoryTheory.CategoryStruct.id X.base)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (∫ F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := 𝟙 X.base\n    fiber := (F.mapId ⟨op X.base⟩).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base ≫ g.base\n    fiber := f.fiber ≫ (F.map f.base.op.toLoc).map g.fiber ≫\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_comp_base","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nx✝¹ x✝ Z : F.Grothendieck\nf : Quiver.Hom x✝¹ x✝\ng : Quiver.Hom x✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (∫ F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := 𝟙 X.base\n    fiber := (F.mapId ⟨op X.base⟩).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base ≫ g.base\n    fiber := f.fiber ≫ (F.map f.base.op.toLoc).map g.fiber ≫\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_Hom","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX Y : F.Grothendieck\n⊢ Eq (Quiver.Hom X Y) (X.Hom Y)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (∫ F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := 𝟙 X.base\n    fiber := (F.mapId ⟨op X.base⟩).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base ≫ g.base\n    fiber := f.fiber ≫ (F.map f.base.op.toLoc).map g.fiber ≫\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_id_fiber","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX : F.Grothendieck\n⊢ Eq (CategoryTheory.CategoryStruct.id X).fiber ((F.mapId { as := { unop := X.base } }).inv.app X.fiber)","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (∫ F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := 𝟙 X.base\n    fiber := (F.mapId ⟨op X.base⟩).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base ≫ g.base\n    fiber := f.fiber ≫ (F.map f.base.op.toLoc).map g.fiber ≫\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.categoryStruct_comp_fiber","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nx✝¹ x✝ Z : F.Grothendieck\nf : Quiver.Hom x✝¹ x✝\ng : Quiver.Hom x✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).fiber (CategoryTheory.CategoryStruct.comp f.fiber (CategoryTheory.CategoryStruct.comp ((F.map f.base.op.toLoc).map g.fiber) ((F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber)))","decl":"@[simps!]\ninstance categoryStruct : CategoryStruct (∫ F) where\n  Hom X Y := Hom X Y\n  id X := {\n    base := 𝟙 X.base\n    fiber := (F.mapId ⟨op X.base⟩).inv.app X.fiber }\n  comp {_ _ Z} f g := {\n    base := f.base ≫ g.base\n    fiber := f.fiber ≫ (F.map f.base.op.toLoc).map g.fiber ≫\n      (F.mapComp g.base.op.toLoc f.base.op.toLoc).inv.app Z.fiber }\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.ext","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\nhfg₁ : Eq f.base g.base\nhfg₂ : Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom ⋯))\n⊢ Eq f g","decl":"@[ext (iff := false)]\nlemma Hom.ext (f g : a ⟶ b) (hfg₁ : f.base = g.base)\n    (hfg₂ : f.fiber = g.fiber ≫ eqToHom (hfg₁ ▸ rfl)) : f = g := by\n  cases f; cases g\n  congr\n  dsimp at hfg₁\n  rw [← conj_eqToHom_iff_heq _ _ rfl (hfg₁ ▸ rfl)]\n  simpa only [eqToHom_refl, id_comp] using hfg₂\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.ext_iff","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\n⊢ Iff (Eq f g) (Exists fun hfg => Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom ⋯)))","decl":"lemma Hom.ext_iff (f g : a ⟶ b) :\n    f = g ↔ ∃ (hfg : f.base = g.base), f.fiber = g.fiber ≫ eqToHom (hfg ▸ rfl) where\n  mp hfg := ⟨by rw [hfg], by simp [hfg]⟩\n  mpr := fun ⟨hfg₁, hfg₂⟩ => Hom.ext f g hfg₁ hfg₂\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.Hom.congr","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\na b : F.Grothendieck\nf g : Quiver.Hom a b\nh : Eq f g\n⊢ Eq f.fiber (CategoryTheory.CategoryStruct.comp g.fiber (CategoryTheory.eqToHom ⋯))","decl":"lemma Hom.congr {a b : ∫ F} {f g : a ⟶ b} (h : f = g) :\n    f.fiber = g.fiber ≫ eqToHom (h ▸ rfl) := by\n  simp [h]\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.forget_obj","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX : F.Grothendieck\n⊢ Eq ((CategoryTheory.Pseudofunctor.Grothendieck.forget F).obj X) X.base","decl":"/-- The projection `∫ F ⥤ 𝒮` given by projecting both objects and homs to the first\nfactor. -/\n@[simps]\ndef forget : ∫ F ⥤ 𝒮 where\n  obj X := X.base\n  map f := f.base\n\n"}
{"name":"CategoryTheory.Pseudofunctor.Grothendieck.forget_map","module":"Mathlib.CategoryTheory.Bicategory.Grothendieck","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nF : CategoryTheory.Pseudofunctor (CategoryTheory.LocallyDiscrete (Opposite 𝒮)) CategoryTheory.Cat\nX✝ Y✝ : F.Grothendieck\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Pseudofunctor.Grothendieck.forget F).map f) f.base","decl":"/-- The projection `∫ F ⥤ 𝒮` given by projecting both objects and homs to the first\nfactor. -/\n@[simps]\ndef forget : ∫ F ⥤ 𝒮 where\n  obj X := X.base\n  map f := f.base\n\n"}
