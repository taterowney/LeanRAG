{"name":"Fin.top_eq_last","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq Top.top (Fin.last n)","decl":"lemma top_eq_last (n : ℕ) : ⊤ = Fin.last n := rfl\n\n"}
{"name":"Fin.bot_eq_zero","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq Bot.bot 0","decl":"lemma bot_eq_zero (n : ℕ) [NeZero n] : ⊥ = (0 : Fin n) := rfl\n\n"}
{"name":"Fin.rev_bot","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq Bot.bot.rev Top.top","decl":"@[simp] theorem rev_bot [NeZero n] : rev (⊥ : Fin n) = ⊤ := rfl\n"}
{"name":"Fin.rev_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq Top.top.rev Bot.bot","decl":"@[simp] theorem rev_top [NeZero n] : rev (⊤ : Fin n) = ⊥ := rev_rev _\n\n"}
{"name":"Fin.rev_zero_eq_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (Fin.rev 0) Top.top","decl":"theorem rev_zero_eq_top (n : ℕ) [NeZero n] : rev (0 : Fin n) = ⊤ := rfl\n"}
{"name":"Fin.rev_last_eq_bot","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.last n).rev Bot.bot","decl":"theorem rev_last_eq_bot (n : ℕ) : rev (last n) = ⊥ := by rw [rev_last, bot_eq_zero]\n\n"}
{"name":"Fin.succ_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq Top.top.succ Top.top","decl":"@[simp]\ntheorem succ_top (n : ℕ) [NeZero n] : (⊤ : Fin n).succ = ⊤ := by\n  rw [← rev_zero_eq_top, ← rev_zero_eq_top, ← rev_castSucc, castSucc_zero']\n\n"}
{"name":"Fin.val_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑Top.top) (HSub.hSub n 1)","decl":"@[simp]\ntheorem val_top (n : ℕ) [NeZero n] : ((⊤ : Fin n) : ℕ) = n - 1 := rfl\n\n"}
{"name":"Fin.zero_eq_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Iff (Eq 0 Top.top) (Eq n 1)","decl":"@[simp]\ntheorem zero_eq_top {n : ℕ} [NeZero n] : (0 : Fin n) = ⊤ ↔ n = 1 := by\n  rw [← bot_eq_zero, subsingleton_iff_bot_eq_top, subsingleton_iff_le_one, LE.le.le_iff_eq]\n  exact pos_of_neZero n\n\n"}
{"name":"Fin.top_eq_zero","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Iff (Eq Top.top 0) (Eq n 1)","decl":"@[simp]\ntheorem top_eq_zero {n : ℕ} [NeZero n] : (⊤ : Fin n) = 0 ↔ n = 1 :=\n  eq_comm.trans zero_eq_top\n\n"}
{"name":"Fin.cast_top","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\ninst✝¹ : NeZero m\ninst✝ : NeZero n\nh : Eq m n\n⊢ Eq (Fin.cast h Top.top) Top.top","decl":"@[simp]\ntheorem cast_top {m n : ℕ} [NeZero m] [NeZero n] (h : m = n) : (⊤ : Fin m).cast h = ⊤ := by\n  simp [← val_inj, h]\n\n"}
{"name":"Fin.strictMono_pred_comp","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : α → Fin (HAdd.hAdd n 1)\nhf : ∀ (a : α), Ne (f a) 0\nhf₂ : StrictMono f\n⊢ StrictMono fun a => (f a).pred ⋯","decl":"lemma strictMono_pred_comp (hf : ∀ a, f a ≠ 0) (hf₂ : StrictMono f) :\n    StrictMono (fun a => pred (f a) (hf a)) := fun _ _ h => pred_lt_pred_iff.2 (hf₂ h)\n\n"}
{"name":"Fin.monotone_pred_comp","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : α → Fin (HAdd.hAdd n 1)\nhf : ∀ (a : α), Ne (f a) 0\nhf₂ : Monotone f\n⊢ Monotone fun a => (f a).pred ⋯","decl":"lemma monotone_pred_comp (hf : ∀ a, f a ≠ 0) (hf₂ : Monotone f) :\n    Monotone (fun a => pred (f a) (hf a)) := fun _ _ h => pred_le_pred_iff.2 (hf₂ h)\n\n"}
{"name":"Fin.strictMono_castPred_comp","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : α → Fin (HAdd.hAdd n 1)\nhf : ∀ (a : α), Ne (f a) (Fin.last n)\nhf₂ : StrictMono f\n⊢ StrictMono fun a => (f a).castPred ⋯","decl":"lemma strictMono_castPred_comp (hf : ∀ a, f a ≠ last n) (hf₂ : StrictMono f) :\n    StrictMono (fun a => castPred (f a) (hf a)) := fun _ _ h => castPred_lt_castPred_iff.2 (hf₂ h)\n\n"}
{"name":"Fin.monotone_castPred_comp","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : α → Fin (HAdd.hAdd n 1)\nhf : ∀ (a : α), Ne (f a) (Fin.last n)\nhf₂ : Monotone f\n⊢ Monotone fun a => (f a).castPred ⋯","decl":"lemma monotone_castPred_comp (hf : ∀ a, f a ≠ last n) (hf₂ : Monotone f) :\n    Monotone (fun a => castPred (f a) (hf a)) := fun _ _ h => castPred_le_castPred_iff.2 (hf₂ h)\n\n"}
{"name":"Fin.strictMono_iff_lt_succ","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Iff (StrictMono f) (∀ (i : Fin n), LT.lt (f i.castSucc) (f i.succ))","decl":"/-- A function `f` on `Fin (n + 1)` is strictly monotone if and only if `f i < f (i + 1)`\nfor all `i`. -/\nlemma strictMono_iff_lt_succ : StrictMono f ↔ ∀ i : Fin n, f (castSucc i) < f i.succ :=\n  liftFun_iff_succ (· < ·)\n\n"}
{"name":"Fin.monotone_iff_le_succ","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Iff (Monotone f) (∀ (i : Fin n), LE.le (f i.castSucc) (f i.succ))","decl":"/-- A function `f` on `Fin (n + 1)` is monotone if and only if `f i ≤ f (i + 1)` for all `i`. -/\nlemma monotone_iff_le_succ : Monotone f ↔ ∀ i : Fin n, f (castSucc i) ≤ f i.succ :=\n  monotone_iff_forall_lt.trans <| liftFun_iff_succ (· ≤ ·)\n\n"}
{"name":"Fin.strictAnti_iff_succ_lt","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Iff (StrictAnti f) (∀ (i : Fin n), LT.lt (f i.succ) (f i.castSucc))","decl":"/-- A function `f` on `Fin (n + 1)` is strictly antitone if and only if `f (i + 1) < f i`\nfor all `i`. -/\nlemma strictAnti_iff_succ_lt : StrictAnti f ↔ ∀ i : Fin n, f i.succ < f (castSucc i) :=\n  liftFun_iff_succ (· > ·)\n\n"}
{"name":"Fin.antitone_iff_succ_le","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf : Fin (HAdd.hAdd n 1) → α\n⊢ Iff (Antitone f) (∀ (i : Fin n), LE.le (f i.succ) (f i.castSucc))","decl":"/-- A function `f` on `Fin (n + 1)` is antitone if and only if `f (i + 1) ≤ f i` for all `i`. -/\nlemma antitone_iff_succ_le : Antitone f ↔ ∀ i : Fin n, f i.succ ≤ f (castSucc i) :=\n  antitone_iff_forall_lt.trans <| liftFun_iff_succ (· ≥ ·)\n\n"}
{"name":"Fin.orderHom_injective_iff","module":"Mathlib.Order.Fin.Basic","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\nn : Nat\nf : OrderHom (Fin (HAdd.hAdd n 1)) α\n⊢ Iff (Function.Injective ⇑f) (∀ (i : Fin n), Ne (f i.castSucc) (f i.succ))","decl":"lemma orderHom_injective_iff {α : Type*} [PartialOrder α] {n : ℕ} (f : Fin (n + 1) →o α) :\n    Function.Injective f ↔ ∀ (i : Fin n), f i.castSucc ≠ f i.succ := by\n  constructor\n  · intro hf i hi\n    have := hf hi\n    simp [Fin.ext_iff] at this\n  · intro hf\n    refine (strictMono_iff_lt_succ (f := f).2 fun i ↦ ?_).injective\n    exact lt_of_le_of_ne (f.monotone (Fin.castSucc_le_succ i)) (hf i)\n\n"}
{"name":"Fin.val_strictMono","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ StrictMono Fin.val","decl":"lemma val_strictMono : StrictMono (val : Fin n → ℕ) := fun _ _ ↦ id\n"}
{"name":"Fin.cast_strictMono","module":"Mathlib.Order.Fin.Basic","initialProofState":"k l : Nat\nh : Eq k l\n⊢ StrictMono (Fin.cast h)","decl":"lemma cast_strictMono {k l : ℕ} (h : k = l) : StrictMono (Fin.cast h) := fun {_ _} h ↦ h\n\n"}
{"name":"Fin.strictMono_succ","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ StrictMono Fin.succ","decl":"lemma strictMono_succ : StrictMono (succ : Fin n → Fin (n + 1)) := fun _ _ ↦ succ_lt_succ\n"}
{"name":"Fin.strictMono_castLE","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ StrictMono (Fin.castLE h)","decl":"lemma strictMono_castLE (h : n ≤ m) : StrictMono (castLE h : Fin n → Fin m) := fun _ _ ↦ id\n"}
{"name":"Fin.strictMono_castAdd","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\n⊢ StrictMono (Fin.castAdd m)","decl":"lemma strictMono_castAdd (m) : StrictMono (castAdd m : Fin n → Fin (n + m)) := strictMono_castLE _\n"}
{"name":"Fin.strictMono_castSucc","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ StrictMono Fin.castSucc","decl":"lemma strictMono_castSucc : StrictMono (castSucc : Fin n → Fin (n + 1)) := strictMono_castAdd _\n"}
{"name":"Fin.strictMono_natAdd","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\n⊢ StrictMono (Fin.natAdd n)","decl":"lemma strictMono_natAdd (n) : StrictMono (natAdd n : Fin m → Fin (n + m)) :=\n  fun i j h ↦ Nat.add_lt_add_left (show i.val < j.val from h) _\n"}
{"name":"Fin.strictMono_addNat","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\n⊢ StrictMono fun x => x.addNat m","decl":"lemma strictMono_addNat (m) : StrictMono ((addNat · m) : Fin n → Fin (n + m)) :=\n  fun i j h ↦ Nat.add_lt_add_right (show i.val < j.val from h) _\n\n"}
{"name":"Fin.strictMono_succAbove","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ StrictMono p.succAbove","decl":"lemma strictMono_succAbove (p : Fin (n + 1)) : StrictMono (succAbove p) :=\n  strictMono_castSucc.ite strictMono_succ\n    (fun _ _ hij hj => (castSucc_lt_castSucc_iff.mpr hij).trans hj) fun i =>\n    (castSucc_lt_succ i).le\n\n"}
{"name":"Fin.succAbove_lt_succAbove_iff","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni j : Fin n\n⊢ Iff (LT.lt (p.succAbove i) (p.succAbove j)) (LT.lt i j)","decl":"lemma succAbove_lt_succAbove_iff : succAbove p i < succAbove p j ↔ i < j :=\n  (strictMono_succAbove p).lt_iff_lt\n\n"}
{"name":"Fin.succAbove_le_succAbove_iff","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni j : Fin n\n⊢ Iff (LE.le (p.succAbove i) (p.succAbove j)) (LE.le i j)","decl":"lemma succAbove_le_succAbove_iff : succAbove p i ≤ succAbove p j ↔ i ≤ j :=\n  (strictMono_succAbove p).le_iff_le\n\n"}
{"name":"Fin.predAbove_right_monotone","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin n\n⊢ Monotone p.predAbove","decl":"lemma predAbove_right_monotone (p : Fin n) : Monotone p.predAbove := fun a b H => by\n  dsimp [predAbove]\n  split_ifs with ha hb hb\n  all_goals simp only [le_iff_val_le_val, coe_pred]\n  · exact pred_le_pred H\n  · calc\n      _ ≤ _ := Nat.pred_le _\n      _ ≤ _ := H\n  · exact le_pred_of_lt ((not_lt.mp ha).trans_lt hb)\n  · exact H\n\n"}
{"name":"Fin.predAbove_left_monotone","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Monotone fun p => p.predAbove i","decl":"lemma predAbove_left_monotone (i : Fin (n + 1)) : Monotone fun p ↦ predAbove p i := fun a b H ↦ by\n  dsimp [predAbove]\n  split_ifs with ha hb hb\n  · rfl\n  · exact pred_le _\n  · have : b < a := castSucc_lt_castSucc_iff.mpr (hb.trans_le (le_of_not_gt ha))\n    exact absurd H this.not_le\n  · rfl\n\n"}
{"name":"Fin.predAboveOrderHom_coe","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (p.predAboveOrderHom i) (p.predAbove i)","decl":"/--  `Fin.predAbove p` as an `OrderHom`. -/\n@[simps!] def predAboveOrderHom (p : Fin n) : Fin (n + 1) →o Fin n :=\n  ⟨p.predAbove, p.predAbove_right_monotone⟩\n\n"}
{"name":"Fin.orderIsoSubtype_symm_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\na : Subtype fun i => LT.lt i n\n⊢ Eq ((RelIso.symm Fin.orderIsoSubtype) a) ⟨↑a, ⋯⟩","decl":"/-- The equivalence `Fin n ≃ {i // i < n}` is an order isomorphism. -/\n@[simps! apply symm_apply]\ndef orderIsoSubtype : Fin n ≃o {i // i < n} :=\n  equivSubtype.toOrderIso (by simp [Monotone]) (by simp [Monotone])\n\n"}
{"name":"Fin.orderIsoSubtype_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\na : Fin n\n⊢ Eq (Fin.orderIsoSubtype a) ⟨↑a, ⋯⟩","decl":"/-- The equivalence `Fin n ≃ {i // i < n}` is an order isomorphism. -/\n@[simps! apply symm_apply]\ndef orderIsoSubtype : Fin n ≃o {i // i < n} :=\n  equivSubtype.toOrderIso (by simp [Monotone]) (by simp [Monotone])\n\n"}
{"name":"Fin.castOrderIso_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\neq : Eq n m\ni : Fin n\n⊢ Eq ((Fin.castOrderIso eq) i) (Fin.cast eq i)","decl":"/-- `Fin.cast` as an `OrderIso`.\n\n`castOrderIso eq i` embeds `i` into an equal `Fin` type. -/\n@[simps]\ndef castOrderIso (eq : n = m) : Fin n ≃o Fin m where\n  toEquiv := ⟨Fin.cast eq, Fin.cast eq.symm, leftInverse_cast eq, rightInverse_cast eq⟩\n  map_rel_iff' := cast_le_cast eq\n\n"}
{"name":"Fin.castOrderIso_symm_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\neq : Eq n m\ni : Fin m\n⊢ Eq ((RelIso.symm (Fin.castOrderIso eq)) i) (Fin.cast ⋯ i)","decl":"/-- `Fin.cast` as an `OrderIso`.\n\n`castOrderIso eq i` embeds `i` into an equal `Fin` type. -/\n@[simps]\ndef castOrderIso (eq : n = m) : Fin n ≃o Fin m where\n  toEquiv := ⟨Fin.cast eq, Fin.cast eq.symm, leftInverse_cast eq, rightInverse_cast eq⟩\n  map_rel_iff' := cast_le_cast eq\n\n"}
{"name":"Fin.symm_castOrderIso","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\nh : Eq n m\n⊢ Eq (Fin.castOrderIso h).symm (Fin.castOrderIso ⋯)","decl":"@[simp]\nlemma symm_castOrderIso (h : n = m) : (castOrderIso h).symm = castOrderIso h.symm := by subst h; rfl\n\n"}
{"name":"Fin.castOrderIso_refl","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nh : optParam (Eq n n) ⋯\n⊢ Eq (Fin.castOrderIso h) (OrderIso.refl (Fin n))","decl":"@[simp]\nlemma castOrderIso_refl (h : n = n := rfl) : castOrderIso h = OrderIso.refl (Fin n) := by ext; simp\n\n"}
{"name":"Fin.castOrderIso_toEquiv","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\nh : Eq n m\n⊢ Eq (Fin.castOrderIso h).toEquiv (Equiv.cast ⋯)","decl":"/-- While in many cases `Fin.castOrderIso` is better than `Equiv.cast`/`cast`, sometimes we want to\napply a generic lemma about `cast`. -/\nlemma castOrderIso_toEquiv (h : n = m) : (castOrderIso h).toEquiv = Equiv.cast (h ▸ rfl) := by\n  subst h; rfl\n\n"}
{"name":"Fin.revOrderIso_toEquiv","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq Fin.revOrderIso.toEquiv (OrderDual.ofDual.trans Fin.revPerm)","decl":"/-- `Fin.rev n` as an order-reversing isomorphism. -/\n@[simps! apply toEquiv]\ndef revOrderIso : (Fin n)ᵒᵈ ≃o Fin n := ⟨OrderDual.ofDual.trans revPerm, rev_le_rev⟩\n\n"}
{"name":"Fin.revOrderIso_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\na✝ : OrderDual (Fin n)\n⊢ Eq (Fin.revOrderIso a✝) (OrderDual.ofDual a✝).rev","decl":"/-- `Fin.rev n` as an order-reversing isomorphism. -/\n@[simps! apply toEquiv]\ndef revOrderIso : (Fin n)ᵒᵈ ≃o Fin n := ⟨OrderDual.ofDual.trans revPerm, rev_le_rev⟩\n\n"}
{"name":"Fin.revOrderIso_symm_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Fin.revOrderIso.symm i) (OrderDual.toDual i.rev)","decl":"@[simp]\nlemma revOrderIso_symm_apply (i : Fin n) : revOrderIso.symm i = OrderDual.toDual (rev i) := rfl\n\n"}
{"name":"Fin.valOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nself : Fin n\n⊢ Eq ((Fin.valOrderEmb n) self) ↑self","decl":"/-- The inclusion map `Fin n → ℕ` is an order embedding. -/\n@[simps! apply]\ndef valOrderEmb (n) : Fin n ↪o ℕ := ⟨valEmbedding, Iff.rfl⟩\n\n"}
{"name":"Fin.Lt.isWellOrder","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ IsWellOrder (Fin n) fun x1 x2 => LT.lt x1 x2","decl":"/-- The ordering on `Fin n` is a well order. -/\ninstance Lt.isWellOrder (n) : IsWellOrder (Fin n) (· < ·) := (valOrderEmb n).isWellOrder\n\n"}
{"name":"Fin.coe_succOrderEmb","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (⇑(Fin.succOrderEmb n)) Fin.succ","decl":"@[simp, norm_cast] lemma coe_succOrderEmb : ⇑(succOrderEmb n) = Fin.succ := rfl\n\n"}
{"name":"Fin.succOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq (Fin.succOrderEmb n).toEmbedding (Fin.succEmb n)","decl":"@[simp] lemma succOrderEmb_toEmbedding : (succOrderEmb n).toEmbedding = succEmb n := rfl\n\n"}
{"name":"Fin.castLEOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\nh : LE.le n m\ni : Fin n\n⊢ Eq ((Fin.castLEOrderEmb h) i) (Fin.castLE h i)","decl":"/-- `Fin.castLE` as an `OrderEmbedding`.\n\n`castLEEmb h i` embeds `i` into a larger `Fin` type. -/\n@[simps! apply toEmbedding]\ndef castLEOrderEmb (h : n ≤ m) : Fin n ↪o Fin m := .ofStrictMono (castLE h) (strictMono_castLE h)\n\n"}
{"name":"Fin.castLEOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Eq (Fin.castLEOrderEmb h).toEmbedding { toFun := Fin.castLE h, inj' := ⋯ }","decl":"/-- `Fin.castLE` as an `OrderEmbedding`.\n\n`castLEEmb h i` embeds `i` into a larger `Fin` type. -/\n@[simps! apply toEmbedding]\ndef castLEOrderEmb (h : n ≤ m) : Fin n ↪o Fin m := .ofStrictMono (castLE h) (strictMono_castLE h)\n\n"}
{"name":"Fin.castAddOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\na✝ : Fin n\n⊢ Eq ((Fin.castAddOrderEmb m) a✝) (Fin.castAdd m a✝)","decl":"/-- `Fin.castAdd` as an `OrderEmbedding`.\n\n`castAddEmb m i` embeds `i : Fin n` in `Fin (n+m)`. See also `Fin.natAddEmb` and `Fin.addNatEmb`. -/\n@[simps! apply toEmbedding]\ndef castAddOrderEmb (m) : Fin n ↪o Fin (n + m) := .ofStrictMono (castAdd m) (strictMono_castAdd m)\n\n"}
{"name":"Fin.castAddOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\n⊢ Eq (Fin.castAddOrderEmb m).toEmbedding { toFun := Fin.castAdd m, inj' := ⋯ }","decl":"/-- `Fin.castAdd` as an `OrderEmbedding`.\n\n`castAddEmb m i` embeds `i : Fin n` in `Fin (n+m)`. See also `Fin.natAddEmb` and `Fin.addNatEmb`. -/\n@[simps! apply toEmbedding]\ndef castAddOrderEmb (m) : Fin n ↪o Fin (n + m) := .ofStrictMono (castAdd m) (strictMono_castAdd m)\n\n"}
{"name":"Fin.castSuccOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\n⊢ Eq Fin.castSuccOrderEmb.toEmbedding { toFun := Fin.castSucc, inj' := ⋯ }","decl":"/-- `Fin.castSucc` as an `OrderEmbedding`.\n\n`castSuccOrderEmb i` embeds `i : Fin n` in `Fin (n+1)`. -/\n@[simps! apply toEmbedding]\ndef castSuccOrderEmb : Fin n ↪o Fin (n + 1) := .ofStrictMono castSucc strictMono_castSucc\n\n"}
{"name":"Fin.castSuccOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\na✝ : Fin n\n⊢ Eq (Fin.castSuccOrderEmb a✝) a✝.castSucc","decl":"/-- `Fin.castSucc` as an `OrderEmbedding`.\n\n`castSuccOrderEmb i` embeds `i : Fin n` in `Fin (n+1)`. -/\n@[simps! apply toEmbedding]\ndef castSuccOrderEmb : Fin n ↪o Fin (n + 1) := .ofStrictMono castSucc strictMono_castSucc\n\n"}
{"name":"Fin.addNatOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\nx✝ : Fin n\n⊢ Eq ((Fin.addNatOrderEmb m) x✝) (x✝.addNat m)","decl":"/-- `Fin.addNat` as an `OrderEmbedding`.\n\n`addNatOrderEmb m i` adds `m` to `i`, generalizes `Fin.succ`. -/\n@[simps! apply toEmbedding]\ndef addNatOrderEmb (m) : Fin n ↪o Fin (n + m) := .ofStrictMono (addNat · m) (strictMono_addNat m)\n\n"}
{"name":"Fin.addNatOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"n m : Nat\n⊢ Eq (Fin.addNatOrderEmb m).toEmbedding { toFun := fun x => x.addNat m, inj' := ⋯ }","decl":"/-- `Fin.addNat` as an `OrderEmbedding`.\n\n`addNatOrderEmb m i` adds `m` to `i`, generalizes `Fin.succ`. -/\n@[simps! apply toEmbedding]\ndef addNatOrderEmb (m) : Fin n ↪o Fin (n + m) := .ofStrictMono (addNat · m) (strictMono_addNat m)\n\n"}
{"name":"Fin.natAddOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\ni : Fin m\n⊢ Eq ((Fin.natAddOrderEmb n) i) (Fin.natAdd n i)","decl":"/-- `Fin.natAdd` as an `OrderEmbedding`.\n\n`natAddOrderEmb n i` adds `n` to `i` \"on the left\". -/\n@[simps! apply toEmbedding]\ndef natAddOrderEmb (n) : Fin m ↪o Fin (n + m) := .ofStrictMono (natAdd n) (strictMono_natAdd n)\n\n"}
{"name":"Fin.natAddOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\n⊢ Eq (Fin.natAddOrderEmb n).toEmbedding { toFun := Fin.natAdd n, inj' := ⋯ }","decl":"/-- `Fin.natAdd` as an `OrderEmbedding`.\n\n`natAddOrderEmb n i` adds `n` to `i` \"on the left\". -/\n@[simps! apply toEmbedding]\ndef natAddOrderEmb (n) : Fin m ↪o Fin (n + m) := .ofStrictMono (natAdd n) (strictMono_natAdd n)\n\n"}
{"name":"Fin.succAboveOrderEmb_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq (p.succAboveOrderEmb i) (p.succAbove i)","decl":"/--  `Fin.succAbove p` as an `OrderEmbedding`. -/\n@[simps! apply toEmbedding]\ndef succAboveOrderEmb (p : Fin (n + 1)) : Fin n ↪o Fin (n + 1) :=\n  OrderEmbedding.ofStrictMono (succAbove p) (strictMono_succAbove p)\n\n"}
{"name":"Fin.succAboveOrderEmb_toEmbedding","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq p.succAboveOrderEmb.toEmbedding { toFun := p.succAbove, inj' := ⋯ }","decl":"/--  `Fin.succAbove p` as an `OrderEmbedding`. -/\n@[simps! apply toEmbedding]\ndef succAboveOrderEmb (p : Fin (n + 1)) : Fin n ↪o Fin (n + 1) :=\n  OrderEmbedding.ofStrictMono (succAbove p) (strictMono_succAbove p)\n\n"}
{"name":"Fin.coe_orderIso_apply","module":"Mathlib.Order.Fin.Basic","initialProofState":"m n : Nat\ne : OrderIso (Fin n) (Fin m)\ni : Fin n\n⊢ Eq ↑(e i) ↑i","decl":"/-- If `e` is an `orderIso` between `Fin n` and `Fin m`, then `n = m` and `e` is the identity\nmap. In this lemma we state that for each `i : Fin n` we have `(e i : ℕ) = (i : ℕ)`. -/\n@[simp] lemma coe_orderIso_apply (e : Fin n ≃o Fin m) (i : Fin n) : (e i : ℕ) = i := by\n  rcases i with ⟨i, hi⟩\n  dsimp only\n  induction' i using Nat.strong_induction_on with i h\n  refine le_antisymm (forall_lt_iff_le.1 fun j hj => ?_) (forall_lt_iff_le.1 fun j hj => ?_)\n  · have := e.symm.lt_iff_lt.2 (mk_lt_of_lt_val hj)\n    rw [e.symm_apply_apply] at this\n    -- Porting note: convert was abusing definitional equality\n    have : _ < i := this\n    convert this\n    simpa using h _ this (e.symm _).is_lt\n  · rwa [← h j hj (hj.trans hi), ← lt_iff_val_lt_val, e.lt_iff_lt]\n\n"}
{"name":"Fin.strictMono_unique","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf g : Fin n → α\nhf : StrictMono f\nhg : StrictMono g\nh : Eq (Set.range f) (Set.range g)\n⊢ Eq f g","decl":"/-- Two strictly monotone functions from `Fin n` are equal provided that their ranges\nare equal. -/\n@[deprecated StrictMono.range_inj (since := \"2024-09-17\")]\nlemma strictMono_unique {f g : Fin n → α} (hf : StrictMono f) (hg : StrictMono g)\n    (h : range f = range g) : f = g :=\n  (hf.range_inj hg).1 h\n\n"}
{"name":"Fin.orderEmbedding_eq","module":"Mathlib.Order.Fin.Basic","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : Preorder α\nf g : OrderEmbedding (Fin n) α\nh : Eq (Set.range ⇑f) (Set.range ⇑g)\n⊢ Eq f g","decl":"/-- Two order embeddings of `Fin n` are equal provided that their ranges are equal. -/\n@[deprecated OrderEmbedding.range_inj (since := \"2024-09-17\")]\nlemma orderEmbedding_eq {f g : Fin n ↪o α} (h : range f = range g) : f = g :=\n  OrderEmbedding.range_inj.1 h\n\n"}
