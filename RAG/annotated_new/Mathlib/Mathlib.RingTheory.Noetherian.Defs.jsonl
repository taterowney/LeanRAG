{"name":"IsNoetherian.noetherian","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : IsNoetherian R M\ns : Submodule R M\n⊢ s.FG","decl":"/-- `IsNoetherian R M` is the proposition that `M` is a Noetherian `R`-module,\nimplemented as the predicate that all `R`-submodules of `M` are finitely generated.\n-/\n-- Porting note: should this be renamed to `Noetherian`?\nclass IsNoetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M] : Prop where\n  noetherian : ∀ s : Submodule R M, s.FG\n\n"}
{"name":"isNoetherian_def","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsNoetherian R M) (∀ (s : Submodule R M), s.FG)","decl":"/-- An R-module is Noetherian iff all its submodules are finitely-generated. -/\ntheorem isNoetherian_def : IsNoetherian R M ↔ ∀ s : Submodule R M, s.FG :=\n  ⟨fun h => h.noetherian, IsNoetherian.mk⟩\n\n"}
{"name":"isNoetherian_submodule","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff (IsNoetherian R (Subtype fun x => Membership.mem N x)) (∀ (s : Submodule R M), LE.le s N → s.FG)","decl":"theorem isNoetherian_submodule {N : Submodule R M} :\n    IsNoetherian R N ↔ ∀ s : Submodule R M, s ≤ N → s.FG := by\n  refine ⟨fun ⟨hn⟩ => fun s hs =>\n    have : s ≤ LinearMap.range N.subtype := N.range_subtype.symm ▸ hs\n    Submodule.map_comap_eq_self this ▸ (hn _).map _,\n    fun h => ⟨fun s => ?_⟩⟩\n  have f := (Submodule.equivMapOfInjective N.subtype Subtype.val_injective s).symm\n  have h₁ := h (s.map N.subtype) (Submodule.map_subtype_le N s)\n  have h₂ : (⊤ : Submodule R (s.map N.subtype)).map f = ⊤ := by simp\n  have h₃ := ((Submodule.fg_top _).2 h₁).map (↑f : _ →ₗ[R] s)\n  exact (Submodule.fg_top _).1 (h₂ ▸ h₃)\n\n"}
{"name":"isNoetherian_submodule_left","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff (IsNoetherian R (Subtype fun x => Membership.mem N x)) (∀ (s : Submodule R M), (Min.min N s).FG)","decl":"theorem isNoetherian_submodule_left {N : Submodule R M} :\n    IsNoetherian R N ↔ ∀ s : Submodule R M, (N ⊓ s).FG :=\n  isNoetherian_submodule.trans ⟨fun H _ => H _ inf_le_left, fun H _ hs => inf_of_le_right hs ▸ H _⟩\n\n"}
{"name":"isNoetherian_submodule_right","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff (IsNoetherian R (Subtype fun x => Membership.mem N x)) (∀ (s : Submodule R M), (Min.min s N).FG)","decl":"theorem isNoetherian_submodule_right {N : Submodule R M} :\n    IsNoetherian R N ↔ ∀ s : Submodule R M, (s ⊓ N).FG :=\n  isNoetherian_submodule.trans ⟨fun H _ => H _ inf_le_right, fun H _ hs => inf_of_le_left hs ▸ H _⟩\n\n"}
{"name":"isNoetherian_submodule'","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nN : Submodule R M\n⊢ IsNoetherian R (Subtype fun x => Membership.mem N x)","decl":"instance isNoetherian_submodule' [IsNoetherian R M] (N : Submodule R M) : IsNoetherian R N :=\n  isNoetherian_submodule.2 fun _ _ => IsNoetherian.noetherian _\n\n"}
{"name":"isNoetherian_of_le","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Submodule R M\nht : IsNoetherian R (Subtype fun x => Membership.mem t x)\nh : LE.le s t\n⊢ IsNoetherian R (Subtype fun x => Membership.mem s x)","decl":"theorem isNoetherian_of_le {s t : Submodule R M} [ht : IsNoetherian R t] (h : s ≤ t) :\n    IsNoetherian R s :=\n  isNoetherian_submodule.mpr fun _ hs' => isNoetherian_submodule.mp ht _ (le_trans hs' h)\n\n"}
{"name":"isNoetherian_iff'","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsNoetherian R M) (WellFoundedGT (Submodule R M))","decl":"theorem isNoetherian_iff' : IsNoetherian R M ↔ WellFoundedGT (Submodule R M) := by\n  have := (CompleteLattice.wellFoundedGT_characterisations <| Submodule R M).out 0 3\n  -- Porting note: inlining this makes rw complain about it being a metavariable\n  rw [this]\n  exact\n    ⟨fun ⟨h⟩ => fun k => (fg_iff_compact k).mp (h k), fun h =>\n      ⟨fun k => (fg_iff_compact k).mpr (h k)⟩⟩\n\n"}
{"name":"isNoetherian_iff","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsNoetherian R M) (WellFounded fun x1 x2 => GT.gt x1 x2)","decl":"theorem isNoetherian_iff :\n    IsNoetherian R M ↔ WellFounded ((· > ·) : Submodule R M → Submodule R M → Prop) := by\n  rw [isNoetherian_iff', ← isWellFounded_iff]\n\n"}
{"name":"IsNoetherian.wf","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ : IsNoetherian R M\n⊢ WellFounded fun x1 x2 => GT.gt x1 x2","decl":"alias ⟨IsNoetherian.wf, _⟩ := isNoetherian_iff\n\n"}
{"name":"IsNoetherian.wellFoundedGT","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ : IsNoetherian R M\n⊢ WellFoundedGT (Submodule R M)","decl":"alias ⟨IsNoetherian.wellFoundedGT, isNoetherian_mk⟩ := isNoetherian_iff'\n\n"}
{"name":"isNoetherian_mk","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ : WellFoundedGT (Submodule R M)\n⊢ IsNoetherian R M","decl":"alias ⟨IsNoetherian.wellFoundedGT, isNoetherian_mk⟩ := isNoetherian_iff'\n\n"}
{"name":"wellFoundedGT","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : IsNoetherian R M\n⊢ WellFoundedGT (Submodule R M)","decl":"instance wellFoundedGT [h : IsNoetherian R M] : WellFoundedGT (Submodule R M) :=\n  h.wellFoundedGT\n\n"}
{"name":"isNoetherian_iff_fg_wellFounded","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (IsNoetherian R M) (WellFoundedGT (Subtype fun N => N.FG))","decl":"theorem isNoetherian_iff_fg_wellFounded :\n    IsNoetherian R M ↔ WellFoundedGT { N : Submodule R M // N.FG } := by\n  let α := { N : Submodule R M // N.FG }\n  constructor\n  · intro H\n    let f : α ↪o Submodule R M := OrderEmbedding.subtype _\n    exact OrderEmbedding.wellFoundedLT f.dual\n  · intro H\n    constructor\n    intro N\n    obtain ⟨⟨N₀, h₁⟩, e : N₀ ≤ N, h₂⟩ :=\n      WellFounded.has_min H.wf { N' : α | N'.1 ≤ N } ⟨⟨⊥, Submodule.fg_bot⟩, @bot_le _ _ _ N⟩\n    convert h₁\n    refine (e.antisymm ?_).symm\n    by_contra h₃\n    obtain ⟨x, hx₁ : x ∈ N, hx₂ : x ∉ N₀⟩ := Set.not_subset.mp h₃\n    apply hx₂\n    rw [eq_of_le_of_not_lt (le_sup_right : N₀ ≤ _) (h₂\n      ⟨_, Submodule.FG.sup ⟨{x}, by rw [Finset.coe_singleton]⟩ h₁⟩ <|\n      sup_le ((Submodule.span_singleton_le_iff_mem _ _).mpr hx₁) e)]\n    exact (le_sup_left : (R ∙ x) ≤ _) (Submodule.mem_span_singleton_self _)\n\n"}
{"name":"set_has_maximal_iff_noetherian","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (∀ (a : Set (Submodule R M)), a.Nonempty → Exists fun M' => And (Membership.mem a M') (∀ (I : Submodule R M), Membership.mem a I → Not (LT.lt M' I))) (IsNoetherian R M)","decl":"/-- A module is Noetherian iff every nonempty set of submodules has a maximal submodule among them.\n-/\ntheorem set_has_maximal_iff_noetherian :\n    (∀ a : Set <| Submodule R M, a.Nonempty → ∃ M' ∈ a, ∀ I ∈ a, ¬M' < I) ↔ IsNoetherian R M := by\n  rw [isNoetherian_iff, WellFounded.wellFounded_iff_has_min]\n\n"}
{"name":"monotone_stabilizes_iff_noetherian","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Iff (∀ (f : OrderHom Nat (Submodule R M)), Exists fun n => ∀ (m : Nat), LE.le n m → Eq (f n) (f m)) (IsNoetherian R M)","decl":"/-- A module is Noetherian iff every increasing chain of submodules stabilizes. -/\ntheorem monotone_stabilizes_iff_noetherian :\n    (∀ f : ℕ →o Submodule R M, ∃ n, ∀ m, n ≤ m → f n = f m) ↔ IsNoetherian R M := by\n  rw [isNoetherian_iff, WellFounded.monotone_chain_condition]\n\n"}
{"name":"LinearMap.eventually_disjoint_ker_pow_range_pow","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\n⊢ Filter.Eventually (fun n => Disjoint (LinearMap.ker (HPow.hPow f n)) (LinearMap.range (HPow.hPow f n))) Filter.atTop","decl":"/-- For an endomorphism of a Noetherian module, any sufficiently large iterate has disjoint kernel\nand range. -/\ntheorem LinearMap.eventually_disjoint_ker_pow_range_pow (f : M →ₗ[R] M) :\n    ∀ᶠ n in atTop, Disjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n)) := by\n  obtain ⟨n, hn : ∀ m, n ≤ m → LinearMap.ker (f ^ n) = LinearMap.ker (f ^ m)⟩ :=\n    monotone_stabilizes_iff_noetherian.mpr inferInstance f.iterateKer\n  refine eventually_atTop.mpr ⟨n, fun m hm ↦ disjoint_iff.mpr ?_⟩\n  rw [← hn _ hm, Submodule.eq_bot_iff]\n  rintro - ⟨hx, ⟨x, rfl⟩⟩\n  apply LinearMap.pow_map_zero_of_le hm\n  replace hx : x ∈ LinearMap.ker (f ^ (n + m)) := by\n    simpa [f.pow_apply n, f.pow_apply m, ← f.pow_apply (n + m), ← iterate_add_apply] using hx\n  rwa [← hn _ (n.le_add_right m)] at hx\n\n"}
{"name":"LinearMap.eventually_iSup_ker_pow_eq","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nf : LinearMap (RingHom.id R) M M\n⊢ Filter.Eventually (fun n => Eq (iSup fun m => LinearMap.ker (HPow.hPow f m)) (LinearMap.ker (HPow.hPow f n))) Filter.atTop","decl":"lemma LinearMap.eventually_iSup_ker_pow_eq (f : M →ₗ[R] M) :\n    ∀ᶠ n in atTop, ⨆ m, LinearMap.ker (f ^ m) = LinearMap.ker (f ^ n) := by\n  obtain ⟨n, hn : ∀ m, n ≤ m → ker (f ^ n) = ker (f ^ m)⟩ :=\n    monotone_stabilizes_iff_noetherian.mpr inferInstance f.iterateKer\n  refine eventually_atTop.mpr ⟨n, fun m hm ↦ ?_⟩\n  refine le_antisymm (iSup_le fun l ↦ ?_) (le_iSup (fun i ↦ LinearMap.ker (f ^ i)) m)\n  rcases le_or_lt m l with h | h\n  · rw [← hn _ (hm.trans h), hn _ hm]\n  · exact f.iterateKer.monotone h.le\n\n"}
{"name":"isNoetherianRing_iff","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Iff (IsNoetherianRing R) (IsNoetherian R R)","decl":"theorem isNoetherianRing_iff {R} [Semiring R] : IsNoetherianRing R ↔ IsNoetherian R R :=\n  Iff.rfl\n\n"}
{"name":"isNoetherianRing_iff_ideal_fg","module":"Mathlib.RingTheory.Noetherian.Defs","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Iff (IsNoetherianRing R) (∀ (I : Ideal R), I.FG)","decl":"/-- A ring is Noetherian if and only if all its ideals are finitely-generated. -/\ntheorem isNoetherianRing_iff_ideal_fg (R : Type*) [Semiring R] :\n    IsNoetherianRing R ↔ ∀ I : Ideal R, I.FG :=\n  isNoetherianRing_iff.trans isNoetherian_def\n"}
