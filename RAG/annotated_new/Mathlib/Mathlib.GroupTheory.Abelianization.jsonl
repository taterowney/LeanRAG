{"name":"instNormalCommutator","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ (commutator G).Normal","decl":"instance : Subgroup.Normal (commutator G) := Subgroup.commutator_normal ⊤ ⊤\n\n"}
{"name":"commutator_def","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (commutator G) (Bracket.bracket Top.top Top.top)","decl":"theorem commutator_def : commutator G = ⁅(⊤ : Subgroup G), ⊤⁆ :=\n  rfl\n\n"}
{"name":"commutator_eq_closure","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (commutator G) (Subgroup.closure (commutatorSet G))","decl":"theorem commutator_eq_closure : commutator G = Subgroup.closure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def, commutatorSet]\n\n"}
{"name":"commutator_eq_normalClosure","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (commutator G) (Subgroup.normalClosure (commutatorSet G))","decl":"theorem commutator_eq_normalClosure : commutator G = Subgroup.normalClosure (commutatorSet G) := by\n  simp [commutator, Subgroup.commutator_def', commutatorSet]\n\n"}
{"name":"Subgroup.map_subtype_commutator","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Subgroup.map H.subtype (commutator (Subtype fun x => Membership.mem H x))) (Bracket.bracket H H)","decl":"variable {G} in\ntheorem Subgroup.map_subtype_commutator (H : Subgroup G) :\n    (_root_.commutator H).map H.subtype = ⁅H, H⁆ := by\n  rw [_root_.commutator_def, map_commutator, ← MonoidHom.range_eq_map, H.range_subtype]\n\n"}
{"name":"commutator_characteristic","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ (commutator G).Characteristic","decl":"instance commutator_characteristic : (commutator G).Characteristic :=\n  Subgroup.commutator_characteristic ⊤ ⊤\n\n"}
{"name":"instFGSubtypeMemSubgroupCommutatorOfFiniteElemCommutatorSet","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Group.FG (Subtype fun x => Membership.mem (commutator G) x)","decl":"instance [Finite (commutatorSet G)] : Group.FG (commutator G) := by\n  rw [commutator_eq_closure]\n  apply Group.closure_finite_fg\n\n"}
{"name":"rank_commutator_le_card","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem (commutator G) x)) (Nat.card ↑(commutatorSet G))","decl":"theorem rank_commutator_le_card [Finite (commutatorSet G)] :\n    Group.rank (commutator G) ≤ Nat.card (commutatorSet G) := by\n  rw [Subgroup.rank_congr (commutator_eq_closure G)]\n  apply Subgroup.rank_closure_finite_le_nat_card\n\n"}
{"name":"commutator_centralizer_commutator_le_center","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ LE.le (Bracket.bracket (Subgroup.centralizer ↑(commutator G)) (Subgroup.centralizer ↑(commutator G))) (Subgroup.center G)","decl":"theorem commutator_centralizer_commutator_le_center :\n    ⁅centralizer (commutator G : Set G), centralizer (commutator G)⁆ ≤ Subgroup.center G := by\n  rw [← Subgroup.centralizer_univ, ← Subgroup.coe_top, ←\n    Subgroup.commutator_eq_bot_iff_le_centralizer]\n  suffices ⁅⁅⊤, centralizer (commutator G : Set G)⁆, centralizer (commutator G : Set G)⁆ = ⊥ by\n    refine Subgroup.commutator_commutator_eq_bot_of_rotate ?_ this\n    rwa [Subgroup.commutator_comm (centralizer (commutator G : Set G))]\n  rw [Subgroup.commutator_comm, Subgroup.commutator_eq_bot_iff_le_centralizer]\n  exact Set.centralizer_subset (Subgroup.commutator_mono le_top le_top)\n\n"}
{"name":"Abelianization.instFinite","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ Finite (Abelianization G)","decl":"instance [Finite G] : Finite (Abelianization G) :=\n  Quotient.finite _\n\n"}
{"name":"Abelianization.mk_eq_of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\na : G\n⊢ Eq (Quot.mk (⇑(QuotientGroup.leftRel (commutator G))) a) (Abelianization.of a)","decl":"@[simp]\ntheorem mk_eq_of (a : G) : Quot.mk _ a = of a :=\n  rfl\n\n"}
{"name":"Abelianization.ker_of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq Abelianization.of.ker (commutator G)","decl":"variable (G) in\n@[simp]\ntheorem ker_of : of.ker = commutator G :=\n  QuotientGroup.ker_mk' (commutator G)\n\n"}
{"name":"Abelianization.commutator_subset_ker","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nA : Type v\ninst✝ : CommGroup A\nf : MonoidHom G A\n⊢ LE.le (commutator G) f.ker","decl":"theorem commutator_subset_ker : commutator G ≤ f.ker := by\n  rw [commutator_eq_closure, Subgroup.closure_le]\n  rintro x ⟨p, q, rfl⟩\n  simp [MonoidHom.mem_ker, mul_right_comm (f p) (f q), commutatorElement_def]\n\n"}
{"name":"Abelianization.lift.of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nA : Type v\ninst✝ : CommGroup A\nf : MonoidHom G A\nx : G\n⊢ Eq ((Abelianization.lift f) (Abelianization.of x)) (f x)","decl":"@[simp]\ntheorem lift.of (x : G) : lift f (of x) = f x :=\n  rfl\n\n"}
{"name":"Abelianization.lift.unique","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nA : Type v\ninst✝ : CommGroup A\nf : MonoidHom G A\nφ : MonoidHom (Abelianization G) A\nhφ : ∀ (x : G), Eq (φ (Abelianization.of x)) (f x)\nx : Abelianization G\n⊢ Eq (φ x) ((Abelianization.lift f) x)","decl":"theorem lift.unique (φ : Abelianization G →* A)\n    -- hφ : φ agrees with f on the image of G in Gᵃᵇ\n    (hφ : ∀ x : G, φ (Abelianization.of x) = f x)\n    {x : Abelianization G} : φ x = lift f x :=\n  QuotientGroup.induction_on x hφ\n\n"}
{"name":"Abelianization.lift_of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Abelianization.lift Abelianization.of) (MonoidHom.id (Abelianization G))","decl":"@[simp]\ntheorem lift_of : lift of = MonoidHom.id (Abelianization G) :=\n  lift.apply_symm_apply <| MonoidHom.id _\n\n"}
{"name":"Abelianization.hom_ext","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nA : Type v\ninst✝ : Monoid A\nφ ψ : MonoidHom (Abelianization G) A\nh : Eq (φ.comp Abelianization.of) (ψ.comp Abelianization.of)\n⊢ Eq φ ψ","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext (φ ψ : Abelianization G →* A) (h : φ.comp of = ψ.comp of) : φ = ψ :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"Abelianization.hom_ext_iff","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nA : Type v\ninst✝ : Monoid A\nφ ψ : MonoidHom (Abelianization G) A\n⊢ Iff (Eq φ ψ) (Eq (φ.comp Abelianization.of) (ψ.comp Abelianization.of))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem hom_ext (φ ψ : Abelianization G →* A) (h : φ.comp of = ψ.comp of) : φ = ψ :=\n  MonoidHom.ext fun x => QuotientGroup.induction_on x <| DFunLike.congr_fun h\n\n"}
{"name":"Abelianization.lift_of_comp","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nf : MonoidHom G H\n⊢ Eq (Abelianization.lift (Abelianization.of.comp f)) (Abelianization.map f)","decl":"/-- Use `map` as the preferred simp normal form. -/\n@[simp] theorem lift_of_comp :\n    Abelianization.lift (Abelianization.of.comp f) = Abelianization.map f := rfl\n\n"}
{"name":"Abelianization.map_of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nf : MonoidHom G H\nx : G\n⊢ Eq ((Abelianization.map f) (Abelianization.of x)) (Abelianization.of (f x))","decl":"@[simp]\ntheorem map_of (x : G) : map f (of x) = of (f x) :=\n  rfl\n\n"}
{"name":"Abelianization.map_id","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Abelianization.map (MonoidHom.id G)) (MonoidHom.id (Abelianization G))","decl":"@[simp]\ntheorem map_id : map (MonoidHom.id G) = MonoidHom.id (Abelianization G) :=\n  hom_ext _ _ rfl\n\n"}
{"name":"Abelianization.map_comp","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝² : Group G\nH : Type v\ninst✝¹ : Group H\nf : MonoidHom G H\nI : Type w\ninst✝ : Group I\ng : MonoidHom H I\n⊢ Eq ((Abelianization.map g).comp (Abelianization.map f)) (Abelianization.map (g.comp f))","decl":"@[simp]\ntheorem map_comp {I : Type w} [Group I] (g : H →* I) : (map g).comp (map f) = map (g.comp f) :=\n  hom_ext _ _ rfl\n\n"}
{"name":"Abelianization.map_map_apply","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝² : Group G\nH : Type v\ninst✝¹ : Group H\nf : MonoidHom G H\nI : Type w\ninst✝ : Group I\ng : MonoidHom H I\nx : Abelianization G\n⊢ Eq ((Abelianization.map g) ((Abelianization.map f) x)) ((Abelianization.map (g.comp f)) x)","decl":"@[simp]\ntheorem map_map_apply {I : Type w} [Group I] {g : H →* I} {x : Abelianization G} :\n    map g (map f x) = map (g.comp f) x :=\n  DFunLike.congr_fun (map_comp _ _) x\n\n"}
{"name":"abelianizationCongr_of","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\ne : MulEquiv G H\nx : G\n⊢ Eq (e.abelianizationCongr (Abelianization.of x)) (Abelianization.of (e x))","decl":"@[simp]\ntheorem abelianizationCongr_of (e : G ≃* H) (x : G) :\n    e.abelianizationCongr (Abelianization.of x) = Abelianization.of (e x) :=\n  rfl\n\n"}
{"name":"abelianizationCongr_refl","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (MulEquiv.refl G).abelianizationCongr (MulEquiv.refl (Abelianization G))","decl":"@[simp]\ntheorem abelianizationCongr_refl :\n    (MulEquiv.refl G).abelianizationCongr = MulEquiv.refl (Abelianization G) :=\n  MulEquiv.toMonoidHom_injective Abelianization.lift_of\n\n"}
{"name":"abelianizationCongr_symm","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\ne : MulEquiv G H\n⊢ Eq e.abelianizationCongr.symm e.symm.abelianizationCongr","decl":"@[simp]\ntheorem abelianizationCongr_symm (e : G ≃* H) :\n    e.abelianizationCongr.symm = e.symm.abelianizationCongr :=\n  rfl\n\n"}
{"name":"abelianizationCongr_trans","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝² : Group G\nH : Type v\ninst✝¹ : Group H\nI : Type v\ninst✝ : Group I\ne : MulEquiv G H\ne₂ : MulEquiv H I\n⊢ Eq (e.abelianizationCongr.trans e₂.abelianizationCongr) (e.trans e₂).abelianizationCongr","decl":"@[simp]\ntheorem abelianizationCongr_trans {I : Type v} [Group I] (e : G ≃* H) (e₂ : H ≃* I) :\n    e.abelianizationCongr.trans e₂.abelianizationCongr = (e.trans e₂).abelianizationCongr :=\n  MulEquiv.toMonoidHom_injective (Abelianization.hom_ext _ _ rfl)\n\n"}
{"name":"Abelianization.equivOfComm_apply","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"H : Type u_1\ninst✝ : CommGroup H\na : H\n⊢ Eq (Abelianization.equivOfComm a) (Abelianization.of a)","decl":"/-- An Abelian group is equivalent to its own abelianization. -/\n@[simps]\ndef Abelianization.equivOfComm {H : Type*} [CommGroup H] : H ≃* Abelianization H :=\n  { Abelianization.of with\n    toFun := Abelianization.of\n    invFun := Abelianization.lift (MonoidHom.id H)\n    left_inv := fun _ => rfl\n    right_inv := by\n      rintro ⟨a⟩\n      rfl }\n\n"}
{"name":"Abelianization.equivOfComm_symm_apply","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"H : Type u_1\ninst✝ : CommGroup H\na : Abelianization H\n⊢ Eq (Abelianization.equivOfComm.symm a) ((Abelianization.lift (MonoidHom.id H)) a)","decl":"/-- An Abelian group is equivalent to its own abelianization. -/\n@[simps]\ndef Abelianization.equivOfComm {H : Type*} [CommGroup H] : H ≃* Abelianization H :=\n  { Abelianization.of with\n    toFun := Abelianization.of\n    invFun := Abelianization.lift (MonoidHom.id H)\n    left_inv := fun _ => rfl\n    right_inv := by\n      rintro ⟨a⟩\n      rfl }\n\n"}
{"name":"instFiniteElemProdCommutatorRepresentativesOfCommutatorSet","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Finite ↑(commutatorRepresentatives G)","decl":"instance [Finite (commutatorSet G)] : Finite (commutatorRepresentatives G) :=\n  Set.finite_coe_iff.mpr (Set.finite_range _)\n\n"}
{"name":"closureCommutatorRepresentatives_fg","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Group.FG (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x)","decl":"instance closureCommutatorRepresentatives_fg [Finite (commutatorSet G)] :\n    Group.FG (closureCommutatorRepresentatives G) :=\n  Group.closure_finite_fg _\n\n"}
{"name":"rank_closureCommutatorRepresentatives_le","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ LE.le (Group.rank (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x)) (HMul.hMul 2 (Nat.card ↑(commutatorSet G)))","decl":"theorem rank_closureCommutatorRepresentatives_le [Finite (commutatorSet G)] :\n    Group.rank (closureCommutatorRepresentatives G) ≤ 2 * Nat.card (commutatorSet G) := by\n  rw [two_mul]\n  exact\n    (Subgroup.rank_closure_finite_le_nat_card _).trans\n      ((Set.card_union_le _ _).trans\n        (add_le_add ((Finite.card_image_le _).trans (Finite.card_range_le _))\n          ((Finite.card_image_le _).trans (Finite.card_range_le _))))\n\n"}
{"name":"image_commutatorSet_closureCommutatorRepresentatives","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Set.image (⇑(closureCommutatorRepresentatives G).subtype) (commutatorSet (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x))) (commutatorSet G)","decl":"theorem image_commutatorSet_closureCommutatorRepresentatives :\n    (closureCommutatorRepresentatives G).subtype ''\n        commutatorSet (closureCommutatorRepresentatives G) =\n      commutatorSet G := by\n  apply Set.Subset.antisymm\n  · rintro - ⟨-, ⟨g₁, g₂, rfl⟩, rfl⟩\n    exact ⟨g₁, g₂, rfl⟩\n  · exact fun g hg =>\n      ⟨_,\n        ⟨⟨_, subset_closure (Or.inl ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩,\n          ⟨_, subset_closure (Or.inr ⟨_, ⟨⟨g, hg⟩, rfl⟩, rfl⟩)⟩, rfl⟩,\n        hg.choose_spec.choose_spec⟩\n\n"}
{"name":"card_commutatorSet_closureCommutatorRepresentatives","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Nat.card ↑(commutatorSet (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x))) (Nat.card ↑(commutatorSet G))","decl":"theorem card_commutatorSet_closureCommutatorRepresentatives :\n    Nat.card (commutatorSet (closureCommutatorRepresentatives G)) = Nat.card (commutatorSet G) := by\n  rw [← image_commutatorSet_closureCommutatorRepresentatives G]\n  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n\n"}
{"name":"card_commutator_closureCommutatorRepresentatives","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (commutator (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x)) x)) (Nat.card (Subtype fun x => Membership.mem (commutator G) x))","decl":"theorem card_commutator_closureCommutatorRepresentatives :\n    Nat.card (commutator (closureCommutatorRepresentatives G)) = Nat.card (commutator G) := by\n  rw [commutator_eq_closure G, ← image_commutatorSet_closureCommutatorRepresentatives, ←\n    MonoidHom.map_closure, ← commutator_eq_closure]\n  exact Nat.card_congr (Equiv.Set.image _ _ (subtype_injective _))\n\n"}
{"name":"instFiniteElemSubtypeMemSubgroupClosureCommutatorRepresentativesCommutatorSet","module":"Mathlib.GroupTheory.Abelianization","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite ↑(commutatorSet G)\n⊢ Finite ↑(commutatorSet (Subtype fun x => Membership.mem (closureCommutatorRepresentatives G) x))","decl":"instance [Finite (commutatorSet G)] :\n    Finite (commutatorSet (closureCommutatorRepresentatives G)) := by\n  apply Nat.finite_of_card_ne_zero\n  rw [card_commutatorSet_closureCommutatorRepresentatives]\n  exact Finite.card_pos.ne'\n\n"}
