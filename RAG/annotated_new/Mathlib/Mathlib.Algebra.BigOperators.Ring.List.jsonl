{"name":"Commute.list_sum_right","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"R : Type u_5\ninst✝ : NonUnitalNonAssocSemiring R\na : R\nl : List R\nh : ∀ (b : R), Membership.mem l b → Commute a b\n⊢ Commute a l.sum","decl":"lemma list_sum_right (a : R) (l : List R) (h : ∀ b ∈ l, Commute a b) : Commute a l.sum := by\n  induction l with\n  | nil => exact Commute.zero_right _\n  | cons x xs ih =>\n    rw [List.sum_cons]\n    exact (h _ <| mem_cons_self _ _).add_right (ih fun j hj ↦ h _ <| mem_cons_of_mem _ hj)\n\n"}
{"name":"Commute.list_sum_left","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"R : Type u_5\ninst✝ : NonUnitalNonAssocSemiring R\nb : R\nl : List R\nh : ∀ (a : R), Membership.mem l a → Commute a b\n⊢ Commute l.sum b","decl":"lemma list_sum_left (b : R) (l : List R) (h : ∀ a ∈ l, Commute a b) : Commute l.sum b :=\n  ((Commute.list_sum_right _ _) fun _x hx ↦ (h _ hx).symm).symm\n\n"}
{"name":"List.prod_map_neg","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"M : Type u_3\ninst✝¹ : CommMonoid M\ninst✝ : HasDistribNeg M\nl : List M\n⊢ Eq (List.map Neg.neg l).prod (HMul.hMul (HPow.hPow (-1) l.length) l.prod)","decl":"@[simp]\nlemma prod_map_neg (l : List M) :\n    (l.map Neg.neg).prod = (-1) ^ l.length * l.prod := by\n  induction l <;> simp [*, pow_succ, ((Commute.neg_one_left _).pow_left _).left_comm]\n\n"}
{"name":"List.prod_eq_zero","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"M₀ : Type u_4\ninst✝ : MonoidWithZero M₀\nl : List M₀\na✝ : Membership.mem l 0\n⊢ Eq l.prod 0","decl":"/-- If zero is an element of a list `l`, then `List.prod l = 0`. If the domain is a nontrivial\nmonoid with zero with no divisors, then this implication becomes an `iff`, see\n`List.prod_eq_zero_iff`. -/\nlemma prod_eq_zero : ∀ {l : List M₀}, (0 : M₀) ∈ l → l.prod = 0\n  -- |  absurd h (not_mem_nil _)\n  | a :: l, h => by\n    rw [prod_cons]\n    rcases mem_cons.1 h with ha | hl\n    exacts [mul_eq_zero_of_left ha.symm _, mul_eq_zero_of_right _ (prod_eq_zero hl)]\n\n"}
{"name":"List.prod_eq_zero_iff","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"M₀ : Type u_4\ninst✝² : MonoidWithZero M₀\ninst✝¹ : Nontrivial M₀\ninst✝ : NoZeroDivisors M₀\nl : List M₀\n⊢ Iff (Eq l.prod 0) (Membership.mem l 0)","decl":"/-- Product of elements of a list `l` equals zero if and only if `0 ∈ l`. See also\n`List.prod_eq_zero` for an implication that needs weaker typeclass assumptions. -/\n@[simp] lemma prod_eq_zero_iff : ∀ {l : List M₀}, l.prod = 0 ↔ (0 : M₀) ∈ l\n  | [] => by simp\n  | a :: l => by rw [prod_cons, mul_eq_zero, prod_eq_zero_iff, mem_cons, eq_comm]\n\n"}
{"name":"List.prod_ne_zero","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"M₀ : Type u_4\ninst✝² : MonoidWithZero M₀\nl : List M₀\ninst✝¹ : Nontrivial M₀\ninst✝ : NoZeroDivisors M₀\nhL : Not (Membership.mem l 0)\n⊢ Ne l.prod 0","decl":"lemma prod_ne_zero (hL : (0 : M₀) ∉ l) : l.prod ≠ 0 := mt prod_eq_zero_iff.1 hL\n\n"}
{"name":"List.sum_map_mul_left","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝ : NonUnitalNonAssocSemiring R\nl : List ι\nf : ι → R\nr : R\n⊢ Eq (List.map (fun b => HMul.hMul r (f b)) l).sum (HMul.hMul r (List.map f l).sum)","decl":"lemma sum_map_mul_left : (l.map fun b ↦ r * f b).sum = r * (l.map f).sum :=\n  sum_map_hom l f <| AddMonoidHom.mulLeft r\n\n"}
{"name":"List.sum_map_mul_right","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"ι : Type u_1\nR : Type u_5\ninst✝ : NonUnitalNonAssocSemiring R\nl : List ι\nf : ι → R\nr : R\n⊢ Eq (List.map (fun b => HMul.hMul (f b) r) l).sum (HMul.hMul (List.map f l).sum r)","decl":"lemma sum_map_mul_right : (l.map fun b ↦ f b * r).sum = (l.map f).sum * r :=\n  sum_map_hom l f <| AddMonoidHom.mulRight r\n\n"}
{"name":"List.dvd_sum","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"R : Type u_5\ninst✝ : NonUnitalSemiring R\na : R\nl : List R\nh : ∀ (x : R), Membership.mem l x → Dvd.dvd a x\n⊢ Dvd.dvd a l.sum","decl":"lemma dvd_sum [NonUnitalSemiring R] {a} {l : List R} (h : ∀ x ∈ l, a ∣ x) : a ∣ l.sum := by\n  induction l with\n  | nil => exact dvd_zero _\n  | cons x l ih =>\n    rw [List.sum_cons]\n    exact dvd_add (h _ (mem_cons_self _ _)) (ih fun x hx ↦ h x (mem_cons_of_mem _ hx))\n\n"}
{"name":"List.sum_zipWith_distrib_left","module":"Mathlib.Algebra.BigOperators.Ring.List","initialProofState":"ι : Type u_1\nκ : Type u_2\nR : Type u_5\ninst✝ : Semiring R\nf : ι → κ → R\na : R\nl₁ : List ι\nl₂ : List κ\n⊢ Eq (List.zipWith (fun i j => HMul.hMul a (f i j)) l₁ l₂).sum (HMul.hMul a (List.zipWith f l₁ l₂).sum)","decl":"@[simp] lemma sum_zipWith_distrib_left [Semiring R] (f : ι → κ → R) (a : R) :\n    ∀ (l₁ : List ι) (l₂ : List κ),\n      (zipWith (fun i j ↦ a * f i j) l₁ l₂).sum = a * (zipWith f l₁ l₂).sum\n  | [], _ => by simp\n  | _, [] => by simp\n  | i :: l₁, j :: l₂ => by simp [sum_zipWith_distrib_left, mul_add]\n\n"}
