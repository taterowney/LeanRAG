{"name":"Stream'.Seq.val_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nx : α\n⊢ Eq (↑(Stream'.Seq.cons x s)) (Stream'.cons (Option.some x) ↑s)","decl":"@[simp]\ntheorem val_cons (s : Seq α) (x : α) : (cons x s).val = some x::s.val :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_mk","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nf : Stream' (Option α)\nhf : f.IsSeq\n⊢ Eq (Stream'.Seq.get? ⟨f, hf⟩) f","decl":"@[simp]\ntheorem get?_mk (f hf) : @get? α ⟨f, hf⟩ = f :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (Stream'.Seq.nil.get? n) Option.none","decl":"@[simp]\ntheorem get?_nil (n : ℕ) : (@nil α).get? n = none :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_cons_zero","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\n⊢ Eq ((Stream'.Seq.cons a s).get? 0) (Option.some a)","decl":"@[simp]\ntheorem get?_cons_zero (a : α) (s : Seq α) : (cons a s).get? 0 = some a :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_cons_succ","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\nn : Nat\n⊢ Eq ((Stream'.Seq.cons a s).get? (HAdd.hAdd n 1)) (s.get? n)","decl":"@[simp]\ntheorem get?_cons_succ (a : α) (s : Seq α) (n : ℕ) : (cons a s).get? (n + 1) = s.get? n :=\n  rfl\n\n"}
{"name":"Stream'.Seq.ext_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns t : Stream'.Seq α\n⊢ Iff (Eq s t) (∀ (n : Nat), Eq (s.get? n) (t.get? n))","decl":"@[ext]\nprotected theorem ext {s t : Seq α} (h : ∀ n : ℕ, s.get? n = t.get? n) : s = t :=\n  Subtype.eq <| funext h\n\n"}
{"name":"Stream'.Seq.ext","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns t : Stream'.Seq α\nh : ∀ (n : Nat), Eq (s.get? n) (t.get? n)\n⊢ Eq s t","decl":"@[ext]\nprotected theorem ext {s t : Seq α} (h : ∀ n : ℕ, s.get? n = t.get? n) : s = t :=\n  Subtype.eq <| funext h\n\n"}
{"name":"Stream'.Seq.cons_injective2","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Function.Injective2 Stream'.Seq.cons","decl":"theorem cons_injective2 : Function.Injective2 (cons : α → Seq α → Seq α) := fun x y s t h =>\n  ⟨by rw [← Option.some_inj, ← get?_cons_zero, h, get?_cons_zero],\n    Seq.ext fun n => by simp_rw [← get?_cons_succ x s n, h, get?_cons_succ]⟩\n\n"}
{"name":"Stream'.Seq.cons_left_injective","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Function.Injective fun x => Stream'.Seq.cons x s","decl":"theorem cons_left_injective (s : Seq α) : Function.Injective fun x => cons x s :=\n  cons_injective2.left _\n\n"}
{"name":"Stream'.Seq.cons_right_injective","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nx : α\n⊢ Function.Injective (Stream'.Seq.cons x)","decl":"theorem cons_right_injective (x : α) : Function.Injective (cons x) :=\n  cons_injective2.right _\n\n"}
{"name":"Stream'.Seq.not_terminates_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Iff (Not s.Terminates) (∀ (n : Nat), Eq (s.get? n).isSome Bool.true)","decl":"theorem not_terminates_iff {s : Seq α} : ¬s.Terminates ↔ ∀ n, (s.get? n).isSome := by\n  simp only [Terminates, TerminatedAt, ← Ne.eq_def, Option.ne_none_iff_isSome, not_exists, iff_self]\n\n"}
{"name":"Stream'.Seq.le_stable","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nm n : Nat\nh : LE.le m n\na✝ : Eq (s.get? m) Option.none\n⊢ Eq (s.get? n) Option.none","decl":"theorem le_stable (s : Seq α) {m n} (h : m ≤ n) : s.get? m = none → s.get? n = none := by\n  cases' s with f al\n  induction' h with n _ IH\n  exacts [id, fun h2 => al (IH h2)]\n\n"}
{"name":"Stream'.Seq.terminated_stable","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nm n : Nat\na✝¹ : LE.le m n\na✝ : s.TerminatedAt m\n⊢ s.TerminatedAt n","decl":"/-- If a sequence terminated at position `n`, it also terminated at `m ≥ n`. -/\ntheorem terminated_stable : ∀ (s : Seq α) {m n : ℕ}, m ≤ n → s.TerminatedAt m → s.TerminatedAt n :=\n  le_stable\n\n"}
{"name":"Stream'.Seq.ge_stable","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\naₙ : α\nn m : Nat\nm_le_n : LE.le m n\ns_nth_eq_some : Eq (s.get? n) (Option.some aₙ)\n⊢ Exists fun aₘ => Eq (s.get? m) (Option.some aₘ)","decl":"/-- If `s.get? n = some aₙ` for some value `aₙ`, then there is also some value `aₘ` such\nthat `s.get? = some aₘ` for `m ≤ n`.\n-/\ntheorem ge_stable (s : Seq α) {aₙ : α} {n m : ℕ} (m_le_n : m ≤ n)\n    (s_nth_eq_some : s.get? n = some aₙ) : ∃ aₘ : α, s.get? m = some aₘ :=\n  have : s.get? n ≠ none := by simp [s_nth_eq_some]\n  have : s.get? m ≠ none := mt (s.le_stable m_le_n) this\n  Option.ne_none_iff_exists'.mp this\n\n"}
{"name":"Stream'.Seq.not_mem_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\n⊢ Not (Membership.mem Stream'.Seq.nil a)","decl":"theorem not_mem_nil (a : α) : a ∉ @nil α := fun ⟨_, (h : some a = none)⟩ => by injection h\n\n"}
{"name":"Stream'.Seq.mem_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\n⊢ Membership.mem (Stream'.Seq.cons a s) a","decl":"theorem mem_cons (a : α) : ∀ s : Seq α, a ∈ cons a s\n  | ⟨_, _⟩ => Stream'.mem_cons (some a) _\n\n"}
{"name":"Stream'.Seq.mem_cons_of_mem","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ny a : α\ns : Stream'.Seq α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.Seq.cons y s) a","decl":"theorem mem_cons_of_mem (y : α) {a : α} : ∀ {s : Seq α}, a ∈ s → a ∈ cons y s\n  | ⟨_, _⟩ => Stream'.mem_cons_of_mem (some y)\n\n"}
{"name":"Stream'.Seq.eq_or_mem_of_mem_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na b : α\ns : Stream'.Seq α\na✝ : Membership.mem (Stream'.Seq.cons b s) a\n⊢ Or (Eq a b) (Membership.mem s a)","decl":"theorem eq_or_mem_of_mem_cons {a b : α} : ∀ {s : Seq α}, a ∈ cons b s → a = b ∨ a ∈ s\n  | ⟨_, _⟩, h => (Stream'.eq_or_mem_of_mem_cons h).imp_left fun h => by injection h\n\n"}
{"name":"Stream'.Seq.mem_cons_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na b : α\ns : Stream'.Seq α\n⊢ Iff (Membership.mem (Stream'.Seq.cons b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_cons_iff {a b : α} {s : Seq α} : a ∈ cons b s ↔ a = b ∨ a ∈ s :=\n  ⟨eq_or_mem_of_mem_cons, by rintro (rfl | m) <;> [apply mem_cons; exact mem_cons_of_mem _ m]⟩\n\n"}
{"name":"Stream'.Seq.destruct_eq_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\na✝ : Eq s.destruct Option.none\n⊢ Eq s Stream'.Seq.nil","decl":"theorem destruct_eq_nil {s : Seq α} : destruct s = none → s = nil := by\n  dsimp [destruct]\n  induction' f0 : get? s 0 <;> intro h\n  · apply Subtype.eq\n    funext n\n    induction' n with n IH\n    exacts [f0, s.2 IH]\n  · contradiction\n\n"}
{"name":"Stream'.Seq.destruct_eq_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\na : α\ns' : Stream'.Seq α\na✝ : Eq s.destruct (Option.some { fst := a, snd := s' })\n⊢ Eq s (Stream'.Seq.cons a s')","decl":"theorem destruct_eq_cons {s : Seq α} {a s'} : destruct s = some (a, s') → s = cons a s' := by\n  dsimp [destruct]\n  induction' f0 : get? s 0 with a' <;> intro h\n  · contradiction\n  · cases' s with f al\n    injections _ h1 h2\n    rw [← h2]\n    apply Subtype.eq\n    dsimp [tail, cons]\n    rw [h1] at f0\n    rw [← f0]\n    exact (Stream'.eta f).symm\n\n"}
{"name":"Stream'.Seq.destruct_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq Stream'.Seq.nil.destruct Option.none","decl":"@[simp]\ntheorem destruct_nil : destruct (nil : Seq α) = none :=\n  rfl\n\n"}
{"name":"Stream'.Seq.destruct_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.cons a s).destruct (Option.some { fst := a, snd := s })","decl":"@[simp]\ntheorem destruct_cons (a : α) : ∀ s, destruct (cons a s) = some (a, s)\n  | ⟨f, al⟩ => by\n    unfold cons destruct Functor.map\n    apply congr_arg fun s => some (a, s)\n    apply Subtype.eq; dsimp [tail]\n\n-- Porting note: needed universe annotation to avoid universe issues\n"}
{"name":"Stream'.Seq.head_eq_destruct","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq s.head (Functor.map Prod.fst s.destruct)","decl":"theorem head_eq_destruct (s : Seq α) : head.{u} s = Prod.fst.{u} <$> destruct.{u} s := by\n  unfold destruct head; cases get? s 0 <;> rfl\n\n"}
{"name":"Stream'.Seq.head_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq Stream'.Seq.nil.head Option.none","decl":"@[simp]\ntheorem head_nil : head (nil : Seq α) = none :=\n  rfl\n\n"}
{"name":"Stream'.Seq.head_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.cons a s).head (Option.some a)","decl":"@[simp]\ntheorem head_cons (a : α) (s) : head (cons a s) = some a := by\n  rw [head_eq_destruct, destruct_cons, Option.map_eq_map, Option.map_some']\n\n"}
{"name":"Stream'.Seq.tail_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq Stream'.Seq.nil.tail Stream'.Seq.nil","decl":"@[simp]\ntheorem tail_nil : tail (nil : Seq α) = nil :=\n  rfl\n\n"}
{"name":"Stream'.Seq.tail_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.cons a s).tail s","decl":"@[simp]\ntheorem tail_cons (a : α) (s) : tail (cons a s) = s := by\n  cases' s with f al\n  apply Subtype.eq\n  dsimp [tail, cons]\n\n"}
{"name":"Stream'.Seq.get?_tail","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq (s.tail.get? n) (s.get? (HAdd.hAdd n 1))","decl":"@[simp]\ntheorem get?_tail (s : Seq α) (n) : get? (tail s) n = get? s (n + 1) :=\n  rfl\n\n"}
{"name":"Stream'.Seq.mem_rec_on","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nC : Stream'.Seq α → Prop\na : α\ns : Stream'.Seq α\nM : Membership.mem s a\nh1 : ∀ (b : α) (s' : Stream'.Seq α), Or (Eq a b) (C s') → C (Stream'.Seq.cons b s')\n⊢ C s","decl":"theorem mem_rec_on {C : Seq α → Prop} {a s} (M : a ∈ s)\n    (h1 : ∀ b s', a = b ∨ C s' → C (cons b s')) : C s := by\n  cases' M with k e; unfold Stream'.get at e\n  induction' k with k IH generalizing s\n  · have TH : s = cons a (tail s) := by\n      apply destruct_eq_cons\n      unfold destruct get? Functor.map\n      rw [← e]\n      rfl\n    rw [TH]\n    apply h1 _ _ (Or.inl rfl)\n  -- Porting note: had to reshuffle `intro`\n  cases' s with b s'\n  · injection e\n  · have h_eq : (cons b s').val (Nat.succ k) = s'.val k := by cases s' using Subtype.recOn; rfl\n    rw [h_eq] at e\n    apply h1 _ _ (Or.inr (IH e))\n\n"}
{"name":"Stream'.Seq.corec_eq","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : β → Option (Prod α β)\nb : β\n⊢ Eq (Stream'.Seq.corec f b).destruct (Stream'.Seq.omap (Stream'.Seq.corec f) (f b))","decl":"@[simp]\ntheorem corec_eq (f : β → Option (α × β)) (b : β) :\n    destruct (corec f b) = omap (corec f) (f b) := by\n  dsimp [corec, destruct, get]\n  -- Porting note: next two lines were `change`...`with`...\n  have h : Stream'.corec' (Corec.f f) (some b) 0 = (Corec.f f (some b)).1 := rfl\n  rw [h]\n  dsimp [Corec.f]\n  induction' h : f b with s; · rfl\n  cases' s with a b'; dsimp [Corec.f]\n  apply congr_arg fun b' => some (a, b')\n  apply Subtype.eq\n  dsimp [corec, tail]\n  rw [Stream'.corec'_eq, Stream'.tail_cons]\n  dsimp [Corec.f]; rw [h]\n\n"}
{"name":"Stream'.Seq.eq_of_bisim","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nR : Stream'.Seq α → Stream'.Seq α → Prop\nbisim : Stream'.Seq.IsBisimulation R\ns₁ s₂ : Stream'.Seq α\nr : R s₁ s₂\n⊢ Eq s₁ s₂","decl":"theorem eq_of_bisim (bisim : IsBisimulation R) {s₁ s₂} (r : s₁ ~ s₂) : s₁ = s₂ := by\n  apply Subtype.eq\n  apply Stream'.eq_of_bisim fun x y => ∃ s s' : Seq α, s.1 = x ∧ s'.1 = y ∧ R s s'\n  · dsimp [Stream'.IsBisimulation]\n    intro t₁ t₂ e\n    exact\n    match t₁, t₂, e with\n    | _, _, ⟨s, s', rfl, rfl, r⟩ => by\n      suffices head s = head s' ∧ R (tail s) (tail s') from\n        And.imp id (fun r => ⟨tail s, tail s', by cases s using Subtype.recOn; rfl,\n          by cases s' using Subtype.recOn; rfl, r⟩) this\n      have := bisim r; revert r this\n      cases' s with x s <;> cases' s' with x' s'\n      · intro r _\n        constructor\n        · rfl\n        · assumption\n      · intro _ this\n        rw [destruct_nil, destruct_cons] at this\n        exact False.elim this\n      · intro _ this\n        rw [destruct_nil, destruct_cons] at this\n        exact False.elim this\n      · intro _ this\n        rw [destruct_cons, destruct_cons] at this\n        rw [head_cons, head_cons, tail_cons, tail_cons]\n        cases' this with h1 h2\n        constructor\n        · rw [h1]\n        · exact h2\n  · exact ⟨s₁, s₂, rfl, rfl, r⟩\n\n"}
{"name":"Stream'.Seq.coinduction","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns₁ s₂ : Stream'.Seq α\na✝¹ : Eq s₁.head s₂.head\na✝ : ∀ (β : Type u) (fr : Stream'.Seq α → β), Eq (fr s₁) (fr s₂) → Eq (fr s₁.tail) (fr s₂.tail)\n⊢ Eq s₁ s₂","decl":"theorem coinduction :\n    ∀ {s₁ s₂ : Seq α},\n      head s₁ = head s₂ →\n        (∀ (β : Type u) (fr : Seq α → β), fr s₁ = fr s₂ → fr (tail s₁) = fr (tail s₂)) → s₁ = s₂\n  | _, _, hh, ht =>\n    Subtype.eq (Stream'.coinduction hh fun β fr => ht β fun s => fr s.1)\n\n"}
{"name":"Stream'.Seq.coinduction2","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\ns : Stream'.Seq α\nf g : Stream'.Seq α → Stream'.Seq β\nH : ∀ (s : Stream'.Seq α), Stream'.Seq.BisimO (fun s1 s2 => Exists fun s => And (Eq s1 (f s)) (Eq s2 (g s))) (f s).destruct (g s).destruct\n⊢ Eq (f s) (g s)","decl":"theorem coinduction2 (s) (f g : Seq α → Seq β)\n    (H :\n      ∀ s,\n        BisimO (fun s1 s2 : Seq β => ∃ s : Seq α, s1 = f s ∧ s2 = g s) (destruct (f s))\n          (destruct (g s))) :\n    f s = g s := by\n  refine eq_of_bisim (fun s1 s2 => ∃ s, s1 = f s ∧ s2 = g s) ?_ ⟨s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨s, h1, h2⟩\n  rw [h1, h2]; apply H\n\n"}
{"name":"Stream'.Seq.ofList_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq (↑List.nil) Stream'.Seq.nil","decl":"@[simp]\ntheorem ofList_nil : ofList [] = (nil : Seq α) :=\n  rfl\n\n"}
{"name":"Stream'.Seq.ofList_get","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq ((↑l).get? n) (l.get? n)","decl":"@[simp]\ntheorem ofList_get (l : List α) (n : ℕ) : (ofList l).get? n = l.get? n :=\n  rfl\n\n"}
{"name":"Stream'.Seq.ofList_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (↑(List.cons a l)) (Stream'.Seq.cons a ↑l)","decl":"@[simp]\ntheorem ofList_cons (a : α) (l : List α) : ofList (a::l) = cons a (ofList l) := by\n  ext1 (_ | n) <;> rfl\n\n"}
{"name":"Stream'.Seq.ofList_injective","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Function.Injective Stream'.Seq.ofList","decl":"theorem ofList_injective : Function.Injective (ofList : List α → _) :=\n  fun _ _ h => List.ext_get? fun _ => congr_fun (Subtype.ext_iff.1 h) _\n\n"}
{"name":"Stream'.Seq.nats_get?","module":"Mathlib.Data.Seq.Seq","initialProofState":"n : Nat\n⊢ Eq (Stream'.Seq.nats.get? n) (Option.some n)","decl":"@[simp]\ntheorem nats_get? (n : ℕ) : nats.get? n = some n :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_zipWith","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β → γ\ns : Stream'.Seq α\ns' : Stream'.Seq β\nn : Nat\n⊢ Eq ((Stream'.Seq.zipWith f s s').get? n) (Option.map₂ f (s.get? n) (s'.get? n))","decl":"@[simp]\ntheorem get?_zipWith (f : α → β → γ) (s s' n) :\n    (zipWith f s s').get? n = Option.map₂ f (s.get? n) (s'.get? n) :=\n  rfl\n\n"}
{"name":"Stream'.Seq.get?_zip","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\ns : Stream'.Seq α\nt : Stream'.Seq β\nn : Nat\n⊢ Eq ((s.zip t).get? n) (Option.map₂ Prod.mk (s.get? n) (t.get? n))","decl":"theorem get?_zip (s : Seq α) (t : Seq β) (n : ℕ) :\n    get? (zip s t) n = Option.map₂ Prod.mk (get? s n) (get? t n) :=\n  get?_zipWith _ _ _ _\n\n"}
{"name":"Stream'.Seq.get?_enum","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq (s.enum.get? n) (Option.map (Prod.mk n) (s.get? n))","decl":"@[simp]\ntheorem get?_enum (s : Seq α) (n : ℕ) : get? (enum s) n = Option.map (Prod.mk n) (get? s n) :=\n  get?_zip _ _ _\n\n"}
{"name":"Stream'.Seq.enum_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq Stream'.Seq.nil.enum Stream'.Seq.nil","decl":"@[simp]\ntheorem enum_nil : enum (nil : Seq α) = nil :=\n  rfl\n\n"}
{"name":"Stream'.Seq.nil_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.nil.append s) s","decl":"@[simp]\ntheorem nil_append (s : Seq α) : append nil s = s := by\n  apply coinduction2; intro s\n  dsimp [append]; rw [corec_eq]\n  dsimp [append]\n  cases' s with x s\n  · trivial\n  · rw [destruct_cons]\n    dsimp\n    exact ⟨rfl, s, rfl, rfl⟩\n\n"}
{"name":"Stream'.Seq.getElem?_take","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nn k : Nat\ns : Stream'.Seq α\n⊢ Eq (GetElem?.getElem? (Stream'.Seq.take k s) n) (ite (LT.lt n k) (s.get? n) Option.none)","decl":"@[simp]\ntheorem getElem?_take : ∀ (n k : ℕ) (s : Seq α),\n    (s.take k)[n]? = if n < k then s.get? n else none\n  | n, 0, s => by simp [take]\n  | n, k+1, s => by\n    rw [take]\n    cases h : destruct s with\n    | none =>\n      simp [destruct_eq_nil h]\n    | some a =>\n      match a with\n      | (x, r) =>\n        rw [destruct_eq_cons h]\n        match n with\n        | 0 => simp\n        | n+1 => simp [List.get?_cons_succ, Nat.add_lt_add_iff_right, get?_cons_succ, getElem?_take]\n\n"}
{"name":"Stream'.Seq.terminatedAt_ofList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl : List α\n⊢ (↑l).TerminatedAt l.length","decl":"theorem terminatedAt_ofList (l : List α) :\n    (ofList l).TerminatedAt l.length := by\n  simp [ofList, TerminatedAt]\n\n"}
{"name":"Stream'.Seq.terminates_ofList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl : List α\n⊢ (↑l).Terminates","decl":"theorem terminates_ofList (l : List α) : (ofList l).Terminates :=\n  ⟨_, terminatedAt_ofList l⟩\n\n"}
{"name":"Stream'.Seq.terminatedAt_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Stream'.Seq.nil.TerminatedAt 0","decl":"theorem terminatedAt_nil : TerminatedAt (nil : Seq α) 0 := rfl\n\n"}
{"name":"Stream'.Seq.terminates_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Stream'.Seq.nil.Terminates","decl":"@[simp]\ntheorem terminates_nil : Terminates (nil : Seq α) := ⟨0, rfl⟩\n\n"}
{"name":"Stream'.Seq.length_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq (Stream'.Seq.nil.length ⋯) 0","decl":"@[simp]\ntheorem length_nil : length (nil : Seq α) terminates_nil = 0 := rfl\n\n"}
{"name":"Stream'.Seq.get?_zero_eq_none","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Iff (Eq (s.get? 0) Option.none) (Eq s Stream'.Seq.nil)","decl":"@[simp]\ntheorem get?_zero_eq_none {s : Seq α} : s.get? 0 = none ↔ s = nil := by\n  refine ⟨fun h => ?_, fun h => h ▸ rfl⟩\n  ext1 n\n  exact le_stable s (Nat.zero_le _) h\n\n"}
{"name":"Stream'.Seq.length_eq_zero","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nh : s.Terminates\n⊢ Iff (Eq (s.length h) 0) (Eq s Stream'.Seq.nil)","decl":"@[simp] theorem length_eq_zero {s : Seq α} {h : s.Terminates} :\n    s.length h = 0 ↔ s = nil := by\n  simp [length, TerminatedAt]\n\n"}
{"name":"Stream'.Seq.terminatedAt_zero_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Iff (s.TerminatedAt 0) (Eq s Stream'.Seq.nil)","decl":"theorem terminatedAt_zero_iff {s : Seq α} : s.TerminatedAt 0 ↔ s = nil := by\n  refine ⟨?_, ?_⟩\n  · intro h\n    ext n\n    rw [le_stable _ (Nat.zero_le _) h]\n    simp\n  · rintro rfl\n    simp [TerminatedAt]\n\n"}
{"name":"Stream'.Seq.length_le_iff'","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Iff (Exists fun h => LE.le (s.length h) n) (s.TerminatedAt n)","decl":"/-- The statement of `length_le_iff'` does not assume that the sequence terminates. For a\nsimpler statement of the theorem where the sequence is known to terminate see `length_le_iff` -/\ntheorem length_le_iff' {s : Seq α} {n : ℕ} :\n    (∃ h, s.length h ≤ n) ↔ s.TerminatedAt n := by\n  simp only [length, Nat.find_le_iff, TerminatedAt, Terminates, exists_prop]\n  refine ⟨?_, ?_⟩\n  · rintro ⟨_, k, hkn, hk⟩\n    exact le_stable s hkn hk\n  · intro hn\n    exact ⟨⟨n, hn⟩, ⟨n, le_rfl, hn⟩⟩\n\n"}
{"name":"Stream'.Seq.length_le_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\nh : s.Terminates\n⊢ Iff (LE.le (s.length h) n) (s.TerminatedAt n)","decl":"/-- The statement of `length_le_iff` assumes that the sequence terminates. For a\nstatement of the where the sequence is not known to terminate see `length_le_iff'` -/\ntheorem length_le_iff {s : Seq α} {n : ℕ} {h : s.Terminates} :\n    s.length h ≤ n ↔ s.TerminatedAt n := by\n  rw [← length_le_iff']; simp [h]\n\n"}
{"name":"Stream'.Seq.lt_length_iff'","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Iff (∀ (h : s.Terminates), LT.lt n (s.length h)) (Exists fun a => Membership.mem (s.get? n) a)","decl":"/-- The statement of `lt_length_iff'` does not assume that the sequence terminates. For a\nsimpler statement of the theorem where the sequence is known to terminate see `lt_length_iff` -/\ntheorem lt_length_iff' {s : Seq α} {n : ℕ} :\n    (∀ h : s.Terminates, n < s.length h) ↔ ∃ a, a ∈ s.get? n := by\n  simp only [Terminates, TerminatedAt, length, Nat.lt_find_iff, forall_exists_index, Option.mem_def,\n    ← Option.ne_none_iff_exists', ne_eq]\n  refine ⟨?_, ?_⟩\n  · intro h hn\n    exact h n hn n le_rfl hn\n  · intro hn _ _ k hkn hk\n    exact hn <| le_stable s hkn hk\n\n"}
{"name":"Stream'.Seq.lt_length_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\nh : s.Terminates\n⊢ Iff (LT.lt n (s.length h)) (Exists fun a => Membership.mem (s.get? n) a)","decl":"/-- The statement of `length_le_iff` assumes that the sequence terminates. For a\nstatement of the where the sequence is not known to terminate see `length_le_iff'` -/\ntheorem lt_length_iff {s : Seq α} {n : ℕ} {h : s.Terminates} :\n    n < s.length h ↔ ∃ a, a ∈ s.get? n := by\n  rw [← lt_length_iff']; simp [h]\n\n"}
{"name":"Stream'.Seq.length_take_of_le_length","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\nhle : ∀ (h : s.Terminates), LE.le n (s.length h)\n⊢ Eq (Stream'.Seq.take n s).length n","decl":"theorem length_take_of_le_length {s : Seq α} {n : ℕ}\n    (hle : ∀ h : s.Terminates, n ≤ s.length h) : (s.take n).length = n := by\n  induction n generalizing s with\n  | zero => simp [take]\n  | succ n ih =>\n      rw [take, destruct]\n      let ⟨a, ha⟩ := lt_length_iff'.1 (fun ht => lt_of_lt_of_le (Nat.succ_pos _) (hle ht))\n      simp [Option.mem_def.1 ha]\n      rw [ih]\n      intro h\n      simp only [length, tail, Nat.le_find_iff, TerminatedAt, get?_mk, Stream'.tail]\n      intro m hmn hs\n      have := lt_length_iff'.1 (fun ht => (Nat.lt_of_succ_le (hle ht)))\n      rw [le_stable s (Nat.succ_le_of_lt hmn) hs] at this\n      simp at this\n\n"}
{"name":"Stream'.Seq.length_toList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nh : s.Terminates\n⊢ Eq (s.toList h).length (s.length h)","decl":"@[simp]\ntheorem length_toList (s : Seq α) (h : s.Terminates) : (toList s h).length = length s h := by\n  rw [toList, length_take_of_le_length]\n  intro _\n  exact le_rfl\n\n"}
{"name":"Stream'.Seq.getElem?_toList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nh : s.Terminates\nn : Nat\n⊢ Eq (GetElem?.getElem? (s.toList h) n) (s.get? n)","decl":"@[simp]\ntheorem getElem?_toList (s : Seq α) (h : s.Terminates) (n : ℕ) : (toList s h)[n]? = s.get? n := by\n  ext k\n  simp only [ofList, toList, get?_mk, Option.mem_def, getElem?_take, Nat.lt_find_iff, length,\n    Option.ite_none_right_eq_some, and_iff_right_iff_imp, TerminatedAt, List.get?_eq_getElem?]\n  intro h m hmn\n  let ⟨a, ha⟩ := ge_stable s hmn h\n  simp [ha]\n\n"}
{"name":"Stream'.Seq.ofList_toList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nh : s.Terminates\n⊢ Eq (↑(s.toList h)) s","decl":"@[simp]\ntheorem ofList_toList (s : Seq α) (h : s.Terminates) :\n    ofList (toList s h) = s := by\n  ext n; simp [ofList, List.get?_eq_getElem?]\n\n"}
{"name":"Stream'.Seq.toList_ofList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl : List α\n⊢ Eq ((↑l).toList ⋯) l","decl":"@[simp]\ntheorem toList_ofList (l : List α) : toList (ofList l) (terminates_ofList l) = l :=\n  ofList_injective (by simp)\n\n"}
{"name":"Stream'.Seq.toList_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq (Stream'.Seq.nil.toList ⋯) List.nil","decl":"@[simp]\ntheorem toList_nil : toList (nil : Seq α) ⟨0, terminatedAt_zero_iff.2 rfl⟩ = [] := by\n  ext; simp [nil, toList, const]\n\n"}
{"name":"Stream'.Seq.getLast?_toList","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nh : s.Terminates\n⊢ Eq (s.toList h).getLast? (s.get? (HSub.hSub (s.length h) 1))","decl":"theorem getLast?_toList (s : Seq α) (h : s.Terminates) :\n    (toList s h).getLast? = s.get? (s.length h - 1) := by\n  rw [List.getLast?_eq_getElem?, getElem?_toList, length_toList]\n\n"}
{"name":"Stream'.Seq.cons_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns t : Stream'.Seq α\n⊢ Eq ((Stream'.Seq.cons a s).append t) (Stream'.Seq.cons a (s.append t))","decl":"@[simp]\ntheorem cons_append (a : α) (s t) : append (cons a s) t = cons a (append s t) :=\n  destruct_eq_cons <| by\n    dsimp [append]; rw [corec_eq]\n    dsimp [append]; rw [destruct_cons]\n\n"}
{"name":"Stream'.Seq.append_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (s.append Stream'.Seq.nil) s","decl":"@[simp]\ntheorem append_nil (s : Seq α) : append s nil = s := by\n  apply coinduction2 s; intro s\n  cases' s with x s\n  · trivial\n  · rw [cons_append, destruct_cons, destruct_cons]\n    dsimp\n    exact ⟨rfl, s, rfl, rfl⟩\n\n"}
{"name":"Stream'.Seq.append_assoc","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns t u : Stream'.Seq α\n⊢ Eq ((s.append t).append u) (s.append (t.append u))","decl":"@[simp]\ntheorem append_assoc (s t u : Seq α) : append (append s t) u = append s (append t u) := by\n  apply eq_of_bisim fun s1 s2 => ∃ s t u, s1 = append (append s t) u ∧ s2 = append s (append t u)\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, t, u, rfl, rfl⟩ => by\n        cases' s with _ s <;> simp\n        · cases' t with _ t <;> simp\n          · cases' u with _ u <;> simp\n            · refine ⟨nil, nil, u, ?_, ?_⟩ <;> simp\n          · refine ⟨nil, t, u, ?_, ?_⟩ <;> simp\n        · exact ⟨s, t, u, rfl, rfl⟩\n  · exact ⟨s, t, u, rfl, rfl⟩\n\n"}
{"name":"Stream'.Seq.map_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (Stream'.Seq.map f Stream'.Seq.nil) Stream'.Seq.nil","decl":"@[simp]\ntheorem map_nil (f : α → β) : map f nil = nil :=\n  rfl\n\n"}
{"name":"Stream'.Seq.map_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map f (Stream'.Seq.cons a s)) (Stream'.Seq.cons (f a) (Stream'.Seq.map f s))","decl":"@[simp]\ntheorem map_cons (f : α → β) (a) : ∀ s, map f (cons a s) = cons (f a) (map f s)\n  | ⟨s, al⟩ => by apply Subtype.eq; dsimp [cons, map]; rw [Stream'.map_cons]; rfl\n\n"}
{"name":"Stream'.Seq.map_id","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map id s) s","decl":"@[simp]\ntheorem map_id : ∀ s : Seq α, map id s = s\n  | ⟨s, al⟩ => by\n    apply Subtype.eq; dsimp [map]\n    rw [Option.map_id, Stream'.map_id]\n\n"}
{"name":"Stream'.Seq.map_tail","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map f s.tail) (Stream'.Seq.map f s).tail","decl":"@[simp]\ntheorem map_tail (f : α → β) : ∀ s, map f (tail s) = tail (map f s)\n  | ⟨s, al⟩ => by apply Subtype.eq; dsimp [tail, map]\n\n"}
{"name":"Stream'.Seq.map_comp","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map (Function.comp g f) s) (Stream'.Seq.map g (Stream'.Seq.map f s))","decl":"theorem map_comp (f : α → β) (g : β → γ) : ∀ s : Seq α, map (g ∘ f) s = map g (map f s)\n  | ⟨s, al⟩ => by\n    apply Subtype.eq; dsimp [map]\n    apply congr_arg fun f : _ → Option γ => Stream'.map f s\n    ext ⟨⟩ <;> rfl\n\n"}
{"name":"Stream'.Seq.map_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map f (s.append t)) ((Stream'.Seq.map f s).append (Stream'.Seq.map f t))","decl":"@[simp]\ntheorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) := by\n  apply\n    eq_of_bisim (fun s1 s2 => ∃ s t, s1 = map f (append s t) ∧ s2 = append (map f s) (map f t)) _\n      ⟨s, t, rfl, rfl⟩\n  intro s1 s2 h\n  exact\n    match s1, s2, h with\n    | _, _, ⟨s, t, rfl, rfl⟩ => by\n      cases' s with _ s <;> simp\n      · cases' t with _ t <;> simp\n        · refine ⟨nil, t, ?_, ?_⟩ <;> simp\n      · exact ⟨s, t, rfl, rfl⟩\n\n"}
{"name":"Stream'.Seq.map_get?","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.Seq α\nn : Nat\n⊢ Eq ((Stream'.Seq.map f s).get? n) (Option.map f (s.get? n))","decl":"@[simp]\ntheorem map_get? (f : α → β) : ∀ s n, get? (map f s) n = (get? s n).map f\n  | ⟨_, _⟩, _ => rfl\n\n"}
{"name":"Stream'.Seq.terminatedAt_map_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.Seq α\nn : Nat\n⊢ Iff ((Stream'.Seq.map f s).TerminatedAt n) (s.TerminatedAt n)","decl":"@[simp]\ntheorem terminatedAt_map_iff {f : α → β} {s : Seq α} {n : ℕ} :\n    (map f s).TerminatedAt n ↔ s.TerminatedAt n := by\n  simp [TerminatedAt]\n\n"}
{"name":"Stream'.Seq.terminates_map_iff","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.Seq α\n⊢ Iff (Stream'.Seq.map f s).Terminates s.Terminates","decl":"@[simp]\ntheorem terminates_map_iff {f : α → β} {s : Seq α}  :\n    (map f s).Terminates ↔ s.Terminates := by\n  simp [Terminates]\n\n"}
{"name":"Stream'.Seq.length_map","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\ns : Stream'.Seq α\nf : α → β\nh : (Stream'.Seq.map f s).Terminates\n⊢ Eq ((Stream'.Seq.map f s).length h) (s.length ⋯)","decl":"@[simp]\ntheorem length_map {s : Seq α} {f : α → β} (h : (s.map f).Terminates) :\n    (s.map f).length h = s.length (terminates_map_iff.1 h) := by\n  rw [length]\n  congr\n  ext\n  simp\n\n"}
{"name":"Stream'.Seq.instLawfulFunctor","module":"Mathlib.Data.Seq.Seq","initialProofState":"⊢ LawfulFunctor Stream'.Seq","decl":"instance : LawfulFunctor Seq where\n  id_map := @map_id\n  comp_map := @map_comp\n  map_const := rfl\n\n"}
{"name":"Stream'.Seq.join_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\n⊢ Eq Stream'.Seq.nil.join Stream'.Seq.nil","decl":"@[simp]\ntheorem join_nil : join nil = (nil : Seq α) :=\n  destruct_eq_nil rfl\n\n-- Not a simp lemmas as `join_cons` is more general\n"}
{"name":"Stream'.Seq.join_cons_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq.cons { fst := a, snd := Stream'.Seq.nil } S).join (Stream'.Seq.cons a S.join)","decl":"theorem join_cons_nil (a : α) (S) : join (cons (a, nil) S) = cons a (join S) :=\n  destruct_eq_cons <| by simp [join]\n\n-- Not a simp lemmas as `join_cons` is more general\n"}
{"name":"Stream'.Seq.join_cons_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na b : α\ns : Stream'.Seq α\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq.cons { fst := a, snd := Stream'.Seq.cons b s } S).join (Stream'.Seq.cons a (Stream'.Seq.cons { fst := b, snd := s } S).join)","decl":"theorem join_cons_cons (a b : α) (s S) :\n    join (cons (a, cons b s) S) = cons a (join (cons (b, s) S)) :=\n  destruct_eq_cons <| by simp [join]\n\n"}
{"name":"Stream'.Seq.join_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream'.Seq α\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq.cons { fst := a, snd := s } S).join (Stream'.Seq.cons a (s.append S.join))","decl":"@[simp]\ntheorem join_cons (a : α) (s S) : join (cons (a, s) S) = cons a (append s (join S)) := by\n  apply\n    eq_of_bisim\n      (fun s1 s2 => s1 = s2 ∨ ∃ a s S, s1 = join (cons (a, s) S) ∧ s2 = cons a (append s (join S)))\n      _ (Or.inr ⟨a, s, S, rfl, rfl⟩)\n  intro s1 s2 h\n  exact\n    match s1, s2, h with\n    | s, _, Or.inl <| Eq.refl s => by\n      cases' s with x s; · trivial\n      · rw [destruct_cons]\n        exact ⟨rfl, Or.inl rfl⟩\n    | _, _, Or.inr ⟨a, s, S, rfl, rfl⟩ => by\n      cases' s with x s\n      · simp [join_cons_cons, join_cons_nil]\n      · simpa [join_cons_cons, join_cons_nil] using Or.inr ⟨x, s, S, rfl, rfl⟩\n\n"}
{"name":"Stream'.Seq.join_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nS T : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (S.append T).join (S.join.append T.join)","decl":"@[simp]\ntheorem join_append (S T : Seq (Seq1 α)) : join (append S T) = append (join S) (join T) := by\n  apply\n    eq_of_bisim fun s1 s2 =>\n      ∃ s S T, s1 = append s (join (append S T)) ∧ s2 = append s (append (join S) (join T))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, T, rfl, rfl⟩ => by\n        cases' s with _ s <;> simp\n        · cases' S with s S <;> simp\n          · cases' T with s T\n            · simp\n            · cases' s with a s; simp only [join_cons, destruct_cons, true_and]\n              refine ⟨s, nil, T, ?_, ?_⟩ <;> simp\n          · cases' s with a s\n            simpa using ⟨s, S, T, rfl, rfl⟩\n        · exact ⟨s, S, T, rfl, rfl⟩\n  · refine ⟨nil, S, T, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.Seq.ofStream_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\ns : Stream' α\n⊢ Eq (↑(Stream'.cons a s)) (Stream'.Seq.cons a ↑s)","decl":"@[simp]\ntheorem ofStream_cons (a : α) (s) : ofStream (a::s) = cons a (ofStream s) := by\n  apply Subtype.eq; simp only [ofStream, cons]; rw [Stream'.map_cons]\n\n"}
{"name":"Stream'.Seq.ofList_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl l' : List α\n⊢ Eq (↑(HAppend.hAppend l l')) ((↑l).append ↑l')","decl":"@[simp]\ntheorem ofList_append (l l' : List α) : ofList (l ++ l') = append (ofList l) (ofList l') := by\n  induction l <;> simp [*]\n\n"}
{"name":"Stream'.Seq.ofStream_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nl : List α\ns : Stream' α\n⊢ Eq (↑(Stream'.appendStream' l s)) ((↑l).append ↑s)","decl":"@[simp]\ntheorem ofStream_append (l : List α) (s : Stream' α) :\n    ofStream (l ++ₛ s) = append (ofList l) (ofStream s) := by\n  induction l <;> simp [*, Stream'.nil_append_stream, Stream'.cons_append_stream]\n\n"}
{"name":"Stream'.Seq.dropn_add","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nm n : Nat\n⊢ Eq (s.drop (HAdd.hAdd m n)) ((s.drop m).drop n)","decl":"theorem dropn_add (s : Seq α) (m) : ∀ n, drop s (m + n) = drop (drop s m) n\n  | 0 => rfl\n  | n + 1 => congr_arg tail (dropn_add s _ n)\n\n"}
{"name":"Stream'.Seq.dropn_tail","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq (s.tail.drop n) (s.drop (HAdd.hAdd n 1))","decl":"theorem dropn_tail (s : Seq α) (n) : drop (tail s) n = drop s (n + 1) := by\n  rw [Nat.add_comm]; symm; apply dropn_add\n\n"}
{"name":"Stream'.Seq.head_dropn","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq (s.drop n).head (s.get? n)","decl":"@[simp]\ntheorem head_dropn (s : Seq α) (n) : head (drop s n) = get? s n := by\n  induction' n with n IH generalizing s; · rfl\n  rw [← get?_tail, ← dropn_tail]; apply IH\n\n"}
{"name":"Stream'.Seq.mem_map","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream'.Seq α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.Seq.map f s) (f a)","decl":"theorem mem_map (f : α → β) {a : α} : ∀ {s : Seq α}, a ∈ s → f a ∈ map f s\n  | ⟨_, _⟩ => Stream'.mem_map (Option.map f)\n\n"}
{"name":"Stream'.Seq.exists_of_mem_map","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nb : β\ns : Stream'.Seq α\na✝ : Membership.mem (Stream'.Seq.map f s) b\n⊢ Exists fun a => And (Membership.mem s a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {f} {b : β} : ∀ {s : Seq α}, b ∈ map f s → ∃ a, a ∈ s ∧ f a = b :=\n  fun {s} h => by match s with\n  | ⟨g, al⟩ =>\n    let ⟨o, om, oe⟩ := @Stream'.exists_of_mem_map _ _ (Option.map f) (some b) g h\n    cases' o with a\n    · injection oe\n    · injection oe with h'; exact ⟨a, om, h'⟩\n\n"}
{"name":"Stream'.Seq.of_mem_append","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns₁ s₂ : Stream'.Seq α\na : α\nh : Membership.mem (s₁.append s₂) a\n⊢ Or (Membership.mem s₁ a) (Membership.mem s₂ a)","decl":"theorem of_mem_append {s₁ s₂ : Seq α} {a : α} (h : a ∈ append s₁ s₂) : a ∈ s₁ ∨ a ∈ s₂ := by\n  have := h; revert this\n  generalize e : append s₁ s₂ = ss; intro h; revert s₁\n  apply mem_rec_on h _\n  intro b s' o s₁\n  cases' s₁ with c t₁\n  · intro m _\n    apply Or.inr\n    simpa using m\n  · intro m e\n    have this := congr_arg destruct e\n    cases' show a = c ∨ a ∈ append t₁ s₂ by simpa using m with e' m\n    · rw [e']\n      exact Or.inl (mem_cons _ _)\n    · cases' show c = b ∧ append t₁ s₂ = s' by simpa with i1 i2\n      cases' o with e' IH\n      · simp [i1, e']\n      · exact Or.imp_left (mem_cons_of_mem _) (IH m i2)\n\n"}
{"name":"Stream'.Seq.mem_append_left","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns₁ s₂ : Stream'.Seq α\na : α\nh : Membership.mem s₁ a\n⊢ Membership.mem (s₁.append s₂) a","decl":"theorem mem_append_left {s₁ s₂ : Seq α} {a : α} (h : a ∈ s₁) : a ∈ append s₁ s₂ := by\n  apply mem_rec_on h; intros; simp [*]\n\n"}
{"name":"Stream'.Seq.enum_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\nx : α\n⊢ Eq (Stream'.Seq.cons x s).enum (Stream'.Seq.cons { fst := 0, snd := x } (Stream'.Seq.map (Prod.map Nat.succ id) s.enum))","decl":"@[simp]\ntheorem enum_cons (s : Seq α) (x : α) :\n    enum (cons x s) = cons (0, x) (map (Prod.map Nat.succ id) (enum s)) := by\n  ext ⟨n⟩ : 1\n  · simp\n  · simp only [get?_enum, get?_cons_succ, map_get?, Option.map_map]\n    congr\n\n"}
{"name":"Stream'.Seq1.map_pair","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq1.map f { fst := a, snd := s }) { fst := f a, snd := Stream'.Seq.map f s }","decl":"theorem map_pair {f : α → β} {a s} : map f (a, s) = (f a, Seq.map f s) := rfl\n\n"}
{"name":"Stream'.Seq1.map_id","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq1 α\n⊢ Eq (Stream'.Seq1.map id s) s","decl":"theorem map_id : ∀ s : Seq1 α, map id s = s\n  | ⟨a, s⟩ => by simp [map]\n\n"}
{"name":"Stream'.Seq1.join_nil","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na : α\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq1.join { fst := { fst := a, snd := Stream'.Seq.nil }, snd := S }) { fst := a, snd := S.join }","decl":"@[simp]\ntheorem join_nil (a : α) (S) : join ((a, nil), S) = (a, Seq.join S) :=\n  rfl\n\n"}
{"name":"Stream'.Seq1.join_cons","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\na b : α\ns : Stream'.Seq α\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq1.join { fst := { fst := a, snd := Stream'.Seq.cons b s }, snd := S }) { fst := a, snd := (Stream'.Seq.cons { fst := b, snd := s } S).join }","decl":"@[simp]\ntheorem join_cons (a b : α) (s S) :\n    join ((a, Seq.cons b s), S) = (a, Seq.join (Seq.cons (b, s) S)) := by\n  dsimp [join]; rw [destruct_cons]\n\n"}
{"name":"Stream'.Seq1.join_map_ret","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (Stream'.Seq.map Stream'.Seq1.ret s).join s","decl":"@[simp]\ntheorem join_map_ret (s : Seq α) : Seq.join (Seq.map ret s) = s := by\n  apply coinduction2 s; intro s; cases s <;> simp [ret]\n\n"}
{"name":"Stream'.Seq1.bind_ret","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.Seq1 α\n⊢ Eq (s.bind (Function.comp Stream'.Seq1.ret f)) (Stream'.Seq1.map f s)","decl":"@[simp]\ntheorem bind_ret (f : α → β) : ∀ s, bind s (ret ∘ f) = map f s\n  | ⟨a, s⟩ => by\n    dsimp [bind, map]\n    -- Porting note: Was `rw [map_comp]; simp [Function.comp, ret]`\n    rw [map_comp, ret]\n    simp\n\n"}
{"name":"Stream'.Seq1.ret_bind","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\na : α\nf : α → Stream'.Seq1 β\n⊢ Eq ((Stream'.Seq1.ret a).bind f) (f a)","decl":"@[simp]\ntheorem ret_bind (a : α) (f : α → Seq1 β) : bind (ret a) f = f a := by\n  simp only [bind, map, ret.eq_1, map_nil]\n  cases' f a with a s\n  cases s <;> simp\n\n"}
{"name":"Stream'.Seq1.map_join'","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nS : Stream'.Seq (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq.map f S.join) (Stream'.Seq.map (Stream'.Seq1.map f) S).join","decl":"@[simp]\ntheorem map_join' (f : α → β) (S) : Seq.map f (Seq.join S) = Seq.join (Seq.map (map f) S) := by\n  apply\n    Seq.eq_of_bisim fun s1 s2 =>\n      ∃ s S,\n        s1 = Seq.append s (Seq.map f (Seq.join S)) ∧ s2 = append s (Seq.join (Seq.map (map f) S))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, rfl, rfl⟩ => by\n        cases' s with _ s <;> simp\n        · cases' S with x S <;> simp\n          · cases' x with a s\n            simpa [map] using ⟨_, _, rfl, rfl⟩\n        · exact ⟨s, S, rfl, rfl⟩\n  · refine ⟨nil, S, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.Seq1.map_join","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nS : Stream'.Seq1 (Stream'.Seq1 α)\n⊢ Eq (Stream'.Seq1.map f S.join) (Stream'.Seq1.map (Stream'.Seq1.map f) S).join","decl":"@[simp]\ntheorem map_join (f : α → β) : ∀ S, map f (join S) = join (map (map f) S)\n  | ((a, s), S) => by cases s <;> simp [map]\n\n"}
{"name":"Stream'.Seq1.join_join","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nSS : Stream'.Seq (Stream'.Seq1 (Stream'.Seq1 α))\n⊢ Eq SS.join.join (Stream'.Seq.map Stream'.Seq1.join SS).join","decl":"@[simp]\ntheorem join_join (SS : Seq (Seq1 (Seq1 α))) :\n    Seq.join (Seq.join SS) = Seq.join (Seq.map join SS) := by\n  apply\n    Seq.eq_of_bisim fun s1 s2 =>\n      ∃ s SS,\n        s1 = Seq.append s (Seq.join (Seq.join SS)) ∧ s2 = Seq.append s (Seq.join (Seq.map join SS))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, SS, rfl, rfl⟩ => by\n        cases' s with _ s <;> simp\n        · cases' SS with S SS <;> simp\n          · cases' S with s S; cases' s with x s\n            simp only [Seq.join_cons, join_append, destruct_cons]\n            cases' s with x s <;> simp\n            · exact ⟨_, _, rfl, rfl⟩\n            · refine ⟨Seq.cons x (append s (Seq.join S)), SS, ?_, ?_⟩ <;> simp\n        · exact ⟨s, SS, rfl, rfl⟩\n  · refine ⟨nil, SS, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.Seq1.bind_assoc","module":"Mathlib.Data.Seq.Seq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ns : Stream'.Seq1 α\nf : α → Stream'.Seq1 β\ng : β → Stream'.Seq1 γ\n⊢ Eq ((s.bind f).bind g) (s.bind fun x => (f x).bind g)","decl":"@[simp]\ntheorem bind_assoc (s : Seq1 α) (f : α → Seq1 β) (g : β → Seq1 γ) :\n    bind (bind s f) g = bind s fun x : α => bind (f x) g := by\n  cases' s with a s\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [bind, map]`.\n  simp only [bind, map_pair, map_join]\n  rw [← map_comp]\n  simp only [show (fun x => join (map g (f x))) = join ∘ (map g ∘ f) from rfl]\n  rw [map_comp _ join]\n  generalize Seq.map (map g ∘ f) s = SS\n  rcases map g (f a) with ⟨⟨a, s⟩, S⟩\n  -- Porting note: Instead of `apply recOn s <;> intros`, `induction'` are used to\n  --   give names to variables.\n  induction' s using recOn with x s_1 <;> induction' S using recOn with x_1 s_2 <;> simp\n  · cases' x_1 with x t\n    cases t <;> simp\n  · cases' x_1 with y t; simp\n\n"}
{"name":"Stream'.Seq1.lawfulMonad","module":"Mathlib.Data.Seq.Seq","initialProofState":"⊢ LawfulMonad Stream'.Seq1","decl":"instance lawfulMonad : LawfulMonad Seq1 := LawfulMonad.mk'\n  (id_map := @map_id)\n  (bind_pure_comp := @bind_ret)\n  (pure_bind := @ret_bind)\n  (bind_assoc := @bind_assoc)\n\n"}
