{"name":"List.reduceOption_cons_of_some","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nx : α\nl : List (Option α)\n⊢ Eq (List.cons (Option.some x) l).reduceOption (List.cons x l.reduceOption)","decl":"@[simp]\ntheorem reduceOption_cons_of_some (x : α) (l : List (Option α)) :\n    reduceOption (some x :: l) = x :: l.reduceOption := by\n  simp only [reduceOption, filterMap, id, eq_self_iff_true, and_self_iff]\n\n"}
{"name":"List.reduceOption_cons_of_none","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Eq (List.cons Option.none l).reduceOption l.reduceOption","decl":"@[simp]\ntheorem reduceOption_cons_of_none (l : List (Option α)) :\n    reduceOption (none :: l) = l.reduceOption := by simp only [reduceOption, filterMap, id]\n\n"}
{"name":"List.reduceOption_nil","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\n⊢ Eq List.nil.reduceOption List.nil","decl":"@[simp]\ntheorem reduceOption_nil : @reduceOption α [] = [] :=\n  rfl\n\n"}
{"name":"List.reduceOption_map","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List (Option α)\nf : α → β\n⊢ Eq (List.map (Option.map f) l).reduceOption (List.map f l.reduceOption)","decl":"@[simp]\ntheorem reduceOption_map {l : List (Option α)} {f : α → β} :\n    reduceOption (map (Option.map f) l) = map f (reduceOption l) := by\n  induction' l with hd tl hl\n  · simp only [reduceOption_nil, map_nil]\n  · cases hd <;>\n      simpa [Option.map_some', map, eq_self_iff_true, reduceOption_cons_of_some] using hl\n\n"}
{"name":"List.reduceOption_append","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl l' : List (Option α)\n⊢ Eq (HAppend.hAppend l l').reduceOption (HAppend.hAppend l.reduceOption l'.reduceOption)","decl":"theorem reduceOption_append (l l' : List (Option α)) :\n    (l ++ l').reduceOption = l.reduceOption ++ l'.reduceOption :=\n  filterMap_append l l' id\n\n"}
{"name":"List.reduceOption_replicate_none","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nn : Nat\n⊢ Eq (List.replicate n Option.none).reduceOption List.nil","decl":"@[simp]\ntheorem reduceOption_replicate_none {n : ℕ} : (replicate n (@none α)).reduceOption = [] := by\n  dsimp [reduceOption]\n  rw [filterMap_replicate_of_none]\n  rfl\n\n"}
{"name":"List.reduceOption_eq_nil_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Iff (Eq l.reduceOption List.nil) (Exists fun n => Eq l (List.replicate n Option.none))","decl":"theorem reduceOption_eq_nil_iff (l : List (Option α)) :\n    l.reduceOption = [] ↔ ∃ n, l = replicate n none := by\n  dsimp [reduceOption]\n  rw [filterMap_eq_nil_iff]\n  constructor\n  · intro h\n    exact ⟨l.length, eq_replicate_of_mem h⟩\n  · intro ⟨_, h⟩\n    simp_rw [h, mem_replicate]\n    tauto\n\n"}
{"name":"List.reduceOption_eq_singleton_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\na : α\n⊢ Iff (Eq l.reduceOption (List.cons a List.nil)) (Exists fun m => Exists fun n => Eq l (HAppend.hAppend (List.replicate m Option.none) (List.cons (Option.some a) (List.replicate n Option.none))))","decl":"theorem reduceOption_eq_singleton_iff (l : List (Option α)) (a : α) :\n    l.reduceOption = [a] ↔ ∃ m n, l = replicate m none ++ some a :: replicate n none := by\n  dsimp [reduceOption]\n  constructor\n  · intro h\n    rw [filterMap_eq_cons_iff] at h\n    obtain ⟨l₁, _, l₂, h, hl₁, ⟨⟩, hl₂⟩ := h\n    rw [filterMap_eq_nil_iff] at hl₂\n    apply eq_replicate_of_mem at hl₁\n    apply eq_replicate_of_mem at hl₂\n    rw [h, hl₁, hl₂]\n    use l₁.length, l₂.length\n  · intro ⟨_, _, h⟩\n    simp only [h, filterMap_append, filterMap_cons_some, filterMap_replicate_of_none, id_eq,\n      nil_append, Option.some.injEq]\n\n"}
{"name":"List.reduceOption_eq_append_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nl'₁ l'₂ : List α\n⊢ Iff (Eq l.reduceOption (HAppend.hAppend l'₁ l'₂)) (Exists fun l₁ => Exists fun l₂ => And (Eq l (HAppend.hAppend l₁ l₂)) (And (Eq l₁.reduceOption l'₁) (Eq l₂.reduceOption l'₂)))","decl":"theorem reduceOption_eq_append_iff (l : List (Option α)) (l'₁ l'₂ : List α) :\n    l.reduceOption = l'₁ ++ l'₂ ↔\n      ∃ l₁ l₂, l = l₁ ++ l₂ ∧ l₁.reduceOption = l'₁ ∧ l₂.reduceOption = l'₂ := by\n  dsimp [reduceOption]\n  constructor\n  · intro h\n    rw [filterMap_eq_append_iff] at h\n    trivial\n  · intro ⟨_, _, h, hl₁, hl₂⟩\n    rw [h, filterMap_append, hl₁, hl₂]\n\n"}
{"name":"List.reduceOption_eq_concat_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nl' : List α\na : α\n⊢ Iff (Eq l.reduceOption (l'.concat a)) (Exists fun l₁ => Exists fun l₂ => And (Eq l (HAppend.hAppend l₁ (List.cons (Option.some a) l₂))) (And (Eq l₁.reduceOption l') (Eq l₂.reduceOption List.nil)))","decl":"theorem reduceOption_eq_concat_iff (l : List (Option α)) (l' : List α) (a : α) :\n    l.reduceOption = l'.concat a ↔\n      ∃ l₁ l₂, l = l₁ ++ some a :: l₂ ∧ l₁.reduceOption = l' ∧ l₂.reduceOption = [] := by\n  rw [concat_eq_append]\n  constructor\n  · intro h\n    rw [reduceOption_eq_append_iff] at h\n    obtain ⟨l₁, _, h, hl₁, hl₂⟩ := h\n    rw [reduceOption_eq_singleton_iff] at hl₂\n    obtain ⟨m, n, hl₂⟩ := hl₂\n    use l₁ ++ replicate m none, replicate n none\n    simp_rw [h, reduceOption_append, reduceOption_replicate_none, append_assoc, append_nil, hl₁,\n      hl₂]\n    trivial\n  · intro ⟨_, _, h, hl₁, hl₂⟩\n    rw [h, reduceOption_append, reduceOption_cons_of_some, hl₁, hl₂]\n\n"}
{"name":"List.reduceOption_length_eq","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Eq l.reduceOption.length (List.filter Option.isSome l).length","decl":"theorem reduceOption_length_eq {l : List (Option α)} :\n    l.reduceOption.length = (l.filter Option.isSome).length := by\n  induction' l with hd tl hl\n  · simp_rw [reduceOption_nil, filter_nil, length]\n  · cases hd <;> simp [hl]\n\n"}
{"name":"List.length_eq_reduceOption_length_add_filter_none","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Eq l.length (HAdd.hAdd l.reduceOption.length (List.filter Option.isNone l).length)","decl":"theorem length_eq_reduceOption_length_add_filter_none {l : List (Option α)} :\n    l.length = l.reduceOption.length + (l.filter Option.isNone).length := by\n  simp_rw [reduceOption_length_eq, l.length_eq_length_filter_add Option.isSome, Option.bnot_isSome]\n\n"}
{"name":"List.reduceOption_length_le","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ LE.le l.reduceOption.length l.length","decl":"theorem reduceOption_length_le (l : List (Option α)) : l.reduceOption.length ≤ l.length := by\n  rw [length_eq_reduceOption_length_add_filter_none]\n  apply Nat.le_add_right\n\n"}
{"name":"List.reduceOption_length_eq_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Iff (Eq l.reduceOption.length l.length) (∀ (x : Option α), Membership.mem l x → Eq x.isSome Bool.true)","decl":"theorem reduceOption_length_eq_iff {l : List (Option α)} :\n    l.reduceOption.length = l.length ↔ ∀ x ∈ l, Option.isSome x := by\n  rw [reduceOption_length_eq, List.filter_length_eq_length]\n\n"}
{"name":"List.reduceOption_length_lt_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\n⊢ Iff (LT.lt l.reduceOption.length l.length) (Membership.mem l Option.none)","decl":"theorem reduceOption_length_lt_iff {l : List (Option α)} :\n    l.reduceOption.length < l.length ↔ none ∈ l := by\n  rw [Nat.lt_iff_le_and_ne, and_iff_right (reduceOption_length_le l), Ne,\n    reduceOption_length_eq_iff]\n  induction l <;> simp\n  rw [@eq_comm _ none, ← Option.not_isSome_iff_eq_none, Decidable.imp_iff_not_or]\n\n"}
{"name":"List.reduceOption_singleton","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nx : Option α\n⊢ Eq (List.cons x List.nil).reduceOption x.toList","decl":"theorem reduceOption_singleton (x : Option α) : [x].reduceOption = x.toList := by cases x <;> rfl\n\n"}
{"name":"List.reduceOption_concat","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nx : Option α\n⊢ Eq (l.concat x).reduceOption (HAppend.hAppend l.reduceOption x.toList)","decl":"theorem reduceOption_concat (l : List (Option α)) (x : Option α) :\n    (l.concat x).reduceOption = l.reduceOption ++ x.toList := by\n  induction' l with hd tl hl generalizing x\n  · cases x <;> simp [Option.toList]\n  · simp only [concat_eq_append, reduceOption_append] at hl\n    cases hd <;> simp [hl, reduceOption_append]\n\n"}
{"name":"List.reduceOption_concat_of_some","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nx : α\n⊢ Eq (l.concat (Option.some x)).reduceOption (l.reduceOption.concat x)","decl":"theorem reduceOption_concat_of_some (l : List (Option α)) (x : α) :\n    (l.concat (some x)).reduceOption = l.reduceOption.concat x := by\n  simp only [reduceOption_nil, concat_eq_append, reduceOption_append, reduceOption_cons_of_some]\n\n"}
{"name":"List.reduceOption_mem_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nx : α\n⊢ Iff (Membership.mem l.reduceOption x) (Membership.mem l (Option.some x))","decl":"theorem reduceOption_mem_iff {l : List (Option α)} {x : α} : x ∈ l.reduceOption ↔ some x ∈ l := by\n  simp only [reduceOption, id, mem_filterMap, exists_eq_right]\n\n"}
{"name":"List.reduceOption_get?_iff","module":"Mathlib.Data.List.ReduceOption","initialProofState":"α : Type u_1\nl : List (Option α)\nx : α\n⊢ Iff (Exists fun i => Eq (l.get? i) (Option.some (Option.some x))) (Exists fun i => Eq (l.reduceOption.get? i) (Option.some x))","decl":"theorem reduceOption_get?_iff {l : List (Option α)} {x : α} :\n    (∃ i, l.get? i = some (some x)) ↔ ∃ i, l.reduceOption.get? i = some x := by\n  rw [← mem_iff_get?, ← mem_iff_get?, reduceOption_mem_iff]\n\n"}
