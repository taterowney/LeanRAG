{"name":"Multiset.lists_coe","module":"Mathlib.Data.Fintype.List","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).lists ↑l.permutations","decl":"@[simp]\ntheorem lists_coe (l : List α) : lists (l : Multiset α) = l.permutations :=\n  rfl\n\n"}
{"name":"Multiset.lists_nodup_finset","module":"Mathlib.Data.Fintype.List","initialProofState":"α : Type u_1\nl : Finset α\n⊢ l.val.lists.Nodup","decl":"@[simp]\ntheorem lists_nodup_finset (l : Finset α) : (lists (l.val)).Nodup := by\n  have h_nodup : l.val.Nodup := l.nodup\n  rw [← Finset.coe_toList l, Multiset.coe_nodup] at h_nodup\n  rw [← Finset.coe_toList l]\n  exact nodup_permutations l.val.toList (h_nodup)\n\n"}
{"name":"Multiset.mem_lists_iff","module":"Mathlib.Data.Fintype.List","initialProofState":"α : Type u_1\ns : Multiset α\nl : List α\n⊢ Iff (Membership.mem s.lists l) (Eq s (Quotient.mk (List.isSetoid α) l))","decl":"@[simp]\ntheorem mem_lists_iff (s : Multiset α) (l : List α) : l ∈ lists s ↔ s = ⟦l⟧ := by\n  induction s using Quotient.inductionOn\n  simpa using perm_comm\n\n"}
{"name":"perm_toList","module":"Mathlib.Data.Fintype.List","initialProofState":"α : Type u_1\nf₁ f₂ : Finset α\n⊢ Iff (f₁.toList.Perm f₂.toList) (Eq f₁ f₂)","decl":"@[simp]\ntheorem perm_toList {f₁ f₂ : Finset α} : f₁.toList ~ f₂.toList ↔ f₁ = f₂ :=\n  ⟨fun h => Finset.ext_iff.mpr (fun x => by simpa [← Finset.mem_toList] using Perm.mem_iff h),\n   fun h ↦ Perm.of_eq <| congrArg Finset.toList h⟩\n\n"}
