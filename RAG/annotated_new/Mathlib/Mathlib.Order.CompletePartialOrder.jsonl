{"name":"CompletePartialOrder.lubOfDirected","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"α : Type u_4\nself : CompletePartialOrder α\nd : Set α\na✝ : DirectedOn (fun x1 x2 => LE.le x1 x2) d\n⊢ IsLUB d (SupSet.sSup d)","decl":"/--\nComplete partial orders are partial orders where every directed set has a least upper bound.\n-/\nclass CompletePartialOrder (α : Type*) extends PartialOrder α, SupSet α where\n  /-- For each directed set `d`, `sSup d` is the least upper bound of `d`. -/\n  lubOfDirected : ∀ d, DirectedOn (· ≤ ·) d → IsLUB d (sSup d)\n\n"}
{"name":"DirectedOn.isLUB_sSup","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : CompletePartialOrder α\nd : Set α\na✝ : DirectedOn (fun x1 x2 => LE.le x1 x2) d\n⊢ IsLUB d (SupSet.sSup d)","decl":"protected lemma DirectedOn.isLUB_sSup : DirectedOn (· ≤ ·) d → IsLUB d (sSup d) :=\nCompletePartialOrder.lubOfDirected _\n\n"}
{"name":"DirectedOn.le_sSup","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : CompletePartialOrder α\nd : Set α\na : α\nhd : DirectedOn (fun x1 x2 => LE.le x1 x2) d\nha : Membership.mem d a\n⊢ LE.le a (SupSet.sSup d)","decl":"protected lemma DirectedOn.le_sSup (hd : DirectedOn (· ≤ ·) d) (ha : a ∈ d) : a ≤ sSup d :=\nhd.isLUB_sSup.1 ha\n\n"}
{"name":"DirectedOn.sSup_le","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"α : Type u_2\ninst✝ : CompletePartialOrder α\nd : Set α\na : α\nhd : DirectedOn (fun x1 x2 => LE.le x1 x2) d\nha : ∀ (b : α), Membership.mem d b → LE.le b a\n⊢ LE.le (SupSet.sSup d) a","decl":"protected lemma DirectedOn.sSup_le (hd : DirectedOn (· ≤ ·) d) (ha : ∀ b ∈ d, b ≤ a) : sSup d ≤ a :=\nhd.isLUB_sSup.2 ha\n\n"}
{"name":"Directed.le_iSup","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompletePartialOrder α\nf : ι → α\nhf : Directed (fun x1 x2 => LE.le x1 x2) f\ni : ι\n⊢ LE.le (f i) (iSup fun j => f j)","decl":"protected lemma Directed.le_iSup (hf : Directed (· ≤ ·) f) (i : ι) : f i ≤ ⨆ j, f j :=\nhf.directedOn_range.le_sSup <| Set.mem_range_self _\n\n"}
{"name":"Directed.iSup_le","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝ : CompletePartialOrder α\nf : ι → α\na : α\nhf : Directed (fun x1 x2 => LE.le x1 x2) f\nha : ∀ (i : ι), LE.le (f i) a\n⊢ LE.le (iSup fun i => f i) a","decl":"protected lemma Directed.iSup_le (hf : Directed (· ≤ ·) f) (ha : ∀ i, f i ≤ a) :  ⨆ i, f i ≤ a :=\nhf.directedOn_range.sSup_le <| Set.forall_mem_range.2 ha\n\n--TODO: We could mimic more `sSup`/`iSup` lemmas\n\n"}
{"name":"CompletePartialOrder.scottContinuous","module":"Mathlib.Order.CompletePartialOrder","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CompletePartialOrder α\ninst✝ : Preorder β\nf : α → β\n⊢ Iff (ScottContinuous f) (∀ ⦃d : Set α⦄, d.Nonempty → DirectedOn (fun x1 x2 => LE.le x1 x2) d → IsLUB (Set.image f d) (f (SupSet.sSup d)))","decl":"/-- Scott-continuity takes on a simpler form in complete partial orders. -/\nlemma CompletePartialOrder.scottContinuous {f : α → β} :\n    ScottContinuous f ↔\n    ∀ ⦃d : Set α⦄, d.Nonempty → DirectedOn (· ≤ ·) d → IsLUB (f '' d) (f (sSup d)) := by\n  refine ⟨fun h d hd₁ hd₂ ↦ h hd₁ hd₂ hd₂.isLUB_sSup, fun h d hne hd a hda ↦ ?_⟩\n  rw [hda.unique hd.isLUB_sSup]\n  exact h hne hd\n\n"}
