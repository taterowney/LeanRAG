{"name":"LieAlgebra.ExtendScalars.bracket_tmul","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\ns t : A\nx : L\ny : M\n⊢ Eq (Bracket.bracket (TensorProduct.tmul R s x) (TensorProduct.tmul R t y)) (TensorProduct.tmul R (HMul.hMul s t) (Bracket.bracket x y))","decl":"@[simp]\ntheorem bracket_tmul (s t : A) (x : L) (y : M) : ⁅s ⊗ₜ[R] x, t ⊗ₜ[R] y⁆ = (s * t) ⊗ₜ ⁅x, y⁆ := rfl\n\n"}
{"name":"LieAlgebra.ExtendScalars.instLieModule","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : LieModule R L M\n⊢ LieModule A (TensorProduct R A L) (TensorProduct R A M)","decl":"instance instLieModule : LieModule A (A ⊗[R] L) (A ⊗[R] M) where\n  smul_lie t x m := by simp only [bracket_def, map_smul, LinearMap.smul_apply]\n  lie_smul _ _ _ := map_smul _ _ _\n\n"}
{"name":"LieModule.toEnd_baseChange","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : L\n⊢ Eq ((LieModule.toEnd A (TensorProduct R A L) (TensorProduct R A M)) (TensorProduct.tmul R 1 x)) (LinearMap.baseChange A ((LieModule.toEnd R L M) x))","decl":"@[simp]\nlemma LieModule.toEnd_baseChange (x : L) :\n    toEnd A (A ⊗[R] L) (A ⊗[R] M) (1 ⊗ₜ x) = (toEnd R L M x).baseChange A := by\n  ext; simp\n\n"}
{"name":"LieSubmodule.coe_baseChange","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nN : LieSubmodule R L M\n⊢ Eq (↑(LieSubmodule.baseChange A N)) (Submodule.baseChange A ↑N)","decl":"@[simp]\nlemma coe_baseChange :\n    (N.baseChange A : Submodule A (A ⊗[R] M)) = (N : Submodule R M).baseChange A :=\n  rfl\n\n"}
{"name":"LieSubmodule.tmul_mem_baseChange_of_mem","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nN : LieSubmodule R L M\na : A\nm : M\nhm : Membership.mem N m\n⊢ Membership.mem (LieSubmodule.baseChange A N) (TensorProduct.tmul R a m)","decl":"variable {R A L M} in\nlemma tmul_mem_baseChange_of_mem (a : A) {m : M} (hm : m ∈ N) :\n    a ⊗ₜ[R] m ∈ N.baseChange A :=\n  (N : Submodule R M).tmul_mem_baseChange_of_mem a hm\n\n"}
{"name":"LieSubmodule.mem_baseChange_iff","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nN : LieSubmodule R L M\nm : TensorProduct R A M\n⊢ Iff (Membership.mem (LieSubmodule.baseChange A N) m) (Membership.mem (Submodule.span A ↑(Submodule.map ((TensorProduct.mk R A M) 1) ↑N)) m)","decl":"lemma mem_baseChange_iff {m : A ⊗[R] M} :\n    m ∈ N.baseChange A ↔\n    m ∈ Submodule.span A ((N : Submodule R M).map (TensorProduct.mk R A M 1)) :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.baseChange_bot","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (LieSubmodule.baseChange A Bot.bot) Bot.bot","decl":"@[simp]\nlemma baseChange_bot : (⊥ : LieSubmodule R L M).baseChange A = ⊥ := by\n  simp only [baseChange, bot_toSubmodule, Submodule.baseChange_bot,\n    Submodule.bot_toAddSubmonoid]\n  rfl\n\n"}
{"name":"LieSubmodule.baseChange_top","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (LieSubmodule.baseChange A Top.top) Top.top","decl":"@[simp]\nlemma baseChange_top : (⊤ : LieSubmodule R L M).baseChange A = ⊤ := by\n  simp only [baseChange, top_toSubmodule, Submodule.baseChange_top,\n    Submodule.bot_toAddSubmonoid]\n  rfl\n\n"}
{"name":"LieSubmodule.lie_baseChange","module":"Mathlib.Algebra.Lie.BaseChange","initialProofState":"R : Type u_1\nA : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nI : LieIdeal R L\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.baseChange A (Bracket.bracket I N)) (Bracket.bracket (LieSubmodule.baseChange A I) (LieSubmodule.baseChange A N))","decl":"lemma lie_baseChange {I : LieIdeal R L} {N : LieSubmodule R L M} :\n    ⁅I, N⁆.baseChange A = ⁅I.baseChange A, N.baseChange A⁆ := by\n  set s : Set (A ⊗[R] M) := { m | ∃ x ∈ I, ∃ n ∈ N, 1 ⊗ₜ ⁅x, n⁆ = m}\n  have : (TensorProduct.mk R A M 1) '' {m | ∃ x ∈ I, ∃ n ∈ N, ⁅x, n⁆ = m} = s := by ext; simp [s]\n  rw [← toSubmodule_inj, coe_baseChange, lieIdeal_oper_eq_linear_span',\n    Submodule.baseChange_span, this, lieIdeal_oper_eq_linear_span']\n  refine le_antisymm (Submodule.span_mono ?_) (Submodule.span_le.mpr ?_)\n  · rintro - ⟨x, hx, m, hm, rfl⟩\n    exact ⟨1 ⊗ₜ x, tmul_mem_baseChange_of_mem 1 hx,\n           1 ⊗ₜ m, tmul_mem_baseChange_of_mem 1 hm, by simp⟩\n  · rintro - ⟨x, hx, m, hm, rfl⟩\n    revert m\n    apply Submodule.span_induction\n      (p := fun x' _ ↦ ∀ m' ∈ N.baseChange A, ⁅x', m'⁆ ∈ Submodule.span A s) (hx := hx)\n    · rintro _ ⟨y : L, hy : y ∈ I, rfl⟩ m hm\n      apply Submodule.span_induction\n        (p := fun m' _ ↦ ⁅(1 : A) ⊗ₜ[R] y, m'⁆ ∈ Submodule.span A s) (hx := hm)\n      · rintro - ⟨m', hm' : m' ∈ N, rfl⟩\n        rw [TensorProduct.mk_apply, LieAlgebra.ExtendScalars.bracket_tmul, mul_one]\n        apply Submodule.subset_span\n        exact ⟨y, hy, m', hm', rfl⟩\n      · simp\n      · intro u v _ _ hu hv\n        rw [lie_add]\n        exact Submodule.add_mem _ hu hv\n      · intro a u _ hu\n        rw [lie_smul]\n        exact Submodule.smul_mem _ a hu\n    · simp\n    · intro x y _ _ hx hy m' hm'\n      rw [add_lie]\n      exact Submodule.add_mem _ (hx _ hm') (hy _ hm')\n    · intro a x _ hx m' hm'\n      rw [smul_lie]\n      exact Submodule.smul_mem _ a (hx _ hm')\n\n"}
