{"name":"Polynomial.isPrimitive_iff_isUnit_of_C_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Polynomial R\n⊢ Iff p.IsPrimitive (∀ (r : R), Dvd.dvd (Polynomial.C r) p → IsUnit r)","decl":"theorem isPrimitive_iff_isUnit_of_C_dvd {p : R[X]} : p.IsPrimitive ↔ ∀ r : R, C r ∣ p → IsUnit r :=\n  Iff.rfl\n\n"}
{"name":"Polynomial.isPrimitive_one","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Polynomial.IsPrimitive 1","decl":"@[simp]\ntheorem isPrimitive_one : IsPrimitive (1 : R[X]) := fun _ h =>\n  isUnit_C.mp (isUnit_of_dvd_one h)\n\n"}
{"name":"Polynomial.Monic.isPrimitive","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Polynomial R\nhp : p.Monic\n⊢ p.IsPrimitive","decl":"theorem Monic.isPrimitive {p : R[X]} (hp : p.Monic) : p.IsPrimitive := by\n  rintro r ⟨q, h⟩\n  exact isUnit_of_mul_eq_one r (q.coeff p.natDegree) (by rwa [← coeff_C_mul, ← h])\n\n"}
{"name":"Polynomial.IsPrimitive.ne_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\np : Polynomial R\nhp : p.IsPrimitive\n⊢ Ne p 0","decl":"theorem IsPrimitive.ne_zero [Nontrivial R] {p : R[X]} (hp : p.IsPrimitive) : p ≠ 0 := by\n  rintro rfl\n  exact (hp 0 (dvd_zero (C 0))).ne_zero rfl\n\n"}
{"name":"Polynomial.isPrimitive_of_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : Dvd.dvd q p\n⊢ q.IsPrimitive","decl":"theorem isPrimitive_of_dvd {p q : R[X]} (hp : IsPrimitive p) (hq : q ∣ p) : IsPrimitive q :=\n  fun a ha => isPrimitive_iff_isUnit_of_C_dvd.mp hp a (dvd_trans ha hq)\n\n"}
{"name":"Polynomial.content_dvd_coeff","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nn : Nat\n⊢ Dvd.dvd p.content (p.coeff n)","decl":"theorem content_dvd_coeff {p : R[X]} (n : ℕ) : p.content ∣ p.coeff n := by\n  by_cases h : n ∈ p.support\n  · apply Finset.gcd_dvd h\n  rw [mem_support_iff, Classical.not_not] at h\n  rw [h]\n  apply dvd_zero\n\n"}
{"name":"Polynomial.content_C","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\nr : R\n⊢ Eq (Polynomial.C r).content (normalize r)","decl":"@[simp]\ntheorem content_C {r : R} : (C r).content = normalize r := by\n  rw [content]\n  by_cases h0 : r = 0\n  · simp [h0]\n  have h : (C r).support = {0} := support_monomial _ h0\n  simp [h]\n\n"}
{"name":"Polynomial.content_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\n⊢ Eq (Polynomial.content 0) 0","decl":"@[simp]\ntheorem content_zero : content (0 : R[X]) = 0 := by rw [← C_0, content_C, normalize_zero]\n\n"}
{"name":"Polynomial.content_one","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\n⊢ Eq (Polynomial.content 1) 1","decl":"@[simp]\ntheorem content_one : content (1 : R[X]) = 1 := by rw [← C_1, content_C, normalize_one]\n\n"}
{"name":"Polynomial.content_X_mul","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq (HMul.hMul Polynomial.X p).content p.content","decl":"theorem content_X_mul {p : R[X]} : content (X * p) = content p := by\n  rw [content, content, Finset.gcd_def, Finset.gcd_def]\n  refine congr rfl ?_\n  have h : (X * p).support = p.support.map ⟨Nat.succ, Nat.succ_injective⟩ := by\n    ext a\n    simp only [exists_prop, Finset.mem_map, Function.Embedding.coeFn_mk, Ne, mem_support_iff]\n    cases' a with a\n    · simp [coeff_X_mul_zero, Nat.succ_ne_zero]\n    rw [mul_comm, coeff_mul_X]\n    constructor\n    · intro h\n      use a\n    · rintro ⟨b, ⟨h1, h2⟩⟩\n      rw [← Nat.succ_injective h2]\n      apply h1\n  rw [h]\n  simp only [Finset.map_val, Function.comp_apply, Function.Embedding.coeFn_mk, Multiset.map_map]\n  refine congr (congr rfl ?_) rfl\n  ext a\n  rw [mul_comm]\n  simp [coeff_mul_X]\n\n"}
{"name":"Polynomial.content_X_pow","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\nk : Nat\n⊢ Eq (HPow.hPow Polynomial.X k).content 1","decl":"@[simp]\ntheorem content_X_pow {k : ℕ} : content ((X : R[X]) ^ k) = 1 := by\n  induction' k with k hi\n  · simp\n  rw [pow_succ', content_X_mul, hi]\n\n"}
{"name":"Polynomial.content_X","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\n⊢ Eq Polynomial.X.content 1","decl":"@[simp]\ntheorem content_X : content (X : R[X]) = 1 := by rw [← mul_one X, content_X_mul, content_one]\n\n"}
{"name":"Polynomial.content_C_mul","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\nr : R\np : Polynomial R\n⊢ Eq (HMul.hMul (Polynomial.C r) p).content (HMul.hMul (normalize r) p.content)","decl":"theorem content_C_mul (r : R) (p : R[X]) : (C r * p).content = normalize r * p.content := by\n  by_cases h0 : r = 0; · simp [h0]\n  rw [content]; rw [content]; rw [← Finset.gcd_mul_left]\n  refine congr (congr rfl ?_) ?_ <;> ext <;> simp [h0, mem_support_iff]\n\n"}
{"name":"Polynomial.content_monomial","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\nr : R\nk : Nat\n⊢ Eq ((Polynomial.monomial k) r).content (normalize r)","decl":"@[simp]\ntheorem content_monomial {r : R} {k : ℕ} : content (monomial k r) = normalize r := by\n  rw [← C_mul_X_pow_eq_monomial, content_C_mul, content_X_pow, mul_one]\n\n"}
{"name":"Polynomial.content_eq_zero_iff","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Iff (Eq p.content 0) (Eq p 0)","decl":"theorem content_eq_zero_iff {p : R[X]} : content p = 0 ↔ p = 0 := by\n  rw [content, Finset.gcd_eq_zero_iff]\n  constructor <;> intro h\n  · ext n\n    by_cases h0 : n ∈ p.support\n    · rw [h n h0, coeff_zero]\n    · rw [mem_support_iff] at h0\n      push_neg at h0\n      simp [h0]\n  · intro x\n    simp [h]\n\n-- Porting note: this reduced with simp so created `normUnit_content` and put simp on it\n"}
{"name":"Polynomial.normalize_content","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq (normalize p.content) p.content","decl":"theorem normalize_content {p : R[X]} : normalize p.content = p.content :=\n  Finset.normalize_gcd\n\n"}
{"name":"Polynomial.normUnit_content","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq (NormalizationMonoid.normUnit p.content) 1","decl":"@[simp]\ntheorem normUnit_content {p : R[X]} : normUnit (content p) = 1 := by\n  by_cases hp0 : p.content = 0\n  · simp [hp0]\n  · ext\n    apply mul_left_cancel₀ hp0\n    erw [← normalize_apply, normalize_content, mul_one]\n\n"}
{"name":"Polynomial.content_eq_gcd_range_of_lt","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nn : Nat\nh : LT.lt p.natDegree n\n⊢ Eq p.content ((Finset.range n).gcd p.coeff)","decl":"theorem content_eq_gcd_range_of_lt (p : R[X]) (n : ℕ) (h : p.natDegree < n) :\n    p.content = (Finset.range n).gcd p.coeff := by\n  apply dvd_antisymm_of_normalize_eq normalize_content Finset.normalize_gcd\n  · rw [Finset.dvd_gcd_iff]\n    intro i _\n    apply content_dvd_coeff _\n  · apply Finset.gcd_mono\n    intro i\n    simp only [Nat.lt_succ_iff, mem_support_iff, Ne, Finset.mem_range]\n    contrapose!\n    intro h1\n    apply coeff_eq_zero_of_natDegree_lt (lt_of_lt_of_le h h1)\n\n"}
{"name":"Polynomial.content_eq_gcd_range_succ","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq p.content ((Finset.range p.natDegree.succ).gcd p.coeff)","decl":"theorem content_eq_gcd_range_succ (p : R[X]) :\n    p.content = (Finset.range p.natDegree.succ).gcd p.coeff :=\n  content_eq_gcd_range_of_lt _ _ (Nat.lt_succ_self _)\n\n"}
{"name":"Polynomial.content_eq_gcd_leadingCoeff_content_eraseLead","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq p.content (GCDMonoid.gcd p.leadingCoeff p.eraseLead.content)","decl":"theorem content_eq_gcd_leadingCoeff_content_eraseLead (p : R[X]) :\n    p.content = GCDMonoid.gcd p.leadingCoeff (eraseLead p).content := by\n  by_cases h : p = 0\n  · simp [h]\n  rw [← leadingCoeff_eq_zero, leadingCoeff, ← Ne, ← mem_support_iff] at h\n  rw [content, ← Finset.insert_erase h, Finset.gcd_insert, leadingCoeff, content,\n    eraseLead_support]\n  refine congr rfl (Finset.gcd_congr rfl fun i hi => ?_)\n  rw [Finset.mem_erase] at hi\n  rw [eraseLead_coeff, if_neg hi.1]\n\n"}
{"name":"Polynomial.dvd_content_iff_C_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nr : R\n⊢ Iff (Dvd.dvd r p.content) (Dvd.dvd (Polynomial.C r) p)","decl":"theorem dvd_content_iff_C_dvd {p : R[X]} {r : R} : r ∣ p.content ↔ C r ∣ p := by\n  rw [C_dvd_iff_dvd_coeff]\n  constructor\n  · intro h i\n    apply h.trans (content_dvd_coeff _)\n  · intro h\n    rw [content, Finset.dvd_gcd_iff]\n    intro i _\n    apply h i\n\n"}
{"name":"Polynomial.C_content_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Dvd.dvd (Polynomial.C p.content) p","decl":"theorem C_content_dvd (p : R[X]) : C p.content ∣ p :=\n  dvd_content_iff_C_dvd.1 dvd_rfl\n\n"}
{"name":"Polynomial.isPrimitive_iff_content_eq_one","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Iff p.IsPrimitive (Eq p.content 1)","decl":"theorem isPrimitive_iff_content_eq_one {p : R[X]} : p.IsPrimitive ↔ p.content = 1 := by\n  rw [← normalize_content, normalize_eq_one, IsPrimitive]\n  simp_rw [← dvd_content_iff_C_dvd]\n  exact ⟨fun h => h p.content (dvd_refl p.content), fun h r hdvd => isUnit_of_dvd_unit hdvd h⟩\n\n"}
{"name":"Polynomial.IsPrimitive.content_eq_one","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nhp : p.IsPrimitive\n⊢ Eq p.content 1","decl":"theorem IsPrimitive.content_eq_one {p : R[X]} (hp : p.IsPrimitive) : p.content = 1 :=\n  isPrimitive_iff_content_eq_one.mp hp\n\n"}
{"name":"Polynomial.eq_C_content_mul_primPart","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq p (HMul.hMul (Polynomial.C p.content) p.primPart)","decl":"theorem eq_C_content_mul_primPart (p : R[X]) : p = C p.content * p.primPart := by\n  by_cases h : p = 0; · simp [h]\n  rw [primPart, if_neg h, ← Classical.choose_spec (C_content_dvd p)]\n\n"}
{"name":"Polynomial.primPart_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\n⊢ Eq (Polynomial.primPart 0) 1","decl":"@[simp]\ntheorem primPart_zero : primPart (0 : R[X]) = 1 :=\n  if_pos rfl\n\n"}
{"name":"Polynomial.isPrimitive_primPart","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ p.primPart.IsPrimitive","decl":"theorem isPrimitive_primPart (p : R[X]) : p.primPart.IsPrimitive := by\n  by_cases h : p = 0; · simp [h]\n  rw [← content_eq_zero_iff] at h\n  rw [isPrimitive_iff_content_eq_one]\n  apply mul_left_cancel₀ h\n  conv_rhs => rw [p.eq_C_content_mul_primPart, mul_one, content_C_mul, normalize_content]\n\n"}
{"name":"Polynomial.content_primPart","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq p.primPart.content 1","decl":"theorem content_primPart (p : R[X]) : p.primPart.content = 1 :=\n  p.isPrimitive_primPart.content_eq_one\n\n"}
{"name":"Polynomial.primPart_ne_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Ne p.primPart 0","decl":"theorem primPart_ne_zero (p : R[X]) : p.primPart ≠ 0 :=\n  p.isPrimitive_primPart.ne_zero\n\n"}
{"name":"Polynomial.natDegree_primPart","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Eq p.primPart.natDegree p.natDegree","decl":"theorem natDegree_primPart (p : R[X]) : p.primPart.natDegree = p.natDegree := by\n  by_cases h : C p.content = 0\n  · rw [C_eq_zero, content_eq_zero_iff] at h\n    simp [h]\n  conv_rhs =>\n    rw [p.eq_C_content_mul_primPart, natDegree_mul h p.primPart_ne_zero, natDegree_C, zero_add]\n\n"}
{"name":"Polynomial.IsPrimitive.primPart_eq","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nhp : p.IsPrimitive\n⊢ Eq p.primPart p","decl":"@[simp]\ntheorem IsPrimitive.primPart_eq {p : R[X]} (hp : p.IsPrimitive) : p.primPart = p := by\n  rw [← one_mul p.primPart, ← C_1, ← hp.content_eq_one, ← p.eq_C_content_mul_primPart]\n\n"}
{"name":"Polynomial.isUnit_primPart_C","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\nr : R\n⊢ IsUnit (Polynomial.C r).primPart","decl":"theorem isUnit_primPart_C (r : R) : IsUnit (C r).primPart := by\n  by_cases h0 : r = 0\n  · simp [h0]\n  unfold IsUnit\n  refine\n    ⟨⟨C ↑(normUnit r)⁻¹, C ↑(normUnit r), by rw [← RingHom.map_mul, Units.inv_mul, C_1], by\n        rw [← RingHom.map_mul, Units.mul_inv, C_1]⟩,\n      ?_⟩\n  rw [← normalize_eq_zero, ← C_eq_zero] at h0\n  apply mul_left_cancel₀ h0\n  conv_rhs => rw [← content_C, ← (C r).eq_C_content_mul_primPart]\n  simp only [Units.val_mk, normalize_apply, RingHom.map_mul]\n  rw [mul_assoc, ← RingHom.map_mul, Units.mul_inv, C_1, mul_one]\n\n"}
{"name":"Polynomial.primPart_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\n⊢ Dvd.dvd p.primPart p","decl":"theorem primPart_dvd (p : R[X]) : p.primPart ∣ p :=\n  Dvd.intro_left (C p.content) p.eq_C_content_mul_primPart.symm\n\n"}
{"name":"Polynomial.aeval_primPart_eq_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : NormalizedGCDMonoid R\nS : Type u_2\ninst✝³ : Ring S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : NoZeroSMulDivisors R S\np : Polynomial R\ns : S\nhpzero : Ne p 0\nhp : Eq ((Polynomial.aeval s) p) 0\n⊢ Eq ((Polynomial.aeval s) p.primPart) 0","decl":"theorem aeval_primPart_eq_zero {S : Type*} [Ring S] [IsDomain S] [Algebra R S]\n    [NoZeroSMulDivisors R S] {p : R[X]} {s : S} (hpzero : p ≠ 0) (hp : aeval s p = 0) :\n    aeval s p.primPart = 0 := by\n  rw [eq_C_content_mul_primPart p, map_mul, aeval_C] at hp\n  have hcont : p.content ≠ 0 := fun h => hpzero (content_eq_zero_iff.1 h)\n  replace hcont := Function.Injective.ne (NoZeroSMulDivisors.algebraMap_injective R S) hcont\n  rw [map_zero] at hcont\n  exact eq_zero_of_ne_zero_of_mul_left_eq_zero hcont hp\n\n"}
{"name":"Polynomial.eval₂_primPart_eq_zero","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\ninst✝² : NormalizedGCDMonoid R\nS : Type u_2\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nf : RingHom R S\nhinj : Function.Injective ⇑f\np : Polynomial R\ns : S\nhpzero : Ne p 0\nhp : Eq (Polynomial.eval₂ f s p) 0\n⊢ Eq (Polynomial.eval₂ f s p.primPart) 0","decl":"theorem eval₂_primPart_eq_zero {S : Type*} [CommRing S] [IsDomain S] {f : R →+* S}\n    (hinj : Function.Injective f) {p : R[X]} {s : S} (hpzero : p ≠ 0) (hp : eval₂ f s p = 0) :\n    eval₂ f s p.primPart = 0 := by\n  rw [eq_C_content_mul_primPart p, eval₂_mul, eval₂_C] at hp\n  have hcont : p.content ≠ 0 := fun h => hpzero (content_eq_zero_iff.1 h)\n  replace hcont := Function.Injective.ne hinj hcont\n  rw [map_zero] at hcont\n  exact eq_zero_of_ne_zero_of_mul_left_eq_zero hcont hp\n\n"}
{"name":"Polynomial.gcd_content_eq_of_dvd_sub","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\na : R\np q : Polynomial R\nh : Dvd.dvd (Polynomial.C a) (HSub.hSub p q)\n⊢ Eq (GCDMonoid.gcd a p.content) (GCDMonoid.gcd a q.content)","decl":"theorem gcd_content_eq_of_dvd_sub {a : R} {p q : R[X]} (h : C a ∣ p - q) :\n    GCDMonoid.gcd a p.content = GCDMonoid.gcd a q.content := by\n  rw [content_eq_gcd_range_of_lt p (max p.natDegree q.natDegree).succ\n      (lt_of_le_of_lt (le_max_left _ _) (Nat.lt_succ_self _))]\n  rw [content_eq_gcd_range_of_lt q (max p.natDegree q.natDegree).succ\n      (lt_of_le_of_lt (le_max_right _ _) (Nat.lt_succ_self _))]\n  apply Finset.gcd_eq_of_dvd_sub\n  intro x _\n  cases' h with w hw\n  use w.coeff x\n  rw [← coeff_sub, hw, coeff_C_mul]\n\n"}
{"name":"Polynomial.content_mul_aux","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\n⊢ Eq (GCDMonoid.gcd (HMul.hMul p q).eraseLead.content p.leadingCoeff) (GCDMonoid.gcd (HMul.hMul p.eraseLead q).content p.leadingCoeff)","decl":"theorem content_mul_aux {p q : R[X]} :\n    GCDMonoid.gcd (p * q).eraseLead.content p.leadingCoeff =\n      GCDMonoid.gcd (p.eraseLead * q).content p.leadingCoeff := by\n  rw [gcd_comm (content _) _, gcd_comm (content _) _]\n  apply gcd_content_eq_of_dvd_sub\n  rw [← self_sub_C_mul_X_pow, ← self_sub_C_mul_X_pow, sub_mul, sub_sub, add_comm, sub_add,\n    sub_sub_cancel, leadingCoeff_mul, RingHom.map_mul, mul_assoc, mul_assoc]\n  apply dvd_sub (Dvd.intro _ rfl) (Dvd.intro _ rfl)\n\n"}
{"name":"Polynomial.content_mul","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\n⊢ Eq (HMul.hMul p q).content (HMul.hMul p.content q.content)","decl":"@[simp]\ntheorem content_mul {p q : R[X]} : (p * q).content = p.content * q.content := by\n  classical\n    suffices h :\n        ∀ (n : ℕ) (p q : R[X]), (p * q).degree < n → (p * q).content = p.content * q.content by\n      apply h\n      apply lt_of_le_of_lt degree_le_natDegree (WithBot.coe_lt_coe.2 (Nat.lt_succ_self _))\n    intro n\n    induction' n with n ih\n    · intro p q hpq\n      rw [Nat.cast_zero,\n        Nat.WithBot.lt_zero_iff, degree_eq_bot, mul_eq_zero] at hpq\n      rcases hpq with (rfl | rfl) <;> simp\n    intro p q hpq\n    by_cases p0 : p = 0\n    · simp [p0]\n    by_cases q0 : q = 0\n    · simp [q0]\n    rw [degree_eq_natDegree (mul_ne_zero p0 q0), Nat.cast_lt,\n      Nat.lt_succ_iff_lt_or_eq, ← Nat.cast_lt (α := WithBot ℕ),\n      ← degree_eq_natDegree (mul_ne_zero p0 q0), natDegree_mul p0 q0] at hpq\n    rcases hpq with (hlt | heq)\n    · apply ih _ _ hlt\n    rw [← p.natDegree_primPart, ← q.natDegree_primPart, ← Nat.cast_inj (R := WithBot ℕ),\n      Nat.cast_add, ← degree_eq_natDegree p.primPart_ne_zero,\n      ← degree_eq_natDegree q.primPart_ne_zero] at heq\n    rw [p.eq_C_content_mul_primPart, q.eq_C_content_mul_primPart]\n    suffices h : (q.primPart * p.primPart).content = 1 by\n      rw [mul_assoc, content_C_mul, content_C_mul, mul_comm p.primPart, mul_assoc, content_C_mul,\n        content_C_mul, h, mul_one, content_primPart, content_primPart, mul_one, mul_one]\n    rw [← normalize_content, normalize_eq_one, isUnit_iff_dvd_one,\n      content_eq_gcd_leadingCoeff_content_eraseLead, leadingCoeff_mul, gcd_comm]\n    apply (gcd_mul_dvd_mul_gcd _ _ _).trans\n    rw [content_mul_aux, ih, content_primPart, mul_one, gcd_comm, ←\n      content_eq_gcd_leadingCoeff_content_eraseLead, content_primPart, one_mul,\n      mul_comm q.primPart, content_mul_aux, ih, content_primPart, mul_one, gcd_comm, ←\n      content_eq_gcd_leadingCoeff_content_eraseLead, content_primPart]\n    · rw [← heq, degree_mul, WithBot.add_lt_add_iff_right]\n      · apply degree_erase_lt p.primPart_ne_zero\n      · rw [Ne, degree_eq_bot]\n        apply q.primPart_ne_zero\n    · rw [mul_comm, ← heq, degree_mul, WithBot.add_lt_add_iff_left]\n      · apply degree_erase_lt q.primPart_ne_zero\n      · rw [Ne, degree_eq_bot]\n        apply p.primPart_ne_zero\n\n"}
{"name":"Polynomial.IsPrimitive.mul","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : q.IsPrimitive\n⊢ (HMul.hMul p q).IsPrimitive","decl":"theorem IsPrimitive.mul {p q : R[X]} (hp : p.IsPrimitive) (hq : q.IsPrimitive) :\n    (p * q).IsPrimitive := by\n  rw [isPrimitive_iff_content_eq_one, content_mul, hp.content_eq_one, hq.content_eq_one, mul_one]\n\n"}
{"name":"Polynomial.primPart_mul","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nh0 : Ne (HMul.hMul p q) 0\n⊢ Eq (HMul.hMul p q).primPart (HMul.hMul p.primPart q.primPart)","decl":"@[simp]\ntheorem primPart_mul {p q : R[X]} (h0 : p * q ≠ 0) :\n    (p * q).primPart = p.primPart * q.primPart := by\n  rw [Ne, ← content_eq_zero_iff, ← C_eq_zero] at h0\n  apply mul_left_cancel₀ h0\n  conv_lhs =>\n    rw [← (p * q).eq_C_content_mul_primPart, p.eq_C_content_mul_primPart,\n      q.eq_C_content_mul_primPart]\n  rw [content_mul, RingHom.map_mul]\n  ring\n\n"}
{"name":"Polynomial.IsPrimitive.dvd_primPart_iff_dvd","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : Ne q 0\n⊢ Iff (Dvd.dvd p q.primPart) (Dvd.dvd p q)","decl":"theorem IsPrimitive.dvd_primPart_iff_dvd {p q : R[X]} (hp : p.IsPrimitive) (hq : q ≠ 0) :\n    p ∣ q.primPart ↔ p ∣ q := by\n  refine ⟨fun h => h.trans (Dvd.intro_left _ q.eq_C_content_mul_primPart.symm), fun h => ?_⟩\n  rcases h with ⟨r, rfl⟩\n  apply Dvd.intro _\n  rw [primPart_mul hq, hp.primPart_eq]\n\n"}
{"name":"Polynomial.exists_primitive_lcm_of_isPrimitive","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhp : p.IsPrimitive\nhq : q.IsPrimitive\n⊢ Exists fun r => And r.IsPrimitive (∀ (s : Polynomial R), Iff (And (Dvd.dvd p s) (Dvd.dvd q s)) (Dvd.dvd r s))","decl":"theorem exists_primitive_lcm_of_isPrimitive {p q : R[X]} (hp : p.IsPrimitive) (hq : q.IsPrimitive) :\n    ∃ r : R[X], r.IsPrimitive ∧ ∀ s : R[X], p ∣ s ∧ q ∣ s ↔ r ∣ s := by\n  classical\n    have h : ∃ (n : ℕ) (r : R[X]), r.natDegree = n ∧ r.IsPrimitive ∧ p ∣ r ∧ q ∣ r :=\n      ⟨(p * q).natDegree, p * q, rfl, hp.mul hq, dvd_mul_right _ _, dvd_mul_left _ _⟩\n    rcases Nat.find_spec h with ⟨r, rdeg, rprim, pr, qr⟩\n    refine ⟨r, rprim, fun s => ⟨?_, fun rs => ⟨pr.trans rs, qr.trans rs⟩⟩⟩\n    suffices hs : ∀ (n : ℕ) (s : R[X]), s.natDegree = n → p ∣ s ∧ q ∣ s → r ∣ s from\n      hs s.natDegree s rfl\n    clear s\n    by_contra! con\n    rcases Nat.find_spec con with ⟨s, sdeg, ⟨ps, qs⟩, rs⟩\n    have s0 : s ≠ 0 := by\n      contrapose! rs\n      simp [rs]\n    have hs :=\n      Nat.find_min' h\n        ⟨_, s.natDegree_primPart, s.isPrimitive_primPart, (hp.dvd_primPart_iff_dvd s0).2 ps,\n          (hq.dvd_primPart_iff_dvd s0).2 qs⟩\n    rw [← rdeg] at hs\n    by_cases sC : s.natDegree ≤ 0\n    · rw [eq_C_of_natDegree_le_zero (le_trans hs sC), isPrimitive_iff_content_eq_one, content_C,\n        normalize_eq_one] at rprim\n      rw [eq_C_of_natDegree_le_zero (le_trans hs sC), ← dvd_content_iff_C_dvd] at rs\n      apply rs rprim.dvd\n    have hcancel := natDegree_cancelLeads_lt_of_natDegree_le_natDegree hs (lt_of_not_ge sC)\n    rw [sdeg] at hcancel\n    apply Nat.find_min con hcancel\n    refine\n      ⟨_, rfl, ⟨dvd_cancelLeads_of_dvd_of_dvd pr ps, dvd_cancelLeads_of_dvd_of_dvd qr qs⟩,\n        fun rcs => rs ?_⟩\n    rw [← rprim.dvd_primPart_iff_dvd s0]\n    rw [cancelLeads, tsub_eq_zero_iff_le.mpr hs, pow_zero, mul_one] at rcs\n    have h :=\n      dvd_add rcs (Dvd.intro_left (C (leadingCoeff s) * X ^ (natDegree s - natDegree r)) rfl)\n    have hC0 := rprim.ne_zero\n    rw [Ne, ← leadingCoeff_eq_zero, ← C_eq_zero] at hC0\n    rw [sub_add_cancel, ← rprim.dvd_primPart_iff_dvd (mul_ne_zero hC0 s0)] at h\n    rcases isUnit_primPart_C r.leadingCoeff with ⟨u, hu⟩\n    apply h.trans (Associated.symm ⟨u, _⟩).dvd\n    rw [primPart_mul (mul_ne_zero hC0 s0), hu, mul_comm]\n\n"}
{"name":"Polynomial.dvd_iff_content_dvd_content_and_primPart_dvd_primPart","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhq : Ne q 0\n⊢ Iff (Dvd.dvd p q) (And (Dvd.dvd p.content q.content) (Dvd.dvd p.primPart q.primPart))","decl":"theorem dvd_iff_content_dvd_content_and_primPart_dvd_primPart {p q : R[X]} (hq : q ≠ 0) :\n    p ∣ q ↔ p.content ∣ q.content ∧ p.primPart ∣ q.primPart := by\n  constructor <;> intro h\n  · rcases h with ⟨r, rfl⟩\n    rw [content_mul, p.isPrimitive_primPart.dvd_primPart_iff_dvd hq]\n    exact ⟨Dvd.intro _ rfl, p.primPart_dvd.trans (Dvd.intro _ rfl)⟩\n  · rw [p.eq_C_content_mul_primPart, q.eq_C_content_mul_primPart]\n    exact mul_dvd_mul (RingHom.map_dvd C h.1) h.2\n\n"}
{"name":"Polynomial.degree_gcd_le_left","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np : Polynomial R\nhp : Ne p 0\nq : Polynomial R\n⊢ LE.le (GCDMonoid.gcd p q).degree p.degree","decl":"theorem degree_gcd_le_left {p : R[X]} (hp : p ≠ 0) (q) : (gcd p q).degree ≤ p.degree := by\n  have := natDegree_le_iff_degree_le.mp (natDegree_le_of_dvd (gcd_dvd_left p q) hp)\n  rwa [degree_eq_natDegree hp]\n\n"}
{"name":"Polynomial.degree_gcd_le_right","module":"Mathlib.RingTheory.Polynomial.Content","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : NormalizedGCDMonoid R\np q : Polynomial R\nhq : Ne q 0\n⊢ LE.le (GCDMonoid.gcd p q).degree q.degree","decl":"theorem degree_gcd_le_right (p) {q : R[X]} (hq : q ≠ 0) : (gcd p q).degree ≤ q.degree := by\n  rw [gcd_comm]\n  exact degree_gcd_le_left hq p\n\n"}
