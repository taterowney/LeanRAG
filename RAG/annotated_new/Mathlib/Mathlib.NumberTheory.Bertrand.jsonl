{"name":"Bertrand.real_main_inequality","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"x : Real\nx_large : LE.le 512 x\n⊢ LE.le (HMul.hMul (HMul.hMul x (HPow.hPow (HMul.hMul 2 x) (HMul.hMul 2 x).sqrt)) (HPow.hPow 4 (HDiv.hDiv (HMul.hMul 2 x) 3))) (HPow.hPow 4 x)","decl":"/-- A refined version of the `Bertrand.main_inequality` below.\nThis is not best possible: it actually holds for 464 ≤ x.\n-/\ntheorem real_main_inequality {x : ℝ} (x_large : (512 : ℝ) ≤ x) :\n    x * (2 * x) ^ √(2 * x) * 4 ^ (2 * x / 3) ≤ 4 ^ x := by\n  let f : ℝ → ℝ := fun x => log x + √(2 * x) * log (2 * x) - log 4 / 3 * x\n  have hf' : ∀ x, 0 < x → 0 < x * (2 * x) ^ √(2 * x) / 4 ^ (x / 3) := fun x h =>\n    div_pos (mul_pos h (rpow_pos_of_pos (mul_pos two_pos h) _)) (rpow_pos_of_pos four_pos _)\n  have hf : ∀ x, 0 < x → f x = log (x * (2 * x) ^ √(2 * x) / 4 ^ (x / 3)) := by\n    intro x h5\n    have h6 := mul_pos (zero_lt_two' ℝ) h5\n    have h7 := rpow_pos_of_pos h6 (√(2 * x))\n    rw [log_div (mul_pos h5 h7).ne' (rpow_pos_of_pos four_pos _).ne', log_mul h5.ne' h7.ne',\n      log_rpow h6, log_rpow zero_lt_four, ← mul_div_right_comm, ← mul_div, mul_comm x]\n  have h5 : 0 < x := lt_of_lt_of_le (by norm_num1) x_large\n  rw [← div_le_one (rpow_pos_of_pos four_pos x), ← div_div_eq_mul_div, ← rpow_sub four_pos, ←\n    mul_div 2 x, mul_div_left_comm, ← mul_one_sub, (by norm_num1 : (1 : ℝ) - 2 / 3 = 1 / 3),\n    mul_one_div, ← log_nonpos_iff (hf' x h5).le, ← hf x h5]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): the proof was rewritten, because it was too slow\n  have h : ConcaveOn ℝ (Set.Ioi 0.5) f := by\n    apply ConcaveOn.sub\n    · apply ConcaveOn.add\n      · exact strictConcaveOn_log_Ioi.concaveOn.subset\n          (Set.Ioi_subset_Ioi (by norm_num)) (convex_Ioi 0.5)\n      convert ((strictConcaveOn_sqrt_mul_log_Ioi.concaveOn.comp_linearMap\n        ((2 : ℝ) • LinearMap.id))) using 1\n      ext x\n      simp only [Set.mem_Ioi, Set.mem_preimage, LinearMap.smul_apply,\n        LinearMap.id_coe, id_eq, smul_eq_mul]\n      rw [← mul_lt_mul_left (two_pos)]\n      norm_num1\n      rfl\n    apply ConvexOn.smul\n    · refine div_nonneg (log_nonneg (by norm_num1)) (by norm_num1)\n    · exact convexOn_id (convex_Ioi (0.5 : ℝ))\n  suffices ∃ x1 x2, 0.5 < x1 ∧ x1 < x2 ∧ x2 ≤ x ∧ 0 ≤ f x1 ∧ f x2 ≤ 0 by\n    obtain ⟨x1, x2, h1, h2, h0, h3, h4⟩ := this\n    exact (h.right_le_of_le_left'' h1 ((h1.trans h2).trans_le h0) h2 h0 (h4.trans h3)).trans h4\n  refine ⟨18, 512, by norm_num1, by norm_num1, x_large, ?_, ?_⟩\n  · have : √(2 * 18 : ℝ) = 6 := (sqrt_eq_iff_mul_self_eq_of_pos (by norm_num1)).mpr (by norm_num1)\n    rw [hf _ (by norm_num1), log_nonneg_iff (by positivity), this, one_le_div (by norm_num1)]\n    norm_num1\n  · have : √(2 * 512) = 32 :=\n      (sqrt_eq_iff_mul_self_eq_of_pos (by norm_num1)).mpr (by norm_num1)\n    rw [hf _ (by norm_num1), log_nonpos_iff (hf' _ (by norm_num1)).le, this,\n        div_le_one (by positivity)]\n    conv in 512 => equals 2 ^ 9 => norm_num1\n    conv in 2 * 512 => equals 2 ^ 10 => norm_num1\n    conv in 32 => rw [← Nat.cast_ofNat]\n    rw [rpow_natCast, ← pow_mul, ← pow_add]\n    conv in 4 => equals 2 ^ (2 : ℝ) => rw [rpow_two]; norm_num1\n    rw [← rpow_mul, ← rpow_natCast]\n    on_goal 1 => apply rpow_le_rpow_of_exponent_le\n    all_goals norm_num1\n\n"}
{"name":"bertrand_main_inequality","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nn_large : LE.le 512 n\n⊢ LE.le (HMul.hMul (HMul.hMul n (HPow.hPow (HMul.hMul 2 n) (HMul.hMul 2 n).sqrt)) (HPow.hPow 4 (HDiv.hDiv (HMul.hMul 2 n) 3))) (HPow.hPow 4 n)","decl":"/-- The inequality which contradicts Bertrand's postulate, for large enough `n`.\n-/\ntheorem bertrand_main_inequality {n : ℕ} (n_large : 512 ≤ n) :\n    n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n := by\n  rw [← @cast_le ℝ]\n  simp only [cast_add, cast_one, cast_mul, cast_pow, ← Real.rpow_natCast]\n  refine _root_.trans ?_ (Bertrand.real_main_inequality (by exact_mod_cast n_large))\n  gcongr\n  · have n2_pos : 0 < 2 * n := by positivity\n    exact mod_cast n2_pos\n  · exact_mod_cast Real.nat_sqrt_le_real_sqrt\n  · norm_num1\n  · exact cast_div_le.trans (by norm_cast)\n\n"}
{"name":"centralBinom_factorization_small","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nn_large : LT.lt 2 n\nno_prime : Not (Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n))))\n⊢ Eq n.centralBinom ((Finset.range (HAdd.hAdd (HDiv.hDiv (HMul.hMul 2 n) 3) 1)).prod fun p => HPow.hPow p (n.centralBinom.factorization p))","decl":"/-- A lemma that tells us that, in the case where Bertrand's postulate does not hold, the prime\nfactorization of the central binomial coefficient only has factors at most `2 * n / 3 + 1`.\n-/\ntheorem centralBinom_factorization_small (n : ℕ) (n_large : 2 < n)\n    (no_prime : ¬∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) :\n    centralBinom n = ∏ p ∈ Finset.range (2 * n / 3 + 1), p ^ (centralBinom n).factorization p := by\n  refine (Eq.trans ?_ n.prod_pow_factorization_centralBinom).symm\n  apply Finset.prod_subset\n  · exact Finset.range_subset.2 (add_le_add_right (Nat.div_le_self _ _) _)\n  intro x hx h2x\n  rw [Finset.mem_range, Nat.lt_succ_iff] at hx h2x\n  rw [not_le, div_lt_iff_lt_mul three_pos, mul_comm x] at h2x\n  replace no_prime := not_exists.mp no_prime x\n  rw [← and_assoc, not_and', not_and_or, not_lt] at no_prime\n  cases' no_prime hx with h h\n  · rw [factorization_eq_zero_of_non_prime n.centralBinom h, Nat.pow_zero]\n  · rw [factorization_centralBinom_of_two_mul_self_lt_three_mul n_large h h2x, Nat.pow_zero]\n\n"}
{"name":"centralBinom_le_of_no_bertrand_prime","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nn_large : LT.lt 2 n\nno_prime : Not (Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n))))\n⊢ LE.le n.centralBinom (HMul.hMul (HPow.hPow (HMul.hMul 2 n) (HMul.hMul 2 n).sqrt) (HPow.hPow 4 (HDiv.hDiv (HMul.hMul 2 n) 3)))","decl":"/-- An upper bound on the central binomial coefficient used in the proof of Bertrand's postulate.\nThe bound splits the prime factors of `centralBinom n` into those\n1. At most `sqrt (2 * n)`, which contribute at most `2 * n` for each such prime.\n2. Between `sqrt (2 * n)` and `2 * n / 3`, which contribute at most `4^(2 * n / 3)` in total.\n3. Between `2 * n / 3` and `n`, which do not exist.\n4. Between `n` and `2 * n`, which would not exist in the case where Bertrand's postulate is false.\n5. Above `2 * n`, which do not exist.\n-/\ntheorem centralBinom_le_of_no_bertrand_prime (n : ℕ) (n_large : 2 < n)\n    (no_prime : ¬∃ p : ℕ, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n) :\n    centralBinom n ≤ (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) := by\n  have n_pos : 0 < n := (Nat.zero_le _).trans_lt n_large\n  have n2_pos : 1 ≤ 2 * n := mul_pos (zero_lt_two' ℕ) n_pos\n  let S := (Finset.range (2 * n / 3 + 1)).filter Nat.Prime\n  let f x := x ^ n.centralBinom.factorization x\n  have : ∏ x ∈ S, f x = ∏ x ∈ Finset.range (2 * n / 3 + 1), f x := by\n    refine Finset.prod_filter_of_ne fun p _ h => ?_\n    contrapose! h; dsimp only [f]\n    rw [factorization_eq_zero_of_non_prime n.centralBinom h, _root_.pow_zero]\n  rw [centralBinom_factorization_small n n_large no_prime, ← this, ←\n    Finset.prod_filter_mul_prod_filter_not S (· ≤ sqrt (2 * n))]\n  apply mul_le_mul'\n  · refine (Finset.prod_le_prod' fun p _ => (?_ : f p ≤ 2 * n)).trans ?_\n    · exact pow_factorization_choose_le (mul_pos two_pos n_pos)\n    have : (Finset.Icc 1 (sqrt (2 * n))).card = sqrt (2 * n) := by rw [card_Icc, Nat.add_sub_cancel]\n    rw [Finset.prod_const]\n    refine pow_right_mono₀ n2_pos ((Finset.card_le_card fun x hx => ?_).trans this.le)\n    obtain ⟨h1, h2⟩ := Finset.mem_filter.1 hx\n    exact Finset.mem_Icc.mpr ⟨(Finset.mem_filter.1 h1).2.one_lt.le, h2⟩\n  · refine le_trans ?_ (primorial_le_4_pow (2 * n / 3))\n    refine (Finset.prod_le_prod' fun p hp => (?_ : f p ≤ p)).trans ?_\n    · obtain ⟨h1, h2⟩ := Finset.mem_filter.1 hp\n      refine (pow_right_mono₀ (Finset.mem_filter.1 h1).2.one_lt.le ?_).trans (pow_one p).le\n      exact Nat.factorization_choose_le_one (sqrt_lt'.mp <| not_le.1 h2)\n    refine Finset.prod_le_prod_of_subset_of_one_le' (Finset.filter_subset _ _) ?_\n    exact fun p hp _ => (Finset.mem_filter.1 hp).2.one_lt.le\n\n"}
{"name":"Nat.exists_prime_lt_and_le_two_mul_eventually","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nn_large : LE.le 512 n\n⊢ Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n)))","decl":"/-- Proves that **Bertrand's postulate** holds for all sufficiently large `n`.\n-/\ntheorem exists_prime_lt_and_le_two_mul_eventually (n : ℕ) (n_large : 512 ≤ n) :\n    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n := by\n  -- Assume there is no prime in the range.\n  by_contra no_prime\n  -- Then we have the above sub-exponential bound on the size of this central binomial coefficient.\n  -- We now couple this bound with an exponential lower bound on the central binomial coefficient,\n  -- yielding an inequality which we have seen is false for large enough n.\n  have H1 : n * (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) ≤ 4 ^ n := bertrand_main_inequality n_large\n  have H2 : 4 ^ n < n * n.centralBinom :=\n    Nat.four_pow_lt_mul_centralBinom n (le_trans (by norm_num1) n_large)\n  have H3 : n.centralBinom ≤ (2 * n) ^ sqrt (2 * n) * 4 ^ (2 * n / 3) :=\n    centralBinom_le_of_no_bertrand_prime n (lt_of_lt_of_le (by norm_num1) n_large) no_prime\n  rw [mul_assoc] at H1; exact not_le.2 H2 ((mul_le_mul_left' H3 n).trans H1)\n\n"}
{"name":"Nat.exists_prime_lt_and_le_two_mul_succ","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n q p : Nat\nprime_p : Nat.Prime p\ncovering : LE.le p (HMul.hMul 2 q)\nH : LT.lt n q → Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n)))\nhn : LT.lt n p\n⊢ Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n)))","decl":"/-- Proves that Bertrand's postulate holds over all positive naturals less than n by identifying a\ndescending list of primes, each no more than twice the next, such that the list contains a witness\nfor each number ≤ n.\n-/\ntheorem exists_prime_lt_and_le_two_mul_succ {n} (q) {p : ℕ} (prime_p : Nat.Prime p)\n    (covering : p ≤ 2 * q) (H : n < q → ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n) (hn : n < p) :\n    ∃ p : ℕ, p.Prime ∧ n < p ∧ p ≤ 2 * n := by\n  by_cases h : p ≤ 2 * n; · exact ⟨p, prime_p, hn, h⟩\n  exact H (lt_of_mul_lt_mul_left' (lt_of_lt_of_le (not_le.1 h) covering))\n\n"}
{"name":"Nat.exists_prime_lt_and_le_two_mul","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nhn0 : Ne n 0\n⊢ Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n)))","decl":"/--\n**Bertrand's Postulate**: For any positive natural number, there is a prime which is greater than\nit, but no more than twice as large.\n-/\ntheorem exists_prime_lt_and_le_two_mul (n : ℕ) (hn0 : n ≠ 0) :\n    ∃ p, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n := by\n  -- Split into cases whether `n` is large or small\n  cases' lt_or_le 511 n with h h\n  -- If `n` is large, apply the lemma derived from the inequalities on the central binomial\n  -- coefficient.\n  · exact exists_prime_lt_and_le_two_mul_eventually n h\n  replace h : n < 521 := h.trans_lt (by norm_num1)\n  revert h\n  -- For small `n`, supply a list of primes to cover the initial cases.\n  open Lean Elab Tactic in\n  run_tac do\n    for i in [317, 163, 83, 43, 23, 13, 7, 5, 3, 2] do\n      let i : Term := quote i\n      evalTactic <| ←\n        `(tactic| refine exists_prime_lt_and_le_two_mul_succ $i (by norm_num1) (by norm_num1) ?_)\n  exact fun h2 => ⟨2, prime_two, h2, Nat.mul_le_mul_left 2 (Nat.pos_of_ne_zero hn0)⟩\n\n"}
{"name":"Nat.bertrand","module":"Mathlib.NumberTheory.Bertrand","initialProofState":"n : Nat\nhn0 : Ne n 0\n⊢ Exists fun p => And (Nat.Prime p) (And (LT.lt n p) (LE.le p (HMul.hMul 2 n)))","decl":"alias bertrand := Nat.exists_prime_lt_and_le_two_mul\n\n"}
