{"name":"MeasureTheory.Submartingale.expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nτ π : Ω → Nat\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ 𝒢\nhf : MeasureTheory.Submartingale f 𝒢 μ\nhτ : MeasureTheory.IsStoppingTime 𝒢 τ\nhπ : MeasureTheory.IsStoppingTime 𝒢 π\nhle : LE.le τ π\nN : Nat\nhbdd : ∀ (ω : Ω), LE.le (π ω) N\n⊢ LE.le (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f τ x) (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f π x)","decl":"/-- Given a submartingale `f` and bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nexpectation of `stoppedValue f τ` is less than or equal to the expectation of `stoppedValue f π`.\nThis is the forward direction of the optional stopping theorem. -/\ntheorem Submartingale.expected_stoppedValue_mono [SigmaFiniteFiltration μ 𝒢]\n    (hf : Submartingale f 𝒢 μ) (hτ : IsStoppingTime 𝒢 τ) (hπ : IsStoppingTime 𝒢 π) (hle : τ ≤ π)\n    {N : ℕ} (hbdd : ∀ ω, π ω ≤ N) : μ[stoppedValue f τ] ≤ μ[stoppedValue f π] := by\n  rw [← sub_nonneg, ← integral_sub', stoppedValue_sub_eq_sum' hle hbdd]\n  · simp only [Finset.sum_apply]\n    have : ∀ i, MeasurableSet[𝒢 i] {ω : Ω | τ ω ≤ i ∧ i < π ω} := by\n      intro i\n      refine (hτ i).inter ?_\n      convert (hπ i).compl using 1\n      ext x\n      simp; rfl\n    rw [integral_finset_sum]\n    · refine Finset.sum_nonneg fun i _ => ?_\n      rw [integral_indicator (𝒢.le _ _ (this _)), integral_sub', sub_nonneg]\n      · exact hf.setIntegral_le (Nat.le_succ i) (this _)\n      · exact (hf.integrable _).integrableOn\n      · exact (hf.integrable _).integrableOn\n    intro i _\n    exact Integrable.indicator (Integrable.sub (hf.integrable _) (hf.integrable _))\n      (𝒢.le _ _ (this _))\n  · exact hf.integrable_stoppedValue hπ hbdd\n  · exact hf.integrable_stoppedValue hτ fun ω => le_trans (hle ω) (hbdd ω)\n\n"}
{"name":"MeasureTheory.submartingale_of_expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhadp : MeasureTheory.Adapted 𝒢 f\nhint : ∀ (i : Nat), MeasureTheory.Integrable (f i) μ\nhf : ∀ (τ π : Ω → Nat), MeasureTheory.IsStoppingTime 𝒢 τ → MeasureTheory.IsStoppingTime 𝒢 π → LE.le τ π → (Exists fun N => ∀ (ω : Ω), LE.le (π ω) N) → LE.le (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f τ x) (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f π x)\n⊢ MeasureTheory.Submartingale f 𝒢 μ","decl":"/-- The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nstopped value of `f` at `τ` has expectation smaller than its stopped value at `π`. -/\ntheorem submartingale_of_expected_stoppedValue_mono [IsFiniteMeasure μ] (hadp : Adapted 𝒢 f)\n    (hint : ∀ i, Integrable (f i) μ) (hf : ∀ τ π : Ω → ℕ, IsStoppingTime 𝒢 τ → IsStoppingTime 𝒢 π →\n      τ ≤ π → (∃ N, ∀ ω, π ω ≤ N) → μ[stoppedValue f τ] ≤ μ[stoppedValue f π]) :\n    Submartingale f 𝒢 μ := by\n  refine submartingale_of_setIntegral_le hadp hint fun i j hij s hs => ?_\n  classical\n  specialize hf (s.piecewise (fun _ => i) fun _ => j) _ (isStoppingTime_piecewise_const hij hs)\n    (isStoppingTime_const 𝒢 j) (fun x => (ite_le_sup _ _ (x ∈ s)).trans (max_eq_right hij).le)\n    ⟨j, fun _ => le_rfl⟩\n  rwa [stoppedValue_const, stoppedValue_piecewise_const,\n    integral_piecewise (𝒢.le _ _ hs) (hint _).integrableOn (hint _).integrableOn, ←\n    integral_add_compl (𝒢.le _ _ hs) (hint j), add_le_add_iff_right] at hf\n\n"}
{"name":"MeasureTheory.submartingale_iff_expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhadp : MeasureTheory.Adapted 𝒢 f\nhint : ∀ (i : Nat), MeasureTheory.Integrable (f i) μ\n⊢ Iff (MeasureTheory.Submartingale f 𝒢 μ) (∀ (τ π : Ω → Nat), MeasureTheory.IsStoppingTime 𝒢 τ → MeasureTheory.IsStoppingTime 𝒢 π → LE.le τ π → (Exists fun N => ∀ (x : Ω), LE.le (π x) N) → LE.le (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f τ x) (MeasureTheory.integral μ fun x => MeasureTheory.stoppedValue f π x))","decl":"/-- **The optional stopping theorem** (fair game theorem): an adapted integrable process `f`\nis a submartingale if and only if for all bounded stopping times `τ` and `π` such that `τ ≤ π`, the\nstopped value of `f` at `τ` has expectation smaller than its stopped value at `π`. -/\ntheorem submartingale_iff_expected_stoppedValue_mono [IsFiniteMeasure μ] (hadp : Adapted 𝒢 f)\n    (hint : ∀ i, Integrable (f i) μ) :\n    Submartingale f 𝒢 μ ↔ ∀ τ π : Ω → ℕ, IsStoppingTime 𝒢 τ → IsStoppingTime 𝒢 π →\n      τ ≤ π → (∃ N, ∀ x, π x ≤ N) → μ[stoppedValue f τ] ≤ μ[stoppedValue f π] :=\n  ⟨fun hf _ _ hτ hπ hle ⟨_, hN⟩ => hf.expected_stoppedValue_mono hτ hπ hle hN,\n    submartingale_of_expected_stoppedValue_mono hadp hint⟩\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedProcess","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\nτ : Ω → Nat\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nh : MeasureTheory.Submartingale f 𝒢 μ\nhτ : MeasureTheory.IsStoppingTime 𝒢 τ\n⊢ MeasureTheory.Submartingale (MeasureTheory.stoppedProcess f τ) 𝒢 μ","decl":"/-- The stopped process of a submartingale with respect to a stopping time is a submartingale. -/\nprotected theorem Submartingale.stoppedProcess [IsFiniteMeasure μ] (h : Submartingale f 𝒢 μ)\n    (hτ : IsStoppingTime 𝒢 τ) : Submartingale (stoppedProcess f τ) 𝒢 μ := by\n  rw [submartingale_iff_expected_stoppedValue_mono]\n  · intro σ π hσ hπ hσ_le_π hπ_bdd\n    simp_rw [stoppedValue_stoppedProcess]\n    obtain ⟨n, hπ_le_n⟩ := hπ_bdd\n    exact h.expected_stoppedValue_mono (hσ.min hτ) (hπ.min hτ)\n      (fun ω => min_le_min (hσ_le_π ω) le_rfl) fun ω => (min_le_left _ _).trans (hπ_le_n ω)\n  · exact Adapted.stoppedProcess_of_discrete h.adapted hτ\n  · exact fun i =>\n      h.integrable_stoppedValue ((isStoppingTime_const _ i).min hτ) fun ω => min_le_left _ _\n\n"}
{"name":"MeasureTheory.smul_le_stoppedValue_hitting","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhsub : MeasureTheory.Submartingale f 𝒢 μ\nε : NNReal\nn : Nat\n⊢ LE.le (HSMul.hSMul ε (μ (setOf fun ω => LE.le (↑ε) ((Finset.range (HAdd.hAdd n 1)).sup' ⋯ fun k => f k ω)))) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict (setOf fun ω => LE.le (↑ε) ((Finset.range (HAdd.hAdd n 1)).sup' ⋯ fun k => f k ω))) fun ω => MeasureTheory.stoppedValue f (MeasureTheory.hitting f (setOf fun y => LE.le (↑ε) y) 0 n) ω))","decl":"theorem smul_le_stoppedValue_hitting [IsFiniteMeasure μ] (hsub : Submartingale f 𝒢 μ) {ε : ℝ≥0}\n    (n : ℕ) : ε • μ {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω} ≤\n    ENNReal.ofReal (∫ ω in {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω},\n      stoppedValue f (hitting f {y : ℝ | ↑ε ≤ y} 0 n) ω ∂μ) := by\n  have hn : Set.Icc 0 n = {k | k ≤ n} := by ext x; simp\n  have : ∀ ω, ((ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω) →\n      (ε : ℝ) ≤ stoppedValue f (hitting f {y : ℝ | ↑ε ≤ y} 0 n) ω := by\n    intro x hx\n    simp_rw [le_sup'_iff, mem_range, Nat.lt_succ_iff] at hx\n    refine stoppedValue_hitting_mem ?_\n    simp only [Set.mem_setOf_eq, exists_prop, hn]\n    exact\n      let ⟨j, hj₁, hj₂⟩ := hx\n      ⟨j, hj₁, hj₂⟩\n  have h := setIntegral_ge_of_const_le (measurableSet_le measurable_const\n    (Finset.measurable_range_sup'' fun n _ => (hsub.stronglyMeasurable n).measurable.le (𝒢.le n)))\n      (measure_ne_top _ _) this (Integrable.integrableOn (hsub.integrable_stoppedValue\n        (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le))\n  rw [ENNReal.le_ofReal_iff_toReal_le, ENNReal.toReal_smul]\n  · exact h\n  · exact ENNReal.mul_ne_top (by simp) (measure_ne_top _ _)\n  · exact le_trans (mul_nonneg ε.coe_nonneg ENNReal.toReal_nonneg) h\n\n"}
{"name":"MeasureTheory.maximal_ineq","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Ω : Type u_1\nm0 : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n𝒢 : MeasureTheory.Filtration Nat m0\nf : Nat → Ω → Real\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhsub : MeasureTheory.Submartingale f 𝒢 μ\nhnonneg : LE.le 0 f\nε : NNReal\nn : Nat\n⊢ LE.le (HSMul.hSMul ε (μ (setOf fun ω => LE.le (↑ε) ((Finset.range (HAdd.hAdd n 1)).sup' ⋯ fun k => f k ω)))) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict (setOf fun ω => LE.le (↑ε) ((Finset.range (HAdd.hAdd n 1)).sup' ⋯ fun k => f k ω))) fun ω => f n ω))","decl":"/-- **Doob's maximal inequality**: Given a non-negative submartingale `f`, for all `ε : ℝ≥0`,\nwe have `ε • μ {ε ≤ f* n} ≤ ∫ ω in {ε ≤ f* n}, f n` where `f* n ω = max_{k ≤ n}, f k ω`.\n\nIn some literature, the Doob's maximal inequality refers to what we call Doob's Lp inequality\n(which is a corollary of this lemma and will be proved in an upcoming PR). -/\ntheorem maximal_ineq [IsFiniteMeasure μ] (hsub : Submartingale f 𝒢 μ) (hnonneg : 0 ≤ f) {ε : ℝ≥0}\n    (n : ℕ) : ε • μ {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω} ≤\n    ENNReal.ofReal (∫ ω in {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω},\n      f n ω ∂μ) := by\n  suffices ε • μ {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω} +\n      ENNReal.ofReal\n          (∫ ω in {ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε}, f n ω ∂μ) ≤\n      ENNReal.ofReal (μ[f n]) by\n    have hadd : ENNReal.ofReal (∫ ω, f n ω ∂μ) =\n      ENNReal.ofReal\n        (∫ ω in {ω | ↑ε ≤ (range (n+1)).sup' nonempty_range_succ fun k => f k ω}, f n ω ∂μ) +\n      ENNReal.ofReal\n        (∫ ω in {ω | ((range (n+1)).sup' nonempty_range_succ fun k => f k ω) < ↑ε}, f n ω ∂μ) := by\n      rw [← ENNReal.ofReal_add, ← setIntegral_union]\n      · rw [← setIntegral_univ]\n        convert rfl\n        ext ω\n        change (ε : ℝ) ≤ _ ∨ _ < (ε : ℝ) ↔ _\n        simp only [le_or_lt, Set.mem_univ]\n      · rw [disjoint_iff_inf_le]\n        rintro ω ⟨hω₁, hω₂⟩\n        change (ε : ℝ) ≤ _ at hω₁\n        change _ < (ε : ℝ) at hω₂\n        exact (not_le.2 hω₂) hω₁\n      · exact measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n          (hsub.stronglyMeasurable n).measurable.le (𝒢.le n)) measurable_const\n      exacts [(hsub.integrable _).integrableOn, (hsub.integrable _).integrableOn,\n        integral_nonneg (hnonneg _), integral_nonneg (hnonneg _)]\n    rwa [hadd, ENNReal.add_le_add_iff_right ENNReal.ofReal_ne_top] at this\n  calc\n    ε • μ {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω} +\n        ENNReal.ofReal\n          (∫ ω in {ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε}, f n ω ∂μ) ≤\n        ENNReal.ofReal\n          (∫ ω in {ω | (ε : ℝ) ≤ (range (n + 1)).sup' nonempty_range_succ fun k => f k ω},\n            stoppedValue f (hitting f {y : ℝ | ↑ε ≤ y} 0 n) ω ∂μ) +\n        ENNReal.ofReal\n          (∫ ω in {ω | ((range (n + 1)).sup' nonempty_range_succ fun k => f k ω) < ε},\n            stoppedValue f (hitting f {y : ℝ | ↑ε ≤ y} 0 n) ω ∂μ) := by\n      refine add_le_add (smul_le_stoppedValue_hitting hsub _)\n        (ENNReal.ofReal_le_ofReal (setIntegral_mono_on (hsub.integrable n).integrableOn\n          (Integrable.integrableOn (hsub.integrable_stoppedValue\n            (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le))\n              (measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n                (hsub.stronglyMeasurable n).measurable.le (𝒢.le n)) measurable_const) ?_))\n      intro ω hω\n      rw [Set.mem_setOf_eq] at hω\n      have : hitting f {y : ℝ | ↑ε ≤ y} 0 n ω = n := by\n        classical simp only [hitting, Set.mem_setOf_eq, exists_prop, Pi.natCast_def, Nat.cast_id,\n          ite_eq_right_iff, forall_exists_index, and_imp]\n        intro m hm hεm\n        exact False.elim\n          ((not_le.2 hω) ((le_sup'_iff _).2 ⟨m, mem_range.2 (Nat.lt_succ_of_le hm.2), hεm⟩))\n      simp_rw [stoppedValue, this, le_rfl]\n    _ = ENNReal.ofReal (∫ ω, stoppedValue f (hitting f {y : ℝ | ↑ε ≤ y} 0 n) ω ∂μ) := by\n      rw [← ENNReal.ofReal_add, ← setIntegral_union]\n      · rw [← setIntegral_univ (μ := μ)]\n        convert rfl\n        ext ω\n        change _ ↔ (ε : ℝ) ≤ _ ∨ _ < (ε : ℝ)\n        simp only [le_or_lt, Set.mem_univ]\n      · rw [disjoint_iff_inf_le]\n        rintro ω ⟨hω₁, hω₂⟩\n        change (ε : ℝ) ≤ _ at hω₁\n        change _ < (ε : ℝ) at hω₂\n        exact (not_le.2 hω₂) hω₁\n      · exact measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n          (hsub.stronglyMeasurable n).measurable.le (𝒢.le n)) measurable_const\n      · exact Integrable.integrableOn (hsub.integrable_stoppedValue\n          (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le)\n      · exact Integrable.integrableOn (hsub.integrable_stoppedValue\n          (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le)\n      exacts [integral_nonneg fun x => hnonneg _ _, integral_nonneg fun x => hnonneg _ _]\n    _ ≤ ENNReal.ofReal (μ[f n]) := by\n      refine ENNReal.ofReal_le_ofReal ?_\n      rw [← stoppedValue_const f n]\n      exact hsub.expected_stoppedValue_mono (hitting_isStoppingTime hsub.adapted measurableSet_Ici)\n        (isStoppingTime_const _ _) (fun ω => hitting_le ω) (fun _ => le_refl n)\n\n"}
