{"name":"MeasureTheory.Submartingale.expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nÏ„ Ï€ : Î© â†’ Nat\ninstâœ : MeasureTheory.SigmaFiniteFiltration Î¼ ğ’¢\nhf : MeasureTheory.Submartingale f ğ’¢ Î¼\nhÏ„ : MeasureTheory.IsStoppingTime ğ’¢ Ï„\nhÏ€ : MeasureTheory.IsStoppingTime ğ’¢ Ï€\nhle : LE.le Ï„ Ï€\nN : Nat\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï€ Ï‰) N\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï„ x) (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï€ x)","decl":"/-- Given a submartingale `f` and bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nexpectation of `stoppedValue f Ï„` is less than or equal to the expectation of `stoppedValue f Ï€`.\nThis is the forward direction of the optional stopping theorem. -/\ntheorem Submartingale.expected_stoppedValue_mono [SigmaFiniteFiltration Î¼ ğ’¢]\n    (hf : Submartingale f ğ’¢ Î¼) (hÏ„ : IsStoppingTime ğ’¢ Ï„) (hÏ€ : IsStoppingTime ğ’¢ Ï€) (hle : Ï„ â‰¤ Ï€)\n    {N : â„•} (hbdd : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) : Î¼[stoppedValue f Ï„] â‰¤ Î¼[stoppedValue f Ï€] := by\n  rw [â† sub_nonneg, â† integral_sub', stoppedValue_sub_eq_sum' hle hbdd]\n  Â· simp only [Finset.sum_apply]\n    have : âˆ€ i, MeasurableSet[ğ’¢ i] {Ï‰ : Î© | Ï„ Ï‰ â‰¤ i âˆ§ i < Ï€ Ï‰} := by\n      intro i\n      refine (hÏ„ i).inter ?_\n      convert (hÏ€ i).compl using 1\n      ext x\n      simp; rfl\n    rw [integral_finset_sum]\n    Â· refine Finset.sum_nonneg fun i _ => ?_\n      rw [integral_indicator (ğ’¢.le _ _ (this _)), integral_sub', sub_nonneg]\n      Â· exact hf.setIntegral_le (Nat.le_succ i) (this _)\n      Â· exact (hf.integrable _).integrableOn\n      Â· exact (hf.integrable _).integrableOn\n    intro i _\n    exact Integrable.indicator (Integrable.sub (hf.integrable _) (hf.integrable _))\n      (ğ’¢.le _ _ (this _))\n  Â· exact hf.integrable_stoppedValue hÏ€ hbdd\n  Â· exact hf.integrable_stoppedValue hÏ„ fun Ï‰ => le_trans (hle Ï‰) (hbdd Ï‰)\n\n"}
{"name":"MeasureTheory.submartingale_of_expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhadp : MeasureTheory.Adapted ğ’¢ f\nhint : âˆ€ (i : Nat), MeasureTheory.Integrable (f i) Î¼\nhf : âˆ€ (Ï„ Ï€ : Î© â†’ Nat), MeasureTheory.IsStoppingTime ğ’¢ Ï„ â†’ MeasureTheory.IsStoppingTime ğ’¢ Ï€ â†’ LE.le Ï„ Ï€ â†’ (Exists fun N => âˆ€ (Ï‰ : Î©), LE.le (Ï€ Ï‰) N) â†’ LE.le (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï„ x) (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï€ x)\nâŠ¢ MeasureTheory.Submartingale f ğ’¢ Î¼","decl":"/-- The converse direction of the optional stopping theorem, i.e. an adapted integrable process `f`\nis a submartingale if for all bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nstopped value of `f` at `Ï„` has expectation smaller than its stopped value at `Ï€`. -/\ntheorem submartingale_of_expected_stoppedValue_mono [IsFiniteMeasure Î¼] (hadp : Adapted ğ’¢ f)\n    (hint : âˆ€ i, Integrable (f i) Î¼) (hf : âˆ€ Ï„ Ï€ : Î© â†’ â„•, IsStoppingTime ğ’¢ Ï„ â†’ IsStoppingTime ğ’¢ Ï€ â†’\n      Ï„ â‰¤ Ï€ â†’ (âˆƒ N, âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) â†’ Î¼[stoppedValue f Ï„] â‰¤ Î¼[stoppedValue f Ï€]) :\n    Submartingale f ğ’¢ Î¼ := by\n  refine submartingale_of_setIntegral_le hadp hint fun i j hij s hs => ?_\n  classical\n  specialize hf (s.piecewise (fun _ => i) fun _ => j) _ (isStoppingTime_piecewise_const hij hs)\n    (isStoppingTime_const ğ’¢ j) (fun x => (ite_le_sup _ _ (x âˆˆ s)).trans (max_eq_right hij).le)\n    âŸ¨j, fun _ => le_rflâŸ©\n  rwa [stoppedValue_const, stoppedValue_piecewise_const,\n    integral_piecewise (ğ’¢.le _ _ hs) (hint _).integrableOn (hint _).integrableOn, â†\n    integral_add_compl (ğ’¢.le _ _ hs) (hint j), add_le_add_iff_right] at hf\n\n"}
{"name":"MeasureTheory.submartingale_iff_expected_stoppedValue_mono","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhadp : MeasureTheory.Adapted ğ’¢ f\nhint : âˆ€ (i : Nat), MeasureTheory.Integrable (f i) Î¼\nâŠ¢ Iff (MeasureTheory.Submartingale f ğ’¢ Î¼) (âˆ€ (Ï„ Ï€ : Î© â†’ Nat), MeasureTheory.IsStoppingTime ğ’¢ Ï„ â†’ MeasureTheory.IsStoppingTime ğ’¢ Ï€ â†’ LE.le Ï„ Ï€ â†’ (Exists fun N => âˆ€ (x : Î©), LE.le (Ï€ x) N) â†’ LE.le (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï„ x) (MeasureTheory.integral Î¼ fun x => MeasureTheory.stoppedValue f Ï€ x))","decl":"/-- **The optional stopping theorem** (fair game theorem): an adapted integrable process `f`\nis a submartingale if and only if for all bounded stopping times `Ï„` and `Ï€` such that `Ï„ â‰¤ Ï€`, the\nstopped value of `f` at `Ï„` has expectation smaller than its stopped value at `Ï€`. -/\ntheorem submartingale_iff_expected_stoppedValue_mono [IsFiniteMeasure Î¼] (hadp : Adapted ğ’¢ f)\n    (hint : âˆ€ i, Integrable (f i) Î¼) :\n    Submartingale f ğ’¢ Î¼ â†” âˆ€ Ï„ Ï€ : Î© â†’ â„•, IsStoppingTime ğ’¢ Ï„ â†’ IsStoppingTime ğ’¢ Ï€ â†’\n      Ï„ â‰¤ Ï€ â†’ (âˆƒ N, âˆ€ x, Ï€ x â‰¤ N) â†’ Î¼[stoppedValue f Ï„] â‰¤ Î¼[stoppedValue f Ï€] :=\n  âŸ¨fun hf _ _ hÏ„ hÏ€ hle âŸ¨_, hNâŸ© => hf.expected_stoppedValue_mono hÏ„ hÏ€ hle hN,\n    submartingale_of_expected_stoppedValue_mono hadp hintâŸ©\n\n"}
{"name":"MeasureTheory.Submartingale.stoppedProcess","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\nÏ„ : Î© â†’ Nat\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nh : MeasureTheory.Submartingale f ğ’¢ Î¼\nhÏ„ : MeasureTheory.IsStoppingTime ğ’¢ Ï„\nâŠ¢ MeasureTheory.Submartingale (MeasureTheory.stoppedProcess f Ï„) ğ’¢ Î¼","decl":"/-- The stopped process of a submartingale with respect to a stopping time is a submartingale. -/\nprotected theorem Submartingale.stoppedProcess [IsFiniteMeasure Î¼] (h : Submartingale f ğ’¢ Î¼)\n    (hÏ„ : IsStoppingTime ğ’¢ Ï„) : Submartingale (stoppedProcess f Ï„) ğ’¢ Î¼ := by\n  rw [submartingale_iff_expected_stoppedValue_mono]\n  Â· intro Ïƒ Ï€ hÏƒ hÏ€ hÏƒ_le_Ï€ hÏ€_bdd\n    simp_rw [stoppedValue_stoppedProcess]\n    obtain âŸ¨n, hÏ€_le_nâŸ© := hÏ€_bdd\n    exact h.expected_stoppedValue_mono (hÏƒ.min hÏ„) (hÏ€.min hÏ„)\n      (fun Ï‰ => min_le_min (hÏƒ_le_Ï€ Ï‰) le_rfl) fun Ï‰ => (min_le_left _ _).trans (hÏ€_le_n Ï‰)\n  Â· exact Adapted.stoppedProcess_of_discrete h.adapted hÏ„\n  Â· exact fun i =>\n      h.integrable_stoppedValue ((isStoppingTime_const _ i).min hÏ„) fun Ï‰ => min_le_left _ _\n\n"}
{"name":"MeasureTheory.smul_le_stoppedValue_hitting","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhsub : MeasureTheory.Submartingale f ğ’¢ Î¼\nÎµ : NNReal\nn : Nat\nâŠ¢ LE.le (HSMul.hSMul Îµ (Î¼ (setOf fun Ï‰ => LE.le (â†‘Îµ) ((Finset.range (HAdd.hAdd n 1)).sup' â‹¯ fun k => f k Ï‰)))) (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict (setOf fun Ï‰ => LE.le (â†‘Îµ) ((Finset.range (HAdd.hAdd n 1)).sup' â‹¯ fun k => f k Ï‰))) fun Ï‰ => MeasureTheory.stoppedValue f (MeasureTheory.hitting f (setOf fun y => LE.le (â†‘Îµ) y) 0 n) Ï‰))","decl":"theorem smul_le_stoppedValue_hitting [IsFiniteMeasure Î¼] (hsub : Submartingale f ğ’¢ Î¼) {Îµ : â„â‰¥0}\n    (n : â„•) : Îµ â€¢ Î¼ {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰} â‰¤\n    ENNReal.ofReal (âˆ« Ï‰ in {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰},\n      stoppedValue f (hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n) Ï‰ âˆ‚Î¼) := by\n  have hn : Set.Icc 0 n = {k | k â‰¤ n} := by ext x; simp\n  have : âˆ€ Ï‰, ((Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) â†’\n      (Îµ : â„) â‰¤ stoppedValue f (hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n) Ï‰ := by\n    intro x hx\n    simp_rw [le_sup'_iff, mem_range, Nat.lt_succ_iff] at hx\n    refine stoppedValue_hitting_mem ?_\n    simp only [Set.mem_setOf_eq, exists_prop, hn]\n    exact\n      let âŸ¨j, hjâ‚, hjâ‚‚âŸ© := hx\n      âŸ¨j, hjâ‚, hjâ‚‚âŸ©\n  have h := setIntegral_ge_of_const_le (measurableSet_le measurable_const\n    (Finset.measurable_range_sup'' fun n _ => (hsub.stronglyMeasurable n).measurable.le (ğ’¢.le n)))\n      (measure_ne_top _ _) this (Integrable.integrableOn (hsub.integrable_stoppedValue\n        (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le))\n  rw [ENNReal.le_ofReal_iff_toReal_le, ENNReal.toReal_smul]\n  Â· exact h\n  Â· exact ENNReal.mul_ne_top (by simp) (measure_ne_top _ _)\n  Â· exact le_trans (mul_nonneg Îµ.coe_nonneg ENNReal.toReal_nonneg) h\n\n"}
{"name":"MeasureTheory.maximal_ineq","module":"Mathlib.Probability.Martingale.OptionalStopping","initialProofState":"Î© : Type u_1\nm0 : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nğ’¢ : MeasureTheory.Filtration Nat m0\nf : Nat â†’ Î© â†’ Real\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhsub : MeasureTheory.Submartingale f ğ’¢ Î¼\nhnonneg : LE.le 0 f\nÎµ : NNReal\nn : Nat\nâŠ¢ LE.le (HSMul.hSMul Îµ (Î¼ (setOf fun Ï‰ => LE.le (â†‘Îµ) ((Finset.range (HAdd.hAdd n 1)).sup' â‹¯ fun k => f k Ï‰)))) (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict (setOf fun Ï‰ => LE.le (â†‘Îµ) ((Finset.range (HAdd.hAdd n 1)).sup' â‹¯ fun k => f k Ï‰))) fun Ï‰ => f n Ï‰))","decl":"/-- **Doob's maximal inequality**: Given a non-negative submartingale `f`, for all `Îµ : â„â‰¥0`,\nwe have `Îµ â€¢ Î¼ {Îµ â‰¤ f* n} â‰¤ âˆ« Ï‰ in {Îµ â‰¤ f* n}, f n` where `f* n Ï‰ = max_{k â‰¤ n}, f k Ï‰`.\n\nIn some literature, the Doob's maximal inequality refers to what we call Doob's Lp inequality\n(which is a corollary of this lemma and will be proved in an upcoming PR). -/\ntheorem maximal_ineq [IsFiniteMeasure Î¼] (hsub : Submartingale f ğ’¢ Î¼) (hnonneg : 0 â‰¤ f) {Îµ : â„â‰¥0}\n    (n : â„•) : Îµ â€¢ Î¼ {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰} â‰¤\n    ENNReal.ofReal (âˆ« Ï‰ in {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰},\n      f n Ï‰ âˆ‚Î¼) := by\n  suffices Îµ â€¢ Î¼ {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰} +\n      ENNReal.ofReal\n          (âˆ« Ï‰ in {Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ}, f n Ï‰ âˆ‚Î¼) â‰¤\n      ENNReal.ofReal (Î¼[f n]) by\n    have hadd : ENNReal.ofReal (âˆ« Ï‰, f n Ï‰ âˆ‚Î¼) =\n      ENNReal.ofReal\n        (âˆ« Ï‰ in {Ï‰ | â†‘Îµ â‰¤ (range (n+1)).sup' nonempty_range_succ fun k => f k Ï‰}, f n Ï‰ âˆ‚Î¼) +\n      ENNReal.ofReal\n        (âˆ« Ï‰ in {Ï‰ | ((range (n+1)).sup' nonempty_range_succ fun k => f k Ï‰) < â†‘Îµ}, f n Ï‰ âˆ‚Î¼) := by\n      rw [â† ENNReal.ofReal_add, â† setIntegral_union]\n      Â· rw [â† setIntegral_univ]\n        convert rfl\n        ext Ï‰\n        change (Îµ : â„) â‰¤ _ âˆ¨ _ < (Îµ : â„) â†” _\n        simp only [le_or_lt, Set.mem_univ]\n      Â· rw [disjoint_iff_inf_le]\n        rintro Ï‰ âŸ¨hÏ‰â‚, hÏ‰â‚‚âŸ©\n        change (Îµ : â„) â‰¤ _ at hÏ‰â‚\n        change _ < (Îµ : â„) at hÏ‰â‚‚\n        exact (not_le.2 hÏ‰â‚‚) hÏ‰â‚\n      Â· exact measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n          (hsub.stronglyMeasurable n).measurable.le (ğ’¢.le n)) measurable_const\n      exacts [(hsub.integrable _).integrableOn, (hsub.integrable _).integrableOn,\n        integral_nonneg (hnonneg _), integral_nonneg (hnonneg _)]\n    rwa [hadd, ENNReal.add_le_add_iff_right ENNReal.ofReal_ne_top] at this\n  calc\n    Îµ â€¢ Î¼ {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰} +\n        ENNReal.ofReal\n          (âˆ« Ï‰ in {Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ}, f n Ï‰ âˆ‚Î¼) â‰¤\n        ENNReal.ofReal\n          (âˆ« Ï‰ in {Ï‰ | (Îµ : â„) â‰¤ (range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰},\n            stoppedValue f (hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n) Ï‰ âˆ‚Î¼) +\n        ENNReal.ofReal\n          (âˆ« Ï‰ in {Ï‰ | ((range (n + 1)).sup' nonempty_range_succ fun k => f k Ï‰) < Îµ},\n            stoppedValue f (hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n) Ï‰ âˆ‚Î¼) := by\n      refine add_le_add (smul_le_stoppedValue_hitting hsub _)\n        (ENNReal.ofReal_le_ofReal (setIntegral_mono_on (hsub.integrable n).integrableOn\n          (Integrable.integrableOn (hsub.integrable_stoppedValue\n            (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le))\n              (measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n                (hsub.stronglyMeasurable n).measurable.le (ğ’¢.le n)) measurable_const) ?_))\n      intro Ï‰ hÏ‰\n      rw [Set.mem_setOf_eq] at hÏ‰\n      have : hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n Ï‰ = n := by\n        classical simp only [hitting, Set.mem_setOf_eq, exists_prop, Pi.natCast_def, Nat.cast_id,\n          ite_eq_right_iff, forall_exists_index, and_imp]\n        intro m hm hÎµm\n        exact False.elim\n          ((not_le.2 hÏ‰) ((le_sup'_iff _).2 âŸ¨m, mem_range.2 (Nat.lt_succ_of_le hm.2), hÎµmâŸ©))\n      simp_rw [stoppedValue, this, le_rfl]\n    _ = ENNReal.ofReal (âˆ« Ï‰, stoppedValue f (hitting f {y : â„ | â†‘Îµ â‰¤ y} 0 n) Ï‰ âˆ‚Î¼) := by\n      rw [â† ENNReal.ofReal_add, â† setIntegral_union]\n      Â· rw [â† setIntegral_univ (Î¼ := Î¼)]\n        convert rfl\n        ext Ï‰\n        change _ â†” (Îµ : â„) â‰¤ _ âˆ¨ _ < (Îµ : â„)\n        simp only [le_or_lt, Set.mem_univ]\n      Â· rw [disjoint_iff_inf_le]\n        rintro Ï‰ âŸ¨hÏ‰â‚, hÏ‰â‚‚âŸ©\n        change (Îµ : â„) â‰¤ _ at hÏ‰â‚\n        change _ < (Îµ : â„) at hÏ‰â‚‚\n        exact (not_le.2 hÏ‰â‚‚) hÏ‰â‚\n      Â· exact measurableSet_lt (Finset.measurable_range_sup'' fun n _ =>\n          (hsub.stronglyMeasurable n).measurable.le (ğ’¢.le n)) measurable_const\n      Â· exact Integrable.integrableOn (hsub.integrable_stoppedValue\n          (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le)\n      Â· exact Integrable.integrableOn (hsub.integrable_stoppedValue\n          (hitting_isStoppingTime hsub.adapted measurableSet_Ici) hitting_le)\n      exacts [integral_nonneg fun x => hnonneg _ _, integral_nonneg fun x => hnonneg _ _]\n    _ â‰¤ ENNReal.ofReal (Î¼[f n]) := by\n      refine ENNReal.ofReal_le_ofReal ?_\n      rw [â† stoppedValue_const f n]\n      exact hsub.expected_stoppedValue_mono (hitting_isStoppingTime hsub.adapted measurableSet_Ici)\n        (isStoppingTime_const _ _) (fun Ï‰ => hitting_le Ï‰) (fun _ => le_refl n)\n\n"}
