{"name":"NormedSpace.norm_smul_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝¹ : NormedField 𝕜\ninst✝ : SeminormedAddCommGroup E\nself : NormedSpace 𝕜 E\na : 𝕜\nb : E\n⊢ LE.le (Norm.norm (HSMul.hSMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed space over a normed field is a vector space endowed with a norm which satisfies the\nequality `‖c • x‖ = ‖c‖ ‖x‖`. We require only `‖c • x‖ ≤ ‖c‖ ‖x‖` in the definition, then prove\n`‖c • x‖ = ‖c‖ ‖x‖` in `norm_smul`.\n\nNote that since this requires `SeminormedAddCommGroup` and not `NormedAddCommGroup`, this\ntypeclass can be used for \"semi normed spaces\" too, just as `Module` can be used for\n\"semi modules\". -/\nclass NormedSpace (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [SeminormedAddCommGroup E]\n    extends Module 𝕜 E where\n  norm_smul_le : ∀ (a : 𝕜) (b : E), ‖a • b‖ ≤ ‖a‖ * ‖b‖\n\n"}
{"name":"NormedSpace.boundedSMul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ BoundedSMul 𝕜 E","decl":"instance (priority := 100) NormedSpace.boundedSMul [NormedSpace 𝕜 E] : BoundedSMul 𝕜 E :=\n  BoundedSMul.of_norm_smul_le NormedSpace.norm_smul_le\n\n"}
{"name":"NormedField.to_boundedSMul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\ninst✝ : NormedField 𝕜\n⊢ BoundedSMul 𝕜 𝕜","decl":"instance NormedField.to_boundedSMul : BoundedSMul 𝕜 𝕜 :=\n  NormedSpace.boundedSMul\n\n"}
{"name":"norm_zsmul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nn : Int\nx : E\n⊢ Eq (Norm.norm (HSMul.hSMul n x)) (HMul.hMul (Norm.norm ↑n) (Norm.norm x))","decl":"variable (𝕜) in\ntheorem norm_zsmul (n : ℤ) (x : E) : ‖n • x‖ = ‖(n : 𝕜)‖ * ‖x‖ := by\n  rw [← norm_smul, ← Int.smul_one_eq_cast, smul_assoc, one_smul]\n\n"}
{"name":"eventually_nhds_norm_smul_sub_lt","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nx : E\nε : Real\nh : LT.lt 0 ε\n⊢ Filter.Eventually (fun y => LT.lt (Norm.norm (HSMul.hSMul c (HSub.hSub y x))) ε) (nhds x)","decl":"theorem eventually_nhds_norm_smul_sub_lt (c : 𝕜) (x : E) {ε : ℝ} (h : 0 < ε) :\n    ∀ᶠ y in 𝓝 x, ‖c • (y - x)‖ < ε :=\n  have : Tendsto (fun y ↦ ‖c • (y - x)‖) (𝓝 x) (𝓝 0) :=\n    Continuous.tendsto' (by fun_prop) _ _ (by simp)\n  this.eventually (gt_mem_nhds h)\n\n"}
{"name":"Filter.Tendsto.zero_smul_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nα : Type u_5\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : α → 𝕜\ng : α → E\nl : Filter α\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.zero_smul_isBoundedUnder_le {f : α → 𝕜} {g : α → E} {l : Filter α}\n    (hf : Tendsto f l (𝓝 0)) (hg : IsBoundedUnder (· ≤ ·) l (Norm.norm ∘ g)) :\n    Tendsto (fun x => f x • g x) l (𝓝 0) :=\n  hf.op_zero_isBoundedUnder_le hg (· • ·) norm_smul_le\n\n"}
{"name":"Filter.IsBoundedUnder.smul_tendsto_zero","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nα : Type u_5\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : α → 𝕜\ng : α → E\nl : Filter α\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\nhg : Filter.Tendsto g l (nhds 0)\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.IsBoundedUnder.smul_tendsto_zero {f : α → 𝕜} {g : α → E} {l : Filter α}\n    (hf : IsBoundedUnder (· ≤ ·) l (norm ∘ f)) (hg : Tendsto g l (𝓝 0)) :\n    Tendsto (fun x => f x • g x) l (𝓝 0) :=\n  hg.op_zero_isBoundedUnder_le hf (flip (· • ·)) fun x y =>\n    (norm_smul_le y x).trans_eq (mul_comm _ _)\n\n"}
{"name":"NormedSpace.discreteTopology_zmultiples","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Rat E\ne : E\n⊢ DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples e) x)","decl":"instance NormedSpace.discreteTopology_zmultiples\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ℚ E] (e : E) :\n    DiscreteTopology <| AddSubgroup.zmultiples e := by\n  rcases eq_or_ne e 0 with (rfl | he)\n  · rw [AddSubgroup.zmultiples_zero_eq_bot]\n    exact Subsingleton.discreteTopology (α := ↑(⊥ : Subspace ℚ E))\n  · rw [discreteTopology_iff_isOpen_singleton_zero, isOpen_induced_iff]\n    refine ⟨Metric.ball 0 ‖e‖, Metric.isOpen_ball, ?_⟩\n    ext ⟨x, hx⟩\n    obtain ⟨k, rfl⟩ := AddSubgroup.mem_zmultiples_iff.mp hx\n    rw [mem_preimage, mem_ball_zero_iff, AddSubgroup.coe_mk, mem_singleton_iff, Subtype.ext_iff,\n      AddSubgroup.coe_mk, AddSubgroup.coe_zero, norm_zsmul ℚ k e, Int.norm_cast_rat,\n      Int.norm_eq_abs, mul_lt_iff_lt_one_left (norm_pos_iff.mpr he), ← @Int.cast_one ℝ _,\n      ← Int.cast_abs, Int.cast_lt, Int.abs_lt_one_iff, smul_eq_zero, or_iff_left he]\n\n"}
{"name":"NormedSpace.exists_lt_norm","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\nc : Real\n⊢ Exists fun x => LT.lt c (Norm.norm x)","decl":"/-- If `E` is a nontrivial normed space over a nontrivially normed field `𝕜`, then `E` is unbounded:\nfor any `c : ℝ`, there exists a vector `x : E` with norm strictly greater than `c`. -/\ntheorem NormedSpace.exists_lt_norm (c : ℝ) : ∃ x : E, c < ‖x‖ := by\n  rcases exists_ne (0 : E) with ⟨x, hx⟩\n  rcases NormedField.exists_lt_norm 𝕜 (c / ‖x‖) with ⟨r, hr⟩\n  use r • x\n  rwa [norm_smul, ← div_lt_iff₀]\n  rwa [norm_pos_iff]\n\n"}
{"name":"NormedSpace.unbounded_univ","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ Not (Bornology.IsBounded Set.univ)","decl":"protected theorem NormedSpace.unbounded_univ : ¬Bornology.IsBounded (univ : Set E) := fun h =>\n  let ⟨R, hR⟩ := isBounded_iff_forall_norm_le.1 h\n  let ⟨x, hx⟩ := NormedSpace.exists_lt_norm 𝕜 E R\n  hx.not_le (hR x trivial)\n\n"}
{"name":"NormedSpace.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : Nontrivial E\n⊢ (Bornology.cobounded E).NeBot","decl":"protected lemma NormedSpace.cobounded_neBot : NeBot (cobounded E) := by\n  rw [neBot_iff, Ne, cobounded_eq_bot_iff, ← isBounded_univ]\n  exact NormedSpace.unbounded_univ 𝕜 E\n\n"}
{"name":"NontriviallyNormedField.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\n⊢ (Bornology.cobounded 𝕜).NeBot","decl":"instance (priority := 100) NontriviallyNormedField.cobounded_neBot : NeBot (cobounded 𝕜) :=\n  NormedSpace.cobounded_neBot 𝕜 𝕜\n\n"}
{"name":"RealNormedSpace.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : Nontrivial E\ninst✝ : NormedSpace Real E\n⊢ (Bornology.cobounded E).NeBot","decl":"instance (priority := 80) RealNormedSpace.cobounded_neBot [NormedSpace ℝ E] :\n    NeBot (cobounded E) := NormedSpace.cobounded_neBot ℝ E\n\n"}
{"name":"NontriviallyNormedField.infinite","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Infinite 𝕜","decl":"instance (priority := 80) NontriviallyNormedField.infinite : Infinite 𝕜 :=\n  ⟨fun _ ↦ NormedSpace.unbounded_univ 𝕜 𝕜 (Set.toFinite _).isBounded⟩\n\n"}
{"name":"NormedSpace.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝⁴ : NormedField 𝕜\ninst✝³ : Infinite 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : Nontrivial E\ninst✝ : NormedSpace 𝕜 E\n⊢ NoncompactSpace E","decl":"/-- A normed vector space over an infinite normed field is a noncompact space.\nThis cannot be an instance because in order to apply it,\nLean would have to search for `NormedSpace 𝕜 E` with unknown `𝕜`.\nWe register this as an instance in two cases: `𝕜 = E` and `𝕜 = ℝ`. -/\nprotected theorem NormedSpace.noncompactSpace : NoncompactSpace E := by\n  by_cases H : ∃ c : 𝕜, c ≠ 0 ∧ ‖c‖ ≠ 1\n  · letI := NontriviallyNormedField.ofNormNeOne H\n    exact ⟨fun h ↦ NormedSpace.unbounded_univ 𝕜 E h.isBounded⟩\n  · push_neg at H\n    rcases exists_ne (0 : E) with ⟨x, hx⟩\n    suffices IsClosedEmbedding (Infinite.natEmbedding 𝕜 · • x) from this.noncompactSpace\n    refine isClosedEmbedding_of_pairwise_le_dist (norm_pos_iff.2 hx) fun k n hne ↦ ?_\n    simp only [dist_eq_norm, ← sub_smul, norm_smul]\n    rw [H, one_mul]\n    rwa [sub_ne_zero, (Embedding.injective _).ne_iff]\n\n"}
{"name":"NormedField.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NormedField 𝕜\ninst✝ : Infinite 𝕜\n⊢ NoncompactSpace 𝕜","decl":"instance (priority := 100) NormedField.noncompactSpace : NoncompactSpace 𝕜 :=\n  NormedSpace.noncompactSpace 𝕜 𝕜\n\n"}
{"name":"RealNormedSpace.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_3\ninst✝² : NormedAddCommGroup E\ninst✝¹ : Nontrivial E\ninst✝ : NormedSpace Real E\n⊢ NoncompactSpace E","decl":"instance (priority := 100) RealNormedSpace.noncompactSpace [NormedSpace ℝ E] : NoncompactSpace E :=\n  NormedSpace.noncompactSpace ℝ E\n\n"}
{"name":"NormedAlgebra.norm_smul_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\n𝕜' : Type u_7\ninst✝¹ : NormedField 𝕜\ninst✝ : SeminormedRing 𝕜'\nself : NormedAlgebra 𝕜 𝕜'\nr : 𝕜\nx : 𝕜'\n⊢ LE.le (Norm.norm (HSMul.hSMul r x)) (HMul.hMul (Norm.norm r) (Norm.norm x))","decl":"/-- A normed algebra `𝕜'` over `𝕜` is normed module that is also an algebra.\n\nSee the implementation notes for `Algebra` for a discussion about non-unital algebras. Following\nthe strategy there, a non-unital *normed* algebra can be written as:\n```lean\nvariable [NormedField 𝕜] [NonUnitalSeminormedRing 𝕜']\nvariable [NormedSpace 𝕜 𝕜'] [SMulCommClass 𝕜 𝕜' 𝕜'] [IsScalarTower 𝕜 𝕜' 𝕜']\n```\n-/\nclass NormedAlgebra (𝕜 : Type*) (𝕜' : Type*) [NormedField 𝕜] [SeminormedRing 𝕜'] extends\n  Algebra 𝕜 𝕜' where\n  norm_smul_le : ∀ (r : 𝕜) (x : 𝕜'), ‖r • x‖ ≤ ‖r‖ * ‖x‖\n\n"}
{"name":"norm_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedRing 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nx : 𝕜\n⊢ Eq (Norm.norm ((algebraMap 𝕜 𝕜') x)) (HMul.hMul (Norm.norm x) (Norm.norm 1))","decl":"theorem norm_algebraMap (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖ = ‖x‖ * ‖(1 : 𝕜')‖ := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  exact norm_smul _ _\n\n"}
{"name":"nnnorm_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedRing 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nx : 𝕜\n⊢ Eq (NNNorm.nnnorm ((algebraMap 𝕜 𝕜') x)) (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm 1))","decl":"theorem nnnorm_algebraMap (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖₊ = ‖x‖₊ * ‖(1 : 𝕜')‖₊ :=\n  Subtype.ext <| norm_algebraMap 𝕜' x\n\n"}
{"name":"dist_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedRing 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nx y : 𝕜\n⊢ Eq (Dist.dist ((algebraMap 𝕜 𝕜') x) ((algebraMap 𝕜 𝕜') y)) (HMul.hMul (Dist.dist x y) (Norm.norm 1))","decl":"theorem dist_algebraMap (x y : 𝕜) :\n    (dist (algebraMap 𝕜 𝕜' x) (algebraMap 𝕜 𝕜' y)) = dist x y * ‖(1 : 𝕜')‖ := by\n  simp only [dist_eq_norm, ← map_sub, norm_algebraMap]\n\n"}
{"name":"norm_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormedAlgebra 𝕜 𝕜'\ninst✝ : NormOneClass 𝕜'\nx : 𝕜\n⊢ Eq (Norm.norm ((algebraMap 𝕜 𝕜') x)) (Norm.norm x)","decl":"/-- This is a simpler version of `norm_algebraMap` when `‖1‖ = 1` in `𝕜'`.-/\n@[simp]\ntheorem norm_algebraMap' [NormOneClass 𝕜'] (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖ = ‖x‖ := by\n  rw [norm_algebraMap, norm_one, mul_one]\n\n"}
{"name":"nnnorm_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormedAlgebra 𝕜 𝕜'\ninst✝ : NormOneClass 𝕜'\nx : 𝕜\n⊢ Eq (NNNorm.nnnorm ((algebraMap 𝕜 𝕜') x)) (NNNorm.nnnorm x)","decl":"/-- This is a simpler version of `nnnorm_algebraMap` when `‖1‖ = 1` in `𝕜'`.-/\n@[simp]\ntheorem nnnorm_algebraMap' [NormOneClass 𝕜'] (x : 𝕜) : ‖algebraMap 𝕜 𝕜' x‖₊ = ‖x‖₊ :=\n  Subtype.ext <| norm_algebraMap' _ _\n\n"}
{"name":"dist_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormedAlgebra 𝕜 𝕜'\ninst✝ : NormOneClass 𝕜'\nx y : 𝕜\n⊢ Eq (Dist.dist ((algebraMap 𝕜 𝕜') x) ((algebraMap 𝕜 𝕜') y)) (Dist.dist x y)","decl":"/-- This is a simpler version of `dist_algebraMap` when `‖1‖ = 1` in `𝕜'`.-/\n@[simp]\ntheorem dist_algebraMap' [NormOneClass 𝕜'] (x y : 𝕜) :\n    (dist (algebraMap 𝕜 𝕜' x) (algebraMap 𝕜 𝕜' y)) = dist x y := by\n  simp only [dist_eq_norm, ← map_sub, norm_algebraMap']\n\n"}
{"name":"norm_algebraMap_nnreal","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜' : Type u_2\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormOneClass 𝕜'\ninst✝ : NormedAlgebra Real 𝕜'\nx : NNReal\n⊢ Eq (Norm.norm ((algebraMap NNReal 𝕜') x)) ↑x","decl":"@[simp]\ntheorem norm_algebraMap_nnreal (x : ℝ≥0) : ‖algebraMap ℝ≥0 𝕜' x‖ = x :=\n  (norm_algebraMap' 𝕜' (x : ℝ)).symm ▸ Real.norm_of_nonneg x.prop\n\n"}
{"name":"nnnorm_algebraMap_nnreal","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜' : Type u_2\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormOneClass 𝕜'\ninst✝ : NormedAlgebra Real 𝕜'\nx : NNReal\n⊢ Eq (NNNorm.nnnorm ((algebraMap NNReal 𝕜') x)) x","decl":"@[simp]\ntheorem nnnorm_algebraMap_nnreal (x : ℝ≥0) : ‖algebraMap ℝ≥0 𝕜' x‖₊ = x :=\n  Subtype.ext <| norm_algebraMap_nnreal 𝕜' x\n\n"}
{"name":"algebraMap_isometry","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_1\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜\ninst✝² : SeminormedRing 𝕜'\ninst✝¹ : NormedAlgebra 𝕜 𝕜'\ninst✝ : NormOneClass 𝕜'\n⊢ Isometry ⇑(algebraMap 𝕜 𝕜')","decl":"/-- In a normed algebra, the inclusion of the base field in the extended field is an isometry. -/\ntheorem algebraMap_isometry [NormOneClass 𝕜'] : Isometry (algebraMap 𝕜 𝕜') := by\n  refine Isometry.of_dist_eq fun x y => ?_\n  rw [dist_eq_norm, dist_eq_norm, ← RingHom.map_sub, norm_algebraMap']\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_smul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Norm E\ninst✝ : Module 𝕜 E\nself : SeminormedAddCommGroup.Core 𝕜 E\nc : 𝕜\nx : E\n⊢ Eq (Norm.norm (HSMul.hSMul c x)) (HMul.hMul (Norm.norm c) (Norm.norm x))","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [AddCommGroup E]\n    [Norm E] [Module 𝕜 E] : Prop where\n  norm_nonneg (x : E) : 0 ≤ ‖x‖\n  norm_smul (c : 𝕜) (x : E) : ‖c • x‖ = ‖c‖ * ‖x‖\n  norm_triangle (x y : E) : ‖x + y‖ ≤ ‖x‖ + ‖y‖\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_nonneg","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Norm E\ninst✝ : Module 𝕜 E\nself : SeminormedAddCommGroup.Core 𝕜 E\nx : E\n⊢ LE.le 0 (Norm.norm x)","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [AddCommGroup E]\n    [Norm E] [Module 𝕜 E] : Prop where\n  norm_nonneg (x : E) : 0 ≤ ‖x‖\n  norm_smul (c : 𝕜) (x : E) : ‖c • x‖ = ‖c‖ * ‖x‖\n  norm_triangle (x y : E) : ‖x + y‖ ≤ ‖x‖ + ‖y‖\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_triangle","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Norm E\ninst✝ : Module 𝕜 E\nself : SeminormedAddCommGroup.Core 𝕜 E\nx y : E\n⊢ LE.le (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [AddCommGroup E]\n    [Norm E] [Module 𝕜 E] : Prop where\n  norm_nonneg (x : E) : 0 ≤ ‖x‖\n  norm_smul (c : 𝕜) (x : E) : ‖c • x‖ = ‖c‖ * ‖x‖\n  norm_triangle (x y : E) : ‖x + y‖ ≤ ‖x‖ + ‖y‖\n\n"}
{"name":"NormedSpace.Core.toCore","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : Norm E\nself : NormedSpace.Core 𝕜 E\n⊢ SeminormedAddCommGroup.Core 𝕜 E","decl":"/-- A structure encapsulating minimal axioms needed to defined a normed vector space, as found\nin textbooks. This is meant to be used to easily define `NormedAddCommGroup E` and `NormedSpace E`\ninstances from scratch on a type with no preexisting distance or topology. -/\nstructure NormedSpace.Core (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]\n    [Norm E] extends SeminormedAddCommGroup.Core 𝕜 E : Prop where\n  norm_eq_zero_iff (x : E) : ‖x‖ = 0 ↔ x = 0\n\n"}
{"name":"NormedSpace.Core.norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"𝕜 : Type u_6\nE : Type u_7\ninst✝³ : NormedField 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : Norm E\nself : NormedSpace.Core 𝕜 E\nx : E\n⊢ Iff (Eq (Norm.norm x) 0) (Eq x 0)","decl":"/-- A structure encapsulating minimal axioms needed to defined a normed vector space, as found\nin textbooks. This is meant to be used to easily define `NormedAddCommGroup E` and `NormedSpace E`\ninstances from scratch on a type with no preexisting distance or topology. -/\nstructure NormedSpace.Core (𝕜 : Type*) (E : Type*) [NormedField 𝕜] [AddCommGroup E] [Module 𝕜 E]\n    [Norm E] extends SeminormedAddCommGroup.Core 𝕜 E : Prop where\n  norm_eq_zero_iff (x : E) : ‖x‖ = 0 ↔ x = 0\n\n"}
{"name":"AddMonoidHom.continuous_of_isBounded_nhds_zero","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"G : Type u_6\nH : Type u_7\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : SeminormedAddCommGroup H\ninst✝ : NormedSpace Real H\ns : Set G\nf : AddMonoidHom G H\nhs : Membership.mem (nhds 0) s\nhbounded : Bornology.IsBounded (Set.image (⇑f) s)\n⊢ Continuous ⇑f","decl":"/-- A group homomorphism from a normed group to a real normed space,\nbounded on a neighborhood of `0`, must be continuous. -/\nlemma AddMonoidHom.continuous_of_isBounded_nhds_zero (f : G →+ H) (hs : s ∈ 𝓝 (0 : G))\n    (hbounded : IsBounded (f '' s)) : Continuous f := by\n  obtain ⟨δ, hδ, hUε⟩ := Metric.mem_nhds_iff.mp hs\n  obtain ⟨C, hC⟩ := (isBounded_iff_subset_ball 0).1 (hbounded.subset <| image_subset f hUε)\n  refine continuous_of_continuousAt_zero _ (continuousAt_iff.2 fun ε (hε : _ < _) => ?_)\n  simp only [dist_zero_right, _root_.map_zero, exists_prop]\n  simp only [subset_def, mem_image, mem_ball, dist_zero_right, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iff₂] at hC\n  have hC₀ : 0 < C := (norm_nonneg _).trans_lt <| hC 0 (by simpa)\n  obtain ⟨n, hn⟩ := exists_nat_gt (C / ε)\n  have hnpos : 0 < (n : ℝ) := (div_pos hC₀ hε).trans hn\n  have hn₀ : n ≠ 0 := by rintro rfl; simp at hnpos\n  refine ⟨δ / n, div_pos hδ hnpos, fun {x} hxδ => ?_⟩\n  calc\n    ‖f x‖\n    _ = ‖(n : ℝ)⁻¹ • f (n • x)‖ := by simp [← Nat.cast_smul_eq_nsmul ℝ, hn₀]\n    _ ≤ ‖(n : ℝ)⁻¹‖ * ‖f (n • x)‖ := norm_smul_le ..\n    _ < ‖(n : ℝ)⁻¹‖ * C := by\n      gcongr\n      · simpa [pos_iff_ne_zero]\n      · refine hC _ <| norm_nsmul_le.trans_lt ?_\n        simpa only [norm_mul, Real.norm_natCast, lt_div_iff₀ hnpos, mul_comm] using hxδ\n    _ = (n : ℝ)⁻¹ * C := by simp\n    _ < (C / ε : ℝ)⁻¹ * C := by gcongr\n    _ = ε := by simp [hC₀.ne']\n"}
