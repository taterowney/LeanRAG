{"name":"NormedSpace.norm_smul_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : SeminormedAddCommGroup E\nself : NormedSpace ğ•œ E\na : ğ•œ\nb : E\nâŠ¢ LE.le (Norm.norm (HSMul.hSMul a b)) (HMul.hMul (Norm.norm a) (Norm.norm b))","decl":"/-- A normed space over a normed field is a vector space endowed with a norm which satisfies the\nequality `â€–c â€¢ xâ€– = â€–câ€– â€–xâ€–`. We require only `â€–c â€¢ xâ€– â‰¤ â€–câ€– â€–xâ€–` in the definition, then prove\n`â€–c â€¢ xâ€– = â€–câ€– â€–xâ€–` in `norm_smul`.\n\nNote that since this requires `SeminormedAddCommGroup` and not `NormedAddCommGroup`, this\ntypeclass can be used for \"semi normed spaces\" too, just as `Module` can be used for\n\"semi modules\". -/\nclass NormedSpace (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [SeminormedAddCommGroup E]\n    extends Module ğ•œ E where\n  norm_smul_le : âˆ€ (a : ğ•œ) (b : E), â€–a â€¢ bâ€– â‰¤ â€–aâ€– * â€–bâ€–\n\n"}
{"name":"NormedSpace.boundedSMul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ BoundedSMul ğ•œ E","decl":"instance (priority := 100) NormedSpace.boundedSMul [NormedSpace ğ•œ E] : BoundedSMul ğ•œ E :=\n  BoundedSMul.of_norm_smul_le NormedSpace.norm_smul_le\n\n"}
{"name":"NormedField.to_boundedSMul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NormedField ğ•œ\nâŠ¢ BoundedSMul ğ•œ ğ•œ","decl":"instance NormedField.to_boundedSMul : BoundedSMul ğ•œ ğ•œ :=\n  NormedSpace.boundedSMul\n\n"}
{"name":"norm_zsmul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nn : Int\nx : E\nâŠ¢ Eq (Norm.norm (HSMul.hSMul n x)) (HMul.hMul (Norm.norm â†‘n) (Norm.norm x))","decl":"variable (ğ•œ) in\ntheorem norm_zsmul (n : â„¤) (x : E) : â€–n â€¢ xâ€– = â€–(n : ğ•œ)â€– * â€–xâ€– := by\n  rw [â† norm_smul, â† Int.smul_one_eq_cast, smul_assoc, one_smul]\n\n"}
{"name":"eventually_nhds_norm_smul_sub_lt","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nx : E\nÎµ : Real\nh : LT.lt 0 Îµ\nâŠ¢ Filter.Eventually (fun y => LT.lt (Norm.norm (HSMul.hSMul c (HSub.hSub y x))) Îµ) (nhds x)","decl":"theorem eventually_nhds_norm_smul_sub_lt (c : ğ•œ) (x : E) {Îµ : â„} (h : 0 < Îµ) :\n    âˆ€á¶  y in ğ“ x, â€–c â€¢ (y - x)â€– < Îµ :=\n  have : Tendsto (fun y â†¦ â€–c â€¢ (y - x)â€–) (ğ“ x) (ğ“ 0) :=\n    Continuous.tendsto' (by fun_prop) _ _ (by simp)\n  this.eventually (gt_mem_nhds h)\n\n"}
{"name":"Filter.Tendsto.zero_smul_isBoundedUnder_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ± : Type u_5\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : Î± â†’ ğ•œ\ng : Î± â†’ E\nl : Filter Î±\nhf : Filter.Tendsto f l (nhds 0)\nhg : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm g)\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.Tendsto.zero_smul_isBoundedUnder_le {f : Î± â†’ ğ•œ} {g : Î± â†’ E} {l : Filter Î±}\n    (hf : Tendsto f l (ğ“ 0)) (hg : IsBoundedUnder (Â· â‰¤ Â·) l (Norm.norm âˆ˜ g)) :\n    Tendsto (fun x => f x â€¢ g x) l (ğ“ 0) :=\n  hf.op_zero_isBoundedUnder_le hg (Â· â€¢ Â·) norm_smul_le\n\n"}
{"name":"Filter.IsBoundedUnder.smul_tendsto_zero","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nÎ± : Type u_5\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : Î± â†’ ğ•œ\ng : Î± â†’ E\nl : Filter Î±\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp Norm.norm f)\nhg : Filter.Tendsto g l (nhds 0)\nâŠ¢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds 0)","decl":"theorem Filter.IsBoundedUnder.smul_tendsto_zero {f : Î± â†’ ğ•œ} {g : Î± â†’ E} {l : Filter Î±}\n    (hf : IsBoundedUnder (Â· â‰¤ Â·) l (norm âˆ˜ f)) (hg : Tendsto g l (ğ“ 0)) :\n    Tendsto (fun x => f x â€¢ g x) l (ğ“ 0) :=\n  hg.op_zero_isBoundedUnder_le hf (flip (Â· â€¢ Â·)) fun x y =>\n    (norm_smul_le y x).trans_eq (mul_comm _ _)\n\n"}
{"name":"NormedSpace.discreteTopology_zmultiples","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Rat E\ne : E\nâŠ¢ DiscreteTopology (Subtype fun x => Membership.mem (AddSubgroup.zmultiples e) x)","decl":"instance NormedSpace.discreteTopology_zmultiples\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace â„š E] (e : E) :\n    DiscreteTopology <| AddSubgroup.zmultiples e := by\n  rcases eq_or_ne e 0 with (rfl | he)\n  Â· rw [AddSubgroup.zmultiples_zero_eq_bot]\n    exact Subsingleton.discreteTopology (Î± := â†‘(âŠ¥ : Subspace â„š E))\n  Â· rw [discreteTopology_iff_isOpen_singleton_zero, isOpen_induced_iff]\n    refine âŸ¨Metric.ball 0 â€–eâ€–, Metric.isOpen_ball, ?_âŸ©\n    ext âŸ¨x, hxâŸ©\n    obtain âŸ¨k, rflâŸ© := AddSubgroup.mem_zmultiples_iff.mp hx\n    rw [mem_preimage, mem_ball_zero_iff, AddSubgroup.coe_mk, mem_singleton_iff, Subtype.ext_iff,\n      AddSubgroup.coe_mk, AddSubgroup.coe_zero, norm_zsmul â„š k e, Int.norm_cast_rat,\n      Int.norm_eq_abs, mul_lt_iff_lt_one_left (norm_pos_iff.mpr he), â† @Int.cast_one â„ _,\n      â† Int.cast_abs, Int.cast_lt, Int.abs_lt_one_iff, smul_eq_zero, or_iff_left he]\n\n"}
{"name":"NormedSpace.exists_lt_norm","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nc : Real\nâŠ¢ Exists fun x => LT.lt c (Norm.norm x)","decl":"/-- If `E` is a nontrivial normed space over a nontrivially normed field `ğ•œ`, then `E` is unbounded:\nfor any `c : â„`, there exists a vector `x : E` with norm strictly greater than `c`. -/\ntheorem NormedSpace.exists_lt_norm (c : â„) : âˆƒ x : E, c < â€–xâ€– := by\n  rcases exists_ne (0 : E) with âŸ¨x, hxâŸ©\n  rcases NormedField.exists_lt_norm ğ•œ (c / â€–xâ€–) with âŸ¨r, hrâŸ©\n  use r â€¢ x\n  rwa [norm_smul, â† div_lt_iffâ‚€]\n  rwa [norm_pos_iff]\n\n"}
{"name":"NormedSpace.unbounded_univ","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ Not (Bornology.IsBounded Set.univ)","decl":"protected theorem NormedSpace.unbounded_univ : Â¬Bornology.IsBounded (univ : Set E) := fun h =>\n  let âŸ¨R, hRâŸ© := isBounded_iff_forall_norm_le.1 h\n  let âŸ¨x, hxâŸ© := NormedSpace.exists_lt_norm ğ•œ E R\n  hx.not_le (hR x trivial)\n\n"}
{"name":"NormedSpace.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : Nontrivial E\nâŠ¢ (Bornology.cobounded E).NeBot","decl":"protected lemma NormedSpace.cobounded_neBot : NeBot (cobounded E) := by\n  rw [neBot_iff, Ne, cobounded_eq_bot_iff, â† isBounded_univ]\n  exact NormedSpace.unbounded_univ ğ•œ E\n\n"}
{"name":"NontriviallyNormedField.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ (Bornology.cobounded ğ•œ).NeBot","decl":"instance (priority := 100) NontriviallyNormedField.cobounded_neBot : NeBot (cobounded ğ•œ) :=\n  NormedSpace.cobounded_neBot ğ•œ ğ•œ\n\n"}
{"name":"RealNormedSpace.cobounded_neBot","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : Nontrivial E\ninstâœ : NormedSpace Real E\nâŠ¢ (Bornology.cobounded E).NeBot","decl":"instance (priority := 80) RealNormedSpace.cobounded_neBot [NormedSpace â„ E] :\n    NeBot (cobounded E) := NormedSpace.cobounded_neBot â„ E\n\n"}
{"name":"NontriviallyNormedField.infinite","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nâŠ¢ Infinite ğ•œ","decl":"instance (priority := 80) NontriviallyNormedField.infinite : Infinite ğ•œ :=\n  âŸ¨fun _ â†¦ NormedSpace.unbounded_univ ğ•œ ğ•œ (Set.toFinite _).isBoundedâŸ©\n\n"}
{"name":"NormedSpace.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœâ´ : NormedField ğ•œ\ninstâœÂ³ : Infinite ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : Nontrivial E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ NoncompactSpace E","decl":"/-- A normed vector space over an infinite normed field is a noncompact space.\nThis cannot be an instance because in order to apply it,\nLean would have to search for `NormedSpace ğ•œ E` with unknown `ğ•œ`.\nWe register this as an instance in two cases: `ğ•œ = E` and `ğ•œ = â„`. -/\nprotected theorem NormedSpace.noncompactSpace : NoncompactSpace E := by\n  by_cases H : âˆƒ c : ğ•œ, c â‰  0 âˆ§ â€–câ€– â‰  1\n  Â· letI := NontriviallyNormedField.ofNormNeOne H\n    exact âŸ¨fun h â†¦ NormedSpace.unbounded_univ ğ•œ E h.isBoundedâŸ©\n  Â· push_neg at H\n    rcases exists_ne (0 : E) with âŸ¨x, hxâŸ©\n    suffices IsClosedEmbedding (Infinite.natEmbedding ğ•œ Â· â€¢ x) from this.noncompactSpace\n    refine isClosedEmbedding_of_pairwise_le_dist (norm_pos_iff.2 hx) fun k n hne â†¦ ?_\n    simp only [dist_eq_norm, â† sub_smul, norm_smul]\n    rw [H, one_mul]\n    rwa [sub_ne_zero, (Embedding.injective _).ne_iff]\n\n"}
{"name":"NormedField.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : Infinite ğ•œ\nâŠ¢ NoncompactSpace ğ•œ","decl":"instance (priority := 100) NormedField.noncompactSpace : NoncompactSpace ğ•œ :=\n  NormedSpace.noncompactSpace ğ•œ ğ•œ\n\n"}
{"name":"RealNormedSpace.noncompactSpace","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"E : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : Nontrivial E\ninstâœ : NormedSpace Real E\nâŠ¢ NoncompactSpace E","decl":"instance (priority := 100) RealNormedSpace.noncompactSpace [NormedSpace â„ E] : NoncompactSpace E :=\n  NormedSpace.noncompactSpace â„ E\n\n"}
{"name":"NormedAlgebra.norm_smul_le","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nğ•œ' : Type u_7\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : SeminormedRing ğ•œ'\nself : NormedAlgebra ğ•œ ğ•œ'\nr : ğ•œ\nx : ğ•œ'\nâŠ¢ LE.le (Norm.norm (HSMul.hSMul r x)) (HMul.hMul (Norm.norm r) (Norm.norm x))","decl":"/-- A normed algebra `ğ•œ'` over `ğ•œ` is normed module that is also an algebra.\n\nSee the implementation notes for `Algebra` for a discussion about non-unital algebras. Following\nthe strategy there, a non-unital *normed* algebra can be written as:\n```lean\nvariable [NormedField ğ•œ] [NonUnitalSeminormedRing ğ•œ']\nvariable [NormedSpace ğ•œ ğ•œ'] [SMulCommClass ğ•œ ğ•œ' ğ•œ'] [IsScalarTower ğ•œ ğ•œ' ğ•œ']\n```\n-/\nclass NormedAlgebra (ğ•œ : Type*) (ğ•œ' : Type*) [NormedField ğ•œ] [SeminormedRing ğ•œ'] extends\n  Algebra ğ•œ ğ•œ' where\n  norm_smul_le : âˆ€ (r : ğ•œ) (x : ğ•œ'), â€–r â€¢ xâ€– â‰¤ â€–râ€– * â€–xâ€–\n\n"}
{"name":"norm_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedRing ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nx : ğ•œ\nâŠ¢ Eq (Norm.norm ((algebraMap ğ•œ ğ•œ') x)) (HMul.hMul (Norm.norm x) (Norm.norm 1))","decl":"theorem norm_algebraMap (x : ğ•œ) : â€–algebraMap ğ•œ ğ•œ' xâ€– = â€–xâ€– * â€–(1 : ğ•œ')â€– := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  exact norm_smul _ _\n\n"}
{"name":"nnnorm_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedRing ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nx : ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm ((algebraMap ğ•œ ğ•œ') x)) (HMul.hMul (NNNorm.nnnorm x) (NNNorm.nnnorm 1))","decl":"theorem nnnorm_algebraMap (x : ğ•œ) : â€–algebraMap ğ•œ ğ•œ' xâ€–â‚Š = â€–xâ€–â‚Š * â€–(1 : ğ•œ')â€–â‚Š :=\n  Subtype.ext <| norm_algebraMap ğ•œ' x\n\n"}
{"name":"dist_algebraMap","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedRing ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nx y : ğ•œ\nâŠ¢ Eq (Dist.dist ((algebraMap ğ•œ ğ•œ') x) ((algebraMap ğ•œ ğ•œ') y)) (HMul.hMul (Dist.dist x y) (Norm.norm 1))","decl":"theorem dist_algebraMap (x y : ğ•œ) :\n    (dist (algebraMap ğ•œ ğ•œ' x) (algebraMap ğ•œ ğ•œ' y)) = dist x y * â€–(1 : ğ•œ')â€– := by\n  simp only [dist_eq_norm, â† map_sub, norm_algebraMap]\n\n"}
{"name":"norm_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ•œ'\ninstâœ : NormOneClass ğ•œ'\nx : ğ•œ\nâŠ¢ Eq (Norm.norm ((algebraMap ğ•œ ğ•œ') x)) (Norm.norm x)","decl":"/-- This is a simpler version of `norm_algebraMap` when `â€–1â€– = 1` in `ğ•œ'`.-/\n@[simp]\ntheorem norm_algebraMap' [NormOneClass ğ•œ'] (x : ğ•œ) : â€–algebraMap ğ•œ ğ•œ' xâ€– = â€–xâ€– := by\n  rw [norm_algebraMap, norm_one, mul_one]\n\n"}
{"name":"nnnorm_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ•œ'\ninstâœ : NormOneClass ğ•œ'\nx : ğ•œ\nâŠ¢ Eq (NNNorm.nnnorm ((algebraMap ğ•œ ğ•œ') x)) (NNNorm.nnnorm x)","decl":"/-- This is a simpler version of `nnnorm_algebraMap` when `â€–1â€– = 1` in `ğ•œ'`.-/\n@[simp]\ntheorem nnnorm_algebraMap' [NormOneClass ğ•œ'] (x : ğ•œ) : â€–algebraMap ğ•œ ğ•œ' xâ€–â‚Š = â€–xâ€–â‚Š :=\n  Subtype.ext <| norm_algebraMap' _ _\n\n"}
{"name":"dist_algebraMap'","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ•œ'\ninstâœ : NormOneClass ğ•œ'\nx y : ğ•œ\nâŠ¢ Eq (Dist.dist ((algebraMap ğ•œ ğ•œ') x) ((algebraMap ğ•œ ğ•œ') y)) (Dist.dist x y)","decl":"/-- This is a simpler version of `dist_algebraMap` when `â€–1â€– = 1` in `ğ•œ'`.-/\n@[simp]\ntheorem dist_algebraMap' [NormOneClass ğ•œ'] (x y : ğ•œ) :\n    (dist (algebraMap ğ•œ ğ•œ' x) (algebraMap ğ•œ ğ•œ' y)) = dist x y := by\n  simp only [dist_eq_norm, â† map_sub, norm_algebraMap']\n\n"}
{"name":"norm_algebraMap_nnreal","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ' : Type u_2\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormOneClass ğ•œ'\ninstâœ : NormedAlgebra Real ğ•œ'\nx : NNReal\nâŠ¢ Eq (Norm.norm ((algebraMap NNReal ğ•œ') x)) â†‘x","decl":"@[simp]\ntheorem norm_algebraMap_nnreal (x : â„â‰¥0) : â€–algebraMap â„â‰¥0 ğ•œ' xâ€– = x :=\n  (norm_algebraMap' ğ•œ' (x : â„)).symm â–¸ Real.norm_of_nonneg x.prop\n\n"}
{"name":"nnnorm_algebraMap_nnreal","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ' : Type u_2\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormOneClass ğ•œ'\ninstâœ : NormedAlgebra Real ğ•œ'\nx : NNReal\nâŠ¢ Eq (NNNorm.nnnorm ((algebraMap NNReal ğ•œ') x)) x","decl":"@[simp]\ntheorem nnnorm_algebraMap_nnreal (x : â„â‰¥0) : â€–algebraMap â„â‰¥0 ğ•œ' xâ€–â‚Š = x :=\n  Subtype.ext <| norm_algebraMap_nnreal ğ•œ' x\n\n"}
{"name":"algebraMap_isometry","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œ' : Type u_2\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : SeminormedRing ğ•œ'\ninstâœÂ¹ : NormedAlgebra ğ•œ ğ•œ'\ninstâœ : NormOneClass ğ•œ'\nâŠ¢ Isometry â‡‘(algebraMap ğ•œ ğ•œ')","decl":"/-- In a normed algebra, the inclusion of the base field in the extended field is an isometry. -/\ntheorem algebraMap_isometry [NormOneClass ğ•œ'] : Isometry (algebraMap ğ•œ ğ•œ') := by\n  refine Isometry.of_dist_eq fun x y => ?_\n  rw [dist_eq_norm, dist_eq_norm, â† RingHom.map_sub, norm_algebraMap']\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_smul","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Norm E\ninstâœ : Module ğ•œ E\nself : SeminormedAddCommGroup.Core ğ•œ E\nc : ğ•œ\nx : E\nâŠ¢ Eq (Norm.norm (HSMul.hSMul c x)) (HMul.hMul (Norm.norm c) (Norm.norm x))","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [AddCommGroup E]\n    [Norm E] [Module ğ•œ E] : Prop where\n  norm_nonneg (x : E) : 0 â‰¤ â€–xâ€–\n  norm_smul (c : ğ•œ) (x : E) : â€–c â€¢ xâ€– = â€–câ€– * â€–xâ€–\n  norm_triangle (x y : E) : â€–x + yâ€– â‰¤ â€–xâ€– + â€–yâ€–\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_nonneg","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Norm E\ninstâœ : Module ğ•œ E\nself : SeminormedAddCommGroup.Core ğ•œ E\nx : E\nâŠ¢ LE.le 0 (Norm.norm x)","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [AddCommGroup E]\n    [Norm E] [Module ğ•œ E] : Prop where\n  norm_nonneg (x : E) : 0 â‰¤ â€–xâ€–\n  norm_smul (c : ğ•œ) (x : E) : â€–c â€¢ xâ€– = â€–câ€– * â€–xâ€–\n  norm_triangle (x y : E) : â€–x + yâ€– â‰¤ â€–xâ€– + â€–yâ€–\n\n"}
{"name":"SeminormedAddCommGroup.Core.norm_triangle","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Norm E\ninstâœ : Module ğ•œ E\nself : SeminormedAddCommGroup.Core ğ•œ E\nx y : E\nâŠ¢ LE.le (Norm.norm (HAdd.hAdd x y)) (HAdd.hAdd (Norm.norm x) (Norm.norm y))","decl":"/-- A structure encapsulating minimal axioms needed to defined a seminormed vector space, as found\nin textbooks. This is meant to be used to easily define `SeminormedAddCommGroup E` instances from\nscratch on a type with no preexisting distance or topology. -/\nstructure SeminormedAddCommGroup.Core (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [AddCommGroup E]\n    [Norm E] [Module ğ•œ E] : Prop where\n  norm_nonneg (x : E) : 0 â‰¤ â€–xâ€–\n  norm_smul (c : ğ•œ) (x : E) : â€–c â€¢ xâ€– = â€–câ€– * â€–xâ€–\n  norm_triangle (x y : E) : â€–x + yâ€– â‰¤ â€–xâ€– + â€–yâ€–\n\n"}
{"name":"NormedSpace.Core.toCore","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Norm E\nself : NormedSpace.Core ğ•œ E\nâŠ¢ SeminormedAddCommGroup.Core ğ•œ E","decl":"/-- A structure encapsulating minimal axioms needed to defined a normed vector space, as found\nin textbooks. This is meant to be used to easily define `NormedAddCommGroup E` and `NormedSpace E`\ninstances from scratch on a type with no preexisting distance or topology. -/\nstructure NormedSpace.Core (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]\n    [Norm E] extends SeminormedAddCommGroup.Core ğ•œ E : Prop where\n  norm_eq_zero_iff (x : E) : â€–xâ€– = 0 â†” x = 0\n\n"}
{"name":"NormedSpace.Core.norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"ğ•œ : Type u_6\nE : Type u_7\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Norm E\nself : NormedSpace.Core ğ•œ E\nx : E\nâŠ¢ Iff (Eq (Norm.norm x) 0) (Eq x 0)","decl":"/-- A structure encapsulating minimal axioms needed to defined a normed vector space, as found\nin textbooks. This is meant to be used to easily define `NormedAddCommGroup E` and `NormedSpace E`\ninstances from scratch on a type with no preexisting distance or topology. -/\nstructure NormedSpace.Core (ğ•œ : Type*) (E : Type*) [NormedField ğ•œ] [AddCommGroup E] [Module ğ•œ E]\n    [Norm E] extends SeminormedAddCommGroup.Core ğ•œ E : Prop where\n  norm_eq_zero_iff (x : E) : â€–xâ€– = 0 â†” x = 0\n\n"}
{"name":"AddMonoidHom.continuous_of_isBounded_nhds_zero","module":"Mathlib.Analysis.Normed.Module.Basic","initialProofState":"G : Type u_6\nH : Type u_7\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : SeminormedAddCommGroup H\ninstâœ : NormedSpace Real H\ns : Set G\nf : AddMonoidHom G H\nhs : Membership.mem (nhds 0) s\nhbounded : Bornology.IsBounded (Set.image (â‡‘f) s)\nâŠ¢ Continuous â‡‘f","decl":"/-- A group homomorphism from a normed group to a real normed space,\nbounded on a neighborhood of `0`, must be continuous. -/\nlemma AddMonoidHom.continuous_of_isBounded_nhds_zero (f : G â†’+ H) (hs : s âˆˆ ğ“ (0 : G))\n    (hbounded : IsBounded (f '' s)) : Continuous f := by\n  obtain âŸ¨Î´, hÎ´, hUÎµâŸ© := Metric.mem_nhds_iff.mp hs\n  obtain âŸ¨C, hCâŸ© := (isBounded_iff_subset_ball 0).1 (hbounded.subset <| image_subset f hUÎµ)\n  refine continuous_of_continuousAt_zero _ (continuousAt_iff.2 fun Îµ (hÎµ : _ < _) => ?_)\n  simp only [dist_zero_right, _root_.map_zero, exists_prop]\n  simp only [subset_def, mem_image, mem_ball, dist_zero_right, forall_exists_index, and_imp,\n    forall_apply_eq_imp_iffâ‚‚] at hC\n  have hCâ‚€ : 0 < C := (norm_nonneg _).trans_lt <| hC 0 (by simpa)\n  obtain âŸ¨n, hnâŸ© := exists_nat_gt (C / Îµ)\n  have hnpos : 0 < (n : â„) := (div_pos hCâ‚€ hÎµ).trans hn\n  have hnâ‚€ : n â‰  0 := by rintro rfl; simp at hnpos\n  refine âŸ¨Î´ / n, div_pos hÎ´ hnpos, fun {x} hxÎ´ => ?_âŸ©\n  calc\n    â€–f xâ€–\n    _ = â€–(n : â„)â»Â¹ â€¢ f (n â€¢ x)â€– := by simp [â† Nat.cast_smul_eq_nsmul â„, hnâ‚€]\n    _ â‰¤ â€–(n : â„)â»Â¹â€– * â€–f (n â€¢ x)â€– := norm_smul_le ..\n    _ < â€–(n : â„)â»Â¹â€– * C := by\n      gcongr\n      Â· simpa [pos_iff_ne_zero]\n      Â· refine hC _ <| norm_nsmul_le.trans_lt ?_\n        simpa only [norm_mul, Real.norm_natCast, lt_div_iffâ‚€ hnpos, mul_comm] using hxÎ´\n    _ = (n : â„)â»Â¹ * C := by simp\n    _ < (C / Îµ : â„)â»Â¹ * C := by gcongr\n    _ = Îµ := by simp [hCâ‚€.ne']\n"}
