{"name":"Sym2.Rel.symm","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : Prod α α\na✝ : Sym2.Rel α x y\n⊢ Sym2.Rel α y x","decl":"@[symm]\ntheorem Rel.symm {x y : α × α} : Rel α x y → Rel α y x := by aesop (rule_sets := [Sym2])\n\n"}
{"name":"Sym2.Rel.trans","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y z : Prod α α\na : Sym2.Rel α x y\nb : Sym2.Rel α y z\n⊢ Sym2.Rel α x z","decl":"@[trans]\ntheorem Rel.trans {x y z : α × α} (a : Rel α x y) (b : Rel α y z) : Rel α x z := by\n  aesop (rule_sets := [Sym2])\n\n"}
{"name":"Sym2.Rel.is_equivalence","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Equivalence (Sym2.Rel α)","decl":"theorem Rel.is_equivalence : Equivalence (Rel α) :=\n  { refl := fun (x, y) ↦ Rel.refl x y, symm := Rel.symm, trans := Rel.trans }\n\n"}
{"name":"Sym2.rel_iff'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np q : Prod α α\n⊢ Iff (Sym2.Rel α p q) (Or (Eq p q) (Eq p q.swap))","decl":"@[simp]\ntheorem rel_iff' {p q : α × α} : Rel α p q ↔ p = q ∨ p = q.swap := by\n  aesop (rule_sets := [Sym2])\n\n"}
{"name":"Sym2.rel_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y z w : α\n⊢ Iff (Sym2.Rel α { fst := x, snd := y } { fst := z, snd := w }) (Or (And (Eq x z) (Eq y w)) (And (Eq x w) (Eq y z)))","decl":"theorem rel_iff {x y z w : α} : Rel α (x, y) (z, w) ↔ x = z ∧ y = w ∨ x = w ∧ y = z := by\n  simp\n\n"}
{"name":"Sym2.sound","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np p' : Prod α α\nh : Sym2.Rel α p p'\n⊢ Eq (Sym2.mk p) (Sym2.mk p')","decl":"protected theorem sound {p p' : α × α} (h : Sym2.Rel α p p') : Sym2.mk p = Sym2.mk p' :=\n  Quot.sound h\n\n"}
{"name":"Sym2.exact","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np p' : Prod α α\nh : Eq (Sym2.mk p) (Sym2.mk p')\n⊢ Sym2.Rel α p p'","decl":"protected theorem exact {p p' : α × α} (h : Sym2.mk p = Sym2.mk p') : Sym2.Rel α p p' :=\n  Quotient.exact (s := Sym2.Rel.setoid α) h\n\n"}
{"name":"Sym2.eq","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np p' : Prod α α\n⊢ Iff (Eq (Sym2.mk p) (Sym2.mk p')) (Sym2.Rel α p p')","decl":"@[simp]\nprotected theorem eq {p p' : α × α} : Sym2.mk p = Sym2.mk p' ↔ Sym2.Rel α p p' :=\n  Quotient.eq' (s₁ := Sym2.Rel.setoid α)\n\n"}
{"name":"Sym2.ind","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nf : Sym2 α → Prop\nh : ∀ (x y : α), f (Sym2.mk { fst := x, snd := y })\ni : Sym2 α\n⊢ f i","decl":"@[elab_as_elim, cases_eliminator, induction_eliminator]\nprotected theorem ind {f : Sym2 α → Prop} (h : ∀ x y, f s(x, y)) : ∀ i, f i :=\n  Quot.ind <| Prod.rec <| h\n\n"}
{"name":"Sym2.inductionOn","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nf : Sym2 α → Prop\ni : Sym2 α\nhf : ∀ (x y : α), f (Sym2.mk { fst := x, snd := y })\n⊢ f i","decl":"@[elab_as_elim]\nprotected theorem inductionOn {f : Sym2 α → Prop} (i : Sym2 α) (hf : ∀ x y, f s(x, y)) : f i :=\n  i.ind hf\n\n"}
{"name":"Sym2.inductionOn₂","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Sym2 α → Sym2 β → Prop\ni : Sym2 α\nj : Sym2 β\nhf : ∀ (a₁ a₂ : α) (b₁ b₂ : β), f (Sym2.mk { fst := a₁, snd := a₂ }) (Sym2.mk { fst := b₁, snd := b₂ })\n⊢ f i j","decl":"@[elab_as_elim]\nprotected theorem inductionOn₂ {f : Sym2 α → Sym2 β → Prop} (i : Sym2 α) (j : Sym2 β)\n    (hf : ∀ a₁ a₂ b₁ b₂, f s(a₁, a₂) s(b₁, b₂)) : f i j :=\n  Quot.induction_on₂ i j <| by\n    intro ⟨a₁, a₂⟩ ⟨b₁, b₂⟩\n    exact hf _ _ _ _\n\n"}
{"name":"Sym2.exists","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_4\nf : Sym2 α → Prop\n⊢ Iff (Exists fun x => f x) (Exists fun x => Exists fun y => f (Sym2.mk { fst := x, snd := y }))","decl":"protected theorem «exists» {α : Sort _} {f : Sym2 α → Prop} :\n    (∃ x : Sym2 α, f x) ↔ ∃ x y, f s(x, y) :=\n  Quot.mk_surjective.exists.trans Prod.exists\n\n"}
{"name":"Sym2.forall","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_4\nf : Sym2 α → Prop\n⊢ Iff (∀ (x : Sym2 α), f x) (∀ (x y : α), f (Sym2.mk { fst := x, snd := y }))","decl":"protected theorem «forall» {α : Sort _} {f : Sym2 α → Prop} :\n    (∀ x : Sym2 α, f x) ↔ ∀ x y, f s(x, y) :=\n  Quot.mk_surjective.forall.trans Prod.forall\n\n"}
{"name":"Sym2.eq_swap","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b : α\n⊢ Eq (Sym2.mk { fst := a, snd := b }) (Sym2.mk { fst := b, snd := a })","decl":"theorem eq_swap {a b : α} : s(a, b) = s(b, a) := Quot.sound (Rel.swap _ _)\n\n"}
{"name":"Sym2.mk_prod_swap_eq","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np : Prod α α\n⊢ Eq (Sym2.mk p.swap) (Sym2.mk p)","decl":"@[simp]\ntheorem mk_prod_swap_eq {p : α × α} : Sym2.mk p.swap = Sym2.mk p := by\n  cases p\n  exact eq_swap\n\n"}
{"name":"Sym2.congr_right","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b c : α\n⊢ Iff (Eq (Sym2.mk { fst := a, snd := b }) (Sym2.mk { fst := a, snd := c })) (Eq b c)","decl":"theorem congr_right {a b c : α} : s(a, b) = s(a, c) ↔ b = c := by\n  simp (config := {contextual := true})\n\n"}
{"name":"Sym2.congr_left","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b c : α\n⊢ Iff (Eq (Sym2.mk { fst := b, snd := a }) (Sym2.mk { fst := c, snd := a })) (Eq b c)","decl":"theorem congr_left {a b c : α} : s(b, a) = s(c, a) ↔ b = c := by\n  simp (config := {contextual := true})\n\n"}
{"name":"Sym2.eq_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y z w : α\n⊢ Iff (Eq (Sym2.mk { fst := x, snd := y }) (Sym2.mk { fst := z, snd := w })) (Or (And (Eq x z) (Eq y w)) (And (Eq x w) (Eq y z)))","decl":"theorem eq_iff {x y z w : α} : s(x, y) = s(z, w) ↔ x = z ∧ y = w ∨ x = w ∧ y = z := by\n  simp\n\n"}
{"name":"Sym2.mk_eq_mk_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np q : Prod α α\n⊢ Iff (Eq (Sym2.mk p) (Sym2.mk q)) (Or (Eq p q) (Eq p q.swap))","decl":"theorem mk_eq_mk_iff {p q : α × α} : Sym2.mk p = Sym2.mk q ↔ p = q ∨ p = q.swap := by\n  cases p\n  cases q\n  simp only [eq_iff, Prod.mk.inj_iff, Prod.swap_prod_mk]\n\n"}
{"name":"Sym2.lift_mk","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Subtype fun f => ∀ (a₁ a₂ : α), Eq (f a₁ a₂) (f a₂ a₁)\na₁ a₂ : α\n⊢ Eq (Sym2.lift f (Sym2.mk { fst := a₁, snd := a₂ })) (↑f a₁ a₂)","decl":"@[simp]\ntheorem lift_mk (f : { f : α → α → β // ∀ a₁ a₂, f a₁ a₂ = f a₂ a₁ }) (a₁ a₂ : α) :\n    lift f s(a₁, a₂) = (f : α → α → β) a₁ a₂ :=\n  rfl\n\n"}
{"name":"Sym2.coe_lift_symm_apply","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nF : Sym2 α → β\na₁ a₂ : α\n⊢ Eq (↑(Sym2.lift.symm F) a₁ a₂) (F (Sym2.mk { fst := a₁, snd := a₂ }))","decl":"@[simp]\ntheorem coe_lift_symm_apply (F : Sym2 α → β) (a₁ a₂ : α) :\n    (lift.symm F : α → α → β) a₁ a₂ = F s(a₁, a₂) :=\n  rfl\n\n"}
{"name":"Sym2.lift₂_mk","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Subtype fun f => ∀ (a₁ a₂ : α) (b₁ b₂ : β), And (Eq (f a₁ a₂ b₁ b₂) (f a₂ a₁ b₁ b₂)) (Eq (f a₁ a₂ b₁ b₂) (f a₁ a₂ b₂ b₁))\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (Sym2.lift₂ f (Sym2.mk { fst := a₁, snd := a₂ }) (Sym2.mk { fst := b₁, snd := b₂ })) (↑f a₁ a₂ b₁ b₂)","decl":"@[simp]\ntheorem lift₂_mk\n    (f :\n    { f : α → α → β → β → γ //\n      ∀ a₁ a₂ b₁ b₂, f a₁ a₂ b₁ b₂ = f a₂ a₁ b₁ b₂ ∧ f a₁ a₂ b₁ b₂ = f a₁ a₂ b₂ b₁ })\n    (a₁ a₂ : α) (b₁ b₂ : β) : lift₂ f s(a₁, a₂) s(b₁, b₂) = (f : α → α → β → β → γ) a₁ a₂ b₁ b₂ :=\n  rfl\n\n"}
{"name":"Sym2.coe_lift₂_symm_apply","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nF : Sym2 α → Sym2 β → γ\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (↑(Sym2.lift₂.symm F) a₁ a₂ b₁ b₂) (F (Sym2.mk { fst := a₁, snd := a₂ }) (Sym2.mk { fst := b₁, snd := b₂ }))","decl":"@[simp]\ntheorem coe_lift₂_symm_apply (F : Sym2 α → Sym2 β → γ) (a₁ a₂ : α) (b₁ b₂ : β) :\n    (lift₂.symm F : α → α → β → β → γ) a₁ a₂ b₁ b₂ = F s(a₁, a₂) s(b₁, b₂) :=\n  rfl\n\n"}
{"name":"Sym2.map_id","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Eq (Sym2.map id) id","decl":"@[simp]\ntheorem map_id : map (@id α) = id := by\n  ext ⟨⟨x, y⟩⟩\n  rfl\n\n"}
{"name":"Sym2.map_comp","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\n⊢ Eq (Sym2.map (Function.comp g f)) (Function.comp (Sym2.map g) (Sym2.map f))","decl":"theorem map_comp {g : β → γ} {f : α → β} : Sym2.map (g ∘ f) = Sym2.map g ∘ Sym2.map f := by\n  ext ⟨⟨x, y⟩⟩\n  rfl\n\n"}
{"name":"Sym2.map_map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ng : β → γ\nf : α → β\nx : Sym2 α\n⊢ Eq (Sym2.map g (Sym2.map f x)) (Sym2.map (Function.comp g f) x)","decl":"theorem map_map {g : β → γ} {f : α → β} (x : Sym2 α) : map g (map f x) = map (g ∘ f) x := by\n  induction x; aesop\n\n"}
{"name":"Sym2.map_pair_eq","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx y : α\n⊢ Eq (Sym2.map f (Sym2.mk { fst := x, snd := y })) (Sym2.mk { fst := f x, snd := f y })","decl":"@[simp]\ntheorem map_pair_eq (f : α → β) (x y : α) : map f s(x, y) = s(f x, f y) :=\n  rfl\n\n"}
{"name":"Sym2.map.injective","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhinj : Function.Injective f\n⊢ Function.Injective (Sym2.map f)","decl":"theorem map.injective {f : α → β} (hinj : Injective f) : Injective (map f) := by\n  intro z z'\n  refine Sym2.inductionOn₂ z z' (fun x y x' y' => ?_)\n  simp [hinj.eq_iff]\n\n"}
{"name":"Sym2.mkEmbedding_apply","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b : α\n⊢ Eq ((Sym2.mkEmbedding a) b) (Sym2.mk { fst := a, snd := b })","decl":"/-- `mk a` as an embedding. This is the symmetric version of `Function.Embedding.sectL`. -/\n@[simps]\ndef mkEmbedding (a : α) : α ↪ Sym2 α where\n  toFun b := s(a, b)\n  inj' b₁ b₁ h := by\n    simp only [Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, true_and, Prod.swap_prod_mk] at h\n    obtain rfl | ⟨rfl, rfl⟩ := h <;> rfl\n\n"}
{"name":"Function.Embedding.sym2Map_apply","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\na✝ : Sym2 α\n⊢ Eq (f.sym2Map a✝) (Sym2.map (⇑f) a✝)","decl":"/-- `Sym2.map` as an embedding. -/\n@[simps]\ndef _root_.Function.Embedding.sym2Map (f : α ↪ β) : Sym2 α ↪ Sym2 β where\n  toFun := map f\n  inj' := map.injective f.injective\n\n"}
{"name":"Sym2.mem_iff'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b c : α\n⊢ Iff (Sym2.Mem a (Sym2.mk { fst := b, snd := c })) (Or (Eq a b) (Eq a c))","decl":"@[aesop norm (rule_sets := [Sym2])]\ntheorem mem_iff' {a b c : α} : Sym2.Mem a s(b, c) ↔ a = b ∨ a = c :=\n  { mp := by\n      rintro ⟨_, h⟩\n      rw [eq_iff] at h\n      aesop\n    mpr := by\n      rintro (rfl | rfl)\n      · exact ⟨_, rfl⟩\n      rw [eq_swap]\n      exact ⟨_, rfl⟩ }\n\n"}
{"name":"Sym2.mem_iff_mem","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx : α\nz : Sym2 α\n⊢ Iff (Sym2.Mem x z) (Membership.mem z x)","decl":"@[simp]\ntheorem mem_iff_mem {x : α} {z : Sym2 α} : Sym2.Mem x z ↔ x ∈ z :=\n  Iff.rfl\n\n"}
{"name":"Sym2.mem_iff_exists","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx : α\nz : Sym2 α\n⊢ Iff (Membership.mem z x) (Exists fun y => Eq z (Sym2.mk { fst := x, snd := y }))","decl":"theorem mem_iff_exists {x : α} {z : Sym2 α} : x ∈ z ↔ ∃ y : α, z = s(x, y) :=\n  Iff.rfl\n\n"}
{"name":"Sym2.ext","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np q : Sym2 α\nh : ∀ (x : α), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : Sym2 α} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"Sym2.ext_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np q : Sym2 α\n⊢ Iff (Eq p q) (∀ (x : α), Iff (Membership.mem p x) (Membership.mem q x))","decl":"@[ext]\ntheorem ext {p q : Sym2 α} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"Sym2.mem_mk_left","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : α\n⊢ Membership.mem (Sym2.mk { fst := x, snd := y }) x","decl":"theorem mem_mk_left (x y : α) : x ∈ s(x, y) :=\n  ⟨y, rfl⟩\n\n"}
{"name":"Sym2.mem_mk_right","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : α\n⊢ Membership.mem (Sym2.mk { fst := x, snd := y }) y","decl":"theorem mem_mk_right (x y : α) : y ∈ s(x, y) :=\n  eq_swap ▸ mem_mk_left y x\n\n"}
{"name":"Sym2.mem_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na b c : α\n⊢ Iff (Membership.mem (Sym2.mk { fst := b, snd := c }) a) (Or (Eq a b) (Eq a c))","decl":"@[simp, aesop norm (rule_sets := [Sym2])]\ntheorem mem_iff {a b c : α} : a ∈ s(b, c) ↔ a = b ∨ a = c :=\n  mem_iff'\n\n"}
{"name":"Sym2.out_fst_mem","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ne : Sym2 α\n⊢ Membership.mem e (Quot.out e).1","decl":"theorem out_fst_mem (e : Sym2 α) : e.out.1 ∈ e :=\n  ⟨e.out.2, by rw [Sym2.mk, e.out_eq]⟩\n\n"}
{"name":"Sym2.out_snd_mem","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ne : Sym2 α\n⊢ Membership.mem e (Quot.out e).2","decl":"theorem out_snd_mem (e : Sym2 α) : e.out.2 ∈ e :=\n  ⟨e.out.1, by rw [eq_swap, Sym2.mk, e.out_eq]⟩\n\n"}
{"name":"Sym2.ball","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\np : α → Prop\na b : α\n⊢ Iff (∀ (c : α), Membership.mem (Sym2.mk { fst := a, snd := b }) c → p c) (And (p a) (p b))","decl":"theorem ball {p : α → Prop} {a b : α} : (∀ c ∈ s(a, b), p c) ↔ p a ∧ p b := by\n  refine ⟨fun h => ⟨h _ <| mem_mk_left _ _, h _ <| mem_mk_right _ _⟩, fun h c hc => ?_⟩\n  obtain rfl | rfl := Sym2.mem_iff.1 hc\n  · exact h.1\n  · exact h.2\n\n"}
{"name":"Sym2.other_spec","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na : α\nz : Sym2 α\nh : Membership.mem z a\n⊢ Eq (Sym2.mk { fst := a, snd := Sym2.Mem.other h }) z","decl":"@[simp]\ntheorem other_spec {a : α} {z : Sym2 α} (h : a ∈ z) : s(a, Mem.other h) = z := by\n  erw [← Classical.choose_spec h]\n\n"}
{"name":"Sym2.other_mem","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na : α\nz : Sym2 α\nh : Membership.mem z a\n⊢ Membership.mem z (Sym2.Mem.other h)","decl":"theorem other_mem {a : α} {z : Sym2 α} (h : a ∈ z) : Mem.other h ∈ z := by\n  convert mem_mk_right a <| Mem.other h\n  rw [other_spec h]\n\n"}
{"name":"Sym2.mem_and_mem_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : α\nz : Sym2 α\nhne : Ne x y\n⊢ Iff (And (Membership.mem z x) (Membership.mem z y)) (Eq z (Sym2.mk { fst := x, snd := y }))","decl":"theorem mem_and_mem_iff {x y : α} {z : Sym2 α} (hne : x ≠ y) : x ∈ z ∧ y ∈ z ↔ z = s(x, y) := by\n  constructor\n  · induction' z with x' y'\n    rw [mem_iff, mem_iff]\n    aesop\n  · rintro rfl\n    simp\n\n"}
{"name":"Sym2.eq_of_ne_mem","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : α\nz z' : Sym2 α\nh : Ne x y\nh1 : Membership.mem z x\nh2 : Membership.mem z y\nh3 : Membership.mem z' x\nh4 : Membership.mem z' y\n⊢ Eq z z'","decl":"theorem eq_of_ne_mem {x y : α} {z z' : Sym2 α} (h : x ≠ y) (h1 : x ∈ z) (h2 : y ∈ z) (h3 : x ∈ z')\n    (h4 : y ∈ z') : z = z' :=\n  ((mem_and_mem_iff h).mp ⟨h1, h2⟩).trans ((mem_and_mem_iff h).mp ⟨h3, h4⟩).symm\n\n"}
{"name":"Sym2.mem_map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\nz : Sym2 α\n⊢ Iff (Membership.mem (Sym2.map f z) b) (Exists fun a => And (Membership.mem z a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map {f : α → β} {b : β} {z : Sym2 α} : b ∈ Sym2.map f z ↔ ∃ a, a ∈ z ∧ f a = b := by\n  induction' z with x y\n  simp only [map_pair_eq, mem_iff, exists_eq_or_imp, exists_eq_left]\n  aesop\n\n"}
{"name":"Sym2.map_congr","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\ns : Sym2 α\nh : ∀ (x : α), Membership.mem s x → Eq (f x) (g x)\n⊢ Eq (Sym2.map f s) (Sym2.map g s)","decl":"@[congr]\ntheorem map_congr {f g : α → β} {s : Sym2 α} (h : ∀ x ∈ s, f x = g x) : map f s = map g s := by\n  ext y\n  simp only [mem_map]\n  constructor <;>\n    · rintro ⟨w, hw, rfl⟩\n      exact ⟨w, hw, by simp [hw, h]⟩\n\n"}
{"name":"Sym2.map_id'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Eq (Sym2.map fun x => x) id","decl":"/-- Note: `Sym2.map_id` will not simplify `Sym2.map id z` due to `Sym2.map_congr`. -/\n@[simp]\ntheorem map_id' : (map fun x : α => x) = id :=\n  map_id\n\n"}
{"name":"Sym2.forall_mem_pair","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nP : α → Prop\na b : α\n⊢ Iff (∀ (x : α), Membership.mem (Sym2.mk { fst := a, snd := b }) x → P x) (And (P a) (P b))","decl":"theorem forall_mem_pair {P : α → Prop} {a b : α} : (∀ x ∈ s(a, b), P x) ↔ P a ∧ P b := by\n  simp only [mem_iff, forall_eq_or_imp, forall_eq]\n\n"}
{"name":"Sym2.pair_eq_pmap","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nP : α → Prop\nf : (a : α) → P a → β\na b : α\nh : P a\nh' : P b\n⊢ Eq (Sym2.mk { fst := f a h, snd := f b h' }) (Sym2.pmap f (Sym2.mk { fst := a, snd := b }) ⋯)","decl":"lemma pair_eq_pmap {P : α → Prop} (f : ∀ a, P a → β) (a b : α) (h : P a) (h' : P b) :\n    s(f a h, f b h') = pmap f s(a, b) (forall_mem_pair.mpr ⟨h, h'⟩) := rfl\n\n"}
{"name":"Sym2.pmap_pair","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nP : α → Prop\nf : (a : α) → P a → β\na b : α\nh : ∀ (x : α), Membership.mem (Sym2.mk { fst := a, snd := b }) x → P x\n⊢ Eq (Sym2.pmap f (Sym2.mk { fst := a, snd := b }) h) (Sym2.mk { fst := f a ⋯, snd := f b ⋯ })","decl":"lemma pmap_pair {P : α → Prop} (f : ∀ a, P a → β) (a b : α) (h : ∀ x ∈ s(a, b), P x) :\n    pmap f s(a, b) h = s(f a (h a (mem_mk_left a b)), f b (h b (mem_mk_right a b))) := rfl\n\n"}
{"name":"Sym2.mem_pmap_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nP : α → Prop\nf : (a : α) → P a → β\nz : Sym2 α\nh : ∀ (a : α), Membership.mem z a → P a\nb : β\n⊢ Iff (Membership.mem (Sym2.pmap f z h) b) (Exists fun a => Exists fun ha => Eq b (f a ⋯))","decl":"@[simp]\nlemma mem_pmap_iff {P : α → Prop} (f : ∀ a, P a → β) (z : Sym2 α) (h : ∀ a ∈ z, P a) (b : β) :\n    b ∈ z.pmap f h ↔ ∃ (a : α) (ha : a ∈ z), b = f a (h a ha) := by\n  induction' z with x y\n  rw [pmap_pair f x y h]\n  aesop\n\n"}
{"name":"Sym2.pmap_eq_map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nP : α → Prop\nf : α → β\nz : Sym2 α\nh : ∀ (a : α), Membership.mem z a → P a\n⊢ Eq (Sym2.pmap (fun a x => f a) z h) (Sym2.map f z)","decl":"lemma pmap_eq_map {P : α → Prop} (f : α → β) (z : Sym2 α) (h : ∀ a ∈ z, P a) :\n    z.pmap (fun a _ => f a) h = z.map f := by\n  induction' z with x y\n  rfl\n\n"}
{"name":"Sym2.map_pmap","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nQ : β → Prop\nf : α → β\ng : (b : β) → Q b → γ\nz : Sym2 α\nh : ∀ (b : β), Membership.mem (Sym2.map f z) b → Q b\n⊢ Eq (Sym2.pmap g (Sym2.map f z) h) (Sym2.pmap (fun a ha => g (f a) ⋯) z ⋯)","decl":"lemma map_pmap {Q : β → Prop} (f : α → β) (g : ∀ b, Q b → γ) (z : Sym2 α) (h : ∀ b ∈ z.map f, Q b):\n    (z.map f).pmap g h =\n    z.pmap (fun a ha => g (f a) (h (f a) (mem_map.mpr ⟨a, ha, rfl⟩))) (fun _ ha => ha) := by\n  induction' z with x y\n  rfl\n\n"}
{"name":"Sym2.pmap_map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nP : α → Prop\nQ : β → Prop\nf : (a : α) → P a → β\ng : β → γ\nz : Sym2 α\nh : ∀ (a : α), Membership.mem z a → P a\nh' : ∀ (b : β), Membership.mem (Sym2.pmap f z h) b → Q b\n⊢ Eq (Sym2.map g (Sym2.pmap f z h)) (Sym2.pmap (fun a ha => g (f a ⋯)) z ⋯)","decl":"lemma pmap_map {P : α → Prop} {Q : β → Prop} (f : ∀ a, P a → β) (g : β → γ)\n    (z : Sym2 α) (h : ∀ a ∈ z, P a) (h' : ∀ b ∈ z.pmap f h, Q b) :\n    (z.pmap f h).map g = z.pmap (fun a ha => g (f a (h a ha))) (fun _ ha ↦ ha) := by\n  induction' z with x y\n  rfl\n\n"}
{"name":"Sym2.pmap_pmap","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nP : α → Prop\nQ : β → Prop\nf : (a : α) → P a → β\ng : (b : β) → Q b → γ\nz : Sym2 α\nh : ∀ (a : α), Membership.mem z a → P a\nh' : ∀ (b : β), Membership.mem (Sym2.pmap f z h) b → Q b\n⊢ Eq (Sym2.pmap g (Sym2.pmap f z h) h') (Sym2.pmap (fun a ha => g (f a ⋯) ⋯) z ⋯)","decl":"lemma pmap_pmap {P : α → Prop} {Q : β → Prop} (f : ∀ a, P a → β) (g : ∀ b, Q b → γ)\n    (z : Sym2 α) (h : ∀ a ∈ z, P a) (h' : ∀ b ∈ z.pmap f h, Q b) :\n    (z.pmap f h).pmap g h' = z.pmap (fun a ha => g (f a (h a ha))\n    (h' _ ((mem_pmap_iff f z h _).mpr ⟨a, ha, rfl⟩))) (fun _ ha ↦ ha) := by\n  induction' z with x y\n  rfl\n\n"}
{"name":"Sym2.pmap_subtype_map_subtypeVal","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nP : α → Prop\ns : Sym2 α\nh : ∀ (a : α), Membership.mem s a → P a\n⊢ Eq (Sym2.map Subtype.val (Sym2.pmap Subtype.mk s h)) s","decl":"@[simp]\nlemma pmap_subtype_map_subtypeVal {P : α → Prop} (s : Sym2 α) (h : ∀ a ∈ s, P a) :\n    (s.pmap Subtype.mk h).map Subtype.val = s := by\n  induction' s with x y\n  rfl\n\n"}
{"name":"Sym2.attachWith_map_subtypeVal","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ns : Sym2 α\nP : α → Prop\nh : ∀ (a : α), Membership.mem s a → P a\n⊢ Eq (Sym2.map Subtype.val (s.attachWith h)) s","decl":"@[simp]\nlemma attachWith_map_subtypeVal {s : Sym2 α} {P : α → Prop} (h : ∀ a ∈ s, P a) :\n    (s.attachWith h).map Subtype.val = s := by\n  induction' s with x y\n  rfl\n\n"}
{"name":"Sym2.diag_injective","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Function.Injective Sym2.diag","decl":"theorem diag_injective : Function.Injective (Sym2.diag : α → Sym2 α) := fun x y h => by\n  cases Sym2.exact h <;> rfl\n\n"}
{"name":"Sym2.mk_isDiag_iff","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nx y : α\n⊢ Iff (Sym2.mk { fst := x, snd := y }).IsDiag (Eq x y)","decl":"theorem mk_isDiag_iff {x y : α} : IsDiag s(x, y) ↔ x = y :=\n  Iff.rfl\n\n"}
{"name":"Sym2.isDiag_iff_proj_eq","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nz : Prod α α\n⊢ Iff (Sym2.mk z).IsDiag (Eq z.1 z.2)","decl":"@[simp]\ntheorem isDiag_iff_proj_eq (z : α × α) : IsDiag (Sym2.mk z) ↔ z.1 = z.2 :=\n  Prod.recOn z fun _ _ => mk_isDiag_iff\n\n"}
{"name":"Sym2.IsDiag.map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Sym2 α\nf : α → β\na✝ : e.IsDiag\n⊢ (Sym2.map f e).IsDiag","decl":"protected lemma IsDiag.map : e.IsDiag → (e.map f).IsDiag := Sym2.ind (fun _ _ ↦ congr_arg f) e\n\n"}
{"name":"Sym2.isDiag_map","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Sym2 α\nf : α → β\nhf : Function.Injective f\n⊢ Iff (Sym2.map f e).IsDiag e.IsDiag","decl":"lemma isDiag_map (hf : Injective f) : (e.map f).IsDiag ↔ e.IsDiag :=\n  Sym2.ind (fun _ _ ↦ hf.eq_iff) e\n\n"}
{"name":"Sym2.diag_isDiag","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na : α\n⊢ (Sym2.diag a).IsDiag","decl":"@[simp]\ntheorem diag_isDiag (a : α) : IsDiag (diag a) :=\n  Eq.refl a\n\n"}
{"name":"Sym2.IsDiag.mem_range_diag","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nz : Sym2 α\na✝ : z.IsDiag\n⊢ Membership.mem (Set.range Sym2.diag) z","decl":"theorem IsDiag.mem_range_diag {z : Sym2 α} : IsDiag z → z ∈ Set.range (@diag α) := by\n  induction' z with x y\n  rintro (rfl : x = y)\n  exact ⟨_, rfl⟩\n\n"}
{"name":"Sym2.isDiag_iff_mem_range_diag","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nz : Sym2 α\n⊢ Iff z.IsDiag (Membership.mem (Set.range Sym2.diag) z)","decl":"theorem isDiag_iff_mem_range_diag (z : Sym2 α) : IsDiag z ↔ z ∈ Set.range (@diag α) :=\n  ⟨IsDiag.mem_range_diag, fun ⟨i, hi⟩ => hi ▸ diag_isDiag i⟩\n\n"}
{"name":"Sym2.other_ne","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na : α\nz : Sym2 α\nhd : Not z.IsDiag\nh : Membership.mem z a\n⊢ Ne (Sym2.Mem.other h) a","decl":"theorem other_ne {a : α} {z : Sym2 α} (hd : ¬IsDiag z) (h : a ∈ z) : Mem.other h ≠ a := by\n  contrapose! hd\n  have h' := Sym2.other_spec h\n  rw [hd] at h'\n  rw [← h']\n  simp\n\n"}
{"name":"Sym2.fromRel_proj_prop","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nr : α → α → Prop\nsym : Symmetric r\nz : Prod α α\n⊢ Iff (Membership.mem (Sym2.fromRel sym) (Sym2.mk z)) (r z.1 z.2)","decl":"@[simp]\ntheorem fromRel_proj_prop {sym : Symmetric r} {z : α × α} : Sym2.mk z ∈ fromRel sym ↔ r z.1 z.2 :=\n  Iff.rfl\n\n"}
{"name":"Sym2.fromRel_prop","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nr : α → α → Prop\nsym : Symmetric r\na b : α\n⊢ Iff (Membership.mem (Sym2.fromRel sym) (Sym2.mk { fst := a, snd := b })) (r a b)","decl":"theorem fromRel_prop {sym : Symmetric r} {a b : α} : s(a, b) ∈ fromRel sym ↔ r a b :=\n  Iff.rfl\n\n"}
{"name":"Sym2.fromRel_bot","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Eq (Sym2.fromRel ⋯) EmptyCollection.emptyCollection","decl":"theorem fromRel_bot : fromRel (fun (_ _ : α) z => z : Symmetric ⊥) = ∅ := by\n  apply Set.eq_empty_of_forall_not_mem fun e => _\n  apply Sym2.ind\n  simp [-Set.bot_eq_empty, Prop.bot_eq_false]\n\n"}
{"name":"Sym2.fromRel_top","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Eq (Sym2.fromRel ⋯) Set.univ","decl":"theorem fromRel_top : fromRel (fun (_ _ : α) z => z : Symmetric ⊤) = Set.univ := by\n  apply Set.eq_univ_of_forall fun e => _\n  apply Sym2.ind\n  simp [-Set.top_eq_univ, Prop.top_eq_true]\n\n"}
{"name":"Sym2.fromRel_ne","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\n⊢ Eq (Sym2.fromRel ⋯) (setOf fun z => Not z.IsDiag)","decl":"theorem fromRel_ne : fromRel (fun (_ _ : α) z => z.symm : Symmetric Ne) = {z | ¬IsDiag z} := by\n  ext z; exact z.ind (by simp)\n\n"}
{"name":"Sym2.fromRel_irreflexive","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nr : α → α → Prop\nsym : Symmetric r\n⊢ Iff (Irreflexive r) (∀ {z : Sym2 α}, Membership.mem (Sym2.fromRel sym) z → Not z.IsDiag)","decl":"theorem fromRel_irreflexive {sym : Symmetric r} :\n    Irreflexive r ↔ ∀ {z}, z ∈ fromRel sym → ¬IsDiag z :=\n  { mp := by intro h; apply Sym2.ind; aesop\n    mpr := fun h _ hr => h (fromRel_prop.mpr hr) rfl }\n\n"}
{"name":"Sym2.mem_fromRel_irrefl_other_ne","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nr : α → α → Prop\nsym : Symmetric r\nirrefl : Irreflexive r\na : α\nz : Sym2 α\nhz : Membership.mem (Sym2.fromRel sym) z\nh : Membership.mem z a\n⊢ Ne (Sym2.Mem.other h) a","decl":"theorem mem_fromRel_irrefl_other_ne {sym : Symmetric r} (irrefl : Irreflexive r) {a : α}\n    {z : Sym2 α} (hz : z ∈ fromRel sym) (h : a ∈ z) : Mem.other h ≠ a :=\n  other_ne (fromRel_irreflexive.mp irrefl hz) h\n\n"}
{"name":"Sym2.toRel_prop","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ns : Set (Sym2 α)\nx y : α\n⊢ Iff (Sym2.ToRel s x y) (Membership.mem s (Sym2.mk { fst := x, snd := y }))","decl":"@[simp]\ntheorem toRel_prop (s : Set (Sym2 α)) (x y : α) : ToRel s x y ↔ s(x, y) ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Sym2.toRel_symmetric","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ns : Set (Sym2 α)\n⊢ Symmetric (Sym2.ToRel s)","decl":"theorem toRel_symmetric (s : Set (Sym2 α)) : Symmetric (ToRel s) := fun x y => by simp [eq_swap]\n\n"}
{"name":"Sym2.toRel_fromRel","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\nr : α → α → Prop\nsym : Symmetric r\n⊢ Eq (Sym2.ToRel (Sym2.fromRel sym)) r","decl":"theorem toRel_fromRel (sym : Symmetric r) : ToRel (fromRel sym) = r :=\n  rfl\n\n"}
{"name":"Sym2.fromRel_toRel","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ns : Set (Sym2 α)\n⊢ Eq (Sym2.fromRel ⋯) s","decl":"theorem fromRel_toRel (s : Set (Sym2 α)) : fromRel (toRel_symmetric s) = s :=\n  Set.ext fun z => Sym2.ind (fun _ _ => Iff.rfl) z\n\n"}
{"name":"Sym2.other_spec'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nz : Sym2 α\nh : Membership.mem z a\n⊢ Eq (Sym2.mk { fst := a, snd := Sym2.Mem.other' h }) z","decl":"@[simp]\ntheorem other_spec' [DecidableEq α] {a : α} {z : Sym2 α} (h : a ∈ z) : s(a, Mem.other' h) = z := by\n  induction z\n  have h' := mem_iff.mp h\n  aesop (add norm unfold [Sym2.rec, Quot.rec]) (rule_sets := [Sym2])\n\n"}
{"name":"Sym2.other_eq_other'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nz : Sym2 α\nh : Membership.mem z a\n⊢ Eq (Sym2.Mem.other h) (Sym2.Mem.other' h)","decl":"@[simp]\ntheorem other_eq_other' [DecidableEq α] {a : α} {z : Sym2 α} (h : a ∈ z) :\n    Mem.other h = Mem.other' h := by rw [← congr_right, other_spec' h, other_spec]\n\n"}
{"name":"Sym2.other_mem'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nz : Sym2 α\nh : Membership.mem z a\n⊢ Membership.mem z (Sym2.Mem.other' h)","decl":"theorem other_mem' [DecidableEq α] {a : α} {z : Sym2 α} (h : a ∈ z) : Mem.other' h ∈ z := by\n  rw [← other_eq_other']\n  exact other_mem h\n\n"}
{"name":"Sym2.other_invol'","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nz : Sym2 α\nha : Membership.mem z a\nhb : Membership.mem z (Sym2.Mem.other' ha)\n⊢ Eq (Sym2.Mem.other' hb) a","decl":"theorem other_invol' [DecidableEq α] {a : α} {z : Sym2 α} (ha : a ∈ z) (hb : Mem.other' ha ∈ z) :\n    Mem.other' hb = a := by\n  induction z\n  aesop (rule_sets := [Sym2]) (add norm unfold [Sym2.rec, Quot.rec])\n\n"}
{"name":"Sym2.other_invol","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\na : α\nz : Sym2 α\nha : Membership.mem z a\nhb : Membership.mem z (Sym2.Mem.other ha)\n⊢ Eq (Sym2.Mem.other hb) a","decl":"theorem other_invol {a : α} {z : Sym2 α} (ha : a ∈ z) (hb : Mem.other ha ∈ z) :\n    Mem.other hb = a := by\n  classical\n    rw [other_eq_other'] at hb ⊢\n    convert other_invol' ha hb using 2\n    apply other_eq_other'\n\n"}
{"name":"Sym2.filter_image_mk_isDiag","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun a => a.IsDiag) (Finset.image Sym2.mk (SProd.sprod s s))) (Finset.image Sym2.mk s.diag)","decl":"theorem filter_image_mk_isDiag [DecidableEq α] (s : Finset α) :\n    {a ∈ (s ×ˢ s).image Sym2.mk | a.IsDiag} = s.diag.image Sym2.mk := by\n  ext z\n  induction' z\n  simp only [mem_image, mem_diag, exists_prop, mem_filter, Prod.exists, mem_product]\n  constructor\n  · rintro ⟨⟨a, b, ⟨ha, hb⟩, h⟩, hab⟩\n    rw [← h, Sym2.mk_isDiag_iff] at hab\n    exact ⟨a, b, ⟨ha, hab⟩, h⟩\n  · rintro ⟨a, b, ⟨ha, rfl⟩, h⟩\n    rw [← h]\n    exact ⟨⟨a, a, ⟨ha, ha⟩, rfl⟩, rfl⟩\n\n"}
{"name":"Sym2.filter_image_mk_not_isDiag","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun a => Not a.IsDiag) (Finset.image Sym2.mk (SProd.sprod s s))) (Finset.image Sym2.mk s.offDiag)","decl":"theorem filter_image_mk_not_isDiag [DecidableEq α] (s : Finset α) :\n    {a ∈ (s ×ˢ s).image Sym2.mk | ¬a.IsDiag} = s.offDiag.image Sym2.mk := by\n  ext z\n  induction z\n  simp only [mem_image, mem_offDiag, mem_filter, Prod.exists, mem_product]\n  constructor\n  · rintro ⟨⟨a, b, ⟨ha, hb⟩, h⟩, hab⟩\n    rw [← h, Sym2.mk_isDiag_iff] at hab\n    exact ⟨a, b, ⟨ha, hb, hab⟩, h⟩\n  · rintro ⟨a, b, ⟨ha, hb, hab⟩, h⟩\n    rw [Ne, ← Sym2.mk_isDiag_iff, h] at hab\n    exact ⟨⟨a, b, ⟨ha, hb⟩, h⟩, hab⟩\n\n"}
{"name":"Sym2.instSubsingleton","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\n⊢ Subsingleton (Sym2 α)","decl":"instance [Subsingleton α] : Subsingleton (Sym2 α) :=\n  (equivSym α).injective.subsingleton\n\n"}
{"name":"Sym2.instIsEmpty","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ IsEmpty (Sym2 α)","decl":"instance [IsEmpty α] : IsEmpty (Sym2 α) :=\n  (equivSym α).isEmpty\n\n"}
{"name":"Sym2.instNontrivial","module":"Mathlib.Data.Sym.Sym2","initialProofState":"α : Type u_1\ninst✝ : Nontrivial α\n⊢ Nontrivial (Sym2 α)","decl":"instance [Nontrivial α] : Nontrivial (Sym2 α) :=\n  diag_injective.nontrivial\n\n-- TODO: use a sort order if available, https://github.com/leanprover-community/mathlib/issues/18166\n"}
