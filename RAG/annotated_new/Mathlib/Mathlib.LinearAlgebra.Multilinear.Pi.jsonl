{"name":"MultilinearMap.pi_ext_iff","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : Type uN\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : ∀ (i : ι), Finite (κ i)\ninst✝ : (i : ι) → DecidableEq (κ i)\nf g : MultilinearMap R (fun i => (j : κ i) → M i j) N\n⊢ Iff (Eq f g) (∀ (p : (i : ι) → κ i), Eq (f.compLinearMap fun i => LinearMap.single R (M i) (p i)) (g.compLinearMap fun i => LinearMap.single R (M i) (p i)))","decl":"/-- Two multilinear maps from finite families are equal if they agree on the generators.\n\nThis is a multilinear version of `LinearMap.pi_ext`. -/\n@[ext]\ntheorem pi_ext [Finite ι] [∀ i, Finite (κ i)] [∀ i, DecidableEq (κ i)]\n    ⦃f g : MultilinearMap R (fun i ↦ Π j : κ i, M i j) N⦄\n    (h : ∀ p : Π i, κ i,\n      f.compLinearMap (fun i => LinearMap.single R _ (p i)) =\n      g.compLinearMap (fun i => LinearMap.single R _ (p i))) : f = g := by\n  ext x\n  show f (fun i ↦ x i) = g (fun i ↦ x i)\n  obtain ⟨i⟩ := nonempty_fintype ι\n  have (i) := (nonempty_fintype (κ i)).some\n  have := Classical.decEq ι\n  rw [funext (fun i ↦ Eq.symm (Finset.univ_sum_single (x i)))]\n  simp_rw [MultilinearMap.map_sum_finset]\n  congr! 1 with p\n  simp_rw [MultilinearMap.ext_iff] at h\n  exact h _ _\n\n"}
{"name":"MultilinearMap.pi_ext","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : Type uN\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝³ : Module R N\ninst✝² : Finite ι\ninst✝¹ : ∀ (i : ι), Finite (κ i)\ninst✝ : (i : ι) → DecidableEq (κ i)\nf g : MultilinearMap R (fun i => (j : κ i) → M i j) N\nh : ∀ (p : (i : ι) → κ i), Eq (f.compLinearMap fun i => LinearMap.single R (M i) (p i)) (g.compLinearMap fun i => LinearMap.single R (M i) (p i))\n⊢ Eq f g","decl":"/-- Two multilinear maps from finite families are equal if they agree on the generators.\n\nThis is a multilinear version of `LinearMap.pi_ext`. -/\n@[ext]\ntheorem pi_ext [Finite ι] [∀ i, Finite (κ i)] [∀ i, DecidableEq (κ i)]\n    ⦃f g : MultilinearMap R (fun i ↦ Π j : κ i, M i j) N⦄\n    (h : ∀ p : Π i, κ i,\n      f.compLinearMap (fun i => LinearMap.single R _ (p i)) =\n      g.compLinearMap (fun i => LinearMap.single R _ (p i))) : f = g := by\n  ext x\n  show f (fun i ↦ x i) = g (fun i ↦ x i)\n  obtain ⟨i⟩ := nonempty_fintype ι\n  have (i) := (nonempty_fintype (κ i)).some\n  have := Classical.decEq ι\n  rw [funext (fun i ↦ Eq.symm (Finset.univ_sum_single (x i)))]\n  simp_rw [MultilinearMap.map_sum_finset]\n  congr! 1 with p\n  simp_rw [MultilinearMap.ext_iff] at h\n  exact h _ _\n\n"}
{"name":"MultilinearMap.piFamily_apply","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → (j : κ i) → M i j\np : (i : ι) → κ i\n⊢ Eq ((MultilinearMap.piFamily f) x p) ((f p) fun i => x i (p i))","decl":"/--\nGiven a family of indices `κ` and a multilinear map `f p` for each way `p` to select one index from\neach family, `piFamily f` maps a family of functions (one for each domain `κ i`) into a function\nfrom each selection of indices (with domain `Π i, κ i`).\n-/\n@[simps]\ndef piFamily (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    MultilinearMap R (fun i => Π j : κ i, M i j) (Π t : Π i, κ i, N t) where\n  toFun x := fun p => f p (fun i => x i (p i))\n  map_update_add' {dec} m i x y := funext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, Pi.add_apply, (f p).map_update_add]\n  map_update_smul' {dec} m i c x := funext fun p => by\n    cases Subsingleton.elim dec (by infer_instance)\n    dsimp\n    simp_rw [Function.apply_update (fun i m => m (p i)) m, Pi.smul_apply, (f p).map_update_smul]\n\n"}
{"name":"MultilinearMap.piFamily_single","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁴ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝³ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝² : (p : (i : ι) → κ i) → Module R (N p)\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (κ i)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\np : (i : ι) → κ i\nm : (i : ι) → M i (p i)\n⊢ Eq ((MultilinearMap.piFamily f) fun i => Pi.single (p i) (m i)) (Pi.single p ((f p) m))","decl":"/-- When applied to a family of finitely-supported functions each supported on a single element,\n`piFamily` is itself supported on a single element, with value equal to the map `f` applied\nat that point. -/\n@[simp]\ntheorem piFamily_single [Fintype ι] [∀ i, DecidableEq (κ i)]\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p))\n    (p : ∀ i, κ i) (m : ∀ i, M i (p i)) :\n    piFamily f (fun i => Pi.single (p i) (m i)) = Pi.single p (f p m) := by\n  ext q\n  obtain rfl | hpq := eq_or_ne p q\n  · simp\n  · rw [Pi.single_eq_of_ne' hpq]\n    rw [Function.ne_iff] at hpq\n    obtain ⟨i, hpqi⟩ := hpq\n    apply (f q).map_coord_zero i\n    simp_rw [Pi.single_eq_of_ne' hpqi]\n\n"}
{"name":"MultilinearMap.piFamily_single_left_apply","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁴ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝³ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝² : (p : (i : ι) → κ i) → Module R (N p)\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (κ i)\np : (i : ι) → κ i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\nx : (i : ι) → (j : κ i) → M i j\n⊢ Eq ((MultilinearMap.piFamily (Pi.single p f)) x) (Pi.single p (f fun i => x i (p i)))","decl":"/-- When only one member of the family of multilinear maps is nonzero, the result consists only of\nthe component from that member. -/\n@[simp]\ntheorem piFamily_single_left_apply [Fintype ι] [∀ i, DecidableEq (κ i)]\n    (p : Π i, κ i) (f : MultilinearMap R (fun i ↦ M i (p i)) (N p)) (x : Π i j, M i j) :\n    piFamily (Pi.single p f) x = Pi.single p (f fun i => x i (p i)) := by\n  ext p'\n  obtain rfl | hp := eq_or_ne p p'\n  · simp\n  · simp [hp]\n\n"}
{"name":"MultilinearMap.piFamily_single_left","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁴ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝³ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝² : (p : (i : ι) → κ i) → Module R (N p)\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (κ i)\np : (i : ι) → κ i\nf : MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.piFamily (Pi.single p f)) ((LinearMap.single R N p).compMultilinearMap (f.compLinearMap fun i => LinearMap.proj (p i)))","decl":"theorem piFamily_single_left [Fintype ι] [∀ i, DecidableEq (κ i)]\n    (p : Π i, κ i) (f : MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    piFamily (Pi.single p f) =\n      (LinearMap.single R _ p).compMultilinearMap (f.compLinearMap fun i => .proj (p i)) :=\n  ext <| piFamily_single_left_apply _ _\n\n"}
{"name":"MultilinearMap.piFamily_compLinearMap_lsingle","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁴ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝³ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝² : (p : (i : ι) → κ i) → Module R (N p)\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (κ i)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\np : (i : ι) → κ i\n⊢ Eq ((MultilinearMap.piFamily f).compLinearMap fun i => LinearMap.single R (M i) (p i)) ((LinearMap.single R N p).compMultilinearMap (f p))","decl":"@[simp]\ntheorem piFamily_compLinearMap_lsingle [Fintype ι] [∀ i, DecidableEq (κ i)]\n    (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) (p : ∀ i, κ i) :\n    (piFamily f).compLinearMap (fun i => LinearMap.single _ _ (p i))\n      = (LinearMap.single _ _ p).compMultilinearMap (f p) :=\n  MultilinearMap.ext <| piFamily_single f p\n\n"}
{"name":"MultilinearMap.piFamily_zero","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\n⊢ Eq (MultilinearMap.piFamily 0) 0","decl":"@[simp]\ntheorem piFamily_zero :\n    piFamily (0 : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) = 0 := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.piFamily_add","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf g : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.piFamily (HAdd.hAdd f g)) (HAdd.hAdd (MultilinearMap.piFamily f) (MultilinearMap.piFamily g))","decl":"@[simp]\ntheorem piFamily_add (f g : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    piFamily (f + g) = piFamily f + piFamily g := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.piFamily_smul","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nS : Type uS\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝⁵ : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝⁴ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝³ : (p : (i : ι) → κ i) → Module R (N p)\ninst✝² : Monoid S\ninst✝¹ : (p : (i : ι) → κ i) → DistribMulAction S (N p)\ninst✝ : ∀ (p : (i : ι) → κ i), SMulCommClass R S (N p)\ns : S\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.piFamily (HSMul.hSMul s f)) (HSMul.hSMul s (MultilinearMap.piFamily f))","decl":"@[simp]\ntheorem piFamily_smul\n    [Monoid S] [∀ p, DistribMulAction S (N p)] [∀ p, SMulCommClass R S (N p)]\n    (s : S) (f : Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p)) :\n    piFamily (s • f) = s • piFamily f := by\n  ext; simp\n\n"}
{"name":"MultilinearMap.piFamilyₗ_apply","module":"Mathlib.LinearAlgebra.Multilinear.Pi","initialProofState":"ι : Type uι\nκ : ι → Type uκ\nR : Type uR\nM : (i : ι) → κ i → Type uM\nN : ((i : ι) → κ i) → Type uN\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → (k : κ i) → AddCommMonoid (M i k)\ninst✝² : (p : (i : ι) → κ i) → AddCommMonoid (N p)\ninst✝¹ : (i : ι) → (k : κ i) → Module R (M i k)\ninst✝ : (p : (i : ι) → κ i) → Module R (N p)\nf : (p : (i : ι) → κ i) → MultilinearMap R (fun i => M i (p i)) (N p)\n⊢ Eq (MultilinearMap.piFamilyₗ f) (MultilinearMap.piFamily f)","decl":"/-- `MultilinearMap.piFamily` as a linear map. -/\n@[simps]\ndef piFamilyₗ :\n    (Π (p : Π i, κ i), MultilinearMap R (fun i ↦ M i (p i)) (N p))\n      →ₗ[R] MultilinearMap R (fun i => Π j : κ i, M i j) (Π t : Π i, κ i, N t) where\n  toFun := piFamily\n  map_add' := piFamily_add\n  map_smul' := piFamily_smul\n\n"}
