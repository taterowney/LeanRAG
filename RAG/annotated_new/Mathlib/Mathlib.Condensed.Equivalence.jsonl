{"name":"Condensed.StoneanProfinite.instPreservesEffectiveEpisStoneanProfiniteToProfinite","module":"Mathlib.Condensed.Equivalence","initialProofState":"⊢ Stonean.toProfinite.PreservesEffectiveEpis","decl":"instance : Stonean.toProfinite.PreservesEffectiveEpis where\n  preserves f h :=\n    ((Profinite.effectiveEpi_tfae _).out 0 2).mpr (((Stonean.effectiveEpi_tfae _).out 0 2).mp h)\n\n"}
{"name":"Condensed.StoneanProfinite.instReflectsEffectiveEpisStoneanProfiniteToProfinite","module":"Mathlib.Condensed.Equivalence","initialProofState":"⊢ Stonean.toProfinite.ReflectsEffectiveEpis","decl":"instance : Stonean.toProfinite.ReflectsEffectiveEpis where\n  reflects f h :=\n    ((Stonean.effectiveEpi_tfae f).out 0 2).mpr (((Profinite.effectiveEpi_tfae _).out 0 2).mp h)\n\n"}
{"name":"Condensed.StoneanProfinite.instEffectivelyEnoughStoneanProfiniteToProfinite","module":"Mathlib.Condensed.Equivalence","initialProofState":"⊢ Stonean.toProfinite.EffectivelyEnough","decl":"instance : Stonean.toProfinite.EffectivelyEnough where\n  presentation X := ⟨stoneanToProfiniteEffectivePresentation X⟩\n\n"}
{"name":"Condensed.isSheafProfinite","module":"Mathlib.Condensed.Equivalence","initialProofState":"A : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} A\nX : Condensed A\ninst✝ : ∀ (Y : Opposite CompHaus), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow Y profiniteToCompHaus.op) A\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology Profinite) (profiniteToCompHaus.op.comp X.val)","decl":"lemma isSheafProfinite\n    [∀ Y, HasLimitsOfShape (StructuredArrow Y profiniteToCompHaus.{u}.op) A] :\n    Presheaf.IsSheaf (coherentTopology Profinite)\n    (profiniteToCompHaus.op ⋙ X.val) :=\n  ((ProfiniteCompHaus.equivalence A).inverse.obj X).cond\n\n"}
{"name":"Condensed.isSheafStonean","module":"Mathlib.Condensed.Equivalence","initialProofState":"A : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} A\nX : Condensed A\ninst✝ : ∀ (Y : Opposite CompHaus), CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.StructuredArrow Y Stonean.toCompHaus.op) A\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.coherentTopology Stonean) (Stonean.toCompHaus.op.comp X.val)","decl":"lemma isSheafStonean\n    [∀ Y, HasLimitsOfShape (StructuredArrow Y Stonean.toCompHaus.{u}.op) A] :\n    Presheaf.IsSheaf (coherentTopology Stonean)\n    (Stonean.toCompHaus.op ⋙ X.val) :=\n  ((StoneanCompHaus.equivalence A).inverse.obj X).cond\n\n"}
