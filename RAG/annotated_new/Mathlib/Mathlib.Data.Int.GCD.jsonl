{"name":"Nat.xgcd_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"s t : Int\nr' : Nat\ns' t' : Int\n⊢ Eq (Nat.xgcdAux 0 s t r' s' t') { fst := r', snd := { fst := s', snd := t' } }","decl":"@[simp]\ntheorem xgcd_zero_left {s t r' s' t'} : xgcdAux 0 s t r' s' t' = (r', s', t') := by simp [xgcdAux]\n\n"}
{"name":"Nat.xgcdAux_rec","module":"Mathlib.Data.Int.GCD","initialProofState":"r : Nat\ns t : Int\nr' : Nat\ns' t' : Int\nh : LT.lt 0 r\n⊢ Eq (r.xgcdAux s t r' s' t') ((HMod.hMod r' r).xgcdAux (HSub.hSub s' (HMul.hMul (HDiv.hDiv ↑r' ↑r) s)) (HSub.hSub t' (HMul.hMul (HDiv.hDiv ↑r' ↑r) t)) r s t)","decl":"theorem xgcdAux_rec {r s t r' s' t'} (h : 0 < r) :\n    xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t := by\n  obtain ⟨r, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h.ne'\n  simp [xgcdAux]\n\n"}
{"name":"Nat.gcdA_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"s : Nat\n⊢ Eq (Nat.gcdA 0 s) 0","decl":"@[simp]\ntheorem gcdA_zero_left {s : ℕ} : gcdA 0 s = 0 := by\n  unfold gcdA\n  rw [xgcd, xgcd_zero_left]\n\n"}
{"name":"Nat.gcdB_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"s : Nat\n⊢ Eq (Nat.gcdB 0 s) 1","decl":"@[simp]\ntheorem gcdB_zero_left {s : ℕ} : gcdB 0 s = 1 := by\n  unfold gcdB\n  rw [xgcd, xgcd_zero_left]\n\n"}
{"name":"Nat.gcdA_zero_right","module":"Mathlib.Data.Int.GCD","initialProofState":"s : Nat\nh : Ne s 0\n⊢ Eq (s.gcdA 0) 1","decl":"@[simp]\ntheorem gcdA_zero_right {s : ℕ} (h : s ≠ 0) : gcdA s 0 = 1 := by\n  unfold gcdA xgcd\n  obtain ⟨s, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h\n  rw [xgcdAux]\n  simp\n\n"}
{"name":"Nat.gcdB_zero_right","module":"Mathlib.Data.Int.GCD","initialProofState":"s : Nat\nh : Ne s 0\n⊢ Eq (s.gcdB 0) 0","decl":"@[simp]\ntheorem gcdB_zero_right {s : ℕ} (h : s ≠ 0) : gcdB s 0 = 0 := by\n  unfold gcdB xgcd\n  obtain ⟨s, rfl⟩ := Nat.exists_eq_succ_of_ne_zero h\n  rw [xgcdAux]\n  simp\n\n"}
{"name":"Nat.xgcdAux_fst","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Nat\ns t s' t' : Int\n⊢ Eq (x.xgcdAux s t y s' t').1 (x.gcd y)","decl":"@[simp]\ntheorem xgcdAux_fst (x y) : ∀ s t s' t', (xgcdAux x s t y s' t').1 = gcd x y :=\n  gcd.induction x y (by simp) fun x y h IH s t s' t' => by\n    simp only [h, xgcdAux_rec, IH]\n    rw [← gcd_rec]\n\n"}
{"name":"Nat.xgcdAux_val","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Nat\n⊢ Eq (x.xgcdAux 1 0 y 0 1) { fst := x.gcd y, snd := x.xgcd y }","decl":"theorem xgcdAux_val (x y) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) := by\n  rw [xgcd, ← xgcdAux_fst x y 1 0 0 1]\n\n"}
{"name":"Nat.xgcd_val","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Nat\n⊢ Eq (x.xgcd y) { fst := x.gcdA y, snd := x.gcdB y }","decl":"theorem xgcd_val (x y) : xgcd x y = (gcdA x y, gcdB x y) := by\n  unfold gcdA gcdB; cases xgcd x y; rfl\n\n"}
{"name":"Nat.xgcdAux_P","module":"Mathlib.Data.Int.GCD","initialProofState":"x y r r' : Nat\ns t s' t' : Int\na✝¹ : Nat.P x y { fst := r, snd := { fst := s, snd := t } }\na✝ : Nat.P x y { fst := r', snd := { fst := s', snd := t' } }\n⊢ Nat.P x y (r.xgcdAux s t r' s' t')","decl":"theorem xgcdAux_P {r r'} :\n    ∀ {s t s' t'}, P x y (r, s, t) → P x y (r', s', t') → P x y (xgcdAux r s t r' s' t') := by\n  induction r, r' using gcd.induction with\n  | H0 => simp\n  | H1 a b h IH =>\n    intro s t s' t' p p'\n    rw [xgcdAux_rec h]; refine IH ?_ p; dsimp [P] at *\n    rw [Int.emod_def]; generalize (b / a : ℤ) = k\n    rw [p, p', Int.mul_sub, sub_add_eq_add_sub, Int.mul_sub, Int.add_mul, mul_comm k t,\n      mul_comm k s, ← mul_assoc, ← mul_assoc, add_comm (x * s * k), ← add_sub_assoc, sub_sub]\n\n"}
{"name":"Nat.gcd_eq_gcd_ab","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Nat\n⊢ Eq (↑(x.gcd y)) (HAdd.hAdd (HMul.hMul (↑x) (x.gcdA y)) (HMul.hMul (↑y) (x.gcdB y)))","decl":"/-- **Bézout's lemma**: given `x y : ℕ`, `gcd x y = x * a + y * b`, where `a = gcd_a x y` and\n`b = gcd_b x y` are computed by the extended Euclidean algorithm.\n-/\ntheorem gcd_eq_gcd_ab : (gcd x y : ℤ) = x * gcdA x y + y * gcdB x y := by\n  have := @xgcdAux_P x y x y 1 0 0 1 (by simp [P]) (by simp [P])\n  rwa [xgcdAux_val, xgcd_val] at this\n\n"}
{"name":"Nat.exists_mul_emod_eq_gcd","module":"Mathlib.Data.Int.GCD","initialProofState":"k n : Nat\nhk : LT.lt (n.gcd k) k\n⊢ Exists fun m => Eq (HMod.hMod (HMul.hMul n m) k) (n.gcd k)","decl":"theorem exists_mul_emod_eq_gcd {k n : ℕ} (hk : gcd n k < k) : ∃ m, n * m % k = gcd n k := by\n  have hk' := Int.ofNat_ne_zero.2 (ne_of_gt (lt_of_le_of_lt (zero_le (gcd n k)) hk))\n  have key := congr_arg (fun (m : ℤ) => (m % k).toNat) (gcd_eq_gcd_ab n k)\n  simp only at key\n  rw [Int.add_mul_emod_self_left, ← Int.natCast_mod, Int.toNat_natCast, mod_eq_of_lt hk] at key\n  refine ⟨(n.gcdA k % k).toNat, Eq.trans (Int.ofNat.inj ?_) key.symm⟩\n  rw [Int.ofNat_eq_coe, Int.natCast_mod, Int.ofNat_mul, Int.toNat_of_nonneg (Int.emod_nonneg _ hk'),\n    Int.ofNat_eq_coe, Int.toNat_of_nonneg (Int.emod_nonneg _ hk'), Int.mul_emod, Int.emod_emod,\n    ← Int.mul_emod]\n\n"}
{"name":"Nat.exists_mul_emod_eq_one_of_coprime","module":"Mathlib.Data.Int.GCD","initialProofState":"k n : Nat\nhkn : n.Coprime k\nhk : LT.lt 1 k\n⊢ Exists fun m => Eq (HMod.hMod (HMul.hMul n m) k) 1","decl":"theorem exists_mul_emod_eq_one_of_coprime {k n : ℕ} (hkn : Coprime n k) (hk : 1 < k) :\n    ∃ m, n * m % k = 1 :=\n  Exists.recOn (exists_mul_emod_eq_gcd (lt_of_le_of_lt (le_of_eq hkn) hk)) fun m hm ↦\n    ⟨m, hm.trans hkn⟩\n\n"}
{"name":"Int.gcd_def","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Eq (i.gcd j) (i.natAbs.gcd j.natAbs)","decl":"theorem gcd_def (i j : ℤ) : gcd i j = Nat.gcd i.natAbs j.natAbs := rfl\n\n"}
{"name":"Int.gcd_natCast_natCast","module":"Mathlib.Data.Int.GCD","initialProofState":"m n : Nat\n⊢ Eq ((↑m).gcd ↑n) (m.gcd n)","decl":"@[simp, norm_cast] protected lemma gcd_natCast_natCast (m n : ℕ) : gcd ↑m ↑n = m.gcd n := rfl\n\n"}
{"name":"Int.gcd_eq_gcd_ab","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Int\n⊢ Eq (↑(x.gcd y)) (HAdd.hAdd (HMul.hMul x (x.gcdA y)) (HMul.hMul y (x.gcdB y)))","decl":"/-- **Bézout's lemma** -/\ntheorem gcd_eq_gcd_ab : ∀ x y : ℤ, (gcd x y : ℤ) = x * gcdA x y + y * gcdB x y\n  | (m : ℕ), (n : ℕ) => Nat.gcd_eq_gcd_ab _ _\n  | (m : ℕ), -[n+1] =>\n    show (_ : ℤ) = _ + -(n + 1) * -_ by rw [Int.neg_mul_neg]; apply Nat.gcd_eq_gcd_ab\n  | -[m+1], (n : ℕ) =>\n    show (_ : ℤ) = -(m + 1) * -_ + _ by rw [Int.neg_mul_neg]; apply Nat.gcd_eq_gcd_ab\n  | -[m+1], -[n+1] =>\n    show (_ : ℤ) = -(m + 1) * -_ + -(n + 1) * -_ by\n      rw [Int.neg_mul_neg, Int.neg_mul_neg]\n      apply Nat.gcd_eq_gcd_ab\n\n"}
{"name":"Int.lcm_def","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Eq (i.lcm j) (i.natAbs.lcm j.natAbs)","decl":"theorem lcm_def (i j : ℤ) : lcm i j = Nat.lcm (natAbs i) (natAbs j) :=\n  rfl\n\n"}
{"name":"Int.coe_nat_lcm","module":"Mathlib.Data.Int.GCD","initialProofState":"m n : Nat\n⊢ Eq ((↑m).lcm ↑n) (m.lcm n)","decl":"protected theorem coe_nat_lcm (m n : ℕ) : Int.lcm ↑m ↑n = Nat.lcm m n :=\n  rfl\n\n"}
{"name":"Int.dvd_gcd","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\nh1 : Dvd.dvd k i\nh2 : Dvd.dvd k j\n⊢ Dvd.dvd k ↑(i.gcd j)","decl":"theorem dvd_gcd {i j k : ℤ} (h1 : k ∣ i) (h2 : k ∣ j) : k ∣ gcd i j :=\n  natAbs_dvd.1 <|\n    natCast_dvd_natCast.2 <| Nat.dvd_gcd (natAbs_dvd_natAbs.2 h1) (natAbs_dvd_natAbs.2 h2)\n\n"}
{"name":"Int.gcd_mul_lcm","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Eq (HMul.hMul (i.gcd j) (i.lcm j)) (HMul.hMul i j).natAbs","decl":"theorem gcd_mul_lcm (i j : ℤ) : gcd i j * lcm i j = natAbs (i * j) := by\n  rw [Int.gcd, Int.lcm, Nat.gcd_mul_lcm, natAbs_mul]\n\n"}
{"name":"Int.gcd_comm","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Eq (i.gcd j) (j.gcd i)","decl":"theorem gcd_comm (i j : ℤ) : gcd i j = gcd j i :=\n  Nat.gcd_comm _ _\n\n"}
{"name":"Int.gcd_assoc","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Eq ((↑(i.gcd j)).gcd k) (i.gcd ↑(j.gcd k))","decl":"theorem gcd_assoc (i j k : ℤ) : gcd (gcd i j) k = gcd i (gcd j k) :=\n  Nat.gcd_assoc _ _ _\n\n"}
{"name":"Int.gcd_self","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (i.gcd i) i.natAbs","decl":"@[simp]\ntheorem gcd_self (i : ℤ) : gcd i i = natAbs i := by simp [gcd]\n\n"}
{"name":"Int.gcd_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (Int.gcd 0 i) i.natAbs","decl":"@[simp]\ntheorem gcd_zero_left (i : ℤ) : gcd 0 i = natAbs i := by simp [gcd]\n\n"}
{"name":"Int.gcd_zero_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (i.gcd 0) i.natAbs","decl":"@[simp]\ntheorem gcd_zero_right (i : ℤ) : gcd i 0 = natAbs i := by simp [gcd]\n\n"}
{"name":"Int.gcd_mul_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Eq ((HMul.hMul i j).gcd (HMul.hMul i k)) (HMul.hMul i.natAbs (j.gcd k))","decl":"theorem gcd_mul_left (i j k : ℤ) : gcd (i * j) (i * k) = natAbs i * gcd j k := by\n  rw [Int.gcd, Int.gcd, natAbs_mul, natAbs_mul]\n  apply Nat.gcd_mul_left\n\n"}
{"name":"Int.gcd_mul_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Eq ((HMul.hMul i j).gcd (HMul.hMul k j)) (HMul.hMul (i.gcd k) j.natAbs)","decl":"theorem gcd_mul_right (i j k : ℤ) : gcd (i * j) (k * j) = gcd i k * natAbs j := by\n  rw [Int.gcd, Int.gcd, natAbs_mul, natAbs_mul]\n  apply Nat.gcd_mul_right\n\n"}
{"name":"Int.gcd_pos_of_ne_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\nhi : Ne i 0\n⊢ LT.lt 0 (i.gcd j)","decl":"theorem gcd_pos_of_ne_zero_left {i : ℤ} (j : ℤ) (hi : i ≠ 0) : 0 < gcd i j :=\n  Nat.gcd_pos_of_pos_left _ <| natAbs_pos.2 hi\n\n"}
{"name":"Int.gcd_pos_of_ne_zero_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\nhj : Ne j 0\n⊢ LT.lt 0 (i.gcd j)","decl":"theorem gcd_pos_of_ne_zero_right (i : ℤ) {j : ℤ} (hj : j ≠ 0) : 0 < gcd i j :=\n  Nat.gcd_pos_of_pos_right _ <| natAbs_pos.2 hj\n\n"}
{"name":"Int.gcd_eq_zero_iff","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Iff (Eq (i.gcd j) 0) (And (Eq i 0) (Eq j 0))","decl":"theorem gcd_eq_zero_iff {i j : ℤ} : gcd i j = 0 ↔ i = 0 ∧ j = 0 := by\n  rw [gcd, Nat.gcd_eq_zero_iff, natAbs_eq_zero, natAbs_eq_zero]\n\n"}
{"name":"Int.gcd_pos_iff","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Iff (LT.lt 0 (i.gcd j)) (Or (Ne i 0) (Ne j 0))","decl":"theorem gcd_pos_iff {i j : ℤ} : 0 < gcd i j ↔ i ≠ 0 ∨ j ≠ 0 :=\n  Nat.pos_iff_ne_zero.trans <| gcd_eq_zero_iff.not.trans not_and_or\n\n"}
{"name":"Int.gcd_div","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\nH1 : Dvd.dvd k i\nH2 : Dvd.dvd k j\n⊢ Eq ((HDiv.hDiv i k).gcd (HDiv.hDiv j k)) (HDiv.hDiv (i.gcd j) k.natAbs)","decl":"theorem gcd_div {i j k : ℤ} (H1 : k ∣ i) (H2 : k ∣ j) :\n    gcd (i / k) (j / k) = gcd i j / natAbs k := by\n  rw [gcd, natAbs_ediv i k H1, natAbs_ediv j k H2]\n  exact Nat.gcd_div (natAbs_dvd_natAbs.mpr H1) (natAbs_dvd_natAbs.mpr H2)\n\n"}
{"name":"Int.gcd_div_gcd_div_gcd","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\nH : LT.lt 0 (i.gcd j)\n⊢ Eq ((HDiv.hDiv i ↑(i.gcd j)).gcd (HDiv.hDiv j ↑(i.gcd j))) 1","decl":"theorem gcd_div_gcd_div_gcd {i j : ℤ} (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1 := by\n  rw [gcd_div gcd_dvd_left gcd_dvd_right, natAbs_ofNat, Nat.div_self H]\n\n"}
{"name":"Int.gcd_dvd_gcd_of_dvd_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i k j : Int\nH : Dvd.dvd i k\n⊢ Dvd.dvd (i.gcd j) (k.gcd j)","decl":"theorem gcd_dvd_gcd_of_dvd_left {i k : ℤ} (j : ℤ) (H : i ∣ k) : gcd i j ∣ gcd k j :=\n  Int.natCast_dvd_natCast.1 <| dvd_gcd (gcd_dvd_left.trans H) gcd_dvd_right\n\n"}
{"name":"Int.gcd_dvd_gcd_of_dvd_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i k j : Int\nH : Dvd.dvd i k\n⊢ Dvd.dvd (j.gcd i) (j.gcd k)","decl":"theorem gcd_dvd_gcd_of_dvd_right {i k : ℤ} (j : ℤ) (H : i ∣ k) : gcd j i ∣ gcd j k :=\n  Int.natCast_dvd_natCast.1 <| dvd_gcd gcd_dvd_left (gcd_dvd_right.trans H)\n\n"}
{"name":"Int.gcd_dvd_gcd_mul_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Dvd.dvd (i.gcd j) ((HMul.hMul k i).gcd j)","decl":"theorem gcd_dvd_gcd_mul_left (i j k : ℤ) : gcd i j ∣ gcd (k * i) j :=\n  gcd_dvd_gcd_of_dvd_left _ (dvd_mul_left _ _)\n\n"}
{"name":"Int.gcd_dvd_gcd_mul_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Dvd.dvd (i.gcd j) ((HMul.hMul i k).gcd j)","decl":"theorem gcd_dvd_gcd_mul_right (i j k : ℤ) : gcd i j ∣ gcd (i * k) j :=\n  gcd_dvd_gcd_of_dvd_left _ (dvd_mul_right _ _)\n\n"}
{"name":"Int.gcd_dvd_gcd_mul_left_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Dvd.dvd (i.gcd j) (i.gcd (HMul.hMul k j))","decl":"theorem gcd_dvd_gcd_mul_left_right (i j k : ℤ) : gcd i j ∣ gcd i (k * j) :=\n  gcd_dvd_gcd_of_dvd_right _ (dvd_mul_left _ _)\n\n"}
{"name":"Int.gcd_dvd_gcd_mul_right_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Dvd.dvd (i.gcd j) (i.gcd (HMul.hMul j k))","decl":"theorem gcd_dvd_gcd_mul_right_right (i j k : ℤ) : gcd i j ∣ gcd i (j * k) :=\n  gcd_dvd_gcd_of_dvd_right _ (dvd_mul_right _ _)\n\n"}
{"name":"Int.gcd_eq_one_of_gcd_mul_right_eq_one_left","module":"Mathlib.Data.Int.GCD","initialProofState":"a : Int\nm n : Nat\nh : Eq (a.gcd (HMul.hMul ↑m ↑n)) 1\n⊢ Eq (a.gcd ↑m) 1","decl":"/-- If `gcd a (m * n) = 1`, then `gcd a m = 1`. -/\ntheorem gcd_eq_one_of_gcd_mul_right_eq_one_left {a : ℤ} {m n : ℕ} (h : a.gcd (m * n) = 1) :\n    a.gcd m = 1 :=\n  Nat.dvd_one.mp <| h ▸ gcd_dvd_gcd_mul_right_right a m n\n\n"}
{"name":"Int.gcd_eq_one_of_gcd_mul_right_eq_one_right","module":"Mathlib.Data.Int.GCD","initialProofState":"a : Int\nm n : Nat\nh : Eq (a.gcd (HMul.hMul ↑m ↑n)) 1\n⊢ Eq (a.gcd ↑n) 1","decl":"/-- If `gcd a (m * n) = 1`, then `gcd a n = 1`. -/\ntheorem gcd_eq_one_of_gcd_mul_right_eq_one_right {a : ℤ} {m n : ℕ} (h : a.gcd (m * n) = 1) :\n    a.gcd n = 1 :=\n  Nat.dvd_one.mp <| h ▸ gcd_dvd_gcd_mul_left_right a n m\n\n"}
{"name":"Int.gcd_eq_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\nH : Dvd.dvd i j\n⊢ Eq (i.gcd j) i.natAbs","decl":"theorem gcd_eq_left {i j : ℤ} (H : i ∣ j) : gcd i j = natAbs i :=\n  Nat.dvd_antisymm (Nat.gcd_dvd_left _ _) (Nat.dvd_gcd dvd_rfl (natAbs_dvd_natAbs.mpr H))\n\n"}
{"name":"Int.gcd_eq_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\nH : Dvd.dvd j i\n⊢ Eq (i.gcd j) j.natAbs","decl":"theorem gcd_eq_right {i j : ℤ} (H : j ∣ i) : gcd i j = natAbs j := by rw [gcd_comm, gcd_eq_left H]\n\n"}
{"name":"Int.ne_zero_of_gcd","module":"Mathlib.Data.Int.GCD","initialProofState":"x y : Int\nhc : Ne (x.gcd y) 0\n⊢ Or (Ne x 0) (Ne y 0)","decl":"theorem ne_zero_of_gcd {x y : ℤ} (hc : gcd x y ≠ 0) : x ≠ 0 ∨ y ≠ 0 := by\n  contrapose! hc\n  rw [hc.left, hc.right, gcd_zero_right, natAbs_zero]\n\n"}
{"name":"Int.exists_gcd_one","module":"Mathlib.Data.Int.GCD","initialProofState":"m n : Int\nH : LT.lt 0 (m.gcd n)\n⊢ Exists fun m' => Exists fun n' => And (Eq (m'.gcd n') 1) (And (Eq m (HMul.hMul m' ↑(m.gcd n))) (Eq n (HMul.hMul n' ↑(m.gcd n))))","decl":"theorem exists_gcd_one {m n : ℤ} (H : 0 < gcd m n) :\n    ∃ m' n' : ℤ, gcd m' n' = 1 ∧ m = m' * gcd m n ∧ n = n' * gcd m n :=\n  ⟨_, _, gcd_div_gcd_div_gcd H, (Int.ediv_mul_cancel gcd_dvd_left).symm,\n    (Int.ediv_mul_cancel gcd_dvd_right).symm⟩\n\n"}
{"name":"Int.exists_gcd_one'","module":"Mathlib.Data.Int.GCD","initialProofState":"m n : Int\nH : LT.lt 0 (m.gcd n)\n⊢ Exists fun g => Exists fun m' => Exists fun n' => And (LT.lt 0 g) (And (Eq (m'.gcd n') 1) (And (Eq m (HMul.hMul m' ↑g)) (Eq n (HMul.hMul n' ↑g))))","decl":"theorem exists_gcd_one' {m n : ℤ} (H : 0 < gcd m n) :\n    ∃ (g : ℕ) (m' n' : ℤ), 0 < g ∧ gcd m' n' = 1 ∧ m = m' * g ∧ n = n' * g :=\n  let ⟨m', n', h⟩ := exists_gcd_one H\n  ⟨_, m', n', H, h⟩\n\n"}
{"name":"Int.pow_dvd_pow_iff","module":"Mathlib.Data.Int.GCD","initialProofState":"m n : Int\nk : Nat\nk0 : Ne k 0\n⊢ Iff (Dvd.dvd (HPow.hPow m k) (HPow.hPow n k)) (Dvd.dvd m n)","decl":"theorem pow_dvd_pow_iff {m n : ℤ} {k : ℕ} (k0 : k ≠ 0) : m ^ k ∣ n ^ k ↔ m ∣ n := by\n  refine ⟨fun h => ?_, fun h => pow_dvd_pow_of_dvd h _⟩\n  rwa [← natAbs_dvd_natAbs, ← Nat.pow_dvd_pow_iff k0, ← Int.natAbs_pow, ← Int.natAbs_pow,\n    natAbs_dvd_natAbs]\n\n"}
{"name":"Int.gcd_dvd_iff","module":"Mathlib.Data.Int.GCD","initialProofState":"a b : Int\nn : Nat\n⊢ Iff (Dvd.dvd (a.gcd b) n) (Exists fun x => Exists fun y => Eq (↑n) (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)))","decl":"theorem gcd_dvd_iff {a b : ℤ} {n : ℕ} : gcd a b ∣ n ↔ ∃ x y : ℤ, ↑n = a * x + b * y := by\n  constructor\n  · intro h\n    rw [← Nat.mul_div_cancel' h, Int.ofNat_mul, gcd_eq_gcd_ab, Int.add_mul, mul_assoc, mul_assoc]\n    exact ⟨_, _, rfl⟩\n  · rintro ⟨x, y, h⟩\n    rw [← Int.natCast_dvd_natCast, h]\n    exact Int.dvd_add (dvd_mul_of_dvd_left gcd_dvd_left _) (dvd_mul_of_dvd_left gcd_dvd_right y)\n\n"}
{"name":"Int.gcd_greatest","module":"Mathlib.Data.Int.GCD","initialProofState":"a b d : Int\nhd_pos : LE.le 0 d\nhda : Dvd.dvd d a\nhdb : Dvd.dvd d b\nhd : ∀ (e : Int), Dvd.dvd e a → Dvd.dvd e b → Dvd.dvd e d\n⊢ Eq d ↑(a.gcd b)","decl":"theorem gcd_greatest {a b d : ℤ} (hd_pos : 0 ≤ d) (hda : d ∣ a) (hdb : d ∣ b)\n    (hd : ∀ e : ℤ, e ∣ a → e ∣ b → e ∣ d) : d = gcd a b :=\n  dvd_antisymm hd_pos (ofNat_zero_le (gcd a b)) (dvd_gcd hda hdb)\n    (hd _ gcd_dvd_left gcd_dvd_right)\n\n"}
{"name":"Int.dvd_of_dvd_mul_left_of_gcd_one","module":"Mathlib.Data.Int.GCD","initialProofState":"a b c : Int\nhabc : Dvd.dvd a (HMul.hMul b c)\nhab : Eq (a.gcd c) 1\n⊢ Dvd.dvd a b","decl":"/-- Euclid's lemma: if `a ∣ b * c` and `gcd a c = 1` then `a ∣ b`.\nCompare with `IsCoprime.dvd_of_dvd_mul_left` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors` -/\ntheorem dvd_of_dvd_mul_left_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : gcd a c = 1) :\n    a ∣ b := by\n  have := gcd_eq_gcd_ab a c\n  simp only [hab, Int.ofNat_zero, Int.ofNat_succ, zero_add] at this\n  have : b * a * gcdA a c + b * c * gcdB a c = b := by simp [mul_assoc, ← Int.mul_add, ← this]\n  rw [← this]\n  exact Int.dvd_add (dvd_mul_of_dvd_left (dvd_mul_left a b) _) (dvd_mul_of_dvd_left habc _)\n\n"}
{"name":"Int.dvd_of_dvd_mul_right_of_gcd_one","module":"Mathlib.Data.Int.GCD","initialProofState":"a b c : Int\nhabc : Dvd.dvd a (HMul.hMul b c)\nhab : Eq (a.gcd b) 1\n⊢ Dvd.dvd a c","decl":"/-- Euclid's lemma: if `a ∣ b * c` and `gcd a b = 1` then `a ∣ c`.\nCompare with `IsCoprime.dvd_of_dvd_mul_right` and\n`UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors` -/\ntheorem dvd_of_dvd_mul_right_of_gcd_one {a b c : ℤ} (habc : a ∣ b * c) (hab : gcd a b = 1) :\n    a ∣ c := by\n  rw [mul_comm] at habc\n  exact dvd_of_dvd_mul_left_of_gcd_one habc hab\n\n"}
{"name":"Int.gcd_least_linear","module":"Mathlib.Data.Int.GCD","initialProofState":"a b : Int\nha : Ne a 0\n⊢ IsLeast (setOf fun n => And (LT.lt 0 n) (Exists fun x => Exists fun y => Eq (↑n) (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)))) (a.gcd b)","decl":"/-- For nonzero integers `a` and `b`, `gcd a b` is the smallest positive natural number that can be\nwritten in the form `a * x + b * y` for some pair of integers `x` and `y` -/\ntheorem gcd_least_linear {a b : ℤ} (ha : a ≠ 0) :\n    IsLeast { n : ℕ | 0 < n ∧ ∃ x y : ℤ, ↑n = a * x + b * y } (a.gcd b) := by\n  simp_rw [← gcd_dvd_iff]\n  constructor\n  · simpa [and_true, dvd_refl, Set.mem_setOf_eq] using gcd_pos_of_ne_zero_left b ha\n  · simp only [lowerBounds, and_imp, Set.mem_setOf_eq]\n    exact fun n hn_pos hn => Nat.le_of_dvd hn_pos hn\n\n"}
{"name":"Int.lcm_comm","module":"Mathlib.Data.Int.GCD","initialProofState":"i j : Int\n⊢ Eq (i.lcm j) (j.lcm i)","decl":"theorem lcm_comm (i j : ℤ) : lcm i j = lcm j i := by\n  rw [Int.lcm, Int.lcm]\n  exact Nat.lcm_comm _ _\n\n"}
{"name":"Int.lcm_assoc","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\n⊢ Eq ((↑(i.lcm j)).lcm k) (i.lcm ↑(j.lcm k))","decl":"theorem lcm_assoc (i j k : ℤ) : lcm (lcm i j) k = lcm i (lcm j k) := by\n  rw [Int.lcm, Int.lcm, Int.lcm, Int.lcm, natAbs_ofNat, natAbs_ofNat]\n  apply Nat.lcm_assoc\n\n"}
{"name":"Int.lcm_zero_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (Int.lcm 0 i) 0","decl":"@[simp]\ntheorem lcm_zero_left (i : ℤ) : lcm 0 i = 0 := by\n  rw [Int.lcm]\n  apply Nat.lcm_zero_left\n\n"}
{"name":"Int.lcm_zero_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (i.lcm 0) 0","decl":"@[simp]\ntheorem lcm_zero_right (i : ℤ) : lcm i 0 = 0 := by\n  rw [Int.lcm]\n  apply Nat.lcm_zero_right\n\n"}
{"name":"Int.lcm_one_left","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (Int.lcm 1 i) i.natAbs","decl":"@[simp]\ntheorem lcm_one_left (i : ℤ) : lcm 1 i = natAbs i := by\n  rw [Int.lcm]\n  apply Nat.lcm_one_left\n\n"}
{"name":"Int.lcm_one_right","module":"Mathlib.Data.Int.GCD","initialProofState":"i : Int\n⊢ Eq (i.lcm 1) i.natAbs","decl":"@[simp]\ntheorem lcm_one_right (i : ℤ) : lcm i 1 = natAbs i := by\n  rw [Int.lcm]\n  apply Nat.lcm_one_right\n\n"}
{"name":"Int.lcm_dvd","module":"Mathlib.Data.Int.GCD","initialProofState":"i j k : Int\na✝¹ : Dvd.dvd i k\na✝ : Dvd.dvd j k\n⊢ Dvd.dvd (↑(i.lcm j)) k","decl":"theorem lcm_dvd {i j k : ℤ} : i ∣ k → j ∣ k → (lcm i j : ℤ) ∣ k := by\n  rw [Int.lcm]\n  intro hi hj\n  exact natCast_dvd.mpr (Nat.lcm_dvd (natAbs_dvd_natAbs.mpr hi) (natAbs_dvd_natAbs.mpr hj))\n\n"}
{"name":"Int.lcm_mul_left","module":"Mathlib.Data.Int.GCD","initialProofState":"m n k : Int\n⊢ Eq ((HMul.hMul m n).lcm (HMul.hMul m k)) (HMul.hMul m.natAbs (n.lcm k))","decl":"theorem lcm_mul_left {m n k : ℤ} : (m * n).lcm (m * k) = natAbs m * n.lcm k := by\n  simp_rw [Int.lcm, natAbs_mul, Nat.lcm_mul_left]\n\n"}
{"name":"Int.lcm_mul_right","module":"Mathlib.Data.Int.GCD","initialProofState":"m n k : Int\n⊢ Eq ((HMul.hMul m n).lcm (HMul.hMul k n)) (HMul.hMul (m.lcm k) n.natAbs)","decl":"theorem lcm_mul_right {m n k : ℤ} : (m * n).lcm (k * n) = m.lcm k * natAbs n := by\n  simp_rw [Int.lcm, natAbs_mul, Nat.lcm_mul_right]\n\n"}
{"name":"pow_gcd_eq_one","module":"Mathlib.Data.Int.GCD","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\nm n : Nat\nhm : Eq (HPow.hPow x m) 1\nhn : Eq (HPow.hPow x n) 1\n⊢ Eq (HPow.hPow x (m.gcd n)) 1","decl":"@[to_additive gcd_nsmul_eq_zero]\ntheorem pow_gcd_eq_one {M : Type*} [Monoid M] (x : M) {m n : ℕ} (hm : x ^ m = 1) (hn : x ^ n = 1) :\n    x ^ m.gcd n = 1 := by\n  rcases m with (rfl | m); · simp [hn]\n  obtain ⟨y, rfl⟩ := isUnit_ofPowEqOne hm m.succ_ne_zero\n  rw [← Units.val_pow_eq_pow_val, ← Units.val_one (α := M), ← zpow_natCast, ← Units.ext_iff] at *\n  rw [Nat.gcd_eq_gcd_ab, zpow_add, zpow_mul, zpow_mul, hn, hm, one_zpow, one_zpow, one_mul]\n\n"}
{"name":"gcd_nsmul_eq_zero","module":"Mathlib.Data.Int.GCD","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : M\nm n : Nat\nhm : Eq (HSMul.hSMul m x) 0\nhn : Eq (HSMul.hSMul n x) 0\n⊢ Eq (HSMul.hSMul (m.gcd n) x) 0","decl":"@[to_additive gcd_nsmul_eq_zero]\ntheorem pow_gcd_eq_one {M : Type*} [Monoid M] (x : M) {m n : ℕ} (hm : x ^ m = 1) (hn : x ^ n = 1) :\n    x ^ m.gcd n = 1 := by\n  rcases m with (rfl | m); · simp [hn]\n  obtain ⟨y, rfl⟩ := isUnit_ofPowEqOne hm m.succ_ne_zero\n  rw [← Units.val_pow_eq_pow_val, ← Units.val_one (α := M), ← zpow_natCast, ← Units.ext_iff] at *\n  rw [Nat.gcd_eq_gcd_ab, zpow_add, zpow_mul, zpow_mul, hn, hm, one_zpow, one_zpow, one_mul]\n\n"}
{"name":"Commute.pow_eq_pow_iff_of_coprime","module":"Mathlib.Data.Int.GCD","initialProofState":"α : Type u_1\ninst✝ : GroupWithZero α\na b : α\nm n : Nat\nhab : Commute a b\nhmn : m.Coprime n\n⊢ Iff (Eq (HPow.hPow a m) (HPow.hPow b n)) (Exists fun c => And (Eq a (HPow.hPow c n)) (Eq b (HPow.hPow c m)))","decl":"protected lemma Commute.pow_eq_pow_iff_of_coprime (hab : Commute a b) (hmn : m.Coprime n) :\n    a ^ m = b ^ n ↔ ∃ c, a = c ^ n ∧ b = c ^ m := by\n  refine ⟨fun h ↦ ?_, by rintro ⟨c, rfl, rfl⟩; rw [← pow_mul, ← pow_mul']⟩\n  by_cases m = 0; · aesop\n  by_cases n = 0; · aesop\n  by_cases hb : b = 0; · exact ⟨0, by aesop⟩\n  by_cases ha : a = 0; · exact ⟨0, by have := h.symm; aesop⟩\n  refine ⟨a ^ Nat.gcdB m n * b ^ Nat.gcdA m n, ?_, ?_⟩ <;>\n  · refine (pow_one _).symm.trans ?_\n    conv_lhs => rw [← zpow_natCast, ← hmn, Nat.gcd_eq_gcd_ab]\n    simp only [zpow_add₀ ha, zpow_add₀ hb, ← zpow_natCast, (hab.zpow_zpow₀ _ _).mul_zpow,\n      ← zpow_mul, mul_comm (Nat.gcdB m n), mul_comm (Nat.gcdA m n)]\n    simp only [zpow_mul, zpow_natCast, h]\n    exact ((Commute.pow_pow (by aesop) _ _).zpow_zpow₀ _ _).symm\n\n"}
{"name":"pow_eq_pow_iff_of_coprime","module":"Mathlib.Data.Int.GCD","initialProofState":"α : Type u_1\ninst✝ : CommGroupWithZero α\na b : α\nm n : Nat\nhmn : m.Coprime n\n⊢ Iff (Eq (HPow.hPow a m) (HPow.hPow b n)) (Exists fun c => And (Eq a (HPow.hPow c n)) (Eq b (HPow.hPow c m)))","decl":"lemma pow_eq_pow_iff_of_coprime (hmn : m.Coprime n) : a ^ m = b ^ n ↔ ∃ c, a = c ^ n ∧ b = c ^ m :=\n  (Commute.all _ _).pow_eq_pow_iff_of_coprime hmn\n\n"}
{"name":"pow_mem_range_pow_of_coprime","module":"Mathlib.Data.Int.GCD","initialProofState":"α : Type u_1\ninst✝ : CommGroupWithZero α\nm n : Nat\nhmn : m.Coprime n\na : α\n⊢ Iff (Membership.mem (Set.range fun x => HPow.hPow x n) (HPow.hPow a m)) (Membership.mem (Set.range fun x => HPow.hPow x n) a)","decl":"lemma pow_mem_range_pow_of_coprime (hmn : m.Coprime n) (a : α) :\n    a ^ m ∈ Set.range (· ^ n : α → α) ↔ a ∈ Set.range (· ^ n : α → α) := by\n  simp [pow_eq_pow_iff_of_coprime hmn.symm]; aesop\n\n"}
