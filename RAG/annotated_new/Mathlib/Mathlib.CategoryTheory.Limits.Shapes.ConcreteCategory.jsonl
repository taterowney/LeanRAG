{"name":"CategoryTheory.Limits.Concrete.productEquiv_apply_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\nF : J → C\ninst✝¹ : CategoryTheory.Limits.HasProduct F\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor F) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.piObj F)\nj : J\n⊢ Eq ((CategoryTheory.Limits.Concrete.productEquiv F) x j) ((CategoryTheory.Limits.Pi.π F j) x)","decl":"@[simp]\nlemma productEquiv_apply_apply (x : (forget C).obj (∏ᶜ F)) (j : J) :\n    productEquiv F x j = Pi.π F j x :=\n  congr_fun (piComparison_comp_π (forget C) F j) x\n\n"}
{"name":"CategoryTheory.Limits.Concrete.productEquiv_symm_apply_π","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\nF : J → C\ninst✝¹ : CategoryTheory.Limits.HasProduct F\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor F) (CategoryTheory.forget C)\nx : (j : J) → (CategoryTheory.forget C).obj (F j)\nj : J\n⊢ Eq ((CategoryTheory.Limits.Pi.π F j) ((CategoryTheory.Limits.Concrete.productEquiv F).symm x)) (x j)","decl":"@[simp]\nlemma productEquiv_symm_apply_π (x : ∀ j, F j) (j : J) :\n    Pi.π F j ((productEquiv F).symm x) = x j := by\n  rw [← productEquiv_apply_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Limits.Concrete.Pi.map_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nJ : Type w\nf : J → C\ninst✝⁶ : CategoryTheory.Limits.HasProduct f\nD : Type t\ninst✝⁵ : CategoryTheory.Category.{r, t} D\ninst✝⁴ : CategoryTheory.HasForget D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F\ninst✝² : CategoryTheory.Limits.HasProduct fun j => F.obj (f j)\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingCospan (CategoryTheory.forget D)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor fun b => F.obj (f b)) (CategoryTheory.forget D)\nx y : (CategoryTheory.forget D).obj (F.obj (CategoryTheory.Limits.piObj f))\nh : ∀ (i : J), Eq ((F.map (CategoryTheory.Limits.Pi.π f i)) x) ((F.map (CategoryTheory.Limits.Pi.π f i)) y)\n⊢ Eq x y","decl":"lemma Pi.map_ext (x y : F.obj (∏ᶜ f : C))\n    (h : ∀ i, F.map (Pi.π f i) x = F.map (Pi.π f i) y) : x = y := by\n  apply ConcreteCategory.injective_of_mono_of_preservesPullback (PreservesProduct.iso F f).hom\n  apply @Concrete.limit_ext.{w, w, r, t} D\n    _ _ (Discrete J) _ _ _ _ (piComparison F _ x) (piComparison F _ y)\n  intro ⟨(j : J)⟩\n  show ((forget D).map (piComparison F f) ≫ (forget D).map (limit.π _ _)) x =\n    ((forget D).map (piComparison F f) ≫ (forget D).map _) y\n  rw [← (forget D).map_comp, piComparison_comp_π]\n  exact h j\n\n"}
{"name":"CategoryTheory.Limits.Concrete.empty_of_initial_of_preserves","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (CategoryTheory.forget C)\nX : C\nh : Nonempty (CategoryTheory.Limits.IsInitial X)\n⊢ IsEmpty ((CategoryTheory.forget C).obj X)","decl":"/-- If `forget C` preserves initials and `X` is initial, then `(forget C).obj X` is empty. -/\nlemma empty_of_initial_of_preserves [PreservesColimit (Functor.empty.{0} C) (forget C)] (X : C)\n    (h : Nonempty (IsInitial X)) : IsEmpty ((forget C).obj X) := by\n  rw [← Types.initial_iff_empty]\n  exact Nonempty.map (IsInitial.isInitialObj (forget C) _) h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.initial_of_empty_of_reflects","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Functor.empty C) (CategoryTheory.forget C)\nX : C\nh : IsEmpty ((CategoryTheory.forget C).obj X)\n⊢ Nonempty (CategoryTheory.Limits.IsInitial X)","decl":"/-- If `forget C` reflects initials and `(forget C).obj X` is empty, then `X` is initial. -/\nlemma initial_of_empty_of_reflects [ReflectsColimit (Functor.empty.{0} C) (forget C)] (X : C)\n    (h : IsEmpty ((forget C).obj X)) : Nonempty (IsInitial X) :=\n  Nonempty.map (IsInitial.isInitialOfObj (forget C) _) <|\n    (Types.initial_iff_empty ((forget C).obj X)).mpr h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.initial_iff_empty_of_preserves_of_reflects","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) (CategoryTheory.forget C)\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Functor.empty C) (CategoryTheory.forget C)\nX : C\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsInitial X)) (IsEmpty ((CategoryTheory.forget C).obj X))","decl":"/-- If `forget C` preserves and reflects initials, then `X` is initial if and only if\n`(forget C).obj X` is empty. -/\nlemma initial_iff_empty_of_preserves_of_reflects [PreservesColimit (Functor.empty.{0} C) (forget C)]\n    [ReflectsColimit (Functor.empty.{0} C) (forget C)] (X : C) :\n    Nonempty (IsInitial X) ↔ IsEmpty ((forget C).obj X) := by\n  rw [← Types.initial_iff_empty, (IsInitial.isInitialIffObj (forget C) X).nonempty_congr]\n\n"}
{"name":"CategoryTheory.Limits.Concrete.prodEquiv_apply_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X₁ X₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X₁ X₂) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.prod X₁ X₂)\n⊢ Eq ((CategoryTheory.Limits.Concrete.prodEquiv X₁ X₂) x).1 (CategoryTheory.Limits.prod.fst x)","decl":"@[simp]\nlemma prodEquiv_apply_fst (x : (forget C).obj (X₁ ⨯ X₂)) :\n    (prodEquiv X₁ X₂ x).fst = (Limits.prod.fst : X₁ ⨯ X₂ ⟶ X₁) x :=\n  congr_fun (prodComparison_fst (forget C) X₁ X₂) x\n\n"}
{"name":"CategoryTheory.Limits.Concrete.prodEquiv_apply_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X₁ X₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X₁ X₂) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.prod X₁ X₂)\n⊢ Eq ((CategoryTheory.Limits.Concrete.prodEquiv X₁ X₂) x).2 (CategoryTheory.Limits.prod.snd x)","decl":"@[simp]\nlemma prodEquiv_apply_snd (x : (forget C).obj (X₁ ⨯ X₂)) :\n    (prodEquiv X₁ X₂ x).snd = (Limits.prod.snd : X₁ ⨯ X₂ ⟶ X₂) x :=\n  congr_fun (prodComparison_snd (forget C) X₁ X₂) x\n\n"}
{"name":"CategoryTheory.Limits.Concrete.prodEquiv_symm_apply_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X₁ X₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X₁ X₂) (CategoryTheory.forget C)\nx : Prod ((CategoryTheory.forget C).obj X₁) ((CategoryTheory.forget C).obj X₂)\n⊢ Eq (CategoryTheory.Limits.prod.fst ((CategoryTheory.Limits.Concrete.prodEquiv X₁ X₂).symm x)) x.1","decl":"@[simp]\nlemma prodEquiv_symm_apply_fst (x : X₁ × X₂) :\n    (Limits.prod.fst : X₁ ⨯ X₂ ⟶ X₁) ((prodEquiv X₁ X₂).symm x) = x.1 := by\n  obtain ⟨y, rfl⟩ := (prodEquiv X₁ X₂).surjective x\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Concrete.prodEquiv_symm_apply_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct X₁ X₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X₁ X₂) (CategoryTheory.forget C)\nx : Prod ((CategoryTheory.forget C).obj X₁) ((CategoryTheory.forget C).obj X₂)\n⊢ Eq (CategoryTheory.Limits.prod.snd ((CategoryTheory.Limits.Concrete.prodEquiv X₁ X₂).symm x)) x.2","decl":"@[simp]\nlemma prodEquiv_symm_apply_snd (x : X₁ × X₂) :\n    (Limits.prod.snd : X₁ ⨯ X₂ ⟶ X₂) ((prodEquiv X₁ X₂).symm x) = x.2 := by\n  obtain ⟨y, rfl⟩ := (prodEquiv X₁ X₂).surjective x\n  simp\n\n"}
{"name":"CategoryTheory.Limits.Concrete.pullbackMk_surjective","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ S : C\nf₁ : Quiver.Hom X₁ S\nf₂ : Quiver.Hom X₂ S\ninst✝¹ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f₁ f₂) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.pullback f₁ f₂)\n⊢ Exists fun x₁ => Exists fun x₂ => Exists fun h => Eq x (CategoryTheory.Limits.Concrete.pullbackMk f₁ f₂ x₁ x₂ h)","decl":"lemma pullbackMk_surjective (x : (forget C).obj (pullback f₁ f₂)) :\n    ∃ (x₁ : X₁) (x₂ : X₂) (h : f₁ x₁ = f₂ x₂), x = pullbackMk f₁ f₂ x₁ x₂ h := by\n  obtain ⟨⟨⟨x₁, x₂⟩, h⟩, rfl⟩ := (pullbackEquiv f₁ f₂).symm.surjective x\n  exact ⟨x₁, x₂, h, rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.Concrete.pullbackMk_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ S : C\nf₁ : Quiver.Hom X₁ S\nf₂ : Quiver.Hom X₂ S\ninst✝¹ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f₁ f₂) (CategoryTheory.forget C)\nx₁ : (CategoryTheory.forget C).obj X₁\nx₂ : (CategoryTheory.forget C).obj X₂\nh : Eq (f₁ x₁) (f₂ x₂)\n⊢ Eq ((CategoryTheory.Limits.pullback.fst f₁ f₂) (CategoryTheory.Limits.Concrete.pullbackMk f₁ f₂ x₁ x₂ h)) x₁","decl":"@[simp]\nlemma pullbackMk_fst (x₁ : X₁) (x₂ : X₂) (h : f₁ x₁ = f₂ x₂) :\n    pullback.fst f₁ f₂ (pullbackMk f₁ f₂ x₁ x₂ h) = x₁ :=\n  (congr_fun (PreservesPullback.iso_inv_fst (forget C) f₁ f₂) _).trans\n    (congr_fun (Types.pullbackIsoPullback_inv_fst ((forget C).map f₁) ((forget C).map f₂)) _)\n\n"}
{"name":"CategoryTheory.Limits.Concrete.pullbackMk_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX₁ X₂ S : C\nf₁ : Quiver.Hom X₁ S\nf₂ : Quiver.Hom X₂ S\ninst✝¹ : CategoryTheory.Limits.HasPullback f₁ f₂\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f₁ f₂) (CategoryTheory.forget C)\nx₁ : (CategoryTheory.forget C).obj X₁\nx₂ : (CategoryTheory.forget C).obj X₂\nh : Eq (f₁ x₁) (f₂ x₂)\n⊢ Eq ((CategoryTheory.Limits.pullback.snd f₁ f₂) (CategoryTheory.Limits.Concrete.pullbackMk f₁ f₂ x₁ x₂ h)) x₂","decl":"@[simp]\nlemma pullbackMk_snd (x₁ : X₁) (x₂ : X₂) (h : f₁ x₁ = f₂ x₂) :\n    pullback.snd f₁ f₂ (pullbackMk f₁ f₂ x₁ x₂ h) = x₂ :=\n  (congr_fun (PreservesPullback.iso_inv_snd (forget C) f₁ f₂) _).trans\n    (congr_fun (Types.pullbackIsoPullback_inv_snd ((forget C).map f₁) ((forget C).map f₂)) _)\n\n"}
{"name":"CategoryTheory.Limits.Concrete.widePullback_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nB : C\nι : Type w\nX : ι → C\nf : (j : ι) → Quiver.Hom (X j) B\ninst✝¹ : CategoryTheory.Limits.HasWidePullback B X f\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.WidePullbackShape.wideCospan B X f) (CategoryTheory.forget C)\nx y : (CategoryTheory.forget C).obj (CategoryTheory.Limits.widePullback B X f)\nh₀ : Eq ((CategoryTheory.Limits.WidePullback.base f) x) ((CategoryTheory.Limits.WidePullback.base f) y)\nh : ∀ (j : ι), Eq ((CategoryTheory.Limits.WidePullback.π f j) x) ((CategoryTheory.Limits.WidePullback.π f j) y)\n⊢ Eq x y","decl":"theorem widePullback_ext {B : C} {ι : Type w} {X : ι → C} (f : ∀ j : ι, X j ⟶ B)\n    [HasWidePullback B X f] [PreservesLimit (wideCospan B X f) (forget C)]\n    (x y : ↑(widePullback B X f)) (h₀ : base f x = base f y) (h : ∀ j, π f j x = π f j y) :\n    x = y := by\n  apply Concrete.limit_ext\n  rintro (_ | j)\n  · exact h₀\n  · apply h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.widePullback_ext'","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nB : C\nι : Type w\ninst✝² : Nonempty ι\nX : ι → C\nf : (j : ι) → Quiver.Hom (X j) B\ninst✝¹ : CategoryTheory.Limits.HasWidePullback B X f\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.WidePullbackShape.wideCospan B X f) (CategoryTheory.forget C)\nx y : (CategoryTheory.forget C).obj (CategoryTheory.Limits.widePullback B X f)\nh : ∀ (j : ι), Eq ((CategoryTheory.Limits.WidePullback.π f j) x) ((CategoryTheory.Limits.WidePullback.π f j) y)\n⊢ Eq x y","decl":"theorem widePullback_ext' {B : C} {ι : Type w} [Nonempty ι] {X : ι → C}\n    (f : ∀ j : ι, X j ⟶ B) [HasWidePullback.{w} B X f]\n    [PreservesLimit (wideCospan B X f) (forget C)] (x y : ↑(widePullback B X f))\n    (h : ∀ j, π f j x = π f j y) : x = y := by\n  apply Concrete.widePullback_ext _ _ _ _ h\n  inhabit ι\n  simp only [← π_arrow f default, CategoryTheory.comp_apply, h]\n\n"}
{"name":"CategoryTheory.Limits.Concrete.multiequalizer_ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasMultiequalizer I\ninst✝ : CategoryTheory.Limits.PreservesLimit I.multicospan (CategoryTheory.forget C)\nx y : (CategoryTheory.forget C).obj (CategoryTheory.Limits.multiequalizer I)\nh : ∀ (t : I.L), Eq ((CategoryTheory.Limits.Multiequalizer.ι I t) x) ((CategoryTheory.Limits.Multiequalizer.ι I t) y)\n⊢ Eq x y","decl":"theorem multiequalizer_ext {I : MulticospanIndex.{w, w'} C} [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x y : ↑(multiequalizer I))\n    (h : ∀ t : I.L, Multiequalizer.ι I t x = Multiequalizer.ι I t y) : x = y := by\n  apply Concrete.limit_ext\n  rintro (a | b)\n  · apply h\n  · rw [← limit.w I.multicospan (WalkingMulticospan.Hom.fst b), CategoryTheory.comp_apply,\n      CategoryTheory.comp_apply]\n    simp [h]\n\n"}
{"name":"CategoryTheory.Limits.Concrete.multiequalizerEquiv_apply","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nI : CategoryTheory.Limits.MulticospanIndex C\ninst✝¹ : CategoryTheory.Limits.HasMultiequalizer I\ninst✝ : CategoryTheory.Limits.PreservesLimit I.multicospan (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.multiequalizer I)\ni : I.L\n⊢ Eq (↑((CategoryTheory.Limits.Concrete.multiequalizerEquiv I) x) i) ((CategoryTheory.Limits.Multiequalizer.ι I i) x)","decl":"@[simp]\ntheorem multiequalizerEquiv_apply (I : MulticospanIndex.{w, w'} C) [HasMultiequalizer I]\n    [PreservesLimit I.multicospan (forget C)] (x : ↑(multiequalizer I)) (i : I.L) :\n    ((Concrete.multiequalizerEquiv I) x : ∀ i : I.L, I.left i) i = Multiequalizer.ι I i x :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.Concrete.widePushout_exists_rep","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nB : C\nα : Type v\nX : α → C\nf : (j : α) → Quiver.Hom B (X j)\ninst✝¹ : CategoryTheory.Limits.HasWidePushout B X f\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.WidePushoutShape.wideSpan B X f) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.widePushout B X f)\n⊢ Or (Exists fun y => Eq ((CategoryTheory.Limits.WidePushout.head f) y) x) (Exists fun i => Exists fun y => Eq ((CategoryTheory.Limits.WidePushout.ι f i) y) x)","decl":"theorem widePushout_exists_rep {B : C} {α : Type _} {X : α → C} (f : ∀ j : α, B ⟶ X j)\n    [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)]\n    (x : ↑(widePushout B X f)) : (∃ y : B, head f y = x) ∨ ∃ (i : α) (y : X i), ι f i y = x := by\n  obtain ⟨_ | j, y, rfl⟩ := Concrete.colimit_exists_rep _ x\n  · left\n    use y\n    rfl\n  · right\n    use j, y\n    rfl\n\n"}
{"name":"CategoryTheory.Limits.Concrete.widePushout_exists_rep'","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nB : C\nα : Type v\ninst✝² : Nonempty α\nX : α → C\nf : (j : α) → Quiver.Hom B (X j)\ninst✝¹ : CategoryTheory.Limits.HasWidePushout B X f\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.WidePushoutShape.wideSpan B X f) (CategoryTheory.forget C)\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.widePushout B X f)\n⊢ Exists fun i => Exists fun y => Eq ((CategoryTheory.Limits.WidePushout.ι f i) y) x","decl":"theorem widePushout_exists_rep' {B : C} {α : Type _} [Nonempty α] {X : α → C}\n    (f : ∀ j : α, B ⟶ X j) [HasWidePushout.{v} B X f] [PreservesColimit (wideSpan B X f) (forget C)]\n    (x : ↑(widePushout B X f)) : ∃ (i : α) (y : X i), ι f i y = x := by\n  rcases Concrete.widePushout_exists_rep f x with (⟨y, rfl⟩ | ⟨i, y, rfl⟩)\n  · inhabit α\n    use default, f _ y\n    simp only [← arrow_ι _ default, CategoryTheory.comp_apply]\n  · use i, y\n\n"}
{"name":"CategoryTheory.Limits.Concrete.cokernel_funext","module":"Mathlib.CategoryTheory.Limits.Shapes.ConcreteCategory","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.HasForget C\nM N K : C\nf : Quiver.Hom M N\ninst✝ : CategoryTheory.Limits.HasCokernel f\ng h : Quiver.Hom (CategoryTheory.Limits.cokernel f) K\nw : ∀ (n : (CategoryTheory.forget C).obj N), Eq (g ((CategoryTheory.Limits.cokernel.π f) n)) (h ((CategoryTheory.Limits.cokernel.π f) n))\n⊢ Eq g h","decl":"theorem cokernel_funext {C : Type*} [Category C] [HasZeroMorphisms C] [HasForget C]\n    {M N K : C} {f : M ⟶ N} [HasCokernel f] {g h : cokernel f ⟶ K}\n    (w : ∀ n : N, g (cokernel.π f n) = h (cokernel.π f n)) : g = h := by\n  ext x\n  simpa using w x\n\n-- TODO: Add analogous lemmas about coproducts and coequalizers.\n\n"}
