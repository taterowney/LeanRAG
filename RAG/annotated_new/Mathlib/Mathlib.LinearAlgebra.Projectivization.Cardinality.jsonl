{"name":"Projectivization.isEmpty_of_subsingleton","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Subsingleton V\n⊢ IsEmpty (Projectivization k V)","decl":"instance isEmpty_of_subsingleton [Subsingleton V] : IsEmpty (ℙ k V) := by\n  have : IsEmpty { v : V // v ≠ 0 } := ⟨fun v ↦ v.2 (Subsingleton.elim v.1 0)⟩\n  simpa using (nonZeroEquivProjectivizationProdUnits k V).symm.isEmpty\n\n"}
{"name":"Projectivization.finite_of_finite","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite V\n⊢ Finite (Projectivization k V)","decl":"/-- If `V` is a finite `k`-module and `k` is finite, `ℙ k V` is finite. -/\ninstance finite_of_finite [Finite V] : Finite (ℙ k V) :=\n  have : Finite (ℙ k V × kˣ) := Finite.of_equiv _ (nonZeroEquivProjectivizationProdUnits k V)\n  Finite.prod_left kˣ\n\n"}
{"name":"Projectivization.finite_iff_of_finite","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite k\n⊢ Iff (Finite (Projectivization k V)) (Finite V)","decl":"lemma finite_iff_of_finite [Finite k] : Finite (ℙ k V) ↔ Finite V := by\n  classical\n  refine ⟨fun h ↦ ?_, fun h ↦ inferInstance⟩\n  let e := nonZeroEquivProjectivizationProdUnits k V\n  have : Finite { v : V // v ≠ 0 } := Finite.of_equiv _ e.symm\n  let eq : { v : V // v ≠ 0 } ⊕ Unit ≃ V :=\n    ⟨(Sum.elim Subtype.val (fun _ ↦ 0)), fun v ↦ if h : v = 0 then Sum.inr () else Sum.inl ⟨v, h⟩,\n      by intro x; aesop, by intro x; aesop⟩\n  exact Finite.of_equiv _ eq\n\n"}
{"name":"Projectivization.card","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : DivisionRing k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\n⊢ Eq (HSub.hSub (Nat.card V) 1) (HMul.hMul (Nat.card (Projectivization k V)) (HSub.hSub (Nat.card k) 1))","decl":"/-- Fraction free cardinality formula for the points of `ℙ k V` if `k` and `V` are finite\n(for silly reasons the formula also holds when `k` and `V` are infinite).\nSee `Projectivization.card'` and `Projectivization.card''` for other spellings of the formula. -/\nlemma card : Nat.card V - 1 = Nat.card (ℙ k V) * (Nat.card k - 1) := by\n  nontriviality V\n  wlog h : Finite k\n  · simp only [not_finite_iff_infinite] at h\n    have : Infinite V := Module.Free.infinite k V\n    simp\n  wlog h : Finite V\n  · simp only [not_finite_iff_infinite] at h\n    have := not_iff_not.mpr (finite_iff_of_finite k V)\n    simp only [not_finite_iff_infinite] at this\n    have : Infinite (ℙ k V) := by rwa [this]\n    simp\n  classical\n  haveI : Fintype V := Fintype.ofFinite V\n  haveI : Fintype (ℙ k V) := Fintype.ofFinite (ℙ k V)\n  haveI : Fintype k := Fintype.ofFinite k\n  have hV : Fintype.card { v : V // v ≠ 0 } = Fintype.card V - 1 := by simp\n  simp_rw [← Fintype.card_eq_nat_card, ← Fintype.card_units (α := k), ← hV]\n  rw [Fintype.card_congr (nonZeroEquivProjectivizationProdUnits k V), Fintype.card_prod]\n\n"}
{"name":"Projectivization.card'","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite V\n⊢ Eq (Nat.card V) (HAdd.hAdd (HMul.hMul (Nat.card (Projectivization k V)) (HSub.hSub (Nat.card k) 1)) 1)","decl":"/-- Cardinality formula for the points of `ℙ k V` if `k` and `V` are finite with less\nnatural subtraction. -/\nlemma card' [Finite V] : Nat.card V = Nat.card (ℙ k V) * (Nat.card k - 1) + 1 := by\n  rw [← card k V]\n  have : Nat.card V > 0 := Nat.card_pos\n  omega\n\n"}
{"name":"Projectivization.card''","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : Field k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite k\n⊢ Eq (Nat.card (Projectivization k V)) (HDiv.hDiv (HSub.hSub (Nat.card V) 1) (HSub.hSub (Nat.card k) 1))","decl":"/-- Cardinality formula for the points of `ℙ k V` if `k` and `V` are finite expressed\nas a fraction. -/\nlemma card'' [Finite k] : Nat.card (ℙ k V) = (Nat.card V - 1) / (Nat.card k - 1) := by\n  have : 1 < Nat.card k := Finite.one_lt_card\n  rw [card k, Nat.mul_div_cancel]\n  omega\n\n"}
{"name":"Projectivization.card_of_finrank","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : Field k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite k\nn : Nat\nh : Eq (Module.finrank k V) n\n⊢ Eq (Nat.card (Projectivization k V)) ((Finset.range n).sum fun i => HPow.hPow (Nat.card k) i)","decl":"lemma card_of_finrank [Finite k] {n : ℕ} (h : Module.finrank k V = n) :\n    Nat.card (ℙ k V) = ∑ i ∈ Finset.range n, Nat.card k ^ i := by\n  wlog hf : Finite V\n  · simp only [not_finite_iff_infinite] at hf\n    have : Infinite (ℙ k V) := by\n      rw [← not_finite_iff_infinite, not_iff_not.mpr (finite_iff_of_finite k V)]\n      simpa\n    have : n = 0 := by\n      rw [← h]\n      apply Module.finrank_of_not_finite\n      contrapose! hf\n      simpa using Module.finite_of_finite k\n    simp [this]\n  have : 1 < Nat.card k := Finite.one_lt_card\n  refine Nat.mul_right_cancel (m := Nat.card k - 1) (by omega) ?_\n  let e : V ≃ₗ[k] (Fin n → k) := LinearEquiv.ofFinrankEq _ _ (by simpa)\n  have hc : Nat.card V = Nat.card k ^ n := by simp [Nat.card_congr e.toEquiv, Nat.card_fun]\n  zify\n  conv_rhs => rw [Int.natCast_sub this.le, Int.natCast_one, geom_sum_mul]\n  rw [← Int.natCast_mul, ← card k V, hc]\n  simp\n\n"}
{"name":"Projectivization.card_of_finrank_two","module":"Mathlib.LinearAlgebra.Projectivization.Cardinality","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : Field k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : Finite k\nh : Eq (Module.finrank k V) 2\n⊢ Eq (Nat.card (Projectivization k V)) (HAdd.hAdd (Nat.card k) 1)","decl":"lemma card_of_finrank_two [Finite k] (h : Module.finrank k V = 2) :\n    Nat.card (ℙ k V) = Nat.card k + 1 := by\n  simp [card_of_finrank k V h]\n\n"}
