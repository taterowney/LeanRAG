{"name":"ModuleCat.free_hom_ext","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\nf g : Quiver.Hom ((ModuleCat.free R).obj X) M\nh : ∀ (x : X), Eq ((CategoryTheory.ConcreteCategory.hom f) (ModuleCat.freeMk x)) ((CategoryTheory.ConcreteCategory.hom g) (ModuleCat.freeMk x))\n⊢ Eq f g","decl":"@[ext 1200]\nlemma free_hom_ext {X : Type u} {M : ModuleCat.{u} R} {f g : (free R).obj X ⟶ M}\n    (h : ∀ (x : X), f (freeMk x) = g (freeMk x)) :\n    f = g :=\n  ModuleCat.hom_ext (Finsupp.lhom_ext' (fun x ↦ LinearMap.ext_ring (h x)))\n\n"}
{"name":"ModuleCat.free_hom_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\nf g : Quiver.Hom ((ModuleCat.free R).obj X) M\n⊢ Iff (Eq f g) (∀ (x : X), Eq ((CategoryTheory.ConcreteCategory.hom f) (ModuleCat.freeMk x)) ((CategoryTheory.ConcreteCategory.hom g) (ModuleCat.freeMk x)))","decl":"@[ext 1200]\nlemma free_hom_ext {X : Type u} {M : ModuleCat.{u} R} {f g : (free R).obj X ⟶ M}\n    (h : ∀ (x : X), f (freeMk x) = g (freeMk x)) :\n    f = g :=\n  ModuleCat.hom_ext (Finsupp.lhom_ext' (fun x ↦ LinearMap.ext_ring (h x)))\n\n"}
{"name":"ModuleCat.freeDesc_apply","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\nf : Quiver.Hom X ↑M\nx : X\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.freeDesc f)) (ModuleCat.freeMk x)) (f x)","decl":"@[simp]\nlemma freeDesc_apply {X : Type u} {M : ModuleCat.{u} R} (f : X ⟶ M) (x : X) :\n    freeDesc f (freeMk x) = f x := by\n  dsimp [freeDesc]\n  erw [Finsupp.lift_apply, Finsupp.sum_single_index]\n  all_goals simp\n\n"}
{"name":"ModuleCat.free_map_apply","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX Y : Type u\nf : X → Y\nx : X\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((ModuleCat.free R).map f)) (ModuleCat.freeMk x)) (ModuleCat.freeMk (f x))","decl":"@[simp]\nlemma free_map_apply {X Y : Type u} (f : X → Y) (x : X) :\n    (free R).map f (freeMk x) = freeMk (f x) := by\n  apply Finsupp.mapDomain_single\n\n"}
{"name":"ModuleCat.freeHomEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\nφ : Quiver.Hom ((ModuleCat.free R).obj X) M\nx : X\n⊢ Eq (ModuleCat.freeHomEquiv φ x) ((CategoryTheory.ConcreteCategory.hom φ) (ModuleCat.freeMk x))","decl":"/-- The bijection `((free R).obj X ⟶ M) ≃ (X → M)` when `X` is a type and `M` a module. -/\n@[simps]\ndef freeHomEquiv {X : Type u} {M : ModuleCat.{u} R} :\n    ((free R).obj X ⟶ M) ≃ (X → M) where\n  toFun φ x := φ (freeMk x)\n  invFun ψ := freeDesc ψ\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"ModuleCat.freeHomEquiv_symm_apply","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\nψ : X → ↑M\n⊢ Eq (ModuleCat.freeHomEquiv.symm ψ) (ModuleCat.freeDesc ψ)","decl":"/-- The bijection `((free R).obj X ⟶ M) ≃ (X → M)` when `X` is a type and `M` a module. -/\n@[simps]\ndef freeHomEquiv {X : Type u} {M : ModuleCat.{u} R} :\n    ((free R).obj X ⟶ M) ≃ (X → M) where\n  toFun φ x := φ (freeMk x)\n  invFun ψ := freeDesc ψ\n  left_inv _ := by ext; simp\n  right_inv _ := by ext; simp\n\n"}
{"name":"ModuleCat.adj_homEquiv","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\nX : Type u\nM : ModuleCat R\n⊢ Eq ((ModuleCat.adj R).homEquiv X M) ModuleCat.freeHomEquiv","decl":"@[simp]\nlemma adj_homEquiv (X : Type u) (M : ModuleCat.{u} R) :\n    (adj R).homEquiv X M = freeHomEquiv := by\n  simp only [adj, Adjunction.mkOfHomEquiv_homEquiv]\n\n"}
{"name":"ModuleCat.instIsRightAdjointForget","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (CategoryTheory.forget (ModuleCat R)).IsRightAdjoint","decl":"instance : (forget (ModuleCat.{u} R)).IsRightAdjoint  :=\n  (adj R).isRightAdjoint\n\n"}
{"name":"ModuleCat.FreeMonoidal.εIso_hom_one","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.FreeMonoidal.εIso R).hom) 1) (ModuleCat.freeMk PUnit.unit)","decl":"@[simp]\nlemma εIso_hom_one : (εIso R).hom 1 = freeMk PUnit.unit := rfl\n\n"}
{"name":"ModuleCat.FreeMonoidal.εIso_inv_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nx : PUnit.{u + 1}\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.FreeMonoidal.εIso R).inv) (ModuleCat.freeMk x)) 1","decl":"@[simp]\nlemma εIso_inv_freeMk (x : PUnit) : (εIso R).inv (freeMk x) = 1 := by\n  dsimp [εIso, freeMk]\n  erw [Finsupp.lapply_apply]\n  rw [Finsupp.single_eq_same]\n\n"}
{"name":"ModuleCat.FreeMonoidal.μIso_hom_freeMk_tmul_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nX Y : Type u\nx : X\ny : Y\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.FreeMonoidal.μIso R X Y).hom) (TensorProduct.tmul R (ModuleCat.freeMk x) (ModuleCat.freeMk y))) (ModuleCat.freeMk { fst := x, snd := y })","decl":"@[simp]\nlemma μIso_hom_freeMk_tmul_freeMk {X Y : Type u} (x : X) (y : Y) :\n    (μIso R X Y).hom (freeMk x ⊗ₜ freeMk y) = freeMk ⟨x, y⟩ := by\n  dsimp [μIso, freeMk]\n  erw [finsuppTensorFinsupp'_single_tmul_single]\n  rw [mul_one]\n\n"}
{"name":"ModuleCat.FreeMonoidal.μIso_inv_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nX Y : Type u\nz : CategoryTheory.MonoidalCategoryStruct.tensorObj X Y\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.FreeMonoidal.μIso R X Y).inv) (ModuleCat.freeMk z)) (TensorProduct.tmul R (ModuleCat.freeMk z.1) (ModuleCat.freeMk z.2))","decl":"@[simp]\nlemma μIso_inv_freeMk {X Y : Type u} (z : X ⊗ Y) :\n    (μIso R X Y).inv (freeMk z) = freeMk z.1 ⊗ₜ freeMk z.2 := by\n  dsimp [μIso, freeMk]\n  erw [finsuppTensorFinsupp'_symm_single_eq_single_one_tmul]\n\n"}
{"name":"ModuleCat.free_ε_one","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Functor.LaxMonoidal.ε (ModuleCat.free R))) 1) (ModuleCat.freeMk PUnit.unit)","decl":"@[simp]\nlemma free_ε_one : ε (free R) 1 = freeMk PUnit.unit := rfl\n\n"}
{"name":"ModuleCat.free_η_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nx : PUnit.{u + 1}\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Functor.OplaxMonoidal.η (ModuleCat.free R))) (ModuleCat.freeMk x)) 1","decl":"@[simp]\nlemma free_η_freeMk (x : PUnit) : η (free R) (freeMk x) = 1 := by\n  apply FreeMonoidal.εIso_inv_freeMk\n\n"}
{"name":"ModuleCat.free_μ_freeMk_tmul_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nX Y : Type u\nx : X\ny : Y\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Functor.LaxMonoidal.μ (ModuleCat.free R) X Y)) (TensorProduct.tmul R (ModuleCat.freeMk x) (ModuleCat.freeMk y))) (ModuleCat.freeMk { fst := x, snd := y })","decl":"@[simp]\nlemma free_μ_freeMk_tmul_freeMk {X Y : Type u} (x : X) (y : Y) :\n    μ (free R) _ _ (freeMk x ⊗ₜ freeMk y) = freeMk ⟨x, y⟩ := by\n  apply FreeMonoidal.μIso_hom_freeMk_tmul_freeMk\n\n"}
{"name":"ModuleCat.free_δ_freeMk","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u\ninst✝ : CommRing R\nX Y : Type u\nz : CategoryTheory.MonoidalCategoryStruct.tensorObj X Y\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Functor.OplaxMonoidal.δ (ModuleCat.free R) X Y)) (ModuleCat.freeMk z)) (TensorProduct.tmul R (ModuleCat.freeMk z.1) (ModuleCat.freeMk z.2))","decl":"@[simp]\nlemma free_δ_freeMk {X Y : Type u} (z : X ⊗ Y) :\n    δ (free R) _ _ (freeMk z) = freeMk z.1 ⊗ₜ freeMk z.2 := by\n  apply FreeMonoidal.μIso_inv_freeMk\n\n"}
{"name":"CategoryTheory.Free.single_comp_single","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nr s : R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Finsupp.single f r) (Finsupp.single g s)) (Finsupp.single (CategoryTheory.CategoryStruct.comp f g) (HMul.hMul r s))","decl":"theorem single_comp_single {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) (r s : R) :\n    (single f r ≫ single g s : Free.of R X ⟶ Free.of R Z) = single (f ≫ g) (r * s) := by\n  dsimp [CategoryTheory.categoryFree]; simp\n\n"}
{"name":"CategoryTheory.Free.embedding_obj","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq ((CategoryTheory.Free.embedding R C).obj X) X","decl":"/-- A category embeds into its `R`-linear completion.\n-/\n@[simps]\ndef embedding : C ⥤ Free R C where\n  obj X := X\n  map {_ _} f := Finsupp.single f 1\n  map_id _ := rfl\n  map_comp {X Y Z} f g := by\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/10959): simp used to be able to close this goal\n    dsimp only []\n    rw [single_comp_single, one_mul]\n\n"}
{"name":"CategoryTheory.Free.embedding_map","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nx✝¹ x✝ : C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Free.embedding R C).map f) (Finsupp.single f 1)","decl":"/-- A category embeds into its `R`-linear completion.\n-/\n@[simps]\ndef embedding : C ⥤ Free R C where\n  obj X := X\n  map {_ _} f := Finsupp.single f 1\n  map_id _ := rfl\n  map_comp {X Y Z} f g := by\n    -- Porting note (https://github.com/leanprover-community/mathlib4/pull/10959): simp used to be able to close this goal\n    dsimp only []\n    rw [single_comp_single, one_mul]\n\n"}
{"name":"CategoryTheory.Free.lift_map","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : CategoryTheory.Linear R D\nF : CategoryTheory.Functor C D\nx✝¹ x✝ : CategoryTheory.Free R C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Free.lift R F).map f) (Finsupp.sum f fun f' r => HSMul.hSMul r (F.map f'))","decl":"/-- A functor to an `R`-linear category lifts to a functor from its `R`-linear completion.\n-/\n@[simps]\ndef lift (F : C ⥤ D) : Free R C ⥤ D where\n  obj X := F.obj X\n  map {_ _} f := f.sum fun f' r => r • F.map f'\n  map_id := by dsimp [CategoryTheory.categoryFree]; simp\n  map_comp {X Y Z} f g := by\n    apply Finsupp.induction_linear f\n    · simp\n    · intro f₁ f₂ w₁ w₂\n      rw [add_comp]\n      dsimp at *\n      rw [Finsupp.sum_add_index', Finsupp.sum_add_index']\n      · simp only [w₁, w₂, add_comp]\n      · intros; rw [zero_smul]\n      · intros; simp only [add_smul]\n      · intros; rw [zero_smul]\n      · intros; simp only [add_smul]\n    · intro f' r\n      apply Finsupp.induction_linear g\n      · simp\n      · intro f₁ f₂ w₁ w₂\n        rw [comp_add]\n        dsimp at *\n        rw [Finsupp.sum_add_index', Finsupp.sum_add_index']\n        · simp only [w₁, w₂, comp_add]\n        · intros; rw [zero_smul]\n        · intros; simp only [add_smul]\n        · intros; rw [zero_smul]\n        · intros; simp only [add_smul]\n      · intro g' s\n        rw [single_comp_single _ _ f' g' r s]\n        simp [mul_comm r s, mul_smul]\n\n"}
{"name":"CategoryTheory.Free.lift_obj","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : CategoryTheory.Linear R D\nF : CategoryTheory.Functor C D\nX : CategoryTheory.Free R C\n⊢ Eq ((CategoryTheory.Free.lift R F).obj X) (F.obj X)","decl":"/-- A functor to an `R`-linear category lifts to a functor from its `R`-linear completion.\n-/\n@[simps]\ndef lift (F : C ⥤ D) : Free R C ⥤ D where\n  obj X := F.obj X\n  map {_ _} f := f.sum fun f' r => r • F.map f'\n  map_id := by dsimp [CategoryTheory.categoryFree]; simp\n  map_comp {X Y Z} f g := by\n    apply Finsupp.induction_linear f\n    · simp\n    · intro f₁ f₂ w₁ w₂\n      rw [add_comp]\n      dsimp at *\n      rw [Finsupp.sum_add_index', Finsupp.sum_add_index']\n      · simp only [w₁, w₂, add_comp]\n      · intros; rw [zero_smul]\n      · intros; simp only [add_smul]\n      · intros; rw [zero_smul]\n      · intros; simp only [add_smul]\n    · intro f' r\n      apply Finsupp.induction_linear g\n      · simp\n      · intro f₁ f₂ w₁ w₂\n        rw [comp_add]\n        dsimp at *\n        rw [Finsupp.sum_add_index', Finsupp.sum_add_index']\n        · simp only [w₁, w₂, comp_add]\n        · intros; rw [zero_smul]\n        · intros; simp only [add_smul]\n        · intros; rw [zero_smul]\n        · intros; simp only [add_smul]\n      · intro g' s\n        rw [single_comp_single _ _ f' g' r s]\n        simp [mul_comm r s, mul_smul]\n\n"}
{"name":"CategoryTheory.Free.lift_map_single","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : CategoryTheory.Linear R D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nr : R\n⊢ Eq ((CategoryTheory.Free.lift R F).map (Finsupp.single f r)) (HSMul.hSMul r (F.map f))","decl":"theorem lift_map_single (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) (r : R) :\n    (lift R F).map (single f r) = r • F.map f := by simp\n\n"}
{"name":"CategoryTheory.Free.lift_additive","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : CategoryTheory.Linear R D\nF : CategoryTheory.Functor C D\n⊢ (CategoryTheory.Free.lift R F).Additive","decl":"instance lift_additive (F : C ⥤ D) : (lift R F).Additive where\n  map_add {X Y} f g := by\n    dsimp\n    rw [Finsupp.sum_add_index'] <;> simp [add_smul]\n\n"}
{"name":"CategoryTheory.Free.lift_linear","module":"Mathlib.Algebra.Category.ModuleCat.Adjunctions","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nC : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u\ninst✝² : CategoryTheory.Category.{v, u} D\ninst✝¹ : CategoryTheory.Preadditive D\ninst✝ : CategoryTheory.Linear R D\nF : CategoryTheory.Functor C D\n⊢ CategoryTheory.Functor.Linear R (CategoryTheory.Free.lift R F)","decl":"instance lift_linear (F : C ⥤ D) : (lift R F).Linear R where\n  map_smul {X Y} f r := by\n    dsimp\n    rw [Finsupp.sum_smul_index] <;> simp [Finsupp.smul_sum, mul_smul]\n\n"}
