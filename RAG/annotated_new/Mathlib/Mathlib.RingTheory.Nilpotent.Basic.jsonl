{"name":"IsNilpotent.neg","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx : R\ninst✝ : Ring R\nh : IsNilpotent x\n⊢ IsNilpotent (Neg.neg x)","decl":"theorem IsNilpotent.neg [Ring R] (h : IsNilpotent x) : IsNilpotent (-x) := by\n  obtain ⟨n, hn⟩ := h\n  use n\n  rw [neg_pow, hn, mul_zero]\n\n"}
{"name":"isNilpotent_neg_iff","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx : R\ninst✝ : Ring R\n⊢ Iff (IsNilpotent (Neg.neg x)) (IsNilpotent x)","decl":"@[simp]\ntheorem isNilpotent_neg_iff [Ring R] : IsNilpotent (-x) ↔ IsNilpotent x :=\n  ⟨fun h => neg_neg x ▸ h.neg, fun h => h.neg⟩\n\n"}
{"name":"IsNilpotent.smul","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : MonoidWithZero R\ninst✝³ : MonoidWithZero S\ninst✝² : MulActionWithZero R S\ninst✝¹ : SMulCommClass R S S\ninst✝ : IsScalarTower R S S\na : S\nha : IsNilpotent a\nt : R\n⊢ IsNilpotent (HSMul.hSMul t a)","decl":"lemma IsNilpotent.smul [MonoidWithZero R] [MonoidWithZero S] [MulActionWithZero R S]\n    [SMulCommClass R S S] [IsScalarTower R S S] {a : S} (ha : IsNilpotent a) (t : R) :\n    IsNilpotent (t • a) := by\n  obtain ⟨k, ha⟩ := ha\n  use k\n  rw [smul_pow, ha, smul_zero]\n\n"}
{"name":"IsNilpotent.isUnit_sub_one","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr : R\nhnil : IsNilpotent r\n⊢ IsUnit (HSub.hSub r 1)","decl":"theorem IsNilpotent.isUnit_sub_one [Ring R] {r : R} (hnil : IsNilpotent r) : IsUnit (r - 1) := by\n  obtain ⟨n, hn⟩ := hnil\n  refine ⟨⟨r - 1, -∑ i ∈ Finset.range n, r ^ i, ?_, ?_⟩, rfl⟩\n  · simp [mul_geom_sum, hn]\n  · simp [geom_sum_mul, hn]\n\n"}
{"name":"IsNilpotent.isUnit_one_sub","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr : R\nhnil : IsNilpotent r\n⊢ IsUnit (HSub.hSub 1 r)","decl":"theorem IsNilpotent.isUnit_one_sub [Ring R] {r : R} (hnil : IsNilpotent r) : IsUnit (1 - r) := by\n  rw [← IsUnit.neg_iff, neg_sub]\n  exact isUnit_sub_one hnil\n\n"}
{"name":"IsNilpotent.isUnit_add_one","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr : R\nhnil : IsNilpotent r\n⊢ IsUnit (HAdd.hAdd r 1)","decl":"theorem IsNilpotent.isUnit_add_one [Ring R] {r : R} (hnil : IsNilpotent r) : IsUnit (r + 1) := by\n  rw [← IsUnit.neg_iff, neg_add']\n  exact isUnit_sub_one hnil.neg\n\n"}
{"name":"IsNilpotent.isUnit_one_add","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr : R\nhnil : IsNilpotent r\n⊢ IsUnit (HAdd.hAdd 1 r)","decl":"theorem IsNilpotent.isUnit_one_add [Ring R] {r : R} (hnil : IsNilpotent r) : IsUnit (1 + r) :=\n  add_comm r 1 ▸ isUnit_add_one hnil\n\n"}
{"name":"IsNilpotent.isUnit_add_left_of_commute","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr u : R\nhnil : IsNilpotent r\nhu : IsUnit u\nh_comm : Commute r u\n⊢ IsUnit (HAdd.hAdd u r)","decl":"theorem IsNilpotent.isUnit_add_left_of_commute [Ring R] {r u : R}\n    (hnil : IsNilpotent r) (hu : IsUnit u) (h_comm : Commute r u) :\n    IsUnit (u + r) := by\n  rw [← Units.isUnit_mul_units _ hu.unit⁻¹, add_mul, IsUnit.mul_val_inv]\n  replace h_comm : Commute r (↑hu.unit⁻¹) := Commute.units_inv_right h_comm\n  refine IsNilpotent.isUnit_one_add ?_\n  exact (hu.unit⁻¹.isUnit.isNilpotent_mul_unit_of_commute_iff h_comm).mpr hnil\n\n"}
{"name":"IsNilpotent.isUnit_add_right_of_commute","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Ring R\nr u : R\nhnil : IsNilpotent r\nhu : IsUnit u\nh_comm : Commute r u\n⊢ IsUnit (HAdd.hAdd r u)","decl":"theorem IsNilpotent.isUnit_add_right_of_commute [Ring R] {r u : R}\n    (hnil : IsNilpotent r) (hu : IsUnit u) (h_comm : Commute r u) :\n    IsUnit (r + u) :=\n  add_comm r u ▸ hnil.isUnit_add_left_of_commute hu h_comm\n\n"}
{"name":"IsUnit.not_isNilpotent","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\nx : R\nhx : IsUnit x\n⊢ Not (IsNilpotent x)","decl":"lemma IsUnit.not_isNilpotent [Ring R] [Nontrivial R] {x : R} (hx : IsUnit x) :\n    ¬ IsNilpotent x := by\n  intro H\n  simpa using H.isUnit_add_right_of_commute hx.neg (by simp)\n\n"}
{"name":"IsNilpotent.not_isUnit","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : Nontrivial R\nx : R\nhx : IsNilpotent x\n⊢ Not (IsUnit x)","decl":"lemma IsNilpotent.not_isUnit [Ring R] [Nontrivial R] {x : R} (hx : IsNilpotent x) :\n    ¬ IsUnit x :=\n  mt IsUnit.not_isNilpotent (by simpa only [not_not] using hx)\n\n"}
{"name":"IsIdempotentElem.eq_zero_of_isNilpotent","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nnilp : IsNilpotent e\n⊢ Eq e 0","decl":"lemma IsIdempotentElem.eq_zero_of_isNilpotent [MonoidWithZero R] {e : R}\n    (idem : IsIdempotentElem e) (nilp : IsNilpotent e) : e = 0 := by\n  obtain ⟨rfl | n, hn⟩ := nilp\n  · rw [pow_zero] at hn; rw [← one_mul e, hn, zero_mul]\n  · rw [← hn, idem.pow_succ_eq]\n\n"}
{"name":"IsNilpotent.eq_zero_of_isIdempotentElem","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\ne : R\nidem : IsIdempotentElem e\nnilp : IsNilpotent e\n⊢ Eq e 0","decl":"alias IsNilpotent.eq_zero_of_isIdempotentElem := IsIdempotentElem.eq_zero_of_isNilpotent\n\n"}
{"name":"instIsReducedProd","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : Zero R\ninst✝⁴ : Pow R Nat\ninst✝³ : Zero S\ninst✝² : Pow S Nat\ninst✝¹ : IsReduced R\ninst✝ : IsReduced S\n⊢ IsReduced (Prod R S)","decl":"instance [Zero R] [Pow R ℕ] [Zero S] [Pow S ℕ] [IsReduced R] [IsReduced S] : IsReduced (R × S) where\n  eq_zero _ := fun ⟨n, hn⟩ ↦ have hn := Prod.ext_iff.1 hn\n    Prod.ext (IsReduced.eq_zero _ ⟨n, hn.1⟩) (IsReduced.eq_zero _ ⟨n, hn.2⟩)\n\n"}
{"name":"Prime.isRadical","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\ny : R\nhy : Prime y\n⊢ IsRadical y","decl":"theorem Prime.isRadical [CommMonoidWithZero R] {y : R} (hy : Prime y) : IsRadical y :=\n  fun _ _ ↦ hy.dvd_of_dvd_pow\n\n"}
{"name":"zero_isRadical_iff","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\n⊢ Iff (IsRadical 0) (IsReduced R)","decl":"theorem zero_isRadical_iff [MonoidWithZero R] : IsRadical (0 : R) ↔ IsReduced R := by\n  simp_rw [isReduced_iff, IsNilpotent, exists_imp, ← zero_dvd_iff]\n  exact forall_swap\n\n"}
{"name":"isReduced_iff_pow_one_lt","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : MonoidWithZero R\nk : Nat\nhk : LT.lt 1 k\n⊢ Iff (IsReduced R) (∀ (x : R), Eq (HPow.hPow x k) 0 → Eq x 0)","decl":"theorem isReduced_iff_pow_one_lt [MonoidWithZero R] (k : ℕ) (hk : 1 < k) :\n    IsReduced R ↔ ∀ x : R, x ^ k = 0 → x = 0 := by\n  simp_rw [← zero_isRadical_iff, isRadical_iff_pow_one_lt k hk, zero_dvd_iff]\n\n"}
{"name":"IsRadical.of_dvd","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : CancelCommMonoidWithZero R\nx y : R\nhy : IsRadical y\nh0 : Ne y 0\nhxy : Dvd.dvd x y\n⊢ IsRadical x","decl":"theorem IsRadical.of_dvd [CancelCommMonoidWithZero R] {x y : R} (hy : IsRadical y) (h0 : y ≠ 0)\n    (hxy : x ∣ y) : IsRadical x := (isRadical_iff_pow_one_lt 2 one_lt_two).2 <| by\n  obtain ⟨z, rfl⟩ := hxy\n  refine fun w dvd ↦ ((mul_dvd_mul_iff_right <| right_ne_zero_of_mul h0).mp <| hy 2 _ ?_)\n  rw [mul_pow, sq z]; exact mul_dvd_mul dvd (dvd_mul_left z z)\n\n"}
{"name":"Commute.add_pow_eq_zero_of_add_le_succ_of_pow_eq_zero","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nm n k : Nat\nhx : Eq (HPow.hPow x m) 0\nhy : Eq (HPow.hPow y n) 0\nh : LE.le (HAdd.hAdd m n) (HAdd.hAdd k 1)\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) k) 0","decl":"theorem add_pow_eq_zero_of_add_le_succ_of_pow_eq_zero (h_comm : Commute x y) {m n k : ℕ}\n    (hx : x ^ m = 0) (hy : y ^ n = 0) (h : m + n ≤ k + 1) :\n    (x + y) ^ k = 0 := by\n  rw [h_comm.add_pow']\n  apply Finset.sum_eq_zero\n  rintro ⟨i, j⟩ hij\n  suffices x ^ i * y ^ j = 0 by simp only [this, nsmul_eq_mul, mul_zero]\n  by_cases hi : m ≤ i\n  · rw [pow_eq_zero_of_le hi hx, zero_mul]\n  rw [pow_eq_zero_of_le ?_ hy, mul_zero]\n  linarith [Finset.mem_antidiagonal.mp hij]\n\n"}
{"name":"Commute.add_pow_add_eq_zero_of_pow_eq_zero","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nm n : Nat\nhx : Eq (HPow.hPow x m) 0\nhy : Eq (HPow.hPow y n) 0\n⊢ Eq (HPow.hPow (HAdd.hAdd x y) (HSub.hSub (HAdd.hAdd m n) 1)) 0","decl":"theorem add_pow_add_eq_zero_of_pow_eq_zero (h_comm : Commute x y) {m n : ℕ}\n    (hx : x ^ m = 0) (hy : y ^ n = 0) :\n    (x + y) ^ (m + n - 1) = 0 :=\n  h_comm.add_pow_eq_zero_of_add_le_succ_of_pow_eq_zero hx hy <| by rw [← Nat.sub_le_iff_le_add]\n\n"}
{"name":"Commute.isNilpotent_add","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nhx : IsNilpotent x\nhy : IsNilpotent y\n⊢ IsNilpotent (HAdd.hAdd x y)","decl":"theorem isNilpotent_add (h_comm : Commute x y) (hx : IsNilpotent x) (hy : IsNilpotent y) :\n    IsNilpotent (x + y) := by\n  obtain ⟨n, hn⟩ := hx\n  obtain ⟨m, hm⟩ := hy\n  exact ⟨_, add_pow_add_eq_zero_of_pow_eq_zero h_comm hn hm⟩\n\n"}
{"name":"Commute.isNilpotent_sum","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nι : Type u_3\ns : Finset ι\nf : ι → R\nhnp : ∀ (i : ι), Membership.mem s i → IsNilpotent (f i)\nh_comm : ∀ (i j : ι), Membership.mem s i → Membership.mem s j → Commute (f i) (f j)\n⊢ IsNilpotent (s.sum fun i => f i)","decl":"protected lemma isNilpotent_sum {ι : Type*} {s : Finset ι} {f : ι → R}\n    (hnp : ∀ i ∈ s, IsNilpotent (f i)) (h_comm : ∀ i j, i ∈ s → j ∈ s → Commute (f i) (f j)) :\n    IsNilpotent (∑ i ∈ s, f i) := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp\n  | @insert j s hj ih => ?_\n  rw [Finset.sum_insert hj]\n  apply Commute.isNilpotent_add\n  · exact Commute.sum_right _ _ _ (fun i hi ↦ h_comm _ _ (by simp) (by simp [hi]))\n  · apply hnp; simp\n  · exact ih (fun i hi ↦ hnp i (by simp [hi]))\n      (fun i j hi hj ↦ h_comm i j (by simp [hi]) (by simp [hj]))\n\n"}
{"name":"Commute.isNilpotent_mul_left_iff","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nhy : Membership.mem (nonZeroDivisorsLeft R) y\n⊢ Iff (IsNilpotent (HMul.hMul x y)) (IsNilpotent x)","decl":"protected lemma isNilpotent_mul_left_iff (h_comm : Commute x y) (hy : y ∈ nonZeroDivisorsLeft R) :\n    IsNilpotent (x * y) ↔ IsNilpotent x := by\n  refine ⟨?_, h_comm.isNilpotent_mul_left⟩\n  rintro ⟨k, hk⟩\n  rw [mul_pow h_comm] at hk\n  exact ⟨k, (nonZeroDivisorsLeft R).pow_mem hy k _ hk⟩\n\n"}
{"name":"Commute.isNilpotent_mul_right_iff","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Semiring R\nh_comm : Commute x y\nhx : Membership.mem (nonZeroDivisorsRight R) x\n⊢ Iff (IsNilpotent (HMul.hMul x y)) (IsNilpotent y)","decl":"protected lemma isNilpotent_mul_right_iff (h_comm : Commute x y) (hx : x ∈ nonZeroDivisorsRight R) :\n    IsNilpotent (x * y) ↔ IsNilpotent y := by\n  refine ⟨?_, h_comm.isNilpotent_mul_right⟩\n  rintro ⟨k, hk⟩\n  rw [mul_pow h_comm] at hk\n  exact ⟨k, (nonZeroDivisorsRight R).pow_mem hx k _ hk⟩\n\n"}
{"name":"Commute.isNilpotent_sub","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\nx y : R\ninst✝ : Ring R\nh_comm : Commute x y\nhx : IsNilpotent x\nhy : IsNilpotent y\n⊢ IsNilpotent (HSub.hSub x y)","decl":"theorem isNilpotent_sub (h_comm : Commute x y) (hx : IsNilpotent x) (hy : IsNilpotent y) :\n    IsNilpotent (x - y) := by\n  rw [← neg_right_iff] at h_comm\n  rw [← isNilpotent_neg_iff] at hy\n  rw [sub_eq_add_neg]\n  exact h_comm.isNilpotent_add hx hy\n\n"}
{"name":"isNilpotent_sum","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nι : Type u_3\ns : Finset ι\nf : ι → R\nhnp : ∀ (i : ι), Membership.mem s i → IsNilpotent (f i)\n⊢ IsNilpotent (s.sum fun i => f i)","decl":"lemma isNilpotent_sum {ι : Type*} {s : Finset ι} {f : ι → R}\n    (hnp : ∀ i ∈ s, IsNilpotent (f i)) :\n    IsNilpotent (∑ i ∈ s, f i) :=\n  Commute.isNilpotent_sum hnp fun _ _ _ _ ↦ Commute.all _ _\n\n"}
{"name":"NoZeroSMulDivisors.isReduced","module":"Mathlib.RingTheory.Nilpotent.Basic","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝⁴ : MonoidWithZero R\ninst✝³ : Zero M\ninst✝² : MulActionWithZero R M\ninst✝¹ : Nontrivial M\ninst✝ : NoZeroSMulDivisors R M\n⊢ IsReduced R","decl":"lemma NoZeroSMulDivisors.isReduced (R M : Type*)\n    [MonoidWithZero R] [Zero M] [MulActionWithZero R M] [Nontrivial M] [NoZeroSMulDivisors R M] :\n    IsReduced R := by\n  refine ⟨fun x ⟨k, hk⟩ ↦ ?_⟩\n  induction' k with k ih\n  · rw [pow_zero] at hk\n    exact eq_zero_of_zero_eq_one hk.symm x\n  · obtain ⟨m : M, hm : m ≠ 0⟩ := exists_ne (0 : M)\n    have : x ^ (k + 1) • m = 0 := by simp only [hk, zero_smul]\n    rw [pow_succ', mul_smul] at this\n    rcases eq_zero_or_eq_zero_of_smul_eq_zero this with rfl | hx\n    · rfl\n    · exact ih <| (eq_zero_or_eq_zero_of_smul_eq_zero hx).resolve_right hm\n"}
