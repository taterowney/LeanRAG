{"name":"Module.Baer.of_divisible","module":"Mathlib.Algebra.Category.Grp.Injective","initialProofState":"A : Type u\ninst✝¹ : AddCommGroup A\ninst✝ : DivisibleBy A Int\n⊢ Module.Baer Int A","decl":"theorem Module.Baer.of_divisible [DivisibleBy A ℤ] : Module.Baer ℤ A := fun I g ↦ by\n  rcases IsPrincipalIdealRing.principal I with ⟨m, rfl⟩\n  obtain rfl | h0 := eq_or_ne m 0\n  · refine ⟨0, fun n hn ↦ ?_⟩\n    rw [Submodule.span_zero_singleton] at hn\n    subst hn\n    exact (map_zero g).symm\n  let gₘ := g ⟨m, Submodule.subset_span (Set.mem_singleton _)⟩\n  refine ⟨LinearMap.toSpanSingleton ℤ A (DivisibleBy.div gₘ m), fun n hn ↦ ?_⟩\n  rcases Submodule.mem_span_singleton.mp hn with ⟨n, rfl⟩\n  rw [map_zsmul, LinearMap.toSpanSingleton_apply, DivisibleBy.div_cancel gₘ h0, ← map_zsmul g,\n    SetLike.mk_smul_mk]\n\n"}
{"name":"AddCommGrp.injective_as_module_iff","module":"Mathlib.Algebra.Category.Grp.Injective","initialProofState":"A : Type u\ninst✝ : AddCommGroup A\n⊢ Iff (CategoryTheory.Injective (ModuleCat.of Int A)) (CategoryTheory.Injective (AddCommGrp.of A))","decl":"theorem injective_as_module_iff : Injective (ModuleCat.of ℤ A) ↔\n    Injective (C := AddCommGrp) (AddCommGrp.of A) :=\n  ((forget₂ (ModuleCat ℤ) AddCommGrp).asEquivalence.map_injective_iff (ModuleCat.of ℤ A)).symm\n\n"}
{"name":"AddCommGrp.injective_of_divisible","module":"Mathlib.Algebra.Category.Grp.Injective","initialProofState":"A : Type u\ninst✝¹ : AddCommGroup A\ninst✝ : DivisibleBy A Int\n⊢ CategoryTheory.Injective (AddCommGrp.of A)","decl":"instance injective_of_divisible [DivisibleBy A ℤ] :\n    Injective (C := AddCommGrp) (AddCommGrp.of A) :=\n  (injective_as_module_iff A).mp <|\n    Module.injective_object_of_injective_module (inj := (Module.Baer.of_divisible A).injective)\n\n"}
{"name":"AddCommGrp.injective_ratCircle","module":"Mathlib.Algebra.Category.Grp.Injective","initialProofState":"⊢ CategoryTheory.Injective (AddCommGrp.of (ULift.{u, 0} (AddCircle 1)))","decl":"instance injective_ratCircle : Injective <| of <| ULift.{u} <| AddCircle (1 : ℚ) :=\n  injective_of_divisible _\n\n"}
