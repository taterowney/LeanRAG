{"name":"CategoryTheory.Localization.structuredArrowEquiv_apply","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\nD' : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} D'\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\ninst✝¹ : L.IsLocalization W\ninst✝ : L'.IsLocalization W\nX : C\nf : CategoryTheory.StructuredArrow (L.obj X) L\n⊢ Eq ((CategoryTheory.Localization.structuredArrowEquiv W L L') f) (CategoryTheory.StructuredArrow.mk ((CategoryTheory.Localization.homEquiv W L L') f.hom))","decl":"/-- The bijection `StructuredArrow (L.obj X) L ≃ StructuredArrow (L'.obj X) L'`\nwhen `L` and `L'` are two localization functors for the same class of morphisms. -/\n@[simps]\nnoncomputable def structuredArrowEquiv :\n    StructuredArrow (L.obj X) L ≃ StructuredArrow (L'.obj X) L' where\n  toFun f := StructuredArrow.mk (homEquiv W L L' f.hom)\n  invFun f := StructuredArrow.mk (homEquiv W L' L f.hom)\n  left_inv f := by\n    obtain ⟨Y, f, rfl⟩ := f.mk_surjective\n    dsimp\n    rw [← homEquiv_symm_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    obtain ⟨Y, f, rfl⟩ := f.mk_surjective\n    dsimp\n    rw [← homEquiv_symm_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.Localization.structuredArrowEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\nD' : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Category.{u_6, u_3} D'\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\ninst✝¹ : L.IsLocalization W\ninst✝ : L'.IsLocalization W\nX : C\nf : CategoryTheory.StructuredArrow (L'.obj X) L'\n⊢ Eq ((CategoryTheory.Localization.structuredArrowEquiv W L L').symm f) (CategoryTheory.StructuredArrow.mk ((CategoryTheory.Localization.homEquiv W L' L) f.hom))","decl":"/-- The bijection `StructuredArrow (L.obj X) L ≃ StructuredArrow (L'.obj X) L'`\nwhen `L` and `L'` are two localization functors for the same class of morphisms. -/\n@[simps]\nnoncomputable def structuredArrowEquiv :\n    StructuredArrow (L.obj X) L ≃ StructuredArrow (L'.obj X) L' where\n  toFun f := StructuredArrow.mk (homEquiv W L L' f.hom)\n  invFun f := StructuredArrow.mk (homEquiv W L' L f.hom)\n  left_inv f := by\n    obtain ⟨Y, f, rfl⟩ := f.mk_surjective\n    dsimp\n    rw [← homEquiv_symm_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    obtain ⟨Y, f, rfl⟩ := f.mk_surjective\n    dsimp\n    rw [← homEquiv_symm_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.Localization.induction_structuredArrow","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\nX : C\nP : CategoryTheory.StructuredArrow (L.obj X) L → Prop\nhP₀ : P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)))\nhP₁ : ∀ ⦃Y₁ Y₂ : C⦄ (f : Quiver.Hom Y₁ Y₂) (φ : Quiver.Hom (L.obj X) (L.obj Y₁)), P (CategoryTheory.StructuredArrow.mk φ) → P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp φ (L.map f)))\nhP₂ : ∀ ⦃Y₁ Y₂ : C⦄ (w : Quiver.Hom Y₁ Y₂) (hw : W w) (φ : Quiver.Hom (L.obj X) (L.obj Y₂)), P (CategoryTheory.StructuredArrow.mk φ) → P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.Localization.isoOfHom L W w hw).inv))\ng : CategoryTheory.StructuredArrow (L.obj X) L\n⊢ P g","decl":"@[elab_as_elim]\nlemma induction_structuredArrow\n    (hP₀ : P (StructuredArrow.mk (𝟙 (L.obj X))))\n    (hP₁ : ∀ ⦃Y₁ Y₂ : C⦄ (f : Y₁ ⟶ Y₂) (φ : L.obj X ⟶ L.obj Y₁),\n      P (StructuredArrow.mk φ) → P (StructuredArrow.mk (φ ≫ L.map f)))\n    (hP₂ : ∀ ⦃Y₁ Y₂ : C⦄ (w : Y₁ ⟶ Y₂) (hw : W w) (φ : L.obj X ⟶ L.obj Y₂),\n      P (StructuredArrow.mk φ) → P (StructuredArrow.mk (φ ≫ (isoOfHom L W w hw).inv)))\n    (g : StructuredArrow (L.obj X) L) : P g := by\n  let P' : StructuredArrow (W.Q.obj X) W.Q → Prop :=\n    fun g ↦ P (structuredArrowEquiv W W.Q L g)\n  rw [← (structuredArrowEquiv W W.Q L).apply_symm_apply g]\n  apply induction_structuredArrow' W P'\n  · convert hP₀\n    simp\n  · intros Y₁ Y₂ f φ hφ\n    convert hP₁ f (homEquiv W W.Q L φ) hφ\n    simp [homEquiv_comp]\n  · intros Y₁ Y₂ w hw φ hφ\n    convert hP₂ w hw (homEquiv W W.Q L φ) hφ\n    simp [homEquiv_comp, homEquiv_isoOfHom_inv]\n\n"}
{"name":"CategoryTheory.Localization.induction_costructuredArrow","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝ : L.IsLocalization W\nY : C\nP : CategoryTheory.CostructuredArrow L (L.obj Y) → Prop\nhP₀ : P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj Y)))\nhP₁ : ∀ ⦃X₁ X₂ : C⦄ (f : Quiver.Hom X₁ X₂) (φ : Quiver.Hom (L.obj X₂) (L.obj Y)), P (CategoryTheory.CostructuredArrow.mk φ) → P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (L.map f) φ))\nhP₂ : ∀ ⦃X₁ X₂ : C⦄ (w : Quiver.Hom X₁ X₂) (hw : W w) (φ : Quiver.Hom (L.obj X₁) (L.obj Y)), P (CategoryTheory.CostructuredArrow.mk φ) → P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W w hw).inv φ))\ng : CategoryTheory.CostructuredArrow L (L.obj Y)\n⊢ P g","decl":"@[elab_as_elim]\nlemma induction_costructuredArrow\n    (hP₀ : P (CostructuredArrow.mk (𝟙 (L.obj Y))))\n    (hP₁ : ∀ ⦃X₁ X₂ : C⦄ (f : X₁ ⟶ X₂) (φ : L.obj X₂ ⟶ L.obj Y),\n      P (CostructuredArrow.mk φ) → P (CostructuredArrow.mk (L.map f ≫ φ)))\n    (hP₂ : ∀ ⦃X₁ X₂ : C⦄ (w : X₁ ⟶ X₂) (hw : W w) (φ : L.obj X₁ ⟶ L.obj Y),\n      P (CostructuredArrow.mk φ) → P (CostructuredArrow.mk ((isoOfHom L W w hw).inv ≫ φ)))\n    (g : CostructuredArrow L (L.obj Y)) : P g := by\n  let g' := StructuredArrow.mk (T := L.op) (Y := op g.left) g.hom.op\n  show P (CostructuredArrow.mk g'.hom.unop)\n  induction g' using induction_structuredArrow L.op W.op with\n  | hP₀ => exact hP₀\n  | hP₁ f φ hφ => exact hP₁ f.unop φ.unop hφ\n  | hP₂ w hw φ hφ => simpa [isoOfHom_op_inv L W w hw] using hP₂ w.unop hw φ.unop hφ\n\n"}
