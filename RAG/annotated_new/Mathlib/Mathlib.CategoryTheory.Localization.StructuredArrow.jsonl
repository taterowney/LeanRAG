{"name":"CategoryTheory.Localization.structuredArrowEquiv_apply","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\nD' : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} D'\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : L'.IsLocalization W\nX : C\nf : CategoryTheory.StructuredArrow (L.obj X) L\nâŠ¢ Eq ((CategoryTheory.Localization.structuredArrowEquiv W L L') f) (CategoryTheory.StructuredArrow.mk ((CategoryTheory.Localization.homEquiv W L L') f.hom))","decl":"/-- The bijection `StructuredArrow (L.obj X) L â‰ƒ StructuredArrow (L'.obj X) L'`\nwhen `L` and `L'` are two localization functors for the same class of morphisms. -/\n@[simps]\nnoncomputable def structuredArrowEquiv :\n    StructuredArrow (L.obj X) L â‰ƒ StructuredArrow (L'.obj X) L' where\n  toFun f := StructuredArrow.mk (homEquiv W L L' f.hom)\n  invFun f := StructuredArrow.mk (homEquiv W L' L f.hom)\n  left_inv f := by\n    obtain âŸ¨Y, f, rflâŸ© := f.mk_surjective\n    dsimp\n    rw [â† homEquiv_symm_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    obtain âŸ¨Y, f, rflâŸ© := f.mk_surjective\n    dsimp\n    rw [â† homEquiv_symm_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.Localization.structuredArrowEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\nD' : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} D'\nW : CategoryTheory.MorphismProperty C\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\ninstâœÂ¹ : L.IsLocalization W\ninstâœ : L'.IsLocalization W\nX : C\nf : CategoryTheory.StructuredArrow (L'.obj X) L'\nâŠ¢ Eq ((CategoryTheory.Localization.structuredArrowEquiv W L L').symm f) (CategoryTheory.StructuredArrow.mk ((CategoryTheory.Localization.homEquiv W L' L) f.hom))","decl":"/-- The bijection `StructuredArrow (L.obj X) L â‰ƒ StructuredArrow (L'.obj X) L'`\nwhen `L` and `L'` are two localization functors for the same class of morphisms. -/\n@[simps]\nnoncomputable def structuredArrowEquiv :\n    StructuredArrow (L.obj X) L â‰ƒ StructuredArrow (L'.obj X) L' where\n  toFun f := StructuredArrow.mk (homEquiv W L L' f.hom)\n  invFun f := StructuredArrow.mk (homEquiv W L' L f.hom)\n  left_inv f := by\n    obtain âŸ¨Y, f, rflâŸ© := f.mk_surjective\n    dsimp\n    rw [â† homEquiv_symm_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    obtain âŸ¨Y, f, rflâŸ© := f.mk_surjective\n    dsimp\n    rw [â† homEquiv_symm_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.Localization.induction_structuredArrow","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœ : L.IsLocalization W\nX : C\nP : CategoryTheory.StructuredArrow (L.obj X) L â†’ Prop\nhPâ‚€ : P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj X)))\nhPâ‚ : âˆ€ â¦ƒYâ‚ Yâ‚‚ : Câ¦„ (f : Quiver.Hom Yâ‚ Yâ‚‚) (Ï† : Quiver.Hom (L.obj X) (L.obj Yâ‚)), P (CategoryTheory.StructuredArrow.mk Ï†) â†’ P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp Ï† (L.map f)))\nhPâ‚‚ : âˆ€ â¦ƒYâ‚ Yâ‚‚ : Câ¦„ (w : Quiver.Hom Yâ‚ Yâ‚‚) (hw : W w) (Ï† : Quiver.Hom (L.obj X) (L.obj Yâ‚‚)), P (CategoryTheory.StructuredArrow.mk Ï†) â†’ P (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.Localization.isoOfHom L W w hw).inv))\ng : CategoryTheory.StructuredArrow (L.obj X) L\nâŠ¢ P g","decl":"@[elab_as_elim]\nlemma induction_structuredArrow\n    (hPâ‚€ : P (StructuredArrow.mk (ðŸ™ (L.obj X))))\n    (hPâ‚ : âˆ€ â¦ƒYâ‚ Yâ‚‚ : Câ¦„ (f : Yâ‚ âŸ¶ Yâ‚‚) (Ï† : L.obj X âŸ¶ L.obj Yâ‚),\n      P (StructuredArrow.mk Ï†) â†’ P (StructuredArrow.mk (Ï† â‰« L.map f)))\n    (hPâ‚‚ : âˆ€ â¦ƒYâ‚ Yâ‚‚ : Câ¦„ (w : Yâ‚ âŸ¶ Yâ‚‚) (hw : W w) (Ï† : L.obj X âŸ¶ L.obj Yâ‚‚),\n      P (StructuredArrow.mk Ï†) â†’ P (StructuredArrow.mk (Ï† â‰« (isoOfHom L W w hw).inv)))\n    (g : StructuredArrow (L.obj X) L) : P g := by\n  let P' : StructuredArrow (W.Q.obj X) W.Q â†’ Prop :=\n    fun g â†¦ P (structuredArrowEquiv W W.Q L g)\n  rw [â† (structuredArrowEquiv W W.Q L).apply_symm_apply g]\n  apply induction_structuredArrow' W P'\n  Â· convert hPâ‚€\n    simp\n  Â· intros Yâ‚ Yâ‚‚ f Ï† hÏ†\n    convert hPâ‚ f (homEquiv W W.Q L Ï†) hÏ†\n    simp [homEquiv_comp]\n  Â· intros Yâ‚ Yâ‚‚ w hw Ï† hÏ†\n    convert hPâ‚‚ w hw (homEquiv W W.Q L Ï†) hÏ†\n    simp [homEquiv_comp, homEquiv_isoOfHom_inv]\n\n"}
{"name":"CategoryTheory.Localization.induction_costructuredArrow","module":"Mathlib.CategoryTheory.Localization.StructuredArrow","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninstâœ : L.IsLocalization W\nY : C\nP : CategoryTheory.CostructuredArrow L (L.obj Y) â†’ Prop\nhPâ‚€ : P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.id (L.obj Y)))\nhPâ‚ : âˆ€ â¦ƒXâ‚ Xâ‚‚ : Câ¦„ (f : Quiver.Hom Xâ‚ Xâ‚‚) (Ï† : Quiver.Hom (L.obj Xâ‚‚) (L.obj Y)), P (CategoryTheory.CostructuredArrow.mk Ï†) â†’ P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (L.map f) Ï†))\nhPâ‚‚ : âˆ€ â¦ƒXâ‚ Xâ‚‚ : Câ¦„ (w : Quiver.Hom Xâ‚ Xâ‚‚) (hw : W w) (Ï† : Quiver.Hom (L.obj Xâ‚) (L.obj Y)), P (CategoryTheory.CostructuredArrow.mk Ï†) â†’ P (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W w hw).inv Ï†))\ng : CategoryTheory.CostructuredArrow L (L.obj Y)\nâŠ¢ P g","decl":"@[elab_as_elim]\nlemma induction_costructuredArrow\n    (hPâ‚€ : P (CostructuredArrow.mk (ðŸ™ (L.obj Y))))\n    (hPâ‚ : âˆ€ â¦ƒXâ‚ Xâ‚‚ : Câ¦„ (f : Xâ‚ âŸ¶ Xâ‚‚) (Ï† : L.obj Xâ‚‚ âŸ¶ L.obj Y),\n      P (CostructuredArrow.mk Ï†) â†’ P (CostructuredArrow.mk (L.map f â‰« Ï†)))\n    (hPâ‚‚ : âˆ€ â¦ƒXâ‚ Xâ‚‚ : Câ¦„ (w : Xâ‚ âŸ¶ Xâ‚‚) (hw : W w) (Ï† : L.obj Xâ‚ âŸ¶ L.obj Y),\n      P (CostructuredArrow.mk Ï†) â†’ P (CostructuredArrow.mk ((isoOfHom L W w hw).inv â‰« Ï†)))\n    (g : CostructuredArrow L (L.obj Y)) : P g := by\n  let g' := StructuredArrow.mk (T := L.op) (Y := op g.left) g.hom.op\n  show P (CostructuredArrow.mk g'.hom.unop)\n  induction g' using induction_structuredArrow L.op W.op with\n  | hPâ‚€ => exact hPâ‚€\n  | hPâ‚ f Ï† hÏ† => exact hPâ‚ f.unop Ï†.unop hÏ†\n  | hPâ‚‚ w hw Ï† hÏ† => simpa [isoOfHom_op_inv L W w hw] using hPâ‚‚ w.unop hw Ï†.unop hÏ†\n\n"}
