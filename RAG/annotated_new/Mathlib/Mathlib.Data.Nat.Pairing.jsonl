{"name":"Nat.pair_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n : Nat\n⊢ Eq (Nat.pair (Nat.unpair n).1 (Nat.unpair n).2) n","decl":"@[simp]\ntheorem pair_unpair (n : ℕ) : pair (unpair n).1 (unpair n).2 = n := by\n  dsimp only [unpair]; let s := sqrt n\n  have sm : s * s + (n - s * s) = n := Nat.add_sub_cancel' (sqrt_le _)\n  split_ifs with h\n  · simp [s, pair, h, sm]\n  · have hl : n - s * s - s ≤ s := Nat.sub_le_iff_le_add.2\n      (Nat.sub_le_iff_le_add'.2 <| by rw [← Nat.add_assoc]; apply sqrt_le_add)\n    simp [s, pair, hl.not_lt, Nat.add_assoc, Nat.add_sub_cancel' (le_of_not_gt h), sm]\n\n"}
{"name":"Nat.pair_unpair'","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n a b : Nat\nH : Eq (Nat.unpair n) { fst := a, snd := b }\n⊢ Eq (Nat.pair a b) n","decl":"theorem pair_unpair' {n a b} (H : unpair n = (a, b)) : pair a b = n := by\n  simpa [H] using pair_unpair n\n\n"}
{"name":"Nat.unpair_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a b : Nat\n⊢ Eq (Nat.unpair (Nat.pair a b)) { fst := a, snd := b }","decl":"@[simp]\ntheorem unpair_pair (a b : ℕ) : unpair (pair a b) = (a, b) := by\n  dsimp only [pair]; split_ifs with h\n  · show unpair (b * b + a) = (a, b)\n    have be : sqrt (b * b + a) = b := sqrt_add_eq _ (le_trans (le_of_lt h) (Nat.le_add_left _ _))\n    simp [unpair, be, Nat.add_sub_cancel_left, h]\n  · show unpair (a * a + a + b) = (a, b)\n    have ae : sqrt (a * a + (a + b)) = a := by\n      rw [sqrt_add_eq]\n      exact Nat.add_le_add_left (le_of_not_gt h) _\n    simp [unpair, ae, Nat.not_lt_zero, Nat.add_assoc, Nat.add_sub_cancel_left]\n\n"}
{"name":"Nat.pairEquiv_symm_apply","module":"Mathlib.Data.Nat.Pairing","initialProofState":"⊢ Eq (⇑Nat.pairEquiv.symm) Nat.unpair","decl":"/-- An equivalence between `ℕ × ℕ` and `ℕ`. -/\n@[simps (config := .asFn)]\ndef pairEquiv : ℕ × ℕ ≃ ℕ :=\n  ⟨uncurry pair, unpair, fun ⟨a, b⟩ => unpair_pair a b, pair_unpair⟩\n\n"}
{"name":"Nat.pairEquiv_apply","module":"Mathlib.Data.Nat.Pairing","initialProofState":"⊢ Eq (⇑Nat.pairEquiv) (Function.uncurry Nat.pair)","decl":"/-- An equivalence between `ℕ × ℕ` and `ℕ`. -/\n@[simps (config := .asFn)]\ndef pairEquiv : ℕ × ℕ ≃ ℕ :=\n  ⟨uncurry pair, unpair, fun ⟨a, b⟩ => unpair_pair a b, pair_unpair⟩\n\n"}
{"name":"Nat.surjective_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"⊢ Function.Surjective Nat.unpair","decl":"theorem surjective_unpair : Surjective unpair :=\n  pairEquiv.symm.surjective\n\n"}
{"name":"Nat.pair_eq_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a b c d : Nat\n⊢ Iff (Eq (Nat.pair a b) (Nat.pair c d)) (And (Eq a c) (Eq b d))","decl":"@[simp]\ntheorem pair_eq_pair {a b c d : ℕ} : pair a b = pair c d ↔ a = c ∧ b = d :=\n  pairEquiv.injective.eq_iff.trans (@Prod.ext_iff ℕ ℕ (a, b) (c, d))\n\n"}
{"name":"Nat.unpair_lt","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n : Nat\nn1 : LE.le 1 n\n⊢ LT.lt (Nat.unpair n).1 n","decl":"theorem unpair_lt {n : ℕ} (n1 : 1 ≤ n) : (unpair n).1 < n := by\n  let s := sqrt n\n  simp only [unpair, Nat.sub_le_iff_le_add]\n  by_cases h : n - s * s < s <;> simp [s, h, ↓reduceIte]\n  · exact lt_of_lt_of_le h (sqrt_le_self _)\n  · simp only [not_lt] at h\n    have s0 : 0 < s := sqrt_pos.2 n1\n    exact lt_of_le_of_lt h (Nat.sub_lt n1 (Nat.mul_pos s0 s0))\n\n"}
{"name":"Nat.unpair_zero","module":"Mathlib.Data.Nat.Pairing","initialProofState":"⊢ Eq (Nat.unpair 0) 0","decl":"@[simp]\ntheorem unpair_zero : unpair 0 = 0 := by\n  rw [unpair]\n  simp\n\n"}
{"name":"Nat.unpair_left_le","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n : Nat\n⊢ LE.le (Nat.unpair n).1 n","decl":"theorem unpair_left_le : ∀ n : ℕ, (unpair n).1 ≤ n\n  | 0 => by simp\n  | _ + 1 => le_of_lt (unpair_lt (Nat.succ_pos _))\n\n"}
{"name":"Nat.left_le_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a b : Nat\n⊢ LE.le a (Nat.pair a b)","decl":"theorem left_le_pair (a b : ℕ) : a ≤ pair a b := by simpa using unpair_left_le (pair a b)\n\n"}
{"name":"Nat.right_le_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a b : Nat\n⊢ LE.le b (Nat.pair a b)","decl":"theorem right_le_pair (a b : ℕ) : b ≤ pair a b := by\n  by_cases h : a < b\n  · simpa [pair, h] using le_trans (le_mul_self _) (Nat.le_add_right _ _)\n  · simp [pair, h]\n\n"}
{"name":"Nat.unpair_right_le","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n : Nat\n⊢ LE.le (Nat.unpair n).2 n","decl":"theorem unpair_right_le (n : ℕ) : (unpair n).2 ≤ n := by\n  simpa using right_le_pair n.unpair.1 n.unpair.2\n\n"}
{"name":"Nat.pair_lt_pair_left","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a₁ a₂ b : Nat\nh : LT.lt a₁ a₂\n⊢ LT.lt (Nat.pair a₁ b) (Nat.pair a₂ b)","decl":"theorem pair_lt_pair_left {a₁ a₂} (b) (h : a₁ < a₂) : pair a₁ b < pair a₂ b := by\n  by_cases h₁ : a₁ < b <;> simp [pair, h₁, Nat.add_assoc]\n  · by_cases h₂ : a₂ < b <;> simp [pair, h₂, h]\n    simp? at h₂ says simp only [not_lt] at h₂\n    apply Nat.add_lt_add_of_le_of_lt\n    · exact Nat.mul_self_le_mul_self h₂\n    · exact Nat.lt_add_right _ h\n  · simp at h₁\n    simp only [not_lt_of_gt (lt_of_le_of_lt h₁ h), ite_false]\n    apply add_lt_add\n    · exact Nat.mul_self_lt_mul_self h\n    · apply Nat.add_lt_add_right; assumption\n\n"}
{"name":"Nat.pair_lt_pair_right","module":"Mathlib.Data.Nat.Pairing","initialProofState":"a b₁ b₂ : Nat\nh : LT.lt b₁ b₂\n⊢ LT.lt (Nat.pair a b₁) (Nat.pair a b₂)","decl":"theorem pair_lt_pair_right (a) {b₁ b₂} (h : b₁ < b₂) : pair a b₁ < pair a b₂ := by\n  by_cases h₁ : a < b₁\n  · simpa [pair, h₁, Nat.add_assoc, lt_trans h₁ h, h] using mul_self_lt_mul_self h\n  · simp only [pair, h₁, ↓reduceIte, Nat.add_assoc]\n    by_cases h₂ : a < b₂ <;> simp [pair, h₂, h]\n    simp? at h₁ says simp only [not_lt] at h₁\n    rw [Nat.add_comm, Nat.add_comm _ a, Nat.add_assoc, Nat.add_lt_add_iff_left]\n    rwa [Nat.add_comm, ← sqrt_lt, sqrt_add_eq]\n    exact le_trans h₁ (Nat.le_add_left _ _)\n\n"}
{"name":"Nat.pair_lt_max_add_one_sq","module":"Mathlib.Data.Nat.Pairing","initialProofState":"m n : Nat\n⊢ LT.lt (Nat.pair m n) (HPow.hPow (HAdd.hAdd (Max.max m n) 1) 2)","decl":"theorem pair_lt_max_add_one_sq (m n : ℕ) : pair m n < (max m n + 1) ^ 2 := by\n  simp only [pair, Nat.pow_two, Nat.mul_add, Nat.add_mul, Nat.mul_one, Nat.one_mul, Nat.add_assoc]\n  split_ifs <;> simp [Nat.max_eq_left, Nat.max_eq_right, Nat.le_of_lt,  not_lt.1, *] <;> omega\n\n"}
{"name":"Nat.max_sq_add_min_le_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"m n : Nat\n⊢ LE.le (HAdd.hAdd (HPow.hPow (Max.max m n) 2) (Min.min m n)) (Nat.pair m n)","decl":"theorem max_sq_add_min_le_pair (m n : ℕ) : max m n ^ 2 + min m n ≤ pair m n := by\n  rw [pair]\n  cases' lt_or_le m n with h h\n  · rw [if_pos h, max_eq_right h.le, min_eq_left h.le, Nat.pow_two]\n  rw [if_neg h.not_lt, max_eq_left h, min_eq_right h, Nat.pow_two, Nat.add_assoc,\n    Nat.add_le_add_iff_left]\n  exact Nat.le_add_left _ _\n\n"}
{"name":"Nat.add_le_pair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"m n : Nat\n⊢ LE.le (HAdd.hAdd m n) (Nat.pair m n)","decl":"theorem add_le_pair (m n : ℕ) : m + n ≤ pair m n := by\n  simp only [pair, Nat.add_assoc]\n  split_ifs\n  · have := le_mul_self n\n    omega\n  · exact Nat.le_add_left _ _\n\n"}
{"name":"Nat.unpair_add_le","module":"Mathlib.Data.Nat.Pairing","initialProofState":"n : Nat\n⊢ LE.le (HAdd.hAdd (Nat.unpair n).1 (Nat.unpair n).2) n","decl":"theorem unpair_add_le (n : ℕ) : (unpair n).1 + (unpair n).2 ≤ n :=\n  (add_le_pair _ _).trans_eq (pair_unpair _)\n\n"}
{"name":"iSup_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → Nat → α\n⊢ Eq (iSup fun n => f (Nat.unpair n).1 (Nat.unpair n).2) (iSup fun i => iSup fun j => f i j)","decl":"theorem iSup_unpair {α} [CompleteLattice α] (f : ℕ → ℕ → α) :\n    ⨆ n : ℕ, f n.unpair.1 n.unpair.2 = ⨆ (i : ℕ) (j : ℕ), f i j := by\n  rw [← (iSup_prod : ⨆ i : ℕ × ℕ, f i.1 i.2 = _), ← Nat.surjective_unpair.iSup_comp]\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"iInf_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Nat → Nat → α\n⊢ Eq (iInf fun n => f (Nat.unpair n).1 (Nat.unpair n).2) (iInf fun i => iInf fun j => f i j)","decl":"theorem iInf_unpair {α} [CompleteLattice α] (f : ℕ → ℕ → α) :\n    ⨅ n : ℕ, f n.unpair.1 n.unpair.2 = ⨅ (i : ℕ) (j : ℕ), f i j :=\n  iSup_unpair (show ℕ → ℕ → αᵒᵈ from f)\n\n"}
{"name":"Set.iUnion_unpair_prod","module":"Mathlib.Data.Nat.Pairing","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Nat → Set α\nt : Nat → Set β\n⊢ Eq (Set.iUnion fun n => SProd.sprod (s (Nat.unpair n).1) (t (Nat.unpair n).2)) (SProd.sprod (Set.iUnion fun n => s n) (Set.iUnion fun n => t n))","decl":"theorem iUnion_unpair_prod {α β} {s : ℕ → Set α} {t : ℕ → Set β} :\n    ⋃ n : ℕ, s n.unpair.fst ×ˢ t n.unpair.snd = (⋃ n, s n) ×ˢ ⋃ n, t n := by\n  rw [← Set.iUnion_prod]\n  exact surjective_unpair.iUnion_comp (fun x => s x.fst ×ˢ t x.snd)\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iUnion_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"α : Type u_1\nf : Nat → Nat → Set α\n⊢ Eq (Set.iUnion fun n => f (Nat.unpair n).1 (Nat.unpair n).2) (Set.iUnion fun i => Set.iUnion fun j => f i j)","decl":"theorem iUnion_unpair {α} (f : ℕ → ℕ → Set α) :\n    ⋃ n : ℕ, f n.unpair.1 n.unpair.2 = ⋃ (i : ℕ) (j : ℕ), f i j :=\n  iSup_unpair f\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i j) -/\n"}
{"name":"Set.iInter_unpair","module":"Mathlib.Data.Nat.Pairing","initialProofState":"α : Type u_1\nf : Nat → Nat → Set α\n⊢ Eq (Set.iInter fun n => f (Nat.unpair n).1 (Nat.unpair n).2) (Set.iInter fun i => Set.iInter fun j => f i j)","decl":"theorem iInter_unpair {α} (f : ℕ → ℕ → Set α) :\n    ⋂ n : ℕ, f n.unpair.1 n.unpair.2 = ⋂ (i : ℕ) (j : ℕ), f i j :=\n  iInf_unpair f\n\n"}
