{"name":"FirstOrder.Language.BoundedFormula.not_all_isAtomic","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Not φ.all.IsAtomic","decl":"theorem not_all_isAtomic (φ : L.BoundedFormula α (n + 1)) : ¬φ.all.IsAtomic := fun con => by\n  cases con\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.not_ex_isAtomic","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Not φ.ex.IsAtomic","decl":"theorem not_ex_isAtomic (φ : L.BoundedFormula α (n + 1)) : ¬φ.ex.IsAtomic := fun con => by cases con\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.relabel","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn m : Nat\nφ : L.BoundedFormula α m\nh : φ.IsAtomic\nf : α → Sum β (Fin n)\n⊢ (FirstOrder.Language.BoundedFormula.relabel f φ).IsAtomic","decl":"theorem IsAtomic.relabel {m : ℕ} {φ : L.BoundedFormula α m} (h : φ.IsAtomic)\n    (f : α → β ⊕ (Fin n)) : (φ.relabel f).IsAtomic :=\n  IsAtomic.recOn h (fun _ _ => IsAtomic.equal _ _) fun _ _ => IsAtomic.rel _ _\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.liftAt","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : Nat\nφ : L.BoundedFormula α l\nk m : Nat\nh : φ.IsAtomic\n⊢ (FirstOrder.Language.BoundedFormula.liftAt k m φ).IsAtomic","decl":"theorem IsAtomic.liftAt {k m : ℕ} (h : IsAtomic φ) : (φ.liftAt k m).IsAtomic :=\n  IsAtomic.recOn h (fun _ _ => IsAtomic.equal _ _) fun _ _ => IsAtomic.rel _ _\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.castLE","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l : Nat\nφ : L.BoundedFormula α l\nh : LE.le l n\nhφ : φ.IsAtomic\n⊢ (FirstOrder.Language.BoundedFormula.castLE h φ).IsAtomic","decl":"theorem IsAtomic.castLE {h : l ≤ n} (hφ : IsAtomic φ) : (φ.castLE h).IsAtomic :=\n  IsAtomic.recOn hφ (fun _ _ => IsAtomic.equal _ _) fun _ _ => IsAtomic.rel _ _\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.brecOn","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nmotive✝ : (a : L.BoundedFormula α n) → a.IsQF → Prop\na✝ : L.BoundedFormula α n\nx✝ : a✝.IsQF\nih✝ : ∀ (a : L.BoundedFormula α n) (x : a.IsQF), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- A quantifier-free formula is a formula defined without quantifiers. These are all equivalent\nto boolean combinations of atomic formulas. -/\ninductive IsQF : L.BoundedFormula α n → Prop\n  | falsum : IsQF falsum\n  | of_isAtomic {φ} (h : IsAtomic φ) : IsQF φ\n  | imp {φ₁ φ₂} (h₁ : IsQF φ₁) (h₂ : IsQF φ₂) : IsQF (φ₁.imp φ₂)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.isQF","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\na✝ : φ.IsAtomic\n⊢ φ.IsQF","decl":"theorem IsAtomic.isQF {φ : L.BoundedFormula α n} : IsAtomic φ → IsQF φ :=\n  IsQF.of_isAtomic\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.isQF_bot","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\n⊢ Bot.bot.IsQF","decl":"theorem isQF_bot : IsQF (⊥ : L.BoundedFormula α n) :=\n  IsQF.falsum\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.not","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nh : φ.IsQF\n⊢ φ.not.IsQF","decl":"theorem not {φ : L.BoundedFormula α n} (h : IsQF φ) : IsQF φ.not :=\n  h.imp isQF_bot\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.top","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\n⊢ Top.top.IsQF","decl":"theorem top : IsQF (⊤ : L.BoundedFormula α n) := isQF_bot.not\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.sup","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsQF\nhψ : ψ.IsQF\n⊢ (Max.max φ ψ).IsQF","decl":"theorem sup {φ ψ : L.BoundedFormula α n} (hφ : IsQF φ) (hψ : IsQF ψ) : IsQF (φ ⊔ ψ) :=\n  hφ.not.imp hψ\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.inf","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsQF\nhψ : ψ.IsQF\n⊢ (Min.min φ ψ).IsQF","decl":"theorem inf {φ ψ : L.BoundedFormula α n} (hφ : IsQF φ) (hψ : IsQF ψ) : IsQF (φ ⊓ ψ) :=\n  (hφ.imp hψ.not).not\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.relabel","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn m : Nat\nφ : L.BoundedFormula α m\nh : φ.IsQF\nf : α → Sum β (Fin n)\n⊢ (FirstOrder.Language.BoundedFormula.relabel f φ).IsQF","decl":"protected theorem relabel {m : ℕ} {φ : L.BoundedFormula α m} (h : φ.IsQF) (f : α → β ⊕ (Fin n)) :\n    (φ.relabel f).IsQF :=\n  IsQF.recOn h isQF_bot (fun h => (h.relabel f).isQF) fun _ _ h1 h2 => h1.imp h2\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.liftAt","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : Nat\nφ : L.BoundedFormula α l\nk m : Nat\nh : φ.IsQF\n⊢ (FirstOrder.Language.BoundedFormula.liftAt k m φ).IsQF","decl":"protected theorem liftAt {k m : ℕ} (h : IsQF φ) : (φ.liftAt k m).IsQF :=\n  IsQF.recOn h isQF_bot (fun ih => ih.liftAt.isQF) fun _ _ ih1 ih2 => ih1.imp ih2\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.castLE","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l : Nat\nφ : L.BoundedFormula α l\nh : LE.le l n\nhφ : φ.IsQF\n⊢ (FirstOrder.Language.BoundedFormula.castLE h φ).IsQF","decl":"protected theorem castLE {h : l ≤ n} (hφ : IsQF φ) : (φ.castLE h).IsQF :=\n  IsQF.recOn hφ isQF_bot (fun ih => ih.castLE.isQF) fun _ _ ih1 ih2 => ih1.imp ih2\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.not_all_isQF","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Not φ.all.IsQF","decl":"theorem not_all_isQF (φ : L.BoundedFormula α (n + 1)) : ¬φ.all.IsQF := fun con => by\n  cases' con with _ con\n  exact φ.not_all_isAtomic con\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.not_ex_isQF","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α (HAdd.hAdd n 1)\n⊢ Not φ.ex.IsQF","decl":"theorem not_ex_isQF (φ : L.BoundedFormula α (n + 1)) : ¬φ.ex.IsQF := fun con => by\n  cases' con with _ con _ _ con\n  · exact φ.not_ex_isAtomic con\n  · exact not_all_isQF _ con\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsPrenex.brecOn","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nmotive✝ : {n : Nat} → (a : L.BoundedFormula α n) → a.IsPrenex → Prop\nn : Nat\na✝ : L.BoundedFormula α n\nx✝ : a✝.IsPrenex\nih✝ : ∀ {n : Nat} (a : L.BoundedFormula α n) (x : a.IsPrenex), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- Indicates that a bounded formula is in prenex normal form - that is, it consists of quantifiers\n  applied to a quantifier-free formula. -/\ninductive IsPrenex : ∀ {n}, L.BoundedFormula α n → Prop\n  | of_isQF {n} {φ : L.BoundedFormula α n} (h : IsQF φ) : IsPrenex φ\n  | all {n} {φ : L.BoundedFormula α (n + 1)} (h : IsPrenex φ) : IsPrenex φ.all\n  | ex {n} {φ : L.BoundedFormula α (n + 1)} (h : IsPrenex φ) : IsPrenex φ.ex\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.isPrenex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\na✝ : φ.IsQF\n⊢ φ.IsPrenex","decl":"theorem IsQF.isPrenex {φ : L.BoundedFormula α n} : IsQF φ → IsPrenex φ :=\n  IsPrenex.of_isQF\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.isPrenex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nh : φ.IsAtomic\n⊢ φ.IsPrenex","decl":"theorem IsAtomic.isPrenex {φ : L.BoundedFormula α n} (h : IsAtomic φ) : IsPrenex φ :=\n  h.isQF.isPrenex\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsPrenex.induction_on_all_not","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nP : {n : Nat} → L.BoundedFormula α n → Prop\nφ : L.BoundedFormula α n\nh : φ.IsPrenex\nhq : ∀ {m : Nat} {ψ : L.BoundedFormula α m}, ψ.IsQF → P ψ\nha : ∀ {m : Nat} {ψ : L.BoundedFormula α (HAdd.hAdd m 1)}, P ψ → P ψ.all\nhn : ∀ {m : Nat} {ψ : L.BoundedFormula α m}, P ψ → P ψ.not\n⊢ P φ","decl":"theorem IsPrenex.induction_on_all_not {P : ∀ {n}, L.BoundedFormula α n → Prop}\n    {φ : L.BoundedFormula α n} (h : IsPrenex φ)\n    (hq : ∀ {m} {ψ : L.BoundedFormula α m}, ψ.IsQF → P ψ)\n    (ha : ∀ {m} {ψ : L.BoundedFormula α (m + 1)}, P ψ → P ψ.all)\n    (hn : ∀ {m} {ψ : L.BoundedFormula α m}, P ψ → P ψ.not) : P φ :=\n  IsPrenex.recOn h hq (fun _ => ha) fun _ ih => hn (ha (hn ih))\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsPrenex.relabel","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nβ : Type v'\nn m : Nat\nφ : L.BoundedFormula α m\nh : φ.IsPrenex\nf : α → Sum β (Fin n)\n⊢ (FirstOrder.Language.BoundedFormula.relabel f φ).IsPrenex","decl":"theorem IsPrenex.relabel {m : ℕ} {φ : L.BoundedFormula α m} (h : φ.IsPrenex)\n    (f : α → β ⊕ (Fin n)) : (φ.relabel f).IsPrenex :=\n  IsPrenex.recOn h (fun h => (h.relabel f).isPrenex) (fun _ h => by simp [h.all])\n    fun _ h => by simp [h.ex]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsPrenex.castLE","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : Nat\nφ : L.BoundedFormula α l\nhφ : φ.IsPrenex\nn : Nat\nh : LE.le l n\n⊢ (FirstOrder.Language.BoundedFormula.castLE h φ).IsPrenex","decl":"theorem IsPrenex.castLE (hφ : IsPrenex φ) : ∀ {n} {h : l ≤ n}, (φ.castLE h).IsPrenex :=\n  IsPrenex.recOn (motive := @fun l φ _ => ∀ (n : ℕ) (h : l ≤ n), (φ.castLE h).IsPrenex) hφ\n    (@fun _ _ ih _ _ => ih.castLE.isPrenex)\n    (@fun _ _ _ ih _ _ => (ih _ _).all)\n    (@fun _ _ _ ih _ _ => (ih _ _).ex) _ _\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsPrenex.liftAt","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nl : Nat\nφ : L.BoundedFormula α l\nk m : Nat\nh : φ.IsPrenex\n⊢ (FirstOrder.Language.BoundedFormula.liftAt k m φ).IsPrenex","decl":"theorem IsPrenex.liftAt {k m : ℕ} (h : IsPrenex φ) : (φ.liftAt k m).IsPrenex :=\n  IsPrenex.recOn h (fun ih => ih.liftAt.isPrenex) (fun _ ih => ih.castLE.all)\n    fun _ ih => ih.castLE.ex\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.toPrenexImpRight","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\na✝ : ψ.IsQF\n⊢ Eq (φ.toPrenexImpRight ψ) (φ.imp ψ)","decl":"theorem IsQF.toPrenexImpRight {φ : L.BoundedFormula α n} :\n    ∀ {ψ : L.BoundedFormula α n}, IsQF ψ → φ.toPrenexImpRight ψ = φ.imp ψ\n  | _, IsQF.falsum => rfl\n  | _, IsQF.of_isAtomic (IsAtomic.equal _ _) => rfl\n  | _, IsQF.of_isAtomic (IsAtomic.rel _ _) => rfl\n  | _, IsQF.imp IsQF.falsum _ => rfl\n  | _, IsQF.imp (IsQF.of_isAtomic (IsAtomic.equal _ _)) _ => rfl\n  | _, IsQF.imp (IsQF.of_isAtomic (IsAtomic.rel _ _)) _ => rfl\n  | _, IsQF.imp (IsQF.imp _ _) _ => rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.isPrenex_toPrenexImpRight","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsQF\nhψ : ψ.IsPrenex\n⊢ (φ.toPrenexImpRight ψ).IsPrenex","decl":"theorem isPrenex_toPrenexImpRight {φ ψ : L.BoundedFormula α n} (hφ : IsQF φ) (hψ : IsPrenex ψ) :\n    IsPrenex (φ.toPrenexImpRight ψ) := by\n  induction hψ with\n  | of_isQF hψ => rw [hψ.toPrenexImpRight]; exact (hφ.imp hψ).isPrenex\n  | all _ ih1 => exact (ih1 hφ.liftAt).all\n  | ex _ ih2 => exact (ih2 hφ.liftAt).ex\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.toPrenexImp","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\na✝ : φ.IsQF\n⊢ Eq (φ.toPrenexImp ψ) (φ.toPrenexImpRight ψ)","decl":"theorem IsQF.toPrenexImp :\n    ∀ {φ ψ : L.BoundedFormula α n}, φ.IsQF → φ.toPrenexImp ψ = φ.toPrenexImpRight ψ\n  | _, _, IsQF.falsum => rfl\n  | _, _, IsQF.of_isAtomic (IsAtomic.equal _ _) => rfl\n  | _, _, IsQF.of_isAtomic (IsAtomic.rel _ _) => rfl\n  | _, _, IsQF.imp IsQF.falsum _ => rfl\n  | _, _, IsQF.imp (IsQF.of_isAtomic (IsAtomic.equal _ _)) _ => rfl\n  | _, _, IsQF.imp (IsQF.of_isAtomic (IsAtomic.rel _ _)) _ => rfl\n  | _, _, IsQF.imp (IsQF.imp _ _) _ => rfl\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.isPrenex_toPrenexImp","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsPrenex\nhψ : ψ.IsPrenex\n⊢ (φ.toPrenexImp ψ).IsPrenex","decl":"theorem isPrenex_toPrenexImp {φ ψ : L.BoundedFormula α n} (hφ : IsPrenex φ) (hψ : IsPrenex ψ) :\n    IsPrenex (φ.toPrenexImp ψ) := by\n  induction hφ with\n  | of_isQF hφ => rw [hφ.toPrenexImp]; exact isPrenex_toPrenexImpRight hφ hψ\n  | all _ ih1 => exact (ih1 hψ.liftAt).ex\n  | ex _ ih2 => exact (ih2 hψ.liftAt).all\n\n-- Porting note: universes in different order\n"}
{"name":"FirstOrder.Language.BoundedFormula.toPrenex_isPrenex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\n⊢ φ.toPrenex.IsPrenex","decl":"theorem toPrenex_isPrenex (φ : L.BoundedFormula α n) : φ.toPrenex.IsPrenex :=\n  BoundedFormula.recOn φ isQF_bot.isPrenex (fun _ _ => (IsAtomic.equal _ _).isPrenex)\n    (fun _ _ => (IsAtomic.rel _ _).isPrenex) (fun _ _ h1 h2 => isPrenex_toPrenexImp h1 h2)\n    fun _ => IsPrenex.all\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_toPrenexImpRight","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nn : Nat\ninst✝ : Nonempty M\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsQF\nhψ : ψ.IsPrenex\nv : α → M\nxs : Fin n → M\n⊢ Iff ((φ.toPrenexImpRight ψ).Realize v xs) ((φ.imp ψ).Realize v xs)","decl":"theorem realize_toPrenexImpRight {φ ψ : L.BoundedFormula α n} (hφ : IsQF φ) (hψ : IsPrenex ψ)\n    {v : α → M} {xs : Fin n → M} :\n    (φ.toPrenexImpRight ψ).Realize v xs ↔ (φ.imp ψ).Realize v xs := by\n  induction hψ with\n  | of_isQF hψ => rw [hψ.toPrenexImpRight]\n  | all _ ih =>\n    refine _root_.trans (forall_congr' fun _ => ih hφ.liftAt) ?_\n    simp only [realize_imp, realize_liftAt_one_self, snoc_comp_castSucc, realize_all]\n    exact ⟨fun h1 a h2 => h1 h2 a, fun h1 h2 a => h1 a h2⟩\n  | ex _ ih =>\n    unfold toPrenexImpRight\n    rw [realize_ex]\n    refine _root_.trans (exists_congr fun _ => ih hφ.liftAt) ?_\n    simp only [realize_imp, realize_liftAt_one_self, snoc_comp_castSucc, realize_ex]\n    refine ⟨?_, fun h' => ?_⟩\n    · rintro ⟨a, ha⟩ h\n      exact ⟨a, ha h⟩\n    · by_cases h : φ.Realize v xs\n      · obtain ⟨a, ha⟩ := h' h\n        exact ⟨a, fun _ => ha⟩\n      · inhabit M\n        exact ⟨default, fun h'' => (h h'').elim⟩\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_toPrenexImp","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nn : Nat\ninst✝ : Nonempty M\nφ ψ : L.BoundedFormula α n\nhφ : φ.IsPrenex\nhψ : ψ.IsPrenex\nv : α → M\nxs : Fin n → M\n⊢ Iff ((φ.toPrenexImp ψ).Realize v xs) ((φ.imp ψ).Realize v xs)","decl":"theorem realize_toPrenexImp {φ ψ : L.BoundedFormula α n} (hφ : IsPrenex φ) (hψ : IsPrenex ψ)\n    {v : α → M} {xs : Fin n → M} : (φ.toPrenexImp ψ).Realize v xs ↔ (φ.imp ψ).Realize v xs := by\n  revert ψ\n  induction hφ with\n  | of_isQF hφ =>\n    intro ψ hψ\n    rw [hφ.toPrenexImp]\n    exact realize_toPrenexImpRight hφ hψ\n  | all _ ih =>\n    intro ψ hψ\n    unfold toPrenexImp\n    rw [realize_ex]\n    refine _root_.trans (exists_congr fun _ => ih hψ.liftAt) ?_\n    simp only [realize_imp, realize_liftAt_one_self, snoc_comp_castSucc, realize_all]\n    refine ⟨?_, fun h' => ?_⟩\n    · rintro ⟨a, ha⟩ h\n      exact ha (h a)\n    · by_cases h : ψ.Realize v xs\n      · inhabit M\n        exact ⟨default, fun _h'' => h⟩\n      · obtain ⟨a, ha⟩ := not_forall.1 (h ∘ h')\n        exact ⟨a, fun h => (ha h).elim⟩\n  | ex _ ih =>\n    intro ψ hψ\n    refine _root_.trans (forall_congr' fun _ => ih hψ.liftAt) ?_\n    simp\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.realize_toPrenex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nα : Type u'\nn : Nat\ninst✝ : Nonempty M\nφ : L.BoundedFormula α n\nv : α → M\nxs : Fin n → M\n⊢ Iff (φ.toPrenex.Realize v xs) (φ.Realize v xs)","decl":"@[simp]\ntheorem realize_toPrenex (φ : L.BoundedFormula α n) {v : α → M} :\n    ∀ {xs : Fin n → M}, φ.toPrenex.Realize v xs ↔ φ.Realize v xs := by\n  induction φ with\n  | falsum => exact Iff.rfl\n  | equal => exact Iff.rfl\n  | rel => exact Iff.rfl\n  | imp f1 f2 h1 h2 =>\n    intros\n    rw [toPrenex, realize_toPrenexImp f1.toPrenex_isPrenex f2.toPrenex_isPrenex, realize_imp,\n      realize_imp, h1, h2]\n  | all _ h =>\n    intros\n    rw [realize_all, toPrenex, realize_all]\n    exact forall_congr' fun a => h\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_sup_not","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nP : L.BoundedFormula α n → Prop\nφ : L.BoundedFormula α n\nh : φ.IsQF\nhf : P Bot.bot\nha : ∀ (ψ : L.BoundedFormula α n), ψ.IsAtomic → P ψ\nhsup : ∀ {φ₁ φ₂ : L.BoundedFormula α n}, P φ₁ → P φ₂ → P (Max.max φ₁ φ₂)\nhnot : ∀ {φ : L.BoundedFormula α n}, P φ → P φ.not\nhse : ∀ {φ₁ φ₂ : L.BoundedFormula α n}, EmptyCollection.emptyCollection.Iff φ₁ φ₂ → Iff (P φ₁) (P φ₂)\n⊢ P φ","decl":"theorem IsQF.induction_on_sup_not {P : L.BoundedFormula α n → Prop} {φ : L.BoundedFormula α n}\n    (h : IsQF φ) (hf : P (⊥ : L.BoundedFormula α n))\n    (ha : ∀ ψ : L.BoundedFormula α n, IsAtomic ψ → P ψ)\n    (hsup : ∀ {φ₁ φ₂}, P φ₁ → P φ₂ → P (φ₁ ⊔ φ₂)) (hnot : ∀ {φ}, P φ → P φ.not)\n    (hse :\n      ∀ {φ₁ φ₂ : L.BoundedFormula α n}, (φ₁ ⇔[∅] φ₂) → (P φ₁ ↔ P φ₂)) :\n    P φ :=\n  IsQF.recOn h hf @(ha) fun {φ₁ φ₂} _ _ h1 h2 =>\n    (hse (φ₁.imp_iff_not_sup φ₂)).2 (hsup (hnot h1) h2)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.induction_on_inf_not","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nP : L.BoundedFormula α n → Prop\nφ : L.BoundedFormula α n\nh : φ.IsQF\nhf : P Bot.bot\nha : ∀ (ψ : L.BoundedFormula α n), ψ.IsAtomic → P ψ\nhinf : ∀ {φ₁ φ₂ : L.BoundedFormula α n}, P φ₁ → P φ₂ → P (Min.min φ₁ φ₂)\nhnot : ∀ {φ : L.BoundedFormula α n}, P φ → P φ.not\nhse : ∀ {φ₁ φ₂ : L.BoundedFormula α n}, EmptyCollection.emptyCollection.Iff φ₁ φ₂ → Iff (P φ₁) (P φ₂)\n⊢ P φ","decl":"theorem IsQF.induction_on_inf_not {P : L.BoundedFormula α n → Prop} {φ : L.BoundedFormula α n}\n    (h : IsQF φ) (hf : P (⊥ : L.BoundedFormula α n))\n    (ha : ∀ ψ : L.BoundedFormula α n, IsAtomic ψ → P ψ)\n    (hinf : ∀ {φ₁ φ₂}, P φ₁ → P φ₂ → P (φ₁ ⊓ φ₂)) (hnot : ∀ {φ}, P φ → P φ.not)\n    (hse :\n      ∀ {φ₁ φ₂ : L.BoundedFormula α n}, (φ₁ ⇔[∅] φ₂) → (P φ₁ ↔ P φ₂)) :\n    P φ :=\n  h.induction_on_sup_not hf ha\n    (fun {φ₁ φ₂} h1 h2 =>\n      (hse (φ₁.sup_iff_not_inf_not φ₂)).2 (hnot (hinf (hnot h1) (hnot h2))))\n    (fun {_} => hnot) fun {_ _} => hse\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.iff_toPrenex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\n⊢ EmptyCollection.emptyCollection.Iff φ φ.toPrenex","decl":"theorem iff_toPrenex (φ : L.BoundedFormula α n) :\n    φ ⇔[∅] φ.toPrenex := fun M v xs => by\n  rw [realize_iff, realize_toPrenex]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.induction_on_all_ex","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nP : {m : Nat} → L.BoundedFormula α m → Prop\nφ : L.BoundedFormula α n\nhqf : ∀ {m : Nat} {ψ : L.BoundedFormula α m}, ψ.IsQF → P ψ\nhall : ∀ {m : Nat} {ψ : L.BoundedFormula α (HAdd.hAdd m 1)}, P ψ → P ψ.all\nhex : ∀ {m : Nat} {φ : L.BoundedFormula α (HAdd.hAdd m 1)}, P φ → P φ.ex\nhse : ∀ {m : Nat} {φ₁ φ₂ : L.BoundedFormula α m}, EmptyCollection.emptyCollection.Iff φ₁ φ₂ → Iff (P φ₁) (P φ₂)\n⊢ P φ","decl":"theorem induction_on_all_ex {P : ∀ {m}, L.BoundedFormula α m → Prop} (φ : L.BoundedFormula α n)\n    (hqf : ∀ {m} {ψ : L.BoundedFormula α m}, IsQF ψ → P ψ)\n    (hall : ∀ {m} {ψ : L.BoundedFormula α (m + 1)}, P ψ → P ψ.all)\n    (hex : ∀ {m} {φ : L.BoundedFormula α (m + 1)}, P φ → P φ.ex)\n    (hse : ∀ {m} {φ₁ φ₂ : L.BoundedFormula α m},\n      (φ₁ ⇔[∅] φ₂) → (P φ₁ ↔ P φ₂)) :\n    P φ := by\n  suffices h' : ∀ {m} {φ : L.BoundedFormula α m}, φ.IsPrenex → P φ from\n    (hse φ.iff_toPrenex).2 (h' φ.toPrenex_isPrenex)\n  intro m φ hφ\n  induction hφ with\n  | of_isQF hφ => exact hqf hφ\n  | all _ hφ => exact hall hφ\n  | ex _ hφ => exact hex hφ\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.induction_on_exists_not","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nP : {m : Nat} → L.BoundedFormula α m → Prop\nφ : L.BoundedFormula α n\nhqf : ∀ {m : Nat} {ψ : L.BoundedFormula α m}, ψ.IsQF → P ψ\nhnot : ∀ {m : Nat} {φ : L.BoundedFormula α m}, P φ → P φ.not\nhex : ∀ {m : Nat} {φ : L.BoundedFormula α (HAdd.hAdd m 1)}, P φ → P φ.ex\nhse : ∀ {m : Nat} {φ₁ φ₂ : L.BoundedFormula α m}, EmptyCollection.emptyCollection.Iff φ₁ φ₂ → Iff (P φ₁) (P φ₂)\n⊢ P φ","decl":"theorem induction_on_exists_not {P : ∀ {m}, L.BoundedFormula α m → Prop} (φ : L.BoundedFormula α n)\n    (hqf : ∀ {m} {ψ : L.BoundedFormula α m}, IsQF ψ → P ψ)\n    (hnot : ∀ {m} {φ : L.BoundedFormula α m}, P φ → P φ.not)\n    (hex : ∀ {m} {φ : L.BoundedFormula α (m + 1)}, P φ → P φ.ex)\n    (hse : ∀ {m} {φ₁ φ₂ : L.BoundedFormula α m},\n      (φ₁ ⇔[∅] φ₂) → (P φ₁ ↔ P φ₂)) :\n    P φ :=\n  φ.induction_on_all_ex (fun {_ _} => hqf)\n    (fun {_ φ} hφ => (hse φ.all_iff_not_ex_not).2 (hnot (hex (hnot hφ))))\n    (fun {_ _} => hex) fun {_ _ _} => hse\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsUniversal.brecOn","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nmotive✝ : {n : Nat} → (a : L.BoundedFormula α n) → a.IsUniversal → Prop\nn : Nat\na✝ : L.BoundedFormula α n\nx✝ : a✝.IsUniversal\nih✝ : ∀ {n : Nat} (a : L.BoundedFormula α n) (x : a.IsUniversal), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- A universal formula is a formula defined by applying only universal quantifiers to a\nquantifier-free formula. -/\ninductive IsUniversal : ∀ {n}, L.BoundedFormula α n → Prop\n  | of_isQF {n} {φ : L.BoundedFormula α n} (h : IsQF φ) : IsUniversal φ\n  | all {n} {φ : L.BoundedFormula α (n + 1)} (h : IsUniversal φ) : IsUniversal φ.all\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.isUniversal","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\na✝ : φ.IsQF\n⊢ φ.IsUniversal","decl":"lemma IsQF.isUniversal {φ : L.BoundedFormula α n} : IsQF φ → IsUniversal φ :=\n  IsUniversal.of_isQF\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.isUniversal","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nh : φ.IsAtomic\n⊢ φ.IsUniversal","decl":"lemma IsAtomic.isUniversal {φ : L.BoundedFormula α n} (h : IsAtomic φ) : IsUniversal φ :=\n  h.isQF.isUniversal\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsExistential.brecOn","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nmotive✝ : {n : Nat} → (a : L.BoundedFormula α n) → a.IsExistential → Prop\nn : Nat\na✝ : L.BoundedFormula α n\nx✝ : a✝.IsExistential\nih✝ : ∀ {n : Nat} (a : L.BoundedFormula α n) (x : a.IsExistential), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- An existential formula is a formula defined by applying only existential quantifiers to a\nquantifier-free formula. -/\ninductive IsExistential : ∀ {n}, L.BoundedFormula α n → Prop\n  | of_isQF {n} {φ : L.BoundedFormula α n} (h : IsQF φ) : IsExistential φ\n  | ex {n} {φ : L.BoundedFormula α (n + 1)} (h : IsExistential φ) : IsExistential φ.ex\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.isExistential","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\na✝ : φ.IsQF\n⊢ φ.IsExistential","decl":"lemma IsQF.isExistential {φ : L.BoundedFormula α n} : IsQF φ → IsExistential φ :=\n  IsExistential.of_isQF\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.isExistential","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nφ : L.BoundedFormula α n\nh : φ.IsAtomic\n⊢ φ.IsExistential","decl":"lemma IsAtomic.isExistential {φ : L.BoundedFormula α n} (h : IsAtomic φ) : IsExistential φ :=\n  h.isQF.isExistential\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.realize_comp_of_injective","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nM : Type u_1\ninst✝³ : L.Structure M\nN : Type u_2\ninst✝² : L.Structure N\nF : Type u_3\ninst✝¹ : FunLike F M N\nφ : L.BoundedFormula α n\nhA : φ.IsAtomic\ninst✝ : L.HomClass F M N\nf : F\nhInj : Function.Injective ⇑f\nv : α → M\nxs : Fin n → M\na✝ : φ.Realize v xs\n⊢ φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)","decl":"lemma IsAtomic.realize_comp_of_injective {φ : L.BoundedFormula α n} (hA : φ.IsAtomic)\n    [L.HomClass F M N] {f : F} (hInj : Function.Injective f) {v : α → M} {xs : Fin n → M} :\n    φ.Realize v xs → φ.Realize (f ∘ v) (f ∘ xs) := by\n  induction hA with\n  | equal t₁ t₂ => simp only [realize_bdEqual, ← Sum.comp_elim, HomClass.realize_term, hInj.eq_iff,\n    imp_self]\n  | rel R ts =>\n    simp only [realize_rel, ← Sum.comp_elim, HomClass.realize_term]\n    exact HomClass.map_rel f R (fun i => Term.realize (Sum.elim v xs) (ts i))\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsAtomic.realize_comp","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nM : Type u_1\ninst✝⁴ : L.Structure M\nN : Type u_2\ninst✝³ : L.Structure N\nF : Type u_3\ninst✝² : FunLike F M N\nφ : L.BoundedFormula α n\nhA : φ.IsAtomic\ninst✝¹ : EmbeddingLike F M N\ninst✝ : L.HomClass F M N\nf : F\nv : α → M\nxs : Fin n → M\na✝ : φ.Realize v xs\n⊢ φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)","decl":"lemma IsAtomic.realize_comp {φ : L.BoundedFormula α n} (hA : φ.IsAtomic)\n    [EmbeddingLike F M N] [L.HomClass F M N] (f : F) {v : α → M} {xs : Fin n → M} :\n    φ.Realize v xs → φ.Realize (f ∘ v) (f ∘ xs) :=\n  hA.realize_comp_of_injective (EmbeddingLike.injective f)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsQF.realize_embedding","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nM : Type u_1\ninst✝⁴ : L.Structure M\nN : Type u_2\ninst✝³ : L.Structure N\nF : Type u_3\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : L.StrongHomClass F M N\nφ : L.BoundedFormula α n\nhQF : φ.IsQF\nf : F\nv : α → M\nxs : Fin n → M\n⊢ Iff (φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)) (φ.Realize v xs)","decl":"lemma IsQF.realize_embedding {φ : L.BoundedFormula α n} (hQF : φ.IsQF)\n    (f : F) {v : α → M} {xs : Fin n → M} :\n    φ.Realize (f ∘ v) (f ∘ xs) ↔ φ.Realize v xs := by\n  induction hQF with\n  | falsum => rfl\n  | of_isAtomic hA => induction hA with\n    | equal t₁ t₂ => simp only [realize_bdEqual, ← Sum.comp_elim, HomClass.realize_term,\n        (EmbeddingLike.injective f).eq_iff]\n    | rel R ts =>\n      simp only [realize_rel, ← Sum.comp_elim, HomClass.realize_term]\n      exact StrongHomClass.map_rel f R (fun i => Term.realize (Sum.elim v xs) (ts i))\n  | imp _ _ ihφ ihψ => simp only [realize_imp, ihφ, ihψ]\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsUniversal.realize_embedding","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nM : Type u_1\ninst✝⁴ : L.Structure M\nN : Type u_2\ninst✝³ : L.Structure N\nF : Type u_3\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : L.StrongHomClass F M N\nφ : L.BoundedFormula α n\nhU : φ.IsUniversal\nf : F\nv : α → M\nxs : Fin n → M\na✝ : φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)\n⊢ φ.Realize v xs","decl":"lemma IsUniversal.realize_embedding {φ : L.BoundedFormula α n} (hU : φ.IsUniversal)\n    (f : F) {v : α → M} {xs : Fin n → M} :\n    φ.Realize (f ∘ v) (f ∘ xs) → φ.Realize v xs := by\n  induction hU with\n  | of_isQF hQF => simp [hQF.realize_embedding]\n  | all _ ih =>\n    simp only [realize_all, Nat.succ_eq_add_one]\n    refine fun h a => ih ?_\n    rw [Fin.comp_snoc]\n    exact h (f a)\n\n"}
{"name":"FirstOrder.Language.BoundedFormula.IsExistential.realize_embedding","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn : Nat\nM : Type u_1\ninst✝⁴ : L.Structure M\nN : Type u_2\ninst✝³ : L.Structure N\nF : Type u_3\ninst✝² : FunLike F M N\ninst✝¹ : EmbeddingLike F M N\ninst✝ : L.StrongHomClass F M N\nφ : L.BoundedFormula α n\nhE : φ.IsExistential\nf : F\nv : α → M\nxs : Fin n → M\na✝ : φ.Realize v xs\n⊢ φ.Realize (Function.comp (⇑f) v) (Function.comp (⇑f) xs)","decl":"lemma IsExistential.realize_embedding {φ : L.BoundedFormula α n} (hE : φ.IsExistential)\n    (f : F) {v : α → M} {xs : Fin n → M} :\n    φ.Realize v xs → φ.Realize (f ∘ v) (f ∘ xs) := by\n  induction hE with\n  | of_isQF hQF => simp [hQF.realize_embedding]\n  | ex _ ih =>\n    simp only [realize_ex, Nat.succ_eq_add_one]\n    refine fun ⟨a, ha⟩ => ⟨f a, ?_⟩\n    rw [← Fin.comp_snoc]\n    exact ih ha\n\n"}
{"name":"FirstOrder.Language.Theory.IsUniversal.isUniversal_of_mem","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nself : T.IsUniversal\nφ : L.Sentence\na✝ : Membership.mem T φ\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal φ","decl":"/-- A theory is universal when it is comprised only of universal sentences - these theories apply\nalso to substructures. -/\nclass Theory.IsUniversal (T : L.Theory) : Prop where\n  isUniversal_of_mem : ∀ ⦃φ⦄, φ ∈ T → φ.IsUniversal\n\n"}
{"name":"FirstOrder.Language.Theory.IsUniversal.models_of_embedding","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nT : L.Theory\nhT : T.IsUniversal\nN : Type u_1\ninst✝¹ : L.Structure N\ninst✝ : FirstOrder.Language.Theory.Model N T\nf : L.Embedding M N\n⊢ FirstOrder.Language.Theory.Model M T","decl":"lemma Theory.IsUniversal.models_of_embedding {T : L.Theory} [hT : T.IsUniversal]\n    {N : Type*} [L.Structure N] [N ⊨ T] (f : M ↪[L] N) : M ⊨ T := by\n  simp only [model_iff]\n  refine fun φ hφ => (hT.isUniversal_of_mem hφ).realize_embedding f (?_)\n  rw [Subsingleton.elim (f ∘ default) default, Subsingleton.elim (f ∘ default) default]\n  exact Theory.realize_sentence_of_mem T hφ\n\n"}
{"name":"FirstOrder.Language.Substructure.models_of_isUniversal","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nS : L.Substructure M\nT : L.Theory\ninst✝¹ : T.IsUniversal\ninst✝ : FirstOrder.Language.Theory.Model M T\n⊢ FirstOrder.Language.Theory.Model (Subtype fun x => Membership.mem S x) T","decl":"instance Substructure.models_of_isUniversal\n    (S : L.Substructure M) (T : L.Theory) [T.IsUniversal] [M ⊨ T] : S ⊨ T :=\n  Theory.IsUniversal.models_of_embedding (Substructure.subtype S)\n\n"}
{"name":"FirstOrder.Language.Theory.IsUniversal.insert","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nhT : T.IsUniversal\nφ : L.Sentence\nhφ : FirstOrder.Language.BoundedFormula.IsUniversal φ\n⊢ (Insert.insert φ T).IsUniversal","decl":"lemma Theory.IsUniversal.insert\n    {T : L.Theory} [hT : T.IsUniversal] {φ : L.Sentence} (hφ : φ.IsUniversal) :\n    (insert φ T).IsUniversal := ⟨by\n  simp only [Set.mem_insert_iff, forall_eq_or_imp, hφ, true_and]\n  exact hT.isUniversal_of_mem⟩\n\n"}
{"name":"FirstOrder.Language.Relations.isAtomic","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l : Nat\nr : L.Relations l\nts : Fin l → L.Term (Sum α (Fin n))\n⊢ (r.boundedFormula ts).IsAtomic","decl":"lemma isAtomic (r : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) :\n    IsAtomic (r.boundedFormula ts) := IsAtomic.rel r ts\n\n"}
{"name":"FirstOrder.Language.Relations.isQF","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nα : Type u'\nn l : Nat\nr : L.Relations l\nts : Fin l → L.Term (Sum α (Fin n))\n⊢ (r.boundedFormula ts).IsQF","decl":"lemma isQF (r : L.Relations l) (ts : Fin l → L.Term (α ⊕ (Fin n))) :\n    IsQF (r.boundedFormula ts) := (r.isAtomic ts).isQF\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_reflexive","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.reflexive","decl":"protected lemma isUniversal_reflexive : r.reflexive.IsUniversal :=\n  (r.isQF _).isUniversal.all\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_irreflexive","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.irreflexive","decl":"protected lemma isUniversal_irreflexive : r.irreflexive.IsUniversal :=\n  (r.isAtomic _).isQF.not.isUniversal.all\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_symmetric","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.symmetric","decl":"protected lemma isUniversal_symmetric : r.symmetric.IsUniversal :=\n  ((r.isQF _).imp (r.isQF _)).isUniversal.all.all\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_antisymmetric","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.antisymmetric","decl":"protected lemma isUniversal_antisymmetric : r.antisymmetric.IsUniversal :=\n  ((r.isQF _).imp ((r.isQF _).imp (IsAtomic.equal _ _).isQF)).isUniversal.all.all\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_transitive","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.transitive","decl":"protected lemma isUniversal_transitive : r.transitive.IsUniversal :=\n  ((r.isQF _).imp ((r.isQF _).imp (r.isQF _))).isUniversal.all.all.all\n\n"}
{"name":"FirstOrder.Language.Relations.isUniversal_total","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nr : L.Relations 2\n⊢ FirstOrder.Language.BoundedFormula.IsUniversal r.total","decl":"protected lemma isUniversal_total : r.total.IsUniversal :=\n  ((r.isQF _).sup (r.isQF _)).isUniversal.all.all\n\n"}
{"name":"FirstOrder.Language.Formula.isAtomic_graph","module":"Mathlib.ModelTheory.Complexity","initialProofState":"L : FirstOrder.Language\nn : Nat\nf : L.Functions n\n⊢ FirstOrder.Language.BoundedFormula.IsAtomic (FirstOrder.Language.Formula.graph f)","decl":"theorem Formula.isAtomic_graph (f : L.Functions n) : (Formula.graph f).IsAtomic :=\n  BoundedFormula.IsAtomic.equal _ _\n\n"}
