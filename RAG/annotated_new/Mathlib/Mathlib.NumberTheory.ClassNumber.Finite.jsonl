{"name":"ClassGroup.normBound_pos","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : EuclideanDomain R\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nbS : Basis ι R S\n⊢ LT.lt 0 (ClassGroup.normBound abv bS)","decl":"theorem normBound_pos : 0 < normBound abv bS := by\n  obtain ⟨i, j, k, hijk⟩ : ∃ i j k, Algebra.leftMulMatrix bS (bS i) j k ≠ 0 := by\n    by_contra! h\n    obtain ⟨i⟩ := bS.index_nonempty\n    apply bS.ne_zero i\n    apply\n      (injective_iff_map_eq_zero (Algebra.leftMulMatrix bS)).mp (Algebra.leftMulMatrix_injective bS)\n    ext j k\n    simp [h, DMatrix.zero_apply]\n  simp only [normBound, Algebra.smul_def, eq_natCast]\n  apply mul_pos (Int.natCast_pos.mpr (Nat.factorial_pos _))\n  refine pow_pos (mul_pos (Int.natCast_pos.mpr (Fintype.card_pos_iff.mpr ⟨i⟩)) ?_) _\n  refine lt_of_lt_of_le (abv.pos hijk) (Finset.le_max' _ _ ?_)\n  exact Finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩\n\n"}
{"name":"ClassGroup.norm_le","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : EuclideanDomain R\ninst✝⁴ : CommRing S\ninst✝³ : IsDomain S\ninst✝² : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nbS : Basis ι R S\na : S\ny : Int\nhy : ∀ (k : ι), LE.le (abv ((bS.repr a) k)) y\n⊢ LE.le (abv ((Algebra.norm R) a)) (HMul.hMul (ClassGroup.normBound abv bS) (HPow.hPow y (Fintype.card ι)))","decl":"/-- If the `R`-integral element `a : S` has coordinates `≤ y` with respect to some basis `b`,\nits norm is less than `normBound abv b * y ^ dim S`. -/\ntheorem norm_le (a : S) {y : ℤ} (hy : ∀ k, abv (bS.repr a k) ≤ y) :\n    abv (Algebra.norm R a) ≤ normBound abv bS * y ^ Fintype.card ι := by\n  conv_lhs => rw [← bS.sum_repr a]\n  rw [Algebra.norm_apply, ← LinearMap.det_toMatrix bS]\n  simp only [Algebra.norm_apply, map_sum, map_smul, map_sum, map_smul, Algebra.toMatrix_lmul_eq,\n    normBound, smul_mul_assoc, ← mul_pow]\n  convert Matrix.det_sum_smul_le Finset.univ _ hy using 3\n  · rw [Finset.card_univ, smul_mul_assoc, mul_comm]\n  · intro i j k\n    apply Finset.le_max'\n    exact Finset.mem_image.mpr ⟨⟨i, j, k⟩, Finset.mem_univ _, rfl⟩\n\n"}
{"name":"ClassGroup.norm_lt","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : EuclideanDomain R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain S\ninst✝³ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\nbS : Basis ι R S\nT : Type u_6\ninst✝ : LinearOrderedRing T\na : S\ny : T\nhy : ∀ (k : ι), LT.lt (↑(abv ((bS.repr a) k))) y\n⊢ LT.lt (↑(abv ((Algebra.norm R) a))) (HMul.hMul (↑(ClassGroup.normBound abv bS)) (HPow.hPow y (Fintype.card ι)))","decl":"/-- If the `R`-integral element `a : S` has coordinates `< y` with respect to some basis `b`,\nits norm is strictly less than `normBound abv b * y ^ dim S`. -/\ntheorem norm_lt {T : Type*} [LinearOrderedRing T] (a : S) {y : T}\n    (hy : ∀ k, (abv (bS.repr a k) : T) < y) :\n    (abv (Algebra.norm R a) : T) < normBound abv bS * y ^ Fintype.card ι := by\n  obtain ⟨i⟩ := bS.index_nonempty\n  have him : (Finset.univ.image fun k => abv (bS.repr a k)).Nonempty :=\n    ⟨_, Finset.mem_image.mpr ⟨i, Finset.mem_univ _, rfl⟩⟩\n  set y' : ℤ := Finset.max' _ him with y'_def\n  have hy' : ∀ k, abv (bS.repr a k) ≤ y' := by\n    intro k\n    exact @Finset.le_max' ℤ _ _ _ (Finset.mem_image.mpr ⟨k, Finset.mem_univ _, rfl⟩)\n  have : (y' : T) < y := by\n    rw [y'_def, ←\n      Finset.max'_image (show Monotone (_ : ℤ → T) from fun x y h => Int.cast_le.mpr h)]\n    apply (Finset.max'_lt_iff _ (him.image _)).mpr\n    simp only [Finset.mem_image, exists_prop]\n    rintro _ ⟨x, ⟨k, -, rfl⟩, rfl⟩\n    exact hy k\n  have y'_nonneg : 0 ≤ y' := le_trans (abv.nonneg _) (hy' i)\n  apply (Int.cast_le.mpr (norm_le abv bS a hy')).trans_lt\n  simp only [Int.cast_mul, Int.cast_pow]\n  apply mul_lt_mul' le_rfl\n  · exact pow_lt_pow_left₀ this (Int.cast_nonneg.mpr y'_nonneg) (@Fintype.card_ne_zero _ _ ⟨i⟩)\n  · exact pow_nonneg (Int.cast_nonneg.mpr y'_nonneg) _\n  · exact Int.cast_pos.mpr (normBound_pos abv bS)\n\n\n"}
{"name":"ClassGroup.exists_min","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : EuclideanDomain R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nabv : AbsoluteValue R Int\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal S)) x\n⊢ Exists fun b => And (Membership.mem (↑I) b) (And (Ne b 0) (∀ (c : S), Membership.mem (↑I) c → LT.lt (abv ((Algebra.norm R) c)) (abv ((Algebra.norm R) b)) → Eq c 0))","decl":"/-- A nonzero ideal has an element of minimal norm. -/\ntheorem exists_min (I : (Ideal S)⁰) :\n    ∃ b ∈ (I : Ideal S),\n      b ≠ 0 ∧ ∀ c ∈ (I : Ideal S), abv (Algebra.norm R c) < abv (Algebra.norm R b) → c =\n      (0 : S) := by\n  obtain ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩, min⟩ := @Int.exists_least_of_bdd\n      (fun a => ∃ b ∈ (I : Ideal S), b ≠ (0 : S) ∧ abv (Algebra.norm R b) = a)\n    (by\n      use 0\n      rintro _ ⟨b, _, _, rfl⟩\n      apply abv.nonneg)\n    (by\n      obtain ⟨b, b_mem, b_ne_zero⟩ := (I : Ideal S).ne_bot_iff.mp (nonZeroDivisors.coe_ne_zero I)\n      exact ⟨_, ⟨b, b_mem, b_ne_zero, rfl⟩⟩)\n  refine ⟨b, b_mem, b_ne_zero, ?_⟩\n  intro c hc lt\n  contrapose! lt with c_ne_zero\n  exact min _ ⟨c, hc, c_ne_zero, rfl⟩\n\n"}
{"name":"ClassGroup.finsetApprox.zero_not_mem","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : EuclideanDomain R\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝¹ : Infinite R\ninst✝ : DecidableEq R\n⊢ Not (Membership.mem (ClassGroup.finsetApprox bS adm) 0)","decl":"theorem finsetApprox.zero_not_mem : (0 : R) ∉ finsetApprox bS adm :=\n  Finset.not_mem_erase _ _\n\n"}
{"name":"ClassGroup.mem_finsetApprox","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : EuclideanDomain R\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝¹ : Infinite R\ninst✝ : DecidableEq R\nx : R\n⊢ Iff (Membership.mem (ClassGroup.finsetApprox bS adm) x) (Exists fun i => Exists fun j => And (Ne i j) (Eq (HSub.hSub ((ClassGroup.distinctElems bS adm) i) ((ClassGroup.distinctElems bS adm) j)) x))","decl":"@[simp]\ntheorem mem_finsetApprox {x : R} :\n    x ∈ finsetApprox bS adm ↔ ∃ i j, i ≠ j ∧ distinctElems bS adm i - distinctElems bS adm j =\n    x := by\n  simp only [finsetApprox, Finset.mem_erase, Finset.mem_image]\n  constructor\n  · rintro ⟨hx, ⟨i, j⟩, _, rfl⟩\n    refine ⟨i, j, ?_, rfl⟩\n    rintro rfl\n    simp at hx\n  · rintro ⟨i, j, hij, rfl⟩\n    refine ⟨?_, ⟨i, j⟩, Finset.mem_univ _, rfl⟩\n    rw [Ne, sub_eq_zero]\n    exact fun h => hij ((distinctElems bS adm).injective h)\n\n"}
{"name":"ClassGroup.exists_mem_finsetApprox","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : EuclideanDomain R\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝¹ : Infinite R\ninst✝ : DecidableEq R\na : S\nb : R\nhb : Ne b 0\n⊢ Exists fun q => Exists fun r => And (Membership.mem (ClassGroup.finsetApprox bS adm) r) (LT.lt (abv ((Algebra.norm R) (HSub.hSub (HSMul.hSMul r a) (HSMul.hSMul b q)))) (abv ((Algebra.norm R) ((algebraMap R S) b))))","decl":"/-- We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. -/\ntheorem exists_mem_finsetApprox (a : S) {b} (hb : b ≠ (0 : R)) :\n    ∃ q : S,\n      ∃ r ∈ finsetApprox bS adm, abv (Algebra.norm R (r • a - b • q)) <\n      abv (Algebra.norm R (algebraMap R S b)) := by\n  have dim_pos := Fintype.card_pos_iff.mpr bS.index_nonempty\n  set ε : ℝ := normBound abv bS ^ (-1 / Fintype.card ι : ℝ) with ε_eq\n  have hε : 0 < ε := Real.rpow_pos_of_pos (Int.cast_pos.mpr (normBound_pos abv bS)) _\n  have ε_le : (normBound abv bS : ℝ) * (abv b • ε) ^ (Fintype.card ι : ℝ)\n                ≤ abv b ^ (Fintype.card ι : ℝ) := by\n    have := normBound_pos abv bS\n    have := abv.nonneg b\n    rw [ε_eq, Algebra.smul_def, eq_intCast, mul_rpow, ← rpow_mul, div_mul_cancel₀, rpow_neg_one,\n      mul_left_comm, mul_inv_cancel₀, mul_one, rpow_natCast] <;>\n      try norm_cast; omega\n    · exact Iff.mpr Int.cast_nonneg this\n    · linarith\n  set μ : Fin (cardM bS adm).succ ↪ R := distinctElems bS adm with hμ\n  let s : ι →₀ R := bS.repr a\n  have s_eq : ∀ i, s i = bS.repr a i := fun i => rfl\n  let qs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i / b\n  let rs : Fin (cardM bS adm).succ → ι → R := fun j i => μ j * s i % b\n  have r_eq : ∀ j i, rs j i = μ j * s i % b := fun i j => rfl\n  have μ_eq : ∀ i j, μ j * s i = b * qs j i + rs j i := by\n    intro i j\n    rw [r_eq, EuclideanDomain.div_add_mod]\n  have μ_mul_a_eq : ∀ j, μ j • a = b • ∑ i, qs j i • bS i + ∑ i, rs j i • bS i := by\n    intro j\n    rw [← bS.sum_repr a]\n    simp only [μ, qs, rs, Finset.smul_sum, ← Finset.sum_add_distrib]\n    refine Finset.sum_congr rfl fun i _ => ?_\n-- Porting note `← hμ, ← r_eq` and the final `← μ_eq` were not needed.\n    rw [← hμ, ← r_eq, ← s_eq, ← mul_smul, μ_eq, add_smul, mul_smul, ← μ_eq]\n  obtain ⟨j, k, j_ne_k, hjk⟩ := adm.exists_approx hε hb fun j i => μ j * s i\n  have hjk' : ∀ i, (abv (rs k i - rs j i) : ℝ) < abv b • ε := by simpa only [r_eq] using hjk\n  let q := ∑ i, (qs k i - qs j i) • bS i\n  set r := μ k - μ j with r_eq\n  refine ⟨q, r, (mem_finsetApprox bS adm).mpr ?_, ?_⟩\n  · exact ⟨k, j, j_ne_k.symm, rfl⟩\n  have : r • a - b • q = ∑ x : ι, (rs k x • bS x - rs j x • bS x) := by\n    simp only [q, r_eq, sub_smul, μ_mul_a_eq, Finset.smul_sum, ← Finset.sum_add_distrib,\n      ← Finset.sum_sub_distrib, smul_sub]\n    refine Finset.sum_congr rfl fun x _ => ?_\n    ring\n  rw [this, Algebra.norm_algebraMap_of_basis bS, abv.map_pow]\n  refine Int.cast_lt.mp ((norm_lt abv bS _ fun i => lt_of_le_of_lt ?_ (hjk' i)).trans_le ?_)\n  · apply le_of_eq\n    congr\n    simp_rw [map_sum, map_sub, map_smul, Finset.sum_apply',\n      Finsupp.sub_apply, Finsupp.smul_apply, Finset.sum_sub_distrib, Basis.repr_self_apply,\n      smul_eq_mul, mul_boole, Finset.sum_ite_eq', Finset.mem_univ, if_true]\n  · exact mod_cast ε_le\n\n"}
{"name":"ClassGroup.exists_mem_finset_approx'","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : EuclideanDomain R\ninst✝⁷ : CommRing S\ninst✝⁶ : IsDomain S\ninst✝⁵ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝⁴ : DecidableEq ι\ninst✝³ : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝² : Infinite R\ninst✝¹ : DecidableEq R\ninst✝ : Algebra.IsAlgebraic R S\na b : S\nhb : Ne b 0\n⊢ Exists fun q => Exists fun r => And (Membership.mem (ClassGroup.finsetApprox bS adm) r) (LT.lt (abv ((Algebra.norm R) (HSub.hSub (HSMul.hSMul r a) (HMul.hMul q b)))) (abv ((Algebra.norm R) b)))","decl":"/-- We can approximate `a / b : L` with `q / r`, where `r` has finitely many options for `L`. -/\ntheorem exists_mem_finset_approx' [Algebra.IsAlgebraic R S] (a : S) {b : S} (hb : b ≠ 0) :\n    ∃ q : S,\n      ∃ r ∈ finsetApprox bS adm, abv (Algebra.norm R (r • a - q * b)) < abv (Algebra.norm R b) := by\n  obtain ⟨a', b', hb', h⟩ := Algebra.IsAlgebraic.exists_smul_eq_mul R a hb\n  obtain ⟨q, r, hr, hqr⟩ := exists_mem_finsetApprox bS adm a' hb'\n  refine ⟨q, r, hr, ?_⟩\n  refine\n    lt_of_mul_lt_mul_left ?_ (show 0 ≤ abv (Algebra.norm R (algebraMap R S b')) from abv.nonneg _)\n  refine\n    lt_of_le_of_lt (le_of_eq ?_)\n      (mul_lt_mul hqr le_rfl (abv.pos ((Algebra.norm_ne_zero_iff_of_basis bS).mpr hb))\n        (abv.nonneg _))\n  rw [← abv.map_mul, ← MonoidHom.map_mul, ← abv.map_mul, ← MonoidHom.map_mul, ← Algebra.smul_def,\n    smul_sub b', sub_mul, smul_comm, h, mul_comm b a', Algebra.smul_mul_assoc r a' b,\n    Algebra.smul_mul_assoc b' q b]\n\n"}
{"name":"ClassGroup.prod_finsetApprox_ne_zero","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : EuclideanDomain R\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝¹ : Infinite R\ninst✝ : DecidableEq R\n⊢ Ne ((algebraMap R S) ((ClassGroup.finsetApprox bS adm).prod fun m => m)) 0","decl":"theorem prod_finsetApprox_ne_zero : algebraMap R S (∏ m ∈ finsetApprox bS adm, m) ≠ 0 := by\n  refine mt ((injective_iff_map_eq_zero _).mp bS.algebraMap_injective _) ?_\n  simp only [Finset.prod_eq_zero_iff, not_exists]\n  rintro x ⟨hx, rfl⟩\n  exact finsetApprox.zero_not_mem bS adm hx\n\n"}
{"name":"ClassGroup.ne_bot_of_prod_finsetApprox_mem","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁷ : EuclideanDomain R\ninst✝⁶ : CommRing S\ninst✝⁵ : IsDomain S\ninst✝⁴ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝³ : DecidableEq ι\ninst✝² : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝¹ : Infinite R\ninst✝ : DecidableEq R\nJ : Ideal S\nh : Membership.mem J ((algebraMap R S) ((ClassGroup.finsetApprox bS adm).prod fun m => m))\n⊢ Ne J Bot.bot","decl":"theorem ne_bot_of_prod_finsetApprox_mem (J : Ideal S)\n    (h : algebraMap _ _ (∏ m ∈ finsetApprox bS adm, m) ∈ J) : J ≠ ⊥ :=\n  (Submodule.ne_bot_iff _).mpr ⟨_, h, prod_finsetApprox_ne_zero _ _⟩\n\n"}
{"name":"ClassGroup.exists_mk0_eq_mk0","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁹ : EuclideanDomain R\ninst✝⁸ : CommRing S\ninst✝⁷ : IsDomain S\ninst✝⁶ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝³ : Infinite R\ninst✝² : DecidableEq R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra.IsAlgebraic R S\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal S)) x\n⊢ Exists fun J => And (Eq (ClassGroup.mk0 I) (ClassGroup.mk0 J)) (Membership.mem (↑J) ((algebraMap R S) ((ClassGroup.finsetApprox bS adm).prod fun m => m)))","decl":"/-- Each class in the class group contains an ideal `J`\nsuch that `M := Π m ∈ finsetApprox` is in `J`. -/\ntheorem exists_mk0_eq_mk0 [IsDedekindDomain S] [Algebra.IsAlgebraic R S] (I : (Ideal S)⁰) :\n    ∃ J : (Ideal S)⁰,\n      ClassGroup.mk0 I = ClassGroup.mk0 J ∧\n        algebraMap _ _ (∏ m ∈ finsetApprox bS adm, m) ∈ (J : Ideal S) := by\n  set M := ∏ m ∈ finsetApprox bS adm, m\n  have hM : algebraMap R S M ≠ 0 := prod_finsetApprox_ne_zero bS adm\n  obtain ⟨b, b_mem, b_ne_zero, b_min⟩ := exists_min abv I\n  suffices Ideal.span {b} ∣ Ideal.span {algebraMap _ _ M} * I.1 by\n    obtain ⟨J, hJ⟩ := this\n    refine ⟨⟨J, ?_⟩, ?_, ?_⟩\n    · rw [mem_nonZeroDivisors_iff_ne_zero]\n      rintro rfl\n      rw [Ideal.zero_eq_bot, Ideal.mul_bot] at hJ\n      exact hM (Ideal.span_singleton_eq_bot.mp (I.2 _ hJ))\n    · rw [ClassGroup.mk0_eq_mk0_iff]\n      exact ⟨algebraMap _ _ M, b, hM, b_ne_zero, hJ⟩\n    rw [← SetLike.mem_coe, ← Set.singleton_subset_iff, ← Ideal.span_le, ← Ideal.dvd_iff_le]\n    apply (mul_dvd_mul_iff_left _).mp _\n    swap; · exact mt Ideal.span_singleton_eq_bot.mp b_ne_zero\n    rw [Subtype.coe_mk, Ideal.dvd_iff_le, ← hJ, mul_comm]\n    apply Ideal.mul_mono le_rfl\n    rw [Ideal.span_le, Set.singleton_subset_iff]\n    exact b_mem\n  rw [Ideal.dvd_iff_le, Ideal.mul_le]\n  intro r' hr' a ha\n  rw [Ideal.mem_span_singleton] at hr' ⊢\n  obtain ⟨q, r, r_mem, lt⟩ := exists_mem_finset_approx' bS adm a b_ne_zero\n  apply @dvd_of_mul_left_dvd _ _ q\n  simp only [Algebra.smul_def] at lt\n  rw [←\n    sub_eq_zero.mp (b_min _ (I.1.sub_mem (I.1.mul_mem_left _ ha) (I.1.mul_mem_left _ b_mem)) lt)]\n  refine mul_dvd_mul_right (dvd_trans (RingHom.map_dvd _ ?_) hr') _\n  exact Multiset.dvd_prod (Multiset.mem_map.mpr ⟨_, r_mem, rfl⟩)\n\n"}
{"name":"ClassGroup.mkMMem_surjective","module":"Mathlib.NumberTheory.ClassNumber.Finite","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁹ : EuclideanDomain R\ninst✝⁸ : CommRing S\ninst✝⁷ : IsDomain S\ninst✝⁶ : Algebra R S\nabv : AbsoluteValue R Int\nι : Type u_5\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Fintype ι\nbS : Basis ι R S\nadm : abv.IsAdmissible\ninst✝³ : Infinite R\ninst✝² : DecidableEq R\ninst✝¹ : IsDedekindDomain S\ninst✝ : Algebra.IsAlgebraic R S\n⊢ Function.Surjective (ClassGroup.mkMMem bS adm)","decl":"theorem mkMMem_surjective [IsDedekindDomain S] [Algebra.IsAlgebraic R S] :\n    Function.Surjective (ClassGroup.mkMMem bS adm) := by\n  intro I'\n  obtain ⟨⟨I, hI⟩, rfl⟩ := ClassGroup.mk0_surjective I'\n  obtain ⟨J, mk0_eq_mk0, J_dvd⟩ := exists_mk0_eq_mk0 bS adm ⟨I, hI⟩\n  exact ⟨⟨J, J_dvd⟩, mk0_eq_mk0.symm⟩\n\n"}
