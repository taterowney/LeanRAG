{"name":"sqrt_one_add_norm_sq_le","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nx : E\n⊢ LE.le (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2)).sqrt (HAdd.hAdd 1 (Norm.norm x))","decl":"theorem sqrt_one_add_norm_sq_le (x : E) : √((1 : ℝ) + ‖x‖ ^ 2) ≤ 1 + ‖x‖ := by\n  rw [sqrt_le_left (by positivity)]\n  simp [add_sq]\n\n"}
{"name":"one_add_norm_le_sqrt_two_mul_sqrt","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nx : E\n⊢ LE.le (HAdd.hAdd 1 (Norm.norm x)) (HMul.hMul (Real.sqrt 2) (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2)).sqrt)","decl":"theorem one_add_norm_le_sqrt_two_mul_sqrt (x : E) :\n    (1 : ℝ) + ‖x‖ ≤ √2 * √(1 + ‖x‖ ^ 2) := by\n  rw [← sqrt_mul zero_le_two]\n  have := sq_nonneg (‖x‖ - 1)\n  apply le_sqrt_of_sq_le\n  linarith\n\n"}
{"name":"rpow_neg_one_add_norm_sq_le","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nr : Real\nx : E\nhr : LT.lt 0 r\n⊢ LE.le (HPow.hPow (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2)) (HDiv.hDiv (Neg.neg r) 2)) (HMul.hMul (HPow.hPow 2 (HDiv.hDiv r 2)) (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg r)))","decl":"theorem rpow_neg_one_add_norm_sq_le {r : ℝ} (x : E) (hr : 0 < r) :\n    ((1 : ℝ) + ‖x‖ ^ 2) ^ (-r / 2) ≤ (2 : ℝ) ^ (r / 2) * (1 + ‖x‖) ^ (-r) :=\n  calc\n    ((1 : ℝ) + ‖x‖ ^ 2) ^ (-r / 2)\n      = (2 : ℝ) ^ (r / 2) * ((√2 * √((1 : ℝ) + ‖x‖ ^ 2)) ^ r)⁻¹ := by\n      rw [rpow_div_two_eq_sqrt, rpow_div_two_eq_sqrt, mul_rpow, mul_inv, rpow_neg,\n        mul_inv_cancel_left₀] <;> positivity\n    _ ≤ (2 : ℝ) ^ (r / 2) * ((1 + ‖x‖) ^ r)⁻¹ := by\n      gcongr\n      apply one_add_norm_le_sqrt_two_mul_sqrt\n    _ = (2 : ℝ) ^ (r / 2) * (1 + ‖x‖) ^ (-r) := by rw [rpow_neg]; positivity\n\n"}
{"name":"le_rpow_one_add_norm_iff_norm_le","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nr t : Real\nhr : LT.lt 0 r\nht : LT.lt 0 t\nx : E\n⊢ Iff (LE.le t (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg r))) (LE.le (Norm.norm x) (HSub.hSub (HPow.hPow t (Neg.neg (Inv.inv r))) 1))","decl":"theorem le_rpow_one_add_norm_iff_norm_le {r t : ℝ} (hr : 0 < r) (ht : 0 < t) (x : E) :\n    t ≤ (1 + ‖x‖) ^ (-r) ↔ ‖x‖ ≤ t ^ (-r⁻¹) - 1 := by\n  rw [le_sub_iff_add_le', neg_inv]\n  exact (Real.le_rpow_inv_iff_of_neg (by positivity) ht (neg_lt_zero.mpr hr)).symm\n\n"}
{"name":"closedBall_rpow_sub_one_eq_empty_aux","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nr t : Real\nhr : LT.lt 0 r\nht : LT.lt 1 t\n⊢ Eq (Metric.closedBall 0 (HSub.hSub (HPow.hPow t (Neg.neg (Inv.inv r))) 1)) EmptyCollection.emptyCollection","decl":"theorem closedBall_rpow_sub_one_eq_empty_aux {r t : ℝ} (hr : 0 < r) (ht : 1 < t) :\n    Metric.closedBall (0 : E) (t ^ (-r⁻¹) - 1) = ∅ := by\n  rw [Metric.closedBall_eq_empty, sub_neg]\n  exact Real.rpow_lt_one_of_one_lt_of_neg ht (by simp only [hr, Right.neg_neg_iff, inv_pos])\n\n"}
{"name":"finite_integral_rpow_sub_one_pow_aux","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"r : Real\nn : Nat\nhnr : LT.lt (↑n) r\n⊢ LT.lt (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 1)) fun x => ENNReal.ofReal (HPow.hPow (HSub.hSub (HPow.hPow x (Neg.neg (Inv.inv r))) 1) n)) Top.top","decl":"theorem finite_integral_rpow_sub_one_pow_aux {r : ℝ} (n : ℕ) (hnr : (n : ℝ) < r) :\n    (∫⁻ x : ℝ in Ioc 0 1, ENNReal.ofReal ((x ^ (-r⁻¹) - 1) ^ n)) < ∞ := by\n  have hr : 0 < r := lt_of_le_of_lt n.cast_nonneg hnr\n  have h_int x (hx : x ∈ Ioc (0 : ℝ) 1) := by\n    calc\n      ENNReal.ofReal ((x ^ (-r⁻¹) - 1) ^ n) ≤ .ofReal ((x ^ (-r⁻¹) - 0) ^ n) := by\n        gcongr\n        · rw [sub_nonneg]\n          exact Real.one_le_rpow_of_pos_of_le_one_of_nonpos hx.1 hx.2 (by simpa using hr.le)\n        · norm_num\n      _ = .ofReal (x ^ (-(r⁻¹ * n))) := by simp [rpow_mul hx.1.le, ← neg_mul]\n  refine lt_of_le_of_lt (setLIntegral_mono' measurableSet_Ioc h_int) ?_\n  refine IntegrableOn.setLIntegral_lt_top ?_\n  rw [← intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n  apply intervalIntegral.intervalIntegrable_rpow'\n  rwa [neg_lt_neg_iff, inv_mul_lt_iff₀' hr, one_mul]\n\n"}
{"name":"finite_integral_one_add_norm","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nr : Real\nhnr : LT.lt (↑(Module.finrank Real E)) r\n⊢ LT.lt (MeasureTheory.lintegral μ fun x => ENNReal.ofReal (HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg r))) Top.top","decl":"theorem finite_integral_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :\n    (∫⁻ x : E, ENNReal.ofReal ((1 + ‖x‖) ^ (-r)) ∂μ) < ∞ := by\n  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E).cast_nonneg hnr\n  -- We start by applying the layer cake formula\n  have h_meas : Measurable fun ω : E => (1 + ‖ω‖) ^ (-r) := by fun_prop\n  have h_pos : ∀ x : E, 0 ≤ (1 + ‖x‖) ^ (-r) := fun x ↦ by positivity\n  rw [lintegral_eq_lintegral_meas_le μ (Eventually.of_forall h_pos) h_meas.aemeasurable]\n  have h_int : ∀ t, 0 < t → μ {a : E | t ≤ (1 + ‖a‖) ^ (-r)} =\n      μ (Metric.closedBall (0 : E) (t ^ (-r⁻¹) - 1)) := fun t ht ↦ by\n    congr 1\n    ext x\n    simp only [mem_setOf_eq, mem_closedBall_zero_iff]\n    exact le_rpow_one_add_norm_iff_norm_le hr (mem_Ioi.mp ht) x\n  rw [setLIntegral_congr_fun measurableSet_Ioi (Eventually.of_forall h_int)]\n  set f := fun t : ℝ ↦ μ (Metric.closedBall (0 : E) (t ^ (-r⁻¹) - 1))\n  set mB := μ (Metric.ball (0 : E) 1)\n  -- the next two inequalities are in fact equalities but we don't need that\n  calc\n    ∫⁻ t in Ioi 0, f t ≤ ∫⁻ t in Ioc 0 1 ∪ Ioi 1, f t := lintegral_mono_set Ioi_subset_Ioc_union_Ioi\n    _ ≤ (∫⁻ t in Ioc 0 1, f t) + ∫⁻ t in Ioi 1, f t := lintegral_union_le _ _ _\n    _ < ∞ := ENNReal.add_lt_top.2 ⟨?_, ?_⟩\n  · -- We use estimates from auxiliary lemmas to deal with integral from `0` to `1`\n    have h_int' : ∀ t ∈ Ioc (0 : ℝ) 1,\n        f t = ENNReal.ofReal ((t ^ (-r⁻¹) - 1) ^ finrank ℝ E) * mB := fun t ht ↦ by\n      refine μ.addHaar_closedBall (0 : E) ?_\n      rw [sub_nonneg]\n      exact Real.one_le_rpow_of_pos_of_le_one_of_nonpos ht.1 ht.2 (by simp [hr.le])\n    rw [setLIntegral_congr_fun measurableSet_Ioc (ae_of_all _ h_int'),\n      lintegral_mul_const' _ _ measure_ball_lt_top.ne]\n    exact ENNReal.mul_lt_top\n      (finite_integral_rpow_sub_one_pow_aux (finrank ℝ E) hnr) measure_ball_lt_top\n  · -- The integral from 1 to ∞ is zero:\n    have h_int'' : ∀ t ∈ Ioi (1 : ℝ), f t = 0 := fun t ht => by\n      simp only [f, closedBall_rpow_sub_one_eq_empty_aux E hr ht, measure_empty]\n    -- The integral over the constant zero function is finite:\n    rw [setLIntegral_congr_fun measurableSet_Ioi (ae_of_all volume <| h_int''), lintegral_const 0,\n      zero_mul]\n    exact WithTop.top_pos\n\n"}
{"name":"integrable_one_add_norm","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nr : Real\nhnr : LT.lt (↑(Module.finrank Real E)) r\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (HAdd.hAdd 1 (Norm.norm x)) (Neg.neg r)) μ","decl":"theorem integrable_one_add_norm {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :\n    Integrable (fun x ↦ (1 + ‖x‖) ^ (-r)) μ := by\n  constructor\n  · apply Measurable.aestronglyMeasurable (by fun_prop)\n  -- Lower Lebesgue integral\n  have : (∫⁻ a : E, ‖(1 + ‖a‖) ^ (-r)‖ₑ ∂μ) = ∫⁻ a : E, ENNReal.ofReal ((1 + ‖a‖) ^ (-r)) ∂μ :=\n    lintegral_enorm_of_nonneg fun _ => rpow_nonneg (by positivity) _\n  rw [hasFiniteIntegral_iff_enorm, this]\n  exact finite_integral_one_add_norm hnr\n\n"}
{"name":"integrable_rpow_neg_one_add_norm_sq","module":"Mathlib.Analysis.SpecialFunctions.JapaneseBracket","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nr : Real\nhnr : LT.lt (↑(Module.finrank Real E)) r\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (HAdd.hAdd 1 (HPow.hPow (Norm.norm x) 2)) (HDiv.hDiv (Neg.neg r) 2)) μ","decl":"theorem integrable_rpow_neg_one_add_norm_sq {r : ℝ} (hnr : (finrank ℝ E : ℝ) < r) :\n    Integrable (fun x ↦ ((1 : ℝ) + ‖x‖ ^ 2) ^ (-r / 2)) μ := by\n  have hr : 0 < r := lt_of_le_of_lt (finrank ℝ E).cast_nonneg hnr\n  refine ((integrable_one_add_norm hnr).const_mul <| (2 : ℝ) ^ (r / 2)).mono'\n    ?_ (Eventually.of_forall fun x => ?_)\n  · apply Measurable.aestronglyMeasurable (by fun_prop)\n  refine (abs_of_pos ?_).trans_le (rpow_neg_one_add_norm_sq_le x hr)\n  positivity\n"}
