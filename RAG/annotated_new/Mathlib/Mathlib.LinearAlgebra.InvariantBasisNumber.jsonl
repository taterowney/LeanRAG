{"name":"StrongRankCondition.le_of_fin_injective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : StrongRankCondition R\nn m : Nat\nf : LinearMap (RingHom.id R) (Fin n → R) (Fin m → R)\na✝ : Function.Injective ⇑f\n⊢ LE.le n m","decl":"/-- We say that `R` satisfies the strong rank condition if `(Fin n → R) →ₗ[R] (Fin m → R)` injective\n    implies `n ≤ m`. -/\n@[mk_iff]\nclass StrongRankCondition : Prop where\n  /-- Any injective linear map from `Rⁿ` to `Rᵐ` guarantees `n ≤ m`. -/\n  le_of_fin_injective : ∀ {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R), Injective f → n ≤ m\n\n"}
{"name":"strongRankCondition_iff","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (StrongRankCondition R) (∀ {n m : Nat} (f : LinearMap (RingHom.id R) (Fin n → R) (Fin m → R)), Function.Injective ⇑f → LE.le n m)","decl":"/-- We say that `R` satisfies the strong rank condition if `(Fin n → R) →ₗ[R] (Fin m → R)` injective\n    implies `n ≤ m`. -/\n@[mk_iff]\nclass StrongRankCondition : Prop where\n  /-- Any injective linear map from `Rⁿ` to `Rᵐ` guarantees `n ≤ m`. -/\n  le_of_fin_injective : ∀ {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R), Injective f → n ≤ m\n\n"}
{"name":"le_of_fin_injective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\nn m : Nat\nf : LinearMap (RingHom.id R) (Fin n → R) (Fin m → R)\na✝ : Function.Injective ⇑f\n⊢ LE.le n m","decl":"theorem le_of_fin_injective [StrongRankCondition R] {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R) :\n    Injective f → n ≤ m :=\n  StrongRankCondition.le_of_fin_injective f\n\n"}
{"name":"strongRankCondition_iff_succ","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (StrongRankCondition R) (∀ (n : Nat) (f : LinearMap (RingHom.id R) (Fin (HAdd.hAdd n 1) → R) (Fin n → R)), Not (Function.Injective ⇑f))","decl":"/-- A ring satisfies the strong rank condition if and only if, for all `n : ℕ`, any linear map\n`(Fin (n + 1) → R) →ₗ[R] (Fin n → R)` is not injective. -/\ntheorem strongRankCondition_iff_succ :\n    StrongRankCondition R ↔\n      ∀ (n : ℕ) (f : (Fin (n + 1) → R) →ₗ[R] Fin n → R), ¬Function.Injective f := by\n  refine ⟨fun h n => fun f hf => ?_, fun h => ⟨@fun n m f hf => ?_⟩⟩\n  · letI : StrongRankCondition R := h\n    exact Nat.not_succ_le_self n (le_of_fin_injective R f hf)\n  · by_contra H\n    exact\n      h m (f.comp (Function.ExtendByZero.linearMap R (Fin.castLE (not_le.1 H))))\n        (hf.comp (Function.extend_injective (Fin.strictMono_castLE _).injective _))\n\n"}
{"name":"strongRankCondition_of_orzechProperty","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝² : Semiring R\ninst✝¹ : Nontrivial R\ninst✝ : OrzechProperty R\n⊢ StrongRankCondition R","decl":"/-- Any nontrivial ring satisfying Orzech property also satisfies strong rank condition. -/\ninstance (priority := 100) strongRankCondition_of_orzechProperty\n    [Nontrivial R] [OrzechProperty R] : StrongRankCondition R := by\n  refine (strongRankCondition_iff_succ R).2 fun n i hi ↦ ?_\n  let f : (Fin (n + 1) → R) →ₗ[R] Fin n → R := {\n    toFun := fun x ↦ x ∘ Fin.castSucc\n    map_add' := fun _ _ ↦ rfl\n    map_smul' := fun _ _ ↦ rfl\n  }\n  have h : (0 : Fin (n + 1) → R) = update (0 : Fin (n + 1) → R) (Fin.last n) 1 := by\n    apply OrzechProperty.injective_of_surjective_of_injective i f hi\n      (Fin.castSucc_injective _).surjective_comp_right\n    ext m\n    simp [f, update_apply, (Fin.castSucc_lt_last m).ne]\n  simpa using congr_fun h (Fin.last n)\n\n"}
{"name":"card_le_of_injective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : StrongRankCondition R\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : LinearMap (RingHom.id R) (α → R) (β → R)\ni : Function.Injective ⇑f\n⊢ LE.le (Fintype.card α) (Fintype.card β)","decl":"theorem card_le_of_injective [StrongRankCondition R] {α β : Type*} [Fintype α] [Fintype β]\n    (f : (α → R) →ₗ[R] β → R) (i : Injective f) : Fintype.card α ≤ Fintype.card β := by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)\n  exact\n    le_of_fin_injective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).injective.comp i).comp (LinearEquiv.injective P))\n\n"}
{"name":"card_le_of_injective'","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : StrongRankCondition R\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : LinearMap (RingHom.id R) (Finsupp α R) (Finsupp β R)\ni : Function.Injective ⇑f\n⊢ LE.le (Fintype.card α) (Fintype.card β)","decl":"theorem card_le_of_injective' [StrongRankCondition R] {α β : Type*} [Fintype α] [Fintype β]\n    (f : (α →₀ R) →ₗ[R] β →₀ R) (i : Injective f) : Fintype.card α ≤ Fintype.card β := by\n  let P := Finsupp.linearEquivFunOnFinite R R β\n  let Q := (Finsupp.linearEquivFunOnFinite R R α).symm\n  exact\n    card_le_of_injective R ((P.toLinearMap.comp f).comp Q.toLinearMap)\n      ((P.injective.comp i).comp Q.injective)\n\n"}
{"name":"RankCondition.le_of_fin_surjective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : RankCondition R\nn m : Nat\nf : LinearMap (RingHom.id R) (Fin n → R) (Fin m → R)\na✝ : Function.Surjective ⇑f\n⊢ LE.le m n","decl":"/-- We say that `R` satisfies the rank condition if `(Fin n → R) →ₗ[R] (Fin m → R)` surjective\n    implies `m ≤ n`. -/\nclass RankCondition : Prop where\n  /-- Any surjective linear map from `Rⁿ` to `Rᵐ` guarantees `m ≤ n`. -/\n  le_of_fin_surjective : ∀ {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R), Surjective f → m ≤ n\n\n"}
{"name":"le_of_fin_surjective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : RankCondition R\nn m : Nat\nf : LinearMap (RingHom.id R) (Fin n → R) (Fin m → R)\na✝ : Function.Surjective ⇑f\n⊢ LE.le m n","decl":"theorem le_of_fin_surjective [RankCondition R] {n m : ℕ} (f : (Fin n → R) →ₗ[R] Fin m → R) :\n    Surjective f → m ≤ n :=\n  RankCondition.le_of_fin_surjective f\n\n"}
{"name":"card_le_of_surjective","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : RankCondition R\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : LinearMap (RingHom.id R) (α → R) (β → R)\ni : Function.Surjective ⇑f\n⊢ LE.le (Fintype.card β) (Fintype.card α)","decl":"theorem card_le_of_surjective [RankCondition R] {α β : Type*} [Fintype α] [Fintype β]\n    (f : (α → R) →ₗ[R] β → R) (i : Surjective f) : Fintype.card β ≤ Fintype.card α := by\n  let P := LinearEquiv.funCongrLeft R R (Fintype.equivFin α)\n  let Q := LinearEquiv.funCongrLeft R R (Fintype.equivFin β)\n  exact\n    le_of_fin_surjective R ((Q.symm.toLinearMap.comp f).comp P.toLinearMap)\n      (((LinearEquiv.symm Q).surjective.comp i).comp (LinearEquiv.surjective P))\n\n"}
{"name":"card_le_of_surjective'","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : RankCondition R\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : LinearMap (RingHom.id R) (Finsupp α R) (Finsupp β R)\ni : Function.Surjective ⇑f\n⊢ LE.le (Fintype.card β) (Fintype.card α)","decl":"theorem card_le_of_surjective' [RankCondition R] {α β : Type*} [Fintype α] [Fintype β]\n    (f : (α →₀ R) →ₗ[R] β →₀ R) (i : Surjective f) : Fintype.card β ≤ Fintype.card α := by\n  let P := Finsupp.linearEquivFunOnFinite R R β\n  let Q := (Finsupp.linearEquivFunOnFinite R R α).symm\n  exact\n    card_le_of_surjective R ((P.toLinearMap.comp f).comp Q.toLinearMap)\n      ((P.surjective.comp i).comp Q.surjective)\n\n"}
{"name":"rankCondition_of_strongRankCondition","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\n⊢ RankCondition R","decl":"/-- By the universal property for free modules, any surjective map `(Fin n → R) →ₗ[R] (Fin m → R)`\nhas an injective splitting `(Fin m → R) →ₗ[R] (Fin n → R)`\nfrom which the strong rank condition gives the necessary inequality for the rank condition.\n-/\ninstance (priority := 100) rankCondition_of_strongRankCondition [StrongRankCondition R] :\n    RankCondition R where\n  le_of_fin_surjective f s :=\n    le_of_fin_injective R _ (f.splittingOfFunOnFintypeSurjective_injective s)\n\n"}
{"name":"InvariantBasisNumber.eq_of_fin_equiv","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : InvariantBasisNumber R\nn m : Nat\na✝ : LinearEquiv (RingHom.id R) (Fin n → R) (Fin m → R)\n⊢ Eq n m","decl":"/-- We say that `R` has the invariant basis number property if `(Fin n → R) ≃ₗ[R] (Fin m → R)`\n    implies `n = m`. This gives rise to a well-defined notion of rank of a finitely generated free\n    module. -/\nclass InvariantBasisNumber : Prop where\n  /-- Any linear equiv between `Rⁿ` and `Rᵐ` guarantees `m = n`. -/\n  eq_of_fin_equiv : ∀ {n m : ℕ}, ((Fin n → R) ≃ₗ[R] Fin m → R) → n = m\n\n"}
{"name":"invariantBasisNumber_of_rankCondition","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : RankCondition R\n⊢ InvariantBasisNumber R","decl":"instance (priority := 100) invariantBasisNumber_of_rankCondition [RankCondition R] :\n    InvariantBasisNumber R where\n  eq_of_fin_equiv e := le_antisymm (le_of_fin_surjective R e.symm.toLinearMap e.symm.surjective)\n    (le_of_fin_surjective R e.toLinearMap e.surjective)\n\n"}
{"name":"eq_of_fin_equiv","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : InvariantBasisNumber R\nn m : Nat\na✝ : LinearEquiv (RingHom.id R) (Fin n → R) (Fin m → R)\n⊢ Eq n m","decl":"theorem eq_of_fin_equiv {n m : ℕ} : ((Fin n → R) ≃ₗ[R] Fin m → R) → n = m :=\n  InvariantBasisNumber.eq_of_fin_equiv\n\n"}
{"name":"card_eq_of_linearEquiv","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝³ : Semiring R\ninst✝² : InvariantBasisNumber R\nα : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : LinearEquiv (RingHom.id R) (α → R) (β → R)\n⊢ Eq (Fintype.card α) (Fintype.card β)","decl":"theorem card_eq_of_linearEquiv {α β : Type*} [Fintype α] [Fintype β] (f : (α → R) ≃ₗ[R] β → R) :\n    Fintype.card α = Fintype.card β :=\n  eq_of_fin_equiv R\n    ((LinearEquiv.funCongrLeft R R (Fintype.equivFin α)).trans f ≪≫ₗ\n      (LinearEquiv.funCongrLeft R R (Fintype.equivFin β)).symm)\n-- Porting note: this was not well-named because `lequiv` could mean other things\n-- (e.g., `localEquiv`)\n\n"}
{"name":"nontrivial_of_invariantBasisNumber","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : InvariantBasisNumber R\n⊢ Nontrivial R","decl":"theorem nontrivial_of_invariantBasisNumber : Nontrivial R := by\n  by_contra h\n  refine zero_ne_one (eq_of_fin_equiv R ?_)\n  haveI := not_nontrivial_iff_subsingleton.1 h\n  haveI : Subsingleton (Fin 1 → R) :=\n    Subsingleton.intro fun a b => funext fun x => Subsingleton.elim _ _\n  exact\n    { toFun := 0\n      invFun := 0\n      map_add' := by simp\n      map_smul' := by simp\n      left_inv := fun _ => by simp [eq_iff_true_of_subsingleton]\n      right_inv := fun _ => by simp [eq_iff_true_of_subsingleton] }\n\n"}
{"name":"IsNoetherianRing.strongRankCondition","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝² : Ring R\ninst✝¹ : Nontrivial R\ninst✝ : IsNoetherianRing R\n⊢ StrongRankCondition R","decl":"/-- Any nontrivial noetherian ring satisfies the strong rank condition,\n    since it satisfies Orzech property. -/\ninstance (priority := 100) IsNoetherianRing.strongRankCondition : StrongRankCondition R :=\n  inferInstance\n\n"}
{"name":"invariantBasisNumber_of_nontrivial_of_commRing","module":"Mathlib.LinearAlgebra.InvariantBasisNumber","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ InvariantBasisNumber R","decl":"/-- Nontrivial commutative rings have the invariant basis number property.\n\nIn fact, any nontrivial commutative ring satisfies the strong rank condition, see\n`commRing_strongRankCondition`. We prove this instance separately to avoid dependency on\n`LinearAlgebra.Charpoly.Basic`. -/\ninstance (priority := 100) invariantBasisNumber_of_nontrivial_of_commRing {R : Type u} [CommRing R]\n    [Nontrivial R] : InvariantBasisNumber R :=\n  ⟨fun e =>\n    let ⟨I, _hI⟩ := Ideal.exists_maximal R\n    eq_of_fin_equiv (R ⧸ I)\n      ((Ideal.piQuotEquiv _ _).symm ≪≫ₗ induced_equiv _ e ≪≫ₗ Ideal.piQuotEquiv _ _)⟩\n\n"}
