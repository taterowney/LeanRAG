{"name":"IsDiscreteValuationRing.toIsPrincipalIdealRing","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nself : IsDiscreteValuationRing R\n⊢ IsPrincipalIdealRing R","decl":"/-- An integral domain is a *discrete valuation ring* (DVR) if it's a local PID which\n  is not a field. -/\nclass IsDiscreteValuationRing (R : Type u) [CommRing R] [IsDomain R]\n    extends IsPrincipalIdealRing R, IsLocalRing R : Prop where\n  not_a_field' : maximalIdeal R ≠ ⊥\n\n"}
{"name":"IsDiscreteValuationRing.toIsLocalRing","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nself : IsDiscreteValuationRing R\n⊢ IsLocalRing R","decl":"/-- An integral domain is a *discrete valuation ring* (DVR) if it's a local PID which\n  is not a field. -/\nclass IsDiscreteValuationRing (R : Type u) [CommRing R] [IsDomain R]\n    extends IsPrincipalIdealRing R, IsLocalRing R : Prop where\n  not_a_field' : maximalIdeal R ≠ ⊥\n\n"}
{"name":"IsDiscreteValuationRing.not_a_field'","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nself : IsDiscreteValuationRing R\n⊢ Ne (IsLocalRing.maximalIdeal R) Bot.bot","decl":"/-- An integral domain is a *discrete valuation ring* (DVR) if it's a local PID which\n  is not a field. -/\nclass IsDiscreteValuationRing (R : Type u) [CommRing R] [IsDomain R]\n    extends IsPrincipalIdealRing R, IsLocalRing R : Prop where\n  not_a_field' : maximalIdeal R ≠ ⊥\n\n"}
{"name":"IsDiscreteValuationRing.not_a_field","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Ne (IsLocalRing.maximalIdeal R) Bot.bot","decl":"theorem not_a_field : maximalIdeal R ≠ ⊥ :=\n  not_a_field'\n\n"}
{"name":"IsDiscreteValuationRing.not_isField","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Not (IsField R)","decl":"/-- A discrete valuation ring `R` is not a field. -/\ntheorem not_isField : ¬IsField R :=\n  IsLocalRing.isField_iff_maximalIdeal_eq.not.mpr (not_a_field R)\n\n"}
{"name":"IsDiscreteValuationRing.irreducible_of_span_eq_maximalIdeal","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsDomain R\nϖ : R\nhϖ : Ne ϖ 0\nh : Eq (IsLocalRing.maximalIdeal R) (Ideal.span (Singleton.singleton ϖ))\n⊢ Irreducible ϖ","decl":"theorem irreducible_of_span_eq_maximalIdeal {R : Type*} [CommRing R] [IsLocalRing R] [IsDomain R]\n    (ϖ : R) (hϖ : ϖ ≠ 0) (h : maximalIdeal R = Ideal.span {ϖ}) : Irreducible ϖ := by\n  have h2 : ¬IsUnit ϖ := show ϖ ∈ maximalIdeal R from h.symm ▸ Submodule.mem_span_singleton_self ϖ\n  refine ⟨h2, ?_⟩\n  intro a b hab\n  by_contra! h\n  obtain ⟨ha : a ∈ maximalIdeal R, hb : b ∈ maximalIdeal R⟩ := h\n  rw [h, mem_span_singleton'] at ha hb\n  rcases ha with ⟨a, rfl⟩\n  rcases hb with ⟨b, rfl⟩\n  rw [show a * ϖ * (b * ϖ) = ϖ * (ϖ * (a * b)) by ring] at hab\n  apply hϖ\n  apply eq_zero_of_mul_eq_self_right _ hab.symm\n  exact fun hh => h2 (isUnit_of_dvd_one ⟨_, hh.symm⟩)\n\n"}
{"name":"IsDiscreteValuationRing.irreducible_iff_uniformizer","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nϖ : R\n⊢ Iff (Irreducible ϖ) (Eq (IsLocalRing.maximalIdeal R) (Ideal.span (Singleton.singleton ϖ)))","decl":"/-- An element of a DVR is irreducible iff it is a uniformizer, that is, generates the\n  maximal ideal of `R`. -/\ntheorem irreducible_iff_uniformizer (ϖ : R) : Irreducible ϖ ↔ maximalIdeal R = Ideal.span {ϖ} :=\n  ⟨fun hϖ => (eq_maximalIdeal (isMaximal_of_irreducible hϖ)).symm,\n    fun h => irreducible_of_span_eq_maximalIdeal ϖ\n      (fun e => not_a_field R <| by rwa [h, span_singleton_eq_bot]) h⟩\n\n"}
{"name":"Irreducible.maximalIdeal_eq","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nϖ : R\nh : Irreducible ϖ\n⊢ Eq (IsLocalRing.maximalIdeal R) (Ideal.span (Singleton.singleton ϖ))","decl":"theorem _root_.Irreducible.maximalIdeal_eq {ϖ : R} (h : Irreducible ϖ) :\n    maximalIdeal R = Ideal.span {ϖ} :=\n  (irreducible_iff_uniformizer _).mp h\n\n"}
{"name":"IsDiscreteValuationRing.exists_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Exists fun ϖ => Irreducible ϖ","decl":"/-- Uniformizers exist in a DVR. -/\ntheorem exists_irreducible : ∃ ϖ : R, Irreducible ϖ := by\n  simp_rw [irreducible_iff_uniformizer]\n  exact (IsPrincipalIdealRing.principal <| maximalIdeal R).principal\n\n"}
{"name":"IsDiscreteValuationRing.exists_prime","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Exists fun ϖ => Prime ϖ","decl":"/-- Uniformizers exist in a DVR. -/\ntheorem exists_prime : ∃ ϖ : R, Prime ϖ :=\n  (exists_irreducible R).imp fun _ => irreducible_iff_prime.1\n\n"}
{"name":"IsDiscreteValuationRing.iff_pid_with_one_nonzero_prime","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ Iff (IsDiscreteValuationRing R) (And (IsPrincipalIdealRing R) (ExistsUnique fun P => And (Ne P Bot.bot) P.IsPrime))","decl":"/-- An integral domain is a DVR iff it's a PID with a unique non-zero prime ideal. -/\ntheorem iff_pid_with_one_nonzero_prime (R : Type u) [CommRing R] [IsDomain R] :\n    IsDiscreteValuationRing R ↔ IsPrincipalIdealRing R ∧ ∃! P : Ideal R, P ≠ ⊥ ∧ IsPrime P := by\n  constructor\n  · intro RDVR\n    rcases id RDVR with ⟨Rlocal⟩\n    constructor\n    · assumption\n    use IsLocalRing.maximalIdeal R\n    constructor\n    · exact ⟨Rlocal, inferInstance⟩\n    · rintro Q ⟨hQ1, hQ2⟩\n      obtain ⟨q, rfl⟩ := (IsPrincipalIdealRing.principal Q).1\n      have hq : q ≠ 0 := by\n        rintro rfl\n        apply hQ1\n        simp\n      erw [span_singleton_prime hq] at hQ2\n      replace hQ2 := hQ2.irreducible\n      rw [irreducible_iff_uniformizer] at hQ2\n      exact hQ2.symm\n  · rintro ⟨RPID, Punique⟩\n    haveI : IsLocalRing R := IsLocalRing.of_unique_nonzero_prime Punique\n    refine { not_a_field' := ?_ }\n    rcases Punique with ⟨P, ⟨hP1, hP2⟩, _⟩\n    have hPM : P ≤ maximalIdeal R := le_maximalIdeal hP2.1\n    intro h\n    rw [h, le_bot_iff] at hPM\n    exact hP1 hPM\n\n"}
{"name":"IsDiscreteValuationRing.associated_of_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na b : R\nha : Irreducible a\nhb : Irreducible b\n⊢ Associated a b","decl":"theorem associated_of_irreducible {a b : R} (ha : Irreducible a) (hb : Irreducible b) :\n    Associated a b := by\n  rw [irreducible_iff_uniformizer] at ha hb\n  rw [← span_singleton_eq_span_singleton, ← ha, hb]\n\n"}
{"name":"IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization.unique_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nhR : IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R\np q : R\nhp : Irreducible p\nhq : Irreducible q\n⊢ Associated p q","decl":"theorem unique_irreducible (hR : HasUnitMulPowIrreducibleFactorization R)\n    ⦃p q : R⦄ (hp : Irreducible p) (hq : Irreducible q) :\n    Associated p q := by\n  rcases hR with ⟨ϖ, hϖ, hR⟩\n  suffices ∀ {p : R} (_ : Irreducible p), Associated p ϖ by\n    apply Associated.trans (this hp) (this hq).symm\n  clear hp hq p q\n  intro p hp\n  obtain ⟨n, hn⟩ := hR hp.ne_zero\n  have : Irreducible (ϖ ^ n) := hn.symm.irreducible hp\n  rcases lt_trichotomy n 1 with (H | rfl | H)\n  · obtain rfl : n = 0 := by\n      clear hn this\n      revert H n\n      decide\n    simp [not_irreducible_one, pow_zero] at this\n  · simpa only [pow_one] using hn.symm\n  · obtain ⟨n, rfl⟩ : ∃ k, n = 1 + k + 1 := Nat.exists_eq_add_of_lt H\n    rw [pow_succ'] at this\n    rcases this.isUnit_or_isUnit rfl with (H0 | H0)\n    · exact (hϖ.not_unit H0).elim\n    · rw [add_comm, pow_succ'] at H0\n      exact (hϖ.not_unit (isUnit_of_mul_isUnit_left H0)).elim\n\n"}
{"name":"IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization.toUniqueFactorizationMonoid","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nhR : IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R\n⊢ UniqueFactorizationMonoid R","decl":"/-- An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p` is a unique factorization domain.\nSee `IsDiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization`. -/\ntheorem toUniqueFactorizationMonoid (hR : HasUnitMulPowIrreducibleFactorization R) :\n    UniqueFactorizationMonoid R :=\n  let p := Classical.choose hR\n  let spec := Classical.choose_spec hR\n  UniqueFactorizationMonoid.of_exists_prime_factors fun x hx => by\n    use Multiset.replicate (Classical.choose (spec.2 hx)) p\n    constructor\n    · intro q hq\n      have hpq := Multiset.eq_of_mem_replicate hq\n      rw [hpq]\n      refine ⟨spec.1.ne_zero, spec.1.not_unit, ?_⟩\n      intro a b h\n      by_cases ha : a = 0\n      · rw [ha]\n        simp only [true_or, dvd_zero]\n      obtain ⟨m, u, rfl⟩ := spec.2 ha\n      rw [mul_assoc, mul_left_comm, Units.dvd_mul_left] at h\n      rw [Units.dvd_mul_right]\n      by_cases hm : m = 0\n      · simp only [hm, one_mul, pow_zero] at h ⊢\n        right\n        exact h\n      left\n      obtain ⟨m, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hm\n      rw [pow_succ']\n      apply dvd_mul_of_dvd_left dvd_rfl _\n    · rw [Multiset.prod_replicate]\n      exact Classical.choose_spec (spec.2 hx)\n\n"}
{"name":"IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization.of_ufd_of_unique_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : UniqueFactorizationMonoid R\nh₁ : Exists fun p => Irreducible p\nh₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q\n⊢ IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R","decl":"theorem of_ufd_of_unique_irreducible [UniqueFactorizationMonoid R] (h₁ : ∃ p : R, Irreducible p)\n    (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) :\n    HasUnitMulPowIrreducibleFactorization R := by\n  obtain ⟨p, hp⟩ := h₁\n  refine ⟨p, hp, ?_⟩\n  intro x hx\n  cases' WfDvdMonoid.exists_factors x hx with fx hfx\n  refine ⟨Multiset.card fx, ?_⟩\n  have H := hfx.2\n  rw [← Associates.mk_eq_mk_iff_associated] at H ⊢\n  rw [← H, ← Associates.prod_mk, Associates.mk_pow, ← Multiset.prod_replicate]\n  congr 1\n  symm\n  rw [Multiset.eq_replicate]\n  simp only [true_and, and_imp, Multiset.card_map, eq_self_iff_true, Multiset.mem_map, exists_imp]\n  rintro _ q hq rfl\n  rw [Associates.mk_eq_mk_iff_associated]\n  apply h₂ (hfx.1 _ hq) hp\n\n"}
{"name":"IsDiscreteValuationRing.aux_pid_of_ufd_of_unique_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : UniqueFactorizationMonoid R\nh₁ : Exists fun p => Irreducible p\nh₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q\n⊢ IsPrincipalIdealRing R","decl":"theorem aux_pid_of_ufd_of_unique_irreducible (R : Type u) [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] (h₁ : ∃ p : R, Irreducible p)\n    (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) :\n    IsPrincipalIdealRing R := by\n  classical\n  constructor\n  intro I\n  by_cases I0 : I = ⊥\n  · rw [I0]\n    use 0\n    simp only [Set.singleton_zero, Submodule.span_zero]\n  obtain ⟨x, hxI, hx0⟩ : ∃ x ∈ I, x ≠ (0 : R) := I.ne_bot_iff.mp I0\n  obtain ⟨p, _, H⟩ := HasUnitMulPowIrreducibleFactorization.of_ufd_of_unique_irreducible h₁ h₂\n  have ex : ∃ n : ℕ, p ^ n ∈ I := by\n    obtain ⟨n, u, rfl⟩ := H hx0\n    refine ⟨n, ?_⟩\n    simpa only [Units.mul_inv_cancel_right] using I.mul_mem_right (↑u⁻¹) hxI\n  constructor\n  use p ^ Nat.find ex\n  show I = Ideal.span _\n  apply le_antisymm\n  · intro r hr\n    by_cases hr0 : r = 0\n    · simp only [hr0, Submodule.zero_mem]\n    obtain ⟨n, u, rfl⟩ := H hr0\n    simp only [mem_span_singleton, Units.isUnit, IsUnit.dvd_mul_right]\n    apply pow_dvd_pow\n    apply Nat.find_min'\n    simpa only [Units.mul_inv_cancel_right] using I.mul_mem_right (↑u⁻¹) hr\n  · erw [Submodule.span_singleton_le_iff_mem]\n    exact Nat.find_spec ex\n\n"}
{"name":"IsDiscreteValuationRing.of_ufd_of_unique_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : UniqueFactorizationMonoid R\nh₁ : Exists fun p => Irreducible p\nh₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q\n⊢ IsDiscreteValuationRing R","decl":"/-- A unique factorization domain with at least one irreducible element\nin which all irreducible elements are associated\nis a discrete valuation ring.\n-/\ntheorem of_ufd_of_unique_irreducible {R : Type u} [CommRing R] [IsDomain R]\n    [UniqueFactorizationMonoid R] (h₁ : ∃ p : R, Irreducible p)\n    (h₂ : ∀ ⦃p q : R⦄, Irreducible p → Irreducible q → Associated p q) :\n    IsDiscreteValuationRing R := by\n  rw [iff_pid_with_one_nonzero_prime]\n  haveI PID : IsPrincipalIdealRing R := aux_pid_of_ufd_of_unique_irreducible R h₁ h₂\n  obtain ⟨p, hp⟩ := h₁\n  refine ⟨PID, ⟨Ideal.span {p}, ⟨?_, ?_⟩, ?_⟩⟩\n  · rw [Submodule.ne_bot_iff]\n    exact ⟨p, Ideal.mem_span_singleton.mpr (dvd_refl p), hp.ne_zero⟩\n  · rwa [Ideal.span_singleton_prime hp.ne_zero, ← UniqueFactorizationMonoid.irreducible_iff_prime]\n  · intro I\n    rw [← Submodule.IsPrincipal.span_singleton_generator I]\n    rintro ⟨I0, hI⟩\n    apply span_singleton_eq_span_singleton.mpr\n    apply h₂ _ hp\n    erw [Ne, span_singleton_eq_bot] at I0\n    rwa [UniqueFactorizationMonoid.irreducible_iff_prime, ← Ideal.span_singleton_prime I0]\n\n"}
{"name":"IsDiscreteValuationRing.ofHasUnitMulPowIrreducibleFactorization","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nhR : IsDiscreteValuationRing.HasUnitMulPowIrreducibleFactorization R\n⊢ IsDiscreteValuationRing R","decl":"/-- An integral domain in which there is an irreducible element `p`\nsuch that every nonzero element is associated to a power of `p`\nis a discrete valuation ring.\n-/\ntheorem ofHasUnitMulPowIrreducibleFactorization {R : Type u} [CommRing R] [IsDomain R]\n    (hR : HasUnitMulPowIrreducibleFactorization R) : IsDiscreteValuationRing R := by\n  letI : UniqueFactorizationMonoid R := hR.toUniqueFactorizationMonoid\n  apply of_ufd_of_unique_irreducible _ hR.unique_irreducible\n  obtain ⟨p, hp, H⟩ := hR\n  exact ⟨p, hp⟩\n\n/- If a ring is equivalent to a DVR, it is itself a DVR. -/\n"}
{"name":"IsDiscreteValuationRing.RingEquivClass.isDiscreteValuationRing","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"A : Type u_2\nB : Type u_3\nE : Type u_4\ninst✝⁶ : CommRing A\ninst✝⁵ : IsDomain A\ninst✝⁴ : CommRing B\ninst✝³ : IsDomain B\ninst✝² : IsDiscreteValuationRing A\ninst✝¹ : EquivLike E A B\ninst✝ : RingEquivClass E A B\ne : E\n⊢ IsDiscreteValuationRing B","decl":"theorem RingEquivClass.isDiscreteValuationRing {A B E : Type*} [CommRing A] [IsDomain A]\n    [CommRing B] [IsDomain B] [IsDiscreteValuationRing A] [EquivLike E A B] [RingEquivClass E A B]\n    (e : E) : IsDiscreteValuationRing B where\n  principal := (isPrincipalIdealRing_iff _).1 <|\n    IsPrincipalIdealRing.of_surjective _ (e : A ≃+* B).surjective\n  __ : IsLocalRing B := (e : A ≃+* B).isLocalRing\n  not_a_field' := by\n    obtain ⟨a, ha⟩ := Submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr\n      <| IsDiscreteValuationRing.not_a_field A)\n    rw [Submodule.ne_bot_iff]\n    refine ⟨e a, ⟨?_, by simp only [ne_eq, EmbeddingLike.map_eq_zero_iff, ZeroMemClass.coe_eq_zero,\n      ha, not_false_eq_true]⟩⟩\n    rw [IsLocalRing.mem_maximalIdeal, map_mem_nonunits_iff e, ← IsLocalRing.mem_maximalIdeal]\n    exact a.2\n\n"}
{"name":"IsDiscreteValuationRing.associated_pow_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nx : R\nhx : Ne x 0\nϖ : R\nhirr : Irreducible ϖ\n⊢ Exists fun n => Associated x (HPow.hPow ϖ n)","decl":"theorem associated_pow_irreducible {x : R} (hx : x ≠ 0) {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ n : ℕ, Associated x (ϖ ^ n) := by\n  have : WfDvdMonoid R := IsNoetherianRing.wfDvdMonoid\n  cases' WfDvdMonoid.exists_factors x hx with fx hfx\n  use Multiset.card fx\n  have H := hfx.2\n  rw [← Associates.mk_eq_mk_iff_associated] at H ⊢\n  rw [← H, ← Associates.prod_mk, Associates.mk_pow, ← Multiset.prod_replicate]\n  congr 1\n  rw [Multiset.eq_replicate]\n  simp only [true_and, and_imp, Multiset.card_map, eq_self_iff_true, Multiset.mem_map, exists_imp]\n  rintro _ _ _ rfl\n  rw [Associates.mk_eq_mk_iff_associated]\n  refine associated_of_irreducible _ ?_ hirr\n  apply hfx.1\n  assumption\n\n"}
{"name":"IsDiscreteValuationRing.eq_unit_mul_pow_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nx : R\nhx : Ne x 0\nϖ : R\nhirr : Irreducible ϖ\n⊢ Exists fun n => Exists fun u => Eq x (HMul.hMul (↑u) (HPow.hPow ϖ n))","decl":"theorem eq_unit_mul_pow_irreducible {x : R} (hx : x ≠ 0) {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ (n : ℕ) (u : Rˣ), x = u * ϖ ^ n := by\n  obtain ⟨n, hn⟩ := associated_pow_irreducible hx hirr\n  obtain ⟨u, rfl⟩ := hn.symm\n  use n, u\n  apply mul_comm\n\n"}
{"name":"IsDiscreteValuationRing.ideal_eq_span_pow_irreducible","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\ns : Ideal R\nhs : Ne s Bot.bot\nϖ : R\nhirr : Irreducible ϖ\n⊢ Exists fun n => Eq s (Ideal.span (Singleton.singleton (HPow.hPow ϖ n)))","decl":"theorem ideal_eq_span_pow_irreducible {s : Ideal R} (hs : s ≠ ⊥) {ϖ : R} (hirr : Irreducible ϖ) :\n    ∃ n : ℕ, s = Ideal.span {ϖ ^ n} := by\n  have gen_ne_zero : generator s ≠ 0 := by\n    rw [Ne, ← eq_bot_iff_generator_eq_zero]\n    assumption\n  rcases associated_pow_irreducible gen_ne_zero hirr with ⟨n, u, hnu⟩\n  use n\n  have : span _ = _ := Ideal.span_singleton_generator s\n  rw [← this, ← hnu, span_singleton_eq_span_singleton]\n  use u\n\n"}
{"name":"IsDiscreteValuationRing.unit_mul_pow_congr_pow","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\np q : R\nhp : Irreducible p\nhq : Irreducible q\nu v : Units R\nm n : Nat\nh : Eq (HMul.hMul (↑u) (HPow.hPow p m)) (HMul.hMul (↑v) (HPow.hPow q n))\n⊢ Eq m n","decl":"theorem unit_mul_pow_congr_pow {p q : R} (hp : Irreducible p) (hq : Irreducible q) (u v : Rˣ)\n    (m n : ℕ) (h : ↑u * p ^ m = v * q ^ n) : m = n := by\n  have key : Associated (Multiset.replicate m p).prod (Multiset.replicate n q).prod := by\n    rw [Multiset.prod_replicate, Multiset.prod_replicate, Associated]\n    refine ⟨u * v⁻¹, ?_⟩\n    simp only [Units.val_mul]\n    rw [mul_left_comm, ← mul_assoc, h, mul_right_comm, Units.mul_inv, one_mul]\n  have := by\n    refine Multiset.card_eq_card_of_rel (UniqueFactorizationMonoid.factors_unique ?_ ?_ key)\n    all_goals\n      intro x hx\n      obtain rfl := Multiset.eq_of_mem_replicate hx\n      assumption\n  simpa only [Multiset.card_replicate]\n\n"}
{"name":"IsDiscreteValuationRing.unit_mul_pow_congr_unit","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nϖ : R\nhirr : Irreducible ϖ\nu v : Units R\nm n : Nat\nh : Eq (HMul.hMul (↑u) (HPow.hPow ϖ m)) (HMul.hMul (↑v) (HPow.hPow ϖ n))\n⊢ Eq u v","decl":"theorem unit_mul_pow_congr_unit {ϖ : R} (hirr : Irreducible ϖ) (u v : Rˣ) (m n : ℕ)\n    (h : ↑u * ϖ ^ m = v * ϖ ^ n) : u = v := by\n  obtain rfl : m = n := unit_mul_pow_congr_pow hirr hirr u v m n h\n  rw [← sub_eq_zero] at h\n  rw [← sub_mul, mul_eq_zero] at h\n  cases' h with h h\n  · rw [sub_eq_zero] at h\n    exact mod_cast h\n  · apply (hirr.ne_zero (pow_eq_zero h)).elim\n\n"}
{"name":"IsDiscreteValuationRing.addVal_def","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nr : R\nu : Units R\nϖ : R\nhϖ : Irreducible ϖ\nn : Nat\nhr : Eq r (HMul.hMul (↑u) (HPow.hPow ϖ n))\n⊢ Eq ((IsDiscreteValuationRing.addVal R) r) ↑n","decl":"theorem addVal_def (r : R) (u : Rˣ) {ϖ : R} (hϖ : Irreducible ϖ) (n : ℕ) (hr : r = u * ϖ ^ n) :\n    addVal R r = n := by\n  classical\n  rw [addVal, multiplicity_addValuation_apply, hr, emultiplicity_eq_of_associated_left\n      (associated_of_irreducible R hϖ (Classical.choose_spec (exists_prime R)).irreducible),\n    emultiplicity_eq_of_associated_right (Associated.symm ⟨u, mul_comm _ _⟩),\n    emultiplicity_pow_self_of_prime (irreducible_iff_prime.1 hϖ)]\n\n"}
{"name":"IsDiscreteValuationRing.addVal_def'","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nu : Units R\nϖ : R\nhϖ : Irreducible ϖ\nn : Nat\n⊢ Eq ((IsDiscreteValuationRing.addVal R) (HMul.hMul (↑u) (HPow.hPow ϖ n))) ↑n","decl":"/-- An alternative definition of the additive valuation, taking units into account.-/\ntheorem addVal_def' (u : Rˣ) {ϖ : R} (hϖ : Irreducible ϖ) (n : ℕ) :\n    addVal R ((u : R) * ϖ ^ n) = n :=\n  addVal_def _ u hϖ n rfl\n\n"}
{"name":"IsDiscreteValuationRing.addVal_zero","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Eq ((IsDiscreteValuationRing.addVal R) 0) Top.top","decl":"theorem addVal_zero : addVal R 0 = ⊤ :=\n  (addVal R).map_zero\n\n"}
{"name":"IsDiscreteValuationRing.addVal_one","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ Eq ((IsDiscreteValuationRing.addVal R) 1) 0","decl":"theorem addVal_one : addVal R 1 = 0 :=\n  (addVal R).map_one\n\n"}
{"name":"IsDiscreteValuationRing.addVal_uniformizer","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nϖ : R\nhϖ : Irreducible ϖ\n⊢ Eq ((IsDiscreteValuationRing.addVal R) ϖ) 1","decl":"@[simp]\ntheorem addVal_uniformizer {ϖ : R} (hϖ : Irreducible ϖ) : addVal R ϖ = 1 := by\n  simpa only [one_mul, eq_self_iff_true, Units.val_one, pow_one, forall_true_left, Nat.cast_one]\n    using addVal_def ϖ 1 hϖ 1\n\n"}
{"name":"IsDiscreteValuationRing.addVal_mul","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na b : R\n⊢ Eq ((IsDiscreteValuationRing.addVal R) (HMul.hMul a b)) (HAdd.hAdd ((IsDiscreteValuationRing.addVal R) a) ((IsDiscreteValuationRing.addVal R) b))","decl":"theorem addVal_mul {a b : R} :\n    addVal R (a * b) = addVal R a + addVal R b :=\n  (addVal R).map_mul _ _\n\n"}
{"name":"IsDiscreteValuationRing.addVal_pow","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na : R\nn : Nat\n⊢ Eq ((IsDiscreteValuationRing.addVal R) (HPow.hPow a n)) (HSMul.hSMul n ((IsDiscreteValuationRing.addVal R) a))","decl":"theorem addVal_pow (a : R) (n : ℕ) : addVal R (a ^ n) = n • addVal R a :=\n  (addVal R).map_pow _ _\n\n"}
{"name":"Irreducible.addVal_pow","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\nϖ : R\nh : Irreducible ϖ\nn : Nat\n⊢ Eq ((IsDiscreteValuationRing.addVal R) (HPow.hPow ϖ n)) ↑n","decl":"nonrec theorem _root_.Irreducible.addVal_pow {ϖ : R} (h : Irreducible ϖ) (n : ℕ) :\n    addVal R (ϖ ^ n) = n := by\n  rw [addVal_pow, addVal_uniformizer h, nsmul_one]\n\n"}
{"name":"IsDiscreteValuationRing.addVal_eq_top_iff","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na : R\n⊢ Iff (Eq ((IsDiscreteValuationRing.addVal R) a) Top.top) (Eq a 0)","decl":"theorem addVal_eq_top_iff {a : R} : addVal R a = ⊤ ↔ a = 0 := by\n  have hi := (Classical.choose_spec (exists_prime R)).irreducible\n  constructor\n  · contrapose\n    intro h\n    obtain ⟨n, ha⟩ := associated_pow_irreducible h hi\n    obtain ⟨u, rfl⟩ := ha.symm\n    rw [mul_comm, addVal_def' u hi n]\n    nofun\n  · rintro rfl\n    exact addVal_zero\n\n"}
{"name":"IsDiscreteValuationRing.addVal_le_iff_dvd","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na b : R\n⊢ Iff (LE.le ((IsDiscreteValuationRing.addVal R) a) ((IsDiscreteValuationRing.addVal R) b)) (Dvd.dvd a b)","decl":"theorem addVal_le_iff_dvd {a b : R} : addVal R a ≤ addVal R b ↔ a ∣ b := by\n  classical\n  have hp := Classical.choose_spec (exists_prime R)\n  constructor <;> intro h\n  · by_cases ha0 : a = 0\n    · rw [ha0, addVal_zero, top_le_iff, addVal_eq_top_iff] at h\n      rw [h]\n      apply dvd_zero\n    obtain ⟨n, ha⟩ := associated_pow_irreducible ha0 hp.irreducible\n    rw [addVal, multiplicity_addValuation_apply, multiplicity_addValuation_apply,\n      emultiplicity_le_emultiplicity_iff] at h\n    exact ha.dvd.trans (h n ha.symm.dvd)\n  · rw [addVal, multiplicity_addValuation_apply, multiplicity_addValuation_apply]\n    exact emultiplicity_le_emultiplicity_of_dvd_right h\n\n"}
{"name":"IsDiscreteValuationRing.addVal_add","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\na b : R\n⊢ LE.le (Min.min ((IsDiscreteValuationRing.addVal R) a) ((IsDiscreteValuationRing.addVal R) b)) ((IsDiscreteValuationRing.addVal R) (HAdd.hAdd a b))","decl":"theorem addVal_add {a b : R} : min (addVal R a) (addVal R b) ≤ addVal R (a + b) :=\n  (addVal R).map_add _ _\n\n"}
{"name":"IsDiscreteValuationRing.instIsHausdorffMaximalIdeal","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"R : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsDiscreteValuationRing R\n⊢ IsHausdorff (IsLocalRing.maximalIdeal R) R","decl":"instance (R : Type*) [CommRing R] [IsDomain R] [IsDiscreteValuationRing R] :\n    IsHausdorff (maximalIdeal R) R where\n  haus' x hx := by\n    obtain ⟨ϖ, hϖ⟩ := exists_irreducible R\n    simp only [← Ideal.one_eq_top, smul_eq_mul, mul_one, SModEq.zero, hϖ.maximalIdeal_eq,\n      Ideal.span_singleton_pow, Ideal.mem_span_singleton, ← addVal_le_iff_dvd, hϖ.addVal_pow] at hx\n    rwa [← addVal_eq_top_iff, ← WithTop.forall_ge_iff_eq_top]\n\n"}
{"name":"of_isDiscreteValuationRing","module":"Mathlib.RingTheory.DiscreteValuationRing.Basic","initialProofState":"A : Type u\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : IsDiscreteValuationRing A\n⊢ ValuationRing A","decl":"/-- A DVR is a valuation ring. -/\ninstance (priority := 100) of_isDiscreteValuationRing : ValuationRing A := inferInstance\n\n"}
