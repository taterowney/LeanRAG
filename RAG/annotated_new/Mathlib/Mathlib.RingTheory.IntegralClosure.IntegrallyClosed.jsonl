{"name":"AlgHom.isIntegrallyClosedIn","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Injective ⇑f\na✝ : IsIntegrallyClosedIn R B\n⊢ IsIntegrallyClosedIn R A","decl":"/-- Being integrally closed is preserved under injective algebra homomorphisms. -/\ntheorem AlgHom.isIntegrallyClosedIn (f : A →ₐ[R] B) (hf : Function.Injective f) :\n    IsIntegrallyClosedIn R B → IsIntegrallyClosedIn R A := by\n  rintro ⟨inj, cl⟩\n  refine ⟨Function.Injective.of_comp (f := f) ?_, fun hx => ?_, ?_⟩\n  · convert inj\n    aesop\n  · obtain ⟨y, fx_eq⟩ := cl.mp ((isIntegral_algHom_iff f hf).mpr hx)\n    aesop\n  · rintro ⟨y, rfl⟩\n    apply (isIntegral_algHom_iff f hf).mp\n    aesop\n\n"}
{"name":"AlgEquiv.isIntegrallyClosedIn","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nA : Type u_2\nB : Type u_3\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\ne : AlgEquiv R A B\n⊢ Iff (IsIntegrallyClosedIn R A) (IsIntegrallyClosedIn R B)","decl":"/-- Being integrally closed is preserved under algebra isomorphisms. -/\ntheorem AlgEquiv.isIntegrallyClosedIn (e : A ≃ₐ[R] B) :\n    IsIntegrallyClosedIn R A ↔ IsIntegrallyClosedIn R B :=\n  ⟨AlgHom.isIntegrallyClosedIn e.symm e.symm.injective, AlgHom.isIntegrallyClosedIn e e.injective⟩\n\n"}
{"name":"isIntegrallyClosed_iff_isIntegrallyClosedIn","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_4\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Iff (IsIntegrallyClosed R) (IsIntegrallyClosedIn R K)","decl":"/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem isIntegrallyClosed_iff_isIntegrallyClosedIn :\n    IsIntegrallyClosed R ↔ IsIntegrallyClosedIn R K :=\n  (IsLocalization.algEquiv R⁰ _ _).isIntegrallyClosedIn\n\n"}
{"name":"isIntegrallyClosed_iff_isIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_4\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Iff (IsIntegrallyClosed R) (IsIntegralClosure R R K)","decl":"/-- `R` is integrally closed iff it is the integral closure of itself in its field of fractions. -/\ntheorem isIntegrallyClosed_iff_isIntegralClosure : IsIntegrallyClosed R ↔ IsIntegralClosure R R K :=\n  isIntegrallyClosed_iff_isIntegrallyClosedIn K\n\n"}
{"name":"isIntegrallyClosedIn_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_5\nA : Type u_6\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (IsIntegrallyClosedIn R A) (And (Function.Injective ⇑(algebraMap R A)) (∀ {x : A}, IsIntegral R x → Exists fun y => Eq ((algebraMap R A) y) x))","decl":"/-- `R` is integrally closed in `A` iff all integral elements of `A` are also elements of `R`. -/\ntheorem isIntegrallyClosedIn_iff {R A : Type*} [CommRing R] [CommRing A] [Algebra R A] :\n    IsIntegrallyClosedIn R A ↔\n      Function.Injective (algebraMap R A) ∧\n        ∀ {x : A}, IsIntegral R x → ∃ y, algebraMap R A y = x := by\n  constructor\n  · rintro ⟨_, cl⟩\n    aesop\n  · rintro ⟨inj, cl⟩\n    refine ⟨inj, by aesop, ?_⟩\n    rintro ⟨y, rfl⟩\n    apply isIntegral_algebraMap\n\n"}
{"name":"isIntegrallyClosed_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_4\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\ninst✝ : IsFractionRing R K\n⊢ Iff (IsIntegrallyClosed R) (∀ {x : K}, IsIntegral R x → Exists fun y => Eq ((algebraMap R K) y) x)","decl":"/-- `R` is integrally closed iff all integral elements of its fraction field `K`\nare also elements of `R`. -/\ntheorem isIntegrallyClosed_iff :\n    IsIntegrallyClosed R ↔ ∀ {x : K}, IsIntegral R x → ∃ y, algebraMap R K y = x := by\n  simp [isIntegrallyClosed_iff_isIntegrallyClosedIn K, isIntegrallyClosedIn_iff,\n        IsFractionRing.injective R K]\n\n"}
{"name":"IsIntegrallyClosedIn.algebraMap_eq_of_integral","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsIntegrallyClosedIn R A\nx : A\na✝ : IsIntegral R x\n⊢ Exists fun y => Eq ((algebraMap R A) y) x","decl":"theorem algebraMap_eq_of_integral [IsIntegrallyClosedIn R A] {x : A} :\n    IsIntegral R x → ∃ y : R, algebraMap R A y = x :=\n  IsIntegralClosure.isIntegral_iff.mp\n\n"}
{"name":"IsIntegrallyClosedIn.isIntegral_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsIntegrallyClosedIn R A\nx : A\n⊢ Iff (IsIntegral R x) (Exists fun y => Eq ((algebraMap R A) y) x)","decl":"theorem isIntegral_iff [IsIntegrallyClosedIn R A] {x : A} :\n    IsIntegral R x ↔ ∃ y : R, algebraMap R A y = x :=\n  IsIntegralClosure.isIntegral_iff\n\n"}
{"name":"IsIntegrallyClosedIn.exists_algebraMap_eq_of_isIntegral_pow","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : IsIntegrallyClosedIn R A\nx : A\nn : Nat\nhn : LT.lt 0 n\nhx : IsIntegral R (HPow.hPow x n)\n⊢ Exists fun y => Eq ((algebraMap R A) y) x","decl":"theorem exists_algebraMap_eq_of_isIntegral_pow [IsIntegrallyClosedIn R A]\n    {x : A} {n : ℕ} (hn : 0 < n)\n    (hx : IsIntegral R <| x ^ n) : ∃ y : R, algebraMap R A y = x :=\n  isIntegral_iff.mp <| hx.of_pow hn\n\n"}
{"name":"IsIntegrallyClosedIn.exists_algebraMap_eq_of_pow_mem_subalgebra","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nA : Type u_3\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nS : Subalgebra R A\ninst✝ : IsIntegrallyClosedIn (Subtype fun x => Membership.mem S x) A\nx : A\nn : Nat\nhn : LT.lt 0 n\nhx : Membership.mem S (HPow.hPow x n)\n⊢ Exists fun y => Eq ((algebraMap (Subtype fun x => Membership.mem S x) A) y) x","decl":"theorem exists_algebraMap_eq_of_pow_mem_subalgebra {A : Type*} [CommRing A] [Algebra R A]\n    {S : Subalgebra R A} [IsIntegrallyClosedIn S A] {x : A} {n : ℕ} (hn : 0 < n)\n    (hx : x ^ n ∈ S) : ∃ y : S, algebraMap S A y = x :=\n  exists_algebraMap_eq_of_isIntegral_pow hn <| isIntegral_iff.mpr ⟨⟨x ^ n, hx⟩, rfl⟩\n\n"}
{"name":"IsIntegrallyClosedIn.integralClosure_eq_bot_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nhRA : Function.Injective ⇑(algebraMap R A)\n⊢ Iff (Eq (integralClosure R A) Bot.bot) (IsIntegrallyClosedIn R A)","decl":"theorem integralClosure_eq_bot_iff (hRA : Function.Injective (algebraMap R A)) :\n    integralClosure R A = ⊥ ↔ IsIntegrallyClosedIn R A := by\n  refine eq_bot_iff.trans ?_\n  constructor\n  · intro h\n    refine ⟨ hRA, fun hx => Set.mem_range.mp (Algebra.mem_bot.mp (h hx)), ?_⟩\n    rintro ⟨y, rfl⟩\n    apply isIntegral_algebraMap\n  · intro h x hx\n    rw [Algebra.mem_bot, Set.mem_range]\n    exact isIntegral_iff.mp hx\n\n"}
{"name":"IsIntegrallyClosedIn.integralClosure_eq_bot","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : IsIntegrallyClosedIn R A\ninst✝¹ : NoZeroSMulDivisors R A\ninst✝ : Nontrivial A\n⊢ Eq (integralClosure R A) Bot.bot","decl":"@[simp]\ntheorem integralClosure_eq_bot [IsIntegrallyClosedIn R A] [NoZeroSMulDivisors R A] [Nontrivial A] :\n    integralClosure R A = ⊥ :=\n  (integralClosure_eq_bot_iff A (NoZeroSMulDivisors.algebraMap_injective _ _)).mpr ‹_›\n\n"}
{"name":"IsIntegrallyClosedIn.of_isIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : Algebra R A\nB : Type u_3\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\ninst✝² : Algebra A B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsIntegralClosure A R B\n⊢ IsIntegrallyClosedIn A B","decl":"/-- If `R` is the integral closure of `S` in `A`, then it is integrally closed in `A`. -/\nlemma of_isIntegralClosure [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n    [IsIntegralClosure A R B] :\n    IsIntegrallyClosedIn A B :=\n  have : Algebra.IsIntegral R A := IsIntegralClosure.isIntegral_algebra R B\n  IsIntegralClosure.tower_top (R := R)\n\n"}
{"name":"IsIntegralClosure.of_isIntegrallyClosedIn","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\nB : Type u_3\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsIntegrallyClosedIn A B\ninst✝ : Algebra.IsIntegral R A\n⊢ IsIntegralClosure A R B","decl":"lemma _root_.IsIntegralClosure.of_isIntegrallyClosedIn\n    [Algebra R B] [Algebra A B] [IsScalarTower R A B]\n    [IsIntegrallyClosedIn A B] [Algebra.IsIntegral R A] :\n    IsIntegralClosure A R B := by\n  refine ⟨IsIntegralClosure.algebraMap_injective _ A _, fun {x} ↦\n    ⟨fun hx ↦ IsIntegralClosure.isIntegral_iff.mp (IsIntegral.tower_top (A := A) hx), ?_⟩⟩\n  rintro ⟨y, rfl⟩\n  exact IsIntegral.map (IsScalarTower.toAlgHom A A B) (Algebra.IsIntegral.isIntegral y)\n\n"}
{"name":"IsIntegrallyClosed.instIsIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nK : Type u_3\ninst✝¹ : CommRing K\ninst✝ : Algebra R K\nifr : IsFractionRing R K\niic : IsIntegrallyClosed R\n⊢ IsIntegralClosure R R K","decl":"/-- Note that this is not a duplicate instance, since `IsIntegrallyClosed R` is instead defined\nas `IsIntegrallyClosed R R (FractionRing R)`. -/\ninstance [iic : IsIntegrallyClosed R] : IsIntegralClosure R R K :=\n  (isIntegrallyClosed_iff_isIntegralClosure K).mp iic\n\n"}
{"name":"IsIntegrallyClosed.algebraMap_eq_of_integral","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\nifr : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\nx : K\na✝ : IsIntegral R x\n⊢ Exists fun y => Eq ((algebraMap R K) y) x","decl":"theorem algebraMap_eq_of_integral [IsIntegrallyClosed R] {x : K} :\n    IsIntegral R x → ∃ y : R, algebraMap R K y = x :=\n  IsIntegralClosure.isIntegral_iff.mp\n\n"}
{"name":"IsIntegrallyClosed.isIntegral_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\nifr : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\nx : K\n⊢ Iff (IsIntegral R x) (Exists fun y => Eq ((algebraMap R K) y) x)","decl":"theorem isIntegral_iff [IsIntegrallyClosed R] {x : K} :\n    IsIntegral R x ↔ ∃ y : R, algebraMap R K y = x :=\n  IsIntegrallyClosedIn.isIntegral_iff\n\n"}
{"name":"IsIntegrallyClosed.exists_algebraMap_eq_of_isIntegral_pow","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\nifr : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\nx : K\nn : Nat\nhn : LT.lt 0 n\nhx : IsIntegral R (HPow.hPow x n)\n⊢ Exists fun y => Eq ((algebraMap R K) y) x","decl":"theorem exists_algebraMap_eq_of_isIntegral_pow [IsIntegrallyClosed R] {x : K} {n : ℕ} (hn : 0 < n)\n    (hx : IsIntegral R <| x ^ n) : ∃ y : R, algebraMap R K y = x :=\n  IsIntegrallyClosedIn.exists_algebraMap_eq_of_isIntegral_pow hn hx\n\n"}
{"name":"IsIntegrallyClosed.exists_algebraMap_eq_of_pow_mem_subalgebra","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nK : Type u_4\ninst✝³ : CommRing K\ninst✝² : Algebra R K\nS : Subalgebra R K\ninst✝¹ : IsIntegrallyClosed (Subtype fun x => Membership.mem S x)\ninst✝ : IsFractionRing (Subtype fun x => Membership.mem S x) K\nx : K\nn : Nat\nhn : LT.lt 0 n\nhx : Membership.mem S (HPow.hPow x n)\n⊢ Exists fun y => Eq ((algebraMap (Subtype fun x => Membership.mem S x) K) y) x","decl":"theorem exists_algebraMap_eq_of_pow_mem_subalgebra {K : Type*} [CommRing K] [Algebra R K]\n    {S : Subalgebra R K} [IsIntegrallyClosed S] [IsFractionRing S K] {x : K} {n : ℕ} (hn : 0 < n)\n    (hx : x ^ n ∈ S) : ∃ y : S, algebraMap S K y = x :=\n  IsIntegrallyClosedIn.exists_algebraMap_eq_of_pow_mem_subalgebra hn hx\n\n"}
{"name":"IsIntegralClosure.of_isIntegrallyClosed","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\nK : Type u_3\ninst✝⁶ : CommRing K\ninst✝⁵ : Algebra R K\nifr : IsFractionRing R K\ninst✝⁴ : IsIntegrallyClosed R\ninst✝³ : Algebra S R\ninst✝² : Algebra S K\ninst✝¹ : IsScalarTower S R K\ninst✝ : Algebra.IsIntegral S R\n⊢ IsIntegralClosure R S K","decl":"instance _root_.IsIntegralClosure.of_isIntegrallyClosed [IsIntegrallyClosed R]\n    [Algebra S R] [Algebra S K] [IsScalarTower S R K] [Algebra.IsIntegral S R] :\n    IsIntegralClosure R S K :=\n  IsIntegralClosure.of_isIntegrallyClosedIn\n\n"}
{"name":"IsIntegrallyClosed.integralClosure_eq_bot_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nK : Type u_3\ninst✝¹ : CommRing K\ninst✝ : Algebra R K\nifr : IsFractionRing R K\n⊢ Iff (Eq (integralClosure R K) Bot.bot) (IsIntegrallyClosed R)","decl":"theorem integralClosure_eq_bot_iff : integralClosure R K = ⊥ ↔ IsIntegrallyClosed R :=\n  (IsIntegrallyClosedIn.integralClosure_eq_bot_iff _ (IsFractionRing.injective _ _)).trans\n    (isIntegrallyClosed_iff_isIntegrallyClosedIn _).symm\n\n"}
{"name":"IsIntegrallyClosed.pow_dvd_pow_iff","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\ninst✝ : IsIntegrallyClosed R\nn : Nat\nhn : Ne n 0\na b : R\n⊢ Iff (Dvd.dvd (HPow.hPow a n) (HPow.hPow b n)) (Dvd.dvd a b)","decl":"@[simp]\ntheorem pow_dvd_pow_iff [IsDomain R] [IsIntegrallyClosed R]\n    {n : ℕ} (hn : n ≠ 0) {a b : R} : a ^ n ∣ b ^ n ↔ a ∣ b := by\n  refine ⟨fun ⟨x, hx⟩ ↦ ?_, fun h ↦ pow_dvd_pow_of_dvd h n⟩\n  by_cases ha : a = 0\n  · simpa [ha, hn] using hx\n  let K := FractionRing R\n  replace ha : algebraMap R K a ≠ 0 := fun h ↦\n    ha <| (injective_iff_map_eq_zero _).1 (IsFractionRing.injective R K) _ h\n  let y := (algebraMap R K b) / (algebraMap R K a)\n  have hy : IsIntegral R y := by\n    refine ⟨X ^ n - C x, monic_X_pow_sub_C _ hn, ?_⟩\n    simp only [y, map_pow, eval₂_sub, eval₂_X_pow, div_pow, eval₂_pow', eval₂_C]\n    replace hx := congr_arg (algebraMap R K) hx\n    rw [map_pow] at hx\n    field_simp [hx, ha]\n  obtain ⟨k, hk⟩ := algebraMap_eq_of_integral hy\n  refine ⟨k, IsFractionRing.injective R K ?_⟩\n  rw [map_mul, hk, mul_div_cancel₀ _ ha]\n\n"}
{"name":"IsIntegrallyClosed.integralClosure_eq_bot","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nK : Type u_3\ninst✝² : CommRing K\ninst✝¹ : Algebra R K\nifr : IsFractionRing R K\ninst✝ : IsIntegrallyClosed R\n⊢ Eq (integralClosure R K) Bot.bot","decl":"/-- This is almost a duplicate of `IsIntegrallyClosedIn.integralClosure_eq_bot`,\nexcept the `NoZeroSMulDivisors` hypothesis isn't inferred automatically from `IsFractionRing`. -/\n@[simp]\ntheorem integralClosure_eq_bot [IsIntegrallyClosed R] : integralClosure R K = ⊥ :=\n  (integralClosure_eq_bot_iff K).mpr ‹_›\n\n"}
{"name":"integralClosure.isIntegrallyClosedOfFiniteExtension","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝⁹ : CommRing R\nK : Type u_2\ninst✝⁸ : Field K\ninst✝⁷ : Algebra R K\ninst✝⁶ : IsFractionRing R K\nL : Type u_3\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra R L\ninst✝² : IsScalarTower R K L\ninst✝¹ : IsDomain R\ninst✝ : FiniteDimensional K L\n⊢ IsIntegrallyClosed (Subtype fun x => Membership.mem (integralClosure R L) x)","decl":"theorem isIntegrallyClosedOfFiniteExtension [IsDomain R] [FiniteDimensional K L] :\n    IsIntegrallyClosed (integralClosure R L) :=\n  letI : IsFractionRing (integralClosure R L) L := isFractionRing_of_finite_extension K L\n  (integralClosure_eq_bot_iff L).mp integralClosure_idem\n\n"}
{"name":"isIntegrallyClosed_of_isLocalization","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsIntegrallyClosed R\ninst✝¹ : IsDomain R\nM : Submonoid R\nhM : LE.le M (nonZeroDivisors R)\ninst✝ : IsLocalization M S\n⊢ IsIntegrallyClosed S","decl":"lemma isIntegrallyClosed_of_isLocalization [IsIntegrallyClosed R] [IsDomain R] (M : Submonoid R)\n    (hM : M ≤ R⁰) [IsLocalization M S] : IsIntegrallyClosed S := by\n  let K := FractionRing R\n  let g : S →+* K := IsLocalization.map _ (T := R⁰) (RingHom.id R) hM\n  letI := g.toAlgebra\n  have : IsScalarTower R S K := IsScalarTower.of_algebraMap_eq'\n    (by rw [RingHom.algebraMap_toAlgebra, IsLocalization.map_comp, RingHomCompTriple.comp_eq])\n  have := IsFractionRing.isFractionRing_of_isDomain_of_isLocalization M S K\n  refine (isIntegrallyClosed_iff_isIntegralClosure (K := K)).mpr\n    ⟨IsFractionRing.injective _ _, fun {x} ↦ ⟨?_, fun e ↦ e.choose_spec ▸ isIntegral_algebraMap⟩⟩\n  intro hx\n  obtain ⟨⟨y, y_mem⟩, hy⟩ := hx.exists_multiple_integral_of_isLocalization M _\n  obtain ⟨z, hz⟩ := (isIntegrallyClosed_iff _).mp ‹_› hy\n  refine ⟨IsLocalization.mk' S z ⟨y, y_mem⟩, (IsLocalization.lift_mk'_spec _ _ _ _).mpr ?_⟩\n  rw [RingHom.comp_id, hz, ← Algebra.smul_def, Submonoid.mk_smul]\n\n"}
{"name":"Field.instIsIntegrallyClosed","module":"Mathlib.RingTheory.IntegralClosure.IntegrallyClosed","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ IsIntegrallyClosed K","decl":"/-- Any field is integral closed. -/\n/- Although `infer_instance` can find this if you import Mathlib, in this file they have not been\n  proven yet. However, it is used to prove a fundamental property of `IsIntegrallyClosed`,\n  and it is not desirable to involve more content from other files. -/\ninstance Field.instIsIntegrallyClosed (K : Type*) [Field K] : IsIntegrallyClosed K :=\n  (isIntegrallyClosed_iff K).mpr fun {x} _ ↦ ⟨x, rfl⟩\n"}
