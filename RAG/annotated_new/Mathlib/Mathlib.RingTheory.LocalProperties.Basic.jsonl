{"name":"RingHom.PropertyIsLocal.ofLocalizationSpan","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nself : RingHom.PropertyIsLocal P\n⊢ RingHom.OfLocalizationSpan P","decl":"/-- A property of ring homs is local if it is preserved by localizations and compositions, and for\neach `{ r }` that spans `S`, we have `P (R →+* S) ↔ ∀ r, P (R →+* Sᵣ)`. -/\nstructure RingHom.PropertyIsLocal : Prop where\n  localizationAwayPreserves : RingHom.LocalizationAwayPreserves @P\n  ofLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P\n  ofLocalizationSpan : RingHom.OfLocalizationSpan @P\n  StableUnderCompositionWithLocalizationAwayTarget :\n    RingHom.StableUnderCompositionWithLocalizationAwayTarget @P\n\n"}
{"name":"RingHom.PropertyIsLocal.localizationAwayPreserves","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nself : RingHom.PropertyIsLocal P\n⊢ RingHom.LocalizationAwayPreserves P","decl":"/-- A property of ring homs is local if it is preserved by localizations and compositions, and for\neach `{ r }` that spans `S`, we have `P (R →+* S) ↔ ∀ r, P (R →+* Sᵣ)`. -/\nstructure RingHom.PropertyIsLocal : Prop where\n  localizationAwayPreserves : RingHom.LocalizationAwayPreserves @P\n  ofLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P\n  ofLocalizationSpan : RingHom.OfLocalizationSpan @P\n  StableUnderCompositionWithLocalizationAwayTarget :\n    RingHom.StableUnderCompositionWithLocalizationAwayTarget @P\n\n"}
{"name":"RingHom.PropertyIsLocal.StableUnderCompositionWithLocalizationAwayTarget","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nself : RingHom.PropertyIsLocal P\n⊢ RingHom.StableUnderCompositionWithLocalizationAwayTarget P","decl":"/-- A property of ring homs is local if it is preserved by localizations and compositions, and for\neach `{ r }` that spans `S`, we have `P (R →+* S) ↔ ∀ r, P (R →+* Sᵣ)`. -/\nstructure RingHom.PropertyIsLocal : Prop where\n  localizationAwayPreserves : RingHom.LocalizationAwayPreserves @P\n  ofLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P\n  ofLocalizationSpan : RingHom.OfLocalizationSpan @P\n  StableUnderCompositionWithLocalizationAwayTarget :\n    RingHom.StableUnderCompositionWithLocalizationAwayTarget @P\n\n"}
{"name":"RingHom.PropertyIsLocal.ofLocalizationSpanTarget","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nself : RingHom.PropertyIsLocal P\n⊢ RingHom.OfLocalizationSpanTarget P","decl":"/-- A property of ring homs is local if it is preserved by localizations and compositions, and for\neach `{ r }` that spans `S`, we have `P (R →+* S) ↔ ∀ r, P (R →+* Sᵣ)`. -/\nstructure RingHom.PropertyIsLocal : Prop where\n  localizationAwayPreserves : RingHom.LocalizationAwayPreserves @P\n  ofLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P\n  ofLocalizationSpan : RingHom.OfLocalizationSpan @P\n  StableUnderCompositionWithLocalizationAwayTarget :\n    RingHom.StableUnderCompositionWithLocalizationAwayTarget @P\n\n"}
{"name":"RingHom.ofLocalizationSpan_iff_finite","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\n⊢ Iff (RingHom.OfLocalizationSpan P) (RingHom.OfLocalizationFiniteSpan P)","decl":"theorem RingHom.ofLocalizationSpan_iff_finite :\n    RingHom.OfLocalizationSpan @P ↔ RingHom.OfLocalizationFiniteSpan @P := by\n  delta RingHom.OfLocalizationSpan RingHom.OfLocalizationFiniteSpan\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s; exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (Ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n\n"}
{"name":"RingHom.ofLocalizationSpanTarget_iff_finite","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\n⊢ Iff (RingHom.OfLocalizationSpanTarget P) (RingHom.OfLocalizationFiniteSpanTarget P)","decl":"theorem RingHom.ofLocalizationSpanTarget_iff_finite :\n    RingHom.OfLocalizationSpanTarget @P ↔ RingHom.OfLocalizationFiniteSpanTarget @P := by\n  delta RingHom.OfLocalizationSpanTarget RingHom.OfLocalizationFiniteSpanTarget\n  apply forall₅_congr\n  -- TODO: Using `refine` here breaks `resetI`.\n  intros\n  constructor\n  · intro h s; exact h s\n  · intro h s hs hs'\n    obtain ⟨s', h₁, h₂⟩ := (Ideal.span_eq_top_iff_finite s).mp hs\n    exact h s' h₂ fun x => hs' ⟨_, h₁ x.prop⟩\n\n"}
{"name":"RingHom.HoldsForLocalizationAway.of_bijective","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nP : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nH : RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\nhf : Function.Bijective ⇑f\n⊢ P f","decl":"theorem RingHom.HoldsForLocalizationAway.of_bijective\n    (H : RingHom.HoldsForLocalizationAway P) (hf : Function.Bijective f) :\n    P f := by\n  letI := f.toAlgebra\n  have := IsLocalization.at_units (.powers (1 : R)) (by simp)\n  have := IsLocalization.isLocalization_of_algEquiv (.powers (1 : R))\n    (AlgEquiv.ofBijective (Algebra.ofId R S) hf)\n  exact H _ 1\n\n"}
{"name":"RingHom.StableUnderComposition.stableUnderCompositionWithLocalizationAway","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPc : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => P","decl":"lemma RingHom.StableUnderComposition.stableUnderCompositionWithLocalizationAway\n    (hPc : RingHom.StableUnderComposition P) (hPl : HoldsForLocalizationAway P) :\n    StableUnderCompositionWithLocalizationAway P := by\n  constructor\n  · introv _ _ hf\n    exact hPc _ _ (hPl S r) hf\n  · introv _ _ hf\n    exact hPc _ _ hf (hPl T s)\n\n"}
{"name":"RingHom.HoldsForLocalizationAway.containsIdentities","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPl : RingHom.HoldsForLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P","decl":"lemma RingHom.HoldsForLocalizationAway.containsIdentities (hPl : HoldsForLocalizationAway P) :\n    ContainsIdentities P := by\n  introv R\n  exact hPl.of_bijective _ _ Function.bijective_id\n\n"}
{"name":"RingHom.LocalizationAwayPreserves.respectsIso","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P","decl":"lemma RingHom.LocalizationAwayPreserves.respectsIso\n    (hP : LocalizationAwayPreserves P) :\n    RespectsIso P where\n  left {R S T} _ _ _ f e hf := by\n    letI := e.toRingHom.toAlgebra\n    have : IsLocalization.Away (1 : R) R :=\n      IsLocalization.away_of_isUnit_of_bijective _ isUnit_one (Equiv.refl _).bijective\n    have : IsLocalization.Away (f 1) T :=\n      IsLocalization.away_of_isUnit_of_bijective _ (by simp) e.bijective\n    convert hP f 1 R T hf\n    trans (IsLocalization.Away.map R T f 1).comp (algebraMap R R)\n    · rw [IsLocalization.Away.map, IsLocalization.map_comp]; rfl\n    · rfl\n  right {R S T} _ _ _ f e hf := by\n    letI := e.symm.toRingHom.toAlgebra\n    have : IsLocalization.Away (1 : S) R :=\n      IsLocalization.away_of_isUnit_of_bijective _ isUnit_one e.symm.bijective\n    have : IsLocalization.Away (f 1) T :=\n      IsLocalization.away_of_isUnit_of_bijective _ (by simp) (Equiv.refl _).bijective\n    convert hP f 1 R T hf\n    have : (IsLocalization.Away.map R T f 1).comp e.symm.toRingHom = f :=\n      IsLocalization.map_comp ..\n    conv_lhs => rw [← this, RingHom.comp_assoc]\n    simp only [RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp, RingHomCompTriple.comp_eq]\n\n"}
{"name":"RingHom.StableUnderCompositionWithLocalizationAway.respectsIso","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P","decl":"lemma RingHom.StableUnderCompositionWithLocalizationAway.respectsIso\n    (hP : StableUnderCompositionWithLocalizationAway P) :\n    RespectsIso P where\n  left {R S T} _ _ _ f e hf := by\n    letI := e.toRingHom.toAlgebra\n    have : IsLocalization.Away (1 : S) T :=\n      IsLocalization.away_of_isUnit_of_bijective _ isUnit_one e.bijective\n    exact hP.right T (1 : S) f hf\n  right {R S T} _ _ _ f e hf := by\n    letI := e.toRingHom.toAlgebra\n    have : IsLocalization.Away (1 : R) S :=\n      IsLocalization.away_of_isUnit_of_bijective _ isUnit_one e.bijective\n    exact hP.left S (1 : R) f hf\n\n"}
{"name":"RingHom.PropertyIsLocal.respectsIso","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.PropertyIsLocal P\n⊢ RingHom.RespectsIso P","decl":"theorem RingHom.PropertyIsLocal.respectsIso (hP : RingHom.PropertyIsLocal @P) :\n    RingHom.RespectsIso @P :=\n  hP.localizationAwayPreserves.respectsIso\n\n-- Almost all arguments are implicit since this is not intended to use mid-proof.\n"}
{"name":"RingHom.LocalizationPreserves.away","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nH : RingHom.LocalizationPreserves P\n⊢ RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P","decl":"theorem RingHom.LocalizationPreserves.away (H : RingHom.LocalizationPreserves @P) :\n    RingHom.LocalizationAwayPreserves P := by\n  intros R S _ _ f r R' S' _ _ _ _ _ _ hf\n  have : IsLocalization ((Submonoid.powers r).map f) S' := by rw [Submonoid.map_powers]; assumption\n  exact H f (Submonoid.powers r) R' S' hf\n\n"}
{"name":"RingHom.PropertyIsLocal.HoldsForLocalizationAway","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.PropertyIsLocal P\nhPi : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => P\n⊢ RingHom.HoldsForLocalizationAway P","decl":"lemma RingHom.PropertyIsLocal.HoldsForLocalizationAway (hP : RingHom.PropertyIsLocal @P)\n    (hPi : ContainsIdentities P) :\n    RingHom.HoldsForLocalizationAway @P := by\n  introv R _\n  have : algebraMap R S = (algebraMap R S).comp (RingHom.id R) := by simp\n  rw [this]\n  apply hP.StableUnderCompositionWithLocalizationAwayTarget S r\n  apply hPi\n\n"}
{"name":"RingHom.OfLocalizationSpanTarget.ofLocalizationSpan","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.OfLocalizationSpanTarget P\nhP' : RingHom.StableUnderCompositionWithLocalizationAwaySource P\n⊢ RingHom.OfLocalizationSpan P","decl":"theorem RingHom.OfLocalizationSpanTarget.ofLocalizationSpan\n    (hP : RingHom.OfLocalizationSpanTarget @P)\n    (hP' : RingHom.StableUnderCompositionWithLocalizationAwaySource @P) :\n    RingHom.OfLocalizationSpan @P := by\n  introv R hs hs'\n  apply_fun Ideal.map f at hs\n  rw [Ideal.map_span, Ideal.map_top] at hs\n  apply hP _ _ hs\n  rintro ⟨_, r, hr, rfl⟩\n  rw [← IsLocalization.map_comp (M := Submonoid.powers r) (S := Localization.Away r)\n    (T := Submonoid.powers (f r))]\n  · apply hP' _ r\n    exact hs' ⟨r, hr⟩\n\n"}
{"name":"RingHom.OfLocalizationSpan.ofIsLocalization","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => P\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\ns : Set R\nhs : Eq (Ideal.span s) Top.top\nhT : ∀ (r : ↑s), Exists fun Rᵣ => Exists fun Sᵣ => Exists fun x => Exists fun x_1 => Exists fun x_2 => Exists fun x_3 => Exists fun x_4 => Exists fun x_5 => Exists fun fᵣ => Exists fun x_6 => P fᵣ\n⊢ P f","decl":"lemma RingHom.OfLocalizationSpan.ofIsLocalization\n    (hP : RingHom.OfLocalizationSpan P) (hPi : RingHom.RespectsIso P)\n    {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S) (s : Set R) (hs : Ideal.span s = ⊤)\n    (hT : ∀ r : s, ∃ (Rᵣ Sᵣ : Type u) (_ : CommRing Rᵣ) (_ : CommRing Sᵣ)\n      (_ : Algebra R Rᵣ) (_ : Algebra S Sᵣ) (_ : IsLocalization.Away r.val Rᵣ)\n      (_ : IsLocalization.Away (f r.val) Sᵣ) (fᵣ : Rᵣ →+* Sᵣ)\n      (_ : fᵣ.comp (algebraMap R Rᵣ) = (algebraMap S Sᵣ).comp f),\n        P fᵣ) : P f := by\n  apply hP _ s hs\n  intro r\n  obtain ⟨Rᵣ, Sᵣ, _, _, _, _, _, _, fᵣ, hfᵣ, hf⟩ := hT r\n  let e₁ := (Localization.algEquiv (.powers r.val) Rᵣ).toRingEquiv\n  let e₂ := (IsLocalization.algEquiv (.powers (f r.val))\n    (Localization (.powers (f r.val))) Sᵣ).symm.toRingEquiv\n  have : Localization.awayMap f r.val =\n      (e₂.toRingHom.comp fᵣ).comp e₁.toRingHom := by\n    apply IsLocalization.ringHom_ext (.powers r.val)\n    ext x\n    have : fᵣ ((algebraMap R Rᵣ) x) = algebraMap S Sᵣ (f x) := by\n      rw [← RingHom.comp_apply, hfᵣ, RingHom.comp_apply]\n    simp [-AlgEquiv.symm_toRingEquiv, e₂, e₁, Localization.awayMap, IsLocalization.Away.map, this]\n  rw [this]\n  apply hPi.right\n  apply hPi.left\n  exact hf\n\n"}
{"name":"RingHom.OfLocalizationSpan.ofIsLocalization'","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => P\nhPi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\ns : Set R\nhs : Eq (Ideal.span s) Top.top\nhT : ∀ (r : ↑s), Exists fun Rᵣ => Exists fun Sᵣ => Exists fun x => Exists fun x_1 => Exists fun x_2 => Exists fun x_3 => Exists fun x_4 => Exists fun x_5 => P (IsLocalization.Away.map Rᵣ Sᵣ f ↑r)\n⊢ P f","decl":"/-- Variant of `RingHom.OfLocalizationSpan.ofIsLocalization` where\n`fᵣ = IsLocalization.Away.map`. -/\nlemma RingHom.OfLocalizationSpan.ofIsLocalization'\n    (hP : RingHom.OfLocalizationSpan P) (hPi : RingHom.RespectsIso P)\n    {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S) (s : Set R) (hs : Ideal.span s = ⊤)\n    (hT : ∀ r : s, ∃ (Rᵣ Sᵣ : Type u) (_ : CommRing Rᵣ) (_ : CommRing Sᵣ)\n      (_ : Algebra R Rᵣ) (_ : Algebra S Sᵣ) (_ : IsLocalization.Away r.val Rᵣ)\n      (_ : IsLocalization.Away (f r.val) Sᵣ),\n        P (IsLocalization.Away.map Rᵣ Sᵣ f r)) : P f := by\n  apply hP.ofIsLocalization hPi _ s hs\n  intro r\n  obtain ⟨Rᵣ, Sᵣ, _, _, _, _, _, _, hf⟩ := hT r\n  exact ⟨Rᵣ, Sᵣ, inferInstance, inferInstance, inferInstance, inferInstance,\n    inferInstance, inferInstance, IsLocalization.Away.map Rᵣ Sᵣ f r, IsLocalization.map_comp _, hf⟩\n\n"}
{"name":"RingHom.OfLocalizationSpanTarget.ofIsLocalization","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.OfLocalizationSpanTarget fun {R S} [CommRing R] [CommRing S] => P\nhP' : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nR S : Type u\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\ns : Set S\nhs : Eq (Ideal.span s) Top.top\nhT : ∀ (r : ↑s), Exists fun T => Exists fun x => Exists fun x_1 => Exists fun x_2 => P ((algebraMap S T).comp f)\n⊢ P f","decl":"lemma RingHom.OfLocalizationSpanTarget.ofIsLocalization\n    (hP : RingHom.OfLocalizationSpanTarget P) (hP' : RingHom.RespectsIso P)\n    {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S) (s : Set S) (hs : Ideal.span s = ⊤)\n    (hT : ∀ r : s, ∃ (T : Type u) (_ : CommRing T) (_ : Algebra S T)\n      (_ : IsLocalization.Away (r : S) T), P ((algebraMap S T).comp f)) : P f := by\n  apply hP _ s hs\n  intros r\n  obtain ⟨T, _, _, _, hT⟩ := hT r\n  convert hP'.1 _\n    (Localization.algEquiv (R := S) (Submonoid.powers (r : S)) T).symm.toRingEquiv hT\n  rw [← RingHom.comp_assoc, RingEquiv.toRingHom_eq_coe, AlgEquiv.toRingEquiv_eq_coe,\n    AlgEquiv.toRingEquiv_toRingHom, Localization.coe_algEquiv_symm, IsLocalization.map_comp,\n    RingHom.comp_id]\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.of_isLocalization","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange P\nR S Rᵣ Sᵣ : Type u\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : CommRing Rᵣ\ninst✝⁹ : CommRing Sᵣ\ninst✝⁸ : Algebra R Rᵣ\ninst✝⁷ : Algebra S Sᵣ\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra R Sᵣ\ninst✝⁴ : Algebra Rᵣ Sᵣ\ninst✝³ : IsScalarTower R S Sᵣ\ninst✝² : IsScalarTower R Rᵣ Sᵣ\nM : Submonoid R\ninst✝¹ : IsLocalization M Rᵣ\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid S M) Sᵣ\nh : P (algebraMap R S)\n⊢ P (algebraMap Rᵣ Sᵣ)","decl":"/-- Let `S` be an `R`-algebra and `Sᵣ` and `Rᵣ` be the respective localizations at a submonoid\n`M` of `R`. If `P` is stable under base change and `P` holds for `algebraMap R S`, then\n`P` holds for `algebraMap Rᵣ Sᵣ`. -/\nlemma RingHom.IsStableUnderBaseChange.of_isLocalization [Algebra R S] [Algebra R Sᵣ] [Algebra Rᵣ Sᵣ]\n    [IsScalarTower R S Sᵣ] [IsScalarTower R Rᵣ Sᵣ]\n    (M : Submonoid R) [IsLocalization M Rᵣ] [IsLocalization (Algebra.algebraMapSubmonoid S M) Sᵣ]\n    (h : P (algebraMap R S)) : P (algebraMap Rᵣ Sᵣ) :=\n  letI : Algebra.IsPushout R S Rᵣ Sᵣ := Algebra.isPushout_of_isLocalization M Rᵣ S Sᵣ\n  hP R S Rᵣ Sᵣ h\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.isLocalization_map","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange P\nR S Rᵣ Sᵣ : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing Rᵣ\ninst✝⁴ : CommRing Sᵣ\ninst✝³ : Algebra R Rᵣ\ninst✝² : Algebra S Sᵣ\nM : Submonoid R\ninst✝¹ : IsLocalization M Rᵣ\nf : RingHom R S\ninst✝ : IsLocalization (Submonoid.map f M) Sᵣ\nhf : P f\n⊢ P (IsLocalization.map Sᵣ f ⋯)","decl":"/-- If `P` is stable under base change and holds for `f`, then `P` holds for `f` localized\nat any submonoid `M` of `R`. -/\nlemma RingHom.IsStableUnderBaseChange.isLocalization_map (M : Submonoid R) [IsLocalization M Rᵣ]\n    (f : R →+* S) [IsLocalization (M.map f) Sᵣ] (hf : P f) :\n    P (IsLocalization.map Sᵣ f M.le_comap_map : Rᵣ →+* Sᵣ) := by\n  algebraize [f, IsLocalization.map (S := Rᵣ) Sᵣ f M.le_comap_map,\n    (IsLocalization.map (S := Rᵣ) Sᵣ f M.le_comap_map).comp (algebraMap R Rᵣ)]\n  haveI : IsScalarTower R S Sᵣ := IsScalarTower.of_algebraMap_eq'\n    (IsLocalization.map_comp M.le_comap_map)\n  haveI : IsLocalization (Algebra.algebraMapSubmonoid S M) Sᵣ :=\n    inferInstanceAs <| IsLocalization (M.map f) Sᵣ\n  apply hP.of_isLocalization M hf\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.localizationPreserves","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange P\n⊢ RingHom.LocalizationPreserves fun {R S} [CommRing R] [CommRing S] => P","decl":"lemma RingHom.IsStableUnderBaseChange.localizationPreserves : LocalizationPreserves P := by\n  introv R hf\n  exact hP.isLocalization_map _ _ hf\n\n"}
{"name":"Ideal.localized'_eq_map","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\np : Submonoid R\ninst✝ : IsLocalization p S\nI : Ideal R\n⊢ Eq (Submodule.localized' S p (Algebra.linearMap R S) I) (Ideal.map (algebraMap R S) I)","decl":"theorem Ideal.localized'_eq_map (I : Ideal R) :\n    haveI := (isLocalizedModule_iff_isLocalization' p S).mpr inferInstance\n    Submodule.localized' S p (Algebra.linearMap R S) I = I.map (algebraMap R S) :=\n  SetLike.ext fun x ↦ by\n    simp_rw [Submodule.mem_localized', IsLocalization.mem_map_algebraMap_iff p,\n      IsLocalizedModule.mk'_eq_iff, mul_comm x, eq_comm (a := _ * x), ← Algebra.smul_def,\n      Prod.exists, Subtype.exists, ← exists_prop]\n    rfl\n\n"}
{"name":"Ideal.localized₀_eq_restrictScalars_map","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\np : Submonoid R\ninst✝ : IsLocalization p S\nI : Ideal R\n⊢ Eq (Submodule.localized₀ p (Algebra.linearMap R S) I) (Submodule.restrictScalars R (Ideal.map (algebraMap R S) I))","decl":"theorem Ideal.localized₀_eq_restrictScalars_map (I : Ideal R) :\n    Submodule.localized₀ p (Algebra.linearMap R S) I = (I.map (algebraMap R S)).restrictScalars R :=\n  congr(Submodule.restrictScalars R $(localized'_eq_map S p I))\n\n"}
{"name":"Algebra.idealMap_eq_ofEq_comp_toLocalized₀","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\np : Submonoid R\ninst✝ : IsLocalization p S\nI : Ideal R\n⊢ Eq (Algebra.idealMap S I) ((↑(LinearEquiv.ofEq (Submodule.localized₀ p (Algebra.linearMap R S) I) (Submodule.restrictScalars R (Ideal.map (algebraMap R S) I)) ⋯)).comp (Submodule.toLocalized₀ p (Algebra.linearMap R S) I))","decl":"theorem Algebra.idealMap_eq_ofEq_comp_toLocalized₀ (I : Ideal R) :\n    haveI := (isLocalizedModule_iff_isLocalization' p S).mpr inferInstance\n    Algebra.idealMap S I =\n      (LinearEquiv.ofEq _ _ <| Ideal.localized₀_eq_restrictScalars_map S p I).toLinearMap ∘ₗ\n      Submodule.toLocalized₀ p (Algebra.linearMap R S) I :=\n  rfl\n\n"}
{"name":"Ideal.mem_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\nJ : Ideal R\nh : ∀ (P : Ideal R) (x : P.IsMaximal), Membership.mem (Ideal.map (algebraMap R (Localization.AtPrime P)) J) ((algebraMap R (Localization.AtPrime P)) r)\n⊢ Membership.mem J r","decl":"theorem Ideal.mem_of_localization_maximal {r : R} {J : Ideal R}\n    (h : ∀ (P : Ideal R) (_ : P.IsMaximal),\n      algebraMap R _ r ∈ Ideal.map (algebraMap R (Localization.AtPrime P)) J) :\n    r ∈ J :=\n  Submodule.mem_of_localization_maximal _ _ _ _ fun P hP ↦ by\n    apply (localized'_eq_map (Localization.AtPrime P) P.primeCompl J).symm ▸ h P hP\n\n"}
{"name":"Ideal.le_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI J : Ideal R\nh : ∀ (P : Ideal R) (x : P.IsMaximal), LE.le (Ideal.map (algebraMap R (Localization.AtPrime P)) I) (Ideal.map (algebraMap R (Localization.AtPrime P)) J)\n⊢ LE.le I J","decl":"/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in\nthe localization of `J` at `P`, then `I ≤ J`. -/\ntheorem Ideal.le_of_localization_maximal {I J : Ideal R}\n    (h : ∀ (P : Ideal R) (_ : P.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I ≤\n        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :\n    I ≤ J :=\n  fun _ hm ↦ mem_of_localization_maximal fun P hP ↦ h P hP (mem_map_of_mem _ hm)\n\n"}
{"name":"Ideal.eq_of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI J : Ideal R\nh : ∀ (P : Ideal R) (x : P.IsMaximal), Eq (Ideal.map (algebraMap R (Localization.AtPrime P)) I) (Ideal.map (algebraMap R (Localization.AtPrime P)) J)\n⊢ Eq I J","decl":"/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to\nthe localization of `J` at `P`, then `I = J`. -/\ntheorem Ideal.eq_of_localization_maximal {I J : Ideal R}\n    (h : ∀ (P : Ideal R) (_ : P.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime P)) I =\n        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :\n    I = J :=\n  le_antisymm (le_of_localization_maximal fun P hP ↦ (h P hP).le)\n    (le_of_localization_maximal fun P hP ↦ (h P hP).ge)\n\n"}
{"name":"ideal_eq_bot_of_localization'","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nh : ∀ (J : Ideal R) (x : J.IsMaximal), Eq (Ideal.map (algebraMap R (Localization.AtPrime J)) I) Bot.bot\n⊢ Eq I Bot.bot","decl":"/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization' (I : Ideal R)\n    (h : ∀ (J : Ideal R) (_ : J.IsMaximal),\n      Ideal.map (algebraMap R (Localization.AtPrime J)) I = ⊥) :\n    I = ⊥ :=\n  Ideal.eq_of_localization_maximal fun P hP => by simpa using h P hP\n\n"}
{"name":"eq_zero_of_localization","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nr : R\nh : ∀ (J : Ideal R) (x : J.IsMaximal), Eq ((algebraMap R (Localization.AtPrime J)) r) 0\n⊢ Eq r 0","decl":"theorem eq_zero_of_localization (r : R)\n    (h : ∀ (J : Ideal R) (_ : J.IsMaximal), algebraMap R (Localization.AtPrime J) r = 0) :\n    r = 0 :=\n  Module.eq_zero_of_localization_maximal _ (fun _ _ ↦ Algebra.linearMap R _) r h\n\n"}
{"name":"ideal_eq_bot_of_localization","module":"Mathlib.RingTheory.LocalProperties.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nh : ∀ (J : Ideal R) (x : J.IsMaximal), Eq (IsLocalization.coeSubmodule (Localization.AtPrime J) I) Bot.bot\n⊢ Eq I Bot.bot","decl":"/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/\ntheorem ideal_eq_bot_of_localization (I : Ideal R)\n    (h : ∀ (J : Ideal R) (_ : J.IsMaximal),\n      IsLocalization.coeSubmodule (Localization.AtPrime J) I = ⊥) :\n    I = ⊥ :=\n  bot_unique fun r hr ↦ eq_zero_of_localization r fun J hJ ↦ (h J hJ).le ⟨r, hr, rfl⟩\n\n"}
