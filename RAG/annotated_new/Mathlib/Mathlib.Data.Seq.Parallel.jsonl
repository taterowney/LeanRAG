{"name":"Computation.terminates_parallel.aux","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nl : List (Computation α)\nS : Stream'.WSeq (Computation α)\nc : Computation α\na✝¹ : Membership.mem l c\na✝ : c.Terminates\n⊢ (Computation.corec Computation.parallel.aux1 { fst := l, snd := S }).Terminates","decl":"theorem terminates_parallel.aux :\n    ∀ {l : List (Computation α)} {S c},\n      c ∈ l → Terminates c → Terminates (corec parallel.aux1 (l, S)) := by\n  have lem1 :\n    ∀ l S, (∃ a : α, parallel.aux2 l = Sum.inl a) → Terminates (corec parallel.aux1 (l, S)) := by\n    intro l S e\n    cases' e with a e\n    have : corec parallel.aux1 (l, S) = return a := by\n      apply destruct_eq_pure\n      simp only [parallel.aux1, rmap, corec_eq]\n      rw [e]\n    rw [this]\n    -- Porting note: This line is required.\n    exact ret_terminates a\n  intro l S c m T\n  revert l S\n  apply @terminatesRecOn _ _ c T _ _\n  · intro a l S m\n    apply lem1\n    induction' l with c l IH <;> simp at m\n    cases' m with e m\n    · rw [← e]\n      simp only [parallel.aux2, rmap, List.foldr_cons, destruct_pure]\n      split <;> simp\n    · cases' IH m with a' e\n      simp only [parallel.aux2, rmap, List.foldr_cons]\n      simp? [parallel.aux2] at e says simp only [parallel.aux2, rmap] at e\n      rw [e]\n      exact ⟨a', rfl⟩\n  · intro s IH l S m\n    have H1 : ∀ l', parallel.aux2 l = Sum.inr l' → s ∈ l' := by\n      induction' l with c l IH' <;> intro l' e' <;> simp at m\n      cases' m with e m <;> simp [parallel.aux2] at e'\n      · rw [← e] at e'\n        -- Porting note: `revert e'` & `intro e'` are required.\n        revert e'\n        split\n        · simp\n        · simp only [destruct_think, Sum.inr.injEq]\n          rintro rfl\n          simp\n      · induction' e : List.foldr (fun c o =>\n            match o with\n            | Sum.inl a => Sum.inl a\n            | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c))\n          (Sum.inr List.nil) l with a' ls <;> erw [e] at e'\n        · contradiction\n        have := IH' m _ e\n        -- Porting note: `revert e'` & `intro e'` are required.\n        revert e'\n        cases destruct c <;> intro e' <;> [injection e'; injection e' with h']\n        rw [← h']\n        simp [this]\n    induction' h : parallel.aux2 l with a l'\n    · exact lem1 _ _ ⟨a, h⟩\n    · have H2 : corec parallel.aux1 (l, S) = think _ := destruct_eq_think (by\n        simp only [parallel.aux1, rmap, corec_eq]\n        rw [h])\n      rw [H2]\n      refine @Computation.think_terminates _ _ ?_\n      have := H1 _ h\n      rcases Seq.destruct S with (_ | ⟨_ | c, S'⟩) <;> simp [parallel.aux1] <;> apply IH <;>\n        simp [this]\n\n"}
{"name":"Computation.terminates_parallel","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS : Stream'.WSeq (Computation α)\nc : Computation α\nh : Membership.mem S c\nT : c.Terminates\n⊢ (Computation.parallel S).Terminates","decl":"theorem terminates_parallel {S : WSeq (Computation α)} {c} (h : c ∈ S) [T : Terminates c] :\n    Terminates (parallel S) := by\n  suffices\n    ∀ (n) (l : List (Computation α)) (S c),\n      c ∈ l ∨ some (some c) = Seq.get? S n → Terminates c → Terminates (corec parallel.aux1 (l, S))\n    from\n    let ⟨n, h⟩ := h\n    this n [] S c (Or.inr h) T\n  intro n; induction' n with n IH <;> intro l S c o T\n  · cases' o with a a\n    · exact terminates_parallel.aux a T\n    have H : Seq.destruct S = some (some c, Seq.tail S) := by simp [Seq.destruct, (· <$> ·), ← a]\n    induction' h : parallel.aux2 l with a l'\n    · have C : corec parallel.aux1 (l, S) = pure a := by\n        apply destruct_eq_pure\n        rw [corec_eq, parallel.aux1]\n        rw [h]\n        simp only [rmap]\n      rw [C]\n      infer_instance\n    · have C : corec parallel.aux1 (l, S) = _ := destruct_eq_think (by\n        simp only [corec_eq, rmap, parallel.aux1.eq_1]\n        rw [h, H])\n      rw [C]\n      refine @Computation.think_terminates _ _ ?_\n      apply terminates_parallel.aux _ T\n      simp\n  · cases' o with a a\n    · exact terminates_parallel.aux a T\n    induction' h : parallel.aux2 l with a l'\n    · have C : corec parallel.aux1 (l, S) = pure a := by\n        apply destruct_eq_pure\n        rw [corec_eq, parallel.aux1]\n        rw [h]\n        simp only [rmap]\n      rw [C]\n      infer_instance\n    · have C : corec parallel.aux1 (l, S) = _ := destruct_eq_think (by\n        simp only [corec_eq, rmap, parallel.aux1.eq_1]\n        rw [h])\n      rw [C]\n      refine @Computation.think_terminates _ _ ?_\n      have TT : ∀ l', Terminates (corec parallel.aux1 (l', S.tail)) := by\n        intro\n        apply IH _ _ _ (Or.inr _) T\n        rw [a, Seq.get?_tail]\n      induction' e : Seq.get? S 0 with o\n      · have D : Seq.destruct S = none := by\n          dsimp [Seq.destruct]\n          rw [e]\n          rfl\n        rw [D]\n        simp only\n        have TT := TT l'\n        rwa [Seq.destruct_eq_nil D, Seq.tail_nil] at TT\n      · have D : Seq.destruct S = some (o, S.tail) := by\n          dsimp [Seq.destruct]\n          rw [e]\n          rfl\n        rw [D]\n        cases' o with c <;> simp [parallel.aux1, TT]\n\n"}
{"name":"Computation.exists_of_mem_parallel","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS : Stream'.WSeq (Computation α)\na : α\nh : Membership.mem (Computation.parallel S) a\n⊢ Exists fun c => And (Membership.mem S c) (Membership.mem c a)","decl":"theorem exists_of_mem_parallel {S : WSeq (Computation α)} {a} (h : a ∈ parallel S) :\n    ∃ c ∈ S, a ∈ c := by\n  suffices\n    ∀ C, a ∈ C → ∀ (l : List (Computation α)) (S),\n      corec parallel.aux1 (l, S) = C → ∃ c, (c ∈ l ∨ c ∈ S) ∧ a ∈ c from\n    let ⟨c, h1, h2⟩ := this _ h [] S rfl\n    ⟨c, h1.resolve_left <| List.not_mem_nil _, h2⟩\n  let F : List (Computation α) → α ⊕ (List (Computation α)) → Prop := by\n    intro l a\n    cases' a with a l'\n    · exact ∃ c ∈ l, a ∈ c\n    · exact ∀ a', (∃ c ∈ l', a' ∈ c) → ∃ c ∈ l, a' ∈ c\n  have lem1 : ∀ l : List (Computation α), F l (parallel.aux2 l) := by\n    intro l\n    induction' l with c l IH <;> simp only [parallel.aux2, List.foldr]\n    · intro a h\n      rcases h with ⟨c, hn, _⟩\n      exact False.elim <| List.not_mem_nil _ hn\n    · simp only [parallel.aux2] at IH\n      -- Porting note: `revert IH` & `intro IH` are required.\n      revert IH\n      cases' List.foldr (fun c o =>\n        match o with\n        | Sum.inl a => Sum.inl a\n        | Sum.inr ls => rmap (fun c' => c' :: ls) (destruct c)) (Sum.inr List.nil) l with a ls <;>\n        intro IH <;>\n        simp only [parallel.aux2]\n      · rcases IH with ⟨c', cl, ac⟩\n        exact ⟨c', List.Mem.tail _ cl, ac⟩\n      · induction' h : destruct c with a c' <;> simp only [rmap]\n        · refine ⟨c, List.mem_cons_self _ _, ?_⟩\n          rw [destruct_eq_pure h]\n          apply ret_mem\n        · intro a' h\n          rcases h with ⟨d, dm, ad⟩\n          simp? at dm says simp only [List.mem_cons] at dm\n          cases' dm with e dl\n          · rw [e] at ad\n            refine ⟨c, List.mem_cons_self _ _, ?_⟩\n            rw [destruct_eq_think h]\n            exact think_mem ad\n          · cases' IH a' ⟨d, dl, ad⟩ with d dm\n            cases' dm with dm ad\n            exact ⟨d, List.Mem.tail _ dm, ad⟩\n  intro C aC\n  -- Porting note: `revert e'` & `intro e'` are required.\n  apply memRecOn aC <;> [skip; intro C' IH] <;> intro l S e <;> have e' := congr_arg destruct e <;>\n    have := lem1 l <;> simp only [parallel.aux1, corec_eq, destruct_pure, destruct_think] at e' <;>\n    revert this e' <;> cases' parallel.aux2 l with a' l' <;> intro this e' <;>\n    [injection e' with h'; injection e'; injection e'; injection e' with h']\n  · rw [h'] at this\n    rcases this with ⟨c, cl, ac⟩\n    exact ⟨c, Or.inl cl, ac⟩\n  · induction' e : Seq.destruct S with a <;> rw [e] at h'\n    · exact\n        let ⟨d, o, ad⟩ := IH _ _ h'\n        let ⟨c, cl, ac⟩ := this a ⟨d, o.resolve_right (WSeq.not_mem_nil _), ad⟩\n        ⟨c, Or.inl cl, ac⟩\n    · cases' a with o S'\n      cases' o with c <;> simp [parallel.aux1] at h' <;> rcases IH _ _ h' with ⟨d, dl | dS', ad⟩\n      · exact\n          let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩\n          ⟨c, Or.inl cl, ac⟩\n      · refine ⟨d, Or.inr ?_, ad⟩\n        rw [Seq.destruct_eq_cons e]\n        exact Seq.mem_cons_of_mem _ dS'\n      · simp at dl\n        cases' dl with dc dl\n        · rw [dc] at ad\n          refine ⟨c, Or.inr ?_, ad⟩\n          rw [Seq.destruct_eq_cons e]\n          apply Seq.mem_cons\n        · exact\n            let ⟨c, cl, ac⟩ := this a ⟨d, dl, ad⟩\n            ⟨c, Or.inl cl, ac⟩\n      · refine ⟨d, Or.inr ?_, ad⟩\n        rw [Seq.destruct_eq_cons e]\n        exact Seq.mem_cons_of_mem _ dS'\n\n"}
{"name":"Computation.map_parallel","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nS : Stream'.WSeq (Computation α)\n⊢ Eq (Computation.map f (Computation.parallel S)) (Computation.parallel (Stream'.WSeq.map (Computation.map f) S))","decl":"theorem map_parallel (f : α → β) (S) : map f (parallel S) = parallel (S.map (map f)) := by\n  refine\n    eq_of_bisim\n      (fun c1 c2 =>\n        ∃ l S,\n          c1 = map f (corec parallel.aux1 (l, S)) ∧\n            c2 = corec parallel.aux1 (l.map (map f), S.map (map f)))\n      ?_ ⟨[], S, rfl, rfl⟩\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | _, _, ⟨l, S, rfl, rfl⟩ => by\n      have : parallel.aux2 (l.map (map f))\n          = lmap f (rmap (List.map (map f)) (parallel.aux2 l)) := by\n        simp only [parallel.aux2, rmap, lmap]\n        induction' l with c l IH <;> simp\n        rw [IH]\n        cases List.foldr _ _ _\n        · simp\n        · cases destruct c <;> simp\n      simp only [BisimO, destruct_map, lmap, rmap, corec_eq, parallel.aux1.eq_1]\n      rw [this]\n      cases' parallel.aux2 l with a l' <;> simp\n      induction' S using WSeq.recOn with c S S <;> simp <;>\n        exact ⟨_, _, rfl, rfl⟩\n\n"}
{"name":"Computation.parallel_empty","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS : Stream'.WSeq (Computation α)\nh : S.head.Promises Option.none\n⊢ Eq (Computation.parallel S) (Computation.empty α)","decl":"theorem parallel_empty (S : WSeq (Computation α)) (h : S.head ~> none) : parallel S = empty _ :=\n  eq_empty_of_not_terminates fun ⟨⟨a, m⟩⟩ => by\n    let ⟨c, cs, _⟩ := exists_of_mem_parallel m\n    let ⟨n, nm⟩ := WSeq.exists_get?_of_mem cs\n    let ⟨c', h'⟩ := WSeq.head_some_of_get?_some nm\n    injection h h'\n\n-- The reason this isn't trivial from exists_of_mem_parallel is because it eliminates to Sort\n"}
{"name":"Computation.parallel_promises","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS : Stream'.WSeq (Computation α)\na : α\nH : ∀ (s : Computation α), Membership.mem S s → s.Promises a\n⊢ (Computation.parallel S).Promises a","decl":"theorem parallel_promises {S : WSeq (Computation α)} {a} (H : ∀ s ∈ S, s ~> a) : parallel S ~> a :=\n  fun _ ma' =>\n  let ⟨_, cs, ac⟩ := exists_of_mem_parallel ma'\n  H _ cs ac\n\n"}
{"name":"Computation.mem_parallel","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS : Stream'.WSeq (Computation α)\na : α\nH : ∀ (s : Computation α), Membership.mem S s → s.Promises a\nc : Computation α\ncs : Membership.mem S c\nac : Membership.mem c a\n⊢ Membership.mem (Computation.parallel S) a","decl":"theorem mem_parallel {S : WSeq (Computation α)} {a} (H : ∀ s ∈ S, s ~> a) {c} (cs : c ∈ S)\n    (ac : a ∈ c) : a ∈ parallel S := by\n  haveI := terminates_of_mem ac\n  haveI := terminates_parallel cs\n  exact mem_of_promises _ (parallel_promises H)\n\n"}
{"name":"Computation.parallel_congr_lem","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS T : Stream'.WSeq (Computation α)\na : α\nH : Stream'.WSeq.LiftRel Computation.Equiv S T\n⊢ Iff (∀ (s : Computation α), Membership.mem S s → s.Promises a) (∀ (t : Computation α), Membership.mem T t → t.Promises a)","decl":"theorem parallel_congr_lem {S T : WSeq (Computation α)} {a} (H : S.LiftRel Equiv T) :\n    (∀ s ∈ S, s ~> a) ↔ ∀ t ∈ T, t ~> a :=\n  ⟨fun h1 _ tT =>\n    let ⟨_, sS, se⟩ := WSeq.exists_of_liftRel_right H tT\n    (promises_congr se _).1 (h1 _ sS),\n    fun h2 _ sS =>\n    let ⟨_, tT, se⟩ := WSeq.exists_of_liftRel_left H sS\n    (promises_congr se _).2 (h2 _ tT)⟩\n\n-- The parallel operation is only deterministic when all computation paths lead to the same value\n"}
{"name":"Computation.parallel_congr_left","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS T : Stream'.WSeq (Computation α)\na : α\nh1 : ∀ (s : Computation α), Membership.mem S s → s.Promises a\nH : Stream'.WSeq.LiftRel Computation.Equiv S T\n⊢ (Computation.parallel S).Equiv (Computation.parallel T)","decl":"theorem parallel_congr_left {S T : WSeq (Computation α)} {a} (h1 : ∀ s ∈ S, s ~> a)\n    (H : S.LiftRel Equiv T) : parallel S ~ parallel T :=\n  let h2 := (parallel_congr_lem H).1 h1\n  fun a' =>\n  ⟨fun h => by\n    have aa := parallel_promises h1 h\n    rw [← aa]\n    rw [← aa] at h\n    exact\n      let ⟨s, sS, as⟩ := exists_of_mem_parallel h\n      let ⟨t, tT, st⟩ := WSeq.exists_of_liftRel_left H sS\n      let aT := (st _).1 as\n      mem_parallel h2 tT aT,\n    fun h => by\n    have aa := parallel_promises h2 h\n    rw [← aa]\n    rw [← aa] at h\n    exact\n      let ⟨s, sS, as⟩ := exists_of_mem_parallel h\n      let ⟨t, tT, st⟩ := WSeq.exists_of_liftRel_right H sS\n      let aT := (st _).2 as\n      mem_parallel h1 tT aT⟩\n\n"}
{"name":"Computation.parallel_congr_right","module":"Mathlib.Data.Seq.Parallel","initialProofState":"α : Type u\nS T : Stream'.WSeq (Computation α)\na : α\nh2 : ∀ (t : Computation α), Membership.mem T t → t.Promises a\nH : Stream'.WSeq.LiftRel Computation.Equiv S T\n⊢ (Computation.parallel S).Equiv (Computation.parallel T)","decl":"theorem parallel_congr_right {S T : WSeq (Computation α)} {a} (h2 : ∀ t ∈ T, t ~> a)\n    (H : S.LiftRel Equiv T) : parallel S ~ parallel T :=\n  parallel_congr_left ((parallel_congr_lem H).2 h2) H\n\n"}
