{"name":"CategoryTheory.isSheaf_pointwiseColimit","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits","initialProofState":"A : Type u_1\nC : Type u_2\nJ : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C\ninst✝³ : CategoryTheory.Category.{u_5, u_3} J\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J A\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts CategoryTheory.Limits.colim\nG : CategoryTheory.Functor J (CategoryTheory.Sheaf (CategoryTheory.extensiveTopology C) A)\n⊢ CategoryTheory.Presheaf.IsSheaf (CategoryTheory.extensiveTopology C) (CategoryTheory.Limits.pointwiseCocone (G.comp (CategoryTheory.sheafToPresheaf (CategoryTheory.extensiveTopology C) A))).pt","decl":"lemma isSheaf_pointwiseColimit [PreservesFiniteProducts (colim (J := J) (C := A))]\n    (G : J ⥤ Sheaf (extensiveTopology C) A) :\n    Presheaf.IsSheaf (extensiveTopology C) (pointwiseCocone (G ⋙ sheafToPresheaf _ A)).pt := by\n  rw [Presheaf.isSheaf_iff_preservesFiniteProducts]\n  dsimp only [pointwiseCocone_pt]\n  apply (config := { allowSynthFailures := true } ) comp_preservesFiniteProducts\n  have : ∀ (i : J), PreservesFiniteProducts ((G ⋙ sheafToPresheaf _ A).obj i) := fun i ↦ by\n    rw [← Presheaf.isSheaf_iff_preservesFiniteProducts]\n    exact Sheaf.cond _\n  exact ⟨fun _ ↦ preservesLimitsOfShape_of_evaluation _ _ fun d ↦\n    inferInstanceAs (PreservesLimitsOfShape _ ((G ⋙ sheafToPresheaf _ _).obj d))⟩\n\n"}
{"name":"CategoryTheory.instPreservesFiniteProductsFunctorColimOfPreadditive","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits","initialProofState":"A : Type u_1\nJ : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_1} A\ninst✝² : CategoryTheory.Category.{u_5, u_3} J\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J A\ninst✝ : CategoryTheory.Preadditive A\n⊢ CategoryTheory.Limits.PreservesFiniteProducts CategoryTheory.Limits.colim","decl":"instance [Preadditive A] : PreservesFiniteProducts (colim (J := J) (C := A)) where\n  preserves I _ := by\n    apply ( config := {allowSynthFailures := true} )\n      preservesProductsOfShape_of_preservesBiproductsOfShape\n    apply preservesBiproductsOfShape_of_preservesCoproductsOfShape\n\n"}
{"name":"CategoryTheory.instPreservesColimitsOfShapeSheafExtensiveTopologyFunctorOppositeSheafToPresheafOfPreservesFiniteProductsColim","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits","initialProofState":"A : Type u_1\nC : Type u_2\nJ : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} C\ninst✝³ : CategoryTheory.Category.{u_5, u_3} J\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J A\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts CategoryTheory.Limits.colim\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J (CategoryTheory.sheafToPresheaf (CategoryTheory.extensiveTopology C) A)","decl":"instance [PreservesFiniteProducts (colim (J := J) (C := A))] :\n    PreservesColimitsOfShape J (sheafToPresheaf (extensiveTopology C) A) where\n  preservesColimit {G} := by\n    suffices CreatesColimit G (sheafToPresheaf (extensiveTopology C) A) from inferInstance\n    refine createsColimitOfIsSheaf _ (fun c hc ↦ ?_)\n    let i : c.pt ≅ (G ⋙ sheafToPresheaf _ _).flip ⋙ colim :=\n      hc.coconePointUniqueUpToIso (pointwiseIsColimit _)\n    rw [Presheaf.isSheaf_of_iso_iff i]\n    exact isSheaf_pointwiseColimit _\n\n"}
{"name":"CategoryTheory.instPreservesFiniteColimitsSheafExtensiveTopologyFunctorOppositeSheafToPresheafOfPreadditiveOfHasFiniteColimits","module":"Mathlib.CategoryTheory.Sites.Coherent.ExtensiveColimits","initialProofState":"A : Type u_1\nC : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\ninst✝³ : CategoryTheory.Category.{u_5, u_2} C\ninst✝² : CategoryTheory.FinitaryExtensive C\ninst✝¹ : CategoryTheory.Preadditive A\ninst✝ : CategoryTheory.Limits.HasFiniteColimits A\n⊢ CategoryTheory.Limits.PreservesFiniteColimits (CategoryTheory.sheafToPresheaf (CategoryTheory.extensiveTopology C) A)","decl":"instance [Preadditive A] [HasFiniteColimits A] :\n    PreservesFiniteColimits (sheafToPresheaf (extensiveTopology C) A) where\n  preservesFiniteColimits _ := inferInstance\n\n"}
