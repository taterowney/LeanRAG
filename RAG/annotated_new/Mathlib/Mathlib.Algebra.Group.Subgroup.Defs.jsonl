{"name":"InvMemClass.inv_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : Inv G\ninst✝ : SetLike S G\nself : InvMemClass S G\ns : S\nx : G\na✝ : Membership.mem s x\n⊢ Membership.mem s (Inv.inv x)","decl":"/-- `InvMemClass S G` states `S` is a type of subsets `s ⊆ G` closed under inverses. -/\nclass InvMemClass (S : Type*) (G : outParam Type*) [Inv G] [SetLike S G] : Prop where\n  /-- `s` is closed under inverses -/\n  inv_mem : ∀ {s : S} {x}, x ∈ s → x⁻¹ ∈ s\n\n"}
{"name":"NegMemClass.neg_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : Neg G\ninst✝ : SetLike S G\nself : NegMemClass S G\ns : S\nx : G\na✝ : Membership.mem s x\n⊢ Membership.mem s (Neg.neg x)","decl":"/-- `NegMemClass S G` states `S` is a type of subsets `s ⊆ G` closed under negation. -/\nclass NegMemClass (S : Type*) (G : outParam Type*) [Neg G] [SetLike S G] : Prop where\n  /-- `s` is closed under negation -/\n  neg_mem : ∀ {s : S} {x}, x ∈ s → -x ∈ s\n\n"}
{"name":"SubgroupClass.toInvMemClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : DivInvMonoid G\ninst✝ : SetLike S G\nself : SubgroupClass S G\n⊢ InvMemClass S G","decl":"/-- `SubgroupClass S G` states `S` is a type of subsets `s ⊆ G` that are subgroups of `G`. -/\nclass SubgroupClass (S : Type*) (G : outParam Type*) [DivInvMonoid G] [SetLike S G]\n    extends SubmonoidClass S G, InvMemClass S G : Prop\n\n"}
{"name":"SubgroupClass.toSubmonoidClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : DivInvMonoid G\ninst✝ : SetLike S G\nself : SubgroupClass S G\n⊢ SubmonoidClass S G","decl":"/-- `SubgroupClass S G` states `S` is a type of subsets `s ⊆ G` that are subgroups of `G`. -/\nclass SubgroupClass (S : Type*) (G : outParam Type*) [DivInvMonoid G] [SetLike S G]\n    extends SubmonoidClass S G, InvMemClass S G : Prop\n\n"}
{"name":"AddSubgroupClass.toNegMemClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : SubNegMonoid G\ninst✝ : SetLike S G\nself : AddSubgroupClass S G\n⊢ NegMemClass S G","decl":"/-- `AddSubgroupClass S G` states `S` is a type of subsets `s ⊆ G` that are\nadditive subgroups of `G`. -/\nclass AddSubgroupClass (S : Type*) (G : outParam Type*) [SubNegMonoid G] [SetLike S G]\n    extends AddSubmonoidClass S G, NegMemClass S G : Prop\n\n"}
{"name":"AddSubgroupClass.toAddSubmonoidClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : outParam (Type u_4)\ninst✝¹ : SubNegMonoid G\ninst✝ : SetLike S G\nself : AddSubgroupClass S G\n⊢ AddSubmonoidClass S G","decl":"/-- `AddSubgroupClass S G` states `S` is a type of subsets `s ⊆ G` that are\nadditive subgroups of `G`. -/\nclass AddSubgroupClass (S : Type*) (G : outParam Type*) [SubNegMonoid G] [SetLike S G]\n    extends AddSubmonoidClass S G, NegMemClass S G : Prop\n\n"}
{"name":"inv_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : Type u_4\ninst✝¹ : InvolutiveInv G\nx✝ : SetLike S G\ninst✝ : InvMemClass S G\nH : S\nx : G\n⊢ Iff (Membership.mem H (Inv.inv x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\ntheorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n    {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=\n  ⟨fun h => inv_inv x ▸ inv_mem h, inv_mem⟩\n\n"}
{"name":"neg_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"S : Type u_3\nG : Type u_4\ninst✝¹ : InvolutiveNeg G\nx✝ : SetLike S G\ninst✝ : NegMemClass S G\nH : S\nx : G\n⊢ Iff (Membership.mem H (Neg.neg x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\ntheorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n    {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=\n  ⟨fun h => inv_inv x ▸ inv_mem h, inv_mem⟩\n\n"}
{"name":"div_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"M : Type u_3\nS : Type u_4\ninst✝¹ : DivInvMonoid M\ninst✝ : SetLike S M\nhSM : SubgroupClass S M\nH : S\nx y : M\nhx : Membership.mem H x\nhy : Membership.mem H y\n⊢ Membership.mem H (HDiv.hDiv x y)","decl":"/-- A subgroup is closed under division. -/\n@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))\n  \"An additive subgroup is closed under subtraction.\"]\ntheorem div_mem {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H := by\n  rw [div_eq_mul_inv]; exact mul_mem hx (inv_mem hy)\n\n"}
{"name":"sub_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"M : Type u_3\nS : Type u_4\ninst✝¹ : SubNegMonoid M\ninst✝ : SetLike S M\nhSM : AddSubgroupClass S M\nH : S\nx y : M\nhx : Membership.mem H x\nhy : Membership.mem H y\n⊢ Membership.mem H (HSub.hSub x y)","decl":"/-- A subgroup is closed under division. -/\n@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))\n  \"An additive subgroup is closed under subtraction.\"]\ntheorem div_mem {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H := by\n  rw [div_eq_mul_inv]; exact mul_mem hx (inv_mem hy)\n\n"}
{"name":"zpow_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"M : Type u_3\nS : Type u_4\ninst✝¹ : DivInvMonoid M\ninst✝ : SetLike S M\nhSM : SubgroupClass S M\nK : S\nx : M\nhx : Membership.mem K x\nn : Int\n⊢ Membership.mem K (HPow.hPow x n)","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))]\ntheorem zpow_mem {x : M} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K\n  | (n : ℕ) => by\n    rw [zpow_natCast]\n    exact pow_mem hx n\n  | -[n+1] => by\n    rw [zpow_negSucc]\n    exact inv_mem (pow_mem hx n.succ)\n\n"}
{"name":"zsmul_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"M : Type u_3\nS : Type u_4\ninst✝¹ : SubNegMonoid M\ninst✝ : SetLike S M\nhSM : AddSubgroupClass S M\nK : S\nx : M\nhx : Membership.mem K x\nn : Int\n⊢ Membership.mem K (HSMul.hSMul n x)","decl":"@[to_additive (attr := aesop safe apply (rule_sets := [SetLike]))]\ntheorem zpow_mem {x : M} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K\n  | (n : ℕ) => by\n    rw [zpow_natCast]\n    exact pow_mem hx n\n  | -[n+1] => by\n    rw [zpow_negSucc]\n    exact inv_mem (pow_mem hx n.succ)\n\n"}
{"name":"exists_neg_mem_iff_exists_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nP : G → Prop\n⊢ Iff (Exists fun x => And (Membership.mem H x) (P (Neg.neg x))) (Exists fun x => And (Membership.mem H x) (P x))","decl":"@[to_additive /-(attr := simp)-/] -- Porting note: `simp` cannot simplify LHS\ntheorem exists_inv_mem_iff_exists_mem {P : G → Prop} :\n    (∃ x : G, x ∈ H ∧ P x⁻¹) ↔ ∃ x ∈ H, P x := by\n  constructor <;>\n    · rintro ⟨x, x_in, hx⟩\n      exact ⟨x⁻¹, inv_mem x_in, by simp [hx]⟩\n\n"}
{"name":"exists_inv_mem_iff_exists_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nP : G → Prop\n⊢ Iff (Exists fun x => And (Membership.mem H x) (P (Inv.inv x))) (Exists fun x => And (Membership.mem H x) (P x))","decl":"@[to_additive /-(attr := simp)-/] -- Porting note: `simp` cannot simplify LHS\ntheorem exists_inv_mem_iff_exists_mem {P : G → Prop} :\n    (∃ x : G, x ∈ H ∧ P x⁻¹) ↔ ∃ x ∈ H, P x := by\n  constructor <;>\n    · rintro ⟨x, x_in, hx⟩\n      exact ⟨x⁻¹, inv_mem x_in, by simp [hx]⟩\n\n"}
{"name":"add_mem_cancel_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HAdd.hAdd y x)) (Membership.mem H y)","decl":"@[to_additive]\ntheorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=\n  ⟨fun hba => by simpa using mul_mem hba (inv_mem h), fun hb => mul_mem hb h⟩\n\n"}
{"name":"mul_mem_cancel_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HMul.hMul y x)) (Membership.mem H y)","decl":"@[to_additive]\ntheorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=\n  ⟨fun hba => by simpa using mul_mem hba (inv_mem h), fun hb => mul_mem hb h⟩\n\n"}
{"name":"mul_mem_cancel_left","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HMul.hMul x y)) (Membership.mem H y)","decl":"@[to_additive]\ntheorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=\n  ⟨fun hab => by simpa using mul_mem (inv_mem h) hab, mul_mem h⟩\n\n"}
{"name":"add_mem_cancel_left","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HAdd.hAdd x y)) (Membership.mem H y)","decl":"@[to_additive]\ntheorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=\n  ⟨fun hab => by simpa using mul_mem (inv_mem h) hab, mul_mem h⟩\n\n"}
{"name":"NegMemClass.coe_neg","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : (x⁻¹).1 = x.1⁻¹ :=\n  rfl\n\n"}
{"name":"InvMemClass.coe_inv","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : (x⁻¹).1 = x.1⁻¹ :=\n  rfl\n\n"}
{"name":"SubgroupClass.subset_union","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nH K L : S\n⊢ Iff (HasSubset.Subset (↑H) (Union.union ↑K ↑L)) (Or (LE.le H K) (LE.le H L))","decl":"@[to_additive]\ntheorem subset_union {H K L : S} : (H : Set G) ⊆ K ∪ L ↔ H ≤ K ∨ H ≤ L := by\n  refine ⟨fun h ↦ ?_, fun h x xH ↦ h.imp (· xH) (· xH)⟩\n  rw [or_iff_not_imp_left, SetLike.not_le_iff_exists]\n  exact fun ⟨x, xH, xK⟩ y yH ↦ (h <| mul_mem xH yH).elim\n    ((h yH).resolve_left fun yK ↦ xK <| (mul_mem_cancel_right yK).mp ·)\n    (mul_mem_cancel_left <| (h xH).resolve_left xK).mp\n\n"}
{"name":"AddSubgroupClass.subset_union","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nH K L : S\n⊢ Iff (HasSubset.Subset (↑H) (Union.union ↑K ↑L)) (Or (LE.le H K) (LE.le H L))","decl":"@[to_additive]\ntheorem subset_union {H K L : S} : (H : Set G) ⊆ K ∪ L ↔ H ≤ K ∨ H ≤ L := by\n  refine ⟨fun h ↦ ?_, fun h x xH ↦ h.imp (· xH) (· xH)⟩\n  rw [or_iff_not_imp_left, SetLike.not_le_iff_exists]\n  exact fun ⟨x, xH, xK⟩ y yH ↦ (h <| mul_mem xH yH).elim\n    ((h yH).resolve_left fun yK ↦ xK <| (mul_mem_cancel_right yK).mp ·)\n    (mul_mem_cancel_left <| (h xH).resolve_left xK).mp\n\n"}
{"name":"SubgroupClass.coe_div","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (x / y).1 = x.1 / y.1 :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.coe_sub","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (x / y).1 = x.1 / y.1 :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.coeSubtype","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\n⊢ Eq (⇑↑H) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coeSubtype : (SubgroupClass.subtype H : H → G) = ((↑) : H → G) := by\n  rfl\n\n"}
{"name":"SubgroupClass.coeSubtype","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\n⊢ Eq (⇑↑H) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coeSubtype : (SubgroupClass.subtype H : H → G) = ((↑) : H → G) := by\n  rfl\n\n"}
{"name":"SubgroupClass.coe_pow","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx : Subtype fun x => Membership.mem H x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.coe_nsmul","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx : Subtype fun x => Membership.mem H x\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"SubgroupClass.coe_zpow","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx : Subtype fun x => Membership.mem H x\nn : Int\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.coe_zsmul","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx : Subtype fun x => Membership.mem H x\nn : Int\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.inclusion_self","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq ((AddSubgroupClass.inclusion ⋯) x) x","decl":"@[to_additive (attr := simp)]\ntheorem inclusion_self (x : H) : inclusion le_rfl x = x := by\n  cases x\n  rfl\n\n"}
{"name":"SubgroupClass.inclusion_self","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq ((SubgroupClass.inclusion ⋯) x) x","decl":"@[to_additive (attr := simp)]\ntheorem inclusion_self (x : H) : inclusion le_rfl x = x := by\n  cases x\n  rfl\n\n"}
{"name":"SubgroupClass.inclusion_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH K : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nh : LE.le H K\nx : G\nhx : Membership.mem H x\n⊢ Eq ((SubgroupClass.inclusion h) ⟨x, hx⟩) ⟨x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem inclusion_mk {h : H ≤ K} (x : G) (hx : x ∈ H) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.inclusion_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH K : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nh : LE.le H K\nx : G\nhx : Membership.mem H x\n⊢ Eq ((AddSubgroupClass.inclusion h) ⟨x, hx⟩) ⟨x, ⋯⟩","decl":"@[to_additive (attr := simp)]\ntheorem inclusion_mk {h : H ≤ K} (x : G) (hx : x ∈ H) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=\n  rfl\n\n"}
{"name":"AddSubgroupClass.inclusion_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\nH K : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nh : LE.le H K\nx : Subtype fun x => Membership.mem K x\nhx : Membership.mem H ↑x\n⊢ Eq ((AddSubgroupClass.inclusion h) ⟨↑x, hx⟩) x","decl":"@[to_additive]\ntheorem inclusion_right (h : H ≤ K) (x : K) (hx : (x : G) ∈ H) : inclusion h ⟨x, hx⟩ = x := by\n  cases x\n  rfl\n\n"}
{"name":"SubgroupClass.inclusion_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH K : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nh : LE.le H K\nx : Subtype fun x => Membership.mem K x\nhx : Membership.mem H ↑x\n⊢ Eq ((SubgroupClass.inclusion h) ⟨↑x, hx⟩) x","decl":"@[to_additive]\ntheorem inclusion_right (h : H ≤ K) (x : K) (hx : (x : G) ∈ H) : inclusion h ⟨x, hx⟩ = x := by\n  cases x\n  rfl\n\n"}
{"name":"SubgroupClass.inclusion_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\nH K : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nL : S\nhHK : LE.le H K\nhKL : LE.le K L\nx : Subtype fun x => Membership.mem H x\n⊢ Eq ((SubgroupClass.inclusion hKL) ((SubgroupClass.inclusion hHK) x)) ((SubgroupClass.inclusion ⋯) x)","decl":"@[simp]\ntheorem inclusion_inclusion {L : S} (hHK : H ≤ K) (hKL : K ≤ L) (x : H) :\n    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x := by\n  cases x\n  rfl\n\n"}
{"name":"AddSubgroupClass.coe_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nH K : S\nh : LE.le H K\na : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((AddSubgroupClass.inclusion h) a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : S} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by\n  cases a\n  simp only [inclusion, MonoidHom.mk'_apply]\n\n"}
{"name":"SubgroupClass.coe_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nH K : S\nh : LE.le H K\na : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((SubgroupClass.inclusion h) a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : S} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by\n  cases a\n  simp only [inclusion, MonoidHom.mk'_apply]\n\n"}
{"name":"AddSubgroupClass.subtype_comp_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nH K : S\nhH : LE.le H K\n⊢ Eq ((↑K).comp (AddSubgroupClass.inclusion hH)) ↑H","decl":"@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : S} (hH : H ≤ K) :\n    (SubgroupClass.subtype K).comp (inclusion hH) = SubgroupClass.subtype H := by\n  ext\n  simp only [MonoidHom.comp_apply, coeSubtype, coe_inclusion]\n\n"}
{"name":"SubgroupClass.subtype_comp_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_4\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nH K : S\nhH : LE.le H K\n⊢ Eq ((↑K).comp (SubgroupClass.inclusion hH)) ↑H","decl":"@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : S} (hH : H ≤ K) :\n    (SubgroupClass.subtype K).comp (inclusion hH) = SubgroupClass.subtype H := by\n  ext\n  simp only [MonoidHom.comp_apply, coeSubtype, coe_inclusion]\n\n"}
{"name":"Subgroup.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : SizeOf G\ntoSubmonoid : Submonoid G\ninv_mem' : ∀ {x : G}, Membership.mem toSubmonoid.carrier x → Membership.mem toSubmonoid.carrier (Inv.inv x)\n⊢ Eq (SizeOf.sizeOf { toSubmonoid := toSubmonoid, inv_mem' := inv_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubmonoid))","decl":"/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. -/\nstructure Subgroup (G : Type*) [Group G] extends Submonoid G where\n  /-- `G` is closed under inverses -/\n  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier\n\n"}
{"name":"Subgroup.mk.inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : Group G\ntoSubmonoid✝ : Submonoid G\ninv_mem'✝ : ∀ {x : G}, Membership.mem toSubmonoid✝.carrier x → Membership.mem toSubmonoid✝.carrier (Inv.inv x)\ntoSubmonoid : Submonoid G\ninv_mem' : ∀ {x : G}, Membership.mem toSubmonoid.carrier x → Membership.mem toSubmonoid.carrier (Inv.inv x)\nx✝ : Eq { toSubmonoid := toSubmonoid✝, inv_mem' := inv_mem'✝ } { toSubmonoid := toSubmonoid, inv_mem' := inv_mem' }\n⊢ Eq toSubmonoid✝ toSubmonoid","decl":"/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. -/\nstructure Subgroup (G : Type*) [Group G] extends Submonoid G where\n  /-- `G` is closed under inverses -/\n  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier\n\n"}
{"name":"Subgroup.mk.injEq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : Group G\ntoSubmonoid✝ : Submonoid G\ninv_mem'✝ : ∀ {x : G}, Membership.mem toSubmonoid✝.carrier x → Membership.mem toSubmonoid✝.carrier (Inv.inv x)\ntoSubmonoid : Submonoid G\ninv_mem' : ∀ {x : G}, Membership.mem toSubmonoid.carrier x → Membership.mem toSubmonoid.carrier (Inv.inv x)\n⊢ Eq (Eq { toSubmonoid := toSubmonoid✝, inv_mem' := inv_mem'✝ } { toSubmonoid := toSubmonoid, inv_mem' := inv_mem' }) (Eq toSubmonoid✝ toSubmonoid)","decl":"/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. -/\nstructure Subgroup (G : Type*) [Group G] extends Submonoid G where\n  /-- `G` is closed under inverses -/\n  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier\n\n"}
{"name":"Subgroup.inv_mem'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : Group G\nself : Subgroup G\nx : G\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (Inv.inv x)","decl":"/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication\nand closed under multiplicative inverse. -/\nstructure Subgroup (G : Type*) [Group G] extends Submonoid G where\n  /-- `G` is closed under inverses -/\n  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier\n\n"}
{"name":"AddSubgroup.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : SizeOf G\ntoAddSubmonoid : AddSubmonoid G\nneg_mem' : ∀ {x : G}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (Neg.neg x)\n⊢ Eq (SizeOf.sizeOf { toAddSubmonoid := toAddSubmonoid, neg_mem' := neg_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddSubmonoid))","decl":"/-- An additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. -/\nstructure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where\n  /-- `G` is closed under negation -/\n  neg_mem' {x} : x ∈ carrier → -x ∈ carrier\n\n"}
{"name":"AddSubgroup.neg_mem'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nself : AddSubgroup G\nx : G\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (Neg.neg x)","decl":"/-- An additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. -/\nstructure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where\n  /-- `G` is closed under negation -/\n  neg_mem' {x} : x ∈ carrier → -x ∈ carrier\n\n"}
{"name":"AddSubgroup.mk.injEq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ntoAddSubmonoid✝ : AddSubmonoid G\nneg_mem'✝ : ∀ {x : G}, Membership.mem toAddSubmonoid✝.carrier x → Membership.mem toAddSubmonoid✝.carrier (Neg.neg x)\ntoAddSubmonoid : AddSubmonoid G\nneg_mem' : ∀ {x : G}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (Neg.neg x)\n⊢ Eq (Eq { toAddSubmonoid := toAddSubmonoid✝, neg_mem' := neg_mem'✝ } { toAddSubmonoid := toAddSubmonoid, neg_mem' := neg_mem' }) (Eq toAddSubmonoid✝ toAddSubmonoid)","decl":"/-- An additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. -/\nstructure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where\n  /-- `G` is closed under negation -/\n  neg_mem' {x} : x ∈ carrier → -x ∈ carrier\n\n"}
{"name":"AddSubgroup.mk.inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\ntoAddSubmonoid✝ : AddSubmonoid G\nneg_mem'✝ : ∀ {x : G}, Membership.mem toAddSubmonoid✝.carrier x → Membership.mem toAddSubmonoid✝.carrier (Neg.neg x)\ntoAddSubmonoid : AddSubmonoid G\nneg_mem' : ∀ {x : G}, Membership.mem toAddSubmonoid.carrier x → Membership.mem toAddSubmonoid.carrier (Neg.neg x)\nx✝ : Eq { toAddSubmonoid := toAddSubmonoid✝, neg_mem' := neg_mem'✝ } { toAddSubmonoid := toAddSubmonoid, neg_mem' := neg_mem' }\n⊢ Eq toAddSubmonoid✝ toAddSubmonoid","decl":"/-- An additive subgroup of an additive group `G` is a subset containing 0, closed\nunder addition and additive inverse. -/\nstructure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where\n  /-- `G` is closed under negation -/\n  neg_mem' {x} : x ∈ carrier → -x ∈ carrier\n\n"}
{"name":"AddSubgroup.instAddSubgroupClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ AddSubgroupClass (AddSubgroup G) G","decl":"@[to_additive]\ninstance : SubgroupClass (Subgroup G) G where\n  inv_mem := Subgroup.inv_mem' _\n  one_mem _ := (Subgroup.toSubmonoid _).one_mem'\n  mul_mem := (Subgroup.toSubmonoid _).mul_mem'\n\n-- This is not a simp lemma,\n-- because the simp normal form left-hand side is given by `mem_toSubmonoid` below.\n"}
{"name":"Subgroup.instSubgroupClass","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ SubgroupClass (Subgroup G) G","decl":"@[to_additive]\ninstance : SubgroupClass (Subgroup G) G where\n  inv_mem := Subgroup.inv_mem' _\n  one_mem _ := (Subgroup.toSubmonoid _).one_mem'\n  mul_mem := (Subgroup.toSubmonoid _).mul_mem'\n\n-- This is not a simp lemma,\n-- because the simp normal form left-hand side is given by `mem_toSubmonoid` below.\n"}
{"name":"Subgroup.mem_carrier","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Subgroup G\nx : G\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"@[to_additive]\ntheorem mem_carrier {s : Subgroup G} {x : G} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_carrier","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"@[to_additive]\ntheorem mem_carrier {s : Subgroup G} {x : G} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\nx : G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HAdd.hAdd a b)\nh_mul : s 0\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier x → Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier (Neg.neg x)\n⊢ Iff (Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul, neg_mem' := h_inv } x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) :\n    x ∈ mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\nx : G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HMul.hMul a b)\nh_mul : s 1\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier x → Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier (Inv.inv x)\n⊢ Iff (Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul, inv_mem' := h_inv } x) (Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) :\n    x ∈ mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.coe_set_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HAdd.hAdd a b)\nh_mul : s 0\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier x → Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier (Neg.neg x)\n⊢ Eq (↑{ carrier := s, add_mem' := h_one, zero_mem' := h_mul, neg_mem' := h_inv }) s","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) :\n    (mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv : Set G) = s :=\n  rfl\n\n"}
{"name":"Subgroup.coe_set_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HMul.hMul a b)\nh_mul : s 1\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier x → Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier (Inv.inv x)\n⊢ Eq (↑{ carrier := s, mul_mem' := h_one, one_mem' := h_mul, inv_mem' := h_inv }) s","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) :\n    (mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv : Set G) = s :=\n  rfl\n\n"}
{"name":"AddSubgroup.mk_le_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns t : Set G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HAdd.hAdd a b)\nh_mul : s 0\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier x → Membership.mem { carrier := s, add_mem' := h_one, zero_mem' := h_mul }.carrier (Neg.neg x)\nh_one' : ∀ {a b : G}, Membership.mem t a → Membership.mem t b → Membership.mem t (HAdd.hAdd a b)\nh_mul' : t 0\nh_inv' : ∀ {x : G}, Membership.mem { carrier := t, add_mem' := h_one', zero_mem' := h_mul' }.carrier x → Membership.mem { carrier := t, add_mem' := h_one', zero_mem' := h_mul' }.carrier (Neg.neg x)\n⊢ Iff (LE.le { carrier := s, add_mem' := h_one, zero_mem' := h_mul, neg_mem' := h_inv } { carrier := t, add_mem' := h_one', zero_mem' := h_mul', neg_mem' := h_inv' }) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :\n    mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv ≤ mk ⟨⟨t, h_one'⟩, h_mul'⟩ h_inv' ↔ s ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mk_le_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\nh_one : ∀ {a b : G}, Membership.mem s a → Membership.mem s b → Membership.mem s (HMul.hMul a b)\nh_mul : s 1\nh_inv : ∀ {x : G}, Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier x → Membership.mem { carrier := s, mul_mem' := h_one, one_mem' := h_mul }.carrier (Inv.inv x)\nh_one' : ∀ {a b : G}, Membership.mem t a → Membership.mem t b → Membership.mem t (HMul.hMul a b)\nh_mul' : t 1\nh_inv' : ∀ {x : G}, Membership.mem { carrier := t, mul_mem' := h_one', one_mem' := h_mul' }.carrier x → Membership.mem { carrier := t, mul_mem' := h_one', one_mem' := h_mul' }.carrier (Inv.inv x)\n⊢ Iff (LE.le { carrier := s, mul_mem' := h_one, one_mem' := h_mul, inv_mem' := h_inv } { carrier := t, mul_mem' := h_one', one_mem' := h_mul', inv_mem' := h_inv' }) (HasSubset.Subset s t)","decl":"@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :\n    mk ⟨⟨s, h_one⟩, h_mul⟩ h_inv ≤ mk ⟨⟨t, h_one'⟩, h_mul'⟩ h_inv' ↔ s ⊆ t :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.coe_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\n⊢ Eq ↑K.toAddSubmonoid ↑K","decl":"@[to_additive (attr := simp)]\ntheorem coe_toSubmonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K :=\n  rfl\n\n"}
{"name":"Subgroup.coe_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\n⊢ Eq ↑K.toSubmonoid ↑K","decl":"@[to_additive (attr := simp)]\ntheorem coe_toSubmonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K :=\n  rfl\n\n"}
{"name":"AddSubgroup.mem_toAddSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem K.toAddSubmonoid x) (Membership.mem K x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_toSubmonoid (K : Subgroup G) (x : G) : x ∈ K.toSubmonoid ↔ x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_toSubmonoid","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nx : G\n⊢ Iff (Membership.mem K.toSubmonoid x) (Membership.mem K x)","decl":"@[to_additive (attr := simp)]\ntheorem mem_toSubmonoid (K : Subgroup G) (x : G) : x ∈ K.toSubmonoid ↔ x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.toSubmonoid_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Function.Injective Subgroup.toSubmonoid","decl":"@[to_additive]\ntheorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G → Submonoid G) :=\n  -- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)\n  fun p q h => by\n    have := SetLike.ext'_iff.1 h\n    rw [coe_toSubmonoid, coe_toSubmonoid] at this\n    exact SetLike.ext'_iff.2 this\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Function.Injective AddSubgroup.toAddSubmonoid","decl":"@[to_additive]\ntheorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G → Submonoid G) :=\n  -- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)\n  fun p q h => by\n    have := SetLike.ext'_iff.1 h\n    rw [coe_toSubmonoid, coe_toSubmonoid] at this\n    exact SetLike.ext'_iff.2 this\n\n"}
{"name":"Subgroup.toSubmonoid_inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\np q : Subgroup G\n⊢ Iff (Eq p.toSubmonoid q.toSubmonoid) (Eq p q)","decl":"@[to_additive (attr := simp)]\ntheorem toSubmonoid_inj {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid ↔ p = q :=\n  toSubmonoid_injective.eq_iff\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\np q : AddSubgroup G\n⊢ Iff (Eq p.toAddSubmonoid q.toAddSubmonoid) (Eq p q)","decl":"@[to_additive (attr := simp)]\ntheorem toSubmonoid_inj {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid ↔ p = q :=\n  toSubmonoid_injective.eq_iff\n\n"}
{"name":"Subgroup.toSubmonoid_eq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\np q : Subgroup G\n⊢ Iff (Eq p.toSubmonoid q.toSubmonoid) (Eq p q)","decl":"@[to_additive, deprecated (since := \"2024-12-29\")] alias toSubmonoid_eq := toSubmonoid_inj\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_eq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\np q : AddSubgroup G\n⊢ Iff (Eq p.toAddSubmonoid q.toAddSubmonoid) (Eq p q)","decl":"@[to_additive, deprecated (since := \"2024-12-29\")] alias toSubmonoid_eq := toSubmonoid_inj\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_strictMono","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ StrictMono AddSubgroup.toAddSubmonoid","decl":"@[to_additive (attr := mono)]\ntheorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subgroup G → Submonoid G) := fun _ _ =>\n  id\n\n"}
{"name":"Subgroup.toSubmonoid_strictMono","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ StrictMono Subgroup.toSubmonoid","decl":"@[to_additive (attr := mono)]\ntheorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subgroup G → Submonoid G) := fun _ _ =>\n  id\n\n"}
{"name":"Subgroup.toSubmonoid_mono","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Monotone Subgroup.toSubmonoid","decl":"@[to_additive (attr := mono)]\ntheorem toSubmonoid_mono : Monotone (toSubmonoid : Subgroup G → Submonoid G) :=\n  toSubmonoid_strictMono.monotone\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_mono","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Monotone AddSubgroup.toAddSubmonoid","decl":"@[to_additive (attr := mono)]\ntheorem toSubmonoid_mono : Monotone (toSubmonoid : Subgroup G → Submonoid G) :=\n  toSubmonoid_strictMono.monotone\n\n"}
{"name":"Subgroup.toSubmonoid_le","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\np q : Subgroup G\n⊢ Iff (LE.le p.toSubmonoid q.toSubmonoid) (LE.le p q)","decl":"@[to_additive (attr := simp)]\ntheorem toSubmonoid_le {p q : Subgroup G} : p.toSubmonoid ≤ q.toSubmonoid ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.toAddSubmonoid_le","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\np q : AddSubgroup G\n⊢ Iff (LE.le p.toAddSubmonoid q.toAddSubmonoid) (LE.le p q)","decl":"@[to_additive (attr := simp)]\ntheorem toSubmonoid_le {p q : Subgroup G} : p.toSubmonoid ≤ q.toSubmonoid ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.coe_nonempty","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Subgroup G\n⊢ (↑s).Nonempty","decl":"@[to_additive (attr := simp)]\nlemma coe_nonempty (s : Subgroup G) : (s : Set G).Nonempty := ⟨1, one_mem _⟩\n\n"}
{"name":"AddSubgroup.coe_nonempty","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : AddSubgroup G\n⊢ (↑s).Nonempty","decl":"@[to_additive (attr := simp)]\nlemma coe_nonempty (s : Subgroup G) : (s : Set G).Nonempty := ⟨1, one_mem _⟩\n\n"}
{"name":"Subgroup.coe_copy","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\ns : Set G\nhs : Eq s ↑K\n⊢ Eq (↑(K.copy s hs)) s","decl":"/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[to_additive (attr := simps)\n      \"Copy of an additive subgroup with a new `carrier` equal to the old one.\n      Useful to fix definitional equalities\"]\nprotected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G where\n  carrier := s\n  one_mem' := hs.symm ▸ K.one_mem'\n  mul_mem' := hs.symm ▸ K.mul_mem'\n  inv_mem' hx := by simpa [hs] using hx -- Porting note: `▸` didn't work here\n\n"}
{"name":"AddSubgroup.coe_copy","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\ns : Set G\nhs : Eq s ↑K\n⊢ Eq (↑(K.copy s hs)) s","decl":"/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional\nequalities. -/\n@[to_additive (attr := simps)\n      \"Copy of an additive subgroup with a new `carrier` equal to the old one.\n      Useful to fix definitional equalities\"]\nprotected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G where\n  carrier := s\n  one_mem' := hs.symm ▸ K.one_mem'\n  mul_mem' := hs.symm ▸ K.mul_mem'\n  inv_mem' hx := by simpa [hs] using hx -- Porting note: `▸` didn't work here\n\n"}
{"name":"AddSubgroup.copy_eq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\ns : Set G\nhs : Eq s ↑K\n⊢ Eq (K.copy s hs) K","decl":"@[to_additive]\ntheorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ↑K) : K.copy s hs = K :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Subgroup.copy_eq","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\ns : Set G\nhs : Eq s ↑K\n⊢ Eq (K.copy s hs) K","decl":"@[to_additive]\ntheorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ↑K) : K.copy s hs = K :=\n  SetLike.coe_injective hs\n\n"}
{"name":"Subgroup.ext_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (Eq H K) (∀ (x : G), Iff (Membership.mem H x) (Membership.mem K x))","decl":"/-- Two subgroups are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=\n  SetLike.ext h\n\n"}
{"name":"AddSubgroup.ext","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : ∀ (x : G), Iff (Membership.mem H x) (Membership.mem K x)\n⊢ Eq H K","decl":"/-- Two subgroups are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=\n  SetLike.ext h\n\n"}
{"name":"Subgroup.ext","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : ∀ (x : G), Iff (Membership.mem H x) (Membership.mem K x)\n⊢ Eq H K","decl":"/-- Two subgroups are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=\n  SetLike.ext h\n\n"}
{"name":"AddSubgroup.ext_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (Eq H K) (∀ (x : G), Iff (Membership.mem H x) (Membership.mem K x))","decl":"/-- Two subgroups are equal if they have the same elements. -/\n@[to_additive (attr := ext) \"Two `AddSubgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=\n  SetLike.ext h\n\n"}
{"name":"AddSubgroup.zero_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Membership.mem H 0","decl":"/-- A subgroup contains the group's 1. -/\n@[to_additive \"An `AddSubgroup` contains the group's 0.\"]\nprotected theorem one_mem : (1 : G) ∈ H :=\n  one_mem _\n\n"}
{"name":"Subgroup.one_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Membership.mem H 1","decl":"/-- A subgroup contains the group's 1. -/\n@[to_additive \"An `AddSubgroup` contains the group's 0.\"]\nprotected theorem one_mem : (1 : G) ∈ H :=\n  one_mem _\n\n"}
{"name":"AddSubgroup.add_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : G\na✝¹ : Membership.mem H x\na✝ : Membership.mem H y\n⊢ Membership.mem H (HAdd.hAdd x y)","decl":"/-- A subgroup is closed under multiplication. -/\n@[to_additive \"An `AddSubgroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : G} : x ∈ H → y ∈ H → x * y ∈ H :=\n  mul_mem\n\n"}
{"name":"Subgroup.mul_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : G\na✝¹ : Membership.mem H x\na✝ : Membership.mem H y\n⊢ Membership.mem H (HMul.hMul x y)","decl":"/-- A subgroup is closed under multiplication. -/\n@[to_additive \"An `AddSubgroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : G} : x ∈ H → y ∈ H → x * y ∈ H :=\n  mul_mem\n\n"}
{"name":"Subgroup.inv_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : G\na✝ : Membership.mem H x\n⊢ Membership.mem H (Inv.inv x)","decl":"/-- A subgroup is closed under inverse. -/\n@[to_additive \"An `AddSubgroup` is closed under inverse.\"]\nprotected theorem inv_mem {x : G} : x ∈ H → x⁻¹ ∈ H :=\n  inv_mem\n\n"}
{"name":"AddSubgroup.neg_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : G\na✝ : Membership.mem H x\n⊢ Membership.mem H (Neg.neg x)","decl":"/-- A subgroup is closed under inverse. -/\n@[to_additive \"An `AddSubgroup` is closed under inverse.\"]\nprotected theorem inv_mem {x : G} : x ∈ H → x⁻¹ ∈ H :=\n  inv_mem\n\n"}
{"name":"AddSubgroup.sub_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : G\nhx : Membership.mem H x\nhy : Membership.mem H y\n⊢ Membership.mem H (HSub.hSub x y)","decl":"/-- A subgroup is closed under division. -/\n@[to_additive \"An `AddSubgroup` is closed under subtraction.\"]\nprotected theorem div_mem {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H :=\n  div_mem hx hy\n\n"}
{"name":"Subgroup.div_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : G\nhx : Membership.mem H x\nhy : Membership.mem H y\n⊢ Membership.mem H (HDiv.hDiv x y)","decl":"/-- A subgroup is closed under division. -/\n@[to_additive \"An `AddSubgroup` is closed under subtraction.\"]\nprotected theorem div_mem {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H :=\n  div_mem hx hy\n\n"}
{"name":"AddSubgroup.neg_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem H (Neg.neg x)) (Membership.mem H x)","decl":"@[to_additive]\nprotected theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=\n  inv_mem_iff\n\n"}
{"name":"Subgroup.inv_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : G\n⊢ Iff (Membership.mem H (Inv.inv x)) (Membership.mem H x)","decl":"@[to_additive]\nprotected theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=\n  inv_mem_iff\n\n"}
{"name":"Subgroup.exists_inv_mem_iff_exists_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nP : G → Prop\n⊢ Iff (Exists fun x => And (Membership.mem K x) (P (Inv.inv x))) (Exists fun x => And (Membership.mem K x) (P x))","decl":"@[to_additive]\nprotected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G → Prop} :\n    (∃ x : G, x ∈ K ∧ P x⁻¹) ↔ ∃ x ∈ K, P x :=\n  exists_inv_mem_iff_exists_mem\n\n"}
{"name":"AddSubgroup.exists_neg_mem_iff_exists_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nP : G → Prop\n⊢ Iff (Exists fun x => And (Membership.mem K x) (P (Neg.neg x))) (Exists fun x => And (Membership.mem K x) (P x))","decl":"@[to_additive]\nprotected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G → Prop} :\n    (∃ x : G, x ∈ K ∧ P x⁻¹) ↔ ∃ x ∈ K, P x :=\n  exists_inv_mem_iff_exists_mem\n\n"}
{"name":"Subgroup.mul_mem_cancel_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HMul.hMul y x)) (Membership.mem H y)","decl":"@[to_additive]\nprotected theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_right h\n\n"}
{"name":"AddSubgroup.add_mem_cancel_right","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HAdd.hAdd y x)) (Membership.mem H y)","decl":"@[to_additive]\nprotected theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_right h\n\n"}
{"name":"AddSubgroup.add_mem_cancel_left","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HAdd.hAdd x y)) (Membership.mem H y)","decl":"@[to_additive]\nprotected theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_left h\n\n"}
{"name":"Subgroup.mul_mem_cancel_left","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : G\nh : Membership.mem H x\n⊢ Iff (Membership.mem H (HMul.hMul x y)) (Membership.mem H y)","decl":"@[to_additive]\nprotected theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=\n  mul_mem_cancel_left h\n\n"}
{"name":"AddSubgroup.nsmul_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nx : G\nhx : Membership.mem K x\nn : Nat\n⊢ Membership.mem K (HSMul.hSMul n x)","decl":"@[to_additive]\nprotected theorem pow_mem {x : G} (hx : x ∈ K) : ∀ n : ℕ, x ^ n ∈ K :=\n  pow_mem hx\n\n"}
{"name":"Subgroup.pow_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nx : G\nhx : Membership.mem K x\nn : Nat\n⊢ Membership.mem K (HPow.hPow x n)","decl":"@[to_additive]\nprotected theorem pow_mem {x : G} (hx : x ∈ K) : ∀ n : ℕ, x ^ n ∈ K :=\n  pow_mem hx\n\n"}
{"name":"AddSubgroup.zsmul_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : AddSubgroup G\nx : G\nhx : Membership.mem K x\nn : Int\n⊢ Membership.mem K (HSMul.hSMul n x)","decl":"@[to_additive]\nprotected theorem zpow_mem {x : G} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K :=\n  zpow_mem hx\n\n"}
{"name":"Subgroup.zpow_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nx : G\nhx : Membership.mem K x\nn : Int\n⊢ Membership.mem K (HPow.hPow x n)","decl":"@[to_additive]\nprotected theorem zpow_mem {x : G} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K :=\n  zpow_mem hx\n\n"}
{"name":"AddSubgroup.coe_add","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : H) : (↑(x * y) : G) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"Subgroup.coe_mul","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : H) : (↑(x * y) : G) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_zero","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (↑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : H) : G) = 1 :=\n  rfl\n\n"}
{"name":"Subgroup.coe_one","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (↑1) 1","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : H) : G) = 1 :=\n  rfl\n\n"}
{"name":"Subgroup.coe_inv","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_neg","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_sub","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (↑(x / y) : G) = ↑x / ↑y :=\n  rfl\n\n-- Porting note: removed simp, theorem has variable as head symbol\n"}
{"name":"Subgroup.coe_div","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx y : Subtype fun x => Membership.mem H x\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (↑(x / y) : G) = ↑x / ↑y :=\n  rfl\n\n-- Porting note: removed simp, theorem has variable as head symbol\n"}
{"name":"AddSubgroup.coe_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : G\nhx : Membership.mem H x\n⊢ Eq (↑⟨x, hx⟩) x","decl":"@[to_additive (attr := norm_cast)]\ntheorem coe_mk (x : G) (hx : x ∈ H) : ((⟨x, hx⟩ : H) : G) = x :=\n  rfl\n\n"}
{"name":"Subgroup.coe_mk","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : G\nhx : Membership.mem H x\n⊢ Eq (↑⟨x, hx⟩) x","decl":"@[to_additive (attr := norm_cast)]\ntheorem coe_mk (x : G) (hx : x ∈ H) : ((⟨x, hx⟩ : H) : G) = x :=\n  rfl\n\n"}
{"name":"Subgroup.coe_pow","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : Subtype fun x => Membership.mem H x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_nsmul","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : Subtype fun x => Membership.mem H x\nn : Nat\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"Subgroup.coe_zpow","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nx : Subtype fun x => Membership.mem H x\nn : Int\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[to_additive (attr := norm_cast)] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10685): dsimp can prove this\ntheorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_zsmul","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : Subtype fun x => Membership.mem H x\nn : Int\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[to_additive (attr := norm_cast)] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10685): dsimp can prove this\ntheorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = (x : G) ^ n :=\n  rfl\n\n"}
{"name":"AddSubgroup.mk_eq_zero","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\nh : Membership.mem H g\n⊢ Iff (Eq ⟨g, h⟩ 0) (Eq g 0)","decl":"@[to_additive (attr := simp)]\ntheorem mk_eq_one {g : G} {h} : (⟨g, h⟩ : H) = 1 ↔ g = 1 := Submonoid.mk_eq_one ..\n\n"}
{"name":"Subgroup.mk_eq_one","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\nh : Membership.mem H g\n⊢ Iff (Eq ⟨g, h⟩ 1) (Eq g 1)","decl":"@[to_additive (attr := simp)]\ntheorem mk_eq_one {g : G} {h} : (⟨g, h⟩ : H) = 1 ↔ g = 1 := Submonoid.mk_eq_one ..\n\n"}
{"name":"Subgroup.coeSubtype","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (⇑H.subtype) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coeSubtype : ⇑ H.subtype = ((↑) : H → G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coeSubtype","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (⇑H.subtype) Subtype.val","decl":"@[to_additive (attr := simp)]\ntheorem coeSubtype : ⇑ H.subtype = ((↑) : H → G) :=\n  rfl\n\n"}
{"name":"AddSubgroup.subtype_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Function.Injective ⇑H.subtype","decl":"@[to_additive]\ntheorem subtype_injective : Function.Injective (Subgroup.subtype H) :=\n  Subtype.coe_injective\n\n"}
{"name":"Subgroup.subtype_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Function.Injective ⇑H.subtype","decl":"@[to_additive]\ntheorem subtype_injective : Function.Injective (Subgroup.subtype H) :=\n  Subtype.coe_injective\n\n"}
{"name":"AddSubgroup.coe_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\na : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((AddSubgroup.inclusion h) a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : Subgroup G} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by\n  cases a\n  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]\n\n"}
{"name":"Subgroup.coe_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\na : Subtype fun x => Membership.mem H x\n⊢ Eq ↑((Subgroup.inclusion h) a) ↑a","decl":"@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : Subgroup G} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by\n  cases a\n  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]\n\n"}
{"name":"AddSubgroup.inclusion_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Function.Injective ⇑(AddSubgroup.inclusion h)","decl":"@[to_additive]\ntheorem inclusion_injective {H K : Subgroup G} (h : H ≤ K) : Function.Injective <| inclusion h :=\n  Set.inclusion_injective h\n\n"}
{"name":"Subgroup.inclusion_injective","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Function.Injective ⇑(Subgroup.inclusion h)","decl":"@[to_additive]\ntheorem inclusion_injective {H K : Subgroup G} (h : H ≤ K) : Function.Injective <| inclusion h :=\n  Set.inclusion_injective h\n\n"}
{"name":"AddSubgroup.inclusion_inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\nx y : Subtype fun x => Membership.mem H x\n⊢ Iff (Eq ((AddSubgroup.inclusion h) x) ((AddSubgroup.inclusion h) y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma inclusion_inj {H K : Subgroup G} (h : H ≤ K) {x y : H} :\n    inclusion h x = inclusion h y ↔ x = y :=\n  (inclusion_injective h).eq_iff\n\n"}
{"name":"Subgroup.inclusion_inj","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\nx y : Subtype fun x => Membership.mem H x\n⊢ Iff (Eq ((Subgroup.inclusion h) x) ((Subgroup.inclusion h) y)) (Eq x y)","decl":"@[to_additive (attr := simp)]\nlemma inclusion_inj {H K : Subgroup G} (h : H ≤ K) {x y : H} :\n    inclusion h x = inclusion h y ↔ x = y :=\n  (inclusion_injective h).eq_iff\n\n"}
{"name":"AddSubgroup.subtype_comp_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhH : LE.le H K\n⊢ Eq (K.subtype.comp (AddSubgroup.inclusion hH)) H.subtype","decl":"@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ≤ K) :\n    K.subtype.comp (inclusion hH) = H.subtype :=\n  rfl\n\n"}
{"name":"Subgroup.subtype_comp_inclusion","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : LE.le H K\n⊢ Eq (K.subtype.comp (Subgroup.inclusion hH)) H.subtype","decl":"@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ≤ K) :\n    K.subtype.comp (inclusion hH) = H.subtype :=\n  rfl\n\n"}
{"name":"Subgroup.Normal.conj_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nself : H.Normal\nn : G\na✝ : Membership.mem H n\ng : G\n⊢ Membership.mem H (HMul.hMul (HMul.hMul g n) (Inv.inv g))","decl":"/-- A subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` -/\nstructure Normal : Prop where\n  /-- `N` is closed under conjugation -/\n  conj_mem : ∀ n, n ∈ H → ∀ g : G, g * n * g⁻¹ ∈ H\n\n"}
{"name":"AddSubgroup.Normal.conj_mem","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"A : Type u_2\ninst✝ : AddGroup A\nH : AddSubgroup A\nself : H.Normal\nn : A\na✝ : Membership.mem H n\ng : A\n⊢ Membership.mem H (HAdd.hAdd (HAdd.hAdd g n) (Neg.neg g))","decl":"/-- An AddSubgroup is normal if whenever `n ∈ H`, then `g + n - g ∈ H` for every `g : G` -/\nstructure Normal (H : AddSubgroup A) : Prop where\n  /-- `N` is closed under additive conjugation -/\n  conj_mem : ∀ n, n ∈ H → ∀ g : A, g + n + -g ∈ H\n\n"}
{"name":"AddSubgroup.normal_of_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nH : AddSubgroup G\n⊢ H.Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_of_comm {G : Type*} [CommGroup G] (H : Subgroup G) : H.Normal :=\n  ⟨by simp [mul_comm, mul_left_comm]⟩\n\n"}
{"name":"Subgroup.normal_of_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nH : Subgroup G\n⊢ H.Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_of_comm {G : Type*} [CommGroup G] (H : Subgroup G) : H.Normal :=\n  ⟨by simp [mul_comm, mul_left_comm]⟩\n\n"}
{"name":"Subgroup.Normal.conj_mem'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nnH : H.Normal\nn : G\nhn : Membership.mem H n\ng : G\n⊢ Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv g) n) g)","decl":"@[to_additive]\ntheorem conj_mem' (nH : H.Normal) (n : G) (hn : n ∈ H) (g : G) :\n    g⁻¹ * n * g ∈ H := by\n  convert nH.conj_mem n hn g⁻¹\n  rw [inv_inv]\n\n"}
{"name":"AddSubgroup.Normal.conj_mem'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nnH : H.Normal\nn : G\nhn : Membership.mem H n\ng : G\n⊢ Membership.mem H (HAdd.hAdd (HAdd.hAdd (Neg.neg g) n) g)","decl":"@[to_additive]\ntheorem conj_mem' (nH : H.Normal) (n : G) (hn : n ∈ H) (g : G) :\n    g⁻¹ * n * g ∈ H := by\n  convert nH.conj_mem n hn g⁻¹\n  rw [inv_inv]\n\n"}
{"name":"Subgroup.Normal.mem_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nnH : H.Normal\na b : G\nh : Membership.mem H (HMul.hMul a b)\n⊢ Membership.mem H (HMul.hMul b a)","decl":"@[to_additive]\ntheorem mem_comm (nH : H.Normal) {a b : G} (h : a * b ∈ H) : b * a ∈ H := by\n  have : a⁻¹ * (a * b) * a⁻¹⁻¹ ∈ H := nH.conj_mem (a * b) h a⁻¹\n  -- Porting note: Previous code was:\n  -- simpa\n  simp_all only [inv_mul_cancel_left, inv_inv]\n\n"}
{"name":"AddSubgroup.Normal.mem_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nnH : H.Normal\na b : G\nh : Membership.mem H (HAdd.hAdd a b)\n⊢ Membership.mem H (HAdd.hAdd b a)","decl":"@[to_additive]\ntheorem mem_comm (nH : H.Normal) {a b : G} (h : a * b ∈ H) : b * a ∈ H := by\n  have : a⁻¹ * (a * b) * a⁻¹⁻¹ ∈ H := nH.conj_mem (a * b) h a⁻¹\n  -- Porting note: Previous code was:\n  -- simpa\n  simp_all only [inv_mul_cancel_left, inv_inv]\n\n"}
{"name":"AddSubgroup.Normal.mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nnH : H.Normal\na b : G\n⊢ Iff (Membership.mem H (HAdd.hAdd a b)) (Membership.mem H (HAdd.hAdd b a))","decl":"@[to_additive]\ntheorem mem_comm_iff (nH : H.Normal) {a b : G} : a * b ∈ H ↔ b * a ∈ H :=\n  ⟨nH.mem_comm, nH.mem_comm⟩\n\n"}
{"name":"Subgroup.Normal.mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nnH : H.Normal\na b : G\n⊢ Iff (Membership.mem H (HMul.hMul a b)) (Membership.mem H (HMul.hMul b a))","decl":"@[to_additive]\ntheorem mem_comm_iff (nH : H.Normal) {a b : G} : a * b ∈ H ↔ b * a ∈ H :=\n  ⟨nH.mem_comm, nH.mem_comm⟩\n\n"}
{"name":"Subgroup.mem_normalizer_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (h : G), Iff (Membership.mem H h) (Membership.mem H (HMul.hMul (HMul.hMul g h) (Inv.inv g))))","decl":"@[to_additive]\ntheorem mem_normalizer_iff {g : G} : g ∈ H.normalizer ↔ ∀ h, h ∈ H ↔ g * h * g⁻¹ ∈ H :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_normalizer_iff","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (h : G), Iff (Membership.mem H h) (Membership.mem H (HAdd.hAdd (HAdd.hAdd g h) (Neg.neg g))))","decl":"@[to_additive]\ntheorem mem_normalizer_iff {g : G} : g ∈ H.normalizer ↔ ∀ h, h ∈ H ↔ g * h * g⁻¹ ∈ H :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.mem_normalizer_iff''","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (h : G), Iff (Membership.mem H h) (Membership.mem H (HMul.hMul (HMul.hMul (Inv.inv g) h) g)))","decl":"@[to_additive]\ntheorem mem_normalizer_iff'' {g : G} : g ∈ H.normalizer ↔ ∀ h : G, h ∈ H ↔ g⁻¹ * h * g ∈ H := by\n  rw [← inv_mem_iff (x := g), mem_normalizer_iff, inv_inv]\n\n"}
{"name":"AddSubgroup.mem_normalizer_iff''","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (h : G), Iff (Membership.mem H h) (Membership.mem H (HAdd.hAdd (HAdd.hAdd (Neg.neg g) h) g)))","decl":"@[to_additive]\ntheorem mem_normalizer_iff'' {g : G} : g ∈ H.normalizer ↔ ∀ h : G, h ∈ H ↔ g⁻¹ * h * g ∈ H := by\n  rw [← inv_mem_iff (x := g), mem_normalizer_iff, inv_inv]\n\n"}
{"name":"Subgroup.mem_normalizer_iff'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (n : G), Iff (Membership.mem H (HMul.hMul n g)) (Membership.mem H (HMul.hMul g n)))","decl":"@[to_additive]\ntheorem mem_normalizer_iff' {g : G} : g ∈ H.normalizer ↔ ∀ n, n * g ∈ H ↔ g * n ∈ H :=\n  ⟨fun h n => by rw [h, mul_assoc, mul_inv_cancel_right], fun h n => by\n    rw [mul_assoc, ← h, inv_mul_cancel_right]⟩\n\n"}
{"name":"AddSubgroup.mem_normalizer_iff'","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\ng : G\n⊢ Iff (Membership.mem H.normalizer g) (∀ (n : G), Iff (Membership.mem H (HAdd.hAdd n g)) (Membership.mem H (HAdd.hAdd g n)))","decl":"@[to_additive]\ntheorem mem_normalizer_iff' {g : G} : g ∈ H.normalizer ↔ ∀ n, n * g ∈ H ↔ g * n ∈ H :=\n  ⟨fun h n => by rw [h, mul_assoc, mul_inv_cancel_right], fun h n => by\n    rw [mul_assoc, ← h, inv_mul_cancel_right]⟩\n\n"}
{"name":"Subgroup.le_normalizer","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ LE.le H H.normalizer","decl":"@[to_additive]\ntheorem le_normalizer : H ≤ normalizer H := fun x xH n => by\n  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]\n\n"}
{"name":"AddSubgroup.le_normalizer","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ LE.le H H.normalizer","decl":"@[to_additive]\ntheorem le_normalizer : H ≤ normalizer H := fun x xH n => by\n  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]\n\n"}
{"name":"Subgroup.IsCommutative.is_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nself : H.IsCommutative\n⊢ Std.Commutative fun x1 x2 => HMul.hMul x1 x2","decl":"/-- Commutativity of a subgroup -/\nstructure IsCommutative : Prop where\n  /-- `*` is commutative on `H` -/\n  is_comm : Std.Commutative (α := H) (· * ·)\n\n"}
{"name":"AddSubgroup.IsCommutative.is_comm","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"A : Type u_2\ninst✝ : AddGroup A\nH : AddSubgroup A\nself : H.IsCommutative\n⊢ Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2","decl":"/-- Commutativity of an additive subgroup -/\nstructure _root_.AddSubgroup.IsCommutative (H : AddSubgroup A) : Prop where\n  /-- `+` is commutative on `H` -/\n  is_comm : Std.Commutative (α := H) (· + ·)\n\n"}
{"name":"Subgroup.commGroup_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\nH : Subgroup G\n⊢ H.IsCommutative","decl":"/-- A subgroup of a commutative group is commutative. -/\n@[to_additive \"A subgroup of a commutative group is commutative.\"]\ninstance commGroup_isCommutative {G : Type*} [CommGroup G] (H : Subgroup G) : H.IsCommutative :=\n  ⟨CommMagma.to_isCommutative⟩\n\n"}
{"name":"AddSubgroup.addCommGroup_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\nH : AddSubgroup G\n⊢ H.IsCommutative","decl":"/-- A subgroup of a commutative group is commutative. -/\n@[to_additive \"A subgroup of a commutative group is commutative.\"]\ninstance commGroup_isCommutative {G : Type*} [CommGroup G] (H : Subgroup G) : H.IsCommutative :=\n  ⟨CommMagma.to_isCommutative⟩\n\n"}
{"name":"AddSubgroup.add_comm_of_mem_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : H.IsCommutative\na b : G\nha : Membership.mem H a\nhb : Membership.mem H b\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"@[to_additive]\nlemma mul_comm_of_mem_isCommutative [H.IsCommutative] {a b : G} (ha : a ∈ H) (hb : b ∈ H) :\n    a * b = b * a := by\n  simpa only [MulMemClass.mk_mul_mk, Subtype.mk.injEq] using mul_comm (⟨a, ha⟩ : H) (⟨b, hb⟩ : H)\n\n"}
{"name":"Subgroup.mul_comm_of_mem_isCommutative","module":"Mathlib.Algebra.Group.Subgroup.Defs","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.IsCommutative\na b : G\nha : Membership.mem H a\nhb : Membership.mem H b\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"@[to_additive]\nlemma mul_comm_of_mem_isCommutative [H.IsCommutative] {a b : G} (ha : a ∈ H) (hb : b ∈ H) :\n    a * b = b * a := by\n  simpa only [MulMemClass.mk_mul_mk, Subtype.mk.injEq] using mul_comm (⟨a, ha⟩ : H) (⟨b, hb⟩ : H)\n\n"}
