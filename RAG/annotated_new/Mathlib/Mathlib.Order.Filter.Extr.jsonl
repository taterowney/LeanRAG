{"name":"IsExtrOn.elim","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\np : Prop\na✝² : IsExtrOn f s a\na✝¹ : IsMinOn f s a → p\na✝ : IsMaxOn f s a → p\n⊢ p","decl":"theorem IsExtrOn.elim {p : Prop} : IsExtrOn f s a → (IsMinOn f s a → p) → (IsMaxOn f s a → p) → p :=\n  Or.elim\n\n"}
{"name":"isMinOn_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (IsMinOn f s a) (∀ (x : α), Membership.mem s x → LE.le (f a) (f x))","decl":"theorem isMinOn_iff : IsMinOn f s a ↔ ∀ x ∈ s, f a ≤ f x :=\n  Iff.rfl\n\n"}
{"name":"isMaxOn_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (IsMaxOn f s a) (∀ (x : α), Membership.mem s x → LE.le (f x) (f a))","decl":"theorem isMaxOn_iff : IsMaxOn f s a ↔ ∀ x ∈ s, f x ≤ f a :=\n  Iff.rfl\n\n"}
{"name":"isMinOn_univ_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\na : α\n⊢ Iff (IsMinOn f Set.univ a) (∀ (x : α), LE.le (f a) (f x))","decl":"theorem isMinOn_univ_iff : IsMinOn f univ a ↔ ∀ x, f a ≤ f x :=\n  univ_subset_iff.trans eq_univ_iff_forall\n\n"}
{"name":"isMaxOn_univ_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\na : α\n⊢ Iff (IsMaxOn f Set.univ a) (∀ (x : α), LE.le (f x) (f a))","decl":"theorem isMaxOn_univ_iff : IsMaxOn f univ a ↔ ∀ x, f x ≤ f a :=\n  univ_subset_iff.trans eq_univ_iff_forall\n\n"}
{"name":"IsMinFilter.tendsto_principal_Ici","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nh : IsMinFilter f l a\n⊢ Filter.Tendsto f l (Filter.principal (Set.Ici (f a)))","decl":"theorem IsMinFilter.tendsto_principal_Ici (h : IsMinFilter f l a) : Tendsto f l (𝓟 <| Ici (f a)) :=\n  tendsto_principal.2 h\n\n"}
{"name":"IsMaxFilter.tendsto_principal_Iic","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nh : IsMaxFilter f l a\n⊢ Filter.Tendsto f l (Filter.principal (Set.Iic (f a)))","decl":"theorem IsMaxFilter.tendsto_principal_Iic (h : IsMaxFilter f l a) : Tendsto f l (𝓟 <| Iic (f a)) :=\n  tendsto_principal.2 h\n\n"}
{"name":"IsMinFilter.isExtr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMinFilter f l a\n⊢ IsExtrFilter f l a","decl":"theorem IsMinFilter.isExtr : IsMinFilter f l a → IsExtrFilter f l a :=\n  Or.inl\n\n"}
{"name":"IsMaxFilter.isExtr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMaxFilter f l a\n⊢ IsExtrFilter f l a","decl":"theorem IsMaxFilter.isExtr : IsMaxFilter f l a → IsExtrFilter f l a :=\n  Or.inr\n\n"}
{"name":"IsMinOn.isExtr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nh : IsMinOn f s a\n⊢ IsExtrOn f s a","decl":"theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a :=\n  IsMinFilter.isExtr h\n\n"}
{"name":"IsMaxOn.isExtr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nh : IsMaxOn f s a\n⊢ IsExtrOn f s a","decl":"theorem IsMaxOn.isExtr (h : IsMaxOn f s a) : IsExtrOn f s a :=\n  IsMaxFilter.isExtr h\n\n"}
{"name":"isMinFilter_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\na : α\nb : β\n⊢ IsMinFilter (fun x => b) l a","decl":"theorem isMinFilter_const {b : β} : IsMinFilter (fun _ => b) l a :=\n  univ_mem' fun _ => le_rfl\n\n"}
{"name":"isMaxFilter_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\na : α\nb : β\n⊢ IsMaxFilter (fun x => b) l a","decl":"theorem isMaxFilter_const {b : β} : IsMaxFilter (fun _ => b) l a :=\n  univ_mem' fun _ => le_rfl\n\n"}
{"name":"isExtrFilter_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nl : Filter α\na : α\nb : β\n⊢ IsExtrFilter (fun x => b) l a","decl":"theorem isExtrFilter_const {b : β} : IsExtrFilter (fun _ => b) l a :=\n  isMinFilter_const.isExtr\n\n"}
{"name":"isMinOn_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\ns : Set α\na : α\nb : β\n⊢ IsMinOn (fun x => b) s a","decl":"theorem isMinOn_const {b : β} : IsMinOn (fun _ => b) s a :=\n  isMinFilter_const\n\n"}
{"name":"isMaxOn_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\ns : Set α\na : α\nb : β\n⊢ IsMaxOn (fun x => b) s a","decl":"theorem isMaxOn_const {b : β} : IsMaxOn (fun _ => b) s a :=\n  isMaxFilter_const\n\n"}
{"name":"isExtrOn_const","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\ns : Set α\na : α\nb : β\n⊢ IsExtrOn (fun x => b) s a","decl":"theorem isExtrOn_const {b : β} : IsExtrOn (fun _ => b) s a :=\n  isExtrFilter_const\n\n"}
{"name":"isMinFilter_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\n⊢ Iff (IsMinFilter (Function.comp (⇑OrderDual.toDual) f) l a) (IsMaxFilter f l a)","decl":"theorem isMinFilter_dual_iff : IsMinFilter (toDual ∘ f) l a ↔ IsMaxFilter f l a :=\n  Iff.rfl\n\n"}
{"name":"isMaxFilter_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\n⊢ Iff (IsMaxFilter (Function.comp (⇑OrderDual.toDual) f) l a) (IsMinFilter f l a)","decl":"theorem isMaxFilter_dual_iff : IsMaxFilter (toDual ∘ f) l a ↔ IsMinFilter f l a :=\n  Iff.rfl\n\n"}
{"name":"isExtrFilter_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\n⊢ Iff (IsExtrFilter (Function.comp (⇑OrderDual.toDual) f) l a) (IsExtrFilter f l a)","decl":"theorem isExtrFilter_dual_iff : IsExtrFilter (toDual ∘ f) l a ↔ IsExtrFilter f l a :=\n  or_comm\n\n"}
{"name":"IsMaxFilter.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMaxFilter f l a\n⊢ IsMinFilter (Function.comp (⇑OrderDual.toDual) f) l a","decl":"alias ⟨IsMinFilter.undual, IsMaxFilter.dual⟩ := isMinFilter_dual_iff\n\n"}
{"name":"IsMinFilter.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMinFilter (Function.comp (⇑OrderDual.toDual) f) l a\n⊢ IsMaxFilter f l a","decl":"alias ⟨IsMinFilter.undual, IsMaxFilter.dual⟩ := isMinFilter_dual_iff\n\n"}
{"name":"IsMinFilter.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMinFilter f l a\n⊢ IsMaxFilter (Function.comp (⇑OrderDual.toDual) f) l a","decl":"alias ⟨IsMaxFilter.undual, IsMinFilter.dual⟩ := isMaxFilter_dual_iff\n\n"}
{"name":"IsMaxFilter.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsMaxFilter (Function.comp (⇑OrderDual.toDual) f) l a\n⊢ IsMinFilter f l a","decl":"alias ⟨IsMaxFilter.undual, IsMinFilter.dual⟩ := isMaxFilter_dual_iff\n\n"}
{"name":"IsExtrFilter.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsExtrFilter (Function.comp (⇑OrderDual.toDual) f) l a\n⊢ IsExtrFilter f l a","decl":"alias ⟨IsExtrFilter.undual, IsExtrFilter.dual⟩ := isExtrFilter_dual_iff\n\n"}
{"name":"IsExtrFilter.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\na✝ : IsExtrFilter f l a\n⊢ IsExtrFilter (Function.comp (⇑OrderDual.toDual) f) l a","decl":"alias ⟨IsExtrFilter.undual, IsExtrFilter.dual⟩ := isExtrFilter_dual_iff\n\n"}
{"name":"isMinOn_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (IsMinOn (Function.comp (⇑OrderDual.toDual) f) s a) (IsMaxOn f s a)","decl":"theorem isMinOn_dual_iff : IsMinOn (toDual ∘ f) s a ↔ IsMaxOn f s a :=\n  Iff.rfl\n\n"}
{"name":"isMaxOn_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (IsMaxOn (Function.comp (⇑OrderDual.toDual) f) s a) (IsMinOn f s a)","decl":"theorem isMaxOn_dual_iff : IsMaxOn (toDual ∘ f) s a ↔ IsMinOn f s a :=\n  Iff.rfl\n\n"}
{"name":"isExtrOn_dual_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\n⊢ Iff (IsExtrOn (Function.comp (⇑OrderDual.toDual) f) s a) (IsExtrOn f s a)","decl":"theorem isExtrOn_dual_iff : IsExtrOn (toDual ∘ f) s a ↔ IsExtrOn f s a :=\n  or_comm\n\n"}
{"name":"IsMinOn.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsMinOn (Function.comp (⇑OrderDual.toDual) f) s a\n⊢ IsMaxOn f s a","decl":"alias ⟨IsMinOn.undual, IsMaxOn.dual⟩ := isMinOn_dual_iff\n\n"}
{"name":"IsMaxOn.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsMaxOn f s a\n⊢ IsMinOn (Function.comp (⇑OrderDual.toDual) f) s a","decl":"alias ⟨IsMinOn.undual, IsMaxOn.dual⟩ := isMinOn_dual_iff\n\n"}
{"name":"IsMaxOn.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsMaxOn (Function.comp (⇑OrderDual.toDual) f) s a\n⊢ IsMinOn f s a","decl":"alias ⟨IsMaxOn.undual, IsMinOn.dual⟩ := isMaxOn_dual_iff\n\n"}
{"name":"IsMinOn.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsMinOn f s a\n⊢ IsMaxOn (Function.comp (⇑OrderDual.toDual) f) s a","decl":"alias ⟨IsMaxOn.undual, IsMinOn.dual⟩ := isMaxOn_dual_iff\n\n"}
{"name":"IsExtrOn.undual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsExtrOn (Function.comp (⇑OrderDual.toDual) f) s a\n⊢ IsExtrOn f s a","decl":"alias ⟨IsExtrOn.undual, IsExtrOn.dual⟩ := isExtrOn_dual_iff\n\n"}
{"name":"IsExtrOn.dual","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\na✝ : IsExtrOn f s a\n⊢ IsExtrOn (Function.comp (⇑OrderDual.toDual) f) s a","decl":"alias ⟨IsExtrOn.undual, IsExtrOn.dual⟩ := isExtrOn_dual_iff\n\n"}
{"name":"IsMinFilter.filter_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nl' : Filter α\nh : IsMinFilter f l a\nhl : LE.le l' l\n⊢ IsMinFilter f l' a","decl":"theorem IsMinFilter.filter_mono (h : IsMinFilter f l a) (hl : l' ≤ l) : IsMinFilter f l' a :=\n  hl h\n\n"}
{"name":"IsMaxFilter.filter_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nl' : Filter α\nh : IsMaxFilter f l a\nhl : LE.le l' l\n⊢ IsMaxFilter f l' a","decl":"theorem IsMaxFilter.filter_mono (h : IsMaxFilter f l a) (hl : l' ≤ l) : IsMaxFilter f l' a :=\n  hl h\n\n"}
{"name":"IsExtrFilter.filter_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nl' : Filter α\nh : IsExtrFilter f l a\nhl : LE.le l' l\n⊢ IsExtrFilter f l' a","decl":"theorem IsExtrFilter.filter_mono (h : IsExtrFilter f l a) (hl : l' ≤ l) : IsExtrFilter f l' a :=\n  h.elim (fun h => (h.filter_mono hl).isExtr) fun h => (h.filter_mono hl).isExtr\n\n"}
{"name":"IsMinFilter.filter_inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nh : IsMinFilter f l a\nl' : Filter α\n⊢ IsMinFilter f (Min.min l l') a","decl":"theorem IsMinFilter.filter_inf (h : IsMinFilter f l a) (l') : IsMinFilter f (l ⊓ l') a :=\n  h.filter_mono inf_le_left\n\n"}
{"name":"IsMaxFilter.filter_inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nh : IsMaxFilter f l a\nl' : Filter α\n⊢ IsMaxFilter f (Min.min l l') a","decl":"theorem IsMaxFilter.filter_inf (h : IsMaxFilter f l a) (l') : IsMaxFilter f (l ⊓ l') a :=\n  h.filter_mono inf_le_left\n\n"}
{"name":"IsExtrFilter.filter_inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\nl : Filter α\na : α\nh : IsExtrFilter f l a\nl' : Filter α\n⊢ IsExtrFilter f (Min.min l l') a","decl":"theorem IsExtrFilter.filter_inf (h : IsExtrFilter f l a) (l') : IsExtrFilter f (l ⊓ l') a :=\n  h.filter_mono inf_le_left\n\n"}
{"name":"IsMinOn.on_subset","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set α\nhf : IsMinOn f t a\nh : HasSubset.Subset s t\n⊢ IsMinOn f s a","decl":"theorem IsMinOn.on_subset (hf : IsMinOn f t a) (h : s ⊆ t) : IsMinOn f s a :=\n  hf.filter_mono <| principal_mono.2 h\n\n"}
{"name":"IsMaxOn.on_subset","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set α\nhf : IsMaxOn f t a\nh : HasSubset.Subset s t\n⊢ IsMaxOn f s a","decl":"theorem IsMaxOn.on_subset (hf : IsMaxOn f t a) (h : s ⊆ t) : IsMaxOn f s a :=\n  hf.filter_mono <| principal_mono.2 h\n\n"}
{"name":"IsExtrOn.on_subset","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set α\nhf : IsExtrOn f t a\nh : HasSubset.Subset s t\n⊢ IsExtrOn f s a","decl":"theorem IsExtrOn.on_subset (hf : IsExtrOn f t a) (h : s ⊆ t) : IsExtrOn f s a :=\n  hf.filter_mono <| principal_mono.2 h\n\n"}
{"name":"IsMinOn.inter","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nhf : IsMinOn f s a\nt : Set α\n⊢ IsMinOn f (Inter.inter s t) a","decl":"theorem IsMinOn.inter (hf : IsMinOn f s a) (t) : IsMinOn f (s ∩ t) a :=\n  hf.on_subset inter_subset_left\n\n"}
{"name":"IsMaxOn.inter","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nhf : IsMaxOn f s a\nt : Set α\n⊢ IsMaxOn f (Inter.inter s t) a","decl":"theorem IsMaxOn.inter (hf : IsMaxOn f s a) (t) : IsMaxOn f (s ∩ t) a :=\n  hf.on_subset inter_subset_left\n\n"}
{"name":"IsExtrOn.inter","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nhf : IsExtrOn f s a\nt : Set α\n⊢ IsExtrOn f (Inter.inter s t) a","decl":"theorem IsExtrOn.inter (hf : IsExtrOn f s a) (t) : IsExtrOn f (s ∩ t) a :=\n  hf.on_subset inter_subset_left\n\n"}
{"name":"IsMinFilter.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsMinFilter f l a\ng : β → γ\nhg : Monotone g\n⊢ IsMinFilter (Function.comp g f) l a","decl":"theorem IsMinFilter.comp_mono (hf : IsMinFilter f l a) {g : β → γ} (hg : Monotone g) :\n    IsMinFilter (g ∘ f) l a :=\n  mem_of_superset hf fun _x hx => hg hx\n\n"}
{"name":"IsMaxFilter.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsMaxFilter f l a\ng : β → γ\nhg : Monotone g\n⊢ IsMaxFilter (Function.comp g f) l a","decl":"theorem IsMaxFilter.comp_mono (hf : IsMaxFilter f l a) {g : β → γ} (hg : Monotone g) :\n    IsMaxFilter (g ∘ f) l a :=\n  mem_of_superset hf fun _x hx => hg hx\n\n"}
{"name":"IsExtrFilter.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsExtrFilter f l a\ng : β → γ\nhg : Monotone g\n⊢ IsExtrFilter (Function.comp g f) l a","decl":"theorem IsExtrFilter.comp_mono (hf : IsExtrFilter f l a) {g : β → γ} (hg : Monotone g) :\n    IsExtrFilter (g ∘ f) l a :=\n  hf.elim (fun hf => (hf.comp_mono hg).isExtr) fun hf => (hf.comp_mono hg).isExtr\n\n"}
{"name":"IsMinFilter.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsMinFilter f l a\ng : β → γ\nhg : Antitone g\n⊢ IsMaxFilter (Function.comp g f) l a","decl":"theorem IsMinFilter.comp_antitone (hf : IsMinFilter f l a) {g : β → γ} (hg : Antitone g) :\n    IsMaxFilter (g ∘ f) l a :=\n  hf.dual.comp_mono fun _ _ h => hg h\n\n"}
{"name":"IsMaxFilter.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsMaxFilter f l a\ng : β → γ\nhg : Antitone g\n⊢ IsMinFilter (Function.comp g f) l a","decl":"theorem IsMaxFilter.comp_antitone (hf : IsMaxFilter f l a) {g : β → γ} (hg : Antitone g) :\n    IsMinFilter (g ∘ f) l a :=\n  hf.dual.comp_mono fun _ _ h => hg h\n\n"}
{"name":"IsExtrFilter.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\nl : Filter α\na : α\nhf : IsExtrFilter f l a\ng : β → γ\nhg : Antitone g\n⊢ IsExtrFilter (Function.comp g f) l a","decl":"theorem IsExtrFilter.comp_antitone (hf : IsExtrFilter f l a) {g : β → γ} (hg : Antitone g) :\n    IsExtrFilter (g ∘ f) l a :=\n  hf.dual.comp_mono fun _ _ h => hg h\n\n"}
{"name":"IsMinOn.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsMinOn f s a\ng : β → γ\nhg : Monotone g\n⊢ IsMinOn (Function.comp g f) s a","decl":"theorem IsMinOn.comp_mono (hf : IsMinOn f s a) {g : β → γ} (hg : Monotone g) :\n    IsMinOn (g ∘ f) s a :=\n  IsMinFilter.comp_mono hf hg\n\n"}
{"name":"IsMaxOn.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsMaxOn f s a\ng : β → γ\nhg : Monotone g\n⊢ IsMaxOn (Function.comp g f) s a","decl":"theorem IsMaxOn.comp_mono (hf : IsMaxOn f s a) {g : β → γ} (hg : Monotone g) :\n    IsMaxOn (g ∘ f) s a :=\n  IsMaxFilter.comp_mono hf hg\n\n"}
{"name":"IsExtrOn.comp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsExtrOn f s a\ng : β → γ\nhg : Monotone g\n⊢ IsExtrOn (Function.comp g f) s a","decl":"theorem IsExtrOn.comp_mono (hf : IsExtrOn f s a) {g : β → γ} (hg : Monotone g) :\n    IsExtrOn (g ∘ f) s a :=\n  IsExtrFilter.comp_mono hf hg\n\n"}
{"name":"IsMinOn.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsMinOn f s a\ng : β → γ\nhg : Antitone g\n⊢ IsMaxOn (Function.comp g f) s a","decl":"theorem IsMinOn.comp_antitone (hf : IsMinOn f s a) {g : β → γ} (hg : Antitone g) :\n    IsMaxOn (g ∘ f) s a :=\n  IsMinFilter.comp_antitone hf hg\n\n"}
{"name":"IsMaxOn.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsMaxOn f s a\ng : β → γ\nhg : Antitone g\n⊢ IsMinOn (Function.comp g f) s a","decl":"theorem IsMaxOn.comp_antitone (hf : IsMaxOn f s a) {g : β → γ} (hg : Antitone g) :\n    IsMinOn (g ∘ f) s a :=\n  IsMaxFilter.comp_antitone hf hg\n\n"}
{"name":"IsExtrOn.comp_antitone","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\nf : α → β\ns : Set α\na : α\nhf : IsExtrOn f s a\ng : β → γ\nhg : Antitone g\n⊢ IsExtrOn (Function.comp g f) s a","decl":"theorem IsExtrOn.comp_antitone (hf : IsExtrOn f s a) {g : β → γ} (hg : Antitone g) :\n    IsExtrOn (g ∘ f) s a :=\n  IsExtrFilter.comp_antitone hf hg\n\n"}
{"name":"IsMinFilter.bicomp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type x\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\nf : α → β\nl : Filter α\na : α\ninst✝ : Preorder δ\nop : β → γ → δ\nhop : Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) op op\nhf : IsMinFilter f l a\ng : α → γ\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => op (f x) (g x)) l a","decl":"theorem IsMinFilter.bicomp_mono [Preorder δ] {op : β → γ → δ}\n    (hop : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) op op) (hf : IsMinFilter f l a) {g : α → γ}\n    (hg : IsMinFilter g l a) : IsMinFilter (fun x => op (f x) (g x)) l a :=\n  mem_of_superset (inter_mem hf hg) fun _x ⟨hfx, hgx⟩ => hop hfx hgx\n\n"}
{"name":"IsMaxFilter.bicomp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type x\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\nf : α → β\nl : Filter α\na : α\ninst✝ : Preorder δ\nop : β → γ → δ\nhop : Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) op op\nhf : IsMaxFilter f l a\ng : α → γ\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => op (f x) (g x)) l a","decl":"theorem IsMaxFilter.bicomp_mono [Preorder δ] {op : β → γ → δ}\n    (hop : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) op op) (hf : IsMaxFilter f l a) {g : α → γ}\n    (hg : IsMaxFilter g l a) : IsMaxFilter (fun x => op (f x) (g x)) l a :=\n  mem_of_superset (inter_mem hf hg) fun _x ⟨hfx, hgx⟩ => hop hfx hgx\n\n-- No `Extr` version because we need `hf` and `hg` to be of the same kind\n"}
{"name":"IsMinOn.bicomp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type x\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\nf : α → β\ns : Set α\na : α\ninst✝ : Preorder δ\nop : β → γ → δ\nhop : Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) op op\nhf : IsMinOn f s a\ng : α → γ\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => op (f x) (g x)) s a","decl":"theorem IsMinOn.bicomp_mono [Preorder δ] {op : β → γ → δ}\n    (hop : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) op op) (hf : IsMinOn f s a) {g : α → γ}\n    (hg : IsMinOn g s a) : IsMinOn (fun x => op (f x) (g x)) s a :=\n  IsMinFilter.bicomp_mono hop hf hg\n\n"}
{"name":"IsMaxOn.bicomp_mono","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type x\ninst✝² : Preorder β\ninst✝¹ : Preorder γ\nf : α → β\ns : Set α\na : α\ninst✝ : Preorder δ\nop : β → γ → δ\nhop : Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) op op\nhf : IsMaxOn f s a\ng : α → γ\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => op (f x) (g x)) s a","decl":"theorem IsMaxOn.bicomp_mono [Preorder δ] {op : β → γ → δ}\n    (hop : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) op op) (hf : IsMaxOn f s a) {g : α → γ}\n    (hg : IsMaxOn g s a) : IsMaxOn (fun x => op (f x) (g x)) s a :=\n  IsMaxFilter.bicomp_mono hop hf hg\n\n"}
{"name":"IsMinFilter.comp_tendsto","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\nl : Filter α\ng : δ → α\nl' : Filter δ\nb : δ\nhf : IsMinFilter f l (g b)\nhg : Filter.Tendsto g l' l\n⊢ IsMinFilter (Function.comp f g) l' b","decl":"theorem IsMinFilter.comp_tendsto {g : δ → α} {l' : Filter δ} {b : δ} (hf : IsMinFilter f l (g b))\n    (hg : Tendsto g l' l) : IsMinFilter (f ∘ g) l' b :=\n  hg hf\n\n"}
{"name":"IsMaxFilter.comp_tendsto","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\nl : Filter α\ng : δ → α\nl' : Filter δ\nb : δ\nhf : IsMaxFilter f l (g b)\nhg : Filter.Tendsto g l' l\n⊢ IsMaxFilter (Function.comp f g) l' b","decl":"theorem IsMaxFilter.comp_tendsto {g : δ → α} {l' : Filter δ} {b : δ} (hf : IsMaxFilter f l (g b))\n    (hg : Tendsto g l' l) : IsMaxFilter (f ∘ g) l' b :=\n  hg hf\n\n"}
{"name":"IsExtrFilter.comp_tendsto","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\nl : Filter α\ng : δ → α\nl' : Filter δ\nb : δ\nhf : IsExtrFilter f l (g b)\nhg : Filter.Tendsto g l' l\n⊢ IsExtrFilter (Function.comp f g) l' b","decl":"theorem IsExtrFilter.comp_tendsto {g : δ → α} {l' : Filter δ} {b : δ} (hf : IsExtrFilter f l (g b))\n    (hg : Tendsto g l' l) : IsExtrFilter (f ∘ g) l' b :=\n  hf.elim (fun hf => (hf.comp_tendsto hg).isExtr) fun hf => (hf.comp_tendsto hg).isExtr\n\n"}
{"name":"IsMinOn.on_preimage","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\ng : δ → α\nb : δ\nhf : IsMinOn f s (g b)\n⊢ IsMinOn (Function.comp f g) (Set.preimage g s) b","decl":"theorem IsMinOn.on_preimage (g : δ → α) {b : δ} (hf : IsMinOn f s (g b)) :\n    IsMinOn (f ∘ g) (g ⁻¹' s) b :=\n  hf.comp_tendsto (tendsto_principal_principal.mpr <| Subset.refl _)\n\n"}
{"name":"IsMaxOn.on_preimage","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\ng : δ → α\nb : δ\nhf : IsMaxOn f s (g b)\n⊢ IsMaxOn (Function.comp f g) (Set.preimage g s) b","decl":"theorem IsMaxOn.on_preimage (g : δ → α) {b : δ} (hf : IsMaxOn f s (g b)) :\n    IsMaxOn (f ∘ g) (g ⁻¹' s) b :=\n  hf.comp_tendsto (tendsto_principal_principal.mpr <| Subset.refl _)\n\n"}
{"name":"IsExtrOn.on_preimage","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\ng : δ → α\nb : δ\nhf : IsExtrOn f s (g b)\n⊢ IsExtrOn (Function.comp f g) (Set.preimage g s) b","decl":"theorem IsExtrOn.on_preimage (g : δ → α) {b : δ} (hf : IsExtrOn f s (g b)) :\n    IsExtrOn (f ∘ g) (g ⁻¹' s) b :=\n  hf.elim (fun hf => (hf.on_preimage g).isExtr) fun hf => (hf.on_preimage g).isExtr\n\n"}
{"name":"IsMinOn.comp_mapsTo","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set δ\ng : δ → α\nb : δ\nhf : IsMinOn f s a\nhg : Set.MapsTo g t s\nha : Eq (g b) a\n⊢ IsMinOn (Function.comp f g) t b","decl":"theorem IsMinOn.comp_mapsTo {t : Set δ} {g : δ → α} {b : δ} (hf : IsMinOn f s a) (hg : MapsTo g t s)\n    (ha : g b = a) : IsMinOn (f ∘ g) t b := fun y hy => by\n  simpa only [ha, (· ∘ ·)] using hf (hg hy)\n\n"}
{"name":"IsMaxOn.comp_mapsTo","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set δ\ng : δ → α\nb : δ\nhf : IsMaxOn f s a\nhg : Set.MapsTo g t s\nha : Eq (g b) a\n⊢ IsMaxOn (Function.comp f g) t b","decl":"theorem IsMaxOn.comp_mapsTo {t : Set δ} {g : δ → α} {b : δ} (hf : IsMaxOn f s a) (hg : MapsTo g t s)\n    (ha : g b = a) : IsMaxOn (f ∘ g) t b :=\n  hf.dual.comp_mapsTo hg ha\n\n"}
{"name":"IsExtrOn.comp_mapsTo","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\nδ : Type x\ninst✝ : Preorder β\nf : α → β\ns : Set α\na : α\nt : Set δ\ng : δ → α\nb : δ\nhf : IsExtrOn f s a\nhg : Set.MapsTo g t s\nha : Eq (g b) a\n⊢ IsExtrOn (Function.comp f g) t b","decl":"theorem IsExtrOn.comp_mapsTo {t : Set δ} {g : δ → α} {b : δ} (hf : IsExtrOn f s a)\n    (hg : MapsTo g t s) (ha : g b = a) : IsExtrOn (f ∘ g) t b :=\n  hf.elim (fun h => Or.inl <| h.comp_mapsTo hg ha) fun h => Or.inr <| h.comp_mapsTo hg ha\n\n"}
{"name":"IsMinFilter.add","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommMonoid β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => HAdd.hAdd (f x) (g x)) l a","decl":"theorem IsMinFilter.add (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x + g x) l a :=\n  show IsMinFilter (fun x => f x + g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => add_le_add hx hy) hg\n\n"}
{"name":"IsMaxFilter.add","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommMonoid β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => HAdd.hAdd (f x) (g x)) l a","decl":"theorem IsMaxFilter.add (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x + g x) l a :=\n  show IsMaxFilter (fun x => f x + g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => add_le_add hx hy) hg\n\n"}
{"name":"IsMinOn.add","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommMonoid β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => HAdd.hAdd (f x) (g x)) s a","decl":"theorem IsMinOn.add (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x + g x) s a :=\n  IsMinFilter.add hf hg\n\n"}
{"name":"IsMaxOn.add","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommMonoid β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => HAdd.hAdd (f x) (g x)) s a","decl":"theorem IsMaxOn.add (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x + g x) s a :=\n  IsMaxFilter.add hf hg\n\n"}
{"name":"IsMinFilter.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\n⊢ IsMaxFilter (fun x => Neg.neg (f x)) l a","decl":"theorem IsMinFilter.neg (hf : IsMinFilter f l a) : IsMaxFilter (fun x => -f x) l a :=\n  hf.comp_antitone fun _x _y hx => neg_le_neg hx\n\n"}
{"name":"IsMaxFilter.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\n⊢ IsMinFilter (fun x => Neg.neg (f x)) l a","decl":"theorem IsMaxFilter.neg (hf : IsMaxFilter f l a) : IsMinFilter (fun x => -f x) l a :=\n  hf.comp_antitone fun _x _y hx => neg_le_neg hx\n\n"}
{"name":"IsExtrFilter.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\nl : Filter α\nhf : IsExtrFilter f l a\n⊢ IsExtrFilter (fun x => Neg.neg (f x)) l a","decl":"theorem IsExtrFilter.neg (hf : IsExtrFilter f l a) : IsExtrFilter (fun x => -f x) l a :=\n  hf.elim (fun hf => hf.neg.isExtr) fun hf => hf.neg.isExtr\n\n"}
{"name":"IsMinOn.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\n⊢ IsMaxOn (fun x => Neg.neg (f x)) s a","decl":"theorem IsMinOn.neg (hf : IsMinOn f s a) : IsMaxOn (fun x => -f x) s a :=\n  hf.comp_antitone fun _x _y hx => neg_le_neg hx\n\n"}
{"name":"IsMaxOn.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\n⊢ IsMinOn (fun x => Neg.neg (f x)) s a","decl":"theorem IsMaxOn.neg (hf : IsMaxOn f s a) : IsMinOn (fun x => -f x) s a :=\n  hf.comp_antitone fun _x _y hx => neg_le_neg hx\n\n"}
{"name":"IsExtrOn.neg","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf : α → β\na : α\ns : Set α\nhf : IsExtrOn f s a\n⊢ IsExtrOn (fun x => Neg.neg (f x)) s a","decl":"theorem IsExtrOn.neg (hf : IsExtrOn f s a) : IsExtrOn (fun x => -f x) s a :=\n  hf.elim (fun hf => hf.neg.isExtr) fun hf => hf.neg.isExtr\n\n"}
{"name":"IsMinFilter.sub","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMinFilter (fun x => HSub.hSub (f x) (g x)) l a","decl":"theorem IsMinFilter.sub (hf : IsMinFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMinFilter (fun x => f x - g x) l a := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"IsMaxFilter.sub","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMaxFilter (fun x => HSub.hSub (f x) (g x)) l a","decl":"theorem IsMaxFilter.sub (hf : IsMaxFilter f l a) (hg : IsMinFilter g l a) :\n    IsMaxFilter (fun x => f x - g x) l a := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"IsMinOn.sub","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMaxOn g s a\n⊢ IsMinOn (fun x => HSub.hSub (f x) (g x)) s a","decl":"theorem IsMinOn.sub (hf : IsMinOn f s a) (hg : IsMaxOn g s a) :\n    IsMinOn (fun x => f x - g x) s a := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"IsMaxOn.sub","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : OrderedAddCommGroup β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMinOn g s a\n⊢ IsMaxOn (fun x => HSub.hSub (f x) (g x)) s a","decl":"theorem IsMaxOn.sub (hf : IsMaxOn f s a) (hg : IsMinOn g s a) :\n    IsMaxOn (fun x => f x - g x) s a := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"IsMinFilter.sup","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => Max.max (f x) (g x)) l a","decl":"theorem IsMinFilter.sup (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x ⊔ g x) l a :=\n  show IsMinFilter (fun x => f x ⊔ g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => sup_le_sup hx hy) hg\n\n"}
{"name":"IsMaxFilter.sup","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => Max.max (f x) (g x)) l a","decl":"theorem IsMaxFilter.sup (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x ⊔ g x) l a :=\n  show IsMaxFilter (fun x => f x ⊔ g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => sup_le_sup hx hy) hg\n\n"}
{"name":"IsMinOn.sup","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => Max.max (f x) (g x)) s a","decl":"theorem IsMinOn.sup (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x ⊔ g x) s a :=\n  IsMinFilter.sup hf hg\n\n"}
{"name":"IsMaxOn.sup","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeSup β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => Max.max (f x) (g x)) s a","decl":"theorem IsMaxOn.sup (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x ⊔ g x) s a :=\n  IsMaxFilter.sup hf hg\n\n"}
{"name":"IsMinFilter.inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeInf β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => Min.min (f x) (g x)) l a","decl":"theorem IsMinFilter.inf (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x ⊓ g x) l a :=\n  show IsMinFilter (fun x => f x ⊓ g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => inf_le_inf hx hy) hg\n\n"}
{"name":"IsMaxFilter.inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeInf β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => Min.min (f x) (g x)) l a","decl":"theorem IsMaxFilter.inf (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x ⊓ g x) l a :=\n  show IsMaxFilter (fun x => f x ⊓ g x) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => inf_le_inf hx hy) hg\n\n"}
{"name":"IsMinOn.inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeInf β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => Min.min (f x) (g x)) s a","decl":"theorem IsMinOn.inf (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x ⊓ g x) s a :=\n  IsMinFilter.inf hf hg\n\n"}
{"name":"IsMaxOn.inf","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : SemilatticeInf β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => Min.min (f x) (g x)) s a","decl":"theorem IsMaxOn.inf (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x ⊓ g x) s a :=\n  IsMaxFilter.inf hf hg\n\n"}
{"name":"IsMinFilter.min","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => Min.min (f x) (g x)) l a","decl":"theorem IsMinFilter.min (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => min (f x) (g x)) l a :=\n  show IsMinFilter (fun x => Min.min (f x) (g x)) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => min_le_min hx hy) hg\n\n"}
{"name":"IsMaxFilter.min","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => Min.min (f x) (g x)) l a","decl":"theorem IsMaxFilter.min (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => min (f x) (g x)) l a :=\n  show IsMaxFilter (fun x => Min.min (f x) (g x)) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => min_le_min hx hy) hg\n\n"}
{"name":"IsMinOn.min","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => Min.min (f x) (g x)) s a","decl":"theorem IsMinOn.min (hf : IsMinOn f s a) (hg : IsMinOn g s a) :\n    IsMinOn (fun x => min (f x) (g x)) s a :=\n  IsMinFilter.min hf hg\n\n"}
{"name":"IsMaxOn.min","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => Min.min (f x) (g x)) s a","decl":"theorem IsMaxOn.min (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) :\n    IsMaxOn (fun x => min (f x) (g x)) s a :=\n  IsMaxFilter.min hf hg\n\n"}
{"name":"IsMinFilter.max","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\nl : Filter α\nhf : IsMinFilter f l a\nhg : IsMinFilter g l a\n⊢ IsMinFilter (fun x => Max.max (f x) (g x)) l a","decl":"theorem IsMinFilter.max (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => max (f x) (g x)) l a :=\n  show IsMinFilter (fun x => Max.max (f x) (g x)) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => max_le_max hx hy) hg\n\n"}
{"name":"IsMaxFilter.max","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\nl : Filter α\nhf : IsMaxFilter f l a\nhg : IsMaxFilter g l a\n⊢ IsMaxFilter (fun x => Max.max (f x) (g x)) l a","decl":"theorem IsMaxFilter.max (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => max (f x) (g x)) l a :=\n  show IsMaxFilter (fun x => Max.max (f x) (g x)) l a from\n    hf.bicomp_mono (fun _x _x' hx _y _y' hy => max_le_max hx hy) hg\n\n"}
{"name":"IsMinOn.max","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\ns : Set α\nhf : IsMinOn f s a\nhg : IsMinOn g s a\n⊢ IsMinOn (fun x => Max.max (f x) (g x)) s a","decl":"theorem IsMinOn.max (hf : IsMinOn f s a) (hg : IsMinOn g s a) :\n    IsMinOn (fun x => max (f x) (g x)) s a :=\n  IsMinFilter.max hf hg\n\n"}
{"name":"IsMaxOn.max","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : LinearOrder β\nf g : α → β\na : α\ns : Set α\nhf : IsMaxOn f s a\nhg : IsMaxOn g s a\n⊢ IsMaxOn (fun x => Max.max (f x) (g x)) s a","decl":"theorem IsMaxOn.max (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) :\n    IsMaxOn (fun x => max (f x) (g x)) s a :=\n  IsMaxFilter.max hf hg\n\n"}
{"name":"Filter.EventuallyLE.isMaxFilter","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nhle : l.EventuallyLE g f\nhfga : Eq (f a) (g a)\nh : IsMaxFilter f l a\n⊢ IsMaxFilter g l a","decl":"theorem Filter.EventuallyLE.isMaxFilter {α β : Type*} [Preorder β] {f g : α → β} {a : α}\n    {l : Filter α} (hle : g ≤ᶠ[l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\n    IsMaxFilter g l a := by\n  refine hle.mp (h.mono fun x hf hgf => ?_)\n  rw [← hfga]\n  exact le_trans hgf hf\n\n"}
{"name":"IsMaxFilter.congr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nh : IsMaxFilter f l a\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ IsMaxFilter g l a","decl":"theorem IsMaxFilter.congr {α β : Type*} [Preorder β] {f g : α → β} {a : α} {l : Filter α}\n    (h : IsMaxFilter f l a) (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsMaxFilter g l a :=\n  heq.symm.le.isMaxFilter hfga h\n\n"}
{"name":"Filter.EventuallyEq.isMaxFilter_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ Iff (IsMaxFilter f l a) (IsMaxFilter g l a)","decl":"theorem Filter.EventuallyEq.isMaxFilter_iff {α β : Type*} [Preorder β] {f g : α → β} {a : α}\n    {l : Filter α} (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsMaxFilter f l a ↔ IsMaxFilter g l a :=\n  ⟨fun h => h.congr heq hfga, fun h => h.congr heq.symm hfga.symm⟩\n\n"}
{"name":"Filter.EventuallyLE.isMinFilter","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nhle : l.EventuallyLE f g\nhfga : Eq (f a) (g a)\nh : IsMinFilter f l a\n⊢ IsMinFilter g l a","decl":"theorem Filter.EventuallyLE.isMinFilter {α β : Type*} [Preorder β] {f g : α → β} {a : α}\n    {l : Filter α} (hle : f ≤ᶠ[l] g) (hfga : f a = g a) (h : IsMinFilter f l a) :\n    IsMinFilter g l a :=\n  @Filter.EventuallyLE.isMaxFilter _ βᵒᵈ _ _ _ _ _ hle hfga h\n\n"}
{"name":"IsMinFilter.congr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nh : IsMinFilter f l a\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ IsMinFilter g l a","decl":"theorem IsMinFilter.congr {α β : Type*} [Preorder β] {f g : α → β} {a : α} {l : Filter α}\n    (h : IsMinFilter f l a) (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsMinFilter g l a :=\n  heq.le.isMinFilter hfga h\n\n"}
{"name":"Filter.EventuallyEq.isMinFilter_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ Iff (IsMinFilter f l a) (IsMinFilter g l a)","decl":"theorem Filter.EventuallyEq.isMinFilter_iff {α β : Type*} [Preorder β] {f g : α → β} {a : α}\n    {l : Filter α} (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsMinFilter f l a ↔ IsMinFilter g l a :=\n  ⟨fun h => h.congr heq hfga, fun h => h.congr heq.symm hfga.symm⟩\n\n"}
{"name":"IsExtrFilter.congr","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nh : IsExtrFilter f l a\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ IsExtrFilter g l a","decl":"theorem IsExtrFilter.congr {α β : Type*} [Preorder β] {f g : α → β} {a : α} {l : Filter α}\n    (h : IsExtrFilter f l a) (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsExtrFilter g l a := by\n  rw [IsExtrFilter] at *\n  rwa [← heq.isMaxFilter_iff hfga, ← heq.isMinFilter_iff hfga]\n\n"}
{"name":"Filter.EventuallyEq.isExtrFilter_iff","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nf g : α → β\na : α\nl : Filter α\nheq : l.EventuallyEq f g\nhfga : Eq (f a) (g a)\n⊢ Iff (IsExtrFilter f l a) (IsExtrFilter g l a)","decl":"theorem Filter.EventuallyEq.isExtrFilter_iff {α β : Type*} [Preorder β] {f g : α → β} {a : α}\n    {l : Filter α} (heq : f =ᶠ[l] g) (hfga : f a = g a) : IsExtrFilter f l a ↔ IsExtrFilter g l a :=\n  ⟨fun h => h.congr heq hfga, fun h => h.congr heq.symm hfga.symm⟩\n\n"}
{"name":"IsMaxOn.iSup_eq","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : ConditionallyCompleteLinearOrder α\nf : β → α\ns : Set β\nx₀ : β\nhx₀ : Membership.mem s x₀\nh : IsMaxOn f s x₀\n⊢ Eq (iSup fun x => f ↑x) (f x₀)","decl":"theorem IsMaxOn.iSup_eq (hx₀ : x₀ ∈ s) (h : IsMaxOn f s x₀) : ⨆ x : s, f x = f x₀ :=\n  haveI : Nonempty s := ⟨⟨x₀, hx₀⟩⟩\n  ciSup_eq_of_forall_le_of_forall_lt_exists_gt (fun x => h x.2) fun _w hw => ⟨⟨x₀, hx₀⟩, hw⟩\n\n"}
{"name":"IsMinOn.iInf_eq","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝ : ConditionallyCompleteLinearOrder α\nf : β → α\ns : Set β\nx₀ : β\nhx₀ : Membership.mem s x₀\nh : IsMinOn f s x₀\n⊢ Eq (iInf fun x => f ↑x) (f x₀)","decl":"theorem IsMinOn.iInf_eq (hx₀ : x₀ ∈ s) (h : IsMinOn f s x₀) : ⨅ x : s, f x = f x₀ :=\n  @IsMaxOn.iSup_eq αᵒᵈ β _ _ _ _ hx₀ h\n\n"}
{"name":"sup_eq_of_isMaxOn","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nD : α → β\ns : Finset α\na : α\nhmem : Membership.mem s a\nhmax : IsMaxOn D (↑s) a\n⊢ Eq (s.sup D) (D a)","decl":"theorem sup_eq_of_isMaxOn {a : α} (hmem : a ∈ s) (hmax : IsMaxOn D s a) : s.sup D = D a :=\n  (Finset.sup_le hmax).antisymm (Finset.le_sup hmem)\n\n"}
{"name":"sup_eq_of_max","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝² : SemilatticeSup β\ninst✝¹ : OrderBot β\nD : α → β\ns : Finset α\ninst✝ : Nonempty α\nb : β\nhb : Membership.mem (Set.range D) b\nhmem : Membership.mem s (Function.invFun D b)\nhmax : ∀ (a : α), Membership.mem s a → LE.le (D a) b\n⊢ Eq (s.sup D) b","decl":"theorem sup_eq_of_max [Nonempty α] {b : β} (hb : b ∈ Set.range D) (hmem : D.invFun b ∈ s)\n    (hmax : ∀ a ∈ s, D a ≤ b) : s.sup D = b := by\n  obtain ⟨a, rfl⟩ := hb\n  rw [← Function.apply_invFun_apply (f := D)]\n  apply sup_eq_of_isMaxOn hmem; intro\n  rw [Function.apply_invFun_apply (f := D)]; apply hmax\n\n"}
{"name":"inf_eq_of_isMinOn","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\nD : α → β\ns : Finset α\na : α\nhmem : Membership.mem s a\nhmax : IsMinOn D (↑s) a\n⊢ Eq (s.inf D) (D a)","decl":"theorem inf_eq_of_isMinOn {a : α} (hmem : a ∈ s) (hmax : IsMinOn D s a) : s.inf D = D a :=\n  sup_eq_of_isMaxOn (α := αᵒᵈ) (β := βᵒᵈ) hmem hmax.dual\n\n"}
{"name":"inf_eq_of_min","module":"Mathlib.Order.Filter.Extr","initialProofState":"α : Type u\nβ : Type v\ninst✝² : SemilatticeInf β\ninst✝¹ : OrderTop β\nD : α → β\ns : Finset α\ninst✝ : Nonempty α\nb : β\nhb : Membership.mem (Set.range D) b\nhmem : Membership.mem s (Function.invFun D b)\nhmin : ∀ (a : α), Membership.mem s a → LE.le b (D a)\n⊢ Eq (s.inf D) b","decl":"theorem inf_eq_of_min [Nonempty α] {b : β} (hb : b ∈ Set.range D) (hmem : D.invFun b ∈ s)\n    (hmin : ∀ a ∈ s, b ≤ D a) : s.inf D = b :=\n  sup_eq_of_max (α := αᵒᵈ) (β := βᵒᵈ) hb hmem hmin\n\n"}
