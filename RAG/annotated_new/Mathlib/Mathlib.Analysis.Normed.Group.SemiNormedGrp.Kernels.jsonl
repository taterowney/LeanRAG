{"name":"SemiNormedGrp₁.instHasCokernels","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"⊢ CategoryTheory.Limits.HasCokernels SemiNormedGrp₁","decl":"instance : HasCokernels SemiNormedGrp₁.{u} where\n  has_colimit f :=\n    HasColimit.mk\n      { cocone := cokernelCocone f\n        isColimit :=\n          isColimitAux _ (cokernelLift f)\n            (fun s => by\n              ext\n              apply NormedAddGroupHom.lift_mk f.1.range\n              rintro _ ⟨b, rfl⟩\n              change (f ≫ s.π) b = 0\n              simp\n              -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n              erw [zero_apply])\n            fun _ _ w =>\n            Subtype.eq\n              (NormedAddGroupHom.lift_unique f.1.range _ _ _ (congr_arg Subtype.val w :)) }\n\n-- Sanity check\n"}
{"name":"SemiNormedGrp.hasLimit_parallelPair","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"V W : SemiNormedGrp\nf g : Quiver.Hom V W\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair f g)","decl":"instance hasLimit_parallelPair {V W : SemiNormedGrp.{u}} (f g : V ⟶ W) :\n    HasLimit (parallelPair f g) where\n  exists_limit :=\n    Nonempty.intro\n      { cone := fork f g\n        isLimit :=\n          Fork.IsLimit.mk _\n            (fun c =>\n              NormedAddGroupHom.ker.lift (Fork.ι c) _ <|\n                show NormedAddGroupHom.compHom (f - g) c.ι = 0 by\n                  rw [AddMonoidHom.map_sub, AddMonoidHom.sub_apply, sub_eq_zero]; exact c.condition)\n            (fun _ => NormedAddGroupHom.ker.incl_comp_lift _ _ _) fun c g h => by\n        -- Porting note: the `simp_rw` was `rw [← h]` but motive is not type correct in mathlib4\n              ext x; dsimp; simp_rw [← h]; rfl}\n\n"}
{"name":"SemiNormedGrp.instHasEqualizers","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"⊢ CategoryTheory.Limits.HasEqualizers SemiNormedGrp","decl":"instance : Limits.HasEqualizers.{u, u + 1} SemiNormedGrp :=\n  @hasEqualizers_of_hasLimit_parallelPair SemiNormedGrp _ fun {_ _ f g} =>\n    SemiNormedGrp.hasLimit_parallelPair f g\n\n"}
{"name":"SemiNormedGrp.instHasCokernels","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"⊢ CategoryTheory.Limits.HasCokernels SemiNormedGrp","decl":"instance : HasCokernels SemiNormedGrp.{u} where\n  has_colimit f :=\n    HasColimit.mk\n      { cocone := cokernelCocone f\n        isColimit := isColimitCokernelCocone f }\n\n-- Sanity check\n"}
{"name":"SemiNormedGrp.explicitCokernelπ_surjective","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ Function.Surjective ⇑(SemiNormedGrp.explicitCokernelπ f)","decl":"theorem explicitCokernelπ_surjective {X Y : SemiNormedGrp.{u}} {f : X ⟶ Y} :\n    Function.Surjective (explicitCokernelπ f) :=\n  Quot.mk_surjective\n\n"}
{"name":"SemiNormedGrp.comp_explicitCokernelπ_assoc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\nZ : SemiNormedGrp\nh : Quiver.Hom (SemiNormedGrp.explicitCokernel f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[simp, reassoc]\ntheorem comp_explicitCokernelπ {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    f ≫ explicitCokernelπ f = 0 := by\n  convert (cokernelCocone f).w WalkingParallelPairHom.left\n  simp\n\n-- Porting note: wasn't necessary in Lean 3. Is this a bug?\n"}
{"name":"SemiNormedGrp.comp_explicitCokernelπ","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (SemiNormedGrp.explicitCokernelπ f)) 0","decl":"@[simp, reassoc]\ntheorem comp_explicitCokernelπ {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    f ≫ explicitCokernelπ f = 0 := by\n  convert (cokernelCocone f).w WalkingParallelPairHom.left\n  simp\n\n-- Porting note: wasn't necessary in Lean 3. Is this a bug?\n"}
{"name":"SemiNormedGrp.explicitCokernelπ_apply_dom_eq_zero","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\nx : ↑X\n⊢ Eq ((SemiNormedGrp.explicitCokernelπ f) (f x)) 0","decl":"@[simp]\ntheorem explicitCokernelπ_apply_dom_eq_zero {X Y : SemiNormedGrp.{u}} {f : X ⟶ Y} (x : X) :\n    (explicitCokernelπ f) (f x) = 0 :=\n  show (f ≫ explicitCokernelπ f) x = 0 by rw [comp_explicitCokernelπ]; rfl\n\n"}
{"name":"SemiNormedGrp.explicitCokernelπ_desc_assoc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z✝ : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nZ : SemiNormedGrp\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelDesc w) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[simp, reassoc]\ntheorem explicitCokernelπ_desc {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    (w : f ≫ g = 0) : explicitCokernelπ f ≫ explicitCokernelDesc w = g :=\n  (isColimitCokernelCocone f).fac _ _\n\n"}
{"name":"SemiNormedGrp.explicitCokernelπ_desc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) (SemiNormedGrp.explicitCokernelDesc w)) g","decl":"@[simp, reassoc]\ntheorem explicitCokernelπ_desc {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    (w : f ≫ g = 0) : explicitCokernelπ f ≫ explicitCokernelDesc w = g :=\n  (isColimitCokernelCocone f).fac _ _\n\n"}
{"name":"SemiNormedGrp.explicitCokernelπ_desc_apply","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ncond : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nx : ↑Y\n⊢ Eq ((SemiNormedGrp.explicitCokernelDesc cond) ((SemiNormedGrp.explicitCokernelπ f) x)) (g x)","decl":"@[simp]\ntheorem explicitCokernelπ_desc_apply {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    {cond : f ≫ g = 0} (x : Y) : explicitCokernelDesc cond (explicitCokernelπ f x) = g x :=\n  show (explicitCokernelπ f ≫ explicitCokernelDesc cond) x = g x by rw [explicitCokernelπ_desc]\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_unique","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ne : Quiver.Hom (SemiNormedGrp.explicitCokernel f) Z\nhe : Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) e) g\n⊢ Eq e (SemiNormedGrp.explicitCokernelDesc w)","decl":"theorem explicitCokernelDesc_unique {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    (w : f ≫ g = 0) (e : explicitCokernel f ⟶ Z) (he : explicitCokernelπ f ≫ e = g) :\n    e = explicitCokernelDesc w := by\n  apply (isColimitCokernelCocone f).uniq (Cofork.ofπ g (by simp [w]))\n  rintro (_ | _)\n  · convert w.symm\n    simp\n  · exact he\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_comp_eq_desc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z W : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom Z W\ncond' : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelDesc cond') h) (SemiNormedGrp.explicitCokernelDesc ⋯)","decl":"theorem explicitCokernelDesc_comp_eq_desc {X Y Z W : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    -- Porting note: renamed `cond` to `cond'` to avoid\n    -- failed to rewrite using equation theorems for 'cond'\n    {h : Z ⟶ W} {cond' : f ≫ g = 0} :\n    explicitCokernelDesc cond' ≫ h =\n      explicitCokernelDesc\n        (show f ≫ g ≫ h = 0 by rw [← CategoryTheory.Category.assoc, cond', Limits.zero_comp]) := by\n  refine explicitCokernelDesc_unique _ _ ?_\n  rw [← CategoryTheory.Category.assoc, explicitCokernelπ_desc]\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_zero","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ Eq (SemiNormedGrp.explicitCokernelDesc ⋯) 0","decl":"@[simp]\ntheorem explicitCokernelDesc_zero {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} :\n    explicitCokernelDesc (show f ≫ (0 : Y ⟶ Z) = 0 from CategoryTheory.Limits.comp_zero) = 0 :=\n  Eq.symm <| explicitCokernelDesc_unique _ _ CategoryTheory.Limits.comp_zero\n\n"}
{"name":"SemiNormedGrp.explicitCokernel_hom_ext_iff","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ne₁ e₂ : Quiver.Hom (SemiNormedGrp.explicitCokernel f) Z\n⊢ Iff (Eq e₁ e₂) (Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) e₁) (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) e₂))","decl":"@[ext]\ntheorem explicitCokernel_hom_ext {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y}\n    (e₁ e₂ : explicitCokernel f ⟶ Z) (h : explicitCokernelπ f ≫ e₁ = explicitCokernelπ f ≫ e₂) :\n    e₁ = e₂ := by\n  let g : Y ⟶ Z := explicitCokernelπ f ≫ e₂\n  have w : f ≫ g = 0 := by simp [g]\n  have : e₂ = explicitCokernelDesc w := by apply explicitCokernelDesc_unique; rfl\n  rw [this]\n  apply explicitCokernelDesc_unique\n  exact h\n\n"}
{"name":"SemiNormedGrp.explicitCokernel_hom_ext","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ne₁ e₂ : Quiver.Hom (SemiNormedGrp.explicitCokernel f) Z\nh : Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) e₁) (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) e₂)\n⊢ Eq e₁ e₂","decl":"@[ext]\ntheorem explicitCokernel_hom_ext {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y}\n    (e₁ e₂ : explicitCokernel f ⟶ Z) (h : explicitCokernelπ f ≫ e₁ = explicitCokernelπ f ≫ e₂) :\n    e₁ = e₂ := by\n  let g : Y ⟶ Z := explicitCokernelπ f ≫ e₂\n  have w : f ≫ g = 0 := by simp [g]\n  have : e₂ = explicitCokernelDesc w := by apply explicitCokernelDesc_unique; rfl\n  rw [this]\n  apply explicitCokernelDesc_unique\n  exact h\n\n"}
{"name":"SemiNormedGrp.explicitCokernelπ.epi","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Epi (SemiNormedGrp.explicitCokernelπ f)","decl":"instance explicitCokernelπ.epi {X Y : SemiNormedGrp.{u}} {f : X ⟶ Y} :\n    Epi (explicitCokernelπ f) := by\n  constructor\n  intro Z g h H\n  ext x\n  -- Porting note: no longer needed\n  -- obtain ⟨x, hx⟩ := explicitCokernelπ_surjective (explicitCokernelπ f x)\n  -- change (explicitCokernelπ f ≫ g) _ = _\n  rw [H]\n\n"}
{"name":"SemiNormedGrp.isQuotient_explicitCokernelπ","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ NormedAddGroupHom.IsQuotient (SemiNormedGrp.explicitCokernelπ f)","decl":"theorem isQuotient_explicitCokernelπ {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    NormedAddGroupHom.IsQuotient (explicitCokernelπ f) :=\n  NormedAddGroupHom.isQuotientQuotient _\n\n"}
{"name":"SemiNormedGrp.normNoninc_explicitCokernelπ","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ NormedAddGroupHom.NormNoninc (SemiNormedGrp.explicitCokernelπ f)","decl":"theorem normNoninc_explicitCokernelπ {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    (explicitCokernelπ f).NormNoninc :=\n  (isQuotient_explicitCokernelπ f).norm_le\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_norm_le_of_norm_le","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nc : NNReal\nh : LE.le (Norm.norm g) ↑c\n⊢ LE.le (Norm.norm (SemiNormedGrp.explicitCokernelDesc w)) ↑c","decl":"theorem explicitCokernelDesc_norm_le_of_norm_le {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y}\n    {g : Y ⟶ Z} (w : f ≫ g = 0) (c : ℝ≥0) (h : ‖g‖ ≤ c) : ‖explicitCokernelDesc w‖ ≤ c :=\n  NormedAddGroupHom.lift_norm_le _ _ _ h\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_normNoninc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ncond : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nhg : NormedAddGroupHom.NormNoninc g\n⊢ NormedAddGroupHom.NormNoninc (SemiNormedGrp.explicitCokernelDesc cond)","decl":"theorem explicitCokernelDesc_normNoninc {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    {cond : f ≫ g = 0} (hg : g.NormNoninc) : (explicitCokernelDesc cond).NormNoninc := by\n  refine NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one.2 ?_\n  rw [← NNReal.coe_one]\n  exact\n    explicitCokernelDesc_norm_le_of_norm_le cond 1\n      (NormedAddGroupHom.NormNoninc.normNoninc_iff_norm_le_one.1 hg)\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_comp_eq_zero","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z W : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Quiver.Hom Z W\ncond : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ncond2 : Eq (CategoryTheory.CategoryStruct.comp g h) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelDesc cond) h) 0","decl":"theorem explicitCokernelDesc_comp_eq_zero {X Y Z W : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    {h : Z ⟶ W} (cond : f ≫ g = 0) (cond2 : g ≫ h = 0) : explicitCokernelDesc cond ≫ h = 0 := by\n  rw [← cancel_epi (explicitCokernelπ f), ← Category.assoc, explicitCokernelπ_desc]\n  simp [cond2]\n\n"}
{"name":"SemiNormedGrp.explicitCokernelDesc_norm_le","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ LE.le (Norm.norm (SemiNormedGrp.explicitCokernelDesc w)) (Norm.norm g)","decl":"theorem explicitCokernelDesc_norm_le {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    (w : f ≫ g = 0) : ‖explicitCokernelDesc w‖ ≤ ‖g‖ :=\n  explicitCokernelDesc_norm_le_of_norm_le w ‖g‖₊ le_rfl\n\n"}
{"name":"SemiNormedGrp.explicitCokernelIso_hom_π","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelπ f) (SemiNormedGrp.explicitCokernelIso f).hom) (CategoryTheory.Limits.cokernel.π f)","decl":"@[simp]\ntheorem explicitCokernelIso_hom_π {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    explicitCokernelπ f ≫ (explicitCokernelIso f).hom = cokernel.π _ := by\n  simp [explicitCokernelπ, explicitCokernelIso, IsColimit.coconePointUniqueUpToIso]\n\n"}
{"name":"SemiNormedGrp.explicitCokernelIso_inv_π","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y : SemiNormedGrp\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π f) (SemiNormedGrp.explicitCokernelIso f).inv) (SemiNormedGrp.explicitCokernelπ f)","decl":"@[simp]\ntheorem explicitCokernelIso_inv_π {X Y : SemiNormedGrp.{u}} (f : X ⟶ Y) :\n    cokernel.π f ≫ (explicitCokernelIso f).inv = explicitCokernelπ f := by\n  simp [explicitCokernelπ, explicitCokernelIso]\n\n"}
{"name":"SemiNormedGrp.explicitCokernelIso_hom_desc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"X Y Z : SemiNormedGrp\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelIso f).hom (CategoryTheory.Limits.cokernel.desc f g w)) (SemiNormedGrp.explicitCokernelDesc w)","decl":"@[simp]\ntheorem explicitCokernelIso_hom_desc {X Y Z : SemiNormedGrp.{u}} {f : X ⟶ Y} {g : Y ⟶ Z}\n    (w : f ≫ g = 0) :\n    (explicitCokernelIso f).hom ≫ cokernel.desc f g w = explicitCokernelDesc w := by\n  ext1\n  simp [explicitCokernelDesc, explicitCokernelπ, explicitCokernelIso,\n    IsColimit.coconePointUniqueUpToIso]\n\n"}
{"name":"SemiNormedGrp.ExplicitCoker.map_desc","module":"Mathlib.Analysis.Normed.Group.SemiNormedGrp.Kernels","initialProofState":"A B C D B' D' : SemiNormedGrp\nfab : Quiver.Hom A B\nfbd : Quiver.Hom B D\nfac : Quiver.Hom A C\nfcd : Quiver.Hom C D\nh : Eq (CategoryTheory.CategoryStruct.comp fab fbd) (CategoryTheory.CategoryStruct.comp fac fcd)\nfbb' : Quiver.Hom B B'\nfdd' : Quiver.Hom D D'\ncondb : Eq (CategoryTheory.CategoryStruct.comp fab fbb') 0\ncondd : Eq (CategoryTheory.CategoryStruct.comp fcd fdd') 0\ng : Quiver.Hom B' D'\nh' : Eq (CategoryTheory.CategoryStruct.comp fbb' g) (CategoryTheory.CategoryStruct.comp fbd fdd')\n⊢ Eq (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernelDesc condb) g) (CategoryTheory.CategoryStruct.comp (SemiNormedGrp.explicitCokernel.map h) (SemiNormedGrp.explicitCokernelDesc condd))","decl":"/-- A special case of `CategoryTheory.Limits.cokernel.map_desc` adapted to `explicitCokernel`. -/\ntheorem ExplicitCoker.map_desc {A B C D B' D' : SemiNormedGrp.{u}}\n    {fab : A ⟶ B} {fbd : B ⟶ D} {fac : A ⟶ C} {fcd : C ⟶ D} {h : fab ≫ fbd = fac ≫ fcd}\n    {fbb' : B ⟶ B'} {fdd' : D ⟶ D'} {condb : fab ≫ fbb' = 0} {condd : fcd ≫ fdd' = 0} {g : B' ⟶ D'}\n    (h' : fbb' ≫ g = fbd ≫ fdd') :\n    explicitCokernelDesc condb ≫ g = explicitCokernel.map h ≫ explicitCokernelDesc condd := by\n  delta explicitCokernel.map\n  simp only [← Category.assoc, ← cancel_epi (explicitCokernelπ fab)]\n  simp [Category.assoc, explicitCokernelπ_desc, h']\n\n"}
