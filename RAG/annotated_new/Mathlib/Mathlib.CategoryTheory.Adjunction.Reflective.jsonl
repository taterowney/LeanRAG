{"name":"CategoryTheory.Reflective.toFull","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\nself : CategoryTheory.Reflective R\n‚ä¢ R.Full","decl":"/--\nA functor is *reflective*, or *a reflective inclusion*, if it is fully faithful and right adjoint.\n-/\nclass Reflective (R : D ‚•§ C) extends R.Full, R.Faithful where\n  /-- a choice of a left adjoint to `R` -/\n  L : C ‚•§ D\n  /-- `R` is a right adjoint -/\n  adj : L ‚ä£ R\n\n"}
{"name":"CategoryTheory.Reflective.toFaithful","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\nself : CategoryTheory.Reflective R\n‚ä¢ R.Faithful","decl":"/--\nA functor is *reflective*, or *a reflective inclusion*, if it is fully faithful and right adjoint.\n-/\nclass Reflective (R : D ‚•§ C) extends R.Full, R.Faithful where\n  /-- a choice of a left adjoint to `R` -/\n  L : C ‚•§ D\n  /-- `R` is a right adjoint -/\n  adj : L ‚ä£ R\n\n"}
{"name":"CategoryTheory.instIsRightAdjointOfReflective","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ i.IsRightAdjoint","decl":"instance [Reflective i] : i.IsRightAdjoint := ‚ü®_, ‚ü®reflectorAdjunction i‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.instIsLeftAdjointReflector","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ (CategoryTheory.reflector i).IsLeftAdjoint","decl":"instance [Reflective i] : (reflector i).IsLeftAdjoint := ‚ü®_, ‚ü®reflectorAdjunction i‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.unit_obj_eq_map_unit","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nX : C\n‚ä¢ Eq ((CategoryTheory.reflectorAdjunction i).unit.app (i.obj ((CategoryTheory.reflector i).obj X))) (i.map ((CategoryTheory.reflector i).map ((CategoryTheory.reflectorAdjunction i).unit.app X)))","decl":"/-- For a reflective functor `i` (with left adjoint `L`), with unit `Œ∑`, we have `Œ∑_iL = iL Œ∑`.\n-/\ntheorem unit_obj_eq_map_unit [Reflective i] (X : C) :\n    (reflectorAdjunction i).unit.app (i.obj ((reflector i).obj X)) =\n      i.map ((reflector i).map ((reflectorAdjunction i).unit.app X)) := by\n  rw [‚Üê cancel_mono (i.map ((reflectorAdjunction i).counit.app ((reflector i).obj X))),\n    ‚Üê i.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.essImage.unit_isIso","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nA : C\nh : Membership.mem i.essImage A\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.reflectorAdjunction i).unit.app A)","decl":"/-- If `A` is essentially in the image of a reflective functor `i`, then `Œ∑_A` is an isomorphism.\nThis gives that the \"witness\" for `A` being in the essential image can instead be given as the\nreflection of `A`, with the isomorphism as `Œ∑_A`.\n\n(For any `B` in the reflective subcategory, we automatically have that `Œµ_B` is an iso.)\n-/\ntheorem Functor.essImage.unit_isIso [Reflective i] {A : C} (h : A ‚àà i.essImage) :\n    IsIso ((reflectorAdjunction i).unit.app A) := by\n  rwa [isIso_unit_app_iff_mem_essImage]\n\n"}
{"name":"CategoryTheory.mem_essImage_of_unit_isSplitMono","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù¬π : CategoryTheory.Reflective i\nA : C\ninst‚úù : CategoryTheory.IsSplitMono ((CategoryTheory.reflectorAdjunction i).unit.app A)\n‚ä¢ Membership.mem i.essImage A","decl":"/-- If `Œ∑_A` is a split monomorphism, then `A` is in the reflective subcategory. -/\ntheorem mem_essImage_of_unit_isSplitMono [Reflective i] {A : C}\n    [IsSplitMono ((reflectorAdjunction i).unit.app A)] : A ‚àà i.essImage := by\n  let Œ∑ : ùü≠ C ‚ü∂ reflector i ‚ãô i := (reflectorAdjunction i).unit\n  haveI : IsIso (Œ∑.app (i.obj ((reflector i).obj A))) :=\n    Functor.essImage.unit_isIso ((i.obj_mem_essImage _))\n  have : Epi (Œ∑.app A) := by\n    refine @epi_of_epi _ _ _ _ _ (retraction (Œ∑.app A)) (Œ∑.app A) ?_\n    rw [show retraction _ ‚â´ Œ∑.app A = _ from Œ∑.naturality (retraction (Œ∑.app A))]\n    apply epi_comp (Œ∑.app (i.obj ((reflector i).obj A)))\n  haveI := isIso_of_epi_of_isSplitMono (Œ∑.app A)\n  exact (reflectorAdjunction i).mem_essImage_of_unit_isIso A\n\n"}
{"name":"CategoryTheory.unitCompPartialBijectiveAux_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nA : C\nB : D\nf : Quiver.Hom (i.obj ((CategoryTheory.reflector i).obj A)) (i.obj B)\n‚ä¢ Eq ((CategoryTheory.unitCompPartialBijectiveAux A B).symm f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.reflectorAdjunction i).unit.app A) f)","decl":"/-- The description of the inverse of the bijection `unitCompPartialBijectiveAux`. -/\ntheorem unitCompPartialBijectiveAux_symm_apply [Reflective i] {A : C} {B : D}\n    (f : i.obj ((reflector i).obj A) ‚ü∂ i.obj B) :\n    (unitCompPartialBijectiveAux _ _).symm f = (reflectorAdjunction i).unit.app A ‚â´ f := by\n  simp [unitCompPartialBijectiveAux, Adjunction.homEquiv_unit]\n\n"}
{"name":"CategoryTheory.unitCompPartialBijective_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nA B : C\nhB : Membership.mem i.essImage B\nf : Quiver.Hom (i.obj ((CategoryTheory.reflector i).obj A)) B\n‚ä¢ Eq ((CategoryTheory.unitCompPartialBijective A hB).symm f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.reflectorAdjunction i).unit.app A) f)","decl":"@[simp]\ntheorem unitCompPartialBijective_symm_apply [Reflective i] (A : C) {B : C} (hB : B ‚àà i.essImage)\n    (f) : (unitCompPartialBijective A hB).symm f = (reflectorAdjunction i).unit.app A ‚â´ f := by\n  simp [unitCompPartialBijective, unitCompPartialBijectiveAux_symm_apply]\n\n"}
{"name":"CategoryTheory.unitCompPartialBijective_symm_natural","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nA B B' : C\nh : Quiver.Hom B B'\nhB : Membership.mem i.essImage B\nhB' : Membership.mem i.essImage B'\nf : Quiver.Hom (i.obj ((CategoryTheory.reflector i).obj A)) B\n‚ä¢ Eq ((CategoryTheory.unitCompPartialBijective A hB').symm (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.unitCompPartialBijective A hB).symm f) h)","decl":"theorem unitCompPartialBijective_symm_natural [Reflective i] (A : C) {B B' : C} (h : B ‚ü∂ B')\n    (hB : B ‚àà i.essImage) (hB' : B' ‚àà i.essImage) (f : i.obj ((reflector i).obj A) ‚ü∂ B) :\n    (unitCompPartialBijective A hB').symm (f ‚â´ h) = (unitCompPartialBijective A hB).symm f ‚â´ h := by\n  simp\n\n"}
{"name":"CategoryTheory.unitCompPartialBijective_natural","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nA B B' : C\nh : Quiver.Hom B B'\nhB : Membership.mem i.essImage B\nhB' : Membership.mem i.essImage B'\nf : Quiver.Hom A B\n‚ä¢ Eq ((CategoryTheory.unitCompPartialBijective A hB') (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.unitCompPartialBijective A hB) f) h)","decl":"theorem unitCompPartialBijective_natural [Reflective i] (A : C) {B B' : C} (h : B ‚ü∂ B')\n    (hB : B ‚àà i.essImage) (hB' : B' ‚àà i.essImage) (f : A ‚ü∂ B) :\n    (unitCompPartialBijective A hB') (f ‚â´ h) = unitCompPartialBijective A hB f ‚â´ h := by\n  rw [‚Üê Equiv.eq_symm_apply, unitCompPartialBijective_symm_natural A h, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.instIsIsoAppUnitReflectorAdjunctionObjEssImage","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\nX : i.EssImageSubcategory\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.reflectorAdjunction i).unit.app X.obj)","decl":"instance [Reflective i] (X : Functor.EssImageSubcategory i) :\n  IsIso (NatTrans.app (reflectorAdjunction i).unit X.obj) :=\nFunctor.essImage.unit_isIso X.property\n\n-- These attributes are necessary to make automation work in `equivEssImageOfReflective`.\n-- Making them global doesn't break anything elsewhere, but this is enough for now.\n-- TODO: investigate further.\n"}
{"name":"CategoryTheory.equivEssImageOfReflective_unitIso","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ Eq CategoryTheory.equivEssImageOfReflective.unitIso (CategoryTheory.asIso (CategoryTheory.reflectorAdjunction i).counit).symm","decl":"attribute [local simp 900] Functor.essImageInclusion_map in\nattribute [local ext] Functor.essImage_ext in\n/-- If `i : D ‚•§ C` is reflective, the inverse functor of `i ‚âå F.essImage` can be explicitly\ndefined by the reflector. -/\n@[simps]\ndef equivEssImageOfReflective [Reflective i] : D ‚âå i.EssImageSubcategory where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion ‚ãô reflector i\n  unitIso := (asIso <| (reflectorAdjunction i).counit).symm\n  counitIso := Functor.fullyFaithfulCancelRight i.essImageInclusion <|\n    NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).unit.app X.obj)).symm)\n\n"}
{"name":"CategoryTheory.equivEssImageOfReflective_inverse","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ Eq CategoryTheory.equivEssImageOfReflective.inverse (i.essImageInclusion.comp (CategoryTheory.reflector i))","decl":"attribute [local simp 900] Functor.essImageInclusion_map in\nattribute [local ext] Functor.essImage_ext in\n/-- If `i : D ‚•§ C` is reflective, the inverse functor of `i ‚âå F.essImage` can be explicitly\ndefined by the reflector. -/\n@[simps]\ndef equivEssImageOfReflective [Reflective i] : D ‚âå i.EssImageSubcategory where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion ‚ãô reflector i\n  unitIso := (asIso <| (reflectorAdjunction i).counit).symm\n  counitIso := Functor.fullyFaithfulCancelRight i.essImageInclusion <|\n    NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).unit.app X.obj)).symm)\n\n"}
{"name":"CategoryTheory.equivEssImageOfReflective_counitIso","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ Eq CategoryTheory.equivEssImageOfReflective.counitIso (CategoryTheory.Functor.fullyFaithfulCancelRight i.essImageInclusion (CategoryTheory.NatIso.ofComponents (fun X => (CategoryTheory.asIso ((CategoryTheory.reflectorAdjunction i).unit.app X.obj)).symm) ‚ãØ))","decl":"attribute [local simp 900] Functor.essImageInclusion_map in\nattribute [local ext] Functor.essImage_ext in\n/-- If `i : D ‚•§ C` is reflective, the inverse functor of `i ‚âå F.essImage` can be explicitly\ndefined by the reflector. -/\n@[simps]\ndef equivEssImageOfReflective [Reflective i] : D ‚âå i.EssImageSubcategory where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion ‚ãô reflector i\n  unitIso := (asIso <| (reflectorAdjunction i).counit).symm\n  counitIso := Functor.fullyFaithfulCancelRight i.essImageInclusion <|\n    NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).unit.app X.obj)).symm)\n\n"}
{"name":"CategoryTheory.Functor.essImage_ext_iff","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : F.EssImageSubcategory\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq (F.essImageInclusion.map f) (F.essImageInclusion.map g))","decl":"attribute [local simp 900] Functor.essImageInclusion_map in\nattribute [local ext] Functor.essImage_ext in\n/-- If `i : D ‚•§ C` is reflective, the inverse functor of `i ‚âå F.essImage` can be explicitly\ndefined by the reflector. -/\n@[simps]\ndef equivEssImageOfReflective [Reflective i] : D ‚âå i.EssImageSubcategory where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion ‚ãô reflector i\n  unitIso := (asIso <| (reflectorAdjunction i).counit).symm\n  counitIso := Functor.fullyFaithfulCancelRight i.essImageInclusion <|\n    NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).unit.app X.obj)).symm)\n\n"}
{"name":"CategoryTheory.equivEssImageOfReflective_functor","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ni : CategoryTheory.Functor D C\ninst‚úù : CategoryTheory.Reflective i\n‚ä¢ Eq CategoryTheory.equivEssImageOfReflective.functor i.toEssImage","decl":"attribute [local simp 900] Functor.essImageInclusion_map in\nattribute [local ext] Functor.essImage_ext in\n/-- If `i : D ‚•§ C` is reflective, the inverse functor of `i ‚âå F.essImage` can be explicitly\ndefined by the reflector. -/\n@[simps]\ndef equivEssImageOfReflective [Reflective i] : D ‚âå i.EssImageSubcategory where\n  functor := i.toEssImage\n  inverse := i.essImageInclusion ‚ãô reflector i\n  unitIso := (asIso <| (reflectorAdjunction i).counit).symm\n  counitIso := Functor.fullyFaithfulCancelRight i.essImageInclusion <|\n    NatIso.ofComponents (fun X ‚Ü¶ (asIso ((reflectorAdjunction i).unit.app X.obj)).symm)\n\n"}
{"name":"CategoryTheory.Coreflective.toFaithful","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nself : CategoryTheory.Coreflective L\n‚ä¢ L.Faithful","decl":"/--\nA functor is *coreflective*, or *a coreflective inclusion*, if it is fully faithful and left\nadjoint.\n-/\nclass Coreflective (L : C ‚•§ D) extends L.Full, L.Faithful where\n  /-- a choice of a right adjoint to `L` -/\n  R : D ‚•§ C\n  /-- `L` is a left adjoint -/\n  adj : L ‚ä£ R\n\n"}
{"name":"CategoryTheory.Coreflective.toFull","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\nself : CategoryTheory.Coreflective L\n‚ä¢ L.Full","decl":"/--\nA functor is *coreflective*, or *a coreflective inclusion*, if it is fully faithful and left\nadjoint.\n-/\nclass Coreflective (L : C ‚•§ D) extends L.Full, L.Faithful where\n  /-- a choice of a right adjoint to `L` -/\n  R : D ‚•§ C\n  /-- `L` is a left adjoint -/\n  adj : L ‚ä£ R\n\n"}
{"name":"CategoryTheory.instIsLeftAdjointOfCoreflective","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nj : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Coreflective j\n‚ä¢ j.IsLeftAdjoint","decl":"instance [Coreflective j] : j.IsLeftAdjoint := ‚ü®_, ‚ü®coreflectorAdjunction j‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.instIsRightAdjointCoreflector","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nj : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Coreflective j\n‚ä¢ (CategoryTheory.coreflector j).IsRightAdjoint","decl":"instance [Coreflective j] : (coreflector j).IsRightAdjoint := ‚ü®_, ‚ü®coreflectorAdjunction j‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.counit_obj_eq_map_counit","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nj : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Coreflective j\nX : D\n‚ä¢ Eq ((CategoryTheory.coreflectorAdjunction j).counit.app (j.obj ((CategoryTheory.coreflector j).obj X))) (j.map ((CategoryTheory.coreflector j).map ((CategoryTheory.coreflectorAdjunction j).counit.app X)))","decl":"lemma counit_obj_eq_map_counit [Coreflective j] (X : D) :\n    (coreflectorAdjunction j).counit.app (j.obj ((coreflector j).obj X)) =\n      j.map ((coreflector j).map ((coreflectorAdjunction j).counit.app X)) := by\n  rw [‚Üê cancel_epi (j.map ((coreflectorAdjunction j).unit.app ((coreflector j).obj X))),\n    ‚Üê j.map_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.essImage.counit_isIso","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nj : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Coreflective j\nA : D\nh : Membership.mem j.essImage A\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.coreflectorAdjunction j).counit.app A)","decl":"lemma Functor.essImage.counit_isIso [Coreflective j] {A : D} (h : A ‚àà j.essImage) :\n    IsIso ((coreflectorAdjunction j).counit.app A) := by\n  rwa [isIso_counit_app_iff_mem_essImage]\n\n"}
{"name":"CategoryTheory.mem_essImage_of_counit_isSplitEpi","module":"Mathlib.CategoryTheory.Adjunction.Reflective","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nj : CategoryTheory.Functor C D\ninst‚úù¬π : CategoryTheory.Coreflective j\nA : D\ninst‚úù : CategoryTheory.IsSplitEpi ((CategoryTheory.coreflectorAdjunction j).counit.app A)\n‚ä¢ Membership.mem j.essImage A","decl":"lemma mem_essImage_of_counit_isSplitEpi [Coreflective j] {A : D}\n    [IsSplitEpi ((coreflectorAdjunction j).counit.app A)] : A ‚àà j.essImage := by\n  let Œµ : coreflector j ‚ãô j ‚ü∂ ùü≠ D  := (coreflectorAdjunction j).counit\n  haveI : IsIso (Œµ.app (j.obj ((coreflector j).obj A))) :=\n    Functor.essImage.counit_isIso ((j.obj_mem_essImage _))\n  have : Mono (Œµ.app A) := by\n    refine @mono_of_mono _ _ _ _ _ (Œµ.app A) (section_ (Œµ.app A)) ?_\n    rw [show Œµ.app A ‚â´ section_ _ = _ from (Œµ.naturality (section_ (Œµ.app A))).symm]\n    apply mono_comp _ (Œµ.app (j.obj ((coreflector j).obj A)))\n  haveI := isIso_of_mono_of_isSplitEpi (Œµ.app A)\n  exact (coreflectorAdjunction j).mem_essImage_of_counit_isIso A\n\n"}
