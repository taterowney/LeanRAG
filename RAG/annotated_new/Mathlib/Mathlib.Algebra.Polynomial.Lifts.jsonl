{"name":"Polynomial.mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts f) p) (Exists fun q => Eq (Polynomial.map f q) p)","decl":"theorem mem_lifts (p : S[X]) : p ∈ lifts f ↔ ∃ q : R[X], map f q = p := by\n  simp only [coe_mapRingHom, lifts, RingHom.mem_rangeS]\n\n"}
{"name":"Polynomial.lifts_iff_set_range","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts f) p) (Membership.mem (Set.range (Polynomial.map f)) p)","decl":"theorem lifts_iff_set_range (p : S[X]) : p ∈ lifts f ↔ p ∈ Set.range (map f) := by\n  simp only [coe_mapRingHom, lifts, Set.mem_range, RingHom.mem_rangeS]\n\n"}
{"name":"Polynomial.lifts_iff_ringHom_rangeS","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts f) p) (Membership.mem (Polynomial.mapRingHom f).rangeS p)","decl":"theorem lifts_iff_ringHom_rangeS (p : S[X]) : p ∈ lifts f ↔ p ∈ (mapRingHom f).rangeS := by\n  simp only [coe_mapRingHom, lifts, Set.mem_range, RingHom.mem_rangeS]\n\n"}
{"name":"Polynomial.lifts_iff_coeff_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts f) p) (∀ (n : Nat), Membership.mem (Set.range ⇑f) (p.coeff n))","decl":"theorem lifts_iff_coeff_lifts (p : S[X]) : p ∈ lifts f ↔ ∀ n : ℕ, p.coeff n ∈ Set.range f := by\n  rw [lifts_iff_ringHom_rangeS, mem_map_rangeS f]\n  rfl\n\n"}
{"name":"Polynomial.C_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\nr : R\n⊢ Membership.mem (Polynomial.lifts f) (Polynomial.C (f r))","decl":"/-- If `(r : R)`, then `C (f r)` lifts. -/\ntheorem C_mem_lifts (f : R →+* S) (r : R) : C (f r) ∈ lifts f :=\n  ⟨C r, by\n    simp only [coe_mapRingHom, map_C, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true,\n      and_self_iff]⟩\n\n"}
{"name":"Polynomial.C'_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\ns : S\nh : Membership.mem (Set.range ⇑f) s\n⊢ Membership.mem (Polynomial.lifts f) (Polynomial.C s)","decl":"/-- If `(s : S)` is in the image of `f`, then `C s` lifts. -/\ntheorem C'_mem_lifts {f : R →+* S} {s : S} (h : s ∈ Set.range f) : C s ∈ lifts f := by\n  obtain ⟨r, rfl⟩ := Set.mem_range.1 h\n  use C r\n  simp only [coe_mapRingHom, map_C, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true,\n    and_self_iff]\n\n"}
{"name":"Polynomial.X_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Membership.mem (Polynomial.lifts f) Polynomial.X","decl":"/-- The polynomial `X` lifts. -/\ntheorem X_mem_lifts (f : R →+* S) : (X : S[X]) ∈ lifts f :=\n  ⟨X, by\n    simp only [coe_mapRingHom, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true, map_X,\n      and_self_iff]⟩\n\n"}
{"name":"Polynomial.X_pow_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\nn : Nat\n⊢ Membership.mem (Polynomial.lifts f) (HPow.hPow Polynomial.X n)","decl":"/-- The polynomial `X ^ n` lifts. -/\ntheorem X_pow_mem_lifts (f : R →+* S) (n : ℕ) : (X ^ n : S[X]) ∈ lifts f :=\n  ⟨X ^ n, by\n    simp only [coe_mapRingHom, map_pow, Set.mem_univ, Subsemiring.coe_top, eq_self_iff_true,\n      map_X, and_self_iff]⟩\n\n"}
{"name":"Polynomial.base_mul_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\nr : R\nhp : Membership.mem (Polynomial.lifts f) p\n⊢ Membership.mem (Polynomial.lifts f) (HMul.hMul (Polynomial.C (f r)) p)","decl":"/-- If `p` lifts and `(r : R)` then `r * p` lifts. -/\ntheorem base_mul_mem_lifts {p : S[X]} (r : R) (hp : p ∈ lifts f) : C (f r) * p ∈ lifts f := by\n  simp only [lifts, RingHom.mem_rangeS] at hp ⊢\n  obtain ⟨p₁, rfl⟩ := hp\n  use C r * p₁\n  simp only [coe_mapRingHom, map_C, map_mul]\n\n"}
{"name":"Polynomial.monomial_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\ns : S\nn : Nat\nh : Membership.mem (Set.range ⇑f) s\n⊢ Membership.mem (Polynomial.lifts f) ((Polynomial.monomial n) s)","decl":"/-- If `(s : S)` is in the image of `f`, then `monomial n s` lifts. -/\ntheorem monomial_mem_lifts {s : S} (n : ℕ) (h : s ∈ Set.range f) : monomial n s ∈ lifts f := by\n  obtain ⟨r, rfl⟩ := Set.mem_range.1 h\n  use monomial n r\n  simp only [coe_mapRingHom, Set.mem_univ, map_monomial, Subsemiring.coe_top, eq_self_iff_true,\n    and_self_iff]\n\n"}
{"name":"Polynomial.erase_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\nn : Nat\nh : Membership.mem (Polynomial.lifts f) p\n⊢ Membership.mem (Polynomial.lifts f) (Polynomial.erase n p)","decl":"/-- If `p` lifts then `p.erase n` lifts. -/\ntheorem erase_mem_lifts {p : S[X]} (n : ℕ) (h : p ∈ lifts f) : p.erase n ∈ lifts f := by\n  rw [lifts_iff_ringHom_rangeS, mem_map_rangeS] at h ⊢\n  intro k\n  by_cases hk : k = n\n  · use 0\n    simp only [hk, RingHom.map_zero, erase_same]\n  obtain ⟨i, hi⟩ := h k\n  use i\n  simp only [hi, hk, erase_ne, Ne, not_false_iff]\n\n"}
{"name":"Polynomial.monomial_mem_lifts_and_degree_eq","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\ns : S\nn : Nat\nhl : Membership.mem (Polynomial.lifts f) ((Polynomial.monomial n) s)\n⊢ Exists fun q => And (Eq (Polynomial.map f q) ((Polynomial.monomial n) s)) (Eq q.degree ((Polynomial.monomial n) s).degree)","decl":"theorem monomial_mem_lifts_and_degree_eq {s : S} {n : ℕ} (hl : monomial n s ∈ lifts f) :\n    ∃ q : R[X], map f q = monomial n s ∧ q.degree = (monomial n s).degree := by\n  rcases eq_or_ne s 0 with rfl | h\n  · exact ⟨0, by simp⟩\n  obtain ⟨a, rfl⟩ := coeff_monomial_same n s ▸ (monomial n s).lifts_iff_coeff_lifts.mp hl n\n  refine ⟨monomial n a, map_monomial f, ?_⟩\n  rw [degree_monomial, degree_monomial n h]\n  exact mt (fun ha ↦ ha ▸ map_zero f) h\n\n"}
{"name":"Polynomial.mem_lifts_and_degree_eq","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\nhlifts : Membership.mem (Polynomial.lifts f) p\n⊢ Exists fun q => And (Eq (Polynomial.map f q) p) (Eq q.degree p.degree)","decl":"/-- A polynomial lifts if and only if it can be lifted to a polynomial of the same degree. -/\ntheorem mem_lifts_and_degree_eq {p : S[X]} (hlifts : p ∈ lifts f) :\n    ∃ q : R[X], map f q = p ∧ q.degree = p.degree := by\n  rw [lifts_iff_coeff_lifts] at hlifts\n  let g : ℕ → R := fun k ↦ (hlifts k).choose\n  have hg : ∀ k, f (g k) = p.coeff k := fun k ↦ (hlifts k).choose_spec\n  let q : R[X] := ∑ k ∈ p.support, monomial k (g k)\n  have hq : map f q = p := by simp_rw [q, Polynomial.map_sum, map_monomial, hg, ← as_sum_support]\n  have hq' : q.support = p.support := by\n    simp_rw [Finset.ext_iff, mem_support_iff, q, finset_sum_coeff, coeff_monomial,\n      Finset.sum_ite_eq', ite_ne_right_iff, mem_support_iff, and_iff_left_iff_imp, not_imp_not]\n    exact fun k h ↦ by rw [← hg, h, map_zero]\n  exact ⟨q, hq, congrArg Finset.max hq'⟩\n\n"}
{"name":"Polynomial.lifts_and_degree_eq_and_monic","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝² : Semiring R\nS : Type v\ninst✝¹ : Semiring S\nf : RingHom R S\ninst✝ : Nontrivial S\np : Polynomial S\nhlifts : Membership.mem (Polynomial.lifts f) p\nhp : p.Monic\n⊢ Exists fun q => And (Eq (Polynomial.map f q) p) (And (Eq q.degree p.degree) q.Monic)","decl":"/-- A monic polynomial lifts if and only if it can be lifted to a monic polynomial\nof the same degree. -/\ntheorem lifts_and_degree_eq_and_monic [Nontrivial S] {p : S[X]} (hlifts : p ∈ lifts f)\n    (hp : p.Monic) : ∃ q : R[X], map f q = p ∧ q.degree = p.degree ∧ q.Monic := by\n  rw [lifts_iff_coeff_lifts] at hlifts\n  let g : ℕ → R := fun k ↦ (hlifts k).choose\n  have hg k : f (g k) = p.coeff k := (hlifts k).choose_spec\n  let q : R[X] := X ^ p.natDegree + ∑ k ∈ Finset.range p.natDegree, C (g k) * X ^ k\n  have hq : map f q = p := by\n    simp_rw [q, Polynomial.map_add, Polynomial.map_sum, Polynomial.map_mul, Polynomial.map_pow,\n      map_X, map_C, hg, ← hp.as_sum]\n  have h : q.Monic := monic_X_pow_add (by simp_rw [← Fin.sum_univ_eq_sum_range, degree_sum_fin_lt])\n  exact ⟨q, hq, hq ▸ (h.degree_map f).symm, h⟩\n\n"}
{"name":"Polynomial.lifts_and_natDegree_eq_and_monic","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Semiring R\nS : Type v\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial S\nhlifts : Membership.mem (Polynomial.lifts f) p\nhp : p.Monic\n⊢ Exists fun q => And (Eq (Polynomial.map f q) p) (And (Eq q.natDegree p.natDegree) q.Monic)","decl":"theorem lifts_and_natDegree_eq_and_monic {p : S[X]} (hlifts : p ∈ lifts f) (hp : p.Monic) :\n    ∃ q : R[X], map f q = p ∧ q.natDegree = p.natDegree ∧ q.Monic := by\n  cases' subsingleton_or_nontrivial S with hR hR\n  · obtain rfl : p = 1 := Subsingleton.elim _ _\n    exact ⟨1, Subsingleton.elim _ _, by simp, by simp⟩\n  obtain ⟨p', h₁, h₂, h₃⟩ := lifts_and_degree_eq_and_monic hlifts hp\n  exact ⟨p', h₁, natDegree_eq_of_degree_eq h₂, h₃⟩\n\n"}
{"name":"Polynomial.lifts_iff_liftsRing","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝¹ : Ring R\nS : Type v\ninst✝ : Ring S\nf : RingHom R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts f) p) (Membership.mem (Polynomial.liftsRing f) p)","decl":"/-- If `R` and `S` are rings, `p` is in the subring of polynomials that lift if and only if it is in\nthe subsemiring of polynomials that lift. -/\ntheorem lifts_iff_liftsRing (p : S[X]) : p ∈ lifts f ↔ p ∈ liftsRing f := by\n  simp only [lifts, liftsRing, RingHom.mem_range, RingHom.mem_rangeS]\n\n"}
{"name":"Polynomial.mapAlg_eq_map","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type v\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial R\n⊢ Eq ((Polynomial.mapAlg R S) p) (Polynomial.map (algebraMap R S) p)","decl":"/-- `mapAlg` is the morphism induced by `R → S`. -/\ntheorem mapAlg_eq_map (p : R[X]) : mapAlg R S p = map (algebraMap R S) p := by\n  simp only [mapAlg, aeval_def, eval₂_eq_sum, map, algebraMap_apply, RingHom.coe_comp]\n  ext; congr\n\n"}
{"name":"Polynomial.mem_lifts_iff_mem_alg","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type v\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial S\n⊢ Iff (Membership.mem (Polynomial.lifts (algebraMap R S)) p) (Membership.mem (Polynomial.mapAlg R S).range p)","decl":"/-- A polynomial `p` lifts if and only if it is in the image of `mapAlg`. -/\ntheorem mem_lifts_iff_mem_alg (R : Type u) [CommSemiring R] {S : Type v} [Semiring S] [Algebra R S]\n    (p : S[X]) : p ∈ lifts (algebraMap R S) ↔ p ∈ AlgHom.range (@mapAlg R _ S _ _) := by\n  simp only [coe_mapRingHom, lifts, mapAlg_eq_map, AlgHom.mem_range, RingHom.mem_rangeS]\n\n"}
{"name":"Polynomial.smul_mem_lifts","module":"Mathlib.Algebra.Polynomial.Lifts","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Type v\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\np : Polynomial S\nr : R\nhp : Membership.mem (Polynomial.lifts (algebraMap R S)) p\n⊢ Membership.mem (Polynomial.lifts (algebraMap R S)) (HSMul.hSMul r p)","decl":"/-- If `p` lifts and `(r : R)` then `r • p` lifts. -/\ntheorem smul_mem_lifts {p : S[X]} (r : R) (hp : p ∈ lifts (algebraMap R S)) :\n    r • p ∈ lifts (algebraMap R S) := by\n  rw [mem_lifts_iff_mem_alg] at hp ⊢\n  exact Subalgebra.smul_mem (mapAlg R S).range hp r\n\n"}
