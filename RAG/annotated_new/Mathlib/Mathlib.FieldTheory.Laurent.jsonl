{"name":"RatFunc.taylor_mem_nonZeroDivisors","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝ : CommRing R\nr : R\np : Polynomial R\nhp : Membership.mem (nonZeroDivisors (Polynomial R)) p\n⊢ Membership.mem (nonZeroDivisors (Polynomial R)) ((Polynomial.taylor r) p)","decl":"theorem taylor_mem_nonZeroDivisors (hp : p ∈ R[X]⁰) : taylor r p ∈ R[X]⁰ := by\n  rw [mem_nonZeroDivisors_iff]\n  intro x hx\n  have : x = taylor (r - r) x := by simp\n  rwa [this, sub_eq_add_neg, ← taylor_taylor, ← taylor_mul,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _), mul_right_mem_nonZeroDivisors_eq_zero_iff hp,\n    LinearMap.map_eq_zero_iff _ (taylor_injective _)] at hx\n\n"}
{"name":"RatFunc.laurentAux_ofFractionRing_mk","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝ : CommRing R\nr : R\np : Polynomial R\nq : Subtype fun x => Membership.mem (nonZeroDivisors (Polynomial R)) x\n⊢ Eq ((RatFunc.laurentAux r) { toFractionRing := Localization.mk p q }) { toFractionRing := Localization.mk ((Polynomial.taylor r) p) ⟨(Polynomial.taylor r) ↑q, ⋯⟩ }","decl":"theorem laurentAux_ofFractionRing_mk (q : R[X]⁰) :\n    laurentAux r (ofFractionRing (Localization.mk p q)) =\n      ofFractionRing (.mk (taylor r p) ⟨taylor r q, taylor_mem_nonZeroDivisors r q q.prop⟩) :=\n  map_apply_ofFractionRing_mk _ _ _ _\n\n"}
{"name":"RatFunc.laurentAux_div","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\np q : Polynomial R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurentAux r) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) p) ((algebraMap (Polynomial R) (RatFunc R)) q))) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) p)) ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) q)))","decl":"theorem laurentAux_div :\n    laurentAux r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  -- Porting note: added `by exact taylor_mem_nonZeroDivisors r`\n  map_apply_div _ (by exact taylor_mem_nonZeroDivisors r) _ _\n\n"}
{"name":"RatFunc.laurentAux_algebraMap","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\np : Polynomial R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurentAux r) ((algebraMap (Polynomial R) (RatFunc R)) p)) ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) p))","decl":"@[simp]\ntheorem laurentAux_algebraMap : laurentAux r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) := by\n  rw [← mk_one, ← mk_one, mk_eq_div, laurentAux_div, mk_eq_div, taylor_one, map_one, map_one]\n\n"}
{"name":"RatFunc.laurent_div","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\np q : Polynomial R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurent r) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) p) ((algebraMap (Polynomial R) (RatFunc R)) q))) (HDiv.hDiv ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) p)) ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) q)))","decl":"theorem laurent_div :\n    laurent r (algebraMap _ _ p / algebraMap _ _ q) =\n      algebraMap _ _ (taylor r p) / algebraMap _ _ (taylor r q) :=\n  laurentAux_div r p q\n\n"}
{"name":"RatFunc.laurent_algebraMap","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\np : Polynomial R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurent r) ((algebraMap (Polynomial R) (RatFunc R)) p)) ((algebraMap (Polynomial R) (RatFunc R)) ((Polynomial.taylor r) p))","decl":"@[simp]\ntheorem laurent_algebraMap : laurent r (algebraMap _ _ p) = algebraMap _ _ (taylor r p) :=\n  laurentAux_algebraMap _ _\n\n"}
{"name":"RatFunc.laurent_X","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurent r) RatFunc.X) (HAdd.hAdd RatFunc.X (RatFunc.C r))","decl":"@[simp]\ntheorem laurent_X : laurent r X = X + C r := by\n  rw [← algebraMap_X, laurent_algebraMap, taylor_X, _root_.map_add, algebraMap_C]\n\n"}
{"name":"RatFunc.laurent_C","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\ninst✝ : IsDomain R\nx : R\n⊢ Eq ((RatFunc.laurent r) (RatFunc.C x)) (RatFunc.C x)","decl":"@[simp]\ntheorem laurent_C (x : R) : laurent r (C x) = C x := by\n  rw [← algebraMap_C, laurent_algebraMap, taylor_C]\n\n"}
{"name":"RatFunc.laurent_at_zero","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nf : RatFunc R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurent 0) f) f","decl":"@[simp]\ntheorem laurent_at_zero : laurent 0 f = f := by induction f using RatFunc.induction_on; simp\n\n"}
{"name":"RatFunc.laurent_laurent","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr s : R\nf : RatFunc R\ninst✝ : IsDomain R\n⊢ Eq ((RatFunc.laurent r) ((RatFunc.laurent s) f)) ((RatFunc.laurent (HAdd.hAdd r s)) f)","decl":"theorem laurent_laurent : laurent r (laurent s f) = laurent (r + s) f := by\n  induction f using RatFunc.induction_on\n  simp_rw [laurent_div, taylor_taylor]\n\n"}
{"name":"RatFunc.laurent_injective","module":"Mathlib.FieldTheory.Laurent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nr : R\ninst✝ : IsDomain R\n⊢ Function.Injective ⇑(RatFunc.laurent r)","decl":"theorem laurent_injective : Function.Injective (laurent r) := fun _ _ h => by\n  simpa [laurent_laurent] using congr_arg (laurent (-r)) h\n\n"}
