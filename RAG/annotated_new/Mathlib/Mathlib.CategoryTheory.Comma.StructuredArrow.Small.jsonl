{"name":"CategoryTheory.StructuredArrow.small_proj_preimage_of_locallySmall","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Small","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nùí¢ : Set C\ninst‚úù¬π : Small.{v‚ÇÅ, u‚ÇÅ} ‚Üëùí¢\ninst‚úù : CategoryTheory.LocallySmall.{v‚ÇÅ, v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Small.{v‚ÇÅ, max u‚ÇÅ v‚ÇÇ} ‚Üë(Set.preimage (CategoryTheory.StructuredArrow.proj S T).obj ùí¢)","decl":"instance small_proj_preimage_of_locallySmall {ùí¢ : Set C} [Small.{v‚ÇÅ} ùí¢] [LocallySmall.{v‚ÇÅ} D] :\n    Small.{v‚ÇÅ} ((proj S T).obj ‚Åª¬π' ùí¢) := by\n  suffices (proj S T).obj ‚Åª¬π' ùí¢ = Set.range fun f : Œ£G : ùí¢, S ‚ü∂ T.obj G => mk f.2 by\n    rw [this]\n    infer_instance\n  exact Set.ext fun X => ‚ü®fun h => ‚ü®‚ü®‚ü®_, h‚ü©, X.hom‚ü©, (eq_mk _).symm‚ü©, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.small_proj_preimage_of_locallySmall","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Small","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor C D\nT : D\nùí¢ : Set C\ninst‚úù¬π : Small.{v‚ÇÅ, u‚ÇÅ} ‚Üëùí¢\ninst‚úù : CategoryTheory.LocallySmall.{v‚ÇÅ, v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Small.{v‚ÇÅ, max u‚ÇÅ v‚ÇÇ} ‚Üë(Set.preimage (CategoryTheory.CostructuredArrow.proj S T).obj ùí¢)","decl":"instance small_proj_preimage_of_locallySmall {ùí¢ : Set C} [Small.{v‚ÇÅ} ùí¢] [LocallySmall.{v‚ÇÅ} D] :\n    Small.{v‚ÇÅ} ((proj S T).obj ‚Åª¬π' ùí¢) := by\n  suffices (proj S T).obj ‚Åª¬π' ùí¢ = Set.range fun f : Œ£G : ùí¢, S.obj G ‚ü∂ T => mk f.2 by\n    rw [this]\n    infer_instance\n  exact Set.ext fun X => ‚ü®fun h => ‚ü®‚ü®‚ü®_, h‚ü©, X.hom‚ü©, (eq_mk _).symm‚ü©, by aesop_cat‚ü©\n\n"}
