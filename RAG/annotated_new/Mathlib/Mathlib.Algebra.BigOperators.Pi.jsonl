{"name":"Pi.list_sum_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\ninst✝ : (a : α) → AddMonoid (β a)\na : α\nl : List ((a : α) → β a)\n⊢ Eq (l.sum a) (List.map (fun f => f a) l).sum","decl":"@[to_additive]\ntheorem list_prod_apply {α : Type*} {β : α → Type*} [∀ a, Monoid (β a)] (a : α)\n    (l : List (∀ a, β a)) : l.prod a = (l.map fun f : ∀ a, β a ↦ f a).prod :=\n  map_list_prod (evalMonoidHom β a) _\n\n"}
{"name":"Pi.list_prod_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\ninst✝ : (a : α) → Monoid (β a)\na : α\nl : List ((a : α) → β a)\n⊢ Eq (l.prod a) (List.map (fun f => f a) l).prod","decl":"@[to_additive]\ntheorem list_prod_apply {α : Type*} {β : α → Type*} [∀ a, Monoid (β a)] (a : α)\n    (l : List (∀ a, β a)) : l.prod a = (l.map fun f : ∀ a, β a ↦ f a).prod :=\n  map_list_prod (evalMonoidHom β a) _\n\n"}
{"name":"Pi.multiset_sum_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\ninst✝ : (a : α) → AddCommMonoid (β a)\na : α\ns : Multiset ((a : α) → β a)\n⊢ Eq (s.sum a) (Multiset.map (fun f => f a) s).sum","decl":"@[to_additive]\ntheorem multiset_prod_apply {α : Type*} {β : α → Type*} [∀ a, CommMonoid (β a)] (a : α)\n    (s : Multiset (∀ a, β a)) : s.prod a = (s.map fun f : ∀ a, β a ↦ f a).prod :=\n  (evalMonoidHom β a).map_multiset_prod _\n\n"}
{"name":"Pi.multiset_prod_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\ninst✝ : (a : α) → CommMonoid (β a)\na : α\ns : Multiset ((a : α) → β a)\n⊢ Eq (s.prod a) (Multiset.map (fun f => f a) s).prod","decl":"@[to_additive]\ntheorem multiset_prod_apply {α : Type*} {β : α → Type*} [∀ a, CommMonoid (β a)] (a : α)\n    (s : Multiset (∀ a, β a)) : s.prod a = (s.map fun f : ∀ a, β a ↦ f a).prod :=\n  (evalMonoidHom β a).map_multiset_prod _\n\n"}
{"name":"Finset.sum_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝ : (a : α) → AddCommMonoid (β a)\na : α\ns : Finset γ\ng : γ → (a : α) → β a\n⊢ Eq (s.sum (fun c => g c) a) (s.sum fun c => g c a)","decl":"@[to_additive (attr := simp)]\ntheorem Finset.prod_apply {α : Type*} {β : α → Type*} {γ} [∀ a, CommMonoid (β a)] (a : α)\n    (s : Finset γ) (g : γ → ∀ a, β a) : (∏ c ∈ s, g c) a = ∏ c ∈ s, g c a :=\n  map_prod (Pi.evalMonoidHom β a) _ _\n\n"}
{"name":"Finset.prod_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝ : (a : α) → CommMonoid (β a)\na : α\ns : Finset γ\ng : γ → (a : α) → β a\n⊢ Eq (s.prod (fun c => g c) a) (s.prod fun c => g c a)","decl":"@[to_additive (attr := simp)]\ntheorem Finset.prod_apply {α : Type*} {β : α → Type*} {γ} [∀ a, CommMonoid (β a)] (a : α)\n    (s : Finset γ) (g : γ → ∀ a, β a) : (∏ c ∈ s, g c) a = ∏ c ∈ s, g c a :=\n  map_prod (Pi.evalMonoidHom β a) _ _\n\n"}
{"name":"Finset.prod_fn","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝ : (a : α) → CommMonoid (β a)\ns : Finset γ\ng : γ → (a : α) → β a\n⊢ Eq (s.prod fun c => g c) fun a => s.prod fun c => g c a","decl":"/-- An 'unapplied' analogue of `Finset.prod_apply`. -/\n@[to_additive \"An 'unapplied' analogue of `Finset.sum_apply`.\"]\ntheorem Finset.prod_fn {α : Type*} {β : α → Type*} {γ} [∀ a, CommMonoid (β a)] (s : Finset γ)\n    (g : γ → ∀ a, β a) : ∏ c ∈ s, g c = fun a ↦ ∏ c ∈ s, g c a :=\n  funext fun _ ↦ Finset.prod_apply _ _ _\n\n"}
{"name":"Finset.sum_fn","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝ : (a : α) → AddCommMonoid (β a)\ns : Finset γ\ng : γ → (a : α) → β a\n⊢ Eq (s.sum fun c => g c) fun a => s.sum fun c => g c a","decl":"/-- An 'unapplied' analogue of `Finset.prod_apply`. -/\n@[to_additive \"An 'unapplied' analogue of `Finset.sum_apply`.\"]\ntheorem Finset.prod_fn {α : Type*} {β : α → Type*} {γ} [∀ a, CommMonoid (β a)] (s : Finset γ)\n    (g : γ → ∀ a, β a) : ∏ c ∈ s, g c = fun a ↦ ∏ c ∈ s, g c a :=\n  funext fun _ ↦ Finset.prod_apply _ _ _\n\n"}
{"name":"Fintype.sum_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝¹ : Fintype γ\ninst✝ : (a : α) → AddCommMonoid (β a)\na : α\ng : γ → (a : α) → β a\n⊢ Eq (Finset.univ.sum (fun c => g c) a) (Finset.univ.sum fun c => g c a)","decl":"@[to_additive]\ntheorem Fintype.prod_apply {α : Type*} {β : α → Type*} {γ : Type*} [Fintype γ]\n    [∀ a, CommMonoid (β a)] (a : α) (g : γ → ∀ a, β a) : (∏ c, g c) a = ∏ c, g c a :=\n  Finset.prod_apply a Finset.univ g\n\n"}
{"name":"Fintype.prod_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : α → Type u_5\nγ : Type u_6\ninst✝¹ : Fintype γ\ninst✝ : (a : α) → CommMonoid (β a)\na : α\ng : γ → (a : α) → β a\n⊢ Eq (Finset.univ.prod (fun c => g c) a) (Finset.univ.prod fun c => g c a)","decl":"@[to_additive]\ntheorem Fintype.prod_apply {α : Type*} {β : α → Type*} {γ : Type*} [Fintype γ]\n    [∀ a, CommMonoid (β a)] (a : α) (g : γ → ∀ a, β a) : (∏ c, g c) a = ∏ c, g c a :=\n  Finset.prod_apply a Finset.univ g\n\n"}
{"name":"prod_mk_sum","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Finset γ\nf : γ → α\ng : γ → β\n⊢ Eq { fst := s.sum fun x => f x, snd := s.sum fun x => g x } (s.sum fun x => { fst := f x, snd := g x })","decl":"@[to_additive prod_mk_sum]\ntheorem prod_mk_prod {α β γ : Type*} [CommMonoid α] [CommMonoid β] (s : Finset γ) (f : γ → α)\n    (g : γ → β) : (∏ x ∈ s, f x, ∏ x ∈ s, g x) = ∏ x ∈ s, (f x, g x) :=\n  haveI := Classical.decEq γ\n  Finset.induction_on s rfl (by simp +contextual [Prod.ext_iff])\n\n"}
{"name":"prod_mk_prod","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Finset γ\nf : γ → α\ng : γ → β\n⊢ Eq { fst := s.prod fun x => f x, snd := s.prod fun x => g x } (s.prod fun x => { fst := f x, snd := g x })","decl":"@[to_additive prod_mk_sum]\ntheorem prod_mk_prod {α β γ : Type*} [CommMonoid α] [CommMonoid β] (s : Finset γ) (f : γ → α)\n    (g : γ → β) : (∏ x ∈ s, f x, ∏ x ∈ s, g x) = ∏ x ∈ s, (f x, g x) :=\n  haveI := Classical.decEq γ\n  Finset.induction_on s rfl (by simp +contextual [Prod.ext_iff])\n\n"}
{"name":"pi_eq_sum_univ","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_4\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\nR : Type u_5\ninst✝ : Semiring R\nx : ι → R\n⊢ Eq x (Finset.univ.sum fun i => HSMul.hSMul (x i) fun j => ite (Eq i j) 1 0)","decl":"/-- decomposing `x : ι → R` as a sum along the canonical basis -/\ntheorem pi_eq_sum_univ {ι : Type*} [Fintype ι] [DecidableEq ι] {R : Type*} [Semiring R]\n    (x : ι → R) : x = ∑ i, (x i) • fun j => if i = j then (1 : R) else 0 := by\n  ext\n  simp\n\n"}
{"name":"prod_indicator_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\nf : ι → Set κ\ng : ι → κ → α\nj : κ\n⊢ Eq (s.prod fun i => (f i).indicator (g i) j) ((Set.iInter fun x => Set.iInter fun h => f x).indicator (s.prod fun i => g i) j)","decl":"lemma prod_indicator_apply (s : Finset ι) (f : ι → Set κ) (g : ι → κ → α) (j : κ) :\n    ∏ i ∈ s, (f i).indicator (g i) j = (⋂ x ∈ s, f x).indicator (∏ i ∈ s, g i) j := by\n  rw [Set.indicator]\n  split_ifs with hj\n  · rw [Finset.prod_apply]\n    congr! 1 with i hi\n    simp only [Finset.inf_set_eq_iInter, Set.mem_iInter] at hj\n    exact Set.indicator_of_mem (hj _ hi) _\n  · obtain ⟨i, hi, hj⟩ := by simpa using hj\n    exact Finset.prod_eq_zero hi <| Set.indicator_of_not_mem hj _\n\n"}
{"name":"prod_indicator","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\nf : ι → Set κ\ng : ι → κ → α\n⊢ Eq (s.prod fun i => (f i).indicator (g i)) ((Set.iInter fun x => Set.iInter fun h => f x).indicator (s.prod fun i => g i))","decl":"lemma prod_indicator (s : Finset ι) (f : ι → Set κ) (g : ι → κ → α) :\n    ∏ i ∈ s, (f i).indicator (g i) = (⋂ x ∈ s, f x).indicator (∏ i ∈ s, g i) := by\n  ext a; simpa using prod_indicator_apply ..\n\n"}
{"name":"prod_indicator_const_apply","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\nf : ι → Set κ\ng : κ → α\nj : κ\n⊢ Eq (s.prod fun i => (f i).indicator g j) ((Set.iInter fun x => Set.iInter fun h => f x).indicator (HPow.hPow g s.card) j)","decl":"lemma prod_indicator_const_apply (s : Finset ι) (f : ι → Set κ) (g : κ → α) (j : κ) :\n    ∏ i ∈ s, (f i).indicator g j = (⋂ x ∈ s, f x).indicator (g ^ #s) j := by\n  simp [prod_indicator_apply]\n\n"}
{"name":"prod_indicator_const","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\nκ : Type u_2\nα : Type u_3\ninst✝ : CommSemiring α\ns : Finset ι\nf : ι → Set κ\ng : κ → α\n⊢ Eq (s.prod fun i => (f i).indicator g) ((Set.iInter fun x => Set.iInter fun h => f x).indicator (HPow.hPow g s.card))","decl":"lemma prod_indicator_const (s : Finset ι) (f : ι → Set κ) (g : κ → α) :\n    ∏ i ∈ s, (f i).indicator g = (⋂ x ∈ s, f x).indicator (g ^ #s) := by simp [prod_indicator]\n\n"}
{"name":"Finset.univ_sum_single","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝² : DecidableEq I\nZ : I → Type u_5\ninst✝¹ : (i : I) → AddCommMonoid (Z i)\ninst✝ : Fintype I\nf : (i : I) → Z i\n⊢ Eq (Finset.univ.sum fun i => Pi.single i (f i)) f","decl":"@[to_additive]\ntheorem Finset.univ_prod_mulSingle [Fintype I] (f : ∀ i, Z i) :\n    (∏ i, Pi.mulSingle i (f i)) = f := by\n  ext a\n  simp\n\n"}
{"name":"Finset.univ_prod_mulSingle","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝² : DecidableEq I\nZ : I → Type u_5\ninst✝¹ : (i : I) → CommMonoid (Z i)\ninst✝ : Fintype I\nf : (i : I) → Z i\n⊢ Eq (Finset.univ.prod fun i => Pi.mulSingle i (f i)) f","decl":"@[to_additive]\ntheorem Finset.univ_prod_mulSingle [Fintype I] (f : ∀ i, Z i) :\n    (∏ i, Pi.mulSingle i (f i)) = f := by\n  ext a\n  simp\n\n"}
{"name":"MonoidHom.functions_ext","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → CommMonoid (Z i)\ninst✝¹ : Finite I\nG : Type u_6\ninst✝ : CommMonoid G\ng h : MonoidHom ((i : I) → Z i) G\nH : ∀ (i : I) (x : Z i), Eq (g (Pi.mulSingle i x)) (h (Pi.mulSingle i x))\n⊢ Eq g h","decl":"@[to_additive]\ntheorem MonoidHom.functions_ext [Finite I] (G : Type*) [CommMonoid G] (g h : (∀ i, Z i) →* G)\n    (H : ∀ i x, g (Pi.mulSingle i x) = h (Pi.mulSingle i x)) : g = h := by\n  cases nonempty_fintype I\n  ext k\n  rw [← Finset.univ_prod_mulSingle k, map_prod, map_prod]\n  simp only [H]\n\n"}
{"name":"AddMonoidHom.functions_ext","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → AddCommMonoid (Z i)\ninst✝¹ : Finite I\nG : Type u_6\ninst✝ : AddCommMonoid G\ng h : AddMonoidHom ((i : I) → Z i) G\nH : ∀ (i : I) (x : Z i), Eq (g (Pi.single i x)) (h (Pi.single i x))\n⊢ Eq g h","decl":"@[to_additive]\ntheorem MonoidHom.functions_ext [Finite I] (G : Type*) [CommMonoid G] (g h : (∀ i, Z i) →* G)\n    (H : ∀ i x, g (Pi.mulSingle i x) = h (Pi.mulSingle i x)) : g = h := by\n  cases nonempty_fintype I\n  ext k\n  rw [← Finset.univ_prod_mulSingle k, map_prod, map_prod]\n  simp only [H]\n\n"}
{"name":"MonoidHom.functions_ext'","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → CommMonoid (Z i)\ninst✝¹ : Finite I\nM : Type u_6\ninst✝ : CommMonoid M\ng h : MonoidHom ((i : I) → Z i) M\nH : ∀ (i : I), Eq (g.comp (MonoidHom.mulSingle Z i)) (h.comp (MonoidHom.mulSingle Z i))\n⊢ Eq g h","decl":"/-- This is used as the ext lemma instead of `MonoidHom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext)\n      \"\\nThis is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons\n      explained in note [partially-applied ext lemmas].\"]\ntheorem MonoidHom.functions_ext' [Finite I] (M : Type*) [CommMonoid M] (g h : (∀ i, Z i) →* M)\n    (H : ∀ i, g.comp (MonoidHom.mulSingle Z i) = h.comp (MonoidHom.mulSingle Z i)) : g = h :=\n  g.functions_ext M h fun i => DFunLike.congr_fun (H i)\n\n"}
{"name":"AddMonoidHom.functions_ext'","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → AddCommMonoid (Z i)\ninst✝¹ : Finite I\nM : Type u_6\ninst✝ : AddCommMonoid M\ng h : AddMonoidHom ((i : I) → Z i) M\nH : ∀ (i : I), Eq (g.comp (AddMonoidHom.single Z i)) (h.comp (AddMonoidHom.single Z i))\n⊢ Eq g h","decl":"/-- This is used as the ext lemma instead of `MonoidHom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext)\n      \"\\nThis is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons\n      explained in note [partially-applied ext lemmas].\"]\ntheorem MonoidHom.functions_ext' [Finite I] (M : Type*) [CommMonoid M] (g h : (∀ i, Z i) →* M)\n    (H : ∀ i, g.comp (MonoidHom.mulSingle Z i) = h.comp (MonoidHom.mulSingle Z i)) : g = h :=\n  g.functions_ext M h fun i => DFunLike.congr_fun (H i)\n\n"}
{"name":"AddMonoidHom.functions_ext'_iff","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → AddCommMonoid (Z i)\ninst✝¹ : Finite I\nM : Type u_6\ninst✝ : AddCommMonoid M\ng h : AddMonoidHom ((i : I) → Z i) M\n⊢ Iff (Eq g h) (∀ (i : I), Eq (g.comp (AddMonoidHom.single Z i)) (h.comp (AddMonoidHom.single Z i)))","decl":"/-- This is used as the ext lemma instead of `MonoidHom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext)\n      \"\\nThis is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons\n      explained in note [partially-applied ext lemmas].\"]\ntheorem MonoidHom.functions_ext' [Finite I] (M : Type*) [CommMonoid M] (g h : (∀ i, Z i) →* M)\n    (H : ∀ i, g.comp (MonoidHom.mulSingle Z i) = h.comp (MonoidHom.mulSingle Z i)) : g = h :=\n  g.functions_ext M h fun i => DFunLike.congr_fun (H i)\n\n"}
{"name":"MonoidHom.functions_ext'_iff","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nZ : I → Type u_5\ninst✝² : (i : I) → CommMonoid (Z i)\ninst✝¹ : Finite I\nM : Type u_6\ninst✝ : CommMonoid M\ng h : MonoidHom ((i : I) → Z i) M\n⊢ Iff (Eq g h) (∀ (i : I), Eq (g.comp (MonoidHom.mulSingle Z i)) (h.comp (MonoidHom.mulSingle Z i)))","decl":"/-- This is used as the ext lemma instead of `MonoidHom.functions_ext` for reasons explained in\nnote [partially-applied ext lemmas]. -/\n@[to_additive (attr := ext)\n      \"\\nThis is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons\n      explained in note [partially-applied ext lemmas].\"]\ntheorem MonoidHom.functions_ext' [Finite I] (M : Type*) [CommMonoid M] (g h : (∀ i, Z i) →* M)\n    (H : ∀ i, g.comp (MonoidHom.mulSingle Z i) = h.comp (MonoidHom.mulSingle Z i)) : g = h :=\n  g.functions_ext M h fun i => DFunLike.congr_fun (H i)\n\n"}
{"name":"RingHom.functions_ext","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nf : I → Type u_5\ninst✝² : (i : I) → NonAssocSemiring (f i)\ninst✝¹ : Finite I\nG : Type u_6\ninst✝ : NonAssocSemiring G\ng h : RingHom ((i : I) → f i) G\nH : ∀ (i : I) (x : f i), Eq (g (Pi.single i x)) (h (Pi.single i x))\n⊢ Eq g h","decl":"@[ext]\ntheorem RingHom.functions_ext [Finite I] (G : Type*) [NonAssocSemiring G] (g h : (∀ i, f i) →+* G)\n    (H : ∀ (i : I) (x : f i), g (single i x) = h (single i x)) : g = h :=\n  RingHom.coe_addMonoidHom_injective <|\n    @AddMonoidHom.functions_ext I _ f _ _ G _ (g : (∀ i, f i) →+ G) h H\n\n"}
{"name":"RingHom.functions_ext_iff","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"I : Type u_4\ninst✝³ : DecidableEq I\nf : I → Type u_5\ninst✝² : (i : I) → NonAssocSemiring (f i)\ninst✝¹ : Finite I\nG : Type u_6\ninst✝ : NonAssocSemiring G\ng h : RingHom ((i : I) → f i) G\n⊢ Iff (Eq g h) (∀ (i : I) (x : f i), Eq (g (Pi.single i x)) (h (Pi.single i x)))","decl":"@[ext]\ntheorem RingHom.functions_ext [Finite I] (G : Type*) [NonAssocSemiring G] (g h : (∀ i, f i) →+* G)\n    (H : ∀ (i : I) (x : f i), g (single i x) = h (single i x)) : g = h :=\n  RingHom.coe_addMonoidHom_injective <|\n    @AddMonoidHom.functions_ext I _ f _ _ G _ (g : (∀ i, f i) →+ G) h H\n\n"}
{"name":"Prod.fst_prod","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Finset γ\nf : γ → Prod α β\n⊢ Eq (s.prod fun c => f c).1 (s.prod fun c => (f c).1)","decl":"@[to_additive]\ntheorem fst_prod : (∏ c ∈ s, f c).1 = ∏ c ∈ s, (f c).1 :=\n  map_prod (MonoidHom.fst α β) f s\n\n"}
{"name":"Prod.fst_sum","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Finset γ\nf : γ → Prod α β\n⊢ Eq (s.sum fun c => f c).1 (s.sum fun c => (f c).1)","decl":"@[to_additive]\ntheorem fst_prod : (∏ c ∈ s, f c).1 = ∏ c ∈ s, (f c).1 :=\n  map_prod (MonoidHom.fst α β) f s\n\n"}
{"name":"Prod.snd_prod","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Finset γ\nf : γ → Prod α β\n⊢ Eq (s.prod fun c => f c).2 (s.prod fun c => (f c).2)","decl":"@[to_additive]\ntheorem snd_prod : (∏ c ∈ s, f c).2 = ∏ c ∈ s, (f c).2 :=\n  map_prod (MonoidHom.snd α β) f s\n\n"}
{"name":"Prod.snd_sum","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Finset γ\nf : γ → Prod α β\n⊢ Eq (s.sum fun c => f c).2 (s.sum fun c => (f c).2)","decl":"@[to_additive]\ntheorem snd_prod : (∏ c ∈ s, f c).2 = ∏ c ∈ s, (f c).2 :=\n  map_prod (MonoidHom.snd α β) f s\n\n"}
{"name":"Pi.single_induction","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\nM : Type u_4\ninst✝ : AddCommMonoid M\np : (ι → M) → Prop\nf : ι → M\nzero : p 0\nadd : ∀ (f g : ι → M), p f → p g → p (HAdd.hAdd f g)\nsingle : ∀ (i : ι) (m : M), p (Pi.single i m)\n⊢ p f","decl":"lemma Pi.single_induction [AddCommMonoid M] (p : (ι → M) → Prop) (f : ι → M)\n    (zero : p 0) (add : ∀ f g, p f → p g → p (f + g))\n    (single : ∀ i m, p (Pi.single i m)) : p f := by\n  cases nonempty_fintype ι\n  rw [← Finset.univ_sum_single f]\n  exact Finset.sum_induction _ _ add zero (by simp [single])\n\n"}
{"name":"Pi.mulSingle_induction","module":"Mathlib.Algebra.BigOperators.Pi","initialProofState":"ι : Type u_1\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\nM : Type u_4\ninst✝ : CommMonoid M\np : (ι → M) → Prop\nf : ι → M\none : p 1\nmul : ∀ (f g : ι → M), p f → p g → p (HMul.hMul f g)\nmulSingle : ∀ (i : ι) (m : M), p (Pi.mulSingle i m)\n⊢ p f","decl":"@[to_additive (attr := elab_as_elim) existing]\nlemma Pi.mulSingle_induction [CommMonoid M] (p : (ι → M) → Prop) (f : ι → M)\n    (one : p 1) (mul : ∀ f g, p f → p g → p (f * g))\n    (mulSingle : ∀ i m, p (Pi.mulSingle i m)) : p f := by\n  cases nonempty_fintype ι\n  rw [← Finset.univ_prod_mulSingle f]\n  exact Finset.prod_induction _ _ mul one (by simp [mulSingle])\n"}
