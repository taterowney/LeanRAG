{"name":"CategoryTheory.EssentiallySmall.equiv_smallCategory","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.EssentiallySmall.{w, v, u} C\n‚ä¢ Exists fun S => Exists fun x => Nonempty (CategoryTheory.Equivalence C S)","decl":"/-- A category is `EssentiallySmall.{w}` if there exists\nan equivalence to some `S : Type w` with `[SmallCategory S]`. -/\n@[pp_with_univ]\nclass EssentiallySmall (C : Type u) [Category.{v} C] : Prop where\n  /-- An essentially small category is equivalent to some small category. -/\n  equiv_smallCategory : ‚àÉ (S : Type w) (_ : SmallCategory S), Nonempty (C ‚âå S)\n\n"}
{"name":"CategoryTheory.EssentiallySmall.mk'","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nS : Type w\ninst‚úù : CategoryTheory.SmallCategory S\ne : CategoryTheory.Equivalence C S\n‚ä¢ CategoryTheory.EssentiallySmall.{w, v, u} C","decl":"/-- Constructor for `EssentiallySmall C` from an explicit small category witness. -/\ntheorem EssentiallySmall.mk' {C : Type u} [Category.{v} C] {S : Type w} [SmallCategory S]\n    (e : C ‚âå S) : EssentiallySmall.{w} C :=\n  ‚ü®‚ü®S, _, ‚ü®e‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.instEssentiallySmallOpposite","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.EssentiallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.EssentiallySmall.{w, v, u} (Opposite C)","decl":"instance (C : Type u) [Category.{v} C] [EssentiallySmall.{w} C] : EssentiallySmall.{w} C·µí·µñ :=\n  EssentiallySmall.mk' (equivSmallModel C).op\n\n"}
{"name":"CategoryTheory.essentiallySmall_congr","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Iff (CategoryTheory.EssentiallySmall.{w, v, u} C) (CategoryTheory.EssentiallySmall.{w, v', u'} D)","decl":"theorem essentiallySmall_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (e : C ‚âå D) : EssentiallySmall.{w} C ‚Üî EssentiallySmall.{w} D := by\n  fconstructor\n  ¬∑ rintro ‚ü®S, ùíÆ, ‚ü®f‚ü©‚ü©\n    exact EssentiallySmall.mk' (e.symm.trans f)\n  ¬∑ rintro ‚ü®S, ùíÆ, ‚ü®f‚ü©‚ü©\n    exact EssentiallySmall.mk' (e.trans f)\n\n"}
{"name":"CategoryTheory.Discrete.essentiallySmallOfSmall","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"Œ± : Type u\ninst‚úù : Small.{w, u} Œ±\n‚ä¢ CategoryTheory.EssentiallySmall.{w, u, u} (CategoryTheory.Discrete Œ±)","decl":"theorem Discrete.essentiallySmallOfSmall {Œ± : Type u} [Small.{w} Œ±] :\n    EssentiallySmall.{w} (Discrete Œ±) :=\n  ‚ü®‚ü®Discrete (Shrink Œ±), ‚ü®inferInstance, ‚ü®Discrete.equivalence (equivShrink _)‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.essentiallySmallSelf","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.EssentiallySmall.{max w v u, v, u} C","decl":"theorem essentiallySmallSelf : EssentiallySmall.{max w v u} C :=\n  EssentiallySmall.mk' (AsSmall.equiv : C ‚âå AsSmall.{w} C)\n\n"}
{"name":"CategoryTheory.LocallySmall.hom_small","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.LocallySmall.{w, v, u} C\nX Y : C\n‚ä¢ Small.{w, v} (Quiver.Hom X Y)","decl":"/-- A category is `w`-locally small if every hom set is `w`-small.\n\nSee `ShrinkHoms C` for a category instance where every hom set has been replaced by a small model.\n-/\n@[pp_with_univ]\nclass LocallySmall (C : Type u) [Category.{v} C] : Prop where\n  /-- A locally small category has small hom-types. -/\n  hom_small : ‚àÄ X Y : C, Small.{w} (X ‚ü∂ Y) := by infer_instance\n\n"}
{"name":"CategoryTheory.instSmallHomOfLocallySmall","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX Y : C\n‚ä¢ Small.{w, v} (Quiver.Hom X Y)","decl":"instance (C : Type u) [Category.{v} C] [LocallySmall.{w} C] (X Y : C) : Small.{w, v} (X ‚ü∂ Y) :=\n  LocallySmall.hom_small X Y\n\n"}
{"name":"CategoryTheory.instLocallySmallOpposite","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} (Opposite C)","decl":"instance (C : Type u) [Category.{v} C] [LocallySmall.{w} C] : LocallySmall.{w} C·µí·µñ where\n  hom_small X Y := small_of_injective (opEquiv X Y).injective\n\n"}
{"name":"CategoryTheory.locallySmall_of_faithful","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Faithful\ninst‚úù : CategoryTheory.LocallySmall.{w, v', u'} D\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} C","decl":"theorem locallySmall_of_faithful {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (F : C ‚•§ D) [F.Faithful] [LocallySmall.{w} D] : LocallySmall.{w} C where\n  hom_small {_ _} := small_of_injective F.map_injective\n\n"}
{"name":"CategoryTheory.locallySmall_congr","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Iff (CategoryTheory.LocallySmall.{w, v, u} C) (CategoryTheory.LocallySmall.{w, v', u'} D)","decl":"theorem locallySmall_congr {C : Type u} [Category.{v} C] {D : Type u'} [Category.{v'} D]\n    (e : C ‚âå D) : LocallySmall.{w} C ‚Üî LocallySmall.{w} D :=\n  ‚ü®fun _ => locallySmall_of_faithful e.inverse, fun _ => locallySmall_of_faithful e.functor‚ü©\n\n"}
{"name":"CategoryTheory.locallySmall_self","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{v, v, u} C","decl":"instance (priority := 100) locallySmall_self (C : Type u) [Category.{v} C] :\n    LocallySmall.{v} C where\n\n"}
{"name":"CategoryTheory.locallySmall_of_univLE","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : UnivLE.{v, w}\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} C","decl":"instance (priority := 100) locallySmall_of_univLE (C : Type u) [Category.{v} C] [UnivLE.{v, w}] :\n    LocallySmall.{w} C where\n\n"}
{"name":"CategoryTheory.locallySmall_max","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{max v w, v, u} C","decl":"theorem locallySmall_max {C : Type u} [Category.{v} C] : LocallySmall.{max v w} C where\n  hom_small _ _ := small_max.{w} _\n\n"}
{"name":"CategoryTheory.locallySmall_of_essentiallySmall","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.EssentiallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} C","decl":"instance (priority := 100) locallySmall_of_essentiallySmall (C : Type u) [Category.{v} C]\n    [EssentiallySmall.{w} C] : LocallySmall.{w} C :=\n  (locallySmall_congr (equivSmallModel C)).mpr (CategoryTheory.locallySmall_self _)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.to_from","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C' : Type u_1\nX : C'\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.toShrinkHoms X).fromShrinkHoms X","decl":"@[simp]\ntheorem to_from (X : C') : fromShrinkHoms (toShrinkHoms X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ShrinkHoms.from_to","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C' : Type u_1\nX : CategoryTheory.ShrinkHoms.{u_1} C'\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.toShrinkHoms X.fromShrinkHoms) X","decl":"@[simp]\ntheorem from_to (X : ShrinkHoms C') : toShrinkHoms (fromShrinkHoms X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ShrinkHoms.instCategory_comp","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.ShrinkHoms.{u} C\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) ((equivShrink (Quiver.Hom X‚úù.fromShrinkHoms Z‚úù.fromShrinkHoms)) (CategoryTheory.CategoryStruct.comp ((equivShrink (Quiver.Hom X‚úù.fromShrinkHoms Y‚úù.fromShrinkHoms)).symm f) ((equivShrink (Quiver.Hom Y‚úù.fromShrinkHoms Z‚úù.fromShrinkHoms)).symm g)))","decl":"@[simps]\nnoncomputable instance : Category.{w} (ShrinkHoms C) where\n  Hom X Y := Shrink (fromShrinkHoms X ‚ü∂ fromShrinkHoms Y)\n  id X := equivShrink _ (ùüô (fromShrinkHoms X))\n  comp f g := equivShrink _ ((equivShrink _).symm f ‚â´ (equivShrink _).symm g)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.instCategory_id","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX : CategoryTheory.ShrinkHoms.{u} C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) ((equivShrink (Quiver.Hom X.fromShrinkHoms X.fromShrinkHoms)) (CategoryTheory.CategoryStruct.id X.fromShrinkHoms))","decl":"@[simps]\nnoncomputable instance : Category.{w} (ShrinkHoms C) where\n  Hom X Y := Shrink (fromShrinkHoms X ‚ü∂ fromShrinkHoms Y)\n  id X := equivShrink _ (ùüô (fromShrinkHoms X))\n  comp f g := equivShrink _ ((equivShrink _).symm f ‚â´ (equivShrink _).symm g)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.functor_obj","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX : C\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.functor C).obj X) (CategoryTheory.ShrinkHoms.toShrinkHoms X)","decl":"/-- Implementation of `ShrinkHoms.equivalence`. -/\n@[simps]\nnoncomputable def functor : C ‚•§ ShrinkHoms C where\n  obj X := toShrinkHoms X\n  map {X Y} f := equivShrink (X ‚ü∂ Y) f\n\n"}
{"name":"CategoryTheory.ShrinkHoms.functor_map","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.functor C).map f) ((equivShrink (Quiver.Hom X Y)) f)","decl":"/-- Implementation of `ShrinkHoms.equivalence`. -/\n@[simps]\nnoncomputable def functor : C ‚•§ ShrinkHoms C where\n  obj X := toShrinkHoms X\n  map {X Y} f := equivShrink (X ‚ü∂ Y) f\n\n"}
{"name":"CategoryTheory.ShrinkHoms.inverse_map","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX Y : CategoryTheory.ShrinkHoms.{u} C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.inverse C).map f) ((equivShrink (Quiver.Hom X.fromShrinkHoms Y.fromShrinkHoms)).symm f)","decl":"/-- Implementation of `ShrinkHoms.equivalence`. -/\n@[simps]\nnoncomputable def inverse : ShrinkHoms C ‚•§ C where\n  obj X := fromShrinkHoms X\n  map {X Y} f := (equivShrink (fromShrinkHoms X ‚ü∂ fromShrinkHoms Y)).symm f\n\n"}
{"name":"CategoryTheory.ShrinkHoms.inverse_obj","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nX : CategoryTheory.ShrinkHoms.{u} C\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.inverse C).obj X) X.fromShrinkHoms","decl":"/-- Implementation of `ShrinkHoms.equivalence`. -/\n@[simps]\nnoncomputable def inverse : ShrinkHoms C ‚•§ C where\n  obj X := fromShrinkHoms X\n  map {X Y} f := (equivShrink (fromShrinkHoms X ‚ü∂ fromShrinkHoms Y)).symm f\n\n"}
{"name":"CategoryTheory.ShrinkHoms.equivalence_inverse","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.equivalence C).inverse (CategoryTheory.ShrinkHoms.inverse C)","decl":"/-- The categorical equivalence between `C` and `ShrinkHoms C`, when `C` is locally small.\n-/\n@[simps]\nnoncomputable def equivalence : C ‚âå ShrinkHoms C where\n  functor := functor C\n  inverse := inverse C\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.equivalence_counitIso","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.equivalence C).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((CategoryTheory.ShrinkHoms.inverse C).comp (CategoryTheory.ShrinkHoms.functor C)).obj x)) ‚ãØ)","decl":"/-- The categorical equivalence between `C` and `ShrinkHoms C`, when `C` is locally small.\n-/\n@[simps]\nnoncomputable def equivalence : C ‚âå ShrinkHoms C where\n  functor := functor C\n  inverse := inverse C\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.equivalence_functor","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.equivalence C).functor (CategoryTheory.ShrinkHoms.functor C)","decl":"/-- The categorical equivalence between `C` and `ShrinkHoms C`, when `C` is locally small.\n-/\n@[simps]\nnoncomputable def equivalence : C ‚âå ShrinkHoms C where\n  functor := functor C\n  inverse := inverse C\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.equivalence_unitIso","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ Eq (CategoryTheory.ShrinkHoms.equivalence C).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id C).obj x)) ‚ãØ)","decl":"/-- The categorical equivalence between `C` and `ShrinkHoms C`, when `C` is locally small.\n-/\n@[simps]\nnoncomputable def equivalence : C ‚âå ShrinkHoms C where\n  functor := functor C\n  inverse := inverse C\n  unitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n  counitIso := NatIso.ofComponents (fun _ ‚Ü¶ Iso.refl _)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.instIsEquivalenceFunctor","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ (CategoryTheory.ShrinkHoms.functor C).IsEquivalence","decl":"instance : (functor C).IsEquivalence := (equivalence C).isEquivalence_functor\n"}
{"name":"CategoryTheory.ShrinkHoms.instIsEquivalenceInverse","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ (CategoryTheory.ShrinkHoms.inverse C).IsEquivalence","decl":"instance : (inverse C).IsEquivalence := (equivalence C).isEquivalence_inverse\n\n"}
{"name":"CategoryTheory.Shrink.instLocallySmallShrink","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : Small.{w', u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{w, v, w'} (Shrink.{w', u} C)","decl":"instance [Small.{w'} C] [LocallySmall.{w} C] :\n    LocallySmall.{w} (Shrink.{w'} C) :=\n  locallySmall_of_faithful.{w} (equivalence.{w'} C).inverse\n\n"}
{"name":"CategoryTheory.essentiallySmall_iff","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Iff (CategoryTheory.EssentiallySmall.{w, v, u} C) (And (Small.{w, u} (CategoryTheory.Skeleton C)) (CategoryTheory.LocallySmall.{w, v, u} C))","decl":"/-- A category is essentially small if and only if\nthe underlying type of its skeleton (i.e. the \"set\" of isomorphism classes) is small,\nand it is locally small.\n-/\ntheorem essentiallySmall_iff (C : Type u) [Category.{v} C] :\n    EssentiallySmall.{w} C ‚Üî Small.{w} (Skeleton C) ‚àß LocallySmall.{w} C := by\n  -- This theorem is the only bit of real work in this file.\n  fconstructor\n  ¬∑ intro h\n    fconstructor\n    ¬∑ rcases h with ‚ü®S, ùíÆ, ‚ü®e‚ü©‚ü©\n      refine ‚ü®‚ü®Skeleton S, ‚ü®?_‚ü©‚ü©‚ü©\n      exact e.skeletonEquiv\n    ¬∑ infer_instance\n  ¬∑ rintro ‚ü®‚ü®S, ‚ü®e‚ü©‚ü©, L‚ü©\n    let e' := (ShrinkHoms.equivalence C).skeletonEquiv.symm\n    letI : Category S := InducedCategory.category (e'.trans e).symm\n    refine ‚ü®‚ü®S, this, ‚ü®?_‚ü©‚ü©‚ü©\n    refine (ShrinkHoms.equivalence C).trans <|\n      (skeletonEquivalence (ShrinkHoms C)).symm.trans\n        ((inducedFunctor (e'.trans e).symm).asEquivalence.symm)\n\n"}
{"name":"CategoryTheory.essentiallySmall_of_small_of_locallySmall","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : Small.{w, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.EssentiallySmall.{w, v, u} C","decl":"theorem essentiallySmall_of_small_of_locallySmall [Small.{w} C] [LocallySmall.{w} C] :\n    EssentiallySmall.{w} C :=\n  (essentiallySmall_iff C).2 ‚ü®small_of_surjective Quotient.exists_rep, by infer_instance‚ü©\n\n"}
{"name":"CategoryTheory.locallySmall_fullSubcategory","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\nP : C ‚Üí Prop\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} (CategoryTheory.FullSubcategory P)","decl":"instance locallySmall_fullSubcategory [LocallySmall.{w} C] (P : C ‚Üí Prop) :\n    LocallySmall.{w} (FullSubcategory P) :=\n  locallySmall_of_faithful <| fullSubcategoryInclusion P\n\n"}
{"name":"CategoryTheory.essentiallySmall_fullSubcategory_mem","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ns : Set C\ninst‚úù¬π : Small.{w, u} ‚Üës\ninst‚úù : CategoryTheory.LocallySmall.{w, v, u} C\n‚ä¢ CategoryTheory.EssentiallySmall.{w, v, u} (CategoryTheory.FullSubcategory fun x => Membership.mem s x)","decl":"instance essentiallySmall_fullSubcategory_mem (s : Set C) [Small.{w} s] [LocallySmall.{w} C] :\n    EssentiallySmall.{w} (FullSubcategory (¬∑ ‚àà s)) :=\n  suffices Small.{w} (FullSubcategory (¬∑ ‚àà s)) from essentiallySmall_of_small_of_locallySmall _\n  small_of_injective (f := fun x => (‚ü®x.1, x.2‚ü© : s)) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.locallySmall_of_thin","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ CategoryTheory.LocallySmall.{w, v, u} C","decl":"/-- Any thin category is locally small.\n-/\ninstance (priority := 100) locallySmall_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    LocallySmall.{w} C where\n\n"}
{"name":"CategoryTheory.essentiallySmall_iff_of_thin","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : Quiver.IsThin C\n‚ä¢ Iff (CategoryTheory.EssentiallySmall.{w, v, u} C) (Small.{w, u} (CategoryTheory.Skeleton C))","decl":"/--\nA thin category is essentially small if and only if the underlying type of its skeleton is small.\n-/\ntheorem essentiallySmall_iff_of_thin {C : Type u} [Category.{v} C] [Quiver.IsThin C] :\n    EssentiallySmall.{w} C ‚Üî Small.{w} (Skeleton C) := by\n  simp [essentiallySmall_iff, CategoryTheory.locallySmall_of_thin]\n\n"}
{"name":"CategoryTheory.instSmallDiscrete","module":"Mathlib.CategoryTheory.EssentiallySmall","initialProofState":"C : Type u\ninst‚úù : Small.{w, u} C\n‚ä¢ Small.{w, u} (CategoryTheory.Discrete C)","decl":"instance [Small.{w} C] : Small.{w} (Discrete C) := small_map discreteEquiv\n\n"}
