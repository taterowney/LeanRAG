{"name":"CategoryTheory.IsSeparating.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nh : CategoryTheory.IsSeparating ğ’¢\nD : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} D\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.IsSeparating (Set.image Î±.functor.obj ğ’¢)","decl":"lemma IsSeparating.of_equivalence\n    {ğ’¢ : Set C} (h : IsSeparating ğ’¢) {D : Type*} [Category D] (Î± : C â‰Œ D) :\n    IsSeparating (Î±.functor.obj '' ğ’¢) := fun X Y f g H =>\n  Î±.inverse.map_injective (h _ _ (fun Z hZ h => by\n    obtain âŸ¨h', rflâŸ© := (Î±.toAdjunction.homEquiv _ _).surjective h\n    simp only [Adjunction.homEquiv_unit, Category.assoc, â† Functor.map_comp,\n      H (Î±.functor.obj Z) (Set.mem_image_of_mem _ hZ) h']))\n\n"}
{"name":"CategoryTheory.IsCoseparating.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nh : CategoryTheory.IsCoseparating ğ’¢\nD : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} D\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.IsCoseparating (Set.image Î±.functor.obj ğ’¢)","decl":"lemma IsCoseparating.of_equivalence\n    {ğ’¢ : Set C} (h : IsCoseparating ğ’¢) {D : Type*} [Category D] (Î± : C â‰Œ D) :\n    IsCoseparating (Î±.functor.obj '' ğ’¢) := fun X Y f g H =>\n  Î±.inverse.map_injective (h _ _ (fun Z hZ h => by\n    obtain âŸ¨h', rflâŸ© := (Î±.symm.toAdjunction.homEquiv _ _).symm.surjective h\n    simp only [Adjunction.homEquiv_symm_apply, â† Category.assoc, â† Functor.map_comp,\n      Equivalence.symm_functor, H (Î±.functor.obj Z) (Set.mem_image_of_mem _ hZ) h']))\n\n"}
{"name":"CategoryTheory.isSeparating_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsSeparating ğ’¢.op) (CategoryTheory.IsCoseparating ğ’¢)","decl":"theorem isSeparating_op_iff (ğ’¢ : Set C) : IsSeparating ğ’¢.op â†” IsCoseparating ğ’¢ := by\n  refine âŸ¨fun hğ’¢ X Y f g hfg => ?_, fun hğ’¢ X Y f g hfg => ?_âŸ©\n  Â· refine Quiver.Hom.op_inj (hğ’¢ _ _ fun G hG h => Quiver.Hom.unop_inj ?_)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  Â· refine Quiver.Hom.unop_inj (hğ’¢ _ _ fun G hG h => Quiver.Hom.op_inj ?_)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n\n"}
{"name":"CategoryTheory.isCoseparating_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsCoseparating ğ’¢.op) (CategoryTheory.IsSeparating ğ’¢)","decl":"theorem isCoseparating_op_iff (ğ’¢ : Set C) : IsCoseparating ğ’¢.op â†” IsSeparating ğ’¢ := by\n  refine âŸ¨fun hğ’¢ X Y f g hfg => ?_, fun hğ’¢ X Y f g hfg => ?_âŸ©\n  Â· refine Quiver.Hom.op_inj (hğ’¢ _ _ fun G hG h => Quiver.Hom.unop_inj ?_)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  Â· refine Quiver.Hom.unop_inj (hğ’¢ _ _ fun G hG h => Quiver.Hom.op_inj ?_)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n\n"}
{"name":"CategoryTheory.isCoseparating_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set (Opposite C)\nâŠ¢ Iff (CategoryTheory.IsCoseparating ğ’¢.unop) (CategoryTheory.IsSeparating ğ’¢)","decl":"theorem isCoseparating_unop_iff (ğ’¢ : Set Cáµ’áµ–) : IsCoseparating ğ’¢.unop â†” IsSeparating ğ’¢ := by\n  rw [â† isSeparating_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isSeparating_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set (Opposite C)\nâŠ¢ Iff (CategoryTheory.IsSeparating ğ’¢.unop) (CategoryTheory.IsCoseparating ğ’¢)","decl":"theorem isSeparating_unop_iff (ğ’¢ : Set Cáµ’áµ–) : IsSeparating ğ’¢.unop â†” IsCoseparating ğ’¢ := by\n  rw [â† isCoseparating_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isDetecting_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsDetecting ğ’¢.op) (CategoryTheory.IsCodetecting ğ’¢)","decl":"theorem isDetecting_op_iff (ğ’¢ : Set C) : IsDetecting ğ’¢.op â†” IsCodetecting ğ’¢ := by\n  refine âŸ¨fun hğ’¢ X Y f hf => ?_, fun hğ’¢ X Y f hf => ?_âŸ©\n  Â· refine (isIso_op_iff _).1 (hğ’¢ _ fun G hG h => ?_)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact\n      âŸ¨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))âŸ©\n  Â· refine (isIso_unop_iff _).1 (hğ’¢ _ fun G hG h => ?_)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine âŸ¨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ ?_)âŸ©\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n\n"}
{"name":"CategoryTheory.isCodetecting_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsCodetecting ğ’¢.op) (CategoryTheory.IsDetecting ğ’¢)","decl":"theorem isCodetecting_op_iff (ğ’¢ : Set C) : IsCodetecting ğ’¢.op â†” IsDetecting ğ’¢ := by\n  refine âŸ¨fun hğ’¢ X Y f hf => ?_, fun hğ’¢ X Y f hf => ?_âŸ©\n  Â· refine (isIso_op_iff _).1 (hğ’¢ _ fun G hG h => ?_)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact\n      âŸ¨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))âŸ©\n  Â· refine (isIso_unop_iff _).1 (hğ’¢ _ fun G hG h => ?_)\n    obtain âŸ¨t, ht, ht'âŸ© := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine âŸ¨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ ?_)âŸ©\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n\n"}
{"name":"CategoryTheory.isDetecting_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set (Opposite C)\nâŠ¢ Iff (CategoryTheory.IsDetecting ğ’¢.unop) (CategoryTheory.IsCodetecting ğ’¢)","decl":"theorem isDetecting_unop_iff (ğ’¢ : Set Cáµ’áµ–) : IsDetecting ğ’¢.unop â†” IsCodetecting ğ’¢ := by\n  rw [â† isCodetecting_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isCodetecting_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set (Opposite C)\nâŠ¢ Iff (CategoryTheory.IsCodetecting ğ’¢.unop) (CategoryTheory.IsDetecting ğ’¢)","decl":"theorem isCodetecting_unop_iff {ğ’¢ : Set Cáµ’áµ–} : IsCodetecting ğ’¢.unop â†” IsDetecting ğ’¢ := by\n  rw [â† isDetecting_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.IsDetecting.isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasEqualizers C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nâŠ¢ CategoryTheory.IsSeparating ğ’¢","decl":"theorem IsDetecting.isSeparating [HasEqualizers C] {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) :\n    IsSeparating ğ’¢ := fun _ _ f g hfg =>\n  have : IsIso (equalizer.Î¹ f g) := hğ’¢ _ fun _ hG _ => equalizer.existsUnique _ (hfg _ hG _)\n  eq_of_epi_equalizer\n\n"}
{"name":"CategoryTheory.IsCodetecting.isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nğ’¢ : Set C\naâœ : CategoryTheory.IsCodetecting ğ’¢\nâŠ¢ CategoryTheory.IsCoseparating ğ’¢","decl":"theorem IsCodetecting.isCoseparating [HasCoequalizers C] {ğ’¢ : Set C} :\n    IsCodetecting ğ’¢ â†’ IsCoseparating ğ’¢ := by\n  simpa only [â† isSeparating_op_iff, â† isDetecting_op_iff] using IsDetecting.isSeparating\n\n"}
{"name":"CategoryTheory.IsSeparating.isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Balanced C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nâŠ¢ CategoryTheory.IsDetecting ğ’¢","decl":"theorem IsSeparating.isDetecting [Balanced C] {ğ’¢ : Set C} (hğ’¢ : IsSeparating ğ’¢) :\n    IsDetecting ğ’¢ := by\n  intro X Y f hf\n  refine\n    (isIso_iff_mono_and_epi _).2 âŸ¨âŸ¨fun g h hgh => hğ’¢ _ _ fun G hG i => ?_âŸ©, âŸ¨fun g h hgh => ?_âŸ©âŸ©\n  Â· obtain âŸ¨t, -, htâŸ© := hf G hG (i â‰« g â‰« f)\n    rw [ht (i â‰« g) (Category.assoc _ _ _), ht (i â‰« h) (hgh.symm â–¸ Category.assoc _ _ _)]\n  Â· refine hğ’¢ _ _ fun G hG i => ?_\n    obtain âŸ¨t, rfl, -âŸ© := hf G hG i\n    rw [Category.assoc, hgh, Category.assoc]\n\n"}
{"name":"CategoryTheory.IsCoseparating.isCodetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Balanced C\nğ’¢ : Set C\naâœ : CategoryTheory.IsCoseparating ğ’¢\nâŠ¢ CategoryTheory.IsCodetecting ğ’¢","decl":"theorem IsCoseparating.isCodetecting [Balanced C] {ğ’¢ : Set C} :\n    IsCoseparating ğ’¢ â†’ IsCodetecting ğ’¢ := by\n  simpa only [â† isDetecting_op_iff, â† isSeparating_op_iff] using IsSeparating.isDetecting\n\n"}
{"name":"CategoryTheory.isDetecting_iff_isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasEqualizers C\ninstâœ : CategoryTheory.Balanced C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsDetecting ğ’¢) (CategoryTheory.IsSeparating ğ’¢)","decl":"theorem isDetecting_iff_isSeparating [HasEqualizers C] [Balanced C] (ğ’¢ : Set C) :\n    IsDetecting ğ’¢ â†” IsSeparating ğ’¢ :=\n  âŸ¨IsDetecting.isSeparating, IsSeparating.isDetectingâŸ©\n\n"}
{"name":"CategoryTheory.isCodetecting_iff_isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : CategoryTheory.Balanced C\nğ’¢ : Set C\nâŠ¢ Iff (CategoryTheory.IsCodetecting ğ’¢) (CategoryTheory.IsCoseparating ğ’¢)","decl":"theorem isCodetecting_iff_isCoseparating [HasCoequalizers C] [Balanced C] {ğ’¢ : Set C} :\n    IsCodetecting ğ’¢ â†” IsCoseparating ğ’¢ :=\n  âŸ¨IsCodetecting.isCoseparating, IsCoseparating.isCodetectingâŸ©\n\n"}
{"name":"CategoryTheory.IsSeparating.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nâ„‹ : Set C\nhğ’¢â„‹ : HasSubset.Subset ğ’¢ â„‹\nâŠ¢ CategoryTheory.IsSeparating â„‹","decl":"theorem IsSeparating.mono {ğ’¢ : Set C} (hğ’¢ : IsSeparating ğ’¢) {â„‹ : Set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) :\n    IsSeparating â„‹ := fun _ _ _ _ hfg => hğ’¢ _ _ fun _ hG _ => hfg _ (hğ’¢â„‹ hG) _\n\n"}
{"name":"CategoryTheory.IsCoseparating.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsCoseparating ğ’¢\nâ„‹ : Set C\nhğ’¢â„‹ : HasSubset.Subset ğ’¢ â„‹\nâŠ¢ CategoryTheory.IsCoseparating â„‹","decl":"theorem IsCoseparating.mono {ğ’¢ : Set C} (hğ’¢ : IsCoseparating ğ’¢) {â„‹ : Set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) :\n    IsCoseparating â„‹ := fun _ _ _ _ hfg => hğ’¢ _ _ fun _ hG _ => hfg _ (hğ’¢â„‹ hG) _\n\n"}
{"name":"CategoryTheory.IsDetecting.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nâ„‹ : Set C\nhğ’¢â„‹ : HasSubset.Subset ğ’¢ â„‹\nâŠ¢ CategoryTheory.IsDetecting â„‹","decl":"theorem IsDetecting.mono {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) {â„‹ : Set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) :\n    IsDetecting â„‹ := fun _ _ _ hf => hğ’¢ _ fun _ hG _ => hf _ (hğ’¢â„‹ hG) _\n\n"}
{"name":"CategoryTheory.IsCodetecting.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsCodetecting ğ’¢\nâ„‹ : Set C\nhğ’¢â„‹ : HasSubset.Subset ğ’¢ â„‹\nâŠ¢ CategoryTheory.IsCodetecting â„‹","decl":"theorem IsCodetecting.mono {ğ’¢ : Set C} (hğ’¢ : IsCodetecting ğ’¢) {â„‹ : Set C} (hğ’¢â„‹ : ğ’¢ âŠ† â„‹) :\n    IsCodetecting â„‹ := fun _ _ _ hf => hğ’¢ _ fun _ hG _ => hf _ (hğ’¢â„‹ hG) _\n\n"}
{"name":"CategoryTheory.thin_of_isSeparating_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.IsSeparating EmptyCollection.emptyCollection\nâŠ¢ Quiver.IsThin C","decl":"theorem thin_of_isSeparating_empty (h : IsSeparating (âˆ… : Set C)) : Quiver.IsThin C := fun _ _ =>\n  âŸ¨fun _ _ => h _ _ fun _ => False.elimâŸ©\n\n"}
{"name":"CategoryTheory.isSeparating_empty_of_thin","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : Quiver.IsThin C\nâŠ¢ CategoryTheory.IsSeparating EmptyCollection.emptyCollection","decl":"theorem isSeparating_empty_of_thin [Quiver.IsThin C] : IsSeparating (âˆ… : Set C) :=\n  fun _ _ _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.thin_of_isCoseparating_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.IsCoseparating EmptyCollection.emptyCollection\nâŠ¢ Quiver.IsThin C","decl":"theorem thin_of_isCoseparating_empty (h : IsCoseparating (âˆ… : Set C)) : Quiver.IsThin C :=\n  fun _ _ => âŸ¨fun _ _ => h _ _ fun _ => False.elimâŸ©\n\n"}
{"name":"CategoryTheory.isCoseparating_empty_of_thin","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : Quiver.IsThin C\nâŠ¢ CategoryTheory.IsCoseparating EmptyCollection.emptyCollection","decl":"theorem isCoseparating_empty_of_thin [Quiver.IsThin C] : IsCoseparating (âˆ… : Set C) :=\n  fun _ _ _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.groupoid_of_isDetecting_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.IsDetecting EmptyCollection.emptyCollection\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem groupoid_of_isDetecting_empty (h : IsDetecting (âˆ… : Set C)) {X Y : C} (f : X âŸ¶ Y) :\n    IsIso f :=\n  h _ fun _ => False.elim\n\n"}
{"name":"CategoryTheory.isDetecting_empty_of_groupoid","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : âˆ€ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.IsDetecting EmptyCollection.emptyCollection","decl":"theorem isDetecting_empty_of_groupoid [âˆ€ {X Y : C} (f : X âŸ¶ Y), IsIso f] :\n    IsDetecting (âˆ… : Set C) := fun _ _ _ _ => inferInstance\n\n"}
{"name":"CategoryTheory.groupoid_of_isCodetecting_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.IsCodetecting EmptyCollection.emptyCollection\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem groupoid_of_isCodetecting_empty (h : IsCodetecting (âˆ… : Set C)) {X Y : C} (f : X âŸ¶ Y) :\n    IsIso f :=\n  h _ fun _ => False.elim\n\n"}
{"name":"CategoryTheory.isCodetecting_empty_of_groupoid","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : âˆ€ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.IsCodetecting EmptyCollection.emptyCollection","decl":"theorem isCodetecting_empty_of_groupoid [âˆ€ {X Y : C} (f : X âŸ¶ Y), IsIso f] :\n    IsCodetecting (âˆ… : Set C) := fun _ _ _ _ => inferInstance\n\n"}
{"name":"CategoryTheory.isSeparating_iff_epi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\ninstâœ : âˆ€ (A : C), CategoryTheory.Limits.HasCoproduct fun f => â†‘f.fst\nâŠ¢ Iff (CategoryTheory.IsSeparating ğ’¢) (âˆ€ (A : C), CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc Sigma.snd))","decl":"theorem isSeparating_iff_epi (ğ’¢ : Set C)\n    [âˆ€ A : C, HasCoproduct fun f : Î£G : ğ’¢, (G : C) âŸ¶ A => (f.1 : C)] :\n    IsSeparating ğ’¢ â†” âˆ€ A : C, Epi (Sigma.desc (@Sigma.snd ğ’¢ fun G => (G : C) âŸ¶ A)) := by\n  refine âŸ¨fun h A => âŸ¨fun u v huv => h _ _ fun G hG f => ?_âŸ©, fun h X Y f g hh => ?_âŸ©\n  Â· simpa using Sigma.Î¹ (fun f : Î£G : ğ’¢, (G : C) âŸ¶ A => (f.1 : C)) âŸ¨âŸ¨G, hGâŸ©, fâŸ© â‰«= huv\n  Â· haveI := h X\n    refine\n      (cancel_epi (Sigma.desc (@Sigma.snd ğ’¢ fun G => (G : C) âŸ¶ X))).1 (colimit.hom_ext fun j => ?_)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n\n"}
{"name":"CategoryTheory.isCoseparating_iff_mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\ninstâœ : âˆ€ (A : C), CategoryTheory.Limits.HasProduct fun f => â†‘f.fst\nâŠ¢ Iff (CategoryTheory.IsCoseparating ğ’¢) (âˆ€ (A : C), CategoryTheory.Mono (CategoryTheory.Limits.Pi.lift Sigma.snd))","decl":"theorem isCoseparating_iff_mono (ğ’¢ : Set C)\n    [âˆ€ A : C, HasProduct fun f : Î£G : ğ’¢, A âŸ¶ (G : C) => (f.1 : C)] :\n    IsCoseparating ğ’¢ â†” âˆ€ A : C, Mono (Pi.lift (@Sigma.snd ğ’¢ fun G => A âŸ¶ (G : C))) := by\n  refine âŸ¨fun h A => âŸ¨fun u v huv => h _ _ fun G hG f => ?_âŸ©, fun h X Y f g hh => ?_âŸ©\n  Â· simpa using huv =â‰« Pi.Ï€ (fun f : Î£G : ğ’¢, A âŸ¶ (G : C) => (f.1 : C)) âŸ¨âŸ¨G, hGâŸ©, fâŸ©\n  Â· haveI := h Y\n    refine (cancel_mono (Pi.lift (@Sigma.snd ğ’¢ fun G => Y âŸ¶ (G : C)))).1 (limit.hom_ext fun j => ?_)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n\n"}
{"name":"CategoryTheory.hasInitial_of_isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.LocallySmall.{w, vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.WellPowered.{w, vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w, vâ‚, uâ‚} C\nğ’¢ : Set C\ninstâœ : Small.{w, uâ‚} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsCoseparating ğ’¢\nâŠ¢ CategoryTheory.Limits.HasInitial C","decl":"/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\n    category with a small coseparating set has an initial object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\n    see `hasColimits_of_hasLimits_of_isCoseparating`. -/\ntheorem hasInitial_of_isCoseparating [LocallySmall.{w} C] [WellPowered.{w} C]\n    [HasLimitsOfSize.{w, w} C] {ğ’¢ : Set C} [Small.{w} ğ’¢]\n    (hğ’¢ : IsCoseparating ğ’¢) : HasInitial C := by\n  have := hasFiniteLimits_of_hasLimitsOfSize C\n  haveI : HasProductsOfShape ğ’¢ C := hasProductsOfShape_of_small C ğ’¢\n  haveI := fun A => hasProductsOfShape_of_small.{w} C (Î£G : ğ’¢, A âŸ¶ (G : C))\n  letI := completeLatticeOfCompleteSemilatticeInf (Subobject (piObj (Subtype.val : ğ’¢ â†’ C)))\n  suffices âˆ€ A : C, Unique (((âŠ¥ : Subobject (piObj (Subtype.val : ğ’¢ â†’ C))) : C) âŸ¶ A) by\n    exact hasInitial_of_unique ((âŠ¥ : Subobject (piObj (Subtype.val : ğ’¢ â†’ C))) : C)\n  refine fun A => âŸ¨âŸ¨?_âŸ©, fun f => ?_âŸ©\n  Â· let s := Pi.lift fun f : Î£G : ğ’¢, A âŸ¶ (G : C) => id (Pi.Ï€ (Subtype.val : ğ’¢ â†’ C)) f.1\n    let t := Pi.lift (@Sigma.snd ğ’¢ fun G => A âŸ¶ (G : C))\n    haveI : Mono t := (isCoseparating_iff_mono ğ’¢).1 hğ’¢ A\n    exact Subobject.ofLEMk _ (pullback.fst _ _ : pullback s t âŸ¶ _) bot_le â‰« pullback.snd _ _\n  Â· suffices âˆ€ (g : Subobject.underlying.obj âŠ¥ âŸ¶ A), f = g by\n      apply this\n    intro g\n    suffices IsSplitEpi (equalizer.Î¹ f g) by exact eq_of_epi_equalizer\n    exact IsSplitEpi.mk' âŸ¨Subobject.ofLEMk _ (equalizer.Î¹ f g â‰« Subobject.arrow _) bot_le, by\n      ext\n      simpâŸ©\n\n"}
{"name":"CategoryTheory.hasTerminal_of_isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.LocallySmall.{w, vâ‚, uâ‚} (Opposite C)\ninstâœÂ² : CategoryTheory.WellPowered.{w, vâ‚, uâ‚} (Opposite C)\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w, vâ‚, uâ‚} C\nğ’¢ : Set C\ninstâœ : Small.{w, uâ‚} â†‘ğ’¢\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nâŠ¢ CategoryTheory.Limits.HasTerminal C","decl":"/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\n    category with a small separating set has a terminal object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n    `hasLimits_of_hasColimits_of_isSeparating`. -/\ntheorem hasTerminal_of_isSeparating [LocallySmall.{w} Cáµ’áµ–] [WellPowered.{w} Cáµ’áµ–]\n    [HasColimitsOfSize.{w, w} C] {ğ’¢ : Set C} [Small.{w} ğ’¢]\n    (hğ’¢ : IsSeparating ğ’¢) : HasTerminal C := by\n  haveI : Small.{w} ğ’¢.op := small_of_injective (Set.opEquiv_self ğ’¢).injective\n  haveI : HasInitial Cáµ’áµ– := hasInitial_of_isCoseparating ((isCoseparating_op_iff _).2 hğ’¢)\n  exact hasTerminal_of_hasInitial_op\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_le_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nX : C\nP Q : CategoryTheory.Subobject X\nhâ‚ : LE.le P Q\nhâ‚‚ : âˆ€ (G : C), Membership.mem ğ’¢ G â†’ âˆ€ {f : Quiver.Hom G X}, Q.Factors f â†’ P.Factors f\nâŠ¢ Eq P Q","decl":"theorem eq_of_le_of_isDetecting {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) {X : C} (P Q : Subobject X)\n    (hâ‚ : P â‰¤ Q) (hâ‚‚ : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : G âŸ¶ X}, Q.Factors f â†’ P.Factors f) : P = Q := by\n  suffices IsIso (ofLE _ _ hâ‚) by exact le_antisymm hâ‚ (le_of_comm (inv (ofLE _ _ hâ‚)) (by simp))\n  refine hğ’¢ _ fun G hG f => ?_\n  have : P.Factors (f â‰« Q.arrow) := hâ‚‚ _ hG ((factors_iff _ _).2 âŸ¨_, rflâŸ©)\n  refine âŸ¨factorThru _ _ this, ?_, fun g (hg : g â‰« _ = f) => ?_âŸ©\n  Â· simp only [â† cancel_mono Q.arrow, Category.assoc, ofLE_arrow, factorThru_arrow]\n  Â· simp only [â† cancel_mono (Subobject.ofLE _ _ hâ‚), â† cancel_mono Q.arrow, hg, Category.assoc,\n      ofLE_arrow, factorThru_arrow]\n\n"}
{"name":"CategoryTheory.Subobject.inf_eq_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nX : C\nP Q : CategoryTheory.Subobject X\nh : âˆ€ (G : C), Membership.mem ğ’¢ G â†’ âˆ€ {f : Quiver.Hom G X}, P.Factors f â†’ Q.Factors f\nâŠ¢ Eq (Min.min P Q) P","decl":"theorem inf_eq_of_isDetecting [HasPullbacks C] {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) {X : C}\n    (P Q : Subobject X) (h : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : G âŸ¶ X}, P.Factors f â†’ Q.Factors f) : P âŠ“ Q = P :=\n  eq_of_le_of_isDetecting hğ’¢ _ _ _root_.inf_le_left\n    fun _ hG _ hf => (inf_factors _).2 âŸ¨hf, h _ hG hfâŸ©\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nX : C\nP Q : CategoryTheory.Subobject X\nh : âˆ€ (G : C), Membership.mem ğ’¢ G â†’ âˆ€ {f : Quiver.Hom G X}, Iff (P.Factors f) (Q.Factors f)\nâŠ¢ Eq P Q","decl":"theorem eq_of_isDetecting [HasPullbacks C] {ğ’¢ : Set C} (hğ’¢ : IsDetecting ğ’¢) {X : C}\n    (P Q : Subobject X) (h : âˆ€ G âˆˆ ğ’¢, âˆ€ {f : G âŸ¶ X}, P.Factors f â†” Q.Factors f) : P = Q :=\n  calc\n    P = P âŠ“ Q := Eq.symm <| inf_eq_of_isDetecting hğ’¢ _ _ fun G hG _ hf => (h G hG).1 hf\n    _ = Q âŠ“ P := inf_comm ..\n    _ = Q := inf_eq_of_isDetecting hğ’¢ _ _ fun G hG _ hf => (h G hG).2 hf\n\n"}
{"name":"CategoryTheory.wellPowered_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.Limits.HasPullbacks C\nğ’¢ : Set C\ninstâœÂ¹ : Small.{w, uâ‚} â†‘ğ’¢\ninstâœ : CategoryTheory.LocallySmall.{w, vâ‚, uâ‚} C\nhğ’¢ : CategoryTheory.IsDetecting ğ’¢\nâŠ¢ CategoryTheory.WellPowered.{w, vâ‚, uâ‚} C","decl":"/-- A category with pullbacks and a small detecting set is well-powered. -/\ntheorem wellPowered_of_isDetecting [HasPullbacks C] {ğ’¢ : Set C} [Small.{w} ğ’¢]\n    [LocallySmall.{w} C] (hğ’¢ : IsDetecting ğ’¢) : WellPowered.{w} C :=\n  âŸ¨fun X =>\n    @small_of_injective _ _ _ (fun P : Subobject X => { f : Î£G : ğ’¢, G.1 âŸ¶ X | P.Factors f.2 })\n      fun P Q h => Subobject.eq_of_isDetecting hğ’¢ _ _\n        (by simpa [Set.ext_iff, Sigma.forall] using h)âŸ©\n\n"}
{"name":"CategoryTheory.StructuredArrow.isCoseparating_proj_preimage","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nS : D\nT : CategoryTheory.Functor C D\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsCoseparating ğ’¢\nâŠ¢ CategoryTheory.IsCoseparating (Set.preimage (CategoryTheory.StructuredArrow.proj S T).obj ğ’¢)","decl":"theorem isCoseparating_proj_preimage {ğ’¢ : Set C} (hğ’¢ : IsCoseparating ğ’¢) :\n    IsCoseparating ((proj S T).obj â»Â¹' ğ’¢) := by\n  refine fun X Y f g hfg => ext _ _ (hğ’¢ _ _ fun G hG h => ?_)\n  exact congr_arg CommaMorphism.right (hfg (mk (Y.hom â‰« T.map h)) hG (homMk h rfl))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isSeparating_proj_preimage","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nS : CategoryTheory.Functor C D\nT : D\nğ’¢ : Set C\nhğ’¢ : CategoryTheory.IsSeparating ğ’¢\nâŠ¢ CategoryTheory.IsSeparating (Set.preimage (CategoryTheory.CostructuredArrow.proj S T).obj ğ’¢)","decl":"theorem isSeparating_proj_preimage {ğ’¢ : Set C} (hğ’¢ : IsSeparating ğ’¢) :\n    IsSeparating ((proj S T).obj â»Â¹' ğ’¢) := by\n  refine fun X Y f g hfg => ext _ _ (hğ’¢ _ _ fun G hG h => ?_)\n  exact congr_arg CommaMorphism.left (hfg (mk (S.map h â‰« X.hom)) hG (homMk h rfl))\n\n"}
{"name":"CategoryTheory.IsSeparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : C\nh : CategoryTheory.IsSeparator G\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.IsSeparator (Î±.functor.obj G)","decl":"theorem IsSeparator.of_equivalence {G : C} (h : IsSeparator G) (Î± : C â‰Œ D) :\n    IsSeparator (Î±.functor.obj G) := by simpa using IsSeparating.of_equivalence h Î±\n\n"}
{"name":"CategoryTheory.IsCoseparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nG : C\nh : CategoryTheory.IsCoseparator G\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.IsCoseparator (Î±.functor.obj G)","decl":"theorem IsCoseparator.of_equivalence {G : C} (h : IsCoseparator G) (Î± : C â‰Œ D) :\n    IsCoseparator (Î±.functor.obj G) := by simpa using IsCoseparating.of_equivalence h Î±\n\n"}
{"name":"CategoryTheory.isSeparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsSeparator { unop := G }) (CategoryTheory.IsCoseparator G)","decl":"theorem isSeparator_op_iff (G : C) : IsSeparator (op G) â†” IsCoseparator G := by\n  rw [IsSeparator, IsCoseparator, â† isSeparating_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCoseparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCoseparator { unop := G }) (CategoryTheory.IsSeparator G)","decl":"theorem isCoseparator_op_iff (G : C) : IsCoseparator (op G) â†” IsSeparator G := by\n  rw [IsSeparator, IsCoseparator, â† isCoseparating_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCoseparator_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : Opposite C\nâŠ¢ Iff (CategoryTheory.IsCoseparator (Opposite.unop G)) (CategoryTheory.IsSeparator G)","decl":"theorem isCoseparator_unop_iff (G : Cáµ’áµ–) : IsCoseparator (unop G) â†” IsSeparator G := by\n  rw [IsSeparator, IsCoseparator, â† isCoseparating_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isSeparator_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : Opposite C\nâŠ¢ Iff (CategoryTheory.IsSeparator (Opposite.unop G)) (CategoryTheory.IsCoseparator G)","decl":"theorem isSeparator_unop_iff (G : Cáµ’áµ–) : IsSeparator (unop G) â†” IsCoseparator G := by\n  rw [IsSeparator, IsCoseparator, â† isSeparating_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isDetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsDetector { unop := G }) (CategoryTheory.IsCodetector G)","decl":"theorem isDetector_op_iff (G : C) : IsDetector (op G) â†” IsCodetector G := by\n  rw [IsDetector, IsCodetector, â† isDetecting_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCodetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCodetector { unop := G }) (CategoryTheory.IsDetector G)","decl":"theorem isCodetector_op_iff (G : C) : IsCodetector (op G) â†” IsDetector G := by\n  rw [IsDetector, IsCodetector, â† isCodetecting_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCodetector_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : Opposite C\nâŠ¢ Iff (CategoryTheory.IsCodetector (Opposite.unop G)) (CategoryTheory.IsDetector G)","decl":"theorem isCodetector_unop_iff (G : Cáµ’áµ–) : IsCodetector (unop G) â†” IsDetector G := by\n  rw [IsDetector, IsCodetector, â† isCodetecting_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isDetector_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : Opposite C\nâŠ¢ Iff (CategoryTheory.IsDetector (Opposite.unop G)) (CategoryTheory.IsCodetector G)","decl":"theorem isDetector_unop_iff (G : Cáµ’áµ–) : IsDetector (unop G) â†” IsCodetector G := by\n  rw [IsDetector, IsCodetector, â† isDetecting_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.IsDetector.isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasEqualizers C\nG : C\naâœ : CategoryTheory.IsDetector G\nâŠ¢ CategoryTheory.IsSeparator G","decl":"theorem IsDetector.isSeparator [HasEqualizers C] {G : C} : IsDetector G â†’ IsSeparator G :=\n  IsDetecting.isSeparating\n\n"}
{"name":"CategoryTheory.IsCodetector.isCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nG : C\naâœ : CategoryTheory.IsCodetector G\nâŠ¢ CategoryTheory.IsCoseparator G","decl":"theorem IsCodetector.isCoseparator [HasCoequalizers C] {G : C} : IsCodetector G â†’ IsCoseparator G :=\n  IsCodetecting.isCoseparating\n\n"}
{"name":"CategoryTheory.IsSeparator.isDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Balanced C\nG : C\naâœ : CategoryTheory.IsSeparator G\nâŠ¢ CategoryTheory.IsDetector G","decl":"theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G â†’ IsDetector G :=\n  IsSeparating.isDetecting\n\n"}
{"name":"CategoryTheory.IsCoseparator.isCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Balanced C\nG : C\naâœ : CategoryTheory.IsCoseparator G\nâŠ¢ CategoryTheory.IsCodetector G","decl":"theorem IsCoseparator.isCodetector [Balanced C] {G : C} : IsCoseparator G â†’ IsCodetector G :=\n  IsCoseparating.isCodetecting\n\n"}
{"name":"CategoryTheory.isSeparator_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsSeparator G) (âˆ€ â¦ƒX Y : Câ¦„ (f g : Quiver.Hom X Y), (âˆ€ (h : Quiver.Hom G X), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)) â†’ Eq f g)","decl":"theorem isSeparator_def (G : C) :\n    IsSeparator G â†” âˆ€ â¦ƒX Y : Câ¦„ (f g : X âŸ¶ Y), (âˆ€ h : G âŸ¶ X, h â‰« f = h â‰« g) â†’ f = g :=\n  âŸ¨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG _ _ _ _ hfg => hG _ _ fun _ => hfg _ (Set.mem_singleton _) _âŸ©\n\n"}
{"name":"CategoryTheory.IsSeparator.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\naâœÂ¹ : CategoryTheory.IsSeparator G\nX Y : C\nf g : Quiver.Hom X Y\naâœ : âˆ€ (h : Quiver.Hom G X), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\nâŠ¢ Eq f g","decl":"theorem IsSeparator.def {G : C} :\n    IsSeparator G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f g : X âŸ¶ Y), (âˆ€ h : G âŸ¶ X, h â‰« f = h â‰« g) â†’ f = g :=\n  (isSeparator_def _).1\n\n"}
{"name":"CategoryTheory.isCoseparator_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCoseparator G) (âˆ€ â¦ƒX Y : Câ¦„ (f g : Quiver.Hom X Y), (âˆ€ (h : Quiver.Hom Y G), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)) â†’ Eq f g)","decl":"theorem isCoseparator_def (G : C) :\n    IsCoseparator G â†” âˆ€ â¦ƒX Y : Câ¦„ (f g : X âŸ¶ Y), (âˆ€ h : Y âŸ¶ G, f â‰« h = g â‰« h) â†’ f = g :=\n  âŸ¨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG _ _ _ _ hfg => hG _ _ fun _ => hfg _ (Set.mem_singleton _) _âŸ©\n\n"}
{"name":"CategoryTheory.IsCoseparator.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\naâœÂ¹ : CategoryTheory.IsCoseparator G\nX Y : C\nf g : Quiver.Hom X Y\naâœ : âˆ€ (h : Quiver.Hom Y G), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\nâŠ¢ Eq f g","decl":"theorem IsCoseparator.def {G : C} :\n    IsCoseparator G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f g : X âŸ¶ Y), (âˆ€ h : Y âŸ¶ G, f â‰« h = g â‰« h) â†’ f = g :=\n  (isCoseparator_def _).1\n\n"}
{"name":"CategoryTheory.isDetector_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsDetector G) (âˆ€ â¦ƒX Y : Câ¦„ (f : Quiver.Hom X Y), (âˆ€ (h : Quiver.Hom G Y), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp h' f) h) â†’ CategoryTheory.IsIso f)","decl":"theorem isDetector_def (G : C) :\n    IsDetector G â†” âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), (âˆ€ h : G âŸ¶ Y, âˆƒ! h', h' â‰« f = h) â†’ IsIso f :=\n  âŸ¨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG _ _ _ hf => hG _ fun _ => hf _ (Set.mem_singleton _) _âŸ©\n\n"}
{"name":"CategoryTheory.IsDetector.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\naâœÂ¹ : CategoryTheory.IsDetector G\nX Y : C\nf : Quiver.Hom X Y\naâœ : âˆ€ (h : Quiver.Hom G Y), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp h' f) h\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem IsDetector.def {G : C} :\n    IsDetector G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), (âˆ€ h : G âŸ¶ Y, âˆƒ! h', h' â‰« f = h) â†’ IsIso f :=\n  (isDetector_def _).1\n\n"}
{"name":"CategoryTheory.isCodetector_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCodetector G) (âˆ€ â¦ƒX Y : Câ¦„ (f : Quiver.Hom X Y), (âˆ€ (h : Quiver.Hom X G), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp f h') h) â†’ CategoryTheory.IsIso f)","decl":"theorem isCodetector_def (G : C) :\n    IsCodetector G â†” âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), (âˆ€ h : X âŸ¶ G, âˆƒ! h', f â‰« h' = h) â†’ IsIso f :=\n  âŸ¨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG _ _ _ hf => hG _ fun _ => hf _ (Set.mem_singleton _) _âŸ©\n\n"}
{"name":"CategoryTheory.IsCodetector.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\naâœÂ¹ : CategoryTheory.IsCodetector G\nX Y : C\nf : Quiver.Hom X Y\naâœ : âˆ€ (h : Quiver.Hom X G), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp f h') h\nâŠ¢ CategoryTheory.IsIso f","decl":"theorem IsCodetector.def {G : C} :\n    IsCodetector G â†’ âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), (âˆ€ h : X âŸ¶ G, âˆƒ! h', f â‰« h' = h) â†’ IsIso f :=\n  (isCodetector_def _).1\n\n"}
{"name":"CategoryTheory.isSeparator_iff_faithful_coyoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsSeparator G) (CategoryTheory.coyoneda.obj { unop := G }).Faithful","decl":"theorem isSeparator_iff_faithful_coyoneda_obj (G : C) :\n    IsSeparator G â†” (coyoneda.obj (op G)).Faithful :=\n  âŸ¨fun hG => âŸ¨fun hfg => hG.def _ _ (congr_fun hfg)âŸ©, fun _ =>\n    (isSeparator_def _).2 fun _ _ _ _ hfg => (coyoneda.obj (op G)).map_injective (funext hfg)âŸ©\n\n"}
{"name":"CategoryTheory.isCoseparator_iff_faithful_yoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCoseparator G) (CategoryTheory.yoneda.obj G).Faithful","decl":"theorem isCoseparator_iff_faithful_yoneda_obj (G : C) : IsCoseparator G â†” (yoneda.obj G).Faithful :=\n  âŸ¨fun hG => âŸ¨fun hfg => Quiver.Hom.unop_inj (hG.def _ _ (congr_fun hfg))âŸ©, fun _ =>\n    (isCoseparator_def _).2 fun _ _ _ _ hfg =>\n      Quiver.Hom.op_inj <| (yoneda.obj G).map_injective (funext hfg)âŸ©\n\n"}
{"name":"CategoryTheory.isSeparator_iff_epi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\ninstâœ : âˆ€ (A : C), CategoryTheory.Limits.HasCoproduct fun x => G\nâŠ¢ Iff (CategoryTheory.IsSeparator G) (âˆ€ (A : C), CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc fun f => f))","decl":"theorem isSeparator_iff_epi (G : C) [âˆ€ A : C, HasCoproduct fun _ : G âŸ¶ A => G] :\n    IsSeparator G â†” âˆ€ A : C, Epi (Sigma.desc fun f : G âŸ¶ A => f) := by\n  rw [isSeparator_def]\n  refine âŸ¨fun h A => âŸ¨fun u v huv => h _ _ fun i => ?_âŸ©, fun h X Y f g hh => ?_âŸ©\n  Â· simpa using Sigma.Î¹ _ i â‰«= huv\n  Â· haveI := h X\n    refine (cancel_epi (Sigma.desc fun f : G âŸ¶ X => f)).1 (colimit.hom_ext fun j => ?_)\n    simpa using hh j.as\n\n"}
{"name":"CategoryTheory.isCoseparator_iff_mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\ninstâœ : âˆ€ (A : C), CategoryTheory.Limits.HasProduct fun x => G\nâŠ¢ Iff (CategoryTheory.IsCoseparator G) (âˆ€ (A : C), CategoryTheory.Mono (CategoryTheory.Limits.Pi.lift fun f => f))","decl":"theorem isCoseparator_iff_mono (G : C) [âˆ€ A : C, HasProduct fun _ : A âŸ¶ G => G] :\n    IsCoseparator G â†” âˆ€ A : C, Mono (Pi.lift fun f : A âŸ¶ G => f) := by\n  rw [isCoseparator_def]\n  refine âŸ¨fun h A => âŸ¨fun u v huv => h _ _ fun i => ?_âŸ©, fun h X Y f g hh => ?_âŸ©\n  Â· simpa using huv =â‰« Pi.Ï€ _ i\n  Â· haveI := h Y\n    refine (cancel_mono (Pi.lift fun f : Y âŸ¶ G => f)).1 (limit.hom_ext fun j => ?_)\n    simpa using hh j.as\n\n"}
{"name":"CategoryTheory.isSeparator_coprod","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproduct G H\nâŠ¢ Iff (CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)) (CategoryTheory.IsSeparating (Insert.insert G (Singleton.singleton H)))","decl":"theorem isSeparator_coprod (G H : C) [HasBinaryCoproduct G H] :\n    IsSeparator (G â¨¿ H) â†” IsSeparating ({G, H} : Set C) := by\n  refine\n    âŸ¨fun h X Y u v huv => ?_, fun h =>\n      (isSeparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_âŸ©\n  Â· refine h.def _ _ fun g => coprod.hom_ext ?_ ?_\n    Â· simpa using huv G (by simp) (coprod.inl â‰« g)\n    Â· simpa using huv H (by simp) (coprod.inr â‰« g)\n  Â· simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    Â· simpa using coprod.inl â‰«= huv (coprod.desc g 0)\n    Â· simpa using coprod.inr â‰«= huv (coprod.desc 0 g)\n\n"}
{"name":"CategoryTheory.isSeparator_coprod_of_isSeparator_left","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproduct G H\nhG : CategoryTheory.IsSeparator G\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)","decl":"theorem isSeparator_coprod_of_isSeparator_left (G H : C) [HasBinaryCoproduct G H]\n    (hG : IsSeparator G) : IsSeparator (G â¨¿ H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hG <| by simp\n\n"}
{"name":"CategoryTheory.isSeparator_coprod_of_isSeparator_right","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryCoproduct G H\nhH : CategoryTheory.IsSeparator H\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)","decl":"theorem isSeparator_coprod_of_isSeparator_right (G H : C) [HasBinaryCoproduct G H]\n    (hH : IsSeparator H) : IsSeparator (G â¨¿ H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hH <| by simp\n\n"}
{"name":"CategoryTheory.isSeparator_of_isColimit_cofan","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\nhf : CategoryTheory.IsSeparating (Set.range f)\nc : CategoryTheory.Limits.Cofan f\nhc : CategoryTheory.Limits.IsColimit c\nâŠ¢ CategoryTheory.IsSeparator c.pt","decl":"lemma isSeparator_of_isColimit_cofan {Î² : Type w} {f : Î² â†’ C}\n    (hf : IsSeparating (Set.range f)) {c : Cofan f} (hc : IsColimit c) : IsSeparator c.pt := by\n  refine (isSeparator_def _).2 fun X Y u v huv => hf _ _ fun Z hZ g => ?_\n  obtain âŸ¨b, rflâŸ© := Set.mem_range.1 hZ\n  classical simpa using c.Î¹.app âŸ¨bâŸ© â‰«= huv (hc.desc (Cofan.mk _ (Pi.single b g)))\n\n"}
{"name":"CategoryTheory.isSeparator_sigma","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nâŠ¢ Iff (CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)) (CategoryTheory.IsSeparating (Set.range f))","decl":"theorem isSeparator_sigma {Î² : Type w} (f : Î² â†’ C) [HasCoproduct f] :\n    IsSeparator (âˆ f) â†” IsSeparating (Set.range f) := by\n  refine âŸ¨fun h X Y u v huv => ?_, fun h => isSeparator_of_isColimit_cofan h (colimit.isColimit _)âŸ©\n  refine h.def _ _ fun g => colimit.hom_ext fun b => ?_\n  simpa using huv (f b.as) (by simp) (colimit.Î¹ (Discrete.functor f) _ â‰« g)\n\n"}
{"name":"CategoryTheory.IsSeparating.isSeparator_coproduct","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nhS : CategoryTheory.IsSeparating (Set.range f)\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)","decl":"theorem IsSeparating.isSeparator_coproduct {Î² : Type w} {f : Î² â†’ C} [HasCoproduct f]\n    (hS : IsSeparating (Set.range f)) : IsSeparator (âˆ f) :=\n  (isSeparator_sigma _).2 hS\n\n"}
{"name":"CategoryTheory.isSeparator_sigma_of_isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasCoproduct f\nb : Î²\nhb : CategoryTheory.IsSeparator (f b)\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)","decl":"theorem isSeparator_sigma_of_isSeparator {Î² : Type w} (f : Î² â†’ C) [HasCoproduct f] (b : Î²)\n    (hb : IsSeparator (f b)) : IsSeparator (âˆ f) :=\n  (isSeparator_sigma _).2 <| IsSeparating.mono hb <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_prod","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct G H\nâŠ¢ Iff (CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)) (CategoryTheory.IsCoseparating (Insert.insert G (Singleton.singleton H)))","decl":"theorem isCoseparator_prod (G H : C) [HasBinaryProduct G H] :\n    IsCoseparator (G â¨¯ H) â†” IsCoseparating ({G, H} : Set C) := by\n  refine\n    âŸ¨fun h X Y u v huv => ?_, fun h =>\n      (isCoseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_âŸ©\n  Â· refine h.def _ _ fun g => Limits.prod.hom_ext ?_ ?_\n    Â· simpa using huv G (by simp) (g â‰« Limits.prod.fst)\n    Â· simpa using huv H (by simp) (g â‰« Limits.prod.snd)\n  Â· simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    Â· simpa using huv (prod.lift g 0) =â‰« Limits.prod.fst\n    Â· simpa using huv (prod.lift 0 g) =â‰« Limits.prod.snd\n\n"}
{"name":"CategoryTheory.isCoseparator_prod_of_isCoseparator_left","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct G H\nhG : CategoryTheory.IsCoseparator G\nâŠ¢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)","decl":"theorem isCoseparator_prod_of_isCoseparator_left (G H : C) [HasBinaryProduct G H]\n    (hG : IsCoseparator G) : IsCoseparator (G â¨¯ H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hG <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_prod_of_isCoseparator_right","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninstâœ : CategoryTheory.Limits.HasBinaryProduct G H\nhH : CategoryTheory.IsCoseparator H\nâŠ¢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)","decl":"theorem isCoseparator_prod_of_isCoseparator_right (G H : C) [HasBinaryProduct G H]\n    (hH : IsCoseparator H) : IsCoseparator (G â¨¯ H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hH <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_pi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nâŠ¢ Iff (CategoryTheory.IsCoseparator (CategoryTheory.Limits.piObj f)) (CategoryTheory.IsCoseparating (Set.range f))","decl":"theorem isCoseparator_pi {Î² : Type w} (f : Î² â†’ C) [HasProduct f] :\n    IsCoseparator (âˆá¶œ f) â†” IsCoseparating (Set.range f) := by\n  refine\n    âŸ¨fun h X Y u v huv => ?_, fun h =>\n      (isCoseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_âŸ©\n  Â· refine h.def _ _ fun g => limit.hom_ext fun b => ?_\n    simpa using huv (f b.as) (by simp) (g â‰« limit.Ï€ (Discrete.functor f) _)\n  Â· obtain âŸ¨b, rflâŸ© := Set.mem_range.1 hZ\n    classical simpa using huv (Pi.lift (Pi.single b g)) =â‰« Pi.Ï€ f b\n\n"}
{"name":"CategoryTheory.isCoseparator_pi_of_isCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nf : Î² â†’ C\ninstâœ : CategoryTheory.Limits.HasProduct f\nb : Î²\nhb : CategoryTheory.IsCoseparator (f b)\nâŠ¢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.piObj f)","decl":"theorem isCoseparator_pi_of_isCoseparator {Î² : Type w} (f : Î² â†’ C) [HasProduct f] (b : Î²)\n    (hb : IsCoseparator (f b)) : IsCoseparator (âˆá¶œ f) :=\n  (isCoseparator_pi _).2 <| IsCoseparating.mono hb <| by simp\n\n"}
{"name":"CategoryTheory.isDetector_iff_reflectsIsomorphisms_coyoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsDetector G) (CategoryTheory.coyoneda.obj { unop := G }).ReflectsIsomorphisms","decl":"theorem isDetector_iff_reflectsIsomorphisms_coyoneda_obj (G : C) :\n    IsDetector G â†” (coyoneda.obj (op G)).ReflectsIsomorphisms := by\n  refine\n    âŸ¨fun hG => âŸ¨fun f hf => hG.def _ fun h => ?_âŸ©, fun h =>\n      (isDetector_def _).2 fun X Y f hf => ?_âŸ©\n  Â· rw [isIso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n    exact hf h\n  Â· suffices IsIso ((coyoneda.obj (op G)).map f) by\n      exact @isIso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique]\n\n"}
{"name":"CategoryTheory.isCodetector_iff_reflectsIsomorphisms_yoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nG : C\nâŠ¢ Iff (CategoryTheory.IsCodetector G) (CategoryTheory.yoneda.obj G).ReflectsIsomorphisms","decl":"theorem isCodetector_iff_reflectsIsomorphisms_yoneda_obj (G : C) :\n    IsCodetector G â†” (yoneda.obj G).ReflectsIsomorphisms := by\n  refine âŸ¨fun hG => âŸ¨fun f hf => ?_âŸ©, fun h => (isCodetector_def _).2 fun X Y f hf => ?_âŸ©\n  Â· refine (isIso_unop_iff _).1 (hG.def _ ?_)\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n  Â· rw [â† isIso_op_iff]\n    suffices IsIso ((yoneda.obj G).map f.op) by\n      exact @isIso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique]\n\n"}
{"name":"CategoryTheory.wellPowered_of_isDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.Limits.HasPullbacks C\nG : C\nhG : CategoryTheory.IsDetector G\nâŠ¢ CategoryTheory.WellPowered.{vâ‚, vâ‚, uâ‚} C","decl":"theorem wellPowered_of_isDetector [HasPullbacks C] (G : C) (hG : IsDetector G) :\n    WellPowered.{vâ‚} C :=\n  -- Porting note: added the following `haveI` to prevent universe issues\n  haveI := small_subsingleton ({G} : Set C)\n  wellPowered_of_isDetecting hG\n\n"}
{"name":"CategoryTheory.wellPowered_of_isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasPullbacks C\ninstâœ : CategoryTheory.Balanced C\nG : C\nhG : CategoryTheory.IsSeparator G\nâŠ¢ CategoryTheory.WellPowered.{vâ‚, vâ‚, uâ‚} C","decl":"theorem wellPowered_of_isSeparator [HasPullbacks C] [Balanced C] (G : C) (hG : IsSeparator G) :\n    WellPowered.{vâ‚} C := wellPowered_of_isDetecting hG.isDetector\n\n"}
{"name":"CategoryTheory.HasSeparator.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nself : CategoryTheory.HasSeparator C\nâŠ¢ Exists fun G => CategoryTheory.IsSeparator G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a separator of `C` if\nthe functor `C(G, -)` is faithful.\n\nWhile `IsSeparator G : Prop` is the proposition that `G` is a separator of `C`,\nan `HasSeparator C : Prop` is the proposition that such a separator exists.\nNote that `HasSeparator C` is a proposition. It does not designate a favored separator\nand merely asserts the existence of one.\n-/\nclass HasSeparator : Prop where\n  hasSeparator : âˆƒ G : C, IsSeparator G\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nself : CategoryTheory.HasCoseparator C\nâŠ¢ Exists fun G => CategoryTheory.IsCoseparator G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a coseparator of `C` if\nthe functor `C(-, G)` is faithful.\n\nWhile `IsCoseparator G : Prop` is the proposition that `G` is a coseparator of `C`,\nan `HasCoseparator C : Prop` is the proposition that such a coseparator exists.\nNote that `HasCoseparator C` is a proposition. It does not designate a favored coseparator\nand merely asserts the existence of one.\n-/\nclass HasCoseparator : Prop where\n  hasCoseparator : âˆƒ G : C, IsCoseparator G\n\n"}
{"name":"CategoryTheory.HasDetector.hasDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nself : CategoryTheory.HasDetector C\nâŠ¢ Exists fun G => CategoryTheory.IsDetector G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a detector of `C` if\nthe functor `C(G, -)` reflects isomorphisms.\n\nWhile `IsDetector G : Prop` is the proposition that `G` is a detector of `C`,\nan `HasDetector C : Prop` is the proposition that such a detector exists.\nNote that `HasDetector C` is a proposition. It does not designate a favored detector\nand merely asserts the existence of one.\n-/\nclass HasDetector : Prop where\n  hasDetector : âˆƒ G : C, IsDetector G\n\n"}
{"name":"CategoryTheory.HasCodetector.hasCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nself : CategoryTheory.HasCodetector C\nâŠ¢ Exists fun G => CategoryTheory.IsCodetector G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a codetector of `C` if\nthe functor `C(-, G)` reflects isomorphisms.\n\nWhile `IsCodetector G : Prop` is the proposition that `G` is a codetector of `C`,\nan `HasCodetector C : Prop` is the proposition that such a codetector exists.\nNote that `HasCodetector C` is a proposition. It does not designate a favored codetector\nand merely asserts the existence of one.\n-/\nclass HasCodetector : Prop where\n  hasCodetector : âˆƒ G : C, IsCodetector G\n\n"}
{"name":"CategoryTheory.isSeparator_separator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasSeparator C\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.separator C)","decl":"theorem isSeparator_separator [HasSeparator C] : IsSeparator (separator C) :=\n  HasSeparator.hasSeparator.choose_spec\n\n"}
{"name":"CategoryTheory.isDetector_separator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Balanced C\ninstâœ : CategoryTheory.HasSeparator C\nâŠ¢ CategoryTheory.IsDetector (CategoryTheory.separator C)","decl":"theorem isDetector_separator [Balanced C] [HasSeparator C] : IsDetector (separator C) :=\n  isSeparator_separator C |>.isDetector\n\n"}
{"name":"CategoryTheory.isCoseparator_coseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCoseparator C\nâŠ¢ CategoryTheory.IsCoseparator (CategoryTheory.coseparator C)","decl":"theorem isCoseparator_coseparator [HasCoseparator C] : IsCoseparator (coseparator C) :=\n  HasCoseparator.hasCoseparator.choose_spec\n\n"}
{"name":"CategoryTheory.isCodetector_coseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Balanced C\ninstâœ : CategoryTheory.HasCoseparator C\nâŠ¢ CategoryTheory.IsCodetector (CategoryTheory.coseparator C)","decl":"theorem isCodetector_coseparator [Balanced C] [HasCoseparator C] : IsCodetector (coseparator C) :=\n  isCoseparator_coseparator C |>.isCodetector\n\n"}
{"name":"CategoryTheory.isDetector_detector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasDetector C\nâŠ¢ CategoryTheory.IsDetector (CategoryTheory.detector C)","decl":"theorem isDetector_detector [HasDetector C] : IsDetector (detector C) :=\n  HasDetector.hasDetector.choose_spec\n\n"}
{"name":"CategoryTheory.isSeparator_detector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasEqualizers C\ninstâœ : CategoryTheory.HasDetector C\nâŠ¢ CategoryTheory.IsSeparator (CategoryTheory.detector C)","decl":"theorem isSeparator_detector [HasEqualizers C] [HasDetector C] : IsSeparator (detector C) :=\n  isDetector_detector C |>.isSeparator\n\n"}
{"name":"CategoryTheory.isCodetector_codetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCodetector C\nâŠ¢ CategoryTheory.IsCodetector (CategoryTheory.codetector C)","decl":"theorem isCodetector_codetector [HasCodetector C] : IsCodetector (codetector C) :=\n  HasCodetector.hasCodetector.choose_spec\n\n"}
{"name":"CategoryTheory.isCoseparator_codetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : CategoryTheory.HasCodetector C\nâŠ¢ CategoryTheory.IsCoseparator (CategoryTheory.codetector C)","decl":"theorem isCoseparator_codetector [HasCoequalizers C] [HasCodetector C] :\n    IsCoseparator (codetector C) := isCodetector_codetector C |>.isCoseparator\n\n"}
{"name":"CategoryTheory.HasSeparator.hasDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Balanced C\ninstâœ : CategoryTheory.HasSeparator C\nâŠ¢ CategoryTheory.HasDetector C","decl":"theorem HasSeparator.hasDetector [Balanced C] [HasSeparator C] : HasDetector C :=\n  âŸ¨_, isDetector_separator CâŸ©\n\n"}
{"name":"CategoryTheory.HasDetector.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasEqualizers C\ninstâœ : CategoryTheory.HasDetector C\nâŠ¢ CategoryTheory.HasSeparator C","decl":"theorem HasDetector.hasSeparator [HasEqualizers C] [HasDetector C] : HasSeparator C :=\n  âŸ¨_, isSeparator_detector CâŸ©\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Balanced C\ninstâœ : CategoryTheory.HasCoseparator C\nâŠ¢ CategoryTheory.HasCodetector C","decl":"theorem HasCoseparator.hasCodetector [Balanced C] [HasCoseparator C] : HasCodetector C :=\n  âŸ¨_, isCodetector_coseparator CâŸ©\n\n"}
{"name":"CategoryTheory.HasCodetector.hasCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : CategoryTheory.HasCodetector C\nâŠ¢ CategoryTheory.HasCoseparator C","decl":"theorem HasCodetector.hasCoseparator [HasCoequalizers C] [HasCodetector C] : HasCoseparator C :=\n  âŸ¨_, isCoseparator_codetector CâŸ©\n\n"}
{"name":"CategoryTheory.HasDetector.wellPowered","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.Limits.HasPullbacks C\ninstâœ : CategoryTheory.HasDetector C\nâŠ¢ CategoryTheory.WellPowered.{vâ‚, vâ‚, uâ‚} C","decl":"instance HasDetector.wellPowered [HasPullbacks C] [HasDetector C] : WellPowered.{vâ‚} C :=\n  isDetector_detector C |> wellPowered_of_isDetector _\n\n"}
{"name":"CategoryTheory.HasSeparator.wellPowered","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.Limits.HasPullbacks C\ninstâœÂ¹ : CategoryTheory.Balanced C\ninstâœ : CategoryTheory.HasSeparator C\nâŠ¢ CategoryTheory.WellPowered.{vâ‚, vâ‚, uâ‚} C","decl":"instance HasSeparator.wellPowered [HasPullbacks C] [Balanced C] [HasSeparator C] :\n    WellPowered.{vâ‚} C := HasSeparator.hasDetector.wellPowered\n\n"}
{"name":"CategoryTheory.HasSeparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.HasSeparator C\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.HasSeparator D","decl":"theorem HasSeparator.of_equivalence [HasSeparator C] (Î± : C â‰Œ D) : HasSeparator D :=\n  âŸ¨Î±.functor.obj (separator C), isSeparator_separator C |>.of_equivalence Î±âŸ©\n\n"}
{"name":"CategoryTheory.HasCoseparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœ : CategoryTheory.HasCoseparator C\nÎ± : CategoryTheory.Equivalence C D\nâŠ¢ CategoryTheory.HasCoseparator D","decl":"theorem HasCoseparator.of_equivalence [HasCoseparator C] (Î± : C â‰Œ D) : HasCoseparator D :=\n  âŸ¨Î±.functor.obj (coseparator C), isCoseparator_coseparator C |>.of_equivalence Î±âŸ©\n\n"}
{"name":"CategoryTheory.hasSeparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Iff (CategoryTheory.HasSeparator (Opposite C)) (CategoryTheory.HasCoseparator C)","decl":"@[simp]\ntheorem hasSeparator_op_iff : HasSeparator Cáµ’áµ– â†” HasCoseparator C :=\n  âŸ¨fun âŸ¨G, hGâŸ© => âŸ¨unop G, (isCoseparator_unop_iff G).mpr hGâŸ©,\n   fun âŸ¨G, hGâŸ© => âŸ¨op G, (isSeparator_op_iff G).mpr hGâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.hasCoseparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Iff (CategoryTheory.HasCoseparator (Opposite C)) (CategoryTheory.HasSeparator C)","decl":"@[simp]\ntheorem hasCoseparator_op_iff : HasCoseparator Cáµ’áµ– â†” HasSeparator C :=\n  âŸ¨fun âŸ¨G, hGâŸ© => âŸ¨unop G, (isSeparator_unop_iff G).mpr hGâŸ©,\n   fun âŸ¨G, hGâŸ© => âŸ¨op G, (isCoseparator_op_iff G).mpr hGâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.hasDetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Iff (CategoryTheory.HasDetector (Opposite C)) (CategoryTheory.HasCodetector C)","decl":"@[simp]\ntheorem hasDetector_op_iff : HasDetector Cáµ’áµ– â†” HasCodetector C :=\n  âŸ¨fun âŸ¨G, hGâŸ© => âŸ¨unop G, (isCodetector_unop_iff G).mpr hGâŸ©,\n   fun âŸ¨G, hGâŸ© => âŸ¨op G, (isDetector_op_iff G).mpr hGâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.hasCodetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Iff (CategoryTheory.HasCodetector (Opposite C)) (CategoryTheory.HasDetector C)","decl":"@[simp]\ntheorem hasCodetector_op_iff : HasCodetector Cáµ’áµ– â†” HasDetector C :=\n  âŸ¨fun âŸ¨G, hGâŸ© => âŸ¨unop G, (isDetector_unop_iff G).mpr hGâŸ©,\n   fun âŸ¨G, hGâŸ© => âŸ¨op G, (isCodetector_op_iff G).mpr hGâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.HasSeparator.hasCoseparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasSeparator C\nâŠ¢ CategoryTheory.HasCoseparator (Opposite C)","decl":"instance HasSeparator.hasCoseparator_op [HasSeparator C] : HasCoseparator Cáµ’áµ– := by simp [*]\n"}
{"name":"CategoryTheory.HasSeparator.hasCoseparator_of_hasSeparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nh : CategoryTheory.HasSeparator (Opposite C)\nâŠ¢ CategoryTheory.HasCoseparator C","decl":"theorem HasSeparator.hasCoseparator_of_hasSeparator_op [h : HasSeparator Cáµ’áµ–] :\n    HasCoseparator C := by simp_all\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasSeparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCoseparator C\nâŠ¢ CategoryTheory.HasSeparator (Opposite C)","decl":"instance HasCoseparator.hasSeparator_op [HasCoseparator C] : HasSeparator Cáµ’áµ– := by simp [*]\n"}
{"name":"CategoryTheory.HasCoseparator.hasSeparator_of_hasCoseparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCoseparator (Opposite C)\nâŠ¢ CategoryTheory.HasSeparator C","decl":"theorem HasCoseparator.hasSeparator_of_hasCoseparator_op [HasCoseparator Cáµ’áµ–] :\n    HasSeparator C := by simp_all\n\n"}
{"name":"CategoryTheory.HasDetector.hasCodetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasDetector C\nâŠ¢ CategoryTheory.HasCodetector (Opposite C)","decl":"instance HasDetector.hasCodetector_op [HasDetector C] : HasCodetector Cáµ’áµ– := by simp [*]\n"}
{"name":"CategoryTheory.HasDetector.hasCodetector_of_hasDetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasDetector (Opposite C)\nâŠ¢ CategoryTheory.HasCodetector C","decl":"theorem HasDetector.hasCodetector_of_hasDetector_op [HasDetector Cáµ’áµ–] :\n    HasCodetector C := by simp_all\n\n"}
{"name":"CategoryTheory.HasCodetector.hasDetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCodetector C\nâŠ¢ CategoryTheory.HasDetector (Opposite C)","decl":"instance HasCodetector.hasDetector_op [HasCodetector C] : HasDetector Cáµ’áµ– := by simp [*]\n"}
{"name":"CategoryTheory.HasCodetector.hasDetector_of_hasCodetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.HasCodetector (Opposite C)\nâŠ¢ CategoryTheory.HasDetector C","decl":"theorem HasCodetector.hasDetector_of_hasCodetector_op [HasCodetector Cáµ’áµ–] :\n    HasDetector C := by simp_all\n\n"}
