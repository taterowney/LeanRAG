{"name":"CategoryTheory.IsSeparating.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh : CategoryTheory.IsSeparating 𝒢\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsSeparating (Set.image α.functor.obj 𝒢)","decl":"lemma IsSeparating.of_equivalence\n    {𝒢 : Set C} (h : IsSeparating 𝒢) {D : Type*} [Category D] (α : C ≌ D) :\n    IsSeparating (α.functor.obj '' 𝒢) := fun X Y f g H =>\n  α.inverse.map_injective (h _ _ (fun Z hZ h => by\n    obtain ⟨h', rfl⟩ := (α.toAdjunction.homEquiv _ _).surjective h\n    simp only [Adjunction.homEquiv_unit, Category.assoc, ← Functor.map_comp,\n      H (α.functor.obj Z) (Set.mem_image_of_mem _ hZ) h']))\n\n"}
{"name":"CategoryTheory.IsCoseparating.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh : CategoryTheory.IsCoseparating 𝒢\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsCoseparating (Set.image α.functor.obj 𝒢)","decl":"lemma IsCoseparating.of_equivalence\n    {𝒢 : Set C} (h : IsCoseparating 𝒢) {D : Type*} [Category D] (α : C ≌ D) :\n    IsCoseparating (α.functor.obj '' 𝒢) := fun X Y f g H =>\n  α.inverse.map_injective (h _ _ (fun Z hZ h => by\n    obtain ⟨h', rfl⟩ := (α.symm.toAdjunction.homEquiv _ _).symm.surjective h\n    simp only [Adjunction.homEquiv_symm_apply, ← Category.assoc, ← Functor.map_comp,\n      Equivalence.symm_functor, H (α.functor.obj Z) (Set.mem_image_of_mem _ hZ) h']))\n\n"}
{"name":"CategoryTheory.isSeparating_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsSeparating 𝒢.op) (CategoryTheory.IsCoseparating 𝒢)","decl":"theorem isSeparating_op_iff (𝒢 : Set C) : IsSeparating 𝒢.op ↔ IsCoseparating 𝒢 := by\n  refine ⟨fun h𝒢 X Y f g hfg => ?_, fun h𝒢 X Y f g hfg => ?_⟩\n  · refine Quiver.Hom.op_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.unop_inj ?_)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  · refine Quiver.Hom.unop_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.op_inj ?_)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n\n"}
{"name":"CategoryTheory.isCoseparating_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsCoseparating 𝒢.op) (CategoryTheory.IsSeparating 𝒢)","decl":"theorem isCoseparating_op_iff (𝒢 : Set C) : IsCoseparating 𝒢.op ↔ IsSeparating 𝒢 := by\n  refine ⟨fun h𝒢 X Y f g hfg => ?_, fun h𝒢 X Y f g hfg => ?_⟩\n  · refine Quiver.Hom.op_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.unop_inj ?_)\n    simpa only [unop_comp, Quiver.Hom.unop_op] using hfg _ (Set.mem_op.1 hG) _\n  · refine Quiver.Hom.unop_inj (h𝒢 _ _ fun G hG h => Quiver.Hom.op_inj ?_)\n    simpa only [op_comp, Quiver.Hom.op_unop] using hfg _ (Set.op_mem_op.2 hG) _\n\n"}
{"name":"CategoryTheory.isCoseparating_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set (Opposite C)\n⊢ Iff (CategoryTheory.IsCoseparating 𝒢.unop) (CategoryTheory.IsSeparating 𝒢)","decl":"theorem isCoseparating_unop_iff (𝒢 : Set Cᵒᵖ) : IsCoseparating 𝒢.unop ↔ IsSeparating 𝒢 := by\n  rw [← isSeparating_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isSeparating_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set (Opposite C)\n⊢ Iff (CategoryTheory.IsSeparating 𝒢.unop) (CategoryTheory.IsCoseparating 𝒢)","decl":"theorem isSeparating_unop_iff (𝒢 : Set Cᵒᵖ) : IsSeparating 𝒢.unop ↔ IsCoseparating 𝒢 := by\n  rw [← isCoseparating_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isDetecting_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsDetecting 𝒢.op) (CategoryTheory.IsCodetecting 𝒢)","decl":"theorem isDetecting_op_iff (𝒢 : Set C) : IsDetecting 𝒢.op ↔ IsCodetecting 𝒢 := by\n  refine ⟨fun h𝒢 X Y f hf => ?_, fun h𝒢 X Y f hf => ?_⟩\n  · refine (isIso_op_iff _).1 (h𝒢 _ fun G hG h => ?_)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact\n      ⟨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))⟩\n  · refine (isIso_unop_iff _).1 (h𝒢 _ fun G hG h => ?_)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine ⟨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ ?_)⟩\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n\n"}
{"name":"CategoryTheory.isCodetecting_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsCodetecting 𝒢.op) (CategoryTheory.IsDetecting 𝒢)","decl":"theorem isCodetecting_op_iff (𝒢 : Set C) : IsCodetecting 𝒢.op ↔ IsDetecting 𝒢 := by\n  refine ⟨fun h𝒢 X Y f hf => ?_, fun h𝒢 X Y f hf => ?_⟩\n  · refine (isIso_op_iff _).1 (h𝒢 _ fun G hG h => ?_)\n    obtain ⟨t, ht, ht'⟩ := hf (unop G) (Set.mem_op.1 hG) h.unop\n    exact\n      ⟨t.op, Quiver.Hom.unop_inj ht, fun y hy => Quiver.Hom.unop_inj (ht' _ (Quiver.Hom.op_inj hy))⟩\n  · refine (isIso_unop_iff _).1 (h𝒢 _ fun G hG h => ?_)\n    obtain ⟨t, ht, ht'⟩ := hf (op G) (Set.op_mem_op.2 hG) h.op\n    refine ⟨t.unop, Quiver.Hom.op_inj ht, fun y hy => Quiver.Hom.op_inj (ht' _ ?_)⟩\n    exact Quiver.Hom.unop_inj (by simpa only using hy)\n\n"}
{"name":"CategoryTheory.isDetecting_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set (Opposite C)\n⊢ Iff (CategoryTheory.IsDetecting 𝒢.unop) (CategoryTheory.IsCodetecting 𝒢)","decl":"theorem isDetecting_unop_iff (𝒢 : Set Cᵒᵖ) : IsDetecting 𝒢.unop ↔ IsCodetecting 𝒢 := by\n  rw [← isCodetecting_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.isCodetecting_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set (Opposite C)\n⊢ Iff (CategoryTheory.IsCodetecting 𝒢.unop) (CategoryTheory.IsDetecting 𝒢)","decl":"theorem isCodetecting_unop_iff {𝒢 : Set Cᵒᵖ} : IsCodetecting 𝒢.unop ↔ IsDetecting 𝒢 := by\n  rw [← isDetecting_op_iff, Set.unop_op]\n\n"}
{"name":"CategoryTheory.IsDetecting.isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\n⊢ CategoryTheory.IsSeparating 𝒢","decl":"theorem IsDetecting.isSeparating [HasEqualizers C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) :\n    IsSeparating 𝒢 := fun _ _ f g hfg =>\n  have : IsIso (equalizer.ι f g) := h𝒢 _ fun _ hG _ => equalizer.existsUnique _ (hfg _ hG _)\n  eq_of_epi_equalizer\n\n"}
{"name":"CategoryTheory.IsCodetecting.isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n𝒢 : Set C\na✝ : CategoryTheory.IsCodetecting 𝒢\n⊢ CategoryTheory.IsCoseparating 𝒢","decl":"theorem IsCodetecting.isCoseparating [HasCoequalizers C] {𝒢 : Set C} :\n    IsCodetecting 𝒢 → IsCoseparating 𝒢 := by\n  simpa only [← isSeparating_op_iff, ← isDetecting_op_iff] using IsDetecting.isSeparating\n\n"}
{"name":"CategoryTheory.IsSeparating.isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Balanced C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsSeparating 𝒢\n⊢ CategoryTheory.IsDetecting 𝒢","decl":"theorem IsSeparating.isDetecting [Balanced C] {𝒢 : Set C} (h𝒢 : IsSeparating 𝒢) :\n    IsDetecting 𝒢 := by\n  intro X Y f hf\n  refine\n    (isIso_iff_mono_and_epi _).2 ⟨⟨fun g h hgh => h𝒢 _ _ fun G hG i => ?_⟩, ⟨fun g h hgh => ?_⟩⟩\n  · obtain ⟨t, -, ht⟩ := hf G hG (i ≫ g ≫ f)\n    rw [ht (i ≫ g) (Category.assoc _ _ _), ht (i ≫ h) (hgh.symm ▸ Category.assoc _ _ _)]\n  · refine h𝒢 _ _ fun G hG i => ?_\n    obtain ⟨t, rfl, -⟩ := hf G hG i\n    rw [Category.assoc, hgh, Category.assoc]\n\n"}
{"name":"CategoryTheory.IsCoseparating.isCodetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Balanced C\n𝒢 : Set C\na✝ : CategoryTheory.IsCoseparating 𝒢\n⊢ CategoryTheory.IsCodetecting 𝒢","decl":"theorem IsCoseparating.isCodetecting [Balanced C] {𝒢 : Set C} :\n    IsCoseparating 𝒢 → IsCodetecting 𝒢 := by\n  simpa only [← isDetecting_op_iff, ← isSeparating_op_iff] using IsSeparating.isDetecting\n\n"}
{"name":"CategoryTheory.isDetecting_iff_isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasEqualizers C\ninst✝ : CategoryTheory.Balanced C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsDetecting 𝒢) (CategoryTheory.IsSeparating 𝒢)","decl":"theorem isDetecting_iff_isSeparating [HasEqualizers C] [Balanced C] (𝒢 : Set C) :\n    IsDetecting 𝒢 ↔ IsSeparating 𝒢 :=\n  ⟨IsDetecting.isSeparating, IsSeparating.isDetecting⟩\n\n"}
{"name":"CategoryTheory.isCodetecting_iff_isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : CategoryTheory.Balanced C\n𝒢 : Set C\n⊢ Iff (CategoryTheory.IsCodetecting 𝒢) (CategoryTheory.IsCoseparating 𝒢)","decl":"theorem isCodetecting_iff_isCoseparating [HasCoequalizers C] [Balanced C] {𝒢 : Set C} :\n    IsCodetecting 𝒢 ↔ IsCoseparating 𝒢 :=\n  ⟨IsCodetecting.isCoseparating, IsCoseparating.isCodetecting⟩\n\n"}
{"name":"CategoryTheory.IsSeparating.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsSeparating 𝒢\nℋ : Set C\nh𝒢ℋ : HasSubset.Subset 𝒢 ℋ\n⊢ CategoryTheory.IsSeparating ℋ","decl":"theorem IsSeparating.mono {𝒢 : Set C} (h𝒢 : IsSeparating 𝒢) {ℋ : Set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) :\n    IsSeparating ℋ := fun _ _ _ _ hfg => h𝒢 _ _ fun _ hG _ => hfg _ (h𝒢ℋ hG) _\n\n"}
{"name":"CategoryTheory.IsCoseparating.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsCoseparating 𝒢\nℋ : Set C\nh𝒢ℋ : HasSubset.Subset 𝒢 ℋ\n⊢ CategoryTheory.IsCoseparating ℋ","decl":"theorem IsCoseparating.mono {𝒢 : Set C} (h𝒢 : IsCoseparating 𝒢) {ℋ : Set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) :\n    IsCoseparating ℋ := fun _ _ _ _ hfg => h𝒢 _ _ fun _ hG _ => hfg _ (h𝒢ℋ hG) _\n\n"}
{"name":"CategoryTheory.IsDetecting.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\nℋ : Set C\nh𝒢ℋ : HasSubset.Subset 𝒢 ℋ\n⊢ CategoryTheory.IsDetecting ℋ","decl":"theorem IsDetecting.mono {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {ℋ : Set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) :\n    IsDetecting ℋ := fun _ _ _ hf => h𝒢 _ fun _ hG _ => hf _ (h𝒢ℋ hG) _\n\n"}
{"name":"CategoryTheory.IsCodetecting.mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsCodetecting 𝒢\nℋ : Set C\nh𝒢ℋ : HasSubset.Subset 𝒢 ℋ\n⊢ CategoryTheory.IsCodetecting ℋ","decl":"theorem IsCodetecting.mono {𝒢 : Set C} (h𝒢 : IsCodetecting 𝒢) {ℋ : Set C} (h𝒢ℋ : 𝒢 ⊆ ℋ) :\n    IsCodetecting ℋ := fun _ _ _ hf => h𝒢 _ fun _ hG _ => hf _ (h𝒢ℋ hG) _\n\n"}
{"name":"CategoryTheory.thin_of_isSeparating_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.IsSeparating EmptyCollection.emptyCollection\n⊢ Quiver.IsThin C","decl":"theorem thin_of_isSeparating_empty (h : IsSeparating (∅ : Set C)) : Quiver.IsThin C := fun _ _ =>\n  ⟨fun _ _ => h _ _ fun _ => False.elim⟩\n\n"}
{"name":"CategoryTheory.isSeparating_empty_of_thin","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ CategoryTheory.IsSeparating EmptyCollection.emptyCollection","decl":"theorem isSeparating_empty_of_thin [Quiver.IsThin C] : IsSeparating (∅ : Set C) :=\n  fun _ _ _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.thin_of_isCoseparating_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.IsCoseparating EmptyCollection.emptyCollection\n⊢ Quiver.IsThin C","decl":"theorem thin_of_isCoseparating_empty (h : IsCoseparating (∅ : Set C)) : Quiver.IsThin C :=\n  fun _ _ => ⟨fun _ _ => h _ _ fun _ => False.elim⟩\n\n"}
{"name":"CategoryTheory.isCoseparating_empty_of_thin","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : Quiver.IsThin C\n⊢ CategoryTheory.IsCoseparating EmptyCollection.emptyCollection","decl":"theorem isCoseparating_empty_of_thin [Quiver.IsThin C] : IsCoseparating (∅ : Set C) :=\n  fun _ _ _ _ _ => Subsingleton.elim _ _\n\n"}
{"name":"CategoryTheory.groupoid_of_isDetecting_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.IsDetecting EmptyCollection.emptyCollection\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.IsIso f","decl":"theorem groupoid_of_isDetecting_empty (h : IsDetecting (∅ : Set C)) {X Y : C} (f : X ⟶ Y) :\n    IsIso f :=\n  h _ fun _ => False.elim\n\n"}
{"name":"CategoryTheory.isDetecting_empty_of_groupoid","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso f\n⊢ CategoryTheory.IsDetecting EmptyCollection.emptyCollection","decl":"theorem isDetecting_empty_of_groupoid [∀ {X Y : C} (f : X ⟶ Y), IsIso f] :\n    IsDetecting (∅ : Set C) := fun _ _ _ _ => inferInstance\n\n"}
{"name":"CategoryTheory.groupoid_of_isCodetecting_empty","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.IsCodetecting EmptyCollection.emptyCollection\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.IsIso f","decl":"theorem groupoid_of_isCodetecting_empty (h : IsCodetecting (∅ : Set C)) {X Y : C} (f : X ⟶ Y) :\n    IsIso f :=\n  h _ fun _ => False.elim\n\n"}
{"name":"CategoryTheory.isCodetecting_empty_of_groupoid","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso f\n⊢ CategoryTheory.IsCodetecting EmptyCollection.emptyCollection","decl":"theorem isCodetecting_empty_of_groupoid [∀ {X Y : C} (f : X ⟶ Y), IsIso f] :\n    IsCodetecting (∅ : Set C) := fun _ _ _ _ => inferInstance\n\n"}
{"name":"CategoryTheory.isSeparating_iff_epi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasCoproduct fun f => ↑f.fst\n⊢ Iff (CategoryTheory.IsSeparating 𝒢) (∀ (A : C), CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc Sigma.snd))","decl":"theorem isSeparating_iff_epi (𝒢 : Set C)\n    [∀ A : C, HasCoproduct fun f : ΣG : 𝒢, (G : C) ⟶ A => (f.1 : C)] :\n    IsSeparating 𝒢 ↔ ∀ A : C, Epi (Sigma.desc (@Sigma.snd 𝒢 fun G => (G : C) ⟶ A)) := by\n  refine ⟨fun h A => ⟨fun u v huv => h _ _ fun G hG f => ?_⟩, fun h X Y f g hh => ?_⟩\n  · simpa using Sigma.ι (fun f : ΣG : 𝒢, (G : C) ⟶ A => (f.1 : C)) ⟨⟨G, hG⟩, f⟩ ≫= huv\n  · haveI := h X\n    refine\n      (cancel_epi (Sigma.desc (@Sigma.snd 𝒢 fun G => (G : C) ⟶ X))).1 (colimit.hom_ext fun j => ?_)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n\n"}
{"name":"CategoryTheory.isCoseparating_iff_mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasProduct fun f => ↑f.fst\n⊢ Iff (CategoryTheory.IsCoseparating 𝒢) (∀ (A : C), CategoryTheory.Mono (CategoryTheory.Limits.Pi.lift Sigma.snd))","decl":"theorem isCoseparating_iff_mono (𝒢 : Set C)\n    [∀ A : C, HasProduct fun f : ΣG : 𝒢, A ⟶ (G : C) => (f.1 : C)] :\n    IsCoseparating 𝒢 ↔ ∀ A : C, Mono (Pi.lift (@Sigma.snd 𝒢 fun G => A ⟶ (G : C))) := by\n  refine ⟨fun h A => ⟨fun u v huv => h _ _ fun G hG f => ?_⟩, fun h X Y f g hh => ?_⟩\n  · simpa using huv =≫ Pi.π (fun f : ΣG : 𝒢, A ⟶ (G : C) => (f.1 : C)) ⟨⟨G, hG⟩, f⟩\n  · haveI := h Y\n    refine (cancel_mono (Pi.lift (@Sigma.snd 𝒢 fun G => Y ⟶ (G : C)))).1 (limit.hom_ext fun j => ?_)\n    simpa using hh j.as.1.1 j.as.1.2 j.as.2\n\n"}
{"name":"CategoryTheory.hasInitial_of_isCoseparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.LocallySmall.{w, v₁, u₁} C\ninst✝² : CategoryTheory.WellPowered.{w, v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v₁, u₁} C\n𝒢 : Set C\ninst✝ : Small.{w, u₁} ↑𝒢\nh𝒢 : CategoryTheory.IsCoseparating 𝒢\n⊢ CategoryTheory.Limits.HasInitial C","decl":"/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a complete well-powered\n    category with a small coseparating set has an initial object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already cocomplete,\n    see `hasColimits_of_hasLimits_of_isCoseparating`. -/\ntheorem hasInitial_of_isCoseparating [LocallySmall.{w} C] [WellPowered.{w} C]\n    [HasLimitsOfSize.{w, w} C] {𝒢 : Set C} [Small.{w} 𝒢]\n    (h𝒢 : IsCoseparating 𝒢) : HasInitial C := by\n  have := hasFiniteLimits_of_hasLimitsOfSize C\n  haveI : HasProductsOfShape 𝒢 C := hasProductsOfShape_of_small C 𝒢\n  haveI := fun A => hasProductsOfShape_of_small.{w} C (ΣG : 𝒢, A ⟶ (G : C))\n  letI := completeLatticeOfCompleteSemilatticeInf (Subobject (piObj (Subtype.val : 𝒢 → C)))\n  suffices ∀ A : C, Unique (((⊥ : Subobject (piObj (Subtype.val : 𝒢 → C))) : C) ⟶ A) by\n    exact hasInitial_of_unique ((⊥ : Subobject (piObj (Subtype.val : 𝒢 → C))) : C)\n  refine fun A => ⟨⟨?_⟩, fun f => ?_⟩\n  · let s := Pi.lift fun f : ΣG : 𝒢, A ⟶ (G : C) => id (Pi.π (Subtype.val : 𝒢 → C)) f.1\n    let t := Pi.lift (@Sigma.snd 𝒢 fun G => A ⟶ (G : C))\n    haveI : Mono t := (isCoseparating_iff_mono 𝒢).1 h𝒢 A\n    exact Subobject.ofLEMk _ (pullback.fst _ _ : pullback s t ⟶ _) bot_le ≫ pullback.snd _ _\n  · suffices ∀ (g : Subobject.underlying.obj ⊥ ⟶ A), f = g by\n      apply this\n    intro g\n    suffices IsSplitEpi (equalizer.ι f g) by exact eq_of_epi_equalizer\n    exact IsSplitEpi.mk' ⟨Subobject.ofLEMk _ (equalizer.ι f g ≫ Subobject.arrow _) bot_le, by\n      ext\n      simp⟩\n\n"}
{"name":"CategoryTheory.hasTerminal_of_isSeparating","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.LocallySmall.{w, v₁, u₁} (Opposite C)\ninst✝² : CategoryTheory.WellPowered.{w, v₁, u₁} (Opposite C)\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w, v₁, u₁} C\n𝒢 : Set C\ninst✝ : Small.{w, u₁} ↑𝒢\nh𝒢 : CategoryTheory.IsSeparating 𝒢\n⊢ CategoryTheory.Limits.HasTerminal C","decl":"/-- An ingredient of the proof of the Special Adjoint Functor Theorem: a cocomplete well-copowered\n    category with a small separating set has a terminal object.\n\n    In fact, it follows from the Special Adjoint Functor Theorem that `C` is already complete, see\n    `hasLimits_of_hasColimits_of_isSeparating`. -/\ntheorem hasTerminal_of_isSeparating [LocallySmall.{w} Cᵒᵖ] [WellPowered.{w} Cᵒᵖ]\n    [HasColimitsOfSize.{w, w} C] {𝒢 : Set C} [Small.{w} 𝒢]\n    (h𝒢 : IsSeparating 𝒢) : HasTerminal C := by\n  haveI : Small.{w} 𝒢.op := small_of_injective (Set.opEquiv_self 𝒢).injective\n  haveI : HasInitial Cᵒᵖ := hasInitial_of_isCoseparating ((isCoseparating_op_iff _).2 h𝒢)\n  exact hasTerminal_of_hasInitial_op\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_le_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\nX : C\nP Q : CategoryTheory.Subobject X\nh₁ : LE.le P Q\nh₂ : ∀ (G : C), Membership.mem 𝒢 G → ∀ {f : Quiver.Hom G X}, Q.Factors f → P.Factors f\n⊢ Eq P Q","decl":"theorem eq_of_le_of_isDetecting {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C} (P Q : Subobject X)\n    (h₁ : P ≤ Q) (h₂ : ∀ G ∈ 𝒢, ∀ {f : G ⟶ X}, Q.Factors f → P.Factors f) : P = Q := by\n  suffices IsIso (ofLE _ _ h₁) by exact le_antisymm h₁ (le_of_comm (inv (ofLE _ _ h₁)) (by simp))\n  refine h𝒢 _ fun G hG f => ?_\n  have : P.Factors (f ≫ Q.arrow) := h₂ _ hG ((factors_iff _ _).2 ⟨_, rfl⟩)\n  refine ⟨factorThru _ _ this, ?_, fun g (hg : g ≫ _ = f) => ?_⟩\n  · simp only [← cancel_mono Q.arrow, Category.assoc, ofLE_arrow, factorThru_arrow]\n  · simp only [← cancel_mono (Subobject.ofLE _ _ h₁), ← cancel_mono Q.arrow, hg, Category.assoc,\n      ofLE_arrow, factorThru_arrow]\n\n"}
{"name":"CategoryTheory.Subobject.inf_eq_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\nX : C\nP Q : CategoryTheory.Subobject X\nh : ∀ (G : C), Membership.mem 𝒢 G → ∀ {f : Quiver.Hom G X}, P.Factors f → Q.Factors f\n⊢ Eq (Min.min P Q) P","decl":"theorem inf_eq_of_isDetecting [HasPullbacks C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C}\n    (P Q : Subobject X) (h : ∀ G ∈ 𝒢, ∀ {f : G ⟶ X}, P.Factors f → Q.Factors f) : P ⊓ Q = P :=\n  eq_of_le_of_isDetecting h𝒢 _ _ _root_.inf_le_left\n    fun _ hG _ hf => (inf_factors _).2 ⟨hf, h _ hG hf⟩\n\n"}
{"name":"CategoryTheory.Subobject.eq_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\nX : C\nP Q : CategoryTheory.Subobject X\nh : ∀ (G : C), Membership.mem 𝒢 G → ∀ {f : Quiver.Hom G X}, Iff (P.Factors f) (Q.Factors f)\n⊢ Eq P Q","decl":"theorem eq_of_isDetecting [HasPullbacks C] {𝒢 : Set C} (h𝒢 : IsDetecting 𝒢) {X : C}\n    (P Q : Subobject X) (h : ∀ G ∈ 𝒢, ∀ {f : G ⟶ X}, P.Factors f ↔ Q.Factors f) : P = Q :=\n  calc\n    P = P ⊓ Q := Eq.symm <| inf_eq_of_isDetecting h𝒢 _ _ fun G hG _ hf => (h G hG).1 hf\n    _ = Q ⊓ P := inf_comm ..\n    _ = Q := inf_eq_of_isDetecting h𝒢 _ _ fun G hG _ hf => (h G hG).2 hf\n\n"}
{"name":"CategoryTheory.wellPowered_of_isDetecting","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\n𝒢 : Set C\ninst✝¹ : Small.{w, u₁} ↑𝒢\ninst✝ : CategoryTheory.LocallySmall.{w, v₁, u₁} C\nh𝒢 : CategoryTheory.IsDetecting 𝒢\n⊢ CategoryTheory.WellPowered.{w, v₁, u₁} C","decl":"/-- A category with pullbacks and a small detecting set is well-powered. -/\ntheorem wellPowered_of_isDetecting [HasPullbacks C] {𝒢 : Set C} [Small.{w} 𝒢]\n    [LocallySmall.{w} C] (h𝒢 : IsDetecting 𝒢) : WellPowered.{w} C :=\n  ⟨fun X =>\n    @small_of_injective _ _ _ (fun P : Subobject X => { f : ΣG : 𝒢, G.1 ⟶ X | P.Factors f.2 })\n      fun P Q h => Subobject.eq_of_isDetecting h𝒢 _ _\n        (by simpa [Set.ext_iff, Sigma.forall] using h)⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.isCoseparating_proj_preimage","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsCoseparating 𝒢\n⊢ CategoryTheory.IsCoseparating (Set.preimage (CategoryTheory.StructuredArrow.proj S T).obj 𝒢)","decl":"theorem isCoseparating_proj_preimage {𝒢 : Set C} (h𝒢 : IsCoseparating 𝒢) :\n    IsCoseparating ((proj S T).obj ⁻¹' 𝒢) := by\n  refine fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => ?_)\n  exact congr_arg CommaMorphism.right (hfg (mk (Y.hom ≫ T.map h)) hG (homMk h rfl))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isSeparating_proj_preimage","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\n𝒢 : Set C\nh𝒢 : CategoryTheory.IsSeparating 𝒢\n⊢ CategoryTheory.IsSeparating (Set.preimage (CategoryTheory.CostructuredArrow.proj S T).obj 𝒢)","decl":"theorem isSeparating_proj_preimage {𝒢 : Set C} (h𝒢 : IsSeparating 𝒢) :\n    IsSeparating ((proj S T).obj ⁻¹' 𝒢) := by\n  refine fun X Y f g hfg => ext _ _ (h𝒢 _ _ fun G hG h => ?_)\n  exact congr_arg CommaMorphism.left (hfg (mk (S.map h ≫ X.hom)) hG (homMk h rfl))\n\n"}
{"name":"CategoryTheory.IsSeparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : C\nh : CategoryTheory.IsSeparator G\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsSeparator (α.functor.obj G)","decl":"theorem IsSeparator.of_equivalence {G : C} (h : IsSeparator G) (α : C ≌ D) :\n    IsSeparator (α.functor.obj G) := by simpa using IsSeparating.of_equivalence h α\n\n"}
{"name":"CategoryTheory.IsCoseparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : C\nh : CategoryTheory.IsCoseparator G\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.IsCoseparator (α.functor.obj G)","decl":"theorem IsCoseparator.of_equivalence {G : C} (h : IsCoseparator G) (α : C ≌ D) :\n    IsCoseparator (α.functor.obj G) := by simpa using IsCoseparating.of_equivalence h α\n\n"}
{"name":"CategoryTheory.isSeparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsSeparator { unop := G }) (CategoryTheory.IsCoseparator G)","decl":"theorem isSeparator_op_iff (G : C) : IsSeparator (op G) ↔ IsCoseparator G := by\n  rw [IsSeparator, IsCoseparator, ← isSeparating_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCoseparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCoseparator { unop := G }) (CategoryTheory.IsSeparator G)","decl":"theorem isCoseparator_op_iff (G : C) : IsCoseparator (op G) ↔ IsSeparator G := by\n  rw [IsSeparator, IsCoseparator, ← isCoseparating_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCoseparator_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : Opposite C\n⊢ Iff (CategoryTheory.IsCoseparator (Opposite.unop G)) (CategoryTheory.IsSeparator G)","decl":"theorem isCoseparator_unop_iff (G : Cᵒᵖ) : IsCoseparator (unop G) ↔ IsSeparator G := by\n  rw [IsSeparator, IsCoseparator, ← isCoseparating_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isSeparator_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : Opposite C\n⊢ Iff (CategoryTheory.IsSeparator (Opposite.unop G)) (CategoryTheory.IsCoseparator G)","decl":"theorem isSeparator_unop_iff (G : Cᵒᵖ) : IsSeparator (unop G) ↔ IsCoseparator G := by\n  rw [IsSeparator, IsCoseparator, ← isSeparating_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isDetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsDetector { unop := G }) (CategoryTheory.IsCodetector G)","decl":"theorem isDetector_op_iff (G : C) : IsDetector (op G) ↔ IsCodetector G := by\n  rw [IsDetector, IsCodetector, ← isDetecting_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCodetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCodetector { unop := G }) (CategoryTheory.IsDetector G)","decl":"theorem isCodetector_op_iff (G : C) : IsCodetector (op G) ↔ IsDetector G := by\n  rw [IsDetector, IsCodetector, ← isCodetecting_op_iff, Set.singleton_op]\n\n"}
{"name":"CategoryTheory.isCodetector_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : Opposite C\n⊢ Iff (CategoryTheory.IsCodetector (Opposite.unop G)) (CategoryTheory.IsDetector G)","decl":"theorem isCodetector_unop_iff (G : Cᵒᵖ) : IsCodetector (unop G) ↔ IsDetector G := by\n  rw [IsDetector, IsCodetector, ← isCodetecting_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.isDetector_unop_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : Opposite C\n⊢ Iff (CategoryTheory.IsDetector (Opposite.unop G)) (CategoryTheory.IsCodetector G)","decl":"theorem isDetector_unop_iff (G : Cᵒᵖ) : IsDetector (unop G) ↔ IsCodetector G := by\n  rw [IsDetector, IsCodetector, ← isDetecting_unop_iff, Set.singleton_unop]\n\n"}
{"name":"CategoryTheory.IsDetector.isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\nG : C\na✝ : CategoryTheory.IsDetector G\n⊢ CategoryTheory.IsSeparator G","decl":"theorem IsDetector.isSeparator [HasEqualizers C] {G : C} : IsDetector G → IsSeparator G :=\n  IsDetecting.isSeparating\n\n"}
{"name":"CategoryTheory.IsCodetector.isCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\nG : C\na✝ : CategoryTheory.IsCodetector G\n⊢ CategoryTheory.IsCoseparator G","decl":"theorem IsCodetector.isCoseparator [HasCoequalizers C] {G : C} : IsCodetector G → IsCoseparator G :=\n  IsCodetecting.isCoseparating\n\n"}
{"name":"CategoryTheory.IsSeparator.isDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Balanced C\nG : C\na✝ : CategoryTheory.IsSeparator G\n⊢ CategoryTheory.IsDetector G","decl":"theorem IsSeparator.isDetector [Balanced C] {G : C} : IsSeparator G → IsDetector G :=\n  IsSeparating.isDetecting\n\n"}
{"name":"CategoryTheory.IsCoseparator.isCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Balanced C\nG : C\na✝ : CategoryTheory.IsCoseparator G\n⊢ CategoryTheory.IsCodetector G","decl":"theorem IsCoseparator.isCodetector [Balanced C] {G : C} : IsCoseparator G → IsCodetector G :=\n  IsCoseparating.isCodetecting\n\n"}
{"name":"CategoryTheory.isSeparator_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsSeparator G) (∀ ⦃X Y : C⦄ (f g : Quiver.Hom X Y), (∀ (h : Quiver.Hom G X), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)) → Eq f g)","decl":"theorem isSeparator_def (G : C) :\n    IsSeparator G ↔ ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), (∀ h : G ⟶ X, h ≫ f = h ≫ g) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG _ _ _ _ hfg => hG _ _ fun _ => hfg _ (Set.mem_singleton _) _⟩\n\n"}
{"name":"CategoryTheory.IsSeparator.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\na✝¹ : CategoryTheory.IsSeparator G\nX Y : C\nf g : Quiver.Hom X Y\na✝ : ∀ (h : Quiver.Hom G X), Eq (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)\n⊢ Eq f g","decl":"theorem IsSeparator.def {G : C} :\n    IsSeparator G → ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), (∀ h : G ⟶ X, h ≫ f = h ≫ g) → f = g :=\n  (isSeparator_def _).1\n\n"}
{"name":"CategoryTheory.isCoseparator_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCoseparator G) (∀ ⦃X Y : C⦄ (f g : Quiver.Hom X Y), (∀ (h : Quiver.Hom Y G), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)) → Eq f g)","decl":"theorem isCoseparator_def (G : C) :\n    IsCoseparator G ↔ ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), (∀ h : Y ⟶ G, f ≫ h = g ≫ h) → f = g :=\n  ⟨fun hG X Y f g hfg =>\n    hG _ _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hfg h,\n    fun hG _ _ _ _ hfg => hG _ _ fun _ => hfg _ (Set.mem_singleton _) _⟩\n\n"}
{"name":"CategoryTheory.IsCoseparator.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\na✝¹ : CategoryTheory.IsCoseparator G\nX Y : C\nf g : Quiver.Hom X Y\na✝ : ∀ (h : Quiver.Hom Y G), Eq (CategoryTheory.CategoryStruct.comp f h) (CategoryTheory.CategoryStruct.comp g h)\n⊢ Eq f g","decl":"theorem IsCoseparator.def {G : C} :\n    IsCoseparator G → ∀ ⦃X Y : C⦄ (f g : X ⟶ Y), (∀ h : Y ⟶ G, f ≫ h = g ≫ h) → f = g :=\n  (isCoseparator_def _).1\n\n"}
{"name":"CategoryTheory.isDetector_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsDetector G) (∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), (∀ (h : Quiver.Hom G Y), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp h' f) h) → CategoryTheory.IsIso f)","decl":"theorem isDetector_def (G : C) :\n    IsDetector G ↔ ∀ ⦃X Y : C⦄ (f : X ⟶ Y), (∀ h : G ⟶ Y, ∃! h', h' ≫ f = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG _ _ _ hf => hG _ fun _ => hf _ (Set.mem_singleton _) _⟩\n\n"}
{"name":"CategoryTheory.IsDetector.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\na✝¹ : CategoryTheory.IsDetector G\nX Y : C\nf : Quiver.Hom X Y\na✝ : ∀ (h : Quiver.Hom G Y), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp h' f) h\n⊢ CategoryTheory.IsIso f","decl":"theorem IsDetector.def {G : C} :\n    IsDetector G → ∀ ⦃X Y : C⦄ (f : X ⟶ Y), (∀ h : G ⟶ Y, ∃! h', h' ≫ f = h) → IsIso f :=\n  (isDetector_def _).1\n\n"}
{"name":"CategoryTheory.isCodetector_def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCodetector G) (∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), (∀ (h : Quiver.Hom X G), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp f h') h) → CategoryTheory.IsIso f)","decl":"theorem isCodetector_def (G : C) :\n    IsCodetector G ↔ ∀ ⦃X Y : C⦄ (f : X ⟶ Y), (∀ h : X ⟶ G, ∃! h', f ≫ h' = h) → IsIso f :=\n  ⟨fun hG X Y f hf =>\n    hG _ fun H hH h => by\n      obtain rfl := Set.mem_singleton_iff.1 hH\n      exact hf h,\n    fun hG _ _ _ hf => hG _ fun _ => hf _ (Set.mem_singleton _) _⟩\n\n"}
{"name":"CategoryTheory.IsCodetector.def","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\na✝¹ : CategoryTheory.IsCodetector G\nX Y : C\nf : Quiver.Hom X Y\na✝ : ∀ (h : Quiver.Hom X G), ExistsUnique fun h' => Eq (CategoryTheory.CategoryStruct.comp f h') h\n⊢ CategoryTheory.IsIso f","decl":"theorem IsCodetector.def {G : C} :\n    IsCodetector G → ∀ ⦃X Y : C⦄ (f : X ⟶ Y), (∀ h : X ⟶ G, ∃! h', f ≫ h' = h) → IsIso f :=\n  (isCodetector_def _).1\n\n"}
{"name":"CategoryTheory.isSeparator_iff_faithful_coyoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsSeparator G) (CategoryTheory.coyoneda.obj { unop := G }).Faithful","decl":"theorem isSeparator_iff_faithful_coyoneda_obj (G : C) :\n    IsSeparator G ↔ (coyoneda.obj (op G)).Faithful :=\n  ⟨fun hG => ⟨fun hfg => hG.def _ _ (congr_fun hfg)⟩, fun _ =>\n    (isSeparator_def _).2 fun _ _ _ _ hfg => (coyoneda.obj (op G)).map_injective (funext hfg)⟩\n\n"}
{"name":"CategoryTheory.isCoseparator_iff_faithful_yoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCoseparator G) (CategoryTheory.yoneda.obj G).Faithful","decl":"theorem isCoseparator_iff_faithful_yoneda_obj (G : C) : IsCoseparator G ↔ (yoneda.obj G).Faithful :=\n  ⟨fun hG => ⟨fun hfg => Quiver.Hom.unop_inj (hG.def _ _ (congr_fun hfg))⟩, fun _ =>\n    (isCoseparator_def _).2 fun _ _ _ _ hfg =>\n      Quiver.Hom.op_inj <| (yoneda.obj G).map_injective (funext hfg)⟩\n\n"}
{"name":"CategoryTheory.isSeparator_iff_epi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nG : C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasCoproduct fun x => G\n⊢ Iff (CategoryTheory.IsSeparator G) (∀ (A : C), CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc fun f => f))","decl":"theorem isSeparator_iff_epi (G : C) [∀ A : C, HasCoproduct fun _ : G ⟶ A => G] :\n    IsSeparator G ↔ ∀ A : C, Epi (Sigma.desc fun f : G ⟶ A => f) := by\n  rw [isSeparator_def]\n  refine ⟨fun h A => ⟨fun u v huv => h _ _ fun i => ?_⟩, fun h X Y f g hh => ?_⟩\n  · simpa using Sigma.ι _ i ≫= huv\n  · haveI := h X\n    refine (cancel_epi (Sigma.desc fun f : G ⟶ X => f)).1 (colimit.hom_ext fun j => ?_)\n    simpa using hh j.as\n\n"}
{"name":"CategoryTheory.isCoseparator_iff_mono","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nG : C\ninst✝ : ∀ (A : C), CategoryTheory.Limits.HasProduct fun x => G\n⊢ Iff (CategoryTheory.IsCoseparator G) (∀ (A : C), CategoryTheory.Mono (CategoryTheory.Limits.Pi.lift fun f => f))","decl":"theorem isCoseparator_iff_mono (G : C) [∀ A : C, HasProduct fun _ : A ⟶ G => G] :\n    IsCoseparator G ↔ ∀ A : C, Mono (Pi.lift fun f : A ⟶ G => f) := by\n  rw [isCoseparator_def]\n  refine ⟨fun h A => ⟨fun u v huv => h _ _ fun i => ?_⟩, fun h X Y f g hh => ?_⟩\n  · simpa using huv =≫ Pi.π _ i\n  · haveI := h Y\n    refine (cancel_mono (Pi.lift fun f : Y ⟶ G => f)).1 (limit.hom_ext fun j => ?_)\n    simpa using hh j.as\n\n"}
{"name":"CategoryTheory.isSeparator_coprod","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct G H\n⊢ Iff (CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)) (CategoryTheory.IsSeparating (Insert.insert G (Singleton.singleton H)))","decl":"theorem isSeparator_coprod (G H : C) [HasBinaryCoproduct G H] :\n    IsSeparator (G ⨿ H) ↔ IsSeparating ({G, H} : Set C) := by\n  refine\n    ⟨fun h X Y u v huv => ?_, fun h =>\n      (isSeparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_⟩\n  · refine h.def _ _ fun g => coprod.hom_ext ?_ ?_\n    · simpa using huv G (by simp) (coprod.inl ≫ g)\n    · simpa using huv H (by simp) (coprod.inr ≫ g)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using coprod.inl ≫= huv (coprod.desc g 0)\n    · simpa using coprod.inr ≫= huv (coprod.desc 0 g)\n\n"}
{"name":"CategoryTheory.isSeparator_coprod_of_isSeparator_left","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct G H\nhG : CategoryTheory.IsSeparator G\n⊢ CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)","decl":"theorem isSeparator_coprod_of_isSeparator_left (G H : C) [HasBinaryCoproduct G H]\n    (hG : IsSeparator G) : IsSeparator (G ⨿ H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hG <| by simp\n\n"}
{"name":"CategoryTheory.isSeparator_coprod_of_isSeparator_right","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct G H\nhH : CategoryTheory.IsSeparator H\n⊢ CategoryTheory.IsSeparator (CategoryTheory.Limits.coprod G H)","decl":"theorem isSeparator_coprod_of_isSeparator_right (G H : C) [HasBinaryCoproduct G H]\n    (hH : IsSeparator H) : IsSeparator (G ⨿ H) :=\n  (isSeparator_coprod _ _).2 <| IsSeparating.mono hH <| by simp\n\n"}
{"name":"CategoryTheory.isSeparator_of_isColimit_cofan","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\nhf : CategoryTheory.IsSeparating (Set.range f)\nc : CategoryTheory.Limits.Cofan f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ CategoryTheory.IsSeparator c.pt","decl":"lemma isSeparator_of_isColimit_cofan {β : Type w} {f : β → C}\n    (hf : IsSeparating (Set.range f)) {c : Cofan f} (hc : IsColimit c) : IsSeparator c.pt := by\n  refine (isSeparator_def _).2 fun X Y u v huv => hf _ _ fun Z hZ g => ?_\n  obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n  classical simpa using c.ι.app ⟨b⟩ ≫= huv (hc.desc (Cofan.mk _ (Pi.single b g)))\n\n"}
{"name":"CategoryTheory.isSeparator_sigma","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\n⊢ Iff (CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)) (CategoryTheory.IsSeparating (Set.range f))","decl":"theorem isSeparator_sigma {β : Type w} (f : β → C) [HasCoproduct f] :\n    IsSeparator (∐ f) ↔ IsSeparating (Set.range f) := by\n  refine ⟨fun h X Y u v huv => ?_, fun h => isSeparator_of_isColimit_cofan h (colimit.isColimit _)⟩\n  refine h.def _ _ fun g => colimit.hom_ext fun b => ?_\n  simpa using huv (f b.as) (by simp) (colimit.ι (Discrete.functor f) _ ≫ g)\n\n"}
{"name":"CategoryTheory.IsSeparating.isSeparator_coproduct","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nhS : CategoryTheory.IsSeparating (Set.range f)\n⊢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)","decl":"theorem IsSeparating.isSeparator_coproduct {β : Type w} {f : β → C} [HasCoproduct f]\n    (hS : IsSeparating (Set.range f)) : IsSeparator (∐ f) :=\n  (isSeparator_sigma _).2 hS\n\n"}
{"name":"CategoryTheory.isSeparator_sigma_of_isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasCoproduct f\nb : β\nhb : CategoryTheory.IsSeparator (f b)\n⊢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj f)","decl":"theorem isSeparator_sigma_of_isSeparator {β : Type w} (f : β → C) [HasCoproduct f] (b : β)\n    (hb : IsSeparator (f b)) : IsSeparator (∐ f) :=\n  (isSeparator_sigma _).2 <| IsSeparating.mono hb <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_prod","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct G H\n⊢ Iff (CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)) (CategoryTheory.IsCoseparating (Insert.insert G (Singleton.singleton H)))","decl":"theorem isCoseparator_prod (G H : C) [HasBinaryProduct G H] :\n    IsCoseparator (G ⨯ H) ↔ IsCoseparating ({G, H} : Set C) := by\n  refine\n    ⟨fun h X Y u v huv => ?_, fun h =>\n      (isCoseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_⟩\n  · refine h.def _ _ fun g => Limits.prod.hom_ext ?_ ?_\n    · simpa using huv G (by simp) (g ≫ Limits.prod.fst)\n    · simpa using huv H (by simp) (g ≫ Limits.prod.snd)\n  · simp only [Set.mem_insert_iff, Set.mem_singleton_iff] at hZ\n    rcases hZ with (rfl | rfl)\n    · simpa using huv (prod.lift g 0) =≫ Limits.prod.fst\n    · simpa using huv (prod.lift 0 g) =≫ Limits.prod.snd\n\n"}
{"name":"CategoryTheory.isCoseparator_prod_of_isCoseparator_left","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct G H\nhG : CategoryTheory.IsCoseparator G\n⊢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)","decl":"theorem isCoseparator_prod_of_isCoseparator_left (G H : C) [HasBinaryProduct G H]\n    (hG : IsCoseparator G) : IsCoseparator (G ⨯ H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hG <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_prod_of_isCoseparator_right","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nG H : C\ninst✝ : CategoryTheory.Limits.HasBinaryProduct G H\nhH : CategoryTheory.IsCoseparator H\n⊢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.prod G H)","decl":"theorem isCoseparator_prod_of_isCoseparator_right (G H : C) [HasBinaryProduct G H]\n    (hH : IsCoseparator H) : IsCoseparator (G ⨯ H) :=\n  (isCoseparator_prod _ _).2 <| IsCoseparating.mono hH <| by simp\n\n"}
{"name":"CategoryTheory.isCoseparator_pi","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\n⊢ Iff (CategoryTheory.IsCoseparator (CategoryTheory.Limits.piObj f)) (CategoryTheory.IsCoseparating (Set.range f))","decl":"theorem isCoseparator_pi {β : Type w} (f : β → C) [HasProduct f] :\n    IsCoseparator (∏ᶜ f) ↔ IsCoseparating (Set.range f) := by\n  refine\n    ⟨fun h X Y u v huv => ?_, fun h =>\n      (isCoseparator_def _).2 fun X Y u v huv => h _ _ fun Z hZ g => ?_⟩\n  · refine h.def _ _ fun g => limit.hom_ext fun b => ?_\n    simpa using huv (f b.as) (by simp) (g ≫ limit.π (Discrete.functor f) _)\n  · obtain ⟨b, rfl⟩ := Set.mem_range.1 hZ\n    classical simpa using huv (Pi.lift (Pi.single b g)) =≫ Pi.π f b\n\n"}
{"name":"CategoryTheory.isCoseparator_pi_of_isCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nβ : Type w\nf : β → C\ninst✝ : CategoryTheory.Limits.HasProduct f\nb : β\nhb : CategoryTheory.IsCoseparator (f b)\n⊢ CategoryTheory.IsCoseparator (CategoryTheory.Limits.piObj f)","decl":"theorem isCoseparator_pi_of_isCoseparator {β : Type w} (f : β → C) [HasProduct f] (b : β)\n    (hb : IsCoseparator (f b)) : IsCoseparator (∏ᶜ f) :=\n  (isCoseparator_pi _).2 <| IsCoseparating.mono hb <| by simp\n\n"}
{"name":"CategoryTheory.isDetector_iff_reflectsIsomorphisms_coyoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsDetector G) (CategoryTheory.coyoneda.obj { unop := G }).ReflectsIsomorphisms","decl":"theorem isDetector_iff_reflectsIsomorphisms_coyoneda_obj (G : C) :\n    IsDetector G ↔ (coyoneda.obj (op G)).ReflectsIsomorphisms := by\n  refine\n    ⟨fun hG => ⟨fun f hf => hG.def _ fun h => ?_⟩, fun h =>\n      (isDetector_def _).2 fun X Y f hf => ?_⟩\n  · rw [isIso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n    exact hf h\n  · suffices IsIso ((coyoneda.obj (op G)).map f) by\n      exact @isIso_of_reflects_iso _ _ _ _ _ _ _ (coyoneda.obj (op G)) _ h\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique]\n\n"}
{"name":"CategoryTheory.isCodetector_iff_reflectsIsomorphisms_yoneda_obj","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : C\n⊢ Iff (CategoryTheory.IsCodetector G) (CategoryTheory.yoneda.obj G).ReflectsIsomorphisms","decl":"theorem isCodetector_iff_reflectsIsomorphisms_yoneda_obj (G : C) :\n    IsCodetector G ↔ (yoneda.obj G).ReflectsIsomorphisms := by\n  refine ⟨fun hG => ⟨fun f hf => ?_⟩, fun h => (isCodetector_def _).2 fun X Y f hf => ?_⟩\n  · refine (isIso_unop_iff _).1 (hG.def _ ?_)\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique] at hf\n  · rw [← isIso_op_iff]\n    suffices IsIso ((yoneda.obj G).map f.op) by\n      exact @isIso_of_reflects_iso _ _ _ _ _ _ _ (yoneda.obj G) _ h\n    rwa [isIso_iff_bijective, Function.bijective_iff_existsUnique]\n\n"}
{"name":"CategoryTheory.wellPowered_of_isDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nG : C\nhG : CategoryTheory.IsDetector G\n⊢ CategoryTheory.WellPowered.{v₁, v₁, u₁} C","decl":"theorem wellPowered_of_isDetector [HasPullbacks C] (G : C) (hG : IsDetector G) :\n    WellPowered.{v₁} C :=\n  -- Porting note: added the following `haveI` to prevent universe issues\n  haveI := small_subsingleton ({G} : Set C)\n  wellPowered_of_isDetecting hG\n\n"}
{"name":"CategoryTheory.wellPowered_of_isSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\ninst✝ : CategoryTheory.Balanced C\nG : C\nhG : CategoryTheory.IsSeparator G\n⊢ CategoryTheory.WellPowered.{v₁, v₁, u₁} C","decl":"theorem wellPowered_of_isSeparator [HasPullbacks C] [Balanced C] (G : C) (hG : IsSeparator G) :\n    WellPowered.{v₁} C := wellPowered_of_isDetecting hG.isDetector\n\n"}
{"name":"CategoryTheory.HasSeparator.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.HasSeparator C\n⊢ Exists fun G => CategoryTheory.IsSeparator G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a separator of `C` if\nthe functor `C(G, -)` is faithful.\n\nWhile `IsSeparator G : Prop` is the proposition that `G` is a separator of `C`,\nan `HasSeparator C : Prop` is the proposition that such a separator exists.\nNote that `HasSeparator C` is a proposition. It does not designate a favored separator\nand merely asserts the existence of one.\n-/\nclass HasSeparator : Prop where\n  hasSeparator : ∃ G : C, IsSeparator G\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.HasCoseparator C\n⊢ Exists fun G => CategoryTheory.IsCoseparator G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a coseparator of `C` if\nthe functor `C(-, G)` is faithful.\n\nWhile `IsCoseparator G : Prop` is the proposition that `G` is a coseparator of `C`,\nan `HasCoseparator C : Prop` is the proposition that such a coseparator exists.\nNote that `HasCoseparator C` is a proposition. It does not designate a favored coseparator\nand merely asserts the existence of one.\n-/\nclass HasCoseparator : Prop where\n  hasCoseparator : ∃ G : C, IsCoseparator G\n\n"}
{"name":"CategoryTheory.HasDetector.hasDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.HasDetector C\n⊢ Exists fun G => CategoryTheory.IsDetector G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a detector of `C` if\nthe functor `C(G, -)` reflects isomorphisms.\n\nWhile `IsDetector G : Prop` is the proposition that `G` is a detector of `C`,\nan `HasDetector C : Prop` is the proposition that such a detector exists.\nNote that `HasDetector C` is a proposition. It does not designate a favored detector\nand merely asserts the existence of one.\n-/\nclass HasDetector : Prop where\n  hasDetector : ∃ G : C, IsDetector G\n\n"}
{"name":"CategoryTheory.HasCodetector.hasCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.HasCodetector C\n⊢ Exists fun G => CategoryTheory.IsCodetector G","decl":"/--\nFor a category `C` and an object `G : C`, `G` is a codetector of `C` if\nthe functor `C(-, G)` reflects isomorphisms.\n\nWhile `IsCodetector G : Prop` is the proposition that `G` is a codetector of `C`,\nan `HasCodetector C : Prop` is the proposition that such a codetector exists.\nNote that `HasCodetector C` is a proposition. It does not designate a favored codetector\nand merely asserts the existence of one.\n-/\nclass HasCodetector : Prop where\n  hasCodetector : ∃ G : C, IsCodetector G\n\n"}
{"name":"CategoryTheory.isSeparator_separator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasSeparator C\n⊢ CategoryTheory.IsSeparator (CategoryTheory.separator C)","decl":"theorem isSeparator_separator [HasSeparator C] : IsSeparator (separator C) :=\n  HasSeparator.hasSeparator.choose_spec\n\n"}
{"name":"CategoryTheory.isDetector_separator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : CategoryTheory.HasSeparator C\n⊢ CategoryTheory.IsDetector (CategoryTheory.separator C)","decl":"theorem isDetector_separator [Balanced C] [HasSeparator C] : IsDetector (separator C) :=\n  isSeparator_separator C |>.isDetector\n\n"}
{"name":"CategoryTheory.isCoseparator_coseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCoseparator C\n⊢ CategoryTheory.IsCoseparator (CategoryTheory.coseparator C)","decl":"theorem isCoseparator_coseparator [HasCoseparator C] : IsCoseparator (coseparator C) :=\n  HasCoseparator.hasCoseparator.choose_spec\n\n"}
{"name":"CategoryTheory.isCodetector_coseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : CategoryTheory.HasCoseparator C\n⊢ CategoryTheory.IsCodetector (CategoryTheory.coseparator C)","decl":"theorem isCodetector_coseparator [Balanced C] [HasCoseparator C] : IsCodetector (coseparator C) :=\n  isCoseparator_coseparator C |>.isCodetector\n\n"}
{"name":"CategoryTheory.isDetector_detector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasDetector C\n⊢ CategoryTheory.IsDetector (CategoryTheory.detector C)","decl":"theorem isDetector_detector [HasDetector C] : IsDetector (detector C) :=\n  HasDetector.hasDetector.choose_spec\n\n"}
{"name":"CategoryTheory.isSeparator_detector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasEqualizers C\ninst✝ : CategoryTheory.HasDetector C\n⊢ CategoryTheory.IsSeparator (CategoryTheory.detector C)","decl":"theorem isSeparator_detector [HasEqualizers C] [HasDetector C] : IsSeparator (detector C) :=\n  isDetector_detector C |>.isSeparator\n\n"}
{"name":"CategoryTheory.isCodetector_codetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCodetector C\n⊢ CategoryTheory.IsCodetector (CategoryTheory.codetector C)","decl":"theorem isCodetector_codetector [HasCodetector C] : IsCodetector (codetector C) :=\n  HasCodetector.hasCodetector.choose_spec\n\n"}
{"name":"CategoryTheory.isCoseparator_codetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : CategoryTheory.HasCodetector C\n⊢ CategoryTheory.IsCoseparator (CategoryTheory.codetector C)","decl":"theorem isCoseparator_codetector [HasCoequalizers C] [HasCodetector C] :\n    IsCoseparator (codetector C) := isCodetector_codetector C |>.isCoseparator\n\n"}
{"name":"CategoryTheory.HasSeparator.hasDetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : CategoryTheory.HasSeparator C\n⊢ CategoryTheory.HasDetector C","decl":"theorem HasSeparator.hasDetector [Balanced C] [HasSeparator C] : HasDetector C :=\n  ⟨_, isDetector_separator C⟩\n\n"}
{"name":"CategoryTheory.HasDetector.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasEqualizers C\ninst✝ : CategoryTheory.HasDetector C\n⊢ CategoryTheory.HasSeparator C","decl":"theorem HasDetector.hasSeparator [HasEqualizers C] [HasDetector C] : HasSeparator C :=\n  ⟨_, isSeparator_detector C⟩\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasCodetector","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : CategoryTheory.HasCoseparator C\n⊢ CategoryTheory.HasCodetector C","decl":"theorem HasCoseparator.hasCodetector [Balanced C] [HasCoseparator C] : HasCodetector C :=\n  ⟨_, isCodetector_coseparator C⟩\n\n"}
{"name":"CategoryTheory.HasCodetector.hasCoseparator","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : CategoryTheory.HasCodetector C\n⊢ CategoryTheory.HasCoseparator C","decl":"theorem HasCodetector.hasCoseparator [HasCoequalizers C] [HasCodetector C] : HasCoseparator C :=\n  ⟨_, isCoseparator_codetector C⟩\n\n"}
{"name":"CategoryTheory.HasDetector.wellPowered","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\ninst✝ : CategoryTheory.HasDetector C\n⊢ CategoryTheory.WellPowered.{v₁, v₁, u₁} C","decl":"instance HasDetector.wellPowered [HasPullbacks C] [HasDetector C] : WellPowered.{v₁} C :=\n  isDetector_detector C |> wellPowered_of_isDetector _\n\n"}
{"name":"CategoryTheory.HasSeparator.wellPowered","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\ninst✝¹ : CategoryTheory.Balanced C\ninst✝ : CategoryTheory.HasSeparator C\n⊢ CategoryTheory.WellPowered.{v₁, v₁, u₁} C","decl":"instance HasSeparator.wellPowered [HasPullbacks C] [Balanced C] [HasSeparator C] :\n    WellPowered.{v₁} C := HasSeparator.hasDetector.wellPowered\n\n"}
{"name":"CategoryTheory.HasSeparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.HasSeparator C\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.HasSeparator D","decl":"theorem HasSeparator.of_equivalence [HasSeparator C] (α : C ≌ D) : HasSeparator D :=\n  ⟨α.functor.obj (separator C), isSeparator_separator C |>.of_equivalence α⟩\n\n"}
{"name":"CategoryTheory.HasCoseparator.of_equivalence","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.HasCoseparator C\nα : CategoryTheory.Equivalence C D\n⊢ CategoryTheory.HasCoseparator D","decl":"theorem HasCoseparator.of_equivalence [HasCoseparator C] (α : C ≌ D) : HasCoseparator D :=\n  ⟨α.functor.obj (coseparator C), isCoseparator_coseparator C |>.of_equivalence α⟩\n\n"}
{"name":"CategoryTheory.hasSeparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Iff (CategoryTheory.HasSeparator (Opposite C)) (CategoryTheory.HasCoseparator C)","decl":"@[simp]\ntheorem hasSeparator_op_iff : HasSeparator Cᵒᵖ ↔ HasCoseparator C :=\n  ⟨fun ⟨G, hG⟩ => ⟨unop G, (isCoseparator_unop_iff G).mpr hG⟩,\n   fun ⟨G, hG⟩ => ⟨op G, (isSeparator_op_iff G).mpr hG⟩⟩\n\n"}
{"name":"CategoryTheory.hasCoseparator_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Iff (CategoryTheory.HasCoseparator (Opposite C)) (CategoryTheory.HasSeparator C)","decl":"@[simp]\ntheorem hasCoseparator_op_iff : HasCoseparator Cᵒᵖ ↔ HasSeparator C :=\n  ⟨fun ⟨G, hG⟩ => ⟨unop G, (isSeparator_unop_iff G).mpr hG⟩,\n   fun ⟨G, hG⟩ => ⟨op G, (isCoseparator_op_iff G).mpr hG⟩⟩\n\n"}
{"name":"CategoryTheory.hasDetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Iff (CategoryTheory.HasDetector (Opposite C)) (CategoryTheory.HasCodetector C)","decl":"@[simp]\ntheorem hasDetector_op_iff : HasDetector Cᵒᵖ ↔ HasCodetector C :=\n  ⟨fun ⟨G, hG⟩ => ⟨unop G, (isCodetector_unop_iff G).mpr hG⟩,\n   fun ⟨G, hG⟩ => ⟨op G, (isDetector_op_iff G).mpr hG⟩⟩\n\n"}
{"name":"CategoryTheory.hasCodetector_op_iff","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Iff (CategoryTheory.HasCodetector (Opposite C)) (CategoryTheory.HasDetector C)","decl":"@[simp]\ntheorem hasCodetector_op_iff : HasCodetector Cᵒᵖ ↔ HasDetector C :=\n  ⟨fun ⟨G, hG⟩ => ⟨unop G, (isDetector_unop_iff G).mpr hG⟩,\n   fun ⟨G, hG⟩ => ⟨op G, (isCodetector_op_iff G).mpr hG⟩⟩\n\n"}
{"name":"CategoryTheory.HasSeparator.hasCoseparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasSeparator C\n⊢ CategoryTheory.HasCoseparator (Opposite C)","decl":"instance HasSeparator.hasCoseparator_op [HasSeparator C] : HasCoseparator Cᵒᵖ := by simp [*]\n"}
{"name":"CategoryTheory.HasSeparator.hasCoseparator_of_hasSeparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nh : CategoryTheory.HasSeparator (Opposite C)\n⊢ CategoryTheory.HasCoseparator C","decl":"theorem HasSeparator.hasCoseparator_of_hasSeparator_op [h : HasSeparator Cᵒᵖ] :\n    HasCoseparator C := by simp_all\n\n"}
{"name":"CategoryTheory.HasCoseparator.hasSeparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCoseparator C\n⊢ CategoryTheory.HasSeparator (Opposite C)","decl":"instance HasCoseparator.hasSeparator_op [HasCoseparator C] : HasSeparator Cᵒᵖ := by simp [*]\n"}
{"name":"CategoryTheory.HasCoseparator.hasSeparator_of_hasCoseparator_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCoseparator (Opposite C)\n⊢ CategoryTheory.HasSeparator C","decl":"theorem HasCoseparator.hasSeparator_of_hasCoseparator_op [HasCoseparator Cᵒᵖ] :\n    HasSeparator C := by simp_all\n\n"}
{"name":"CategoryTheory.HasDetector.hasCodetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasDetector C\n⊢ CategoryTheory.HasCodetector (Opposite C)","decl":"instance HasDetector.hasCodetector_op [HasDetector C] : HasCodetector Cᵒᵖ := by simp [*]\n"}
{"name":"CategoryTheory.HasDetector.hasCodetector_of_hasDetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasDetector (Opposite C)\n⊢ CategoryTheory.HasCodetector C","decl":"theorem HasDetector.hasCodetector_of_hasDetector_op [HasDetector Cᵒᵖ] :\n    HasCodetector C := by simp_all\n\n"}
{"name":"CategoryTheory.HasCodetector.hasDetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCodetector C\n⊢ CategoryTheory.HasDetector (Opposite C)","decl":"instance HasCodetector.hasDetector_op [HasCodetector C] : HasDetector Cᵒᵖ := by simp [*]\n"}
{"name":"CategoryTheory.HasCodetector.hasDetector_of_hasCodetector_op","module":"Mathlib.CategoryTheory.Generator.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.HasCodetector (Opposite C)\n⊢ CategoryTheory.HasDetector C","decl":"theorem HasCodetector.hasDetector_of_hasCodetector_op [HasCodetector Cᵒᵖ] :\n    HasDetector C := by simp_all\n\n"}
