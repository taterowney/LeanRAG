{"name":"Nat.emultiplicity_eq_card_pow_dvd","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"m n b : Nat\nhm : Ne m 1\nhn : LT.lt 0 n\nhb : LT.lt (Nat.log m n) b\n⊢ Eq (emultiplicity m n) ↑(Finset.filter (fun i => Dvd.dvd (HPow.hPow m i) n) (Finset.Ico 1 b)).card","decl":"/-- The multiplicity of `m` in `n` is the number of positive natural numbers `i` such that `m ^ i`\ndivides `n`. This set is expressed by filtering `Ico 1 b` where `b` is any bound greater than\n`log m n`. -/\ntheorem emultiplicity_eq_card_pow_dvd {m n b : ℕ} (hm : m ≠ 1) (hn : 0 < n) (hb : log m n < b) :\n    emultiplicity m n = #{i ∈ Ico 1 b | m ^ i ∣ n} :=\n  have fin := Nat.finiteMultiplicity_iff.2 ⟨hm, hn⟩\n  calc\n    emultiplicity m n = #(Ico 1 <| multiplicity m n + 1) := by\n      simp [fin.emultiplicity_eq_multiplicity]\n    _ = #{i ∈ Ico 1 b | m ^ i ∣ n} :=\n      congr_arg _ <|\n        congr_arg card <|\n          Finset.ext fun i => by\n            simp only [mem_Ico, Nat.lt_succ_iff,\n              fin.pow_dvd_iff_le_multiplicity, mem_filter,\n              and_assoc, and_congr_right_iff, iff_and_self]\n            intro hi h\n            rw [← fin.pow_dvd_iff_le_multiplicity] at h\n            cases' m with m\n            · rw [zero_pow, zero_dvd_iff] at h\n              exacts [(hn.ne' h).elim, one_le_iff_ne_zero.1 hi]\n            refine LE.le.trans_lt ?_ hb\n            exact le_log_of_pow_le (one_lt_iff_ne_zero_and_ne_one.2 ⟨m.succ_ne_zero, hm⟩)\n                (le_of_dvd hn h)\n\n"}
{"name":"Nat.Prime.emultiplicity_one","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p 1) 0","decl":"theorem emultiplicity_one {p : ℕ} (hp : p.Prime) : emultiplicity p 1 = 0 :=\n  emultiplicity_of_one_right hp.prime.not_unit\n\n"}
{"name":"Nat.Prime.emultiplicity_mul","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p m n : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p (HMul.hMul m n)) (HAdd.hAdd (emultiplicity p m) (emultiplicity p n))","decl":"theorem emultiplicity_mul {p m n : ℕ} (hp : p.Prime) :\n    emultiplicity p (m * n) = emultiplicity p m + emultiplicity p n :=\n  _root_.emultiplicity_mul hp.prime\n\n"}
{"name":"Nat.Prime.emultiplicity_pow","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p m n : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p (HPow.hPow m n)) (HMul.hMul (↑n) (emultiplicity p m))","decl":"theorem emultiplicity_pow {p m n : ℕ} (hp : p.Prime) :\n    emultiplicity p (m ^ n) = n * emultiplicity p m :=\n  _root_.emultiplicity_pow hp.prime\n\n"}
{"name":"Nat.Prime.emultiplicity_self","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p p) 1","decl":"theorem emultiplicity_self {p : ℕ} (hp : p.Prime) : emultiplicity p p = 1 :=\n  (Nat.finiteMultiplicity_iff.2 ⟨hp.ne_one, hp.pos⟩).emultiplicity_self\n\n"}
{"name":"Nat.Prime.emultiplicity_pow_self","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p (HPow.hPow p n)) ↑n","decl":"theorem emultiplicity_pow_self {p n : ℕ} (hp : p.Prime) : emultiplicity p (p ^ n) = n :=\n  _root_.emultiplicity_pow_self hp.ne_zero hp.prime.not_unit n\n\n"}
{"name":"Nat.Prime.emultiplicity_factorial","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nn b : Nat\na✝ : LT.lt (Nat.log p n) b\n⊢ Eq (emultiplicity p n.factorial) ↑((Finset.Ico 1 b).sum fun i => HDiv.hDiv n (HPow.hPow p i))","decl":"/-- **Legendre's Theorem**\n\nThe multiplicity of a prime in `n!` is the sum of the quotients `n / p ^ i`. This sum is expressed\nover the finset `Ico 1 b` where `b` is any bound greater than `log p n`. -/\ntheorem emultiplicity_factorial {p : ℕ} (hp : p.Prime) :\n    ∀ {n b : ℕ}, log p n < b → emultiplicity p n ! = (∑ i ∈ Ico 1 b, n / p ^ i : ℕ)\n  | 0, b, _ => by simp [Ico, hp.emultiplicity_one]\n  | n + 1, b, hb =>\n    calc\n      emultiplicity p (n + 1)! = emultiplicity p n ! + emultiplicity p (n + 1) := by\n        rw [factorial_succ, hp.emultiplicity_mul, add_comm]\n      _ = (∑ i ∈ Ico 1 b, n / p ^ i : ℕ) + #{i ∈ Ico 1 b | p ^ i ∣ n + 1} := by\n        rw [emultiplicity_factorial hp ((log_mono_right <| le_succ _).trans_lt hb), ←\n          emultiplicity_eq_card_pow_dvd hp.ne_one (succ_pos _) hb]\n      _ = (∑ i ∈ Ico 1 b, (n / p ^ i + if p ^ i ∣ n + 1 then 1 else 0) : ℕ) := by\n        rw [sum_add_distrib, sum_boole]\n        simp\n      _ = (∑ i ∈ Ico 1 b, (n + 1) / p ^ i : ℕ) :=\n        congr_arg _ <| Finset.sum_congr rfl fun _ _ => (succ_div _ _).symm\n\n"}
{"name":"Nat.Prime.sub_one_mul_multiplicity_factorial","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"n p : Nat\nhp : Nat.Prime p\n⊢ Eq (HMul.hMul (HSub.hSub p 1) (multiplicity p n.factorial)) (HSub.hSub n (p.digits n).sum)","decl":"/-- For a prime number `p`, taking `(p - 1)` times the multiplicity of `p` in `n!` equals `n` minus\nthe sum of base `p` digits of `n`. -/\n theorem sub_one_mul_multiplicity_factorial {n p : ℕ} (hp : p.Prime) :\n     (p - 1) * multiplicity p n ! =\n     n - (p.digits n).sum := by\n  simp only [multiplicity_eq_of_emultiplicity_eq_some <|\n      emultiplicity_factorial hp <| lt_succ_of_lt <| lt.base (log p n),\n    ← Finset.sum_Ico_add' _ 0 _ 1, Ico_zero_eq_range, ←\n    sub_one_mul_sum_log_div_pow_eq_sub_sum_digits]\n\n"}
{"name":"Nat.Prime.emultiplicity_factorial_mul_succ","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"n p : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p (HMul.hMul p (HAdd.hAdd n 1)).factorial) (HAdd.hAdd (HAdd.hAdd (emultiplicity p (HMul.hMul p n).factorial) (emultiplicity p (HAdd.hAdd n 1))) 1)","decl":"/-- The multiplicity of `p` in `(p * (n + 1))!` is one more than the sum\n  of the multiplicities of `p` in `(p * n)!` and `n + 1`. -/\ntheorem emultiplicity_factorial_mul_succ {n p : ℕ} (hp : p.Prime) :\n    emultiplicity p (p * (n + 1))! = emultiplicity p (p * n)! + emultiplicity p (n + 1) + 1 := by\n  have hp' := hp.prime\n  have h0 : 2 ≤ p := hp.two_le\n  have h1 : 1 ≤ p * n + 1 := Nat.le_add_left _ _\n  have h2 : p * n + 1 ≤ p * (n + 1) := by linarith\n  have h3 : p * n + 1 ≤ p * (n + 1) + 1 := by omega\n  have hm : emultiplicity p (p * n)! ≠ ⊤ := by\n    rw [Ne, emultiplicity_eq_top, Classical.not_not, Nat.finiteMultiplicity_iff]\n    exact ⟨hp.ne_one, factorial_pos _⟩\n  revert hm\n  have h4 : ∀ m ∈ Ico (p * n + 1) (p * (n + 1)), emultiplicity p m = 0 := by\n    intro m hm\n    rw [emultiplicity_eq_zero, ← not_dvd_iff_between_consec_multiples _ hp.pos]\n    rw [mem_Ico] at hm\n    exact ⟨n, lt_of_succ_le hm.1, hm.2⟩\n  simp_rw [← prod_Ico_id_eq_factorial, Finset.emultiplicity_prod hp', ← sum_Ico_consecutive _ h1 h3,\n    add_assoc]\n  intro h\n  rw [WithTop.add_left_cancel_iff h, sum_Ico_succ_top h2, hp.emultiplicity_mul,\n    hp.emultiplicity_self, sum_congr rfl h4, sum_const_zero, zero_add, add_comm 1]\n\n"}
{"name":"Nat.Prime.emultiplicity_factorial_mul","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"n p : Nat\nhp : Nat.Prime p\n⊢ Eq (emultiplicity p (HMul.hMul p n).factorial) (HAdd.hAdd (emultiplicity p n.factorial) ↑n)","decl":"/-- The multiplicity of `p` in `(p * n)!` is `n` more than that of `n!`. -/\ntheorem emultiplicity_factorial_mul {n p : ℕ} (hp : p.Prime) :\n    emultiplicity p (p * n)! = emultiplicity p n ! + n := by\n  induction' n with n ih\n  · simp\n  · simp only [hp, emultiplicity_factorial_mul_succ, ih, factorial_succ, emultiplicity_mul,\n    cast_add, cast_one, ← add_assoc]\n    congr 1\n    rw [add_comm, add_assoc]\n\n"}
{"name":"Nat.Prime.pow_dvd_factorial_iff","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n r b : Nat\nhp : Nat.Prime p\nhbn : LT.lt (Nat.log p n) b\n⊢ Iff (Dvd.dvd (HPow.hPow p r) n.factorial) (LE.le r ((Finset.Ico 1 b).sum fun i => HDiv.hDiv n (HPow.hPow p i)))","decl":"/-- A prime power divides `n!` iff it is at most the sum of the quotients `n / p ^ i`.\n  This sum is expressed over the set `Ico 1 b` where `b` is any bound greater than `log p n` -/\ntheorem pow_dvd_factorial_iff {p : ℕ} {n r b : ℕ} (hp : p.Prime) (hbn : log p n < b) :\n    p ^ r ∣ n ! ↔ r ≤ ∑ i ∈ Ico 1 b, n / p ^ i := by\n  rw [← WithTop.coe_le_coe, ENat.some_eq_coe, ← hp.emultiplicity_factorial hbn,\n    pow_dvd_iff_le_emultiplicity]\n\n"}
{"name":"Nat.Prime.emultiplicity_factorial_le_div_pred","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nn : Nat\n⊢ LE.le (emultiplicity p n.factorial) ↑(HDiv.hDiv n (HSub.hSub p 1))","decl":"theorem emultiplicity_factorial_le_div_pred {p : ℕ} (hp : p.Prime) (n : ℕ) :\n    emultiplicity p n ! ≤ (n / (p - 1) : ℕ) := by\n  rw [hp.emultiplicity_factorial (lt_succ_self _)]\n  apply WithTop.coe_mono\n  exact Nat.geom_sum_Ico_le hp.two_le _ _\n\n"}
{"name":"Nat.Prime.multiplicity_choose_aux","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n b k : Nat\nhp : Nat.Prime p\nhkn : LE.le k n\n⊢ Eq ((Finset.Ico 1 b).sum fun i => HDiv.hDiv n (HPow.hPow p i)) (HAdd.hAdd (HAdd.hAdd ((Finset.Ico 1 b).sum fun i => HDiv.hDiv k (HPow.hPow p i)) ((Finset.Ico 1 b).sum fun i => HDiv.hDiv (HSub.hSub n k) (HPow.hPow p i))) (Finset.filter (fun i => LE.le (HPow.hPow p i) (HAdd.hAdd (HMod.hMod k (HPow.hPow p i)) (HMod.hMod (HSub.hSub n k) (HPow.hPow p i)))) (Finset.Ico 1 b)).card)","decl":"theorem multiplicity_choose_aux {p n b k : ℕ} (hp : p.Prime) (hkn : k ≤ n) :\n    ∑ i ∈ Finset.Ico 1 b, n / p ^ i =\n      ((∑ i ∈ Finset.Ico 1 b, k / p ^ i) + ∑ i ∈ Finset.Ico 1 b, (n - k) / p ^ i) +\n        #{i ∈ Ico 1 b | p ^ i ≤ k % p ^ i + (n - k) % p ^ i} :=\n  calc\n    ∑ i ∈ Finset.Ico 1 b, n / p ^ i = ∑ i ∈ Finset.Ico 1 b, (k + (n - k)) / p ^ i := by\n      simp only [add_tsub_cancel_of_le hkn]\n    _ = ∑ i ∈ Finset.Ico 1 b,\n          (k / p ^ i + (n - k) / p ^ i + if p ^ i ≤ k % p ^ i + (n - k) % p ^ i then 1 else 0) := by\n      simp only [Nat.add_div (pow_pos hp.pos _)]\n    _ = _ := by simp [sum_add_distrib, sum_boole]\n\n"}
{"name":"Nat.Prime.emultiplicity_choose'","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k b : Nat\nhp : Nat.Prime p\nhnb : LT.lt (Nat.log p (HAdd.hAdd n k)) b\n⊢ Eq (emultiplicity p ((HAdd.hAdd n k).choose k)) ↑(Finset.filter (fun i => LE.le (HPow.hPow p i) (HAdd.hAdd (HMod.hMod k (HPow.hPow p i)) (HMod.hMod n (HPow.hPow p i)))) (Finset.Ico 1 b)).card","decl":"/-- The multiplicity of `p` in `choose (n + k) k` is the number of carries when `k` and `n`\n  are added in base `p`. The set is expressed by filtering `Ico 1 b` where `b`\n  is any bound greater than `log p (n + k)`. -/\ntheorem emultiplicity_choose' {p n k b : ℕ} (hp : p.Prime) (hnb : log p (n + k) < b) :\n    emultiplicity p (choose (n + k) k) = #{i ∈ Ico 1 b | p ^ i ≤ k % p ^ i + n % p ^ i} := by\n  have h₁ :\n      emultiplicity p (choose (n + k) k) + emultiplicity p (k ! * n !) =\n        #{i ∈ Ico 1 b | p ^ i ≤ k % p ^ i + n % p ^ i} + emultiplicity p (k ! * n !) := by\n    rw [← hp.emultiplicity_mul, ← mul_assoc]\n    have := (add_tsub_cancel_right n k) ▸ choose_mul_factorial_mul_factorial (le_add_left k n)\n    rw [this, hp.emultiplicity_factorial hnb, hp.emultiplicity_mul,\n      hp.emultiplicity_factorial ((log_mono_right (le_add_left k n)).trans_lt hnb),\n      hp.emultiplicity_factorial ((log_mono_right (le_add_left n k)).trans_lt\n      (add_comm n k ▸ hnb)), multiplicity_choose_aux hp (le_add_left k n)]\n    simp [add_comm]\n  refine (WithTop.add_right_cancel_iff ?_).1 h₁\n  apply finiteMultiplicity_iff_emultiplicity_ne_top.1\n  exact Nat.finiteMultiplicity_iff.2 ⟨hp.ne_one, mul_pos (factorial_pos k) (factorial_pos n)⟩\n\n"}
{"name":"Nat.Prime.emultiplicity_choose","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k b : Nat\nhp : Nat.Prime p\nhkn : LE.le k n\nhnb : LT.lt (Nat.log p n) b\n⊢ Eq (emultiplicity p (n.choose k)) ↑(Finset.filter (fun i => LE.le (HPow.hPow p i) (HAdd.hAdd (HMod.hMod k (HPow.hPow p i)) (HMod.hMod (HSub.hSub n k) (HPow.hPow p i)))) (Finset.Ico 1 b)).card","decl":"/-- The multiplicity of `p` in `choose n k` is the number of carries when `k` and `n - k`\n  are added in base `p`. The set is expressed by filtering `Ico 1 b` where `b`\n  is any bound greater than `log p n`. -/\ntheorem emultiplicity_choose {p n k b : ℕ} (hp : p.Prime) (hkn : k ≤ n) (hnb : log p n < b) :\n    emultiplicity p (choose n k) = #{i ∈ Ico 1 b | p ^ i ≤ k % p ^ i + (n - k) % p ^ i} := by\n  have := Nat.sub_add_cancel hkn\n  convert @emultiplicity_choose' p (n - k) k b hp _\n  · rw [this]\n  exact this.symm ▸ hnb\n\n"}
{"name":"Nat.Prime.emultiplicity_le_emultiplicity_choose_add","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p : Nat\nhp : Nat.Prime p\nn k : Nat\n⊢ LE.le (emultiplicity p n) (HAdd.hAdd (emultiplicity p (n.choose k)) (emultiplicity p k))","decl":"/-- A lower bound on the multiplicity of `p` in `choose n k`. -/\ntheorem emultiplicity_le_emultiplicity_choose_add {p : ℕ} (hp : p.Prime) :\n    ∀ n k : ℕ, emultiplicity p n ≤ emultiplicity p (choose n k) + emultiplicity p k\n  | _, 0 => by simp\n  | 0, _ + 1 => by simp\n  | n + 1, k + 1 => by\n    rw [← hp.emultiplicity_mul]\n    refine emultiplicity_le_emultiplicity_of_dvd_right ?_\n    rw [← succ_mul_choose_eq]\n    exact dvd_mul_right _ _\n\n"}
{"name":"Nat.Prime.emultiplicity_choose_prime_pow_add_emultiplicity","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k : Nat\nhp : Nat.Prime p\nhkn : LE.le k (HPow.hPow p n)\nhk0 : Ne k 0\n⊢ Eq (HAdd.hAdd (emultiplicity p ((HPow.hPow p n).choose k)) (emultiplicity p k)) ↑n","decl":"theorem emultiplicity_choose_prime_pow_add_emultiplicity (hp : p.Prime) (hkn : k ≤ p ^ n)\n    (hk0 : k ≠ 0) : emultiplicity p (choose (p ^ n) k) + emultiplicity p k = n :=\n  le_antisymm\n    (by\n      have hdisj :\n        Disjoint {i ∈ Ico 1 n.succ | p ^ i ≤ k % p ^ i + (p ^ n - k) % p ^ i}\n          {i ∈ Ico 1 n.succ | p ^ i ∣ k} := by\n        simp +contextual [disjoint_right, *, dvd_iff_mod_eq_zero,\n          Nat.mod_lt _ (pow_pos hp.pos _)]\n      rw [emultiplicity_choose hp hkn (lt_succ_self _),\n        emultiplicity_eq_card_pow_dvd (ne_of_gt hp.one_lt) hk0.bot_lt\n          (lt_succ_of_le (log_mono_right hkn)),\n        ← Nat.cast_add]\n      apply WithTop.coe_mono\n      rw [log_pow hp.one_lt, ← card_union_of_disjoint hdisj, filter_union_right]\n      have filter_le_Ico := (Ico 1 n.succ).card_filter_le\n        fun x => p ^ x ≤ k % p ^ x + (p ^ n - k) % p ^ x ∨ p ^ x ∣ k\n      rwa [card_Ico 1 n.succ] at filter_le_Ico)\n    (by rw [← hp.emultiplicity_pow_self]; exact emultiplicity_le_emultiplicity_choose_add hp _ _)\n\n"}
{"name":"Nat.Prime.emultiplicity_choose_prime_pow","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k : Nat\nhp : Nat.Prime p\nhkn : LE.le k (HPow.hPow p n)\nhk0 : Ne k 0\n⊢ Eq (emultiplicity p ((HPow.hPow p n).choose k)) ↑(HSub.hSub n (multiplicity p k))","decl":"theorem emultiplicity_choose_prime_pow {p n k : ℕ} (hp : p.Prime) (hkn : k ≤ p ^ n) (hk0 : k ≠ 0) :\n    emultiplicity p (choose (p ^ n) k) = ↑(n - multiplicity p k) := by\n  push_cast\n  rw [← emultiplicity_choose_prime_pow_add_emultiplicity hp hkn hk0,\n    (finiteMultiplicity_iff.2 ⟨hp.ne_one, Nat.pos_of_ne_zero hk0⟩).emultiplicity_eq_multiplicity,\n    (finiteMultiplicity_iff.2 ⟨hp.ne_one, choose_pos hkn⟩).emultiplicity_eq_multiplicity]\n  norm_cast\n  rw [Nat.add_sub_cancel_right]\n\n"}
{"name":"Nat.Prime.dvd_choose_pow","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k : Nat\nhp : Nat.Prime p\nhk : Ne k 0\nhkp : Ne k (HPow.hPow p n)\n⊢ Dvd.dvd p ((HPow.hPow p n).choose k)","decl":"theorem dvd_choose_pow (hp : Prime p) (hk : k ≠ 0) (hkp : k ≠ p ^ n) : p ∣ (p ^ n).choose k := by\n  obtain hkp | hkp := hkp.symm.lt_or_lt\n  · simp [choose_eq_zero_of_lt hkp]\n  refine emultiplicity_ne_zero.1 fun h => hkp.not_le <| Nat.le_of_dvd hk.bot_lt ?_\n  have H := hp.emultiplicity_choose_prime_pow_add_emultiplicity hkp.le hk\n  rw [h, zero_add, emultiplicity_eq_coe] at H\n  exact H.1\n\n"}
{"name":"Nat.Prime.dvd_choose_pow_iff","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"p n k : Nat\nhp : Nat.Prime p\n⊢ Iff (Dvd.dvd p ((HPow.hPow p n).choose k)) (And (Ne k 0) (Ne k (HPow.hPow p n)))","decl":"theorem dvd_choose_pow_iff (hp : Prime p) : p ∣ (p ^ n).choose k ↔ k ≠ 0 ∧ k ≠ p ^ n := by\n  refine ⟨fun h => ⟨?_, ?_⟩, fun h => dvd_choose_pow hp h.1 h.2⟩ <;> rintro rfl <;>\n    simp [hp.ne_one] at h\n\n"}
{"name":"Nat.emultiplicity_two_factorial_lt","module":"Mathlib.Data.Nat.Multiplicity","initialProofState":"n : Nat\nx✝ : Ne n 0\n⊢ LT.lt (emultiplicity 2 n.factorial) ↑n","decl":"theorem emultiplicity_two_factorial_lt : ∀ {n : ℕ} (_ : n ≠ 0), emultiplicity 2 n ! < n := by\n  have h2 := prime_two.prime\n  refine binaryRec ?_ ?_\n  · exact fun h => False.elim <| h rfl\n  · intro b n ih h\n    by_cases hn : n = 0\n    · subst hn\n      simp only [ne_eq, bit_eq_zero_iff, true_and, Bool.not_eq_false] at h\n      simp only [bit, h, cond_true, mul_zero, zero_add, factorial_one]\n      rw [Prime.emultiplicity_one]\n      · exact zero_lt_one\n      · decide\n    have : emultiplicity 2 (2 * n)! < (2 * n : ℕ) := by\n      rw [prime_two.emultiplicity_factorial_mul]\n      rw [two_mul]\n      push_cast\n      apply WithTop.add_lt_add_right _ (ih hn)\n      exact Ne.symm nofun\n    cases b\n    · simpa\n    · suffices emultiplicity 2 (2 * n + 1) + emultiplicity 2 (2 * n)! < ↑(2 * n) + 1 by\n        simpa [emultiplicity_mul, h2, prime_two, bit, factorial]\n      rw [emultiplicity_eq_zero.2 (two_not_dvd_two_mul_add_one n), zero_add]\n      refine this.trans ?_\n      exact mod_cast lt_succ_self _\n\n"}
