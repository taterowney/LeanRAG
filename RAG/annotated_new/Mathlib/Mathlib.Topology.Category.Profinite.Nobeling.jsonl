{"name":"Profinite.NobelingProof.continuous_proj","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\n⊢ Continuous (Profinite.NobelingProof.Proj J)","decl":"@[simp]\ntheorem continuous_proj :\n    Continuous (Proj J : (I → Bool) → (I → Bool)) := by\n  dsimp (config := { unfoldPartialApp := true }) [Proj]\n  apply continuous_pi\n  intro i\n  split\n  · apply continuous_apply\n  · apply continuous_const\n\n"}
{"name":"Profinite.NobelingProof.ProjRestrict_coe","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\na✝¹ : ↑C\na✝ : I\n⊢ Eq (↑(Profinite.NobelingProof.ProjRestrict C J a✝¹) a✝) (Profinite.NobelingProof.Proj J (↑a✝¹) a✝)","decl":"/-- The restriction of `Proj π J` to a subset, mapping to its image. -/\n@[simps!]\ndef ProjRestrict : C → π C J :=\n  Set.MapsTo.restrict (Proj J) _ _ (Set.mapsTo_image _ _)\n\n"}
{"name":"Profinite.NobelingProof.continuous_projRestrict","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\n⊢ Continuous (Profinite.NobelingProof.ProjRestrict C J)","decl":"@[simp]\ntheorem continuous_projRestrict : Continuous (ProjRestrict C J) :=\n  Continuous.restrict _ (continuous_proj _)\n\n"}
{"name":"Profinite.NobelingProof.proj_eq_self","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\nx : I → Bool\nh : ∀ (i : I), Ne (x i) Bool.false → J i\n⊢ Eq (Profinite.NobelingProof.Proj J x) x","decl":"theorem proj_eq_self {x : I → Bool} (h : ∀ i, x i ≠ false → J i) : Proj J x = x := by\n  ext i\n  simp only [Proj, ite_eq_left_iff]\n  contrapose!\n  simpa only [ne_comm] using h i\n\n"}
{"name":"Profinite.NobelingProof.proj_prop_eq_self","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\nhh : ∀ (i : I) (x : I → Bool), Membership.mem C x → Ne (x i) Bool.false → J i\n⊢ Eq (Profinite.NobelingProof.π C J) C","decl":"theorem proj_prop_eq_self (hh : ∀ i x, x ∈ C → x i ≠ false → J i) : π C J = C := by\n  ext x\n  refine ⟨fun ⟨y, hy, h⟩ ↦ ?_, fun h ↦ ⟨x, h, ?_⟩⟩\n  · rwa [← h, proj_eq_self]; exact (hh · y hy)\n  · rw [proj_eq_self]; exact (hh · x h)\n\n"}
{"name":"Profinite.NobelingProof.proj_comp_of_subset","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\n⊢ Eq (Function.comp (Profinite.NobelingProof.Proj J) (Profinite.NobelingProof.Proj K)) (Profinite.NobelingProof.Proj J)","decl":"theorem proj_comp_of_subset (h : ∀ i, J i → K i) : (Proj J ∘ Proj K) =\n    (Proj J : (I → Bool) → (I → Bool)) := by\n  ext x i; dsimp [Proj]; aesop\n\n"}
{"name":"Profinite.NobelingProof.proj_eq_of_subset","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\n⊢ Eq (Profinite.NobelingProof.π (Profinite.NobelingProof.π C K) J) (Profinite.NobelingProof.π C J)","decl":"theorem proj_eq_of_subset (h : ∀ i, J i → K i) : π (π C K) J = π C J := by\n  ext x\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · obtain ⟨y, ⟨z, hz, rfl⟩, rfl⟩ := h\n    refine ⟨z, hz, (?_ : _ = (Proj J ∘ Proj K) z)⟩\n    rw [proj_comp_of_subset J K h]\n  · obtain ⟨y, hy, rfl⟩ := h\n    dsimp [π]\n    rw [← Set.image_comp]\n    refine ⟨y, hy, ?_⟩\n    rw [proj_comp_of_subset J K h]\n\n"}
{"name":"Profinite.NobelingProof.ProjRestricts_coe","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\na✝¹ : ↑(Profinite.NobelingProof.π C K)\na✝ : I\n⊢ Eq (↑(Profinite.NobelingProof.ProjRestricts C h a✝¹) a✝) (Profinite.NobelingProof.Proj J (↑a✝¹) a✝)","decl":"/-- A variant of `ProjRestrict` with domain of the form `π C K` -/\n@[simps!]\ndef ProjRestricts (h : ∀ i, J i → K i) : π C K → π C J :=\n  Homeomorph.setCongr (proj_eq_of_subset C J K h) ∘ ProjRestrict (π C K) J\n\n"}
{"name":"Profinite.NobelingProof.continuous_projRestricts","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\n⊢ Continuous (Profinite.NobelingProof.ProjRestricts C h)","decl":"@[simp]\ntheorem continuous_projRestricts (h : ∀ i, J i → K i) : Continuous (ProjRestricts C h) :=\n  Continuous.comp (Homeomorph.continuous _) (continuous_projRestrict _ _)\n\n"}
{"name":"Profinite.NobelingProof.surjective_projRestricts","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\n⊢ Function.Surjective (Profinite.NobelingProof.ProjRestricts C h)","decl":"theorem surjective_projRestricts (h : ∀ i, J i → K i) : Function.Surjective (ProjRestricts C h) :=\n  (Homeomorph.surjective _).comp (Set.surjective_mapsTo_image_restrict _ _)\n\n"}
{"name":"Profinite.NobelingProof.projRestricts_eq_id","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\n⊢ Eq (Profinite.NobelingProof.ProjRestricts C ⋯) id","decl":"variable (J) in\ntheorem projRestricts_eq_id : ProjRestricts C (fun i (h : J i) ↦ h) = id := by\n  ext ⟨x, y, hy, rfl⟩ i\n  simp +contextual only [π, Proj, ProjRestricts_coe, id_eq, if_true]\n\n"}
{"name":"Profinite.NobelingProof.projRestricts_eq_comp","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K L : I → Prop\ninst✝² : (i : I) → Decidable (J i)\ninst✝¹ : (i : I) → Decidable (K i)\ninst✝ : (i : I) → Decidable (L i)\nhJK : ∀ (i : I), J i → K i\nhKL : ∀ (i : I), K i → L i\n⊢ Eq (Function.comp (Profinite.NobelingProof.ProjRestricts C hJK) (Profinite.NobelingProof.ProjRestricts C hKL)) (Profinite.NobelingProof.ProjRestricts C ⋯)","decl":"theorem projRestricts_eq_comp (hJK : ∀ i, J i → K i) (hKL : ∀ i, K i → L i) :\n    ProjRestricts C hJK ∘ ProjRestricts C hKL = ProjRestricts C (fun i ↦ hKL i ∘ hJK i) := by\n  ext x i\n  simp only [π, Proj, Function.comp_apply, ProjRestricts_coe]\n  aesop\n\n"}
{"name":"Profinite.NobelingProof.projRestricts_comp_projRestrict","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ K : I → Prop\ninst✝¹ : (i : I) → Decidable (J i)\ninst✝ : (i : I) → Decidable (K i)\nh : ∀ (i : I), J i → K i\n⊢ Eq (Function.comp (Profinite.NobelingProof.ProjRestricts C h) (Profinite.NobelingProof.ProjRestrict C K)) (Profinite.NobelingProof.ProjRestrict C J)","decl":"theorem projRestricts_comp_projRestrict (h : ∀ i, J i → K i) :\n    ProjRestricts C h ∘ ProjRestrict C K = ProjRestrict C J := by\n  ext x i\n  simp only [π, Proj, Function.comp_apply, ProjRestricts_coe, ProjRestrict_coe]\n  aesop\n\n"}
{"name":"Profinite.NobelingProof.iso_map_bijective","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\nJ : I → Prop\ninst✝ : (i : I) → Decidable (J i)\n⊢ Function.Bijective ⇑(Profinite.NobelingProof.iso_map C J)","decl":"lemma iso_map_bijective : Function.Bijective (iso_map C J) := by\n  refine ⟨fun a b h ↦ ?_, fun a ↦ ?_⟩\n  · ext i\n    rw [Subtype.ext_iff] at h\n    by_cases hi : J i\n    · exact congr_fun h ⟨i, hi⟩\n    · rcases a with ⟨_, c, hc, rfl⟩\n      rcases b with ⟨_, d, hd, rfl⟩\n      simp only [Proj, if_neg hi]\n  · refine ⟨⟨fun i ↦ if hi : J i then a.val ⟨i, hi⟩ else false, ?_⟩, ?_⟩\n    · rcases a with ⟨_, y, hy, rfl⟩\n      exact ⟨y, hy, rfl⟩\n    · ext i\n      exact dif_pos i.prop\n\n"}
{"name":"Profinite.NobelingProof.Products.lt_iff_lex_lt","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝ : LinearOrder I\nl m : Profinite.NobelingProof.Products I\n⊢ Iff (LT.lt l m) (List.Lex (fun x1 x2 => LT.lt x1 x2) ↑l ↑m)","decl":"@[simp]\ntheorem lt_iff_lex_lt (l m : Products I) : l < m ↔ List.Lex (·<·) l.val m.val := by\n  cases l; cases m; rw [Subtype.mk_lt_mk]; exact Iff.rfl\n\n"}
{"name":"Profinite.NobelingProof.Products.instWellFoundedLT","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\n⊢ WellFoundedLT (Profinite.NobelingProof.Products I)","decl":"instance [WellFoundedLT I] : WellFoundedLT (Products I) := by\n  have : (· < · : Products I → _ → _) = (fun l m ↦ List.Lex (·<·) l.val m.val) := by\n    ext; exact lt_iff_lex_lt _ _\n  rw [WellFoundedLT, this]\n  dsimp [Products]\n  rw [(by rfl : (·>· : I → _) = flip (·<·))]\n  infer_instance\n\n"}
{"name":"Profinite.NobelingProof.Products.rel_head!_of_mem","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : Inhabited I\ni : I\nl : Profinite.NobelingProof.Products I\nhi : Membership.mem (↑l) i\n⊢ LE.le i (↑l).head!","decl":"theorem rel_head!_of_mem [Inhabited I] {i : I} {l : Products I} (hi : i ∈ l.val) :\n    i ≤ l.val.head! :=\n  List.Sorted.le_head! (List.chain'_iff_pairwise.mp l.prop) hi\n\n"}
{"name":"Profinite.NobelingProof.Products.head!_le_of_lt","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : Inhabited I\nq l : Profinite.NobelingProof.Products I\nh : LT.lt q l\nhq : Ne (↑q) List.nil\n⊢ LE.le (↑q).head! (↑l).head!","decl":"theorem head!_le_of_lt [Inhabited I] {q l : Products I} (h : q < l) (hq : q.val ≠ []) :\n    q.val.head! ≤ l.val.head! :=\n  List.head!_le_of_lt l.val q.val h hq\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.injective","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\n⊢ Function.Injective (Profinite.NobelingProof.GoodProducts.eval C)","decl":"theorem injective : Function.Injective (eval C) := by\n  intro ⟨a, ha⟩ ⟨b, hb⟩ h\n  dsimp [eval] at h\n  rcases lt_trichotomy a b with (h'|rfl|h')\n  · exfalso; apply hb; rw [← h]\n    exact Submodule.subset_span ⟨a, h', rfl⟩\n  · rfl\n  · exfalso; apply ha; rw [h]\n    exact Submodule.subset_span ⟨b, ⟨h',rfl⟩⟩\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.equiv_toFun_eq_eval","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\n⊢ Eq (Profinite.NobelingProof.GoodProducts.equiv_range C).toFun (Set.rangeFactorization (Profinite.NobelingProof.GoodProducts.eval C))","decl":"theorem equiv_toFun_eq_eval : (equiv_range C).toFun = Set.rangeFactorization (eval C) := rfl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent_iff_range","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\n⊢ Iff (LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval C)) (LinearIndependent Int fun p => ↑p)","decl":"theorem linearIndependent_iff_range : LinearIndependent ℤ (GoodProducts.eval C) ↔\n    LinearIndependent ℤ (fun (p : range C) ↦ p.1) := by\n  rw [← @Set.rangeFactorization_eq _ _ (GoodProducts.eval C), ← equiv_toFun_eq_eval C]\n  exact linearIndependent_equiv (equiv_range C)\n\n"}
{"name":"Profinite.NobelingProof.Products.eval_eq","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\nl : Profinite.NobelingProof.Products I\nx : ↑C\n⊢ Eq ((Profinite.NobelingProof.Products.eval C l) x) (ite (∀ (i : I), Membership.mem (↑l) i → Eq (↑x i) Bool.true) 1 0)","decl":"theorem eval_eq (l : Products I) (x : C) :\n    l.eval C x = if ∀ i, i ∈ l.val → (x.val i = true) then 1 else 0 := by\n  change LocallyConstant.evalMonoidHom x (l.eval C) = _\n  rw [eval, map_list_prod]\n  split_ifs with h\n  · simp only [List.map_map]\n    apply List.prod_eq_one\n    simp only [List.mem_map, Function.comp_apply]\n    rintro _ ⟨i, hi, rfl⟩\n    exact if_pos (h i hi)\n  · simp only [List.map_map, List.prod_eq_zero_iff, List.mem_map, Function.comp_apply]\n    push_neg at h\n    convert h with i\n    dsimp [LocallyConstant.evalMonoidHom, e]\n    simp only [ite_eq_right_iff, one_ne_zero]\n\n"}
{"name":"Profinite.NobelingProof.Products.evalFacProp","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\nl : Profinite.NobelingProof.Products I\nJ : I → Prop\nh : ∀ (a : I), Membership.mem (↑l) a → J a\ninst✝ : (j : I) → Decidable (J j)\n⊢ Eq (Function.comp (⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l)) (Profinite.NobelingProof.ProjRestrict C J)) ⇑(Profinite.NobelingProof.Products.eval C l)","decl":"theorem evalFacProp {l : Products I} (J : I → Prop)\n    (h : ∀ a, a ∈ l.val → J a) [∀ j, Decidable (J j)] :\n    l.eval (π C J) ∘ ProjRestrict C J = l.eval C := by\n  ext x\n  dsimp [ProjRestrict]\n  rw [Products.eval_eq, Products.eval_eq]\n  congr\n  apply forall_congr; intro i\n  apply forall_congr; intro hi\n  simp [h i hi, Proj]\n\n"}
{"name":"Profinite.NobelingProof.Products.evalFacProps","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝² : LinearOrder I\nl : Profinite.NobelingProof.Products I\nJ K : I → Prop\nh : ∀ (a : I), Membership.mem (↑l) a → J a\ninst✝¹ : (j : I) → Decidable (J j)\ninst✝ : (j : I) → Decidable (K j)\nhJK : ∀ (i : I), J i → K i\n⊢ Eq (Function.comp (⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C J) l)) (Profinite.NobelingProof.ProjRestricts C hJK)) ⇑(Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C K) l)","decl":"theorem evalFacProps {l : Products I} (J K : I → Prop)\n    (h : ∀ a, a ∈ l.val → J a) [∀ j, Decidable (J j)] [∀ j, Decidable (K j)]\n    (hJK : ∀ i, J i → K i) :\n    l.eval (π C J) ∘ ProjRestricts C hJK = l.eval (π C K) := by\n  have : l.eval (π C J) ∘ Homeomorph.setCongr (proj_eq_of_subset C J K hJK) =\n      l.eval (π (π C K) J) := by\n    ext; simp [Homeomorph.setCongr, Products.eval_eq]\n  rw [ProjRestricts, ← Function.comp_assoc, this, ← evalFacProp (π C K) J h]\n\n"}
{"name":"Profinite.NobelingProof.Products.prop_of_isGood","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\nl : Profinite.NobelingProof.Products I\nJ : I → Prop\ninst✝ : (j : I) → Decidable (J j)\nh : Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C J) l\na : I\na✝ : Membership.mem (↑l) a\n⊢ J a","decl":"theorem prop_of_isGood {l : Products I} (J : I → Prop) [∀ j, Decidable (J j)]\n    (h : l.isGood (π C J)) : ∀ a, a ∈ l.val → J a := by\n  intro i hi\n  by_contra h'\n  apply h\n  suffices eval (π C J) l = 0 by\n    rw [this]\n    exact Submodule.zero_mem _\n  ext ⟨_, _, _, rfl⟩\n  rw [eval_eq, if_neg fun h ↦ ?_, LocallyConstant.zero_apply]\n  simpa [Proj, h'] using h i hi\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.span_iff_products","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\n⊢ Iff (LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval C)))) (LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.Products.eval C))))","decl":"/-- The good products span `LocallyConstant C ℤ` if and only all the products do. -/\ntheorem GoodProducts.span_iff_products [WellFoundedLT I] :\n    ⊤ ≤ Submodule.span ℤ (Set.range (eval C)) ↔\n      ⊤ ≤ Submodule.span ℤ (Set.range (Products.eval C)) := by\n  refine ⟨fun h ↦ le_trans h (span_mono (fun a ⟨b, hb⟩ ↦ ⟨b.val, hb⟩)), fun h ↦ le_trans h ?_⟩\n  rw [span_le]\n  rintro f ⟨l, rfl⟩\n  let L : Products I → Prop := fun m ↦ m.eval C ∈ span ℤ (Set.range (GoodProducts.eval C))\n  suffices L l by assumption\n  apply IsWellFounded.induction (·<· : Products I → Products I → Prop)\n  intro l h\n  dsimp\n  by_cases hl : l.isGood C\n  · apply subset_span\n    exact ⟨⟨l, hl⟩, rfl⟩\n  · simp only [Products.isGood, not_not] at hl\n    suffices Products.eval C '' {m | m < l} ⊆ span ℤ (Set.range (GoodProducts.eval C)) by\n      rw [← span_le] at this\n      exact this hl\n    rintro a ⟨m, hm, rfl⟩\n    exact h m hm\n\n"}
{"name":"Profinite.NobelingProof.eval_eq_πJ","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nl : Profinite.NobelingProof.Products I\nhl : Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => Membership.mem s x) l\n⊢ Eq (Profinite.NobelingProof.Products.eval C l) ((Profinite.NobelingProof.πJ C s) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => Membership.mem s x) l))","decl":"theorem eval_eq_πJ (l : Products I) (hl : l.isGood (π C (· ∈ s))) :\n    l.eval C = πJ C s (l.eval (π C (· ∈ s))) := by\n  ext f\n  simp only [πJ, LocallyConstant.comapₗ, LinearMap.coe_mk, AddHom.coe_mk,\n    (continuous_projRestrict C (· ∈ s)), LocallyConstant.coe_comap, Function.comp_apply]\n  exact (congr_fun (Products.evalFacProp C (· ∈ s) (Products.prop_of_isGood  C (· ∈ s) hl)) _).symm\n\n"}
{"name":"Profinite.NobelingProof.spanFinBasis.span","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\n⊢ LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.spanFinBasis C s)))","decl":"open scoped Classical in\ntheorem spanFinBasis.span : ⊤ ≤ Submodule.span ℤ (Set.range (spanFinBasis C s)) := by\n  intro f _\n  rw [Finsupp.mem_span_range_iff_exists_finsupp]\n  use Finsupp.onFinset (Finset.univ) f.toFun (fun _ _ ↦ Finset.mem_univ _)\n  ext x\n  change LocallyConstant.evalₗ ℤ x _ = _\n  simp only [zsmul_eq_mul, map_finsupp_sum, LocallyConstant.evalₗ_apply,\n    LocallyConstant.coe_mul, Pi.mul_apply, spanFinBasis, LocallyConstant.coe_mk, mul_ite, mul_one,\n    mul_zero, Finsupp.sum_ite_eq, Finsupp.mem_support_iff, ne_eq, ite_not]\n  split_ifs with h <;> [exact h.symm; rfl]\n\n"}
{"name":"Profinite.NobelingProof.list_prod_apply","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\nC : Set (I → Bool)\nx : ↑C\nl : List (LocallyConstant (↑C) Int)\n⊢ Eq (l.prod x) (List.map (⇑(LocallyConstant.evalMonoidHom x)) l).prod","decl":"theorem list_prod_apply {I} (C : Set (I → Bool)) (x : C) (l : List (LocallyConstant C ℤ)) :\n    l.prod x = (l.map (LocallyConstant.evalMonoidHom x)).prod := by\n  rw [← map_list_prod (LocallyConstant.evalMonoidHom x) l]\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.factors_prod_eq_basis_of_eq","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nx y : ↑(Profinite.NobelingProof.π C fun x => Membership.mem s x)\nh : Eq y x\n⊢ Eq ((Profinite.NobelingProof.factors C s x).prod y) 1","decl":"theorem factors_prod_eq_basis_of_eq {x y : (π C fun x ↦ x ∈ s)} (h : y = x) :\n    (factors C s x).prod y = 1 := by\n  rw [list_prod_apply (π C (· ∈ s)) y _]\n  apply List.prod_eq_one\n  simp only [h, List.mem_map, LocallyConstant.evalMonoidHom, factors]\n  rintro _ ⟨a, ⟨b, _, rfl⟩, rfl⟩\n  dsimp\n  split_ifs with hh\n  · rw [e, LocallyConstant.coe_mk, if_pos hh]\n  · rw [LocallyConstant.sub_apply, e, LocallyConstant.coe_mk, LocallyConstant.coe_mk, if_neg hh]\n    simp only [LocallyConstant.toFun_eq_coe, LocallyConstant.coe_one, Pi.one_apply, sub_zero]\n\n"}
{"name":"Profinite.NobelingProof.e_mem_of_eq_true","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nx : ↑(Profinite.NobelingProof.π C fun x => Membership.mem s x)\na : I\nhx : Eq (↑x a) Bool.true\n⊢ Membership.mem (Profinite.NobelingProof.factors C s x) (Profinite.NobelingProof.e (Profinite.NobelingProof.π C fun x => Membership.mem s x) a)","decl":"theorem e_mem_of_eq_true {x : (π C (· ∈ s))} {a : I} (hx : x.val a = true) :\n    e (π C (· ∈ s)) a ∈ factors C s x := by\n  rcases x with ⟨_, z, hz, rfl⟩\n  simp only [factors, List.mem_map, Finset.mem_sort]\n  refine ⟨a, ?_, if_pos hx⟩\n  aesop (add simp Proj)\n\n"}
{"name":"Profinite.NobelingProof.one_sub_e_mem_of_false","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nx y : ↑(Profinite.NobelingProof.π C fun x => Membership.mem s x)\na : I\nha : Eq (↑y a) Bool.true\nhx : Eq (↑x a) Bool.false\n⊢ Membership.mem (Profinite.NobelingProof.factors C s x) (HSub.hSub 1 (Profinite.NobelingProof.e (Profinite.NobelingProof.π C fun x => Membership.mem s x) a))","decl":"theorem one_sub_e_mem_of_false {x y : (π C (· ∈ s))} {a : I} (ha : y.val a = true)\n    (hx : x.val a = false) : 1 - e (π C (· ∈ s)) a ∈ factors C s x := by\n  simp only [factors, List.mem_map, Finset.mem_sort]\n  use a\n  simp only [hx, ite_false, and_true]\n  rcases y with ⟨_, z, hz, rfl⟩\n  aesop (add simp Proj)\n\n"}
{"name":"Profinite.NobelingProof.factors_prod_eq_basis_of_ne","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nx y : ↑(Profinite.NobelingProof.π C fun x => Membership.mem s x)\nh : Ne y x\n⊢ Eq ((Profinite.NobelingProof.factors C s x).prod y) 0","decl":"theorem factors_prod_eq_basis_of_ne {x y : (π C (· ∈ s))} (h : y ≠ x) :\n    (factors C s x).prod y = 0 := by\n  rw [list_prod_apply (π C (· ∈ s)) y _]\n  apply List.prod_eq_zero\n  simp only [List.mem_map]\n  obtain ⟨a, ha⟩ : ∃ a, y.val a ≠ x.val a := by contrapose! h; ext; apply h\n  cases hx : x.val a\n  · rw [hx, ne_eq, Bool.not_eq_false] at ha\n    refine ⟨1 - (e (π C (· ∈ s)) a), ⟨one_sub_e_mem_of_false _ _ ha hx, ?_⟩⟩\n    rw [e, LocallyConstant.evalMonoidHom_apply, LocallyConstant.sub_apply,\n      LocallyConstant.coe_one, Pi.one_apply, LocallyConstant.coe_mk, if_pos ha, sub_self]\n  · refine ⟨e (π C (· ∈ s)) a, ⟨e_mem_of_eq_true _ _ hx, ?_⟩⟩\n    rw [hx] at ha\n    rw [LocallyConstant.evalMonoidHom_apply, e, LocallyConstant.coe_mk, if_neg ha]\n\n"}
{"name":"Profinite.NobelingProof.factors_prod_eq_basis","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\nx : ↑(Profinite.NobelingProof.π C fun x => Membership.mem s x)\n⊢ Eq (Profinite.NobelingProof.factors C s x).prod (Profinite.NobelingProof.spanFinBasis C s x)","decl":"/-- If `s` is finite, the product of the elements of the list `factors C s x`\nis the delta function at `x`. -/\ntheorem factors_prod_eq_basis (x : π C (· ∈ s)) :\n    (factors C s x).prod = spanFinBasis C s x := by\n  ext y\n  dsimp [spanFinBasis]\n  split_ifs with h <;> [exact factors_prod_eq_basis_of_eq _ _ h;\n    exact factors_prod_eq_basis_of_ne _ _ h]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.finsupp_sum_mem_span_eval","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\ns : Finset I\na : I\nas : List I\nha : List.Chain' (fun x1 x2 => GT.gt x1 x2) (List.cons a as)\nc : Finsupp (Profinite.NobelingProof.Products I) Int\nhc : HasSubset.Subset (↑c.support) (setOf fun m => LE.le (↑m) as)\n⊢ Membership.mem (Submodule.span Int (Set.image (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => Membership.mem s x)) (setOf fun m => LE.le (↑m) (List.cons a as)))) (c.sum fun a_1 b => HMul.hMul (Profinite.NobelingProof.e (Profinite.NobelingProof.π C fun x => Membership.mem s x) a) (HSMul.hSMul b (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => Membership.mem s x) a_1)))","decl":"theorem GoodProducts.finsupp_sum_mem_span_eval {a : I} {as : List I}\n    (ha : List.Chain' (· > ·) (a :: as)) {c : Products I →₀ ℤ}\n    (hc : (c.support : Set (Products I)) ⊆ {m | m.val ≤ as}) :\n    (Finsupp.sum c fun a_1 b ↦ e (π C (· ∈ s)) a * b • Products.eval (π C (· ∈ s)) a_1) ∈\n      Submodule.span ℤ (Products.eval (π C (· ∈ s)) '' {m | m.val ≤ a :: as}) := by\n  apply Submodule.finsupp_sum_mem\n  intro m hm\n  have hsm := (LinearMap.mulLeft ℤ (e (π C (· ∈ s)) a)).map_smul\n  dsimp at hsm\n  rw [hsm]\n  apply Submodule.smul_mem\n  apply Submodule.subset_span\n  have hmas : m.val ≤ as := by\n    apply hc\n    simpa only [Finset.mem_coe, Finsupp.mem_support_iff] using hm\n  refine ⟨⟨a :: m.val, ha.cons_of_le m.prop hmas⟩, ⟨List.cons_le_cons a hmas, ?_⟩⟩\n  simp only [Products.eval, List.map, List.prod_cons]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.spanFin","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ns : Finset I\ninst✝ : WellFoundedLT I\n⊢ LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => Membership.mem s x))))","decl":"/-- If `s` is a finite subset of `I`, then the good products span. -/\ntheorem GoodProducts.spanFin [WellFoundedLT I] :\n    ⊤ ≤ Submodule.span ℤ (Set.range (eval (π C (· ∈ s)))) := by\n  rw [span_iff_products]\n  refine le_trans (spanFinBasis.span C s) ?_\n  rw [Submodule.span_le]\n  rintro _ ⟨x, rfl⟩\n  rw [← factors_prod_eq_basis]\n  let l := s.sort (·≥·)\n  dsimp [factors]\n  suffices l.Chain' (·>·) → (l.map (fun i ↦ if x.val i = true then e (π C (· ∈ s)) i\n      else (1 - (e (π C (· ∈ s)) i)))).prod ∈\n      Submodule.span ℤ ((Products.eval (π C (· ∈ s))) '' {m | m.val ≤ l}) from\n    Submodule.span_mono (Set.image_subset_range _ _) (this (Finset.sort_sorted_gt _).chain')\n  induction l with\n  | nil =>\n    intro _\n    apply Submodule.subset_span\n    exact ⟨⟨[], List.chain'_nil⟩,⟨Or.inl rfl, rfl⟩⟩\n  | cons a as ih =>\n    rw [List.map_cons, List.prod_cons]\n    intro ha\n    specialize ih (by rw [List.chain'_cons'] at ha; exact ha.2)\n    rw [Finsupp.mem_span_image_iff_linearCombination] at ih\n    simp only [Finsupp.mem_supported, Finsupp.linearCombination_apply] at ih\n    obtain ⟨c, hc, hc'⟩ := ih\n    rw [← hc']; clear hc'\n    have hmap := fun g ↦ map_finsupp_sum (LinearMap.mulLeft ℤ (e (π C (· ∈ s)) a)) c g\n    dsimp at hmap ⊢\n    split_ifs\n    · rw [hmap]\n      exact finsupp_sum_mem_span_eval _ _ ha hc\n    · ring_nf\n      rw [hmap]\n      apply Submodule.add_mem\n      · apply Submodule.neg_mem\n        exact finsupp_sum_mem_span_eval _ _ ha hc\n      · apply Submodule.finsupp_sum_mem\n        intro m hm\n        apply Submodule.smul_mem\n        apply Submodule.subset_span\n        refine ⟨m, ⟨?_, rfl⟩⟩\n        simp only [Set.mem_setOf_eq]\n        have hmas : m.val ≤ as :=\n          hc (by simpa only [Finset.mem_coe, Finsupp.mem_support_iff] using hm)\n        refine le_trans hmas ?_\n        cases as with\n        | nil => exact (List.nil_lt_cons a []).le\n        | cons b bs =>\n          apply le_of_lt\n          rw [List.chain'_cons] at ha\n          exact (List.lt_iff_lex_lt _ _).mp (List.Lex.rel ha.1)\n\n"}
{"name":"Profinite.NobelingProof.fin_comap_jointlySurjective","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝ : LinearOrder I\nhC : IsClosed C\nf : LocallyConstant (↑C) Int\n⊢ Exists fun s => Exists fun g => Eq f (LocallyConstant.comap { toFun := Profinite.NobelingProof.ProjRestrict C fun x => Membership.mem s x, continuous_toFun := ⋯ } g)","decl":"theorem fin_comap_jointlySurjective\n    (hC : IsClosed C)\n    (f : LocallyConstant C ℤ) : ∃ (s : Finset I)\n    (g : LocallyConstant (π C (· ∈ s)) ℤ), f = g.comap ⟨(ProjRestrict C (· ∈ s)),\n      continuous_projRestrict _ _⟩ := by\n  obtain ⟨J, g, h⟩ := @Profinite.exists_locallyConstant (Finset I)ᵒᵖ _ _ _\n    (spanCone hC.isCompact) ℤ\n    (spanCone_isLimit hC.isCompact) f\n  exact ⟨(Opposite.unop J), g, h⟩\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.span","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nhC : IsClosed C\n⊢ LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval C)))","decl":"/-- The good products span all of `LocallyConstant C ℤ` if `C` is closed. -/\ntheorem GoodProducts.span [WellFoundedLT I] (hC : IsClosed C) :\n    ⊤ ≤ Submodule.span ℤ (Set.range (eval C)) := by\n  rw [span_iff_products]\n  intro f _\n  obtain ⟨K, f', rfl⟩ : ∃ K f', f = πJ C K f' := fin_comap_jointlySurjective C hC f\n  refine Submodule.span_mono ?_ <| Submodule.apply_mem_span_image_of_mem_span (πJ C K) <|\n    spanFin C K (Submodule.mem_top : f' ∈ ⊤)\n  rintro l ⟨y, ⟨m, rfl⟩, rfl⟩\n  exact ⟨m.val, eval_eq_πJ C K m.val m.prop⟩\n\n"}
{"name":"Profinite.NobelingProof.term_ord_aux","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\ni : I\nho : LT.lt (Profinite.NobelingProof.ord I i) (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Profinite.NobelingProof.term I ho) i","decl":"theorem term_ord_aux {i : I} (ho : ord I i < Ordinal.type ((·<·) : I → I → Prop)) :\n    term I ho = i := by\n  simp only [term, ord, Ordinal.enum_typein]\n\n"}
{"name":"Profinite.NobelingProof.ord_term_aux","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Profinite.NobelingProof.ord I (Profinite.NobelingProof.term I ho)) o","decl":"@[simp]\ntheorem ord_term_aux {o : Ordinal} (ho : o < Ordinal.type ((·<·) : I → I → Prop)) :\n    ord I (term I ho) = o := by\n  simp only [ord, term, Ordinal.typein_enum]\n\n"}
{"name":"Profinite.NobelingProof.ord_term","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ni : I\n⊢ Iff (Eq (Profinite.NobelingProof.ord I i) o) (Eq (Profinite.NobelingProof.term I ho) i)","decl":"theorem ord_term {o : Ordinal} (ho : o < Ordinal.type ((·<·) : I → I → Prop)) (i : I) :\n    ord I i = o ↔ term I ho = i := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · subst h\n    exact term_ord_aux ho\n  · subst h\n    exact ord_term_aux ho\n\n"}
{"name":"Profinite.NobelingProof.Products.prop_of_isGood_of_contained","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no : Ordinal.{u}\nh : Profinite.NobelingProof.Products.isGood C l\nhsC : Profinite.NobelingProof.contained C o\ni : I\nhi : Membership.mem (↑l) i\n⊢ LT.lt (Profinite.NobelingProof.ord I i) o","decl":"theorem Products.prop_of_isGood_of_contained  {l : Products I} (o : Ordinal) (h : l.isGood C)\n    (hsC : contained C o) (i : I) (hi : i ∈ l.val) : ord I i < o := by\n  by_contra h'\n  apply h\n  suffices eval C l = 0 by simp [this, Submodule.zero_mem]\n  ext x\n  simp only [eval_eq, LocallyConstant.coe_zero, Pi.zero_apply, ite_eq_right_iff, one_ne_zero]\n  contrapose! h'\n  exact hsC x.val x.prop i (h'.1 i hi)\n\n"}
{"name":"Profinite.NobelingProof.instSubsingletonLocallyConstantElemForallBoolEmptyCollectionSetInt","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\n⊢ Subsingleton (LocallyConstant (↑EmptyCollection.emptyCollection) Int)","decl":"instance : Subsingleton (LocallyConstant (∅ : Set (I → Bool)) ℤ) :=\n  subsingleton_iff.mpr (fun _ _ ↦ LocallyConstant.ext isEmptyElim)\n\n"}
{"name":"Profinite.NobelingProof.instIsEmptySubtypeProductsIsGoodEmptyCollectionSetForallBool","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝ : LinearOrder I\n⊢ IsEmpty (Subtype fun l => Profinite.NobelingProof.Products.isGood EmptyCollection.emptyCollection l)","decl":"instance : IsEmpty { l // Products.isGood (∅ : Set (I → Bool)) l } :=\n  isEmpty_iff.mpr fun ⟨l, hl⟩ ↦ hl <| by\n    rw [subsingleton_iff.mp inferInstance (Products.eval ∅ l) 0]\n    exact Submodule.zero_mem _\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependentEmpty","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\n⊢ LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval EmptyCollection.emptyCollection)","decl":"theorem GoodProducts.linearIndependentEmpty {I} [LinearOrder I] :\n    LinearIndependent ℤ (eval (∅ : Set (I → Bool))) := linearIndependent_empty_type\n\n"}
{"name":"Profinite.NobelingProof.Products.lt_nil_empty","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\n⊢ Eq (setOf fun m => LT.lt m Profinite.NobelingProof.Products.nil) EmptyCollection.emptyCollection","decl":"theorem Products.lt_nil_empty {I} [LinearOrder I] : { m : Products I | m < Products.nil } = ∅ := by\n  ext ⟨m, hm⟩\n  refine ⟨fun h ↦ ?_, by tauto⟩\n  simp only [Set.mem_setOf_eq, lt_iff_lex_lt, nil, List.not_lex_nil] at h\n\n"}
{"name":"Profinite.NobelingProof.instNontrivialLocallyConstantIntOfNonempty","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Nonempty α\n⊢ Nontrivial (LocallyConstant α Int)","decl":"instance {α : Type*} [TopologicalSpace α] [Nonempty α] : Nontrivial (LocallyConstant α ℤ) :=\n  ⟨0, 1, ne_of_apply_ne DFunLike.coe <| (Function.const_injective (β := ℤ)).ne zero_ne_one⟩\n\n"}
{"name":"Profinite.NobelingProof.Products.isGood_nil","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\n⊢ Profinite.NobelingProof.Products.isGood (Singleton.singleton fun x => Bool.false) Profinite.NobelingProof.Products.nil","decl":"theorem Products.isGood_nil {I} [LinearOrder I] :\n    Products.isGood ({fun _ ↦ false} : Set (I → Bool)) Products.nil := by\n  intro h\n  simp [Products.eval, Products.nil] at h\n\n"}
{"name":"Profinite.NobelingProof.Products.span_nil_eq_top","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\n⊢ Eq (Submodule.span Int (Set.image (Profinite.NobelingProof.Products.eval (Singleton.singleton fun x => Bool.false)) (Singleton.singleton Profinite.NobelingProof.Products.nil))) Top.top","decl":"theorem Products.span_nil_eq_top {I} [LinearOrder I] :\n    Submodule.span ℤ (eval ({fun _ ↦ false} : Set (I → Bool)) '' {nil}) = ⊤ := by\n  rw [Set.image_singleton, eq_top_iff]\n  intro f _\n  rw [Submodule.mem_span_singleton]\n  refine ⟨f default, ?_⟩\n  simp only [eval, List.map, List.prod_nil, zsmul_eq_mul, mul_one, Products.nil]\n  ext x\n  obtain rfl : x = default := by simp only [Set.default_coe_singleton, eq_iff_true_of_subsingleton]\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.instNoZeroSMulDivisorsIntLocallyConstant","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ NoZeroSMulDivisors Int (LocallyConstant α Int)","decl":"instance (α : Type*) [TopologicalSpace α] : NoZeroSMulDivisors ℤ (LocallyConstant α ℤ) := by\n  constructor\n  intro c f h\n  rw [or_iff_not_imp_left]\n  intro hc\n  ext x\n  apply mul_right_injective₀ hc\n  simp [LocallyConstant.ext_iff] at h\n  simpa [LocallyConstant.ext_iff] using h x\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependentSingleton","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\n⊢ LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval (Singleton.singleton fun x => Bool.false))","decl":"theorem GoodProducts.linearIndependentSingleton {I} [LinearOrder I] :\n    LinearIndependent ℤ (eval ({fun _ ↦ false} : Set (I → Bool))) := by\n  refine linearIndependent_unique (eval ({fun _ ↦ false} : Set (I → Bool))) ?_\n  simp [eval, Products.eval, Products.nil, default]\n\n"}
{"name":"Profinite.NobelingProof.contained_eq_proj","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nh : Profinite.NobelingProof.contained C o\n⊢ Eq C (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)","decl":"theorem contained_eq_proj (o : Ordinal) (h : contained C o) :\n    C = π C (ord I · < o) := by\n  have := proj_prop_eq_self C (ord I · < o)\n  simp only [ne_eq, Bool.not_eq_false, π] at this\n  exact (this (fun i x hx ↦ h x hx i)).symm\n\n"}
{"name":"Profinite.NobelingProof.isClosed_proj","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\n⊢ IsClosed (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)","decl":"theorem isClosed_proj (o : Ordinal) (hC : IsClosed C) : IsClosed (π C (ord I · < o)) :=\n  (continuous_proj (ord I · < o)).isClosedMap C hC\n\n"}
{"name":"Profinite.NobelingProof.contained_proj","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Profinite.NobelingProof.contained (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o) o","decl":"theorem contained_proj (o : Ordinal) : contained (π C (ord I · < o)) o := by\n  intro x ⟨_, _, h⟩ j hj\n  aesop (add simp Proj)\n\n"}
{"name":"Profinite.NobelingProof.πs_apply_apply","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\ng : LocallyConstant (↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) Int\na✝ : ↑C\n⊢ Eq (((Profinite.NobelingProof.πs C o) g) a✝) (g (Profinite.NobelingProof.ProjRestrict C (fun x => LT.lt (Profinite.NobelingProof.ord I x) o) a✝))","decl":"/-- The `ℤ`-linear map induced by precomposition of the projection `C → π C (ord I · < o)`. -/\n@[simps!]\nnoncomputable\ndef πs (o : Ordinal) : LocallyConstant (π C (ord I · < o)) ℤ →ₗ[ℤ] LocallyConstant C ℤ :=\n  LocallyConstant.comapₗ ℤ ⟨(ProjRestrict C (ord I · < o)), (continuous_projRestrict _ _)⟩\n\n"}
{"name":"Profinite.NobelingProof.coe_πs","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nf : LocallyConstant (↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) Int\n⊢ Eq (⇑((Profinite.NobelingProof.πs C o) f)) (Function.comp (⇑f) (Profinite.NobelingProof.ProjRestrict C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))","decl":"theorem coe_πs (o : Ordinal) (f : LocallyConstant (π C (ord I · < o)) ℤ) :\n    πs C o f = f ∘ ProjRestrict C (ord I · < o) := by\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.injective_πs","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Function.Injective ⇑(Profinite.NobelingProof.πs C o)","decl":"theorem injective_πs (o : Ordinal) : Function.Injective (πs C o) :=\n  LocallyConstant.comap_injective ⟨_, (continuous_projRestrict _ _)⟩\n    (Set.surjective_mapsTo_image_restrict _ _)\n\n"}
{"name":"Profinite.NobelingProof.πs'_apply_apply","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\ng : LocallyConstant (↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₁)) Int\na✝ : ↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₂)\n⊢ Eq (((Profinite.NobelingProof.πs' C h) g) a✝) (g (Profinite.NobelingProof.ProjRestricts C ⋯ a✝))","decl":"/-- The `ℤ`-linear map induced by precomposition of the projection\n    `π C (ord I · < o₂) → π C (ord I · < o₁)` for `o₁ ≤ o₂`. -/\n@[simps!]\nnoncomputable\ndef πs' {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂) :\n    LocallyConstant (π C (ord I · < o₁)) ℤ →ₗ[ℤ] LocallyConstant (π C (ord I · < o₂)) ℤ :=\n  LocallyConstant.comapₗ ℤ ⟨(ProjRestricts C (fun _ hh ↦ lt_of_lt_of_le hh h)),\n    (continuous_projRestricts _ _)⟩\n\n"}
{"name":"Profinite.NobelingProof.coe_πs'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\nf : LocallyConstant (↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₁)) Int\n⊢ Eq ((Profinite.NobelingProof.πs' C h) f).toFun (Function.comp f.toFun (Profinite.NobelingProof.ProjRestricts C ⋯))","decl":"theorem coe_πs' {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂) (f : LocallyConstant (π C (ord I · < o₁)) ℤ) :\n    (πs' C h f).toFun = f.toFun ∘ (ProjRestricts C (fun _ hh ↦ lt_of_lt_of_le hh h)) := by\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.injective_πs'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\n⊢ Function.Injective ⇑(Profinite.NobelingProof.πs' C h)","decl":"theorem injective_πs' {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂) : Function.Injective (πs' C h) :=\n  LocallyConstant.comap_injective ⟨_, (continuous_projRestricts _ _)⟩\n    (surjective_projRestricts _ fun _ hi ↦ lt_of_lt_of_le hi h)\n\n"}
{"name":"Profinite.NobelingProof.Products.lt_ord_of_lt","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl m : Profinite.NobelingProof.Products I\no : Ordinal.{u}\nh₁ : LT.lt m l\nh₂ : ∀ (i : I), Membership.mem (↑l) i → LT.lt (Profinite.NobelingProof.ord I i) o\ni : I\na✝ : Membership.mem (↑m) i\n⊢ LT.lt (Profinite.NobelingProof.ord I i) o","decl":"theorem lt_ord_of_lt {l m : Products I} {o : Ordinal} (h₁ : m < l)\n    (h₂ : ∀ i ∈ l.val, ord I i < o) : ∀ i ∈ m.val, ord I i < o :=\n  List.Sorted.lt_ord_of_lt (List.chain'_iff_pairwise.mp l.2) (List.chain'_iff_pairwise.mp m.2) h₁ h₂\n\n"}
{"name":"Profinite.NobelingProof.Products.eval_πs","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no : Ordinal.{u}\nhlt : ∀ (i : I), Membership.mem (↑l) i → LT.lt (Profinite.NobelingProof.ord I i) o\n⊢ Eq ((Profinite.NobelingProof.πs C o) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o) l)) (Profinite.NobelingProof.Products.eval C l)","decl":"theorem eval_πs {l : Products I} {o : Ordinal} (hlt : ∀ i ∈ l.val, ord I i < o) :\n    πs C o (l.eval (π C (ord I · < o))) = l.eval C := by\n  simpa only [← LocallyConstant.coe_inj] using evalFacProp C (ord I · < o) hlt\n\n"}
{"name":"Profinite.NobelingProof.Products.eval_πs'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\nhlt : ∀ (i : I), Membership.mem (↑l) i → LT.lt (Profinite.NobelingProof.ord I i) o₁\n⊢ Eq ((Profinite.NobelingProof.πs' C h) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₁) l)) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₂) l)","decl":"theorem eval_πs' {l : Products I} {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂)\n    (hlt : ∀ i ∈ l.val, ord I i < o₁) :\n    πs' C h (l.eval (π C (ord I · < o₁))) = l.eval (π C (ord I · < o₂)) := by\n  rw [← LocallyConstant.coe_inj, ← LocallyConstant.toFun_eq_coe]\n  exact evalFacProps C (fun (i : I) ↦ ord I i < o₁) (fun (i : I) ↦ ord I i < o₂) hlt\n    (fun _ hh ↦ lt_of_lt_of_le hh h)\n\n"}
{"name":"Profinite.NobelingProof.Products.eval_πs_image","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no : Ordinal.{u}\nhl : ∀ (i : I), Membership.mem (↑l) i → LT.lt (Profinite.NobelingProof.ord I i) o\n⊢ Eq (Set.image (Profinite.NobelingProof.Products.eval C) (setOf fun m => LT.lt m l)) (Set.image (⇑(Profinite.NobelingProof.πs C o)) (Set.image (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) (setOf fun m => LT.lt m l)))","decl":"theorem eval_πs_image {l : Products I} {o : Ordinal}\n    (hl : ∀ i ∈ l.val, ord I i < o) : eval C '' { m | m < l } =\n    (πs C o) '' (eval (π C (ord I · < o)) '' { m | m < l }) := by\n  ext f\n  simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and]\n  apply exists_congr; intro m\n  apply and_congr_right; intro hm\n  rw [eval_πs C (lt_ord_of_lt hm hl)]\n\n"}
{"name":"Profinite.NobelingProof.Products.eval_πs_image'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\nhl : ∀ (i : I), Membership.mem (↑l) i → LT.lt (Profinite.NobelingProof.ord I i) o₁\n⊢ Eq (Set.image (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₂)) (setOf fun m => LT.lt m l)) (Set.image (⇑(Profinite.NobelingProof.πs' C h)) (Set.image (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₁)) (setOf fun m => LT.lt m l)))","decl":"theorem eval_πs_image' {l : Products I} {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂)\n    (hl : ∀ i ∈ l.val, ord I i < o₁) : eval (π C (ord I · < o₂)) '' { m | m < l } =\n    (πs' C h) '' (eval (π C (ord I · < o₁)) '' { m | m < l }) := by\n  ext f\n  simp only [Set.mem_image, Set.mem_setOf_eq, exists_exists_and_eq_and]\n  apply exists_congr; intro m\n  apply and_congr_right; intro hm\n  rw [eval_πs' C h (lt_ord_of_lt hm hl)]\n\n"}
{"name":"Profinite.NobelingProof.Products.head_lt_ord_of_isGood","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝² : LinearOrder I\ninst✝¹ : WellFoundedLT I\ninst✝ : Inhabited I\nl : Profinite.NobelingProof.Products I\no : Ordinal.{u}\nh : Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o) l\nhn : Ne (↑l) List.nil\n⊢ LT.lt (Profinite.NobelingProof.ord I (↑l).head!) o","decl":"theorem head_lt_ord_of_isGood [Inhabited I] {l : Products I} {o : Ordinal}\n    (h : l.isGood (π C (ord I · < o))) (hn : l.val ≠ []) : ord I (l.val.head!) < o :=\n  prop_of_isGood C (ord I · < o) h l.val.head! (List.head!_mem_self hn)\n\n"}
{"name":"Profinite.NobelingProof.Products.isGood_mono","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nl : Profinite.NobelingProof.Products I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\nhl : Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₁) l\n⊢ Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o₂) l","decl":"/--\nIf `l` is good w.r.t. `π C (ord I · < o₁)` and `o₁ ≤ o₂`, then it is good w.r.t.\n`π C (ord I · < o₂)`\n-/\ntheorem isGood_mono {l : Products I} {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂)\n    (hl : l.isGood (π C (ord I · < o₁))) : l.isGood (π C (ord I · < o₂)) := by\n  intro hl'\n  apply hl\n  rwa [eval_πs_image' C h (prop_of_isGood  C _ hl), ← eval_πs' C h (prop_of_isGood  C _ hl),\n    Submodule.apply_mem_span_image_iff_mem_span (injective_πs' C h)] at hl'\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.range_equiv_smaller_toFun_bijective","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Function.Bijective (Profinite.NobelingProof.GoodProducts.range_equiv_smaller_toFun C o)","decl":"theorem range_equiv_smaller_toFun_bijective (o : Ordinal) :\n    Function.Bijective (range_equiv_smaller_toFun C o) := by\n  dsimp (config := { unfoldPartialApp := true }) [range_equiv_smaller_toFun]\n  refine ⟨fun a b hab ↦ ?_, fun ⟨a, b, hb⟩ ↦ ?_⟩\n  · ext1\n    simp only [Subtype.mk.injEq] at hab\n    exact injective_πs C o hab\n  · use ⟨b, hb.1⟩\n    simpa only [Subtype.mk.injEq] using hb.2\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.smaller_factorization","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Eq (Function.comp (fun p => ↑p) (Profinite.NobelingProof.GoodProducts.range_equiv_smaller C o).toFun) (Function.comp ⇑(Profinite.NobelingProof.πs C o) fun p => ↑p)","decl":"theorem smaller_factorization (o : Ordinal) :\n    (fun (p : smaller C o) ↦ p.1) ∘ (range_equiv_smaller C o).toFun =\n    (πs C o) ∘ (fun (p : range (π C (ord I · < o))) ↦ p.1) := by rfl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent_iff_smaller","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Iff (LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))) (LinearIndependent Int fun p => ↑p)","decl":"theorem linearIndependent_iff_smaller (o : Ordinal) :\n    LinearIndependent ℤ (GoodProducts.eval (π C (ord I · < o))) ↔\n    LinearIndependent ℤ (fun (p : smaller C o) ↦ p.1) := by\n  rw [GoodProducts.linearIndependent_iff_range,\n    ← LinearMap.linearIndependent_iff (πs C o)\n    (LinearMap.ker_eq_bot_of_injective (injective_πs _ _)), ← smaller_factorization C o]\n  exact linearIndependent_equiv _\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.smaller_mono","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no₁ o₂ : Ordinal.{u}\nh : LE.le o₁ o₂\n⊢ HasSubset.Subset (Profinite.NobelingProof.GoodProducts.smaller C o₁) (Profinite.NobelingProof.GoodProducts.smaller C o₂)","decl":"theorem smaller_mono {o₁ o₂ : Ordinal} (h : o₁ ≤ o₂) : smaller C o₁ ⊆ smaller C o₂ := by\n  rintro f ⟨g, hg, rfl⟩\n  simp only [smaller, Set.mem_image]\n  use πs' C h g\n  obtain ⟨⟨l, gl⟩, rfl⟩ := hg\n  refine ⟨?_, ?_⟩\n  · use ⟨l, Products.isGood_mono C h gl⟩\n    ext x\n    rw [eval, ← Products.eval_πs' _ h (Products.prop_of_isGood  C _ gl), eval]\n  · rw [← LocallyConstant.coe_inj, coe_πs C o₂, ← LocallyConstant.toFun_eq_coe, coe_πs',\n      Function.comp_assoc, projRestricts_comp_projRestrict C _, coe_πs]\n    rfl\n\n"}
{"name":"Profinite.NobelingProof.Products.limitOrdinal","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : o.IsLimit\nl : Profinite.NobelingProof.Products I\n⊢ Iff (Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o) l) (Exists fun o' => And (LT.lt o' o) (Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o') l))","decl":"theorem Products.limitOrdinal (l : Products I) : l.isGood (π C (ord I · < o)) ↔\n    ∃ (o' : Ordinal), o' < o ∧ l.isGood (π C (ord I · < o')) := by\n  refine ⟨fun h ↦ ?_, fun ⟨o', ⟨ho', hl⟩⟩ ↦ isGood_mono C (le_of_lt ho') hl⟩\n  use Finset.sup l.val.toFinset (fun a ↦ Order.succ (ord I a))\n  have hslt : Finset.sup l.val.toFinset (fun a ↦ Order.succ (ord I a)) < o := by\n    simp only [Finset.sup_lt_iff ho.pos, List.mem_toFinset]\n    exact fun b hb ↦ ho.succ_lt (prop_of_isGood C (ord I · < o) h b hb)\n  refine ⟨hslt, fun he ↦ h ?_⟩\n  have hlt : ∀ i ∈ l.val, ord I i < Finset.sup l.val.toFinset (fun a ↦ Order.succ (ord I a)) := by\n    intro i hi\n    simp only [Finset.lt_sup_iff, List.mem_toFinset, Order.lt_succ_iff]\n    exact ⟨i, hi, le_rfl⟩\n  rwa [eval_πs_image' C (le_of_lt hslt) hlt, ← eval_πs' C (le_of_lt hslt) hlt,\n    Submodule.apply_mem_span_image_iff_mem_span (injective_πs' C _)]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.union","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : o.IsLimit\nhsC : Profinite.NobelingProof.contained C o\n⊢ Eq (Profinite.NobelingProof.GoodProducts.range C) (Set.iUnion fun e => Profinite.NobelingProof.GoodProducts.smaller C ↑e)","decl":"theorem GoodProducts.union : range C = ⋃ (e : {o' // o' < o}), (smaller C e.val) := by\n  ext p\n  simp only [smaller, range, Set.mem_iUnion, Set.mem_image, Set.mem_range, Subtype.exists]\n  refine ⟨fun hp ↦ ?_, fun hp ↦ ?_⟩\n  · obtain ⟨l, hl, rfl⟩ := hp\n    rw [contained_eq_proj C o hsC, Products.limitOrdinal C ho] at hl\n    obtain ⟨o', ho'⟩ := hl\n    refine ⟨o', ho'.1, eval (π C (ord I · < o')) ⟨l, ho'.2⟩, ⟨l, ho'.2, rfl⟩, ?_⟩\n    exact Products.eval_πs C (Products.prop_of_isGood  C _ ho'.2)\n  · obtain ⟨o', h, _, ⟨l, hl, rfl⟩, rfl⟩ := hp\n    refine ⟨l, ?_, (Products.eval_πs C (Products.prop_of_isGood  C _ hl)).symm⟩\n    rw [contained_eq_proj C o hsC]\n    exact Products.isGood_mono C (le_of_lt h) hl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.range_equiv_factorization","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : o.IsLimit\nhsC : Profinite.NobelingProof.contained C o\n⊢ Eq (Function.comp (fun p => ↑p) (Profinite.NobelingProof.GoodProducts.range_equiv C ho hsC).toFun) fun p => ↑p","decl":"theorem GoodProducts.range_equiv_factorization :\n    (fun (p : ⋃ (e : {o' // o' < o}), (smaller C e.val)) ↦ p.1) ∘ (range_equiv C ho hsC).toFun =\n    (fun (p : range C) ↦ (p.1 : LocallyConstant C ℤ)) := rfl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent_iff_union_smaller","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : o.IsLimit\nhsC : Profinite.NobelingProof.contained C o\n⊢ Iff (LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval C)) (LinearIndependent Int fun p => ↑p)","decl":"theorem GoodProducts.linearIndependent_iff_union_smaller :\n    LinearIndependent ℤ (GoodProducts.eval C) ↔\n      LinearIndependent ℤ (fun (p : ⋃ (e : {o' // o' < o}), (smaller C e.val)) ↦ p.1) := by\n  rw [GoodProducts.linearIndependent_iff_range, ← range_equiv_factorization C ho hsC]\n  exact linearIndependent_equiv (range_equiv C ho hsC)\n\n"}
{"name":"Profinite.NobelingProof.isClosed_C0","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ IsClosed (Profinite.NobelingProof.C0 C ho)","decl":"include hC in\ntheorem isClosed_C0 : IsClosed (C0 C ho) := by\n  refine hC.inter ?_\n  have h : Continuous (fun (f : I → Bool) ↦ f (term I ho)) := continuous_apply (term I ho)\n  exact IsClosed.preimage h (t := {false}) (isClosed_discrete _)\n\n"}
{"name":"Profinite.NobelingProof.isClosed_C1","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ IsClosed (Profinite.NobelingProof.C1 C ho)","decl":"include hC in\ntheorem isClosed_C1 : IsClosed (C1 C ho) := by\n  refine hC.inter ?_\n  have h : Continuous (fun (f : I → Bool) ↦ f (term I ho)) := continuous_apply (term I ho)\n  exact IsClosed.preimage h (t := {true}) (isClosed_discrete _)\n\n"}
{"name":"Profinite.NobelingProof.contained_C1","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Profinite.NobelingProof.contained (Profinite.NobelingProof.π (Profinite.NobelingProof.C1 C ho) fun x => LT.lt (Profinite.NobelingProof.ord I x) o) o","decl":"theorem contained_C1 : contained (π (C1 C ho) (ord I · < o)) o :=\n  contained_proj _ _\n\n"}
{"name":"Profinite.NobelingProof.union_C0C1_eq","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Union.union (Profinite.NobelingProof.C0 C ho) (Profinite.NobelingProof.C1 C ho)) C","decl":"theorem union_C0C1_eq : (C0 C ho) ∪ (C1 C ho) = C := by\n  ext x\n  simp only [C0, C1, Set.mem_union, Set.mem_inter_iff, Set.mem_setOf_eq,\n    ← and_or_left, and_iff_left_iff_imp, Bool.dichotomy (x (term I ho)), implies_true]\n\n"}
{"name":"Profinite.NobelingProof.isClosed_C'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ IsClosed (Profinite.NobelingProof.C' C ho)","decl":"include hC in\ntheorem isClosed_C' : IsClosed (C' C ho) :=\n  IsClosed.inter (isClosed_C0 _ hC _) (isClosed_proj _ _ (isClosed_C1 _ hC _))\n\n"}
{"name":"Profinite.NobelingProof.contained_C'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Profinite.NobelingProof.contained (Profinite.NobelingProof.C' C ho) o","decl":"theorem contained_C' : contained (C' C ho) o := fun f hf i hi ↦ contained_C1 C ho f hf.2 i hi\n\n"}
{"name":"Profinite.NobelingProof.continuous_swapTrue","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ Continuous (Profinite.NobelingProof.SwapTrue o)","decl":"theorem continuous_swapTrue  :\n    Continuous (SwapTrue o : (I → Bool) → I → Bool) := by\n  dsimp (config := { unfoldPartialApp := true }) [SwapTrue]\n  apply continuous_pi\n  intro i\n  apply Continuous.comp'\n  · apply continuous_bot\n  · apply continuous_apply\n\n"}
{"name":"Profinite.NobelingProof.swapTrue_mem_C1","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nf : ↑(Profinite.NobelingProof.π (Profinite.NobelingProof.C1 C ho) fun x => LT.lt (Profinite.NobelingProof.ord I x) o)\n⊢ Membership.mem (Profinite.NobelingProof.C1 C ho) (Profinite.NobelingProof.SwapTrue o ↑f)","decl":"include hsC in\ntheorem swapTrue_mem_C1 (f : π (C1 C ho) (ord I · < o)) :\n    SwapTrue o f.val ∈ C1 C ho := by\n  obtain ⟨f, g, hg, rfl⟩ := f\n  convert hg\n  dsimp (config := { unfoldPartialApp := true }) [SwapTrue]\n  ext i\n  split_ifs with h\n  · rw [ord_term ho] at h\n    simpa only [← h] using hg.2.symm\n  · simp only [Proj, ite_eq_left_iff, not_lt, @eq_comm _ false, ← Bool.not_eq_true]\n    specialize hsC g hg.1 i\n    intro h'\n    contrapose! hsC\n    exact ⟨hsC, Order.succ_le_of_lt (h'.lt_of_ne' h)⟩\n\n"}
{"name":"Profinite.NobelingProof.continuous_CC'₀","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Continuous (Profinite.NobelingProof.CC'₀ C ho)","decl":"theorem continuous_CC'₀ : Continuous (CC'₀ C ho) := Continuous.subtype_mk continuous_subtype_val _\n\n"}
{"name":"Profinite.NobelingProof.continuous_CC'₁","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Continuous (Profinite.NobelingProof.CC'₁ C hsC ho)","decl":"theorem continuous_CC'₁ : Continuous (CC'₁ C hsC ho) :=\n  Continuous.subtype_mk (Continuous.comp (continuous_swapTrue o) continuous_subtype_val) _\n\n"}
{"name":"Profinite.NobelingProof.CC_comp_zero","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ny : LocallyConstant (↑(Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) Int\n⊢ Eq ((Profinite.NobelingProof.Linear_CC' C hsC ho) ((Profinite.NobelingProof.πs C o) y)) 0","decl":"theorem CC_comp_zero : ∀ y, (Linear_CC' C hsC ho) ((πs C o) y) = 0 := by\n  intro y\n  ext x\n  dsimp [Linear_CC', Linear_CC'₀, Linear_CC'₁, LocallyConstant.sub_apply]\n  simp only [Pi.zero_apply, sub_eq_zero]\n  congr 1\n  ext i\n  dsimp [CC'₀, CC'₁, ProjRestrict, Proj]\n  apply if_ctx_congr Iff.rfl _ (fun _ ↦ rfl)\n  simp only [SwapTrue, ite_eq_right_iff]\n  intro h₁ h₂\n  exact (h₁.ne h₂).elim\n\n"}
{"name":"Profinite.NobelingProof.C0_projOrd","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nx : I → Bool\nhx : Membership.mem (Profinite.NobelingProof.C0 C ho) x\n⊢ Eq (Profinite.NobelingProof.Proj (fun x => LT.lt (Profinite.NobelingProof.ord I x) o) x) x","decl":"include hsC in\ntheorem C0_projOrd {x : I → Bool} (hx : x ∈ C0 C ho) : Proj (ord I · < o) x = x := by\n  ext i\n  simp only [Proj, Set.mem_setOf, ite_eq_left_iff, not_lt]\n  intro hi\n  rw [le_iff_lt_or_eq] at hi\n  cases' hi with hi hi\n  · specialize hsC x hx.1 i\n    rw [← not_imp_not] at hsC\n    simp only [not_lt, Bool.not_eq_true, Order.succ_le_iff] at hsC\n    exact (hsC hi).symm\n  · simp only [C0, Set.mem_inter_iff, Set.mem_setOf_eq] at hx\n    rw [eq_comm, ord_term ho] at hi\n    rw [← hx.2, hi]\n\n"}
{"name":"Profinite.NobelingProof.C1_projOrd","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nx : I → Bool\nhx : Membership.mem (Profinite.NobelingProof.C1 C ho) x\n⊢ Eq (Profinite.NobelingProof.SwapTrue o (Profinite.NobelingProof.Proj (fun x => LT.lt (Profinite.NobelingProof.ord I x) o) x)) x","decl":"include hsC in\ntheorem C1_projOrd {x : I → Bool} (hx : x ∈ C1 C ho) : SwapTrue o (Proj (ord I · < o) x) = x := by\n  ext i\n  dsimp [SwapTrue, Proj]\n  split_ifs with hi h\n  · rw [ord_term ho] at hi\n    rw [← hx.2, hi]\n  · rfl\n  · simp only [not_lt] at h\n    have h' : o < ord I i := lt_of_le_of_ne h (Ne.symm hi)\n    specialize hsC x hx.1 i\n    rw [← not_imp_not] at hsC\n    simp only [not_lt, Bool.not_eq_true, Order.succ_le_iff] at hsC\n    exact (hsC h').symm\n\n"}
{"name":"Profinite.NobelingProof.CC_exact","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nf : LocallyConstant (↑C) Int\nhf : Eq ((Profinite.NobelingProof.Linear_CC' C hsC ho) f) 0\n⊢ Exists fun y => Eq ((Profinite.NobelingProof.πs C o) y) f","decl":"include hC in\nopen scoped Classical in\ntheorem CC_exact {f : LocallyConstant C ℤ} (hf : Linear_CC' C hsC ho f = 0) :\n    ∃ y, πs C o y = f := by\n  dsimp [Linear_CC', Linear_CC'₀, Linear_CC'₁] at hf\n  simp only [sub_eq_zero, ← LocallyConstant.coe_inj, LocallyConstant.coe_comap,\n    continuous_CC'₀, continuous_CC'₁] at hf\n  let C₀C : C0 C ho → C := fun x ↦ ⟨x.val, x.prop.1⟩\n  have h₀ : Continuous C₀C := Continuous.subtype_mk continuous_induced_dom _\n  let C₁C : π (C1 C ho) (ord I · < o) → C :=\n    fun x ↦ ⟨SwapTrue o x.val, (swapTrue_mem_C1 C hsC ho x).1⟩\n  have h₁ : Continuous C₁C := Continuous.subtype_mk\n    ((continuous_swapTrue o).comp continuous_subtype_val) _\n  refine ⟨LocallyConstant.piecewise' ?_ (isClosed_C0 C hC ho)\n      (isClosed_proj _ o (isClosed_C1 C hC ho)) (f.comap ⟨C₀C, h₀⟩) (f.comap ⟨C₁C, h₁⟩) ?_, ?_⟩\n  · rintro _ ⟨y, hyC, rfl⟩\n    simp only [Set.mem_union, Set.mem_setOf_eq, Set.mem_univ, iff_true]\n    rw [← union_C0C1_eq C ho] at hyC\n    refine hyC.imp (fun hyC ↦ ?_) (fun hyC ↦ ⟨y, hyC, rfl⟩)\n    rwa [C0_projOrd C hsC ho hyC]\n  · intro x hx\n    simpa only [h₀, h₁, LocallyConstant.coe_comap] using (congrFun hf ⟨x, hx⟩).symm\n  · ext ⟨x, hx⟩\n    rw [← union_C0C1_eq C ho] at hx\n    cases' hx with hx₀ hx₁\n    · have hx₀' : ProjRestrict C (ord I · < o) ⟨x, hx⟩ = x := by\n        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using C0_projOrd C hsC ho hx₀\n      simp only [C₀C, πs_apply_apply, hx₀', hx₀, LocallyConstant.piecewise'_apply_left,\n        LocallyConstant.coe_comap, ContinuousMap.coe_mk, Function.comp_apply]\n    · have hx₁' : (ProjRestrict C (ord I · < o) ⟨x, hx⟩).val ∈ π (C1 C ho) (ord I · < o) := by\n        simpa only [ProjRestrict, Set.MapsTo.val_restrict_apply] using ⟨x, hx₁, rfl⟩\n      simp only [C₁C, πs_apply_apply, continuous_projRestrict, LocallyConstant.coe_comap,\n        Function.comp_apply, hx₁', LocallyConstant.piecewise'_apply_right, h₁]\n      congr\n      simp only [ContinuousMap.coe_mk, Subtype.mk.injEq]\n      exact C1_projOrd C hsC ho hx₁\n\n"}
{"name":"Profinite.NobelingProof.succ_mono","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\n⊢ CategoryTheory.Mono (ModuleCat.ofHom (Profinite.NobelingProof.πs C o))","decl":"variable (o) in\ntheorem succ_mono : CategoryTheory.Mono (ModuleCat.ofHom (πs C o)) := by\n  rw [ModuleCat.mono_iff_injective]\n  exact injective_πs _ _\n\n"}
{"name":"Profinite.NobelingProof.succ_exact","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ (CategoryTheory.ShortComplex.mk (ModuleCat.ofHom (Profinite.NobelingProof.πs C o)) (ModuleCat.ofHom (Profinite.NobelingProof.Linear_CC' C hsC ho)) ⋯).Exact","decl":"include hC in\ntheorem succ_exact :\n    (ShortComplex.mk (ModuleCat.ofHom (πs C o)) (ModuleCat.ofHom (Linear_CC' C hsC ho))\n    (by ext : 2; apply CC_comp_zero)).Exact := by\n  rw [ShortComplex.moduleCat_exact_iff]\n  intro f\n  exact CC_exact C hC hsC ho\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.union_succ","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Profinite.NobelingProof.GoodProducts C) (Union.union (Profinite.NobelingProof.GoodProducts (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) (Profinite.NobelingProof.GoodProducts.MaxProducts C ho))","decl":"include hsC in\ntheorem union_succ : GoodProducts C = GoodProducts (π C (ord I · < o)) ∪ MaxProducts C ho := by\n  ext l\n  simp only [GoodProducts, MaxProducts, Set.mem_union, Set.mem_setOf_eq]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · by_cases hh : term I ho ∈ l.val\n    · exact Or.inr ⟨h, hh⟩\n    · left\n      intro he\n      apply h\n      have h' := Products.prop_of_isGood_of_contained C _ h hsC\n      simp only [Order.lt_succ_iff] at h'\n      simp only [not_imp_not] at hh\n      have hh' : ∀ a ∈ l.val, ord I a < o := by\n        intro a ha\n        refine (h' a ha).lt_of_ne ?_\n        rw [ne_eq, ord_term ho a]\n        rintro rfl\n        contradiction\n      rwa [Products.eval_πs_image C hh', ← Products.eval_πs C hh',\n        Submodule.apply_mem_span_image_iff_mem_span (injective_πs _ _)]\n  · refine h.elim (fun hh ↦ ?_) And.left\n    have := Products.isGood_mono C (Order.lt_succ o).le hh\n    rwa [contained_eq_proj C (Order.succ o) hsC]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.injective_sum_to","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Function.Injective (Profinite.NobelingProof.GoodProducts.sum_to C ho)","decl":"theorem injective_sum_to : Function.Injective (sum_to C ho) := by\n  refine Function.Injective.sum_elim Subtype.val_injective Subtype.val_injective\n    (fun ⟨a,ha⟩ ⟨b,hb⟩  ↦ (fun (hab : a = b) ↦ ?_))\n  rw [← hab] at hb\n  have ha' := Products.prop_of_isGood  C _ ha (term I ho) hb.2\n  simp only [ord_term_aux, lt_self_iff_false] at ha'\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.sum_to_range","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Set.range (Profinite.NobelingProof.GoodProducts.sum_to C ho)) (Union.union (Profinite.NobelingProof.GoodProducts (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)) (Profinite.NobelingProof.GoodProducts.MaxProducts C ho))","decl":"theorem sum_to_range :\n    Set.range (sum_to C ho) = GoodProducts (π C (ord I · < o)) ∪ MaxProducts C ho := by\n  have h : Set.range (sum_to C ho) = _ ∪ _ := Set.Sum.elim_range _ _; rw [h]; congr<;> ext l\n  · exact ⟨fun ⟨m,hm⟩ ↦ by rw [← hm]; exact m.prop, fun hl ↦ ⟨⟨l,hl⟩, rfl⟩⟩\n  · exact ⟨fun ⟨m,hm⟩ ↦ by rw [← hm]; exact m.prop, fun hl ↦ ⟨⟨l,hl⟩, rfl⟩⟩\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.sum_equiv_comp_eval_eq_elim","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Function.comp (Profinite.NobelingProof.GoodProducts.eval C) (Profinite.NobelingProof.GoodProducts.sum_equiv C hsC ho).toFun) (Sum.elim (fun l => Profinite.NobelingProof.Products.eval C ↑l) fun l => Profinite.NobelingProof.Products.eval C ↑l)","decl":"theorem sum_equiv_comp_eval_eq_elim : eval C ∘ (sum_equiv C hsC ho).toFun =\n    (Sum.elim (fun (l : GoodProducts (π C (ord I · < o))) ↦ Products.eval C l.1)\n    (fun (l : MaxProducts C ho) ↦ Products.eval C l.1)) := by\n  ext ⟨_,_⟩ <;> [rfl; rfl]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent_iff_sum","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Iff (LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval C)) (LinearIndependent Int (Profinite.NobelingProof.GoodProducts.SumEval C ho))","decl":"include hsC in\ntheorem linearIndependent_iff_sum :\n    LinearIndependent ℤ (eval C) ↔ LinearIndependent ℤ (SumEval C ho) := by\n  rw [← linearIndependent_equiv (sum_equiv C hsC ho), SumEval,\n    ← sum_equiv_comp_eval_eq_elim C hsC ho]\n  exact Iff.rfl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.span_sum","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Set.range (Profinite.NobelingProof.GoodProducts.eval C)) (Set.range (Sum.elim (fun l => Profinite.NobelingProof.Products.eval C ↑l) fun l => Profinite.NobelingProof.Products.eval C ↑l))","decl":"include hsC in\ntheorem span_sum : Set.range (eval C) = Set.range (Sum.elim\n    (fun (l : GoodProducts (π C (ord I · < o))) ↦ Products.eval C l.1)\n    (fun (l : MaxProducts C ho) ↦ Products.eval C l.1)) := by\n  rw [← sum_equiv_comp_eval_eq_elim C hsC ho, Equiv.toFun_as_coe,\n    EquivLike.range_comp (e := sum_equiv C hsC ho)]\n\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.square_commutes","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Function.comp (Profinite.NobelingProof.GoodProducts.SumEval C ho) Sum.inl) (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom (ModuleCat.ofHom (Profinite.NobelingProof.πs C o)))) (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o)))","decl":"theorem square_commutes : SumEval C ho ∘ Sum.inl =\n    ModuleCat.ofHom (πs C o) ∘ eval (π C (ord I · < o)) := by\n  ext l\n  dsimp [SumEval]\n  rw [← Products.eval_πs C (Products.prop_of_isGood  _ _ l.prop)]\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.swapTrue_eq_true","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nx : I → Bool\n⊢ Eq (Profinite.NobelingProof.SwapTrue o x (Profinite.NobelingProof.term I ho)) Bool.true","decl":"theorem swapTrue_eq_true (x : I → Bool) : SwapTrue o x (term I ho) = true := by\n  simp only [SwapTrue, ord_term_aux, ite_true]\n\n"}
{"name":"Profinite.NobelingProof.mem_C'_eq_false","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nx : I → Bool\na✝ : Membership.mem (Profinite.NobelingProof.C' C ho) x\n⊢ Eq (x (Profinite.NobelingProof.term I ho)) Bool.false","decl":"theorem mem_C'_eq_false : ∀ x, x ∈ C' C ho → x (term I ho) = false := by\n  rintro x ⟨_, y, _, rfl⟩\n  simp only [Proj, ord_term_aux, lt_self_iff_false, ite_false]\n\n"}
{"name":"Profinite.NobelingProof.Products.max_eq_o_cons_tail","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝² : LinearOrder I\ninst✝¹ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ninst✝ : Inhabited I\nl : Profinite.NobelingProof.Products I\nhl : Ne (↑l) List.nil\nhlh : Eq (↑l).head! (Profinite.NobelingProof.term I ho)\n⊢ Eq (↑l) (List.cons (Profinite.NobelingProof.term I ho) ↑l.Tail)","decl":"theorem Products.max_eq_o_cons_tail [Inhabited I] (l : Products I) (hl : l.val ≠ [])\n    (hlh : l.val.head! = term I ho) : l.val = term I ho :: l.Tail.val := by\n  rw [← List.cons_head!_tail hl, hlh]\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.Products.max_eq_o_cons_tail'","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝² : LinearOrder I\ninst✝¹ : WellFoundedLT I\no : Ordinal.{u}\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ninst✝ : Inhabited I\nl : Profinite.NobelingProof.Products I\nhl : Ne (↑l) List.nil\nhlh : Eq (↑l).head! (Profinite.NobelingProof.term I ho)\nhlc : List.Chain' (fun x1 x2 => GT.gt x1 x2) (List.cons (Profinite.NobelingProof.term I ho) ↑l.Tail)\n⊢ Eq l ⟨List.cons (Profinite.NobelingProof.term I ho) ↑l.Tail, hlc⟩","decl":"theorem Products.max_eq_o_cons_tail' [Inhabited I] (l : Products I) (hl : l.val ≠ [])\n    (hlh : l.val.head! = term I ho) (hlc : List.Chain' (·>·) (term I ho :: l.Tail.val)) :\n    l = ⟨term I ho :: l.Tail.val, hlc⟩ := by\n  simp_rw [← max_eq_o_cons_tail ho l hl hlh]\n  rfl\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.head!_eq_o_of_maxProducts","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝² : LinearOrder I\ninst✝¹ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ninst✝ : Inhabited I\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\n⊢ Eq (↑↑l).head! (Profinite.NobelingProof.term I ho)","decl":"include hsC in\ntheorem GoodProducts.head!_eq_o_of_maxProducts [Inhabited I] (l : ↑(MaxProducts C ho)) :\n    l.val.val.head! = term I ho := by\n  rw [eq_comm, ← ord_term ho]\n  have hm := l.prop.2\n  have := Products.prop_of_isGood_of_contained C _ l.prop.1 hsC l.val.val.head!\n    (List.head!_mem_self (List.ne_nil_of_mem hm))\n  simp only [Order.lt_succ_iff] at this\n  refine eq_of_le_of_not_lt this (not_lt.mpr ?_)\n  have h : ord I (term I ho) ≤ ord I l.val.val.head! := by\n    simp only [← ord_term_aux, ord, Ordinal.typein_le_typein, not_lt]\n    exact Products.rel_head!_of_mem hm\n  rwa [ord_term_aux] at h\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.max_eq_o_cons_tail","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\n⊢ Eq (↑↑l) (List.cons (Profinite.NobelingProof.term I ho) ↑(↑l).Tail)","decl":"include hsC in\ntheorem GoodProducts.max_eq_o_cons_tail (l : MaxProducts C ho) :\n    l.val.val = (term I ho) :: l.val.Tail.val :=\n  have : Inhabited I := ⟨term I ho⟩\n  Products.max_eq_o_cons_tail ho l.val (List.ne_nil_of_mem l.prop.2)\n    (head!_eq_o_of_maxProducts _ hsC ho l)\n\n"}
{"name":"Profinite.NobelingProof.Products.evalCons","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u_1\ninst✝ : LinearOrder I\nC : Set (I → Bool)\nl : List I\na : I\nhla : List.Chain' (fun x1 x2 => GT.gt x1 x2) (List.cons a l)\n⊢ Eq (Profinite.NobelingProof.Products.eval C ⟨List.cons a l, hla⟩) (HMul.hMul (Profinite.NobelingProof.e C a) (Profinite.NobelingProof.Products.eval C ⟨l, ⋯⟩))","decl":"theorem Products.evalCons {I} [LinearOrder I] {C : Set (I → Bool)} {l : List I} {a : I}\n    (hla : (a::l).Chain' (·>·)) : Products.eval C ⟨a::l,hla⟩ =\n    (e C a) * Products.eval C ⟨l,List.Chain'.sublist hla (List.tail_sublist (a::l))⟩ := by\n  simp only [eval.eq_1, List.map, List.prod_cons]\n\n"}
{"name":"Profinite.NobelingProof.Products.max_eq_eval","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝² : LinearOrder I\ninst✝¹ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\ninst✝ : Inhabited I\nl : Profinite.NobelingProof.Products I\nhl : Ne (↑l) List.nil\nhlh : Eq (↑l).head! (Profinite.NobelingProof.term I ho)\n⊢ Eq ((Profinite.NobelingProof.Linear_CC' C hsC ho) (Profinite.NobelingProof.Products.eval C l)) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.C' C ho) l.Tail)","decl":"theorem Products.max_eq_eval [Inhabited I] (l : Products I) (hl : l.val ≠ [])\n    (hlh : l.val.head! = term I ho) :\n    Linear_CC' C hsC ho (l.eval C) = l.Tail.eval (C' C ho) := by\n  have hlc : ((term I ho) :: l.Tail.val).Chain' (·>·) := by\n    rw [← max_eq_o_cons_tail ho l hl hlh]; exact l.prop\n  rw [max_eq_o_cons_tail' ho l hl hlh hlc, Products.evalCons]\n  ext x\n  simp only [Linear_CC', Linear_CC'₁, LocallyConstant.comapₗ, Linear_CC'₀, Subtype.coe_eta,\n    LinearMap.sub_apply, LinearMap.coe_mk, AddHom.coe_mk, LocallyConstant.sub_apply,\n    LocallyConstant.coe_comap, LocallyConstant.coe_mul, ContinuousMap.coe_mk, Function.comp_apply,\n    Pi.mul_apply]\n  rw [CC'₁, CC'₀, Products.eval_eq, Products.eval_eq, Products.eval_eq]\n  simp only [mul_ite, mul_one, mul_zero]\n  have hi' : ∀ i, i ∈ l.Tail.val → (x.val i = SwapTrue o x.val i) := by\n    intro i hi\n    simp only [SwapTrue, @eq_comm _ (x.val i), ite_eq_right_iff, ord_term ho]\n    rintro rfl\n    exact ((List.Chain.rel hlc hi).ne rfl).elim\n  have H : (∀ i, i ∈ l.Tail.val → (x.val i = true)) =\n      (∀ i, i ∈ l.Tail.val → (SwapTrue o x.val i = true)) := by\n    apply forall_congr; intro i; apply forall_congr; intro hi; rw [hi' i hi]\n  simp only [H]\n  split_ifs with h₁ h₂ h₃ <;> try (dsimp [e])\n  · rw [if_pos (swapTrue_eq_true _ _), if_neg]\n    · rfl\n    · simp [mem_C'_eq_false C ho x x.prop, Bool.coe_false]\n  · push_neg at h₂; obtain ⟨i, hi⟩ := h₂; exfalso; rw [hi' i hi.1] at hi; exact hi.2 (h₁ i hi.1)\n  · push_neg at h₁; obtain ⟨i, hi⟩ := h₁; exfalso; rw [← hi' i hi.1] at hi; exact hi.2 (h₃ i hi.1)\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.max_eq_eval","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\n⊢ Eq ((Profinite.NobelingProof.Linear_CC' C hsC ho) (Profinite.NobelingProof.Products.eval C ↑l)) (Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.C' C ho) (↑l).Tail)","decl":"theorem max_eq_eval (l : MaxProducts C ho) :\n    Linear_CC' C hsC ho (l.val.eval C) = l.val.Tail.eval (C' C ho) :=\n  have : Inhabited I := ⟨term I ho⟩\n  Products.max_eq_eval _ _ _ _ (List.ne_nil_of_mem l.prop.2)\n    (head!_eq_o_of_maxProducts _ hsC ho l)\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.max_eq_eval_unapply","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\n⊢ Eq (Function.comp ⇑(Profinite.NobelingProof.Linear_CC' C hsC ho) fun l => Profinite.NobelingProof.Products.eval C ↑l) fun l => Profinite.NobelingProof.Products.eval (Profinite.NobelingProof.C' C ho) (↑l).Tail","decl":"theorem max_eq_eval_unapply :\n    (Linear_CC' C hsC ho) ∘ (fun (l : MaxProducts C ho) ↦ Products.eval C l.val) =\n    (fun l ↦ l.val.Tail.eval (C' C ho)) := by\n  ext1 l\n  exact max_eq_eval _ _ _ _\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.chain'_cons_of_lt","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\nq : Profinite.NobelingProof.Products I\nhq : LT.lt q (↑l).Tail\n⊢ List.Chain' (fun x x_1 => GT.gt x x_1) (List.cons (Profinite.NobelingProof.term I ho) ↑q)","decl":"include hsC in\ntheorem chain'_cons_of_lt (l : MaxProducts C ho)\n    (q : Products I) (hq : q < l.val.Tail) :\n    List.Chain' (fun x x_1 ↦ x > x_1) (term I ho :: q.val) := by\n  have : Inhabited I := ⟨term I ho⟩\n  rw [List.chain'_iff_pairwise]\n  simp only [gt_iff_lt, List.pairwise_cons]\n  refine ⟨fun a ha ↦ lt_of_le_of_lt (Products.rel_head!_of_mem ha) ?_,\n    List.chain'_iff_pairwise.mp q.prop⟩\n  refine lt_of_le_of_lt (Products.head!_le_of_lt hq (q.val.ne_nil_of_mem ha)) ?_\n  by_cases hM : l.val.Tail.val = []\n  · rw [Products.lt_iff_lex_lt, hM] at hq\n    simp only [List.not_lex_nil] at hq\n  · have := l.val.prop\n    rw [max_eq_o_cons_tail C hsC ho l, List.chain'_iff_pairwise] at this\n    exact List.rel_of_pairwise_cons this (List.head!_mem_self hM)\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.good_lt_maxProducts","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nq : ↑(Profinite.NobelingProof.GoodProducts (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\n⊢ List.Lex (fun x1 x2 => LT.lt x1 x2) ↑↑q ↑↑l","decl":"include hsC in\ntheorem good_lt_maxProducts (q : GoodProducts (π C (ord I · < o)))\n    (l : MaxProducts C ho) : List.Lex (·<·) q.val.val l.val.val := by\n  have : Inhabited I := ⟨term I ho⟩\n  by_cases h : q.val.val = []\n  · rw [h, max_eq_o_cons_tail C hsC ho l]\n    exact List.Lex.nil\n  · rw [← List.cons_head!_tail h, max_eq_o_cons_tail C hsC ho l]\n    apply List.Lex.rel\n    rw [← Ordinal.typein_lt_typein (·<·)]\n    simp only [term, Ordinal.typein_enum]\n    exact Products.prop_of_isGood C _ q.prop q.val.val.head! (List.head!_mem_self h)\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.maxTail_isGood","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nl : ↑(Profinite.NobelingProof.GoodProducts.MaxProducts C ho)\nh₁ : LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))))\n⊢ Profinite.NobelingProof.Products.isGood (Profinite.NobelingProof.C' C ho) (↑l).Tail","decl":"include hC hsC in\n/--\nRemoving the leading `o` from a term of `MaxProducts C` yields a list which `isGood` with respect to\n`C'`.\n-/\ntheorem maxTail_isGood (l : MaxProducts C ho)\n    (h₁ : ⊤ ≤ Submodule.span ℤ (Set.range (eval (π C (ord I · < o))))) :\n    l.val.Tail.isGood (C' C ho) := by\n  have : Inhabited I := ⟨term I ho⟩\n  -- Write `l.Tail` as a linear combination of smaller products:\n  intro h\n  rw [Finsupp.mem_span_image_iff_linearCombination, ← max_eq_eval C hsC ho] at h\n  obtain ⟨m, ⟨hmmem, hmsum⟩⟩ := h\n  rw [Finsupp.linearCombination_apply] at hmsum\n\n  -- Write the image of `l` under `Linear_CC'` as `Linear_CC'` applied to the linear combination\n  -- above, with leading `term I ho`'s added to each term:\n  have : (Linear_CC' C hsC ho) (l.val.eval C) = (Linear_CC' C hsC ho)\n      (Finsupp.sum m fun i a ↦ a • ((term I ho :: i.1).map (e C)).prod) := by\n    rw [← hmsum]\n    simp only [map_finsupp_sum]\n    apply Finsupp.sum_congr\n    intro q hq\n    rw [LinearMap.map_smul]\n    rw [Finsupp.mem_supported] at hmmem\n    have hx'' : q < l.val.Tail := hmmem hq\n    have : ∃ (p : Products I), p.val ≠ [] ∧ p.val.head! = term I ho ∧ q = p.Tail :=\n      ⟨⟨term I ho :: q.val, chain'_cons_of_lt C hsC ho l q hx''⟩,\n        ⟨List.cons_ne_nil _ _, by simp only [List.head!_cons],\n        by simp only [Products.Tail, List.tail_cons, Subtype.coe_eta]⟩⟩\n    obtain ⟨p, hp⟩ := this\n    rw [hp.2.2, ← Products.max_eq_eval C hsC ho p hp.1 hp.2.1]\n    dsimp [Products.eval]\n    rw [Products.max_eq_o_cons_tail ho p hp.1 hp.2.1]\n    rfl\n  have hse := succ_exact C hC hsC ho\n  rw [ShortComplex.moduleCat_exact_iff_range_eq_ker] at hse\n  dsimp [ModuleCat.ofHom] at hse\n\n  -- Rewrite `this` using exact sequence manipulations to conclude that a term is in the range of\n  -- the linear map `πs`:\n  rw [← LinearMap.sub_mem_ker_iff, ← hse] at this\n  obtain ⟨(n : LocallyConstant (π C (ord I · < o)) ℤ), hn⟩ := this\n  rw [eq_sub_iff_add_eq] at hn\n  have hn' := h₁ (Submodule.mem_top : n ∈ ⊤)\n  rw [Finsupp.mem_span_range_iff_exists_finsupp] at hn'\n  obtain ⟨w,hc⟩ := hn'\n  rw [← hc, map_finsupp_sum] at hn\n  apply l.prop.1\n  rw [← hn]\n\n  -- Now we just need to prove that a sum of two terms belongs to a span:\n  apply Submodule.add_mem\n  · apply Submodule.finsupp_sum_mem\n    intro q _\n    rw [LinearMap.map_smul]\n    apply Submodule.smul_mem\n    apply Submodule.subset_span\n    dsimp only [eval]\n    rw [Products.eval_πs C (Products.prop_of_isGood _ _ q.prop)]\n    refine ⟨q.val, ⟨?_, rfl⟩⟩\n    simp only [Products.lt_iff_lex_lt, Set.mem_setOf_eq]\n    exact good_lt_maxProducts C hsC ho q l\n  · apply Submodule.finsupp_sum_mem\n    intro q hq\n    apply Submodule.smul_mem\n    apply Submodule.subset_span\n    rw [Finsupp.mem_supported] at hmmem\n    rw [← Finsupp.mem_support_iff] at hq\n    refine ⟨⟨term I ho :: q.val, chain'_cons_of_lt C hsC ho l q (hmmem hq)⟩, ⟨?_, rfl⟩⟩\n    simp only [Products.lt_iff_lex_lt, Set.mem_setOf_eq]\n    rw [max_eq_o_cons_tail C hsC ho l]\n    exact List.Lex.cons ((Products.lt_iff_lex_lt q l.val.Tail).mp (hmmem hq))\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.maxToGood_injective","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nh₁ : LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))))\n⊢ Function.Injective (Profinite.NobelingProof.GoodProducts.MaxToGood C hC hsC ho h₁)","decl":"theorem maxToGood_injective\n    (h₁ : ⊤ ≤ Submodule.span ℤ (Set.range (eval (π C (ord I · < o))))) :\n    (MaxToGood C hC hsC ho h₁).Injective := by\n  intro m n h\n  apply Subtype.ext ∘ Subtype.ext\n  rw [Subtype.ext_iff] at h\n  dsimp [MaxToGood] at h\n  rw [max_eq_o_cons_tail C hsC ho m, max_eq_o_cons_tail C hsC ho n, h]\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent_comp_of_eval","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nhC : IsClosed C\nhsC : Profinite.NobelingProof.contained C (Order.succ o)\nho : LT.lt o (Ordinal.type fun x1 x2 => LT.lt x1 x2)\nh₁ : LE.le Top.top (Submodule.span Int (Set.range (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.π C fun x => LT.lt (Profinite.NobelingProof.ord I x) o))))\na✝ : LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval (Profinite.NobelingProof.C' C ho))\n⊢ LinearIndependent Int (Function.comp (⇑(CategoryTheory.ConcreteCategory.hom (ModuleCat.ofHom (Profinite.NobelingProof.Linear_CC' C hsC ho)))) (Function.comp (Profinite.NobelingProof.GoodProducts.SumEval C ho) Sum.inr))","decl":"include hC in\ntheorem linearIndependent_comp_of_eval\n    (h₁ : ⊤ ≤ Submodule.span ℤ (Set.range (eval (π C (ord I · < o))))) :\n    LinearIndependent ℤ (eval (C' C ho)) →\n    LinearIndependent ℤ (ModuleCat.ofHom (Linear_CC' C hsC ho) ∘ SumEval C ho ∘ Sum.inr) := by\n  dsimp [SumEval, ModuleCat.ofHom]\n  rw [max_eq_eval_unapply C hsC ho]\n  intro h\n  let f := MaxToGood C hC hsC ho h₁\n  have hf : f.Injective := maxToGood_injective C hC hsC ho h₁\n  have hh : (fun l ↦ Products.eval (C' C ho) l.val.Tail) = eval (C' C ho) ∘ f := rfl\n  rw [hh]\n  exact h.comp f hf\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.P0","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\n⊢ Profinite.NobelingProof.P I 0","decl":"theorem GoodProducts.P0 : P I 0 := fun _ C _ hsC ↦ by\n  have : C ⊆ {(fun _ ↦ false)} := fun c hc ↦ by\n    ext x; exact Bool.eq_false_iff.mpr (fun ht ↦ (Ordinal.not_lt_zero (ord I x)) (hsC c hc x ht))\n  rw [Set.subset_singleton_iff_eq] at this\n  cases this\n  · subst C\n    exact linearIndependentEmpty\n  · subst C\n    exact linearIndependentSingleton\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.Plimit","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\no : Ordinal.{u}\nho : o.IsLimit\na✝ : ∀ (o' : Ordinal.{u}), LT.lt o' o → Profinite.NobelingProof.P I o'\n⊢ Profinite.NobelingProof.P I o","decl":"theorem GoodProducts.Plimit (o : Ordinal) (ho : Ordinal.IsLimit o) :\n    (∀ (o' : Ordinal), o' < o → P I o') → P I o := by\n  intro h hho C hC hsC\n  rw [linearIndependent_iff_union_smaller C ho hsC]\n  exact linearIndependent_iUnion_of_directed\n    (Monotone.directed_le fun _ _ h ↦ GoodProducts.smaller_mono C h) fun ⟨o', ho'⟩ ↦\n    (linearIndependent_iff_smaller _ _).mp (h o' ho' (le_of_lt (lt_of_lt_of_le ho' hho))\n    (π C (ord I · < o')) (isClosed_proj _ _ hC) (contained_proj _ _))\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependentAux","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nμ : Ordinal.{u}\n⊢ Profinite.NobelingProof.P I μ","decl":"theorem GoodProducts.linearIndependentAux (μ : Ordinal) : P I μ := by\n  refine Ordinal.limitRecOn μ P0 (fun o h ho C hC hsC ↦ ?_)\n      (fun o ho h ↦ (GoodProducts.Plimit o ho (fun o' ho' ↦ (h o' ho'))))\n  have ho' : o < Ordinal.type (·<· : I → I → Prop) :=\n    lt_of_lt_of_le (Order.lt_succ _) ho\n  rw [linearIndependent_iff_sum C hsC ho']\n  refine ModuleCat.linearIndependent_leftExact (succ_exact C hC hsC ho') ?_ ?_ (succ_mono C o)\n    (square_commutes C ho')\n  · exact h (le_of_lt ho') (π C (ord I · < o)) (isClosed_proj C o hC) (contained_proj C o)\n  · exact linearIndependent_comp_of_eval C hC hsC ho' (span (π C (ord I · < o))\n      (isClosed_proj C o hC)) (h (le_of_lt ho') (C' C ho') (isClosed_C' C hC ho')\n      (contained_C' C ho'))\n\n"}
{"name":"Profinite.NobelingProof.GoodProducts.linearIndependent","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\nC : Set (I → Bool)\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nhC : IsClosed C\n⊢ LinearIndependent Int (Profinite.NobelingProof.GoodProducts.eval C)","decl":"theorem GoodProducts.linearIndependent (hC : IsClosed C) :\n    LinearIndependent ℤ (GoodProducts.eval C) :=\n  GoodProducts.linearIndependentAux (Ordinal.type (·<· : I → I → Prop)) (le_refl _)\n    C hC (fun _ _ _ _ ↦ Ordinal.typein_lt_type _ _)\n\n"}
{"name":"Profinite.NobelingProof.Nobeling_aux","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"I : Type u\ninst✝¹ : LinearOrder I\ninst✝ : WellFoundedLT I\nS : Profinite\nι : ↑S.toTop → I → Bool\nhι : Topology.IsClosedEmbedding ι\n⊢ Module.Free Int (LocallyConstant (↑S.toTop) Int)","decl":"/--\nGiven a profinite set `S` and a closed embedding `S → (I → Bool)`, the `ℤ`-module\n`LocallyConstant C ℤ` is free.\n-/\ntheorem Nobeling_aux : Module.Free ℤ (LocallyConstant S ℤ) := Module.Free.of_equiv'\n  (Module.Free.of_basis <| GoodProducts.Basis _ hι.isClosed_range) (LocallyConstant.congrLeftₗ ℤ\n    (.ofIsEmbedding ι hι.isEmbedding)).symm\n\n"}
{"name":"Profinite.Nobeling.isClosedEmbedding","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"S : Profinite\n⊢ Topology.IsClosedEmbedding (Profinite.Nobeling.ι S)","decl":"open scoped Classical in\n/-- The map `Nobeling.ι` is a closed embedding. -/\ntheorem Nobeling.isClosedEmbedding : IsClosedEmbedding (Nobeling.ι S) := by\n  apply Continuous.isClosedEmbedding\n  · dsimp (config := { unfoldPartialApp := true }) [ι]\n    refine continuous_pi ?_\n    intro C\n    rw [← IsLocallyConstant.iff_continuous]\n    refine ((IsLocallyConstant.tfae _).out 0 3).mpr ?_\n    rintro ⟨⟩\n    · refine IsClopen.isOpen (isClopen_compl_iff.mp ?_)\n      convert C.2\n      ext x\n      simp only [Set.mem_compl_iff, Set.mem_preimage, Set.mem_singleton_iff,\n        decide_eq_false_iff_not, not_not]\n    · refine IsClopen.isOpen ?_\n      convert C.2\n      ext x\n      simp only [Set.mem_preimage, Set.mem_singleton_iff, decide_eq_true_eq]\n  · intro a b h\n    by_contra hn\n    obtain ⟨C, hC, hh⟩ := exists_isClopen_of_totally_separated hn\n    apply hh.2 ∘ of_decide_eq_true\n    dsimp (config := { unfoldPartialApp := true }) [ι] at h\n    rw [← congr_fun h ⟨C, hC⟩]\n    exact decide_eq_true hh.1\n\n"}
{"name":"Profinite.Nobeling.embedding","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"S : Profinite\n⊢ Topology.IsClosedEmbedding (Profinite.Nobeling.ι S)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Nobeling.embedding := Nobeling.isClosedEmbedding\n\n"}
{"name":"LocallyConstant.freeOfProfinite","module":"Mathlib.Topology.Category.Profinite.Nobeling","initialProofState":"S : Profinite\n⊢ Module.Free Int (LocallyConstant (↑S.toTop) Int)","decl":"/-- Nöbeling's theorem: the `ℤ`-module `LocallyConstant S ℤ` is free for every `S : Profinite` -/\ninstance LocallyConstant.freeOfProfinite (S : Profinite.{u}) :\n    Module.Free ℤ (LocallyConstant S ℤ) := by\n  obtain ⟨_, _⟩ := exists_wellOrder {C : Set S // IsClopen C}\n  exact @Nobeling_aux {C : Set S // IsClopen C} _ _ S (Nobeling.ι S) (Nobeling.isClosedEmbedding S)\n\n"}
