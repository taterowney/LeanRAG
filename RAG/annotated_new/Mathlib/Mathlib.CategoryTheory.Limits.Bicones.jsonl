{"name":"CategoryTheory.Bicone.diagram.inj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\nval✝ val : J\nx✝ : Eq (CategoryTheory.Bicone.diagram val✝) (CategoryTheory.Bicone.diagram val)\n⊢ Eq val✝ val","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type u₁)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CategoryTheory.Bicone.right) 1","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type u₁)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.diagram.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : SizeOf J\nval : J\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Bicone.diagram val)) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type u₁)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.diagram.injEq","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\nval✝ val : J\n⊢ Eq (Eq (CategoryTheory.Bicone.diagram val✝) (CategoryTheory.Bicone.diagram val)) (Eq val✝ val)","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type u₁)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CategoryTheory.Bicone.left) 1","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type u₁)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : SizeOf J\nj k : J\nf : Quiver.Hom j k\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.diagram f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf j)) (SizeOf.sizeOf k)) (SizeOf.sizeOf f))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.right_id.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CategoryTheory.BiconeHom.right_id) 1","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.inj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj k : J\nf✝ f : Quiver.Hom j k\nx✝ : Eq (CategoryTheory.BiconeHom.diagram f✝) (CategoryTheory.BiconeHom.diagram f)\n⊢ Eq f✝ f","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.injEq","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj k : J\nf✝ f : Quiver.Hom j k\n⊢ Eq (Eq (CategoryTheory.BiconeHom.diagram f✝) (CategoryTheory.BiconeHom.diagram f)) (Eq f✝ f)","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.left_id.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CategoryTheory.BiconeHom.left_id) 1","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : SizeOf J\nj : J\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.left j)) (HAdd.hAdd 1 (SizeOf.sizeOf j))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\ninst✝ : SizeOf J\nj : J\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.right j)) (HAdd.hAdd 1 (SizeOf.sizeOf j))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J → Bicone J → Type max u₁ v₁\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j ⟶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_Hom","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\na✝¹ a✝ : CategoryTheory.Bicone J\n⊢ Eq (Quiver.Hom a✝¹ a✝) (CategoryTheory.BiconeHom J a✝¹ a✝)","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (𝟙 k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    · exact g\n    · exact g\n    · cases g\n      apply BiconeHom.left\n    · cases g\n      apply BiconeHom.right\n    · rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f ≫ g)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_comp","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nX✝ Y✝ Z✝ : CategoryTheory.Bicone J\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq X✝ a → Eq Y✝ a_1 → HEq f x → Quiver.Hom X✝ Z✝) f (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ CategoryTheory.Bicone.left → HEq f CategoryTheory.BiconeHom.left_id → Quiver.Hom X Z✝) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Z✝ → (f : Quiver.Hom CategoryTheory.Bicone.left Y) → HEq f CategoryTheory.BiconeHom.left_id → Quiver.Hom CategoryTheory.Bicone.left Z✝) (fun g f h => g) ⋯ g f) ⋯ f) (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ CategoryTheory.Bicone.right → HEq f CategoryTheory.BiconeHom.right_id → Quiver.Hom X Z✝) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Z✝ → (f : Quiver.Hom CategoryTheory.Bicone.right Y) → HEq f CategoryTheory.BiconeHom.right_id → Quiver.Hom CategoryTheory.Bicone.right Z✝) (fun g f h => g) ⋯ g f) ⋯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram j) → HEq f (CategoryTheory.BiconeHom.left j) → Quiver.Hom X Z✝) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Z✝ → (f : Quiver.Hom CategoryTheory.Bicone.left Y) → HEq f (CategoryTheory.BiconeHom.left j) → Quiver.Hom CategoryTheory.Bicone.left Z✝) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 t => Eq (CategoryTheory.Bicone.diagram j) a → Eq Z✝ a_1 → HEq g t → Quiver.Hom CategoryTheory.Bicone.left Z✝) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k} f h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (f : Quiver.Hom j_2 k) → Eq Z✝ (CategoryTheory.Bicone.diagram k) → HEq g (CategoryTheory.BiconeHom.diagram f) → Quiver.Hom CategoryTheory.Bicone.left Z✝) (fun f h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) → HEq g (CategoryTheory.BiconeHom.diagram f) → Quiver.Hom CategoryTheory.Bicone.left Z) (fun g h => CategoryTheory.BiconeHom.left k) ⋯ g) val_eq f) ⋯ ⋯ ⋯) ⋯ g f) ⋯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram j) → HEq f (CategoryTheory.BiconeHom.right j) → Quiver.Hom X Z✝) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Z✝ → (f : Quiver.Hom CategoryTheory.Bicone.right Y) → HEq f (CategoryTheory.BiconeHom.right j) → Quiver.Hom CategoryTheory.Bicone.right Z✝) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 t => Eq (CategoryTheory.Bicone.diagram j) a → Eq Z✝ a_1 → HEq g t → Quiver.Hom CategoryTheory.Bicone.right Z✝) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k} f h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (f : Quiver.Hom j_2 k) → Eq Z✝ (CategoryTheory.Bicone.diagram k) → HEq g (CategoryTheory.BiconeHom.diagram f) → Quiver.Hom CategoryTheory.Bicone.right Z✝) (fun f h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) → HEq g (CategoryTheory.BiconeHom.diagram f) → Quiver.Hom CategoryTheory.Bicone.right Z) (fun g h => CategoryTheory.BiconeHom.right k) ⋯ g) val_eq f) ⋯ ⋯ ⋯) ⋯ g f) ⋯ f) (fun {j k} f_1 h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram k) → HEq f (CategoryTheory.BiconeHom.diagram f_1) → Quiver.Hom X Z✝) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Z✝ → (f : Quiver.Hom (CategoryTheory.Bicone.diagram j) Y) → HEq f (CategoryTheory.BiconeHom.diagram f_1) → Quiver.Hom (CategoryTheory.Bicone.diagram j) Z✝) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq (CategoryTheory.Bicone.diagram k) a → Eq Z✝ a_1 → HEq g x → Quiver.Hom (CategoryTheory.Bicone.diagram j) Z✝) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k_1} g_1 h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (g_2 : Quiver.Hom j_2 k_1) → Eq Z✝ (CategoryTheory.Bicone.diagram k_1) → HEq g (CategoryTheory.BiconeHom.diagram g_2) → Quiver.Hom (CategoryTheory.Bicone.diagram j) Z✝) (fun g_2 h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram k) Z) → HEq g (CategoryTheory.BiconeHom.diagram g_2) → Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) (fun g h => CategoryTheory.BiconeHom.diagram (CategoryTheory.CategoryStruct.comp f_1 g_2)) ⋯ g) val_eq g_1) ⋯ ⋯ ⋯) ⋯ g f) ⋯ f) ⋯ ⋯ ⋯)","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (𝟙 k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    · exact g\n    · exact g\n    · cases g\n      apply BiconeHom.left\n    · cases g\n      apply BiconeHom.right\n    · rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f ≫ g)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_id","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} J\nj : CategoryTheory.Bicone J\n⊢ Eq (CategoryTheory.CategoryStruct.id j) (CategoryTheory.Bicone.casesOn j CategoryTheory.BiconeHom.left_id CategoryTheory.BiconeHom.right_id fun k => CategoryTheory.BiconeHom.diagram (CategoryTheory.CategoryStruct.id k))","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (𝟙 k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    · exact g\n    · exact g\n    · cases g\n      apply BiconeHom.left\n    · cases g\n      apply BiconeHom.right\n    · rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f ≫ g)\n\n"}
{"name":"CategoryTheory.biconeMk_obj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type v₁\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor J C\nc₁ c₂ : CategoryTheory.Limits.Cone F\nX : CategoryTheory.Bicone J\n⊢ Eq ((CategoryTheory.biconeMk J c₁ c₂).obj X) (CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j)","decl":"/-- Given a diagram `F : J ⥤ C` and two `Cone F`s, we can join them into a diagram `Bicone J ⥤ C`.\n-/\n@[simps]\ndef biconeMk {C : Type u₁} [Category.{v₁} C] {F : J ⥤ C} (c₁ c₂ : Cone F) : Bicone J ⥤ C where\n  obj X := Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j\n  map f := by\n    rcases f with (_|_|_|_|f)\n    · exact 𝟙 _\n    · exact 𝟙 _\n    · exact c₁.π.app _\n    · exact c₂.π.app _\n    · exact F.map f\n  map_id X := by cases X <;> simp\n  map_comp f g := by\n    rcases f with (_|_|_|_|_)\n    · exact (Category.id_comp _).symm\n    · exact (Category.id_comp _).symm\n    · cases g\n      exact (Category.id_comp _).symm.trans (c₁.π.naturality _)\n    · cases g\n      exact (Category.id_comp _).symm.trans (c₂.π.naturality _)\n    · cases g\n      apply F.map_comp\n\n"}
{"name":"CategoryTheory.biconeMk_map","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type v₁\ninst✝¹ : CategoryTheory.SmallCategory J\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor J C\nc₁ c₂ : CategoryTheory.Limits.Cone F\nX✝ Y✝ : CategoryTheory.Bicone J\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.biconeMk J c₁ c₂).map f) (CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq X✝ a → Eq Y✝ a_1 → HEq f x → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X✝) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) f (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ CategoryTheory.Bicone.left → HEq f CategoryTheory.BiconeHom.left_id → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.left Y) → HEq f CategoryTheory.BiconeHom.left_id → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.left) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.left)) ⋯ f) ⋯ f) (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ CategoryTheory.Bicone.right → HEq f CategoryTheory.BiconeHom.right_id → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.right Y) → HEq f CategoryTheory.BiconeHom.right_id → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.right) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.right)) ⋯ f) ⋯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram j) → HEq f (CategoryTheory.BiconeHom.left j) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.left Y) → HEq f (CategoryTheory.BiconeHom.left j) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.left) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y)) (fun f h => c₁.π.app j) ⋯ f) ⋯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram j) → HEq f (CategoryTheory.BiconeHom.right j) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.right Y) → HEq f (CategoryTheory.BiconeHom.right j) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) CategoryTheory.Bicone.right) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y)) (fun f h => c₂.π.app j) ⋯ f) ⋯ f) (fun {j k} f_1 h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Y✝) → Eq Y✝ (CategoryTheory.Bicone.diagram k) → HEq f (CategoryTheory.BiconeHom.diagram f_1) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y✝)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom (CategoryTheory.Bicone.diagram j) Y) → HEq f (CategoryTheory.BiconeHom.diagram f_1) → Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) (CategoryTheory.Bicone.diagram j)) ((fun X => CategoryTheory.Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j) Y)) (fun f h => F.map f_1) ⋯ f) ⋯ f) ⋯ ⋯ ⋯)","decl":"/-- Given a diagram `F : J ⥤ C` and two `Cone F`s, we can join them into a diagram `Bicone J ⥤ C`.\n-/\n@[simps]\ndef biconeMk {C : Type u₁} [Category.{v₁} C] {F : J ⥤ C} (c₁ c₂ : Cone F) : Bicone J ⥤ C where\n  obj X := Bicone.casesOn X c₁.pt c₂.pt fun j => F.obj j\n  map f := by\n    rcases f with (_|_|_|_|f)\n    · exact 𝟙 _\n    · exact 𝟙 _\n    · exact c₁.π.app _\n    · exact c₂.π.app _\n    · exact F.map f\n  map_id X := by cases X <;> simp\n  map_comp f g := by\n    rcases f with (_|_|_|_|_)\n    · exact (Category.id_comp _).symm\n    · exact (Category.id_comp _).symm\n    · cases g\n      exact (Category.id_comp _).symm.trans (c₁.π.naturality _)\n    · cases g\n      exact (Category.id_comp _).symm.trans (c₂.π.naturality _)\n    · cases g\n      apply F.map_comp\n\n"}
