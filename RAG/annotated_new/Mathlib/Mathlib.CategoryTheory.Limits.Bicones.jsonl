{"name":"CategoryTheory.Bicone.diagram.inj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\nvalâœ val : J\nxâœ : Eq (CategoryTheory.Bicone.diagram valâœ) (CategoryTheory.Bicone.diagram val)\nâŠ¢ Eq valâœ val","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type uâ‚)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : SizeOf J\nâŠ¢ Eq (SizeOf.sizeOf CategoryTheory.Bicone.right) 1","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type uâ‚)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.diagram.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : SizeOf J\nval : J\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.Bicone.diagram val)) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type uâ‚)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.diagram.injEq","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\nvalâœ val : J\nâŠ¢ Eq (Eq (CategoryTheory.Bicone.diagram valâœ) (CategoryTheory.Bicone.diagram val)) (Eq valâœ val)","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type uâ‚)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.Bicone.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : SizeOf J\nâŠ¢ Eq (SizeOf.sizeOf CategoryTheory.Bicone.left) 1","decl":"/-- Given a category `J`, construct a walking `Bicone J` by adjoining two elements. -/\ninductive Bicone (J : Type uâ‚)\n  | left : Bicone J\n  | right : Bicone J\n  | diagram (val : J) : Bicone J\n  deriving DecidableEq\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : SizeOf J\nj k : J\nf : Quiver.Hom j k\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.diagram f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf j)) (SizeOf.sizeOf k)) (SizeOf.sizeOf f))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.right_id.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : SizeOf J\nâŠ¢ Eq (SizeOf.sizeOf CategoryTheory.BiconeHom.right_id) 1","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.inj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nj k : J\nfâœ f : Quiver.Hom j k\nxâœ : Eq (CategoryTheory.BiconeHom.diagram fâœ) (CategoryTheory.BiconeHom.diagram f)\nâŠ¢ Eq fâœ f","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.diagram.injEq","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nj k : J\nfâœ f : Quiver.Hom j k\nâŠ¢ Eq (Eq (CategoryTheory.BiconeHom.diagram fâœ) (CategoryTheory.BiconeHom.diagram f)) (Eq fâœ f)","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.left_id.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : SizeOf J\nâŠ¢ Eq (SizeOf.sizeOf CategoryTheory.BiconeHom.left_id) 1","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.left.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : SizeOf J\nj : J\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.left j)) (HAdd.hAdd 1 (SizeOf.sizeOf j))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.BiconeHom.right.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} J\ninstâœ : SizeOf J\nj : J\nâŠ¢ Eq (SizeOf.sizeOf (CategoryTheory.BiconeHom.right j)) (HAdd.hAdd 1 (SizeOf.sizeOf j))","decl":"/-- The homs for a walking `Bicone J`. -/\ninductive BiconeHom : Bicone J â†’ Bicone J â†’ Type max uâ‚ vâ‚\n  | left_id : BiconeHom Bicone.left Bicone.left\n  | right_id : BiconeHom Bicone.right Bicone.right\n  | left (j : J) : BiconeHom Bicone.left (Bicone.diagram j)\n  | right (j : J) : BiconeHom Bicone.right (Bicone.diagram j)\n  | diagram {j k : J} (f : j âŸ¶ k) : BiconeHom (Bicone.diagram j) (Bicone.diagram k)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_Hom","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\naâœÂ¹ aâœ : CategoryTheory.Bicone J\nâŠ¢ Eq (Quiver.Hom aâœÂ¹ aâœ) (CategoryTheory.BiconeHom J aâœÂ¹ aâœ)","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (ğŸ™ k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    Â· exact g\n    Â· exact g\n    Â· cases g\n      apply BiconeHom.left\n    Â· cases g\n      apply BiconeHom.right\n    Â· rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f â‰« g)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_comp","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nXâœ Yâœ Zâœ : CategoryTheory.Bicone J\nf : Quiver.Hom Xâœ Yâœ\ng : Quiver.Hom Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq Xâœ a â†’ Eq Yâœ a_1 â†’ HEq f x â†’ Quiver.Hom Xâœ Zâœ) f (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ CategoryTheory.Bicone.left â†’ HEq f CategoryTheory.BiconeHom.left_id â†’ Quiver.Hom X Zâœ) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Zâœ â†’ (f : Quiver.Hom CategoryTheory.Bicone.left Y) â†’ HEq f CategoryTheory.BiconeHom.left_id â†’ Quiver.Hom CategoryTheory.Bicone.left Zâœ) (fun g f h => g) â‹¯ g f) â‹¯ f) (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ CategoryTheory.Bicone.right â†’ HEq f CategoryTheory.BiconeHom.right_id â†’ Quiver.Hom X Zâœ) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Zâœ â†’ (f : Quiver.Hom CategoryTheory.Bicone.right Y) â†’ HEq f CategoryTheory.BiconeHom.right_id â†’ Quiver.Hom CategoryTheory.Bicone.right Zâœ) (fun g f h => g) â‹¯ g f) â‹¯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram j) â†’ HEq f (CategoryTheory.BiconeHom.left j) â†’ Quiver.Hom X Zâœ) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Zâœ â†’ (f : Quiver.Hom CategoryTheory.Bicone.left Y) â†’ HEq f (CategoryTheory.BiconeHom.left j) â†’ Quiver.Hom CategoryTheory.Bicone.left Zâœ) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 t => Eq (CategoryTheory.Bicone.diagram j) a â†’ Eq Zâœ a_1 â†’ HEq g t â†’ Quiver.Hom CategoryTheory.Bicone.left Zâœ) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k} f h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (f : Quiver.Hom j_2 k) â†’ Eq Zâœ (CategoryTheory.Bicone.diagram k) â†’ HEq g (CategoryTheory.BiconeHom.diagram f) â†’ Quiver.Hom CategoryTheory.Bicone.left Zâœ) (fun f h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) â†’ HEq g (CategoryTheory.BiconeHom.diagram f) â†’ Quiver.Hom CategoryTheory.Bicone.left Z) (fun g h => CategoryTheory.BiconeHom.left k) â‹¯ g) val_eq f) â‹¯ â‹¯ â‹¯) â‹¯ g f) â‹¯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram j) â†’ HEq f (CategoryTheory.BiconeHom.right j) â†’ Quiver.Hom X Zâœ) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Zâœ â†’ (f : Quiver.Hom CategoryTheory.Bicone.right Y) â†’ HEq f (CategoryTheory.BiconeHom.right j) â†’ Quiver.Hom CategoryTheory.Bicone.right Zâœ) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 t => Eq (CategoryTheory.Bicone.diagram j) a â†’ Eq Zâœ a_1 â†’ HEq g t â†’ Quiver.Hom CategoryTheory.Bicone.right Zâœ) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k} f h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (f : Quiver.Hom j_2 k) â†’ Eq Zâœ (CategoryTheory.Bicone.diagram k) â†’ HEq g (CategoryTheory.BiconeHom.diagram f) â†’ Quiver.Hom CategoryTheory.Bicone.right Zâœ) (fun f h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) â†’ HEq g (CategoryTheory.BiconeHom.diagram f) â†’ Quiver.Hom CategoryTheory.Bicone.right Z) (fun g h => CategoryTheory.BiconeHom.right k) â‹¯ g) val_eq f) â‹¯ â‹¯ â‹¯) â‹¯ g f) â‹¯ f) (fun {j k} f_1 h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram k) â†’ HEq f (CategoryTheory.BiconeHom.diagram f_1) â†’ Quiver.Hom X Zâœ) (fun f h => Eq.ndrec (motive := fun {Y} => Quiver.Hom Y Zâœ â†’ (f : Quiver.Hom (CategoryTheory.Bicone.diagram j) Y) â†’ HEq f (CategoryTheory.BiconeHom.diagram f_1) â†’ Quiver.Hom (CategoryTheory.Bicone.diagram j) Zâœ) (fun g f h => CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq (CategoryTheory.Bicone.diagram k) a â†’ Eq Zâœ a_1 â†’ HEq g x â†’ Quiver.Hom (CategoryTheory.Bicone.diagram j) Zâœ) g (fun h => CategoryTheory.Bicone.noConfusion h) (fun h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun j_1 h => CategoryTheory.Bicone.noConfusion h) (fun {j_1 k_1} g_1 h => CategoryTheory.Bicone.noConfusion h fun val_eq => Eq.ndrec (motive := fun {j_2} => (g_2 : Quiver.Hom j_2 k_1) â†’ Eq Zâœ (CategoryTheory.Bicone.diagram k_1) â†’ HEq g (CategoryTheory.BiconeHom.diagram g_2) â†’ Quiver.Hom (CategoryTheory.Bicone.diagram j) Zâœ) (fun g_2 h => Eq.ndrec (motive := fun {Z} => (g : Quiver.Hom (CategoryTheory.Bicone.diagram k) Z) â†’ HEq g (CategoryTheory.BiconeHom.diagram g_2) â†’ Quiver.Hom (CategoryTheory.Bicone.diagram j) Z) (fun g h => CategoryTheory.BiconeHom.diagram (CategoryTheory.CategoryStruct.comp f_1 g_2)) â‹¯ g) val_eq g_1) â‹¯ â‹¯ â‹¯) â‹¯ g f) â‹¯ f) â‹¯ â‹¯ â‹¯)","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (ğŸ™ k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    Â· exact g\n    Â· exact g\n    Â· cases g\n      apply BiconeHom.left\n    Â· cases g\n      apply BiconeHom.right\n    Â· rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f â‰« g)\n\n"}
{"name":"CategoryTheory.biconeCategoryStruct_id","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} J\nj : CategoryTheory.Bicone J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id j) (CategoryTheory.Bicone.casesOn j CategoryTheory.BiconeHom.left_id CategoryTheory.BiconeHom.right_id fun k => CategoryTheory.BiconeHom.diagram (CategoryTheory.CategoryStruct.id k))","decl":"@[simps]\ninstance biconeCategoryStruct : CategoryStruct (Bicone J) where\n  Hom := BiconeHom J\n  id j := Bicone.casesOn j BiconeHom.left_id BiconeHom.right_id fun k => BiconeHom.diagram (ğŸ™ k)\n  comp f g := by\n    rcases f with (_ | _ | _ | _ | f)\n    Â· exact g\n    Â· exact g\n    Â· cases g\n      apply BiconeHom.left\n    Â· cases g\n      apply BiconeHom.right\n    Â· rcases g with (_|_|_|_|g)\n      exact BiconeHom.diagram (f â‰« g)\n\n"}
{"name":"CategoryTheory.biconeMk_obj","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type vâ‚\ninstâœÂ¹ : CategoryTheory.SmallCategory J\nC : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nF : CategoryTheory.Functor J C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Cone F\nX : CategoryTheory.Bicone J\nâŠ¢ Eq ((CategoryTheory.biconeMk J câ‚ câ‚‚).obj X) (CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j)","decl":"/-- Given a diagram `F : J â¥¤ C` and two `Cone F`s, we can join them into a diagram `Bicone J â¥¤ C`.\n-/\n@[simps]\ndef biconeMk {C : Type uâ‚} [Category.{vâ‚} C] {F : J â¥¤ C} (câ‚ câ‚‚ : Cone F) : Bicone J â¥¤ C where\n  obj X := Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j\n  map f := by\n    rcases f with (_|_|_|_|f)\n    Â· exact ğŸ™ _\n    Â· exact ğŸ™ _\n    Â· exact câ‚.Ï€.app _\n    Â· exact câ‚‚.Ï€.app _\n    Â· exact F.map f\n  map_id X := by cases X <;> simp\n  map_comp f g := by\n    rcases f with (_|_|_|_|_)\n    Â· exact (Category.id_comp _).symm\n    Â· exact (Category.id_comp _).symm\n    Â· cases g\n      exact (Category.id_comp _).symm.trans (câ‚.Ï€.naturality _)\n    Â· cases g\n      exact (Category.id_comp _).symm.trans (câ‚‚.Ï€.naturality _)\n    Â· cases g\n      apply F.map_comp\n\n"}
{"name":"CategoryTheory.biconeMk_map","module":"Mathlib.CategoryTheory.Limits.Bicones","initialProofState":"J : Type vâ‚\ninstâœÂ¹ : CategoryTheory.SmallCategory J\nC : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nF : CategoryTheory.Functor J C\ncâ‚ câ‚‚ : CategoryTheory.Limits.Cone F\nXâœ Yâœ : CategoryTheory.Bicone J\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.biconeMk J câ‚ câ‚‚).map f) (CategoryTheory.BiconeHom.casesOn (motive := fun a a_1 x => Eq Xâœ a â†’ Eq Yâœ a_1 â†’ HEq f x â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Xâœ) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) f (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ CategoryTheory.Bicone.left â†’ HEq f CategoryTheory.BiconeHom.left_id â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.left Y) â†’ HEq f CategoryTheory.BiconeHom.left_id â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.left) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.left)) â‹¯ f) â‹¯ f) (fun h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ CategoryTheory.Bicone.right â†’ HEq f CategoryTheory.BiconeHom.right_id â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.right Y) â†’ HEq f CategoryTheory.BiconeHom.right_id â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.right) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Y)) (fun f h => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.right)) â‹¯ f) â‹¯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram j) â†’ HEq f (CategoryTheory.BiconeHom.left j) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.left Y) â†’ HEq f (CategoryTheory.BiconeHom.left j) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.left) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Y)) (fun f h => câ‚.Ï€.app j) â‹¯ f) â‹¯ f) (fun j h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram j) â†’ HEq f (CategoryTheory.BiconeHom.right j) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom CategoryTheory.Bicone.right Y) â†’ HEq f (CategoryTheory.BiconeHom.right j) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) CategoryTheory.Bicone.right) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Y)) (fun f h => câ‚‚.Ï€.app j) â‹¯ f) â‹¯ f) (fun {j k} f_1 h => Eq.ndrec (motive := fun {X} => (f : Quiver.Hom X Yâœ) â†’ Eq Yâœ (CategoryTheory.Bicone.diagram k) â†’ HEq f (CategoryTheory.BiconeHom.diagram f_1) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) X) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Yâœ)) (fun f h => Eq.ndrec (motive := fun {Y} => (f : Quiver.Hom (CategoryTheory.Bicone.diagram j) Y) â†’ HEq f (CategoryTheory.BiconeHom.diagram f_1) â†’ Quiver.Hom ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) (CategoryTheory.Bicone.diagram j)) ((fun X => CategoryTheory.Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j) Y)) (fun f h => F.map f_1) â‹¯ f) â‹¯ f) â‹¯ â‹¯ â‹¯)","decl":"/-- Given a diagram `F : J â¥¤ C` and two `Cone F`s, we can join them into a diagram `Bicone J â¥¤ C`.\n-/\n@[simps]\ndef biconeMk {C : Type uâ‚} [Category.{vâ‚} C] {F : J â¥¤ C} (câ‚ câ‚‚ : Cone F) : Bicone J â¥¤ C where\n  obj X := Bicone.casesOn X câ‚.pt câ‚‚.pt fun j => F.obj j\n  map f := by\n    rcases f with (_|_|_|_|f)\n    Â· exact ğŸ™ _\n    Â· exact ğŸ™ _\n    Â· exact câ‚.Ï€.app _\n    Â· exact câ‚‚.Ï€.app _\n    Â· exact F.map f\n  map_id X := by cases X <;> simp\n  map_comp f g := by\n    rcases f with (_|_|_|_|_)\n    Â· exact (Category.id_comp _).symm\n    Â· exact (Category.id_comp _).symm\n    Â· cases g\n      exact (Category.id_comp _).symm.trans (câ‚.Ï€.naturality _)\n    Â· cases g\n      exact (Category.id_comp _).symm.trans (câ‚‚.Ï€.naturality _)\n    Â· cases g\n      apply F.map_comp\n\n"}
