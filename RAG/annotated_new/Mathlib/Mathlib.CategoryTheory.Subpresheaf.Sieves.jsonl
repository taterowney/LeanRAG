{"name":"CategoryTheory.Subpresheaf.sieveOfSection_apply","module":"Mathlib.CategoryTheory.Subpresheaf.Sieves","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nU : Opposite C\ns : F.obj U\nV : C\nf : Quiver.Hom V (Opposite.unop U)\n⊢ Eq ((G.sieveOfSection s).arrows f) (Membership.mem (G.obj { unop := V }) (F.map f.op s))","decl":"/-- Given a subpresheaf `G` of `F`, an `F`-section `s` on `U`, we may define a sieve of `U`\nconsisting of all `f : V ⟶ U` such that the restriction of `s` along `f` is in `G`. -/\n@[simps]\ndef sieveOfSection {U : Cᵒᵖ} (s : F.obj U) : Sieve (unop U) where\n  arrows V f := F.map f.op s ∈ G.obj (op V)\n  downward_closed := @fun V W i hi j => by\n    simp only [op_unop, op_comp, FunctorToTypes.map_comp_apply]\n    exact G.map _ hi\n\n"}
{"name":"CategoryTheory.Subpresheaf.family_of_elements_compatible","module":"Mathlib.CategoryTheory.Subpresheaf.Sieves","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type w)\nG : CategoryTheory.Subpresheaf F\nU : Opposite C\ns : F.obj U\n⊢ (G.familyOfElementsOfSection s).Compatible","decl":"theorem family_of_elements_compatible {U : Cᵒᵖ} (s : F.obj U) :\n    (G.familyOfElementsOfSection s).Compatible := by\n  intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ h₁ h₂ e\n  refine Subtype.ext ?_ -- Porting note: `ext1` does not work here\n  change F.map g₁.op (F.map f₁.op s) = F.map g₂.op (F.map f₂.op s)\n  rw [← FunctorToTypes.map_comp_apply, ← FunctorToTypes.map_comp_apply, ← op_comp, ← op_comp, e]\n\n"}
