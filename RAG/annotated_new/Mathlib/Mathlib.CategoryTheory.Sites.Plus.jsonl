{"name":"CategoryTheory.GrothendieckTopology.diagram_map","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\nX : C\nS x‚úù : Opposite (J.Cover X)\nf : Quiver.Hom S x‚úù\n‚ä¢ Eq ((J.diagram P X).map f) (CategoryTheory.Limits.Multiequalizer.lift ((Opposite.unop x‚úù).index P) ((fun S => CategoryTheory.Limits.multiequalizer ((Opposite.unop S).index P)) S) (fun I => CategoryTheory.Limits.Multiequalizer.Œπ ((Opposite.unop S).index P) (CategoryTheory.GrothendieckTopology.Cover.Arrow.map I f.unop)) ‚ãØ)","decl":"/-- The diagram whose colimit defines the values of `plus`. -/\n@[simps]\ndef diagram (X : C) : (J.Cover X)·µí·µñ ‚•§ D where\n  obj S := multiequalizer (S.unop.index P)\n  map {S _} f :=\n    Multiequalizer.lift _ _ (fun I => Multiequalizer.Œπ (S.unop.index P) (I.map f.unop))\n      (fun I => Multiequalizer.condition (S.unop.index P) (Cover.Relation.mk' (I.r.map f.unop)))\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagram_obj","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\nX : C\nS : Opposite (J.Cover X)\n‚ä¢ Eq ((J.diagram P X).obj S) (CategoryTheory.Limits.multiequalizer ((Opposite.unop S).index P))","decl":"/-- The diagram whose colimit defines the values of `plus`. -/\n@[simps]\ndef diagram (X : C) : (J.Cover X)·µí·µñ ‚•§ D where\n  obj S := multiequalizer (S.unop.index P)\n  map {S _} f :=\n    Multiequalizer.lift _ _ (fun I => Multiequalizer.Œπ (S.unop.index P) (I.map f.unop))\n      (fun I => Multiequalizer.condition (S.unop.index P) (Cover.Relation.mk' (I.r.map f.unop)))\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramPullback_app","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\nX Y : C\nf : Quiver.Hom X Y\nS : Opposite (J.Cover Y)\n‚ä¢ Eq ((J.diagramPullback P f).app S) (CategoryTheory.Limits.Multiequalizer.lift ((Opposite.unop ((J.pullback f).op.obj S)).index P) ((J.diagram P Y).obj S) (fun I => CategoryTheory.Limits.Multiequalizer.Œπ ((Opposite.unop S).index P) (CategoryTheory.GrothendieckTopology.Cover.Arrow.base I)) ‚ãØ)","decl":"/-- A helper definition used to define the morphisms for `plus`. -/\n@[simps]\ndef diagramPullback {X Y : C} (f : X ‚ü∂ Y) : J.diagram P Y ‚ü∂ (J.pullback f).op ‚ãô J.diagram P X where\n  app S :=\n    Multiequalizer.lift _ _ (fun I => Multiequalizer.Œπ (S.unop.index P) I.base) fun I =>\n      Multiequalizer.condition (S.unop.index P) (Cover.Relation.mk' I.r.base)\n  naturality S T f := Multiequalizer.hom_ext _ _ _ (fun I => by dsimp; simp; rfl)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramNatTrans_app","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nX : C\nW : Opposite (J.Cover X)\n‚ä¢ Eq ((J.diagramNatTrans Œ∑ X).app W) (CategoryTheory.Limits.Multiequalizer.lift ((Opposite.unop W).index Q) ((J.diagram P X).obj W) (fun x => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Multiequalizer.Œπ ((Opposite.unop W).index P) x) (Œ∑.app { unop := x.Y })) ‚ãØ)","decl":"/-- A natural transformation `P ‚ü∂ Q` induces a natural transformation\nbetween diagrams whose colimits define the values of `plus`. -/\n@[simps]\ndef diagramNatTrans {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (X : C) : J.diagram P X ‚ü∂ J.diagram Q X where\n  app W :=\n    Multiequalizer.lift _ _ (fun _ => Multiequalizer.Œπ _ _ ‚â´ Œ∑.app _) (fun i => by\n      dsimp only\n      erw [Category.assoc, Category.assoc, ‚Üê Œ∑.naturality, ‚Üê Œ∑.naturality,\n        Multiequalizer.condition_assoc]\n      rfl)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramNatTrans_id","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (J.diagramNatTrans (CategoryTheory.CategoryStruct.id P) X) (CategoryTheory.CategoryStruct.id (J.diagram P X))","decl":"@[simp]\ntheorem diagramNatTrans_id (X : C) (P : C·µí·µñ ‚•§ D) :\n    J.diagramNatTrans (ùüô P) X = ùüô (J.diagram P X) := by\n  ext : 2\n  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramNatTrans_zero","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : CategoryTheory.Preadditive D\nX : C\nP Q : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (J.diagramNatTrans 0 X) 0","decl":"@[simp]\ntheorem diagramNatTrans_zero [Preadditive D] (X : C) (P Q : C·µí·µñ ‚•§ D) :\n    J.diagramNatTrans (0 : P ‚ü∂ Q) X = 0 := by\n  ext : 2\n  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramNatTrans_comp","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\nX : C\n‚ä¢ Eq (J.diagramNatTrans (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥) X) (CategoryTheory.CategoryStruct.comp (J.diagramNatTrans Œ∑ X) (J.diagramNatTrans Œ≥ X))","decl":"@[simp]\ntheorem diagramNatTrans_comp {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R) (X : C) :\n    J.diagramNatTrans (Œ∑ ‚â´ Œ≥) X = J.diagramNatTrans Œ∑ X ‚â´ J.diagramNatTrans Œ≥ X := by\n  ext : 2\n  refine Multiequalizer.hom_ext _ _ _ (fun i => ?_)\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramFunctor_obj","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((J.diagramFunctor D X).obj P) (J.diagram P X)","decl":"/-- `J.diagram P`, as a functor in `P`. -/\n@[simps]\ndef diagramFunctor (X : C) : (C·µí·µñ ‚•§ D) ‚•§ (J.Cover X)·µí·µñ ‚•§ D where\n  obj P := J.diagram P X\n  map Œ∑ := J.diagramNatTrans Œ∑ X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.diagramFunctor_map","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬π : CategoryTheory.Category.{max v u, w} D\ninst‚úù : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nX : C\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((J.diagramFunctor D X).map Œ∑) (J.diagramNatTrans Œ∑ X)","decl":"/-- `J.diagram P`, as a functor in `P`. -/\n@[simps]\ndef diagramFunctor (X : C) : (C·µí·µñ ‚•§ D) ‚•§ (J.Cover X)·µí·µñ ‚•§ D where\n  obj P := J.diagram P X\n  map Œ∑ := J.diagramNatTrans Œ∑ X\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_id","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (J.plusMap (CategoryTheory.CategoryStruct.id P)) (CategoryTheory.CategoryStruct.id (J.plusObj P))","decl":"@[simp]\ntheorem plusMap_id (P : C·µí·µñ ‚•§ D) : J.plusMap (ùüô P) = ùüô _ := by\n  ext : 2\n  dsimp only [plusMap, plusObj]\n  rw [J.diagramNatTrans_id, NatTrans.id_app]\n  ext\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_zero","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≤ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : CategoryTheory.Preadditive D\nP Q : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq (J.plusMap 0) 0","decl":"@[simp]\ntheorem plusMap_zero [Preadditive D] (P Q : C·µí·µñ ‚•§ D) : J.plusMap (0 : P ‚ü∂ Q) = 0 := by\n  ext : 2\n  refine colimit.hom_ext (fun S => ?_)\n  erw [comp_zero, colimit.Œπ_map, J.diagramNatTrans_zero, zero_comp]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_comp","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\n‚ä¢ Eq (J.plusMap (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥)) (CategoryTheory.CategoryStruct.comp (J.plusMap Œ∑) (J.plusMap Œ≥))","decl":"@[simp, reassoc]\ntheorem plusMap_comp {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R) :\n    J.plusMap (Œ∑ ‚â´ Œ≥) = J.plusMap Œ∑ ‚â´ J.plusMap Œ≥ := by\n  ext : 2\n  refine colimit.hom_ext (fun S => ?_)\n  simp [plusMap, J.diagramNatTrans_comp]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_comp_assoc","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (J.plusObj R) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.plusMap (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥)) h) (CategoryTheory.CategoryStruct.comp (J.plusMap Œ∑) (CategoryTheory.CategoryStruct.comp (J.plusMap Œ≥) h))","decl":"@[simp, reassoc]\ntheorem plusMap_comp {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R) :\n    J.plusMap (Œ∑ ‚â´ Œ≥) = J.plusMap Œ∑ ‚â´ J.plusMap Œ≥ := by\n  ext : 2\n  refine colimit.hom_ext (fun S => ?_)\n  simp [plusMap, J.diagramNatTrans_comp]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctor_obj","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((J.plusFunctor D).obj P) (J.plusObj P)","decl":"/-- The plus construction, a functor sending `P` to `J.plusObj P`. -/\n@[simps]\ndef plusFunctor : (C·µí·µñ ‚•§ D) ‚•§ C·µí·µñ ‚•§ D where\n  obj P := J.plusObj P\n  map Œ∑ := J.plusMap Œ∑\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctor_map","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((J.plusFunctor D).map Œ∑) (J.plusMap Œ∑)","decl":"/-- The plus construction, a functor sending `P` to `J.plusObj P`. -/\n@[simps]\ndef plusFunctor : (C·µí·µñ ‚•§ D) ‚•§ C·µí·µñ ‚•§ D where\n  obj P := J.plusObj P\n  map Œ∑ := J.plusMap Œ∑\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlus_naturality","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ∑ (J.toPlus Q)) (CategoryTheory.CategoryStruct.comp (J.toPlus P) (J.plusMap Œ∑))","decl":"@[reassoc (attr := simp)]\ntheorem toPlus_naturality {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :\n    Œ∑ ‚â´ J.toPlus Q = J.toPlus _ ‚â´ J.plusMap Œ∑ := by\n  ext\n  dsimp [toPlus, plusMap]\n  delta Cover.toMultiequalizer\n  simp only [Œπ_colimMap, Category.assoc]\n  simp_rw [‚Üê Category.assoc]\n  congr 1\n  exact Multiequalizer.hom_ext _ _ _ (fun I => by dsimp; simp)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlus_naturality_assoc","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom (J.plusObj Q) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ∑ (CategoryTheory.CategoryStruct.comp (J.toPlus Q) h)) (CategoryTheory.CategoryStruct.comp (J.toPlus P) (CategoryTheory.CategoryStruct.comp (J.plusMap Œ∑) h))","decl":"@[reassoc (attr := simp)]\ntheorem toPlus_naturality {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :\n    Œ∑ ‚â´ J.toPlus Q = J.toPlus _ ‚â´ J.plusMap Œ∑ := by\n  ext\n  dsimp [toPlus, plusMap]\n  delta Cover.toMultiequalizer\n  simp only [Œπ_colimMap, Category.assoc]\n  simp_rw [‚Üê Category.assoc]\n  congr 1\n  exact Multiequalizer.hom_ext _ _ _ (fun I => by dsimp; simp)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlusNatTrans_app","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP : CategoryTheory.Functor (Opposite C) D\n‚ä¢ Eq ((J.toPlusNatTrans D).app P) (J.toPlus P)","decl":"/-- The natural transformation from the identity functor to `plus`. -/\n@[simps]\ndef toPlusNatTrans : ùü≠ (C·µí·µñ ‚•§ D) ‚ü∂ J.plusFunctor D where\n  app P := J.toPlus P\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_toPlus","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\n‚ä¢ Eq (J.plusMap (J.toPlus P)) (J.toPlus (J.plusObj P))","decl":"/-- `(P ‚ü∂ P‚Å∫)‚Å∫ = P‚Å∫ ‚ü∂ P‚Å∫‚Å∫` -/\n@[simp]\ntheorem plusMap_toPlus : J.plusMap (J.toPlus P) = J.toPlus (J.plusObj P) := by\n  ext X : 2\n  refine colimit.hom_ext (fun S => ?_)\n  dsimp only [plusMap, toPlus]\n  let e : S.unop ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)\n  rw [Œπ_colimMap, ‚Üê colimit.w _ e.op, ‚Üê Category.assoc, ‚Üê Category.assoc]\n  congr 1\n  refine Multiequalizer.hom_ext _ _ _ (fun I => ?_)\n  erw [Multiequalizer.lift_Œπ]\n  simp only [unop_op, op_unop, diagram_map, Category.assoc, limit.lift_œÄ,\n    Multifork.ofŒπ_œÄ_app]\n  let ee : (J.pullback (I.map e).f).obj S.unop ‚ü∂ ‚ä§ := homOfLE (OrderTop.le_top _)\n  erw [‚Üê colimit.w _ ee.op, Œπ_colimMap_assoc, colimit.Œπ_pre, diagramPullback_app,\n    ‚Üê Category.assoc, ‚Üê Category.assoc]\n  congr 1\n  refine Multiequalizer.hom_ext _ _ _ (fun II => ?_)\n  convert Multiequalizer.condition (S.unop.index P)\n    (Cover.Relation.mk I II.base { g‚ÇÅ := II.f, g‚ÇÇ := ùüô _ }) using 1\n  all_goals dsimp; simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isIso_toPlus_of_isSheaf","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ CategoryTheory.IsIso (J.toPlus P)","decl":"theorem isIso_toPlus_of_isSheaf (hP : Presheaf.IsSheaf J P) : IsIso (J.toPlus P) := by\n  rw [Presheaf.isSheaf_iff_multiequalizer] at hP\n  suffices ‚àÄ X, IsIso ((J.toPlus P).app X) from NatIso.isIso_of_isIso_app _\n  intro X\n  refine IsIso.comp_isIso' inferInstance ?_\n  suffices ‚àÄ (S T : (J.Cover X.unop)·µí·µñ) (f : S ‚ü∂ T), IsIso ((J.diagram P X.unop).map f) from\n    isIso_Œπ_of_isInitial (initialOpOfTerminal isTerminalTop) _\n  intro S T e\n  have : S.unop.toMultiequalizer P ‚â´ (J.diagram P X.unop).map e = T.unop.toMultiequalizer P :=\n    Multiequalizer.hom_ext _ _ _ (fun II => by dsimp; simp)\n  have :\n    (J.diagram P X.unop).map e = inv (S.unop.toMultiequalizer P) ‚â´ T.unop.toMultiequalizer P := by\n    simp [‚Üê this]\n  rw [this]\n  infer_instance\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoToPlus_hom","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ Eq (J.isoToPlus P hP).hom (J.toPlus P)","decl":"@[simp]\ntheorem isoToPlus_hom (hP : Presheaf.IsSheaf J P) : (J.isoToPlus P hP).hom = J.toPlus P :=\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlus_plusLift_assoc","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nZ : CategoryTheory.Functor (Opposite C) D\nh : Quiver.Hom Q Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.toPlus P) (CategoryTheory.CategoryStruct.comp (J.plusLift Œ∑ hQ) h)) (CategoryTheory.CategoryStruct.comp Œ∑ h)","decl":"@[reassoc (attr := simp)]\ntheorem toPlus_plusLift {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toPlus P ‚â´ J.plusLift Œ∑ hQ = Œ∑ := by\n  dsimp [plusLift]\n  rw [‚Üê Category.assoc]\n  rw [Iso.comp_inv_eq]\n  dsimp only [isoToPlus, asIso]\n  rw [toPlus_naturality]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.toPlus_plusLift","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.toPlus P) (J.plusLift Œ∑ hQ)) Œ∑","decl":"@[reassoc (attr := simp)]\ntheorem toPlus_plusLift {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q) :\n    J.toPlus P ‚â´ J.plusLift Œ∑ hQ = Œ∑ := by\n  dsimp [plusLift]\n  rw [‚Üê Category.assoc]\n  rw [Iso.comp_inv_eq]\n  dsimp only [isoToPlus, asIso]\n  rw [toPlus_naturality]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusLift_unique","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nŒ≥ : Quiver.Hom (J.plusObj P) Q\nhŒ≥ : Eq (CategoryTheory.CategoryStruct.comp (J.toPlus P) Œ≥) Œ∑\n‚ä¢ Eq Œ≥ (J.plusLift Œ∑ hQ)","decl":"theorem plusLift_unique {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q)\n    (Œ≥ : J.plusObj P ‚ü∂ Q) (hŒ≥ : J.toPlus P ‚â´ Œ≥ = Œ∑) : Œ≥ = J.plusLift Œ∑ hQ := by\n  dsimp only [plusLift]\n  rw [Iso.eq_comp_inv, ‚Üê hŒ≥, plusMap_comp]\n  simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plus_hom_ext","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q : CategoryTheory.Functor (Opposite C) D\nŒ∑ Œ≥ : Quiver.Hom (J.plusObj P) Q\nhQ : CategoryTheory.Presheaf.IsSheaf J Q\nh : Eq (CategoryTheory.CategoryStruct.comp (J.toPlus P) Œ∑) (CategoryTheory.CategoryStruct.comp (J.toPlus P) Œ≥)\n‚ä¢ Eq Œ∑ Œ≥","decl":"theorem plus_hom_ext {P Q : C·µí·µñ ‚•§ D} (Œ∑ Œ≥ : J.plusObj P ‚ü∂ Q) (hQ : Presheaf.IsSheaf J Q)\n    (h : J.toPlus P ‚â´ Œ∑ = J.toPlus P ‚â´ Œ≥) : Œ∑ = Œ≥ := by\n  have : Œ≥ = J.plusLift (J.toPlus P ‚â´ Œ≥) hQ := by\n    apply plusLift_unique\n    rfl\n  rw [this]\n  apply plusLift_unique\n  exact h\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.isoToPlus_inv","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\nP : CategoryTheory.Functor (Opposite C) D\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ Eq (J.isoToPlus P hP).inv (J.plusLift (CategoryTheory.CategoryStruct.id P) hP)","decl":"@[simp]\ntheorem isoToPlus_inv (hP : Presheaf.IsSheaf J P) :\n    (J.isoToPlus P hP).inv = J.plusLift (ùüô _) hP := by\n  apply J.plusLift_unique\n  rw [Iso.comp_inv_eq, Category.id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusMap_plusLift","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≤ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬π : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\nP Q R : CategoryTheory.Functor (Opposite C) D\nŒ∑ : Quiver.Hom P Q\nŒ≥ : Quiver.Hom Q R\nhR : CategoryTheory.Presheaf.IsSheaf J R\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (J.plusMap Œ∑) (J.plusLift Œ≥ hR)) (J.plusLift (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥) hR)","decl":"@[simp]\ntheorem plusMap_plusLift {P Q R : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) (Œ≥ : Q ‚ü∂ R) (hR : Presheaf.IsSheaf J R) :\n    J.plusMap Œ∑ ‚â´ J.plusLift Œ≥ hR = J.plusLift (Œ∑ ‚â´ Œ≥) hR := by\n  apply J.plusLift_unique\n  rw [‚Üê Category.assoc, ‚Üê J.toPlus_naturality, Category.assoc, J.toPlus_plusLift]\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.plusFunctor_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Sites.Plus","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nD : Type w\ninst‚úù¬≥ : CategoryTheory.Category.{max v u, w} D\ninst‚úù¬≤ : ‚àÄ (P : CategoryTheory.Functor (Opposite C) D) (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.Limits.HasColimitsOfShape (Opposite (J.Cover X)) D\ninst‚úù : CategoryTheory.Preadditive D\n‚ä¢ (J.plusFunctor D).PreservesZeroMorphisms","decl":"instance plusFunctor_preservesZeroMorphisms [Preadditive D] :\n    (plusFunctor J D).PreservesZeroMorphisms where\n  map_zero F G := by\n    ext\n    dsimp\n    rw [J.plusMap_zero, NatTrans.app_zero]\n\n"}
