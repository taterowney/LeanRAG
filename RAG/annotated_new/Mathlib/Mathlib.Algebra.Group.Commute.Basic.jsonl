{"name":"Commute.inv_inv","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\na✝ : Commute a b\n⊢ Commute (Inv.inv a) (Inv.inv b)","decl":"@[to_additive]\nprotected theorem inv_inv : Commute a b → Commute a⁻¹ b⁻¹ :=\n  SemiconjBy.inv_inv_symm\n\n"}
{"name":"AddCommute.neg_neg","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\na✝ : AddCommute a b\n⊢ AddCommute (Neg.neg a) (Neg.neg b)","decl":"@[to_additive]\nprotected theorem inv_inv : Commute a b → Commute a⁻¹ b⁻¹ :=\n  SemiconjBy.inv_inv_symm\n\n"}
{"name":"AddCommute.neg_neg_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b : G\n⊢ Iff (AddCommute (Neg.neg a) (Neg.neg b)) (AddCommute a b)","decl":"@[to_additive (attr := simp)]\ntheorem inv_inv_iff : Commute a⁻¹ b⁻¹ ↔ Commute a b :=\n  SemiconjBy.inv_inv_symm_iff\n\n"}
{"name":"Commute.inv_inv_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b : G\n⊢ Iff (Commute (Inv.inv a) (Inv.inv b)) (Commute a b)","decl":"@[to_additive (attr := simp)]\ntheorem inv_inv_iff : Commute a⁻¹ b⁻¹ ↔ Commute a b :=\n  SemiconjBy.inv_inv_symm_iff\n\n"}
{"name":"Commute.div_mul_div_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b c d : G\nhbd : Commute b d\nhbc : Commute (Inv.inv b) c\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\nprotected theorem div_mul_div_comm (hbd : Commute b d) (hbc : Commute b⁻¹ c) :\n    a / b * (c / d) = a * c / (b * d) := by\n  simp_rw [div_eq_mul_inv, mul_inv_rev, hbd.inv_inv.symm.eq, hbc.mul_mul_mul_comm]\n\n"}
{"name":"AddCommute.sub_add_sub_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b c d : G\nhbd : AddCommute b d\nhbc : AddCommute (Neg.neg b) c\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) (HSub.hSub c d)) (HSub.hSub (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\nprotected theorem div_mul_div_comm (hbd : Commute b d) (hbc : Commute b⁻¹ c) :\n    a / b * (c / d) = a * c / (b * d) := by\n  simp_rw [div_eq_mul_inv, mul_inv_rev, hbd.inv_inv.symm.eq, hbc.mul_mul_mul_comm]\n\n"}
{"name":"AddCommute.add_sub_add_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b c d : G\nhcd : AddCommute c d\nhbc : AddCommute b (Neg.neg c)\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\nprotected theorem mul_div_mul_comm (hcd : Commute c d) (hbc : Commute b c⁻¹) :\n    a * b / (c * d) = a / c * (b / d) :=\n  (hcd.div_mul_div_comm hbc.symm).symm\n\n"}
{"name":"Commute.mul_div_mul_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b c d : G\nhcd : Commute c d\nhbc : Commute b (Inv.inv c)\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\nprotected theorem mul_div_mul_comm (hcd : Commute c d) (hbc : Commute b c⁻¹) :\n    a * b / (c * d) = a / c * (b / d) :=\n  (hcd.div_mul_div_comm hbc.symm).symm\n\n"}
{"name":"AddCommute.sub_sub_sub_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : SubtractionMonoid G\na b c d : G\nhbc : AddCommute b c\nhbd : AddCommute (Neg.neg b) d\nhcd : AddCommute (Neg.neg c) d\n⊢ Eq (HSub.hSub (HSub.hSub a b) (HSub.hSub c d)) (HSub.hSub (HSub.hSub a c) (HSub.hSub b d))","decl":"@[to_additive]\nprotected theorem div_div_div_comm (hbc : Commute b c) (hbd : Commute b⁻¹ d) (hcd : Commute c⁻¹ d) :\n    a / b / (c / d) = a / c / (b / d) := by\n  simp_rw [div_eq_mul_inv, mul_inv_rev, inv_inv, hbd.symm.eq, hcd.symm.eq,\n    hbc.inv_inv.mul_mul_mul_comm]\n\n"}
{"name":"Commute.div_div_div_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : DivisionMonoid G\na b c d : G\nhbc : Commute b c\nhbd : Commute (Inv.inv b) d\nhcd : Commute (Inv.inv c) d\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HDiv.hDiv a c) (HDiv.hDiv b d))","decl":"@[to_additive]\nprotected theorem div_div_div_comm (hbc : Commute b c) (hbd : Commute b⁻¹ d) (hcd : Commute c⁻¹ d) :\n    a / b / (c / d) = a / c / (b / d) := by\n  simp_rw [div_eq_mul_inv, mul_inv_rev, inv_inv, hbd.symm.eq, hcd.symm.eq,\n    hbc.inv_inv.mul_mul_mul_comm]\n\n"}
{"name":"Commute.inv_left_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Iff (Commute (Inv.inv a) b) (Commute a b)","decl":"@[to_additive (attr := simp)]\nlemma inv_left_iff : Commute a⁻¹ b ↔ Commute a b := SemiconjBy.inv_symm_left_iff\n\n"}
{"name":"AddCommute.neg_left_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Iff (AddCommute (Neg.neg a) b) (AddCommute a b)","decl":"@[to_additive (attr := simp)]\nlemma inv_left_iff : Commute a⁻¹ b ↔ Commute a b := SemiconjBy.inv_symm_left_iff\n\n"}
{"name":"AddCommute.neg_left","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\na✝ : AddCommute a b\n⊢ AddCommute (Neg.neg a) b","decl":"@[to_additive] alias ⟨_, inv_left⟩ := inv_left_iff\n\n"}
{"name":"Commute.inv_left","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\na✝ : Commute a b\n⊢ Commute (Inv.inv a) b","decl":"@[to_additive] alias ⟨_, inv_left⟩ := inv_left_iff\n\n"}
{"name":"Commute.inv_right_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\n⊢ Iff (Commute a (Inv.inv b)) (Commute a b)","decl":"@[to_additive (attr := simp)]\nlemma inv_right_iff : Commute a b⁻¹ ↔ Commute a b := SemiconjBy.inv_right_iff\n\n"}
{"name":"AddCommute.neg_right_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\n⊢ Iff (AddCommute a (Neg.neg b)) (AddCommute a b)","decl":"@[to_additive (attr := simp)]\nlemma inv_right_iff : Commute a b⁻¹ ↔ Commute a b := SemiconjBy.inv_right_iff\n\n"}
{"name":"AddCommute.neg_right","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\na✝ : AddCommute a b\n⊢ AddCommute a (Neg.neg b)","decl":"@[to_additive] alias ⟨_, inv_right⟩ := inv_right_iff\n\n"}
{"name":"Commute.inv_right","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\na✝ : Commute a b\n⊢ Commute a (Inv.inv b)","decl":"@[to_additive] alias ⟨_, inv_right⟩ := inv_right_iff\n\n"}
{"name":"Commute.inv_mul_cancel","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\n⊢ Eq (HMul.hMul (HMul.hMul (Inv.inv a) b) a) b","decl":"@[to_additive]\nprotected lemma inv_mul_cancel (h : Commute a b) : a⁻¹ * b * a = b := by\n  rw [h.inv_left.eq, inv_mul_cancel_right]\n\n"}
{"name":"AddCommute.neg_add_cancel","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (Neg.neg a) b) a) b","decl":"@[to_additive]\nprotected lemma inv_mul_cancel (h : Commute a b) : a⁻¹ * b * a = b := by\n  rw [h.inv_left.eq, inv_mul_cancel_right]\n\n"}
{"name":"Commute.inv_mul_cancel_assoc","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\n⊢ Eq (HMul.hMul (Inv.inv a) (HMul.hMul b a)) b","decl":"@[to_additive]\nlemma inv_mul_cancel_assoc (h : Commute a b) : a⁻¹ * (b * a) = b := by\n  rw [← mul_assoc, h.inv_mul_cancel]\n\n"}
{"name":"AddCommute.neg_add_cancel_assoc","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\n⊢ Eq (HAdd.hAdd (Neg.neg a) (HAdd.hAdd b a)) b","decl":"@[to_additive]\nlemma inv_mul_cancel_assoc (h : Commute a b) : a⁻¹ * (b * a) = b := by\n  rw [← mul_assoc, h.inv_mul_cancel]\n\n"}
{"name":"Commute.conj_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b h : G\n⊢ Iff (Commute (HMul.hMul (HMul.hMul h a) (Inv.inv h)) (HMul.hMul (HMul.hMul h b) (Inv.inv h))) (Commute a b)","decl":"@[to_additive (attr := simp)]\nprotected theorem conj_iff (h : G) : Commute (h * a * h⁻¹) (h * b * h⁻¹) ↔ Commute a b :=\n  SemiconjBy.conj_iff\n\n"}
{"name":"AddCommute.conj_iff","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b h : G\n⊢ Iff (AddCommute (HAdd.hAdd (HAdd.hAdd h a) (Neg.neg h)) (HAdd.hAdd (HAdd.hAdd h b) (Neg.neg h))) (AddCommute a b)","decl":"@[to_additive (attr := simp)]\nprotected theorem conj_iff (h : G) : Commute (h * a * h⁻¹) (h * b * h⁻¹) ↔ Commute a b :=\n  SemiconjBy.conj_iff\n\n"}
{"name":"Commute.conj","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\ncomm : Commute a b\nh : G\n⊢ Commute (HMul.hMul (HMul.hMul h a) (Inv.inv h)) (HMul.hMul (HMul.hMul h b) (Inv.inv h))","decl":"@[to_additive]\nprotected theorem conj (comm : Commute a b) (h : G) : Commute (h * a * h⁻¹) (h * b * h⁻¹) :=\n  (Commute.conj_iff h).mpr comm\n\n"}
{"name":"AddCommute.conj","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\ncomm : AddCommute a b\nh : G\n⊢ AddCommute (HAdd.hAdd (HAdd.hAdd h a) (Neg.neg h)) (HAdd.hAdd (HAdd.hAdd h b) (Neg.neg h))","decl":"@[to_additive]\nprotected theorem conj (comm : Commute a b) (h : G) : Commute (h * a * h⁻¹) (h * b * h⁻¹) :=\n  (Commute.conj_iff h).mpr comm\n\n"}
{"name":"AddCommute.zsmul_right","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\nm : Int\n⊢ AddCommute a (HSMul.hSMul m b)","decl":"@[to_additive (attr := simp)]\nlemma zpow_right (h : Commute a b) (m : ℤ) : Commute a (b ^ m) := SemiconjBy.zpow_right h m\n\n"}
{"name":"Commute.zpow_right","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\nm : Int\n⊢ Commute a (HPow.hPow b m)","decl":"@[to_additive (attr := simp)]\nlemma zpow_right (h : Commute a b) (m : ℤ) : Commute a (b ^ m) := SemiconjBy.zpow_right h m\n\n"}
{"name":"AddCommute.zsmul_left","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\nm : Int\n⊢ AddCommute (HSMul.hSMul m a) b","decl":"@[to_additive (attr := simp)]\nlemma zpow_left (h : Commute a b) (m : ℤ) : Commute (a ^ m) b := (h.symm.zpow_right m).symm\n\n"}
{"name":"Commute.zpow_left","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\nm : Int\n⊢ Commute (HPow.hPow a m) b","decl":"@[to_additive (attr := simp)]\nlemma zpow_left (h : Commute a b) (m : ℤ) : Commute (a ^ m) b := (h.symm.zpow_right m).symm\n\n"}
{"name":"AddCommute.zsmul_zsmul","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na b : G\nh : AddCommute a b\nm n : Int\n⊢ AddCommute (HSMul.hSMul m a) (HSMul.hSMul n b)","decl":"@[to_additive] lemma zpow_zpow (h : Commute a b) (m n : ℤ) : Commute (a ^ m) (b ^ n) :=\n  (h.zpow_left m).zpow_right n\n\n"}
{"name":"Commute.zpow_zpow","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na b : G\nh : Commute a b\nm n : Int\n⊢ Commute (HPow.hPow a m) (HPow.hPow b n)","decl":"@[to_additive] lemma zpow_zpow (h : Commute a b) (m n : ℤ) : Commute (a ^ m) (b ^ n) :=\n  (h.zpow_left m).zpow_right n\n\n"}
{"name":"AddCommute.self_zsmul","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ AddCommute a (HSMul.hSMul n a)","decl":"@[to_additive] lemma self_zpow : Commute a (a ^ n) := (Commute.refl a).zpow_right n\n\n"}
{"name":"Commute.self_zpow","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\nn : Int\n⊢ Commute a (HPow.hPow a n)","decl":"@[to_additive] lemma self_zpow : Commute a (a ^ n) := (Commute.refl a).zpow_right n\n\n"}
{"name":"AddCommute.zsmul_self","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ AddCommute (HSMul.hSMul n a) a","decl":"@[to_additive] lemma zpow_self : Commute (a ^ n) a := (Commute.refl a).zpow_left n\n\n"}
{"name":"Commute.zpow_self","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\nn : Int\n⊢ Commute (HPow.hPow a n) a","decl":"@[to_additive] lemma zpow_self : Commute (a ^ n) a := (Commute.refl a).zpow_left n\n\n"}
{"name":"AddCommute.zsmul_zsmul_self","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\nm n : Int\n⊢ AddCommute (HSMul.hSMul m a) (HSMul.hSMul n a)","decl":"@[to_additive] lemma zpow_zpow_self : Commute (a ^ m) (a ^ n) := (Commute.refl a).zpow_zpow m n\n\n"}
{"name":"Commute.zpow_zpow_self","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\nm n : Int\n⊢ Commute (HPow.hPow a m) (HPow.hPow a n)","decl":"@[to_additive] lemma zpow_zpow_self : Commute (a ^ m) (a ^ n) := (Commute.refl a).zpow_zpow m n\n\n"}
{"name":"nsmul_neg_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\nm n : Nat\n⊢ Eq (HAdd.hAdd (HSMul.hSMul m (Neg.neg a)) (HSMul.hSMul n a)) (HAdd.hAdd (HSMul.hSMul n a) (HSMul.hSMul m (Neg.neg a)))","decl":"@[to_additive] lemma pow_inv_comm (a : G) (m n : ℕ) : a⁻¹ ^ m * a ^ n = a ^ n * a⁻¹ ^ m :=\n  (Commute.refl a).inv_left.pow_pow _ _\n\n"}
{"name":"pow_inv_comm","module":"Mathlib.Algebra.Group.Commute.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\nm n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (Inv.inv a) m) (HPow.hPow a n)) (HMul.hMul (HPow.hPow a n) (HPow.hPow (Inv.inv a) m))","decl":"@[to_additive] lemma pow_inv_comm (a : G) (m n : ℕ) : a⁻¹ ^ m * a ^ n = a ^ n * a⁻¹ ^ m :=\n  (Commute.refl a).inv_left.pow_pow _ _\n\n"}
