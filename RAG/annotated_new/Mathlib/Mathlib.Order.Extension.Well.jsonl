{"name":"IsWellFounded.wellOrderExtension.isWellFounded_lt","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\n⊢ IsWellFounded α LT.lt","decl":"instance wellOrderExtension.isWellFounded_lt : IsWellFounded α (wellOrderExtension r).lt :=\n  ⟨InvImage.wf (fun a : α => (rank r a, embeddingToCardinal a)) <|\n    Ordinal.lt_wf.prod_lex Cardinal.lt_wf⟩\n\n"}
{"name":"IsWellFounded.wellOrderExtension.isWellOrder_lt","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\n⊢ IsWellOrder α LT.lt","decl":"instance wellOrderExtension.isWellOrder_lt : IsWellOrder α (wellOrderExtension r).lt where\n\n"}
{"name":"IsWellFounded.exists_well_order_ge","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\n⊢ Exists fun s => And (LE.le r s) (IsWellOrder α s)","decl":"/-- Any well-founded relation can be extended to a well-ordering on that type. -/\ntheorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s :=\n  ⟨(wellOrderExtension r).lt, fun _ _ h => Prod.Lex.left _ _ (rank_lt_of_rel h), ⟨⟩⟩\n\n"}
{"name":"WellFounded.wellOrderExtension.isWellFounded_lt","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\nr : α → α → Prop\nhwf : WellFounded r\n⊢ IsWellFounded α LT.lt","decl":"set_option linter.deprecated false in\n@[deprecated IsWellFounded.wellOrderExtension.isWellFounded_lt (since := \"2024-09-07\")]\ninstance wellOrderExtension.isWellFounded_lt : IsWellFounded α hwf.wellOrderExtension.lt :=\n  ⟨InvImage.wf (fun a : α => (hwf.rank a, embeddingToCardinal a)) <|\n    Ordinal.lt_wf.prod_lex Cardinal.lt_wf⟩\n\n"}
{"name":"WellFounded.exists_well_order_ge","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\nr : α → α → Prop\nhwf : WellFounded r\n⊢ Exists fun s => And (LE.le r s) (IsWellOrder α s)","decl":"include hwf in\nset_option linter.deprecated false in\n/-- Any well-founded relation can be extended to a well-ordering on that type. -/\n@[deprecated IsWellFounded.exists_well_order_ge (since := \"2024-09-07\")]\ntheorem exists_well_order_ge : ∃ s, r ≤ s ∧ IsWellOrder α s :=\n  ⟨hwf.wellOrderExtension.lt, fun _ _ h => Prod.Lex.left _ _ (hwf.rank_lt_of_rel h), ⟨⟩⟩\n\n"}
{"name":"WellOrderExtension.wellFoundedLT","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\n⊢ WellFoundedLT (WellOrderExtension α)","decl":"instance WellOrderExtension.wellFoundedLT [LT α] [WellFoundedLT α] :\n    WellFoundedLT (WellOrderExtension α) :=\n  IsWellFounded.wellOrderExtension.isWellFounded_lt (α := α) (· < ·)\n\n"}
{"name":"toWellOrderExtension_strictMono","module":"Mathlib.Order.Extension.Well","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : WellFoundedLT α\n⊢ StrictMono ⇑toWellOrderExtension","decl":"theorem toWellOrderExtension_strictMono [Preorder α] [WellFoundedLT α] :\n    StrictMono (toWellOrderExtension : α → WellOrderExtension α) := fun _ _ h =>\n  Prod.Lex.left _ _ <| IsWellFounded.rank_lt_of_rel h\n"}
