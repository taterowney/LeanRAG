{"name":"LipschitzWith.memℒp_lineDeriv","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\nhf : LipschitzWith C f\nv : E\n⊢ MeasureTheory.Memℒp (fun x => lineDeriv Real f x v) Top.top μ","decl":"theorem memℒp_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    Memℒp (fun x ↦ lineDeriv ℝ f x v) ∞ μ :=\n  memℒp_top_of_bound (aestronglyMeasurable_lineDeriv hf.continuous μ)\n    (C * ‖v‖) (.of_forall fun _x ↦ norm_lineDeriv_le_of_lipschitz ℝ hf)\n\n"}
{"name":"LipschitzWith.ae_lineDifferentiableAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nv : E\n⊢ Filter.Eventually (fun p => LineDifferentiableAt Real f p v) (MeasureTheory.ae μ)","decl":"theorem ae_lineDifferentiableAt\n    (hf : LipschitzWith C f) (v : E) :\n    ∀ᵐ p ∂μ, LineDifferentiableAt ℝ f p v := by\n  let L : ℝ →L[ℝ] E := ContinuousLinearMap.smulRight (1 : ℝ →L[ℝ] ℝ) v\n  suffices A : ∀ p, ∀ᵐ (t : ℝ) ∂volume, LineDifferentiableAt ℝ f (p + t • v) v from\n    ae_mem_of_ae_add_linearMap_mem L.toLinearMap volume μ\n      (measurableSet_lineDifferentiableAt hf.continuous) A\n  intro p\n  have : ∀ᵐ (s : ℝ), DifferentiableAt ℝ (fun t ↦ f (p + t • v)) s :=\n    (hf.comp ((LipschitzWith.const p).add L.lipschitz)).ae_differentiableAt_real\n  filter_upwards [this] with s hs\n  have h's : DifferentiableAt ℝ (fun t ↦ f (p + t • v)) (s + 0) := by simpa using hs\n  have : DifferentiableAt ℝ (fun t ↦ s + t) 0 := differentiableAt_id.const_add _\n  simp only [LineDifferentiableAt]\n  convert h's.comp 0 this with _ t\n  simp only [LineDifferentiableAt, add_assoc, Function.comp_apply, add_smul]\n\n"}
{"name":"LipschitzWith.locallyIntegrable_lineDeriv","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nv : E\n⊢ MeasureTheory.LocallyIntegrable (fun x => lineDeriv Real f x v) μ","decl":"theorem locallyIntegrable_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    LocallyIntegrable (fun x ↦ lineDeriv ℝ f x v) μ :=\n  (hf.memℒp_lineDeriv v).locallyIntegrable le_top\n\n"}
{"name":"LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf g : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nhg : MeasureTheory.Integrable g μ\nv : E\n⊢ Filter.Tendsto (fun t => MeasureTheory.integral μ fun x => HMul.hMul (HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul t v))) (f x))) (g x)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (MeasureTheory.integral μ fun x => HMul.hMul (lineDeriv Real f x v) (g x)))","decl":"theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul\n    (hf : LipschitzWith C f) (hg : Integrable g μ) (v : E) :\n    Tendsto (fun (t : ℝ) ↦ ∫ x, (t⁻¹ • (f (x + t • v) - f x)) * g x ∂μ) (𝓝[>] 0)\n      (𝓝 (∫ x, lineDeriv ℝ f x v * g x ∂μ)) := by\n  apply tendsto_integral_filter_of_dominated_convergence (fun x ↦ (C * ‖v‖) * ‖g x‖)\n  · filter_upwards with t\n    apply AEStronglyMeasurable.mul ?_ hg.aestronglyMeasurable\n    apply aestronglyMeasurable_const.smul\n    apply AEStronglyMeasurable.sub _ hf.continuous.measurable.aestronglyMeasurable\n    apply AEMeasurable.aestronglyMeasurable\n    exact hf.continuous.measurable.comp_aemeasurable' (aemeasurable_id'.add_const _)\n  · filter_upwards [self_mem_nhdsWithin] with t (ht : 0 < t)\n    filter_upwards with x\n    calc ‖t⁻¹ • (f (x + t • v) - f x) * g x‖\n      = (t⁻¹ * ‖f (x + t • v) - f x‖) * ‖g x‖ := by simp [norm_mul, ht.le]\n    _ ≤ (t⁻¹ * (C * ‖(x + t • v) - x‖)) * ‖g x‖ := by\n      gcongr; exact LipschitzWith.norm_sub_le hf (x + t • v) x\n    _ = (C * ‖v‖) *‖g x‖ := by field_simp [norm_smul, abs_of_nonneg ht.le]; ring\n  · exact hg.norm.const_mul _\n  · filter_upwards [hf.ae_lineDifferentiableAt v] with x hx\n    exact hx.hasLineDerivAt.tendsto_slope_zero_right.mul tendsto_const_nhds\n\n"}
{"name":"LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf g : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nh'f : HasCompactSupport f\nhg : Continuous g\nv : E\n⊢ Filter.Tendsto (fun t => MeasureTheory.integral μ fun x => HMul.hMul (HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul t v))) (f x))) (g x)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (MeasureTheory.integral μ fun x => HMul.hMul (lineDeriv Real f x v) (g x)))","decl":"theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'\n    (hf : LipschitzWith C f) (h'f : HasCompactSupport f) (hg : Continuous g) (v : E) :\n    Tendsto (fun (t : ℝ) ↦ ∫ x, (t⁻¹ • (f (x + t • v) - f x)) * g x ∂μ) (𝓝[>] 0)\n      (𝓝 (∫ x, lineDeriv ℝ f x v * g x ∂μ)) := by\n  let K := cthickening (‖v‖) (tsupport f)\n  have K_compact : IsCompact K := IsCompact.cthickening h'f\n  apply tendsto_integral_filter_of_dominated_convergence\n      (K.indicator (fun x ↦ (C * ‖v‖) * ‖g x‖))\n  · filter_upwards with t\n    apply AEStronglyMeasurable.mul ?_ hg.aestronglyMeasurable\n    apply aestronglyMeasurable_const.smul\n    apply AEStronglyMeasurable.sub _ hf.continuous.measurable.aestronglyMeasurable\n    apply AEMeasurable.aestronglyMeasurable\n    exact hf.continuous.measurable.comp_aemeasurable' (aemeasurable_id'.add_const _)\n  · filter_upwards [Ioc_mem_nhdsGT zero_lt_one] with t ht\n    have t_pos : 0 < t := ht.1\n    filter_upwards with x\n    by_cases hx : x ∈ K\n    · calc ‖t⁻¹ • (f (x + t • v) - f x) * g x‖\n        = (t⁻¹ * ‖f (x + t • v) - f x‖) * ‖g x‖ := by simp [norm_mul, t_pos.le]\n      _ ≤ (t⁻¹ * (C * ‖(x + t • v) - x‖)) * ‖g x‖ := by\n        gcongr; exact LipschitzWith.norm_sub_le hf (x + t • v) x\n      _ = (C * ‖v‖) *‖g x‖ := by field_simp [norm_smul, abs_of_nonneg t_pos.le]; ring\n      _ = K.indicator (fun x ↦ (C * ‖v‖) * ‖g x‖) x := by rw [indicator_of_mem hx]\n    · have A : f x = 0 := by\n        rw [← Function.nmem_support]\n        contrapose! hx\n        exact self_subset_cthickening _ (subset_tsupport _ hx)\n      have B : f (x + t • v) = 0 := by\n        rw [← Function.nmem_support]\n        contrapose! hx\n        apply mem_cthickening_of_dist_le _ _ (‖v‖) (tsupport f) (subset_tsupport _ hx)\n        simp only [dist_eq_norm, sub_add_cancel_left, norm_neg, norm_smul, Real.norm_eq_abs,\n          abs_of_nonneg t_pos.le, norm_pos_iff]\n        exact mul_le_of_le_one_left (norm_nonneg v) ht.2\n      simp only [B, A, _root_.sub_self, smul_eq_mul, mul_zero, zero_mul, norm_zero]\n      exact indicator_nonneg (fun y _hy ↦ by positivity) _\n  · rw [integrable_indicator_iff K_compact.measurableSet]\n    apply ContinuousOn.integrableOn_compact K_compact\n    exact (Continuous.mul continuous_const hg.norm).continuousOn\n  · filter_upwards [hf.ae_lineDifferentiableAt v] with x hx\n    exact hx.hasLineDerivAt.tendsto_slope_zero_right.mul tendsto_const_nhds\n\n"}
{"name":"LipschitzWith.integral_lineDeriv_mul_eq","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC D : NNReal\nf g : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nhg : LipschitzWith D g\nh'g : HasCompactSupport g\nv : E\n⊢ Eq (MeasureTheory.integral μ fun x => HMul.hMul (lineDeriv Real f x v) (g x)) (MeasureTheory.integral μ fun x => HMul.hMul (lineDeriv Real g x (Neg.neg v)) (f x))","decl":"/-- Integration by parts formula for the line derivative of Lipschitz functions, assuming one of\nthem is compactly supported. -/\ntheorem integral_lineDeriv_mul_eq\n    (hf : LipschitzWith C f) (hg : LipschitzWith D g) (h'g : HasCompactSupport g) (v : E) :\n    ∫ x, lineDeriv ℝ f x v * g x ∂μ = ∫ x, lineDeriv ℝ g x (-v) * f x ∂μ := by\n  /- Write down the line derivative as the limit of `(f (x + t v) - f x) / t` and\n  `(g (x - t v) - g x) / t`, and therefore the integrals as limits of the corresponding integrals\n  thanks to the dominated convergence theorem. At fixed positive `t`, the integrals coincide\n  (with the change of variables `y = x + t v`), so the limits also coincide. -/\n  have A : Tendsto (fun (t : ℝ) ↦ ∫ x, (t⁻¹ • (f (x + t • v) - f x)) * g x ∂μ) (𝓝[>] 0)\n              (𝓝 (∫ x, lineDeriv ℝ f x v * g x ∂μ)) :=\n    integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul\n      hf (hg.continuous.integrable_of_hasCompactSupport h'g) v\n  have B : Tendsto (fun (t : ℝ) ↦ ∫ x, (t⁻¹ • (g (x + t • (-v)) - g x)) * f x ∂μ) (𝓝[>] 0)\n              (𝓝 (∫ x, lineDeriv ℝ g x (-v) * f x ∂μ)) :=\n    integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul' hg h'g hf.continuous (-v)\n  suffices S1 : ∀ (t : ℝ), ∫ x, (t⁻¹ • (f (x + t • v) - f x)) * g x ∂μ =\n                            ∫ x, (t⁻¹ • (g (x + t • (-v)) - g x)) * f x ∂μ by\n    simp only [S1] at A; exact tendsto_nhds_unique A B\n  intro t\n  suffices S2 : ∫ x, (f (x + t • v) - f x) * g x ∂μ = ∫ x, f x * (g (x + t • (-v)) - g x) ∂μ by\n    simp only [smul_eq_mul, mul_assoc, integral_mul_left, S2, mul_neg, mul_comm (f _)]\n  have S3 : ∫ x, f (x + t • v) * g x ∂μ = ∫ x, f x * g (x + t • (-v)) ∂μ := by\n    rw [← integral_add_right_eq_self _ (t • (-v))]; simp\n  simp_rw [_root_.sub_mul, _root_.mul_sub]\n  rw [integral_sub, integral_sub, S3]\n  · apply Continuous.integrable_of_hasCompactSupport\n    · exact hf.continuous.mul (hg.continuous.comp (continuous_add_right _))\n    · exact (h'g.comp_homeomorph (Homeomorph.addRight (t • (-v)))).mul_left\n  · exact (hf.continuous.mul hg.continuous).integrable_of_hasCompactSupport h'g.mul_left\n  · apply Continuous.integrable_of_hasCompactSupport\n    · exact (hf.continuous.comp (continuous_add_right _)).mul hg.continuous\n    · exact h'g.mul_left\n  · exact (hf.continuous.mul hg.continuous).integrable_of_hasCompactSupport h'g.mul_left\n\n"}
{"name":"LipschitzWith.ae_lineDeriv_sum_eq","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\nι : Type u_3\ns : Finset ι\na : ι → Real\nv : ι → E\n⊢ Filter.Eventually (fun x => Eq (lineDeriv Real f x (s.sum fun i => HSMul.hSMul (a i) (v i))) (s.sum fun i => HSMul.hSMul (a i) (lineDeriv Real f x (v i)))) (MeasureTheory.ae μ)","decl":"/-- The line derivative of a Lipschitz function is almost everywhere linear with respect to fixed\ncoefficients. -/\ntheorem ae_lineDeriv_sum_eq\n    (hf : LipschitzWith C f) {ι : Type*} (s : Finset ι) (a : ι → ℝ) (v : ι → E) :\n    ∀ᵐ x ∂μ, lineDeriv ℝ f x (∑ i ∈ s, a i • v i) = ∑ i ∈ s, a i • lineDeriv ℝ f x (v i) := by\n  /- Clever argument by Morrey: integrate against a smooth compactly supported function `g`, switch\n  the derivative to `g` by integration by parts, and use the linearity of the derivative of `g` to\n  conclude that the initial integrals coincide. -/\n  apply ae_eq_of_integral_contDiff_smul_eq (hf.locallyIntegrable_lineDeriv _)\n    (locallyIntegrable_finset_sum _ (fun i hi ↦ (hf.locallyIntegrable_lineDeriv (v i)).smul (a i)))\n    (fun g g_smooth g_comp ↦ ?_)\n  simp_rw [Finset.smul_sum]\n  have A : ∀ i ∈ s, Integrable (fun x ↦ g x • (a i • fun x ↦ lineDeriv ℝ f x (v i)) x) μ :=\n    fun i hi ↦ (g_smooth.continuous.integrable_of_hasCompactSupport g_comp).smul_of_top_left\n      ((hf.memℒp_lineDeriv (v i)).const_smul (a i))\n  rw [integral_finset_sum _ A]\n  suffices S1 : ∫ x, lineDeriv ℝ f x (∑ i ∈ s, a i • v i) * g x ∂μ\n      = ∑ i ∈ s, a i * ∫ x, lineDeriv ℝ f x (v i) * g x ∂μ by\n    dsimp only [smul_eq_mul, Pi.smul_apply]\n    simp_rw [← mul_assoc, mul_comm _ (a _), mul_assoc, integral_mul_left, mul_comm (g _), S1]\n  suffices S2 : ∫ x, (∑ i ∈ s, a i * fderiv ℝ g x (v i)) * f x ∂μ =\n                  ∑ i ∈ s, a i * ∫ x, fderiv ℝ g x (v i) * f x ∂μ by\n    obtain ⟨D, g_lip⟩ : ∃ D, LipschitzWith D g :=\n      ContDiff.lipschitzWith_of_hasCompactSupport g_comp g_smooth (mod_cast le_top)\n    simp_rw [integral_lineDeriv_mul_eq hf g_lip g_comp]\n    simp_rw [(g_smooth.differentiable (mod_cast le_top)).differentiableAt.lineDeriv_eq_fderiv]\n    simp only [map_neg, _root_.map_sum, _root_.map_smul, smul_eq_mul, neg_mul]\n    simp only [integral_neg, mul_neg, Finset.sum_neg_distrib, neg_inj]\n    exact S2\n  suffices B : ∀ i ∈ s, Integrable (fun x ↦ a i * (fderiv ℝ g x (v i) * f x)) μ by\n    simp_rw [Finset.sum_mul, mul_assoc, integral_finset_sum s B, integral_mul_left]\n  intro i _hi\n  let L : (E →L[ℝ] ℝ) → ℝ := fun f ↦ f (v i)\n  change Integrable (fun x ↦ a i * ((L ∘ (fderiv ℝ g)) x * f x)) μ\n  refine (Continuous.integrable_of_hasCompactSupport ?_ ?_).const_mul _\n  · exact ((g_smooth.continuous_fderiv (mod_cast le_top)).clm_apply continuous_const).mul\n      hf.continuous\n  · exact ((g_comp.fderiv ℝ).comp_left rfl).mul_right\n\n"}
{"name":"LipschitzWith.ae_exists_fderiv_of_countable","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\ns : Set E\nhs : s.Countable\n⊢ Filter.Eventually (fun x => Exists fun L => ∀ (v : E), Membership.mem s v → HasLineDerivAt Real f (L v) x v) (MeasureTheory.ae μ)","decl":"theorem ae_exists_fderiv_of_countable\n    (hf : LipschitzWith C f) {s : Set E} (hs : s.Countable) :\n    ∀ᵐ x ∂μ, ∃ (L : E →L[ℝ] ℝ), ∀ v ∈ s, HasLineDerivAt ℝ f (L v) x v := by\n  have B := Basis.ofVectorSpace ℝ E\n  have I1 : ∀ᵐ (x : E) ∂μ, ∀ v ∈ s, lineDeriv ℝ f x (∑ i, (B.repr v i) • B i) =\n                                  ∑ i, B.repr v i • lineDeriv ℝ f x (B i) :=\n    (ae_ball_iff hs).2 (fun v _ ↦ hf.ae_lineDeriv_sum_eq _ _ _)\n  have I2 : ∀ᵐ (x : E) ∂μ, ∀ v ∈ s, LineDifferentiableAt ℝ f x v :=\n    (ae_ball_iff hs).2 (fun v _ ↦ hf.ae_lineDifferentiableAt v)\n  filter_upwards [I1, I2] with x hx h'x\n  let L : E →L[ℝ] ℝ :=\n    LinearMap.toContinuousLinearMap (B.constr ℝ (fun i ↦ lineDeriv ℝ f x (B i)))\n  refine ⟨L, fun v hv ↦ ?_⟩\n  have J : L v = lineDeriv ℝ f x v := by convert (hx v hv).symm <;> simp [L, B.sum_repr v]\n  simpa [J] using (h'x v hv).hasLineDerivAt\n\n"}
{"name":"LipschitzWith.hasFDerivAt_of_hasLineDerivAt_of_closure","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nC : NNReal\ninst✝ : FiniteDimensional Real E\nf : E → F\nhf : LipschitzWith C f\ns : Set E\nhs : HasSubset.Subset (Metric.sphere 0 1) (closure s)\nL : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhL : ∀ (v : E), Membership.mem s v → HasLineDerivAt Real f (L v) x v\n⊢ HasFDerivAt f L x","decl":"omit [MeasurableSpace E] in\n/-- If a Lipschitz functions has line derivatives in a dense set of directions, all of them given by\na single continuous linear map `L`, then it admits `L` as Fréchet derivative. -/\ntheorem hasFDerivAt_of_hasLineDerivAt_of_closure\n    {f : E → F} (hf : LipschitzWith C f) {s : Set E} (hs : sphere 0 1 ⊆ closure s)\n    {L : E →L[ℝ] F} {x : E} (hL : ∀ v ∈ s, HasLineDerivAt ℝ f (L v) x v) :\n    HasFDerivAt f L x := by\n  rw [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]\n  intro ε εpos\n  obtain ⟨δ, δpos, hδ⟩ : ∃ δ, 0 < δ ∧ (C + ‖L‖ + 1) * δ = ε :=\n    ⟨ε / (C + ‖L‖ + 1), by positivity, mul_div_cancel₀ ε (by positivity)⟩\n  obtain ⟨q, hqs, q_fin, hq⟩ : ∃ q, q ⊆ s ∧ q.Finite ∧ sphere 0 1 ⊆ ⋃ y ∈ q, ball y δ := by\n    have : sphere 0 1 ⊆ ⋃ y ∈ s, ball y δ := by\n      apply hs.trans (fun z hz ↦ ?_)\n      obtain ⟨y, ys, hy⟩ : ∃ y ∈ s, dist z y < δ := Metric.mem_closure_iff.1 hz δ δpos\n      exact mem_biUnion ys hy\n    exact (isCompact_sphere 0 1).elim_finite_subcover_image (fun y _hy ↦ isOpen_ball) this\n  have I : ∀ᶠ t in 𝓝 (0 : ℝ), ∀ v ∈ q, ‖f (x + t • v) - f x - t • L v‖ ≤ δ * ‖t‖ := by\n    apply (Finite.eventually_all q_fin).2 (fun v hv ↦ ?_)\n    apply Asymptotics.IsLittleO.def ?_ δpos\n    exact hasLineDerivAt_iff_isLittleO_nhds_zero.1 (hL v (hqs hv))\n  obtain ⟨r, r_pos, hr⟩ : ∃ (r : ℝ), 0 < r ∧ ∀ (t : ℝ), ‖t‖ < r →\n      ∀ v ∈ q, ‖f (x + t • v) - f x - t • L v‖ ≤ δ * ‖t‖ := by\n    rcases Metric.mem_nhds_iff.1 I with ⟨r, r_pos, hr⟩\n    exact ⟨r, r_pos, fun t ht v hv ↦ hr (mem_ball_zero_iff.2 ht) v hv⟩\n  apply Metric.mem_nhds_iff.2 ⟨r, r_pos, fun v hv ↦ ?_⟩\n  rcases eq_or_ne v 0 with rfl|v_ne\n  · simp\n  obtain ⟨w, ρ, w_mem, hvw, hρ⟩ : ∃ w ρ, w ∈ sphere 0 1 ∧ v = ρ • w ∧ ρ = ‖v‖ := by\n    refine ⟨‖v‖⁻¹ • v, ‖v‖, by simp [norm_smul, inv_mul_cancel₀ (norm_ne_zero_iff.2 v_ne)], ?_, rfl⟩\n    simp [smul_smul, mul_inv_cancel₀ (norm_ne_zero_iff.2 v_ne)]\n  have norm_rho : ‖ρ‖ = ρ := by rw [hρ, norm_norm]\n  have rho_pos : 0 ≤ ρ := by simp [hρ]\n  obtain ⟨y, yq, hy⟩ : ∃ y ∈ q, ‖w - y‖ < δ := by simpa [← dist_eq_norm] using hq w_mem\n  have : ‖y - w‖ < δ := by rwa [norm_sub_rev]\n  calc  ‖f (x + v) - f x - L v‖\n      = ‖f (x + ρ • w) - f x - ρ • L w‖ := by simp [hvw]\n    _ = ‖(f (x + ρ • w) - f (x + ρ • y)) + (ρ • L y - ρ • L w)\n          + (f (x + ρ • y) - f x - ρ • L y)‖ := by congr; abel\n    _ ≤ ‖f (x + ρ • w) - f (x + ρ • y)‖ + ‖ρ • L y - ρ • L w‖\n          + ‖f (x + ρ • y) - f x - ρ • L y‖ := norm_add₃_le\n    _ ≤ C * ‖(x + ρ • w) - (x + ρ • y)‖ + ρ * (‖L‖ * ‖y - w‖) + δ * ρ := by\n      gcongr\n      · exact hf.norm_sub_le _ _\n      · rw [← smul_sub, norm_smul, norm_rho]\n        gcongr\n        exact L.lipschitz.norm_sub_le _ _\n      · conv_rhs => rw [← norm_rho]\n        apply hr _ _ _ yq\n        simpa [norm_rho, hρ] using hv\n    _ ≤ C * (ρ * δ) + ρ * (‖L‖ * δ) + δ * ρ := by\n      simp only [add_sub_add_left_eq_sub, ← smul_sub, norm_smul, norm_rho]; gcongr\n    _ = ((C + ‖L‖ + 1) * δ) * ρ := by ring\n    _ = ε * ‖v‖ := by rw [hδ, hρ]\n\n"}
{"name":"LipschitzWith.hasFderivAt_of_hasLineDerivAt_of_closure","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real F\nC : NNReal\ninst✝ : FiniteDimensional Real E\nf : E → F\nhf : LipschitzWith C f\ns : Set E\nhs : HasSubset.Subset (Metric.sphere 0 1) (closure s)\nL : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhL : ∀ (v : E), Membership.mem s v → HasLineDerivAt Real f (L v) x v\n⊢ HasFDerivAt f L x","decl":"@[deprecated (since := \"2025-01-15\")]\nalias hasFderivAt_of_hasLineDerivAt_of_closure := hasFDerivAt_of_hasLineDerivAt_of_closure\n\n"}
{"name":"LipschitzWith.ae_differentiableAt_of_real","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzWith C f\n⊢ Filter.Eventually (fun x => DifferentiableAt Real f x) (MeasureTheory.ae μ)","decl":"/-- A real-valued function on a finite-dimensional space which is Lipschitz is\ndifferentiable almost everywere. Superseded by\n`LipschitzWith.ae_differentiableAt` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableAt_of_real (hf : LipschitzWith C f) :\n    ∀ᵐ x ∂μ, DifferentiableAt ℝ f x := by\n  obtain ⟨s, s_count, s_dense⟩ : ∃ (s : Set E), s.Countable ∧ Dense s :=\n    TopologicalSpace.exists_countable_dense E\n  have hs : sphere 0 1 ⊆ closure s := by rw [s_dense.closure_eq]; exact subset_univ _\n  filter_upwards [hf.ae_exists_fderiv_of_countable s_count]\n  rintro x ⟨L, hL⟩\n  exact (hf.hasFDerivAt_of_hasLineDerivAt_of_closure hs hL).differentiableAt\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem_of_real","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nC : NNReal\nf : E → Real\ns : Set E\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\nhf : LipschitzOnWith C f s\n⊢ Filter.Eventually (fun x => Membership.mem s x → DifferentiableWithinAt Real f s x) (MeasureTheory.ae μ)","decl":"/-- A real-valued function on a finite-dimensional space which is Lipschitz on a set is\ndifferentiable almost everywere in this set. Superseded by\n`LipschitzOnWith.ae_differentiableWithinAt_of_mem` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableWithinAt_of_mem_of_real (hf : LipschitzOnWith C f s) :\n    ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ f s x := by\n  obtain ⟨g, g_lip, hg⟩ : ∃ (g : E → ℝ), LipschitzWith C g ∧ EqOn f g s := hf.extend_real\n  filter_upwards [g_lip.ae_differentiableAt_of_real] with x hx xs\n  exact hx.differentiableWithinAt.congr hg (hg xs)\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem_pi","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nC : NNReal\nμ : MeasureTheory.Measure E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : μ.IsAddHaarMeasure\nι : Type u_3\ninst✝ : Fintype ι\nf : E → ι → Real\ns : Set E\nhf : LipschitzOnWith C f s\n⊢ Filter.Eventually (fun x => Membership.mem s x → DifferentiableWithinAt Real f s x) (MeasureTheory.ae μ)","decl":"/-- A function on a finite-dimensional space which is Lipschitz on a set and taking values in a\nproduct space is differentiable almost everywere in this set. Superseded by\n`LipschitzOnWith.ae_differentiableWithinAt_of_mem` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableWithinAt_of_mem_pi\n    {ι : Type*} [Fintype ι] {f : E → ι → ℝ} {s : Set E}\n    (hf : LipschitzOnWith C f s) : ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ f s x := by\n  have A : ∀ i : ι, LipschitzWith 1 (fun x : ι → ℝ ↦ x i) := fun i => LipschitzWith.eval i\n  have : ∀ i : ι, ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ (fun x : E ↦ f x i) s x := fun i ↦ by\n    apply ae_differentiableWithinAt_of_mem_of_real\n    exact LipschitzWith.comp_lipschitzOnWith (A i) hf\n  filter_upwards [ae_all_iff.2 this] with x hx xs\n  exact differentiableWithinAt_pi.2 (fun i ↦ hx i xs)\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\nF : Type u_2\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nC : NNReal\ns : Set E\nμ : MeasureTheory.Measure E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : FiniteDimensional Real F\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nhf : LipschitzOnWith C f s\n⊢ Filter.Eventually (fun x => Membership.mem s x → DifferentiableWithinAt Real f s x) (MeasureTheory.ae μ)","decl":"/-- *Rademacher's theorem*: a function between finite-dimensional real vector spaces which is\nLipschitz on a set is differentiable almost everywere in this set. -/\ntheorem ae_differentiableWithinAt_of_mem {f : E → F} (hf : LipschitzOnWith C f s) :\n    ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ f s x := by\n  have A := (Basis.ofVectorSpace ℝ F).equivFun.toContinuousLinearEquiv\n  suffices H : ∀ᵐ x ∂μ, x ∈ s → DifferentiableWithinAt ℝ (A ∘ f) s x by\n    filter_upwards [H] with x hx xs\n    have : f = (A.symm ∘ A) ∘ f := by\n      simp only [ContinuousLinearEquiv.symm_comp_self, Function.id_comp]\n    rw [this]\n    exact A.symm.differentiableAt.comp_differentiableWithinAt x (hx xs)\n  apply ae_differentiableWithinAt_of_mem_pi\n  exact A.lipschitz.comp_lipschitzOnWith hf\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\nF : Type u_2\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nC : NNReal\ns : Set E\nμ : MeasureTheory.Measure E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : FiniteDimensional Real F\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nhf : LipschitzOnWith C f s\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => DifferentiableWithinAt Real f s x) (MeasureTheory.ae (μ.restrict s))","decl":"/-- *Rademacher's theorem*: a function between finite-dimensional real vector spaces which is\nLipschitz on a set is differentiable almost everywere in this set. -/\ntheorem ae_differentiableWithinAt {f : E → F} (hf : LipschitzOnWith C f s)\n    (hs : MeasurableSet s) :\n    ∀ᵐ x ∂(μ.restrict s), DifferentiableWithinAt ℝ f s x := by\n  rw [ae_restrict_iff' hs]\n  exact hf.ae_differentiableWithinAt_of_mem\n\n"}
{"name":"LipschitzWith.ae_differentiableAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\nF : Type u_2\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real F\nC : NNReal\nμ : MeasureTheory.Measure E\ninst✝² : FiniteDimensional Real E\ninst✝¹ : FiniteDimensional Real F\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nh : LipschitzWith C f\n⊢ Filter.Eventually (fun x => DifferentiableAt Real f x) (MeasureTheory.ae μ)","decl":"/-- *Rademacher's theorem*: a Lipschitz function between finite-dimensional real vector spaces is\ndifferentiable almost everywhere. -/\ntheorem LipschitzWith.ae_differentiableAt {f : E → F} (h : LipschitzWith C f) :\n    ∀ᵐ x ∂μ, DifferentiableAt ℝ f x := by\n  rw [← lipschitzOnWith_univ] at h\n  simpa [differentiableWithinAt_univ] using h.ae_differentiableWithinAt_of_mem\n\n"}
{"name":"ae_differentiableAt_norm","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nμ : MeasureTheory.Measure E\ninst✝¹ : FiniteDimensional Real E\ninst✝ : μ.IsAddHaarMeasure\n⊢ Filter.Eventually (fun x => DifferentiableAt Real (fun x => Norm.norm x) x) (MeasureTheory.ae μ)","decl":"/-- In a real finite-dimensional normed vector space,\n  the norm is almost everywhere differentiable. -/\ntheorem ae_differentiableAt_norm :\n    ∀ᵐ x ∂μ, DifferentiableAt ℝ (‖·‖) x := lipschitzWith_one_norm.ae_differentiableAt\n\n"}
{"name":"dense_differentiableAt_norm","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : FiniteDimensional Real E\n⊢ Dense (setOf fun x => DifferentiableAt Real (fun x => Norm.norm x) x)","decl":"omit [MeasurableSpace E] in\n/-- In a real finite-dimensional normed vector space,\n  the set of points where the norm is differentiable at is dense. -/\ntheorem dense_differentiableAt_norm :\n    Dense {x : E | DifferentiableAt ℝ (‖·‖) x} :=\n  let _ : MeasurableSpace E := borel E\n  have _ : BorelSpace E := ⟨rfl⟩\n  let w := Basis.ofVectorSpace ℝ E\n  MeasureTheory.Measure.dense_of_ae (ae_differentiableAt_norm (μ := w.addHaar))\n"}
