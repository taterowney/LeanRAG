{"name":"LipschitzWith.memâ„’p_lineDeriv","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\nhf : LipschitzWith C f\nv : E\nâŠ¢ MeasureTheory.Memâ„’p (fun x => lineDeriv Real f x v) Top.top Î¼","decl":"theorem memâ„’p_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    Memâ„’p (fun x â†¦ lineDeriv â„ f x v) âˆ Î¼ :=\n  memâ„’p_top_of_bound (aestronglyMeasurable_lineDeriv hf.continuous Î¼)\n    (C * â€–vâ€–) (.of_forall fun _x â†¦ norm_lineDeriv_le_of_lipschitz â„ hf)\n\n"}
{"name":"LipschitzWith.ae_lineDifferentiableAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nv : E\nâŠ¢ Filter.Eventually (fun p => LineDifferentiableAt Real f p v) (MeasureTheory.ae Î¼)","decl":"theorem ae_lineDifferentiableAt\n    (hf : LipschitzWith C f) (v : E) :\n    âˆ€áµ p âˆ‚Î¼, LineDifferentiableAt â„ f p v := by\n  let L : â„ â†’L[â„] E := ContinuousLinearMap.smulRight (1 : â„ â†’L[â„] â„) v\n  suffices A : âˆ€ p, âˆ€áµ (t : â„) âˆ‚volume, LineDifferentiableAt â„ f (p + t â€¢ v) v from\n    ae_mem_of_ae_add_linearMap_mem L.toLinearMap volume Î¼\n      (measurableSet_lineDifferentiableAt hf.continuous) A\n  intro p\n  have : âˆ€áµ (s : â„), DifferentiableAt â„ (fun t â†¦ f (p + t â€¢ v)) s :=\n    (hf.comp ((LipschitzWith.const p).add L.lipschitz)).ae_differentiableAt_real\n  filter_upwards [this] with s hs\n  have h's : DifferentiableAt â„ (fun t â†¦ f (p + t â€¢ v)) (s + 0) := by simpa using hs\n  have : DifferentiableAt â„ (fun t â†¦ s + t) 0 := differentiableAt_id.const_add _\n  simp only [LineDifferentiableAt]\n  convert h's.comp 0 this with _ t\n  simp only [LineDifferentiableAt, add_assoc, Function.comp_apply, add_smul]\n\n"}
{"name":"LipschitzWith.locallyIntegrable_lineDeriv","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nv : E\nâŠ¢ MeasureTheory.LocallyIntegrable (fun x => lineDeriv Real f x v) Î¼","decl":"theorem locallyIntegrable_lineDeriv (hf : LipschitzWith C f) (v : E) :\n    LocallyIntegrable (fun x â†¦ lineDeriv â„ f x v) Î¼ :=\n  (hf.memâ„’p_lineDeriv v).locallyIntegrable le_top\n\n"}
{"name":"LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf g : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nhg : MeasureTheory.Integrable g Î¼\nv : E\nâŠ¢ Filter.Tendsto (fun t => MeasureTheory.integral Î¼ fun x => HMul.hMul (HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul t v))) (f x))) (g x)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (MeasureTheory.integral Î¼ fun x => HMul.hMul (lineDeriv Real f x v) (g x)))","decl":"theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul\n    (hf : LipschitzWith C f) (hg : Integrable g Î¼) (v : E) :\n    Tendsto (fun (t : â„) â†¦ âˆ« x, (tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x)) * g x âˆ‚Î¼) (ğ“[>] 0)\n      (ğ“ (âˆ« x, lineDeriv â„ f x v * g x âˆ‚Î¼)) := by\n  apply tendsto_integral_filter_of_dominated_convergence (fun x â†¦ (C * â€–vâ€–) * â€–g xâ€–)\n  Â· filter_upwards with t\n    apply AEStronglyMeasurable.mul ?_ hg.aestronglyMeasurable\n    apply aestronglyMeasurable_const.smul\n    apply AEStronglyMeasurable.sub _ hf.continuous.measurable.aestronglyMeasurable\n    apply AEMeasurable.aestronglyMeasurable\n    exact hf.continuous.measurable.comp_aemeasurable' (aemeasurable_id'.add_const _)\n  Â· filter_upwards [self_mem_nhdsWithin] with t (ht : 0 < t)\n    filter_upwards with x\n    calc â€–tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x) * g xâ€–\n      = (tâ»Â¹ * â€–f (x + t â€¢ v) - f xâ€–) * â€–g xâ€– := by simp [norm_mul, ht.le]\n    _ â‰¤ (tâ»Â¹ * (C * â€–(x + t â€¢ v) - xâ€–)) * â€–g xâ€– := by\n      gcongr; exact LipschitzWith.norm_sub_le hf (x + t â€¢ v) x\n    _ = (C * â€–vâ€–) *â€–g xâ€– := by field_simp [norm_smul, abs_of_nonneg ht.le]; ring\n  Â· exact hg.norm.const_mul _\n  Â· filter_upwards [hf.ae_lineDifferentiableAt v] with x hx\n    exact hx.hasLineDerivAt.tendsto_slope_zero_right.mul tendsto_const_nhds\n\n"}
{"name":"LipschitzWith.integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf g : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nh'f : HasCompactSupport f\nhg : Continuous g\nv : E\nâŠ¢ Filter.Tendsto (fun t => MeasureTheory.integral Î¼ fun x => HMul.hMul (HSMul.hSMul (Inv.inv t) (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul t v))) (f x))) (g x)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (MeasureTheory.integral Î¼ fun x => HMul.hMul (lineDeriv Real f x v) (g x)))","decl":"theorem integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul'\n    (hf : LipschitzWith C f) (h'f : HasCompactSupport f) (hg : Continuous g) (v : E) :\n    Tendsto (fun (t : â„) â†¦ âˆ« x, (tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x)) * g x âˆ‚Î¼) (ğ“[>] 0)\n      (ğ“ (âˆ« x, lineDeriv â„ f x v * g x âˆ‚Î¼)) := by\n  let K := cthickening (â€–vâ€–) (tsupport f)\n  have K_compact : IsCompact K := IsCompact.cthickening h'f\n  apply tendsto_integral_filter_of_dominated_convergence\n      (K.indicator (fun x â†¦ (C * â€–vâ€–) * â€–g xâ€–))\n  Â· filter_upwards with t\n    apply AEStronglyMeasurable.mul ?_ hg.aestronglyMeasurable\n    apply aestronglyMeasurable_const.smul\n    apply AEStronglyMeasurable.sub _ hf.continuous.measurable.aestronglyMeasurable\n    apply AEMeasurable.aestronglyMeasurable\n    exact hf.continuous.measurable.comp_aemeasurable' (aemeasurable_id'.add_const _)\n  Â· filter_upwards [Ioc_mem_nhdsGT zero_lt_one] with t ht\n    have t_pos : 0 < t := ht.1\n    filter_upwards with x\n    by_cases hx : x âˆˆ K\n    Â· calc â€–tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x) * g xâ€–\n        = (tâ»Â¹ * â€–f (x + t â€¢ v) - f xâ€–) * â€–g xâ€– := by simp [norm_mul, t_pos.le]\n      _ â‰¤ (tâ»Â¹ * (C * â€–(x + t â€¢ v) - xâ€–)) * â€–g xâ€– := by\n        gcongr; exact LipschitzWith.norm_sub_le hf (x + t â€¢ v) x\n      _ = (C * â€–vâ€–) *â€–g xâ€– := by field_simp [norm_smul, abs_of_nonneg t_pos.le]; ring\n      _ = K.indicator (fun x â†¦ (C * â€–vâ€–) * â€–g xâ€–) x := by rw [indicator_of_mem hx]\n    Â· have A : f x = 0 := by\n        rw [â† Function.nmem_support]\n        contrapose! hx\n        exact self_subset_cthickening _ (subset_tsupport _ hx)\n      have B : f (x + t â€¢ v) = 0 := by\n        rw [â† Function.nmem_support]\n        contrapose! hx\n        apply mem_cthickening_of_dist_le _ _ (â€–vâ€–) (tsupport f) (subset_tsupport _ hx)\n        simp only [dist_eq_norm, sub_add_cancel_left, norm_neg, norm_smul, Real.norm_eq_abs,\n          abs_of_nonneg t_pos.le, norm_pos_iff]\n        exact mul_le_of_le_one_left (norm_nonneg v) ht.2\n      simp only [B, A, _root_.sub_self, smul_eq_mul, mul_zero, zero_mul, norm_zero]\n      exact indicator_nonneg (fun y _hy â†¦ by positivity) _\n  Â· rw [integrable_indicator_iff K_compact.measurableSet]\n    apply ContinuousOn.integrableOn_compact K_compact\n    exact (Continuous.mul continuous_const hg.norm).continuousOn\n  Â· filter_upwards [hf.ae_lineDifferentiableAt v] with x hx\n    exact hx.hasLineDerivAt.tendsto_slope_zero_right.mul tendsto_const_nhds\n\n"}
{"name":"LipschitzWith.integral_lineDeriv_mul_eq","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC D : NNReal\nf g : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nhg : LipschitzWith D g\nh'g : HasCompactSupport g\nv : E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HMul.hMul (lineDeriv Real f x v) (g x)) (MeasureTheory.integral Î¼ fun x => HMul.hMul (lineDeriv Real g x (Neg.neg v)) (f x))","decl":"/-- Integration by parts formula for the line derivative of Lipschitz functions, assuming one of\nthem is compactly supported. -/\ntheorem integral_lineDeriv_mul_eq\n    (hf : LipschitzWith C f) (hg : LipschitzWith D g) (h'g : HasCompactSupport g) (v : E) :\n    âˆ« x, lineDeriv â„ f x v * g x âˆ‚Î¼ = âˆ« x, lineDeriv â„ g x (-v) * f x âˆ‚Î¼ := by\n  /- Write down the line derivative as the limit of `(f (x + t v) - f x) / t` and\n  `(g (x - t v) - g x) / t`, and therefore the integrals as limits of the corresponding integrals\n  thanks to the dominated convergence theorem. At fixed positive `t`, the integrals coincide\n  (with the change of variables `y = x + t v`), so the limits also coincide. -/\n  have A : Tendsto (fun (t : â„) â†¦ âˆ« x, (tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x)) * g x âˆ‚Î¼) (ğ“[>] 0)\n              (ğ“ (âˆ« x, lineDeriv â„ f x v * g x âˆ‚Î¼)) :=\n    integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul\n      hf (hg.continuous.integrable_of_hasCompactSupport h'g) v\n  have B : Tendsto (fun (t : â„) â†¦ âˆ« x, (tâ»Â¹ â€¢ (g (x + t â€¢ (-v)) - g x)) * f x âˆ‚Î¼) (ğ“[>] 0)\n              (ğ“ (âˆ« x, lineDeriv â„ g x (-v) * f x âˆ‚Î¼)) :=\n    integral_inv_smul_sub_mul_tendsto_integral_lineDeriv_mul' hg h'g hf.continuous (-v)\n  suffices S1 : âˆ€ (t : â„), âˆ« x, (tâ»Â¹ â€¢ (f (x + t â€¢ v) - f x)) * g x âˆ‚Î¼ =\n                            âˆ« x, (tâ»Â¹ â€¢ (g (x + t â€¢ (-v)) - g x)) * f x âˆ‚Î¼ by\n    simp only [S1] at A; exact tendsto_nhds_unique A B\n  intro t\n  suffices S2 : âˆ« x, (f (x + t â€¢ v) - f x) * g x âˆ‚Î¼ = âˆ« x, f x * (g (x + t â€¢ (-v)) - g x) âˆ‚Î¼ by\n    simp only [smul_eq_mul, mul_assoc, integral_mul_left, S2, mul_neg, mul_comm (f _)]\n  have S3 : âˆ« x, f (x + t â€¢ v) * g x âˆ‚Î¼ = âˆ« x, f x * g (x + t â€¢ (-v)) âˆ‚Î¼ := by\n    rw [â† integral_add_right_eq_self _ (t â€¢ (-v))]; simp\n  simp_rw [_root_.sub_mul, _root_.mul_sub]\n  rw [integral_sub, integral_sub, S3]\n  Â· apply Continuous.integrable_of_hasCompactSupport\n    Â· exact hf.continuous.mul (hg.continuous.comp (continuous_add_right _))\n    Â· exact (h'g.comp_homeomorph (Homeomorph.addRight (t â€¢ (-v)))).mul_left\n  Â· exact (hf.continuous.mul hg.continuous).integrable_of_hasCompactSupport h'g.mul_left\n  Â· apply Continuous.integrable_of_hasCompactSupport\n    Â· exact (hf.continuous.comp (continuous_add_right _)).mul hg.continuous\n    Â· exact h'g.mul_left\n  Â· exact (hf.continuous.mul hg.continuous).integrable_of_hasCompactSupport h'g.mul_left\n\n"}
{"name":"LipschitzWith.ae_lineDeriv_sum_eq","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nÎ¹ : Type u_3\ns : Finset Î¹\na : Î¹ â†’ Real\nv : Î¹ â†’ E\nâŠ¢ Filter.Eventually (fun x => Eq (lineDeriv Real f x (s.sum fun i => HSMul.hSMul (a i) (v i))) (s.sum fun i => HSMul.hSMul (a i) (lineDeriv Real f x (v i)))) (MeasureTheory.ae Î¼)","decl":"/-- The line derivative of a Lipschitz function is almost everywhere linear with respect to fixed\ncoefficients. -/\ntheorem ae_lineDeriv_sum_eq\n    (hf : LipschitzWith C f) {Î¹ : Type*} (s : Finset Î¹) (a : Î¹ â†’ â„) (v : Î¹ â†’ E) :\n    âˆ€áµ x âˆ‚Î¼, lineDeriv â„ f x (âˆ‘ i âˆˆ s, a i â€¢ v i) = âˆ‘ i âˆˆ s, a i â€¢ lineDeriv â„ f x (v i) := by\n  /- Clever argument by Morrey: integrate against a smooth compactly supported function `g`, switch\n  the derivative to `g` by integration by parts, and use the linearity of the derivative of `g` to\n  conclude that the initial integrals coincide. -/\n  apply ae_eq_of_integral_contDiff_smul_eq (hf.locallyIntegrable_lineDeriv _)\n    (locallyIntegrable_finset_sum _ (fun i hi â†¦ (hf.locallyIntegrable_lineDeriv (v i)).smul (a i)))\n    (fun g g_smooth g_comp â†¦ ?_)\n  simp_rw [Finset.smul_sum]\n  have A : âˆ€ i âˆˆ s, Integrable (fun x â†¦ g x â€¢ (a i â€¢ fun x â†¦ lineDeriv â„ f x (v i)) x) Î¼ :=\n    fun i hi â†¦ (g_smooth.continuous.integrable_of_hasCompactSupport g_comp).smul_of_top_left\n      ((hf.memâ„’p_lineDeriv (v i)).const_smul (a i))\n  rw [integral_finset_sum _ A]\n  suffices S1 : âˆ« x, lineDeriv â„ f x (âˆ‘ i âˆˆ s, a i â€¢ v i) * g x âˆ‚Î¼\n      = âˆ‘ i âˆˆ s, a i * âˆ« x, lineDeriv â„ f x (v i) * g x âˆ‚Î¼ by\n    dsimp only [smul_eq_mul, Pi.smul_apply]\n    simp_rw [â† mul_assoc, mul_comm _ (a _), mul_assoc, integral_mul_left, mul_comm (g _), S1]\n  suffices S2 : âˆ« x, (âˆ‘ i âˆˆ s, a i * fderiv â„ g x (v i)) * f x âˆ‚Î¼ =\n                  âˆ‘ i âˆˆ s, a i * âˆ« x, fderiv â„ g x (v i) * f x âˆ‚Î¼ by\n    obtain âŸ¨D, g_lipâŸ© : âˆƒ D, LipschitzWith D g :=\n      ContDiff.lipschitzWith_of_hasCompactSupport g_comp g_smooth (mod_cast le_top)\n    simp_rw [integral_lineDeriv_mul_eq hf g_lip g_comp]\n    simp_rw [(g_smooth.differentiable (mod_cast le_top)).differentiableAt.lineDeriv_eq_fderiv]\n    simp only [map_neg, _root_.map_sum, _root_.map_smul, smul_eq_mul, neg_mul]\n    simp only [integral_neg, mul_neg, Finset.sum_neg_distrib, neg_inj]\n    exact S2\n  suffices B : âˆ€ i âˆˆ s, Integrable (fun x â†¦ a i * (fderiv â„ g x (v i) * f x)) Î¼ by\n    simp_rw [Finset.sum_mul, mul_assoc, integral_finset_sum s B, integral_mul_left]\n  intro i _hi\n  let L : (E â†’L[â„] â„) â†’ â„ := fun f â†¦ f (v i)\n  change Integrable (fun x â†¦ a i * ((L âˆ˜ (fderiv â„ g)) x * f x)) Î¼\n  refine (Continuous.integrable_of_hasCompactSupport ?_ ?_).const_mul _\n  Â· exact ((g_smooth.continuous_fderiv (mod_cast le_top)).clm_apply continuous_const).mul\n      hf.continuous\n  Â· exact ((g_comp.fderiv â„).comp_left rfl).mul_right\n\n"}
{"name":"LipschitzWith.ae_exists_fderiv_of_countable","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\ns : Set E\nhs : s.Countable\nâŠ¢ Filter.Eventually (fun x => Exists fun L => âˆ€ (v : E), Membership.mem s v â†’ HasLineDerivAt Real f (L v) x v) (MeasureTheory.ae Î¼)","decl":"theorem ae_exists_fderiv_of_countable\n    (hf : LipschitzWith C f) {s : Set E} (hs : s.Countable) :\n    âˆ€áµ x âˆ‚Î¼, âˆƒ (L : E â†’L[â„] â„), âˆ€ v âˆˆ s, HasLineDerivAt â„ f (L v) x v := by\n  have B := Basis.ofVectorSpace â„ E\n  have I1 : âˆ€áµ (x : E) âˆ‚Î¼, âˆ€ v âˆˆ s, lineDeriv â„ f x (âˆ‘ i, (B.repr v i) â€¢ B i) =\n                                  âˆ‘ i, B.repr v i â€¢ lineDeriv â„ f x (B i) :=\n    (ae_ball_iff hs).2 (fun v _ â†¦ hf.ae_lineDeriv_sum_eq _ _ _)\n  have I2 : âˆ€áµ (x : E) âˆ‚Î¼, âˆ€ v âˆˆ s, LineDifferentiableAt â„ f x v :=\n    (ae_ball_iff hs).2 (fun v _ â†¦ hf.ae_lineDifferentiableAt v)\n  filter_upwards [I1, I2] with x hx h'x\n  let L : E â†’L[â„] â„ :=\n    LinearMap.toContinuousLinearMap (B.constr â„ (fun i â†¦ lineDeriv â„ f x (B i)))\n  refine âŸ¨L, fun v hv â†¦ ?_âŸ©\n  have J : L v = lineDeriv â„ f x v := by convert (hx v hv).symm <;> simp [L, B.sum_repr v]\n  simpa [J] using (h'x v hv).hasLineDerivAt\n\n"}
{"name":"LipschitzWith.hasFDerivAt_of_hasLineDerivAt_of_closure","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nC : NNReal\ninstâœ : FiniteDimensional Real E\nf : E â†’ F\nhf : LipschitzWith C f\ns : Set E\nhs : HasSubset.Subset (Metric.sphere 0 1) (closure s)\nL : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhL : âˆ€ (v : E), Membership.mem s v â†’ HasLineDerivAt Real f (L v) x v\nâŠ¢ HasFDerivAt f L x","decl":"omit [MeasurableSpace E] in\n/-- If a Lipschitz functions has line derivatives in a dense set of directions, all of them given by\na single continuous linear map `L`, then it admits `L` as FrÃ©chet derivative. -/\ntheorem hasFDerivAt_of_hasLineDerivAt_of_closure\n    {f : E â†’ F} (hf : LipschitzWith C f) {s : Set E} (hs : sphere 0 1 âŠ† closure s)\n    {L : E â†’L[â„] F} {x : E} (hL : âˆ€ v âˆˆ s, HasLineDerivAt â„ f (L v) x v) :\n    HasFDerivAt f L x := by\n  rw [hasFDerivAt_iff_isLittleO_nhds_zero, isLittleO_iff]\n  intro Îµ Îµpos\n  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ Î´, 0 < Î´ âˆ§ (C + â€–Lâ€– + 1) * Î´ = Îµ :=\n    âŸ¨Îµ / (C + â€–Lâ€– + 1), by positivity, mul_div_cancelâ‚€ Îµ (by positivity)âŸ©\n  obtain âŸ¨q, hqs, q_fin, hqâŸ© : âˆƒ q, q âŠ† s âˆ§ q.Finite âˆ§ sphere 0 1 âŠ† â‹ƒ y âˆˆ q, ball y Î´ := by\n    have : sphere 0 1 âŠ† â‹ƒ y âˆˆ s, ball y Î´ := by\n      apply hs.trans (fun z hz â†¦ ?_)\n      obtain âŸ¨y, ys, hyâŸ© : âˆƒ y âˆˆ s, dist z y < Î´ := Metric.mem_closure_iff.1 hz Î´ Î´pos\n      exact mem_biUnion ys hy\n    exact (isCompact_sphere 0 1).elim_finite_subcover_image (fun y _hy â†¦ isOpen_ball) this\n  have I : âˆ€á¶  t in ğ“ (0 : â„), âˆ€ v âˆˆ q, â€–f (x + t â€¢ v) - f x - t â€¢ L vâ€– â‰¤ Î´ * â€–tâ€– := by\n    apply (Finite.eventually_all q_fin).2 (fun v hv â†¦ ?_)\n    apply Asymptotics.IsLittleO.def ?_ Î´pos\n    exact hasLineDerivAt_iff_isLittleO_nhds_zero.1 (hL v (hqs hv))\n  obtain âŸ¨r, r_pos, hrâŸ© : âˆƒ (r : â„), 0 < r âˆ§ âˆ€ (t : â„), â€–tâ€– < r â†’\n      âˆ€ v âˆˆ q, â€–f (x + t â€¢ v) - f x - t â€¢ L vâ€– â‰¤ Î´ * â€–tâ€– := by\n    rcases Metric.mem_nhds_iff.1 I with âŸ¨r, r_pos, hrâŸ©\n    exact âŸ¨r, r_pos, fun t ht v hv â†¦ hr (mem_ball_zero_iff.2 ht) v hvâŸ©\n  apply Metric.mem_nhds_iff.2 âŸ¨r, r_pos, fun v hv â†¦ ?_âŸ©\n  rcases eq_or_ne v 0 with rfl|v_ne\n  Â· simp\n  obtain âŸ¨w, Ï, w_mem, hvw, hÏâŸ© : âˆƒ w Ï, w âˆˆ sphere 0 1 âˆ§ v = Ï â€¢ w âˆ§ Ï = â€–vâ€– := by\n    refine âŸ¨â€–vâ€–â»Â¹ â€¢ v, â€–vâ€–, by simp [norm_smul, inv_mul_cancelâ‚€ (norm_ne_zero_iff.2 v_ne)], ?_, rflâŸ©\n    simp [smul_smul, mul_inv_cancelâ‚€ (norm_ne_zero_iff.2 v_ne)]\n  have norm_rho : â€–Ïâ€– = Ï := by rw [hÏ, norm_norm]\n  have rho_pos : 0 â‰¤ Ï := by simp [hÏ]\n  obtain âŸ¨y, yq, hyâŸ© : âˆƒ y âˆˆ q, â€–w - yâ€– < Î´ := by simpa [â† dist_eq_norm] using hq w_mem\n  have : â€–y - wâ€– < Î´ := by rwa [norm_sub_rev]\n  calc  â€–f (x + v) - f x - L vâ€–\n      = â€–f (x + Ï â€¢ w) - f x - Ï â€¢ L wâ€– := by simp [hvw]\n    _ = â€–(f (x + Ï â€¢ w) - f (x + Ï â€¢ y)) + (Ï â€¢ L y - Ï â€¢ L w)\n          + (f (x + Ï â€¢ y) - f x - Ï â€¢ L y)â€– := by congr; abel\n    _ â‰¤ â€–f (x + Ï â€¢ w) - f (x + Ï â€¢ y)â€– + â€–Ï â€¢ L y - Ï â€¢ L wâ€–\n          + â€–f (x + Ï â€¢ y) - f x - Ï â€¢ L yâ€– := norm_addâ‚ƒ_le\n    _ â‰¤ C * â€–(x + Ï â€¢ w) - (x + Ï â€¢ y)â€– + Ï * (â€–Lâ€– * â€–y - wâ€–) + Î´ * Ï := by\n      gcongr\n      Â· exact hf.norm_sub_le _ _\n      Â· rw [â† smul_sub, norm_smul, norm_rho]\n        gcongr\n        exact L.lipschitz.norm_sub_le _ _\n      Â· conv_rhs => rw [â† norm_rho]\n        apply hr _ _ _ yq\n        simpa [norm_rho, hÏ] using hv\n    _ â‰¤ C * (Ï * Î´) + Ï * (â€–Lâ€– * Î´) + Î´ * Ï := by\n      simp only [add_sub_add_left_eq_sub, â† smul_sub, norm_smul, norm_rho]; gcongr\n    _ = ((C + â€–Lâ€– + 1) * Î´) * Ï := by ring\n    _ = Îµ * â€–vâ€– := by rw [hÎ´, hÏ]\n\n"}
{"name":"LipschitzWith.hasFderivAt_of_hasLineDerivAt_of_closure","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nF : Type u_2\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nC : NNReal\ninstâœ : FiniteDimensional Real E\nf : E â†’ F\nhf : LipschitzWith C f\ns : Set E\nhs : HasSubset.Subset (Metric.sphere 0 1) (closure s)\nL : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhL : âˆ€ (v : E), Membership.mem s v â†’ HasLineDerivAt Real f (L v) x v\nâŠ¢ HasFDerivAt f L x","decl":"@[deprecated (since := \"2025-01-15\")]\nalias hasFderivAt_of_hasLineDerivAt_of_closure := hasFDerivAt_of_hasLineDerivAt_of_closure\n\n"}
{"name":"LipschitzWith.ae_differentiableAt_of_real","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzWith C f\nâŠ¢ Filter.Eventually (fun x => DifferentiableAt Real f x) (MeasureTheory.ae Î¼)","decl":"/-- A real-valued function on a finite-dimensional space which is Lipschitz is\ndifferentiable almost everywere. Superseded by\n`LipschitzWith.ae_differentiableAt` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableAt_of_real (hf : LipschitzWith C f) :\n    âˆ€áµ x âˆ‚Î¼, DifferentiableAt â„ f x := by\n  obtain âŸ¨s, s_count, s_denseâŸ© : âˆƒ (s : Set E), s.Countable âˆ§ Dense s :=\n    TopologicalSpace.exists_countable_dense E\n  have hs : sphere 0 1 âŠ† closure s := by rw [s_dense.closure_eq]; exact subset_univ _\n  filter_upwards [hf.ae_exists_fderiv_of_countable s_count]\n  rintro x âŸ¨L, hLâŸ©\n  exact (hf.hasFDerivAt_of_hasLineDerivAt_of_closure hs hL).differentiableAt\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem_of_real","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nC : NNReal\nf : E â†’ Real\ns : Set E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : LipschitzOnWith C f s\nâŠ¢ Filter.Eventually (fun x => Membership.mem s x â†’ DifferentiableWithinAt Real f s x) (MeasureTheory.ae Î¼)","decl":"/-- A real-valued function on a finite-dimensional space which is Lipschitz on a set is\ndifferentiable almost everywere in this set. Superseded by\n`LipschitzOnWith.ae_differentiableWithinAt_of_mem` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableWithinAt_of_mem_of_real (hf : LipschitzOnWith C f s) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ DifferentiableWithinAt â„ f s x := by\n  obtain âŸ¨g, g_lip, hgâŸ© : âˆƒ (g : E â†’ â„), LipschitzWith C g âˆ§ EqOn f g s := hf.extend_real\n  filter_upwards [g_lip.ae_differentiableAt_of_real] with x hx xs\n  exact hx.differentiableWithinAt.congr hg (hg xs)\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem_pi","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : MeasurableSpace E\ninstâœÂ³ : BorelSpace E\nC : NNReal\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : Î¼.IsAddHaarMeasure\nÎ¹ : Type u_3\ninstâœ : Fintype Î¹\nf : E â†’ Î¹ â†’ Real\ns : Set E\nhf : LipschitzOnWith C f s\nâŠ¢ Filter.Eventually (fun x => Membership.mem s x â†’ DifferentiableWithinAt Real f s x) (MeasureTheory.ae Î¼)","decl":"/-- A function on a finite-dimensional space which is Lipschitz on a set and taking values in a\nproduct space is differentiable almost everywere in this set. Superseded by\n`LipschitzOnWith.ae_differentiableWithinAt_of_mem` which works for functions taking value in any\nfinite-dimensional space. -/\ntheorem ae_differentiableWithinAt_of_mem_pi\n    {Î¹ : Type*} [Fintype Î¹] {f : E â†’ Î¹ â†’ â„} {s : Set E}\n    (hf : LipschitzOnWith C f s) : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ DifferentiableWithinAt â„ f s x := by\n  have A : âˆ€ i : Î¹, LipschitzWith 1 (fun x : Î¹ â†’ â„ â†¦ x i) := fun i => LipschitzWith.eval i\n  have : âˆ€ i : Î¹, âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ DifferentiableWithinAt â„ (fun x : E â†¦ f x i) s x := fun i â†¦ by\n    apply ae_differentiableWithinAt_of_mem_of_real\n    exact LipschitzWith.comp_lipschitzOnWith (A i) hf\n  filter_upwards [ae_all_iff.2 this] with x hx xs\n  exact differentiableWithinAt_pi.2 (fun i â†¦ hx i xs)\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt_of_mem","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nC : NNReal\ns : Set E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : FiniteDimensional Real F\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nhf : LipschitzOnWith C f s\nâŠ¢ Filter.Eventually (fun x => Membership.mem s x â†’ DifferentiableWithinAt Real f s x) (MeasureTheory.ae Î¼)","decl":"/-- *Rademacher's theorem*: a function between finite-dimensional real vector spaces which is\nLipschitz on a set is differentiable almost everywere in this set. -/\ntheorem ae_differentiableWithinAt_of_mem {f : E â†’ F} (hf : LipschitzOnWith C f s) :\n    âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ DifferentiableWithinAt â„ f s x := by\n  have A := (Basis.ofVectorSpace â„ F).equivFun.toContinuousLinearEquiv\n  suffices H : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ DifferentiableWithinAt â„ (A âˆ˜ f) s x by\n    filter_upwards [H] with x hx xs\n    have : f = (A.symm âˆ˜ A) âˆ˜ f := by\n      simp only [ContinuousLinearEquiv.symm_comp_self, Function.id_comp]\n    rw [this]\n    exact A.symm.differentiableAt.comp_differentiableWithinAt x (hx xs)\n  apply ae_differentiableWithinAt_of_mem_pi\n  exact A.lipschitz.comp_lipschitzOnWith hf\n\n"}
{"name":"LipschitzOnWith.ae_differentiableWithinAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nC : NNReal\ns : Set E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : FiniteDimensional Real F\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nhf : LipschitzOnWith C f s\nhs : MeasurableSet s\nâŠ¢ Filter.Eventually (fun x => DifferentiableWithinAt Real f s x) (MeasureTheory.ae (Î¼.restrict s))","decl":"/-- *Rademacher's theorem*: a function between finite-dimensional real vector spaces which is\nLipschitz on a set is differentiable almost everywere in this set. -/\ntheorem ae_differentiableWithinAt {f : E â†’ F} (hf : LipschitzOnWith C f s)\n    (hs : MeasurableSet s) :\n    âˆ€áµ x âˆ‚(Î¼.restrict s), DifferentiableWithinAt â„ f s x := by\n  rw [ae_restrict_iff' hs]\n  exact hf.ae_differentiableWithinAt_of_mem\n\n"}
{"name":"LipschitzWith.ae_differentiableAt","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : MeasurableSpace E\ninstâœâµ : BorelSpace E\nF : Type u_2\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nC : NNReal\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : FiniteDimensional Real E\ninstâœÂ¹ : FiniteDimensional Real F\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nh : LipschitzWith C f\nâŠ¢ Filter.Eventually (fun x => DifferentiableAt Real f x) (MeasureTheory.ae Î¼)","decl":"/-- *Rademacher's theorem*: a Lipschitz function between finite-dimensional real vector spaces is\ndifferentiable almost everywhere. -/\ntheorem LipschitzWith.ae_differentiableAt {f : E â†’ F} (h : LipschitzWith C f) :\n    âˆ€áµ x âˆ‚Î¼, DifferentiableAt â„ f x := by\n  rw [â† lipschitzOnWith_univ] at h\n  simpa [differentiableWithinAt_univ] using h.ae_differentiableWithinAt_of_mem\n\n"}
{"name":"ae_differentiableAt_norm","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ¹ : FiniteDimensional Real E\ninstâœ : Î¼.IsAddHaarMeasure\nâŠ¢ Filter.Eventually (fun x => DifferentiableAt Real (fun x => Norm.norm x) x) (MeasureTheory.ae Î¼)","decl":"/-- In a real finite-dimensional normed vector space,\n  the norm is almost everywhere differentiable. -/\ntheorem ae_differentiableAt_norm :\n    âˆ€áµ x âˆ‚Î¼, DifferentiableAt â„ (â€–Â·â€–) x := lipschitzWith_one_norm.ae_differentiableAt\n\n"}
{"name":"dense_differentiableAt_norm","module":"Mathlib.Analysis.Calculus.Rademacher","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : FiniteDimensional Real E\nâŠ¢ Dense (setOf fun x => DifferentiableAt Real (fun x => Norm.norm x) x)","decl":"omit [MeasurableSpace E] in\n/-- In a real finite-dimensional normed vector space,\n  the set of points where the norm is differentiable at is dense. -/\ntheorem dense_differentiableAt_norm :\n    Dense {x : E | DifferentiableAt â„ (â€–Â·â€–) x} :=\n  let _ : MeasurableSpace E := borel E\n  have _ : BorelSpace E := âŸ¨rflâŸ©\n  let w := Basis.ofVectorSpace â„ E\n  MeasureTheory.Measure.dense_of_ae (ae_differentiableAt_norm (Î¼ := w.addHaar))\n"}
