{"name":"LieModule.LinearWeights.map_smul","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nself : LieModule.LinearWeights R L M\nχ : L → R\na✝ : Ne (LieModule.genWeightSpace M χ) Bot.bot\nt : R\nx : L\n⊢ Eq (χ (HSMul.hSMul t x)) (HSMul.hSMul t (χ x))","decl":"/-- A typeclass encoding the fact that a given Lie module has linear weights, vanishing on the\nderived ideal. -/\nclass LinearWeights [LieRing.IsNilpotent L] : Prop where\n  map_add : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y, χ (x + y) = χ x + χ y\n  map_smul : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ (t : R) x, χ (t • x) = t • χ x\n  map_lie : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y : L, χ ⁅x, y⁆ = 0\n\n"}
{"name":"LieModule.LinearWeights.map_add","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nself : LieModule.LinearWeights R L M\nχ : L → R\na✝ : Ne (LieModule.genWeightSpace M χ) Bot.bot\nx y : L\n⊢ Eq (χ (HAdd.hAdd x y)) (HAdd.hAdd (χ x) (χ y))","decl":"/-- A typeclass encoding the fact that a given Lie module has linear weights, vanishing on the\nderived ideal. -/\nclass LinearWeights [LieRing.IsNilpotent L] : Prop where\n  map_add : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y, χ (x + y) = χ x + χ y\n  map_smul : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ (t : R) x, χ (t • x) = t • χ x\n  map_lie : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y : L, χ ⁅x, y⁆ = 0\n\n"}
{"name":"LieModule.LinearWeights.map_lie","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nself : LieModule.LinearWeights R L M\nχ : L → R\na✝ : Ne (LieModule.genWeightSpace M χ) Bot.bot\nx y : L\n⊢ Eq (χ (Bracket.bracket x y)) 0","decl":"/-- A typeclass encoding the fact that a given Lie module has linear weights, vanishing on the\nderived ideal. -/\nclass LinearWeights [LieRing.IsNilpotent L] : Prop where\n  map_add : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y, χ (x + y) = χ x + χ y\n  map_smul : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ (t : R) x, χ (t • x) = t • χ x\n  map_lie : ∀ χ : L → R, genWeightSpace M χ ≠ ⊥ → ∀ x y : L, χ ⁅x, y⁆ = 0\n\n"}
{"name":"LieModule.Weight.toLinear_apply","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\nχ : LieModule.Weight R L M\na : L\n⊢ Eq ((LieModule.Weight.toLinear R L M χ) a) (χ a)","decl":"/-- A weight of a Lie module, bundled as a linear map. -/\n@[simps]\ndef toLinear : L →ₗ[R] R where\n  toFun := χ\n  map_add' := LinearWeights.map_add χ χ.genWeightSpace_ne_bot\n  map_smul' := LinearWeights.map_smul χ χ.genWeightSpace_ne_bot\n\n"}
{"name":"LieModule.Weight.instLinearMapClass","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\n⊢ LinearMapClass (LieModule.Weight R L M) R L R","decl":"instance instLinearMapClass : LinearMapClass (Weight R L M) R L R where\n  map_add χ := LinearWeights.map_add χ χ.genWeightSpace_ne_bot\n  map_smulₛₗ χ := LinearWeights.map_smul χ χ.genWeightSpace_ne_bot\n\n"}
{"name":"LieModule.Weight.apply_lie","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\nχ : LieModule.Weight R L M\nx y : L\n⊢ Eq (χ (Bracket.bracket x y)) 0","decl":"@[simp]\nlemma apply_lie (x y : L) :\n    χ ⁅x, y⁆ = 0 :=\n  LinearWeights.map_lie χ χ.genWeightSpace_ne_bot x y\n\n"}
{"name":"LieModule.Weight.coe_coe","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\nχ : LieModule.Weight R L M\n⊢ Eq ⇑(LieModule.Weight.toLinear R L M χ) ⇑χ","decl":"@[simp] lemma coe_coe : (↑(χ : L →ₗ[R] R) : L → R) = (χ : L → R) := rfl\n\n"}
{"name":"LieModule.Weight.coe_toLinear_eq_zero_iff","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\nχ : LieModule.Weight R L M\n⊢ Iff (Eq (LieModule.Weight.toLinear R L M χ) 0) χ.IsZero","decl":"@[simp] lemma coe_toLinear_eq_zero_iff : (χ : L →ₗ[R] R) = 0 ↔ χ.IsZero :=\n  ⟨fun h ↦ funext fun x ↦ LinearMap.congr_fun h x, fun h ↦ by ext; simp [h.eq]⟩\n\n"}
{"name":"LieModule.Weight.coe_toLinear_ne_zero_iff","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : LieModule.LinearWeights R L M\nχ : LieModule.Weight R L M\n⊢ Iff (Ne (LieModule.Weight.toLinear R L M χ) 0) χ.IsNonZero","decl":"lemma coe_toLinear_ne_zero_iff : (χ : L →ₗ[R] R) ≠ 0 ↔ χ.IsNonZero := by simp\n\n"}
{"name":"LieModule.instLinearWeightsOfIsLieAbelian","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : IsLieAbelian L\ninst✝ : NoZeroSMulDivisors R M\n⊢ LieModule.LinearWeights R L M","decl":"/-- For an Abelian Lie algebra, the weights of any Lie module are linear. -/\ninstance instLinearWeightsOfIsLieAbelian [IsLieAbelian L] [NoZeroSMulDivisors R M] :\n    LinearWeights R L M :=\n  have aux : ∀ (χ : L → R), genWeightSpace M χ ≠ ⊥ → ∀ (x y : L), χ (x + y) = χ x + χ y := by\n    have h : ∀ x y, Commute (toEnd R L M x) (toEnd R L M y) := fun x y ↦ by\n      rw [commute_iff_lie_eq, ← LieHom.map_lie, trivial_lie_zero, LieHom.map_zero]\n    intro χ hχ x y\n    simp_rw [Ne, ← LieSubmodule.toSubmodule_inj, genWeightSpace, genWeightSpaceOf,\n      LieSubmodule.iInf_toSubmodule, LieSubmodule.bot_toSubmodule] at hχ\n    exact Module.End.map_add_of_iInf_genEigenspace_ne_bot_of_commute\n      (toEnd R L M).toLinearMap χ _ hχ h x y\n  { map_add := aux\n    map_smul := fun χ hχ t x ↦ by\n      simp_rw [Ne, ← LieSubmodule.toSubmodule_inj, genWeightSpace, genWeightSpaceOf,\n        LieSubmodule.iInf_toSubmodule, LieSubmodule.bot_toSubmodule] at hχ\n      exact Module.End.map_smul_of_iInf_genEigenspace_ne_bot\n        (toEnd R L M).toLinearMap χ _ hχ t x\n    map_lie := fun χ hχ t x ↦ by\n      rw [trivial_lie_zero, ← add_left_inj (χ 0), ← aux χ hχ, zero_add, zero_add] }\n\n"}
{"name":"LieModule.trace_comp_toEnd_genWeightSpace_eq","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\n⊢ Eq (⇑((LinearMap.trace R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)).comp ↑(LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)))) (HSMul.hSMul (Module.finrank R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) χ)","decl":"lemma trace_comp_toEnd_genWeightSpace_eq (χ : L → R) :\n    LinearMap.trace R _ ∘ₗ (toEnd R L (genWeightSpace M χ)).toLinearMap =\n    finrank R (genWeightSpace M χ) • χ := by\n  ext x\n  let n := toEnd R L (genWeightSpace M χ) x - χ x • LinearMap.id\n  have h₁ : toEnd R L (genWeightSpace M χ) x = n + χ x • LinearMap.id := eq_add_of_sub_eq rfl\n  have h₂ : LinearMap.trace R _ n = 0 := IsReduced.eq_zero _ <|\n    LinearMap.isNilpotent_trace_of_isNilpotent <| isNilpotent_toEnd_sub_algebraMap M χ x\n  rw [LinearMap.comp_apply, LieHom.coe_toLinearMap, h₁, map_add, h₂]\n  simp [mul_comm (χ x)]\n\n"}
{"name":"LieModule.zero_lt_finrank_genWeightSpace","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : LieRing L\ninst✝⁹ : LieAlgebra R L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : LieModule R L M\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : Module.Free R M\ninst✝¹ : Module.Finite R M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\nhχ : Ne (LieModule.genWeightSpace M χ) Bot.bot\n⊢ LT.lt 0 (Module.finrank R (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x))","decl":"variable {R L M} in\nlemma zero_lt_finrank_genWeightSpace {χ : L → R} (hχ : genWeightSpace M χ ≠ ⊥) :\n    0 < finrank R (genWeightSpace M χ) := by\n  rwa [← LieSubmodule.nontrivial_iff_ne_bot, ← rank_pos_iff_nontrivial (R := R), ← finrank_eq_rank,\n    Nat.cast_pos] at hχ\n\n"}
{"name":"LieModule.instLinearWeightsOfCharZero","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\ninst✝ : CharZero R\n⊢ LieModule.LinearWeights R L M","decl":"/-- In characteristic zero, the weights of any finite-dimensional Lie module are linear and vanish\non the derived ideal. -/\ninstance instLinearWeightsOfCharZero [CharZero R] :\n    LinearWeights R L M where\n  map_add χ hχ x y := by\n    rw [← smul_right_inj (zero_lt_finrank_genWeightSpace hχ).ne', smul_add, ← Pi.smul_apply,\n      ← Pi.smul_apply, ← Pi.smul_apply, ← trace_comp_toEnd_genWeightSpace_eq, map_add]\n  map_smul χ hχ t x := by\n    rw [← smul_right_inj (zero_lt_finrank_genWeightSpace hχ).ne', smul_comm, ← Pi.smul_apply,\n      ← Pi.smul_apply (finrank R _), ← trace_comp_toEnd_genWeightSpace_eq, map_smul]\n  map_lie χ hχ x y := by\n    rw [← smul_right_inj (zero_lt_finrank_genWeightSpace hχ).ne', nsmul_zero, ← Pi.smul_apply,\n      ← trace_comp_toEnd_genWeightSpace_eq, LinearMap.comp_apply, LieHom.coe_toLinearMap,\n      LieHom.map_lie, Ring.lie_def, map_sub, LinearMap.trace_mul_comm, sub_self]\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.coe_lie_shiftedGenWeightSpace_apply","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\nχ : L → R\ninst✝ : LieModule.LinearWeights R L M\nx : L\nm : Subtype fun x => Membership.mem (LieModule.shiftedGenWeightSpace R L M χ) x\n⊢ Eq (↑(Bracket.bracket x m)) (HSub.hSub (Bracket.bracket x ↑m) (HSMul.hSMul (χ x) ↑m))","decl":"@[simp] lemma coe_lie_shiftedGenWeightSpace_apply (x : L) (m : shiftedGenWeightSpace R L M χ) :\n    letI : Bracket L (shiftedGenWeightSpace R L M χ) := LieRingModule.toBracket\n    ⁅x, m⁆ = ⁅x, (m : M)⁆ - χ x • m :=\n  rfl\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.instSubtypeMemLieSubmodule","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\n⊢ LieModule R L (Subtype fun x => Membership.mem (LieModule.shiftedGenWeightSpace R L M χ) x)","decl":"instance : LieModule R L (shiftedGenWeightSpace R L M χ) where\n  smul_lie t x m := by\n    nontriviality shiftedGenWeightSpace R L M χ\n    apply Subtype.ext\n    rw [coe_lie_shiftedGenWeightSpace_apply]\n    simp only [smul_lie, LinearWeights.map_smul χ (aux R L M χ), smul_assoc t, SetLike.val_smul]\n    rw [← smul_sub]\n    congr\n  lie_smul t x m := by\n    nontriviality shiftedGenWeightSpace R L M χ\n    apply Subtype.ext\n    rw [coe_lie_shiftedGenWeightSpace_apply]\n    simp only [SetLike.val_smul, lie_smul]\n    rw [smul_comm (χ x), ← smul_sub]\n    congr\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.shift_symm_apply","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\na✝ : Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x\n⊢ Eq ((LieModule.shiftedGenWeightSpace.shift R L M χ).symm a✝) a✝","decl":"/-- Forgetting the action of `L`,\nthe spaces `genWeightSpace M χ` and `shiftedGenWeightSpace R L M χ` are equivalent. -/\n@[simps!] def shift : genWeightSpace M χ ≃ₗ[R] shiftedGenWeightSpace R L M χ := LinearEquiv.refl R _\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.shift_apply","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ : L → R\na : Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x\n⊢ Eq ((LieModule.shiftedGenWeightSpace.shift R L M χ) a) a","decl":"/-- Forgetting the action of `L`,\nthe spaces `genWeightSpace M χ` and `shiftedGenWeightSpace R L M χ` are equivalent. -/\n@[simps!] def shift : genWeightSpace M χ ≃ₗ[R] shiftedGenWeightSpace R L M χ := LinearEquiv.refl R _\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.toEnd_eq","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\nχ : L → R\ninst✝ : LieModule.LinearWeights R L M\nx : L\n⊢ Eq ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.shiftedGenWeightSpace R L M χ) x)) x) ((LieModule.shiftedGenWeightSpace.shift R L M χ).conj (HSub.hSub ((LieModule.toEnd R L (Subtype fun x => Membership.mem (LieModule.genWeightSpace M χ) x)) x) (HSMul.hSMul (χ x) LinearMap.id)))","decl":"lemma toEnd_eq (x : L) :\n    toEnd R L (shiftedGenWeightSpace R L M χ) x =\n    (shift R L M χ).conj (toEnd R L (genWeightSpace M χ) x - χ x • LinearMap.id) := by\n  ext\n  simp only [toEnd_apply_apply, map_sub, LinearEquiv.conj_apply, map_smul, LinearMap.comp_id,\n    LinearEquiv.comp_coe, LinearEquiv.symm_trans_self, LinearEquiv.refl_toLinearMap,\n    LinearMap.sub_apply, LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    shift_symm_apply, shift_apply, LinearMap.smul_apply, LinearMap.id_coe, id_eq,\n    AddSubgroupClass.coe_sub, SetLike.val_smul]\n  rw [LieSubmodule.coe_bracket]\n  rfl\n\n"}
{"name":"LieModule.shiftedGenWeightSpace.instIsNilpotentSubtypeMemLieSubmoduleOfIsNoetherian","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\ninst✝¹ : LieRing.IsNilpotent L\nχ : L → R\ninst✝ : IsNoetherian R M\n⊢ LieModule.IsNilpotent L (Subtype fun x => Membership.mem (LieModule.shiftedGenWeightSpace R L M χ) x)","decl":"/-- By Engel's theorem, if `M` is Noetherian, the shifted action `⁅x, m⁆ - χ x • m` makes the\n`χ`-weight space into a nilpotent Lie module. -/\ninstance [IsNoetherian R M] : IsNilpotent L (shiftedGenWeightSpace R L M χ) :=\n  LieModule.isNilpotent_iff_forall'.mpr fun x ↦ isNilpotent_toEnd_sub_algebraMap M χ x\n\n"}
{"name":"LieModule.exists_forall_lie_eq_smul","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"R : Type u_2\nL : Type u_3\nM : Type u_4\ninst✝⁹ : CommRing R\ninst✝⁸ : LieRing L\ninst✝⁷ : LieAlgebra R L\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : LieRingModule L M\ninst✝³ : LieModule R L M\ninst✝² : LieRing.IsNilpotent L\ninst✝¹ : LieModule.LinearWeights R L M\ninst✝ : IsNoetherian R M\nχ : LieModule.Weight R L M\n⊢ Exists fun m => And (Ne m 0) (∀ (x : L), Eq (Bracket.bracket x m) (HSMul.hSMul (χ x) m))","decl":"open shiftedGenWeightSpace in\n/-- Given a Lie module `M` of a nilpotent Lie algebra `L` with coefficients in `R`,\nif a function `χ : L → R` has a simultaneous generalized eigenvector for the action of `L`\nthen it has a simultaneous true eigenvector, provided `M` is Noetherian and has linear weights. -/\nlemma exists_forall_lie_eq_smul [LinearWeights R L M] [IsNoetherian R M] (χ : Weight R L M) :\n    ∃ m : M, m ≠ 0 ∧ ∀ x : L, ⁅x, m⁆ = χ x • m := by\n  replace hχ : Nontrivial (shiftedGenWeightSpace R L M χ) :=\n    (LieSubmodule.nontrivial_iff_ne_bot R L M).mpr χ.genWeightSpace_ne_bot\n  obtain ⟨⟨⟨m, _⟩, hm₁⟩, hm₂⟩ :=\n    @exists_ne _ (nontrivial_max_triv_of_isNilpotent R L (shiftedGenWeightSpace R L M χ)) 0\n  simp_rw [mem_maxTrivSubmodule, Subtype.ext_iff,\n    ZeroMemClass.coe_zero] at hm₁\n  refine ⟨m, by simpa [LieSubmodule.mk_eq_zero] using hm₂, ?_⟩\n  intro x\n  have := hm₁ x\n  rwa [coe_lie_shiftedGenWeightSpace_apply, sub_eq_zero] at this\n\n"}
{"name":"LieModule.exists_nontrivial_weightSpace_of_isNilpotent","module":"Mathlib.Algebra.Lie.Weights.Linear","initialProofState":"k : Type u_1\nL : Type u_3\nM : Type u_4\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : LieRingModule L M\ninst✝⁸ : LieRing.IsNilpotent L\ninst✝⁷ : Field k\ninst✝⁶ : LieAlgebra k L\ninst✝⁵ : Module k M\ninst✝⁴ : Module.Finite k M\ninst✝³ : LieModule k L M\ninst✝² : LieModule.LinearWeights k L M\ninst✝¹ : LieModule.IsTriangularizable k L M\ninst✝ : Nontrivial M\n⊢ Exists fun χ => Nontrivial (Subtype fun x => Membership.mem (LieModule.weightSpace M ⇑χ) x)","decl":"/-- See `LieModule.exists_nontrivial_weightSpace_of_isSolvable` for the variant that\nonly assumes that `L` is solvable but additionally requires `k` to be of characteristic zero. -/\nlemma exists_nontrivial_weightSpace_of_isNilpotent [Field k] [LieAlgebra k L] [Module k M]\n    [Module.Finite k M] [LieModule k L M] [LinearWeights k L M]\n    [IsTriangularizable k L M] [Nontrivial M] :\n    ∃ χ : Module.Dual k L, Nontrivial (weightSpace M χ) := by\n  obtain ⟨χ⟩ : Nonempty (Weight k L M) := by\n    by_contra contra\n    rw [not_nonempty_iff] at contra\n    simpa only [iSup_of_empty, bot_ne_top] using LieModule.iSup_genWeightSpace_eq_top' k L M\n  obtain ⟨m, hm₀, hm⟩ := exists_forall_lie_eq_smul k L M χ\n  simp only [LieSubmodule.nontrivial_iff_ne_bot, LieSubmodule.eq_bot_iff, Weight.coe_coe, ne_eq,\n    not_forall, Classical.not_imp]\n  exact ⟨χ.toLinear, m, by simpa [mem_weightSpace], hm₀⟩\n\n"}
