{"name":"SimpleGraph.Subgraph.Preconnected.coe","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nself : H.Preconnected\n⊢ H.coe.Preconnected","decl":"/-- A subgraph is preconnected if it is preconnected when coerced to be a simple graph.\n\nNote: This is a structure to make it so one can be precise about how dot notation resolves. -/\nprotected structure Preconnected (H : G.Subgraph) : Prop where\n  protected coe : H.coe.Preconnected\n\n"}
{"name":"SimpleGraph.Subgraph.preconnected_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Iff H.Preconnected H.coe.Preconnected","decl":"protected lemma preconnected_iff {H : G.Subgraph} :\n    H.Preconnected ↔ H.coe.Preconnected := ⟨fun ⟨h⟩ => h, .mk⟩\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.coe","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nself : H.Connected\n⊢ H.coe.Connected","decl":"/-- A subgraph is connected if it is connected when coerced to be a simple graph.\n\nNote: This is a structure to make it so one can be precise about how dot notation resolves. -/\nprotected structure Connected (H : G.Subgraph) : Prop where\n  protected coe : H.coe.Connected\n\n"}
{"name":"SimpleGraph.Subgraph.connected_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Iff H.Connected H.coe.Connected","decl":"protected lemma connected_iff' {H : G.Subgraph} :\n    H.Connected ↔ H.coe.Connected := ⟨fun ⟨h⟩ => h, .mk⟩\n\n"}
{"name":"SimpleGraph.Subgraph.connected_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Iff H.Connected (And H.Preconnected H.verts.Nonempty)","decl":"protected lemma connected_iff {H : G.Subgraph} :\n    H.Connected ↔ H.Preconnected ∧ H.verts.Nonempty := by\n  rw [H.connected_iff', connected_iff, H.preconnected_iff, Set.nonempty_coe_sort]\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nh : H.Connected\n⊢ H.Preconnected","decl":"protected lemma Connected.preconnected {H : G.Subgraph} (h : H.Connected) : H.Preconnected := by\n  rw [H.connected_iff] at h; exact h.1\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nh : H.Connected\n⊢ H.verts.Nonempty","decl":"protected lemma Connected.nonempty {H : G.Subgraph} (h : H.Connected) : H.verts.Nonempty := by\n  rw [H.connected_iff] at h; exact h.2\n\n"}
{"name":"SimpleGraph.Subgraph.singletonSubgraph_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ (G.singletonSubgraph v).Connected","decl":"theorem singletonSubgraph_connected {v : V} : (G.singletonSubgraph v).Connected := by\n  refine ⟨⟨?_⟩⟩\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  simp only [singletonSubgraph_verts, Set.mem_singleton_iff] at ha hb\n  subst_vars\n  rfl\n\n"}
{"name":"SimpleGraph.Subgraph.subgraphOfAdj_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\nhvw : G.Adj v w\n⊢ (G.subgraphOfAdj hvw).Connected","decl":"@[simp]\ntheorem subgraphOfAdj_connected {v w : V} (hvw : G.Adj v w) : (G.subgraphOfAdj hvw).Connected := by\n  refine ⟨⟨?_⟩⟩\n  rintro ⟨a, ha⟩ ⟨b, hb⟩\n  simp only [subgraphOfAdj_verts, Set.mem_insert_iff, Set.mem_singleton_iff] at ha hb\n  obtain rfl | rfl := ha <;> obtain rfl | rfl := hb <;>\n    first | rfl | (apply Adj.reachable; simp)\n\n"}
{"name":"SimpleGraph.Subgraph.top_induce_pair_connected_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nhuv : G.Adj u v\n⊢ (Top.top.induce (Insert.insert u (Singleton.singleton v))).Connected","decl":"lemma top_induce_pair_connected_of_adj {u v : V} (huv : G.Adj u v) :\n    ((⊤ : G.Subgraph).induce {u, v}).Connected := by\n  rw [← subgraphOfAdj_eq_induce huv]\n  exact subgraphOfAdj_connected huv\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.mono","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nhle : LE.le H H'\nhv : Eq H.verts H'.verts\nh : H.Connected\n⊢ H'.Connected","decl":"@[mono]\nprotected lemma Connected.mono {H H' : G.Subgraph} (hle : H ≤ H') (hv : H.verts = H'.verts)\n    (h : H.Connected) : H'.Connected := by\n  rw [← Subgraph.copy_eq H' H.verts hv H'.Adj rfl]\n  refine ⟨h.coe.mono ?_⟩\n  rintro ⟨v, hv⟩ ⟨w, hw⟩ hvw\n  exact hle.2 hvw\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.mono'","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH H' : G.Subgraph\nhle : ∀ (v w : V), H.Adj v w → H'.Adj v w\nhv : Eq H.verts H'.verts\nh : H.Connected\n⊢ H'.Connected","decl":"protected lemma Connected.mono' {H H' : G.Subgraph}\n    (hle : ∀ v w, H.Adj v w → H'.Adj v w) (hv : H.verts = H'.verts)\n    (h : H.Connected) : H'.Connected := by\n  exact h.mono ⟨hv.le, hle⟩ hv\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.sup","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH K : G.Subgraph\nhH : H.Connected\nhK : K.Connected\nhn : (Min.min H K).verts.Nonempty\n⊢ (Max.max H K).Connected","decl":"protected lemma Connected.sup {H K : G.Subgraph}\n    (hH : H.Connected) (hK : K.Connected) (hn : (H ⊓ K).verts.Nonempty) :\n    (H ⊔ K).Connected := by\n  rw [Subgraph.connected_iff', connected_iff_exists_forall_reachable]\n  obtain ⟨u, hu, hu'⟩ := hn\n  exists ⟨u, Or.inl hu⟩\n  rintro ⟨v, (hv|hv)⟩\n  · exact Reachable.map (Subgraph.inclusion (le_sup_left : H ≤ H ⊔ K)) (hH ⟨u, hu⟩ ⟨v, hv⟩)\n  · exact Reachable.map (Subgraph.inclusion (le_sup_right : K ≤ H ⊔ K)) (hK ⟨u, hu'⟩ ⟨v, hv⟩)\n"}
{"name":"SimpleGraph.Walk.toSubgraph_cons_nil_eq_subgraphOfAdj","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ Eq (SimpleGraph.Walk.cons h SimpleGraph.Walk.nil).toSubgraph (G.subgraphOfAdj h)","decl":"theorem toSubgraph_cons_nil_eq_subgraphOfAdj (h : G.Adj u v) :\n    (cons h nil).toSubgraph = G.subgraphOfAdj h := by simp\n\n"}
{"name":"SimpleGraph.Walk.mem_verts_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\n⊢ Iff (Membership.mem p.toSubgraph.verts w) (Membership.mem p.support w)","decl":"theorem mem_verts_toSubgraph (p : G.Walk u v) : w ∈ p.toSubgraph.verts ↔ w ∈ p.support := by\n  induction' p with _ x y z h p' ih\n  · simp\n  · have : w = y ∨ w ∈ p'.support ↔ w ∈ p'.support :=\n      ⟨by rintro (rfl | h) <;> simp [*], by simp +contextual⟩\n    simp [ih, or_assoc, this]\n\n"}
{"name":"SimpleGraph.Walk.start_mem_verts_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Membership.mem p.toSubgraph.verts u","decl":"lemma start_mem_verts_toSubgraph (p : G.Walk u v) : u ∈ p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]\n\n"}
{"name":"SimpleGraph.Walk.end_mem_verts_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Membership.mem p.toSubgraph.verts v","decl":"lemma end_mem_verts_toSubgraph (p : G.Walk u v) : v ∈ p.toSubgraph.verts := by\n  simp [mem_verts_toSubgraph]\n\n"}
{"name":"SimpleGraph.Walk.verts_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.toSubgraph.verts (setOf fun w => Membership.mem p.support w)","decl":"@[simp]\ntheorem verts_toSubgraph (p : G.Walk u v) : p.toSubgraph.verts = { w | w ∈ p.support } :=\n  Set.ext fun _ => p.mem_verts_toSubgraph\n\n"}
{"name":"SimpleGraph.Walk.mem_edges_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\ne : Sym2 V\n⊢ Iff (Membership.mem p.toSubgraph.edgeSet e) (Membership.mem p.edges e)","decl":"theorem mem_edges_toSubgraph (p : G.Walk u v) {e : Sym2 V} :\n    e ∈ p.toSubgraph.edgeSet ↔ e ∈ p.edges := by induction p <;> simp [*]\n\n"}
{"name":"SimpleGraph.Walk.edgeSet_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.toSubgraph.edgeSet (setOf fun e => Membership.mem p.edges e)","decl":"@[simp]\ntheorem edgeSet_toSubgraph (p : G.Walk u v) : p.toSubgraph.edgeSet = { e | e ∈ p.edges } :=\n  Set.ext fun _ => p.mem_edges_toSubgraph\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_append","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\nq : G.Walk v w\n⊢ Eq (p.append q).toSubgraph (Max.max p.toSubgraph q.toSubgraph)","decl":"@[simp]\ntheorem toSubgraph_append (p : G.Walk u v) (q : G.Walk v w) :\n    (p.append q).toSubgraph = p.toSubgraph ⊔ q.toSubgraph := by induction p <;> simp [*, sup_assoc]\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_reverse","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ Eq p.reverse.toSubgraph p.toSubgraph","decl":"@[simp]\ntheorem toSubgraph_reverse (p : G.Walk u v) : p.reverse.toSubgraph = p.toSubgraph := by\n  induction p with\n  | nil => simp\n  | cons _ _ _ =>\n    simp only [*, Walk.toSubgraph, reverse_cons, toSubgraph_append, subgraphOfAdj_symm]\n    rw [sup_comm]\n    congr\n    ext <;> simp [-Set.bot_eq_empty]\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_rotate","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\ninst✝ : DecidableEq V\nc : G.Walk v v\nh : Membership.mem c.support u\n⊢ Eq (c.rotate h).toSubgraph c.toSubgraph","decl":"@[simp]\ntheorem toSubgraph_rotate [DecidableEq V] (c : G.Walk v v) (h : u ∈ c.support) :\n    (c.rotate h).toSubgraph = c.toSubgraph := by\n  rw [rotate, toSubgraph_append, sup_comm, ← toSubgraph_append, take_spec]\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_map","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nV' : Type v\nG : SimpleGraph V\nG' : SimpleGraph V'\nu v : V\nf : G.Hom G'\np : G.Walk u v\n⊢ Eq (SimpleGraph.Walk.map f p).toSubgraph (SimpleGraph.Subgraph.map f p.toSubgraph)","decl":"@[simp]\ntheorem toSubgraph_map (f : G →g G') (p : G.Walk u v) :\n    (p.map f).toSubgraph = p.toSubgraph.map f := by induction p <;> simp [*, Subgraph.map_sup]\n\n"}
{"name":"SimpleGraph.Walk.finite_neighborSet_toSubgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\np : G.Walk u v\n⊢ (p.toSubgraph.neighborSet w).Finite","decl":"@[simp]\ntheorem finite_neighborSet_toSubgraph (p : G.Walk u v) : (p.toSubgraph.neighborSet w).Finite := by\n  induction p with\n  | nil =>\n    rw [Walk.toSubgraph, neighborSet_singletonSubgraph]\n    apply Set.toFinite\n  | cons ha _ ih =>\n    rw [Walk.toSubgraph, Subgraph.neighborSet_sup]\n    refine Set.Finite.union ?_ ih\n    refine Set.Finite.subset ?_ (neighborSet_subgraphOfAdj_subset ha)\n    apply Set.toFinite\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_le_induce_support","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ LE.le p.toSubgraph (Top.top.induce (setOf fun v_1 => Membership.mem p.support v_1))","decl":"lemma toSubgraph_le_induce_support (p : G.Walk u v) :\n    p.toSubgraph ≤ (⊤ : G.Subgraph).induce {v | v ∈ p.support} := by\n  convert Subgraph.le_induce_top_verts\n  exact p.verts_toSubgraph.symm\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_adj_getVert","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\ni : Nat\nhi : LT.lt i w.length\n⊢ w.toSubgraph.Adj (w.getVert i) (w.getVert (HAdd.hAdd i 1))","decl":"theorem toSubgraph_adj_getVert {u v} (w : G.Walk u v) {i : ℕ} (hi : i < w.length) :\n    w.toSubgraph.Adj (w.getVert i) (w.getVert (i + 1)) := by\n  induction w generalizing i with\n  | nil => cases hi\n  | cons hxy i' ih =>\n    cases i\n    · simp only [Walk.toSubgraph, Walk.getVert_zero, zero_add, getVert_cons_succ, Subgraph.sup_adj,\n        subgraphOfAdj_adj, true_or]\n    · simp only [Walk.toSubgraph, getVert_cons_succ, Subgraph.sup_adj, subgraphOfAdj_adj, Sym2.eq,\n        Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk]\n      right\n      exact ih (Nat.succ_lt_succ_iff.mp hi)\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_adj_snd","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\nh : Not w.Nil\n⊢ w.toSubgraph.Adj u w.snd","decl":"theorem toSubgraph_adj_snd {u v} (w : G.Walk u v) (h : ¬ w.Nil) : w.toSubgraph.Adj u w.snd := by\n  simpa using w.toSubgraph_adj_getVert (not_nil_iff_lt_length.mp h)\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_adj_penultimate","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nw : G.Walk u v\nh : Not w.Nil\n⊢ w.toSubgraph.Adj w.penultimate v","decl":"theorem toSubgraph_adj_penultimate {u v} (w : G.Walk u v) (h : ¬ w.Nil) :\n    w.toSubgraph.Adj w.penultimate v := by\n  rw [not_nil_iff_lt_length] at h\n  simpa [show w.length - 1 + 1 = w.length from by omega]\n    using w.toSubgraph_adj_getVert (by omega : w.length - 1 < w.length)\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_adj_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v u' v' : V\nw : G.Walk u v\n⊢ Iff (w.toSubgraph.Adj u' v') (Exists fun i => And (Eq (Sym2.mk { fst := w.getVert i, snd := w.getVert (HAdd.hAdd i 1) }) (Sym2.mk { fst := u', snd := v' })) (LT.lt i w.length))","decl":"theorem toSubgraph_adj_iff {u v u' v'} (w : G.Walk u v) :\n    w.toSubgraph.Adj u' v' ↔ ∃ i, s(w.getVert i, w.getVert (i + 1)) =\n      s(u', v') ∧ i < w.length := by\n  constructor\n  · intro hadj\n    unfold Walk.toSubgraph at hadj\n    match w with\n    | .nil =>\n      simp only [singletonSubgraph_adj, Pi.bot_apply, Prop.bot_eq_false] at hadj\n    | .cons h p =>\n      simp only [Subgraph.sup_adj, subgraphOfAdj_adj, Sym2.eq, Sym2.rel_iff', Prod.mk.injEq,\n        Prod.swap_prod_mk] at hadj\n      cases hadj with\n      | inl hl =>\n        use 0\n        simp only [Walk.getVert_zero, zero_add, getVert_cons_succ]\n        refine ⟨?_, by simp only [length_cons, Nat.zero_lt_succ]⟩\n        simp only [Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk]\n        cases hl with\n        | inl h1 => left; exact ⟨h1.1, h1.2⟩\n        | inr h2 => right; exact ⟨h2.1, h2.2⟩\n      | inr hr =>\n        obtain ⟨i, hi⟩ := (toSubgraph_adj_iff _).mp hr\n        use i + 1\n        simp only [getVert_cons_succ]\n        constructor\n        · exact hi.1\n        · simp only [Walk.length_cons, add_lt_add_iff_right, Nat.add_lt_add_right hi.2 1]\n  · rintro ⟨i, hi⟩\n    rw [← Subgraph.mem_edgeSet, ← hi.1, Subgraph.mem_edgeSet]\n    exact toSubgraph_adj_getVert _ hi.2\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.neighborSet_toSubgraph_endpoint","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\np : G.Walk u u\nhpc : p.IsCycle\n⊢ Eq (p.toSubgraph.neighborSet u) (Insert.insert p.snd (Singleton.singleton p.penultimate))","decl":"lemma neighborSet_toSubgraph_endpoint {u} {p : G.Walk u u} (hpc : p.IsCycle) :\n    p.toSubgraph.neighborSet u = {p.snd, p.penultimate} := by\n  have hadj1 := p.toSubgraph_adj_snd hpc.not_nil\n  have hadj2 := (p.toSubgraph_adj_penultimate hpc.not_nil).symm\n  ext v\n  simp_all only [Subgraph.mem_neighborSet, Set.mem_insert_iff, Set.mem_singleton_iff,\n    SimpleGraph.Walk.toSubgraph_adj_iff, Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk]\n  refine ⟨?_, by aesop⟩\n  rintro ⟨i, (hl | hr)⟩\n  · rw [hpc.getVert_endpoint_iff (by omega)] at hl\n    cases hl.1 <;> aesop\n  · cases' (hpc.getVert_endpoint_iff (by omega)).mp hr.2 with h1 h2\n    · contradiction\n    · simp only [penultimate, ← h2, add_tsub_cancel_right]\n      aesop\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.neighborSet_toSubgraph_internal","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu : V\ni : Nat\np : G.Walk u u\nhpc : p.IsCycle\nh : Ne i 0\nh' : LT.lt i p.length\n⊢ Eq (p.toSubgraph.neighborSet (p.getVert i)) (Insert.insert (p.getVert (HSub.hSub i 1)) (Singleton.singleton (p.getVert (HAdd.hAdd i 1))))","decl":"lemma neighborSet_toSubgraph_internal {u} {i : ℕ} {p : G.Walk u u} (hpc : p.IsCycle)\n    (h : i ≠ 0) (h' : i < p.length) :\n    p.toSubgraph.neighborSet (p.getVert i) = {p.getVert (i - 1), p.getVert (i + 1)} := by\n  have hadj1 := ((show i - 1 + 1 = i from by omega) ▸\n    p.toSubgraph_adj_getVert (by omega : (i - 1) < p.length)).symm\n  have hadj2 := p.toSubgraph_adj_getVert (by omega : i < p.length)\n  ext v\n  simp_all only [ne_eq, Subgraph.mem_neighborSet, Set.mem_insert_iff, Set.mem_singleton_iff,\n    SimpleGraph.Walk.toSubgraph_adj_iff, Sym2.eq, Sym2.rel_iff', Prod.mk.injEq,\n    Prod.swap_prod_mk]\n  refine ⟨?_, by aesop⟩\n  rintro ⟨i', (⟨hl1, hl2⟩ | ⟨hr1, hr2⟩)⟩\n  · apply hpc.getVert_injOn' (by rw [Set.mem_setOf_eq]; omega)\n      (by rw [Set.mem_setOf_eq]; omega) at hl1\n    aesop\n  · apply hpc.getVert_injOn (by rw [Set.mem_setOf_eq]; omega)\n      (by rw [Set.mem_setOf_eq]; omega) at hr2\n    aesop\n\n"}
{"name":"SimpleGraph.Walk.IsCycle.ncard_neighborSet_toSubgraph_eq_two","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u u\nhpc : p.IsCycle\nh : Membership.mem p.support v\n⊢ Eq (p.toSubgraph.neighborSet v).ncard 2","decl":"lemma ncard_neighborSet_toSubgraph_eq_two {u v} {p : G.Walk u u} (hpc : p.IsCycle)\n    (h : v ∈ p.support) : (p.toSubgraph.neighborSet v).ncard = 2 := by\n  simp only [SimpleGraph.Walk.mem_support_iff_exists_getVert] at h ⊢\n  obtain ⟨i, hi⟩ := h\n  by_cases he : i = 0 ∨ i = p.length\n  · have huv : u = v := by aesop\n    rw [← huv, hpc.neighborSet_toSubgraph_endpoint]\n    exact Set.ncard_pair hpc.snd_ne_penultimate\n  push_neg at he\n  rw [← hi.1, hpc.neighborSet_toSubgraph_internal he.1 (by omega)]\n  exact Set.ncard_pair (hpc.getVert_sub_one_neq_getVert_add_one (by omega))\n\n"}
{"name":"SimpleGraph.Walk.toSubgraph_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ p.toSubgraph.Connected","decl":"lemma _root_.SimpleGraph.Walk.toSubgraph_connected {u v : V} (p : G.Walk u v) :\n    p.toSubgraph.Connected := by\n  induction p with\n  | nil => apply singletonSubgraph_connected\n  | @cons _ w _ h p ih =>\n    apply (subgraphOfAdj_connected h).sup ih\n    exists w\n    simp\n\n"}
{"name":"SimpleGraph.Subgraph.induce_union_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\ns t : Set V\nsconn : (H.induce s).Connected\ntconn : (H.induce t).Connected\nsintert : (Min.min s t).Nonempty\n⊢ (H.induce (Union.union s t)).Connected","decl":"lemma induce_union_connected {H : G.Subgraph} {s t : Set V}\n    (sconn : (H.induce s).Connected) (tconn : (H.induce t).Connected)\n    (sintert : (s ⊓ t).Nonempty) :\n    (H.induce (s ∪ t)).Connected := by\n  refine (sconn.sup tconn sintert).mono ?_ ?_\n  · apply le_induce_union\n  · simp\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.adj_union","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH K : G.Subgraph\nHconn : H.Connected\nKconn : K.Connected\nu v : V\nuH : Membership.mem H.verts u\nvK : Membership.mem K.verts v\nhuv : G.Adj u v\n⊢ (Max.max (Max.max (Top.top.induce (Insert.insert u (Singleton.singleton v))) H) K).Connected","decl":"lemma Connected.adj_union {H K : G.Subgraph}\n    (Hconn : H.Connected) (Kconn : K.Connected) {u v : V} (uH : u ∈ H.verts) (vK : v ∈ K.verts)\n    (huv : G.Adj u v) :\n    ((⊤ : G.Subgraph).induce {u, v} ⊔ H ⊔ K).Connected := by\n  refine ((top_induce_pair_connected_of_adj huv).sup Hconn ?_).sup Kconn ?_\n  · exact ⟨u, by simp [uH]⟩\n  · exact ⟨v, by simp [vK]⟩\n\n"}
{"name":"SimpleGraph.Subgraph.preconnected_iff_forall_exists_walk_subgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Iff H.Preconnected (∀ {u v : V}, Membership.mem H.verts u → Membership.mem H.verts v → Exists fun p => LE.le p.toSubgraph H)","decl":"lemma preconnected_iff_forall_exists_walk_subgraph (H : G.Subgraph) :\n    H.Preconnected ↔ ∀ {u v}, u ∈ H.verts → v ∈ H.verts → ∃ p : G.Walk u v, p.toSubgraph ≤ H := by\n  constructor\n  · intro hc u v hu hv\n    refine (hc ⟨_, hu⟩ ⟨_, hv⟩).elim fun p => ?_\n    exists p.map (Subgraph.hom _)\n    simp [coeSubgraph_le]\n  · intro hw\n    rw [Subgraph.preconnected_iff]\n    rintro ⟨u, hu⟩ ⟨v, hv⟩\n    obtain ⟨p, h⟩ := hw hu hv\n    exact Reachable.map (Subgraph.inclusion h)\n      (p.toSubgraph_connected ⟨_, p.start_mem_verts_toSubgraph⟩ ⟨_, p.end_mem_verts_toSubgraph⟩)\n\n"}
{"name":"SimpleGraph.Subgraph.connected_iff_forall_exists_walk_subgraph","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\n⊢ Iff H.Connected (And H.verts.Nonempty (∀ {u v : V}, Membership.mem H.verts u → Membership.mem H.verts v → Exists fun p => LE.le p.toSubgraph H))","decl":"lemma connected_iff_forall_exists_walk_subgraph (H : G.Subgraph) :\n    H.Connected ↔\n      H.verts.Nonempty ∧\n        ∀ {u v}, u ∈ H.verts → v ∈ H.verts → ∃ p : G.Walk u v, p.toSubgraph ≤ H := by\n  rw [H.connected_iff, preconnected_iff_forall_exists_walk_subgraph, and_comm]\n\n"}
{"name":"SimpleGraph.connected_induce_iff","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set V\n⊢ Iff (SimpleGraph.induce s G).Connected (Top.top.induce s).Connected","decl":"lemma connected_induce_iff {s : Set V} :\n    (G.induce s).Connected ↔ ((⊤ : G.Subgraph).induce s).Connected := by\n  rw [induce_eq_coe_induce_top, ← Subgraph.connected_iff']\n\n"}
{"name":"SimpleGraph.induce_union_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns t : Set V\nsconn : (SimpleGraph.induce s G).Connected\ntconn : (SimpleGraph.induce t G).Connected\nsintert : (Inter.inter s t).Nonempty\n⊢ (SimpleGraph.induce (Union.union s t) G).Connected","decl":"lemma induce_union_connected {s t : Set V}\n    (sconn : (G.induce s).Connected) (tconn : (G.induce t).Connected)\n    (sintert : (s ∩ t).Nonempty) :\n    (G.induce (s ∪ t)).Connected := by\n  rw [connected_induce_iff] at sconn tconn ⊢\n  exact Subgraph.induce_union_connected sconn tconn sintert\n\n"}
{"name":"SimpleGraph.induce_pair_connected_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nhuv : G.Adj u v\n⊢ (SimpleGraph.induce (Insert.insert u (Singleton.singleton v)) G).Connected","decl":"lemma induce_pair_connected_of_adj {u v : V} (huv : G.Adj u v) :\n    (G.induce {u, v}).Connected := by\n  rw [connected_induce_iff]\n  exact Subgraph.top_induce_pair_connected_of_adj huv\n\n"}
{"name":"SimpleGraph.Subgraph.Connected.induce_verts","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nH : G.Subgraph\nh : H.Connected\n⊢ (SimpleGraph.induce H.verts G).Connected","decl":"lemma Subgraph.Connected.induce_verts {H : G.Subgraph} (h : H.Connected) :\n    (G.induce H.verts).Connected := by\n  rw [connected_induce_iff]\n  exact h.mono le_induce_top_verts (by exact rfl)\n\n"}
{"name":"SimpleGraph.Walk.connected_induce_support","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ (SimpleGraph.induce (setOf fun v_1 => Membership.mem p.support v_1) G).Connected","decl":"lemma Walk.connected_induce_support {u v : V} (p : G.Walk u v) :\n    (G.induce {v | v ∈ p.support}).Connected := by\n  rw [← p.verts_toSubgraph]\n  exact p.toSubgraph_connected.induce_verts\n\n"}
{"name":"SimpleGraph.induce_connected_adj_union","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\ns t : Set V\nsconn : (SimpleGraph.induce s G).Connected\ntconn : (SimpleGraph.induce t G).Connected\nhv : Membership.mem s v\nhw : Membership.mem t w\nha : G.Adj v w\n⊢ (SimpleGraph.induce (Union.union s t) G).Connected","decl":"lemma induce_connected_adj_union {v w : V} {s t : Set V}\n    (sconn : (G.induce s).Connected) (tconn : (G.induce t).Connected)\n    (hv : v ∈ s) (hw : w ∈ t) (ha : G.Adj v w) :\n    (G.induce (s ∪ t)).Connected := by\n  rw [connected_induce_iff] at sconn tconn ⊢\n  apply (sconn.adj_union tconn hv hw ha).mono\n  · simp only [Set.mem_singleton_iff, sup_le_iff, Subgraph.le_induce_union_left,\n      Subgraph.le_induce_union_right, and_true, ← Subgraph.subgraphOfAdj_eq_induce ha]\n    apply subgraphOfAdj_le_of_adj\n    simp [hv, hw, ha]\n  · simp only [Set.mem_singleton_iff, sup_le_iff, Subgraph.verts_sup, Subgraph.induce_verts]\n    rw [Set.union_assoc]\n    simp [Set.insert_subset_iff, Set.singleton_subset_iff, hv, hw]\n\n"}
{"name":"SimpleGraph.induce_connected_of_patches","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set V\nu : V\nhu : Membership.mem s u\npatches : ∀ {v : V}, Membership.mem s v → Exists fun s' => And (HasSubset.Subset s' s) (Exists fun hu' => Exists fun hv' => (SimpleGraph.induce s' G).Reachable ⟨u, hu'⟩ ⟨v, hv'⟩)\n⊢ (SimpleGraph.induce s G).Connected","decl":"lemma induce_connected_of_patches {s : Set V} (u : V) (hu : u ∈ s)\n    (patches : ∀ {v}, v ∈ s → ∃ s' ⊆ s, ∃ (hu' : u ∈ s') (hv' : v ∈ s'),\n                  (G.induce s').Reachable ⟨u, hu'⟩ ⟨v, hv'⟩) : (G.induce s).Connected := by\n  rw [connected_iff_exists_forall_reachable]\n  refine ⟨⟨u, hu⟩, ?_⟩\n  rintro ⟨v, hv⟩\n  obtain ⟨sv, svs, hu', hv', uv⟩ := patches hv\n  exact uv.map (induceHomOfLE _ svs).toHom\n\n"}
{"name":"SimpleGraph.induce_sUnion_connected_of_pairwise_not_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nS : Set (Set V)\nSn : S.Nonempty\nSnd : ∀ {s t : Set V}, Membership.mem S s → Membership.mem S t → (Inter.inter s t).Nonempty\nSc : ∀ {s : Set V}, Membership.mem S s → (SimpleGraph.induce s G).Connected\n⊢ (SimpleGraph.induce S.sUnion G).Connected","decl":"lemma induce_sUnion_connected_of_pairwise_not_disjoint {S : Set (Set V)} (Sn : S.Nonempty)\n    (Snd : ∀ {s t}, s ∈ S → t ∈ S → (s ∩ t).Nonempty)\n    (Sc : ∀ {s}, s ∈ S → (G.induce s).Connected) :\n    (G.induce (⋃₀ S)).Connected := by\n  obtain ⟨s, sS⟩ := Sn\n  obtain ⟨v, vs⟩ := (Sc sS).nonempty\n  apply G.induce_connected_of_patches _ (Set.subset_sUnion_of_mem sS vs)\n  rintro w hw\n  simp only [Set.mem_sUnion, exists_prop] at hw\n  obtain ⟨t, tS, wt⟩ := hw\n  refine ⟨s ∪ t, Set.union_subset (Set.subset_sUnion_of_mem sS) (Set.subset_sUnion_of_mem tS),\n          Or.inl vs, Or.inr wt, induce_union_connected (Sc sS) (Sc tS) (Snd sS tS) _ _⟩\n\n"}
{"name":"SimpleGraph.extend_finset_to_connected","module":"Mathlib.Combinatorics.SimpleGraph.Connectivity.Subgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nGpc : G.Preconnected\nt : Finset V\ntn : t.Nonempty\n⊢ Exists fun t' => And (HasSubset.Subset t t') (SimpleGraph.induce (↑t') G).Connected","decl":"lemma extend_finset_to_connected (Gpc : G.Preconnected) {t : Finset V} (tn : t.Nonempty) :\n    ∃ (t' : Finset V), t ⊆ t' ∧ (G.induce (t' : Set V)).Connected := by\n  classical\n  obtain ⟨u, ut⟩ := tn\n  refine ⟨t.biUnion (fun v => (Gpc u v).some.support.toFinset), fun v vt => ?_, ?_⟩\n  · simp only [Finset.mem_biUnion, List.mem_toFinset, exists_prop]\n    exact ⟨v, vt, Walk.end_mem_support _⟩\n  · apply G.induce_connected_of_patches u\n    · simp only [Finset.coe_biUnion, Finset.mem_coe, List.coe_toFinset, Set.mem_iUnion,\n                 Set.mem_setOf_eq, Walk.start_mem_support, exists_prop, and_true]\n      exact ⟨u, ut⟩\n    intros v hv\n    simp only [Finset.mem_coe, Finset.mem_biUnion, List.mem_toFinset, exists_prop] at hv\n    obtain ⟨w, wt, hw⟩ := hv\n    refine ⟨{x | x ∈ (Gpc u w).some.support}, ?_, ?_⟩\n    · simp only [Finset.coe_biUnion, Finset.mem_coe, List.coe_toFinset]\n      exact fun x xw => Set.mem_iUnion₂.mpr ⟨w,wt,xw⟩\n    · simp only [Set.mem_setOf_eq, Walk.start_mem_support, exists_true_left]\n      refine ⟨hw, Walk.connected_induce_support _ _ _⟩\n\n"}
