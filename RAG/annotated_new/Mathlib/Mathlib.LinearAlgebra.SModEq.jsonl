{"name":"SModEq.def","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\n⊢ Iff (SModEq U x y) (Eq (Submodule.Quotient.mk x) (Submodule.Quotient.mk y))","decl":"protected theorem SModEq.def :\n    x ≡ y [SMOD U] ↔ (Submodule.Quotient.mk x : M ⧸ U) = Submodule.Quotient.mk y :=\n  Iff.rfl\n\n"}
{"name":"SModEq.sub_mem","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\n⊢ Iff (SModEq U x y) (Membership.mem U (HSub.hSub x y))","decl":"theorem sub_mem : x ≡ y [SMOD U] ↔ x - y ∈ U := by rw [SModEq.def, Submodule.Quotient.eq]\n\n"}
{"name":"SModEq.top","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ SModEq Top.top x y","decl":"@[simp]\ntheorem top : x ≡ y [SMOD (⊤ : Submodule R M)] :=\n  (Submodule.Quotient.eq ⊤).2 mem_top\n\n"}
{"name":"SModEq.bot","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\n⊢ Iff (SModEq Bot.bot x y) (Eq x y)","decl":"@[simp]\ntheorem bot : x ≡ y [SMOD (⊥ : Submodule R M)] ↔ x = y := by\n  rw [SModEq.def, Submodule.Quotient.eq, mem_bot, sub_eq_zero]\n\n"}
{"name":"SModEq.mono","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU₁ U₂ : Submodule R M\nx y : M\nHU : LE.le U₁ U₂\nhxy : SModEq U₁ x y\n⊢ SModEq U₂ x y","decl":"@[mono]\ntheorem mono (HU : U₁ ≤ U₂) (hxy : x ≡ y [SMOD U₁]) : x ≡ y [SMOD U₂] :=\n  (Submodule.Quotient.eq U₂).2 <| HU <| (Submodule.Quotient.eq U₁).1 hxy\n\n"}
{"name":"SModEq.refl","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx : M\n⊢ SModEq U x x","decl":"@[refl]\nprotected theorem refl (x : M) : x ≡ x [SMOD U] :=\n  @rfl _ _\n\n"}
{"name":"SModEq.rfl","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx : M\n⊢ SModEq U x x","decl":"protected theorem rfl : x ≡ x [SMOD U] :=\n  SModEq.refl _\n\n"}
{"name":"SModEq.instIsRefl","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\n⊢ IsRefl M (SModEq U)","decl":"instance : IsRefl _ (SModEq U) :=\n  ⟨SModEq.refl⟩\n\n"}
{"name":"SModEq.symm","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\nhxy : SModEq U x y\n⊢ SModEq U y x","decl":"@[symm]\nnonrec theorem symm (hxy : x ≡ y [SMOD U]) : y ≡ x [SMOD U] :=\n  hxy.symm\n\n"}
{"name":"SModEq.trans","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y z : M\nhxy : SModEq U x y\nhyz : SModEq U y z\n⊢ SModEq U x z","decl":"@[trans]\nnonrec theorem trans (hxy : x ≡ y [SMOD U]) (hyz : y ≡ z [SMOD U]) : x ≡ z [SMOD U] :=\n  hxy.trans hyz\n\n"}
{"name":"SModEq.add","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx₁ x₂ y₁ y₂ : M\nhxy₁ : SModEq U x₁ y₁\nhxy₂ : SModEq U x₂ y₂\n⊢ SModEq U (HAdd.hAdd x₁ x₂) (HAdd.hAdd y₁ y₂)","decl":"theorem add (hxy₁ : x₁ ≡ y₁ [SMOD U]) (hxy₂ : x₂ ≡ y₂ [SMOD U]) : x₁ + x₂ ≡ y₁ + y₂ [SMOD U] := by\n  rw [SModEq.def] at hxy₁ hxy₂ ⊢\n  simp_rw [Quotient.mk_add, hxy₁, hxy₂]\n\n"}
{"name":"SModEq.smul","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\nhxy : SModEq U x y\nc : R\n⊢ SModEq U (HSMul.hSMul c x) (HSMul.hSMul c y)","decl":"theorem smul (hxy : x ≡ y [SMOD U]) (c : R) : c • x ≡ c • y [SMOD U] := by\n  rw [SModEq.def] at hxy ⊢\n  simp_rw [Quotient.mk_smul, hxy]\n\n"}
{"name":"SModEq.nsmul","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\nhxy : SModEq U x y\nn : Nat\n⊢ SModEq U (HSMul.hSMul n x) (HSMul.hSMul n y)","decl":"lemma nsmul (hxy : x ≡ y [SMOD U]) (n : ℕ) : n • x ≡ n • y [SMOD U] := by\n  rw [SModEq.def] at hxy ⊢\n  simp_rw [Quotient.mk_smul, hxy]\n\n"}
{"name":"SModEq.zsmul","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\nhxy : SModEq U x y\nn : Int\n⊢ SModEq U (HSMul.hSMul n x) (HSMul.hSMul n y)","decl":"lemma zsmul (hxy : x ≡ y [SMOD U]) (n : ℤ) : n • x ≡ n • y [SMOD U] := by\n  rw [SModEq.def] at hxy ⊢\n  simp_rw [Quotient.mk_smul, hxy]\n\n"}
{"name":"SModEq.mul","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nI : Ideal A\nx₁ x₂ y₁ y₂ : A\nhxy₁ : SModEq I x₁ y₁\nhxy₂ : SModEq I x₂ y₂\n⊢ SModEq I (HMul.hMul x₁ x₂) (HMul.hMul y₁ y₂)","decl":"theorem mul {I : Ideal A} {x₁ x₂ y₁ y₂ : A} (hxy₁ : x₁ ≡ y₁ [SMOD I])\n    (hxy₂ : x₂ ≡ y₂ [SMOD I]) : x₁ * x₂ ≡ y₁ * y₂ [SMOD I] := by\n  simp only [SModEq.def, Ideal.Quotient.mk_eq_mk, map_mul] at hxy₁ hxy₂ ⊢\n  rw [hxy₁, hxy₂]\n\n"}
{"name":"SModEq.pow","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"A : Type u_2\ninst✝ : CommRing A\nI : Ideal A\nx y : A\nn : Nat\nhxy : SModEq I x y\n⊢ SModEq I (HPow.hPow x n) (HPow.hPow y n)","decl":"lemma pow {I : Ideal A} {x y : A} (n : ℕ) (hxy : x ≡ y [SMOD I]) :\n    x ^ n ≡ y ^ n [SMOD I] := by\n  simp only [SModEq.def, Ideal.Quotient.mk_eq_mk, map_pow] at hxy ⊢\n  rw [hxy]\n\n"}
{"name":"SModEq.neg","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx y : M\nhxy : SModEq U x y\n⊢ SModEq U (Neg.neg x) (Neg.neg y)","decl":"lemma neg (hxy : x ≡ y [SMOD U]) : - x ≡ - y [SMOD U] := by\n  simpa only [SModEq.def, Quotient.mk_neg, neg_inj]\n\n"}
{"name":"SModEq.sub","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx₁ x₂ y₁ y₂ : M\nhxy₁ : SModEq U x₁ y₁\nhxy₂ : SModEq U x₂ y₂\n⊢ SModEq U (HSub.hSub x₁ x₂) (HSub.hSub y₁ y₂)","decl":"lemma sub (hxy₁ : x₁ ≡ y₁ [SMOD U]) (hxy₂ : x₂ ≡ y₂ [SMOD U]) : x₁ - x₂ ≡ y₁ - y₂ [SMOD U] := by\n  rw [SModEq.def] at hxy₁ hxy₂ ⊢\n  simp_rw [Quotient.mk_sub, hxy₁, hxy₂]\n\n"}
{"name":"SModEq.zero","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nU : Submodule R M\nx : M\n⊢ Iff (SModEq U x 0) (Membership.mem U x)","decl":"theorem zero : x ≡ 0 [SMOD U] ↔ x ∈ U := by rw [SModEq.def, Submodule.Quotient.eq, sub_zero]\n\n"}
{"name":"SModEq.map","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nU : Submodule R M\nx y : M\nN : Type u_4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nhxy : SModEq U x y\nf : LinearMap (RingHom.id R) M N\n⊢ SModEq (Submodule.map f U) (f x) (f y)","decl":"theorem map (hxy : x ≡ y [SMOD U]) (f : M →ₗ[R] N) : f x ≡ f y [SMOD U.map f] :=\n  (Submodule.Quotient.eq _).2 <| f.map_sub x y ▸ mem_map_of_mem <| (Submodule.Quotient.eq _).1 hxy\n\n"}
{"name":"SModEq.comap","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nx y : M\nN : Type u_4\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nV : Submodule R N\nf : LinearMap (RingHom.id R) M N\nhxy : SModEq V (f x) (f y)\n⊢ SModEq (Submodule.comap f V) x y","decl":"theorem comap {f : M →ₗ[R] N} (hxy : f x ≡ f y [SMOD V]) : x ≡ y [SMOD V.comap f] :=\n  (Submodule.Quotient.eq _).2 <|\n    show f (x - y) ∈ V from (f.map_sub x y).symm ▸ (Submodule.Quotient.eq _).1 hxy\n\n"}
{"name":"SModEq.eval","module":"Mathlib.LinearAlgebra.SModEq","initialProofState":"R : Type u_5\ninst✝ : CommRing R\nI : Ideal R\nx y : R\nh : SModEq I x y\nf : Polynomial R\n⊢ SModEq I (Polynomial.eval x f) (Polynomial.eval y f)","decl":"theorem eval {R : Type*} [CommRing R] {I : Ideal R} {x y : R} (h : x ≡ y [SMOD I]) (f : R[X]) :\n    f.eval x ≡ f.eval y [SMOD I] := by\n  rw [SModEq.def] at h ⊢\n  show Ideal.Quotient.mk I (f.eval x) = Ideal.Quotient.mk I (f.eval y)\n  replace h : Ideal.Quotient.mk I x = Ideal.Quotient.mk I y := h\n  rw [← Polynomial.eval₂_at_apply, ← Polynomial.eval₂_at_apply, h]\n\n"}
