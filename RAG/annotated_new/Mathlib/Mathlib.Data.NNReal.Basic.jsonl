{"name":"NNReal.coe_indicator","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î± : Type u_1\ns : Set Î±\nf : Î± â†’ NNReal\na : Î±\nâŠ¢ Eq (â†‘(s.indicator f a)) (s.indicator (fun x => â†‘(f x)) a)","decl":"@[simp, norm_cast]\ntheorem coe_indicator {Î±} (s : Set Î±) (f : Î± â†’ â„â‰¥0) (a : Î±) :\n    ((s.indicator f a : â„â‰¥0) : â„) = s.indicator (fun x => â†‘(f x)) a :=\n  (toRealHom : â„â‰¥0 â†’+ â„).map_indicator _ _ _\n\n"}
{"name":"NNReal.coe_list_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"l : List NNReal\nâŠ¢ Eq (â†‘l.sum) (List.map NNReal.toReal l).sum","decl":"@[norm_cast]\ntheorem coe_list_sum (l : List â„â‰¥0) : ((l.sum : â„â‰¥0) : â„) = (l.map (â†‘)).sum :=\n  map_list_sum toRealHom l\n\n"}
{"name":"NNReal.coe_list_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"l : List NNReal\nâŠ¢ Eq (â†‘l.prod) (List.map NNReal.toReal l).prod","decl":"@[norm_cast]\ntheorem coe_list_prod (l : List â„â‰¥0) : ((l.prod : â„â‰¥0) : â„) = (l.map (â†‘)).prod :=\n  map_list_prod toRealHom l\n\n"}
{"name":"NNReal.coe_multiset_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"s : Multiset NNReal\nâŠ¢ Eq (â†‘s.sum) (Multiset.map NNReal.toReal s).sum","decl":"@[norm_cast]\ntheorem coe_multiset_sum (s : Multiset â„â‰¥0) : ((s.sum : â„â‰¥0) : â„) = (s.map (â†‘)).sum :=\n  map_multiset_sum toRealHom s\n\n"}
{"name":"NNReal.coe_multiset_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"s : Multiset NNReal\nâŠ¢ Eq (â†‘s.prod) (Multiset.map NNReal.toReal s).prod","decl":"@[norm_cast]\ntheorem coe_multiset_prod (s : Multiset â„â‰¥0) : ((s.prod : â„â‰¥0) : â„) = (s.map (â†‘)).prod :=\n  map_multiset_prod toRealHom s\n\n"}
{"name":"NNReal.coe_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Type u_1\ns : Finset Î¹\nf : Î¹ â†’ NNReal\nâŠ¢ Eq (â†‘(s.sum fun i => f i)) (s.sum fun i => â†‘(f i))","decl":"@[simp, norm_cast]\ntheorem coe_sum (s : Finset Î¹) (f : Î¹ â†’ â„â‰¥0) : âˆ‘ i âˆˆ s, f i = âˆ‘ i âˆˆ s, (f i : â„) :=\n  map_sum toRealHom _ _\n\n"}
{"name":"NNReal.coe_expect","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Type u_1\ns : Finset Î¹\nf : Î¹ â†’ NNReal\nâŠ¢ Eq (â†‘(s.expect fun i => f i)) (s.expect fun i => â†‘(f i))","decl":"@[simp, norm_cast]\nlemma coe_expect (s : Finset Î¹) (f : Î¹ â†’ â„â‰¥0) : ð”¼ i âˆˆ s, f i = ð”¼ i âˆˆ s, (f i : â„) :=\n  map_expect toRealHom ..\n\n"}
{"name":"Real.toNNReal_sum_of_nonneg","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Type u_1\ns : Finset Î¹\nf : Î¹ â†’ Real\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le 0 (f i)\nâŠ¢ Eq (s.sum fun a => f a).toNNReal (s.sum fun a => (f a).toNNReal)","decl":"theorem _root_.Real.toNNReal_sum_of_nonneg (hf : âˆ€ i âˆˆ s, 0 â‰¤ f i) :\n    Real.toNNReal (âˆ‘ a âˆˆ s, f a) = âˆ‘ a âˆˆ s, Real.toNNReal (f a) := by\n  rw [â† coe_inj, NNReal.coe_sum, Real.coe_toNNReal _ (Finset.sum_nonneg hf)]\n  exact Finset.sum_congr rfl fun x hxs => by rw [Real.coe_toNNReal _ (hf x hxs)]\n\n"}
{"name":"NNReal.coe_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Type u_1\ns : Finset Î¹\nf : Î¹ â†’ NNReal\nâŠ¢ Eq (â†‘(s.prod fun a => f a)) (s.prod fun a => â†‘(f a))","decl":"@[simp, norm_cast]\ntheorem coe_prod (s : Finset Î¹) (f : Î¹ â†’ â„â‰¥0) : â†‘(âˆ a âˆˆ s, f a) = âˆ a âˆˆ s, (f a : â„) :=\n  map_prod toRealHom _ _\n\n"}
{"name":"Real.toNNReal_prod_of_nonneg","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Type u_1\ns : Finset Î¹\nf : Î¹ â†’ Real\nhf : âˆ€ (a : Î¹), Membership.mem s a â†’ LE.le 0 (f a)\nâŠ¢ Eq (s.prod fun a => f a).toNNReal (s.prod fun a => (f a).toNNReal)","decl":"theorem _root_.Real.toNNReal_prod_of_nonneg (hf : âˆ€ a, a âˆˆ s â†’ 0 â‰¤ f a) :\n    Real.toNNReal (âˆ a âˆˆ s, f a) = âˆ a âˆˆ s, Real.toNNReal (f a) := by\n  rw [â† coe_inj, NNReal.coe_prod, Real.coe_toNNReal _ (Finset.prod_nonneg hf)]\n  exact Finset.prod_congr rfl fun x hxs => by rw [Real.coe_toNNReal _ (hf x hxs)]\n\n"}
{"name":"NNReal.le_iInf_add_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nÎ¹' : Sort u_3\ninstâœÂ¹ : Nonempty Î¹\ninstâœ : Nonempty Î¹'\nf : Î¹ â†’ NNReal\ng : Î¹' â†’ NNReal\na : NNReal\nh : âˆ€ (i : Î¹) (j : Î¹'), LE.le a (HAdd.hAdd (f i) (g j))\nâŠ¢ LE.le a (HAdd.hAdd (iInf fun i => f i) (iInf fun j => g j))","decl":"theorem le_iInf_add_iInf {Î¹ Î¹' : Sort*} [Nonempty Î¹] [Nonempty Î¹'] {f : Î¹ â†’ â„â‰¥0} {g : Î¹' â†’ â„â‰¥0}\n    {a : â„â‰¥0} (h : âˆ€ i j, a â‰¤ f i + g j) : a â‰¤ (â¨… i, f i) + â¨… j, g j := by\n  rw [â† NNReal.coe_le_coe, NNReal.coe_add, coe_iInf, coe_iInf]\n  exact le_ciInf_add_ciInf h\n\n"}
{"name":"NNReal.mul_finset_sup","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î± : Type u_2\nr : NNReal\ns : Finset Î±\nf : Î± â†’ NNReal\nâŠ¢ Eq (HMul.hMul r (s.sup f)) (s.sup fun a => HMul.hMul r (f a))","decl":"theorem mul_finset_sup {Î±} (r : â„â‰¥0) (s : Finset Î±) (f : Î± â†’ â„â‰¥0) :\n    r * s.sup f = s.sup fun a => r * f a :=\n  Finset.comp_sup_eq_sup_comp _ (NNReal.mul_sup r) (mul_zero r)\n\n"}
{"name":"NNReal.finset_sup_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î± : Type u_2\ns : Finset Î±\nf : Î± â†’ NNReal\nr : NNReal\nâŠ¢ Eq (HMul.hMul (s.sup f) r) (s.sup fun a => HMul.hMul (f a) r)","decl":"theorem finset_sup_mul {Î±} (s : Finset Î±) (f : Î± â†’ â„â‰¥0) (r : â„â‰¥0) :\n    s.sup f * r = s.sup fun a => f a * r :=\n  Finset.comp_sup_eq_sup_comp (Â· * r) (fun x y => NNReal.sup_mul x y r) (zero_mul r)\n\n"}
{"name":"NNReal.finset_sup_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î± : Type u_2\nf : Î± â†’ NNReal\ns : Finset Î±\nr : NNReal\nâŠ¢ Eq (HDiv.hDiv (s.sup f) r) (s.sup fun a => HDiv.hDiv (f a) r)","decl":"theorem finset_sup_div {Î±} {f : Î± â†’ â„â‰¥0} {s : Finset Î±} (r : â„â‰¥0) :\n    s.sup f / r = s.sup fun a => f a / r := by simp only [div_eq_inv_mul, mul_finset_sup]\n\n"}
{"name":"NNReal.sub_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"a b c : NNReal\nâŠ¢ Eq (HDiv.hDiv (HSub.hSub a b) c) (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem sub_div (a b c : â„â‰¥0) : (a - b) / c = a / c - b / c :=\n  tsub_div _ _ _\n\n"}
{"name":"NNReal.iInf_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nf : Î¹ â†’ NNReal\na : NNReal\nâŠ¢ Eq (HMul.hMul (iInf f) a) (iInf fun i => HMul.hMul (f i) a)","decl":"theorem iInf_mul (f : Î¹ â†’ â„â‰¥0) (a : â„â‰¥0) : iInf f * a = â¨… i, f i * a := by\n  rw [â† coe_inj, NNReal.coe_mul, coe_iInf, coe_iInf]\n  exact Real.iInf_mul_of_nonneg (NNReal.coe_nonneg _) _\n\n"}
{"name":"NNReal.mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nf : Î¹ â†’ NNReal\na : NNReal\nâŠ¢ Eq (HMul.hMul a (iInf f)) (iInf fun i => HMul.hMul a (f i))","decl":"theorem mul_iInf (f : Î¹ â†’ â„â‰¥0) (a : â„â‰¥0) : a * iInf f = â¨… i, a * f i := by\n  simpa only [mul_comm] using iInf_mul f a\n\n"}
{"name":"NNReal.mul_iSup","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nf : Î¹ â†’ NNReal\na : NNReal\nâŠ¢ Eq (HMul.hMul a (iSup fun i => f i)) (iSup fun i => HMul.hMul a (f i))","decl":"theorem mul_iSup (f : Î¹ â†’ â„â‰¥0) (a : â„â‰¥0) : (a * â¨† i, f i) = â¨† i, a * f i := by\n  rw [â† coe_inj, NNReal.coe_mul, NNReal.coe_iSup, NNReal.coe_iSup]\n  exact Real.mul_iSup_of_nonneg (NNReal.coe_nonneg _) _\n\n"}
{"name":"NNReal.iSup_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nf : Î¹ â†’ NNReal\na : NNReal\nâŠ¢ Eq (HMul.hMul (iSup fun i => f i) a) (iSup fun i => HMul.hMul (f i) a)","decl":"theorem iSup_mul (f : Î¹ â†’ â„â‰¥0) (a : â„â‰¥0) : (â¨† i, f i) * a = â¨† i, f i * a := by\n  rw [mul_comm, mul_iSup]\n  simp_rw [mul_comm]\n\n"}
{"name":"NNReal.iSup_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\nf : Î¹ â†’ NNReal\na : NNReal\nâŠ¢ Eq (HDiv.hDiv (iSup fun i => f i) a) (iSup fun i => HDiv.hDiv (f i) a)","decl":"theorem iSup_div (f : Î¹ â†’ â„â‰¥0) (a : â„â‰¥0) : (â¨† i, f i) / a = â¨† i, f i / a := by\n  simp only [div_eq_mul_inv, iSup_mul]\n\n-- Porting note: generalized to allow empty `Î¹`\n"}
{"name":"NNReal.mul_iSup_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\na g : NNReal\nh : Î¹ â†’ NNReal\nH : âˆ€ (j : Î¹), LE.le (HMul.hMul g (h j)) a\nâŠ¢ LE.le (HMul.hMul g (iSup h)) a","decl":"theorem mul_iSup_le {a : â„â‰¥0} {g : â„â‰¥0} {h : Î¹ â†’ â„â‰¥0} (H : âˆ€ j, g * h j â‰¤ a) : g * iSup h â‰¤ a := by\n  rw [mul_iSup]\n  exact ciSup_le' H\n\n-- Porting note: generalized to allow empty `Î¹`\n"}
{"name":"NNReal.iSup_mul_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\na : NNReal\ng : Î¹ â†’ NNReal\nh : NNReal\nH : âˆ€ (i : Î¹), LE.le (HMul.hMul (g i) h) a\nâŠ¢ LE.le (HMul.hMul (iSup g) h) a","decl":"theorem iSup_mul_le {a : â„â‰¥0} {g : Î¹ â†’ â„â‰¥0} {h : â„â‰¥0} (H : âˆ€ i, g i * h â‰¤ a) : iSup g * h â‰¤ a := by\n  rw [iSup_mul]\n  exact ciSup_le' H\n\n-- Porting note: generalized to allow empty `Î¹`\n"}
{"name":"NNReal.iSup_mul_iSup_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\na : NNReal\ng h : Î¹ â†’ NNReal\nH : âˆ€ (i j : Î¹), LE.le (HMul.hMul (g i) (h j)) a\nâŠ¢ LE.le (HMul.hMul (iSup g) (iSup h)) a","decl":"theorem iSup_mul_iSup_le {a : â„â‰¥0} {g h : Î¹ â†’ â„â‰¥0} (H : âˆ€ i j, g i * h j â‰¤ a) :\n    iSup g * iSup h â‰¤ a :=\n  iSup_mul_le fun _ => mul_iSup_le <| H _\n\n"}
{"name":"NNReal.le_mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\ninstâœ : Nonempty Î¹\na g : NNReal\nh : Î¹ â†’ NNReal\nH : âˆ€ (j : Î¹), LE.le a (HMul.hMul g (h j))\nâŠ¢ LE.le a (HMul.hMul g (iInf h))","decl":"theorem le_mul_iInf {a : â„â‰¥0} {g : â„â‰¥0} {h : Î¹ â†’ â„â‰¥0} (H : âˆ€ j, a â‰¤ g * h j) : a â‰¤ g * iInf h := by\n  rw [mul_iInf]\n  exact le_ciInf H\n\n"}
{"name":"NNReal.le_iInf_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\ninstâœ : Nonempty Î¹\na : NNReal\ng : Î¹ â†’ NNReal\nh : NNReal\nH : âˆ€ (i : Î¹), LE.le a (HMul.hMul (g i) h)\nâŠ¢ LE.le a (HMul.hMul (iInf g) h)","decl":"theorem le_iInf_mul {a : â„â‰¥0} {g : Î¹ â†’ â„â‰¥0} {h : â„â‰¥0} (H : âˆ€ i, a â‰¤ g i * h) : a â‰¤ iInf g * h := by\n  rw [iInf_mul]\n  exact le_ciInf H\n\n"}
{"name":"NNReal.le_iInf_mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"Î¹ : Sort u_2\ninstâœ : Nonempty Î¹\na : NNReal\ng h : Î¹ â†’ NNReal\nH : âˆ€ (i j : Î¹), LE.le a (HMul.hMul (g i) (h j))\nâŠ¢ LE.le a (HMul.hMul (iInf g) (iInf h))","decl":"theorem le_iInf_mul_iInf {a : â„â‰¥0} {g h : Î¹ â†’ â„â‰¥0} (H : âˆ€ i j, a â‰¤ g i * h j) :\n    a â‰¤ iInf g * iInf h :=\n  le_iInf_mul fun i => le_mul_iInf <| H i\n\n"}
