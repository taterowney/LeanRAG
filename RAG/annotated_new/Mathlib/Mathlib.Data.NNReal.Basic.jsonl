{"name":"NNReal.coe_indicator","module":"Mathlib.Data.NNReal.Basic","initialProofState":"α : Type u_1\ns : Set α\nf : α → NNReal\na : α\n⊢ Eq (↑(s.indicator f a)) (s.indicator (fun x => ↑(f x)) a)","decl":"@[simp, norm_cast]\ntheorem coe_indicator {α} (s : Set α) (f : α → ℝ≥0) (a : α) :\n    ((s.indicator f a : ℝ≥0) : ℝ) = s.indicator (fun x => ↑(f x)) a :=\n  (toRealHom : ℝ≥0 →+ ℝ).map_indicator _ _ _\n\n"}
{"name":"NNReal.coe_list_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"l : List NNReal\n⊢ Eq (↑l.sum) (List.map NNReal.toReal l).sum","decl":"@[norm_cast]\ntheorem coe_list_sum (l : List ℝ≥0) : ((l.sum : ℝ≥0) : ℝ) = (l.map (↑)).sum :=\n  map_list_sum toRealHom l\n\n"}
{"name":"NNReal.coe_list_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"l : List NNReal\n⊢ Eq (↑l.prod) (List.map NNReal.toReal l).prod","decl":"@[norm_cast]\ntheorem coe_list_prod (l : List ℝ≥0) : ((l.prod : ℝ≥0) : ℝ) = (l.map (↑)).prod :=\n  map_list_prod toRealHom l\n\n"}
{"name":"NNReal.coe_multiset_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"s : Multiset NNReal\n⊢ Eq (↑s.sum) (Multiset.map NNReal.toReal s).sum","decl":"@[norm_cast]\ntheorem coe_multiset_sum (s : Multiset ℝ≥0) : ((s.sum : ℝ≥0) : ℝ) = (s.map (↑)).sum :=\n  map_multiset_sum toRealHom s\n\n"}
{"name":"NNReal.coe_multiset_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"s : Multiset NNReal\n⊢ Eq (↑s.prod) (Multiset.map NNReal.toReal s).prod","decl":"@[norm_cast]\ntheorem coe_multiset_prod (s : Multiset ℝ≥0) : ((s.prod : ℝ≥0) : ℝ) = (s.map (↑)).prod :=\n  map_multiset_prod toRealHom s\n\n"}
{"name":"NNReal.coe_sum","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → NNReal\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem coe_sum (s : Finset ι) (f : ι → ℝ≥0) : ∑ i ∈ s, f i = ∑ i ∈ s, (f i : ℝ) :=\n  map_sum toRealHom _ _\n\n"}
{"name":"NNReal.coe_expect","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → NNReal\n⊢ Eq (↑(s.expect fun i => f i)) (s.expect fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma coe_expect (s : Finset ι) (f : ι → ℝ≥0) : 𝔼 i ∈ s, f i = 𝔼 i ∈ s, (f i : ℝ) :=\n  map_expect toRealHom ..\n\n"}
{"name":"Real.toNNReal_sum_of_nonneg","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → Real\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ Eq (s.sum fun a => f a).toNNReal (s.sum fun a => (f a).toNNReal)","decl":"theorem _root_.Real.toNNReal_sum_of_nonneg (hf : ∀ i ∈ s, 0 ≤ f i) :\n    Real.toNNReal (∑ a ∈ s, f a) = ∑ a ∈ s, Real.toNNReal (f a) := by\n  rw [← coe_inj, NNReal.coe_sum, Real.coe_toNNReal _ (Finset.sum_nonneg hf)]\n  exact Finset.sum_congr rfl fun x hxs => by rw [Real.coe_toNNReal _ (hf x hxs)]\n\n"}
{"name":"NNReal.coe_prod","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → NNReal\n⊢ Eq (↑(s.prod fun a => f a)) (s.prod fun a => ↑(f a))","decl":"@[simp, norm_cast]\ntheorem coe_prod (s : Finset ι) (f : ι → ℝ≥0) : ↑(∏ a ∈ s, f a) = ∏ a ∈ s, (f a : ℝ) :=\n  map_prod toRealHom _ _\n\n"}
{"name":"Real.toNNReal_prod_of_nonneg","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → Real\nhf : ∀ (a : ι), Membership.mem s a → LE.le 0 (f a)\n⊢ Eq (s.prod fun a => f a).toNNReal (s.prod fun a => (f a).toNNReal)","decl":"theorem _root_.Real.toNNReal_prod_of_nonneg (hf : ∀ a, a ∈ s → 0 ≤ f a) :\n    Real.toNNReal (∏ a ∈ s, f a) = ∏ a ∈ s, Real.toNNReal (f a) := by\n  rw [← coe_inj, NNReal.coe_prod, Real.coe_toNNReal _ (Finset.prod_nonneg hf)]\n  exact Finset.prod_congr rfl fun x hxs => by rw [Real.coe_toNNReal _ (hf x hxs)]\n\n"}
{"name":"NNReal.le_iInf_add_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nι' : Sort u_3\ninst✝¹ : Nonempty ι\ninst✝ : Nonempty ι'\nf : ι → NNReal\ng : ι' → NNReal\na : NNReal\nh : ∀ (i : ι) (j : ι'), LE.le a (HAdd.hAdd (f i) (g j))\n⊢ LE.le a (HAdd.hAdd (iInf fun i => f i) (iInf fun j => g j))","decl":"theorem le_iInf_add_iInf {ι ι' : Sort*} [Nonempty ι] [Nonempty ι'] {f : ι → ℝ≥0} {g : ι' → ℝ≥0}\n    {a : ℝ≥0} (h : ∀ i j, a ≤ f i + g j) : a ≤ (⨅ i, f i) + ⨅ j, g j := by\n  rw [← NNReal.coe_le_coe, NNReal.coe_add, coe_iInf, coe_iInf]\n  exact le_ciInf_add_ciInf h\n\n"}
{"name":"NNReal.mul_finset_sup","module":"Mathlib.Data.NNReal.Basic","initialProofState":"α : Type u_2\nr : NNReal\ns : Finset α\nf : α → NNReal\n⊢ Eq (HMul.hMul r (s.sup f)) (s.sup fun a => HMul.hMul r (f a))","decl":"theorem mul_finset_sup {α} (r : ℝ≥0) (s : Finset α) (f : α → ℝ≥0) :\n    r * s.sup f = s.sup fun a => r * f a :=\n  Finset.comp_sup_eq_sup_comp _ (NNReal.mul_sup r) (mul_zero r)\n\n"}
{"name":"NNReal.finset_sup_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"α : Type u_2\ns : Finset α\nf : α → NNReal\nr : NNReal\n⊢ Eq (HMul.hMul (s.sup f) r) (s.sup fun a => HMul.hMul (f a) r)","decl":"theorem finset_sup_mul {α} (s : Finset α) (f : α → ℝ≥0) (r : ℝ≥0) :\n    s.sup f * r = s.sup fun a => f a * r :=\n  Finset.comp_sup_eq_sup_comp (· * r) (fun x y => NNReal.sup_mul x y r) (zero_mul r)\n\n"}
{"name":"NNReal.finset_sup_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"α : Type u_2\nf : α → NNReal\ns : Finset α\nr : NNReal\n⊢ Eq (HDiv.hDiv (s.sup f) r) (s.sup fun a => HDiv.hDiv (f a) r)","decl":"theorem finset_sup_div {α} {f : α → ℝ≥0} {s : Finset α} (r : ℝ≥0) :\n    s.sup f / r = s.sup fun a => f a / r := by simp only [div_eq_inv_mul, mul_finset_sup]\n\n"}
{"name":"NNReal.sub_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"a b c : NNReal\n⊢ Eq (HDiv.hDiv (HSub.hSub a b) c) (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem sub_div (a b c : ℝ≥0) : (a - b) / c = a / c - b / c :=\n  tsub_div _ _ _\n\n"}
{"name":"NNReal.iInf_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\na : NNReal\n⊢ Eq (HMul.hMul (iInf f) a) (iInf fun i => HMul.hMul (f i) a)","decl":"theorem iInf_mul (f : ι → ℝ≥0) (a : ℝ≥0) : iInf f * a = ⨅ i, f i * a := by\n  rw [← coe_inj, NNReal.coe_mul, coe_iInf, coe_iInf]\n  exact Real.iInf_mul_of_nonneg (NNReal.coe_nonneg _) _\n\n"}
{"name":"NNReal.mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\na : NNReal\n⊢ Eq (HMul.hMul a (iInf f)) (iInf fun i => HMul.hMul a (f i))","decl":"theorem mul_iInf (f : ι → ℝ≥0) (a : ℝ≥0) : a * iInf f = ⨅ i, a * f i := by\n  simpa only [mul_comm] using iInf_mul f a\n\n"}
{"name":"NNReal.mul_iSup","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\na : NNReal\n⊢ Eq (HMul.hMul a (iSup fun i => f i)) (iSup fun i => HMul.hMul a (f i))","decl":"theorem mul_iSup (f : ι → ℝ≥0) (a : ℝ≥0) : (a * ⨆ i, f i) = ⨆ i, a * f i := by\n  rw [← coe_inj, NNReal.coe_mul, NNReal.coe_iSup, NNReal.coe_iSup]\n  exact Real.mul_iSup_of_nonneg (NNReal.coe_nonneg _) _\n\n"}
{"name":"NNReal.iSup_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\na : NNReal\n⊢ Eq (HMul.hMul (iSup fun i => f i) a) (iSup fun i => HMul.hMul (f i) a)","decl":"theorem iSup_mul (f : ι → ℝ≥0) (a : ℝ≥0) : (⨆ i, f i) * a = ⨆ i, f i * a := by\n  rw [mul_comm, mul_iSup]\n  simp_rw [mul_comm]\n\n"}
{"name":"NNReal.iSup_div","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\na : NNReal\n⊢ Eq (HDiv.hDiv (iSup fun i => f i) a) (iSup fun i => HDiv.hDiv (f i) a)","decl":"theorem iSup_div (f : ι → ℝ≥0) (a : ℝ≥0) : (⨆ i, f i) / a = ⨆ i, f i / a := by\n  simp only [div_eq_mul_inv, iSup_mul]\n\n-- Porting note: generalized to allow empty `ι`\n"}
{"name":"NNReal.mul_iSup_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\na g : NNReal\nh : ι → NNReal\nH : ∀ (j : ι), LE.le (HMul.hMul g (h j)) a\n⊢ LE.le (HMul.hMul g (iSup h)) a","decl":"theorem mul_iSup_le {a : ℝ≥0} {g : ℝ≥0} {h : ι → ℝ≥0} (H : ∀ j, g * h j ≤ a) : g * iSup h ≤ a := by\n  rw [mul_iSup]\n  exact ciSup_le' H\n\n-- Porting note: generalized to allow empty `ι`\n"}
{"name":"NNReal.iSup_mul_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\na : NNReal\ng : ι → NNReal\nh : NNReal\nH : ∀ (i : ι), LE.le (HMul.hMul (g i) h) a\n⊢ LE.le (HMul.hMul (iSup g) h) a","decl":"theorem iSup_mul_le {a : ℝ≥0} {g : ι → ℝ≥0} {h : ℝ≥0} (H : ∀ i, g i * h ≤ a) : iSup g * h ≤ a := by\n  rw [iSup_mul]\n  exact ciSup_le' H\n\n-- Porting note: generalized to allow empty `ι`\n"}
{"name":"NNReal.iSup_mul_iSup_le","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\na : NNReal\ng h : ι → NNReal\nH : ∀ (i j : ι), LE.le (HMul.hMul (g i) (h j)) a\n⊢ LE.le (HMul.hMul (iSup g) (iSup h)) a","decl":"theorem iSup_mul_iSup_le {a : ℝ≥0} {g h : ι → ℝ≥0} (H : ∀ i j, g i * h j ≤ a) :\n    iSup g * iSup h ≤ a :=\n  iSup_mul_le fun _ => mul_iSup_le <| H _\n\n"}
{"name":"NNReal.le_mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\ninst✝ : Nonempty ι\na g : NNReal\nh : ι → NNReal\nH : ∀ (j : ι), LE.le a (HMul.hMul g (h j))\n⊢ LE.le a (HMul.hMul g (iInf h))","decl":"theorem le_mul_iInf {a : ℝ≥0} {g : ℝ≥0} {h : ι → ℝ≥0} (H : ∀ j, a ≤ g * h j) : a ≤ g * iInf h := by\n  rw [mul_iInf]\n  exact le_ciInf H\n\n"}
{"name":"NNReal.le_iInf_mul","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\ninst✝ : Nonempty ι\na : NNReal\ng : ι → NNReal\nh : NNReal\nH : ∀ (i : ι), LE.le a (HMul.hMul (g i) h)\n⊢ LE.le a (HMul.hMul (iInf g) h)","decl":"theorem le_iInf_mul {a : ℝ≥0} {g : ι → ℝ≥0} {h : ℝ≥0} (H : ∀ i, a ≤ g i * h) : a ≤ iInf g * h := by\n  rw [iInf_mul]\n  exact le_ciInf H\n\n"}
{"name":"NNReal.le_iInf_mul_iInf","module":"Mathlib.Data.NNReal.Basic","initialProofState":"ι : Sort u_2\ninst✝ : Nonempty ι\na : NNReal\ng h : ι → NNReal\nH : ∀ (i j : ι), LE.le a (HMul.hMul (g i) (h j))\n⊢ LE.le a (HMul.hMul (iInf g) (iInf h))","decl":"theorem le_iInf_mul_iInf {a : ℝ≥0} {g h : ι → ℝ≥0} (H : ∀ i j, a ≤ g i * h j) :\n    a ≤ iInf g * iInf h :=\n  le_iInf_mul fun i => le_mul_iInf <| H i\n\n"}
