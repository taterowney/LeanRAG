{"name":"NumberField.mixedEmbedding.unitSMul_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù : Field K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (HSMul.hSMul u x) (HMul.hMul ((NumberField.mixedEmbedding K) ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üëu)) x)","decl":"/-- The action of `(ùìû K)À£` on the mixed space `‚Ñù^r‚ÇÅ √ó ‚ÑÇ^r‚ÇÇ` defined, for `u : (ùìû K)À£`, by\nmultiplication component by component with `mixedEmbedding K u`. -/\n@[simps]\ninstance unitSMul : SMul (ùìû K)À£ (mixedSpace K) where\n  smul u x := mixedEmbedding K u * x\n\n"}
{"name":"NumberField.mixedEmbedding.unit_smul_eq_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù : Field K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Eq (HSMul.hSMul u x) 0) (Eq x 0)","decl":"theorem unit_smul_eq_zero (u : (ùìû K)À£) (x : mixedSpace K) :\n    u ‚Ä¢ x = 0 ‚Üî x = 0 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by rw [h, smul_zero]‚ü©\n  contrapose! h\n  obtain ‚ü®w, h‚ü© := exists_normAtPlace_ne_zero_iff.mpr h\n  refine exists_normAtPlace_ne_zero_iff.mp ‚ü®w, ?_‚ü©\n  rw [unitSMul_smul, map_mul]\n  exact mul_ne_zero (by simp) h\n\n"}
{"name":"NumberField.mixedEmbedding.unit_smul_eq_iff_mul_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx y : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\n‚ä¢ Iff (Eq (HSMul.hSMul u ((NumberField.mixedEmbedding K) ‚Üëx)) ((NumberField.mixedEmbedding K) ‚Üëy)) (Eq (HMul.hMul (‚Üëu) x) y)","decl":"theorem unit_smul_eq_iff_mul_eq {x y : ùìû K} {u : (ùìû K)À£} :\n    u ‚Ä¢ mixedEmbedding K x = mixedEmbedding K y ‚Üî u * x = y := by\n  rw [unitSMul_smul, ‚Üê map_mul, Function.Injective.eq_iff, ‚Üê RingOfIntegers.coe_eq_algebraMap,\n    ‚Üê map_mul, ‚Üê RingOfIntegers.ext_iff]\n  exact mixedEmbedding_injective K\n\n"}
{"name":"NumberField.mixedEmbedding.norm_unit_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (NumberField.mixedEmbedding.norm (HSMul.hSMul u x)) (NumberField.mixedEmbedding.norm x)","decl":"theorem norm_unit_smul (u : (ùìû K)À£) (x : mixedSpace K) :\n    mixedEmbedding.norm (u ‚Ä¢ x) = mixedEmbedding.norm x := by\n  rw [unitSMul_smul, map_mul, norm_unit, one_mul]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w‚ÇÄ\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap x w) (HMul.hMul (‚Üë(‚Üëw).mult) (HSub.hSub (Real.log ((NumberField.mixedEmbedding.normAtPlace ‚Üëw) x)) (HMul.hMul (Real.log (NumberField.mixedEmbedding.norm x)) (Inv.inv ‚Üë(Module.finrank Rat K)))))","decl":"@[simp]\ntheorem logMap_apply (x : mixedSpace K) (w : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :\n    logMap x w = mult w.val * (Real.log (normAtPlace w.val x) -\n      Real.log (mixedEmbedding.norm x) * (finrank ‚Ñö K : ‚Ñù)‚Åª¬π) := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap 0) 0","decl":"@[simp]\ntheorem logMap_zero : logMap (0 : mixedSpace K) = 0 := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_one","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap 1) 0","decl":"@[simp]\ntheorem logMap_one : logMap (1 : mixedSpace K) = 0 := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_mul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nhy : Ne (NumberField.mixedEmbedding.norm y) 0\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap (HMul.hMul x y)) (HAdd.hAdd (NumberField.mixedEmbedding.logMap x) (NumberField.mixedEmbedding.logMap y))","decl":"theorem logMap_mul (hx : mixedEmbedding.norm x ‚â† 0) (hy : mixedEmbedding.norm y ‚â† 0) :\n    logMap (x * y) = logMap x + logMap y := by\n  ext w\n  simp_rw [Pi.add_apply, logMap_apply]\n  rw [map_mul, map_mul, Real.log_mul, Real.log_mul hx hy, add_mul]\n  ¬∑ ring\n  ¬∑ exact mixedEmbedding.norm_ne_zero_iff.mp hx w\n  ¬∑ exact mixedEmbedding.norm_ne_zero_iff.mp hy w\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_apply_of_norm_one","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Eq (NumberField.mixedEmbedding.norm x) 1\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.w‚ÇÄ\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap x w) (HMul.hMul (‚Üë(‚Üëw).mult) (Real.log ((NumberField.mixedEmbedding.normAtPlace ‚Üëw) x)))","decl":"theorem logMap_apply_of_norm_one (hx : mixedEmbedding.norm x = 1)\n    (w : {w : InfinitePlace K // w ‚â† w‚ÇÄ}) :\n    logMap x w = mult w.val * Real.log (normAtPlace w x) := by\n  rw [logMap_apply, hx, Real.log_one, zero_mul, sub_zero]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_eq_logEmbedding","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nu : Units (NumberField.RingOfIntegers K)\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap ((NumberField.mixedEmbedding K) ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üëu))) ((NumberField.Units.logEmbedding K) (Additive.ofMul u))","decl":"@[simp]\ntheorem logMap_eq_logEmbedding (u : (ùìû K)À£) :\n    logMap (mixedEmbedding K u) = logEmbedding K (Additive.ofMul u) := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_unit_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nu : Units (NumberField.RingOfIntegers K)\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul u x)) (HAdd.hAdd ((NumberField.Units.logEmbedding K) (Additive.ofMul u)) (NumberField.mixedEmbedding.logMap x))","decl":"theorem logMap_unit_smul (u : (ùìû K)À£) (hx : mixedEmbedding.norm x ‚â† 0) :\n    logMap (u ‚Ä¢ x) = logEmbedding K (Additive.ofMul u) + logMap x := by\n  rw [unitSMul_smul, logMap_mul (by rw [norm_unit]; norm_num) hx, logMap_eq_logEmbedding]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_torsion_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nŒ∂ : Units (NumberField.RingOfIntegers K)\nhŒ∂ : Membership.mem (NumberField.Units.torsion K) Œ∂\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul Œ∂ x)) (NumberField.mixedEmbedding.logMap x)","decl":"variable (x) in\ntheorem logMap_torsion_smul {Œ∂ : (ùìû K)À£} (hŒ∂ : Œ∂ ‚àà torsion K) :\n    logMap (Œ∂ ‚Ä¢ x) = logMap x := by\n  ext\n  simp_rw [logMap_apply, unitSMul_smul, map_mul, norm_eq_norm, Units.norm, Rat.cast_one, one_mul,\n    normAtPlace_apply, (mem_torsion K).mp hŒ∂, one_mul]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_real","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nc : Real\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul c 1)) 0","decl":"theorem logMap_real (c : ‚Ñù) :\n    logMap (c ‚Ä¢ (1 : mixedSpace K)) = 0 := by\n  ext\n  rw [logMap_apply, normAtPlace_smul, norm_smul, map_one, map_one, mul_one, mul_one, Real.log_pow,\n    mul_comm (finrank ‚Ñö K : ‚Ñù) _, mul_assoc, mul_inv_cancel‚ÇÄ (Nat.cast_ne_zero.mpr finrank_pos.ne'),\n    mul_one, sub_self, mul_zero, Pi.zero_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_real_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nc : Real\nhc : Ne c 0\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul c x)) (NumberField.mixedEmbedding.logMap x)","decl":"theorem logMap_real_smul (hx : mixedEmbedding.norm x ‚â† 0) {c : ‚Ñù} (hc : c ‚â† 0) :\n    logMap (c ‚Ä¢ x) = logMap x := by\n  have : mixedEmbedding.norm (c ‚Ä¢ (1 : mixedSpace K)) ‚â† 0 := by\n    rw [norm_smul, map_one, mul_one]\n    exact pow_ne_zero _ (abs_ne_zero.mpr hc)\n  rw [‚Üê smul_one_mul, logMap_mul this hx, logMap_real, zero_add]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_eq_of_normAtPlace_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nh : ‚àÄ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) x) ((NumberField.mixedEmbedding.normAtPlace w) y)\n‚ä¢ Eq (NumberField.mixedEmbedding.logMap x) (NumberField.mixedEmbedding.logMap y)","decl":"theorem logMap_eq_of_normAtPlace_eq (h : ‚àÄ w, normAtPlace w x = normAtPlace w y) :\n    logMap x = logMap y := by\n  ext\n  simp_rw [logMap_apply, h, norm_eq_of_normAtPlace_eq h]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.norm_pos_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\n‚ä¢ LT.lt 0 (NumberField.mixedEmbedding.norm x)","decl":"theorem norm_pos_of_mem (hx : x ‚àà fundamentalCone K) :\n    0 < mixedEmbedding.norm x :=\n  lt_of_le_of_ne (mixedEmbedding.norm_nonneg _) (Ne.symm hx.2)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nw : NumberField.InfinitePlace K\n‚ä¢ LT.lt 0 ((NumberField.mixedEmbedding.normAtPlace w) x)","decl":"theorem normAtPlace_pos_of_mem (hx : x ‚àà fundamentalCone K) (w : InfinitePlace K) :\n    0 < normAtPlace w x :=\n  lt_of_le_of_ne (normAtPlace_nonneg _ _)\n    (mixedEmbedding.norm_ne_zero_iff.mp (norm_pos_of_mem hx).ne' w).symm\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_of_normAtPlace_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nhy : ‚àÄ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) y) ((NumberField.mixedEmbedding.normAtPlace w) x)\n‚ä¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) y","decl":"theorem mem_of_normAtPlace_eq (hx : x ‚àà fundamentalCone K)\n    (hy : ‚àÄ w, normAtPlace w y = normAtPlace w x) :\n    y ‚àà fundamentalCone K := by\n  refine ‚ü®?_, by simpa [norm_eq_of_normAtPlace_eq hy] using hx.2‚ü©\n  rw [Set.mem_preimage, logMap_eq_of_normAtPlace_eq hy]\n  exact hx.1\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.smul_mem_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nc : Real\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nhc : Ne c 0\n‚ä¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul c x)","decl":"theorem smul_mem_of_mem (hx : x ‚àà fundamentalCone K) (hc : c ‚â† 0) :\n    c ‚Ä¢ x ‚àà fundamentalCone K := by\n  refine ‚ü®?_, ?_‚ü©\n  ¬∑ rw [Set.mem_preimage, logMap_real_smul hx.2 hc]\n    exact hx.1\n  ¬∑ rw [Set.mem_setOf_eq, mixedEmbedding.norm_smul, mul_eq_zero, not_or]\n    exact ‚ü®pow_ne_zero _ (abs_ne_zero.mpr hc), hx.2‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.smul_mem_iff_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nc : Real\nhc : Ne c 0\n‚ä¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul c x)) (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x)","decl":"theorem smul_mem_iff_mem (hc : c ‚â† 0) :\n    c ‚Ä¢ x ‚àà fundamentalCone K ‚Üî x ‚àà fundamentalCone K := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ smul_mem_of_mem h hc‚ü©\n  convert smul_mem_of_mem h (inv_ne_zero hc)\n  rw [eq_inv_smul_iff‚ÇÄ hc]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unit_smul_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\n‚ä¢ Exists fun u => Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul u x)","decl":"theorem exists_unit_smul_mem (hx : mixedEmbedding.norm x ‚â† 0) :\n    ‚àÉ u : (ùìû K)À£, u ‚Ä¢ x ‚àà fundamentalCone K := by\n  classical\n  let B := (basisUnitLattice K).ofZLatticeBasis ‚Ñù\n  rsuffices ‚ü®‚ü®_, ‚ü®u, _, rfl‚ü©‚ü©, hu‚ü© : ‚àÉ e : unitLattice K, e + logMap x ‚àà ZSpan.fundamentalDomain B\n  ¬∑ exact ‚ü®u, by rwa [Set.mem_preimage, logMap_unit_smul u hx], by simp [hx]‚ü©\n  ¬∑ obtain ‚ü®‚ü®e, h‚ÇÅ‚ü©, h‚ÇÇ, -‚ü© := ZSpan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)\n    exact ‚ü®‚ü®e, by rwa [‚Üê Basis.ofZLatticeBasis_span ‚Ñù (unitLattice K)]‚ü©, h‚ÇÇ‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.torsion_smul_mem_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nŒ∂ : Units (NumberField.RingOfIntegers K)\nhŒ∂ : Membership.mem (NumberField.Units.torsion K) Œ∂\n‚ä¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul Œ∂ x)","decl":"theorem torsion_smul_mem_of_mem (hx : x ‚àà fundamentalCone K) {Œ∂ : (ùìû K)À£} (hŒ∂ : Œ∂ ‚àà torsion K) :\n    Œ∂ ‚Ä¢ x ‚àà fundamentalCone K := by\n  constructor\n  ¬∑ rw [Set.mem_preimage, logMap_torsion_smul _ hŒ∂]\n    exact hx.1\n  ¬∑ rw [Set.mem_setOf_eq, unitSMul_smul, map_mul, norm_unit, one_mul]\n    exact hx.2\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.unit_smul_mem_iff_mem_torsion","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nu : Units (NumberField.RingOfIntegers K)\n‚ä¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul u x)) (Membership.mem (NumberField.Units.torsion K) u)","decl":"theorem unit_smul_mem_iff_mem_torsion (hx : x ‚àà fundamentalCone K) (u : (ùìû K)À£) :\n    u ‚Ä¢ x ‚àà fundamentalCone K ‚Üî u ‚àà torsion K := by\n  classical\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ torsion_smul_mem_of_mem hx h‚ü©\n  rw [‚Üê logEmbedding_eq_zero_iff]\n  let B := (basisUnitLattice K).ofZLatticeBasis ‚Ñù\n  refine (Subtype.mk_eq_mk (h := ?_) (h' := Submodule.zero_mem _)).mp <|\n    (ZSpan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)).unique ?_ ?_\n  ¬∑ rw [Basis.ofZLatticeBasis_span ‚Ñù (unitLattice K)]\n    exact ‚ü®u, trivial, rfl‚ü©\n  ¬∑ rw [AddSubmonoid.mk_vadd, vadd_eq_add, ‚Üê logMap_unit_smul _ hx.2]\n    exact h.1\n  ¬∑ rw [AddSubmonoid.mk_vadd, vadd_eq_add, zero_add]\n    exact hx.1\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a) (And (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) a) (Exists fun x => Eq ((NumberField.mixedEmbedding K) ‚Üëx) a))","decl":"theorem mem_integerSet {a : mixedSpace K} :\n    a ‚àà integerSet K ‚Üî a ‚àà fundamentalCone K ‚àß ‚àÉ x : ùìû K, mixedEmbedding K x = a := by\n  simp only [integerSet, Set.mem_inter_iff, SetLike.mem_coe, LinearMap.mem_range,\n    AlgHom.toLinearMap_apply, RingHom.toIntAlgHom_coe, RingHom.coe_comp, Function.comp_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.existsUnique_preimage_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\nha : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a\n‚ä¢ ExistsUnique fun x => Eq ((NumberField.mixedEmbedding K) ‚Üëx) a","decl":"/-- If `a` is in `integerSet`, then there is a *unique* algebraic integer in `ùìû K` such\nthat `mixedEmbedding K x = a`. -/\ntheorem existsUnique_preimage_of_mem_integerSet {a : mixedSpace K} (ha : a ‚àà integerSet K) :\n    ‚àÉ! x : ùìû K, mixedEmbedding K x = a := by\n  obtain ‚ü®_, ‚ü®x, rfl‚ü©‚ü© := mem_integerSet.mp ha\n  refine Function.Injective.existsUnique_of_mem_range ?_ (Set.mem_range_self x)\n  exact (mixedEmbedding_injective K).comp RingOfIntegers.coe_injective\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unique_preimage_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\nha : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a\n‚ä¢ ExistsUnique fun x => Eq ((NumberField.mixedEmbedding K) ‚Üëx) a","decl":"@[deprecated (since := \"2024-12-17\")]\nalias exists_unique_preimage_of_mem_integerSet := existsUnique_preimage_of_mem_integerSet\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.ne_zero_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Ne (‚Üëa) 0","decl":"theorem ne_zero_of_mem_integerSet (a : integerSet K) : (a : mixedSpace K) ‚â† 0 := by\n  by_contra!\n  exact a.prop.1.2 (this.symm ‚ñ∏ mixedEmbedding.norm.map_zero')\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mixedEmbedding_preimageOfMemIntegerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq ((NumberField.mixedEmbedding K) ‚Üë‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)) ‚Üëa","decl":"@[simp]\ntheorem mixedEmbedding_preimageOfMemIntegerSet (a : integerSet K) :\n    mixedEmbedding K (preimageOfMemIntegerSet a : ùìû K) = (a : mixedSpace K) := by\n  rw [preimageOfMemIntegerSet, (mem_integerSet.mp a.prop).2.choose_spec]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet_mixedEmbedding","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.RingOfIntegers K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) ((NumberField.mixedEmbedding K) ‚Üëx)\n‚ä¢ Eq (‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet ‚ü®(NumberField.mixedEmbedding K) ‚Üëx, hx‚ü©)) x","decl":"theorem preimageOfMemIntegerSet_mixedEmbedding {x : (ùìû K)}\n    (hx : mixedEmbedding K (x : ùìû K) ‚àà integerSet K) :\n    preimageOfMemIntegerSet (‚ü®mixedEmbedding K (x : ùìû K), hx‚ü©) = x := by\n  simp_rw [RingOfIntegers.ext_iff, ‚Üê (mixedEmbedding_injective K).eq_iff,\n    mixedEmbedding_preimageOfMemIntegerSet]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unitSMul_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne x 0\nhx' : Membership.mem (Set.image (‚áë(NumberField.mixedEmbedding K)) (Set.range ‚áë(algebraMap (NumberField.RingOfIntegers K) K))) x\n‚ä¢ Exists fun u => Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) (HSMul.hSMul u x)","decl":"/-- If `x : mixedSpace K` is nonzero and the image of an algebraic integer, then there exists a\nunit such that `u ‚Ä¢ x ‚àà integerSet K`. -/\ntheorem exists_unitSMul_mem_integerSet {x : mixedSpace K} (hx : x ‚â† 0)\n    (hx' : x ‚àà mixedEmbedding K '' (Set.range (algebraMap (ùìû K) K))) :\n    ‚àÉ u : (ùìû K)À£, u ‚Ä¢ x ‚àà integerSet K := by\n  replace hx : mixedEmbedding.norm x ‚â† 0 :=\n      (norm_eq_zero_iff' (Set.mem_range_of_mem_image (mixedEmbedding K) _ hx')).not.mpr hx\n  obtain ‚ü®u, hu‚ü© := exists_unit_smul_mem hx\n  obtain ‚ü®_, ‚ü®x, rfl‚ü©, _, rfl‚ü© := hx'\n  exact ‚ü®u, mem_integerSet.mpr ‚ü®hu, u * x, by simp_rw [unitSMul_smul, ‚Üê map_mul]‚ü©‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.torsion_unitSMul_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nŒ∂ : Units (NumberField.RingOfIntegers K)\nhŒ∂ : Membership.mem (NumberField.Units.torsion K) Œ∂\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) x\n‚ä¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) (HSMul.hSMul Œ∂ x)","decl":"/-- The set `integerSet K` is stable under the action of the torsion. -/\ntheorem torsion_unitSMul_mem_integerSet {x : mixedSpace K} {Œ∂ : (ùìû K)À£} (hŒ∂ : Œ∂ ‚àà torsion K)\n    (hx : x ‚àà integerSet K) : Œ∂ ‚Ä¢ x ‚àà integerSet K := by\n  obtain ‚ü®a, ‚ü®_, rfl‚ü©, rfl‚ü© := (mem_integerSet.mp hx).2\n  refine mem_integerSet.mpr ‚ü®torsion_smul_mem_of_mem hx.1 hŒ∂, ‚ü®Œ∂ * a, by simp‚ü©‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetTorsionSMul_smul_coe","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx‚úù¬π : Subtype fun x => Membership.mem (NumberField.Units.torsion K) x\nx‚úù : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (‚Üë(HSMul.hSMul x‚úù¬π x‚úù)) (HSMul.hSMul ‚Üëx‚úù¬π ‚Üëx‚úù)","decl":"/-- The action of `torsion K` on `integerSet K`. -/\n@[simps]\ninstance integerSetTorsionSMul: SMul (torsion K) (integerSet K) where\n  smul := fun ‚ü®Œ∂, hŒ∂‚ü© ‚ü®x, hx‚ü© ‚Ü¶ ‚ü®Œ∂ ‚Ä¢ x, torsion_unitSMul_mem_integerSet hŒ∂ hx‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.intNorm_coe","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (‚Üë(NumberField.mixedEmbedding.fundamentalCone.intNorm a)) (NumberField.mixedEmbedding.norm ‚Üëa)","decl":"@[simp]\ntheorem intNorm_coe (a : integerSet K) :\n    (intNorm a : ‚Ñù) = mixedEmbedding.norm (a : mixedSpace K) := by\n  rw [intNorm, Int.cast_natAbs, ‚Üê Rat.cast_intCast, Int.cast_abs, Algebra.coe_norm_int,\n    ‚Üê norm_eq_norm, mixedEmbedding_preimageOfMemIntegerSet]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.quotIntNorm_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (NumberField.mixedEmbedding.fundamentalCone.quotIntNorm (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)) a)) (NumberField.mixedEmbedding.fundamentalCone.intNorm a)","decl":"@[simp]\ntheorem quotIntNorm_apply (a : integerSet K) : quotIntNorm ‚ü¶a‚üß = intNorm a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K a) (Quotient.mk (Associated.setoid (Subtype fun x => Membership.mem (nonZeroDivisors (NumberField.RingOfIntegers K)) x)) (NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a))","decl":"@[simp]\ntheorem integerSetToAssociates_apply (a : integerSet K) :\n    integerSetToAssociates K a = ‚ü¶preimageOfMemIntegerSet a‚üß := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_surjective","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Function.Surjective (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K)","decl":"variable (K) in\ntheorem integerSetToAssociates_surjective :\n    Function.Surjective (integerSetToAssociates K) := by\n  rintro ‚ü®x‚ü©\n  obtain ‚ü®u, hu‚ü© : ‚àÉ u : (ùìû K)À£, u ‚Ä¢ mixedEmbedding K (x : ùìû K) ‚àà integerSet K := by\n    refine exists_unitSMul_mem_integerSet ?_ ‚ü®(x : ùìû K), Set.mem_range_self _, rfl‚ü©\n    exact (map_ne_zero _).mpr <| RingOfIntegers.coe_ne_zero_iff.mpr (nonZeroDivisors.coe_ne_zero _)\n  refine ‚ü®‚ü®u ‚Ä¢ mixedEmbedding K (x : ùìû K), hu‚ü©,\n    Quotient.sound ‚ü®unitsNonZeroDivisorsEquiv.symm u‚Åª¬π, ?_‚ü©‚ü©\n  simp_rw [Subtype.ext_iff, RingOfIntegers.ext_iff, ‚Üê (mixedEmbedding_injective K).eq_iff,\n    Submonoid.coe_mul, map_mul, mixedEmbedding_preimageOfMemIntegerSet,\n    unitSMul_smul, ‚Üê map_mul, mul_comm, map_inv, val_inv_unitsNonZeroDivisorsEquiv_symm_apply_coe,\n    Units.mul_inv_cancel_right]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_eq_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na b : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Iff (Eq (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K a) (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K b)) (Exists fun Œ∂ => Eq (HSMul.hSMul Œ∂ a) b)","decl":"theorem integerSetToAssociates_eq_iff (a b : integerSet K) :\n    integerSetToAssociates K a = integerSetToAssociates K b ‚Üî\n      ‚àÉ Œ∂ : torsion K, Œ∂ ‚Ä¢ a = b := by\n  simp_rw [integerSetToAssociates_apply, Associates.quotient_mk_eq_mk,\n    Associates.mk_eq_mk_iff_associated, Associated, mul_comm, Subtype.ext_iff,\n    RingOfIntegers.ext_iff, ‚Üê (mixedEmbedding_injective K).eq_iff, Submonoid.coe_mul, map_mul,\n    mixedEmbedding_preimageOfMemIntegerSet, integerSetTorsionSMul_smul_coe]\n  refine ‚ü®fun ‚ü®u, h‚ü© ‚Ü¶  ‚ü®‚ü®unitsNonZeroDivisorsEquiv u, ?_‚ü©, by simpa using h‚ü©,\n    fun ‚ü®‚ü®u, _‚ü©, h‚ü© ‚Ü¶ ‚ü®unitsNonZeroDivisorsEquiv.symm u, by simpa using h‚ü©‚ü©\n  exact (unit_smul_mem_iff_mem_torsion a.prop.1 _).mp (by simpa [h] using b.prop.1)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetQuotEquivAssociates_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq ((NumberField.mixedEmbedding.fundamentalCone.integerSetQuotEquivAssociates K) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)) a)) (Quotient.mk (Associated.setoid (Subtype fun x => Membership.mem (nonZeroDivisors (NumberField.RingOfIntegers K)) x)) (NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a))","decl":"@[simp]\ntheorem integerSetQuotEquivAssociates_apply (a : integerSet K) :\n    integerSetQuotEquivAssociates K ‚ü¶a‚üß = ‚ü¶preimageOfMemIntegerSet a‚üß := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetTorsionSMul_stabilizer","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (MulAction.stabilizer (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) a) Bot.bot","decl":"theorem integerSetTorsionSMul_stabilizer (a : integerSet K) :\n    MulAction.stabilizer (torsion K) a = ‚ä• := by\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun Œ∂ hŒ∂ ‚Ü¶ ?_\n  rwa [MulAction.mem_stabilizer_iff, Subtype.ext_iff, integerSetTorsionSMul_smul_coe,\n    unitSMul_smul, ‚Üê mixedEmbedding_preimageOfMemIntegerSet, ‚Üê map_mul,\n    (mixedEmbedding_injective K).eq_iff, ‚Üê map_mul, ‚Üê RingOfIntegers.ext_iff, mul_eq_right‚ÇÄ,\n    Units.val_eq_one, OneMemClass.coe_eq_one] at hŒ∂\n  exact nonZeroDivisors.coe_ne_zero _\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetEquiv_apply_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\n‚ä¢ Eq (‚Üë‚Üë((NumberField.mixedEmbedding.fundamentalCone.integerSetEquiv K) a).1) (Ideal.span (Singleton.singleton ‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)))","decl":"@[simp]\ntheorem integerSetEquiv_apply_fst (a : integerSet K) :\n    ((integerSetEquiv K a).1 : Ideal (ùìû K)) = span {(preimageOfMemIntegerSet a : ùìû K)} := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetEquivNorm_apply_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nn : Nat\na : Subtype fun a => Eq (NumberField.mixedEmbedding.norm ‚Üëa) ‚Üën\n‚ä¢ Eq (‚Üë‚Üë((NumberField.mixedEmbedding.fundamentalCone.integerSetEquivNorm K n) a).1) (Ideal.span (Singleton.singleton ‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet ‚Üëa)))","decl":"@[simp]\ntheorem integerSetEquivNorm_apply_fst {n : ‚Ñï}\n    (a : {a : integerSet K // mixedEmbedding.norm (a : mixedSpace K) = n}) :\n    ((integerSetEquivNorm K n a).1 : Ideal (ùìû K)) =\n      span {(preimageOfMemIntegerSet a.val : ùìû K)} := by\n simp_rw [integerSetEquivNorm, Equiv.prodSubtypeFstEquivSubtypeProd, Equiv.instTrans_trans,\n   Equiv.prodCongrLeft, Equiv.trans_apply, Equiv.subtypeEquiv_apply, Equiv.coe_fn_mk,\n   Equiv.subtypeSubtypeEquivSubtypeInter_apply_coe, integerSetEquiv_apply_fst]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.card_isPrincipal_norm_eq_mul_torsion","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nn : Nat\n‚ä¢ Eq (HMul.hMul (Nat.card ‚Üë(setOf fun I => And (Submodule.IsPrincipal ‚ÜëI) (Eq (Ideal.absNorm ‚ÜëI) n))) ‚Üë(NumberField.Units.torsionOrder K)) (Nat.card ‚Üë(setOf fun a => Eq (NumberField.mixedEmbedding.norm ‚Üëa) ‚Üën))","decl":"/-- For `n` positive, the number of principal ideals in `ùìû K` of norm `n` multiplied by the order\nof the torsion of `K` is equal to the number of elements in `integerSet K` of norm `n`. -/\ntheorem card_isPrincipal_norm_eq_mul_torsion (n : ‚Ñï) :\n    Nat.card {I : (Ideal (ùìû K))‚Å∞ | IsPrincipal (I : Ideal (ùìû K)) ‚àß\n      absNorm (I : Ideal (ùìû K)) = n} * torsionOrder K =\n        Nat.card {a : integerSet K | mixedEmbedding.norm (a : mixedSpace K) = n} := by\n  rw [torsionOrder, PNat.mk_coe, ‚Üê Nat.card_eq_fintype_card, ‚Üê Nat.card_prod]\n  exact Nat.card_congr (integerSetEquivNorm K n).symm\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_idealSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\n‚ä¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone.idealSet K J) x) (And (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x) (Exists fun a => And (Membership.mem (‚Üë‚ÜëJ) a) (Eq ((NumberField.mixedEmbedding K) ‚Üëa) x)))","decl":"variable {K J} in\ntheorem mem_idealSet :\n    x ‚àà idealSet K J ‚Üî x ‚àà fundamentalCone K ‚àß ‚àÉ a : (ùìû K), (a : ùìû K) ‚àà (J : Set (ùìû K)) ‚àß\n      mixedEmbedding K (a : ùìû K) = x := by\n  simp_rw [idealSet, Set.mem_inter_iff, idealLattice, SetLike.mem_coe, FractionalIdeal.coe_mk0,\n    LinearMap.mem_range, LinearMap.coe_comp, LinearMap.coe_restrictScalars, coe_subtype,\n    Function.comp_apply, AlgHom.toLinearMap_apply, RingHom.toIntAlgHom_coe, Subtype.exists,\n    FractionalIdeal.mem_coe, FractionalIdeal.mem_coeIdeal, exists_prop', nonempty_prop,\n    exists_exists_and_eq_and]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetMap_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\n‚ä¢ Eq ‚Üë(NumberField.mixedEmbedding.fundamentalCone.idealSetMap K J a) ‚Üëa","decl":"@[simp]\ntheorem idealSetMap_apply (a : idealSet K J) : (idealSetMap K J a : mixedSpace K) = a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.preimage_of_IdealSetMap","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\n‚ä¢ Membership.mem ‚Üë‚ÜëJ ‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet (NumberField.mixedEmbedding.fundamentalCone.idealSetMap K J a))","decl":"theorem preimage_of_IdealSetMap (a : idealSet K J) :\n    (preimageOfMemIntegerSet (idealSetMap K J a) : ùìû K) ‚àà (J : Set (ùìû K)) := by\n  obtain ‚ü®_, ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü©‚ü© := mem_idealSet.mp a.prop\n  simp_rw [idealSetMap, ‚Üê hx‚ÇÇ, preimageOfMemIntegerSet_mixedEmbedding]\n  exact hx‚ÇÅ\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\n‚ä¢ Eq ‚Üë‚Üë((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J) a) ‚Üëa","decl":"theorem idealSetEquiv_apply (a : idealSet K J) :\n    (idealSetEquiv K J a : mixedSpace K) = a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv_symm_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : Subtype fun a => Membership.mem ‚Üë‚ÜëJ ‚Üë(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)\n‚ä¢ Eq ‚Üë((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J).symm a) ‚Üë‚Üëa","decl":"theorem idealSetEquiv_symm_apply\n    (a : {a : integerSet K // (preimageOfMemIntegerSet a : ùìû K) ‚àà (J : Set (ùìû K)) }) :\n    ((idealSetEquiv K J).symm a : mixedSpace K) = a := by\n  rw [‚Üê (idealSetEquiv_apply ((idealSetEquiv K J).symm a)), Equiv.apply_symm_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.intNorm_idealSetEquiv_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : ‚Üë(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\n‚ä¢ Eq (‚Üë(NumberField.mixedEmbedding.fundamentalCone.intNorm ‚Üë((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J) a))) (NumberField.mixedEmbedding.norm ‚Üëa)","decl":"theorem intNorm_idealSetEquiv_apply (a : idealSet K J) :\n    intNorm (idealSetEquiv K J a).val = mixedEmbedding.norm (a : mixedSpace K) := by\n  rw [intNorm_coe, idealSetEquiv_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.card_isPrincipal_dvd_norm_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\ns : Real\n‚ä¢ Eq (HMul.hMul (Nat.card (Subtype fun I => And (Dvd.dvd ‚ÜëJ ‚ÜëI) (And (Submodule.IsPrincipal ‚ÜëI) (LE.le (‚Üë(Ideal.absNorm ‚ÜëI)) s)))) ‚Üë(NumberField.Units.torsionOrder K)) (Nat.card (Subtype fun a => LE.le (NumberField.mixedEmbedding.norm ‚Üëa) s))","decl":"/-- For `s : ‚Ñù`, the number of principal nonzero ideals in `ùìû K` divisible par `J` of norm `‚â§ s`\nmultiplied by the order of the torsion of `K` is equal to the number of elements in `idealSet K J`\nof norm `‚â§ s`. -/\ntheorem card_isPrincipal_dvd_norm_le (s : ‚Ñù) :\n    Nat.card {I : (Ideal (ùìû K))‚Å∞ // (J : Ideal (ùìû K)) ‚à£ I ‚àß IsPrincipal (I : Ideal (ùìû K)) ‚àß\n      absNorm (I : Ideal (ùìû K)) ‚â§ s} * torsionOrder K =\n        Nat.card {a : idealSet K J // mixedEmbedding.norm (a : mixedSpace K) ‚â§ s} := by\n  obtain hs | hs := le_or_gt 0 s\n  ¬∑ simp_rw [‚Üê intNorm_idealSetEquiv_apply, ‚Üê Nat.le_floor_iff hs]\n    rw [torsionOrder, PNat.mk_coe, ‚Üê Nat.card_eq_fintype_card, ‚Üê Nat.card_prod]\n    refine Nat.card_congr <| @Equiv.ofFiberEquiv _ (Œ≥ := Finset.Iic ‚åäs‚åã‚Çä) _\n      (fun I ‚Ü¶ ‚ü®absNorm I.1.val.1, Finset.mem_Iic.mpr I.1.prop.2.2‚ü©)\n      (fun a ‚Ü¶ ‚ü®intNorm (idealSetEquiv K J a.1).1, Finset.mem_Iic.mpr a.prop‚ü©) fun ‚ü®i, hi‚ü© ‚Ü¶ ?_\n    simp_rw [Subtype.mk.injEq]\n    calc _ ‚âÉ {I : {I : (Ideal (ùìû K))‚Å∞ // _ ‚àß _ ‚àß _} // absNorm I.1.1 = i} √ó torsion K :=\n        Equiv.prodSubtypeFstEquivSubtypeProd\n      _    ‚âÉ {I : (Ideal (ùìû K))‚Å∞ // (_ ‚àß _ ‚àß absNorm I.1 ‚â§ ‚åäs‚åã‚Çä) ‚àß absNorm I.1 = i}\n            √ó torsion K := Equiv.prodCongrLeft fun _ ‚Ü¶ (Equiv.subtypeSubtypeEquivSubtypeInter\n        (p := fun I : (Ideal (ùìû K))‚Å∞ ‚Ü¶ J.1 ‚à£ I.1 ‚àß IsPrincipal I.1 ‚àß absNorm I.1 ‚â§ ‚åäs‚åã‚Çä)\n        (q := fun I ‚Ü¶ absNorm I.1 = i))\n      _   ‚âÉ {I : (Ideal (ùìû K))‚Å∞ // J.1 ‚à£ I.1 ‚àß IsPrincipal I.1 ‚àß absNorm I.1 = i}\n            √ó torsion K := Equiv.prodCongrLeft fun _ ‚Ü¶ Equiv.subtypeEquivRight fun _ ‚Ü¶ by aesop\n      _   ‚âÉ {a : idealSet K J // mixedEmbedding.norm (a : mixedSpace K) = i} :=\n            (idealSetEquivNorm K J i).symm\n      _   ‚âÉ {a : idealSet K J // intNorm (idealSetEquiv K J a).1 = i} := by\n        simp_rw [‚Üê intNorm_idealSetEquiv_apply, Nat.cast_inj]\n        rfl\n      _   ‚âÉ {b : {a : idealSet K J // intNorm (idealSetEquiv K J a).1 ‚â§ ‚åäs‚åã‚Çä} //\n            intNorm (idealSetEquiv K J b).1 = i} :=\n        (Equiv.subtypeSubtypeEquivSubtype fun h ‚Ü¶ Finset.mem_Iic.mp (h ‚ñ∏ hi)).symm\n  ¬∑ simp_rw [lt_iff_not_le.mp (lt_of_lt_of_le hs (Nat.cast_nonneg _)), lt_iff_not_le.mp\n      (lt_of_lt_of_le hs (mixedEmbedding.norm_nonneg _)), and_false, Nat.card_of_isEmpty,\n      zero_mul]\n\n"}
