{"name":"NumberField.mixedEmbedding.unitSMul_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœ : Field K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\nâŠ¢ Eq (HSMul.hSMul u x) (HMul.hMul ((NumberField.mixedEmbedding K) ((algebraMap (NumberField.RingOfIntegers K) K) â†‘u)) x)","decl":"/-- The action of `(ğ“ K)Ë£` on the mixed space `â„^râ‚ Ã— â„‚^râ‚‚` defined, for `u : (ğ“ K)Ë£`, by\nmultiplication component by component with `mixedEmbedding K u`. -/\n@[simps]\ninstance unitSMul : SMul (ğ“ K)Ë£ (mixedSpace K) where\n  smul u x := mixedEmbedding K u * x\n\n"}
{"name":"NumberField.mixedEmbedding.unit_smul_eq_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœ : Field K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\nâŠ¢ Iff (Eq (HSMul.hSMul u x) 0) (Eq x 0)","decl":"theorem unit_smul_eq_zero (u : (ğ“ K)Ë£) (x : mixedSpace K) :\n    u â€¢ x = 0 â†” x = 0 := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ by rw [h, smul_zero]âŸ©\n  contrapose! h\n  obtain âŸ¨w, hâŸ© := exists_normAtPlace_ne_zero_iff.mpr h\n  refine exists_normAtPlace_ne_zero_iff.mp âŸ¨w, ?_âŸ©\n  rw [unitSMul_smul, map_mul]\n  exact mul_ne_zero (by simp) h\n\n"}
{"name":"NumberField.mixedEmbedding.unit_smul_eq_iff_mul_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx y : NumberField.RingOfIntegers K\nu : Units (NumberField.RingOfIntegers K)\nâŠ¢ Iff (Eq (HSMul.hSMul u ((NumberField.mixedEmbedding K) â†‘x)) ((NumberField.mixedEmbedding K) â†‘y)) (Eq (HMul.hMul (â†‘u) x) y)","decl":"theorem unit_smul_eq_iff_mul_eq {x y : ğ“ K} {u : (ğ“ K)Ë£} :\n    u â€¢ mixedEmbedding K x = mixedEmbedding K y â†” u * x = y := by\n  rw [unitSMul_smul, â† map_mul, Function.Injective.eq_iff, â† RingOfIntegers.coe_eq_algebraMap,\n    â† map_mul, â† RingOfIntegers.ext_iff]\n  exact mixedEmbedding_injective K\n\n"}
{"name":"NumberField.mixedEmbedding.norm_unit_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nu : Units (NumberField.RingOfIntegers K)\nx : NumberField.mixedEmbedding.mixedSpace K\nâŠ¢ Eq (NumberField.mixedEmbedding.norm (HSMul.hSMul u x)) (NumberField.mixedEmbedding.norm x)","decl":"theorem norm_unit_smul (u : (ğ“ K)Ë£) (x : mixedSpace K) :\n    mixedEmbedding.norm (u â€¢ x) = mixedEmbedding.norm x := by\n  rw [unitSMul_smul, map_mul, norm_unit, one_mul]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.wâ‚€\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap x w) (HMul.hMul (â†‘(â†‘w).mult) (HSub.hSub (Real.log ((NumberField.mixedEmbedding.normAtPlace â†‘w) x)) (HMul.hMul (Real.log (NumberField.mixedEmbedding.norm x)) (Inv.inv â†‘(Module.finrank Rat K)))))","decl":"@[simp]\ntheorem logMap_apply (x : mixedSpace K) (w : {w : InfinitePlace K // w â‰  wâ‚€}) :\n    logMap x w = mult w.val * (Real.log (normAtPlace w.val x) -\n      Real.log (mixedEmbedding.norm x) * (finrank â„š K : â„)â»Â¹) := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap 0) 0","decl":"@[simp]\ntheorem logMap_zero : logMap (0 : mixedSpace K) = 0 := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_one","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap 1) 0","decl":"@[simp]\ntheorem logMap_one : logMap (1 : mixedSpace K) = 0 := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_mul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nhy : Ne (NumberField.mixedEmbedding.norm y) 0\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap (HMul.hMul x y)) (HAdd.hAdd (NumberField.mixedEmbedding.logMap x) (NumberField.mixedEmbedding.logMap y))","decl":"theorem logMap_mul (hx : mixedEmbedding.norm x â‰  0) (hy : mixedEmbedding.norm y â‰  0) :\n    logMap (x * y) = logMap x + logMap y := by\n  ext w\n  simp_rw [Pi.add_apply, logMap_apply]\n  rw [map_mul, map_mul, Real.log_mul, Real.log_mul hx hy, add_mul]\n  Â· ring\n  Â· exact mixedEmbedding.norm_ne_zero_iff.mp hx w\n  Â· exact mixedEmbedding.norm_ne_zero_iff.mp hy w\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_apply_of_norm_one","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Eq (NumberField.mixedEmbedding.norm x) 1\nw : Subtype fun w => Ne w NumberField.Units.dirichletUnitTheorem.wâ‚€\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap x w) (HMul.hMul (â†‘(â†‘w).mult) (Real.log ((NumberField.mixedEmbedding.normAtPlace â†‘w) x)))","decl":"theorem logMap_apply_of_norm_one (hx : mixedEmbedding.norm x = 1)\n    (w : {w : InfinitePlace K // w â‰  wâ‚€}) :\n    logMap x w = mult w.val * Real.log (normAtPlace w x) := by\n  rw [logMap_apply, hx, Real.log_one, zero_mul, sub_zero]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_eq_logEmbedding","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nu : Units (NumberField.RingOfIntegers K)\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap ((NumberField.mixedEmbedding K) ((algebraMap (NumberField.RingOfIntegers K) K) â†‘u))) ((NumberField.Units.logEmbedding K) (Additive.ofMul u))","decl":"@[simp]\ntheorem logMap_eq_logEmbedding (u : (ğ“ K)Ë£) :\n    logMap (mixedEmbedding K u) = logEmbedding K (Additive.ofMul u) := by\n  ext; simp\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_unit_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nu : Units (NumberField.RingOfIntegers K)\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul u x)) (HAdd.hAdd ((NumberField.Units.logEmbedding K) (Additive.ofMul u)) (NumberField.mixedEmbedding.logMap x))","decl":"theorem logMap_unit_smul (u : (ğ“ K)Ë£) (hx : mixedEmbedding.norm x â‰  0) :\n    logMap (u â€¢ x) = logEmbedding K (Additive.ofMul u) + logMap x := by\n  rw [unitSMul_smul, logMap_mul (by rw [norm_unit]; norm_num) hx, logMap_eq_logEmbedding]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_torsion_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nÎ¶ : Units (NumberField.RingOfIntegers K)\nhÎ¶ : Membership.mem (NumberField.Units.torsion K) Î¶\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul Î¶ x)) (NumberField.mixedEmbedding.logMap x)","decl":"variable (x) in\ntheorem logMap_torsion_smul {Î¶ : (ğ“ K)Ë£} (hÎ¶ : Î¶ âˆˆ torsion K) :\n    logMap (Î¶ â€¢ x) = logMap x := by\n  ext\n  simp_rw [logMap_apply, unitSMul_smul, map_mul, norm_eq_norm, Units.norm, Rat.cast_one, one_mul,\n    normAtPlace_apply, (mem_torsion K).mp hÎ¶, one_mul]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_real","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nc : Real\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul c 1)) 0","decl":"theorem logMap_real (c : â„) :\n    logMap (c â€¢ (1 : mixedSpace K)) = 0 := by\n  ext\n  rw [logMap_apply, normAtPlace_smul, norm_smul, map_one, map_one, mul_one, mul_one, Real.log_pow,\n    mul_comm (finrank â„š K : â„) _, mul_assoc, mul_inv_cancelâ‚€ (Nat.cast_ne_zero.mpr finrank_pos.ne'),\n    mul_one, sub_self, mul_zero, Pi.zero_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_real_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nc : Real\nhc : Ne c 0\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap (HSMul.hSMul c x)) (NumberField.mixedEmbedding.logMap x)","decl":"theorem logMap_real_smul (hx : mixedEmbedding.norm x â‰  0) {c : â„} (hc : c â‰  0) :\n    logMap (c â€¢ x) = logMap x := by\n  have : mixedEmbedding.norm (c â€¢ (1 : mixedSpace K)) â‰  0 := by\n    rw [norm_smul, map_one, mul_one]\n    exact pow_ne_zero _ (abs_ne_zero.mpr hc)\n  rw [â† smul_one_mul, logMap_mul this hx, logMap_real, zero_add]\n\n"}
{"name":"NumberField.mixedEmbedding.logMap_eq_of_normAtPlace_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nh : âˆ€ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) x) ((NumberField.mixedEmbedding.normAtPlace w) y)\nâŠ¢ Eq (NumberField.mixedEmbedding.logMap x) (NumberField.mixedEmbedding.logMap y)","decl":"theorem logMap_eq_of_normAtPlace_eq (h : âˆ€ w, normAtPlace w x = normAtPlace w y) :\n    logMap x = logMap y := by\n  ext\n  simp_rw [logMap_apply, h, norm_eq_of_normAtPlace_eq h]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.norm_pos_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nâŠ¢ LT.lt 0 (NumberField.mixedEmbedding.norm x)","decl":"theorem norm_pos_of_mem (hx : x âˆˆ fundamentalCone K) :\n    0 < mixedEmbedding.norm x :=\n  lt_of_le_of_ne (mixedEmbedding.norm_nonneg _) (Ne.symm hx.2)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.normAtPlace_pos_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nw : NumberField.InfinitePlace K\nâŠ¢ LT.lt 0 ((NumberField.mixedEmbedding.normAtPlace w) x)","decl":"theorem normAtPlace_pos_of_mem (hx : x âˆˆ fundamentalCone K) (w : InfinitePlace K) :\n    0 < normAtPlace w x :=\n  lt_of_le_of_ne (normAtPlace_nonneg _ _)\n    (mixedEmbedding.norm_ne_zero_iff.mp (norm_pos_of_mem hx).ne' w).symm\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_of_normAtPlace_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nhy : âˆ€ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) y) ((NumberField.mixedEmbedding.normAtPlace w) x)\nâŠ¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) y","decl":"theorem mem_of_normAtPlace_eq (hx : x âˆˆ fundamentalCone K)\n    (hy : âˆ€ w, normAtPlace w y = normAtPlace w x) :\n    y âˆˆ fundamentalCone K := by\n  refine âŸ¨?_, by simpa [norm_eq_of_normAtPlace_eq hy] using hx.2âŸ©\n  rw [Set.mem_preimage, logMap_eq_of_normAtPlace_eq hy]\n  exact hx.1\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.smul_mem_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nc : Real\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nhc : Ne c 0\nâŠ¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul c x)","decl":"theorem smul_mem_of_mem (hx : x âˆˆ fundamentalCone K) (hc : c â‰  0) :\n    c â€¢ x âˆˆ fundamentalCone K := by\n  refine âŸ¨?_, ?_âŸ©\n  Â· rw [Set.mem_preimage, logMap_real_smul hx.2 hc]\n    exact hx.1\n  Â· rw [Set.mem_setOf_eq, mixedEmbedding.norm_smul, mul_eq_zero, not_or]\n    exact âŸ¨pow_ne_zero _ (abs_ne_zero.mpr hc), hx.2âŸ©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.smul_mem_iff_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nc : Real\nhc : Ne c 0\nâŠ¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul c x)) (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x)","decl":"theorem smul_mem_iff_mem (hc : c â‰  0) :\n    c â€¢ x âˆˆ fundamentalCone K â†” x âˆˆ fundamentalCone K := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ smul_mem_of_mem h hcâŸ©\n  convert smul_mem_of_mem h (inv_ne_zero hc)\n  rw [eq_inv_smul_iffâ‚€ hc]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unit_smul_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne (NumberField.mixedEmbedding.norm x) 0\nâŠ¢ Exists fun u => Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul u x)","decl":"theorem exists_unit_smul_mem (hx : mixedEmbedding.norm x â‰  0) :\n    âˆƒ u : (ğ“ K)Ë£, u â€¢ x âˆˆ fundamentalCone K := by\n  classical\n  let B := (basisUnitLattice K).ofZLatticeBasis â„\n  rsuffices âŸ¨âŸ¨_, âŸ¨u, _, rflâŸ©âŸ©, huâŸ© : âˆƒ e : unitLattice K, e + logMap x âˆˆ ZSpan.fundamentalDomain B\n  Â· exact âŸ¨u, by rwa [Set.mem_preimage, logMap_unit_smul u hx], by simp [hx]âŸ©\n  Â· obtain âŸ¨âŸ¨e, hâ‚âŸ©, hâ‚‚, -âŸ© := ZSpan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)\n    exact âŸ¨âŸ¨e, by rwa [â† Basis.ofZLatticeBasis_span â„ (unitLattice K)]âŸ©, hâ‚‚âŸ©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.torsion_smul_mem_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nÎ¶ : Units (NumberField.RingOfIntegers K)\nhÎ¶ : Membership.mem (NumberField.Units.torsion K) Î¶\nâŠ¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul Î¶ x)","decl":"theorem torsion_smul_mem_of_mem (hx : x âˆˆ fundamentalCone K) {Î¶ : (ğ“ K)Ë£} (hÎ¶ : Î¶ âˆˆ torsion K) :\n    Î¶ â€¢ x âˆˆ fundamentalCone K := by\n  constructor\n  Â· rw [Set.mem_preimage, logMap_torsion_smul _ hÎ¶]\n    exact hx.1\n  Â· rw [Set.mem_setOf_eq, unitSMul_smul, map_mul, norm_unit, one_mul]\n    exact hx.2\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.unit_smul_mem_iff_mem_torsion","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x\nu : Units (NumberField.RingOfIntegers K)\nâŠ¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) (HSMul.hSMul u x)) (Membership.mem (NumberField.Units.torsion K) u)","decl":"theorem unit_smul_mem_iff_mem_torsion (hx : x âˆˆ fundamentalCone K) (u : (ğ“ K)Ë£) :\n    u â€¢ x âˆˆ fundamentalCone K â†” u âˆˆ torsion K := by\n  classical\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ torsion_smul_mem_of_mem hx hâŸ©\n  rw [â† logEmbedding_eq_zero_iff]\n  let B := (basisUnitLattice K).ofZLatticeBasis â„\n  refine (Subtype.mk_eq_mk (h := ?_) (h' := Submodule.zero_mem _)).mp <|\n    (ZSpan.exist_unique_vadd_mem_fundamentalDomain B (logMap x)).unique ?_ ?_\n  Â· rw [Basis.ofZLatticeBasis_span â„ (unitLattice K)]\n    exact âŸ¨u, trivial, rflâŸ©\n  Â· rw [AddSubmonoid.mk_vadd, vadd_eq_add, â† logMap_unit_smul _ hx.2]\n    exact h.1\n  Â· rw [AddSubmonoid.mk_vadd, vadd_eq_add, zero_add]\n    exact hx.1\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\nâŠ¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a) (And (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) a) (Exists fun x => Eq ((NumberField.mixedEmbedding K) â†‘x) a))","decl":"theorem mem_integerSet {a : mixedSpace K} :\n    a âˆˆ integerSet K â†” a âˆˆ fundamentalCone K âˆ§ âˆƒ x : ğ“ K, mixedEmbedding K x = a := by\n  simp only [integerSet, Set.mem_inter_iff, SetLike.mem_coe, LinearMap.mem_range,\n    AlgHom.toLinearMap_apply, RingHom.toIntAlgHom_coe, RingHom.coe_comp, Function.comp_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.existsUnique_preimage_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\nha : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a\nâŠ¢ ExistsUnique fun x => Eq ((NumberField.mixedEmbedding K) â†‘x) a","decl":"/-- If `a` is in `integerSet`, then there is a *unique* algebraic integer in `ğ“ K` such\nthat `mixedEmbedding K x = a`. -/\ntheorem existsUnique_preimage_of_mem_integerSet {a : mixedSpace K} (ha : a âˆˆ integerSet K) :\n    âˆƒ! x : ğ“ K, mixedEmbedding K x = a := by\n  obtain âŸ¨_, âŸ¨x, rflâŸ©âŸ© := mem_integerSet.mp ha\n  refine Function.Injective.existsUnique_of_mem_range ?_ (Set.mem_range_self x)\n  exact (mixedEmbedding_injective K).comp RingOfIntegers.coe_injective\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unique_preimage_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : NumberField.mixedEmbedding.mixedSpace K\nha : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) a\nâŠ¢ ExistsUnique fun x => Eq ((NumberField.mixedEmbedding K) â†‘x) a","decl":"@[deprecated (since := \"2024-12-17\")]\nalias exists_unique_preimage_of_mem_integerSet := existsUnique_preimage_of_mem_integerSet\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.ne_zero_of_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Ne (â†‘a) 0","decl":"theorem ne_zero_of_mem_integerSet (a : integerSet K) : (a : mixedSpace K) â‰  0 := by\n  by_contra!\n  exact a.prop.1.2 (this.symm â–¸ mixedEmbedding.norm.map_zero')\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mixedEmbedding_preimageOfMemIntegerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq ((NumberField.mixedEmbedding K) â†‘â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)) â†‘a","decl":"@[simp]\ntheorem mixedEmbedding_preimageOfMemIntegerSet (a : integerSet K) :\n    mixedEmbedding K (preimageOfMemIntegerSet a : ğ“ K) = (a : mixedSpace K) := by\n  rw [preimageOfMemIntegerSet, (mem_integerSet.mp a.prop).2.choose_spec]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet_mixedEmbedding","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.RingOfIntegers K\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) ((NumberField.mixedEmbedding K) â†‘x)\nâŠ¢ Eq (â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet âŸ¨(NumberField.mixedEmbedding K) â†‘x, hxâŸ©)) x","decl":"theorem preimageOfMemIntegerSet_mixedEmbedding {x : (ğ“ K)}\n    (hx : mixedEmbedding K (x : ğ“ K) âˆˆ integerSet K) :\n    preimageOfMemIntegerSet (âŸ¨mixedEmbedding K (x : ğ“ K), hxâŸ©) = x := by\n  simp_rw [RingOfIntegers.ext_iff, â† (mixedEmbedding_injective K).eq_iff,\n    mixedEmbedding_preimageOfMemIntegerSet]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.exists_unitSMul_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Ne x 0\nhx' : Membership.mem (Set.image (â‡‘(NumberField.mixedEmbedding K)) (Set.range â‡‘(algebraMap (NumberField.RingOfIntegers K) K))) x\nâŠ¢ Exists fun u => Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) (HSMul.hSMul u x)","decl":"/-- If `x : mixedSpace K` is nonzero and the image of an algebraic integer, then there exists a\nunit such that `u â€¢ x âˆˆ integerSet K`. -/\ntheorem exists_unitSMul_mem_integerSet {x : mixedSpace K} (hx : x â‰  0)\n    (hx' : x âˆˆ mixedEmbedding K '' (Set.range (algebraMap (ğ“ K) K))) :\n    âˆƒ u : (ğ“ K)Ë£, u â€¢ x âˆˆ integerSet K := by\n  replace hx : mixedEmbedding.norm x â‰  0 :=\n      (norm_eq_zero_iff' (Set.mem_range_of_mem_image (mixedEmbedding K) _ hx')).not.mpr hx\n  obtain âŸ¨u, huâŸ© := exists_unit_smul_mem hx\n  obtain âŸ¨_, âŸ¨x, rflâŸ©, _, rflâŸ© := hx'\n  exact âŸ¨u, mem_integerSet.mpr âŸ¨hu, u * x, by simp_rw [unitSMul_smul, â† map_mul]âŸ©âŸ©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.torsion_unitSMul_mem_integerSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nÎ¶ : Units (NumberField.RingOfIntegers K)\nhÎ¶ : Membership.mem (NumberField.Units.torsion K) Î¶\nhx : Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) x\nâŠ¢ Membership.mem (NumberField.mixedEmbedding.fundamentalCone.integerSet K) (HSMul.hSMul Î¶ x)","decl":"/-- The set `integerSet K` is stable under the action of the torsion. -/\ntheorem torsion_unitSMul_mem_integerSet {x : mixedSpace K} {Î¶ : (ğ“ K)Ë£} (hÎ¶ : Î¶ âˆˆ torsion K)\n    (hx : x âˆˆ integerSet K) : Î¶ â€¢ x âˆˆ integerSet K := by\n  obtain âŸ¨a, âŸ¨_, rflâŸ©, rflâŸ© := (mem_integerSet.mp hx).2\n  refine mem_integerSet.mpr âŸ¨torsion_smul_mem_of_mem hx.1 hÎ¶, âŸ¨Î¶ * a, by simpâŸ©âŸ©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetTorsionSMul_smul_coe","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nxâœÂ¹ : Subtype fun x => Membership.mem (NumberField.Units.torsion K) x\nxâœ : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (â†‘(HSMul.hSMul xâœÂ¹ xâœ)) (HSMul.hSMul â†‘xâœÂ¹ â†‘xâœ)","decl":"/-- The action of `torsion K` on `integerSet K`. -/\n@[simps]\ninstance integerSetTorsionSMul: SMul (torsion K) (integerSet K) where\n  smul := fun âŸ¨Î¶, hÎ¶âŸ© âŸ¨x, hxâŸ© â†¦ âŸ¨Î¶ â€¢ x, torsion_unitSMul_mem_integerSet hÎ¶ hxâŸ©\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.intNorm_coe","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (â†‘(NumberField.mixedEmbedding.fundamentalCone.intNorm a)) (NumberField.mixedEmbedding.norm â†‘a)","decl":"@[simp]\ntheorem intNorm_coe (a : integerSet K) :\n    (intNorm a : â„) = mixedEmbedding.norm (a : mixedSpace K) := by\n  rw [intNorm, Int.cast_natAbs, â† Rat.cast_intCast, Int.cast_abs, Algebra.coe_norm_int,\n    â† norm_eq_norm, mixedEmbedding_preimageOfMemIntegerSet]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.quotIntNorm_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (NumberField.mixedEmbedding.fundamentalCone.quotIntNorm (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)) a)) (NumberField.mixedEmbedding.fundamentalCone.intNorm a)","decl":"@[simp]\ntheorem quotIntNorm_apply (a : integerSet K) : quotIntNorm âŸ¦aâŸ§ = intNorm a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K a) (Quotient.mk (Associated.setoid (Subtype fun x => Membership.mem (nonZeroDivisors (NumberField.RingOfIntegers K)) x)) (NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a))","decl":"@[simp]\ntheorem integerSetToAssociates_apply (a : integerSet K) :\n    integerSetToAssociates K a = âŸ¦preimageOfMemIntegerSet aâŸ§ := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_surjective","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Function.Surjective (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K)","decl":"variable (K) in\ntheorem integerSetToAssociates_surjective :\n    Function.Surjective (integerSetToAssociates K) := by\n  rintro âŸ¨xâŸ©\n  obtain âŸ¨u, huâŸ© : âˆƒ u : (ğ“ K)Ë£, u â€¢ mixedEmbedding K (x : ğ“ K) âˆˆ integerSet K := by\n    refine exists_unitSMul_mem_integerSet ?_ âŸ¨(x : ğ“ K), Set.mem_range_self _, rflâŸ©\n    exact (map_ne_zero _).mpr <| RingOfIntegers.coe_ne_zero_iff.mpr (nonZeroDivisors.coe_ne_zero _)\n  refine âŸ¨âŸ¨u â€¢ mixedEmbedding K (x : ğ“ K), huâŸ©,\n    Quotient.sound âŸ¨unitsNonZeroDivisorsEquiv.symm uâ»Â¹, ?_âŸ©âŸ©\n  simp_rw [Subtype.ext_iff, RingOfIntegers.ext_iff, â† (mixedEmbedding_injective K).eq_iff,\n    Submonoid.coe_mul, map_mul, mixedEmbedding_preimageOfMemIntegerSet,\n    unitSMul_smul, â† map_mul, mul_comm, map_inv, val_inv_unitsNonZeroDivisorsEquiv_symm_apply_coe,\n    Units.mul_inv_cancel_right]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates_eq_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na b : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Iff (Eq (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K a) (NumberField.mixedEmbedding.fundamentalCone.integerSetToAssociates K b)) (Exists fun Î¶ => Eq (HSMul.hSMul Î¶ a) b)","decl":"theorem integerSetToAssociates_eq_iff (a b : integerSet K) :\n    integerSetToAssociates K a = integerSetToAssociates K b â†”\n      âˆƒ Î¶ : torsion K, Î¶ â€¢ a = b := by\n  simp_rw [integerSetToAssociates_apply, Associates.quotient_mk_eq_mk,\n    Associates.mk_eq_mk_iff_associated, Associated, mul_comm, Subtype.ext_iff,\n    RingOfIntegers.ext_iff, â† (mixedEmbedding_injective K).eq_iff, Submonoid.coe_mul, map_mul,\n    mixedEmbedding_preimageOfMemIntegerSet, integerSetTorsionSMul_smul_coe]\n  refine âŸ¨fun âŸ¨u, hâŸ© â†¦  âŸ¨âŸ¨unitsNonZeroDivisorsEquiv u, ?_âŸ©, by simpa using hâŸ©,\n    fun âŸ¨âŸ¨u, _âŸ©, hâŸ© â†¦ âŸ¨unitsNonZeroDivisorsEquiv.symm u, by simpa using hâŸ©âŸ©\n  exact (unit_smul_mem_iff_mem_torsion a.prop.1 _).mp (by simpa [h] using b.prop.1)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetQuotEquivAssociates_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq ((NumberField.mixedEmbedding.fundamentalCone.integerSetQuotEquivAssociates K) (Quotient.mk (MulAction.orbitRel (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)) a)) (Quotient.mk (Associated.setoid (Subtype fun x => Membership.mem (nonZeroDivisors (NumberField.RingOfIntegers K)) x)) (NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a))","decl":"@[simp]\ntheorem integerSetQuotEquivAssociates_apply (a : integerSet K) :\n    integerSetQuotEquivAssociates K âŸ¦aâŸ§ = âŸ¦preimageOfMemIntegerSet aâŸ§ := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetTorsionSMul_stabilizer","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (MulAction.stabilizer (Subtype fun x => Membership.mem (NumberField.Units.torsion K) x) a) Bot.bot","decl":"theorem integerSetTorsionSMul_stabilizer (a : integerSet K) :\n    MulAction.stabilizer (torsion K) a = âŠ¥ := by\n  refine (Subgroup.eq_bot_iff_forall _).mpr fun Î¶ hÎ¶ â†¦ ?_\n  rwa [MulAction.mem_stabilizer_iff, Subtype.ext_iff, integerSetTorsionSMul_smul_coe,\n    unitSMul_smul, â† mixedEmbedding_preimageOfMemIntegerSet, â† map_mul,\n    (mixedEmbedding_injective K).eq_iff, â† map_mul, â† RingOfIntegers.ext_iff, mul_eq_rightâ‚€,\n    Units.val_eq_one, OneMemClass.coe_eq_one] at hÎ¶\n  exact nonZeroDivisors.coe_ne_zero _\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetEquiv_apply_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.integerSet K)\nâŠ¢ Eq (â†‘â†‘((NumberField.mixedEmbedding.fundamentalCone.integerSetEquiv K) a).1) (Ideal.span (Singleton.singleton â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)))","decl":"@[simp]\ntheorem integerSetEquiv_apply_fst (a : integerSet K) :\n    ((integerSetEquiv K a).1 : Ideal (ğ“ K)) = span {(preimageOfMemIntegerSet a : ğ“ K)} := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.integerSetEquivNorm_apply_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nn : Nat\na : Subtype fun a => Eq (NumberField.mixedEmbedding.norm â†‘a) â†‘n\nâŠ¢ Eq (â†‘â†‘((NumberField.mixedEmbedding.fundamentalCone.integerSetEquivNorm K n) a).1) (Ideal.span (Singleton.singleton â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet â†‘a)))","decl":"@[simp]\ntheorem integerSetEquivNorm_apply_fst {n : â„•}\n    (a : {a : integerSet K // mixedEmbedding.norm (a : mixedSpace K) = n}) :\n    ((integerSetEquivNorm K n a).1 : Ideal (ğ“ K)) =\n      span {(preimageOfMemIntegerSet a.val : ğ“ K)} := by\n simp_rw [integerSetEquivNorm, Equiv.prodSubtypeFstEquivSubtypeProd, Equiv.instTrans_trans,\n   Equiv.prodCongrLeft, Equiv.trans_apply, Equiv.subtypeEquiv_apply, Equiv.coe_fn_mk,\n   Equiv.subtypeSubtypeEquivSubtypeInter_apply_coe, integerSetEquiv_apply_fst]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.card_isPrincipal_norm_eq_mul_torsion","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nn : Nat\nâŠ¢ Eq (HMul.hMul (Nat.card â†‘(setOf fun I => And (Submodule.IsPrincipal â†‘I) (Eq (Ideal.absNorm â†‘I) n))) â†‘(NumberField.Units.torsionOrder K)) (Nat.card â†‘(setOf fun a => Eq (NumberField.mixedEmbedding.norm â†‘a) â†‘n))","decl":"/-- For `n` positive, the number of principal ideals in `ğ“ K` of norm `n` multiplied by the order\nof the torsion of `K` is equal to the number of elements in `integerSet K` of norm `n`. -/\ntheorem card_isPrincipal_norm_eq_mul_torsion (n : â„•) :\n    Nat.card {I : (Ideal (ğ“ K))â° | IsPrincipal (I : Ideal (ğ“ K)) âˆ§\n      absNorm (I : Ideal (ğ“ K)) = n} * torsionOrder K =\n        Nat.card {a : integerSet K | mixedEmbedding.norm (a : mixedSpace K) = n} := by\n  rw [torsionOrder, PNat.mk_coe, â† Nat.card_eq_fintype_card, â† Nat.card_prod]\n  exact Nat.card_congr (integerSetEquivNorm K n).symm\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.mem_idealSet","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\nâŠ¢ Iff (Membership.mem (NumberField.mixedEmbedding.fundamentalCone.idealSet K J) x) (And (Membership.mem (NumberField.mixedEmbedding.fundamentalCone K) x) (Exists fun a => And (Membership.mem (â†‘â†‘J) a) (Eq ((NumberField.mixedEmbedding K) â†‘a) x)))","decl":"variable {K J} in\ntheorem mem_idealSet :\n    x âˆˆ idealSet K J â†” x âˆˆ fundamentalCone K âˆ§ âˆƒ a : (ğ“ K), (a : ğ“ K) âˆˆ (J : Set (ğ“ K)) âˆ§\n      mixedEmbedding K (a : ğ“ K) = x := by\n  simp_rw [idealSet, Set.mem_inter_iff, idealLattice, SetLike.mem_coe, FractionalIdeal.coe_mk0,\n    LinearMap.mem_range, LinearMap.coe_comp, LinearMap.coe_restrictScalars, coe_subtype,\n    Function.comp_apply, AlgHom.toLinearMap_apply, RingHom.toIntAlgHom_coe, Subtype.exists,\n    FractionalIdeal.mem_coe, FractionalIdeal.mem_coeIdeal, exists_prop', nonempty_prop,\n    exists_exists_and_eq_and]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetMap_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\nâŠ¢ Eq â†‘(NumberField.mixedEmbedding.fundamentalCone.idealSetMap K J a) â†‘a","decl":"@[simp]\ntheorem idealSetMap_apply (a : idealSet K J) : (idealSetMap K J a : mixedSpace K) = a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.preimage_of_IdealSetMap","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\nâŠ¢ Membership.mem â†‘â†‘J â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet (NumberField.mixedEmbedding.fundamentalCone.idealSetMap K J a))","decl":"theorem preimage_of_IdealSetMap (a : idealSet K J) :\n    (preimageOfMemIntegerSet (idealSetMap K J a) : ğ“ K) âˆˆ (J : Set (ğ“ K)) := by\n  obtain âŸ¨_, âŸ¨x, hxâ‚, hxâ‚‚âŸ©âŸ© := mem_idealSet.mp a.prop\n  simp_rw [idealSetMap, â† hxâ‚‚, preimageOfMemIntegerSet_mixedEmbedding]\n  exact hxâ‚\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\nâŠ¢ Eq â†‘â†‘((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J) a) â†‘a","decl":"theorem idealSetEquiv_apply (a : idealSet K J) :\n    (idealSetEquiv K J a : mixedSpace K) = a := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv_symm_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : Subtype fun a => Membership.mem â†‘â†‘J â†‘(NumberField.mixedEmbedding.fundamentalCone.preimageOfMemIntegerSet a)\nâŠ¢ Eq â†‘((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J).symm a) â†‘â†‘a","decl":"theorem idealSetEquiv_symm_apply\n    (a : {a : integerSet K // (preimageOfMemIntegerSet a : ğ“ K) âˆˆ (J : Set (ğ“ K)) }) :\n    ((idealSetEquiv K J).symm a : mixedSpace K) = a := by\n  rw [â† (idealSetEquiv_apply ((idealSetEquiv K J).symm a)), Equiv.apply_symm_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.intNorm_idealSetEquiv_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\na : â†‘(NumberField.mixedEmbedding.fundamentalCone.idealSet K J)\nâŠ¢ Eq (â†‘(NumberField.mixedEmbedding.fundamentalCone.intNorm â†‘((NumberField.mixedEmbedding.fundamentalCone.idealSetEquiv K J) a))) (NumberField.mixedEmbedding.norm â†‘a)","decl":"theorem intNorm_idealSetEquiv_apply (a : idealSet K J) :\n    intNorm (idealSetEquiv K J a).val = mixedEmbedding.norm (a : mixedSpace K) := by\n  rw [intNorm_coe, idealSetEquiv_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalCone.card_isPrincipal_dvd_norm_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.FundamentalCone","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nJ : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal (NumberField.RingOfIntegers K))) x\ns : Real\nâŠ¢ Eq (HMul.hMul (Nat.card (Subtype fun I => And (Dvd.dvd â†‘J â†‘I) (And (Submodule.IsPrincipal â†‘I) (LE.le (â†‘(Ideal.absNorm â†‘I)) s)))) â†‘(NumberField.Units.torsionOrder K)) (Nat.card (Subtype fun a => LE.le (NumberField.mixedEmbedding.norm â†‘a) s))","decl":"/-- For `s : â„`, the number of principal nonzero ideals in `ğ“ K` divisible par `J` of norm `â‰¤ s`\nmultiplied by the order of the torsion of `K` is equal to the number of elements in `idealSet K J`\nof norm `â‰¤ s`. -/\ntheorem card_isPrincipal_dvd_norm_le (s : â„) :\n    Nat.card {I : (Ideal (ğ“ K))â° // (J : Ideal (ğ“ K)) âˆ£ I âˆ§ IsPrincipal (I : Ideal (ğ“ K)) âˆ§\n      absNorm (I : Ideal (ğ“ K)) â‰¤ s} * torsionOrder K =\n        Nat.card {a : idealSet K J // mixedEmbedding.norm (a : mixedSpace K) â‰¤ s} := by\n  obtain hs | hs := le_or_gt 0 s\n  Â· simp_rw [â† intNorm_idealSetEquiv_apply, â† Nat.le_floor_iff hs]\n    rw [torsionOrder, PNat.mk_coe, â† Nat.card_eq_fintype_card, â† Nat.card_prod]\n    refine Nat.card_congr <| @Equiv.ofFiberEquiv _ (Î³ := Finset.Iic âŒŠsâŒ‹â‚Š) _\n      (fun I â†¦ âŸ¨absNorm I.1.val.1, Finset.mem_Iic.mpr I.1.prop.2.2âŸ©)\n      (fun a â†¦ âŸ¨intNorm (idealSetEquiv K J a.1).1, Finset.mem_Iic.mpr a.propâŸ©) fun âŸ¨i, hiâŸ© â†¦ ?_\n    simp_rw [Subtype.mk.injEq]\n    calc _ â‰ƒ {I : {I : (Ideal (ğ“ K))â° // _ âˆ§ _ âˆ§ _} // absNorm I.1.1 = i} Ã— torsion K :=\n        Equiv.prodSubtypeFstEquivSubtypeProd\n      _    â‰ƒ {I : (Ideal (ğ“ K))â° // (_ âˆ§ _ âˆ§ absNorm I.1 â‰¤ âŒŠsâŒ‹â‚Š) âˆ§ absNorm I.1 = i}\n            Ã— torsion K := Equiv.prodCongrLeft fun _ â†¦ (Equiv.subtypeSubtypeEquivSubtypeInter\n        (p := fun I : (Ideal (ğ“ K))â° â†¦ J.1 âˆ£ I.1 âˆ§ IsPrincipal I.1 âˆ§ absNorm I.1 â‰¤ âŒŠsâŒ‹â‚Š)\n        (q := fun I â†¦ absNorm I.1 = i))\n      _   â‰ƒ {I : (Ideal (ğ“ K))â° // J.1 âˆ£ I.1 âˆ§ IsPrincipal I.1 âˆ§ absNorm I.1 = i}\n            Ã— torsion K := Equiv.prodCongrLeft fun _ â†¦ Equiv.subtypeEquivRight fun _ â†¦ by aesop\n      _   â‰ƒ {a : idealSet K J // mixedEmbedding.norm (a : mixedSpace K) = i} :=\n            (idealSetEquivNorm K J i).symm\n      _   â‰ƒ {a : idealSet K J // intNorm (idealSetEquiv K J a).1 = i} := by\n        simp_rw [â† intNorm_idealSetEquiv_apply, Nat.cast_inj]\n        rfl\n      _   â‰ƒ {b : {a : idealSet K J // intNorm (idealSetEquiv K J a).1 â‰¤ âŒŠsâŒ‹â‚Š} //\n            intNorm (idealSetEquiv K J b).1 = i} :=\n        (Equiv.subtypeSubtypeEquivSubtype fun h â†¦ Finset.mem_Iic.mp (h â–¸ hi)).symm\n  Â· simp_rw [lt_iff_not_le.mp (lt_of_lt_of_le hs (Nat.cast_nonneg _)), lt_iff_not_le.mp\n      (lt_of_lt_of_le hs (mixedEmbedding.norm_nonneg _)), and_false, Nat.card_of_isEmpty,\n      zero_mul]\n\n"}
