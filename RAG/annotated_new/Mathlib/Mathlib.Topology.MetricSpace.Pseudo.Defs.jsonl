{"name":"UniformSpace.ofDist_aux","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (x : Real), LT.lt x Œ¥ ‚Üí ‚àÄ (y : Real), LT.lt y Œ¥ ‚Üí LT.lt (HAdd.hAdd x y) Œµ)","decl":"theorem UniformSpace.ofDist_aux (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) : ‚àÉ Œ¥ > (0 : ‚Ñù), ‚àÄ x < Œ¥, ‚àÄ y < Œ¥, x + y < Œµ :=\n  ‚ü®Œµ / 2, half_pos hŒµ, fun _x hx _y hy => add_halves Œµ ‚ñ∏ add_lt_add hx hy‚ü©\n\n"}
{"name":"Dist.ext_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nx y : Dist Œ±\n‚ä¢ Iff (Eq x y) (Eq Dist.dist Dist.dist)","decl":"/-- The distance function (given an ambient metric space on `Œ±`), which returns\n  a nonnegative real number `dist x y` given `x y : Œ±`. -/\n@[ext]\nclass Dist (Œ± : Type*) where\n  dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù\n\n"}
{"name":"Dist.ext","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nx y : Dist Œ±\ndist : Eq Dist.dist Dist.dist\n‚ä¢ Eq x y","decl":"/-- The distance function (given an ambient metric space on `Œ±`), which returns\n  a nonnegative real number `dist x y` given `x y : Œ±`. -/\n@[ext]\nclass Dist (Œ± : Type*) where\n  dist : Œ± ‚Üí Œ± ‚Üí ‚Ñù\n\n"}
{"name":"PseudoMetricSpace.cobounded_sets","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\n‚ä¢ Eq (Bornology.cobounded Œ±).sets (setOf fun s => Exists fun C => ‚àÄ (x : Œ±), Membership.mem (HasCompl.compl s) x ‚Üí ‚àÄ (y : Œ±), Membership.mem (HasCompl.compl s) y ‚Üí LE.le (Dist.dist x y) C)","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Dist.dist x x) 0","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.uniformity_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (Dist.dist p.1 p.2) Œµ))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.edist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (PseudoMetricSpace.edist x y) (ENNReal.ofReal (Dist.dist x y))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nself : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Dist.dist y x)","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 ‚Üí x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 ‚Üí x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (Œ± : Type u) extends Dist Œ± : Type u where\n  dist_self : ‚àÄ x : Œ±, dist x x = 0\n  dist_comm : ‚àÄ x y : Œ±, dist x y = dist y x\n  dist_triangle : ‚àÄ x y z : Œ±, dist x z ‚â§ dist x y + dist y z\n  edist : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun x y => ENNReal.ofNNReal ‚ü®dist x y, dist_nonneg' _ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫‚ü©\n  edist_dist : ‚àÄ x y : Œ±, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace Œ± := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by intros; rfl\n  toBornology : Bornology Œ± := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded Œ±).sets =\n    { s | ‚àÉ C : ‚Ñù, ‚àÄ x ‚àà s·∂ú, ‚àÄ y ‚àà s·∂ú, dist x y ‚â§ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.ext","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nm m' : PseudoMetricSpace Œ±\nh : Eq PseudoMetricSpace.toDist PseudoMetricSpace.toDist\n‚ä¢ Eq m m'","decl":"/-- Two pseudo metric space structures with the same distance function coincide. -/\n@[ext]\ntheorem PseudoMetricSpace.ext {Œ± : Type*} {m m' : PseudoMetricSpace Œ±}\n    (h : m.toDist = m'.toDist) : m = m' := by\n  cases' m with d _ _ _ ed hed U hU B hB\n  cases' m' with d' _ _ _ ed' hed' U' hU' B' hB'\n  obtain rfl : d = d' := h\n  congr\n  ¬∑ ext x y : 2\n    rw [hed, hed']\n  ¬∑ exact UniformSpace.ext (hU.trans hU'.symm)\n  ¬∑ ext : 2\n    rw [‚Üê Filter.mem_sets, ‚Üê Filter.mem_sets, hB, hB']\n\n"}
{"name":"PseudoMetricSpace.ext_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nm m' : PseudoMetricSpace Œ±\n‚ä¢ Iff (Eq m m') (Eq PseudoMetricSpace.toDist PseudoMetricSpace.toDist)","decl":"/-- Two pseudo metric space structures with the same distance function coincide. -/\n@[ext]\ntheorem PseudoMetricSpace.ext {Œ± : Type*} {m m' : PseudoMetricSpace Œ±}\n    (h : m.toDist = m'.toDist) : m = m' := by\n  cases' m with d _ _ _ ed hed U hU B hB\n  cases' m' with d' _ _ _ ed' hed' U' hU' B' hB'\n  obtain rfl : d = d' := h\n  congr\n  ¬∑ ext x y : 2\n    rw [hed, hed']\n  ¬∑ exact UniformSpace.ext (hU.trans hU'.symm)\n  ¬∑ ext : 2\n    rw [‚Üê Filter.mem_sets, ‚Üê Filter.mem_sets, hB, hB']\n\n"}
{"name":"dist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Dist.dist x x) 0","decl":"@[simp]\ntheorem dist_self (x : Œ±) : dist x x = 0 :=\n  PseudoMetricSpace.dist_self x\n\n"}
{"name":"dist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (Dist.dist y x)","decl":"theorem dist_comm (x y : Œ±) : dist x y = dist y x :=\n  PseudoMetricSpace.dist_comm x y\n\n"}
{"name":"edist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist x y) (ENNReal.ofReal (Dist.dist x y))","decl":"theorem edist_dist (x y : Œ±) : edist x y = ENNReal.ofReal (dist x y) :=\n  PseudoMetricSpace.edist_dist x y\n\n"}
{"name":"dist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"@[bound]\ntheorem dist_triangle (x y z : Œ±) : dist x z ‚â§ dist x y + dist y z :=\n  PseudoMetricSpace.dist_triangle x y z\n\n"}
{"name":"dist_triangle_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist x y) (HAdd.hAdd (Dist.dist z x) (Dist.dist z y))","decl":"theorem dist_triangle_left (x y z : Œ±) : dist x y ‚â§ dist z x + dist z y := by\n  rw [dist_comm z]; apply dist_triangle\n\n"}
{"name":"dist_triangle_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist x y) (HAdd.hAdd (Dist.dist x z) (Dist.dist y z))","decl":"theorem dist_triangle_right (x y z : Œ±) : dist x y ‚â§ dist x z + dist y z := by\n  rw [dist_comm y]; apply dist_triangle\n\n"}
{"name":"dist_triangle4","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z w : Œ±\n‚ä¢ LE.le (Dist.dist x w) (HAdd.hAdd (HAdd.hAdd (Dist.dist x y) (Dist.dist y z)) (Dist.dist z w))","decl":"theorem dist_triangle4 (x y z w : Œ±) : dist x w ‚â§ dist x y + dist y z + dist z w :=\n  calc\n    dist x w ‚â§ dist x z + dist z w := dist_triangle x z w\n    _ ‚â§ dist x y + dist y z + dist z w := add_le_add_right (dist_triangle x y z) _\n\n"}
{"name":"dist_triangle4_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±\n‚ä¢ LE.le (Dist.dist x‚ÇÇ y‚ÇÇ) (HAdd.hAdd (Dist.dist x‚ÇÅ y‚ÇÅ) (HAdd.hAdd (Dist.dist x‚ÇÅ x‚ÇÇ) (Dist.dist y‚ÇÅ y‚ÇÇ)))","decl":"theorem dist_triangle4_left (x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±) :\n    dist x‚ÇÇ y‚ÇÇ ‚â§ dist x‚ÇÅ y‚ÇÅ + (dist x‚ÇÅ x‚ÇÇ + dist y‚ÇÅ y‚ÇÇ) := by\n  rw [add_left_comm, dist_comm x‚ÇÅ, ‚Üê add_assoc]\n  apply dist_triangle4\n\n"}
{"name":"dist_triangle4_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±\n‚ä¢ LE.le (Dist.dist x‚ÇÅ y‚ÇÅ) (HAdd.hAdd (HAdd.hAdd (Dist.dist x‚ÇÅ x‚ÇÇ) (Dist.dist y‚ÇÅ y‚ÇÇ)) (Dist.dist x‚ÇÇ y‚ÇÇ))","decl":"theorem dist_triangle4_right (x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Œ±) :\n    dist x‚ÇÅ y‚ÇÅ ‚â§ dist x‚ÇÅ x‚ÇÇ + dist y‚ÇÅ y‚ÇÇ + dist x‚ÇÇ y‚ÇÇ := by\n  rw [add_right_comm, dist_comm y‚ÇÅ]\n  apply dist_triangle4\n\n"}
{"name":"swap_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ Eq (Function.swap Dist.dist) Dist.dist","decl":"theorem swap_dist : Function.swap (@dist Œ± _) = dist := by funext x y; exact dist_comm _ _\n\n"}
{"name":"abs_dist_sub_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (abs (HSub.hSub (Dist.dist x z) (Dist.dist y z))) (Dist.dist x y)","decl":"theorem abs_dist_sub_le (x y z : Œ±) : |dist x z - dist y z| ‚â§ dist x y :=\n  abs_sub_le_iff.2\n    ‚ü®sub_le_iff_le_add.2 (dist_triangle _ _ _), sub_le_iff_le_add.2 (dist_triangle_left _ _ _)‚ü©\n\n"}
{"name":"dist_nonneg","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ LE.le 0 (Dist.dist x y)","decl":"@[bound]\ntheorem dist_nonneg {x y : Œ±} : 0 ‚â§ dist x y :=\n  dist_nonneg' dist dist_self dist_comm dist_triangle\n\n"}
{"name":"abs_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\na b : Œ±\n‚ä¢ Eq (abs (Dist.dist a b)) (Dist.dist a b)","decl":"@[simp] theorem abs_dist {a b : Œ±} : |dist a b| = dist a b := abs_of_nonneg dist_nonneg\n\n"}
{"name":"dist_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) ‚Üë(NNDist.nndist x y)","decl":"/-- Express `dist` in terms of `nndist`-/\ntheorem dist_nndist (x y : Œ±) : dist x y = nndist x y := rfl\n\n"}
{"name":"coe_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (‚Üë(NNDist.nndist x y)) (Dist.dist x y)","decl":"@[simp, norm_cast]\ntheorem coe_nndist (x y : Œ±) : ‚Üë(nndist x y) = dist x y := rfl\n\n"}
{"name":"edist_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (EDist.edist x y) ‚Üë(NNDist.nndist x y)","decl":"/-- Express `edist` in terms of `nndist`-/\ntheorem edist_nndist (x y : Œ±) : edist x y = nndist x y := by\n  rw [edist_dist, dist_nndist, ENNReal.ofReal_coe_nnreal]\n\n"}
{"name":"nndist_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (NNDist.nndist x y) (EDist.edist x y).toNNReal","decl":"/-- Express `nndist` in terms of `edist`-/\ntheorem nndist_edist (x y : Œ±) : nndist x y = (edist x y).toNNReal := by\n  simp [edist_nndist]\n\n"}
{"name":"coe_nnreal_ennreal_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (‚Üë(NNDist.nndist x y)) (EDist.edist x y)","decl":"@[simp, norm_cast]\ntheorem coe_nnreal_ennreal_nndist (x y : Œ±) : ‚Üë(nndist x y) = edist x y :=\n  (edist_nndist x y).symm\n\n"}
{"name":"edist_lt_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nc : NNReal\n‚ä¢ Iff (LT.lt (EDist.edist x y) ‚Üëc) (LT.lt (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem edist_lt_coe {x y : Œ±} {c : ‚Ñù‚â•0} : edist x y < c ‚Üî nndist x y < c := by\n  rw [edist_nndist, ENNReal.coe_lt_coe]\n\n"}
{"name":"edist_le_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nc : NNReal\n‚ä¢ Iff (LE.le (EDist.edist x y) ‚Üëc) (LE.le (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem edist_le_coe {x y : Œ±} {c : ‚Ñù‚â•0} : edist x y ‚â§ c ‚Üî nndist x y ‚â§ c := by\n  rw [edist_nndist, ENNReal.coe_le_coe]\n\n"}
{"name":"edist_lt_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ LT.lt (EDist.edist x y) Top.top","decl":"/-- In a pseudometric space, the extended distance is always finite -/\ntheorem edist_lt_top {Œ± : Type*} [PseudoMetricSpace Œ±] (x y : Œ±) : edist x y < ‚ä§ :=\n  (edist_dist x y).symm ‚ñ∏ ENNReal.ofReal_lt_top\n\n"}
{"name":"edist_ne_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Ne (EDist.edist x y) Top.top","decl":"/-- In a pseudometric space, the extended distance is always finite -/\ntheorem edist_ne_top (x y : Œ±) : edist x y ‚â† ‚ä§ :=\n  (edist_lt_top x y).ne\n\n"}
{"name":"nndist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\na : Œ±\n‚ä¢ Eq (NNDist.nndist a a) 0","decl":"/-- `nndist x x` vanishes -/\n@[simp] theorem nndist_self (a : Œ±) : nndist a a = 0 := NNReal.coe_eq_zero.1 (dist_self a)\n\n-- Porting note: `dist_nndist` and `coe_nndist` moved up\n\n"}
{"name":"dist_lt_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nc : NNReal\n‚ä¢ Iff (LT.lt (Dist.dist x y) ‚Üëc) (LT.lt (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem dist_lt_coe {x y : Œ±} {c : ‚Ñù‚â•0} : dist x y < c ‚Üî nndist x y < c :=\n  Iff.rfl\n\n"}
{"name":"dist_le_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nc : NNReal\n‚ä¢ Iff (LE.le (Dist.dist x y) ‚Üëc) (LE.le (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem dist_le_coe {x y : Œ±} {c : ‚Ñù‚â•0} : dist x y ‚â§ c ‚Üî nndist x y ‚â§ c :=\n  Iff.rfl\n\n"}
{"name":"edist_lt_ofReal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nr : Real\n‚ä¢ Iff (LT.lt (EDist.edist x y) (ENNReal.ofReal r)) (LT.lt (Dist.dist x y) r)","decl":"@[simp]\ntheorem edist_lt_ofReal {x y : Œ±} {r : ‚Ñù} : edist x y < ENNReal.ofReal r ‚Üî dist x y < r := by\n  rw [edist_dist, ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\n"}
{"name":"edist_le_ofReal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nr : Real\nhr : LE.le 0 r\n‚ä¢ Iff (LE.le (EDist.edist x y) (ENNReal.ofReal r)) (LE.le (Dist.dist x y) r)","decl":"@[simp]\ntheorem edist_le_ofReal {x y : Œ±} {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    edist x y ‚â§ ENNReal.ofReal r ‚Üî dist x y ‚â§ r := by\n  rw [edist_dist, ENNReal.ofReal_le_ofReal_iff hr]\n\n"}
{"name":"nndist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (NNDist.nndist x y) (Dist.dist x y).toNNReal","decl":"/-- Express `nndist` in terms of `dist`-/\ntheorem nndist_dist (x y : Œ±) : nndist x y = Real.toNNReal (dist x y) := by\n  rw [dist_nndist, Real.toNNReal_coe]\n\n"}
{"name":"nndist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (NNDist.nndist x y) (NNDist.nndist y x)","decl":"theorem nndist_comm (x y : Œ±) : nndist x y = nndist y x := NNReal.eq <| dist_comm x y\n\n"}
{"name":"nndist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (NNDist.nndist x z) (HAdd.hAdd (NNDist.nndist x y) (NNDist.nndist y z))","decl":"/-- Triangle inequality for the nonnegative distance -/\ntheorem nndist_triangle (x y z : Œ±) : nndist x z ‚â§ nndist x y + nndist y z :=\n  dist_triangle _ _ _\n\n"}
{"name":"nndist_triangle_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist z x) (NNDist.nndist z y))","decl":"theorem nndist_triangle_left (x y z : Œ±) : nndist x y ‚â§ nndist z x + nndist z y :=\n  dist_triangle_left _ _ _\n\n"}
{"name":"nndist_triangle_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist x z) (NNDist.nndist y z))","decl":"theorem nndist_triangle_right (x y z : Œ±) : nndist x y ‚â§ nndist x z + nndist y z :=\n  dist_triangle_right _ _ _\n\n"}
{"name":"dist_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\n‚ä¢ Eq (Dist.dist x y) (EDist.edist x y).toReal","decl":"/-- Express `dist` in terms of `edist`-/\ntheorem dist_edist (x y : Œ±) : dist x y = (edist x y).toReal := by\n  rw [edist_dist, ENNReal.toReal_ofReal dist_nonneg]\n\n"}
{"name":"Metric.mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.ball x Œµ) y) (LT.lt (Dist.dist y x) Œµ)","decl":"@[simp]\ntheorem mem_ball : y ‚àà ball x Œµ ‚Üî dist y x < Œµ :=\n  Iff.rfl\n\n"}
{"name":"Metric.mem_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.ball x Œµ) y) (LT.lt (Dist.dist x y) Œµ)","decl":"theorem mem_ball' : y ‚àà ball x Œµ ‚Üî dist x y < Œµ := by rw [dist_comm, mem_ball]\n\n"}
{"name":"Metric.pos_of_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\nhy : Membership.mem (Metric.ball x Œµ) y\n‚ä¢ LT.lt 0 Œµ","decl":"theorem pos_of_mem_ball (hy : y ‚àà ball x Œµ) : 0 < Œµ :=\n  dist_nonneg.trans_lt hy\n\n"}
{"name":"Metric.mem_ball_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nh : LT.lt 0 Œµ\n‚ä¢ Membership.mem (Metric.ball x Œµ) x","decl":"theorem mem_ball_self (h : 0 < Œµ) : x ‚àà ball x Œµ := by\n  rwa [mem_ball, dist_self]\n\n"}
{"name":"Metric.nonempty_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Iff (Metric.ball x Œµ).Nonempty (LT.lt 0 Œµ)","decl":"@[simp]\ntheorem nonempty_ball : (ball x Œµ).Nonempty ‚Üî 0 < Œµ :=\n  ‚ü®fun ‚ü®_x, hx‚ü© => pos_of_mem_ball hx, fun h => ‚ü®x, mem_ball_self h‚ü©‚ü©\n\n"}
{"name":"Metric.ball_eq_empty","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Iff (Eq (Metric.ball x Œµ) EmptyCollection.emptyCollection) (LE.le Œµ 0)","decl":"@[simp]\ntheorem ball_eq_empty : ball x Œµ = ‚àÖ ‚Üî Œµ ‚â§ 0 := by\n  rw [‚Üê not_nonempty_iff_eq_empty, nonempty_ball, not_lt]\n\n"}
{"name":"Metric.ball_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Metric.ball x 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_zero : ball x 0 = ‚àÖ := by rw [ball_eq_empty]\n\n"}
{"name":"Metric.exists_lt_mem_ball_of_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\nh : Membership.mem (Metric.ball y Œµ) x\n‚ä¢ Exists fun Œµ' => And (LT.lt Œµ' Œµ) (Membership.mem (Metric.ball y Œµ') x)","decl":"/-- If a point belongs to an open ball, then there is a strictly smaller radius whose ball also\ncontains it.\n\nSee also `exists_lt_subset_ball`. -/\ntheorem exists_lt_mem_ball_of_mem_ball (h : x ‚àà ball y Œµ) : ‚àÉ Œµ' < Œµ, x ‚àà ball y Œµ' := by\n  simp only [mem_ball] at h ‚ä¢\n  exact ‚ü®(dist x y + Œµ) / 2, by linarith, by linarith‚ü©\n\n"}
{"name":"Metric.ball_eq_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒµ : Real\nx : Œ±\n‚ä¢ Eq (UniformSpace.ball x (setOf fun p => LT.lt (Dist.dist p.2 p.1) Œµ)) (Metric.ball x Œµ)","decl":"theorem ball_eq_ball (Œµ : ‚Ñù) (x : Œ±) :\n    UniformSpace.ball x { p | dist p.2 p.1 < Œµ } = Metric.ball x Œµ :=\n  rfl\n\n"}
{"name":"Metric.ball_eq_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒµ : Real\nx : Œ±\n‚ä¢ Eq (UniformSpace.ball x (setOf fun p => LT.lt (Dist.dist p.1 p.2) Œµ)) (Metric.ball x Œµ)","decl":"theorem ball_eq_ball' (Œµ : ‚Ñù) (x : Œ±) :\n    UniformSpace.ball x { p | dist p.1 p.2 < Œµ } = Metric.ball x Œµ := by\n  ext\n  simp [dist_comm, UniformSpace.ball]\n\n"}
{"name":"Metric.iUnion_ball_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Set.iUnion fun n => Metric.ball x ‚Üën) Set.univ","decl":"@[simp]\ntheorem iUnion_ball_nat (x : Œ±) : ‚ãÉ n : ‚Ñï, ball x n = univ :=\n  iUnion_eq_univ_iff.2 fun y => exists_nat_gt (dist y x)\n\n"}
{"name":"Metric.iUnion_ball_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Set.iUnion fun n => Metric.ball x (HAdd.hAdd (‚Üën) 1)) Set.univ","decl":"@[simp]\ntheorem iUnion_ball_nat_succ (x : Œ±) : ‚ãÉ n : ‚Ñï, ball x (n + 1) = univ :=\n  iUnion_eq_univ_iff.2 fun y => (exists_nat_gt (dist y x)).imp fun _ h => h.trans (lt_add_one _)\n\n"}
{"name":"Metric.mem_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.closedBall x Œµ) y) (LE.le (Dist.dist y x) Œµ)","decl":"@[simp] theorem mem_closedBall : y ‚àà closedBall x Œµ ‚Üî dist y x ‚â§ Œµ := Iff.rfl\n\n"}
{"name":"Metric.mem_closedBall'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.closedBall x Œµ) y) (LE.le (Dist.dist x y) Œµ)","decl":"theorem mem_closedBall' : y ‚àà closedBall x Œµ ‚Üî dist x y ‚â§ Œµ := by rw [dist_comm, mem_closedBall]\n\n"}
{"name":"Metric.mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.sphere x Œµ) y) (Eq (Dist.dist y x) Œµ)","decl":"@[simp] theorem mem_sphere : y ‚àà sphere x Œµ ‚Üî dist y x = Œµ := Iff.rfl\n\n"}
{"name":"Metric.mem_sphere'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.sphere x Œµ) y) (Eq (Dist.dist x y) Œµ)","decl":"theorem mem_sphere' : y ‚àà sphere x Œµ ‚Üî dist x y = Œµ := by rw [dist_comm, mem_sphere]\n\n"}
{"name":"Metric.ne_of_mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\nh : Membership.mem (Metric.sphere x Œµ) y\nhŒµ : Ne Œµ 0\n‚ä¢ Ne y x","decl":"theorem ne_of_mem_sphere (h : y ‚àà sphere x Œµ) (hŒµ : Œµ ‚â† 0) : y ‚â† x :=\n  ne_of_mem_of_not_mem h <| by simpa using hŒµ.symm\n\n"}
{"name":"Metric.nonneg_of_mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\nhy : Membership.mem (Metric.sphere x Œµ) y\n‚ä¢ LE.le 0 Œµ","decl":"theorem nonneg_of_mem_sphere (hy : y ‚àà sphere x Œµ) : 0 ‚â§ Œµ :=\n  dist_nonneg.trans_eq hy\n\n"}
{"name":"Metric.sphere_eq_empty_of_neg","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nhŒµ : LT.lt Œµ 0\n‚ä¢ Eq (Metric.sphere x Œµ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sphere_eq_empty_of_neg (hŒµ : Œµ < 0) : sphere x Œµ = ‚àÖ :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun _y hy => (nonneg_of_mem_sphere hy).not_lt hŒµ\n\n"}
{"name":"Metric.sphere_eq_empty_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù¬π : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\ninst‚úù : Subsingleton Œ±\nhŒµ : Ne Œµ 0\n‚ä¢ Eq (Metric.sphere x Œµ) EmptyCollection.emptyCollection","decl":"theorem sphere_eq_empty_of_subsingleton [Subsingleton Œ±] (hŒµ : Œµ ‚â† 0) : sphere x Œµ = ‚àÖ :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun _ h => ne_of_mem_sphere h hŒµ (Subsingleton.elim _ _)\n\n"}
{"name":"Metric.sphere_isEmpty_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\ninst‚úù¬π : Subsingleton Œ±\ninst‚úù : NeZero Œµ\n‚ä¢ IsEmpty ‚Üë(Metric.sphere x Œµ)","decl":"instance sphere_isEmpty_of_subsingleton [Subsingleton Œ±] [NeZero Œµ] : IsEmpty (sphere x Œµ) := by\n  rw [sphere_eq_empty_of_subsingleton (NeZero.ne Œµ)]; infer_instance\n\n"}
{"name":"Metric.closedBall_eq_singleton_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù¬π : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\ninst‚úù : Subsingleton Œ±\nh : LE.le 0 Œµ\n‚ä¢ Eq (Metric.closedBall x Œµ) (Singleton.singleton x)","decl":"theorem closedBall_eq_singleton_of_subsingleton [Subsingleton Œ±] (h : 0 ‚â§ Œµ) :\n    closedBall x Œµ = {x} := by\n  ext x'\n  simpa [Subsingleton.allEq x x']\n\n"}
{"name":"Metric.ball_eq_singleton_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù¬π : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\ninst‚úù : Subsingleton Œ±\nh : LT.lt 0 Œµ\n‚ä¢ Eq (Metric.ball x Œµ) (Singleton.singleton x)","decl":"theorem ball_eq_singleton_of_subsingleton [Subsingleton Œ±] (h : 0 < Œµ) : ball x Œµ = {x} := by\n  ext x'\n  simpa [Subsingleton.allEq x x']\n\n"}
{"name":"Metric.mem_closedBall_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nh : LE.le 0 Œµ\n‚ä¢ Membership.mem (Metric.closedBall x Œµ) x","decl":"theorem mem_closedBall_self (h : 0 ‚â§ Œµ) : x ‚àà closedBall x Œµ := by\n  rwa [mem_closedBall, dist_self]\n\n"}
{"name":"Metric.nonempty_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Iff (Metric.closedBall x Œµ).Nonempty (LE.le 0 Œµ)","decl":"@[simp]\ntheorem nonempty_closedBall : (closedBall x Œµ).Nonempty ‚Üî 0 ‚â§ Œµ :=\n  ‚ü®fun ‚ü®_x, hx‚ü© => dist_nonneg.trans hx, fun h => ‚ü®x, mem_closedBall_self h‚ü©‚ü©\n\n"}
{"name":"Metric.closedBall_eq_empty","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Iff (Eq (Metric.closedBall x Œµ) EmptyCollection.emptyCollection) (LT.lt Œµ 0)","decl":"@[simp]\ntheorem closedBall_eq_empty : closedBall x Œµ = ‚àÖ ‚Üî Œµ < 0 := by\n  rw [‚Üê not_nonempty_iff_eq_empty, nonempty_closedBall, not_le]\n\n"}
{"name":"Metric.closedBall_eq_sphere_of_nonpos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nhŒµ : LE.le Œµ 0\n‚ä¢ Eq (Metric.closedBall x Œµ) (Metric.sphere x Œµ)","decl":"/-- Closed balls and spheres coincide when the radius is non-positive -/\ntheorem closedBall_eq_sphere_of_nonpos (hŒµ : Œµ ‚â§ 0) : closedBall x Œµ = sphere x Œµ :=\n  Set.ext fun _ => (hŒµ.trans dist_nonneg).le_iff_eq\n\n"}
{"name":"Metric.ball_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ HasSubset.Subset (Metric.ball x Œµ) (Metric.closedBall x Œµ)","decl":"theorem ball_subset_closedBall : ball x Œµ ‚äÜ closedBall x Œµ := fun _y hy =>\n  mem_closedBall.2 (le_of_lt hy)\n\n"}
{"name":"Metric.sphere_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ HasSubset.Subset (Metric.sphere x Œµ) (Metric.closedBall x Œµ)","decl":"theorem sphere_subset_closedBall : sphere x Œµ ‚äÜ closedBall x Œµ := fun _ => le_of_eq\n\n"}
{"name":"Metric.sphere_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nr R : Real\nh : LT.lt r R\n‚ä¢ HasSubset.Subset (Metric.sphere x r) (Metric.ball x R)","decl":"lemma sphere_subset_ball {r R : ‚Ñù} (h : r < R) : sphere x r ‚äÜ ball x R := fun _x hx ‚Ü¶\n  (mem_sphere.1 hx).trans_lt h\n\n"}
{"name":"Metric.closedBall_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒ¥ Œµ : Real\nh : LE.le (HAdd.hAdd Œ¥ Œµ) (Dist.dist x y)\n‚ä¢ Disjoint (Metric.closedBall x Œ¥) (Metric.ball y Œµ)","decl":"theorem closedBall_disjoint_ball (h : Œ¥ + Œµ ‚â§ dist x y) : Disjoint (closedBall x Œ¥) (ball y Œµ) :=\n  Set.disjoint_left.mpr fun _a ha1 ha2 =>\n    (h.trans <| dist_triangle_left _ _ _).not_lt <| add_lt_add_of_le_of_lt ha1 ha2\n\n"}
{"name":"Metric.ball_disjoint_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒ¥ Œµ : Real\nh : LE.le (HAdd.hAdd Œ¥ Œµ) (Dist.dist x y)\n‚ä¢ Disjoint (Metric.ball x Œ¥) (Metric.closedBall y Œµ)","decl":"theorem ball_disjoint_closedBall (h : Œ¥ + Œµ ‚â§ dist x y) : Disjoint (ball x Œ¥) (closedBall y Œµ) :=\n  (closedBall_disjoint_ball <| by rwa [add_comm, dist_comm]).symm\n\n"}
{"name":"Metric.ball_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒ¥ Œµ : Real\nh : LE.le (HAdd.hAdd Œ¥ Œµ) (Dist.dist x y)\n‚ä¢ Disjoint (Metric.ball x Œ¥) (Metric.ball y Œµ)","decl":"theorem ball_disjoint_ball (h : Œ¥ + Œµ ‚â§ dist x y) : Disjoint (ball x Œ¥) (ball y Œµ) :=\n  (closedBall_disjoint_ball h).mono_left ball_subset_closedBall\n\n"}
{"name":"Metric.closedBall_disjoint_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒ¥ Œµ : Real\nh : LT.lt (HAdd.hAdd Œ¥ Œµ) (Dist.dist x y)\n‚ä¢ Disjoint (Metric.closedBall x Œ¥) (Metric.closedBall y Œµ)","decl":"theorem closedBall_disjoint_closedBall (h : Œ¥ + Œµ < dist x y) :\n    Disjoint (closedBall x Œ¥) (closedBall y Œµ) :=\n  Set.disjoint_left.mpr fun _a ha1 ha2 =>\n    h.not_le <| (dist_triangle_left _ _ _).trans <| add_le_add ha1 ha2\n\n"}
{"name":"Metric.sphere_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Disjoint (Metric.sphere x Œµ) (Metric.ball x Œµ)","decl":"theorem sphere_disjoint_ball : Disjoint (sphere x Œµ) (ball x Œµ) :=\n  Set.disjoint_left.mpr fun _y hy‚ÇÅ hy‚ÇÇ => absurd hy‚ÇÅ <| ne_of_lt hy‚ÇÇ\n\n"}
{"name":"Metric.ball_union_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (Union.union (Metric.ball x Œµ) (Metric.sphere x Œµ)) (Metric.closedBall x Œµ)","decl":"@[simp]\ntheorem ball_union_sphere : ball x Œµ ‚à™ sphere x Œµ = closedBall x Œµ :=\n  Set.ext fun _y => (@le_iff_lt_or_eq ‚Ñù _ _ _).symm\n\n"}
{"name":"Metric.sphere_union_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (Union.union (Metric.sphere x Œµ) (Metric.ball x Œµ)) (Metric.closedBall x Œµ)","decl":"@[simp]\ntheorem sphere_union_ball : sphere x Œµ ‚à™ ball x Œµ = closedBall x Œµ := by\n  rw [union_comm, ball_union_sphere]\n\n"}
{"name":"Metric.closedBall_diff_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (SDiff.sdiff (Metric.closedBall x Œµ) (Metric.sphere x Œµ)) (Metric.ball x Œµ)","decl":"@[simp]\ntheorem closedBall_diff_sphere : closedBall x Œµ \\ sphere x Œµ = ball x Œµ := by\n  rw [‚Üê ball_union_sphere, Set.union_diff_cancel_right sphere_disjoint_ball.symm.le_bot]\n\n"}
{"name":"Metric.closedBall_diff_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (SDiff.sdiff (Metric.closedBall x Œµ) (Metric.ball x Œµ)) (Metric.sphere x Œµ)","decl":"@[simp]\ntheorem closedBall_diff_ball : closedBall x Œµ \\ ball x Œµ = sphere x Œµ := by\n  rw [‚Üê ball_union_sphere, Set.union_diff_cancel_left sphere_disjoint_ball.symm.le_bot]\n\n"}
{"name":"Metric.mem_ball_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.ball y Œµ) x) (Membership.mem (Metric.ball x Œµ) y)","decl":"theorem mem_ball_comm : x ‚àà ball y Œµ ‚Üî y ‚àà ball x Œµ := by rw [mem_ball', mem_ball]\n\n"}
{"name":"Metric.mem_closedBall_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.closedBall y Œµ) x) (Membership.mem (Metric.closedBall x Œµ) y)","decl":"theorem mem_closedBall_comm : x ‚àà closedBall y Œµ ‚Üî y ‚àà closedBall x Œµ := by\n  rw [mem_closedBall', mem_closedBall]\n\n"}
{"name":"Metric.mem_sphere_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\n‚ä¢ Iff (Membership.mem (Metric.sphere y Œµ) x) (Membership.mem (Metric.sphere x Œµ) y)","decl":"theorem mem_sphere_comm : x ‚àà sphere y Œµ ‚Üî y ‚àà sphere x Œµ := by rw [mem_sphere', mem_sphere]\n\n"}
{"name":"Metric.ball_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LE.le Œµ‚ÇÅ Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.ball x Œµ‚ÇÅ) (Metric.ball x Œµ‚ÇÇ)","decl":"@[gcongr]\ntheorem ball_subset_ball (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ := fun _y yx =>\n  lt_of_lt_of_le (mem_ball.1 yx) h\n\n"}
{"name":"Metric.closedBall_eq_bInter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (Metric.closedBall x Œµ) (Set.iInter fun Œ¥ => Set.iInter fun h => Metric.ball x Œ¥)","decl":"theorem closedBall_eq_bInter_ball : closedBall x Œµ = ‚ãÇ Œ¥ > Œµ, ball x Œ¥ := by\n  ext y; rw [mem_closedBall, ‚Üê forall_lt_iff_le', mem_iInter‚ÇÇ]; rfl\n\n"}
{"name":"Metric.ball_subset_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LE.le (HAdd.hAdd Œµ‚ÇÅ (Dist.dist x y)) Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.ball x Œµ‚ÇÅ) (Metric.ball y Œµ‚ÇÇ)","decl":"theorem ball_subset_ball' (h : Œµ‚ÇÅ + dist x y ‚â§ Œµ‚ÇÇ) : ball x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ := fun z hz =>\n  calc\n    dist z y ‚â§ dist z x + dist x y := dist_triangle _ _ _\n    _ < Œµ‚ÇÅ + dist x y := add_lt_add_right (mem_ball.1 hz) _\n    _ ‚â§ Œµ‚ÇÇ := h\n\n"}
{"name":"Metric.closedBall_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LE.le Œµ‚ÇÅ Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.closedBall x Œµ‚ÇÅ) (Metric.closedBall x Œµ‚ÇÇ)","decl":"@[gcongr]\ntheorem closedBall_subset_closedBall (h : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) : closedBall x Œµ‚ÇÅ ‚äÜ closedBall x Œµ‚ÇÇ :=\n  fun _y (yx : _ ‚â§ Œµ‚ÇÅ) => le_trans yx h\n\n"}
{"name":"Metric.closedBall_subset_closedBall'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LE.le (HAdd.hAdd Œµ‚ÇÅ (Dist.dist x y)) Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.closedBall x Œµ‚ÇÅ) (Metric.closedBall y Œµ‚ÇÇ)","decl":"theorem closedBall_subset_closedBall' (h : Œµ‚ÇÅ + dist x y ‚â§ Œµ‚ÇÇ) :\n    closedBall x Œµ‚ÇÅ ‚äÜ closedBall y Œµ‚ÇÇ := fun z hz =>\n  calc\n    dist z y ‚â§ dist z x + dist x y := dist_triangle _ _ _\n    _ ‚â§ Œµ‚ÇÅ + dist x y := add_le_add_right (mem_closedBall.1 hz) _\n    _ ‚â§ Œµ‚ÇÇ := h\n\n"}
{"name":"Metric.closedBall_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LT.lt Œµ‚ÇÅ Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.closedBall x Œµ‚ÇÅ) (Metric.ball x Œµ‚ÇÇ)","decl":"theorem closedBall_subset_ball (h : Œµ‚ÇÅ < Œµ‚ÇÇ) : closedBall x Œµ‚ÇÅ ‚äÜ ball x Œµ‚ÇÇ :=\n  fun y (yh : dist y x ‚â§ Œµ‚ÇÅ) => lt_of_le_of_lt yh h\n\n"}
{"name":"Metric.closedBall_subset_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LT.lt (HAdd.hAdd Œµ‚ÇÅ (Dist.dist x y)) Œµ‚ÇÇ\n‚ä¢ HasSubset.Subset (Metric.closedBall x Œµ‚ÇÅ) (Metric.ball y Œµ‚ÇÇ)","decl":"theorem closedBall_subset_ball' (h : Œµ‚ÇÅ + dist x y < Œµ‚ÇÇ) :\n    closedBall x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ := fun z hz =>\n  calc\n    dist z y ‚â§ dist z x + dist x y := dist_triangle _ _ _\n    _ ‚â§ Œµ‚ÇÅ + dist x y := add_le_add_right (mem_closedBall.1 hz) _\n    _ < Œµ‚ÇÇ := h\n\n"}
{"name":"Metric.dist_le_add_of_nonempty_closedBall_inter_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : (Inter.inter (Metric.closedBall x Œµ‚ÇÅ) (Metric.closedBall y Œµ‚ÇÇ)).Nonempty\n‚ä¢ LE.le (Dist.dist x y) (HAdd.hAdd Œµ‚ÇÅ Œµ‚ÇÇ)","decl":"theorem dist_le_add_of_nonempty_closedBall_inter_closedBall\n    (h : (closedBall x Œµ‚ÇÅ ‚à© closedBall y Œµ‚ÇÇ).Nonempty) : dist x y ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ :=\n  let ‚ü®z, hz‚ü© := h\n  calc\n    dist x y ‚â§ dist z x + dist z y := dist_triangle_left _ _ _\n    _ ‚â§ Œµ‚ÇÅ + Œµ‚ÇÇ := add_le_add hz.1 hz.2\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_closedBall_inter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : (Inter.inter (Metric.closedBall x Œµ‚ÇÅ) (Metric.ball y Œµ‚ÇÇ)).Nonempty\n‚ä¢ LT.lt (Dist.dist x y) (HAdd.hAdd Œµ‚ÇÅ Œµ‚ÇÇ)","decl":"theorem dist_lt_add_of_nonempty_closedBall_inter_ball (h : (closedBall x Œµ‚ÇÅ ‚à© ball y Œµ‚ÇÇ).Nonempty) :\n    dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ :=\n  let ‚ü®z, hz‚ü© := h\n  calc\n    dist x y ‚â§ dist z x + dist z y := dist_triangle_left _ _ _\n    _ < Œµ‚ÇÅ + Œµ‚ÇÇ := add_lt_add_of_le_of_lt hz.1 hz.2\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_ball_inter_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : (Inter.inter (Metric.ball x Œµ‚ÇÅ) (Metric.closedBall y Œµ‚ÇÇ)).Nonempty\n‚ä¢ LT.lt (Dist.dist x y) (HAdd.hAdd Œµ‚ÇÅ Œµ‚ÇÇ)","decl":"theorem dist_lt_add_of_nonempty_ball_inter_closedBall (h : (ball x Œµ‚ÇÅ ‚à© closedBall y Œµ‚ÇÇ).Nonempty) :\n    dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ := by\n  rw [inter_comm] at h\n  rw [add_comm, dist_comm]\n  exact dist_lt_add_of_nonempty_closedBall_inter_ball h\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_ball_inter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : (Inter.inter (Metric.ball x Œµ‚ÇÅ) (Metric.ball y Œµ‚ÇÇ)).Nonempty\n‚ä¢ LT.lt (Dist.dist x y) (HAdd.hAdd Œµ‚ÇÅ Œµ‚ÇÇ)","decl":"theorem dist_lt_add_of_nonempty_ball_inter_ball (h : (ball x Œµ‚ÇÅ ‚à© ball y Œµ‚ÇÇ).Nonempty) :\n    dist x y < Œµ‚ÇÅ + Œµ‚ÇÇ :=\n  dist_lt_add_of_nonempty_closedBall_inter_ball <|\n    h.mono (inter_subset_inter ball_subset_closedBall Subset.rfl)\n\n"}
{"name":"Metric.iUnion_closedBall_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (Set.iUnion fun n => Metric.closedBall x ‚Üën) Set.univ","decl":"@[simp]\ntheorem iUnion_closedBall_nat (x : Œ±) : ‚ãÉ n : ‚Ñï, closedBall x n = univ :=\n  iUnion_eq_univ_iff.2 fun y => exists_nat_ge (dist y x)\n\n"}
{"name":"Metric.iUnion_inter_closedBall_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nx : Œ±\n‚ä¢ Eq (Set.iUnion fun n => Inter.inter s (Metric.closedBall x ‚Üën)) s","decl":"theorem iUnion_inter_closedBall_nat (s : Set Œ±) (x : Œ±) : ‚ãÉ n : ‚Ñï, s ‚à© closedBall x n = s := by\n  rw [‚Üê inter_iUnion, iUnion_closedBall_nat, inter_univ]\n\n"}
{"name":"Metric.ball_subset","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ‚ÇÅ Œµ‚ÇÇ : Real\nh : LE.le (Dist.dist x y) (HSub.hSub Œµ‚ÇÇ Œµ‚ÇÅ)\n‚ä¢ HasSubset.Subset (Metric.ball x Œµ‚ÇÅ) (Metric.ball y Œµ‚ÇÇ)","decl":"theorem ball_subset (h : dist x y ‚â§ Œµ‚ÇÇ - Œµ‚ÇÅ) : ball x Œµ‚ÇÅ ‚äÜ ball y Œµ‚ÇÇ := fun z zx => by\n  rw [‚Üê add_sub_cancel Œµ‚ÇÅ Œµ‚ÇÇ]\n  exact lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)\n\n"}
{"name":"Metric.ball_half_subset","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\ny : Œ±\nh : Membership.mem (Metric.ball x (HDiv.hDiv Œµ 2)) y\n‚ä¢ HasSubset.Subset (Metric.ball y (HDiv.hDiv Œµ 2)) (Metric.ball x Œµ)","decl":"theorem ball_half_subset (y) (h : y ‚àà ball x (Œµ / 2)) : ball y (Œµ / 2) ‚äÜ ball x Œµ :=\n  ball_subset <| by rw [sub_self_div_two]; exact le_of_lt h\n\n"}
{"name":"Metric.exists_ball_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y : Œ±\nŒµ : Real\nh : Membership.mem (Metric.ball x Œµ) y\n‚ä¢ Exists fun Œµ' => And (GT.gt Œµ' 0) (HasSubset.Subset (Metric.ball y Œµ') (Metric.ball x Œµ))","decl":"theorem exists_ball_subset_ball (h : y ‚àà ball x Œµ) : ‚àÉ Œµ' > 0, ball y Œµ' ‚äÜ ball x Œµ :=\n  ‚ü®_, sub_pos.2 h, ball_subset <| by rw [sub_sub_self]‚ü©\n\n"}
{"name":"Metric.forall_of_forall_mem_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\np : Œ± ‚Üí Prop\nx : Œ±\nH : Filter.Frequently (fun R => ‚àÄ (y : Œ±), Membership.mem (Metric.closedBall x R) y ‚Üí p y) Filter.atTop\ny : Œ±\n‚ä¢ p y","decl":"/-- If a property holds for all points in closed balls of arbitrarily large radii, then it holds for\nall points. -/\ntheorem forall_of_forall_mem_closedBall (p : Œ± ‚Üí Prop) (x : Œ±)\n    (H : ‚àÉ·∂† R : ‚Ñù in atTop, ‚àÄ y ‚àà closedBall x R, p y) (y : Œ±) : p y := by\n  obtain ‚ü®R, hR, h‚ü© : ‚àÉ R ‚â• dist y x, ‚àÄ z : Œ±, z ‚àà closedBall x R ‚Üí p z :=\n    frequently_iff.1 H (Ici_mem_atTop (dist y x))\n  exact h _ hR\n\n"}
{"name":"Metric.forall_of_forall_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\np : Œ± ‚Üí Prop\nx : Œ±\nH : Filter.Frequently (fun R => ‚àÄ (y : Œ±), Membership.mem (Metric.ball x R) y ‚Üí p y) Filter.atTop\ny : Œ±\n‚ä¢ p y","decl":"/-- If a property holds for all points in balls of arbitrarily large radii, then it holds for all\npoints. -/\ntheorem forall_of_forall_mem_ball (p : Œ± ‚Üí Prop) (x : Œ±)\n    (H : ‚àÉ·∂† R : ‚Ñù in atTop, ‚àÄ y ‚àà ball x R, p y) (y : Œ±) : p y := by\n  obtain ‚ü®R, hR, h‚ü© : ‚àÉ R > dist y x, ‚àÄ z : Œ±, z ‚àà ball x R ‚Üí p z :=\n    frequently_iff.1 H (Ioi_mem_atTop (dist y x))\n  exact h _ hR\n\n"}
{"name":"Metric.isBounded_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (Bornology.IsBounded s) (Exists fun C => ‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, Membership.mem s y ‚Üí LE.le (Dist.dist x y) C)","decl":"theorem isBounded_iff {s : Set Œ±} :\n    IsBounded s ‚Üî ‚àÉ C : ‚Ñù, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C := by\n  rw [isBounded_def, ‚Üê Filter.mem_sets, @PseudoMetricSpace.cobounded_sets Œ±, mem_setOf_eq,\n    compl_compl]\n\n"}
{"name":"Metric.isBounded_iff_eventually","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (Bornology.IsBounded s) (Filter.Eventually (fun C => ‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, Membership.mem s y ‚Üí LE.le (Dist.dist x y) C) Filter.atTop)","decl":"theorem isBounded_iff_eventually {s : Set Œ±} :\n    IsBounded s ‚Üî ‚àÄ·∂† C in atTop, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C :=\n  isBounded_iff.trans\n    ‚ü®fun ‚ü®C, h‚ü© => eventually_atTop.2 ‚ü®C, fun _C' hC' _x hx _y hy => (h hx hy).trans hC'‚ü©,\n      Eventually.exists‚ü©\n\n"}
{"name":"Metric.isBounded_iff_exists_ge","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nc : Real\n‚ä¢ Iff (Bornology.IsBounded s) (Exists fun C => And (LE.le c C) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, Membership.mem s y ‚Üí LE.le (Dist.dist x y) C))","decl":"theorem isBounded_iff_exists_ge {s : Set Œ±} (c : ‚Ñù) :\n    IsBounded s ‚Üî ‚àÉ C, c ‚â§ C ‚àß ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà s ‚Üí dist x y ‚â§ C :=\n  ‚ü®fun h => ((eventually_ge_atTop c).and (isBounded_iff_eventually.1 h)).exists, fun h =>\n    isBounded_iff.2 <| h.imp fun _ => And.right‚ü©\n\n"}
{"name":"Metric.isBounded_iff_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (Bornology.IsBounded s) (Exists fun C => ‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, Membership.mem s y ‚Üí LE.le (NNDist.nndist x y) C)","decl":"theorem isBounded_iff_nndist {s : Set Œ±} :\n    IsBounded s ‚Üî ‚àÉ C : ‚Ñù‚â•0, ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà s ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà s ‚Üí nndist x y ‚â§ C := by\n  simp only [isBounded_iff_exists_ge 0, NNReal.exists, ‚Üê NNReal.coe_le_coe, ‚Üê dist_nndist,\n    NNReal.coe_mk, exists_prop]\n\n"}
{"name":"Metric.toUniformSpace_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ Eq PseudoMetricSpace.toUniformSpace (UniformSpace.ofDist Dist.dist ‚ãØ ‚ãØ ‚ãØ)","decl":"theorem toUniformSpace_eq :\n    ‚ÄπPseudoMetricSpace Œ±‚Ä∫.toUniformSpace = .ofDist dist dist_self dist_comm dist_triangle :=\n  UniformSpace.ext PseudoMetricSpace.uniformity_dist\n\n"}
{"name":"Metric.uniformity_basis_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => setOf fun p => LT.lt (Dist.dist p.1 p.2) Œµ","decl":"theorem uniformity_basis_dist :\n    (ùì§ Œ±).HasBasis (fun Œµ : ‚Ñù => 0 < Œµ) fun Œµ => { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } := by\n  rw [toUniformSpace_eq]\n  exact UniformSpace.hasBasis_ofFun (exists_gt _) _ _ _ _ _\n\n"}
{"name":"Metric.mk_uniformity_basis","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒ≤ : Type u_3\np : Œ≤ ‚Üí Prop\nf : Œ≤ ‚Üí Real\nhf‚ÇÄ : ‚àÄ (i : Œ≤), p i ‚Üí LT.lt 0 (f i)\nhf : ‚àÄ ‚¶ÉŒµ : Real‚¶Ñ, LT.lt 0 Œµ ‚Üí Exists fun i => And (p i) (LE.le (f i) Œµ)\n‚ä¢ (uniformity Œ±).HasBasis p fun i => setOf fun p => LT.lt (Dist.dist p.1 p.2) (f i)","decl":"/-- Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `ùì§ Œ±`.\n\nFor specific bases see `uniformity_basis_dist`, `uniformity_basis_dist_inv_nat_succ`,\nand `uniformity_basis_dist_inv_nat_pos`. -/\nprotected theorem mk_uniformity_basis {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù}\n    (hf‚ÇÄ : ‚àÄ i, p i ‚Üí 0 < f i) (hf : ‚àÄ ‚¶ÉŒµ‚¶Ñ, 0 < Œµ ‚Üí ‚àÉ i, p i ‚àß f i ‚â§ Œµ) :\n    (ùì§ Œ±).HasBasis p fun i => { p : Œ± √ó Œ± | dist p.1 p.2 < f i } := by\n  refine ‚ü®fun s => uniformity_basis_dist.mem_iff.trans ?_‚ü©\n  constructor\n  ¬∑ rintro ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©\n    rcases hf Œµ‚ÇÄ with ‚ü®i, hi, H‚ü©\n    exact ‚ü®i, hi, fun x (hx : _ < _) => hŒµ <| lt_of_lt_of_le hx H‚ü©\n  ¬∑ exact fun ‚ü®i, hi, H‚ü© => ‚ü®f i, hf‚ÇÄ i hi, H‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_rat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun r => LT.lt 0 r) fun r => setOf fun p => LT.lt (Dist.dist p.1 p.2) ‚Üër","decl":"theorem uniformity_basis_dist_rat :\n    (ùì§ Œ±).HasBasis (fun r : ‚Ñö => 0 < r) fun r => { p : Œ± √ó Œ± | dist p.1 p.2 < r } :=\n  Metric.mk_uniformity_basis (fun _ => Rat.cast_pos.2) fun _Œµ hŒµ =>\n    let ‚ü®r, hr0, hrŒµ‚ü© := exists_rat_btwn hŒµ\n    ‚ü®r, Rat.cast_pos.1 hr0, hrŒµ.le‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_inv_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1))","decl":"theorem uniformity_basis_dist_inv_nat_succ :\n    (ùì§ Œ±).HasBasis (fun _ => True) fun n : ‚Ñï => { p : Œ± √ó Œ± | dist p.1 p.2 < 1 / (‚Üën + 1) } :=\n  Metric.mk_uniformity_basis (fun n _ => div_pos zero_lt_one <| Nat.cast_add_one_pos n) fun _Œµ Œµ0 =>\n    (exists_nat_one_div_lt Œµ0).imp fun _n hn => ‚ü®trivial, le_of_lt hn‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_inv_nat_pos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun n => LT.lt 0 n) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HDiv.hDiv 1 ‚Üën)","decl":"theorem uniformity_basis_dist_inv_nat_pos :\n    (ùì§ Œ±).HasBasis (fun n : ‚Ñï => 0 < n) fun n : ‚Ñï => { p : Œ± √ó Œ± | dist p.1 p.2 < 1 / ‚Üën } :=\n  Metric.mk_uniformity_basis (fun _ hn => div_pos zero_lt_one <| Nat.cast_pos.2 hn) fun _ Œµ0 =>\n    let ‚ü®n, hn‚ü© := exists_nat_one_div_lt Œµ0\n    ‚ü®n + 1, Nat.succ_pos n, mod_cast hn.le‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HPow.hPow r n)","decl":"theorem uniformity_basis_dist_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :\n    (ùì§ Œ±).HasBasis (fun _ : ‚Ñï => True) fun n : ‚Ñï => { p : Œ± √ó Œ± | dist p.1 p.2 < r ^ n } :=\n  Metric.mk_uniformity_basis (fun _ _ => pow_pos h0 _) fun _Œµ Œµ0 =>\n    let ‚ü®n, hn‚ü© := exists_pow_lt_of_lt_one Œµ0 h1\n    ‚ü®n, trivial, hn.le‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nR : Real\nhR : LT.lt 0 R\n‚ä¢ (uniformity Œ±).HasBasis (fun r => And (LT.lt 0 r) (LT.lt r R)) fun r => setOf fun p => LT.lt (Dist.dist p.1 p.2) r","decl":"theorem uniformity_basis_dist_lt {R : ‚Ñù} (hR : 0 < R) :\n    (ùì§ Œ±).HasBasis (fun r : ‚Ñù => 0 < r ‚àß r < R) fun r => { p : Œ± √ó Œ± | dist p.1 p.2 < r } :=\n  Metric.mk_uniformity_basis (fun _ => And.left) fun r hr =>\n    ‚ü®min r (R / 2), ‚ü®lt_min hr (half_pos hR), min_lt_iff.2 <| Or.inr (half_lt_self hR)‚ü©,\n      min_le_left _ _‚ü©\n\n"}
{"name":"Metric.mk_uniformity_basis_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒ≤ : Type u_3\np : Œ≤ ‚Üí Prop\nf : Œ≤ ‚Üí Real\nhf‚ÇÄ : ‚àÄ (x : Œ≤), p x ‚Üí LT.lt 0 (f x)\nhf : ‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun x => And (p x) (LE.le (f x) Œµ)\n‚ä¢ (uniformity Œ±).HasBasis p fun x => setOf fun p => LE.le (Dist.dist p.1 p.2) (f x)","decl":"/-- Given `f : Œ≤ ‚Üí ‚Ñù`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed neighborhoods of the diagonal of sizes `{f i | p i}`\nform a basis of `ùì§ Œ±`.\n\nCurrently we have only one specific basis `uniformity_basis_dist_le` based on this constructor.\nMore can be easily added if needed in the future. -/\nprotected theorem mk_uniformity_basis_le {Œ≤ : Type*} {p : Œ≤ ‚Üí Prop} {f : Œ≤ ‚Üí ‚Ñù}\n    (hf‚ÇÄ : ‚àÄ x, p x ‚Üí 0 < f x) (hf : ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ x, p x ‚àß f x ‚â§ Œµ) :\n    (ùì§ Œ±).HasBasis p fun x => { p : Œ± √ó Œ± | dist p.1 p.2 ‚â§ f x } := by\n  refine ‚ü®fun s => uniformity_basis_dist.mem_iff.trans ?_‚ü©\n  constructor\n  ¬∑ rintro ‚ü®Œµ, Œµ‚ÇÄ, hŒµ‚ü©\n    rcases exists_between Œµ‚ÇÄ with ‚ü®Œµ', hŒµ'‚ü©\n    rcases hf Œµ' hŒµ'.1 with ‚ü®i, hi, H‚ü©\n    exact ‚ü®i, hi, fun x (hx : _ ‚â§ _) => hŒµ <| lt_of_le_of_lt (le_trans hx H) hŒµ'.2‚ü©\n  ¬∑ exact fun ‚ü®i, hi, H‚ü© => ‚ü®f i, hf‚ÇÄ i hi, fun x (hx : _ < _) => H (mem_setOf.2 hx.le)‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ (uniformity Œ±).HasBasis (fun x => LT.lt 0 x) fun Œµ => setOf fun p => LE.le (Dist.dist p.1 p.2) Œµ","decl":"/-- Constant size closed neighborhoods of the diagonal form a basis\nof the uniformity filter. -/\ntheorem uniformity_basis_dist_le :\n    (ùì§ Œ±).HasBasis ((0 : ‚Ñù) < ¬∑) fun Œµ => { p : Œ± √ó Œ± | dist p.1 p.2 ‚â§ Œµ } :=\n  Metric.mk_uniformity_basis_le (fun _ => id) fun Œµ Œµ‚ÇÄ => ‚ü®Œµ, Œµ‚ÇÄ, le_refl Œµ‚ü©\n\n"}
{"name":"Metric.uniformity_basis_dist_le_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n‚ä¢ (uniformity Œ±).HasBasis (fun x => True) fun n => setOf fun p => LE.le (Dist.dist p.1 p.2) (HPow.hPow r n)","decl":"theorem uniformity_basis_dist_le_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :\n    (ùì§ Œ±).HasBasis (fun _ : ‚Ñï => True) fun n : ‚Ñï => { p : Œ± √ó Œ± | dist p.1 p.2 ‚â§ r ^ n } :=\n  Metric.mk_uniformity_basis_le (fun _ _ => pow_pos h0 _) fun _Œµ Œµ0 =>\n    let ‚ü®n, hn‚ü© := exists_pow_lt_of_lt_one Œµ0 h1\n    ‚ü®n, trivial, hn.le‚ü©\n\n"}
{"name":"Metric.mem_uniformity_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set (Prod Œ± Œ±)\n‚ä¢ Iff (Membership.mem (uniformity Œ±) s) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ ‚¶Éa b : Œ±‚¶Ñ, LT.lt (Dist.dist a b) Œµ ‚Üí Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_uniformity_dist {s : Set (Œ± √ó Œ±)} :\n    s ‚àà ùì§ Œ± ‚Üî ‚àÉ Œµ > 0, ‚àÄ ‚¶Éa b : Œ±‚¶Ñ, dist a b < Œµ ‚Üí (a, b) ‚àà s :=\n  uniformity_basis_dist.mem_uniformity_iff\n\n"}
{"name":"Metric.dist_mem_uniformity","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒµ : Real\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (uniformity Œ±) (setOf fun p => LT.lt (Dist.dist p.1 p.2) Œµ)","decl":"/-- A constant size neighborhood of the diagonal is an entourage. -/\ntheorem dist_mem_uniformity {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) : { p : Œ± √ó Œ± | dist p.1 p.2 < Œµ } ‚àà ùì§ Œ± :=\n  mem_uniformity_dist.2 ‚ü®Œµ, Œµ0, fun _ _ ‚Ü¶ id‚ü©\n\n"}
{"name":"Metric.uniformContinuous_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (UniformContinuous f) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éa b : Œ±‚¶Ñ, LT.lt (Dist.dist a b) Œ¥ ‚Üí LT.lt (Dist.dist (f a) (f b)) Œµ))","decl":"theorem uniformContinuous_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    UniformContinuous f ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éa b : Œ±‚¶Ñ, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=\n  uniformity_basis_dist.uniformContinuous_iff uniformity_basis_dist\n\n"}
{"name":"Metric.uniformContinuousOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (UniformContinuousOn f s) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí ‚àÄ (y : Œ±), Membership.mem s y ‚Üí LT.lt (Dist.dist x y) Œ¥ ‚Üí LT.lt (Dist.dist (f x) (f y)) Œµ))","decl":"theorem uniformContinuousOn_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    UniformContinuousOn f s ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, dist x y < Œ¥ ‚Üí dist (f x) (f y) < Œµ :=\n  Metric.uniformity_basis_dist.uniformContinuousOn_iff Metric.uniformity_basis_dist\n\n"}
{"name":"Metric.uniformContinuousOn_iff_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (UniformContinuousOn f s) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí ‚àÄ (y : Œ±), Membership.mem s y ‚Üí LE.le (Dist.dist x y) Œ¥ ‚Üí LE.le (Dist.dist (f x) (f y)) Œµ))","decl":"theorem uniformContinuousOn_iff_le [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    UniformContinuousOn f s ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÄ y ‚àà s, dist x y ‚â§ Œ¥ ‚Üí dist (f x) (f y) ‚â§ Œµ :=\n  Metric.uniformity_basis_dist_le.uniformContinuousOn_iff Metric.uniformity_basis_dist_le\n\n"}
{"name":"Metric.nhds_basis_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun x => LT.lt 0 x) (Metric.ball x)","decl":"theorem nhds_basis_ball : (ùìù x).HasBasis (0 < ¬∑) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_dist\n\n"}
{"name":"Metric.mem_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ Iff (Membership.mem (nhds x) s) (Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (Metric.ball x Œµ) s))","decl":"theorem mem_nhds_iff : s ‚àà ùìù x ‚Üî ‚àÉ Œµ > 0, ball x Œµ ‚äÜ s :=\n  nhds_basis_ball.mem_iff\n\n"}
{"name":"Metric.eventually_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun y => p y) (nhds x)) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ ‚¶Éy : Œ±‚¶Ñ, LT.lt (Dist.dist y x) Œµ ‚Üí p y))","decl":"theorem eventually_nhds_iff {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† y in ùìù x, p y) ‚Üî ‚àÉ Œµ > 0, ‚àÄ ‚¶Éy‚¶Ñ, dist y x < Œµ ‚Üí p y :=\n  mem_nhds_iff\n\n"}
{"name":"Metric.eventually_nhds_iff_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\np : Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun y => p y) (nhds x)) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (y : Œ±), Membership.mem (Metric.ball x Œµ) y ‚Üí p y))","decl":"theorem eventually_nhds_iff_ball {p : Œ± ‚Üí Prop} :\n    (‚àÄ·∂† y in ùìù x, p y) ‚Üî ‚àÉ Œµ > 0, ‚àÄ y ‚àà ball x Œµ, p y :=\n  mem_nhds_iff\n\n"}
{"name":"Metric.eventually_nhds_prod_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf : Filter Œπ\nx‚ÇÄ : Œ±\np : Prod Œ± Œπ ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod (nhds x‚ÇÄ) f)) (Exists fun Œµ => And (GT.gt Œµ 0) (Exists fun pa => And (Filter.Eventually (fun i => pa i) f) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, LT.lt (Dist.dist x x‚ÇÄ) Œµ ‚Üí ‚àÄ ‚¶Éi : Œπ‚¶Ñ, pa i ‚Üí p { fst := x, snd := i })))","decl":"/-- A version of `Filter.eventually_prod_iff` where the first filter consists of neighborhoods\nin a pseudo-metric space. -/\ntheorem eventually_nhds_prod_iff {f : Filter Œπ} {x‚ÇÄ : Œ±} {p : Œ± √ó Œπ ‚Üí Prop} :\n    (‚àÄ·∂† x in ùìù x‚ÇÄ √óÀ¢ f, p x) ‚Üî ‚àÉ Œµ > (0 : ‚Ñù), ‚àÉ pa : Œπ ‚Üí Prop, (‚àÄ·∂† i in f, pa i) ‚àß\n      ‚àÄ ‚¶Éx‚¶Ñ, dist x x‚ÇÄ < Œµ ‚Üí ‚àÄ ‚¶Éi‚¶Ñ, pa i ‚Üí p (x, i) := by\n  refine (nhds_basis_ball.prod f.basis_sets).eventually_iff.trans ?_\n  simp only [Prod.exists, forall_prod_set, id, mem_ball, and_assoc, exists_and_left, and_imp]\n  rfl\n\n"}
{"name":"Metric.eventually_prod_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf : Filter Œπ\nx‚ÇÄ : Œ±\np : Prod Œπ Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f (nhds x‚ÇÄ))) (Exists fun pa => And (Filter.Eventually (fun i => pa i) f) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ ‚¶Éi : Œπ‚¶Ñ, pa i ‚Üí ‚àÄ ‚¶Éx : Œ±‚¶Ñ, LT.lt (Dist.dist x x‚ÇÄ) Œµ ‚Üí p { fst := i, snd := x })))","decl":"/-- A version of `Filter.eventually_prod_iff` where the second filter consists of neighborhoods\nin a pseudo-metric space. -/\ntheorem eventually_prod_nhds_iff {f : Filter Œπ} {x‚ÇÄ : Œ±} {p : Œπ √ó Œ± ‚Üí Prop} :\n    (‚àÄ·∂† x in f √óÀ¢ ùìù x‚ÇÄ, p x) ‚Üî ‚àÉ pa : Œπ ‚Üí Prop, (‚àÄ·∂† i in f, pa i) ‚àß\n      ‚àÉ Œµ > 0, ‚àÄ ‚¶Éi‚¶Ñ, pa i ‚Üí ‚àÄ ‚¶Éx‚¶Ñ, dist x x‚ÇÄ < Œµ ‚Üí p (i, x) := by\n  rw [eventually_swap_iff, Metric.eventually_nhds_prod_iff]\n  constructor <;>\n    ¬∑ rintro ‚ü®a1, a2, a3, a4, a5‚ü©\n      exact ‚ü®a3, a4, a1, a2, fun _ b1 b2 b3 => a5 b3 b1‚ü©\n\n"}
{"name":"Metric.nhds_basis_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun Œµ => LT.lt 0 Œµ) (Metric.closedBall x)","decl":"theorem nhds_basis_closedBall : (ùìù x).HasBasis (fun Œµ : ‚Ñù => 0 < Œµ) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_dist_le\n\n"}
{"name":"Metric.nhds_basis_ball_inv_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun x => True) fun n => Metric.ball x (HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1))","decl":"theorem nhds_basis_ball_inv_nat_succ :\n    (ùìù x).HasBasis (fun _ => True) fun n : ‚Ñï => ball x (1 / (‚Üën + 1)) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_succ\n\n"}
{"name":"Metric.nhds_basis_ball_inv_nat_pos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ (nhds x).HasBasis (fun n => LT.lt 0 n) fun n => Metric.ball x (HDiv.hDiv 1 ‚Üën)","decl":"theorem nhds_basis_ball_inv_nat_pos :\n    (ùìù x).HasBasis (fun n => 0 < n) fun n : ‚Ñï => ball x (1 / ‚Üën) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_pos\n\n"}
{"name":"Metric.nhds_basis_ball_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n‚ä¢ (nhds x).HasBasis (fun x => True) fun n => Metric.ball x (HPow.hPow r n)","decl":"theorem nhds_basis_ball_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :\n    (ùìù x).HasBasis (fun _ => True) fun n : ‚Ñï => ball x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_pow h0 h1)\n\n"}
{"name":"Metric.nhds_basis_closedBall_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n‚ä¢ (nhds x).HasBasis (fun x => True) fun n => Metric.closedBall x (HPow.hPow r n)","decl":"theorem nhds_basis_closedBall_pow {r : ‚Ñù} (h0 : 0 < r) (h1 : r < 1) :\n    (ùìù x).HasBasis (fun _ => True) fun n : ‚Ñï => closedBall x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_le_pow h0 h1)\n\n"}
{"name":"Metric.isOpen_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (IsOpen s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (Metric.ball x Œµ) s))","decl":"theorem isOpen_iff : IsOpen s ‚Üî ‚àÄ x ‚àà s, ‚àÉ Œµ > 0, ball x Œµ ‚äÜ s := by\n  simp only [isOpen_iff_mem_nhds, mem_nhds_iff]\n\n"}
{"name":"Metric.isOpen_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ IsOpen (Metric.ball x Œµ)","decl":"theorem isOpen_ball : IsOpen (ball x Œµ) :=\n  isOpen_iff.2 fun _ => exists_ball_subset_ball\n\n"}
{"name":"Metric.ball_mem_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (nhds x) (Metric.ball x Œµ)","decl":"theorem ball_mem_nhds (x : Œ±) {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) : ball x Œµ ‚àà ùìù x :=\n  isOpen_ball.mem_nhds (mem_ball_self Œµ0)\n\n"}
{"name":"Metric.closedBall_mem_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nŒµ0 : LT.lt 0 Œµ\n‚ä¢ Membership.mem (nhds x) (Metric.closedBall x Œµ)","decl":"theorem closedBall_mem_nhds (x : Œ±) {Œµ : ‚Ñù} (Œµ0 : 0 < Œµ) : closedBall x Œµ ‚àà ùìù x :=\n  mem_of_superset (ball_mem_nhds x Œµ0) ball_subset_closedBall\n\n"}
{"name":"Metric.closedBall_mem_nhds_of_mem","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx c : Œ±\nŒµ : Real\nh : Membership.mem (Metric.ball c Œµ) x\n‚ä¢ Membership.mem (nhds x) (Metric.closedBall c Œµ)","decl":"theorem closedBall_mem_nhds_of_mem {x c : Œ±} {Œµ : ‚Ñù} (h : x ‚àà ball c Œµ) : closedBall c Œµ ‚àà ùìù x :=\n  mem_of_superset (isOpen_ball.mem_nhds h) ball_subset_closedBall\n\n"}
{"name":"Metric.nhdsWithin_basis_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\ns : Set Œ±\n‚ä¢ (nhdsWithin x s).HasBasis (fun Œµ => LT.lt 0 Œµ) fun Œµ => Inter.inter (Metric.ball x Œµ) s","decl":"theorem nhdsWithin_basis_ball {s : Set Œ±} :\n    (ùìù[s] x).HasBasis (fun Œµ : ‚Ñù => 0 < Œµ) fun Œµ => ball x Œµ ‚à© s :=\n  nhdsWithin_hasBasis nhds_basis_ball s\n\n"}
{"name":"Metric.mem_nhdsWithin_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\ns t : Set Œ±\n‚ä¢ Iff (Membership.mem (nhdsWithin x t) s) (Exists fun Œµ => And (GT.gt Œµ 0) (HasSubset.Subset (Inter.inter (Metric.ball x Œµ) t) s))","decl":"theorem mem_nhdsWithin_iff {t : Set Œ±} : s ‚àà ùìù[t] x ‚Üî ‚àÉ Œµ > 0, ball x Œµ ‚à© t ‚äÜ s :=\n  nhdsWithin_basis_ball.mem_iff\n\n"}
{"name":"Metric.tendsto_nhdsWithin_nhdsWithin","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ns : Set Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nt : Set Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhdsWithin b t)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí LT.lt (Dist.dist x a) Œ¥ ‚Üí And (Membership.mem t (f x)) (LT.lt (Dist.dist (f x) b) Œµ)))","decl":"theorem tendsto_nhdsWithin_nhdsWithin [PseudoMetricSpace Œ≤] {t : Set Œ≤} {f : Œ± ‚Üí Œ≤} {a b} :\n    Tendsto f (ùìù[s] a) (ùìù[t] b) ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí f x ‚àà t ‚àß dist (f x) b < Œµ :=\n  (nhdsWithin_basis_ball.tendsto_iff nhdsWithin_basis_ball).trans <| by\n    simp only [inter_comm _ s, inter_comm _ t, mem_inter_iff, and_imp, gt_iff_lt, mem_ball]\n\n"}
{"name":"Metric.tendsto_nhdsWithin_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ns : Set Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhds b)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí LT.lt (Dist.dist x a) Œ¥ ‚Üí LT.lt (Dist.dist (f x) b) Œµ))","decl":"theorem tendsto_nhdsWithin_nhds [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a b} :\n    Tendsto f (ùìù[s] a) (ùìù b) ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí dist (f x) b < Œµ := by\n  rw [‚Üê nhdsWithin_univ b, tendsto_nhdsWithin_nhdsWithin]\n  simp only [mem_univ, true_and]\n\n"}
{"name":"Metric.tendsto_nhds_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\nb : Œ≤\n‚ä¢ Iff (Filter.Tendsto f (nhds a) (nhds b)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, LT.lt (Dist.dist x a) Œ¥ ‚Üí LT.lt (Dist.dist (f x) b) Œµ))","decl":"theorem tendsto_nhds_nhds [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a b} :\n    Tendsto f (ùìù a) (ùìù b) ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, dist x a < Œ¥ ‚Üí dist (f x) b < Œµ :=\n  nhds_basis_ball.tendsto_iff nhds_basis_ball\n\n"}
{"name":"Metric.continuousAt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\n‚ä¢ Iff (ContinuousAt f a) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, LT.lt (Dist.dist x a) Œ¥ ‚Üí LT.lt (Dist.dist (f x) (f a)) Œµ))","decl":"theorem continuousAt_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} :\n    ContinuousAt f a ‚Üî ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ := by\n  rw [ContinuousAt, tendsto_nhds_nhds]\n\n"}
{"name":"Metric.continuousWithinAt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\na : Œ±\ns : Set Œ±\n‚ä¢ Iff (ContinuousWithinAt f s a) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ ‚¶Éx : Œ±‚¶Ñ, Membership.mem s x ‚Üí LT.lt (Dist.dist x a) Œ¥ ‚Üí LT.lt (Dist.dist (f x) (f a)) Œµ))","decl":"theorem continuousWithinAt_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : Set Œ±} :\n    ContinuousWithinAt f s a ‚Üî\n      ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà s ‚Üí dist x a < Œ¥ ‚Üí dist (f x) (f a) < Œµ := by\n  rw [ContinuousWithinAt, tendsto_nhdsWithin_nhds]\n\n"}
{"name":"Metric.continuousOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\n‚ä¢ Iff (ContinuousOn f s) (‚àÄ (b : Œ±), Membership.mem s b ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (a : Œ±), Membership.mem s a ‚Üí LT.lt (Dist.dist a b) Œ¥ ‚Üí LT.lt (Dist.dist (f a) (f b)) Œµ))","decl":"theorem continuousOn_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±} :\n    ContinuousOn f s ‚Üî ‚àÄ b ‚àà s, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ a ‚àà s, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ := by\n  simp [ContinuousOn, continuousWithinAt_iff]\n\n"}
{"name":"Metric.continuous_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (Continuous f) (‚àÄ (b : Œ±) (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (a : Œ±), LT.lt (Dist.dist a b) Œ¥ ‚Üí LT.lt (Dist.dist (f a) (f b)) Œµ))","decl":"theorem continuous_iff [PseudoMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤} :\n    Continuous f ‚Üî ‚àÄ b, ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ a, dist a b < Œ¥ ‚Üí dist (f a) (f b) < Œµ :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds_nhds\n\n"}
{"name":"Metric.tendsto_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoMetricSpace Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u f (nhds a)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (Dist.dist (u x) a) Œµ) f)","decl":"theorem tendsto_nhds {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u f (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, dist (u x) a < Œµ :=\n  nhds_basis_ball.tendsto_right_iff\n\n"}
{"name":"Metric.continuousAt_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\n‚ä¢ Iff (ContinuousAt f b) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) Œµ) (nhds b))","decl":"theorem continuousAt_iff' [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} :\n    ContinuousAt f b ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù b, dist (f x) (f b) < Œµ := by\n  rw [ContinuousAt, tendsto_nhds]\n\n"}
{"name":"Metric.continuousWithinAt_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\nb : Œ≤\ns : Set Œ≤\n‚ä¢ Iff (ContinuousWithinAt f s b) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) Œµ) (nhdsWithin b s))","decl":"theorem continuousWithinAt_iff' [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : Set Œ≤} :\n    ContinuousWithinAt f s b ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù[s] b, dist (f x) (f b) < Œµ := by\n  rw [ContinuousWithinAt, tendsto_nhds]\n\n"}
{"name":"Metric.continuousOn_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\ns : Set Œ≤\n‚ä¢ Iff (ContinuousOn f s) (‚àÄ (b : Œ≤), Membership.mem s b ‚Üí ‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) Œµ) (nhdsWithin b s))","decl":"theorem continuousOn_iff' [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {s : Set Œ≤} :\n    ContinuousOn f s ‚Üî ‚àÄ b ‚àà s, ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù[s] b, dist (f x) (f b) < Œµ := by\n  simp [ContinuousOn, continuousWithinAt_iff']\n\n"}
{"name":"Metric.continuous_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Continuous f) (‚àÄ (a : Œ≤) (Œµ : Real), GT.gt Œµ 0 ‚Üí Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f a)) Œµ) (nhds a))","decl":"theorem continuous_iff' [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} :\n    Continuous f ‚Üî ‚àÄ (a), ‚àÄ Œµ > 0, ‚àÄ·∂† x in ùìù a, dist (f x) (f a) < Œµ :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds\n\n"}
{"name":"Metric.tendsto_atTop","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : Nonempty Œ≤\ninst‚úù : SemilatticeSup Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun N => ‚àÄ (n : Œ≤), GE.ge n N ‚Üí LT.lt (Dist.dist (u n) a) Œµ)","decl":"theorem tendsto_atTop [Nonempty Œ≤] [SemilatticeSup Œ≤] {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, dist (u n) a < Œµ :=\n  (atTop_basis.tendsto_iff nhds_basis_ball).trans <| by\n    simp only [true_and, mem_ball, mem_Ici]\n\n"}
{"name":"Metric.tendsto_atTop'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬≥ : PseudoMetricSpace Œ±\ninst‚úù¬≤ : Nonempty Œ≤\ninst‚úù¬π : SemilatticeSup Œ≤\ninst‚úù : NoMaxOrder Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun N => ‚àÄ (n : Œ≤), GT.gt n N ‚Üí LT.lt (Dist.dist (u n) a) Œµ)","decl":"/-- A variant of `tendsto_atTop` that\nuses `‚àÉ N, ‚àÄ n > N, ...` rather than `‚àÉ N, ‚àÄ n ‚â• N, ...`\n-/\ntheorem tendsto_atTop' [Nonempty Œ≤] [SemilatticeSup Œ≤] [NoMaxOrder Œ≤] {u : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    Tendsto u atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n > N, dist (u n) a < Œµ :=\n  (atTop_basis_Ioi.tendsto_iff nhds_basis_ball).trans <| by\n    simp only [true_and, gt_iff_lt, mem_Ioi, mem_ball]\n\n"}
{"name":"Metric.isOpen_singleton_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Iff (IsOpen (Singleton.singleton x)) (Exists fun Œµ => And (GT.gt Œµ 0) (‚àÄ (y : Œ±), LT.lt (Dist.dist y x) Œµ ‚Üí Eq y x))","decl":"theorem isOpen_singleton_iff {Œ± : Type*} [PseudoMetricSpace Œ±] {x : Œ±} :\n    IsOpen ({x} : Set Œ±) ‚Üî ‚àÉ Œµ > 0, ‚àÄ y, dist y x < Œµ ‚Üí y = x := by\n  simp [isOpen_iff, subset_singleton_iff, mem_ball]\n\n"}
{"name":"Dense.exists_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nhs : Dense s\nx : Œ±\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun y => And (Membership.mem s y) (LT.lt (Dist.dist x y) Œµ)","decl":"theorem _root_.Dense.exists_dist_lt {s : Set Œ±} (hs : Dense s) (x : Œ±) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ y ‚àà s, dist x y < Œµ := by\n  have : (ball x Œµ).Nonempty := by simp [hŒµ]\n  simpa only [mem_ball'] using hs.exists_mem_open isOpen_ball this\n\n"}
{"name":"DenseRange.exists_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nŒ≤ : Type u_3\nf : Œ≤ ‚Üí Œ±\nhf : DenseRange f\nx : Œ±\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun y => LT.lt (Dist.dist x (f y)) Œµ","decl":"nonrec theorem _root_.DenseRange.exists_dist_lt {Œ≤ : Type*} {f : Œ≤ ‚Üí Œ±} (hf : DenseRange f) (x : Œ±)\n    {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) : ‚àÉ y, dist x (f y) < Œµ :=\n  exists_range_iff.1 (hf.exists_dist_lt x hŒµ)\n\n"}
{"name":"Metric.uniformSpace_eq_bot","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ Iff (Eq PseudoMetricSpace.toUniformSpace Bot.bot) (Exists fun r => And (LT.lt 0 r) (Pairwise fun x1 x2 => LE.le r (Dist.dist x1 x2)))","decl":"/-- (Pseudo) metric space has discrete `UniformSpace` structure\niff the distances between distinct points are uniformly bounded away from zero. -/\nprotected lemma uniformSpace_eq_bot :\n    ‚ÄπPseudoMetricSpace Œ±‚Ä∫.toUniformSpace = ‚ä• ‚Üî\n      ‚àÉ r : ‚Ñù, 0 < r ‚àß Pairwise (r ‚â§ dist ¬∑ ¬∑ : Œ± ‚Üí Œ± ‚Üí Prop) := by\n  simp only [uniformity_basis_dist.uniformSpace_eq_bot, mem_setOf_eq, not_lt]\n\n"}
{"name":"DiscreteTopology.of_forall_le_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\nr : Real\nhpos : LT.lt 0 r\nhr : Pairwise fun x1 x2 => LE.le r (Dist.dist x1 x2)\n‚ä¢ DiscreteTopology Œ±","decl":"/-- If the distances between distinct points in a (pseudo) metric space\nare uniformly bounded away from zero, then the space has discrete topology. -/\nlemma DiscreteTopology.of_forall_le_dist {Œ±} [PseudoMetricSpace Œ±] {r : ‚Ñù} (hpos : 0 < r)\n    (hr : Pairwise (r ‚â§ dist ¬∑ ¬∑ : Œ± ‚Üí Œ± ‚Üí Prop)) : DiscreteTopology Œ± :=\n  ‚ü®by rw [Metric.uniformSpace_eq_bot.2 ‚ü®r, hpos, hr‚ü©, UniformSpace.toTopologicalSpace_bot]‚ü©\n\n/- Instantiate a pseudometric space as a pseudoemetric space. Before we can state the instance,\nwe need to show that the uniform structure coming from the edistance and the\ndistance coincide. -/\n\n"}
{"name":"Metric.uniformity_edist_aux","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nd : Œ± ‚Üí Œ± ‚Üí NNReal\n‚ä¢ Eq (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (‚Üë(d p.1 p.2)) Œµ)) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (‚Üë(d p.1 p.2)) Œµ))","decl":"theorem Metric.uniformity_edist_aux {Œ±} (d : Œ± ‚Üí Œ± ‚Üí ‚Ñù‚â•0) :\n    ‚®Ö Œµ > (0 : ‚Ñù), ùìü { p : Œ± √ó Œ± | ‚Üë(d p.1 p.2) < Œµ } =\n      ‚®Ö Œµ > (0 : ‚Ñù‚â•0‚àû), ùìü { p : Œ± √ó Œ± | ‚Üë(d p.1 p.2) < Œµ } := by\n  simp only [le_antisymm_iff, le_iInf_iff, le_principal_iff]\n  refine ‚ü®fun Œµ hŒµ => ?_, fun Œµ hŒµ => ?_‚ü©\n  ¬∑ rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hŒµ with ‚ü®Œµ', Œµ'0, Œµ'Œµ‚ü©\n    refine mem_iInf_of_mem (Œµ' : ‚Ñù) (mem_iInf_of_mem (ENNReal.coe_pos.1 Œµ'0) ?_)\n    exact fun x hx => lt_trans (ENNReal.coe_lt_coe.2 hx) Œµ'Œµ\n  ¬∑ lift Œµ to ‚Ñù‚â•0 using le_of_lt hŒµ\n    refine mem_iInf_of_mem (Œµ : ‚Ñù‚â•0‚àû) (mem_iInf_of_mem (ENNReal.coe_pos.2 hŒµ) ?_)\n    exact fun _ => ENNReal.coe_lt_coe.1\n\n"}
{"name":"Metric.uniformity_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (iInf fun Œµ => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) Œµ))","decl":"theorem Metric.uniformity_edist : ùì§ Œ± = ‚®Ö Œµ > 0, ùìü { p : Œ± √ó Œ± | edist p.1 p.2 < Œµ } := by\n  simp only [PseudoMetricSpace.uniformity_dist, dist_nndist, edist_nndist,\n    Metric.uniformity_edist_aux]\n\n-- see Note [lower instance priority]\n"}
{"name":"Metric.eball_top_eq_univ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.ball x Top.top) Set.univ","decl":"/-- In a pseudometric space, an open ball of infinite radius is the whole space -/\ntheorem Metric.eball_top_eq_univ (x : Œ±) : EMetric.ball x ‚àû = Set.univ :=\n  Set.eq_univ_iff_forall.mpr fun y => edist_lt_top y x\n\n"}
{"name":"Metric.emetric_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ Eq (EMetric.ball x (ENNReal.ofReal Œµ)) (Metric.ball x Œµ)","decl":"/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_ball {x : Œ±} {Œµ : ‚Ñù} : EMetric.ball x (ENNReal.ofReal Œµ) = ball x Œµ := by\n  ext y\n  simp only [EMetric.mem_ball, mem_ball, edist_dist]\n  exact ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg\n\n"}
{"name":"Metric.emetric_ball_nnreal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : NNReal\n‚ä¢ Eq (EMetric.ball x ‚ÜëŒµ) (Metric.ball x ‚ÜëŒµ)","decl":"/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_ball_nnreal {x : Œ±} {Œµ : ‚Ñù‚â•0} : EMetric.ball x Œµ = ball x Œµ := by\n  rw [‚Üê Metric.emetric_ball]\n  simp\n\n"}
{"name":"Metric.emetric_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\nh : LE.le 0 Œµ\n‚ä¢ Eq (EMetric.closedBall x (ENNReal.ofReal Œµ)) (Metric.closedBall x Œµ)","decl":"/-- Closed balls defined using the distance or the edistance coincide -/\ntheorem Metric.emetric_closedBall {x : Œ±} {Œµ : ‚Ñù} (h : 0 ‚â§ Œµ) :\n    EMetric.closedBall x (ENNReal.ofReal Œµ) = closedBall x Œµ := by\n  ext y; simp [edist_le_ofReal h]\n\n"}
{"name":"Metric.emetric_closedBall_nnreal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : NNReal\n‚ä¢ Eq (EMetric.closedBall x ‚ÜëŒµ) (Metric.closedBall x ‚ÜëŒµ)","decl":"/-- Closed balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_closedBall_nnreal {x : Œ±} {Œµ : ‚Ñù‚â•0} :\n    EMetric.closedBall x Œµ = closedBall x Œµ := by\n  rw [‚Üê Metric.emetric_closedBall Œµ.coe_nonneg, ENNReal.ofReal_coe_nnreal]\n\n"}
{"name":"Metric.emetric_ball_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\n‚ä¢ Eq (EMetric.ball x Top.top) Set.univ","decl":"@[simp]\ntheorem Metric.emetric_ball_top (x : Œ±) : EMetric.ball x ‚ä§ = univ :=\n  eq_univ_of_forall fun _ => edist_lt_top _ _\n\n"}
{"name":"PseudoMetricSpace.replaceUniformity_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nU : UniformSpace Œ±\nm : PseudoMetricSpace Œ±\nH : Eq (uniformity Œ±) (uniformity Œ±)\n‚ä¢ Eq (m.replaceUniformity H) m","decl":"theorem PseudoMetricSpace.replaceUniformity_eq {Œ±} [U : UniformSpace Œ±] (m : PseudoMetricSpace Œ±)\n    (H : ùì§[U] = ùì§[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m := by\n  ext\n  rfl\n\n-- ensure that the bornology is unchanged when replacing the uniformity.\n"}
{"name":"PseudoMetricSpace.replaceTopology_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ≥ : Type u_3\nU : TopologicalSpace Œ≥\nm : PseudoMetricSpace Œ≥\nH : Eq U UniformSpace.toTopologicalSpace\n‚ä¢ Eq (m.replaceTopology H) m","decl":"theorem PseudoMetricSpace.replaceTopology_eq {Œ≥} [U : TopologicalSpace Œ≥] (m : PseudoMetricSpace Œ≥)\n    (H : U = m.toUniformSpace.toTopologicalSpace) : m.replaceTopology H = m := by\n  ext\n  rfl\n\n"}
{"name":"PseudoMetricSpace.replaceBornology_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u_3\nm : PseudoMetricSpace Œ±\nB : Bornology Œ±\nH : ‚àÄ (s : Set Œ±), Iff (Bornology.IsBounded s) (Bornology.IsBounded s)\n‚ä¢ Eq (m.replaceBornology H) m","decl":"theorem PseudoMetricSpace.replaceBornology_eq {Œ±} [m : PseudoMetricSpace Œ±] [B : Bornology Œ±]\n    (H : ‚àÄ s, @IsBounded _ B s ‚Üî @IsBounded _ PseudoMetricSpace.toBornology s) :\n    PseudoMetricSpace.replaceBornology _ H = m := by\n  ext\n  rfl\n\n-- ensure that the uniformity is unchanged when replacing the bornology.\n"}
{"name":"Real.dist_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ Eq (Dist.dist x y) (abs (HSub.hSub x y))","decl":"theorem Real.dist_eq (x y : ‚Ñù) : dist x y = |x - y| := rfl\n\n"}
{"name":"Real.nndist_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ Eq (NNDist.nndist x y) (Real.nnabs (HSub.hSub x y))","decl":"theorem Real.nndist_eq (x y : ‚Ñù) : nndist x y = Real.nnabs (x - y) := rfl\n\n"}
{"name":"Real.nndist_eq'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ Eq (NNDist.nndist x y) (Real.nnabs (HSub.hSub y x))","decl":"theorem Real.nndist_eq' (x y : ‚Ñù) : nndist x y = Real.nnabs (y - x) :=\n  nndist_comm _ _\n\n"}
{"name":"Real.dist_0_eq_abs","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x : Real\n‚ä¢ Eq (Dist.dist x 0) (abs x)","decl":"theorem Real.dist_0_eq_abs (x : ‚Ñù) : dist x 0 = |x| := by simp [Real.dist_eq]\n\n"}
{"name":"Real.sub_le_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ LE.le (HSub.hSub x y) (Dist.dist x y)","decl":"theorem Real.sub_le_dist (x y : ‚Ñù) : x - y ‚â§ dist x y := by\n  rw [Real.dist_eq, le_abs]\n  exact Or.inl (le_refl _)\n\n"}
{"name":"Real.ball_eq_Ioo","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x r : Real\n‚ä¢ Eq (Metric.ball x r) (Set.Ioo (HSub.hSub x r) (HAdd.hAdd x r))","decl":"theorem Real.ball_eq_Ioo (x r : ‚Ñù) : ball x r = Ioo (x - r) (x + r) :=\n  Set.ext fun y => by\n    rw [mem_ball, dist_comm, Real.dist_eq, abs_sub_lt_iff, mem_Ioo, ‚Üê sub_lt_iff_lt_add',\n      sub_lt_comm]\n\n"}
{"name":"Real.closedBall_eq_Icc","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x r : Real\n‚ä¢ Eq (Metric.closedBall x r) (Set.Icc (HSub.hSub x r) (HAdd.hAdd x r))","decl":"theorem Real.closedBall_eq_Icc {x r : ‚Ñù} : closedBall x r = Icc (x - r) (x + r) := by\n  ext y\n  rw [mem_closedBall, dist_comm, Real.dist_eq, abs_sub_le_iff, mem_Icc, ‚Üê sub_le_iff_le_add',\n    sub_le_comm]\n\n"}
{"name":"Real.Ioo_eq_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ Eq (Set.Ioo x y) (Metric.ball (HDiv.hDiv (HAdd.hAdd x y) 2) (HDiv.hDiv (HSub.hSub y x) 2))","decl":"theorem Real.Ioo_eq_ball (x y : ‚Ñù) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.ball_eq_Ioo, ‚Üê sub_div, add_comm, ‚Üê sub_add, add_sub_cancel_left, add_self_div_two,\n    ‚Üê add_div, add_assoc, add_sub_cancel, add_self_div_two]\n\n"}
{"name":"Real.Icc_eq_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n‚ä¢ Eq (Set.Icc x y) (Metric.closedBall (HDiv.hDiv (HAdd.hAdd x y) 2) (HDiv.hDiv (HSub.hSub y x) 2))","decl":"theorem Real.Icc_eq_closedBall (x y : ‚Ñù) : Icc x y = closedBall ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.closedBall_eq_Icc, ‚Üê sub_div, add_comm, ‚Üê sub_add, add_sub_cancel_left, add_self_div_two,\n    ‚Üê add_div, add_assoc, add_sub_cancel, add_self_div_two]\n\n"}
{"name":"Metric.uniformity_eq_comap_nhds_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\n‚ä¢ Eq (uniformity Œ±) (Filter.comap (fun p => Dist.dist p.1 p.2) (nhds 0))","decl":"theorem Metric.uniformity_eq_comap_nhds_zero :\n    ùì§ Œ± = comap (fun p : Œ± √ó Œ± => dist p.1 p.2) (ùìù (0 : ‚Ñù)) := by\n  ext s\n  simp only [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff]\n  simp [subset_def, Real.dist_0_eq_abs]\n\n"}
{"name":"tendsto_uniformity_iff_dist_tendsto_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf : Œπ ‚Üí Prod Œ± Œ±\np : Filter Œπ\n‚ä¢ Iff (Filter.Tendsto f p (uniformity Œ±)) (Filter.Tendsto (fun x => Dist.dist (f x).1 (f x).2) p (nhds 0))","decl":"theorem tendsto_uniformity_iff_dist_tendsto_zero {f : Œπ ‚Üí Œ± √ó Œ±} {p : Filter Œπ} :\n    Tendsto f p (ùì§ Œ±) ‚Üî Tendsto (fun x => dist (f x).1 (f x).2) p (ùìù 0) := by\n  rw [Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.Tendsto.congr_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±\np : Filter Œπ\na : Œ±\nh‚ÇÅ : Filter.Tendsto f‚ÇÅ p (nhds a)\nh : Filter.Tendsto (fun x => Dist.dist (f‚ÇÅ x) (f‚ÇÇ x)) p (nhds 0)\n‚ä¢ Filter.Tendsto f‚ÇÇ p (nhds a)","decl":"theorem Filter.Tendsto.congr_dist {f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±} {p : Filter Œπ} {a : Œ±}\n    (h‚ÇÅ : Tendsto f‚ÇÅ p (ùìù a)) (h : Tendsto (fun x => dist (f‚ÇÅ x) (f‚ÇÇ x)) p (ùìù 0)) :\n    Tendsto f‚ÇÇ p (ùìù a) :=\n  h‚ÇÅ.congr_uniformity <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n\n"}
{"name":"tendsto_of_tendsto_of_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±\np : Filter Œπ\na : Œ±\nh‚ÇÅ : Filter.Tendsto f‚ÇÅ p (nhds a)\nh : Filter.Tendsto (fun x => Dist.dist (f‚ÇÅ x) (f‚ÇÇ x)) p (nhds 0)\n‚ä¢ Filter.Tendsto f‚ÇÇ p (nhds a)","decl":"alias tendsto_of_tendsto_of_dist := Filter.Tendsto.congr_dist\n\n"}
{"name":"tendsto_iff_of_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒπ : Type u_2\ninst‚úù : PseudoMetricSpace Œ±\nf‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±\np : Filter Œπ\na : Œ±\nh : Filter.Tendsto (fun x => Dist.dist (f‚ÇÅ x) (f‚ÇÇ x)) p (nhds 0)\n‚ä¢ Iff (Filter.Tendsto f‚ÇÅ p (nhds a)) (Filter.Tendsto f‚ÇÇ p (nhds a))","decl":"theorem tendsto_iff_of_dist {f‚ÇÅ f‚ÇÇ : Œπ ‚Üí Œ±} {p : Filter Œπ} {a : Œ±}\n    (h : Tendsto (fun x => dist (f‚ÇÅ x) (f‚ÇÇ x)) p (ùìù 0)) : Tendsto f‚ÇÅ p (ùìù a) ‚Üî Tendsto f‚ÇÇ p (ùìù a) :=\n  Uniform.tendsto_congr <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n\n"}
{"name":"PseudoMetricSpace.dist_eq_of_dist_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\nh : Eq (Dist.dist y z) 0\n‚ä¢ Eq (Dist.dist x y) (Dist.dist x z)","decl":"theorem PseudoMetricSpace.dist_eq_of_dist_zero (x : Œ±) {y z : Œ±} (h : dist y z = 0) :\n    dist x y = dist x z :=\n  dist_comm y x ‚ñ∏ dist_comm z x ‚ñ∏ sub_eq_zero.1 (abs_nonpos_iff.1 (h ‚ñ∏ abs_dist_sub_le y z x))\n\n-- Porting note: 3 new lemmas\n"}
{"name":"dist_dist_dist_le_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist (Dist.dist x z) (Dist.dist y z)) (Dist.dist x y)","decl":"theorem dist_dist_dist_le_left (x y z : Œ±) : dist (dist x z) (dist y z) ‚â§ dist x y :=\n  abs_dist_sub_le ..\n\n"}
{"name":"dist_dist_dist_le_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y z : Œ±\n‚ä¢ LE.le (Dist.dist (Dist.dist x y) (Dist.dist x z)) (Dist.dist y z)","decl":"theorem dist_dist_dist_le_right (x y z : Œ±) : dist (dist x y) (dist x z) ‚â§ dist y z := by\n  simpa only [dist_comm x] using dist_dist_dist_le_left y z x\n\n"}
{"name":"dist_dist_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx y x' y' : Œ±\n‚ä¢ LE.le (Dist.dist (Dist.dist x y) (Dist.dist x' y')) (HAdd.hAdd (Dist.dist x x') (Dist.dist y y'))","decl":"theorem dist_dist_dist_le (x y x' y' : Œ±) : dist (dist x y) (dist x' y') ‚â§ dist x x' + dist y y' :=\n  (dist_triangle _ _ _).trans <|\n    add_le_add (dist_dist_dist_le_left _ _ _) (dist_dist_dist_le_right _ _ _)\n\n"}
{"name":"nhds_comap_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\na : Œ±\n‚ä¢ Eq (Filter.comap (fun x => Dist.dist x a) (nhds 0)) (nhds a)","decl":"theorem nhds_comap_dist (a : Œ±) : ((ùìù (0 : ‚Ñù)).comap (dist ¬∑ a)) = ùìù a := by\n  simp only [@nhds_eq_comap_uniformity Œ±, Metric.uniformity_eq_comap_nhds_zero, comap_comap,\n    Function.comp_def, dist_comm]\n\n"}
{"name":"tendsto_iff_dist_tendsto_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoMetricSpace Œ±\nf : Œ≤ ‚Üí Œ±\nx : Filter Œ≤\na : Œ±\n‚ä¢ Iff (Filter.Tendsto f x (nhds a)) (Filter.Tendsto (fun b => Dist.dist (f b) a) x (nhds 0))","decl":"theorem tendsto_iff_dist_tendsto_zero {f : Œ≤ ‚Üí Œ±} {x : Filter Œ≤} {a : Œ±} :\n    Tendsto f x (ùìù a) ‚Üî Tendsto (fun b => dist (f b) a) x (ùìù 0) := by\n  rw [‚Üê nhds_comap_dist a, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Metric.ball_subset_interior_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\nx : Œ±\nŒµ : Real\n‚ä¢ HasSubset.Subset (Metric.ball x Œµ) (interior (Metric.closedBall x Œµ))","decl":"theorem ball_subset_interior_closedBall : ball x Œµ ‚äÜ interior (closedBall x Œµ) :=\n  interior_maximal ball_subset_closedBall isOpen_ball\n\n"}
{"name":"Metric.mem_closure_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\na : Œ±\n‚ä¢ Iff (Membership.mem (closure s) a) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun b => And (Membership.mem s b) (LT.lt (Dist.dist a b) Œµ))","decl":"/-- Œµ-characterization of the closure in pseudometric spaces -/\ntheorem mem_closure_iff {s : Set Œ±} {a : Œ±} : a ‚àà closure s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist a b < Œµ :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball).trans <| by simp only [mem_ball, dist_comm]\n\n"}
{"name":"Metric.mem_closure_range_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoMetricSpace Œ±\ne : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Membership.mem (closure (Set.range e)) a) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun k => LT.lt (Dist.dist a (e k)) Œµ)","decl":"theorem mem_closure_range_iff {e : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    a ‚àà closure (range e) ‚Üî ‚àÄ Œµ > 0, ‚àÉ k : Œ≤, dist a (e k) < Œµ := by\n  simp only [mem_closure_iff, exists_range_iff]\n\n"}
{"name":"Metric.mem_closure_range_iff_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoMetricSpace Œ±\ne : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Iff (Membership.mem (closure (Set.range e)) a) (‚àÄ (n : Nat), Exists fun k => LT.lt (Dist.dist a (e k)) (HDiv.hDiv 1 (HAdd.hAdd (‚Üën) 1)))","decl":"theorem mem_closure_range_iff_nat {e : Œ≤ ‚Üí Œ±} {a : Œ±} :\n    a ‚àà closure (range e) ‚Üî ‚àÄ n : ‚Ñï, ‚àÉ k : Œ≤, dist a (e k) < 1 / ((n : ‚Ñù) + 1) :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball_inv_nat_succ).trans <| by\n    simp only [mem_ball, dist_comm, exists_range_iff, forall_const]\n\n"}
{"name":"Metric.mem_of_closed'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nhs : IsClosed s\na : Œ±\n‚ä¢ Iff (Membership.mem s a) (‚àÄ (Œµ : Real), GT.gt Œµ 0 ‚Üí Exists fun b => And (Membership.mem s b) (LT.lt (Dist.dist a b) Œµ))","decl":"theorem mem_of_closed' {s : Set Œ±} (hs : IsClosed s) {a : Œ±} :\n    a ‚àà s ‚Üî ‚àÄ Œµ > 0, ‚àÉ b ‚àà s, dist a b < Œµ := by\n  simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a\n\n"}
{"name":"Metric.dense_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (Dense s) (‚àÄ (x : Œ±) (r : Real), GT.gt r 0 ‚Üí (Inter.inter (Metric.ball x r) s).Nonempty)","decl":"theorem dense_iff {s : Set Œ±} : Dense s ‚Üî ‚àÄ x, ‚àÄ r > 0, (ball x r ‚à© s).Nonempty :=\n  forall_congr' fun x => by\n    simp only [mem_closure_iff, Set.Nonempty, exists_prop, mem_inter_iff, mem_ball', and_comm]\n\n"}
{"name":"Metric.dense_iff_iUnion_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\n‚ä¢ Iff (Dense s) (‚àÄ (r : Real), GT.gt r 0 ‚Üí Eq (Set.iUnion fun c => Set.iUnion fun h => Metric.ball c r) Set.univ)","decl":"theorem dense_iff_iUnion_ball (s : Set Œ±) : Dense s ‚Üî ‚àÄ r > 0, ‚ãÉ c ‚àà s, ball c r = univ := by\n  simp_rw [eq_univ_iff_forall, mem_iUnion, exists_prop, mem_ball, Dense, mem_closure_iff,\n    forall_comm (Œ± := Œ±)]\n\n"}
{"name":"Metric.denseRange_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù : PseudoMetricSpace Œ±\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (DenseRange f) (‚àÄ (x : Œ±) (r : Real), GT.gt r 0 ‚Üí Exists fun y => LT.lt (Dist.dist x (f y)) r)","decl":"theorem denseRange_iff {f : Œ≤ ‚Üí Œ±} : DenseRange f ‚Üî ‚àÄ x, ‚àÄ r > 0, ‚àÉ y, dist x (f y) < r :=\n  forall_congr' fun x => by simp only [mem_closure_iff, exists_range_iff]\n\n"}
{"name":"ContinuousOn.isSeparable_image","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : ContinuousOn f s\nhs : TopologicalSpace.IsSeparable s\n‚ä¢ TopologicalSpace.IsSeparable (Set.image f s)","decl":"/-- If a map is continuous on a separable set `s`, then the image of `s` is also separable. -/\ntheorem _root_.ContinuousOn.isSeparable_image [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {s : Set Œ±}\n    (hf : ContinuousOn f s) (hs : IsSeparable s) : IsSeparable (f '' s) := by\n  rw [image_eq_range, ‚Üê image_univ]\n  exact (isSeparable_univ_iff.2 hs.separableSpace).image hf.restrict\n\n"}
{"name":"finite_cover_balls_of_compact","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nhs : IsCompact s\ne : Real\nhe : LT.lt 0 e\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x e)))","decl":"/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem finite_cover_balls_of_compact {Œ± : Type u} [PseudoMetricSpace Œ±] {s : Set Œ±}\n    (hs : IsCompact s) {e : ‚Ñù} (he : 0 < e) :\n    ‚àÉ t, t ‚äÜ s ‚àß Set.Finite t ‚àß s ‚äÜ ‚ãÉ x ‚àà t, ball x e :=\n  let ‚ü®t, hts, ht‚ü© := hs.elim_nhds_subcover _ (fun x _ => ball_mem_nhds x he)\n  ‚ü®t, hts, t.finite_toSet, ht‚ü©\n\n"}
{"name":"IsCompact.finite_cover_balls","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nhs : IsCompact s\ne : Real\nhe : LT.lt 0 e\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x e)))","decl":"alias IsCompact.finite_cover_balls := finite_cover_balls_of_compact\n\n"}
{"name":"lebesgue_number_lemma_of_metric","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nŒπ : Sort u_3\nc : Œπ ‚Üí Set Œ±\nhs : IsCompact s\nhc‚ÇÅ : ‚àÄ (i : Œπ), IsOpen (c i)\nhc‚ÇÇ : HasSubset.Subset s (Set.iUnion fun i => c i)\n‚ä¢ Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun i => HasSubset.Subset (Metric.ball x Œ¥) (c i))","decl":"theorem lebesgue_number_lemma_of_metric {s : Set Œ±} {Œπ : Sort*} {c : Œπ ‚Üí Set Œ±} (hs : IsCompact s)\n    (hc‚ÇÅ : ‚àÄ i, IsOpen (c i)) (hc‚ÇÇ : s ‚äÜ ‚ãÉ i, c i) : ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÉ i, ball x Œ¥ ‚äÜ c i := by\n  simpa only [ball, UniformSpace.ball, preimage_setOf_eq, dist_comm]\n    using uniformity_basis_dist.lebesgue_number_lemma hs hc‚ÇÅ hc‚ÇÇ\n\n"}
{"name":"lebesgue_number_lemma_of_metric_sUnion","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"Œ± : Type u\ninst‚úù : PseudoMetricSpace Œ±\ns : Set Œ±\nc : Set (Set Œ±)\nhs : IsCompact s\nhc‚ÇÅ : ‚àÄ (t : Set Œ±), Membership.mem c t ‚Üí IsOpen t\nhc‚ÇÇ : HasSubset.Subset s c.sUnion\n‚ä¢ Exists fun Œ¥ => And (GT.gt Œ¥ 0) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun t => And (Membership.mem c t) (HasSubset.Subset (Metric.ball x Œ¥) t))","decl":"theorem lebesgue_number_lemma_of_metric_sUnion {s : Set Œ±} {c : Set (Set Œ±)} (hs : IsCompact s)\n    (hc‚ÇÅ : ‚àÄ t ‚àà c, IsOpen t) (hc‚ÇÇ : s ‚äÜ ‚ãÉ‚ÇÄ c) : ‚àÉ Œ¥ > 0, ‚àÄ x ‚àà s, ‚àÉ t ‚àà c, ball x Œ¥ ‚äÜ t := by\n  rw [sUnion_eq_iUnion] at hc‚ÇÇ; simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc‚ÇÇ\n\n"}
