{"name":"UniformSpace.ofDist_aux","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"ε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ (x : Real), LT.lt x δ → ∀ (y : Real), LT.lt y δ → LT.lt (HAdd.hAdd x y) ε)","decl":"theorem UniformSpace.ofDist_aux (ε : ℝ) (hε : 0 < ε) : ∃ δ > (0 : ℝ), ∀ x < δ, ∀ y < δ, x + y < ε :=\n  ⟨ε / 2, half_pos hε, fun _x hx _y hy => add_halves ε ▸ add_lt_add hx hy⟩\n\n"}
{"name":"Dist.ext_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nx y : Dist α\n⊢ Iff (Eq x y) (Eq Dist.dist Dist.dist)","decl":"/-- The distance function (given an ambient metric space on `α`), which returns\n  a nonnegative real number `dist x y` given `x y : α`. -/\n@[ext]\nclass Dist (α : Type*) where\n  dist : α → α → ℝ\n\n"}
{"name":"Dist.ext","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nx y : Dist α\ndist : Eq Dist.dist Dist.dist\n⊢ Eq x y","decl":"/-- The distance function (given an ambient metric space on `α`), which returns\n  a nonnegative real number `dist x y` given `x y : α`. -/\n@[ext]\nclass Dist (α : Type*) where\n  dist : α → α → ℝ\n\n"}
{"name":"PseudoMetricSpace.cobounded_sets","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\n⊢ Eq (Bornology.cobounded α).sets (setOf fun s => Exists fun C => ∀ (x : α), Membership.mem (HasCompl.compl s) x → ∀ (y : α), Membership.mem (HasCompl.compl s) y → LE.le (Dist.dist x y) C)","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\nx : α\n⊢ Eq (Dist.dist x x) 0","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.uniformity_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\n⊢ Eq (uniformity α) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (Dist.dist p.1 p.2) ε))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.edist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\nx y : α\n⊢ Eq (PseudoMetricSpace.edist x y) (ENNReal.ofReal (Dist.dist x y))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.dist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nself : PseudoMetricSpace α\nx y : α\n⊢ Eq (Dist.dist x y) (Dist.dist y x)","decl":"/-- Pseudo metric and Metric spaces\n\nA pseudo metric space is endowed with a distance for which the requirement `d(x,y)=0 → x = y` might\nnot hold. A metric space is a pseudo metric space such that `d(x,y)=0 → x = y`.\nEach pseudo metric space induces a canonical `UniformSpace` and hence a canonical\n`TopologicalSpace` This is enforced in the type class definition, by extending the `UniformSpace`\nstructure. When instantiating a `PseudoMetricSpace` structure, the uniformity fields are not\nnecessary, they will be filled in by default. In the same way, each (pseudo) metric space induces a\n(pseudo) emetric space structure. It is included in the structure, but filled in by default.\n-/\nclass PseudoMetricSpace (α : Type u) extends Dist α : Type u where\n  dist_self : ∀ x : α, dist x x = 0\n  dist_comm : ∀ x y : α, dist x y = dist y x\n  dist_triangle : ∀ x y z : α, dist x z ≤ dist x y + dist y z\n  edist : α → α → ℝ≥0∞ := fun x y => ENNReal.ofNNReal ⟨dist x y, dist_nonneg' _ ‹_› ‹_› ‹_›⟩\n  edist_dist : ∀ x y : α, edist x y = ENNReal.ofReal (dist x y) := by\n    intros x y; exact ENNReal.coe_nnreal_eq _\n  toUniformSpace : UniformSpace α := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | dist p.1 p.2 < ε } := by intros; rfl\n  toBornology : Bornology α := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded α).sets =\n    { s | ∃ C : ℝ, ∀ x ∈ sᶜ, ∀ y ∈ sᶜ, dist x y ≤ C } := by intros; rfl\n\n"}
{"name":"PseudoMetricSpace.ext","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nm m' : PseudoMetricSpace α\nh : Eq PseudoMetricSpace.toDist PseudoMetricSpace.toDist\n⊢ Eq m m'","decl":"/-- Two pseudo metric space structures with the same distance function coincide. -/\n@[ext]\ntheorem PseudoMetricSpace.ext {α : Type*} {m m' : PseudoMetricSpace α}\n    (h : m.toDist = m'.toDist) : m = m' := by\n  cases' m with d _ _ _ ed hed U hU B hB\n  cases' m' with d' _ _ _ ed' hed' U' hU' B' hB'\n  obtain rfl : d = d' := h\n  congr\n  · ext x y : 2\n    rw [hed, hed']\n  · exact UniformSpace.ext (hU.trans hU'.symm)\n  · ext : 2\n    rw [← Filter.mem_sets, ← Filter.mem_sets, hB, hB']\n\n"}
{"name":"PseudoMetricSpace.ext_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nm m' : PseudoMetricSpace α\n⊢ Iff (Eq m m') (Eq PseudoMetricSpace.toDist PseudoMetricSpace.toDist)","decl":"/-- Two pseudo metric space structures with the same distance function coincide. -/\n@[ext]\ntheorem PseudoMetricSpace.ext {α : Type*} {m m' : PseudoMetricSpace α}\n    (h : m.toDist = m'.toDist) : m = m' := by\n  cases' m with d _ _ _ ed hed U hU B hB\n  cases' m' with d' _ _ _ ed' hed' U' hU' B' hB'\n  obtain rfl : d = d' := h\n  congr\n  · ext x y : 2\n    rw [hed, hed']\n  · exact UniformSpace.ext (hU.trans hU'.symm)\n  · ext : 2\n    rw [← Filter.mem_sets, ← Filter.mem_sets, hB, hB']\n\n"}
{"name":"dist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Dist.dist x x) 0","decl":"@[simp]\ntheorem dist_self (x : α) : dist x x = 0 :=\n  PseudoMetricSpace.dist_self x\n\n"}
{"name":"dist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Dist.dist x y) (Dist.dist y x)","decl":"theorem dist_comm (x y : α) : dist x y = dist y x :=\n  PseudoMetricSpace.dist_comm x y\n\n"}
{"name":"edist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (EDist.edist x y) (ENNReal.ofReal (Dist.dist x y))","decl":"theorem edist_dist (x y : α) : edist x y = ENNReal.ofReal (dist x y) :=\n  PseudoMetricSpace.edist_dist x y\n\n"}
{"name":"dist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist x z) (HAdd.hAdd (Dist.dist x y) (Dist.dist y z))","decl":"@[bound]\ntheorem dist_triangle (x y z : α) : dist x z ≤ dist x y + dist y z :=\n  PseudoMetricSpace.dist_triangle x y z\n\n"}
{"name":"dist_triangle_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist x y) (HAdd.hAdd (Dist.dist z x) (Dist.dist z y))","decl":"theorem dist_triangle_left (x y z : α) : dist x y ≤ dist z x + dist z y := by\n  rw [dist_comm z]; apply dist_triangle\n\n"}
{"name":"dist_triangle_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist x y) (HAdd.hAdd (Dist.dist x z) (Dist.dist y z))","decl":"theorem dist_triangle_right (x y z : α) : dist x y ≤ dist x z + dist y z := by\n  rw [dist_comm y]; apply dist_triangle\n\n"}
{"name":"dist_triangle4","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z w : α\n⊢ LE.le (Dist.dist x w) (HAdd.hAdd (HAdd.hAdd (Dist.dist x y) (Dist.dist y z)) (Dist.dist z w))","decl":"theorem dist_triangle4 (x y z w : α) : dist x w ≤ dist x y + dist y z + dist z w :=\n  calc\n    dist x w ≤ dist x z + dist z w := dist_triangle x z w\n    _ ≤ dist x y + dist y z + dist z w := add_le_add_right (dist_triangle x y z) _\n\n"}
{"name":"dist_triangle4_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx₁ y₁ x₂ y₂ : α\n⊢ LE.le (Dist.dist x₂ y₂) (HAdd.hAdd (Dist.dist x₁ y₁) (HAdd.hAdd (Dist.dist x₁ x₂) (Dist.dist y₁ y₂)))","decl":"theorem dist_triangle4_left (x₁ y₁ x₂ y₂ : α) :\n    dist x₂ y₂ ≤ dist x₁ y₁ + (dist x₁ x₂ + dist y₁ y₂) := by\n  rw [add_left_comm, dist_comm x₁, ← add_assoc]\n  apply dist_triangle4\n\n"}
{"name":"dist_triangle4_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx₁ y₁ x₂ y₂ : α\n⊢ LE.le (Dist.dist x₁ y₁) (HAdd.hAdd (HAdd.hAdd (Dist.dist x₁ x₂) (Dist.dist y₁ y₂)) (Dist.dist x₂ y₂))","decl":"theorem dist_triangle4_right (x₁ y₁ x₂ y₂ : α) :\n    dist x₁ y₁ ≤ dist x₁ x₂ + dist y₁ y₂ + dist x₂ y₂ := by\n  rw [add_right_comm, dist_comm y₁]\n  apply dist_triangle4\n\n"}
{"name":"swap_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Eq (Function.swap Dist.dist) Dist.dist","decl":"theorem swap_dist : Function.swap (@dist α _) = dist := by funext x y; exact dist_comm _ _\n\n"}
{"name":"abs_dist_sub_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (abs (HSub.hSub (Dist.dist x z) (Dist.dist y z))) (Dist.dist x y)","decl":"theorem abs_dist_sub_le (x y z : α) : |dist x z - dist y z| ≤ dist x y :=\n  abs_sub_le_iff.2\n    ⟨sub_le_iff_le_add.2 (dist_triangle _ _ _), sub_le_iff_le_add.2 (dist_triangle_left _ _ _)⟩\n\n"}
{"name":"dist_nonneg","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ LE.le 0 (Dist.dist x y)","decl":"@[bound]\ntheorem dist_nonneg {x y : α} : 0 ≤ dist x y :=\n  dist_nonneg' dist dist_self dist_comm dist_triangle\n\n"}
{"name":"abs_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\na b : α\n⊢ Eq (abs (Dist.dist a b)) (Dist.dist a b)","decl":"@[simp] theorem abs_dist {a b : α} : |dist a b| = dist a b := abs_of_nonneg dist_nonneg\n\n"}
{"name":"dist_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Dist.dist x y) ↑(NNDist.nndist x y)","decl":"/-- Express `dist` in terms of `nndist`-/\ntheorem dist_nndist (x y : α) : dist x y = nndist x y := rfl\n\n"}
{"name":"coe_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (↑(NNDist.nndist x y)) (Dist.dist x y)","decl":"@[simp, norm_cast]\ntheorem coe_nndist (x y : α) : ↑(nndist x y) = dist x y := rfl\n\n"}
{"name":"edist_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (EDist.edist x y) ↑(NNDist.nndist x y)","decl":"/-- Express `edist` in terms of `nndist`-/\ntheorem edist_nndist (x y : α) : edist x y = nndist x y := by\n  rw [edist_dist, dist_nndist, ENNReal.ofReal_coe_nnreal]\n\n"}
{"name":"nndist_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (NNDist.nndist x y) (EDist.edist x y).toNNReal","decl":"/-- Express `nndist` in terms of `edist`-/\ntheorem nndist_edist (x y : α) : nndist x y = (edist x y).toNNReal := by\n  simp [edist_nndist]\n\n"}
{"name":"coe_nnreal_ennreal_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (↑(NNDist.nndist x y)) (EDist.edist x y)","decl":"@[simp, norm_cast]\ntheorem coe_nnreal_ennreal_nndist (x y : α) : ↑(nndist x y) = edist x y :=\n  (edist_nndist x y).symm\n\n"}
{"name":"edist_lt_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nc : NNReal\n⊢ Iff (LT.lt (EDist.edist x y) ↑c) (LT.lt (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem edist_lt_coe {x y : α} {c : ℝ≥0} : edist x y < c ↔ nndist x y < c := by\n  rw [edist_nndist, ENNReal.coe_lt_coe]\n\n"}
{"name":"edist_le_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nc : NNReal\n⊢ Iff (LE.le (EDist.edist x y) ↑c) (LE.le (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem edist_le_coe {x y : α} {c : ℝ≥0} : edist x y ≤ c ↔ nndist x y ≤ c := by\n  rw [edist_nndist, ENNReal.coe_le_coe]\n\n"}
{"name":"edist_lt_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ LT.lt (EDist.edist x y) Top.top","decl":"/-- In a pseudometric space, the extended distance is always finite -/\ntheorem edist_lt_top {α : Type*} [PseudoMetricSpace α] (x y : α) : edist x y < ⊤ :=\n  (edist_dist x y).symm ▸ ENNReal.ofReal_lt_top\n\n"}
{"name":"edist_ne_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Ne (EDist.edist x y) Top.top","decl":"/-- In a pseudometric space, the extended distance is always finite -/\ntheorem edist_ne_top (x y : α) : edist x y ≠ ⊤ :=\n  (edist_lt_top x y).ne\n\n"}
{"name":"nndist_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\na : α\n⊢ Eq (NNDist.nndist a a) 0","decl":"/-- `nndist x x` vanishes -/\n@[simp] theorem nndist_self (a : α) : nndist a a = 0 := NNReal.coe_eq_zero.1 (dist_self a)\n\n-- Porting note: `dist_nndist` and `coe_nndist` moved up\n\n"}
{"name":"dist_lt_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nc : NNReal\n⊢ Iff (LT.lt (Dist.dist x y) ↑c) (LT.lt (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem dist_lt_coe {x y : α} {c : ℝ≥0} : dist x y < c ↔ nndist x y < c :=\n  Iff.rfl\n\n"}
{"name":"dist_le_coe","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nc : NNReal\n⊢ Iff (LE.le (Dist.dist x y) ↑c) (LE.le (NNDist.nndist x y) c)","decl":"@[simp, norm_cast]\ntheorem dist_le_coe {x y : α} {c : ℝ≥0} : dist x y ≤ c ↔ nndist x y ≤ c :=\n  Iff.rfl\n\n"}
{"name":"edist_lt_ofReal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nr : Real\n⊢ Iff (LT.lt (EDist.edist x y) (ENNReal.ofReal r)) (LT.lt (Dist.dist x y) r)","decl":"@[simp]\ntheorem edist_lt_ofReal {x y : α} {r : ℝ} : edist x y < ENNReal.ofReal r ↔ dist x y < r := by\n  rw [edist_dist, ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg]\n\n"}
{"name":"edist_le_ofReal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nr : Real\nhr : LE.le 0 r\n⊢ Iff (LE.le (EDist.edist x y) (ENNReal.ofReal r)) (LE.le (Dist.dist x y) r)","decl":"@[simp]\ntheorem edist_le_ofReal {x y : α} {r : ℝ} (hr : 0 ≤ r) :\n    edist x y ≤ ENNReal.ofReal r ↔ dist x y ≤ r := by\n  rw [edist_dist, ENNReal.ofReal_le_ofReal_iff hr]\n\n"}
{"name":"nndist_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (NNDist.nndist x y) (Dist.dist x y).toNNReal","decl":"/-- Express `nndist` in terms of `dist`-/\ntheorem nndist_dist (x y : α) : nndist x y = Real.toNNReal (dist x y) := by\n  rw [dist_nndist, Real.toNNReal_coe]\n\n"}
{"name":"nndist_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (NNDist.nndist x y) (NNDist.nndist y x)","decl":"theorem nndist_comm (x y : α) : nndist x y = nndist y x := NNReal.eq <| dist_comm x y\n\n"}
{"name":"nndist_triangle","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (NNDist.nndist x z) (HAdd.hAdd (NNDist.nndist x y) (NNDist.nndist y z))","decl":"/-- Triangle inequality for the nonnegative distance -/\ntheorem nndist_triangle (x y z : α) : nndist x z ≤ nndist x y + nndist y z :=\n  dist_triangle _ _ _\n\n"}
{"name":"nndist_triangle_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist z x) (NNDist.nndist z y))","decl":"theorem nndist_triangle_left (x y z : α) : nndist x y ≤ nndist z x + nndist z y :=\n  dist_triangle_left _ _ _\n\n"}
{"name":"nndist_triangle_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist x z) (NNDist.nndist y z))","decl":"theorem nndist_triangle_right (x y z : α) : nndist x y ≤ nndist x z + nndist y z :=\n  dist_triangle_right _ _ _\n\n"}
{"name":"dist_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Dist.dist x y) (EDist.edist x y).toReal","decl":"/-- Express `dist` in terms of `edist`-/\ntheorem dist_edist (x y : α) : dist x y = (edist x y).toReal := by\n  rw [edist_dist, ENNReal.toReal_ofReal dist_nonneg]\n\n"}
{"name":"Metric.mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.ball x ε) y) (LT.lt (Dist.dist y x) ε)","decl":"@[simp]\ntheorem mem_ball : y ∈ ball x ε ↔ dist y x < ε :=\n  Iff.rfl\n\n"}
{"name":"Metric.mem_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.ball x ε) y) (LT.lt (Dist.dist x y) ε)","decl":"theorem mem_ball' : y ∈ ball x ε ↔ dist x y < ε := by rw [dist_comm, mem_ball]\n\n"}
{"name":"Metric.pos_of_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\nhy : Membership.mem (Metric.ball x ε) y\n⊢ LT.lt 0 ε","decl":"theorem pos_of_mem_ball (hy : y ∈ ball x ε) : 0 < ε :=\n  dist_nonneg.trans_lt hy\n\n"}
{"name":"Metric.mem_ball_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nh : LT.lt 0 ε\n⊢ Membership.mem (Metric.ball x ε) x","decl":"theorem mem_ball_self (h : 0 < ε) : x ∈ ball x ε := by\n  rwa [mem_ball, dist_self]\n\n"}
{"name":"Metric.nonempty_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Iff (Metric.ball x ε).Nonempty (LT.lt 0 ε)","decl":"@[simp]\ntheorem nonempty_ball : (ball x ε).Nonempty ↔ 0 < ε :=\n  ⟨fun ⟨_x, hx⟩ => pos_of_mem_ball hx, fun h => ⟨x, mem_ball_self h⟩⟩\n\n"}
{"name":"Metric.ball_eq_empty","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Iff (Eq (Metric.ball x ε) EmptyCollection.emptyCollection) (LE.le ε 0)","decl":"@[simp]\ntheorem ball_eq_empty : ball x ε = ∅ ↔ ε ≤ 0 := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_ball, not_lt]\n\n"}
{"name":"Metric.ball_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Metric.ball x 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_zero : ball x 0 = ∅ := by rw [ball_eq_empty]\n\n"}
{"name":"Metric.exists_lt_mem_ball_of_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\nh : Membership.mem (Metric.ball y ε) x\n⊢ Exists fun ε' => And (LT.lt ε' ε) (Membership.mem (Metric.ball y ε') x)","decl":"/-- If a point belongs to an open ball, then there is a strictly smaller radius whose ball also\ncontains it.\n\nSee also `exists_lt_subset_ball`. -/\ntheorem exists_lt_mem_ball_of_mem_ball (h : x ∈ ball y ε) : ∃ ε' < ε, x ∈ ball y ε' := by\n  simp only [mem_ball] at h ⊢\n  exact ⟨(dist x y + ε) / 2, by linarith, by linarith⟩\n\n"}
{"name":"Metric.ball_eq_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nε : Real\nx : α\n⊢ Eq (UniformSpace.ball x (setOf fun p => LT.lt (Dist.dist p.2 p.1) ε)) (Metric.ball x ε)","decl":"theorem ball_eq_ball (ε : ℝ) (x : α) :\n    UniformSpace.ball x { p | dist p.2 p.1 < ε } = Metric.ball x ε :=\n  rfl\n\n"}
{"name":"Metric.ball_eq_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nε : Real\nx : α\n⊢ Eq (UniformSpace.ball x (setOf fun p => LT.lt (Dist.dist p.1 p.2) ε)) (Metric.ball x ε)","decl":"theorem ball_eq_ball' (ε : ℝ) (x : α) :\n    UniformSpace.ball x { p | dist p.1 p.2 < ε } = Metric.ball x ε := by\n  ext\n  simp [dist_comm, UniformSpace.ball]\n\n"}
{"name":"Metric.iUnion_ball_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Set.iUnion fun n => Metric.ball x ↑n) Set.univ","decl":"@[simp]\ntheorem iUnion_ball_nat (x : α) : ⋃ n : ℕ, ball x n = univ :=\n  iUnion_eq_univ_iff.2 fun y => exists_nat_gt (dist y x)\n\n"}
{"name":"Metric.iUnion_ball_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Set.iUnion fun n => Metric.ball x (HAdd.hAdd (↑n) 1)) Set.univ","decl":"@[simp]\ntheorem iUnion_ball_nat_succ (x : α) : ⋃ n : ℕ, ball x (n + 1) = univ :=\n  iUnion_eq_univ_iff.2 fun y => (exists_nat_gt (dist y x)).imp fun _ h => h.trans (lt_add_one _)\n\n"}
{"name":"Metric.mem_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.closedBall x ε) y) (LE.le (Dist.dist y x) ε)","decl":"@[simp] theorem mem_closedBall : y ∈ closedBall x ε ↔ dist y x ≤ ε := Iff.rfl\n\n"}
{"name":"Metric.mem_closedBall'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.closedBall x ε) y) (LE.le (Dist.dist x y) ε)","decl":"theorem mem_closedBall' : y ∈ closedBall x ε ↔ dist x y ≤ ε := by rw [dist_comm, mem_closedBall]\n\n"}
{"name":"Metric.mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.sphere x ε) y) (Eq (Dist.dist y x) ε)","decl":"@[simp] theorem mem_sphere : y ∈ sphere x ε ↔ dist y x = ε := Iff.rfl\n\n"}
{"name":"Metric.mem_sphere'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.sphere x ε) y) (Eq (Dist.dist x y) ε)","decl":"theorem mem_sphere' : y ∈ sphere x ε ↔ dist x y = ε := by rw [dist_comm, mem_sphere]\n\n"}
{"name":"Metric.ne_of_mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\nh : Membership.mem (Metric.sphere x ε) y\nhε : Ne ε 0\n⊢ Ne y x","decl":"theorem ne_of_mem_sphere (h : y ∈ sphere x ε) (hε : ε ≠ 0) : y ≠ x :=\n  ne_of_mem_of_not_mem h <| by simpa using hε.symm\n\n"}
{"name":"Metric.nonneg_of_mem_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\nhy : Membership.mem (Metric.sphere x ε) y\n⊢ LE.le 0 ε","decl":"theorem nonneg_of_mem_sphere (hy : y ∈ sphere x ε) : 0 ≤ ε :=\n  dist_nonneg.trans_eq hy\n\n"}
{"name":"Metric.sphere_eq_empty_of_neg","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nhε : LT.lt ε 0\n⊢ Eq (Metric.sphere x ε) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sphere_eq_empty_of_neg (hε : ε < 0) : sphere x ε = ∅ :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun _y hy => (nonneg_of_mem_sphere hy).not_lt hε\n\n"}
{"name":"Metric.sphere_eq_empty_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\nx : α\nε : Real\ninst✝ : Subsingleton α\nhε : Ne ε 0\n⊢ Eq (Metric.sphere x ε) EmptyCollection.emptyCollection","decl":"theorem sphere_eq_empty_of_subsingleton [Subsingleton α] (hε : ε ≠ 0) : sphere x ε = ∅ :=\n  Set.eq_empty_iff_forall_not_mem.mpr fun _ h => ne_of_mem_sphere h hε (Subsingleton.elim _ _)\n\n"}
{"name":"Metric.sphere_isEmpty_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\nx : α\nε : Real\ninst✝¹ : Subsingleton α\ninst✝ : NeZero ε\n⊢ IsEmpty ↑(Metric.sphere x ε)","decl":"instance sphere_isEmpty_of_subsingleton [Subsingleton α] [NeZero ε] : IsEmpty (sphere x ε) := by\n  rw [sphere_eq_empty_of_subsingleton (NeZero.ne ε)]; infer_instance\n\n"}
{"name":"Metric.closedBall_eq_singleton_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\nx : α\nε : Real\ninst✝ : Subsingleton α\nh : LE.le 0 ε\n⊢ Eq (Metric.closedBall x ε) (Singleton.singleton x)","decl":"theorem closedBall_eq_singleton_of_subsingleton [Subsingleton α] (h : 0 ≤ ε) :\n    closedBall x ε = {x} := by\n  ext x'\n  simpa [Subsingleton.allEq x x']\n\n"}
{"name":"Metric.ball_eq_singleton_of_subsingleton","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\nx : α\nε : Real\ninst✝ : Subsingleton α\nh : LT.lt 0 ε\n⊢ Eq (Metric.ball x ε) (Singleton.singleton x)","decl":"theorem ball_eq_singleton_of_subsingleton [Subsingleton α] (h : 0 < ε) : ball x ε = {x} := by\n  ext x'\n  simpa [Subsingleton.allEq x x']\n\n"}
{"name":"Metric.mem_closedBall_self","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nh : LE.le 0 ε\n⊢ Membership.mem (Metric.closedBall x ε) x","decl":"theorem mem_closedBall_self (h : 0 ≤ ε) : x ∈ closedBall x ε := by\n  rwa [mem_closedBall, dist_self]\n\n"}
{"name":"Metric.nonempty_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Iff (Metric.closedBall x ε).Nonempty (LE.le 0 ε)","decl":"@[simp]\ntheorem nonempty_closedBall : (closedBall x ε).Nonempty ↔ 0 ≤ ε :=\n  ⟨fun ⟨_x, hx⟩ => dist_nonneg.trans hx, fun h => ⟨x, mem_closedBall_self h⟩⟩\n\n"}
{"name":"Metric.closedBall_eq_empty","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Iff (Eq (Metric.closedBall x ε) EmptyCollection.emptyCollection) (LT.lt ε 0)","decl":"@[simp]\ntheorem closedBall_eq_empty : closedBall x ε = ∅ ↔ ε < 0 := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_closedBall, not_le]\n\n"}
{"name":"Metric.closedBall_eq_sphere_of_nonpos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nhε : LE.le ε 0\n⊢ Eq (Metric.closedBall x ε) (Metric.sphere x ε)","decl":"/-- Closed balls and spheres coincide when the radius is non-positive -/\ntheorem closedBall_eq_sphere_of_nonpos (hε : ε ≤ 0) : closedBall x ε = sphere x ε :=\n  Set.ext fun _ => (hε.trans dist_nonneg).le_iff_eq\n\n"}
{"name":"Metric.ball_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ HasSubset.Subset (Metric.ball x ε) (Metric.closedBall x ε)","decl":"theorem ball_subset_closedBall : ball x ε ⊆ closedBall x ε := fun _y hy =>\n  mem_closedBall.2 (le_of_lt hy)\n\n"}
{"name":"Metric.sphere_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ HasSubset.Subset (Metric.sphere x ε) (Metric.closedBall x ε)","decl":"theorem sphere_subset_closedBall : sphere x ε ⊆ closedBall x ε := fun _ => le_of_eq\n\n"}
{"name":"Metric.sphere_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr R : Real\nh : LT.lt r R\n⊢ HasSubset.Subset (Metric.sphere x r) (Metric.ball x R)","decl":"lemma sphere_subset_ball {r R : ℝ} (h : r < R) : sphere x r ⊆ ball x R := fun _x hx ↦\n  (mem_sphere.1 hx).trans_lt h\n\n"}
{"name":"Metric.closedBall_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nδ ε : Real\nh : LE.le (HAdd.hAdd δ ε) (Dist.dist x y)\n⊢ Disjoint (Metric.closedBall x δ) (Metric.ball y ε)","decl":"theorem closedBall_disjoint_ball (h : δ + ε ≤ dist x y) : Disjoint (closedBall x δ) (ball y ε) :=\n  Set.disjoint_left.mpr fun _a ha1 ha2 =>\n    (h.trans <| dist_triangle_left _ _ _).not_lt <| add_lt_add_of_le_of_lt ha1 ha2\n\n"}
{"name":"Metric.ball_disjoint_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nδ ε : Real\nh : LE.le (HAdd.hAdd δ ε) (Dist.dist x y)\n⊢ Disjoint (Metric.ball x δ) (Metric.closedBall y ε)","decl":"theorem ball_disjoint_closedBall (h : δ + ε ≤ dist x y) : Disjoint (ball x δ) (closedBall y ε) :=\n  (closedBall_disjoint_ball <| by rwa [add_comm, dist_comm]).symm\n\n"}
{"name":"Metric.ball_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nδ ε : Real\nh : LE.le (HAdd.hAdd δ ε) (Dist.dist x y)\n⊢ Disjoint (Metric.ball x δ) (Metric.ball y ε)","decl":"theorem ball_disjoint_ball (h : δ + ε ≤ dist x y) : Disjoint (ball x δ) (ball y ε) :=\n  (closedBall_disjoint_ball h).mono_left ball_subset_closedBall\n\n"}
{"name":"Metric.closedBall_disjoint_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nδ ε : Real\nh : LT.lt (HAdd.hAdd δ ε) (Dist.dist x y)\n⊢ Disjoint (Metric.closedBall x δ) (Metric.closedBall y ε)","decl":"theorem closedBall_disjoint_closedBall (h : δ + ε < dist x y) :\n    Disjoint (closedBall x δ) (closedBall y ε) :=\n  Set.disjoint_left.mpr fun _a ha1 ha2 =>\n    h.not_le <| (dist_triangle_left _ _ _).trans <| add_le_add ha1 ha2\n\n"}
{"name":"Metric.sphere_disjoint_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Disjoint (Metric.sphere x ε) (Metric.ball x ε)","decl":"theorem sphere_disjoint_ball : Disjoint (sphere x ε) (ball x ε) :=\n  Set.disjoint_left.mpr fun _y hy₁ hy₂ => absurd hy₁ <| ne_of_lt hy₂\n\n"}
{"name":"Metric.ball_union_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (Union.union (Metric.ball x ε) (Metric.sphere x ε)) (Metric.closedBall x ε)","decl":"@[simp]\ntheorem ball_union_sphere : ball x ε ∪ sphere x ε = closedBall x ε :=\n  Set.ext fun _y => (@le_iff_lt_or_eq ℝ _ _ _).symm\n\n"}
{"name":"Metric.sphere_union_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (Union.union (Metric.sphere x ε) (Metric.ball x ε)) (Metric.closedBall x ε)","decl":"@[simp]\ntheorem sphere_union_ball : sphere x ε ∪ ball x ε = closedBall x ε := by\n  rw [union_comm, ball_union_sphere]\n\n"}
{"name":"Metric.closedBall_diff_sphere","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (SDiff.sdiff (Metric.closedBall x ε) (Metric.sphere x ε)) (Metric.ball x ε)","decl":"@[simp]\ntheorem closedBall_diff_sphere : closedBall x ε \\ sphere x ε = ball x ε := by\n  rw [← ball_union_sphere, Set.union_diff_cancel_right sphere_disjoint_ball.symm.le_bot]\n\n"}
{"name":"Metric.closedBall_diff_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (SDiff.sdiff (Metric.closedBall x ε) (Metric.ball x ε)) (Metric.sphere x ε)","decl":"@[simp]\ntheorem closedBall_diff_ball : closedBall x ε \\ ball x ε = sphere x ε := by\n  rw [← ball_union_sphere, Set.union_diff_cancel_left sphere_disjoint_ball.symm.le_bot]\n\n"}
{"name":"Metric.mem_ball_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.ball y ε) x) (Membership.mem (Metric.ball x ε) y)","decl":"theorem mem_ball_comm : x ∈ ball y ε ↔ y ∈ ball x ε := by rw [mem_ball', mem_ball]\n\n"}
{"name":"Metric.mem_closedBall_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.closedBall y ε) x) (Membership.mem (Metric.closedBall x ε) y)","decl":"theorem mem_closedBall_comm : x ∈ closedBall y ε ↔ y ∈ closedBall x ε := by\n  rw [mem_closedBall', mem_closedBall]\n\n"}
{"name":"Metric.mem_sphere_comm","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\n⊢ Iff (Membership.mem (Metric.sphere y ε) x) (Membership.mem (Metric.sphere x ε) y)","decl":"theorem mem_sphere_comm : x ∈ sphere y ε ↔ y ∈ sphere x ε := by rw [mem_sphere', mem_sphere]\n\n"}
{"name":"Metric.ball_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε₁ ε₂ : Real\nh : LE.le ε₁ ε₂\n⊢ HasSubset.Subset (Metric.ball x ε₁) (Metric.ball x ε₂)","decl":"@[gcongr]\ntheorem ball_subset_ball (h : ε₁ ≤ ε₂) : ball x ε₁ ⊆ ball x ε₂ := fun _y yx =>\n  lt_of_lt_of_le (mem_ball.1 yx) h\n\n"}
{"name":"Metric.closedBall_eq_bInter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (Metric.closedBall x ε) (Set.iInter fun δ => Set.iInter fun h => Metric.ball x δ)","decl":"theorem closedBall_eq_bInter_ball : closedBall x ε = ⋂ δ > ε, ball x δ := by\n  ext y; rw [mem_closedBall, ← forall_lt_iff_le', mem_iInter₂]; rfl\n\n"}
{"name":"Metric.ball_subset_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : LE.le (HAdd.hAdd ε₁ (Dist.dist x y)) ε₂\n⊢ HasSubset.Subset (Metric.ball x ε₁) (Metric.ball y ε₂)","decl":"theorem ball_subset_ball' (h : ε₁ + dist x y ≤ ε₂) : ball x ε₁ ⊆ ball y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ < ε₁ + dist x y := add_lt_add_right (mem_ball.1 hz) _\n    _ ≤ ε₂ := h\n\n"}
{"name":"Metric.closedBall_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε₁ ε₂ : Real\nh : LE.le ε₁ ε₂\n⊢ HasSubset.Subset (Metric.closedBall x ε₁) (Metric.closedBall x ε₂)","decl":"@[gcongr]\ntheorem closedBall_subset_closedBall (h : ε₁ ≤ ε₂) : closedBall x ε₁ ⊆ closedBall x ε₂ :=\n  fun _y (yx : _ ≤ ε₁) => le_trans yx h\n\n"}
{"name":"Metric.closedBall_subset_closedBall'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : LE.le (HAdd.hAdd ε₁ (Dist.dist x y)) ε₂\n⊢ HasSubset.Subset (Metric.closedBall x ε₁) (Metric.closedBall y ε₂)","decl":"theorem closedBall_subset_closedBall' (h : ε₁ + dist x y ≤ ε₂) :\n    closedBall x ε₁ ⊆ closedBall y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ ≤ ε₁ + dist x y := add_le_add_right (mem_closedBall.1 hz) _\n    _ ≤ ε₂ := h\n\n"}
{"name":"Metric.closedBall_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε₁ ε₂ : Real\nh : LT.lt ε₁ ε₂\n⊢ HasSubset.Subset (Metric.closedBall x ε₁) (Metric.ball x ε₂)","decl":"theorem closedBall_subset_ball (h : ε₁ < ε₂) : closedBall x ε₁ ⊆ ball x ε₂ :=\n  fun y (yh : dist y x ≤ ε₁) => lt_of_le_of_lt yh h\n\n"}
{"name":"Metric.closedBall_subset_ball'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : LT.lt (HAdd.hAdd ε₁ (Dist.dist x y)) ε₂\n⊢ HasSubset.Subset (Metric.closedBall x ε₁) (Metric.ball y ε₂)","decl":"theorem closedBall_subset_ball' (h : ε₁ + dist x y < ε₂) :\n    closedBall x ε₁ ⊆ ball y ε₂ := fun z hz =>\n  calc\n    dist z y ≤ dist z x + dist x y := dist_triangle _ _ _\n    _ ≤ ε₁ + dist x y := add_le_add_right (mem_closedBall.1 hz) _\n    _ < ε₂ := h\n\n"}
{"name":"Metric.dist_le_add_of_nonempty_closedBall_inter_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : (Inter.inter (Metric.closedBall x ε₁) (Metric.closedBall y ε₂)).Nonempty\n⊢ LE.le (Dist.dist x y) (HAdd.hAdd ε₁ ε₂)","decl":"theorem dist_le_add_of_nonempty_closedBall_inter_closedBall\n    (h : (closedBall x ε₁ ∩ closedBall y ε₂).Nonempty) : dist x y ≤ ε₁ + ε₂ :=\n  let ⟨z, hz⟩ := h\n  calc\n    dist x y ≤ dist z x + dist z y := dist_triangle_left _ _ _\n    _ ≤ ε₁ + ε₂ := add_le_add hz.1 hz.2\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_closedBall_inter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : (Inter.inter (Metric.closedBall x ε₁) (Metric.ball y ε₂)).Nonempty\n⊢ LT.lt (Dist.dist x y) (HAdd.hAdd ε₁ ε₂)","decl":"theorem dist_lt_add_of_nonempty_closedBall_inter_ball (h : (closedBall x ε₁ ∩ ball y ε₂).Nonempty) :\n    dist x y < ε₁ + ε₂ :=\n  let ⟨z, hz⟩ := h\n  calc\n    dist x y ≤ dist z x + dist z y := dist_triangle_left _ _ _\n    _ < ε₁ + ε₂ := add_lt_add_of_le_of_lt hz.1 hz.2\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_ball_inter_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : (Inter.inter (Metric.ball x ε₁) (Metric.closedBall y ε₂)).Nonempty\n⊢ LT.lt (Dist.dist x y) (HAdd.hAdd ε₁ ε₂)","decl":"theorem dist_lt_add_of_nonempty_ball_inter_closedBall (h : (ball x ε₁ ∩ closedBall y ε₂).Nonempty) :\n    dist x y < ε₁ + ε₂ := by\n  rw [inter_comm] at h\n  rw [add_comm, dist_comm]\n  exact dist_lt_add_of_nonempty_closedBall_inter_ball h\n\n"}
{"name":"Metric.dist_lt_add_of_nonempty_ball_inter_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : (Inter.inter (Metric.ball x ε₁) (Metric.ball y ε₂)).Nonempty\n⊢ LT.lt (Dist.dist x y) (HAdd.hAdd ε₁ ε₂)","decl":"theorem dist_lt_add_of_nonempty_ball_inter_ball (h : (ball x ε₁ ∩ ball y ε₂).Nonempty) :\n    dist x y < ε₁ + ε₂ :=\n  dist_lt_add_of_nonempty_closedBall_inter_ball <|\n    h.mono (inter_subset_inter ball_subset_closedBall Subset.rfl)\n\n"}
{"name":"Metric.iUnion_closedBall_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Set.iUnion fun n => Metric.closedBall x ↑n) Set.univ","decl":"@[simp]\ntheorem iUnion_closedBall_nat (x : α) : ⋃ n : ℕ, closedBall x n = univ :=\n  iUnion_eq_univ_iff.2 fun y => exists_nat_ge (dist y x)\n\n"}
{"name":"Metric.iUnion_inter_closedBall_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\n⊢ Eq (Set.iUnion fun n => Inter.inter s (Metric.closedBall x ↑n)) s","decl":"theorem iUnion_inter_closedBall_nat (s : Set α) (x : α) : ⋃ n : ℕ, s ∩ closedBall x n = s := by\n  rw [← inter_iUnion, iUnion_closedBall_nat, inter_univ]\n\n"}
{"name":"Metric.ball_subset","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε₁ ε₂ : Real\nh : LE.le (Dist.dist x y) (HSub.hSub ε₂ ε₁)\n⊢ HasSubset.Subset (Metric.ball x ε₁) (Metric.ball y ε₂)","decl":"theorem ball_subset (h : dist x y ≤ ε₂ - ε₁) : ball x ε₁ ⊆ ball y ε₂ := fun z zx => by\n  rw [← add_sub_cancel ε₁ ε₂]\n  exact lt_of_le_of_lt (dist_triangle z x y) (add_lt_add_of_lt_of_le zx h)\n\n"}
{"name":"Metric.ball_half_subset","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\ny : α\nh : Membership.mem (Metric.ball x (HDiv.hDiv ε 2)) y\n⊢ HasSubset.Subset (Metric.ball y (HDiv.hDiv ε 2)) (Metric.ball x ε)","decl":"theorem ball_half_subset (y) (h : y ∈ ball x (ε / 2)) : ball y (ε / 2) ⊆ ball x ε :=\n  ball_subset <| by rw [sub_self_div_two]; exact le_of_lt h\n\n"}
{"name":"Metric.exists_ball_subset_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\nε : Real\nh : Membership.mem (Metric.ball x ε) y\n⊢ Exists fun ε' => And (GT.gt ε' 0) (HasSubset.Subset (Metric.ball y ε') (Metric.ball x ε))","decl":"theorem exists_ball_subset_ball (h : y ∈ ball x ε) : ∃ ε' > 0, ball y ε' ⊆ ball x ε :=\n  ⟨_, sub_pos.2 h, ball_subset <| by rw [sub_sub_self]⟩\n\n"}
{"name":"Metric.forall_of_forall_mem_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\np : α → Prop\nx : α\nH : Filter.Frequently (fun R => ∀ (y : α), Membership.mem (Metric.closedBall x R) y → p y) Filter.atTop\ny : α\n⊢ p y","decl":"/-- If a property holds for all points in closed balls of arbitrarily large radii, then it holds for\nall points. -/\ntheorem forall_of_forall_mem_closedBall (p : α → Prop) (x : α)\n    (H : ∃ᶠ R : ℝ in atTop, ∀ y ∈ closedBall x R, p y) (y : α) : p y := by\n  obtain ⟨R, hR, h⟩ : ∃ R ≥ dist y x, ∀ z : α, z ∈ closedBall x R → p z :=\n    frequently_iff.1 H (Ici_mem_atTop (dist y x))\n  exact h _ hR\n\n"}
{"name":"Metric.forall_of_forall_mem_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\np : α → Prop\nx : α\nH : Filter.Frequently (fun R => ∀ (y : α), Membership.mem (Metric.ball x R) y → p y) Filter.atTop\ny : α\n⊢ p y","decl":"/-- If a property holds for all points in balls of arbitrarily large radii, then it holds for all\npoints. -/\ntheorem forall_of_forall_mem_ball (p : α → Prop) (x : α)\n    (H : ∃ᶠ R : ℝ in atTop, ∀ y ∈ ball x R, p y) (y : α) : p y := by\n  obtain ⟨R, hR, h⟩ : ∃ R > dist y x, ∀ z : α, z ∈ ball x R → p z :=\n    frequently_iff.1 H (Ioi_mem_atTop (dist y x))\n  exact h _ hR\n\n"}
{"name":"Metric.isBounded_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Exists fun C => ∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → LE.le (Dist.dist x y) C)","decl":"theorem isBounded_iff {s : Set α} :\n    IsBounded s ↔ ∃ C : ℝ, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C := by\n  rw [isBounded_def, ← Filter.mem_sets, @PseudoMetricSpace.cobounded_sets α, mem_setOf_eq,\n    compl_compl]\n\n"}
{"name":"Metric.isBounded_iff_eventually","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Filter.Eventually (fun C => ∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → LE.le (Dist.dist x y) C) Filter.atTop)","decl":"theorem isBounded_iff_eventually {s : Set α} :\n    IsBounded s ↔ ∀ᶠ C in atTop, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C :=\n  isBounded_iff.trans\n    ⟨fun ⟨C, h⟩ => eventually_atTop.2 ⟨C, fun _C' hC' _x hx _y hy => (h hx hy).trans hC'⟩,\n      Eventually.exists⟩\n\n"}
{"name":"Metric.isBounded_iff_exists_ge","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nc : Real\n⊢ Iff (Bornology.IsBounded s) (Exists fun C => And (LE.le c C) (∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → LE.le (Dist.dist x y) C))","decl":"theorem isBounded_iff_exists_ge {s : Set α} (c : ℝ) :\n    IsBounded s ↔ ∃ C, c ≤ C ∧ ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → dist x y ≤ C :=\n  ⟨fun h => ((eventually_ge_atTop c).and (isBounded_iff_eventually.1 h)).exists, fun h =>\n    isBounded_iff.2 <| h.imp fun _ => And.right⟩\n\n"}
{"name":"Metric.isBounded_iff_nndist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Exists fun C => ∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → LE.le (NNDist.nndist x y) C)","decl":"theorem isBounded_iff_nndist {s : Set α} :\n    IsBounded s ↔ ∃ C : ℝ≥0, ∀ ⦃x⦄, x ∈ s → ∀ ⦃y⦄, y ∈ s → nndist x y ≤ C := by\n  simp only [isBounded_iff_exists_ge 0, NNReal.exists, ← NNReal.coe_le_coe, ← dist_nndist,\n    NNReal.coe_mk, exists_prop]\n\n"}
{"name":"Metric.toUniformSpace_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Eq PseudoMetricSpace.toUniformSpace (UniformSpace.ofDist Dist.dist ⋯ ⋯ ⋯)","decl":"theorem toUniformSpace_eq :\n    ‹PseudoMetricSpace α›.toUniformSpace = .ofDist dist dist_self dist_comm dist_triangle :=\n  UniformSpace.ext PseudoMetricSpace.uniformity_dist\n\n"}
{"name":"Metric.uniformity_basis_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ (uniformity α).HasBasis (fun ε => LT.lt 0 ε) fun ε => setOf fun p => LT.lt (Dist.dist p.1 p.2) ε","decl":"theorem uniformity_basis_dist :\n    (𝓤 α).HasBasis (fun ε : ℝ => 0 < ε) fun ε => { p : α × α | dist p.1 p.2 < ε } := by\n  rw [toUniformSpace_eq]\n  exact UniformSpace.hasBasis_ofFun (exists_gt _) _ _ _ _ _\n\n"}
{"name":"Metric.mk_uniformity_basis","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nβ : Type u_3\np : β → Prop\nf : β → Real\nhf₀ : ∀ (i : β), p i → LT.lt 0 (f i)\nhf : ∀ ⦃ε : Real⦄, LT.lt 0 ε → Exists fun i => And (p i) (LE.le (f i) ε)\n⊢ (uniformity α).HasBasis p fun i => setOf fun p => LT.lt (Dist.dist p.1 p.2) (f i)","decl":"/-- Given `f : β → ℝ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then `f i`-neighborhoods of the diagonal form a basis of `𝓤 α`.\n\nFor specific bases see `uniformity_basis_dist`, `uniformity_basis_dist_inv_nat_succ`,\nand `uniformity_basis_dist_inv_nat_pos`. -/\nprotected theorem mk_uniformity_basis {β : Type*} {p : β → Prop} {f : β → ℝ}\n    (hf₀ : ∀ i, p i → 0 < f i) (hf : ∀ ⦃ε⦄, 0 < ε → ∃ i, p i ∧ f i ≤ ε) :\n    (𝓤 α).HasBasis p fun i => { p : α × α | dist p.1 p.2 < f i } := by\n  refine ⟨fun s => uniformity_basis_dist.mem_iff.trans ?_⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases hf ε₀ with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x (hx : _ < _) => hε <| lt_of_lt_of_le hx H⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, H⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_rat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ (uniformity α).HasBasis (fun r => LT.lt 0 r) fun r => setOf fun p => LT.lt (Dist.dist p.1 p.2) ↑r","decl":"theorem uniformity_basis_dist_rat :\n    (𝓤 α).HasBasis (fun r : ℚ => 0 < r) fun r => { p : α × α | dist p.1 p.2 < r } :=\n  Metric.mk_uniformity_basis (fun _ => Rat.cast_pos.2) fun _ε hε =>\n    let ⟨r, hr0, hrε⟩ := exists_rat_btwn hε\n    ⟨r, Rat.cast_pos.1 hr0, hrε.le⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_inv_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ (uniformity α).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))","decl":"theorem uniformity_basis_dist_inv_nat_succ :\n    (𝓤 α).HasBasis (fun _ => True) fun n : ℕ => { p : α × α | dist p.1 p.2 < 1 / (↑n + 1) } :=\n  Metric.mk_uniformity_basis (fun n _ => div_pos zero_lt_one <| Nat.cast_add_one_pos n) fun _ε ε0 =>\n    (exists_nat_one_div_lt ε0).imp fun _n hn => ⟨trivial, le_of_lt hn⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_inv_nat_pos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ (uniformity α).HasBasis (fun n => LT.lt 0 n) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HDiv.hDiv 1 ↑n)","decl":"theorem uniformity_basis_dist_inv_nat_pos :\n    (𝓤 α).HasBasis (fun n : ℕ => 0 < n) fun n : ℕ => { p : α × α | dist p.1 p.2 < 1 / ↑n } :=\n  Metric.mk_uniformity_basis (fun _ hn => div_pos zero_lt_one <| Nat.cast_pos.2 hn) fun _ ε0 =>\n    let ⟨n, hn⟩ := exists_nat_one_div_lt ε0\n    ⟨n + 1, Nat.succ_pos n, mod_cast hn.le⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n⊢ (uniformity α).HasBasis (fun x => True) fun n => setOf fun p => LT.lt (Dist.dist p.1 p.2) (HPow.hPow r n)","decl":"theorem uniformity_basis_dist_pow {r : ℝ} (h0 : 0 < r) (h1 : r < 1) :\n    (𝓤 α).HasBasis (fun _ : ℕ => True) fun n : ℕ => { p : α × α | dist p.1 p.2 < r ^ n } :=\n  Metric.mk_uniformity_basis (fun _ _ => pow_pos h0 _) fun _ε ε0 =>\n    let ⟨n, hn⟩ := exists_pow_lt_of_lt_one ε0 h1\n    ⟨n, trivial, hn.le⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nR : Real\nhR : LT.lt 0 R\n⊢ (uniformity α).HasBasis (fun r => And (LT.lt 0 r) (LT.lt r R)) fun r => setOf fun p => LT.lt (Dist.dist p.1 p.2) r","decl":"theorem uniformity_basis_dist_lt {R : ℝ} (hR : 0 < R) :\n    (𝓤 α).HasBasis (fun r : ℝ => 0 < r ∧ r < R) fun r => { p : α × α | dist p.1 p.2 < r } :=\n  Metric.mk_uniformity_basis (fun _ => And.left) fun r hr =>\n    ⟨min r (R / 2), ⟨lt_min hr (half_pos hR), min_lt_iff.2 <| Or.inr (half_lt_self hR)⟩,\n      min_le_left _ _⟩\n\n"}
{"name":"Metric.mk_uniformity_basis_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nβ : Type u_3\np : β → Prop\nf : β → Real\nhf₀ : ∀ (x : β), p x → LT.lt 0 (f x)\nhf : ∀ (ε : Real), LT.lt 0 ε → Exists fun x => And (p x) (LE.le (f x) ε)\n⊢ (uniformity α).HasBasis p fun x => setOf fun p => LE.le (Dist.dist p.1 p.2) (f x)","decl":"/-- Given `f : β → ℝ`, if `f` sends `{i | p i}` to a set of positive numbers\naccumulating to zero, then closed neighborhoods of the diagonal of sizes `{f i | p i}`\nform a basis of `𝓤 α`.\n\nCurrently we have only one specific basis `uniformity_basis_dist_le` based on this constructor.\nMore can be easily added if needed in the future. -/\nprotected theorem mk_uniformity_basis_le {β : Type*} {p : β → Prop} {f : β → ℝ}\n    (hf₀ : ∀ x, p x → 0 < f x) (hf : ∀ ε, 0 < ε → ∃ x, p x ∧ f x ≤ ε) :\n    (𝓤 α).HasBasis p fun x => { p : α × α | dist p.1 p.2 ≤ f x } := by\n  refine ⟨fun s => uniformity_basis_dist.mem_iff.trans ?_⟩\n  constructor\n  · rintro ⟨ε, ε₀, hε⟩\n    rcases exists_between ε₀ with ⟨ε', hε'⟩\n    rcases hf ε' hε'.1 with ⟨i, hi, H⟩\n    exact ⟨i, hi, fun x (hx : _ ≤ _) => hε <| lt_of_le_of_lt (le_trans hx H) hε'.2⟩\n  · exact fun ⟨i, hi, H⟩ => ⟨f i, hf₀ i hi, fun x (hx : _ < _) => H (mem_setOf.2 hx.le)⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ (uniformity α).HasBasis (fun x => LT.lt 0 x) fun ε => setOf fun p => LE.le (Dist.dist p.1 p.2) ε","decl":"/-- Constant size closed neighborhoods of the diagonal form a basis\nof the uniformity filter. -/\ntheorem uniformity_basis_dist_le :\n    (𝓤 α).HasBasis ((0 : ℝ) < ·) fun ε => { p : α × α | dist p.1 p.2 ≤ ε } :=\n  Metric.mk_uniformity_basis_le (fun _ => id) fun ε ε₀ => ⟨ε, ε₀, le_refl ε⟩\n\n"}
{"name":"Metric.uniformity_basis_dist_le_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n⊢ (uniformity α).HasBasis (fun x => True) fun n => setOf fun p => LE.le (Dist.dist p.1 p.2) (HPow.hPow r n)","decl":"theorem uniformity_basis_dist_le_pow {r : ℝ} (h0 : 0 < r) (h1 : r < 1) :\n    (𝓤 α).HasBasis (fun _ : ℕ => True) fun n : ℕ => { p : α × α | dist p.1 p.2 ≤ r ^ n } :=\n  Metric.mk_uniformity_basis_le (fun _ _ => pow_pos h0 _) fun _ε ε0 =>\n    let ⟨n, hn⟩ := exists_pow_lt_of_lt_one ε0 h1\n    ⟨n, trivial, hn.le⟩\n\n"}
{"name":"Metric.mem_uniformity_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set (Prod α α)\n⊢ Iff (Membership.mem (uniformity α) s) (Exists fun ε => And (GT.gt ε 0) (∀ ⦃a b : α⦄, LT.lt (Dist.dist a b) ε → Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_uniformity_dist {s : Set (α × α)} :\n    s ∈ 𝓤 α ↔ ∃ ε > 0, ∀ ⦃a b : α⦄, dist a b < ε → (a, b) ∈ s :=\n  uniformity_basis_dist.mem_uniformity_iff\n\n"}
{"name":"Metric.dist_mem_uniformity","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nε : Real\nε0 : LT.lt 0 ε\n⊢ Membership.mem (uniformity α) (setOf fun p => LT.lt (Dist.dist p.1 p.2) ε)","decl":"/-- A constant size neighborhood of the diagonal is an entourage. -/\ntheorem dist_mem_uniformity {ε : ℝ} (ε0 : 0 < ε) : { p : α × α | dist p.1 p.2 < ε } ∈ 𝓤 α :=\n  mem_uniformity_dist.2 ⟨ε, ε0, fun _ _ ↦ id⟩\n\n"}
{"name":"Metric.uniformContinuous_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (UniformContinuous f) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃a b : α⦄, LT.lt (Dist.dist a b) δ → LT.lt (Dist.dist (f a) (f b)) ε))","decl":"theorem uniformContinuous_iff [PseudoMetricSpace β] {f : α → β} :\n    UniformContinuous f ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃a b : α⦄, dist a b < δ → dist (f a) (f b) < ε :=\n  uniformity_basis_dist.uniformContinuous_iff uniformity_basis_dist\n\n"}
{"name":"Metric.uniformContinuousOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\ns : Set α\n⊢ Iff (UniformContinuousOn f s) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LT.lt (Dist.dist x y) δ → LT.lt (Dist.dist (f x) (f y)) ε))","decl":"theorem uniformContinuousOn_iff [PseudoMetricSpace β] {f : α → β} {s : Set α} :\n    UniformContinuousOn f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ x ∈ s, ∀ y ∈ s, dist x y < δ → dist (f x) (f y) < ε :=\n  Metric.uniformity_basis_dist.uniformContinuousOn_iff Metric.uniformity_basis_dist\n\n"}
{"name":"Metric.uniformContinuousOn_iff_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\ns : Set α\n⊢ Iff (UniformContinuousOn f s) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist x y) δ → LE.le (Dist.dist (f x) (f y)) ε))","decl":"theorem uniformContinuousOn_iff_le [PseudoMetricSpace β] {f : α → β} {s : Set α} :\n    UniformContinuousOn f s ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ δ → dist (f x) (f y) ≤ ε :=\n  Metric.uniformity_basis_dist_le.uniformContinuousOn_iff Metric.uniformity_basis_dist_le\n\n"}
{"name":"Metric.nhds_basis_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun x => LT.lt 0 x) (Metric.ball x)","decl":"theorem nhds_basis_ball : (𝓝 x).HasBasis (0 < ·) (ball x) :=\n  nhds_basis_uniformity uniformity_basis_dist\n\n"}
{"name":"Metric.mem_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\ns : Set α\n⊢ Iff (Membership.mem (nhds x) s) (Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (Metric.ball x ε) s))","decl":"theorem mem_nhds_iff : s ∈ 𝓝 x ↔ ∃ ε > 0, ball x ε ⊆ s :=\n  nhds_basis_ball.mem_iff\n\n"}
{"name":"Metric.eventually_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun y => p y) (nhds x)) (Exists fun ε => And (GT.gt ε 0) (∀ ⦃y : α⦄, LT.lt (Dist.dist y x) ε → p y))","decl":"theorem eventually_nhds_iff {p : α → Prop} :\n    (∀ᶠ y in 𝓝 x, p y) ↔ ∃ ε > 0, ∀ ⦃y⦄, dist y x < ε → p y :=\n  mem_nhds_iff\n\n"}
{"name":"Metric.eventually_nhds_iff_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun y => p y) (nhds x)) (Exists fun ε => And (GT.gt ε 0) (∀ (y : α), Membership.mem (Metric.ball x ε) y → p y))","decl":"theorem eventually_nhds_iff_ball {p : α → Prop} :\n    (∀ᶠ y in 𝓝 x, p y) ↔ ∃ ε > 0, ∀ y ∈ ball x ε, p y :=\n  mem_nhds_iff\n\n"}
{"name":"Metric.eventually_nhds_prod_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf : Filter ι\nx₀ : α\np : Prod α ι → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod (nhds x₀) f)) (Exists fun ε => And (GT.gt ε 0) (Exists fun pa => And (Filter.Eventually (fun i => pa i) f) (∀ ⦃x : α⦄, LT.lt (Dist.dist x x₀) ε → ∀ ⦃i : ι⦄, pa i → p { fst := x, snd := i })))","decl":"/-- A version of `Filter.eventually_prod_iff` where the first filter consists of neighborhoods\nin a pseudo-metric space. -/\ntheorem eventually_nhds_prod_iff {f : Filter ι} {x₀ : α} {p : α × ι → Prop} :\n    (∀ᶠ x in 𝓝 x₀ ×ˢ f, p x) ↔ ∃ ε > (0 : ℝ), ∃ pa : ι → Prop, (∀ᶠ i in f, pa i) ∧\n      ∀ ⦃x⦄, dist x x₀ < ε → ∀ ⦃i⦄, pa i → p (x, i) := by\n  refine (nhds_basis_ball.prod f.basis_sets).eventually_iff.trans ?_\n  simp only [Prod.exists, forall_prod_set, id, mem_ball, and_assoc, exists_and_left, and_imp]\n  rfl\n\n"}
{"name":"Metric.eventually_prod_nhds_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf : Filter ι\nx₀ : α\np : Prod ι α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f (nhds x₀))) (Exists fun pa => And (Filter.Eventually (fun i => pa i) f) (Exists fun ε => And (GT.gt ε 0) (∀ ⦃i : ι⦄, pa i → ∀ ⦃x : α⦄, LT.lt (Dist.dist x x₀) ε → p { fst := i, snd := x })))","decl":"/-- A version of `Filter.eventually_prod_iff` where the second filter consists of neighborhoods\nin a pseudo-metric space. -/\ntheorem eventually_prod_nhds_iff {f : Filter ι} {x₀ : α} {p : ι × α → Prop} :\n    (∀ᶠ x in f ×ˢ 𝓝 x₀, p x) ↔ ∃ pa : ι → Prop, (∀ᶠ i in f, pa i) ∧\n      ∃ ε > 0, ∀ ⦃i⦄, pa i → ∀ ⦃x⦄, dist x x₀ < ε → p (i, x) := by\n  rw [eventually_swap_iff, Metric.eventually_nhds_prod_iff]\n  constructor <;>\n    · rintro ⟨a1, a2, a3, a4, a5⟩\n      exact ⟨a3, a4, a1, a2, fun _ b1 b2 b3 => a5 b3 b1⟩\n\n"}
{"name":"Metric.nhds_basis_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun ε => LT.lt 0 ε) (Metric.closedBall x)","decl":"theorem nhds_basis_closedBall : (𝓝 x).HasBasis (fun ε : ℝ => 0 < ε) (closedBall x) :=\n  nhds_basis_uniformity uniformity_basis_dist_le\n\n"}
{"name":"Metric.nhds_basis_ball_inv_nat_succ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun x => True) fun n => Metric.ball x (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))","decl":"theorem nhds_basis_ball_inv_nat_succ :\n    (𝓝 x).HasBasis (fun _ => True) fun n : ℕ => ball x (1 / (↑n + 1)) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_succ\n\n"}
{"name":"Metric.nhds_basis_ball_inv_nat_pos","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ (nhds x).HasBasis (fun n => LT.lt 0 n) fun n => Metric.ball x (HDiv.hDiv 1 ↑n)","decl":"theorem nhds_basis_ball_inv_nat_pos :\n    (𝓝 x).HasBasis (fun n => 0 < n) fun n : ℕ => ball x (1 / ↑n) :=\n  nhds_basis_uniformity uniformity_basis_dist_inv_nat_pos\n\n"}
{"name":"Metric.nhds_basis_ball_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n⊢ (nhds x).HasBasis (fun x => True) fun n => Metric.ball x (HPow.hPow r n)","decl":"theorem nhds_basis_ball_pow {r : ℝ} (h0 : 0 < r) (h1 : r < 1) :\n    (𝓝 x).HasBasis (fun _ => True) fun n : ℕ => ball x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_pow h0 h1)\n\n"}
{"name":"Metric.nhds_basis_closedBall_pow","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\nh0 : LT.lt 0 r\nh1 : LT.lt r 1\n⊢ (nhds x).HasBasis (fun x => True) fun n => Metric.closedBall x (HPow.hPow r n)","decl":"theorem nhds_basis_closedBall_pow {r : ℝ} (h0 : 0 < r) (h1 : r < 1) :\n    (𝓝 x).HasBasis (fun _ => True) fun n : ℕ => closedBall x (r ^ n) :=\n  nhds_basis_uniformity (uniformity_basis_dist_le_pow h0 h1)\n\n"}
{"name":"Metric.isOpen_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (IsOpen s) (∀ (x : α), Membership.mem s x → Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (Metric.ball x ε) s))","decl":"theorem isOpen_iff : IsOpen s ↔ ∀ x ∈ s, ∃ ε > 0, ball x ε ⊆ s := by\n  simp only [isOpen_iff_mem_nhds, mem_nhds_iff]\n\n"}
{"name":"Metric.isOpen_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ IsOpen (Metric.ball x ε)","decl":"theorem isOpen_ball : IsOpen (ball x ε) :=\n  isOpen_iff.2 fun _ => exists_ball_subset_ball\n\n"}
{"name":"Metric.ball_mem_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nε0 : LT.lt 0 ε\n⊢ Membership.mem (nhds x) (Metric.ball x ε)","decl":"theorem ball_mem_nhds (x : α) {ε : ℝ} (ε0 : 0 < ε) : ball x ε ∈ 𝓝 x :=\n  isOpen_ball.mem_nhds (mem_ball_self ε0)\n\n"}
{"name":"Metric.closedBall_mem_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nε0 : LT.lt 0 ε\n⊢ Membership.mem (nhds x) (Metric.closedBall x ε)","decl":"theorem closedBall_mem_nhds (x : α) {ε : ℝ} (ε0 : 0 < ε) : closedBall x ε ∈ 𝓝 x :=\n  mem_of_superset (ball_mem_nhds x ε0) ball_subset_closedBall\n\n"}
{"name":"Metric.closedBall_mem_nhds_of_mem","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx c : α\nε : Real\nh : Membership.mem (Metric.ball c ε) x\n⊢ Membership.mem (nhds x) (Metric.closedBall c ε)","decl":"theorem closedBall_mem_nhds_of_mem {x c : α} {ε : ℝ} (h : x ∈ ball c ε) : closedBall c ε ∈ 𝓝 x :=\n  mem_of_superset (isOpen_ball.mem_nhds h) ball_subset_closedBall\n\n"}
{"name":"Metric.nhdsWithin_basis_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\ns : Set α\n⊢ (nhdsWithin x s).HasBasis (fun ε => LT.lt 0 ε) fun ε => Inter.inter (Metric.ball x ε) s","decl":"theorem nhdsWithin_basis_ball {s : Set α} :\n    (𝓝[s] x).HasBasis (fun ε : ℝ => 0 < ε) fun ε => ball x ε ∩ s :=\n  nhdsWithin_hasBasis nhds_basis_ball s\n\n"}
{"name":"Metric.mem_nhdsWithin_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\ns t : Set α\n⊢ Iff (Membership.mem (nhdsWithin x t) s) (Exists fun ε => And (GT.gt ε 0) (HasSubset.Subset (Inter.inter (Metric.ball x ε) t) s))","decl":"theorem mem_nhdsWithin_iff {t : Set α} : s ∈ 𝓝[t] x ↔ ∃ ε > 0, ball x ε ∩ t ⊆ s :=\n  nhdsWithin_basis_ball.mem_iff\n\n"}
{"name":"Metric.tendsto_nhdsWithin_nhdsWithin","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : PseudoMetricSpace β\nt : Set β\nf : α → β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhdsWithin b t)) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, Membership.mem s x → LT.lt (Dist.dist x a) δ → And (Membership.mem t (f x)) (LT.lt (Dist.dist (f x) b) ε)))","decl":"theorem tendsto_nhdsWithin_nhdsWithin [PseudoMetricSpace β] {t : Set β} {f : α → β} {a b} :\n    Tendsto f (𝓝[s] a) (𝓝[t] b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, x ∈ s → dist x a < δ → f x ∈ t ∧ dist (f x) b < ε :=\n  (nhdsWithin_basis_ball.tendsto_iff nhdsWithin_basis_ball).trans <| by\n    simp only [inter_comm _ s, inter_comm _ t, mem_inter_iff, and_imp, gt_iff_lt, mem_ball]\n\n"}
{"name":"Metric.tendsto_nhdsWithin_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : PseudoMetricSpace β\nf : α → β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhdsWithin a s) (nhds b)) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, Membership.mem s x → LT.lt (Dist.dist x a) δ → LT.lt (Dist.dist (f x) b) ε))","decl":"theorem tendsto_nhdsWithin_nhds [PseudoMetricSpace β] {f : α → β} {a b} :\n    Tendsto f (𝓝[s] a) (𝓝 b) ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, x ∈ s → dist x a < δ → dist (f x) b < ε := by\n  rw [← nhdsWithin_univ b, tendsto_nhdsWithin_nhdsWithin]\n  simp only [mem_univ, true_and]\n\n"}
{"name":"Metric.tendsto_nhds_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\na : α\nb : β\n⊢ Iff (Filter.Tendsto f (nhds a) (nhds b)) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, LT.lt (Dist.dist x a) δ → LT.lt (Dist.dist (f x) b) ε))","decl":"theorem tendsto_nhds_nhds [PseudoMetricSpace β] {f : α → β} {a b} :\n    Tendsto f (𝓝 a) (𝓝 b) ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, dist x a < δ → dist (f x) b < ε :=\n  nhds_basis_ball.tendsto_iff nhds_basis_ball\n\n"}
{"name":"Metric.continuousAt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\na : α\n⊢ Iff (ContinuousAt f a) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, LT.lt (Dist.dist x a) δ → LT.lt (Dist.dist (f x) (f a)) ε))","decl":"theorem continuousAt_iff [PseudoMetricSpace β] {f : α → β} {a : α} :\n    ContinuousAt f a ↔ ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, dist x a < δ → dist (f x) (f a) < ε := by\n  rw [ContinuousAt, tendsto_nhds_nhds]\n\n"}
{"name":"Metric.continuousWithinAt_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\na : α\ns : Set α\n⊢ Iff (ContinuousWithinAt f s a) (∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ ⦃x : α⦄, Membership.mem s x → LT.lt (Dist.dist x a) δ → LT.lt (Dist.dist (f x) (f a)) ε))","decl":"theorem continuousWithinAt_iff [PseudoMetricSpace β] {f : α → β} {a : α} {s : Set α} :\n    ContinuousWithinAt f s a ↔\n      ∀ ε > 0, ∃ δ > 0, ∀ ⦃x : α⦄, x ∈ s → dist x a < δ → dist (f x) (f a) < ε := by\n  rw [ContinuousWithinAt, tendsto_nhdsWithin_nhds]\n\n"}
{"name":"Metric.continuousOn_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\ns : Set α\n⊢ Iff (ContinuousOn f s) (∀ (b : α), Membership.mem s b → ∀ (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (a : α), Membership.mem s a → LT.lt (Dist.dist a b) δ → LT.lt (Dist.dist (f a) (f b)) ε))","decl":"theorem continuousOn_iff [PseudoMetricSpace β] {f : α → β} {s : Set α} :\n    ContinuousOn f s ↔ ∀ b ∈ s, ∀ ε > 0, ∃ δ > 0, ∀ a ∈ s, dist a b < δ → dist (f a) (f b) < ε := by\n  simp [ContinuousOn, continuousWithinAt_iff]\n\n"}
{"name":"Metric.continuous_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\n⊢ Iff (Continuous f) (∀ (b : α) (ε : Real), GT.gt ε 0 → Exists fun δ => And (GT.gt δ 0) (∀ (a : α), LT.lt (Dist.dist a b) δ → LT.lt (Dist.dist (f a) (f b)) ε))","decl":"theorem continuous_iff [PseudoMetricSpace β] {f : α → β} :\n    Continuous f ↔ ∀ b, ∀ ε > 0, ∃ δ > 0, ∀ a, dist a b < δ → dist (f a) (f b) < ε :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds_nhds\n\n"}
{"name":"Metric.tendsto_nhds","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : Filter β\nu : β → α\na : α\n⊢ Iff (Filter.Tendsto u f (nhds a)) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Dist.dist (u x) a) ε) f)","decl":"theorem tendsto_nhds {f : Filter β} {u : β → α} {a : α} :\n    Tendsto u f (𝓝 a) ↔ ∀ ε > 0, ∀ᶠ x in f, dist (u x) a < ε :=\n  nhds_basis_ball.tendsto_right_iff\n\n"}
{"name":"Metric.continuousAt_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\n⊢ Iff (ContinuousAt f b) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) ε) (nhds b))","decl":"theorem continuousAt_iff' [TopologicalSpace β] {f : β → α} {b : β} :\n    ContinuousAt f b ↔ ∀ ε > 0, ∀ᶠ x in 𝓝 b, dist (f x) (f b) < ε := by\n  rw [ContinuousAt, tendsto_nhds]\n\n"}
{"name":"Metric.continuousWithinAt_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nf : β → α\nb : β\ns : Set β\n⊢ Iff (ContinuousWithinAt f s b) (∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) ε) (nhdsWithin b s))","decl":"theorem continuousWithinAt_iff' [TopologicalSpace β] {f : β → α} {b : β} {s : Set β} :\n    ContinuousWithinAt f s b ↔ ∀ ε > 0, ∀ᶠ x in 𝓝[s] b, dist (f x) (f b) < ε := by\n  rw [ContinuousWithinAt, tendsto_nhds]\n\n"}
{"name":"Metric.continuousOn_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nf : β → α\ns : Set β\n⊢ Iff (ContinuousOn f s) (∀ (b : β), Membership.mem s b → ∀ (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f b)) ε) (nhdsWithin b s))","decl":"theorem continuousOn_iff' [TopologicalSpace β] {f : β → α} {s : Set β} :\n    ContinuousOn f s ↔ ∀ b ∈ s, ∀ ε > 0, ∀ᶠ x in 𝓝[s] b, dist (f x) (f b) < ε := by\n  simp [ContinuousOn, continuousWithinAt_iff']\n\n"}
{"name":"Metric.continuous_iff'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nf : β → α\n⊢ Iff (Continuous f) (∀ (a : β) (ε : Real), GT.gt ε 0 → Filter.Eventually (fun x => LT.lt (Dist.dist (f x) (f a)) ε) (nhds a))","decl":"theorem continuous_iff' [TopologicalSpace β] {f : β → α} :\n    Continuous f ↔ ∀ (a), ∀ ε > 0, ∀ᶠ x in 𝓝 a, dist (f x) (f a) < ε :=\n  continuous_iff_continuousAt.trans <| forall_congr' fun _ => tendsto_nhds\n\n"}
{"name":"Metric.tendsto_atTop","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\na : α\n⊢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (∀ (ε : Real), GT.gt ε 0 → Exists fun N => ∀ (n : β), GE.ge n N → LT.lt (Dist.dist (u n) a) ε)","decl":"theorem tendsto_atTop [Nonempty β] [SemilatticeSup β] {u : β → α} {a : α} :\n    Tendsto u atTop (𝓝 a) ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, dist (u n) a < ε :=\n  (atTop_basis.tendsto_iff nhds_basis_ball).trans <| by\n    simp only [true_and, mem_ball, mem_Ici]\n\n"}
{"name":"Metric.tendsto_atTop'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : PseudoMetricSpace α\ninst✝² : Nonempty β\ninst✝¹ : SemilatticeSup β\ninst✝ : NoMaxOrder β\nu : β → α\na : α\n⊢ Iff (Filter.Tendsto u Filter.atTop (nhds a)) (∀ (ε : Real), GT.gt ε 0 → Exists fun N => ∀ (n : β), GT.gt n N → LT.lt (Dist.dist (u n) a) ε)","decl":"/-- A variant of `tendsto_atTop` that\nuses `∃ N, ∀ n > N, ...` rather than `∃ N, ∀ n ≥ N, ...`\n-/\ntheorem tendsto_atTop' [Nonempty β] [SemilatticeSup β] [NoMaxOrder β] {u : β → α} {a : α} :\n    Tendsto u atTop (𝓝 a) ↔ ∀ ε > 0, ∃ N, ∀ n > N, dist (u n) a < ε :=\n  (atTop_basis_Ioi.tendsto_iff nhds_basis_ball).trans <| by\n    simp only [true_and, gt_iff_lt, mem_Ioi, mem_ball]\n\n"}
{"name":"Metric.isOpen_singleton_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Iff (IsOpen (Singleton.singleton x)) (Exists fun ε => And (GT.gt ε 0) (∀ (y : α), LT.lt (Dist.dist y x) ε → Eq y x))","decl":"theorem isOpen_singleton_iff {α : Type*} [PseudoMetricSpace α] {x : α} :\n    IsOpen ({x} : Set α) ↔ ∃ ε > 0, ∀ y, dist y x < ε → y = x := by\n  simp [isOpen_iff, subset_singleton_iff, mem_ball]\n\n"}
{"name":"Dense.exists_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : Dense s\nx : α\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun y => And (Membership.mem s y) (LT.lt (Dist.dist x y) ε)","decl":"theorem _root_.Dense.exists_dist_lt {s : Set α} (hs : Dense s) (x : α) {ε : ℝ} (hε : 0 < ε) :\n    ∃ y ∈ s, dist x y < ε := by\n  have : (ball x ε).Nonempty := by simp [hε]\n  simpa only [mem_ball'] using hs.exists_mem_open isOpen_ball this\n\n"}
{"name":"DenseRange.exists_dist_lt","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nβ : Type u_3\nf : β → α\nhf : DenseRange f\nx : α\nε : Real\nhε : LT.lt 0 ε\n⊢ Exists fun y => LT.lt (Dist.dist x (f y)) ε","decl":"nonrec theorem _root_.DenseRange.exists_dist_lt {β : Type*} {f : β → α} (hf : DenseRange f) (x : α)\n    {ε : ℝ} (hε : 0 < ε) : ∃ y, dist x (f y) < ε :=\n  exists_range_iff.1 (hf.exists_dist_lt x hε)\n\n"}
{"name":"Metric.uniformSpace_eq_bot","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Iff (Eq PseudoMetricSpace.toUniformSpace Bot.bot) (Exists fun r => And (LT.lt 0 r) (Pairwise fun x1 x2 => LE.le r (Dist.dist x1 x2)))","decl":"/-- (Pseudo) metric space has discrete `UniformSpace` structure\niff the distances between distinct points are uniformly bounded away from zero. -/\nprotected lemma uniformSpace_eq_bot :\n    ‹PseudoMetricSpace α›.toUniformSpace = ⊥ ↔\n      ∃ r : ℝ, 0 < r ∧ Pairwise (r ≤ dist · · : α → α → Prop) := by\n  simp only [uniformity_basis_dist.uniformSpace_eq_bot, mem_setOf_eq, not_lt]\n\n"}
{"name":"DiscreteTopology.of_forall_le_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\ninst✝ : PseudoMetricSpace α\nr : Real\nhpos : LT.lt 0 r\nhr : Pairwise fun x1 x2 => LE.le r (Dist.dist x1 x2)\n⊢ DiscreteTopology α","decl":"/-- If the distances between distinct points in a (pseudo) metric space\nare uniformly bounded away from zero, then the space has discrete topology. -/\nlemma DiscreteTopology.of_forall_le_dist {α} [PseudoMetricSpace α] {r : ℝ} (hpos : 0 < r)\n    (hr : Pairwise (r ≤ dist · · : α → α → Prop)) : DiscreteTopology α :=\n  ⟨by rw [Metric.uniformSpace_eq_bot.2 ⟨r, hpos, hr⟩, UniformSpace.toTopologicalSpace_bot]⟩\n\n/- Instantiate a pseudometric space as a pseudoemetric space. Before we can state the instance,\nwe need to show that the uniform structure coming from the edistance and the\ndistance coincide. -/\n\n"}
{"name":"Metric.uniformity_edist_aux","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nd : α → α → NNReal\n⊢ Eq (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (↑(d p.1 p.2)) ε)) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (↑(d p.1 p.2)) ε))","decl":"theorem Metric.uniformity_edist_aux {α} (d : α → α → ℝ≥0) :\n    ⨅ ε > (0 : ℝ), 𝓟 { p : α × α | ↑(d p.1 p.2) < ε } =\n      ⨅ ε > (0 : ℝ≥0∞), 𝓟 { p : α × α | ↑(d p.1 p.2) < ε } := by\n  simp only [le_antisymm_iff, le_iInf_iff, le_principal_iff]\n  refine ⟨fun ε hε => ?_, fun ε hε => ?_⟩\n  · rcases ENNReal.lt_iff_exists_nnreal_btwn.1 hε with ⟨ε', ε'0, ε'ε⟩\n    refine mem_iInf_of_mem (ε' : ℝ) (mem_iInf_of_mem (ENNReal.coe_pos.1 ε'0) ?_)\n    exact fun x hx => lt_trans (ENNReal.coe_lt_coe.2 hx) ε'ε\n  · lift ε to ℝ≥0 using le_of_lt hε\n    refine mem_iInf_of_mem (ε : ℝ≥0∞) (mem_iInf_of_mem (ENNReal.coe_pos.2 hε) ?_)\n    exact fun _ => ENNReal.coe_lt_coe.1\n\n"}
{"name":"Metric.uniformity_edist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Eq (uniformity α) (iInf fun ε => iInf fun h => Filter.principal (setOf fun p => LT.lt (EDist.edist p.1 p.2) ε))","decl":"theorem Metric.uniformity_edist : 𝓤 α = ⨅ ε > 0, 𝓟 { p : α × α | edist p.1 p.2 < ε } := by\n  simp only [PseudoMetricSpace.uniformity_dist, dist_nndist, edist_nndist,\n    Metric.uniformity_edist_aux]\n\n-- see Note [lower instance priority]\n"}
{"name":"Metric.eball_top_eq_univ","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (EMetric.ball x Top.top) Set.univ","decl":"/-- In a pseudometric space, an open ball of infinite radius is the whole space -/\ntheorem Metric.eball_top_eq_univ (x : α) : EMetric.ball x ∞ = Set.univ :=\n  Set.eq_univ_iff_forall.mpr fun y => edist_lt_top y x\n\n"}
{"name":"Metric.emetric_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ Eq (EMetric.ball x (ENNReal.ofReal ε)) (Metric.ball x ε)","decl":"/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_ball {x : α} {ε : ℝ} : EMetric.ball x (ENNReal.ofReal ε) = ball x ε := by\n  ext y\n  simp only [EMetric.mem_ball, mem_ball, edist_dist]\n  exact ENNReal.ofReal_lt_ofReal_iff_of_nonneg dist_nonneg\n\n"}
{"name":"Metric.emetric_ball_nnreal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : NNReal\n⊢ Eq (EMetric.ball x ↑ε) (Metric.ball x ↑ε)","decl":"/-- Balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_ball_nnreal {x : α} {ε : ℝ≥0} : EMetric.ball x ε = ball x ε := by\n  rw [← Metric.emetric_ball]\n  simp\n\n"}
{"name":"Metric.emetric_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\nh : LE.le 0 ε\n⊢ Eq (EMetric.closedBall x (ENNReal.ofReal ε)) (Metric.closedBall x ε)","decl":"/-- Closed balls defined using the distance or the edistance coincide -/\ntheorem Metric.emetric_closedBall {x : α} {ε : ℝ} (h : 0 ≤ ε) :\n    EMetric.closedBall x (ENNReal.ofReal ε) = closedBall x ε := by\n  ext y; simp [edist_le_ofReal h]\n\n"}
{"name":"Metric.emetric_closedBall_nnreal","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : NNReal\n⊢ Eq (EMetric.closedBall x ↑ε) (Metric.closedBall x ↑ε)","decl":"/-- Closed balls defined using the distance or the edistance coincide -/\n@[simp]\ntheorem Metric.emetric_closedBall_nnreal {x : α} {ε : ℝ≥0} :\n    EMetric.closedBall x ε = closedBall x ε := by\n  rw [← Metric.emetric_closedBall ε.coe_nonneg, ENNReal.ofReal_coe_nnreal]\n\n"}
{"name":"Metric.emetric_ball_top","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (EMetric.ball x Top.top) Set.univ","decl":"@[simp]\ntheorem Metric.emetric_ball_top (x : α) : EMetric.ball x ⊤ = univ :=\n  eq_univ_of_forall fun _ => edist_lt_top _ _\n\n"}
{"name":"PseudoMetricSpace.replaceUniformity_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nU : UniformSpace α\nm : PseudoMetricSpace α\nH : Eq (uniformity α) (uniformity α)\n⊢ Eq (m.replaceUniformity H) m","decl":"theorem PseudoMetricSpace.replaceUniformity_eq {α} [U : UniformSpace α] (m : PseudoMetricSpace α)\n    (H : 𝓤[U] = 𝓤[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m := by\n  ext\n  rfl\n\n-- ensure that the bornology is unchanged when replacing the uniformity.\n"}
{"name":"PseudoMetricSpace.replaceTopology_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"γ : Type u_3\nU : TopologicalSpace γ\nm : PseudoMetricSpace γ\nH : Eq U UniformSpace.toTopologicalSpace\n⊢ Eq (m.replaceTopology H) m","decl":"theorem PseudoMetricSpace.replaceTopology_eq {γ} [U : TopologicalSpace γ] (m : PseudoMetricSpace γ)\n    (H : U = m.toUniformSpace.toTopologicalSpace) : m.replaceTopology H = m := by\n  ext\n  rfl\n\n"}
{"name":"PseudoMetricSpace.replaceBornology_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u_3\nm : PseudoMetricSpace α\nB : Bornology α\nH : ∀ (s : Set α), Iff (Bornology.IsBounded s) (Bornology.IsBounded s)\n⊢ Eq (m.replaceBornology H) m","decl":"theorem PseudoMetricSpace.replaceBornology_eq {α} [m : PseudoMetricSpace α] [B : Bornology α]\n    (H : ∀ s, @IsBounded _ B s ↔ @IsBounded _ PseudoMetricSpace.toBornology s) :\n    PseudoMetricSpace.replaceBornology _ H = m := by\n  ext\n  rfl\n\n-- ensure that the uniformity is unchanged when replacing the bornology.\n"}
{"name":"Real.dist_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ Eq (Dist.dist x y) (abs (HSub.hSub x y))","decl":"theorem Real.dist_eq (x y : ℝ) : dist x y = |x - y| := rfl\n\n"}
{"name":"Real.nndist_eq","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ Eq (NNDist.nndist x y) (Real.nnabs (HSub.hSub x y))","decl":"theorem Real.nndist_eq (x y : ℝ) : nndist x y = Real.nnabs (x - y) := rfl\n\n"}
{"name":"Real.nndist_eq'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ Eq (NNDist.nndist x y) (Real.nnabs (HSub.hSub y x))","decl":"theorem Real.nndist_eq' (x y : ℝ) : nndist x y = Real.nnabs (y - x) :=\n  nndist_comm _ _\n\n"}
{"name":"Real.dist_0_eq_abs","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x : Real\n⊢ Eq (Dist.dist x 0) (abs x)","decl":"theorem Real.dist_0_eq_abs (x : ℝ) : dist x 0 = |x| := by simp [Real.dist_eq]\n\n"}
{"name":"Real.sub_le_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ LE.le (HSub.hSub x y) (Dist.dist x y)","decl":"theorem Real.sub_le_dist (x y : ℝ) : x - y ≤ dist x y := by\n  rw [Real.dist_eq, le_abs]\n  exact Or.inl (le_refl _)\n\n"}
{"name":"Real.ball_eq_Ioo","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x r : Real\n⊢ Eq (Metric.ball x r) (Set.Ioo (HSub.hSub x r) (HAdd.hAdd x r))","decl":"theorem Real.ball_eq_Ioo (x r : ℝ) : ball x r = Ioo (x - r) (x + r) :=\n  Set.ext fun y => by\n    rw [mem_ball, dist_comm, Real.dist_eq, abs_sub_lt_iff, mem_Ioo, ← sub_lt_iff_lt_add',\n      sub_lt_comm]\n\n"}
{"name":"Real.closedBall_eq_Icc","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x r : Real\n⊢ Eq (Metric.closedBall x r) (Set.Icc (HSub.hSub x r) (HAdd.hAdd x r))","decl":"theorem Real.closedBall_eq_Icc {x r : ℝ} : closedBall x r = Icc (x - r) (x + r) := by\n  ext y\n  rw [mem_closedBall, dist_comm, Real.dist_eq, abs_sub_le_iff, mem_Icc, ← sub_le_iff_le_add',\n    sub_le_comm]\n\n"}
{"name":"Real.Ioo_eq_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ Eq (Set.Ioo x y) (Metric.ball (HDiv.hDiv (HAdd.hAdd x y) 2) (HDiv.hDiv (HSub.hSub y x) 2))","decl":"theorem Real.Ioo_eq_ball (x y : ℝ) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.ball_eq_Ioo, ← sub_div, add_comm, ← sub_add, add_sub_cancel_left, add_self_div_two,\n    ← add_div, add_assoc, add_sub_cancel, add_self_div_two]\n\n"}
{"name":"Real.Icc_eq_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"x y : Real\n⊢ Eq (Set.Icc x y) (Metric.closedBall (HDiv.hDiv (HAdd.hAdd x y) 2) (HDiv.hDiv (HSub.hSub y x) 2))","decl":"theorem Real.Icc_eq_closedBall (x y : ℝ) : Icc x y = closedBall ((x + y) / 2) ((y - x) / 2) := by\n  rw [Real.closedBall_eq_Icc, ← sub_div, add_comm, ← sub_add, add_sub_cancel_left, add_self_div_two,\n    ← add_div, add_assoc, add_sub_cancel, add_self_div_two]\n\n"}
{"name":"Metric.uniformity_eq_comap_nhds_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Eq (uniformity α) (Filter.comap (fun p => Dist.dist p.1 p.2) (nhds 0))","decl":"theorem Metric.uniformity_eq_comap_nhds_zero :\n    𝓤 α = comap (fun p : α × α => dist p.1 p.2) (𝓝 (0 : ℝ)) := by\n  ext s\n  simp only [mem_uniformity_dist, (nhds_basis_ball.comap _).mem_iff]\n  simp [subset_def, Real.dist_0_eq_abs]\n\n"}
{"name":"tendsto_uniformity_iff_dist_tendsto_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf : ι → Prod α α\np : Filter ι\n⊢ Iff (Filter.Tendsto f p (uniformity α)) (Filter.Tendsto (fun x => Dist.dist (f x).1 (f x).2) p (nhds 0))","decl":"theorem tendsto_uniformity_iff_dist_tendsto_zero {f : ι → α × α} {p : Filter ι} :\n    Tendsto f p (𝓤 α) ↔ Tendsto (fun x => dist (f x).1 (f x).2) p (𝓝 0) := by\n  rw [Metric.uniformity_eq_comap_nhds_zero, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.Tendsto.congr_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf₁ f₂ : ι → α\np : Filter ι\na : α\nh₁ : Filter.Tendsto f₁ p (nhds a)\nh : Filter.Tendsto (fun x => Dist.dist (f₁ x) (f₂ x)) p (nhds 0)\n⊢ Filter.Tendsto f₂ p (nhds a)","decl":"theorem Filter.Tendsto.congr_dist {f₁ f₂ : ι → α} {p : Filter ι} {a : α}\n    (h₁ : Tendsto f₁ p (𝓝 a)) (h : Tendsto (fun x => dist (f₁ x) (f₂ x)) p (𝓝 0)) :\n    Tendsto f₂ p (𝓝 a) :=\n  h₁.congr_uniformity <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n\n"}
{"name":"tendsto_of_tendsto_of_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf₁ f₂ : ι → α\np : Filter ι\na : α\nh₁ : Filter.Tendsto f₁ p (nhds a)\nh : Filter.Tendsto (fun x => Dist.dist (f₁ x) (f₂ x)) p (nhds 0)\n⊢ Filter.Tendsto f₂ p (nhds a)","decl":"alias tendsto_of_tendsto_of_dist := Filter.Tendsto.congr_dist\n\n"}
{"name":"tendsto_iff_of_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nf₁ f₂ : ι → α\np : Filter ι\na : α\nh : Filter.Tendsto (fun x => Dist.dist (f₁ x) (f₂ x)) p (nhds 0)\n⊢ Iff (Filter.Tendsto f₁ p (nhds a)) (Filter.Tendsto f₂ p (nhds a))","decl":"theorem tendsto_iff_of_dist {f₁ f₂ : ι → α} {p : Filter ι} {a : α}\n    (h : Tendsto (fun x => dist (f₁ x) (f₂ x)) p (𝓝 0)) : Tendsto f₁ p (𝓝 a) ↔ Tendsto f₂ p (𝓝 a) :=\n  Uniform.tendsto_congr <| tendsto_uniformity_iff_dist_tendsto_zero.2 h\n\n"}
{"name":"PseudoMetricSpace.dist_eq_of_dist_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\nh : Eq (Dist.dist y z) 0\n⊢ Eq (Dist.dist x y) (Dist.dist x z)","decl":"theorem PseudoMetricSpace.dist_eq_of_dist_zero (x : α) {y z : α} (h : dist y z = 0) :\n    dist x y = dist x z :=\n  dist_comm y x ▸ dist_comm z x ▸ sub_eq_zero.1 (abs_nonpos_iff.1 (h ▸ abs_dist_sub_le y z x))\n\n-- Porting note: 3 new lemmas\n"}
{"name":"dist_dist_dist_le_left","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist (Dist.dist x z) (Dist.dist y z)) (Dist.dist x y)","decl":"theorem dist_dist_dist_le_left (x y z : α) : dist (dist x z) (dist y z) ≤ dist x y :=\n  abs_dist_sub_le ..\n\n"}
{"name":"dist_dist_dist_le_right","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ LE.le (Dist.dist (Dist.dist x y) (Dist.dist x z)) (Dist.dist y z)","decl":"theorem dist_dist_dist_le_right (x y z : α) : dist (dist x y) (dist x z) ≤ dist y z := by\n  simpa only [dist_comm x] using dist_dist_dist_le_left y z x\n\n"}
{"name":"dist_dist_dist_le","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y x' y' : α\n⊢ LE.le (Dist.dist (Dist.dist x y) (Dist.dist x' y')) (HAdd.hAdd (Dist.dist x x') (Dist.dist y y'))","decl":"theorem dist_dist_dist_le (x y x' y' : α) : dist (dist x y) (dist x' y') ≤ dist x x' + dist y y' :=\n  (dist_triangle _ _ _).trans <|\n    add_le_add (dist_dist_dist_le_left _ _ _) (dist_dist_dist_le_right _ _ _)\n\n"}
{"name":"nhds_comap_dist","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\na : α\n⊢ Eq (Filter.comap (fun x => Dist.dist x a) (nhds 0)) (nhds a)","decl":"theorem nhds_comap_dist (a : α) : ((𝓝 (0 : ℝ)).comap (dist · a)) = 𝓝 a := by\n  simp only [@nhds_eq_comap_uniformity α, Metric.uniformity_eq_comap_nhds_zero, comap_comap,\n    Function.comp_def, dist_comm]\n\n"}
{"name":"tendsto_iff_dist_tendsto_zero","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\nx : Filter β\na : α\n⊢ Iff (Filter.Tendsto f x (nhds a)) (Filter.Tendsto (fun b => Dist.dist (f b) a) x (nhds 0))","decl":"theorem tendsto_iff_dist_tendsto_zero {f : β → α} {x : Filter β} {a : α} :\n    Tendsto f x (𝓝 a) ↔ Tendsto (fun b => dist (f b) a) x (𝓝 0) := by\n  rw [← nhds_comap_dist a, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Metric.ball_subset_interior_closedBall","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nε : Real\n⊢ HasSubset.Subset (Metric.ball x ε) (interior (Metric.closedBall x ε))","decl":"theorem ball_subset_interior_closedBall : ball x ε ⊆ interior (closedBall x ε) :=\n  interior_maximal ball_subset_closedBall isOpen_ball\n\n"}
{"name":"Metric.mem_closure_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\na : α\n⊢ Iff (Membership.mem (closure s) a) (∀ (ε : Real), GT.gt ε 0 → Exists fun b => And (Membership.mem s b) (LT.lt (Dist.dist a b) ε))","decl":"/-- ε-characterization of the closure in pseudometric spaces -/\ntheorem mem_closure_iff {s : Set α} {a : α} : a ∈ closure s ↔ ∀ ε > 0, ∃ b ∈ s, dist a b < ε :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball).trans <| by simp only [mem_ball, dist_comm]\n\n"}
{"name":"Metric.mem_closure_range_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\ne : β → α\na : α\n⊢ Iff (Membership.mem (closure (Set.range e)) a) (∀ (ε : Real), GT.gt ε 0 → Exists fun k => LT.lt (Dist.dist a (e k)) ε)","decl":"theorem mem_closure_range_iff {e : β → α} {a : α} :\n    a ∈ closure (range e) ↔ ∀ ε > 0, ∃ k : β, dist a (e k) < ε := by\n  simp only [mem_closure_iff, exists_range_iff]\n\n"}
{"name":"Metric.mem_closure_range_iff_nat","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\ne : β → α\na : α\n⊢ Iff (Membership.mem (closure (Set.range e)) a) (∀ (n : Nat), Exists fun k => LT.lt (Dist.dist a (e k)) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1)))","decl":"theorem mem_closure_range_iff_nat {e : β → α} {a : α} :\n    a ∈ closure (range e) ↔ ∀ n : ℕ, ∃ k : β, dist a (e k) < 1 / ((n : ℝ) + 1) :=\n  (mem_closure_iff_nhds_basis nhds_basis_ball_inv_nat_succ).trans <| by\n    simp only [mem_ball, dist_comm, exists_range_iff, forall_const]\n\n"}
{"name":"Metric.mem_of_closed'","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsClosed s\na : α\n⊢ Iff (Membership.mem s a) (∀ (ε : Real), GT.gt ε 0 → Exists fun b => And (Membership.mem s b) (LT.lt (Dist.dist a b) ε))","decl":"theorem mem_of_closed' {s : Set α} (hs : IsClosed s) {a : α} :\n    a ∈ s ↔ ∀ ε > 0, ∃ b ∈ s, dist a b < ε := by\n  simpa only [hs.closure_eq] using @mem_closure_iff _ _ s a\n\n"}
{"name":"Metric.dense_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Dense s) (∀ (x : α) (r : Real), GT.gt r 0 → (Inter.inter (Metric.ball x r) s).Nonempty)","decl":"theorem dense_iff {s : Set α} : Dense s ↔ ∀ x, ∀ r > 0, (ball x r ∩ s).Nonempty :=\n  forall_congr' fun x => by\n    simp only [mem_closure_iff, Set.Nonempty, exists_prop, mem_inter_iff, mem_ball', and_comm]\n\n"}
{"name":"Metric.dense_iff_iUnion_ball","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Dense s) (∀ (r : Real), GT.gt r 0 → Eq (Set.iUnion fun c => Set.iUnion fun h => Metric.ball c r) Set.univ)","decl":"theorem dense_iff_iUnion_ball (s : Set α) : Dense s ↔ ∀ r > 0, ⋃ c ∈ s, ball c r = univ := by\n  simp_rw [eq_univ_iff_forall, mem_iUnion, exists_prop, mem_ball, Dense, mem_closure_iff,\n    forall_comm (α := α)]\n\n"}
{"name":"Metric.denseRange_iff","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\n⊢ Iff (DenseRange f) (∀ (x : α) (r : Real), GT.gt r 0 → Exists fun y => LT.lt (Dist.dist x (f y)) r)","decl":"theorem denseRange_iff {f : β → α} : DenseRange f ↔ ∀ x, ∀ r > 0, ∃ y, dist x (f y) < r :=\n  forall_congr' fun x => by simp only [mem_closure_iff, exists_range_iff]\n\n"}
{"name":"ContinuousOn.isSeparable_image","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nf : α → β\ns : Set α\nhf : ContinuousOn f s\nhs : TopologicalSpace.IsSeparable s\n⊢ TopologicalSpace.IsSeparable (Set.image f s)","decl":"/-- If a map is continuous on a separable set `s`, then the image of `s` is also separable. -/\ntheorem _root_.ContinuousOn.isSeparable_image [TopologicalSpace β] {f : α → β} {s : Set α}\n    (hf : ContinuousOn f s) (hs : IsSeparable s) : IsSeparable (f '' s) := by\n  rw [image_eq_range, ← image_univ]\n  exact (isSeparable_univ_iff.2 hs.separableSpace).image hf.restrict\n\n"}
{"name":"finite_cover_balls_of_compact","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsCompact s\ne : Real\nhe : LT.lt 0 e\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x e)))","decl":"/-- Any compact set in a pseudometric space can be covered by finitely many balls of a given\npositive radius -/\ntheorem finite_cover_balls_of_compact {α : Type u} [PseudoMetricSpace α] {s : Set α}\n    (hs : IsCompact s) {e : ℝ} (he : 0 < e) :\n    ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ x ∈ t, ball x e :=\n  let ⟨t, hts, ht⟩ := hs.elim_nhds_subcover _ (fun x _ => ball_mem_nhds x he)\n  ⟨t, hts, t.finite_toSet, ht⟩\n\n"}
{"name":"IsCompact.finite_cover_balls","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsCompact s\ne : Real\nhe : LT.lt 0 e\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => Metric.ball x e)))","decl":"alias IsCompact.finite_cover_balls := finite_cover_balls_of_compact\n\n"}
{"name":"lebesgue_number_lemma_of_metric","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nι : Sort u_3\nc : ι → Set α\nhs : IsCompact s\nhc₁ : ∀ (i : ι), IsOpen (c i)\nhc₂ : HasSubset.Subset s (Set.iUnion fun i => c i)\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ (x : α), Membership.mem s x → Exists fun i => HasSubset.Subset (Metric.ball x δ) (c i))","decl":"theorem lebesgue_number_lemma_of_metric {s : Set α} {ι : Sort*} {c : ι → Set α} (hs : IsCompact s)\n    (hc₁ : ∀ i, IsOpen (c i)) (hc₂ : s ⊆ ⋃ i, c i) : ∃ δ > 0, ∀ x ∈ s, ∃ i, ball x δ ⊆ c i := by\n  simpa only [ball, UniformSpace.ball, preimage_setOf_eq, dist_comm]\n    using uniformity_basis_dist.lebesgue_number_lemma hs hc₁ hc₂\n\n"}
{"name":"lebesgue_number_lemma_of_metric_sUnion","module":"Mathlib.Topology.MetricSpace.Pseudo.Defs","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nc : Set (Set α)\nhs : IsCompact s\nhc₁ : ∀ (t : Set α), Membership.mem c t → IsOpen t\nhc₂ : HasSubset.Subset s c.sUnion\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ (x : α), Membership.mem s x → Exists fun t => And (Membership.mem c t) (HasSubset.Subset (Metric.ball x δ) t))","decl":"theorem lebesgue_number_lemma_of_metric_sUnion {s : Set α} {c : Set (Set α)} (hs : IsCompact s)\n    (hc₁ : ∀ t ∈ c, IsOpen t) (hc₂ : s ⊆ ⋃₀ c) : ∃ δ > 0, ∀ x ∈ s, ∃ t ∈ c, ball x δ ⊆ t := by\n  rw [sUnion_eq_iUnion] at hc₂; simpa using lebesgue_number_lemma_of_metric hs (by simpa) hc₂\n\n"}
