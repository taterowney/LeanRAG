{"name":"RingCat.Colimits.Prequotient.mul.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\na✝¹ a✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf (a✝¹.mul a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.add.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝³ a✝² a✝¹ a✝ : RingCat.Colimits.Prequotient F\nx✝ : Eq (a✝³.add a✝²) (a✝¹.add a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.neg.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝¹ a✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (Eq a✝¹.neg a✝.neg) (Eq a✝¹ a✝)","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.of.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nj✝ : J\nx✝² : ↑(F.obj j✝)\nj : J\nx✝¹ : ↑(F.obj j)\nx✝ : Eq (RingCat.Colimits.Prequotient.of j✝ x✝²) (RingCat.Colimits.Prequotient.of j x✝¹)\n⊢ And (Eq j✝ j) (HEq x✝² x✝¹)","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.neg.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝¹ a✝ : RingCat.Colimits.Prequotient F\nx✝ : Eq a✝¹.neg a✝.neg\n⊢ Eq a✝¹ a✝","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.of.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (SizeOf.sizeOf (RingCat.Colimits.Prequotient.of j x✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf j)) (SizeOf.sizeOf x✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.of.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nj✝ : J\nx✝¹ : ↑(F.obj j✝)\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (Eq (RingCat.Colimits.Prequotient.of j✝ x✝¹) (RingCat.Colimits.Prequotient.of j x✝)) (And (Eq j✝ j) (HEq x✝¹ x✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.one.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf RingCat.Colimits.Prequotient.one) 1","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.add.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\na✝¹ a✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf (a✝¹.add a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.neg.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\na✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf a✝.neg) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.mul.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝³ a✝² a✝¹ a✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (Eq (a✝³.mul a✝²) (a✝¹.mul a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.zero.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf RingCat.Colimits.Prequotient.zero) 1","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.mul.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝³ a✝² a✝¹ a✝ : RingCat.Colimits.Prequotient F\nx✝ : Eq (a✝³.mul a✝²) (a✝¹.mul a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.Prequotient.add.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\na✝³ a✝² a✝¹ a✝ : RingCat.Colimits.Prequotient F\n⊢ Eq (Eq (a✝³.add a✝²) (a✝¹.add a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- An inductive type representing all ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient\n  -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient\n\n  -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"RingCat.Colimits.quot_zero","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\n⊢ Eq (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) RingCat.Colimits.Prequotient.zero) 0","decl":"@[simp]\ntheorem quot_zero : Quot.mk Setoid.r zero = (0 : ColimitType F) :=\n  rfl\n\n"}
{"name":"RingCat.Colimits.quot_one","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\n⊢ Eq (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) RingCat.Colimits.Prequotient.one) 1","decl":"@[simp]\ntheorem quot_one : Quot.mk Setoid.r one = (1 : ColimitType F) :=\n  rfl\n\n"}
{"name":"RingCat.Colimits.quot_neg","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nx : RingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) x.neg) (Neg.neg (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) x))","decl":"@[simp]\ntheorem quot_neg (x : Prequotient F) :\n    -- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type\n    -- annotation unless we use `by exact` to change the elaboration order.\n    (by exact Quot.mk Setoid.r (neg x) : ColimitType F) = -(by exact Quot.mk Setoid.r x) :=\n  rfl\n\n-- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type annotation\n-- unless we use `by exact` to change the elaboration order.\n"}
{"name":"RingCat.Colimits.quot_add","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nx y : RingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) (x.add y)) (HAdd.hAdd (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) x) (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) y))","decl":"@[simp]\ntheorem quot_add (x y) :\n    (by exact Quot.mk Setoid.r (add x y) : ColimitType F) =\n      (by exact Quot.mk _ x) + (by exact Quot.mk _ y) :=\n  rfl\n\n-- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type annotation\n-- unless we use `by exact` to change the elaboration order.\n"}
{"name":"RingCat.Colimits.quot_mul","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nx y : RingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) (x.mul y)) (HMul.hMul (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) x) (Quot.mk (⇑(RingCat.Colimits.colimitSetoid F)) y))","decl":"@[simp]\ntheorem quot_mul (x y) :\n    (by exact Quot.mk Setoid.r (mul x y) : ColimitType F) =\n      (by exact Quot.mk _ x) * (by exact Quot.mk _ y) :=\n  rfl\n\n"}
{"name":"RingCat.Colimits.cocone_naturality","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (RingCat.Colimits.coconeMorphism F j')) (RingCat.Colimits.coconeMorphism F j)","decl":"@[simp]\ntheorem cocone_naturality {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ coconeMorphism F j' = coconeMorphism F j := by\n  ext\n  apply Quot.sound\n  apply Relation.map\n\n"}
{"name":"RingCat.Colimits.cocone_naturality_components","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J RingCat\nj j' : J\nf : Quiver.Hom j j'\nx : ↑(F.obj j)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (RingCat.Colimits.coconeMorphism F j')) ((CategoryTheory.ConcreteCategory.hom (F.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (RingCat.Colimits.coconeMorphism F j)) x)","decl":"@[simp]\ntheorem cocone_naturality_components (j j' : J) (f : j ⟶ j') (x : F.obj j) :\n    (coconeMorphism F j') (F.map f x) = (coconeMorphism F j) x := by\n  rw [← cocone_naturality F f, comp_apply]\n\n"}
{"name":"RingCat.Colimits.hasColimits_ringCat","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"⊢ CategoryTheory.Limits.HasColimits RingCat","decl":"instance hasColimits_ringCat : HasColimits RingCat where\n  has_colimits_of_shape _ _ :=\n    { has_colimit := fun F =>\n        HasColimit.mk\n          { cocone := colimitCocone F\n            isColimit := colimitIsColimit F } }\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.neg.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝¹ a✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Eq a✝¹.neg a✝.neg) (Eq a✝¹ a✝)","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.of.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (SizeOf.sizeOf (CommRingCat.Colimits.Prequotient.of j x✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf j)) (SizeOf.sizeOf x✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.one.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CommRingCat.Colimits.Prequotient.one) 1","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.mul.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝³ a✝² a✝¹ a✝ : CommRingCat.Colimits.Prequotient F\nx✝ : Eq (a✝³.mul a✝²) (a✝¹.mul a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.mul.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\na✝¹ a✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf (a✝¹.mul a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.mul.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝³ a✝² a✝¹ a✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Eq (a✝³.mul a✝²) (a✝¹.mul a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.add.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\na✝¹ a✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf (a✝¹.add a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.add.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝³ a✝² a✝¹ a✝ : CommRingCat.Colimits.Prequotient F\nx✝ : Eq (a✝³.add a✝²) (a✝¹.add a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.zero.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\n⊢ Eq (SizeOf.sizeOf CommRingCat.Colimits.Prequotient.zero) 1","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.of.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nj✝ : J\nx✝¹ : ↑(F.obj j✝)\nj : J\nx✝ : ↑(F.obj j)\n⊢ Eq (Eq (CommRingCat.Colimits.Prequotient.of j✝ x✝¹) (CommRingCat.Colimits.Prequotient.of j x✝)) (And (Eq j✝ j) (HEq x✝¹ x✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.neg.sizeOf_spec","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\ninst✝ : SizeOf J\na✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (SizeOf.sizeOf a✝.neg) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.add.injEq","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝³ a✝² a✝¹ a✝ : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Eq (a✝³.add a✝²) (a✝¹.add a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.neg.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\na✝¹ a✝ : CommRingCat.Colimits.Prequotient F\nx✝ : Eq a✝¹.neg a✝.neg\n⊢ Eq a✝¹ a✝","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.Prequotient.of.inj","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nj✝ : J\nx✝² : ↑(F.obj j✝)\nj : J\nx✝¹ : ↑(F.obj j)\nx✝ : Eq (CommRingCat.Colimits.Prequotient.of j✝ x✝²) (CommRingCat.Colimits.Prequotient.of j x✝¹)\n⊢ And (Eq j✝ j) (HEq x✝² x✝¹)","decl":"/-- An inductive type representing all commutative ring expressions (without Relations)\non a collection of types indexed by the objects of `J`.\n-/\ninductive Prequotient -- There's always `of`\n  | of : ∀ (j : J) (_ : F.obj j), Prequotient -- Then one generator for each operation\n  | zero : Prequotient\n  | one : Prequotient\n  | neg : Prequotient → Prequotient\n  | add : Prequotient → Prequotient → Prequotient\n  | mul : Prequotient → Prequotient → Prequotient\n\n"}
{"name":"CommRingCat.Colimits.quot_zero","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\n⊢ Eq (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) CommRingCat.Colimits.Prequotient.zero) 0","decl":"@[simp]\ntheorem quot_zero : Quot.mk Setoid.r zero = (0 : ColimitType F) :=\n  rfl\n\n"}
{"name":"CommRingCat.Colimits.quot_one","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\n⊢ Eq (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) CommRingCat.Colimits.Prequotient.one) 1","decl":"@[simp]\ntheorem quot_one : Quot.mk Setoid.r one = (1 : ColimitType F) :=\n  rfl\n\n"}
{"name":"CommRingCat.Colimits.quot_neg","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nx : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) x.neg) (Neg.neg (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) x))","decl":"@[simp]\ntheorem quot_neg (x : Prequotient F) :\n    -- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type\n    -- annotation unless we use `by exact` to change the elaboration order.\n    (by exact Quot.mk Setoid.r (neg x) : ColimitType F) = -(by exact Quot.mk Setoid.r x) :=\n  rfl\n\n-- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type annotation\n-- unless we use `by exact` to change the elaboration order.\n"}
{"name":"CommRingCat.Colimits.quot_add","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nx y : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) (x.add y)) (HAdd.hAdd (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) x) (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) y))","decl":"@[simp]\ntheorem quot_add (x y) :\n    (by exact Quot.mk Setoid.r (add x y) : ColimitType F) =\n      (by exact Quot.mk _ x) + (by exact Quot.mk _ y) :=\n  rfl\n\n-- Porting note: Lean can't see `Quot.mk Setoid.r x` is a `ColimitType F` even with type annotation\n-- unless we use `by exact` to change the elaboration order.\n"}
{"name":"CommRingCat.Colimits.quot_mul","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nx y : CommRingCat.Colimits.Prequotient F\n⊢ Eq (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) (x.mul y)) (HMul.hMul (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) x) (Quot.mk (⇑(CommRingCat.Colimits.colimitSetoid F)) y))","decl":"@[simp]\ntheorem quot_mul (x y) :\n    (by exact Quot.mk Setoid.r (mul x y) : ColimitType F) =\n      (by exact Quot.mk _ x) * (by exact Quot.mk _ y) :=\n  rfl\n\n"}
{"name":"CommRingCat.Colimits.cocone_naturality","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CommRingCat.Colimits.coconeMorphism F j')) (CommRingCat.Colimits.coconeMorphism F j)","decl":"@[simp]\ntheorem cocone_naturality {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ coconeMorphism F j' = coconeMorphism F j := by\n  ext\n  apply Quot.sound\n  apply Relation.map\n\n"}
{"name":"CommRingCat.Colimits.cocone_naturality_components","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J CommRingCat\nj j' : J\nf : Quiver.Hom j j'\nx : ↑(F.obj j)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CommRingCat.Colimits.coconeMorphism F j')) ((CategoryTheory.ConcreteCategory.hom (F.map f)) x)) ((CategoryTheory.ConcreteCategory.hom (CommRingCat.Colimits.coconeMorphism F j)) x)","decl":"@[simp]\ntheorem cocone_naturality_components (j j' : J) (f : j ⟶ j') (x : F.obj j) :\n    (coconeMorphism F j') (F.map f x) = (coconeMorphism F j) x := by\n  rw [← cocone_naturality F f, comp_apply]\n\n"}
{"name":"CommRingCat.Colimits.hasColimits_commRingCat","module":"Mathlib.Algebra.Category.Ring.Colimits","initialProofState":"⊢ CategoryTheory.Limits.HasColimits CommRingCat","decl":"instance hasColimits_commRingCat : HasColimits CommRingCat where\n  has_colimits_of_shape _ _ :=\n    { has_colimit := fun F =>\n        HasColimit.mk\n          { cocone := colimitCocone F\n            isColimit := colimitIsColimit F } }\n\n"}
