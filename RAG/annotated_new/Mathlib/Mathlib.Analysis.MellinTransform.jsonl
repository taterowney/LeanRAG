{"name":"MellinConvergent.const_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\nhf : MellinConvergent f s\nùïú : Type u_2\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : SMulCommClass Complex ùïú E\nc : ùïú\n‚ä¢ MellinConvergent (fun t => HSMul.hSMul c (f t)) s","decl":"theorem MellinConvergent.const_smul {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hf : MellinConvergent f s) {ùïú : Type*}\n    [NontriviallyNormedField ùïú] [NormedSpace ùïú E] [SMulCommClass ‚ÑÇ ùïú E] (c : ùïú) :\n    MellinConvergent (fun t => c ‚Ä¢ f t) s := by\n  simpa only [MellinConvergent, smul_comm] using hf.smul c\n\n"}
{"name":"MellinConvergent.cpow_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns a : Complex\n‚ä¢ Iff (MellinConvergent (fun t => HSMul.hSMul (HPow.hPow (‚Üët) a) (f t)) s) (MellinConvergent f (HAdd.hAdd s a))","decl":"theorem MellinConvergent.cpow_smul {f : ‚Ñù ‚Üí E} {s a : ‚ÑÇ} :\n    MellinConvergent (fun t => (t : ‚ÑÇ) ^ a ‚Ä¢ f t) s ‚Üî MellinConvergent f (s + a) := by\n  refine integrableOn_congr_fun (fun t ht => ?_) measurableSet_Ioi\n  simp_rw [‚Üê sub_add_eq_add_sub, cpow_add _ _ (ofReal_ne_zero.2 <| ne_of_gt ht), mul_smul]\n\n"}
{"name":"MellinConvergent.div_const","module":"Mathlib.Analysis.MellinTransform","initialProofState":"f : Real ‚Üí Complex\ns : Complex\nhf : MellinConvergent f s\na : Complex\n‚ä¢ MellinConvergent (fun t => HDiv.hDiv (f t) a) s","decl":"nonrec theorem MellinConvergent.div_const {f : ‚Ñù ‚Üí ‚ÑÇ} {s : ‚ÑÇ} (hf : MellinConvergent f s) (a : ‚ÑÇ) :\n    MellinConvergent (fun t => f t / a) s := by\n  simpa only [MellinConvergent, smul_eq_mul, ‚Üê mul_div_assoc] using hf.div_const a\n\n"}
{"name":"MellinConvergent.comp_mul_left","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\na : Real\nha : LT.lt 0 a\n‚ä¢ Iff (MellinConvergent (fun t => f (HMul.hMul a t)) s) (MellinConvergent f s)","decl":"theorem MellinConvergent.comp_mul_left {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} {a : ‚Ñù} (ha : 0 < a) :\n    MellinConvergent (fun t => f (a * t)) s ‚Üî MellinConvergent f s := by\n  have := integrableOn_Ioi_comp_mul_left_iff (fun t : ‚Ñù => (t : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f t) 0 ha\n  rw [mul_zero] at this\n  have h1 : EqOn (fun t : ‚Ñù => (‚Üë(a * t) : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f (a * t))\n      ((a : ‚ÑÇ) ^ (s - 1) ‚Ä¢ fun t : ‚Ñù => (t : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f (a * t)) (Ioi 0) := fun t ht ‚Ü¶ by\n    simp only [ofReal_mul, mul_cpow_ofReal_nonneg ha.le (le_of_lt ht), mul_smul, Pi.smul_apply]\n  have h2 : (a : ‚ÑÇ) ^ (s - 1) ‚â† 0 := by\n    rw [Ne, cpow_eq_zero_iff, not_and_or, ofReal_eq_zero]\n    exact Or.inl ha.ne'\n  rw [MellinConvergent, MellinConvergent, ‚Üê this, integrableOn_congr_fun h1 measurableSet_Ioi,\n    IntegrableOn, IntegrableOn, integrable_smul_iff h2]\n\n"}
{"name":"MellinConvergent.comp_rpow","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\na : Real\nha : Ne a 0\n‚ä¢ Iff (MellinConvergent (fun t => f (HPow.hPow t a)) s) (MellinConvergent f (HDiv.hDiv s ‚Üëa))","decl":"theorem MellinConvergent.comp_rpow {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} {a : ‚Ñù} (ha : a ‚â† 0) :\n    MellinConvergent (fun t => f (t ^ a)) s ‚Üî MellinConvergent f (s / a) := by\n  refine Iff.trans ?_ (integrableOn_Ioi_comp_rpow_iff' _ ha)\n  rw [MellinConvergent]\n  refine integrableOn_congr_fun (fun t ht => ?_) measurableSet_Ioi\n  dsimp only [Pi.smul_apply]\n  rw [‚Üê Complex.coe_smul (t ^ (a - 1)), ‚Üê mul_smul, ‚Üê cpow_mul_ofReal_nonneg (le_of_lt ht),\n    ofReal_cpow (le_of_lt ht), ‚Üê cpow_add _ _ (ofReal_ne_zero.mpr (ne_of_gt ht)), ofReal_sub,\n    ofReal_one, mul_sub, mul_div_cancel‚ÇÄ _ (ofReal_ne_zero.mpr ha), mul_one, add_comm, ‚Üê\n    add_sub_assoc, sub_add_cancel]\n\n"}
{"name":"mellin_cpow_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns a : Complex\n‚ä¢ Eq (mellin (fun t => HSMul.hSMul (HPow.hPow (‚Üët) a) (f t)) s) (mellin f (HAdd.hAdd s a))","decl":"theorem mellin_cpow_smul (f : ‚Ñù ‚Üí E) (s a : ‚ÑÇ) :\n    mellin (fun t => (t : ‚ÑÇ) ^ a ‚Ä¢ f t) s = mellin f (s + a) := by\n  refine setIntegral_congr_fun measurableSet_Ioi fun t ht => ?_\n  simp_rw [‚Üê sub_add_eq_add_sub, cpow_add _ _ (ofReal_ne_zero.2 <| ne_of_gt ht), mul_smul]\n\n"}
{"name":"mellin_const_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù‚Å¥ : NormedAddCommGroup E\ninst‚úù¬≥ : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\nùïú : Type u_2\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : SMulCommClass Complex ùïú E\nc : ùïú\n‚ä¢ Eq (mellin (fun t => HSMul.hSMul c (f t)) s) (HSMul.hSMul c (mellin f s))","decl":"theorem mellin_const_smul (f : ‚Ñù ‚Üí E) (s : ‚ÑÇ) {ùïú : Type*} [NontriviallyNormedField ùïú]\n    [NormedSpace ùïú E] [SMulCommClass ‚ÑÇ ùïú E] (c : ùïú) :\n    mellin (fun t => c ‚Ä¢ f t) s = c ‚Ä¢ mellin f s := by simp only [mellin, smul_comm, integral_smul]\n\n"}
{"name":"mellin_div_const","module":"Mathlib.Analysis.MellinTransform","initialProofState":"f : Real ‚Üí Complex\ns a : Complex\n‚ä¢ Eq (mellin (fun t => HDiv.hDiv (f t) a) s) (HDiv.hDiv (mellin f s) a)","decl":"theorem mellin_div_const (f : ‚Ñù ‚Üí ‚ÑÇ) (s a : ‚ÑÇ) : mellin (fun t => f t / a) s = mellin f s / a := by\n  simp_rw [mellin, smul_eq_mul, ‚Üê mul_div_assoc, integral_div]\n\n"}
{"name":"mellin_comp_rpow","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\na : Real\n‚ä¢ Eq (mellin (fun t => f (HPow.hPow t a)) s) (HSMul.hSMul (Inv.inv (abs a)) (mellin f (HDiv.hDiv s ‚Üëa)))","decl":"theorem mellin_comp_rpow (f : ‚Ñù ‚Üí E) (s : ‚ÑÇ) (a : ‚Ñù) :\n    mellin (fun t => f (t ^ a)) s = |a|‚Åª¬π ‚Ä¢ mellin f (s / a) := by\n  /- This is true for `a = 0` as all sides are undefined but turn out to vanish thanks to our\n  convention. The interesting case is `a ‚â† 0` -/\n  rcases eq_or_ne a 0 with rfl|ha\n  ¬∑ by_cases hE : CompleteSpace E\n    ¬∑ simp [integral_smul_const, mellin, setIntegral_Ioi_zero_cpow]\n    ¬∑ simp [integral, mellin, hE]\n  simp_rw [mellin]\n  conv_rhs => rw [‚Üê integral_comp_rpow_Ioi _ ha, ‚Üê integral_smul]\n  refine setIntegral_congr_fun measurableSet_Ioi fun t ht => ?_\n  dsimp only\n  rw [‚Üê mul_smul, ‚Üê mul_assoc, inv_mul_cancel‚ÇÄ (mt abs_eq_zero.1 ha), one_mul, ‚Üê smul_assoc,\n    real_smul]\n  rw [ofReal_cpow (le_of_lt ht), ‚Üê cpow_mul_ofReal_nonneg (le_of_lt ht), ‚Üê\n    cpow_add _ _ (ofReal_ne_zero.mpr <| ne_of_gt ht), ofReal_sub, ofReal_one, mul_sub,\n    mul_div_cancel‚ÇÄ _ (ofReal_ne_zero.mpr ha), add_comm, ‚Üê add_sub_assoc, mul_one, sub_add_cancel]\n\n"}
{"name":"mellin_comp_mul_left","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\na : Real\nha : LT.lt 0 a\n‚ä¢ Eq (mellin (fun t => f (HMul.hMul a t)) s) (HSMul.hSMul (HPow.hPow (‚Üëa) (Neg.neg s)) (mellin f s))","decl":"theorem mellin_comp_mul_left (f : ‚Ñù ‚Üí E) (s : ‚ÑÇ) {a : ‚Ñù} (ha : 0 < a) :\n    mellin (fun t => f (a * t)) s = (a : ‚ÑÇ) ^ (-s) ‚Ä¢ mellin f s := by\n  simp_rw [mellin]\n  have : EqOn (fun t : ‚Ñù => (t : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f (a * t))\n      (fun t : ‚Ñù => (a : ‚ÑÇ) ^ (1 - s) ‚Ä¢ (fun u : ‚Ñù => (u : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f u) (a * t))\n        (Ioi 0) := fun t ht ‚Ü¶ by\n    dsimp only\n    rw [ofReal_mul, mul_cpow_ofReal_nonneg ha.le (le_of_lt ht), ‚Üê mul_smul,\n      (by ring : 1 - s = -(s - 1)), cpow_neg, inv_mul_cancel_left‚ÇÄ]\n    rw [Ne, cpow_eq_zero_iff, ofReal_eq_zero, not_and_or]\n    exact Or.inl ha.ne'\n  rw [setIntegral_congr_fun measurableSet_Ioi this, integral_smul,\n    integral_comp_mul_left_Ioi (fun u ‚Ü¶ (u : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f u) _ ha,\n    mul_zero, ‚Üê Complex.coe_smul, ‚Üê mul_smul, sub_eq_add_neg,\n    cpow_add _ _ (ofReal_ne_zero.mpr ha.ne'), cpow_one, ofReal_inv,\n    mul_assoc, mul_comm, inv_mul_cancel_right‚ÇÄ (ofReal_ne_zero.mpr ha.ne')]\n\n"}
{"name":"mellin_comp_mul_right","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\na : Real\nha : LT.lt 0 a\n‚ä¢ Eq (mellin (fun t => f (HMul.hMul t a)) s) (HSMul.hSMul (HPow.hPow (‚Üëa) (Neg.neg s)) (mellin f s))","decl":"theorem mellin_comp_mul_right (f : ‚Ñù ‚Üí E) (s : ‚ÑÇ) {a : ‚Ñù} (ha : 0 < a) :\n    mellin (fun t => f (t * a)) s = (a : ‚ÑÇ) ^ (-s) ‚Ä¢ mellin f s := by\n  simpa only [mul_comm] using mellin_comp_mul_left f s ha\n\n"}
{"name":"mellin_comp_inv","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\ns : Complex\n‚ä¢ Eq (mellin (fun t => f (Inv.inv t)) s) (mellin f (Neg.neg s))","decl":"theorem mellin_comp_inv (f : ‚Ñù ‚Üí E) (s : ‚ÑÇ) : mellin (fun t => f t‚Åª¬π) s = mellin f (-s) := by\n  simp_rw [‚Üê rpow_neg_one, mellin_comp_rpow _ _ _, abs_neg, abs_one,\n    inv_one, one_smul, ofReal_neg, ofReal_one, div_neg, div_one]\n\n"}
{"name":"hasMellin_add","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Real ‚Üí E\ns : Complex\nhf : MellinConvergent f s\nhg : MellinConvergent g s\n‚ä¢ HasMellin (fun t => HAdd.hAdd (f t) (g t)) s (HAdd.hAdd (mellin f s) (mellin g s))","decl":"theorem hasMellin_add {f g : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hf : MellinConvergent f s)\n    (hg : MellinConvergent g s) : HasMellin (fun t => f t + g t) s (mellin f s + mellin g s) :=\n  ‚ü®by simpa only [MellinConvergent, smul_add] using hf.add hg, by\n    simpa only [mellin, smul_add] using integral_add hf hg‚ü©\n\n"}
{"name":"hasMellin_sub","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf g : Real ‚Üí E\ns : Complex\nhf : MellinConvergent f s\nhg : MellinConvergent g s\n‚ä¢ HasMellin (fun t => HSub.hSub (f t) (g t)) s (HSub.hSub (mellin f s) (mellin g s))","decl":"theorem hasMellin_sub {f g : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hf : MellinConvergent f s)\n    (hg : MellinConvergent g s) : HasMellin (fun t => f t - g t) s (mellin f s - mellin g s) :=\n  ‚ü®by simpa only [MellinConvergent, smul_sub] using hf.sub hg, by\n    simpa only [mellin, smul_sub] using integral_sub hf hg‚ü©\n\n"}
{"name":"mellin_convergent_iff_norm","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nf : Real ‚Üí E\nT : Set Real\nhT : HasSubset.Subset T (Set.Ioi 0)\nhT' : MeasurableSet T\nhfc : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0))\ns : Complex\n‚ä¢ Iff (MeasureTheory.IntegrableOn (fun t => HSMul.hSMul (HPow.hPow (‚Üët) (HSub.hSub s 1)) (f t)) T MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn (fun t => HMul.hMul (HPow.hPow t (HSub.hSub s.re 1)) (Norm.norm (f t))) T MeasureTheory.MeasureSpace.volume)","decl":"/-- Auxiliary lemma to reduce convergence statements from vector-valued functions to real\nscalar-valued functions. -/\ntheorem mellin_convergent_iff_norm [NormedSpace ‚ÑÇ E] {f : ‚Ñù ‚Üí E} {T : Set ‚Ñù} (hT : T ‚äÜ Ioi 0)\n    (hT' : MeasurableSet T) (hfc : AEStronglyMeasurable f <| volume.restrict <| Ioi 0) {s : ‚ÑÇ} :\n    IntegrableOn (fun t : ‚Ñù => (t : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f t) T ‚Üî\n      IntegrableOn (fun t : ‚Ñù => t ^ (s.re - 1) * ‚Äñf t‚Äñ) T := by\n  have : AEStronglyMeasurable (fun t : ‚Ñù => (t : ‚ÑÇ) ^ (s - 1) ‚Ä¢ f t) (volume.restrict T) := by\n    refine ((continuousOn_of_forall_continuousAt ?_).aestronglyMeasurable hT').smul\n      (hfc.mono_set hT)\n    exact fun t ht => continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt (hT ht))\n  rw [IntegrableOn, ‚Üê integrable_norm_iff this, ‚Üê IntegrableOn]\n  refine integrableOn_congr_fun (fun t ht => ?_) hT'\n  simp_rw [norm_smul, Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos (hT ht), sub_re, one_re]\n\n"}
{"name":"mellin_convergent_top_of_isBigO","module":"Mathlib.Analysis.MellinTransform","initialProofState":"f : Real ‚Üí Real\nhfc : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0))\na s : Real\nhf : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\nhs : LT.lt s a\n‚ä¢ Exists fun c => And (LT.lt 0 c) (MeasureTheory.IntegrableOn (fun t => HMul.hMul (HPow.hPow t (HSub.hSub s 1)) (f t)) (Set.Ioi c) MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` is a locally integrable real-valued function which is `O(x ^ (-a))` at `‚àû`, then for any\n`s < a`, its Mellin transform converges on some neighbourhood of `+‚àû`. -/\ntheorem mellin_convergent_top_of_isBigO {f : ‚Ñù ‚Üí ‚Ñù}\n    (hfc : AEStronglyMeasurable f <| volume.restrict (Ioi 0)) {a s : ‚Ñù}\n    (hf : f =O[atTop] (¬∑ ^ (-a))) (hs : s < a) :\n    ‚àÉ c : ‚Ñù, 0 < c ‚àß IntegrableOn (fun t : ‚Ñù => t ^ (s - 1) * f t) (Ioi c) := by\n  obtain ‚ü®d, hd'‚ü© := hf.isBigOWith\n  simp_rw [IsBigOWith, eventually_atTop] at hd'\n  obtain ‚ü®e, he‚ü© := hd'\n  have he' : 0 < max e 1 := zero_lt_one.trans_le (le_max_right _ _)\n  refine ‚ü®max e 1, he', ?_, ?_‚ü©\n  ¬∑ refine AEStronglyMeasurable.mul ?_ (hfc.mono_set (Ioi_subset_Ioi he'.le))\n    refine (continuousOn_of_forall_continuousAt fun t ht => ?_).aestronglyMeasurable\n      measurableSet_Ioi\n    exact continuousAt_rpow_const _ _ (Or.inl <| (he'.trans ht).ne')\n  ¬∑ have : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi <| max e 1),\n        ‚Äñt ^ (s - 1) * f t‚Äñ ‚â§ t ^ (s - 1 + -a) * d := by\n      refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht => ?_\n      have ht' : 0 < t := he'.trans ht\n      rw [norm_mul, rpow_add ht', ‚Üê norm_of_nonneg (rpow_nonneg ht'.le (-a)), mul_assoc,\n        mul_comm _ d, norm_of_nonneg (rpow_nonneg ht'.le _)]\n      gcongr\n      exact he t ((le_max_left e 1).trans_lt ht).le\n    refine (HasFiniteIntegral.mul_const ?_ _).mono' this\n    exact (integrableOn_Ioi_rpow_of_lt (by linarith) he').hasFiniteIntegral\n\n"}
{"name":"mellin_convergent_zero_of_isBigO","module":"Mathlib.Analysis.MellinTransform","initialProofState":"b : Real\nf : Real ‚Üí Real\nhfc : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0))\nhf : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\ns : Real\nhs : LT.lt b s\n‚ä¢ Exists fun c => And (LT.lt 0 c) (MeasureTheory.IntegrableOn (fun t => HMul.hMul (HPow.hPow t (HSub.hSub s 1)) (f t)) (Set.Ioc 0 c) MeasureTheory.MeasureSpace.volume)","decl":"/-- If `f` is a locally integrable real-valued function which is `O(x ^ (-b))` at `0`, then for any\n`b < s`, its Mellin transform converges on some right neighbourhood of `0`. -/\ntheorem mellin_convergent_zero_of_isBigO {b : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù}\n    (hfc : AEStronglyMeasurable f <| volume.restrict (Ioi 0))\n    (hf :  f =O[ùìù[>] 0] (¬∑ ^ (-b))) {s : ‚Ñù} (hs : b < s) :\n    ‚àÉ c : ‚Ñù, 0 < c ‚àß IntegrableOn (fun t : ‚Ñù => t ^ (s - 1) * f t) (Ioc 0 c) := by\n  obtain ‚ü®d, _, hd'‚ü© := hf.exists_pos\n  simp_rw [IsBigOWith, eventually_nhdsWithin_iff, Metric.eventually_nhds_iff, gt_iff_lt] at hd'\n  obtain ‚ü®Œµ, hŒµ, hŒµ'‚ü© := hd'\n  refine ‚ü®Œµ, hŒµ, integrableOn_Ioc_iff_integrableOn_Ioo.mpr ‚ü®?_, ?_‚ü©‚ü©\n  ¬∑ refine AEStronglyMeasurable.mul ?_ (hfc.mono_set Ioo_subset_Ioi_self)\n    refine (continuousOn_of_forall_continuousAt fun t ht => ?_).aestronglyMeasurable\n      measurableSet_Ioo\n    exact continuousAt_rpow_const _ _ (Or.inl ht.1.ne')\n  ¬∑ apply HasFiniteIntegral.mono'\n    ¬∑ show HasFiniteIntegral (fun t => d * t ^ (s - b - 1)) _\n      refine (Integrable.hasFiniteIntegral ?_).const_mul _\n      rw [‚Üê IntegrableOn, ‚Üê integrableOn_Ioc_iff_integrableOn_Ioo, ‚Üê\n        intervalIntegrable_iff_integrableOn_Ioc_of_le hŒµ.le]\n      exact intervalIntegral.intervalIntegrable_rpow' (by linarith)\n    ¬∑ refine (ae_restrict_iff' measurableSet_Ioo).mpr (Eventually.of_forall fun t ht => ?_)\n      rw [mul_comm, norm_mul]\n      specialize hŒµ' _ ht.1\n      ¬∑ rw [dist_eq_norm, sub_zero, norm_of_nonneg (le_of_lt ht.1)]\n        exact ht.2\n      ¬∑ calc _ ‚â§ d * ‚Äñt ^ (-b)‚Äñ * ‚Äñt ^ (s - 1)‚Äñ := by gcongr\n          _ = d * t ^ (s - b - 1) := ?_\n        simp_rw [norm_of_nonneg (rpow_nonneg (le_of_lt ht.1) _), mul_assoc]\n        rw [‚Üê rpow_add ht.1]\n        congr 2\n        abel\n\n"}
{"name":"mellin_convergent_of_isBigO_scalar","module":"Mathlib.Analysis.MellinTransform","initialProofState":"a b : Real\nf : Real ‚Üí Real\ns : Real\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\nhs_top : LT.lt s a\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s\n‚ä¢ MeasureTheory.IntegrableOn (fun t => HMul.hMul (HPow.hPow t (HSub.hSub s 1)) (f t)) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- If `f` is a locally integrable real-valued function on `Ioi 0` which is `O(x ^ (-a))` at `‚àû`\nand `O(x ^ (-b))` at `0`, then its Mellin transform integral converges for `b < s < a`. -/\ntheorem mellin_convergent_of_isBigO_scalar {a b : ‚Ñù} {f : ‚Ñù ‚Üí ‚Ñù} {s : ‚Ñù}\n    (hfc : LocallyIntegrableOn f <| Ioi 0) (hf_top : f =O[atTop] (¬∑ ^ (-a)))\n    (hs_top : s < a) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s) :\n    IntegrableOn (fun t : ‚Ñù => t ^ (s - 1) * f t) (Ioi 0) := by\n  obtain ‚ü®c1, hc1, hc1'‚ü© := mellin_convergent_top_of_isBigO hfc.aestronglyMeasurable hf_top hs_top\n  obtain ‚ü®c2, hc2, hc2'‚ü© :=\n    mellin_convergent_zero_of_isBigO hfc.aestronglyMeasurable hf_bot hs_bot\n  have : Ioi 0 = Ioc 0 c2 ‚à™ Ioc c2 c1 ‚à™ Ioi c1 := by\n    rw [union_assoc, Ioc_union_Ioi (le_max_right _ _),\n      Ioc_union_Ioi ((min_le_left _ _).trans (le_max_right _ _)), min_eq_left (lt_min hc2 hc1).le]\n  rw [this, integrableOn_union, integrableOn_union]\n  refine ‚ü®‚ü®hc2', integrableOn_Icc_iff_integrableOn_Ioc.mp ?_‚ü©, hc1'‚ü©\n  refine\n    (hfc.continuousOn_mul ?_ isOpen_Ioi.isLocallyClosed).integrableOn_compact_subset\n      (fun t ht => (hc2.trans_le ht.1 : 0 < t)) isCompact_Icc\n  exact continuousOn_of_forall_continuousAt\n    fun t ht ‚Ü¶ continuousAt_rpow_const _ _ <| Or.inl <| ne_of_gt ht\n\n"}
{"name":"mellinConvergent_of_isBigO_rpow","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf : Real ‚Üí E\ns : Complex\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\nhs_top : LT.lt s.re a\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s.re\n‚ä¢ MellinConvergent f s","decl":"theorem mellinConvergent_of_isBigO_rpow [NormedSpace ‚ÑÇ E] {a b : ‚Ñù} {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ}\n    (hfc : LocallyIntegrableOn f <| Ioi 0) (hf_top : f =O[atTop] (¬∑ ^ (-a)))\n    (hs_top : s.re < a) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) :\n    MellinConvergent f s := by\n  rw [MellinConvergent,\n    mellin_convergent_iff_norm Subset.rfl measurableSet_Ioi hfc.aestronglyMeasurable]\n  exact mellin_convergent_of_isBigO_scalar hfc.norm hf_top.norm_left hs_top hf_bot.norm_left hs_bot\n\n"}
{"name":"isBigO_rpow_top_log_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\na b : Real\nf : Real ‚Üí E\nhab : LT.lt b a\nhf : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun t => HSMul.hSMul (Real.log t) (f t)) fun x => HPow.hPow x (Neg.neg b)","decl":"/-- If `f` is `O(x ^ (-a))` as `x ‚Üí +‚àû`, then `log ‚Ä¢ f` is `O(x ^ (-b))` for every `b < a`. -/\ntheorem isBigO_rpow_top_log_smul [NormedSpace ‚Ñù E] {a b : ‚Ñù} {f : ‚Ñù ‚Üí E} (hab : b < a)\n    (hf : f =O[atTop] (¬∑ ^ (-a))) :\n    (fun t : ‚Ñù => log t ‚Ä¢ f t) =O[atTop] (¬∑ ^ (-b)) := by\n  refine\n    ((isLittleO_log_rpow_atTop (sub_pos.mpr hab)).isBigO.smul hf).congr'\n      (Eventually.of_forall fun t => by rfl)\n      ((eventually_gt_atTop 0).mp (Eventually.of_forall fun t ht => ?_))\n  simp only\n  rw [smul_eq_mul, ‚Üê rpow_add ht, ‚Üê sub_eq_add_neg, sub_eq_add_neg a, add_sub_cancel_left]\n\n"}
{"name":"isBigO_rpow_zero_log_smul","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\na b : Real\nf : Real ‚Üí E\nhab : LT.lt a b\nhf : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg a)\n‚ä¢ Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) (fun t => HSMul.hSMul (Real.log t) (f t)) fun x => HPow.hPow x (Neg.neg b)","decl":"/-- If `f` is `O(x ^ (-a))` as `x ‚Üí 0`, then `log ‚Ä¢ f` is `O(x ^ (-b))` for every `a < b`. -/\ntheorem isBigO_rpow_zero_log_smul [NormedSpace ‚Ñù E] {a b : ‚Ñù} {f : ‚Ñù ‚Üí E} (hab : a < b)\n    (hf : f =O[ùìù[>] 0] (¬∑ ^ (-a))) :\n    (fun t : ‚Ñù => log t ‚Ä¢ f t) =O[ùìù[>] 0] (¬∑ ^ (-b)) := by\n  have : log =o[ùìù[>] 0] fun t : ‚Ñù => t ^ (a - b) := by\n    refine ((isLittleO_log_rpow_atTop (sub_pos.mpr hab)).neg_left.comp_tendsto\n          tendsto_inv_nhdsGT_zero).congr'\n      (.of_forall fun t => ?_)\n      (eventually_mem_nhdsWithin.mono fun t ht => ?_)\n    ¬∑ simp\n    ¬∑ simp_rw [Function.comp_apply, inv_rpow (le_of_lt ht), ‚Üê rpow_neg (le_of_lt ht), neg_sub]\n  refine (this.isBigO.smul hf).congr' (Eventually.of_forall fun t => by rfl)\n      (eventually_nhdsWithin_iff.mpr (Eventually.of_forall fun t ht => ?_))\n  simp_rw [smul_eq_mul, ‚Üê rpow_add ht]\n  congr 1\n  abel\n\n"}
{"name":"mellin_hasDerivAt_of_isBigO_rpow","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf : Real ‚Üí E\ns : Complex\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\nhs_top : LT.lt s.re a\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s.re\n‚ä¢ And (MellinConvergent (fun t => HSMul.hSMul (Real.log t) (f t)) s) (HasDerivAt (mellin f) (mellin (fun t => HSMul.hSMul (Real.log t) (f t)) s) s)","decl":"/-- Suppose `f` is locally integrable on `(0, ‚àû)`, is `O(x ^ (-a))` as `x ‚Üí ‚àû`, and is\n`O(x ^ (-b))` as `x ‚Üí 0`. Then its Mellin transform is differentiable on the domain `b < re s < a`,\nwith derivative equal to the Mellin transform of `log ‚Ä¢ f`. -/\ntheorem mellin_hasDerivAt_of_isBigO_rpow [NormedSpace ‚ÑÇ E] {a b : ‚Ñù}\n    {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f (Ioi 0)) (hf_top : f =O[atTop] (¬∑ ^ (-a)))\n    (hs_top : s.re < a) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) :\n    MellinConvergent (fun t => log t ‚Ä¢ f t) s ‚àß\n      HasDerivAt (mellin f) (mellin (fun t => log t ‚Ä¢ f t) s) s := by\n  set F : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => (t : ‚ÑÇ) ^ (z - 1) ‚Ä¢ f t\n  set F' : ‚ÑÇ ‚Üí ‚Ñù ‚Üí E := fun (z : ‚ÑÇ) (t : ‚Ñù) => ((t : ‚ÑÇ) ^ (z - 1) * log t) ‚Ä¢ f t\n  -- A convenient radius of ball within which we can uniformly bound the derivative.\n  obtain ‚ü®v, hv0, hv1, hv2‚ü© : ‚àÉ v : ‚Ñù, 0 < v ‚àß v < s.re - b ‚àß v < a - s.re := by\n    obtain ‚ü®w, hw1, hw2‚ü© := exists_between (sub_pos.mpr hs_top)\n    obtain ‚ü®w', hw1', hw2'‚ü© := exists_between (sub_pos.mpr hs_bot)\n    exact\n      ‚ü®min w w', lt_min hw1 hw1', (min_le_right _ _).trans_lt hw2', (min_le_left _ _).trans_lt hw2‚ü©\n  let bound : ‚Ñù ‚Üí ‚Ñù := fun t : ‚Ñù => (t ^ (s.re + v - 1) + t ^ (s.re - v - 1)) * |log t| * ‚Äñf t‚Äñ\n  have h1 : ‚àÄ·∂† z : ‚ÑÇ in ùìù s, AEStronglyMeasurable (F z) (volume.restrict <| Ioi 0) := by\n    refine Eventually.of_forall fun z => AEStronglyMeasurable.smul ?_ hfc.aestronglyMeasurable\n    refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n    refine continuousOn_of_forall_continuousAt fun t ht => ?_\n    exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)\n  have h2 : IntegrableOn (F s) (Ioi (0 : ‚Ñù)) := by\n    exact mellinConvergent_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot\n  have h3 : AEStronglyMeasurable (F' s) (volume.restrict <| Ioi 0) := by\n    apply LocallyIntegrableOn.aestronglyMeasurable\n    refine hfc.continuousOn_smul isOpen_Ioi.isLocallyClosed\n      ((continuousOn_of_forall_continuousAt fun t ht => ?_).mul ?_)\n    ¬∑ exact continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_gt ht)\n    ¬∑ refine continuous_ofReal.comp_continuousOn ?_\n      exact continuousOn_log.mono (subset_compl_singleton_iff.mpr not_mem_Ioi_self)\n  have h4 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),\n      ‚àÄ z : ‚ÑÇ, z ‚àà Metric.ball s v ‚Üí ‚ÄñF' z t‚Äñ ‚â§ bound t := by\n    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht z hz => ?_\n    simp_rw [F', bound, norm_smul, norm_mul, Complex.norm_eq_abs (log _), Complex.abs_ofReal,\n      mul_assoc]\n    gcongr\n    rw [Complex.norm_eq_abs, abs_cpow_eq_rpow_re_of_pos ht]\n    rcases le_or_lt 1 t with h | h\n    ¬∑ refine le_add_of_le_of_nonneg (rpow_le_rpow_of_exponent_le h ?_)\n        (rpow_nonneg (zero_le_one.trans h) _)\n      rw [sub_re, one_re, sub_le_sub_iff_right]\n      rw [mem_ball_iff_norm, Complex.norm_eq_abs] at hz\n      have hz' := (re_le_abs _).trans hz.le\n      rwa [sub_re, sub_le_iff_le_add'] at hz'\n    ¬∑ refine\n        le_add_of_nonneg_of_le (rpow_pos_of_pos ht _).le (rpow_le_rpow_of_exponent_ge ht h.le ?_)\n      rw [sub_re, one_re, sub_le_iff_le_add, sub_add_cancel]\n      rw [mem_ball_iff_norm', Complex.norm_eq_abs] at hz\n      have hz' := (re_le_abs _).trans hz.le\n      rwa [sub_re, sub_le_iff_le_add, ‚Üê sub_le_iff_le_add'] at hz'\n  have h5 : IntegrableOn bound (Ioi 0) := by\n    simp_rw [bound, add_mul, mul_assoc]\n    suffices ‚àÄ {j : ‚Ñù}, b < j ‚Üí j < a ‚Üí\n        IntegrableOn (fun t : ‚Ñù => t ^ (j - 1) * (|log t| * ‚Äñf t‚Äñ)) (Ioi 0) volume by\n      refine Integrable.add (this ?_ ?_) (this ?_ ?_)\n      all_goals linarith\n    ¬∑ intro j hj hj'\n      obtain ‚ü®w, hw1, hw2‚ü© := exists_between hj\n      obtain ‚ü®w', hw1', hw2'‚ü© := exists_between hj'\n      refine mellin_convergent_of_isBigO_scalar ?_ ?_ hw1' ?_ hw2\n      ¬∑ simp_rw [mul_comm]\n        refine hfc.norm.mul_continuousOn ?_ isOpen_Ioi.isLocallyClosed\n        refine Continuous.comp_continuousOn _root_.continuous_abs (continuousOn_log.mono ?_)\n        exact subset_compl_singleton_iff.mpr not_mem_Ioi_self\n      ¬∑ refine (isBigO_rpow_top_log_smul hw2' hf_top).norm_left.congr_left fun t ‚Ü¶ ?_\n        simp only [norm_smul, Real.norm_eq_abs]\n      ¬∑ refine (isBigO_rpow_zero_log_smul hw1 hf_bot).norm_left.congr_left fun t ‚Ü¶ ?_\n        simp only [norm_smul, Real.norm_eq_abs]\n  have h6 : ‚àÄ·µê t : ‚Ñù ‚àÇvolume.restrict (Ioi 0),\n      ‚àÄ y : ‚ÑÇ, y ‚àà Metric.ball s v ‚Üí HasDerivAt (fun z : ‚ÑÇ => F z t) (F' y t) y := by\n    refine (ae_restrict_mem measurableSet_Ioi).mono fun t ht y _ => ?_\n    have ht' : (t : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht)\n    have u1 : HasDerivAt (fun z : ‚ÑÇ => (t : ‚ÑÇ) ^ (z - 1)) (t ^ (y - 1) * log t) y := by\n      convert ((hasDerivAt_id' y).sub_const 1).const_cpow (Or.inl ht') using 1\n      rw [ofReal_log (le_of_lt ht)]\n      ring\n    exact u1.smul_const (f t)\n  have main := hasDerivAt_integral_of_dominated_loc_of_deriv_le hv0 h1 h2 h3 h4 h5 h6\n  simpa only [F', mul_smul] using main\n\n"}
{"name":"mellin_differentiableAt_of_isBigO_rpow","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nf : Real ‚Üí E\ns : Complex\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun x => HPow.hPow x (Neg.neg a)\nhs_top : LT.lt s.re a\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s.re\n‚ä¢ DifferentiableAt Complex (mellin f) s","decl":"/-- Suppose `f` is locally integrable on `(0, ‚àû)`, is `O(x ^ (-a))` as `x ‚Üí ‚àû`, and is\n`O(x ^ (-b))` as `x ‚Üí 0`. Then its Mellin transform is differentiable on the domain `b < re s < a`.\n-/\ntheorem mellin_differentiableAt_of_isBigO_rpow [NormedSpace ‚ÑÇ E] {a b : ‚Ñù}\n    {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f <| Ioi 0)\n    (hf_top : f =O[atTop] (¬∑ ^ (-a))) (hs_top : s.re < a)\n    (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) :\n    DifferentiableAt ‚ÑÇ (mellin f) s :=\n  (mellin_hasDerivAt_of_isBigO_rpow hfc hf_top hs_top hf_bot hs_bot).2.differentiableAt\n\n"}
{"name":"mellinConvergent_of_isBigO_rpow_exp","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nha : LT.lt 0 a\nf : Real ‚Üí E\ns : Complex\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun t => Real.exp (HMul.hMul (Neg.neg a) t)\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s.re\n‚ä¢ MellinConvergent f s","decl":"/-- If `f` is locally integrable, decays exponentially at infinity, and is `O(x ^ (-b))` at 0, then\nits Mellin transform converges for `b < s.re`. -/\ntheorem mellinConvergent_of_isBigO_rpow_exp [NormedSpace ‚ÑÇ E] {a b : ‚Ñù} (ha : 0 < a) {f : ‚Ñù ‚Üí E}\n    {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f <| Ioi 0) (hf_top : f =O[atTop] fun t => exp (-a * t))\n    (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b))) (hs_bot : b < s.re) : MellinConvergent f s :=\n  mellinConvergent_of_isBigO_rpow hfc (hf_top.trans (isLittleO_exp_neg_mul_rpow_atTop ha _).isBigO)\n    (lt_add_one _) hf_bot hs_bot\n\n"}
{"name":"mellin_differentiableAt_of_isBigO_rpow_exp","module":"Mathlib.Analysis.MellinTransform","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\na b : Real\nha : LT.lt 0 a\nf : Real ‚Üí E\ns : Complex\nhfc : MeasureTheory.LocallyIntegrableOn f (Set.Ioi 0) MeasureTheory.MeasureSpace.volume\nhf_top : Asymptotics.IsBigO Filter.atTop f fun t => Real.exp (HMul.hMul (Neg.neg a) t)\nhf_bot : Asymptotics.IsBigO (nhdsWithin 0 (Set.Ioi 0)) f fun x => HPow.hPow x (Neg.neg b)\nhs_bot : LT.lt b s.re\n‚ä¢ DifferentiableAt Complex (mellin f) s","decl":"/-- If `f` is locally integrable, decays exponentially at infinity, and is `O(x ^ (-b))` at 0, then\nits Mellin transform is holomorphic on `b < s.re`. -/\ntheorem mellin_differentiableAt_of_isBigO_rpow_exp [NormedSpace ‚ÑÇ E] {a b : ‚Ñù}\n    (ha : 0 < a) {f : ‚Ñù ‚Üí E} {s : ‚ÑÇ} (hfc : LocallyIntegrableOn f <| Ioi 0)\n    (hf_top : f =O[atTop] fun t => exp (-a * t)) (hf_bot : f =O[ùìù[>] 0] (¬∑ ^ (-b)))\n    (hs_bot : b < s.re) : DifferentiableAt ‚ÑÇ (mellin f) s :=\n  mellin_differentiableAt_of_isBigO_rpow hfc\n    (hf_top.trans (isLittleO_exp_neg_mul_rpow_atTop ha _).isBigO) (lt_add_one _) hf_bot hs_bot\n\n"}
{"name":"hasMellin_one_Ioc","module":"Mathlib.Analysis.MellinTransform","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ HasMellin ((Set.Ioc 0 1).indicator fun x => 1) s (HDiv.hDiv 1 s)","decl":"/-- The Mellin transform of the indicator function of `Ioc 0 1`. -/\ntheorem hasMellin_one_Ioc {s : ‚ÑÇ} (hs : 0 < re s) :\n    HasMellin (indicator (Ioc 0 1) (fun _ => 1 : ‚Ñù ‚Üí ‚ÑÇ)) s (1 / s) := by\n  have aux1 : -1 < (s - 1).re := by\n    simpa only [sub_re, one_re, sub_eq_add_neg] using lt_add_of_pos_left _ hs\n  have aux2 : s ‚â† 0 := by contrapose! hs; rw [hs, zero_re]\n  have aux3 : MeasurableSet (Ioc (0 : ‚Ñù) 1) := measurableSet_Ioc\n  simp_rw [HasMellin, mellin, MellinConvergent, ‚Üê indicator_smul, IntegrableOn,\n    integrable_indicator_iff aux3, smul_eq_mul, integral_indicator aux3, mul_one, IntegrableOn,\n    Measure.restrict_restrict_of_subset Ioc_subset_Ioi_self]\n  rw [‚Üê IntegrableOn, ‚Üê intervalIntegrable_iff_integrableOn_Ioc_of_le zero_le_one]\n  refine ‚ü®intervalIntegral.intervalIntegrable_cpow' aux1, ?_‚ü©\n  rw [‚Üê intervalIntegral.integral_of_le zero_le_one, integral_cpow (Or.inl aux1), sub_add_cancel,\n    ofReal_zero, ofReal_one, one_cpow, zero_cpow aux2, sub_zero]\n\n"}
{"name":"hasMellin_cpow_Ioc","module":"Mathlib.Analysis.MellinTransform","initialProofState":"a s : Complex\nhs : LT.lt 0 (HAdd.hAdd s.re a.re)\n‚ä¢ HasMellin ((Set.Ioc 0 1).indicator fun t => HPow.hPow (‚Üët) a) s (HDiv.hDiv 1 (HAdd.hAdd s a))","decl":"/-- The Mellin transform of a power function restricted to `Ioc 0 1`. -/\ntheorem hasMellin_cpow_Ioc (a : ‚ÑÇ) {s : ‚ÑÇ} (hs : 0 < re s + re a) :\n    HasMellin (indicator (Ioc 0 1) (fun t => ‚Üët ^ a : ‚Ñù ‚Üí ‚ÑÇ)) s (1 / (s + a)) := by\n  have := hasMellin_one_Ioc (by rwa [add_re] : 0 < (s + a).re)\n  simp_rw [HasMellin, ‚Üê MellinConvergent.cpow_smul, ‚Üê mellin_cpow_smul, ‚Üê indicator_smul,\n    smul_eq_mul, mul_one] at this\n  exact this\n\n"}
