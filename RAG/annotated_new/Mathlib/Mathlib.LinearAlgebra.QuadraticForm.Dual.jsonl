{"name":"LinearMap.dualProd_apply_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na✝ a : Prod (Module.Dual R M) M\n⊢ Eq (((LinearMap.dualProd R M) a✝) a) (HAdd.hAdd (a.1 a✝.2) (a✝.1 a.2))","decl":"/-- The symmetric bilinear form on `Module.Dual R M × M` defined as\n`B (f, x) (g, y) = f y + g x`. -/\n@[simps!]\ndef dualProd : LinearMap.BilinForm R (Module.Dual R M × M) :=\n    (applyₗ.comp (snd R (Module.Dual R M) M)).compl₂ (fst R (Module.Dual R M) M) +\n      ((applyₗ.comp (snd R (Module.Dual R M) M)).compl₂ (fst R (Module.Dual R M) M)).flip\n\n"}
{"name":"LinearMap.isSymm_dualProd","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ LinearMap.IsSymm (LinearMap.dualProd R M)","decl":"theorem isSymm_dualProd : (dualProd R M).IsSymm := fun _x _y => add_comm _ _\n\n"}
{"name":"LinearMap.separatingLeft_dualProd","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (LinearMap.SeparatingLeft (LinearMap.dualProd R M)) (Function.Injective ⇑(Module.Dual.eval R M))","decl":"theorem separatingLeft_dualProd :\n    (dualProd R M).SeparatingLeft ↔ Function.Injective (Module.Dual.eval R M) := by\n  classical\n  rw [separatingLeft_iff_ker_eq_bot, ker_eq_bot]\n  let e := LinearEquiv.prodComm R _ _ ≪≫ₗ Module.dualProdDualEquivDual R (Module.Dual R M) M\n  let h_d := e.symm.toLinearMap.comp (dualProd R M)\n  refine (Function.Injective.of_comp_iff e.symm.injective\n    (dualProd R M)).symm.trans ?_\n  rw [← LinearEquiv.coe_toLinearMap, ← coe_comp]\n  change Function.Injective h_d ↔ _\n  have : h_d = prodMap id (Module.Dual.eval R M) := by\n    refine ext fun x => Prod.ext ?_ ?_\n    · ext\n      dsimp [e, h_d, Module.Dual.eval, LinearEquiv.prodComm]\n      simp\n    · ext\n      dsimp [e, h_d, Module.Dual.eval, LinearEquiv.prodComm]\n      simp\n  rw [this, coe_prodMap]\n  refine Prod.map_injective.trans ?_\n  exact and_iff_right Function.injective_id\n\n"}
{"name":"QuadraticForm.dualProd_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Prod (Module.Dual R M) M\n⊢ Eq ((QuadraticForm.dualProd R M) p) (p.1 p.2)","decl":"/-- The quadratic form on `Module.Dual R M × M` defined as `Q (f, x) = f x`. -/\n@[simps]\ndef dualProd : QuadraticForm R (Module.Dual R M × M) where\n  toFun p := p.1 p.2\n  toFun_smul a p := by\n    dsimp only  -- Porting note: added\n    rw [Prod.smul_fst, Prod.smul_snd, LinearMap.smul_apply, LinearMap.map_smul, smul_eq_mul,\n      smul_eq_mul, smul_eq_mul, mul_assoc]\n  exists_companion' :=\n    ⟨LinearMap.dualProd R M, fun p q => by\n      dsimp only  -- Porting note: added\n      rw [LinearMap.dualProd_apply_apply, Prod.fst_add, Prod.snd_add, LinearMap.add_apply, map_add,\n        map_add, add_right_comm _ (q.1 q.2), add_comm (q.1 p.2) (p.1 q.2), ← add_assoc, ←\n        add_assoc]⟩\n\n"}
{"name":"LinearMap.dualProd.toQuadraticForm","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.BilinMap.toQuadraticMap (LinearMap.dualProd R M)) (HSMul.hSMul 2 (QuadraticForm.dualProd R M))","decl":"@[simp]\ntheorem _root_.LinearMap.dualProd.toQuadraticForm :\n    (LinearMap.dualProd R M).toQuadraticMap = 2 • dualProd R M :=\n  ext fun _a => (two_nsmul _).symm\n\n"}
{"name":"QuadraticForm.dualProdIsometry_toFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\na✝ : Prod (Module.Dual R M) M\n⊢ Eq ((QuadraticForm.dualProdIsometry f) a✝) (((↑f.symm.dualMap).prodCongr ↑f) a✝)","decl":"/-- Any module isomorphism induces a quadratic isomorphism between the corresponding `dual_prod.` -/\n@[simps!]\ndef dualProdIsometry (f : M ≃ₗ[R] N) : (dualProd R M).IsometryEquiv (dualProd R N) where\n  toLinearEquiv := f.dualMap.symm.prod f\n  map_app' x := DFunLike.congr_arg x.fst <| f.symm_apply_apply _\n\n"}
{"name":"QuadraticForm.dualProdIsometry_invFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearEquiv (RingHom.id R) M N\na✝ : Prod (Module.Dual R N) N\n⊢ Eq ((QuadraticForm.dualProdIsometry f).invFun a✝) (((↑f.symm.dualMap).prodCongr ↑f).symm a✝)","decl":"/-- Any module isomorphism induces a quadratic isomorphism between the corresponding `dual_prod.` -/\n@[simps!]\ndef dualProdIsometry (f : M ≃ₗ[R] N) : (dualProd R M).IsometryEquiv (dualProd R N) where\n  toLinearEquiv := f.dualMap.symm.prod f\n  map_app' x := DFunLike.congr_arg x.fst <| f.symm_apply_apply _\n\n"}
{"name":"QuadraticForm.dualProdProdIsometry_toFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\na✝ : Prod (Module.Dual R (Prod M N)) (Prod M N)\n⊢ Eq (QuadraticForm.dualProdProdIsometry a✝) { fst := { fst := LinearMap.comp a✝.1 (LinearMap.inl R M N), snd := a✝.2.1 }, snd := { fst := LinearMap.comp a✝.1 (LinearMap.inr R M N), snd := a✝.2.2 } }","decl":"/-- `QuadraticForm.dualProd` commutes (isometrically) with `QuadraticForm.prod`. -/\n@[simps!]\ndef dualProdProdIsometry :\n    (dualProd R (M × N)).IsometryEquiv ((dualProd R M).prod (dualProd R N)) where\n  toLinearEquiv :=\n    (Module.dualProdDualEquivDual R M N).symm.prod (LinearEquiv.refl R (M × N)) ≪≫ₗ\n      LinearEquiv.prodProdProdComm R _ _ M N\n  map_app' m :=\n    (m.fst.map_add _ _).symm.trans <| DFunLike.congr_arg m.fst <| Prod.ext (add_zero _) (zero_add _)\n\n"}
{"name":"QuadraticForm.dualProdProdIsometry_invFun","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\na✝ : Prod (Prod (Module.Dual R M) M) (Prod (Module.Dual R N) N)\n⊢ Eq (QuadraticForm.dualProdProdIsometry.invFun a✝) (((Module.dualProdDualEquivDual R M N).symm.prod (LinearEquiv.refl R (Prod M N))).symm { fst := { fst := a✝.1.1, snd := a✝.2.1 }, snd := { fst := a✝.1.2, snd := a✝.2.2 } })","decl":"/-- `QuadraticForm.dualProd` commutes (isometrically) with `QuadraticForm.prod`. -/\n@[simps!]\ndef dualProdProdIsometry :\n    (dualProd R (M × N)).IsometryEquiv ((dualProd R M).prod (dualProd R N)) where\n  toLinearEquiv :=\n    (Module.dualProdDualEquivDual R M N).symm.prod (LinearEquiv.refl R (M × N)) ≪≫ₗ\n      LinearEquiv.prodProdProdComm R _ _ M N\n  map_app' m :=\n    (m.fst.map_add _ _).symm.trans <| DFunLike.congr_arg m.fst <| Prod.ext (add_zero _) (zero_add _)\n\n"}
{"name":"QuadraticForm.toDualProd_apply","module":"Mathlib.LinearAlgebra.QuadraticForm.Dual","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\ninst✝ : Invertible 2\ni : Prod M M\n⊢ Eq (Q.toDualProd i) { fst := HAdd.hAdd ((QuadraticMap.associated Q) i.1) ((QuadraticMap.associated Q) i.2), snd := HSub.hSub i.1 i.2 }","decl":"/-- The isometry sending `(Q.prod <| -Q)` to `(QuadraticForm.dualProd R M)`.\n\nThis is `σ` from Proposition 4.8, page 84 of\n[*Hermitian K-Theory and Geometric Applications*][hyman1973]; though we swap the order of the pairs.\n-/\n@[simps!]\ndef toDualProd (Q : QuadraticForm R M) [Invertible (2 : R)] :\n    (Q.prod <| -Q) →qᵢ QuadraticForm.dualProd R M where\n  toLinearMap := LinearMap.prod\n    (Q.associated.comp (LinearMap.fst _ _ _) + Q.associated.comp (LinearMap.snd _ _ _))\n    (LinearMap.fst _ _ _ - LinearMap.snd _ _ _)\n  map_app' x := by\n    dsimp only [associated, associatedHom]\n    dsimp only [LinearMap.smul_apply, LinearMap.coe_mk, AddHom.coe_mk, AddHom.toFun_eq_coe,\n      LinearMap.coe_toAddHom, LinearMap.prod_apply, Pi.prod, LinearMap.add_apply,\n      LinearMap.coe_comp, Function.comp_apply, LinearMap.fst_apply, LinearMap.snd_apply,\n      LinearMap.sub_apply, dualProd_apply, polarBilin_apply_apply, prod_apply, neg_apply]\n    simp only [polar_sub_right, polar_self, nsmul_eq_mul, Nat.cast_ofNat, polar_comm _ x.1 x.2,\n      smul_sub, LinearMap.smul_def, sub_add_sub_cancel, ← sub_eq_add_neg (Q x.1) (Q x.2)]\n    rw [← LinearMap.map_sub (⅟ 2 : Module.End R R), ← mul_sub, ← LinearMap.smul_def]\n    simp only [LinearMap.smul_def, half_moduleEnd_apply_eq_half_smul, smul_eq_mul,\n      invOf_mul_cancel_left']\n\n"}
