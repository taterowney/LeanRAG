{"name":"Prod.Lex.toLex_le_toLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LE β\nx y : Prod α β\n⊢ Iff (LE.le (toLex x) (toLex y)) (Or (LT.lt x.1 y.1) (And (Eq x.1 y.1) (LE.le x.2 y.2)))","decl":"theorem toLex_le_toLex [LT α] [LE β] {x y : α × β} :\n    toLex x ≤ toLex y ↔ x.1 < y.1 ∨ x.1 = y.1 ∧ x.2 ≤ y.2 :=\n  Prod.lex_def\n\n"}
{"name":"Prod.Lex.toLex_lt_toLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\nx y : Prod α β\n⊢ Iff (LT.lt (toLex x) (toLex y)) (Or (LT.lt x.1 y.1) (And (Eq x.1 y.1) (LT.lt x.2 y.2)))","decl":"theorem toLex_lt_toLex [LT α] [LT β] {x y : α × β} :\n    toLex x < toLex y ↔ x.1 < y.1 ∨ x.1 = y.1 ∧ x.2 < y.2 :=\n  Prod.lex_def\n\n"}
{"name":"Prod.Lex.le_iff","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LE β\nx y : Lex (Prod α β)\n⊢ Iff (LE.le x y) (Or (LT.lt (ofLex x).1 (ofLex y).1) (And (Eq (ofLex x).1 (ofLex y).1) (LE.le (ofLex x).2 (ofLex y).2)))","decl":"lemma le_iff [LT α] [LE β] {x y : α ×ₗ β} :\n    x ≤ y ↔ (ofLex x).1 < (ofLex y).1 ∨ (ofLex x).1 = (ofLex y).1 ∧ (ofLex x).2 ≤ (ofLex y).2 :=\n  Prod.lex_def\n\n"}
{"name":"Prod.Lex.lt_iff","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\nx y : Lex (Prod α β)\n⊢ Iff (LT.lt x y) (Or (LT.lt (ofLex x).1 (ofLex y).1) (And (Eq (ofLex x).1 (ofLex y).1) (LT.lt (ofLex x).2 (ofLex y).2)))","decl":"lemma lt_iff [LT α] [LT β] {x y : α ×ₗ β} :\n    x < y ↔ (ofLex x).1 < (ofLex y).1 ∨ (ofLex x).1 = (ofLex y).1 ∧ (ofLex x).2 < (ofLex y).2 :=\n  Prod.lex_def\n\n"}
{"name":"Prod.Lex.instWellFoundedLTLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LT α\ninst✝² : LT β\ninst✝¹ : WellFoundedLT α\ninst✝ : WellFoundedLT β\n⊢ WellFoundedLT (Lex (Prod α β))","decl":"instance [LT α] [LT β] [WellFoundedLT α] [WellFoundedLT β] : WellFoundedLT (α ×ₗ β) :=\n  instIsWellFounded\n\n"}
{"name":"Prod.Lex.monotone_fst","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : LE β\nt c : Lex (Prod α β)\nh : LE.le t c\n⊢ LE.le (ofLex t).1 (ofLex c).1","decl":"theorem monotone_fst [Preorder α] [LE β] (t c : α ×ₗ β) (h : t ≤ c) :\n    (ofLex t).1 ≤ (ofLex c).1 := by\n  cases toLex_le_toLex.mp h with\n  | inl h' => exact h'.le\n  | inr h' => exact h'.1.le\n\n"}
{"name":"Prod.Lex.toLex_le_toLex'","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nx y : Prod α β\n⊢ Iff (LE.le (toLex x) (toLex y)) (And (LE.le x.1 y.1) (Eq x.1 y.1 → LE.le x.2 y.2))","decl":"/-- Variant of `Prod.Lex.toLex_le_toLex` for partial orders. -/\nlemma toLex_le_toLex' : toLex x ≤ toLex y ↔ x.1 ≤ y.1 ∧ (x.1 = y.1 → x.2 ≤ y.2) := by\n  simp only [toLex_le_toLex, lt_iff_le_not_le, le_antisymm_iff]\n  tauto\n\n"}
{"name":"Prod.Lex.toLex_lt_toLex'","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nx y : Prod α β\n⊢ Iff (LT.lt (toLex x) (toLex y)) (And (LE.le x.1 y.1) (Eq x.1 y.1 → LT.lt x.2 y.2))","decl":"/-- Variant of `Prod.Lex.toLex_lt_toLex` for partial orders. -/\nlemma toLex_lt_toLex' : toLex x < toLex y ↔ x.1 ≤ y.1 ∧ (x.1 = y.1 → x.2 < y.2) := by\n  rw [toLex_lt_toLex]\n  simp only [lt_iff_le_not_le, le_antisymm_iff]\n  tauto\n\n"}
{"name":"Prod.Lex.le_iff'","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nx y : Lex (Prod α β)\n⊢ Iff (LE.le x y) (And (LE.le (ofLex x).1 (ofLex y).1) (Eq (ofLex x).1 (ofLex y).1 → LE.le (ofLex x).2 (ofLex y).2))","decl":"/-- Variant of `Prod.Lex.le_iff` for partial orders. -/\nlemma le_iff' {x y : α ×ₗ β} :\n    x ≤ y ↔ (ofLex x).1 ≤ (ofLex y).1 ∧ ((ofLex x).1 = (ofLex y).1 → (ofLex x).2 ≤ (ofLex y).2) :=\n  toLex_le_toLex'\n\n"}
{"name":"Prod.Lex.lt_iff'","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\nx y : Lex (Prod α β)\n⊢ Iff (LT.lt x y) (And (LE.le (ofLex x).1 (ofLex y).1) (Eq (ofLex x).1 (ofLex y).1 → LT.lt (ofLex x).2 (ofLex y).2))","decl":"/-- Variant of `Prod.Lex.lt_iff` for partial orders. -/\nlemma lt_iff' {x y : α ×ₗ β} :\n    x < y ↔ (ofLex x).1 ≤ (ofLex y).1 ∧ ((ofLex x).1 = (ofLex y).1 → (ofLex x).2 < (ofLex y).2) :=\n  toLex_lt_toLex'\n\n"}
{"name":"Prod.Lex.toLex_mono","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\n⊢ Monotone ⇑toLex","decl":"theorem toLex_mono : Monotone (toLex : α × β → α ×ₗ β) :=\n  fun _x _y hxy ↦ toLex_le_toLex'.2 ⟨hxy.1, fun _ ↦ hxy.2⟩\n\n"}
{"name":"Prod.Lex.toLex_strictMono","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\n⊢ StrictMono ⇑toLex","decl":"theorem toLex_strictMono : StrictMono (toLex : α × β → α ×ₗ β) := by\n  rintro ⟨a₁, b₁⟩ ⟨a₂, b₂⟩ h\n  obtain rfl | ha : a₁ = a₂ ∨ _ := h.le.1.eq_or_lt\n  · exact right _ (Prod.mk_lt_mk_iff_right.1 h)\n  · exact left _ _ ha\n\n"}
{"name":"Prod.Lex.compare_def","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Ord α\ninst✝ : Ord β\n⊢ Eq Ord.compare (compareLex (compareOn fun x => (ofLex x).1) (compareOn fun x => (ofLex x).2))","decl":"theorem compare_def [Ord α] [Ord β] : @compare (α ×ₗ β) _ =\n    compareLex (compareOn fun x => (ofLex x).1) (compareOn fun x => (ofLex x).2) := rfl\n\n"}
{"name":"lexOrd_eq","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Ord α\ninst✝ : Ord β\n⊢ Eq lexOrd Prod.Lex.instOrdLexProd","decl":"theorem _root_.lexOrd_eq [Ord α] [Ord β] : @lexOrd α β _ _ = instOrdLexProd := rfl\n\n"}
{"name":"Ord.lex_eq","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\noα : Ord α\noβ : Ord β\n⊢ Eq (oα.lex oβ) Prod.Lex.instOrdLexProd","decl":"theorem _root_.Ord.lex_eq [oα : Ord α] [oβ : Ord β] : Ord.lex oα oβ = instOrdLexProd := rfl\n\n"}
{"name":"Prod.Lex.instOrientedOrdLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Ord α\ninst✝² : Ord β\ninst✝¹ : Batteries.OrientedOrd α\ninst✝ : Batteries.OrientedOrd β\n⊢ Batteries.OrientedOrd (Lex (Prod α β))","decl":"instance [Ord α] [Ord β] [OrientedOrd α] [OrientedOrd β] : OrientedOrd (α ×ₗ β) :=\n  inferInstanceAs (OrientedCmp (compareLex _ _))\n\n"}
{"name":"Prod.Lex.instTransOrdLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Ord α\ninst✝² : Ord β\ninst✝¹ : Batteries.TransOrd α\ninst✝ : Batteries.TransOrd β\n⊢ Batteries.TransOrd (Lex (Prod α β))","decl":"instance [Ord α] [Ord β] [TransOrd α] [TransOrd β] : TransOrd (α ×ₗ β) :=\n  inferInstanceAs (TransCmp (compareLex _ _))\n\n"}
{"name":"Prod.Lex.instDenselyOrderedLex","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : DenselyOrdered α\ninst✝ : DenselyOrdered β\n⊢ DenselyOrdered (Lex (Prod α β))","decl":"instance [Preorder α] [Preorder β] [DenselyOrdered α] [DenselyOrdered β] :\n    DenselyOrdered (α ×ₗ β) where\n  dense := by\n    rintro _ _ (@⟨a₁, b₁, a₂, b₂, h⟩ | @⟨a, b₁, b₂, h⟩)\n    · obtain ⟨c, h₁, h₂⟩ := exists_between h\n      exact ⟨(c, b₁), left _ _ h₁, left _ _ h₂⟩\n    · obtain ⟨c, h₁, h₂⟩ := exists_between h\n      exact ⟨(a, c), right _ h₁, right _ h₂⟩\n\n"}
{"name":"Prod.Lex.noMaxOrder_of_left","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMaxOrder α\n⊢ NoMaxOrder (Lex (Prod α β))","decl":"instance noMaxOrder_of_left [Preorder α] [Preorder β] [NoMaxOrder α] : NoMaxOrder (α ×ₗ β) where\n  exists_gt := by\n    rintro ⟨a, b⟩\n    obtain ⟨c, h⟩ := exists_gt a\n    exact ⟨⟨c, b⟩, left _ _ h⟩\n\n"}
{"name":"Prod.Lex.noMinOrder_of_left","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMinOrder α\n⊢ NoMinOrder (Lex (Prod α β))","decl":"instance noMinOrder_of_left [Preorder α] [Preorder β] [NoMinOrder α] : NoMinOrder (α ×ₗ β) where\n  exists_lt := by\n    rintro ⟨a, b⟩\n    obtain ⟨c, h⟩ := exists_lt a\n    exact ⟨⟨c, b⟩, left _ _ h⟩\n\n"}
{"name":"Prod.Lex.noMaxOrder_of_right","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMaxOrder β\n⊢ NoMaxOrder (Lex (Prod α β))","decl":"instance noMaxOrder_of_right [Preorder α] [Preorder β] [NoMaxOrder β] : NoMaxOrder (α ×ₗ β) where\n  exists_gt := by\n    rintro ⟨a, b⟩\n    obtain ⟨c, h⟩ := exists_gt b\n    exact ⟨⟨a, c⟩, right _ h⟩\n\n"}
{"name":"Prod.Lex.noMinOrder_of_right","module":"Mathlib.Data.Prod.Lex","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : NoMinOrder β\n⊢ NoMinOrder (Lex (Prod α β))","decl":"instance noMinOrder_of_right [Preorder α] [Preorder β] [NoMinOrder β] : NoMinOrder (α ×ₗ β) where\n  exists_lt := by\n    rintro ⟨a, b⟩\n    obtain ⟨c, h⟩ := exists_lt b\n    exact ⟨⟨a, c⟩, right _ h⟩\n\n"}
