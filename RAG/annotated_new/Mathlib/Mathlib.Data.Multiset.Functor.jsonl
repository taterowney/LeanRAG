{"name":"Multiset.fmap_def","module":"Mathlib.Data.Multiset.Functor","initialProofState":"α' β' : Type u_1\ns : Multiset α'\nf : α' → β'\n⊢ Eq (Functor.map f s) (Multiset.map f s)","decl":"@[simp]\ntheorem fmap_def {α' β'} {s : Multiset α'} (f : α' → β') : f <$> s = s.map f :=\n  rfl\n\n"}
{"name":"Multiset.instLawfulFunctor","module":"Mathlib.Data.Multiset.Functor","initialProofState":"⊢ LawfulFunctor Multiset","decl":"instance : LawfulFunctor Multiset where\n  id_map := by simp\n  comp_map := by simp\n  map_const {_ _} := rfl\n\n"}
{"name":"Multiset.pure_def","module":"Mathlib.Data.Multiset.Functor","initialProofState":"α : Type u_1\n⊢ Eq Pure.pure Singleton.singleton","decl":"@[simp]\ntheorem pure_def {α} : (pure : α → Multiset α) = singleton :=\n  rfl\n\n"}
{"name":"Multiset.bind_def","module":"Mathlib.Data.Multiset.Functor","initialProofState":"α β : Type u_1\n⊢ Eq (fun x1 x2 => Bind.bind x1 x2) Multiset.bind","decl":"@[simp]\ntheorem bind_def {α β} : (· >>= ·) = @bind α β :=\n  rfl\n\n"}
{"name":"Multiset.instLawfulMonad","module":"Mathlib.Data.Multiset.Functor","initialProofState":"⊢ LawfulMonad Multiset","decl":"instance : LawfulMonad Multiset := LawfulMonad.mk'\n  (bind_pure_comp := fun _ _ ↦ by simp only [pure_def, bind_def, bind_singleton, fmap_def])\n  (id_map := fun _ ↦ by simp only [fmap_def, id_eq, map_id'])\n  (pure_bind := fun _ _ ↦ by simp only [pure_def, bind_def, singleton_bind])\n  (bind_assoc := @bind_assoc)\n\n"}
{"name":"Multiset.map_comp_coe","module":"Mathlib.Data.Multiset.Functor","initialProofState":"α β : Type u_1\nh : α → β\n⊢ Eq (Function.comp (Functor.map h) Multiset.ofList) (Function.comp Multiset.ofList (Functor.map h))","decl":"@[simp]\ntheorem map_comp_coe {α β} (h : α → β) :\n    Functor.map h ∘ ofList = (ofList ∘ Functor.map h : List α → Multiset β) := by\n  funext; simp only [Function.comp_apply, fmap_def, map_coe, List.map_eq_map]\n\n"}
{"name":"Multiset.id_traverse","module":"Mathlib.Data.Multiset.Functor","initialProofState":"α : Type u_1\nx : Multiset α\n⊢ Eq (Multiset.traverse Pure.pure x) x","decl":"theorem id_traverse {α : Type*} (x : Multiset α) : traverse (pure : α → Id α) x = x := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp [traverse]\n\n"}
{"name":"Multiset.comp_traverse","module":"Mathlib.Data.Multiset.Functor","initialProofState":"G H : Type u_1 → Type u_1\ninst✝³ : Applicative G\ninst✝² : Applicative H\ninst✝¹ : CommApplicative G\ninst✝ : CommApplicative H\nα β γ : Type u_1\ng : α → G β\nh : β → H γ\nx : Multiset α\n⊢ Eq (Multiset.traverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map h) g)) x) (Functor.Comp.mk (Functor.map (Multiset.traverse h) (Multiset.traverse g x)))","decl":"theorem comp_traverse {G H : Type _ → Type _} [Applicative G] [Applicative H] [CommApplicative G]\n    [CommApplicative H] {α β γ : Type _} (g : α → G β) (h : β → H γ) (x : Multiset α) :\n    traverse (Comp.mk ∘ Functor.map h ∘ g) x =\n    Comp.mk (Functor.map (traverse h) (traverse g x)) := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp only [traverse, quot_mk_to_coe, lift_coe, Function.comp_apply, Functor.map_map, functor_norm]\n\n"}
{"name":"Multiset.map_traverse","module":"Mathlib.Data.Multiset.Functor","initialProofState":"G : Type u_1 → Type u_1\ninst✝¹ : Applicative G\ninst✝ : CommApplicative G\nα β γ : Type u_1\ng : α → G β\nh : β → γ\nx : Multiset α\n⊢ Eq (Functor.map (Functor.map h) (Multiset.traverse g x)) (Multiset.traverse (Function.comp (Functor.map h) g) x)","decl":"theorem map_traverse {G : Type* → Type _} [Applicative G] [CommApplicative G] {α β γ : Type _}\n    (g : α → G β) (h : β → γ) (x : Multiset α) :\n    Functor.map (Functor.map h) (traverse g x) = traverse (Functor.map h ∘ g) x := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp only [traverse, quot_mk_to_coe, lift_coe, Function.comp_apply, Functor.map_map, map_comp_coe]\n  rw [Traversable.map_traverse']\n  simp only [fmap_def, Function.comp_apply, Functor.map_map, List.map_eq_map, map_coe]\n\n"}
{"name":"Multiset.traverse_map","module":"Mathlib.Data.Multiset.Functor","initialProofState":"G : Type u_1 → Type u_1\ninst✝¹ : Applicative G\ninst✝ : CommApplicative G\nα β γ : Type u_1\ng : α → β\nh : β → G γ\nx : Multiset α\n⊢ Eq (Multiset.traverse h (Multiset.map g x)) (Multiset.traverse (Function.comp h g) x)","decl":"theorem traverse_map {G : Type* → Type _} [Applicative G] [CommApplicative G] {α β γ : Type _}\n    (g : α → β) (h : β → G γ) (x : Multiset α) : traverse h (map g x) = traverse (h ∘ g) x := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp only [traverse, quot_mk_to_coe, map_coe, lift_coe, Function.comp_apply]\n  rw [← Traversable.traverse_map h g, List.map_eq_map]\n\n"}
{"name":"Multiset.naturality","module":"Mathlib.Data.Multiset.Functor","initialProofState":"G H : Type u_1 → Type u_1\ninst✝³ : Applicative G\ninst✝² : Applicative H\ninst✝¹ : CommApplicative G\ninst✝ : CommApplicative H\neta : ApplicativeTransformation G H\nα β : Type u_1\nf : α → G β\nx : Multiset α\n⊢ Eq ((fun {α} => eta.app α) (Multiset.traverse f x)) (Multiset.traverse (Function.comp (fun {α} => eta.app α) f) x)","decl":"theorem naturality {G H : Type _ → Type _} [Applicative G] [Applicative H] [CommApplicative G]\n    [CommApplicative H] (eta : ApplicativeTransformation G H) {α β : Type _} (f : α → G β)\n    (x : Multiset α) : eta (traverse f x) = traverse (@eta _ ∘ f) x := by\n  refine Quotient.inductionOn x ?_\n  intro\n  simp only [quot_mk_to_coe, traverse, lift_coe, Function.comp_apply,\n    ApplicativeTransformation.preserves_map, LawfulTraversable.naturality]\n\n"}
