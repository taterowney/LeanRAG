{"name":"Filter.HasBasis.cauchy_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nι : Sort u_1\np : ι → Prop\ns : ι → Set (Prod α α)\nh : (uniformity α).HasBasis p s\nf : Filter α\n⊢ Iff (Cauchy f) (And f.NeBot (∀ (i : ι), p i → Exists fun t => And (Membership.mem f t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → Membership.mem (s i) { fst := x, snd := y })))","decl":"theorem Filter.HasBasis.cauchy_iff {ι} {p : ι → Prop} {s : ι → Set (α × α)} (h : (𝓤 α).HasBasis p s)\n    {f : Filter α} :\n    Cauchy f ↔ NeBot f ∧ ∀ i, p i → ∃ t ∈ f, ∀ x ∈ t, ∀ y ∈ t, (x, y) ∈ s i :=\n  and_congr Iff.rfl <|\n    (f.basis_sets.prod_self.le_basis_iff h).trans <| by\n      simp only [subset_def, Prod.forall, mem_prod_eq, and_imp, id, forall_mem_comm]\n\n"}
{"name":"cauchy_iff'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\n⊢ Iff (Cauchy f) (And f.NeBot (∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun t => And (Membership.mem f t) (∀ (x : α), Membership.mem t x → ∀ (y : α), Membership.mem t y → Membership.mem s { fst := x, snd := y })))","decl":"theorem cauchy_iff' {f : Filter α} :\n    Cauchy f ↔ NeBot f ∧ ∀ s ∈ 𝓤 α, ∃ t ∈ f, ∀ x ∈ t, ∀ y ∈ t, (x, y) ∈ s :=\n  (𝓤 α).basis_sets.cauchy_iff\n\n"}
{"name":"cauchy_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\n⊢ Iff (Cauchy f) (And f.NeBot (∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun t => And (Membership.mem f t) (HasSubset.Subset (SProd.sprod t t) s)))","decl":"theorem cauchy_iff {f : Filter α} : Cauchy f ↔ NeBot f ∧ ∀ s ∈ 𝓤 α, ∃ t ∈ f, t ×ˢ t ⊆ s :=\n  cauchy_iff'.trans <| by\n    simp only [subset_def, Prod.forall, mem_prod_eq, and_imp, id, forall_mem_comm]\n\n"}
{"name":"cauchy_iff_le","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nl : Filter α\nhl : l.NeBot\n⊢ Iff (Cauchy l) (LE.le (SProd.sprod l l) (uniformity α))","decl":"lemma cauchy_iff_le {l : Filter α} [hl : l.NeBot] :\n    Cauchy l ↔ l ×ˢ l ≤ 𝓤 α := by\n  simp only [Cauchy, hl, true_and]\n\n"}
{"name":"Cauchy.ultrafilter_of","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nl : Filter α\nh : Cauchy l\n⊢ Cauchy ↑(Ultrafilter.of l)","decl":"theorem Cauchy.ultrafilter_of {l : Filter α} (h : Cauchy l) :\n    Cauchy (@Ultrafilter.of _ l h.1 : Filter α) := by\n  haveI := h.1\n  have := Ultrafilter.of_le l\n  exact ⟨Ultrafilter.neBot _, (Filter.prod_mono this this).trans h.2⟩\n\n"}
{"name":"cauchy_map_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nl : Filter β\nf : β → α\n⊢ Iff (Cauchy (Filter.map f l)) (And l.NeBot (Filter.Tendsto (fun p => { fst := f p.1, snd := f p.2 }) (SProd.sprod l l) (uniformity α)))","decl":"theorem cauchy_map_iff {l : Filter β} {f : β → α} :\n    Cauchy (l.map f) ↔ NeBot l ∧ Tendsto (fun p : β × β => (f p.1, f p.2)) (l ×ˢ l) (𝓤 α) := by\n  rw [Cauchy, map_neBot_iff, prod_map_map_eq, Tendsto]\n\n"}
{"name":"cauchy_map_iff'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nl : Filter β\nhl : l.NeBot\nf : β → α\n⊢ Iff (Cauchy (Filter.map f l)) (Filter.Tendsto (fun p => { fst := f p.1, snd := f p.2 }) (SProd.sprod l l) (uniformity α))","decl":"theorem cauchy_map_iff' {l : Filter β} [hl : NeBot l] {f : β → α} :\n    Cauchy (l.map f) ↔ Tendsto (fun p : β × β => (f p.1, f p.2)) (l ×ˢ l) (𝓤 α) :=\n  cauchy_map_iff.trans <| and_iff_right hl\n\n"}
{"name":"Cauchy.mono","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf g : Filter α\nhg : g.NeBot\nh_c : Cauchy f\nh_le : LE.le g f\n⊢ Cauchy g","decl":"theorem Cauchy.mono {f g : Filter α} [hg : NeBot g] (h_c : Cauchy f) (h_le : g ≤ f) : Cauchy g :=\n  ⟨hg, le_trans (Filter.prod_mono h_le h_le) h_c.right⟩\n\n"}
{"name":"Cauchy.mono'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf g : Filter α\nh_c : Cauchy f\nx✝ : g.NeBot\nh_le : LE.le g f\n⊢ Cauchy g","decl":"theorem Cauchy.mono' {f g : Filter α} (h_c : Cauchy f) (_ : NeBot g) (h_le : g ≤ f) : Cauchy g :=\n  h_c.mono h_le\n\n"}
{"name":"cauchy_nhds","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\na : α\n⊢ Cauchy (nhds a)","decl":"theorem cauchy_nhds {a : α} : Cauchy (𝓝 a) :=\n  ⟨nhds_neBot, nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)⟩\n\n"}
{"name":"cauchy_pure","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\na : α\n⊢ Cauchy (Pure.pure a)","decl":"theorem cauchy_pure {a : α} : Cauchy (pure a) :=\n  cauchy_nhds.mono (pure_le_nhds a)\n\n"}
{"name":"Filter.Tendsto.cauchy_map","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nl : Filter β\ninst✝ : l.NeBot\nf : β → α\na : α\nh : Filter.Tendsto f l (nhds a)\n⊢ Cauchy (Filter.map f l)","decl":"theorem Filter.Tendsto.cauchy_map {l : Filter β} [NeBot l] {f : β → α} {a : α}\n    (h : Tendsto f l (𝓝 a)) : Cauchy (map f l) :=\n  cauchy_nhds.mono h\n\n"}
{"name":"Cauchy.mono_uniformSpace","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"β : Type v\nu v : UniformSpace β\nF : Filter β\nhuv : LE.le u v\nhF : Cauchy F\n⊢ Cauchy F","decl":"lemma Cauchy.mono_uniformSpace {u v : UniformSpace β} {F : Filter β} (huv : u ≤ v)\n    (hF : Cauchy (uniformSpace := u) F) : Cauchy (uniformSpace := v) F :=\n  ⟨hF.1, hF.2.trans huv⟩\n\n"}
{"name":"cauchy_inf_uniformSpace","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"β : Type v\nu v : UniformSpace β\nF : Filter β\n⊢ Iff (Cauchy F) (And (Cauchy F) (Cauchy F))","decl":"lemma cauchy_inf_uniformSpace {u v : UniformSpace β} {F : Filter β} :\n    Cauchy (uniformSpace := u ⊓ v) F ↔\n    Cauchy (uniformSpace := u) F ∧ Cauchy (uniformSpace := v) F := by\n  unfold Cauchy\n  rw [inf_uniformity (u := u), le_inf_iff, and_and_left]\n\n"}
{"name":"cauchy_iInf_uniformSpace","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"β : Type v\nι : Sort u_1\ninst✝ : Nonempty ι\nu : ι → UniformSpace β\nl : Filter β\n⊢ Iff (Cauchy l) (∀ (i : ι), Cauchy l)","decl":"lemma cauchy_iInf_uniformSpace {ι : Sort*} [Nonempty ι] {u : ι → UniformSpace β}\n    {l : Filter β} :\n    Cauchy (uniformSpace := ⨅ i, u i) l ↔ ∀ i, Cauchy (uniformSpace := u i) l := by\n  unfold Cauchy\n  rw [iInf_uniformity, le_iInf_iff, forall_and, forall_const]\n\n"}
{"name":"cauchy_iInf_uniformSpace'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"β : Type v\nι : Sort u_1\nu : ι → UniformSpace β\nl : Filter β\ninst✝ : l.NeBot\n⊢ Iff (Cauchy l) (∀ (i : ι), Cauchy l)","decl":"lemma cauchy_iInf_uniformSpace' {ι : Sort*} {u : ι → UniformSpace β}\n    {l : Filter β} [l.NeBot] :\n    Cauchy (uniformSpace := ⨅ i, u i) l ↔ ∀ i, Cauchy (uniformSpace := u i) l := by\n  simp_rw [cauchy_iff_le (uniformSpace := _), iInf_uniformity, le_iInf_iff]\n\n"}
{"name":"cauchy_comap_uniformSpace","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"β : Type v\nu : UniformSpace β\nα : Type u_1\nf : α → β\nl : Filter α\n⊢ Iff (Cauchy l) (Cauchy (Filter.map f l))","decl":"lemma cauchy_comap_uniformSpace {u : UniformSpace β} {α} {f : α → β} {l : Filter α} :\n    Cauchy (uniformSpace := comap f u) l ↔ Cauchy (map f l) := by\n  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_le_iff_le_comap]\n  rfl\n\n"}
{"name":"cauchy_prod_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : UniformSpace β\nF : Filter (Prod α β)\n⊢ Iff (Cauchy F) (And (Cauchy (Filter.map Prod.fst F)) (Cauchy (Filter.map Prod.snd F)))","decl":"lemma cauchy_prod_iff [UniformSpace β] {F : Filter (α × β)} :\n    Cauchy F ↔ Cauchy (map Prod.fst F) ∧ Cauchy (map Prod.snd F) := by\n  simp_rw [instUniformSpaceProd, ← cauchy_comap_uniformSpace, ← cauchy_inf_uniformSpace]\n\n"}
{"name":"Cauchy.prod","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : UniformSpace β\nf : Filter α\ng : Filter β\nhf : Cauchy f\nhg : Cauchy g\n⊢ Cauchy (SProd.sprod f g)","decl":"theorem Cauchy.prod [UniformSpace β] {f : Filter α} {g : Filter β} (hf : Cauchy f) (hg : Cauchy g) :\n    Cauchy (f ×ˢ g) := by\n  have := hf.1; have := hg.1\n  simpa [cauchy_prod_iff, hf.1] using ⟨hf, hg⟩\n\n"}
{"name":"le_nhds_of_cauchy_adhp_aux","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nx : α\nadhs : ∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun t => And (Membership.mem f t) (And (HasSubset.Subset (SProd.sprod t t) s) (Exists fun y => And (Membership.mem s { fst := x, snd := y }) (Membership.mem t y)))\n⊢ LE.le f (nhds x)","decl":"/-- The common part of the proofs of `le_nhds_of_cauchy_adhp` and\n`SequentiallyComplete.le_nhds_of_seq_tendsto_nhds`: if for any entourage `s`\none can choose a set `t ∈ f` of diameter `s` such that it contains a point `y`\nwith `(x, y) ∈ s`, then `f` converges to `x`. -/\ntheorem le_nhds_of_cauchy_adhp_aux {f : Filter α} {x : α}\n    (adhs : ∀ s ∈ 𝓤 α, ∃ t ∈ f, t ×ˢ t ⊆ s ∧ ∃ y, (x, y) ∈ s ∧ y ∈ t) : f ≤ 𝓝 x := by\n  -- Consider a neighborhood `s` of `x`\n  intro s hs\n  -- Take an entourage twice smaller than `s`\n  rcases comp_mem_uniformity_sets (mem_nhds_uniformity_iff_right.1 hs) with ⟨U, U_mem, hU⟩\n  -- Take a set `t ∈ f`, `t × t ⊆ U`, and a point `y ∈ t` such that `(x, y) ∈ U`\n  rcases adhs U U_mem with ⟨t, t_mem, ht, y, hxy, hy⟩\n  apply mem_of_superset t_mem\n  -- Given a point `z ∈ t`, we have `(x, y) ∈ U` and `(y, z) ∈ t × t ⊆ U`, hence `z ∈ s`\n  exact fun z hz => hU (prod_mk_mem_compRel hxy (ht <| mk_mem_prod hy hz)) rfl\n\n"}
{"name":"le_nhds_of_cauchy_adhp","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nx : α\nhf : Cauchy f\nadhs : ClusterPt x f\n⊢ LE.le f (nhds x)","decl":"/-- If `x` is an adherent (cluster) point for a Cauchy filter `f`, then it is a limit point\nfor `f`. -/\ntheorem le_nhds_of_cauchy_adhp {f : Filter α} {x : α} (hf : Cauchy f) (adhs : ClusterPt x f) :\n    f ≤ 𝓝 x :=\n  le_nhds_of_cauchy_adhp_aux\n    (fun s hs => by\n      obtain ⟨t, t_mem, ht⟩ : ∃ t ∈ f, t ×ˢ t ⊆ s := (cauchy_iff.1 hf).2 s hs\n      use t, t_mem, ht\n      exact forall_mem_nonempty_iff_neBot.2 adhs _ (inter_mem_inf (mem_nhds_left x hs) t_mem))\n\n"}
{"name":"le_nhds_iff_adhp_of_cauchy","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nx : α\nhf : Cauchy f\n⊢ Iff (LE.le f (nhds x)) (ClusterPt x f)","decl":"theorem le_nhds_iff_adhp_of_cauchy {f : Filter α} {x : α} (hf : Cauchy f) :\n    f ≤ 𝓝 x ↔ ClusterPt x f :=\n  ⟨fun h => ClusterPt.of_le_nhds' h hf.1, le_nhds_of_cauchy_adhp hf⟩\n\n"}
{"name":"Cauchy.map","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : UniformSpace β\nf : Filter α\nm : α → β\nhf : Cauchy f\nhm : UniformContinuous m\n⊢ Cauchy (Filter.map m f)","decl":"nonrec theorem Cauchy.map [UniformSpace β] {f : Filter α} {m : α → β} (hf : Cauchy f)\n    (hm : UniformContinuous m) : Cauchy (map m f) :=\n  ⟨hf.1.map _,\n    calc\n      map m f ×ˢ map m f = map (Prod.map m m) (f ×ˢ f) := Filter.prod_map_map_eq\n      _ ≤ Filter.map (Prod.map m m) (𝓤 α) := map_mono hf.right\n      _ ≤ 𝓤 β := hm⟩\n\n"}
{"name":"Cauchy.comap","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : UniformSpace β\nf : Filter β\nm : α → β\nhf : Cauchy f\nhm : LE.le (Filter.comap (fun p => { fst := m p.1, snd := m p.2 }) (uniformity β)) (uniformity α)\ninst✝ : (Filter.comap m f).NeBot\n⊢ Cauchy (Filter.comap m f)","decl":"nonrec theorem Cauchy.comap [UniformSpace β] {f : Filter β} {m : α → β} (hf : Cauchy f)\n    (hm : comap (fun p : α × α => (m p.1, m p.2)) (𝓤 β) ≤ 𝓤 α) [NeBot (comap m f)] :\n    Cauchy (comap m f) :=\n  ⟨‹_›,\n    calc\n      comap m f ×ˢ comap m f = comap (Prod.map m m) (f ×ˢ f) := prod_comap_comap_eq\n      _ ≤ comap (Prod.map m m) (𝓤 β) := comap_mono hf.right\n      _ ≤ 𝓤 α := hm⟩\n\n"}
{"name":"Cauchy.comap'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : UniformSpace β\nf : Filter β\nm : α → β\nhf : Cauchy f\nhm : LE.le (Filter.comap (fun p => { fst := m p.1, snd := m p.2 }) (uniformity β)) (uniformity α)\nx✝ : (Filter.comap m f).NeBot\n⊢ Cauchy (Filter.comap m f)","decl":"theorem Cauchy.comap' [UniformSpace β] {f : Filter β} {m : α → β} (hf : Cauchy f)\n    (hm : Filter.comap (fun p : α × α => (m p.1, m p.2)) (𝓤 β) ≤ 𝓤 α)\n    (_ : NeBot (Filter.comap m f)) : Cauchy (Filter.comap m f) :=\n  hf.comap hm\n\n"}
{"name":"CauchySeq.tendsto_uniformity","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : Preorder β\nu : β → α\nh : CauchySeq u\n⊢ Filter.Tendsto (Prod.map u u) Filter.atTop (uniformity α)","decl":"theorem CauchySeq.tendsto_uniformity [Preorder β] {u : β → α} (h : CauchySeq u) :\n    Tendsto (Prod.map u u) atTop (𝓤 α) := by\n  simpa only [Tendsto, prod_map_map_eq', prod_atTop_atTop_eq] using h.right\n\n"}
{"name":"CauchySeq.nonempty","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : Preorder β\nu : β → α\nhu : CauchySeq u\n⊢ Nonempty β","decl":"theorem CauchySeq.nonempty [Preorder β] {u : β → α} (hu : CauchySeq u) : Nonempty β :=\n  @nonempty_of_neBot _ _ <| (map_neBot_iff _).1 hu.1\n\n"}
{"name":"CauchySeq.mem_entourage","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nβ : Type u_1\ninst✝ : SemilatticeSup β\nu : β → α\nh : CauchySeq u\nV : Set (Prod α α)\nhV : Membership.mem (uniformity α) V\n⊢ Exists fun k₀ => ∀ (i j : β), LE.le k₀ i → LE.le k₀ j → Membership.mem V { fst := u i, snd := u j }","decl":"theorem CauchySeq.mem_entourage {β : Type*} [SemilatticeSup β] {u : β → α} (h : CauchySeq u)\n    {V : Set (α × α)} (hV : V ∈ 𝓤 α) : ∃ k₀, ∀ i j, k₀ ≤ i → k₀ ≤ j → (u i, u j) ∈ V := by\n  haveI := h.nonempty\n  have := h.tendsto_uniformity; rw [← prod_atTop_atTop_eq] at this\n  simpa [MapsTo] using atTop_basis.prod_self.tendsto_left_iff.1 this V hV\n\n"}
{"name":"Filter.Tendsto.cauchySeq","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : SemilatticeSup β\ninst✝ : Nonempty β\nf : β → α\nx : α\nhx : Filter.Tendsto f Filter.atTop (nhds x)\n⊢ CauchySeq f","decl":"theorem Filter.Tendsto.cauchySeq [SemilatticeSup β] [Nonempty β] {f : β → α} {x}\n    (hx : Tendsto f atTop (𝓝 x)) : CauchySeq f :=\n  hx.cauchy_map\n\n"}
{"name":"cauchySeq_const","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : SemilatticeSup β\ninst✝ : Nonempty β\nx : α\n⊢ CauchySeq fun x_1 => x","decl":"theorem cauchySeq_const [SemilatticeSup β] [Nonempty β] (x : α) : CauchySeq fun _ : β => x :=\n  tendsto_const_nhds.cauchySeq\n\n"}
{"name":"cauchySeq_iff_tendsto","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\n⊢ Iff (CauchySeq u) (Filter.Tendsto (Prod.map u u) Filter.atTop (uniformity α))","decl":"theorem cauchySeq_iff_tendsto [Nonempty β] [SemilatticeSup β] {u : β → α} :\n    CauchySeq u ↔ Tendsto (Prod.map u u) atTop (𝓤 α) :=\n  cauchy_map_iff'.trans <| by simp only [prod_atTop_atTop_eq, Prod.map_def]\n\n"}
{"name":"CauchySeq.comp_tendsto","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Type u_1\ninst✝² : Preorder β\ninst✝¹ : SemilatticeSup γ\ninst✝ : Nonempty γ\nf : β → α\nhf : CauchySeq f\ng : γ → β\nhg : Filter.Tendsto g Filter.atTop Filter.atTop\n⊢ CauchySeq (Function.comp f g)","decl":"theorem CauchySeq.comp_tendsto {γ} [Preorder β] [SemilatticeSup γ] [Nonempty γ] {f : β → α}\n    (hf : CauchySeq f) {g : γ → β} (hg : Tendsto g atTop atTop) : CauchySeq (f ∘ g) :=\n  ⟨inferInstance, le_trans (prod_le_prod.mpr ⟨Tendsto.comp le_rfl hg, Tendsto.comp le_rfl hg⟩) hf.2⟩\n\n"}
{"name":"CauchySeq.comp_injective","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝² : SemilatticeSup β\ninst✝¹ : NoMaxOrder β\ninst✝ : Nonempty β\nu : Nat → α\nhu : CauchySeq u\nf : β → Nat\nhf : Function.Injective f\n⊢ CauchySeq (Function.comp u f)","decl":"theorem CauchySeq.comp_injective [SemilatticeSup β] [NoMaxOrder β] [Nonempty β] {u : ℕ → α}\n    (hu : CauchySeq u) {f : β → ℕ} (hf : Injective f) : CauchySeq (u ∘ f) :=\n  hu.comp_tendsto <| Nat.cofinite_eq_atTop ▸ hf.tendsto_cofinite.mono_left atTop_le_cofinite\n\n"}
{"name":"Function.Bijective.cauchySeq_comp_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Nat → Nat\nhf : Function.Bijective f\nu : Nat → α\n⊢ Iff (CauchySeq (Function.comp u f)) (CauchySeq u)","decl":"theorem Function.Bijective.cauchySeq_comp_iff {f : ℕ → ℕ} (hf : Bijective f) (u : ℕ → α) :\n    CauchySeq (u ∘ f) ↔ CauchySeq u := by\n  refine ⟨fun H => ?_, fun H => H.comp_injective hf.injective⟩\n  lift f to ℕ ≃ ℕ using hf\n  simpa only [Function.comp_def, f.apply_symm_apply] using H.comp_injective f.symm.injective\n\n"}
{"name":"CauchySeq.subseq_subseq_mem","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nV : Nat → Set (Prod α α)\nhV : ∀ (n : Nat), Membership.mem (uniformity α) (V n)\nu : Nat → α\nhu : CauchySeq u\nf g : Nat → Nat\nhf : Filter.Tendsto f Filter.atTop Filter.atTop\nhg : Filter.Tendsto g Filter.atTop Filter.atTop\n⊢ Exists fun φ => And (StrictMono φ) (∀ (n : Nat), Membership.mem (V n) { fst := Function.comp u (Function.comp f φ) n, snd := Function.comp u (Function.comp g φ) n })","decl":"theorem CauchySeq.subseq_subseq_mem {V : ℕ → Set (α × α)} (hV : ∀ n, V n ∈ 𝓤 α) {u : ℕ → α}\n    (hu : CauchySeq u) {f g : ℕ → ℕ} (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, ((u ∘ f ∘ φ) n, (u ∘ g ∘ φ) n) ∈ V n := by\n  rw [cauchySeq_iff_tendsto] at hu\n  exact ((hu.comp <| hf.prod_atTop hg).comp tendsto_atTop_diagonal).subseq_mem hV\n\n-- todo: generalize this and other lemmas to a nonempty semilattice\n"}
{"name":"cauchySeq_iff'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nu : Nat → α\n⊢ Iff (CauchySeq u) (∀ (V : Set (Prod α α)), Membership.mem (uniformity α) V → Filter.Eventually (fun k => Membership.mem (Set.preimage (Prod.map u u) V) k) Filter.atTop)","decl":"theorem cauchySeq_iff' {u : ℕ → α} :\n    CauchySeq u ↔ ∀ V ∈ 𝓤 α, ∀ᶠ k in atTop, k ∈ Prod.map u u ⁻¹' V :=\n  cauchySeq_iff_tendsto\n\n"}
{"name":"cauchySeq_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nu : Nat → α\n⊢ Iff (CauchySeq u) (∀ (V : Set (Prod α α)), Membership.mem (uniformity α) V → Exists fun N => ∀ (k : Nat), GE.ge k N → ∀ (l : Nat), GE.ge l N → Membership.mem V { fst := u k, snd := u l })","decl":"theorem cauchySeq_iff {u : ℕ → α} :\n    CauchySeq u ↔ ∀ V ∈ 𝓤 α, ∃ N, ∀ k ≥ N, ∀ l ≥ N, (u k, u l) ∈ V := by\n  simp only [cauchySeq_iff', Filter.eventually_atTop_prod_self', mem_preimage, Prod.map_apply]\n\n"}
{"name":"CauchySeq.prod_map","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Type u_1\nδ : Type u_2\ninst✝² : UniformSpace β\ninst✝¹ : Preorder γ\ninst✝ : Preorder δ\nu : γ → α\nv : δ → β\nhu : CauchySeq u\nhv : CauchySeq v\n⊢ CauchySeq (Prod.map u v)","decl":"theorem CauchySeq.prod_map {γ δ} [UniformSpace β] [Preorder γ] [Preorder δ] {u : γ → α}\n    {v : δ → β} (hu : CauchySeq u) (hv : CauchySeq v) : CauchySeq (Prod.map u v) := by\n  simpa only [CauchySeq, prod_map_map_eq', prod_atTop_atTop_eq] using hu.prod hv\n\n"}
{"name":"CauchySeq.prod","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Type u_1\ninst✝¹ : UniformSpace β\ninst✝ : Preorder γ\nu : γ → α\nv : γ → β\nhu : CauchySeq u\nhv : CauchySeq v\n⊢ CauchySeq fun x => { fst := u x, snd := v x }","decl":"theorem CauchySeq.prod {γ} [UniformSpace β] [Preorder γ] {u : γ → α} {v : γ → β}\n    (hu : CauchySeq u) (hv : CauchySeq v) : CauchySeq fun x => (u x, v x) :=\n  haveI := hu.1.of_map\n  (Cauchy.prod hu hv).mono (Tendsto.prod_mk le_rfl le_rfl)\n\n"}
{"name":"CauchySeq.eventually_eventually","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : SemilatticeSup β\nu : β → α\nhu : CauchySeq u\nV : Set (Prod α α)\nhV : Membership.mem (uniformity α) V\n⊢ Filter.Eventually (fun k => Filter.Eventually (fun l => Membership.mem V { fst := u k, snd := u l }) Filter.atTop) Filter.atTop","decl":"theorem CauchySeq.eventually_eventually [SemilatticeSup β] {u : β → α} (hu : CauchySeq u)\n    {V : Set (α × α)} (hV : V ∈ 𝓤 α) : ∀ᶠ k in atTop, ∀ᶠ l in atTop, (u k, u l) ∈ V :=\n  eventually_atTop_curry <| hu.tendsto_uniformity hV\n\n"}
{"name":"UniformContinuous.comp_cauchySeq","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Type u_1\ninst✝¹ : UniformSpace β\ninst✝ : Preorder γ\nf : α → β\nhf : UniformContinuous f\nu : γ → α\nhu : CauchySeq u\n⊢ CauchySeq (Function.comp f u)","decl":"theorem UniformContinuous.comp_cauchySeq {γ} [UniformSpace β] [Preorder γ] {f : α → β}\n    (hf : UniformContinuous f) {u : γ → α} (hu : CauchySeq u) : CauchySeq (f ∘ u) :=\n  hu.map hf\n\n"}
{"name":"CauchySeq.subseq_mem","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nV : Nat → Set (Prod α α)\nhV : ∀ (n : Nat), Membership.mem (uniformity α) (V n)\nu : Nat → α\nhu : CauchySeq u\n⊢ Exists fun φ => And (StrictMono φ) (∀ (n : Nat), Membership.mem (V n) { fst := u (φ (HAdd.hAdd n 1)), snd := u (φ n) })","decl":"theorem CauchySeq.subseq_mem {V : ℕ → Set (α × α)} (hV : ∀ n, V n ∈ 𝓤 α) {u : ℕ → α}\n    (hu : CauchySeq u) : ∃ φ : ℕ → ℕ, StrictMono φ ∧ ∀ n, (u <| φ (n + 1), u <| φ n) ∈ V n := by\n  have : ∀ n, ∃ N, ∀ k ≥ N, ∀ l ≥ k, (u l, u k) ∈ V n := fun n => by\n    rw [cauchySeq_iff] at hu\n    rcases hu _ (hV n) with ⟨N, H⟩\n    exact ⟨N, fun k hk l hl => H _ (le_trans hk hl) _ hk⟩\n  obtain ⟨φ : ℕ → ℕ, φ_extr : StrictMono φ, hφ : ∀ n, ∀ l ≥ φ n, (u l, u <| φ n) ∈ V n⟩ :=\n    extraction_forall_of_eventually' this\n  exact ⟨φ, φ_extr, fun n => hφ _ _ (φ_extr <| Nat.lt_add_one n).le⟩\n\n"}
{"name":"Filter.Tendsto.subseq_mem_entourage","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nV : Nat → Set (Prod α α)\nhV : ∀ (n : Nat), Membership.mem (uniformity α) (V n)\nu : Nat → α\na : α\nhu : Filter.Tendsto u Filter.atTop (nhds a)\n⊢ Exists fun φ => And (StrictMono φ) (And (Membership.mem (V 0) { fst := u (φ 0), snd := a }) (∀ (n : Nat), Membership.mem (V (HAdd.hAdd n 1)) { fst := u (φ (HAdd.hAdd n 1)), snd := u (φ n) }))","decl":"theorem Filter.Tendsto.subseq_mem_entourage {V : ℕ → Set (α × α)} (hV : ∀ n, V n ∈ 𝓤 α) {u : ℕ → α}\n    {a : α} (hu : Tendsto u atTop (𝓝 a)) : ∃ φ : ℕ → ℕ, StrictMono φ ∧ (u (φ 0), a) ∈ V 0 ∧\n      ∀ n, (u <| φ (n + 1), u <| φ n) ∈ V (n + 1) := by\n  rcases mem_atTop_sets.1 (hu (ball_mem_nhds a (symm_le_uniformity <| hV 0))) with ⟨n, hn⟩\n  rcases (hu.comp (tendsto_add_atTop_nat n)).cauchySeq.subseq_mem fun n => hV (n + 1) with\n    ⟨φ, φ_mono, hφV⟩\n  exact ⟨fun k => φ k + n, φ_mono.add_const _, hn _ le_add_self, hφV⟩\n\n"}
{"name":"tendsto_nhds_of_cauchySeq_of_subseq","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : Preorder β\nu : β → α\nhu : CauchySeq u\nι : Type u_1\nf : ι → β\np : Filter ι\ninst✝ : p.NeBot\nhf : Filter.Tendsto f p Filter.atTop\na : α\nha : Filter.Tendsto (Function.comp u f) p (nhds a)\n⊢ Filter.Tendsto u Filter.atTop (nhds a)","decl":"/-- If a Cauchy sequence has a convergent subsequence, then it converges. -/\ntheorem tendsto_nhds_of_cauchySeq_of_subseq [Preorder β] {u : β → α} (hu : CauchySeq u)\n    {ι : Type*} {f : ι → β} {p : Filter ι} [NeBot p] (hf : Tendsto f p atTop) {a : α}\n    (ha : Tendsto (u ∘ f) p (𝓝 a)) : Tendsto u atTop (𝓝 a) :=\n  le_nhds_of_cauchy_adhp hu (ha.mapClusterPt.of_comp hf)\n\n"}
{"name":"cauchySeq_shift","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nu : Nat → α\nk : Nat\n⊢ Iff (CauchySeq fun n => u (HAdd.hAdd n k)) (CauchySeq u)","decl":"/-- Any shift of a Cauchy sequence is also a Cauchy sequence. -/\ntheorem cauchySeq_shift {u : ℕ → α} (k : ℕ) : CauchySeq (fun n ↦ u (n + k)) ↔ CauchySeq u := by\n  constructor <;> intro h\n  · rw [cauchySeq_iff] at h ⊢\n    intro V mV\n    obtain ⟨N, h⟩ := h V mV\n    use N + k\n    intro a ha b hb\n    convert h (a - k) (Nat.le_sub_of_add_le ha) (b - k) (Nat.le_sub_of_add_le hb) <;> omega\n  · exact h.comp_tendsto (tendsto_add_atTop_nat k)\n\n"}
{"name":"Filter.HasBasis.cauchySeq_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Sort u_1\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\np : γ → Prop\ns : γ → Set (Prod α α)\nh : (uniformity α).HasBasis p s\n⊢ Iff (CauchySeq u) (∀ (i : γ), p i → Exists fun N => ∀ (m : β), LE.le N m → ∀ (n : β), LE.le N n → Membership.mem (s i) { fst := u m, snd := u n })","decl":"theorem Filter.HasBasis.cauchySeq_iff {γ} [Nonempty β] [SemilatticeSup β] {u : β → α} {p : γ → Prop}\n    {s : γ → Set (α × α)} (h : (𝓤 α).HasBasis p s) :\n    CauchySeq u ↔ ∀ i, p i → ∃ N, ∀ m, N ≤ m → ∀ n, N ≤ n → (u m, u n) ∈ s i := by\n  rw [cauchySeq_iff_tendsto, ← prod_atTop_atTop_eq]\n  refine (atTop_basis.prod_self.tendsto_iff h).trans ?_\n  simp only [exists_prop, true_and, MapsTo, preimage, subset_def, Prod.forall, mem_prod_eq,\n    mem_setOf_eq, mem_Ici, and_imp, Prod.map, @forall_swap (_ ≤ _) β]\n\n"}
{"name":"Filter.HasBasis.cauchySeq_iff'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\nγ : Sort u_1\ninst✝¹ : Nonempty β\ninst✝ : SemilatticeSup β\nu : β → α\np : γ → Prop\ns : γ → Set (Prod α α)\nH : (uniformity α).HasBasis p s\n⊢ Iff (CauchySeq u) (∀ (i : γ), p i → Exists fun N => ∀ (n : β), GE.ge n N → Membership.mem (s i) { fst := u n, snd := u N })","decl":"theorem Filter.HasBasis.cauchySeq_iff' {γ} [Nonempty β] [SemilatticeSup β] {u : β → α}\n    {p : γ → Prop} {s : γ → Set (α × α)} (H : (𝓤 α).HasBasis p s) :\n    CauchySeq u ↔ ∀ i, p i → ∃ N, ∀ n ≥ N, (u n, u N) ∈ s i := by\n  refine H.cauchySeq_iff.trans ⟨fun h i hi => ?_, fun h i hi => ?_⟩\n  · exact (h i hi).imp fun N hN n hn => hN n hn N le_rfl\n  · rcases comp_symm_of_uniformity (H.mem_of_mem hi) with ⟨t, ht, ht', hts⟩\n    rcases H.mem_iff.1 ht with ⟨j, hj, hjt⟩\n    refine (h j hj).imp fun N hN m hm n hn => hts ⟨u N, hjt ?_, ht' <| hjt ?_⟩\n    exacts [hN m hm, hN n hn]\n\n"}
{"name":"cauchySeq_of_controlled","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : SemilatticeSup β\ninst✝ : Nonempty β\nU : β → Set (Prod α α)\nhU : ∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun n => HasSubset.Subset (U n) s\nf : β → α\nhf : ∀ ⦃N m n : β⦄, LE.le N m → LE.le N n → Membership.mem (U N) { fst := f m, snd := f n }\n⊢ CauchySeq f","decl":"theorem cauchySeq_of_controlled [SemilatticeSup β] [Nonempty β] (U : β → Set (α × α))\n    (hU : ∀ s ∈ 𝓤 α, ∃ n, U n ⊆ s) {f : β → α}\n    (hf : ∀ ⦃N m n : β⦄, N ≤ m → N ≤ n → (f m, f n) ∈ U N) : CauchySeq f :=\n    -- Porting note: changed to semi-implicit arguments\n  cauchySeq_iff_tendsto.2\n    (by\n      intro s hs\n      rw [mem_map, mem_atTop_sets]\n      cases' hU s hs with N hN\n      refine ⟨(N, N), fun mn hmn => ?_⟩\n      cases' mn with m n\n      exact hN (hf hmn.1 hmn.2))\n\n"}
{"name":"isComplete_iff_clusterPt","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (IsComplete s) (∀ (l : Filter α), Cauchy l → LE.le l (Filter.principal s) → Exists fun x => And (Membership.mem s x) (ClusterPt x l))","decl":"theorem isComplete_iff_clusterPt {s : Set α} :\n    IsComplete s ↔ ∀ l, Cauchy l → l ≤ 𝓟 s → ∃ x ∈ s, ClusterPt x l :=\n  forall₃_congr fun _ hl _ => exists_congr fun _ => and_congr_right fun _ =>\n    le_nhds_iff_adhp_of_cauchy hl\n\n"}
{"name":"isComplete_iff_ultrafilter","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (IsComplete s) (∀ (l : Ultrafilter α), Cauchy ↑l → LE.le (↑l) (Filter.principal s) → Exists fun x => And (Membership.mem s x) (LE.le (↑l) (nhds x)))","decl":"theorem isComplete_iff_ultrafilter {s : Set α} :\n    IsComplete s ↔ ∀ l : Ultrafilter α, Cauchy (l : Filter α) → ↑l ≤ 𝓟 s → ∃ x ∈ s, ↑l ≤ 𝓝 x := by\n  refine ⟨fun h l => h l, fun H => isComplete_iff_clusterPt.2 fun l hl hls => ?_⟩\n  haveI := hl.1\n  rcases H (Ultrafilter.of l) hl.ultrafilter_of ((Ultrafilter.of_le l).trans hls) with ⟨x, hxs, hxl⟩\n  exact ⟨x, hxs, (ClusterPt.of_le_nhds hxl).mono (Ultrafilter.of_le l)⟩\n\n"}
{"name":"isComplete_iff_ultrafilter'","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (IsComplete s) (∀ (l : Ultrafilter α), Cauchy ↑l → Membership.mem l s → Exists fun x => And (Membership.mem s x) (LE.le (↑l) (nhds x)))","decl":"theorem isComplete_iff_ultrafilter' {s : Set α} :\n    IsComplete s ↔ ∀ l : Ultrafilter α, Cauchy (l : Filter α) → s ∈ l → ∃ x ∈ s, ↑l ≤ 𝓝 x :=\n  isComplete_iff_ultrafilter.trans <| by simp only [le_principal_iff, Ultrafilter.mem_coe]\n\n"}
{"name":"IsComplete.union","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns t : Set α\nhs : IsComplete s\nht : IsComplete t\n⊢ IsComplete (Union.union s t)","decl":"protected theorem IsComplete.union {s t : Set α} (hs : IsComplete s) (ht : IsComplete t) :\n    IsComplete (s ∪ t) := by\n  simp only [isComplete_iff_ultrafilter', Ultrafilter.union_mem_iff, or_imp] at *\n  exact fun l hl =>\n    ⟨fun hsl => (hs l hl hsl).imp fun x hx => ⟨Or.inl hx.1, hx.2⟩, fun htl =>\n      (ht l hl htl).imp fun x hx => ⟨Or.inr hx.1, hx.2⟩⟩\n\n"}
{"name":"isComplete_iUnion_separated","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nι : Sort u_1\ns : ι → Set α\nhs : ∀ (i : ι), IsComplete (s i)\nU : Set (Prod α α)\nhU : Membership.mem (uniformity α) U\nhd : ∀ (i j : ι) (x : α), Membership.mem (s i) x → ∀ (y : α), Membership.mem (s j) y → Membership.mem U { fst := x, snd := y } → Eq i j\n⊢ IsComplete (Set.iUnion fun i => s i)","decl":"theorem isComplete_iUnion_separated {ι : Sort*} {s : ι → Set α} (hs : ∀ i, IsComplete (s i))\n    {U : Set (α × α)} (hU : U ∈ 𝓤 α) (hd : ∀ (i j : ι), ∀ x ∈ s i, ∀ y ∈ s j, (x, y) ∈ U → i = j) :\n    IsComplete (⋃ i, s i) := by\n  set S := ⋃ i, s i\n  intro l hl hls\n  rw [le_principal_iff] at hls\n  cases' cauchy_iff.1 hl with hl_ne hl'\n  obtain ⟨t, htS, htl, htU⟩ : ∃ t, t ⊆ S ∧ t ∈ l ∧ t ×ˢ t ⊆ U := by\n    rcases hl' U hU with ⟨t, htl, htU⟩\n    refine ⟨t ∩ S, inter_subset_right, inter_mem htl hls, Subset.trans ?_ htU⟩\n    gcongr <;> apply inter_subset_left\n  obtain ⟨i, hi⟩ : ∃ i, t ⊆ s i := by\n    rcases Filter.nonempty_of_mem htl with ⟨x, hx⟩\n    rcases mem_iUnion.1 (htS hx) with ⟨i, hi⟩\n    refine ⟨i, fun y hy => ?_⟩\n    rcases mem_iUnion.1 (htS hy) with ⟨j, hj⟩\n    rwa [hd i j x hi y hj (htU <| mk_mem_prod hx hy)]\n  rcases hs i l hl (le_principal_iff.2 <| mem_of_superset htl hi) with ⟨x, hxs, hlx⟩\n  exact ⟨x, mem_iUnion.2 ⟨i, hxs⟩, hlx⟩\n\n"}
{"name":"CompleteSpace.complete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\ninst✝ : UniformSpace α\nself : CompleteSpace α\nf : Filter α\na✝ : Cauchy f\n⊢ Exists fun x => LE.le f (nhds x)","decl":"/-- A complete space is defined here using uniformities. A uniform space\n  is complete if every Cauchy filter converges. -/\nclass CompleteSpace (α : Type u) [UniformSpace α] : Prop where\n  /-- In a complete uniform space, every Cauchy filter converges. -/\n  complete : ∀ {f : Filter α}, Cauchy f → ∃ x, f ≤ 𝓝 x\n\n"}
{"name":"complete_univ","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\ninst✝¹ : UniformSpace α\ninst✝ : CompleteSpace α\n⊢ IsComplete Set.univ","decl":"theorem complete_univ {α : Type u} [UniformSpace α] [CompleteSpace α] :\n    IsComplete (univ : Set α) := fun f hf _ => by\n  rcases CompleteSpace.complete hf with ⟨x, hx⟩\n  exact ⟨x, mem_univ x, hx⟩\n\n"}
{"name":"CompleteSpace.prod","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : CompleteSpace α\ninst✝ : CompleteSpace β\n⊢ CompleteSpace (Prod α β)","decl":"instance CompleteSpace.prod [UniformSpace β] [CompleteSpace α] [CompleteSpace β] :\n    CompleteSpace (α × β) where\n  complete hf :=\n    let ⟨x1, hx1⟩ := CompleteSpace.complete <| hf.map uniformContinuous_fst\n    let ⟨x2, hx2⟩ := CompleteSpace.complete <| hf.map uniformContinuous_snd\n    ⟨(x1, x2), by rw [nhds_prod_eq, le_prod]; constructor <;> assumption⟩\n\n"}
{"name":"CompleteSpace.fst_of_prod","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : UniformSpace β\ninst✝ : CompleteSpace (Prod α β)\nh : Nonempty β\n⊢ CompleteSpace α","decl":"lemma CompleteSpace.fst_of_prod [UniformSpace β] [CompleteSpace (α × β)] [h : Nonempty β] :\n    CompleteSpace α where\n  complete hf :=\n    let ⟨y⟩ := h\n    let ⟨(a, b), hab⟩ := CompleteSpace.complete <| hf.prod <| cauchy_pure (a := y)\n    ⟨a, by simpa only [map_fst_prod, nhds_prod_eq] using map_mono (m := Prod.fst) hab⟩\n\n"}
{"name":"CompleteSpace.snd_of_prod","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : UniformSpace β\ninst✝ : CompleteSpace (Prod α β)\nh : Nonempty α\n⊢ CompleteSpace β","decl":"lemma CompleteSpace.snd_of_prod [UniformSpace β] [CompleteSpace (α × β)] [h : Nonempty α] :\n    CompleteSpace β where\n  complete hf :=\n    let ⟨x⟩ := h\n    let ⟨(a, b), hab⟩ := CompleteSpace.complete <| (cauchy_pure (a := x)).prod hf\n    ⟨b, by simpa only [map_snd_prod, nhds_prod_eq] using map_mono (m := Prod.snd) hab⟩\n\n"}
{"name":"completeSpace_prod_of_nonempty","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\n⊢ Iff (CompleteSpace (Prod α β)) (And (CompleteSpace α) (CompleteSpace β))","decl":"lemma completeSpace_prod_of_nonempty [UniformSpace β] [Nonempty α] [Nonempty β] :\n    CompleteSpace (α × β) ↔ CompleteSpace α ∧ CompleteSpace β :=\n  ⟨fun _ ↦ ⟨.fst_of_prod (β := β), .snd_of_prod (α := α)⟩, fun ⟨_, _⟩ ↦ .prod⟩\n\n"}
{"name":"CompleteSpace.addOpposite","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : CompleteSpace α\n⊢ CompleteSpace (AddOpposite α)","decl":"@[to_additive]\ninstance CompleteSpace.mulOpposite [CompleteSpace α] : CompleteSpace αᵐᵒᵖ where\n  complete hf :=\n    MulOpposite.op_surjective.exists.mpr <|\n      let ⟨x, hx⟩ := CompleteSpace.complete (hf.map MulOpposite.uniformContinuous_unop)\n      ⟨x, (map_le_iff_le_comap.mp hx).trans_eq <| MulOpposite.comap_unop_nhds _⟩\n\n"}
{"name":"CompleteSpace.mulOpposite","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : CompleteSpace α\n⊢ CompleteSpace (MulOpposite α)","decl":"@[to_additive]\ninstance CompleteSpace.mulOpposite [CompleteSpace α] : CompleteSpace αᵐᵒᵖ where\n  complete hf :=\n    MulOpposite.op_surjective.exists.mpr <|\n      let ⟨x, hx⟩ := CompleteSpace.complete (hf.map MulOpposite.uniformContinuous_unop)\n      ⟨x, (map_le_iff_le_comap.mp hx).trans_eq <| MulOpposite.comap_unop_nhds _⟩\n\n"}
{"name":"completeSpace_of_isComplete_univ","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nh : IsComplete Set.univ\n⊢ CompleteSpace α","decl":"/-- If `univ` is complete, the space is a complete space -/\ntheorem completeSpace_of_isComplete_univ (h : IsComplete (univ : Set α)) : CompleteSpace α :=\n  ⟨fun hf => let ⟨x, _, hx⟩ := h _ hf ((@principal_univ α).symm ▸ le_top); ⟨x, hx⟩⟩\n\n"}
{"name":"completeSpace_iff_isComplete_univ","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\n⊢ Iff (CompleteSpace α) (IsComplete Set.univ)","decl":"theorem completeSpace_iff_isComplete_univ : CompleteSpace α ↔ IsComplete (univ : Set α) :=\n  ⟨@complete_univ α _, completeSpace_of_isComplete_univ⟩\n\n"}
{"name":"completeSpace_iff_ultrafilter","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\n⊢ Iff (CompleteSpace α) (∀ (l : Ultrafilter α), Cauchy ↑l → Exists fun x => LE.le (↑l) (nhds x))","decl":"theorem completeSpace_iff_ultrafilter :\n    CompleteSpace α ↔ ∀ l : Ultrafilter α, Cauchy (l : Filter α) → ∃ x : α, ↑l ≤ 𝓝 x := by\n  simp [completeSpace_iff_isComplete_univ, isComplete_iff_ultrafilter]\n\n"}
{"name":"cauchy_iff_exists_le_nhds","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝¹ : CompleteSpace α\nl : Filter α\ninst✝ : l.NeBot\n⊢ Iff (Cauchy l) (Exists fun x => LE.le l (nhds x))","decl":"theorem cauchy_iff_exists_le_nhds [CompleteSpace α] {l : Filter α} [NeBot l] :\n    Cauchy l ↔ ∃ x, l ≤ 𝓝 x :=\n  ⟨CompleteSpace.complete, fun ⟨_, hx⟩ => cauchy_nhds.mono hx⟩\n\n"}
{"name":"cauchy_map_iff_exists_tendsto","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : CompleteSpace α\nl : Filter β\nf : β → α\ninst✝ : l.NeBot\n⊢ Iff (Cauchy (Filter.map f l)) (Exists fun x => Filter.Tendsto f l (nhds x))","decl":"theorem cauchy_map_iff_exists_tendsto [CompleteSpace α] {l : Filter β} {f : β → α} [NeBot l] :\n    Cauchy (l.map f) ↔ ∃ x, Tendsto f l (𝓝 x) :=\n  cauchy_iff_exists_le_nhds\n\n"}
{"name":"cauchySeq_tendsto_of_complete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : Preorder β\ninst✝ : CompleteSpace α\nu : β → α\nH : CauchySeq u\n⊢ Exists fun x => Filter.Tendsto u Filter.atTop (nhds x)","decl":"/-- A Cauchy sequence in a complete space converges -/\ntheorem cauchySeq_tendsto_of_complete [Preorder β] [CompleteSpace α] {u : β → α}\n    (H : CauchySeq u) : ∃ x, Tendsto u atTop (𝓝 x) :=\n  CompleteSpace.complete H\n\n"}
{"name":"cauchySeq_tendsto_of_isComplete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : Preorder β\nK : Set α\nh₁ : IsComplete K\nu : β → α\nh₂ : ∀ (n : β), Membership.mem K (u n)\nh₃ : CauchySeq u\n⊢ Exists fun v => And (Membership.mem K v) (Filter.Tendsto u Filter.atTop (nhds v))","decl":"/-- If `K` is a complete subset, then any cauchy sequence in `K` converges to a point in `K` -/\ntheorem cauchySeq_tendsto_of_isComplete [Preorder β] {K : Set α} (h₁ : IsComplete K)\n    {u : β → α} (h₂ : ∀ n, u n ∈ K) (h₃ : CauchySeq u) : ∃ v ∈ K, Tendsto u atTop (𝓝 v) :=\n  h₁ _ h₃ <| le_principal_iff.2 <| mem_map_iff_exists_image.2\n    ⟨univ, univ_mem, by rwa [image_univ, range_subset_iff]⟩\n\n"}
{"name":"Cauchy.le_nhds_lim","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : CompleteSpace α\nf : Filter α\nhf : Cauchy f\n⊢ LE.le f (nhds (lim f))","decl":"theorem Cauchy.le_nhds_lim [CompleteSpace α] {f : Filter α} (hf : Cauchy f) :\n    haveI := hf.1.nonempty; f ≤ 𝓝 (lim f) :=\n  _root_.le_nhds_lim (CompleteSpace.complete hf)\n\n"}
{"name":"CauchySeq.tendsto_limUnder","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝¹ : Preorder β\ninst✝ : CompleteSpace α\nu : β → α\nh : CauchySeq u\n⊢ Filter.Tendsto u Filter.atTop (nhds (limUnder Filter.atTop u))","decl":"theorem CauchySeq.tendsto_limUnder [Preorder β] [CompleteSpace α] {u : β → α} (h : CauchySeq u) :\n    haveI := h.1.nonempty; Tendsto u atTop (𝓝 <| limUnder atTop u) :=\n  h.le_nhds_lim\n\n"}
{"name":"IsClosed.isComplete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : CompleteSpace α\ns : Set α\nh : IsClosed s\n⊢ IsComplete s","decl":"theorem IsClosed.isComplete [CompleteSpace α] {s : Set α} (h : IsClosed s) : IsComplete s :=\n  fun _ cf fs =>\n  let ⟨x, hx⟩ := CompleteSpace.complete cf\n  ⟨x, isClosed_iff_clusterPt.mp h x (cf.left.mono (le_inf hx fs)), hx⟩\n\n"}
{"name":"TotallyBounded.exists_subset","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nhs : TotallyBounded s\nU : Set (Prod α α)\nhU : Membership.mem (uniformity α) U\n⊢ Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => setOf fun x => Membership.mem U { fst := x, snd := y })))","decl":"theorem TotallyBounded.exists_subset {s : Set α} (hs : TotallyBounded s) {U : Set (α × α)}\n    (hU : U ∈ 𝓤 α) : ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ y ∈ t, { x | (x, y) ∈ U } := by\n  rcases comp_symm_of_uniformity hU with ⟨r, hr, rs, rU⟩\n  rcases hs r hr with ⟨k, fk, ks⟩\n  let u := k ∩ { y | ∃ x ∈ s, (x, y) ∈ r }\n  choose f hfs hfr using fun x : u => x.coe_prop.2\n  refine ⟨range f, ?_, ?_, ?_⟩\n  · exact range_subset_iff.2 hfs\n  · haveI : Fintype u := (fk.inter_of_left _).fintype\n    exact finite_range f\n  · intro x xs\n    obtain ⟨y, hy, xy⟩ := mem_iUnion₂.1 (ks xs)\n    rw [biUnion_range, mem_iUnion]\n    set z : ↥u := ⟨y, hy, ⟨x, xs, xy⟩⟩\n    exact ⟨z, rU <| mem_compRel.2 ⟨y, xy, rs (hfr z)⟩⟩\n\n"}
{"name":"totallyBounded_iff_subset","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (d : Set (Prod α α)), Membership.mem (uniformity α) d → Exists fun t => And (HasSubset.Subset t s) (And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => setOf fun x => Membership.mem d { fst := x, snd := y }))))","decl":"theorem totallyBounded_iff_subset {s : Set α} :\n    TotallyBounded s ↔\n      ∀ d ∈ 𝓤 α, ∃ t, t ⊆ s ∧ Set.Finite t ∧ s ⊆ ⋃ y ∈ t, { x | (x, y) ∈ d } :=\n  ⟨fun H _ hd ↦ H.exists_subset hd, fun H d hd ↦ let ⟨t, _, ht⟩ := H d hd; ⟨t, ht⟩⟩\n\n"}
{"name":"Filter.HasBasis.totallyBounded_iff","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nι : Sort u_1\np : ι → Prop\nU : ι → Set (Prod α α)\nH : (uniformity α).HasBasis p U\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (i : ι), p i → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => setOf fun x => Membership.mem (U i) { fst := x, snd := y })))","decl":"theorem Filter.HasBasis.totallyBounded_iff {ι} {p : ι → Prop} {U : ι → Set (α × α)}\n    (H : (𝓤 α).HasBasis p U) {s : Set α} :\n    TotallyBounded s ↔ ∀ i, p i → ∃ t : Set α, Set.Finite t ∧ s ⊆ ⋃ y ∈ t, { x | (x, y) ∈ U i } :=\n  H.forall_iff fun _ _ hUV h =>\n    h.imp fun _ ht => ⟨ht.1, ht.2.trans <| iUnion₂_mono fun _ _ _ hy => hUV hy⟩\n\n"}
{"name":"totallyBounded_of_forall_symm","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nh : ∀ (V : Set (Prod α α)), Membership.mem (uniformity α) V → SymmetricRel V → Exists fun t => And t.Finite (HasSubset.Subset s (Set.iUnion fun y => Set.iUnion fun h => UniformSpace.ball y V))\n⊢ TotallyBounded s","decl":"theorem totallyBounded_of_forall_symm {s : Set α}\n    (h : ∀ V ∈ 𝓤 α, SymmetricRel V → ∃ t : Set α, Set.Finite t ∧ s ⊆ ⋃ y ∈ t, ball y V) :\n    TotallyBounded s :=\n  UniformSpace.hasBasis_symmetric.totallyBounded_iff.2 fun V hV => by\n    simpa only [ball_eq_of_symmetry hV.2] using h V hV.1 hV.2\n\n"}
{"name":"TotallyBounded.subset","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns₁ s₂ : Set α\nhs : HasSubset.Subset s₁ s₂\nh : TotallyBounded s₂\n⊢ TotallyBounded s₁","decl":"theorem TotallyBounded.subset {s₁ s₂ : Set α} (hs : s₁ ⊆ s₂) (h : TotallyBounded s₂) :\n    TotallyBounded s₁ := fun d hd =>\n  let ⟨t, ht₁, ht₂⟩ := h d hd\n  ⟨t, ht₁, Subset.trans hs ht₂⟩\n\n"}
{"name":"TotallyBounded.closure","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nh : TotallyBounded s\n⊢ TotallyBounded (closure s)","decl":"/-- The closure of a totally bounded set is totally bounded. -/\ntheorem TotallyBounded.closure {s : Set α} (h : TotallyBounded s) : TotallyBounded (closure s) :=\n  uniformity_hasBasis_closed.totallyBounded_iff.2 fun V hV =>\n    let ⟨t, htf, hst⟩ := h V hV.1\n    ⟨t, htf,\n      closure_minimal hst <|\n        htf.isClosed_biUnion fun _ _ => hV.2.preimage (continuous_id.prod_mk continuous_const)⟩\n\n"}
{"name":"totallyBounded_closure","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (TotallyBounded (closure s)) (TotallyBounded s)","decl":"@[simp]\nlemma totallyBounded_closure {s : Set α} : TotallyBounded (closure s) ↔ TotallyBounded s :=\n  ⟨fun h ↦ h.subset subset_closure, TotallyBounded.closure⟩\n\n"}
{"name":"totallyBounded_iUnion","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nι : Sort u_1\ninst✝ : Finite ι\ns : ι → Set α\n⊢ Iff (TotallyBounded (Set.iUnion fun i => s i)) (∀ (i : ι), TotallyBounded (s i))","decl":"/-- A finite indexed union is totally bounded\nif and only if each set of the family is totally bounded. -/\n@[simp]\nlemma totallyBounded_iUnion {ι : Sort*} [Finite ι] {s : ι → Set α} :\n    TotallyBounded (⋃ i, s i) ↔ ∀ i, TotallyBounded (s i) := by\n  refine ⟨fun h i ↦ h.subset (subset_iUnion _ _), fun h U hU ↦ ?_⟩\n  choose t htf ht using (h · U hU)\n  refine ⟨⋃ i, t i, finite_iUnion htf, ?_⟩\n  rw [biUnion_iUnion]\n  gcongr; apply ht\n\n"}
{"name":"totallyBounded_biUnion","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nι : Type u_1\nI : Set ι\nhI : I.Finite\ns : ι → Set α\n⊢ Iff (TotallyBounded (Set.iUnion fun i => Set.iUnion fun h => s i)) (∀ (i : ι), Membership.mem I i → TotallyBounded (s i))","decl":"/-- A union indexed by a finite set is totally bounded\nif and only if each set of the family is totally bounded. -/\nlemma totallyBounded_biUnion {ι : Type*} {I : Set ι} (hI : I.Finite) {s : ι → Set α} :\n    TotallyBounded (⋃ i ∈ I, s i) ↔ ∀ i ∈ I, TotallyBounded (s i) := by\n  have := hI.to_subtype\n  rw [biUnion_eq_iUnion, totallyBounded_iUnion, Subtype.forall]\n\n"}
{"name":"totallyBounded_sUnion","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nS : Set (Set α)\nhS : S.Finite\n⊢ Iff (TotallyBounded S.sUnion) (∀ (s : Set α), Membership.mem S s → TotallyBounded s)","decl":"/-- A union of a finite family of sets is totally bounded\nif and only if each set of the family is totally bounded. -/\nlemma totallyBounded_sUnion {S : Set (Set α)} (hS : S.Finite) :\n    TotallyBounded (⋃₀ S) ↔ ∀ s ∈ S, TotallyBounded s := by\n  rw [sUnion_eq_biUnion, totallyBounded_biUnion hS]\n\n"}
{"name":"Set.Finite.totallyBounded","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nhs : s.Finite\n⊢ TotallyBounded s","decl":"/-- A finite set is totally bounded. -/\nlemma Set.Finite.totallyBounded {s : Set α} (hs : s.Finite) : TotallyBounded s := fun _U hU ↦\n  ⟨s, hs, fun _x hx ↦ mem_biUnion hx <| refl_mem_uniformity hU⟩\n\n"}
{"name":"Set.Subsingleton.totallyBounded","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nhs : s.Subsingleton\n⊢ TotallyBounded s","decl":"/-- A subsingleton is totally bounded. -/\nlemma Set.Subsingleton.totallyBounded {s : Set α} (hs : s.Subsingleton) :\n    TotallyBounded s :=\n  hs.finite.totallyBounded\n\n"}
{"name":"totallyBounded_singleton","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\na : α\n⊢ TotallyBounded (Singleton.singleton a)","decl":"@[simp]\nlemma totallyBounded_singleton (a : α) : TotallyBounded {a} := (finite_singleton a).totallyBounded\n\n"}
{"name":"totallyBounded_empty","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\n⊢ TotallyBounded EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem totallyBounded_empty : TotallyBounded (∅ : Set α) := finite_empty.totallyBounded\n\n"}
{"name":"totallyBounded_union","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns t : Set α\n⊢ Iff (TotallyBounded (Union.union s t)) (And (TotallyBounded s) (TotallyBounded t))","decl":"/-- The union of two sets is totally bounded\nif and only if each of the two sets is totally bounded.-/\n@[simp]\nlemma totallyBounded_union {s t : Set α} :\n    TotallyBounded (s ∪ t) ↔ TotallyBounded s ∧ TotallyBounded t := by\n  rw [union_eq_iUnion, totallyBounded_iUnion]\n  simp [and_comm]\n\n"}
{"name":"TotallyBounded.union","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns t : Set α\nhs : TotallyBounded s\nht : TotallyBounded t\n⊢ TotallyBounded (Union.union s t)","decl":"/-- The union of two totally bounded sets is totally bounded. -/\nprotected lemma TotallyBounded.union {s t : Set α} (hs : TotallyBounded s) (ht : TotallyBounded t) :\n    TotallyBounded (s ∪ t) :=\n  totallyBounded_union.2 ⟨hs, ht⟩\n\n"}
{"name":"totallyBounded_insert","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\na : α\ns : Set α\n⊢ Iff (TotallyBounded (Insert.insert a s)) (TotallyBounded s)","decl":"@[simp]\nlemma totallyBounded_insert (a : α) {s : Set α} :\n    TotallyBounded (insert a s) ↔ TotallyBounded s := by\n  simp_rw [← singleton_union, totallyBounded_union, totallyBounded_singleton, true_and]\n\n"}
{"name":"TotallyBounded.insert","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\na : α\ns : Set α\na✝ : TotallyBounded s\n⊢ TotallyBounded (Insert.insert a s)","decl":"protected alias ⟨_, TotallyBounded.insert⟩ := totallyBounded_insert\n\n"}
{"name":"TotallyBounded.image","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nβ : Type v\nuniformSpace : UniformSpace α\ninst✝ : UniformSpace β\nf : α → β\ns : Set α\nhs : TotallyBounded s\nhf : UniformContinuous f\n⊢ TotallyBounded (Set.image f s)","decl":"/-- The image of a totally bounded set under a uniformly continuous map is totally bounded. -/\ntheorem TotallyBounded.image [UniformSpace β] {f : α → β} {s : Set α} (hs : TotallyBounded s)\n    (hf : UniformContinuous f) : TotallyBounded (f '' s) := fun t ht =>\n  have : { p : α × α | (f p.1, f p.2) ∈ t } ∈ 𝓤 α := hf ht\n  let ⟨c, hfc, hct⟩ := hs _ this\n  ⟨f '' c, hfc.image f, by\n    simp only [mem_image, iUnion_exists, biUnion_and', iUnion_iUnion_eq_right, image_subset_iff,\n      preimage_iUnion, preimage_setOf_eq]\n    simp? [subset_def] at hct says\n      simp only [mem_setOf_eq, subset_def, mem_iUnion, exists_prop] at hct\n    intro x hx\n    simpa using hct x hx⟩\n\n"}
{"name":"Ultrafilter.cauchy_of_totallyBounded","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nf : Ultrafilter α\nhs : TotallyBounded s\nh : LE.le (↑f) (Filter.principal s)\n⊢ Cauchy ↑f","decl":"theorem Ultrafilter.cauchy_of_totallyBounded {s : Set α} (f : Ultrafilter α) (hs : TotallyBounded s)\n    (h : ↑f ≤ 𝓟 s) : Cauchy (f : Filter α) :=\n  ⟨f.neBot', fun _ ht =>\n    let ⟨t', ht'₁, ht'_symm, ht'_t⟩ := comp_symm_of_uniformity ht\n    let ⟨i, hi, hs_union⟩ := hs t' ht'₁\n    have : (⋃ y ∈ i, { x | (x, y) ∈ t' }) ∈ f := mem_of_superset (le_principal_iff.mp h) hs_union\n    have : ∃ y ∈ i, { x | (x, y) ∈ t' } ∈ f := (Ultrafilter.finite_biUnion_mem_iff hi).1 this\n    let ⟨y, _, hif⟩ := this\n    have : { x | (x, y) ∈ t' } ×ˢ { x | (x, y) ∈ t' } ⊆ compRel t' t' :=\n      fun ⟨_, _⟩ ⟨(h₁ : (_, y) ∈ t'), (h₂ : (_, y) ∈ t')⟩ => ⟨y, h₁, ht'_symm h₂⟩\n    mem_of_superset (prod_mem_prod hif hif) (Subset.trans this ht'_t)⟩\n\n"}
{"name":"totallyBounded_iff_filter","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (f : Filter α), f.NeBot → LE.le f (Filter.principal s) → Exists fun c => And (LE.le c f) (Cauchy c))","decl":"theorem totallyBounded_iff_filter {s : Set α} :\n    TotallyBounded s ↔ ∀ f, NeBot f → f ≤ 𝓟 s → ∃ c ≤ f, Cauchy c := by\n  constructor\n  · exact fun H f hf hfs => ⟨Ultrafilter.of f, Ultrafilter.of_le f,\n      (Ultrafilter.of f).cauchy_of_totallyBounded H ((Ultrafilter.of_le f).trans hfs)⟩\n  · intro H d hd\n    contrapose! H with hd_cover\n    set f := ⨅ t : Finset α, 𝓟 (s \\ ⋃ y ∈ t, { x | (x, y) ∈ d })\n    have hb : HasAntitoneBasis f fun t : Finset α ↦ s \\ ⋃ y ∈ t, { x | (x, y) ∈ d } :=\n      .iInf_principal fun _ _ ↦ diff_subset_diff_right ∘ biUnion_subset_biUnion_left\n    have : Filter.NeBot f := hb.1.neBot_iff.2 fun _ ↦\n      diff_nonempty.2 <| hd_cover _ (Finset.finite_toSet _)\n    have : f ≤ 𝓟 s := iInf_le_of_le ∅ (by simp)\n    refine ⟨f, ‹_›, ‹_›, fun c hcf hc => ?_⟩\n    rcases mem_prod_same_iff.1 (hc.2 hd) with ⟨m, hm, hmd⟩\n    rcases hc.1.nonempty_of_mem hm with ⟨y, hym⟩\n    have : s \\ {x | (x, y) ∈ d} ∈ c := by simpa using hcf (hb.mem {y})\n    rcases hc.1.nonempty_of_mem (inter_mem hm this) with ⟨z, hzm, -, hyz⟩\n    exact hyz (hmd ⟨hzm, hym⟩)\n\n"}
{"name":"totallyBounded_iff_ultrafilter","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (TotallyBounded s) (∀ (f : Ultrafilter α), LE.le (↑f) (Filter.principal s) → Cauchy ↑f)","decl":"theorem totallyBounded_iff_ultrafilter {s : Set α} :\n    TotallyBounded s ↔ ∀ f : Ultrafilter α, ↑f ≤ 𝓟 s → Cauchy (f : Filter α) := by\n  refine ⟨fun hs f => f.cauchy_of_totallyBounded hs, fun H => totallyBounded_iff_filter.2 ?_⟩\n  intro f hf hfs\n  exact ⟨Ultrafilter.of f, Ultrafilter.of_le f, H _ ((Ultrafilter.of_le f).trans hfs)⟩\n\n"}
{"name":"isCompact_iff_totallyBounded_isComplete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\n⊢ Iff (IsCompact s) (And (TotallyBounded s) (IsComplete s))","decl":"theorem isCompact_iff_totallyBounded_isComplete {s : Set α} :\n    IsCompact s ↔ TotallyBounded s ∧ IsComplete s :=\n  ⟨fun hs =>\n    ⟨totallyBounded_iff_ultrafilter.2 fun f hf =>\n        let ⟨_, _, fx⟩ := isCompact_iff_ultrafilter_le_nhds.1 hs f hf\n        cauchy_nhds.mono fx,\n      fun f fc fs =>\n      let ⟨a, as, fa⟩ := @hs f fc.1 fs\n      ⟨a, as, le_nhds_of_cauchy_adhp fc fa⟩⟩,\n    fun ⟨ht, hc⟩ =>\n    isCompact_iff_ultrafilter_le_nhds.2 fun f hf =>\n      hc _ (totallyBounded_iff_ultrafilter.1 ht f hf) hf⟩\n\n"}
{"name":"IsCompact.totallyBounded","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nh : IsCompact s\n⊢ TotallyBounded s","decl":"protected theorem IsCompact.totallyBounded {s : Set α} (h : IsCompact s) : TotallyBounded s :=\n  (isCompact_iff_totallyBounded_isComplete.1 h).1\n\n"}
{"name":"IsCompact.isComplete","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Set α\nh : IsCompact s\n⊢ IsComplete s","decl":"protected theorem IsCompact.isComplete {s : Set α} (h : IsCompact s) : IsComplete s :=\n  (isCompact_iff_totallyBounded_isComplete.1 h).2\n\n-- see Note [lower instance priority]\n"}
{"name":"complete_of_compact","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\ninst✝¹ : UniformSpace α\ninst✝ : CompactSpace α\n⊢ CompleteSpace α","decl":"instance (priority := 100) complete_of_compact {α : Type u} [UniformSpace α] [CompactSpace α] :\n    CompleteSpace α :=\n  ⟨fun hf => by simpa using (isCompact_iff_totallyBounded_isComplete.1 isCompact_univ).2 _ hf⟩\n\n"}
{"name":"isCompact_of_totallyBounded_isClosed","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : CompleteSpace α\ns : Set α\nht : TotallyBounded s\nhc : IsClosed s\n⊢ IsCompact s","decl":"theorem isCompact_of_totallyBounded_isClosed [CompleteSpace α] {s : Set α} (ht : TotallyBounded s)\n    (hc : IsClosed s) : IsCompact s :=\n  (@isCompact_iff_totallyBounded_isComplete α _ s).2 ⟨ht, hc.isComplete⟩\n\n"}
{"name":"CauchySeq.totallyBounded_range","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ns : Nat → α\nhs : CauchySeq s\n⊢ TotallyBounded (Set.range s)","decl":"/-- Every Cauchy sequence over `ℕ` is totally bounded. -/\ntheorem CauchySeq.totallyBounded_range {s : ℕ → α} (hs : CauchySeq s) :\n    TotallyBounded (range s) := by\n  intro a ha\n  cases' cauchySeq_iff.1 hs a ha with n hn\n  refine ⟨s '' { k | k ≤ n }, (finite_le_nat _).image _, ?_⟩\n  rw [range_subset_iff, biUnion_image]\n  intro m\n  rw [mem_iUnion₂]\n  rcases le_total m n with hm | hm\n  exacts [⟨m, hm, refl_mem_uniformity ha⟩, ⟨n, le_refl n, hn m hm n le_rfl⟩]\n\n"}
{"name":"totallyBounded_interUnionBalls","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\np : Nat → Prop\nU : Nat → Set (Prod α α)\nH : (uniformity α).HasBasis p U\nxs : Nat → α\nu : Nat → Nat\n⊢ TotallyBounded (interUnionBalls xs u U)","decl":"lemma totallyBounded_interUnionBalls {p : ℕ → Prop} {U : ℕ → Set (α × α)}\n    (H : (uniformity α).HasBasis p U) (xs : ℕ → α) (u : ℕ → ℕ) :\n    TotallyBounded (interUnionBalls xs u U) := by\n  rw [Filter.HasBasis.totallyBounded_iff H]\n  intro i _\n  have h_subset : interUnionBalls xs u U\n      ⊆ ⋃ m ≤ u i, UniformSpace.ball (xs m) (Prod.swap ⁻¹' U i) :=\n    fun x hx ↦ Set.mem_iInter.1 hx i\n  classical\n  refine ⟨Finset.image xs (Finset.range (u i + 1)), Finset.finite_toSet _, fun x hx ↦ ?_⟩\n  simp only [Finset.coe_image, Finset.coe_range, mem_image, mem_Iio, iUnion_exists, biUnion_and',\n    iUnion_iUnion_eq_right, Nat.lt_succ_iff]\n  exact h_subset hx\n\n"}
{"name":"isCompact_closure_interUnionBalls","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\np : Nat → Prop\nU : Nat → Set (Prod α α)\nH : (uniformity α).HasBasis p U\ninst✝ : CompleteSpace α\nxs : Nat → α\nu : Nat → Nat\n⊢ IsCompact (closure (interUnionBalls xs u U))","decl":"/-- The construction `interUnionBalls` is used to have a relatively compact set. -/\ntheorem isCompact_closure_interUnionBalls {p : ℕ → Prop} {U : ℕ → Set (α × α)}\n    (H : (uniformity α).HasBasis p U) [CompleteSpace α] (xs : ℕ → α) (u : ℕ → ℕ) :\n    IsCompact (closure (interUnionBalls xs u U)) := by\n  rw [isCompact_iff_totallyBounded_isComplete]\n  refine ⟨TotallyBounded.closure ?_, isClosed_closure.isComplete⟩\n  exact totallyBounded_interUnionBalls H xs u\n\n"}
{"name":"SequentiallyComplete.setSeq_mem","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nn : Nat\n⊢ Membership.mem f (SequentiallyComplete.setSeq hf U_mem n)","decl":"theorem setSeq_mem (n : ℕ) : setSeq hf U_mem n ∈ f :=\n  (biInter_mem (finite_le_nat n)).2 fun m _ => (setSeqAux hf U_mem m).2.1\n\n"}
{"name":"SequentiallyComplete.setSeq_mono","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nm n : Nat\nh : LE.le m n\n⊢ HasSubset.Subset (SequentiallyComplete.setSeq hf U_mem n) (SequentiallyComplete.setSeq hf U_mem m)","decl":"theorem setSeq_mono ⦃m n : ℕ⦄ (h : m ≤ n) : setSeq hf U_mem n ⊆ setSeq hf U_mem m :=\n  biInter_subset_biInter_left <| Iic_subset_Iic.2 h\n\n"}
{"name":"SequentiallyComplete.setSeq_sub_aux","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nn : Nat\n⊢ HasSubset.Subset (SequentiallyComplete.setSeq hf U_mem n) ↑(SequentiallyComplete.setSeqAux hf U_mem n)","decl":"theorem setSeq_sub_aux (n : ℕ) : setSeq hf U_mem n ⊆ setSeqAux hf U_mem n :=\n  biInter_subset_of_mem right_mem_Iic\n\n"}
{"name":"SequentiallyComplete.setSeq_prod_subset","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nN m n : Nat\nhm : LE.le N m\nhn : LE.le N n\n⊢ HasSubset.Subset (SProd.sprod (SequentiallyComplete.setSeq hf U_mem m) (SequentiallyComplete.setSeq hf U_mem n)) (U N)","decl":"theorem setSeq_prod_subset {N m n} (hm : N ≤ m) (hn : N ≤ n) :\n    setSeq hf U_mem m ×ˢ setSeq hf U_mem n ⊆ U N := fun p hp => by\n  refine (setSeqAux hf U_mem N).2.2 ⟨?_, ?_⟩ <;> apply setSeq_sub_aux\n  · exact setSeq_mono hf U_mem hm hp.1\n  · exact setSeq_mono hf U_mem hn hp.2\n\n"}
{"name":"SequentiallyComplete.seq_mem","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nn : Nat\n⊢ Membership.mem (SequentiallyComplete.setSeq hf U_mem n) (SequentiallyComplete.seq hf U_mem n)","decl":"theorem seq_mem (n : ℕ) : seq hf U_mem n ∈ setSeq hf U_mem n :=\n  (hf.1.nonempty_of_mem (setSeq_mem hf U_mem n)).choose_spec\n\n"}
{"name":"SequentiallyComplete.seq_pair_mem","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nN m n : Nat\nhm : LE.le N m\nhn : LE.le N n\n⊢ Membership.mem (U N) { fst := SequentiallyComplete.seq hf U_mem m, snd := SequentiallyComplete.seq hf U_mem n }","decl":"theorem seq_pair_mem ⦃N m n : ℕ⦄ (hm : N ≤ m) (hn : N ≤ n) :\n    (seq hf U_mem m, seq hf U_mem n) ∈ U N :=\n  setSeq_prod_subset hf U_mem hm hn ⟨seq_mem hf U_mem m, seq_mem hf U_mem n⟩\n\n"}
{"name":"SequentiallyComplete.seq_is_cauchySeq","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nU_le : ∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun n => HasSubset.Subset (U n) s\n⊢ CauchySeq (SequentiallyComplete.seq hf U_mem)","decl":"theorem seq_is_cauchySeq (U_le : ∀ s ∈ 𝓤 α, ∃ n, U n ⊆ s) : CauchySeq <| seq hf U_mem :=\n  cauchySeq_of_controlled U U_le <| seq_pair_mem hf U_mem\n\n"}
{"name":"SequentiallyComplete.le_nhds_of_seq_tendsto_nhds","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\nf : Filter α\nhf : Cauchy f\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nU_le : ∀ (s : Set (Prod α α)), Membership.mem (uniformity α) s → Exists fun n => HasSubset.Subset (U n) s\na : α\nha : Filter.Tendsto (SequentiallyComplete.seq hf U_mem) Filter.atTop (nhds a)\n⊢ LE.le f (nhds a)","decl":"/-- If the sequence `SequentiallyComplete.seq` converges to `a`, then `f ≤ 𝓝 a`. -/\ntheorem le_nhds_of_seq_tendsto_nhds (U_le : ∀ s ∈ 𝓤 α, ∃ n, U n ⊆ s)\n    ⦃a : α⦄ (ha : Tendsto (seq hf U_mem) atTop (𝓝 a)) : f ≤ 𝓝 a :=\n  le_nhds_of_cauchy_adhp_aux\n    (fun s hs => by\n      rcases U_le s hs with ⟨m, hm⟩\n      rcases tendsto_atTop'.1 ha _ (mem_nhds_left a (U_mem m)) with ⟨n, hn⟩\n      refine\n        ⟨setSeq hf U_mem (max m n), setSeq_mem hf U_mem _, ?_, seq hf U_mem (max m n), ?_,\n          seq_mem hf U_mem _⟩\n      · have := le_max_left m n\n        exact Set.Subset.trans (setSeq_prod_subset hf U_mem this this) hm\n      · exact hm (hn _ <| le_max_right m n))\n\n"}
{"name":"UniformSpace.complete_of_convergent_controlled_sequences","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : (uniformity α).IsCountablyGenerated\nU : Nat → Set (Prod α α)\nU_mem : ∀ (n : Nat), Membership.mem (uniformity α) (U n)\nHU : ∀ (u : Nat → α), (∀ (N m n : Nat), LE.le N m → LE.le N n → Membership.mem (U N) { fst := u m, snd := u n }) → Exists fun a => Filter.Tendsto u Filter.atTop (nhds a)\n⊢ CompleteSpace α","decl":"/-- A uniform space is complete provided that (a) its uniformity filter has a countable basis;\n(b) any sequence satisfying a \"controlled\" version of the Cauchy condition converges. -/\ntheorem complete_of_convergent_controlled_sequences (U : ℕ → Set (α × α)) (U_mem : ∀ n, U n ∈ 𝓤 α)\n    (HU : ∀ u : ℕ → α, (∀ N m n, N ≤ m → N ≤ n → (u m, u n) ∈ U N) → ∃ a, Tendsto u atTop (𝓝 a)) :\n    CompleteSpace α := by\n  obtain ⟨U', -, hU'⟩ := (𝓤 α).exists_antitone_seq\n  have Hmem : ∀ n, U n ∩ U' n ∈ 𝓤 α := fun n => inter_mem (U_mem n) (hU'.2 ⟨n, Subset.refl _⟩)\n  refine ⟨fun hf => (HU (seq hf Hmem) fun N m n hm hn => ?_).imp <|\n    le_nhds_of_seq_tendsto_nhds _ _ fun s hs => ?_⟩\n  · exact inter_subset_left (seq_pair_mem hf Hmem hm hn)\n  · rcases hU'.1 hs with ⟨N, hN⟩\n    exact ⟨N, Subset.trans inter_subset_right hN⟩\n\n"}
{"name":"UniformSpace.complete_of_cauchySeq_tendsto","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝ : (uniformity α).IsCountablyGenerated\nH' : ∀ (u : Nat → α), CauchySeq u → Exists fun a => Filter.Tendsto u Filter.atTop (nhds a)\n⊢ CompleteSpace α","decl":"/-- A sequentially complete uniform space with a countable basis of the uniformity filter is\ncomplete. -/\ntheorem complete_of_cauchySeq_tendsto (H' : ∀ u : ℕ → α, CauchySeq u → ∃ a, Tendsto u atTop (𝓝 a)) :\n    CompleteSpace α :=\n  let ⟨U', _, hU'⟩ := (𝓤 α).exists_antitone_seq\n  complete_of_convergent_controlled_sequences U' (fun n => hU'.2 ⟨n, Subset.refl _⟩) fun u hu =>\n    H' u <| cauchySeq_of_controlled U' (fun _ hs => hU'.1 hs) hu\n\n"}
{"name":"UniformSpace.firstCountableTopology","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\n⊢ FirstCountableTopology α","decl":"instance (priority := 100) firstCountableTopology : FirstCountableTopology α :=\n  ⟨fun a => by rw [nhds_eq_comap_uniformity]; infer_instance⟩\n\n"}
{"name":"UniformSpace.secondCountable_of_separable","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"α : Type u\nuniformSpace : UniformSpace α\ninst✝¹ : (uniformity α).IsCountablyGenerated\ninst✝ : TopologicalSpace.SeparableSpace α\n⊢ SecondCountableTopology α","decl":"/-- A separable uniform space with countably generated uniformity filter is second countable:\none obtains a countable basis by taking the balls centered at points in a dense subset,\nand with rational \"radii\" from a countable open symmetric antitone basis of `𝓤 α`. We do not\nregister this as an instance, as there is already an instance going in the other direction\nfrom second countable spaces to separable spaces, and we want to avoid loops. -/\ntheorem secondCountable_of_separable [SeparableSpace α] : SecondCountableTopology α := by\n  rcases exists_countable_dense α with ⟨s, hsc, hsd⟩\n  obtain\n    ⟨t : ℕ → Set (α × α), hto : ∀ i : ℕ, t i ∈ (𝓤 α).sets ∧ IsOpen (t i) ∧ SymmetricRel (t i),\n      h_basis : (𝓤 α).HasAntitoneBasis t⟩ :=\n    (@uniformity_hasBasis_open_symmetric α _).exists_antitone_subbasis\n  choose ht_mem hto hts using hto\n  refine ⟨⟨⋃ x ∈ s, range fun k => ball x (t k), hsc.biUnion fun x _ => countable_range _, ?_⟩⟩\n  refine (isTopologicalBasis_of_isOpen_of_nhds ?_ ?_).eq_generateFrom\n  · simp only [mem_iUnion₂, mem_range]\n    rintro _ ⟨x, _, k, rfl⟩\n    exact isOpen_ball x (hto k)\n  · intro x V hxV hVo\n    simp only [mem_iUnion₂, mem_range, exists_prop]\n    rcases UniformSpace.mem_nhds_iff.1 (IsOpen.mem_nhds hVo hxV) with ⟨U, hU, hUV⟩\n    rcases comp_symm_of_uniformity hU with ⟨U', hU', _, hUU'⟩\n    rcases h_basis.toHasBasis.mem_iff.1 hU' with ⟨k, -, hk⟩\n    rcases hsd.inter_open_nonempty (ball x <| t k) (isOpen_ball x (hto k))\n        ⟨x, UniformSpace.mem_ball_self _ (ht_mem k)⟩ with\n      ⟨y, hxy, hys⟩\n    refine ⟨_, ⟨y, hys, k, rfl⟩, (hts k).subset hxy, fun z hz => ?_⟩\n    exact hUV (ball_subset_of_comp_subset (hk hxy) hUU' (hk hz))\n\n"}
{"name":"UniformSpace.DiscreteUnif.cauchy_le_pure","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"X : Type u_1\nuX : UniformSpace X\nhX : Eq uX Bot.bot\nα : Filter X\nhα : Cauchy α\n⊢ Exists fun x => Eq α (Pure.pure x)","decl":"/-- A Cauchy filter in a discrete uniform space is contained in a principal filter-/\ntheorem DiscreteUnif.cauchy_le_pure {X : Type*} {uX : UniformSpace X}\n    (hX : uX = ⊥) {α : Filter X} (hα : Cauchy α) : ∃ x : X, α = pure x := by\n  rcases hα with ⟨α_ne_bot, α_le⟩\n  rw [hX, bot_uniformity, le_principal_iff, mem_prod_iff] at α_le\n  obtain ⟨S, ⟨hS, ⟨T, ⟨hT, H⟩⟩⟩⟩ := α_le\n  obtain ⟨x, rfl⟩ := eq_singleton_left_of_prod_subset_idRel (α_ne_bot.nonempty_of_mem hS)\n    (Filter.nonempty_of_mem hT) H\n  exact ⟨x, α_ne_bot.le_pure_iff.mp <| le_pure_iff.mpr hS⟩\n\n"}
{"name":"UniformSpace.DiscreteUnif.eq_const_of_cauchy","module":"Mathlib.Topology.UniformSpace.Cauchy","initialProofState":"X : Type u_1\nuX : UniformSpace X\nhX : Eq uX Bot.bot\nα : Filter X\nhα : Cauchy α\n⊢ Eq α (Pure.pure (UniformSpace.DiscreteUnif.cauchyConst hX hα))","decl":"theorem DiscreteUnif.eq_const_of_cauchy {X : Type*} {uX : UniformSpace X} (hX : uX = ⊥)\n    {α : Filter X} (hα : Cauchy α) : α = pure (DiscreteUnif.cauchyConst hX hα) :=\n  (DiscreteUnif.cauchy_le_pure hX hα).choose_spec\n\n"}
