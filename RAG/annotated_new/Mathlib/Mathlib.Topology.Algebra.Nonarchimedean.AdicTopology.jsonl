{"name":"Ideal.adic_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nI : Ideal R\nâŠ¢ SubmodulesRingBasis fun n => HSMul.hSMul (HPow.hPow I n) Top.top","decl":"theorem adic_basis (I : Ideal R) : SubmodulesRingBasis fun n : â„• => (I ^ n â€¢ âŠ¤ : Ideal R) :=\n  { inter := by\n      suffices âˆ€ i j : â„•, âˆƒ k, I ^ k â‰¤ I ^ i âˆ§ I ^ k â‰¤ I ^ j by\n        simpa only [smul_eq_mul, mul_top, Algebra.id.map_eq_id, map_id, le_inf_iff] using this\n      intro i j\n      exact âŸ¨max i j, pow_le_pow_right (le_max_left i j), pow_le_pow_right (le_max_right i j)âŸ©\n    leftMul := by\n      suffices âˆ€ (a : R) (i : â„•), âˆƒ j : â„•, a â€¢ I ^ j â‰¤ I ^ i by\n        simpa only [smul_top_eq_map, Algebra.id.map_eq_id, map_id] using this\n      intro r n\n      use n\n      rintro a âŸ¨x, hx, rflâŸ©\n      exact (I ^ n).smul_mem r hx\n    mul := by\n      suffices âˆ€ i : â„•, âˆƒ j : â„•, (â†‘(I ^ j) * â†‘(I ^ j) : Set R) âŠ† (â†‘(I ^ i) : Set R) by\n        simpa only [smul_top_eq_map, Algebra.id.map_eq_id, map_id] using this\n      intro n\n      use n\n      rintro a âŸ¨x, _hx, b, hb, rflâŸ©\n      exact (I ^ n).smul_mem x hb }\n\n"}
{"name":"Ideal.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nI : Ideal R\nâŠ¢ NonarchimedeanRing R","decl":"theorem nonarchimedean (I : Ideal R) : @NonarchimedeanRing R _ I.adicTopology :=\n  I.adic_basis.toRing_subgroups_basis.nonarchimedean\n\n"}
{"name":"Ideal.hasBasis_nhds_zero_adic","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nI : Ideal R\nâŠ¢ (nhds 0).HasBasis (fun _n => True) fun n => â†‘(HPow.hPow I n)","decl":"/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem hasBasis_nhds_zero_adic (I : Ideal R) :\n    HasBasis (@nhds R I.adicTopology (0 : R)) (fun _n : â„• => True) fun n =>\n      ((I ^ n : Ideal R) : Set R) :=\n  âŸ¨by\n    intro U\n    rw [I.ringFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff]\n    constructor\n    Â· rintro âŸ¨-, âŸ¨i, rflâŸ©, hâŸ©\n      replace h : â†‘(I ^ i) âŠ† U := by simpa using h\n      exact âŸ¨i, trivial, hâŸ©\n    Â· rintro âŸ¨i, -, hâŸ©\n      exact âŸ¨(I ^ i : Ideal R), âŸ¨i, by simpâŸ©, hâŸ©âŸ©\n\n"}
{"name":"Ideal.hasBasis_nhds_adic","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœ : CommRing R\nI : Ideal R\nx : R\nâŠ¢ (nhds x).HasBasis (fun _n => True) fun n => Set.image (fun y => HAdd.hAdd x y) â†‘(HPow.hPow I n)","decl":"theorem hasBasis_nhds_adic (I : Ideal R) (x : R) :\n    HasBasis (@nhds R I.adicTopology x) (fun _n : â„• => True) fun n =>\n      (fun y => x + y) '' (I ^ n : Ideal R) := by\n  letI := I.adicTopology\n  have := I.hasBasis_nhds_zero_adic.map fun y => x + y\n  rwa [map_add_left_nhds_zero x] at this\n\n"}
{"name":"Ideal.adic_module_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\nI : Ideal R\nM : Type u_2\ninstâœÂ¹ : AddCommGroup M\ninstâœ : Module R M\nâŠ¢ I.ringFilterBasis.SubmodulesBasis fun n => HSMul.hSMul (HPow.hPow I n) Top.top","decl":"theorem adic_module_basis :\n    I.ringFilterBasis.SubmodulesBasis fun n : â„• => I ^ n â€¢ (âŠ¤ : Submodule R M) :=\n  { inter := fun i j =>\n      âŸ¨max i j,\n        le_inf_iff.mpr\n          âŸ¨smul_mono_left <| pow_le_pow_right (le_max_left i j),\n            smul_mono_left <| pow_le_pow_right (le_max_right i j)âŸ©âŸ©\n    smul := fun m i =>\n      âŸ¨(I ^ i â€¢ âŠ¤ : Ideal R), âŸ¨i, by simpâŸ©, fun a a_in => by\n        replace a_in : a âˆˆ I ^ i := by simpa [(I ^ i).mul_top] using a_in\n        exact smul_mem_smul a_in mem_topâŸ© }\n\n"}
{"name":"isAdic_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\ntop : TopologicalSpace R\ninstâœ : TopologicalRing R\nJ : Ideal R\nâŠ¢ Iff (IsAdic J) (And (âˆ€ (n : Nat), IsOpen â†‘(HPow.hPow J n)) (âˆ€ (s : Set R), Membership.mem (nhds 0) s â†’ Exists fun n => HasSubset.Subset (â†‘(HPow.hPow J n)) s))","decl":"/-- A topological ring is `J`-adic if and only if it admits the powers of `J` as a basis of\nopen neighborhoods of zero. -/\ntheorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J â†”\n      (âˆ€ n : â„•, IsOpen ((J ^ n : Ideal R) : Set R)) âˆ§\n        âˆ€ s âˆˆ ğ“ (0 : R), âˆƒ n : â„•, ((J ^ n : Ideal R) : Set R) âŠ† s := by\n  constructor\n  Â· intro H\n    change _ = _ at H\n    rw [H]\n    letI := J.adicTopology\n    constructor\n    Â· intro n\n      exact (J.openAddSubgroup n).isOpen'\n    Â· intro s hs\n      simpa using J.hasBasis_nhds_zero_adic.mem_iff.mp hs\n  Â· rintro âŸ¨Hâ‚, Hâ‚‚âŸ©\n    apply TopologicalAddGroup.ext\n    Â· apply @TopologicalRing.to_topologicalAddGroup\n    Â· apply (RingSubgroupsBasis.toRingFilterBasis _).toAddGroupFilterBasis.isTopologicalAddGroup\n    Â· ext s\n      letI := Ideal.adic_basis J\n      rw [J.hasBasis_nhds_zero_adic.mem_iff]\n      constructor <;> intro H\n      Â· rcases Hâ‚‚ s H with âŸ¨n, hâŸ©\n        exact âŸ¨n, trivial, hâŸ©\n      Â· rcases H with âŸ¨n, -, hnâŸ©\n        rw [mem_nhds_iff]\n        exact âŸ¨_, hn, Hâ‚ n, (J ^ n).zero_memâŸ©\n\n"}
{"name":"is_ideal_adic_pow","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœÂ² : CommRing R\ninstâœÂ¹ : TopologicalSpace R\ninstâœ : TopologicalRing R\nJ : Ideal R\nh : IsAdic J\nn : Nat\nhn : LT.lt 0 n\nâŠ¢ IsAdic (HPow.hPow J n)","decl":"theorem is_ideal_adic_pow {J : Ideal R} (h : IsAdic J) {n : â„•} (hn : 0 < n) : IsAdic (J ^ n) := by\n  rw [isAdic_iff] at h âŠ¢\n  constructor\n  Â· intro m\n    rw [â† pow_mul]\n    apply h.left\n  Â· intro V hV\n    cases' h.right V hV with m hm\n    use m\n    refine Set.Subset.trans ?_ hm\n    cases n\n    Â· exfalso\n      exact Nat.not_succ_le_zero 0 hn\n    rw [â† pow_mul, Nat.succ_mul]\n    apply Ideal.pow_le_pow_right\n    apply Nat.le_add_left\n\n"}
{"name":"is_bot_adic_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"A : Type u_2\ninstâœÂ² : CommRing A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : TopologicalRing A\nâŠ¢ Iff (IsAdic Bot.bot) (DiscreteTopology A)","decl":"theorem is_bot_adic_iff {A : Type*} [CommRing A] [TopologicalSpace A] [TopologicalRing A] :\n    IsAdic (âŠ¥ : Ideal A) â†” DiscreteTopology A := by\n  rw [isAdic_iff]\n  constructor\n  Â· rintro âŸ¨h, _h'âŸ©\n    rw [discreteTopology_iff_isOpen_singleton_zero]\n    simpa using h 1\n  Â· intros\n    constructor\n    Â· simp\n    Â· intro U U_nhds\n      use 1\n      simp [mem_of_mem_nhds U_nhds]\n\n"}
{"name":"WithIdeal.instNonarchimedeanRing","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\ninstâœ : WithIdeal R\nâŠ¢ NonarchimedeanRing R","decl":"instance (priority := 100) : NonarchimedeanRing R :=\n  RingSubgroupsBasis.nonarchimedean _\n\n"}
{"name":"WithIdeal.instUniformAddGroup","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninstâœÂ¹ : CommRing R\ninstâœ : WithIdeal R\nâŠ¢ UniformAddGroup R","decl":"instance (priority := 100) : UniformAddGroup R :=\n  comm_topologicalAddGroup_is_uniform\n\n"}
