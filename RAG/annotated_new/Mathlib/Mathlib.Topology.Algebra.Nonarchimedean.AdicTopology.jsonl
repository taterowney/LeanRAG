{"name":"Ideal.adic_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ SubmodulesRingBasis fun n => HSMul.hSMul (HPow.hPow I n) Top.top","decl":"theorem adic_basis (I : Ideal R) : SubmodulesRingBasis fun n : ℕ => (I ^ n • ⊤ : Ideal R) :=\n  { inter := by\n      suffices ∀ i j : ℕ, ∃ k, I ^ k ≤ I ^ i ∧ I ^ k ≤ I ^ j by\n        simpa only [smul_eq_mul, mul_top, Algebra.id.map_eq_id, map_id, le_inf_iff] using this\n      intro i j\n      exact ⟨max i j, pow_le_pow_right (le_max_left i j), pow_le_pow_right (le_max_right i j)⟩\n    leftMul := by\n      suffices ∀ (a : R) (i : ℕ), ∃ j : ℕ, a • I ^ j ≤ I ^ i by\n        simpa only [smul_top_eq_map, Algebra.id.map_eq_id, map_id] using this\n      intro r n\n      use n\n      rintro a ⟨x, hx, rfl⟩\n      exact (I ^ n).smul_mem r hx\n    mul := by\n      suffices ∀ i : ℕ, ∃ j : ℕ, (↑(I ^ j) * ↑(I ^ j) : Set R) ⊆ (↑(I ^ i) : Set R) by\n        simpa only [smul_top_eq_map, Algebra.id.map_eq_id, map_id] using this\n      intro n\n      use n\n      rintro a ⟨x, _hx, b, hb, rfl⟩\n      exact (I ^ n).smul_mem x hb }\n\n"}
{"name":"Ideal.nonarchimedean","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ NonarchimedeanRing R","decl":"theorem nonarchimedean (I : Ideal R) : @NonarchimedeanRing R _ I.adicTopology :=\n  I.adic_basis.toRing_subgroups_basis.nonarchimedean\n\n"}
{"name":"Ideal.hasBasis_nhds_zero_adic","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\n⊢ (nhds 0).HasBasis (fun _n => True) fun n => ↑(HPow.hPow I n)","decl":"/-- For the `I`-adic topology, the neighborhoods of zero has basis given by the powers of `I`. -/\ntheorem hasBasis_nhds_zero_adic (I : Ideal R) :\n    HasBasis (@nhds R I.adicTopology (0 : R)) (fun _n : ℕ => True) fun n =>\n      ((I ^ n : Ideal R) : Set R) :=\n  ⟨by\n    intro U\n    rw [I.ringFilterBasis.toAddGroupFilterBasis.nhds_zero_hasBasis.mem_iff]\n    constructor\n    · rintro ⟨-, ⟨i, rfl⟩, h⟩\n      replace h : ↑(I ^ i) ⊆ U := by simpa using h\n      exact ⟨i, trivial, h⟩\n    · rintro ⟨i, -, h⟩\n      exact ⟨(I ^ i : Ideal R), ⟨i, by simp⟩, h⟩⟩\n\n"}
{"name":"Ideal.hasBasis_nhds_adic","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\nx : R\n⊢ (nhds x).HasBasis (fun _n => True) fun n => Set.image (fun y => HAdd.hAdd x y) ↑(HPow.hPow I n)","decl":"theorem hasBasis_nhds_adic (I : Ideal R) (x : R) :\n    HasBasis (@nhds R I.adicTopology x) (fun _n : ℕ => True) fun n =>\n      (fun y => x + y) '' (I ^ n : Ideal R) := by\n  letI := I.adicTopology\n  have := I.hasBasis_nhds_zero_adic.map fun y => x + y\n  rwa [map_add_left_nhds_zero x] at this\n\n"}
{"name":"Ideal.adic_module_basis","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nI : Ideal R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ I.ringFilterBasis.SubmodulesBasis fun n => HSMul.hSMul (HPow.hPow I n) Top.top","decl":"theorem adic_module_basis :\n    I.ringFilterBasis.SubmodulesBasis fun n : ℕ => I ^ n • (⊤ : Submodule R M) :=\n  { inter := fun i j =>\n      ⟨max i j,\n        le_inf_iff.mpr\n          ⟨smul_mono_left <| pow_le_pow_right (le_max_left i j),\n            smul_mono_left <| pow_le_pow_right (le_max_right i j)⟩⟩\n    smul := fun m i =>\n      ⟨(I ^ i • ⊤ : Ideal R), ⟨i, by simp⟩, fun a a_in => by\n        replace a_in : a ∈ I ^ i := by simpa [(I ^ i).mul_top] using a_in\n        exact smul_mem_smul a_in mem_top⟩ }\n\n"}
{"name":"isAdic_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ntop : TopologicalSpace R\ninst✝ : TopologicalRing R\nJ : Ideal R\n⊢ Iff (IsAdic J) (And (∀ (n : Nat), IsOpen ↑(HPow.hPow J n)) (∀ (s : Set R), Membership.mem (nhds 0) s → Exists fun n => HasSubset.Subset (↑(HPow.hPow J n)) s))","decl":"/-- A topological ring is `J`-adic if and only if it admits the powers of `J` as a basis of\nopen neighborhoods of zero. -/\ntheorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\n    IsAdic J ↔\n      (∀ n : ℕ, IsOpen ((J ^ n : Ideal R) : Set R)) ∧\n        ∀ s ∈ 𝓝 (0 : R), ∃ n : ℕ, ((J ^ n : Ideal R) : Set R) ⊆ s := by\n  constructor\n  · intro H\n    change _ = _ at H\n    rw [H]\n    letI := J.adicTopology\n    constructor\n    · intro n\n      exact (J.openAddSubgroup n).isOpen'\n    · intro s hs\n      simpa using J.hasBasis_nhds_zero_adic.mem_iff.mp hs\n  · rintro ⟨H₁, H₂⟩\n    apply TopologicalAddGroup.ext\n    · apply @TopologicalRing.to_topologicalAddGroup\n    · apply (RingSubgroupsBasis.toRingFilterBasis _).toAddGroupFilterBasis.isTopologicalAddGroup\n    · ext s\n      letI := Ideal.adic_basis J\n      rw [J.hasBasis_nhds_zero_adic.mem_iff]\n      constructor <;> intro H\n      · rcases H₂ s H with ⟨n, h⟩\n        exact ⟨n, trivial, h⟩\n      · rcases H with ⟨n, -, hn⟩\n        rw [mem_nhds_iff]\n        exact ⟨_, hn, H₁ n, (J ^ n).zero_mem⟩\n\n"}
{"name":"is_ideal_adic_pow","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : TopologicalSpace R\ninst✝ : TopologicalRing R\nJ : Ideal R\nh : IsAdic J\nn : Nat\nhn : LT.lt 0 n\n⊢ IsAdic (HPow.hPow J n)","decl":"theorem is_ideal_adic_pow {J : Ideal R} (h : IsAdic J) {n : ℕ} (hn : 0 < n) : IsAdic (J ^ n) := by\n  rw [isAdic_iff] at h ⊢\n  constructor\n  · intro m\n    rw [← pow_mul]\n    apply h.left\n  · intro V hV\n    cases' h.right V hV with m hm\n    use m\n    refine Set.Subset.trans ?_ hm\n    cases n\n    · exfalso\n      exact Nat.not_succ_le_zero 0 hn\n    rw [← pow_mul, Nat.succ_mul]\n    apply Ideal.pow_le_pow_right\n    apply Nat.le_add_left\n\n"}
{"name":"is_bot_adic_iff","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"A : Type u_2\ninst✝² : CommRing A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalRing A\n⊢ Iff (IsAdic Bot.bot) (DiscreteTopology A)","decl":"theorem is_bot_adic_iff {A : Type*} [CommRing A] [TopologicalSpace A] [TopologicalRing A] :\n    IsAdic (⊥ : Ideal A) ↔ DiscreteTopology A := by\n  rw [isAdic_iff]\n  constructor\n  · rintro ⟨h, _h'⟩\n    rw [discreteTopology_iff_isOpen_singleton_zero]\n    simpa using h 1\n  · intros\n    constructor\n    · simp\n    · intro U U_nhds\n      use 1\n      simp [mem_of_mem_nhds U_nhds]\n\n"}
{"name":"WithIdeal.instNonarchimedeanRing","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : WithIdeal R\n⊢ NonarchimedeanRing R","decl":"instance (priority := 100) : NonarchimedeanRing R :=\n  RingSubgroupsBasis.nonarchimedean _\n\n"}
{"name":"WithIdeal.instUniformAddGroup","module":"Mathlib.Topology.Algebra.Nonarchimedean.AdicTopology","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : WithIdeal R\n⊢ UniformAddGroup R","decl":"instance (priority := 100) : UniformAddGroup R :=\n  comm_topologicalAddGroup_is_uniform\n\n"}
