{"name":"ModuleCat.MonModuleEquivalenceAlgebra.algebraMap","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : Mon_ (ModuleCat R)\nr : R\n⊢ Eq ((algebraMap R ↑A.X) r) ((CategoryTheory.ConcreteCategory.hom A.one) r)","decl":"@[simp]\ntheorem algebraMap (A : Mon_ (ModuleCat.{u} R)) (r : R) : algebraMap R A.X r = A.one r :=\n  rfl\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.functor_obj_carrier","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : Mon_ (ModuleCat R)\n⊢ Eq ↑(ModuleCat.MonModuleEquivalenceAlgebra.functor.obj A) ↑A.X","decl":"/-- Converting a monoid object in `ModuleCat R` to a bundled algebra.\n-/\n@[simps!]\ndef functor : Mon_ (ModuleCat.{u} R) ⥤ AlgebraCat R where\n  obj A := AlgebraCat.of R A.X\n  map {_ _} f := AlgebraCat.ofHom\n    { f.hom.hom.toAddMonoidHom with\n      toFun := f.hom\n      map_one' := LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.one_hom) (1 : R)\n      map_mul' := fun x y => LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.mul_hom) (x ⊗ₜ y)\n      commutes' := fun r => LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.one_hom) r }\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.functor_map_hom_apply","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nx✝¹ x✝ : Mon_ (ModuleCat R)\nf : Quiver.Hom x✝¹ x✝\na : ↑x✝¹.X\n⊢ Eq ((AlgebraCat.Hom.hom (ModuleCat.MonModuleEquivalenceAlgebra.functor.map f)) a) ((CategoryTheory.ConcreteCategory.hom f.hom) a)","decl":"/-- Converting a monoid object in `ModuleCat R` to a bundled algebra.\n-/\n@[simps!]\ndef functor : Mon_ (ModuleCat.{u} R) ⥤ AlgebraCat R where\n  obj A := AlgebraCat.of R A.X\n  map {_ _} f := AlgebraCat.ofHom\n    { f.hom.hom.toAddMonoidHom with\n      toFun := f.hom\n      map_one' := LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.one_hom) (1 : R)\n      map_mul' := fun x y => LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.mul_hom) (x ⊗ₜ y)\n      commutes' := fun r => LinearMap.congr_fun (ModuleCat.hom_ext_iff.mp f.one_hom) r }\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverseObj_mul","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A).mul (ModuleCat.ofHom (LinearMap.mul' R ↑A))","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := ofHom <| Algebra.linearMap R A\n  mul := ofHom <| LinearMap.mul' R A\n  one_mul := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    rw [compr₂_apply, compr₂_apply, hom_comp, LinearMap.comp_apply]\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --    LinearMap.compr₂_apply, Function.comp_apply, RingHom.map_one,\n    --    ModuleCat.MonoidalCategory.tensorHom_tmul, AlgebraCat.hom_comp,\n    --    ModuleCat.MonoidalCategory.leftUnitor_hom_apply]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    dsimp\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, ← Algebra.smul_def]\n    dsimp\n  mul_one := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp only [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --   LinearMap.compr₂_apply, Function.comp_apply, ModuleCat.MonoidalCategory.hom_apply,\n    --   AlgebraCat.coe_comp]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    erw [compr₂_apply, compr₂_apply]\n    rw [ModuleCat.hom_comp, LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, ← Algebra.commutes,\n      ← Algebra.smul_def]\n    dsimp\n  mul_assoc := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    dsimp only [compr₂_apply, TensorProduct.mk_apply]\n    rw [hom_comp, LinearMap.comp_apply, hom_comp, LinearMap.comp_apply, hom_comp,\n        LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    dsimp only [id_coe, id_eq]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, mul'_apply, LinearMap.id_apply, mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverseObj_X_isModule","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A).X.isModule Algebra.toModule","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := ofHom <| Algebra.linearMap R A\n  mul := ofHom <| LinearMap.mul' R A\n  one_mul := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    rw [compr₂_apply, compr₂_apply, hom_comp, LinearMap.comp_apply]\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --    LinearMap.compr₂_apply, Function.comp_apply, RingHom.map_one,\n    --    ModuleCat.MonoidalCategory.tensorHom_tmul, AlgebraCat.hom_comp,\n    --    ModuleCat.MonoidalCategory.leftUnitor_hom_apply]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    dsimp\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, ← Algebra.smul_def]\n    dsimp\n  mul_one := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp only [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --   LinearMap.compr₂_apply, Function.comp_apply, ModuleCat.MonoidalCategory.hom_apply,\n    --   AlgebraCat.coe_comp]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    erw [compr₂_apply, compr₂_apply]\n    rw [ModuleCat.hom_comp, LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, ← Algebra.commutes,\n      ← Algebra.smul_def]\n    dsimp\n  mul_assoc := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    dsimp only [compr₂_apply, TensorProduct.mk_apply]\n    rw [hom_comp, LinearMap.comp_apply, hom_comp, LinearMap.comp_apply, hom_comp,\n        LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    dsimp only [id_coe, id_eq]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, mul'_apply, LinearMap.id_apply, mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverseObj_one","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A).one (ModuleCat.ofHom (Algebra.linearMap R ↑A))","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := ofHom <| Algebra.linearMap R A\n  mul := ofHom <| LinearMap.mul' R A\n  one_mul := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    rw [compr₂_apply, compr₂_apply, hom_comp, LinearMap.comp_apply]\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --    LinearMap.compr₂_apply, Function.comp_apply, RingHom.map_one,\n    --    ModuleCat.MonoidalCategory.tensorHom_tmul, AlgebraCat.hom_comp,\n    --    ModuleCat.MonoidalCategory.leftUnitor_hom_apply]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    dsimp\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, ← Algebra.smul_def]\n    dsimp\n  mul_one := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp only [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --   LinearMap.compr₂_apply, Function.comp_apply, ModuleCat.MonoidalCategory.hom_apply,\n    --   AlgebraCat.coe_comp]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    erw [compr₂_apply, compr₂_apply]\n    rw [ModuleCat.hom_comp, LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, ← Algebra.commutes,\n      ← Algebra.smul_def]\n    dsimp\n  mul_assoc := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    dsimp only [compr₂_apply, TensorProduct.mk_apply]\n    rw [hom_comp, LinearMap.comp_apply, hom_comp, LinearMap.comp_apply, hom_comp,\n        LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    dsimp only [id_coe, id_eq]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, mul'_apply, LinearMap.id_apply, mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverseObj_X_isAddCommGroup","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A).X.isAddCommGroup Ring.toAddCommGroup","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := ofHom <| Algebra.linearMap R A\n  mul := ofHom <| LinearMap.mul' R A\n  one_mul := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    rw [compr₂_apply, compr₂_apply, hom_comp, LinearMap.comp_apply]\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --    LinearMap.compr₂_apply, Function.comp_apply, RingHom.map_one,\n    --    ModuleCat.MonoidalCategory.tensorHom_tmul, AlgebraCat.hom_comp,\n    --    ModuleCat.MonoidalCategory.leftUnitor_hom_apply]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    dsimp\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, ← Algebra.smul_def]\n    dsimp\n  mul_one := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp only [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --   LinearMap.compr₂_apply, Function.comp_apply, ModuleCat.MonoidalCategory.hom_apply,\n    --   AlgebraCat.coe_comp]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    erw [compr₂_apply, compr₂_apply]\n    rw [ModuleCat.hom_comp, LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, ← Algebra.commutes,\n      ← Algebra.smul_def]\n    dsimp\n  mul_assoc := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    dsimp only [compr₂_apply, TensorProduct.mk_apply]\n    rw [hom_comp, LinearMap.comp_apply, hom_comp, LinearMap.comp_apply, hom_comp,\n        LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    dsimp only [id_coe, id_eq]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, mul'_apply, LinearMap.id_apply, mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverseObj_X_carrier","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq ↑(ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A).X ↑A","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverseObj (A : AlgebraCat.{u} R) : Mon_ (ModuleCat.{u} R) where\n  X := ModuleCat.of R A\n  one := ofHom <| Algebra.linearMap R A\n  mul := ofHom <| LinearMap.mul' R A\n  one_mul := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext_ring <| LinearMap.ext fun x => ?_\n    rw [compr₂_apply, compr₂_apply, hom_comp, LinearMap.comp_apply]\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --    LinearMap.compr₂_apply, Function.comp_apply, RingHom.map_one,\n    --    ModuleCat.MonoidalCategory.tensorHom_tmul, AlgebraCat.hom_comp,\n    --    ModuleCat.MonoidalCategory.leftUnitor_hom_apply]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    dsimp\n    erw [LinearMap.mul'_apply, MonoidalCategory.leftUnitor_hom_apply, ← Algebra.smul_def]\n    dsimp\n  mul_one := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext_ring ?_\n    -- Porting note: this `dsimp` does nothing\n    -- dsimp only [AlgebraCat.id_apply, TensorProduct.mk_apply, Algebra.linearMap_apply,\n    --   LinearMap.compr₂_apply, Function.comp_apply, ModuleCat.MonoidalCategory.hom_apply,\n    --   AlgebraCat.coe_comp]\n    -- Porting note: because `dsimp` is not effective, `rw` needs to be changed to `erw`\n    erw [compr₂_apply, compr₂_apply]\n    rw [ModuleCat.hom_comp, LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, ModuleCat.MonoidalCategory.rightUnitor_hom_apply, ← Algebra.commutes,\n      ← Algebra.smul_def]\n    dsimp\n  mul_assoc := by\n    ext : 1\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` did not pick up `TensorProduct.ext`\n    refine TensorProduct.ext <| TensorProduct.ext <| LinearMap.ext fun x => LinearMap.ext fun y =>\n      LinearMap.ext fun z => ?_\n    dsimp only [compr₂_apply, TensorProduct.mk_apply]\n    rw [hom_comp, LinearMap.comp_apply, hom_comp, LinearMap.comp_apply, hom_comp,\n        LinearMap.comp_apply]\n    erw [LinearMap.mul'_apply, LinearMap.mul'_apply]\n    dsimp only [id_coe, id_eq]\n    erw [TensorProduct.mk_apply, TensorProduct.mk_apply, mul'_apply, LinearMap.id_apply, mul'_apply]\n    simp only [LinearMap.mul'_apply, mul_assoc]\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverse_obj","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nA : AlgebraCat R\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverse.obj A) (ModuleCat.MonModuleEquivalenceAlgebra.inverseObj A)","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverse : AlgebraCat.{u} R ⥤ Mon_ (ModuleCat.{u} R) where\n  obj := inverseObj\n  map f :=\n    { hom := ofHom <| f.hom.toLinearMap\n      one_hom := hom_ext <| LinearMap.ext f.hom.commutes\n      mul_hom := hom_ext <| TensorProduct.ext <| LinearMap.ext₂ <| map_mul f.hom }\n\n"}
{"name":"ModuleCat.MonModuleEquivalenceAlgebra.inverse_map_hom","module":"Mathlib.CategoryTheory.Monoidal.Internal.Module","initialProofState":"R : Type u\ninst✝ : CommRing R\nX✝ Y✝ : AlgebraCat R\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (ModuleCat.MonModuleEquivalenceAlgebra.inverse.map f).hom (ModuleCat.ofHom (AlgebraCat.Hom.hom f).toLinearMap)","decl":"/-- Converting a bundled algebra to a monoid object in `ModuleCat R`.\n-/\n@[simps]\ndef inverse : AlgebraCat.{u} R ⥤ Mon_ (ModuleCat.{u} R) where\n  obj := inverseObj\n  map f :=\n    { hom := ofHom <| f.hom.toLinearMap\n      one_hom := hom_ext <| LinearMap.ext f.hom.commutes\n      mul_hom := hom_ext <| TensorProduct.ext <| LinearMap.ext₂ <| map_mul f.hom }\n\n"}
