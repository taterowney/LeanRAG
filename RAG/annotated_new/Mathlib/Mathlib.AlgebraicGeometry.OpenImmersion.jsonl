{"name":"AlgebraicGeometry.IsOpenImmersion.comp","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\n⊢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.CategoryStruct.comp f g)","decl":"instance IsOpenImmersion.comp {X Y Z : Scheme.{u}} (f : X ⟶ Y) (g : Y ⟶ Z)\n  [IsOpenImmersion f] [IsOpenImmersion g] : IsOpenImmersion (f ≫ g) :=\nLocallyRingedSpace.IsOpenImmersion.comp f.toLRSHom g.toLRSHom\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.isOpen_range","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ IsOpen (Set.range ⇑f.base)","decl":"theorem IsOpenImmersion.isOpen_range {X Y : Scheme.{u}} (f : X ⟶ Y) [H : IsOpenImmersion f] :\n    IsOpen (Set.range f.base) :=\n  H.base_open.isOpen_range\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isOpenEmbedding","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Topology.IsOpenEmbedding ⇑f.base","decl":"theorem isOpenEmbedding : IsOpenEmbedding f.base :=\n  H.base_open\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.openEmbedding","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Topology.IsOpenEmbedding ⇑f.base","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding := isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.coe_opensRange","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (↑f.opensRange) (Set.range ⇑f.base)","decl":"/-- The image of an open immersion as an open set. -/\n@[simps]\ndef opensRange : Y.Opens :=\n  ⟨_, f.isOpenEmbedding.isOpen_range⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_le_image_of_le","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ne : LE.le U V\n⊢ LE.le (f.opensFunctor.obj U) (f.opensFunctor.obj V)","decl":"lemma image_le_image_of_le {U V : X.Opens} (e : U ≤ V) : f ''ᵁ U ≤ f ''ᵁ V := by\n  rintro a ⟨u, hu, rfl⟩\n  exact Set.mem_image_of_mem (⇑f.base) (e hu)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.opensFunctor_map_homOfLE","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (f.opensFunctor.map (CategoryTheory.homOfLE e)) (CategoryTheory.homOfLE ⋯)","decl":"@[simp]\nlemma opensFunctor_map_homOfLE {U V : X.Opens} (e : U ≤ V) :\n    (Scheme.Hom.opensFunctor f).map (homOfLE e) = homOfLE (f.image_le_image_of_le e) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_top_eq_opensRange","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (f.opensFunctor.obj Top.top) f.opensRange","decl":"@[simp]\nlemma image_top_eq_opensRange : f ''ᵁ ⊤ = f.opensRange := by\n  apply Opens.ext\n  simp\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.opensRange_comp","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.CategoryStruct.comp f g)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor g).obj (AlgebraicGeometry.Scheme.Hom.opensRange f))","decl":"lemma opensRange_comp {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z)\n    [IsOpenImmersion f] [IsOpenImmersion g] : (f ≫ g).opensRange = g ''ᵁ f.opensRange :=\n  TopologicalSpace.Opens.ext (Set.range_comp g.base f.base)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.opensRange_of_isIso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange f) Top.top","decl":"lemma opensRange_of_isIso {X Y : Scheme} (f : X ⟶ Y) [IsIso f] :\n    f.opensRange = ⊤ :=\n  TopologicalSpace.Opens.ext (Set.range_eq_univ.mpr f.homeomorph.surjective)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.opensRange_comp_of_isIso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.IsIso f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.CategoryStruct.comp f g)) (AlgebraicGeometry.Scheme.Hom.opensRange g)","decl":"lemma opensRange_comp_of_isIso {X Y Z : Scheme} (f : X ⟶ Y) (g : Y ⟶ Z)\n    [IsIso f] [IsOpenImmersion g] : (f ≫ g).opensRange = g.opensRange := by\n  rw [opensRange_comp, opensRange_of_isIso, image_top_eq_opensRange]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimage_image_eq","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj (f.opensFunctor.obj U)) U","decl":"@[simp]\nlemma preimage_image_eq (U : X.Opens) : f ⁻¹ᵁ f ''ᵁ U = U := by\n  apply Opens.ext\n  simp [Set.preimage_image_eq _ f.isOpenEmbedding.injective]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_le_image_iff","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU U' : X.Opens\n⊢ Iff (LE.le ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U) ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U')) (LE.le U U')","decl":"lemma image_le_image_iff (f : X ⟶ Y) [IsOpenImmersion f] (U U' : X.Opens) :\n    f ''ᵁ U ≤ f ''ᵁ U' ↔ U ≤ U' := by\n  refine ⟨fun h ↦ ?_, image_le_image_of_le f⟩\n  rw [← preimage_image_eq f U, ← preimage_image_eq f U']\n  apply preimage_le_preimage_of_le f h\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_preimage_eq_opensRange_inter","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\n⊢ Eq (f.opensFunctor.obj ((TopologicalSpace.Opens.map f.base).obj U)) (Min.min f.opensRange U)","decl":"lemma image_preimage_eq_opensRange_inter (U : Y.Opens) : f ''ᵁ f ⁻¹ᵁ U = f.opensRange ⊓ U := by\n  apply Opens.ext\n  simp [Set.image_preimage_eq_range_inter]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_injective","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Function.Injective fun x => f.opensFunctor.obj x","decl":"lemma image_injective : Function.Injective (f ''ᵁ ·) := by\n  intro U V hUV\n  simpa using congrArg (f ⁻¹ᵁ ·) hUV\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_iSup","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nι : Sort u_1\ns : ι → X.Opens\n⊢ Eq (f.opensFunctor.obj (iSup fun i => s i)) (iSup fun i => f.opensFunctor.obj (s i))","decl":"lemma image_iSup {ι : Sort*} (s : ι → X.Opens) :\n    (f ''ᵁ ⨆ (i : ι), s i) = ⨆ (i : ι), f ''ᵁ s i := by\n  ext : 1\n  simp [Set.image_iUnion]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.image_iSup₂","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nι : Sort u_1\nκ : ι → Sort u_2\ns : (i : ι) → κ i → X.Opens\n⊢ Eq (f.opensFunctor.obj (iSup fun i => iSup fun j => s i j)) (iSup fun i => iSup fun j => f.opensFunctor.obj (s i j))","decl":"lemma image_iSup₂ {ι : Sort*} {κ : ι → Sort*} (s : (i : ι) → κ i → X.Opens) :\n    (f ''ᵁ ⨆ (i : ι), ⨆ (j : κ i), s i j) = ⨆ (i : ι), ⨆ (j : κ i), f ''ᵁ s i j := by\n  ext : 1\n  simp [Set.image_iUnion₂]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_mem_image_iff","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nx : ↑↑X.toPresheafedSpace\n⊢ Iff (Membership.mem ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U) (f.base x)) (Membership.mem U x)","decl":"@[simp]\nlemma map_mem_image_iff {X Y : Scheme} (f : X ⟶ Y) [IsOpenImmersion f]\n    {U : X.Opens} {x : X} : f.base x ∈ f ''ᵁ U ↔ x ∈ U :=\n  f.isOpenEmbedding.injective.mem_set_image\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_naturality","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ni : Quiver.Hom { unop := U } { unop := V }\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.map i) (f.appIso V).inv) (CategoryTheory.CategoryStruct.comp (f.appIso U).inv (Y.presheaf.map (f.opensFunctor.op.map i)))","decl":"@[reassoc (attr := simp)]\ntheorem appIso_inv_naturality {U V : X.Opens} (i : op U ⟶ op V) :\n    X.presheaf.map i ≫ (f.appIso V).inv =\n      (f.appIso U).inv ≫ Y.presheaf.map (f.opensFunctor.op.map i) :=\n  PresheafedSpace.IsOpenImmersion.inv_naturality _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_naturality_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ni : Quiver.Hom { unop := U } { unop := V }\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.obj { unop := f.opensFunctor.obj V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.map i) (CategoryTheory.CategoryStruct.comp (f.appIso V).inv h)) (CategoryTheory.CategoryStruct.comp (f.appIso U).inv (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (f.opensFunctor.op.map i)) h))","decl":"@[reassoc (attr := simp)]\ntheorem appIso_inv_naturality {U V : X.Opens} (i : op U ⟶ op V) :\n    X.presheaf.map i ≫ (f.appIso V).inv =\n      (f.appIso U).inv ≫ Y.presheaf.map (f.opensFunctor.op.map i) :=\n  PresheafedSpace.IsOpenImmersion.inv_naturality _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_hom","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (f.appIso U).hom (CategoryTheory.CategoryStruct.comp (f.app (f.opensFunctor.obj U)) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op))","decl":"theorem appIso_hom (U) :\n    (f.appIso U).hom = f.app (f ''ᵁ U) ≫ X.presheaf.map\n      (eqToHom (preimage_image_eq f U).symm).op :=\n  (PresheafedSpace.IsOpenImmersion.inv_invApp f.toPshHom U).trans (by rw [eqToHom_op])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_hom'","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (f.appIso U).hom (f.appLE (f.opensFunctor.obj U) U ⋯)","decl":"theorem appIso_hom' (U) :\n    (f.appIso U).hom = f.appLE (f ''ᵁ U) U (preimage_image_eq f U).ge :=\n  f.appIso_hom U\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.app_appIso_inv_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.obj { unop := f.opensFunctor.obj ((TopologicalSpace.Opens.map f.base).obj U) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.app U) (CategoryTheory.CategoryStruct.comp (f.appIso ((TopologicalSpace.Opens.map f.base).obj U)).inv h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op) h)","decl":"@[reassoc (attr := simp)]\ntheorem app_appIso_inv (U) :\n    f.app U ≫ (f.appIso (f ⁻¹ᵁ U)).inv =\n      Y.presheaf.map (homOfLE (Set.image_preimage_subset f.base U.1)).op :=\n  PresheafedSpace.IsOpenImmersion.app_invApp _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.app_appIso_inv","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.app U) (f.appIso ((TopologicalSpace.Opens.map f.base).obj U)).inv) (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[reassoc (attr := simp)]\ntheorem app_appIso_inv (U) :\n    f.app U ≫ (f.appIso (f ⁻¹ᵁ U)).inv =\n      Y.presheaf.map (homOfLE (Set.image_preimage_subset f.base U.1)).op :=\n  PresheafedSpace.IsOpenImmersion.app_invApp _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.app_invApp'_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nhU : LE.le U f.opensRange\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.obj { unop := f.opensFunctor.obj ((TopologicalSpace.Opens.map f.base).obj U) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.app U) (CategoryTheory.CategoryStruct.comp (f.appIso ((TopologicalSpace.Opens.map f.base).obj U)).inv h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.eqToHom ⋯).op) h)","decl":"/-- A variant of `app_invApp` that gives an `eqToHom` instead of `homOfLE`. -/\n@[reassoc]\ntheorem app_invApp' (U) (hU : U ≤ f.opensRange) :\n    f.app U ≫ (f.appIso (f ⁻¹ᵁ U)).inv =\n      Y.presheaf.map (eqToHom (Opens.ext <| by simpa [Set.image_preimage_eq_inter_range])).op :=\n  PresheafedSpace.IsOpenImmersion.app_invApp _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.app_invApp'","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nhU : LE.le U f.opensRange\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.app U) (f.appIso ((TopologicalSpace.Opens.map f.base).obj U)).inv) (Y.presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"/-- A variant of `app_invApp` that gives an `eqToHom` instead of `homOfLE`. -/\n@[reassoc]\ntheorem app_invApp' (U) (hU : U ≤ f.opensRange) :\n    f.app U ≫ (f.appIso (f ⁻¹ᵁ U)).inv =\n      Y.presheaf.map (eqToHom (Opens.ext <| by simpa [Set.image_preimage_eq_inter_range])).op :=\n  PresheafedSpace.IsOpenImmersion.app_invApp _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_app_apply","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nx : CategoryTheory.ToType (X.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (f.app (f.opensFunctor.obj U))) ((CategoryTheory.ConcreteCategory.hom (f.appIso U).inv) x)) ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)) x)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem appIso_inv_app (U) :\n    (f.appIso U).inv ≫ f.app (f ''ᵁ U) = X.presheaf.map (eqToHom (preimage_image_eq f U)).op :=\n  (PresheafedSpace.IsOpenImmersion.invApp_app _ _).trans (by rw [eqToHom_op])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_app","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appIso U).inv (f.app (f.opensFunctor.obj U))) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem appIso_inv_app (U) :\n    (f.appIso U).inv ≫ f.app (f ''ᵁ U) = X.presheaf.map (eqToHom (preimage_image_eq f U)).op :=\n  (PresheafedSpace.IsOpenImmersion.invApp_app _ _).trans (by rw [eqToHom_op])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_app_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := (TopologicalSpace.Opens.map f.base).obj (f.opensFunctor.obj U) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.appIso U).inv (CategoryTheory.CategoryStruct.comp (f.app (f.opensFunctor.obj U)) h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.map (CategoryTheory.eqToHom ⋯).op) h)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem appIso_inv_app (U) :\n    (f.appIso U).inv ≫ f.app (f ''ᵁ U) = X.presheaf.map (eqToHom (preimage_image_eq f U)).op :=\n  (PresheafedSpace.IsOpenImmersion.invApp_app _ _).trans (by rw [eqToHom_op])\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_app_apply'","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nx : ↑(X.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (f.app (f.opensFunctor.obj U))) ((CategoryTheory.ConcreteCategory.hom (f.appIso U).inv) x)) ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)) x)","decl":"/--\n`elementwise` generates the `HasForget.instFunLike` lemma, we want `CommRingCat.Hom.hom`.\n-/\ntheorem appIso_inv_app_apply' (U) (x) :\n    f.app (f ''ᵁ U) ((f.appIso U).inv x) = X.presheaf.map (eqToHom (preimage_image_eq f U)).op x :=\n  appIso_inv_app_apply f U x\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_appIso_inv_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.obj { unop := (AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE f U V e) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appIso f V).inv h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op) h)","decl":"@[reassoc (attr := simp), elementwise nosimp]\nlemma appLE_appIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] {U : Y.Opens}\n    {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U) :\n    f.appLE U V e ≫ (f.appIso V).inv =\n        Y.presheaf.map (homOfLE <| (f.image_le_image_of_le e).trans\n          (f.image_preimage_eq_opensRange_inter U ▸ inf_le_right)).op := by\n  simp only [appLE, Category.assoc, appIso_inv_naturality, Functor.op_obj, Functor.op_map,\n    Quiver.Hom.unop_op, opensFunctor_map_homOfLE, app_appIso_inv_assoc, Opens.carrier_eq_coe]\n  rw [← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_appIso_inv_apply","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nx : CategoryTheory.ToType (Y.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appIso f V).inv) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appLE f U V e)) x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)) x)","decl":"@[reassoc (attr := simp), elementwise nosimp]\nlemma appLE_appIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] {U : Y.Opens}\n    {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U) :\n    f.appLE U V e ≫ (f.appIso V).inv =\n        Y.presheaf.map (homOfLE <| (f.image_le_image_of_le e).trans\n          (f.image_preimage_eq_opensRange_inter U ▸ inf_le_right)).op := by\n  simp only [appLE, Category.assoc, appIso_inv_naturality, Functor.op_obj, Functor.op_map,\n    Quiver.Hom.unop_op, opensFunctor_map_homOfLE, app_appIso_inv_assoc, Opens.carrier_eq_coe]\n  rw [← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appLE_appIso_inv","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE f U V e) (AlgebraicGeometry.Scheme.Hom.appIso f V).inv) (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[reassoc (attr := simp), elementwise nosimp]\nlemma appLE_appIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] {U : Y.Opens}\n    {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U) :\n    f.appLE U V e ≫ (f.appIso V).inv =\n        Y.presheaf.map (homOfLE <| (f.image_le_image_of_le e).trans\n          (f.image_preimage_eq_opensRange_inter U ▸ inf_le_right)).op := by\n  simp only [appLE, Category.assoc, appIso_inv_naturality, Functor.op_obj, Functor.op_map,\n    Quiver.Hom.unop_op, opensFunctor_map_homOfLE, app_appIso_inv_assoc, Opens.carrier_eq_coe]\n  rw [← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_appLE","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appIso f U).inv (AlgebraicGeometry.Scheme.Hom.appLE f ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U) V e)) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[reassoc (attr := simp)]\nlemma appIso_inv_appLE {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] {U V : X.Opens}\n    (e : V ≤ f ⁻¹ᵁ f ''ᵁ U) :\n    (f.appIso U).inv ≫ f.appLE (f ''ᵁ U) V e =\n        X.presheaf.map (homOfLE (by rwa [preimage_image_eq] at e)).op := by\n  simp only [appLE, appIso_inv_app_assoc, eqToHom_op]\n  rw [← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.appIso_inv_appLE_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU V : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U))\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := V }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appIso f U).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appLE f ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U) V e) h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.map (CategoryTheory.homOfLE ⋯).op) h)","decl":"@[reassoc (attr := simp)]\nlemma appIso_inv_appLE {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] {U V : X.Opens}\n    (e : V ≤ f ⁻¹ᵁ f ''ᵁ U) :\n    (f.appIso U).inv ≫ f.appLE (f ''ᵁ U) V e =\n        X.presheaf.map (homOfLE (by rwa [preimage_image_eq] at e)).op := by\n  simp only [appLE, appIso_inv_app_assoc, eqToHom_op]\n  rw [← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.opensEquiv_apply_coe","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (↑((AlgebraicGeometry.IsOpenImmersion.opensEquiv f) U)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U)","decl":"/-- The open sets of an open subscheme corresponds to the open sets containing in the image. -/\n@[simps]\ndef IsOpenImmersion.opensEquiv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] :\n    X.Opens ≃ { U : Y.Opens // U ≤ f.opensRange } where\n  toFun U := ⟨f ''ᵁ U, Set.image_subset_range _ _⟩\n  invFun U := f ⁻¹ᵁ U\n  left_inv _ := Opens.ext (Set.preimage_image_eq _ f.isOpenEmbedding.injective)\n  right_inv U := Subtype.ext (Opens.ext (Set.image_preimage_eq_of_subset U.2))\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.opensEquiv_symm_apply","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Subtype fun U => LE.le U (AlgebraicGeometry.Scheme.Hom.opensRange f)\n⊢ Eq ((AlgebraicGeometry.IsOpenImmersion.opensEquiv f).symm U) ((TopologicalSpace.Opens.map f.base).obj ↑U)","decl":"/-- The open sets of an open subscheme corresponds to the open sets containing in the image. -/\n@[simps]\ndef IsOpenImmersion.opensEquiv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] :\n    X.Opens ≃ { U : Y.Opens // U ≤ f.opensRange } where\n  toFun U := ⟨f ''ᵁ U, Set.image_subset_range _ _⟩\n  invFun U := f ⁻¹ᵁ U\n  left_inv _ := Opens.ext (Set.preimage_image_eq _ f.isOpenEmbedding.injective)\n  right_inv U := Subtype.ext (Opens.ext (Set.image_preimage_eq_of_subset U.2))\n\n"}
{"name":"AlgebraicGeometry.Scheme.basic_open_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"R : CommRingCat\nf : ↑R\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap (↑R) (Localization.Away f))))","decl":"instance basic_open_isOpenImmersion {R : CommRingCat.{u}} (f : R) :\n    IsOpenImmersion (Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away f)))) := by\n  apply SheafedSpace.IsOpenImmersion.of_stalk_iso (H := ?_)\n  · exact (PrimeSpectrum.localization_away_isOpenEmbedding (Localization.Away f) f :)\n  · intro x\n    exact Spec_map_localization_isIso R (Submonoid.powers f) x\n\n"}
{"name":"AlgebraicGeometry.Scheme.instIsOpenImmersionMapOfHomAwayAlgebraMap","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away f))))","decl":"instance {R} [CommRing R] (f : R) :\n    IsOpenImmersion (Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away f)))) :=\n  basic_open_isOpenImmersion (R := .of R) f\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.of_isLocalization","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"R S : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nf : R\ninst✝ : IsLocalization.Away f S\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Spec.map (CommRingCat.ofHom (algebraMap R S)))","decl":"lemma _root_.AlgebraicGeometry.IsOpenImmersion.of_isLocalization {R S} [CommRing R] [CommRing S]\n    [Algebra R S] (f : R) [IsLocalization.Away f S] :\n    IsOpenImmersion (Spec.map (CommRingCat.ofHom (algebraMap R S))) := by\n  have e := (IsLocalization.algEquiv (.powers f) S\n    (Localization.Away f)).symm.toAlgHom.comp_algebraMap\n  rw [← e, CommRingCat.ofHom_comp, Spec.map_comp]\n  have H : IsIso (CommRingCat.ofHom (IsLocalization.algEquiv\n    (Submonoid.powers f) S (Localization.Away f)).symm.toAlgHom.toRingHom) := by\n    exact inferInstanceAs (IsIso <| (IsLocalization.algEquiv\n      (Submonoid.powers f) S (Localization.Away f)).toRingEquiv.toCommRingCatIso.inv)\n  simp only [AlgEquiv.toAlgHom_eq_coe, AlgHom.toRingHom_eq_coe, AlgEquiv.toAlgHom_toRingHom] at H ⊢\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.exists_affine_mem_range_and_range_subset","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ↑↑X.toPresheafedSpace\nU : X.Opens\nhxU : Membership.mem U x\n⊢ Exists fun R => Exists fun f => And (AlgebraicGeometry.IsOpenImmersion f) (And (Membership.mem (Set.range ⇑f.base) x) (HasSubset.Subset (Set.range ⇑f.base) ↑U))","decl":"theorem exists_affine_mem_range_and_range_subset\n    {X : Scheme.{u}} {x : X} {U : X.Opens} (hxU : x ∈ U) :\n    ∃ (R : CommRingCat) (f : Spec R ⟶ X),\n      IsOpenImmersion f ∧ x ∈ Set.range f.base ∧ Set.range f.base ⊆ U := by\n  obtain ⟨⟨V, hxV⟩, R, ⟨e⟩⟩ := X.2 x\n  have : e.hom.base ⟨x, hxV⟩ ∈ (Opens.map (e.inv.base ≫ V.inclusion')).obj U :=\n    show ((e.hom ≫ e.inv).base ⟨x, hxV⟩).1 ∈ U from e.hom_inv_id ▸ hxU\n  obtain ⟨_, ⟨_, ⟨r : R, rfl⟩, rfl⟩, hr, hr'⟩ :=\n    PrimeSpectrum.isBasis_basic_opens.exists_subset_of_mem_open this (Opens.is_open' _)\n  let f : Spec (CommRingCat.of (Localization.Away r)) ⟶ X :=\n    Spec.map (CommRingCat.ofHom (algebraMap R (Localization.Away r))) ≫ ⟨e.inv ≫ X.ofRestrict _⟩\n  refine ⟨.of (Localization.Away r), f, inferInstance, ?_⟩\n  rw [Scheme.comp_base, TopCat.coe_comp, Set.range_comp]\n  erw [PrimeSpectrum.localization_away_comap_range (Localization.Away r) r]\n  exact ⟨⟨_, hr, congr(($(e.hom_inv_id).base ⟨x, hxV⟩).1)⟩, Set.image_subset_iff.mpr hr'⟩\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toScheme_toLocallyRingedSpace","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X : AlgebraicGeometry.PresheafedSpace CommRingCat\nY : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y.toPresheafedSpace\nH : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toScheme Y f).toLocallyRingedSpace (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toLocallyRingedSpace Y.toLocallyRingedSpace f)","decl":"@[simp]\ntheorem toScheme_toLocallyRingedSpace :\n    (toScheme Y f).toLocallyRingedSpace = toLocallyRingedSpace Y.1 f :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toSchemeHom_toPshHom","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X : AlgebraicGeometry.PresheafedSpace CommRingCat\nY : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y.toPresheafedSpace\nH : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toSchemeHom Y f).toPshHom f","decl":"@[simp]\ntheorem toSchemeHom_toPshHom : (toSchemeHom Y f).toPshHom = f :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toSchemeHom_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X : AlgebraicGeometry.PresheafedSpace CommRingCat\nY : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y.toPresheafedSpace\nH : AlgebraicGeometry.PresheafedSpace.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toSchemeHom Y f)","decl":"instance toSchemeHom_isOpenImmersion : AlgebraicGeometry.IsOpenImmersion (toSchemeHom Y f) :=\n  H\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.scheme_eq_of_locallyRingedSpace_eq","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nH : Eq X.toLocallyRingedSpace Y.toLocallyRingedSpace\n⊢ Eq X Y","decl":"theorem scheme_eq_of_locallyRingedSpace_eq {X Y : Scheme.{u}}\n    (H : X.toLocallyRingedSpace = Y.toLocallyRingedSpace) : X = Y := by\n  cases X; cases Y; congr\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.scheme_toScheme","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.toScheme Y f.toPshHom) X","decl":"theorem scheme_toScheme {X Y : Scheme.{u}} (f : X ⟶ Y) [AlgebraicGeometry.IsOpenImmersion f] :\n    toScheme Y f.toPshHom = X := by\n  apply scheme_eq_of_locallyRingedSpace_eq\n  exact locallyRingedSpace_toLocallyRingedSpace f.toLRSHom\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrict_carrier","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\n⊢ Eq (↑(X.restrict h).toPresheafedSpace) U","decl":"/-- The restriction of a Scheme along an open embedding. -/\n@[simps! (config := .lemmasOnly) carrier, simps! presheaf_obj]\ndef Scheme.restrict : Scheme :=\n  { PresheafedSpace.IsOpenImmersion.toScheme X (X.toPresheafedSpace.ofRestrict h) with\n    toPresheafedSpace := X.toPresheafedSpace.restrict h }\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrict_presheaf_obj","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X✝.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nX : Opposite (TopologicalSpace.Opens ↑U)\n⊢ Eq ((X✝.restrict h).presheaf.obj X) (X✝.presheaf.obj { unop := ⋯.functor.obj (Opposite.unop X) })","decl":"/-- The restriction of a Scheme along an open embedding. -/\n@[simps! (config := .lemmasOnly) carrier, simps! presheaf_obj]\ndef Scheme.restrict : Scheme :=\n  { PresheafedSpace.IsOpenImmersion.toScheme X (X.toPresheafedSpace.ofRestrict h) with\n    toPresheafedSpace := X.toPresheafedSpace.restrict h }\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrict_toPresheafedSpace","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\n⊢ Eq (X.restrict h).toPresheafedSpace (X.restrict h)","decl":"lemma Scheme.restrict_toPresheafedSpace :\n    (X.restrict h).toPresheafedSpace = X.toPresheafedSpace.restrict h := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.ofRestrict_toLRSHom_c_app","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nV : Opposite (TopologicalSpace.Opens ↑↑X.toPresheafedSpace)\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.toLRSHom (X.ofRestrict h)).c.app V) (X.presheaf.map (⋯.adjunction.counit.app (Opposite.unop V)).op)","decl":"/-- The canonical map from the restriction to the subspace. -/\n@[simps! toLRSHom_base, simps! (config := .lemmasOnly) toLRSHom_c_app]\ndef Scheme.ofRestrict : X.restrict h ⟶ X :=\n  ⟨X.toLocallyRingedSpace.ofRestrict h⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.ofRestrict_toLRSHom_base","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.toLRSHom (X.ofRestrict h)).base f","decl":"/-- The canonical map from the restriction to the subspace. -/\n@[simps! toLRSHom_base, simps! (config := .lemmasOnly) toLRSHom_c_app]\ndef Scheme.ofRestrict : X.restrict h ⟶ X :=\n  ⟨X.toLocallyRingedSpace.ofRestrict h⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.ofRestrict_app","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nV : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (X.ofRestrict h) V) (X.presheaf.map (⋯.adjunction.counit.app V).op)","decl":"@[simp]\nlemma Scheme.ofRestrict_app (V) :\n    (X.ofRestrict h).app V = X.presheaf.map (h.isOpenMap.adjunction.counit.app V).op  :=\n  Scheme.ofRestrict_toLRSHom_c_app X h (op V)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.ofRestrict","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\n⊢ AlgebraicGeometry.IsOpenImmersion (X.ofRestrict h)","decl":"instance IsOpenImmersion.ofRestrict : IsOpenImmersion (X.ofRestrict h) :=\n  show PresheafedSpace.IsOpenImmersion (X.toPresheafedSpace.ofRestrict h) by infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.ofRestrict_appLE","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nV : X.Opens\nW : (X.restrict h).Opens\ne : LE.le W ((TopologicalSpace.Opens.map (X.ofRestrict h).base).obj V)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE (X.ofRestrict h) V W e) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\nlemma Scheme.ofRestrict_appLE (V W e) :\n    (X.ofRestrict h).appLE V W e = X.presheaf.map\n      (homOfLE (show X.ofRestrict h ''ᵁ _ ≤ _ by exact Set.image_subset_iff.mpr e)).op := by\n  dsimp [Hom.appLE]\n  exact (X.presheaf.map_comp _ _).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.ofRestrict_appIso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U✝ : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U✝ (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nU : (X.restrict h).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appIso (X.ofRestrict h) U) (CategoryTheory.Iso.refl (X.presheaf.obj { unop := (AlgebraicGeometry.Scheme.Hom.opensFunctor (X.ofRestrict h)).obj U }))","decl":"@[simp]\nlemma Scheme.ofRestrict_appIso (U) :\n    (X.ofRestrict h).appIso U = Iso.refl _ := by\n  ext1\n  simp only [restrict_presheaf_obj, Hom.appIso_hom', ofRestrict_appLE, homOfLE_refl, op_id,\n    CategoryTheory.Functor.map_id, Iso.refl_hom]\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrict_presheaf_map","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"U : TopCat\nX : AlgebraicGeometry.Scheme\nf : Quiver.Hom U (TopCat.of ↑↑X.toPresheafedSpace)\nh : Topology.IsOpenEmbedding ⇑f\nV W : Opposite (TopologicalSpace.Opens ↑↑(X.restrict h).toPresheafedSpace)\ni : Quiver.Hom V W\n⊢ Eq ((X.restrict h).presheaf.map i) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\nlemma Scheme.restrict_presheaf_map (V W) (i : V ⟶ W) :\n    (X.restrict h).presheaf.map i = X.presheaf.map (homOfLE (show X.ofRestrict h ''ᵁ W.unop ≤\n      X.ofRestrict h ''ᵁ V.unop from Set.image_subset _ i.unop.le)).op := rfl\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.of_isIso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"Y Z : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso g\n⊢ AlgebraicGeometry.IsOpenImmersion g","decl":"instance (priority := 100) of_isIso [IsIso g] : IsOpenImmersion g :=\n  LocallyRingedSpace.IsOpenImmersion.of_isIso _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.to_iso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nh : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : CategoryTheory.Epi f.base\n⊢ CategoryTheory.IsIso f","decl":"theorem to_iso {X Y : Scheme.{u}} (f : X ⟶ Y) [h : IsOpenImmersion f] [Epi f.base] : IsIso f :=\n  @isIso_of_reflects_iso _ _ _ _ _ _ f\n    (Scheme.forgetToLocallyRingedSpace ⋙\n      LocallyRingedSpace.forgetToSheafedSpace ⋙ SheafedSpace.forgetToPresheafedSpace)\n    (@PresheafedSpace.IsOpenImmersion.to_iso _ _ _ _ f.toPshHom h _) _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.of_stalk_iso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding ⇑f.base\ninst✝ : ∀ (x : ↑↑X.toPresheafedSpace), CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap f x)\n⊢ AlgebraicGeometry.IsOpenImmersion f","decl":"theorem of_stalk_iso {X Y : Scheme.{u}} (f : X ⟶ Y) (hf : IsOpenEmbedding f.base)\n    [∀ x, IsIso (f.stalkMap x)] : IsOpenImmersion f :=\n  haveI (x : X) : IsIso (f.toShHom.stalkMap x) := inferInstanceAs <| IsIso (f.stalkMap x)\n  SheafedSpace.IsOpenImmersion.of_stalk_iso f.toShHom hf\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.stalk_iso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nx : ↑↑X.toPresheafedSpace\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap f x)","decl":"instance stalk_iso {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (x : X) :\n    IsIso (f.stalkMap x) :=\n  inferInstanceAs <| IsIso (f.toLRSHom.stalkMap x)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.of_comp","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion g\ninst✝ : AlgebraicGeometry.IsOpenImmersion (CategoryTheory.CategoryStruct.comp f g)\n⊢ AlgebraicGeometry.IsOpenImmersion f","decl":"lemma of_comp {X Y Z : Scheme.{u}} (f : X ⟶ Y) (g : Y ⟶ Z) [IsOpenImmersion g]\n    [IsOpenImmersion (f ≫ g)] : IsOpenImmersion f :=\n  haveI (x : X) : IsIso (f.stalkMap x) :=\n    haveI : IsIso (g.stalkMap (f.base x) ≫ f.stalkMap x) := by\n      rw [← Scheme.stalkMap_comp]\n      infer_instance\n    IsIso.of_isIso_comp_left (f := g.stalkMap (f.base x)) _\n  IsOpenImmersion.of_stalk_iso _ <|\n    IsOpenEmbedding.of_comp _ (Scheme.Hom.isOpenEmbedding g) (Scheme.Hom.isOpenEmbedding (f ≫ g))\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.iff_stalk_iso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsOpenImmersion f) (And (Topology.IsOpenEmbedding ⇑f.base) (∀ (x : ↑↑X.toPresheafedSpace), CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap f x)))","decl":"theorem iff_stalk_iso {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    IsOpenImmersion f ↔ IsOpenEmbedding f.base ∧ ∀ x, IsIso (f.stalkMap x) :=\n  ⟨fun H => ⟨H.1, fun x ↦ inferInstanceAs <| IsIso (f.toPshHom.stalkMap x)⟩,\n    fun ⟨h, _⟩ => IsOpenImmersion.of_stalk_iso f h⟩\n\n"}
{"name":"AlgebraicGeometry.isIso_iff_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.IsIso f) (And (AlgebraicGeometry.IsOpenImmersion f) (CategoryTheory.Epi f.base))","decl":"theorem _root_.AlgebraicGeometry.isIso_iff_isOpenImmersion {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    IsIso f ↔ IsOpenImmersion f ∧ Epi f.base :=\n  ⟨fun _ => ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ => IsOpenImmersion.to_iso f⟩\n\n"}
{"name":"AlgebraicGeometry.isIso_iff_stalk_iso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.IsIso f) (And (CategoryTheory.IsIso f.base) (∀ (x : ↑↑X.toPresheafedSpace), CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap f x)))","decl":"theorem _root_.AlgebraicGeometry.isIso_iff_stalk_iso {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    IsIso f ↔ IsIso f.base ∧ ∀ x, IsIso (f.stalkMap x) := by\n  rw [isIso_iff_isOpenImmersion, IsOpenImmersion.iff_stalk_iso, and_comm, ← and_assoc]\n  refine and_congr ⟨?_, ?_⟩ Iff.rfl\n  · rintro ⟨h₁, h₂⟩\n    convert_to\n      IsIso\n        (TopCat.isoOfHomeo\n            (Homeomorph.homeomorphOfContinuousOpen\n              (.ofBijective _ ⟨h₂.injective, (TopCat.epi_iff_surjective _).mp h₁⟩) h₂.continuous\n              h₂.isOpenMap)).hom\n    infer_instance\n  · intro H; exact ⟨inferInstance, (TopCat.homeoOfIso (asIso f.base)).isOpenEmbedding⟩\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.mono","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\n⊢ CategoryTheory.Mono f","decl":"instance mono : Mono f :=\n  Scheme.forgetToLocallyRingedSpace.mono_of_mono_map\n    (show Mono f.toLRSHom by infer_instance)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.forget_map_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace.map f)","decl":"instance forget_map_isOpenImmersion : LocallyRingedSpace.IsOpenImmersion ((forget).map f) :=\n  ⟨H.base_open, H.c_iso⟩\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasLimit_cospan_forget_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ CategoryTheory.Limits.HasLimit ((CategoryTheory.Limits.cospan f g).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace)","decl":"instance hasLimit_cospan_forget_of_left :\n    HasLimit (cospan f g ⋙ Scheme.forgetToLocallyRingedSpace) := by\n  apply @hasLimitOfIso _ _ _ _ _ _ ?_ (diagramIsoCospan.{u} _).symm\n  change HasLimit (cospan ((forget).map f) ((forget).map g))\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasLimit_cospan_forget_of_left'","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan (((CategoryTheory.Limits.cospan f g).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace).map CategoryTheory.Limits.WalkingCospan.Hom.inl) (((CategoryTheory.Limits.cospan f g).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace).map CategoryTheory.Limits.WalkingCospan.Hom.inr))","decl":"instance hasLimit_cospan_forget_of_left' :\n    HasLimit (cospan ((cospan f g ⋙ forget).map Hom.inl) ((cospan f g ⋙ forget).map Hom.inr)) :=\n  show HasLimit (cospan ((forget).map f) ((forget).map g)) from inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasLimit_cospan_forget_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ CategoryTheory.Limits.HasLimit ((CategoryTheory.Limits.cospan g f).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace)","decl":"instance hasLimit_cospan_forget_of_right : HasLimit (cospan g f ⋙ forget) := by\n  apply @hasLimitOfIso _ _ _ _ _ _ ?_ (diagramIsoCospan.{u} _).symm\n  change HasLimit (cospan ((forget).map g) ((forget).map f))\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasLimit_cospan_forget_of_right'","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.cospan (((CategoryTheory.Limits.cospan g f).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace).map CategoryTheory.Limits.WalkingCospan.Hom.inl) (((CategoryTheory.Limits.cospan g f).comp AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace).map CategoryTheory.Limits.WalkingCospan.Hom.inr))","decl":"instance hasLimit_cospan_forget_of_right' :\n    HasLimit (cospan ((cospan g f ⋙ forget).map Hom.inl) ((cospan g f ⋙ forget).map Hom.inr)) :=\n  show HasLimit (cospan ((forget).map g) ((forget).map f)) from inferInstance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.forget_preservesOfLeft","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace","decl":"instance forget_preservesOfLeft : PreservesLimit (cospan f g) forget :=\n  CategoryTheory.preservesLimit_of_createsLimit_and_hasLimit _ _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.forget_preservesOfRight","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan g f) AlgebraicGeometry.Scheme.forgetToLocallyRingedSpace","decl":"instance forget_preservesOfRight : PreservesLimit (cospan g f) forget :=\n  preservesPullback_symmetry _ _ _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasPullback_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"instance hasPullback_of_left : HasPullback f g :=\n  hasLimit_of_created (cospan f g) forget\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.hasPullback_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ CategoryTheory.Limits.HasPullback g f","decl":"instance hasPullback_of_right : HasPullback g f :=\n  hasLimit_of_created (cospan g f) forget\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.pullback_snd_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.pullback.snd f g)","decl":"instance pullback_snd_of_left : IsOpenImmersion (pullback.snd f g) := by\n  have := PreservesPullback.iso_hom_snd forget f g\n  dsimp only [Scheme.forgetToLocallyRingedSpace, inducedFunctor_map] at this\n  change LocallyRingedSpace.IsOpenImmersion _\n  rw [← this]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.pullback_fst_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.pullback.fst g f)","decl":"instance pullback_fst_of_right : IsOpenImmersion (pullback.fst g f) := by\n  rw [← pullbackSymmetry_hom_comp_snd]\n  -- Porting note: was just `infer_instance`, it is a bit weird that no explicit class instance is\n  -- provided but still class inference fail to find this\n  exact LocallyRingedSpace.IsOpenImmersion.comp (H := inferInstance) _ _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.pullback_to_base","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\n⊢ AlgebraicGeometry.IsOpenImmersion (CategoryTheory.Limits.limit.π (CategoryTheory.Limits.cospan f g) CategoryTheory.Limits.WalkingCospan.one)","decl":"instance pullback_to_base [IsOpenImmersion g] :\n    IsOpenImmersion (limit.π (cospan f g) WalkingCospan.one) := by\n  rw [← limit.w (cospan f g) WalkingCospan.Hom.inl]\n  change IsOpenImmersion (_ ≫ f)\n  -- Porting note: was just `infer_instance`, it is a bit weird that no explicit class instance is\n  -- provided but still class inference fail to find this\n  exact LocallyRingedSpace.IsOpenImmersion.comp (H := inferInstance) _ _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.forgetToTop_preserves_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) AlgebraicGeometry.Scheme.forgetToTop","decl":"instance forgetToTop_preserves_of_left : PreservesLimit (cospan f g) Scheme.forgetToTop := by\n  delta Scheme.forgetToTop\n  refine @Limits.comp_preservesLimit _ _ _ _ _ _ (K := cospan f g) _ _ (F := forget)\n    (G := LocallyRingedSpace.forgetToTop) ?_ ?_\n  · infer_instance\n  refine @preservesLimit_of_iso_diagram _ _ _ _ _ _ _ _ _ (diagramIsoCospan.{u} _).symm ?_\n  dsimp [LocallyRingedSpace.forgetToTop]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.forgetToTop_preserves_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan g f) AlgebraicGeometry.Scheme.forgetToTop","decl":"instance forgetToTop_preserves_of_right : PreservesLimit (cospan g f) Scheme.forgetToTop :=\n  preservesPullback_symmetry _ _ _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.range_pullback_snd_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.snd f g).base) ((TopologicalSpace.Opens.map g.base).obj (AlgebraicGeometry.Scheme.Hom.opensRange f)).carrier","decl":"theorem range_pullback_snd_of_left :\n    Set.range (pullback.snd f g).base = (g ⁻¹ᵁ f.opensRange).1 := by\n  rw [← show _ = (pullback.snd f g).base from\n    PreservesPullback.iso_hom_snd Scheme.forgetToTop f g, TopCat.coe_comp, Set.range_comp,\n    Set.range_eq_univ.mpr, ← @Set.preimage_univ _ _ (pullback.fst f.base g.base)]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw`\n  · erw [TopCat.pullback_snd_image_fst_preimage]\n    rw [Set.image_univ]\n    rfl\n  rw [← TopCat.epi_iff_surjective]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.opensRange_pullback_snd_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.Limits.pullback.snd f g)) ((TopologicalSpace.Opens.map g.base).obj (AlgebraicGeometry.Scheme.Hom.opensRange f))","decl":"theorem opensRange_pullback_snd_of_left :\n    (pullback.snd f g).opensRange = g ⁻¹ᵁ f.opensRange :=\n  Opens.ext (range_pullback_snd_of_left f g)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.range_pullback_fst_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.pullback.fst g f).base) ((TopologicalSpace.Opens.map g.base).obj { carrier := Set.range ⇑f.base, is_open' := ⋯ }).carrier","decl":"theorem range_pullback_fst_of_right :\n    Set.range (pullback.fst g f).base =\n      ((Opens.map g.base).obj ⟨Set.range f.base, H.base_open.isOpen_range⟩).1 := by\n  rw [← show _ = (pullback.fst g f).base from\n    PreservesPullback.iso_hom_fst Scheme.forgetToTop g f, TopCat.coe_comp, Set.range_comp,\n    Set.range_eq_univ.mpr, ← @Set.preimage_univ _ _ (pullback.snd g.base f.base)]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw`\n  · erw [TopCat.pullback_fst_image_snd_preimage]\n    rw [Set.image_univ]\n    rfl\n  rw [← TopCat.epi_iff_surjective]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.opensRange_pullback_fst_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange (CategoryTheory.Limits.pullback.fst g f)) ((TopologicalSpace.Opens.map g.base).obj (AlgebraicGeometry.Scheme.Hom.opensRange f))","decl":"theorem opensRange_pullback_fst_of_right :\n    (pullback.fst g f).opensRange = g ⁻¹ᵁ f.opensRange :=\n  Opens.ext (range_pullback_fst_of_right f g)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.range_pullback_to_base_of_left","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (Set.range ⇑(CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) f).base) (Inter.inter (Set.range ⇑f.base) (Set.range ⇑g.base))","decl":"theorem range_pullback_to_base_of_left :\n    Set.range (pullback.fst f g ≫ f).base =\n      Set.range f.base ∩ Set.range g.base := by\n  rw [pullback.condition, Scheme.comp_base, TopCat.coe_comp, Set.range_comp,\n    range_pullback_snd_of_left, Opens.carrier_eq_coe, Opens.map_obj, Opens.coe_mk,\n    Set.image_preimage_eq_inter_range, Opens.carrier_eq_coe, Scheme.Hom.coe_opensRange]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.range_pullback_to_base_of_right","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\n⊢ Eq (Set.range ⇑(CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst g f) g).base) (Inter.inter (Set.range ⇑g.base) (Set.range ⇑f.base))","decl":"theorem range_pullback_to_base_of_right :\n    Set.range (pullback.fst g f ≫ g).base =\n      Set.range g.base ∩ Set.range f.base := by\n  rw [Scheme.comp_base, TopCat.coe_comp, Set.range_comp, range_pullback_fst_of_right,\n    Opens.map_obj, Opens.carrier_eq_coe, Opens.coe_mk, Set.image_preimage_eq_inter_range,\n    Set.inter_comm]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.lift_fac_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nH : AlgebraicGeometry.IsOpenImmersion f\nH' : HasSubset.Subset (Set.range ⇑g.base) (Set.range ⇑f.base)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.lift f g H') (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[simp, reassoc]\ntheorem lift_fac (H' : Set.range g.base ⊆ Set.range f.base) : lift f g H' ≫ f = g :=\n  Scheme.Hom.ext' <| LocallyRingedSpace.IsOpenImmersion.lift_fac f.toLRSHom g.toLRSHom H'\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.lift_fac","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\nH' : HasSubset.Subset (Set.range ⇑g.base) (Set.range ⇑f.base)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.lift f g H') f) g","decl":"@[simp, reassoc]\ntheorem lift_fac (H' : Set.range g.base ⊆ Set.range f.base) : lift f g H' ≫ f = g :=\n  Scheme.Hom.ext' <| LocallyRingedSpace.IsOpenImmersion.lift_fac f.toLRSHom g.toLRSHom H'\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.lift_uniq","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nH : AlgebraicGeometry.IsOpenImmersion f\nH' : HasSubset.Subset (Set.range ⇑g.base) (Set.range ⇑f.base)\nl : Quiver.Hom Y X\nhl : Eq (CategoryTheory.CategoryStruct.comp l f) g\n⊢ Eq l (AlgebraicGeometry.IsOpenImmersion.lift f g H')","decl":"theorem lift_uniq (H' : Set.range g.base ⊆ Set.range f.base) (l : Y ⟶ X) (hl : l ≫ f = g) :\n    l = lift f g H' :=\n  Scheme.Hom.ext' <| LocallyRingedSpace.IsOpenImmersion.lift_uniq\n    f.toLRSHom g.toLRSHom H' l.toLRSHom congr(($hl).toLRSHom)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq_hom_fac_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\ne : Eq (Set.range ⇑f.base) (Set.range ⇑g.base)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq f g e).hom (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[simp, reassoc]\nlemma isoOfRangeEq_hom_fac {X Y Z : Scheme.{u}} (f : X ⟶ Z) (g : Y ⟶ Z)\n    [IsOpenImmersion f] [IsOpenImmersion g] (e : Set.range f.base = Set.range g.base) :\n    (isoOfRangeEq f g e).hom ≫ g = f :=\n  lift_fac _ _ (le_of_eq e)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq_hom_fac","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\ne : Eq (Set.range ⇑f.base) (Set.range ⇑g.base)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq f g e).hom g) f","decl":"@[simp, reassoc]\nlemma isoOfRangeEq_hom_fac {X Y Z : Scheme.{u}} (f : X ⟶ Z) (g : Y ⟶ Z)\n    [IsOpenImmersion f] [IsOpenImmersion g] (e : Set.range f.base = Set.range g.base) :\n    (isoOfRangeEq f g e).hom ≫ g = f :=\n  lift_fac _ _ (le_of_eq e)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq_inv_fac_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z✝ : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\ne : Eq (Set.range ⇑f.base) (Set.range ⇑g.base)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Z✝ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq f g e).inv (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[simp, reassoc]\nlemma isoOfRangeEq_inv_fac {X Y Z : Scheme.{u}} (f : X ⟶ Z) (g : Y ⟶ Z)\n    [IsOpenImmersion f] [IsOpenImmersion g] (e : Set.range f.base = Set.range g.base) :\n    (isoOfRangeEq f g e).inv ≫ f = g :=\n  lift_fac _ _ (le_of_eq e.symm)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq_inv_fac","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\ne : Eq (Set.range ⇑f.base) (Set.range ⇑g.base)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.isoOfRangeEq f g e).inv f) g","decl":"@[simp, reassoc]\nlemma isoOfRangeEq_inv_fac {X Y Z : Scheme.{u}} (f : X ⟶ Z) (g : Y ⟶ Z)\n    [IsOpenImmersion f] [IsOpenImmersion g] (e : Set.range f.base = Set.range g.base) :\n    (isoOfRangeEq f g e).inv ≫ f = g :=\n  lift_fac _ _ (le_of_eq e.symm)\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y U : AlgebraicGeometry.Scheme\nf : Quiver.Hom Y U\ng : Quiver.Hom U X\nfg : Quiver.Hom Y X\nH : Eq fg (CategoryTheory.CategoryStruct.comp f g)\nh : AlgebraicGeometry.IsOpenImmersion g\nV : U.Opens\n⊢ Eq ((TopologicalSpace.Opens.map f.base).obj V) ((TopologicalSpace.Opens.map fg.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor g).obj V))","decl":"theorem app_eq_invApp_app_of_comp_eq_aux {X Y U : Scheme.{u}} (f : Y ⟶ U) (g : U ⟶ X) (fg : Y ⟶ X)\n    (H : fg = f ≫ g) [h : IsOpenImmersion g] (V : U.Opens) :\n    f ⁻¹ᵁ V = fg ⁻¹ᵁ (g ''ᵁ V) := by\n  subst H\n  rw [Scheme.comp_base, Opens.map_comp_obj]\n  congr 1\n  ext1\n  exact (Set.preimage_image_eq _ h.base_open.injective).symm\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.app_eq_appIso_inv_app_of_comp_eq","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y U : AlgebraicGeometry.Scheme\nf : Quiver.Hom Y U\ng : Quiver.Hom U X\nfg : Quiver.Hom Y X\nH : Eq fg (CategoryTheory.CategoryStruct.comp f g)\nh : AlgebraicGeometry.IsOpenImmersion g\nV : U.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app f V) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appIso g V).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app fg ((AlgebraicGeometry.Scheme.Hom.opensFunctor g).obj V)) (Y.presheaf.map (CategoryTheory.eqToHom ⋯).op)))","decl":"/-- The `fg` argument is to avoid nasty stuff about dependent types. -/\ntheorem app_eq_appIso_inv_app_of_comp_eq {X Y U : Scheme.{u}} (f : Y ⟶ U) (g : U ⟶ X) (fg : Y ⟶ X)\n    (H : fg = f ≫ g) [h : IsOpenImmersion g] (V : U.Opens) :\n    f.app V = (g.appIso V).inv ≫ fg.app (g ''ᵁ V) ≫ Y.presheaf.map\n      (eqToHom <| IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux f g fg H V).op := by\n  subst H\n  rw [Scheme.comp_app, Category.assoc, Scheme.Hom.appIso_inv_app_assoc, f.naturality_assoc,\n    ← Functor.map_comp, ← op_comp, Quiver.Hom.unop_op, eqToHom_map, eqToHom_trans,\n    eqToHom_op, eqToHom_refl, CategoryTheory.Functor.map_id, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.lift_app","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y U : AlgebraicGeometry.Scheme\nf : Quiver.Hom U Y\ng : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nH : HasSubset.Subset (Set.range ⇑g.base) (Set.range ⇑f.base)\nV : U.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (AlgebraicGeometry.IsOpenImmersion.lift f g H) V) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.appIso f V).inv (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app g ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj V)) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)))","decl":"theorem lift_app {X Y U : Scheme.{u}} (f : U ⟶ Y) (g : X ⟶ Y) [IsOpenImmersion f] (H)\n    (V : U.Opens) :\n    (IsOpenImmersion.lift f g H).app V = (f.appIso V).inv ≫ g.app (f ''ᵁ V) ≫\n      X.presheaf.map (eqToHom <| IsOpenImmersion.app_eq_invApp_app_of_comp_eq_aux _ _ _\n        (IsOpenImmersion.lift_fac f g H).symm V).op :=\n  IsOpenImmersion.app_eq_appIso_inv_app_of_comp_eq _ _ _ (lift_fac _ _ _).symm _\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.ΓIso_inv","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).inv (AlgebraicGeometry.Scheme.Hom.appLE f (Min.min (AlgebraicGeometry.Scheme.Hom.opensRange f) U) ((TopologicalSpace.Opens.map f.base).obj U) ⋯)","decl":"@[simp]\nlemma ΓIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    (ΓIso f U).inv = f.appLE (f.opensRange ⊓ U) (f⁻¹ᵁ U)\n      (by rw [← f.image_preimage_eq_opensRange_inter, f.preimage_image_eq]) := by\n  simp only [ΓIso, Iso.trans_inv, Functor.mapIso_inv, Iso.op_inv, eqToIso.inv, eqToHom_op,\n    asIso_inv, IsIso.comp_inv_eq, Iso.symm_inv, Scheme.Hom.appIso_hom', Scheme.Hom.map_appLE]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.map_ΓIso_inv","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op) (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).inv) (AlgebraicGeometry.Scheme.Hom.app f U)","decl":"@[reassoc, elementwise]\nlemma map_ΓIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    Y.presheaf.map (homOfLE inf_le_right).op ≫ (ΓIso f U).inv = f.app U := by\n  simp [Scheme.Hom.appLE_eq_app]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.map_ΓIso_inv_apply","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nx : CategoryTheory.ToType (Y.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appLE f (Min.min (AlgebraicGeometry.Scheme.Hom.opensRange f) U) ((TopologicalSpace.Opens.map f.base).obj U) ⋯)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)) x)) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app f U)) x)","decl":"@[reassoc, elementwise]\nlemma map_ΓIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    Y.presheaf.map (homOfLE inf_le_right).op ≫ (ΓIso f U).inv = f.app U := by\n  simp [Scheme.Hom.appLE_eq_app]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.map_ΓIso_inv_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.obj { unop := (TopologicalSpace.Opens.map f.base).obj U }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).inv h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) h)","decl":"@[reassoc, elementwise]\nlemma map_ΓIso_inv {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    Y.presheaf.map (homOfLE inf_le_right).op ≫ (ΓIso f U).inv = f.app U := by\n  simp [Scheme.Hom.appLE_eq_app]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.ΓIso_hom_map","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).hom) (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[reassoc, elementwise]\nlemma ΓIso_hom_map {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    f.app U ≫ (ΓIso f U).hom = Y.presheaf.map (homOfLE inf_le_right).op := by\n  rw [← map_ΓIso_inv]\n  simp [-ΓIso_inv]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.ΓIso_hom_map_apply","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nx : CategoryTheory.ToType (Y.presheaf.obj { unop := U })\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).hom) ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.app f U)) x)) ((CategoryTheory.ConcreteCategory.hom (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op)) x)","decl":"@[reassoc, elementwise]\nlemma ΓIso_hom_map {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    f.app U ≫ (ΓIso f U).hom = Y.presheaf.map (homOfLE inf_le_right).op := by\n  rw [← map_ΓIso_inv]\n  simp [-ΓIso_inv]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.ΓIso_hom_map_assoc","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : Y.Opens\nZ : CommRingCat\nh : Quiver.Hom (Y.presheaf.obj { unop := Min.min (AlgebraicGeometry.Scheme.Hom.opensRange f) U }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.IsOpenImmersion.ΓIso f U).hom h)) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.homOfLE ⋯).op) h)","decl":"@[reassoc, elementwise]\nlemma ΓIso_hom_map {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : Y.Opens) :\n    f.app U ≫ (ΓIso f U).hom = Y.presheaf.map (homOfLE inf_le_right).op := by\n  rw [← map_ΓIso_inv]\n  simp [-ΓIso_inv]\n\n"}
{"name":"AlgebraicGeometry.IsOpenImmersion.instLift","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsOpenImmersion f\nH' : HasSubset.Subset (Set.range ⇑g.base) (Set.range ⇑f.base)\ninst✝ : AlgebraicGeometry.IsOpenImmersion g\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.IsOpenImmersion.lift f g H')","decl":"instance {Z : Scheme.{u}} (f : X ⟶ Z) (g : Y ⟶ Z) [IsOpenImmersion f]\n    (H' : Set.range g.base ⊆ Set.range f.base) [IsOpenImmersion g] :\n    IsOpenImmersion (IsOpenImmersion.lift f g H') :=\n  haveI : IsOpenImmersion (IsOpenImmersion.lift f g H' ≫ f) := by simpa\n  IsOpenImmersion.of_comp _ f\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_isStableUnderComposition","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.IsOpenImmersion","decl":"instance isOpenImmersion_isStableUnderComposition :\n    MorphismProperty.IsStableUnderComposition @IsOpenImmersion where\n  comp_mem f g _ _ := LocallyRingedSpace.IsOpenImmersion.comp f.toLRSHom g.toLRSHom\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_respectsIso","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.RespectsIso @AlgebraicGeometry.IsOpenImmersion","decl":"instance isOpenImmersion_respectsIso : MorphismProperty.RespectsIso @IsOpenImmersion := by\n  apply MorphismProperty.respectsIso_of_isStableUnderComposition\n  intro _ _ f (hf : IsIso f)\n  have : IsIso f := hf\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_isMultiplicative","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsMultiplicative @AlgebraicGeometry.IsOpenImmersion","decl":"instance isOpenImmersion_isMultiplicative :\n    MorphismProperty.IsMultiplicative @IsOpenImmersion where\n  id_mem _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_stableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsOpenImmersion","decl":"instance isOpenImmersion_stableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange @IsOpenImmersion :=\n  MorphismProperty.IsStableUnderBaseChange.mk' <| by\n    intro X Y Z f g _ H; infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.image_basicOpen","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nr : ↑(X.presheaf.obj { unop := U })\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj (X.basicOpen r)) (Y.basicOpen ((CategoryTheory.ConcreteCategory.hom (AlgebraicGeometry.Scheme.Hom.appIso f U).inv) r))","decl":"theorem image_basicOpen {U : X.Opens} (r : Γ(X, U)) :\n    f ''ᵁ X.basicOpen r = Y.basicOpen ((f.appIso U).inv r) := by\n  have e := Scheme.preimage_basicOpen f ((f.appIso U).inv r)\n  rw [Scheme.Hom.appIso_inv_app_apply', Scheme.basicOpen_res, inf_eq_right.mpr _] at e\n  · rw [← e, f.image_preimage_eq_opensRange_inter, inf_eq_right]\n    refine Set.Subset.trans (Scheme.basicOpen_le _ _) (Set.image_subset_range _ _)\n  · exact (X.basicOpen_le r).trans (f.preimage_image_eq _).ge\n\n"}
{"name":"AlgebraicGeometry.Scheme.image_zeroLocus","module":"Mathlib.AlgebraicGeometry.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\ns : Set ↑(X.presheaf.obj { unop := U })\n⊢ Eq (Set.image (⇑f.base) (X.zeroLocus s)) (Inter.inter (Y.zeroLocus (Set.image (⇑(CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appIso f U).inv)) s)) (Set.range ⇑f.base))","decl":"lemma image_zeroLocus {U : X.Opens} (s : Set Γ(X, U)) :\n    f.base '' X.zeroLocus s =\n      Y.zeroLocus (U := f ''ᵁ U) ((f.appIso U).inv.hom '' s) ∩ Set.range f.base := by\n  ext x\n  by_cases hx : x ∈ Set.range f.base\n  · obtain ⟨x, rfl⟩ := hx\n    simp only [f.isOpenEmbedding.injective.mem_set_image, Scheme.mem_zeroLocus_iff,\n      ← SetLike.mem_coe, Set.mem_inter_iff, Set.forall_mem_image, ← Scheme.image_basicOpen,\n      IsOpenMap.coe_functor_obj, Set.mem_range, exists_apply_eq_apply, and_true]\n  · simp only [Set.mem_inter_iff, hx, and_false, iff_false]\n    exact fun H ↦ hx (Set.image_subset_range _ _ H)\n\n"}
