{"name":"Erased.out_proof","module":"Mathlib.Data.Erased","initialProofState":"p : Prop\na : Erased p\n⊢ p","decl":"/-- Extracts the erased value, if it is a proof. -/\ntheorem out_proof {p : Prop} (a : Erased p) : p :=\n  out a\n\n"}
{"name":"Erased.out_mk","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\na : α\n⊢ Eq (Erased.mk a).out a","decl":"@[simp]\ntheorem out_mk {α} (a : α) : (mk a).out = a := by\n  let h := (mk a).2; show Classical.choose h = a\n  have := Classical.choose_spec h\n  exact cast (congr_fun this a).symm rfl\n\n"}
{"name":"Erased.mk_out","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\na : Erased α\n⊢ Eq (Erased.mk a.out) a","decl":"@[simp]\ntheorem mk_out {α} : ∀ a : Erased α, mk (out a) = a\n  | ⟨s, h⟩ => by simp only [mk]; congr; exact Classical.choose_spec h\n\n"}
{"name":"Erased.out_inj_iff","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\na b : Erased α\n⊢ Iff (Eq a b) (Eq a.out b.out)","decl":"@[ext]\ntheorem out_inj {α} (a b : Erased α) (h : a.out = b.out) : a = b := by simpa using congr_arg mk h\n\n"}
{"name":"Erased.out_inj","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\na b : Erased α\nh : Eq a.out b.out\n⊢ Eq a b","decl":"@[ext]\ntheorem out_inj {α} (a b : Erased α) (h : a.out = b.out) : a = b := by simpa using congr_arg mk h\n\n"}
{"name":"Erased.nonempty_iff","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\n⊢ Iff (Nonempty (Erased α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_iff {α} : Nonempty (Erased α) ↔ Nonempty α :=\n  ⟨fun ⟨a⟩ => ⟨a.out⟩, fun ⟨a⟩ => ⟨mk a⟩⟩\n\n"}
{"name":"Erased.bind_eq_out","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\nβ : Sort u_2\na : Erased α\nf : α → Erased β\n⊢ Eq (a.bind f) (f a.out)","decl":"@[simp]\ntheorem bind_eq_out {α β} (a f) : @bind α β a f = f a.out := rfl\n\n"}
{"name":"Erased.join_eq_out","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\na : Erased (Erased α)\n⊢ Eq a.join a.out","decl":"@[simp]\ntheorem join_eq_out {α} (a) : @join α a = a.out :=\n  bind_eq_out _ _\n\n"}
{"name":"Erased.map_out","module":"Mathlib.Data.Erased","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\na : Erased α\n⊢ Eq (Erased.map f a).out (f a.out)","decl":"@[simp]\ntheorem map_out {α β} {f : α → β} (a : Erased α) : (a.map f).out = f a.out := by simp [map]\n\n"}
{"name":"Erased.pure_def","module":"Mathlib.Data.Erased","initialProofState":"α : Type u_1\n⊢ Eq Pure.pure Erased.mk","decl":"@[simp]\ntheorem pure_def {α} : (pure : α → Erased α) = @mk _ :=\n  rfl\n\n"}
{"name":"Erased.bind_def","module":"Mathlib.Data.Erased","initialProofState":"α β : Type u_1\n⊢ Eq (fun x1 x2 => Bind.bind x1 x2) Erased.bind","decl":"@[simp]\ntheorem bind_def {α β} : ((· >>= ·) : Erased α → (α → Erased β) → Erased β) = @bind _ _ :=\n  rfl\n\n"}
{"name":"Erased.map_def","module":"Mathlib.Data.Erased","initialProofState":"α β : Type u_1\n⊢ Eq (fun x1 x2 => Functor.map x1 x2) Erased.map","decl":"@[simp]\ntheorem map_def {α β} : ((· <$> ·) : (α → β) → Erased α → Erased β) = @map _ _ :=\n  rfl\n\n-- Porting note: Old proof `by refine' { .. } <;> intros <;> ext <;> simp`\n"}
{"name":"Erased.instLawfulMonad","module":"Mathlib.Data.Erased","initialProofState":"⊢ LawfulMonad Erased","decl":"protected instance instLawfulMonad : LawfulMonad Erased :=\n  { id_map := by intros; ext; simp\n    map_const := by intros; ext; simp [Functor.mapConst]\n    pure_bind := by intros; ext; simp\n    bind_assoc := by intros; ext; simp\n    bind_pure_comp := by intros; ext; simp\n    bind_map := by intros; ext; simp [Seq.seq]\n    seqLeft_eq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqLeft.seqLeft]\n    seqRight_eq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqRight.seqRight]\n    pure_seq := by intros; ext; simp [Seq.seq, Functor.mapConst, SeqRight.seqRight] }\n\n"}
