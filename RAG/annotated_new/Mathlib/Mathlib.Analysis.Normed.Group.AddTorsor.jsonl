{"name":"NormedAddTorsor.dist_eq_norm'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : outParam (Type u_1)\nP : Type u_2\ninst✝¹ : SeminormedAddCommGroup V\ninst✝ : PseudoMetricSpace P\nself : NormedAddTorsor V P\nx y : P\n⊢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub x y))","decl":"/-- A `NormedAddTorsor V P` is a torsor of an additive seminormed group\naction by a `SeminormedAddCommGroup V` on points `P`. We bundle the pseudometric space\nstructure and require the distance to be the same as results from the\nnorm (which in fact implies the distance yields a pseudometric space, but\nbundling just the distance and using an instance for the pseudometric space\nresults in type class problems). -/\nclass NormedAddTorsor (V : outParam Type*) (P : Type*) [SeminormedAddCommGroup V]\n  [PseudoMetricSpace P] extends AddTorsor V P where\n  dist_eq_norm' : ∀ x y : P, dist x y = ‖(x -ᵥ y : V)‖\n\n"}
{"name":"NormedAddTorsor.to_isometricVAdd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ IsometricVAdd V P","decl":"instance (priority := 100) NormedAddTorsor.to_isometricVAdd : IsometricVAdd V P :=\n  ⟨fun c => Isometry.of_dist_eq fun x y => by\n    simp [NormedAddTorsor.dist_eq_norm']⟩\n\n"}
{"name":"dist_eq_norm_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y : P\n⊢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub x y))","decl":"/-- The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub` sometimes doesn't work. -/\ntheorem dist_eq_norm_vsub (x y : P) : dist x y = ‖x -ᵥ y‖ :=\n  NormedAddTorsor.dist_eq_norm' x y\n\n"}
{"name":"nndist_eq_nnnorm_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y : P\n⊢ Eq (NNDist.nndist x y) (NNNorm.nnnorm (VSub.vsub x y))","decl":"theorem nndist_eq_nnnorm_vsub (x y : P) : nndist x y = ‖x -ᵥ y‖₊ :=\n  NNReal.eq <| dist_eq_norm_vsub V x y\n\n\n"}
{"name":"dist_eq_norm_vsub'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y : P\n⊢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub y x))","decl":"/-- The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub'` sometimes doesn't work. -/\ntheorem dist_eq_norm_vsub' (x y : P) : dist x y = ‖y -ᵥ x‖ :=\n  (dist_comm _ _).trans (dist_eq_norm_vsub _ _ _)\n\n"}
{"name":"nndist_eq_nnnorm_vsub'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y : P\n⊢ Eq (NNDist.nndist x y) (NNNorm.nnnorm (VSub.vsub y x))","decl":"theorem nndist_eq_nnnorm_vsub' (x y : P) : nndist x y = ‖y -ᵥ x‖₊ :=\n  NNReal.eq <| dist_eq_norm_vsub' V x y\n\n"}
{"name":"dist_vadd_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx y : P\n⊢ Eq (Dist.dist (HVAdd.hVAdd v x) (HVAdd.hVAdd v y)) (Dist.dist x y)","decl":"theorem dist_vadd_cancel_left (v : V) (x y : P) : dist (v +ᵥ x) (v +ᵥ y) = dist x y :=\n  dist_vadd _ _ _\n\n"}
{"name":"nndist_vadd_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx y : P\n⊢ Eq (NNDist.nndist (HVAdd.hVAdd v x) (HVAdd.hVAdd v y)) (NNDist.nndist x y)","decl":"theorem nndist_vadd_cancel_left (v : V) (x y : P) : nndist (v +ᵥ x) (v +ᵥ y) = nndist x y :=\n  NNReal.eq <| dist_vadd_cancel_left _ _ _\n\n"}
{"name":"dist_vadd_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv₁ v₂ : V\nx : P\n⊢ Eq (Dist.dist (HVAdd.hVAdd v₁ x) (HVAdd.hVAdd v₂ x)) (Dist.dist v₁ v₂)","decl":"@[simp]\ntheorem dist_vadd_cancel_right (v₁ v₂ : V) (x : P) : dist (v₁ +ᵥ x) (v₂ +ᵥ x) = dist v₁ v₂ := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm, vadd_vsub_vadd_cancel_right]\n\n"}
{"name":"nndist_vadd_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv₁ v₂ : V\nx : P\n⊢ Eq (NNDist.nndist (HVAdd.hVAdd v₁ x) (HVAdd.hVAdd v₂ x)) (NNDist.nndist v₁ v₂)","decl":"@[simp]\ntheorem nndist_vadd_cancel_right (v₁ v₂ : V) (x : P) : nndist (v₁ +ᵥ x) (v₂ +ᵥ x) = nndist v₁ v₂ :=\n  NNReal.eq <| dist_vadd_cancel_right _ _ _\n\n"}
{"name":"dist_vadd_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx : P\n⊢ Eq (Dist.dist (HVAdd.hVAdd v x) x) (Norm.norm v)","decl":"@[simp]\ntheorem dist_vadd_left (v : V) (x : P) : dist (v +ᵥ x) x = ‖v‖ := by\n  simp [dist_eq_norm_vsub V _ x]\n\n"}
{"name":"nndist_vadd_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx : P\n⊢ Eq (NNDist.nndist (HVAdd.hVAdd v x) x) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nndist_vadd_left (v : V) (x : P) : nndist (v +ᵥ x) x = ‖v‖₊ :=\n  NNReal.eq <| dist_vadd_left _ _\n\n"}
{"name":"dist_vadd_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx : P\n⊢ Eq (Dist.dist x (HVAdd.hVAdd v x)) (Norm.norm v)","decl":"@[simp]\ntheorem dist_vadd_right (v : V) (x : P) : dist x (v +ᵥ x) = ‖v‖ := by rw [dist_comm, dist_vadd_left]\n\n"}
{"name":"nndist_vadd_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\nx : P\n⊢ Eq (NNDist.nndist x (HVAdd.hVAdd v x)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nndist_vadd_right (v : V) (x : P) : nndist x (v +ᵥ x) = ‖v‖₊ :=\n  NNReal.eq <| dist_vadd_right _ _\n\n"}
{"name":"IsometryEquiv.vaddConst_symm_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx p' : P\n⊢ Eq ((IsometryEquiv.vaddConst x).symm p') (VSub.vsub p' x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\naddition/subtraction of `x : P`. -/\n@[simps!]\ndef IsometryEquiv.vaddConst (x : P) : V ≃ᵢ P where\n  toEquiv := Equiv.vaddConst x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vadd_cancel_right _ _ _\n\n"}
{"name":"IsometryEquiv.vaddConst_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx : P\nv : V\n⊢ Eq ((IsometryEquiv.vaddConst x) v) (HVAdd.hVAdd v x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\naddition/subtraction of `x : P`. -/\n@[simps!]\ndef IsometryEquiv.vaddConst (x : P) : V ≃ᵢ P where\n  toEquiv := Equiv.vaddConst x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vadd_cancel_right _ _ _\n\n"}
{"name":"dist_vsub_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y z : P\n⊢ Eq (Dist.dist (VSub.vsub x y) (VSub.vsub x z)) (Dist.dist y z)","decl":"@[simp]\ntheorem dist_vsub_cancel_left (x y z : P) : dist (x -ᵥ y) (x -ᵥ z) = dist y z := by\n  rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]\n\n"}
{"name":"nndist_vsub_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y z : P\n⊢ Eq (NNDist.nndist (VSub.vsub x y) (VSub.vsub x z)) (NNDist.nndist y z)","decl":"@[simp]\ntheorem nndist_vsub_cancel_left (x y z : P) : nndist (x -ᵥ y) (x -ᵥ z) = nndist y z :=\n  NNReal.eq <| dist_vsub_cancel_left _ _ _\n\n"}
{"name":"IsometryEquiv.constVSub_symm_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx : P\nx✝ : V\n⊢ Eq ((IsometryEquiv.constVSub x).symm x✝) (HVAdd.hVAdd (Neg.neg x✝) x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. -/\n@[simps!]\ndef IsometryEquiv.constVSub (x : P) : P ≃ᵢ V where\n  toEquiv := Equiv.constVSub x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vsub_cancel_left _ _ _\n\n"}
{"name":"IsometryEquiv.constVSub_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx x✝ : P\n⊢ Eq ((IsometryEquiv.constVSub x) x✝) (VSub.vsub x x✝)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. -/\n@[simps!]\ndef IsometryEquiv.constVSub (x : P) : P ≃ᵢ V where\n  toEquiv := Equiv.constVSub x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vsub_cancel_left _ _ _\n\n"}
{"name":"dist_vsub_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y z : P\n⊢ Eq (Dist.dist (VSub.vsub x z) (VSub.vsub y z)) (Dist.dist x y)","decl":"@[simp]\ntheorem dist_vsub_cancel_right (x y z : P) : dist (x -ᵥ z) (y -ᵥ z) = dist x y :=\n  (IsometryEquiv.vaddConst z).symm.dist_eq x y\n\n"}
{"name":"nndist_vsub_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nx y z : P\n⊢ Eq (NNDist.nndist (VSub.vsub x z) (VSub.vsub y z)) (NNDist.nndist x y)","decl":"@[simp]\ntheorem nndist_vsub_cancel_right (x y z : P) : nndist (x -ᵥ z) (y -ᵥ z) = nndist x y :=\n  NNReal.eq <| dist_vsub_cancel_right _ _ _\n\n"}
{"name":"dist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv v' : V\np p' : P\n⊢ LE.le (Dist.dist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (Dist.dist v v') (Dist.dist p p'))","decl":"theorem dist_vadd_vadd_le (v v' : V) (p p' : P) :\n    dist (v +ᵥ p) (v' +ᵥ p') ≤ dist v v' + dist p p' := by\n  simpa using dist_triangle (v +ᵥ p) (v' +ᵥ p) (v' +ᵥ p')\n\n"}
{"name":"nndist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv v' : V\np p' : P\n⊢ LE.le (NNDist.nndist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (NNDist.nndist v v') (NNDist.nndist p p'))","decl":"theorem nndist_vadd_vadd_le (v v' : V) (p p' : P) :\n    nndist (v +ᵥ p) (v' +ᵥ p') ≤ nndist v v' + nndist p p' :=\n  dist_vadd_vadd_le _ _ _ _\n\n"}
{"name":"dist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ p₄ : P\n⊢ LE.le (Dist.dist (VSub.vsub p₁ p₂) (VSub.vsub p₃ p₄)) (HAdd.hAdd (Dist.dist p₁ p₃) (Dist.dist p₂ p₄))","decl":"theorem dist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :\n    dist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ dist p₁ p₃ + dist p₂ p₄ := by\n  rw [dist_eq_norm, vsub_sub_vsub_comm, dist_eq_norm_vsub V, dist_eq_norm_vsub V]\n  exact norm_sub_le _ _\n\n"}
{"name":"nndist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ p₄ : P\n⊢ LE.le (NNDist.nndist (VSub.vsub p₁ p₂) (VSub.vsub p₃ p₄)) (HAdd.hAdd (NNDist.nndist p₁ p₃) (NNDist.nndist p₂ p₄))","decl":"theorem nndist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :\n    nndist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ nndist p₁ p₃ + nndist p₂ p₄ := by\n  simp only [← NNReal.coe_le_coe, NNReal.coe_add, ← dist_nndist, dist_vsub_vsub_le]\n\n"}
{"name":"edist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nv v' : V\np p' : P\n⊢ LE.le (EDist.edist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (EDist.edist v v') (EDist.edist p p'))","decl":"theorem edist_vadd_vadd_le (v v' : V) (p p' : P) :\n    edist (v +ᵥ p) (v' +ᵥ p') ≤ edist v v' + edist p p' := by\n  simp only [edist_nndist]\n  norm_cast  -- Porting note: was apply_mod_cast\n  apply dist_vadd_vadd_le\n\n"}
{"name":"edist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ p₄ : P\n⊢ LE.le (EDist.edist (VSub.vsub p₁ p₂) (VSub.vsub p₃ p₄)) (HAdd.hAdd (EDist.edist p₁ p₃) (EDist.edist p₂ p₄))","decl":"theorem edist_vsub_vsub_le (p₁ p₂ p₃ p₄ : P) :\n    edist (p₁ -ᵥ p₂) (p₃ -ᵥ p₄) ≤ edist p₁ p₃ + edist p₂ p₄ := by\n  simp only [edist_nndist]\n  norm_cast  -- Porting note: was apply_mod_cast\n  apply dist_vsub_vsub_le\n\n"}
{"name":"LipschitzWith.vadd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : PseudoEMetricSpace α\nf : α → V\ng : α → P\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n⊢ LipschitzWith (HAdd.hAdd Kf Kg) (HVAdd.hVAdd f g)","decl":"theorem LipschitzWith.vadd [PseudoEMetricSpace α] {f : α → V} {g : α → P} {Kf Kg : ℝ≥0}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f +ᵥ g) :=\n  fun x y =>\n  calc\n    edist (f x +ᵥ g x) (f y +ᵥ g y) ≤ edist (f x) (f y) + edist (g x) (g y) :=\n      edist_vadd_vadd_le _ _ _ _\n    _ ≤ Kf * edist x y + Kg * edist x y := add_le_add (hf x y) (hg x y)\n    _ = (Kf + Kg) * edist x y := (add_mul _ _ _).symm\n\n"}
{"name":"LipschitzWith.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : PseudoEMetricSpace α\nf g : α → P\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n⊢ LipschitzWith (HAdd.hAdd Kf Kg) (VSub.vsub f g)","decl":"theorem LipschitzWith.vsub [PseudoEMetricSpace α] {f g : α → P} {Kf Kg : ℝ≥0}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f -ᵥ g) :=\n  fun x y =>\n  calc\n    edist (f x -ᵥ g x) (f y -ᵥ g y) ≤ edist (f x) (f y) + edist (g x) (g y) :=\n      edist_vsub_vsub_le _ _ _ _\n    _ ≤ Kf * edist x y + Kg * edist x y := add_le_add (hf x y) (hg x y)\n    _ = (Kf + Kg) * edist x y := (add_mul _ _ _).symm\n\n"}
{"name":"uniformContinuous_vadd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ UniformContinuous fun x => HVAdd.hVAdd x.1 x.2","decl":"theorem uniformContinuous_vadd : UniformContinuous fun x : V × P => x.1 +ᵥ x.2 :=\n  (LipschitzWith.prod_fst.vadd LipschitzWith.prod_snd).uniformContinuous\n\n"}
{"name":"uniformContinuous_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ UniformContinuous fun x => VSub.vsub x.1 x.2","decl":"theorem uniformContinuous_vsub : UniformContinuous fun x : P × P => x.1 -ᵥ x.2 :=\n  (LipschitzWith.prod_fst.vsub LipschitzWith.prod_snd).uniformContinuous\n\n"}
{"name":"NormedAddTorsor.to_continuousVAdd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ ContinuousVAdd V P","decl":"instance (priority := 100) NormedAddTorsor.to_continuousVAdd : ContinuousVAdd V P where\n  continuous_vadd := uniformContinuous_vadd.continuous\n\n"}
{"name":"continuous_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ Continuous fun x => VSub.vsub x.1 x.2","decl":"theorem continuous_vsub : Continuous fun x : P × P => x.1 -ᵥ x.2 :=\n  uniformContinuous_vsub.continuous\n\n"}
{"name":"Filter.Tendsto.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\nl : Filter α\nf g : α → P\nx y : P\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\n⊢ Filter.Tendsto (VSub.vsub f g) l (nhds (VSub.vsub x y))","decl":"theorem Filter.Tendsto.vsub {l : Filter α} {f g : α → P} {x y : P} (hf : Tendsto f l (𝓝 x))\n    (hg : Tendsto g l (𝓝 y)) : Tendsto (f -ᵥ g) l (𝓝 (x -ᵥ y)) :=\n  (continuous_vsub.tendsto (x, y)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Continuous.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : TopologicalSpace α\nf g : α → P\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous (VSub.vsub f g)","decl":"theorem Continuous.vsub {f g : α → P} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (f -ᵥ g) :=\n  continuous_vsub.comp (hf.prod_mk hg :)\n\n"}
{"name":"ContinuousAt.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : TopologicalSpace α\nf g : α → P\nx : α\nhf : ContinuousAt f x\nhg : ContinuousAt g x\n⊢ ContinuousAt (VSub.vsub f g) x","decl":"nonrec theorem ContinuousAt.vsub {f g : α → P} {x : α} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) :\n    ContinuousAt (f -ᵥ g) x :=\n  hf.vsub hg\n\n"}
{"name":"ContinuousWithinAt.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : TopologicalSpace α\nf g : α → P\nx : α\ns : Set α\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\n⊢ ContinuousWithinAt (VSub.vsub f g) s x","decl":"nonrec theorem ContinuousWithinAt.vsub {f g : α → P} {x : α} {s : Set α}\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (f -ᵥ g) s x :=\n  hf.vsub hg\n\n"}
{"name":"ContinuousOn.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : SeminormedAddCommGroup V\ninst✝² : PseudoMetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : TopologicalSpace α\nf g : α → P\ns : Set α\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (VSub.vsub f g) s","decl":"theorem ContinuousOn.vsub {f g : α → P} {s : Set α} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) : ContinuousOn (f -ᵥ g) s := fun x hx ↦\n  (hf x hx).vsub (hg x hx)\n\n"}
{"name":"Filter.Tendsto.lineMap","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : SeminormedAddCommGroup V\ninst✝⁵ : PseudoMetricSpace P\ninst✝⁴ : NormedAddTorsor V P\nR : Type u_6\ninst✝³ : Ring R\ninst✝² : TopologicalSpace R\ninst✝¹ : Module R V\ninst✝ : ContinuousSMul R V\nl : Filter α\nf₁ f₂ : α → P\ng : α → R\np₁ p₂ : P\nc : R\nh₁ : Filter.Tendsto f₁ l (nhds p₁)\nh₂ : Filter.Tendsto f₂ l (nhds p₂)\nhg : Filter.Tendsto g l (nhds c)\n⊢ Filter.Tendsto (fun x => (AffineMap.lineMap (f₁ x) (f₂ x)) (g x)) l (nhds ((AffineMap.lineMap p₁ p₂) c))","decl":"theorem Filter.Tendsto.lineMap {l : Filter α} {f₁ f₂ : α → P} {g : α → R} {p₁ p₂ : P} {c : R}\n    (h₁ : Tendsto f₁ l (𝓝 p₁)) (h₂ : Tendsto f₂ l (𝓝 p₂)) (hg : Tendsto g l (𝓝 c)) :\n    Tendsto (fun x => AffineMap.lineMap (f₁ x) (f₂ x) (g x)) l (𝓝 <| AffineMap.lineMap p₁ p₂ c) :=\n  (hg.smul (h₂.vsub h₁)).vadd h₁\n\n"}
{"name":"Filter.Tendsto.midpoint","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"α : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁷ : SeminormedAddCommGroup V\ninst✝⁶ : PseudoMetricSpace P\ninst✝⁵ : NormedAddTorsor V P\nR : Type u_6\ninst✝⁴ : Ring R\ninst✝³ : TopologicalSpace R\ninst✝² : Module R V\ninst✝¹ : ContinuousSMul R V\ninst✝ : Invertible 2\nl : Filter α\nf₁ f₂ : α → P\np₁ p₂ : P\nh₁ : Filter.Tendsto f₁ l (nhds p₁)\nh₂ : Filter.Tendsto f₂ l (nhds p₂)\n⊢ Filter.Tendsto (fun x => midpoint R (f₁ x) (f₂ x)) l (nhds (midpoint R p₁ p₂))","decl":"theorem Filter.Tendsto.midpoint [Invertible (2 : R)] {l : Filter α} {f₁ f₂ : α → P} {p₁ p₂ : P}\n    (h₁ : Tendsto f₁ l (𝓝 p₁)) (h₂ : Tendsto f₂ l (𝓝 p₂)) :\n    Tendsto (fun x => midpoint R (f₁ x) (f₂ x)) l (𝓝 <| midpoint R p₁ p₂) :=\n  h₁.lineMap h₂ tendsto_const_nhds\n\n"}
{"name":"IsClosed.vadd_right_of_isCompact","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninst✝² : SeminormedAddCommGroup V\ninst✝¹ : PseudoMetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set V\nt : Set P\nhs : IsClosed s\nht : IsCompact t\n⊢ IsClosed (HVAdd.hVAdd s t)","decl":"theorem IsClosed.vadd_right_of_isCompact {s : Set V} {t : Set P} (hs : IsClosed s)\n    (ht : IsCompact t) : IsClosed (s +ᵥ t) := by\n  -- This result is still true for any `AddTorsor` where `-ᵥ` is continuous,\n  -- but we don't yet have a nice way to state it.\n  refine IsSeqClosed.isClosed (fun u p husv hup ↦ ?_)\n  choose! a ha v hv hav using husv\n  rcases ht.isSeqCompact hv with ⟨q, hqt, φ, φ_mono, hφq⟩\n  refine ⟨p -ᵥ q, hs.mem_of_tendsto ((hup.comp φ_mono.tendsto_atTop).vsub hφq)\n    (Eventually.of_forall fun n ↦ ?_), q, hqt, vsub_vadd _ _⟩\n  convert ha (φ n) using 1\n  exact (eq_vadd_iff_vsub_eq _ _ _).mp (hav (φ n)).symm\n\n"}
