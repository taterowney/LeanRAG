{"name":"NormedAddTorsor.dist_eq_norm'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : outParam (Type u_1)\nP : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup V\ninstâœ : PseudoMetricSpace P\nself : NormedAddTorsor V P\nx y : P\nâŠ¢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub x y))","decl":"/-- A `NormedAddTorsor V P` is a torsor of an additive seminormed group\naction by a `SeminormedAddCommGroup V` on points `P`. We bundle the pseudometric space\nstructure and require the distance to be the same as results from the\nnorm (which in fact implies the distance yields a pseudometric space, but\nbundling just the distance and using an instance for the pseudometric space\nresults in type class problems). -/\nclass NormedAddTorsor (V : outParam Type*) (P : Type*) [SeminormedAddCommGroup V]\n  [PseudoMetricSpace P] extends AddTorsor V P where\n  dist_eq_norm' : âˆ€ x y : P, dist x y = â€–(x -áµ¥ y : V)â€–\n\n"}
{"name":"NormedAddTorsor.to_isometricVAdd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ IsometricVAdd V P","decl":"instance (priority := 100) NormedAddTorsor.to_isometricVAdd : IsometricVAdd V P :=\n  âŸ¨fun c => Isometry.of_dist_eq fun x y => by\n    simp [NormedAddTorsor.dist_eq_norm']âŸ©\n\n"}
{"name":"dist_eq_norm_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y : P\nâŠ¢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub x y))","decl":"/-- The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub` sometimes doesn't work. -/\ntheorem dist_eq_norm_vsub (x y : P) : dist x y = â€–x -áµ¥ yâ€– :=\n  NormedAddTorsor.dist_eq_norm' x y\n\n"}
{"name":"nndist_eq_nnnorm_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y : P\nâŠ¢ Eq (NNDist.nndist x y) (NNNorm.nnnorm (VSub.vsub x y))","decl":"theorem nndist_eq_nnnorm_vsub (x y : P) : nndist x y = â€–x -áµ¥ yâ€–â‚Š :=\n  NNReal.eq <| dist_eq_norm_vsub V x y\n\n\n"}
{"name":"dist_eq_norm_vsub'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y : P\nâŠ¢ Eq (Dist.dist x y) (Norm.norm (VSub.vsub y x))","decl":"/-- The distance equals the norm of subtracting two points. In this\nlemma, it is necessary to have `V` as an explicit argument; otherwise\n`rw dist_eq_norm_vsub'` sometimes doesn't work. -/\ntheorem dist_eq_norm_vsub' (x y : P) : dist x y = â€–y -áµ¥ xâ€– :=\n  (dist_comm _ _).trans (dist_eq_norm_vsub _ _ _)\n\n"}
{"name":"nndist_eq_nnnorm_vsub'","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y : P\nâŠ¢ Eq (NNDist.nndist x y) (NNNorm.nnnorm (VSub.vsub y x))","decl":"theorem nndist_eq_nnnorm_vsub' (x y : P) : nndist x y = â€–y -áµ¥ xâ€–â‚Š :=\n  NNReal.eq <| dist_eq_norm_vsub' V x y\n\n"}
{"name":"dist_vadd_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx y : P\nâŠ¢ Eq (Dist.dist (HVAdd.hVAdd v x) (HVAdd.hVAdd v y)) (Dist.dist x y)","decl":"theorem dist_vadd_cancel_left (v : V) (x y : P) : dist (v +áµ¥ x) (v +áµ¥ y) = dist x y :=\n  dist_vadd _ _ _\n\n"}
{"name":"nndist_vadd_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx y : P\nâŠ¢ Eq (NNDist.nndist (HVAdd.hVAdd v x) (HVAdd.hVAdd v y)) (NNDist.nndist x y)","decl":"theorem nndist_vadd_cancel_left (v : V) (x y : P) : nndist (v +áµ¥ x) (v +áµ¥ y) = nndist x y :=\n  NNReal.eq <| dist_vadd_cancel_left _ _ _\n\n"}
{"name":"dist_vadd_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nvâ‚ vâ‚‚ : V\nx : P\nâŠ¢ Eq (Dist.dist (HVAdd.hVAdd vâ‚ x) (HVAdd.hVAdd vâ‚‚ x)) (Dist.dist vâ‚ vâ‚‚)","decl":"@[simp]\ntheorem dist_vadd_cancel_right (vâ‚ vâ‚‚ : V) (x : P) : dist (vâ‚ +áµ¥ x) (vâ‚‚ +áµ¥ x) = dist vâ‚ vâ‚‚ := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm, vadd_vsub_vadd_cancel_right]\n\n"}
{"name":"nndist_vadd_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nvâ‚ vâ‚‚ : V\nx : P\nâŠ¢ Eq (NNDist.nndist (HVAdd.hVAdd vâ‚ x) (HVAdd.hVAdd vâ‚‚ x)) (NNDist.nndist vâ‚ vâ‚‚)","decl":"@[simp]\ntheorem nndist_vadd_cancel_right (vâ‚ vâ‚‚ : V) (x : P) : nndist (vâ‚ +áµ¥ x) (vâ‚‚ +áµ¥ x) = nndist vâ‚ vâ‚‚ :=\n  NNReal.eq <| dist_vadd_cancel_right _ _ _\n\n"}
{"name":"dist_vadd_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx : P\nâŠ¢ Eq (Dist.dist (HVAdd.hVAdd v x) x) (Norm.norm v)","decl":"@[simp]\ntheorem dist_vadd_left (v : V) (x : P) : dist (v +áµ¥ x) x = â€–vâ€– := by\n  simp [dist_eq_norm_vsub V _ x]\n\n"}
{"name":"nndist_vadd_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx : P\nâŠ¢ Eq (NNDist.nndist (HVAdd.hVAdd v x) x) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nndist_vadd_left (v : V) (x : P) : nndist (v +áµ¥ x) x = â€–vâ€–â‚Š :=\n  NNReal.eq <| dist_vadd_left _ _\n\n"}
{"name":"dist_vadd_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx : P\nâŠ¢ Eq (Dist.dist x (HVAdd.hVAdd v x)) (Norm.norm v)","decl":"@[simp]\ntheorem dist_vadd_right (v : V) (x : P) : dist x (v +áµ¥ x) = â€–vâ€– := by rw [dist_comm, dist_vadd_left]\n\n"}
{"name":"nndist_vadd_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv : V\nx : P\nâŠ¢ Eq (NNDist.nndist x (HVAdd.hVAdd v x)) (NNNorm.nnnorm v)","decl":"@[simp]\ntheorem nndist_vadd_right (v : V) (x : P) : nndist x (v +áµ¥ x) = â€–vâ€–â‚Š :=\n  NNReal.eq <| dist_vadd_right _ _\n\n"}
{"name":"IsometryEquiv.vaddConst_symm_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx p' : P\nâŠ¢ Eq ((IsometryEquiv.vaddConst x).symm p') (VSub.vsub p' x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\naddition/subtraction of `x : P`. -/\n@[simps!]\ndef IsometryEquiv.vaddConst (x : P) : V â‰ƒáµ¢ P where\n  toEquiv := Equiv.vaddConst x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vadd_cancel_right _ _ _\n\n"}
{"name":"IsometryEquiv.vaddConst_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx : P\nv : V\nâŠ¢ Eq ((IsometryEquiv.vaddConst x) v) (HVAdd.hVAdd v x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\naddition/subtraction of `x : P`. -/\n@[simps!]\ndef IsometryEquiv.vaddConst (x : P) : V â‰ƒáµ¢ P where\n  toEquiv := Equiv.vaddConst x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vadd_cancel_right _ _ _\n\n"}
{"name":"dist_vsub_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y z : P\nâŠ¢ Eq (Dist.dist (VSub.vsub x y) (VSub.vsub x z)) (Dist.dist y z)","decl":"@[simp]\ntheorem dist_vsub_cancel_left (x y z : P) : dist (x -áµ¥ y) (x -áµ¥ z) = dist y z := by\n  rw [dist_eq_norm, vsub_sub_vsub_cancel_left, dist_comm, dist_eq_norm_vsub V]\n\n"}
{"name":"nndist_vsub_cancel_left","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y z : P\nâŠ¢ Eq (NNDist.nndist (VSub.vsub x y) (VSub.vsub x z)) (NNDist.nndist y z)","decl":"@[simp]\ntheorem nndist_vsub_cancel_left (x y z : P) : nndist (x -áµ¥ y) (x -áµ¥ z) = nndist y z :=\n  NNReal.eq <| dist_vsub_cancel_left _ _ _\n\n"}
{"name":"IsometryEquiv.constVSub_symm_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx : P\nxâœ : V\nâŠ¢ Eq ((IsometryEquiv.constVSub x).symm xâœ) (HVAdd.hVAdd (Neg.neg xâœ) x)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. -/\n@[simps!]\ndef IsometryEquiv.constVSub (x : P) : P â‰ƒáµ¢ V where\n  toEquiv := Equiv.constVSub x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vsub_cancel_left _ _ _\n\n"}
{"name":"IsometryEquiv.constVSub_apply","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx xâœ : P\nâŠ¢ Eq ((IsometryEquiv.constVSub x) xâœ) (VSub.vsub x xâœ)","decl":"/-- Isometry between the tangent space `V` of a (semi)normed add torsor `P` and `P` given by\nsubtraction from `x : P`. -/\n@[simps!]\ndef IsometryEquiv.constVSub (x : P) : P â‰ƒáµ¢ V where\n  toEquiv := Equiv.constVSub x\n  isometry_toFun := Isometry.of_dist_eq fun _ _ => dist_vsub_cancel_left _ _ _\n\n"}
{"name":"dist_vsub_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y z : P\nâŠ¢ Eq (Dist.dist (VSub.vsub x z) (VSub.vsub y z)) (Dist.dist x y)","decl":"@[simp]\ntheorem dist_vsub_cancel_right (x y z : P) : dist (x -áµ¥ z) (y -áµ¥ z) = dist x y :=\n  (IsometryEquiv.vaddConst z).symm.dist_eq x y\n\n"}
{"name":"nndist_vsub_cancel_right","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nx y z : P\nâŠ¢ Eq (NNDist.nndist (VSub.vsub x z) (VSub.vsub y z)) (NNDist.nndist x y)","decl":"@[simp]\ntheorem nndist_vsub_cancel_right (x y z : P) : nndist (x -áµ¥ z) (y -áµ¥ z) = nndist x y :=\n  NNReal.eq <| dist_vsub_cancel_right _ _ _\n\n"}
{"name":"dist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv v' : V\np p' : P\nâŠ¢ LE.le (Dist.dist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (Dist.dist v v') (Dist.dist p p'))","decl":"theorem dist_vadd_vadd_le (v v' : V) (p p' : P) :\n    dist (v +áµ¥ p) (v' +áµ¥ p') â‰¤ dist v v' + dist p p' := by\n  simpa using dist_triangle (v +áµ¥ p) (v' +áµ¥ p) (v' +áµ¥ p')\n\n"}
{"name":"nndist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv v' : V\np p' : P\nâŠ¢ LE.le (NNDist.nndist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (NNDist.nndist v v') (NNDist.nndist p p'))","decl":"theorem nndist_vadd_vadd_le (v v' : V) (p p' : P) :\n    nndist (v +áµ¥ p) (v' +áµ¥ p') â‰¤ nndist v v' + nndist p p' :=\n  dist_vadd_vadd_le _ _ _ _\n\n"}
{"name":"dist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P\nâŠ¢ LE.le (Dist.dist (VSub.vsub pâ‚ pâ‚‚) (VSub.vsub pâ‚ƒ pâ‚„)) (HAdd.hAdd (Dist.dist pâ‚ pâ‚ƒ) (Dist.dist pâ‚‚ pâ‚„))","decl":"theorem dist_vsub_vsub_le (pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P) :\n    dist (pâ‚ -áµ¥ pâ‚‚) (pâ‚ƒ -áµ¥ pâ‚„) â‰¤ dist pâ‚ pâ‚ƒ + dist pâ‚‚ pâ‚„ := by\n  rw [dist_eq_norm, vsub_sub_vsub_comm, dist_eq_norm_vsub V, dist_eq_norm_vsub V]\n  exact norm_sub_le _ _\n\n"}
{"name":"nndist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P\nâŠ¢ LE.le (NNDist.nndist (VSub.vsub pâ‚ pâ‚‚) (VSub.vsub pâ‚ƒ pâ‚„)) (HAdd.hAdd (NNDist.nndist pâ‚ pâ‚ƒ) (NNDist.nndist pâ‚‚ pâ‚„))","decl":"theorem nndist_vsub_vsub_le (pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P) :\n    nndist (pâ‚ -áµ¥ pâ‚‚) (pâ‚ƒ -áµ¥ pâ‚„) â‰¤ nndist pâ‚ pâ‚ƒ + nndist pâ‚‚ pâ‚„ := by\n  simp only [â† NNReal.coe_le_coe, NNReal.coe_add, â† dist_nndist, dist_vsub_vsub_le]\n\n"}
{"name":"edist_vadd_vadd_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nv v' : V\np p' : P\nâŠ¢ LE.le (EDist.edist (HVAdd.hVAdd v p) (HVAdd.hVAdd v' p')) (HAdd.hAdd (EDist.edist v v') (EDist.edist p p'))","decl":"theorem edist_vadd_vadd_le (v v' : V) (p p' : P) :\n    edist (v +áµ¥ p) (v' +áµ¥ p') â‰¤ edist v v' + edist p p' := by\n  simp only [edist_nndist]\n  norm_cast  -- Porting note: was apply_mod_cast\n  apply dist_vadd_vadd_le\n\n"}
{"name":"edist_vsub_vsub_le","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\npâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P\nâŠ¢ LE.le (EDist.edist (VSub.vsub pâ‚ pâ‚‚) (VSub.vsub pâ‚ƒ pâ‚„)) (HAdd.hAdd (EDist.edist pâ‚ pâ‚ƒ) (EDist.edist pâ‚‚ pâ‚„))","decl":"theorem edist_vsub_vsub_le (pâ‚ pâ‚‚ pâ‚ƒ pâ‚„ : P) :\n    edist (pâ‚ -áµ¥ pâ‚‚) (pâ‚ƒ -áµ¥ pâ‚„) â‰¤ edist pâ‚ pâ‚ƒ + edist pâ‚‚ pâ‚„ := by\n  simp only [edist_nndist]\n  norm_cast  -- Porting note: was apply_mod_cast\n  apply dist_vsub_vsub_le\n\n"}
{"name":"LipschitzWith.vadd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : PseudoEMetricSpace Î±\nf : Î± â†’ V\ng : Î± â†’ P\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\nâŠ¢ LipschitzWith (HAdd.hAdd Kf Kg) (HVAdd.hVAdd f g)","decl":"theorem LipschitzWith.vadd [PseudoEMetricSpace Î±] {f : Î± â†’ V} {g : Î± â†’ P} {Kf Kg : â„â‰¥0}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f +áµ¥ g) :=\n  fun x y =>\n  calc\n    edist (f x +áµ¥ g x) (f y +áµ¥ g y) â‰¤ edist (f x) (f y) + edist (g x) (g y) :=\n      edist_vadd_vadd_le _ _ _ _\n    _ â‰¤ Kf * edist x y + Kg * edist x y := add_le_add (hf x y) (hg x y)\n    _ = (Kf + Kg) * edist x y := (add_mul _ _ _).symm\n\n"}
{"name":"LipschitzWith.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : PseudoEMetricSpace Î±\nf g : Î± â†’ P\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\nâŠ¢ LipschitzWith (HAdd.hAdd Kf Kg) (VSub.vsub f g)","decl":"theorem LipschitzWith.vsub [PseudoEMetricSpace Î±] {f g : Î± â†’ P} {Kf Kg : â„â‰¥0}\n    (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) : LipschitzWith (Kf + Kg) (f -áµ¥ g) :=\n  fun x y =>\n  calc\n    edist (f x -áµ¥ g x) (f y -áµ¥ g y) â‰¤ edist (f x) (f y) + edist (g x) (g y) :=\n      edist_vsub_vsub_le _ _ _ _\n    _ â‰¤ Kf * edist x y + Kg * edist x y := add_le_add (hf x y) (hg x y)\n    _ = (Kf + Kg) * edist x y := (add_mul _ _ _).symm\n\n"}
{"name":"uniformContinuous_vadd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ UniformContinuous fun x => HVAdd.hVAdd x.1 x.2","decl":"theorem uniformContinuous_vadd : UniformContinuous fun x : V Ã— P => x.1 +áµ¥ x.2 :=\n  (LipschitzWith.prod_fst.vadd LipschitzWith.prod_snd).uniformContinuous\n\n"}
{"name":"uniformContinuous_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ UniformContinuous fun x => VSub.vsub x.1 x.2","decl":"theorem uniformContinuous_vsub : UniformContinuous fun x : P Ã— P => x.1 -áµ¥ x.2 :=\n  (LipschitzWith.prod_fst.vsub LipschitzWith.prod_snd).uniformContinuous\n\n"}
{"name":"NormedAddTorsor.to_continuousVAdd","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ ContinuousVAdd V P","decl":"instance (priority := 100) NormedAddTorsor.to_continuousVAdd : ContinuousVAdd V P where\n  continuous_vadd := uniformContinuous_vadd.continuous\n\n"}
{"name":"continuous_vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nâŠ¢ Continuous fun x => VSub.vsub x.1 x.2","decl":"theorem continuous_vsub : Continuous fun x : P Ã— P => x.1 -áµ¥ x.2 :=\n  uniformContinuous_vsub.continuous\n\n"}
{"name":"Filter.Tendsto.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\nl : Filter Î±\nf g : Î± â†’ P\nx y : P\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nâŠ¢ Filter.Tendsto (VSub.vsub f g) l (nhds (VSub.vsub x y))","decl":"theorem Filter.Tendsto.vsub {l : Filter Î±} {f g : Î± â†’ P} {x y : P} (hf : Tendsto f l (ğ“ x))\n    (hg : Tendsto g l (ğ“ y)) : Tendsto (f -áµ¥ g) l (ğ“ (x -áµ¥ y)) :=\n  (continuous_vsub.tendsto (x, y)).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Continuous.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ P\nhf : Continuous f\nhg : Continuous g\nâŠ¢ Continuous (VSub.vsub f g)","decl":"theorem Continuous.vsub {f g : Î± â†’ P} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (f -áµ¥ g) :=\n  continuous_vsub.comp (hf.prod_mk hg :)\n\n"}
{"name":"ContinuousAt.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ P\nx : Î±\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nâŠ¢ ContinuousAt (VSub.vsub f g) x","decl":"nonrec theorem ContinuousAt.vsub {f g : Î± â†’ P} {x : Î±} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) :\n    ContinuousAt (f -áµ¥ g) x :=\n  hf.vsub hg\n\n"}
{"name":"ContinuousWithinAt.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ P\nx : Î±\ns : Set Î±\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nâŠ¢ ContinuousWithinAt (VSub.vsub f g) s x","decl":"nonrec theorem ContinuousWithinAt.vsub {f g : Î± â†’ P} {x : Î±} {s : Set Î±}\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (f -áµ¥ g) s x :=\n  hf.vsub hg\n\n"}
{"name":"ContinuousOn.vsub","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœÂ³ : SeminormedAddCommGroup V\ninstâœÂ² : PseudoMetricSpace P\ninstâœÂ¹ : NormedAddTorsor V P\ninstâœ : TopologicalSpace Î±\nf g : Î± â†’ P\ns : Set Î±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nâŠ¢ ContinuousOn (VSub.vsub f g) s","decl":"theorem ContinuousOn.vsub {f g : Î± â†’ P} {s : Set Î±} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) : ContinuousOn (f -áµ¥ g) s := fun x hx â†¦\n  (hf x hx).vsub (hg x hx)\n\n"}
{"name":"Filter.Tendsto.lineMap","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœâ¶ : SeminormedAddCommGroup V\ninstâœâµ : PseudoMetricSpace P\ninstâœâ´ : NormedAddTorsor V P\nR : Type u_6\ninstâœÂ³ : Ring R\ninstâœÂ² : TopologicalSpace R\ninstâœÂ¹ : Module R V\ninstâœ : ContinuousSMul R V\nl : Filter Î±\nfâ‚ fâ‚‚ : Î± â†’ P\ng : Î± â†’ R\npâ‚ pâ‚‚ : P\nc : R\nhâ‚ : Filter.Tendsto fâ‚ l (nhds pâ‚)\nhâ‚‚ : Filter.Tendsto fâ‚‚ l (nhds pâ‚‚)\nhg : Filter.Tendsto g l (nhds c)\nâŠ¢ Filter.Tendsto (fun x => (AffineMap.lineMap (fâ‚ x) (fâ‚‚ x)) (g x)) l (nhds ((AffineMap.lineMap pâ‚ pâ‚‚) c))","decl":"theorem Filter.Tendsto.lineMap {l : Filter Î±} {fâ‚ fâ‚‚ : Î± â†’ P} {g : Î± â†’ R} {pâ‚ pâ‚‚ : P} {c : R}\n    (hâ‚ : Tendsto fâ‚ l (ğ“ pâ‚)) (hâ‚‚ : Tendsto fâ‚‚ l (ğ“ pâ‚‚)) (hg : Tendsto g l (ğ“ c)) :\n    Tendsto (fun x => AffineMap.lineMap (fâ‚ x) (fâ‚‚ x) (g x)) l (ğ“ <| AffineMap.lineMap pâ‚ pâ‚‚ c) :=\n  (hg.smul (hâ‚‚.vsub hâ‚)).vadd hâ‚\n\n"}
{"name":"Filter.Tendsto.midpoint","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"Î± : Type u_1\nV : Type u_2\nP : Type u_3\ninstâœâ· : SeminormedAddCommGroup V\ninstâœâ¶ : PseudoMetricSpace P\ninstâœâµ : NormedAddTorsor V P\nR : Type u_6\ninstâœâ´ : Ring R\ninstâœÂ³ : TopologicalSpace R\ninstâœÂ² : Module R V\ninstâœÂ¹ : ContinuousSMul R V\ninstâœ : Invertible 2\nl : Filter Î±\nfâ‚ fâ‚‚ : Î± â†’ P\npâ‚ pâ‚‚ : P\nhâ‚ : Filter.Tendsto fâ‚ l (nhds pâ‚)\nhâ‚‚ : Filter.Tendsto fâ‚‚ l (nhds pâ‚‚)\nâŠ¢ Filter.Tendsto (fun x => midpoint R (fâ‚ x) (fâ‚‚ x)) l (nhds (midpoint R pâ‚ pâ‚‚))","decl":"theorem Filter.Tendsto.midpoint [Invertible (2 : R)] {l : Filter Î±} {fâ‚ fâ‚‚ : Î± â†’ P} {pâ‚ pâ‚‚ : P}\n    (hâ‚ : Tendsto fâ‚ l (ğ“ pâ‚)) (hâ‚‚ : Tendsto fâ‚‚ l (ğ“ pâ‚‚)) :\n    Tendsto (fun x => midpoint R (fâ‚ x) (fâ‚‚ x)) l (ğ“ <| midpoint R pâ‚ pâ‚‚) :=\n  hâ‚.lineMap hâ‚‚ tendsto_const_nhds\n\n"}
{"name":"IsClosed.vadd_right_of_isCompact","module":"Mathlib.Analysis.Normed.Group.AddTorsor","initialProofState":"V : Type u_2\nP : Type u_3\ninstâœÂ² : SeminormedAddCommGroup V\ninstâœÂ¹ : PseudoMetricSpace P\ninstâœ : NormedAddTorsor V P\ns : Set V\nt : Set P\nhs : IsClosed s\nht : IsCompact t\nâŠ¢ IsClosed (HVAdd.hVAdd s t)","decl":"theorem IsClosed.vadd_right_of_isCompact {s : Set V} {t : Set P} (hs : IsClosed s)\n    (ht : IsCompact t) : IsClosed (s +áµ¥ t) := by\n  -- This result is still true for any `AddTorsor` where `-áµ¥` is continuous,\n  -- but we don't yet have a nice way to state it.\n  refine IsSeqClosed.isClosed (fun u p husv hup â†¦ ?_)\n  choose! a ha v hv hav using husv\n  rcases ht.isSeqCompact hv with âŸ¨q, hqt, Ï†, Ï†_mono, hÏ†qâŸ©\n  refine âŸ¨p -áµ¥ q, hs.mem_of_tendsto ((hup.comp Ï†_mono.tendsto_atTop).vsub hÏ†q)\n    (Eventually.of_forall fun n â†¦ ?_), q, hqt, vsub_vadd _ _âŸ©\n  convert ha (Ï† n) using 1\n  exact (eq_vadd_iff_vsub_eq _ _ _).mp (hav (Ï† n)).symm\n\n"}
