{"name":"Besicovitch.SatelliteConfig.mk.injEq","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nc✝ : Fin N.succ → α\nr✝ : Fin N.succ → Real\nrpos✝ : ∀ (i : Fin N.succ), LT.lt 0 (r✝ i)\nh✝ : Pairwise fun i j => Or (And (LE.le (r✝ i) (Dist.dist (c✝ i) (c✝ j))) (LE.le (r✝ j) (HMul.hMul τ (r✝ i)))) (And (LE.le (r✝ j) (Dist.dist (c✝ j) (c✝ i))) (LE.le (r✝ i) (HMul.hMul τ (r✝ j))))\nhlast✝ : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → And (LE.le (r✝ i) (Dist.dist (c✝ i) (c✝ (Fin.last N)))) (LE.le (r✝ (Fin.last N)) (HMul.hMul τ (r✝ i)))\ninter✝ : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → LE.le (Dist.dist (c✝ i) (c✝ (Fin.last N))) (HAdd.hAdd (r✝ i) (r✝ (Fin.last N)))\nc : Fin N.succ → α\nr : Fin N.succ → Real\nrpos : ∀ (i : Fin N.succ), LT.lt 0 (r i)\nh : Pairwise fun i j => Or (And (LE.le (r i) (Dist.dist (c i) (c j))) (LE.le (r j) (HMul.hMul τ (r i)))) (And (LE.le (r j) (Dist.dist (c j) (c i))) (LE.le (r i) (HMul.hMul τ (r j))))\nhlast : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → And (LE.le (r i) (Dist.dist (c i) (c (Fin.last N)))) (LE.le (r (Fin.last N)) (HMul.hMul τ (r i)))\ninter : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → LE.le (Dist.dist (c i) (c (Fin.last N))) (HAdd.hAdd (r i) (r (Fin.last N)))\n⊢ Eq (Eq { c := c✝, r := r✝, rpos := rpos✝, h := h✝, hlast := hlast✝, inter := inter✝ } { c := c, r := r, rpos := rpos, h := h, hlast := hlast, inter := inter }) (And (Eq c✝ c) (Eq r✝ r))","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.hlast","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nself : Besicovitch.SatelliteConfig α N τ\ni : Fin (HAdd.hAdd N 1)\na✝ : LT.lt i (Fin.last N)\n⊢ And (LE.le (self.r i) (Dist.dist (self.c i) (self.c (Fin.last N)))) (LE.le (self.r (Fin.last N)) (HMul.hMul τ (self.r i)))","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nN : Nat\nτ : Real\ninst✝ : SizeOf α\nc : Fin N.succ → α\nr : Fin N.succ → Real\nrpos : ∀ (i : Fin N.succ), LT.lt 0 (r i)\nh : Pairwise fun i j => Or (And (LE.le (r i) (Dist.dist (c i) (c j))) (LE.le (r j) (HMul.hMul τ (r i)))) (And (LE.le (r j) (Dist.dist (c j) (c i))) (LE.le (r i) (HMul.hMul τ (r j))))\nhlast : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → And (LE.le (r i) (Dist.dist (c i) (c (Fin.last N)))) (LE.le (r (Fin.last N)) (HMul.hMul τ (r i)))\ninter : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → LE.le (Dist.dist (c i) (c (Fin.last N))) (HAdd.hAdd (r i) (r (Fin.last N)))\n⊢ Eq (SizeOf.sizeOf { c := c, r := r, rpos := rpos, h := h, hlast := hlast, inter := inter }) 1","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.h","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nself : Besicovitch.SatelliteConfig α N τ\n⊢ Pairwise fun i j => Or (And (LE.le (self.r i) (Dist.dist (self.c i) (self.c j))) (LE.le (self.r j) (HMul.hMul τ (self.r i)))) (And (LE.le (self.r j) (Dist.dist (self.c j) (self.c i))) (LE.le (self.r i) (HMul.hMul τ (self.r j))))","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.mk.inj","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nc✝ : Fin N.succ → α\nr✝ : Fin N.succ → Real\nrpos✝ : ∀ (i : Fin N.succ), LT.lt 0 (r✝ i)\nh✝ : Pairwise fun i j => Or (And (LE.le (r✝ i) (Dist.dist (c✝ i) (c✝ j))) (LE.le (r✝ j) (HMul.hMul τ (r✝ i)))) (And (LE.le (r✝ j) (Dist.dist (c✝ j) (c✝ i))) (LE.le (r✝ i) (HMul.hMul τ (r✝ j))))\nhlast✝ : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → And (LE.le (r✝ i) (Dist.dist (c✝ i) (c✝ (Fin.last N)))) (LE.le (r✝ (Fin.last N)) (HMul.hMul τ (r✝ i)))\ninter✝ : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → LE.le (Dist.dist (c✝ i) (c✝ (Fin.last N))) (HAdd.hAdd (r✝ i) (r✝ (Fin.last N)))\nc : Fin N.succ → α\nr : Fin N.succ → Real\nrpos : ∀ (i : Fin N.succ), LT.lt 0 (r i)\nh : Pairwise fun i j => Or (And (LE.le (r i) (Dist.dist (c i) (c j))) (LE.le (r j) (HMul.hMul τ (r i)))) (And (LE.le (r j) (Dist.dist (c j) (c i))) (LE.le (r i) (HMul.hMul τ (r j))))\nhlast : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → And (LE.le (r i) (Dist.dist (c i) (c (Fin.last N)))) (LE.le (r (Fin.last N)) (HMul.hMul τ (r i)))\ninter : ∀ (i : Fin (HAdd.hAdd N 1)), LT.lt i (Fin.last N) → LE.le (Dist.dist (c i) (c (Fin.last N))) (HAdd.hAdd (r i) (r (Fin.last N)))\nx✝ : Eq { c := c✝, r := r✝, rpos := rpos✝, h := h✝, hlast := hlast✝, inter := inter✝ } { c := c, r := r, rpos := rpos, h := h, hlast := hlast, inter := inter }\n⊢ And (Eq c✝ c) (Eq r✝ r)","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.rpos","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nself : Besicovitch.SatelliteConfig α N τ\ni : Fin N.succ\n⊢ LT.lt 0 (self.r i)","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"Besicovitch.SatelliteConfig.inter","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\nself : Besicovitch.SatelliteConfig α N τ\ni : Fin (HAdd.hAdd N 1)\na✝ : LT.lt i (Fin.last N)\n⊢ LE.le (Dist.dist (self.c i) (self.c (Fin.last N))) (HAdd.hAdd (self.r i) (self.r (Fin.last N)))","decl":"/-- A satellite configuration is a configuration of `N+1` points that shows up in the inductive\nconstruction for the Besicovitch covering theorem. It depends on some parameter `τ ≥ 1`.\n\nThis is a family of balls (indexed by `i : Fin N.succ`, with center `c i` and radius `r i`) such\nthat the last ball intersects all the other balls (condition `inter`),\nand given any two balls there is an order between them, ensuring that the first ball does not\ncontain the center of the other one, and the radius of the second ball can not be larger than\nthe radius of the first ball (up to a factor `τ`). This order corresponds to the order of choice\nin the inductive construction: otherwise, the second ball would have been chosen before.\nThis is the condition `h`.\n\nFinally, the last ball is chosen after all the other ones, meaning that `h` can be strengthened\nby keeping only one side of the alternative in `hlast`.\n-/\nstructure Besicovitch.SatelliteConfig (α : Type*) [MetricSpace α] (N : ℕ) (τ : ℝ) where\n  c : Fin N.succ → α\n  r : Fin N.succ → ℝ\n  rpos : ∀ i, 0 < r i\n  h : Pairwise fun i j =>\n    r i ≤ dist (c i) (c j) ∧ r j ≤ τ * r i ∨ r j ≤ dist (c j) (c i) ∧ r i ≤ τ * r j\n  hlast : ∀ i < last N, r i ≤ dist (c i) (c (last N)) ∧ r (last N) ≤ τ * r i\n  inter : ∀ i < last N, dist (c i) (c (last N)) ≤ r i + r (last N)\n\n"}
{"name":"HasBesicovitchCovering.no_satelliteConfig","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nself : HasBesicovitchCovering α\n⊢ Exists fun N => Exists fun τ => And (LT.lt 1 τ) (IsEmpty (Besicovitch.SatelliteConfig α N τ))","decl":"/-- A metric space has the Besicovitch covering property if there exist `N` and `τ > 1` such that\nthere are no satellite configuration of parameter `τ` with `N+1` points. This is the condition that\nguarantees that the measurable Besicovitch covering theorem holds. It is satisfied by\nfinite-dimensional real vector spaces. -/\nclass HasBesicovitchCovering (α : Type*) [MetricSpace α] : Prop where\n  no_satelliteConfig : ∃ (N : ℕ) (τ : ℝ), 1 < τ ∧ IsEmpty (Besicovitch.SatelliteConfig α N τ)\n\n"}
{"name":"Besicovitch.SatelliteConfig.inter'","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig α N τ\ni : Fin N.succ\n⊢ LE.le (Dist.dist (a.c i) (a.c (Fin.last N))) (HAdd.hAdd (a.r i) (a.r (Fin.last N)))","decl":"theorem inter' (i : Fin N.succ) : dist (a.c i) (a.c (last N)) ≤ a.r i + a.r (last N) := by\n  rcases lt_or_le i (last N) with (H | H)\n  · exact a.inter i H\n  · have I : i = last N := top_le_iff.1 H\n    have := (a.rpos (last N)).le\n    simp only [I, add_nonneg this this, dist_self]\n\n"}
{"name":"Besicovitch.SatelliteConfig.hlast'","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nN : Nat\nτ : Real\na : Besicovitch.SatelliteConfig α N τ\ni : Fin N.succ\nh : LE.le 1 τ\n⊢ LE.le (a.r (Fin.last N)) (HMul.hMul τ (a.r i))","decl":"theorem hlast' (i : Fin N.succ) (h : 1 ≤ τ) : a.r (last N) ≤ τ * a.r i := by\n  rcases lt_or_le i (last N) with (H | H)\n  · exact (a.hlast i H).2\n  · have : i = last N := top_le_iff.1 H\n    rw [this]\n    exact le_mul_of_one_le_left (a.rpos _).le h\n\n"}
{"name":"Besicovitch.BallPackage.r_le","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\nself : Besicovitch.BallPackage β α\nb : β\n⊢ LE.le (self.r b) self.r_bound","decl":"/-- A ball package is a family of balls in a metric space with positive bounded radii. -/\nstructure BallPackage (β : Type*) (α : Type*) where\n  c : β → α\n  r : β → ℝ\n  rpos : ∀ b, 0 < r b\n  r_bound : ℝ\n  r_le : ∀ b, r b ≤ r_bound\n\n"}
{"name":"Besicovitch.BallPackage.mk.inj","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\nc✝ : β → α\nr✝ : β → Real\nrpos✝ : ∀ (b : β), LT.lt 0 (r✝ b)\nr_bound✝ : Real\nr_le✝ : ∀ (b : β), LE.le (r✝ b) r_bound✝\nc : β → α\nr : β → Real\nrpos : ∀ (b : β), LT.lt 0 (r b)\nr_bound : Real\nr_le : ∀ (b : β), LE.le (r b) r_bound\nx✝ : Eq { c := c✝, r := r✝, rpos := rpos✝, r_bound := r_bound✝, r_le := r_le✝ } { c := c, r := r, rpos := rpos, r_bound := r_bound, r_le := r_le }\n⊢ And (Eq c✝ c) (And (Eq r✝ r) (Eq r_bound✝ r_bound))","decl":"/-- A ball package is a family of balls in a metric space with positive bounded radii. -/\nstructure BallPackage (β : Type*) (α : Type*) where\n  c : β → α\n  r : β → ℝ\n  rpos : ∀ b, 0 < r b\n  r_bound : ℝ\n  r_le : ∀ b, r b ≤ r_bound\n\n"}
{"name":"Besicovitch.BallPackage.rpos","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\nself : Besicovitch.BallPackage β α\nb : β\n⊢ LT.lt 0 (self.r b)","decl":"/-- A ball package is a family of balls in a metric space with positive bounded radii. -/\nstructure BallPackage (β : Type*) (α : Type*) where\n  c : β → α\n  r : β → ℝ\n  rpos : ∀ b, 0 < r b\n  r_bound : ℝ\n  r_le : ∀ b, r b ≤ r_bound\n\n"}
{"name":"Besicovitch.BallPackage.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\ninst✝¹ : SizeOf β\ninst✝ : SizeOf α\nc : β → α\nr : β → Real\nrpos : ∀ (b : β), LT.lt 0 (r b)\nr_bound : Real\nr_le : ∀ (b : β), LE.le (r b) r_bound\n⊢ Eq (SizeOf.sizeOf { c := c, r := r, rpos := rpos, r_bound := r_bound, r_le := r_le }) (HAdd.hAdd 1 (SizeOf.sizeOf r_bound))","decl":"/-- A ball package is a family of balls in a metric space with positive bounded radii. -/\nstructure BallPackage (β : Type*) (α : Type*) where\n  c : β → α\n  r : β → ℝ\n  rpos : ∀ b, 0 < r b\n  r_bound : ℝ\n  r_le : ∀ b, r b ≤ r_bound\n\n"}
{"name":"Besicovitch.BallPackage.mk.injEq","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\nc✝ : β → α\nr✝ : β → Real\nrpos✝ : ∀ (b : β), LT.lt 0 (r✝ b)\nr_bound✝ : Real\nr_le✝ : ∀ (b : β), LE.le (r✝ b) r_bound✝\nc : β → α\nr : β → Real\nrpos : ∀ (b : β), LT.lt 0 (r b)\nr_bound : Real\nr_le : ∀ (b : β), LE.le (r b) r_bound\n⊢ Eq (Eq { c := c✝, r := r✝, rpos := rpos✝, r_bound := r_bound✝, r_le := r_le✝ } { c := c, r := r, rpos := rpos, r_bound := r_bound, r_le := r_le }) (And (Eq c✝ c) (And (Eq r✝ r) (Eq r_bound✝ r_bound)))","decl":"/-- A ball package is a family of balls in a metric space with positive bounded radii. -/\nstructure BallPackage (β : Type*) (α : Type*) where\n  c : β → α\n  r : β → ℝ\n  rpos : ∀ b, 0 < r b\n  r_bound : ℝ\n  r_le : ∀ b, r b ≤ r_bound\n\n"}
{"name":"Besicovitch.TauPackage.one_lt_tau","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\nself : Besicovitch.TauPackage β α\n⊢ LT.lt 1 self.τ","decl":"/-- A Besicovitch tau-package is a family of balls in a metric space with positive bounded radii,\ntogether with enough data to proceed with the Besicovitch greedy algorithm. We register this in\na single structure to make sure that all our constructions in this algorithm only depend on\none variable. -/\nstructure TauPackage (β : Type*) (α : Type*) extends BallPackage β α where\n  τ : ℝ\n  one_lt_tau : 1 < τ\n\n"}
{"name":"Besicovitch.TauPackage.mk.injEq","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\ntoBallPackage✝ : Besicovitch.BallPackage β α\nτ✝ : Real\none_lt_tau✝ : LT.lt 1 τ✝\ntoBallPackage : Besicovitch.BallPackage β α\nτ : Real\none_lt_tau : LT.lt 1 τ\n⊢ Eq (Eq { toBallPackage := toBallPackage✝, τ := τ✝, one_lt_tau := one_lt_tau✝ } { toBallPackage := toBallPackage, τ := τ, one_lt_tau := one_lt_tau }) (And (Eq toBallPackage✝ toBallPackage) (Eq τ✝ τ))","decl":"/-- A Besicovitch tau-package is a family of balls in a metric space with positive bounded radii,\ntogether with enough data to proceed with the Besicovitch greedy algorithm. We register this in\na single structure to make sure that all our constructions in this algorithm only depend on\none variable. -/\nstructure TauPackage (β : Type*) (α : Type*) extends BallPackage β α where\n  τ : ℝ\n  one_lt_tau : 1 < τ\n\n"}
{"name":"Besicovitch.TauPackage.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\ninst✝¹ : SizeOf β\ninst✝ : SizeOf α\ntoBallPackage : Besicovitch.BallPackage β α\nτ : Real\none_lt_tau : LT.lt 1 τ\n⊢ Eq (SizeOf.sizeOf { toBallPackage := toBallPackage, τ := τ, one_lt_tau := one_lt_tau }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toBallPackage)) (SizeOf.sizeOf τ)) (SizeOf.sizeOf one_lt_tau))","decl":"/-- A Besicovitch tau-package is a family of balls in a metric space with positive bounded radii,\ntogether with enough data to proceed with the Besicovitch greedy algorithm. We register this in\na single structure to make sure that all our constructions in this algorithm only depend on\none variable. -/\nstructure TauPackage (β : Type*) (α : Type*) extends BallPackage β α where\n  τ : ℝ\n  one_lt_tau : 1 < τ\n\n"}
{"name":"Besicovitch.TauPackage.mk.inj","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u_1\nα : Type u_2\ntoBallPackage✝ : Besicovitch.BallPackage β α\nτ✝ : Real\none_lt_tau✝ : LT.lt 1 τ✝\ntoBallPackage : Besicovitch.BallPackage β α\nτ : Real\none_lt_tau : LT.lt 1 τ\nx✝ : Eq { toBallPackage := toBallPackage✝, τ := τ✝, one_lt_tau := one_lt_tau✝ } { toBallPackage := toBallPackage, τ := τ, one_lt_tau := one_lt_tau }\n⊢ And (Eq toBallPackage✝ toBallPackage) (Eq τ✝ τ)","decl":"/-- A Besicovitch tau-package is a family of balls in a metric space with positive bounded radii,\ntogether with enough data to proceed with the Besicovitch greedy algorithm. We register this in\na single structure to make sure that all our constructions in this algorithm only depend on\none variable. -/\nstructure TauPackage (β : Type*) (α : Type*) extends BallPackage β α where\n  τ : ℝ\n  one_lt_tau : 1 < τ\n\n"}
{"name":"Besicovitch.TauPackage.monotone_iUnionUpTo","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nβ : Type u\ninst✝ : Nonempty β\np : Besicovitch.TauPackage β α\n⊢ Monotone p.iUnionUpTo","decl":"theorem monotone_iUnionUpTo : Monotone p.iUnionUpTo := by\n  intro i j hij\n  simp only [iUnionUpTo]\n  exact iUnion_mono' fun r => ⟨⟨r, r.2.trans_le hij⟩, Subset.rfl⟩\n\n"}
{"name":"Besicovitch.TauPackage.lastStep_nonempty","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nβ : Type u\ninst✝ : Nonempty β\np : Besicovitch.TauPackage β α\n⊢ (setOf fun i => Not (Exists fun b => And (Not (Membership.mem (p.iUnionUpTo i) (p.c b))) (LE.le (p.R i) (HMul.hMul p.τ (p.r b))))).Nonempty","decl":"theorem lastStep_nonempty :\n    {i | ¬∃ b : β, p.c b ∉ p.iUnionUpTo i ∧ p.R i ≤ p.τ * p.r b}.Nonempty := by\n  by_contra h\n  suffices H : Function.Injective p.index from not_injective_of_ordinal p.index H\n  intro x y hxy\n  wlog x_le_y : x ≤ y generalizing x y\n  · exact (this hxy.symm (le_of_not_le x_le_y)).symm\n  rcases eq_or_lt_of_le x_le_y with (rfl | H); · rfl\n  simp only [nonempty_def, not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq,\n    not_forall] at h\n  specialize h y\n  have A : p.c (p.index y) ∉ p.iUnionUpTo y := by\n    have :\n        p.index y =\n          Classical.epsilon fun b : β => p.c b ∉ p.iUnionUpTo y ∧ p.R y ≤ p.τ * p.r b := by\n      rw [TauPackage.index]; rfl\n    rw [this]\n    exact (Classical.epsilon_spec h).1\n  simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,\n    Subtype.exists, Subtype.coe_mk] at A\n  specialize A x H\n  simp? [hxy] at A says simp only [hxy, mem_ball, dist_self, not_lt] at A\n  exact (lt_irrefl _ ((p.rpos (p.index y)).trans_le A)).elim\n\n"}
{"name":"Besicovitch.TauPackage.mem_iUnionUpTo_lastStep","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nβ : Type u\ninst✝ : Nonempty β\np : Besicovitch.TauPackage β α\nx : β\n⊢ Membership.mem (p.iUnionUpTo p.lastStep) (p.c x)","decl":"/-- Every point is covered by chosen balls, before `p.lastStep`. -/\ntheorem mem_iUnionUpTo_lastStep (x : β) : p.c x ∈ p.iUnionUpTo p.lastStep := by\n  have A : ∀ z : β, p.c z ∈ p.iUnionUpTo p.lastStep ∨ p.τ * p.r z < p.R p.lastStep := by\n    have : p.lastStep ∈ {i | ¬∃ b : β, p.c b ∉ p.iUnionUpTo i ∧ p.R i ≤ p.τ * p.r b} :=\n      csInf_mem p.lastStep_nonempty\n    simpa only [not_exists, mem_setOf_eq, not_and_or, not_le, not_not_mem]\n  by_contra h\n  rcases A x with (H | H); · exact h H\n  have Rpos : 0 < p.R p.lastStep := by\n    apply lt_trans (mul_pos (_root_.zero_lt_one.trans p.one_lt_tau) (p.rpos _)) H\n  have B : p.τ⁻¹ * p.R p.lastStep < p.R p.lastStep := by\n    conv_rhs => rw [← one_mul (p.R p.lastStep)]\n    exact mul_lt_mul (inv_lt_one_of_one_lt₀ p.one_lt_tau) le_rfl Rpos zero_le_one\n  obtain ⟨y, hy1, hy2⟩ : ∃ y, p.c y ∉ p.iUnionUpTo p.lastStep ∧ p.τ⁻¹ * p.R p.lastStep < p.r y := by\n    have := exists_lt_of_lt_csSup ?_ B\n    · simpa only [exists_prop, mem_range, exists_exists_and_eq_and, Subtype.exists,\n      Subtype.coe_mk]\n    rw [← image_univ, image_nonempty]\n    exact ⟨⟨_, h⟩, mem_univ _⟩\n  rcases A y with (Hy | Hy)\n  · exact hy1 Hy\n  · rw [← div_eq_inv_mul] at hy2\n    have := (div_le_iff₀' (_root_.zero_lt_one.trans p.one_lt_tau)).1 hy2.le\n    exact lt_irrefl _ (Hy.trans_le this)\n\n"}
{"name":"Besicovitch.TauPackage.color_lt","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝¹ : MetricSpace α\nβ : Type u\ninst✝ : Nonempty β\np : Besicovitch.TauPackage β α\ni : Ordinal.{u}\nhi : LT.lt i p.lastStep\nN : Nat\nhN : IsEmpty (Besicovitch.SatelliteConfig α N p.τ)\n⊢ LT.lt (p.color i) N","decl":"/-- If there are no configurations of satellites with `N+1` points, one never uses more than `N`\ndistinct families in the Besicovitch inductive construction. -/\ntheorem color_lt {i : Ordinal.{u}} (hi : i < p.lastStep) {N : ℕ}\n    (hN : IsEmpty (SatelliteConfig α N p.τ)) : p.color i < N := by\n  /- By contradiction, consider the first ordinal `i` for which one would have `p.color i = N`.\n    Choose for each `k < N` a ball with color `k` that intersects the ball at color `i`\n    (there is such a ball, otherwise one would have used the color `k` and not `N`).\n    Then this family of `N+1` balls forms a satellite configuration, which is forbidden by\n    the assumption `hN`. -/\n  induction' i using Ordinal.induction with i IH\n  let A : Set ℕ :=\n    ⋃ (j : { j // j < i })\n      (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) ∩\n        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty),\n      {p.color j}\n  have color_i : p.color i = sInf (univ \\ A) := by rw [color]\n  rw [color_i]\n  have N_mem : N ∈ univ \\ A := by\n    simp only [A, not_exists, true_and, exists_prop, mem_iUnion, mem_singleton_iff,\n      mem_closedBall, not_and, mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]\n    intro j ji _\n    exact (IH j ji (ji.trans hi)).ne'\n  suffices sInf (univ \\ A) ≠ N by\n    rcases (csInf_le (OrderBot.bddBelow (univ \\ A)) N_mem).lt_or_eq with (H | H)\n    · exact H\n    · exact (this H).elim\n  intro Inf_eq_N\n  have :\n    ∀ k, k < N → ∃ j, j < i ∧\n      (closedBall (p.c (p.index j)) (p.r (p.index j)) ∩\n        closedBall (p.c (p.index i)) (p.r (p.index i))).Nonempty ∧ k = p.color j := by\n    intro k hk\n    rw [← Inf_eq_N] at hk\n    have : k ∈ A := by\n      simpa only [true_and, mem_univ, Classical.not_not, mem_diff] using\n        Nat.not_mem_of_lt_sInf hk\n    simp only [mem_iUnion, mem_singleton_iff, exists_prop, Subtype.exists, exists_and_right,\n      and_assoc] at this\n    simpa only [A, exists_prop, mem_iUnion, mem_singleton_iff, mem_closedBall, Subtype.exists,\n      Subtype.coe_mk]\n  choose! g hg using this\n  -- Choose for each `k < N` an ordinal `G k < i` giving a ball of color `k` intersecting\n  -- the last ball.\n  let G : ℕ → Ordinal := fun n => if n = N then i else g n\n  have color_G : ∀ n, n ≤ N → p.color (G n) = n := by\n    intro n hn\n    rcases hn.eq_or_lt with (rfl | H)\n    · simp only [G]; simp only [color_i, Inf_eq_N, if_true, eq_self_iff_true]\n    · simp only [G]; simp only [H.ne, (hg n H).right.right.symm, if_false]\n  have G_lt_last : ∀ n, n ≤ N → G n < p.lastStep := by\n    intro n hn\n    rcases hn.eq_or_lt with (rfl | H)\n    · simp only [G]; simp only [hi, if_true, eq_self_iff_true]\n    · simp only [G]; simp only [H.ne, (hg n H).left.trans hi, if_false]\n  have fGn :\n      ∀ n, n ≤ N →\n        p.c (p.index (G n)) ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r (p.index (G n)) := by\n    intro n hn\n    have :\n      p.index (G n) =\n        Classical.epsilon fun t => p.c t ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r t := by\n      rw [index]; rfl\n    rw [this]\n    have : ∃ t, p.c t ∉ p.iUnionUpTo (G n) ∧ p.R (G n) ≤ p.τ * p.r t := by\n      simpa only [not_exists, exists_prop, not_and, not_lt, not_le, mem_setOf_eq, not_forall] using\n        not_mem_of_lt_csInf (G_lt_last n hn) (OrderBot.bddBelow _)\n    exact Classical.epsilon_spec this\n  -- the balls with indices `G k` satisfy the characteristic property of satellite configurations.\n  have Gab :\n    ∀ a b : Fin (Nat.succ N),\n      G a < G b →\n        p.r (p.index (G a)) ≤ dist (p.c (p.index (G a))) (p.c (p.index (G b))) ∧\n          p.r (p.index (G b)) ≤ p.τ * p.r (p.index (G a)) := by\n    intro a b G_lt\n    have ha : (a : ℕ) ≤ N := Nat.lt_succ_iff.1 a.2\n    have hb : (b : ℕ) ≤ N := Nat.lt_succ_iff.1 b.2\n    constructor\n    · have := (fGn b hb).1\n      simp only [iUnionUpTo, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_le,\n        Subtype.exists, Subtype.coe_mk] at this\n      simpa only [dist_comm, mem_ball, not_lt] using this (G a) G_lt\n    · apply le_trans _ (fGn a ha).2\n      have B : p.c (p.index (G b)) ∉ p.iUnionUpTo (G a) := by\n        intro H; exact (fGn b hb).1 (p.monotone_iUnionUpTo G_lt.le H)\n      let b' : { t // p.c t ∉ p.iUnionUpTo (G a) } := ⟨p.index (G b), B⟩\n      apply @le_ciSup _ _ _ (fun t : { t // p.c t ∉ p.iUnionUpTo (G a) } => p.r t) _ b'\n      refine ⟨p.r_bound, fun t ht => ?_⟩\n      simp only [exists_prop, mem_range, Subtype.exists, Subtype.coe_mk] at ht\n      rcases ht with ⟨u, hu⟩\n      rw [← hu.2]\n      exact p.r_le _\n  -- therefore, one may use them to construct a satellite configuration with `N+1` points\n  let sc : SatelliteConfig α N p.τ :=\n    { c := fun k => p.c (p.index (G k))\n      r := fun k => p.r (p.index (G k))\n      rpos := fun k => p.rpos (p.index (G k))\n      h := by\n        intro a b a_ne_b\n        wlog G_le : G a ≤ G b generalizing a b\n        · exact (this a_ne_b.symm (le_of_not_le G_le)).symm\n        have G_lt : G a < G b := by\n          rcases G_le.lt_or_eq with (H | H); · exact H\n          have A : (a : ℕ) ≠ b := Fin.val_injective.ne a_ne_b\n          rw [← color_G a (Nat.lt_succ_iff.1 a.2), ← color_G b (Nat.lt_succ_iff.1 b.2), H] at A\n          exact (A rfl).elim\n        exact Or.inl (Gab a b G_lt)\n      hlast := by\n        intro a ha\n        have I : (a : ℕ) < N := ha\n        have : G a < G (Fin.last N) := by dsimp; simp [G, I.ne, (hg a I).1]\n        exact Gab _ _ this\n      inter := by\n        intro a ha\n        have I : (a : ℕ) < N := ha\n        have J : G (Fin.last N) = i := by dsimp; simp only [G, if_true, eq_self_iff_true]\n        have K : G a = g a := by dsimp [G]; simp [I.ne, (hg a I).1]\n        convert dist_le_add_of_nonempty_closedBall_inter_closedBall (hg _ I).2.1 }\n  -- this is a contradiction\n  exact hN.false sc\n\n"}
{"name":"Besicovitch.exist_disjoint_covering_families","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝ : MetricSpace α\nβ : Type u\nN : Nat\nτ : Real\nhτ : LT.lt 1 τ\nhN : IsEmpty (Besicovitch.SatelliteConfig α N τ)\nq : Besicovitch.BallPackage β α\n⊢ Exists fun s => And (∀ (i : Fin N), (s i).PairwiseDisjoint fun j => Metric.closedBall (q.c j) (q.r j)) (HasSubset.Subset (Set.range q.c) (Set.iUnion fun i => Set.iUnion fun j => Set.iUnion fun h => Metric.ball (q.c j) (q.r j)))","decl":"/-- The topological Besicovitch covering theorem: there exist finitely many families of disjoint\nballs covering all the centers in a package. More specifically, one can use `N` families if there\nare no satellite configurations with `N+1` points. -/\ntheorem exist_disjoint_covering_families {N : ℕ} {τ : ℝ} (hτ : 1 < τ)\n    (hN : IsEmpty (SatelliteConfig α N τ)) (q : BallPackage β α) :\n    ∃ s : Fin N → Set β,\n      (∀ i : Fin N, (s i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) ∧\n        range q.c ⊆ ⋃ i : Fin N, ⋃ j ∈ s i, ball (q.c j) (q.r j) := by\n  -- first exclude the trivial case where `β` is empty (we need non-emptiness for the transfinite\n  -- induction, to be able to choose garbage when there is no point left).\n  cases isEmpty_or_nonempty β\n  · refine ⟨fun _ => ∅, fun _ => pairwiseDisjoint_empty, ?_⟩\n    rw [← image_univ, eq_empty_of_isEmpty (univ : Set β)]\n    simp\n  -- Now, assume `β` is nonempty.\n  let p : TauPackage β α :=\n    { q with\n      τ\n      one_lt_tau := hτ }\n  -- we use for `s i` the balls of color `i`.\n  let s := fun i : Fin N =>\n    ⋃ (k : Ordinal.{u}) (_ : k < p.lastStep) (_ : p.color k = i), ({p.index k} : Set β)\n  refine ⟨s, fun i => ?_, ?_⟩\n  · -- show that balls of the same color are disjoint\n    intro x hx y hy x_ne_y\n    obtain ⟨jx, jx_lt, jxi, rfl⟩ :\n      ∃ jx : Ordinal, jx < p.lastStep ∧ p.color jx = i ∧ x = p.index jx := by\n      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hx\n    obtain ⟨jy, jy_lt, jyi, rfl⟩ :\n      ∃ jy : Ordinal, jy < p.lastStep ∧ p.color jy = i ∧ y = p.index jy := by\n      simpa only [s, exists_prop, mem_iUnion, mem_singleton_iff] using hy\n    wlog jxy : jx ≤ jy generalizing jx jy\n    · exact (this jy jy_lt jyi hy jx jx_lt jxi hx x_ne_y.symm (le_of_not_le jxy)).symm\n    replace jxy : jx < jy := by\n      rcases lt_or_eq_of_le jxy with (H | rfl); · { exact H }; · { exact (x_ne_y rfl).elim }\n    let A : Set ℕ :=\n      ⋃ (j : { j // j < jy })\n        (_ : (closedBall (p.c (p.index j)) (p.r (p.index j)) ∩\n          closedBall (p.c (p.index jy)) (p.r (p.index jy))).Nonempty),\n        {p.color j}\n    have color_j : p.color jy = sInf (univ \\ A) := by rw [TauPackage.color]\n    have h : p.color jy ∈ univ \\ A := by\n      rw [color_j]\n      apply csInf_mem\n      refine ⟨N, ?_⟩\n      simp only [A, not_exists, true_and, exists_prop, mem_iUnion, mem_singleton_iff, not_and,\n        mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk]\n      intro k hk _\n      exact (p.color_lt (hk.trans jy_lt) hN).ne'\n    simp only [A, not_exists, true_and, exists_prop, mem_iUnion, mem_singleton_iff, not_and,\n      mem_univ, mem_diff, Subtype.exists, Subtype.coe_mk] at h\n    specialize h jx jxy\n    contrapose! h\n    simpa only [jxi, jyi, and_true, eq_self_iff_true, ← not_disjoint_iff_nonempty_inter] using h\n  · -- show that the balls of color at most `N` cover every center.\n    refine range_subset_iff.2 fun b => ?_\n    obtain ⟨a, ha⟩ :\n      ∃ a : Ordinal, a < p.lastStep ∧ dist (p.c b) (p.c (p.index a)) < p.r (p.index a) := by\n      simpa only [iUnionUpTo, exists_prop, mem_iUnion, mem_ball, Subtype.exists,\n        Subtype.coe_mk] using p.mem_iUnionUpTo_lastStep b\n    simp only [s, exists_prop, mem_iUnion, mem_ball, mem_singleton_iff, biUnion_and',\n      exists_eq_left, iUnion_exists, exists_and_left]\n    exact ⟨⟨p.color a, p.color_lt ha.1 hN⟩, a, rfl, ha⟩\n\n"}
{"name":"Besicovitch.exist_finset_disjoint_balls_large_measure","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁴ : MetricSpace α\ninst✝³ : SecondCountableTopology α\ninst✝² : MeasurableSpace α\ninst✝¹ : OpensMeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nN : Nat\nτ : Real\nhτ : LT.lt 1 τ\nhN : IsEmpty (Besicovitch.SatelliteConfig α N τ)\ns : Set α\nr : α → Real\nrpos : ∀ (x : α), Membership.mem s x → LT.lt 0 (r x)\nrle : ∀ (x : α), Membership.mem s x → LE.le (r x) 1\n⊢ Exists fun t => And (HasSubset.Subset (↑t) s) (And (LE.le (μ (SDiff.sdiff s (Set.iUnion fun x => Set.iUnion fun h => Metric.closedBall x (r x)))) (HMul.hMul (HDiv.hDiv (↑N) (HAdd.hAdd (↑N) 1)) (μ s))) ((↑t).PairwiseDisjoint fun x => Metric.closedBall x (r x)))","decl":"/-- Consider, for each `x` in a set `s`, a radius `r x ∈ (0, 1]`. Then one can find finitely\nmany disjoint balls of the form `closedBall x (r x)` covering a proportion `1/(N+1)` of `s`, if\nthere are no satellite configurations with `N+1` points.\n-/\ntheorem exist_finset_disjoint_balls_large_measure (μ : Measure α) [IsFiniteMeasure μ] {N : ℕ}\n    {τ : ℝ} (hτ : 1 < τ) (hN : IsEmpty (SatelliteConfig α N τ)) (s : Set α) (r : α → ℝ)\n    (rpos : ∀ x ∈ s, 0 < r x) (rle : ∀ x ∈ s, r x ≤ 1) :\n    ∃ t : Finset α, ↑t ⊆ s ∧ μ (s \\ ⋃ x ∈ t, closedBall x (r x)) ≤ N / (N + 1) * μ s ∧\n      (t : Set α).PairwiseDisjoint fun x => closedBall x (r x) := by\n  classical\n  -- exclude the trivial case where `μ s = 0`.\n  rcases le_or_lt (μ s) 0 with (hμs | hμs)\n  · have : μ s = 0 := le_bot_iff.1 hμs\n    refine ⟨∅, by simp only [Finset.coe_empty, empty_subset], ?_, ?_⟩\n    · simp only [this, Finset.not_mem_empty, diff_empty, iUnion_false, iUnion_empty,\n        nonpos_iff_eq_zero, mul_zero]\n    · simp only [Finset.coe_empty, pairwiseDisjoint_empty]\n  cases isEmpty_or_nonempty α\n  · simp only [eq_empty_of_isEmpty s, measure_empty] at hμs\n    exact (lt_irrefl _ hμs).elim\n  have Npos : N ≠ 0 := by\n    rintro rfl\n    inhabit α\n    exact not_isEmpty_of_nonempty _ hN\n  -- introduce a measurable superset `o` with the same measure, for measure computations\n  obtain ⟨o, so, omeas, μo⟩ : ∃ o : Set α, s ⊆ o ∧ MeasurableSet o ∧ μ o = μ s :=\n    exists_measurable_superset μ s\n  /- We will apply the topological Besicovitch theorem, giving `N` disjoint subfamilies of balls\n    covering `s`. Among these, one of them covers a proportion at least `1/N` of `s`. A large\n    enough finite subfamily will then cover a proportion at least `1/(N+1)`. -/\n  let a : BallPackage s α :=\n    { c := fun x => x\n      r := fun x => r x\n      rpos := fun x => rpos x x.2\n      r_bound := 1\n      r_le := fun x => rle x x.2 }\n  rcases exist_disjoint_covering_families hτ hN a with ⟨u, hu, hu'⟩\n  have u_count : ∀ i, (u i).Countable := by\n    intro i\n    refine (hu i).countable_of_nonempty_interior fun j _ => ?_\n    have : (ball (j : α) (r j)).Nonempty := nonempty_ball.2 (a.rpos _)\n    exact this.mono ball_subset_interior_closedBall\n  let v : Fin N → Set α := fun i => ⋃ (x : s) (_ : x ∈ u i), closedBall x (r x)\n  have A : s = ⋃ i : Fin N, s ∩ v i := by\n    refine Subset.antisymm ?_ (iUnion_subset fun i => inter_subset_left)\n    intro x hx\n    obtain ⟨i, y, hxy, h'⟩ :\n        ∃ (i : Fin N) (i_1 : ↥s), i_1 ∈ u i ∧ x ∈ ball (↑i_1) (r ↑i_1) := by\n      have : x ∈ range a.c := by simpa only [a, Subtype.range_coe_subtype, setOf_mem_eq]\n      simpa only [mem_iUnion, bex_def] using hu' this\n    refine mem_iUnion.2 ⟨i, ⟨hx, ?_⟩⟩\n    simp only [v, exists_prop, mem_iUnion, SetCoe.exists, exists_and_right, Subtype.coe_mk]\n    exact ⟨y, ⟨y.2, by simpa only [Subtype.coe_eta]⟩, ball_subset_closedBall h'⟩\n  have S : ∑ _i : Fin N, μ s / N ≤ ∑ i, μ (s ∩ v i) :=\n    calc\n      ∑ _i : Fin N, μ s / N = μ s := by\n        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul]\n        rw [ENNReal.mul_div_cancel]\n        · simp only [Npos, Ne, Nat.cast_eq_zero, not_false_iff]\n        · exact ENNReal.natCast_ne_top _\n      _ ≤ ∑ i, μ (s ∩ v i) := by\n        conv_lhs => rw [A]\n        apply measure_iUnion_fintype_le\n  -- choose an index `i` of a subfamily covering at least a proportion `1/N` of `s`.\n  obtain ⟨i, -, hi⟩ : ∃ (i : Fin N), i ∈ Finset.univ ∧ μ s / N ≤ μ (s ∩ v i) := by\n    apply ENNReal.exists_le_of_sum_le _ S\n    exact ⟨⟨0, bot_lt_iff_ne_bot.2 Npos⟩, Finset.mem_univ _⟩\n  replace hi : μ s / (N + 1) < μ (s ∩ v i) := by\n    apply lt_of_lt_of_le _ hi\n    apply (ENNReal.mul_lt_mul_left hμs.ne' (measure_lt_top μ s).ne).2\n    rw [ENNReal.inv_lt_inv]\n    conv_lhs => rw [← add_zero (N : ℝ≥0∞)]\n    exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one\n  have B : μ (o ∩ v i) = ∑' x : u i, μ (o ∩ closedBall x (r x)) := by\n    have : o ∩ v i = ⋃ (x : s) (_ : x ∈ u i), o ∩ closedBall x (r x) := by\n      simp only [v, inter_iUnion]\n    rw [this, measure_biUnion (u_count i)]\n    · exact (hu i).mono fun k => inter_subset_right\n    · exact fun b _ => omeas.inter measurableSet_closedBall\n  -- A large enough finite subfamily of `u i` will also cover a proportion `> 1/(N+1)` of `s`.\n  -- Since `s` might not be measurable, we express this in terms of the measurable superset `o`.\n  obtain ⟨w, hw⟩ :\n    ∃ w : Finset (u i), μ s / (N + 1) <\n      ∑ x ∈ w, μ (o ∩ closedBall (x : α) (r (x : α))) := by\n    have C : HasSum (fun x : u i => μ (o ∩ closedBall x (r x))) (μ (o ∩ v i)) := by\n      rw [B]; exact ENNReal.summable.hasSum\n    have : μ s / (N + 1) < μ (o ∩ v i) := hi.trans_le (measure_mono (inter_subset_inter_left _ so))\n    exact ((tendsto_order.1 C).1 _ this).exists\n  -- Bring back the finset `w i` of `↑(u i)` to a finset of `α`, and check that it works by design.\n  refine ⟨Finset.image (fun x : u i => x) w, ?_, ?_, ?_⟩\n  -- show that the finset is included in `s`.\n  · simp only [image_subset_iff, Finset.coe_image]\n    intro y _\n    simp only [Subtype.coe_prop, mem_preimage]\n  -- show that it covers a large enough proportion of `s`. For measure computations, we do not\n  -- use `s` (which might not be measurable), but its measurable superset `o`. Since their measures\n  -- are the same, this does not spoil the estimates\n  · suffices H : μ (o \\ ⋃ x ∈ w, closedBall (↑x) (r ↑x)) ≤ N / (N + 1) * μ s by\n      rw [Finset.set_biUnion_finset_image]\n      exact le_trans (measure_mono (diff_subset_diff so (Subset.refl _))) H\n    rw [← diff_inter_self_eq_diff,\n      measure_diff_le_iff_le_add _ inter_subset_right (measure_lt_top μ _).ne]\n    swap\n    · exact .inter\n        (w.nullMeasurableSet_biUnion fun _ _ ↦ measurableSet_closedBall.nullMeasurableSet)\n        omeas.nullMeasurableSet\n    calc\n      μ o = 1 / (N + 1) * μ s + N / (N + 1) * μ s := by\n        rw [μo, ← add_mul, ENNReal.div_add_div_same, add_comm, ENNReal.div_self, one_mul] <;> simp\n      _ ≤ μ ((⋃ x ∈ w, closedBall (↑x) (r ↑x)) ∩ o) + N / (N + 1) * μ s := by\n        gcongr\n        rw [one_div, mul_comm, ← div_eq_mul_inv]\n        apply hw.le.trans (le_of_eq _)\n        rw [← Finset.set_biUnion_coe, inter_comm _ o, inter_iUnion₂, Finset.set_biUnion_coe,\n          measure_biUnion_finset]\n        · have : (w : Set (u i)).PairwiseDisjoint\n              fun b : u i => closedBall (b : α) (r (b : α)) := by\n            intro k _ l _ hkl; exact hu i k.2 l.2 (Subtype.val_injective.ne hkl)\n          exact this.mono fun k => inter_subset_right\n        · intro b _\n          apply omeas.inter measurableSet_closedBall\n  -- show that the balls are disjoint\n  · intro k hk l hl hkl\n    obtain ⟨k', _, rfl⟩ : ∃ k' : u i, k' ∈ w ∧ ↑k' = k := by\n      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hk\n    obtain ⟨l', _, rfl⟩ : ∃ l' : u i, l' ∈ w ∧ ↑l' = l := by\n      simpa only [mem_image, Finset.mem_coe, Finset.coe_image] using hl\n    have k'nel' : (k' : s) ≠ l' := by intro h; rw [h] at hkl; exact hkl rfl\n    exact hu i k'.2 l'.2 k'nel'\n\n"}
{"name":"Besicovitch.exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁵ : MetricSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : HasBesicovitchCovering α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → Set Real\ns : Set α\nhf : ∀ (x : α), Membership.mem s x → ∀ (δ : Real), GT.gt δ 0 → (Inter.inter (f x) (Set.Ioo 0 δ)).Nonempty\n⊢ Exists fun t => And t.Countable (And (∀ (p : Prod α Real), Membership.mem t p → Membership.mem s p.1) (And (∀ (p : Prod α Real), Membership.mem t p → Membership.mem (f p.1) p.2) (And (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun x => Metric.closedBall p.1 p.2))) 0) (t.PairwiseDisjoint fun p => Metric.closedBall p.1 p.2))))","decl":"/-- The **measurable Besicovitch covering theorem**. Assume that, for any `x` in a set `s`,\none is given a set of admissible closed balls centered at `x`, with arbitrarily small radii.\nThen there exists a disjoint covering of almost all `s` by admissible closed balls centered at some\npoints of `s`.\nThis version requires that the underlying measure is finite, and that the space has the Besicovitch\ncovering property (which is satisfied for instance by normed real vector spaces). It expresses the\nconclusion in a slightly awkward form (with a subset of `α × ℝ`) coming from the proof technique.\nFor a version assuming that the measure is sigma-finite,\nsee `exists_disjoint_closedBall_covering_ae_aux`.\nFor a version giving the conclusion in a nicer form, see `exists_disjoint_closedBall_covering_ae`.\n-/\ntheorem exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux (μ : Measure α)\n    [IsFiniteMeasure μ] (f : α → Set ℝ) (s : Set α)\n    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :\n    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧\n      μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧\n        t.PairwiseDisjoint fun p => closedBall p.1 p.2 := by\n  classical\n  rcases HasBesicovitchCovering.no_satelliteConfig (α := α) with ⟨N, τ, hτ, hN⟩\n  /- Introduce a property `P` on finsets saying that we have a nice disjoint covering of a\n      subset of `s` by admissible balls. -/\n  let P : Finset (α × ℝ) → Prop := fun t =>\n    ((t : Set (α × ℝ)).PairwiseDisjoint fun p => closedBall p.1 p.2) ∧\n      (∀ p : α × ℝ, p ∈ t → p.1 ∈ s) ∧ ∀ p : α × ℝ, p ∈ t → p.2 ∈ f p.1\n  /- Given a finite good covering of a subset `s`, one can find a larger finite good covering,\n    covering additionally a proportion at least `1/(N+1)` of leftover points. This follows from\n    `exist_finset_disjoint_balls_large_measure` applied to balls not intersecting the initial\n    covering. -/\n  have :\n      ∀ t : Finset (α × ℝ), P t → ∃ u : Finset (α × ℝ), t ⊆ u ∧ P u ∧\n        μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ u), closedBall p.1 p.2) ≤\n          N / (N + 1) * μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) := by\n    intro t ht\n    set B := ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2 with hB\n    have B_closed : IsClosed B := isClosed_biUnion_finset fun i _ => isClosed_ball\n    set s' := s \\ B\n    have : ∀ x ∈ s', ∃ r ∈ f x ∩ Ioo 0 1, Disjoint B (closedBall x r) := by\n      intro x hx\n      have xs : x ∈ s := ((mem_diff x).1 hx).1\n      rcases eq_empty_or_nonempty B with (hB | hB)\n      · rcases hf x xs 1 zero_lt_one with ⟨r, hr, h'r⟩\n        exact ⟨r, ⟨hr, h'r⟩, by simp only [hB, empty_disjoint]⟩\n      · let r := infDist x B\n        have : 0 < min r 1 :=\n          lt_min ((B_closed.not_mem_iff_infDist_pos hB).1 ((mem_diff x).1 hx).2) zero_lt_one\n        rcases hf x xs _ this with ⟨r, hr, h'r⟩\n        refine ⟨r, ⟨hr, ⟨h'r.1, h'r.2.trans_le (min_le_right _ _)⟩⟩, ?_⟩\n        rw [disjoint_comm]\n        exact disjoint_closedBall_of_lt_infDist (h'r.2.trans_le (min_le_left _ _))\n    choose! r hr using this\n    obtain ⟨v, vs', hμv, hv⟩ :\n      ∃ v : Finset α,\n        ↑v ⊆ s' ∧\n          μ (s' \\ ⋃ x ∈ v, closedBall x (r x)) ≤ N / (N + 1) * μ s' ∧\n            (v : Set α).PairwiseDisjoint fun x : α => closedBall x (r x) :=\n      haveI rI : ∀ x ∈ s', r x ∈ Ioo (0 : ℝ) 1 := fun x hx => (hr x hx).1.2\n      exist_finset_disjoint_balls_large_measure μ hτ hN s' r (fun x hx => (rI x hx).1) fun x hx =>\n        (rI x hx).2.le\n    refine ⟨t ∪ Finset.image (fun x => (x, r x)) v, Finset.subset_union_left, ⟨?_, ?_, ?_⟩, ?_⟩\n    · simp only [Finset.coe_union, pairwiseDisjoint_union, ht.1, true_and, Finset.coe_image]\n      constructor\n      · intro p hp q hq hpq\n        rcases (mem_image _ _ _).1 hp with ⟨p', p'v, rfl⟩\n        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩\n        refine hv p'v q'v fun hp'q' => ?_\n        rw [hp'q'] at hpq\n        exact hpq rfl\n      · intro p hp q hq hpq\n        rcases (mem_image _ _ _).1 hq with ⟨q', q'v, rfl⟩\n        apply disjoint_of_subset_left _ (hr q' (vs' q'v)).2\n        rw [hB, ← Finset.set_biUnion_coe]\n        exact subset_biUnion_of_mem (u := fun x : α × ℝ => closedBall x.1 x.2) hp\n    · intro p hp\n      rcases Finset.mem_union.1 hp with (h'p | h'p)\n      · exact ht.2.1 p h'p\n      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩\n        exact ((mem_diff _).1 (vs' (Finset.mem_coe.2 p'v))).1\n    · intro p hp\n      rcases Finset.mem_union.1 hp with (h'p | h'p)\n      · exact ht.2.2 p h'p\n      · rcases Finset.mem_image.1 h'p with ⟨p', p'v, rfl⟩\n        exact (hr p' (vs' p'v)).1.1\n    · convert hμv using 2\n      rw [Finset.set_biUnion_union, ← diff_diff, Finset.set_biUnion_finset_image]\n  /- Define `F` associating to a finite good covering the above enlarged good covering, covering\n    a proportion `1/(N+1)` of leftover points. Iterating `F`, one will get larger and larger good\n    coverings, missing in the end only a measure-zero set. -/\n  choose! F hF using this\n  let u n := F^[n] ∅\n  have u_succ : ∀ n : ℕ, u n.succ = F (u n) := fun n => by\n    simp only [u, Function.comp_apply, Function.iterate_succ']\n  have Pu : ∀ n, P (u n) := by\n    intro n\n    induction' n with n IH\n    · simp only [P, u, Prod.forall, id, Function.iterate_zero]\n      simp only [Finset.not_mem_empty, IsEmpty.forall_iff, Finset.coe_empty, forall₂_true_iff,\n        and_self_iff, pairwiseDisjoint_empty]\n    · rw [u_succ]\n      exact (hF (u n) IH).2.1\n  refine ⟨⋃ n, u n, countable_iUnion fun n => (u n).countable_toSet, ?_, ?_, ?_, ?_⟩\n  · intro p hp\n    rcases mem_iUnion.1 hp with ⟨n, hn⟩\n    exact (Pu n).2.1 p (Finset.mem_coe.1 hn)\n  · intro p hp\n    rcases mem_iUnion.1 hp with ⟨n, hn⟩\n    exact (Pu n).2.2 p (Finset.mem_coe.1 hn)\n  · have A :\n      ∀ n,\n        μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ ⋃ n : ℕ, (u n : Set (α × ℝ))), closedBall p.fst p.snd) ≤\n          μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by\n      intro n\n      gcongr μ (s \\ ?_)\n      exact biUnion_subset_biUnion_left (subset_iUnion (fun i => (u i : Set (α × ℝ))) n)\n    have B :\n        ∀ n, μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) ≤\n          (N / (N + 1) : ℝ≥0∞) ^ n * μ s := by\n      intro n\n      induction' n with n IH\n      · simp only [u, le_refl, diff_empty, one_mul, iUnion_false, iUnion_empty, pow_zero,\n          Function.iterate_zero, id, Finset.not_mem_empty]\n      calc\n        μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ u n.succ), closedBall p.fst p.snd) ≤\n            N / (N + 1) * μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ u n), closedBall p.fst p.snd) := by\n          rw [u_succ]; exact (hF (u n) (Pu n)).2.2\n        _ ≤ (N / (N + 1) : ℝ≥0∞) ^ n.succ * μ s := by\n          rw [pow_succ', mul_assoc]; exact mul_le_mul_left' IH _\n    have C : Tendsto (fun n : ℕ => ((N : ℝ≥0∞) / (N + 1)) ^ n * μ s) atTop (𝓝 (0 * μ s)) := by\n      apply ENNReal.Tendsto.mul_const _ (Or.inr (measure_lt_top μ s).ne)\n      apply ENNReal.tendsto_pow_atTop_nhds_zero_of_lt_one\n      rw [ENNReal.div_lt_iff, one_mul]\n      · conv_lhs => rw [← add_zero (N : ℝ≥0∞)]\n        exact ENNReal.add_lt_add_left (ENNReal.natCast_ne_top N) zero_lt_one\n      · simp only [true_or, add_eq_zero, Ne, not_false_iff, one_ne_zero, and_false]\n      · simp only [ENNReal.natCast_ne_top, Ne, not_false_iff, or_true]\n    rw [zero_mul] at C\n    apply le_bot_iff.1\n    exact le_of_tendsto_of_tendsto' tendsto_const_nhds C fun n => (A n).trans (B n)\n  · refine (pairwiseDisjoint_iUnion ?_).2 fun n => (Pu n).1\n    apply (monotone_nat_of_le_succ fun n => ?_).directed_le\n    rw [← Nat.succ_eq_add_one, u_succ]\n    exact (hF (u n) (Pu n)).1\n\n"}
{"name":"Besicovitch.exists_disjoint_closedBall_covering_ae_aux","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁵ : MetricSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : HasBesicovitchCovering α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → Set Real\ns : Set α\nhf : ∀ (x : α), Membership.mem s x → ∀ (δ : Real), GT.gt δ 0 → (Inter.inter (f x) (Set.Ioo 0 δ)).Nonempty\n⊢ Exists fun t => And t.Countable (And (∀ (p : Prod α Real), Membership.mem t p → Membership.mem s p.1) (And (∀ (p : Prod α Real), Membership.mem t p → Membership.mem (f p.1) p.2) (And (Eq (μ (SDiff.sdiff s (Set.iUnion fun p => Set.iUnion fun x => Metric.closedBall p.1 p.2))) 0) (t.PairwiseDisjoint fun p => Metric.closedBall p.1 p.2))))","decl":"/-- The measurable **Besicovitch covering theorem**.\n\nAssume that, for any `x` in a set `s`, one is given a set of admissible closed balls centered at\n`x`, with arbitrarily small radii. Then there exists a disjoint covering of almost all `s` by\nadmissible closed balls centered at some points of `s`.\n\nThis version requires the underlying measure to be sigma-finite, and the space to have the\nBesicovitch covering property (which is satisfied for instance by normed real vector spaces).\nIt expresses the conclusion in a slightly awkward form (with a subset of `α × ℝ`) coming from the\nproof technique.\n\nFor a version giving the conclusion in a nicer form, see `exists_disjoint_closedBall_covering_ae`.\n-/\ntheorem exists_disjoint_closedBall_covering_ae_aux (μ : Measure α) [SFinite μ] (f : α → Set ℝ)\n    (s : Set α) (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :\n    ∃ t : Set (α × ℝ), t.Countable ∧ (∀ p ∈ t, p.1 ∈ s) ∧ (∀ p ∈ t, p.2 ∈ f p.1) ∧\n      μ (s \\ ⋃ (p : α × ℝ) (_ : p ∈ t), closedBall p.1 p.2) = 0 ∧\n        t.PairwiseDisjoint fun p => closedBall p.1 p.2 := by\n  /- This is deduced from the finite measure case, by using a finite measure with respect to which\n    the initial sigma-finite measure is absolutely continuous. -/\n  rcases exists_isFiniteMeasure_absolutelyContinuous μ with ⟨ν, hν, hμν, -⟩\n  rcases exists_disjoint_closedBall_covering_ae_of_finiteMeasure_aux ν f s hf with\n    ⟨t, t_count, ts, tr, tν, tdisj⟩\n  exact ⟨t, t_count, ts, tr, hμν tν, tdisj⟩\n\n"}
{"name":"Besicovitch.exists_disjoint_closedBall_covering_ae","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁵ : MetricSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : HasBesicovitchCovering α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → Set Real\ns : Set α\nhf : ∀ (x : α), Membership.mem s x → ∀ (δ : Real), GT.gt δ 0 → (Inter.inter (f x) (Set.Ioo 0 δ)).Nonempty\nR : α → Real\nhR : ∀ (x : α), Membership.mem s x → LT.lt 0 (R x)\n⊢ Exists fun t => Exists fun r => And t.Countable (And (HasSubset.Subset t s) (And (∀ (x : α), Membership.mem t x → Membership.mem (Inter.inter (f x) (Set.Ioo 0 (R x))) (r x)) (And (Eq (μ (SDiff.sdiff s (Set.iUnion fun x => Set.iUnion fun h => Metric.closedBall x (r x)))) 0) (t.PairwiseDisjoint fun x => Metric.closedBall x (r x)))))","decl":"/-- The measurable **Besicovitch covering theorem**.\n\nAssume that, for any `x` in a set `s`, one is given a set of admissible closed balls centered at\n`x`, with arbitrarily small radii. Then there exists a disjoint covering of almost all `s` by\nadmissible closed balls centered at some points of `s`. We can even require that the radius at `x`\nis bounded by a given function `R x`. (Take `R = 1` if you don't need this additional feature).\n\nThis version requires the underlying measure to be sigma-finite, and the space to have the\nBesicovitch covering property (which is satisfied for instance by normed real vector spaces).\n-/\ntheorem exists_disjoint_closedBall_covering_ae (μ : Measure α) [SFinite μ] (f : α → Set ℝ)\n    (s : Set α) (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) (R : α → ℝ)\n    (hR : ∀ x ∈ s, 0 < R x) :\n    ∃ (t : Set α) (r : α → ℝ), t.Countable ∧ t ⊆ s ∧\n      (∀ x ∈ t, r x ∈ f x ∩ Ioo 0 (R x)) ∧ μ (s \\ ⋃ x ∈ t, closedBall x (r x)) = 0 ∧\n        t.PairwiseDisjoint fun x => closedBall x (r x) := by\n  let g x := f x ∩ Ioo 0 (R x)\n  have hg : ∀ x ∈ s, ∀ δ > 0, (g x ∩ Ioo 0 δ).Nonempty := fun x hx δ δpos ↦ by\n    rcases hf x hx (min δ (R x)) (lt_min δpos (hR x hx)) with ⟨r, hr⟩\n    exact ⟨r, ⟨⟨hr.1, hr.2.1, hr.2.2.trans_le (min_le_right _ _)⟩,\n      ⟨hr.2.1, hr.2.2.trans_le (min_le_left _ _)⟩⟩⟩\n  rcases exists_disjoint_closedBall_covering_ae_aux μ g s hg with ⟨v, v_count, vs, vg, μv, v_disj⟩\n  obtain ⟨r, t, rfl⟩ : ∃ (r : α → ℝ) (t : Set α), v = graphOn r t := by\n    have I : ∀ p ∈ v, 0 ≤ p.2 := fun p hp => (vg p hp).2.1.le\n    rw [exists_eq_graphOn]\n    refine fun x hx y hy heq ↦ v_disj.eq hx hy <| not_disjoint_iff.2 ⟨x.1, ?_⟩\n    simp [*]\n  have hinj : InjOn (fun x ↦ (x, r x)) t := LeftInvOn.injOn (f₁' := Prod.fst) fun _ _ ↦ rfl\n  simp only [graphOn, forall_mem_image, biUnion_image, hinj.pairwiseDisjoint_image] at *\n  exact ⟨t, r, countable_of_injective_of_countable_image hinj v_count, vs, vg, μv, v_disj⟩\n\n"}
{"name":"Besicovitch.exists_closedBall_covering_tsum_measure_le","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁶ : MetricSpace α\ninst✝⁵ : SecondCountableTopology α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : OpensMeasurableSpace α\ninst✝² : HasBesicovitchCovering α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SFinite μ\ninst✝ : μ.OuterRegular\nε : ENNReal\nhε : Ne ε 0\nf : α → Set Real\ns : Set α\nhf : ∀ (x : α), Membership.mem s x → ∀ (δ : Real), GT.gt δ 0 → (Inter.inter (f x) (Set.Ioo 0 δ)).Nonempty\n⊢ Exists fun t => Exists fun r => And t.Countable (And (HasSubset.Subset t s) (And (∀ (x : α), Membership.mem t x → Membership.mem (f x) (r x)) (And (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => Metric.closedBall x (r x))) (LE.le (tsum fun x => μ (Metric.closedBall (↑x) (r ↑x))) (HAdd.hAdd (μ s) ε)))))","decl":"/-- In a space with the Besicovitch property, any set `s` can be covered with balls whose measures\nadd up to at most `μ s + ε`, for any positive `ε`. This works even if one restricts the set of\nallowed radii around a point `x` to a set `f x` which accumulates at `0`. -/\ntheorem exists_closedBall_covering_tsum_measure_le (μ : Measure α) [SFinite μ]\n    [Measure.OuterRegular μ] {ε : ℝ≥0∞} (hε : ε ≠ 0) (f : α → Set ℝ) (s : Set α)\n    (hf : ∀ x ∈ s, ∀ δ > 0, (f x ∩ Ioo 0 δ).Nonempty) :\n    ∃ (t : Set α) (r : α → ℝ), t.Countable ∧ t ⊆ s ∧ (∀ x ∈ t, r x ∈ f x) ∧\n      (s ⊆ ⋃ x ∈ t, closedBall x (r x)) ∧ (∑' x : t, μ (closedBall x (r x))) ≤ μ s + ε := by\n  /- For the proof, first cover almost all `s` with disjoint balls thanks to the usual Besicovitch\n    theorem. Taking the balls included in a well-chosen open neighborhood `u` of `s`, one may\n    ensure that their measures add at most to `μ s + ε / 2`. Let `s'` be the remaining set, of\n    measure `0`. Applying the other version of Besicovitch, one may cover it with at most `N`\n    disjoint subfamilies. Making sure that they are all included in a neighborhood `v` of `s'` of\n    measure at most `ε / (2 N)`, the sum of their measures is at most `ε / 2`,\n    completing the proof. -/\n  classical\n  obtain ⟨u, su, u_open, μu⟩ : ∃ U, U ⊇ s ∧ IsOpen U ∧ μ U ≤ μ s + ε / 2 :=\n    Set.exists_isOpen_le_add _ _\n      (by\n        simpa only [or_false, Ne, ENNReal.div_eq_zero_iff, ENNReal.ofNat_ne_top] using hε)\n  have : ∀ x ∈ s, ∃ R > 0, ball x R ⊆ u := fun x hx =>\n    Metric.mem_nhds_iff.1 (u_open.mem_nhds (su hx))\n  choose! R hR using this\n  obtain ⟨t0, r0, t0_count, t0s, hr0, μt0, t0_disj⟩ :\n    ∃ (t0 : Set α) (r0 : α → ℝ), t0.Countable ∧ t0 ⊆ s ∧\n      (∀ x ∈ t0, r0 x ∈ f x ∩ Ioo 0 (R x)) ∧ μ (s \\ ⋃ x ∈ t0, closedBall x (r0 x)) = 0 ∧\n        t0.PairwiseDisjoint fun x => closedBall x (r0 x) :=\n    exists_disjoint_closedBall_covering_ae μ f s hf R fun x hx => (hR x hx).1\n  -- we have constructed an almost everywhere covering of `s` by disjoint balls. Let `s'` be the\n  -- remaining set.\n  let s' := s \\ ⋃ x ∈ t0, closedBall x (r0 x)\n  have s's : s' ⊆ s := diff_subset\n  obtain ⟨N, τ, hτ, H⟩ : ∃ N τ, 1 < τ ∧ IsEmpty (Besicovitch.SatelliteConfig α N τ) :=\n    HasBesicovitchCovering.no_satelliteConfig\n  obtain ⟨v, s'v, v_open, μv⟩ : ∃ v, v ⊇ s' ∧ IsOpen v ∧ μ v ≤ μ s' + ε / 2 / N :=\n    Set.exists_isOpen_le_add _ _\n      (by simp only [ne_eq, ENNReal.div_eq_zero_iff, hε, ENNReal.ofNat_ne_top, or_self,\n          ENNReal.natCast_ne_top, not_false_eq_true])\n  have : ∀ x ∈ s', ∃ r1 ∈ f x ∩ Ioo (0 : ℝ) 1, closedBall x r1 ⊆ v := by\n    intro x hx\n    rcases Metric.mem_nhds_iff.1 (v_open.mem_nhds (s'v hx)) with ⟨r, rpos, hr⟩\n    rcases hf x (s's hx) (min r 1) (lt_min rpos zero_lt_one) with ⟨R', hR'⟩\n    exact\n      ⟨R', ⟨hR'.1, hR'.2.1, hR'.2.2.trans_le (min_le_right _ _)⟩,\n        Subset.trans (closedBall_subset_ball (hR'.2.2.trans_le (min_le_left _ _))) hr⟩\n  choose! r1 hr1 using this\n  let q : BallPackage s' α :=\n    { c := fun x => x\n      r := fun x => r1 x\n      rpos := fun x => (hr1 x.1 x.2).1.2.1\n      r_bound := 1\n      r_le := fun x => (hr1 x.1 x.2).1.2.2.le }\n  -- by Besicovitch, we cover `s'` with at most `N` families of disjoint balls, all included in\n  -- a suitable neighborhood `v` of `s'`.\n  obtain ⟨S, S_disj, hS⟩ :\n    ∃ S : Fin N → Set s',\n      (∀ i : Fin N, (S i).PairwiseDisjoint fun j => closedBall (q.c j) (q.r j)) ∧\n        range q.c ⊆ ⋃ i : Fin N, ⋃ j ∈ S i, ball (q.c j) (q.r j) :=\n    exist_disjoint_covering_families hτ H q\n  have S_count : ∀ i, (S i).Countable := by\n    intro i\n    apply (S_disj i).countable_of_nonempty_interior fun j _ => ?_\n    have : (ball (j : α) (r1 j)).Nonempty := nonempty_ball.2 (q.rpos _)\n    exact this.mono ball_subset_interior_closedBall\n  let r x := if x ∈ s' then r1 x else r0 x\n  have r_t0 : ∀ x ∈ t0, r x = r0 x := by\n    intro x hx\n    have : ¬x ∈ s' := by\n      simp only [s', not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and, not_lt, not_le,\n        mem_diff, not_forall]\n      intro _\n      refine ⟨x, hx, ?_⟩\n      rw [dist_self]\n      exact (hr0 x hx).2.1.le\n    simp only [r, if_neg this]\n  -- the desired covering set is given by the union of the families constructed in the first and\n  -- second steps.\n  refine ⟨t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i, r, ?_, ?_, ?_, ?_, ?_⟩\n  -- it remains to check that they have the desired properties\n  · exact t0_count.union (countable_iUnion fun i => (S_count i).image _)\n  · simp only [t0s, true_and, union_subset_iff, image_subset_iff, iUnion_subset_iff]\n    intro i x _\n    exact s's x.2\n  · intro x hx\n    cases hx with\n    | inl hx =>\n      rw [r_t0 x hx]\n      exact (hr0 _ hx).1\n    | inr hx =>\n      have h'x : x ∈ s' := by\n        simp only [mem_iUnion, mem_image] at hx\n        rcases hx with ⟨i, y, _, rfl⟩\n        exact y.2\n      simp only [r, if_pos h'x, (hr1 x h'x).1.1]\n  · intro x hx\n    by_cases h'x : x ∈ s'\n    · obtain ⟨i, y, ySi, xy⟩ : ∃ (i : Fin N) (y : ↥s'), y ∈ S i ∧ x ∈ ball (y : α) (r1 y) := by\n        have A : x ∈ range q.c := by\n          simpa only [q, not_exists, exists_prop, mem_iUnion, mem_closedBall, not_and,\n            not_le, mem_setOf_eq, Subtype.range_coe_subtype, mem_diff] using h'x\n        simpa only [mem_iUnion, mem_image, bex_def] using hS A\n      refine mem_iUnion₂.2 ⟨y, Or.inr ?_, ?_⟩\n      · simp only [mem_iUnion, mem_image]\n        exact ⟨i, y, ySi, rfl⟩\n      · have : (y : α) ∈ s' := y.2\n        simp only [r, if_pos this]\n        exact ball_subset_closedBall xy\n    · obtain ⟨y, yt0, hxy⟩ : ∃ y : α, y ∈ t0 ∧ x ∈ closedBall y (r0 y) := by\n        simpa [s', hx, -mem_closedBall] using h'x\n      refine mem_iUnion₂.2 ⟨y, Or.inl yt0, ?_⟩\n      rwa [r_t0 _ yt0]\n  -- the only nontrivial property is the measure control, which we check now\n  · -- the sets in the first step have measure at most `μ s + ε / 2`\n    have A : (∑' x : t0, μ (closedBall x (r x))) ≤ μ s + ε / 2 :=\n      calc\n        (∑' x : t0, μ (closedBall x (r x))) = ∑' x : t0, μ (closedBall x (r0 x)) := by\n          congr 1; ext x; rw [r_t0 x x.2]\n        _ = μ (⋃ x : t0, closedBall x (r0 x)) := by\n          haveI : Encodable t0 := t0_count.toEncodable\n          rw [measure_iUnion]\n          · exact (pairwise_subtype_iff_pairwise_set _ _).2 t0_disj\n          · exact fun i => measurableSet_closedBall\n        _ ≤ μ u := by\n          apply measure_mono\n          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]\n          intro x hx\n          apply Subset.trans (closedBall_subset_ball (hr0 x hx).2.2) (hR x (t0s hx)).2\n        _ ≤ μ s + ε / 2 := μu\n    -- each subfamily in the second step has measure at most `ε / (2 N)`.\n    have B : ∀ i : Fin N, (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) ≤ ε / 2 / N :=\n      fun i =>\n      calc\n        (∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x))) =\n            ∑' x : S i, μ (closedBall x (r x)) := by\n          have : InjOn ((↑) : s' → α) (S i) := Subtype.val_injective.injOn\n          let F : S i ≃ ((↑) : s' → α) '' S i := this.bijOn_image.equiv _\n          exact (F.tsum_eq fun x => μ (closedBall x (r x))).symm\n        _ = ∑' x : S i, μ (closedBall x (r1 x)) := by\n          congr 1; ext x; have : (x : α) ∈ s' := x.1.2; simp only [s', r, if_pos this]\n        _ = μ (⋃ x : S i, closedBall x (r1 x)) := by\n          haveI : Encodable (S i) := (S_count i).toEncodable\n          rw [measure_iUnion]\n          · exact (pairwise_subtype_iff_pairwise_set _ _).2 (S_disj i)\n          · exact fun i => measurableSet_closedBall\n        _ ≤ μ v := by\n          apply measure_mono\n          simp only [SetCoe.forall, Subtype.coe_mk, iUnion_subset_iff]\n          intro x xs' _\n          exact (hr1 x xs').2\n        _ ≤ ε / 2 / N := by have : μ s' = 0 := μt0; rwa [this, zero_add] at μv\n    -- add up all these to prove the desired estimate\n    calc\n      (∑' x : ↥(t0 ∪ ⋃ i : Fin N, ((↑) : s' → α) '' S i), μ (closedBall x (r x))) ≤\n          (∑' x : t0, μ (closedBall x (r x))) +\n            ∑' x : ⋃ i : Fin N, ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=\n        ENNReal.tsum_union_le (fun x => μ (closedBall x (r x))) _ _\n      _ ≤\n          (∑' x : t0, μ (closedBall x (r x))) +\n            ∑ i : Fin N, ∑' x : ((↑) : s' → α) '' S i, μ (closedBall x (r x)) :=\n        (add_le_add le_rfl (ENNReal.tsum_iUnion_le (fun x => μ (closedBall x (r x))) _))\n      _ ≤ μ s + ε / 2 + ∑ i : Fin N, ε / 2 / N := by\n        gcongr\n        apply B\n      _ ≤ μ s + ε / 2 + ε / 2 := by\n        gcongr\n        simp only [Finset.card_fin, Finset.sum_const, nsmul_eq_mul, ENNReal.mul_div_le]\n      _ = μ s + ε := by rw [add_assoc, ENNReal.add_halves]\n\n"}
{"name":"Besicovitch.tendsto_filterAt","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"α : Type u_1\ninst✝⁵ : MetricSpace α\ninst✝⁴ : SecondCountableTopology α\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : HasBesicovitchCovering α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nx : α\n⊢ Filter.Tendsto (fun r => Metric.closedBall x r) (nhdsWithin 0 (Set.Ioi 0)) ((Besicovitch.vitaliFamily μ).filterAt x)","decl":"/-- The main feature of the Besicovitch Vitali family is that its filter at a point `x` corresponds\nto convergence along closed balls. We record one of the two implications here, which will enable us\nto deduce specific statements on differentiation of measures in this context from the general\nversions. -/\ntheorem tendsto_filterAt (μ : Measure α) [SFinite μ] (x : α) :\n    Tendsto (fun r => closedBall x r) (𝓝[>] 0) ((Besicovitch.vitaliFamily μ).filterAt x) := by\n  intro s hs\n  simp only [mem_map]\n  obtain ⟨ε, εpos, hε⟩ :\n    ∃ (ε : ℝ), ε > 0 ∧\n      ∀ a : Set α, a ∈ (Besicovitch.vitaliFamily μ).setsAt x → a ⊆ closedBall x ε → a ∈ s :=\n    (VitaliFamily.mem_filterAt_iff _).1 hs\n  filter_upwards [Ioc_mem_nhdsGT εpos] with _r hr\n  apply hε\n  · exact mem_image_of_mem _ hr.1\n  · exact closedBall_subset_closedBall hr.2\n\n"}
{"name":"Besicovitch.ae_tendsto_rnDeriv","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u\ninst✝⁶ : MetricSpace β\ninst✝⁵ : MeasurableSpace β\ninst✝⁴ : BorelSpace β\ninst✝³ : SecondCountableTopology β\ninst✝² : HasBesicovitchCovering β\nρ μ : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure ρ\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun r => HDiv.hDiv (ρ (Metric.closedBall x r)) (μ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds (ρ.rnDeriv μ x))) (MeasureTheory.ae μ)","decl":"/-- In a space with the Besicovitch covering property, the ratio of the measure of balls converges\nalmost surely to the Radon-Nikodym derivative. -/\ntheorem ae_tendsto_rnDeriv (ρ μ : Measure β) [IsLocallyFiniteMeasure μ] [IsLocallyFiniteMeasure ρ] :\n    ∀ᵐ x ∂μ,\n      Tendsto (fun r => ρ (closedBall x r) / μ (closedBall x r)) (𝓝[>] 0) (𝓝 (ρ.rnDeriv μ x)) := by\n  filter_upwards [VitaliFamily.ae_tendsto_rnDeriv (Besicovitch.vitaliFamily μ) ρ] with x hx\n  exact hx.comp (tendsto_filterAt μ x)\n\n"}
{"name":"Besicovitch.ae_tendsto_measure_inter_div_of_measurableSet","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u\ninst✝⁵ : MetricSpace β\ninst✝⁴ : MeasurableSpace β\ninst✝³ : BorelSpace β\ninst✝² : SecondCountableTopology β\ninst✝¹ : HasBesicovitchCovering β\nμ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\ns : Set β\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun r => HDiv.hDiv (μ (Inter.inter s (Metric.closedBall x r))) (μ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds (s.indicator 1 x))) (MeasureTheory.ae μ)","decl":"/-- Given a measurable set `s`, then `μ (s ∩ closedBall x r) / μ (closedBall x r)` converges when\n`r` tends to `0`, for almost every `x`. The limit is `1` for `x ∈ s` and `0` for `x ∉ s`.\nThis shows that almost every point of `s` is a Lebesgue density point for `s`.\nA version for non-measurable sets holds, but it only gives the first conclusion,\nsee `ae_tendsto_measure_inter_div`. -/\ntheorem ae_tendsto_measure_inter_div_of_measurableSet (μ : Measure β) [IsLocallyFiniteMeasure μ]\n    {s : Set β} (hs : MeasurableSet s) :\n    ∀ᵐ x ∂μ,\n      Tendsto (fun r => μ (s ∩ closedBall x r) / μ (closedBall x r)) (𝓝[>] 0)\n        (𝓝 (s.indicator 1 x)) := by\n  filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div_of_measurableSet\n      (Besicovitch.vitaliFamily μ) hs]\n  intro x hx\n  exact hx.comp (tendsto_filterAt μ x)\n\n"}
{"name":"Besicovitch.ae_tendsto_measure_inter_div","module":"Mathlib.MeasureTheory.Covering.Besicovitch","initialProofState":"β : Type u\ninst✝⁵ : MetricSpace β\ninst✝⁴ : MeasurableSpace β\ninst✝³ : BorelSpace β\ninst✝² : SecondCountableTopology β\ninst✝¹ : HasBesicovitchCovering β\nμ : MeasureTheory.Measure β\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\ns : Set β\n⊢ Filter.Eventually (fun x => Filter.Tendsto (fun r => HDiv.hDiv (μ (Inter.inter s (Metric.closedBall x r))) (μ (Metric.closedBall x r))) (nhdsWithin 0 (Set.Ioi 0)) (nhds 1)) (MeasureTheory.ae (μ.restrict s))","decl":"/-- Given an arbitrary set `s`, then `μ (s ∩ closedBall x r) / μ (closedBall x r)` converges\nto `1` when `r` tends to `0`, for almost every `x` in `s`.\nThis shows that almost every point of `s` is a Lebesgue density point for `s`.\nA stronger version holds for measurable sets, see `ae_tendsto_measure_inter_div_of_measurableSet`.\n\nSee also `IsUnifLocDoublingMeasure.ae_tendsto_measure_inter_div`. -/\ntheorem ae_tendsto_measure_inter_div (μ : Measure β) [IsLocallyFiniteMeasure μ] (s : Set β) :\n    ∀ᵐ x ∂μ.restrict s,\n      Tendsto (fun r => μ (s ∩ closedBall x r) / μ (closedBall x r)) (𝓝[>] 0) (𝓝 1) := by\n  filter_upwards [VitaliFamily.ae_tendsto_measure_inter_div (Besicovitch.vitaliFamily μ) s] with x\n    hx using hx.comp (tendsto_filterAt μ x)\n\n"}
