{"name":"DFA.mk.sizeOf_spec","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\ninst✝¹ : SizeOf α\ninst✝ : SizeOf σ\nstep : σ → α → σ\nstart : σ\naccept : Set σ\n⊢ Eq (SizeOf.sizeOf { step := step, start := start, accept := accept }) (HAdd.hAdd 1 (SizeOf.sizeOf start))","decl":"/-- A DFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`). -/\nstructure DFA (α : Type u) (σ : Type v) where\n  /-- A transition function from state to state labelled by the alphabet. -/\n  step : σ → α → σ\n  /-- Starting state. -/\n  start : σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"DFA.mk.inj","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → α → σ\nstart✝ : σ\naccept✝ : Set σ\nstep : σ → α → σ\nstart : σ\naccept : Set σ\nx✝ : Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }\n⊢ And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept))","decl":"/-- A DFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`). -/\nstructure DFA (α : Type u) (σ : Type v) where\n  /-- A transition function from state to state labelled by the alphabet. -/\n  step : σ → α → σ\n  /-- Starting state. -/\n  start : σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"DFA.mk.injEq","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nstep✝ : σ → α → σ\nstart✝ : σ\naccept✝ : Set σ\nstep : σ → α → σ\nstart : σ\naccept : Set σ\n⊢ Eq (Eq { step := step✝, start := start✝, accept := accept✝ } { step := step, start := start, accept := accept }) (And (Eq step✝ step) (And (Eq start✝ start) (Eq accept✝ accept)))","decl":"/-- A DFA is a set of states (`σ`), a transition function from state to state labelled by the\n  alphabet (`step`), a starting state (`start`) and a set of acceptance states (`accept`). -/\nstructure DFA (α : Type u) (σ : Type v) where\n  /-- A transition function from state to state labelled by the alphabet. -/\n  step : σ → α → σ\n  /-- Starting state. -/\n  start : σ\n  /-- Set of acceptance states. -/\n  accept : Set σ\n\n"}
{"name":"DFA.evalFrom_nil","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ns : σ\n⊢ Eq (M.evalFrom s List.nil) s","decl":"@[simp]\ntheorem evalFrom_nil (s : σ) : M.evalFrom s [] = s :=\n  rfl\n\n"}
{"name":"DFA.evalFrom_singleton","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ns : σ\na : α\n⊢ Eq (M.evalFrom s (List.cons a List.nil)) (M.step s a)","decl":"@[simp]\ntheorem evalFrom_singleton (s : σ) (a : α) : M.evalFrom s [a] = M.step s a :=\n  rfl\n\n"}
{"name":"DFA.evalFrom_append_singleton","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ns : σ\nx : List α\na : α\n⊢ Eq (M.evalFrom s (HAppend.hAppend x (List.cons a List.nil))) (M.step (M.evalFrom s x) a)","decl":"@[simp]\ntheorem evalFrom_append_singleton (s : σ) (x : List α) (a : α) :\n    M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a := by\n  simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\n\n"}
{"name":"DFA.eval_nil","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\n⊢ Eq (M.eval List.nil) M.start","decl":"@[simp]\ntheorem eval_nil : M.eval [] = M.start :=\n  rfl\n\n"}
{"name":"DFA.eval_singleton","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\na : α\n⊢ Eq (M.eval (List.cons a List.nil)) (M.step M.start a)","decl":"@[simp]\ntheorem eval_singleton (a : α) : M.eval [a] = M.step M.start a :=\n  rfl\n\n"}
{"name":"DFA.eval_append_singleton","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nx : List α\na : α\n⊢ Eq (M.eval (HAppend.hAppend x (List.cons a List.nil))) (M.step (M.eval x) a)","decl":"@[simp]\ntheorem eval_append_singleton (x : List α) (a : α) : M.eval (x ++ [a]) = M.step (M.eval x) a :=\n  evalFrom_append_singleton _ _ _ _\n\n"}
{"name":"DFA.evalFrom_of_append","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nstart : σ\nx y : List α\n⊢ Eq (M.evalFrom start (HAppend.hAppend x y)) (M.evalFrom (M.evalFrom start x) y)","decl":"theorem evalFrom_of_append (start : σ) (x y : List α) :\n    M.evalFrom start (x ++ y) = M.evalFrom (M.evalFrom start x) y :=\n  x.foldl_append _ _ y\n\n"}
{"name":"DFA.mem_acceptsFrom","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ns : σ\nx : List α\n⊢ Iff (Membership.mem (M.acceptsFrom s) x) (Membership.mem M.accept (M.evalFrom s x))","decl":"theorem mem_acceptsFrom {s : σ} {x : List α} :\n    x ∈ M.acceptsFrom s ↔ M.evalFrom s x ∈ M.accept := by rfl\n\n"}
{"name":"DFA.mem_accepts","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nx : List α\n⊢ Iff (Membership.mem M.accepts x) (Membership.mem M.accept (M.eval x))","decl":"theorem mem_accepts {x : List α} : x ∈ M.accepts ↔ M.eval x ∈ M.accept := by rfl\n\n"}
{"name":"DFA.evalFrom_split","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ninst✝ : Fintype σ\nx : List α\ns t : σ\nhlen : LE.le (Fintype.card σ) x.length\nhx : Eq (M.evalFrom s x) t\n⊢ Exists fun q => Exists fun a => Exists fun b => Exists fun c => And (Eq x (HAppend.hAppend (HAppend.hAppend a b) c)) (And (LE.le (HAdd.hAdd a.length b.length) (Fintype.card σ)) (And (Ne b List.nil) (And (Eq (M.evalFrom s a) q) (And (Eq (M.evalFrom q b) q) (Eq (M.evalFrom q c) t)))))","decl":"theorem evalFrom_split [Fintype σ] {x : List α} {s t : σ} (hlen : Fintype.card σ ≤ x.length)\n    (hx : M.evalFrom s x = t) :\n    ∃ q a b c,\n      x = a ++ b ++ c ∧\n        a.length + b.length ≤ Fintype.card σ ∧\n          b ≠ [] ∧ M.evalFrom s a = q ∧ M.evalFrom q b = q ∧ M.evalFrom q c = t := by\n  obtain ⟨n, m, hneq, heq⟩ :=\n    Fintype.exists_ne_map_eq_of_card_lt\n      (fun n : Fin (Fintype.card σ + 1) => M.evalFrom s (x.take n)) (by norm_num)\n  wlog hle : (n : ℕ) ≤ m generalizing n m\n  · exact this m n hneq.symm heq.symm (le_of_not_le hle)\n  have hm : (m : ℕ) ≤ Fintype.card σ := Fin.is_le m\n  refine\n    ⟨M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n,\n                    x.drop m, ?_, ?_, ?_, by rfl, ?_⟩\n  · rw [List.take_append_drop, List.take_append_drop]\n  · simp only [List.length_drop, List.length_take]\n    rw [min_eq_left (hm.trans hlen), min_eq_left hle, add_tsub_cancel_of_le hle]\n    exact hm\n  · intro h\n    have hlen' := congr_arg List.length h\n    simp only [List.length_drop, List.length, List.length_take] at hlen'\n    rw [min_eq_left, tsub_eq_zero_iff_le] at hlen'\n    · apply hneq\n      apply le_antisymm\n      assumption'\n    exact hm.trans hlen\n  have hq : M.evalFrom (M.evalFrom s ((x.take m).take n)) ((x.take m).drop n) =\n      M.evalFrom s ((x.take m).take n) := by\n    rw [List.take_take, min_eq_left hle, ← evalFrom_of_append, heq, ← min_eq_left hle, ←\n      List.take_take, min_eq_left hle, List.take_append_drop]\n  use hq\n  rwa [← hq, ← evalFrom_of_append, ← evalFrom_of_append, ← List.append_assoc,\n    List.take_append_drop, List.take_append_drop]\n\n"}
{"name":"DFA.evalFrom_of_pow","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nx y : List α\ns : σ\nhx : Eq (M.evalFrom s x) s\nhy : Membership.mem (KStar.kstar (Singleton.singleton x)) y\n⊢ Eq (M.evalFrom s y) s","decl":"theorem evalFrom_of_pow {x y : List α} {s : σ} (hx : M.evalFrom s x = s)\n    (hy : y ∈ ({x} : Language α)∗) : M.evalFrom s y = s := by\n  rw [Language.mem_kstar] at hy\n  rcases hy with ⟨S, rfl, hS⟩\n  induction' S with a S ih\n  · rfl\n  · have ha := hS a (List.mem_cons_self _ _)\n    rw [Set.mem_singleton_iff] at ha\n    rw [List.flatten, evalFrom_of_append, ha, hx]\n    apply ih\n    intro z hz\n    exact hS z (List.mem_cons_of_mem a hz)\n\n"}
{"name":"DFA.pumping_lemma","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\ninst✝ : Fintype σ\nx : List α\nhx : Membership.mem M.accepts x\nhlen : LE.le (Fintype.card σ) x.length\n⊢ Exists fun a => Exists fun b => Exists fun c => And (Eq x (HAppend.hAppend (HAppend.hAppend a b) c)) (And (LE.le (HAdd.hAdd a.length b.length) (Fintype.card σ)) (And (Ne b List.nil) (LE.le (HMul.hMul (HMul.hMul (Singleton.singleton a) (KStar.kstar (Singleton.singleton b))) (Singleton.singleton c)) M.accepts)))","decl":"theorem pumping_lemma [Fintype σ] {x : List α} (hx : x ∈ M.accepts)\n    (hlen : Fintype.card σ ≤ List.length x) :\n    ∃ a b c,\n      x = a ++ b ++ c ∧\n        a.length + b.length ≤ Fintype.card σ ∧ b ≠ [] ∧ {a} * {b}∗ * {c} ≤ M.accepts := by\n  obtain ⟨_, a, b, c, hx, hlen, hnil, rfl, hb, hc⟩ := M.evalFrom_split (s := M.start) hlen rfl\n  use a, b, c, hx, hlen, hnil\n  intro y hy\n  rw [Language.mem_mul] at hy\n  rcases hy with ⟨ab, hab, c', hc', rfl⟩\n  rw [Language.mem_mul] at hab\n  rcases hab with ⟨a', ha', b', hb', rfl⟩\n  rw [Set.mem_singleton_iff] at ha' hc'\n  substs ha' hc'\n  have h := M.evalFrom_of_pow hb hb'\n  rwa [mem_accepts, eval, evalFrom_of_append, evalFrom_of_append, h, hc]\n\n"}
{"name":"DFA.comap_accept","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nα' : Type u_1\nf : α' → α\nM : DFA α σ\n⊢ Eq (DFA.comap f M).accept M.accept","decl":"/--\n`M.comap f` pulls back the alphabet of `M` along `f`. In other words, it applies `f` to the input\nbefore passing it to `M`.\n-/\n@[simps]\ndef comap (f : α' → α) (M : DFA α σ) : DFA α' σ where\n  step s a := M.step s (f a)\n  start := M.start\n  accept := M.accept\n\n"}
{"name":"DFA.comap_step","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nα' : Type u_1\nf : α' → α\nM : DFA α σ\ns : σ\na : α'\n⊢ Eq ((DFA.comap f M).step s a) (M.step s (f a))","decl":"/--\n`M.comap f` pulls back the alphabet of `M` along `f`. In other words, it applies `f` to the input\nbefore passing it to `M`.\n-/\n@[simps]\ndef comap (f : α' → α) (M : DFA α σ) : DFA α' σ where\n  step s a := M.step s (f a)\n  start := M.start\n  accept := M.accept\n\n"}
{"name":"DFA.comap_start","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nα' : Type u_1\nf : α' → α\nM : DFA α σ\n⊢ Eq (DFA.comap f M).start M.start","decl":"/--\n`M.comap f` pulls back the alphabet of `M` along `f`. In other words, it applies `f` to the input\nbefore passing it to `M`.\n-/\n@[simps]\ndef comap (f : α' → α) (M : DFA α σ) : DFA α' σ where\n  step s a := M.step s (f a)\n  start := M.start\n  accept := M.accept\n\n"}
{"name":"DFA.comap_id","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\n⊢ Eq (DFA.comap id M) M","decl":"@[simp]\ntheorem comap_id : M.comap id = M := rfl\n\n"}
{"name":"DFA.evalFrom_comap","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nα' : Type u_1\nf : α' → α\ns : σ\nx : List α'\n⊢ Eq ((DFA.comap f M).evalFrom s x) (M.evalFrom s (List.map f x))","decl":"@[simp]\ntheorem evalFrom_comap (f : α' → α) (s : σ) (x : List α') :\n    (M.comap f).evalFrom s x = M.evalFrom s (x.map f) := by\n  induction x using List.reverseRecOn with\n  | nil => simp\n  | append_singleton x a ih => simp [ih]\n\n"}
{"name":"DFA.eval_comap","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nα' : Type u_1\nf : α' → α\nx : List α'\n⊢ Eq ((DFA.comap f M).eval x) (M.eval (List.map f x))","decl":"@[simp]\ntheorem eval_comap (f : α' → α) (x : List α') : (M.comap f).eval x = M.eval (x.map f) := by\n  simp [eval]\n\n"}
{"name":"DFA.accepts_comap","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nα' : Type u_1\nf : α' → α\n⊢ Eq (DFA.comap f M).accepts (Set.preimage (List.map f) M.accepts)","decl":"@[simp]\ntheorem accepts_comap (f : α' → α) : (M.comap f).accepts = List.map f ⁻¹' M.accepts := by\n  ext x\n  conv =>\n    rhs\n    rw [Set.mem_preimage, mem_accepts]\n  simp [mem_accepts]\n\n"}
{"name":"DFA.reindex_apply_step","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nσ' : Type u_2\ng : Equiv σ σ'\nM : DFA α σ\ns : σ'\na : α\n⊢ Eq (((DFA.reindex g) M).step s a) (g (M.step (g.symm s) a))","decl":"/-- Lifts an equivalence on states to an equivalence on DFAs. -/\n@[simps apply_step apply_start apply_accept]\ndef reindex (g : σ ≃ σ') : DFA α σ ≃ DFA α σ' where\n  toFun M := {\n    step := fun s a => g (M.step (g.symm s) a)\n    start := g M.start\n    accept := g.symm ⁻¹' M.accept\n  }\n  invFun M := {\n    step := fun s a => g.symm (M.step (g s) a)\n    start := g.symm M.start\n    accept := g ⁻¹' M.accept\n  }\n  left_inv M := by simp\n  right_inv M := by simp\n\n"}
{"name":"DFA.reindex_apply_accept","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nσ' : Type u_2\ng : Equiv σ σ'\nM : DFA α σ\n⊢ Eq ((DFA.reindex g) M).accept (Set.preimage (⇑g.symm) M.accept)","decl":"/-- Lifts an equivalence on states to an equivalence on DFAs. -/\n@[simps apply_step apply_start apply_accept]\ndef reindex (g : σ ≃ σ') : DFA α σ ≃ DFA α σ' where\n  toFun M := {\n    step := fun s a => g (M.step (g.symm s) a)\n    start := g M.start\n    accept := g.symm ⁻¹' M.accept\n  }\n  invFun M := {\n    step := fun s a => g.symm (M.step (g s) a)\n    start := g.symm M.start\n    accept := g ⁻¹' M.accept\n  }\n  left_inv M := by simp\n  right_inv M := by simp\n\n"}
{"name":"DFA.reindex_apply_start","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nσ' : Type u_2\ng : Equiv σ σ'\nM : DFA α σ\n⊢ Eq ((DFA.reindex g) M).start (g M.start)","decl":"/-- Lifts an equivalence on states to an equivalence on DFAs. -/\n@[simps apply_step apply_start apply_accept]\ndef reindex (g : σ ≃ σ') : DFA α σ ≃ DFA α σ' where\n  toFun M := {\n    step := fun s a => g (M.step (g.symm s) a)\n    start := g M.start\n    accept := g.symm ⁻¹' M.accept\n  }\n  invFun M := {\n    step := fun s a => g.symm (M.step (g s) a)\n    start := g.symm M.start\n    accept := g ⁻¹' M.accept\n  }\n  left_inv M := by simp\n  right_inv M := by simp\n\n"}
{"name":"DFA.reindex_refl","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\n⊢ Eq ((DFA.reindex (Equiv.refl σ)) M) M","decl":"@[simp]\ntheorem reindex_refl : reindex (Equiv.refl σ) M = M := rfl\n\n"}
{"name":"DFA.symm_reindex","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nσ' : Type u_2\ng : Equiv σ σ'\n⊢ Eq (DFA.reindex g).symm (DFA.reindex g.symm)","decl":"@[simp]\ntheorem symm_reindex (g : σ ≃ σ') : (reindex (α := α) g).symm = reindex g.symm := rfl\n\n"}
{"name":"DFA.evalFrom_reindex","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nσ' : Type u_2\ng : Equiv σ σ'\ns : σ'\nx : List α\n⊢ Eq (((DFA.reindex g) M).evalFrom s x) (g (M.evalFrom (g.symm s) x))","decl":"@[simp]\ntheorem evalFrom_reindex (g : σ ≃ σ') (s : σ') (x : List α) :\n    (reindex g M).evalFrom s x = g (M.evalFrom (g.symm s) x) := by\n  induction x using List.reverseRecOn with\n  | nil => simp\n  | append_singleton x a ih => simp [ih]\n\n"}
{"name":"DFA.eval_reindex","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nσ' : Type u_2\ng : Equiv σ σ'\nx : List α\n⊢ Eq (((DFA.reindex g) M).eval x) (g (M.eval x))","decl":"@[simp]\ntheorem eval_reindex (g : σ ≃ σ') (x : List α) : (reindex g M).eval x = g (M.eval x) := by\n  simp [eval]\n\n"}
{"name":"DFA.accepts_reindex","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nσ' : Type u_2\ng : Equiv σ σ'\n⊢ Eq ((DFA.reindex g) M).accepts M.accepts","decl":"@[simp]\ntheorem accepts_reindex (g : σ ≃ σ') : (reindex g M).accepts = M.accepts := by\n  ext x\n  simp [mem_accepts]\n\n"}
{"name":"DFA.comap_reindex","module":"Mathlib.Computability.DFA","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nα' : Type u_1\nσ' : Type u_2\nf : α' → α\ng : Equiv σ σ'\n⊢ Eq (DFA.comap f ((DFA.reindex g) M)) ((DFA.reindex g) (DFA.comap f M))","decl":"theorem comap_reindex (f : α' → α) (g : σ ≃ σ') :\n    (reindex g M).comap f = reindex g (M.comap f) := by\n  simp [comap, reindex]\n\n"}
{"name":"Language.isRegular_iff","module":"Mathlib.Computability.DFA","initialProofState":"T : Type u\nL : Language T\n⊢ Iff L.IsRegular (Exists fun σ => Exists fun x => Exists fun M => Eq M.accepts L)","decl":"/--\nA language is regular if and only if it is defined by a DFA with finite states.\n\nThis is more general than using the definition of `Language.IsRegular` directly, as the state type\n`σ` is universe-polymorphic.\n-/\ntheorem Language.isRegular_iff {T : Type u} {L : Language T} :\n    L.IsRegular ↔ ∃ σ : Type v, ∃ _ : Fintype σ, ∃ M : DFA T σ, M.accepts = L :=\n  ⟨Language.isRegular_iff.helper, Language.isRegular_iff.helper⟩\n"}
