{"name":"LinearEquiv.restrictScalars_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nf : LinearEquiv (RingHom.id S) M M₂\na : M₂\n⊢ Eq ((LinearEquiv.restrictScalars R f).symm a) (f.symm a)","decl":"/-- If `M` and `M₂` are both `R`-semimodules and `S`-semimodules and `R`-semimodule structures\nare defined by an action of `R` on `S` (formally, we have two scalar towers), then any `S`-linear\nequivalence from `M` to `M₂` is also an `R`-linear equivalence.\n\nSee also `LinearMap.restrictScalars`. -/\n@[simps]\ndef restrictScalars (f : M ≃ₗ[S] M₂) : M ≃ₗ[R] M₂ :=\n  { f.toLinearMap.restrictScalars R with\n    toFun := f\n    invFun := f.symm\n    left_inv := f.left_inv\n    right_inv := f.right_inv }\n\n"}
{"name":"LinearEquiv.restrictScalars_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nf : LinearEquiv (RingHom.id S) M M₂\na : M\n⊢ Eq ((LinearEquiv.restrictScalars R f) a) (f a)","decl":"/-- If `M` and `M₂` are both `R`-semimodules and `S`-semimodules and `R`-semimodule structures\nare defined by an action of `R` on `S` (formally, we have two scalar towers), then any `S`-linear\nequivalence from `M` to `M₂` is also an `R`-linear equivalence.\n\nSee also `LinearMap.restrictScalars`. -/\n@[simps]\ndef restrictScalars (f : M ≃ₗ[S] M₂) : M ≃ₗ[R] M₂ :=\n  { f.toLinearMap.restrictScalars R with\n    toFun := f\n    invFun := f.symm\n    left_inv := f.left_inv\n    right_inv := f.right_inv }\n\n"}
{"name":"LinearEquiv.restrictScalars_injective","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\n⊢ Function.Injective (LinearEquiv.restrictScalars R)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (M ≃ₗ[S] M₂) → M ≃ₗ[R] M₂) := fun _ _ h ↦\n  ext (LinearEquiv.congr_fun h :)\n\n"}
{"name":"LinearEquiv.restrictScalars_inj","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\nM₂ : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M\ninst✝³ : Module R M₂\ninst✝² : Module S M\ninst✝¹ : Module S M₂\ninst✝ : LinearMap.CompatibleSMul M M₂ R S\nf g : LinearEquiv (RingHom.id S) M M₂\n⊢ Iff (Eq (LinearEquiv.restrictScalars R f) (LinearEquiv.restrictScalars R g)) (Eq f g)","decl":"@[simp]\ntheorem restrictScalars_inj (f g : M ≃ₗ[S] M₂) :\n    f.restrictScalars R = g.restrictScalars R ↔ f = g :=\n  (restrictScalars_injective R).eq_iff\n\n"}
{"name":"Module.End_isUnit_iff","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff (IsUnit f) (Function.Bijective ⇑f)","decl":"theorem _root_.Module.End_isUnit_iff [Module R M] (f : Module.End R M) :\n    IsUnit f ↔ Function.Bijective f :=\n  ⟨fun h ↦\n    Function.bijective_iff_has_inverse.mpr <|\n      ⟨h.unit.inv,\n        ⟨Module.End_isUnit_inv_apply_apply_of_isUnit h,\n        Module.End_isUnit_apply_inv_apply_of_isUnit h⟩⟩,\n    fun H ↦\n    let e : M ≃ₗ[R] M := { f, Equiv.ofBijective f H with }\n    ⟨⟨_, e.symm, LinearMap.ext e.right_inv, LinearMap.ext e.left_inv⟩, rfl⟩⟩\n\n"}
{"name":"LinearEquiv.coe_one","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (⇑1) id","decl":"@[simp]\nlemma coe_one : ↑(1 : M ≃ₗ[R] M) = id := rfl\n\n"}
{"name":"LinearEquiv.coe_toLinearMap_one","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (↑1) LinearMap.id","decl":"@[simp]\nlemma coe_toLinearMap_one : (↑(1 : M ≃ₗ[R] M) : M →ₗ[R] M) = LinearMap.id := rfl\n\n"}
{"name":"LinearEquiv.coe_toLinearMap_mul","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne₁ e₂ : LinearEquiv (RingHom.id R) M M\n⊢ Eq (↑(HMul.hMul e₁ e₂)) (HMul.hMul ↑e₁ ↑e₂)","decl":"@[simp]\nlemma coe_toLinearMap_mul {e₁ e₂ : M ≃ₗ[R] M} :\n    (↑(e₁ * e₂) : M →ₗ[R] M) = (e₁ : M →ₗ[R] M) * (e₂ : M →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_pow","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M M\nn : Nat\n⊢ Eq (⇑(HPow.hPow e n)) (Nat.iterate (⇑e) n)","decl":"theorem coe_pow (e : M ≃ₗ[R] M) (n : ℕ) : ⇑(e ^ n) = e^[n] := hom_coe_pow _ rfl (fun _ _ ↦ rfl) _ _\n\n"}
{"name":"LinearEquiv.pow_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M M\nn : Nat\nm : M\n⊢ Eq ((HPow.hPow e n) m) (Nat.iterate (⇑e) n m)","decl":"theorem pow_apply (e : M ≃ₗ[R] M) (n : ℕ) (m : M) : (e ^ n) m = e^[n] m := congr_fun (coe_pow e n) m\n\n"}
{"name":"LinearEquiv.mul_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearEquiv (RingHom.id R) M M\nx : M\n⊢ Eq ((HMul.hMul f g) x) (f (g x))","decl":"@[simp] lemma mul_apply (f : M ≃ₗ[R] M) (g : M ≃ₗ[R] M) (x : M) : (f * g) x = f (g x) := rfl\n\n"}
{"name":"LinearEquiv.automorphismGroup.toLinearMapMonoidHom_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M M\n⊢ Eq (LinearEquiv.automorphismGroup.toLinearMapMonoidHom e) ↑e","decl":"/-- Restriction from `R`-linear automorphisms of `M` to `R`-linear endomorphisms of `M`,\npromoted to a monoid hom. -/\n@[simps]\ndef automorphismGroup.toLinearMapMonoidHom : (M ≃ₗ[R] M) →* M →ₗ[R] M where\n  toFun e := e.toLinearMap\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"LinearEquiv.smul_def","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : LinearEquiv (RingHom.id R) M M\na : M\n⊢ Eq (HSMul.hSMul f a) (f a)","decl":"@[simp]\nprotected theorem smul_def (f : M ≃ₗ[R] M) (a : M) : f • a = f a :=\n  rfl\n\n"}
{"name":"LinearEquiv.apply_faithfulSMul","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ FaithfulSMul (LinearEquiv (RingHom.id R) M M) M","decl":"/-- `LinearEquiv.applyDistribMulAction` is faithful. -/\ninstance apply_faithfulSMul : FaithfulSMul (M ≃ₗ[R] M) M :=\n  ⟨LinearEquiv.ext⟩\n\n"}
{"name":"LinearEquiv.apply_smulCommClass","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass S (LinearEquiv (RingHom.id R) M M) M","decl":"instance apply_smulCommClass [SMul S R] [SMul S M] [IsScalarTower S R M] :\n    SMulCommClass S (M ≃ₗ[R] M) M where\n  smul_comm r e m := (e.map_smul_of_tower r m).symm\n\n"}
{"name":"LinearEquiv.apply_smulCommClass'","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SMul S R\ninst✝¹ : SMul S M\ninst✝ : IsScalarTower S R M\n⊢ SMulCommClass (LinearEquiv (RingHom.id R) M M) S M","decl":"instance apply_smulCommClass' [SMul S R] [SMul S M] [IsScalarTower S R M] :\n    SMulCommClass (M ≃ₗ[R] M) S M :=\n  SMulCommClass.symm _ _ _\n\n"}
{"name":"LinearEquiv.ofSubsingleton_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Subsingleton M\ninst✝ : Subsingleton M₂\nx✝ : M₂\n⊢ Eq ((LinearEquiv.ofSubsingleton M M₂).symm x✝) 0","decl":"/-- Any two modules that are subsingletons are isomorphic. -/\n@[simps]\ndef ofSubsingleton : M ≃ₗ[R] M₂ :=\n  { (0 : M →ₗ[R] M₂) with\n    toFun := fun _ ↦ 0\n    invFun := fun _ ↦ 0\n    left_inv := fun _ ↦ Subsingleton.elim _ _\n    right_inv := fun _ ↦ Subsingleton.elim _ _ }\n\n"}
{"name":"LinearEquiv.ofSubsingleton_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Subsingleton M\ninst✝ : Subsingleton M₂\nx✝ : M\n⊢ Eq ((LinearEquiv.ofSubsingleton M M₂) x✝) 0","decl":"/-- Any two modules that are subsingletons are isomorphic. -/\n@[simps]\ndef ofSubsingleton : M ≃ₗ[R] M₂ :=\n  { (0 : M →ₗ[R] M₂) with\n    toFun := fun _ ↦ 0\n    invFun := fun _ ↦ 0\n    left_inv := fun _ ↦ Subsingleton.elim _ _\n    right_inv := fun _ ↦ Subsingleton.elim _ _ }\n\n"}
{"name":"LinearEquiv.ofSubsingleton_self","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton M\n⊢ Eq (LinearEquiv.ofSubsingleton M M) (LinearEquiv.refl R M)","decl":"@[simp]\ntheorem ofSubsingleton_self : ofSubsingleton M M = refl R M := by\n  ext\n  simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Module.compHom.toLinearEquiv_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_9\nS : Type u_10\ninst✝¹ : Semiring R\ninst✝ : Semiring S\ng : RingEquiv R S\na : R\n⊢ Eq ((Module.compHom.toLinearEquiv g) a) (g a)","decl":"/-- `g : R ≃+* S` is `R`-linear when the module structure on `S` is `Module.compHom S g` . -/\n@[simps]\ndef compHom.toLinearEquiv {R S : Type*} [Semiring R] [Semiring S] (g : R ≃+* S) :\n    haveI := compHom S (↑g : R →+* S)\n    R ≃ₗ[R] S :=\n  letI := compHom S (↑g : R →+* S)\n  { g with\n    toFun := (g : R → S)\n    invFun := (g.symm : S → R)\n    map_smul' := g.map_mul }\n\n"}
{"name":"Module.compHom.toLinearEquiv_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_9\nS : Type u_10\ninst✝¹ : Semiring R\ninst✝ : Semiring S\ng : RingEquiv R S\na : S\n⊢ Eq ((Module.compHom.toLinearEquiv g).symm a) (g.symm a)","decl":"/-- `g : R ≃+* S` is `R`-linear when the module structure on `S` is `Module.compHom S g` . -/\n@[simps]\ndef compHom.toLinearEquiv {R S : Type*} [Semiring R] [Semiring S] (g : R ≃+* S) :\n    haveI := compHom S (↑g : R →+* S)\n    R ≃ₗ[R] S :=\n  letI := compHom S (↑g : R →+* S)\n  { g with\n    toFun := (g : R → S)\n    invFun := (g.symm : S → R)\n    map_smul' := g.map_mul }\n\n"}
{"name":"DistribMulAction.toLinearEquiv_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Group S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\na✝ : M\n⊢ Eq ((DistribMulAction.toLinearEquiv R M s).symm a✝) (HSMul.hSMul (Inv.inv s) a✝)","decl":"/-- Each element of the group defines a linear equivalence.\n\nThis is a stronger version of `DistribMulAction.toAddEquiv`. -/\n@[simps!]\ndef toLinearEquiv (s : S) : M ≃ₗ[R] M :=\n  { toAddEquiv M s, toLinearMap R M s with }\n\n"}
{"name":"DistribMulAction.toLinearEquiv_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Group S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\na✝ : M\n⊢ Eq ((DistribMulAction.toLinearEquiv R M s) a✝) (HSMul.hSMul s a✝)","decl":"/-- Each element of the group defines a linear equivalence.\n\nThis is a stronger version of `DistribMulAction.toAddEquiv`. -/\n@[simps!]\ndef toLinearEquiv (s : S) : M ≃ₗ[R] M :=\n  { toAddEquiv M s, toLinearMap R M s with }\n\n"}
{"name":"DistribMulAction.toModuleAut_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Group S\ninst✝¹ : DistribMulAction S M\ninst✝ : SMulCommClass S R M\ns : S\n⊢ Eq ((DistribMulAction.toModuleAut R M) s) (DistribMulAction.toLinearEquiv R M s)","decl":"/-- Each element of the group defines a module automorphism.\n\nThis is a stronger version of `DistribMulAction.toAddAut`. -/\n@[simps]\ndef toModuleAut : S →* M ≃ₗ[R] M where\n  toFun := toLinearEquiv R M\n  map_one' := LinearEquiv.ext <| one_smul _\n  map_mul' _ _ := LinearEquiv.ext <| mul_smul _ _\n\n"}
{"name":"AddEquiv.coe_toLinearEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : AddEquiv M M₂\nh : ∀ (c : R) (x : M), Eq (e (HSMul.hSMul c x)) (HSMul.hSMul c (e x))\n⊢ Eq ⇑(e.toLinearEquiv h) ⇑e","decl":"@[simp]\ntheorem coe_toLinearEquiv (h : ∀ (c : R) (x), e (c • x) = c • e x) : ⇑(e.toLinearEquiv h) = e :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_toLinearEquiv_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : AddEquiv M M₂\nh : ∀ (c : R) (x : M), Eq (e (HSMul.hSMul c x)) (HSMul.hSMul c (e x))\n⊢ Eq ⇑(e.toLinearEquiv h).symm ⇑e.symm","decl":"@[simp]\ntheorem coe_toLinearEquiv_symm (h : ∀ (c : R) (x), e (c • x) = c • e x) :\n    ⇑(e.toLinearEquiv h).symm = e.symm :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_toNatLinearEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\ne : AddEquiv M M₂\n⊢ Eq ⇑e.toNatLinearEquiv ⇑e","decl":"@[simp]\ntheorem coe_toNatLinearEquiv : ⇑e.toNatLinearEquiv = e :=\n  rfl\n\n"}
{"name":"AddEquiv.toNatLinearEquiv_toAddEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\ne : AddEquiv M M₂\n⊢ Eq (↑e.toNatLinearEquiv) e","decl":"@[simp]\ntheorem toNatLinearEquiv_toAddEquiv : ↑e.toNatLinearEquiv = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.toAddEquiv_toNatLinearEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\ne : LinearEquiv (RingHom.id Nat) M M₂\n⊢ Eq (↑e).toNatLinearEquiv e","decl":"@[simp]\ntheorem _root_.LinearEquiv.toAddEquiv_toNatLinearEquiv (e : M ≃ₗ[ℕ] M₂) :\n    AddEquiv.toNatLinearEquiv ↑e = e :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"AddEquiv.toNatLinearEquiv_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\ne : AddEquiv M M₂\n⊢ Eq e.toNatLinearEquiv.symm e.symm.toNatLinearEquiv","decl":"@[simp]\ntheorem toNatLinearEquiv_symm : e.toNatLinearEquiv.symm = e.symm.toNatLinearEquiv :=\n  rfl\n\n"}
{"name":"AddEquiv.toNatLinearEquiv_refl","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\ninst✝ : AddCommMonoid M\n⊢ Eq (AddEquiv.refl M).toNatLinearEquiv (LinearEquiv.refl Nat M)","decl":"@[simp]\ntheorem toNatLinearEquiv_refl : (AddEquiv.refl M).toNatLinearEquiv = LinearEquiv.refl ℕ M :=\n  rfl\n\n"}
{"name":"AddEquiv.toNatLinearEquiv_trans","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid M₂\ninst✝ : AddCommMonoid M₃\ne : AddEquiv M M₂\ne₂ : AddEquiv M₂ M₃\n⊢ Eq (e.toNatLinearEquiv.trans e₂.toNatLinearEquiv) (e.trans e₂).toNatLinearEquiv","decl":"@[simp]\ntheorem toNatLinearEquiv_trans (e₂ : M₂ ≃+ M₃) :\n    e.toNatLinearEquiv.trans e₂.toNatLinearEquiv = (e.trans e₂).toNatLinearEquiv :=\n  rfl\n\n"}
{"name":"AddEquiv.coe_toIntLinearEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\ne : AddEquiv M M₂\n⊢ Eq ⇑e.toIntLinearEquiv ⇑e","decl":"@[simp]\ntheorem coe_toIntLinearEquiv : ⇑e.toIntLinearEquiv = e :=\n  rfl\n\n"}
{"name":"AddEquiv.toIntLinearEquiv_toAddEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\ne : AddEquiv M M₂\n⊢ Eq (↑e.toIntLinearEquiv) e","decl":"@[simp]\ntheorem toIntLinearEquiv_toAddEquiv : ↑e.toIntLinearEquiv = e := by\n  ext\n  rfl\n\n"}
{"name":"LinearEquiv.toAddEquiv_toIntLinearEquiv","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\ne : LinearEquiv (RingHom.id Int) M M₂\n⊢ Eq (↑e).toIntLinearEquiv e","decl":"@[simp]\ntheorem _root_.LinearEquiv.toAddEquiv_toIntLinearEquiv (e : M ≃ₗ[ℤ] M₂) :\n    AddEquiv.toIntLinearEquiv (e : M ≃+ M₂) = e :=\n  DFunLike.coe_injective rfl\n\n"}
{"name":"AddEquiv.toIntLinearEquiv_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup M₂\ne : AddEquiv M M₂\n⊢ Eq e.toIntLinearEquiv.symm e.symm.toIntLinearEquiv","decl":"@[simp]\ntheorem toIntLinearEquiv_symm : e.toIntLinearEquiv.symm = e.symm.toIntLinearEquiv :=\n  rfl\n\n"}
{"name":"AddEquiv.toIntLinearEquiv_refl","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\ninst✝ : AddCommGroup M\n⊢ Eq (AddEquiv.refl M).toIntLinearEquiv (LinearEquiv.refl Int M)","decl":"@[simp]\ntheorem toIntLinearEquiv_refl : (AddEquiv.refl M).toIntLinearEquiv = LinearEquiv.refl ℤ M :=\n  rfl\n\n"}
{"name":"AddEquiv.toIntLinearEquiv_trans","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"M : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝² : AddCommGroup M\ninst✝¹ : AddCommGroup M₂\ninst✝ : AddCommGroup M₃\ne : AddEquiv M M₂\ne₂ : AddEquiv M₂ M₃\n⊢ Eq (e.toIntLinearEquiv.trans e₂.toIntLinearEquiv) (e.trans e₂).toIntLinearEquiv","decl":"@[simp]\ntheorem toIntLinearEquiv_trans (e₂ : M₂ ≃+ M₃) :\n    e.toIntLinearEquiv.trans e₂.toIntLinearEquiv = (e.trans e₂).toIntLinearEquiv :=\n  rfl\n\n"}
{"name":"LinearMap.ringLmapEquivSelf_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nx : M\n⊢ Eq ((LinearMap.ringLmapEquivSelf R S M).symm x) (LinearMap.smulRight 1 x)","decl":"/-- The equivalence between R-linear maps from `R` to `M`, and points of `M` itself.\nThis says that the forgetful functor from `R`-modules to types is representable, by `R`.\n\nThis is an `S`-linear equivalence, under the assumption that `S` acts on `M` commuting with `R`.\nWhen `R` is commutative, we can take this to be the usual action with `S = R`.\nOtherwise, `S = ℕ` shows that the equivalence is additive.\nSee note [bundled maps over different rings].\n-/\n@[simps]\ndef ringLmapEquivSelf [Module S M] [SMulCommClass R S M] : (R →ₗ[R] M) ≃ₗ[S] M :=\n  { applyₗ' S (1 : R) with\n    toFun := fun f ↦ f 1\n    invFun := smulRight (1 : R →ₗ[R] R)\n    left_inv := fun f ↦ by\n      ext\n      simp only [coe_smulRight, one_apply, smul_eq_mul, ← map_smul f, mul_one]\n    right_inv := fun x ↦ by simp }\n\n"}
{"name":"LinearMap.ringLmapEquivSelf_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nM : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : SMulCommClass R S M\nf : LinearMap (RingHom.id R) R M\n⊢ Eq ((LinearMap.ringLmapEquivSelf R S M) f) (f 1)","decl":"/-- The equivalence between R-linear maps from `R` to `M`, and points of `M` itself.\nThis says that the forgetful functor from `R`-modules to types is representable, by `R`.\n\nThis is an `S`-linear equivalence, under the assumption that `S` acts on `M` commuting with `R`.\nWhen `R` is commutative, we can take this to be the usual action with `S = R`.\nOtherwise, `S = ℕ` shows that the equivalence is additive.\nSee note [bundled maps over different rings].\n-/\n@[simps]\ndef ringLmapEquivSelf [Module S M] [SMulCommClass R S M] : (R →ₗ[R] M) ≃ₗ[S] M :=\n  { applyₗ' S (1 : R) with\n    toFun := fun f ↦ f 1\n    invFun := smulRight (1 : R →ₗ[R] R)\n    left_inv := fun f ↦ by\n      ext\n      simp only [coe_smulRight, one_apply, smul_eq_mul, ← map_smul f, mul_one]\n    right_inv := fun x ↦ by simp }\n\n"}
{"name":"addMonoidHomLequivNat_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\nB : Type u_10\nR : Type u_11\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid A\ninst✝¹ : AddCommMonoid B\ninst✝ : Module R B\nf : LinearMap (RingHom.id Nat) A B\n⊢ Eq ((addMonoidHomLequivNat R).symm f) f.toAddMonoidHom","decl":"/--\nThe `R`-linear equivalence between additive morphisms `A →+ B` and `ℕ`-linear morphisms `A →ₗ[ℕ] B`.\n-/\n@[simps]\ndef addMonoidHomLequivNat {A B : Type*} (R : Type*) [Semiring R] [AddCommMonoid A]\n    [AddCommMonoid B] [Module R B] : (A →+ B) ≃ₗ[R] A →ₗ[ℕ] B\n    where\n  toFun := AddMonoidHom.toNatLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"addMonoidHomLequivNat_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\nB : Type u_10\nR : Type u_11\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid A\ninst✝¹ : AddCommMonoid B\ninst✝ : Module R B\nf : AddMonoidHom A B\n⊢ Eq ((addMonoidHomLequivNat R) f) f.toNatLinearMap","decl":"/--\nThe `R`-linear equivalence between additive morphisms `A →+ B` and `ℕ`-linear morphisms `A →ₗ[ℕ] B`.\n-/\n@[simps]\ndef addMonoidHomLequivNat {A B : Type*} (R : Type*) [Semiring R] [AddCommMonoid A]\n    [AddCommMonoid B] [Module R B] : (A →+ B) ≃ₗ[R] A →ₗ[ℕ] B\n    where\n  toFun := AddMonoidHom.toNatLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"addMonoidHomLequivInt_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\nB : Type u_10\nR : Type u_11\ninst✝³ : Semiring R\ninst✝² : AddCommGroup A\ninst✝¹ : AddCommGroup B\ninst✝ : Module R B\nf : LinearMap (RingHom.id Int) A B\n⊢ Eq ((addMonoidHomLequivInt R).symm f) f.toAddMonoidHom","decl":"/--\nThe `R`-linear equivalence between additive morphisms `A →+ B` and `ℤ`-linear morphisms `A →ₗ[ℤ] B`.\n-/\n@[simps]\ndef addMonoidHomLequivInt {A B : Type*} (R : Type*) [Semiring R] [AddCommGroup A] [AddCommGroup B]\n    [Module R B] : (A →+ B) ≃ₗ[R] A →ₗ[ℤ] B\n    where\n  toFun := AddMonoidHom.toIntLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"addMonoidHomLequivInt_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\nB : Type u_10\nR : Type u_11\ninst✝³ : Semiring R\ninst✝² : AddCommGroup A\ninst✝¹ : AddCommGroup B\ninst✝ : Module R B\nf : AddMonoidHom A B\n⊢ Eq ((addMonoidHomLequivInt R) f) f.toIntLinearMap","decl":"/--\nThe `R`-linear equivalence between additive morphisms `A →+ B` and `ℤ`-linear morphisms `A →ₗ[ℤ] B`.\n-/\n@[simps]\ndef addMonoidHomLequivInt {A B : Type*} (R : Type*) [Semiring R] [AddCommGroup A] [AddCommGroup B]\n    [Module R B] : (A →+ B) ≃ₗ[R] A →ₗ[ℤ] B\n    where\n  toFun := AddMonoidHom.toIntLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"addMonoidEndRingEquivInt_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\ninst✝ : AddCommGroup A\na✝ : AddMonoidHom A A\n⊢ Eq ((addMonoidEndRingEquivInt A) a✝) ((↑(addMonoidHomLequivInt Int)).toFun a✝)","decl":"/-- Ring equivalence between additive group endomorphisms of an `AddCommGroup` `A` and\n`ℤ`-module endomorphisms of `A.` -/\n@[simps] def addMonoidEndRingEquivInt (A : Type*) [AddCommGroup A] :\n    AddMonoid.End A ≃+* Module.End ℤ A :=\n  { addMonoidHomLequivInt (B := A) ℤ with\n    map_mul' := fun _ _ ↦ rfl }\n\n"}
{"name":"addMonoidEndRingEquivInt_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"A : Type u_9\ninst✝ : AddCommGroup A\na✝ : LinearMap (RingHom.id Int) A A\n⊢ Eq ((addMonoidEndRingEquivInt A).symm a✝) ((addMonoidHomLequivInt Int).invFun a✝)","decl":"/-- Ring equivalence between additive group endomorphisms of an `AddCommGroup` `A` and\n`ℤ`-module endomorphisms of `A.` -/\n@[simps] def addMonoidEndRingEquivInt (A : Type*) [AddCommGroup A] :\n    AddMonoid.End A ≃+* Module.End ℤ A :=\n  { addMonoidHomLequivInt (B := A) ℤ with\n    map_mul' := fun _ _ ↦ rfl }\n\n"}
{"name":"LinearEquiv.zero_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Subsingleton M\ninst✝ : Subsingleton M₂\n⊢ Eq (LinearEquiv.symm 0) 0","decl":"@[simp]\ntheorem zero_symm : (0 : M ≃ₛₗ[σ₁₂] M₂).symm = 0 :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_zero","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Subsingleton M\ninst✝ : Subsingleton M₂\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : M ≃ₛₗ[σ₁₂] M₂) = 0 :=\n  rfl\n\n"}
{"name":"LinearEquiv.zero_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝⁹ : Semiring R\ninst✝⁸ : Semiring R₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M\ninst✝⁴ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\ninst✝³ : RingHomInvPair σ₁₂ σ₂₁\ninst✝² : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Subsingleton M\ninst✝ : Subsingleton M₂\nx : M\n⊢ Eq (0 x) 0","decl":"theorem zero_apply (x : M) : (0 : M ≃ₛₗ[σ₁₂] M₂) x = 0 :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_curry","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nV : Type u_9\nV₂ : Type u_10\n⊢ Eq (⇑(LinearEquiv.curry R M V V₂)) Function.curry","decl":"@[simp]\ntheorem coe_curry : ⇑(LinearEquiv.curry R M V V₂) = curry :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_curry_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nV : Type u_9\nV₂ : Type u_10\n⊢ Eq (⇑(LinearEquiv.curry R M V V₂).symm) Function.uncurry","decl":"@[simp]\ntheorem coe_curry_symm : ⇑(LinearEquiv.curry R M V V₂).symm = uncurry :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofLinear_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\nh₁ : Eq (f.comp g) LinearMap.id\nh₂ : Eq (g.comp f) LinearMap.id\nx : M\n⊢ Eq ((LinearEquiv.ofLinear f g h₁ h₂) x) (f x)","decl":"@[simp]\ntheorem ofLinear_apply {h₁ h₂} (x : M) : (ofLinear f g h₁ h₂ : M ≃ₛₗ[σ₁₂] M₂) x = f x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofLinear_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\nh₁ : Eq (f.comp g) LinearMap.id\nh₂ : Eq (g.comp f) LinearMap.id\nx : M₂\n⊢ Eq ((LinearEquiv.ofLinear f g h₁ h₂).symm x) (g x)","decl":"@[simp]\ntheorem ofLinear_symm_apply {h₁ h₂} (x : M₂) : (ofLinear f g h₁ h₂ : M ≃ₛₗ[σ₁₂] M₂).symm x = g x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofLinear_toLinearMap","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\nh₁ : Eq (f.comp g) LinearMap.id\nh₂ : Eq (g.comp f) LinearMap.id\n⊢ Eq (↑(LinearEquiv.ofLinear f g h₁ h₂)) f","decl":"@[simp]\ntheorem ofLinear_toLinearMap {h₁ h₂} : (ofLinear f g h₁ h₂ : M ≃ₛₗ[σ₁₂] M₂) = f := rfl\n\n"}
{"name":"LinearEquiv.ofLinear_symm_toLinearMap","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nR₂ : Type u_2\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\nh₁ : Eq (f.comp g) LinearMap.id\nh₂ : Eq (g.comp f) LinearMap.id\n⊢ Eq (↑(LinearEquiv.ofLinear f g h₁ h₂).symm) g","decl":"@[simp]\ntheorem ofLinear_symm_toLinearMap {h₁ h₂} : (ofLinear f g h₁ h₂ : M ≃ₛₗ[σ₁₂] M₂).symm = g := rfl\n\n"}
{"name":"LinearEquiv.coe_neg","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (⇑(LinearEquiv.neg R)) (Neg.neg id)","decl":"@[simp]\ntheorem coe_neg : ⇑(neg R : M ≃ₗ[R] M) = -id :=\n  rfl\n\n"}
{"name":"LinearEquiv.neg_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\n⊢ Eq ((LinearEquiv.neg R) x) (Neg.neg x)","decl":"theorem neg_apply (x : M) : neg R x = -x := by simp\n\n"}
{"name":"LinearEquiv.symm_neg","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq (LinearEquiv.neg R).symm (LinearEquiv.neg R)","decl":"@[simp]\ntheorem symm_neg : (neg R : M ≃ₗ[R] M).symm = neg R :=\n  rfl\n\n"}
{"name":"LinearEquiv.arrowCongr_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_9\nM₁ : Type u_10\nM₂ : Type u_11\nM₂₁ : Type u_12\nM₂₂ : Type u_13\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₂₁\ninst✝⁴ : AddCommMonoid M₂₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\ninst✝¹ : Module R M₂₁\ninst✝ : Module R M₂₂\ne₁ : LinearEquiv (RingHom.id R) M₁ M₂\ne₂ : LinearEquiv (RingHom.id R) M₂₁ M₂₂\nf : LinearMap (RingHom.id R) M₁ M₂₁\nx : M₂\n⊢ Eq (((e₁.arrowCongr e₂) f) x) (e₂ (f (e₁.symm x)))","decl":"@[simp]\ntheorem arrowCongr_apply {R M₁ M₂ M₂₁ M₂₂ : Sort _} [CommSemiring R] [AddCommMonoid M₁]\n    [AddCommMonoid M₂] [AddCommMonoid M₂₁] [AddCommMonoid M₂₂] [Module R M₁] [Module R M₂]\n    [Module R M₂₁] [Module R M₂₂] (e₁ : M₁ ≃ₗ[R] M₂) (e₂ : M₂₁ ≃ₗ[R] M₂₂) (f : M₁ →ₗ[R] M₂₁)\n    (x : M₂) : arrowCongr e₁ e₂ f x = e₂ (f (e₁.symm x)) :=\n  rfl\n\n"}
{"name":"LinearEquiv.arrowCongr_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_9\nM₁ : Type u_10\nM₂ : Type u_11\nM₂₁ : Type u_12\nM₂₂ : Type u_13\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M₂₁\ninst✝⁴ : AddCommMonoid M₂₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\ninst✝¹ : Module R M₂₁\ninst✝ : Module R M₂₂\ne₁ : LinearEquiv (RingHom.id R) M₁ M₂\ne₂ : LinearEquiv (RingHom.id R) M₂₁ M₂₂\nf : LinearMap (RingHom.id R) M₂ M₂₂\nx : M₁\n⊢ Eq (((e₁.arrowCongr e₂).symm f) x) (e₂.symm (f (e₁ x)))","decl":"@[simp]\ntheorem arrowCongr_symm_apply {R M₁ M₂ M₂₁ M₂₂ : Sort _} [CommSemiring R] [AddCommMonoid M₁]\n    [AddCommMonoid M₂] [AddCommMonoid M₂₁] [AddCommMonoid M₂₂] [Module R M₁] [Module R M₂]\n    [Module R M₂₁] [Module R M₂₂] (e₁ : M₁ ≃ₗ[R] M₂) (e₂ : M₂₁ ≃ₗ[R] M₂₂) (f : M₂ →ₗ[R] M₂₂)\n    (x : M₁) : (arrowCongr e₁ e₂).symm f x = e₂.symm (f (e₁ x)) :=\n  rfl\n\n"}
{"name":"LinearEquiv.arrowCongr_comp","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝¹² : CommSemiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : Module R M\ninst✝⁷ : Module R M₂\ninst✝⁶ : Module R M₃\nN : Type u_9\nN₂ : Type u_10\nN₃ : Type u_11\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid N₂\ninst✝³ : AddCommMonoid N₃\ninst✝² : Module R N\ninst✝¹ : Module R N₂\ninst✝ : Module R N₃\ne₁ : LinearEquiv (RingHom.id R) M N\ne₂ : LinearEquiv (RingHom.id R) M₂ N₂\ne₃ : LinearEquiv (RingHom.id R) M₃ N₃\nf : LinearMap (RingHom.id R) M M₂\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq ((e₁.arrowCongr e₃) (g.comp f)) (((e₂.arrowCongr e₃) g).comp ((e₁.arrowCongr e₂) f))","decl":"theorem arrowCongr_comp {N N₂ N₃ : Sort _} [AddCommMonoid N] [AddCommMonoid N₂] [AddCommMonoid N₃]\n    [Module R N] [Module R N₂] [Module R N₃] (e₁ : M ≃ₗ[R] N) (e₂ : M₂ ≃ₗ[R] N₂) (e₃ : M₃ ≃ₗ[R] N₃)\n    (f : M →ₗ[R] M₂) (g : M₂ →ₗ[R] M₃) :\n    arrowCongr e₁ e₃ (g.comp f) = (arrowCongr e₂ e₃ g).comp (arrowCongr e₁ e₂ f) := by\n  ext\n  simp only [symm_apply_apply, arrowCongr_apply, LinearMap.comp_apply]\n\n"}
{"name":"LinearEquiv.arrowCongr_trans","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM₁ : Type u_9\nM₂ : Type u_10\nM₃ : Type u_11\nN₁ : Type u_12\nN₂ : Type u_13\nN₃ : Type u_14\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M₃\ninst✝⁵ : AddCommMonoid N₁\ninst✝⁴ : Module R N₁\ninst✝³ : AddCommMonoid N₂\ninst✝² : Module R N₂\ninst✝¹ : AddCommMonoid N₃\ninst✝ : Module R N₃\ne₁ : LinearEquiv (RingHom.id R) M₁ M₂\ne₂ : LinearEquiv (RingHom.id R) N₁ N₂\ne₃ : LinearEquiv (RingHom.id R) M₂ M₃\ne₄ : LinearEquiv (RingHom.id R) N₂ N₃\n⊢ Eq ((e₁.arrowCongr e₂).trans (e₃.arrowCongr e₄)) ((e₁.trans e₃).arrowCongr (e₂.trans e₄))","decl":"theorem arrowCongr_trans {M₁ M₂ M₃ N₁ N₂ N₃ : Sort _} [AddCommMonoid M₁] [Module R M₁]\n    [AddCommMonoid M₂] [Module R M₂] [AddCommMonoid M₃] [Module R M₃] [AddCommMonoid N₁]\n    [Module R N₁] [AddCommMonoid N₂] [Module R N₂] [AddCommMonoid N₃] [Module R N₃]\n    (e₁ : M₁ ≃ₗ[R] M₂) (e₂ : N₁ ≃ₗ[R] N₂) (e₃ : M₂ ≃ₗ[R] M₃) (e₄ : N₂ ≃ₗ[R] N₃) :\n    (arrowCongr e₁ e₂).trans (arrowCongr e₃ e₄) = arrowCongr (e₁.trans e₃) (e₂.trans e₄) :=\n  rfl\n\n"}
{"name":"LinearEquiv.conj_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nf : Module.End R M\n⊢ Eq (e.conj f) (((↑e).comp f).comp ↑e.symm)","decl":"theorem conj_apply (e : M ≃ₗ[R] M₂) (f : Module.End R M) :\n    e.conj f = ((↑e : M →ₗ[R] M₂).comp f).comp (e.symm : M₂ →ₗ[R] M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.conj_apply_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nf : Module.End R M\nx : M₂\n⊢ Eq ((e.conj f) x) (e (f (e.symm x)))","decl":"theorem conj_apply_apply (e : M ≃ₗ[R] M₂) (f : Module.End R M) (x : M₂) :\n    e.conj f x = e (f (e.symm x)) :=\n  rfl\n\n"}
{"name":"LinearEquiv.symm_conj_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nf : Module.End R M₂\n⊢ Eq (e.symm.conj f) (((↑e.symm).comp f).comp ↑e)","decl":"theorem symm_conj_apply (e : M ≃ₗ[R] M₂) (f : Module.End R M₂) :\n    e.symm.conj f = ((↑e.symm : M₂ →ₗ[R] M).comp f).comp (e : M →ₗ[R] M₂) :=\n  rfl\n\n"}
{"name":"LinearEquiv.conj_comp","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nf g : Module.End R M\n⊢ Eq (e.conj (LinearMap.comp g f)) (LinearMap.comp (e.conj g) (e.conj f))","decl":"theorem conj_comp (e : M ≃ₗ[R] M₂) (f g : Module.End R M) :\n    e.conj (g.comp f) = (e.conj g).comp (e.conj f) :=\n  arrowCongr_comp e e e f g\n\n"}
{"name":"LinearEquiv.conj_trans","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ne₁ : LinearEquiv (RingHom.id R) M M₂\ne₂ : LinearEquiv (RingHom.id R) M₂ M₃\n⊢ Eq (e₁.conj.trans e₂.conj) (e₁.trans e₂).conj","decl":"theorem conj_trans (e₁ : M ≃ₗ[R] M₂) (e₂ : M₂ ≃ₗ[R] M₃) :\n    e₁.conj.trans e₂.conj = (e₁.trans e₂).conj :=\n  rfl\n\n"}
{"name":"LinearEquiv.conj_id","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\n⊢ Eq (e.conj LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem conj_id (e : M ≃ₗ[R] M₂) : e.conj LinearMap.id = LinearMap.id := by\n  ext\n  simp [conj_apply]\n\n"}
{"name":"LinearEquiv.smulOfNeZero_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"K : Type u_3\nM : Type u_5\ninst✝² : Field K\ninst✝¹ : AddCommGroup M\ninst✝ : Module K M\na : K\nha : Ne a 0\na✝ : M\n⊢ Eq ((LinearEquiv.smulOfNeZero K M a ha).symm a✝) (HSMul.hSMul (Inv.inv (Units.mk0 a ha)) a✝)","decl":"/-- Multiplying by a nonzero element `a` of the field `K` is a linear equivalence. -/\n@[simps!]\ndef smulOfNeZero (a : K) (ha : a ≠ 0) : M ≃ₗ[K] M :=\n  smulOfUnit <| Units.mk0 a ha\n\n"}
{"name":"LinearEquiv.smulOfNeZero_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"K : Type u_3\nM : Type u_5\ninst✝² : Field K\ninst✝¹ : AddCommGroup M\ninst✝ : Module K M\na : K\nha : Ne a 0\na✝ : M\n⊢ Eq ((LinearEquiv.smulOfNeZero K M a ha) a✝) (HSMul.hSMul (Units.mk0 a ha) a✝)","decl":"/-- Multiplying by a nonzero element `a` of the field `K` is a linear equivalence. -/\n@[simps!]\ndef smulOfNeZero (a : K) (ha : a ≠ 0) : M ≃ₗ[K] M :=\n  smulOfUnit <| Units.mk0 a ha\n\n"}
{"name":"LinearMap.funLeft_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\nf : m → n\ng : n → M\ni : m\n⊢ Eq ((LinearMap.funLeft R M f) g i) (g (f i))","decl":"@[simp]\ntheorem funLeft_apply (f : m → n) (g : n → M) (i : m) : funLeft R M f g i = g (f i) :=\n  rfl\n\n"}
{"name":"LinearMap.funLeft_id","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Type u_10\ng : n → M\n⊢ Eq ((LinearMap.funLeft R M id) g) g","decl":"@[simp]\ntheorem funLeft_id (g : n → M) : funLeft R M _root_.id g = g :=\n  rfl\n\n"}
{"name":"LinearMap.funLeft_comp","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\np : Type u_11\nf₁ : n → p\nf₂ : m → n\n⊢ Eq (LinearMap.funLeft R M (Function.comp f₁ f₂)) ((LinearMap.funLeft R M f₂).comp (LinearMap.funLeft R M f₁))","decl":"theorem funLeft_comp (f₁ : n → p) (f₂ : m → n) :\n    funLeft R M (f₁ ∘ f₂) = (funLeft R M f₂).comp (funLeft R M f₁) :=\n  rfl\n\n"}
{"name":"LinearMap.funLeft_surjective_of_injective","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\nf : m → n\nhf : Function.Injective f\n⊢ Function.Surjective ⇑(LinearMap.funLeft R M f)","decl":"theorem funLeft_surjective_of_injective (f : m → n) (hf : Injective f) :\n    Surjective (funLeft R M f) := by\n  classical\n    intro g\n    refine ⟨fun x ↦ if h : ∃ y, f y = x then g h.choose else 0, ?_⟩\n    ext\n    dsimp only [funLeft_apply]\n    split_ifs with w\n    · congr\n      exact hf w.choose_spec\n    · simp only [not_true, exists_apply_eq_apply] at w\n\n"}
{"name":"LinearMap.funLeft_injective_of_surjective","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\nf : m → n\nhf : Function.Surjective f\n⊢ Function.Injective ⇑(LinearMap.funLeft R M f)","decl":"theorem funLeft_injective_of_surjective (f : m → n) (hf : Surjective f) :\n    Injective (funLeft R M f) := by\n  obtain ⟨g, hg⟩ := hf.hasRightInverse\n  suffices LeftInverse (funLeft R M g) (funLeft R M f) by exact this.injective\n  intro x\n  rw [← LinearMap.comp_apply, ← funLeft_comp, hg.id, funLeft_id]\n\n"}
{"name":"LinearEquiv.funCongrLeft_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\ne : Equiv m n\nx : n → M\n⊢ Eq ((LinearEquiv.funCongrLeft R M e) x) ((LinearMap.funLeft R M ⇑e) x)","decl":"@[simp]\ntheorem funCongrLeft_apply (e : m ≃ n) (x : n → M) : funCongrLeft R M e x = funLeft R M e x :=\n  rfl\n\n"}
{"name":"LinearEquiv.funCongrLeft_id","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Type u_10\n⊢ Eq (LinearEquiv.funCongrLeft R M (Equiv.refl n)) (LinearEquiv.refl R (n → M))","decl":"@[simp]\ntheorem funCongrLeft_id : funCongrLeft R M (Equiv.refl n) = LinearEquiv.refl R (n → M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.funCongrLeft_comp","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\np : Type u_11\ne₁ : Equiv m n\ne₂ : Equiv n p\n⊢ Eq (LinearEquiv.funCongrLeft R M (e₁.trans e₂)) ((LinearEquiv.funCongrLeft R M e₂).trans (LinearEquiv.funCongrLeft R M e₁))","decl":"@[simp]\ntheorem funCongrLeft_comp (e₁ : m ≃ n) (e₂ : n ≃ p) :\n    funCongrLeft R M (Equiv.trans e₁ e₂) =\n      LinearEquiv.trans (funCongrLeft R M e₂) (funCongrLeft R M e₁) :=\n  rfl\n\n"}
{"name":"LinearEquiv.funCongrLeft_symm","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : Type u_9\nn : Type u_10\ne : Equiv m n\n⊢ Eq (LinearEquiv.funCongrLeft R M e).symm (LinearEquiv.funCongrLeft R M e.symm)","decl":"@[simp]\ntheorem funCongrLeft_symm (e : m ≃ n) : (funCongrLeft R M e).symm = funCongrLeft R M e.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.piUnique_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝³ : Unique α\nR : Type u_10\ninst✝² : Semiring R\nf : α → Type u_11\ninst✝¹ : (x : α) → AddCommMonoid (f x)\ninst✝ : (x : α) → Module R (f x)\n⊢ Eq (⇑(LinearEquiv.piUnique R f)) (Equiv.piUnique f).toFun","decl":"/-- The product `Π t : α, f t` of a family of modules is linearly isomorphic to the module\n`f ⬝` when `α` only contains `⬝`.\n\nThis is `Equiv.piUnique` as a `LinearEquiv`.\n-/\n@[simps (config := .asFn)]\ndef piUnique {α : Type*} [Unique α] (R : Type*) [Semiring R] (f : α → Type*)\n    [∀ x, AddCommMonoid (f x)] [∀ x, Module R (f x)] : (Π t : α, f t) ≃ₗ[R] f default where\n  __ := Equiv.piUnique _\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
{"name":"LinearEquiv.piUnique_symm_apply","module":"Mathlib.Algebra.Module.Equiv.Basic","initialProofState":"α : Type u_9\ninst✝³ : Unique α\nR : Type u_10\ninst✝² : Semiring R\nf : α → Type u_11\ninst✝¹ : (x : α) → AddCommMonoid (f x)\ninst✝ : (x : α) → Module R (f x)\n⊢ Eq (⇑(LinearEquiv.piUnique R f).symm) (Equiv.piUnique f).invFun","decl":"/-- The product `Π t : α, f t` of a family of modules is linearly isomorphic to the module\n`f ⬝` when `α` only contains `⬝`.\n\nThis is `Equiv.piUnique` as a `LinearEquiv`.\n-/\n@[simps (config := .asFn)]\ndef piUnique {α : Type*} [Unique α] (R : Type*) [Semiring R] (f : α → Type*)\n    [∀ x, AddCommMonoid (f x)] [∀ x, Module R (f x)] : (Π t : α, f t) ≃ₗ[R] f default where\n  __ := Equiv.piUnique _\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n\n"}
