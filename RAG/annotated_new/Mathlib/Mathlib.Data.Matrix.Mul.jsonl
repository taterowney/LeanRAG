{"name":"dotProduct_assoc","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalSemiring α\nu : m → α\nw : n → α\nv : Matrix m n α\n⊢ Eq (dotProduct (fun j => dotProduct u fun i => v i j) w) (dotProduct u fun i => dotProduct (v i) w)","decl":"theorem dotProduct_assoc [NonUnitalSemiring α] (u : m → α) (w : n → α) (v : Matrix m n α) :\n    (fun j => u ⬝ᵥ fun i => v i j) ⬝ᵥ w = u ⬝ᵥ fun i => v i ⬝ᵥ w := by\n  simpa [dotProduct, Finset.mul_sum, Finset.sum_mul, mul_assoc] using Finset.sum_comm\n\n"}
{"name":"Matrix.dotProduct_assoc","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalSemiring α\nu : m → α\nw : n → α\nv : Matrix m n α\n⊢ Eq (dotProduct (fun j => dotProduct u fun i => v i j) w) (dotProduct u fun i => dotProduct (v i) w)","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_assoc := dotProduct_assoc\n\n"}
{"name":"dotProduct_comm","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : AddCommMonoid α\ninst✝ : CommSemigroup α\nv w : m → α\n⊢ Eq (dotProduct v w) (dotProduct w v)","decl":"theorem dotProduct_comm [AddCommMonoid α] [CommSemigroup α] (v w : m → α) : v ⬝ᵥ w = w ⬝ᵥ v := by\n  simp_rw [dotProduct, mul_comm]\n\n"}
{"name":"Matrix.dotProduct_comm","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : AddCommMonoid α\ninst✝ : CommSemigroup α\nv w : m → α\n⊢ Eq (dotProduct v w) (dotProduct w v)","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_comm := dotProduct_comm\n\n"}
{"name":"dotProduct_pUnit","module":"Mathlib.Data.Matrix.Mul","initialProofState":"α : Type v\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv w : PUnit.{u_10 + 1} → α\n⊢ Eq (dotProduct v w) (HMul.hMul (v PUnit.unit) (w PUnit.unit))","decl":"@[simp]\ntheorem dotProduct_pUnit [AddCommMonoid α] [Mul α] (v w : PUnit → α) : v ⬝ᵥ w = v ⟨⟩ * w ⟨⟩ := by\n  simp [dotProduct]\n\n"}
{"name":"Matrix.dotProduct_pUnit","module":"Mathlib.Data.Matrix.Mul","initialProofState":"α : Type v\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv w : PUnit.{u_10 + 1} → α\n⊢ Eq (dotProduct v w) (HMul.hMul (v PUnit.unit) (w PUnit.unit))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_pUnit := dotProduct_pUnit\n\n"}
{"name":"dotProduct_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : MulOneClass α\ninst✝ : AddCommMonoid α\nv : n → α\n⊢ Eq (dotProduct v 1) (Finset.univ.sum fun i => v i)","decl":"theorem dotProduct_one (v : n → α) : v ⬝ᵥ 1 = ∑ i, v i := by simp [(· ⬝ᵥ ·)]\n\n"}
{"name":"Matrix.dotProduct_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : MulOneClass α\ninst✝ : AddCommMonoid α\nv : n → α\n⊢ Eq (dotProduct v 1) (Finset.univ.sum fun i => v i)","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_one := dotProduct_one\n\n"}
{"name":"one_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : MulOneClass α\ninst✝ : AddCommMonoid α\nv : n → α\n⊢ Eq (dotProduct 1 v) (Finset.univ.sum fun i => v i)","decl":"theorem one_dotProduct (v : n → α) : 1 ⬝ᵥ v = ∑ i, v i := by simp [(· ⬝ᵥ ·)]\n\n"}
{"name":"Matrix.one_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : MulOneClass α\ninst✝ : AddCommMonoid α\nv : n → α\n⊢ Eq (dotProduct 1 v) (Finset.univ.sum fun i => v i)","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.one_dotProduct := one_dotProduct\n\n"}
{"name":"dotProduct_zero","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct v 0) 0","decl":"@[simp]\ntheorem dotProduct_zero : v ⬝ᵥ 0 = 0 := by simp [dotProduct]\n\n"}
{"name":"Matrix.dotProduct_zero","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct v 0) 0","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_zero := dotProduct_zero\n\n"}
{"name":"dotProduct_zero'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct v fun x => 0) 0","decl":"@[simp]\ntheorem dotProduct_zero' : (v ⬝ᵥ fun _ => 0) = 0 :=\n  dotProduct_zero v\n\n"}
{"name":"Matrix.dotProduct_zero'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct v fun x => 0) 0","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_zero' := dotProduct_zero'\n\n"}
{"name":"zero_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct 0 v) 0","decl":"@[simp]\ntheorem zero_dotProduct : 0 ⬝ᵥ v = 0 := by simp [dotProduct]\n\n"}
{"name":"Matrix.zero_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct 0 v) 0","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.zero_dotProduct := zero_dotProduct\n\n"}
{"name":"zero_dotProduct'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct (fun x => 0) v) 0","decl":"@[simp]\ntheorem zero_dotProduct' : (fun _ => (0 : α)) ⬝ᵥ v = 0 :=\n  zero_dotProduct v\n\n"}
{"name":"Matrix.zero_dotProduct'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\n⊢ Eq (dotProduct (fun x => 0) v) 0","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.zero_dotProduct' := zero_dotProduct'\n\n"}
{"name":"add_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nu v w : m → α\n⊢ Eq (dotProduct (HAdd.hAdd u v) w) (HAdd.hAdd (dotProduct u w) (dotProduct v w))","decl":"@[simp]\ntheorem add_dotProduct : (u + v) ⬝ᵥ w = u ⬝ᵥ w + v ⬝ᵥ w := by\n  simp [dotProduct, add_mul, Finset.sum_add_distrib]\n\n"}
{"name":"Matrix.add_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nu v w : m → α\n⊢ Eq (dotProduct (HAdd.hAdd u v) w) (HAdd.hAdd (dotProduct u w) (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.add_dotProduct := add_dotProduct\n\n"}
{"name":"dotProduct_add","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nu v w : m → α\n⊢ Eq (dotProduct u (HAdd.hAdd v w)) (HAdd.hAdd (dotProduct u v) (dotProduct u w))","decl":"@[simp]\ntheorem dotProduct_add : u ⬝ᵥ (v + w) = u ⬝ᵥ v + u ⬝ᵥ w := by\n  simp [dotProduct, mul_add, Finset.sum_add_distrib]\n\n"}
{"name":"Matrix.dotProduct_add","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nu v w : m → α\n⊢ Eq (dotProduct u (HAdd.hAdd v w)) (HAdd.hAdd (dotProduct u v) (dotProduct u w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_add := dotProduct_add\n\n"}
{"name":"sum_elim_dotProduct_sum_elim","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu v : m → α\nx y : n → α\n⊢ Eq (dotProduct (Sum.elim u x) (Sum.elim v y)) (HAdd.hAdd (dotProduct u v) (dotProduct x y))","decl":"@[simp]\ntheorem sum_elim_dotProduct_sum_elim : Sum.elim u x ⬝ᵥ Sum.elim v y = u ⬝ᵥ v + x ⬝ᵥ y := by\n  simp [dotProduct]\n\n"}
{"name":"Matrix.sum_elim_dotProduct_sum_elim","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu v : m → α\nx y : n → α\n⊢ Eq (dotProduct (Sum.elim u x) (Sum.elim v y)) (HAdd.hAdd (dotProduct u v) (dotProduct x y))","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.sum_elim_dotProduct_sum_elim := sum_elim_dotProduct_sum_elim\n\n"}
{"name":"comp_equiv_symm_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu : m → α\nx : n → α\ne : Equiv m n\n⊢ Eq (dotProduct (Function.comp u ⇑e.symm) x) (dotProduct u (Function.comp x ⇑e))","decl":"/-- Permuting a vector on the left of a dot product can be transferred to the right. -/\n@[simp]\ntheorem comp_equiv_symm_dotProduct (e : m ≃ n) : u ∘ e.symm ⬝ᵥ x = u ⬝ᵥ x ∘ e :=\n  (e.sum_comp _).symm.trans <|\n    Finset.sum_congr rfl fun _ _ => by simp only [Function.comp, Equiv.symm_apply_apply]\n\n"}
{"name":"Matrix.comp_equiv_symm_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu : m → α\nx : n → α\ne : Equiv m n\n⊢ Eq (dotProduct (Function.comp u ⇑e.symm) x) (dotProduct u (Function.comp x ⇑e))","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.comp_equiv_symm_dotProduct := comp_equiv_symm_dotProduct\n\n"}
{"name":"dotProduct_comp_equiv_symm","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu : m → α\nx : n → α\ne : Equiv n m\n⊢ Eq (dotProduct u (Function.comp x ⇑e.symm)) (dotProduct (Function.comp u ⇑e) x)","decl":"/-- Permuting a vector on the right of a dot product can be transferred to the left. -/\n@[simp]\ntheorem dotProduct_comp_equiv_symm (e : n ≃ m) : u ⬝ᵥ x ∘ e.symm = u ∘ e ⬝ᵥ x := by\n  simpa only [Equiv.symm_symm] using (comp_equiv_symm_dotProduct u x e.symm).symm\n\n"}
{"name":"Matrix.dotProduct_comp_equiv_symm","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nu : m → α\nx : n → α\ne : Equiv n m\n⊢ Eq (dotProduct u (Function.comp x ⇑e.symm)) (dotProduct (Function.comp u ⇑e) x)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.dotProduct_comp_equiv_symm := dotProduct_comp_equiv_symm\n\n"}
{"name":"comp_equiv_dotProduct_comp_equiv","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nx y : n → α\ne : Equiv m n\n⊢ Eq (dotProduct (Function.comp x ⇑e) (Function.comp y ⇑e)) (dotProduct x y)","decl":"/-- Permuting vectors on both sides of a dot product is a no-op. -/\n@[simp]\ntheorem comp_equiv_dotProduct_comp_equiv (e : m ≃ n) : x ∘ e ⬝ᵥ y ∘ e = x ⬝ᵥ y := by\n  -- Porting note: was `simp only` with all three lemmas\n  rw [← dotProduct_comp_equiv_symm]; simp only [Function.comp_def, Equiv.apply_symm_apply]\n\n"}
{"name":"Matrix.comp_equiv_dotProduct_comp_equiv","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Fintype n\ninst✝ : NonUnitalNonAssocSemiring α\nx y : n → α\ne : Equiv m n\n⊢ Eq (dotProduct (Function.comp x ⇑e) (Function.comp y ⇑e)) (dotProduct x y)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.comp_equiv_dotProduct_comp_equiv := comp_equiv_dotProduct_comp_equiv\n\n"}
{"name":"diagonal_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct (Matrix.diagonal v i) w) (HMul.hMul (v i) (w i))","decl":"@[simp]\ntheorem diagonal_dotProduct (i : m) : diagonal v i ⬝ᵥ w = v i * w i := by\n  have : ∀ j ≠ i, diagonal v i j * w j = 0 := fun j hij => by\n    simp [diagonal_apply_ne' _ hij]\n  convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp\n\n"}
{"name":"Matrix.diagonal_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct (Matrix.diagonal v i) w) (HMul.hMul (v i) (w i))","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.diagonal_dotProduct := diagonal_dotProduct\n\n"}
{"name":"dotProduct_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct v (Matrix.diagonal w i)) (HMul.hMul (v i) (w i))","decl":"@[simp]\ntheorem dotProduct_diagonal (i : m) : v ⬝ᵥ diagonal w i = v i * w i := by\n  have : ∀ j ≠ i, v j * diagonal w i j = 0 := fun j hij => by\n    simp [diagonal_apply_ne' _ hij]\n  convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp\n\n"}
{"name":"Matrix.dotProduct_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct v (Matrix.diagonal w i)) (HMul.hMul (v i) (w i))","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.dotProduct_diagonal := dotProduct_diagonal\n\n"}
{"name":"dotProduct_diagonal'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct v fun j => Matrix.diagonal w j i) (HMul.hMul (v i) (w i))","decl":"@[simp]\ntheorem dotProduct_diagonal' (i : m) : (v ⬝ᵥ fun j => diagonal w j i) = v i * w i := by\n  have : ∀ j ≠ i, v j * diagonal w j i = 0 := fun j hij => by\n    simp [diagonal_apply_ne _ hij]\n  convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp\n\n"}
{"name":"Matrix.dotProduct_diagonal'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv w : m → α\ni : m\n⊢ Eq (dotProduct v fun j => Matrix.diagonal w j i) (HMul.hMul (v i) (w i))","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.dotProduct_diagonal' := dotProduct_diagonal'\n\n"}
{"name":"single_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\nx : α\ni : m\n⊢ Eq (dotProduct (Pi.single i x) v) (HMul.hMul x (v i))","decl":"@[simp]\ntheorem single_dotProduct (x : α) (i : m) : Pi.single i x ⬝ᵥ v = x * v i := by\n  -- Porting note: (implicit arg) added `(f := fun _ => α)`\n  have : ∀ j ≠ i, Pi.single (f := fun _ => α) i x j * v j = 0 := fun j hij => by\n    simp [Pi.single_eq_of_ne hij]\n  convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp\n\n"}
{"name":"Matrix.single_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\nx : α\ni : m\n⊢ Eq (dotProduct (Pi.single i x) v) (HMul.hMul x (v i))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.single_dotProduct := single_dotProduct\n\n"}
{"name":"dotProduct_single","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\nx : α\ni : m\n⊢ Eq (dotProduct v (Pi.single i x)) (HMul.hMul (v i) x)","decl":"@[simp]\ntheorem dotProduct_single (x : α) (i : m) : v ⬝ᵥ Pi.single i x = v i * x := by\n  -- Porting note: (implicit arg) added `(f := fun _ => α)`\n  have : ∀ j ≠ i, v j * Pi.single (f := fun _ => α) i x j = 0 := fun j hij => by\n    simp [Pi.single_eq_of_ne hij]\n  convert Finset.sum_eq_single i (fun j _ => this j) _ using 1 <;> simp\n\n"}
{"name":"Matrix.dotProduct_single","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring α\nv : m → α\nx : α\ni : m\n⊢ Eq (dotProduct v (Pi.single i x)) (HMul.hMul (v i) x)","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_single := dotProduct_single\n\n"}
{"name":"one_dotProduct_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : Fintype n\ninst✝ : NonAssocSemiring α\n⊢ Eq (dotProduct 1 1) ↑(Fintype.card n)","decl":"@[simp]\ntheorem one_dotProduct_one : (1 : n → α) ⬝ᵥ 1 = Fintype.card n := by\n  simp [dotProduct]\n\n"}
{"name":"Matrix.one_dotProduct_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : Fintype n\ninst✝ : NonAssocSemiring α\n⊢ Eq (dotProduct 1 1) ↑(Fintype.card n)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.one_dotProduct_one := one_dotProduct_one\n\n"}
{"name":"dotProduct_single_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq n\nv : n → α\ni : n\n⊢ Eq (dotProduct v (Pi.single i 1)) (v i)","decl":"theorem dotProduct_single_one [DecidableEq n] (v : n → α) (i : n) :\n    dotProduct v (Pi.single i 1) = v i := by\n  rw [dotProduct_single, mul_one]\n\n"}
{"name":"Matrix.dotProduct_single_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq n\nv : n → α\ni : n\n⊢ Eq (dotProduct v (Pi.single i 1)) (v i)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.dotProduct_single_one := dotProduct_single_one\n\n"}
{"name":"single_one_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq n\ni : n\nv : n → α\n⊢ Eq (dotProduct (Pi.single i 1) v) (v i)","decl":"theorem single_one_dotProduct [DecidableEq n] (i : n) (v : n → α) :\n    dotProduct (Pi.single i 1) v = v i := by\n  rw [single_dotProduct, one_mul]\n\n"}
{"name":"Matrix.single_one_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq n\ni : n\nv : n → α\n⊢ Eq (dotProduct (Pi.single i 1) v) (v i)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.single_one_dotProduct := single_one_dotProduct\n\n"}
{"name":"neg_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct (Neg.neg v) w) (Neg.neg (dotProduct v w))","decl":"@[simp]\ntheorem neg_dotProduct : -v ⬝ᵥ w = -(v ⬝ᵥ w) := by simp [dotProduct]\n\n"}
{"name":"Matrix.neg_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct (Neg.neg v) w) (Neg.neg (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.neg_dotProduct := neg_dotProduct\n\n"}
{"name":"dotProduct_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct v (Neg.neg w)) (Neg.neg (dotProduct v w))","decl":"@[simp]\ntheorem dotProduct_neg : v ⬝ᵥ -w = -(v ⬝ᵥ w) := by simp [dotProduct]\n\n"}
{"name":"Matrix.dotProduct_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct v (Neg.neg w)) (Neg.neg (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_neg := dotProduct_neg\n\n"}
{"name":"neg_dotProduct_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct (Neg.neg v) (Neg.neg w)) (dotProduct v w)","decl":"lemma neg_dotProduct_neg : -v ⬝ᵥ -w = v ⬝ᵥ w := by\n  rw [neg_dotProduct, dotProduct_neg, neg_neg]\n\n"}
{"name":"Matrix.neg_dotProduct_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nv w : m → α\n⊢ Eq (dotProduct (Neg.neg v) (Neg.neg w)) (dotProduct v w)","decl":"@[deprecated (since := \"2024-12-12\")]\nprotected alias Matrix.neg_dotProduct_neg := neg_dotProduct_neg\n\n"}
{"name":"sub_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nu v w : m → α\n⊢ Eq (dotProduct (HSub.hSub u v) w) (HSub.hSub (dotProduct u w) (dotProduct v w))","decl":"@[simp]\ntheorem sub_dotProduct : (u - v) ⬝ᵥ w = u ⬝ᵥ w - v ⬝ᵥ w := by simp [sub_eq_add_neg]\n\n"}
{"name":"Matrix.sub_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nu v w : m → α\n⊢ Eq (dotProduct (HSub.hSub u v) w) (HSub.hSub (dotProduct u w) (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.sub_dotProduct := sub_dotProduct\n\n"}
{"name":"dotProduct_sub","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nu v w : m → α\n⊢ Eq (dotProduct u (HSub.hSub v w)) (HSub.hSub (dotProduct u v) (dotProduct u w))","decl":"@[simp]\ntheorem dotProduct_sub : u ⬝ᵥ (v - w) = u ⬝ᵥ v - u ⬝ᵥ w := by simp [sub_eq_add_neg]\n\n"}
{"name":"Matrix.dotProduct_sub","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocRing α\nu v w : m → α\n⊢ Eq (dotProduct u (HSub.hSub v w)) (HSub.hSub (dotProduct u v) (dotProduct u w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_sub := dotProduct_sub\n\n"}
{"name":"smul_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁵ : Fintype m\ninst✝⁴ : Monoid R\ninst✝³ : Mul α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction R α\ninst✝ : IsScalarTower R α α\nx : R\nv w : m → α\n⊢ Eq (dotProduct (HSMul.hSMul x v) w) (HSMul.hSMul x (dotProduct v w))","decl":"@[simp]\ntheorem smul_dotProduct [IsScalarTower R α α] (x : R) (v w : m → α) :\n    x • v ⬝ᵥ w = x • (v ⬝ᵥ w) := by simp [dotProduct, Finset.smul_sum, smul_mul_assoc]\n\n"}
{"name":"Matrix.smul_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁵ : Fintype m\ninst✝⁴ : Monoid R\ninst✝³ : Mul α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction R α\ninst✝ : IsScalarTower R α α\nx : R\nv w : m → α\n⊢ Eq (dotProduct (HSMul.hSMul x v) w) (HSMul.hSMul x (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.smul_dotProduct := smul_dotProduct\n\n"}
{"name":"dotProduct_smul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁵ : Fintype m\ninst✝⁴ : Monoid R\ninst✝³ : Mul α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction R α\ninst✝ : SMulCommClass R α α\nx : R\nv w : m → α\n⊢ Eq (dotProduct v (HSMul.hSMul x w)) (HSMul.hSMul x (dotProduct v w))","decl":"@[simp]\ntheorem dotProduct_smul [SMulCommClass R α α] (x : R) (v w : m → α) :\n    v ⬝ᵥ x • w = x • (v ⬝ᵥ w) := by simp [dotProduct, Finset.smul_sum, mul_smul_comm]\n\n"}
{"name":"Matrix.dotProduct_smul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\nα : Type v\ninst✝⁵ : Fintype m\ninst✝⁴ : Monoid R\ninst✝³ : Mul α\ninst✝² : AddCommMonoid α\ninst✝¹ : DistribMulAction R α\ninst✝ : SMulCommClass R α α\nx : R\nv w : m → α\n⊢ Eq (dotProduct v (HSMul.hSMul x w)) (HSMul.hSMul x (dotProduct v w))","decl":"@[deprecated (since := \"2024-12-12\")] protected alias Matrix.dotProduct_smul := dotProduct_smul\n\n"}
{"name":"Matrix.mul_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nM : Matrix l m α\nN : Matrix m n α\ni : l\nk : n\n⊢ Eq (HMul.hMul M N i k) (Finset.univ.sum fun j => HMul.hMul (M i j) (N j k))","decl":"theorem mul_apply [Fintype m] [Mul α] [AddCommMonoid α] {M : Matrix l m α} {N : Matrix m n α}\n    {i k} : (M * N) i k = ∑ j, M i j * N j k :=\n  rfl\n\n"}
{"name":"Matrix.mul_apply'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Fintype m\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nM : Matrix l m α\nN : Matrix m n α\ni : l\nk : n\n⊢ Eq (HMul.hMul M N i k) (dotProduct (fun j => M i j) fun j => N j k)","decl":"theorem mul_apply' [Fintype m] [Mul α] [AddCommMonoid α] {M : Matrix l m α} {N : Matrix m n α}\n    {i k} : (M * N) i k = (fun j => M i j) ⬝ᵥ fun j => N j k :=\n  rfl\n\n"}
{"name":"Matrix.two_mul_expl","module":"Mathlib.Data.Matrix.Mul","initialProofState":"R : Type u_10\ninst✝ : CommRing R\nA B : Matrix (Fin 2) (Fin 2) R\n⊢ And (Eq (HMul.hMul A B 0 0) (HAdd.hAdd (HMul.hMul (A 0 0) (B 0 0)) (HMul.hMul (A 0 1) (B 1 0)))) (And (Eq (HMul.hMul A B 0 1) (HAdd.hAdd (HMul.hMul (A 0 0) (B 0 1)) (HMul.hMul (A 0 1) (B 1 1)))) (And (Eq (HMul.hMul A B 1 0) (HAdd.hAdd (HMul.hMul (A 1 0) (B 0 0)) (HMul.hMul (A 1 1) (B 1 0)))) (Eq (HMul.hMul A B 1 1) (HAdd.hAdd (HMul.hMul (A 1 0) (B 0 1)) (HMul.hMul (A 1 1) (B 1 1))))))","decl":"theorem two_mul_expl {R : Type*} [CommRing R] (A B : Matrix (Fin 2) (Fin 2) R) :\n    (A * B) 0 0 = A 0 0 * B 0 0 + A 0 1 * B 1 0 ∧\n    (A * B) 0 1 = A 0 0 * B 0 1 + A 0 1 * B 1 1 ∧\n    (A * B) 1 0 = A 1 0 * B 0 0 + A 1 1 * B 1 0 ∧\n    (A * B) 1 1 = A 1 0 * B 0 1 + A 1 1 * B 1 1 := by\n  refine ⟨?_, ?_, ?_, ?_⟩ <;>\n  · rw [Matrix.mul_apply, Finset.sum_fin_eq_sum_range, Finset.sum_range_succ, Finset.sum_range_succ]\n    simp\n\n"}
{"name":"Matrix.smul_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : Mul α\ninst✝³ : Fintype n\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R α\ninst✝ : IsScalarTower R α α\na : R\nM : Matrix m n α\nN : Matrix n l α\n⊢ Eq (HMul.hMul (HSMul.hSMul a M) N) (HSMul.hSMul a (HMul.hMul M N))","decl":"@[simp]\ntheorem smul_mul [Fintype n] [Monoid R] [DistribMulAction R α] [IsScalarTower R α α] (a : R)\n    (M : Matrix m n α) (N : Matrix n l α) : (a • M) * N = a • (M * N) := by\n  ext\n  apply smul_dotProduct a\n\n"}
{"name":"Matrix.mul_smul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : Mul α\ninst✝³ : Fintype n\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R α\ninst✝ : SMulCommClass R α α\nM : Matrix m n α\na : R\nN : Matrix n l α\n⊢ Eq (HMul.hMul M (HSMul.hSMul a N)) (HSMul.hSMul a (HMul.hMul M N))","decl":"@[simp]\ntheorem mul_smul [Fintype n] [Monoid R] [DistribMulAction R α] [SMulCommClass R α α]\n    (M : Matrix m n α) (a : R) (N : Matrix n l α) : M * (a • N) = a • (M * N) := by\n  ext\n  apply dotProduct_smul\n\n"}
{"name":"Matrix.mul_zero","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nM : Matrix m n α\n⊢ Eq (HMul.hMul M 0) 0","decl":"@[simp]\nprotected theorem mul_zero [Fintype n] (M : Matrix m n α) : M * (0 : Matrix n o α) = 0 := by\n  ext\n  apply dotProduct_zero\n\n"}
{"name":"Matrix.zero_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nM : Matrix m n α\n⊢ Eq (HMul.hMul 0 M) 0","decl":"@[simp]\nprotected theorem zero_mul [Fintype m] (M : Matrix m n α) : (0 : Matrix l m α) * M = 0 := by\n  ext\n  apply zero_dotProduct\n\n"}
{"name":"Matrix.mul_add","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nL : Matrix m n α\nM N : Matrix n o α\n⊢ Eq (HMul.hMul L (HAdd.hAdd M N)) (HAdd.hAdd (HMul.hMul L M) (HMul.hMul L N))","decl":"protected theorem mul_add [Fintype n] (L : Matrix m n α) (M N : Matrix n o α) :\n    L * (M + N) = L * M + L * N := by\n  ext\n  apply dotProduct_add\n\n"}
{"name":"Matrix.add_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nL M : Matrix l m α\nN : Matrix m n α\n⊢ Eq (HMul.hMul (HAdd.hAdd L M) N) (HAdd.hAdd (HMul.hMul L N) (HMul.hMul M N))","decl":"protected theorem add_mul [Fintype m] (L M : Matrix l m α) (N : Matrix m n α) :\n    (L + M) * N = L * N + M * N := by\n  ext\n  apply add_dotProduct\n\n"}
{"name":"Matrix.diagonal_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nd : m → α\nM : Matrix m n α\ni : m\nj : n\n⊢ Eq (HMul.hMul (Matrix.diagonal d) M i j) (HMul.hMul (d i) (M i j))","decl":"@[simp]\ntheorem diagonal_mul [Fintype m] [DecidableEq m] (d : m → α) (M : Matrix m n α) (i j) :\n    (diagonal d * M) i j = d i * M i j :=\n  diagonal_dotProduct _ _ _\n\n"}
{"name":"Matrix.mul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nd : n → α\nM : Matrix m n α\ni : m\nj : n\n⊢ Eq (HMul.hMul M (Matrix.diagonal d) i j) (HMul.hMul (M i j) (d j))","decl":"@[simp]\ntheorem mul_diagonal [Fintype n] [DecidableEq n] (d : n → α) (M : Matrix m n α) (i j) :\n    (M * diagonal d) i j = M i j * d j := by\n  rw [← diagonal_transpose]\n  apply dotProduct_diagonal\n\n"}
{"name":"Matrix.diagonal_mul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nd₁ d₂ : n → α\n⊢ Eq (HMul.hMul (Matrix.diagonal d₁) (Matrix.diagonal d₂)) (Matrix.diagonal fun i => HMul.hMul (d₁ i) (d₂ i))","decl":"@[simp]\ntheorem diagonal_mul_diagonal [Fintype n] [DecidableEq n] (d₁ d₂ : n → α) :\n    diagonal d₁ * diagonal d₂ = diagonal fun i => d₁ i * d₂ i := by\n  ext i j\n  by_cases h : i = j <;>\n  simp [h]\n\n"}
{"name":"Matrix.diagonal_mul_diagonal'","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nd₁ d₂ : n → α\n⊢ Eq (HMul.hMul (Matrix.diagonal d₁) (Matrix.diagonal d₂)) (Matrix.diagonal fun i => HMul.hMul (d₁ i) (d₂ i))","decl":"theorem diagonal_mul_diagonal' [Fintype n] [DecidableEq n] (d₁ d₂ : n → α) :\n    diagonal d₁ * diagonal d₂ = diagonal fun i => d₁ i * d₂ i :=\n  diagonal_mul_diagonal _ _\n\n"}
{"name":"Matrix.smul_eq_diagonal_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n α\na : α\n⊢ Eq (HSMul.hSMul a M) (HMul.hMul (Matrix.diagonal fun x => a) M)","decl":"theorem smul_eq_diagonal_mul [Fintype m] [DecidableEq m] (M : Matrix m n α) (a : α) :\n    a • M = (diagonal fun _ => a) * M := by\n  ext\n  simp\n\n"}
{"name":"Matrix.op_smul_eq_mul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n α\na : α\n⊢ Eq (HSMul.hSMul (MulOpposite.op a) M) (HMul.hMul M (Matrix.diagonal fun x => a))","decl":"theorem op_smul_eq_mul_diagonal [Fintype n] [DecidableEq n] (M : Matrix m n α) (a : α) :\n    MulOpposite.op a • M = M * (diagonal fun _ : n => a) := by\n  ext\n  simp\n\n"}
{"name":"Matrix.addMonoidHomMulLeft_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nM : Matrix l m α\nx : Matrix m n α\n⊢ Eq (M.addMonoidHomMulLeft x) (HMul.hMul M x)","decl":"/-- Left multiplication by a matrix, as an `AddMonoidHom` from matrices to matrices. -/\n@[simps]\ndef addMonoidHomMulLeft [Fintype m] (M : Matrix l m α) : Matrix m n α →+ Matrix l n α where\n  toFun x := M * x\n  map_zero' := Matrix.mul_zero _\n  map_add' := Matrix.mul_add _\n\n"}
{"name":"Matrix.addMonoidHomMulRight_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nM : Matrix m n α\nx : Matrix l m α\n⊢ Eq (M.addMonoidHomMulRight x) (HMul.hMul x M)","decl":"/-- Right multiplication by a matrix, as an `AddMonoidHom` from matrices to matrices. -/\n@[simps]\ndef addMonoidHomMulRight [Fintype m] (M : Matrix m n α) : Matrix l m α →+ Matrix l n α where\n  toFun x := x * M\n  map_zero' := Matrix.zero_mul _\n  map_add' _ _ := Matrix.add_mul _ _ _\n\n"}
{"name":"Matrix.sum_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\ns : Finset β\nf : β → Matrix l m α\nM : Matrix m n α\n⊢ Eq (HMul.hMul (s.sum fun a => f a) M) (s.sum fun a => HMul.hMul (f a) M)","decl":"protected theorem sum_mul [Fintype m] (s : Finset β) (f : β → Matrix l m α) (M : Matrix m n α) :\n    (∑ a ∈ s, f a) * M = ∑ a ∈ s, f a * M :=\n  map_sum (addMonoidHomMulRight M) f s\n\n"}
{"name":"Matrix.mul_sum","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\ns : Finset β\nf : β → Matrix m n α\nM : Matrix l m α\n⊢ Eq (HMul.hMul M (s.sum fun a => f a)) (s.sum fun a => HMul.hMul M (f a))","decl":"protected theorem mul_sum [Fintype m] (s : Finset β) (f : β → Matrix m n α) (M : Matrix l m α) :\n    (M * ∑ a ∈ s, f a) = ∑ a ∈ s, M * f a :=\n  map_sum (addMonoidHomMulLeft M) f s\n\n"}
{"name":"Matrix.Semiring.isScalarTower","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : NonUnitalNonAssocSemiring α\ninst✝³ : Fintype n\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R α\ninst✝ : IsScalarTower R α α\n⊢ IsScalarTower R (Matrix n n α) (Matrix n n α)","decl":"/-- This instance enables use with `smul_mul_assoc`. -/\ninstance Semiring.isScalarTower [Fintype n] [Monoid R] [DistribMulAction R α]\n    [IsScalarTower R α α] : IsScalarTower R (Matrix n n α) (Matrix n n α) :=\n  ⟨fun r m n => Matrix.smul_mul r m n⟩\n\n"}
{"name":"Matrix.Semiring.smulCommClass","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : NonUnitalNonAssocSemiring α\ninst✝³ : Fintype n\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R α\ninst✝ : SMulCommClass R α α\n⊢ SMulCommClass R (Matrix n n α) (Matrix n n α)","decl":"/-- This instance enables use with `mul_smul_comm`. -/\ninstance Semiring.smulCommClass [Fintype n] [Monoid R] [DistribMulAction R α]\n    [SMulCommClass R α α] : SMulCommClass R (Matrix n n α) (Matrix n n α) :=\n  ⟨fun r m n => (Matrix.mul_smul m r n).symm⟩\n\n"}
{"name":"Matrix.one_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n α\n⊢ Eq (HMul.hMul 1 M) M","decl":"@[simp]\nprotected theorem one_mul [Fintype m] [DecidableEq m] (M : Matrix m n α) :\n    (1 : Matrix m m α) * M = M := by\n  ext\n  rw [← diagonal_one, diagonal_mul, one_mul]\n\n"}
{"name":"Matrix.mul_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n α\n⊢ Eq (HMul.hMul M 1) M","decl":"@[simp]\nprotected theorem mul_one [Fintype n] [DecidableEq n] (M : Matrix m n α) :\n    M * (1 : Matrix n n α) = M := by\n  ext\n  rw [← diagonal_one, mul_diagonal, mul_one]\n\n"}
{"name":"Matrix.map_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nβ : Type w\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype n\nL : Matrix m n α\nM : Matrix n o α\ninst✝ : NonAssocSemiring β\nf : RingHom α β\n⊢ Eq ((HMul.hMul L M).map ⇑f) (HMul.hMul (L.map ⇑f) (M.map ⇑f))","decl":"@[simp]\ntheorem map_mul [Fintype n] {L : Matrix m n α} {M : Matrix n o α} [NonAssocSemiring β]\n    {f : α →+* β} : (L * M).map f = L.map f * M.map f := by\n  ext\n  simp [mul_apply, map_sum]\n\n"}
{"name":"Matrix.smul_one_eq_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq m\na : α\n⊢ Eq (HSMul.hSMul a 1) (Matrix.diagonal fun x => a)","decl":"theorem smul_one_eq_diagonal [DecidableEq m] (a : α) :\n    a • (1 : Matrix m m α) = diagonal fun _ => a := by\n  simp_rw [← diagonal_one, ← diagonal_smul, Pi.smul_def, smul_eq_mul, mul_one]\n\n"}
{"name":"Matrix.op_smul_one_eq_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq m\na : α\n⊢ Eq (HSMul.hSMul (MulOpposite.op a) 1) (Matrix.diagonal fun x => a)","decl":"theorem op_smul_one_eq_diagonal [DecidableEq m] (a : α) :\n    MulOpposite.op a • (1 : Matrix m m α) = diagonal fun _ => a := by\n  simp_rw [← diagonal_one, ← diagonal_smul, Pi.smul_def, op_smul_eq_mul, one_mul]\n\n"}
{"name":"Matrix.mul_assoc","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nL : Matrix l m α\nM : Matrix m n α\nN : Matrix n o α\n⊢ Eq (HMul.hMul (HMul.hMul L M) N) (HMul.hMul L (HMul.hMul M N))","decl":"protected theorem mul_assoc (L : Matrix l m α) (M : Matrix m n α) (N : Matrix n o α) :\n    L * M * N = L * (M * N) := by\n  ext\n  apply dotProduct_assoc\n\n"}
{"name":"Matrix.neg_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nM : Matrix m n α\nN : Matrix n o α\n⊢ Eq (HMul.hMul (Neg.neg M) N) (Neg.neg (HMul.hMul M N))","decl":"@[simp]\nprotected theorem neg_mul (M : Matrix m n α) (N : Matrix n o α) : (-M) * N = -(M * N) := by\n  ext\n  apply neg_dotProduct\n\n"}
{"name":"Matrix.mul_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nM : Matrix m n α\nN : Matrix n o α\n⊢ Eq (HMul.hMul M (Neg.neg N)) (Neg.neg (HMul.hMul M N))","decl":"@[simp]\nprotected theorem mul_neg (M : Matrix m n α) (N : Matrix n o α) : M * (-N) = -(M * N) := by\n  ext\n  apply dotProduct_neg\n\n"}
{"name":"Matrix.sub_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nM M' : Matrix m n α\nN : Matrix n o α\n⊢ Eq (HMul.hMul (HSub.hSub M M') N) (HSub.hSub (HMul.hMul M N) (HMul.hMul M' N))","decl":"protected theorem sub_mul (M M' : Matrix m n α) (N : Matrix n o α) :\n    (M - M') * N = M * N - M' * N := by\n  rw [sub_eq_add_neg, Matrix.add_mul, Matrix.neg_mul, sub_eq_add_neg]\n\n"}
{"name":"Matrix.mul_sub","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nM : Matrix m n α\nN N' : Matrix n o α\n⊢ Eq (HMul.hMul M (HSub.hSub N N')) (HSub.hSub (HMul.hMul M N) (HMul.hMul M N'))","decl":"protected theorem mul_sub (M : Matrix m n α) (N N' : Matrix n o α) :\n    M * (N - N') = M * N - M * N' := by\n  rw [sub_eq_add_neg, Matrix.mul_add, Matrix.mul_neg, sub_eq_add_neg]\n\n"}
{"name":"Matrix.mul_mul_left","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : Semiring α\ninst✝ : Fintype n\nM : Matrix m n α\nN : Matrix n o α\na : α\n⊢ Eq (HMul.hMul (Matrix.of fun i j => HMul.hMul a (M i j)) N) (HSMul.hSMul a (HMul.hMul M N))","decl":"@[simp]\ntheorem mul_mul_left [Fintype n] (M : Matrix m n α) (N : Matrix n o α) (a : α) :\n    (of fun i j => a * M i j) * N = a • (M * N) :=\n  smul_mul a M N\n\n"}
{"name":"Matrix.smul_eq_mul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : CommSemiring α\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n α\na : α\n⊢ Eq (HSMul.hSMul a M) (HMul.hMul M (Matrix.diagonal fun x => a))","decl":"theorem smul_eq_mul_diagonal [Fintype n] [DecidableEq n] (M : Matrix m n α) (a : α) :\n    a • M = M * diagonal fun _ => a := by\n  ext\n  simp [mul_comm]\n\n"}
{"name":"Matrix.mul_mul_right","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : CommSemiring α\ninst✝ : Fintype n\nM : Matrix m n α\nN : Matrix n o α\na : α\n⊢ Eq (HMul.hMul M (Matrix.of fun i j => HMul.hMul a (N i j))) (HSMul.hSMul a (HMul.hMul M N))","decl":"@[simp]\ntheorem mul_mul_right [Fintype n] (M : Matrix m n α) (N : Matrix n o α) (a : α) :\n    (M * of fun i j => a * N i j) = a • (M * N) :=\n  mul_smul M a N\n\n"}
{"name":"Matrix.vecMulVec_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Mul α\nw : m → α\nv : n → α\ni : m\nj : n\n⊢ Eq (Matrix.vecMulVec w v i j) (HMul.hMul (w i) (v j))","decl":"theorem vecMulVec_apply [Mul α] (w : m → α) (v : n → α) (i j) : vecMulVec w v i j = w i * v j :=\n  rfl\n\n"}
{"name":"Matrix.mulVec.addMonoidHomLeft_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nv : n → α\nM : Matrix m n α\na✝ : m\n⊢ Eq ((Matrix.mulVec.addMonoidHomLeft v) M a✝) (M.mulVec v a✝)","decl":"/-- Left multiplication by a matrix, as an `AddMonoidHom` from vectors to vectors. -/\n@[simps]\ndef mulVec.addMonoidHomLeft [Fintype n] (v : n → α) : Matrix m n α →+ m → α where\n  toFun M := M *ᵥ v\n  map_zero' := by\n    ext\n    simp [mulVec]\n  map_add' x y := by\n    ext m\n    apply add_dotProduct\n\n"}
{"name":"Matrix.mul_apply_eq_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\nB : Matrix n o α\ni : m\n⊢ Eq (HMul.hMul A B i) (Matrix.vecMul (A i) B)","decl":"/-- The `i`th row of the multiplication is the same as the `vecMul` with the `i`th row of `A`. -/\ntheorem mul_apply_eq_vecMul [Fintype n] (A : Matrix m n α) (B : Matrix n o α) (i : m) :\n    (A * B) i = A i ᵥ* B :=\n  rfl\n\n"}
{"name":"Matrix.vecMul_eq_sum","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nv : m → α\nM : Matrix m n α\n⊢ Eq (Matrix.vecMul v M) (Finset.univ.sum fun i => HSMul.hSMul (v i) (M i))","decl":"theorem vecMul_eq_sum [Fintype m] (v : m → α) (M : Matrix m n α) : v ᵥ* M = ∑ i, v i • M i :=\n  (Finset.sum_fn ..).symm\n\n"}
{"name":"Matrix.mulVec_eq_sum","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nv : n → α\nM : Matrix m n α\n⊢ Eq (M.mulVec v) (Finset.univ.sum fun i => HSMul.hSMul (MulOpposite.op (v i)) (M.transpose i))","decl":"theorem mulVec_eq_sum [Fintype n] (v : n → α) (M : Matrix m n α) :\n    M *ᵥ v = ∑ i, MulOpposite.op (v i) • Mᵀ i :=\n  (Finset.sum_fn ..).symm\n\n"}
{"name":"Matrix.mulVec_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nv w : m → α\nx : m\n⊢ Eq ((Matrix.diagonal v).mulVec w x) (HMul.hMul (v x) (w x))","decl":"theorem mulVec_diagonal [Fintype m] [DecidableEq m] (v w : m → α) (x : m) :\n    (diagonal v *ᵥ w) x = v x * w x :=\n  diagonal_dotProduct v w x\n\n"}
{"name":"Matrix.vecMul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nv w : m → α\nx : m\n⊢ Eq (Matrix.vecMul v (Matrix.diagonal w) x) (HMul.hMul (v x) (w x))","decl":"theorem vecMul_diagonal [Fintype m] [DecidableEq m] (v w : m → α) (x : m) :\n    (v ᵥ* diagonal w) x = v x * w x :=\n  dotProduct_diagonal' v w x\n\n"}
{"name":"Matrix.dotProduct_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : NonUnitalSemiring R\nv : m → R\nA : Matrix m n R\nw : n → R\n⊢ Eq (dotProduct v (A.mulVec w)) (dotProduct (Matrix.vecMul v A) w)","decl":"/-- Associate the dot product of `mulVec` to the left. -/\ntheorem dotProduct_mulVec [Fintype n] [Fintype m] [NonUnitalSemiring R] (v : m → R)\n    (A : Matrix m n R) (w : n → R) : v ⬝ᵥ A *ᵥ w = v ᵥ* A ⬝ᵥ w := by\n  simp only [dotProduct, vecMul, mulVec, Finset.mul_sum, Finset.sum_mul, mul_assoc]\n  exact Finset.sum_comm\n\n"}
{"name":"Matrix.mulVec_zero","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\n⊢ Eq (A.mulVec 0) 0","decl":"@[simp]\ntheorem mulVec_zero [Fintype n] (A : Matrix m n α) : A *ᵥ 0 = 0 := by\n  ext\n  simp [mulVec]\n\n"}
{"name":"Matrix.zero_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul 0 A) 0","decl":"@[simp]\ntheorem zero_vecMul [Fintype m] (A : Matrix m n α) : 0 ᵥ* A = 0 := by\n  ext\n  simp [vecMul]\n\n"}
{"name":"Matrix.zero_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nv : n → α\n⊢ Eq (Matrix.mulVec 0 v) 0","decl":"@[simp]\ntheorem zero_mulVec [Fintype n] (v : n → α) : (0 : Matrix m n α) *ᵥ v = 0 := by\n  ext\n  simp [mulVec]\n\n"}
{"name":"Matrix.vecMul_zero","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nv : m → α\n⊢ Eq (Matrix.vecMul v 0) 0","decl":"@[simp]\ntheorem vecMul_zero [Fintype m] (v : m → α) : v ᵥ* (0 : Matrix m n α) = 0 := by\n  ext\n  simp [vecMul]\n\n"}
{"name":"Matrix.smul_mulVec_assoc","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝⁴ : NonUnitalNonAssocSemiring α\ninst✝³ : Fintype n\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R α\ninst✝ : IsScalarTower R α α\na : R\nA : Matrix m n α\nb : n → α\n⊢ Eq ((HSMul.hSMul a A).mulVec b) (HSMul.hSMul a (A.mulVec b))","decl":"theorem smul_mulVec_assoc [Fintype n] [Monoid R] [DistribMulAction R α] [IsScalarTower R α α]\n    (a : R) (A : Matrix m n α) (b : n → α) : (a • A) *ᵥ b = a • A *ᵥ b := by\n  ext\n  apply smul_dotProduct\n\n"}
{"name":"Matrix.mulVec_add","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\nx y : n → α\n⊢ Eq (A.mulVec (HAdd.hAdd x y)) (HAdd.hAdd (A.mulVec x) (A.mulVec y))","decl":"theorem mulVec_add [Fintype n] (A : Matrix m n α) (x y : n → α) :\n    A *ᵥ (x + y) = A *ᵥ x + A *ᵥ y := by\n  ext\n  apply dotProduct_add\n\n"}
{"name":"Matrix.add_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n\nA B : Matrix m n α\nx : n → α\n⊢ Eq ((HAdd.hAdd A B).mulVec x) (HAdd.hAdd (A.mulVec x) (B.mulVec x))","decl":"theorem add_mulVec [Fintype n] (A B : Matrix m n α) (x : n → α) :\n    (A + B) *ᵥ x = A *ᵥ x + B *ᵥ x := by\n  ext\n  apply add_dotProduct\n\n"}
{"name":"Matrix.vecMul_add","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nA B : Matrix m n α\nx : m → α\n⊢ Eq (Matrix.vecMul x (HAdd.hAdd A B)) (HAdd.hAdd (Matrix.vecMul x A) (Matrix.vecMul x B))","decl":"theorem vecMul_add [Fintype m] (A B : Matrix m n α) (x : m → α) :\n    x ᵥ* (A + B) = x ᵥ* A + x ᵥ* B := by\n  ext\n  apply dotProduct_add\n\n"}
{"name":"Matrix.add_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype m\nA : Matrix m n α\nx y : m → α\n⊢ Eq (Matrix.vecMul (HAdd.hAdd x y) A) (HAdd.hAdd (Matrix.vecMul x A) (Matrix.vecMul y A))","decl":"theorem add_vecMul [Fintype m] (A : Matrix m n α) (x y : m → α) :\n    (x + y) ᵥ* A = x ᵥ* A + y ᵥ* A := by\n  ext\n  apply add_dotProduct\n\n"}
{"name":"Matrix.vecMul_smul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝⁴ : Fintype n\ninst✝³ : Monoid R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : DistribMulAction R S\ninst✝ : IsScalarTower R S S\nM : Matrix n m S\nb : R\nv : n → S\n⊢ Eq (Matrix.vecMul (HSMul.hSMul b v) M) (HSMul.hSMul b (Matrix.vecMul v M))","decl":"theorem vecMul_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [IsScalarTower R S S] (M : Matrix n m S) (b : R) (v : n → S) :\n    (b • v) ᵥ* M = b • v ᵥ* M := by\n  ext i\n  simp only [vecMul, dotProduct, Finset.smul_sum, Pi.smul_apply, smul_mul_assoc]\n\n"}
{"name":"Matrix.mulVec_smul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝⁴ : Fintype n\ninst✝³ : Monoid R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : DistribMulAction R S\ninst✝ : SMulCommClass R S S\nM : Matrix m n S\nb : R\nv : n → S\n⊢ Eq (M.mulVec (HSMul.hSMul b v)) (HSMul.hSMul b (M.mulVec v))","decl":"theorem mulVec_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [SMulCommClass R S S] (M : Matrix m n S) (b : R) (v : n → S) :\n    M *ᵥ (b • v) = b • M *ᵥ v := by\n  ext i\n  simp only [mulVec, dotProduct, Finset.smul_sum, Pi.smul_apply, mul_smul_comm]\n\n"}
{"name":"Matrix.mulVec_single","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : NonUnitalNonAssocSemiring R\nM : Matrix m n R\nj : n\nx : R\n⊢ Eq (M.mulVec (Pi.single j x)) (HSMul.hSMul (MulOpposite.op x) (M.transpose j))","decl":"@[simp]\ntheorem mulVec_single [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (M : Matrix m n R)\n    (j : n) (x : R) : M *ᵥ Pi.single j x = MulOpposite.op x • Mᵀ j :=\n  funext fun _ => dotProduct_single _ _ _\n\n"}
{"name":"Matrix.single_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonUnitalNonAssocSemiring R\nM : Matrix m n R\ni : m\nx : R\n⊢ Eq (Matrix.vecMul (Pi.single i x) M) (HSMul.hSMul x (M i))","decl":"@[simp]\ntheorem single_vecMul [Fintype m] [DecidableEq m] [NonUnitalNonAssocSemiring R] (M : Matrix m n R)\n    (i : m) (x : R) : Pi.single i x ᵥ* M = x • M i :=\n  funext fun _ => single_dotProduct _ _ _\n\n"}
{"name":"Matrix.mulVec_single_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : NonAssocSemiring R\nM : Matrix m n R\nj : n\n⊢ Eq (M.mulVec (Pi.single j 1)) (M.transpose j)","decl":"theorem mulVec_single_one [Fintype n] [DecidableEq n] [NonAssocSemiring R]\n    (M : Matrix m n R) (j : n) :\n    M *ᵥ Pi.single j 1 = Mᵀ j := by ext; simp\n\n"}
{"name":"Matrix.single_one_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : NonAssocSemiring R\ni : m\nM : Matrix m n R\n⊢ Eq (Matrix.vecMul (Pi.single i 1) M) (M i)","decl":"theorem single_one_vecMul [Fintype m] [DecidableEq m] [NonAssocSemiring R]\n    (i : m) (M : Matrix m n R) :\n    Pi.single i 1 ᵥ* M = M i := by ext; simp\n\n"}
{"name":"Matrix.diagonal_mulVec_single","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nR : Type u_7\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : NonUnitalNonAssocSemiring R\nv : n → R\nj : n\nx : R\n⊢ Eq ((Matrix.diagonal v).mulVec (Pi.single j x)) (Pi.single j (HMul.hMul (v j) x))","decl":"theorem diagonal_mulVec_single [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n → R)\n    (j : n) (x : R) : diagonal v *ᵥ Pi.single j x = Pi.single j (v j * x) := by\n  ext i\n  rw [mulVec_diagonal]\n  exact Pi.apply_single (fun i x => v i * x) (fun i => mul_zero _) j x i\n\n"}
{"name":"Matrix.single_vecMul_diagonal","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nR : Type u_7\ninst✝² : Fintype n\ninst✝¹ : DecidableEq n\ninst✝ : NonUnitalNonAssocSemiring R\nv : n → R\nj : n\nx : R\n⊢ Eq (Matrix.vecMul (Pi.single j x) (Matrix.diagonal v)) (Pi.single j (HMul.hMul x (v j)))","decl":"theorem single_vecMul_diagonal [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n → R)\n    (j : n) (x : R) : (Pi.single j x) ᵥ* (diagonal v) = Pi.single j (x * v j) := by\n  ext i\n  rw [vecMul_diagonal]\n  exact Pi.apply_single (fun i x => x * v i) (fun i => zero_mul _) j x i\n\n"}
{"name":"Matrix.vecMul_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype n\ninst✝ : Fintype m\nv : m → α\nM : Matrix m n α\nN : Matrix n o α\n⊢ Eq (Matrix.vecMul (Matrix.vecMul v M) N) (Matrix.vecMul v (HMul.hMul M N))","decl":"@[simp]\ntheorem vecMul_vecMul [Fintype n] [Fintype m] (v : m → α) (M : Matrix m n α) (N : Matrix n o α) :\n    v ᵥ* M ᵥ* N = v ᵥ* (M * N) := by\n  ext\n  apply dotProduct_assoc\n\n"}
{"name":"Matrix.mulVec_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : NonUnitalSemiring α\ninst✝¹ : Fintype n\ninst✝ : Fintype o\nv : o → α\nM : Matrix m n α\nN : Matrix n o α\n⊢ Eq (M.mulVec (N.mulVec v)) ((HMul.hMul M N).mulVec v)","decl":"@[simp]\ntheorem mulVec_mulVec [Fintype n] [Fintype o] (v : o → α) (M : Matrix m n α) (N : Matrix n o α) :\n    M *ᵥ N *ᵥ v = (M * N) *ᵥ v := by\n  ext\n  symm\n  apply dotProduct_assoc\n\n"}
{"name":"Matrix.mul_mul_apply","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nα : Type v\ninst✝¹ : NonUnitalSemiring α\ninst✝ : Fintype n\nA B C : Matrix n n α\ni j : n\n⊢ Eq (HMul.hMul (HMul.hMul A B) C i j) (dotProduct (A i) (B.mulVec (C.transpose j)))","decl":"theorem mul_mul_apply [Fintype n] (A B C : Matrix n n α) (i j : n) :\n    (A * B * C) i j = A i ⬝ᵥ B *ᵥ (Cᵀ j) := by\n  rw [Matrix.mul_assoc]\n  simp only [mul_apply, dotProduct, mulVec]\n  rfl\n\n"}
{"name":"Matrix.mulVec_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonAssocSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\n⊢ Eq (A.mulVec 1) (Finset.univ.sum fun j => A.transpose j)","decl":"theorem mulVec_one [Fintype n] (A : Matrix m n α) : A *ᵥ 1 = ∑ j, Aᵀ j := by\n  ext; simp [mulVec, dotProduct]\n\n"}
{"name":"Matrix.one_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonAssocSemiring α\ninst✝ : Fintype m\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul 1 A) (Finset.univ.sum fun i => A i)","decl":"theorem one_vecMul [Fintype m] (A : Matrix m n α) : 1 ᵥ* A = ∑ i, A i := by\n  ext; simp [vecMul, dotProduct]\n\n"}
{"name":"Matrix.vec_one_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonAssocSemiring α\ninst✝ : Fintype m\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul 1 A) (Finset.univ.sum fun i => A i)","decl":"@[deprecated (since := \"2025-01-26\")] alias vec_one_mul := one_vecMul\n\n"}
{"name":"Matrix.ext_of_mulVec_single","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM N : Matrix m n α\nh : ∀ (i : n), Eq (M.mulVec (Pi.single i 1)) (N.mulVec (Pi.single i 1))\n⊢ Eq M N","decl":"lemma ext_of_mulVec_single [DecidableEq n] [Fintype n] {M N : Matrix m n α}\n    (h : ∀ i, M *ᵥ Pi.single i 1 = N *ᵥ Pi.single i 1) :\n    M = N := by\n  ext i j\n  simp_rw [mulVec_single_one] at h\n  exact congrFun (h j) i\n\n"}
{"name":"Matrix.ext_of_single_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\nM N : Matrix m n α\nh : ∀ (i : m), Eq (Matrix.vecMul (Pi.single i 1) M) (Matrix.vecMul (Pi.single i 1) N)\n⊢ Eq M N","decl":"lemma ext_of_single_vecMul [DecidableEq m] [Fintype m] {M N : Matrix m n α}\n    (h : ∀ i, Pi.single i 1 ᵥ* M = Pi.single i 1 ᵥ* N) :\n    M = N := by\n  ext i j\n  simp_rw [single_one_vecMul] at h\n  exact congrFun (h i) j\n\n"}
{"name":"Matrix.one_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nv : m → α\n⊢ Eq (Matrix.mulVec 1 v) v","decl":"@[simp]\ntheorem one_mulVec (v : m → α) : 1 *ᵥ v = v := by\n  ext\n  rw [← diagonal_one, mulVec_diagonal, one_mul]\n\n"}
{"name":"Matrix.vecMul_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nv : m → α\n⊢ Eq (Matrix.vecMul v 1) v","decl":"@[simp]\ntheorem vecMul_one (v : m → α) : v ᵥ* 1 = v := by\n  ext\n  rw [← diagonal_one, vecMul_diagonal, mul_one]\n\n"}
{"name":"Matrix.diagonal_const_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : α\nv : m → α\n⊢ Eq ((Matrix.diagonal fun x_1 => x).mulVec v) (HSMul.hSMul x v)","decl":"@[simp]\ntheorem diagonal_const_mulVec (x : α) (v : m → α) :\n    (diagonal fun _ => x) *ᵥ v = x • v := by\n  ext; simp [mulVec_diagonal]\n\n"}
{"name":"Matrix.vecMul_diagonal_const","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : α\nv : m → α\n⊢ Eq (Matrix.vecMul v (Matrix.diagonal fun x_1 => x)) (HSMul.hSMul (MulOpposite.op x) v)","decl":"@[simp]\ntheorem vecMul_diagonal_const (x : α) (v : m → α) :\n    v ᵥ* (diagonal fun _ => x) = MulOpposite.op x • v := by\n  ext; simp [vecMul_diagonal]\n\n"}
{"name":"Matrix.natCast_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : Nat\nv : m → α\n⊢ Eq ((↑x).mulVec v) (HSMul.hSMul (↑x) v)","decl":"@[simp]\ntheorem natCast_mulVec (x : ℕ) (v : m → α) : x *ᵥ v = (x : α) • v :=\n  diagonal_const_mulVec _ _\n\n"}
{"name":"Matrix.vecMul_natCast","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocSemiring α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : Nat\nv : m → α\n⊢ Eq (Matrix.vecMul v ↑x) (HSMul.hSMul (MulOpposite.op ↑x) v)","decl":"@[simp]\ntheorem vecMul_natCast (x : ℕ) (v : m → α) : v ᵥ* x = MulOpposite.op (x : α) • v :=\n  vecMul_diagonal_const _ _\n\n\n"}
{"name":"Matrix.ofNat_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝³ : NonAssocSemiring α\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\nx : Nat\ninst✝ : x.AtLeastTwo\nv : m → α\n⊢ Eq ((OfNat.ofNat x).mulVec v) (HSMul.hSMul (OfNat.ofNat x) v)","decl":"@[simp]\ntheorem ofNat_mulVec (x : ℕ) [x.AtLeastTwo] (v : m → α) :\n    ofNat(x) *ᵥ v = (OfNat.ofNat x : α) • v :=\n  natCast_mulVec _ _\n\n"}
{"name":"Matrix.vecMul_ofNat","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝³ : NonAssocSemiring α\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\nx : Nat\ninst✝ : x.AtLeastTwo\nv : m → α\n⊢ Eq (Matrix.vecMul v (OfNat.ofNat x)) (HSMul.hSMul (MulOpposite.op (OfNat.ofNat x)) v)","decl":"@[simp]\ntheorem vecMul_ofNat (x : ℕ) [x.AtLeastTwo] (v : m → α) :\n    v ᵥ* ofNat(x) = MulOpposite.op (OfNat.ofNat x : α) • v :=\n  vecMul_natCast _ _\n\n"}
{"name":"Matrix.neg_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype m\nv : m → α\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul (Neg.neg v) A) (Neg.neg (Matrix.vecMul v A))","decl":"theorem neg_vecMul [Fintype m] (v : m → α) (A : Matrix m n α) : (-v) ᵥ* A = - (v ᵥ* A) := by\n  ext\n  apply neg_dotProduct\n\n"}
{"name":"Matrix.vecMul_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype m\nv : m → α\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul v (Neg.neg A)) (Neg.neg (Matrix.vecMul v A))","decl":"theorem vecMul_neg [Fintype m] (v : m → α) (A : Matrix m n α) : v ᵥ* (-A) = - (v ᵥ* A) := by\n  ext\n  apply dotProduct_neg\n\n"}
{"name":"Matrix.neg_vecMul_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype m\nv : m → α\nA : Matrix m n α\n⊢ Eq (Matrix.vecMul (Neg.neg v) (Neg.neg A)) (Matrix.vecMul v A)","decl":"lemma neg_vecMul_neg [Fintype m] (v : m → α) (A : Matrix m n α) : (-v) ᵥ* (-A) = v ᵥ* A := by\n  rw [vecMul_neg, neg_vecMul, neg_neg]\n\n"}
{"name":"Matrix.neg_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nv : n → α\nA : Matrix m n α\n⊢ Eq ((Neg.neg A).mulVec v) (Neg.neg (A.mulVec v))","decl":"theorem neg_mulVec [Fintype n] (v : n → α) (A : Matrix m n α) : (-A) *ᵥ v = - (A *ᵥ v) := by\n  ext\n  apply neg_dotProduct\n\n"}
{"name":"Matrix.mulVec_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nv : n → α\nA : Matrix m n α\n⊢ Eq (A.mulVec (Neg.neg v)) (Neg.neg (A.mulVec v))","decl":"theorem mulVec_neg [Fintype n] (v : n → α) (A : Matrix m n α) : A *ᵥ (-v) = - (A *ᵥ v) := by\n  ext\n  apply dotProduct_neg\n\n"}
{"name":"Matrix.neg_mulVec_neg","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nv : n → α\nA : Matrix m n α\n⊢ Eq ((Neg.neg A).mulVec (Neg.neg v)) (A.mulVec v)","decl":"lemma neg_mulVec_neg [Fintype n] (v : n → α) (A : Matrix m n α) : (-A) *ᵥ (-v) = A *ᵥ v := by\n  rw [mulVec_neg, neg_mulVec, neg_neg]\n\n"}
{"name":"Matrix.mulVec_sub","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nA : Matrix m n α\nx y : n → α\n⊢ Eq (A.mulVec (HSub.hSub x y)) (HSub.hSub (A.mulVec x) (A.mulVec y))","decl":"theorem mulVec_sub [Fintype n] (A : Matrix m n α) (x y : n → α) :\n    A *ᵥ (x - y) = A *ᵥ x - A *ᵥ y := by\n  ext\n  apply dotProduct_sub\n\n"}
{"name":"Matrix.sub_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype n\nA B : Matrix m n α\nx : n → α\n⊢ Eq ((HSub.hSub A B).mulVec x) (HSub.hSub (A.mulVec x) (B.mulVec x))","decl":"theorem sub_mulVec [Fintype n] (A B : Matrix m n α) (x : n → α) :\n    (A - B) *ᵥ x = A *ᵥ x - B *ᵥ x := by simp [sub_eq_add_neg, add_mulVec, neg_mulVec]\n\n"}
{"name":"Matrix.vecMul_sub","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype m\nA B : Matrix m n α\nx : m → α\n⊢ Eq (Matrix.vecMul x (HSub.hSub A B)) (HSub.hSub (Matrix.vecMul x A) (Matrix.vecMul x B))","decl":"theorem vecMul_sub [Fintype m] (A B : Matrix m n α) (x : m → α) :\n    x ᵥ* (A - B) = x ᵥ* A - x ᵥ* B := by simp [sub_eq_add_neg, vecMul_add, vecMul_neg]\n\n"}
{"name":"Matrix.sub_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalNonAssocRing α\ninst✝ : Fintype m\nA : Matrix m n α\nx y : m → α\n⊢ Eq (Matrix.vecMul (HSub.hSub x y) A) (HSub.hSub (Matrix.vecMul x A) (Matrix.vecMul y A))","decl":"theorem sub_vecMul [Fintype m] (A : Matrix m n α) (x y : m → α) :\n    (x - y) ᵥ* A = x ᵥ* A - y ᵥ* A := by\n  ext\n  apply sub_dotProduct\n\n"}
{"name":"Matrix.mulVec_transpose","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalCommSemiring α\ninst✝ : Fintype m\nA : Matrix m n α\nx : m → α\n⊢ Eq (A.transpose.mulVec x) (Matrix.vecMul x A)","decl":"theorem mulVec_transpose [Fintype m] (A : Matrix m n α) (x : m → α) : Aᵀ *ᵥ x = x ᵥ* A := by\n  ext\n  apply dotProduct_comm\n\n"}
{"name":"Matrix.vecMul_transpose","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : NonUnitalCommSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\nx : n → α\n⊢ Eq (Matrix.vecMul x A.transpose) (A.mulVec x)","decl":"theorem vecMul_transpose [Fintype n] (A : Matrix m n α) (x : n → α) : x ᵥ* Aᵀ = A *ᵥ x := by\n  ext\n  apply dotProduct_comm\n\n"}
{"name":"Matrix.mulVec_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : NonUnitalCommSemiring α\ninst✝¹ : Fintype n\ninst✝ : Fintype o\nA : Matrix m n α\nB : Matrix o n α\nx : o → α\n⊢ Eq (A.mulVec (Matrix.vecMul x B)) ((HMul.hMul A B.transpose).mulVec x)","decl":"theorem mulVec_vecMul [Fintype n] [Fintype o] (A : Matrix m n α) (B : Matrix o n α) (x : o → α) :\n    A *ᵥ (x ᵥ* B) = (A * Bᵀ) *ᵥ x := by rw [← mulVec_mulVec, mulVec_transpose]\n\n"}
{"name":"Matrix.vecMul_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : NonUnitalCommSemiring α\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nA : Matrix m n α\nB : Matrix m o α\nx : n → α\n⊢ Eq (Matrix.vecMul (A.mulVec x) B) (Matrix.vecMul x (HMul.hMul A.transpose B))","decl":"theorem vecMul_mulVec [Fintype m] [Fintype n] (A : Matrix m n α) (B : Matrix m o α) (x : n → α) :\n    (A *ᵥ x) ᵥ* B = x ᵥ* (Aᵀ * B) := by rw [← vecMul_vecMul, vecMul_transpose]\n\n"}
{"name":"Matrix.mulVec_injective_of_isUnit","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\ninst✝² : Semiring R\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m R\nha : IsUnit A\n⊢ Function.Injective A.mulVec","decl":"lemma mulVec_injective_of_isUnit [Fintype m] [DecidableEq m] {A : Matrix m m R}\n    (ha : IsUnit A) : Function.Injective A.mulVec := by\n  obtain ⟨B, hBl, hBr⟩ := isUnit_iff_exists.mp ha\n  intro x y hxy\n  simpa [hBr] using congrArg B.mulVec hxy\n\n"}
{"name":"Matrix.vecMul_injective_of_isUnit","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nR : Type u_7\ninst✝² : Semiring R\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nA : Matrix m m R\nha : IsUnit A\n⊢ Function.Injective fun v => Matrix.vecMul v A","decl":"lemma vecMul_injective_of_isUnit [Fintype m] [DecidableEq m] {A : Matrix m m R}\n    (ha : IsUnit A) : Function.Injective A.vecMul := by\n  obtain ⟨B, hBl, hBr⟩ := isUnit_iff_exists.mp ha\n  intro x y hxy\n  simpa [hBl] using congrArg B.vecMul hxy\n\n"}
{"name":"Matrix.mulVec_smul_assoc","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝¹ : CommSemiring α\ninst✝ : Fintype n\nA : Matrix m n α\nb : n → α\na : α\n⊢ Eq (A.mulVec (HSMul.hSMul a b)) (HSMul.hSMul a (A.mulVec b))","decl":"theorem mulVec_smul_assoc [Fintype n] (A : Matrix m n α) (b : n → α) (a : α) :\n    A *ᵥ (a • b) = a • A *ᵥ b := by\n  ext\n  apply dotProduct_smul\n\n"}
{"name":"Matrix.intCast_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : Int\nv : m → α\n⊢ Eq ((↑x).mulVec v) (HSMul.hSMul (↑x) v)","decl":"@[simp]\ntheorem intCast_mulVec (x : ℤ) (v : m → α) : x *ᵥ v = (x : α) • v :=\n  diagonal_const_mulVec _ _\n\n"}
{"name":"Matrix.vecMul_intCast","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nα : Type v\ninst✝² : NonAssocRing α\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nx : Int\nv : m → α\n⊢ Eq (Matrix.vecMul v ↑x) (HSMul.hSMul (MulOpposite.op ↑x) v)","decl":"@[simp]\ntheorem vecMul_intCast (x : ℤ) (v : m → α) : v ᵥ* x = MulOpposite.op (x : α) • v :=\n  vecMul_diagonal_const _ _\n\n"}
{"name":"Matrix.transpose_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : AddCommMonoid α\ninst✝¹ : CommSemigroup α\ninst✝ : Fintype n\nM : Matrix m n α\nN : Matrix n l α\n⊢ Eq (HMul.hMul M N).transpose (HMul.hMul N.transpose M.transpose)","decl":"@[simp]\ntheorem transpose_mul [AddCommMonoid α] [CommSemigroup α] [Fintype n] (M : Matrix m n α)\n    (N : Matrix n l α) : (M * N)ᵀ = Nᵀ * Mᵀ := by\n  ext\n  apply dotProduct_comm\n\n"}
{"name":"Matrix.submatrix_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\np : Type u_10\nq : Type u_11\nM : Matrix m n α\nN : Matrix n p α\ne₁ : l → m\ne₂ : o → n\ne₃ : q → p\nhe₂ : Function.Bijective e₂\n⊢ Eq ((HMul.hMul M N).submatrix e₁ e₃) (HMul.hMul (M.submatrix e₁ e₂) (N.submatrix e₂ e₃))","decl":"theorem submatrix_mul [Fintype n] [Fintype o] [Mul α] [AddCommMonoid α] {p q : Type*}\n    (M : Matrix m n α) (N : Matrix n p α) (e₁ : l → m) (e₂ : o → n) (e₃ : q → p)\n    (he₂ : Function.Bijective e₂) :\n    (M * N).submatrix e₁ e₃ = M.submatrix e₁ e₂ * N.submatrix e₂ e₃ :=\n  ext fun _ _ => (he₂.sum_comp _).symm\n\n"}
{"name":"Matrix.submatrix_mul_equiv","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\np : Type u_10\nq : Type u_11\nM : Matrix m n α\nN : Matrix n p α\ne₁ : l → m\ne₂ : Equiv o n\ne₃ : q → p\n⊢ Eq (HMul.hMul (M.submatrix e₁ ⇑e₂) (N.submatrix (⇑e₂) e₃)) ((HMul.hMul M N).submatrix e₁ e₃)","decl":"@[simp]\ntheorem submatrix_mul_equiv [Fintype n] [Fintype o] [AddCommMonoid α] [Mul α] {p q : Type*}\n    (M : Matrix m n α) (N : Matrix n p α) (e₁ : l → m) (e₂ : o ≃ n) (e₃ : q → p) :\n    M.submatrix e₁ e₂ * N.submatrix e₂ e₃ = (M * N).submatrix e₁ e₃ :=\n  (submatrix_mul M N e₁ e₂ e₃ e₂.bijective).symm\n\n"}
{"name":"Matrix.submatrix_mulVec_equiv","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : Fintype n\ninst✝¹ : Fintype o\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : o → α\ne₁ : l → m\ne₂ : Equiv o n\n⊢ Eq ((M.submatrix e₁ ⇑e₂).mulVec v) (Function.comp (M.mulVec (Function.comp v ⇑e₂.symm)) e₁)","decl":"theorem submatrix_mulVec_equiv [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring α]\n    (M : Matrix m n α) (v : o → α) (e₁ : l → m) (e₂ : o ≃ n) :\n    M.submatrix e₁ e₂ *ᵥ v = (M *ᵥ (v ∘ e₂.symm)) ∘ e₁ :=\n  funext fun _ => Eq.symm (dotProduct_comp_equiv_symm _ _ _)\n\n"}
{"name":"Matrix.submatrix_id_mul_left","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\np : Type u_10\nM : Matrix m n α\nN : Matrix o p α\ne₁ : l → m\ne₂ : Equiv n o\n⊢ Eq (HMul.hMul (M.submatrix e₁ id) (N.submatrix (⇑e₂) id)) (HMul.hMul (M.submatrix e₁ ⇑e₂.symm) N)","decl":"@[simp]\ntheorem submatrix_id_mul_left [Fintype n] [Fintype o] [Mul α] [AddCommMonoid α] {p : Type*}\n    (M : Matrix m n α) (N : Matrix o p α) (e₁ : l → m) (e₂ : n ≃ o) :\n    M.submatrix e₁ id * N.submatrix e₂ id = M.submatrix e₁ e₂.symm * N := by\n  ext; simp [mul_apply, ← e₂.bijective.sum_comp]\n\n"}
{"name":"Matrix.submatrix_id_mul_right","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Fintype o\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\np : Type u_10\nM : Matrix m n α\nN : Matrix o p α\ne₁ : l → p\ne₂ : Equiv o n\n⊢ Eq (HMul.hMul (M.submatrix id ⇑e₂) (N.submatrix id e₁)) (HMul.hMul M (N.submatrix (⇑e₂.symm) e₁))","decl":"@[simp]\ntheorem submatrix_id_mul_right [Fintype n] [Fintype o] [Mul α] [AddCommMonoid α] {p : Type*}\n    (M : Matrix m n α) (N : Matrix o p α) (e₁ : l → p) (e₂ : o ≃ n) :\n    M.submatrix id e₂ * N.submatrix id e₁ = M * N.submatrix e₂.symm e₁ := by\n  ext; simp [mul_apply, ← e₂.bijective.sum_comp]\n\n"}
{"name":"Matrix.submatrix_vecMul_equiv","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝² : Fintype l\ninst✝¹ : Fintype m\ninst✝ : NonUnitalNonAssocSemiring α\nM : Matrix m n α\nv : l → α\ne₁ : Equiv l m\ne₂ : o → n\n⊢ Eq (Matrix.vecMul v (M.submatrix (⇑e₁) e₂)) (Function.comp (Matrix.vecMul (Function.comp v ⇑e₁.symm) M) e₂)","decl":"theorem submatrix_vecMul_equiv [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring α]\n    (M : Matrix m n α) (v : l → α) (e₁ : l ≃ m) (e₂ : o → n) :\n    v ᵥ* M.submatrix e₁ e₂ = ((v ∘ e₁.symm) ᵥ* M) ∘ e₂ :=\n  funext fun _ => Eq.symm (comp_equiv_symm_dotProduct _ _ _)\n\n"}
{"name":"Matrix.mul_submatrix_one","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype n\ninst✝² : Finite o\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq o\ne₁ : Equiv n o\ne₂ : l → o\nM : Matrix m n α\n⊢ Eq (HMul.hMul M (Matrix.submatrix 1 (⇑e₁) e₂)) (M.submatrix id (Function.comp (⇑e₁.symm) e₂))","decl":"theorem mul_submatrix_one [Fintype n] [Finite o] [NonAssocSemiring α] [DecidableEq o] (e₁ : n ≃ o)\n    (e₂ : l → o) (M : Matrix m n α) :\n    M * (1 : Matrix o o α).submatrix e₁ e₂ = submatrix M id (e₁.symm ∘ e₂) := by\n  cases nonempty_fintype o\n  let A := M.submatrix id e₁.symm\n  have : M = A.submatrix id e₁ := by\n    simp only [A, submatrix_submatrix, Function.comp_id, submatrix_id_id, Equiv.symm_comp_self]\n  rw [this, submatrix_mul_equiv]\n  simp only [A, Matrix.mul_one, submatrix_submatrix, Function.comp_id, submatrix_id_id,\n    Equiv.symm_comp_self]\n\n"}
{"name":"Matrix.one_submatrix_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝³ : Fintype m\ninst✝² : Finite o\ninst✝¹ : NonAssocSemiring α\ninst✝ : DecidableEq o\ne₁ : l → o\ne₂ : Equiv m o\nM : Matrix m n α\n⊢ Eq (HMul.hMul (Matrix.submatrix 1 e₁ ⇑e₂) M) (M.submatrix (Function.comp (⇑e₂.symm) e₁) id)","decl":"theorem one_submatrix_mul [Fintype m] [Finite o] [NonAssocSemiring α] [DecidableEq o] (e₁ : l → o)\n    (e₂ : m ≃ o) (M : Matrix m n α) :\n    ((1 : Matrix o o α).submatrix e₁ e₂) * M = submatrix M (e₂.symm ∘ e₁) id := by\n  cases nonempty_fintype o\n  let A := M.submatrix e₂.symm id\n  have : M = A.submatrix e₂ id := by\n    simp only [A, submatrix_submatrix, Function.comp_id, submatrix_id_id, Equiv.symm_comp_self]\n  rw [this, submatrix_mul_equiv]\n  simp only [A, Matrix.one_mul, submatrix_submatrix, Function.comp_id, submatrix_id_id,\n    Equiv.symm_comp_self]\n\n"}
{"name":"Matrix.submatrix_mul_transpose_submatrix","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\ne : Equiv m n\nM : Matrix m n α\n⊢ Eq (HMul.hMul (M.submatrix id ⇑e) (M.transpose.submatrix (⇑e) id)) (HMul.hMul M M.transpose)","decl":"theorem submatrix_mul_transpose_submatrix [Fintype m] [Fintype n] [AddCommMonoid α] [Mul α]\n    (e : m ≃ n) (M : Matrix m n α) : M.submatrix id e * Mᵀ.submatrix e id = M * Mᵀ := by\n  rw [submatrix_mul_equiv, submatrix_id_id]\n\n"}
{"name":"RingHom.map_matrix_mul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nβ : Type w\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nM : Matrix m n α\nN : Matrix n o α\ni : m\nj : o\nf : RingHom α β\n⊢ Eq (f (HMul.hMul M N i j)) (HMul.hMul (M.map ⇑f) (N.map ⇑f) i j)","decl":"theorem map_matrix_mul (M : Matrix m n α) (N : Matrix n o α) (i : m) (j : o) (f : α →+* β) :\n    f ((M * N) i j) = (M.map f * N.map f) i j := by\n  simp [Matrix.mul_apply, map_sum]\n\n"}
{"name":"RingHom.map_dotProduct","module":"Mathlib.Data.Matrix.Mul","initialProofState":"n : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nv w : n → R\n⊢ Eq (f (dotProduct v w)) (dotProduct (Function.comp (⇑f) v) (Function.comp (⇑f) w))","decl":"theorem map_dotProduct [NonAssocSemiring R] [NonAssocSemiring S] (f : R →+* S) (v w : n → R) :\n    f (v ⬝ᵥ w) = f ∘ v ⬝ᵥ f ∘ w := by\n  simp only [dotProduct, map_sum f, f.map_mul, Function.comp]\n\n"}
{"name":"RingHom.map_vecMul","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nM : Matrix n m R\nv : n → R\ni : m\n⊢ Eq (f (Matrix.vecMul v M i)) (Matrix.vecMul (Function.comp (⇑f) v) (M.map ⇑f) i)","decl":"theorem map_vecMul [NonAssocSemiring R] [NonAssocSemiring S] (f : R →+* S) (M : Matrix n m R)\n    (v : n → R) (i : m) : f ((v ᵥ* M) i) =  ((f ∘ v) ᵥ* M.map f) i := by\n  simp only [Matrix.vecMul, Matrix.map_apply, RingHom.map_dotProduct, Function.comp_def]\n\n"}
{"name":"RingHom.map_mulVec","module":"Mathlib.Data.Matrix.Mul","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝² : Fintype n\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nM : Matrix m n R\nv : n → R\ni : m\n⊢ Eq (f (M.mulVec v i)) ((M.map ⇑f).mulVec (Function.comp (⇑f) v) i)","decl":"theorem map_mulVec [NonAssocSemiring R] [NonAssocSemiring S] (f : R →+* S) (M : Matrix m n R)\n    (v : n → R) (i : m) : f ((M *ᵥ v) i) = (M.map f *ᵥ (f ∘ v)) i := by\n  simp only [Matrix.mulVec, Matrix.map_apply, RingHom.map_dotProduct, Function.comp_def]\n\n"}
