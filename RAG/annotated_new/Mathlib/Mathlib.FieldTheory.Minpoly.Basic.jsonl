{"name":"minpoly.monic","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\nhx : IsIntegral A x\n⊢ (minpoly A x).Monic","decl":"/-- A minimal polynomial is monic. -/\ntheorem monic (hx : IsIntegral A x) : Monic (minpoly A x) := by\n  delta minpoly\n  rw [dif_pos hx]\n  exact (degree_lt_wf.min_mem _ hx).1\n\n"}
{"name":"minpoly.ne_zero","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial A\nhx : IsIntegral A x\n⊢ Ne (minpoly A x) 0","decl":"/-- A minimal polynomial is nonzero. -/\ntheorem ne_zero [Nontrivial A] (hx : IsIntegral A x) : minpoly A x ≠ 0 :=\n  (monic hx).ne_zero\n\n"}
{"name":"minpoly.eq_zero","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\nhx : Not (IsIntegral A x)\n⊢ Eq (minpoly A x) 0","decl":"theorem eq_zero (hx : ¬IsIntegral A x) : minpoly A x = 0 :=\n  dif_neg hx\n\n"}
{"name":"minpoly.ne_zero_iff","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial A\n⊢ Iff (Ne (minpoly A x) 0) (IsIntegral A x)","decl":"theorem ne_zero_iff [Nontrivial A] : minpoly A x ≠ 0 ↔ IsIntegral A x :=\n  ⟨fun h => of_not_not <| eq_zero.mt h, ne_zero⟩\n\n"}
{"name":"minpoly.algHom_eq","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Ring B\ninst✝² : Ring B'\ninst✝¹ : Algebra A B\ninst✝ : Algebra A B'\nf : AlgHom A B B'\nhf : Function.Injective ⇑f\nx : B\n⊢ Eq (minpoly A (f x)) (minpoly A x)","decl":"theorem algHom_eq (f : B →ₐ[A] B') (hf : Function.Injective f) (x : B) :\n    minpoly A (f x) = minpoly A x := by\n  classical\n  simp_rw [minpoly, isIntegral_algHom_iff _ hf, ← Polynomial.aeval_def, aeval_algHom,\n    AlgHom.comp_apply, _root_.map_eq_zero_iff f hf]\n\n"}
{"name":"minpoly.algebraMap_eq","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB' : Type u_3\ninst✝⁶ : CommRing A\ninst✝⁵ : Ring B'\ninst✝⁴ : Algebra A B'\nB : Type u_4\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Algebra B B'\ninst✝ : IsScalarTower A B B'\nh : Function.Injective ⇑(algebraMap B B')\nx : B\n⊢ Eq (minpoly A ((algebraMap B B') x)) (minpoly A x)","decl":"theorem algebraMap_eq {B} [CommRing B] [Algebra A B] [Algebra B B'] [IsScalarTower A B B']\n    (h : Function.Injective (algebraMap B B')) (x : B) :\n    minpoly A (algebraMap B B' x) = minpoly A x :=\n  algHom_eq (IsScalarTower.toAlgHom A B B') h x\n\n"}
{"name":"minpoly.algEquiv_eq","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Ring B\ninst✝² : Ring B'\ninst✝¹ : Algebra A B\ninst✝ : Algebra A B'\nf : AlgEquiv A B B'\nx : B\n⊢ Eq (minpoly A (f x)) (minpoly A x)","decl":"@[simp]\ntheorem algEquiv_eq (f : B ≃ₐ[A] B') (x : B) : minpoly A (f x) = minpoly A x :=\n  algHom_eq (f : B →ₐ[A] B') f.injective x\n\n"}
{"name":"minpoly.aeval","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\n⊢ Eq ((Polynomial.aeval x) (minpoly A x)) 0","decl":"/-- An element is a root of its minimal polynomial. -/\n@[simp]\ntheorem aeval : aeval x (minpoly A x) = 0 := by\n  delta minpoly\n  split_ifs with hx\n  · exact (degree_lt_wf.min_mem _ hx).2\n  · exact aeval_zero _\n\n"}
{"name":"minpoly.aeval_algHom","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\nB' : Type u_3\ninst✝⁴ : CommRing A\ninst✝³ : Ring B\ninst✝² : Ring B'\ninst✝¹ : Algebra A B\ninst✝ : Algebra A B'\nf : AlgHom A B B'\nx : B\n⊢ Eq ((Polynomial.aeval (f x)) (minpoly A x)) 0","decl":"/-- Given any `f : B →ₐ[A] B'` and any `x : L`, the minimal polynomial of `x` vanishes at `f x`. -/\n@[simp]\ntheorem aeval_algHom (f : B →ₐ[A] B') (x : B) : (Polynomial.aeval (f x)) (minpoly A x) = 0 := by\n  rw [Polynomial.aeval_algHom, AlgHom.coe_comp, comp_apply, aeval, map_zero]\n\n"}
{"name":"minpoly.ne_one","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\n⊢ Ne (minpoly A x) 1","decl":"/-- A minimal polynomial is not `1`. -/\ntheorem ne_one [Nontrivial B] : minpoly A x ≠ 1 := by\n  intro h\n  refine (one_ne_zero : (1 : B) ≠ 0) ?_\n  simpa using congr_arg (Polynomial.aeval x) h\n\n"}
{"name":"minpoly.map_ne_one","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : Ring B\ninst✝³ : Algebra A B\nx : B\ninst✝² : Nontrivial B\nR : Type u_4\ninst✝¹ : Semiring R\ninst✝ : Nontrivial R\nf : RingHom A R\n⊢ Ne (Polynomial.map f (minpoly A x)) 1","decl":"theorem map_ne_one [Nontrivial B] {R : Type*} [Semiring R] [Nontrivial R] (f : A →+* R) :\n    (minpoly A x).map f ≠ 1 := by\n  by_cases hx : IsIntegral A x\n  · exact mt ((monic hx).eq_one_of_map_eq_one f) (ne_one A x)\n  · rw [eq_zero hx, Polynomial.map_zero]\n    exact zero_ne_one\n\n"}
{"name":"minpoly.not_isUnit","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\n⊢ Not (IsUnit (minpoly A x))","decl":"/-- A minimal polynomial is not a unit. -/\ntheorem not_isUnit [Nontrivial B] : ¬IsUnit (minpoly A x) := by\n  haveI : Nontrivial A := (algebraMap A B).domain_nontrivial\n  by_cases hx : IsIntegral A x\n  · exact mt (monic hx).eq_one_of_isUnit (ne_one A x)\n  · rw [eq_zero hx]\n    exact not_isUnit_zero\n\n"}
{"name":"minpoly.mem_range_of_degree_eq_one","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\nhx : Eq (minpoly A x).degree 1\n⊢ Membership.mem (algebraMap A B).range x","decl":"theorem mem_range_of_degree_eq_one (hx : (minpoly A x).degree = 1) :\n    x ∈ (algebraMap A B).range := by\n  have h : IsIntegral A x := by\n    by_contra h\n    rw [eq_zero h, degree_zero, ← WithBot.coe_one] at hx\n    exact ne_of_lt (show ⊥ < ↑1 from WithBot.bot_lt_coe 1) hx\n  have key := minpoly.aeval A x\n  rw [eq_X_add_C_of_degree_eq_one hx, (minpoly.monic h).leadingCoeff, C_1, one_mul, aeval_add,\n    aeval_C, aeval_X, ← eq_neg_iff_add_eq_zero, ← RingHom.map_neg] at key\n  exact ⟨-(minpoly A x).coeff 0, key.symm⟩\n\n"}
{"name":"minpoly.min","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\npmonic : p.Monic\nhp : Eq ((Polynomial.aeval x) p) 0\n⊢ LE.le (minpoly A x).degree p.degree","decl":"/-- The defining property of the minimal polynomial of an element `x`:\nit is the monic polynomial with smallest degree that has `x` as its root. -/\ntheorem min {p : A[X]} (pmonic : p.Monic) (hp : Polynomial.aeval x p = 0) :\n    degree (minpoly A x) ≤ degree p := by\n  delta minpoly; split_ifs with hx\n  · exact le_of_not_lt (degree_lt_wf.not_lt_min _ hx ⟨pmonic, hp⟩)\n  · simp only [degree_zero, bot_le]\n\n"}
{"name":"minpoly.unique'","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\np : Polynomial A\nhm : p.Monic\nhp : Eq ((Polynomial.aeval x) p) 0\nhl : ∀ (q : Polynomial A), LT.lt q.degree p.degree → Or (Eq q 0) (Ne ((Polynomial.aeval x) q) 0)\n⊢ Eq p (minpoly A x)","decl":"theorem unique' {p : A[X]} (hm : p.Monic) (hp : Polynomial.aeval x p = 0)\n    (hl : ∀ q : A[X], degree q < degree p → q = 0 ∨ Polynomial.aeval x q ≠ 0) :\n    p = minpoly A x := by\n  nontriviality A\n  have hx : IsIntegral A x := ⟨p, hm, hp⟩\n  obtain h | h := hl _ ((minpoly A x).degree_modByMonic_lt hm)\n  swap\n  · exact (h <| (aeval_modByMonic_eq_self_of_root hm hp).trans <| aeval A x).elim\n  obtain ⟨r, hr⟩ := (modByMonic_eq_zero_iff_dvd hm).1 h\n  rw [hr]\n  have hlead := congr_arg leadingCoeff hr\n  rw [mul_comm, leadingCoeff_mul_monic hm, (monic hx).leadingCoeff] at hlead\n  have : natDegree r ≤ 0 := by\n    have hr0 : r ≠ 0 := by\n      rintro rfl\n      exact ne_zero hx (mul_zero p ▸ hr)\n    apply_fun natDegree at hr\n    rw [hm.natDegree_mul' hr0] at hr\n    apply Nat.le_of_add_le_add_left\n    rw [add_zero]\n    exact hr.symm.trans_le (natDegree_le_natDegree <| min A x hm hp)\n  rw [eq_C_of_natDegree_le_zero this, ← Nat.eq_zero_of_le_zero this, ← leadingCoeff, ← hlead, C_1,\n    mul_one]\n\n"}
{"name":"minpoly.subsingleton","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Subsingleton B\n⊢ Eq (minpoly A x) 1","decl":"@[nontriviality]\ntheorem subsingleton [Subsingleton B] : minpoly A x = 1 := by\n  nontriviality A\n  have := minpoly.min A x monic_one (Subsingleton.elim _ _)\n  rw [degree_one] at this\n  rcases le_or_lt (minpoly A x).degree 0 with h | h\n  · rwa [(monic ⟨1, monic_one, by simp [eq_iff_true_of_subsingleton]⟩ :\n           (minpoly A x).Monic).degree_le_zero_iff_eq_one] at h\n  · exact (this.not_lt h).elim\n\n"}
{"name":"minpoly.natDegree_pos","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\nhx : IsIntegral A x\n⊢ LT.lt 0 (minpoly A x).natDegree","decl":"/-- The degree of a minimal polynomial, as a natural number, is positive. -/\ntheorem natDegree_pos [Nontrivial B] (hx : IsIntegral A x) : 0 < natDegree (minpoly A x) := by\n  rw [pos_iff_ne_zero]\n  intro ndeg_eq_zero\n  have eq_one : minpoly A x = 1 := by\n    rw [eq_C_of_natDegree_eq_zero ndeg_eq_zero]\n    convert C_1 (R := A)\n    simpa only [ndeg_eq_zero.symm] using (monic hx).leadingCoeff\n  simpa only [eq_one, map_one, one_ne_zero] using aeval A x\n\n"}
{"name":"minpoly.degree_pos","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\nhx : IsIntegral A x\n⊢ LT.lt 0 (minpoly A x).degree","decl":"/-- The degree of a minimal polynomial is positive. -/\ntheorem degree_pos [Nontrivial B] (hx : IsIntegral A x) : 0 < degree (minpoly A x) :=\n  natDegree_pos_iff_degree_pos.mp (natDegree_pos hx)\n\n"}
{"name":"minpoly.degree_eq_one_iff","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\n⊢ Iff (Eq (minpoly A x).degree 1) (Membership.mem (algebraMap A B).range x)","decl":"open Polynomial in\ntheorem degree_eq_one_iff : (minpoly A x).degree = 1 ↔ x ∈ (algebraMap A B).range := by\n  refine ⟨minpoly.mem_range_of_degree_eq_one _ _, ?_⟩\n  rintro ⟨x, rfl⟩\n  haveI := Module.nontrivial A B\n  exact (degree_X_sub_C x ▸ minpoly.min A (algebraMap A B x) (monic_X_sub_C x) (by simp)).antisymm\n    (Nat.WithBot.add_one_le_of_lt <| minpoly.degree_pos isIntegral_algebraMap)\n\n"}
{"name":"minpoly.natDegree_eq_one_iff","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\n⊢ Iff (Eq (minpoly A x).natDegree 1) (Membership.mem (algebraMap A B).range x)","decl":"theorem natDegree_eq_one_iff :\n    (minpoly A x).natDegree = 1 ↔ x ∈ (algebraMap A B).range := by\n  rw [← Polynomial.degree_eq_iff_natDegree_eq_of_pos zero_lt_one]\n  exact degree_eq_one_iff\n\n"}
{"name":"minpoly.two_le_natDegree_iff","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra A B\nx : B\ninst✝ : Nontrivial B\nint : IsIntegral A x\n⊢ Iff (LE.le 2 (minpoly A x).natDegree) (Not (Membership.mem (algebraMap A B).range x))","decl":"theorem two_le_natDegree_iff (int : IsIntegral A x) :\n    2 ≤ (minpoly A x).natDegree ↔ x ∉ (algebraMap A B).range := by\n  rw [iff_not_comm, ← natDegree_eq_one_iff, not_le]\n  exact ⟨fun h ↦ h.trans_lt one_lt_two, fun h ↦ by linarith only [minpoly.natDegree_pos int, h]⟩\n\n"}
{"name":"minpoly.two_le_natDegree_subalgebra","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\ninst✝³ : CommRing A\nB : Type u_4\ninst✝² : CommRing B\ninst✝¹ : Algebra A B\ninst✝ : Nontrivial B\nS : Subalgebra A B\nx : B\nint : IsIntegral (Subtype fun x => Membership.mem S x) x\n⊢ Iff (LE.le 2 (minpoly (Subtype fun x => Membership.mem S x) x).natDegree) (Not (Membership.mem S x))","decl":"theorem two_le_natDegree_subalgebra {B} [CommRing B] [Algebra A B] [Nontrivial B]\n    {S : Subalgebra A B} {x : B} (int : IsIntegral S x) : 2 ≤ (minpoly S x).natDegree ↔ x ∉ S := by\n  rw [two_le_natDegree_iff int, Iff.not]\n  apply Set.ext_iff.mp Subtype.range_val_subtype\n\n"}
{"name":"minpoly.eq_X_sub_C_of_algebraMap_inj","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\na : A\nhf : Function.Injective ⇑(algebraMap A B)\n⊢ Eq (minpoly A ((algebraMap A B) a)) (HSub.hSub Polynomial.X (Polynomial.C a))","decl":"/-- If `B/A` is an injective ring extension, and `a` is an element of `A`,\nthen the minimal polynomial of `algebraMap A B a` is `X - C a`. -/\ntheorem eq_X_sub_C_of_algebraMap_inj (a : A) (hf : Function.Injective (algebraMap A B)) :\n    minpoly A (algebraMap A B a) = X - C a := by\n  nontriviality A\n  refine (unique' A _ (monic_X_sub_C a) ?_ ?_).symm\n  · rw [map_sub, aeval_C, aeval_X, sub_self]\n  simp_rw [or_iff_not_imp_left]\n  intro q hl h0\n  rw [← natDegree_lt_natDegree_iff h0, natDegree_X_sub_C, Nat.lt_one_iff] at hl\n  rw [eq_C_of_natDegree_eq_zero hl] at h0 ⊢\n  rwa [aeval_C, map_ne_zero_iff _ hf, ← C_ne_zero]\n\n"}
{"name":"minpoly.aeval_ne_zero_of_dvdNotUnit_minpoly","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : CommRing A\ninst✝¹ : Ring B\ninst✝ : Algebra A B\nx : B\na : Polynomial A\nhx : IsIntegral A x\nhamonic : a.Monic\nhdvd : DvdNotUnit a (minpoly A x)\n⊢ Ne ((Polynomial.aeval x) a) 0","decl":"/-- If `a` strictly divides the minimal polynomial of `x`, then `x` cannot be a root for `a`. -/\ntheorem aeval_ne_zero_of_dvdNotUnit_minpoly {a : A[X]} (hx : IsIntegral A x) (hamonic : a.Monic)\n    (hdvd : DvdNotUnit a (minpoly A x)) : Polynomial.aeval x a ≠ 0 := by\n  refine fun ha => (min A x hamonic ha).not_lt (degree_lt_degree ?_)\n  obtain ⟨_, c, hu, he⟩ := hdvd\n  have hcm := hamonic.of_mul_monic_left (he.subst <| monic hx)\n  rw [he, hamonic.natDegree_mul hcm]\n  -- TODO: port Nat.lt_add_of_zero_lt_left from lean3 core\n  apply lt_add_of_pos_right\n  refine (lt_of_not_le fun h => hu ?_)\n  rw [eq_C_of_natDegree_le_zero h, ← Nat.eq_zero_of_le_zero h, ← leadingCoeff, hcm.leadingCoeff,\n    C_1]\n  exact isUnit_one\n\n"}
{"name":"minpoly.irreducible","module":"Mathlib.FieldTheory.Minpoly.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : Ring B\ninst✝² : Algebra A B\nx : B\ninst✝¹ : IsDomain A\ninst✝ : IsDomain B\nhx : IsIntegral A x\n⊢ Irreducible (minpoly A x)","decl":"/-- A minimal polynomial is irreducible. -/\ntheorem irreducible (hx : IsIntegral A x) : Irreducible (minpoly A x) := by\n  refine (irreducible_of_monic (monic hx) <| ne_one A x).2 fun f g hf hg he => ?_\n  rw [← hf.isUnit_iff, ← hg.isUnit_iff]\n  by_contra! h\n  have heval := congr_arg (Polynomial.aeval x) he\n  rw [aeval A x, aeval_mul, mul_eq_zero] at heval\n  cases' heval with heval heval\n  · exact aeval_ne_zero_of_dvdNotUnit_minpoly hx hf ⟨hf.ne_zero, g, h.2, he.symm⟩ heval\n  · refine aeval_ne_zero_of_dvdNotUnit_minpoly hx hg ⟨hg.ne_zero, f, h.1, ?_⟩ heval\n    rw [mul_comm, he]\n\n"}
