{"name":"WellFounded.isAsymm","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : WellFounded r\n⊢ IsAsymm α r","decl":"protected theorem isAsymm (h : WellFounded r) : IsAsymm α r := ⟨h.asymmetric⟩\n\n"}
{"name":"WellFounded.isIrrefl","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : WellFounded r\n⊢ IsIrrefl α r","decl":"protected theorem isIrrefl (h : WellFounded r) : IsIrrefl α r := @IsAsymm.isIrrefl α r h.isAsymm\n\n"}
{"name":"WellFounded.instIsAsymmRel","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\ninst✝ : WellFoundedRelation α\n⊢ IsAsymm α WellFoundedRelation.rel","decl":"instance [WellFoundedRelation α] : IsAsymm α WellFoundedRelation.rel :=\n  WellFoundedRelation.wf.isAsymm\n\n"}
{"name":"WellFounded.instIsIrreflRel","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\n⊢ IsIrrefl α WellFoundedRelation.rel","decl":"instance : IsIrrefl α WellFoundedRelation.rel := IsAsymm.isIrrefl\n\n"}
{"name":"WellFounded.mono","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr r' : α → α → Prop\nhr : WellFounded r\nh : ∀ (a b : α), r' a b → r a b\n⊢ WellFounded r'","decl":"theorem mono (hr : WellFounded r) (h : ∀ a b, r' a b → r a b) : WellFounded r' :=\n  Subrelation.wf (h _ _) hr\n\n"}
{"name":"WellFounded.onFun","module":"Mathlib.Order.WellFounded","initialProofState":"α : Sort u_4\nβ : Sort u_5\nr : β → β → Prop\nf : α → β\na✝ : WellFounded r\n⊢ WellFounded (Function.onFun r f)","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem onFun {α β : Sort*} {r : β → β → Prop} {f : α → β} :\n    WellFounded r → WellFounded (r on f) :=\n  InvImage.wf _\n\n"}
{"name":"WellFounded.has_min","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_4\nr : α → α → Prop\nH : WellFounded r\ns : Set α\na✝ : s.Nonempty\n⊢ Exists fun a => And (Membership.mem s a) (∀ (x : α), Membership.mem s x → Not (r x a))","decl":"/-- If `r` is a well-founded relation, then any nonempty set has a minimal element\nwith respect to `r`. -/\ntheorem has_min {α} {r : α → α → Prop} (H : WellFounded r) (s : Set α) :\n    s.Nonempty → ∃ a ∈ s, ∀ x ∈ s, ¬r x a\n  | ⟨a, ha⟩ => show ∃ b ∈ s, ∀ x ∈ s, ¬r x b from\n    Acc.recOn (H.apply a) (fun x _ IH =>\n        not_imp_not.1 fun hne hx => hne <| ⟨x, hx, fun y hy hyx => hne <| IH y hyx hy⟩)\n      ha\n\n"}
{"name":"WellFounded.min_mem","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nH : WellFounded r\ns : Set α\nh : s.Nonempty\n⊢ Membership.mem s (H.min s h)","decl":"theorem min_mem {r : α → α → Prop} (H : WellFounded r) (s : Set α) (h : s.Nonempty) :\n    H.min s h ∈ s :=\n  let ⟨h, _⟩ := Classical.choose_spec (H.has_min s h)\n  h\n\n"}
{"name":"WellFounded.not_lt_min","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nH : WellFounded r\ns : Set α\nh : s.Nonempty\nx : α\nhx : Membership.mem s x\n⊢ Not (r x (H.min s h))","decl":"theorem not_lt_min {r : α → α → Prop} (H : WellFounded r) (s : Set α) (h : s.Nonempty) {x}\n    (hx : x ∈ s) : ¬r x (H.min s h) :=\n  let ⟨_, h'⟩ := Classical.choose_spec (H.has_min s h)\n  h' _ hx\n\n"}
{"name":"WellFounded.wellFounded_iff_has_min","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (WellFounded r) (∀ (s : Set α), s.Nonempty → Exists fun m => And (Membership.mem s m) (∀ (x : α), Membership.mem s x → Not (r x m)))","decl":"theorem wellFounded_iff_has_min {r : α → α → Prop} :\n    WellFounded r ↔ ∀ s : Set α, s.Nonempty → ∃ m ∈ s, ∀ x ∈ s, ¬r x m := by\n  refine ⟨fun h => h.has_min, fun h => ⟨fun x => ?_⟩⟩\n  by_contra hx\n  obtain ⟨m, hm, hm'⟩ := h {x | ¬Acc r x} ⟨x, hx⟩\n  refine hm ⟨_, fun y hy => ?_⟩\n  by_contra hy'\n  exact hm' y hy' hy\n\n"}
{"name":"WellFounded.wellFounded_iff_no_descending_seq","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (WellFounded r) (IsEmpty (Subtype fun f => ∀ (n : Nat), r (f (HAdd.hAdd n 1)) (f n)))","decl":"/-- A relation is well-founded iff it doesn't have any infinite decreasing sequence.\n\nSee `RelEmbedding.wellFounded_iff_no_descending_seq` for a version on strict orders. -/\ntheorem wellFounded_iff_no_descending_seq :\n    WellFounded r ↔ IsEmpty { f : ℕ → α // ∀ n, r (f (n + 1)) (f n) } := by\n  rw [WellFounded.wellFounded_iff_has_min]\n  refine ⟨fun hr ↦ ⟨fun ⟨f, hf⟩ ↦ ?_⟩, ?_⟩\n  · obtain ⟨_, ⟨n, rfl⟩, hn⟩ := hr _ (Set.range_nonempty f)\n    exact hn _ (Set.mem_range_self (n + 1)) (hf n)\n  · contrapose!\n    rw [not_isEmpty_iff]\n    rintro ⟨s, hs, hs'⟩\n    let f : ℕ → s := Nat.rec (Classical.indefiniteDescription _ hs) fun n IH ↦\n      ⟨(hs' _ IH.2).choose, (hs' _ IH.2).choose_spec.1⟩\n    exact ⟨⟨Subtype.val ∘ f, fun n ↦ (hs' _ (f n).2).choose_spec.2⟩⟩\n\n"}
{"name":"WellFounded.not_rel_apply_succ","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nh : IsWellFounded α r\nf : Nat → α\n⊢ Exists fun n => Not (r (f (HAdd.hAdd n 1)) (f n))","decl":"theorem not_rel_apply_succ [h : IsWellFounded α r] (f : ℕ → α) : ∃ n, ¬ r (f (n + 1)) (f n) := by\n  by_contra! hf\n  exact (wellFounded_iff_no_descending_seq.1 h.wf).elim ⟨f, hf⟩\n\n"}
{"name":"WellFounded.lt_sup","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nwf : WellFounded r\ns : Set α\nh : Set.Bounded r s\nx : α\nhx : Membership.mem s x\n⊢ r x (wf.sup s h)","decl":"protected theorem lt_sup {r : α → α → Prop} (wf : WellFounded r) {s : Set α} (h : Bounded r s) {x}\n    (hx : x ∈ s) : r x (wf.sup s h) :=\n  min_mem wf { x | ∀ a ∈ s, r a x } h x hx\n\n"}
{"name":"WellFounded.lt_succ","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nwf : WellFounded r\nx : α\nh : Exists fun y => r x y\n⊢ r x (wf.succ x)","decl":"set_option linter.deprecated false in\n@[deprecated \"`WellFounded.succ` is deprecated\" (since := \"2024-10-25\")]\nprotected theorem lt_succ {r : α → α → Prop} (wf : WellFounded r) {x : α} (h : ∃ y, r x y) :\n    r x (wf.succ x) := by\n  rw [WellFounded.succ, dif_pos h]\n  apply min_mem\n\n"}
{"name":"WellFounded.lt_succ_iff","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nr : α → α → Prop\nwo : IsWellOrder α r\nx : α\nh : Exists fun y => r x y\ny : α\n⊢ Iff (r y (⋯.succ x)) (Or (r y x) (Eq y x))","decl":"set_option linter.deprecated false in\n@[deprecated \"`WellFounded.succ` is deprecated\" (since := \"2024-10-25\")]\nprotected theorem lt_succ_iff {r : α → α → Prop} [wo : IsWellOrder α r] {x : α} (h : ∃ y, r x y)\n    (y : α) : r y (wo.wf.succ x) ↔ r y x ∨ y = x := by\n  constructor\n  · intro h'\n    have : ¬r x y := by\n      intro hy\n      rw [WellFounded.succ, dif_pos] at h'\n      exact wo.wf.not_lt_min _ h hy h'\n    rcases trichotomous_of r x y with (hy | hy | hy)\n    · exfalso\n      exact this hy\n    · right\n      exact hy.symm\n    left\n    exact hy\n  rintro (hy | rfl); (· exact _root_.trans hy (wo.wf.lt_succ h)); exact wo.wf.lt_succ h\n\n"}
{"name":"WellFounded.min_le","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝ : LinearOrder β\nh : WellFounded fun x1 x2 => LT.lt x1 x2\nx : β\ns : Set β\nhx : Membership.mem s x\nhne : optParam s.Nonempty ⋯\n⊢ LE.le (h.min s hne) x","decl":"theorem WellFounded.min_le (h : WellFounded ((· < ·) : β → β → Prop))\n    {x : β} {s : Set β} (hx : x ∈ s) (hne : s.Nonempty := ⟨x, hx⟩) : h.min s hne ≤ x :=\n  not_lt.1 <| h.not_lt_min _ _ hx\n\n"}
{"name":"Set.range_injOn_strictMono","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : WellFoundedLT β\n⊢ Set.InjOn Set.range (setOf fun f => StrictMono f)","decl":"theorem Set.range_injOn_strictMono [WellFoundedLT β] :\n    Set.InjOn Set.range { f : β → γ | StrictMono f } := by\n  intro f hf g hg hfg\n  ext a\n  apply WellFoundedLT.induction a\n  intro a IH\n  obtain ⟨b, hb⟩ := hfg ▸ mem_range_self a\n  obtain h | rfl | h := lt_trichotomy b a\n  · rw [← IH b h] at hb\n    cases (hf.injective hb).not_lt h\n  · rw [hb]\n  · obtain ⟨c, hc⟩ := hfg.symm ▸ mem_range_self a\n    have := hg h\n    rw [hb, ← hc, hf.lt_iff_lt] at this\n    rw [IH c this] at hc\n    cases (hg.injective hc).not_lt this\n\n"}
{"name":"Set.range_injOn_strictAnti","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : WellFoundedGT β\n⊢ Set.InjOn Set.range (setOf fun f => StrictAnti f)","decl":"theorem Set.range_injOn_strictAnti [WellFoundedGT β] :\n    Set.InjOn Set.range { f : β → γ | StrictAnti f } :=\n  fun _ hf _ hg ↦ Set.range_injOn_strictMono (β := βᵒᵈ) hf.dual hg.dual\n\n"}
{"name":"StrictMono.range_inj","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : WellFoundedLT β\nf g : β → γ\nhf : StrictMono f\nhg : StrictMono g\n⊢ Iff (Eq (Set.range f) (Set.range g)) (Eq f g)","decl":"theorem StrictMono.range_inj [WellFoundedLT β] {f g : β → γ}\n    (hf : StrictMono f) (hg : StrictMono g) : Set.range f = Set.range g ↔ f = g :=\n  Set.range_injOn_strictMono.eq_iff hf hg\n\n"}
{"name":"StrictAnti.range_inj","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : WellFoundedGT β\nf g : β → γ\nhf : StrictAnti f\nhg : StrictAnti g\n⊢ Iff (Eq (Set.range f) (Set.range g)) (Eq f g)","decl":"theorem StrictAnti.range_inj [WellFoundedGT β] {f g : β → γ}\n    (hf : StrictAnti f) (hg : StrictAnti g) : Set.range f = Set.range g ↔ f = g :=\n  Set.range_injOn_strictAnti.eq_iff hf hg\n\n"}
{"name":"WellFounded.eq_strictMono_iff_eq_range","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\nγ : Type u_3\ninst✝¹ : LinearOrder β\ninst✝ : Preorder γ\nh : WellFounded fun x1 x2 => LT.lt x1 x2\nf g : β → γ\nhf : StrictMono f\nhg : StrictMono g\n⊢ Iff (Eq (Set.range f) (Set.range g)) (Eq f g)","decl":"@[deprecated StrictMono.range_inj (since := \"2024-09-11\")]\ntheorem WellFounded.eq_strictMono_iff_eq_range (h : WellFounded ((· < ·) : β → β → Prop))\n    {f g : β → γ} (hf : StrictMono f) (hg : StrictMono g) :\n    Set.range f = Set.range g ↔ f = g :=\n  @StrictMono.range_inj β γ _ _ ⟨h⟩ f g hf hg\n\n"}
{"name":"StrictMono.id_le","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝¹ : LinearOrder β\ninst✝ : WellFoundedLT β\nf : β → β\nhf : StrictMono f\n⊢ LE.le id f","decl":"/-- A strictly monotone function `f` on a well-order satisfies `x ≤ f x` for all `x`. -/\ntheorem StrictMono.id_le [WellFoundedLT β] {f : β → β} (hf : StrictMono f) : id ≤ f := by\n  rw [Pi.le_def]\n  by_contra! H\n  obtain ⟨m, hm, hm'⟩ := wellFounded_lt.has_min _ H\n  exact hm' _ (hf hm) hm\n\n"}
{"name":"StrictMono.le_apply","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝¹ : LinearOrder β\ninst✝ : WellFoundedLT β\nf : β → β\nhf : StrictMono f\nx : β\n⊢ LE.le x (f x)","decl":"theorem StrictMono.le_apply [WellFoundedLT β] {f : β → β} (hf : StrictMono f) {x} : x ≤ f x :=\n  hf.id_le x\n\n"}
{"name":"StrictMono.le_id","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝¹ : LinearOrder β\ninst✝ : WellFoundedGT β\nf : β → β\nhf : StrictMono f\n⊢ LE.le f id","decl":"/-- A strictly monotone function `f` on a cowell-order satisfies `f x ≤ x` for all `x`. -/\ntheorem StrictMono.le_id [WellFoundedGT β] {f : β → β} (hf : StrictMono f) : f ≤ id :=\n  StrictMono.id_le (β := βᵒᵈ) hf.dual\n\n"}
{"name":"StrictMono.apply_le","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝¹ : LinearOrder β\ninst✝ : WellFoundedGT β\nf : β → β\nhf : StrictMono f\nx : β\n⊢ LE.le (f x) x","decl":"theorem StrictMono.apply_le [WellFoundedGT β] {f : β → β} (hf : StrictMono f) {x} : f x ≤ x :=\n  StrictMono.le_apply (β := βᵒᵈ) hf.dual\n\n"}
{"name":"WellFounded.self_le_of_strictMono","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝ : LinearOrder β\nh : WellFounded fun x1 x2 => LT.lt x1 x2\nf : β → β\nhf : StrictMono f\nn : β\n⊢ LE.le n (f n)","decl":"@[deprecated StrictMono.le_apply (since := \"2024-09-11\")]\ntheorem WellFounded.self_le_of_strictMono (h : WellFounded ((· < ·) : β → β → Prop))\n    {f : β → β} (hf : StrictMono f) : ∀ n, n ≤ f n := by\n  by_contra! h₁\n  have h₂ := h.min_mem _ h₁\n  exact h.not_lt_min _ h₁ (hf h₂) h₂\n\n"}
{"name":"StrictMono.not_bddAbove_range_of_wellFoundedLT","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝² : LinearOrder β\nf : β → β\ninst✝¹ : WellFoundedLT β\ninst✝ : NoMaxOrder β\nhf : StrictMono f\n⊢ Not (BddAbove (Set.range f))","decl":"theorem StrictMono.not_bddAbove_range_of_wellFoundedLT {f : β → β} [WellFoundedLT β] [NoMaxOrder β]\n    (hf : StrictMono f) : ¬ BddAbove (Set.range f) := by\n  rintro ⟨a, ha⟩\n  obtain ⟨b, hb⟩ := exists_gt a\n  exact ((hf.le_apply.trans_lt (hf hb)).trans_le <| ha (Set.mem_range_self _)).false\n\n"}
{"name":"StrictMono.not_bddBelow_range_of_wellFoundedGT","module":"Mathlib.Order.WellFounded","initialProofState":"β : Type u_2\ninst✝² : LinearOrder β\nf : β → β\ninst✝¹ : WellFoundedGT β\ninst✝ : NoMinOrder β\nhf : StrictMono f\n⊢ Not (BddBelow (Set.range f))","decl":"theorem StrictMono.not_bddBelow_range_of_wellFoundedGT {f : β → β} [WellFoundedGT β] [NoMinOrder β]\n    (hf : StrictMono f) : ¬ BddBelow (Set.range f) :=\n  hf.dual.not_bddAbove_range_of_wellFoundedLT\n\n"}
{"name":"Function.not_lt_argmin","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LT β\nh : WellFoundedLT β\ninst✝ : Nonempty α\na : α\n⊢ Not (LT.lt (f a) (f (Function.argmin f)))","decl":"theorem not_lt_argmin [Nonempty α] (a : α) : ¬f a < f (argmin f) :=\n  WellFounded.not_lt_min (InvImage.wf f h.wf) _ _ (Set.mem_univ a)\n\n"}
{"name":"Function.argminOn_mem","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝ : LT β\nh : WellFoundedLT β\ns : Set α\nhs : s.Nonempty\n⊢ Membership.mem s (Function.argminOn f s hs)","decl":"@[simp]\ntheorem argminOn_mem (s : Set α) (hs : s.Nonempty) : argminOn f s hs ∈ s :=\n  WellFounded.min_mem _ _ _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as it will never apply\n"}
{"name":"Function.not_lt_argminOn","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝ : LT β\nh : WellFoundedLT β\ns : Set α\na : α\nha : Membership.mem s a\nhs : optParam s.Nonempty ⋯\n⊢ Not (LT.lt (f a) (f (Function.argminOn f s hs)))","decl":"theorem not_lt_argminOn (s : Set α) {a : α} (ha : a ∈ s)\n    (hs : s.Nonempty := Set.nonempty_of_mem ha) : ¬f a < f (argminOn f s hs) :=\n  WellFounded.not_lt_min (InvImage.wf f h.wf) s hs ha\n\n"}
{"name":"Function.argmin_le","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝² : LinearOrder β\ninst✝¹ : WellFoundedLT β\na : α\ninst✝ : Nonempty α\n⊢ LE.le (f (Function.argmin f)) (f a)","decl":"theorem argmin_le (a : α) [Nonempty α] : f (argmin f) ≤ f a :=\n  not_lt.mp <| not_lt_argmin f a\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as it will never apply\n"}
{"name":"Function.argminOn_le","module":"Mathlib.Order.WellFounded","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝¹ : LinearOrder β\ninst✝ : WellFoundedLT β\ns : Set α\na : α\nha : Membership.mem s a\nhs : optParam s.Nonempty ⋯\n⊢ LE.le (f (Function.argminOn f s hs)) (f a)","decl":"theorem argminOn_le (s : Set α) {a : α} (ha : a ∈ s) (hs : s.Nonempty := Set.nonempty_of_mem ha) :\n    f (argminOn f s hs) ≤ f a :=\n  not_lt.mp <| not_lt_argminOn f s ha hs\n\n"}
{"name":"Acc.induction_bot'","module":"Mathlib.Order.WellFounded","initialProofState":"α : Sort u_4\nβ : Sort u_5\nr : α → α → Prop\na bot : α\nha : Acc r a\nC : β → Prop\nf : α → β\nih : ∀ (b : α), Ne (f b) (f bot) → C (f b) → Exists fun c => And (r c b) (C (f c))\na✝ : C (f a)\n⊢ C (f bot)","decl":"/-- Let `r` be a relation on `α`, let `f : α → β` be a function, let `C : β → Prop`, and\nlet `bot : α`. This induction principle shows that `C (f bot)` holds, given that\n* some `a` that is accessible by `r` satisfies `C (f a)`, and\n* for each `b` such that `f b ≠ f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. -/\ntheorem Acc.induction_bot' {α β} {r : α → α → Prop} {a bot : α} (ha : Acc r a) {C : β → Prop}\n    {f : α → β} (ih : ∀ b, f b ≠ f bot → C (f b) → ∃ c, r c b ∧ C (f c)) : C (f a) → C (f bot) :=\n  (@Acc.recOn _ _ (fun x _ => C (f x) → C (f bot)) _ ha) fun x _ ih' hC =>\n    (eq_or_ne (f x) (f bot)).elim (fun h => h ▸ hC) (fun h =>\n      let ⟨y, hy₁, hy₂⟩ := ih x h hC\n      ih' y hy₁ hy₂)\n\n"}
{"name":"Acc.induction_bot","module":"Mathlib.Order.WellFounded","initialProofState":"α : Sort u_4\nr : α → α → Prop\na bot : α\nha : Acc r a\nC : α → Prop\nih : ∀ (b : α), Ne b bot → C b → Exists fun c => And (r c b) (C c)\na✝ : C a\n⊢ C bot","decl":"/-- Let `r` be a relation on `α`, let `C : α → Prop` and let `bot : α`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` that is accessible by `r` satisfies `C a`, and\n* for each `b ≠ bot` such that `C b` holds, there is `c` satisfying `r c b` and `C c`. -/\ntheorem Acc.induction_bot {α} {r : α → α → Prop} {a bot : α} (ha : Acc r a) {C : α → Prop}\n    (ih : ∀ b, b ≠ bot → C b → ∃ c, r c b ∧ C c) : C a → C bot :=\n  ha.induction_bot' ih\n\n"}
{"name":"WellFounded.induction_bot'","module":"Mathlib.Order.WellFounded","initialProofState":"α : Sort u_4\nβ : Sort u_5\nr : α → α → Prop\nhwf : WellFounded r\na bot : α\nC : β → Prop\nf : α → β\nih : ∀ (b : α), Ne (f b) (f bot) → C (f b) → Exists fun c => And (r c b) (C (f c))\na✝ : C (f a)\n⊢ C (f bot)","decl":"/-- Let `r` be a well-founded relation on `α`, let `f : α → β` be a function,\nlet `C : β → Prop`, and let `bot : α`.\nThis induction principle shows that `C (f bot)` holds, given that\n* some `a` satisfies `C (f a)`, and\n* for each `b` such that `f b ≠ f bot` and `C (f b)` holds, there is `c`\n  satisfying `r c b` and `C (f c)`. -/\ntheorem WellFounded.induction_bot' {α β} {r : α → α → Prop} (hwf : WellFounded r) {a bot : α}\n    {C : β → Prop} {f : α → β} (ih : ∀ b, f b ≠ f bot → C (f b) → ∃ c, r c b ∧ C (f c)) :\n    C (f a) → C (f bot) :=\n  (hwf.apply a).induction_bot' ih\n\n"}
{"name":"WellFounded.induction_bot","module":"Mathlib.Order.WellFounded","initialProofState":"α : Sort u_4\nr : α → α → Prop\nhwf : WellFounded r\na bot : α\nC : α → Prop\nih : ∀ (b : α), Ne b bot → C b → Exists fun c => And (r c b) (C c)\na✝ : C a\n⊢ C bot","decl":"/-- Let `r` be a well-founded relation on `α`, let `C : α → Prop`, and let `bot : α`.\nThis induction principle shows that `C bot` holds, given that\n* some `a` satisfies `C a`, and\n* for each `b` that satisfies `C b`, there is `c` satisfying `r c b` and `C c`.\n\nThe naming is inspired by the fact that when `r` is transitive, it follows that `bot` is\nthe smallest element w.r.t. `r` that satisfies `C`. -/\ntheorem WellFounded.induction_bot {α} {r : α → α → Prop} (hwf : WellFounded r) {a bot : α}\n    {C : α → Prop} (ih : ∀ b, b ≠ bot → C b → ∃ c, r c b ∧ C c) : C a → C bot :=\n  hwf.induction_bot' ih\n\n"}
