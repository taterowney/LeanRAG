{"name":"CochainComplex.instHasHomotopyCofiberOfHasBinaryBiproductXHAddOfNat","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\ninstâœÂ³ : CategoryTheory.Preadditive C\nÎ¹ : Type u_3\ninstâœÂ² : AddRightCancelSemigroup Î¹\ninstâœÂ¹ : One Î¹\nF G : CochainComplex C Î¹\nÏ† : Quiver.Hom F G\ninstâœ : âˆ€ (p : Î¹), CategoryTheory.Limits.HasBinaryBiproduct (F.X (HAdd.hAdd p 1)) (G.X p)\nâŠ¢ HomologicalComplex.HasHomotopyCofiber Ï†","decl":"instance [âˆ€ p, HasBinaryBiproduct (F.X (p + 1)) (G.X p)] :\n    HasHomotopyCofiber Ï† where\n  hasBinaryBiproduct := by\n    rintro i _ rfl\n    infer_instance\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd q 1) p\nZ : C\nh : Quiver.Hom (F.X p) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q â‹¯) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v q p hpq) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inl_v_fst_v (p q : â„¤) (hpq : q + 1 = p) :\n    (inl Ï†).v p q (by rw [â† hpq, add_neg_cancel_right]) â‰«\n      (fst Ï† : Cochain (mappingCone Ï†) F 1).v q p hpq = ğŸ™ _ := by\n  simp [inl, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd q 1) p\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q â‹¯) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v q p hpq)) (CategoryTheory.CategoryStruct.id (F.X p))","decl":"@[reassoc (attr := simp)]\nlemma inl_v_fst_v (p q : â„¤) (hpq : q + 1 = p) :\n    (inl Ï†).v p q (by rw [â† hpq, add_neg_cancel_right]) â‰«\n      (fst Ï† : Cochain (mappingCone Ï†) F 1).v q p hpq = ğŸ™ _ := by\n  simp [inl, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q hpq) ((CochainComplex.mappingCone.snd Ï†).v q q â‹¯)) 0","decl":"@[reassoc (attr := simp)]\nlemma inl_v_snd_v (p q : â„¤) (hpq : p + (-1) = q) :\n    (inl Ï†).v p q hpq â‰« (snd Ï†).v q q (add_zero q) = 0 := by\n  simp [inl, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (G.X q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q hpq) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v q q â‹¯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_snd_v (p q : â„¤) (hpq : p + (-1) = q) :\n    (inl Ï†).v p q hpq â‰« (snd Ï†).v q q (add_zero q) = 0 := by\n  simp [inl, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq)) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_f_fst_v (p q : â„¤) (hpq : p + 1 = q) :\n    (inr Ï†).f p â‰« (fst Ï†).1.v p q hpq = 0 := by\n  simp [inr, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nZ : C\nh : Quiver.Hom (F.X q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_fst_v (p q : â„¤) (hpq : p + 1 = q) :\n    (inr Ï†).f p â‰« (fst Ï†).1.v p q hpq = 0 := by\n  simp [inr, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np : Int\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) ((CochainComplex.mappingCone.snd Ï†).v p p â‹¯)) (CategoryTheory.CategoryStruct.id (G.X p))","decl":"@[reassoc (attr := simp)]\nlemma inr_f_snd_v (p : â„¤) :\n    (inr Ï†).f p â‰« (snd Ï†).v p p (add_zero p) = ğŸ™ _ := by\n  simp [inr, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np : Int\nZ : C\nh : Quiver.Hom (G.X p) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v p p â‹¯) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inr_f_snd_v (p : â„¤) :\n    (inr Ï†).f p â‰« (snd Ï†).v p p (add_zero p) = ğŸ™ _ := by\n  simp [inr, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inl_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp â†‘(CochainComplex.mappingCone.fst Ï†) â‹¯) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id F))","decl":"@[simp]\nlemma inl_fst :\n    (inl Ï†).comp (fst Ï†).1 (neg_add_cancel 1) = Cochain.ofHom (ğŸ™ F) := by\n  ext p\n  simp [Cochain.comp_v _ _ (neg_add_cancel 1) p (p-1) p rfl (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inl_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp (CochainComplex.mappingCone.snd Ï†) â‹¯) 0","decl":"@[simp]\nlemma inl_snd :\n    (inl Ï†).comp (snd Ï†) (add_zero (-1)) = 0 := by\n  ext p q hpq\n  simp [Cochain.comp_v _ _ (add_zero (-1)) p q q (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inr_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp â†‘(CochainComplex.mappingCone.fst Ï†) â‹¯) 0","decl":"@[simp]\nlemma inr_fst :\n    (Cochain.ofHom (inr Ï†)).comp (fst Ï†).1 (zero_add 1) = 0 := by\n  ext p q hpq\n  simp [Cochain.comp_v _ _ (zero_add 1) p p q (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inr_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp (CochainComplex.mappingCone.snd Ï†) â‹¯) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id G))","decl":"@[simp]\nlemma inr_snd :\n    (Cochain.ofHom (inr Ï†)).comp (snd Ï†) (zero_add 0) = Cochain.ofHom (ğŸ™ G) := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.inl_fst_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nd e : Int\nÎ³ : CochainComplex.HomComplex.Cochain F K d\nhe : Eq (HAdd.hAdd 1 d) e\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).comp Î³ he) â‹¯) Î³","decl":"@[simp]\nlemma inl_fst_assoc {K : CochainComplex C â„¤} {d e : â„¤} (Î³ : Cochain F K d) (he : 1 + d = e) :\n    (inl Ï†).comp ((fst Ï†).1.comp Î³ he) (by rw [â† he, neg_add_cancel_left]) = Î³ := by\n  rw [â† Cochain.comp_assoc _ _ _ (neg_add_cancel 1) (by omega) (by omega), inl_fst,\n    Cochain.id_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inl_snd_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nd e f : Int\nÎ³ : CochainComplex.HomComplex.Cochain G K d\nhe : Eq (HAdd.hAdd 0 d) e\nhf : Eq (HAdd.hAdd (-1) e) f\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp ((CochainComplex.mappingCone.snd Ï†).comp Î³ he) hf) 0","decl":"@[simp]\nlemma inl_snd_assoc {K : CochainComplex C â„¤} {d e f : â„¤} (Î³ : Cochain G K d)\n    (he : 0 + d = e) (hf : -1 + e = f) :\n    (inl Ï†).comp ((snd Ï†).comp Î³ he) hf = 0 := by\n  obtain rfl : e = d := by omega\n  rw [â† Cochain.comp_assoc_of_second_is_zero_cochain, inl_snd, Cochain.zero_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inr_fst_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nd e f : Int\nÎ³ : CochainComplex.HomComplex.Cochain F K d\nhe : Eq (HAdd.hAdd 1 d) e\nhf : Eq (HAdd.hAdd 0 e) f\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).comp Î³ he) hf) 0","decl":"@[simp]\nlemma inr_fst_assoc {K : CochainComplex C â„¤} {d e f : â„¤} (Î³ : Cochain F K d)\n    (he : 1 + d = e) (hf : 0 + e = f) :\n    (Cochain.ofHom (inr Ï†)).comp ((fst Ï†).1.comp Î³ he) hf = 0 := by\n  obtain rfl : e = f := by omega\n  rw [â† Cochain.comp_assoc_of_first_is_zero_cochain, inr_fst, Cochain.zero_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inr_snd_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nd e : Int\nÎ³ : CochainComplex.HomComplex.Cochain G K d\nhe : Eq (HAdd.hAdd 0 d) e\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp ((CochainComplex.mappingCone.snd Ï†).comp Î³ he) â‹¯) Î³","decl":"@[simp]\nlemma inr_snd_assoc {K : CochainComplex C â„¤} {d e : â„¤} (Î³ : Cochain G K d) (he : 0 + d = e) :\n    (Cochain.ofHom (inr Ï†)).comp ((snd Ï†).comp Î³ he) (by simp only [â† he, zero_add]) = Î³ := by\n  obtain rfl : d = e := by omega\n  rw [â† Cochain.comp_assoc_of_first_is_zero_cochain, inr_snd, Cochain.id_comp]\n\n"}
{"name":"CochainComplex.mappingCone.ext_to","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nA : C\nf g : Quiver.Hom A ((CochainComplex.mappingCone Ï†).X i)\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp f ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij)) (CategoryTheory.CategoryStruct.comp g ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij))\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp f ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯)) (CategoryTheory.CategoryStruct.comp g ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯))\nâŠ¢ Eq f g","decl":"lemma ext_to (i j : â„¤) (hij : i + 1 = j) {A : C} {f g : A âŸ¶ (mappingCone Ï†).X i}\n    (hâ‚ : f â‰« (fst Ï†).1.v i j hij = g â‰« (fst Ï†).1.v i j hij)\n    (hâ‚‚ : f â‰« (snd Ï†).v i i (add_zero i) = g â‰« (snd Ï†).v i i (add_zero i)) :\n    f = g :=\n  homotopyCofiber.ext_to_X Ï† i j hij hâ‚ (by simpa [snd] using hâ‚‚)\n\n"}
{"name":"CochainComplex.mappingCone.ext_to_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nA : C\nf g : Quiver.Hom A ((CochainComplex.mappingCone Ï†).X i)\nâŠ¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij)) (CategoryTheory.CategoryStruct.comp g ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij))) (Eq (CategoryTheory.CategoryStruct.comp f ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯)) (CategoryTheory.CategoryStruct.comp g ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯))))","decl":"lemma ext_to_iff (i j : â„¤) (hij : i + 1 = j) {A : C} (f g : A âŸ¶ (mappingCone Ï†).X i) :\n    f = g â†” f â‰« (fst Ï†).1.v i j hij = g â‰« (fst Ï†).1.v i j hij âˆ§\n      f â‰« (snd Ï†).v i i (add_zero i) = g â‰« (snd Ï†).v i i (add_zero i) := by\n  constructor\n  Â· rintro rfl\n    tauto\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    exact ext_to Ï† i j hij hâ‚ hâ‚‚\n\n"}
{"name":"CochainComplex.mappingCone.ext_from","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd j 1) i\nA : C\nf g : Quiver.Hom ((CochainComplex.mappingCone Ï†).X j) A\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j â‹¯) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j â‹¯) g)\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f j) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f j) g)\nâŠ¢ Eq f g","decl":"lemma ext_from (i j : â„¤) (hij : j + 1 = i) {A : C} {f g : (mappingCone Ï†).X j âŸ¶ A}\n    (hâ‚ : (inl Ï†).v i j (by omega) â‰« f = (inl Ï†).v i j (by omega) â‰« g)\n    (hâ‚‚ : (inr Ï†).f j â‰« f = (inr Ï†).f j â‰« g) :\n    f = g :=\n  homotopyCofiber.ext_from_X Ï† i j hij hâ‚ hâ‚‚\n\n"}
{"name":"CochainComplex.mappingCone.ext_from_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd j 1) i\nA : C\nf g : Quiver.Hom ((CochainComplex.mappingCone Ï†).X j) A\nâŠ¢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j â‹¯) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j â‹¯) g)) (Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f j) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f j) g)))","decl":"lemma ext_from_iff (i j : â„¤) (hij : j + 1 = i) {A : C} (f g : (mappingCone Ï†).X j âŸ¶ A) :\n    f = g â†” (inl Ï†).v i j (by omega) â‰« f = (inl Ï†).v i j (by omega) â‰« g âˆ§\n      (inr Ï†).f j â‰« f = (inr Ï†).f j â‰« g := by\n  constructor\n  Â· rintro rfl\n    tauto\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    exact ext_from Ï† i j hij hâ‚ hâ‚‚\n\n"}
{"name":"CochainComplex.mappingCone.decomp_to","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni : Int\nA : C\nf : Quiver.Hom A ((CochainComplex.mappingCone Ï†).X i)\nj : Int\nhij : Eq (HAdd.hAdd i 1) j\nâŠ¢ Exists fun a => Exists fun b => Eq f (HAdd.hAdd (CategoryTheory.CategoryStruct.comp a ((CochainComplex.mappingCone.inl Ï†).v j i â‹¯)) (CategoryTheory.CategoryStruct.comp b ((CochainComplex.mappingCone.inr Ï†).f i)))","decl":"lemma decomp_to {i : â„¤} {A : C} (f : A âŸ¶ (mappingCone Ï†).X i) (j : â„¤) (hij : i + 1 = j) :\n    âˆƒ (a : A âŸ¶ F.X j) (b : A âŸ¶ G.X i), f = a â‰« (inl Ï†).v j i (by omega) + b â‰« (inr Ï†).f i :=\n  âŸ¨f â‰« (fst Ï†).1.v i j hij, f â‰« (snd Ï†).v i i (add_zero i),\n    by apply ext_to Ï† i j hij <;> simpâŸ©\n\n"}
{"name":"CochainComplex.mappingCone.decomp_from","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nj : Int\nA : C\nf : Quiver.Hom ((CochainComplex.mappingCone Ï†).X j) A\ni : Int\nhij : Eq (HAdd.hAdd j 1) i\nâŠ¢ Exists fun a => Exists fun b => Eq f (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v j i hij) a) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v j j â‹¯) b))","decl":"lemma decomp_from {j : â„¤} {A : C} (f : (mappingCone Ï†).X j âŸ¶ A) (i : â„¤) (hij : j + 1 = i) :\n    âˆƒ (a : F.X i âŸ¶ A) (b : G.X j âŸ¶ A),\n      f = (fst Ï†).1.v j i hij â‰« a + (snd Ï†).v j j (add_zero j) â‰« b :=\n  âŸ¨(inl Ï†).v i j (by omega) â‰« f, (inr Ï†).f j â‰« f,\n    by apply ext_from Ï† i j hij <;> simpâŸ©\n\n"}
{"name":"CochainComplex.mappingCone.ext_cochain_to_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nK : CochainComplex C Int\nÎ³â‚ Î³â‚‚ : CochainComplex.HomComplex.Cochain K (CochainComplex.mappingCone Ï†) i\nâŠ¢ Iff (Eq Î³â‚ Î³â‚‚) (And (Eq (Î³â‚.comp (â†‘(CochainComplex.mappingCone.fst Ï†)) hij) (Î³â‚‚.comp (â†‘(CochainComplex.mappingCone.fst Ï†)) hij)) (Eq (Î³â‚.comp (CochainComplex.mappingCone.snd Ï†) â‹¯) (Î³â‚‚.comp (CochainComplex.mappingCone.snd Ï†) â‹¯)))","decl":"lemma ext_cochain_to_iff (i j : â„¤) (hij : i + 1 = j)\n    {K : CochainComplex C â„¤} {Î³â‚ Î³â‚‚ : Cochain K (mappingCone Ï†) i} :\n    Î³â‚ = Î³â‚‚ â†” Î³â‚.comp (fst Ï†).1 hij = Î³â‚‚.comp (fst Ï†).1 hij âˆ§\n      Î³â‚.comp (snd Ï†) (add_zero i) = Î³â‚‚.comp (snd Ï†) (add_zero i) := by\n  constructor\n  Â· rintro rfl\n    tauto\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    ext p q hpq\n    rw [ext_to_iff Ï† q (q + 1) rfl]\n    replace hâ‚ := Cochain.congr_v hâ‚ p (q + 1) (by omega)\n    replace hâ‚‚ := Cochain.congr_v hâ‚‚ p q hpq\n    simp only [Cochain.comp_v _ _ _ p q (q + 1) hpq rfl] at hâ‚\n    simp only [Cochain.comp_zero_cochain_v] at hâ‚‚\n    exact âŸ¨hâ‚, hâ‚‚âŸ©\n\n"}
{"name":"CochainComplex.mappingCone.ext_cochain_from_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nK : CochainComplex C Int\nÎ³â‚ Î³â‚‚ : CochainComplex.HomComplex.Cochain (CochainComplex.mappingCone Ï†) K j\nâŠ¢ Iff (Eq Î³â‚ Î³â‚‚) (And (Eq ((CochainComplex.mappingCone.inl Ï†).comp Î³â‚ â‹¯) ((CochainComplex.mappingCone.inl Ï†).comp Î³â‚‚ â‹¯)) (Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp Î³â‚ â‹¯) ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp Î³â‚‚ â‹¯)))","decl":"lemma ext_cochain_from_iff (i j : â„¤) (hij : i + 1 = j)\n    {K : CochainComplex C â„¤} {Î³â‚ Î³â‚‚ : Cochain (mappingCone Ï†) K j} :\n    Î³â‚ = Î³â‚‚ â†”\n      (inl Ï†).comp Î³â‚ (show _ = i by omega) = (inl Ï†).comp Î³â‚‚ (by omega) âˆ§\n        (Cochain.ofHom (inr Ï†)).comp Î³â‚ (zero_add j) =\n          (Cochain.ofHom (inr Ï†)).comp Î³â‚‚ (zero_add j) := by\n  constructor\n  Â· rintro rfl\n    tauto\n  Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n    ext p q hpq\n    rw [ext_from_iff Ï† (p + 1) p rfl]\n    replace hâ‚ := Cochain.congr_v hâ‚ (p + 1) q (by omega)\n    replace hâ‚‚ := Cochain.congr_v hâ‚‚ p q (by omega)\n    simp only [Cochain.comp_v (inl Ï†) _ _ (p + 1) p q (by omega) hpq] at hâ‚\n    simp only [Cochain.zero_cochain_comp_v, Cochain.ofHom_v] at hâ‚‚\n    exact âŸ¨hâ‚, hâ‚‚âŸ©\n\n"}
{"name":"CochainComplex.mappingCone.id","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq (HAdd.hAdd ((â†‘(CochainComplex.mappingCone.fst Ï†)).comp (CochainComplex.mappingCone.inl Ï†) â‹¯) ((CochainComplex.mappingCone.snd Ï†).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)) â‹¯)) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone Ï†)))","decl":"lemma id :\n    (fst Ï†).1.comp (inl Ï†) (add_neg_cancel 1) +\n      (snd Ï†).comp (Cochain.ofHom (inr Ï†)) (add_zero 0) = Cochain.ofHom (ğŸ™ _) := by\n  simp [ext_cochain_from_iff Ï† (-1) 0 (neg_add_cancel 1)]\n\n"}
{"name":"CochainComplex.mappingCone.id_X","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nâŠ¢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq) ((CochainComplex.mappingCone.inl Ï†).v q p â‹¯)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v p p â‹¯) ((CochainComplex.mappingCone.inr Ï†).f p))) (CategoryTheory.CategoryStruct.id ((CochainComplex.mappingCone Ï†).X p))","decl":"lemma id_X (p q : â„¤) (hpq : p + 1 = q) :\n    (fst Ï†).1.v p q hpq â‰« (inl Ï†).v q p (by omega) +\n      (snd Ï†).v p p (add_zero p) â‰« (inr Ï†).f p = ğŸ™ ((mappingCone Ï†).X p) := by\n  simpa only [Cochain.add_v, Cochain.comp_zero_cochain_v, Cochain.ofHom_v, id_f,\n    Cochain.comp_v _ _ (add_neg_cancel 1) p q p hpq (by omega)]\n    using Cochain.congr_v (id Ï†) p p (add_zero p)\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j k : Int\nhij : Eq (HAdd.hAdd i (-1)) j\nhik : Eq (HAdd.hAdd k (-1)) i\nZ : C\nh : Quiver.Hom ((CochainComplex.mappingCone Ï†).X i) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j hij) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d j i) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.comp (Ï†.f i) ((CochainComplex.mappingCone.inr Ï†).f i)) (CategoryTheory.CategoryStruct.comp (F.d i k) ((CochainComplex.mappingCone.inl Ï†).v k i hik))) h)","decl":"@[reassoc]\nlemma inl_v_d (i j k : â„¤) (hij : i + (-1) = j) (hik : k + (-1) = i) :\n    (inl Ï†).v i j hij â‰« (mappingCone Ï†).d j i =\n      Ï†.f i â‰« (inr Ï†).f i - F.d i k â‰« (inl Ï†).v _ _ hik := by\n  dsimp [mappingCone, inl, inr]\n  rw [homotopyCofiber.inlX_d Ï† j i k (by dsimp; omega) (by dsimp; omega)]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j k : Int\nhij : Eq (HAdd.hAdd i (-1)) j\nhik : Eq (HAdd.hAdd k (-1)) i\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v i j hij) ((CochainComplex.mappingCone Ï†).d j i)) (HSub.hSub (CategoryTheory.CategoryStruct.comp (Ï†.f i) ((CochainComplex.mappingCone.inr Ï†).f i)) (CategoryTheory.CategoryStruct.comp (F.d i k) ((CochainComplex.mappingCone.inl Ï†).v k i hik)))","decl":"@[reassoc]\nlemma inl_v_d (i j k : â„¤) (hij : i + (-1) = j) (hik : k + (-1) = i) :\n    (inl Ï†).v i j hij â‰« (mappingCone Ï†).d j i =\n      Ï†.f i â‰« (inr Ï†).f i - F.d i k â‰« (inl Ï†).v _ _ hik := by\n  dsimp [mappingCone, inl, inr]\n  rw [homotopyCofiber.inlX_d Ï† j i k (by dsimp; omega) (by dsimp; omega)]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nnâ‚ nâ‚‚ : Int\nZ : C\nh : Quiver.Hom ((CochainComplex.mappingCone Ï†).X nâ‚‚) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f nâ‚) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d nâ‚ nâ‚‚) h)) (CategoryTheory.CategoryStruct.comp (G.d nâ‚ nâ‚‚) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f nâ‚‚) h))","decl":"@[reassoc]\nlemma inr_f_d (nâ‚ nâ‚‚ : â„¤) :\n    (inr Ï†).f nâ‚ â‰« (mappingCone Ï†).d nâ‚ nâ‚‚ = G.d nâ‚ nâ‚‚ â‰« (inr Ï†).f nâ‚‚ := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nnâ‚ nâ‚‚ : Int\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f nâ‚) ((CochainComplex.mappingCone Ï†).d nâ‚ nâ‚‚)) (CategoryTheory.CategoryStruct.comp (G.d nâ‚ nâ‚‚) ((CochainComplex.mappingCone.inr Ï†).f nâ‚‚))","decl":"@[reassoc]\nlemma inr_f_d (nâ‚ nâ‚‚ : â„¤) :\n    (inr Ï†).f nâ‚ â‰« (mappingCone Ï†).d nâ‚ nâ‚‚ = G.d nâ‚ nâ‚‚ â‰« (inr Ï†).f nâ‚‚ := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j k : Int\nhij : Eq (HAdd.hAdd i 1) j\nhjk : Eq (HAdd.hAdd j 1) k\nZ : C\nh : Quiver.Hom (F.X k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d i j) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v j k hjk) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij) (F.d j k))) h)","decl":"@[reassoc]\nlemma d_fst_v (i j k : â„¤) (hij : i + 1 = j) (hjk : j + 1 = k) :\n    (mappingCone Ï†).d i j â‰« (fst Ï†).1.v j k hjk =\n      -(fst Ï†).1.v i j hij â‰« F.d j k := by\n  apply homotopyCofiber.d_fstX\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j k : Int\nhij : Eq (HAdd.hAdd i 1) j\nhjk : Eq (HAdd.hAdd j 1) k\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d i j) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v j k hjk)) (Neg.neg (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij) (F.d j k)))","decl":"@[reassoc]\nlemma d_fst_v (i j k : â„¤) (hij : i + 1 = j) (hjk : j + 1 = k) :\n    (mappingCone Ï†).d i j â‰« (fst Ï†).1.v j k hjk =\n      -(fst Ï†).1.v i j hij â‰« F.d j k := by\n  apply homotopyCofiber.d_fstX\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v'","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d (HSub.hSub i 1) i) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij)) (Neg.neg (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v (HSub.hSub i 1) i â‹¯) (F.d i j)))","decl":"@[reassoc (attr := simp)]\nlemma d_fst_v' (i j : â„¤) (hij : i + 1 = j) :\n    (mappingCone Ï†).d (i - 1) i â‰« (fst Ï†).1.v i j hij =\n      -(fst Ï†).1.v (i - 1) i (by omega) â‰« F.d i j :=\n  d_fst_v Ï† (i - 1) i j (by omega) hij\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nZ : C\nh : Quiver.Hom (F.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d (HSub.hSub i 1) i) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v (HSub.hSub i 1) i â‹¯) (F.d i j))) h)","decl":"@[reassoc (attr := simp)]\nlemma d_fst_v' (i j : â„¤) (hij : i + 1 = j) :\n    (mappingCone Ï†).d (i - 1) i â‰« (fst Ï†).1.v i j hij =\n      -(fst Ï†).1.v (i - 1) i (by omega) â‰« F.d i j :=\n  d_fst_v Ï† (i - 1) i j (by omega) hij\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nZ : C\nh : Quiver.Hom (G.X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d i j) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v j j â‹¯) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij) (Ï†.f j)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯) (G.d i j))) h)","decl":"@[reassoc]\nlemma d_snd_v (i j : â„¤) (hij : i + 1 = j) :\n    (mappingCone Ï†).d i j â‰« (snd Ï†).v j j (add_zero _) =\n      (fst Ï†).1.v i j hij â‰« Ï†.f j + (snd Ï†).v i i (add_zero i) â‰« G.d i j := by\n  dsimp [mappingCone, snd, fst]\n  simp only [Cochain.ofHoms_v]\n  apply homotopyCofiber.d_sndX\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d i j) ((CochainComplex.mappingCone.snd Ï†).v j j â‹¯)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v i j hij) (Ï†.f j)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v i i â‹¯) (G.d i j)))","decl":"@[reassoc]\nlemma d_snd_v (i j : â„¤) (hij : i + 1 = j) :\n    (mappingCone Ï†).d i j â‰« (snd Ï†).v j j (add_zero _) =\n      (fst Ï†).1.v i j hij â‰« Ï†.f j + (snd Ï†).v i i (add_zero i) â‰« G.d i j := by\n  dsimp [mappingCone, snd, fst]\n  simp only [Cochain.ofHoms_v]\n  apply homotopyCofiber.d_sndX\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v'","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nn : Int\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d (HSub.hSub n 1) n) ((CochainComplex.mappingCone.snd Ï†).v n n â‹¯)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v (HSub.hSub n 1) n â‹¯) (Ï†.f n)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v (HSub.hSub n 1) (HSub.hSub n 1) â‹¯) (G.d (HSub.hSub n 1) n)))","decl":"@[reassoc (attr := simp)]\nlemma d_snd_v' (n : â„¤) :\n    (mappingCone Ï†).d (n - 1) n â‰« (snd Ï†).v n n (add_zero n) =\n    (fst Ï† : Cochain (mappingCone Ï†) F 1).v (n - 1) n (by omega) â‰« Ï†.f n +\n      (snd Ï†).v (n - 1) (n - 1) (add_zero _) â‰« G.d (n - 1) n := by\n  apply d_snd_v\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nn : Int\nZ : C\nh : Quiver.Hom (G.X n) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone Ï†).d (HSub.hSub n 1) n) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v n n â‹¯) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v (HSub.hSub n 1) n â‹¯) (Ï†.f n)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v (HSub.hSub n 1) (HSub.hSub n 1) â‹¯) (G.d (HSub.hSub n 1) n))) h)","decl":"@[reassoc (attr := simp)]\nlemma d_snd_v' (n : â„¤) :\n    (mappingCone Ï†).d (n - 1) n â‰« (snd Ï†).v n n (add_zero n) =\n    (fst Ï† : Cochain (mappingCone Ï†) F 1).v (n - 1) n (by omega) â‰« Ï†.f n +\n      (snd Ï†).v (n - 1) (n - 1) (add_zero _) â‰« G.d (n - 1) n := by\n  apply d_snd_v\n\n"}
{"name":"CochainComplex.mappingCone.Î´_inl","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq (CochainComplex.HomComplex.Î´ (-1) 0 (CochainComplex.mappingCone.inl Ï†)) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† (CochainComplex.mappingCone.inr Ï†)))","decl":"@[simp]\nlemma Î´_inl :\n    Î´ (-1) 0 (inl Ï†) = Cochain.ofHom (Ï† â‰« inr Ï†) := by\n  ext p\n  simp [Î´_v (-1) 0 (neg_add_cancel 1) (inl Ï†) p p (add_zero p) _ _ rfl rfl,\n    inl_v_d Ï† p (p - 1) (p + 1) (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.Î´_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nâŠ¢ Eq (CochainComplex.HomComplex.Î´ 0 1 (CochainComplex.mappingCone.snd Ï†)) (Neg.neg ((â†‘(CochainComplex.mappingCone.fst Ï†)).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯))","decl":"@[simp]\nlemma Î´_snd :\n    Î´ 0 1 (snd Ï†) = -(fst Ï†).1.comp (Cochain.ofHom Ï†) (add_zero 1) := by\n  ext p q hpq\n  simp [d_snd_v Ï† p q hpq]\n\n"}
{"name":"CochainComplex.mappingCone.inl_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp (CochainComplex.mappingCone.descCochain Ï† Î± Î² h) â‹¯) Î±","decl":"@[simp]\nlemma inl_descCochain :\n    (inl Ï†).comp (descCochain Ï† Î± Î² h) (by omega) = Î± := by\n  simp [descCochain]\n\n"}
{"name":"CochainComplex.mappingCone.inr_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)).comp (CochainComplex.mappingCone.descCochain Ï† Î± Î² h) â‹¯) Î²","decl":"@[simp]\nlemma inr_descCochain :\n    (Cochain.ofHom (inr Ï†)).comp (descCochain Ï† Î± Î² h) (zero_add n) = Î² := by\n  simp [descCochain]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\npâ‚ pâ‚‚ pâ‚ƒ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ (-1)) pâ‚‚\nhâ‚‚â‚ƒ : Eq (HAdd.hAdd pâ‚‚ n) pâ‚ƒ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v pâ‚ pâ‚‚ hâ‚â‚‚) ((CochainComplex.mappingCone.descCochain Ï† Î± Î² h).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ)) (Î±.v pâ‚ pâ‚ƒ â‹¯)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descCochain_v (pâ‚ pâ‚‚ pâ‚ƒ : â„¤) (hâ‚â‚‚ : pâ‚ + (-1) = pâ‚‚) (hâ‚‚â‚ƒ : pâ‚‚ + n = pâ‚ƒ) :\n    (inl Ï†).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (descCochain Ï† Î± Î² h).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ =\n        Î±.v pâ‚ pâ‚ƒ (by rw [â† hâ‚‚â‚ƒ, â† hâ‚â‚‚, â† h, add_comm m, add_assoc, neg_add_cancel_left]) := by\n  simpa only [Cochain.comp_v _ _ (show -1 + n = m by omega) pâ‚ pâ‚‚ pâ‚ƒ\n    (by omega) (by omega)] using\n      Cochain.congr_v (inl_descCochain Ï† Î± Î² h) pâ‚ pâ‚ƒ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descCochain_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nhâœ : Eq (HAdd.hAdd m 1) n\npâ‚ pâ‚‚ pâ‚ƒ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ (-1)) pâ‚‚\nhâ‚‚â‚ƒ : Eq (HAdd.hAdd pâ‚‚ n) pâ‚ƒ\nZ : C\nh : Quiver.Hom (K.X pâ‚ƒ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v pâ‚ pâ‚‚ hâ‚â‚‚) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descCochain Ï† Î± Î² hâœ).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ) h)) (CategoryTheory.CategoryStruct.comp (Î±.v pâ‚ pâ‚ƒ â‹¯) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descCochain_v (pâ‚ pâ‚‚ pâ‚ƒ : â„¤) (hâ‚â‚‚ : pâ‚ + (-1) = pâ‚‚) (hâ‚‚â‚ƒ : pâ‚‚ + n = pâ‚ƒ) :\n    (inl Ï†).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (descCochain Ï† Î± Î² h).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ =\n        Î±.v pâ‚ pâ‚ƒ (by rw [â† hâ‚‚â‚ƒ, â† hâ‚â‚‚, â† h, add_comm m, add_assoc, neg_add_cancel_left]) := by\n  simpa only [Cochain.comp_v _ _ (show -1 + n = m by omega) pâ‚ pâ‚‚ pâ‚ƒ\n    (by omega) (by omega)] using\n      Cochain.congr_v (inl_descCochain Ï† Î± Î² h) pâ‚ pâ‚ƒ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\npâ‚ pâ‚‚ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f pâ‚) ((CochainComplex.mappingCone.descCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚)) (Î².v pâ‚ pâ‚‚ hâ‚â‚‚)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descCochain_v (pâ‚ pâ‚‚ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) :\n    (inr Ï†).f pâ‚ â‰« (descCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ = Î².v pâ‚ pâ‚‚ hâ‚â‚‚ := by\n  simpa only [Cochain.comp_v _ _ (zero_add n) pâ‚ pâ‚ pâ‚‚ (add_zero pâ‚) hâ‚â‚‚, Cochain.ofHom_v]\n    using Cochain.congr_v (inr_descCochain Ï† Î± Î² h) pâ‚ pâ‚‚ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descCochain_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nhâœ : Eq (HAdd.hAdd m 1) n\npâ‚ pâ‚‚ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nZ : C\nh : Quiver.Hom (K.X pâ‚‚) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f pâ‚) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descCochain Ï† Î± Î² hâœ).v pâ‚ pâ‚‚ hâ‚â‚‚) h)) (CategoryTheory.CategoryStruct.comp (Î².v pâ‚ pâ‚‚ hâ‚â‚‚) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descCochain_v (pâ‚ pâ‚‚ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) :\n    (inr Ï†).f pâ‚ â‰« (descCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ = Î².v pâ‚ pâ‚‚ hâ‚â‚‚ := by\n  simpa only [Cochain.comp_v _ _ (zero_add n) pâ‚ pâ‚ pâ‚‚ (add_zero pâ‚) hâ‚â‚‚, Cochain.ofHom_v]\n    using Cochain.congr_v (inr_descCochain Ï† Î± Î² h) pâ‚ pâ‚‚ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.Î´_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\nn' : Int\nhn' : Eq (HAdd.hAdd n 1) n'\nâŠ¢ Eq (CochainComplex.HomComplex.Î´ n n' (CochainComplex.mappingCone.descCochain Ï† Î± Î² h)) (HAdd.hAdd ((â†‘(CochainComplex.mappingCone.fst Ï†)).comp (HAdd.hAdd (CochainComplex.HomComplex.Î´ m n Î±) (HSMul.hSMul n'.negOnePow ((CochainComplex.HomComplex.Cochain.ofHom Ï†).comp Î² â‹¯))) â‹¯) ((CochainComplex.mappingCone.snd Ï†).comp (CochainComplex.HomComplex.Î´ n n' Î²) â‹¯))","decl":"lemma Î´_descCochain (n' : â„¤) (hn' : n + 1 = n') :\n    Î´ n n' (descCochain Ï† Î± Î² h) =\n      (fst Ï†).1.comp (Î´ m n Î± +\n          n'.negOnePow â€¢ (Cochain.ofHom Ï†).comp Î² (zero_add n)) (by omega) +\n      (snd Ï†).comp (Î´ n n' Î²) (zero_add n') := by\n  dsimp only [descCochain]\n  simp only [Î´_add, Cochain.comp_add, Î´_comp (fst Ï†).1 Î± _ 2 n n' hn' (by omega) (by omega),\n    Cocycle.Î´_eq_zero, Cochain.zero_comp, smul_zero, add_zero,\n    Î´_comp (snd Ï†) Î² (zero_add n) 1 n' n' hn' (zero_add 1) hn', Î´_snd, Cochain.neg_comp,\n    smul_neg, Cochain.comp_assoc_of_second_is_zero_cochain, Cochain.comp_units_smul, â† hn',\n    Int.negOnePow_succ, Units.neg_smul, Cochain.comp_neg]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.descCocycle_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain F K m\nÎ² : CochainComplex.HomComplex.Cocycle G K n\nh : Eq (HAdd.hAdd m 1) n\neq : Eq (CochainComplex.HomComplex.Î´ m n Î±) (HSMul.hSMul n.negOnePow ((CochainComplex.HomComplex.Cochain.ofHom Ï†).comp â†‘Î² â‹¯))\nâŠ¢ Eq (â†‘(CochainComplex.mappingCone.descCocycle Ï† Î± Î² h eq)) (CochainComplex.mappingCone.descCochain Ï† Î± (â†‘Î²) h)","decl":"/-- Given `Ï† : F âŸ¶ G`, this is the cocycle in `Cocycle (mappingCone Ï†) K n` that is\nconstructed from `Î± : Cochain F K m` (with `m + 1 = n`) and `Î² : Cocycle F K n`,\nwhen a suitable cocycle relation is satisfied. -/\n@[simps!]\nnoncomputable def descCocycle {K : CochainComplex C â„¤} {n m : â„¤}\n    (Î± : Cochain F K m) (Î² : Cocycle G K n)\n    (h : m + 1 = n) (eq : Î´ m n Î± = n.negOnePow â€¢ (Cochain.ofHom Ï†).comp Î².1 (zero_add n)) :\n    Cocycle (mappingCone Ï†) K n :=\n  Cocycle.mk (descCochain Ï† Î± Î².1 h) (n + 1) rfl\n    (by simp [Î´_descCochain _ _ _ _ _ rfl, eq, Int.negOnePow_succ])\n\n"}
{"name":"CochainComplex.mappingCone.ofHom_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\nâŠ¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.desc Ï† Î± Î² eq)) (CochainComplex.mappingCone.descCochain Ï† Î± (CochainComplex.HomComplex.Cochain.ofHom Î²) â‹¯)","decl":"@[simp]\nlemma ofHom_desc :\n    Cochain.ofHom (desc Ï† Î± Î² eq) = descCochain Ï† Î± (Cochain.ofHom Î²) (neg_add_cancel 1) := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\np q : Int\nh : Eq (HAdd.hAdd p (-1)) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q h) ((CochainComplex.mappingCone.desc Ï† Î± Î² eq).f q)) (Î±.v p q h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_desc_f (p q : â„¤) (h : p + (-1) = q) :\n    (inl Ï†).v p q h â‰« (desc Ï† Î± Î² eq).f q = Î±.v p q h := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\np q : Int\nhâœ : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (K.X q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl Ï†).v p q hâœ) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.desc Ï† Î± Î² eq).f q) h)) (CategoryTheory.CategoryStruct.comp (Î±.v p q hâœ) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_desc_f (p q : â„¤) (h : p + (-1) = q) :\n    (inl Ï†).v p q h â‰« (desc Ï† Î± Î² eq).f q = Î±.v p q h := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\nâŠ¢ Eq ((CochainComplex.mappingCone.inl Ï†).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.desc Ï† Î± Î² eq)) â‹¯) Î±","decl":"lemma inl_desc :\n    (inl Ï†).comp (Cochain.ofHom (desc Ï† Î± Î² eq)) (add_zero _) = Î± := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\np : Int\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) ((CochainComplex.mappingCone.desc Ï† Î± Î² eq).f p)) (Î².f p)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_desc_f (p : â„¤) :\n    (inr Ï†).f p â‰« (desc Ï† Î± Î² eq).f p = Î².f p := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\np : Int\nZ : C\nh : Quiver.Hom (K.X p) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr Ï†).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.desc Ï† Î± Î² eq).f p) h)) (CategoryTheory.CategoryStruct.comp (Î².f p) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_desc_f (p : â„¤) :\n    (inr Ï†).f p â‰« (desc Ï† Î± Î² eq).f p = Î².f p := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\nZ : CochainComplex C Int\nh : Quiver.Hom K Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr Ï†) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.desc Ï† Î± Î² eq) h)) (CategoryTheory.CategoryStruct.comp Î² h)","decl":"@[reassoc (attr := simp)]\nlemma inr_desc : inr Ï† â‰« desc Ï† Î± Î² eq = Î² := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.inr_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr Ï†) (CochainComplex.mappingCone.desc Ï† Î± Î² eq)) Î²","decl":"@[reassoc (attr := simp)]\nlemma inr_desc : inr Ï† â‰« desc Ï† Î± Î² eq = Î² := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cochain F K (-1)\nÎ² : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²))\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nâŠ¢ Eq ((CochainComplex.mappingCone.desc Ï† Î± Î² eq).f p) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq) (Î±.v q p â‹¯)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v p p â‹¯) (Î².f p)))","decl":"lemma desc_f (p q : â„¤) (hpq : p + 1 = q) :\n    (desc Ï† Î± Î² eq).f p = (fst Ï†).1.v p q hpq â‰« Î±.v q p (by omega) +\n      (snd Ï†).v p p (add_zero p) â‰« Î².f p := by\n  simp [ext_from_iff _ _ _ hpq]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\nâŠ¢ Eq ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).comp (â†‘(CochainComplex.mappingCone.fst Ï†)) h) Î±","decl":"@[simp]\nlemma liftCochain_fst :\n    (liftCochain Ï† Î± Î² h).comp (fst Ï†).1 h = Î± := by\n  simp [liftCochain]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\nâŠ¢ Eq ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).comp (CochainComplex.mappingCone.snd Ï†) â‹¯) Î²","decl":"@[simp]\nlemma liftCochain_snd :\n    (liftCochain Ï† Î± Î² h).comp (snd Ï†) (add_zero n) = Î² := by\n  simp [liftCochain]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\npâ‚ pâ‚‚ pâ‚ƒ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nhâ‚‚â‚ƒ : Eq (HAdd.hAdd pâ‚‚ 1) pâ‚ƒ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ)) (Î±.v pâ‚ pâ‚ƒ â‹¯)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_fst_v (pâ‚ pâ‚‚ pâ‚ƒ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) (hâ‚‚â‚ƒ : pâ‚‚ + 1 = pâ‚ƒ) :\n    (liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (fst Ï†).1.v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ = Î±.v pâ‚ pâ‚ƒ (by omega) := by\n  simpa only [Cochain.comp_v _ _ h pâ‚ pâ‚‚ pâ‚ƒ hâ‚â‚‚ hâ‚‚â‚ƒ]\n    using Cochain.congr_v (liftCochain_fst Ï† Î± Î² h) pâ‚ pâ‚ƒ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nhâœ : Eq (HAdd.hAdd n 1) m\npâ‚ pâ‚‚ pâ‚ƒ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nhâ‚‚â‚ƒ : Eq (HAdd.hAdd pâ‚‚ 1) pâ‚ƒ\nZ : C\nh : Quiver.Hom (F.X pâ‚ƒ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² hâœ).v pâ‚ pâ‚‚ hâ‚â‚‚) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ) h)) (CategoryTheory.CategoryStruct.comp (Î±.v pâ‚ pâ‚ƒ â‹¯) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_fst_v (pâ‚ pâ‚‚ pâ‚ƒ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) (hâ‚‚â‚ƒ : pâ‚‚ + 1 = pâ‚ƒ) :\n    (liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (fst Ï†).1.v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ = Î±.v pâ‚ pâ‚ƒ (by omega) := by\n  simpa only [Cochain.comp_v _ _ h pâ‚ pâ‚‚ pâ‚ƒ hâ‚â‚‚ hâ‚‚â‚ƒ]\n    using Cochain.congr_v (liftCochain_fst Ï† Î± Î² h) pâ‚ pâ‚ƒ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\npâ‚ pâ‚‚ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚) ((CochainComplex.mappingCone.snd Ï†).v pâ‚‚ pâ‚‚ â‹¯)) (Î².v pâ‚ pâ‚‚ hâ‚â‚‚)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_snd_v (pâ‚ pâ‚‚ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) :\n    (liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (snd Ï†).v pâ‚‚ pâ‚‚ (add_zero pâ‚‚) = Î².v pâ‚ pâ‚‚ hâ‚â‚‚ := by\n  simpa only [Cochain.comp_v _ _ (add_zero n) pâ‚ pâ‚‚ pâ‚‚ hâ‚â‚‚ (add_zero pâ‚‚)]\n    using Cochain.congr_v (liftCochain_snd Ï† Î± Î² h) pâ‚ pâ‚‚ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nhâœ : Eq (HAdd.hAdd n 1) m\npâ‚ pâ‚‚ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nZ : C\nh : Quiver.Hom (G.X pâ‚‚) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² hâœ).v pâ‚ pâ‚‚ hâ‚â‚‚) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v pâ‚‚ pâ‚‚ â‹¯) h)) (CategoryTheory.CategoryStruct.comp (Î².v pâ‚ pâ‚‚ hâ‚â‚‚) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_snd_v (pâ‚ pâ‚‚ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) :\n    (liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (snd Ï†).v pâ‚‚ pâ‚‚ (add_zero pâ‚‚) = Î².v pâ‚ pâ‚‚ hâ‚â‚‚ := by\n  simpa only [Cochain.comp_v _ _ (add_zero n) pâ‚ pâ‚‚ pâ‚‚ hâ‚â‚‚ (add_zero pâ‚‚)]\n    using Cochain.congr_v (liftCochain_snd Ï† Î± Î² h) pâ‚ pâ‚‚ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.Î´_liftCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\nm' : Int\nhm' : Eq (HAdd.hAdd m 1) m'\nâŠ¢ Eq (CochainComplex.HomComplex.Î´ n m (CochainComplex.mappingCone.liftCochain Ï† Î± Î² h)) (HAdd.hAdd (Neg.neg ((CochainComplex.HomComplex.Î´ m m' Î±).comp (CochainComplex.mappingCone.inl Ï†) â‹¯)) ((HAdd.hAdd (CochainComplex.HomComplex.Î´ n m Î²) (Î±.comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr Ï†)) â‹¯))","decl":"lemma Î´_liftCochain (m' : â„¤) (hm' : m + 1 = m') :\n    Î´ n m (liftCochain Ï† Î± Î² h) = -(Î´ m m' Î±).comp (inl Ï†) (by omega) +\n      (Î´ n m Î² + Î±.comp (Cochain.ofHom Ï†) (add_zero m)).comp\n        (Cochain.ofHom (inr Ï†)) (add_zero m) := by\n  dsimp only [liftCochain]\n  simp only [Î´_add, Î´_comp Î± (inl Ï†) _ m' _ _ h hm' (neg_add_cancel 1),\n    Î´_comp_zero_cochain _ _ _ h, Î´_inl, Cochain.ofHom_comp,\n    Int.negOnePow_neg, Int.negOnePow_one, Units.neg_smul, one_smul,\n    Î´_ofHom, Cochain.comp_zero, zero_add, Cochain.add_comp,\n    Cochain.comp_assoc_of_second_is_zero_cochain]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.liftCocycle_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cocycle K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ n m Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\nâŠ¢ Eq (â†‘(CochainComplex.mappingCone.liftCocycle Ï† Î± Î² h eq)) (CochainComplex.mappingCone.liftCochain Ï† (â†‘Î±) Î² h)","decl":"/-- Given `Ï† : F âŸ¶ G`, this is the cocycle in `Cocycle K (mappingCone Ï†) n` that is\nconstructed from `Î± : Cochain K F m` (with `n + 1 = m`) and `Î² : Cocycle K G n`,\nwhen a suitable cocycle relation is satisfied. -/\n@[simps!]\nnoncomputable def liftCocycle {K : CochainComplex C â„¤} {n m : â„¤}\n    (Î± : Cocycle K F m) (Î² : Cochain K G n) (h : n + 1 = m)\n    (eq : Î´ n m Î² + Î±.1.comp (Cochain.ofHom Ï†) (add_zero m) = 0) :\n    Cocycle K (mappingCone Ï†) n :=\n  Cocycle.mk (liftCochain Ï† Î± Î² h) m h (by\n    simp only [Î´_liftCochain Ï† Î± Î² h (m+1) rfl, eq,\n      Cocycle.Î´_eq_zero, Cochain.zero_comp, neg_zero, add_zero])\n\n"}
{"name":"CochainComplex.mappingCone.ofHom_lift","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\nâŠ¢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift Ï† Î± Î² eq)) (CochainComplex.mappingCone.liftCochain Ï† (â†‘Î±) Î² â‹¯)","decl":"@[simp]\nlemma ofHom_lift :\n    Cochain.ofHom (lift Ï† Î± Î² eq) = liftCochain Ï† Î± Î² (zero_add 1) := by\n  simp only [lift, Cocycle.cochain_ofHom_homOf_eq_coe, liftCocycle_coe]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nZ : C\nh : Quiver.Hom (F.X q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f p) (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp ((â†‘Î±).v p q hpq) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_fst_v (p q : â„¤) (hpq : p + 1 = q) :\n    (lift Ï† Î± Î² eq).f p â‰« (fst Ï†).1.v p q hpq = Î±.1.v p q hpq := by\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f p) ((â†‘(CochainComplex.mappingCone.fst Ï†)).v p q hpq)) ((â†‘Î±).v p q hpq)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_fst_v (p q : â„¤) (hpq : p + 1 = q) :\n    (lift Ï† Î± Î² eq).f p â‰« (fst Ï†).1.v p q hpq = Î±.1.v p q hpq := by\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift Ï† Î± Î² eq)).comp â†‘(CochainComplex.mappingCone.fst Ï†) â‹¯) â†‘Î±","decl":"lemma lift_fst :\n    (Cochain.ofHom (lift Ï† Î± Î² eq)).comp (fst Ï†).1 (zero_add 1) = Î±.1 := by simp\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 0) q\nZ : C\nh : Quiver.Hom (G.X q) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd Ï†).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp (Î².v p q hpq) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_snd_v (p q : â„¤) (hpq : p + 0 = q) :\n    (lift Ï† Î± Î² eq).f p â‰« (snd Ï†).v p q hpq = Î².v p q hpq := by\n  obtain rfl : q = p := by omega\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 0) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f p) ((CochainComplex.mappingCone.snd Ï†).v p q hpq)) (Î².v p q hpq)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_snd_v (p q : â„¤) (hpq : p + 0 = q) :\n    (lift Ï† Î± Î² eq).f p â‰« (snd Ï†).v p q hpq = Î².v p q hpq := by\n  obtain rfl : q = p := by omega\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\nâŠ¢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift Ï† Î± Î² eq)).comp (CochainComplex.mappingCone.snd Ï†) â‹¯) Î²","decl":"lemma lift_snd :\n    (Cochain.ofHom (lift Ï† Î± Î² eq)).comp (snd Ï†) (zero_add 0) = Î² := by simp\n\n"}
{"name":"CochainComplex.mappingCone.lift_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nâŠ¢ Eq ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f p) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘Î±).v p q hpq) ((CochainComplex.mappingCone.inl Ï†).v q p â‹¯)) (CategoryTheory.CategoryStruct.comp (Î².v p p â‹¯) ((CochainComplex.mappingCone.inr Ï†).f p)))","decl":"lemma lift_f (p q : â„¤) (hpq : p + 1 = q) :\n    (lift Ï† Î± Î² eq).f p = Î±.1.v p q hpq â‰«\n      (inl Ï†).v q p (by omega) + Î².v p p (add_zero p) â‰« (inr Ï†).f p := by\n  simp [ext_to_iff _ _ _ hpq]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK L : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nn' m' : Int\nÎ±' : CochainComplex.HomComplex.Cochain F L m'\nÎ²' : CochainComplex.HomComplex.Cochain G L n'\nh : Eq (HAdd.hAdd n 1) m\nh' : Eq (HAdd.hAdd m' 1) n'\np : Int\nhp : Eq (HAdd.hAdd n n') p\nâŠ¢ Eq ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).comp (CochainComplex.mappingCone.descCochain Ï† Î±' Î²' h') hp) (HAdd.hAdd (Î±.comp Î±' â‹¯) (Î².comp Î²' â‹¯))","decl":"@[simp]\nlemma liftCochain_descCochain :\n    (liftCochain Ï† Î± Î² h).comp (descCochain Ï† Î±' Î²' h') hp =\n      Î±.comp Î±' (by omega) + Î².comp Î²' (by omega) := by\n  simp [liftCochain, descCochain,\n    Cochain.comp_assoc Î± (inl Ï†) _ _ (show -1 + n' = m' by omega) (by linarith)]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK L : CochainComplex C Int\nn m : Int\nÎ± : CochainComplex.HomComplex.Cochain K F m\nÎ² : CochainComplex.HomComplex.Cochain K G n\nn' m' : Int\nÎ±' : CochainComplex.HomComplex.Cochain F L m'\nÎ²' : CochainComplex.HomComplex.Cochain G L n'\nh : Eq (HAdd.hAdd n 1) m\nh' : Eq (HAdd.hAdd m' 1) n'\npâ‚ pâ‚‚ pâ‚ƒ : Int\nhâ‚â‚‚ : Eq (HAdd.hAdd pâ‚ n) pâ‚‚\nhâ‚‚â‚ƒ : Eq (HAdd.hAdd pâ‚‚ n') pâ‚ƒ\nq : Int\nhq : Eq (HAdd.hAdd pâ‚ m) q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚) ((CochainComplex.mappingCone.descCochain Ï† Î±' Î²' h').v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (Î±.v pâ‚ q hq) (Î±'.v q pâ‚ƒ â‹¯)) (CategoryTheory.CategoryStruct.comp (Î².v pâ‚ pâ‚‚ hâ‚â‚‚) (Î²'.v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ)))","decl":"lemma liftCochain_v_descCochain_v (pâ‚ pâ‚‚ pâ‚ƒ : â„¤) (hâ‚â‚‚ : pâ‚ + n = pâ‚‚) (hâ‚‚â‚ƒ : pâ‚‚ + n' = pâ‚ƒ)\n    (q : â„¤) (hq : pâ‚ + m = q) :\n    (liftCochain Ï† Î± Î² h).v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« (descCochain Ï† Î±' Î²' h').v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ =\n      Î±.v pâ‚ q hq â‰« Î±'.v q pâ‚ƒ (by omega) + Î².v pâ‚ pâ‚‚ hâ‚â‚‚ â‰« Î²'.v pâ‚‚ pâ‚ƒ hâ‚‚â‚ƒ := by\n  have eq := Cochain.congr_v (liftCochain_descCochain Ï† Î± Î² Î±' Î²' h h' p hp) pâ‚ pâ‚ƒ (by omega)\n  simpa only [Cochain.comp_v _ _ hp pâ‚ pâ‚‚ pâ‚ƒ hâ‚â‚‚ hâ‚‚â‚ƒ, Cochain.add_v,\n    Cochain.comp_v _ _ _ _ _ _ hq (show q + m' = pâ‚ƒ by omega)] using eq\n\n"}
{"name":"CochainComplex.mappingCone.lift_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœ : HomologicalComplex.HasHomotopyCofiber Ï†\nK L : CochainComplex C Int\nÎ± : CochainComplex.HomComplex.Cocycle K F 1\nÎ² : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.Î´ 0 1 Î²) ((â†‘Î±).comp (CochainComplex.HomComplex.Cochain.ofHom Ï†) â‹¯)) 0\nÎ±' : CochainComplex.HomComplex.Cochain F L (-1)\nÎ²' : Quiver.Hom G L\neq' : Eq (CochainComplex.HomComplex.Î´ (-1) 0 Î±') (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp Ï† Î²'))\nn n' : Int\nhnn' : Eq (HAdd.hAdd n 1) n'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift Ï† Î± Î² eq).f n) ((CochainComplex.mappingCone.desc Ï† Î±' Î²' eq').f n)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘Î±).v n n' hnn') (Î±'.v n' n â‹¯)) (CategoryTheory.CategoryStruct.comp (Î².v n n â‹¯) (Î²'.f n)))","decl":"lemma lift_desc_f {K L : CochainComplex C â„¤} (Î± : Cocycle K F 1) (Î² : Cochain K G 0)\n    (eq : Î´ 0 1 Î² + Î±.1.comp (Cochain.ofHom Ï†) (add_zero 1) = 0)\n    (Î±' : Cochain F L (-1)) (Î²' : G âŸ¶ L)\n    (eq' : Î´ (-1) 0 Î±' = Cochain.ofHom (Ï† â‰« Î²')) (n n' : â„¤) (hnn' : n + 1 = n') :\n    (lift Ï† Î± Î² eq).f n â‰« (desc Ï† Î±' Î²' eq').f n =\n    Î±.1.v n n' hnn' â‰« Î±'.v n' n (by omega) + Î².v n n (add_zero n) â‰« Î²'.f n := by\n  simp only [lift, desc, Cocycle.homOf_f, liftCocycle_coe, descCocycle_coe, Cocycle.ofHom_coe,\n    liftCochain_v_descCochain_v Ï† Î±.1 Î² Î±' (Cochain.ofHom Î²') (zero_add 1) (neg_add_cancel 1) 0\n    (add_zero 0) n n n (add_zero n) (add_zero n) n' hnn', Cochain.ofHom_v]\n\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso'_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_4, u_2} D\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœÂ² : HomologicalComplex.HasHomotopyCofiber Ï†\nH : CategoryTheory.Functor C D\ninstâœÂ¹ : H.Additive\ninstâœ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nâŠ¢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso' Ï† H n m hnm).hom (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (H.map ((â†‘(CochainComplex.mappingCone.fst Ï†)).v n m â‹¯)) ((CochainComplex.mappingCone.inl ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)).v m n â‹¯)) (CategoryTheory.CategoryStruct.comp (H.map ((CochainComplex.mappingCone.snd Ï†).v n n â‹¯)) ((CochainComplex.mappingCone.inr ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)).f n)))","decl":"/-- If `H : C â¥¤ D` is an additive functor and `Ï†` is a morphism of cochain complexes\nin `C`, this is the comparison isomorphism (in each degree `n`) between the image\nby `H` of `mappingCone Ï†` and the mapping cone of the image by `H` of `Ï†`.\nIt is an auxiliary definition for `mapHomologicalComplexXIso` and\n`mapHomologicalComplexIso`. This definition takes an extra\nparameter `m : â„¤` such that `n + 1 = m` which may help getting better\ndefinitional properties. See also the equational lemma `mapHomologicalComplexXIso_eq`. -/\n@[simps]\nnoncomputable def mapHomologicalComplexXIso' (n m : â„¤) (hnm : n + 1 = m) :\n    ((H.mapHomologicalComplex (ComplexShape.up â„¤)).obj (mappingCone Ï†)).X n â‰…\n      (mappingCone ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).X n where\n  hom := H.map ((fst Ï†).1.v n m (by omega)) â‰«\n      (inl ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).v m n (by omega) +\n      H.map ((snd Ï†).v n n (add_zero n)) â‰«\n        (inr ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).f n\n  inv := (fst ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).1.v n m (by omega) â‰«\n      H.map ((inl Ï†).v m n (by omega)) +\n      (snd ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).v n n (add_zero n) â‰«\n        H.map ((inr Ï†).f n)\n  hom_inv_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      inl_v_fst_v_assoc, inr_f_fst_v_assoc, zero_comp, comp_zero, add_zero,\n      inl_v_snd_v_assoc, inr_f_snd_v_assoc, zero_add, â† Functor.map_comp, â† Functor.map_add]\n    rw [â† H.map_id]\n    congr 1\n    simp [ext_from_iff  _ _ _ hnm]\n  inv_hom_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      â† H.map_comp_assoc, inl_v_fst_v, CategoryTheory.Functor.map_id, id_comp, inr_f_fst_v,\n      inl_v_snd_v, inr_f_snd_v]\n    simp [ext_from_iff _ _ _ hnm]\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso'_inv","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_4, u_2} D\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœÂ² : HomologicalComplex.HasHomotopyCofiber Ï†\nH : CategoryTheory.Functor C D\ninstâœÂ¹ : H.Additive\ninstâœ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nâŠ¢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso' Ï† H n m hnm).inv (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((â†‘(CochainComplex.mappingCone.fst ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†))).v n m â‹¯) (H.map ((CochainComplex.mappingCone.inl Ï†).v m n â‹¯))) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)).v n n â‹¯) (H.map ((CochainComplex.mappingCone.inr Ï†).f n))))","decl":"/-- If `H : C â¥¤ D` is an additive functor and `Ï†` is a morphism of cochain complexes\nin `C`, this is the comparison isomorphism (in each degree `n`) between the image\nby `H` of `mappingCone Ï†` and the mapping cone of the image by `H` of `Ï†`.\nIt is an auxiliary definition for `mapHomologicalComplexXIso` and\n`mapHomologicalComplexIso`. This definition takes an extra\nparameter `m : â„¤` such that `n + 1 = m` which may help getting better\ndefinitional properties. See also the equational lemma `mapHomologicalComplexXIso_eq`. -/\n@[simps]\nnoncomputable def mapHomologicalComplexXIso' (n m : â„¤) (hnm : n + 1 = m) :\n    ((H.mapHomologicalComplex (ComplexShape.up â„¤)).obj (mappingCone Ï†)).X n â‰…\n      (mappingCone ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).X n where\n  hom := H.map ((fst Ï†).1.v n m (by omega)) â‰«\n      (inl ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).v m n (by omega) +\n      H.map ((snd Ï†).v n n (add_zero n)) â‰«\n        (inr ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).f n\n  inv := (fst ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).1.v n m (by omega) â‰«\n      H.map ((inl Ï†).v m n (by omega)) +\n      (snd ((H.mapHomologicalComplex (ComplexShape.up â„¤)).map Ï†)).v n n (add_zero n) â‰«\n        H.map ((inr Ï†).f n)\n  hom_inv_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      inl_v_fst_v_assoc, inr_f_fst_v_assoc, zero_comp, comp_zero, add_zero,\n      inl_v_snd_v_assoc, inr_f_snd_v_assoc, zero_add, â† Functor.map_comp, â† Functor.map_add]\n    rw [â† H.map_id]\n    congr 1\n    simp [ext_from_iff  _ _ _ hnm]\n  inv_hom_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      â† H.map_comp_assoc, inl_v_fst_v, CategoryTheory.Functor.map_id, id_comp, inr_f_fst_v,\n      inl_v_snd_v, inr_f_snd_v]\n    simp [ext_from_iff _ _ _ hnm]\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_3, u_2} D\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœÂ² : HomologicalComplex.HasHomotopyCofiber Ï†\nH : CategoryTheory.Functor C D\ninstâœÂ¹ : H.Additive\ninstâœ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\nâŠ¢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso Ï† H n) (CochainComplex.mappingCone.mapHomologicalComplexXIso' Ï† H n m hnm)","decl":"lemma mapHomologicalComplexXIso_eq (n m : â„¤) (hnm : n + 1 = m) :\n    mapHomologicalComplexXIso Ï† H n = mapHomologicalComplexXIso' Ï† H n m hnm := by\n  subst hnm\n  rfl\n\n"}
{"name":"CochainComplex.mappingCone.map_inr","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_3, u_2} D\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nÏ† : Quiver.Hom F G\ninstâœÂ² : HomologicalComplex.HasHomotopyCofiber Ï†\nH : CategoryTheory.Functor C D\ninstâœÂ¹ : H.Additive\ninstâœ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((H.mapHomologicalComplex (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr Ï†)) (CochainComplex.mappingCone.mapHomologicalComplexIso Ï† H).hom) (CochainComplex.mappingCone.inr ((H.mapHomologicalComplex (ComplexShape.up Int)).map Ï†))","decl":"lemma map_inr :\n    (H.mapHomologicalComplex (ComplexShape.up â„¤)).map (inr Ï†) â‰«\n      (mapHomologicalComplexIso Ï† H).hom =\n    inr ((Functor.mapHomologicalComplex H (ComplexShape.up â„¤)).map Ï†) := by\n  ext n\n  dsimp [mapHomologicalComplexIso]\n  simp only [mapHomologicalComplexXIso_eq Ï† H n (n + 1) rfl, mappingCone.ext_to_iff _ _ _ rfl,\n    Functor.mapHomologicalComplex_obj_X, mapHomologicalComplexXIso'_hom, comp_add,\n    add_comp, assoc, inl_v_fst_v, comp_id, inr_f_fst_v, comp_zero, add_zero, inl_v_snd_v,\n    inr_f_snd_v, zero_add, â† H.map_comp, H.map_zero, H.map_id, and_self]\n\n"}
