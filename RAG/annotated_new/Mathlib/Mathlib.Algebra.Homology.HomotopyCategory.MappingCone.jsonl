{"name":"CochainComplex.instHasHomotopyCofiberOfHasBinaryBiproductXHAddOfNat","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_3\ninst✝² : AddRightCancelSemigroup ι\ninst✝¹ : One ι\nF G : CochainComplex C ι\nφ : Quiver.Hom F G\ninst✝ : ∀ (p : ι), CategoryTheory.Limits.HasBinaryBiproduct (F.X (HAdd.hAdd p 1)) (G.X p)\n⊢ HomologicalComplex.HasHomotopyCofiber φ","decl":"instance [∀ p, HasBinaryBiproduct (F.X (p + 1)) (G.X p)] :\n    HasHomotopyCofiber φ where\n  hasBinaryBiproduct := by\n    rintro i _ rfl\n    infer_instance\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd q 1) p\nZ : C\nh : Quiver.Hom (F.X p) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q ⋯) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v q p hpq) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inl_v_fst_v (p q : ℤ) (hpq : q + 1 = p) :\n    (inl φ).v p q (by rw [← hpq, add_neg_cancel_right]) ≫\n      (fst φ : Cochain (mappingCone φ) F 1).v q p hpq = 𝟙 _ := by\n  simp [inl, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd q 1) p\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q ⋯) ((↑(CochainComplex.mappingCone.fst φ)).v q p hpq)) (CategoryTheory.CategoryStruct.id (F.X p))","decl":"@[reassoc (attr := simp)]\nlemma inl_v_fst_v (p q : ℤ) (hpq : q + 1 = p) :\n    (inl φ).v p q (by rw [← hpq, add_neg_cancel_right]) ≫\n      (fst φ : Cochain (mappingCone φ) F 1).v q p hpq = 𝟙 _ := by\n  simp [inl, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q hpq) ((CochainComplex.mappingCone.snd φ).v q q ⋯)) 0","decl":"@[reassoc (attr := simp)]\nlemma inl_v_snd_v (p q : ℤ) (hpq : p + (-1) = q) :\n    (inl φ).v p q hpq ≫ (snd φ).v q q (add_zero q) = 0 := by\n  simp [inl, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (G.X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q hpq) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v q q ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_snd_v (p q : ℤ) (hpq : p + (-1) = q) :\n    (inl φ).v p q hpq ≫ (snd φ).v q q (add_zero q) = 0 := by\n  simp [inl, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq)) 0","decl":"@[reassoc (attr := simp)]\nlemma inr_f_fst_v (p q : ℤ) (hpq : p + 1 = q) :\n    (inr φ).f p ≫ (fst φ).1.v p q hpq = 0 := by\n  simp [inr, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nZ : C\nh : Quiver.Hom (F.X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_fst_v (p q : ℤ) (hpq : p + 1 = q) :\n    (inr φ).f p ≫ (fst φ).1.v p q hpq = 0 := by\n  simp [inr, fst]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) ((CochainComplex.mappingCone.snd φ).v p p ⋯)) (CategoryTheory.CategoryStruct.id (G.X p))","decl":"@[reassoc (attr := simp)]\nlemma inr_f_snd_v (p : ℤ) :\n    (inr φ).f p ≫ (snd φ).v p p (add_zero p) = 𝟙 _ := by\n  simp [inr, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np : Int\nZ : C\nh : Quiver.Hom (G.X p) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v p p ⋯) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inr_f_snd_v (p : ℤ) :\n    (inr φ).f p ≫ (snd φ).v p p (add_zero p) = 𝟙 _ := by\n  simp [inr, snd]\n\n"}
{"name":"CochainComplex.mappingCone.inl_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp ↑(CochainComplex.mappingCone.fst φ) ⋯) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id F))","decl":"@[simp]\nlemma inl_fst :\n    (inl φ).comp (fst φ).1 (neg_add_cancel 1) = Cochain.ofHom (𝟙 F) := by\n  ext p\n  simp [Cochain.comp_v _ _ (neg_add_cancel 1) p (p-1) p rfl (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inl_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp (CochainComplex.mappingCone.snd φ) ⋯) 0","decl":"@[simp]\nlemma inl_snd :\n    (inl φ).comp (snd φ) (add_zero (-1)) = 0 := by\n  ext p q hpq\n  simp [Cochain.comp_v _ _ (add_zero (-1)) p q q (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inr_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp ↑(CochainComplex.mappingCone.fst φ) ⋯) 0","decl":"@[simp]\nlemma inr_fst :\n    (Cochain.ofHom (inr φ)).comp (fst φ).1 (zero_add 1) = 0 := by\n  ext p q hpq\n  simp [Cochain.comp_v _ _ (zero_add 1) p p q (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.inr_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp (CochainComplex.mappingCone.snd φ) ⋯) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id G))","decl":"@[simp]\nlemma inr_snd :\n    (Cochain.ofHom (inr φ)).comp (snd φ) (zero_add 0) = Cochain.ofHom (𝟙 G) := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.inl_fst_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nd e : Int\nγ : CochainComplex.HomComplex.Cochain F K d\nhe : Eq (HAdd.hAdd 1 d) e\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp ((↑(CochainComplex.mappingCone.fst φ)).comp γ he) ⋯) γ","decl":"@[simp]\nlemma inl_fst_assoc {K : CochainComplex C ℤ} {d e : ℤ} (γ : Cochain F K d) (he : 1 + d = e) :\n    (inl φ).comp ((fst φ).1.comp γ he) (by rw [← he, neg_add_cancel_left]) = γ := by\n  rw [← Cochain.comp_assoc _ _ _ (neg_add_cancel 1) (by omega) (by omega), inl_fst,\n    Cochain.id_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inl_snd_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nd e f : Int\nγ : CochainComplex.HomComplex.Cochain G K d\nhe : Eq (HAdd.hAdd 0 d) e\nhf : Eq (HAdd.hAdd (-1) e) f\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp ((CochainComplex.mappingCone.snd φ).comp γ he) hf) 0","decl":"@[simp]\nlemma inl_snd_assoc {K : CochainComplex C ℤ} {d e f : ℤ} (γ : Cochain G K d)\n    (he : 0 + d = e) (hf : -1 + e = f) :\n    (inl φ).comp ((snd φ).comp γ he) hf = 0 := by\n  obtain rfl : e = d := by omega\n  rw [← Cochain.comp_assoc_of_second_is_zero_cochain, inl_snd, Cochain.zero_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inr_fst_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nd e f : Int\nγ : CochainComplex.HomComplex.Cochain F K d\nhe : Eq (HAdd.hAdd 1 d) e\nhf : Eq (HAdd.hAdd 0 e) f\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp ((↑(CochainComplex.mappingCone.fst φ)).comp γ he) hf) 0","decl":"@[simp]\nlemma inr_fst_assoc {K : CochainComplex C ℤ} {d e f : ℤ} (γ : Cochain F K d)\n    (he : 1 + d = e) (hf : 0 + e = f) :\n    (Cochain.ofHom (inr φ)).comp ((fst φ).1.comp γ he) hf = 0 := by\n  obtain rfl : e = f := by omega\n  rw [← Cochain.comp_assoc_of_first_is_zero_cochain, inr_fst, Cochain.zero_comp]\n\n"}
{"name":"CochainComplex.mappingCone.inr_snd_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nd e : Int\nγ : CochainComplex.HomComplex.Cochain G K d\nhe : Eq (HAdd.hAdd 0 d) e\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp ((CochainComplex.mappingCone.snd φ).comp γ he) ⋯) γ","decl":"@[simp]\nlemma inr_snd_assoc {K : CochainComplex C ℤ} {d e : ℤ} (γ : Cochain G K d) (he : 0 + d = e) :\n    (Cochain.ofHom (inr φ)).comp ((snd φ).comp γ he) (by simp only [← he, zero_add]) = γ := by\n  obtain rfl : d = e := by omega\n  rw [← Cochain.comp_assoc_of_first_is_zero_cochain, inr_snd, Cochain.id_comp]\n\n"}
{"name":"CochainComplex.mappingCone.ext_to","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nA : C\nf g : Quiver.Hom A ((CochainComplex.mappingCone φ).X i)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp f ((↑(CochainComplex.mappingCone.fst φ)).v i j hij)) (CategoryTheory.CategoryStruct.comp g ((↑(CochainComplex.mappingCone.fst φ)).v i j hij))\nh₂ : Eq (CategoryTheory.CategoryStruct.comp f ((CochainComplex.mappingCone.snd φ).v i i ⋯)) (CategoryTheory.CategoryStruct.comp g ((CochainComplex.mappingCone.snd φ).v i i ⋯))\n⊢ Eq f g","decl":"lemma ext_to (i j : ℤ) (hij : i + 1 = j) {A : C} {f g : A ⟶ (mappingCone φ).X i}\n    (h₁ : f ≫ (fst φ).1.v i j hij = g ≫ (fst φ).1.v i j hij)\n    (h₂ : f ≫ (snd φ).v i i (add_zero i) = g ≫ (snd φ).v i i (add_zero i)) :\n    f = g :=\n  homotopyCofiber.ext_to_X φ i j hij h₁ (by simpa [snd] using h₂)\n\n"}
{"name":"CochainComplex.mappingCone.ext_to_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nA : C\nf g : Quiver.Hom A ((CochainComplex.mappingCone φ).X i)\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp f ((↑(CochainComplex.mappingCone.fst φ)).v i j hij)) (CategoryTheory.CategoryStruct.comp g ((↑(CochainComplex.mappingCone.fst φ)).v i j hij))) (Eq (CategoryTheory.CategoryStruct.comp f ((CochainComplex.mappingCone.snd φ).v i i ⋯)) (CategoryTheory.CategoryStruct.comp g ((CochainComplex.mappingCone.snd φ).v i i ⋯))))","decl":"lemma ext_to_iff (i j : ℤ) (hij : i + 1 = j) {A : C} (f g : A ⟶ (mappingCone φ).X i) :\n    f = g ↔ f ≫ (fst φ).1.v i j hij = g ≫ (fst φ).1.v i j hij ∧\n      f ≫ (snd φ).v i i (add_zero i) = g ≫ (snd φ).v i i (add_zero i) := by\n  constructor\n  · rintro rfl\n    tauto\n  · rintro ⟨h₁, h₂⟩\n    exact ext_to φ i j hij h₁ h₂\n\n"}
{"name":"CochainComplex.mappingCone.ext_from","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd j 1) i\nA : C\nf g : Quiver.Hom ((CochainComplex.mappingCone φ).X j) A\nh₁ : Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j ⋯) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j ⋯) g)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f j) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f j) g)\n⊢ Eq f g","decl":"lemma ext_from (i j : ℤ) (hij : j + 1 = i) {A : C} {f g : (mappingCone φ).X j ⟶ A}\n    (h₁ : (inl φ).v i j (by omega) ≫ f = (inl φ).v i j (by omega) ≫ g)\n    (h₂ : (inr φ).f j ≫ f = (inr φ).f j ≫ g) :\n    f = g :=\n  homotopyCofiber.ext_from_X φ i j hij h₁ h₂\n\n"}
{"name":"CochainComplex.mappingCone.ext_from_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd j 1) i\nA : C\nf g : Quiver.Hom ((CochainComplex.mappingCone φ).X j) A\n⊢ Iff (Eq f g) (And (Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j ⋯) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j ⋯) g)) (Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f j) f) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f j) g)))","decl":"lemma ext_from_iff (i j : ℤ) (hij : j + 1 = i) {A : C} (f g : (mappingCone φ).X j ⟶ A) :\n    f = g ↔ (inl φ).v i j (by omega) ≫ f = (inl φ).v i j (by omega) ≫ g ∧\n      (inr φ).f j ≫ f = (inr φ).f j ≫ g := by\n  constructor\n  · rintro rfl\n    tauto\n  · rintro ⟨h₁, h₂⟩\n    exact ext_from φ i j hij h₁ h₂\n\n"}
{"name":"CochainComplex.mappingCone.decomp_to","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni : Int\nA : C\nf : Quiver.Hom A ((CochainComplex.mappingCone φ).X i)\nj : Int\nhij : Eq (HAdd.hAdd i 1) j\n⊢ Exists fun a => Exists fun b => Eq f (HAdd.hAdd (CategoryTheory.CategoryStruct.comp a ((CochainComplex.mappingCone.inl φ).v j i ⋯)) (CategoryTheory.CategoryStruct.comp b ((CochainComplex.mappingCone.inr φ).f i)))","decl":"lemma decomp_to {i : ℤ} {A : C} (f : A ⟶ (mappingCone φ).X i) (j : ℤ) (hij : i + 1 = j) :\n    ∃ (a : A ⟶ F.X j) (b : A ⟶ G.X i), f = a ≫ (inl φ).v j i (by omega) + b ≫ (inr φ).f i :=\n  ⟨f ≫ (fst φ).1.v i j hij, f ≫ (snd φ).v i i (add_zero i),\n    by apply ext_to φ i j hij <;> simp⟩\n\n"}
{"name":"CochainComplex.mappingCone.decomp_from","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nj : Int\nA : C\nf : Quiver.Hom ((CochainComplex.mappingCone φ).X j) A\ni : Int\nhij : Eq (HAdd.hAdd j 1) i\n⊢ Exists fun a => Exists fun b => Eq f (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v j i hij) a) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v j j ⋯) b))","decl":"lemma decomp_from {j : ℤ} {A : C} (f : (mappingCone φ).X j ⟶ A) (i : ℤ) (hij : j + 1 = i) :\n    ∃ (a : F.X i ⟶ A) (b : G.X j ⟶ A),\n      f = (fst φ).1.v j i hij ≫ a + (snd φ).v j j (add_zero j) ≫ b :=\n  ⟨(inl φ).v i j (by omega) ≫ f, (inr φ).f j ≫ f,\n    by apply ext_from φ i j hij <;> simp⟩\n\n"}
{"name":"CochainComplex.mappingCone.ext_cochain_to_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nK : CochainComplex C Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain K (CochainComplex.mappingCone φ) i\n⊢ Iff (Eq γ₁ γ₂) (And (Eq (γ₁.comp (↑(CochainComplex.mappingCone.fst φ)) hij) (γ₂.comp (↑(CochainComplex.mappingCone.fst φ)) hij)) (Eq (γ₁.comp (CochainComplex.mappingCone.snd φ) ⋯) (γ₂.comp (CochainComplex.mappingCone.snd φ) ⋯)))","decl":"lemma ext_cochain_to_iff (i j : ℤ) (hij : i + 1 = j)\n    {K : CochainComplex C ℤ} {γ₁ γ₂ : Cochain K (mappingCone φ) i} :\n    γ₁ = γ₂ ↔ γ₁.comp (fst φ).1 hij = γ₂.comp (fst φ).1 hij ∧\n      γ₁.comp (snd φ) (add_zero i) = γ₂.comp (snd φ) (add_zero i) := by\n  constructor\n  · rintro rfl\n    tauto\n  · rintro ⟨h₁, h₂⟩\n    ext p q hpq\n    rw [ext_to_iff φ q (q + 1) rfl]\n    replace h₁ := Cochain.congr_v h₁ p (q + 1) (by omega)\n    replace h₂ := Cochain.congr_v h₂ p q hpq\n    simp only [Cochain.comp_v _ _ _ p q (q + 1) hpq rfl] at h₁\n    simp only [Cochain.comp_zero_cochain_v] at h₂\n    exact ⟨h₁, h₂⟩\n\n"}
{"name":"CochainComplex.mappingCone.ext_cochain_from_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nK : CochainComplex C Int\nγ₁ γ₂ : CochainComplex.HomComplex.Cochain (CochainComplex.mappingCone φ) K j\n⊢ Iff (Eq γ₁ γ₂) (And (Eq ((CochainComplex.mappingCone.inl φ).comp γ₁ ⋯) ((CochainComplex.mappingCone.inl φ).comp γ₂ ⋯)) (Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp γ₁ ⋯) ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp γ₂ ⋯)))","decl":"lemma ext_cochain_from_iff (i j : ℤ) (hij : i + 1 = j)\n    {K : CochainComplex C ℤ} {γ₁ γ₂ : Cochain (mappingCone φ) K j} :\n    γ₁ = γ₂ ↔\n      (inl φ).comp γ₁ (show _ = i by omega) = (inl φ).comp γ₂ (by omega) ∧\n        (Cochain.ofHom (inr φ)).comp γ₁ (zero_add j) =\n          (Cochain.ofHom (inr φ)).comp γ₂ (zero_add j) := by\n  constructor\n  · rintro rfl\n    tauto\n  · rintro ⟨h₁, h₂⟩\n    ext p q hpq\n    rw [ext_from_iff φ (p + 1) p rfl]\n    replace h₁ := Cochain.congr_v h₁ (p + 1) q (by omega)\n    replace h₂ := Cochain.congr_v h₂ p q (by omega)\n    simp only [Cochain.comp_v (inl φ) _ _ (p + 1) p q (by omega) hpq] at h₁\n    simp only [Cochain.zero_cochain_comp_v, Cochain.ofHom_v] at h₂\n    exact ⟨h₁, h₂⟩\n\n"}
{"name":"CochainComplex.mappingCone.id","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq (HAdd.hAdd ((↑(CochainComplex.mappingCone.fst φ)).comp (CochainComplex.mappingCone.inl φ) ⋯) ((CochainComplex.mappingCone.snd φ).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)) ⋯)) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.id (CochainComplex.mappingCone φ)))","decl":"lemma id :\n    (fst φ).1.comp (inl φ) (add_neg_cancel 1) +\n      (snd φ).comp (Cochain.ofHom (inr φ)) (add_zero 0) = Cochain.ofHom (𝟙 _) := by\n  simp [ext_cochain_from_iff φ (-1) 0 (neg_add_cancel 1)]\n\n"}
{"name":"CochainComplex.mappingCone.id_X","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq) ((CochainComplex.mappingCone.inl φ).v q p ⋯)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v p p ⋯) ((CochainComplex.mappingCone.inr φ).f p))) (CategoryTheory.CategoryStruct.id ((CochainComplex.mappingCone φ).X p))","decl":"lemma id_X (p q : ℤ) (hpq : p + 1 = q) :\n    (fst φ).1.v p q hpq ≫ (inl φ).v q p (by omega) +\n      (snd φ).v p p (add_zero p) ≫ (inr φ).f p = 𝟙 ((mappingCone φ).X p) := by\n  simpa only [Cochain.add_v, Cochain.comp_zero_cochain_v, Cochain.ofHom_v, id_f,\n    Cochain.comp_v _ _ (add_neg_cancel 1) p q p hpq (by omega)]\n    using Cochain.congr_v (id φ) p p (add_zero p)\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j k : Int\nhij : Eq (HAdd.hAdd i (-1)) j\nhik : Eq (HAdd.hAdd k (-1)) i\nZ : C\nh : Quiver.Hom ((CochainComplex.mappingCone φ).X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j hij) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d j i) h)) (CategoryTheory.CategoryStruct.comp (HSub.hSub (CategoryTheory.CategoryStruct.comp (φ.f i) ((CochainComplex.mappingCone.inr φ).f i)) (CategoryTheory.CategoryStruct.comp (F.d i k) ((CochainComplex.mappingCone.inl φ).v k i hik))) h)","decl":"@[reassoc]\nlemma inl_v_d (i j k : ℤ) (hij : i + (-1) = j) (hik : k + (-1) = i) :\n    (inl φ).v i j hij ≫ (mappingCone φ).d j i =\n      φ.f i ≫ (inr φ).f i - F.d i k ≫ (inl φ).v _ _ hik := by\n  dsimp [mappingCone, inl, inr]\n  rw [homotopyCofiber.inlX_d φ j i k (by dsimp; omega) (by dsimp; omega)]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j k : Int\nhij : Eq (HAdd.hAdd i (-1)) j\nhik : Eq (HAdd.hAdd k (-1)) i\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v i j hij) ((CochainComplex.mappingCone φ).d j i)) (HSub.hSub (CategoryTheory.CategoryStruct.comp (φ.f i) ((CochainComplex.mappingCone.inr φ).f i)) (CategoryTheory.CategoryStruct.comp (F.d i k) ((CochainComplex.mappingCone.inl φ).v k i hik)))","decl":"@[reassoc]\nlemma inl_v_d (i j k : ℤ) (hij : i + (-1) = j) (hik : k + (-1) = i) :\n    (inl φ).v i j hij ≫ (mappingCone φ).d j i =\n      φ.f i ≫ (inr φ).f i - F.d i k ≫ (inl φ).v _ _ hik := by\n  dsimp [mappingCone, inl, inr]\n  rw [homotopyCofiber.inlX_d φ j i k (by dsimp; omega) (by dsimp; omega)]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_d_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nn₁ n₂ : Int\nZ : C\nh : Quiver.Hom ((CochainComplex.mappingCone φ).X n₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f n₁) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d n₁ n₂) h)) (CategoryTheory.CategoryStruct.comp (G.d n₁ n₂) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f n₂) h))","decl":"@[reassoc]\nlemma inr_f_d (n₁ n₂ : ℤ) :\n    (inr φ).f n₁ ≫ (mappingCone φ).d n₁ n₂ = G.d n₁ n₂ ≫ (inr φ).f n₂ := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_d","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nn₁ n₂ : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f n₁) ((CochainComplex.mappingCone φ).d n₁ n₂)) (CategoryTheory.CategoryStruct.comp (G.d n₁ n₂) ((CochainComplex.mappingCone.inr φ).f n₂))","decl":"@[reassoc]\nlemma inr_f_d (n₁ n₂ : ℤ) :\n    (inr φ).f n₁ ≫ (mappingCone φ).d n₁ n₂ = G.d n₁ n₂ ≫ (inr φ).f n₂ := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j k : Int\nhij : Eq (HAdd.hAdd i 1) j\nhjk : Eq (HAdd.hAdd j 1) k\nZ : C\nh : Quiver.Hom (F.X k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d i j) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v j k hjk) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v i j hij) (F.d j k))) h)","decl":"@[reassoc]\nlemma d_fst_v (i j k : ℤ) (hij : i + 1 = j) (hjk : j + 1 = k) :\n    (mappingCone φ).d i j ≫ (fst φ).1.v j k hjk =\n      -(fst φ).1.v i j hij ≫ F.d j k := by\n  apply homotopyCofiber.d_fstX\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j k : Int\nhij : Eq (HAdd.hAdd i 1) j\nhjk : Eq (HAdd.hAdd j 1) k\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d i j) ((↑(CochainComplex.mappingCone.fst φ)).v j k hjk)) (Neg.neg (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v i j hij) (F.d j k)))","decl":"@[reassoc]\nlemma d_fst_v (i j k : ℤ) (hij : i + 1 = j) (hjk : j + 1 = k) :\n    (mappingCone φ).d i j ≫ (fst φ).1.v j k hjk =\n      -(fst φ).1.v i j hij ≫ F.d j k := by\n  apply homotopyCofiber.d_fstX\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v'","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d (HSub.hSub i 1) i) ((↑(CochainComplex.mappingCone.fst φ)).v i j hij)) (Neg.neg (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v (HSub.hSub i 1) i ⋯) (F.d i j)))","decl":"@[reassoc (attr := simp)]\nlemma d_fst_v' (i j : ℤ) (hij : i + 1 = j) :\n    (mappingCone φ).d (i - 1) i ≫ (fst φ).1.v i j hij =\n      -(fst φ).1.v (i - 1) i (by omega) ≫ F.d i j :=\n  d_fst_v φ (i - 1) i j (by omega) hij\n\n"}
{"name":"CochainComplex.mappingCone.d_fst_v'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nZ : C\nh : Quiver.Hom (F.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d (HSub.hSub i 1) i) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v i j hij) h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v (HSub.hSub i 1) i ⋯) (F.d i j))) h)","decl":"@[reassoc (attr := simp)]\nlemma d_fst_v' (i j : ℤ) (hij : i + 1 = j) :\n    (mappingCone φ).d (i - 1) i ≫ (fst φ).1.v i j hij =\n      -(fst φ).1.v (i - 1) i (by omega) ≫ F.d i j :=\n  d_fst_v φ (i - 1) i j (by omega) hij\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\nZ : C\nh : Quiver.Hom (G.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d i j) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v j j ⋯) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v i j hij) (φ.f j)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v i i ⋯) (G.d i j))) h)","decl":"@[reassoc]\nlemma d_snd_v (i j : ℤ) (hij : i + 1 = j) :\n    (mappingCone φ).d i j ≫ (snd φ).v j j (add_zero _) =\n      (fst φ).1.v i j hij ≫ φ.f j + (snd φ).v i i (add_zero i) ≫ G.d i j := by\n  dsimp [mappingCone, snd, fst]\n  simp only [Cochain.ofHoms_v]\n  apply homotopyCofiber.d_sndX\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\ni j : Int\nhij : Eq (HAdd.hAdd i 1) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d i j) ((CochainComplex.mappingCone.snd φ).v j j ⋯)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v i j hij) (φ.f j)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v i i ⋯) (G.d i j)))","decl":"@[reassoc]\nlemma d_snd_v (i j : ℤ) (hij : i + 1 = j) :\n    (mappingCone φ).d i j ≫ (snd φ).v j j (add_zero _) =\n      (fst φ).1.v i j hij ≫ φ.f j + (snd φ).v i i (add_zero i) ≫ G.d i j := by\n  dsimp [mappingCone, snd, fst]\n  simp only [Cochain.ofHoms_v]\n  apply homotopyCofiber.d_sndX\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v'","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nn : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d (HSub.hSub n 1) n) ((CochainComplex.mappingCone.snd φ).v n n ⋯)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v (HSub.hSub n 1) n ⋯) (φ.f n)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v (HSub.hSub n 1) (HSub.hSub n 1) ⋯) (G.d (HSub.hSub n 1) n)))","decl":"@[reassoc (attr := simp)]\nlemma d_snd_v' (n : ℤ) :\n    (mappingCone φ).d (n - 1) n ≫ (snd φ).v n n (add_zero n) =\n    (fst φ : Cochain (mappingCone φ) F 1).v (n - 1) n (by omega) ≫ φ.f n +\n      (snd φ).v (n - 1) (n - 1) (add_zero _) ≫ G.d (n - 1) n := by\n  apply d_snd_v\n\n"}
{"name":"CochainComplex.mappingCone.d_snd_v'_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nn : Int\nZ : C\nh : Quiver.Hom (G.X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone φ).d (HSub.hSub n 1) n) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v n n ⋯) h)) (CategoryTheory.CategoryStruct.comp (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v (HSub.hSub n 1) n ⋯) (φ.f n)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v (HSub.hSub n 1) (HSub.hSub n 1) ⋯) (G.d (HSub.hSub n 1) n))) h)","decl":"@[reassoc (attr := simp)]\nlemma d_snd_v' (n : ℤ) :\n    (mappingCone φ).d (n - 1) n ≫ (snd φ).v n n (add_zero n) =\n    (fst φ : Cochain (mappingCone φ) F 1).v (n - 1) n (by omega) ≫ φ.f n +\n      (snd φ).v (n - 1) (n - 1) (add_zero _) ≫ G.d (n - 1) n := by\n  apply d_snd_v\n\n"}
{"name":"CochainComplex.mappingCone.δ_inl","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq (CochainComplex.HomComplex.δ (-1) 0 (CochainComplex.mappingCone.inl φ)) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ (CochainComplex.mappingCone.inr φ)))","decl":"@[simp]\nlemma δ_inl :\n    δ (-1) 0 (inl φ) = Cochain.ofHom (φ ≫ inr φ) := by\n  ext p\n  simp [δ_v (-1) 0 (neg_add_cancel 1) (inl φ) p p (add_zero p) _ _ rfl rfl,\n    inl_v_d φ p (p - 1) (p + 1) (by omega) (by omega)]\n\n"}
{"name":"CochainComplex.mappingCone.δ_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\n⊢ Eq (CochainComplex.HomComplex.δ 0 1 (CochainComplex.mappingCone.snd φ)) (Neg.neg ((↑(CochainComplex.mappingCone.fst φ)).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯))","decl":"@[simp]\nlemma δ_snd :\n    δ 0 1 (snd φ) = -(fst φ).1.comp (Cochain.ofHom φ) (add_zero 1) := by\n  ext p q hpq\n  simp [d_snd_v φ p q hpq]\n\n"}
{"name":"CochainComplex.mappingCone.inl_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp (CochainComplex.mappingCone.descCochain φ α β h) ⋯) α","decl":"@[simp]\nlemma inl_descCochain :\n    (inl φ).comp (descCochain φ α β h) (by omega) = α := by\n  simp [descCochain]\n\n"}
{"name":"CochainComplex.mappingCone.inr_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)).comp (CochainComplex.mappingCone.descCochain φ α β h) ⋯) β","decl":"@[simp]\nlemma inr_descCochain :\n    (Cochain.ofHom (inr φ)).comp (descCochain φ α β h) (zero_add n) = β := by\n  simp [descCochain]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\np₁ p₂ p₃ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ (-1)) p₂\nh₂₃ : Eq (HAdd.hAdd p₂ n) p₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p₁ p₂ h₁₂) ((CochainComplex.mappingCone.descCochain φ α β h).v p₂ p₃ h₂₃)) (α.v p₁ p₃ ⋯)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descCochain_v (p₁ p₂ p₃ : ℤ) (h₁₂ : p₁ + (-1) = p₂) (h₂₃ : p₂ + n = p₃) :\n    (inl φ).v p₁ p₂ h₁₂ ≫ (descCochain φ α β h).v p₂ p₃ h₂₃ =\n        α.v p₁ p₃ (by rw [← h₂₃, ← h₁₂, ← h, add_comm m, add_assoc, neg_add_cancel_left]) := by\n  simpa only [Cochain.comp_v _ _ (show -1 + n = m by omega) p₁ p₂ p₃\n    (by omega) (by omega)] using\n      Cochain.congr_v (inl_descCochain φ α β h) p₁ p₃ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_descCochain_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh✝ : Eq (HAdd.hAdd m 1) n\np₁ p₂ p₃ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ (-1)) p₂\nh₂₃ : Eq (HAdd.hAdd p₂ n) p₃\nZ : C\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p₁ p₂ h₁₂) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descCochain φ α β h✝).v p₂ p₃ h₂₃) h)) (CategoryTheory.CategoryStruct.comp (α.v p₁ p₃ ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_descCochain_v (p₁ p₂ p₃ : ℤ) (h₁₂ : p₁ + (-1) = p₂) (h₂₃ : p₂ + n = p₃) :\n    (inl φ).v p₁ p₂ h₁₂ ≫ (descCochain φ α β h).v p₂ p₃ h₂₃ =\n        α.v p₁ p₃ (by rw [← h₂₃, ← h₁₂, ← h, add_comm m, add_assoc, neg_add_cancel_left]) := by\n  simpa only [Cochain.comp_v _ _ (show -1 + n = m by omega) p₁ p₂ p₃\n    (by omega) (by omega)] using\n      Cochain.congr_v (inl_descCochain φ α β h) p₁ p₃ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\np₁ p₂ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p₁) ((CochainComplex.mappingCone.descCochain φ α β h).v p₁ p₂ h₁₂)) (β.v p₁ p₂ h₁₂)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descCochain_v (p₁ p₂ : ℤ) (h₁₂ : p₁ + n = p₂) :\n    (inr φ).f p₁ ≫ (descCochain φ α β h).v p₁ p₂ h₁₂ = β.v p₁ p₂ h₁₂ := by\n  simpa only [Cochain.comp_v _ _ (zero_add n) p₁ p₁ p₂ (add_zero p₁) h₁₂, Cochain.ofHom_v]\n    using Cochain.congr_v (inr_descCochain φ α β h) p₁ p₂ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_descCochain_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh✝ : Eq (HAdd.hAdd m 1) n\np₁ p₂ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\nZ : C\nh : Quiver.Hom (K.X p₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p₁) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.descCochain φ α β h✝).v p₁ p₂ h₁₂) h)) (CategoryTheory.CategoryStruct.comp (β.v p₁ p₂ h₁₂) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_descCochain_v (p₁ p₂ : ℤ) (h₁₂ : p₁ + n = p₂) :\n    (inr φ).f p₁ ≫ (descCochain φ α β h).v p₁ p₂ h₁₂ = β.v p₁ p₂ h₁₂ := by\n  simpa only [Cochain.comp_v _ _ (zero_add n) p₁ p₁ p₂ (add_zero p₁) h₁₂, Cochain.ofHom_v]\n    using Cochain.congr_v (inr_descCochain φ α β h) p₁ p₂ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.δ_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cochain G K n\nh : Eq (HAdd.hAdd m 1) n\nn' : Int\nhn' : Eq (HAdd.hAdd n 1) n'\n⊢ Eq (CochainComplex.HomComplex.δ n n' (CochainComplex.mappingCone.descCochain φ α β h)) (HAdd.hAdd ((↑(CochainComplex.mappingCone.fst φ)).comp (HAdd.hAdd (CochainComplex.HomComplex.δ m n α) (HSMul.hSMul n'.negOnePow ((CochainComplex.HomComplex.Cochain.ofHom φ).comp β ⋯))) ⋯) ((CochainComplex.mappingCone.snd φ).comp (CochainComplex.HomComplex.δ n n' β) ⋯))","decl":"lemma δ_descCochain (n' : ℤ) (hn' : n + 1 = n') :\n    δ n n' (descCochain φ α β h) =\n      (fst φ).1.comp (δ m n α +\n          n'.negOnePow • (Cochain.ofHom φ).comp β (zero_add n)) (by omega) +\n      (snd φ).comp (δ n n' β) (zero_add n') := by\n  dsimp only [descCochain]\n  simp only [δ_add, Cochain.comp_add, δ_comp (fst φ).1 α _ 2 n n' hn' (by omega) (by omega),\n    Cocycle.δ_eq_zero, Cochain.zero_comp, smul_zero, add_zero,\n    δ_comp (snd φ) β (zero_add n) 1 n' n' hn' (zero_add 1) hn', δ_snd, Cochain.neg_comp,\n    smul_neg, Cochain.comp_assoc_of_second_is_zero_cochain, Cochain.comp_units_smul, ← hn',\n    Int.negOnePow_succ, Units.neg_smul, Cochain.comp_neg]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.descCocycle_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain F K m\nβ : CochainComplex.HomComplex.Cocycle G K n\nh : Eq (HAdd.hAdd m 1) n\neq : Eq (CochainComplex.HomComplex.δ m n α) (HSMul.hSMul n.negOnePow ((CochainComplex.HomComplex.Cochain.ofHom φ).comp ↑β ⋯))\n⊢ Eq (↑(CochainComplex.mappingCone.descCocycle φ α β h eq)) (CochainComplex.mappingCone.descCochain φ α (↑β) h)","decl":"/-- Given `φ : F ⟶ G`, this is the cocycle in `Cocycle (mappingCone φ) K n` that is\nconstructed from `α : Cochain F K m` (with `m + 1 = n`) and `β : Cocycle F K n`,\nwhen a suitable cocycle relation is satisfied. -/\n@[simps!]\nnoncomputable def descCocycle {K : CochainComplex C ℤ} {n m : ℤ}\n    (α : Cochain F K m) (β : Cocycle G K n)\n    (h : m + 1 = n) (eq : δ m n α = n.negOnePow • (Cochain.ofHom φ).comp β.1 (zero_add n)) :\n    Cocycle (mappingCone φ) K n :=\n  Cocycle.mk (descCochain φ α β.1 h) (n + 1) rfl\n    (by simp [δ_descCochain _ _ _ _ _ rfl, eq, Int.negOnePow_succ])\n\n"}
{"name":"CochainComplex.mappingCone.ofHom_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.desc φ α β eq)) (CochainComplex.mappingCone.descCochain φ α (CochainComplex.HomComplex.Cochain.ofHom β) ⋯)","decl":"@[simp]\nlemma ofHom_desc :\n    Cochain.ofHom (desc φ α β eq) = descCochain φ α (Cochain.ofHom β) (neg_add_cancel 1) := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\np q : Int\nh : Eq (HAdd.hAdd p (-1)) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q h) ((CochainComplex.mappingCone.desc φ α β eq).f q)) (α.v p q h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_desc_f (p q : ℤ) (h : p + (-1) = q) :\n    (inl φ).v p q h ≫ (desc φ α β eq).f q = α.v p q h := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_v_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\np q : Int\nh✝ : Eq (HAdd.hAdd p (-1)) q\nZ : C\nh : Quiver.Hom (K.X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inl φ).v p q h✝) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.desc φ α β eq).f q) h)) (CategoryTheory.CategoryStruct.comp (α.v p q h✝) h)","decl":"@[reassoc (attr := simp)]\nlemma inl_v_desc_f (p q : ℤ) (h : p + (-1) = q) :\n    (inl φ).v p q h ≫ (desc φ α β eq).f q = α.v p q h := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inl_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\n⊢ Eq ((CochainComplex.mappingCone.inl φ).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.desc φ α β eq)) ⋯) α","decl":"lemma inl_desc :\n    (inl φ).comp (Cochain.ofHom (desc φ α β eq)) (add_zero _) = α := by\n  simp\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\np : Int\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) ((CochainComplex.mappingCone.desc φ α β eq).f p)) (β.f p)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_desc_f (p : ℤ) :\n    (inr φ).f p ≫ (desc φ α β eq).f p = β.f p := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_f_desc_f_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\np : Int\nZ : C\nh : Quiver.Hom (K.X p) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.inr φ).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.desc φ α β eq).f p) h)) (CategoryTheory.CategoryStruct.comp (β.f p) h)","decl":"@[reassoc (attr := simp)]\nlemma inr_f_desc_f (p : ℤ) :\n    (inr φ).f p ≫ (desc φ α β eq).f p = β.f p := by\n  simp [desc]\n\n"}
{"name":"CochainComplex.mappingCone.inr_desc_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\nZ : CochainComplex C Int\nh : Quiver.Hom K Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ) (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.desc φ α β eq) h)) (CategoryTheory.CategoryStruct.comp β h)","decl":"@[reassoc (attr := simp)]\nlemma inr_desc : inr φ ≫ desc φ α β eq = β := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.inr_desc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CochainComplex.mappingCone.inr φ) (CochainComplex.mappingCone.desc φ α β eq)) β","decl":"@[reassoc (attr := simp)]\nlemma inr_desc : inr φ ≫ desc φ α β eq = β := by aesop_cat\n\n"}
{"name":"CochainComplex.mappingCone.desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cochain F K (-1)\nβ : Quiver.Hom G K\neq : Eq (CochainComplex.HomComplex.δ (-1) 0 α) (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β))\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq ((CochainComplex.mappingCone.desc φ α β eq).f p) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq) (α.v q p ⋯)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v p p ⋯) (β.f p)))","decl":"lemma desc_f (p q : ℤ) (hpq : p + 1 = q) :\n    (desc φ α β eq).f p = (fst φ).1.v p q hpq ≫ α.v q p (by omega) +\n      (snd φ).v p p (add_zero p) ≫ β.f p := by\n  simp [ext_from_iff _ _ _ hpq]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\n⊢ Eq ((CochainComplex.mappingCone.liftCochain φ α β h).comp (↑(CochainComplex.mappingCone.fst φ)) h) α","decl":"@[simp]\nlemma liftCochain_fst :\n    (liftCochain φ α β h).comp (fst φ).1 h = α := by\n  simp [liftCochain]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\n⊢ Eq ((CochainComplex.mappingCone.liftCochain φ α β h).comp (CochainComplex.mappingCone.snd φ) ⋯) β","decl":"@[simp]\nlemma liftCochain_snd :\n    (liftCochain φ α β h).comp (snd φ) (add_zero n) = β := by\n  simp [liftCochain]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\np₁ p₂ p₃ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\nh₂₃ : Eq (HAdd.hAdd p₂ 1) p₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain φ α β h).v p₁ p₂ h₁₂) ((↑(CochainComplex.mappingCone.fst φ)).v p₂ p₃ h₂₃)) (α.v p₁ p₃ ⋯)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_fst_v (p₁ p₂ p₃ : ℤ) (h₁₂ : p₁ + n = p₂) (h₂₃ : p₂ + 1 = p₃) :\n    (liftCochain φ α β h).v p₁ p₂ h₁₂ ≫ (fst φ).1.v p₂ p₃ h₂₃ = α.v p₁ p₃ (by omega) := by\n  simpa only [Cochain.comp_v _ _ h p₁ p₂ p₃ h₁₂ h₂₃]\n    using Cochain.congr_v (liftCochain_fst φ α β h) p₁ p₃ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh✝ : Eq (HAdd.hAdd n 1) m\np₁ p₂ p₃ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\nh₂₃ : Eq (HAdd.hAdd p₂ 1) p₃\nZ : C\nh : Quiver.Hom (F.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain φ α β h✝).v p₁ p₂ h₁₂) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v p₂ p₃ h₂₃) h)) (CategoryTheory.CategoryStruct.comp (α.v p₁ p₃ ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_fst_v (p₁ p₂ p₃ : ℤ) (h₁₂ : p₁ + n = p₂) (h₂₃ : p₂ + 1 = p₃) :\n    (liftCochain φ α β h).v p₁ p₂ h₁₂ ≫ (fst φ).1.v p₂ p₃ h₂₃ = α.v p₁ p₃ (by omega) := by\n  simpa only [Cochain.comp_v _ _ h p₁ p₂ p₃ h₁₂ h₂₃]\n    using Cochain.congr_v (liftCochain_fst φ α β h) p₁ p₃ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\np₁ p₂ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain φ α β h).v p₁ p₂ h₁₂) ((CochainComplex.mappingCone.snd φ).v p₂ p₂ ⋯)) (β.v p₁ p₂ h₁₂)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_snd_v (p₁ p₂ : ℤ) (h₁₂ : p₁ + n = p₂) :\n    (liftCochain φ α β h).v p₁ p₂ h₁₂ ≫ (snd φ).v p₂ p₂ (add_zero p₂) = β.v p₁ p₂ h₁₂ := by\n  simpa only [Cochain.comp_v _ _ (add_zero n) p₁ p₂ p₂ h₁₂ (add_zero p₂)]\n    using Cochain.congr_v (liftCochain_snd φ α β h) p₁ p₂ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh✝ : Eq (HAdd.hAdd n 1) m\np₁ p₂ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\nZ : C\nh : Quiver.Hom (G.X p₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain φ α β h✝).v p₁ p₂ h₁₂) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v p₂ p₂ ⋯) h)) (CategoryTheory.CategoryStruct.comp (β.v p₁ p₂ h₁₂) h)","decl":"@[reassoc (attr := simp)]\nlemma liftCochain_v_snd_v (p₁ p₂ : ℤ) (h₁₂ : p₁ + n = p₂) :\n    (liftCochain φ α β h).v p₁ p₂ h₁₂ ≫ (snd φ).v p₂ p₂ (add_zero p₂) = β.v p₁ p₂ h₁₂ := by\n  simpa only [Cochain.comp_v _ _ (add_zero n) p₁ p₂ p₂ h₁₂ (add_zero p₂)]\n    using Cochain.congr_v (liftCochain_snd φ α β h) p₁ p₂ (by omega)\n\n"}
{"name":"CochainComplex.mappingCone.δ_liftCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\nm' : Int\nhm' : Eq (HAdd.hAdd m 1) m'\n⊢ Eq (CochainComplex.HomComplex.δ n m (CochainComplex.mappingCone.liftCochain φ α β h)) (HAdd.hAdd (Neg.neg ((CochainComplex.HomComplex.δ m m' α).comp (CochainComplex.mappingCone.inl φ) ⋯)) ((HAdd.hAdd (CochainComplex.HomComplex.δ n m β) (α.comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)).comp (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.inr φ)) ⋯))","decl":"lemma δ_liftCochain (m' : ℤ) (hm' : m + 1 = m') :\n    δ n m (liftCochain φ α β h) = -(δ m m' α).comp (inl φ) (by omega) +\n      (δ n m β + α.comp (Cochain.ofHom φ) (add_zero m)).comp\n        (Cochain.ofHom (inr φ)) (add_zero m) := by\n  dsimp only [liftCochain]\n  simp only [δ_add, δ_comp α (inl φ) _ m' _ _ h hm' (neg_add_cancel 1),\n    δ_comp_zero_cochain _ _ _ h, δ_inl, Cochain.ofHom_comp,\n    Int.negOnePow_neg, Int.negOnePow_one, Units.neg_smul, one_smul,\n    δ_ofHom, Cochain.comp_zero, zero_add, Cochain.add_comp,\n    Cochain.comp_assoc_of_second_is_zero_cochain]\n  abel\n\n"}
{"name":"CochainComplex.mappingCone.liftCocycle_coe","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cocycle K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nh : Eq (HAdd.hAdd n 1) m\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ n m β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\n⊢ Eq (↑(CochainComplex.mappingCone.liftCocycle φ α β h eq)) (CochainComplex.mappingCone.liftCochain φ (↑α) β h)","decl":"/-- Given `φ : F ⟶ G`, this is the cocycle in `Cocycle K (mappingCone φ) n` that is\nconstructed from `α : Cochain K F m` (with `n + 1 = m`) and `β : Cocycle K G n`,\nwhen a suitable cocycle relation is satisfied. -/\n@[simps!]\nnoncomputable def liftCocycle {K : CochainComplex C ℤ} {n m : ℤ}\n    (α : Cocycle K F m) (β : Cochain K G n) (h : n + 1 = m)\n    (eq : δ n m β + α.1.comp (Cochain.ofHom φ) (add_zero m) = 0) :\n    Cocycle K (mappingCone φ) n :=\n  Cocycle.mk (liftCochain φ α β h) m h (by\n    simp only [δ_liftCochain φ α β h (m+1) rfl, eq,\n      Cocycle.δ_eq_zero, Cochain.zero_comp, neg_zero, add_zero])\n\n"}
{"name":"CochainComplex.mappingCone.ofHom_lift","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\n⊢ Eq (CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift φ α β eq)) (CochainComplex.mappingCone.liftCochain φ (↑α) β ⋯)","decl":"@[simp]\nlemma ofHom_lift :\n    Cochain.ofHom (lift φ α β eq) = liftCochain φ α β (zero_add 1) := by\n  simp only [lift, Cocycle.cochain_ofHom_homOf_eq_coe, liftCocycle_coe]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_fst_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\nZ : C\nh : Quiver.Hom (F.X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift φ α β eq).f p) (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp ((↑α).v p q hpq) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_fst_v (p q : ℤ) (hpq : p + 1 = q) :\n    (lift φ α β eq).f p ≫ (fst φ).1.v p q hpq = α.1.v p q hpq := by\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_fst_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift φ α β eq).f p) ((↑(CochainComplex.mappingCone.fst φ)).v p q hpq)) ((↑α).v p q hpq)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_fst_v (p q : ℤ) (hpq : p + 1 = q) :\n    (lift φ α β eq).f p ≫ (fst φ).1.v p q hpq = α.1.v p q hpq := by\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_fst","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift φ α β eq)).comp ↑(CochainComplex.mappingCone.fst φ) ⋯) ↑α","decl":"lemma lift_fst :\n    (Cochain.ofHom (lift φ α β eq)).comp (fst φ).1 (zero_add 1) = α.1 := by simp\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_snd_v_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 0) q\nZ : C\nh : Quiver.Hom (G.X q) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift φ α β eq).f p) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd φ).v p q hpq) h)) (CategoryTheory.CategoryStruct.comp (β.v p q hpq) h)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_snd_v (p q : ℤ) (hpq : p + 0 = q) :\n    (lift φ α β eq).f p ≫ (snd φ).v p q hpq = β.v p q hpq := by\n  obtain rfl : q = p := by omega\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_f_snd_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 0) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift φ α β eq).f p) ((CochainComplex.mappingCone.snd φ).v p q hpq)) (β.v p q hpq)","decl":"@[reassoc (attr := simp)]\nlemma lift_f_snd_v (p q : ℤ) (hpq : p + 0 = q) :\n    (lift φ α β eq).f p ≫ (snd φ).v p q hpq = β.v p q hpq := by\n  obtain rfl : q = p := by omega\n  simp [lift]\n\n"}
{"name":"CochainComplex.mappingCone.lift_snd","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\n⊢ Eq ((CochainComplex.HomComplex.Cochain.ofHom (CochainComplex.mappingCone.lift φ α β eq)).comp (CochainComplex.mappingCone.snd φ) ⋯) β","decl":"lemma lift_snd :\n    (Cochain.ofHom (lift φ α β eq)).comp (snd φ) (zero_add 0) = β := by simp\n\n"}
{"name":"CochainComplex.mappingCone.lift_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\np q : Int\nhpq : Eq (HAdd.hAdd p 1) q\n⊢ Eq ((CochainComplex.mappingCone.lift φ α β eq).f p) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑α).v p q hpq) ((CochainComplex.mappingCone.inl φ).v q p ⋯)) (CategoryTheory.CategoryStruct.comp (β.v p p ⋯) ((CochainComplex.mappingCone.inr φ).f p)))","decl":"lemma lift_f (p q : ℤ) (hpq : p + 1 = q) :\n    (lift φ α β eq).f p = α.1.v p q hpq ≫\n      (inl φ).v q p (by omega) + β.v p p (add_zero p) ≫ (inr φ).f p := by\n  simp [ext_to_iff _ _ _ hpq]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_descCochain","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK L : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nn' m' : Int\nα' : CochainComplex.HomComplex.Cochain F L m'\nβ' : CochainComplex.HomComplex.Cochain G L n'\nh : Eq (HAdd.hAdd n 1) m\nh' : Eq (HAdd.hAdd m' 1) n'\np : Int\nhp : Eq (HAdd.hAdd n n') p\n⊢ Eq ((CochainComplex.mappingCone.liftCochain φ α β h).comp (CochainComplex.mappingCone.descCochain φ α' β' h') hp) (HAdd.hAdd (α.comp α' ⋯) (β.comp β' ⋯))","decl":"@[simp]\nlemma liftCochain_descCochain :\n    (liftCochain φ α β h).comp (descCochain φ α' β' h') hp =\n      α.comp α' (by omega) + β.comp β' (by omega) := by\n  simp [liftCochain, descCochain,\n    Cochain.comp_assoc α (inl φ) _ _ (show -1 + n' = m' by omega) (by linarith)]\n\n"}
{"name":"CochainComplex.mappingCone.liftCochain_v_descCochain_v","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK L : CochainComplex C Int\nn m : Int\nα : CochainComplex.HomComplex.Cochain K F m\nβ : CochainComplex.HomComplex.Cochain K G n\nn' m' : Int\nα' : CochainComplex.HomComplex.Cochain F L m'\nβ' : CochainComplex.HomComplex.Cochain G L n'\nh : Eq (HAdd.hAdd n 1) m\nh' : Eq (HAdd.hAdd m' 1) n'\np₁ p₂ p₃ : Int\nh₁₂ : Eq (HAdd.hAdd p₁ n) p₂\nh₂₃ : Eq (HAdd.hAdd p₂ n') p₃\nq : Int\nhq : Eq (HAdd.hAdd p₁ m) q\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.liftCochain φ α β h).v p₁ p₂ h₁₂) ((CochainComplex.mappingCone.descCochain φ α' β' h').v p₂ p₃ h₂₃)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (α.v p₁ q hq) (α'.v q p₃ ⋯)) (CategoryTheory.CategoryStruct.comp (β.v p₁ p₂ h₁₂) (β'.v p₂ p₃ h₂₃)))","decl":"lemma liftCochain_v_descCochain_v (p₁ p₂ p₃ : ℤ) (h₁₂ : p₁ + n = p₂) (h₂₃ : p₂ + n' = p₃)\n    (q : ℤ) (hq : p₁ + m = q) :\n    (liftCochain φ α β h).v p₁ p₂ h₁₂ ≫ (descCochain φ α' β' h').v p₂ p₃ h₂₃ =\n      α.v p₁ q hq ≫ α'.v q p₃ (by omega) + β.v p₁ p₂ h₁₂ ≫ β'.v p₂ p₃ h₂₃ := by\n  have eq := Cochain.congr_v (liftCochain_descCochain φ α β α' β' h h' p hp) p₁ p₃ (by omega)\n  simpa only [Cochain.comp_v _ _ hp p₁ p₂ p₃ h₁₂ h₂₃, Cochain.add_v,\n    Cochain.comp_v _ _ _ _ _ _ hq (show q + m' = p₃ by omega)] using eq\n\n"}
{"name":"CochainComplex.mappingCone.lift_desc_f","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝ : HomologicalComplex.HasHomotopyCofiber φ\nK L : CochainComplex C Int\nα : CochainComplex.HomComplex.Cocycle K F 1\nβ : CochainComplex.HomComplex.Cochain K G 0\neq : Eq (HAdd.hAdd (CochainComplex.HomComplex.δ 0 1 β) ((↑α).comp (CochainComplex.HomComplex.Cochain.ofHom φ) ⋯)) 0\nα' : CochainComplex.HomComplex.Cochain F L (-1)\nβ' : Quiver.Hom G L\neq' : Eq (CochainComplex.HomComplex.δ (-1) 0 α') (CochainComplex.HomComplex.Cochain.ofHom (CategoryTheory.CategoryStruct.comp φ β'))\nn n' : Int\nhnn' : Eq (HAdd.hAdd n 1) n'\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.lift φ α β eq).f n) ((CochainComplex.mappingCone.desc φ α' β' eq').f n)) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑α).v n n' hnn') (α'.v n' n ⋯)) (CategoryTheory.CategoryStruct.comp (β.v n n ⋯) (β'.f n)))","decl":"lemma lift_desc_f {K L : CochainComplex C ℤ} (α : Cocycle K F 1) (β : Cochain K G 0)\n    (eq : δ 0 1 β + α.1.comp (Cochain.ofHom φ) (add_zero 1) = 0)\n    (α' : Cochain F L (-1)) (β' : G ⟶ L)\n    (eq' : δ (-1) 0 α' = Cochain.ofHom (φ ≫ β')) (n n' : ℤ) (hnn' : n + 1 = n') :\n    (lift φ α β eq).f n ≫ (desc φ α' β' eq').f n =\n    α.1.v n n' hnn' ≫ α'.v n' n (by omega) + β.v n n (add_zero n) ≫ β'.f n := by\n  simp only [lift, desc, Cocycle.homOf_f, liftCocycle_coe, descCocycle_coe, Cocycle.ofHom_coe,\n    liftCochain_v_descCochain_v φ α.1 β α' (Cochain.ofHom β') (zero_add 1) (neg_add_cancel 1) 0\n    (add_zero 0) n n n (add_zero n) (add_zero n) n' hnn', Cochain.ofHom_v]\n\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso'_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝² : HomologicalComplex.HasHomotopyCofiber φ\nH : CategoryTheory.Functor C D\ninst✝¹ : H.Additive\ninst✝ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\n⊢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso' φ H n m hnm).hom (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (H.map ((↑(CochainComplex.mappingCone.fst φ)).v n m ⋯)) ((CochainComplex.mappingCone.inl ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)).v m n ⋯)) (CategoryTheory.CategoryStruct.comp (H.map ((CochainComplex.mappingCone.snd φ).v n n ⋯)) ((CochainComplex.mappingCone.inr ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)).f n)))","decl":"/-- If `H : C ⥤ D` is an additive functor and `φ` is a morphism of cochain complexes\nin `C`, this is the comparison isomorphism (in each degree `n`) between the image\nby `H` of `mappingCone φ` and the mapping cone of the image by `H` of `φ`.\nIt is an auxiliary definition for `mapHomologicalComplexXIso` and\n`mapHomologicalComplexIso`. This definition takes an extra\nparameter `m : ℤ` such that `n + 1 = m` which may help getting better\ndefinitional properties. See also the equational lemma `mapHomologicalComplexXIso_eq`. -/\n@[simps]\nnoncomputable def mapHomologicalComplexXIso' (n m : ℤ) (hnm : n + 1 = m) :\n    ((H.mapHomologicalComplex (ComplexShape.up ℤ)).obj (mappingCone φ)).X n ≅\n      (mappingCone ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).X n where\n  hom := H.map ((fst φ).1.v n m (by omega)) ≫\n      (inl ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).v m n (by omega) +\n      H.map ((snd φ).v n n (add_zero n)) ≫\n        (inr ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).f n\n  inv := (fst ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).1.v n m (by omega) ≫\n      H.map ((inl φ).v m n (by omega)) +\n      (snd ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).v n n (add_zero n) ≫\n        H.map ((inr φ).f n)\n  hom_inv_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      inl_v_fst_v_assoc, inr_f_fst_v_assoc, zero_comp, comp_zero, add_zero,\n      inl_v_snd_v_assoc, inr_f_snd_v_assoc, zero_add, ← Functor.map_comp, ← Functor.map_add]\n    rw [← H.map_id]\n    congr 1\n    simp [ext_from_iff  _ _ _ hnm]\n  inv_hom_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      ← H.map_comp_assoc, inl_v_fst_v, CategoryTheory.Functor.map_id, id_comp, inr_f_fst_v,\n      inl_v_snd_v, inr_f_snd_v]\n    simp [ext_from_iff _ _ _ hnm]\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso'_inv","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝² : HomologicalComplex.HasHomotopyCofiber φ\nH : CategoryTheory.Functor C D\ninst✝¹ : H.Additive\ninst✝ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\n⊢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso' φ H n m hnm).inv (HAdd.hAdd (CategoryTheory.CategoryStruct.comp ((↑(CochainComplex.mappingCone.fst ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ))).v n m ⋯) (H.map ((CochainComplex.mappingCone.inl φ).v m n ⋯))) (CategoryTheory.CategoryStruct.comp ((CochainComplex.mappingCone.snd ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)).v n n ⋯) (H.map ((CochainComplex.mappingCone.inr φ).f n))))","decl":"/-- If `H : C ⥤ D` is an additive functor and `φ` is a morphism of cochain complexes\nin `C`, this is the comparison isomorphism (in each degree `n`) between the image\nby `H` of `mappingCone φ` and the mapping cone of the image by `H` of `φ`.\nIt is an auxiliary definition for `mapHomologicalComplexXIso` and\n`mapHomologicalComplexIso`. This definition takes an extra\nparameter `m : ℤ` such that `n + 1 = m` which may help getting better\ndefinitional properties. See also the equational lemma `mapHomologicalComplexXIso_eq`. -/\n@[simps]\nnoncomputable def mapHomologicalComplexXIso' (n m : ℤ) (hnm : n + 1 = m) :\n    ((H.mapHomologicalComplex (ComplexShape.up ℤ)).obj (mappingCone φ)).X n ≅\n      (mappingCone ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).X n where\n  hom := H.map ((fst φ).1.v n m (by omega)) ≫\n      (inl ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).v m n (by omega) +\n      H.map ((snd φ).v n n (add_zero n)) ≫\n        (inr ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).f n\n  inv := (fst ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).1.v n m (by omega) ≫\n      H.map ((inl φ).v m n (by omega)) +\n      (snd ((H.mapHomologicalComplex (ComplexShape.up ℤ)).map φ)).v n n (add_zero n) ≫\n        H.map ((inr φ).f n)\n  hom_inv_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      inl_v_fst_v_assoc, inr_f_fst_v_assoc, zero_comp, comp_zero, add_zero,\n      inl_v_snd_v_assoc, inr_f_snd_v_assoc, zero_add, ← Functor.map_comp, ← Functor.map_add]\n    rw [← H.map_id]\n    congr 1\n    simp [ext_from_iff  _ _ _ hnm]\n  inv_hom_id := by\n    simp only [Functor.mapHomologicalComplex_obj_X, comp_add, add_comp, assoc,\n      ← H.map_comp_assoc, inl_v_fst_v, CategoryTheory.Functor.map_id, id_comp, inr_f_fst_v,\n      inl_v_snd_v, inr_f_snd_v]\n    simp [ext_from_iff _ _ _ hnm]\n\n"}
{"name":"CochainComplex.mappingCone.mapHomologicalComplexXIso_eq","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝² : HomologicalComplex.HasHomotopyCofiber φ\nH : CategoryTheory.Functor C D\ninst✝¹ : H.Additive\ninst✝ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)\nn m : Int\nhnm : Eq (HAdd.hAdd n 1) m\n⊢ Eq (CochainComplex.mappingCone.mapHomologicalComplexXIso φ H n) (CochainComplex.mappingCone.mapHomologicalComplexXIso' φ H n m hnm)","decl":"lemma mapHomologicalComplexXIso_eq (n m : ℤ) (hnm : n + 1 = m) :\n    mapHomologicalComplexXIso φ H n = mapHomologicalComplexXIso' φ H n m hnm := by\n  subst hnm\n  rfl\n\n"}
{"name":"CochainComplex.mappingCone.map_inr","module":"Mathlib.Algebra.Homology.HomotopyCategory.MappingCone","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF G : CochainComplex C Int\nφ : Quiver.Hom F G\ninst✝² : HomologicalComplex.HasHomotopyCofiber φ\nH : CategoryTheory.Functor C D\ninst✝¹ : H.Additive\ninst✝ : HomologicalComplex.HasHomotopyCofiber ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((H.mapHomologicalComplex (ComplexShape.up Int)).map (CochainComplex.mappingCone.inr φ)) (CochainComplex.mappingCone.mapHomologicalComplexIso φ H).hom) (CochainComplex.mappingCone.inr ((H.mapHomologicalComplex (ComplexShape.up Int)).map φ))","decl":"lemma map_inr :\n    (H.mapHomologicalComplex (ComplexShape.up ℤ)).map (inr φ) ≫\n      (mapHomologicalComplexIso φ H).hom =\n    inr ((Functor.mapHomologicalComplex H (ComplexShape.up ℤ)).map φ) := by\n  ext n\n  dsimp [mapHomologicalComplexIso]\n  simp only [mapHomologicalComplexXIso_eq φ H n (n + 1) rfl, mappingCone.ext_to_iff _ _ _ rfl,\n    Functor.mapHomologicalComplex_obj_X, mapHomologicalComplexXIso'_hom, comp_add,\n    add_comp, assoc, inl_v_fst_v, comp_id, inr_f_fst_v, comp_zero, add_zero, inl_v_snd_v,\n    inr_f_snd_v, zero_add, ← H.map_comp, H.map_zero, H.map_id, and_self]\n\n"}
