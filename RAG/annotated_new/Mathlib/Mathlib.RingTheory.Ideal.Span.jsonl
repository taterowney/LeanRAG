{"name":"isPrincipalIdealRing_iff","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u\ninst✝ : Semiring R\n⊢ Iff (IsPrincipalIdealRing R) (∀ (S : Ideal R), Submodule.IsPrincipal S)","decl":"/-- A ring is a principal ideal ring if all (left) ideals are principal. -/\n@[mk_iff]\nclass IsPrincipalIdealRing (R : Type u) [Semiring R] : Prop where\n  principal : ∀ S : Ideal R, S.IsPrincipal\n\n"}
{"name":"IsPrincipalIdealRing.principal","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u\ninst✝ : Semiring R\nself : IsPrincipalIdealRing R\nS : Ideal R\n⊢ Submodule.IsPrincipal S","decl":"/-- A ring is a principal ideal ring if all (left) ideals are principal. -/\n@[mk_iff]\nclass IsPrincipalIdealRing (R : Type u) [Semiring R] : Prop where\n  principal : ∀ S : Ideal R, S.IsPrincipal\n\n"}
{"name":"Ideal.submodule_span_eq","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\n⊢ Eq (Submodule.span α s) (Ideal.span s)","decl":"@[simp]\ntheorem submodule_span_eq {s : Set α} : Submodule.span α s = Ideal.span s :=\n  rfl\n\n"}
{"name":"Ideal.span_empty","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ Eq (Ideal.span EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem span_empty : span (∅ : Set α) = ⊥ :=\n  Submodule.span_empty\n\n"}
{"name":"Ideal.span_univ","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ Eq (Ideal.span Set.univ) Top.top","decl":"@[simp]\ntheorem span_univ : span (Set.univ : Set α) = ⊤ :=\n  Submodule.span_univ\n\n"}
{"name":"Ideal.span_union","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns t : Set α\n⊢ Eq (Ideal.span (Union.union s t)) (Max.max (Ideal.span s) (Ideal.span t))","decl":"theorem span_union (s t : Set α) : span (s ∪ t) = span s ⊔ span t :=\n  Submodule.span_union _ _\n\n"}
{"name":"Ideal.span_iUnion","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nι : Sort u_1\ns : ι → Set α\n⊢ Eq (Ideal.span (Set.iUnion fun i => s i)) (iSup fun i => Ideal.span (s i))","decl":"theorem span_iUnion {ι} (s : ι → Set α) : span (⋃ i, s i) = ⨆ i, span (s i) :=\n  Submodule.span_iUnion _\n\n"}
{"name":"Ideal.mem_span","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\nx : α\n⊢ Iff (Membership.mem (Ideal.span s) x) (∀ (p : Ideal α), HasSubset.Subset s ↑p → Membership.mem p x)","decl":"theorem mem_span {s : Set α} (x) : x ∈ span s ↔ ∀ p : Ideal α, s ⊆ p → x ∈ p :=\n  mem_iInter₂\n\n"}
{"name":"Ideal.subset_span","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\n⊢ HasSubset.Subset s ↑(Ideal.span s)","decl":"theorem subset_span {s : Set α} : s ⊆ span s :=\n  Submodule.subset_span\n\n"}
{"name":"Ideal.span_le","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\nI : Ideal α\n⊢ Iff (LE.le (Ideal.span s) I) (HasSubset.Subset s ↑I)","decl":"theorem span_le {s : Set α} {I} : span s ≤ I ↔ s ⊆ I :=\n  Submodule.span_le\n\n"}
{"name":"Ideal.span_mono","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns t : Set α\na✝ : HasSubset.Subset s t\n⊢ LE.le (Ideal.span s) (Ideal.span t)","decl":"theorem span_mono {s t : Set α} : s ⊆ t → span s ≤ span t :=\n  Submodule.span_mono\n\n"}
{"name":"Ideal.span_eq","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\n⊢ Eq (Ideal.span ↑I) I","decl":"@[simp]\ntheorem span_eq : span (I : Set α) = I :=\n  Submodule.span_eq _\n\n"}
{"name":"Ideal.span_singleton_one","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ Eq (Ideal.span (Singleton.singleton 1)) Top.top","decl":"@[simp]\ntheorem span_singleton_one : span ({1} : Set α) = ⊤ :=\n  (eq_top_iff_one _).2 <| subset_span <| mem_singleton _\n\n"}
{"name":"Ideal.isCompactElement_top","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ CompleteLattice.IsCompactElement Top.top","decl":"theorem isCompactElement_top : CompleteLattice.IsCompactElement (⊤ : Ideal α) := by\n  simpa only [← span_singleton_one] using Submodule.singleton_span_isCompactElement 1\n\n"}
{"name":"Ideal.mem_span_insert","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\nx y : α\n⊢ Iff (Membership.mem (Ideal.span (Insert.insert y s)) x) (Exists fun a => Exists fun z => And (Membership.mem (Ideal.span s) z) (Eq x (HAdd.hAdd (HMul.hMul a y) z)))","decl":"theorem mem_span_insert {s : Set α} {x y} :\n    x ∈ span (insert y s) ↔ ∃ a, ∃ z ∈ span s, x = a * y + z :=\n  Submodule.mem_span_insert\n\n"}
{"name":"Ideal.mem_span_singleton'","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx y : α\n⊢ Iff (Membership.mem (Ideal.span (Singleton.singleton y)) x) (Exists fun a => Eq (HMul.hMul a y) x)","decl":"theorem mem_span_singleton' {x y : α} : x ∈ span ({y} : Set α) ↔ ∃ a, a * y = x :=\n  Submodule.mem_span_singleton\n\n"}
{"name":"Ideal.mem_span_singleton_self","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx : α\n⊢ Membership.mem (Ideal.span (Singleton.singleton x)) x","decl":"theorem mem_span_singleton_self (x : α) : x ∈ span ({x} : Set α) :=\n  Submodule.mem_span_singleton_self x\n\n"}
{"name":"Ideal.span_singleton_le_iff_mem","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nx : α\n⊢ Iff (LE.le (Ideal.span (Singleton.singleton x)) I) (Membership.mem I x)","decl":"theorem span_singleton_le_iff_mem {x : α} : span {x} ≤ I ↔ x ∈ I :=\n  Submodule.span_singleton_le_iff_mem _ _\n\n"}
{"name":"Ideal.span_singleton_mul_left_unit","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\na : α\nh2 : IsUnit a\nx : α\n⊢ Eq (Ideal.span (Singleton.singleton (HMul.hMul a x))) (Ideal.span (Singleton.singleton x))","decl":"theorem span_singleton_mul_left_unit {a : α} (h2 : IsUnit a) (x : α) :\n    span ({a * x} : Set α) = span {x} := by\n  apply le_antisymm <;> rw [span_singleton_le_iff_mem, mem_span_singleton']\n  exacts [⟨a, rfl⟩, ⟨_, h2.unit.inv_mul_cancel_left x⟩]\n\n"}
{"name":"Ideal.span_insert","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx : α\ns : Set α\n⊢ Eq (Ideal.span (Insert.insert x s)) (Max.max (Ideal.span (Singleton.singleton x)) (Ideal.span s))","decl":"theorem span_insert (x) (s : Set α) : span (insert x s) = span ({x} : Set α) ⊔ span s :=\n  Submodule.span_insert x s\n\n"}
{"name":"Ideal.span_eq_bot","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\n⊢ Iff (Eq (Ideal.span s) Bot.bot) (∀ (x : α), Membership.mem s x → Eq x 0)","decl":"theorem span_eq_bot {s : Set α} : span s = ⊥ ↔ ∀ x ∈ s, (x : α) = 0 :=\n  Submodule.span_eq_bot\n\n"}
{"name":"Ideal.span_singleton_eq_bot","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx : α\n⊢ Iff (Eq (Ideal.span (Singleton.singleton x)) Bot.bot) (Eq x 0)","decl":"@[simp]\ntheorem span_singleton_eq_bot {x} : span ({x} : Set α) = ⊥ ↔ x = 0 :=\n  Submodule.span_singleton_eq_bot\n\n"}
{"name":"Ideal.span_singleton_ne_top","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u_1\ninst✝ : CommSemiring α\nx : α\nhx : Not (IsUnit x)\n⊢ Ne (Ideal.span (Singleton.singleton x)) Top.top","decl":"theorem span_singleton_ne_top {α : Type*} [CommSemiring α] {x : α} (hx : ¬IsUnit x) :\n    Ideal.span ({x} : Set α) ≠ ⊤ :=\n  (Ideal.ne_top_iff_one _).mpr fun h1 =>\n    let ⟨y, hy⟩ := Ideal.mem_span_singleton'.mp h1\n    hx ⟨⟨x, y, mul_comm y x ▸ hy, hy⟩, rfl⟩\n\n"}
{"name":"Ideal.span_zero","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ Eq (Ideal.span 0) Bot.bot","decl":"@[simp]\ntheorem span_zero : span (0 : Set α) = ⊥ := by rw [← Set.singleton_zero, span_singleton_eq_bot]\n\n"}
{"name":"Ideal.span_one","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\n⊢ Eq (Ideal.span 1) Top.top","decl":"@[simp]\ntheorem span_one : span (1 : Set α) = ⊤ := by rw [← Set.singleton_one, span_singleton_one]\n\n"}
{"name":"Ideal.span_eq_top_iff_finite","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\ns : Set α\n⊢ Iff (Eq (Ideal.span s) Top.top) (Exists fun s' => And (HasSubset.Subset (↑s') s) (Eq (Ideal.span ↑s') Top.top))","decl":"theorem span_eq_top_iff_finite (s : Set α) :\n    span s = ⊤ ↔ ∃ s' : Finset α, ↑s' ⊆ s ∧ span (s' : Set α) = ⊤ := by\n  simp_rw [eq_top_iff_one]\n  exact ⟨Submodule.mem_span_finite_of_mem_span, fun ⟨s', h₁, h₂⟩ => span_mono h₁ h₂⟩\n\n"}
{"name":"Ideal.mem_span_singleton_sup","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx y : α\nI : Ideal α\n⊢ Iff (Membership.mem (Max.max (Ideal.span (Singleton.singleton y)) I) x) (Exists fun a => Exists fun b => And (Membership.mem I b) (Eq (HAdd.hAdd (HMul.hMul a y) b) x))","decl":"theorem mem_span_singleton_sup {x y : α} {I : Ideal α} :\n    x ∈ Ideal.span {y} ⊔ I ↔ ∃ a : α, ∃ b ∈ I, a * y + b = x := by\n  rw [Submodule.mem_sup]\n  constructor\n  · rintro ⟨ya, hya, b, hb, rfl⟩\n    obtain ⟨a, rfl⟩ := mem_span_singleton'.mp hya\n    exact ⟨a, b, hb, rfl⟩\n  · rintro ⟨a, b, hb, rfl⟩\n    exact ⟨a * y, Ideal.mem_span_singleton'.mpr ⟨a, rfl⟩, b, hb, rfl⟩\n\n"}
{"name":"Ideal.zero_ne_one_of_proper","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nh : Ne I Top.top\n⊢ Ne 0 1","decl":"theorem zero_ne_one_of_proper {I : Ideal α} (h : I ≠ ⊤) : (0 : α) ≠ 1 := fun hz =>\n  I.ne_top_iff_one.1 h <| hz ▸ I.zero_mem\n\n"}
{"name":"Ideal.span_pair_comm","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx y : α\n⊢ Eq (Ideal.span (Insert.insert x (Singleton.singleton y))) (Ideal.span (Insert.insert y (Singleton.singleton x)))","decl":"theorem span_pair_comm {x y : α} : (span {x, y} : Ideal α) = span {y, x} := by\n  simp only [span_insert, sup_comm]\n\n"}
{"name":"Ideal.mem_span_pair","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Semiring α\nx y z : α\n⊢ Iff (Membership.mem (Ideal.span (Insert.insert x (Singleton.singleton y))) z) (Exists fun a => Exists fun b => Eq (HAdd.hAdd (HMul.hMul a x) (HMul.hMul b y)) z)","decl":"theorem mem_span_pair {x y z : α} : z ∈ span ({x, y} : Set α) ↔ ∃ a b, a * x + b * y = z :=\n  Submodule.mem_span_pair\n\n"}
{"name":"Ideal.span_pair_add_mul_left","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Eq (Ideal.span (Insert.insert (HAdd.hAdd x (HMul.hMul y z)) (Singleton.singleton y))) (Ideal.span (Insert.insert x (Singleton.singleton y)))","decl":"@[simp]\ntheorem span_pair_add_mul_left {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x + y * z, y} : Ideal R) = span {x, y} := by\n  ext\n  rw [mem_span_pair, mem_span_pair]\n  exact\n    ⟨fun ⟨a, b, h⟩ =>\n      ⟨a, b + a * z, by\n        rw [← h]\n        ring1⟩,\n      fun ⟨a, b, h⟩ =>\n      ⟨a, b - a * z, by\n        rw [← h]\n        ring1⟩⟩\n\n"}
{"name":"Ideal.span_pair_add_mul_right","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Eq (Ideal.span (Insert.insert x (Singleton.singleton (HAdd.hAdd y (HMul.hMul x z))))) (Ideal.span (Insert.insert x (Singleton.singleton y)))","decl":"@[simp]\ntheorem span_pair_add_mul_right {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x, y + x * z} : Ideal R) = span {x, y} := by\n  rw [span_pair_comm, span_pair_add_mul_left, span_pair_comm]\n\n"}
{"name":"Ideal.mem_span_singleton","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nx y : α\n⊢ Iff (Membership.mem (Ideal.span (Singleton.singleton y)) x) (Dvd.dvd y x)","decl":"theorem mem_span_singleton {x y : α} : x ∈ span ({y} : Set α) ↔ y ∣ x :=\n  mem_span_singleton'.trans <| exists_congr fun _ => by rw [eq_comm, mul_comm]\n\n"}
{"name":"Ideal.span_singleton_le_span_singleton","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nx y : α\n⊢ Iff (LE.le (Ideal.span (Singleton.singleton x)) (Ideal.span (Singleton.singleton y))) (Dvd.dvd y x)","decl":"theorem span_singleton_le_span_singleton {x y : α} :\n    span ({x} : Set α) ≤ span ({y} : Set α) ↔ y ∣ x :=\n  span_le.trans <| singleton_subset_iff.trans mem_span_singleton\n\n"}
{"name":"Ideal.span_singleton_eq_span_singleton","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝¹ : CommRing α\ninst✝ : IsDomain α\nx y : α\n⊢ Iff (Eq (Ideal.span (Singleton.singleton x)) (Ideal.span (Singleton.singleton y))) (Associated x y)","decl":"theorem span_singleton_eq_span_singleton {α : Type u} [CommRing α] [IsDomain α] {x y : α} :\n    span ({x} : Set α) = span ({y} : Set α) ↔ Associated x y := by\n  rw [← dvd_dvd_iff_associated, le_antisymm_iff, and_comm]\n  apply and_congr <;> rw [span_singleton_le_span_singleton]\n\n"}
{"name":"Ideal.span_singleton_mul_right_unit","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : CommSemiring α\na : α\nh2 : IsUnit a\nx : α\n⊢ Eq (Ideal.span (Singleton.singleton (HMul.hMul x a))) (Ideal.span (Singleton.singleton x))","decl":"theorem span_singleton_mul_right_unit {a : α} (h2 : IsUnit a) (x : α) :\n    span ({x * a} : Set α) = span {x} := by rw [mul_comm, span_singleton_mul_left_unit h2]\n\n"}
{"name":"Ideal.span_singleton_eq_top","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nx : α\n⊢ Iff (Eq (Ideal.span (Singleton.singleton x)) Top.top) (IsUnit x)","decl":"@[simp]\ntheorem span_singleton_eq_top {x} : span ({x} : Set α) = ⊤ ↔ IsUnit x := by\n  rw [isUnit_iff_dvd_one, ← span_singleton_le_span_singleton, span_singleton_one, eq_top_iff]\n\n"}
{"name":"Ideal.factors_decreasing","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝¹ : CommSemiring α\ninst✝ : IsDomain α\nb₁ b₂ : α\nh₁ : Ne b₁ 0\nh₂ : Not (IsUnit b₂)\n⊢ LT.lt (Ideal.span (Singleton.singleton (HMul.hMul b₁ b₂))) (Ideal.span (Singleton.singleton b₁))","decl":"theorem factors_decreasing [IsDomain α] (b₁ b₂ : α) (h₁ : b₁ ≠ 0) (h₂ : ¬IsUnit b₂) :\n    span ({b₁ * b₂} : Set α) < span {b₁} :=\n  lt_of_le_not_le\n    (Ideal.span_le.2 <| singleton_subset_iff.2 <| Ideal.mem_span_singleton.2 ⟨b₂, rfl⟩) fun h =>\n    h₂ <| isUnit_of_dvd_one <|\n        (mul_dvd_mul_iff_left h₁).1 <| by rwa [mul_one, ← Ideal.span_singleton_le_span_singleton]\n\n"}
{"name":"Ideal.mem_span_insert'","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Ring α\ns : Set α\nx y : α\n⊢ Iff (Membership.mem (Ideal.span (Insert.insert y s)) x) (Exists fun a => Membership.mem (Ideal.span s) (HAdd.hAdd x (HMul.hMul a y)))","decl":"theorem mem_span_insert' {s : Set α} {x y} : x ∈ span (insert y s) ↔ ∃ a, x + a * y ∈ span s :=\n  Submodule.mem_span_insert'\n\n"}
{"name":"Ideal.span_singleton_neg","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"α : Type u\ninst✝ : Ring α\nx : α\n⊢ Eq (Ideal.span (Singleton.singleton (Neg.neg x))) (Ideal.span (Singleton.singleton x))","decl":"@[simp]\ntheorem span_singleton_neg (x : α) : (span {-x} : Ideal α) = span {x} := by\n  ext\n  simp only [mem_span_singleton']\n  exact ⟨fun ⟨y, h⟩ => ⟨-y, h ▸ neg_mul_comm y x⟩, fun ⟨y, h⟩ => ⟨-y, h ▸ neg_mul_neg y x⟩⟩\n\n"}
{"name":"IsIdempotentElem.ker_toSpanSingleton_eq_span","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ne : R\nhe : IsIdempotentElem e\n⊢ Eq (LinearMap.ker (LinearMap.toSpanSingleton R R e)) (Ideal.span (Singleton.singleton (HSub.hSub 1 e)))","decl":"theorem ker_toSpanSingleton_eq_span :\n    LinearMap.ker (LinearMap.toSpanSingleton R R e) = Ideal.span {1 - e} := SetLike.ext fun x ↦ by\n  rw [Ideal.mem_span_singleton']\n  refine ⟨fun h ↦ ⟨x, by rw [mul_sub, show x * e = 0 from h, mul_one, sub_zero]⟩, fun h ↦ ?_⟩\n  obtain ⟨x, rfl⟩ := h\n  show x * (1 - e) * e = 0\n  rw [mul_assoc, sub_mul, one_mul, he, sub_self, mul_zero]\n\n"}
{"name":"IsIdempotentElem.ker_toSpanSingleton_one_sub_eq_span","module":"Mathlib.RingTheory.Ideal.Span","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ne : R\nhe : IsIdempotentElem e\n⊢ Eq (LinearMap.ker (LinearMap.toSpanSingleton R R (HSub.hSub 1 e))) (Ideal.span (Singleton.singleton e))","decl":"theorem ker_toSpanSingleton_one_sub_eq_span :\n    LinearMap.ker (LinearMap.toSpanSingleton R R (1 - e)) = Ideal.span {e} := by\n  rw [ker_toSpanSingleton_eq_span he.one_sub, sub_sub_cancel]\n\n"}
