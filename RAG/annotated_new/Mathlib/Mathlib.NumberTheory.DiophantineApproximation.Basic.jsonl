{"name":"Real.exists_int_int_abs_mul_sub_le","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nn : Nat\nn_pos : LT.lt 0 n\n⊢ Exists fun j => Exists fun k => And (LT.lt 0 k) (And (LE.le k ↑n) (LE.le (abs (HSub.hSub (HMul.hMul (↑k) ξ) ↑j)) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))))","decl":"/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there are integers `j` and `k`,\nwith `0 < k ≤ n` and `|k*ξ - j| ≤ 1/(n+1)`.\n\nSee also `Real.exists_nat_abs_mul_sub_round_le`. -/\ntheorem exists_int_int_abs_mul_sub_le (ξ : ℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ j k : ℤ, 0 < k ∧ k ≤ n ∧ |↑k * ξ - j| ≤ 1 / (n + 1) := by\n  let f : ℤ → ℤ := fun m => ⌊fract (ξ * m) * (n + 1)⌋\n  have hn : 0 < (n : ℝ) + 1 := mod_cast Nat.succ_pos _\n  have hfu := fun m : ℤ => mul_lt_of_lt_one_left hn <| fract_lt_one (ξ * ↑m)\n  conv in |_| ≤ _ => rw [mul_comm, le_div_iff₀ hn, ← abs_of_pos hn, ← abs_mul]\n  let D := Icc (0 : ℤ) n\n  by_cases H : ∃ m ∈ D, f m = n\n  · obtain ⟨m, hm, hf⟩ := H\n    have hf' : ((n : ℤ) : ℝ) ≤ fract (ξ * m) * (n + 1) := hf ▸ floor_le (fract (ξ * m) * (n + 1))\n    have hm₀ : 0 < m := by\n      have hf₀ : f 0 = 0 := by\n        -- Porting note: was\n        -- simp only [floor_eq_zero_iff, algebraMap.coe_zero, mul_zero, fract_zero,\n        --   zero_mul, Set.left_mem_Ico, zero_lt_one]\n        simp only [f, cast_zero, mul_zero, fract_zero, zero_mul, floor_zero]\n      refine Ne.lt_of_le (fun h => n_pos.ne ?_) (mem_Icc.mp hm).1\n      exact mod_cast hf₀.symm.trans (h.symm ▸ hf : f 0 = n)\n    refine ⟨⌊ξ * m⌋ + 1, m, hm₀, (mem_Icc.mp hm).2, ?_⟩\n    rw [cast_add, ← sub_sub, sub_mul, cast_one, one_mul, abs_le]\n    refine\n      ⟨le_sub_iff_add_le.mpr ?_, sub_le_iff_le_add.mpr <| le_of_lt <| (hfu m).trans <| lt_one_add _⟩\n    simpa only [neg_add_cancel_comm_assoc] using hf'\n  · -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5127): added `not_and`\n    simp_rw [not_exists, not_and] at H\n    have hD : #(Ico (0 : ℤ) n) < #D := by rw [card_Icc, card_Ico]; exact lt_add_one n\n    have hfu' : ∀ m, f m ≤ n := fun m => lt_add_one_iff.mp (floor_lt.mpr (mod_cast hfu m))\n    have hwd : ∀ m : ℤ, m ∈ D → f m ∈ Ico (0 : ℤ) n := fun x hx =>\n      mem_Ico.mpr\n        ⟨floor_nonneg.mpr (mul_nonneg (fract_nonneg (ξ * x)) hn.le), Ne.lt_of_le (H x hx) (hfu' x)⟩\n    obtain ⟨x, hx, y, hy, x_lt_y, hxy⟩ : ∃ x ∈ D, ∃ y ∈ D, x < y ∧ f x = f y := by\n      obtain ⟨x, hx, y, hy, x_ne_y, hxy⟩ := exists_ne_map_eq_of_card_lt_of_maps_to hD hwd\n      rcases lt_trichotomy x y with (h | h | h)\n      exacts [⟨x, hx, y, hy, h, hxy⟩, False.elim (x_ne_y h), ⟨y, hy, x, hx, h, hxy.symm⟩]\n    refine\n      ⟨⌊ξ * y⌋ - ⌊ξ * x⌋, y - x, sub_pos_of_lt x_lt_y,\n        sub_le_iff_le_add.mpr <| le_add_of_le_of_nonneg (mem_Icc.mp hy).2 (mem_Icc.mp hx).1, ?_⟩\n    convert_to |fract (ξ * y) * (n + 1) - fract (ξ * x) * (n + 1)| ≤ 1\n    · congr; push_cast; simp only [fract]; ring\n    exact (abs_sub_lt_one_of_floor_eq_floor hxy.symm).le\n\n"}
{"name":"Real.exists_nat_abs_mul_sub_round_le","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nn : Nat\nn_pos : LT.lt 0 n\n⊢ Exists fun k => And (LT.lt 0 k) (And (LE.le k n) (LE.le (abs (HSub.hSub (HMul.hMul (↑k) ξ) ↑(round (HMul.hMul (↑k) ξ)))) (HDiv.hDiv 1 (HAdd.hAdd (↑n) 1))))","decl":"/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there is a natural number `k`,\nwith `0 < k ≤ n` such that `|k*ξ - round(k*ξ)| ≤ 1/(n+1)`.\n-/\ntheorem exists_nat_abs_mul_sub_round_le (ξ : ℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ k : ℕ, 0 < k ∧ k ≤ n ∧ |↑k * ξ - round (↑k * ξ)| ≤ 1 / (n + 1) := by\n  obtain ⟨j, k, hk₀, hk₁, h⟩ := exists_int_int_abs_mul_sub_le ξ n_pos\n  have hk := toNat_of_nonneg hk₀.le\n  rw [← hk] at hk₀ hk₁ h\n  exact ⟨k.toNat, natCast_pos.mp hk₀, Nat.cast_le.mp hk₁, (round_le (↑k.toNat * ξ) j).trans h⟩\n\n"}
{"name":"Real.exists_rat_abs_sub_le_and_den_le","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nn : Nat\nn_pos : LT.lt 0 n\n⊢ Exists fun q => And (LE.le (abs (HSub.hSub ξ ↑q)) (HDiv.hDiv 1 (HMul.hMul (HAdd.hAdd (↑n) 1) ↑q.den))) (LE.le q.den n)","decl":"/-- *Dirichlet's approximation theorem:*\nFor any real number `ξ` and positive natural `n`, there is a fraction `q`\nsuch that `q.den ≤ n` and `|ξ - q| ≤ 1/((n+1)*q.den)`.\n\nSee also `AddCircle.exists_norm_nsmul_le`. -/\ntheorem exists_rat_abs_sub_le_and_den_le (ξ : ℝ) {n : ℕ} (n_pos : 0 < n) :\n    ∃ q : ℚ, |ξ - q| ≤ 1 / ((n + 1) * q.den) ∧ q.den ≤ n := by\n  obtain ⟨j, k, hk₀, hk₁, h⟩ := exists_int_int_abs_mul_sub_le ξ n_pos\n  have hk₀' : (0 : ℝ) < k := Int.cast_pos.mpr hk₀\n  have hden : ((j / k : ℚ).den : ℤ) ≤ k := by\n    convert le_of_dvd hk₀ (Rat.den_dvd j k)\n    exact Rat.intCast_div_eq_divInt _ _\n  refine ⟨j / k, ?_, Nat.cast_le.mp (hden.trans hk₁)⟩\n  rw [← div_div, le_div_iff₀ (Nat.cast_pos.mpr <| Rat.pos _ : (0 : ℝ) < _)]\n  refine (mul_le_mul_of_nonneg_left (Int.cast_le.mpr hden : _ ≤ (k : ℝ)) (abs_nonneg _)).trans ?_\n  rwa [← abs_of_pos hk₀', Rat.cast_div, Rat.cast_intCast, Rat.cast_intCast, ← abs_mul, sub_mul,\n    div_mul_cancel₀ _ hk₀'.ne', mul_comm]\n\n"}
{"name":"Real.exists_rat_abs_sub_lt_and_lt_of_irrational","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nhξ : Irrational ξ\nq : Rat\n⊢ Exists fun q' => And (LT.lt (abs (HSub.hSub ξ ↑q')) (HDiv.hDiv 1 (HPow.hPow (↑q'.den) 2))) (LT.lt (abs (HSub.hSub ξ ↑q')) (abs (HSub.hSub ξ ↑q)))","decl":"/-- Given any rational approximation `q` to the irrational real number `ξ`, there is\na good rational approximation `q'` such that `|ξ - q'| < |ξ - q|`. -/\ntheorem exists_rat_abs_sub_lt_and_lt_of_irrational {ξ : ℝ} (hξ : Irrational ξ) (q : ℚ) :\n    ∃ q' : ℚ, |ξ - q'| < 1 / (q'.den : ℝ) ^ 2 ∧ |ξ - q'| < |ξ - q| := by\n  have h := abs_pos.mpr (sub_ne_zero.mpr <| Irrational.ne_rat hξ q)\n  obtain ⟨m, hm⟩ := exists_nat_gt (1 / |ξ - q|)\n  have m_pos : (0 : ℝ) < m := (one_div_pos.mpr h).trans hm\n  obtain ⟨q', hbd, hden⟩ := exists_rat_abs_sub_le_and_den_le ξ (Nat.cast_pos.mp m_pos)\n  have den_pos : (0 : ℝ) < q'.den := Nat.cast_pos.mpr q'.pos\n  have md_pos := mul_pos (add_pos m_pos zero_lt_one) den_pos\n  refine\n    ⟨q', lt_of_le_of_lt hbd ?_,\n      lt_of_le_of_lt hbd <|\n        (one_div_lt md_pos h).mpr <|\n          hm.trans <|\n            lt_of_lt_of_le (lt_add_one _) <|\n              (le_mul_iff_one_le_right <| add_pos m_pos zero_lt_one).mpr <|\n                mod_cast (q'.pos : 1 ≤ q'.den)⟩\n  rw [sq, one_div_lt_one_div md_pos (mul_pos den_pos den_pos), mul_lt_mul_right den_pos]\n  exact lt_add_of_le_of_pos (Nat.cast_le.mpr hden) zero_lt_one\n\n"}
{"name":"Real.infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nhξ : Irrational ξ\n⊢ (setOf fun q => LT.lt (abs (HSub.hSub ξ ↑q)) (HDiv.hDiv 1 (HPow.hPow (↑q.den) 2))).Infinite","decl":"/-- If `ξ` is an irrational real number, then there are infinitely many good\nrational approximations to `ξ`. -/\ntheorem infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational {ξ : ℝ} (hξ : Irrational ξ) :\n    {q : ℚ | |ξ - q| < 1 / (q.den : ℝ) ^ 2}.Infinite := by\n  refine Or.resolve_left (Set.finite_or_infinite _) fun h => ?_\n  obtain ⟨q, _, hq⟩ :=\n    exists_min_image {q : ℚ | |ξ - q| < 1 / (q.den : ℝ) ^ 2} (fun q => |ξ - q|) h\n      ⟨⌊ξ⌋, by simp [abs_of_nonneg, Int.fract_lt_one]⟩\n  obtain ⟨q', hmem, hbetter⟩ := exists_rat_abs_sub_lt_and_lt_of_irrational hξ q\n  exact lt_irrefl _ (lt_of_le_of_lt (hq q' hmem) hbetter)\n\n"}
{"name":"Rat.den_le_and_le_num_le_of_sub_lt_one_div_den_sq","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ q : Rat\nh : LT.lt (abs (HSub.hSub ξ q)) (HDiv.hDiv 1 (HPow.hPow (↑q.den) 2))\n⊢ And (LE.le q.den ξ.den) (And (LE.le (HSub.hSub (Int.ceil (HMul.hMul ξ ↑q.den)) 1) q.num) (LE.le q.num (HAdd.hAdd (Int.floor (HMul.hMul ξ ↑q.den)) 1)))","decl":"/-- If `ξ` is rational, then the good rational approximations to `ξ` have bounded\nnumerator and denominator. -/\ntheorem den_le_and_le_num_le_of_sub_lt_one_div_den_sq {ξ q : ℚ}\n    (h : |ξ - q| < 1 / (q.den : ℚ) ^ 2) :\n    q.den ≤ ξ.den ∧ ⌈ξ * q.den⌉ - 1 ≤ q.num ∧ q.num ≤ ⌊ξ * q.den⌋ + 1 := by\n  have hq₀ : (0 : ℚ) < q.den := Nat.cast_pos.mpr q.pos\n  replace h : |ξ * q.den - q.num| < 1 / q.den := by\n    rw [← mul_lt_mul_right hq₀] at h\n    conv_lhs at h => rw [← abs_of_pos hq₀, ← abs_mul, sub_mul, mul_den_eq_num]\n    rwa [sq, div_mul, mul_div_cancel_left₀ _ hq₀.ne'] at h\n  constructor\n  · rcases eq_or_ne ξ q with (rfl | H)\n    · exact le_rfl\n    · have hξ₀ : (0 : ℚ) < ξ.den := Nat.cast_pos.mpr ξ.pos\n      rw [← Rat.num_div_den ξ, div_mul_eq_mul_div, div_sub' _ _ _ hξ₀.ne', abs_div, abs_of_pos hξ₀,\n        div_lt_iff₀ hξ₀, div_mul_comm, mul_one] at h\n      refine Nat.cast_le.mp ((one_lt_div hq₀).mp <| lt_of_le_of_lt ?_ h).le\n      norm_cast\n      rw [mul_comm _ q.num]\n      exact Int.one_le_abs (sub_ne_zero_of_ne <| mt Rat.eq_iff_mul_eq_mul.mpr H)\n  · obtain ⟨h₁, h₂⟩ :=\n      abs_sub_lt_iff.mp\n        (h.trans_le <|\n          (one_div_le zero_lt_one hq₀).mp <| (@one_div_one ℚ _).symm ▸ Nat.cast_le.mpr q.pos)\n    rw [sub_lt_iff_lt_add, add_comm] at h₁ h₂\n    rw [← sub_lt_iff_lt_add] at h₂\n    norm_cast at h₁ h₂\n    exact\n      ⟨sub_le_iff_le_add.mpr (Int.ceil_le.mpr h₁.le), sub_le_iff_le_add.mp (Int.le_floor.mpr h₂.le)⟩\n\n"}
{"name":"Rat.finite_rat_abs_sub_lt_one_div_den_sq","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Rat\n⊢ (setOf fun q => LT.lt (abs (HSub.hSub ξ q)) (HDiv.hDiv 1 (HPow.hPow (↑q.den) 2))).Finite","decl":"/-- A rational number has only finitely many good rational approximations. -/\ntheorem finite_rat_abs_sub_lt_one_div_den_sq (ξ : ℚ) :\n    {q : ℚ | |ξ - q| < 1 / (q.den : ℚ) ^ 2}.Finite := by\n  let f : ℚ → ℤ × ℕ := fun q => (q.num, q.den)\n  set s := {q : ℚ | |ξ - q| < 1 / (q.den : ℚ) ^ 2}\n  have hinj : Function.Injective f := by\n    intro a b hab\n    simp only [f, Prod.mk.inj_iff] at hab\n    rw [← Rat.num_div_den a, ← Rat.num_div_den b, hab.1, hab.2]\n  have H : f '' s ⊆ ⋃ (y : ℕ) (_ : y ∈ Ioc 0 ξ.den), Icc (⌈ξ * y⌉ - 1) (⌊ξ * y⌋ + 1) ×ˢ {y} := by\n    intro xy hxy\n    simp only [mem_image, mem_setOf] at hxy\n    obtain ⟨q, hq₁, hq₂⟩ := hxy\n    obtain ⟨hd, hn⟩ := den_le_and_le_num_le_of_sub_lt_one_div_den_sq hq₁\n    simp_rw [mem_iUnion]\n    refine ⟨q.den, Set.mem_Ioc.mpr ⟨q.pos, hd⟩, ?_⟩\n    simp only [prod_singleton, mem_image, mem_Icc, (congr_arg Prod.snd (Eq.symm hq₂)).trans rfl]\n    exact ⟨q.num, hn, hq₂⟩\n  refine (Finite.subset ?_ H).of_finite_image hinj.injOn\n  exact Finite.biUnion (finite_Ioc _ _) fun x _ => Finite.prod (finite_Icc _ _) (finite_singleton _)\n\n"}
{"name":"Real.infinite_rat_abs_sub_lt_one_div_den_sq_iff_irrational","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\n⊢ Iff (setOf fun q => LT.lt (abs (HSub.hSub ξ ↑q)) (HDiv.hDiv 1 (HPow.hPow (↑q.den) 2))).Infinite (Irrational ξ)","decl":"/-- The set of good rational approximations to a real number `ξ` is infinite if and only if\n`ξ` is irrational. -/\ntheorem Real.infinite_rat_abs_sub_lt_one_div_den_sq_iff_irrational (ξ : ℝ) :\n    {q : ℚ | |ξ - q| < 1 / (q.den : ℝ) ^ 2}.Infinite ↔ Irrational ξ := by\n  refine\n    ⟨fun h => (irrational_iff_ne_rational ξ).mpr fun a b H => Set.not_infinite.mpr ?_ h,\n      Real.infinite_rat_abs_sub_lt_one_div_den_sq_of_irrational⟩\n  convert Rat.finite_rat_abs_sub_lt_one_div_den_sq ((a : ℚ) / b) with q\n  rw [H, (by (push_cast; rfl) : (1 : ℝ) / (q.den : ℝ) ^ 2 = (1 / (q.den : ℚ) ^ 2 : ℚ))]\n  norm_cast\n\n"}
{"name":"Real.convergent_zero","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\n⊢ Eq (ξ.convergent 0) ↑(Int.floor ξ)","decl":"/-- The zeroth convergent of `ξ` is `⌊ξ⌋`. -/\n@[simp]\ntheorem convergent_zero (ξ : ℝ) : ξ.convergent 0 = ⌊ξ⌋ :=\n  rfl\n\n"}
{"name":"Real.convergent_succ","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nn : Nat\n⊢ Eq (ξ.convergent (HAdd.hAdd n 1)) (HAdd.hAdd (↑(Int.floor ξ)) (Inv.inv ((Inv.inv (Int.fract ξ)).convergent n)))","decl":"/-- The `(n+1)`th convergent of `ξ` is the `n`th convergent of `1/(fract ξ)`. -/\n@[simp]\ntheorem convergent_succ (ξ : ℝ) (n : ℕ) :\n    ξ.convergent (n + 1) = ⌊ξ⌋ + ((fract ξ)⁻¹.convergent n)⁻¹ :=\n  -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5026): was\n  -- by simp only [convergent]\n  rfl\n\n"}
{"name":"Real.convergent_of_zero","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"n : Nat\n⊢ Eq (Real.convergent 0 n) 0","decl":"/-- All convergents of `0` are zero. -/\n@[simp]\ntheorem convergent_of_zero (n : ℕ) : convergent 0 n = 0 := by\n  induction' n with n ih\n  · simp only [convergent_zero, floor_zero, cast_zero]\n  · simp only [ih, convergent_succ, floor_zero, cast_zero, fract_zero, add_zero, inv_zero]\n\n"}
{"name":"Real.convergent_of_int","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Int\nn : Nat\n⊢ Eq ((↑ξ).convergent n) ↑ξ","decl":"/-- If `ξ` is an integer, all its convergents equal `ξ`. -/\n@[simp]\ntheorem convergent_of_int {ξ : ℤ} (n : ℕ) : convergent ξ n = ξ := by\n  cases n\n  · simp only [convergent_zero, floor_intCast]\n  · simp only [convergent_succ, floor_intCast, fract_intCast, convergent_of_zero, add_zero,\n      inv_zero]\n\n"}
{"name":"Real.exists_rat_eq_convergent'","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nu : Int\nv : Nat\nh : Real.ContfracLegendre.Ass ξ u ↑v\n⊢ Exists fun n => Eq (HDiv.hDiv ↑u ↑v) (ξ.convergent n)","decl":"/-- The technical version of *Legendre's Theorem*. -/\ntheorem exists_rat_eq_convergent' {v : ℕ} (h : ContfracLegendre.Ass ξ u v) :\n    ∃ n, (u / v : ℚ) = ξ.convergent n := by\n  induction v using Nat.strong_induction_on generalizing ξ u with | h v ih => ?_\n  rcases lt_trichotomy v 1 with (ht | rfl | ht)\n  · replace h := h.2.2\n    simp only [Nat.lt_one_iff.mp ht, Nat.cast_zero, div_zero, tsub_zero, zero_mul,\n      cast_zero, inv_zero] at h\n    exact False.elim (lt_irrefl _ <| (abs_nonneg ξ).trans_lt h)\n  · rw [Nat.cast_one, div_one]\n    obtain ⟨_, h₁, h₂⟩ := h\n    rcases le_or_lt (u : ℝ) ξ with ht | ht\n    · use 0\n      rw [convergent_zero, Rat.coe_int_inj, eq_comm, floor_eq_iff]\n      convert And.intro ht (sub_lt_iff_lt_add'.mp (abs_lt.mp h₂).2) <;> norm_num\n    · replace h₁ := lt_sub_iff_add_lt'.mp (h₁ rfl)\n      have hξ₁ : ⌊ξ⌋ = u - 1 := by\n        rw [floor_eq_iff, cast_sub, cast_one, sub_add_cancel]\n        exact ⟨(((sub_lt_sub_iff_left _).mpr one_half_lt_one).trans h₁).le, ht⟩\n      rcases eq_or_ne ξ ⌊ξ⌋ with Hξ | Hξ\n      · rw [Hξ, hξ₁, cast_sub, cast_one, ← sub_eq_add_neg, sub_lt_sub_iff_left] at h₁\n        exact False.elim (lt_irrefl _ <| h₁.trans one_half_lt_one)\n      · have hξ₂ : ⌊(fract ξ)⁻¹⌋ = 1 := by\n          rw [floor_eq_iff, cast_one, le_inv_comm₀ zero_lt_one (fract_pos.mpr Hξ), inv_one,\n            one_add_one_eq_two, inv_lt_comm₀ (fract_pos.mpr Hξ) zero_lt_two]\n          refine ⟨(fract_lt_one ξ).le, ?_⟩\n          rw [fract, hξ₁, cast_sub, cast_one, lt_sub_iff_add_lt', sub_add]\n          convert h₁ using 1\n          -- Porting note: added (`convert` handled this in lean 3)\n          rw [sub_eq_add_neg]\n          norm_num\n        use 1\n        simp [convergent, hξ₁, hξ₂, cast_sub, cast_one]\n  · obtain ⟨huv₀, huv₁⟩ := aux₂ (Nat.cast_le.mpr ht) h\n    have Hv : (v : ℚ) ≠ 0 := (Nat.cast_pos.mpr (zero_lt_one.trans ht)).ne'\n    have huv₁' : (u - ⌊ξ⌋ * v).toNat < v := by zify; rwa [toNat_of_nonneg huv₀.le]\n    have inv : ContfracLegendre.Ass (fract ξ)⁻¹ v (u - ⌊ξ⌋ * ↑v).toNat :=\n      (toNat_of_nonneg huv₀.le).symm ▸ invariant (Nat.cast_le.mpr ht) h\n    obtain ⟨n, hn⟩ := ih (u - ⌊ξ⌋ * v).toNat huv₁' inv\n    use n + 1\n    rw [convergent_succ, ← hn,\n      (mod_cast toNat_of_nonneg huv₀.le : ((u - ⌊ξ⌋ * v).toNat : ℚ) = u - ⌊ξ⌋ * v),\n      cast_natCast, inv_div, sub_div, mul_div_cancel_right₀ _ Hv, add_sub_cancel]\n\n"}
{"name":"Real.exists_rat_eq_convergent","module":"Mathlib.NumberTheory.DiophantineApproximation.Basic","initialProofState":"ξ : Real\nq : Rat\nh : LT.lt (abs (HSub.hSub ξ ↑q)) (HDiv.hDiv 1 (HMul.hMul 2 (HPow.hPow (↑q.den) 2)))\n⊢ Exists fun n => Eq q (ξ.convergent n)","decl":"/-- The main result, *Legendre's Theorem* on rational approximation:\nif `ξ` is a real number and `q` is a rational number such that `|ξ - q| < 1/(2*q.den^2)`,\nthen `q` is a convergent of the continued fraction expansion of `ξ`.\nThis version uses `Real.convergent`. -/\ntheorem exists_rat_eq_convergent {q : ℚ} (h : |ξ - q| < 1 / (2 * (q.den : ℝ) ^ 2)) :\n    ∃ n, q = ξ.convergent n := by\n  refine q.num_div_den ▸ exists_rat_eq_convergent' ⟨?_, fun hd => ?_, ?_⟩\n  · exact isCoprime_iff_nat_coprime.mpr (natAbs_ofNat q.den ▸ q.reduced)\n  · rw [← q.den_eq_one_iff.mp (Nat.cast_eq_one.mp hd)] at h\n    simpa only [Rat.den_intCast, Nat.cast_one, one_pow, mul_one] using (abs_lt.mp h).1\n  · obtain ⟨hq₀, hq₁⟩ := aux₀ (Nat.cast_pos.mpr q.pos)\n    replace hq₁ := mul_pos hq₀ hq₁\n    have hq₂ : (0 : ℝ) < 2 * (q.den * q.den) := mul_pos zero_lt_two (mul_pos hq₀ hq₀)\n    rw [cast_natCast] at *\n    rw [(by norm_cast : (q.num / q.den : ℝ) = (q.num / q.den : ℚ)), Rat.num_div_den]\n    exact h.trans (by rw [← one_div, sq, one_div_lt_one_div hq₂ hq₁, ← sub_pos]; ring_nf; exact hq₀)\n\n"}
