{"name":"Turing.BlankExtends.refl","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : List Γ\n⊢ Turing.BlankExtends l l","decl":"@[refl]\ntheorem BlankExtends.refl {Γ} [Inhabited Γ] (l : List Γ) : BlankExtends l l :=\n  ⟨0, by simp⟩\n\n"}
{"name":"Turing.BlankExtends.trans","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl₁ l₂ l₃ : List Γ\na✝¹ : Turing.BlankExtends l₁ l₂\na✝ : Turing.BlankExtends l₂ l₃\n⊢ Turing.BlankExtends l₁ l₃","decl":"@[trans]\ntheorem BlankExtends.trans {Γ} [Inhabited Γ] {l₁ l₂ l₃ : List Γ} :\n    BlankExtends l₁ l₂ → BlankExtends l₂ l₃ → BlankExtends l₁ l₃ := by\n  rintro ⟨i, rfl⟩ ⟨j, rfl⟩\n  exact ⟨i + j, by simp⟩\n\n"}
{"name":"Turing.BlankExtends.below_of_le","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl l₁ l₂ : List Γ\na✝² : Turing.BlankExtends l l₁\na✝¹ : Turing.BlankExtends l l₂\na✝ : LE.le l₁.length l₂.length\n⊢ Turing.BlankExtends l₁ l₂","decl":"theorem BlankExtends.below_of_le {Γ} [Inhabited Γ] {l l₁ l₂ : List Γ} :\n    BlankExtends l l₁ → BlankExtends l l₂ → l₁.length ≤ l₂.length → BlankExtends l₁ l₂ := by\n  rintro ⟨i, rfl⟩ ⟨j, rfl⟩ h; use j - i\n  simp only [List.length_append, Nat.add_le_add_iff_left, List.length_replicate] at h\n  simp only [← List.replicate_add, Nat.add_sub_cancel' h, List.append_assoc]\n\n"}
{"name":"Turing.BlankExtends.above_of_le","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl l₁ l₂ : List Γ\na✝² : Turing.BlankExtends l₁ l\na✝¹ : Turing.BlankExtends l₂ l\na✝ : LE.le l₁.length l₂.length\n⊢ Turing.BlankExtends l₁ l₂","decl":"theorem BlankExtends.above_of_le {Γ} [Inhabited Γ] {l l₁ l₂ : List Γ} :\n    BlankExtends l₁ l → BlankExtends l₂ l → l₁.length ≤ l₂.length → BlankExtends l₁ l₂ := by\n  rintro ⟨i, rfl⟩ ⟨j, e⟩ h; use i - j\n  refine List.append_cancel_right (e.symm.trans ?_)\n  rw [List.append_assoc, ← List.replicate_add, Nat.sub_add_cancel]\n  apply_fun List.length at e\n  simp only [List.length_append, List.length_replicate] at e\n  rwa [← Nat.add_le_add_iff_left, e, Nat.add_le_add_iff_right]\n\n"}
{"name":"Turing.BlankRel.refl","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : List Γ\n⊢ Turing.BlankRel l l","decl":"@[refl]\ntheorem BlankRel.refl {Γ} [Inhabited Γ] (l : List Γ) : BlankRel l l :=\n  Or.inl (BlankExtends.refl _)\n\n"}
{"name":"Turing.BlankRel.symm","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl₁ l₂ : List Γ\na✝ : Turing.BlankRel l₁ l₂\n⊢ Turing.BlankRel l₂ l₁","decl":"@[symm]\ntheorem BlankRel.symm {Γ} [Inhabited Γ] {l₁ l₂ : List Γ} : BlankRel l₁ l₂ → BlankRel l₂ l₁ :=\n  Or.symm\n\n"}
{"name":"Turing.BlankRel.trans","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl₁ l₂ l₃ : List Γ\na✝¹ : Turing.BlankRel l₁ l₂\na✝ : Turing.BlankRel l₂ l₃\n⊢ Turing.BlankRel l₁ l₃","decl":"@[trans]\ntheorem BlankRel.trans {Γ} [Inhabited Γ] {l₁ l₂ l₃ : List Γ} :\n    BlankRel l₁ l₂ → BlankRel l₂ l₃ → BlankRel l₁ l₃ := by\n  rintro (h₁ | h₁) (h₂ | h₂)\n  · exact Or.inl (h₁.trans h₂)\n  · rcases le_total l₁.length l₃.length with h | h\n    · exact Or.inl (h₁.above_of_le h₂ h)\n    · exact Or.inr (h₂.above_of_le h₁ h)\n  · rcases le_total l₁.length l₃.length with h | h\n    · exact Or.inl (h₁.below_of_le h₂ h)\n    · exact Or.inr (h₂.below_of_le h₁ h)\n  · exact Or.inr (h₂.trans h₁)\n\n"}
{"name":"Turing.BlankRel.equivalence","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\n⊢ Equivalence Turing.BlankRel","decl":"theorem BlankRel.equivalence (Γ) [Inhabited Γ] : Equivalence (@BlankRel Γ _) :=\n  ⟨BlankRel.refl, @BlankRel.symm _ _, @BlankRel.trans _ _⟩\n\n"}
{"name":"Turing.ListBlank.induction_on","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\np : Turing.ListBlank Γ → Prop\nq : Turing.ListBlank Γ\nh : ∀ (a : List Γ), p (Turing.ListBlank.mk a)\n⊢ p q","decl":"@[elab_as_elim]\nprotected theorem ListBlank.induction_on {Γ} [Inhabited Γ] {p : ListBlank Γ → Prop}\n    (q : ListBlank Γ) (h : ∀ a, p (ListBlank.mk a)) : p q :=\n  Quotient.inductionOn' q h\n\n"}
{"name":"Turing.ListBlank.head_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : List Γ\n⊢ Eq (Turing.ListBlank.mk l).head l.headI","decl":"@[simp]\ntheorem ListBlank.head_mk {Γ} [Inhabited Γ] (l : List Γ) :\n    ListBlank.head (ListBlank.mk l) = l.headI :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.tail_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : List Γ\n⊢ Eq (Turing.ListBlank.mk l).tail (Turing.ListBlank.mk l.tail)","decl":"@[simp]\ntheorem ListBlank.tail_mk {Γ} [Inhabited Γ] (l : List Γ) :\n    ListBlank.tail (ListBlank.mk l) = ListBlank.mk l.tail :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.cons_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\na : Γ\nl : List Γ\n⊢ Eq (Turing.ListBlank.cons a (Turing.ListBlank.mk l)) (Turing.ListBlank.mk (List.cons a l))","decl":"@[simp]\ntheorem ListBlank.cons_mk {Γ} [Inhabited Γ] (a : Γ) (l : List Γ) :\n    ListBlank.cons a (ListBlank.mk l) = ListBlank.mk (a :: l) :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.head_cons","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\na : Γ\nl : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.cons a l).head a","decl":"@[simp]\ntheorem ListBlank.head_cons {Γ} [Inhabited Γ] (a : Γ) : ∀ l : ListBlank Γ, (l.cons a).head = a :=\n  Quotient.ind' fun _ ↦ rfl\n\n"}
{"name":"Turing.ListBlank.tail_cons","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\na : Γ\nl : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.cons a l).tail l","decl":"@[simp]\ntheorem ListBlank.tail_cons {Γ} [Inhabited Γ] (a : Γ) : ∀ l : ListBlank Γ, (l.cons a).tail = l :=\n  Quotient.ind' fun _ ↦ rfl\n\n"}
{"name":"Turing.ListBlank.cons_head_tail","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.cons l.head l.tail) l","decl":"/-- The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `List` where\nthis only holds for nonempty lists. -/\n@[simp]\ntheorem ListBlank.cons_head_tail {Γ} [Inhabited Γ] : ∀ l : ListBlank Γ, l.tail.cons l.head = l := by\n  apply Quotient.ind'\n  refine fun l ↦ Quotient.sound' (Or.inr ?_)\n  cases l\n  · exact ⟨1, rfl⟩\n  · rfl\n\n"}
{"name":"Turing.ListBlank.exists_cons","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : Turing.ListBlank Γ\n⊢ Exists fun a => Exists fun l' => Eq l (Turing.ListBlank.cons a l')","decl":"/-- The `cons` and `head`/`tail` functions are mutually inverse, unlike in the case of `List` where\nthis only holds for nonempty lists. -/\ntheorem ListBlank.exists_cons {Γ} [Inhabited Γ] (l : ListBlank Γ) :\n    ∃ a l', l = ListBlank.cons a l' :=\n  ⟨_, _, (ListBlank.cons_head_tail _).symm⟩\n\n"}
{"name":"Turing.ListBlank.nth_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : List Γ\nn : Nat\n⊢ Eq ((Turing.ListBlank.mk l).nth n) (l.getI n)","decl":"@[simp]\ntheorem ListBlank.nth_mk {Γ} [Inhabited Γ] (l : List Γ) (n : ℕ) :\n    (ListBlank.mk l).nth n = l.getI n :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.nth_zero","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : Turing.ListBlank Γ\n⊢ Eq (l.nth 0) l.head","decl":"@[simp]\ntheorem ListBlank.nth_zero {Γ} [Inhabited Γ] (l : ListBlank Γ) : l.nth 0 = l.head := by\n  conv => lhs; rw [← ListBlank.cons_head_tail l]\n  exact Quotient.inductionOn' l.tail fun l ↦ rfl\n\n"}
{"name":"Turing.ListBlank.nth_succ","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl : Turing.ListBlank Γ\nn : Nat\n⊢ Eq (l.nth (HAdd.hAdd n 1)) (l.tail.nth n)","decl":"@[simp]\ntheorem ListBlank.nth_succ {Γ} [Inhabited Γ] (l : ListBlank Γ) (n : ℕ) :\n    l.nth (n + 1) = l.tail.nth n := by\n  conv => lhs; rw [← ListBlank.cons_head_tail l]\n  exact Quotient.inductionOn' l.tail fun l ↦ rfl\n\n"}
{"name":"Turing.ListBlank.ext_iff","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ni : Inhabited Γ\nL₁ L₂ : Turing.ListBlank Γ\n⊢ Iff (Eq L₁ L₂) (∀ (i_1 : Nat), Eq (L₁.nth i_1) (L₂.nth i_1))","decl":"@[ext]\ntheorem ListBlank.ext {Γ} [i : Inhabited Γ] {L₁ L₂ : ListBlank Γ} :\n    (∀ i, L₁.nth i = L₂.nth i) → L₁ = L₂ := by\n  refine ListBlank.induction_on L₁ fun l₁ ↦ ListBlank.induction_on L₂ fun l₂ H ↦ ?_\n  wlog h : l₁.length ≤ l₂.length\n  · cases le_total l₁.length l₂.length <;> [skip; symm] <;> apply this <;> try assumption\n    intro\n    rw [H]\n  refine Quotient.sound' (Or.inl ⟨l₂.length - l₁.length, ?_⟩)\n  refine List.ext_getElem ?_ fun i h h₂ ↦ Eq.symm ?_\n  · simp only [Nat.add_sub_cancel' h, List.length_append, List.length_replicate]\n  simp only [ListBlank.nth_mk] at H\n  cases' lt_or_le i l₁.length with h' h'\n  · simp [h', List.getElem_append _ h₂, ← List.getI_eq_getElem _ h, ← List.getI_eq_getElem _ h', H]\n  · rw [List.getElem_append_right h', List.getElem_replicate,\n      ← List.getI_eq_default _ h', H, List.getI_eq_getElem _ h]\n\n"}
{"name":"Turing.ListBlank.ext","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ni : Inhabited Γ\nL₁ L₂ : Turing.ListBlank Γ\na✝ : ∀ (i_1 : Nat), Eq (L₁.nth i_1) (L₂.nth i_1)\n⊢ Eq L₁ L₂","decl":"@[ext]\ntheorem ListBlank.ext {Γ} [i : Inhabited Γ] {L₁ L₂ : ListBlank Γ} :\n    (∀ i, L₁.nth i = L₂.nth i) → L₁ = L₂ := by\n  refine ListBlank.induction_on L₁ fun l₁ ↦ ListBlank.induction_on L₂ fun l₂ H ↦ ?_\n  wlog h : l₁.length ≤ l₂.length\n  · cases le_total l₁.length l₂.length <;> [skip; symm] <;> apply this <;> try assumption\n    intro\n    rw [H]\n  refine Quotient.sound' (Or.inl ⟨l₂.length - l₁.length, ?_⟩)\n  refine List.ext_getElem ?_ fun i h h₂ ↦ Eq.symm ?_\n  · simp only [Nat.add_sub_cancel' h, List.length_append, List.length_replicate]\n  simp only [ListBlank.nth_mk] at H\n  cases' lt_or_le i l₁.length with h' h'\n  · simp [h', List.getElem_append _ h₂, ← List.getI_eq_getElem _ h, ← List.getI_eq_getElem _ h', H]\n  · rw [List.getElem_append_right h', List.getElem_replicate,\n      ← List.getI_eq_default _ h', H, List.getI_eq_getElem _ h]\n\n"}
{"name":"Turing.ListBlank.nth_modifyNth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nf : Γ → Γ\nn i : Nat\nL : Turing.ListBlank Γ\n⊢ Eq ((Turing.ListBlank.modifyNth f n L).nth i) (ite (Eq i n) (f (L.nth i)) (L.nth i))","decl":"theorem ListBlank.nth_modifyNth {Γ} [Inhabited Γ] (f : Γ → Γ) (n i) (L : ListBlank Γ) :\n    (L.modifyNth f n).nth i = if i = n then f (L.nth i) else L.nth i := by\n  induction' n with n IH generalizing i L\n  · cases i <;> simp only [ListBlank.nth_zero, if_true, ListBlank.head_cons, ListBlank.modifyNth,\n      ListBlank.nth_succ, if_false, ListBlank.tail_cons, reduceCtorEq]\n  · cases i\n    · rw [if_neg (Nat.succ_ne_zero _).symm]\n      simp only [ListBlank.nth_zero, ListBlank.head_cons, ListBlank.modifyNth]\n    · simp only [IH, ListBlank.modifyNth, ListBlank.nth_succ, ListBlank.tail_cons, Nat.succ.injEq]\n\n"}
{"name":"Turing.PointedMap.map_pt'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u\nΓ' : Type v\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nself : Turing.PointedMap Γ Γ'\n⊢ Eq (self.f Inhabited.default) Inhabited.default","decl":"/-- A pointed map of `Inhabited` types is a map that sends one default value to the other. -/\nstructure PointedMap.{u, v} (Γ : Type u) (Γ' : Type v) [Inhabited Γ] [Inhabited Γ'] :\n    Type max u v where\n  /-- The map underlying this instance. -/\n  f : Γ → Γ'\n  map_pt' : f default = default\n\n"}
{"name":"Turing.PointedMap.mk.inj","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u\nΓ' : Type v\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf✝ : Γ → Γ'\nmap_pt'✝ : Eq (f✝ Inhabited.default) Inhabited.default\nf : Γ → Γ'\nmap_pt' : Eq (f Inhabited.default) Inhabited.default\nx✝ : Eq { f := f✝, map_pt' := map_pt'✝ } { f := f, map_pt' := map_pt' }\n⊢ Eq f✝ f","decl":"/-- A pointed map of `Inhabited` types is a map that sends one default value to the other. -/\nstructure PointedMap.{u, v} (Γ : Type u) (Γ' : Type v) [Inhabited Γ] [Inhabited Γ'] :\n    Type max u v where\n  /-- The map underlying this instance. -/\n  f : Γ → Γ'\n  map_pt' : f default = default\n\n"}
{"name":"Turing.PointedMap.mk.sizeOf_spec","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u\nΓ' : Type v\ninst✝³ : Inhabited Γ\ninst✝² : Inhabited Γ'\ninst✝¹ : SizeOf Γ\ninst✝ : SizeOf Γ'\nf : Γ → Γ'\nmap_pt' : Eq (f Inhabited.default) Inhabited.default\n⊢ Eq (SizeOf.sizeOf { f := f, map_pt' := map_pt' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_pt'))","decl":"/-- A pointed map of `Inhabited` types is a map that sends one default value to the other. -/\nstructure PointedMap.{u, v} (Γ : Type u) (Γ' : Type v) [Inhabited Γ] [Inhabited Γ'] :\n    Type max u v where\n  /-- The map underlying this instance. -/\n  f : Γ → Γ'\n  map_pt' : f default = default\n\n"}
{"name":"Turing.PointedMap.mk.injEq","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u\nΓ' : Type v\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf✝ : Γ → Γ'\nmap_pt'✝ : Eq (f✝ Inhabited.default) Inhabited.default\nf : Γ → Γ'\nmap_pt' : Eq (f Inhabited.default) Inhabited.default\n⊢ Eq (Eq { f := f✝, map_pt' := map_pt'✝ } { f := f, map_pt' := map_pt' }) (Eq f✝ f)","decl":"/-- A pointed map of `Inhabited` types is a map that sends one default value to the other. -/\nstructure PointedMap.{u, v} (Γ : Type u) (Γ' : Type v) [Inhabited Γ] [Inhabited Γ'] :\n    Type max u v where\n  /-- The map underlying this instance. -/\n  f : Γ → Γ'\n  map_pt' : f default = default\n\n"}
{"name":"Turing.PointedMap.mk_val","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Γ → Γ'\npt : Eq (f Inhabited.default) Inhabited.default\n⊢ Eq { f := f, map_pt' := pt }.f f","decl":"theorem PointedMap.mk_val {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : Γ → Γ') (pt) :\n    (PointedMap.mk f pt : Γ → Γ') = f :=\n  rfl\n\n"}
{"name":"Turing.PointedMap.map_pt","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\n⊢ Eq (f.f Inhabited.default) Inhabited.default","decl":"@[simp]\ntheorem PointedMap.map_pt {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') :\n    f default = default :=\n  PointedMap.map_pt' _\n\n"}
{"name":"Turing.PointedMap.headI_map","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : List Γ\n⊢ Eq (List.map f.f l).headI (f.f l.headI)","decl":"@[simp]\ntheorem PointedMap.headI_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')\n    (l : List Γ) : (l.map f).headI = f l.headI := by\n  cases l <;> [exact (PointedMap.map_pt f).symm; rfl]\n\n"}
{"name":"Turing.ListBlank.map_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : List Γ\n⊢ Eq (Turing.ListBlank.map f (Turing.ListBlank.mk l)) (Turing.ListBlank.mk (List.map f.f l))","decl":"@[simp]\ntheorem ListBlank.map_mk {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : List Γ) :\n    (ListBlank.mk l).map f = ListBlank.mk (l.map f) :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.head_map","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.map f l).head (f.f l.head)","decl":"@[simp]\ntheorem ListBlank.head_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')\n    (l : ListBlank Γ) : (l.map f).head = f l.head := by\n  conv => lhs; rw [← ListBlank.cons_head_tail l]\n  exact Quotient.inductionOn' l fun a ↦ rfl\n\n"}
{"name":"Turing.ListBlank.tail_map","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.map f l).tail (Turing.ListBlank.map f l.tail)","decl":"@[simp]\ntheorem ListBlank.tail_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')\n    (l : ListBlank Γ) : (l.map f).tail = l.tail.map f := by\n  conv => lhs; rw [← ListBlank.cons_head_tail l]\n  exact Quotient.inductionOn' l fun a ↦ rfl\n\n"}
{"name":"Turing.ListBlank.map_cons","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : Turing.ListBlank Γ\na : Γ\n⊢ Eq (Turing.ListBlank.map f (Turing.ListBlank.cons a l)) (Turing.ListBlank.cons (f.f a) (Turing.ListBlank.map f l))","decl":"@[simp]\ntheorem ListBlank.map_cons {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')\n    (l : ListBlank Γ) (a : Γ) : (l.cons a).map f = (l.map f).cons (f a) := by\n  refine (ListBlank.cons_head_tail _).symm.trans ?_\n  simp only [ListBlank.head_map, ListBlank.head_cons, ListBlank.tail_map, ListBlank.tail_cons]\n\n"}
{"name":"Turing.ListBlank.nth_map","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : Turing.ListBlank Γ\nn : Nat\n⊢ Eq ((Turing.ListBlank.map f l).nth n) (f.f (l.nth n))","decl":"@[simp]\ntheorem ListBlank.nth_map {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ')\n    (l : ListBlank Γ) (n : ℕ) : (l.map f).nth n = f (l.nth n) := by\n  refine l.inductionOn fun l ↦ ?_\n  -- Porting note: Added `suffices` to get `simp` to work.\n  suffices ((mk l).map f).nth n = f ((mk l).nth n) by exact this\n  simp only [ListBlank.map_mk, ListBlank.nth_mk, ← List.getD_default_eq_getI]\n  rw [← List.getD_map _ _ f]\n  simp\n\n"}
{"name":"Turing.proj_map_nth","module":"Mathlib.Computability.Tape","initialProofState":"ι : Type u_1\nΓ : ι → Type u_2\ninst✝ : (i : ι) → Inhabited (Γ i)\ni : ι\nL : Turing.ListBlank ((i : ι) → Γ i)\nn : Nat\n⊢ Eq ((Turing.ListBlank.map (Turing.proj i) L).nth n) (L.nth n i)","decl":"theorem proj_map_nth {ι : Type*} {Γ : ι → Type*} [∀ i, Inhabited (Γ i)] (i : ι) (L n) :\n    (ListBlank.map (@proj ι Γ _ i) L).nth n = L.nth n i := by\n  rw [ListBlank.nth_map]; rfl\n\n"}
{"name":"Turing.ListBlank.map_modifyNth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nF : Turing.PointedMap Γ Γ'\nf : Γ → Γ\nf' : Γ' → Γ'\nH : ∀ (x : Γ), Eq (F.f (f x)) (f' (F.f x))\nn : Nat\nL : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.map F (Turing.ListBlank.modifyNth f n L)) (Turing.ListBlank.modifyNth f' n (Turing.ListBlank.map F L))","decl":"theorem ListBlank.map_modifyNth {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (F : PointedMap Γ Γ')\n    (f : Γ → Γ) (f' : Γ' → Γ') (H : ∀ x, F (f x) = f' (F x)) (n) (L : ListBlank Γ) :\n    (L.modifyNth f n).map F = (L.map F).modifyNth f' n := by\n  induction' n with n IH generalizing L <;>\n    simp only [*, ListBlank.head_map, ListBlank.modifyNth, ListBlank.map_cons, ListBlank.tail_map]\n\n"}
{"name":"Turing.ListBlank.append_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl₁ l₂ : List Γ\n⊢ Eq (Turing.ListBlank.append l₁ (Turing.ListBlank.mk l₂)) (Turing.ListBlank.mk (HAppend.hAppend l₁ l₂))","decl":"@[simp]\ntheorem ListBlank.append_mk {Γ} [Inhabited Γ] (l₁ l₂ : List Γ) :\n    ListBlank.append l₁ (ListBlank.mk l₂) = ListBlank.mk (l₁ ++ l₂) := by\n  induction l₁ <;>\n    simp only [*, ListBlank.append, List.nil_append, List.cons_append, ListBlank.cons_mk]\n\n"}
{"name":"Turing.ListBlank.append_assoc","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nl₁ l₂ : List Γ\nl₃ : Turing.ListBlank Γ\n⊢ Eq (Turing.ListBlank.append (HAppend.hAppend l₁ l₂) l₃) (Turing.ListBlank.append l₁ (Turing.ListBlank.append l₂ l₃))","decl":"theorem ListBlank.append_assoc {Γ} [Inhabited Γ] (l₁ l₂ : List Γ) (l₃ : ListBlank Γ) :\n    ListBlank.append (l₁ ++ l₂) l₃ = ListBlank.append l₁ (ListBlank.append l₂ l₃) := by\n  refine l₃.inductionOn fun l ↦ ?_\n  -- Porting note: Added `suffices` to get `simp` to work.\n  suffices append (l₁ ++ l₂) (mk l) = append l₁ (append l₂ (mk l)) by exact this\n  simp only [ListBlank.append_mk, List.append_assoc]\n\n"}
{"name":"Turing.ListBlank.flatMap_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nl : List Γ\nf : Γ → List Γ'\nhf : Exists fun n => Eq (f Inhabited.default) (List.replicate n Inhabited.default)\n⊢ Eq ((Turing.ListBlank.mk l).flatMap f hf) (Turing.ListBlank.mk (l.flatMap f))","decl":"@[simp]\ntheorem ListBlank.flatMap_mk\n    {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (l : List Γ) (f : Γ → List Γ') (hf) :\n    (ListBlank.mk l).flatMap f hf = ListBlank.mk (l.flatMap f) :=\n  rfl\n\n"}
{"name":"Turing.ListBlank.bind_mk","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nl : List Γ\nf : Γ → List Γ'\nhf : Exists fun n => Eq (f Inhabited.default) (List.replicate n Inhabited.default)\n⊢ Eq ((Turing.ListBlank.mk l).flatMap f hf) (Turing.ListBlank.mk (l.flatMap f))","decl":"@[deprecated (since := \"2024-10-16\")] alias ListBlank.bind_mk := ListBlank.flatMap_mk\n\n"}
{"name":"Turing.ListBlank.cons_flatMap","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\na : Γ\nl : Turing.ListBlank Γ\nf : Γ → List Γ'\nhf : Exists fun n => Eq (f Inhabited.default) (List.replicate n Inhabited.default)\n⊢ Eq ((Turing.ListBlank.cons a l).flatMap f hf) (Turing.ListBlank.append (f a) (l.flatMap f hf))","decl":"@[simp]\ntheorem ListBlank.cons_flatMap {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (a : Γ) (l : ListBlank Γ)\n    (f : Γ → List Γ') (hf) : (l.cons a).flatMap f hf = (l.flatMap f hf).append (f a) := by\n  refine l.inductionOn fun l ↦ ?_\n  -- Porting note: Added `suffices` to get `simp` to work.\n  suffices ((mk l).cons a).flatMap f hf = ((mk l).flatMap f hf).append (f a) by exact this\n  simp only [ListBlank.append_mk, ListBlank.flatMap_mk, ListBlank.cons_mk, List.flatMap_cons]\n\n"}
{"name":"Turing.ListBlank.cons_bind","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\na : Γ\nl : Turing.ListBlank Γ\nf : Γ → List Γ'\nhf : Exists fun n => Eq (f Inhabited.default) (List.replicate n Inhabited.default)\n⊢ Eq ((Turing.ListBlank.cons a l).flatMap f hf) (Turing.ListBlank.append (f a) (l.flatMap f hf))","decl":"@[deprecated (since := \"2024-10-16\")] alias ListBlank.cons_bind := ListBlank.cons_flatMap\n\n"}
{"name":"Turing.Tape.mk.sizeOf_spec","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝¹ : Inhabited Γ\ninst✝ : SizeOf Γ\nhead : Γ\nleft right : Turing.ListBlank Γ\n⊢ Eq (SizeOf.sizeOf { head := head, left := left, right := right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf head)) (SizeOf.sizeOf left)) (SizeOf.sizeOf right))","decl":"/-- The tape of a Turing machine is composed of a head element (which we imagine to be the\ncurrent position of the head), together with two `ListBlank`s denoting the portions of the tape\ngoing off to the left and right. When the Turing machine moves right, an element is pulled from the\nright side and becomes the new head, while the head element is `cons`ed onto the left side. -/\nstructure Tape (Γ : Type*) [Inhabited Γ] where\n  /-- The current position of the head. -/\n  head : Γ\n  /-- The portion of the tape going off to the left. -/\n  left : ListBlank Γ\n  /-- The portion of the tape going off to the right. -/\n  right : ListBlank Γ\n\n"}
{"name":"Turing.Tape.mk.inj","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nhead✝ : Γ\nleft✝ right✝ : Turing.ListBlank Γ\nhead : Γ\nleft right : Turing.ListBlank Γ\nx✝ : Eq { head := head✝, left := left✝, right := right✝ } { head := head, left := left, right := right }\n⊢ And (Eq head✝ head) (And (Eq left✝ left) (Eq right✝ right))","decl":"/-- The tape of a Turing machine is composed of a head element (which we imagine to be the\ncurrent position of the head), together with two `ListBlank`s denoting the portions of the tape\ngoing off to the left and right. When the Turing machine moves right, an element is pulled from the\nright side and becomes the new head, while the head element is `cons`ed onto the left side. -/\nstructure Tape (Γ : Type*) [Inhabited Γ] where\n  /-- The current position of the head. -/\n  head : Γ\n  /-- The portion of the tape going off to the left. -/\n  left : ListBlank Γ\n  /-- The portion of the tape going off to the right. -/\n  right : ListBlank Γ\n\n"}
{"name":"Turing.Tape.mk.injEq","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nhead✝ : Γ\nleft✝ right✝ : Turing.ListBlank Γ\nhead : Γ\nleft right : Turing.ListBlank Γ\n⊢ Eq (Eq { head := head✝, left := left✝, right := right✝ } { head := head, left := left, right := right }) (And (Eq head✝ head) (And (Eq left✝ left) (Eq right✝ right)))","decl":"/-- The tape of a Turing machine is composed of a head element (which we imagine to be the\ncurrent position of the head), together with two `ListBlank`s denoting the portions of the tape\ngoing off to the left and right. When the Turing machine moves right, an element is pulled from the\nright side and becomes the new head, while the head element is `cons`ed onto the left side. -/\nstructure Tape (Γ : Type*) [Inhabited Γ] where\n  /-- The current position of the head. -/\n  head : Γ\n  /-- The portion of the tape going off to the left. -/\n  left : ListBlank Γ\n  /-- The portion of the tape going off to the right. -/\n  right : ListBlank Γ\n\n"}
{"name":"Turing.Dir.left.sizeOf_spec","module":"Mathlib.Computability.Tape","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.Dir.left) 1","decl":"/-- A direction for the Turing machine `move` command, either\n  left or right. -/\ninductive Dir\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.Dir.right.sizeOf_spec","module":"Mathlib.Computability.Tape","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.Dir.right) 1","decl":"/-- A direction for the Turing machine `move` command, either\n  left or right. -/\ninductive Dir\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.Dir.ofNat_toCtorIdx","module":"Mathlib.Computability.Tape","initialProofState":"x : Turing.Dir\n⊢ Eq (Turing.Dir.ofNat x.toCtorIdx) x","decl":"/-- A direction for the Turing machine `move` command, either\n  left or right. -/\ninductive Dir\n  | left\n  | right\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.Tape.move_left_right","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.move Turing.Dir.right (Turing.Tape.move Turing.Dir.left T)) T","decl":"@[simp]\ntheorem Tape.move_left_right {Γ} [Inhabited Γ] (T : Tape Γ) :\n    (T.move Dir.left).move Dir.right = T := by\n  cases T; simp [Tape.move]\n\n"}
{"name":"Turing.Tape.move_right_left","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.move Turing.Dir.left (Turing.Tape.move Turing.Dir.right T)) T","decl":"@[simp]\ntheorem Tape.move_right_left {Γ} [Inhabited Γ] (T : Tape Γ) :\n    (T.move Dir.right).move Dir.left = T := by\n  cases T; simp [Tape.move]\n\n"}
{"name":"Turing.Tape.mk'_left","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.mk' L R).left L","decl":"@[simp]\ntheorem Tape.mk'_left {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).left = L :=\n  rfl\n\n"}
{"name":"Turing.Tape.mk'_head","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.mk' L R).head R.head","decl":"@[simp]\ntheorem Tape.mk'_head {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).head = R.head :=\n  rfl\n\n"}
{"name":"Turing.Tape.mk'_right","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.mk' L R).right R.tail","decl":"@[simp]\ntheorem Tape.mk'_right {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).right = R.tail :=\n  rfl\n\n"}
{"name":"Turing.Tape.mk'_right₀","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.mk' L R).right₀ R","decl":"@[simp]\ntheorem Tape.mk'_right₀ {Γ} [Inhabited Γ] (L R : ListBlank Γ) : (Tape.mk' L R).right₀ = R :=\n  ListBlank.cons_head_tail _\n\n"}
{"name":"Turing.Tape.mk'_left_right₀","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.mk' T.left T.right₀) T","decl":"@[simp]\ntheorem Tape.mk'_left_right₀ {Γ} [Inhabited Γ] (T : Tape Γ) : Tape.mk' T.left T.right₀ = T := by\n  cases T\n  simp only [Tape.right₀, Tape.mk', ListBlank.head_cons, ListBlank.tail_cons, eq_self_iff_true,\n    and_self_iff]\n\n"}
{"name":"Turing.Tape.exists_mk'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Exists fun L => Exists fun R => Eq T (Turing.Tape.mk' L R)","decl":"theorem Tape.exists_mk' {Γ} [Inhabited Γ] (T : Tape Γ) : ∃ L R, T = Tape.mk' L R :=\n  ⟨_, _, (Tape.mk'_left_right₀ _).symm⟩\n\n"}
{"name":"Turing.Tape.move_left_mk'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.move Turing.Dir.left (Turing.Tape.mk' L R)) (Turing.Tape.mk' L.tail (Turing.ListBlank.cons L.head R))","decl":"@[simp]\ntheorem Tape.move_left_mk' {Γ} [Inhabited Γ] (L R : ListBlank Γ) :\n    (Tape.mk' L R).move Dir.left = Tape.mk' L.tail (R.cons L.head) := by\n  simp only [Tape.move, Tape.mk', ListBlank.head_cons, eq_self_iff_true, ListBlank.cons_head_tail,\n    and_self_iff, ListBlank.tail_cons]\n\n"}
{"name":"Turing.Tape.move_right_mk'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.move Turing.Dir.right (Turing.Tape.mk' L R)) (Turing.Tape.mk' (Turing.ListBlank.cons R.head L) R.tail)","decl":"@[simp]\ntheorem Tape.move_right_mk' {Γ} [Inhabited Γ] (L R : ListBlank Γ) :\n    (Tape.mk' L R).move Dir.right = Tape.mk' (L.cons R.head) R.tail := by\n  simp only [Tape.move, Tape.mk', ListBlank.head_cons, eq_self_iff_true, ListBlank.cons_head_tail,\n    and_self_iff, ListBlank.tail_cons]\n\n"}
{"name":"Turing.Tape.nth_zero","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Eq (T.nth 0) T.head","decl":"@[simp]\ntheorem Tape.nth_zero {Γ} [Inhabited Γ] (T : Tape Γ) : T.nth 0 = T.1 :=\n  rfl\n\n"}
{"name":"Turing.Tape.right₀_nth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\nn : Nat\n⊢ Eq (T.right₀.nth n) (T.nth ↑n)","decl":"theorem Tape.right₀_nth {Γ} [Inhabited Γ] (T : Tape Γ) (n : ℕ) : T.right₀.nth n = T.nth n := by\n  cases n <;> simp only [Tape.nth, Tape.right₀, Int.ofNat_zero, ListBlank.nth_zero,\n    ListBlank.nth_succ, ListBlank.head_cons, ListBlank.tail_cons]\n\n"}
{"name":"Turing.Tape.mk'_nth_nat","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nL R : Turing.ListBlank Γ\nn : Nat\n⊢ Eq ((Turing.Tape.mk' L R).nth ↑n) (R.nth n)","decl":"@[simp]\ntheorem Tape.mk'_nth_nat {Γ} [Inhabited Γ] (L R : ListBlank Γ) (n : ℕ) :\n    (Tape.mk' L R).nth n = R.nth n := by\n  rw [← Tape.right₀_nth, Tape.mk'_right₀]\n\n"}
{"name":"Turing.Tape.move_left_nth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\ni : Int\n⊢ Eq ((Turing.Tape.move Turing.Dir.left T).nth i) (T.nth (HSub.hSub i 1))","decl":"@[simp]\ntheorem Tape.move_left_nth {Γ} [Inhabited Γ] :\n    ∀ (T : Tape Γ) (i : ℤ), (T.move Dir.left).nth i = T.nth (i - 1)\n  | ⟨_, _, _⟩, -(_ + 1 : ℕ) => (ListBlank.nth_succ _ _).symm\n  | ⟨_, _, _⟩, 0 => (ListBlank.nth_zero _).symm\n  | ⟨_, _, _⟩, 1 => (ListBlank.nth_zero _).trans (ListBlank.head_cons _ _)\n  | ⟨a, L, R⟩, (n + 1 : ℕ) + 1 => by\n    rw [add_sub_cancel_right]\n    change (R.cons a).nth (n + 1) = R.nth n\n    rw [ListBlank.nth_succ, ListBlank.tail_cons]\n\n"}
{"name":"Turing.Tape.move_right_nth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\ni : Int\n⊢ Eq ((Turing.Tape.move Turing.Dir.right T).nth i) (T.nth (HAdd.hAdd i 1))","decl":"@[simp]\ntheorem Tape.move_right_nth {Γ} [Inhabited Γ] (T : Tape Γ) (i : ℤ) :\n    (T.move Dir.right).nth i = T.nth (i + 1) := by\n  conv => rhs; rw [← T.move_right_left]\n  rw [Tape.move_left_nth, add_sub_cancel_right]\n\n"}
{"name":"Turing.Tape.move_right_n_head","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\ni : Nat\n⊢ Eq (Nat.iterate (Turing.Tape.move Turing.Dir.right) i T).head (T.nth ↑i)","decl":"@[simp]\ntheorem Tape.move_right_n_head {Γ} [Inhabited Γ] (T : Tape Γ) (i : ℕ) :\n    ((Tape.move Dir.right)^[i] T).head = T.nth i := by\n  induction i generalizing T\n  · rfl\n  · simp only [*, Tape.move_right_nth, Int.ofNat_succ, iterate_succ, Function.comp_apply]\n\n"}
{"name":"Turing.Tape.write_self","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.write T.head T) T","decl":"@[simp]\ntheorem Tape.write_self {Γ} [Inhabited Γ] : ∀ T : Tape Γ, T.write T.1 = T := by\n  rintro ⟨⟩; rfl\n\n"}
{"name":"Turing.Tape.write_nth","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nb : Γ\nT : Turing.Tape Γ\ni : Int\n⊢ Eq ((Turing.Tape.write b T).nth i) (ite (Eq i 0) b (T.nth i))","decl":"@[simp]\ntheorem Tape.write_nth {Γ} [Inhabited Γ] (b : Γ) :\n    ∀ (T : Tape Γ) {i : ℤ}, (T.write b).nth i = if i = 0 then b else T.nth i\n  | _, 0 => rfl\n  | _, (_ + 1 : ℕ) => rfl\n  | _, -(_ + 1 : ℕ) => rfl\n\n"}
{"name":"Turing.Tape.write_mk'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\na b : Γ\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.write b (Turing.Tape.mk' L (Turing.ListBlank.cons a R))) (Turing.Tape.mk' L (Turing.ListBlank.cons b R))","decl":"@[simp]\ntheorem Tape.write_mk' {Γ} [Inhabited Γ] (a b : Γ) (L R : ListBlank Γ) :\n    (Tape.mk' L (R.cons a)).write b = Tape.mk' L (R.cons b) := by\n  simp only [Tape.write, Tape.mk', ListBlank.head_cons, ListBlank.tail_cons, eq_self_iff_true,\n    and_self_iff]\n\n"}
{"name":"Turing.Tape.map_fst","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.map f T).head (f.f T.head)","decl":"@[simp]\ntheorem Tape.map_fst {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') :\n    ∀ T : Tape Γ, (T.map f).1 = f T.1 := by\n  rintro ⟨⟩; rfl\n\n"}
{"name":"Turing.Tape.map_write","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nb : Γ\nT : Turing.Tape Γ\n⊢ Eq (Turing.Tape.map f (Turing.Tape.write b T)) (Turing.Tape.write (f.f b) (Turing.Tape.map f T))","decl":"@[simp]\ntheorem Tape.map_write {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (b : Γ) :\n    ∀ T : Tape Γ, (T.write b).map f = (T.map f).write (f b) := by\n  rintro ⟨⟩; rfl\n\n"}
{"name":"Turing.Tape.write_move_right_n","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\ninst✝ : Inhabited Γ\nf : Γ → Γ\nL R : Turing.ListBlank Γ\nn : Nat\n⊢ Eq (Turing.Tape.write (f (R.nth n)) (Nat.iterate (Turing.Tape.move Turing.Dir.right) n (Turing.Tape.mk' L R))) (Nat.iterate (Turing.Tape.move Turing.Dir.right) n (Turing.Tape.mk' L (Turing.ListBlank.modifyNth f n R)))","decl":"@[simp]\ntheorem Tape.write_move_right_n {Γ} [Inhabited Γ] (f : Γ → Γ) (L R : ListBlank Γ) (n : ℕ) :\n    ((Tape.move Dir.right)^[n] (Tape.mk' L R)).write (f (R.nth n)) =\n      (Tape.move Dir.right)^[n] (Tape.mk' L (R.modifyNth f n)) := by\n  induction' n with n IH generalizing L R\n  · simp only [ListBlank.nth_zero, ListBlank.modifyNth, iterate_zero_apply]\n    rw [← Tape.write_mk', ListBlank.cons_head_tail]\n  simp only [ListBlank.head_cons, ListBlank.nth_succ, ListBlank.modifyNth, Tape.move_right_mk',\n    ListBlank.tail_cons, iterate_succ_apply, IH]\n\n"}
{"name":"Turing.Tape.map_move","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nT : Turing.Tape Γ\nd : Turing.Dir\n⊢ Eq (Turing.Tape.map f (Turing.Tape.move d T)) (Turing.Tape.move d (Turing.Tape.map f T))","decl":"theorem Tape.map_move {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (T : Tape Γ) (d) :\n    (T.move d).map f = (T.map f).move d := by\n  cases T\n  cases d <;> simp only [Tape.move, Tape.map, ListBlank.head_map, eq_self_iff_true,\n    ListBlank.map_cons, and_self_iff, ListBlank.tail_map]\n\n"}
{"name":"Turing.Tape.map_mk'","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nL R : Turing.ListBlank Γ\n⊢ Eq (Turing.Tape.map f (Turing.Tape.mk' L R)) (Turing.Tape.mk' (Turing.ListBlank.map f L) (Turing.ListBlank.map f R))","decl":"theorem Tape.map_mk' {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (L R : ListBlank Γ) :\n    (Tape.mk' L R).map f = Tape.mk' (L.map f) (R.map f) := by\n  simp only [Tape.mk', Tape.map, ListBlank.head_map, eq_self_iff_true, and_self_iff,\n    ListBlank.tail_map]\n\n"}
{"name":"Turing.Tape.map_mk₂","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nL R : List Γ\n⊢ Eq (Turing.Tape.map f (Turing.Tape.mk₂ L R)) (Turing.Tape.mk₂ (List.map f.f L) (List.map f.f R))","decl":"theorem Tape.map_mk₂ {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (L R : List Γ) :\n    (Tape.mk₂ L R).map f = Tape.mk₂ (L.map f) (R.map f) := by\n  simp only [Tape.mk₂, Tape.map_mk', ListBlank.map_mk]\n\n"}
{"name":"Turing.Tape.map_mk₁","module":"Mathlib.Computability.Tape","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\ninst✝¹ : Inhabited Γ\ninst✝ : Inhabited Γ'\nf : Turing.PointedMap Γ Γ'\nl : List Γ\n⊢ Eq (Turing.Tape.map f (Turing.Tape.mk₁ l)) (Turing.Tape.mk₁ (List.map f.f l))","decl":"theorem Tape.map_mk₁ {Γ Γ'} [Inhabited Γ] [Inhabited Γ'] (f : PointedMap Γ Γ') (l : List Γ) :\n    (Tape.mk₁ l).map f = Tape.mk₁ (l.map f) :=\n  Tape.map_mk₂ _ _ _\n\n"}
