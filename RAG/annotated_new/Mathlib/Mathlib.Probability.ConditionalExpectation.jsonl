{"name":"MeasureTheory.condExp_indep_eq","module":"Mathlib.Probability.ConditionalExpectation","initialProofState":"Î© : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nmâ‚ mâ‚‚ m : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nf : Î© â†’ E\nhleâ‚ : LE.le mâ‚ m\nhleâ‚‚ : LE.le mâ‚‚ m\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hleâ‚‚)\nhf : MeasureTheory.StronglyMeasurable f\nhindp : ProbabilityTheory.Indep mâ‚ mâ‚‚ Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp mâ‚‚ Î¼ f) fun x => MeasureTheory.integral Î¼ fun x => f x","decl":"/-- If `mâ‚, mâ‚‚` are independent Ïƒ-algebras and `f` is `mâ‚`-measurable, then `ð”¼[f | mâ‚‚] = ð”¼[f]`\nalmost everywhere. -/\ntheorem condExp_indep_eq (hleâ‚ : mâ‚ â‰¤ m) (hleâ‚‚ : mâ‚‚ â‰¤ m) [SigmaFinite (Î¼.trim hleâ‚‚)]\n    (hf : StronglyMeasurable[mâ‚] f) (hindp : Indep mâ‚ mâ‚‚ Î¼) : Î¼[f|mâ‚‚] =áµ[Î¼] fun _ => Î¼[f] := by\n  by_cases hfint : Integrable f Î¼\n  swap; Â· rw [condExp_of_not_integrable hfint, integral_undef hfint]; rfl\n  refine (ae_eq_condExp_of_forall_setIntegral_eq hleâ‚‚ hfint\n    (fun s _ hs => integrableOn_const.2 (Or.inr hs)) (fun s hms hs => ?_)\n      stronglyMeasurable_const.aestronglyMeasurable).symm\n  rw [setIntegral_const]\n  rw [â† memâ„’p_one_iff_integrable] at hfint\n  refine Memâ„’p.induction_stronglyMeasurable hleâ‚ ENNReal.one_ne_top _ ?_ ?_ ?_ ?_ hfint ?_\n  Â· exact âŸ¨f, hf, EventuallyEq.rflâŸ©\n  Â· intro c t hmt _\n    rw [Indep_iff] at hindp\n    rw [integral_indicator (hleâ‚ _ hmt), setIntegral_const, smul_smul, â† ENNReal.toReal_mul,\n      mul_comm, â† hindp _ _ hmt hms, setIntegral_indicator (hleâ‚ _ hmt), setIntegral_const,\n      Set.inter_comm]\n  Â· intro u v _ huint hvint hu hv hu_eq hv_eq\n    rw [memâ„’p_one_iff_integrable] at huint hvint\n    rw [integral_add' huint hvint, smul_add, hu_eq, hv_eq,\n      integral_add' huint.integrableOn hvint.integrableOn]\n  Â· have heqâ‚ : (fun f : lpMeas E â„ mâ‚ 1 Î¼ => âˆ« x, (f : Î© â†’ E) x âˆ‚Î¼) =\n        (fun f : Lp E 1 Î¼ => âˆ« x, f x âˆ‚Î¼) âˆ˜ Submodule.subtypeL _ := by\n      refine funext fun f => integral_congr_ae ?_\n      simp_rw [Submodule.coe_subtypeL', Submodule.coe_subtype]; norm_cast\n    have heqâ‚‚ : (fun f : lpMeas E â„ mâ‚ 1 Î¼ => âˆ« x in s, (f : Î© â†’ E) x âˆ‚Î¼) =\n        (fun f : Lp E 1 Î¼ => âˆ« x in s, f x âˆ‚Î¼) âˆ˜ Submodule.subtypeL _ := by\n      refine funext fun f => integral_congr_ae (ae_restrict_of_ae ?_)\n      simp_rw [Submodule.coe_subtypeL', Submodule.coe_subtype]\n      exact Eventually.of_forall fun _ => (by trivial)\n    refine isClosed_eq (Continuous.const_smul ?_ _) ?_\n    Â· rw [heqâ‚]\n      exact continuous_integral.comp (ContinuousLinearMap.continuous _)\n    Â· rw [heqâ‚‚]\n      exact (continuous_setIntegral _).comp (ContinuousLinearMap.continuous _)\n  Â· intro u v huv _ hueq\n    rwa [â† integral_congr_ae huv, â†\n      (setIntegral_congr_ae (hleâ‚‚ _ hms) _ : âˆ« x in s, u x âˆ‚Î¼ = âˆ« x in s, v x âˆ‚Î¼)]\n    filter_upwards [huv] with x hx _ using hx\n\n"}
{"name":"MeasureTheory.condexp_indep_eq","module":"Mathlib.Probability.ConditionalExpectation","initialProofState":"Î© : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nmâ‚ mâ‚‚ m : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nf : Î© â†’ E\nhleâ‚ : LE.le mâ‚ m\nhleâ‚‚ : LE.le mâ‚‚ m\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hleâ‚‚)\nhf : MeasureTheory.StronglyMeasurable f\nhindp : ProbabilityTheory.Indep mâ‚ mâ‚‚ Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (MeasureTheory.condExp mâ‚‚ Î¼ f) fun x => MeasureTheory.integral Î¼ fun x => f x","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_indep_eq := condExp_indep_eq\n\n"}
