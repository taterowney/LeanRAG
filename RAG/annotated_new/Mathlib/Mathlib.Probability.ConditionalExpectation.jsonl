{"name":"MeasureTheory.condExp_indep_eq","module":"Mathlib.Probability.ConditionalExpectation","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nm₁ m₂ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Ω → E\nhle₁ : LE.le m₁ m\nhle₂ : LE.le m₂ m\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hle₂)\nhf : MeasureTheory.StronglyMeasurable f\nhindp : ProbabilityTheory.Indep m₁ m₂ μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m₂ μ f) fun x => MeasureTheory.integral μ fun x => f x","decl":"/-- If `m₁, m₂` are independent σ-algebras and `f` is `m₁`-measurable, then `𝔼[f | m₂] = 𝔼[f]`\nalmost everywhere. -/\ntheorem condExp_indep_eq (hle₁ : m₁ ≤ m) (hle₂ : m₂ ≤ m) [SigmaFinite (μ.trim hle₂)]\n    (hf : StronglyMeasurable[m₁] f) (hindp : Indep m₁ m₂ μ) : μ[f|m₂] =ᵐ[μ] fun _ => μ[f] := by\n  by_cases hfint : Integrable f μ\n  swap; · rw [condExp_of_not_integrable hfint, integral_undef hfint]; rfl\n  refine (ae_eq_condExp_of_forall_setIntegral_eq hle₂ hfint\n    (fun s _ hs => integrableOn_const.2 (Or.inr hs)) (fun s hms hs => ?_)\n      stronglyMeasurable_const.aestronglyMeasurable).symm\n  rw [setIntegral_const]\n  rw [← memℒp_one_iff_integrable] at hfint\n  refine Memℒp.induction_stronglyMeasurable hle₁ ENNReal.one_ne_top _ ?_ ?_ ?_ ?_ hfint ?_\n  · exact ⟨f, hf, EventuallyEq.rfl⟩\n  · intro c t hmt _\n    rw [Indep_iff] at hindp\n    rw [integral_indicator (hle₁ _ hmt), setIntegral_const, smul_smul, ← ENNReal.toReal_mul,\n      mul_comm, ← hindp _ _ hmt hms, setIntegral_indicator (hle₁ _ hmt), setIntegral_const,\n      Set.inter_comm]\n  · intro u v _ huint hvint hu hv hu_eq hv_eq\n    rw [memℒp_one_iff_integrable] at huint hvint\n    rw [integral_add' huint hvint, smul_add, hu_eq, hv_eq,\n      integral_add' huint.integrableOn hvint.integrableOn]\n  · have heq₁ : (fun f : lpMeas E ℝ m₁ 1 μ => ∫ x, (f : Ω → E) x ∂μ) =\n        (fun f : Lp E 1 μ => ∫ x, f x ∂μ) ∘ Submodule.subtypeL _ := by\n      refine funext fun f => integral_congr_ae ?_\n      simp_rw [Submodule.coe_subtypeL', Submodule.coe_subtype]; norm_cast\n    have heq₂ : (fun f : lpMeas E ℝ m₁ 1 μ => ∫ x in s, (f : Ω → E) x ∂μ) =\n        (fun f : Lp E 1 μ => ∫ x in s, f x ∂μ) ∘ Submodule.subtypeL _ := by\n      refine funext fun f => integral_congr_ae (ae_restrict_of_ae ?_)\n      simp_rw [Submodule.coe_subtypeL', Submodule.coe_subtype]\n      exact Eventually.of_forall fun _ => (by trivial)\n    refine isClosed_eq (Continuous.const_smul ?_ _) ?_\n    · rw [heq₁]\n      exact continuous_integral.comp (ContinuousLinearMap.continuous _)\n    · rw [heq₂]\n      exact (continuous_setIntegral _).comp (ContinuousLinearMap.continuous _)\n  · intro u v huv _ hueq\n    rwa [← integral_congr_ae huv, ←\n      (setIntegral_congr_ae (hle₂ _ hms) _ : ∫ x in s, u x ∂μ = ∫ x in s, v x ∂μ)]\n    filter_upwards [huv] with x hx _ using hx\n\n"}
{"name":"MeasureTheory.condexp_indep_eq","module":"Mathlib.Probability.ConditionalExpectation","initialProofState":"Ω : Type u_1\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nm₁ m₂ m : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf : Ω → E\nhle₁ : LE.le m₁ m\nhle₂ : LE.le m₂ m\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hle₂)\nhf : MeasureTheory.StronglyMeasurable f\nhindp : ProbabilityTheory.Indep m₁ m₂ μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp m₂ μ f) fun x => MeasureTheory.integral μ fun x => f x","decl":"@[deprecated (since := \"2025-01-21\")] alias condexp_indep_eq := condExp_indep_eq\n\n"}
