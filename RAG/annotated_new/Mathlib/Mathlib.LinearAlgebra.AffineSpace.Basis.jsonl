{"name":"AffineBasis.tot'","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nself : AffineBasis ι k P\n⊢ Eq (affineSpan k (Set.range self.toFun)) Top.top","decl":"/-- An affine basis is a family of affine-independent points whose span is the top subspace. -/\nstructure AffineBasis (ι : Type u₁) (k : Type u₂) {V : Type u₃} (P : Type u₄) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : ι → P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = ⊤\n\n"}
{"name":"AffineBasis.mk.injEq","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\ntoFun✝ : ι → P\nind'✝ : AffineIndependent k toFun✝\ntot'✝ : Eq (affineSpan k (Set.range toFun✝)) Top.top\ntoFun : ι → P\nind' : AffineIndependent k toFun\ntot' : Eq (affineSpan k (Set.range toFun)) Top.top\n⊢ Eq (Eq { toFun := toFun✝, ind' := ind'✝, tot' := tot'✝ } { toFun := toFun, ind' := ind', tot' := tot' }) (Eq toFun✝ toFun)","decl":"/-- An affine basis is a family of affine-independent points whose span is the top subspace. -/\nstructure AffineBasis (ι : Type u₁) (k : Type u₂) {V : Type u₃} (P : Type u₄) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : ι → P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = ⊤\n\n"}
{"name":"AffineBasis.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : AddTorsor V P\ninst✝⁵ : Ring k\ninst✝⁴ : Module k V\ninst✝³ : SizeOf ι\ninst✝² : SizeOf k\ninst✝¹ : SizeOf V\ninst✝ : SizeOf P\ntoFun : ι → P\nind' : AffineIndependent k toFun\ntot' : Eq (affineSpan k (Set.range toFun)) Top.top\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, ind' := ind', tot' := tot' }) (HAdd.hAdd 1 (SizeOf.sizeOf tot'))","decl":"/-- An affine basis is a family of affine-independent points whose span is the top subspace. -/\nstructure AffineBasis (ι : Type u₁) (k : Type u₂) {V : Type u₃} (P : Type u₄) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : ι → P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = ⊤\n\n"}
{"name":"AffineBasis.mk.inj","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\ntoFun✝ : ι → P\nind'✝ : AffineIndependent k toFun✝\ntot'✝ : Eq (affineSpan k (Set.range toFun✝)) Top.top\ntoFun : ι → P\nind' : AffineIndependent k toFun\ntot' : Eq (affineSpan k (Set.range toFun)) Top.top\nx✝ : Eq { toFun := toFun✝, ind' := ind'✝, tot' := tot'✝ } { toFun := toFun, ind' := ind', tot' := tot' }\n⊢ Eq toFun✝ toFun","decl":"/-- An affine basis is a family of affine-independent points whose span is the top subspace. -/\nstructure AffineBasis (ι : Type u₁) (k : Type u₂) {V : Type u₃} (P : Type u₄) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : ι → P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = ⊤\n\n"}
{"name":"AffineBasis.ind'","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nself : AffineBasis ι k P\n⊢ AffineIndependent k self.toFun","decl":"/-- An affine basis is a family of affine-independent points whose span is the top subspace. -/\nstructure AffineBasis (ι : Type u₁) (k : Type u₂) {V : Type u₃} (P : Type u₄) [AddCommGroup V]\n  [AffineSpace V P] [Ring k] [Module k V] where\n  protected toFun : ι → P\n  protected ind' : AffineIndependent k toFun\n  protected tot' : affineSpan k (range toFun) = ⊤\n\n"}
{"name":"AffineBasis.ext_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb₁ b₂ : AffineBasis ι k P\n⊢ Iff (Eq b₁ b₂) (Eq ⇑b₁ ⇑b₂)","decl":"@[ext]\ntheorem ext {b₁ b₂ : AffineBasis ι k P} (h : (b₁ : ι → P) = b₂) : b₁ = b₂ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"AffineBasis.ext","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb₁ b₂ : AffineBasis ι k P\nh : Eq ⇑b₁ ⇑b₂\n⊢ Eq b₁ b₂","decl":"@[ext]\ntheorem ext {b₁ b₂ : AffineBasis ι k P} (h : (b₁ : ι → P) = b₂) : b₁ = b₂ :=\n  DFunLike.coe_injective h\n\n"}
{"name":"AffineBasis.ind","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\n⊢ AffineIndependent k ⇑b","decl":"theorem ind : AffineIndependent k b :=\n  b.ind'\n\n"}
{"name":"AffineBasis.tot","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\n⊢ Eq (affineSpan k (Set.range ⇑b)) Top.top","decl":"theorem tot : affineSpan k (range b) = ⊤ :=\n  b.tot'\n\n"}
{"name":"AffineBasis.nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\n⊢ Nonempty ι","decl":"include b in\nprotected theorem nonempty : Nonempty ι :=\n  not_isEmpty_iff.mp fun hι => by\n    simpa only [@range_eq_empty _ _ hι, AffineSubspace.span_empty, bot_ne_top] using b.tot\n\n"}
{"name":"AffineBasis.coe_reindex","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ne : Equiv ι ι'\n⊢ Eq (⇑(b.reindex e)) (Function.comp ⇑b ⇑e.symm)","decl":"@[simp, norm_cast]\ntheorem coe_reindex : ⇑(b.reindex e) = b ∘ e.symm :=\n  rfl\n\n"}
{"name":"AffineBasis.reindex_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ne : Equiv ι ι'\ni' : ι'\n⊢ Eq ((b.reindex e) i') (b (e.symm i'))","decl":"@[simp]\ntheorem reindex_apply (i' : ι') : b.reindex e i' = b (e.symm i') :=\n  rfl\n\n"}
{"name":"AffineBasis.reindex_refl","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\n⊢ Eq (b.reindex (Equiv.refl ι)) b","decl":"@[simp]\ntheorem reindex_refl : b.reindex (Equiv.refl _) = b :=\n  ext rfl\n\n"}
{"name":"AffineBasis.basisOf_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ni : ι\nj : Subtype fun j => Ne j i\n⊢ Eq ((b.basisOf i) j) (VSub.vsub (b ↑j) (b i))","decl":"@[simp]\ntheorem basisOf_apply (i : ι) (j : { j : ι // j ≠ i }) : b.basisOf i j = b ↑j -ᵥ b i := by\n  simp [basisOf]\n\n"}
{"name":"AffineBasis.basisOf_reindex","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ne : Equiv ι ι'\ni : ι'\n⊢ Eq ((b.reindex e).basisOf i) ((b.basisOf (e.symm i)).reindex (e.subtypeEquiv ⋯))","decl":"@[simp]\ntheorem basisOf_reindex (i : ι') :\n    (b.reindex e).basisOf i =\n      (b.basisOf <| e.symm i).reindex (e.subtypeEquiv fun _ => e.eq_symm_apply.not) := by\n  ext j\n  simp\n\n"}
{"name":"AffineBasis.linear_eq_sumCoords","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ni : ι\n⊢ Eq (b.coord i).linear (Neg.neg (b.basisOf i).sumCoords)","decl":"@[simp]\ntheorem linear_eq_sumCoords (i : ι) : (b.coord i).linear = -(b.basisOf i).sumCoords :=\n  rfl\n\n"}
{"name":"AffineBasis.coord_reindex","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ne : Equiv ι ι'\ni : ι'\n⊢ Eq ((b.reindex e).coord i) (b.coord (e.symm i))","decl":"@[simp]\ntheorem coord_reindex (i : ι') : (b.reindex e).coord i = b.coord (e.symm i) := by\n  ext\n  classical simp [AffineBasis.coord]\n\n"}
{"name":"AffineBasis.coord_apply_eq","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ni : ι\n⊢ Eq ((b.coord i) (b i)) 1","decl":"@[simp]\ntheorem coord_apply_eq (i : ι) : b.coord i (b i) = 1 := by\n  simp only [coord, Basis.coe_sumCoords, LinearEquiv.map_zero, LinearEquiv.coe_coe, sub_zero,\n    AffineMap.coe_mk, Finsupp.sum_zero_index, vsub_self]\n\n"}
{"name":"AffineBasis.coord_apply_ne","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ni j : ι\nh : Ne i j\n⊢ Eq ((b.coord i) (b j)) 0","decl":"@[simp]\ntheorem coord_apply_ne (h : i ≠ j) : b.coord i (b j) = 0 := by\n  -- Porting note:\n  -- in mathlib3 we didn't need to given the `fun j => j ≠ i` argument to `Subtype.coe_mk`,\n  -- but I don't think we can complain: this proof was over-golfed.\n  rw [coord, AffineMap.coe_mk, ← @Subtype.coe_mk _ (fun j => j ≠ i) j h.symm, ← b.basisOf_apply,\n    Basis.sumCoords_self_apply, sub_self]\n\n"}
{"name":"AffineBasis.coord_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : DecidableEq ι\ni j : ι\n⊢ Eq ((b.coord i) (b j)) (ite (Eq i j) 1 0)","decl":"theorem coord_apply [DecidableEq ι] (i j : ι) : b.coord i (b j) = if i = j then 1 else 0 := by\n  rcases eq_or_ne i j with h | h <;> simp [h]\n\n"}
{"name":"AffineBasis.coord_apply_combination_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ns : Finset ι\ni : ι\nhi : Membership.mem s i\nw : ι → k\nhw : Eq (s.sum w) 1\n⊢ Eq ((b.coord i) ((Finset.affineCombination k s ⇑b) w)) (w i)","decl":"@[simp]\ntheorem coord_apply_combination_of_mem (hi : i ∈ s) {w : ι → k} (hw : s.sum w = 1) :\n    b.coord i (s.affineCombination k b w) = w i := by\n  classical simp only [coord_apply, hi, Finset.affineCombination_eq_linear_combination, if_true,\n      mul_boole, hw, Function.comp_apply, smul_eq_mul, s.sum_ite_eq,\n      s.map_affineCombination b w hw]\n\n"}
{"name":"AffineBasis.coord_apply_combination_of_not_mem","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\nw : ι → k\nhw : Eq (s.sum w) 1\n⊢ Eq ((b.coord i) ((Finset.affineCombination k s ⇑b) w)) 0","decl":"@[simp]\ntheorem coord_apply_combination_of_not_mem (hi : i ∉ s) {w : ι → k} (hw : s.sum w = 1) :\n    b.coord i (s.affineCombination k b w) = 0 := by\n  classical simp only [coord_apply, hi, Finset.affineCombination_eq_linear_combination, if_false,\n      mul_boole, hw, Function.comp_apply, smul_eq_mul, s.sum_ite_eq,\n      s.map_affineCombination b w hw]\n\n"}
{"name":"AffineBasis.sum_coord_apply_eq_one","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Fintype ι\nq : P\n⊢ Eq (Finset.univ.sum fun i => (b.coord i) q) 1","decl":"@[simp]\ntheorem sum_coord_apply_eq_one [Fintype ι] (q : P) : ∑ i, b.coord i q = 1 := by\n  have hq : q ∈ affineSpan k (range b) := by\n    rw [b.tot]\n    exact AffineSubspace.mem_top k V q\n  obtain ⟨w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan_of_fintype hq\n  convert hw\n  exact b.coord_apply_combination_of_mem (Finset.mem_univ _) hw\n\n"}
{"name":"AffineBasis.affineCombination_coord_eq_self","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Fintype ι\nq : P\n⊢ Eq ((Finset.affineCombination k Finset.univ ⇑b) fun i => (b.coord i) q) q","decl":"@[simp]\ntheorem affineCombination_coord_eq_self [Fintype ι] (q : P) :\n    (Finset.univ.affineCombination k b fun i => b.coord i q) = q := by\n  have hq : q ∈ affineSpan k (range b) := by\n    rw [b.tot]\n    exact AffineSubspace.mem_top k V q\n  obtain ⟨w, hw, rfl⟩ := eq_affineCombination_of_mem_affineSpan_of_fintype hq\n  congr\n  ext i\n  exact b.coord_apply_combination_of_mem (Finset.mem_univ i) hw\n\n"}
{"name":"AffineBasis.linear_combination_coord_eq_self","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\ninst✝³ : AddCommGroup V\ninst✝² : Ring k\ninst✝¹ : Module k V\ninst✝ : Fintype ι\nb : AffineBasis ι k V\nv : V\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul ((b.coord i) v) (b i)) v","decl":"/-- A variant of `AffineBasis.affineCombination_coord_eq_self` for the special case when the\naffine space is a module so we can talk about linear combinations. -/\n@[simp]\ntheorem linear_combination_coord_eq_self [Fintype ι] (b : AffineBasis ι k V) (v : V) :\n    ∑ i, b.coord i v • b i = v := by\n  have hb := b.affineCombination_coord_eq_self v\n  rwa [Finset.univ.affineCombination_eq_linear_combination _ _ (b.sum_coord_apply_eq_one v)] at hb\n\n"}
{"name":"AffineBasis.ext_elem","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Finite ι\nq₁ q₂ : P\nh : ∀ (i : ι), Eq ((b.coord i) q₁) ((b.coord i) q₂)\n⊢ Eq q₁ q₂","decl":"theorem ext_elem [Finite ι] {q₁ q₂ : P} (h : ∀ i, b.coord i q₁ = b.coord i q₂) : q₁ = q₂ := by\n  cases nonempty_fintype ι\n  rw [← b.affineCombination_coord_eq_self q₁, ← b.affineCombination_coord_eq_self q₂]\n  simp only [h]\n\n"}
{"name":"AffineBasis.coe_coord_of_subsingleton_eq_one","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Subsingleton ι\ni : ι\n⊢ Eq (⇑(b.coord i)) 1","decl":"@[simp]\ntheorem coe_coord_of_subsingleton_eq_one [Subsingleton ι] (i : ι) : (b.coord i : P → k) = 1 := by\n  ext q\n  have hp : (range b).Subsingleton := by\n    rw [← image_univ]\n    apply Subsingleton.image\n    apply subsingleton_of_subsingleton\n  haveI := AffineSubspace.subsingleton_of_subsingleton_span_eq_top hp b.tot\n  let s : Finset ι := {i}\n  have hi : i ∈ s := by simp [s]\n  have hw : s.sum (Function.const ι (1 : k)) = 1 := by simp [s]\n  have hq : q = s.affineCombination k b (Function.const ι (1 : k)) := by\n    simp [eq_iff_true_of_subsingleton]\n  rw [Pi.one_apply, hq, b.coord_apply_combination_of_mem hi hw, Function.const_apply]\n\n"}
{"name":"AffineBasis.surjective_coord","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Nontrivial ι\ni : ι\n⊢ Function.Surjective ⇑(b.coord i)","decl":"theorem surjective_coord [Nontrivial ι] (i : ι) : Function.Surjective <| b.coord i := by\n  classical\n    intro x\n    obtain ⟨j, hij⟩ := exists_ne i\n    let s : Finset ι := {i, j}\n    have hi : i ∈ s := by simp [s]\n    let w : ι → k := fun j' => if j' = i then x else 1 - x\n    have hw : s.sum w = 1 := by simp [s, w, Finset.sum_ite, Finset.filter_insert, hij,\n      Finset.filter_true_of_mem, Finset.filter_false_of_mem]\n    use s.affineCombination k b w\n    simp [w, b.coord_apply_combination_of_mem hi hw]\n\n"}
{"name":"AffineBasis.coords_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\nq : P\ni : ι\n⊢ Eq (b.coords q i) ((b.coord i) q)","decl":"@[simp]\ntheorem coords_apply (q : P) (i : ι) : b.coords q i = b.coord i q :=\n  rfl\n\n"}
{"name":"AffineBasis.coe_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nv : V\nb : AffineBasis ι k P\n⊢ Eq (⇑(HVAdd.hVAdd v b)) (HVAdd.hVAdd v ⇑b)","decl":"@[simp, norm_cast] lemma coe_vadd (v : V) (b : AffineBasis ι k P) : ⇑(v +ᵥ b) = v +ᵥ ⇑b := rfl\n\n"}
{"name":"AffineBasis.basisOf_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nv : V\nb : AffineBasis ι k P\n⊢ Eq (HVAdd.hVAdd v b).basisOf b.basisOf","decl":"@[simp] lemma basisOf_vadd (v : V) (b : AffineBasis ι k P) : (v +ᵥ b).basisOf = b.basisOf := by\n  ext\n  simp\n\n"}
{"name":"AffineBasis.coord_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\ni : ι\nv : V\nb : AffineBasis ι k P\n⊢ Eq ((HVAdd.hVAdd v b).coord i) ((b.coord i).comp ↑(AffineEquiv.constVAdd k P v).symm)","decl":"@[simp] lemma coord_vadd (v : V) (b : AffineBasis ι k P) :\n    (v +ᵥ b).coord i = (b.coord i).comp (AffineEquiv.constVAdd k P v).symm := by\n  ext p\n  simp only [coord, ne_eq, basisOf_vadd, coe_vadd, Pi.vadd_apply, Basis.coe_sumCoords,\n    AffineMap.coe_mk, AffineEquiv.constVAdd_symm, AffineMap.coe_comp, AffineEquiv.coe_toAffineMap,\n    Function.comp_apply, AffineEquiv.constVAdd_apply, sub_right_inj]\n  congr! 1\n  rw [vadd_vsub_assoc, neg_add_eq_sub, vsub_vadd_eq_vsub_sub]\n\n"}
{"name":"AffineBasis.coe_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nG : Type u_3\nk : Type u_5\nV : Type u_6\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Ring k\ninst✝³ : Module k V\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\na : G\nb : AffineBasis ι k V\n⊢ Eq (⇑(HSMul.hSMul a b)) (HSMul.hSMul a ⇑b)","decl":"@[simp, norm_cast] lemma coe_smul (a : G) (b : AffineBasis ι k V) : ⇑(a • b) = a • ⇑b := rfl\n\n"}
{"name":"AffineBasis.instSMulCommClass","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nG : Type u_3\nG' : Type u_4\nk : Type u_5\nV : Type u_6\ninst✝⁹ : AddCommGroup V\ninst✝⁸ : Ring k\ninst✝⁷ : Module k V\ninst✝⁶ : Group G\ninst✝⁵ : Group G'\ninst✝⁴ : DistribMulAction G V\ninst✝³ : DistribMulAction G' V\ninst✝² : SMulCommClass G k V\ninst✝¹ : SMulCommClass G' k V\ninst✝ : SMulCommClass G G' V\n⊢ SMulCommClass G G' (AffineBasis ι k V)","decl":"/-- TODO: generalize to include `SMul (P ≃ᵃ[k] P) (AffineBasis ι k P)`, which acts on `P` with a\n`VAdd` version of a `DistribMulAction`. -/\ninstance [SMulCommClass G G' V] : SMulCommClass G G' (AffineBasis ι k V) where\n  smul_comm _g _g' _b := DFunLike.ext _ _ fun _ => smul_comm _ _ _\n\n"}
{"name":"AffineBasis.instIsScalarTower","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nG : Type u_3\nG' : Type u_4\nk : Type u_5\nV : Type u_6\ninst✝¹⁰ : AddCommGroup V\ninst✝⁹ : Ring k\ninst✝⁸ : Module k V\ninst✝⁷ : Group G\ninst✝⁶ : Group G'\ninst✝⁵ : DistribMulAction G V\ninst✝⁴ : DistribMulAction G' V\ninst✝³ : SMulCommClass G k V\ninst✝² : SMulCommClass G' k V\ninst✝¹ : SMul G G'\ninst✝ : IsScalarTower G G' V\n⊢ IsScalarTower G G' (AffineBasis ι k V)","decl":"/-- TODO: generalize to include `SMul (P ≃ᵃ[k] P) (AffineBasis ι k P)`, which acts on `P` with a\n`VAdd` version of a `DistribMulAction`. -/\ninstance [SMul G G'] [IsScalarTower G G' V] : IsScalarTower G G' (AffineBasis ι k V) where\n  smul_assoc _g _g' _b := DFunLike.ext _ _ fun _ => smul_assoc _ _ _\n\n"}
{"name":"AffineBasis.basisOf_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nG : Type u_3\nk : Type u_5\nV : Type u_6\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Ring k\ninst✝³ : Module k V\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\na : G\nb : AffineBasis ι k V\ni : ι\n⊢ Eq ((HSMul.hSMul a b).basisOf i) (HSMul.hSMul a (b.basisOf i))","decl":"@[simp] lemma basisOf_smul (a : G) (b : AffineBasis ι k V) (i : ι) :\n    (a • b).basisOf i = a • b.basisOf i := by ext j; simp [smul_sub]\n\n"}
{"name":"AffineBasis.reindex_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nι' : Type u_2\nG : Type u_3\nk : Type u_5\nV : Type u_6\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Ring k\ninst✝³ : Module k V\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\na : G\nb : AffineBasis ι k V\ne : Equiv ι ι'\n⊢ Eq ((HSMul.hSMul a b).reindex e) (HSMul.hSMul a (b.reindex e))","decl":"@[simp] lemma reindex_smul (a : G) (b : AffineBasis ι k V) (e : ι ≃ ι') :\n    (a • b).reindex e = a • b.reindex e :=\n  rfl\n\n"}
{"name":"AffineBasis.coord_smul","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nG : Type u_3\nk : Type u_5\nV : Type u_6\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Ring k\ninst✝³ : Module k V\ninst✝² : Group G\ninst✝¹ : DistribMulAction G V\ninst✝ : SMulCommClass G k V\na : G\nb : AffineBasis ι k V\ni : ι\n⊢ Eq ((HSMul.hSMul a b).coord i) ((b.coord i).comp (↑(DistribMulAction.toLinearEquiv k V a).symm).toAffineMap)","decl":"@[simp] lemma coord_smul (a : G) (b : AffineBasis ι k V) (i : ι) :\n    (a • b).coord i = (b.coord i).comp (DistribMulAction.toLinearEquiv _ _ a).symm.toAffineMap := by\n  ext v; simp [map_sub, coord]\n\n"}
{"name":"AffineBasis.coord_apply_centroid","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"ι : Type u_1\nk : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : DivisionRing k\ninst✝¹ : Module k V\ninst✝ : CharZero k\nb : AffineBasis ι k P\ns : Finset ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq ((b.coord i) (Finset.centroid k s ⇑b)) (Inv.inv ↑s.card)","decl":"@[simp]\ntheorem coord_apply_centroid [CharZero k] (b : AffineBasis ι k P) {s : Finset ι} {i : ι}\n    (hi : i ∈ s) : b.coord i (s.centroid k b) = (s.card : k)⁻¹ := by\n  rw [Finset.centroid,\n    b.coord_apply_combination_of_mem hi (s.sum_centroidWeights_eq_one_of_nonempty _ ⟨i, hi⟩),\n    Finset.centroidWeights, Function.const_apply]\n\n"}
{"name":"AffineBasis.exists_affine_subbasis","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"k : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : DivisionRing k\ninst✝ : Module k V\nt : Set P\nht : Eq (affineSpan k t) Top.top\n⊢ Exists fun s => And (HasSubset.Subset s t) (Exists fun b => Eq (⇑b) Subtype.val)","decl":"theorem exists_affine_subbasis {t : Set P} (ht : affineSpan k t = ⊤) :\n    ∃ s ⊆ t, ∃ b : AffineBasis s k P, ⇑b = ((↑) : s → P) := by\n  obtain ⟨s, hst, h_tot, h_ind⟩ := exists_affineIndependent k V t\n  refine ⟨s, hst, ⟨(↑), h_ind, ?_⟩, rfl⟩\n  rw [Subtype.range_coe, h_tot, ht]\n\n"}
{"name":"AffineBasis.exists_affineBasis","module":"Mathlib.LinearAlgebra.AffineSpace.Basis","initialProofState":"k : Type u_5\nV : Type u_6\nP : Type u_7\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : DivisionRing k\ninst✝ : Module k V\n⊢ Exists fun s => Exists fun b => Eq (⇑b) Subtype.val","decl":"theorem exists_affineBasis : ∃ (s : Set P) (b : AffineBasis (↥s) k P), ⇑b = ((↑) : s → P) :=\n  let ⟨s, _, hs⟩ := exists_affine_subbasis (AffineSubspace.span_univ k V P)\n  ⟨s, hs⟩\n\n"}
