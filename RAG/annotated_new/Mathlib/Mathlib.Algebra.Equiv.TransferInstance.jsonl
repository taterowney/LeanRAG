{"name":"Equiv.one_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : One β\n⊢ Eq 1 (e.symm 1)","decl":"@[to_additive]\ntheorem one_def [One β] :\n    letI := e.one\n    1 = e.symm 1 :=\n  rfl\n\n"}
{"name":"Equiv.zero_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Zero β\n⊢ Eq 0 (e.symm 0)","decl":"@[to_additive]\ntheorem one_def [One β] :\n    letI := e.one\n    1 = e.symm 1 :=\n  rfl\n\n"}
{"name":"Equiv.add_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Add β\nx y : α\n⊢ Eq (HAdd.hAdd x y) (e.symm (HAdd.hAdd (e x) (e y)))","decl":"@[to_additive]\ntheorem mul_def [Mul β] (x y : α) :\n    letI := Equiv.mul e\n    x * y = e.symm (e x * e y) :=\n  rfl\n\n"}
{"name":"Equiv.mul_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Mul β\nx y : α\n⊢ Eq (HMul.hMul x y) (e.symm (HMul.hMul (e x) (e y)))","decl":"@[to_additive]\ntheorem mul_def [Mul β] (x y : α) :\n    letI := Equiv.mul e\n    x * y = e.symm (e x * e y) :=\n  rfl\n\n"}
{"name":"Equiv.div_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Div β\nx y : α\n⊢ Eq (HDiv.hDiv x y) (e.symm (HDiv.hDiv (e x) (e y)))","decl":"@[to_additive]\ntheorem div_def [Div β] (x y : α) :\n    letI := Equiv.div e\n    x / y = e.symm (e x / e y) :=\n  rfl\n\n"}
{"name":"Equiv.sub_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Sub β\nx y : α\n⊢ Eq (HSub.hSub x y) (e.symm (HSub.hSub (e x) (e y)))","decl":"@[to_additive]\ntheorem div_def [Div β] (x y : α) :\n    letI := Equiv.div e\n    x / y = e.symm (e x / e y) :=\n  rfl\n\n"}
{"name":"Equiv.inv_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Inv β\nx : α\n⊢ Eq (Inv.inv x) (e.symm (Inv.inv (e x)))","decl":"@[to_additive]\ntheorem inv_def [Inv β] (x : α) :\n    letI := Equiv.Inv e\n    x⁻¹ = e.symm (e x)⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.neg_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Neg β\nx : α\n⊢ Eq (Neg.neg x) (e.symm (Neg.neg (e x)))","decl":"@[to_additive]\ntheorem inv_def [Inv β] (x : α) :\n    letI := Equiv.Inv e\n    x⁻¹ = e.symm (e x)⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.smul_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\nR : Type u_1\ninst✝ : SMul R β\nr : R\nx : α\n⊢ Eq (HSMul.hSMul r x) (e.symm (HSMul.hSMul r (e x)))","decl":"theorem smul_def {R : Type*} [SMul R β] (r : R) (x : α) :\n    letI := e.smul R\n    r • x = e.symm (r • e x) :=\n  rfl\n\n"}
{"name":"Equiv.pow_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\nN : Type u_1\ninst✝ : Pow β N\nn : N\nx : α\n⊢ Eq (HPow.hPow x n) (e.symm (HPow.hPow (e x) n))","decl":"theorem pow_def {N : Type*} [Pow β N] (n : N) (x : α) :\n    letI := e.pow N\n    x ^ n = e.symm (e x ^ n) :=\n  rfl\n\n"}
{"name":"Equiv.mulEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Mul β\na : α\n⊢ Eq (e.mulEquiv a) (e a)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquiv_apply (e : α ≃ β) [Mul β] (a : α) : (mulEquiv e) a = e a :=\n  rfl\n\n"}
{"name":"Equiv.addEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Add β\na : α\n⊢ Eq (e.addEquiv a) (e a)","decl":"@[to_additive (attr := simp)]\ntheorem mulEquiv_apply (e : α ≃ β) [Mul β] (a : α) : (mulEquiv e) a = e a :=\n  rfl\n\n"}
{"name":"Equiv.addEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Add β\nb : β\n⊢ Eq ((AddEquiv.symm e.addEquiv) b) (e.symm b)","decl":"@[to_additive]\ntheorem mulEquiv_symm_apply (e : α ≃ β) [Mul β] (b : β) :\n    letI := Equiv.mul e\n    (mulEquiv e).symm b = e.symm b :=\n  rfl\n\n"}
{"name":"Equiv.mulEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Mul β\nb : β\n⊢ Eq ((MulEquiv.symm e.mulEquiv) b) (e.symm b)","decl":"@[to_additive]\ntheorem mulEquiv_symm_apply (e : α ≃ β) [Mul β] (b : β) :\n    letI := Equiv.mul e\n    (mulEquiv e).symm b = e.symm b :=\n  rfl\n\n"}
{"name":"Equiv.ringEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝¹ : Add β\ninst✝ : Mul β\na : α\n⊢ Eq (e.ringEquiv a) (e a)","decl":"@[simp]\ntheorem ringEquiv_apply (e : α ≃ β) [Add β] [Mul β] (a : α) : (ringEquiv e) a = e a :=\n  rfl\n\n"}
{"name":"Equiv.ringEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝¹ : Add β\ninst✝ : Mul β\nb : β\n⊢ Eq ((RingEquiv.symm e.ringEquiv) b) (e.symm b)","decl":"theorem ringEquiv_symm_apply (e : α ≃ β) [Add β] [Mul β] (b : β) : by\n    letI := Equiv.add e\n    letI := Equiv.mul e\n    exact (ringEquiv e).symm b = e.symm b := rfl\n\n"}
{"name":"Equiv.nontrivial","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\ninst✝ : Nontrivial β\n⊢ Nontrivial α","decl":"include e in\n/-- Transfer `Nontrivial` across an `Equiv` -/\nprotected theorem nontrivial [Nontrivial β] : Nontrivial α :=\n  e.surjective.nontrivial\n\n"}
{"name":"Equiv.instNontrivialShrink","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\ninst✝¹ : Small.{v, u} α\ninst✝ : Nontrivial α\n⊢ Nontrivial (Shrink.{v, u} α)","decl":"noncomputable instance [Small.{v} α] [Nontrivial α] : Nontrivial (Shrink.{v} α) :=\n  (equivShrink α).symm.nontrivial\n\n"}
{"name":"Equiv.isDomain","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\ninst✝² : Semiring α\ninst✝¹ : Semiring β\ninst✝ : IsDomain β\ne : RingEquiv α β\n⊢ IsDomain α","decl":"/-- Transfer `IsDomain` across an `Equiv` -/\nprotected theorem isDomain [Semiring α] [Semiring β] [IsDomain β] (e : α ≃+* β) : IsDomain α :=\n  Function.Injective.isDomain e.toRingHom e.injective\n\n"}
{"name":"Equiv.instIsDomainShrink","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\ninst✝² : Small.{v, u} α\ninst✝¹ : Semiring α\ninst✝ : IsDomain α\n⊢ IsDomain (Shrink.{v, u} α)","decl":"noncomputable instance [Small.{v} α] [Semiring α] [IsDomain α] : IsDomain (Shrink.{v} α) :=\n  Equiv.isDomain (Shrink.ringEquiv α)\n\n"}
{"name":"Shrink.linearEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nR : Type u_1\ninst✝³ : Semiring R\ninst✝² : Small.{v, u} α\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\na✝ : α\n⊢ Eq ((Shrink.linearEquiv α R).symm a✝) ((AddEquiv.symm (equivShrink α).symm.addEquiv) a✝)","decl":"variable (α) in\n/-- Shrink `α` to a smaller universe preserves module structure. -/\n@[simps!]\nnoncomputable def _root_.Shrink.linearEquiv [Small.{v} α] [AddCommMonoid α] [Module R α] :\n    Shrink.{v} α ≃ₗ[R] α :=\n  Equiv.linearEquiv _ (equivShrink α).symm\n\n"}
{"name":"Shrink.linearEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nR : Type u_1\ninst✝³ : Semiring R\ninst✝² : Small.{v, u} α\ninst✝¹ : AddCommMonoid α\ninst✝ : Module R α\na✝ : Shrink.{v, u} α\n⊢ Eq ((Shrink.linearEquiv α R) a✝) ((equivShrink α).symm a✝)","decl":"variable (α) in\n/-- Shrink `α` to a smaller universe preserves module structure. -/\n@[simps!]\nnoncomputable def _root_.Shrink.linearEquiv [Small.{v} α] [AddCommMonoid α] [Module R α] :\n    Shrink.{v} α ≃ₗ[R] α :=\n  Equiv.linearEquiv _ (equivShrink α).symm\n\n"}
{"name":"Equiv.algebraMap_def","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\nR : Type u_1\ninst✝² : CommSemiring R\ne : Equiv α β\ninst✝¹ : Semiring β\ninst✝ : Algebra R β\nr : R\n⊢ Eq ((algebraMap R α) r) (e.symm ((algebraMap R β) r))","decl":"lemma algebraMap_def (e : α ≃ β) [Semiring β] [Algebra R β] (r : R) :\n    (@algebraMap R α _ (Equiv.semiring e) (Equiv.algebra R e)) r = e.symm ((algebraMap R β) r) := by\n  let _ := Equiv.semiring e\n  let _ := Equiv.algebra R e\n  simp only [Algebra.algebraMap_eq_smul_one]\n  show e.symm (r • e 1) = e.symm (r • 1)\n  simp only [Equiv.one_def, apply_symm_apply]\n\n"}
{"name":"Equiv.algEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\nR : Type u_1\ninst✝² : CommSemiring R\ne : Equiv α β\ninst✝¹ : Semiring β\ninst✝ : Algebra R β\na : α\n⊢ Eq ((Equiv.algEquiv R e) a) (e a)","decl":"@[simp]\ntheorem algEquiv_apply (e : α ≃ β) [Semiring β] [Algebra R β] (a : α) : (algEquiv R e) a = e a :=\n  rfl\n\n"}
{"name":"Equiv.algEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\nR : Type u_1\ninst✝² : CommSemiring R\ne : Equiv α β\ninst✝¹ : Semiring β\ninst✝ : Algebra R β\nb : β\n⊢ Eq ((AlgEquiv.symm (Equiv.algEquiv R e)) b) (e.symm b)","decl":"theorem algEquiv_symm_apply (e : α ≃ β) [Semiring β] [Algebra R β] (b : β) : by\n    letI := Equiv.semiring e\n    letI := Equiv.algebra R e\n    exact (algEquiv R e).symm b = e.symm b := rfl\n\n"}
{"name":"Shrink.algEquiv_symm_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nR : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : Small.{v, u} α\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\na✝ : α\n⊢ Eq ((Shrink.algEquiv α R).symm a✝) ((equivShrink α) a✝)","decl":"variable (α) in\n/-- Shrink `α` to a smaller universe preserves algebra structure. -/\n@[simps!]\nnoncomputable def _root_.Shrink.algEquiv [Small.{v} α] [Semiring α] [Algebra R α] :\n    Shrink.{v} α ≃ₐ[R] α :=\n  Equiv.algEquiv _ (equivShrink α).symm\n\n"}
{"name":"Shrink.algEquiv_apply","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nR : Type u_1\ninst✝³ : CommSemiring R\ninst✝² : Small.{v, u} α\ninst✝¹ : Semiring α\ninst✝ : Algebra R α\na✝ : Shrink.{v, u} α\n⊢ Eq ((Shrink.algEquiv α R) a✝) ((equivShrink α).symm a✝)","decl":"variable (α) in\n/-- Shrink `α` to a smaller universe preserves algebra structure. -/\n@[simps!]\nnoncomputable def _root_.Shrink.algEquiv [Small.{v} α] [Semiring α] [Algebra R α] :\n    Shrink.{v} α ≃ₐ[R] α :=\n  Equiv.algEquiv _ (equivShrink α).symm\n\n"}
{"name":"Finite.exists_type_univ_nonempty_mulEquiv","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"G : Type u\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ Exists fun G' => Exists fun x => Exists fun x_1 => Nonempty (MulEquiv G G')","decl":"/-- Any finite group in universe `u` is equivalent to some finite group in universe `v`. -/\nlemma exists_type_univ_nonempty_mulEquiv (G : Type u) [Group G] [Finite G] :\n    ∃ (G' : Type v) (_ : Group G') (_ : Fintype G'), Nonempty (G ≃* G') := by\n  obtain ⟨n, ⟨e⟩⟩ := Finite.exists_equiv_fin G\n  let f : Fin n ≃ ULift (Fin n) := Equiv.ulift.symm\n  let e : G ≃ ULift (Fin n) := e.trans f\n  letI groupH : Group (ULift (Fin n)) := e.symm.group\n  exact ⟨ULift (Fin n), groupH, inferInstance, ⟨MulEquiv.symm <| e.symm.mulEquiv⟩⟩\n\n"}
{"name":"LinearEquiv.isScalarTower","module":"Mathlib.Algebra.Equiv.TransferInstance","initialProofState":"α : Type u\nβ : Type v\nR : Type u_1\ninst✝⁸ : CommSemiring R\nA : Type u_2\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : AddCommMonoid β\ninst✝³ : Module A β\ninst✝² : Module R α\ninst✝¹ : Module R β\ninst✝ : IsScalarTower R A β\ne : LinearEquiv (RingHom.id R) α β\n⊢ IsScalarTower R A α","decl":"/-- The module instance from `AddEquiv.module` is compatible with the `R`-module structures,\nif the `AddEquiv` is induced by an `R`-module isomorphism. -/\nlemma LinearEquiv.isScalarTower [Module R α] [Module R β] [IsScalarTower R A β]\n    (e : α ≃ₗ[R] β) :\n    letI := e.toAddEquiv.module A\n    IsScalarTower R A α := by\n  letI := e.toAddEquiv.module A\n  constructor\n  intro x y z\n  simp only [Equiv.smul_def, AddEquiv.toEquiv_eq_coe, smul_assoc]\n  apply e.symm.map_smul\n\n"}
