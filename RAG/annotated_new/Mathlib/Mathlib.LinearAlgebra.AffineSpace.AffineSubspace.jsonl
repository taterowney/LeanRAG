{"name":"vectorSpan_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (vectorSpan k s) (Submodule.span k (VSub.vsub s s))","decl":"/-- The definition of `vectorSpan`, for rewriting. -/\ntheorem vectorSpan_def (s : Set P) : vectorSpan k s = Submodule.span k (s -ᵥ s) :=\n  rfl\n\n"}
{"name":"vectorSpan_mono","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (vectorSpan k s₁) (vectorSpan k s₂)","decl":"/-- `vectorSpan` is monotone. -/\ntheorem vectorSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : vectorSpan k s₁ ≤ vectorSpan k s₂ :=\n  Submodule.span_mono (vsub_self_mono h)\n\n"}
{"name":"vectorSpan_empty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\n⊢ Eq (vectorSpan k EmptyCollection.emptyCollection) Bot.bot","decl":"/-- The `vectorSpan` of the empty set is `⊥`. -/\n@[simp]\ntheorem vectorSpan_empty : vectorSpan k (∅ : Set P) = (⊥ : Submodule k V) := by\n  rw [vectorSpan_def, vsub_empty, Submodule.span_empty]\n\n"}
{"name":"vectorSpan_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\n⊢ Eq (vectorSpan k (Singleton.singleton p)) Bot.bot","decl":"/-- The `vectorSpan` of a single point is `⊥`. -/\n@[simp]\ntheorem vectorSpan_singleton (p : P) : vectorSpan k ({p} : Set P) = ⊥ := by simp [vectorSpan_def]\n\n"}
{"name":"vsub_set_subset_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset (VSub.vsub s s) ↑(vectorSpan k s)","decl":"/-- The `s -ᵥ s` lies within the `vectorSpan k s`. -/\ntheorem vsub_set_subset_vectorSpan (s : Set P) : s -ᵥ s ⊆ ↑(vectorSpan k s) :=\n  Submodule.subset_span\n\n"}
{"name":"vsub_mem_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np1 p2 : P\nhp1 : Membership.mem s p1\nhp2 : Membership.mem s p2\n⊢ Membership.mem (vectorSpan k s) (VSub.vsub p1 p2)","decl":"/-- Each pairwise difference is in the `vectorSpan`. -/\ntheorem vsub_mem_vectorSpan {s : Set P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :\n    p1 -ᵥ p2 ∈ vectorSpan k s :=\n  vsub_set_subset_vectorSpan k s (vsub_mem_vsub hp1 hp2)\n\n"}
{"name":"vectorSpan_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nv : V\n⊢ Eq (vectorSpan k (HVAdd.hVAdd v s)) (vectorSpan k s)","decl":"@[simp] lemma vectorSpan_vadd (s : Set P) (v : V) : vectorSpan k (v +ᵥ s) = vectorSpan k s := by\n  simp [vectorSpan]\n\n"}
{"name":"mem_spanPoints","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ns : Set P\na✝ : Membership.mem s p\n⊢ Membership.mem (spanPoints k s) p","decl":"/-- A point in a set is in its affine span. -/\ntheorem mem_spanPoints (p : P) (s : Set P) : p ∈ s → p ∈ spanPoints k s\n  | hp => ⟨p, hp, 0, Submodule.zero_mem _, (zero_vadd V p).symm⟩\n\n"}
{"name":"subset_spanPoints","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset s (spanPoints k s)","decl":"/-- A set is contained in its `spanPoints`. -/\ntheorem subset_spanPoints (s : Set P) : s ⊆ spanPoints k s := fun p => mem_spanPoints k p s\n\n"}
{"name":"spanPoints_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (spanPoints k s).Nonempty s.Nonempty","decl":"/-- The `spanPoints` of a set is nonempty if and only if that set is. -/\n@[simp]\ntheorem spanPoints_nonempty (s : Set P) : (spanPoints k s).Nonempty ↔ s.Nonempty := by\n  constructor\n  · contrapose\n    rw [Set.not_nonempty_iff_eq_empty, Set.not_nonempty_iff_eq_empty]\n    intro h\n    simp [h, spanPoints]\n  · exact fun h => h.mono (subset_spanPoints _ _)\n\n"}
{"name":"vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nv : V\nhp : Membership.mem (spanPoints k s) p\nhv : Membership.mem (vectorSpan k s) v\n⊢ Membership.mem (spanPoints k s) (HVAdd.hVAdd v p)","decl":"/-- Adding a point in the affine span and a vector in the spanning submodule produces a point in the\naffine span. -/\ntheorem vadd_mem_spanPoints_of_mem_spanPoints_of_mem_vectorSpan {s : Set P} {p : P} {v : V}\n    (hp : p ∈ spanPoints k s) (hv : v ∈ vectorSpan k s) : v +ᵥ p ∈ spanPoints k s := by\n  rcases hp with ⟨p2, ⟨hp2, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩\n  rw [hv2p, vadd_vadd]\n  exact ⟨p2, hp2, v + v2, (vectorSpan k s).add_mem hv hv2, rfl⟩\n\n"}
{"name":"vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np1 p2 : P\nhp1 : Membership.mem (spanPoints k s) p1\nhp2 : Membership.mem (spanPoints k s) p2\n⊢ Membership.mem (vectorSpan k s) (VSub.vsub p1 p2)","decl":"/-- Subtracting two points in the affine span produces a vector in the spanning submodule. -/\ntheorem vsub_mem_vectorSpan_of_mem_spanPoints_of_mem_spanPoints {s : Set P} {p1 p2 : P}\n    (hp1 : p1 ∈ spanPoints k s) (hp2 : p2 ∈ spanPoints k s) : p1 -ᵥ p2 ∈ vectorSpan k s := by\n  rcases hp1 with ⟨p1a, ⟨hp1a, ⟨v1, ⟨hv1, hv1p⟩⟩⟩⟩\n  rcases hp2 with ⟨p2a, ⟨hp2a, ⟨v2, ⟨hv2, hv2p⟩⟩⟩⟩\n  rw [hv1p, hv2p, vsub_vadd_eq_vsub_sub (v1 +ᵥ p1a), vadd_vsub_assoc, add_comm, add_sub_assoc]\n  have hv1v2 : v1 - v2 ∈ vectorSpan k s := (vectorSpan k s).sub_mem hv1 hv2\n  refine (vectorSpan k s).add_mem ?_ hv1v2\n  exact vsub_mem_vectorSpan k hp1a hp2a\n\n"}
{"name":"AffineSubspace.mk.injEq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ncarrier✝ : Set P\nsmul_vsub_vadd_mem✝ : ∀ (c : k) {p1 p2 p3 : P}, Membership.mem carrier✝ p1 → Membership.mem carrier✝ p2 → Membership.mem carrier✝ p3 → Membership.mem carrier✝ (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)\ncarrier : Set P\nsmul_vsub_vadd_mem : ∀ (c : k) {p1 p2 p3 : P}, Membership.mem carrier p1 → Membership.mem carrier p2 → Membership.mem carrier p3 → Membership.mem carrier (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)\n⊢ Eq (Eq { carrier := carrier✝, smul_vsub_vadd_mem := smul_vsub_vadd_mem✝ } { carrier := carrier, smul_vsub_vadd_mem := smul_vsub_vadd_mem }) (Eq carrier✝ carrier)","decl":"/-- An `AffineSubspace k P` is a subset of an `AffineSpace V P` that, if not empty, has an affine\nspace structure induced by a corresponding subspace of the `Module k V`. -/\nstructure AffineSubspace (k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V]\n  [Module k V] [AffineSpace V P] where\n  /-- The affine subspace seen as a subset. -/\n  carrier : Set P\n  smul_vsub_vadd_mem :\n    ∀ (c : k) {p1 p2 p3 : P},\n      p1 ∈ carrier → p2 ∈ carrier → p3 ∈ carrier → c • (p1 -ᵥ p2 : V) +ᵥ p3 ∈ carrier\n\n"}
{"name":"AffineSubspace.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : Module k V\ninst✝³ : AddTorsor V P\ninst✝² : SizeOf k\ninst✝¹ : SizeOf V\ninst✝ : SizeOf P\ncarrier : Set P\nsmul_vsub_vadd_mem : ∀ (c : k) {p1 p2 p3 : P}, Membership.mem carrier p1 → Membership.mem carrier p2 → Membership.mem carrier p3 → Membership.mem carrier (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, smul_vsub_vadd_mem := smul_vsub_vadd_mem }) 1","decl":"/-- An `AffineSubspace k P` is a subset of an `AffineSpace V P` that, if not empty, has an affine\nspace structure induced by a corresponding subspace of the `Module k V`. -/\nstructure AffineSubspace (k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V]\n  [Module k V] [AffineSpace V P] where\n  /-- The affine subspace seen as a subset. -/\n  carrier : Set P\n  smul_vsub_vadd_mem :\n    ∀ (c : k) {p1 p2 p3 : P},\n      p1 ∈ carrier → p2 ∈ carrier → p3 ∈ carrier → c • (p1 -ᵥ p2 : V) +ᵥ p3 ∈ carrier\n\n"}
{"name":"AffineSubspace.mk.inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ncarrier✝ : Set P\nsmul_vsub_vadd_mem✝ : ∀ (c : k) {p1 p2 p3 : P}, Membership.mem carrier✝ p1 → Membership.mem carrier✝ p2 → Membership.mem carrier✝ p3 → Membership.mem carrier✝ (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)\ncarrier : Set P\nsmul_vsub_vadd_mem : ∀ (c : k) {p1 p2 p3 : P}, Membership.mem carrier p1 → Membership.mem carrier p2 → Membership.mem carrier p3 → Membership.mem carrier (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)\nx✝ : Eq { carrier := carrier✝, smul_vsub_vadd_mem := smul_vsub_vadd_mem✝ } { carrier := carrier, smul_vsub_vadd_mem := smul_vsub_vadd_mem }\n⊢ Eq carrier✝ carrier","decl":"/-- An `AffineSubspace k P` is a subset of an `AffineSpace V P` that, if not empty, has an affine\nspace structure induced by a corresponding subspace of the `Module k V`. -/\nstructure AffineSubspace (k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V]\n  [Module k V] [AffineSpace V P] where\n  /-- The affine subspace seen as a subset. -/\n  carrier : Set P\n  smul_vsub_vadd_mem :\n    ∀ (c : k) {p1 p2 p3 : P},\n      p1 ∈ carrier → p2 ∈ carrier → p3 ∈ carrier → c • (p1 -ᵥ p2 : V) +ᵥ p3 ∈ carrier\n\n"}
{"name":"AffineSubspace.smul_vsub_vadd_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nself : AffineSubspace k P\nc : k\np1 p2 p3 : P\na✝² : Membership.mem self.carrier p1\na✝¹ : Membership.mem self.carrier p2\na✝ : Membership.mem self.carrier p3\n⊢ Membership.mem self.carrier (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p1 p2)) p3)","decl":"/-- An `AffineSubspace k P` is a subset of an `AffineSpace V P` that, if not empty, has an affine\nspace structure induced by a corresponding subspace of the `Module k V`. -/\nstructure AffineSubspace (k : Type*) {V : Type*} (P : Type*) [Ring k] [AddCommGroup V]\n  [Module k V] [AffineSpace V P] where\n  /-- The affine subspace seen as a subset. -/\n  carrier : Set P\n  smul_vsub_vadd_mem :\n    ∀ (c : k) {p1 p2 p3 : P},\n      p1 ∈ carrier → p2 ∈ carrier → p3 ∈ carrier → c • (p1 -ᵥ p2 : V) +ᵥ p3 ∈ carrier\n\n"}
{"name":"AffineSubspace.mem_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ns : AffineSubspace k P\n⊢ Iff (Membership.mem (↑s) p) (Membership.mem s p)","decl":"/-- A point is in an affine subspace coerced to a set if and only if it is in that affine\nsubspace. -/\n-- Porting note: removed `simp`, proof is `simp only [SetLike.mem_coe]`\ntheorem mem_coe (p : P) (s : AffineSubspace k P) : p ∈ (s : Set P) ↔ p ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.direction_eq_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\n⊢ Eq s.direction (vectorSpan k ↑s)","decl":"/-- The direction equals the `vectorSpan`. -/\ntheorem direction_eq_vectorSpan (s : AffineSubspace k P) : s.direction = vectorSpan k (s : Set P) :=\n  rfl\n\n"}
{"name":"AffineSubspace.directionOfNonempty_eq_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nh : (↑s).Nonempty\n⊢ Eq (AffineSubspace.directionOfNonempty h) s.direction","decl":"/-- `direction_of_nonempty` gives the same submodule as `direction`. -/\ntheorem directionOfNonempty_eq_direction {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    directionOfNonempty h = s.direction := by\n  refine le_antisymm ?_ (Submodule.span_le.2 Set.Subset.rfl)\n  rw [← SetLike.coe_subset_coe, directionOfNonempty, direction, Submodule.coe_set_mk,\n    AddSubmonoid.coe_set_mk]\n  exact vsub_set_subset_vectorSpan k _\n\n"}
{"name":"AffineSubspace.coe_direction_eq_vsub_set","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nh : (↑s).Nonempty\n⊢ Eq (↑s.direction) (VSub.vsub ↑s ↑s)","decl":"/-- The set of vectors in the direction of a nonempty affine subspace is given by `vsub_set`. -/\ntheorem coe_direction_eq_vsub_set {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    (s.direction : Set V) = (s : Set P) -ᵥ s :=\n  directionOfNonempty_eq_direction h ▸ rfl\n\n"}
{"name":"AffineSubspace.mem_direction_iff_eq_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nh : (↑s).Nonempty\nv : V\n⊢ Iff (Membership.mem s.direction v) (Exists fun p1 => And (Membership.mem s p1) (Exists fun p2 => And (Membership.mem s p2) (Eq v (VSub.vsub p1 p2))))","decl":"/-- A vector is in the direction of a nonempty affine subspace if and only if it is the subtraction\nof two vectors in the subspace. -/\ntheorem mem_direction_iff_eq_vsub {s : AffineSubspace k P} (h : (s : Set P).Nonempty) (v : V) :\n    v ∈ s.direction ↔ ∃ p1 ∈ s, ∃ p2 ∈ s, v = p1 -ᵥ p2 := by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set h, Set.mem_vsub]\n  simp only [SetLike.mem_coe, eq_comm]\n\n"}
{"name":"AffineSubspace.vadd_mem_of_mem_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nv : V\nhv : Membership.mem s.direction v\np : P\nhp : Membership.mem s p\n⊢ Membership.mem s (HVAdd.hVAdd v p)","decl":"/-- Adding a vector in the direction to a point in the subspace produces a point in the\nsubspace. -/\ntheorem vadd_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction) {p : P}\n    (hp : p ∈ s) : v +ᵥ p ∈ s := by\n  rw [mem_direction_iff_eq_vsub ⟨p, hp⟩] at hv\n  rcases hv with ⟨p1, hp1, p2, hp2, hv⟩\n  rw [hv]\n  convert s.smul_vsub_vadd_mem 1 hp1 hp2 hp\n  rw [one_smul]\n\n"}
{"name":"AffineSubspace.vsub_mem_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np1 p2 : P\nhp1 : Membership.mem s p1\nhp2 : Membership.mem s p2\n⊢ Membership.mem s.direction (VSub.vsub p1 p2)","decl":"/-- Subtracting two points in the subspace produces a vector in the direction. -/\ntheorem vsub_mem_direction {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :\n    p1 -ᵥ p2 ∈ s.direction :=\n  vsub_mem_vectorSpan k hp1 hp2\n\n"}
{"name":"AffineSubspace.vadd_mem_iff_mem_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nv : V\np : P\nhp : Membership.mem s p\n⊢ Iff (Membership.mem s (HVAdd.hVAdd v p)) (Membership.mem s.direction v)","decl":"/-- Adding a vector to a point in a subspace produces a point in the subspace if and only if the\nvector is in the direction. -/\ntheorem vadd_mem_iff_mem_direction {s : AffineSubspace k P} (v : V) {p : P} (hp : p ∈ s) :\n    v +ᵥ p ∈ s ↔ v ∈ s.direction :=\n  ⟨fun h => by simpa using vsub_mem_direction h hp, fun h => vadd_mem_of_mem_direction h hp⟩\n\n"}
{"name":"AffineSubspace.vadd_mem_iff_mem_of_mem_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\nv : V\nhv : Membership.mem s.direction v\np : P\n⊢ Iff (Membership.mem s (HVAdd.hVAdd v p)) (Membership.mem s p)","decl":"/-- Adding a vector in the direction to a point produces a point in the subspace if and only if\nthe original point is in the subspace. -/\ntheorem vadd_mem_iff_mem_of_mem_direction {s : AffineSubspace k P} {v : V} (hv : v ∈ s.direction)\n    {p : P} : v +ᵥ p ∈ s ↔ p ∈ s := by\n  refine ⟨fun h => ?_, fun h => vadd_mem_of_mem_direction hv h⟩\n  convert vadd_mem_of_mem_direction (Submodule.neg_mem _ hv) h\n  simp\n\n"}
{"name":"AffineSubspace.coe_direction_eq_vsub_set_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\n⊢ Eq (↑s.direction) (Set.image (fun x => VSub.vsub x p) ↑s)","decl":"/-- Given a point in an affine subspace, the set of vectors in its direction equals the set of\nvectors subtracting that point on the right. -/\ntheorem coe_direction_eq_vsub_set_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :\n    (s.direction : Set V) = (· -ᵥ p) '' s := by\n  rw [coe_direction_eq_vsub_set ⟨p, hp⟩]\n  refine le_antisymm ?_ ?_\n  · rintro v ⟨p1, hp1, p2, hp2, rfl⟩\n    exact ⟨(p1 -ᵥ p2) +ᵥ p,\n      vadd_mem_of_mem_direction (vsub_mem_direction hp1 hp2) hp, vadd_vsub _ _⟩\n  · rintro v ⟨p2, hp2, rfl⟩\n    exact ⟨p2, hp2, p, hp, rfl⟩\n\n"}
{"name":"AffineSubspace.coe_direction_eq_vsub_set_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\n⊢ Eq (↑s.direction) (Set.image (fun x => VSub.vsub p x) ↑s)","decl":"/-- Given a point in an affine subspace, the set of vectors in its direction equals the set of\nvectors subtracting that point on the left. -/\ntheorem coe_direction_eq_vsub_set_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) :\n    (s.direction : Set V) = (p -ᵥ ·) '' s := by\n  ext v\n  rw [SetLike.mem_coe, ← Submodule.neg_mem_iff, ← SetLike.mem_coe,\n    coe_direction_eq_vsub_set_right hp, Set.mem_image, Set.mem_image]\n  conv_lhs =>\n    congr\n    ext\n    rw [← neg_vsub_eq_vsub_rev, neg_inj]\n\n"}
{"name":"AffineSubspace.mem_direction_iff_eq_vsub_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\nv : V\n⊢ Iff (Membership.mem s.direction v) (Exists fun p2 => And (Membership.mem s p2) (Eq v (VSub.vsub p2 p)))","decl":"/-- Given a point in an affine subspace, a vector is in its direction if and only if it results from\nsubtracting that point on the right. -/\ntheorem mem_direction_iff_eq_vsub_right {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :\n    v ∈ s.direction ↔ ∃ p2 ∈ s, v = p2 -ᵥ p := by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_right hp]\n  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩\n\n"}
{"name":"AffineSubspace.mem_direction_iff_eq_vsub_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\nv : V\n⊢ Iff (Membership.mem s.direction v) (Exists fun p2 => And (Membership.mem s p2) (Eq v (VSub.vsub p p2)))","decl":"/-- Given a point in an affine subspace, a vector is in its direction if and only if it results from\nsubtracting that point on the left. -/\ntheorem mem_direction_iff_eq_vsub_left {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (v : V) :\n    v ∈ s.direction ↔ ∃ p2 ∈ s, v = p -ᵥ p2 := by\n  rw [← SetLike.mem_coe, coe_direction_eq_vsub_set_left hp]\n  exact ⟨fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩, fun ⟨p2, hp2, hv⟩ => ⟨p2, hp2, hv.symm⟩⟩\n\n"}
{"name":"AffineSubspace.vsub_right_mem_direction_iff_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\np2 : P\n⊢ Iff (Membership.mem s.direction (VSub.vsub p2 p)) (Membership.mem s p2)","decl":"/-- Given a point in an affine subspace, a result of subtracting that point on the right is in the\ndirection if and only if the other point is in the subspace. -/\ntheorem vsub_right_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :\n    p2 -ᵥ p ∈ s.direction ↔ p2 ∈ s := by\n  rw [mem_direction_iff_eq_vsub_right hp]\n  simp\n\n"}
{"name":"AffineSubspace.vsub_left_mem_direction_iff_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\np2 : P\n⊢ Iff (Membership.mem s.direction (VSub.vsub p p2)) (Membership.mem s p2)","decl":"/-- Given a point in an affine subspace, a result of subtracting that point on the left is in the\ndirection if and only if the other point is in the subspace. -/\ntheorem vsub_left_mem_direction_iff_mem {s : AffineSubspace k P} {p : P} (hp : p ∈ s) (p2 : P) :\n    p -ᵥ p2 ∈ s.direction ↔ p2 ∈ s := by\n  rw [mem_direction_iff_eq_vsub_left hp]\n  simp\n\n"}
{"name":"AffineSubspace.coe_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\n⊢ Function.Injective SetLike.coe","decl":"/-- Two affine subspaces are equal if they have the same points. -/\ntheorem coe_injective : Function.Injective ((↑) : AffineSubspace k P → Set P) :=\n  SetLike.coe_injective\n\n"}
{"name":"AffineSubspace.ext","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np q : AffineSubspace k P\nh : ∀ (x : P), Iff (Membership.mem p x) (Membership.mem q x)\n⊢ Eq p q","decl":"@[ext (iff := false)]\ntheorem ext {p q : AffineSubspace k P} (h : ∀ x, x ∈ p ↔ x ∈ q) : p = q :=\n  SetLike.ext h\n\n"}
{"name":"AffineSubspace.ext_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\n⊢ Iff (Eq s₁ s₂) (Eq ↑s₁ ↑s₂)","decl":"protected theorem ext_iff (s₁ s₂ : AffineSubspace k P) : s₁ = s₂ ↔ (s₁ : Set P) = s₂ :=\n  SetLike.ext'_iff\n\n"}
{"name":"AffineSubspace.ext_of_direction_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns1 s2 : AffineSubspace k P\nhd : Eq s1.direction s2.direction\nhn : (Inter.inter ↑s1 ↑s2).Nonempty\n⊢ Eq s1 s2","decl":"/-- Two affine subspaces with the same direction and nonempty intersection are equal. -/\ntheorem ext_of_direction_eq {s1 s2 : AffineSubspace k P} (hd : s1.direction = s2.direction)\n    (hn : ((s1 : Set P) ∩ s2).Nonempty) : s1 = s2 := by\n  ext p\n  have hq1 := Set.mem_of_mem_inter_left hn.some_mem\n  have hq2 := Set.mem_of_mem_inter_right hn.some_mem\n  constructor\n  · intro hp\n    rw [← vsub_vadd p hn.some]\n    refine vadd_mem_of_mem_direction ?_ hq2\n    rw [← hd]\n    exact vsub_mem_direction hp hq1\n  · intro hp\n    rw [← vsub_vadd p hn.some]\n    refine vadd_mem_of_mem_direction ?_ hq1\n    rw [hd]\n    exact vsub_mem_direction hp hq2\n\n-- See note [reducible non instances]\n"}
{"name":"AffineSubspace.coe_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\na b : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(VSub.vsub a b)) (VSub.vsub ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem coe_vsub (s : AffineSubspace k P) [Nonempty s] (a b : s) : ↑(a -ᵥ b) = (a : P) -ᵥ (b : P) :=\n  rfl\n\n"}
{"name":"AffineSubspace.coe_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\na : Subtype fun x => Membership.mem s.direction x\nb : Subtype fun x => Membership.mem s x\n⊢ Eq (↑(HVAdd.hVAdd a b)) (HVAdd.hVAdd ↑a ↑b)","decl":"@[simp, norm_cast]\ntheorem coe_vadd (s : AffineSubspace k P) [Nonempty s] (a : s.direction) (b : s) :\n    ↑(a +ᵥ b) = (a : V) +ᵥ (b : P) :=\n  rfl\n\n"}
{"name":"AffineSubspace.subtype_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\n⊢ Eq s.subtype.linear s.direction.subtype","decl":"@[simp]\ntheorem subtype_linear (s : AffineSubspace k P) [Nonempty s] :\n    s.subtype.linear = s.direction.subtype := rfl\n\n"}
{"name":"AffineSubspace.subtype_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\np : Subtype fun x => Membership.mem s x\n⊢ Eq (s.subtype p) ↑p","decl":"theorem subtype_apply (s : AffineSubspace k P) [Nonempty s] (p : s) : s.subtype p = p :=\n  rfl\n\n"}
{"name":"AffineSubspace.coeSubtype","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\n⊢ Eq (⇑s.subtype) Subtype.val","decl":"@[simp]\ntheorem coeSubtype (s : AffineSubspace k P) [Nonempty s] : (s.subtype : s → P) = ((↑) : s → P) :=\n  rfl\n\n"}
{"name":"AffineSubspace.injective_subtype","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : Nonempty (Subtype fun x => Membership.mem s x)\n⊢ Function.Injective ⇑s.subtype","decl":"theorem injective_subtype (s : AffineSubspace k P) [Nonempty s] : Function.Injective s.subtype :=\n  Subtype.coe_injective\n\n"}
{"name":"AffineSubspace.eq_iff_direction_eq_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\np : P\nh₁ : Membership.mem s₁ p\nh₂ : Membership.mem s₂ p\n⊢ Iff (Eq s₁ s₂) (Eq s₁.direction s₂.direction)","decl":"/-- Two affine subspaces with nonempty intersection are equal if and only if their directions are\nequal. -/\ntheorem eq_iff_direction_eq_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁)\n    (h₂ : p ∈ s₂) : s₁ = s₂ ↔ s₁.direction = s₂.direction :=\n  ⟨fun h => h ▸ rfl, fun h => ext_of_direction_eq h ⟨p, h₁, h₂⟩⟩\n\n"}
{"name":"AffineSubspace.self_mem_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ndirection : Submodule k V\n⊢ Membership.mem (AffineSubspace.mk' p direction) p","decl":"/-- An affine subspace constructed from a point and a direction contains that point. -/\ntheorem self_mem_mk' (p : P) (direction : Submodule k V) : p ∈ mk' p direction :=\n  ⟨0, ⟨direction.zero_mem, (zero_vadd _ _).symm⟩⟩\n\n"}
{"name":"AffineSubspace.vadd_mem_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nv : V\np : P\ndirection : Submodule k V\nhv : Membership.mem direction v\n⊢ Membership.mem (AffineSubspace.mk' p direction) (HVAdd.hVAdd v p)","decl":"/-- An affine subspace constructed from a point and a direction contains the result of adding a\nvector in that direction to that point. -/\ntheorem vadd_mem_mk' {v : V} (p : P) {direction : Submodule k V} (hv : v ∈ direction) :\n    v +ᵥ p ∈ mk' p direction :=\n  ⟨v, hv, rfl⟩\n\n"}
{"name":"AffineSubspace.mk'_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ndirection : Submodule k V\n⊢ (↑(AffineSubspace.mk' p direction)).Nonempty","decl":"/-- An affine subspace constructed from a point and a direction is nonempty. -/\ntheorem mk'_nonempty (p : P) (direction : Submodule k V) : (mk' p direction : Set P).Nonempty :=\n  ⟨p, self_mem_mk' p direction⟩\n\n"}
{"name":"AffineSubspace.direction_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ndirection : Submodule k V\n⊢ Eq (AffineSubspace.mk' p direction).direction direction","decl":"/-- The direction of an affine subspace constructed from a point and a direction. -/\n@[simp]\ntheorem direction_mk' (p : P) (direction : Submodule k V) :\n    (mk' p direction).direction = direction := by\n  ext v\n  rw [mem_direction_iff_eq_vsub (mk'_nonempty _ _)]\n  constructor\n  · rintro ⟨p1, ⟨v1, hv1, hp1⟩, p2, ⟨v2, hv2, hp2⟩, hv⟩\n    rw [hv, hp1, hp2, vadd_vsub_vadd_cancel_right]\n    exact direction.sub_mem hv1 hv2\n  · exact fun hv => ⟨v +ᵥ p, vadd_mem_mk' _ hv, p, self_mem_mk' _ _, (vadd_vsub _ _).symm⟩\n\n"}
{"name":"AffineSubspace.mem_mk'_iff_vsub_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\ndirection : Submodule k V\n⊢ Iff (Membership.mem (AffineSubspace.mk' p₁ direction) p₂) (Membership.mem direction (VSub.vsub p₂ p₁))","decl":"/-- A point lies in an affine subspace constructed from another point and a direction if and only\nif their difference is in that direction. -/\ntheorem mem_mk'_iff_vsub_mem {p₁ p₂ : P} {direction : Submodule k V} :\n    p₂ ∈ mk' p₁ direction ↔ p₂ -ᵥ p₁ ∈ direction := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [← direction_mk' p₁ direction]\n    exact vsub_mem_direction h (self_mem_mk' _ _)\n  · rw [← vsub_vadd p₂ p₁]\n    exact vadd_mem_mk' p₁ h\n\n"}
{"name":"AffineSubspace.mk'_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\nhp : Membership.mem s p\n⊢ Eq (AffineSubspace.mk' p s.direction) s","decl":"/-- Constructing an affine subspace from a point in a subspace and that subspace's direction\nyields the original subspace. -/\n@[simp]\ntheorem mk'_eq {s : AffineSubspace k P} {p : P} (hp : p ∈ s) : mk' p s.direction = s :=\n  ext_of_direction_eq (direction_mk' p s.direction) ⟨p, Set.mem_inter (self_mem_mk' _ _) hp⟩\n\n"}
{"name":"AffineSubspace.spanPoints_subset_coe_of_subset_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\ns1 : AffineSubspace k P\nh : HasSubset.Subset s ↑s1\n⊢ HasSubset.Subset (spanPoints k s) ↑s1","decl":"/-- If an affine subspace contains a set of points, it contains the `spanPoints` of that set. -/\ntheorem spanPoints_subset_coe_of_subset_coe {s : Set P} {s1 : AffineSubspace k P} (h : s ⊆ s1) :\n    spanPoints k s ⊆ s1 := by\n  rintro p ⟨p1, hp1, v, hv, hp⟩\n  rw [hp]\n  have hp1s1 : p1 ∈ (s1 : Set P) := Set.mem_of_mem_of_subset hp1 h\n  refine vadd_mem_of_mem_direction ?_ hp1s1\n  have hs : vectorSpan k s ≤ s1.direction := vectorSpan_mono k h\n  rw [SetLike.le_def] at hs\n  rw [← SetLike.mem_coe]\n  exact Set.mem_of_mem_of_subset hv hs\n\n"}
{"name":"Submodule.mem_toAffineSubspace","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\np : Submodule k V\nx : V\n⊢ Iff (Membership.mem p.toAffineSubspace x) (Membership.mem p x)","decl":"@[simp]\ntheorem mem_toAffineSubspace {p : Submodule k V} {x : V} :\n    x ∈ p.toAffineSubspace ↔ x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"Submodule.toAffineSubspace_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Submodule k V\n⊢ Eq s.toAffineSubspace.direction s","decl":"@[simp]\ntheorem toAffineSubspace_direction (s : Submodule k V) : s.toAffineSubspace.direction = s := by\n  ext x; simp [← s.toAffineSubspace.vadd_mem_iff_mem_direction _ s.zero_mem]\n\n"}
{"name":"AffineMap.lineMap_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nQ : AffineSubspace k P\np₀ p₁ : P\nc : k\nh₀ : Membership.mem Q p₀\nh₁ : Membership.mem Q p₁\n⊢ Membership.mem Q ((AffineMap.lineMap p₀ p₁) c)","decl":"theorem AffineMap.lineMap_mem {k V P : Type*} [Ring k] [AddCommGroup V] [Module k V]\n    [AddTorsor V P] {Q : AffineSubspace k P} {p₀ p₁ : P} (c : k) (h₀ : p₀ ∈ Q) (h₁ : p₁ ∈ Q) :\n    AffineMap.lineMap p₀ p₁ c ∈ Q := by\n  rw [AffineMap.lineMap_apply]\n  exact Q.smul_vsub_vadd_mem c h₁ h₀ h₀\n\n"}
{"name":"coe_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (↑(affineSpan k s)) (spanPoints k s)","decl":"/-- The affine span, converted to a set, is `spanPoints`. -/\n@[simp]\ntheorem coe_affineSpan (s : Set P) : (affineSpan k s : Set P) = spanPoints k s :=\n  rfl\n\n"}
{"name":"subset_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ HasSubset.Subset s ↑(affineSpan k s)","decl":"/-- A set is contained in its affine span. -/\ntheorem subset_affineSpan (s : Set P) : s ⊆ affineSpan k s :=\n  subset_spanPoints k s\n\n"}
{"name":"direction_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Eq (affineSpan k s).direction (vectorSpan k s)","decl":"/-- The direction of the affine span is the `vectorSpan`. -/\ntheorem direction_affineSpan (s : Set P) : (affineSpan k s).direction = vectorSpan k s := by\n  apply le_antisymm\n  · refine Submodule.span_le.2 ?_\n    rintro v ⟨p1, ⟨p2, hp2, v1, hv1, hp1⟩, p3, ⟨p4, hp4, v2, hv2, hp3⟩, rfl⟩\n    simp only [SetLike.mem_coe]\n    rw [hp1, hp3, vsub_vadd_eq_vsub_sub, vadd_vsub_assoc]\n    exact\n      (vectorSpan k s).sub_mem ((vectorSpan k s).add_mem hv1 (vsub_mem_vectorSpan k hp2 hp4)) hv2\n  · exact vectorSpan_mono k (subset_spanPoints k s)\n\n"}
{"name":"mem_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\ns : Set P\nhp : Membership.mem s p\n⊢ Membership.mem (affineSpan k s) p","decl":"/-- A point in a set is in its affine span. -/\ntheorem mem_affineSpan {p : P} {s : Set P} (hp : p ∈ s) : p ∈ affineSpan k s :=\n  mem_spanPoints k p s hp\n\n"}
{"name":"vectorSpan_add_self","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Set V\n⊢ Eq (HAdd.hAdd (↑(vectorSpan k s)) s) ↑(affineSpan k s)","decl":"@[simp]\nlemma vectorSpan_add_self (s : Set V) : (vectorSpan k s : Set V) + s = affineSpan k s := by\n  ext\n  simp [mem_add, spanPoints]\n  aesop\n\n"}
{"name":"AffineSubspace.le_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Iff (LE.le s1 s2) (HasSubset.Subset ↑s1 ↑s2)","decl":"/-- The `≤` order on subspaces is the same as that on the corresponding sets. -/\ntheorem le_def (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ (s1 : Set P) ⊆ s2 :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.le_def'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Iff (LE.le s1 s2) (∀ (p : P), Membership.mem s1 p → Membership.mem s2 p)","decl":"/-- One subspace is less than or equal to another if and only if all its points are in the second\nsubspace. -/\ntheorem le_def' (s1 s2 : AffineSubspace k P) : s1 ≤ s2 ↔ ∀ p ∈ s1, p ∈ s2 :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.lt_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Iff (LT.lt s1 s2) (HasSSubset.SSubset ↑s1 ↑s2)","decl":"/-- The `<` order on subspaces is the same as that on the corresponding sets. -/\ntheorem lt_def (s1 s2 : AffineSubspace k P) : s1 < s2 ↔ (s1 : Set P) ⊂ s2 :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.not_le_iff_exists","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Iff (Not (LE.le s1 s2)) (Exists fun p => And (Membership.mem s1 p) (Not (Membership.mem s2 p)))","decl":"/-- One subspace is not less than or equal to another if and only if it has a point not in the\nsecond subspace. -/\ntheorem not_le_iff_exists (s1 s2 : AffineSubspace k P) : ¬s1 ≤ s2 ↔ ∃ p ∈ s1, p ∉ s2 :=\n  Set.not_subset\n\n"}
{"name":"AffineSubspace.exists_of_lt","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh : LT.lt s1 s2\n⊢ Exists fun p => And (Membership.mem s2 p) (Not (Membership.mem s1 p))","decl":"/-- If a subspace is less than another, there is a point only in the second. -/\ntheorem exists_of_lt {s1 s2 : AffineSubspace k P} (h : s1 < s2) : ∃ p ∈ s2, p ∉ s1 :=\n  Set.exists_of_ssubset h\n\n"}
{"name":"AffineSubspace.lt_iff_le_and_exists","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Iff (LT.lt s1 s2) (And (LE.le s1 s2) (Exists fun p => And (Membership.mem s2 p) (Not (Membership.mem s1 p))))","decl":"/-- A subspace is less than another if and only if it is less than or equal to the second subspace\nand there is a point only in the second. -/\ntheorem lt_iff_le_and_exists (s1 s2 : AffineSubspace k P) :\n    s1 < s2 ↔ s1 ≤ s2 ∧ ∃ p ∈ s2, p ∉ s1 := by\n  rw [lt_iff_le_not_le, not_le_iff_exists]\n\n"}
{"name":"AffineSubspace.eq_of_direction_eq_of_nonempty_of_le","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\nhd : Eq s₁.direction s₂.direction\nhn : (↑s₁).Nonempty\nhle : LE.le s₁ s₂\n⊢ Eq s₁ s₂","decl":"/-- If an affine subspace is nonempty and contained in another with the same direction, they are\nequal. -/\ntheorem eq_of_direction_eq_of_nonempty_of_le {s₁ s₂ : AffineSubspace k P}\n    (hd : s₁.direction = s₂.direction) (hn : (s₁ : Set P).Nonempty) (hle : s₁ ≤ s₂) : s₁ = s₂ :=\n  let ⟨p, hp⟩ := hn\n  ext_of_direction_eq hd ⟨p, hp, hle hp⟩\n\n"}
{"name":"AffineSubspace.affineSpan_eq_sInf","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\n⊢ Eq (affineSpan k s) (InfSet.sInf (setOf fun s' => HasSubset.Subset s ↑s'))","decl":"/-- The affine span is the `sInf` of subspaces containing the given points. -/\ntheorem affineSpan_eq_sInf (s : Set P) :\n    affineSpan k s = sInf { s' : AffineSubspace k P | s ⊆ s' } :=\n  le_antisymm (spanPoints_subset_coe_of_subset_coe <| Set.subset_iInter₂ fun _ => id)\n    (sInf_le (subset_spanPoints k _))\n\n"}
{"name":"AffineSubspace.span_empty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq (affineSpan k EmptyCollection.emptyCollection) Bot.bot","decl":"/-- The span of the empty set is `⊥`. -/\n@[simp]\ntheorem span_empty : affineSpan k (∅ : Set P) = ⊥ :=\n  (AffineSubspace.gi k V P).gc.l_bot\n\n"}
{"name":"AffineSubspace.span_univ","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq (affineSpan k Set.univ) Top.top","decl":"/-- The span of `univ` is `⊤`. -/\n@[simp]\ntheorem span_univ : affineSpan k (Set.univ : Set P) = ⊤ :=\n  eq_top_iff.2 <| subset_spanPoints k _\n\n"}
{"name":"affineSpan_le","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nQ : AffineSubspace k P\n⊢ Iff (LE.le (affineSpan k s) Q) (HasSubset.Subset s ↑Q)","decl":"theorem _root_.affineSpan_le {s : Set P} {Q : AffineSubspace k P} :\n    affineSpan k s ≤ Q ↔ s ⊆ (Q : Set P) :=\n  (AffineSubspace.gi k V P).gc _ _\n\n"}
{"name":"AffineSubspace.coe_affineSpan_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\np : P\n⊢ Eq (↑(affineSpan k (Singleton.singleton p))) (Singleton.singleton p)","decl":"/-- The affine span of a single point, coerced to a set, contains just that point. -/\n@[simp 1001] -- Porting note: this needs to take priority over `coe_affineSpan`\ntheorem coe_affineSpan_singleton (p : P) : (affineSpan k ({p} : Set P) : Set P) = {p} := by\n  ext x\n  rw [mem_coe, ← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_singleton p)) _,\n    direction_affineSpan]\n  simp\n\n"}
{"name":"AffineSubspace.mem_affineSpan_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\np₁ p₂ : P\n⊢ Iff (Membership.mem (affineSpan k (Singleton.singleton p₂)) p₁) (Eq p₁ p₂)","decl":"/-- A point is in the affine span of a single point if and only if they are equal. -/\n@[simp]\ntheorem mem_affineSpan_singleton : p₁ ∈ affineSpan k ({p₂} : Set P) ↔ p₁ = p₂ := by\n  simp [← mem_coe]\n\n"}
{"name":"AffineSubspace.preimage_coe_affineSpan_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nx : P\n⊢ Eq (Set.preimage Subtype.val (Singleton.singleton x)) Set.univ","decl":"@[simp]\ntheorem preimage_coe_affineSpan_singleton (x : P) :\n    ((↑) : affineSpan k ({x} : Set P) → P) ⁻¹' {x} = univ :=\n  eq_univ_of_forall fun y => (AffineSubspace.mem_affineSpan_singleton _ _).1 y.2\n\n"}
{"name":"AffineSubspace.span_union","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns t : Set P\n⊢ Eq (affineSpan k (Union.union s t)) (Max.max (affineSpan k s) (affineSpan k t))","decl":"/-- The span of a union of sets is the sup of their spans. -/\ntheorem span_union (s t : Set P) : affineSpan k (s ∪ t) = affineSpan k s ⊔ affineSpan k t :=\n  (AffineSubspace.gi k V P).gc.l_sup\n\n"}
{"name":"AffineSubspace.span_iUnion","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nι : Type u_4\ns : ι → Set P\n⊢ Eq (affineSpan k (Set.iUnion fun i => s i)) (iSup fun i => affineSpan k (s i))","decl":"/-- The span of a union of an indexed family of sets is the sup of their spans. -/\ntheorem span_iUnion {ι : Type*} (s : ι → Set P) :\n    affineSpan k (⋃ i, s i) = ⨆ i, affineSpan k (s i) :=\n  (AffineSubspace.gi k V P).gc.l_iSup\n\n"}
{"name":"AffineSubspace.top_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq (↑Top.top) Set.univ","decl":"/-- `⊤`, coerced to a set, is the whole set of points. -/\n@[simp]\ntheorem top_coe : ((⊤ : AffineSubspace k P) : Set P) = Set.univ :=\n  rfl\n\n"}
{"name":"AffineSubspace.mem_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\np : P\n⊢ Membership.mem Top.top p","decl":"/-- All points are in `⊤`. -/\n@[simp]\ntheorem mem_top (p : P) : p ∈ (⊤ : AffineSubspace k P) :=\n  Set.mem_univ p\n\n"}
{"name":"AffineSubspace.direction_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq Top.top.direction Top.top","decl":"/-- The direction of `⊤` is the whole module as a submodule. -/\n@[simp]\ntheorem direction_top : (⊤ : AffineSubspace k P).direction = ⊤ := by\n  cases' S.nonempty with p\n  ext v\n  refine ⟨imp_intro Submodule.mem_top, fun _hv => ?_⟩\n  have hpv : ((v +ᵥ p) -ᵥ p : V) ∈ (⊤ : AffineSubspace k P).direction :=\n    vsub_mem_direction (mem_top k V _) (mem_top k V _)\n  rwa [vadd_vsub] at hpv\n\n"}
{"name":"AffineSubspace.bot_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"/-- `⊥`, coerced to a set, is the empty set. -/\n@[simp]\ntheorem bot_coe : ((⊥ : AffineSubspace k P) : Set P) = ∅ :=\n  rfl\n\n"}
{"name":"AffineSubspace.bot_ne_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Ne Bot.bot Top.top","decl":"theorem bot_ne_top : (⊥ : AffineSubspace k P) ≠ ⊤ := by\n  intro contra\n  rw [AffineSubspace.ext_iff, bot_coe, top_coe] at contra\n  exact Set.empty_ne_univ contra\n\n"}
{"name":"AffineSubspace.instNontrivial","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Nontrivial (AffineSubspace k P)","decl":"instance : Nontrivial (AffineSubspace k P) :=\n  ⟨⟨⊥, ⊤, bot_ne_top k V P⟩⟩\n\n"}
{"name":"AffineSubspace.nonempty_of_affineSpan_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nh : Eq (affineSpan k s) Top.top\n⊢ s.Nonempty","decl":"theorem nonempty_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = ⊤) : s.Nonempty := by\n  rw [Set.nonempty_iff_ne_empty]\n  rintro rfl\n  rw [AffineSubspace.span_empty] at h\n  exact bot_ne_top k V P h\n\n"}
{"name":"AffineSubspace.vectorSpan_eq_top_of_affineSpan_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nh : Eq (affineSpan k s) Top.top\n⊢ Eq (vectorSpan k s) Top.top","decl":"/-- If the affine span of a set is `⊤`, then the vector span of the same set is the `⊤`. -/\ntheorem vectorSpan_eq_top_of_affineSpan_eq_top {s : Set P} (h : affineSpan k s = ⊤) :\n    vectorSpan k s = ⊤ := by rw [← direction_affineSpan, h, direction_top]\n\n"}
{"name":"AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nhs : s.Nonempty\n⊢ Iff (Eq (affineSpan k s) Top.top) (Eq (vectorSpan k s) Top.top)","decl":"/-- For a nonempty set, the affine span is `⊤` iff its vector span is `⊤`. -/\ntheorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty {s : Set P} (hs : s.Nonempty) :\n    affineSpan k s = ⊤ ↔ vectorSpan k s = ⊤ := by\n  refine ⟨vectorSpan_eq_top_of_affineSpan_eq_top k V P, ?_⟩\n  intro h\n  suffices Nonempty (affineSpan k s) by\n    obtain ⟨p, hp : p ∈ affineSpan k s⟩ := this\n    rw [eq_iff_direction_eq_of_mem hp (mem_top k V p), direction_affineSpan, h, direction_top]\n  obtain ⟨x, hx⟩ := hs\n  exact ⟨⟨x, mem_affineSpan k hx⟩⟩\n\n"}
{"name":"AffineSubspace.affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\ns : Set P\ninst✝ : Nontrivial P\n⊢ Iff (Eq (affineSpan k s) Top.top) (Eq (vectorSpan k s) Top.top)","decl":"/-- For a non-trivial space, the affine span of a set is `⊤` iff its vector span is `⊤`. -/\ntheorem affineSpan_eq_top_iff_vectorSpan_eq_top_of_nontrivial {s : Set P} [Nontrivial P] :\n    affineSpan k s = ⊤ ↔ vectorSpan k s = ⊤ := by\n  rcases s.eq_empty_or_nonempty with hs | hs\n  · simp [hs, subsingleton_iff_bot_eq_top, AddTorsor.subsingleton_iff V P, not_subsingleton]\n  · rw [affineSpan_eq_top_iff_vectorSpan_eq_top_of_nonempty k V P hs]\n\n"}
{"name":"AffineSubspace.card_pos_of_affineSpan_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nS : AddTorsor V P\nι : Type u_4\ninst✝ : Fintype ι\np : ι → P\nh : Eq (affineSpan k (Set.range p)) Top.top\n⊢ LT.lt 0 (Fintype.card ι)","decl":"theorem card_pos_of_affineSpan_eq_top {ι : Type*} [Fintype ι] {p : ι → P}\n    (h : affineSpan k (range p) = ⊤) : 0 < Fintype.card ι := by\n  obtain ⟨-, ⟨i, -⟩⟩ := nonempty_of_affineSpan_eq_top k V P h\n  exact Fintype.card_pos_iff.mpr ⟨i⟩\n\n"}
{"name":"AffineSubspace.instNonemptySubtypeMemTop","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Nonempty (Subtype fun x => Membership.mem Top.top x)","decl":"instance : Nonempty (⊤ : AffineSubspace k P) := inferInstanceAs (Nonempty (⊤ : Set P))\n\n"}
{"name":"AffineSubspace.topEquiv_symm_apply_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\na : P\n⊢ Eq (↑((AffineSubspace.topEquiv k V P).symm a)) a","decl":"/-- The top affine subspace is linearly equivalent to the affine space.\nThis is the affine version of `Submodule.topEquiv`. -/\n@[simps! linear apply symm_apply_coe]\ndef topEquiv : (⊤ : AffineSubspace k P) ≃ᵃ[k] P where\n  toEquiv := Equiv.Set.univ P\n  linear := .ofEq _ _ (direction_top _ _ _) ≪≫ₗ Submodule.topEquiv\n  map_vadd' _ _ := rfl\n\n"}
{"name":"AffineSubspace.linear_topEquiv","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq (AffineSubspace.topEquiv k V P).linear ((LinearEquiv.ofEq Top.top.direction Top.top ⋯).trans Submodule.topEquiv)","decl":"/-- The top affine subspace is linearly equivalent to the affine space.\nThis is the affine version of `Submodule.topEquiv`. -/\n@[simps! linear apply symm_apply_coe]\ndef topEquiv : (⊤ : AffineSubspace k P) ≃ᵃ[k] P where\n  toEquiv := Equiv.Set.univ P\n  linear := .ofEq _ _ (direction_top _ _ _) ≪≫ₗ Submodule.topEquiv\n  map_vadd' _ _ := rfl\n\n"}
{"name":"AffineSubspace.topEquiv_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nself : Subtype fun x => Membership.mem Set.univ x\n⊢ Eq ((AffineSubspace.topEquiv k V P) self) ↑self","decl":"/-- The top affine subspace is linearly equivalent to the affine space.\nThis is the affine version of `Submodule.topEquiv`. -/\n@[simps! linear apply symm_apply_coe]\ndef topEquiv : (⊤ : AffineSubspace k P) ≃ᵃ[k] P where\n  toEquiv := Equiv.Set.univ P\n  linear := .ofEq _ _ (direction_top _ _ _) ≪≫ₗ Submodule.topEquiv\n  map_vadd' _ _ := rfl\n\n"}
{"name":"AffineSubspace.not_mem_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\np : P\n⊢ Not (Membership.mem Bot.bot p)","decl":"/-- No points are in `⊥`. -/\ntheorem not_mem_bot (p : P) : p ∉ (⊥ : AffineSubspace k P) :=\n  Set.not_mem_empty p\n\n"}
{"name":"AffineSubspace.direction_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\n⊢ Eq Bot.bot.direction Bot.bot","decl":"/-- The direction of `⊥` is the submodule `⊥`. -/\n@[simp]\ntheorem direction_bot : (⊥ : AffineSubspace k P).direction = ⊥ := by\n  rw [direction_eq_vectorSpan, bot_coe, vectorSpan_def, vsub_empty, Submodule.span_empty]\n\n"}
{"name":"AffineSubspace.coe_eq_bot_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nQ : AffineSubspace k P\n⊢ Iff (Eq (↑Q) EmptyCollection.emptyCollection) (Eq Q Bot.bot)","decl":"@[simp]\ntheorem coe_eq_bot_iff (Q : AffineSubspace k P) : (Q : Set P) = ∅ ↔ Q = ⊥ :=\n  coe_injective.eq_iff' (bot_coe _ _ _)\n\n"}
{"name":"AffineSubspace.coe_eq_univ_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nQ : AffineSubspace k P\n⊢ Iff (Eq (↑Q) Set.univ) (Eq Q Top.top)","decl":"@[simp]\ntheorem coe_eq_univ_iff (Q : AffineSubspace k P) : (Q : Set P) = univ ↔ Q = ⊤ :=\n  coe_injective.eq_iff' (top_coe _ _ _)\n\n"}
{"name":"AffineSubspace.nonempty_iff_ne_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nQ : AffineSubspace k P\n⊢ Iff (↑Q).Nonempty (Ne Q Bot.bot)","decl":"theorem nonempty_iff_ne_bot (Q : AffineSubspace k P) : (Q : Set P).Nonempty ↔ Q ≠ ⊥ := by\n  rw [nonempty_iff_ne_empty]\n  exact not_congr Q.coe_eq_bot_iff\n\n"}
{"name":"AffineSubspace.eq_bot_or_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\nQ : AffineSubspace k P\n⊢ Or (Eq Q Bot.bot) (↑Q).Nonempty","decl":"theorem eq_bot_or_nonempty (Q : AffineSubspace k P) : Q = ⊥ ∨ (Q : Set P).Nonempty := by\n  rw [nonempty_iff_ne_bot]\n  apply eq_or_ne\n\n"}
{"name":"AffineSubspace.subsingleton_of_subsingleton_span_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nh₁ : s.Subsingleton\nh₂ : Eq (affineSpan k s) Top.top\n⊢ Subsingleton P","decl":"theorem subsingleton_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.Subsingleton)\n    (h₂ : affineSpan k s = ⊤) : Subsingleton P := by\n  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂\n  have : s = {p} := Subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])\n  rw [this, AffineSubspace.ext_iff, AffineSubspace.coe_affineSpan_singleton,\n    AffineSubspace.top_coe, eq_comm, ← subsingleton_iff_singleton (mem_univ _)] at h₂\n  exact subsingleton_of_univ_subsingleton h₂\n\n"}
{"name":"AffineSubspace.eq_univ_of_subsingleton_span_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : Set P\nh₁ : s.Subsingleton\nh₂ : Eq (affineSpan k s) Top.top\n⊢ Eq s Set.univ","decl":"theorem eq_univ_of_subsingleton_span_eq_top {s : Set P} (h₁ : s.Subsingleton)\n    (h₂ : affineSpan k s = ⊤) : s = (univ : Set P) := by\n  obtain ⟨p, hp⟩ := AffineSubspace.nonempty_of_affineSpan_eq_top k V P h₂\n  have : s = {p} := Subset.antisymm (fun q hq => h₁ hq hp) (by simp [hp])\n  rw [this, eq_comm, ← subsingleton_iff_singleton (mem_univ p), subsingleton_univ_iff]\n  exact subsingleton_of_subsingleton_span_eq_top h₁ h₂\n\n"}
{"name":"AffineSubspace.direction_eq_top_iff_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : AffineSubspace k P\nh : (↑s).Nonempty\n⊢ Iff (Eq s.direction Top.top) (Eq s Top.top)","decl":"/-- A nonempty affine subspace is `⊤` if and only if its direction is `⊤`. -/\n@[simp]\ntheorem direction_eq_top_iff_of_nonempty {s : AffineSubspace k P} (h : (s : Set P).Nonempty) :\n    s.direction = ⊤ ↔ s = ⊤ := by\n  constructor\n  · intro hd\n    rw [← direction_top k V P] at hd\n    refine ext_of_direction_eq hd ?_\n    simp [h]\n  · rintro rfl\n    simp\n\n"}
{"name":"AffineSubspace.inf_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ Eq (Min.min ↑s1 ↑s2) (Inter.inter ↑s1 ↑s2)","decl":"/-- The inf of two affine subspaces, coerced to a set, is the intersection of the two sets of\npoints. -/\n@[simp]\ntheorem inf_coe (s1 s2 : AffineSubspace k P) : (s1 ⊓ s2 : Set P) = (s1 : Set P) ∩ s2 :=\n  rfl\n\n"}
{"name":"AffineSubspace.mem_inf_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\np : P\ns1 s2 : AffineSubspace k P\n⊢ Iff (Membership.mem (Min.min s1 s2) p) (And (Membership.mem s1 p) (Membership.mem s2 p))","decl":"/-- A point is in the inf of two affine subspaces if and only if it is in both of them. -/\ntheorem mem_inf_iff (p : P) (s1 s2 : AffineSubspace k P) : p ∈ s1 ⊓ s2 ↔ p ∈ s1 ∧ p ∈ s2 :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.direction_inf","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ LE.le (Min.min s1 s2).direction (Min.min s1.direction s2.direction)","decl":"/-- The direction of the inf of two affine subspaces is less than or equal to the inf of their\ndirections. -/\ntheorem direction_inf (s1 s2 : AffineSubspace k P) :\n    (s1 ⊓ s2).direction ≤ s1.direction ⊓ s2.direction := by\n  simp only [direction_eq_vectorSpan, vectorSpan_def]\n  exact\n    le_inf (sInf_le_sInf fun p hp => trans (vsub_self_mono inter_subset_left) hp)\n      (sInf_le_sInf fun p hp => trans (vsub_self_mono inter_subset_right) hp)\n\n"}
{"name":"AffineSubspace.direction_inf_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\np : P\nh₁ : Membership.mem s₁ p\nh₂ : Membership.mem s₂ p\n⊢ Eq (Min.min s₁ s₂).direction (Min.min s₁.direction s₂.direction)","decl":"/-- If two affine subspaces have a point in common, the direction of their inf equals the inf of\ntheir directions. -/\ntheorem direction_inf_of_mem {s₁ s₂ : AffineSubspace k P} {p : P} (h₁ : p ∈ s₁) (h₂ : p ∈ s₂) :\n    (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction := by\n  ext v\n  rw [Submodule.mem_inf, ← vadd_mem_iff_mem_direction v h₁, ← vadd_mem_iff_mem_direction v h₂, ←\n    vadd_mem_iff_mem_direction v ((mem_inf_iff p s₁ s₂).2 ⟨h₁, h₂⟩), mem_inf_iff]\n\n"}
{"name":"AffineSubspace.direction_inf_of_mem_inf","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\np : P\nh : Membership.mem (Min.min s₁ s₂) p\n⊢ Eq (Min.min s₁ s₂).direction (Min.min s₁.direction s₂.direction)","decl":"/-- If two affine subspaces have a point in their inf, the direction of their inf equals the inf of\ntheir directions. -/\ntheorem direction_inf_of_mem_inf {s₁ s₂ : AffineSubspace k P} {p : P} (h : p ∈ s₁ ⊓ s₂) :\n    (s₁ ⊓ s₂).direction = s₁.direction ⊓ s₂.direction :=\n  direction_inf_of_mem ((mem_inf_iff p s₁ s₂).1 h).1 ((mem_inf_iff p s₁ s₂).1 h).2\n\n"}
{"name":"AffineSubspace.direction_le","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh : LE.le s1 s2\n⊢ LE.le s1.direction s2.direction","decl":"/-- If one affine subspace is less than or equal to another, the same applies to their\ndirections. -/\ntheorem direction_le {s1 s2 : AffineSubspace k P} (h : s1 ≤ s2) : s1.direction ≤ s2.direction := by\n  simp only [direction_eq_vectorSpan, vectorSpan_def]\n  exact vectorSpan_mono k h\n\n"}
{"name":"AffineSubspace.direction_lt_of_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh : LT.lt s1 s2\nhn : (↑s1).Nonempty\n⊢ LT.lt s1.direction s2.direction","decl":"/-- If one nonempty affine subspace is less than another, the same applies to their directions -/\ntheorem direction_lt_of_nonempty {s1 s2 : AffineSubspace k P} (h : s1 < s2)\n    (hn : (s1 : Set P).Nonempty) : s1.direction < s2.direction := by\n  cases' hn with p hp\n  rw [lt_iff_le_and_exists] at h\n  rcases h with ⟨hle, p2, hp2, hp2s1⟩\n  rw [SetLike.lt_iff_le_and_exists]\n  use direction_le hle, p2 -ᵥ p, vsub_mem_direction hp2 (hle hp)\n  intro hm\n  rw [vsub_right_mem_direction_iff_mem hp p2] at hm\n  exact hp2s1 hm\n\n"}
{"name":"AffineSubspace.sup_direction_le","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\n⊢ LE.le (Max.max s1.direction s2.direction) (Max.max s1 s2).direction","decl":"/-- The sup of the directions of two affine subspaces is less than or equal to the direction of\ntheir sup. -/\ntheorem sup_direction_le (s1 s2 : AffineSubspace k P) :\n    s1.direction ⊔ s2.direction ≤ (s1 ⊔ s2).direction := by\n  simp only [direction_eq_vectorSpan, vectorSpan_def]\n  exact\n    sup_le\n      (sInf_le_sInf fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_left : s1 ≤ s1 ⊔ s2)) hp)\n      (sInf_le_sInf fun p hp => Set.Subset.trans (vsub_self_mono (le_sup_right : s2 ≤ s1 ⊔ s2)) hp)\n\n"}
{"name":"AffineSubspace.sup_direction_lt_of_nonempty_of_inter_empty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh1 : (↑s1).Nonempty\nh2 : (↑s2).Nonempty\nhe : Eq (Inter.inter ↑s1 ↑s2) EmptyCollection.emptyCollection\n⊢ LT.lt (Max.max s1.direction s2.direction) (Max.max s1 s2).direction","decl":"/-- The sup of the directions of two nonempty affine subspaces with empty intersection is less than\nthe direction of their sup. -/\ntheorem sup_direction_lt_of_nonempty_of_inter_empty {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty) (he : (s1 ∩ s2 : Set P) = ∅) :\n    s1.direction ⊔ s2.direction < (s1 ⊔ s2).direction := by\n  cases' h1 with p1 hp1\n  cases' h2 with p2 hp2\n  rw [SetLike.lt_iff_le_and_exists]\n  use sup_direction_le s1 s2, p2 -ᵥ p1,\n    vsub_mem_direction ((le_sup_right : s2 ≤ s1 ⊔ s2) hp2) ((le_sup_left : s1 ≤ s1 ⊔ s2) hp1)\n  intro h\n  rw [Submodule.mem_sup] at h\n  rcases h with ⟨v1, hv1, v2, hv2, hv1v2⟩\n  rw [← sub_eq_zero, sub_eq_add_neg, neg_vsub_eq_vsub_rev, add_comm v1, add_assoc, ←\n    vadd_vsub_assoc, ← neg_neg v2, add_comm, ← sub_eq_add_neg, ← vsub_vadd_eq_vsub_sub,\n    vsub_eq_zero_iff_eq] at hv1v2\n  refine Set.Nonempty.ne_empty ?_ he\n  use v1 +ᵥ p1, vadd_mem_of_mem_direction hv1 hp1\n  rw [hv1v2]\n  exact vadd_mem_of_mem_direction (Submodule.neg_mem _ hv2) hp2\n\n"}
{"name":"AffineSubspace.inter_nonempty_of_nonempty_of_sup_direction_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh1 : (↑s1).Nonempty\nh2 : (↑s2).Nonempty\nhd : Eq (Max.max s1.direction s2.direction) Top.top\n⊢ (Inter.inter ↑s1 ↑s2).Nonempty","decl":"/-- If the directions of two nonempty affine subspaces span the whole module, they have nonempty\nintersection. -/\ntheorem inter_nonempty_of_nonempty_of_sup_direction_eq_top {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)\n    (hd : s1.direction ⊔ s2.direction = ⊤) : ((s1 : Set P) ∩ s2).Nonempty := by\n  by_contra h\n  rw [Set.not_nonempty_iff_eq_empty] at h\n  have hlt := sup_direction_lt_of_nonempty_of_inter_empty h1 h2 h\n  rw [hd] at hlt\n  exact not_top_lt hlt\n\n"}
{"name":"AffineSubspace.inter_eq_singleton_of_nonempty_of_isCompl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns1 s2 : AffineSubspace k P\nh1 : (↑s1).Nonempty\nh2 : (↑s2).Nonempty\nhd : IsCompl s1.direction s2.direction\n⊢ Exists fun p => Eq (Inter.inter ↑s1 ↑s2) (Singleton.singleton p)","decl":"/-- If the directions of two nonempty affine subspaces are complements of each other, they intersect\nin exactly one point. -/\ntheorem inter_eq_singleton_of_nonempty_of_isCompl {s1 s2 : AffineSubspace k P}\n    (h1 : (s1 : Set P).Nonempty) (h2 : (s2 : Set P).Nonempty)\n    (hd : IsCompl s1.direction s2.direction) : ∃ p, (s1 : Set P) ∩ s2 = {p} := by\n  cases' inter_nonempty_of_nonempty_of_sup_direction_eq_top h1 h2 hd.sup_eq_top with p hp\n  use p\n  ext q\n  rw [Set.mem_singleton_iff]\n  constructor\n  · rintro ⟨hq1, hq2⟩\n    have hqp : q -ᵥ p ∈ s1.direction ⊓ s2.direction :=\n      ⟨vsub_mem_direction hq1 hp.1, vsub_mem_direction hq2 hp.2⟩\n    rwa [hd.inf_eq_bot, Submodule.mem_bot, vsub_eq_zero_iff_eq] at hqp\n  · exact fun h => h.symm ▸ hp\n\n"}
{"name":"AffineSubspace.affineSpan_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nS : AddTorsor V P\ns : AffineSubspace k P\n⊢ Eq (affineSpan k ↑s) s","decl":"/-- Coercing a subspace to a set then taking the affine span produces the original subspace. -/\n@[simp]\ntheorem affineSpan_coe (s : AffineSubspace k P) : affineSpan k (s : Set P) = s := by\n  refine le_antisymm ?_ (subset_spanPoints _ _)\n  rintro p ⟨p1, hp1, v, hv, rfl⟩\n  exact vadd_mem_of_mem_direction hv hp1\n\n"}
{"name":"vectorSpan_eq_span_vsub_set_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nhp : Membership.mem s p\n⊢ Eq (vectorSpan k s) (Submodule.span k (Set.image (fun x => VSub.vsub p x) s))","decl":"/-- The `vectorSpan` is the span of the pairwise subtractions with a given point on the left. -/\ntheorem vectorSpan_eq_span_vsub_set_left {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k ((p -ᵥ ·) '' s) := by\n  rw [vectorSpan_def]\n  refine le_antisymm ?_ (Submodule.span_mono ?_)\n  · rw [Submodule.span_le]\n    rintro v ⟨p1, hp1, p2, hp2, hv⟩\n    simp_rw [← vsub_sub_vsub_cancel_left p1 p2 p] at hv\n    rw [← hv, SetLike.mem_coe, Submodule.mem_span]\n    exact fun m hm => Submodule.sub_mem _ (hm ⟨p2, hp2, rfl⟩) (hm ⟨p1, hp1, rfl⟩)\n  · rintro v ⟨p2, hp2, hv⟩\n    exact ⟨p, hp, p2, hp2, hv⟩\n\n"}
{"name":"vectorSpan_eq_span_vsub_set_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nhp : Membership.mem s p\n⊢ Eq (vectorSpan k s) (Submodule.span k (Set.image (fun x => VSub.vsub x p) s))","decl":"/-- The `vectorSpan` is the span of the pairwise subtractions with a given point on the right. -/\ntheorem vectorSpan_eq_span_vsub_set_right {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k ((· -ᵥ p) '' s) := by\n  rw [vectorSpan_def]\n  refine le_antisymm ?_ (Submodule.span_mono ?_)\n  · rw [Submodule.span_le]\n    rintro v ⟨p1, hp1, p2, hp2, hv⟩\n    simp_rw [← vsub_sub_vsub_cancel_right p1 p2 p] at hv\n    rw [← hv, SetLike.mem_coe, Submodule.mem_span]\n    exact fun m hm => Submodule.sub_mem _ (hm ⟨p1, hp1, rfl⟩) (hm ⟨p2, hp2, rfl⟩)\n  · rintro v ⟨p2, hp2, hv⟩\n    exact ⟨p2, hp2, p, hp, hv⟩\n\n"}
{"name":"vectorSpan_eq_span_vsub_set_left_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nhp : Membership.mem s p\n⊢ Eq (vectorSpan k s) (Submodule.span k (Set.image (fun x => VSub.vsub p x) (SDiff.sdiff s (Singleton.singleton p))))","decl":"/-- The `vectorSpan` is the span of the pairwise subtractions with a given point on the left,\nexcluding the subtraction of that point from itself. -/\ntheorem vectorSpan_eq_span_vsub_set_left_ne {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k ((p -ᵥ ·) '' (s \\ {p})) := by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_left k hp, ← Set.insert_eq_of_mem hp, ←\n      Set.insert_diff_singleton, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n\n"}
{"name":"vectorSpan_eq_span_vsub_set_right_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nhp : Membership.mem s p\n⊢ Eq (vectorSpan k s) (Submodule.span k (Set.image (fun x => VSub.vsub x p) (SDiff.sdiff s (Singleton.singleton p))))","decl":"/-- The `vectorSpan` is the span of the pairwise subtractions with a given point on the right,\nexcluding the subtraction of that point from itself. -/\ntheorem vectorSpan_eq_span_vsub_set_right_ne {s : Set P} {p : P} (hp : p ∈ s) :\n    vectorSpan k s = Submodule.span k ((· -ᵥ p) '' (s \\ {p})) := by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_right k hp, ← Set.insert_eq_of_mem hp, ←\n      Set.insert_diff_singleton, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n\n"}
{"name":"vectorSpan_eq_span_vsub_finset_right_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : DecidableEq P\ninst✝ : DecidableEq V\ns : Finset P\np : P\nhp : Membership.mem s p\n⊢ Eq (vectorSpan k ↑s) (Submodule.span k ↑(Finset.image (fun x => VSub.vsub x p) (s.erase p)))","decl":"/-- The `vectorSpan` is the span of the pairwise subtractions with a given point on the right,\nexcluding the subtraction of that point from itself. -/\ntheorem vectorSpan_eq_span_vsub_finset_right_ne [DecidableEq P] [DecidableEq V] {s : Finset P}\n    {p : P} (hp : p ∈ s) :\n    vectorSpan k (s : Set P) = Submodule.span k ((s.erase p).image (· -ᵥ p)) := by\n  simp [vectorSpan_eq_span_vsub_set_right_ne _ (Finset.mem_coe.mpr hp)]\n\n"}
{"name":"vectorSpan_image_eq_span_vsub_set_left_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ns : Set ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (vectorSpan k (Set.image p s)) (Submodule.span k (Set.image (fun x => VSub.vsub (p i) x) (Set.image p (SDiff.sdiff s (Singleton.singleton i)))))","decl":"/-- The `vectorSpan` of the image of a function is the span of the pairwise subtractions with a\ngiven point on the left, excluding the subtraction of that point from itself. -/\ntheorem vectorSpan_image_eq_span_vsub_set_left_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :\n    vectorSpan k (p '' s) = Submodule.span k ((p i -ᵥ ·) '' (p '' (s \\ {i}))) := by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi, ←\n      Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n\n"}
{"name":"vectorSpan_image_eq_span_vsub_set_right_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ns : Set ι\ni : ι\nhi : Membership.mem s i\n⊢ Eq (vectorSpan k (Set.image p s)) (Submodule.span k (Set.image (fun x => VSub.vsub x (p i)) (Set.image p (SDiff.sdiff s (Singleton.singleton i)))))","decl":"/-- The `vectorSpan` of the image of a function is the span of the pairwise subtractions with a\ngiven point on the right, excluding the subtraction of that point from itself. -/\ntheorem vectorSpan_image_eq_span_vsub_set_right_ne (p : ι → P) {s : Set ι} {i : ι} (hi : i ∈ s) :\n    vectorSpan k (p '' s) = Submodule.span k ((· -ᵥ p i) '' (p '' (s \\ {i}))) := by\n  conv_lhs =>\n    rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_image_of_mem p hi), ← Set.insert_eq_of_mem hi,\n      ← Set.insert_diff_singleton, Set.image_insert_eq, Set.image_insert_eq]\n  simp [Submodule.span_insert_eq_span]\n\n"}
{"name":"vectorSpan_range_eq_span_range_vsub_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni0 : ι\n⊢ Eq (vectorSpan k (Set.range p)) (Submodule.span k (Set.range fun i => VSub.vsub (p i0) (p i)))","decl":"/-- The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the left. -/\ntheorem vectorSpan_range_eq_span_range_vsub_left (p : ι → P) (i0 : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => p i0 -ᵥ p i) := by\n  rw [vectorSpan_eq_span_vsub_set_left k (Set.mem_range_self i0), ← Set.range_comp]\n  congr\n\n"}
{"name":"vectorSpan_range_eq_span_range_vsub_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni0 : ι\n⊢ Eq (vectorSpan k (Set.range p)) (Submodule.span k (Set.range fun i => VSub.vsub (p i) (p i0)))","decl":"/-- The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right. -/\ntheorem vectorSpan_range_eq_span_range_vsub_right (p : ι → P) (i0 : ι) :\n    vectorSpan k (Set.range p) = Submodule.span k (Set.range fun i : ι => p i -ᵥ p i0) := by\n  rw [vectorSpan_eq_span_vsub_set_right k (Set.mem_range_self i0), ← Set.range_comp]\n  congr\n\n"}
{"name":"vectorSpan_range_eq_span_range_vsub_left_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni₀ : ι\n⊢ Eq (vectorSpan k (Set.range p)) (Submodule.span k (Set.range fun i => VSub.vsub (p i₀) (p ↑i)))","decl":"/-- The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the left, excluding the subtraction of that point from itself. -/\ntheorem vectorSpan_range_eq_span_range_vsub_left_ne (p : ι → P) (i₀ : ι) :\n    vectorSpan k (Set.range p) =\n      Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => p i₀ -ᵥ p i) := by\n  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_left_ne k _ (Set.mem_univ i₀)]\n  congr with v\n  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists,\n    Subtype.coe_mk]\n  constructor\n  · rintro ⟨x, ⟨i₁, ⟨⟨_, hi₁⟩, rfl⟩⟩, hv⟩\n    exact ⟨i₁, hi₁, hv⟩\n  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩\n\n"}
{"name":"vectorSpan_range_eq_span_range_vsub_right_ne","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nι : Type u_4\np : ι → P\ni₀ : ι\n⊢ Eq (vectorSpan k (Set.range p)) (Submodule.span k (Set.range fun i => VSub.vsub (p ↑i) (p i₀)))","decl":"/-- The `vectorSpan` of an indexed family is the span of the pairwise subtractions with a given\npoint on the right, excluding the subtraction of that point from itself. -/\ntheorem vectorSpan_range_eq_span_range_vsub_right_ne (p : ι → P) (i₀ : ι) :\n    vectorSpan k (Set.range p) =\n      Submodule.span k (Set.range fun i : { x // x ≠ i₀ } => p i -ᵥ p i₀) := by\n  rw [← Set.image_univ, vectorSpan_image_eq_span_vsub_set_right_ne k _ (Set.mem_univ i₀)]\n  congr with v\n  simp only [Set.mem_range, Set.mem_image, Set.mem_diff, Set.mem_singleton_iff, Subtype.exists,\n    Subtype.coe_mk]\n  constructor\n  · rintro ⟨x, ⟨i₁, ⟨⟨_, hi₁⟩, rfl⟩⟩, hv⟩\n    exact ⟨i₁, hi₁, hv⟩\n  · exact fun ⟨i₁, hi₁, hv⟩ => ⟨p i₁, ⟨i₁, ⟨Set.mem_univ _, hi₁⟩, rfl⟩, hv⟩\n\n"}
{"name":"affineSpan_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (↑(affineSpan k s)).Nonempty s.Nonempty","decl":"/-- The affine span of a set is nonempty if and only if that set is. -/\ntheorem affineSpan_nonempty : (affineSpan k s : Set P).Nonempty ↔ s.Nonempty :=\n  spanPoints_nonempty k s\n\n"}
{"name":"Set.Nonempty.affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\na✝ : s.Nonempty\n⊢ (↑(affineSpan k s)).Nonempty","decl":"alias ⟨_, _root_.Set.Nonempty.affineSpan⟩ := affineSpan_nonempty\n\n"}
{"name":"instNonemptySubtypeMemAffineSubspaceAffineSpanOfElem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : Nonempty ↑s\n⊢ Nonempty (Subtype fun x => Membership.mem (affineSpan k s) x)","decl":"/-- The affine span of a nonempty set is nonempty. -/\ninstance [Nonempty s] : Nonempty (affineSpan k s) :=\n  ((nonempty_coe_sort.1 ‹_›).affineSpan _).to_subtype\n\n"}
{"name":"affineSpan_eq_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (Eq (affineSpan k s) Bot.bot) (Eq s EmptyCollection.emptyCollection)","decl":"/-- The affine span of a set is `⊥` if and only if that set is empty. -/\n@[simp]\ntheorem affineSpan_eq_bot : affineSpan k s = ⊥ ↔ s = ∅ := by\n  rw [← not_iff_not, ← Ne, ← Ne, ← nonempty_iff_ne_bot, affineSpan_nonempty,\n    nonempty_iff_ne_empty]\n\n"}
{"name":"bot_lt_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (LT.lt Bot.bot (affineSpan k s)) s.Nonempty","decl":"@[simp]\ntheorem bot_lt_affineSpan : ⊥ < affineSpan k s ↔ s.Nonempty := by\n  rw [bot_lt_iff_ne_bot, nonempty_iff_ne_empty]\n  exact (affineSpan_eq_bot _).not\n\n"}
{"name":"affineSpan_induction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nx : P\ns : Set P\np : P → Prop\nh : Membership.mem (affineSpan k s) x\nmem : ∀ (x : P), Membership.mem s x → p x\nsmul_vsub_vadd : ∀ (c : k) (u v w : P), p u → p v → p w → p (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub u v)) w)\n⊢ p x","decl":"/-- An induction principle for span membership. If `p` holds for all elements of `s` and is\npreserved under certain affine combinations, then `p` holds for all elements of the span of `s`. -/\ntheorem affineSpan_induction {x : P} {s : Set P} {p : P → Prop} (h : x ∈ affineSpan k s)\n    (mem : ∀ x : P, x ∈ s → p x)\n    (smul_vsub_vadd : ∀ (c : k) (u v w : P), p u → p v → p w → p (c • (u -ᵥ v) +ᵥ w)) : p x :=\n  (affineSpan_le (Q := ⟨p, smul_vsub_vadd⟩)).mpr mem h\n\n"}
{"name":"affineSpan_induction'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : (x : P) → Membership.mem (affineSpan k s) x → Prop\nmem : ∀ (y : P) (hys : Membership.mem s y), p y ⋯\nsmul_vsub_vadd : ∀ (c : k) (u : P) (hu : Membership.mem (affineSpan k s) u) (v : P) (hv : Membership.mem (affineSpan k s) v) (w : P) (hw : Membership.mem (affineSpan k s) w), p u hu → p v hv → p w hw → p (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub u v)) w) ⋯\nx : P\nh : Membership.mem (affineSpan k s) x\n⊢ p x h","decl":"/-- A dependent version of `affineSpan_induction`. -/\n@[elab_as_elim]\ntheorem affineSpan_induction' {s : Set P} {p : ∀ x, x ∈ affineSpan k s → Prop}\n    (mem : ∀ (y) (hys : y ∈ s), p y (subset_affineSpan k _ hys))\n    (smul_vsub_vadd :\n      ∀ (c : k) (u hu v hv w hw),\n        p u hu →\n          p v hv → p w hw → p (c • (u -ᵥ v) +ᵥ w) (AffineSubspace.smul_vsub_vadd_mem _ _ hu hv hw))\n    {x : P} (h : x ∈ affineSpan k s) : p x h := by\n  refine Exists.elim ?_ fun (hx : x ∈ affineSpan k s) (hc : p x hx) => hc\n  -- Porting note: Lean couldn't infer the motive\n  refine affineSpan_induction (p := fun y => ∃ z, p y z) h ?_ ?_\n  · exact fun y hy => ⟨subset_affineSpan _ _ hy, mem y hy⟩\n  · exact fun c u v w hu hv hw =>\n      Exists.elim hu fun hu' hu =>\n        Exists.elim hv fun hv' hv =>\n          Exists.elim hw fun hw' hw =>\n            ⟨AffineSubspace.smul_vsub_vadd_mem _ _ hu' hv' hw',\n              smul_vsub_vadd _ _ _ _ _ _ _ hu hv hw⟩\n\n"}
{"name":"affineSpan_coe_preimage_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\nA : Set P\ninst✝ : Nonempty ↑A\n⊢ Eq (affineSpan k (Set.preimage Subtype.val A)) Top.top","decl":"/-- A set, considered as a subset of its spanned affine subspace, spans the whole subspace. -/\n@[simp]\ntheorem affineSpan_coe_preimage_eq_top (A : Set P) [Nonempty A] :\n    affineSpan k (((↑) : affineSpan k A → P) ⁻¹' A) = ⊤ := by\n  rw [eq_top_iff]\n  rintro ⟨x, hx⟩ -\n  refine affineSpan_induction' (fun y hy ↦ ?_) (fun c u hu v hv w hw ↦ ?_) hx\n  · exact subset_affineSpan _ _ hy\n  · exact AffineSubspace.smul_vsub_vadd_mem _ _\n\n"}
{"name":"affineSpan_singleton_union_vadd_eq_top_of_span_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set V\np : P\nh : Eq (Submodule.span k (Set.range Subtype.val)) Top.top\n⊢ Eq (affineSpan k (Union.union (Singleton.singleton p) (Set.image (fun v => HVAdd.hVAdd v p) s))) Top.top","decl":"/-- Suppose a set of vectors spans `V`.  Then a point `p`, together with those vectors added to `p`,\nspans `P`. -/\ntheorem affineSpan_singleton_union_vadd_eq_top_of_span_eq_top {s : Set V} (p : P)\n    (h : Submodule.span k (Set.range ((↑) : s → V)) = ⊤) :\n    affineSpan k ({p} ∪ (fun v => v +ᵥ p) '' s) = ⊤ := by\n  convert ext_of_direction_eq _\n      ⟨p, mem_affineSpan k (Set.mem_union_left _ (Set.mem_singleton _)), mem_top k V p⟩\n  rw [direction_affineSpan, direction_top,\n    vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ (Set.mem_singleton _) : p ∈ _),\n    eq_top_iff, ← h]\n  apply Submodule.span_mono\n  rintro v ⟨v', rfl⟩\n  use (v' : V) +ᵥ p\n  simp\n\n"}
{"name":"vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Eq (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (Submodule.span k (Singleton.singleton (VSub.vsub p₁ p₂)))","decl":"/-- The `vectorSpan` of two points is the span of their difference. -/\ntheorem vectorSpan_pair (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = k ∙ p₁ -ᵥ p₂ := by\n  simp_rw [vectorSpan_eq_span_vsub_set_left k (mem_insert p₁ _), image_pair, vsub_self,\n    Submodule.span_insert_zero]\n\n"}
{"name":"vectorSpan_pair_rev","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Eq (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (Submodule.span k (Singleton.singleton (VSub.vsub p₂ p₁)))","decl":"/-- The `vectorSpan` of two points is the span of their difference (reversed). -/\ntheorem vectorSpan_pair_rev (p₁ p₂ : P) : vectorSpan k ({p₁, p₂} : Set P) = k ∙ p₂ -ᵥ p₁ := by\n  rw [pair_comm, vectorSpan_pair]\n\n"}
{"name":"vsub_mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (VSub.vsub p₁ p₂)","decl":"/-- The difference between two points lies in their `vectorSpan`. -/\ntheorem vsub_mem_vectorSpan_pair (p₁ p₂ : P) : p₁ -ᵥ p₂ ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  vsub_mem_vectorSpan _ (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n\n"}
{"name":"vsub_rev_mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (VSub.vsub p₂ p₁)","decl":"/-- The difference between two points (reversed) lies in their `vectorSpan`. -/\ntheorem vsub_rev_mem_vectorSpan_pair (p₁ p₂ : P) : p₂ -ᵥ p₁ ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  vsub_mem_vectorSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _)) (Set.mem_insert _ _)\n\n"}
{"name":"smul_vsub_mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HSMul.hSMul r (VSub.vsub p₁ p₂))","decl":"/-- A multiple of the difference between two points lies in their `vectorSpan`. -/\ntheorem smul_vsub_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :\n    r • (p₁ -ᵥ p₂) ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  Submodule.smul_mem _ _ (vsub_mem_vectorSpan_pair k p₁ p₂)\n\n"}
{"name":"smul_vsub_rev_mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HSMul.hSMul r (VSub.vsub p₂ p₁))","decl":"/-- A multiple of the difference between two points (reversed) lies in their `vectorSpan`. -/\ntheorem smul_vsub_rev_mem_vectorSpan_pair (r : k) (p₁ p₂ : P) :\n    r • (p₂ -ᵥ p₁) ∈ vectorSpan k ({p₁, p₂} : Set P) :=\n  Submodule.smul_mem _ _ (vsub_rev_mem_vectorSpan_pair k p₁ p₂)\n\n"}
{"name":"mem_vectorSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\nv : V\n⊢ Iff (Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) v) (Exists fun r => Eq (HSMul.hSMul r (VSub.vsub p₁ p₂)) v)","decl":"/-- A vector lies in the `vectorSpan` of two points if and only if it is a multiple of their\ndifference. -/\ntheorem mem_vectorSpan_pair {p₁ p₂ : P} {v : V} :\n    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, r • (p₁ -ᵥ p₂) = v := by\n  rw [vectorSpan_pair, Submodule.mem_span_singleton]\n\n"}
{"name":"mem_vectorSpan_pair_rev","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\nv : V\n⊢ Iff (Membership.mem (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) v) (Exists fun r => Eq (HSMul.hSMul r (VSub.vsub p₂ p₁)) v)","decl":"/-- A vector lies in the `vectorSpan` of two points if and only if it is a multiple of their\ndifference (reversed). -/\ntheorem mem_vectorSpan_pair_rev {p₁ p₂ : P} {v : V} :\n    v ∈ vectorSpan k ({p₁, p₂} : Set P) ↔ ∃ r : k, r • (p₂ -ᵥ p₁) = v := by\n  rw [vectorSpan_pair_rev, Submodule.mem_span_singleton]\n\n"}
{"name":"left_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) p₁","decl":"/-- The first of two points lies in their affine span. -/\ntheorem left_mem_affineSpan_pair (p₁ p₂ : P) : p₁ ∈ line[k, p₁, p₂] :=\n  mem_affineSpan _ (Set.mem_insert _ _)\n\n"}
{"name":"right_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) p₂","decl":"/-- The second of two points lies in their affine span. -/\ntheorem right_mem_affineSpan_pair (p₁ p₂ : P) : p₂ ∈ line[k, p₁, p₂] :=\n  mem_affineSpan _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))\n\n"}
{"name":"AffineMap.lineMap_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) ((AffineMap.lineMap p₁ p₂) r)","decl":"/-- A combination of two points expressed with `lineMap` lies in their affine span. -/\ntheorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    AffineMap.lineMap p₁ p₂ r ∈ line[k, p₁, p₂] :=\n  AffineMap.lineMap_mem _ (left_mem_affineSpan_pair _ _ _) (right_mem_affineSpan_pair _ _ _)\n\n"}
{"name":"AffineMap.lineMap_rev_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) ((AffineMap.lineMap p₂ p₁) r)","decl":"/-- A combination of two points expressed with `lineMap` (with the two points reversed) lies in\ntheir affine span. -/\ntheorem AffineMap.lineMap_rev_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    AffineMap.lineMap p₂ p₁ r ∈ line[k, p₁, p₂] :=\n  AffineMap.lineMap_mem _ (right_mem_affineSpan_pair _ _ _) (left_mem_affineSpan_pair _ _ _)\n\n"}
{"name":"smul_vsub_vadd_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p₂ p₁)) p₁)","decl":"/-- A multiple of the difference of two points added to the first point lies in their affine\nspan. -/\ntheorem smul_vsub_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    r • (p₂ -ᵥ p₁) +ᵥ p₁ ∈ line[k, p₁, p₂] :=\n  AffineMap.lineMap_mem_affineSpan_pair _ _ _\n\n"}
{"name":"smul_vsub_rev_vadd_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\nr : k\np₁ p₂ : P\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p₁ p₂)) p₂)","decl":"/-- A multiple of the difference of two points added to the second point lies in their affine\nspan. -/\ntheorem smul_vsub_rev_vadd_mem_affineSpan_pair (r : k) (p₁ p₂ : P) :\n    r • (p₁ -ᵥ p₂) +ᵥ p₂ ∈ line[k, p₁, p₂] :=\n  AffineMap.lineMap_rev_mem_affineSpan_pair _ _ _\n\n"}
{"name":"vadd_left_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\nv : V\n⊢ Iff (Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HVAdd.hVAdd v p₁)) (Exists fun r => Eq (HSMul.hSMul r (VSub.vsub p₂ p₁)) v)","decl":"/-- A vector added to the first point lies in the affine span of two points if and only if it is\na multiple of their difference. -/\ntheorem vadd_left_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :\n    v +ᵥ p₁ ∈ line[k, p₁, p₂] ↔ ∃ r : k, r • (p₂ -ᵥ p₁) = v := by\n  rw [vadd_mem_iff_mem_direction _ (left_mem_affineSpan_pair _ _ _), direction_affineSpan,\n    mem_vectorSpan_pair_rev]\n\n"}
{"name":"vadd_right_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\nv : V\n⊢ Iff (Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (HVAdd.hVAdd v p₂)) (Exists fun r => Eq (HSMul.hSMul r (VSub.vsub p₁ p₂)) v)","decl":"/-- A vector added to the second point lies in the affine span of two points if and only if it is\na multiple of their difference. -/\ntheorem vadd_right_mem_affineSpan_pair {p₁ p₂ : P} {v : V} :\n    v +ᵥ p₂ ∈ line[k, p₁, p₂] ↔ ∃ r : k, r • (p₁ -ᵥ p₂) = v := by\n  rw [vadd_mem_iff_mem_direction _ (right_mem_affineSpan_pair _ _ _), direction_affineSpan,\n    mem_vectorSpan_pair]\n\n"}
{"name":"affineSpan_pair_le_of_mem_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\ns : AffineSubspace k P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\n⊢ LE.le (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) s","decl":"/-- The span of two points that lie in an affine subspace is contained in that subspace. -/\ntheorem affineSpan_pair_le_of_mem_of_mem {p₁ p₂ : P} {s : AffineSubspace k P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) : line[k, p₁, p₂] ≤ s := by\n  rw [affineSpan_le, Set.insert_subset_iff, Set.singleton_subset_iff]\n  exact ⟨hp₁, hp₂⟩\n\n"}
{"name":"affineSpan_pair_le_of_left_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Membership.mem (affineSpan k (Insert.insert p₂ (Singleton.singleton p₃))) p₁\n⊢ LE.le (affineSpan k (Insert.insert p₁ (Singleton.singleton p₃))) (affineSpan k (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- One line is contained in another differing in the first point if the first point of the first\nline is contained in the second line. -/\ntheorem affineSpan_pair_le_of_left_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :\n    line[k, p₁, p₃] ≤ line[k, p₂, p₃] :=\n  affineSpan_pair_le_of_mem_of_mem h (right_mem_affineSpan_pair _ _ _)\n\n"}
{"name":"affineSpan_pair_le_of_right_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Membership.mem (affineSpan k (Insert.insert p₂ (Singleton.singleton p₃))) p₁\n⊢ LE.le (affineSpan k (Insert.insert p₂ (Singleton.singleton p₁))) (affineSpan k (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- One line is contained in another differing in the second point if the second point of the\nfirst line is contained in the second line. -/\ntheorem affineSpan_pair_le_of_right_mem {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :\n    line[k, p₂, p₁] ≤ line[k, p₂, p₃] :=\n  affineSpan_pair_le_of_mem_of_mem (left_mem_affineSpan_pair _ _ _) h\n\n"}
{"name":"affineSpan_mono","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (affineSpan k s₁) (affineSpan k s₂)","decl":"/-- `affineSpan` is monotone. -/\n@[gcongr, mono]\ntheorem affineSpan_mono {s₁ s₂ : Set P} (h : s₁ ⊆ s₂) : affineSpan k s₁ ≤ affineSpan k s₂ :=\n  spanPoints_subset_coe_of_subset_coe (Set.Subset.trans h (subset_affineSpan k _))\n\n"}
{"name":"affineSpan_insert_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\nps : Set P\n⊢ Eq (affineSpan k (Insert.insert p ↑(affineSpan k ps))) (affineSpan k (Insert.insert p ps))","decl":"/-- Taking the affine span of a set, adding a point and taking the span again produces the same\nresults as adding the point to the set and taking the span. -/\ntheorem affineSpan_insert_affineSpan (p : P) (ps : Set P) :\n    affineSpan k (insert p (affineSpan k ps : Set P)) = affineSpan k (insert p ps) := by\n  rw [Set.insert_eq, Set.insert_eq, span_union, span_union, affineSpan_coe]\n\n"}
{"name":"affineSpan_insert_eq_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\nps : Set P\nh : Membership.mem (affineSpan k ps) p\n⊢ Eq (affineSpan k (Insert.insert p ps)) (affineSpan k ps)","decl":"/-- If a point is in the affine span of a set, adding it to that set does not change the affine\nspan. -/\ntheorem affineSpan_insert_eq_affineSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :\n    affineSpan k (insert p ps) = affineSpan k ps := by\n  rw [← mem_coe] at h\n  rw [← affineSpan_insert_affineSpan, Set.insert_eq_of_mem h, affineSpan_coe]\n\n"}
{"name":"vectorSpan_insert_eq_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\nps : Set P\nh : Membership.mem (affineSpan k ps) p\n⊢ Eq (vectorSpan k (Insert.insert p ps)) (vectorSpan k ps)","decl":"/-- If a point is in the affine span of a set, adding it to that set does not change the vector\nspan. -/\ntheorem vectorSpan_insert_eq_vectorSpan {p : P} {ps : Set P} (h : p ∈ affineSpan k ps) :\n    vectorSpan k (insert p ps) = vectorSpan k ps := by\n  simp_rw [← direction_affineSpan, affineSpan_insert_eq_affineSpan _ h]\n\n"}
{"name":"affineSpan_le_toAffineSubspace_span","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Set V\n⊢ LE.le (affineSpan k s) (Submodule.span k s).toAffineSubspace","decl":"/-- When the affine space is also a vector space, the affine span is contained within the linear\nspan. -/\nlemma affineSpan_le_toAffineSubspace_span {s : Set V} :\n    affineSpan k s ≤ (Submodule.span k s).toAffineSubspace := by\n  intro x hx\n  simp only [SetLike.mem_coe, Submodule.mem_toAffineSubspace]\n  induction hx using affineSpan_induction' with\n  | mem x hx => exact Submodule.subset_span hx\n  | smul_vsub_vadd c u _ v _ w _ hu hv hw =>\n    simp only [vsub_eq_sub, vadd_eq_add]\n    apply Submodule.add_mem _ _ hw\n    exact Submodule.smul_mem _ _ (Submodule.sub_mem _ hu hv)\n\n"}
{"name":"affineSpan_subset_span","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Set V\n⊢ HasSubset.Subset ↑(affineSpan k s) ↑(Submodule.span k s)","decl":"lemma affineSpan_subset_span {s : Set V} :\n    (affineSpan k s : Set V) ⊆  Submodule.span k s :=\n  affineSpan_le_toAffineSubspace_span\n\n-- TODO: We want this to be simp, but `affineSpan` gets simped away to `spanPoints`!\n-- Let's delete `spanPoints`\n"}
{"name":"affineSpan_insert_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns : Set V\n⊢ Eq ↑(affineSpan k (Insert.insert 0 s)) ↑(Submodule.span k s)","decl":"lemma affineSpan_insert_zero (s : Set V) :\n    (affineSpan k (insert 0 s) : Set V) = Submodule.span k s := by\n  rw [← Submodule.span_insert_zero]\n  refine affineSpan_subset_span.antisymm ?_\n  rw [← vectorSpan_add_self, vectorSpan_def]\n  refine Subset.trans ?_ <| subset_add_left _ <| mem_insert ..\n  gcongr\n  exact subset_sub_left <| mem_insert ..\n\n"}
{"name":"AffineSubspace.direction_sup","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns1 s2 : AffineSubspace k P\np1 p2 : P\nhp1 : Membership.mem s1 p1\nhp2 : Membership.mem s2 p2\n⊢ Eq (Max.max s1 s2).direction (Max.max (Max.max s1.direction s2.direction) (Submodule.span k (Singleton.singleton (VSub.vsub p2 p1))))","decl":"/-- The direction of the sup of two nonempty affine subspaces is the sup of the two directions and\nof any one difference between points in the two subspaces. -/\ntheorem direction_sup {s1 s2 : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s1) (hp2 : p2 ∈ s2) :\n    (s1 ⊔ s2).direction = s1.direction ⊔ s2.direction ⊔ k ∙ p2 -ᵥ p1 := by\n  refine le_antisymm ?_ ?_\n  · change (affineSpan k ((s1 : Set P) ∪ s2)).direction ≤ _\n    rw [← mem_coe] at hp1\n    rw [direction_affineSpan, vectorSpan_eq_span_vsub_set_right k (Set.mem_union_left _ hp1),\n      Submodule.span_le]\n    rintro v ⟨p3, hp3, rfl⟩\n    cases' hp3 with hp3 hp3\n    · rw [sup_assoc, sup_comm, SetLike.mem_coe, Submodule.mem_sup]\n      use 0, Submodule.zero_mem _, p3 -ᵥ p1, vsub_mem_direction hp3 hp1\n      rw [zero_add]\n    · rw [sup_assoc, SetLike.mem_coe, Submodule.mem_sup]\n      use 0, Submodule.zero_mem _, p3 -ᵥ p1\n      rw [and_comm, zero_add]\n      use rfl\n      rw [← vsub_add_vsub_cancel p3 p2 p1, Submodule.mem_sup]\n      use p3 -ᵥ p2, vsub_mem_direction hp3 hp2, p2 -ᵥ p1, Submodule.mem_span_singleton_self _\n  · refine sup_le (sup_direction_le _ _) ?_\n    rw [direction_eq_vectorSpan, vectorSpan_def]\n    exact\n      sInf_le_sInf fun p hp =>\n        Set.Subset.trans\n          (Set.singleton_subset_iff.2\n            (vsub_mem_vsub (mem_spanPoints k p2 _ (Set.mem_union_right _ hp2))\n              (mem_spanPoints k p1 _ (Set.mem_union_left _ hp1))))\n          hp\n\n"}
{"name":"AffineSubspace.direction_affineSpan_insert","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np1 p2 : P\nhp1 : Membership.mem s p1\n⊢ Eq (affineSpan k (Insert.insert p2 ↑s)).direction (Max.max (Submodule.span k (Singleton.singleton (VSub.vsub p2 p1))) s.direction)","decl":"/-- The direction of the span of the result of adding a point to a nonempty affine subspace is the\nsup of the direction of that subspace and of any one difference between that point and a point in\nthe subspace. -/\ntheorem direction_affineSpan_insert {s : AffineSubspace k P} {p1 p2 : P} (hp1 : p1 ∈ s) :\n    (affineSpan k (insert p2 (s : Set P))).direction =\n    Submodule.span k {p2 -ᵥ p1} ⊔ s.direction := by\n  rw [sup_comm, ← Set.union_singleton, ← coe_affineSpan_singleton k V p2]\n  change (s ⊔ affineSpan k {p2}).direction = _\n  rw [direction_sup hp1 (mem_affineSpan k (Set.mem_singleton _)), direction_affineSpan]\n  simp\n\n"}
{"name":"AffineSubspace.mem_affineSpan_insert_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np1 : P\nhp1 : Membership.mem s p1\np2 p : P\n⊢ Iff (Membership.mem (affineSpan k (Insert.insert p2 ↑s)) p) (Exists fun r => Exists fun p0 => And (Membership.mem s p0) (Eq p (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p2 p1)) p0)))","decl":"/-- Given a point `p1` in an affine subspace `s`, and a point `p2`, a point `p` is in the span of\n`s` with `p2` added if and only if it is a multiple of `p2 -ᵥ p1` added to a point in `s`. -/\ntheorem mem_affineSpan_insert_iff {s : AffineSubspace k P} {p1 : P} (hp1 : p1 ∈ s) (p2 p : P) :\n    p ∈ affineSpan k (insert p2 (s : Set P)) ↔\n      ∃ r : k, ∃ p0 ∈ s, p = r • (p2 -ᵥ p1 : V) +ᵥ p0 := by\n  rw [← mem_coe] at hp1\n  rw [← vsub_right_mem_direction_iff_mem (mem_affineSpan k (Set.mem_insert_of_mem _ hp1)),\n    direction_affineSpan_insert hp1, Submodule.mem_sup]\n  constructor\n  · rintro ⟨v1, hv1, v2, hv2, hp⟩\n    rw [Submodule.mem_span_singleton] at hv1\n    rcases hv1 with ⟨r, rfl⟩\n    use r, v2 +ᵥ p1, vadd_mem_of_mem_direction hv2 hp1\n    symm at hp\n    rw [← sub_eq_zero, ← vsub_vadd_eq_vsub_sub, vsub_eq_zero_iff_eq] at hp\n    rw [hp, vadd_vadd]\n  · rintro ⟨r, p3, hp3, rfl⟩\n    use r • (p2 -ᵥ p1), Submodule.mem_span_singleton.2 ⟨r, rfl⟩, p3 -ᵥ p1,\n      vsub_mem_direction hp3 hp1\n    rw [vadd_vsub_assoc]\n\n"}
{"name":"AffineMap.vectorSpan_image_eq_submodule_map","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : Set P₁\n⊢ Eq (Submodule.map f.linear (vectorSpan k s)) (vectorSpan k (Set.image (⇑f) s))","decl":"@[simp]\ntheorem AffineMap.vectorSpan_image_eq_submodule_map {s : Set P₁} :\n    Submodule.map f.linear (vectorSpan k s) = vectorSpan k (f '' s) := by\n  rw [vectorSpan_def, vectorSpan_def, f.image_vsub_image, Submodule.span_image]\n  -- Porting note: Lean unfolds things too far with `simp` here.\n\n"}
{"name":"AffineSubspace.coe_map","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₁\n⊢ Eq (↑(AffineSubspace.map f s)) (Set.image ⇑f ↑s)","decl":"@[simp]\ntheorem coe_map (s : AffineSubspace k P₁) : (s.map f : Set P₂) = f '' s :=\n  rfl\n\n"}
{"name":"AffineSubspace.mem_map","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nx : P₂\ns : AffineSubspace k P₁\n⊢ Iff (Membership.mem (AffineSubspace.map f s) x) (Exists fun y => And (Membership.mem s y) (Eq (f y) x))","decl":"@[simp]\ntheorem mem_map {f : P₁ →ᵃ[k] P₂} {x : P₂} {s : AffineSubspace k P₁} :\n    x ∈ s.map f ↔ ∃ y ∈ s, f y = x :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.mem_map_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nx : P₁\ns : AffineSubspace k P₁\nh : Membership.mem s x\n⊢ Membership.mem (AffineSubspace.map f s) (f x)","decl":"theorem mem_map_of_mem {x : P₁} {s : AffineSubspace k P₁} (h : x ∈ s) : f x ∈ s.map f :=\n  Set.mem_image_of_mem _ h\n\n-- The simpNF linter says that the LHS can be simplified via `AffineSubspace.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"AffineSubspace.mem_map_iff_mem_of_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nx : P₁\ns : AffineSubspace k P₁\nhf : Function.Injective ⇑f\n⊢ Iff (Membership.mem (AffineSubspace.map f s) (f x)) (Membership.mem s x)","decl":"@[simp 1100, nolint simpNF]\ntheorem mem_map_iff_mem_of_injective {f : P₁ →ᵃ[k] P₂} {x : P₁} {s : AffineSubspace k P₁}\n    (hf : Function.Injective f) : f x ∈ s.map f ↔ x ∈ s :=\n  hf.mem_set_image\n\n"}
{"name":"AffineSubspace.map_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\n⊢ Eq (AffineSubspace.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot : (⊥ : AffineSubspace k P₁).map f = ⊥ :=\n  coe_injective <| image_empty f\n\n"}
{"name":"AffineSubspace.map_eq_bot_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₁\n⊢ Iff (Eq (AffineSubspace.map f s) Bot.bot) (Eq s Bot.bot)","decl":"@[simp]\ntheorem map_eq_bot_iff {s : AffineSubspace k P₁} : s.map f = ⊥ ↔ s = ⊥ := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rwa [← coe_eq_bot_iff, coe_map, image_eq_empty, coe_eq_bot_iff] at h\n  · rw [h, map_bot]\n\n"}
{"name":"AffineSubspace.map_id","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ns : AffineSubspace k P₁\n⊢ Eq (AffineSubspace.map (AffineMap.id k P₁) s) s","decl":"@[simp]\ntheorem map_id (s : AffineSubspace k P₁) : s.map (AffineMap.id k P₁) = s :=\n  coe_injective <| image_id _\n\n"}
{"name":"AffineSubspace.map_map","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\nV₃ : Type u_6\nP₃ : Type u_7\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V₁\ninst✝⁷ : Module k V₁\ninst✝⁶ : AddTorsor V₁ P₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₂ P₂\ninst✝² : AddCommGroup V₃\ninst✝¹ : Module k V₃\ninst✝ : AddTorsor V₃ P₃\ns : AffineSubspace k P₁\nf : AffineMap k P₁ P₂\ng : AffineMap k P₂ P₃\n⊢ Eq (AffineSubspace.map g (AffineSubspace.map f s)) (AffineSubspace.map (g.comp f) s)","decl":"theorem map_map (s : AffineSubspace k P₁) (f : P₁ →ᵃ[k] P₂) (g : P₂ →ᵃ[k] P₃) :\n    (s.map f).map g = s.map (g.comp f) :=\n  coe_injective <| image_image _ _ _\n\n"}
{"name":"AffineSubspace.map_direction","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₁\n⊢ Eq (AffineSubspace.map f s).direction (Submodule.map f.linear s.direction)","decl":"@[simp]\ntheorem map_direction (s : AffineSubspace k P₁) :\n    (s.map f).direction = s.direction.map f.linear := by\n  rw [direction_eq_vectorSpan, direction_eq_vectorSpan, coe_map,\n    AffineMap.vectorSpan_image_eq_submodule_map]\n  -- Porting note: again, Lean unfolds too aggressively with `simp`\n\n"}
{"name":"AffineSubspace.map_span","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : Set P₁\n⊢ Eq (AffineSubspace.map f (affineSpan k s)) (affineSpan k (Set.image (⇑f) s))","decl":"theorem map_span (s : Set P₁) : (affineSpan k s).map f = affineSpan k (f '' s) := by\n  rcases s.eq_empty_or_nonempty with (rfl | ⟨p, hp⟩)\n  · rw [image_empty, span_empty, span_empty, map_bot]\n    -- Porting note: I don't know exactly why this `simp` was broken.\n  apply ext_of_direction_eq\n  · simp [direction_affineSpan]\n  · exact\n      ⟨f p, mem_image_of_mem f (subset_affineSpan k _ hp),\n        subset_affineSpan k _ (mem_image_of_mem f hp)⟩\n\n"}
{"name":"AffineSubspace.inclusion_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module k V₁\ninst✝² : AddTorsor V₁ P₁\nS₁ S₂ : AffineSubspace k P₁\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem S₁ x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₂ x)\nh : LE.le S₁ S₂\n⊢ Eq (AffineSubspace.inclusion h).linear (Submodule.inclusion ⋯)","decl":"/-- Affine map from a smaller to a larger subspace of the same space.\n\nThis is the affine version of `Submodule.inclusion`. -/\n@[simps linear]\ndef inclusion (h : S₁ ≤ S₂) : S₁ →ᵃ[k] S₂ where\n  toFun := Set.inclusion h\n  linear := Submodule.inclusion <| AffineSubspace.direction_le h\n  map_vadd' := fun ⟨_,_⟩ ⟨_,_⟩ => rfl\n\n"}
{"name":"AffineSubspace.coe_inclusion_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module k V₁\ninst✝² : AddTorsor V₁ P₁\nS₁ S₂ : AffineSubspace k P₁\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem S₁ x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₂ x)\nh : LE.le S₁ S₂\nx : Subtype fun x => Membership.mem S₁ x\n⊢ Eq ↑((AffineSubspace.inclusion h) x) ↑x","decl":"@[simp]\ntheorem coe_inclusion_apply (h : S₁ ≤ S₂) (x : S₁) : (inclusion h x : P₁) = x :=\n  rfl\n\n"}
{"name":"AffineSubspace.inclusion_rfl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddTorsor V₁ P₁\nS₁ : AffineSubspace k P₁\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₁ x)\n⊢ Eq (AffineSubspace.inclusion ⋯) (AffineMap.id k (Subtype fun x => Membership.mem S₁ x))","decl":"@[simp]\ntheorem inclusion_rfl : inclusion (le_refl S₁) = AffineMap.id k S₁ := rfl\n\n"}
{"name":"AffineMap.map_top_of_surjective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nhf : Function.Surjective ⇑f\n⊢ Eq (AffineSubspace.map f Top.top) Top.top","decl":"@[simp]\ntheorem map_top_of_surjective (hf : Function.Surjective f) : AffineSubspace.map f ⊤ = ⊤ := by\n  rw [AffineSubspace.ext_iff]\n  exact image_univ_of_surjective hf\n\n"}
{"name":"AffineMap.span_eq_top_of_surjective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : Set P₁\nhf : Function.Surjective ⇑f\nh : Eq (affineSpan k s) Top.top\n⊢ Eq (affineSpan k (Set.image (⇑f) s)) Top.top","decl":"theorem span_eq_top_of_surjective {s : Set P₁} (hf : Function.Surjective f)\n    (h : affineSpan k s = ⊤) : affineSpan k (f '' s) = ⊤ := by\n  rw [← AffineSubspace.map_span, h, map_top_of_surjective f hf]\n\n"}
{"name":"AffineEquiv.linear_ofEq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module k V₁\ninst✝² : AddTorsor V₁ P₁\nS₁ S₂ : AffineSubspace k P₁\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem S₁ x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₂ x)\nh : Eq S₁ S₂\n⊢ Eq (AffineEquiv.ofEq S₁ S₂ h).linear (LinearEquiv.ofEq S₁.direction S₂.direction ⋯)","decl":"/-- Affine equivalence between two equal affine subspace.\n\nThis is the affine version of `LinearEquiv.ofEq`. -/\n@[simps linear]\ndef ofEq (h : S₁ = S₂) : S₁ ≃ᵃ[k] S₂ where\n  toEquiv := Equiv.Set.ofEq <| congr_arg _ h\n  linear := .ofEq _ _ <| congr_arg _ h\n  map_vadd' := fun ⟨_,_⟩ ⟨_,_⟩ => rfl\n\n"}
{"name":"AffineEquiv.coe_ofEq_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module k V₁\ninst✝² : AddTorsor V₁ P₁\nS₁ S₂ : AffineSubspace k P₁\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem S₁ x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₂ x)\nh : Eq S₁ S₂\nx : Subtype fun x => Membership.mem S₁ x\n⊢ Eq ↑((AffineEquiv.ofEq S₁ S₂ h) x) ↑x","decl":"@[simp]\ntheorem coe_ofEq_apply (h : S₁ = S₂) (x : S₁) : (ofEq S₁ S₂ h x : P₁) = x :=\n  rfl\n\n"}
{"name":"AffineEquiv.ofEq_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V₁\ninst✝³ : Module k V₁\ninst✝² : AddTorsor V₁ P₁\nS₁ S₂ : AffineSubspace k P₁\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem S₁ x)\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₂ x)\nh : Eq S₁ S₂\n⊢ Eq (AffineEquiv.ofEq S₁ S₂ h).symm (AffineEquiv.ofEq S₂ S₁ ⋯)","decl":"@[simp]\ntheorem ofEq_symm (h : S₁ = S₂) : (ofEq S₁ S₂ h).symm = ofEq S₂ S₁ h.symm := by\n  ext\n  rfl\n\n"}
{"name":"AffineEquiv.ofEq_rfl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddTorsor V₁ P₁\nS₁ : AffineSubspace k P₁\ninst✝ : Nonempty (Subtype fun x => Membership.mem S₁ x)\n⊢ Eq (AffineEquiv.ofEq S₁ S₁ ⋯) (AffineEquiv.refl k (Subtype fun x => Membership.mem S₁ x))","decl":"@[simp]\ntheorem ofEq_rfl : ofEq S₁ S₁ rfl = AffineEquiv.refl k S₁ := rfl\n\n"}
{"name":"AffineEquiv.span_eq_top_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ns : Set P₁\ne : AffineEquiv k P₁ P₂\n⊢ Iff (Eq (affineSpan k s) Top.top) (Eq (affineSpan k (Set.image (⇑e) s)) Top.top)","decl":"theorem span_eq_top_iff {s : Set P₁} (e : P₁ ≃ᵃ[k] P₂) :\n    affineSpan k s = ⊤ ↔ affineSpan k (e '' s) = ⊤ := by\n  refine ⟨(e : P₁ →ᵃ[k] P₂).span_eq_top_of_surjective e.surjective, ?_⟩\n  intro h\n  have : s = e.symm '' (e '' s) := by rw [← image_comp]; simp\n  rw [this]\n  exact (e.symm : P₂ →ᵃ[k] P₁).span_eq_top_of_surjective e.symm.surjective h\n\n"}
{"name":"AffineSubspace.coe_comap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₂\n⊢ Eq (↑(AffineSubspace.comap f s)) (Set.preimage ⇑f ↑s)","decl":"@[simp]\ntheorem coe_comap (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₂) : (s.comap f : Set P₁) = f ⁻¹' ↑s :=\n  rfl\n\n"}
{"name":"AffineSubspace.mem_comap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\nx : P₁\ns : AffineSubspace k P₂\n⊢ Iff (Membership.mem (AffineSubspace.comap f s) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_comap {f : P₁ →ᵃ[k] P₂} {x : P₁} {s : AffineSubspace k P₂} : x ∈ s.comap f ↔ f x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"AffineSubspace.comap_mono","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns t : AffineSubspace k P₂\na✝ : LE.le s t\n⊢ LE.le (AffineSubspace.comap f s) (AffineSubspace.comap f t)","decl":"theorem comap_mono {f : P₁ →ᵃ[k] P₂} {s t : AffineSubspace k P₂} : s ≤ t → s.comap f ≤ t.comap f :=\n  preimage_mono\n\n"}
{"name":"AffineSubspace.comap_top","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\n⊢ Eq (AffineSubspace.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top {f : P₁ →ᵃ[k] P₂} : (⊤ : AffineSubspace k P₂).comap f = ⊤ := by\n  rw [AffineSubspace.ext_iff]\n  exact preimage_univ (f := f)\n\n"}
{"name":"AffineSubspace.comap_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\n⊢ Eq (AffineSubspace.comap f Bot.bot) Bot.bot","decl":"@[simp] theorem comap_bot (f : P₁ →ᵃ[k] P₂) : comap f ⊥ = ⊥ := rfl\n\n"}
{"name":"AffineSubspace.comap_id","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V₁\ninst✝¹ : Module k V₁\ninst✝ : AddTorsor V₁ P₁\ns : AffineSubspace k P₁\n⊢ Eq (AffineSubspace.comap (AffineMap.id k P₁) s) s","decl":"@[simp]\ntheorem comap_id (s : AffineSubspace k P₁) : s.comap (AffineMap.id k P₁) = s :=\n  rfl\n\n"}
{"name":"AffineSubspace.comap_comap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\nV₃ : Type u_6\nP₃ : Type u_7\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V₁\ninst✝⁷ : Module k V₁\ninst✝⁶ : AddTorsor V₁ P₁\ninst✝⁵ : AddCommGroup V₂\ninst✝⁴ : Module k V₂\ninst✝³ : AddTorsor V₂ P₂\ninst✝² : AddCommGroup V₃\ninst✝¹ : Module k V₃\ninst✝ : AddTorsor V₃ P₃\ns : AffineSubspace k P₃\nf : AffineMap k P₁ P₂\ng : AffineMap k P₂ P₃\n⊢ Eq (AffineSubspace.comap f (AffineSubspace.comap g s)) (AffineSubspace.comap (g.comp f) s)","decl":"theorem comap_comap (s : AffineSubspace k P₃) (f : P₁ →ᵃ[k] P₂) (g : P₂ →ᵃ[k] P₃) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n\n-- lemmas about map and comap derived from the galois connection\n"}
{"name":"AffineSubspace.map_le_iff_le_comap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₁\nt : AffineSubspace k P₂\n⊢ Iff (LE.le (AffineSubspace.map f s) t) (LE.le s (AffineSubspace.comap f t))","decl":"theorem map_le_iff_le_comap {f : P₁ →ᵃ[k] P₂} {s : AffineSubspace k P₁} {t : AffineSubspace k P₂} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  image_subset_iff\n\n"}
{"name":"AffineSubspace.gc_map_comap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\n⊢ GaloisConnection (AffineSubspace.map f) (AffineSubspace.comap f)","decl":"theorem gc_map_comap (f : P₁ →ᵃ[k] P₂) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"AffineSubspace.map_comap_le","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₂\n⊢ LE.le (AffineSubspace.map f (AffineSubspace.comap f s)) s","decl":"theorem map_comap_le (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₂) : (s.comap f).map f ≤ s :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"AffineSubspace.le_comap_map","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineMap k P₁ P₂\ns : AffineSubspace k P₁\n⊢ LE.le s (AffineSubspace.comap f (AffineSubspace.map f s))","decl":"theorem le_comap_map (f : P₁ →ᵃ[k] P₂) (s : AffineSubspace k P₁) : s ≤ (s.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"AffineSubspace.map_sup","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ns t : AffineSubspace k P₁\nf : AffineMap k P₁ P₂\n⊢ Eq (AffineSubspace.map f (Max.max s t)) (Max.max (AffineSubspace.map f s) (AffineSubspace.map f t))","decl":"theorem map_sup (s t : AffineSubspace k P₁) (f : P₁ →ᵃ[k] P₂) : (s ⊔ t).map f = s.map f ⊔ t.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"AffineSubspace.map_iSup","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nι : Sort u_8\nf : AffineMap k P₁ P₂\ns : ι → AffineSubspace k P₁\n⊢ Eq (AffineSubspace.map f (iSup s)) (iSup fun i => AffineSubspace.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : P₁ →ᵃ[k] P₂) (s : ι → AffineSubspace k P₁) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"AffineSubspace.comap_inf","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ns t : AffineSubspace k P₂\nf : AffineMap k P₁ P₂\n⊢ Eq (AffineSubspace.comap f (Min.min s t)) (Min.min (AffineSubspace.comap f s) (AffineSubspace.comap f t))","decl":"theorem comap_inf (s t : AffineSubspace k P₂) (f : P₁ →ᵃ[k] P₂) :\n    (s ⊓ t).comap f = s.comap f ⊓ t.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"AffineSubspace.comap_supr","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nι : Sort u_8\nf : AffineMap k P₁ P₂\ns : ι → AffineSubspace k P₂\n⊢ Eq (AffineSubspace.comap f (iInf s)) (iInf fun i => AffineSubspace.comap f (s i))","decl":"theorem comap_supr {ι : Sort*} (f : P₁ →ᵃ[k] P₂) (s : ι → AffineSubspace k P₂) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"AffineSubspace.comap_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\ns : AffineSubspace k P₁\n⊢ Eq (AffineSubspace.comap (↑e.symm) s) (AffineSubspace.map (↑e) s)","decl":"@[simp]\ntheorem comap_symm (e : P₁ ≃ᵃ[k] P₂) (s : AffineSubspace k P₁) :\n    s.comap (e.symm : P₂ →ᵃ[k] P₁) = s.map e :=\n  coe_injective <| e.preimage_symm _\n\n"}
{"name":"AffineSubspace.map_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\ne : AffineEquiv k P₁ P₂\ns : AffineSubspace k P₂\n⊢ Eq (AffineSubspace.map (↑e.symm) s) (AffineSubspace.comap (↑e) s)","decl":"@[simp]\ntheorem map_symm (e : P₁ ≃ᵃ[k] P₂) (s : AffineSubspace k P₂) :\n    s.map (e.symm : P₂ →ᵃ[k] P₁) = s.comap e :=\n  coe_injective <| e.image_symm _\n\n"}
{"name":"AffineSubspace.comap_span","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV₁ : Type u_2\nP₁ : Type u_3\nV₂ : Type u_4\nP₂ : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V₁\ninst✝⁴ : Module k V₁\ninst✝³ : AddTorsor V₁ P₁\ninst✝² : AddCommGroup V₂\ninst✝¹ : Module k V₂\ninst✝ : AddTorsor V₂ P₂\nf : AffineEquiv k P₁ P₂\ns : Set P₂\n⊢ Eq (AffineSubspace.comap (↑f) (affineSpan k s)) (affineSpan k (Set.preimage (⇑f) s))","decl":"theorem comap_span (f : P₁ ≃ᵃ[k] P₂) (s : Set P₂) :\n    (affineSpan k s).comap (f : P₁ →ᵃ[k] P₂) = affineSpan k (f ⁻¹' s) := by\n  rw [← map_symm, map_span, AffineEquiv.coe_coe, f.image_symm]\n\n"}
{"name":"AffineSubspace.Parallel.symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\nh : s₁.Parallel s₂\n⊢ s₂.Parallel s₁","decl":"@[symm]\ntheorem Parallel.symm {s₁ s₂ : AffineSubspace k P} (h : s₁ ∥ s₂) : s₂ ∥ s₁ := by\n  rcases h with ⟨v, rfl⟩\n  refine ⟨-v, ?_⟩\n  rw [map_map, ← coe_trans_to_affineMap, ← constVAdd_add, neg_add_cancel, constVAdd_zero,\n    coe_refl_to_affineMap, map_id]\n\n"}
{"name":"AffineSubspace.parallel_comm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\n⊢ Iff (s₁.Parallel s₂) (s₂.Parallel s₁)","decl":"theorem parallel_comm {s₁ s₂ : AffineSubspace k P} : s₁ ∥ s₂ ↔ s₂ ∥ s₁ :=\n  ⟨Parallel.symm, Parallel.symm⟩\n\n"}
{"name":"AffineSubspace.Parallel.refl","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\n⊢ s.Parallel s","decl":"@[refl]\ntheorem Parallel.refl (s : AffineSubspace k P) : s ∥ s :=\n  ⟨0, by simp⟩\n\n"}
{"name":"AffineSubspace.Parallel.trans","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ s₃ : AffineSubspace k P\nh₁₂ : s₁.Parallel s₂\nh₂₃ : s₂.Parallel s₃\n⊢ s₁.Parallel s₃","decl":"@[trans]\ntheorem Parallel.trans {s₁ s₂ s₃ : AffineSubspace k P} (h₁₂ : s₁ ∥ s₂) (h₂₃ : s₂ ∥ s₃) :\n    s₁ ∥ s₃ := by\n  rcases h₁₂ with ⟨v₁₂, rfl⟩\n  rcases h₂₃ with ⟨v₂₃, rfl⟩\n  refine ⟨v₂₃ + v₁₂, ?_⟩\n  rw [map_map, ← coe_trans_to_affineMap, ← constVAdd_add]\n\n"}
{"name":"AffineSubspace.Parallel.direction_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\nh : s₁.Parallel s₂\n⊢ Eq s₁.direction s₂.direction","decl":"theorem Parallel.direction_eq {s₁ s₂ : AffineSubspace k P} (h : s₁ ∥ s₂) :\n    s₁.direction = s₂.direction := by\n  rcases h with ⟨v, rfl⟩\n  simp\n\n"}
{"name":"AffineSubspace.parallel_bot_iff_eq_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\n⊢ Iff (s.Parallel Bot.bot) (Eq s Bot.bot)","decl":"@[simp]\ntheorem parallel_bot_iff_eq_bot {s : AffineSubspace k P} : s ∥ ⊥ ↔ s = ⊥ := by\n  refine ⟨fun h => ?_, fun h => h ▸ Parallel.refl _⟩\n  rcases h with ⟨v, h⟩\n  rwa [eq_comm, map_eq_bot_iff] at h\n\n"}
{"name":"AffineSubspace.bot_parallel_iff_eq_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\n⊢ Iff (Bot.bot.Parallel s) (Eq s Bot.bot)","decl":"@[simp]\ntheorem bot_parallel_iff_eq_bot {s : AffineSubspace k P} : ⊥ ∥ s ↔ s = ⊥ := by\n  rw [parallel_comm, parallel_bot_iff_eq_bot]\n\n"}
{"name":"AffineSubspace.parallel_iff_direction_eq_and_eq_bot_iff_eq_bot","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : AffineSubspace k P\n⊢ Iff (s₁.Parallel s₂) (And (Eq s₁.direction s₂.direction) (Iff (Eq s₁ Bot.bot) (Eq s₂ Bot.bot)))","decl":"theorem parallel_iff_direction_eq_and_eq_bot_iff_eq_bot {s₁ s₂ : AffineSubspace k P} :\n    s₁ ∥ s₂ ↔ s₁.direction = s₂.direction ∧ (s₁ = ⊥ ↔ s₂ = ⊥) := by\n  refine ⟨fun h => ⟨h.direction_eq, ?_, ?_⟩, fun h => ?_⟩\n  · rintro rfl\n    exact bot_parallel_iff_eq_bot.1 h\n  · rintro rfl\n    exact parallel_bot_iff_eq_bot.1 h\n  · rcases h with ⟨hd, hb⟩\n    by_cases hs₁ : s₁ = ⊥\n    · rw [hs₁, bot_parallel_iff_eq_bot]\n      exact hb.1 hs₁\n    · have hs₂ : s₂ ≠ ⊥ := hb.not.1 hs₁\n      rcases (nonempty_iff_ne_bot s₁).2 hs₁ with ⟨p₁, hp₁⟩\n      rcases (nonempty_iff_ne_bot s₂).2 hs₂ with ⟨p₂, hp₂⟩\n      refine ⟨p₂ -ᵥ p₁, (eq_iff_direction_eq_of_mem hp₂ ?_).2 ?_⟩\n      · rw [mem_map]\n        refine ⟨p₁, hp₁, ?_⟩\n        simp\n      · simpa using hd.symm\n\n"}
{"name":"AffineSubspace.Parallel.vectorSpan_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\nh : (affineSpan k s₁).Parallel (affineSpan k s₂)\n⊢ Eq (vectorSpan k s₁) (vectorSpan k s₂)","decl":"theorem Parallel.vectorSpan_eq {s₁ s₂ : Set P} (h : affineSpan k s₁ ∥ affineSpan k s₂) :\n    vectorSpan k s₁ = vectorSpan k s₂ := by\n  simp_rw [← direction_affineSpan]\n  exact h.direction_eq\n\n"}
{"name":"AffineSubspace.affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\n⊢ Iff ((affineSpan k s₁).Parallel (affineSpan k s₂)) (And (Eq (vectorSpan k s₁) (vectorSpan k s₂)) (Iff (Eq s₁ EmptyCollection.emptyCollection) (Eq s₂ EmptyCollection.emptyCollection)))","decl":"theorem affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty {s₁ s₂ : Set P} :\n    affineSpan k s₁ ∥ affineSpan k s₂ ↔ vectorSpan k s₁ = vectorSpan k s₂ ∧ (s₁ = ∅ ↔ s₂ = ∅) := by\n  repeat rw [← direction_affineSpan, ← affineSpan_eq_bot k]\n  -- Porting note: more issues with `simp`\n  exact parallel_iff_direction_eq_and_eq_bot_iff_eq_bot\n\n"}
{"name":"AffineSubspace.affineSpan_pair_parallel_iff_vectorSpan_eq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineSubspace","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ p₄ : P\n⊢ Iff ((affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))).Parallel (affineSpan k (Insert.insert p₃ (Singleton.singleton p₄)))) (Eq (vectorSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (vectorSpan k (Insert.insert p₃ (Singleton.singleton p₄))))","decl":"theorem affineSpan_pair_parallel_iff_vectorSpan_eq {p₁ p₂ p₃ p₄ : P} :\n    line[k, p₁, p₂] ∥ line[k, p₃, p₄] ↔\n      vectorSpan k ({p₁, p₂} : Set P) = vectorSpan k ({p₃, p₄} : Set P) := by\n  simp [affineSpan_parallel_iff_vectorSpan_eq_and_eq_empty_iff_eq_empty, ←\n    not_nonempty_iff_eq_empty]\n\n"}
