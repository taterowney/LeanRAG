{"name":"card_comm_eq_card_conjClasses_mul_card","module":"Mathlib.GroupTheory.GroupAction.CardCommute","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq (Nat.card (Subtype fun p => Commute p.1 p.2)) (HMul.hMul (Nat.card (ConjClasses G)) (Nat.card G))","decl":"theorem card_comm_eq_card_conjClasses_mul_card (G : Type*) [Group G] :\n    Nat.card { p : G × G // Commute p.1 p.2 } = Nat.card (ConjClasses G) * Nat.card G := by\n  classical\n  rcases fintypeOrInfinite G; swap\n  · rw [mul_comm, Nat.card_eq_zero_of_infinite, Nat.card_eq_zero_of_infinite, zero_mul]\n  simp only [Nat.card_eq_fintype_card]\n  -- Porting note: Changed `calc` proof into a `rw` proof.\n  rw [card_congr (Equiv.subtypeProdEquivSigmaSubtype Commute), card_sigma,\n    sum_equiv ConjAct.toConjAct.toEquiv (fun a ↦ card { b // Commute a b })\n      (fun g ↦ card (MulAction.fixedBy G g))\n      fun g ↦ card_congr' <| congr_arg _ <| funext fun h ↦ mul_inv_eq_iff_eq_mul.symm.eq,\n    MulAction.sum_card_fixedBy_eq_card_orbits_mul_card_group]\n  congr 1; apply card_congr'; congr; ext\n  exact (Setoid.comm' _).trans isConj_iff.symm\n"}
