{"name":"degree_radical_le","module":"Mathlib.RingTheory.Polynomial.Radical","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\na : Polynomial k\nh : Ne a 0\n⊢ LE.le (UniqueFactorizationMonoid.radical a).degree a.degree","decl":"theorem degree_radical_le {a : k[X]} (h : a ≠ 0) :\n  (radical a).degree ≤ a.degree := degree_le_of_dvd (radical_dvd_self a) h\n\n"}
{"name":"natDegree_radical_le","module":"Mathlib.RingTheory.Polynomial.Radical","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\na : Polynomial k\n⊢ LE.le (UniqueFactorizationMonoid.radical a).natDegree a.natDegree","decl":"theorem natDegree_radical_le {a : k[X]} :\n    (radical a).natDegree ≤ a.natDegree := by\n  by_cases ha : a = 0\n  · simp [ha]\n  · exact natDegree_le_of_dvd (radical_dvd_self a) ha\n\n"}
{"name":"divRadical_dvd_derivative","module":"Mathlib.RingTheory.Polynomial.Radical","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\na : Polynomial k\n⊢ Dvd.dvd (EuclideanDomain.divRadical a) (Polynomial.derivative a)","decl":"theorem divRadical_dvd_derivative (a : k[X]) : divRadical a ∣ derivative a := by\n  induction a using induction_on_coprime\n  · case h0 =>\n    rw [derivative_zero]\n    apply dvd_zero\n  · case h1 a ha =>\n    exact (divRadical_isUnit ha).dvd\n  · case hpr p i hp =>\n    cases i\n    · rw [pow_zero, derivative_one]\n      apply dvd_zero\n    · case succ i =>\n      rw [← mul_dvd_mul_iff_left (radical_ne_zero (p ^ i.succ)), radical_mul_divRadical,\n        radical_pow_of_prime hp i.succ_pos, derivative_pow_succ, ← mul_assoc]\n      apply dvd_mul_of_dvd_left\n      rw [mul_comm, mul_assoc]\n      apply dvd_mul_of_dvd_right\n      rw [pow_succ, mul_dvd_mul_iff_left (pow_ne_zero i hp.ne_zero), dvd_normalize_iff]\n  · -- If it holds for coprime pair a and b, then it also holds for a * b.\n    case hcp x y hpxy hx hy =>\n    have hc : IsCoprime x y :=\n      EuclideanDomain.isCoprime_of_dvd\n        (fun ⟨hx, hy⟩ => not_isUnit_zero (hpxy (zero_dvd_iff.mpr hx) (zero_dvd_iff.mpr hy)))\n        fun p hp _ hpx hpy => hp (hpxy hpx hpy)\n    rw [divRadical_mul hc, derivative_mul]\n    exact dvd_add (mul_dvd_mul hx (divRadical_dvd_self y)) (mul_dvd_mul (divRadical_dvd_self x) hy)\n\n"}
{"name":"divRadical_dvd_wronskian_left","module":"Mathlib.RingTheory.Polynomial.Radical","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\na b : Polynomial k\n⊢ Dvd.dvd (EuclideanDomain.divRadical a) (a.wronskian b)","decl":"theorem divRadical_dvd_wronskian_left (a b : k[X]) : divRadical a ∣ wronskian a b := by\n  rw [wronskian]\n  apply dvd_sub\n  · apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_self a\n  · apply dvd_mul_of_dvd_left\n    exact divRadical_dvd_derivative a\n\n"}
{"name":"divRadical_dvd_wronskian_right","module":"Mathlib.RingTheory.Polynomial.Radical","initialProofState":"k : Type u_1\ninst✝¹ : Field k\ninst✝ : DecidableEq k\na b : Polynomial k\n⊢ Dvd.dvd (EuclideanDomain.divRadical b) (a.wronskian b)","decl":"theorem divRadical_dvd_wronskian_right (a b : k[X]) : divRadical b ∣ wronskian a b := by\n  rw [← wronskian_neg_eq, dvd_neg]\n  exact divRadical_dvd_wronskian_left _ _\n"}
