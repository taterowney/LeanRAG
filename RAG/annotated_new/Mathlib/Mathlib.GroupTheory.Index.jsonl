{"name":"AddSubgroup.index_comap_of_surjective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G' G\nhf : Function.Surjective ⇑f\n⊢ Eq (AddSubgroup.comap f H).index H.index","decl":"@[to_additive]\ntheorem index_comap_of_surjective {f : G' →* G} (hf : Function.Surjective f) :\n    (H.comap f).index = H.index := by\n  have key : ∀ x y : G',\n      QuotientGroup.leftRel (H.comap f) x y ↔ QuotientGroup.leftRel H (f x) (f y) := by\n    simp only [QuotientGroup.leftRel_apply]\n    exact fun x y => iff_of_eq (congr_arg (· ∈ H) (by rw [f.map_mul, f.map_inv]))\n  refine Cardinal.toNat_congr (Equiv.ofBijective (Quotient.map' f fun x y => (key x y).mp) ⟨?_, ?_⟩)\n  · simp_rw [← Quotient.eq''] at key\n    refine Quotient.ind' fun x => ?_\n    refine Quotient.ind' fun y => ?_\n    exact (key x y).mpr\n  · refine Quotient.ind' fun x => ?_\n    obtain ⟨y, hy⟩ := hf x\n    exact ⟨y, (Quotient.map'_mk'' f _ y).trans (congr_arg Quotient.mk'' hy)⟩\n\n"}
{"name":"Subgroup.index_comap_of_surjective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G' G\nhf : Function.Surjective ⇑f\n⊢ Eq (Subgroup.comap f H).index H.index","decl":"@[to_additive]\ntheorem index_comap_of_surjective {f : G' →* G} (hf : Function.Surjective f) :\n    (H.comap f).index = H.index := by\n  have key : ∀ x y : G',\n      QuotientGroup.leftRel (H.comap f) x y ↔ QuotientGroup.leftRel H (f x) (f y) := by\n    simp only [QuotientGroup.leftRel_apply]\n    exact fun x y => iff_of_eq (congr_arg (· ∈ H) (by rw [f.map_mul, f.map_inv]))\n  refine Cardinal.toNat_congr (Equiv.ofBijective (Quotient.map' f fun x y => (key x y).mp) ⟨?_, ?_⟩)\n  · simp_rw [← Quotient.eq''] at key\n    refine Quotient.ind' fun x => ?_\n    refine Quotient.ind' fun y => ?_\n    exact (key x y).mpr\n  · refine Quotient.ind' fun x => ?_\n    obtain ⟨y, hy⟩ := hf x\n    exact ⟨y, (Quotient.map'_mk'' f _ y).trans (congr_arg Quotient.mk'' hy)⟩\n\n"}
{"name":"AddSubgroup.index_comap","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G' G\n⊢ Eq (AddSubgroup.comap f H).index (H.relindex f.range)","decl":"@[to_additive]\ntheorem index_comap (f : G' →* G) :\n    (H.comap f).index = H.relindex f.range :=\n  Eq.trans (congr_arg index (by rfl))\n    ((H.subgroupOf f.range).index_comap_of_surjective f.rangeRestrict_surjective)\n\n"}
{"name":"Subgroup.index_comap","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G' G\n⊢ Eq (Subgroup.comap f H).index (H.relindex f.range)","decl":"@[to_additive]\ntheorem index_comap (f : G' →* G) :\n    (H.comap f).index = H.relindex f.range :=\n  Eq.trans (congr_arg index (by rfl))\n    ((H.subgroupOf f.range).index_comap_of_surjective f.rangeRestrict_surjective)\n\n"}
{"name":"Subgroup.relindex_comap","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G' G\nK : Subgroup G'\n⊢ Eq ((Subgroup.comap f H).relindex K) (H.relindex (Subgroup.map f K))","decl":"@[to_additive]\ntheorem relindex_comap (f : G' →* G) (K : Subgroup G') :\n    relindex (comap f H) K = relindex H (map f K) := by\n  rw [relindex, subgroupOf, comap_comap, index_comap, ← f.map_range, K.range_subtype]\n\n"}
{"name":"AddSubgroup.relindex_comap","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G' G\nK : AddSubgroup G'\n⊢ Eq ((AddSubgroup.comap f H).relindex K) (H.relindex (AddSubgroup.map f K))","decl":"@[to_additive]\ntheorem relindex_comap (f : G' →* G) (K : Subgroup G') :\n    relindex (comap f H) K = relindex H (map f K) := by\n  rw [relindex, subgroupOf, comap_comap, index_comap, ← f.map_range, K.range_subtype]\n\n"}
{"name":"AddSubgroup.relindex_mul_index","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Eq (HMul.hMul (H.relindex K) K.index) H.index","decl":"@[to_additive relindex_mul_index]\ntheorem relindex_mul_index (h : H ≤ K) : H.relindex K * K.index = H.index :=\n  ((mul_comm _ _).trans (Cardinal.toNat_mul _ _).symm).trans\n    (congr_arg Cardinal.toNat (Equiv.cardinal_eq (quotientEquivProdOfLE h))).symm\n\n"}
{"name":"Subgroup.relindex_mul_index","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Eq (HMul.hMul (H.relindex K) K.index) H.index","decl":"@[to_additive relindex_mul_index]\ntheorem relindex_mul_index (h : H ≤ K) : H.relindex K * K.index = H.index :=\n  ((mul_comm _ _).trans (Cardinal.toNat_mul _ _).symm).trans\n    (congr_arg Cardinal.toNat (Equiv.cardinal_eq (quotientEquivProdOfLE h))).symm\n\n"}
{"name":"AddSubgroup.index_dvd_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Dvd.dvd K.index H.index","decl":"@[to_additive]\ntheorem index_dvd_of_le (h : H ≤ K) : K.index ∣ H.index :=\n  dvd_of_mul_left_eq (H.relindex K) (relindex_mul_index h)\n\n"}
{"name":"Subgroup.index_dvd_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Dvd.dvd K.index H.index","decl":"@[to_additive]\ntheorem index_dvd_of_le (h : H ≤ K) : K.index ∣ H.index :=\n  dvd_of_mul_left_eq (H.relindex K) (relindex_mul_index h)\n\n"}
{"name":"AddSubgroup.relindex_dvd_index_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\n⊢ Dvd.dvd (H.relindex K) H.index","decl":"@[to_additive]\ntheorem relindex_dvd_index_of_le (h : H ≤ K) : H.relindex K ∣ H.index :=\n  dvd_of_mul_right_eq K.index (relindex_mul_index h)\n\n"}
{"name":"Subgroup.relindex_dvd_index_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ Dvd.dvd (H.relindex K) H.index","decl":"@[to_additive]\ntheorem relindex_dvd_index_of_le (h : H ≤ K) : H.relindex K ∣ H.index :=\n  dvd_of_mul_right_eq K.index (relindex_mul_index h)\n\n"}
{"name":"AddSubgroup.relindex_addSubgroupOf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhKL : LE.le K L\n⊢ Eq ((H.addSubgroupOf L).relindex (K.addSubgroupOf L)) (H.relindex K)","decl":"@[to_additive]\ntheorem relindex_subgroupOf (hKL : K ≤ L) :\n    (H.subgroupOf L).relindex (K.subgroupOf L) = H.relindex K :=\n  ((index_comap (H.subgroupOf L) (inclusion hKL)).trans (congr_arg _ (inclusion_range hKL))).symm\n\n"}
{"name":"Subgroup.relindex_subgroupOf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhKL : LE.le K L\n⊢ Eq ((H.subgroupOf L).relindex (K.subgroupOf L)) (H.relindex K)","decl":"@[to_additive]\ntheorem relindex_subgroupOf (hKL : K ≤ L) :\n    (H.subgroupOf L).relindex (K.subgroupOf L) = H.relindex K :=\n  ((index_comap (H.subgroupOf L) (inclusion hKL)).trans (congr_arg _ (inclusion_range hKL))).symm\n\n"}
{"name":"Subgroup.relindex_mul_relindex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhHK : LE.le H K\nhKL : LE.le K L\n⊢ Eq (HMul.hMul (H.relindex K) (K.relindex L)) (H.relindex L)","decl":"@[to_additive relindex_mul_relindex]\ntheorem relindex_mul_relindex (hHK : H ≤ K) (hKL : K ≤ L) :\n    H.relindex K * K.relindex L = H.relindex L := by\n  rw [← relindex_subgroupOf hKL]\n  exact relindex_mul_index fun x hx => hHK hx\n\n"}
{"name":"AddSubgroup.relindex_mul_relindex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhHK : LE.le H K\nhKL : LE.le K L\n⊢ Eq (HMul.hMul (H.relindex K) (K.relindex L)) (H.relindex L)","decl":"@[to_additive relindex_mul_relindex]\ntheorem relindex_mul_relindex (hHK : H ≤ K) (hKL : K ≤ L) :\n    H.relindex K * K.relindex L = H.relindex L := by\n  rw [← relindex_subgroupOf hKL]\n  exact relindex_mul_index fun x hx => hHK hx\n\n"}
{"name":"Subgroup.inf_relindex_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq ((Min.min H K).relindex K) (H.relindex K)","decl":"@[to_additive]\ntheorem inf_relindex_right : (H ⊓ K).relindex K = H.relindex K := by\n  rw [relindex, relindex, inf_subgroupOf_right]\n\n"}
{"name":"AddSubgroup.inf_relindex_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq ((Min.min H K).relindex K) (H.relindex K)","decl":"@[to_additive]\ntheorem inf_relindex_right : (H ⊓ K).relindex K = H.relindex K := by\n  rw [relindex, relindex, inf_subgroupOf_right]\n\n"}
{"name":"Subgroup.inf_relindex_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq ((Min.min H K).relindex H) (K.relindex H)","decl":"@[to_additive]\ntheorem inf_relindex_left : (H ⊓ K).relindex H = K.relindex H := by\n  rw [inf_comm, inf_relindex_right]\n\n"}
{"name":"AddSubgroup.inf_relindex_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq ((Min.min H K).relindex H) (K.relindex H)","decl":"@[to_additive]\ntheorem inf_relindex_left : (H ⊓ K).relindex H = K.relindex H := by\n  rw [inf_comm, inf_relindex_right]\n\n"}
{"name":"Subgroup.relindex_inf_mul_relindex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\n⊢ Eq (HMul.hMul (H.relindex (Min.min K L)) (K.relindex L)) ((Min.min H K).relindex L)","decl":"@[to_additive relindex_inf_mul_relindex]\ntheorem relindex_inf_mul_relindex : H.relindex (K ⊓ L) * K.relindex L = (H ⊓ K).relindex L := by\n  rw [← inf_relindex_right H (K ⊓ L), ← inf_relindex_right K L, ← inf_relindex_right (H ⊓ K) L,\n    inf_assoc, relindex_mul_relindex (H ⊓ (K ⊓ L)) (K ⊓ L) L inf_le_right inf_le_right]\n\n"}
{"name":"AddSubgroup.relindex_inf_mul_relindex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\n⊢ Eq (HMul.hMul (H.relindex (Min.min K L)) (K.relindex L)) ((Min.min H K).relindex L)","decl":"@[to_additive relindex_inf_mul_relindex]\ntheorem relindex_inf_mul_relindex : H.relindex (K ⊓ L) * K.relindex L = (H ⊓ K).relindex L := by\n  rw [← inf_relindex_right H (K ⊓ L), ← inf_relindex_right K L, ← inf_relindex_right (H ⊓ K) L,\n    inf_assoc, relindex_mul_relindex (H ⊓ (K ⊓ L)) (K ⊓ L) L inf_le_right inf_le_right]\n\n"}
{"name":"AddSubgroup.relindex_sup_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : K.Normal\n⊢ Eq (K.relindex (Max.max H K)) (K.relindex H)","decl":"@[to_additive (attr := simp)]\ntheorem relindex_sup_right [K.Normal] : K.relindex (H ⊔ K) = K.relindex H :=\n  Nat.card_congr (QuotientGroup.quotientInfEquivProdNormalQuotient H K).toEquiv.symm\n\n"}
{"name":"Subgroup.relindex_sup_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : K.Normal\n⊢ Eq (K.relindex (Max.max H K)) (K.relindex H)","decl":"@[to_additive (attr := simp)]\ntheorem relindex_sup_right [K.Normal] : K.relindex (H ⊔ K) = K.relindex H :=\n  Nat.card_congr (QuotientGroup.quotientInfEquivProdNormalQuotient H K).toEquiv.symm\n\n"}
{"name":"Subgroup.relindex_sup_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : K.Normal\n⊢ Eq (K.relindex (Max.max K H)) (K.relindex H)","decl":"@[to_additive (attr := simp)]\ntheorem relindex_sup_left [K.Normal] : K.relindex (K ⊔ H) = K.relindex H := by\n  rw [sup_comm, relindex_sup_right]\n\n"}
{"name":"AddSubgroup.relindex_sup_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : K.Normal\n⊢ Eq (K.relindex (Max.max K H)) (K.relindex H)","decl":"@[to_additive (attr := simp)]\ntheorem relindex_sup_left [K.Normal] : K.relindex (K ⊔ H) = K.relindex H := by\n  rw [sup_comm, relindex_sup_right]\n\n"}
{"name":"Subgroup.relindex_dvd_index_of_normal","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : H.Normal\n⊢ Dvd.dvd (H.relindex K) H.index","decl":"@[to_additive]\ntheorem relindex_dvd_index_of_normal [H.Normal] : H.relindex K ∣ H.index :=\n  relindex_sup_right K H ▸ relindex_dvd_index_of_le le_sup_right\n\n"}
{"name":"AddSubgroup.relindex_dvd_index_of_normal","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : H.Normal\n⊢ Dvd.dvd (H.relindex K) H.index","decl":"@[to_additive]\ntheorem relindex_dvd_index_of_normal [H.Normal] : H.relindex K ∣ H.index :=\n  relindex_sup_right K H ▸ relindex_dvd_index_of_le le_sup_right\n\n"}
{"name":"Subgroup.relindex_dvd_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhHK : LE.le H K\n⊢ Dvd.dvd (K.relindex L) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_dvd_of_le_left (hHK : H ≤ K) : K.relindex L ∣ H.relindex L :=\n  inf_of_le_left hHK ▸ dvd_of_mul_left_eq _ (relindex_inf_mul_relindex _ _ _)\n\n"}
{"name":"AddSubgroup.relindex_dvd_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhHK : LE.le H K\n⊢ Dvd.dvd (K.relindex L) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_dvd_of_le_left (hHK : H ≤ K) : K.relindex L ∣ H.relindex L :=\n  inf_of_le_left hHK ▸ dvd_of_mul_left_eq _ (relindex_inf_mul_relindex _ _ _)\n\n"}
{"name":"Subgroup.index_eq_two_iff","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H.index 2) (Exists fun a => ∀ (b : G), Xor' (Membership.mem H (HMul.hMul b a)) (Membership.mem H b))","decl":"/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\n@[to_additive \"An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"]\ntheorem index_eq_two_iff : H.index = 2 ↔ ∃ a, ∀ b, Xor' (b * a ∈ H) (b ∈ H) := by\n  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G ⧸ H), ExistsUnique, inv_mem_iff,\n    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,\n    xor_iff_iff_not]\n  refine exists_congr fun a =>\n    ⟨fun ha b => ⟨fun hba hb => ?_, fun hb => ?_⟩, fun ha => ⟨?_, fun b hb => ?_⟩⟩\n  · exact ha.1 ((mul_mem_cancel_left hb).1 hba)\n  · exact inv_inv b ▸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)\n  · rw [← inv_mem_iff (x := a), ← ha, inv_mul_cancel]\n    exact one_mem _\n  · rwa [ha, inv_mem_iff (x := b)]\n\n"}
{"name":"AddSubgroup.index_eq_two_iff","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H.index 2) (Exists fun a => ∀ (b : G), Xor' (Membership.mem H (HAdd.hAdd b a)) (Membership.mem H b))","decl":"/-- A subgroup has index two if and only if there exists `a` such that for all `b`, exactly one\nof `b * a` and `b` belong to `H`. -/\n@[to_additive \"An additive subgroup has index two if and only if there exists `a` such that\nfor all `b`, exactly one of `b + a` and `b` belong to `H`.\"]\ntheorem index_eq_two_iff : H.index = 2 ↔ ∃ a, ∀ b, Xor' (b * a ∈ H) (b ∈ H) := by\n  simp only [index, Nat.card_eq_two_iff' ((1 : G) : G ⧸ H), ExistsUnique, inv_mem_iff,\n    QuotientGroup.exists_mk, QuotientGroup.forall_mk, Ne, QuotientGroup.eq, mul_one,\n    xor_iff_iff_not]\n  refine exists_congr fun a =>\n    ⟨fun ha b => ⟨fun hba hb => ?_, fun hb => ?_⟩, fun ha => ⟨?_, fun b hb => ?_⟩⟩\n  · exact ha.1 ((mul_mem_cancel_left hb).1 hba)\n  · exact inv_inv b ▸ ha.2 _ (mt (inv_mem_iff (x := b)).1 hb)\n  · rw [← inv_mem_iff (x := a), ← ha, inv_mul_cancel]\n    exact one_mem _\n  · rwa [ha, inv_mem_iff (x := b)]\n\n"}
{"name":"Subgroup.mul_mem_iff_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Eq H.index 2\na b : G\n⊢ Iff (Membership.mem H (HMul.hMul a b)) (Iff (Membership.mem H a) (Membership.mem H b))","decl":"@[to_additive]\ntheorem mul_mem_iff_of_index_two (h : H.index = 2) {a b : G} : a * b ∈ H ↔ (a ∈ H ↔ b ∈ H) := by\n  by_cases ha : a ∈ H; · simp only [ha, true_iff, mul_mem_cancel_left ha]\n  by_cases hb : b ∈ H; · simp only [hb, iff_true, mul_mem_cancel_right hb]\n  simp only [ha, hb, iff_true]\n  rcases index_eq_two_iff.1 h with ⟨c, hc⟩\n  refine (hc _).or.resolve_left ?_\n  rwa [mul_assoc, mul_mem_cancel_right ((hc _).or.resolve_right hb)]\n\n"}
{"name":"AddSubgroup.add_mem_iff_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Eq H.index 2\na b : G\n⊢ Iff (Membership.mem H (HAdd.hAdd a b)) (Iff (Membership.mem H a) (Membership.mem H b))","decl":"@[to_additive]\ntheorem mul_mem_iff_of_index_two (h : H.index = 2) {a b : G} : a * b ∈ H ↔ (a ∈ H ↔ b ∈ H) := by\n  by_cases ha : a ∈ H; · simp only [ha, true_iff, mul_mem_cancel_left ha]\n  by_cases hb : b ∈ H; · simp only [hb, iff_true, mul_mem_cancel_right hb]\n  simp only [ha, hb, iff_true]\n  rcases index_eq_two_iff.1 h with ⟨c, hc⟩\n  refine (hc _).or.resolve_left ?_\n  rwa [mul_assoc, mul_mem_cancel_right ((hc _).or.resolve_right hb)]\n\n"}
{"name":"AddSubgroup.add_self_mem_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Eq H.index 2\na : G\n⊢ Membership.mem H (HAdd.hAdd a a)","decl":"@[to_additive]\ntheorem mul_self_mem_of_index_two (h : H.index = 2) (a : G) : a * a ∈ H := by\n  rw [mul_mem_iff_of_index_two h]\n\n"}
{"name":"Subgroup.mul_self_mem_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Eq H.index 2\na : G\n⊢ Membership.mem H (HMul.hMul a a)","decl":"@[to_additive]\ntheorem mul_self_mem_of_index_two (h : H.index = 2) (a : G) : a * a ∈ H := by\n  rw [mul_mem_iff_of_index_two h]\n\n"}
{"name":"Subgroup.sq_mem_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Eq H.index 2\na : G\n⊢ Membership.mem H (HPow.hPow a 2)","decl":"@[to_additive two_smul_mem_of_index_two]\ntheorem sq_mem_of_index_two (h : H.index = 2) (a : G) : a ^ 2 ∈ H :=\n  (pow_two a).symm ▸ mul_self_mem_of_index_two h a\n\n"}
{"name":"AddSubgroup.two_smul_mem_of_index_two","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Eq H.index 2\na : G\n⊢ Membership.mem H (HSMul.hSMul 2 a)","decl":"@[to_additive two_smul_mem_of_index_two]\ntheorem sq_mem_of_index_two (h : H.index = 2) (a : G) : a ^ 2 ∈ H :=\n  (pow_two a).symm ▸ mul_self_mem_of_index_two h a\n\n"}
{"name":"AddSubgroup.index_top","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq Top.top.index 1","decl":"@[to_additive (attr := simp)]\ntheorem index_top : (⊤ : Subgroup G).index = 1 :=\n  Nat.card_eq_one_iff_unique.mpr ⟨QuotientGroup.subsingleton_quotient_top, ⟨1⟩⟩\n\n"}
{"name":"Subgroup.index_top","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq Top.top.index 1","decl":"@[to_additive (attr := simp)]\ntheorem index_top : (⊤ : Subgroup G).index = 1 :=\n  Nat.card_eq_one_iff_unique.mpr ⟨QuotientGroup.subsingleton_quotient_top, ⟨1⟩⟩\n\n"}
{"name":"AddSubgroup.index_bot","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Eq Bot.bot.index (Nat.card G)","decl":"@[to_additive (attr := simp)]\ntheorem index_bot : (⊥ : Subgroup G).index = Nat.card G :=\n  Cardinal.toNat_congr QuotientGroup.quotientBot.toEquiv\n\n"}
{"name":"Subgroup.index_bot","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Eq Bot.bot.index (Nat.card G)","decl":"@[to_additive (attr := simp)]\ntheorem index_bot : (⊥ : Subgroup G).index = Nat.card G :=\n  Cardinal.toNat_congr QuotientGroup.quotientBot.toEquiv\n\n"}
{"name":"AddSubgroup.relindex_top_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (Top.top.relindex H) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_top_left : (⊤ : Subgroup G).relindex H = 1 :=\n  index_top\n\n"}
{"name":"Subgroup.relindex_top_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Top.top.relindex H) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_top_left : (⊤ : Subgroup G).relindex H = 1 :=\n  index_top\n\n"}
{"name":"Subgroup.relindex_top_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.relindex Top.top) H.index","decl":"@[to_additive (attr := simp)]\ntheorem relindex_top_right : H.relindex ⊤ = H.index := by\n  rw [← relindex_mul_index (show H ≤ ⊤ from le_top), index_top, mul_one]\n\n"}
{"name":"AddSubgroup.relindex_top_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.relindex Top.top) H.index","decl":"@[to_additive (attr := simp)]\ntheorem relindex_top_right : H.relindex ⊤ = H.index := by\n  rw [← relindex_mul_index (show H ≤ ⊤ from le_top), index_top, mul_one]\n\n"}
{"name":"Subgroup.relindex_bot_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Bot.bot.relindex H) (Nat.card (Subtype fun x => Membership.mem H x))","decl":"@[to_additive (attr := simp)]\ntheorem relindex_bot_left : (⊥ : Subgroup G).relindex H = Nat.card H := by\n  rw [relindex, bot_subgroupOf, index_bot]\n\n"}
{"name":"AddSubgroup.relindex_bot_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (Bot.bot.relindex H) (Nat.card (Subtype fun x => Membership.mem H x))","decl":"@[to_additive (attr := simp)]\ntheorem relindex_bot_left : (⊥ : Subgroup G).relindex H = Nat.card H := by\n  rw [relindex, bot_subgroupOf, index_bot]\n\n"}
{"name":"AddSubgroup.relindex_bot_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.relindex Bot.bot) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_bot_right : H.relindex ⊥ = 1 := by rw [relindex, subgroupOf_bot_eq_top, index_top]\n\n"}
{"name":"Subgroup.relindex_bot_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.relindex Bot.bot) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_bot_right : H.relindex ⊥ = 1 := by rw [relindex, subgroupOf_bot_eq_top, index_top]\n\n"}
{"name":"AddSubgroup.relindex_self","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (H.relindex H) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_self : H.relindex H = 1 := by rw [relindex, subgroupOf_self, index_top]\n\n"}
{"name":"Subgroup.relindex_self","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (H.relindex H) 1","decl":"@[to_additive (attr := simp)]\ntheorem relindex_self : H.relindex H = 1 := by rw [relindex, subgroupOf_self, index_top]\n\n"}
{"name":"AddSubgroup.index_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\n⊢ Eq f.ker.index (Nat.card (Subtype fun x => Membership.mem f.range x))","decl":"@[to_additive]\ntheorem index_ker (f : G →* G') : f.ker.index = Nat.card f.range := by\n  rw [← MonoidHom.comap_bot, index_comap, relindex_bot_left]\n\n"}
{"name":"Subgroup.index_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\n⊢ Eq f.ker.index (Nat.card (Subtype fun x => Membership.mem f.range x))","decl":"@[to_additive]\ntheorem index_ker (f : G →* G') : f.ker.index = Nat.card f.range := by\n  rw [← MonoidHom.comap_bot, index_comap, relindex_bot_left]\n\n"}
{"name":"Subgroup.relindex_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nK : Subgroup G\nf : MonoidHom G G'\n⊢ Eq (f.ker.relindex K) (Nat.card (Subtype fun x => Membership.mem (Subgroup.map f K) x))","decl":"@[to_additive]\ntheorem relindex_ker (f : G →* G') : f.ker.relindex K = Nat.card (K.map f) := by\n  rw [← MonoidHom.comap_bot, relindex_comap, relindex_bot_left]\n\n"}
{"name":"AddSubgroup.relindex_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nK : AddSubgroup G\nf : AddMonoidHom G G'\n⊢ Eq (f.ker.relindex K) (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.map f K) x))","decl":"@[to_additive]\ntheorem relindex_ker (f : G →* G') : f.ker.relindex K = Nat.card (K.map f) := by\n  rw [← MonoidHom.comap_bot, relindex_comap, relindex_bot_left]\n\n"}
{"name":"Subgroup.card_mul_index","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) H.index) (Nat.card G)","decl":"@[to_additive (attr := simp) card_mul_index]\ntheorem card_mul_index : Nat.card H * H.index = Nat.card G := by\n  rw [← relindex_bot_left, ← index_bot]\n  exact relindex_mul_index bot_le\n\n"}
{"name":"AddSubgroup.card_mul_index","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (HMul.hMul (Nat.card (Subtype fun x => Membership.mem H x)) H.index) (Nat.card G)","decl":"@[to_additive (attr := simp) card_mul_index]\ntheorem card_mul_index : Nat.card H * H.index = Nat.card G := by\n  rw [← relindex_bot_left, ← index_bot]\n  exact relindex_mul_index bot_le\n\n"}
{"name":"AddSubgroup.card_dvd_of_surjective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (Nat.card G') (Nat.card G)","decl":"@[to_additive]\ntheorem card_dvd_of_surjective (f : G →* G') (hf : Function.Surjective f) :\n    Nat.card G' ∣ Nat.card G := by\n  rw [← Nat.card_congr (QuotientGroup.quotientKerEquivOfSurjective f hf).toEquiv]\n  exact Dvd.intro_left (Nat.card f.ker) f.ker.card_mul_index\n\n"}
{"name":"Subgroup.card_dvd_of_surjective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (Nat.card G') (Nat.card G)","decl":"@[to_additive]\ntheorem card_dvd_of_surjective (f : G →* G') (hf : Function.Surjective f) :\n    Nat.card G' ∣ Nat.card G := by\n  rw [← Nat.card_congr (QuotientGroup.quotientKerEquivOfSurjective f hf).toEquiv]\n  exact Dvd.intro_left (Nat.card f.ker) f.ker.card_mul_index\n\n"}
{"name":"AddSubgroup.card_range_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nf : AddMonoidHom G G'\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem f.range x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_range_dvd (f : G →* G') : Nat.card f.range ∣ Nat.card G :=\n  card_dvd_of_surjective f.rangeRestrict f.rangeRestrict_surjective\n\n"}
{"name":"Subgroup.card_range_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nf : MonoidHom G G'\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem f.range x)) (Nat.card G)","decl":"@[to_additive]\ntheorem card_range_dvd (f : G →* G') : Nat.card f.range ∣ Nat.card G :=\n  card_dvd_of_surjective f.rangeRestrict f.rangeRestrict_surjective\n\n"}
{"name":"AddSubgroup.card_map_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem (AddSubgroup.map f H) x)) (Nat.card (Subtype fun x => Membership.mem H x))","decl":"@[to_additive]\ntheorem card_map_dvd (f : G →* G') : Nat.card (H.map f) ∣ Nat.card H :=\n  card_dvd_of_surjective (f.subgroupMap H) (f.subgroupMap_surjective H)\n\n"}
{"name":"Subgroup.card_map_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\n⊢ Dvd.dvd (Nat.card (Subtype fun x => Membership.mem (Subgroup.map f H) x)) (Nat.card (Subtype fun x => Membership.mem H x))","decl":"@[to_additive]\ntheorem card_map_dvd (f : G →* G') : Nat.card (H.map f) ∣ Nat.card H :=\n  card_dvd_of_surjective (f.subgroupMap H) (f.subgroupMap_surjective H)\n\n"}
{"name":"Subgroup.index_map","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\n⊢ Eq (Subgroup.map f H).index (HMul.hMul (Max.max H f.ker).index f.range.index)","decl":"@[to_additive]\ntheorem index_map (f : G →* G') :\n    (H.map f).index = (H ⊔ f.ker).index * f.range.index := by\n  rw [← comap_map_eq, index_comap, relindex_mul_index (H.map_le_range f)]\n\n"}
{"name":"AddSubgroup.index_map","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\n⊢ Eq (AddSubgroup.map f H).index (HMul.hMul (Max.max H f.ker).index f.range.index)","decl":"@[to_additive]\ntheorem index_map (f : G →* G') :\n    (H.map f).index = (H ⊔ f.ker).index * f.range.index := by\n  rw [← comap_map_eq, index_comap, relindex_mul_index (H.map_le_range f)]\n\n"}
{"name":"AddSubgroup.index_map_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (AddSubgroup.map f H).index H.index","decl":"@[to_additive]\ntheorem index_map_dvd {f : G →* G'} (hf : Function.Surjective f) :\n    (H.map f).index ∣ H.index := by\n  rw [index_map, f.range_eq_top_of_surjective hf, index_top, mul_one]\n  exact index_dvd_of_le le_sup_left\n\n"}
{"name":"Subgroup.index_map_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\nhf : Function.Surjective ⇑f\n⊢ Dvd.dvd (Subgroup.map f H).index H.index","decl":"@[to_additive]\ntheorem index_map_dvd {f : G →* G'} (hf : Function.Surjective f) :\n    (H.map f).index ∣ H.index := by\n  rw [index_map, f.range_eq_top_of_surjective hf, index_top, mul_one]\n  exact index_dvd_of_le le_sup_left\n\n"}
{"name":"AddSubgroup.dvd_index_map","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\nhf : LE.le f.ker H\n⊢ Dvd.dvd H.index (AddSubgroup.map f H).index","decl":"@[to_additive]\ntheorem dvd_index_map {f : G →* G'} (hf : f.ker ≤ H) :\n    H.index ∣ (H.map f).index := by\n  rw [index_map, sup_of_le_left hf]\n  apply dvd_mul_right\n\n"}
{"name":"Subgroup.dvd_index_map","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\nhf : LE.le f.ker H\n⊢ Dvd.dvd H.index (Subgroup.map f H).index","decl":"@[to_additive]\ntheorem dvd_index_map {f : G →* G'} (hf : f.ker ≤ H) :\n    H.index ∣ (H.map f).index := by\n  rw [index_map, sup_of_le_left hf]\n  apply dvd_mul_right\n\n"}
{"name":"AddSubgroup.index_map_eq","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\nhf1 : Function.Surjective ⇑f\nhf2 : LE.le f.ker H\n⊢ Eq (AddSubgroup.map f H).index H.index","decl":"@[to_additive]\ntheorem index_map_eq {f : G →* G'} (hf1 : Function.Surjective f)\n    (hf2 : f.ker ≤ H) : (H.map f).index = H.index :=\n  Nat.dvd_antisymm (H.index_map_dvd hf1) (H.dvd_index_map hf2)\n\n"}
{"name":"Subgroup.index_map_eq","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\nhf1 : Function.Surjective ⇑f\nhf2 : LE.le f.ker H\n⊢ Eq (Subgroup.map f H).index H.index","decl":"@[to_additive]\ntheorem index_map_eq {f : G →* G'} (hf1 : Function.Surjective f)\n    (hf2 : f.ker ≤ H) : (H.map f).index = H.index :=\n  Nat.dvd_antisymm (H.index_map_dvd hf1) (H.dvd_index_map hf2)\n\n"}
{"name":"Subgroup.index_map_of_injective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nf : MonoidHom G G'\nhf : Function.Injective ⇑f\n⊢ Eq (Subgroup.map f H).index (HMul.hMul H.index f.range.index)","decl":"@[to_additive]\ntheorem index_map_of_injective {f : G →* G'} (hf : Function.Injective f) :\n    (H.map f).index = H.index * f.range.index := by\n  rw [H.index_map, f.ker_eq_bot_iff.mpr hf, sup_bot_eq]\n\n"}
{"name":"AddSubgroup.index_map_of_injective","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nf : AddMonoidHom G G'\nhf : Function.Injective ⇑f\n⊢ Eq (AddSubgroup.map f H).index (HMul.hMul H.index f.range.index)","decl":"@[to_additive]\ntheorem index_map_of_injective {f : G →* G'} (hf : Function.Injective f) :\n    (H.map f).index = H.index * f.range.index := by\n  rw [H.index_map, f.ker_eq_bot_iff.mpr hf, sup_bot_eq]\n\n"}
{"name":"AddSubgroup.index_map_subtype","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nK : AddSubgroup (Subtype fun x => Membership.mem H x)\n⊢ Eq (AddSubgroup.map H.subtype K).index (HMul.hMul K.index H.index)","decl":"@[to_additive]\ntheorem index_map_subtype {H : Subgroup G} (K : Subgroup H) :\n    (K.map H.subtype).index = K.index * H.index := by\n  rw [K.index_map_of_injective H.subtype_injective, H.range_subtype]\n\n"}
{"name":"Subgroup.index_map_subtype","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nK : Subgroup (Subtype fun x => Membership.mem H x)\n⊢ Eq (Subgroup.map H.subtype K).index (HMul.hMul K.index H.index)","decl":"@[to_additive]\ntheorem index_map_subtype {H : Subgroup G} (K : Subgroup H) :\n    (K.map H.subtype).index = K.index * H.index := by\n  rw [K.index_map_of_injective H.subtype_injective, H.range_subtype]\n\n"}
{"name":"AddSubgroup.index_eq_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq H.index (Nat.card (HasQuotient.Quotient G H))","decl":"@[to_additive]\ntheorem index_eq_card : H.index = Nat.card (G ⧸ H) :=\n  rfl\n\n"}
{"name":"Subgroup.index_eq_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.index (Nat.card (HasQuotient.Quotient G H))","decl":"@[to_additive]\ntheorem index_eq_card : H.index = Nat.card (G ⧸ H) :=\n  rfl\n\n"}
{"name":"Subgroup.index_mul_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (HMul.hMul H.index (Nat.card (Subtype fun x => Membership.mem H x))) (Nat.card G)","decl":"@[to_additive index_mul_card]\ntheorem index_mul_card : H.index * Nat.card H = Nat.card G := by\n  rw [mul_comm, card_mul_index]\n\n"}
{"name":"AddSubgroup.index_mul_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (HMul.hMul H.index (Nat.card (Subtype fun x => Membership.mem H x))) (Nat.card G)","decl":"@[to_additive index_mul_card]\ntheorem index_mul_card : H.index * Nat.card H = Nat.card G := by\n  rw [mul_comm, card_mul_index]\n\n"}
{"name":"AddSubgroup.index_dvd_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Dvd.dvd H.index (Nat.card G)","decl":"@[to_additive]\ntheorem index_dvd_card : H.index ∣ Nat.card G :=\n  ⟨Nat.card H, H.index_mul_card.symm⟩\n\n"}
{"name":"Subgroup.index_dvd_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Dvd.dvd H.index (Nat.card G)","decl":"@[to_additive]\ntheorem index_dvd_card : H.index ∣ Nat.card G :=\n  ⟨Nat.card H, H.index_mul_card.symm⟩\n\n"}
{"name":"Subgroup.relindex_dvd_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Dvd.dvd (H.relindex K) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem relindex_dvd_card : H.relindex K ∣ Nat.card K :=\n  (H.subgroupOf K).index_dvd_card\n\n"}
{"name":"AddSubgroup.relindex_dvd_card","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Dvd.dvd (H.relindex K) (Nat.card (Subtype fun x => Membership.mem K x))","decl":"@[to_additive]\ntheorem relindex_dvd_card : H.relindex K ∣ Nat.card K :=\n  (H.subgroupOf K).index_dvd_card\n\n"}
{"name":"Subgroup.relindex_eq_zero_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhHK : LE.le H K\nhKL : Eq (K.relindex L) 0\n⊢ Eq (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_eq_zero_of_le_left (hHK : H ≤ K) (hKL : K.relindex L = 0) : H.relindex L = 0 :=\n  eq_zero_of_zero_dvd (hKL ▸ relindex_dvd_of_le_left L hHK)\n\n"}
{"name":"AddSubgroup.relindex_eq_zero_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhHK : LE.le H K\nhKL : Eq (K.relindex L) 0\n⊢ Eq (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_eq_zero_of_le_left (hHK : H ≤ K) (hKL : K.relindex L = 0) : H.relindex L = 0 :=\n  eq_zero_of_zero_dvd (hKL ▸ relindex_dvd_of_le_left L hHK)\n\n"}
{"name":"Subgroup.relindex_eq_zero_of_le_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhKL : LE.le K L\nhHK : Eq (H.relindex K) 0\n⊢ Eq (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_eq_zero_of_le_right (hKL : K ≤ L) (hHK : H.relindex K = 0) : H.relindex L = 0 :=\n  Finite.card_eq_zero_of_embedding (quotientSubgroupOfEmbeddingOfLE H hKL) hHK\n\n"}
{"name":"AddSubgroup.relindex_eq_zero_of_le_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhKL : LE.le K L\nhHK : Eq (H.relindex K) 0\n⊢ Eq (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_eq_zero_of_le_right (hKL : K ≤ L) (hHK : H.relindex K = 0) : H.relindex L = 0 :=\n  Finite.card_eq_zero_of_embedding (quotientSubgroupOfEmbeddingOfLE H hKL) hHK\n\n"}
{"name":"Subgroup.index_eq_zero_of_relindex_eq_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Eq (H.relindex K) 0\n⊢ Eq H.index 0","decl":"@[to_additive]\ntheorem index_eq_zero_of_relindex_eq_zero (h : H.relindex K = 0) : H.index = 0 :=\n  H.relindex_top_right.symm.trans (relindex_eq_zero_of_le_right le_top h)\n\n"}
{"name":"AddSubgroup.index_eq_zero_of_relindex_eq_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Eq (H.relindex K) 0\n⊢ Eq H.index 0","decl":"@[to_additive]\ntheorem index_eq_zero_of_relindex_eq_zero (h : H.relindex K = 0) : H.index = 0 :=\n  H.relindex_top_right.symm.trans (relindex_eq_zero_of_le_right le_top h)\n\n"}
{"name":"AddSubgroup.relindex_le_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhHK : LE.le H K\nhHL : Ne (H.relindex L) 0\n⊢ LE.le (K.relindex L) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_le_of_le_left (hHK : H ≤ K) (hHL : H.relindex L ≠ 0) :\n    K.relindex L ≤ H.relindex L :=\n  Nat.le_of_dvd (Nat.pos_of_ne_zero hHL) (relindex_dvd_of_le_left L hHK)\n\n"}
{"name":"Subgroup.relindex_le_of_le_left","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhHK : LE.le H K\nhHL : Ne (H.relindex L) 0\n⊢ LE.le (K.relindex L) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_le_of_le_left (hHK : H ≤ K) (hHL : H.relindex L ≠ 0) :\n    K.relindex L ≤ H.relindex L :=\n  Nat.le_of_dvd (Nat.pos_of_ne_zero hHL) (relindex_dvd_of_le_left L hHK)\n\n"}
{"name":"AddSubgroup.relindex_le_of_le_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhKL : LE.le K L\nhHL : Ne (H.relindex L) 0\n⊢ LE.le (H.relindex K) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_le_of_le_right (hKL : K ≤ L) (hHL : H.relindex L ≠ 0) :\n    H.relindex K ≤ H.relindex L :=\n  Finite.card_le_of_embedding' (quotientSubgroupOfEmbeddingOfLE H hKL) fun h => (hHL h).elim\n\n"}
{"name":"Subgroup.relindex_le_of_le_right","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhKL : LE.le K L\nhHL : Ne (H.relindex L) 0\n⊢ LE.le (H.relindex K) (H.relindex L)","decl":"@[to_additive]\ntheorem relindex_le_of_le_right (hKL : K ≤ L) (hHL : H.relindex L ≠ 0) :\n    H.relindex K ≤ H.relindex L :=\n  Finite.card_le_of_embedding' (quotientSubgroupOfEmbeddingOfLE H hKL) fun h => (hHL h).elim\n\n"}
{"name":"Subgroup.relindex_ne_zero_trans","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhHK : Ne (H.relindex K) 0\nhKL : Ne (K.relindex L) 0\n⊢ Ne (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_ne_zero_trans (hHK : H.relindex K ≠ 0) (hKL : K.relindex L ≠ 0) :\n    H.relindex L ≠ 0 := fun h =>\n  mul_ne_zero (mt (relindex_eq_zero_of_le_right (show K ⊓ L ≤ K from inf_le_left)) hHK) hKL\n    ((relindex_inf_mul_relindex H K L).trans (relindex_eq_zero_of_le_left inf_le_left h))\n\n"}
{"name":"AddSubgroup.relindex_ne_zero_trans","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhHK : Ne (H.relindex K) 0\nhKL : Ne (K.relindex L) 0\n⊢ Ne (H.relindex L) 0","decl":"@[to_additive]\ntheorem relindex_ne_zero_trans (hHK : H.relindex K ≠ 0) (hKL : K.relindex L ≠ 0) :\n    H.relindex L ≠ 0 := fun h =>\n  mul_ne_zero (mt (relindex_eq_zero_of_le_right (show K ⊓ L ≤ K from inf_le_left)) hHK) hKL\n    ((relindex_inf_mul_relindex H K L).trans (relindex_eq_zero_of_le_left inf_le_left h))\n\n"}
{"name":"AddSubgroup.relindex_inf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\nhH : Ne (H.relindex L) 0\nhK : Ne (K.relindex L) 0\n⊢ Ne ((Min.min H K).relindex L) 0","decl":"@[to_additive]\ntheorem relindex_inf_ne_zero (hH : H.relindex L ≠ 0) (hK : K.relindex L ≠ 0) :\n    (H ⊓ K).relindex L ≠ 0 := by\n  replace hH : H.relindex (K ⊓ L) ≠ 0 := mt (relindex_eq_zero_of_le_right inf_le_right) hH\n  rw [← inf_relindex_right] at hH hK ⊢\n  rw [inf_assoc]\n  exact relindex_ne_zero_trans hH hK\n\n"}
{"name":"Subgroup.relindex_inf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\nhH : Ne (H.relindex L) 0\nhK : Ne (K.relindex L) 0\n⊢ Ne ((Min.min H K).relindex L) 0","decl":"@[to_additive]\ntheorem relindex_inf_ne_zero (hH : H.relindex L ≠ 0) (hK : K.relindex L ≠ 0) :\n    (H ⊓ K).relindex L ≠ 0 := by\n  replace hH : H.relindex (K ⊓ L) ≠ 0 := mt (relindex_eq_zero_of_le_right inf_le_right) hH\n  rw [← inf_relindex_right] at hH hK ⊢\n  rw [inf_assoc]\n  exact relindex_ne_zero_trans hH hK\n\n"}
{"name":"Subgroup.index_inf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : Ne H.index 0\nhK : Ne K.index 0\n⊢ Ne (Min.min H K).index 0","decl":"@[to_additive]\ntheorem index_inf_ne_zero (hH : H.index ≠ 0) (hK : K.index ≠ 0) : (H ⊓ K).index ≠ 0 := by\n  rw [← relindex_top_right] at hH hK ⊢\n  exact relindex_inf_ne_zero hH hK\n\n"}
{"name":"AddSubgroup.index_inf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhH : Ne H.index 0\nhK : Ne K.index 0\n⊢ Ne (Min.min H K).index 0","decl":"@[to_additive]\ntheorem index_inf_ne_zero (hH : H.index ≠ 0) (hK : K.index ≠ 0) : (H ⊓ K).index ≠ 0 := by\n  rw [← relindex_top_right] at hH hK ⊢\n  exact relindex_inf_ne_zero hH hK\n\n"}
{"name":"AddSubgroup.relindex_inf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K L : AddSubgroup G\n⊢ LE.le ((Min.min H K).relindex L) (HMul.hMul (H.relindex L) (K.relindex L))","decl":"@[to_additive]\ntheorem relindex_inf_le : (H ⊓ K).relindex L ≤ H.relindex L * K.relindex L := by\n  by_cases h : H.relindex L = 0\n  · exact (le_of_eq (relindex_eq_zero_of_le_left inf_le_left h)).trans (zero_le _)\n  rw [← inf_relindex_right, inf_assoc, ← relindex_mul_relindex _ _ L inf_le_right inf_le_right,\n    inf_relindex_right, inf_relindex_right]\n  exact mul_le_mul_right' (relindex_le_of_le_right inf_le_right h) (K.relindex L)\n\n"}
{"name":"Subgroup.relindex_inf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K L : Subgroup G\n⊢ LE.le ((Min.min H K).relindex L) (HMul.hMul (H.relindex L) (K.relindex L))","decl":"@[to_additive]\ntheorem relindex_inf_le : (H ⊓ K).relindex L ≤ H.relindex L * K.relindex L := by\n  by_cases h : H.relindex L = 0\n  · exact (le_of_eq (relindex_eq_zero_of_le_left inf_le_left h)).trans (zero_le _)\n  rw [← inf_relindex_right, inf_assoc, ← relindex_mul_relindex _ _ L inf_le_right inf_le_right,\n    inf_relindex_right, inf_relindex_right]\n  exact mul_le_mul_right' (relindex_le_of_le_right inf_le_right h) (K.relindex L)\n\n"}
{"name":"Subgroup.index_inf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ LE.le (Min.min H K).index (HMul.hMul H.index K.index)","decl":"@[to_additive]\ntheorem index_inf_le : (H ⊓ K).index ≤ H.index * K.index := by\n  simp_rw [← relindex_top_right, relindex_inf_le]\n\n"}
{"name":"AddSubgroup.index_inf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ LE.le (Min.min H K).index (HMul.hMul H.index K.index)","decl":"@[to_additive]\ntheorem index_inf_le : (H ⊓ K).index ≤ H.index * K.index := by\n  simp_rw [← relindex_top_right, relindex_inf_le]\n\n"}
{"name":"Subgroup.relindex_iInf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nL : Subgroup G\nι : Type u_3\n_hι : Finite ι\nf : ι → Subgroup G\nhf : ∀ (i : ι), Ne ((f i).relindex L) 0\n⊢ Ne ((iInf fun i => f i).relindex L) 0","decl":"@[to_additive]\ntheorem relindex_iInf_ne_zero {ι : Type*} [_hι : Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).relindex L ≠ 0) : (⨅ i, f i).relindex L ≠ 0 :=\n  haveI := Fintype.ofFinite ι\n  (Finset.prod_ne_zero_iff.mpr fun i _hi => hf i) ∘\n    Nat.card_pi.symm.trans ∘\n      Finite.card_eq_zero_of_embedding (quotientiInfSubgroupOfEmbedding f L)\n\n"}
{"name":"AddSubgroup.relindex_iInf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nL : AddSubgroup G\nι : Type u_3\n_hι : Finite ι\nf : ι → AddSubgroup G\nhf : ∀ (i : ι), Ne ((f i).relindex L) 0\n⊢ Ne ((iInf fun i => f i).relindex L) 0","decl":"@[to_additive]\ntheorem relindex_iInf_ne_zero {ι : Type*} [_hι : Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).relindex L ≠ 0) : (⨅ i, f i).relindex L ≠ 0 :=\n  haveI := Fintype.ofFinite ι\n  (Finset.prod_ne_zero_iff.mpr fun i _hi => hf i) ∘\n    Nat.card_pi.symm.trans ∘\n      Finite.card_eq_zero_of_embedding (quotientiInfSubgroupOfEmbedding f L)\n\n"}
{"name":"Subgroup.relindex_iInf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nL : Subgroup G\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → Subgroup G\n⊢ LE.le ((iInf fun i => f i).relindex L) (Finset.univ.prod fun i => (f i).relindex L)","decl":"@[to_additive]\ntheorem relindex_iInf_le {ι : Type*} [Fintype ι] (f : ι → Subgroup G) :\n    (⨅ i, f i).relindex L ≤ ∏ i, (f i).relindex L :=\n  le_of_le_of_eq\n    (Finite.card_le_of_embedding' (quotientiInfSubgroupOfEmbedding f L) fun h =>\n      let ⟨i, _hi, h⟩ := Finset.prod_eq_zero_iff.mp (Nat.card_pi.symm.trans h)\n      relindex_eq_zero_of_le_left (iInf_le f i) h)\n    Nat.card_pi\n\n"}
{"name":"AddSubgroup.relindex_iInf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nL : AddSubgroup G\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → AddSubgroup G\n⊢ LE.le ((iInf fun i => f i).relindex L) (Finset.univ.prod fun i => (f i).relindex L)","decl":"@[to_additive]\ntheorem relindex_iInf_le {ι : Type*} [Fintype ι] (f : ι → Subgroup G) :\n    (⨅ i, f i).relindex L ≤ ∏ i, (f i).relindex L :=\n  le_of_le_of_eq\n    (Finite.card_le_of_embedding' (quotientiInfSubgroupOfEmbedding f L) fun h =>\n      let ⟨i, _hi, h⟩ := Finset.prod_eq_zero_iff.mp (Nat.card_pi.symm.trans h)\n      relindex_eq_zero_of_le_left (iInf_le f i) h)\n    Nat.card_pi\n\n"}
{"name":"Subgroup.index_iInf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_3\ninst✝ : Finite ι\nf : ι → Subgroup G\nhf : ∀ (i : ι), Ne (f i).index 0\n⊢ Ne (iInf fun i => f i).index 0","decl":"@[to_additive]\ntheorem index_iInf_ne_zero {ι : Type*} [Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).index ≠ 0) : (⨅ i, f i).index ≠ 0 := by\n  simp_rw [← relindex_top_right] at hf ⊢\n  exact relindex_iInf_ne_zero hf\n\n"}
{"name":"AddSubgroup.index_iInf_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_3\ninst✝ : Finite ι\nf : ι → AddSubgroup G\nhf : ∀ (i : ι), Ne (f i).index 0\n⊢ Ne (iInf fun i => f i).index 0","decl":"@[to_additive]\ntheorem index_iInf_ne_zero {ι : Type*} [Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).index ≠ 0) : (⨅ i, f i).index ≠ 0 := by\n  simp_rw [← relindex_top_right] at hf ⊢\n  exact relindex_iInf_ne_zero hf\n\n"}
{"name":"AddSubgroup.index_iInf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → AddSubgroup G\n⊢ LE.le (iInf fun i => f i).index (Finset.univ.prod fun i => (f i).index)","decl":"@[to_additive]\ntheorem index_iInf_le {ι : Type*} [Fintype ι] (f : ι → Subgroup G) :\n    (⨅ i, f i).index ≤ ∏ i, (f i).index := by simp_rw [← relindex_top_right, relindex_iInf_le]\n\n-- Porting note: had to replace `Cardinal.toNat_eq_one_iff_unique` with `Nat.card_eq_one_iff_unique`\n"}
{"name":"Subgroup.index_iInf_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_3\ninst✝ : Fintype ι\nf : ι → Subgroup G\n⊢ LE.le (iInf fun i => f i).index (Finset.univ.prod fun i => (f i).index)","decl":"@[to_additive]\ntheorem index_iInf_le {ι : Type*} [Fintype ι] (f : ι → Subgroup G) :\n    (⨅ i, f i).index ≤ ∏ i, (f i).index := by simp_rw [← relindex_top_right, relindex_iInf_le]\n\n-- Porting note: had to replace `Cardinal.toNat_eq_one_iff_unique` with `Nat.card_eq_one_iff_unique`\n"}
{"name":"Subgroup.index_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H.index 1) (Eq H Top.top)","decl":"@[to_additive (attr := simp) index_eq_one]\ntheorem index_eq_one : H.index = 1 ↔ H = ⊤ :=\n  ⟨fun h =>\n    QuotientGroup.subgroup_eq_top_of_subsingleton H (Nat.card_eq_one_iff_unique.mp h).1,\n    fun h => (congr_arg index h).trans index_top⟩\n\n"}
{"name":"AddSubgroup.index_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H.index 1) (Eq H Top.top)","decl":"@[to_additive (attr := simp) index_eq_one]\ntheorem index_eq_one : H.index = 1 ↔ H = ⊤ :=\n  ⟨fun h =>\n    QuotientGroup.subgroup_eq_top_of_subsingleton H (Nat.card_eq_one_iff_unique.mp h).1,\n    fun h => (congr_arg index h).trans index_top⟩\n\n"}
{"name":"Subgroup.relindex_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Iff (Eq (H.relindex K) 1) (LE.le K H)","decl":"@[to_additive (attr := simp) relindex_eq_one]\ntheorem relindex_eq_one : H.relindex K = 1 ↔ K ≤ H :=\n  index_eq_one.trans subgroupOf_eq_top\n\n"}
{"name":"AddSubgroup.relindex_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Iff (Eq (H.relindex K) 1) (LE.le K H)","decl":"@[to_additive (attr := simp) relindex_eq_one]\ntheorem relindex_eq_one : H.relindex K = 1 ↔ K ≤ H :=\n  index_eq_one.trans subgroupOf_eq_top\n\n"}
{"name":"AddSubgroup.card_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp) card_eq_one]\ntheorem card_eq_one : Nat.card H = 1 ↔ H = ⊥ :=\n  H.relindex_bot_left ▸ relindex_eq_one.trans le_bot_iff\n\n"}
{"name":"Subgroup.card_eq_one","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq (Nat.card (Subtype fun x => Membership.mem H x)) 1) (Eq H Bot.bot)","decl":"@[to_additive (attr := simp) card_eq_one]\ntheorem card_eq_one : Nat.card H = 1 ↔ H = ⊥ :=\n  H.relindex_bot_left ▸ relindex_eq_one.trans le_bot_iff\n\n"}
{"name":"AddSubgroup.inf_eq_bot_of_coprime","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime (Nat.card (Subtype fun x => Membership.mem K x))\n⊢ Eq (Min.min H K) Bot.bot","decl":"@[to_additive]\nlemma inf_eq_bot_of_coprime (h : Nat.Coprime (Nat.card H) (Nat.card K)) : H ⊓ K = ⊥ :=\n  card_eq_one.1 <| Nat.eq_one_of_dvd_coprimes h\n    (card_dvd_of_le inf_le_left) (card_dvd_of_le inf_le_right)\n\n"}
{"name":"Subgroup.inf_eq_bot_of_coprime","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime (Nat.card (Subtype fun x => Membership.mem K x))\n⊢ Eq (Min.min H K) Bot.bot","decl":"@[to_additive]\nlemma inf_eq_bot_of_coprime (h : Nat.Coprime (Nat.card H) (Nat.card K)) : H ⊓ K = ⊥ :=\n  card_eq_one.1 <| Nat.eq_one_of_dvd_coprimes h\n    (card_dvd_of_le inf_le_left) (card_dvd_of_le inf_le_right)\n\n"}
{"name":"add_inf_eq_bot_of_coprime","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : (Nat.card (Subtype fun x => Membership.mem H x)).Coprime (Nat.card (Subtype fun x => Membership.mem K x))\n⊢ Eq (Min.min H K) Bot.bot","decl":"@[deprecated (since := \"2024-12-18\")]\nalias _root_.add_inf_eq_bot_of_coprime := AddSubgroup.inf_eq_bot_of_coprime\n\n"}
{"name":"Subgroup.index_ne_zero_of_finite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhH : Finite (HasQuotient.Quotient G H)\n⊢ Ne H.index 0","decl":"@[to_additive]\ntheorem index_ne_zero_of_finite [hH : Finite (G ⧸ H)] : H.index ≠ 0 := by\n  cases nonempty_fintype (G ⧸ H)\n  rw [index_eq_card]\n  exact Nat.card_pos.ne'\n\n-- Porting note: changed due to error with `Cardinal.toNat_apply_of_aleph0_le`\n"}
{"name":"AddSubgroup.index_ne_zero_of_finite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nhH : Finite (HasQuotient.Quotient G H)\n⊢ Ne H.index 0","decl":"@[to_additive]\ntheorem index_ne_zero_of_finite [hH : Finite (G ⧸ H)] : H.index ≠ 0 := by\n  cases nonempty_fintype (G ⧸ H)\n  rw [index_eq_card]\n  exact Nat.card_pos.ne'\n\n-- Porting note: changed due to error with `Cardinal.toNat_apply_of_aleph0_le`\n"}
{"name":"AddSubgroup.index_eq_zero_iff_infinite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H.index 0) (Infinite (HasQuotient.Quotient G H))","decl":"@[to_additive]\nlemma index_eq_zero_iff_infinite : H.index = 0 ↔ Infinite (G ⧸ H) := by\n  simp [index_eq_card, Nat.card_eq_zero]\n\n"}
{"name":"Subgroup.index_eq_zero_iff_infinite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H.index 0) (Infinite (HasQuotient.Quotient G H))","decl":"@[to_additive]\nlemma index_eq_zero_iff_infinite : H.index = 0 ↔ Infinite (G ⧸ H) := by\n  simp [index_eq_card, Nat.card_eq_zero]\n\n"}
{"name":"AddSubgroup.one_lt_index_of_ne_top","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (HasQuotient.Quotient G H)\nhH : Ne H Top.top\n⊢ LT.lt 1 H.index","decl":"@[to_additive one_lt_index_of_ne_top]\ntheorem one_lt_index_of_ne_top [Finite (G ⧸ H)] (hH : H ≠ ⊤) : 1 < H.index :=\n  Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨index_ne_zero_of_finite, mt index_eq_one.mp hH⟩\n\n"}
{"name":"Subgroup.one_lt_index_of_ne_top","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (HasQuotient.Quotient G H)\nhH : Ne H Top.top\n⊢ LT.lt 1 H.index","decl":"@[to_additive one_lt_index_of_ne_top]\ntheorem one_lt_index_of_ne_top [Finite (G ⧸ H)] (hH : H ≠ ⊤) : 1 < H.index :=\n  Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨index_ne_zero_of_finite, mt index_eq_one.mp hH⟩\n\n"}
{"name":"Subgroup.finite_quotient_of_finite_quotient_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nX : Type u_3\ninst✝¹ : MulAction G X\ninst✝ : Finite (MulAction.orbitRel.Quotient G X)\nhi : Ne H.index 0\n⊢ Finite (MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) X)","decl":"@[to_additive]\nlemma finite_quotient_of_finite_quotient_of_index_ne_zero {X : Type*} [MulAction G X]\n    [Finite <| MulAction.orbitRel.Quotient G X] (hi : H.index ≠ 0) :\n    Finite <| MulAction.orbitRel.Quotient H X := by\n  have := fintypeOfIndexNeZero hi\n  exact MulAction.finite_quotient_of_finite_quotient_of_finite_quotient\n\n"}
{"name":"AddSubgroup.finite_quotient_of_finite_quotient_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nX : Type u_3\ninst✝¹ : AddAction G X\ninst✝ : Finite (AddAction.orbitRel.Quotient G X)\nhi : Ne H.index 0\n⊢ Finite (AddAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) X)","decl":"@[to_additive]\nlemma finite_quotient_of_finite_quotient_of_index_ne_zero {X : Type*} [MulAction G X]\n    [Finite <| MulAction.orbitRel.Quotient G X] (hi : H.index ≠ 0) :\n    Finite <| MulAction.orbitRel.Quotient H X := by\n  have := fintypeOfIndexNeZero hi\n  exact MulAction.finite_quotient_of_finite_quotient_of_finite_quotient\n\n"}
{"name":"AddSubgroup.finite_quotient_of_pretransitive_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH : AddSubgroup G\nX : Type u_3\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nhi : Ne H.index 0\n⊢ Finite (AddAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) X)","decl":"@[to_additive]\nlemma finite_quotient_of_pretransitive_of_index_ne_zero {X : Type*} [MulAction G X]\n    [MulAction.IsPretransitive G X] (hi : H.index ≠ 0) :\n    Finite <| MulAction.orbitRel.Quotient H X := by\n  have := (MulAction.pretransitive_iff_subsingleton_quotient G X).1 inferInstance\n  exact finite_quotient_of_finite_quotient_of_index_ne_zero hi\n\n"}
{"name":"Subgroup.finite_quotient_of_pretransitive_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\nH : Subgroup G\nX : Type u_3\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nhi : Ne H.index 0\n⊢ Finite (MulAction.orbitRel.Quotient (Subtype fun x => Membership.mem H x) X)","decl":"@[to_additive]\nlemma finite_quotient_of_pretransitive_of_index_ne_zero {X : Type*} [MulAction G X]\n    [MulAction.IsPretransitive G X] (hi : H.index ≠ 0) :\n    Finite <| MulAction.orbitRel.Quotient H X := by\n  have := (MulAction.pretransitive_iff_subsingleton_quotient G X).1 inferInstance\n  exact finite_quotient_of_finite_quotient_of_index_ne_zero hi\n\n"}
{"name":"AddSubgroup.exists_nsmul_mem_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Ne H.index 0\na : G\n⊢ Exists fun n => And (LT.lt 0 n) (And (LE.le n H.index) (Membership.mem H (HSMul.hSMul n a)))","decl":"@[to_additive]\nlemma exists_pow_mem_of_index_ne_zero (h : H.index ≠ 0) (a : G) :\n    ∃ n, 0 < n ∧ n ≤ H.index ∧ a ^ n ∈ H := by\n  suffices ∃ n₁ n₂, n₁ < n₂ ∧ n₂ ≤ H.index ∧ ((a ^ n₂ : G) : G ⧸ H) = ((a ^ n₁ : G) : G ⧸ H) by\n    rcases this with ⟨n₁, n₂, hlt, hle, he⟩\n    refine ⟨n₂ - n₁, by omega, by omega, ?_⟩\n    rw [eq_comm, QuotientGroup.eq, ← zpow_natCast, ← zpow_natCast, ← zpow_neg, ← zpow_add,\n        add_comm] at he\n    rw [← zpow_natCast]\n    convert he\n    omega\n  suffices ∃ n₁ n₂, n₁ ≠ n₂ ∧ n₁ ≤ H.index ∧ n₂ ≤ H.index ∧\n      ((a ^ n₂ : G) : G ⧸ H) = ((a ^ n₁ : G) : G ⧸ H) by\n    rcases this with ⟨n₁, n₂, hne, hle₁, hle₂, he⟩\n    rcases hne.lt_or_lt with hlt | hlt\n    · exact ⟨n₁, n₂, hlt, hle₂, he⟩\n    · exact ⟨n₂, n₁, hlt, hle₁, he.symm⟩\n  by_contra hc\n  simp_rw [not_exists] at hc\n  let f : (Set.Icc 0 H.index) → G ⧸ H := fun n ↦ (a ^ (n : ℕ) : G)\n  have hf : Function.Injective f := by\n    rintro ⟨n₁, h₁, hle₁⟩ ⟨n₂, h₂, hle₂⟩ he\n    have hc' := hc n₁ n₂\n    dsimp only [f] at he\n    simpa [hle₁, hle₂, he] using hc'\n  have := (fintypeOfIndexNeZero h).finite\n  have hcard := Finite.card_le_of_injective f hf\n  simp [← index_eq_card] at hcard\n\n"}
{"name":"Subgroup.exists_pow_mem_of_index_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Ne H.index 0\na : G\n⊢ Exists fun n => And (LT.lt 0 n) (And (LE.le n H.index) (Membership.mem H (HPow.hPow a n)))","decl":"@[to_additive]\nlemma exists_pow_mem_of_index_ne_zero (h : H.index ≠ 0) (a : G) :\n    ∃ n, 0 < n ∧ n ≤ H.index ∧ a ^ n ∈ H := by\n  suffices ∃ n₁ n₂, n₁ < n₂ ∧ n₂ ≤ H.index ∧ ((a ^ n₂ : G) : G ⧸ H) = ((a ^ n₁ : G) : G ⧸ H) by\n    rcases this with ⟨n₁, n₂, hlt, hle, he⟩\n    refine ⟨n₂ - n₁, by omega, by omega, ?_⟩\n    rw [eq_comm, QuotientGroup.eq, ← zpow_natCast, ← zpow_natCast, ← zpow_neg, ← zpow_add,\n        add_comm] at he\n    rw [← zpow_natCast]\n    convert he\n    omega\n  suffices ∃ n₁ n₂, n₁ ≠ n₂ ∧ n₁ ≤ H.index ∧ n₂ ≤ H.index ∧\n      ((a ^ n₂ : G) : G ⧸ H) = ((a ^ n₁ : G) : G ⧸ H) by\n    rcases this with ⟨n₁, n₂, hne, hle₁, hle₂, he⟩\n    rcases hne.lt_or_lt with hlt | hlt\n    · exact ⟨n₁, n₂, hlt, hle₂, he⟩\n    · exact ⟨n₂, n₁, hlt, hle₁, he.symm⟩\n  by_contra hc\n  simp_rw [not_exists] at hc\n  let f : (Set.Icc 0 H.index) → G ⧸ H := fun n ↦ (a ^ (n : ℕ) : G)\n  have hf : Function.Injective f := by\n    rintro ⟨n₁, h₁, hle₁⟩ ⟨n₂, h₂, hle₂⟩ he\n    have hc' := hc n₁ n₂\n    dsimp only [f] at he\n    simpa [hle₁, hle₂, he] using hc'\n  have := (fintypeOfIndexNeZero h).finite\n  have hcard := Finite.card_le_of_injective f hf\n  simp [← index_eq_card] at hcard\n\n"}
{"name":"AddSubgroup.exists_nsmul_mem_of_relindex_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Ne (H.relindex K) 0\na : G\nha : Membership.mem K a\n⊢ Exists fun n => And (LT.lt 0 n) (And (LE.le n (H.relindex K)) (Membership.mem (Min.min H K) (HSMul.hSMul n a)))","decl":"@[to_additive]\nlemma exists_pow_mem_of_relindex_ne_zero (h : H.relindex K ≠ 0) {a : G} (ha : a ∈ K) :\n    ∃ n, 0 < n ∧ n ≤ H.relindex K ∧ a ^ n ∈ H ⊓ K := by\n  rcases exists_pow_mem_of_index_ne_zero h ⟨a, ha⟩ with ⟨n, hlt, hle, he⟩\n  refine ⟨n, hlt, hle, ?_⟩\n  simpa [pow_mem ha, mem_subgroupOf] using he\n\n"}
{"name":"Subgroup.exists_pow_mem_of_relindex_ne_zero","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Ne (H.relindex K) 0\na : G\nha : Membership.mem K a\n⊢ Exists fun n => And (LT.lt 0 n) (And (LE.le n (H.relindex K)) (Membership.mem (Min.min H K) (HPow.hPow a n)))","decl":"@[to_additive]\nlemma exists_pow_mem_of_relindex_ne_zero (h : H.relindex K ≠ 0) {a : G} (ha : a ∈ K) :\n    ∃ n, 0 < n ∧ n ≤ H.relindex K ∧ a ^ n ∈ H ⊓ K := by\n  rcases exists_pow_mem_of_index_ne_zero h ⟨a, ha⟩ with ⟨n, hlt, hle, he⟩\n  refine ⟨n, hlt, hle, ?_⟩\n  simpa [pow_mem ha, mem_subgroupOf] using he\n\n"}
{"name":"AddSubgroup.nsmul_mem_of_index_ne_zero_of_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Ne H.index 0\na : G\nn : Nat\nhn : ∀ (m : Nat), LT.lt 0 m → LE.le m H.index → Dvd.dvd m n\n⊢ Membership.mem H (HSMul.hSMul n a)","decl":"@[to_additive]\nlemma pow_mem_of_index_ne_zero_of_dvd (h : H.index ≠ 0) (a : G) {n : ℕ}\n    (hn : ∀ m, 0 < m → m ≤ H.index → m ∣ n) : a ^ n ∈ H := by\n  rcases exists_pow_mem_of_index_ne_zero h a with ⟨m, hlt, hle, he⟩\n  rcases hn m hlt hle with ⟨k, rfl⟩\n  rw [pow_mul]\n  exact pow_mem he _\n\n"}
{"name":"Subgroup.pow_mem_of_index_ne_zero_of_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : Ne H.index 0\na : G\nn : Nat\nhn : ∀ (m : Nat), LT.lt 0 m → LE.le m H.index → Dvd.dvd m n\n⊢ Membership.mem H (HPow.hPow a n)","decl":"@[to_additive]\nlemma pow_mem_of_index_ne_zero_of_dvd (h : H.index ≠ 0) (a : G) {n : ℕ}\n    (hn : ∀ m, 0 < m → m ≤ H.index → m ∣ n) : a ^ n ∈ H := by\n  rcases exists_pow_mem_of_index_ne_zero h a with ⟨m, hlt, hle, he⟩\n  rcases hn m hlt hle with ⟨k, rfl⟩\n  rw [pow_mul]\n  exact pow_mem he _\n\n"}
{"name":"Subgroup.pow_mem_of_relindex_ne_zero_of_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : Ne (H.relindex K) 0\na : G\nha : Membership.mem K a\nn : Nat\nhn : ∀ (m : Nat), LT.lt 0 m → LE.le m (H.relindex K) → Dvd.dvd m n\n⊢ Membership.mem (Min.min H K) (HPow.hPow a n)","decl":"@[to_additive]\nlemma pow_mem_of_relindex_ne_zero_of_dvd (h : H.relindex K ≠ 0) {a : G} (ha : a ∈ K) {n : ℕ}\n    (hn : ∀ m, 0 < m → m ≤ H.relindex K → m ∣ n) : a ^ n ∈ H ⊓ K := by\n  convert pow_mem_of_index_ne_zero_of_dvd h ⟨a, ha⟩ hn\n  simp [pow_mem ha, mem_subgroupOf]\n\n"}
{"name":"AddSubgroup.nsmul_mem_of_relindex_ne_zero_of_dvd","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nh : Ne (H.relindex K) 0\na : G\nha : Membership.mem K a\nn : Nat\nhn : ∀ (m : Nat), LT.lt 0 m → LE.le m (H.relindex K) → Dvd.dvd m n\n⊢ Membership.mem (Min.min H K) (HSMul.hSMul n a)","decl":"@[to_additive]\nlemma pow_mem_of_relindex_ne_zero_of_dvd (h : H.relindex K ≠ 0) {a : G} (ha : a ∈ K) {n : ℕ}\n    (hn : ∀ m, 0 < m → m ≤ H.relindex K → m ∣ n) : a ^ n ∈ H ⊓ K := by\n  convert pow_mem_of_index_ne_zero_of_dvd h ⟨a, ha⟩ hn\n  simp [pow_mem ha, mem_subgroupOf]\n\n"}
{"name":"AddSubgroup.index_sum","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\nH : AddSubgroup G\nK : AddSubgroup G'\n⊢ Eq (H.prod K).index (HMul.hMul H.index K.index)","decl":"@[to_additive (attr := simp)]\nlemma index_prod (H : Subgroup G) (K : Subgroup G') : (H.prod K).index = H.index * K.index := by\n  simp_rw [index, ← Nat.card_prod]\n  refine Nat.card_congr\n    ((Quotient.congrRight (fun x y ↦ ?_)).trans (Setoid.prodQuotientEquiv _ _).symm)\n  rw [QuotientGroup.leftRel_prod]\n\n"}
{"name":"Subgroup.index_prod","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\nH : Subgroup G\nK : Subgroup G'\n⊢ Eq (H.prod K).index (HMul.hMul H.index K.index)","decl":"@[to_additive (attr := simp)]\nlemma index_prod (H : Subgroup G) (K : Subgroup G') : (H.prod K).index = H.index * K.index := by\n  simp_rw [index, ← Nat.card_prod]\n  refine Nat.card_congr\n    ((Quotient.congrRight (fun x y ↦ ?_)).trans (Setoid.prodQuotientEquiv _ _).symm)\n  rw [QuotientGroup.leftRel_prod]\n\n"}
{"name":"AddSubgroup.index_pi","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_3\ninst✝ : Fintype ι\nH : ι → AddSubgroup G\n⊢ Eq (AddSubgroup.pi Set.univ H).index (Finset.univ.prod fun i => (H i).index)","decl":"@[to_additive (attr := simp)]\nlemma index_pi {ι : Type*} [Fintype ι] (H : ι → Subgroup G) :\n    (Subgroup.pi Set.univ H).index = ∏ i, (H i).index := by\n  simp_rw [index, ← Nat.card_pi]\n  refine Nat.card_congr\n    ((Quotient.congrRight (fun x y ↦ ?_)).trans (Setoid.piQuotientEquiv _).symm)\n  rw [QuotientGroup.leftRel_pi]\n\n"}
{"name":"Subgroup.index_pi","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_3\ninst✝ : Fintype ι\nH : ι → Subgroup G\n⊢ Eq (Subgroup.pi Set.univ H).index (Finset.univ.prod fun i => (H i).index)","decl":"@[to_additive (attr := simp)]\nlemma index_pi {ι : Type*} [Fintype ι] (H : ι → Subgroup G) :\n    (Subgroup.pi Set.univ H).index = ∏ i, (H i).index := by\n  simp_rw [index, ← Nat.card_pi]\n  refine Nat.card_congr\n    ((Quotient.congrRight (fun x y ↦ ?_)).trans (Setoid.piQuotientEquiv _).symm)\n  rw [QuotientGroup.leftRel_pi]\n\n"}
{"name":"Subgroup.index_toAddSubgroup","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq (Subgroup.toAddSubgroup H).index H.index","decl":"@[simp]\nlemma index_toAddSubgroup : (Subgroup.toAddSubgroup H).index = H.index :=\n  rfl\n\n"}
{"name":"AddSubgroup.index_toSubgroup","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Eq (AddSubgroup.toSubgroup H).index H.index","decl":"@[simp]\nlemma _root_.AddSubgroup.index_toSubgroup {G : Type*} [AddGroup G] (H : AddSubgroup G) :\n    (AddSubgroup.toSubgroup H).index = H.index :=\n  rfl\n\n"}
{"name":"Subgroup.relindex_toAddSubgroup","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\n⊢ Eq ((Subgroup.toAddSubgroup H).relindex (Subgroup.toAddSubgroup K)) (H.relindex K)","decl":"@[simp]\nlemma relindex_toAddSubgroup :\n    (Subgroup.toAddSubgroup H).relindex (Subgroup.toAddSubgroup K) = H.relindex K :=\n  rfl\n\n"}
{"name":"AddSubgroup.relindex_toSubgroup","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nH K : AddSubgroup G\n⊢ Eq ((AddSubgroup.toSubgroup H).relindex (AddSubgroup.toSubgroup K)) (H.relindex K)","decl":"@[simp]\nlemma _root_.AddSubgroup.relindex_toSubgroup {G : Type*} [AddGroup G] (H K : AddSubgroup G) :\n    (AddSubgroup.toSubgroup H).relindex (AddSubgroup.toSubgroup K) = H.relindex K :=\n  rfl\n\n"}
{"name":"Subgroup.FiniteIndex.finiteIndex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nself : H.FiniteIndex\n⊢ Ne H.index 0","decl":"/-- Typeclass for finite index subgroups. -/\nclass FiniteIndex : Prop where\n  /-- The subgroup has finite index -/\n  finiteIndex : H.index ≠ 0\n\n"}
{"name":"AddSubgroup.FiniteIndex.finiteIndex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_3\ninst✝ : AddGroup G\nH : AddSubgroup G\nself : H.FiniteIndex\n⊢ Ne H.index 0","decl":"/-- Typeclass for finite index subgroups. -/\nclass _root_.AddSubgroup.FiniteIndex {G : Type*} [AddGroup G] (H : AddSubgroup G) : Prop where\n  /-- The additive subgroup has finite index -/\n  finiteIndex : H.index ≠ 0\n\n"}
{"name":"AddSubgroup.finite_quotient_of_finiteIndex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : H.FiniteIndex\n⊢ Finite (HasQuotient.Quotient G H)","decl":"@[to_additive]\ninstance finite_quotient_of_finiteIndex [FiniteIndex H] : Finite (G ⧸ H) :=\n  H.fintypeQuotientOfFiniteIndex.finite\n\n"}
{"name":"Subgroup.finite_quotient_of_finiteIndex","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.FiniteIndex\n⊢ Finite (HasQuotient.Quotient G H)","decl":"@[to_additive]\ninstance finite_quotient_of_finiteIndex [FiniteIndex H] : Finite (G ⧸ H) :=\n  H.fintypeQuotientOfFiniteIndex.finite\n\n"}
{"name":"Subgroup.finiteIndex_of_finite_quotient","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite (HasQuotient.Quotient G H)\n⊢ H.FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=\n  ⟨index_ne_zero_of_finite⟩\n\n-- Porting note: had to manually provide finite instance for quotient when it should be automatic\n"}
{"name":"AddSubgroup.finiteIndex_of_finite_quotient","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite (HasQuotient.Quotient G H)\n⊢ H.FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_of_finite_quotient [Finite (G ⧸ H)] : FiniteIndex H :=\n  ⟨index_ne_zero_of_finite⟩\n\n-- Porting note: had to manually provide finite instance for quotient when it should be automatic\n"}
{"name":"Subgroup.finiteIndex_of_finite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : Finite G\n⊢ H.FiniteIndex","decl":"@[to_additive]\ninstance (priority := 100) finiteIndex_of_finite [Finite G] : FiniteIndex H :=\n  @finiteIndex_of_finite_quotient _ _ H (Quotient.finite _)\n\n"}
{"name":"AddSubgroup.finiteIndex_of_finite","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\ninst✝ : Finite G\n⊢ H.FiniteIndex","decl":"@[to_additive]\ninstance (priority := 100) finiteIndex_of_finite [Finite G] : FiniteIndex H :=\n  @finiteIndex_of_finite_quotient _ _ H (Quotient.finite _)\n\n"}
{"name":"AddSubgroup.instFiniteIndexTop","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Top.top.FiniteIndex","decl":"@[to_additive]\ninstance : FiniteIndex (⊤ : Subgroup G) :=\n  ⟨ne_of_eq_of_ne index_top one_ne_zero⟩\n\n"}
{"name":"Subgroup.instFiniteIndexTop","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Top.top.FiniteIndex","decl":"@[to_additive]\ninstance : FiniteIndex (⊤ : Subgroup G) :=\n  ⟨ne_of_eq_of_ne index_top one_ne_zero⟩\n\n"}
{"name":"AddSubgroup.instFiniteIndexMin","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nH K : AddSubgroup G\ninst✝¹ : H.FiniteIndex\ninst✝ : K.FiniteIndex\n⊢ (Min.min H K).FiniteIndex","decl":"@[to_additive]\ninstance [FiniteIndex H] [FiniteIndex K] : FiniteIndex (H ⊓ K) :=\n  ⟨index_inf_ne_zero FiniteIndex.finiteIndex FiniteIndex.finiteIndex⟩\n\n"}
{"name":"Subgroup.instFiniteIndexMin","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\nH K : Subgroup G\ninst✝¹ : H.FiniteIndex\ninst✝ : K.FiniteIndex\n⊢ (Min.min H K).FiniteIndex","decl":"@[to_additive]\ninstance [FiniteIndex H] [FiniteIndex K] : FiniteIndex (H ⊓ K) :=\n  ⟨index_inf_ne_zero FiniteIndex.finiteIndex FiniteIndex.finiteIndex⟩\n\n"}
{"name":"AddSubgroup.finiteIndex_iInf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_3\ninst✝ : Finite ι\nf : ι → AddSubgroup G\nhf : ∀ (i : ι), (f i).FiniteIndex\n⊢ (iInf fun i => f i).FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_iInf {ι : Type*} [Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).FiniteIndex) : (⨅ i, f i).FiniteIndex :=\n  ⟨index_iInf_ne_zero fun i => (hf i).finiteIndex⟩\n\n"}
{"name":"Subgroup.finiteIndex_iInf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_3\ninst✝ : Finite ι\nf : ι → Subgroup G\nhf : ∀ (i : ι), (f i).FiniteIndex\n⊢ (iInf fun i => f i).FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_iInf {ι : Type*} [Finite ι] {f : ι → Subgroup G}\n    (hf : ∀ i, (f i).FiniteIndex) : (⨅ i, f i).FiniteIndex :=\n  ⟨index_iInf_ne_zero fun i => (hf i).finiteIndex⟩\n\n"}
{"name":"AddSubgroup.finiteIndex_iInf'","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_3\ns : Finset ι\nf : ι → AddSubgroup G\nhs : ∀ (i : ι), Membership.mem s i → (f i).FiniteIndex\n⊢ (iInf fun i => iInf fun h => f i).FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_iInf' {ι : Type*} {s : Finset ι}\n    (f : ι → Subgroup G) (hs : ∀ i ∈ s, (f i).FiniteIndex) :\n    (⨅ i ∈ s, f i).FiniteIndex := by\n  rw [iInf_subtype']\n  exact finiteIndex_iInf fun ⟨i, hi⟩ => hs i hi\n\n"}
{"name":"Subgroup.finiteIndex_iInf'","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_3\ns : Finset ι\nf : ι → Subgroup G\nhs : ∀ (i : ι), Membership.mem s i → (f i).FiniteIndex\n⊢ (iInf fun i => iInf fun h => f i).FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_iInf' {ι : Type*} {s : Finset ι}\n    (f : ι → Subgroup G) (hs : ∀ i ∈ s, (f i).FiniteIndex) :\n    (⨅ i ∈ s, f i).FiniteIndex := by\n  rw [iInf_subtype']\n  exact finiteIndex_iInf fun ⟨i, hi⟩ => hs i hi\n\n"}
{"name":"AddSubgroup.instFiniteIndex_addSubgroupOf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : H.FiniteIndex\n⊢ (H.addSubgroupOf K).FiniteIndex","decl":"@[to_additive]\ninstance instFiniteIndex_subgroupOf (H K : Subgroup G) [H.FiniteIndex] :\n    (H.subgroupOf K).FiniteIndex :=\n  ⟨fun h => H.index_ne_zero_of_finite <| H.index_eq_zero_of_relindex_eq_zero h⟩\n\n"}
{"name":"Subgroup.instFiniteIndex_subgroupOf","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : H.FiniteIndex\n⊢ (H.subgroupOf K).FiniteIndex","decl":"@[to_additive]\ninstance instFiniteIndex_subgroupOf (H K : Subgroup G) [H.FiniteIndex] :\n    (H.subgroupOf K).FiniteIndex :=\n  ⟨fun h => H.index_ne_zero_of_finite <| H.index_eq_zero_of_relindex_eq_zero h⟩\n\n"}
{"name":"Subgroup.finiteIndex_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\ninst✝ : H.FiniteIndex\nh : LE.le H K\n⊢ K.FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_of_le [FiniteIndex H] (h : H ≤ K) : FiniteIndex K :=\n  ⟨ne_zero_of_dvd_ne_zero FiniteIndex.finiteIndex (index_dvd_of_le h)⟩\n\n"}
{"name":"AddSubgroup.finiteIndex_of_le","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\ninst✝ : H.FiniteIndex\nh : LE.le H K\n⊢ K.FiniteIndex","decl":"@[to_additive]\ntheorem finiteIndex_of_le [FiniteIndex H] (h : H ≤ K) : FiniteIndex K :=\n  ⟨ne_zero_of_dvd_ne_zero FiniteIndex.finiteIndex (index_dvd_of_le h)⟩\n\n"}
{"name":"AddSubgroup.index_antitone","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\nh : LE.le H K\ninst✝ : H.FiniteIndex\n⊢ LE.le K.index H.index","decl":"@[to_additive (attr := gcongr)]\nlemma index_antitone (h : H ≤ K) [H.FiniteIndex] : K.index ≤ H.index :=\n  Nat.le_of_dvd (Nat.zero_lt_of_ne_zero FiniteIndex.finiteIndex) (index_dvd_of_le h)\n\n"}
{"name":"Subgroup.index_antitone","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\nh : LE.le H K\ninst✝ : H.FiniteIndex\n⊢ LE.le K.index H.index","decl":"@[to_additive (attr := gcongr)]\nlemma index_antitone (h : H ≤ K) [H.FiniteIndex] : K.index ≤ H.index :=\n  Nat.le_of_dvd (Nat.zero_lt_of_ne_zero FiniteIndex.finiteIndex) (index_dvd_of_le h)\n\n"}
{"name":"Subgroup.index_strictAnti","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH K : Subgroup G\nh : LT.lt H K\ninst✝ : H.FiniteIndex\n⊢ LT.lt K.index H.index","decl":"@[to_additive (attr := gcongr)]\nlemma index_strictAnti (h : H < K) [H.FiniteIndex] : K.index < H.index := by\n  have h0 : K.index ≠ 0 := (finiteIndex_of_le h.le).finiteIndex\n  apply lt_of_le_of_ne (index_antitone h.le)\n  rw [← relindex_mul_index h.le, Ne, eq_comm, mul_eq_right₀ h0, relindex_eq_one]\n  exact h.not_le\n\n"}
{"name":"AddSubgroup.index_strictAnti","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH K : AddSubgroup G\nh : LT.lt H K\ninst✝ : H.FiniteIndex\n⊢ LT.lt K.index H.index","decl":"@[to_additive (attr := gcongr)]\nlemma index_strictAnti (h : H < K) [H.FiniteIndex] : K.index < H.index := by\n  have h0 : K.index ≠ 0 := (finiteIndex_of_le h.le).finiteIndex\n  apply lt_of_le_of_ne (index_antitone h.le)\n  rw [← relindex_mul_index h.le, Ne, eq_comm, mul_eq_right₀ h0, relindex_eq_one]\n  exact h.not_le\n\n"}
{"name":"Subgroup.finiteIndex_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\nG' : Type u_3\ninst✝¹ : Group G'\nf : MonoidHom G G'\ninst✝ : Finite (Subtype fun x => Membership.mem f.range x)\n⊢ f.ker.FiniteIndex","decl":"@[to_additive]\ninstance finiteIndex_ker {G' : Type*} [Group G'] (f : G →* G') [Finite f.range] :\n    f.ker.FiniteIndex :=\n  @finiteIndex_of_finite_quotient G _ f.ker\n    (Finite.of_equiv f.range (QuotientGroup.quotientKerEquivRange f).symm)\n\n"}
{"name":"AddSubgroup.finiteIndex_ker","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nG' : Type u_3\ninst✝¹ : AddGroup G'\nf : AddMonoidHom G G'\ninst✝ : Finite (Subtype fun x => Membership.mem f.range x)\n⊢ f.ker.FiniteIndex","decl":"@[to_additive]\ninstance finiteIndex_ker {G' : Type*} [Group G'] (f : G →* G') [Finite f.range] :\n    f.ker.FiniteIndex :=\n  @finiteIndex_of_finite_quotient G _ f.ker\n    (Finite.of_equiv f.range (QuotientGroup.quotientKerEquivRange f).symm)\n\n"}
{"name":"Subgroup.finiteIndex_normalCore","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.FiniteIndex\n⊢ H.normalCore.FiniteIndex","decl":"instance finiteIndex_normalCore [H.FiniteIndex] : H.normalCore.FiniteIndex := by\n  rw [normalCore_eq_ker]\n  infer_instance\n\n"}
{"name":"Subgroup.finiteIndex_center","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite ↑(commutatorSet G)\ninst✝ : Group.FG G\n⊢ (Subgroup.center G).FiniteIndex","decl":"instance finiteIndex_center [Finite (commutatorSet G)] [Group.FG G] : FiniteIndex (center G) := by\n  obtain ⟨S, -, hS⟩ := Group.rank_spec G\n  exact ⟨mt (Finite.card_eq_zero_of_embedding (quotientCenterEmbedding hS)) Finite.card_pos.ne'⟩\n\n"}
{"name":"Subgroup.index_center_le_pow","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\ninst✝² : Group G\ninst✝¹ : Finite ↑(commutatorSet G)\ninst✝ : Group.FG G\n⊢ LE.le (Subgroup.center G).index (HPow.hPow (Nat.card ↑(commutatorSet G)) (Group.rank G))","decl":"theorem index_center_le_pow [Finite (commutatorSet G)] [Group.FG G] :\n    (center G).index ≤ Nat.card (commutatorSet G) ^ Group.rank G := by\n  obtain ⟨S, hS1, hS2⟩ := Group.rank_spec G\n  rw [← hS1, ← Fintype.card_coe, ← Nat.card_eq_fintype_card, ← Finset.coe_sort_coe, ← Nat.card_fun]\n  exact Finite.card_le_of_embedding (quotientCenterEmbedding hS2)\n\n"}
{"name":"MulAction.index_stabilizer","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : Group G\ninst✝ : MulAction G X\nx : X\n⊢ Eq (MulAction.stabilizer G x).index (MulAction.orbit G x).ncard","decl":"@[to_additive] theorem index_stabilizer :\n    (stabilizer G x).index = (orbit G x).ncard :=\n  (Nat.card_congr (MulAction.orbitEquivQuotientStabilizer G x)).symm.trans\n    (Set.Nat.card_coe_set_eq (orbit G x))\n\n"}
{"name":"AddAction.index_stabilizer","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddAction G X\nx : X\n⊢ Eq (AddAction.stabilizer G x).index (AddAction.orbit G x).ncard","decl":"@[to_additive] theorem index_stabilizer :\n    (stabilizer G x).index = (orbit G x).ncard :=\n  (Nat.card_congr (MulAction.orbitEquivQuotientStabilizer G x)).symm.trans\n    (Set.Nat.card_coe_set_eq (orbit G x))\n\n"}
{"name":"MulAction.index_stabilizer_of_transitive","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝² : Group G\ninst✝¹ : MulAction G X\nx : X\ninst✝ : MulAction.IsPretransitive G X\n⊢ Eq (MulAction.stabilizer G x).index (Nat.card X)","decl":"@[to_additive] theorem index_stabilizer_of_transitive [IsPretransitive G X] :\n    (stabilizer G x).index = Nat.card X := by\n  rw [index_stabilizer, orbit_eq_univ, Set.ncard_univ]\n\n"}
{"name":"AddAction.index_stabilizer_of_transitive","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : AddAction G X\nx : X\ninst✝ : AddAction.IsPretransitive G X\n⊢ Eq (AddAction.stabilizer G x).index (Nat.card X)","decl":"@[to_additive] theorem index_stabilizer_of_transitive [IsPretransitive G X] :\n    (stabilizer G x).index = Nat.card X := by\n  rw [index_stabilizer, orbit_eq_univ, Set.ncard_univ]\n\n"}
{"name":"AddMonoidHom.card_fiber_eq_of_mem_range","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nM : Type u_2\nF : Type u_3\ninst✝⁵ : AddGroup G\ninst✝⁴ : Fintype G\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq M\ninst✝¹ : FunLike F G M\ninst✝ : AddMonoidHomClass F G M\nf : F\nx y : M\nhx : Membership.mem (Set.range ⇑f) x\nhy : Membership.mem (Set.range ⇑f) y\n⊢ Eq (Finset.filter (fun g => Eq (f g) x) Finset.univ).card (Finset.filter (fun g => Eq (f g) y) Finset.univ).card","decl":"@[to_additive]\nlemma card_fiber_eq_of_mem_range (f : F) {x y : M} (hx : x ∈ Set.range f) (hy : y ∈ Set.range f) :\n    #{g | f g = x} = #{g | f g = y} := by\n  rcases hx with ⟨x, rfl⟩\n  rcases hy with ⟨y, rfl⟩\n  rcases mul_left_surjective x y with ⟨y, rfl⟩\n  conv_lhs =>\n    rw [← map_univ_equiv (Equiv.mulRight y⁻¹), filter_map, card_map]\n  congr 2 with g\n  simp only [Function.comp, Equiv.toEmbedding_apply, Equiv.coe_mulRight, map_mul]\n  let f' := MonoidHomClass.toMonoidHom f\n  show f' g * f' y⁻¹ = f' x ↔ f' g = f' x * f' y\n  rw [← f'.coe_toHomUnits y⁻¹, map_inv, Units.mul_inv_eq_iff_eq_mul, f'.coe_toHomUnits]\n\n"}
{"name":"MonoidHom.card_fiber_eq_of_mem_range","module":"Mathlib.GroupTheory.Index","initialProofState":"G : Type u_1\nM : Type u_2\nF : Type u_3\ninst✝⁵ : Group G\ninst✝⁴ : Fintype G\ninst✝³ : Monoid M\ninst✝² : DecidableEq M\ninst✝¹ : FunLike F G M\ninst✝ : MonoidHomClass F G M\nf : F\nx y : M\nhx : Membership.mem (Set.range ⇑f) x\nhy : Membership.mem (Set.range ⇑f) y\n⊢ Eq (Finset.filter (fun g => Eq (f g) x) Finset.univ).card (Finset.filter (fun g => Eq (f g) y) Finset.univ).card","decl":"@[to_additive]\nlemma card_fiber_eq_of_mem_range (f : F) {x y : M} (hx : x ∈ Set.range f) (hy : y ∈ Set.range f) :\n    #{g | f g = x} = #{g | f g = y} := by\n  rcases hx with ⟨x, rfl⟩\n  rcases hy with ⟨y, rfl⟩\n  rcases mul_left_surjective x y with ⟨y, rfl⟩\n  conv_lhs =>\n    rw [← map_univ_equiv (Equiv.mulRight y⁻¹), filter_map, card_map]\n  congr 2 with g\n  simp only [Function.comp, Equiv.toEmbedding_apply, Equiv.coe_mulRight, map_mul]\n  let f' := MonoidHomClass.toMonoidHom f\n  show f' g * f' y⁻¹ = f' x ↔ f' g = f' x * f' y\n  rw [← f'.coe_toHomUnits y⁻¹, map_inv, Units.mul_inv_eq_iff_eq_mul, f'.coe_toHomUnits]\n\n"}
