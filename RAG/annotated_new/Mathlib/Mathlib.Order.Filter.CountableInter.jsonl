{"name":"CountableInterFilter.countable_sInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\nself : CountableInterFilter l\nS : Set (Set α)\na✝¹ : S.Countable\na✝ : ∀ (s : Set α), Membership.mem S s → Membership.mem l s\n⊢ Membership.mem l S.sInter","decl":"/-- A filter `l` has the countable intersection property if for any countable collection\nof sets `s ∈ l` their intersection belongs to `l` as well. -/\nclass CountableInterFilter (l : Filter α) : Prop where\n  /-- For a countable collection of sets `s ∈ l`, their intersection belongs to `l` as well. -/\n  countable_sInter_mem : ∀ S : Set (Set α), S.Countable → (∀ s ∈ S, s ∈ l) → ⋂₀ S ∈ l\n\n"}
{"name":"countable_sInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nS : Set (Set α)\nhSc : S.Countable\n⊢ Iff (Membership.mem l S.sInter) (∀ (s : Set α), Membership.mem S s → Membership.mem l s)","decl":"theorem countable_sInter_mem {S : Set (Set α)} (hSc : S.Countable) : ⋂₀ S ∈ l ↔ ∀ s ∈ S, s ∈ l :=\n  ⟨fun hS _s hs => mem_of_superset hS (sInter_subset_of_mem hs),\n    CountableInterFilter.countable_sInter_mem _ hSc⟩\n\n"}
{"name":"countable_iInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Iff (Membership.mem l (Set.iInter fun i => s i)) (∀ (i : ι), Membership.mem l (s i))","decl":"theorem countable_iInter_mem [Countable ι] {s : ι → Set α} : (⋂ i, s i) ∈ l ↔ ∀ i, s i ∈ l :=\n  sInter_range s ▸ (countable_sInter_mem (countable_range _)).trans forall_mem_range\n\n"}
{"name":"countable_bInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\ns : (i : ι) → Membership.mem S i → Set α\n⊢ Iff (Membership.mem l (Set.iInter fun i => Set.iInter fun hi => s i hi)) (∀ (i : ι) (hi : Membership.mem S i), Membership.mem l (s i hi))","decl":"theorem countable_bInter_mem {ι : Type*} {S : Set ι} (hS : S.Countable) {s : ∀ i ∈ S, Set α} :\n    (⋂ i, ⋂ hi : i ∈ S, s i ‹_›) ∈ l ↔ ∀ i, ∀ hi : i ∈ S, s i ‹_› ∈ l := by\n  rw [biInter_eq_iInter]\n  haveI := hS.toEncodable\n  exact countable_iInter_mem.trans Subtype.forall\n\n"}
{"name":"eventually_countable_forall","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\np : α → ι → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι), p x i) l) (∀ (i : ι), Filter.Eventually (fun x => p x i) l)","decl":"theorem eventually_countable_forall [Countable ι] {p : α → ι → Prop} :\n    (∀ᶠ x in l, ∀ i, p x i) ↔ ∀ i, ∀ᶠ x in l, p x i := by\n  simpa only [Filter.Eventually, setOf_forall] using\n    @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }\n\n"}
{"name":"eventually_countable_ball","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\np : α → (i : ι) → Membership.mem S i → Prop\n⊢ Iff (Filter.Eventually (fun x => ∀ (i : ι) (hi : Membership.mem S i), p x i hi) l) (∀ (i : ι) (hi : Membership.mem S i), Filter.Eventually (fun x => p x i hi) l)","decl":"theorem eventually_countable_ball {ι : Type*} {S : Set ι} (hS : S.Countable)\n    {p : α → ∀ i ∈ S, Prop} :\n    (∀ᶠ x in l, ∀ i hi, p x i hi) ↔ ∀ i hi, ∀ᶠ x in l, p x i hi := by\n  simpa only [Filter.Eventually, setOf_forall] using\n    @countable_bInter_mem _ l _ _ _ hS fun i hi => { x | p x i hi }\n\n"}
{"name":"EventuallyLE.countable_iUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyLE.countable_iUnion [Countable ι] {s t : ι → Set α} (h : ∀ i, s i ≤ᶠ[l] t i) :\n    ⋃ i, s i ≤ᶠ[l] ⋃ i, t i :=\n  (eventually_countable_forall.2 h).mono fun _ hst hs => mem_iUnion.2 <| (mem_iUnion.1 hs).imp hst\n\n"}
{"name":"EventuallyEq.countable_iUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyEq.countable_iUnion [Countable ι] {s t : ι → Set α} (h : ∀ i, s i =ᶠ[l] t i) :\n    ⋃ i, s i =ᶠ[l] ⋃ i, t i :=\n  (EventuallyLE.countable_iUnion fun i => (h i).le).antisymm\n    (EventuallyLE.countable_iUnion fun i => (h i).symm.le)\n\n"}
{"name":"EventuallyLE.countable_bUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n⊢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyLE.countable_bUnion {ι : Type*} {S : Set ι} (hS : S.Countable)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi ≤ᶠ[l] t i hi) :\n    ⋃ i ∈ S, s i ‹_› ≤ᶠ[l] ⋃ i ∈ S, t i ‹_› := by\n  simp only [biUnion_eq_iUnion]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iUnion fun i => h i i.2\n\n"}
{"name":"EventuallyEq.countable_bUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n⊢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyEq.countable_bUnion {ι : Type*} {S : Set ι} (hS : S.Countable)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi =ᶠ[l] t i hi) :\n    ⋃ i ∈ S, s i ‹_› =ᶠ[l] ⋃ i ∈ S, t i ‹_› :=\n  (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"EventuallyLE.countable_iInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyLE (s i) (t i)\n⊢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyLE.countable_iInter [Countable ι] {s t : ι → Set α} (h : ∀ i, s i ≤ᶠ[l] t i) :\n    ⋂ i, s i ≤ᶠ[l] ⋂ i, t i :=\n  (eventually_countable_forall.2 h).mono fun _ hst hs =>\n    mem_iInter.2 fun i => hst _ (mem_iInter.1 hs i)\n\n"}
{"name":"EventuallyEq.countable_iInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"ι : Sort u_1\nα : Type u_2\nl : Filter α\ninst✝¹ : CountableInterFilter l\ninst✝ : Countable ι\ns t : ι → Set α\nh : ∀ (i : ι), l.EventuallyEq (s i) (t i)\n⊢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyEq.countable_iInter [Countable ι] {s t : ι → Set α} (h : ∀ i, s i =ᶠ[l] t i) :\n    ⋂ i, s i =ᶠ[l] ⋂ i, t i :=\n  (EventuallyLE.countable_iInter fun i => (h i).le).antisymm\n    (EventuallyLE.countable_iInter fun i => (h i).symm.le)\n\n"}
{"name":"EventuallyLE.countable_bInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\n⊢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyLE.countable_bInter {ι : Type*} {S : Set ι} (hS : S.Countable)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi ≤ᶠ[l] t i hi) :\n    ⋂ i ∈ S, s i ‹_› ≤ᶠ[l] ⋂ i ∈ S, t i ‹_› := by\n  simp only [biInter_eq_iInter]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iInter fun i => h i i.2\n\n"}
{"name":"EventuallyEq.countable_bInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Filter α\ninst✝ : CountableInterFilter l\nι : Type u_4\nS : Set ι\nhS : S.Countable\ns t : (i : ι) → Membership.mem S i → Set α\nh : ∀ (i : ι) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\n⊢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyEq.countable_bInter {ι : Type*} {S : Set ι} (hS : S.Countable)\n    {s t : ∀ i ∈ S, Set α} (h : ∀ i hi, s i hi =ᶠ[l] t i hi) :\n    ⋂ i ∈ S, s i ‹_› =ᶠ[l] ⋂ i ∈ S, t i ‹_› :=\n  (EventuallyLE.countable_bInter hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.countable_bInter hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.countableInter_ofCountableInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Set (Set α)\nhl : ∀ (S : Set (Set α)), S.Countable → HasSubset.Subset S l → Membership.mem l S.sInter\nh_mono : ∀ (s t : Set α), Membership.mem l s → HasSubset.Subset s t → Membership.mem l t\n⊢ CountableInterFilter (Filter.ofCountableInter l hl h_mono)","decl":"instance Filter.countableInter_ofCountableInter (l : Set (Set α))\n    (hl : ∀ S : Set (Set α), S.Countable → S ⊆ l → ⋂₀ S ∈ l)\n    (h_mono : ∀ s t, s ∈ l → s ⊆ t → t ∈ l) :\n    CountableInterFilter (Filter.ofCountableInter l hl h_mono) :=\n  ⟨hl⟩\n\n"}
{"name":"Filter.mem_ofCountableInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Set (Set α)\nhl : ∀ (S : Set (Set α)), S.Countable → HasSubset.Subset S l → Membership.mem l S.sInter\nh_mono : ∀ (s t : Set α), Membership.mem l s → HasSubset.Subset s t → Membership.mem l t\ns : Set α\n⊢ Iff (Membership.mem (Filter.ofCountableInter l hl h_mono) s) (Membership.mem l s)","decl":"@[simp]\ntheorem Filter.mem_ofCountableInter {l : Set (Set α)}\n    (hl : ∀ S : Set (Set α), S.Countable → S ⊆ l → ⋂₀ S ∈ l) (h_mono : ∀ s t, s ∈ l → s ⊆ t → t ∈ l)\n    {s : Set α} : s ∈ Filter.ofCountableInter l hl h_mono ↔ s ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Filter.countableInter_ofCountableUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Set (Set α)\nh₁ : ∀ (S : Set (Set α)), S.Countable → (∀ (s : Set α), Membership.mem S s → Membership.mem l s) → Membership.mem l S.sUnion\nh₂ : ∀ (t : Set α), Membership.mem l t → ∀ (s : Set α), HasSubset.Subset s t → Membership.mem l s\n⊢ CountableInterFilter (Filter.ofCountableUnion l h₁ h₂)","decl":"instance Filter.countableInter_ofCountableUnion (l : Set (Set α)) (h₁ h₂) :\n    CountableInterFilter (Filter.ofCountableUnion l h₁ h₂) :=\n  countableInter_ofCountableInter ..\n\n"}
{"name":"Filter.mem_ofCountableUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl : Set (Set α)\nhunion : ∀ (S : Set (Set α)), S.Countable → (∀ (s : Set α), Membership.mem S s → Membership.mem l s) → Membership.mem l S.sUnion\nhmono : ∀ (t : Set α), Membership.mem l t → ∀ (s : Set α), HasSubset.Subset s t → Membership.mem l s\ns : Set α\n⊢ Iff (Membership.mem (Filter.ofCountableUnion l hunion hmono) s) (l (HasCompl.compl s))","decl":"@[simp]\ntheorem Filter.mem_ofCountableUnion {l : Set (Set α)} {hunion hmono s} :\n    s ∈ ofCountableUnion l hunion hmono ↔ l sᶜ :=\n  Iff.rfl\n\n"}
{"name":"countableInterFilter_principal","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\ns : Set α\n⊢ CountableInterFilter (Filter.principal s)","decl":"instance countableInterFilter_principal (s : Set α) : CountableInterFilter (𝓟 s) :=\n  ⟨fun _ _ hS => subset_sInter hS⟩\n\n"}
{"name":"countableInterFilter_bot","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\n⊢ CountableInterFilter Bot.bot","decl":"instance countableInterFilter_bot : CountableInterFilter (⊥ : Filter α) := by\n  rw [← principal_empty]\n  apply countableInterFilter_principal\n\n"}
{"name":"countableInterFilter_top","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\n⊢ CountableInterFilter Top.top","decl":"instance countableInterFilter_top : CountableInterFilter (⊤ : Filter α) := by\n  rw [← principal_univ]\n  apply countableInterFilter_principal\n\n"}
{"name":"instCountableInterFilterComap","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nβ : Type u_3\nl : Filter β\ninst✝ : CountableInterFilter l\nf : α → β\n⊢ CountableInterFilter (Filter.comap f l)","decl":"instance (l : Filter β) [CountableInterFilter l] (f : α → β) :\n    CountableInterFilter (comap f l) := by\n  refine ⟨fun S hSc hS => ?_⟩\n  choose! t htl ht using hS\n  have : (⋂ s ∈ S, t s) ∈ l := (countable_bInter_mem hSc).2 htl\n  refine ⟨_, this, ?_⟩\n  simpa [preimage_iInter] using iInter₂_mono ht\n\n"}
{"name":"instCountableInterFilterMap","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nβ : Type u_3\nl : Filter α\ninst✝ : CountableInterFilter l\nf : α → β\n⊢ CountableInterFilter (Filter.map f l)","decl":"instance (l : Filter α) [CountableInterFilter l] (f : α → β) : CountableInterFilter (map f l) := by\n  refine ⟨fun S hSc hS => ?_⟩\n  simp only [mem_map, sInter_eq_biInter, preimage_iInter₂] at hS ⊢\n  exact (countable_bInter_mem hSc).2 hS\n\n"}
{"name":"countableInterFilter_inf","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl₁ l₂ : Filter α\ninst✝¹ : CountableInterFilter l₁\ninst✝ : CountableInterFilter l₂\n⊢ CountableInterFilter (Min.min l₁ l₂)","decl":"/-- Infimum of two `CountableInterFilter`s is a `CountableInterFilter`. This is useful, e.g.,\nto automatically get an instance for `residual α ⊓ 𝓟 s`. -/\ninstance countableInterFilter_inf (l₁ l₂ : Filter α) [CountableInterFilter l₁]\n    [CountableInterFilter l₂] : CountableInterFilter (l₁ ⊓ l₂) := by\n  refine ⟨fun S hSc hS => ?_⟩\n  choose s hs t ht hst using hS\n  replace hs : (⋂ i ∈ S, s i ‹_›) ∈ l₁ := (countable_bInter_mem hSc).2 hs\n  replace ht : (⋂ i ∈ S, t i ‹_›) ∈ l₂ := (countable_bInter_mem hSc).2 ht\n  refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => ?_)\n  rw [hst i hi]\n  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)\n\n"}
{"name":"countableInterFilter_sup","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\nl₁ l₂ : Filter α\ninst✝¹ : CountableInterFilter l₁\ninst✝ : CountableInterFilter l₂\n⊢ CountableInterFilter (Max.max l₁ l₂)","decl":"/-- Supremum of two `CountableInterFilter`s is a `CountableInterFilter`. -/\ninstance countableInterFilter_sup (l₁ l₂ : Filter α) [CountableInterFilter l₁]\n    [CountableInterFilter l₂] : CountableInterFilter (l₁ ⊔ l₂) := by\n  refine ⟨fun S hSc hS => ⟨?_, ?_⟩⟩ <;> refine (countable_sInter_mem hSc).2 fun s hs => ?_\n  exacts [(hS s hs).1, (hS s hs).2]\n\n"}
{"name":"CountableInterFilter.curry","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_4\nβ : Type u_5\nl : Filter α\nm : Filter β\ninst✝¹ : CountableInterFilter l\ninst✝ : CountableInterFilter m\n⊢ CountableInterFilter (l.curry m)","decl":"instance CountableInterFilter.curry {α β : Type*} {l : Filter α} {m : Filter β}\n    [CountableInterFilter l] [CountableInterFilter m] : CountableInterFilter (l.curry m) := ⟨by\n  intro S Sct hS\n  simp_rw [mem_curry_iff, mem_sInter, eventually_countable_ball (p := fun _ _ _ => (_ ,_) ∈ _) Sct,\n    eventually_countable_ball (p := fun _ _ _ => ∀ᶠ (_ : β) in m, _)  Sct, ← mem_curry_iff]\n  exact hS⟩\n\n"}
{"name":"Filter.instCountableInterFilterCountableGenerate","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\ng : Set (Set α)\n⊢ CountableInterFilter (Filter.countableGenerate g)","decl":"instance : CountableInterFilter (countableGenerate g) := by\n  delta countableGenerate; infer_instance\n\n"}
{"name":"Filter.mem_countableGenerate_iff","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\ng : Set (Set α)\ns : Set α\n⊢ Iff (Membership.mem (Filter.countableGenerate g) s) (Exists fun S => And (HasSubset.Subset S g) (And S.Countable (HasSubset.Subset S.sInter s)))","decl":"/-- A set is in the `countableInterFilter` generated by `g` if and only if\nit contains a countable intersection of elements of `g`. -/\ntheorem mem_countableGenerate_iff {s : Set α} :\n    s ∈ countableGenerate g ↔ ∃ S : Set (Set α), S ⊆ g ∧ S.Countable ∧ ⋂₀ S ⊆ s := by\n  constructor <;> intro h\n  · induction h with\n    | @basic s hs => exact ⟨{s}, by simp [hs, subset_refl]⟩\n    | univ => exact ⟨∅, by simp⟩\n    | superset _ _ ih => refine Exists.imp (fun S => ?_) ih; tauto\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine ⟨⋃ (s) (H : s ∈ S), T s H, by simpa, Sct.biUnion Tct, ?_⟩\n      apply subset_sInter\n      intro s H\n      exact subset_trans (sInter_subset_sInter (subset_iUnion₂ s H)) (hT s H)\n  rcases h with ⟨S, Sg, Sct, hS⟩\n  refine mem_of_superset ((countable_sInter_mem Sct).mpr ?_) hS\n  intro s H\n  exact CountableGenerateSets.basic (Sg H)\n\n"}
{"name":"Filter.le_countableGenerate_iff_of_countableInterFilter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\ng : Set (Set α)\nf : Filter α\ninst✝ : CountableInterFilter f\n⊢ Iff (LE.le f (Filter.countableGenerate g)) (HasSubset.Subset g f.sets)","decl":"theorem le_countableGenerate_iff_of_countableInterFilter {f : Filter α} [CountableInterFilter f] :\n    f ≤ countableGenerate g ↔ g ⊆ f.sets := by\n  constructor <;> intro h\n  · exact subset_trans (fun s => CountableGenerateSets.basic) h\n  intro s hs\n  induction hs with\n  | basic hs => exact h hs\n  | univ => exact univ_mem\n  | superset _ st ih => exact mem_of_superset ih st\n  | sInter Sct _ ih => exact (countable_sInter_mem Sct).mpr ih\n\n"}
{"name":"Filter.countableGenerate_isGreatest","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"α : Type u_2\ng : Set (Set α)\n⊢ IsGreatest (setOf fun f => And (CountableInterFilter f) (HasSubset.Subset g f.sets)) (Filter.countableGenerate g)","decl":"/-- `countableGenerate g` is the greatest `countableInterFilter` containing `g`. -/\ntheorem countableGenerate_isGreatest :\n    IsGreatest { f : Filter α | CountableInterFilter f ∧ g ⊆ f.sets } (countableGenerate g) := by\n  refine ⟨⟨inferInstance, fun s => CountableGenerateSets.basic⟩, ?_⟩\n  rintro f ⟨fct, hf⟩\n  rwa [@le_countableGenerate_iff_of_countableInterFilter _ _ _ fct]\n\n"}
