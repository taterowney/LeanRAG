{"name":"CountableInterFilter.countable_sInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\nself : CountableInterFilter l\nS : Set (Set Î±)\naâœÂ¹ : S.Countable\naâœ : âˆ€ (s : Set Î±), Membership.mem S s â†’ Membership.mem l s\nâŠ¢ Membership.mem l S.sInter","decl":"/-- A filter `l` has the countable intersection property if for any countable collection\nof sets `s âˆˆ l` their intersection belongs to `l` as well. -/\nclass CountableInterFilter (l : Filter Î±) : Prop where\n  /-- For a countable collection of sets `s âˆˆ l`, their intersection belongs to `l` as well. -/\n  countable_sInter_mem : âˆ€ S : Set (Set Î±), S.Countable â†’ (âˆ€ s âˆˆ S, s âˆˆ l) â†’ â‹‚â‚€ S âˆˆ l\n\n"}
{"name":"countable_sInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nS : Set (Set Î±)\nhSc : S.Countable\nâŠ¢ Iff (Membership.mem l S.sInter) (âˆ€ (s : Set Î±), Membership.mem S s â†’ Membership.mem l s)","decl":"theorem countable_sInter_mem {S : Set (Set Î±)} (hSc : S.Countable) : â‹‚â‚€ S âˆˆ l â†” âˆ€ s âˆˆ S, s âˆˆ l :=\n  âŸ¨fun hS _s hs => mem_of_superset hS (sInter_subset_of_mem hs),\n    CountableInterFilter.countable_sInter_mem _ hScâŸ©\n\n"}
{"name":"countable_iInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set Î±\nâŠ¢ Iff (Membership.mem l (Set.iInter fun i => s i)) (âˆ€ (i : Î¹), Membership.mem l (s i))","decl":"theorem countable_iInter_mem [Countable Î¹] {s : Î¹ â†’ Set Î±} : (â‹‚ i, s i) âˆˆ l â†” âˆ€ i, s i âˆˆ l :=\n  sInter_range s â–¸ (countable_sInter_mem (countable_range _)).trans forall_mem_range\n\n"}
{"name":"countable_bInter_mem","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\ns : (i : Î¹) â†’ Membership.mem S i â†’ Set Î±\nâŠ¢ Iff (Membership.mem l (Set.iInter fun i => Set.iInter fun hi => s i hi)) (âˆ€ (i : Î¹) (hi : Membership.mem S i), Membership.mem l (s i hi))","decl":"theorem countable_bInter_mem {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable) {s : âˆ€ i âˆˆ S, Set Î±} :\n    (â‹‚ i, â‹‚ hi : i âˆˆ S, s i â€¹_â€º) âˆˆ l â†” âˆ€ i, âˆ€ hi : i âˆˆ S, s i â€¹_â€º âˆˆ l := by\n  rw [biInter_eq_iInter]\n  haveI := hS.toEncodable\n  exact countable_iInter_mem.trans Subtype.forall\n\n"}
{"name":"eventually_countable_forall","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\np : Î± â†’ Î¹ â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹), p x i) l) (âˆ€ (i : Î¹), Filter.Eventually (fun x => p x i) l)","decl":"theorem eventually_countable_forall [Countable Î¹] {p : Î± â†’ Î¹ â†’ Prop} :\n    (âˆ€á¶  x in l, âˆ€ i, p x i) â†” âˆ€ i, âˆ€á¶  x in l, p x i := by\n  simpa only [Filter.Eventually, setOf_forall] using\n    @countable_iInter_mem _ _ l _ _ fun i => { x | p x i }\n\n"}
{"name":"eventually_countable_ball","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\np : Î± â†’ (i : Î¹) â†’ Membership.mem S i â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun x => âˆ€ (i : Î¹) (hi : Membership.mem S i), p x i hi) l) (âˆ€ (i : Î¹) (hi : Membership.mem S i), Filter.Eventually (fun x => p x i hi) l)","decl":"theorem eventually_countable_ball {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable)\n    {p : Î± â†’ âˆ€ i âˆˆ S, Prop} :\n    (âˆ€á¶  x in l, âˆ€ i hi, p x i hi) â†” âˆ€ i hi, âˆ€á¶  x in l, p x i hi := by\n  simpa only [Filter.Eventually, setOf_forall] using\n    @countable_bInter_mem _ l _ _ _ hS fun i hi => { x | p x i hi }\n\n"}
{"name":"EventuallyLE.countable_iUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyLE (s i) (t i)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyLE.countable_iUnion [Countable Î¹] {s t : Î¹ â†’ Set Î±} (h : âˆ€ i, s i â‰¤á¶ [l] t i) :\n    â‹ƒ i, s i â‰¤á¶ [l] â‹ƒ i, t i :=\n  (eventually_countable_forall.2 h).mono fun _ hst hs => mem_iUnion.2 <| (mem_iUnion.1 hs).imp hst\n\n"}
{"name":"EventuallyEq.countable_iUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyEq (s i) (t i)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => s i) (Set.iUnion fun i => t i)","decl":"theorem EventuallyEq.countable_iUnion [Countable Î¹] {s t : Î¹ â†’ Set Î±} (h : âˆ€ i, s i =á¶ [l] t i) :\n    â‹ƒ i, s i =á¶ [l] â‹ƒ i, t i :=\n  (EventuallyLE.countable_iUnion fun i => (h i).le).antisymm\n    (EventuallyLE.countable_iUnion fun i => (h i).symm.le)\n\n"}
{"name":"EventuallyLE.countable_bUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\ns t : (i : Î¹) â†’ Membership.mem S i â†’ Set Î±\nh : âˆ€ (i : Î¹) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\nâŠ¢ l.EventuallyLE (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyLE.countable_bUnion {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable)\n    {s t : âˆ€ i âˆˆ S, Set Î±} (h : âˆ€ i hi, s i hi â‰¤á¶ [l] t i hi) :\n    â‹ƒ i âˆˆ S, s i â€¹_â€º â‰¤á¶ [l] â‹ƒ i âˆˆ S, t i â€¹_â€º := by\n  simp only [biUnion_eq_iUnion]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iUnion fun i => h i i.2\n\n"}
{"name":"EventuallyEq.countable_bUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\ns t : (i : Î¹) â†’ Membership.mem S i â†’ Set Î±\nh : âˆ€ (i : Î¹) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\nâŠ¢ l.EventuallyEq (Set.iUnion fun i => Set.iUnion fun h => s i h) (Set.iUnion fun i => Set.iUnion fun h => t i h)","decl":"theorem EventuallyEq.countable_bUnion {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable)\n    {s t : âˆ€ i âˆˆ S, Set Î±} (h : âˆ€ i hi, s i hi =á¶ [l] t i hi) :\n    â‹ƒ i âˆˆ S, s i â€¹_â€º =á¶ [l] â‹ƒ i âˆˆ S, t i â€¹_â€º :=\n  (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.countable_bUnion hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"EventuallyLE.countable_iInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyLE (s i) (t i)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyLE.countable_iInter [Countable Î¹] {s t : Î¹ â†’ Set Î±} (h : âˆ€ i, s i â‰¤á¶ [l] t i) :\n    â‹‚ i, s i â‰¤á¶ [l] â‹‚ i, t i :=\n  (eventually_countable_forall.2 h).mono fun _ hst hs =>\n    mem_iInter.2 fun i => hst _ (mem_iInter.1 hs i)\n\n"}
{"name":"EventuallyEq.countable_iInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î¹ : Sort u_1\nÎ± : Type u_2\nl : Filter Î±\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : Countable Î¹\ns t : Î¹ â†’ Set Î±\nh : âˆ€ (i : Î¹), l.EventuallyEq (s i) (t i)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => s i) (Set.iInter fun i => t i)","decl":"theorem EventuallyEq.countable_iInter [Countable Î¹] {s t : Î¹ â†’ Set Î±} (h : âˆ€ i, s i =á¶ [l] t i) :\n    â‹‚ i, s i =á¶ [l] â‹‚ i, t i :=\n  (EventuallyLE.countable_iInter fun i => (h i).le).antisymm\n    (EventuallyLE.countable_iInter fun i => (h i).symm.le)\n\n"}
{"name":"EventuallyLE.countable_bInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\ns t : (i : Î¹) â†’ Membership.mem S i â†’ Set Î±\nh : âˆ€ (i : Î¹) (hi : Membership.mem S i), l.EventuallyLE (s i hi) (t i hi)\nâŠ¢ l.EventuallyLE (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyLE.countable_bInter {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable)\n    {s t : âˆ€ i âˆˆ S, Set Î±} (h : âˆ€ i hi, s i hi â‰¤á¶ [l] t i hi) :\n    â‹‚ i âˆˆ S, s i â€¹_â€º â‰¤á¶ [l] â‹‚ i âˆˆ S, t i â€¹_â€º := by\n  simp only [biInter_eq_iInter]\n  haveI := hS.toEncodable\n  exact EventuallyLE.countable_iInter fun i => h i i.2\n\n"}
{"name":"EventuallyEq.countable_bInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Filter Î±\ninstâœ : CountableInterFilter l\nÎ¹ : Type u_4\nS : Set Î¹\nhS : S.Countable\ns t : (i : Î¹) â†’ Membership.mem S i â†’ Set Î±\nh : âˆ€ (i : Î¹) (hi : Membership.mem S i), l.EventuallyEq (s i hi) (t i hi)\nâŠ¢ l.EventuallyEq (Set.iInter fun i => Set.iInter fun h => s i h) (Set.iInter fun i => Set.iInter fun h => t i h)","decl":"theorem EventuallyEq.countable_bInter {Î¹ : Type*} {S : Set Î¹} (hS : S.Countable)\n    {s t : âˆ€ i âˆˆ S, Set Î±} (h : âˆ€ i hi, s i hi =á¶ [l] t i hi) :\n    â‹‚ i âˆˆ S, s i â€¹_â€º =á¶ [l] â‹‚ i âˆˆ S, t i â€¹_â€º :=\n  (EventuallyLE.countable_bInter hS fun i hi => (h i hi).le).antisymm\n    (EventuallyLE.countable_bInter hS fun i hi => (h i hi).symm.le)\n\n"}
{"name":"Filter.countableInter_ofCountableInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Set (Set Î±)\nhl : âˆ€ (S : Set (Set Î±)), S.Countable â†’ HasSubset.Subset S l â†’ Membership.mem l S.sInter\nh_mono : âˆ€ (s t : Set Î±), Membership.mem l s â†’ HasSubset.Subset s t â†’ Membership.mem l t\nâŠ¢ CountableInterFilter (Filter.ofCountableInter l hl h_mono)","decl":"instance Filter.countableInter_ofCountableInter (l : Set (Set Î±))\n    (hl : âˆ€ S : Set (Set Î±), S.Countable â†’ S âŠ† l â†’ â‹‚â‚€ S âˆˆ l)\n    (h_mono : âˆ€ s t, s âˆˆ l â†’ s âŠ† t â†’ t âˆˆ l) :\n    CountableInterFilter (Filter.ofCountableInter l hl h_mono) :=\n  âŸ¨hlâŸ©\n\n"}
{"name":"Filter.mem_ofCountableInter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Set (Set Î±)\nhl : âˆ€ (S : Set (Set Î±)), S.Countable â†’ HasSubset.Subset S l â†’ Membership.mem l S.sInter\nh_mono : âˆ€ (s t : Set Î±), Membership.mem l s â†’ HasSubset.Subset s t â†’ Membership.mem l t\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.ofCountableInter l hl h_mono) s) (Membership.mem l s)","decl":"@[simp]\ntheorem Filter.mem_ofCountableInter {l : Set (Set Î±)}\n    (hl : âˆ€ S : Set (Set Î±), S.Countable â†’ S âŠ† l â†’ â‹‚â‚€ S âˆˆ l) (h_mono : âˆ€ s t, s âˆˆ l â†’ s âŠ† t â†’ t âˆˆ l)\n    {s : Set Î±} : s âˆˆ Filter.ofCountableInter l hl h_mono â†” s âˆˆ l :=\n  Iff.rfl\n\n"}
{"name":"Filter.countableInter_ofCountableUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Set (Set Î±)\nhâ‚ : âˆ€ (S : Set (Set Î±)), S.Countable â†’ (âˆ€ (s : Set Î±), Membership.mem S s â†’ Membership.mem l s) â†’ Membership.mem l S.sUnion\nhâ‚‚ : âˆ€ (t : Set Î±), Membership.mem l t â†’ âˆ€ (s : Set Î±), HasSubset.Subset s t â†’ Membership.mem l s\nâŠ¢ CountableInterFilter (Filter.ofCountableUnion l hâ‚ hâ‚‚)","decl":"instance Filter.countableInter_ofCountableUnion (l : Set (Set Î±)) (hâ‚ hâ‚‚) :\n    CountableInterFilter (Filter.ofCountableUnion l hâ‚ hâ‚‚) :=\n  countableInter_ofCountableInter ..\n\n"}
{"name":"Filter.mem_ofCountableUnion","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nl : Set (Set Î±)\nhunion : âˆ€ (S : Set (Set Î±)), S.Countable â†’ (âˆ€ (s : Set Î±), Membership.mem S s â†’ Membership.mem l s) â†’ Membership.mem l S.sUnion\nhmono : âˆ€ (t : Set Î±), Membership.mem l t â†’ âˆ€ (s : Set Î±), HasSubset.Subset s t â†’ Membership.mem l s\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.ofCountableUnion l hunion hmono) s) (l (HasCompl.compl s))","decl":"@[simp]\ntheorem Filter.mem_ofCountableUnion {l : Set (Set Î±)} {hunion hmono s} :\n    s âˆˆ ofCountableUnion l hunion hmono â†” l sá¶œ :=\n  Iff.rfl\n\n"}
{"name":"countableInterFilter_principal","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\ns : Set Î±\nâŠ¢ CountableInterFilter (Filter.principal s)","decl":"instance countableInterFilter_principal (s : Set Î±) : CountableInterFilter (ğ“Ÿ s) :=\n  âŸ¨fun _ _ hS => subset_sInter hSâŸ©\n\n"}
{"name":"countableInterFilter_bot","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nâŠ¢ CountableInterFilter Bot.bot","decl":"instance countableInterFilter_bot : CountableInterFilter (âŠ¥ : Filter Î±) := by\n  rw [â† principal_empty]\n  apply countableInterFilter_principal\n\n"}
{"name":"countableInterFilter_top","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nâŠ¢ CountableInterFilter Top.top","decl":"instance countableInterFilter_top : CountableInterFilter (âŠ¤ : Filter Î±) := by\n  rw [â† principal_univ]\n  apply countableInterFilter_principal\n\n"}
{"name":"instCountableInterFilterComap","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nl : Filter Î²\ninstâœ : CountableInterFilter l\nf : Î± â†’ Î²\nâŠ¢ CountableInterFilter (Filter.comap f l)","decl":"instance (l : Filter Î²) [CountableInterFilter l] (f : Î± â†’ Î²) :\n    CountableInterFilter (comap f l) := by\n  refine âŸ¨fun S hSc hS => ?_âŸ©\n  choose! t htl ht using hS\n  have : (â‹‚ s âˆˆ S, t s) âˆˆ l := (countable_bInter_mem hSc).2 htl\n  refine âŸ¨_, this, ?_âŸ©\n  simpa [preimage_iInter] using iInterâ‚‚_mono ht\n\n"}
{"name":"instCountableInterFilterMap","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\nl : Filter Î±\ninstâœ : CountableInterFilter l\nf : Î± â†’ Î²\nâŠ¢ CountableInterFilter (Filter.map f l)","decl":"instance (l : Filter Î±) [CountableInterFilter l] (f : Î± â†’ Î²) : CountableInterFilter (map f l) := by\n  refine âŸ¨fun S hSc hS => ?_âŸ©\n  simp only [mem_map, sInter_eq_biInter, preimage_iInterâ‚‚] at hS âŠ¢\n  exact (countable_bInter_mem hSc).2 hS\n\n"}
{"name":"countableInterFilter_inf","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nlâ‚ lâ‚‚ : Filter Î±\ninstâœÂ¹ : CountableInterFilter lâ‚\ninstâœ : CountableInterFilter lâ‚‚\nâŠ¢ CountableInterFilter (Min.min lâ‚ lâ‚‚)","decl":"/-- Infimum of two `CountableInterFilter`s is a `CountableInterFilter`. This is useful, e.g.,\nto automatically get an instance for `residual Î± âŠ“ ğ“Ÿ s`. -/\ninstance countableInterFilter_inf (lâ‚ lâ‚‚ : Filter Î±) [CountableInterFilter lâ‚]\n    [CountableInterFilter lâ‚‚] : CountableInterFilter (lâ‚ âŠ“ lâ‚‚) := by\n  refine âŸ¨fun S hSc hS => ?_âŸ©\n  choose s hs t ht hst using hS\n  replace hs : (â‹‚ i âˆˆ S, s i â€¹_â€º) âˆˆ lâ‚ := (countable_bInter_mem hSc).2 hs\n  replace ht : (â‹‚ i âˆˆ S, t i â€¹_â€º) âˆˆ lâ‚‚ := (countable_bInter_mem hSc).2 ht\n  refine mem_of_superset (inter_mem_inf hs ht) (subset_sInter fun i hi => ?_)\n  rw [hst i hi]\n  apply inter_subset_inter <;> exact iInter_subset_of_subset i (iInter_subset _ _)\n\n"}
{"name":"countableInterFilter_sup","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\nlâ‚ lâ‚‚ : Filter Î±\ninstâœÂ¹ : CountableInterFilter lâ‚\ninstâœ : CountableInterFilter lâ‚‚\nâŠ¢ CountableInterFilter (Max.max lâ‚ lâ‚‚)","decl":"/-- Supremum of two `CountableInterFilter`s is a `CountableInterFilter`. -/\ninstance countableInterFilter_sup (lâ‚ lâ‚‚ : Filter Î±) [CountableInterFilter lâ‚]\n    [CountableInterFilter lâ‚‚] : CountableInterFilter (lâ‚ âŠ” lâ‚‚) := by\n  refine âŸ¨fun S hSc hS => âŸ¨?_, ?_âŸ©âŸ© <;> refine (countable_sInter_mem hSc).2 fun s hs => ?_\n  exacts [(hS s hs).1, (hS s hs).2]\n\n"}
{"name":"CountableInterFilter.curry","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_4\nÎ² : Type u_5\nl : Filter Î±\nm : Filter Î²\ninstâœÂ¹ : CountableInterFilter l\ninstâœ : CountableInterFilter m\nâŠ¢ CountableInterFilter (l.curry m)","decl":"instance CountableInterFilter.curry {Î± Î² : Type*} {l : Filter Î±} {m : Filter Î²}\n    [CountableInterFilter l] [CountableInterFilter m] : CountableInterFilter (l.curry m) := âŸ¨by\n  intro S Sct hS\n  simp_rw [mem_curry_iff, mem_sInter, eventually_countable_ball (p := fun _ _ _ => (_ ,_) âˆˆ _) Sct,\n    eventually_countable_ball (p := fun _ _ _ => âˆ€á¶  (_ : Î²) in m, _)  Sct, â† mem_curry_iff]\n  exact hSâŸ©\n\n"}
{"name":"Filter.instCountableInterFilterCountableGenerate","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\ng : Set (Set Î±)\nâŠ¢ CountableInterFilter (Filter.countableGenerate g)","decl":"instance : CountableInterFilter (countableGenerate g) := by\n  delta countableGenerate; infer_instance\n\n"}
{"name":"Filter.mem_countableGenerate_iff","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\ng : Set (Set Î±)\ns : Set Î±\nâŠ¢ Iff (Membership.mem (Filter.countableGenerate g) s) (Exists fun S => And (HasSubset.Subset S g) (And S.Countable (HasSubset.Subset S.sInter s)))","decl":"/-- A set is in the `countableInterFilter` generated by `g` if and only if\nit contains a countable intersection of elements of `g`. -/\ntheorem mem_countableGenerate_iff {s : Set Î±} :\n    s âˆˆ countableGenerate g â†” âˆƒ S : Set (Set Î±), S âŠ† g âˆ§ S.Countable âˆ§ â‹‚â‚€ S âŠ† s := by\n  constructor <;> intro h\n  Â· induction h with\n    | @basic s hs => exact âŸ¨{s}, by simp [hs, subset_refl]âŸ©\n    | univ => exact âŸ¨âˆ…, by simpâŸ©\n    | superset _ _ ih => refine Exists.imp (fun S => ?_) ih; tauto\n    | @sInter S Sct _ ih =>\n      choose T Tg Tct hT using ih\n      refine âŸ¨â‹ƒ (s) (H : s âˆˆ S), T s H, by simpa, Sct.biUnion Tct, ?_âŸ©\n      apply subset_sInter\n      intro s H\n      exact subset_trans (sInter_subset_sInter (subset_iUnionâ‚‚ s H)) (hT s H)\n  rcases h with âŸ¨S, Sg, Sct, hSâŸ©\n  refine mem_of_superset ((countable_sInter_mem Sct).mpr ?_) hS\n  intro s H\n  exact CountableGenerateSets.basic (Sg H)\n\n"}
{"name":"Filter.le_countableGenerate_iff_of_countableInterFilter","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\ng : Set (Set Î±)\nf : Filter Î±\ninstâœ : CountableInterFilter f\nâŠ¢ Iff (LE.le f (Filter.countableGenerate g)) (HasSubset.Subset g f.sets)","decl":"theorem le_countableGenerate_iff_of_countableInterFilter {f : Filter Î±} [CountableInterFilter f] :\n    f â‰¤ countableGenerate g â†” g âŠ† f.sets := by\n  constructor <;> intro h\n  Â· exact subset_trans (fun s => CountableGenerateSets.basic) h\n  intro s hs\n  induction hs with\n  | basic hs => exact h hs\n  | univ => exact univ_mem\n  | superset _ st ih => exact mem_of_superset ih st\n  | sInter Sct _ ih => exact (countable_sInter_mem Sct).mpr ih\n\n"}
{"name":"Filter.countableGenerate_isGreatest","module":"Mathlib.Order.Filter.CountableInter","initialProofState":"Î± : Type u_2\ng : Set (Set Î±)\nâŠ¢ IsGreatest (setOf fun f => And (CountableInterFilter f) (HasSubset.Subset g f.sets)) (Filter.countableGenerate g)","decl":"/-- `countableGenerate g` is the greatest `countableInterFilter` containing `g`. -/\ntheorem countableGenerate_isGreatest :\n    IsGreatest { f : Filter Î± | CountableInterFilter f âˆ§ g âŠ† f.sets } (countableGenerate g) := by\n  refine âŸ¨âŸ¨inferInstance, fun s => CountableGenerateSets.basicâŸ©, ?_âŸ©\n  rintro f âŸ¨fct, hfâŸ©\n  rwa [@le_countableGenerate_iff_of_countableInterFilter _ _ _ fct]\n\n"}
