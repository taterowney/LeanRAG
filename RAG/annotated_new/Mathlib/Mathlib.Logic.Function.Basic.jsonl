{"name":"Function.eval_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_4\nx : α\nf : (x : α) → β x\n⊢ Eq (Function.eval x f) (f x)","decl":"theorem eval_apply {β : α → Sort*} (x : α) (f : ∀ x, β x) : eval x f = f x :=\n  rfl\n\n"}
{"name":"Function.const_def","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ny : β\n⊢ Eq (fun x => y) (Function.const α y)","decl":"theorem const_def {y : β} : (fun _ : α ↦ y) = const α y :=\n  rfl\n\n"}
{"name":"Function.const_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\n⊢ Function.Injective (Function.const α)","decl":"theorem const_injective [Nonempty α] : Injective (const α : β → α → β) := fun _ _ h ↦\n  let ⟨x⟩ := ‹Nonempty α›\n  congr_fun h x\n\n"}
{"name":"Function.const_inj","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\ny₁ y₂ : β\n⊢ Iff (Eq (Function.const α y₁) (Function.const α y₂)) (Eq y₁ y₂)","decl":"@[simp]\ntheorem const_inj [Nonempty α] {y₁ y₂ : β} : const α y₁ = const α y₂ ↔ y₁ = y₂ :=\n  ⟨fun h ↦ const_injective h, fun h ↦ h ▸ rfl⟩\n\n-- Porting note: `Function.onFun` is now reducible\n-- @[simp]\n"}
{"name":"Function.onFun_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : β → β → γ\ng : α → β\na b : α\n⊢ Eq (Function.onFun f g a b) (f (g a) (g b))","decl":"theorem onFun_apply (f : β → β → γ) (g : α → β) (a b : α) : onFun f g a b = f (g a) (g b) :=\n  rfl\n\n"}
{"name":"Function.hfunext","module":"Mathlib.Logic.Function.Basic","initialProofState":"α α' : Sort u\nβ : α → Sort v\nβ' : α' → Sort v\nf : (a : α) → β a\nf' : (a : α') → β' a\nhα : Eq α α'\nh : ∀ (a : α) (a' : α'), HEq a a' → HEq (f a) (f' a')\n⊢ HEq f f'","decl":"lemma hfunext {α α' : Sort u} {β : α → Sort v} {β' : α' → Sort v} {f : ∀a, β a} {f' : ∀a, β' a}\n    (hα : α = α') (h : ∀a a', HEq a a' → HEq (f a) (f' a')) : HEq f f' := by\n  subst hα\n  have : ∀a, HEq (f a) (f' a) := fun a ↦ h a a (HEq.refl a)\n  have : β = β' := by funext a; exact type_eq_of_heq (this a)\n  subst this\n  apply heq_of_eq\n  funext a\n  exact eq_of_heq (this a)\n\n"}
{"name":"Function.ne_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_4\nf₁ f₂ : (a : α) → β a\n⊢ Iff (Ne f₁ f₂) (Exists fun a => Ne (f₁ a) (f₂ a))","decl":"theorem ne_iff {β : α → Sort*} {f₁ f₂ : ∀ a, β a} : f₁ ≠ f₂ ↔ ∃ a, f₁ a ≠ f₂ a :=\n  funext_iff.not.trans not_forall\n\n"}
{"name":"Function.funext_iff_of_subsingleton","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ninst✝ : Subsingleton α\ng : α → β\nx y : α\n⊢ Iff (Eq (f x) (g y)) (Eq f g)","decl":"lemma funext_iff_of_subsingleton [Subsingleton α] {g : α → β} (x y : α) :\n    f x = g y ↔ f = g := by\n  refine ⟨fun h ↦ funext fun z ↦ ?_, fun h ↦ ?_⟩\n  · rwa [Subsingleton.elim x z, Subsingleton.elim y z] at h\n  · rw [h, Subsingleton.elim x y]\n\n"}
{"name":"Function.swap_lt","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Eq (Function.swap fun x1 x2 => LT.lt x1 x2) fun x1 x2 => GT.gt x1 x2","decl":"theorem swap_lt {α} [Preorder α] : swap (· < · : α → α → _) = (· > ·) := rfl\n"}
{"name":"Function.swap_le","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Eq (Function.swap fun x1 x2 => LE.le x1 x2) fun x1 x2 => GE.ge x1 x2","decl":"theorem swap_le {α} [Preorder α] : swap (· ≤ · : α → α → _) = (· ≥ ·) := rfl\n"}
{"name":"Function.swap_gt","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Eq (Function.swap fun x1 x2 => GT.gt x1 x2) fun x1 x2 => LT.lt x1 x2","decl":"theorem swap_gt {α} [Preorder α] : swap (· > · : α → α → _) = (· < ·) := rfl\n"}
{"name":"Function.swap_ge","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\ninst✝ : Preorder α\n⊢ Eq (Function.swap fun x1 x2 => GE.ge x1 x2) fun x1 x2 => LE.le x1 x2","decl":"theorem swap_ge {α} [Preorder α] : swap (· ≥ · : α → α → _) = (· ≤ ·) := rfl\n\n"}
{"name":"Function.Bijective.injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Bijective f\n⊢ Function.Injective f","decl":"protected theorem Bijective.injective {f : α → β} (hf : Bijective f) : Injective f := hf.1\n"}
{"name":"Function.Bijective.surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Bijective f\n⊢ Function.Surjective f","decl":"protected theorem Bijective.surjective {f : α → β} (hf : Bijective f) : Surjective f := hf.2\n\n"}
{"name":"Function.Injective.eq_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nI : Function.Injective f\na b : α\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem Injective.eq_iff (I : Injective f) {a b : α} : f a = f b ↔ a = b :=\n  ⟨@I _ _, congr_arg f⟩\n\n"}
{"name":"Function.Injective.beq_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝³ : BEq α\ninst✝² : LawfulBEq α\ninst✝¹ : BEq β\ninst✝ : LawfulBEq β\nf : α → β\nI : Function.Injective f\na b : α\n⊢ Eq (BEq.beq (f a) (f b)) (BEq.beq a b)","decl":"theorem Injective.beq_eq {α β : Type*} [BEq α] [LawfulBEq α] [BEq β] [LawfulBEq β] {f : α → β}\n    (I : Injective f) {a b : α} : (f a == f b) = (a == b) := by\n  by_cases h : a == b <;> simp [h] <;> simpa [I.eq_iff] using h\n\n"}
{"name":"Function.Injective.eq_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nI : Function.Injective f\na b : α\nc : β\nh : Eq (f b) c\n⊢ Iff (Eq (f a) c) (Eq a b)","decl":"theorem Injective.eq_iff' (I : Injective f) {a b : α} {c : β} (h : f b = c) : f a = c ↔ a = b :=\n  h ▸ I.eq_iff\n\n"}
{"name":"Function.Injective.ne","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Injective f\na₁ a₂ : α\na✝ : Ne a₁ a₂\n⊢ Ne (f a₁) (f a₂)","decl":"theorem Injective.ne (hf : Injective f) {a₁ a₂ : α} : a₁ ≠ a₂ → f a₁ ≠ f a₂ :=\n  mt fun h ↦ hf h\n\n"}
{"name":"Function.Injective.ne_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Injective f\nx y : α\n⊢ Iff (Ne (f x) (f y)) (Ne x y)","decl":"theorem Injective.ne_iff (hf : Injective f) {x y : α} : f x ≠ f y ↔ x ≠ y :=\n  ⟨mt <| congr_arg f, hf.ne⟩\n\n"}
{"name":"Function.Injective.ne_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Injective f\nx y : α\nz : β\nh : Eq (f y) z\n⊢ Iff (Ne (f x) z) (Ne x y)","decl":"theorem Injective.ne_iff' (hf : Injective f) {x y : α} {z : β} (h : f y = z) : f x ≠ z ↔ x ≠ y :=\n  h ▸ hf.ne_iff\n\n"}
{"name":"Function.not_injective_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\n⊢ Iff (Not (Function.Injective f)) (Exists fun a => Exists fun b => And (Eq (f a) (f b)) (Ne a b))","decl":"theorem not_injective_iff : ¬ Injective f ↔ ∃ a b, f a = f b ∧ a ≠ b := by\n  simp only [Injective, not_forall, exists_prop]\n\n"}
{"name":"Function.Injective.of_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nI : Function.Injective (Function.comp f g)\n⊢ Function.Injective g","decl":"theorem Injective.of_comp {g : γ → α} (I : Injective (f ∘ g)) : Injective g :=\n  fun _ _ h ↦ I <| congr_arg f h\n\n"}
{"name":"Function.Injective.of_comp_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ng : γ → α\n⊢ Iff (Function.Injective (Function.comp f g)) (Function.Injective g)","decl":"@[simp]\ntheorem Injective.of_comp_iff (hf : Injective f) (g : γ → α) :\n    Injective (f ∘ g) ↔ Injective g :=\n  ⟨Injective.of_comp, hf.comp⟩\n\n"}
{"name":"Function.Injective.of_comp_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nI : Function.Injective (Function.comp f g)\nhg : Function.Surjective g\n⊢ Function.Injective f","decl":"theorem Injective.of_comp_right {g : γ → α} (I : Injective (f ∘ g)) (hg : Surjective g) :\n    Injective f := fun x y h ↦ by\n  obtain ⟨x, rfl⟩ := hg x\n  obtain ⟨y, rfl⟩ := hg y\n  exact congr_arg g (I h)\n\n"}
{"name":"Function.Surjective.bijective₂_of_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nhf : Function.Surjective f\nhg : Function.Surjective g\nI : Function.Injective (Function.comp f g)\n⊢ And (Function.Bijective f) (Function.Bijective g)","decl":"theorem Surjective.bijective₂_of_injective {g : γ → α} (hf : Surjective f) (hg : Surjective g)\n    (I : Injective (f ∘ g)) : Bijective f ∧ Bijective g :=\n  ⟨⟨I.of_comp_right hg, hf⟩, I.of_comp, hg⟩\n\n"}
{"name":"Function.Injective.of_comp_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nhg : Function.Bijective g\n⊢ Iff (Function.Injective (Function.comp f g)) (Function.Injective f)","decl":"@[simp]\ntheorem Injective.of_comp_iff' (f : α → β) {g : γ → α} (hg : Bijective g) :\n    Injective (f ∘ g) ↔ Injective f :=\n  ⟨fun I ↦ I.of_comp_right hg.2, fun h ↦ h.comp hg.injective⟩\n\n"}
{"name":"Function.Injective.piMap","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_4\nα : ι → Sort u_5\nβ : ι → Sort u_6\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Injective (f i)\n⊢ Function.Injective (Pi.map f)","decl":"theorem Injective.piMap {ι : Sort*} {α β : ι → Sort*} {f : ∀ i, α i → β i}\n    (hf : ∀ i, Injective (f i)) : Injective (Pi.map f) := fun _ _ h ↦\n  funext fun i ↦ hf i <| congrFun h _\n\n"}
{"name":"Function.injective_pi_map","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_4\nα : ι → Sort u_5\nβ : ι → Sort u_6\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Injective (f i)\n⊢ Function.Injective (Pi.map f)","decl":"@[deprecated (since := \"2024-10-06\")] alias injective_pi_map := Injective.piMap\n\n"}
{"name":"Function.Injective.comp_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ng : β → γ\nhg : Function.Injective g\n⊢ Function.Injective fun x => Function.comp g x","decl":"/-- Composition by an injective function on the left is itself injective. -/\ntheorem Injective.comp_left {g : β → γ} (hg : Injective g) : Injective (g ∘ · : (α → β) → α → γ) :=\n  .piMap fun _ ↦ hg\n\n"}
{"name":"Function.injective_of_subsingleton","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Subsingleton α\nf : α → β\n⊢ Function.Injective f","decl":"theorem injective_of_subsingleton [Subsingleton α] (f : α → β) : Injective f :=\n  fun _ _ _ ↦ Subsingleton.elim _ _\n\n"}
{"name":"Function.Injective.dite","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\np : α → Prop\ninst✝ : DecidablePred p\nf : (Subtype fun a => p a) → β\nf' : (Subtype fun a => Not (p a)) → β\nhf : Function.Injective f\nhf' : Function.Injective f'\nim_disj : ∀ {x x' : α} {hx : p x} {hx' : Not (p x')}, Ne (f ⟨x, hx⟩) (f' ⟨x', hx'⟩)\n⊢ Function.Injective fun x => dite (p x) (fun h => f ⟨x, h⟩) fun h => f' ⟨x, h⟩","decl":"lemma Injective.dite (p : α → Prop) [DecidablePred p]\n    {f : {a : α // p a} → β} {f' : {a : α // ¬ p a} → β}\n    (hf : Injective f) (hf' : Injective f')\n    (im_disj : ∀ {x x' : α} {hx : p x} {hx' : ¬ p x'}, f ⟨x, hx⟩ ≠ f' ⟨x', hx'⟩) :\n    Function.Injective (fun x ↦ if h : p x then f ⟨x, h⟩ else f' ⟨x, h⟩) := fun x₁ x₂ h => by\n dsimp only at h\n by_cases h₁ : p x₁ <;> by_cases h₂ : p x₂\n · rw [dif_pos h₁, dif_pos h₂] at h; injection (hf h)\n · rw [dif_pos h₁, dif_neg h₂] at h; exact (im_disj h).elim\n · rw [dif_neg h₁, dif_pos h₂] at h; exact (im_disj h.symm).elim\n · rw [dif_neg h₁, dif_neg h₂] at h; injection (hf' h)\n\n"}
{"name":"Function.Surjective.of_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nS : Function.Surjective (Function.comp f g)\n⊢ Function.Surjective f","decl":"theorem Surjective.of_comp {g : γ → α} (S : Surjective (f ∘ g)) : Surjective f := fun y ↦\n  let ⟨x, h⟩ := S y\n  ⟨g x, h⟩\n\n"}
{"name":"Function.Surjective.of_comp_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nhg : Function.Surjective g\n⊢ Iff (Function.Surjective (Function.comp f g)) (Function.Surjective f)","decl":"@[simp]\ntheorem Surjective.of_comp_iff (f : α → β) {g : γ → α} (hg : Surjective g) :\n    Surjective (f ∘ g) ↔ Surjective f :=\n  ⟨Surjective.of_comp, fun h ↦ h.comp hg⟩\n\n"}
{"name":"Function.Surjective.of_comp_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nS : Function.Surjective (Function.comp f g)\nhf : Function.Injective f\n⊢ Function.Surjective g","decl":"theorem Surjective.of_comp_left {g : γ → α} (S : Surjective (f ∘ g)) (hf : Injective f) :\n    Surjective g := fun a ↦ let ⟨c, hc⟩ := S (f a); ⟨c, hf hc⟩\n\n"}
{"name":"Function.Injective.bijective₂_of_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nhf : Function.Injective f\nhg : Function.Injective g\nS : Function.Surjective (Function.comp f g)\n⊢ And (Function.Bijective f) (Function.Bijective g)","decl":"theorem Injective.bijective₂_of_surjective {g : γ → α} (hf : Injective f) (hg : Injective g)\n    (S : Surjective (f ∘ g)) : Bijective f ∧ Bijective g :=\n  ⟨⟨hf, S.of_comp⟩, hg, S.of_comp_left hf⟩\n\n"}
{"name":"Function.Surjective.of_comp_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Bijective f\ng : γ → α\n⊢ Iff (Function.Surjective (Function.comp f g)) (Function.Surjective g)","decl":"@[simp]\ntheorem Surjective.of_comp_iff' (hf : Bijective f) (g : γ → α) :\n    Surjective (f ∘ g) ↔ Surjective g :=\n  ⟨fun S ↦ S.of_comp_left hf.1, hf.surjective.comp⟩\n\n"}
{"name":"Function.Surjective.forall","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → Prop\n⊢ Iff (∀ (y : β), p y) (∀ (x : α), p (f x))","decl":"protected theorem Surjective.forall (hf : Surjective f) {p : β → Prop} :\n    (∀ y, p y) ↔ ∀ x, p (f x) :=\n  ⟨fun h x ↦ h (f x), fun h y ↦\n    let ⟨x, hx⟩ := hf y\n    hx ▸ h x⟩\n\n"}
{"name":"Function.Surjective.forall₂","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → β → Prop\n⊢ Iff (∀ (y₁ y₂ : β), p y₁ y₂) (∀ (x₁ x₂ : α), p (f x₁) (f x₂))","decl":"protected theorem Surjective.forall₂ (hf : Surjective f) {p : β → β → Prop} :\n    (∀ y₁ y₂, p y₁ y₂) ↔ ∀ x₁ x₂, p (f x₁) (f x₂) :=\n  hf.forall.trans <| forall_congr' fun _ ↦ hf.forall\n\n"}
{"name":"Function.Surjective.forall₃","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → β → β → Prop\n⊢ Iff (∀ (y₁ y₂ y₃ : β), p y₁ y₂ y₃) (∀ (x₁ x₂ x₃ : α), p (f x₁) (f x₂) (f x₃))","decl":"protected theorem Surjective.forall₃ (hf : Surjective f) {p : β → β → β → Prop} :\n    (∀ y₁ y₂ y₃, p y₁ y₂ y₃) ↔ ∀ x₁ x₂ x₃, p (f x₁) (f x₂) (f x₃) :=\n  hf.forall.trans <| forall_congr' fun _ ↦ hf.forall₂\n\n"}
{"name":"Function.Surjective.exists","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → Prop\n⊢ Iff (Exists fun y => p y) (Exists fun x => p (f x))","decl":"protected theorem Surjective.exists (hf : Surjective f) {p : β → Prop} :\n    (∃ y, p y) ↔ ∃ x, p (f x) :=\n  ⟨fun ⟨y, hy⟩ ↦\n    let ⟨x, hx⟩ := hf y\n    ⟨x, hx.symm ▸ hy⟩,\n    fun ⟨x, hx⟩ ↦ ⟨f x, hx⟩⟩\n\n"}
{"name":"Function.Surjective.exists₂","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → β → Prop\n⊢ Iff (Exists fun y₁ => Exists fun y₂ => p y₁ y₂) (Exists fun x₁ => Exists fun x₂ => p (f x₁) (f x₂))","decl":"protected theorem Surjective.exists₂ (hf : Surjective f) {p : β → β → Prop} :\n    (∃ y₁ y₂, p y₁ y₂) ↔ ∃ x₁ x₂, p (f x₁) (f x₂) :=\n  hf.exists.trans <| exists_congr fun _ ↦ hf.exists\n\n"}
{"name":"Function.Surjective.exists₃","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Surjective f\np : β → β → β → Prop\n⊢ Iff (Exists fun y₁ => Exists fun y₂ => Exists fun y₃ => p y₁ y₂ y₃) (Exists fun x₁ => Exists fun x₂ => Exists fun x₃ => p (f x₁) (f x₂) (f x₃))","decl":"protected theorem Surjective.exists₃ (hf : Surjective f) {p : β → β → β → Prop} :\n    (∃ y₁ y₂ y₃, p y₁ y₂ y₃) ↔ ∃ x₁ x₂ x₃, p (f x₁) (f x₂) (f x₃) :=\n  hf.exists.trans <| exists_congr fun _ ↦ hf.exists₂\n\n"}
{"name":"Function.Surjective.injective_comp_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Injective fun g => Function.comp g f","decl":"theorem Surjective.injective_comp_right (hf : Surjective f) : Injective fun g : β → γ ↦ g ∘ f :=\n  fun _ _ h ↦ funext <| hf.forall.2 <| congr_fun h\n\n"}
{"name":"Function.Surjective.right_cancellable","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Surjective f\ng₁ g₂ : β → γ\n⊢ Iff (Eq (Function.comp g₁ f) (Function.comp g₂ f)) (Eq g₁ g₂)","decl":"protected theorem Surjective.right_cancellable (hf : Surjective f) {g₁ g₂ : β → γ} :\n    g₁ ∘ f = g₂ ∘ f ↔ g₁ = g₂ :=\n  hf.injective_comp_right.eq_iff\n\n"}
{"name":"Function.surjective_of_right_cancellable_Prop","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nh : ∀ (g₁ g₂ : β → Prop), Eq (Function.comp g₁ f) (Function.comp g₂ f) → Eq g₁ g₂\n⊢ Function.Surjective f","decl":"theorem surjective_of_right_cancellable_Prop (h : ∀ g₁ g₂ : β → Prop, g₁ ∘ f = g₂ ∘ f → g₁ = g₂) :\n    Surjective f := by\n  specialize h (fun y ↦ ∃ x, f x = y) (fun _ ↦ True) (funext fun x ↦ eq_true ⟨_, rfl⟩)\n  intro y; rw [congr_fun h y]; trivial\n\n"}
{"name":"Function.bijective_iff_existsUnique","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\n⊢ Iff (Function.Bijective f) (∀ (b : β), ExistsUnique fun a => Eq (f a) b)","decl":"theorem bijective_iff_existsUnique (f : α → β) : Bijective f ↔ ∀ b : β, ∃! a : α, f a = b :=\n  ⟨fun hf b ↦\n      let ⟨a, ha⟩ := hf.surjective b\n      ⟨a, ha, fun _ ha' ↦ hf.injective (ha'.trans ha.symm)⟩,\n    fun he ↦ ⟨fun {_a a'} h ↦ (he (f a')).unique h rfl, fun b ↦ (he b).exists⟩⟩\n\n"}
{"name":"Function.Bijective.existsUnique","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Bijective f\nb : β\n⊢ ExistsUnique fun a => Eq (f a) b","decl":"/-- Shorthand for using projection notation with `Function.bijective_iff_existsUnique`. -/\nprotected theorem Bijective.existsUnique {f : α → β} (hf : Bijective f) (b : β) :\n    ∃! a : α, f a = b :=\n  (bijective_iff_existsUnique f).mp hf b\n\n"}
{"name":"Function.Bijective.existsUnique_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\nhf : Function.Bijective f\np : β → Prop\n⊢ Iff (ExistsUnique fun y => p y) (ExistsUnique fun x => p (f x))","decl":"theorem Bijective.existsUnique_iff {f : α → β} (hf : Bijective f) {p : β → Prop} :\n    (∃! y, p y) ↔ ∃! x, p (f x) :=\n  ⟨fun ⟨y, hpy, hy⟩ ↦\n    let ⟨x, hx⟩ := hf.surjective y\n    ⟨x, by simpa [hx], fun z (hz : p (f z)) ↦ hf.injective <| hx.symm ▸ hy _ hz⟩,\n    fun ⟨x, hpx, hx⟩ ↦\n    ⟨f x, hpx, fun y hy ↦\n      let ⟨z, hz⟩ := hf.surjective y\n      hz ▸ congr_arg f (hx _ (by simpa [hz]))⟩⟩\n\n"}
{"name":"Function.Bijective.of_comp_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : γ → α\nhg : Function.Bijective g\n⊢ Iff (Function.Bijective (Function.comp f g)) (Function.Bijective f)","decl":"theorem Bijective.of_comp_iff (f : α → β) {g : γ → α} (hg : Bijective g) :\n    Bijective (f ∘ g) ↔ Bijective f :=\n  and_congr (Injective.of_comp_iff' _ hg) (Surjective.of_comp_iff _ hg.surjective)\n\n"}
{"name":"Function.Bijective.of_comp_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Bijective f\ng : γ → α\n⊢ Iff (Function.Bijective (Function.comp f g)) (Function.Bijective g)","decl":"theorem Bijective.of_comp_iff' {f : α → β} (hf : Bijective f) (g : γ → α) :\n    Function.Bijective (f ∘ g) ↔ Function.Bijective g :=\n  and_congr (Injective.of_comp_iff hf.injective _) (Surjective.of_comp_iff' hf _)\n\n"}
{"name":"Function.cantor_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nf : α → Set α\n⊢ Not (Function.Surjective f)","decl":"/-- **Cantor's diagonal argument** implies that there are no surjective functions from `α`\nto `Set α`. -/\ntheorem cantor_surjective {α} (f : α → Set α) : ¬Surjective f\n  | h => let ⟨D, e⟩ := h {a | ¬ f a a}\n        @iff_not_self (D ∈ f D) <| iff_of_eq <| congr_arg (D ∈ ·) e\n\n"}
{"name":"Function.cantor_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nf : Set α → α\n⊢ Not (Function.Injective f)","decl":"/-- **Cantor's diagonal argument** implies that there are no injective functions from `Set α`\nto `α`. -/\ntheorem cantor_injective {α : Type*} (f : Set α → α) : ¬Injective f\n  | i => cantor_surjective (fun a ↦ {b | ∀ U, a = f U → U b}) <|\n         RightInverse.surjective (fun U ↦ Set.ext fun _ ↦ ⟨fun h ↦ h U rfl, fun h _ e ↦ i e ▸ h⟩)\n\n"}
{"name":"Function.not_surjective_Type","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u\nf : α → Type (max u v)\n⊢ Not (Function.Surjective f)","decl":"/-- There is no surjection from `α : Type u` into `Type (max u v)`. This theorem\n  demonstrates why `Type : Type` would be inconsistent in Lean. -/\ntheorem not_surjective_Type {α : Type u} (f : α → Type max u v) : ¬Surjective f := by\n  intro hf\n  let T : Type max u v := Sigma f\n  cases hf (Set T) with | intro U hU =>\n  let g : Set T → T := fun s ↦ ⟨U, cast hU.symm s⟩\n  have hg : Injective g := by\n    intro s t h\n    suffices cast hU (g s).2 = cast hU (g t).2 by\n      simp only [g, cast_cast, cast_eq] at this\n      assumption\n    · congr\n  exact cantor_injective g hg\n\n"}
{"name":"Function.isPartialInv_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Sort u_5\nf : α → β\ng : β → Option α\nH : Function.IsPartialInv f g\nx : α\n⊢ Eq (g (f x)) (Option.some x)","decl":"theorem isPartialInv_left {α β} {f : α → β} {g} (H : IsPartialInv f g) (x) : g (f x) = some x :=\n  (H _ _).2 rfl\n\n"}
{"name":"Function.injective_of_isPartialInv","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Sort u_5\nf : α → β\ng : β → Option α\nH : Function.IsPartialInv f g\n⊢ Function.Injective f","decl":"theorem injective_of_isPartialInv {α β} {f : α → β} {g} (H : IsPartialInv f g) :\n    Injective f := fun _ _ h ↦\n  Option.some.inj <| ((H _ _).2 h).symm.trans ((H _ _).2 rfl)\n\n"}
{"name":"Function.injective_of_isPartialInv_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Sort u_5\nf : α → β\ng : β → Option α\nH : Function.IsPartialInv f g\nx y : β\nb : α\nh₁ : Membership.mem (g x) b\nh₂ : Membership.mem (g y) b\n⊢ Eq x y","decl":"theorem injective_of_isPartialInv_right {α β} {f : α → β} {g} (H : IsPartialInv f g) (x y b)\n    (h₁ : b ∈ g x) (h₂ : b ∈ g y) : x = y :=\n  ((H _ _).1 h₁).symm.trans ((H _ _).1 h₂)\n\n"}
{"name":"Function.LeftInverse.comp_eq_id","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\n⊢ Eq (Function.comp f g) id","decl":"theorem LeftInverse.comp_eq_id {f : α → β} {g : β → α} (h : LeftInverse f g) : f ∘ g = id :=\n  funext h\n\n"}
{"name":"Function.leftInverse_iff_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\n⊢ Iff (Function.LeftInverse f g) (Eq (Function.comp f g) id)","decl":"theorem leftInverse_iff_comp {f : α → β} {g : β → α} : LeftInverse f g ↔ f ∘ g = id :=\n  ⟨LeftInverse.comp_eq_id, congr_fun⟩\n\n"}
{"name":"Function.RightInverse.comp_eq_id","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.RightInverse f g\n⊢ Eq (Function.comp g f) id","decl":"theorem RightInverse.comp_eq_id {f : α → β} {g : β → α} (h : RightInverse f g) : g ∘ f = id :=\n  funext h\n\n"}
{"name":"Function.rightInverse_iff_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\n⊢ Iff (Function.RightInverse f g) (Eq (Function.comp g f) id)","decl":"theorem rightInverse_iff_comp {f : α → β} {g : β → α} : RightInverse f g ↔ g ∘ f = id :=\n  ⟨RightInverse.comp_eq_id, congr_fun⟩\n\n"}
{"name":"Function.LeftInverse.comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : β → α\nh : β → γ\ni : γ → β\nhf : Function.LeftInverse f g\nhh : Function.LeftInverse h i\n⊢ Function.LeftInverse (Function.comp h f) (Function.comp g i)","decl":"theorem LeftInverse.comp {f : α → β} {g : β → α} {h : β → γ} {i : γ → β} (hf : LeftInverse f g)\n    (hh : LeftInverse h i) : LeftInverse (h ∘ f) (g ∘ i) :=\n  fun a ↦ show h (f (g (i a))) = a by rw [hf (i a), hh a]\n\n"}
{"name":"Function.RightInverse.comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : β → α\nh : β → γ\ni : γ → β\nhf : Function.RightInverse f g\nhh : Function.RightInverse h i\n⊢ Function.RightInverse (Function.comp h f) (Function.comp g i)","decl":"theorem RightInverse.comp {f : α → β} {g : β → α} {h : β → γ} {i : γ → β} (hf : RightInverse f g)\n    (hh : RightInverse h i) : RightInverse (h ∘ f) (g ∘ i) :=\n  LeftInverse.comp hh hf\n\n"}
{"name":"Function.LeftInverse.rightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\n⊢ Function.RightInverse f g","decl":"theorem LeftInverse.rightInverse {f : α → β} {g : β → α} (h : LeftInverse g f) : RightInverse f g :=\n  h\n\n"}
{"name":"Function.RightInverse.leftInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.RightInverse g f\n⊢ Function.LeftInverse f g","decl":"theorem RightInverse.leftInverse {f : α → β} {g : β → α} (h : RightInverse g f) : LeftInverse f g :=\n  h\n\n"}
{"name":"Function.LeftInverse.surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\n⊢ Function.Surjective f","decl":"theorem LeftInverse.surjective {f : α → β} {g : β → α} (h : LeftInverse f g) : Surjective f :=\n  h.rightInverse.surjective\n\n"}
{"name":"Function.RightInverse.injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.RightInverse f g\n⊢ Function.Injective f","decl":"theorem RightInverse.injective {f : α → β} {g : β → α} (h : RightInverse f g) : Injective f :=\n  h.leftInverse.injective\n\n"}
{"name":"Function.LeftInverse.rightInverse_of_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\nhf : Function.Injective f\n⊢ Function.RightInverse f g","decl":"theorem LeftInverse.rightInverse_of_injective {f : α → β} {g : β → α} (h : LeftInverse f g)\n    (hf : Injective f) : RightInverse f g :=\n  fun x ↦ hf <| h (f x)\n\n"}
{"name":"Function.LeftInverse.rightInverse_of_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\nh : Function.LeftInverse f g\nhg : Function.Surjective g\n⊢ Function.RightInverse f g","decl":"theorem LeftInverse.rightInverse_of_surjective {f : α → β} {g : β → α} (h : LeftInverse f g)\n    (hg : Surjective g) : RightInverse f g :=\n  fun x ↦ let ⟨y, hy⟩ := hg x; hy ▸ congr_arg g (h y)\n\n"}
{"name":"Function.RightInverse.leftInverse_of_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\na✝¹ : Function.RightInverse f g\na✝ : Function.Surjective f\n⊢ Function.LeftInverse f g","decl":"theorem RightInverse.leftInverse_of_surjective {f : α → β} {g : β → α} :\n    RightInverse f g → Surjective f → LeftInverse f g :=\n  LeftInverse.rightInverse_of_surjective\n\n"}
{"name":"Function.RightInverse.leftInverse_of_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng : β → α\na✝¹ : Function.RightInverse f g\na✝ : Function.Injective g\n⊢ Function.LeftInverse f g","decl":"theorem RightInverse.leftInverse_of_injective {f : α → β} {g : β → α} :\n    RightInverse f g → Injective g → LeftInverse f g :=\n  LeftInverse.rightInverse_of_injective\n\n"}
{"name":"Function.LeftInverse.eq_rightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ng₁ g₂ : β → α\nh₁ : Function.LeftInverse g₁ f\nh₂ : Function.RightInverse g₂ f\n⊢ Eq g₁ g₂","decl":"theorem LeftInverse.eq_rightInverse {f : α → β} {g₁ g₂ : β → α} (h₁ : LeftInverse g₁ f)\n    (h₂ : RightInverse g₂ f) : g₁ = g₂ :=\n  calc\n    g₁ = g₁ ∘ f ∘ g₂ := by rw [h₂.comp_eq_id, comp_id]\n     _ = g₂ := by rw [← comp_assoc, h₁.comp_eq_id, id_comp]\n\n"}
{"name":"Function.partialInv_of_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Sort u_5\nf : α → β\nI : Function.Injective f\n⊢ Function.IsPartialInv f (Function.partialInv f)","decl":"theorem partialInv_of_injective {α β} {f : α → β} (I : Injective f) : IsPartialInv f (partialInv f)\n  | a, b =>\n  ⟨fun h =>\n    have hpi : partialInv f b = if h : ∃ a, f a = b then some (Classical.choose h) else none :=\n      rfl\n    if h' : ∃ a, f a = b\n    then by rw [hpi, dif_pos h'] at h\n            injection h with h\n            subst h\n            apply Classical.choose_spec h'\n    else by rw [hpi, dif_neg h'] at h; contradiction,\n  fun e => e ▸ have h : ∃ a', f a' = f a := ⟨_, rfl⟩\n              (dif_pos h).trans (congr_arg _ (I <| Classical.choose_spec h))⟩\n\n"}
{"name":"Function.partialInv_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Sort u_5\nf : α → β\nI : Function.Injective f\nx : α\n⊢ Eq (Function.partialInv f (f x)) (Option.some x)","decl":"theorem partialInv_left {α β} {f : α → β} (I : Injective f) : ∀ x, partialInv f (f x) = some x :=\n  isPartialInv_left (partialInv_of_injective I)\n\n"}
{"name":"Function.invFun_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nb : β\nh : Exists fun a => Eq (f a) b\n⊢ Eq (f (Function.invFun f b)) b","decl":"theorem invFun_eq (h : ∃ a, f a = b) : f (invFun f b) = b := by\n  simp only [invFun, dif_pos h, h.choose_spec]\n\n"}
{"name":"Function.apply_invFun_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\na : α\n⊢ Eq (f (Function.invFun f (f a))) (f a)","decl":"theorem apply_invFun_apply {α β : Type*} {f : α → β} {a : α} :\n    f (@invFun _ _ ⟨a⟩ f (f a)) = f a :=\n  @invFun_eq _ _ ⟨a⟩ _ _ ⟨_, rfl⟩\n\n"}
{"name":"Function.invFun_neg","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nb : β\nh : Not (Exists fun a => Eq (f a) b)\n⊢ Eq (Function.invFun f b) (Classical.choice inst✝)","decl":"theorem invFun_neg (h : ¬∃ a, f a = b) : invFun f b = Classical.choice ‹_› :=\n  dif_neg h\n\n"}
{"name":"Function.invFun_eq_of_injective_of_rightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\ng : β → α\nhf : Function.Injective f\nhg : Function.RightInverse g f\n⊢ Eq (Function.invFun f) g","decl":"theorem invFun_eq_of_injective_of_rightInverse {g : β → α} (hf : Injective f)\n    (hg : RightInverse g f) : invFun f = g :=\n  funext fun b ↦\n    hf\n      (by\n        rw [hg b]\n        exact invFun_eq ⟨g b, hg b⟩)\n\n"}
{"name":"Function.rightInverse_invFun","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Surjective f\n⊢ Function.RightInverse (Function.invFun f) f","decl":"theorem rightInverse_invFun (hf : Surjective f) : RightInverse (invFun f) f :=\n  fun b ↦ invFun_eq <| hf b\n\n"}
{"name":"Function.leftInverse_invFun","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Injective f\n⊢ Function.LeftInverse (Function.invFun f) f","decl":"theorem leftInverse_invFun (hf : Injective f) : LeftInverse (invFun f) f :=\n  fun b ↦ hf <| invFun_eq ⟨b, rfl⟩\n\n"}
{"name":"Function.invFun_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Injective f\n⊢ Function.Surjective (Function.invFun f)","decl":"theorem invFun_surjective (hf : Injective f) : Surjective (invFun f) :=\n  (leftInverse_invFun hf).surjective\n\n"}
{"name":"Function.invFun_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Function.comp (Function.invFun f) f) id","decl":"theorem invFun_comp (hf : Injective f) : invFun f ∘ f = id :=\n  funext <| leftInverse_invFun hf\n\n"}
{"name":"Function.Injective.hasLeftInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\nhf : Function.Injective f\n⊢ Function.HasLeftInverse f","decl":"theorem Injective.hasLeftInverse (hf : Injective f) : HasLeftInverse f :=\n  ⟨invFun f, leftInverse_invFun hf⟩\n\n"}
{"name":"Function.injective_iff_hasLeftInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : Nonempty α\nf : α → β\n⊢ Iff (Function.Injective f) (Function.HasLeftInverse f)","decl":"theorem injective_iff_hasLeftInverse : Injective f ↔ HasLeftInverse f :=\n  ⟨Injective.hasLeftInverse, HasLeftInverse.injective⟩\n\n"}
{"name":"Function.surjInv_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nh : Function.Surjective f\nb : β\n⊢ Eq (f (Function.surjInv h b)) b","decl":"theorem surjInv_eq (h : Surjective f) (b) : f (surjInv h b) = b :=\n  Classical.choose_spec (h b)\n\n"}
{"name":"Function.rightInverse_surjInv","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Surjective f\n⊢ Function.RightInverse (Function.surjInv hf) f","decl":"theorem rightInverse_surjInv (hf : Surjective f) : RightInverse (surjInv hf) f :=\n  surjInv_eq hf\n\n"}
{"name":"Function.leftInverse_surjInv","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Bijective f\n⊢ Function.LeftInverse (Function.surjInv ⋯) f","decl":"theorem leftInverse_surjInv (hf : Bijective f) : LeftInverse (surjInv hf.2) f :=\n  rightInverse_of_injective_of_leftInverse hf.1 (rightInverse_surjInv hf.2)\n\n"}
{"name":"Function.Surjective.hasRightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Surjective f\n⊢ Function.HasRightInverse f","decl":"theorem Surjective.hasRightInverse (hf : Surjective f) : HasRightInverse f :=\n  ⟨_, rightInverse_surjInv hf⟩\n\n"}
{"name":"Function.surjective_iff_hasRightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\n⊢ Iff (Function.Surjective f) (Function.HasRightInverse f)","decl":"theorem surjective_iff_hasRightInverse : Surjective f ↔ HasRightInverse f :=\n  ⟨Surjective.hasRightInverse, HasRightInverse.surjective⟩\n\n"}
{"name":"Function.bijective_iff_has_inverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\n⊢ Iff (Function.Bijective f) (Exists fun g => And (Function.LeftInverse g f) (Function.RightInverse g f))","decl":"theorem bijective_iff_has_inverse : Bijective f ↔ ∃ g, LeftInverse g f ∧ RightInverse g f :=\n  ⟨fun hf ↦ ⟨_, leftInverse_surjInv hf, rightInverse_surjInv hf.2⟩, fun ⟨_, gl, gr⟩ ↦\n    ⟨gl.injective, gr.surjective⟩⟩\n\n"}
{"name":"Function.injective_surjInv","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nh : Function.Surjective f\n⊢ Function.Injective (Function.surjInv h)","decl":"theorem injective_surjInv (h : Surjective f) : Injective (surjInv h) :=\n  (rightInverse_surjInv h).injective\n\n"}
{"name":"Function.surjective_to_subsingleton","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nna : Nonempty α\ninst✝ : Subsingleton β\nf : α → β\n⊢ Function.Surjective f","decl":"theorem surjective_to_subsingleton [na : Nonempty α] [Subsingleton β] (f : α → β) :\n    Surjective f :=\n  fun _ ↦ let ⟨a⟩ := na; ⟨a, Subsingleton.elim _ _⟩\n\n"}
{"name":"Function.Surjective.piMap","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Surjective (f i)\n⊢ Function.Surjective (Pi.map f)","decl":"theorem Surjective.piMap {ι : Sort*} {α β : ι → Sort*} {f : ∀ i, α i → β i}\n    (hf : ∀ i, Surjective (f i)) : Surjective (Pi.map f) := fun g ↦\n  ⟨fun i ↦ surjInv (hf i) (g i), funext fun _ ↦ rightInverse_surjInv _ _⟩\n\n"}
{"name":"Function.surjective_pi_map","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Surjective (f i)\n⊢ Function.Surjective (Pi.map f)","decl":"@[deprecated (since := \"2024-10-06\")] alias surjective_pi_map := Surjective.piMap\n\n"}
{"name":"Function.Surjective.comp_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ng : β → γ\nhg : Function.Surjective g\n⊢ Function.Surjective fun x => Function.comp g x","decl":"/-- Composition by a surjective function on the left is itself surjective. -/\ntheorem Surjective.comp_left {g : β → γ} (hg : Surjective g) :\n    Surjective (g ∘ · : (α → β) → α → γ) :=\n  .piMap fun _ ↦ hg\n\n"}
{"name":"Function.Bijective.piMap","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Bijective (f i)\n⊢ Function.Bijective (Pi.map f)","decl":"theorem Bijective.piMap {ι : Sort*} {α β : ι → Sort*} {f : ∀ i, α i → β i}\n    (hf : ∀ i, Bijective (f i)) : Bijective (Pi.map f) :=\n  ⟨.piMap fun i ↦ (hf i).1, .piMap fun i ↦ (hf i).2⟩\n\n"}
{"name":"Function.bijective_pi_map","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\nhf : ∀ (i : ι), Function.Bijective (f i)\n⊢ Function.Bijective (Pi.map f)","decl":"@[deprecated (since := \"2024-10-06\")] alias bijective_pi_map := Bijective.piMap\n\n"}
{"name":"Function.Bijective.comp_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ng : β → γ\nhg : Function.Bijective g\n⊢ Function.Bijective fun x => Function.comp g x","decl":"/-- Composition by a bijective function on the left is itself bijective. -/\ntheorem Bijective.comp_left {g : β → γ} (hg : Bijective g) :\n    Bijective (g ∘ · : (α → β) → α → γ) :=\n  ⟨hg.injective.comp_left, hg.surjective.comp_left⟩\n\n"}
{"name":"Function.update_self","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na : α\nv : β a\nf : (a : α) → β a\n⊢ Eq (Function.update f a v a) v","decl":"@[simp]\ntheorem update_self (a : α) (v : β a) (f : ∀ a, β a) : update f a v a = v :=\n  dif_pos rfl\n\n"}
{"name":"Function.update_same","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na : α\nv : β a\nf : (a : α) → β a\n⊢ Eq (Function.update f a v a) v","decl":"@[deprecated (since := \"2024-12-28\")] alias update_same := update_self\n\n"}
{"name":"Function.update_of_ne","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na a' : α\nh : Ne a a'\nv : β a'\nf : (a : α) → β a\n⊢ Eq (Function.update f a' v a) (f a)","decl":"@[simp]\ntheorem update_of_ne {a a' : α} (h : a ≠ a') (v : β a') (f : ∀ a, β a) : update f a' v a = f a :=\n  dif_neg h\n\n"}
{"name":"Function.update_noteq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na a' : α\nh : Ne a a'\nv : β a'\nf : (a : α) → β a\n⊢ Eq (Function.update f a' v a) (f a)","decl":"@[deprecated (since := \"2024-12-28\")] alias update_noteq := update_of_ne\n\n"}
{"name":"Function.update_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\ninst✝ : DecidableEq α\nβ : Sort u_1\nf : α → β\na' : α\nb : β\na : α\n⊢ Eq (Function.update f a' b a) (ite (Eq a a') b (f a))","decl":"/-- On non-dependent functions, `Function.update` can be expressed as an `ite` -/\ntheorem update_apply {β : Sort*} (f : α → β) (a' : α) (b : β) (a : α) :\n    update f a' b a = if a = a' then b else f a := by\n  rcases Decidable.eq_or_ne a a' with rfl | hne <;> simp [*]\n\n"}
{"name":"Function.update_eq_const_of_subsingleton","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nα' : Sort w\ninst✝¹ : DecidableEq α\ninst✝ : Subsingleton α\na : α\nv : α'\nf : α → α'\n⊢ Eq (Function.update f a v) (Function.const α v)","decl":"@[nontriviality]\ntheorem update_eq_const_of_subsingleton [Subsingleton α] (a : α) (v : α') (f : α → α') :\n    update f a v = const α v :=\n  funext fun a' ↦ Subsingleton.elim a a' ▸ update_self ..\n\n"}
{"name":"Function.surjective_eval","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\nh : ∀ (a : α), Nonempty (β a)\na : α\n⊢ Function.Surjective (Function.eval a)","decl":"theorem surjective_eval {α : Sort u} {β : α → Sort v} [h : ∀ a, Nonempty (β a)] (a : α) :\n    Surjective (eval a : (∀ a, β a) → β a) := fun b ↦\n  ⟨@update _ _ (Classical.decEq α) (fun a ↦ (h a).some) a b,\n   @update_self _ _ (Classical.decEq α) _ _ _⟩\n\n"}
{"name":"Function.update_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na' : α\n⊢ Function.Injective (Function.update f a')","decl":"theorem update_injective (f : ∀ a, β a) (a' : α) : Injective (update f a') := fun v v' h ↦ by\n  have := congr_fun h a'\n  rwa [update_self, update_self] at this\n\n"}
{"name":"Function.forall_update_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\np : (a : α) → β a → Prop\n⊢ Iff (∀ (x : α), p x (Function.update f a b x)) (And (p a b) (∀ (x : α), Ne x a → p x (f x)))","decl":"lemma forall_update_iff (f : ∀a, β a) {a : α} {b : β a} (p : ∀a, β a → Prop) :\n    (∀ x, p x (update f a b x)) ↔ p a b ∧ ∀ x, x ≠ a → p x (f x) := by\n  rw [← and_forall_ne a, update_self]\n  simp +contextual\n\n"}
{"name":"Function.exists_update_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\np : (a : α) → β a → Prop\n⊢ Iff (Exists fun x => p x (Function.update f a b x)) (Or (p a b) (Exists fun x => And (Ne x a) (p x (f x))))","decl":"theorem exists_update_iff (f : ∀ a, β a) {a : α} {b : β a} (p : ∀ a, β a → Prop) :\n    (∃ x, p x (update f a b x)) ↔ p a b ∨ ∃ x ≠ a, p x (f x) := by\n  rw [← not_forall_not, forall_update_iff f fun a b ↦ ¬p a b]\n  simp [-not_and, not_and_or]\n\n"}
{"name":"Function.update_eq_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na : α\nb : β a\nf g : (a : α) → β a\n⊢ Iff (Eq (Function.update f a b) g) (And (Eq b (g a)) (∀ (x : α), Ne x a → Eq (f x) (g x)))","decl":"theorem update_eq_iff {a : α} {b : β a} {f g : ∀ a, β a} :\n    update f a b = g ↔ b = g a ∧ ∀ x ≠ a, f x = g x :=\n  funext_iff.trans <| forall_update_iff _ fun x y ↦ y = g x\n\n"}
{"name":"Function.eq_update_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na : α\nb : β a\nf g : (a : α) → β a\n⊢ Iff (Eq g (Function.update f a b)) (And (Eq (g a) b) (∀ (x : α), Ne x a → Eq (g x) (f x)))","decl":"theorem eq_update_iff {a : α} {b : β a} {f g : ∀ a, β a} :\n    g = update f a b ↔ g a = b ∧ ∀ x ≠ a, g x = f x :=\n  funext_iff.trans <| forall_update_iff _ fun x y ↦ g x = y\n\n"}
{"name":"Function.update_eq_self_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\n⊢ Iff (Eq (Function.update f a b) f) (Eq b (f a))","decl":"@[simp] lemma update_eq_self_iff : update f a b = f ↔ b = f a := by simp [update_eq_iff]\n\n"}
{"name":"Function.eq_update_self_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\n⊢ Iff (Eq f (Function.update f a b)) (Eq (f a) b)","decl":"@[simp] lemma eq_update_self_iff : f = update f a b ↔ f a = b := by simp [eq_update_iff]\n\n"}
{"name":"Function.ne_update_self_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\n⊢ Iff (Ne f (Function.update f a b)) (Ne (f a) b)","decl":"lemma ne_update_self_iff : f ≠ update f a b ↔ f a ≠ b := eq_update_self_iff.not\n\n"}
{"name":"Function.update_ne_self_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nf : (a : α) → β a\na : α\nb : β a\n⊢ Iff (Ne (Function.update f a b) f) (Ne b (f a))","decl":"lemma update_ne_self_iff : update f a b ≠ f ↔ b ≠ f a := update_eq_self_iff.not\n\n"}
{"name":"Function.update_eq_self","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\na : α\nf : (a : α) → β a\n⊢ Eq (Function.update f a (f a)) f","decl":"@[simp]\ntheorem update_eq_self (a : α) (f : ∀ a, β a) : update f a (f a) = f :=\n  update_eq_iff.2 ⟨rfl, fun _ _ ↦ rfl⟩\n\n"}
{"name":"Function.update_comp_eq_of_forall_ne'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nα' : Sort u_1\ng : (a : α) → β a\nf : α' → α\ni : α\na : β i\nh : ∀ (x : α'), Ne (f x) i\n⊢ Eq (fun j => Function.update g i a (f j)) fun j => g (f j)","decl":"theorem update_comp_eq_of_forall_ne' {α'} (g : ∀ a, β a) {f : α' → α} {i : α} (a : β i)\n    (h : ∀ x, f x ≠ i) : (fun j ↦ (update g i a) (f j)) = fun j ↦ g (f j) :=\n  funext fun _ ↦ update_of_ne (h _) _ _\n\n"}
{"name":"Function.update_comp_eq_of_forall_ne","module":"Mathlib.Logic.Function.Basic","initialProofState":"α' : Sort w\ninst✝ : DecidableEq α'\nα : Sort u_1\nβ : Sort u_2\ng : α' → β\nf : α → α'\ni : α'\na : β\nh : ∀ (x : α), Ne (f x) i\n⊢ Eq (Function.comp (Function.update g i a) f) (Function.comp g f)","decl":"/-- Non-dependent version of `Function.update_comp_eq_of_forall_ne'` -/\ntheorem update_comp_eq_of_forall_ne {α β : Sort*} (g : α' → β) {f : α → α'} {i : α'} (a : β)\n    (h : ∀ x, f x ≠ i) : update g i a ∘ f = g ∘ f :=\n  update_comp_eq_of_forall_ne' g a h\n\n"}
{"name":"Function.update_comp_eq_of_injective'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\nα' : Sort w\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq α'\ng : (a : α) → β a\nf : α' → α\nhf : Function.Injective f\ni : α'\na : β (f i)\n⊢ Eq (fun j => Function.update g (f i) a (f j)) (Function.update (fun i => g (f i)) i a)","decl":"theorem update_comp_eq_of_injective' (g : ∀ a, β a) {f : α' → α} (hf : Function.Injective f)\n    (i : α') (a : β (f i)) : (fun j ↦ update g (f i) a (f j)) = update (fun i ↦ g (f i)) i a :=\n  eq_update_iff.2 ⟨update_self .., fun _ hj ↦ update_of_ne (hf.ne hj) _ _⟩\n\n"}
{"name":"Function.update_comp_eq_of_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nα' : Sort w\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq α'\nβ : Sort u_1\ng : α' → β\nf : α → α'\nhf : Function.Injective f\ni : α\na : β\n⊢ Eq (Function.comp (Function.update g (f i) a) f) (Function.update (Function.comp g f) i a)","decl":"/-- Non-dependent version of `Function.update_comp_eq_of_injective'` -/\ntheorem update_comp_eq_of_injective {β : Sort*} (g : α' → β) {f : α → α'}\n    (hf : Function.Injective f) (i : α) (a : β) :\n    Function.update g (f i) a ∘ f = Function.update (g ∘ f) i a :=\n  update_comp_eq_of_injective' g hf i a\n\n"}
{"name":"Function.apply_update","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nβ : ι → Sort u_3\nf : (i : ι) → α i → β i\ng : (i : ι) → α i\ni : ι\nv : α i\nj : ι\n⊢ Eq (f j (Function.update g i v j)) (Function.update (fun k => f k (g k)) i (f i v) j)","decl":"theorem apply_update {ι : Sort*} [DecidableEq ι] {α β : ι → Sort*} (f : ∀ i, α i → β i)\n    (g : ∀ i, α i) (i : ι) (v : α i) (j : ι) :\n    f j (update g i v j) = update (fun k ↦ f k (g k)) i (f i v) j := by\n  by_cases h : j = i\n  · subst j\n    simp\n  · simp [h]\n\n"}
{"name":"Function.apply_update₂","module":"Mathlib.Logic.Function.Basic","initialProofState":"ι : Sort u_1\ninst✝ : DecidableEq ι\nα : ι → Sort u_2\nβ : ι → Sort u_3\nγ : ι → Sort u_4\nf : (i : ι) → α i → β i → γ i\ng : (i : ι) → α i\nh : (i : ι) → β i\ni : ι\nv : α i\nw : β i\nj : ι\n⊢ Eq (f j (Function.update g i v j) (Function.update h i w j)) (Function.update (fun k => f k (g k) (h k)) i (f i v w) j)","decl":"theorem apply_update₂ {ι : Sort*} [DecidableEq ι] {α β γ : ι → Sort*} (f : ∀ i, α i → β i → γ i)\n    (g : ∀ i, α i) (h : ∀ i, β i) (i : ι) (v : α i) (w : β i) (j : ι) :\n    f j (update g i v j) (update h i w j) = update (fun k ↦ f k (g k) (h k)) i (f i v w) j := by\n  by_cases h : j = i\n  · subst j\n    simp\n  · simp [h]\n\n"}
{"name":"Function.pred_update","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : α → Sort v\ninst✝ : DecidableEq α\nP : ⦃a : α⦄ → β a → Prop\nf : (a : α) → β a\na' : α\nv : β a'\na : α\n⊢ Iff (P (Function.update f a' v a)) (Or (And (Eq a a') (P v)) (And (Ne a a') (P (f a))))","decl":"theorem pred_update (P : ∀ ⦃a⦄, β a → Prop) (f : ∀ a, β a) (a' : α) (v : β a') (a : α) :\n    P (update f a' v a) ↔ a = a' ∧ P v ∨ a ≠ a' ∧ P (f a) := by\n  rw [apply_update P, update_apply, ite_prop_iff_or]\n\n"}
{"name":"Function.comp_update","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\ninst✝ : DecidableEq α\nα' : Sort u_1\nβ : Sort u_2\nf : α' → β\ng : α → α'\ni : α\nv : α'\n⊢ Eq (Function.comp f (Function.update g i v)) (Function.update (Function.comp f g) i (f v))","decl":"theorem comp_update {α' : Sort*} {β : Sort*} (f : α' → β) (g : α → α') (i : α) (v : α') :\n    f ∘ update g i v = update (f ∘ g) i (f v) :=\n  funext <| apply_update _ _ _ _\n\n"}
{"name":"Function.update_comm","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_2\ninst✝ : DecidableEq α\nβ : α → Sort u_1\na b : α\nh : Ne a b\nv : β a\nw : β b\nf : (a : α) → β a\n⊢ Eq (Function.update (Function.update f a v) b w) (Function.update (Function.update f b w) a v)","decl":"theorem update_comm {α} [DecidableEq α] {β : α → Sort*} {a b : α} (h : a ≠ b) (v : β a) (w : β b)\n    (f : ∀ a, β a) : update (update f a v) b w = update (update f b w) a v := by\n  funext c\n  simp only [update]\n  by_cases h₁ : c = b <;> by_cases h₂ : c = a\n  · rw [dif_pos h₁, dif_pos h₂]\n    cases h (h₂.symm.trans h₁)\n  · rw [dif_pos h₁, dif_pos h₁, dif_neg h₂]\n  · rw [dif_neg h₁, dif_neg h₁]\n  · rw [dif_neg h₁, dif_neg h₁]\n\n"}
{"name":"Function.update_idem","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_2\ninst✝ : DecidableEq α\nβ : α → Sort u_1\na : α\nv w : β a\nf : (a : α) → β a\n⊢ Eq (Function.update (Function.update f a v) a w) (Function.update f a w)","decl":"@[simp]\ntheorem update_idem {α} [DecidableEq α] {β : α → Sort*} {a : α} (v w : β a) (f : ∀ a, β a) :\n    update (update f a v) a w = update f a w := by\n  funext b\n  by_cases h : b = a <;> simp [update, h]\n\n"}
{"name":"Function.extend_def","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : α → γ\ne' : β → γ\nb : β\ninst✝ : Decidable (Exists fun a => Eq (f a) b)\n⊢ Eq (Function.extend f g e' b) (dite (Exists fun a => Eq (f a) b) (fun h => g (Classical.choose h)) fun h => e' b)","decl":"theorem extend_def (f : α → β) (g : α → γ) (e' : β → γ) (b : β) [Decidable (∃ a, f a = b)] :\n    extend f g e' b = if h : ∃ a, f a = b then g (Classical.choose h) else e' b := by\n  unfold extend\n  congr\n\n"}
{"name":"Function.Injective.factorsThrough","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ng : α → γ\n⊢ Function.FactorsThrough g f","decl":"lemma Injective.factorsThrough (hf : Injective f) (g : α → γ) : g.FactorsThrough f :=\n  fun _ _ h => congr_arg g (hf h)\n\n"}
{"name":"Function.FactorsThrough.extend_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : α → γ\nhf : Function.FactorsThrough g f\ne' : β → γ\na : α\n⊢ Eq (Function.extend f g e' (f a)) (g a)","decl":"lemma FactorsThrough.extend_apply {g : α → γ} (hf : g.FactorsThrough f) (e' : β → γ) (a : α) :\n    extend f g e' (f a) = g a := by\n  simp only [extend_def, dif_pos, exists_apply_eq_apply]\n  exact hf (Classical.choose_spec (exists_apply_eq_apply f a))\n\n"}
{"name":"Function.Injective.extend_apply","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ng : α → γ\ne' : β → γ\na : α\n⊢ Eq (Function.extend f g e' (f a)) (g a)","decl":"@[simp]\ntheorem Injective.extend_apply (hf : Injective f) (g : α → γ) (e' : β → γ) (a : α) :\n    extend f g e' (f a) = g a :=\n  (hf.factorsThrough g).extend_apply e' a\n\n"}
{"name":"Function.extend_apply'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : α → γ\ne' : β → γ\nb : β\nhb : Not (Exists fun a => Eq (f a) b)\n⊢ Eq (Function.extend f g e' b) (e' b)","decl":"@[simp]\ntheorem extend_apply' (g : α → γ) (e' : β → γ) (b : β) (hb : ¬∃ a, f a = b) :\n    extend f g e' b = e' b := by\n  simp [Function.extend_def, hb]\n\n"}
{"name":"Function.factorsThrough_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : α → γ\ninst✝ : Nonempty γ\n⊢ Iff (Function.FactorsThrough g f) (Exists fun e => Eq g (Function.comp e f))","decl":"lemma factorsThrough_iff (g : α → γ) [Nonempty γ] : g.FactorsThrough f ↔ ∃ (e : β → γ), g = e ∘ f :=\n⟨fun hf => ⟨extend f g (const β (Classical.arbitrary γ)),\n      funext (fun x => by simp only [comp_apply, hf.extend_apply])⟩,\n  fun h _ _ hf => by rw [Classical.choose_spec h, comp_apply, comp_apply, hf]⟩\n\n"}
{"name":"Function.apply_extend","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nδ : Sort u_4\ng : α → γ\nF : γ → δ\nf : α → β\ne' : β → γ\nb : β\n⊢ Eq (F (Function.extend f g e' b)) (Function.extend f (Function.comp F g) (Function.comp F e') b)","decl":"lemma apply_extend {δ} {g : α → γ} (F : γ → δ) (f : α → β) (e' : β → γ) (b : β) :\n    F (extend f g e' b) = extend f (F ∘ g) (F ∘ e') b :=\n  apply_dite F _ _ _\n\n"}
{"name":"Function.extend_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ne' : β → γ\n⊢ Function.Injective fun g => Function.extend f g e'","decl":"theorem extend_injective (hf : Injective f) (e' : β → γ) : Injective fun g ↦ extend f g e' := by\n  intro g₁ g₂ hg\n  refine funext fun x ↦ ?_\n  have H := congr_fun hg (f x)\n  simp only [hf.extend_apply] at H\n  exact H\n\n"}
{"name":"Function.FactorsThrough.extend_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : α → γ\ne' : β → γ\nhf : Function.FactorsThrough g f\n⊢ Eq (Function.comp (Function.extend f g e') f) g","decl":"lemma FactorsThrough.extend_comp {g : α → γ} (e' : β → γ) (hf : FactorsThrough g f) :\n    extend f g e' ∘ f = g :=\n  funext fun a => hf.extend_apply e' a\n\n"}
{"name":"Function.extend_const","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nc : γ\n⊢ Eq (Function.extend f (fun x => c) fun x => c) fun x => c","decl":"@[simp]\nlemma extend_const (f : α → β) (c : γ) : extend f (fun _ ↦ c) (fun _ ↦ c) = fun _ ↦ c :=\n  funext fun _ ↦ ite_id _\n\n"}
{"name":"Function.extend_comp","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ng : α → γ\ne' : β → γ\n⊢ Eq (Function.comp (Function.extend f g e') f) g","decl":"@[simp]\ntheorem extend_comp (hf : Injective f) (g : α → γ) (e' : β → γ) : extend f g e' ∘ f = g :=\n  funext fun a ↦ hf.extend_apply g e' a\n\n"}
{"name":"Function.Injective.surjective_comp_right'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Injective f\ng₀ : β → γ\n⊢ Function.Surjective fun g => Function.comp g f","decl":"theorem Injective.surjective_comp_right' (hf : Injective f) (g₀ : β → γ) :\n    Surjective fun g : β → γ ↦ g ∘ f :=\n  fun g ↦ ⟨extend f g g₀, extend_comp hf _ _⟩\n\n"}
{"name":"Function.Injective.surjective_comp_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ninst✝ : Nonempty γ\nhf : Function.Injective f\n⊢ Function.Surjective fun g => Function.comp g f","decl":"theorem Injective.surjective_comp_right [Nonempty γ] (hf : Injective f) :\n    Surjective fun g : β → γ ↦ g ∘ f :=\n  hf.surjective_comp_right' fun _ ↦ Classical.choice ‹_›\n\n"}
{"name":"Function.Bijective.comp_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\nhf : Function.Bijective f\n⊢ Function.Bijective fun g => Function.comp g f","decl":"theorem Bijective.comp_right (hf : Bijective f) : Bijective fun g : β → γ ↦ g ∘ f :=\n  ⟨hf.surjective.injective_comp_right, fun g ↦\n    ⟨g ∘ surjInv hf.surjective,\n     by simp only [comp_assoc g _ f, (leftInverse_surjInv hf).comp_eq_id, comp_id]⟩⟩\n\n"}
{"name":"Function.FactorsThrough.rfl","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\n⊢ Function.FactorsThrough f f","decl":"protected theorem rfl {α β : Sort*} {f : α → β} : FactorsThrough f f := fun _ _ ↦ id\n\n"}
{"name":"Function.FactorsThrough.comp_left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nδ : Sort u_4\nf : α → β\ng : α → γ\nh : Function.FactorsThrough g f\ng' : γ → δ\n⊢ Function.FactorsThrough (Function.comp g' g) f","decl":"theorem comp_left {α β γ δ : Sort*} {f : α → β} {g : α → γ} (h : FactorsThrough g f) (g' : γ → δ) :\n    FactorsThrough (g' ∘ g) f := fun _x _y hxy ↦\n  congr_arg g' (h hxy)\n\n"}
{"name":"Function.FactorsThrough.comp_right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nδ : Sort u_4\nf : α → β\ng : α → γ\nh : Function.FactorsThrough g f\ng' : δ → α\n⊢ Function.FactorsThrough (Function.comp g g') (Function.comp f g')","decl":"theorem comp_right {α β γ δ : Sort*} {f : α → β} {g : α → γ} (h : FactorsThrough g f) (g' : δ → α) :\n    FactorsThrough (g ∘ g') (f ∘ g') := fun _x _y hxy ↦\n  h hxy\n\n"}
{"name":"Function.uncurry_def","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Sort u_3\nf : α → β → γ\n⊢ Eq (Function.uncurry f) fun p => f p.fst p.snd","decl":"theorem uncurry_def {α β γ} (f : α → β → γ) : uncurry f = fun p ↦ f p.1 p.2 :=\n  rfl\n\n"}
{"name":"Function.uncurry_bicompr","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β → γ\ng : γ → δ\n⊢ Eq (Function.uncurry (Function.bicompr g f)) (Function.comp g (Function.uncurry f))","decl":"theorem uncurry_bicompr (f : α → β → γ) (g : γ → δ) : uncurry (g ∘₂ f) = g ∘ uncurry f :=\n  rfl\n\n"}
{"name":"Function.uncurry_bicompl","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nε : Type u_5\nf : γ → δ → ε\ng : α → γ\nh : β → δ\n⊢ Eq (Function.uncurry (Function.bicompl f g h)) (Function.comp (Function.uncurry f) (Prod.map g h))","decl":"theorem uncurry_bicompl (f : γ → δ → ε) (g : α → γ) (h : β → δ) :\n    uncurry (bicompl f g h) = uncurry f ∘ Prod.map g h :=\n  rfl\n\n"}
{"name":"Bool.involutive_not","module":"Mathlib.Logic.Function.Basic","initialProofState":"⊢ Function.Involutive Bool.not","decl":"theorem _root_.Bool.involutive_not : Involutive not :=\n  Bool.not_not\n\n"}
{"name":"Function.Involutive.comp_self","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Eq (Function.comp f f) id","decl":"@[simp]\ntheorem comp_self : f ∘ f = id :=\n  funext h\n\n"}
{"name":"Function.Involutive.leftInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Function.LeftInverse f f","decl":"protected theorem leftInverse : LeftInverse f f := h\n\n"}
{"name":"Function.Involutive.leftInverse_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\ng : α → α\n⊢ Iff (Function.LeftInverse g f) (Eq g f)","decl":"theorem leftInverse_iff {g : α → α} :\n    g.LeftInverse f ↔ g = f :=\n  ⟨fun hg ↦ funext fun x ↦ by rw [← h x, hg, h], fun he ↦ he ▸ h.leftInverse⟩\n\n"}
{"name":"Function.Involutive.rightInverse","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Function.RightInverse f f","decl":"protected theorem rightInverse : RightInverse f f := h\n\n"}
{"name":"Function.Involutive.injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Function.Injective f","decl":"protected theorem injective : Injective f := h.leftInverse.injective\n\n"}
{"name":"Function.Involutive.surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Function.Surjective f","decl":"protected theorem surjective : Surjective f := fun x ↦ ⟨f x, h x⟩\n\n"}
{"name":"Function.Involutive.bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\n⊢ Function.Bijective f","decl":"protected theorem bijective : Bijective f := ⟨h.injective, h.surjective⟩\n\n"}
{"name":"Function.Involutive.ite_not","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\nP : Prop\ninst✝ : Decidable P\nx : α\n⊢ Eq (f (ite P x (f x))) (ite (Not P) x (f x))","decl":"/-- Involuting an `ite` of an involuted value `x : α` negates the `Prop` condition in the `ite`. -/\nprotected theorem ite_not (P : Prop) [Decidable P] (x : α) :\n    f (ite P x (f x)) = ite (¬P) x (f x) := by rw [apply_ite f, h, ite_not]\n\n"}
{"name":"Function.Involutive.eq_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nf : α → α\nh : Function.Involutive f\nx y : α\n⊢ Iff (Eq (f x) y) (Eq x (f y))","decl":"/-- An involution commutes across an equality. Compare to `Function.Injective.eq_iff`. -/\nprotected theorem eq_iff {x y : α} : f x = y ↔ x = f y :=\n  h.injective.eq_iff' (h y)\n\n"}
{"name":"Function.not_involutive","module":"Mathlib.Logic.Function.Basic","initialProofState":"⊢ Function.Involutive Not","decl":"lemma not_involutive : Involutive Not := fun _ ↦ propext not_not\n"}
{"name":"Function.not_injective","module":"Mathlib.Logic.Function.Basic","initialProofState":"⊢ Function.Injective Not","decl":"lemma not_injective : Injective Not := not_involutive.injective\n"}
{"name":"Function.not_surjective","module":"Mathlib.Logic.Function.Basic","initialProofState":"⊢ Function.Surjective Not","decl":"lemma not_surjective : Surjective Not := not_involutive.surjective\n"}
{"name":"Function.not_bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"⊢ Function.Bijective Not","decl":"lemma not_bijective : Bijective Not := not_involutive.bijective\n\n"}
{"name":"Function.symmetric_apply_eq_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nf : α → α\n⊢ Iff (Symmetric fun x1 x2 => Eq (f x1) x2) (Function.Involutive f)","decl":"@[simp]\nlemma symmetric_apply_eq_iff {α : Sort*} {f : α → α} : Symmetric (f · = ·) ↔ Involutive f := by\n  simp [Symmetric, Involutive]\n\n"}
{"name":"Function.Injective2.left","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\nhf : Function.Injective2 f\nb : β\n⊢ Function.Injective fun a => f a b","decl":"/-- A binary injective function is injective when only the left argument varies. -/\nprotected theorem left (hf : Injective2 f) (b : β) : Function.Injective fun a ↦ f a b :=\n  fun _ _ h ↦ (hf h).left\n\n"}
{"name":"Function.Injective2.right","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\nhf : Function.Injective2 f\na : α\n⊢ Function.Injective (f a)","decl":"/-- A binary injective function is injective when only the right argument varies. -/\nprotected theorem right (hf : Injective2 f) (a : α) : Function.Injective (f a) :=\n  fun _ _ h ↦ (hf h).right\n\n"}
{"name":"Function.Injective2.uncurry","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\nf : α → β → γ\nhf : Function.Injective2 f\n⊢ Function.Injective (Function.uncurry f)","decl":"protected theorem uncurry {α β γ : Type*} {f : α → β → γ} (hf : Injective2 f) :\n    Function.Injective (uncurry f) :=\n  fun ⟨_, _⟩ ⟨_, _⟩ h ↦ (hf h).elim (congr_arg₂ _)\n\n"}
{"name":"Function.Injective2.left'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\nhf : Function.Injective2 f\ninst✝ : Nonempty β\n⊢ Function.Injective f","decl":"/-- As a map from the left argument to a unary function, `f` is injective. -/\ntheorem left' (hf : Injective2 f) [Nonempty β] : Function.Injective f := fun _ _ h ↦\n  let ⟨b⟩ := ‹Nonempty β›\n  hf.left b <| (congr_fun h b :)\n\n"}
{"name":"Function.Injective2.right'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\nhf : Function.Injective2 f\ninst✝ : Nonempty α\n⊢ Function.Injective fun b a => f a b","decl":"/-- As a map from the right argument to a unary function, `f` is injective. -/\ntheorem right' (hf : Injective2 f) [Nonempty α] : Function.Injective fun b a ↦ f a b :=\n  fun _ _ h ↦\n    let ⟨a⟩ := ‹Nonempty α›\n    hf.right a <| (congr_fun h a :)\n\n"}
{"name":"Function.Injective2.eq_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β → γ\nhf : Function.Injective2 f\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Iff (Eq (f a₁ b₁) (f a₂ b₂)) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"theorem eq_iff (hf : Injective2 f) {a₁ a₂ b₁ b₂} : f a₁ b₁ = f a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ :=\n  ⟨fun h ↦ hf h, fun ⟨h1, h2⟩ ↦ congr_arg₂ f h1 h2⟩\n\n"}
{"name":"Function.sometimes_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"p : Prop\nα : Sort u_1\ninst✝ : Nonempty α\nf : p → α\na : p\n⊢ Eq (Function.sometimes f) (f a)","decl":"theorem sometimes_eq {p : Prop} {α} [Nonempty α] (f : p → α) (a : p) : sometimes f = f a :=\n  dif_pos ⟨a⟩\n\n"}
{"name":"Function.sometimes_spec","module":"Mathlib.Logic.Function.Basic","initialProofState":"p : Prop\nα : Sort u_1\ninst✝ : Nonempty α\nP : α → Prop\nf : p → α\na : p\nh : P (f a)\n⊢ P (Function.sometimes f)","decl":"theorem sometimes_spec {p : Prop} {α} [Nonempty α] (P : α → Prop) (f : p → α) (a : p)\n    (h : P (f a)) : P (sometimes f) := by\n  rwa [sometimes_eq]\n\n"}
{"name":"forall_existsUnique_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : α → β → Prop\n⊢ Iff (∀ (a : α), ExistsUnique fun b => r a b) (Exists fun f => ∀ {a : α} {b : β}, Iff (r a b) (Eq (f a) b))","decl":"/-- A relation `r : α → β → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some function `f`. -/\nlemma forall_existsUnique_iff {r : α → β → Prop} :\n    (∀ a, ∃! b, r a b) ↔ ∃ f : α → β, ∀ {a b}, r a b ↔ f a = b := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · refine ⟨fun a ↦ (h a).choose, fun hr ↦ ?_, fun h' ↦ h' ▸ ?_⟩\n    exacts [((h _).choose_spec.2 _ hr).symm, (h _).choose_spec.1]\n  · rintro ⟨f, hf⟩\n    simp [hf]\n\n"}
{"name":"forall_existsUnique_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : α → β → Prop\n⊢ Iff (∀ (a : α), ExistsUnique fun b => r a b) (Exists fun f => Eq r fun x1 x2 => Eq (f x1) x2)","decl":"/-- A relation `r : α → β → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some function `f`. -/\nlemma forall_existsUnique_iff' {r : α → β → Prop} :\n    (∀ a, ∃! b, r a b) ↔ ∃ f : α → β, r = (f · = ·) := by\n  simp [forall_existsUnique_iff, funext_iff]\n\n"}
{"name":"Symmetric.forall_existsUnique_iff'","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nr : α → α → Prop\nhr : Symmetric r\n⊢ Iff (∀ (a : α), ExistsUnique fun b => r a b) (Exists fun f => And (Function.Involutive f) (Eq r fun x1 x2 => Eq (f x1) x2))","decl":"/-- A symmetric relation `r : α → α → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some involutive function `f`. -/\nprotected lemma Symmetric.forall_existsUnique_iff' {r : α → α → Prop} (hr : Symmetric r) :\n    (∀ a, ∃! b, r a b) ↔ ∃ f : α → α, Involutive f ∧ r = (f · = ·) := by\n  refine ⟨fun h ↦ ?_, fun ⟨f, _, hf⟩ ↦ forall_existsUnique_iff'.2 ⟨f, hf⟩⟩\n  rcases forall_existsUnique_iff'.1 h with ⟨f, rfl : r = _⟩\n  exact ⟨f, symmetric_apply_eq_iff.1 hr, rfl⟩\n\n"}
{"name":"Symmetric.forall_existsUnique_iff","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nr : α → α → Prop\nhr : Symmetric r\n⊢ Iff (∀ (a : α), ExistsUnique fun b => r a b) (Exists fun f => And (Function.Involutive f) (∀ {a b : α}, Iff (r a b) (Eq (f a) b)))","decl":"/-- A symmetric relation `r : α → α → Prop` is \"function-like\"\n(for each `a` there exists a unique `b` such that `r a b`)\nif and only if it is `(f · = ·)` for some involutive function `f`. -/\nprotected lemma Symmetric.forall_existsUnique_iff {r : α → α → Prop} (hr : Symmetric r) :\n    (∀ a, ∃! b, r a b) ↔ ∃ f : α → α, Involutive f ∧ ∀ {a b}, r a b ↔ f a = b := by\n  simp [hr.forall_existsUnique_iff', funext_iff]\n\n"}
{"name":"eq_rec_on_bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nC : α → Sort u_3\na a' : α\nh : Eq a a'\n⊢ Function.Bijective fun x => Eq.ndrec x h","decl":"theorem eq_rec_on_bijective {C : α → Sort*} :\n    ∀ {a a' : α} (h : a = a'), Function.Bijective (@Eq.ndrec _ _ C · _ h)\n  | _, _, rfl => ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩\n\n"}
{"name":"eq_mp_bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α β : Sort u_3\nh : Eq α β\n⊢ Function.Bijective h.mp","decl":"theorem eq_mp_bijective {α β : Sort _} (h : α = β) : Function.Bijective (Eq.mp h) := by\n  -- TODO: mathlib3 uses `eq_rec_on_bijective`, difference in elaboration here\n  -- due to `@[macro_inline]` possibly?\n  cases h\n  exact ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩\n\n"}
{"name":"eq_mpr_bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α β : Sort u_3\nh : Eq α β\n⊢ Function.Bijective h.mpr","decl":"theorem eq_mpr_bijective {α β : Sort _} (h : α = β) : Function.Bijective (Eq.mpr h) := by\n  cases h\n  exact ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩\n\n"}
{"name":"cast_bijective","module":"Mathlib.Logic.Function.Basic","initialProofState":"α β : Sort u_3\nh : Eq α β\n⊢ Function.Bijective (cast h)","decl":"theorem cast_bijective {α β : Sort _} (h : α = β) : Function.Bijective (cast h) := by\n  cases h\n  exact ⟨fun _ _ ↦ id, fun x ↦ ⟨x, rfl⟩⟩\n\n"}
{"name":"eq_rec_inj","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\na a' : α\nh : Eq a a'\nC : α → Type u_3\nx y : C a\n⊢ Iff (Eq (Eq.ndrec x h) (Eq.ndrec y h)) (Eq x y)","decl":"@[simp]\ntheorem eq_rec_inj {a a' : α} (h : a = a') {C : α → Type*} (x y : C a) :\n    (Eq.ndrec x h : C a') = Eq.ndrec y h ↔ x = y :=\n  (eq_rec_on_bijective h).injective.eq_iff\n\n"}
{"name":"cast_inj","module":"Mathlib.Logic.Function.Basic","initialProofState":"α β : Type u\nh : Eq α β\nx y : α\n⊢ Iff (Eq (cast h x) (cast h y)) (Eq x y)","decl":"@[simp]\ntheorem cast_inj {α β : Type u} (h : α = β) {x y : α} : cast h x = cast h y ↔ x = y :=\n  (cast_bijective h).injective.eq_iff\n\n"}
{"name":"Function.LeftInverse.eq_rec_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : β → Sort v\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\nC : (a : α) → γ (f a)\na : α\n⊢ Eq (Eq.rec (C (g (f a))) ⋯) (C a)","decl":"theorem Function.LeftInverse.eq_rec_eq {γ : β → Sort v} {f : α → β} {g : β → α}\n    (h : Function.LeftInverse g f) (C : ∀ a : α, γ (f a)) (a : α) :\n    -- TODO: mathlib3 uses `(congr_arg f (h a)).rec (C (g (f a)))` for LHS\n    @Eq.rec β (f (g (f a))) (fun x _ ↦ γ x) (C (g (f a))) (f a) (congr_arg f (h a)) = C a :=\n  eq_of_heq <| (eqRec_heq _ _).trans <| by rw [h]\n\n"}
{"name":"Function.LeftInverse.eq_rec_on_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : β → Sort v\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\nC : (a : α) → γ (f a)\na : α\n⊢ Eq (Eq.recOn ⋯ (C (g (f a)))) (C a)","decl":"theorem Function.LeftInverse.eq_rec_on_eq {γ : β → Sort v} {f : α → β} {g : β → α}\n    (h : Function.LeftInverse g f) (C : ∀ a : α, γ (f a)) (a : α) :\n    -- TODO: mathlib3 uses `(congr_arg f (h a)).recOn (C (g (f a)))` for LHS\n    @Eq.recOn β (f (g (f a))) (fun x _ ↦ γ x) (f a) (congr_arg f (h a)) (C (g (f a))) = C a :=\n  h.eq_rec_eq _ _\n\n"}
{"name":"Function.LeftInverse.cast_eq","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : β → Sort v\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\nC : (a : α) → γ (f a)\na : α\n⊢ Eq (cast ⋯ (C (g (f a)))) (C a)","decl":"theorem Function.LeftInverse.cast_eq {γ : β → Sort v} {f : α → β} {g : β → α}\n    (h : Function.LeftInverse g f) (C : ∀ a : α, γ (f a)) (a : α) :\n    cast (congr_arg (fun a ↦ γ (f a)) (h a)) (C (g (f a))) = C a := by\n  rw [cast_eq_iff_heq, h]\n\n"}
{"name":"InvImage.equivalence","module":"Mathlib.Logic.Function.Basic","initialProofState":"α : Sort u\nβ : Sort v\nr : β → β → Prop\nf : α → β\nh : Equivalence r\n⊢ Equivalence (InvImage r f)","decl":"theorem InvImage.equivalence {α : Sort u} {β : Sort v} (r : β → β → Prop) (f : α → β)\n    (h : Equivalence r) : Equivalence (InvImage r f) :=\n  ⟨fun _ ↦ h.1 _, h.symm, h.trans⟩\n\n"}
