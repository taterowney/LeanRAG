{"name":"AddGroupConeClass.toAddSubmonoidClass","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : outParam (Type u_2)\ninst✝¹ : AddCommGroup G\ninst✝ : SetLike S G\nself : AddGroupConeClass S G\n⊢ AddSubmonoidClass S G","decl":"/-- `AddGroupConeClass S G` says that `S` is a type of cones in `G`. -/\nclass AddGroupConeClass (S : Type*) (G : outParam Type*) [AddCommGroup G] [SetLike S G]\n    extends AddSubmonoidClass S G : Prop where\n  eq_zero_of_mem_of_neg_mem {C : S} {a : G} : a ∈ C → -a ∈ C → a = 0\n\n"}
{"name":"AddGroupConeClass.eq_zero_of_mem_of_neg_mem","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : outParam (Type u_2)\ninst✝¹ : AddCommGroup G\ninst✝ : SetLike S G\nself : AddGroupConeClass S G\nC : S\na : G\na✝¹ : Membership.mem C a\na✝ : Membership.mem C (Neg.neg a)\n⊢ Eq a 0","decl":"/-- `AddGroupConeClass S G` says that `S` is a type of cones in `G`. -/\nclass AddGroupConeClass (S : Type*) (G : outParam Type*) [AddCommGroup G] [SetLike S G]\n    extends AddSubmonoidClass S G : Prop where\n  eq_zero_of_mem_of_neg_mem {C : S} {a : G} : a ∈ C → -a ∈ C → a = 0\n\n"}
{"name":"GroupConeClass.eq_one_of_mem_of_inv_mem","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : outParam (Type u_2)\ninst✝¹ : CommGroup G\ninst✝ : SetLike S G\nself : GroupConeClass S G\nC : S\na : G\na✝¹ : Membership.mem C a\na✝ : Membership.mem C (Inv.inv a)\n⊢ Eq a 1","decl":"/-- `GroupConeClass S G` says that `S` is a type of cones in `G`. -/\n@[to_additive]\nclass GroupConeClass (S : Type*) (G : outParam Type*) [CommGroup G] [SetLike S G] extends\n    SubmonoidClass S G : Prop where\n  eq_one_of_mem_of_inv_mem {C : S} {a : G} : a ∈ C → a⁻¹ ∈ C → a = 1\n\n"}
{"name":"GroupConeClass.toSubmonoidClass","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : outParam (Type u_2)\ninst✝¹ : CommGroup G\ninst✝ : SetLike S G\nself : GroupConeClass S G\n⊢ SubmonoidClass S G","decl":"/-- `GroupConeClass S G` says that `S` is a type of cones in `G`. -/\n@[to_additive]\nclass GroupConeClass (S : Type*) (G : outParam Type*) [CommGroup G] [SetLike S G] extends\n    SubmonoidClass S G : Prop where\n  eq_one_of_mem_of_inv_mem {C : S} {a : G} : a ∈ C → a⁻¹ ∈ C → a = 1\n\n"}
{"name":"AddGroupCone.eq_zero_of_mem_of_neg_mem'","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\nself : AddGroupCone G\na : G\na✝¹ : Membership.mem self.carrier a\na✝ : Membership.mem self.carrier (Neg.neg a)\n⊢ Eq a 0","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the group into a partially ordered group. -/\nstructure AddGroupCone (G : Type*) [AddCommGroup G] extends AddSubmonoid G where\n  eq_zero_of_mem_of_neg_mem' {a} : a ∈ carrier → -a ∈ carrier → a = 0\n\n"}
{"name":"AddGroupCone.mk.inj","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\ntoAddSubmonoid✝ : AddSubmonoid G\neq_zero_of_mem_of_neg_mem'✝ : ∀ {a : G}, Membership.mem toAddSubmonoid✝.carrier a → Membership.mem toAddSubmonoid✝.carrier (Neg.neg a) → Eq a 0\ntoAddSubmonoid : AddSubmonoid G\neq_zero_of_mem_of_neg_mem' : ∀ {a : G}, Membership.mem toAddSubmonoid.carrier a → Membership.mem toAddSubmonoid.carrier (Neg.neg a) → Eq a 0\nx✝ : Eq { toAddSubmonoid := toAddSubmonoid✝, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem'✝ } { toAddSubmonoid := toAddSubmonoid, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }\n⊢ Eq toAddSubmonoid✝ toAddSubmonoid","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the group into a partially ordered group. -/\nstructure AddGroupCone (G : Type*) [AddCommGroup G] extends AddSubmonoid G where\n  eq_zero_of_mem_of_neg_mem' {a} : a ∈ carrier → -a ∈ carrier → a = 0\n\n"}
{"name":"AddGroupCone.mk.injEq","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\ntoAddSubmonoid✝ : AddSubmonoid G\neq_zero_of_mem_of_neg_mem'✝ : ∀ {a : G}, Membership.mem toAddSubmonoid✝.carrier a → Membership.mem toAddSubmonoid✝.carrier (Neg.neg a) → Eq a 0\ntoAddSubmonoid : AddSubmonoid G\neq_zero_of_mem_of_neg_mem' : ∀ {a : G}, Membership.mem toAddSubmonoid.carrier a → Membership.mem toAddSubmonoid.carrier (Neg.neg a) → Eq a 0\n⊢ Eq (Eq { toAddSubmonoid := toAddSubmonoid✝, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem'✝ } { toAddSubmonoid := toAddSubmonoid, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }) (Eq toAddSubmonoid✝ toAddSubmonoid)","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the group into a partially ordered group. -/\nstructure AddGroupCone (G : Type*) [AddCommGroup G] extends AddSubmonoid G where\n  eq_zero_of_mem_of_neg_mem' {a} : a ∈ carrier → -a ∈ carrier → a = 0\n\n"}
{"name":"AddGroupCone.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : SizeOf G\ntoAddSubmonoid : AddSubmonoid G\neq_zero_of_mem_of_neg_mem' : ∀ {a : G}, Membership.mem toAddSubmonoid.carrier a → Membership.mem toAddSubmonoid.carrier (Neg.neg a) → Eq a 0\n⊢ Eq (SizeOf.sizeOf { toAddSubmonoid := toAddSubmonoid, eq_zero_of_mem_of_neg_mem' := eq_zero_of_mem_of_neg_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddSubmonoid))","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `-a` for any nonzero `a`.\nThis is equivalent to being the set of non-negative elements of\nsome order making the group into a partially ordered group. -/\nstructure AddGroupCone (G : Type*) [AddCommGroup G] extends AddSubmonoid G where\n  eq_zero_of_mem_of_neg_mem' {a} : a ∈ carrier → -a ∈ carrier → a = 0\n\n"}
{"name":"GroupCone.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : SizeOf G\ntoSubmonoid : Submonoid G\neq_one_of_mem_of_inv_mem' : ∀ {a : G}, Membership.mem toSubmonoid.carrier a → Membership.mem toSubmonoid.carrier (Inv.inv a) → Eq a 1\n⊢ Eq (SizeOf.sizeOf { toSubmonoid := toSubmonoid, eq_one_of_mem_of_inv_mem' := eq_one_of_mem_of_inv_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubmonoid))","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `a⁻¹` for any non-identity `a`.\nThis is equivalent to being the set of elements that are at least 1 in\nsome order making the group into a partially ordered group. -/\n@[to_additive]\nstructure GroupCone (G : Type*) [CommGroup G] extends Submonoid G where\n  eq_one_of_mem_of_inv_mem' {a} : a ∈ carrier → a⁻¹ ∈ carrier → a = 1\n\n"}
{"name":"GroupCone.mk.inj","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\ntoSubmonoid✝ : Submonoid G\neq_one_of_mem_of_inv_mem'✝ : ∀ {a : G}, Membership.mem toSubmonoid✝.carrier a → Membership.mem toSubmonoid✝.carrier (Inv.inv a) → Eq a 1\ntoSubmonoid : Submonoid G\neq_one_of_mem_of_inv_mem' : ∀ {a : G}, Membership.mem toSubmonoid.carrier a → Membership.mem toSubmonoid.carrier (Inv.inv a) → Eq a 1\nx✝ : Eq { toSubmonoid := toSubmonoid✝, eq_one_of_mem_of_inv_mem' := eq_one_of_mem_of_inv_mem'✝ } { toSubmonoid := toSubmonoid, eq_one_of_mem_of_inv_mem' := eq_one_of_mem_of_inv_mem' }\n⊢ Eq toSubmonoid✝ toSubmonoid","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `a⁻¹` for any non-identity `a`.\nThis is equivalent to being the set of elements that are at least 1 in\nsome order making the group into a partially ordered group. -/\n@[to_additive]\nstructure GroupCone (G : Type*) [CommGroup G] extends Submonoid G where\n  eq_one_of_mem_of_inv_mem' {a} : a ∈ carrier → a⁻¹ ∈ carrier → a = 1\n\n"}
{"name":"GroupCone.eq_one_of_mem_of_inv_mem'","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\nself : GroupCone G\na : G\na✝¹ : Membership.mem self.carrier a\na✝ : Membership.mem self.carrier (Inv.inv a)\n⊢ Eq a 1","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `a⁻¹` for any non-identity `a`.\nThis is equivalent to being the set of elements that are at least 1 in\nsome order making the group into a partially ordered group. -/\n@[to_additive]\nstructure GroupCone (G : Type*) [CommGroup G] extends Submonoid G where\n  eq_one_of_mem_of_inv_mem' {a} : a ∈ carrier → a⁻¹ ∈ carrier → a = 1\n\n"}
{"name":"GroupCone.mk.injEq","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\ntoSubmonoid✝ : Submonoid G\neq_one_of_mem_of_inv_mem'✝ : ∀ {a : G}, Membership.mem toSubmonoid✝.carrier a → Membership.mem toSubmonoid✝.carrier (Inv.inv a) → Eq a 1\ntoSubmonoid : Submonoid G\neq_one_of_mem_of_inv_mem' : ∀ {a : G}, Membership.mem toSubmonoid.carrier a → Membership.mem toSubmonoid.carrier (Inv.inv a) → Eq a 1\n⊢ Eq (Eq { toSubmonoid := toSubmonoid✝, eq_one_of_mem_of_inv_mem' := eq_one_of_mem_of_inv_mem'✝ } { toSubmonoid := toSubmonoid, eq_one_of_mem_of_inv_mem' := eq_one_of_mem_of_inv_mem' }) (Eq toSubmonoid✝ toSubmonoid)","decl":"/-- A (positive) cone in an abelian group is a submonoid that\ndoes not contain both `a` and `a⁻¹` for any non-identity `a`.\nThis is equivalent to being the set of elements that are at least 1 in\nsome order making the group into a partially ordered group. -/\n@[to_additive]\nstructure GroupCone (G : Type*) [CommGroup G] extends Submonoid G where\n  eq_one_of_mem_of_inv_mem' {a} : a ∈ carrier → a⁻¹ ∈ carrier → a = 1\n\n"}
{"name":"AddGroupCone.instAddGroupConeClass","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\n⊢ AddGroupConeClass (AddGroupCone G) G","decl":"@[to_additive]\ninstance GroupCone.instGroupConeClass (G : Type*) [CommGroup G] :\n    GroupConeClass (GroupCone G) G where\n  mul_mem {C} := C.mul_mem'\n  one_mem {C} := C.one_mem'\n  eq_one_of_mem_of_inv_mem {C} := C.eq_one_of_mem_of_inv_mem'\n\n"}
{"name":"GroupCone.instGroupConeClass","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\n⊢ GroupConeClass (GroupCone G) G","decl":"@[to_additive]\ninstance GroupCone.instGroupConeClass (G : Type*) [CommGroup G] :\n    GroupConeClass (GroupCone G) G where\n  mul_mem {C} := C.mul_mem'\n  one_mem {C} := C.one_mem'\n  eq_one_of_mem_of_inv_mem {C} := C.eq_one_of_mem_of_inv_mem'\n\n"}
{"name":"IsMaxCone.mem_or_neg_mem","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : Type u_2\ninst✝¹ : AddCommGroup G\ninst✝ : SetLike S G\nC : S\nself : IsMaxCone C\na : G\n⊢ Or (Membership.mem C a) (Membership.mem C (Neg.neg a))","decl":"/-- Typeclass for maximal additive cones. -/\nclass IsMaxCone {S G : Type*} [AddCommGroup G] [SetLike S G] (C : S) : Prop where\n  mem_or_neg_mem (a : G) : a ∈ C ∨ -a ∈ C\n\n"}
{"name":"IsMaxMulCone.mem_or_inv_mem","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"S : Type u_1\nG : Type u_2\ninst✝¹ : CommGroup G\ninst✝ : SetLike S G\nC : S\nself : IsMaxMulCone C\na : G\n⊢ Or (Membership.mem C a) (Membership.mem C (Inv.inv a))","decl":"/-- Typeclass for maximal multiplicative cones. -/\n@[to_additive IsMaxCone]\nclass IsMaxMulCone {S G : Type*} [CommGroup G] [SetLike S G] (C : S) : Prop where\n  mem_or_inv_mem (a : G) : a ∈ C ∨ a⁻¹ ∈ C\n\n"}
{"name":"GroupCone.oneLE_toSubmonoid","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedCommGroup H\n⊢ Eq (GroupCone.oneLE H).toSubmonoid (Submonoid.oneLE H)","decl":"@[to_additive (attr := simp)]\nlemma oneLE_toSubmonoid : (oneLE H).toSubmonoid = .oneLE H := rfl\n"}
{"name":"AddGroupCone.nonneg_toAddSubmonoid","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedAddCommGroup H\n⊢ Eq (AddGroupCone.nonneg H).toAddSubmonoid (AddSubmonoid.nonneg H)","decl":"@[to_additive (attr := simp)]\nlemma oneLE_toSubmonoid : (oneLE H).toSubmonoid = .oneLE H := rfl\n"}
{"name":"GroupCone.mem_oneLE","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedCommGroup H\na : H\n⊢ Iff (Membership.mem (GroupCone.oneLE H) a) (LE.le 1 a)","decl":"@[to_additive (attr := simp)]\nlemma mem_oneLE : a ∈ oneLE H ↔ 1 ≤ a := Iff.rfl\n"}
{"name":"AddGroupCone.mem_nonneg","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedAddCommGroup H\na : H\n⊢ Iff (Membership.mem (AddGroupCone.nonneg H) a) (LE.le 0 a)","decl":"@[to_additive (attr := simp)]\nlemma mem_oneLE : a ∈ oneLE H ↔ 1 ≤ a := Iff.rfl\n"}
{"name":"AddGroupCone.coe_nonneg","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedAddCommGroup H\n⊢ Eq (↑(AddGroupCone.nonneg H)) (setOf fun x => LE.le 0 x)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_oneLE : oneLE H = {x : H | 1 ≤ x} := rfl\n\n"}
{"name":"GroupCone.coe_oneLE","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_1\ninst✝ : OrderedCommGroup H\n⊢ Eq (↑(GroupCone.oneLE H)) (setOf fun x => LE.le 1 x)","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma coe_oneLE : oneLE H = {x : H | 1 ≤ x} := rfl\n\n"}
{"name":"AddGroupCone.nonneg.isMaxCone","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_2\ninst✝ : LinearOrderedAddCommGroup H\n⊢ IsMaxCone (AddGroupCone.nonneg H)","decl":"@[to_additive nonneg.isMaxCone]\ninstance oneLE.isMaxMulCone {H : Type*} [LinearOrderedCommGroup H] : IsMaxMulCone (oneLE H) where\n  mem_or_inv_mem := by simpa using le_total 1\n\n"}
{"name":"GroupCone.oneLE.isMaxMulCone","module":"Mathlib.Algebra.Order.Group.Cone","initialProofState":"H : Type u_2\ninst✝ : LinearOrderedCommGroup H\n⊢ IsMaxMulCone (GroupCone.oneLE H)","decl":"@[to_additive nonneg.isMaxCone]\ninstance oneLE.isMaxMulCone {H : Type*} [LinearOrderedCommGroup H] : IsMaxMulCone (oneLE H) where\n  mem_or_inv_mem := by simpa using le_total 1\n\n"}
