{"name":"NumberField.mixedEmbedding.volume_fundamentalDomain_latticeBasis","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.latticeBasis K))) (HMul.hMul (HPow.hPow (Inv.inv 2) (NumberField.InfinitePlace.nrComplexPlaces K)) ‚Üë(NNReal.sqrt (NNNorm.nnnorm (NumberField.discr K))))","decl":"open scoped Classical in\ntheorem _root_.NumberField.mixedEmbedding.volume_fundamentalDomain_latticeBasis :\n    volume (fundamentalDomain (latticeBasis K)) =\n      (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ nrComplexPlaces K * sqrt ‚Äñdiscr K‚Äñ‚Çä := by\n  let f : Module.Free.ChooseBasisIndex ‚Ñ§ (ùìû K) ‚âÉ (K ‚Üí+* ‚ÑÇ) :=\n    (canonicalEmbedding.latticeBasis K).indexEquiv (Pi.basisFun ‚ÑÇ _)\n  let e : (index K) ‚âÉ Module.Free.ChooseBasisIndex ‚Ñ§ (ùìû K) := (indexEquiv K).trans f.symm\n  let M := (mixedEmbedding.stdBasis K).toMatrix ((latticeBasis K).reindex e.symm)\n  let N := Algebra.embeddingsMatrixReindex ‚Ñö ‚ÑÇ (integralBasis K ‚àò f.symm)\n    RingHom.equivRatAlgHom\n  suffices M.map ofRealHom = matrixToStdBasis K *\n      (Matrix.reindex (indexEquiv K).symm (indexEquiv K).symm N).transpose by\n    calc volume (fundamentalDomain (latticeBasis K))\n      _ = ‚Äñ((mixedEmbedding.stdBasis K).toMatrix ((latticeBasis K).reindex e.symm)).det‚Äñ‚Çä := by\n        rw [‚Üê fundamentalDomain_reindex _ e.symm, ‚Üê norm_toNNReal, measure_fundamentalDomain\n          ((latticeBasis K).reindex e.symm), volume_fundamentalDomain_stdBasis, mul_one]\n        rfl\n      _ = ‚Äñ(matrixToStdBasis K).det * N.det‚Äñ‚Çä := by\n        rw [‚Üê nnnorm_real, ‚Üê ofRealHom_eq_coe, RingHom.map_det, RingHom.mapMatrix_apply, this,\n          det_mul, det_transpose, det_reindex_self]\n      _ = (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ Fintype.card {w : InfinitePlace K // IsComplex w} * sqrt ‚ÄñN.det ^ 2‚Äñ‚Çä := by\n        have : ‚ÄñComplex.I‚Äñ‚Çä = 1 := by rw [‚Üê norm_toNNReal, norm_eq_abs, abs_I, Real.toNNReal_one]\n        rw [det_matrixToStdBasis, nnnorm_mul, nnnorm_pow, nnnorm_mul, this, mul_one, nnnorm_inv,\n          coe_mul, ENNReal.coe_pow, ‚Üê norm_toNNReal, RCLike.norm_two, Real.toNNReal_ofNat,\n          coe_inv two_ne_zero, coe_ofNat, nnnorm_pow, NNReal.sqrt_sq]\n      _ = (2 : ‚Ñù‚â•0‚àû)‚Åª¬π ^ Fintype.card { w // IsComplex w } * NNReal.sqrt ‚Äñdiscr K‚Äñ‚Çä := by\n        rw [‚Üê Algebra.discr_eq_det_embeddingsMatrixReindex_pow_two, Algebra.discr_reindex,\n          ‚Üê coe_discr, map_intCast, ‚Üê Complex.nnnorm_intCast]\n  ext : 2\n  dsimp only [M]\n  rw [Matrix.map_apply, Basis.toMatrix_apply, Basis.coe_reindex, Function.comp_apply,\n    Equiv.symm_symm, latticeBasis_apply, ‚Üê commMap_canonical_eq_mixed, Complex.ofRealHom_eq_coe,\n    stdBasis_repr_eq_matrixToStdBasis_mul K _ (fun _ => rfl)]\n  rfl\n\n"}
{"name":"NumberField.mixedEmbedding.covolume_integerLattice","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (ZLattice.covolume (NumberField.mixedEmbedding.integerLattice K) MeasureTheory.MeasureSpace.volume) (HMul.hMul (HPow.hPow (Inv.inv 2) (NumberField.InfinitePlace.nrComplexPlaces K)) (abs ‚Üë(NumberField.discr K)).sqrt)","decl":"open scoped Classical in\ntheorem _root_.NumberField.mixedEmbedding.covolume_integerLattice :\n    ZLattice.covolume (mixedEmbedding.integerLattice K) =\n      (2 ‚Åª¬π) ^ nrComplexPlaces K * ‚àö|discr K| := by\n  rw [ZLattice.covolume_eq_measure_fundamentalDomain _ _ (fundamentalDomain_integerLattice K),\n    volume_fundamentalDomain_latticeBasis, ENNReal.toReal_mul, ENNReal.toReal_pow,\n    ENNReal.toReal_inv, toReal_ofNat, ENNReal.coe_toReal, Real.coe_sqrt, coe_nnnorm,\n    Int.norm_eq_abs]\n\n"}
{"name":"NumberField.mixedEmbedding.covolume_idealLattice","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ Eq (ZLattice.covolume (NumberField.mixedEmbedding.idealLattice K I) MeasureTheory.MeasureSpace.volume) (HMul.hMul (HMul.hMul (‚Üë(FractionalIdeal.absNorm ‚ÜëI)) (HPow.hPow (Inv.inv 2) (NumberField.InfinitePlace.nrComplexPlaces K))) (abs ‚Üë(NumberField.discr K)).sqrt)","decl":"open scoped Classical in\ntheorem _root_.NumberField.mixedEmbedding.covolume_idealLattice (I : (FractionalIdeal (ùìû K)‚Å∞ K)À£) :\n    ZLattice.covolume (mixedEmbedding.idealLattice K I) =\n      (FractionalIdeal.absNorm (I : FractionalIdeal (ùìû K)‚Å∞ K)) *\n        (2 ‚Åª¬π) ^ nrComplexPlaces K * ‚àö|discr K| := by\n  rw [ZLattice.covolume_eq_measure_fundamentalDomain _ _ (fundamentalDomain_idealLattice K I),\n    volume_fundamentalDomain_fractionalIdealLatticeBasis, volume_fundamentalDomain_latticeBasis,\n    ENNReal.toReal_mul, ENNReal.toReal_mul, ENNReal.toReal_pow, ENNReal.toReal_inv, toReal_ofNat,\n    ENNReal.coe_toReal, Real.coe_sqrt, coe_nnnorm, Int.norm_eq_abs,\n    ENNReal.toReal_ofReal (Rat.cast_nonneg.mpr (FractionalIdeal.absNorm_nonneg I.val)), mul_assoc]\n\n"}
{"name":"NumberField.exists_ne_zero_mem_ideal_of_norm_le_mul_sqrt_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ Exists fun a => And (Membership.mem (‚ÜëI) a) (And (Ne a 0) (LE.le (‚Üë(abs ((Algebra.norm Rat) a))) (HMul.hMul (HDiv.hDiv (HMul.hMul (HMul.hMul (‚Üë(FractionalIdeal.absNorm ‚ÜëI)) (HPow.hPow (HDiv.hDiv 4 Real.pi) (NumberField.InfinitePlace.nrComplexPlaces K))) ‚Üë(Module.finrank Rat K).factorial) (HPow.hPow (‚Üë(Module.finrank Rat K)) (Module.finrank Rat K))) (abs ‚Üë(NumberField.discr K)).sqrt)))","decl":"theorem exists_ne_zero_mem_ideal_of_norm_le_mul_sqrt_discr (I : (FractionalIdeal (ùìû K)‚Å∞ K)À£) :\n    ‚àÉ a ‚àà (I : FractionalIdeal (ùìû K)‚Å∞ K), a ‚â† 0 ‚àß\n      |Algebra.norm ‚Ñö (a : K)| ‚â§ FractionalIdeal.absNorm I.1 * (4 / œÄ) ^ nrComplexPlaces K *\n        (finrank ‚Ñö K).factorial / (finrank ‚Ñö K) ^ (finrank ‚Ñö K) * Real.sqrt |discr K| := by\n  classical\n  -- The smallest possible value for `exists_ne_zero_mem_ideal_of_norm_le`\n  let B := (minkowskiBound K I * (convexBodySumFactor K)‚Åª¬π).toReal ^ (1 / (finrank ‚Ñö K : ‚Ñù))\n  have h_le : (minkowskiBound K I) ‚â§ volume (convexBodySum K B) := by\n    refine le_of_eq ?_\n    rw [convexBodySum_volume, ‚Üê ENNReal.ofReal_pow (by positivity), ‚Üê Real.rpow_natCast,\n      ‚Üê Real.rpow_mul toReal_nonneg, div_mul_cancel‚ÇÄ, Real.rpow_one, ofReal_toReal, mul_comm,\n      mul_assoc, ‚Üê coe_mul, inv_mul_cancel‚ÇÄ (convexBodySumFactor_ne_zero K), ENNReal.coe_one,\n      mul_one]\n    ¬∑ exact mul_ne_top (ne_of_lt (minkowskiBound_lt_top K I)) coe_ne_top\n    ¬∑ exact (Nat.cast_ne_zero.mpr (ne_of_gt finrank_pos))\n  convert exists_ne_zero_mem_ideal_of_norm_le K I h_le\n  rw [div_pow B, ‚Üê Real.rpow_natCast B, ‚Üê Real.rpow_mul (by positivity), div_mul_cancel‚ÇÄ _\n    (Nat.cast_ne_zero.mpr <| ne_of_gt finrank_pos), Real.rpow_one, mul_comm_div, mul_div_assoc']\n  congr 1\n  rw [eq_comm]\n  calc\n    _ = FractionalIdeal.absNorm I.1 * (2 : ‚Ñù)‚Åª¬π ^ nrComplexPlaces K * sqrt ‚Äñdiscr K‚Äñ‚Çä *\n          (2 : ‚Ñù) ^ finrank ‚Ñö K * ((2 : ‚Ñù) ^ nrRealPlaces K * (œÄ / 2) ^ nrComplexPlaces K /\n            (Nat.factorial (finrank ‚Ñö K)))‚Åª¬π := by\n      simp_rw [minkowskiBound, convexBodySumFactor,\n        volume_fundamentalDomain_fractionalIdealLatticeBasis,\n        volume_fundamentalDomain_latticeBasis, toReal_mul, toReal_pow, toReal_inv, coe_toReal,\n        toReal_ofNat, mixedEmbedding.finrank, mul_assoc]\n      rw [ENNReal.toReal_ofReal (Rat.cast_nonneg.mpr (FractionalIdeal.absNorm_nonneg I.1))]\n      simp_rw [NNReal.coe_inv, NNReal.coe_div, NNReal.coe_mul, NNReal.coe_pow, NNReal.coe_div,\n        coe_real_pi, NNReal.coe_ofNat, NNReal.coe_natCast]\n    _ = FractionalIdeal.absNorm I.1 * (2 : ‚Ñù) ^ (finrank ‚Ñö K - nrComplexPlaces K - nrRealPlaces K +\n          nrComplexPlaces K : ‚Ñ§) * Real.sqrt ‚Äñdiscr K‚Äñ * Nat.factorial (finrank ‚Ñö K) *\n            œÄ‚Åª¬π ^ (nrComplexPlaces K) := by\n      simp_rw [inv_div, div_eq_mul_inv, mul_inv, ‚Üê zpow_neg_one, ‚Üê zpow_natCast, mul_zpow,\n        ‚Üê zpow_mul, neg_one_mul, mul_neg_one, neg_neg, Real.coe_sqrt, coe_nnnorm, sub_eq_add_neg,\n        zpow_add‚ÇÄ (two_ne_zero : (2 : ‚Ñù) ‚â† 0)]\n      ring\n    _ = FractionalIdeal.absNorm I.1 * (2 : ‚Ñù) ^ (2 * nrComplexPlaces K : ‚Ñ§) * Real.sqrt ‚Äñdiscr K‚Äñ *\n          Nat.factorial (finrank ‚Ñö K) * œÄ‚Åª¬π ^ (nrComplexPlaces K) := by\n      congr\n      rw [‚Üê card_add_two_mul_card_eq_rank, Nat.cast_add, Nat.cast_mul, Nat.cast_ofNat]\n      ring\n    _ = FractionalIdeal.absNorm I.1 * (4 / œÄ) ^ nrComplexPlaces K * (finrank ‚Ñö K).factorial *\n          Real.sqrt |discr K| := by\n      rw [Int.norm_eq_abs, zpow_mul, show (2 : ‚Ñù) ^ (2 : ‚Ñ§) = 4 by norm_cast, div_pow,\n        inv_eq_one_div, div_pow, one_pow, zpow_natCast]\n      ring\n\n"}
{"name":"NumberField.exists_ne_zero_mem_ringOfIntegers_of_norm_le_mul_sqrt_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Exists fun a => And (Ne a 0) (LE.le (‚Üë(abs ((Algebra.norm Rat) ‚Üëa))) (HMul.hMul (HDiv.hDiv (HMul.hMul (HPow.hPow (HDiv.hDiv 4 Real.pi) (NumberField.InfinitePlace.nrComplexPlaces K)) ‚Üë(Module.finrank Rat K).factorial) (HPow.hPow (‚Üë(Module.finrank Rat K)) (Module.finrank Rat K))) (abs ‚Üë(NumberField.discr K)).sqrt))","decl":"theorem exists_ne_zero_mem_ringOfIntegers_of_norm_le_mul_sqrt_discr :\n    ‚àÉ (a : ùìû K), a ‚â† 0 ‚àß\n      |Algebra.norm ‚Ñö (a : K)| ‚â§ (4 / œÄ) ^ nrComplexPlaces K *\n        (finrank ‚Ñö K).factorial / (finrank ‚Ñö K) ^ (finrank ‚Ñö K) * Real.sqrt |discr K| := by\n  obtain ‚ü®_, h_mem, h_nz, h_nm‚ü© := exists_ne_zero_mem_ideal_of_norm_le_mul_sqrt_discr K ‚Üë1\n  obtain ‚ü®a, rfl‚ü© := (FractionalIdeal.mem_one_iff _).mp h_mem\n  refine ‚ü®a, ne_zero_of_map h_nz, ?_‚ü©\n  simp_rw [Units.val_one, FractionalIdeal.absNorm_one, Rat.cast_one, one_mul] at h_nm\n  exact h_nm\n\n"}
{"name":"NumberField.abs_discr_ge","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nh : LT.lt 1 (Module.finrank Rat K)\n‚ä¢ LE.le (HMul.hMul (4 / 9) (HPow.hPow (HDiv.hDiv (HMul.hMul 3 Real.pi) 4) (Module.finrank Rat K))) ‚Üë(abs (NumberField.discr K))","decl":"theorem abs_discr_ge (h : 1 < finrank ‚Ñö K) :\n    (4 / 9 : ‚Ñù) * (3 * œÄ / 4) ^ finrank ‚Ñö K ‚â§ |discr K| := by\n  -- We use `exists_ne_zero_mem_ringOfIntegers_of_norm_le_mul_sqrt_discr` to get a nonzero\n  -- algebraic integer `x` of small norm and the fact that `1 ‚â§ |Norm x|` to get a lower bound\n  -- on `sqrt |discr K|`.\n  obtain ‚ü®x, h_nz, h_bd‚ü© := exists_ne_zero_mem_ringOfIntegers_of_norm_le_mul_sqrt_discr K\n  have h_nm : (1 : ‚Ñù) ‚â§ |Algebra.norm ‚Ñö (x : K)| := by\n    rw [‚Üê Algebra.coe_norm_int, ‚Üê Int.cast_one, ‚Üê Int.cast_abs, Rat.cast_intCast, Int.cast_le]\n    exact Int.one_le_abs (Algebra.norm_ne_zero_iff.mpr h_nz)\n  replace h_bd := le_trans h_nm h_bd\n  rw [‚Üê inv_mul_le_iff‚ÇÄ (by positivity), inv_div, mul_one, Real.le_sqrt (by positivity)\n    (by positivity), ‚Üê Int.cast_abs, div_pow, mul_pow, ‚Üê pow_mul, ‚Üê pow_mul] at h_bd\n  refine le_trans ?_ h_bd\n  -- The sequence `a n` is a lower bound for `|discr K|`. We prove below by induction an uniform\n  -- lower bound for this sequence from which we deduce the result.\n  let a : ‚Ñï ‚Üí ‚Ñù := fun n => (n : ‚Ñù) ^ (n * 2) / ((4 / œÄ) ^ n * (n.factorial : ‚Ñù) ^ 2)\n  suffices ‚àÄ n, 2 ‚â§ n ‚Üí (4 / 9 : ‚Ñù) * (3 * œÄ / 4) ^ n ‚â§ a n by\n    refine le_trans (this (finrank ‚Ñö K) h) ?_\n    simp only [a]\n    gcongr\n    ¬∑ exact (one_le_div Real.pi_pos).2 Real.pi_le_four\n    ¬∑ rw [‚Üê card_add_two_mul_card_eq_rank, mul_comm]\n      exact Nat.le_add_left _ _\n  intro n hn\n  induction n, hn using Nat.le_induction with\n  | base => exact le_of_eq <| by norm_num [a, Nat.factorial_two]; field_simp; ring\n  | succ m _ h_m =>\n      suffices (3 : ‚Ñù) ‚â§ (1 + 1 / m : ‚Ñù) ^ (2 * m) by\n        convert_to _ ‚â§ (a m) * (1 + 1 / m : ‚Ñù) ^ (2 * m) / (4 / œÄ)\n        ¬∑ simp_rw [a, add_mul, one_mul, pow_succ, Nat.factorial_succ]\n          field_simp; ring\n        ¬∑ rw [_root_.le_div_iff‚ÇÄ (by positivity), pow_succ]\n          convert (mul_le_mul h_m this (by positivity) (by positivity)) using 1\n          field_simp; ring\n      refine le_trans (le_of_eq (by field_simp; norm_num)) (one_add_mul_le_pow ?_ (2 * m))\n      exact le_trans (by norm_num : (-2 : ‚Ñù) ‚â§ 0) (by positivity)\n\n"}
{"name":"NumberField.abs_discr_gt_two","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nh : LT.lt 1 (Module.finrank Rat K)\n‚ä¢ LT.lt 2 (abs (NumberField.discr K))","decl":"/-- **Hermite-Minkowski Theorem**. A nontrivial number field has discriminant greater than `2`. -/\ntheorem abs_discr_gt_two (h : 1 < finrank ‚Ñö K) : 2 < |discr K| := by\n  rw [‚Üê Nat.succ_le_iff] at h\n  rify\n  calc\n    (2 : ‚Ñù) < (4 / 9) * (3 * œÄ / 4) ^ 2 := by\n      nlinarith [Real.pi_gt_three]\n    _ ‚â§ (4 / 9 : ‚Ñù) * (3 * œÄ / 4) ^ finrank ‚Ñö K := by\n      gcongr\n      linarith [Real.pi_gt_three]\n    _ ‚â§ |(discr K : ‚Ñù)| := mod_cast abs_discr_ge h\n\n"}
{"name":"NumberField.hermiteTheorem.finite_of_finite_generating_set","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : Field A\ninst‚úù : CharZero A\np : IntermediateField Rat A ‚Üí Prop\nS : Set (Subtype fun F => p F)\nT : Set A\nhT : T.Finite\nh : ‚àÄ (F : Subtype fun F => p F), Membership.mem S F ‚Üí Exists fun x => And (Membership.mem T x) (Eq (‚ÜëF) (IntermediateField.adjoin Rat (Singleton.singleton x)))\n‚ä¢ S.Finite","decl":"theorem finite_of_finite_generating_set {p : IntermediateField ‚Ñö A ‚Üí Prop}\n    (S : Set {F : IntermediateField ‚Ñö A // p F}) {T : Set A}\n    (hT : T.Finite) (h : ‚àÄ F ‚àà S, ‚àÉ x ‚àà T, F = ‚Ñö‚üÆx‚üØ) :\n    S.Finite := by\n  rw [‚Üê Set.finite_coe_iff] at hT\n  refine Set.finite_coe_iff.mp <| Finite.of_injective\n    (fun ‚ü®F, hF‚ü© ‚Ü¶ (‚ü®(h F hF).choose, (h F hF).choose_spec.1‚ü© : T)) (fun _ _ h_eq ‚Ü¶ ?_)\n  rw [Subtype.ext_iff_val, Subtype.ext_iff_val]\n  convert congr_arg (‚Ñö‚üÆ¬∑‚üØ) (Subtype.mk_eq_mk.mp h_eq)\n  all_goals exact (h _ (Subtype.mem _)).choose_spec.2\n\n"}
{"name":"NumberField.hermiteTheorem.rank_le_rankOfDiscrBdd","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nN : Nat\nhK : LE.le (abs (NumberField.discr K)) ‚ÜëN\n‚ä¢ LE.le (Module.finrank Rat K) (NumberField.hermiteTheorem.rankOfDiscrBdd N)","decl":"include hK in\n/-- If `|discr K| ‚â§ N` then the degree of `K` is at most `rankOfDiscrBdd`. -/\ntheorem rank_le_rankOfDiscrBdd :\n    finrank ‚Ñö K ‚â§ rankOfDiscrBdd N := by\n  have h_nz : N ‚â† 0 := by\n    refine fun h ‚Ü¶ discr_ne_zero K ?_\n    rwa [h, Nat.cast_zero, abs_nonpos_iff] at hK\n  have h‚ÇÇ : 1 < 3 * œÄ / 4 := by\n    rw [_root_.lt_div_iff‚ÇÄ (by positivity), ‚Üê _root_.div_lt_iff‚ÇÄ' (by positivity), one_mul]\n    linarith [Real.pi_gt_three]\n  obtain h | h := lt_or_le 1 (finrank ‚Ñö K)\n  ¬∑ apply le_max_of_le_right\n    rw [Nat.le_floor_iff]\n    ¬∑ have h := le_trans (abs_discr_ge h) (Int.cast_le.mpr hK)\n      contrapose! h\n      rw [‚Üê Real.rpow_natCast]\n      rw [Real.log_div_log] at h\n      refine lt_of_le_of_lt ?_ (mul_lt_mul_of_pos_left\n        (Real.rpow_lt_rpow_of_exponent_lt h‚ÇÇ h) (by positivity : (0 : ‚Ñù) < 4 / 9))\n      rw [Real.rpow_logb (lt_trans zero_lt_one h‚ÇÇ) (ne_of_gt h‚ÇÇ) (by positivity), ‚Üê mul_assoc,\n            ‚Üê inv_div, inv_mul_cancel‚ÇÄ (by norm_num), one_mul, Int.cast_natCast]\n    ¬∑ refine div_nonneg (Real.log_nonneg ?_) (Real.log_nonneg (le_of_lt h‚ÇÇ))\n      rw [mul_comm, ‚Üê mul_div_assoc, _root_.le_div_iff‚ÇÄ (by positivity), one_mul,\n        ‚Üê _root_.div_le_iff‚ÇÄ (by positivity)]\n      exact le_trans (by norm_num) (Nat.one_le_cast.mpr (Nat.one_le_iff_ne_zero.mpr h_nz))\n  ¬∑ exact le_max_of_le_left h\n\n"}
{"name":"NumberField.hermiteTheorem.minkowskiBound_lt_boundOfDiscBdd","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nN : Nat\nhK : LE.le (abs (NumberField.discr K)) ‚ÜëN\n‚ä¢ LT.lt (NumberField.mixedEmbedding.minkowskiBound K 1) ‚Üë(NumberField.hermiteTheorem.boundOfDiscBdd N)","decl":"include hK in\n/-- If `|discr K| ‚â§ N` then the Minkowski bound of `K` is less than `boundOfDiscrBdd`. -/\ntheorem minkowskiBound_lt_boundOfDiscBdd : minkowskiBound K ‚Üë1 < boundOfDiscBdd N := by\n  have : boundOfDiscBdd N - 1 < boundOfDiscBdd N := by\n    simp_rw [boundOfDiscBdd, add_tsub_cancel_right, lt_add_iff_pos_right, zero_lt_one]\n  refine lt_of_le_of_lt ?_ (coe_lt_coe.mpr this)\n  rw [minkowskiBound, volume_fundamentalDomain_fractionalIdealLatticeBasis, boundOfDiscBdd,\n    add_tsub_cancel_right, Units.val_one, FractionalIdeal.absNorm_one, Rat.cast_one,\n    ENNReal.ofReal_one, one_mul, mixedEmbedding.finrank, volume_fundamentalDomain_latticeBasis,\n    coe_mul, ENNReal.coe_pow, coe_ofNat, show sqrt N = (1 : ‚Ñù‚â•0‚àû) * sqrt N by rw [one_mul]]\n  gcongr\n  ¬∑ exact pow_le_one‚ÇÄ (by positivity) (by norm_num)\n  ¬∑ rwa [‚Üê NNReal.coe_le_coe, coe_nnnorm, Int.norm_eq_abs, ‚Üê Int.cast_abs,\n      NNReal.coe_natCast, ‚Üê Int.cast_natCast, Int.cast_le]\n  ¬∑ exact one_le_two\n  ¬∑ exact rank_le_rankOfDiscrBdd hK\n\n"}
{"name":"NumberField.hermiteTheorem.natDegree_le_rankOfDiscrBdd","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nN : Nat\nhK : LE.le (abs (NumberField.discr K)) ‚ÜëN\na : NumberField.RingOfIntegers K\nh : Eq (IntermediateField.adjoin Rat (Singleton.singleton ‚Üëa)) Top.top\n‚ä¢ LE.le (minpoly Int ‚Üëa).natDegree (NumberField.hermiteTheorem.rankOfDiscrBdd N)","decl":"include hK in\ntheorem natDegree_le_rankOfDiscrBdd (a : ùìû K) (h : ‚Ñö‚üÆ(a : K)‚üØ = ‚ä§) :\n    natDegree (minpoly ‚Ñ§ (a : K)) ‚â§ rankOfDiscrBdd N := by\n  rw [Field.primitive_element_iff_minpoly_natDegree_eq,\n    minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö a.isIntegral_coe,\n    (minpoly.monic a.isIntegral_coe).natDegree_map] at h\n  exact h.symm ‚ñ∏ rank_le_rankOfDiscrBdd hK\n\n"}
{"name":"NumberField.hermiteTheorem.finite_of_discr_bdd_of_isReal","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : Field A\ninst‚úù : CharZero A\nN : Nat\n‚ä¢ (setOf fun K => And (setOf fun w => w.IsReal).Nonempty (LE.le (abs (NumberField.discr (Subtype fun x => Membership.mem (‚ÜëK) x))) ‚ÜëN)).Finite","decl":"theorem finite_of_discr_bdd_of_isReal :\n    {K : { F : IntermediateField ‚Ñö A // FiniteDimensional ‚Ñö F} |\n      haveI :  NumberField K := @NumberField.mk _ _ inferInstance K.prop\n      {w : InfinitePlace K | IsReal w}.Nonempty ‚àß |discr K| ‚â§ N }.Finite := by\n  classical\n  -- The bound on the degree of the generating polynomials\n  let D := rankOfDiscrBdd N\n  -- The bound on the Minkowski bound\n  let B := boundOfDiscBdd N\n  -- The bound on the coefficients of the generating polynomials\n  let C := Nat.ceil ((max B 1) ^ D *  Nat.choose D (D / 2))\n  refine finite_of_finite_generating_set A _ (bUnion_roots_finite (algebraMap ‚Ñ§ A) D\n      (Set.finite_Icc (-C : ‚Ñ§) C)) (fun ‚ü®K, hK‚ÇÄ‚ü© ‚ü®hK‚ÇÅ, hK‚ÇÇ‚ü© ‚Ü¶ ?_)\n  -- We now need to prove that each field is generated by an element of the union of the rootset\n  simp_rw [Set.mem_iUnion]\n  -- this is purely an optimization\n  have : CharZero K := SubsemiringClass.instCharZero K\n  haveI : NumberField K := @NumberField.mk _ _ inferInstance hK‚ÇÄ\n  obtain ‚ü®w‚ÇÄ, hw‚ÇÄ‚ü© := hK‚ÇÅ\n  suffices minkowskiBound K ‚Üë1 < (convexBodyLTFactor K) * B by\n    obtain ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© := exists_primitive_element_lt_of_isReal K hw‚ÇÄ this\n    have hx := x.isIntegral_coe\n    refine ‚ü®x, ‚ü®‚ü®minpoly ‚Ñ§ (x : K), ‚ü®?_, fun i ‚Ü¶ ?_‚ü©, ?_‚ü©, ?_‚ü©‚ü©\n    ¬∑ exact natDegree_le_rankOfDiscrBdd hK‚ÇÇ x hx‚ÇÅ\n    ¬∑ rw [Set.mem_Icc, ‚Üê abs_le, ‚Üê @Int.cast_le ‚Ñù]\n      refine (Eq.trans_le ?_ <| Embeddings.coeff_bdd_of_norm_le\n          ((le_iff_le (x : K) _).mp (fun w ‚Ü¶ le_of_lt (hx‚ÇÇ w))) i).trans ?_\n      ¬∑ rw [minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hx, coeff_map, eq_intCast,\n          Int.norm_cast_rat, Int.norm_eq_abs, Int.cast_abs]\n      ¬∑ refine le_trans ?_ (Nat.le_ceil _)\n        rw [show max ‚Üë(max (B : ‚Ñù‚â•0) 1) (1 : ‚Ñù) = max (B : ‚Ñù) 1 by simp, val_eq_coe, NNReal.coe_mul,\n          NNReal.coe_pow, NNReal.coe_max, NNReal.coe_one, NNReal.coe_natCast]\n        gcongr\n        ¬∑ exact le_max_right _ 1\n        ¬∑ exact rank_le_rankOfDiscrBdd hK‚ÇÇ\n        ¬∑ exact (Nat.choose_le_choose _ (rank_le_rankOfDiscrBdd hK‚ÇÇ)).trans\n            (Nat.choose_le_middle _ _)\n    ¬∑ refine mem_rootSet.mpr ‚ü®minpoly.ne_zero hx, ?_‚ü©\n      exact (aeval_algebraMap_eq_zero_iff A (x : K) _).mpr (minpoly.aeval ‚Ñ§ (x : K))\n    ¬∑ rw [‚Üê (IntermediateField.lift_injective _).eq_iff, eq_comm] at hx‚ÇÅ\n      convert hx‚ÇÅ\n      ¬∑ simp only [IntermediateField.lift_top]\n      ¬∑ simp only [IntermediateField.lift_adjoin, Set.image_singleton]\n  calc\n    minkowskiBound K 1 < B := minkowskiBound_lt_boundOfDiscBdd hK‚ÇÇ\n    _ = 1 * B := by rw [one_mul]\n    _ ‚â§ convexBodyLTFactor K * B := by gcongr; exact mod_cast one_le_convexBodyLTFactor K\n\n"}
{"name":"NumberField.hermiteTheorem.finite_of_discr_bdd_of_isComplex","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : Field A\ninst‚úù : CharZero A\nN : Nat\n‚ä¢ (setOf fun K => And (setOf fun w => w.IsComplex).Nonempty (LE.le (abs (NumberField.discr (Subtype fun x => Membership.mem (‚ÜëK) x))) ‚ÜëN)).Finite","decl":"theorem finite_of_discr_bdd_of_isComplex :\n    {K : { F : IntermediateField ‚Ñö A // FiniteDimensional ‚Ñö F} |\n      haveI :  NumberField K := @NumberField.mk _ _ inferInstance K.prop\n      {w : InfinitePlace K | IsComplex w}.Nonempty ‚àß |discr K| ‚â§ N }.Finite := by\n  classical\n  -- The bound on the degree of the generating polynomials\n  let D := rankOfDiscrBdd N\n  -- The bound on the Minkowski bound\n  let B := boundOfDiscBdd N\n  -- The bound on the coefficients of the generating polynomials\n  let C := Nat.ceil ((max (sqrt (1 + B ^ 2)) 1) ^ D * Nat.choose D (D / 2))\n  refine finite_of_finite_generating_set A _ (bUnion_roots_finite (algebraMap ‚Ñ§ A) D\n      (Set.finite_Icc (-C : ‚Ñ§) C)) (fun ‚ü®K, hK‚ÇÄ‚ü© ‚ü®hK‚ÇÅ, hK‚ÇÇ‚ü© ‚Ü¶ ?_)\n  -- We now need to prove that each field is generated by an element of the union of the rootset\n  simp_rw [Set.mem_iUnion]\n  -- this is purely an optimization\n  have : CharZero K := SubsemiringClass.instCharZero K\n  haveI : NumberField K := @NumberField.mk _ _ inferInstance hK‚ÇÄ\n  obtain ‚ü®w‚ÇÄ, hw‚ÇÄ‚ü© := hK‚ÇÅ\n  suffices minkowskiBound K ‚Üë1 < (convexBodyLT'Factor K) * boundOfDiscBdd N by\n    obtain ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© := exists_primitive_element_lt_of_isComplex K hw‚ÇÄ this\n    have hx := x.isIntegral_coe\n    refine ‚ü®x, ‚ü®‚ü®minpoly ‚Ñ§ (x : K), ‚ü®?_, fun i ‚Ü¶ ?_‚ü©, ?_‚ü©, ?_‚ü©‚ü©\n    ¬∑ exact natDegree_le_rankOfDiscrBdd hK‚ÇÇ x hx‚ÇÅ\n    ¬∑ rw [Set.mem_Icc, ‚Üê abs_le, ‚Üê @Int.cast_le ‚Ñù]\n      refine (Eq.trans_le ?_ <| Embeddings.coeff_bdd_of_norm_le\n          ((le_iff_le (x : K) _).mp (fun w ‚Ü¶ le_of_lt (hx‚ÇÇ w))) i).trans ?_\n      ¬∑ rw [minpoly.isIntegrallyClosed_eq_field_fractions' ‚Ñö hx, coeff_map, eq_intCast,\n          Int.norm_cast_rat, Int.norm_eq_abs, Int.cast_abs]\n      ¬∑ refine le_trans ?_ (Nat.le_ceil _)\n        rw [val_eq_coe, NNReal.coe_mul, NNReal.coe_pow, NNReal.coe_max, NNReal.coe_one,\n          Real.coe_sqrt, NNReal.coe_add 1, NNReal.coe_one, NNReal.coe_pow]\n        gcongr\n        ¬∑ exact le_max_right _ 1\n        ¬∑ exact rank_le_rankOfDiscrBdd hK‚ÇÇ\n        ¬∑ rw [NNReal.coe_natCast, Nat.cast_le]\n          exact (Nat.choose_le_choose _ (rank_le_rankOfDiscrBdd hK‚ÇÇ)).trans\n            (Nat.choose_le_middle _ _)\n    ¬∑ refine mem_rootSet.mpr ‚ü®minpoly.ne_zero hx, ?_‚ü©\n      exact (aeval_algebraMap_eq_zero_iff A (x : K) _).mpr (minpoly.aeval ‚Ñ§ (x : K))\n    ¬∑ rw [‚Üê (IntermediateField.lift_injective _).eq_iff, eq_comm] at hx‚ÇÅ\n      convert hx‚ÇÅ\n      ¬∑ simp only [IntermediateField.lift_top]\n      ¬∑ simp only [IntermediateField.lift_adjoin, Set.image_singleton]\n  calc\n    minkowskiBound K 1 < B := minkowskiBound_lt_boundOfDiscBdd hK‚ÇÇ\n    _ = 1 * B := by rw [one_mul]\n    _ ‚â§ convexBodyLT'Factor K * B := by gcongr; exact mod_cast one_le_convexBodyLT'Factor K\n\n"}
{"name":"NumberField.finite_of_discr_bdd","module":"Mathlib.NumberTheory.NumberField.Discriminant.Basic","initialProofState":"A : Type u_2\ninst‚úù¬π : Field A\ninst‚úù : CharZero A\nN : Nat\n‚ä¢ (setOf fun K => LE.le (abs (NumberField.discr (Subtype fun x => Membership.mem (‚ÜëK) x))) ‚ÜëN).Finite","decl":"/-- **Hermite Theorem**. Let `N` be an integer. There are only finitely many number fields\n(in some fixed extension of `‚Ñö`) of discriminant bounded by `N`. -/\ntheorem _root_.NumberField.finite_of_discr_bdd :\n    {K : { F : IntermediateField ‚Ñö A // FiniteDimensional ‚Ñö F} |\n      haveI :  NumberField K := @NumberField.mk _ _ inferInstance K.prop\n      |discr K| ‚â§ N }.Finite := by\n  refine Set.Finite.subset (Set.Finite.union (finite_of_discr_bdd_of_isReal A N)\n    (finite_of_discr_bdd_of_isComplex A N)) ?_\n  rintro ‚ü®K, hK‚ÇÄ‚ü© hK‚ÇÅ\n  -- this is purely an optimization\n  have : CharZero K := SubsemiringClass.instCharZero K\n  haveI : NumberField K := @NumberField.mk _ _ inferInstance hK‚ÇÄ\n  obtain ‚ü®w‚ÇÄ‚ü© := (inferInstance : Nonempty (InfinitePlace K))\n  by_cases hw‚ÇÄ : IsReal w‚ÇÄ\n  ¬∑ apply Set.mem_union_left\n    exact ‚ü®‚ü®w‚ÇÄ, hw‚ÇÄ‚ü©, hK‚ÇÅ‚ü©\n  ¬∑ apply Set.mem_union_right\n    exact ‚ü®‚ü®w‚ÇÄ, not_isReal_iff_isComplex.mp hw‚ÇÄ‚ü©, hK‚ÇÅ‚ü©\n\n"}
