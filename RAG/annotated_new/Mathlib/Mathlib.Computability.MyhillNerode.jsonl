{"name":"Language.leftQuotient_nil","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\n⊢ Eq (L.leftQuotient List.nil) L","decl":"variable (L) in\n@[simp]\ntheorem leftQuotient_nil : L.leftQuotient [] = L := rfl\n\n"}
{"name":"Language.leftQuotient_append","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\nx y : List α\n⊢ Eq (L.leftQuotient (HAppend.hAppend x y)) ((L.leftQuotient x).leftQuotient y)","decl":"variable (L) in\ntheorem leftQuotient_append (x y : List α) :\n    L.leftQuotient (x ++ y) = (L.leftQuotient x).leftQuotient y := by\n  simp [leftQuotient, Language]\n\n"}
{"name":"Language.mem_leftQuotient","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\nx y : List α\n⊢ Iff (Membership.mem (L.leftQuotient x) y) (Membership.mem L (HAppend.hAppend x y))","decl":"@[simp]\ntheorem mem_leftQuotient (x y : List α) : y ∈ L.leftQuotient x ↔ x ++ y ∈ L := Iff.rfl\n\n"}
{"name":"Language.leftQuotient_accepts_apply","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\nx : List α\n⊢ Eq (M.accepts.leftQuotient x) (M.acceptsFrom (M.eval x))","decl":"theorem leftQuotient_accepts_apply (M : DFA α σ) (x : List α) :\n    leftQuotient M.accepts x = M.acceptsFrom (M.eval x) := by\n  ext y\n  simp [DFA.mem_accepts, DFA.mem_acceptsFrom, DFA.eval, DFA.evalFrom_of_append]\n\n"}
{"name":"Language.leftQuotient_accepts","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nσ : Type v\nM : DFA α σ\n⊢ Eq M.accepts.leftQuotient (Function.comp M.acceptsFrom M.eval)","decl":"theorem leftQuotient_accepts (M : DFA α σ) : leftQuotient M.accepts = M.acceptsFrom ∘ M.eval :=\n  funext <| leftQuotient_accepts_apply M\n\n"}
{"name":"Language.IsRegular.finite_range_leftQuotient","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\nh : L.IsRegular\n⊢ (Set.range L.leftQuotient).Finite","decl":"theorem IsRegular.finite_range_leftQuotient (h : L.IsRegular) :\n    (Set.range L.leftQuotient).Finite := by\n  have ⟨σ, x, M, hM⟩ := h\n  rw [← hM, leftQuotient_accepts]\n  exact Set.finite_of_finite_preimage (Set.toFinite _)\n    (Set.range_comp_subset_range M.eval M.acceptsFrom)\n\n"}
{"name":"Language.mem_accept_toDFA","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\ns : ↑(Set.range L.leftQuotient)\n⊢ Iff (Membership.mem L.toDFA.accept s) (Membership.mem (↑s) List.nil)","decl":"@[simp]\ntheorem mem_accept_toDFA (s : Set.range L.leftQuotient) : s ∈ L.toDFA.accept ↔ [] ∈ s.val := Iff.rfl\n\n"}
{"name":"Language.step_toDFA","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\ns : ↑(Set.range L.leftQuotient)\na : α\n⊢ Eq (↑(L.toDFA.step s a)) ((↑s).leftQuotient (List.cons a List.nil))","decl":"@[simp]\ntheorem step_toDFA (s : Set.range L.leftQuotient) (a : α) :\n    (L.toDFA.step s a).val = s.val.leftQuotient [a] := rfl\n\n"}
{"name":"Language.start_toDFA","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\n⊢ Eq (↑L.toDFA.start) L","decl":"variable (L) in\n@[simp]\ntheorem start_toDFA : L.toDFA.start.val = L := rfl\n\n"}
{"name":"Language.accepts_toDFA","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\n⊢ Eq L.toDFA.accepts L","decl":"variable (L) in\n@[simp]\ntheorem accepts_toDFA : L.toDFA.accepts = L := by\n  ext x\n  rw [DFA.mem_accepts]\n  suffices L.toDFA.eval x = L.leftQuotient x by simp [this]\n  induction x using List.reverseRecOn with\n  | nil => simp\n  | append_singleton x a ih => simp [ih, leftQuotient_append]\n\n"}
{"name":"Language.IsRegular.of_finite_range_leftQuotient","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\nh : (Set.range L.leftQuotient).Finite\n⊢ L.IsRegular","decl":"theorem IsRegular.of_finite_range_leftQuotient (h : Set.Finite (Set.range L.leftQuotient)) :\n    L.IsRegular :=\n  Language.isRegular_iff.mpr ⟨_, h.fintype, L.toDFA, by simp⟩\n\n"}
{"name":"Language.isRegular_iff_finite_range_leftQuotient","module":"Mathlib.Computability.MyhillNerode","initialProofState":"α : Type u\nL : Language α\n⊢ Iff L.IsRegular (Set.range L.leftQuotient).Finite","decl":"/--\n**Myhill–Nerode theorem**. A language is regular if and only if the set of left quotients is finite.\n-/\ntheorem isRegular_iff_finite_range_leftQuotient :\n    L.IsRegular ↔ (Set.range L.leftQuotient).Finite :=\n  ⟨IsRegular.finite_range_leftQuotient, .of_finite_range_leftQuotient⟩\n\n"}
