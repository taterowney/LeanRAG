{"name":"ContinuousLinearEquiv.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ HasStrictFDerivAt (⇑iso) (↑iso) x","decl":"@[fun_prop]\nprotected theorem hasStrictFDerivAt : HasStrictFDerivAt iso (iso : E →L[𝕜] F) x :=\n  iso.toContinuousLinearMap.hasStrictFDerivAt\n\n"}
{"name":"ContinuousLinearEquiv.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ HasFDerivWithinAt (⇑iso) (↑iso) s x","decl":"@[fun_prop]\nprotected theorem hasFDerivWithinAt : HasFDerivWithinAt iso (iso : E →L[𝕜] F) s x :=\n  iso.toContinuousLinearMap.hasFDerivWithinAt\n\n"}
{"name":"ContinuousLinearEquiv.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ HasFDerivAt (⇑iso) (↑iso) x","decl":"@[fun_prop]\nprotected theorem hasFDerivAt : HasFDerivAt iso (iso : E →L[𝕜] F) x :=\n  iso.toContinuousLinearMap.hasFDerivAtFilter\n\n"}
{"name":"ContinuousLinearEquiv.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableAt 𝕜 (⇑iso) x","decl":"@[fun_prop]\nprotected theorem differentiableAt : DifferentiableAt 𝕜 iso x :=\n  iso.hasFDerivAt.differentiableAt\n\n"}
{"name":"ContinuousLinearEquiv.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableWithinAt 𝕜 (⇑iso) s x","decl":"@[fun_prop]\nprotected theorem differentiableWithinAt : DifferentiableWithinAt 𝕜 iso s x :=\n  iso.differentiableAt.differentiableWithinAt\n\n"}
{"name":"ContinuousLinearEquiv.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ Eq (fderiv 𝕜 (⇑iso) x) ↑iso","decl":"protected theorem fderiv : fderiv 𝕜 iso x = iso :=\n  iso.hasFDerivAt.fderiv\n\n"}
{"name":"ContinuousLinearEquiv.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (⇑iso) s x) ↑iso","decl":"protected theorem fderivWithin (hxs : UniqueDiffWithinAt 𝕜 s x) : fderivWithin 𝕜 iso s x = iso :=\n  iso.toContinuousLinearMap.fderivWithin hxs\n\n"}
{"name":"ContinuousLinearEquiv.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ Differentiable 𝕜 ⇑iso","decl":"@[fun_prop]\nprotected theorem differentiable : Differentiable 𝕜 iso := fun _ => iso.differentiableAt\n\n"}
{"name":"ContinuousLinearEquiv.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableOn 𝕜 (⇑iso) s","decl":"@[fun_prop]\nprotected theorem differentiableOn : DifferentiableOn 𝕜 iso s :=\n  iso.differentiable.differentiableOn\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\n⊢ Iff (DifferentiableWithinAt 𝕜 (Function.comp (⇑iso) f) s x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem comp_differentiableWithinAt_iff {f : G → E} {s : Set G} {x : G} :\n    DifferentiableWithinAt 𝕜 (iso ∘ f) s x ↔ DifferentiableWithinAt 𝕜 f s x := by\n  refine\n    ⟨fun H => ?_, fun H => iso.differentiable.differentiableAt.comp_differentiableWithinAt x H⟩\n  have : DifferentiableWithinAt 𝕜 (iso.symm ∘ iso ∘ f) s x :=\n    iso.symm.differentiable.differentiableAt.comp_differentiableWithinAt x H\n  rwa [← Function.comp_assoc iso.symm iso f, iso.symm_comp_self] at this\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\n⊢ Iff (DifferentiableAt 𝕜 (Function.comp (⇑iso) f) x) (DifferentiableAt 𝕜 f x)","decl":"theorem comp_differentiableAt_iff {f : G → E} {x : G} :\n    DifferentiableAt 𝕜 (iso ∘ f) x ↔ DifferentiableAt 𝕜 f x := by\n  rw [← differentiableWithinAt_univ, ← differentiableWithinAt_univ,\n    iso.comp_differentiableWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\n⊢ Iff (DifferentiableOn 𝕜 (Function.comp (⇑iso) f) s) (DifferentiableOn 𝕜 f s)","decl":"theorem comp_differentiableOn_iff {f : G → E} {s : Set G} :\n    DifferentiableOn 𝕜 (iso ∘ f) s ↔ DifferentiableOn 𝕜 f s := by\n  rw [DifferentiableOn, DifferentiableOn]\n  simp only [iso.comp_differentiableWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\n⊢ Iff (Differentiable 𝕜 (Function.comp (⇑iso) f)) (Differentiable 𝕜 f)","decl":"theorem comp_differentiable_iff {f : G → E} : Differentiable 𝕜 (iso ∘ f) ↔ Differentiable 𝕜 f := by\n  rw [← differentiableOn_univ, ← differentiableOn_univ]\n  exact iso.comp_differentiableOn_iff\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasFDerivWithinAt (Function.comp (⇑iso) f) ((↑iso).comp f') s x) (HasFDerivWithinAt f f' s x)","decl":"theorem comp_hasFDerivWithinAt_iff {f : G → E} {s : Set G} {x : G} {f' : G →L[𝕜] E} :\n    HasFDerivWithinAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') s x ↔ HasFDerivWithinAt f f' s x := by\n  refine ⟨fun H => ?_, fun H => iso.hasFDerivAt.comp_hasFDerivWithinAt x H⟩\n  have A : f = iso.symm ∘ iso ∘ f := by\n    rw [← Function.comp_assoc, iso.symm_comp_self]\n    rfl\n  have B : f' = (iso.symm : F →L[𝕜] E).comp ((iso : E →L[𝕜] F).comp f') := by\n    rw [← ContinuousLinearMap.comp_assoc, iso.coe_symm_comp_coe, ContinuousLinearMap.id_comp]\n  rw [A, B]\n  exact iso.symm.hasFDerivAt.comp_hasFDerivWithinAt x H\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasStrictFDerivAt (Function.comp (⇑iso) f) ((↑iso).comp f') x) (HasStrictFDerivAt f f' x)","decl":"theorem comp_hasStrictFDerivAt_iff {f : G → E} {x : G} {f' : G →L[𝕜] E} :\n    HasStrictFDerivAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') x ↔ HasStrictFDerivAt f f' x := by\n  refine ⟨fun H => ?_, fun H => iso.hasStrictFDerivAt.comp x H⟩\n  convert iso.symm.hasStrictFDerivAt.comp x H using 1 <;>\n    ext z <;> apply (iso.symm_apply_apply _).symm\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasFDerivAt (Function.comp (⇑iso) f) ((↑iso).comp f') x) (HasFDerivAt f f' x)","decl":"theorem comp_hasFDerivAt_iff {f : G → E} {x : G} {f' : G →L[𝕜] E} :\n    HasFDerivAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') x ↔ HasFDerivAt f f' x := by\n  simp_rw [← hasFDerivWithinAt_univ, iso.comp_hasFDerivWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G F\n⊢ Iff (HasFDerivWithinAt (Function.comp (⇑iso) f) f' s x) (HasFDerivWithinAt f ((↑iso.symm).comp f') s x)","decl":"theorem comp_hasFDerivWithinAt_iff' {f : G → E} {s : Set G} {x : G} {f' : G →L[𝕜] F} :\n    HasFDerivWithinAt (iso ∘ f) f' s x ↔\n      HasFDerivWithinAt f ((iso.symm : F →L[𝕜] E).comp f') s x := by\n  rw [← iso.comp_hasFDerivWithinAt_iff, ← ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm,\n    ContinuousLinearMap.id_comp]\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G F\n⊢ Iff (HasFDerivAt (Function.comp (⇑iso) f) f' x) (HasFDerivAt f ((↑iso.symm).comp f') x)","decl":"theorem comp_hasFDerivAt_iff' {f : G → E} {x : G} {f' : G →L[𝕜] F} :\n    HasFDerivAt (iso ∘ f) f' x ↔ HasFDerivAt f ((iso.symm : F →L[𝕜] E).comp f') x := by\n  simp_rw [← hasFDerivWithinAt_univ, iso.comp_hasFDerivWithinAt_iff']\n\n"}
{"name":"ContinuousLinearEquiv.comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (Function.comp (⇑iso) f) s x) ((↑iso).comp (fderivWithin 𝕜 f s x))","decl":"theorem comp_fderivWithin {f : G → E} {s : Set G} {x : G} (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (iso ∘ f) s x = (iso : E →L[𝕜] F).comp (fderivWithin 𝕜 f s x) := by\n  by_cases h : DifferentiableWithinAt 𝕜 f s x\n  · rw [fderiv_comp_fderivWithin x iso.differentiableAt h hxs, iso.fderiv]\n  · have : ¬DifferentiableWithinAt 𝕜 (iso ∘ f) s x := mt iso.comp_differentiableWithinAt_iff.1 h\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h,\n      fderivWithin_zero_of_not_differentiableWithinAt this, ContinuousLinearMap.comp_zero]\n\n"}
{"name":"ContinuousLinearEquiv.comp_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\n⊢ Eq (fderiv 𝕜 (Function.comp (⇑iso) f) x) ((↑iso).comp (fderiv 𝕜 f x))","decl":"theorem comp_fderiv {f : G → E} {x : G} :\n    fderiv 𝕜 (iso ∘ f) x = (iso : E →L[𝕜] F).comp (fderiv 𝕜 f x) := by\n  rw [← fderivWithin_univ, ← fderivWithin_univ]\n  exact iso.comp_fderivWithin uniqueDiffWithinAt_univ\n\n"}
{"name":"fderivWithin_continuousLinearEquiv_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nx : E\ns : Set E\nL : ContinuousLinearEquiv (RingHom.id 𝕜) G G'\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (fun x => (↑L).comp (f x)) s x) ((↑((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)).comp (fderivWithin 𝕜 f s x))","decl":"lemma _root_.fderivWithin_continuousLinearEquiv_comp (L : G ≃L[𝕜] G') (f : E → (F →L[𝕜] G))\n    (hs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (fun x ↦ (L : G →L[𝕜] G').comp (f x)) s x =\n      (((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)) ∘L (fderivWithin 𝕜 f s x) := by\n  change fderivWithin 𝕜 (((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L) ∘ f) s x = _\n  rw [ContinuousLinearEquiv.comp_fderivWithin _ hs]\n\n"}
{"name":"fderiv_continuousLinearEquiv_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nL : ContinuousLinearEquiv (RingHom.id 𝕜) G G'\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nx : E\n⊢ Eq (fderiv 𝕜 (fun x => (↑L).comp (f x)) x) ((↑((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)).comp (fderiv 𝕜 f x))","decl":"lemma _root_.fderiv_continuousLinearEquiv_comp (L : G ≃L[𝕜] G') (f : E → (F →L[𝕜] G)) (x : E) :\n    fderiv 𝕜 (fun x ↦ (L : G →L[𝕜] G').comp (f x)) x =\n      (((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)) ∘L (fderiv 𝕜 f x) := by\n  change fderiv 𝕜 (((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L) ∘ f) x = _\n  rw [ContinuousLinearEquiv.comp_fderiv]\n\n"}
{"name":"fderiv_continuousLinearEquiv_comp'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type u_4\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nG' : Type u_5\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nL : ContinuousLinearEquiv (RingHom.id 𝕜) G G'\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\n⊢ Eq (fderiv 𝕜 fun x => (↑L).comp (f x)) fun x => (↑((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)).comp (fderiv 𝕜 f x)","decl":"lemma _root_.fderiv_continuousLinearEquiv_comp' (L : G ≃L[𝕜] G') (f : E → (F →L[𝕜] G)) :\n    fderiv 𝕜 (fun x ↦ (L : G →L[𝕜] G').comp (f x)) =\n      fun x ↦ (((ContinuousLinearEquiv.refl 𝕜 F).arrowCongr L)) ∘L (fderiv 𝕜 f x) := by\n  ext x : 1\n  exact fderiv_continuousLinearEquiv_comp L f x\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\ns : Set F\nx : E\n⊢ Iff (DifferentiableWithinAt 𝕜 (Function.comp f ⇑iso) (Set.preimage (⇑iso) s) x) (DifferentiableWithinAt 𝕜 f s (iso x))","decl":"theorem comp_right_differentiableWithinAt_iff {f : F → G} {s : Set F} {x : E} :\n    DifferentiableWithinAt 𝕜 (f ∘ iso) (iso ⁻¹' s) x ↔ DifferentiableWithinAt 𝕜 f s (iso x) := by\n  refine ⟨fun H => ?_, fun H => H.comp x iso.differentiableWithinAt (mapsTo_preimage _ s)⟩\n  have : DifferentiableWithinAt 𝕜 ((f ∘ iso) ∘ iso.symm) s (iso x) := by\n    rw [← iso.symm_apply_apply x] at H\n    apply H.comp (iso x) iso.symm.differentiableWithinAt\n    intro y hy\n    simpa only [mem_preimage, apply_symm_apply] using hy\n  rwa [Function.comp_assoc, iso.self_comp_symm] at this\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\nx : E\n⊢ Iff (DifferentiableAt 𝕜 (Function.comp f ⇑iso) x) (DifferentiableAt 𝕜 f (iso x))","decl":"theorem comp_right_differentiableAt_iff {f : F → G} {x : E} :\n    DifferentiableAt 𝕜 (f ∘ iso) x ↔ DifferentiableAt 𝕜 f (iso x) := by\n  simp only [← differentiableWithinAt_univ, ← iso.comp_right_differentiableWithinAt_iff,\n    preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\ns : Set F\n⊢ Iff (DifferentiableOn 𝕜 (Function.comp f ⇑iso) (Set.preimage (⇑iso) s)) (DifferentiableOn 𝕜 f s)","decl":"theorem comp_right_differentiableOn_iff {f : F → G} {s : Set F} :\n    DifferentiableOn 𝕜 (f ∘ iso) (iso ⁻¹' s) ↔ DifferentiableOn 𝕜 f s := by\n  refine ⟨fun H y hy => ?_, fun H y hy => iso.comp_right_differentiableWithinAt_iff.2 (H _ hy)⟩\n  rw [← iso.apply_symm_apply y, ← comp_right_differentiableWithinAt_iff]\n  apply H\n  simpa only [mem_preimage, apply_symm_apply] using hy\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\n⊢ Iff (Differentiable 𝕜 (Function.comp f ⇑iso)) (Differentiable 𝕜 f)","decl":"theorem comp_right_differentiable_iff {f : F → G} :\n    Differentiable 𝕜 (f ∘ iso) ↔ Differentiable 𝕜 f := by\n  simp only [← differentiableOn_univ, ← iso.comp_right_differentiableOn_iff, preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\ns : Set F\nx : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) F G\n⊢ Iff (HasFDerivWithinAt (Function.comp f ⇑iso) (f'.comp ↑iso) (Set.preimage (⇑iso) s) x) (HasFDerivWithinAt f f' s (iso x))","decl":"theorem comp_right_hasFDerivWithinAt_iff {f : F → G} {s : Set F} {x : E} {f' : F →L[𝕜] G} :\n    HasFDerivWithinAt (f ∘ iso) (f'.comp (iso : E →L[𝕜] F)) (iso ⁻¹' s) x ↔\n      HasFDerivWithinAt f f' s (iso x) := by\n  refine ⟨fun H => ?_, fun H => H.comp x iso.hasFDerivWithinAt (mapsTo_preimage _ s)⟩\n  rw [← iso.symm_apply_apply x] at H\n  have A : f = (f ∘ iso) ∘ iso.symm := by\n    rw [Function.comp_assoc, iso.self_comp_symm]\n    rfl\n  have B : f' = (f'.comp (iso : E →L[𝕜] F)).comp (iso.symm : F →L[𝕜] E) := by\n    rw [ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm, ContinuousLinearMap.comp_id]\n  rw [A, B]\n  apply H.comp (iso x) iso.symm.hasFDerivWithinAt\n  intro y hy\n  simpa only [mem_preimage, apply_symm_apply] using hy\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\nx : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) F G\n⊢ Iff (HasFDerivAt (Function.comp f ⇑iso) (f'.comp ↑iso) x) (HasFDerivAt f f' (iso x))","decl":"theorem comp_right_hasFDerivAt_iff {f : F → G} {x : E} {f' : F →L[𝕜] G} :\n    HasFDerivAt (f ∘ iso) (f'.comp (iso : E →L[𝕜] F)) x ↔ HasFDerivAt f f' (iso x) := by\n  simp only [← hasFDerivWithinAt_univ, ← comp_right_hasFDerivWithinAt_iff, preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\ns : Set F\nx : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E G\n⊢ Iff (HasFDerivWithinAt (Function.comp f ⇑iso) f' (Set.preimage (⇑iso) s) x) (HasFDerivWithinAt f (f'.comp ↑iso.symm) s (iso x))","decl":"theorem comp_right_hasFDerivWithinAt_iff' {f : F → G} {s : Set F} {x : E} {f' : E →L[𝕜] G} :\n    HasFDerivWithinAt (f ∘ iso) f' (iso ⁻¹' s) x ↔\n      HasFDerivWithinAt f (f'.comp (iso.symm : F →L[𝕜] E)) s (iso x) := by\n  rw [← iso.comp_right_hasFDerivWithinAt_iff, ContinuousLinearMap.comp_assoc,\n    iso.coe_symm_comp_coe, ContinuousLinearMap.comp_id]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\nx : E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E G\n⊢ Iff (HasFDerivAt (Function.comp f ⇑iso) f' x) (HasFDerivAt f (f'.comp ↑iso.symm) (iso x))","decl":"theorem comp_right_hasFDerivAt_iff' {f : F → G} {x : E} {f' : E →L[𝕜] G} :\n    HasFDerivAt (f ∘ iso) f' x ↔ HasFDerivAt f (f'.comp (iso.symm : F →L[𝕜] E)) (iso x) := by\n  simp only [← hasFDerivWithinAt_univ, ← iso.comp_right_hasFDerivWithinAt_iff', preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\ns : Set F\nx : E\nhxs : UniqueDiffWithinAt 𝕜 (Set.preimage (⇑iso) s) x\n⊢ Eq (fderivWithin 𝕜 (Function.comp f ⇑iso) (Set.preimage (⇑iso) s) x) ((fderivWithin 𝕜 f s (iso x)).comp ↑iso)","decl":"theorem comp_right_fderivWithin {f : F → G} {s : Set F} {x : E}\n    (hxs : UniqueDiffWithinAt 𝕜 (iso ⁻¹' s) x) :\n    fderivWithin 𝕜 (f ∘ iso) (iso ⁻¹' s) x =\n      (fderivWithin 𝕜 f s (iso x)).comp (iso : E →L[𝕜] F) := by\n  by_cases h : DifferentiableWithinAt 𝕜 f s (iso x)\n  · exact (iso.comp_right_hasFDerivWithinAt_iff.2 h.hasFDerivWithinAt).fderivWithin hxs\n  · have : ¬DifferentiableWithinAt 𝕜 (f ∘ iso) (iso ⁻¹' s) x := by\n      intro h'\n      exact h (iso.comp_right_differentiableWithinAt_iff.1 h')\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h,\n      fderivWithin_zero_of_not_differentiableWithinAt this, ContinuousLinearMap.zero_comp]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nf : F → G\nx : E\n⊢ Eq (fderiv 𝕜 (Function.comp f ⇑iso) x) ((fderiv 𝕜 f (iso x)).comp ↑iso)","decl":"theorem comp_right_fderiv {f : F → G} {x : E} :\n    fderiv 𝕜 (f ∘ iso) x = (fderiv 𝕜 f (iso x)).comp (iso : E →L[𝕜] F) := by\n  rw [← fderivWithin_univ, ← fderivWithin_univ, ← iso.comp_right_fderivWithin, preimage_univ]\n  exact uniqueDiffWithinAt_univ\n\n"}
{"name":"LinearIsometryEquiv.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ HasStrictFDerivAt (⇑iso) (↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }) x","decl":"@[fun_prop]\nprotected theorem hasStrictFDerivAt : HasStrictFDerivAt iso (iso : E →L[𝕜] F) x :=\n  (iso : E ≃L[𝕜] F).hasStrictFDerivAt\n\n"}
{"name":"LinearIsometryEquiv.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ HasFDerivWithinAt (⇑iso) (↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }) s x","decl":"@[fun_prop]\nprotected theorem hasFDerivWithinAt : HasFDerivWithinAt iso (iso : E →L[𝕜] F) s x :=\n  (iso : E ≃L[𝕜] F).hasFDerivWithinAt\n\n"}
{"name":"LinearIsometryEquiv.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ HasFDerivAt (⇑iso) (↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }) x","decl":"@[fun_prop]\nprotected theorem hasFDerivAt : HasFDerivAt iso (iso : E →L[𝕜] F) x :=\n  (iso : E ≃L[𝕜] F).hasFDerivAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableAt 𝕜 (⇑iso) x","decl":"@[fun_prop]\nprotected theorem differentiableAt : DifferentiableAt 𝕜 iso x :=\n  iso.hasFDerivAt.differentiableAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableWithinAt 𝕜 (⇑iso) s x","decl":"@[fun_prop]\nprotected theorem differentiableWithinAt : DifferentiableWithinAt 𝕜 iso s x :=\n  iso.differentiableAt.differentiableWithinAt\n\n"}
{"name":"LinearIsometryEquiv.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ Eq (fderiv 𝕜 (⇑iso) x) ↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"protected theorem fderiv : fderiv 𝕜 iso x = iso :=\n  iso.hasFDerivAt.fderiv\n\n"}
{"name":"LinearIsometryEquiv.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (⇑iso) s x) ↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }","decl":"protected theorem fderivWithin (hxs : UniqueDiffWithinAt 𝕜 s x) : fderivWithin 𝕜 iso s x = iso :=\n  (iso : E ≃L[𝕜] F).fderivWithin hxs\n\n"}
{"name":"LinearIsometryEquiv.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ Differentiable 𝕜 ⇑iso","decl":"@[fun_prop]\nprotected theorem differentiable : Differentiable 𝕜 iso := fun _ => iso.differentiableAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ DifferentiableOn 𝕜 (⇑iso) s","decl":"@[fun_prop]\nprotected theorem differentiableOn : DifferentiableOn 𝕜 iso s :=\n  iso.differentiable.differentiableOn\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\n⊢ Iff (DifferentiableWithinAt 𝕜 (Function.comp (⇑iso) f) s x) (DifferentiableWithinAt 𝕜 f s x)","decl":"theorem comp_differentiableWithinAt_iff {f : G → E} {s : Set G} {x : G} :\n    DifferentiableWithinAt 𝕜 (iso ∘ f) s x ↔ DifferentiableWithinAt 𝕜 f s x :=\n  (iso : E ≃L[𝕜] F).comp_differentiableWithinAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\n⊢ Iff (DifferentiableAt 𝕜 (Function.comp (⇑iso) f) x) (DifferentiableAt 𝕜 f x)","decl":"theorem comp_differentiableAt_iff {f : G → E} {x : G} :\n    DifferentiableAt 𝕜 (iso ∘ f) x ↔ DifferentiableAt 𝕜 f x :=\n  (iso : E ≃L[𝕜] F).comp_differentiableAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\n⊢ Iff (DifferentiableOn 𝕜 (Function.comp (⇑iso) f) s) (DifferentiableOn 𝕜 f s)","decl":"theorem comp_differentiableOn_iff {f : G → E} {s : Set G} :\n    DifferentiableOn 𝕜 (iso ∘ f) s ↔ DifferentiableOn 𝕜 f s :=\n  (iso : E ≃L[𝕜] F).comp_differentiableOn_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\n⊢ Iff (Differentiable 𝕜 (Function.comp (⇑iso) f)) (Differentiable 𝕜 f)","decl":"theorem comp_differentiable_iff {f : G → E} : Differentiable 𝕜 (iso ∘ f) ↔ Differentiable 𝕜 f :=\n  (iso : E ≃L[𝕜] F).comp_differentiable_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasFDerivWithinAt (Function.comp (⇑iso) f) ((↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp f') s x) (HasFDerivWithinAt f f' s x)","decl":"theorem comp_hasFDerivWithinAt_iff {f : G → E} {s : Set G} {x : G} {f' : G →L[𝕜] E} :\n    HasFDerivWithinAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') s x ↔ HasFDerivWithinAt f f' s x :=\n  (iso : E ≃L[𝕜] F).comp_hasFDerivWithinAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasStrictFDerivAt (Function.comp (⇑iso) f) ((↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp f') x) (HasStrictFDerivAt f f' x)","decl":"theorem comp_hasStrictFDerivAt_iff {f : G → E} {x : G} {f' : G →L[𝕜] E} :\n    HasStrictFDerivAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') x ↔ HasStrictFDerivAt f f' x :=\n  (iso : E ≃L[𝕜] F).comp_hasStrictFDerivAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ Iff (HasFDerivAt (Function.comp (⇑iso) f) ((↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp f') x) (HasFDerivAt f f' x)","decl":"theorem comp_hasFDerivAt_iff {f : G → E} {x : G} {f' : G →L[𝕜] E} :\n    HasFDerivAt (iso ∘ f) ((iso : E →L[𝕜] F).comp f') x ↔ HasFDerivAt f f' x :=\n  (iso : E ≃L[𝕜] F).comp_hasFDerivAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G F\n⊢ Iff (HasFDerivWithinAt (Function.comp (⇑iso) f) f' s x) (HasFDerivWithinAt f ((↑{ toLinearEquiv := iso.symm.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp f') s x)","decl":"theorem comp_hasFDerivWithinAt_iff' {f : G → E} {s : Set G} {x : G} {f' : G →L[𝕜] F} :\n    HasFDerivWithinAt (iso ∘ f) f' s x ↔ HasFDerivWithinAt f ((iso.symm : F →L[𝕜] E).comp f') s x :=\n  (iso : E ≃L[𝕜] F).comp_hasFDerivWithinAt_iff'\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\nf' : ContinuousLinearMap (RingHom.id 𝕜) G F\n⊢ Iff (HasFDerivAt (Function.comp (⇑iso) f) f' x) (HasFDerivAt f ((↑{ toLinearEquiv := iso.symm.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp f') x)","decl":"theorem comp_hasFDerivAt_iff' {f : G → E} {x : G} {f' : G →L[𝕜] F} :\n    HasFDerivAt (iso ∘ f) f' x ↔ HasFDerivAt f ((iso.symm : F →L[𝕜] E).comp f') x :=\n  (iso : E ≃L[𝕜] F).comp_hasFDerivAt_iff'\n\n"}
{"name":"LinearIsometryEquiv.comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (fderivWithin 𝕜 (Function.comp (⇑iso) f) s x) ((↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp (fderivWithin 𝕜 f s x))","decl":"theorem comp_fderivWithin {f : G → E} {s : Set G} {x : G} (hxs : UniqueDiffWithinAt 𝕜 s x) :\n    fderivWithin 𝕜 (iso ∘ f) s x = (iso : E →L[𝕜] F).comp (fderivWithin 𝕜 f s x) :=\n  (iso : E ≃L[𝕜] F).comp_fderivWithin hxs\n\n"}
{"name":"LinearIsometryEquiv.comp_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\nx : G\n⊢ Eq (fderiv 𝕜 (Function.comp (⇑iso) f) x) ((↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp (fderiv 𝕜 f x))","decl":"theorem comp_fderiv {f : G → E} {x : G} :\n    fderiv 𝕜 (iso ∘ f) x = (iso : E →L[𝕜] F).comp (fderiv 𝕜 f x) :=\n  (iso : E ≃L[𝕜] F).comp_fderiv\n\n"}
{"name":"LinearIsometryEquiv.comp_fderiv'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_3\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type u_4\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\niso : LinearIsometryEquiv (RingHom.id 𝕜) E F\nf : G → E\n⊢ Eq (fderiv 𝕜 (Function.comp (⇑iso) f)) fun x => (↑{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := ⋯, continuous_invFun := ⋯ }).comp (fderiv 𝕜 f x)","decl":"theorem comp_fderiv' {f : G → E} :\n    fderiv 𝕜 (iso ∘ f) = fun x ↦ (iso : E →L[𝕜] F).comp (fderiv 𝕜 f x) := by\n  ext x : 1\n  exact LinearIsometryEquiv.comp_fderiv iso\n\n"}
{"name":"HasFDerivWithinAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\ng : F → E\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : F\nt : Set F\nhg : Filter.Tendsto g (nhdsWithin a t) (nhdsWithin (g a) s)\nhf : HasFDerivWithinAt f (↑f') s (g a)\nha : Membership.mem t a\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhdsWithin a t)\n⊢ HasFDerivWithinAt g (↑f'.symm) t a","decl":"/-- If `f (g y) = y` for `y` in a neighborhood of `a` within `t`,\n`g` maps a neighborhood of `a` within `t` to a neighborhood of `g a` within `s`,\nand `f` has an invertible derivative `f'` at `g a` within `s`,\nthen `g` has the derivative `f'⁻¹` at `a` within `t`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasFDerivWithinAt.of_local_left_inverse {g : F → E} {f' : E ≃L[𝕜] F} {a : F} {t : Set F}\n    (hg : Tendsto g (𝓝[t] a) (𝓝[s] (g a))) (hf : HasFDerivWithinAt f (f' : E →L[𝕜] F) s (g a))\n    (ha : a ∈ t) (hfg : ∀ᶠ y in 𝓝[t] a, f (g y) = y) :\n    HasFDerivWithinAt g (f'.symm : F →L[𝕜] E) t a := by\n  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[𝓝[t] a]\n      fun x : F => f' (g x - g a) - (x - a) :=\n    ((f'.symm : F →L[𝕜] E).isBigO_comp _ _).congr (fun x ↦ by simp) fun _ ↦ rfl\n  refine .of_isLittleO <| this.trans_isLittleO ?_\n  clear this\n  refine ((hf.isLittleO.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_\n  · intro p hp\n    simp [hp, hfg.self_of_nhdsWithin ha]\n  · refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'\n      (Eventually.of_forall fun _ => rfl) (hfg.mono ?_)\n    rintro p hp\n    simp only [(· ∘ ·), hp, hfg.self_of_nhdsWithin ha]\n\n"}
{"name":"HasStrictFDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ng : F → E\na : F\nhg : ContinuousAt g a\nhf : HasStrictFDerivAt f (↑f') (g a)\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\n⊢ HasStrictFDerivAt g (↑f'.symm) a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'⁻¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasStrictFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}\n    (hg : ContinuousAt g a) (hf : HasStrictFDerivAt f (f' : E →L[𝕜] F) (g a))\n    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasStrictFDerivAt g (f'.symm : F →L[𝕜] E) a := by\n  replace hg := hg.prodMap' hg\n  replace hfg := hfg.prod_mk_nhds hfg\n  have :\n    (fun p : F × F => g p.1 - g p.2 - f'.symm (p.1 - p.2)) =O[𝓝 (a, a)] fun p : F × F =>\n      f' (g p.1 - g p.2) - (p.1 - p.2) := by\n    refine ((f'.symm : F →L[𝕜] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl\n    simp\n  refine .of_isLittleO <| this.trans_isLittleO ?_\n  clear this\n  refine ((hf.isLittleO.comp_tendsto hg).symm.congr'\n    (hfg.mono ?_) (Eventually.of_forall fun _ => rfl)).trans_isBigO ?_\n  · rintro p ⟨hp1, hp2⟩\n    simp [hp1, hp2]\n  · refine (hf.isBigO_sub_rev.comp_tendsto hg).congr' (Eventually.of_forall fun _ => rfl)\n      (hfg.mono ?_)\n    rintro p ⟨hp1, hp2⟩\n    simp only [(· ∘ ·), hp1, hp2, Prod.map]\n\n"}
{"name":"HasFDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\ng : F → E\na : F\nhg : ContinuousAt g a\nhf : HasFDerivAt f (↑f') (g a)\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\n⊢ HasFDerivAt g (↑f'.symm) a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem HasFDerivAt.of_local_left_inverse {f : E → F} {f' : E ≃L[𝕜] F} {g : F → E} {a : F}\n    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E →L[𝕜] F) (g a))\n    (hfg : ∀ᶠ y in 𝓝 a, f (g y) = y) : HasFDerivAt g (f'.symm : F →L[𝕜] E) a := by\n  simp only [← hasFDerivWithinAt_univ, ← nhdsWithin_univ] at hf hfg ⊢\n  exact hf.of_local_left_inverse (.inf hg (by simp)) (mem_univ _) hfg\n\n"}
{"name":"PartialHomeomorph.hasStrictFDerivAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : F\nha : Membership.mem f.target a\nhtff' : HasStrictFDerivAt (↑f) (↑f') (↑f.symm a)\n⊢ HasStrictFDerivAt (↑f.symm) (↑f'.symm) a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` in the sense of strict differentiability at `f.symm a`, then `f.symm` has\nthe derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasStrictFDerivAt_symm (f : PartialHomeomorph E F) {f' : E ≃L[𝕜] F}\n    {a : F} (ha : a ∈ f.target) (htff' : HasStrictFDerivAt f (f' : E →L[𝕜] F) (f.symm a)) :\n    HasStrictFDerivAt f.symm (f'.symm : F →L[𝕜] E) a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) (f.eventually_right_inverse ha)\n\n"}
{"name":"PartialHomeomorph.hasFDerivAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nf' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : F\nha : Membership.mem f.target a\nhtff' : HasFDerivAt (↑f) (↑f') (↑f.symm a)\n⊢ HasFDerivAt (↑f.symm) (↑f'.symm) a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'⁻¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasFDerivAt_symm (f : PartialHomeomorph E F) {f' : E ≃L[𝕜] F} {a : F}\n    (ha : a ∈ f.target) (htff' : HasFDerivAt f (f' : E →L[𝕜] F) (f.symm a)) :\n    HasFDerivAt f.symm (f'.symm : F →L[𝕜] E) a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) (f.eventually_right_inverse ha)\n\n"}
{"name":"HasFDerivWithinAt.eventually_ne","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhf' : Exists fun C => ∀ (z : E), LE.le (Norm.norm z) (HMul.hMul C (Norm.norm (f' z)))\n⊢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem HasFDerivWithinAt.eventually_ne (h : HasFDerivWithinAt f f' s x)\n    (hf' : ∃ C, ∀ z, ‖z‖ ≤ C * ‖f' z‖) : ∀ᶠ z in 𝓝[s \\ {x}] x, f z ≠ f x := by\n  rw [nhdsWithin, diff_eq, ← inf_principal, ← inf_assoc, eventually_inf_principal]\n  have A : (fun z => z - x) =O[𝓝[s] x] fun z => f' (z - x) :=\n    isBigO_iff.2 <| hf'.imp fun C hC => Eventually.of_forall fun z => hC _\n  have : (fun z => f z - f x) ~[𝓝[s] x] fun z => f' (z - x) := h.isLittleO.trans_isBigO A\n  simpa [not_imp_not, sub_eq_zero] using (A.trans this.isBigO_symm).eq_zero_imp\n\n"}
{"name":"HasFDerivAt.eventually_ne","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivAt f f' x\nhf' : Exists fun C => ∀ (z : E), LE.le (Norm.norm z) (HMul.hMul C (Norm.norm (f' z)))\n⊢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem HasFDerivAt.eventually_ne (h : HasFDerivAt f f' x) (hf' : ∃ C, ∀ z, ‖z‖ ≤ C * ‖f' z‖) :\n    ∀ᶠ z in 𝓝[≠] x, f z ≠ f x := by\n  simpa only [compl_eq_univ_diff] using (hasFDerivWithinAt_univ.2 h).eventually_ne hf'\n\n"}
{"name":"has_fderiv_at_filter_real_equiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nL : Filter E\n⊢ Iff (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) L (nhds 0)) (Filter.Tendsto (fun x' => HSMul.hSMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x)))) L (nhds 0))","decl":"theorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => ‖x' - x‖⁻¹ * ‖f x' - f x - f' (x' - x)‖) L (𝓝 0) ↔\n      Tendsto (fun x' : E => ‖x' - x‖⁻¹ • (f x' - f x - f' (x' - x))) L (𝓝 0) := by\n  symm\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  refine tendsto_congr fun x' => ?_\n  simp [norm_smul]\n\n"}
{"name":"HasFDerivAt.lim_real","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nf' : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhf : HasFDerivAt f f' x\nv : E\n⊢ Filter.Tendsto (fun c => HSMul.hSMul c (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul (Inv.inv c) v))) (f x))) Filter.atTop (nhds (f' v))","decl":"theorem HasFDerivAt.lim_real (hf : HasFDerivAt f f' x) (v : E) :\n    Tendsto (fun c : ℝ => c • (f (x + c⁻¹ • v) - f x)) atTop (𝓝 (f' v)) := by\n  apply hf.lim v\n  rw [tendsto_atTop_atTop]\n  exact fun b => ⟨b, fun a ha => le_trans ha (le_abs_self _)⟩\n\n"}
{"name":"HasFDerivWithinAt.mapsTo_tangent_cone","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivWithinAt f f' s x\n⊢ Set.MapsTo (⇑f') (tangentConeAt 𝕜 s x) (tangentConeAt 𝕜 (Set.image f s) (f x))","decl":"/-- The image of a tangent cone under the differential of a map is included in the tangent cone to\nthe image. -/\ntheorem HasFDerivWithinAt.mapsTo_tangent_cone {x : E} (h : HasFDerivWithinAt f f' s x) :\n    MapsTo f' (tangentConeAt 𝕜 s x) (tangentConeAt 𝕜 (f '' s) (f x)) := by\n  rintro v ⟨c, d, dtop, clim, cdlim⟩\n  refine\n    ⟨c, fun n => f (x + d n) - f x, mem_of_superset dtop ?_, clim, h.lim atTop dtop clim cdlim⟩\n  simp +contextual [-mem_image, mem_image_of_mem]\n\n"}
{"name":"HasFDerivWithinAt.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nf' : ContinuousLinearMap (RingHom.id 𝕜) E F\nx : E\nh : HasFDerivWithinAt f f' s x\nhs : UniqueDiffWithinAt 𝕜 s x\nh' : DenseRange ⇑f'\n⊢ UniqueDiffWithinAt 𝕜 (Set.image f s) (f x)","decl":"/-- If a set has the unique differentiability property at a point x, then the image of this set\nunder a map with onto derivative has also the unique differentiability property at the image point.\n-/\ntheorem HasFDerivWithinAt.uniqueDiffWithinAt {x : E} (h : HasFDerivWithinAt f f' s x)\n    (hs : UniqueDiffWithinAt 𝕜 s x) (h' : DenseRange f') : UniqueDiffWithinAt 𝕜 (f '' s) (f x) := by\n  refine ⟨h'.dense_of_mapsTo f'.continuous hs.1 ?_, h.continuousWithinAt.mem_closure_image hs.2⟩\n  show\n    Submodule.span 𝕜 (tangentConeAt 𝕜 s x) ≤\n      (Submodule.span 𝕜 (tangentConeAt 𝕜 (f '' s) (f x))).comap f'\n  rw [Submodule.span_le]\n  exact h.mapsTo_tangent_cone.mono Subset.rfl Submodule.subset_span\n\n"}
{"name":"UniqueDiffOn.image","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nf' : E → ContinuousLinearMap (RingHom.id 𝕜) E F\nhs : UniqueDiffOn 𝕜 s\nhf' : ∀ (x : E), Membership.mem s x → HasFDerivWithinAt f (f' x) s x\nhd : ∀ (x : E), Membership.mem s x → DenseRange ⇑(f' x)\n⊢ UniqueDiffOn 𝕜 (Set.image f s)","decl":"theorem UniqueDiffOn.image {f' : E → E →L[𝕜] F} (hs : UniqueDiffOn 𝕜 s)\n    (hf' : ∀ x ∈ s, HasFDerivWithinAt f (f' x) s x) (hd : ∀ x ∈ s, DenseRange (f' x)) :\n    UniqueDiffOn 𝕜 (f '' s) :=\n  forall_mem_image.2 fun x hx => (hf' x hx).uniqueDiffWithinAt (hs x hx) (hd x hx)\n\n"}
{"name":"HasFDerivWithinAt.uniqueDiffWithinAt_of_continuousLinearEquiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\ne' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nh : HasFDerivWithinAt f (↑e') s x\nhs : UniqueDiffWithinAt 𝕜 s x\n⊢ UniqueDiffWithinAt 𝕜 (Set.image f s) (f x)","decl":"theorem HasFDerivWithinAt.uniqueDiffWithinAt_of_continuousLinearEquiv {x : E} (e' : E ≃L[𝕜] F)\n    (h : HasFDerivWithinAt f (e' : E →L[𝕜] F) s x) (hs : UniqueDiffWithinAt 𝕜 s x) :\n    UniqueDiffWithinAt 𝕜 (f '' s) (f x) :=\n  h.uniqueDiffWithinAt hs e'.surjective.denseRange\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_image","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nh : UniqueDiffOn 𝕜 s\n⊢ UniqueDiffOn 𝕜 (Set.image (⇑e) s)","decl":"theorem ContinuousLinearEquiv.uniqueDiffOn_image (e : E ≃L[𝕜] F) (h : UniqueDiffOn 𝕜 s) :\n    UniqueDiffOn 𝕜 (e '' s) :=\n  h.image (fun _ _ => e.hasFDerivWithinAt) fun _ _ => e.surjective.denseRange\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_image_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ Iff (UniqueDiffOn 𝕜 (Set.image (⇑e) s)) (UniqueDiffOn 𝕜 s)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.uniqueDiffOn_image_iff (e : E ≃L[𝕜] F) :\n    UniqueDiffOn 𝕜 (e '' s) ↔ UniqueDiffOn 𝕜 s :=\n  ⟨fun h => e.symm_image_image s ▸ e.symm.uniqueDiffOn_image h, e.uniqueDiffOn_image⟩\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_preimage_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_3\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id 𝕜) F E\n⊢ Iff (UniqueDiffOn 𝕜 (Set.preimage (⇑e) s)) (UniqueDiffOn 𝕜 s)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.uniqueDiffOn_preimage_iff (e : F ≃L[𝕜] E) :\n    UniqueDiffOn 𝕜 (e ⁻¹' s) ↔ UniqueDiffOn 𝕜 s := by\n  rw [← e.image_symm_eq_preimage, e.symm.uniqueDiffOn_image_iff]\n\n"}
