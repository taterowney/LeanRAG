{"name":"ContinuousLinearEquiv.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasStrictFDerivAt (â‡‘iso) (â†‘iso) x","decl":"@[fun_prop]\nprotected theorem hasStrictFDerivAt : HasStrictFDerivAt iso (iso : E â†’L[ğ•œ] F) x :=\n  iso.toContinuousLinearMap.hasStrictFDerivAt\n\n"}
{"name":"ContinuousLinearEquiv.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasFDerivWithinAt (â‡‘iso) (â†‘iso) s x","decl":"@[fun_prop]\nprotected theorem hasFDerivWithinAt : HasFDerivWithinAt iso (iso : E â†’L[ğ•œ] F) s x :=\n  iso.toContinuousLinearMap.hasFDerivWithinAt\n\n"}
{"name":"ContinuousLinearEquiv.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasFDerivAt (â‡‘iso) (â†‘iso) x","decl":"@[fun_prop]\nprotected theorem hasFDerivAt : HasFDerivAt iso (iso : E â†’L[ğ•œ] F) x :=\n  iso.toContinuousLinearMap.hasFDerivAtFilter\n\n"}
{"name":"ContinuousLinearEquiv.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableAt ğ•œ (â‡‘iso) x","decl":"@[fun_prop]\nprotected theorem differentiableAt : DifferentiableAt ğ•œ iso x :=\n  iso.hasFDerivAt.differentiableAt\n\n"}
{"name":"ContinuousLinearEquiv.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableWithinAt ğ•œ (â‡‘iso) s x","decl":"@[fun_prop]\nprotected theorem differentiableWithinAt : DifferentiableWithinAt ğ•œ iso s x :=\n  iso.differentiableAt.differentiableWithinAt\n\n"}
{"name":"ContinuousLinearEquiv.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq (fderiv ğ•œ (â‡‘iso) x) â†‘iso","decl":"protected theorem fderiv : fderiv ğ•œ iso x = iso :=\n  iso.hasFDerivAt.fderiv\n\n"}
{"name":"ContinuousLinearEquiv.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (â‡‘iso) s x) â†‘iso","decl":"protected theorem fderivWithin (hxs : UniqueDiffWithinAt ğ•œ s x) : fderivWithin ğ•œ iso s x = iso :=\n  iso.toContinuousLinearMap.fderivWithin hxs\n\n"}
{"name":"ContinuousLinearEquiv.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Differentiable ğ•œ â‡‘iso","decl":"@[fun_prop]\nprotected theorem differentiable : Differentiable ğ•œ iso := fun _ => iso.differentiableAt\n\n"}
{"name":"ContinuousLinearEquiv.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableOn ğ•œ (â‡‘iso) s","decl":"@[fun_prop]\nprotected theorem differentiableOn : DifferentiableOn ğ•œ iso s :=\n  iso.differentiable.differentiableOn\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ (Function.comp (â‡‘iso) f) s x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem comp_differentiableWithinAt_iff {f : G â†’ E} {s : Set G} {x : G} :\n    DifferentiableWithinAt ğ•œ (iso âˆ˜ f) s x â†” DifferentiableWithinAt ğ•œ f s x := by\n  refine\n    âŸ¨fun H => ?_, fun H => iso.differentiable.differentiableAt.comp_differentiableWithinAt x HâŸ©\n  have : DifferentiableWithinAt ğ•œ (iso.symm âˆ˜ iso âˆ˜ f) s x :=\n    iso.symm.differentiable.differentiableAt.comp_differentiableWithinAt x H\n  rwa [â† Function.comp_assoc iso.symm iso f, iso.symm_comp_self] at this\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nâŠ¢ Iff (DifferentiableAt ğ•œ (Function.comp (â‡‘iso) f) x) (DifferentiableAt ğ•œ f x)","decl":"theorem comp_differentiableAt_iff {f : G â†’ E} {x : G} :\n    DifferentiableAt ğ•œ (iso âˆ˜ f) x â†” DifferentiableAt ğ•œ f x := by\n  rw [â† differentiableWithinAt_univ, â† differentiableWithinAt_univ,\n    iso.comp_differentiableWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nâŠ¢ Iff (DifferentiableOn ğ•œ (Function.comp (â‡‘iso) f) s) (DifferentiableOn ğ•œ f s)","decl":"theorem comp_differentiableOn_iff {f : G â†’ E} {s : Set G} :\n    DifferentiableOn ğ•œ (iso âˆ˜ f) s â†” DifferentiableOn ğ•œ f s := by\n  rw [DifferentiableOn, DifferentiableOn]\n  simp only [iso.comp_differentiableWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nâŠ¢ Iff (Differentiable ğ•œ (Function.comp (â‡‘iso) f)) (Differentiable ğ•œ f)","decl":"theorem comp_differentiable_iff {f : G â†’ E} : Differentiable ğ•œ (iso âˆ˜ f) â†” Differentiable ğ•œ f := by\n  rw [â† differentiableOn_univ, â† differentiableOn_univ]\n  exact iso.comp_differentiableOn_iff\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp (â‡‘iso) f) ((â†‘iso).comp f') s x) (HasFDerivWithinAt f f' s x)","decl":"theorem comp_hasFDerivWithinAt_iff {f : G â†’ E} {s : Set G} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasFDerivWithinAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') s x â†” HasFDerivWithinAt f f' s x := by\n  refine âŸ¨fun H => ?_, fun H => iso.hasFDerivAt.comp_hasFDerivWithinAt x HâŸ©\n  have A : f = iso.symm âˆ˜ iso âˆ˜ f := by\n    rw [â† Function.comp_assoc, iso.symm_comp_self]\n    rfl\n  have B : f' = (iso.symm : F â†’L[ğ•œ] E).comp ((iso : E â†’L[ğ•œ] F).comp f') := by\n    rw [â† ContinuousLinearMap.comp_assoc, iso.coe_symm_comp_coe, ContinuousLinearMap.id_comp]\n  rw [A, B]\n  exact iso.symm.hasFDerivAt.comp_hasFDerivWithinAt x H\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasStrictFDerivAt (Function.comp (â‡‘iso) f) ((â†‘iso).comp f') x) (HasStrictFDerivAt f f' x)","decl":"theorem comp_hasStrictFDerivAt_iff {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasStrictFDerivAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') x â†” HasStrictFDerivAt f f' x := by\n  refine âŸ¨fun H => ?_, fun H => iso.hasStrictFDerivAt.comp x HâŸ©\n  convert iso.symm.hasStrictFDerivAt.comp x H using 1 <;>\n    ext z <;> apply (iso.symm_apply_apply _).symm\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasFDerivAt (Function.comp (â‡‘iso) f) ((â†‘iso).comp f') x) (HasFDerivAt f f' x)","decl":"theorem comp_hasFDerivAt_iff {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasFDerivAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') x â†” HasFDerivAt f f' x := by\n  simp_rw [â† hasFDerivWithinAt_univ, iso.comp_hasFDerivWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G F\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp (â‡‘iso) f) f' s x) (HasFDerivWithinAt f ((â†‘iso.symm).comp f') s x)","decl":"theorem comp_hasFDerivWithinAt_iff' {f : G â†’ E} {s : Set G} {x : G} {f' : G â†’L[ğ•œ] F} :\n    HasFDerivWithinAt (iso âˆ˜ f) f' s x â†”\n      HasFDerivWithinAt f ((iso.symm : F â†’L[ğ•œ] E).comp f') s x := by\n  rw [â† iso.comp_hasFDerivWithinAt_iff, â† ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm,\n    ContinuousLinearMap.id_comp]\n\n"}
{"name":"ContinuousLinearEquiv.comp_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G F\nâŠ¢ Iff (HasFDerivAt (Function.comp (â‡‘iso) f) f' x) (HasFDerivAt f ((â†‘iso.symm).comp f') x)","decl":"theorem comp_hasFDerivAt_iff' {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] F} :\n    HasFDerivAt (iso âˆ˜ f) f' x â†” HasFDerivAt f ((iso.symm : F â†’L[ğ•œ] E).comp f') x := by\n  simp_rw [â† hasFDerivWithinAt_univ, iso.comp_hasFDerivWithinAt_iff']\n\n"}
{"name":"ContinuousLinearEquiv.comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp (â‡‘iso) f) s x) ((â†‘iso).comp (fderivWithin ğ•œ f s x))","decl":"theorem comp_fderivWithin {f : G â†’ E} {s : Set G} {x : G} (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (iso âˆ˜ f) s x = (iso : E â†’L[ğ•œ] F).comp (fderivWithin ğ•œ f s x) := by\n  by_cases h : DifferentiableWithinAt ğ•œ f s x\n  Â· rw [fderiv_comp_fderivWithin x iso.differentiableAt h hxs, iso.fderiv]\n  Â· have : Â¬DifferentiableWithinAt ğ•œ (iso âˆ˜ f) s x := mt iso.comp_differentiableWithinAt_iff.1 h\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h,\n      fderivWithin_zero_of_not_differentiableWithinAt this, ContinuousLinearMap.comp_zero]\n\n"}
{"name":"ContinuousLinearEquiv.comp_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nâŠ¢ Eq (fderiv ğ•œ (Function.comp (â‡‘iso) f) x) ((â†‘iso).comp (fderiv ğ•œ f x))","decl":"theorem comp_fderiv {f : G â†’ E} {x : G} :\n    fderiv ğ•œ (iso âˆ˜ f) x = (iso : E â†’L[ğ•œ] F).comp (fderiv ğ•œ f x) := by\n  rw [â† fderivWithin_univ, â† fderivWithin_univ]\n  exact iso.comp_fderivWithin uniqueDiffWithinAt_univ\n\n"}
{"name":"fderivWithin_continuousLinearEquiv_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nx : E\ns : Set E\nL : ContinuousLinearEquiv (RingHom.id ğ•œ) G G'\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (fun x => (â†‘L).comp (f x)) s x) ((â†‘((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)).comp (fderivWithin ğ•œ f s x))","decl":"lemma _root_.fderivWithin_continuousLinearEquiv_comp (L : G â‰ƒL[ğ•œ] G') (f : E â†’ (F â†’L[ğ•œ] G))\n    (hs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (fun x â†¦ (L : G â†’L[ğ•œ] G').comp (f x)) s x =\n      (((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)) âˆ˜L (fderivWithin ğ•œ f s x) := by\n  change fderivWithin ğ•œ (((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L) âˆ˜ f) s x = _\n  rw [ContinuousLinearEquiv.comp_fderivWithin _ hs]\n\n"}
{"name":"fderiv_continuousLinearEquiv_comp","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nL : ContinuousLinearEquiv (RingHom.id ğ•œ) G G'\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nx : E\nâŠ¢ Eq (fderiv ğ•œ (fun x => (â†‘L).comp (f x)) x) ((â†‘((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)).comp (fderiv ğ•œ f x))","decl":"lemma _root_.fderiv_continuousLinearEquiv_comp (L : G â‰ƒL[ğ•œ] G') (f : E â†’ (F â†’L[ğ•œ] G)) (x : E) :\n    fderiv ğ•œ (fun x â†¦ (L : G â†’L[ğ•œ] G').comp (f x)) x =\n      (((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)) âˆ˜L (fderiv ğ•œ f x) := by\n  change fderiv ğ•œ (((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L) âˆ˜ f) x = _\n  rw [ContinuousLinearEquiv.comp_fderiv]\n\n"}
{"name":"fderiv_continuousLinearEquiv_comp'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nG' : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nL : ContinuousLinearEquiv (RingHom.id ğ•œ) G G'\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nâŠ¢ Eq (fderiv ğ•œ fun x => (â†‘L).comp (f x)) fun x => (â†‘((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)).comp (fderiv ğ•œ f x)","decl":"lemma _root_.fderiv_continuousLinearEquiv_comp' (L : G â‰ƒL[ğ•œ] G') (f : E â†’ (F â†’L[ğ•œ] G)) :\n    fderiv ğ•œ (fun x â†¦ (L : G â†’L[ğ•œ] G').comp (f x)) =\n      fun x â†¦ (((ContinuousLinearEquiv.refl ğ•œ F).arrowCongr L)) âˆ˜L (fderiv ğ•œ f x) := by\n  ext x : 1\n  exact fderiv_continuousLinearEquiv_comp L f x\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\ns : Set F\nx : E\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ (Function.comp f â‡‘iso) (Set.preimage (â‡‘iso) s) x) (DifferentiableWithinAt ğ•œ f s (iso x))","decl":"theorem comp_right_differentiableWithinAt_iff {f : F â†’ G} {s : Set F} {x : E} :\n    DifferentiableWithinAt ğ•œ (f âˆ˜ iso) (iso â»Â¹' s) x â†” DifferentiableWithinAt ğ•œ f s (iso x) := by\n  refine âŸ¨fun H => ?_, fun H => H.comp x iso.differentiableWithinAt (mapsTo_preimage _ s)âŸ©\n  have : DifferentiableWithinAt ğ•œ ((f âˆ˜ iso) âˆ˜ iso.symm) s (iso x) := by\n    rw [â† iso.symm_apply_apply x] at H\n    apply H.comp (iso x) iso.symm.differentiableWithinAt\n    intro y hy\n    simpa only [mem_preimage, apply_symm_apply] using hy\n  rwa [Function.comp_assoc, iso.self_comp_symm] at this\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\nx : E\nâŠ¢ Iff (DifferentiableAt ğ•œ (Function.comp f â‡‘iso) x) (DifferentiableAt ğ•œ f (iso x))","decl":"theorem comp_right_differentiableAt_iff {f : F â†’ G} {x : E} :\n    DifferentiableAt ğ•œ (f âˆ˜ iso) x â†” DifferentiableAt ğ•œ f (iso x) := by\n  simp only [â† differentiableWithinAt_univ, â† iso.comp_right_differentiableWithinAt_iff,\n    preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\ns : Set F\nâŠ¢ Iff (DifferentiableOn ğ•œ (Function.comp f â‡‘iso) (Set.preimage (â‡‘iso) s)) (DifferentiableOn ğ•œ f s)","decl":"theorem comp_right_differentiableOn_iff {f : F â†’ G} {s : Set F} :\n    DifferentiableOn ğ•œ (f âˆ˜ iso) (iso â»Â¹' s) â†” DifferentiableOn ğ•œ f s := by\n  refine âŸ¨fun H y hy => ?_, fun H y hy => iso.comp_right_differentiableWithinAt_iff.2 (H _ hy)âŸ©\n  rw [â† iso.apply_symm_apply y, â† comp_right_differentiableWithinAt_iff]\n  apply H\n  simpa only [mem_preimage, apply_symm_apply] using hy\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\nâŠ¢ Iff (Differentiable ğ•œ (Function.comp f â‡‘iso)) (Differentiable ğ•œ f)","decl":"theorem comp_right_differentiable_iff {f : F â†’ G} :\n    Differentiable ğ•œ (f âˆ˜ iso) â†” Differentiable ğ•œ f := by\n  simp only [â† differentiableOn_univ, â† iso.comp_right_differentiableOn_iff, preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\ns : Set F\nx : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp f â‡‘iso) (f'.comp â†‘iso) (Set.preimage (â‡‘iso) s) x) (HasFDerivWithinAt f f' s (iso x))","decl":"theorem comp_right_hasFDerivWithinAt_iff {f : F â†’ G} {s : Set F} {x : E} {f' : F â†’L[ğ•œ] G} :\n    HasFDerivWithinAt (f âˆ˜ iso) (f'.comp (iso : E â†’L[ğ•œ] F)) (iso â»Â¹' s) x â†”\n      HasFDerivWithinAt f f' s (iso x) := by\n  refine âŸ¨fun H => ?_, fun H => H.comp x iso.hasFDerivWithinAt (mapsTo_preimage _ s)âŸ©\n  rw [â† iso.symm_apply_apply x] at H\n  have A : f = (f âˆ˜ iso) âˆ˜ iso.symm := by\n    rw [Function.comp_assoc, iso.self_comp_symm]\n    rfl\n  have B : f' = (f'.comp (iso : E â†’L[ğ•œ] F)).comp (iso.symm : F â†’L[ğ•œ] E) := by\n    rw [ContinuousLinearMap.comp_assoc, iso.coe_comp_coe_symm, ContinuousLinearMap.comp_id]\n  rw [A, B]\n  apply H.comp (iso x) iso.symm.hasFDerivWithinAt\n  intro y hy\n  simpa only [mem_preimage, apply_symm_apply] using hy\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\nx : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) F G\nâŠ¢ Iff (HasFDerivAt (Function.comp f â‡‘iso) (f'.comp â†‘iso) x) (HasFDerivAt f f' (iso x))","decl":"theorem comp_right_hasFDerivAt_iff {f : F â†’ G} {x : E} {f' : F â†’L[ğ•œ] G} :\n    HasFDerivAt (f âˆ˜ iso) (f'.comp (iso : E â†’L[ğ•œ] F)) x â†” HasFDerivAt f f' (iso x) := by\n  simp only [â† hasFDerivWithinAt_univ, â† comp_right_hasFDerivWithinAt_iff, preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\ns : Set F\nx : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp f â‡‘iso) f' (Set.preimage (â‡‘iso) s) x) (HasFDerivWithinAt f (f'.comp â†‘iso.symm) s (iso x))","decl":"theorem comp_right_hasFDerivWithinAt_iff' {f : F â†’ G} {s : Set F} {x : E} {f' : E â†’L[ğ•œ] G} :\n    HasFDerivWithinAt (f âˆ˜ iso) f' (iso â»Â¹' s) x â†”\n      HasFDerivWithinAt f (f'.comp (iso.symm : F â†’L[ğ•œ] E)) s (iso x) := by\n  rw [â† iso.comp_right_hasFDerivWithinAt_iff, ContinuousLinearMap.comp_assoc,\n    iso.coe_symm_comp_coe, ContinuousLinearMap.comp_id]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\nx : E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E G\nâŠ¢ Iff (HasFDerivAt (Function.comp f â‡‘iso) f' x) (HasFDerivAt f (f'.comp â†‘iso.symm) (iso x))","decl":"theorem comp_right_hasFDerivAt_iff' {f : F â†’ G} {x : E} {f' : E â†’L[ğ•œ] G} :\n    HasFDerivAt (f âˆ˜ iso) f' x â†” HasFDerivAt f (f'.comp (iso.symm : F â†’L[ğ•œ] E)) (iso x) := by\n  simp only [â† hasFDerivWithinAt_univ, â† iso.comp_right_hasFDerivWithinAt_iff', preimage_univ]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\ns : Set F\nx : E\nhxs : UniqueDiffWithinAt ğ•œ (Set.preimage (â‡‘iso) s) x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp f â‡‘iso) (Set.preimage (â‡‘iso) s) x) ((fderivWithin ğ•œ f s (iso x)).comp â†‘iso)","decl":"theorem comp_right_fderivWithin {f : F â†’ G} {s : Set F} {x : E}\n    (hxs : UniqueDiffWithinAt ğ•œ (iso â»Â¹' s) x) :\n    fderivWithin ğ•œ (f âˆ˜ iso) (iso â»Â¹' s) x =\n      (fderivWithin ğ•œ f s (iso x)).comp (iso : E â†’L[ğ•œ] F) := by\n  by_cases h : DifferentiableWithinAt ğ•œ f s (iso x)\n  Â· exact (iso.comp_right_hasFDerivWithinAt_iff.2 h.hasFDerivWithinAt).fderivWithin hxs\n  Â· have : Â¬DifferentiableWithinAt ğ•œ (f âˆ˜ iso) (iso â»Â¹' s) x := by\n      intro h'\n      exact h (iso.comp_right_differentiableWithinAt_iff.1 h')\n    rw [fderivWithin_zero_of_not_differentiableWithinAt h,\n      fderivWithin_zero_of_not_differentiableWithinAt this, ContinuousLinearMap.zero_comp]\n\n"}
{"name":"ContinuousLinearEquiv.comp_right_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nf : F â†’ G\nx : E\nâŠ¢ Eq (fderiv ğ•œ (Function.comp f â‡‘iso) x) ((fderiv ğ•œ f (iso x)).comp â†‘iso)","decl":"theorem comp_right_fderiv {f : F â†’ G} {x : E} :\n    fderiv ğ•œ (f âˆ˜ iso) x = (fderiv ğ•œ f (iso x)).comp (iso : E â†’L[ğ•œ] F) := by\n  rw [â† fderivWithin_univ, â† fderivWithin_univ, â† iso.comp_right_fderivWithin, preimage_univ]\n  exact uniqueDiffWithinAt_univ\n\n"}
{"name":"LinearIsometryEquiv.hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasStrictFDerivAt (â‡‘iso) (â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) x","decl":"@[fun_prop]\nprotected theorem hasStrictFDerivAt : HasStrictFDerivAt iso (iso : E â†’L[ğ•œ] F) x :=\n  (iso : E â‰ƒL[ğ•œ] F).hasStrictFDerivAt\n\n"}
{"name":"LinearIsometryEquiv.hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasFDerivWithinAt (â‡‘iso) (â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) s x","decl":"@[fun_prop]\nprotected theorem hasFDerivWithinAt : HasFDerivWithinAt iso (iso : E â†’L[ğ•œ] F) s x :=\n  (iso : E â‰ƒL[ğ•œ] F).hasFDerivWithinAt\n\n"}
{"name":"LinearIsometryEquiv.hasFDerivAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ HasFDerivAt (â‡‘iso) (â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }) x","decl":"@[fun_prop]\nprotected theorem hasFDerivAt : HasFDerivAt iso (iso : E â†’L[ğ•œ] F) x :=\n  (iso : E â‰ƒL[ğ•œ] F).hasFDerivAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableAt ğ•œ (â‡‘iso) x","decl":"@[fun_prop]\nprotected theorem differentiableAt : DifferentiableAt ğ•œ iso x :=\n  iso.hasFDerivAt.differentiableAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableWithinAt ğ•œ (â‡‘iso) s x","decl":"@[fun_prop]\nprotected theorem differentiableWithinAt : DifferentiableWithinAt ğ•œ iso s x :=\n  iso.differentiableAt.differentiableWithinAt\n\n"}
{"name":"LinearIsometryEquiv.fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq (fderiv ğ•œ (â‡‘iso) x) â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }","decl":"protected theorem fderiv : fderiv ğ•œ iso x = iso :=\n  iso.hasFDerivAt.fderiv\n\n"}
{"name":"LinearIsometryEquiv.fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ns : Set E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (â‡‘iso) s x) â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }","decl":"protected theorem fderivWithin (hxs : UniqueDiffWithinAt ğ•œ s x) : fderivWithin ğ•œ iso s x = iso :=\n  (iso : E â‰ƒL[ğ•œ] F).fderivWithin hxs\n\n"}
{"name":"LinearIsometryEquiv.differentiable","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Differentiable ğ•œ â‡‘iso","decl":"@[fun_prop]\nprotected theorem differentiable : Differentiable ğ•œ iso := fun _ => iso.differentiableAt\n\n"}
{"name":"LinearIsometryEquiv.differentiableOn","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ DifferentiableOn ğ•œ (â‡‘iso) s","decl":"@[fun_prop]\nprotected theorem differentiableOn : DifferentiableOn ğ•œ iso s :=\n  iso.differentiable.differentiableOn\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nâŠ¢ Iff (DifferentiableWithinAt ğ•œ (Function.comp (â‡‘iso) f) s x) (DifferentiableWithinAt ğ•œ f s x)","decl":"theorem comp_differentiableWithinAt_iff {f : G â†’ E} {s : Set G} {x : G} :\n    DifferentiableWithinAt ğ•œ (iso âˆ˜ f) s x â†” DifferentiableWithinAt ğ•œ f s x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_differentiableWithinAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nâŠ¢ Iff (DifferentiableAt ğ•œ (Function.comp (â‡‘iso) f) x) (DifferentiableAt ğ•œ f x)","decl":"theorem comp_differentiableAt_iff {f : G â†’ E} {x : G} :\n    DifferentiableAt ğ•œ (iso âˆ˜ f) x â†” DifferentiableAt ğ•œ f x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_differentiableAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiableOn_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nâŠ¢ Iff (DifferentiableOn ğ•œ (Function.comp (â‡‘iso) f) s) (DifferentiableOn ğ•œ f s)","decl":"theorem comp_differentiableOn_iff {f : G â†’ E} {s : Set G} :\n    DifferentiableOn ğ•œ (iso âˆ˜ f) s â†” DifferentiableOn ğ•œ f s :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_differentiableOn_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_differentiable_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nâŠ¢ Iff (Differentiable ğ•œ (Function.comp (â‡‘iso) f)) (Differentiable ğ•œ f)","decl":"theorem comp_differentiable_iff {f : G â†’ E} : Differentiable ğ•œ (iso âˆ˜ f) â†” Differentiable ğ•œ f :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_differentiable_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivWithinAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp (â‡‘iso) f) ((â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp f') s x) (HasFDerivWithinAt f f' s x)","decl":"theorem comp_hasFDerivWithinAt_iff {f : G â†’ E} {s : Set G} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasFDerivWithinAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') s x â†” HasFDerivWithinAt f f' s x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_hasFDerivWithinAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasStrictFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasStrictFDerivAt (Function.comp (â‡‘iso) f) ((â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp f') x) (HasStrictFDerivAt f f' x)","decl":"theorem comp_hasStrictFDerivAt_iff {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasStrictFDerivAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') x â†” HasStrictFDerivAt f f' x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_hasStrictFDerivAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivAt_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ Iff (HasFDerivAt (Function.comp (â‡‘iso) f) ((â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp f') x) (HasFDerivAt f f' x)","decl":"theorem comp_hasFDerivAt_iff {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] E} :\n    HasFDerivAt (iso âˆ˜ f) ((iso : E â†’L[ğ•œ] F).comp f') x â†” HasFDerivAt f f' x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_hasFDerivAt_iff\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivWithinAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G F\nâŠ¢ Iff (HasFDerivWithinAt (Function.comp (â‡‘iso) f) f' s x) (HasFDerivWithinAt f ((â†‘{ toLinearEquiv := iso.symm.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp f') s x)","decl":"theorem comp_hasFDerivWithinAt_iff' {f : G â†’ E} {s : Set G} {x : G} {f' : G â†’L[ğ•œ] F} :\n    HasFDerivWithinAt (iso âˆ˜ f) f' s x â†” HasFDerivWithinAt f ((iso.symm : F â†’L[ğ•œ] E).comp f') s x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_hasFDerivWithinAt_iff'\n\n"}
{"name":"LinearIsometryEquiv.comp_hasFDerivAt_iff'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nf' : ContinuousLinearMap (RingHom.id ğ•œ) G F\nâŠ¢ Iff (HasFDerivAt (Function.comp (â‡‘iso) f) f' x) (HasFDerivAt f ((â†‘{ toLinearEquiv := iso.symm.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp f') x)","decl":"theorem comp_hasFDerivAt_iff' {f : G â†’ E} {x : G} {f' : G â†’L[ğ•œ] F} :\n    HasFDerivAt (iso âˆ˜ f) f' x â†” HasFDerivAt f ((iso.symm : F â†’L[ğ•œ] E).comp f') x :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_hasFDerivAt_iff'\n\n"}
{"name":"LinearIsometryEquiv.comp_fderivWithin","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\ns : Set G\nx : G\nhxs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ Eq (fderivWithin ğ•œ (Function.comp (â‡‘iso) f) s x) ((â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp (fderivWithin ğ•œ f s x))","decl":"theorem comp_fderivWithin {f : G â†’ E} {s : Set G} {x : G} (hxs : UniqueDiffWithinAt ğ•œ s x) :\n    fderivWithin ğ•œ (iso âˆ˜ f) s x = (iso : E â†’L[ğ•œ] F).comp (fderivWithin ğ•œ f s x) :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_fderivWithin hxs\n\n"}
{"name":"LinearIsometryEquiv.comp_fderiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nx : G\nâŠ¢ Eq (fderiv ğ•œ (Function.comp (â‡‘iso) f) x) ((â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp (fderiv ğ•œ f x))","decl":"theorem comp_fderiv {f : G â†’ E} {x : G} :\n    fderiv ğ•œ (iso âˆ˜ f) x = (iso : E â†’L[ğ•œ] F).comp (fderiv ğ•œ f x) :=\n  (iso : E â‰ƒL[ğ•œ] F).comp_fderiv\n\n"}
{"name":"LinearIsometryEquiv.comp_fderiv'","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type u_4\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\niso : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nf : G â†’ E\nâŠ¢ Eq (fderiv ğ•œ (Function.comp (â‡‘iso) f)) fun x => (â†‘{ toLinearEquiv := iso.toLinearEquiv, continuous_toFun := â‹¯, continuous_invFun := â‹¯ }).comp (fderiv ğ•œ f x)","decl":"theorem comp_fderiv' {f : G â†’ E} :\n    fderiv ğ•œ (iso âˆ˜ f) = fun x â†¦ (iso : E â†’L[ğ•œ] F).comp (fderiv ğ•œ f x) := by\n  ext x : 1\n  exact LinearIsometryEquiv.comp_fderiv iso\n\n"}
{"name":"HasFDerivWithinAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\ng : F â†’ E\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : F\nt : Set F\nhg : Filter.Tendsto g (nhdsWithin a t) (nhdsWithin (g a) s)\nhf : HasFDerivWithinAt f (â†‘f') s (g a)\nha : Membership.mem t a\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhdsWithin a t)\nâŠ¢ HasFDerivWithinAt g (â†‘f'.symm) t a","decl":"/-- If `f (g y) = y` for `y` in a neighborhood of `a` within `t`,\n`g` maps a neighborhood of `a` within `t` to a neighborhood of `g a` within `s`,\nand `f` has an invertible derivative `f'` at `g a` within `s`,\nthen `g` has the derivative `f'â»Â¹` at `a` within `t`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasFDerivWithinAt.of_local_left_inverse {g : F â†’ E} {f' : E â‰ƒL[ğ•œ] F} {a : F} {t : Set F}\n    (hg : Tendsto g (ğ“[t] a) (ğ“[s] (g a))) (hf : HasFDerivWithinAt f (f' : E â†’L[ğ•œ] F) s (g a))\n    (ha : a âˆˆ t) (hfg : âˆ€á¶  y in ğ“[t] a, f (g y) = y) :\n    HasFDerivWithinAt g (f'.symm : F â†’L[ğ•œ] E) t a := by\n  have : (fun x : F => g x - g a - f'.symm (x - a)) =O[ğ“[t] a]\n      fun x : F => f' (g x - g a) - (x - a) :=\n    ((f'.symm : F â†’L[ğ•œ] E).isBigO_comp _ _).congr (fun x â†¦ by simp) fun _ â†¦ rfl\n  refine .of_isLittleO <| this.trans_isLittleO ?_\n  clear this\n  refine ((hf.isLittleO.comp_tendsto hg).symm.congr' (hfg.mono ?_) .rfl).trans_isBigO ?_\n  Â· intro p hp\n    simp [hp, hfg.self_of_nhdsWithin ha]\n  Â· refine ((hf.isBigO_sub_rev f'.antilipschitz).comp_tendsto hg).congr'\n      (Eventually.of_forall fun _ => rfl) (hfg.mono ?_)\n    rintro p hp\n    simp only [(Â· âˆ˜ Â·), hp, hfg.self_of_nhdsWithin ha]\n\n"}
{"name":"HasStrictFDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ng : F â†’ E\na : F\nhg : ContinuousAt g a\nhf : HasStrictFDerivAt f (â†‘f') (g a)\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\nâŠ¢ HasStrictFDerivAt g (â†‘f'.symm) a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a` in the strict sense, then `g` has the derivative `f'â»Â¹` at `a`\nin the strict sense.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have an\ninverse function. -/\ntheorem HasStrictFDerivAt.of_local_left_inverse {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F}\n    (hg : ContinuousAt g a) (hf : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) (g a))\n    (hfg : âˆ€á¶  y in ğ“ a, f (g y) = y) : HasStrictFDerivAt g (f'.symm : F â†’L[ğ•œ] E) a := by\n  replace hg := hg.prodMap' hg\n  replace hfg := hfg.prod_mk_nhds hfg\n  have :\n    (fun p : F Ã— F => g p.1 - g p.2 - f'.symm (p.1 - p.2)) =O[ğ“ (a, a)] fun p : F Ã— F =>\n      f' (g p.1 - g p.2) - (p.1 - p.2) := by\n    refine ((f'.symm : F â†’L[ğ•œ] E).isBigO_comp _ _).congr (fun x => ?_) fun _ => rfl\n    simp\n  refine .of_isLittleO <| this.trans_isLittleO ?_\n  clear this\n  refine ((hf.isLittleO.comp_tendsto hg).symm.congr'\n    (hfg.mono ?_) (Eventually.of_forall fun _ => rfl)).trans_isBigO ?_\n  Â· rintro p âŸ¨hp1, hp2âŸ©\n    simp [hp1, hp2]\n  Â· refine (hf.isBigO_sub_rev.comp_tendsto hg).congr' (Eventually.of_forall fun _ => rfl)\n      (hfg.mono ?_)\n    rintro p âŸ¨hp1, hp2âŸ©\n    simp only [(Â· âˆ˜ Â·), hp1, hp2, Prod.map]\n\n"}
{"name":"HasFDerivAt.of_local_left_inverse","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\ng : F â†’ E\na : F\nhg : ContinuousAt g a\nhf : HasFDerivAt f (â†‘f') (g a)\nhfg : Filter.Eventually (fun y => Eq (f (g y)) y) (nhds a)\nâŠ¢ HasFDerivAt g (â†‘f'.symm) a","decl":"/-- If `f (g y) = y` for `y` in some neighborhood of `a`, `g` is continuous at `a`, and `f` has an\ninvertible derivative `f'` at `g a`, then `g` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem HasFDerivAt.of_local_left_inverse {f : E â†’ F} {f' : E â‰ƒL[ğ•œ] F} {g : F â†’ E} {a : F}\n    (hg : ContinuousAt g a) (hf : HasFDerivAt f (f' : E â†’L[ğ•œ] F) (g a))\n    (hfg : âˆ€á¶  y in ğ“ a, f (g y) = y) : HasFDerivAt g (f'.symm : F â†’L[ğ•œ] E) a := by\n  simp only [â† hasFDerivWithinAt_univ, â† nhdsWithin_univ] at hf hfg âŠ¢\n  exact hf.of_local_left_inverse (.inf hg (by simp)) (mem_univ _) hfg\n\n"}
{"name":"PartialHomeomorph.hasStrictFDerivAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : F\nha : Membership.mem f.target a\nhtff' : HasStrictFDerivAt (â†‘f) (â†‘f') (â†‘f.symm a)\nâŠ¢ HasStrictFDerivAt (â†‘f.symm) (â†‘f'.symm) a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` in the sense of strict differentiability at `f.symm a`, then `f.symm` has\nthe derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasStrictFDerivAt_symm (f : PartialHomeomorph E F) {f' : E â‰ƒL[ğ•œ] F}\n    {a : F} (ha : a âˆˆ f.target) (htff' : HasStrictFDerivAt f (f' : E â†’L[ğ•œ] F) (f.symm a)) :\n    HasStrictFDerivAt f.symm (f'.symm : F â†’L[ğ•œ] E) a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) (f.eventually_right_inverse ha)\n\n"}
{"name":"PartialHomeomorph.hasFDerivAt_symm","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nf' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : F\nha : Membership.mem f.target a\nhtff' : HasFDerivAt (â†‘f) (â†‘f') (â†‘f.symm a)\nâŠ¢ HasFDerivAt (â†‘f.symm) (â†‘f'.symm) a","decl":"/-- If `f` is a partial homeomorphism defined on a neighbourhood of `f.symm a`, and `f` has an\ninvertible derivative `f'` at `f.symm a`, then `f.symm` has the derivative `f'â»Â¹` at `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.hasFDerivAt_symm (f : PartialHomeomorph E F) {f' : E â‰ƒL[ğ•œ] F} {a : F}\n    (ha : a âˆˆ f.target) (htff' : HasFDerivAt f (f' : E â†’L[ğ•œ] F) (f.symm a)) :\n    HasFDerivAt f.symm (f'.symm : F â†’L[ğ•œ] E) a :=\n  htff'.of_local_left_inverse (f.symm.continuousAt ha) (f.eventually_right_inverse ha)\n\n"}
{"name":"HasFDerivWithinAt.eventually_ne","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\ns : Set E\nh : HasFDerivWithinAt f f' s x\nhf' : Exists fun C => âˆ€ (z : E), LE.le (Norm.norm z) (HMul.hMul C (Norm.norm (f' z)))\nâŠ¢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (SDiff.sdiff s (Singleton.singleton x)))","decl":"theorem HasFDerivWithinAt.eventually_ne (h : HasFDerivWithinAt f f' s x)\n    (hf' : âˆƒ C, âˆ€ z, â€–zâ€– â‰¤ C * â€–f' zâ€–) : âˆ€á¶  z in ğ“[s \\ {x}] x, f z â‰  f x := by\n  rw [nhdsWithin, diff_eq, â† inf_principal, â† inf_assoc, eventually_inf_principal]\n  have A : (fun z => z - x) =O[ğ“[s] x] fun z => f' (z - x) :=\n    isBigO_iff.2 <| hf'.imp fun C hC => Eventually.of_forall fun z => hC _\n  have : (fun z => f z - f x) ~[ğ“[s] x] fun z => f' (z - x) := h.isLittleO.trans_isBigO A\n  simpa [not_imp_not, sub_eq_zero] using (A.trans this.isBigO_symm).eq_zero_imp\n\n"}
{"name":"HasFDerivAt.eventually_ne","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivAt f f' x\nhf' : Exists fun C => âˆ€ (z : E), LE.le (Norm.norm z) (HMul.hMul C (Norm.norm (f' z)))\nâŠ¢ Filter.Eventually (fun z => Ne (f z) (f x)) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem HasFDerivAt.eventually_ne (h : HasFDerivAt f f' x) (hf' : âˆƒ C, âˆ€ z, â€–zâ€– â‰¤ C * â€–f' zâ€–) :\n    âˆ€á¶  z in ğ“[â‰ ] x, f z â‰  f x := by\n  simpa only [compl_eq_univ_diff] using (hasFDerivWithinAt_univ.2 h).eventually_ne hf'\n\n"}
{"name":"has_fderiv_at_filter_real_equiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nL : Filter E\nâŠ¢ Iff (Filter.Tendsto (fun x' => HMul.hMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (Norm.norm (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x))))) L (nhds 0)) (Filter.Tendsto (fun x' => HSMul.hSMul (Inv.inv (Norm.norm (HSub.hSub x' x))) (HSub.hSub (HSub.hSub (f x') (f x)) (f' (HSub.hSub x' x)))) L (nhds 0))","decl":"theorem has_fderiv_at_filter_real_equiv {L : Filter E} :\n    Tendsto (fun x' : E => â€–x' - xâ€–â»Â¹ * â€–f x' - f x - f' (x' - x)â€–) L (ğ“ 0) â†”\n      Tendsto (fun x' : E => â€–x' - xâ€–â»Â¹ â€¢ (f x' - f x - f' (x' - x))) L (ğ“ 0) := by\n  symm\n  rw [tendsto_iff_norm_sub_tendsto_zero]\n  refine tendsto_congr fun x' => ?_\n  simp [norm_smul]\n\n"}
{"name":"HasFDerivAt.lim_real","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nf' : ContinuousLinearMap (RingHom.id Real) E F\nx : E\nhf : HasFDerivAt f f' x\nv : E\nâŠ¢ Filter.Tendsto (fun c => HSMul.hSMul c (HSub.hSub (f (HAdd.hAdd x (HSMul.hSMul (Inv.inv c) v))) (f x))) Filter.atTop (nhds (f' v))","decl":"theorem HasFDerivAt.lim_real (hf : HasFDerivAt f f' x) (v : E) :\n    Tendsto (fun c : â„ => c â€¢ (f (x + câ»Â¹ â€¢ v) - f x)) atTop (ğ“ (f' v)) := by\n  apply hf.lim v\n  rw [tendsto_atTop_atTop]\n  exact fun b => âŸ¨b, fun a ha => le_trans ha (le_abs_self _)âŸ©\n\n"}
{"name":"HasFDerivWithinAt.mapsTo_tangent_cone","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivWithinAt f f' s x\nâŠ¢ Set.MapsTo (â‡‘f') (tangentConeAt ğ•œ s x) (tangentConeAt ğ•œ (Set.image f s) (f x))","decl":"/-- The image of a tangent cone under the differential of a map is included in the tangent cone to\nthe image. -/\ntheorem HasFDerivWithinAt.mapsTo_tangent_cone {x : E} (h : HasFDerivWithinAt f f' s x) :\n    MapsTo f' (tangentConeAt ğ•œ s x) (tangentConeAt ğ•œ (f '' s) (f x)) := by\n  rintro v âŸ¨c, d, dtop, clim, cdlimâŸ©\n  refine\n    âŸ¨c, fun n => f (x + d n) - f x, mem_of_superset dtop ?_, clim, h.lim atTop dtop clim cdlimâŸ©\n  simp +contextual [-mem_image, mem_image_of_mem]\n\n"}
{"name":"HasFDerivWithinAt.uniqueDiffWithinAt","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nf' : ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : E\nh : HasFDerivWithinAt f f' s x\nhs : UniqueDiffWithinAt ğ•œ s x\nh' : DenseRange â‡‘f'\nâŠ¢ UniqueDiffWithinAt ğ•œ (Set.image f s) (f x)","decl":"/-- If a set has the unique differentiability property at a point x, then the image of this set\nunder a map with onto derivative has also the unique differentiability property at the image point.\n-/\ntheorem HasFDerivWithinAt.uniqueDiffWithinAt {x : E} (h : HasFDerivWithinAt f f' s x)\n    (hs : UniqueDiffWithinAt ğ•œ s x) (h' : DenseRange f') : UniqueDiffWithinAt ğ•œ (f '' s) (f x) := by\n  refine âŸ¨h'.dense_of_mapsTo f'.continuous hs.1 ?_, h.continuousWithinAt.mem_closure_image hs.2âŸ©\n  show\n    Submodule.span ğ•œ (tangentConeAt ğ•œ s x) â‰¤\n      (Submodule.span ğ•œ (tangentConeAt ğ•œ (f '' s) (f x))).comap f'\n  rw [Submodule.span_le]\n  exact h.mapsTo_tangent_cone.mono Subset.rfl Submodule.subset_span\n\n"}
{"name":"UniqueDiffOn.image","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nf' : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhs : UniqueDiffOn ğ•œ s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhd : âˆ€ (x : E), Membership.mem s x â†’ DenseRange â‡‘(f' x)\nâŠ¢ UniqueDiffOn ğ•œ (Set.image f s)","decl":"theorem UniqueDiffOn.image {f' : E â†’ E â†’L[ğ•œ] F} (hs : UniqueDiffOn ğ•œ s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hd : âˆ€ x âˆˆ s, DenseRange (f' x)) :\n    UniqueDiffOn ğ•œ (f '' s) :=\n  forall_mem_image.2 fun x hx => (hf' x hx).uniqueDiffWithinAt (hs x hx) (hd x hx)\n\n"}
{"name":"HasFDerivWithinAt.uniqueDiffWithinAt_of_continuousLinearEquiv","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\ne' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nh : HasFDerivWithinAt f (â†‘e') s x\nhs : UniqueDiffWithinAt ğ•œ s x\nâŠ¢ UniqueDiffWithinAt ğ•œ (Set.image f s) (f x)","decl":"theorem HasFDerivWithinAt.uniqueDiffWithinAt_of_continuousLinearEquiv {x : E} (e' : E â‰ƒL[ğ•œ] F)\n    (h : HasFDerivWithinAt f (e' : E â†’L[ğ•œ] F) s x) (hs : UniqueDiffWithinAt ğ•œ s x) :\n    UniqueDiffWithinAt ğ•œ (f '' s) (f x) :=\n  h.uniqueDiffWithinAt hs e'.surjective.denseRange\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_image","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nh : UniqueDiffOn ğ•œ s\nâŠ¢ UniqueDiffOn ğ•œ (Set.image (â‡‘e) s)","decl":"theorem ContinuousLinearEquiv.uniqueDiffOn_image (e : E â‰ƒL[ğ•œ] F) (h : UniqueDiffOn ğ•œ s) :\n    UniqueDiffOn ğ•œ (e '' s) :=\n  h.image (fun _ _ => e.hasFDerivWithinAt) fun _ _ => e.surjective.denseRange\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_image_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Iff (UniqueDiffOn ğ•œ (Set.image (â‡‘e) s)) (UniqueDiffOn ğ•œ s)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.uniqueDiffOn_image_iff (e : E â‰ƒL[ğ•œ] F) :\n    UniqueDiffOn ğ•œ (e '' s) â†” UniqueDiffOn ğ•œ s :=\n  âŸ¨fun h => e.symm_image_image s â–¸ e.symm.uniqueDiffOn_image h, e.uniqueDiffOn_imageâŸ©\n\n"}
{"name":"ContinuousLinearEquiv.uniqueDiffOn_preimage_iff","module":"Mathlib.Analysis.Calculus.FDeriv.Equiv","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) F E\nâŠ¢ Iff (UniqueDiffOn ğ•œ (Set.preimage (â‡‘e) s)) (UniqueDiffOn ğ•œ s)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.uniqueDiffOn_preimage_iff (e : F â‰ƒL[ğ•œ] E) :\n    UniqueDiffOn ğ•œ (e â»Â¹' s) â†” UniqueDiffOn ğ•œ s := by\n  rw [â† e.image_symm_eq_preimage, e.symm.uniqueDiffOn_image_iff]\n\n"}
