{"name":"Finset.card_def","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.card s.val.card","decl":"theorem card_def (s : Finset α) : #s = Multiset.card s.1 :=\n  rfl\n\n"}
{"name":"Finset.card_val","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.val.card s.card","decl":"@[simp] lemma card_val (s : Finset α) : Multiset.card s.1 = #s := rfl\n\n"}
{"name":"Finset.card_mk","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nm : Multiset α\nnodup : m.Nodup\n⊢ Eq { val := m, nodup := nodup }.card m.card","decl":"@[simp]\ntheorem card_mk {m nodup} : #(⟨m, nodup⟩ : Finset α) = Multiset.card m :=\n  rfl\n\n"}
{"name":"Finset.card_empty","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection.card 0","decl":"@[simp]\ntheorem card_empty : #(∅ : Finset α) = 0 :=\n  rfl\n\n"}
{"name":"Finset.card_le_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : HasSubset.Subset s t\n⊢ LE.le s.card t.card","decl":"@[gcongr]\ntheorem card_le_card : s ⊆ t → #s ≤ #t :=\n  Multiset.card_le_card ∘ val_le_iff.mpr\n\n"}
{"name":"Finset.card_mono","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\n⊢ Monotone Finset.card","decl":"@[mono]\ntheorem card_mono : Monotone (@card α) := by apply card_le_card\n\n"}
{"name":"Finset.card_eq_zero","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.card 0) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp] lemma card_eq_zero : #s = 0 ↔ s = ∅ := Multiset.card_eq_zero.trans val_eq_zero\n"}
{"name":"Finset.card_ne_zero","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Ne s.card 0) s.Nonempty","decl":"lemma card_ne_zero : #s ≠ 0 ↔ s.Nonempty := card_eq_zero.ne.trans nonempty_iff_ne_empty.symm\n"}
{"name":"Finset.card_pos","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 0 s.card) s.Nonempty","decl":"@[simp] lemma card_pos : 0 < #s ↔ s.Nonempty := Nat.pos_iff_ne_zero.trans card_ne_zero\n"}
{"name":"Finset.one_le_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LE.le 1 s.card) s.Nonempty","decl":"@[simp] lemma one_le_card : 1 ≤ #s ↔ s.Nonempty := card_pos\n\n"}
{"name":"Finset.Nonempty.card_pos","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ LT.lt 0 s.card","decl":"alias ⟨_, Nonempty.card_pos⟩ := card_pos\n"}
{"name":"Finset.Nonempty.card_ne_zero","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na✝ : s.Nonempty\n⊢ Ne s.card 0","decl":"alias ⟨_, Nonempty.card_ne_zero⟩ := card_ne_zero\n\n"}
{"name":"Finset.card_ne_zero_of_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Membership.mem s a\n⊢ Ne s.card 0","decl":"theorem card_ne_zero_of_mem (h : a ∈ s) : #s ≠ 0 :=\n  (not_congr card_eq_zero).2 <| ne_empty_of_mem h\n\n"}
{"name":"Finset.card_singleton","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).card 1","decl":"@[simp]\ntheorem card_singleton (a : α) : #{a} = 1 :=\n  Multiset.card_singleton _\n\n"}
{"name":"Finset.card_singleton_inter","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\n⊢ LE.le (Inter.inter (Singleton.singleton a) s).card 1","decl":"theorem card_singleton_inter [DecidableEq α] : #({a} ∩ s) ≤ 1 := by\n  cases' Finset.decidableMem a s with h h\n  · simp [Finset.singleton_inter_of_not_mem h]\n  · simp [Finset.singleton_inter_of_mem h]\n\n"}
{"name":"Finset.card_cons","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Eq (Finset.cons a s h).card (HAdd.hAdd s.card 1)","decl":"@[simp]\ntheorem card_cons (h : a ∉ s) : #(s.cons a h) = #s + 1 :=\n  Multiset.card_cons _ _\n\n"}
{"name":"Finset.card_insert_of_not_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nh : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a s).card (HAdd.hAdd s.card 1)","decl":"@[simp]\ntheorem card_insert_of_not_mem (h : a ∉ s) : #(insert a s) = #s + 1 := by\n  rw [← cons_eq_insert _ _ h, card_cons]\n\n"}
{"name":"Finset.card_insert_of_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nh : Membership.mem s a\n⊢ Eq (Insert.insert a s).card s.card","decl":"theorem card_insert_of_mem (h : a ∈ s) : #(insert a s) = #s := by rw [insert_eq_of_mem h]\n\n"}
{"name":"Finset.card_insert_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ LE.le (Insert.insert a s).card (HAdd.hAdd s.card 1)","decl":"theorem card_insert_le (a : α) (s : Finset α) : #(insert a s) ≤ #s + 1 := by\n  by_cases h : a ∈ s\n  · rw [insert_eq_of_mem h]\n    exact Nat.le_succ _\n  · rw [card_insert_of_not_mem h]\n\n"}
{"name":"Finset.card_le_two","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ LE.le (Insert.insert a (Singleton.singleton b)).card 2","decl":"theorem card_le_two : #{a, b} ≤ 2 := card_insert_le _ _\n\n"}
{"name":"Finset.card_le_three","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b c : α\n⊢ LE.le (Insert.insert a (Insert.insert b (Singleton.singleton c))).card 3","decl":"theorem card_le_three : #{a, b, c} ≤ 3 :=\n  (card_insert_le _ _).trans (Nat.succ_le_succ card_le_two)\n\n"}
{"name":"Finset.card_le_four","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b c d : α\n⊢ LE.le (Insert.insert a (Insert.insert b (Insert.insert c (Singleton.singleton d)))).card 4","decl":"theorem card_le_four : #{a, b, c, d} ≤ 4 :=\n  (card_insert_le _ _).trans (Nat.succ_le_succ card_le_three)\n\n"}
{"name":"Finset.card_le_five","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b c d e : α\n⊢ LE.le (Insert.insert a (Insert.insert b (Insert.insert c (Insert.insert d (Singleton.singleton e))))).card 5","decl":"theorem card_le_five : #{a, b, c, d, e} ≤ 5 :=\n  (card_insert_le _ _).trans (Nat.succ_le_succ card_le_four)\n\n"}
{"name":"Finset.card_le_six","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b c d e f : α\n⊢ LE.le (Insert.insert a (Insert.insert b (Insert.insert c (Insert.insert d (Insert.insert e (Singleton.singleton f)))))).card 6","decl":"theorem card_le_six : #{a, b, c, d, e, f} ≤ 6 :=\n  (card_insert_le _ _).trans (Nat.succ_le_succ card_le_five)\n\n"}
{"name":"Finset.card_insert_eq_ite","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\n⊢ Eq (Insert.insert a s).card (ite (Membership.mem s a) s.card (HAdd.hAdd s.card 1))","decl":"/-- If `a ∈ s` is known, see also `Finset.card_insert_of_mem` and `Finset.card_insert_of_not_mem`.\n-/\ntheorem card_insert_eq_ite : #(insert a s) = if a ∈ s then #s else #s + 1 := by\n  by_cases h : a ∈ s\n  · rw [card_insert_of_mem h, if_pos h]\n  · rw [card_insert_of_not_mem h, if_neg h]\n\n"}
{"name":"Finset.card_pair_eq_one_or_two","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\na b : α\ninst✝ : DecidableEq α\n⊢ Or (Eq (Insert.insert a (Singleton.singleton b)).card 1) (Eq (Insert.insert a (Singleton.singleton b)).card 2)","decl":"@[simp]\ntheorem card_pair_eq_one_or_two : #{a, b} = 1 ∨ #{a, b} = 2 := by\n  simp [card_insert_eq_ite]\n  tauto\n\n"}
{"name":"Finset.card_pair","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\na b : α\ninst✝ : DecidableEq α\nh : Ne a b\n⊢ Eq (Insert.insert a (Singleton.singleton b)).card 2","decl":"@[simp]\ntheorem card_pair (h : a ≠ b) : #{a, b} = 2 := by\n  rw [card_insert_of_not_mem (not_mem_singleton.2 h), card_singleton]\n\n"}
{"name":"Finset.card_erase_of_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\na✝ : Membership.mem s a\n⊢ Eq (s.erase a).card (HSub.hSub s.card 1)","decl":"/-- $\\#(s \\setminus \\{a\\}) = \\#s - 1$ if $a \\in s$. -/\n@[simp]\ntheorem card_erase_of_mem : a ∈ s → #(s.erase a) = #s - 1 :=\n  Multiset.card_erase_of_mem\n\n"}
{"name":"Finset.cast_card_erase_of_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\na : α\ninst✝¹ : DecidableEq α\nR : Type u_4\ninst✝ : AddGroupWithOne R\ns : Finset α\nhs : Membership.mem s a\n⊢ Eq (↑(s.erase a).card) (HSub.hSub (↑s.card) 1)","decl":"/-- $\\#(s \\setminus \\{a\\}) = \\#s - 1$ if $a \\in s$.\n  This result is casted to any additive group with 1,\n  so that we don't have to work with `ℕ`-subtraction. -/\n@[simp]\ntheorem cast_card_erase_of_mem {R} [AddGroupWithOne R] {s : Finset α} (hs : a ∈ s) :\n    (#(s.erase a) : R) = #s - 1 := by\n  rw [card_erase_of_mem hs, Nat.cast_sub, Nat.cast_one]\n  rw [Nat.add_one_le_iff, Finset.card_pos]\n  exact ⟨a, hs⟩\n\n"}
{"name":"Finset.card_erase_add_one","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\na✝ : Membership.mem s a\n⊢ Eq (HAdd.hAdd (s.erase a).card 1) s.card","decl":"@[simp]\ntheorem card_erase_add_one : a ∈ s → #(s.erase a) + 1 = #s :=\n  Multiset.card_erase_add_one\n\n"}
{"name":"Finset.card_erase_lt_of_mem","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\na✝ : Membership.mem s a\n⊢ LT.lt (s.erase a).card s.card","decl":"theorem card_erase_lt_of_mem : a ∈ s → #(s.erase a) < #s :=\n  Multiset.card_erase_lt_of_mem\n\n"}
{"name":"Finset.card_erase_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\n⊢ LE.le (s.erase a).card s.card","decl":"theorem card_erase_le : #(s.erase a) ≤ #s :=\n  Multiset.card_erase_le\n\n"}
{"name":"Finset.pred_card_le_card_erase","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\n⊢ LE.le (HSub.hSub s.card 1) (s.erase a).card","decl":"theorem pred_card_le_card_erase : #s - 1 ≤ #(s.erase a) := by\n  by_cases h : a ∈ s\n  · exact (card_erase_of_mem h).ge\n  · rw [erase_eq_of_not_mem h]\n    exact Nat.sub_le _ _\n\n"}
{"name":"Finset.card_erase_eq_ite","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\n⊢ Eq (s.erase a).card (ite (Membership.mem s a) (HSub.hSub s.card 1) s.card)","decl":"/-- If `a ∈ s` is known, see also `Finset.card_erase_of_mem` and `Finset.erase_eq_of_not_mem`. -/\ntheorem card_erase_eq_ite : #(s.erase a) = if a ∈ s then #s - 1 else #s :=\n  Multiset.card_erase_eq_ite\n\n"}
{"name":"Finset.card_range","module":"Mathlib.Data.Finset.Card","initialProofState":"n : Nat\n⊢ Eq (Finset.range n).card n","decl":"@[simp]\ntheorem card_range (n : ℕ) : #(range n) = n :=\n  Multiset.card_range n\n\n"}
{"name":"Finset.card_attach","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.attach.card s.card","decl":"@[simp]\ntheorem card_attach : #s.attach = #s :=\n  Multiset.card_attach\n\n"}
{"name":"Multiset.card_toFinset","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Eq m.toFinset.card m.dedup.card","decl":"theorem Multiset.card_toFinset : #m.toFinset = Multiset.card m.dedup :=\n  rfl\n\n"}
{"name":"Multiset.toFinset_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ LE.le m.toFinset.card m.card","decl":"theorem Multiset.toFinset_card_le : #m.toFinset ≤ Multiset.card m :=\n  card_le_card <| dedup_le _\n\n"}
{"name":"Multiset.toFinset_card_of_nodup","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\nh : m.Nodup\n⊢ Eq m.toFinset.card m.card","decl":"theorem Multiset.toFinset_card_of_nodup {m : Multiset α} (h : m.Nodup) :\n    #m.toFinset = Multiset.card m :=\n  congr_arg card <| Multiset.dedup_eq_self.mpr h\n\n"}
{"name":"Multiset.dedup_card_eq_card_iff_nodup","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Iff (Eq m.dedup.card m.card) m.Nodup","decl":"theorem Multiset.dedup_card_eq_card_iff_nodup {m : Multiset α} :\n    card m.dedup = card m ↔ m.Nodup :=\n  .trans ⟨fun h ↦ eq_of_le_of_card_le (dedup_le m) h.ge, congr_arg _⟩ dedup_eq_self\n\n"}
{"name":"Multiset.toFinset_card_eq_card_iff_nodup","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nm : Multiset α\n⊢ Iff (Eq m.toFinset.card m.card) m.Nodup","decl":"theorem Multiset.toFinset_card_eq_card_iff_nodup {m : Multiset α} :\n    #m.toFinset = card m ↔ m.Nodup := dedup_card_eq_card_iff_nodup\n\n"}
{"name":"List.card_toFinset","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq l.toFinset.card l.dedup.length","decl":"theorem List.card_toFinset : #l.toFinset = l.dedup.length :=\n  rfl\n\n"}
{"name":"List.toFinset_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ LE.le l.toFinset.card l.length","decl":"theorem List.toFinset_card_le : #l.toFinset ≤ l.length :=\n  Multiset.toFinset_card_le ⟦l⟧\n\n"}
{"name":"List.toFinset_card_of_nodup","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ Eq l.toFinset.card l.length","decl":"theorem List.toFinset_card_of_nodup {l : List α} (h : l.Nodup) : #l.toFinset = l.length :=\n  Multiset.toFinset_card_of_nodup h\n\n"}
{"name":"Finset.length_toList","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.toList.length s.card","decl":"@[simp]\ntheorem length_toList (s : Finset α) : s.toList.length = #s := by\n  rw [toList, ← Multiset.coe_card, Multiset.coe_toList, card_def]\n\n"}
{"name":"Finset.card_image_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : α → β\ninst✝ : DecidableEq β\n⊢ LE.le (Finset.image f s).card s.card","decl":"theorem card_image_le [DecidableEq β] : #(s.image f) ≤ #s := by\n  simpa only [card_map] using (s.1.map f).toFinset_card_le\n\n"}
{"name":"Finset.card_image_of_injOn","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : α → β\ninst✝ : DecidableEq β\nH : Set.InjOn f ↑s\n⊢ Eq (Finset.image f s).card s.card","decl":"theorem card_image_of_injOn [DecidableEq β] (H : Set.InjOn f s) : #(s.image f) = #s := by\n  simp only [card, image_val_of_injOn H, card_map]\n\n"}
{"name":"Finset.injOn_of_card_image_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : α → β\ninst✝ : DecidableEq β\nH : Eq (Finset.image f s).card s.card\n⊢ Set.InjOn f ↑s","decl":"theorem injOn_of_card_image_eq [DecidableEq β] (H : #(s.image f) = #s) : Set.InjOn f s := by\n  rw [card_def, card_def, image, toFinset] at H\n  dsimp only at H\n  have : (s.1.map f).dedup = s.1.map f := by\n    refine Multiset.eq_of_le_of_card_le (Multiset.dedup_le _) ?_\n    simp only [H, Multiset.card_map, le_rfl]\n  rw [Multiset.dedup_eq_self] at this\n  exact inj_on_of_nodup_map this\n\n"}
{"name":"Finset.card_image_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : α → β\ninst✝ : DecidableEq β\n⊢ Iff (Eq (Finset.image f s).card s.card) (Set.InjOn f ↑s)","decl":"theorem card_image_iff [DecidableEq β] : #(s.image f) = #s ↔ Set.InjOn f s :=\n  ⟨injOn_of_card_image_eq, card_image_of_injOn⟩\n\n"}
{"name":"Finset.card_image_of_injective","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ninst✝ : DecidableEq β\ns : Finset α\nH : Function.Injective f\n⊢ Eq (Finset.image f s).card s.card","decl":"theorem card_image_of_injective [DecidableEq β] (s : Finset α) (H : Injective f) :\n    #(s.image f) = #s :=\n  card_image_of_injOn fun _ _ _ _ h => H h\n\n"}
{"name":"Finset.fiber_card_ne_zero_iff_mem_image","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : α → β\ninst✝ : DecidableEq β\ny : β\n⊢ Iff (Ne (Finset.filter (fun x => Eq (f x) y) s).card 0) (Membership.mem (Finset.image f s) y)","decl":"theorem fiber_card_ne_zero_iff_mem_image (s : Finset α) (f : α → β) [DecidableEq β] (y : β) :\n    #(s.filter fun x ↦ f x = y) ≠ 0 ↔ y ∈ s.image f := by\n  rw [← Nat.pos_iff_ne_zero, card_pos, fiber_nonempty_iff_mem_image]\n\n"}
{"name":"Finset.card_filter_le_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nP : α → Prop\ninst✝ : DecidablePred P\nn : Nat\n⊢ Iff (LE.le (Finset.filter P s).card n) (∀ (s' : Finset α), HasSubset.Subset s' s → LT.lt n s'.card → Exists fun a => And (Membership.mem s' a) (Not (P a)))","decl":"lemma card_filter_le_iff (s : Finset α) (P : α → Prop) [DecidablePred P] (n : ℕ) :\n    #(s.filter P) ≤ n ↔ ∀ s' ⊆ s, n < #s' → ∃ a ∈ s', ¬ P a :=\n  (s.1.card_filter_le_iff P n).trans ⟨fun H s' hs' h ↦ H s'.1 (by aesop) h,\n    fun H s' hs' h ↦ H ⟨s', nodup_of_le hs' s.2⟩ (fun _ hx ↦ Multiset.subset_of_le hs' hx) h⟩\n\n"}
{"name":"Finset.card_map","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nf : Function.Embedding α β\n⊢ Eq (Finset.map f s).card s.card","decl":"@[simp]\ntheorem card_map (f : α ↪ β) : #(s.map f) = #s :=\n  Multiset.card_map _ _\n\n"}
{"name":"Finset.card_subtype","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Eq (Finset.subtype p s).card (Finset.filter p s).card","decl":"@[simp]\ntheorem card_subtype (p : α → Prop) [DecidablePred p] (s : Finset α) :\n    #(s.subtype p) = #(s.filter p) := by simp [Finset.subtype]\n\n"}
{"name":"Finset.card_filter_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ LE.le (Finset.filter p s).card s.card","decl":"theorem card_filter_le (s : Finset α) (p : α → Prop) [DecidablePred p] :\n    #(s.filter p) ≤ #s :=\n  card_le_card <| filter_subset _ _\n\n"}
{"name":"Finset.eq_of_subset_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSubset.Subset s t\nh₂ : LE.le t.card s.card\n⊢ Eq s t","decl":"theorem eq_of_subset_of_card_le {s t : Finset α} (h : s ⊆ t) (h₂ : #t ≤ #s) : s = t :=\n  eq_of_veq <| Multiset.eq_of_le_of_card_le (val_le_iff.mpr h) h₂\n\n"}
{"name":"Finset.eq_iff_card_le_of_subset","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nhst : HasSubset.Subset s t\n⊢ Iff (LE.le t.card s.card) (Eq s t)","decl":"theorem eq_iff_card_le_of_subset (hst : s ⊆ t) : #t ≤ #s ↔ s = t :=\n  ⟨eq_of_subset_of_card_le hst, (ge_of_eq <| congr_arg _ ·)⟩\n\n"}
{"name":"Finset.eq_of_superset_of_card_ge","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nhst : HasSubset.Subset s t\nhts : LE.le t.card s.card\n⊢ Eq t s","decl":"theorem eq_of_superset_of_card_ge (hst : s ⊆ t) (hts : #t ≤ #s) : t = s :=\n  (eq_of_subset_of_card_le hst hts).symm\n\n"}
{"name":"Finset.eq_iff_card_ge_of_superset","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nhst : HasSubset.Subset s t\n⊢ Iff (LE.le t.card s.card) (Eq t s)","decl":"theorem eq_iff_card_ge_of_superset (hst : s ⊆ t) : #t ≤ #s ↔ t = s :=\n  (eq_iff_card_le_of_subset hst).trans eq_comm\n\n"}
{"name":"Finset.subset_iff_eq_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nh : LE.le t.card s.card\n⊢ Iff (HasSubset.Subset s t) (Eq s t)","decl":"theorem subset_iff_eq_of_card_le (h : #t ≤ #s) : s ⊆ t ↔ s = t :=\n  ⟨fun hst => eq_of_subset_of_card_le hst h, Eq.subset'⟩\n\n"}
{"name":"Finset.map_eq_of_subset","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nf : Function.Embedding α α\nhs : HasSubset.Subset (Finset.map f s) s\n⊢ Eq (Finset.map f s) s","decl":"theorem map_eq_of_subset {f : α ↪ α} (hs : s.map f ⊆ s) : s.map f = s :=\n  eq_of_subset_of_card_le hs (card_map _).ge\n\n"}
{"name":"Finset.card_filter_eq_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Iff (Eq (Finset.filter p s).card s.card) (∀ (x : α), Membership.mem s x → p x)","decl":"theorem card_filter_eq_iff {p : α → Prop} [DecidablePred p] :\n    #(s.filter p) = #s ↔ ∀ x ∈ s, p x := by\n  rw [(card_filter_le s p).eq_iff_not_lt, not_lt, eq_iff_card_le_of_subset (filter_subset p s),\n    filter_eq_self]\n\n"}
{"name":"Finset.filter_card_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\na✝¹ : Eq (Finset.filter p s).card s.card\nx : α\na✝ : Membership.mem s x\n⊢ p x","decl":"alias ⟨filter_card_eq, _⟩ := card_filter_eq_iff\n\n"}
{"name":"Finset.card_filter_eq_zero_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Iff (Eq (Finset.filter p s).card 0) (∀ (x : α), Membership.mem s x → Not (p x))","decl":"theorem card_filter_eq_zero_iff {p : α → Prop} [DecidablePred p] :\n    #(s.filter p) = 0 ↔ ∀ x ∈ s, ¬ p x := by\n  rw [card_eq_zero, filter_eq_empty_iff]\n\n"}
{"name":"Finset.card_lt_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nh : HasSSubset.SSubset s t\n⊢ LT.lt s.card t.card","decl":"nonrec lemma card_lt_card (h : s ⊂ t) : #s < #t := card_lt_card <| val_lt_iff.2 h\n\n"}
{"name":"Finset.card_strictMono","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\n⊢ StrictMono Finset.card","decl":"lemma card_strictMono : StrictMono (card : Finset α → ℕ) := fun _ _ ↦ card_lt_card\n\n"}
{"name":"Finset.card_eq_of_bijective","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\nf : (i : Nat) → LT.lt i n → α\nhf : ∀ (a : α), Membership.mem s a → Exists fun i => Exists fun h => Eq (f i h) a\nhf' : ∀ (i : Nat) (h : LT.lt i n), Membership.mem s (f i h)\nf_inj : ∀ (i j : Nat) (hi : LT.lt i n) (hj : LT.lt j n), Eq (f i hi) (f j hj) → Eq i j\n⊢ Eq s.card n","decl":"theorem card_eq_of_bijective (f : ∀ i, i < n → α) (hf : ∀ a ∈ s, ∃ i, ∃ h : i < n, f i h = a)\n    (hf' : ∀ i (h : i < n), f i h ∈ s)\n    (f_inj : ∀ i j (hi : i < n) (hj : j < n), f i hi = f j hj → i = j) : #s = n := by\n  classical\n  have : s = (range n).attach.image fun i => f i.1 (mem_range.1 i.2) := by\n    ext a\n    suffices _ : a ∈ s ↔ ∃ (i : _) (hi : i ∈ range n), f i (mem_range.1 hi) = a by\n      simpa only [mem_image, mem_attach, true_and, Subtype.exists]\n    constructor\n    · intro ha; obtain ⟨i, hi, rfl⟩ := hf a ha; use i, mem_range.2 hi\n    · rintro ⟨i, hi, rfl⟩; apply hf'\n  calc\n    #s = #((range n).attach.image fun i => f i.1 (mem_range.1 i.2)) := by rw [this]\n    _ = #(range n).attach := ?_\n    _ = #(range n) := card_attach\n    _ = n := card_range n\n  apply card_image_of_injective\n  intro ⟨i, hi⟩ ⟨j, hj⟩ eq\n  exact Subtype.eq <| f_inj i j (mem_range.1 hi) (mem_range.1 hj) eq\n\n"}
{"name":"Finset.card_bij","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ni : (a : α) → Membership.mem s a → β\nhi : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (i a ha)\ni_inj : ∀ (a₁ : α) (ha₁ : Membership.mem s a₁) (a₂ : α) (ha₂ : Membership.mem s a₂), Eq (i a₁ ha₁) (i a₂ ha₂) → Eq a₁ a₂\ni_surj : ∀ (b : β), Membership.mem t b → Exists fun a => Exists fun ha => Eq (i a ha) b\n⊢ Eq s.card t.card","decl":"/-- Reorder a finset.\n\nThe difference with `Finset.card_bij'` is that the bijection is specified as a surjective injection,\nrather than by an inverse function.\n\nThe difference with `Finset.card_nbij` is that the bijection is allowed to use membership of the\ndomain, rather than being a non-dependent function. -/\nlemma card_bij (i : ∀ a ∈ s, β) (hi : ∀ a ha, i a ha ∈ t)\n    (i_inj : ∀ a₁ ha₁ a₂ ha₂, i a₁ ha₁ = i a₂ ha₂ → a₁ = a₂)\n    (i_surj : ∀ b ∈ t, ∃ a ha, i a ha = b) : #s = #t := by\n  classical\n  calc\n    #s = #s.attach := card_attach.symm\n    _ = #(s.attach.image fun a ↦ i a.1 a.2) := Eq.symm ?_\n    _ = #t := ?_\n  · apply card_image_of_injective\n    intro ⟨_, _⟩ ⟨_, _⟩ h\n    simpa using i_inj _ _ _ _ h\n  · congr 1\n    ext b\n    constructor <;> intro h\n    · obtain ⟨_, _, rfl⟩ := mem_image.1 h; apply hi\n    · obtain ⟨a, ha, rfl⟩ := i_surj b h; exact mem_image.2 ⟨⟨a, ha⟩, by simp⟩\n\n"}
{"name":"Finset.card_bij'","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ni : (a : α) → Membership.mem s a → β\nj : (a : β) → Membership.mem t a → α\nhi : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (i a ha)\nhj : ∀ (a : β) (ha : Membership.mem t a), Membership.mem s (j a ha)\nleft_inv : ∀ (a : α) (ha : Membership.mem s a), Eq (j (i a ha) ⋯) a\nright_inv : ∀ (a : β) (ha : Membership.mem t a), Eq (i (j a ha) ⋯) a\n⊢ Eq s.card t.card","decl":"/-- Reorder a finset.\n\nThe difference with `Finset.card_bij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.card_nbij'` is that the bijection and its inverse are allowed to use\nmembership of the domains, rather than being non-dependent functions. -/\nlemma card_bij' (i : ∀ a ∈ s, β) (j : ∀ a ∈ t, α) (hi : ∀ a ha, i a ha ∈ t)\n    (hj : ∀ a ha, j a ha ∈ s) (left_inv : ∀ a ha, j (i a ha) (hi a ha) = a)\n    (right_inv : ∀ a ha, i (j a ha) (hj a ha) = a) : #s = #t := by\n  refine card_bij i hi (fun a1 h1 a2 h2 eq ↦ ?_) (fun b hb ↦ ⟨_, hj b hb, right_inv b hb⟩)\n  rw [← left_inv a1 h1, ← left_inv a2 h2]\n  simp only [eq]\n\n"}
{"name":"Finset.card_nbij","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ni : α → β\nhi : ∀ (a : α), Membership.mem s a → Membership.mem t (i a)\ni_inj : Set.InjOn i ↑s\ni_surj : Set.SurjOn i ↑s ↑t\n⊢ Eq s.card t.card","decl":"/-- Reorder a finset.\n\nThe difference with `Finset.card_nbij'` is that the bijection is specified as a surjective\ninjection, rather than by an inverse function.\n\nThe difference with `Finset.card_bij` is that the bijection is a non-dependent function, rather than\nbeing allowed to use membership of the domain. -/\nlemma card_nbij (i : α → β) (hi : ∀ a ∈ s, i a ∈ t) (i_inj : (s : Set α).InjOn i)\n    (i_surj : (s : Set α).SurjOn i t) : #s = #t :=\n  card_bij (fun a _ ↦ i a) hi i_inj (by simpa using i_surj)\n\n"}
{"name":"Finset.card_nbij'","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ni : α → β\nj : β → α\nhi : ∀ (a : α), Membership.mem s a → Membership.mem t (i a)\nhj : ∀ (a : β), Membership.mem t a → Membership.mem s (j a)\nleft_inv : ∀ (a : α), Membership.mem s a → Eq (j (i a)) a\nright_inv : ∀ (a : β), Membership.mem t a → Eq (i (j a)) a\n⊢ Eq s.card t.card","decl":"/-- Reorder a finset.\n\nThe difference with `Finset.card_nbij` is that the bijection is specified with an inverse, rather\nthan as a surjective injection.\n\nThe difference with `Finset.card_bij'` is that the bijection and its inverse are non-dependent\nfunctions, rather than being allowed to use membership of the domains.\n\nThe difference with `Finset.card_equiv` is that bijectivity is only required to hold on the domains,\nrather than on the entire types. -/\nlemma card_nbij' (i : α → β) (j : β → α) (hi : ∀ a ∈ s, i a ∈ t) (hj : ∀ a ∈ t, j a ∈ s)\n    (left_inv : ∀ a ∈ s, j (i a) = a) (right_inv : ∀ a ∈ t, i (j a) = a) : #s = #t :=\n  card_bij' (fun a _ ↦ i a) (fun b _ ↦ j b) hi hj left_inv right_inv\n\n"}
{"name":"Finset.card_equiv","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ne : Equiv α β\nhst : ∀ (i : α), Iff (Membership.mem s i) (Membership.mem t (e i))\n⊢ Eq s.card t.card","decl":"/-- Specialization of `Finset.card_nbij'` that automatically fills in most arguments.\n\nSee `Fintype.card_equiv` for the version where `s` and `t` are `univ`. -/\nlemma card_equiv (e : α ≃ β) (hst : ∀ i, i ∈ s ↔ e i ∈ t) : #s = #t := by\n  refine card_nbij' e e.symm ?_ ?_ ?_ ?_ <;> simp [hst]\n\n"}
{"name":"Finset.card_bijective","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ne : α → β\nhe : Function.Bijective e\nhst : ∀ (i : α), Iff (Membership.mem s i) (Membership.mem t (e i))\n⊢ Eq s.card t.card","decl":"/-- Specialization of `Finset.card_nbij` that automatically fills in most arguments.\n\nSee `Fintype.card_bijective` for the version where `s` and `t` are `univ`. -/\nlemma card_bijective (e : α → β) (he : e.Bijective) (hst : ∀ i, i ∈ s ↔ e i ∈ t) :\n    #s = #t := card_equiv (.ofBijective e he) hst\n\n"}
{"name":"Finset.card_le_card_of_injOn","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : α → β\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nf_inj : Set.InjOn f ↑s\n⊢ LE.le s.card t.card","decl":"lemma card_le_card_of_injOn (f : α → β) (hf : ∀ a ∈ s, f a ∈ t) (f_inj : (s : Set α).InjOn f) :\n    #s ≤ #t := by\n  classical\n  calc\n    #s = #(s.image f) := (card_image_of_injOn f_inj).symm\n    _  ≤ #t           := card_le_card <| image_subset_iff.2 hf\n"}
{"name":"Finset.card_le_card_of_injective","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : (Subtype fun x => Membership.mem s x) → Subtype fun x => Membership.mem t x\nhf : Function.Injective f\n⊢ LE.le s.card t.card","decl":"lemma card_le_card_of_injective {f : s → t} (hf : f.Injective) : #s ≤ #t := by\n  rcases s.eq_empty_or_nonempty with rfl | ⟨a₀, ha₀⟩\n  · simp\n  · classical\n    let f' : α → β := fun a => f (if ha : a ∈ s then ⟨a, ha⟩ else ⟨a₀, ha₀⟩)\n    apply card_le_card_of_injOn f'\n    · aesop\n    · intro a₁ ha₁ a₂ ha₂ haa\n      rw [mem_coe] at ha₁ ha₂\n      simp only [f', ha₁, ha₂, ← Subtype.ext_iff] at haa\n      exact Subtype.ext_iff.mp (hf haa)\n\n"}
{"name":"Finset.card_le_card_of_surjOn","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : α → β\nhf : Set.SurjOn f ↑s ↑t\n⊢ LE.le t.card s.card","decl":"lemma card_le_card_of_surjOn (f : α → β) (hf : Set.SurjOn f s t) : #t ≤ #s := by\n  classical unfold Set.SurjOn at hf; exact (card_le_card (mod_cast hf)).trans card_image_le\n\n"}
{"name":"Finset.exists_ne_map_eq_of_card_lt_of_maps_to","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nhc : LT.lt t.card s.card\nf : α → β\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\n⊢ Exists fun x => And (Membership.mem s x) (Exists fun y => And (Membership.mem s y) (And (Ne x y) (Eq (f x) (f y))))","decl":"/-- If there are more pigeons than pigeonholes, then there are two pigeons in the same pigeonhole.\n-/\ntheorem exists_ne_map_eq_of_card_lt_of_maps_to {t : Finset β} (hc : #t < #s) {f : α → β}\n    (hf : ∀ a ∈ s, f a ∈ t) : ∃ x ∈ s, ∃ y ∈ s, x ≠ y ∧ f x = f y := by\n  classical\n  by_contra! hz\n  refine hc.not_le (card_le_card_of_injOn f hf ?_)\n  intro x hx y hy\n  contrapose\n  exact hz x hx y hy\n\n"}
{"name":"Finset.le_card_of_inj_on_range","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\nf : Nat → α\nhf : ∀ (i : Nat), LT.lt i n → Membership.mem s (f i)\nf_inj : ∀ (i : Nat), LT.lt i n → ∀ (j : Nat), LT.lt j n → Eq (f i) (f j) → Eq i j\n⊢ LE.le n s.card","decl":"lemma le_card_of_inj_on_range (f : ℕ → α) (hf : ∀ i < n, f i ∈ s)\n    (f_inj : ∀ i < n, ∀ j < n, f i = f j → i = j) : n ≤ #s :=\n  calc\n    n = #(range n) := (card_range n).symm\n    _ ≤ #s := card_le_card_of_injOn f (by simpa only [mem_range]) (by simpa)\n\n"}
{"name":"Finset.surjOn_of_injOn_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : α → β\nhf : Set.MapsTo f ↑s ↑t\nhinj : Set.InjOn f ↑s\nhst : LE.le t.card s.card\n⊢ Set.SurjOn f ↑s ↑t","decl":"lemma surjOn_of_injOn_of_card_le (f : α → β) (hf : Set.MapsTo f s t) (hinj : Set.InjOn f s)\n    (hst : #t ≤ #s) : Set.SurjOn f s t := by\n  classical\n  suffices s.image f = t by simp [← this, Set.SurjOn]\n  have : s.image f ⊆ t := by aesop (add simp Finset.subset_iff)\n  exact eq_of_subset_of_card_le this (hst.trans_eq (card_image_of_injOn hinj).symm)\n\n"}
{"name":"Finset.surj_on_of_inj_on_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : (a : α) → Membership.mem s a → β\nhf : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (f a ha)\nhinj : ∀ (a₁ a₂ : α) (ha₁ : Membership.mem s a₁) (ha₂ : Membership.mem s a₂), Eq (f a₁ ha₁) (f a₂ ha₂) → Eq a₁ a₂\nhst : LE.le t.card s.card\nb : β\na✝ : Membership.mem t b\n⊢ Exists fun a => Exists fun ha => Eq b (f a ha)","decl":"lemma surj_on_of_inj_on_of_card_le (f : ∀ a ∈ s, β) (hf : ∀ a ha, f a ha ∈ t)\n    (hinj : ∀ a₁ a₂ ha₁ ha₂, f a₁ ha₁ = f a₂ ha₂ → a₁ = a₂) (hst : #t ≤ #s) :\n    ∀ b ∈ t, ∃ a ha, b = f a ha := by\n  let f' : s → β := fun a ↦ f a a.2\n  have hinj' : Set.InjOn f' s.attach := fun x hx y hy hxy ↦ Subtype.ext (hinj _ _ x.2 y.2 hxy)\n  have hmapsto' : Set.MapsTo f' s.attach t := fun x hx ↦ hf _ _\n  intro b hb\n  obtain ⟨a, ha, rfl⟩ := surjOn_of_injOn_of_card_le _ hmapsto' hinj' (by rwa [card_attach]) hb\n  exact ⟨a, a.2, rfl⟩\n\n"}
{"name":"Finset.injOn_of_surjOn_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : α → β\nhf : Set.MapsTo f ↑s ↑t\nhsurj : Set.SurjOn f ↑s ↑t\nhst : LE.le s.card t.card\n⊢ Set.InjOn f ↑s","decl":"lemma injOn_of_surjOn_of_card_le (f : α → β) (hf : Set.MapsTo f s t) (hsurj : Set.SurjOn f s t)\n    (hst : #s ≤ #t) : Set.InjOn f s := by\n  classical\n  have : s.image f = t := Finset.coe_injective <| by simp [hsurj.image_eq_of_mapsTo hf]\n  have : #(s.image f) = #t := by rw [this]\n  have : #(s.image f) ≤ #s := card_image_le\n  rw [← card_image_iff]\n  omega\n\n"}
{"name":"Finset.inj_on_of_surj_on_of_card_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\nf : (a : α) → Membership.mem s a → β\nhf : ∀ (a : α) (ha : Membership.mem s a), Membership.mem t (f a ha)\nhsurj : ∀ (b : β), Membership.mem t b → Exists fun a => Exists fun ha => Eq (f a ha) b\nhst : LE.le s.card t.card\na₁ : α\nha₁ : Membership.mem s a₁\na₂ : α\nha₂ : Membership.mem s a₂\nha₁a₂ : Eq (f a₁ ha₁) (f a₂ ha₂)\n⊢ Eq a₁ a₂","decl":"theorem inj_on_of_surj_on_of_card_le (f : ∀ a ∈ s, β) (hf : ∀ a ha, f a ha ∈ t)\n    (hsurj : ∀ b ∈ t, ∃ a ha, f a ha = b) (hst : #s ≤ #t) ⦃a₁⦄ (ha₁ : a₁ ∈ s) ⦃a₂⦄\n    (ha₂ : a₂ ∈ s) (ha₁a₂ : f a₁ ha₁ = f a₂ ha₂) : a₁ = a₂ := by\n  let f' : s → β := fun a ↦ f a a.2\n  have hsurj' : Set.SurjOn f' s.attach t := fun x hx ↦ by simpa [f'] using hsurj x hx\n  have hinj' := injOn_of_surjOn_of_card_le f' (fun x hx ↦ hf _ _) hsurj' (by simpa)\n  exact congrArg Subtype.val (@hinj' ⟨a₁, ha₁⟩ (by simp) ⟨a₂, ha₂⟩ (by simp) ha₁a₂)\n\n"}
{"name":"Finset.card_disjUnion","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nh : Disjoint s t\n⊢ Eq (s.disjUnion t h).card (HAdd.hAdd s.card t.card)","decl":"@[simp]\ntheorem card_disjUnion (s t : Finset α) (h) : #(s.disjUnion t h) = #s + #t :=\n  Multiset.card_add _ _\n\n"}
{"name":"Finset.card_union_add_card_inter","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (Union.union s t).card (Inter.inter s t).card) (HAdd.hAdd s.card t.card)","decl":"theorem card_union_add_card_inter (s t : Finset α) :\n    #(s ∪ t) + #(s ∩ t) = #s + #t :=\n  Finset.induction_on t (by simp) fun a r har h => by by_cases a ∈ s <;>\n    simp [*, ← add_assoc, add_right_comm _ 1]\n\n"}
{"name":"Finset.card_inter_add_card_union","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (Inter.inter s t).card (Union.union s t).card) (HAdd.hAdd s.card t.card)","decl":"theorem card_inter_add_card_union (s t : Finset α) :\n    #(s ∩ t) + #(s ∪ t) = #s + #t := by rw [add_comm, card_union_add_card_inter]\n\n"}
{"name":"Finset.card_union","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Union.union s t).card (HSub.hSub (HAdd.hAdd s.card t.card) (Inter.inter s t).card)","decl":"lemma card_union (s t : Finset α) : #(s ∪ t) = #s + #t - #(s ∩ t) := by\n  rw [← card_union_add_card_inter, Nat.add_sub_cancel]\n\n"}
{"name":"Finset.card_inter","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (Inter.inter s t).card (HSub.hSub (HAdd.hAdd s.card t.card) (Union.union s t).card)","decl":"lemma card_inter (s t : Finset α) : #(s ∩ t) = #s + #t - #(s ∪ t) := by\n  rw [← card_inter_add_card_union, Nat.add_sub_cancel]\n\n"}
{"name":"Finset.card_union_le","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ LE.le (Union.union s t).card (HAdd.hAdd s.card t.card)","decl":"theorem card_union_le (s t : Finset α) : #(s ∪ t) ≤ #s + #t :=\n  card_union_add_card_inter s t ▸ Nat.le_add_right _ _\n\n"}
{"name":"Finset.card_union_eq_card_add_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (Eq (Union.union s t).card (HAdd.hAdd s.card t.card)) (Disjoint s t)","decl":"lemma card_union_eq_card_add_card : #(s ∪ t) = #s + #t ↔ Disjoint s t := by\n  rw [← card_union_add_card_inter]; simp [disjoint_iff_inter_eq_empty]\n\n"}
{"name":"Finset.card_union_of_disjoint","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\na✝ : Disjoint s t\n⊢ Eq (Union.union s t).card (HAdd.hAdd s.card t.card)","decl":"@[simp] alias ⟨_, card_union_of_disjoint⟩ := card_union_eq_card_add_card\n\n\n"}
{"name":"Finset.cast_card_inter","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nR : Type u_3\ns t : Finset α\ninst✝¹ : DecidableEq α\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑(Inter.inter s t).card) (HSub.hSub (HAdd.hAdd ↑s.card ↑t.card) ↑(Union.union s t).card)","decl":"lemma cast_card_inter [AddGroupWithOne R] :\n    (#(s ∩ t) : R) = #s + #t - #(s ∪ t) := by\n  rw [eq_sub_iff_add_eq, ← cast_add, card_inter_add_card_union, cast_add]\n\n"}
{"name":"Finset.cast_card_union","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nR : Type u_3\ns t : Finset α\ninst✝¹ : DecidableEq α\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑(Union.union s t).card) (HSub.hSub (HAdd.hAdd ↑s.card ↑t.card) ↑(Inter.inter s t).card)","decl":"lemma cast_card_union [AddGroupWithOne R] :\n    (#(s ∪ t) : R) = #s + #t - #(s ∩ t) := by\n  rw [eq_sub_iff_add_eq, ← cast_add, card_union_add_card_inter, cast_add]\n\n"}
{"name":"Finset.card_sdiff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\nh : HasSubset.Subset s t\n⊢ Eq (SDiff.sdiff t s).card (HSub.hSub t.card s.card)","decl":"theorem card_sdiff (h : s ⊆ t) : #(t \\ s) = #t - #s := by\n  suffices #(t \\ s) = #(t \\ s ∪ s) - #s by rwa [sdiff_union_of_subset h] at this\n  rw [card_union_of_disjoint sdiff_disjoint, Nat.add_sub_cancel_right]\n\n"}
{"name":"Finset.cast_card_sdiff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nR : Type u_3\ns t : Finset α\ninst✝¹ : DecidableEq α\ninst✝ : AddGroupWithOne R\nh : HasSubset.Subset s t\n⊢ Eq (↑(SDiff.sdiff t s).card) (HSub.hSub ↑t.card ↑s.card)","decl":"lemma cast_card_sdiff [AddGroupWithOne R] (h : s ⊆ t) : (#(t \\ s) : R) = #t - #s := by\n  rw [card_sdiff h, Nat.cast_sub (card_mono h)]\n\n"}
{"name":"Finset.card_sdiff_add_card_eq_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ Eq (HAdd.hAdd (SDiff.sdiff t s).card s.card) t.card","decl":"theorem card_sdiff_add_card_eq_card {s t : Finset α} (h : s ⊆ t) : #(t \\ s) + #s = #t :=\n  ((Nat.sub_eq_iff_eq_add (card_le_card h)).mp (card_sdiff h).symm).symm\n\n"}
{"name":"Finset.le_card_sdiff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ LE.le (HSub.hSub t.card s.card) (SDiff.sdiff t s).card","decl":"theorem le_card_sdiff (s t : Finset α) : #t - #s ≤ #(t \\ s) :=\n  calc\n    #t - #s ≤ #t - #(s ∩ t) :=\n      Nat.sub_le_sub_left (card_le_card inter_subset_left) _\n    _ = #(t \\ (s ∩ t)) := (card_sdiff inter_subset_right).symm\n    _ ≤ #(t \\ s) := by rw [sdiff_inter_self_right t s]\n\n"}
{"name":"Finset.card_le_card_sdiff_add_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ LE.le s.card (HAdd.hAdd (SDiff.sdiff s t).card t.card)","decl":"theorem card_le_card_sdiff_add_card : #s ≤ #(s \\ t) + #t :=\n  Nat.sub_le_iff_le_add.1 <| le_card_sdiff _ _\n\n"}
{"name":"Finset.card_sdiff_add_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s t).card t.card) (Union.union s t).card","decl":"theorem card_sdiff_add_card (s t : Finset α) : #(s \\ t) + #t = #(s ∪ t) := by\n  rw [← card_union_of_disjoint sdiff_disjoint, sdiff_union_self_eq_union]\n\n"}
{"name":"Finset.card_sdiff_comm","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\nh : Eq s.card t.card\n⊢ Eq (SDiff.sdiff s t).card (SDiff.sdiff t s).card","decl":"lemma card_sdiff_comm (h : #s = #t) : #(s \\ t) = #(t \\ s) :=\n  add_left_injective #t <| by\n    simp_rw [card_sdiff_add_card, ← h, card_sdiff_add_card, union_comm]\n\n"}
{"name":"Finset.card_sdiff_add_card_inter","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (SDiff.sdiff s t).card (Inter.inter s t).card) s.card","decl":"@[simp]\nlemma card_sdiff_add_card_inter (s t : Finset α) :\n    #(s \\ t) + #(s ∩ t) = #s := by\n  rw [← card_union_of_disjoint (disjoint_sdiff_inter _ _), sdiff_union_inter]\n\n"}
{"name":"Finset.card_inter_add_card_sdiff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HAdd.hAdd (Inter.inter s t).card (SDiff.sdiff s t).card) s.card","decl":"@[simp]\nlemma card_inter_add_card_sdiff (s t : Finset α) :\n    #(s ∩ t) + #(s \\ t) = #s := by\n  rw [add_comm, card_sdiff_add_card_inter]\n\n"}
{"name":"Finset.inter_nonempty_of_card_lt_card_add_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t u : Finset α\ninst✝ : DecidableEq α\nhts : HasSubset.Subset t s\nhus : HasSubset.Subset u s\nhstu : LT.lt s.card (HAdd.hAdd t.card u.card)\n⊢ (Inter.inter t u).Nonempty","decl":"/-- **Pigeonhole principle** for two finsets inside an ambient finset. -/\ntheorem inter_nonempty_of_card_lt_card_add_card (hts : t ⊆ s) (hus : u ⊆ s)\n    (hstu : #s < #t + #u) : (t ∩ u).Nonempty := by\n  contrapose! hstu\n  calc\n    _ = #(t ∪ u) := by simp [← card_union_add_card_inter, not_nonempty_iff_eq_empty.1 hstu]\n    _ ≤ #s := by gcongr; exact union_subset hts hus\n\n"}
{"name":"Finset.filter_card_add_filter_neg_card_eq_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\n⊢ Eq (HAdd.hAdd (Finset.filter p s).card (Finset.filter (fun a => Not (p a)) s).card) s.card","decl":"theorem filter_card_add_filter_neg_card_eq_card\n    (p : α → Prop) [DecidablePred p] [∀ x, Decidable (¬p x)] :\n    #(s.filter p) + #(s.filter fun a ↦ ¬ p a) = #s := by\n  classical\n  rw [← card_union_of_disjoint (disjoint_filter_filter_neg _ _ _), filter_union_filter_neg_eq]\n\n"}
{"name":"Finset.exists_subsuperset_card_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns t : Finset α\nn : Nat\nhst : HasSubset.Subset s t\nhsn : LE.le s.card n\nhnt : LE.le n t.card\n⊢ Exists fun u => And (HasSubset.Subset s u) (And (HasSubset.Subset u t) (Eq u.card n))","decl":"/-- Given a subset `s` of a set `t`, of sizes at most and at least `n` respectively, there exists a\nset `u` of size `n` which is both a superset of `s` and a subset of `t`. -/\nlemma exists_subsuperset_card_eq (hst : s ⊆ t) (hsn : #s ≤ n) (hnt : n ≤ #t) :\n    ∃ u, s ⊆ u ∧ u ⊆ t ∧ #u = n := by\n  classical\n  refine Nat.decreasingInduction' ?_ hnt ⟨t, by simp [hst]⟩\n  intro k _ hnk ⟨u, hu₁, hu₂, hu₃⟩\n  obtain ⟨a, ha⟩ : (u \\ s).Nonempty := by rw [← card_pos, card_sdiff hu₁]; omega\n  simp only [mem_sdiff] at ha\n  exact ⟨u.erase a, by simp [subset_erase, erase_subset_iff_of_mem (hu₂ _), *]⟩\n\n"}
{"name":"Finset.exists_subset_card_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\nhns : LE.le n s.card\n⊢ Exists fun t => And (HasSubset.Subset t s) (Eq t.card n)","decl":"/-- We can shrink a set to any smaller size. -/\nlemma exists_subset_card_eq (hns : n ≤ #s) : ∃ t ⊆ s, #t = n := by\n  simpa using exists_subsuperset_card_eq s.empty_subset (by simp) hns\n\n"}
{"name":"Finset.le_card_iff_exists_subset_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\n⊢ Iff (LE.le n s.card) (Exists fun t => And (HasSubset.Subset t s) (Eq t.card n))","decl":"theorem le_card_iff_exists_subset_card : n ≤ #s ↔ ∃ t ⊆ s, #t = n := by\n  refine ⟨fun h => ?_, fun ⟨t, hst, ht⟩ => ht ▸ card_le_card hst⟩\n  exact exists_subset_card_eq h\n\n"}
{"name":"Finset.exists_subset_or_subset_of_two_mul_lt_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nX Y : Finset α\nn : Nat\nhXY : LT.lt (HMul.hMul 2 n) (Union.union X Y).card\n⊢ Exists fun C => And (LT.lt n C.card) (Or (HasSubset.Subset C X) (HasSubset.Subset C Y))","decl":"theorem exists_subset_or_subset_of_two_mul_lt_card [DecidableEq α] {X Y : Finset α} {n : ℕ}\n    (hXY : 2 * n < #(X ∪ Y)) : ∃ C : Finset α, n < #C ∧ (C ⊆ X ∨ C ⊆ Y) := by\n  have h₁ : #(X ∩ (Y \\ X)) = 0 := Finset.card_eq_zero.mpr (Finset.inter_sdiff_self X Y)\n  have h₂ : #(X ∪ Y) = #X + #(Y \\ X) := by\n    rw [← card_union_add_card_inter X (Y \\ X), Finset.union_sdiff_self_eq_union, h₁, add_zero]\n  rw [h₂, Nat.two_mul] at hXY\n  obtain h | h : n < #X ∨ n < #(Y \\ X) := by contrapose! hXY; omega\n  · exact ⟨X, h, Or.inl (Finset.Subset.refl X)⟩\n  · exact ⟨Y \\ X, h, Or.inr sdiff_subset⟩\n\n"}
{"name":"Finset.card_eq_one","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (Eq s.card 1) (Exists fun a => Eq s (Singleton.singleton a))","decl":"theorem card_eq_one : #s = 1 ↔ ∃ a, s = {a} := by\n  cases s\n  simp only [Multiset.card_eq_one, Finset.card, ← val_inj, singleton_val]\n\n"}
{"name":"Finset.exists_eq_insert_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)) (And (HasSubset.Subset s t) (Eq (HAdd.hAdd s.card 1) t.card))","decl":"theorem exists_eq_insert_iff [DecidableEq α] {s t : Finset α} :\n    (∃ a ∉ s, insert a s = t) ↔ s ⊆ t ∧ #s + 1 = #t := by\n  constructor\n  · rintro ⟨a, ha, rfl⟩\n    exact ⟨subset_insert _ _, (card_insert_of_not_mem ha).symm⟩\n  · rintro ⟨hst, h⟩\n    obtain ⟨a, ha⟩ : ∃ a, t \\ s = {a} :=\n      card_eq_one.1 (by rw [card_sdiff hst, ← h, Nat.add_sub_cancel_left])\n    refine\n      ⟨a, fun hs => (?_ : a ∉ {a}) <| mem_singleton_self _, by\n        rw [insert_eq, ← ha, sdiff_union_of_subset hst]⟩\n    rw [← ha]\n    exact not_mem_sdiff_of_mem_right hs\n\n"}
{"name":"Finset.card_le_one","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LE.le s.card 1) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → Eq a b)","decl":"theorem card_le_one : #s ≤ 1 ↔ ∀ a ∈ s, ∀ b ∈ s, a = b := by\n  obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n  · simp\n  refine (Nat.succ_le_of_lt (card_pos.2 ⟨x, hx⟩)).le_iff_eq.trans (card_eq_one.trans ⟨?_, ?_⟩)\n  · rintro ⟨y, rfl⟩\n    simp\n  · exact fun h => ⟨x, eq_singleton_iff_unique_mem.2 ⟨hx, fun y hy => h _ hy _ hx⟩⟩\n\n"}
{"name":"Finset.card_le_one_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LE.le s.card 1) (∀ {a b : α}, Membership.mem s a → Membership.mem s b → Eq a b)","decl":"theorem card_le_one_iff : #s ≤ 1 ↔ ∀ {a b}, a ∈ s → b ∈ s → a = b := by\n  rw [card_le_one]\n  tauto\n\n"}
{"name":"Finset.card_le_one_iff_subsingleton_coe","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LE.le s.card 1) (Subsingleton (Subtype fun x => Membership.mem s x))","decl":"theorem card_le_one_iff_subsingleton_coe : #s ≤ 1 ↔ Subsingleton (s : Type _) :=\n  card_le_one.trans (s : Set α).subsingleton_coe.symm\n\n"}
{"name":"Finset.card_le_one_iff_subset_singleton","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : Nonempty α\n⊢ Iff (LE.le s.card 1) (Exists fun x => HasSubset.Subset s (Singleton.singleton x))","decl":"theorem card_le_one_iff_subset_singleton [Nonempty α] : #s ≤ 1 ↔ ∃ x : α, s ⊆ {x} := by\n  refine ⟨fun H => ?_, ?_⟩\n  · obtain rfl | ⟨x, hx⟩ := s.eq_empty_or_nonempty\n    · exact ⟨Classical.arbitrary α, empty_subset _⟩\n    · exact ⟨x, fun y hy => by rw [card_le_one.1 H y hy x hx, mem_singleton]⟩\n  · rintro ⟨x, hx⟩\n    rw [← card_singleton x]\n    exact card_le_card hx\n\n"}
{"name":"Finset.exists_mem_ne","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nhs : LT.lt 1 s.card\na : α\n⊢ Exists fun b => And (Membership.mem s b) (Ne b a)","decl":"lemma exists_mem_ne (hs : 1 < #s) (a : α) : ∃ b ∈ s, b ≠ a := by\n  have : Nonempty α := ⟨a⟩\n  by_contra!\n  exact hs.not_le (card_le_one_iff_subset_singleton.2 ⟨a, subset_singleton_iff'.2 this⟩)\n\n"}
{"name":"Finset.card_le_one_of_subsingleton","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\ns : Finset α\n⊢ LE.le s.card 1","decl":"/-- A `Finset` of a subsingleton type has cardinality at most one. -/\ntheorem card_le_one_of_subsingleton [Subsingleton α] (s : Finset α) : #s ≤ 1 :=\n  Finset.card_le_one_iff.2 fun {_ _ _ _} => Subsingleton.elim _ _\n\n"}
{"name":"Finset.one_lt_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 1 s.card) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Ne a b)))","decl":"theorem one_lt_card : 1 < #s ↔ ∃ a ∈ s, ∃ b ∈ s, a ≠ b := by\n  rw [← not_iff_not]\n  push_neg\n  exact card_le_one\n\n"}
{"name":"Finset.one_lt_card_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 1 s.card) (Exists fun a => Exists fun b => And (Membership.mem s a) (And (Membership.mem s b) (Ne a b)))","decl":"theorem one_lt_card_iff : 1 < #s ↔ ∃ a b, a ∈ s ∧ b ∈ s ∧ a ≠ b := by\n  rw [one_lt_card]\n  simp only [exists_prop, exists_and_left]\n\n"}
{"name":"Finset.one_lt_card_iff_nontrivial","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 1 s.card) s.Nontrivial","decl":"theorem one_lt_card_iff_nontrivial : 1 < #s ↔ s.Nontrivial := by\n  rw [← not_iff_not, not_lt, Finset.Nontrivial, ← Set.nontrivial_coe_sort,\n    not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton_coe, coe_sort_coe]\n\n"}
{"name":"Finset.exists_ne_of_one_lt_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nhs : LT.lt 1 s.card\na : α\n⊢ Exists fun b => And (Membership.mem s b) (Ne b a)","decl":"theorem exists_ne_of_one_lt_card (hs : 1 < #s) (a : α) : ∃ b, b ∈ s ∧ b ≠ a := by\n  obtain ⟨x, hx, y, hy, hxy⟩ := Finset.one_lt_card.mp hs\n  by_cases ha : y = a\n  · exact ⟨x, hx, ne_of_ne_of_eq hxy ha⟩\n  · exact ⟨y, hy, ha⟩\n\n"}
{"name":"Finset.exists_of_one_lt_card_pi","module":"Mathlib.Data.Finset.Card","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝ : (i : ι) → DecidableEq (α i)\ns : Finset ((i : ι) → α i)\nh : LT.lt 1 s.card\n⊢ Exists fun i => And (LT.lt 1 (Finset.image (fun x => x i) s).card) (∀ (ai : α i), HasSSubset.SSubset (Finset.filter (fun x => Eq (x i) ai) s) s)","decl":"/-- If a Finset in a Pi type is nontrivial (has at least two elements), then\n  its projection to some factor is nontrivial, and the fibers of the projection\n  are proper subsets. -/\nlemma exists_of_one_lt_card_pi {ι : Type*} {α : ι → Type*} [∀ i, DecidableEq (α i)]\n    {s : Finset (∀ i, α i)} (h : 1 < #s) :\n    ∃ i, 1 < #(s.image (· i)) ∧ ∀ ai, s.filter (· i = ai) ⊂ s := by\n  simp_rw [one_lt_card_iff, Function.ne_iff] at h ⊢\n  obtain ⟨a1, a2, h1, h2, i, hne⟩ := h\n  refine ⟨i, ⟨_, _, mem_image_of_mem _ h1, mem_image_of_mem _ h2, hne⟩, fun ai => ?_⟩\n  rw [filter_ssubset]\n  obtain rfl | hne := eq_or_ne (a2 i) ai\n  exacts [⟨a1, h1, hne⟩, ⟨a2, h2, hne⟩]\n\n"}
{"name":"Finset.card_eq_succ_iff_cons","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\n⊢ Iff (Eq s.card (HAdd.hAdd n 1)) (Exists fun a => Exists fun t => Exists fun h => And (Eq (Finset.cons a t h) s) (Eq t.card n))","decl":"theorem card_eq_succ_iff_cons :\n    #s = n + 1 ↔ ∃ a t, ∃ (h : a ∉ t), cons a t h = s ∧ #t = n :=\n  ⟨cons_induction_on s (by simp) fun a s _ _ _ => ⟨a, s, by simp_all⟩,\n   fun ⟨a, t, _, hs, _⟩ => by simpa [← hs]⟩\n\n"}
{"name":"Finset.card_eq_succ","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\ninst✝ : DecidableEq α\n⊢ Iff (Eq s.card (HAdd.hAdd n 1)) (Exists fun a => Exists fun t => And (Not (Membership.mem t a)) (And (Eq (Insert.insert a t) s) (Eq t.card n)))","decl":"theorem card_eq_succ : #s = n + 1 ↔ ∃ a t, a ∉ t ∧ insert a t = s ∧ #t = n :=\n  ⟨fun h =>\n    let ⟨a, has⟩ := card_pos.mp (h.symm ▸ Nat.zero_lt_succ _ : 0 < #s)\n    ⟨a, s.erase a, s.not_mem_erase a, insert_erase has, by\n      simp only [h, card_erase_of_mem has, Nat.add_sub_cancel_right]⟩,\n    fun ⟨_, _, hat, s_eq, n_eq⟩ => s_eq ▸ n_eq ▸ card_insert_of_not_mem hat⟩\n\n"}
{"name":"Finset.card_eq_two","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (Eq s.card 2) (Exists fun x => Exists fun y => And (Ne x y) (Eq s (Insert.insert x (Singleton.singleton y))))","decl":"theorem card_eq_two : #s = 2 ↔ ∃ x y, x ≠ y ∧ s = {x, y} := by\n  constructor\n  · rw [card_eq_succ]\n    simp_rw [card_eq_one]\n    rintro ⟨a, _, hab, rfl, b, rfl⟩\n    exact ⟨a, b, not_mem_singleton.1 hab, rfl⟩\n  · rintro ⟨x, y, h, rfl⟩\n    exact card_pair h\n\n"}
{"name":"Finset.card_eq_three","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (Eq s.card 3) (Exists fun x => Exists fun y => Exists fun z => And (Ne x y) (And (Ne x z) (And (Ne y z) (Eq s (Insert.insert x (Insert.insert y (Singleton.singleton z)))))))","decl":"theorem card_eq_three : #s = 3 ↔ ∃ x y z, x ≠ y ∧ x ≠ z ∧ y ≠ z ∧ s = {x, y, z} := by\n  constructor\n  · rw [card_eq_succ]\n    simp_rw [card_eq_two]\n    rintro ⟨a, _, abc, rfl, b, c, bc, rfl⟩\n    rw [mem_insert, mem_singleton, not_or] at abc\n    exact ⟨a, b, c, abc.1, abc.2, bc, rfl⟩\n  · rintro ⟨x, y, z, xy, xz, yz, rfl⟩\n    simp only [xy, xz, yz, mem_insert, card_insert_of_not_mem, not_false_iff, mem_singleton,\n      or_self_iff, card_singleton]\n\n"}
{"name":"Finset.two_lt_card_iff","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 2 s.card) (Exists fun a => Exists fun b => Exists fun c => And (Membership.mem s a) (And (Membership.mem s b) (And (Membership.mem s c) (And (Ne a b) (And (Ne a c) (Ne b c))))))","decl":"theorem two_lt_card_iff : 2 < #s ↔ ∃ a b c, a ∈ s ∧ b ∈ s ∧ c ∈ s ∧ a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  classical\n    simp_rw [lt_iff_add_one_le, le_card_iff_exists_subset_card, reduceAdd, card_eq_three,\n      ← exists_and_left, exists_comm (α := Finset α)]\n    constructor\n    · rintro ⟨a, b, c, t, hsub, hab, hac, hbc, rfl⟩\n      exact ⟨a, b, c, by simp_all [insert_subset_iff]⟩\n    · rintro ⟨a, b, c, ha, hb, hc, hab, hac, hbc⟩\n      exact ⟨a, b, c, {a, b, c}, by simp_all [insert_subset_iff]⟩\n\n"}
{"name":"Finset.two_lt_card","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (LT.lt 2 s.card) (Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem s b) (Exists fun c => And (Membership.mem s c) (And (Ne a b) (And (Ne a c) (Ne b c))))))","decl":"theorem two_lt_card : 2 < #s ↔ ∃ a ∈ s, ∃ b ∈ s, ∃ c ∈ s, a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  simp_rw [two_lt_card_iff, exists_and_left]\n\n"}
{"name":"Finset.strongInduction_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\np : Finset α → Sort u_4\nH : (s : Finset α) → ((t : Finset α) → HasSSubset.SSubset t s → p t) → p s\ns : Finset α\n⊢ Eq (Finset.strongInduction H s) (H s fun t x => Finset.strongInduction H t)","decl":"@[nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem strongInduction_eq {p : Finset α → Sort*} (H : ∀ s, (∀ t ⊂ s, p t) → p s)\n    (s : Finset α) : strongInduction H s = H s fun t _ => strongInduction H t := by\n  rw [strongInduction]\n\n"}
{"name":"Finset.strongInductionOn_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\np : Finset α → Sort u_4\ns : Finset α\nH : (s : Finset α) → ((t : Finset α) → HasSSubset.SSubset t s → p t) → p s\n⊢ Eq (s.strongInductionOn H) (H s fun t x => t.strongInductionOn H)","decl":"@[nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem strongInductionOn_eq {p : Finset α → Sort*} (s : Finset α)\n    (H : ∀ s, (∀ t ⊂ s, p t) → p s) :\n    s.strongInductionOn H = H s fun t _ => t.strongInductionOn H := by\n  dsimp only [strongInductionOn]\n  rw [strongInduction]\n\n"}
{"name":"Finset.case_strong_induction_on","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\np : Finset α → Prop\ns : Finset α\nh₀ : p EmptyCollection.emptyCollection\nh₁ : ∀ (a : α) (s : Finset α), Not (Membership.mem s a) → (∀ (t : Finset α), HasSubset.Subset t s → p t) → p (Insert.insert a s)\n⊢ p s","decl":"@[elab_as_elim]\ntheorem case_strong_induction_on [DecidableEq α] {p : Finset α → Prop} (s : Finset α) (h₀ : p ∅)\n    (h₁ : ∀ a s, a ∉ s → (∀ t ⊆ s, p t) → p (insert a s)) : p s :=\n  Finset.strongInductionOn s fun s =>\n    Finset.induction_on s (fun _ => h₀) fun a s n _ ih =>\n      (h₁ a s n) fun t ss => ih _ (lt_of_le_of_lt ss (ssubset_insert n) : t < _)\n\n"}
{"name":"Finset.Nonempty.strong_induction","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\np : (s : Finset α) → s.Nonempty → Prop\nh₀ : ∀ (a : α), p (Singleton.singleton a) ⋯\nh₁ : ∀ ⦃s : Finset α⦄ (hs : s.Nontrivial), (∀ (t : Finset α) (ht : t.Nonempty), HasSSubset.SSubset t s → p t ht) → p s ⋯\ns : Finset α\nhs : s.Nonempty\n⊢ p s hs","decl":"/-- Suppose that, given objects defined on all nonempty strict subsets of any nontrivial finset `s`,\none knows how to define an object on `s`. Then one can inductively define an object on all finsets,\nstarting from singletons and iterating.\n\nTODO: Currently this can only be used to prove properties.\nReplace `Finset.Nonempty.exists_eq_singleton_or_nontrivial` with computational content\nin order to let `p` be `Sort`-valued. -/\n@[elab_as_elim]\nprotected lemma Nonempty.strong_induction {p : ∀ s, s.Nonempty → Prop}\n    (h₀ : ∀ a, p {a} (singleton_nonempty _))\n    (h₁ : ∀ ⦃s⦄ (hs : s.Nontrivial), (∀ t ht, t ⊂ s → p t ht) → p s hs.nonempty) :\n    ∀ ⦃s : Finset α⦄ (hs), p s hs\n  | s, hs => by\n    obtain ⟨a, rfl⟩ | hs := hs.exists_eq_singleton_or_nontrivial\n    · exact h₀ _\n    · refine h₁ hs fun t ht hts ↦ ?_\n      have := card_lt_card hts\n      exact ht.strong_induction h₀ h₁\ntermination_by s => #s\n\n"}
{"name":"Finset.strongDownwardInduction_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nn : Nat\np : Finset α → Sort u_4\nH : (t₁ : Finset α) → ({t₂ : Finset α} → LE.le t₂.card n → HasSSubset.SSubset t₁ t₂ → p t₂) → LE.le t₁.card n → p t₁\ns : Finset α\n⊢ Eq (Finset.strongDownwardInduction H s) (H s fun {t} ht x => Finset.strongDownwardInduction H t ht)","decl":"@[nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem strongDownwardInduction_eq {p : Finset α → Sort*}\n    (H : ∀ t₁, (∀ {t₂ : Finset α}, #t₂ ≤ n → t₁ ⊂ t₂ → p t₂) → #t₁ ≤ n → p t₁)\n    (s : Finset α) :\n    strongDownwardInduction H s = H s fun {t} ht _ => strongDownwardInduction H t ht := by\n  rw [strongDownwardInduction]\n\n"}
{"name":"Finset.strongDownwardInductionOn_eq","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_1\nn : Nat\np : Finset α → Sort u_4\ns : Finset α\nH : (t₁ : Finset α) → ({t₂ : Finset α} → LE.le t₂.card n → HasSSubset.SSubset t₁ t₂ → p t₂) → LE.le t₁.card n → p t₁\n⊢ Eq (fun a => s.strongDownwardInductionOn H a) (H s fun {t} ht x => t.strongDownwardInductionOn H ht)","decl":"@[nolint unusedHavesSuffices] -- Porting note: false positive\ntheorem strongDownwardInductionOn_eq {p : Finset α → Sort*} (s : Finset α)\n    (H : ∀ t₁, (∀ {t₂ : Finset α}, #t₂ ≤ n → t₁ ⊂ t₂ → p t₂) → #t₁ ≤ n → p t₁) :\n    s.strongDownwardInductionOn H = H s fun {t} ht _ => t.strongDownwardInductionOn H ht := by\n  dsimp only [strongDownwardInductionOn]\n  rw [strongDownwardInduction]\n\n"}
{"name":"Finset.lt_wf","module":"Mathlib.Data.Finset.Card","initialProofState":"α : Type u_4\n⊢ WellFounded LT.lt","decl":"theorem lt_wf {α} : WellFounded (@LT.lt (Finset α) _) :=\n  have H : Subrelation (@LT.lt (Finset α) _) (InvImage (· < ·) card) := fun {_ _} hxy =>\n    card_lt_card hxy\n  Subrelation.wf H <| InvImage.wf _ <| (Nat.lt_wfRel).2\n\n"}
