{"name":"vadd_eq_add","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\ninst✝ : Add α\na a' : α\n⊢ Eq (HVAdd.hVAdd a a') (HAdd.hAdd a a')","decl":"@[to_additive (attr := simp)]\nlemma smul_eq_mul (α : Type*) [Mul α] {a a' : α} : a • a' = a * a' := rfl\n\n"}
{"name":"smul_eq_mul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\ninst✝ : Mul α\na a' : α\n⊢ Eq (HSMul.hSMul a a') (HMul.hMul a a')","decl":"@[to_additive (attr := simp)]\nlemma smul_eq_mul (α : Type*) [Mul α] {a a' : α} : a • a' = a * a' := rfl\n\n"}
{"name":"AddAction.add_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_9\nP : Type u_10\ninst✝ : AddMonoid G\nself : AddAction G P\ng₁ g₂ : G\np : P\n⊢ Eq (HVAdd.hVAdd (HAdd.hAdd g₁ g₂) p) (HVAdd.hVAdd g₁ (HVAdd.hVAdd g₂ p))","decl":"/-- Type class for additive monoid actions. -/\nclass AddAction (G : Type*) (P : Type*) [AddMonoid G] extends VAdd G P where\n  /-- Zero is a neutral element for `+ᵥ` -/\n  protected zero_vadd : ∀ p : P, (0 : G) +ᵥ p = p\n  /-- Associativity of `+` and `+ᵥ` -/\n  add_vadd : ∀ (g₁ g₂ : G) (p : P), (g₁ + g₂) +ᵥ p = g₁ +ᵥ g₂ +ᵥ p\n\n"}
{"name":"AddAction.zero_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_9\nP : Type u_10\ninst✝ : AddMonoid G\nself : AddAction G P\np : P\n⊢ Eq (HVAdd.hVAdd 0 p) p","decl":"/-- Type class for additive monoid actions. -/\nclass AddAction (G : Type*) (P : Type*) [AddMonoid G] extends VAdd G P where\n  /-- Zero is a neutral element for `+ᵥ` -/\n  protected zero_vadd : ∀ p : P, (0 : G) +ᵥ p = p\n  /-- Associativity of `+` and `+ᵥ` -/\n  add_vadd : ∀ (g₁ g₂ : G) (p : P), (g₁ + g₂) +ᵥ p = g₁ +ᵥ g₂ +ᵥ p\n\n"}
{"name":"AddAction.ext","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_9\nP : Type u_10\ninst✝ : AddMonoid G\nx y : AddAction G P\nvadd : Eq VAdd.vadd VAdd.vadd\n⊢ Eq x y","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"AddAction.ext_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_9\nP : Type u_10\ninst✝ : AddMonoid G\nx y : AddAction G P\n⊢ Iff (Eq x y) (Eq VAdd.vadd VAdd.vadd)","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"MulAction.ext","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Monoid α\nx y : MulAction α β\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"MulAction.ext_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Monoid α\nx y : MulAction α β\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"MulAction.mul_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Monoid α\nself : MulAction α β\nx y : α\nb : β\n⊢ Eq (HSMul.hSMul (HMul.hMul x y) b) (HSMul.hSMul x (HSMul.hSMul y b))","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"MulAction.one_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_9\nβ : Type u_10\ninst✝ : Monoid α\nself : MulAction α β\nb : β\n⊢ Eq (HSMul.hSMul 1 b) b","decl":"/-- Typeclass for multiplicative actions by monoids. This generalizes group actions. -/\n@[to_additive (attr := ext)]\nclass MulAction (α : Type*) (β : Type*) [Monoid α] extends SMul α β where\n  /-- One is the neutral element for `•` -/\n  protected one_smul : ∀ b : β, (1 : α) • b = b\n  /-- Associativity of `•` and `*` -/\n  mul_smul : ∀ (x y : α) (b : β), (x * y) • b = x • y • b\n\n"}
{"name":"VAddCommClass.vadd_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝¹ : VAdd M α\ninst✝ : VAdd N α\nself : VAddCommClass M N α\nm : M\nn : N\na : α\n⊢ Eq (HVAdd.hVAdd m (HVAdd.hVAdd n a)) (HVAdd.hVAdd n (HVAdd.hVAdd m a))","decl":"/-- A typeclass mixin saying that two additive actions on the same space commute. -/\nclass VAddCommClass (M N α : Type*) [VAdd M α] [VAdd N α] : Prop where\n  /-- `+ᵥ` is left commutative -/\n  vadd_comm : ∀ (m : M) (n : N) (a : α), m +ᵥ (n +ᵥ a) = n +ᵥ (m +ᵥ a)\n\n"}
{"name":"SMulCommClass.smul_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝¹ : SMul M α\ninst✝ : SMul N α\nself : SMulCommClass M N α\nm : M\nn : N\na : α\n⊢ Eq (HSMul.hSMul m (HSMul.hSMul n a)) (HSMul.hSMul n (HSMul.hSMul m a))","decl":"/-- A typeclass mixin saying that two multiplicative actions on the same space commute. -/\n@[to_additive]\nclass SMulCommClass (M N α : Type*) [SMul M α] [SMul N α] : Prop where\n  /-- `•` is left commutative -/\n  smul_comm : ∀ (m : M) (n : N) (a : α), m • n • a = n • m • a\n\n"}
{"name":"SMulCommClass.symm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝² : SMul M α\ninst✝¹ : SMul N α\ninst✝ : SMulCommClass M N α\n⊢ SMulCommClass N M α","decl":"/-- Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph. -/\n@[to_additive]\nlemma SMulCommClass.symm (M N α : Type*) [SMul M α] [SMul N α] [SMulCommClass M N α] :\n    SMulCommClass N M α where smul_comm a' a b := (smul_comm a a' b).symm\n\n"}
{"name":"VAddCommClass.symm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝² : VAdd M α\ninst✝¹ : VAdd N α\ninst✝ : VAddCommClass M N α\n⊢ VAddCommClass N M α","decl":"/-- Commutativity of actions is a symmetric relation. This lemma can't be an instance because this\nwould cause a loop in the instance search graph. -/\n@[to_additive]\nlemma SMulCommClass.symm (M N α : Type*) [SMul M α] [SMul N α] [SMulCommClass M N α] :\n    SMulCommClass N M α where smul_comm a' a b := (smul_comm a a' b).symm\n\n"}
{"name":"Function.Injective.smulCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : SMul M α\ninst✝³ : SMul N α\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : SMulCommClass M N β\nf : α → β\nhf : Function.Injective f\nh₁ : ∀ (c : M) (x : α), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\nh₂ : ∀ (c : N) (x : α), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\n⊢ SMulCommClass M N α","decl":"@[to_additive]\nlemma Function.Injective.smulCommClass [SMul M α] [SMul N α] [SMul M β] [SMul N β]\n    [SMulCommClass M N β] {f : α → β} (hf : Injective f) (h₁ : ∀ (c : M) x, f (c • x) = c • f x)\n    (h₂ : ∀ (c : N) x, f (c • x) = c • f x) : SMulCommClass M N α where\n  smul_comm c₁ c₂ x := hf <| by simp only [h₁, h₂, smul_comm c₁ c₂ (f x)]\n\n"}
{"name":"Function.Injective.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : VAdd M α\ninst✝³ : VAdd N α\ninst✝² : VAdd M β\ninst✝¹ : VAdd N β\ninst✝ : VAddCommClass M N β\nf : α → β\nhf : Function.Injective f\nh₁ : ∀ (c : M) (x : α), Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))\nh₂ : ∀ (c : N) (x : α), Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))\n⊢ VAddCommClass M N α","decl":"@[to_additive]\nlemma Function.Injective.smulCommClass [SMul M α] [SMul N α] [SMul M β] [SMul N β]\n    [SMulCommClass M N β] {f : α → β} (hf : Injective f) (h₁ : ∀ (c : M) x, f (c • x) = c • f x)\n    (h₂ : ∀ (c : N) x, f (c • x) = c • f x) : SMulCommClass M N α where\n  smul_comm c₁ c₂ x := hf <| by simp only [h₁, h₂, smul_comm c₁ c₂ (f x)]\n\n"}
{"name":"Function.Surjective.smulCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : SMul M α\ninst✝³ : SMul N α\ninst✝² : SMul M β\ninst✝¹ : SMul N β\ninst✝ : SMulCommClass M N α\nf : α → β\nhf : Function.Surjective f\nh₁ : ∀ (c : M) (x : α), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\nh₂ : ∀ (c : N) (x : α), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\n⊢ SMulCommClass M N β","decl":"@[to_additive]\nlemma Function.Surjective.smulCommClass [SMul M α] [SMul N α] [SMul M β] [SMul N β]\n    [SMulCommClass M N α] {f : α → β} (hf : Surjective f) (h₁ : ∀ (c : M) x, f (c • x) = c • f x)\n    (h₂ : ∀ (c : N) x, f (c • x) = c • f x) : SMulCommClass M N β where\n  smul_comm c₁ c₂ := hf.forall.2 fun x ↦ by simp only [← h₁, ← h₂, smul_comm c₁ c₂ x]\n\n"}
{"name":"Function.Surjective.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝⁴ : VAdd M α\ninst✝³ : VAdd N α\ninst✝² : VAdd M β\ninst✝¹ : VAdd N β\ninst✝ : VAddCommClass M N α\nf : α → β\nhf : Function.Surjective f\nh₁ : ∀ (c : M) (x : α), Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))\nh₂ : ∀ (c : N) (x : α), Eq (f (HVAdd.hVAdd c x)) (HVAdd.hVAdd c (f x))\n⊢ VAddCommClass M N β","decl":"@[to_additive]\nlemma Function.Surjective.smulCommClass [SMul M α] [SMul N α] [SMul M β] [SMul N β]\n    [SMulCommClass M N α] {f : α → β} (hf : Surjective f) (h₁ : ∀ (c : M) x, f (c • x) = c • f x)\n    (h₂ : ∀ (c : N) x, f (c • x) = c • f x) : SMulCommClass M N β where\n  smul_comm c₁ c₂ := hf.forall.2 fun x ↦ by simp only [← h₁, ← h₂, smul_comm c₁ c₂ x]\n\n"}
{"name":"vaddCommClass_self","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝¹ : AddCommMonoid M\ninst✝ : AddAction M α\n⊢ VAddCommClass M M α","decl":"@[to_additive]\ninstance smulCommClass_self (M α : Type*) [CommMonoid M] [MulAction M α] : SMulCommClass M M α where\n  smul_comm a a' b := by rw [← mul_smul, mul_comm, mul_smul]\n\n"}
{"name":"smulCommClass_self","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝¹ : CommMonoid M\ninst✝ : MulAction M α\n⊢ SMulCommClass M M α","decl":"@[to_additive]\ninstance smulCommClass_self (M α : Type*) [CommMonoid M] [MulAction M α] : SMulCommClass M M α where\n  smul_comm a a' b := by rw [← mul_smul, mul_comm, mul_smul]\n\n"}
{"name":"VAddAssocClass.vadd_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝² : VAdd M N\ninst✝¹ : VAdd N α\ninst✝ : VAdd M α\nself : VAddAssocClass M N α\nx : M\ny : N\nz : α\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd x y) z) (HVAdd.hVAdd x (HVAdd.hVAdd y z))","decl":"/-- An instance of `VAddAssocClass M N α` states that the additive action of `M` on `α` is\ndetermined by the additive actions of `M` on `N` and `N` on `α`. -/\nclass VAddAssocClass (M N α : Type*) [VAdd M N] [VAdd N α] [VAdd M α] : Prop where\n  /-- Associativity of `+ᵥ` -/\n  vadd_assoc : ∀ (x : M) (y : N) (z : α), (x +ᵥ y) +ᵥ z = x +ᵥ y +ᵥ z\n\n"}
{"name":"IsScalarTower.smul_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\nα : Type u_11\ninst✝² : SMul M N\ninst✝¹ : SMul N α\ninst✝ : SMul M α\nself : IsScalarTower M N α\nx : M\ny : N\nz : α\n⊢ Eq (HSMul.hSMul (HSMul.hSMul x y) z) (HSMul.hSMul x (HSMul.hSMul y z))","decl":"/-- An instance of `IsScalarTower M N α` states that the multiplicative\naction of `M` on `α` is determined by the multiplicative actions of `M` on `N`\nand `N` on `α`. -/\n@[to_additive VAddAssocClass] -- TODO auto-translating\nclass IsScalarTower (M N α : Type*) [SMul M N] [SMul N α] [SMul M α] : Prop where\n  /-- Associativity of `•` -/\n  smul_assoc : ∀ (x : M) (y : N) (z : α), (x • y) • z = x • y • z\n\n"}
{"name":"vadd_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nM : Type u_9\nN : Type u_10\ninst✝³ : VAdd M N\ninst✝² : VAdd N α\ninst✝¹ : VAdd M α\ninst✝ : VAddAssocClass M N α\nx : M\ny : N\nz : α\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd x y) z) (HVAdd.hVAdd x (HVAdd.hVAdd y z))","decl":"@[to_additive (attr := simp)]\nlemma smul_assoc {M N} [SMul M N] [SMul N α] [SMul M α] [IsScalarTower M N α] (x : M) (y : N)\n    (z : α) : (x • y) • z = x • y • z := IsScalarTower.smul_assoc x y z\n\n"}
{"name":"smul_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nM : Type u_9\nN : Type u_10\ninst✝³ : SMul M N\ninst✝² : SMul N α\ninst✝¹ : SMul M α\ninst✝ : IsScalarTower M N α\nx : M\ny : N\nz : α\n⊢ Eq (HSMul.hSMul (HSMul.hSMul x y) z) (HSMul.hSMul x (HSMul.hSMul y z))","decl":"@[to_additive (attr := simp)]\nlemma smul_assoc {M N} [SMul M N] [SMul N α] [SMul M α] [IsScalarTower M N α] (x : M) (y : N)\n    (z : α) : (x • y) • z = x • y • z := IsScalarTower.smul_assoc x y z\n\n"}
{"name":"AddSemigroup.isScalarTower","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\ninst✝ : AddSemigroup α\n⊢ VAddAssocClass α α α","decl":"@[to_additive]\ninstance Semigroup.isScalarTower [Semigroup α] : IsScalarTower α α α := ⟨mul_assoc⟩\n\n"}
{"name":"Semigroup.isScalarTower","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\ninst✝ : Semigroup α\n⊢ IsScalarTower α α α","decl":"@[to_additive]\ninstance Semigroup.isScalarTower [Semigroup α] : IsScalarTower α α α := ⟨mul_assoc⟩\n\n"}
{"name":"IsCentralVAdd.op_vadd_eq_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝¹ : VAdd M α\ninst✝ : VAdd (AddOpposite M) α\nself : IsCentralVAdd M α\nm : M\na : α\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op m) a) (HVAdd.hVAdd m a)","decl":"/-- A typeclass indicating that the right (aka `AddOpposite`) and left actions by `M` on `α` are\nequal, that is that `M` acts centrally on `α`. This can be thought of as a version of commutativity\nfor `+ᵥ`. -/\nclass IsCentralVAdd (M α : Type*) [VAdd M α] [VAdd Mᵃᵒᵖ α] : Prop where\n  /-- The right and left actions of `M` on `α` are equal. -/\n  op_vadd_eq_vadd : ∀ (m : M) (a : α), AddOpposite.op m +ᵥ a = m +ᵥ a\n\n"}
{"name":"IsCentralScalar.op_smul_eq_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝¹ : SMul M α\ninst✝ : SMul (MulOpposite M) α\nself : IsCentralScalar M α\nm : M\na : α\n⊢ Eq (HSMul.hSMul (MulOpposite.op m) a) (HSMul.hSMul m a)","decl":"/-- A typeclass indicating that the right (aka `MulOpposite`) and left actions by `M` on `α` are\nequal, that is that `M` acts centrally on `α`. This can be thought of as a version of commutativity\nfor `•`. -/\n@[to_additive]\nclass IsCentralScalar (M α : Type*) [SMul M α] [SMul Mᵐᵒᵖ α] : Prop where\n  /-- The right and left actions of `M` on `α` are equal. -/\n  op_smul_eq_smul : ∀ (m : M) (a : α), MulOpposite.op m • a = m • a\n\n"}
{"name":"IsCentralVAdd.unop_vadd_eq_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝² : VAdd M α\ninst✝¹ : VAdd (AddOpposite M) α\ninst✝ : IsCentralVAdd M α\nm : AddOpposite M\na : α\n⊢ Eq (HVAdd.hVAdd (AddOpposite.unop m) a) (HVAdd.hVAdd m a)","decl":"@[to_additive]\nlemma IsCentralScalar.unop_smul_eq_smul {M α : Type*} [SMul M α] [SMul Mᵐᵒᵖ α]\n    [IsCentralScalar M α] (m : Mᵐᵒᵖ) (a : α) : MulOpposite.unop m • a = m • a := by\n  induction m; exact (IsCentralScalar.op_smul_eq_smul _ a).symm\n\n"}
{"name":"IsCentralScalar.unop_smul_eq_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nα : Type u_10\ninst✝² : SMul M α\ninst✝¹ : SMul (MulOpposite M) α\ninst✝ : IsCentralScalar M α\nm : MulOpposite M\na : α\n⊢ Eq (HSMul.hSMul (MulOpposite.unop m) a) (HSMul.hSMul m a)","decl":"@[to_additive]\nlemma IsCentralScalar.unop_smul_eq_smul {M α : Type*} [SMul M α] [SMul Mᵐᵒᵖ α]\n    [IsCentralScalar M α] (m : Mᵐᵒᵖ) (a : α) : MulOpposite.unop m • a = m • a := by\n  induction m; exact (IsCentralScalar.op_smul_eq_smul _ a).symm\n\n"}
{"name":"SMulCommClass.op_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁴ : SMul M α\ninst✝³ : SMul (MulOpposite M) α\ninst✝² : IsCentralScalar M α\ninst✝¹ : SMul N α\ninst✝ : SMulCommClass M N α\n⊢ SMulCommClass (MulOpposite M) N α","decl":"@[to_additive]\ninstance (priority := 50) SMulCommClass.op_left [SMul M α] [SMul Mᵐᵒᵖ α] [IsCentralScalar M α]\n    [SMul N α] [SMulCommClass M N α] : SMulCommClass Mᵐᵒᵖ N α :=\n  ⟨fun m n a ↦ by rw [← unop_smul_eq_smul m (n • a), ← unop_smul_eq_smul m a, smul_comm]⟩\n\n"}
{"name":"VAddCommClass.op_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁴ : VAdd M α\ninst✝³ : VAdd (AddOpposite M) α\ninst✝² : IsCentralVAdd M α\ninst✝¹ : VAdd N α\ninst✝ : VAddCommClass M N α\n⊢ VAddCommClass (AddOpposite M) N α","decl":"@[to_additive]\ninstance (priority := 50) SMulCommClass.op_left [SMul M α] [SMul Mᵐᵒᵖ α] [IsCentralScalar M α]\n    [SMul N α] [SMulCommClass M N α] : SMulCommClass Mᵐᵒᵖ N α :=\n  ⟨fun m n a ↦ by rw [← unop_smul_eq_smul m (n • a), ← unop_smul_eq_smul m a, smul_comm]⟩\n\n"}
{"name":"SMulCommClass.op_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁴ : SMul M α\ninst✝³ : SMul N α\ninst✝² : SMul (MulOpposite N) α\ninst✝¹ : IsCentralScalar N α\ninst✝ : SMulCommClass M N α\n⊢ SMulCommClass M (MulOpposite N) α","decl":"@[to_additive]\ninstance (priority := 50) SMulCommClass.op_right [SMul M α] [SMul N α] [SMul Nᵐᵒᵖ α]\n    [IsCentralScalar N α] [SMulCommClass M N α] : SMulCommClass M Nᵐᵒᵖ α :=\n  ⟨fun m n a ↦ by rw [← unop_smul_eq_smul n (m • a), ← unop_smul_eq_smul n a, smul_comm]⟩\n\n"}
{"name":"VAddCommClass.op_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁴ : VAdd M α\ninst✝³ : VAdd N α\ninst✝² : VAdd (AddOpposite N) α\ninst✝¹ : IsCentralVAdd N α\ninst✝ : VAddCommClass M N α\n⊢ VAddCommClass M (AddOpposite N) α","decl":"@[to_additive]\ninstance (priority := 50) SMulCommClass.op_right [SMul M α] [SMul N α] [SMul Nᵐᵒᵖ α]\n    [IsCentralScalar N α] [SMulCommClass M N α] : SMulCommClass M Nᵐᵒᵖ α :=\n  ⟨fun m n a ↦ by rw [← unop_smul_eq_smul n (m • a), ← unop_smul_eq_smul n a, smul_comm]⟩\n\n"}
{"name":"IsScalarTower.op_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁷ : SMul M α\ninst✝⁶ : SMul (MulOpposite M) α\ninst✝⁵ : IsCentralScalar M α\ninst✝⁴ : SMul M N\ninst✝³ : SMul (MulOpposite M) N\ninst✝² : IsCentralScalar M N\ninst✝¹ : SMul N α\ninst✝ : IsScalarTower M N α\n⊢ IsScalarTower (MulOpposite M) N α","decl":"@[to_additive]\ninstance (priority := 50) IsScalarTower.op_left [SMul M α] [SMul Mᵐᵒᵖ α] [IsCentralScalar M α]\n    [SMul M N] [SMul Mᵐᵒᵖ N] [IsCentralScalar M N] [SMul N α] [IsScalarTower M N α] :\n    IsScalarTower Mᵐᵒᵖ N α where\n  smul_assoc m n a := by rw [← unop_smul_eq_smul m (n • a), ← unop_smul_eq_smul m n, smul_assoc]\n\n"}
{"name":"VAddAssocClass.op_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁷ : VAdd M α\ninst✝⁶ : VAdd (AddOpposite M) α\ninst✝⁵ : IsCentralVAdd M α\ninst✝⁴ : VAdd M N\ninst✝³ : VAdd (AddOpposite M) N\ninst✝² : IsCentralVAdd M N\ninst✝¹ : VAdd N α\ninst✝ : VAddAssocClass M N α\n⊢ VAddAssocClass (AddOpposite M) N α","decl":"@[to_additive]\ninstance (priority := 50) IsScalarTower.op_left [SMul M α] [SMul Mᵐᵒᵖ α] [IsCentralScalar M α]\n    [SMul M N] [SMul Mᵐᵒᵖ N] [IsCentralScalar M N] [SMul N α] [IsScalarTower M N α] :\n    IsScalarTower Mᵐᵒᵖ N α where\n  smul_assoc m n a := by rw [← unop_smul_eq_smul m (n • a), ← unop_smul_eq_smul m n, smul_assoc]\n\n"}
{"name":"IsScalarTower.op_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁵ : SMul M α\ninst✝⁴ : SMul M N\ninst✝³ : SMul N α\ninst✝² : SMul (MulOpposite N) α\ninst✝¹ : IsCentralScalar N α\ninst✝ : IsScalarTower M N α\n⊢ IsScalarTower M (MulOpposite N) α","decl":"@[to_additive]\ninstance (priority := 50) IsScalarTower.op_right [SMul M α] [SMul M N] [SMul N α]\n    [SMul Nᵐᵒᵖ α] [IsCentralScalar N α] [IsScalarTower M N α] : IsScalarTower M Nᵐᵒᵖ α where\n  smul_assoc m n a := by\n    rw [← unop_smul_eq_smul n a, ← unop_smul_eq_smul (m • n) a, MulOpposite.unop_smul, smul_assoc]\n\n"}
{"name":"VAddAssocClass.op_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\ninst✝⁵ : VAdd M α\ninst✝⁴ : VAdd M N\ninst✝³ : VAdd N α\ninst✝² : VAdd (AddOpposite N) α\ninst✝¹ : IsCentralVAdd N α\ninst✝ : VAddAssocClass M N α\n⊢ VAddAssocClass M (AddOpposite N) α","decl":"@[to_additive]\ninstance (priority := 50) IsScalarTower.op_right [SMul M α] [SMul M N] [SMul N α]\n    [SMul Nᵐᵒᵖ α] [IsCentralScalar N α] [IsScalarTower M N α] : IsScalarTower M Nᵐᵒᵖ α where\n  smul_assoc m n a := by\n    rw [← unop_smul_eq_smul n a, ← unop_smul_eq_smul (m • n) a, MulOpposite.unop_smul, smul_assoc]\n\n"}
{"name":"SMul.comp.isScalarTower","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝³ : SMul M α\ninst✝² : SMul M β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower M α β\ng : N → M\n⊢ IsScalarTower N α β","decl":"/-- Given a tower of scalar actions `M → α → β`, if we use `SMul.comp`\nto pull back both of `M`'s actions by a map `g : N → M`, then we obtain a new\ntower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"Given a tower of additive actions `M → α → β`, if we use `SMul.comp` to pull back both of\n`M`'s actions by a map `g : N → M`, then we obtain a new tower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\"]\nlemma comp.isScalarTower [SMul M β] [SMul α β] [IsScalarTower M α β] (g : N → M) : by\n    haveI := comp α g; haveI := comp β g; exact IsScalarTower N α β where\n  __ := comp α g\n  __ := comp β g\n  smul_assoc n := smul_assoc (g n)\n\n"}
{"name":"VAdd.comp.isScalarTower","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝³ : VAdd M α\ninst✝² : VAdd M β\ninst✝¹ : VAdd α β\ninst✝ : VAddAssocClass M α β\ng : N → M\n⊢ VAddAssocClass N α β","decl":"/-- Given a tower of scalar actions `M → α → β`, if we use `SMul.comp`\nto pull back both of `M`'s actions by a map `g : N → M`, then we obtain a new\ntower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"Given a tower of additive actions `M → α → β`, if we use `SMul.comp` to pull back both of\n`M`'s actions by a map `g : N → M`, then we obtain a new tower of scalar actions `N → α → β`.\n\nThis cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables.\"]\nlemma comp.isScalarTower [SMul M β] [SMul α β] [IsScalarTower M α β] (g : N → M) : by\n    haveI := comp α g; haveI := comp β g; exact IsScalarTower N α β where\n  __ := comp α g\n  __ := comp β g\n  smul_assoc n := smul_assoc (g n)\n\n"}
{"name":"VAdd.comp.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : VAdd M α\ninst✝¹ : VAdd β α\ninst✝ : VAddCommClass M β α\ng : N → M\n⊢ VAddCommClass N β α","decl":"/-- This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables.\"]\nlemma comp.smulCommClass [SMul β α] [SMulCommClass M β α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass N β α where\n  __ := comp α g\n  smul_comm n := smul_comm (g n)\n\n"}
{"name":"SMul.comp.smulCommClass","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : SMul M α\ninst✝¹ : SMul β α\ninst✝ : SMulCommClass M β α\ng : N → M\n⊢ SMulCommClass N β α","decl":"/-- This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables.\"]\nlemma comp.smulCommClass [SMul β α] [SMulCommClass M β α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass N β α where\n  __ := comp α g\n  smul_comm n := smul_comm (g n)\n\n"}
{"name":"SMul.comp.smulCommClass'","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : SMul M α\ninst✝¹ : SMul β α\ninst✝ : SMulCommClass β M α\ng : N → M\n⊢ SMulCommClass β N α","decl":"/-- This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables.\"]\nlemma comp.smulCommClass' [SMul β α] [SMulCommClass β M α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass β N α where\n  __ := comp α g\n  smul_comm _ n := smul_comm _ (g n)\n\n"}
{"name":"VAdd.comp.vaddCommClass'","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_5\nβ : Type u_6\ninst✝² : VAdd M α\ninst✝¹ : VAdd β α\ninst✝ : VAddCommClass β M α\ng : N → M\n⊢ VAddCommClass β N α","decl":"/-- This cannot be an instance because it can cause infinite loops whenever the `SMul` arguments\nare still metavariables. -/\n@[to_additive\n\"This cannot be an instance because it can cause infinite loops whenever the `VAdd` arguments\nare still metavariables.\"]\nlemma comp.smulCommClass' [SMul β α] [SMulCommClass β M α] (g : N → M) :\n    haveI := comp α g\n    SMulCommClass β N α where\n  __ := comp α g\n  smul_comm _ n := smul_comm _ (g n)\n\n"}
{"name":"add_vadd_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Add β\ninst✝¹ : VAdd α β\ninst✝ : VAddCommClass α β β\ns : α\nx y : β\n⊢ Eq (HAdd.hAdd x (HVAdd.hVAdd s y)) (HVAdd.hVAdd s (HAdd.hAdd x y))","decl":"/-- Note that the `SMulCommClass α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive] -- Porting note: nolint to_additive_doc\nlemma mul_smul_comm [Mul β] [SMul α β] [SMulCommClass α β β] (s : α) (x y : β) :\n    x * s • y = s • (x * y) := (smul_comm s x y).symm\n\n"}
{"name":"mul_smul_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Mul β\ninst✝¹ : SMul α β\ninst✝ : SMulCommClass α β β\ns : α\nx y : β\n⊢ Eq (HMul.hMul x (HSMul.hSMul s y)) (HSMul.hSMul s (HMul.hMul x y))","decl":"/-- Note that the `SMulCommClass α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive] -- Porting note: nolint to_additive_doc\nlemma mul_smul_comm [Mul β] [SMul α β] [SMulCommClass α β β] (s : α) (x y : β) :\n    x * s • y = s • (x * y) := (smul_comm s x y).symm\n\n"}
{"name":"vadd_add_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Add β\ninst✝¹ : VAdd α β\ninst✝ : VAddAssocClass α β β\nr : α\nx y : β\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd r x) y) (HVAdd.hVAdd r (HAdd.hAdd x y))","decl":"/-- Note that the `IsScalarTower α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive] -- Porting note: nolint to_additive_doc\nlemma smul_mul_assoc [Mul β] [SMul α β] [IsScalarTower α β β] (r : α) (x y : β) :\n    r • x * y = r • (x * y) := smul_assoc r x y\n\n"}
{"name":"smul_mul_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : Mul β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower α β β\nr : α\nx y : β\n⊢ Eq (HMul.hMul (HSMul.hSMul r x) y) (HSMul.hSMul r (HMul.hMul x y))","decl":"/-- Note that the `IsScalarTower α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive] -- Porting note: nolint to_additive_doc\nlemma smul_mul_assoc [Mul β] [SMul α β] [IsScalarTower α β β] (r : α) (x y : β) :\n    r • x * y = r • (x * y) := smul_assoc r x y\n\n"}
{"name":"vadd_sub_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : SubNegMonoid β\ninst✝¹ : VAdd α β\ninst✝ : VAddAssocClass α β β\nr : α\nx y : β\n⊢ Eq (HSub.hSub (HVAdd.hVAdd r x) y) (HVAdd.hVAdd r (HSub.hSub x y))","decl":"/-- Note that the `IsScalarTower α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive]\nlemma smul_div_assoc [DivInvMonoid β] [SMul α β] [IsScalarTower α β β] (r : α) (x y : β) :\n    r • x / y = r • (x / y) := by simp [div_eq_mul_inv, smul_mul_assoc]\n\n"}
{"name":"smul_div_assoc","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝² : DivInvMonoid β\ninst✝¹ : SMul α β\ninst✝ : IsScalarTower α β β\nr : α\nx y : β\n⊢ Eq (HDiv.hDiv (HSMul.hSMul r x) y) (HSMul.hSMul r (HDiv.hDiv x y))","decl":"/-- Note that the `IsScalarTower α β β` typeclass argument is usually satisfied by `Algebra α β`. -/\n@[to_additive]\nlemma smul_div_assoc [DivInvMonoid β] [SMul α β] [IsScalarTower α β β] (r : α) (x y : β) :\n    r • x / y = r • (x / y) := by simp [div_eq_mul_inv, smul_mul_assoc]\n\n"}
{"name":"vadd_vadd_vadd_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\nγ : Type u_7\nδ : Type u_8\ninst✝⁷ : VAdd α β\ninst✝⁶ : VAdd α γ\ninst✝⁵ : VAdd β δ\ninst✝⁴ : VAdd α δ\ninst✝³ : VAdd γ δ\ninst✝² : VAddAssocClass α β δ\ninst✝¹ : VAddAssocClass α γ δ\ninst✝ : VAddCommClass β γ δ\na : α\nb : β\nc : γ\nd : δ\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd a b) (HVAdd.hVAdd c d)) (HVAdd.hVAdd (HVAdd.hVAdd a c) (HVAdd.hVAdd b d))","decl":"@[to_additive]\nlemma smul_smul_smul_comm [SMul α β] [SMul α γ] [SMul β δ] [SMul α δ] [SMul γ δ]\n    [IsScalarTower α β δ] [IsScalarTower α γ δ] [SMulCommClass β γ δ] (a : α) (b : β) (c : γ)\n    (d : δ) : (a • b) • c • d = (a • c) • b • d := by rw [smul_assoc, smul_assoc, smul_comm b]\n\n"}
{"name":"smul_smul_smul_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\nγ : Type u_7\nδ : Type u_8\ninst✝⁷ : SMul α β\ninst✝⁶ : SMul α γ\ninst✝⁵ : SMul β δ\ninst✝⁴ : SMul α δ\ninst✝³ : SMul γ δ\ninst✝² : IsScalarTower α β δ\ninst✝¹ : IsScalarTower α γ δ\ninst✝ : SMulCommClass β γ δ\na : α\nb : β\nc : γ\nd : δ\n⊢ Eq (HSMul.hSMul (HSMul.hSMul a b) (HSMul.hSMul c d)) (HSMul.hSMul (HSMul.hSMul a c) (HSMul.hSMul b d))","decl":"@[to_additive]\nlemma smul_smul_smul_comm [SMul α β] [SMul α γ] [SMul β δ] [SMul α δ] [SMul γ δ]\n    [IsScalarTower α β δ] [IsScalarTower α γ δ] [SMulCommClass β γ δ] (a : α) (b : β) (c : γ)\n    (d : δ) : (a • b) • c • d = (a • c) • b • d := by rw [smul_assoc, smul_assoc, smul_comm b]\n\n"}
{"name":"vadd_add_vadd_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Add α\ninst✝⁴ : Add β\ninst✝³ : VAdd α β\ninst✝² : VAddAssocClass α β β\ninst✝¹ : VAddAssocClass α α β\ninst✝ : VAddCommClass α β β\na : α\nb : β\nc : α\nd : β\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd a b) (HVAdd.hVAdd c d)) (HVAdd.hVAdd (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"/-- Note that the `IsScalarTower α β β` and `SMulCommClass α β β` typeclass arguments are usually\nsatisfied by `Algebra α β`. -/\n@[to_additive]\nlemma smul_mul_smul_comm [Mul α] [Mul β] [SMul α β] [IsScalarTower α β β]\n    [IsScalarTower α α β] [SMulCommClass α β β] (a : α) (b : β) (c : α) (d : β) :\n    (a • b) * (c • d) = (a * c) • (b * d) := by\n  have : SMulCommClass β α β := .symm ..; exact smul_smul_smul_comm a b c d\n\n"}
{"name":"smul_mul_smul_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : SMul α β\ninst✝² : IsScalarTower α β β\ninst✝¹ : IsScalarTower α α β\ninst✝ : SMulCommClass α β β\na : α\nb : β\nc : α\nd : β\n⊢ Eq (HMul.hMul (HSMul.hSMul a b) (HSMul.hSMul c d)) (HSMul.hSMul (HMul.hMul a c) (HMul.hMul b d))","decl":"/-- Note that the `IsScalarTower α β β` and `SMulCommClass α β β` typeclass arguments are usually\nsatisfied by `Algebra α β`. -/\n@[to_additive]\nlemma smul_mul_smul_comm [Mul α] [Mul β] [SMul α β] [IsScalarTower α β β]\n    [IsScalarTower α α β] [SMulCommClass α β β] (a : α) (b : β) (c : α) (d : β) :\n    (a • b) * (c • d) = (a * c) • (b * d) := by\n  have : SMulCommClass β α β := .symm ..; exact smul_smul_smul_comm a b c d\n\n"}
{"name":"smul_mul_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : SMul α β\ninst✝² : IsScalarTower α β β\ninst✝¹ : IsScalarTower α α β\ninst✝ : SMulCommClass α β β\na : α\nb : β\nc : α\nd : β\n⊢ Eq (HMul.hMul (HSMul.hSMul a b) (HSMul.hSMul c d)) (HSMul.hSMul (HMul.hMul a c) (HMul.hMul b d))","decl":"@[to_additive]\nalias smul_mul_smul := smul_mul_smul_comm\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"vadd_add_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Add α\ninst✝⁴ : Add β\ninst✝³ : VAdd α β\ninst✝² : VAddAssocClass α β β\ninst✝¹ : VAddAssocClass α α β\ninst✝ : VAddCommClass α β β\na : α\nb : β\nc : α\nd : β\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd a b) (HVAdd.hVAdd c d)) (HVAdd.hVAdd (HAdd.hAdd a c) (HAdd.hAdd b d))","decl":"@[to_additive]\nalias smul_mul_smul := smul_mul_smul_comm\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"mul_smul_mul_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : SMul α β\ninst✝² : IsScalarTower α β β\ninst✝¹ : IsScalarTower α α β\ninst✝ : SMulCommClass α β β\na b : α\nc d : β\n⊢ Eq (HSMul.hSMul (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (HSMul.hSMul a c) (HSMul.hSMul b d))","decl":"/-- Note that the `IsScalarTower α β β` and `SMulCommClass α β β` typeclass arguments are usually\nsatisfied by `Algebra α β`. -/\n@[to_additive]\nlemma mul_smul_mul_comm [Mul α] [Mul β] [SMul α β] [IsScalarTower α β β]\n    [IsScalarTower α α β] [SMulCommClass α β β] (a b : α) (c d : β) :\n    (a * b) • (c * d) = (a • c) * (b • d) := smul_smul_smul_comm a b c d\n\n"}
{"name":"add_vadd_add_comm","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nβ : Type u_6\ninst✝⁵ : Add α\ninst✝⁴ : Add β\ninst✝³ : VAdd α β\ninst✝² : VAddAssocClass α β β\ninst✝¹ : VAddAssocClass α α β\ninst✝ : VAddCommClass α β β\na b : α\nc d : β\n⊢ Eq (HVAdd.hVAdd (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (HVAdd.hVAdd a c) (HVAdd.hVAdd b d))","decl":"/-- Note that the `IsScalarTower α β β` and `SMulCommClass α β β` typeclass arguments are usually\nsatisfied by `Algebra α β`. -/\n@[to_additive]\nlemma mul_smul_mul_comm [Mul α] [Mul β] [SMul α β] [IsScalarTower α β β]\n    [IsScalarTower α α β] [SMulCommClass α β β] (a b : α) (c d : β) :\n    (a * b) • (c * d) = (a • c) * (b • d) := smul_smul_smul_comm a b c d\n\n"}
{"name":"AddCommute.vadd_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝³ : VAdd M α\ninst✝² : Add α\ninst✝¹ : VAddCommClass M α α\ninst✝ : VAddAssocClass M α α\na b : α\nh : AddCommute a b\nr : M\n⊢ AddCommute a (HVAdd.hVAdd r b)","decl":"@[to_additive]\nlemma Commute.smul_right [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α}\n    (h : Commute a b) (r : M) : Commute a (r • b) :=\n  (mul_smul_comm _ _ _).trans ((congr_arg _ h).trans <| (smul_mul_assoc _ _ _).symm)\n\n"}
{"name":"Commute.smul_right","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝³ : SMul M α\ninst✝² : Mul α\ninst✝¹ : SMulCommClass M α α\ninst✝ : IsScalarTower M α α\na b : α\nh : Commute a b\nr : M\n⊢ Commute a (HSMul.hSMul r b)","decl":"@[to_additive]\nlemma Commute.smul_right [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α}\n    (h : Commute a b) (r : M) : Commute a (r • b) :=\n  (mul_smul_comm _ _ _).trans ((congr_arg _ h).trans <| (smul_mul_assoc _ _ _).symm)\n\n"}
{"name":"Commute.smul_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝³ : SMul M α\ninst✝² : Mul α\ninst✝¹ : SMulCommClass M α α\ninst✝ : IsScalarTower M α α\na b : α\nh : Commute a b\nr : M\n⊢ Commute (HSMul.hSMul r a) b","decl":"@[to_additive]\nlemma Commute.smul_left [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α}\n    (h : Commute a b) (r : M) : Commute (r • a) b := (h.symm.smul_right r).symm\n\n"}
{"name":"AddCommute.vadd_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝³ : VAdd M α\ninst✝² : Add α\ninst✝¹ : VAddCommClass M α α\ninst✝ : VAddAssocClass M α α\na b : α\nh : AddCommute a b\nr : M\n⊢ AddCommute (HVAdd.hVAdd r a) b","decl":"@[to_additive]\nlemma Commute.smul_left [Mul α] [SMulCommClass M α α] [IsScalarTower M α α] {a b : α}\n    (h : Commute a b) (r : M) : Commute (r • a) b := (h.symm.smul_right r).symm\n\n"}
{"name":"smul_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\na₁ a₂ : M\nb : α\n⊢ Eq (HSMul.hSMul a₁ (HSMul.hSMul a₂ b)) (HSMul.hSMul (HMul.hMul a₁ a₂) b)","decl":"@[to_additive]\nlemma smul_smul (a₁ a₂ : M) (b : α) : a₁ • a₂ • b = (a₁ * a₂) • b := (mul_smul _ _ _).symm\n\n"}
{"name":"vadd_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\na₁ a₂ : M\nb : α\n⊢ Eq (HVAdd.hVAdd a₁ (HVAdd.hVAdd a₂ b)) (HVAdd.hVAdd (HAdd.hAdd a₁ a₂) b)","decl":"@[to_additive]\nlemma smul_smul (a₁ a₂ : M) (b : α) : a₁ • a₂ • b = (a₁ * a₂) • b := (mul_smul _ _ _).symm\n\n"}
{"name":"one_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nb : α\n⊢ Eq (HSMul.hSMul 1 b) b","decl":"@[to_additive (attr := simp)]\nlemma one_smul (b : α) : (1 : M) • b = b := MulAction.one_smul _\n\n"}
{"name":"zero_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nb : α\n⊢ Eq (HVAdd.hVAdd 0 b) b","decl":"@[to_additive (attr := simp)]\nlemma one_smul (b : α) : (1 : M) • b = b := MulAction.one_smul _\n\n"}
{"name":"zero_vadd_eq_id","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\n⊢ Eq (fun x => HVAdd.hVAdd 0 x) id","decl":"/-- `SMul` version of `one_mul_eq_id` -/\n@[to_additive \"`VAdd` version of `zero_add_eq_id`\"]\nlemma one_smul_eq_id : (((1 : M) • ·) : α → α) = id := funext <| one_smul _\n\n"}
{"name":"one_smul_eq_id","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\n⊢ Eq (fun x => HSMul.hSMul 1 x) id","decl":"/-- `SMul` version of `one_mul_eq_id` -/\n@[to_additive \"`VAdd` version of `zero_add_eq_id`\"]\nlemma one_smul_eq_id : (((1 : M) • ·) : α → α) = id := funext <| one_smul _\n\n"}
{"name":"comp_vadd_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\na₁ a₂ : M\n⊢ Eq (Function.comp (fun x => HVAdd.hVAdd a₁ x) fun x => HVAdd.hVAdd a₂ x) fun x => HVAdd.hVAdd (HAdd.hAdd a₁ a₂) x","decl":"/-- `SMul` version of `comp_mul_left` -/\n@[to_additive \"`VAdd` version of `comp_add_left`\"]\nlemma comp_smul_left (a₁ a₂ : M) : (a₁ • ·) ∘ (a₂ • ·) = (((a₁ * a₂) • ·) : α → α) :=\n  funext fun _ ↦ (mul_smul _ _ _).symm\n\n"}
{"name":"comp_smul_left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\na₁ a₂ : M\n⊢ Eq (Function.comp (fun x => HSMul.hSMul a₁ x) fun x => HSMul.hSMul a₂ x) fun x => HSMul.hSMul (HMul.hMul a₁ a₂) x","decl":"/-- `SMul` version of `comp_mul_left` -/\n@[to_additive \"`VAdd` version of `comp_add_left`\"]\nlemma comp_smul_left (a₁ a₂ : M) : (a₁ • ·) ∘ (a₂ • ·) = (((a₁ * a₂) • ·) : α → α) :=\n  funext fun _ ↦ (mul_smul _ _ _).symm\n\n"}
{"name":"IsScalarTower.left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\n⊢ IsScalarTower M M α","decl":"@[to_additive]\ninstance IsScalarTower.left : IsScalarTower M M α where\n  smul_assoc x y z := mul_smul x y z\n\n"}
{"name":"VAddAssocClass.left","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\n⊢ VAddAssocClass M M α","decl":"@[to_additive]\ninstance IsScalarTower.left : IsScalarTower M M α where\n  smul_assoc x y z := mul_smul x y z\n\n"}
{"name":"smul_pow","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁴ : Monoid M\ninst✝³ : Monoid N\ninst✝² : MulAction M N\ninst✝¹ : IsScalarTower M N N\ninst✝ : SMulCommClass M N N\nr : M\nx : N\nn : Nat\n⊢ Eq (HPow.hPow (HSMul.hSMul r x) n) (HSMul.hSMul (HPow.hPow r n) (HPow.hPow x n))","decl":"lemma smul_pow (r : M) (x : N) : ∀ n, (r • x) ^ n = r ^ n • x ^ n\n  | 0 => by simp\n  | n + 1 => by rw [pow_succ', smul_pow _ _ n, smul_mul_smul_comm, ← pow_succ', ← pow_succ']\n\n"}
{"name":"inv_smul_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (HSMul.hSMul (Inv.inv g) (HSMul.hSMul g a)) a","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_smul (g : G) (a : α) : g⁻¹ • g • a = a := by rw [smul_smul, inv_mul_cancel, one_smul]\n\n"}
{"name":"neg_vadd_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd (Neg.neg g) (HVAdd.hVAdd g a)) a","decl":"@[to_additive (attr := simp)]\nlemma inv_smul_smul (g : G) (a : α) : g⁻¹ • g • a = a := by rw [smul_smul, inv_mul_cancel, one_smul]\n\n"}
{"name":"vadd_neg_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na : α\n⊢ Eq (HVAdd.hVAdd g (HVAdd.hVAdd (Neg.neg g) a)) a","decl":"@[to_additive (attr := simp)]\nlemma smul_inv_smul (g : G) (a : α) : g • g⁻¹ • a = a := by rw [smul_smul, mul_inv_cancel, one_smul]\n\n"}
{"name":"smul_inv_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na : α\n⊢ Eq (HSMul.hSMul g (HSMul.hSMul (Inv.inv g) a)) a","decl":"@[to_additive (attr := simp)]\nlemma smul_inv_smul (g : G) (a : α) : g • g⁻¹ • a = a := by rw [smul_smul, mul_inv_cancel, one_smul]\n\n"}
{"name":"neg_vadd_eq_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na b : α\n⊢ Iff (Eq (HVAdd.hVAdd (Neg.neg g) a) b) (Eq a (HVAdd.hVAdd g b))","decl":"@[to_additive] lemma inv_smul_eq_iff : g⁻¹ • a = b ↔ a = g • b :=\n  ⟨fun h ↦ by rw [← h, smul_inv_smul], fun h ↦ by rw [h, inv_smul_smul]⟩\n\n"}
{"name":"inv_smul_eq_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na b : α\n⊢ Iff (Eq (HSMul.hSMul (Inv.inv g) a) b) (Eq a (HSMul.hSMul g b))","decl":"@[to_additive] lemma inv_smul_eq_iff : g⁻¹ • a = b ↔ a = g • b :=\n  ⟨fun h ↦ by rw [← h, smul_inv_smul], fun h ↦ by rw [h, inv_smul_smul]⟩\n\n"}
{"name":"eq_neg_vadd_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : AddGroup G\ninst✝ : AddAction G α\ng : G\na b : α\n⊢ Iff (Eq a (HVAdd.hVAdd (Neg.neg g) b)) (Eq (HVAdd.hVAdd g a) b)","decl":"@[to_additive] lemma eq_inv_smul_iff : a = g⁻¹ • b ↔ g • a = b :=\n  ⟨fun h ↦ by rw [h, smul_inv_smul], fun h ↦ by rw [← h, inv_smul_smul]⟩\n\n"}
{"name":"eq_inv_smul_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nα : Type u_5\ninst✝¹ : Group G\ninst✝ : MulAction G α\ng : G\na b : α\n⊢ Iff (Eq a (HSMul.hSMul (Inv.inv g) b)) (Eq (HSMul.hSMul g a) b)","decl":"@[to_additive] lemma eq_inv_smul_iff : a = g⁻¹ • b ↔ g • a = b :=\n  ⟨fun h ↦ by rw [h, smul_inv_smul], fun h ↦ by rw [← h, inv_smul_smul]⟩\n\n"}
{"name":"Commute.smul_right_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nH : Type u_4\ninst✝⁴ : Group G\ng : G\ninst✝³ : Mul H\ninst✝² : MulAction G H\ninst✝¹ : SMulCommClass G H H\ninst✝ : IsScalarTower G H H\na b : H\n⊢ Iff (Commute a (HSMul.hSMul g b)) (Commute a b)","decl":"@[simp] lemma Commute.smul_right_iff : Commute a (g • b) ↔ Commute a b :=\n  ⟨fun h ↦ inv_smul_smul g b ▸ h.smul_right g⁻¹, fun h ↦ h.smul_right g⟩\n\n"}
{"name":"Commute.smul_left_iff","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nH : Type u_4\ninst✝⁴ : Group G\ng : G\ninst✝³ : Mul H\ninst✝² : MulAction G H\ninst✝¹ : SMulCommClass G H H\ninst✝ : IsScalarTower G H H\na b : H\n⊢ Iff (Commute (HSMul.hSMul g a) b) (Commute a b)","decl":"@[simp] lemma Commute.smul_left_iff : Commute (g • a) b ↔ Commute a b := by\n  rw [Commute.symm_iff, Commute.smul_right_iff, Commute.symm_iff]\n\n"}
{"name":"smul_inv","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nH : Type u_4\ninst✝⁴ : Group G\ninst✝³ : Group H\ninst✝² : MulAction G H\ninst✝¹ : SMulCommClass G H H\ninst✝ : IsScalarTower G H H\ng : G\na : H\n⊢ Eq (Inv.inv (HSMul.hSMul g a)) (HSMul.hSMul (Inv.inv g) (Inv.inv a))","decl":"lemma smul_inv (g : G) (a : H) : (g • a)⁻¹ = g⁻¹ • a⁻¹ :=\n  inv_eq_of_mul_eq_one_right <| by rw [smul_mul_smul_comm, mul_inv_cancel, mul_inv_cancel, one_smul]\n\n"}
{"name":"smul_zpow","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"G : Type u_3\nH : Type u_4\ninst✝⁴ : Group G\ninst✝³ : Group H\ninst✝² : MulAction G H\ninst✝¹ : SMulCommClass G H H\ninst✝ : IsScalarTower G H H\ng : G\na : H\nn : Int\n⊢ Eq (HPow.hPow (HSMul.hSMul g a) n) (HSMul.hSMul (HPow.hPow g n) (HPow.hPow a n))","decl":"lemma smul_zpow (g : G) (a : H) (n : ℤ) : (g • a) ^ n = g ^ n • a ^ n := by\n  cases n <;> simp [smul_pow, smul_inv]\n\n"}
{"name":"SMulCommClass.of_commMonoid","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"A : Type u_9\nB : Type u_10\nG : Type u_11\ninst✝⁴ : CommMonoid G\ninst✝³ : SMul A G\ninst✝² : SMul B G\ninst✝¹ : IsScalarTower A G G\ninst✝ : IsScalarTower B G G\n⊢ SMulCommClass A B G","decl":"lemma SMulCommClass.of_commMonoid\n    (A B G : Type*) [CommMonoid G] [SMul A G] [SMul B G]\n    [IsScalarTower A G G] [IsScalarTower B G G] :\n    SMulCommClass A B G where\n  smul_comm r s x := by\n    rw [← one_smul G (s • x), ← smul_assoc, ← one_smul G x, ← smul_assoc s 1 x,\n      smul_comm, smul_assoc, one_smul, smul_assoc, one_smul]\n\n"}
{"name":"MulAction.toFun_apply","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : Monoid M\ninst✝ : MulAction M α\nx : M\ny : α\n⊢ Eq ((MulAction.toFun M α) y x) (HSMul.hSMul x y)","decl":"@[to_additive (attr := simp)]\nlemma toFun_apply (x : M) (y : α) : MulAction.toFun M α y x = x • y := rfl\n\n"}
{"name":"AddAction.toFun_apply","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_1\nα : Type u_5\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M α\nx : M\ny : α\n⊢ Eq ((AddAction.toFun M α) y x) (HVAdd.hVAdd x y)","decl":"@[to_additive (attr := simp)]\nlemma toFun_apply (x : M) (y : α) : MulAction.toFun M α y x = x • y := rfl\n\n"}
{"name":"vadd_zero_vadd","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nM : Type u_9\nN : Type u_10\ninst✝⁴ : AddMonoid N\ninst✝³ : VAdd M N\ninst✝² : AddAction N α\ninst✝¹ : VAdd M α\ninst✝ : VAddAssocClass M N α\nx : M\ny : α\n⊢ Eq (HVAdd.hVAdd (HVAdd.hVAdd x 0) y) (HVAdd.hVAdd x y)","decl":"@[to_additive]\nlemma smul_one_smul {M} (N) [Monoid N] [SMul M N] [MulAction N α] [SMul M α]\n    [IsScalarTower M N α] (x : M) (y : α) : (x • (1 : N)) • y = x • y := by\n  rw [smul_assoc, one_smul]\n\n"}
{"name":"smul_one_smul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"α : Type u_5\nM : Type u_9\nN : Type u_10\ninst✝⁴ : Monoid N\ninst✝³ : SMul M N\ninst✝² : MulAction N α\ninst✝¹ : SMul M α\ninst✝ : IsScalarTower M N α\nx : M\ny : α\n⊢ Eq (HSMul.hSMul (HSMul.hSMul x 1) y) (HSMul.hSMul x y)","decl":"@[to_additive]\nlemma smul_one_smul {M} (N) [Monoid N] [SMul M N] [MulAction N α] [SMul M α]\n    [IsScalarTower M N α] (x : M) (y : α) : (x • (1 : N)) • y = x • y := by\n  rw [smul_assoc, one_smul]\n\n"}
{"name":"vadd_zero_add","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝² : AddZeroClass N\ninst✝¹ : VAdd M N\ninst✝ : VAddAssocClass M N N\nx : M\ny : N\n⊢ Eq (HAdd.hAdd (HVAdd.hVAdd x 0) y) (HVAdd.hVAdd x y)","decl":"@[to_additive (attr := simp)]\nlemma smul_one_mul {M N} [MulOneClass N] [SMul M N] [IsScalarTower M N N] (x : M) (y : N) :\n    x • (1 : N) * y = x • y := by rw [smul_mul_assoc, one_mul]\n\n"}
{"name":"smul_one_mul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝² : MulOneClass N\ninst✝¹ : SMul M N\ninst✝ : IsScalarTower M N N\nx : M\ny : N\n⊢ Eq (HMul.hMul (HSMul.hSMul x 1) y) (HSMul.hSMul x y)","decl":"@[to_additive (attr := simp)]\nlemma smul_one_mul {M N} [MulOneClass N] [SMul M N] [IsScalarTower M N N] (x : M) (y : N) :\n    x • (1 : N) * y = x • y := by rw [smul_mul_assoc, one_mul]\n\n"}
{"name":"mul_smul_one","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝² : MulOneClass N\ninst✝¹ : SMul M N\ninst✝ : SMulCommClass M N N\nx : M\ny : N\n⊢ Eq (HMul.hMul y (HSMul.hSMul x 1)) (HSMul.hSMul x y)","decl":"@[to_additive (attr := simp)]\nlemma mul_smul_one {M N} [MulOneClass N] [SMul M N] [SMulCommClass M N N] (x : M) (y : N) :\n    y * x • (1 : N) = x • y := by rw [← smul_eq_mul, ← smul_comm, smul_eq_mul, mul_one]\n\n"}
{"name":"add_vadd_zero","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝² : AddZeroClass N\ninst✝¹ : VAdd M N\ninst✝ : VAddCommClass M N N\nx : M\ny : N\n⊢ Eq (HAdd.hAdd y (HVAdd.hVAdd x 0)) (HVAdd.hVAdd x y)","decl":"@[to_additive (attr := simp)]\nlemma mul_smul_one {M N} [MulOneClass N] [SMul M N] [SMulCommClass M N N] (x : M) (y : N) :\n    y * x • (1 : N) = x • y := by rw [← smul_eq_mul, ← smul_comm, smul_eq_mul, mul_one]\n\n"}
{"name":"IsScalarTower.of_smul_one_mul","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Monoid N\ninst✝ : SMul M N\nh : ∀ (x : M) (y : N), Eq (HMul.hMul (HSMul.hSMul x 1) y) (HSMul.hSMul x y)\n⊢ IsScalarTower M N N","decl":"@[to_additive]\nlemma IsScalarTower.of_smul_one_mul {M N} [Monoid N] [SMul M N]\n    (h : ∀ (x : M) (y : N), x • (1 : N) * y = x • y) : IsScalarTower M N N :=\n  ⟨fun x y z ↦ by rw [← h, smul_eq_mul, mul_assoc, h, smul_eq_mul]⟩\n\n"}
{"name":"VAddAssocClass.of_vadd_zero_add","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : AddMonoid N\ninst✝ : VAdd M N\nh : ∀ (x : M) (y : N), Eq (HAdd.hAdd (HVAdd.hVAdd x 0) y) (HVAdd.hVAdd x y)\n⊢ VAddAssocClass M N N","decl":"@[to_additive]\nlemma IsScalarTower.of_smul_one_mul {M N} [Monoid N] [SMul M N]\n    (h : ∀ (x : M) (y : N), x • (1 : N) * y = x • y) : IsScalarTower M N N :=\n  ⟨fun x y z ↦ by rw [← h, smul_eq_mul, mul_assoc, h, smul_eq_mul]⟩\n\n"}
{"name":"VAddCommClass.of_add_vadd_zero","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : AddMonoid N\ninst✝ : VAdd M N\nH : ∀ (x : M) (y : N), Eq (HAdd.hAdd y (HVAdd.hVAdd x 0)) (HVAdd.hVAdd x y)\n⊢ VAddCommClass M N N","decl":"@[to_additive]\nlemma SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n    (H : ∀ (x : M) (y : N), y * x • (1 : N) = x • y) : SMulCommClass M N N :=\n  ⟨fun x y z ↦ by rw [← H x z, smul_eq_mul, ← H, smul_eq_mul, mul_assoc]⟩\n\n"}
{"name":"SMulCommClass.of_mul_smul_one","module":"Mathlib.Algebra.Group.Action.Defs","initialProofState":"M : Type u_9\nN : Type u_10\ninst✝¹ : Monoid N\ninst✝ : SMul M N\nH : ∀ (x : M) (y : N), Eq (HMul.hMul y (HSMul.hSMul x 1)) (HSMul.hSMul x y)\n⊢ SMulCommClass M N N","decl":"@[to_additive]\nlemma SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n    (H : ∀ (x : M) (y : N), y * x • (1 : N) = x • y) : SMulCommClass M N N :=\n  ⟨fun x y z ↦ by rw [← H x z, smul_eq_mul, ← H, smul_eq_mul, mul_assoc]⟩\n\n"}
