{"name":"IsLprojection.proj","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\nself : IsLprojection X P\n⊢ IsIdempotentElem P","decl":"/-- A projection on a normed space `X` is said to be an L-projection if, for all `x` in `X`,\n$\\|x\\| = \\|P x\\| + \\|(1 - P) x\\|$.\n\nNote that we write `P • x` instead of `P x` for reasons described in the module docstring.\n-/\nstructure IsLprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Lnorm : ∀ x : X, ‖x‖ = ‖P • x‖ + ‖(1 - P) • x‖\n\n"}
{"name":"IsLprojection.Lnorm","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\nself : IsLprojection X P\nx : X\n⊢ Eq (Norm.norm x) (HAdd.hAdd (Norm.norm (HSMul.hSMul P x)) (Norm.norm (HSMul.hSMul (HSub.hSub 1 P) x)))","decl":"/-- A projection on a normed space `X` is said to be an L-projection if, for all `x` in `X`,\n$\\|x\\| = \\|P x\\| + \\|(1 - P) x\\|$.\n\nNote that we write `P • x` instead of `P x` for reasons described in the module docstring.\n-/\nstructure IsLprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Lnorm : ∀ x : X, ‖x‖ = ‖P • x‖ + ‖(1 - P) • x‖\n\n"}
{"name":"IsMprojection.proj","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\nself : IsMprojection X P\n⊢ IsIdempotentElem P","decl":"/-- A projection on a normed space `X` is said to be an M-projection if, for all `x` in `X`,\n$\\|x\\| = max(\\|P x\\|,\\|(1 - P) x\\|)$.\n\nNote that we write `P • x` instead of `P x` for reasons described in the module docstring.\n-/\nstructure IsMprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Mnorm : ∀ x : X, ‖x‖ = max ‖P • x‖ ‖(1 - P) • x‖\n\n"}
{"name":"IsMprojection.Mnorm","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\nself : IsMprojection X P\nx : X\n⊢ Eq (Norm.norm x) (Max.max (Norm.norm (HSMul.hSMul P x)) (Norm.norm (HSMul.hSMul (HSub.hSub 1 P) x)))","decl":"/-- A projection on a normed space `X` is said to be an M-projection if, for all `x` in `X`,\n$\\|x\\| = max(\\|P x\\|,\\|(1 - P) x\\|)$.\n\nNote that we write `P • x` instead of `P x` for reasons described in the module docstring.\n-/\nstructure IsMprojection (P : M) : Prop where\n  proj : IsIdempotentElem P\n  Mnorm : ∀ x : X, ‖x‖ = max ‖P • x‖ ‖(1 - P) • x‖\n\n"}
{"name":"IsLprojection.Lcomplement","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\nh : IsLprojection X P\n⊢ IsLprojection X (HSub.hSub 1 P)","decl":"theorem Lcomplement {P : M} (h : IsLprojection X P) : IsLprojection X (1 - P) :=\n  ⟨h.proj.one_sub, fun x => by\n    rw [add_comm, sub_sub_cancel]\n    exact h.Lnorm x⟩\n\n"}
{"name":"IsLprojection.Lcomplement_iff","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : M\n⊢ Iff (IsLprojection X P) (IsLprojection X (HSub.hSub 1 P))","decl":"theorem Lcomplement_iff (P : M) : IsLprojection X P ↔ IsLprojection X (1 - P) :=\n  ⟨Lcomplement, fun h => sub_sub_cancel 1 P ▸ h.Lcomplement⟩\n\n"}
{"name":"IsLprojection.commute","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : M\nh₁ : IsLprojection X P\nh₂ : IsLprojection X Q\n⊢ Commute P Q","decl":"theorem commute [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :\n    Commute P Q := by\n  have PR_eq_RPR : ∀ R : M, IsLprojection X R → P * R = R * P * R := fun R h₃ => by\n    -- Porting note: Needed to fix function, which changes indent of following lines\n    refine @eq_of_smul_eq_smul _ X _ _ _ _ fun x => by\n      rw [← norm_sub_eq_zero_iff]\n      have e1 : ‖R • x‖ ≥ ‖R • x‖ + 2 • ‖(P * R) • x - (R * P * R) • x‖ :=\n        calc\n          ‖R • x‖ = ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +\n              (‖(R * R) • x - R • P • R • x‖ + ‖(1 - R) • (1 - P) • R • x‖) := by\n            rw [h₁.Lnorm, h₃.Lnorm, h₃.Lnorm ((1 - P) • R • x), sub_smul 1 P, one_smul, smul_sub,\n              mul_smul]\n          _ = ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +\n              (‖R • x - R • P • R • x‖ + ‖((1 - R) * R) • x - (1 - R) • P • R • x‖) := by\n            rw [h₃.proj.eq, sub_smul 1 P, one_smul, smul_sub, mul_smul]\n          _ = ‖R • P • R • x‖ + ‖(1 - R) • P • R • x‖ +\n              (‖R • x - R • P • R • x‖ + ‖(1 - R) • P • R • x‖) := by\n            rw [sub_mul, h₃.proj.eq, one_mul, sub_self, zero_smul, zero_sub, norm_neg]\n          _ = ‖R • P • R • x‖ + ‖R • x - R • P • R • x‖ + 2 • ‖(1 - R) • P • R • x‖ := by abel\n          _ ≥ ‖R • x‖ + 2 • ‖(P * R) • x - (R * P * R) • x‖ := by\n            rw [GE.ge]\n            have :=\n              add_le_add_right (norm_le_insert' (R • x) (R • P • R • x)) (2 • ‖(1 - R) • P • R • x‖)\n            simpa only [mul_smul, sub_smul, one_smul] using this\n\n      rw [GE.ge] at e1\n      -- Porting note: Bump index in nth_rewrite\n      nth_rewrite 2 [← add_zero ‖R • x‖] at e1\n      rw [add_le_add_iff_left, two_smul, ← two_mul] at e1\n      rw [le_antisymm_iff]\n      refine ⟨?_, norm_nonneg _⟩\n      rwa [← mul_zero (2 : ℝ), mul_le_mul_left (show (0 : ℝ) < 2 by norm_num)] at e1\n  have QP_eq_QPQ : Q * P = Q * P * Q := by\n    have e1 : P * (1 - Q) = P * (1 - Q) - (Q * P - Q * P * Q) :=\n      calc\n        P * (1 - Q) = (1 - Q) * P * (1 - Q) := by rw [PR_eq_RPR (1 - Q) h₂.Lcomplement]\n        _ = P * (1 - Q) - (Q * P - Q * P * Q) := by noncomm_ring\n    rwa [eq_sub_iff_add_eq, add_right_eq_self, sub_eq_zero] at e1\n  show P * Q = Q * P\n  rw [QP_eq_QPQ, PR_eq_RPR Q h₂]\n\n"}
{"name":"IsLprojection.mul","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : M\nh₁ : IsLprojection X P\nh₂ : IsLprojection X Q\n⊢ IsLprojection X (HMul.hMul P Q)","decl":"theorem mul [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :\n    IsLprojection X (P * Q) := by\n  refine ⟨IsIdempotentElem.mul_of_commute (h₁.commute h₂) h₁.proj h₂.proj, ?_⟩\n  intro x\n  refine le_antisymm ?_ ?_\n  · calc\n      ‖x‖ = ‖(P * Q) • x + (x - (P * Q) • x)‖ := by rw [add_sub_cancel ((P * Q) • x) x]\n      _ ≤ ‖(P * Q) • x‖ + ‖x - (P * Q) • x‖ := by apply norm_add_le\n      _ = ‖(P * Q) • x‖ + ‖(1 - P * Q) • x‖ := by rw [sub_smul, one_smul]\n  · calc\n      ‖x‖ = ‖P • Q • x‖ + (‖Q • x - P • Q • x‖ + ‖x - Q • x‖) := by\n        rw [h₂.Lnorm x, h₁.Lnorm (Q • x), sub_smul, one_smul, sub_smul, one_smul, add_assoc]\n      _ ≥ ‖P • Q • x‖ + ‖Q • x - P • Q • x + (x - Q • x)‖ :=\n        ((add_le_add_iff_left ‖P • Q • x‖).mpr (norm_add_le (Q • x - P • Q • x) (x - Q • x)))\n      _ = ‖(P * Q) • x‖ + ‖(1 - P * Q) • x‖ := by\n        rw [sub_add_sub_cancel', sub_smul, one_smul, mul_smul]\n\n"}
{"name":"IsLprojection.join","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : M\nh₁ : IsLprojection X P\nh₂ : IsLprojection X Q\n⊢ IsLprojection X (HSub.hSub (HAdd.hAdd P Q) (HMul.hMul P Q))","decl":"theorem join [FaithfulSMul M X] {P Q : M} (h₁ : IsLprojection X P) (h₂ : IsLprojection X Q) :\n    IsLprojection X (P + Q - P * Q) := by\n  convert (Lcomplement_iff _).mp (h₁.Lcomplement.mul h₂.Lcomplement) using 1\n  noncomm_ring\n\n-- Porting note: Advice is to explicitly name instances\n-- https://github.com/leanprover-community/mathlib4/wiki/Porting-wiki#some-common-fixes\n"}
{"name":"IsLprojection.coe_compl","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : Subtype fun P => IsLprojection X P\n⊢ Eq (↑(HasCompl.compl P)) (HSub.hSub 1 ↑P)","decl":"@[simp]\ntheorem coe_compl (P : { P : M // IsLprojection X P }) : ↑Pᶜ = (1 : M) - ↑P :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_inf","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : Subtype fun P => IsLprojection X P\n⊢ Eq (↑(Min.min P Q)) (HMul.hMul ↑P ↑Q)","decl":"@[simp]\ntheorem coe_inf [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    ↑(P ⊓ Q) = (↑P : M) * ↑Q :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_sup","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : Subtype fun P => IsLprojection X P\n⊢ Eq (↑(Max.max P Q)) (HSub.hSub (HAdd.hAdd ↑P ↑Q) (HMul.hMul ↑P ↑Q))","decl":"@[simp]\ntheorem coe_sup [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    ↑(P ⊔ Q) = (↑P : M) + ↑Q - ↑P * ↑Q :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_sdiff","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : Subtype fun P => IsLprojection X P\n⊢ Eq (↑(SDiff.sdiff P Q)) (HMul.hMul (↑P) (HSub.hSub 1 ↑Q))","decl":"@[simp]\ntheorem coe_sdiff [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    ↑(P \\ Q) = (↑P : M) * (1 - ↑Q) :=\n  rfl\n\n"}
{"name":"IsLprojection.le_def","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q : Subtype fun P => IsLprojection X P\n⊢ Iff (LE.le P Q) (Eq ↑P ↑(Min.min P Q))","decl":"theorem le_def [FaithfulSMul M X] (P Q : { P : M // IsLprojection X P }) :\n    P ≤ Q ↔ (P : M) = ↑(P ⊓ Q) :=\n  Iff.rfl\n\n"}
{"name":"IsLprojection.coe_zero","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coe_zero : ↑(0 : { P : M // IsLprojection X P }) = (0 : M) :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_one","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem coe_one : ↑(1 : { P : M // IsLprojection X P }) = (1 : M) :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_bot","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\n⊢ Eq (↑Bot.bot) 0","decl":"@[simp]\ntheorem coe_bot [FaithfulSMul M X] :\n    -- Porting note: Manual correction of name required here\n    ↑(BoundedOrder.toOrderBot.toBot.bot : { P : M // IsLprojection X P }) = (0 : M) :=\n  rfl\n\n"}
{"name":"IsLprojection.coe_top","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\n⊢ Eq (↑Top.top) 1","decl":"@[simp]\ntheorem coe_top [FaithfulSMul M X] :\n    -- Porting note: Manual correction of name required here\n    ↑(BoundedOrder.toOrderTop.toTop.top : { P : M // IsLprojection X P }) = (1 : M) :=\n  rfl\n\n"}
{"name":"IsLprojection.compl_mul","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : Subtype fun P => IsLprojection X P\nQ : M\n⊢ Eq (HMul.hMul (↑(HasCompl.compl P)) Q) (HSub.hSub Q (HMul.hMul (↑P) Q))","decl":"theorem compl_mul {P : { P : M // IsLprojection X P }} {Q : M} : ↑Pᶜ * Q = Q - ↑P * Q := by\n  rw [coe_compl, sub_mul, one_mul]\n\n"}
{"name":"IsLprojection.mul_compl_self","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝² : NormedAddCommGroup X\nM : Type u_2\ninst✝¹ : Ring M\ninst✝ : Module M X\nP : Subtype fun P => IsLprojection X P\n⊢ Eq (HMul.hMul ↑P ↑(HasCompl.compl P)) 0","decl":"theorem mul_compl_self {P : { P : M // IsLprojection X P }} : (↑P : M) * ↑Pᶜ = 0 := by\n  rw [coe_compl, P.prop.proj.mul_one_sub_self]\n\n"}
{"name":"IsLprojection.distrib_lattice_lemma","module":"Mathlib.Analysis.NormedSpace.MStructure","initialProofState":"X : Type u_1\ninst✝³ : NormedAddCommGroup X\nM : Type u_2\ninst✝² : Ring M\ninst✝¹ : Module M X\ninst✝ : FaithfulSMul M X\nP Q R : Subtype fun P => IsLprojection X P\n⊢ Eq (HMul.hMul (HAdd.hAdd (↑P) (HMul.hMul ↑(HasCompl.compl P) ↑R)) (HAdd.hAdd (↑P) (HMul.hMul (HMul.hMul ↑Q ↑R) ↑(HasCompl.compl P)))) (HAdd.hAdd (↑P) (HMul.hMul (HMul.hMul ↑Q ↑R) ↑(HasCompl.compl P)))","decl":"theorem distrib_lattice_lemma [FaithfulSMul M X] {P Q R : { P : M // IsLprojection X P }} :\n    ((↑P : M) + ↑Pᶜ * R) * (↑P + ↑Q * ↑R * ↑Pᶜ) = ↑P + ↑Q * ↑R * ↑Pᶜ := by\n  rw [add_mul, mul_add, mul_add, (mul_assoc _ (R : M) (↑Q * ↑R * ↑Pᶜ)),\n    ← mul_assoc (R : M) (↑Q * ↑R) _, ← coe_inf Q, (Pᶜ.prop.commute R.prop).eq,\n    ((Q ⊓ R).prop.commute Pᶜ.prop).eq, (R.prop.commute (Q ⊓ R).prop).eq, coe_inf Q,\n    mul_assoc (Q : M), ← mul_assoc, mul_assoc (R : M), (Pᶜ.prop.commute P.prop).eq, mul_compl_self,\n    zero_mul, mul_zero, zero_add, add_zero, ← mul_assoc, P.prop.proj.eq,\n    R.prop.proj.eq, ← coe_inf Q, mul_assoc, ((Q ⊓ R).prop.commute Pᶜ.prop).eq, ← mul_assoc,\n    Pᶜ.prop.proj.eq]\n\n-- Porting note: In mathlib3 we were able to directly show that `{ P : M // IsLprojection X P }` was\n--  an instance of a `DistribLattice`. Trying to do that in mathlib4 fails with \"error:\n-- (deterministic) timeout at 'whnf', maximum number of heartbeats (800000) has been reached\"\n-- My workaround is to show instance Lattice first\n"}
