{"name":"Finset.disjiUnion_val","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\nh : (↑s).PairwiseDisjoint t\n⊢ Eq (s.disjiUnion t h).val (s.val.bind fun a => (t a).val)","decl":"@[simp]\nlemma disjiUnion_val (s : Finset α) (t : α → Finset β) (h) :\n    (s.disjiUnion t h).1 = s.1.bind fun a ↦ (t a).1 := rfl\n\n"}
{"name":"Finset.disjiUnion_empty","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Finset β\n⊢ Eq (EmptyCollection.emptyCollection.disjiUnion t ⋯) EmptyCollection.emptyCollection","decl":"@[simp] lemma disjiUnion_empty (t : α → Finset β) : disjiUnion ∅ t (by simp) = ∅ := rfl\n\n"}
{"name":"Finset.mem_disjiUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\nb : β\nh : (↑s).PairwiseDisjoint t\n⊢ Iff (Membership.mem (s.disjiUnion t h) b) (Exists fun a => And (Membership.mem s a) (Membership.mem (t a) b))","decl":"@[simp] lemma mem_disjiUnion {b : β} {h} : b ∈ s.disjiUnion t h ↔ ∃ a ∈ s, b ∈ t a := by\n  simp only [mem_def, disjiUnion_val, Multiset.mem_bind, exists_prop]\n\n"}
{"name":"Finset.coe_disjiUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\nh : (↑s).PairwiseDisjoint t\n⊢ Eq (↑(s.disjiUnion t h)) (Set.iUnion fun x => Set.iUnion fun h => ↑(t x))","decl":"@[simp, norm_cast]\nlemma coe_disjiUnion {h} : (s.disjiUnion t h : Set β) = ⋃ x ∈ (s : Set α), t x := by\n  simp [Set.ext_iff, mem_disjiUnion, Set.mem_iUnion, mem_coe, imp_true_iff]\n\n"}
{"name":"Finset.disjiUnion_cons","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\ns : Finset α\nha : Not (Membership.mem s a)\nf : α → Finset β\nH : (↑(Finset.cons a s ha)).PairwiseDisjoint f\n⊢ Eq ((Finset.cons a s ha).disjiUnion f H) ((f a).disjUnion (s.disjiUnion f ⋯) ⋯)","decl":"@[simp] lemma disjiUnion_cons (a : α) (s : Finset α) (ha : a ∉ s) (f : α → Finset β) (H) :\n    disjiUnion (cons a s ha) f H =\n    (f a).disjUnion ((s.disjiUnion f) fun _ hb _ hc ↦ H (mem_cons_of_mem hb) (mem_cons_of_mem hc))\n      (disjoint_left.2 fun _ hb h ↦\n        let ⟨_, hc, h⟩ := mem_disjiUnion.mp h\n        disjoint_left.mp\n          (H (mem_cons_self a s) (mem_cons_of_mem hc) (ne_of_mem_of_not_mem hc ha).symm) hb h) :=\n  eq_of_veq <| Multiset.cons_bind _ _ _\n\n"}
{"name":"Finset.singleton_disjiUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Finset β\na : α\nh : (↑(Singleton.singleton a)).PairwiseDisjoint t\n⊢ Eq ((Singleton.singleton a).disjiUnion t h) (t a)","decl":"@[simp] lemma singleton_disjiUnion (a : α) {h} : Finset.disjiUnion {a} t h = t a :=\n  eq_of_veq <| Multiset.singleton_bind _ _\n\n"}
{"name":"Finset.disjiUnion_disjiUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Finset α\nf : α → Finset β\ng : β → Finset γ\nh1 : (↑s).PairwiseDisjoint f\nh2 : (↑(s.disjiUnion f h1)).PairwiseDisjoint g\n⊢ Eq ((s.disjiUnion f h1).disjiUnion g h2) (s.attach.disjiUnion (fun a => (f ↑a).disjiUnion g ⋯) ⋯)","decl":"lemma disjiUnion_disjiUnion (s : Finset α) (f : α → Finset β) (g : β → Finset γ) (h1 h2) :\n    (s.disjiUnion f h1).disjiUnion g h2 =\n      s.attach.disjiUnion\n        (fun a ↦ ((f a).disjiUnion g) fun _ hb _ hc ↦\n            h2 (mem_disjiUnion.mpr ⟨_, a.prop, hb⟩) (mem_disjiUnion.mpr ⟨_, a.prop, hc⟩))\n        fun a _ b _ hab ↦\n        disjoint_left.mpr fun x hxa hxb ↦ by\n          obtain ⟨xa, hfa, hga⟩ := mem_disjiUnion.mp hxa\n          obtain ⟨xb, hfb, hgb⟩ := mem_disjiUnion.mp hxb\n          refine disjoint_left.mp\n            (h2 (mem_disjiUnion.mpr ⟨_, a.prop, hfa⟩) (mem_disjiUnion.mpr ⟨_, b.prop, hfb⟩) ?_) hga\n            hgb\n          rintro rfl\n          exact disjoint_left.mp (h1 a.prop b.prop <| Subtype.coe_injective.ne hab) hfa hfb :=\n  eq_of_veq <| Multiset.bind_assoc.trans (Multiset.attach_bind_coe _ _).symm\n\n"}
{"name":"Finset.sUnion_disjiUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → Finset (Set β)\nI : Finset α\nhf : (↑I).PairwiseDisjoint f\n⊢ Eq (↑(I.disjiUnion f hf)).sUnion (Set.iUnion fun a => Set.iUnion fun h => (↑(f a)).sUnion)","decl":"lemma sUnion_disjiUnion {f : α → Finset (Set β)} (I : Finset α)\n    (hf : (I : Set α).PairwiseDisjoint f) :\n    ⋃₀ (I.disjiUnion f hf : Set (Set β)) = ⋃ a ∈ I, ⋃₀ ↑(f a) := by\n  ext\n  simp only [coe_disjiUnion, Set.mem_sUnion, Set.mem_iUnion, mem_coe, exists_prop]\n  tauto\n\n"}
{"name":"Finset.disjiUnion_filter_eq","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\n⊢ Eq (t.disjiUnion (fun a => Finset.filter (fun x => Eq (f x) a) s) ⋯) (Finset.filter (fun c => Membership.mem t (f c)) s)","decl":"@[simp] lemma disjiUnion_filter_eq (s : Finset α) (t : Finset β) (f : α → β) :\n    t.disjiUnion (fun a ↦ s.filter (f · = a)) pairwiseDisjoint_fibers =\n      s.filter fun c ↦ f c ∈ t :=\n  ext fun b => by simpa using and_comm\n\n"}
{"name":"Finset.disjiUnion_filter_eq_of_maps_to","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nh : ∀ (x : α), Membership.mem s x → Membership.mem t (f x)\n⊢ Eq (t.disjiUnion (fun a => Finset.filter (fun x => Eq (f x) a) s) ⋯) s","decl":"lemma disjiUnion_filter_eq_of_maps_to (h : ∀ x ∈ s, f x ∈ t) :\n    t.disjiUnion (fun a ↦ s.filter (f · = a)) pairwiseDisjoint_fibers = s := by\n  simpa [filter_eq_self]\n\n"}
{"name":"Finset.biUnion_val","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nt : α → Finset β\n⊢ Eq (s.biUnion t).val (s.val.bind fun a => (t a).val).dedup","decl":"@[simp] lemma biUnion_val (s : Finset α) (t : α → Finset β) :\n    (s.biUnion t).1 = (s.1.bind fun a ↦ (t a).1).dedup := rfl\n\n"}
{"name":"Finset.biUnion_empty","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Finset β\ninst✝ : DecidableEq β\n⊢ Eq (EmptyCollection.emptyCollection.biUnion t) EmptyCollection.emptyCollection","decl":"@[simp] lemma biUnion_empty : Finset.biUnion ∅ t = ∅ := rfl\n\n"}
{"name":"Finset.mem_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝ : DecidableEq β\nb : β\n⊢ Iff (Membership.mem (s.biUnion t) b) (Exists fun a => And (Membership.mem s a) (Membership.mem (t a) b))","decl":"@[simp] lemma mem_biUnion {b : β} : b ∈ s.biUnion t ↔ ∃ a ∈ s, b ∈ t a := by\n  simp only [mem_def, biUnion_val, Multiset.mem_dedup, Multiset.mem_bind, exists_prop]\n\n"}
{"name":"Finset.coe_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝ : DecidableEq β\n⊢ Eq (↑(s.biUnion t)) (Set.iUnion fun x => Set.iUnion fun h => ↑(t x))","decl":"@[simp, norm_cast]\nlemma coe_biUnion : (s.biUnion t : Set β) = ⋃ x ∈ (s : Set α), t x := by\n  simp [Set.ext_iff, mem_biUnion, Set.mem_iUnion, mem_coe, imp_true_iff]\n\n"}
{"name":"Finset.biUnion_insert","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Insert.insert a s).biUnion t) (Union.union (t a) (s.biUnion t))","decl":"@[simp]\nlemma biUnion_insert [DecidableEq α] {a : α} : (insert a s).biUnion t = t a ∪ s.biUnion t :=\n  ext fun x ↦ by\n    simp only [mem_biUnion, exists_prop, mem_union, mem_insert, or_and_right, exists_or,\n      exists_eq_left]\n\n"}
{"name":"Finset.biUnion_congr","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Finset α\nt₁ t₂ : α → Finset β\ninst✝ : DecidableEq β\nhs : Eq s₁ s₂\nht : ∀ (a : α), Membership.mem s₁ a → Eq (t₁ a) (t₂ a)\n⊢ Eq (s₁.biUnion t₁) (s₂.biUnion t₂)","decl":"lemma biUnion_congr (hs : s₁ = s₂) (ht : ∀ a ∈ s₁, t₁ a = t₂ a) : s₁.biUnion t₁ = s₂.biUnion t₂ :=\n  ext fun x ↦ by\n    -- Porting note: this entire proof was `simp [or_and_right, exists_or]`\n    simp_rw [mem_biUnion]\n    apply exists_congr\n    simp +contextual only [hs, and_congr_right_iff, ht, implies_true]\n\n"}
{"name":"Finset.disjiUnion_eq_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Finset β\nhf : (↑s).PairwiseDisjoint f\n⊢ Eq (s.disjiUnion f hf) (s.biUnion f)","decl":"@[simp]\nlemma disjiUnion_eq_biUnion (s : Finset α) (f : α → Finset β) (hf) :\n    s.disjiUnion f hf = s.biUnion f := eq_of_veq (s.disjiUnion f hf).nodup.dedup.symm\n\n"}
{"name":"Finset.biUnion_subset","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝ : DecidableEq β\ns' : Finset β\n⊢ Iff (HasSubset.Subset (s.biUnion t) s') (∀ (x : α), Membership.mem s x → HasSubset.Subset (t x) s')","decl":"lemma biUnion_subset {s' : Finset β} : s.biUnion t ⊆ s' ↔ ∀ x ∈ s, t x ⊆ s' := by\n  simp only [subset_iff, mem_biUnion]\n  exact ⟨fun H a ha b hb ↦ H ⟨a, ha, hb⟩, fun H b ⟨a, ha, hb⟩ ↦ H a ha hb⟩\n\n"}
{"name":"Finset.singleton_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nt : α → Finset β\ninst✝ : DecidableEq β\na : α\n⊢ Eq ((Singleton.singleton a).biUnion t) (t a)","decl":"@[simp]\nlemma singleton_biUnion {a : α} : Finset.biUnion {a} t = t a := by\n  classical rw [← insert_emptyc_eq, biUnion_insert, biUnion_empty, union_empty]\n\n"}
{"name":"Finset.biUnion_inter","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Finset β\nt : Finset β\n⊢ Eq (Inter.inter (s.biUnion f) t) (s.biUnion fun x => Inter.inter (f x) t)","decl":"lemma biUnion_inter (s : Finset α) (f : α → Finset β) (t : Finset β) :\n    s.biUnion f ∩ t = s.biUnion fun x ↦ f x ∩ t := by\n  ext x\n  simp only [mem_biUnion, mem_inter]\n  tauto\n\n"}
{"name":"Finset.inter_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nt : Finset β\ns : Finset α\nf : α → Finset β\n⊢ Eq (Inter.inter t (s.biUnion f)) (s.biUnion fun x => Inter.inter t (f x))","decl":"lemma inter_biUnion (t : Finset β) (s : Finset α) (f : α → Finset β) :\n    t ∩ s.biUnion f = s.biUnion fun x ↦ t ∩ f x := by\n  rw [inter_comm, biUnion_inter]\n  simp [inter_comm]\n\n"}
{"name":"Finset.biUnion_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq γ\ns : Finset α\nf : α → Finset β\ng : β → Finset γ\n⊢ Eq ((s.biUnion f).biUnion g) (s.biUnion fun a => (f a).biUnion g)","decl":"lemma biUnion_biUnion [DecidableEq γ] (s : Finset α) (f : α → Finset β) (g : β → Finset γ) :\n    (s.biUnion f).biUnion g = s.biUnion fun a ↦ (f a).biUnion g := by\n  ext\n  simp only [Finset.mem_biUnion, exists_prop]\n  simp_rw [← exists_and_right, ← exists_and_left, and_assoc]\n  rw [exists_comm]\n\n"}
{"name":"Finset.bind_toFinset","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\ns : Multiset α\nt : α → Multiset β\n⊢ Eq (s.bind t).toFinset (s.toFinset.biUnion fun a => (t a).toFinset)","decl":"lemma bind_toFinset [DecidableEq α] (s : Multiset α) (t : α → Multiset β) :\n    (s.bind t).toFinset = s.toFinset.biUnion fun a ↦ (t a).toFinset :=\n  ext fun x ↦ by simp only [Multiset.mem_toFinset, mem_biUnion, Multiset.mem_bind, exists_prop]\n\n"}
{"name":"Finset.biUnion_mono","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt₁ t₂ : α → Finset β\ninst✝ : DecidableEq β\nh : ∀ (a : α), Membership.mem s a → HasSubset.Subset (t₁ a) (t₂ a)\n⊢ HasSubset.Subset (s.biUnion t₁) (s.biUnion t₂)","decl":"lemma biUnion_mono (h : ∀ a ∈ s, t₁ a ⊆ t₂ a) : s.biUnion t₁ ⊆ s.biUnion t₂ := by\n  have : ∀ b a, a ∈ s → b ∈ t₁ a → ∃ a : α, a ∈ s ∧ b ∈ t₂ a := fun b a ha hb ↦\n    ⟨a, ha, Finset.mem_of_subset (h a ha) hb⟩\n  simpa only [subset_iff, mem_biUnion, exists_imp, and_imp, exists_prop]\n\n"}
{"name":"Finset.biUnion_subset_biUnion_of_subset_left","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns₁ s₂ : Finset α\ninst✝ : DecidableEq β\nt : α → Finset β\nh : HasSubset.Subset s₁ s₂\n⊢ HasSubset.Subset (s₁.biUnion t) (s₂.biUnion t)","decl":"lemma biUnion_subset_biUnion_of_subset_left (t : α → Finset β) (h : s₁ ⊆ s₂) :\n    s₁.biUnion t ⊆ s₂.biUnion t := fun x ↦ by\n  simp only [and_imp, mem_biUnion, exists_prop]; exact Exists.imp fun a ha ↦ ⟨h ha.1, ha.2⟩\n\n"}
{"name":"Finset.subset_biUnion_of_mem","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\ninst✝ : DecidableEq β\nu : α → Finset β\nx : α\nxs : Membership.mem s x\n⊢ HasSubset.Subset (u x) (s.biUnion u)","decl":"lemma subset_biUnion_of_mem (u : α → Finset β) {x : α} (xs : x ∈ s) : u x ⊆ s.biUnion u :=\n  singleton_biUnion.superset.trans <|\n    biUnion_subset_biUnion_of_subset_left u <| singleton_subset_iff.2 xs\n\n"}
{"name":"Finset.biUnion_subset_iff_forall_subset","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → Finset β\n⊢ Iff (HasSubset.Subset (s.biUnion f) t) (∀ (x : α), Membership.mem s x → HasSubset.Subset (f x) t)","decl":"@[simp]\nlemma biUnion_subset_iff_forall_subset {α β : Type*} [DecidableEq β] {s : Finset α}\n    {t : Finset β} {f : α → Finset β} : s.biUnion f ⊆ t ↔ ∀ x ∈ s, f x ⊆ t :=\n  ⟨fun h _ hx ↦ (subset_biUnion_of_mem f hx).trans h, fun h _ hx ↦\n    let ⟨_, ha₁, ha₂⟩ := mem_biUnion.mp hx\n    h _ ha₁ ha₂⟩\n\n"}
{"name":"Finset.biUnion_singleton_eq_self","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : DecidableEq α\n⊢ Eq (s.biUnion Singleton.singleton) s","decl":"@[simp]\nlemma biUnion_singleton_eq_self [DecidableEq α] : s.biUnion (singleton : α → Finset α) = s :=\n  ext fun x ↦ by simp only [mem_biUnion, mem_singleton, exists_prop, exists_eq_right']\n\n"}
{"name":"Finset.filter_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ns : Finset α\nf : α → Finset β\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter p (s.biUnion f)) (s.biUnion fun a => Finset.filter p (f a))","decl":"lemma filter_biUnion (s : Finset α) (f : α → Finset β) (p : β → Prop) [DecidablePred p] :\n    (s.biUnion f).filter p = s.biUnion fun a ↦ (f a).filter p := by\n  ext b\n  simp only [mem_biUnion, exists_prop, mem_filter]\n  constructor\n  · rintro ⟨⟨a, ha, hba⟩, hb⟩\n    exact ⟨a, ha, hba, hb⟩\n  · rintro ⟨a, ha, hba, hb⟩\n    exact ⟨⟨a, ha, hba⟩, hb⟩\n\n"}
{"name":"Finset.biUnion_filter_eq_of_maps_to","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq β\ninst✝ : DecidableEq α\ns : Finset α\nt : Finset β\nf : α → β\nh : ∀ (x : α), Membership.mem s x → Membership.mem t (f x)\n⊢ Eq (t.biUnion fun a => Finset.filter (fun c => Eq (f c) a) s) s","decl":"lemma biUnion_filter_eq_of_maps_to [DecidableEq α] {s : Finset α} {t : Finset β} {f : α → β}\n    (h : ∀ x ∈ s, f x ∈ t) : (t.biUnion fun a ↦ s.filter fun c ↦ f c = a) = s := by\n  simpa only [disjiUnion_eq_biUnion] using disjiUnion_filter_eq_of_maps_to h\n\n"}
{"name":"Finset.erase_biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → Finset β\ns : Finset α\nb : β\n⊢ Eq ((s.biUnion f).erase b) (s.biUnion fun x => (f x).erase b)","decl":"lemma erase_biUnion (f : α → Finset β) (s : Finset α) (b : β) :\n    (s.biUnion f).erase b = s.biUnion fun x ↦ (f x).erase b := by\n  ext a\n  simp only [mem_biUnion, not_exists, not_and, mem_erase, ne_eq]\n  tauto\n\n"}
{"name":"Finset.biUnion_nonempty","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝ : DecidableEq β\n⊢ Iff (s.biUnion t).Nonempty (Exists fun x => And (Membership.mem s x) (t x).Nonempty)","decl":"@[simp]\nlemma biUnion_nonempty : (s.biUnion t).Nonempty ↔ ∃ x ∈ s, (t x).Nonempty := by\n  simp only [Finset.Nonempty, mem_biUnion]\n  rw [exists_swap]\n  simp [exists_and_left]\n\n"}
{"name":"Finset.Nonempty.biUnion","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : α → Finset β\ninst✝ : DecidableEq β\nhs : s.Nonempty\nht : ∀ (x : α), Membership.mem s x → (t x).Nonempty\n⊢ (s.biUnion t).Nonempty","decl":"lemma Nonempty.biUnion (hs : s.Nonempty) (ht : ∀ x ∈ s, (t x).Nonempty) :\n    (s.biUnion t).Nonempty := biUnion_nonempty.2 <| hs.imp fun x hx ↦ ⟨hx, ht x hx⟩\n\n"}
{"name":"Finset.disjoint_biUnion_left","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset α\nf : α → Finset β\nt : Finset β\n⊢ Iff (Disjoint (s.biUnion f) t) (∀ (i : α), Membership.mem s i → Disjoint (f i) t)","decl":"lemma disjoint_biUnion_left (s : Finset α) (f : α → Finset β) (t : Finset β) :\n    Disjoint (s.biUnion f) t ↔ ∀ i ∈ s, Disjoint (f i) t := by\n  classical\n  refine s.induction ?_ ?_\n  · simp only [forall_mem_empty_iff, biUnion_empty, disjoint_empty_left]\n  · intro i s his ih\n    simp only [disjoint_union_left, biUnion_insert, his, forall_mem_insert, ih]\n\n"}
{"name":"Finset.disjoint_biUnion_right","module":"Mathlib.Data.Finset.Union","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\ns : Finset β\nt : Finset α\nf : α → Finset β\n⊢ Iff (Disjoint s (t.biUnion f)) (∀ (i : α), Membership.mem t i → Disjoint s (f i))","decl":"lemma disjoint_biUnion_right (s : Finset β) (t : Finset α) (f : α → Finset β) :\n    Disjoint s (t.biUnion f) ↔ ∀ i ∈ t, Disjoint s (f i) := by\n  simpa only [_root_.disjoint_comm] using disjoint_biUnion_left t f s\n\n"}
