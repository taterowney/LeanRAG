{"name":"SetTheory.PGame.Domineering.shiftUp_symm_apply","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"a✝ : Prod Int Int\n⊢ Eq (SetTheory.PGame.Domineering.shiftUp.symm a✝) (Prod.map id (fun x => HAdd.hAdd x (-1)) a✝)","decl":"/-- The equivalence `(x, y) ↦ (x, y+1)`. -/\n@[simps!]\ndef shiftUp : ℤ × ℤ ≃ ℤ × ℤ :=\n  (Equiv.refl ℤ).prodCongr (Equiv.addRight (1 : ℤ))\n\n"}
{"name":"SetTheory.PGame.Domineering.shiftUp_apply","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"a✝ : Prod Int Int\n⊢ Eq (SetTheory.PGame.Domineering.shiftUp a✝) (Prod.map id (fun x => HAdd.hAdd x 1) a✝)","decl":"/-- The equivalence `(x, y) ↦ (x, y+1)`. -/\n@[simps!]\ndef shiftUp : ℤ × ℤ ≃ ℤ × ℤ :=\n  (Equiv.refl ℤ).prodCongr (Equiv.addRight (1 : ℤ))\n\n"}
{"name":"SetTheory.PGame.Domineering.shiftRight_symm_apply","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"a✝ : Prod Int Int\n⊢ Eq (SetTheory.PGame.Domineering.shiftRight.symm a✝) (Prod.map (fun x => HAdd.hAdd x (-1)) id a✝)","decl":"/-- The equivalence `(x, y) ↦ (x+1, y)`. -/\n@[simps!]\ndef shiftRight : ℤ × ℤ ≃ ℤ × ℤ :=\n  (Equiv.addRight (1 : ℤ)).prodCongr (Equiv.refl ℤ)\n\n"}
{"name":"SetTheory.PGame.Domineering.shiftRight_apply","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"a✝ : Prod Int Int\n⊢ Eq (SetTheory.PGame.Domineering.shiftRight a✝) (Prod.map (fun x => HAdd.hAdd x 1) id a✝)","decl":"/-- The equivalence `(x, y) ↦ (x+1, y)`. -/\n@[simps!]\ndef shiftRight : ℤ × ℤ ≃ ℤ × ℤ :=\n  (Equiv.addRight (1 : ℤ)).prodCongr (Equiv.refl ℤ)\n\n"}
{"name":"SetTheory.PGame.Domineering.mem_left","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nx : Prod Int Int\n⊢ Iff (Membership.mem (SetTheory.PGame.Domineering.left b) x) (And (Membership.mem b x) (Membership.mem b { fst := x.1, snd := HSub.hSub x.2 1 }))","decl":"theorem mem_left {b : Board} (x : ℤ × ℤ) : x ∈ left b ↔ x ∈ b ∧ (x.1, x.2 - 1) ∈ b :=\n  Finset.mem_inter.trans (and_congr Iff.rfl Finset.mem_map_equiv)\n\n"}
{"name":"SetTheory.PGame.Domineering.mem_right","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nx : Prod Int Int\n⊢ Iff (Membership.mem (SetTheory.PGame.Domineering.right b) x) (And (Membership.mem b x) (Membership.mem b { fst := HSub.hSub x.1 1, snd := x.2 }))","decl":"theorem mem_right {b : Board} (x : ℤ × ℤ) : x ∈ right b ↔ x ∈ b ∧ (x.1 - 1, x.2) ∈ b :=\n  Finset.mem_inter.trans (and_congr Iff.rfl Finset.mem_map_equiv)\n\n"}
{"name":"SetTheory.PGame.Domineering.fst_pred_mem_erase_of_mem_right","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.right b) m\n⊢ Membership.mem (Finset.erase b m) { fst := HSub.hSub m.1 1, snd := m.2 }","decl":"theorem fst_pred_mem_erase_of_mem_right {b : Board} {m : ℤ × ℤ} (h : m ∈ right b) :\n    (m.1 - 1, m.2) ∈ b.erase m := by\n  rw [mem_right] at h\n  apply Finset.mem_erase_of_ne_of_mem _ h.2\n  exact ne_of_apply_ne Prod.fst (pred_ne_self m.1)\n\n"}
{"name":"SetTheory.PGame.Domineering.snd_pred_mem_erase_of_mem_left","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.left b) m\n⊢ Membership.mem (Finset.erase b m) { fst := m.1, snd := HSub.hSub m.2 1 }","decl":"theorem snd_pred_mem_erase_of_mem_left {b : Board} {m : ℤ × ℤ} (h : m ∈ left b) :\n    (m.1, m.2 - 1) ∈ b.erase m := by\n  rw [mem_left] at h\n  apply Finset.mem_erase_of_ne_of_mem _ h.2\n  exact ne_of_apply_ne Prod.snd (pred_ne_self m.2)\n\n"}
{"name":"SetTheory.PGame.Domineering.card_of_mem_left","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.left b) m\n⊢ LE.le 2 (Finset.card b)","decl":"theorem card_of_mem_left {b : Board} {m : ℤ × ℤ} (h : m ∈ left b) : 2 ≤ Finset.card b := by\n  have w₁ : m ∈ b := (Finset.mem_inter.1 h).1\n  have w₂ : (m.1, m.2 - 1) ∈ b.erase m := snd_pred_mem_erase_of_mem_left h\n  have i₁ := Finset.card_erase_lt_of_mem w₁\n  have i₂ := Nat.lt_of_le_of_lt (Nat.zero_le _) (Finset.card_erase_lt_of_mem w₂)\n  exact Nat.lt_of_le_of_lt i₂ i₁\n\n"}
{"name":"SetTheory.PGame.Domineering.card_of_mem_right","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.right b) m\n⊢ LE.le 2 (Finset.card b)","decl":"theorem card_of_mem_right {b : Board} {m : ℤ × ℤ} (h : m ∈ right b) : 2 ≤ Finset.card b := by\n  have w₁ : m ∈ b := (Finset.mem_inter.1 h).1\n  have w₂ := fst_pred_mem_erase_of_mem_right h\n  have i₁ := Finset.card_erase_lt_of_mem w₁\n  have i₂ := Nat.lt_of_le_of_lt (Nat.zero_le _) (Finset.card_erase_lt_of_mem w₂)\n  exact Nat.lt_of_le_of_lt i₂ i₁\n\n"}
{"name":"SetTheory.PGame.Domineering.moveLeft_card","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.left b) m\n⊢ Eq (HAdd.hAdd (Finset.card (SetTheory.PGame.Domineering.moveLeft b m)) 2) (Finset.card b)","decl":"theorem moveLeft_card {b : Board} {m : ℤ × ℤ} (h : m ∈ left b) :\n    Finset.card (moveLeft b m) + 2 = Finset.card b := by\n  dsimp only [moveLeft]\n  rw [Finset.card_erase_of_mem (snd_pred_mem_erase_of_mem_left h)]\n  rw [Finset.card_erase_of_mem (Finset.mem_of_mem_inter_left h)]\n  exact tsub_add_cancel_of_le (card_of_mem_left h)\n\n"}
{"name":"SetTheory.PGame.Domineering.moveRight_card","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.right b) m\n⊢ Eq (HAdd.hAdd (Finset.card (SetTheory.PGame.Domineering.moveRight b m)) 2) (Finset.card b)","decl":"theorem moveRight_card {b : Board} {m : ℤ × ℤ} (h : m ∈ right b) :\n    Finset.card (moveRight b m) + 2 = Finset.card b := by\n  dsimp only [moveRight]\n  rw [Finset.card_erase_of_mem (fst_pred_mem_erase_of_mem_right h)]\n  rw [Finset.card_erase_of_mem (Finset.mem_of_mem_inter_left h)]\n  exact tsub_add_cancel_of_le (card_of_mem_right h)\n\n"}
{"name":"SetTheory.PGame.Domineering.moveLeft_smaller","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.left b) m\n⊢ LT.lt (HDiv.hDiv (Finset.card (SetTheory.PGame.Domineering.moveLeft b m)) 2) (HDiv.hDiv (Finset.card b) 2)","decl":"theorem moveLeft_smaller {b : Board} {m : ℤ × ℤ} (h : m ∈ left b) :\n    Finset.card (moveLeft b m) / 2 < Finset.card b / 2 := by simp [← moveLeft_card h, lt_add_one]\n\n"}
{"name":"SetTheory.PGame.Domineering.moveRight_smaller","module":"Mathlib.SetTheory.Game.Domineering","initialProofState":"b : SetTheory.PGame.Domineering.Board\nm : Prod Int Int\nh : Membership.mem (SetTheory.PGame.Domineering.right b) m\n⊢ LT.lt (HDiv.hDiv (Finset.card (SetTheory.PGame.Domineering.moveRight b m)) 2) (HDiv.hDiv (Finset.card b) 2)","decl":"theorem moveRight_smaller {b : Board} {m : ℤ × ℤ} (h : m ∈ right b) :\n    Finset.card (moveRight b m) / 2 < Finset.card b / 2 := by simp [← moveRight_card h, lt_add_one]\n\n"}
