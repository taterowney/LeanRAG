{"name":"CategoryTheory.Square.IsPullback.map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nh : sq.IsPullback\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan sq.f₂₄ sq.f₃₄) F\n⊢ (sq.map F).IsPullback","decl":"lemma IsPullback.map (h : sq.IsPullback) (F : C ⥤ D) [PreservesLimit (cospan sq.f₂₄ sq.f₃₄) F] :\n    (sq.map F).IsPullback :=\n  Square.IsPullback.mk _ (isLimitPullbackConeMapOfIsLimit F sq.fac h.isLimit)\n\n"}
{"name":"CategoryTheory.Square.IsPullback.of_map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan sq.f₂₄ sq.f₃₄) F\nh : (sq.map F).IsPullback\n⊢ sq.IsPullback","decl":"lemma IsPullback.of_map (F : C ⥤ D) [ReflectsLimit (cospan sq.f₂₄ sq.f₃₄) F]\n    (h : (sq.map F).IsPullback) : sq.IsPullback :=\n  CategoryTheory.IsPullback.of_map F sq.fac h\n\n"}
{"name":"CategoryTheory.Square.IsPullback.map_iff","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan sq.f₂₄ sq.f₃₄) F\ninst✝ : CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.cospan sq.f₂₄ sq.f₃₄) F\n⊢ Iff (sq.map F).IsPullback sq.IsPullback","decl":"variable (sq) in\nlemma IsPullback.map_iff (F : C ⥤ D) [PreservesLimit (cospan sq.f₂₄ sq.f₃₄) F]\n    [ReflectsLimit (cospan sq.f₂₄ sq.f₃₄) F] :\n    (sq.map F).IsPullback ↔ sq.IsPullback :=\n  ⟨fun h ↦ of_map F h, fun h ↦ h.map F⟩\n\n"}
{"name":"CategoryTheory.Square.IsPushout.map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nh : sq.IsPushout\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span sq.f₁₂ sq.f₁₃) F\n⊢ (sq.map F).IsPushout","decl":"lemma IsPushout.map (h : sq.IsPushout) (F : C ⥤ D) [PreservesColimit (span sq.f₁₂ sq.f₁₃) F] :\n    (sq.map F).IsPushout :=\n  Square.IsPushout.mk _ (isColimitPushoutCoconeMapOfIsColimit F sq.fac h.isColimit)\n\n"}
{"name":"CategoryTheory.Square.IsPushout.of_map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span sq.f₁₂ sq.f₁₃) F\nh : (sq.map F).IsPushout\n⊢ sq.IsPushout","decl":"lemma IsPushout.of_map (F : C ⥤ D) [ReflectsColimit (span sq.f₁₂ sq.f₁₃) F]\n    (h : (sq.map F).IsPushout) : sq.IsPushout :=\n  CategoryTheory.IsPushout.of_map F sq.fac h\n\n"}
{"name":"CategoryTheory.Square.IsPushout.map_iff","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nsq : CategoryTheory.Square C\nF : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span sq.f₁₂ sq.f₁₃) F\ninst✝ : CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.span sq.f₁₂ sq.f₁₃) F\n⊢ Iff (sq.map F).IsPushout sq.IsPushout","decl":"variable (sq) in\nlemma IsPushout.map_iff (F : C ⥤ D) [PreservesColimit (span sq.f₁₂ sq.f₁₃) F]\n    [ReflectsColimit (span sq.f₁₂ sq.f₁₃) F] :\n    (sq.map F).IsPushout ↔ sq.IsPushout :=\n  ⟨fun h ↦ of_map F h, fun h ↦ h.map F⟩\n\n"}
{"name":"CategoryTheory.Square.isPullback_iff_map_coyoneda_isPullback","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Iff sq.IsPullback (∀ (X : Opposite C), (sq.map (CategoryTheory.coyoneda.obj X)).IsPullback)","decl":"lemma isPullback_iff_map_coyoneda_isPullback :\n    sq.IsPullback ↔ ∀ (X : Cᵒᵖ), (sq.map (coyoneda.obj X)).IsPullback :=\n  ⟨fun h _ ↦ h.map _, fun h ↦ IsPullback.mk _\n    ((sq.pullbackCone.isLimitCoyonedaEquiv).symm (fun X ↦ (h X).isLimit))⟩\n\n"}
{"name":"CategoryTheory.Square.isPushout_iff_op_map_yoneda_isPullback","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nsq : CategoryTheory.Square C\n⊢ Iff sq.IsPushout (∀ (X : C), (sq.op.map (CategoryTheory.yoneda.obj X)).IsPullback)","decl":"lemma isPushout_iff_op_map_yoneda_isPullback :\n    sq.IsPushout ↔ ∀ (X : C), (sq.op.map (yoneda.obj X)).IsPullback :=\n  ⟨fun h _ ↦ h.op.map _, fun h ↦ IsPushout.mk _\n    ((sq.pushoutCocone.isColimitYonedaEquiv).symm\n      (fun X ↦ IsLimit.ofIsoLimit (h X).isLimit (PullbackCone.ext (Iso.refl _))))⟩\n\n"}
{"name":"CategoryTheory.Square.IsPullback.iff_of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"sq₁ : CategoryTheory.Square (Type v)\nsq₂ : CategoryTheory.Square (Type u)\ne₁ : Equiv sq₁.X₁ sq₂.X₁\ne₂ : Equiv sq₁.X₂ sq₂.X₂\ne₃ : Equiv sq₁.X₃ sq₂.X₃\ne₄ : Equiv sq₁.X₄ sq₂.X₄\ncomm₁₂ : Eq (Function.comp (⇑e₂) sq₁.f₁₂) (Function.comp sq₂.f₁₂ ⇑e₁)\ncomm₁₃ : Eq (Function.comp (⇑e₃) sq₁.f₁₃) (Function.comp sq₂.f₁₃ ⇑e₁)\ncomm₂₄ : Eq (Function.comp (⇑e₄) sq₁.f₂₄) (Function.comp sq₂.f₂₄ ⇑e₂)\ncomm₃₄ : Eq (Function.comp (⇑e₄) sq₁.f₃₄) (Function.comp sq₂.f₃₄ ⇑e₃)\n⊢ Iff sq₁.IsPullback sq₂.IsPullback","decl":"variable (sq₁ sq₂) in\nlemma IsPullback.iff_of_equiv : sq₁.IsPullback ↔ sq₂.IsPullback := by\n  rw [← IsPullback.map_iff sq₁ uliftFunctor.{max u v},\n      ← IsPullback.map_iff sq₂ uliftFunctor.{max u v}]\n  refine iff_of_iso (Square.isoMk\n    (((Equiv.trans Equiv.ulift e₁).trans Equiv.ulift.symm).toIso)\n    (((Equiv.trans Equiv.ulift e₂).trans Equiv.ulift.symm).toIso)\n    (((Equiv.trans Equiv.ulift e₃).trans Equiv.ulift.symm).toIso)\n    (((Equiv.trans Equiv.ulift e₄).trans Equiv.ulift.symm).toIso)\n    ?_ ?_ ?_ ?_)\n  all_goals ext; apply ULift.down_injective\n  · simpa [types_comp, uliftFunctor_map] using congrFun comm₁₂ _\n  · simpa [types_comp, uliftFunctor_map] using congrFun comm₁₃ _\n  · simpa [types_comp, uliftFunctor_map] using congrFun comm₂₄ _\n  · simpa [types_comp, uliftFunctor_map] using congrFun comm₃₄ _\n\n"}
{"name":"CategoryTheory.Square.IsPullback.of_equiv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Square","initialProofState":"sq₁ : CategoryTheory.Square (Type v)\nsq₂ : CategoryTheory.Square (Type u)\ne₁ : Equiv sq₁.X₁ sq₂.X₁\ne₂ : Equiv sq₁.X₂ sq₂.X₂\ne₃ : Equiv sq₁.X₃ sq₂.X₃\ne₄ : Equiv sq₁.X₄ sq₂.X₄\ncomm₁₂ : Eq (Function.comp (⇑e₂) sq₁.f₁₂) (Function.comp sq₂.f₁₂ ⇑e₁)\ncomm₁₃ : Eq (Function.comp (⇑e₃) sq₁.f₁₃) (Function.comp sq₂.f₁₃ ⇑e₁)\ncomm₂₄ : Eq (Function.comp (⇑e₄) sq₁.f₂₄) (Function.comp sq₂.f₂₄ ⇑e₂)\ncomm₃₄ : Eq (Function.comp (⇑e₄) sq₁.f₃₄) (Function.comp sq₂.f₃₄ ⇑e₃)\nh₁ : sq₁.IsPullback\n⊢ sq₂.IsPullback","decl":"lemma IsPullback.of_equiv (h₁ : sq₁.IsPullback) : sq₂.IsPullback :=\n  (iff_of_equiv sq₁ sq₂ e₁ e₂ e₃ e₄ comm₁₂ comm₁₃ comm₂₄ comm₃₄).1 h₁\n\n"}
