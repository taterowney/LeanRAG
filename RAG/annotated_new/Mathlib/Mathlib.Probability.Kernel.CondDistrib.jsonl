{"name":"ProbabilityTheory.condDistrib_def","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_5\nβ : Type u_6\nΩ : Type u_7\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nx✝ : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nY : α → Ω\nX : α → β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (ProbabilityTheory.condDistrib Y X μ) (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ).condKernel","decl":"/-- **Regular conditional probability distribution**: kernel associated with the conditional\nexpectation of `Y` given `X`.\nFor almost all `a`, `condDistrib Y X μ` evaluated at `X a` and a measurable set `s` is equal to\nthe conditional expectation `μ⟦Y ⁻¹' s | mβ.comap X⟧ a`. It also satisfies the equality\n`μ[(fun a => f (X a, Y a)) | mβ.comap X] =ᵐ[μ] fun a => ∫ y, f (X a, y) ∂(condDistrib Y X μ (X a))`\nfor all integrable functions `f`. -/\nnoncomputable irreducible_def condDistrib {_ : MeasurableSpace α} [MeasurableSpace β] (Y : α → Ω)\n    (X : α → β) (μ : Measure α) [IsFiniteMeasure μ] : Kernel β Ω :=\n  (μ.map fun a => (X a, Y a)).condKernel\n\n"}
{"name":"ProbabilityTheory.instIsMarkovKernelCondDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\ninst✝ : MeasurableSpace β\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.condDistrib Y X μ)","decl":"instance [MeasurableSpace β] : IsMarkovKernel (condDistrib Y X μ) := by\n  rw [condDistrib]; infer_instance\n\n"}
{"name":"ProbabilityTheory.condDistrib_apply_of_ne_zero","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass β\nhY : Measurable Y\nx : β\nhX : Ne ((MeasureTheory.Measure.map X μ) (Singleton.singleton x)) 0\ns : Set Ω\n⊢ Eq (((ProbabilityTheory.condDistrib Y X μ) x) s) (HMul.hMul (Inv.inv ((MeasureTheory.Measure.map X μ) (Singleton.singleton x))) ((MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ) (SProd.sprod (Singleton.singleton x) s)))","decl":"/-- If the singleton `{x}` has non-zero mass for `μ.map X`, then for all `s : Set Ω`,\n`condDistrib Y X μ x s = (μ.map X {x})⁻¹ * μ.map (fun a => (X a, Y a)) ({x} ×ˢ s)` . -/\nlemma condDistrib_apply_of_ne_zero [MeasurableSingletonClass β]\n    (hY : Measurable Y) (x : β) (hX : μ.map X {x} ≠ 0) (s : Set Ω) :\n    condDistrib Y X μ x s = (μ.map X {x})⁻¹ * μ.map (fun a => (X a, Y a)) ({x} ×ˢ s) := by\n  rw [condDistrib, Measure.condKernel_apply_of_ne_zero _ s]\n  · rw [Measure.fst_map_prod_mk hY]\n  · rwa [Measure.fst_map_prod_mk hY]\n\n"}
{"name":"ProbabilityTheory.measurable_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nhs : MeasurableSet s\n⊢ Measurable fun a => ((ProbabilityTheory.condDistrib Y X μ) (X a)) s","decl":"theorem measurable_condDistrib (hs : MeasurableSet s) :\n    Measurable[mβ.comap X] fun a => condDistrib Y X μ (X a) s :=\n  (Kernel.measurable_coe _ hs).comp (Measurable.of_comap_le le_rfl)\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.ae_integrable_condDistrib_map_iff","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ Iff (And (Filter.Eventually (fun a => MeasureTheory.Integrable (fun ω => f { fst := a, snd := ω }) ((ProbabilityTheory.condDistrib Y X μ) a)) (MeasureTheory.ae (MeasureTheory.Measure.map X μ))) (MeasureTheory.Integrable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) a) fun ω => Norm.norm (f { fst := a, snd := ω })) (MeasureTheory.Measure.map X μ))) (MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ))","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.ae_integrable_condDistrib_map_iff\n    (hY : AEMeasurable Y μ) (hf : AEStronglyMeasurable f (μ.map fun a => (X a, Y a))) :\n    (∀ᵐ a ∂μ.map X, Integrable (fun ω => f (a, ω)) (condDistrib Y X μ a)) ∧\n      Integrable (fun a => ∫ ω, ‖f (a, ω)‖ ∂condDistrib Y X μ a) (μ.map X) ↔\n    Integrable f (μ.map fun a => (X a, Y a)) := by\n  rw [condDistrib, ← hf.ae_integrable_condKernel_iff, Measure.fst_map_prod_mk₀ hY]\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_condDistrib_map","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) x) fun y => f { fst := x, snd := y }) (MeasureTheory.Measure.map X μ)","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condDistrib_map\n    (hY : AEMeasurable Y μ) (hf : AEStronglyMeasurable f (μ.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable (fun x => ∫ y, f (x, y) ∂condDistrib Y X μ x) (μ.map X) := by\n  rw [← Measure.fst_map_prod_mk₀ hY, condDistrib]; exact hf.integral_condKernel\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.AEStronglyMeasurable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }) μ","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.integral_condDistrib (hX : AEMeasurable X μ)\n    (hY : AEMeasurable Y μ) (hf : AEStronglyMeasurable f (μ.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable (fun a => ∫ y, f (X a, y) ∂condDistrib Y X μ (X a)) μ :=\n  (hf.integral_condDistrib_map hY).comp_aemeasurable hX\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.AEStronglyMeasurable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }) μ","decl":"theorem aestronglyMeasurable_integral_condDistrib (hX : AEMeasurable X μ) (hY : AEMeasurable Y μ)\n    (hf : AEStronglyMeasurable f (μ.map fun a => (X a, Y a))) :\n    AEStronglyMeasurable[mβ.comap X] (fun a => ∫ y, f (X a, y) ∂condDistrib Y X μ (X a)) μ :=\n  (hf.integral_condDistrib_map hY).comp_ae_measurable' hX\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable'_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.AEStronglyMeasurable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }) μ","decl":"@[deprecated (since := \"2025-01-24\")]\nalias aestronglyMeasurable'_integral_condDistrib := aestronglyMeasurable_integral_condDistrib\n\n"}
{"name":"ProbabilityTheory.condDistrib_ae_eq_of_measure_eq_compProd","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nhX : Measurable X\nhY : Measurable Y\nκ : ProbabilityTheory.Kernel β Ω\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhκ : Eq (MeasureTheory.Measure.map (fun x => { fst := X x, snd := Y x }) μ) ((MeasureTheory.Measure.map X μ).compProd κ)\n⊢ Filter.Eventually (fun x => Eq (κ x) ((ProbabilityTheory.condDistrib Y X μ) x)) (MeasureTheory.ae (MeasureTheory.Measure.map X μ))","decl":"/-- `condDistrib` is a.e. uniquely defined as the kernel satisfying the defining property of\n`condKernel`. -/\ntheorem condDistrib_ae_eq_of_measure_eq_compProd (hX : Measurable X) (hY : Measurable Y)\n    (κ : Kernel β Ω) [IsFiniteKernel κ] (hκ : μ.map (fun x => (X x, Y x)) = μ.map X ⊗ₘ κ) :\n    ∀ᵐ x ∂μ.map X, κ x = condDistrib Y X μ x := by\n  have heq : μ.map X = (μ.map (fun x ↦ (X x, Y x))).fst := by\n    ext s hs\n    rw [Measure.map_apply hX hs, Measure.fst_apply hs, Measure.map_apply]\n    exacts [rfl, Measurable.prod hX hY, measurable_fst hs]\n  rw [heq, condDistrib]\n  refine eq_condKernel_of_measure_eq_compProd _ ?_\n  convert hκ\n  exact heq.symm\n\n"}
{"name":"ProbabilityTheory.integrable_toReal_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nhX : AEMeasurable X μ\nhs : MeasurableSet s\n⊢ MeasureTheory.Integrable (fun a => (((ProbabilityTheory.condDistrib Y X μ) (X a)) s).toReal) μ","decl":"theorem integrable_toReal_condDistrib (hX : AEMeasurable X μ) (hs : MeasurableSet s) :\n    Integrable (fun a => (condDistrib Y X μ (X a) s).toReal) μ := by\n  refine integrable_toReal_of_lintegral_ne_top ?_ ?_\n  · exact Measurable.comp_aemeasurable (Kernel.measurable_coe _ hs) hX\n  · refine ne_of_lt ?_\n    calc\n      ∫⁻ a, condDistrib Y X μ (X a) s ∂μ ≤ ∫⁻ _, 1 ∂μ := lintegral_mono fun a => prob_le_one\n      _ = μ univ := lintegral_one\n      _ < ∞ := measure_lt_top _ _\n\n"}
{"name":"MeasureTheory.Integrable.condDistrib_ae_map","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ Filter.Eventually (fun b => MeasureTheory.Integrable (fun ω => f { fst := b, snd := ω }) ((ProbabilityTheory.condDistrib Y X μ) b)) (MeasureTheory.ae (MeasureTheory.Measure.map X μ))","decl":"theorem _root_.MeasureTheory.Integrable.condDistrib_ae_map\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    ∀ᵐ b ∂μ.map X, Integrable (fun ω => f (b, ω)) (condDistrib Y X μ b) := by\n  rw [condDistrib, ← Measure.fst_map_prod_mk₀ (X := X) hY]; exact hf_int.condKernel_ae\n\n"}
{"name":"MeasureTheory.Integrable.condDistrib_ae","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ Filter.Eventually (fun a => MeasureTheory.Integrable (fun ω => f { fst := X a, snd := ω }) ((ProbabilityTheory.condDistrib Y X μ) (X a))) (MeasureTheory.ae μ)","decl":"theorem _root_.MeasureTheory.Integrable.condDistrib_ae (hX : AEMeasurable X μ)\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    ∀ᵐ a ∂μ, Integrable (fun ω => f (X a, ω)) (condDistrib Y X μ (X a)) :=\n  ae_of_ae_map hX (hf_int.condDistrib_ae_map hY)\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_condDistrib_map","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun x => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) x) fun y => Norm.norm (f { fst := x, snd := y })) (MeasureTheory.Measure.map X μ)","decl":"theorem _root_.MeasureTheory.Integrable.integral_norm_condDistrib_map\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun x => ∫ y, ‖f (x, y)‖ ∂condDistrib Y X μ x) (μ.map X) := by\n  rw [condDistrib, ← Measure.fst_map_prod_mk₀ (X := X) hY]; exact hf_int.integral_norm_condKernel\n\n"}
{"name":"MeasureTheory.Integrable.integral_norm_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace Ω\ninst✝³ : StandardBorelSpace Ω\ninst✝² : Nonempty Ω\ninst✝¹ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => Norm.norm (f { fst := X a, snd := y })) μ","decl":"theorem _root_.MeasureTheory.Integrable.integral_norm_condDistrib (hX : AEMeasurable X μ)\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun a => ∫ y, ‖f (X a, y)‖ ∂condDistrib Y X μ (X a)) μ :=\n  (hf_int.integral_norm_condDistrib_map hY).comp_aemeasurable hX\n\n"}
{"name":"MeasureTheory.Integrable.norm_integral_condDistrib_map","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun x => Norm.norm (MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) x) fun y => f { fst := x, snd := y })) (MeasureTheory.Measure.map X μ)","decl":"theorem _root_.MeasureTheory.Integrable.norm_integral_condDistrib_map\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun x => ‖∫ y, f (x, y) ∂condDistrib Y X μ x‖) (μ.map X) := by\n  rw [condDistrib, ← Measure.fst_map_prod_mk₀ (X := X) hY]; exact hf_int.norm_integral_condKernel\n\n"}
{"name":"MeasureTheory.Integrable.norm_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun a => Norm.norm (MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y })) μ","decl":"theorem _root_.MeasureTheory.Integrable.norm_integral_condDistrib (hX : AEMeasurable X μ)\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun a => ‖∫ y, f (X a, y) ∂condDistrib Y X μ (X a)‖) μ :=\n  (hf_int.norm_integral_condDistrib_map hY).comp_aemeasurable hX\n\n"}
{"name":"MeasureTheory.Integrable.integral_condDistrib_map","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun x => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) x) fun y => f { fst := x, snd := y }) (MeasureTheory.Measure.map X μ)","decl":"theorem _root_.MeasureTheory.Integrable.integral_condDistrib_map\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun x => ∫ y, f (x, y) ∂condDistrib Y X μ x) (μ.map X) :=\n  (integrable_norm_iff (hf_int.1.integral_condDistrib_map hY)).mp\n    (hf_int.norm_integral_condDistrib_map hY)\n\n"}
{"name":"MeasureTheory.Integrable.integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace Ω\ninst✝⁴ : StandardBorelSpace Ω\ninst✝³ : Nonempty Ω\ninst✝² : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝ : NormedSpace Real F\nhX : AEMeasurable X μ\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ MeasureTheory.Integrable (fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }) μ","decl":"theorem _root_.MeasureTheory.Integrable.integral_condDistrib (hX : AEMeasurable X μ)\n    (hY : AEMeasurable Y μ) (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    Integrable (fun a => ∫ y, f (X a, y) ∂condDistrib Y X μ (X a)) μ :=\n  (hf_int.integral_condDistrib_map hY).comp_aemeasurable hX\n\n"}
{"name":"ProbabilityTheory.setLIntegral_preimage_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nt : Set β\nhX : Measurable X\nhY : AEMeasurable Y μ\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (μ.restrict (Set.preimage X t)) fun a => ((ProbabilityTheory.condDistrib Y X μ) (X a)) s) (μ (Inter.inter (Set.preimage X t) (Set.preimage Y s)))","decl":"theorem setLIntegral_preimage_condDistrib (hX : Measurable X) (hY : AEMeasurable Y μ)\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    ∫⁻ a in X ⁻¹' t, condDistrib Y X μ (X a) s ∂μ = μ (X ⁻¹' t ∩ Y ⁻¹' s) := by\n  -- Porting note: need to massage the LHS integrand into the form accepted by `lintegral_comp`\n  -- (`rw` does not see that the two forms are defeq)\n  conv_lhs => arg 2; change (fun a => ((condDistrib Y X μ) a) s) ∘ X\n  rw [lintegral_comp (Kernel.measurable_coe _ hs) hX, condDistrib, ← Measure.restrict_map hX ht, ←\n    Measure.fst_map_prod_mk₀ hY, Measure.setLIntegral_condKernel_eq_measure_prod ht hs,\n    Measure.map_apply_of_aemeasurable (hX.aemeasurable.prod_mk hY) (ht.prod hs), mk_preimage_prod]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_condDistrib_of_measurableSet","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nhX : Measurable X\nhY : AEMeasurable Y μ\nhs : MeasurableSet s\nt : Set α\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (μ.restrict t) fun a => ((ProbabilityTheory.condDistrib Y X μ) (X a)) s) (μ (Inter.inter t (Set.preimage Y s)))","decl":"theorem setLIntegral_condDistrib_of_measurableSet (hX : Measurable X) (hY : AEMeasurable Y μ)\n    (hs : MeasurableSet s) {t : Set α} (ht : MeasurableSet[mβ.comap X] t) :\n    ∫⁻ a in t, condDistrib Y X μ (X a) s ∂μ = μ (t ∩ Y ⁻¹' s) := by\n  obtain ⟨t', ht', rfl⟩ := ht\n  rw [setLIntegral_preimage_condDistrib hX hY hs ht']\n\n"}
{"name":"ProbabilityTheory.condDistrib_ae_eq_condExp","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nhX : Measurable X\nhY : Measurable Y\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun a => (((ProbabilityTheory.condDistrib Y X μ) (X a)) s).toReal) (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ ((Set.preimage Y s).indicator fun ω => 1))","decl":"/-- For almost every `a : α`, the `condDistrib Y X μ` kernel applied to `X a` and a measurable set\n`s` is equal to the conditional expectation of the indicator of `Y ⁻¹' s`. -/\ntheorem condDistrib_ae_eq_condExp (hX : Measurable X) (hY : Measurable Y) (hs : MeasurableSet s) :\n    (fun a => (condDistrib Y X μ (X a) s).toReal) =ᵐ[μ] μ⟦Y ⁻¹' s|mβ.comap X⟧ := by\n  refine ae_eq_condExp_of_forall_setIntegral_eq hX.comap_le ?_ ?_ ?_ ?_\n  · exact (integrable_const _).indicator (hY hs)\n  · exact fun t _ _ => (integrable_toReal_condDistrib hX.aemeasurable hs).integrableOn\n  · intro t ht _\n    rw [integral_toReal ((measurable_condDistrib hs).mono hX.comap_le le_rfl).aemeasurable\n      (Eventually.of_forall fun ω => measure_lt_top (condDistrib Y X μ (X ω)) _),\n      integral_indicator_const _ (hY hs), Measure.restrict_apply (hY hs), smul_eq_mul, mul_one,\n      inter_comm, setLIntegral_condDistrib_of_measurableSet hX hY.aemeasurable hs ht]\n  · exact (measurable_condDistrib hs).ennreal_toReal.aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.condDistrib_ae_eq_condexp","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\ninst✝³ : MeasurableSpace Ω\ninst✝² : StandardBorelSpace Ω\ninst✝¹ : Nonempty Ω\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ns : Set Ω\nhX : Measurable X\nhY : Measurable Y\nhs : MeasurableSet s\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun a => (((ProbabilityTheory.condDistrib Y X μ) (X a)) s).toReal) (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ ((Set.preimage Y s).indicator fun ω => 1))","decl":"@[deprecated (since := \"2025-01-21\")] alias condDistrib_ae_eq_condexp := condDistrib_ae_eq_condExp\n\n"}
{"name":"ProbabilityTheory.condExp_prod_ae_eq_integral_condDistrib'","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"/-- The conditional expectation of a function `f` of the product `(X, Y)` is almost everywhere equal\nto the integral of `y ↦ f(X, y)` against the `condDistrib` kernel. -/\ntheorem condExp_prod_ae_eq_integral_condDistrib' [NormedSpace ℝ F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y μ)\n    (hf_int : Integrable f (μ.map fun a => (X a, Y a))) :\n    μ[fun a => f (X a, Y a)|mβ.comap X] =ᵐ[μ] fun a => ∫ y, f (X a,y) ∂condDistrib Y X μ (X a) := by\n  have hf_int' : Integrable (fun a => f (X a, Y a)) μ :=\n    (integrable_map_measure hf_int.1 (hX.aemeasurable.prod_mk hY)).mp hf_int\n  refine (ae_eq_condExp_of_forall_setIntegral_eq hX.comap_le hf_int' (fun s _ _ => ?_) ?_ ?_).symm\n  · exact (hf_int.integral_condDistrib hX.aemeasurable hY).integrableOn\n  · rintro s ⟨t, ht, rfl⟩ _\n    change ∫ a in X ⁻¹' t, ((fun x' => ∫ y, f (x', y) ∂(condDistrib Y X μ) x') ∘ X) a ∂μ =\n      ∫ a in X ⁻¹' t, f (X a, Y a) ∂μ\n    simp only [Function.comp_apply]\n    rw [← integral_map hX.aemeasurable (f := fun x' => ∫ y, f (x', y) ∂(condDistrib Y X μ) x')]\n    swap\n    · rw [← Measure.restrict_map hX ht]\n      exact (hf_int.1.integral_condDistrib_map hY).restrict\n    rw [← Measure.restrict_map hX ht, ← Measure.fst_map_prod_mk₀ hY, condDistrib,\n      Measure.setIntegral_condKernel_univ_right ht hf_int.integrableOn,\n      setIntegral_map (ht.prod MeasurableSet.univ) hf_int.1 (hX.aemeasurable.prod_mk hY),\n      mk_preimage_prod, preimage_univ, inter_univ]\n  · exact aestronglyMeasurable_integral_condDistrib hX.aemeasurable hY hf_int.1\n\n"}
{"name":"ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib'","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf_int : MeasureTheory.Integrable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_prod_ae_eq_integral_condDistrib' := condExp_prod_ae_eq_integral_condDistrib'\n\n"}
{"name":"ProbabilityTheory.condExp_prod_ae_eq_integral_condDistrib₀","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\nhf_int : MeasureTheory.Integrable (fun a => f { fst := X a, snd := Y a }) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"/-- The conditional expectation of a function `f` of the product `(X, Y)` is almost everywhere equal\nto the integral of `y ↦ f(X, y)` against the `condDistrib` kernel. -/\ntheorem condExp_prod_ae_eq_integral_condDistrib₀ [NormedSpace ℝ F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y μ)\n    (hf : AEStronglyMeasurable f (μ.map fun a => (X a, Y a)))\n    (hf_int : Integrable (fun a => f (X a, Y a)) μ) :\n    μ[fun a => f (X a, Y a)|mβ.comap X] =ᵐ[μ] fun a => ∫ y, f (X a, y) ∂condDistrib Y X μ (X a) :=\n  haveI hf_int' : Integrable f (μ.map fun a => (X a, Y a)) := by\n    rwa [integrable_map_measure hf (hX.aemeasurable.prod_mk hY)]\n  condExp_prod_ae_eq_integral_condDistrib' hX hY hf_int'\n\n"}
{"name":"ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib₀","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map (fun a => { fst := X a, snd := Y a }) μ)\nhf_int : MeasureTheory.Integrable (fun a => f { fst := X a, snd := Y a }) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_prod_ae_eq_integral_condDistrib₀ := condExp_prod_ae_eq_integral_condDistrib₀\n\n"}
{"name":"ProbabilityTheory.condExp_prod_ae_eq_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf : MeasureTheory.StronglyMeasurable f\nhf_int : MeasureTheory.Integrable (fun a => f { fst := X a, snd := Y a }) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"/-- The conditional expectation of a function `f` of the product `(X, Y)` is almost everywhere equal\nto the integral of `y ↦ f(X, y)` against the `condDistrib` kernel. -/\ntheorem condExp_prod_ae_eq_integral_condDistrib [NormedSpace ℝ F] [CompleteSpace F]\n    (hX : Measurable X) (hY : AEMeasurable Y μ) (hf : StronglyMeasurable f)\n    (hf_int : Integrable (fun a => f (X a, Y a)) μ) :\n    μ[fun a => f (X a, Y a)|mβ.comap X] =ᵐ[μ] fun a => ∫ y, f (X a, y) ∂condDistrib Y X μ (X a) :=\n  haveI hf_int' : Integrable f (μ.map fun a => (X a, Y a)) := by\n    rwa [integrable_map_measure hf.aestronglyMeasurable (hX.aemeasurable.prod_mk hY)]\n  condExp_prod_ae_eq_integral_condDistrib' hX hY hf_int'\n\n"}
{"name":"ProbabilityTheory.condexp_prod_ae_eq_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\nf : Prod β Ω → F\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nhf : MeasureTheory.StronglyMeasurable f\nhf_int : MeasureTheory.Integrable (fun a => f { fst := X a, snd := Y a }) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f { fst := X a, snd := Y a }) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f { fst := X a, snd := y }","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_prod_ae_eq_integral_condDistrib := condExp_prod_ae_eq_integral_condDistrib\n\n"}
{"name":"ProbabilityTheory.condExp_ae_eq_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nf : Ω → F\nhf : MeasureTheory.StronglyMeasurable f\nhf_int : MeasureTheory.Integrable (fun a => f (Y a)) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f (Y a)) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f y","decl":"theorem condExp_ae_eq_integral_condDistrib [NormedSpace ℝ F] [CompleteSpace F] (hX : Measurable X)\n    (hY : AEMeasurable Y μ) {f : Ω → F} (hf : StronglyMeasurable f)\n    (hf_int : Integrable (fun a => f (Y a)) μ) :\n    μ[fun a => f (Y a)|mβ.comap X] =ᵐ[μ] fun a => ∫ y, f y ∂condDistrib Y X μ (X a) :=\n  condExp_prod_ae_eq_integral_condDistrib hX hY (hf.comp_measurable measurable_snd) hf_int\n\n"}
{"name":"ProbabilityTheory.condexp_ae_eq_integral_condDistrib","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nY : α → Ω\nmβ : MeasurableSpace β\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nhX : Measurable X\nhY : AEMeasurable Y μ\nf : Ω → F\nhf : MeasureTheory.StronglyMeasurable f\nhf_int : MeasureTheory.Integrable (fun a => f (Y a)) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ fun a => f (Y a)) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => f y","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_integral_condDistrib := condExp_ae_eq_integral_condDistrib\n\n"}
{"name":"ProbabilityTheory.condExp_ae_eq_integral_condDistrib'","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁶ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nmβ : MeasurableSpace β\nΩ : Type u_5\ninst✝⁵ : NormedAddCommGroup Ω\ninst✝⁴ : NormedSpace Real Ω\ninst✝³ : CompleteSpace Ω\ninst✝² : MeasurableSpace Ω\ninst✝¹ : BorelSpace Ω\ninst✝ : SecondCountableTopology Ω\nY : α → Ω\nhX : Measurable X\nhY_int : MeasureTheory.Integrable Y μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ Y) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => y","decl":"/-- The conditional expectation of `Y` given `X` is almost everywhere equal to the integral\n`∫ y, y ∂(condDistrib Y X μ (X a))`. -/\ntheorem condExp_ae_eq_integral_condDistrib' {Ω} [NormedAddCommGroup Ω] [NormedSpace ℝ Ω]\n    [CompleteSpace Ω] [MeasurableSpace Ω] [BorelSpace Ω] [SecondCountableTopology Ω] {Y : α → Ω}\n    (hX : Measurable X) (hY_int : Integrable Y μ) :\n    μ[Y|mβ.comap X] =ᵐ[μ] fun a => ∫ y, y ∂condDistrib Y X μ (X a) :=\n  condExp_ae_eq_integral_condDistrib hX hY_int.1.aemeasurable stronglyMeasurable_id hY_int\n\n"}
{"name":"ProbabilityTheory.condexp_ae_eq_integral_condDistrib'","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁶ : MeasureTheory.IsFiniteMeasure μ\nX : α → β\nmβ : MeasurableSpace β\nΩ : Type u_5\ninst✝⁵ : NormedAddCommGroup Ω\ninst✝⁴ : NormedSpace Real Ω\ninst✝³ : CompleteSpace Ω\ninst✝² : MeasurableSpace Ω\ninst✝¹ : BorelSpace Ω\ninst✝ : SecondCountableTopology Ω\nY : α → Ω\nhX : Measurable X\nhY_int : MeasureTheory.Integrable Y μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ Y) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib Y X μ) (X a)) fun y => y","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_integral_condDistrib' := condExp_ae_eq_integral_condDistrib'\n\n"}
{"name":"MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_mk","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nΩ : Type u_5\nF : Type u_6\nmΩ : MeasurableSpace Ω\nX : Ω → β\nμ : MeasureTheory.Measure Ω\ninst✝ : TopologicalSpace F\nf : Ω → F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ MeasureTheory.AEStronglyMeasurable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := X ω, snd := ω }) μ)","decl":"theorem _root_.MeasureTheory.AEStronglyMeasurable.comp_snd_map_prod_mk\n    {Ω F} {mΩ : MeasurableSpace Ω} (X : Ω → β) {μ : Measure Ω} [TopologicalSpace F] {f : Ω → F}\n    (hf : AEStronglyMeasurable f μ) :\n    AEStronglyMeasurable (fun x : β × Ω => f x.2) (μ.map fun ω => (X ω, ω)) := by\n  refine ⟨fun x => hf.mk f x.2, hf.stronglyMeasurable_mk.comp_measurable measurable_snd, ?_⟩\n  suffices h : Measure.QuasiMeasurePreserving Prod.snd (μ.map fun ω ↦ (X ω, ω)) μ from\n    Measure.QuasiMeasurePreserving.ae_eq h hf.ae_eq_mk\n  refine ⟨measurable_snd, Measure.AbsolutelyContinuous.mk fun s hs hμs => ?_⟩\n  rw [Measure.map_apply _ hs]\n  swap; · exact measurable_snd\n  by_cases hX : AEMeasurable X μ\n  · rw [Measure.map_apply_of_aemeasurable]\n    · rw [← univ_prod, mk_preimage_prod, preimage_univ, univ_inter, preimage_id']\n      exact hμs\n    · exact hX.prod_mk aemeasurable_id\n    · exact measurable_snd hs\n  · rw [Measure.map_of_not_aemeasurable]\n    · simp\n    · contrapose! hX; exact measurable_fst.comp_aemeasurable hX\n\n"}
{"name":"MeasureTheory.Integrable.comp_snd_map_prod_mk","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nmβ : MeasurableSpace β\nΩ : Type u_5\nmΩ : MeasurableSpace Ω\nX : Ω → β\nμ : MeasureTheory.Measure Ω\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := X ω, snd := ω }) μ)","decl":"theorem _root_.MeasureTheory.Integrable.comp_snd_map_prod_mk\n    {Ω} {mΩ : MeasurableSpace Ω} (X : Ω → β) {μ : Measure Ω} {f : Ω → F} (hf_int : Integrable f μ) :\n    Integrable (fun x : β × Ω => f x.2) (μ.map fun ω => (X ω, ω)) := by\n  by_cases hX : AEMeasurable X μ\n  · have hf := hf_int.1.comp_snd_map_prod_mk X (mΩ := mΩ) (mβ := mβ)\n    refine ⟨hf, ?_⟩\n    rw [hasFiniteIntegral_iff_enorm, lintegral_map' hf.enorm (hX.prod_mk aemeasurable_id)]\n    exact hf_int.2\n  · rw [Measure.map_of_not_aemeasurable]\n    · simp\n    · contrapose! hX; exact measurable_fst.comp_aemeasurable hX\n\n"}
{"name":"ProbabilityTheory.aestronglyMeasurable_comp_snd_map_prod_mk_iff","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nΩ : Type u_5\nF : Type u_6\nx✝ : MeasurableSpace Ω\ninst✝ : TopologicalSpace F\nX : Ω → β\nμ : MeasureTheory.Measure Ω\nhX : Measurable X\nf : Ω → F\n⊢ Iff (MeasureTheory.AEStronglyMeasurable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := X ω, snd := ω }) μ)) (MeasureTheory.AEStronglyMeasurable f μ)","decl":"theorem aestronglyMeasurable_comp_snd_map_prod_mk_iff {Ω F} {_ : MeasurableSpace Ω}\n    [TopologicalSpace F] {X : Ω → β} {μ : Measure Ω} (hX : Measurable X) {f : Ω → F} :\n    AEStronglyMeasurable (fun x : β × Ω => f x.2) (μ.map fun ω => (X ω, ω)) ↔\n    AEStronglyMeasurable f μ :=\n  ⟨fun h => h.comp_measurable (hX.prod_mk measurable_id), fun h => h.comp_snd_map_prod_mk X⟩\n\n"}
{"name":"ProbabilityTheory.integrable_comp_snd_map_prod_mk_iff","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nmβ : MeasurableSpace β\nΩ : Type u_5\nx✝ : MeasurableSpace Ω\nX : Ω → β\nμ : MeasureTheory.Measure Ω\nhX : Measurable X\nf : Ω → F\n⊢ Iff (MeasureTheory.Integrable (fun x => f x.2) (MeasureTheory.Measure.map (fun ω => { fst := X ω, snd := ω }) μ)) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_comp_snd_map_prod_mk_iff {Ω} {_ : MeasurableSpace Ω} {X : Ω → β} {μ : Measure Ω}\n    (hX : Measurable X) {f : Ω → F} :\n    Integrable (fun x : β × Ω => f x.2) (μ.map fun ω => (X ω, ω)) ↔ Integrable f μ :=\n  ⟨fun h => h.comp_measurable (hX.prod_mk measurable_id), fun h => h.comp_snd_map_prod_mk X⟩\n\n"}
{"name":"ProbabilityTheory.condExp_ae_eq_integral_condDistrib_id","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmβ : MeasurableSpace β\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace F\nX : Ω → β\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : Measurable X\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ f) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib id X μ) (X a)) fun y => f y","decl":"theorem condExp_ae_eq_integral_condDistrib_id [NormedSpace ℝ F] [CompleteSpace F] {X : Ω → β}\n    {μ : Measure Ω} [IsFiniteMeasure μ] (hX : Measurable X) {f : Ω → F} (hf_int : Integrable f μ) :\n    μ[f|mβ.comap X] =ᵐ[μ] fun a => ∫ y, f y ∂condDistrib id X μ (X a) :=\n  condExp_prod_ae_eq_integral_condDistrib' hX aemeasurable_id (hf_int.comp_snd_map_prod_mk X)\n\n"}
{"name":"ProbabilityTheory.condexp_ae_eq_integral_condDistrib_id","module":"Mathlib.Probability.Kernel.CondDistrib","initialProofState":"β : Type u_2\nΩ : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace Ω\ninst✝⁵ : StandardBorelSpace Ω\ninst✝⁴ : Nonempty Ω\ninst✝³ : NormedAddCommGroup F\nmβ : MeasurableSpace β\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace F\nX : Ω → β\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : Measurable X\nf : Ω → F\nhf_int : MeasureTheory.Integrable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (MeasureTheory.condExp (MeasurableSpace.comap X mβ) μ f) fun a => MeasureTheory.integral ((ProbabilityTheory.condDistrib id X μ) (X a)) fun y => f y","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_ae_eq_integral_condDistrib_id := condExp_ae_eq_integral_condDistrib_id\n\n"}
