{"name":"IsCompact.isSigmaCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\nhs : IsCompact s\n‚ä¢ IsSigmaCompact s","decl":"/-- Compact sets are œÉ-compact. -/\nlemma IsCompact.isSigmaCompact {s : Set X} (hs : IsCompact s) : IsSigmaCompact s :=\n  ‚ü®fun _ => s, fun _ => hs, iUnion_const _‚ü©\n\n"}
{"name":"isSigmaCompact_empty","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsSigmaCompact EmptyCollection.emptyCollection","decl":"/-- The empty set is œÉ-compact. -/\n@[simp]\nlemma isSigmaCompact_empty : IsSigmaCompact (‚àÖ : Set X) :=\n  IsCompact.isSigmaCompact isCompact_empty\n\n"}
{"name":"isSigmaCompact_iUnion_of_isCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nŒπ : Type u_3\ninst‚úù : TopologicalSpace X\nhŒπ : Countable Œπ\ns : Œπ ‚Üí Set X\nhcomp : ‚àÄ (i : Œπ), IsCompact (s i)\n‚ä¢ IsSigmaCompact (Set.iUnion fun i => s i)","decl":"/-- Countable unions of compact sets are œÉ-compact. -/\nlemma isSigmaCompact_iUnion_of_isCompact [hŒπ : Countable Œπ] (s : Œπ ‚Üí Set X)\n    (hcomp : ‚àÄ i, IsCompact (s i)) : IsSigmaCompact (‚ãÉ i, s i) := by\n  rcases isEmpty_or_nonempty Œπ\n  ¬∑ simp only [iUnion_of_empty, isSigmaCompact_empty]\n  ¬∑ -- If Œπ is non-empty, choose a surjection f : ‚Ñï ‚Üí Œπ, this yields a map ‚Ñï ‚Üí Set X.\n    obtain ‚ü®f, hf‚ü© := countable_iff_exists_surjective.mp hŒπ\n    exact ‚ü®s ‚àò f, fun n ‚Ü¶ hcomp (f n), Function.Surjective.iUnion_comp hf _‚ü©\n\n"}
{"name":"isSigmaCompact_sUnion_of_isCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : ‚àÄ (s : Set X), Membership.mem S s ‚Üí IsCompact s\n‚ä¢ IsSigmaCompact S.sUnion","decl":"/-- Countable unions of compact sets are œÉ-compact. -/\nlemma isSigmaCompact_sUnion_of_isCompact {S : Set (Set X)} (hc : Set.Countable S)\n    (hcomp : ‚àÄ (s : Set X), s ‚àà S ‚Üí IsCompact s) : IsSigmaCompact (‚ãÉ‚ÇÄ S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  rw [sUnion_eq_iUnion]\n  apply isSigmaCompact_iUnion_of_isCompact _ (fun ‚ü®s, hs‚ü© ‚Ü¶ hcomp s hs)\n\n"}
{"name":"isSigmaCompact_iUnion","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nŒπ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : Countable Œπ\ns : Œπ ‚Üí Set X\nhcomp : ‚àÄ (i : Œπ), IsSigmaCompact (s i)\n‚ä¢ IsSigmaCompact (Set.iUnion fun i => s i)","decl":"/-- Countable unions of œÉ-compact sets are œÉ-compact. -/\nlemma isSigmaCompact_iUnion [Countable Œπ] (s : Œπ ‚Üí Set X)\n    (hcomp : ‚àÄ i, IsSigmaCompact (s i)) : IsSigmaCompact (‚ãÉ i, s i) := by\n  -- Choose a decomposition s_i = ‚ãÉ K_i,j for each i.\n  choose K hcomp hcov using fun i ‚Ü¶ hcomp i\n  -- Then, we have a countable union of countable unions of compact sets, i.e. countably many.\n  have := calc\n    ‚ãÉ i, s i\n    _ = ‚ãÉ i, ‚ãÉ n, (K i n) := by simp_rw [hcov]\n    _ = ‚ãÉ (i) (n : ‚Ñï), (K.uncurry ‚ü®i, n‚ü©) := by rw [Function.uncurry_def]\n    _ = ‚ãÉ x, K.uncurry x := by rw [‚Üê iUnion_prod']\n  rw [this]\n  exact isSigmaCompact_iUnion_of_isCompact K.uncurry fun x ‚Ü¶ (hcomp x.1 x.2)\n\n"}
{"name":"isSigmaCompact_sUnion","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nhc : S.Countable\nhcomp : ‚àÄ (s : ‚ÜëS), IsSigmaCompact ‚Üës\n‚ä¢ IsSigmaCompact S.sUnion","decl":"/-- Countable unions of œÉ-compact sets are œÉ-compact. -/\nlemma isSigmaCompact_sUnion (S : Set (Set X)) (hc : Set.Countable S)\n    (hcomp : ‚àÄ s : S, IsSigmaCompact s (X := X)) : IsSigmaCompact (‚ãÉ‚ÇÄ S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  apply sUnion_eq_iUnion.symm ‚ñ∏ isSigmaCompact_iUnion _ hcomp\n\n"}
{"name":"isSigmaCompact_biUnion","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nŒπ : Type u_3\ninst‚úù : TopologicalSpace X\ns : Set Œπ\nS : Œπ ‚Üí Set X\nhc : s.Countable\nhcomp : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí IsSigmaCompact (S i)\n‚ä¢ IsSigmaCompact (Set.iUnion fun i => Set.iUnion fun x => S i)","decl":"/-- Countable unions of œÉ-compact sets are œÉ-compact. -/\nlemma isSigmaCompact_biUnion {s : Set Œπ} {S : Œπ ‚Üí Set X} (hc : Set.Countable s)\n    (hcomp : ‚àÄ (i : Œπ), i ‚àà s ‚Üí IsSigmaCompact (S i)) :\n    IsSigmaCompact (‚ãÉ (i : Œπ) (_ : i ‚àà s), S i) := by\n  have : Countable ‚Üës := countable_coe_iff.mpr hc\n  rw [biUnion_eq_iUnion]\n  exact isSigmaCompact_iUnion _ (fun ‚ü®i', hi'‚ü© ‚Ü¶ hcomp i' hi')\n\n"}
{"name":"IsSigmaCompact.of_isClosed_subset","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns t : Set X\nht : IsSigmaCompact t\nhs : IsClosed s\nh : HasSubset.Subset s t\n‚ä¢ IsSigmaCompact s","decl":"/-- A closed subset of a œÉ-compact set is œÉ-compact. -/\nlemma IsSigmaCompact.of_isClosed_subset {s t : Set X} (ht : IsSigmaCompact t)\n    (hs : IsClosed s) (h : s ‚äÜ t) : IsSigmaCompact s := by\n  rcases ht with ‚ü®K, hcompact, hcov‚ü©\n  refine ‚ü®(fun n ‚Ü¶ s ‚à© (K n)), fun n ‚Ü¶ (hcompact n).inter_left hs, ?_‚ü©\n  rw [‚Üê inter_iUnion, hcov]\n  exact inter_eq_left.mpr h\n\n"}
{"name":"IsSigmaCompact.image_of_continuousOn","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nhs : IsSigmaCompact s\nhf : ContinuousOn f s\n‚ä¢ IsSigmaCompact (Set.image f s)","decl":"/-- If `s` is œÉ-compact and `f` is continuous on `s`, `f(s)` is œÉ-compact. -/\nlemma IsSigmaCompact.image_of_continuousOn {f : X ‚Üí Y} {s : Set X} (hs : IsSigmaCompact s)\n    (hf : ContinuousOn f s) : IsSigmaCompact (f '' s) := by\n  rcases hs with ‚ü®K, hcompact, hcov‚ü©\n  refine ‚ü®fun n ‚Ü¶ f '' K n, ?_, hcov.symm ‚ñ∏ image_iUnion.symm‚ü©\n  exact fun n ‚Ü¶ (hcompact n).image_of_continuousOn (hf.mono (hcov.symm ‚ñ∏ subset_iUnion K n))\n\n"}
{"name":"IsSigmaCompact.image","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\ns : Set X\nhs : IsSigmaCompact s\n‚ä¢ IsSigmaCompact (Set.image f s)","decl":"/-- If `s` is œÉ-compact and `f` continuous, `f(s)` is œÉ-compact. -/\nlemma IsSigmaCompact.image {f : X ‚Üí Y} (hf : Continuous f) {s : Set X} (hs : IsSigmaCompact s) :\n    IsSigmaCompact (f '' s) := hs.image_of_continuousOn hf.continuousOn\n\n"}
{"name":"Topology.IsInducing.isSigmaCompact_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nhf : Topology.IsInducing f\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact (Set.image f s))","decl":"/-- If `f : X ‚Üí Y` is an inducing map, the image `f '' s` of a set `s` is œÉ-compact\n  if and only `s` is œÉ-compact. -/\nlemma Topology.IsInducing.isSigmaCompact_iff {f : X ‚Üí Y} {s : Set X}\n    (hf : IsInducing f) : IsSigmaCompact s ‚Üî IsSigmaCompact (f '' s) := by\n  constructor\n  ¬∑ exact fun h ‚Ü¶ h.image hf.continuous\n  ¬∑ rintro ‚ü®L, hcomp, hcov‚ü©\n    -- Suppose f(s) is œÉ-compact; we want to show s is œÉ-compact.\n    -- Write f(s) as a union of compact sets L n, so s = ‚ãÉ K n with K n := f‚Åª¬π(L n) ‚à© s.\n    -- Since f is inducing, each K n is compact iff L n is.\n    refine ‚ü®fun n ‚Ü¶ f ‚Åª¬π' (L n) ‚à© s, ?_, ?_‚ü©\n    ¬∑ intro n\n      have : f '' (f ‚Åª¬π' (L n) ‚à© s) = L n := by\n        rw [image_preimage_inter, inter_eq_left.mpr]\n        exact (subset_iUnion _ n).trans hcov.le\n      apply hf.isCompact_iff.mpr (this.symm ‚ñ∏ (hcomp n))\n    ¬∑ calc ‚ãÉ n, f ‚Åª¬π' L n ‚à© s\n        _ = f ‚Åª¬π' (‚ãÉ n, L n) ‚à© s  := by rw [preimage_iUnion, iUnion_inter]\n        _ = f ‚Åª¬π' (f '' s) ‚à© s := by rw [hcov]\n        _ = s := inter_eq_right.mpr (subset_preimage_image _ _)\n\n"}
{"name":"Inducing.isSigmaCompact_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nhf : Topology.IsInducing f\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact (Set.image f s))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.isSigmaCompact_iff := IsInducing.isSigmaCompact_iff\n\n"}
{"name":"Topology.IsEmbedding.isSigmaCompact_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nhf : Topology.IsEmbedding f\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact (Set.image f s))","decl":"/-- If `f : X ‚Üí Y` is an embedding, the image `f '' s` of a set `s` is œÉ-compact\nif and only `s` is œÉ-compact. -/\nlemma Topology.IsEmbedding.isSigmaCompact_iff {f : X ‚Üí Y} {s : Set X}\n    (hf : IsEmbedding f) : IsSigmaCompact s ‚Üî IsSigmaCompact (f '' s) :=\n  hf.isInducing.isSigmaCompact_iff\n\n"}
{"name":"Embedding.isSigmaCompact_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\ns : Set X\nhf : Topology.IsEmbedding f\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact (Set.image f s))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.isSigmaCompact_iff := IsEmbedding.isSigmaCompact_iff\n\n"}
{"name":"Subtype.isSigmaCompact_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\np : X ‚Üí Prop\ns : Set (Subtype fun a => p a)\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact (Set.image Subtype.val s))","decl":"/-- Sets of subtype are œÉ-compact iff the image under a coercion is. -/\nlemma Subtype.isSigmaCompact_iff {p : X ‚Üí Prop} {s : Set { a // p a }} :\n    IsSigmaCompact s ‚Üî IsSigmaCompact ((‚Üë) '' s : Set X) :=\n  IsEmbedding.subtypeVal.isSigmaCompact_iff\n\n"}
{"name":"SigmaCompactSpace.isSigmaCompact_univ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : SigmaCompactSpace X\n‚ä¢ IsSigmaCompact Set.univ","decl":"/-- A œÉ-compact space is a space that is the union of a countable collection of compact subspaces.\n  Note that a locally compact separable T‚ÇÇ space need not be œÉ-compact.\n  The sequence can be extracted using `compactCovering`. -/\nclass SigmaCompactSpace (X : Type*) [TopologicalSpace X] : Prop where\n  /-- In a œÉ-compact space, `Set.univ` is a œÉ-compact set. -/\n  isSigmaCompact_univ : IsSigmaCompact (univ : Set X)\n\n"}
{"name":"isSigmaCompact_univ_iff","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (IsSigmaCompact Set.univ) (SigmaCompactSpace X)","decl":"/-- A topological space is œÉ-compact iff `univ` is œÉ-compact. -/\nlemma isSigmaCompact_univ_iff : IsSigmaCompact (univ : Set X) ‚Üî SigmaCompactSpace X :=\n  ‚ü®fun h => ‚ü®h‚ü©, fun h => h.1‚ü©\n\n"}
{"name":"isSigmaCompact_univ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : SigmaCompactSpace X\n‚ä¢ IsSigmaCompact Set.univ","decl":"/-- In a œÉ-compact space, `univ` is œÉ-compact. -/\nlemma isSigmaCompact_univ [h : SigmaCompactSpace X] : IsSigmaCompact (univ : Set X) :=\n  isSigmaCompact_univ_iff.mpr h\n\n"}
{"name":"SigmaCompactSpace_iff_exists_compact_covering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (SigmaCompactSpace X) (Exists fun K => And (‚àÄ (n : Nat), IsCompact (K n)) (Eq (Set.iUnion fun n => K n) Set.univ))","decl":"/-- A topological space is œÉ-compact iff there exists a countable collection of compact\nsubspaces that cover the entire space. -/\nlemma SigmaCompactSpace_iff_exists_compact_covering :\n    SigmaCompactSpace X ‚Üî ‚àÉ K : ‚Ñï ‚Üí Set X, (‚àÄ n, IsCompact (K n)) ‚àß ‚ãÉ n, K n = univ := by\n  rw [‚Üê isSigmaCompact_univ_iff, IsSigmaCompact]\n\n"}
{"name":"SigmaCompactSpace.exists_compact_covering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : SigmaCompactSpace X\n‚ä¢ Exists fun K => And (‚àÄ (n : Nat), IsCompact (K n)) (Eq (Set.iUnion fun n => K n) Set.univ)","decl":"lemma SigmaCompactSpace.exists_compact_covering [h : SigmaCompactSpace X] :\n    ‚àÉ K : ‚Ñï ‚Üí Set X, (‚àÄ n, IsCompact (K n)) ‚àß ‚ãÉ n, K n = univ :=\n  SigmaCompactSpace_iff_exists_compact_covering.mp h\n\n"}
{"name":"isSigmaCompact_range","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nf : X ‚Üí Y\nhf : Continuous f\ninst‚úù : SigmaCompactSpace X\n‚ä¢ IsSigmaCompact (Set.range f)","decl":"/-- If `X` is œÉ-compact, `im f` is œÉ-compact. -/\nlemma isSigmaCompact_range {f : X ‚Üí Y} (hf : Continuous f) [SigmaCompactSpace X] :\n    IsSigmaCompact (range f) :=\n  image_univ ‚ñ∏ isSigmaCompact_univ.image hf\n\n"}
{"name":"isSigmaCompact_iff_isSigmaCompact_univ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (IsSigmaCompact s) (IsSigmaCompact Set.univ)","decl":"/-- A subset `s` is œÉ-compact iff `s` (with the subspace topology) is a œÉ-compact space. -/\nlemma isSigmaCompact_iff_isSigmaCompact_univ {s : Set X} :\n    IsSigmaCompact s ‚Üî IsSigmaCompact (univ : Set s) := by\n  rw [Subtype.isSigmaCompact_iff, image_univ, Subtype.range_coe]\n\n"}
{"name":"isSigmaCompact_iff_sigmaCompactSpace","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\ns : Set X\n‚ä¢ Iff (IsSigmaCompact s) (SigmaCompactSpace ‚Üës)","decl":"lemma isSigmaCompact_iff_sigmaCompactSpace {s : Set X} :\n    IsSigmaCompact s ‚Üî SigmaCompactSpace s :=\n  isSigmaCompact_iff_isSigmaCompact_univ.trans isSigmaCompact_univ_iff\n\n-- see Note [lower instance priority]\n"}
{"name":"CompactSpace.sigmaCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\n‚ä¢ SigmaCompactSpace X","decl":"instance (priority := 200) CompactSpace.sigmaCompact [CompactSpace X] : SigmaCompactSpace X :=\n  ‚ü®‚ü®fun _ => univ, fun _ => isCompact_univ, iUnion_const _‚ü©‚ü©\n\n-- The `alias` command creates a definition, triggering the defLemma linter.\n"}
{"name":"CompactSpace.sigma_compact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\n‚ä¢ SigmaCompactSpace X","decl":"@[nolint defLemma, deprecated (since := \"2024-11-13\")] alias\nCompactSpace.sigma_compact := CompactSpace.sigmaCompact\n\n"}
{"name":"SigmaCompactSpace.of_countable","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nS : Set (Set X)\nHc : S.Countable\nHcomp : ‚àÄ (s : Set X), Membership.mem S s ‚Üí IsCompact s\nHU : Eq S.sUnion Set.univ\n‚ä¢ SigmaCompactSpace X","decl":"theorem SigmaCompactSpace.of_countable (S : Set (Set X)) (Hc : S.Countable)\n    (Hcomp : ‚àÄ s ‚àà S, IsCompact s) (HU : ‚ãÉ‚ÇÄ S = univ) : SigmaCompactSpace X :=\n  ‚ü®(exists_seq_cover_iff_countable ‚ü®_, isCompact_empty‚ü©).2 ‚ü®S, Hc, Hcomp, HU‚ü©‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"sigmaCompactSpace_of_locallyCompact_secondCountable","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : SecondCountableTopology X\n‚ä¢ SigmaCompactSpace X","decl":"instance (priority := 100) sigmaCompactSpace_of_locallyCompact_secondCountable\n    [LocallyCompactSpace X] [SecondCountableTopology X] : SigmaCompactSpace X := by\n  choose K hKc hxK using fun x : X => exists_compact_mem_nhds x\n  rcases countable_cover_nhds hxK with ‚ü®s, hsc, hsU‚ü©\n  refine SigmaCompactSpace.of_countable _ (hsc.image K) (forall_mem_image.2 fun x _ => hKc x) ?_\n  rwa [sUnion_image]\n\n-- The `alias` command creates a definition, triggering the defLemma linter.\n"}
{"name":"sigmaCompactSpace_of_locally_compact_second_countable","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : SecondCountableTopology X\n‚ä¢ SigmaCompactSpace X","decl":"@[nolint defLemma, deprecated (since := \"2024-11-13\")]\nalias sigmaCompactSpace_of_locally_compact_second_countable :=\n  sigmaCompactSpace_of_locallyCompact_secondCountable\n\n"}
{"name":"isCompact_compactCovering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nn : Nat\n‚ä¢ IsCompact (compactCovering X n)","decl":"theorem isCompact_compactCovering (n : ‚Ñï) : IsCompact (compactCovering X n) :=\n  isCompact_accumulate (Classical.choose_spec SigmaCompactSpace.exists_compact_covering).1 n\n\n"}
{"name":"iUnion_compactCovering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\n‚ä¢ Eq (Set.iUnion fun n => compactCovering X n) Set.univ","decl":"theorem iUnion_compactCovering : ‚ãÉ n, compactCovering X n = univ := by\n  rw [compactCovering, iUnion_accumulate]\n  exact (Classical.choose_spec SigmaCompactSpace.exists_compact_covering).2\n\n"}
{"name":"iUnion_closure_compactCovering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\n‚ä¢ Eq (Set.iUnion fun n => closure (compactCovering X n)) Set.univ","decl":"theorem iUnion_closure_compactCovering : ‚ãÉ n, closure (compactCovering X n) = univ :=\n  eq_top_mono (iUnion_mono fun _ ‚Ü¶ subset_closure) (iUnion_compactCovering X)\n\n"}
{"name":"compactCovering_subset","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nm n : Nat\nh : LE.le m n\n‚ä¢ HasSubset.Subset (compactCovering X m) (compactCovering X n)","decl":"@[mono, gcongr]\ntheorem compactCovering_subset ‚¶Ém n : ‚Ñï‚¶Ñ (h : m ‚â§ n) : compactCovering X m ‚äÜ compactCovering X n :=\n  monotone_accumulate h\n\n"}
{"name":"exists_mem_compactCovering","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nx : X\n‚ä¢ Exists fun n => Membership.mem (compactCovering X n) x","decl":"theorem exists_mem_compactCovering (x : X) : ‚àÉ n, x ‚àà compactCovering X n :=\n  iUnion_eq_univ_iff.mp (iUnion_compactCovering X) x\n\n"}
{"name":"instSigmaCompactSpaceProd","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SigmaCompactSpace X\ninst‚úù : SigmaCompactSpace Y\n‚ä¢ SigmaCompactSpace (Prod X Y)","decl":"instance [SigmaCompactSpace Y] : SigmaCompactSpace (X √ó Y) :=\n  ‚ü®‚ü®fun n => compactCovering X n √óÀ¢ compactCovering Y n, fun _ =>\n      (isCompact_compactCovering _ _).prod (isCompact_compactCovering _ _), by\n      simp only [iUnion_prod_of_monotone (compactCovering_subset X) (compactCovering_subset Y),\n        iUnion_compactCovering, univ_prod_univ]‚ü©‚ü©\n\n"}
{"name":"instSigmaCompactSpaceForallOfFinite","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"Œπ : Type u_3\ninst‚úù¬≤ : Finite Œπ\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), SigmaCompactSpace (X i)\n‚ä¢ SigmaCompactSpace ((i : Œπ) ‚Üí X i)","decl":"instance [Finite Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, SigmaCompactSpace (X i)] :\n    SigmaCompactSpace (‚àÄ i, X i) := by\n  refine ‚ü®‚ü®fun n => Set.pi univ fun i => compactCovering (X i) n,\n    fun n => isCompact_univ_pi fun i => isCompact_compactCovering (X i) _, ?_‚ü©‚ü©\n  rw [iUnion_univ_pi_of_monotone]\n  ¬∑ simp only [iUnion_compactCovering, pi_univ]\n  ¬∑ exact fun i => compactCovering_subset (X i)\n\n"}
{"name":"instSigmaCompactSpaceSum","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SigmaCompactSpace X\ninst‚úù : SigmaCompactSpace Y\n‚ä¢ SigmaCompactSpace (Sum X Y)","decl":"instance [SigmaCompactSpace Y] : SigmaCompactSpace (X ‚äï Y) :=\n  ‚ü®‚ü®fun n => Sum.inl '' compactCovering X n ‚à™ Sum.inr '' compactCovering Y n, fun n =>\n      ((isCompact_compactCovering X n).image continuous_inl).union\n        ((isCompact_compactCovering Y n).image continuous_inr),\n      by simp only [iUnion_union_distrib, ‚Üê image_iUnion, iUnion_compactCovering, image_univ,\n        range_inl_union_range_inr]‚ü©‚ü©\n\n"}
{"name":"instSigmaCompactSpaceSigmaOfCountable","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"Œπ : Type u_3\ninst‚úù¬≤ : Countable Œπ\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), SigmaCompactSpace (X i)\n‚ä¢ SigmaCompactSpace (Sigma fun i => X i)","decl":"instance [Countable Œπ] {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]\n    [‚àÄ i, SigmaCompactSpace (X i)] : SigmaCompactSpace (Œ£i, X i) := by\n  cases isEmpty_or_nonempty Œπ\n  ¬∑ infer_instance\n  ¬∑ rcases exists_surjective_nat Œπ with ‚ü®f, hf‚ü©\n    refine ‚ü®‚ü®fun n => ‚ãÉ k ‚â§ n, Sigma.mk (f k) '' compactCovering (X (f k)) n, fun n => ?_, ?_‚ü©‚ü©\n    ¬∑ refine (finite_le_nat _).isCompact_biUnion fun k _ => ?_\n      exact (isCompact_compactCovering _ _).image continuous_sigmaMk\n    ¬∑ simp only [iUnion_eq_univ_iff, Sigma.forall, mem_iUnion, hf.forall]\n      intro k y\n      rcases exists_mem_compactCovering y with ‚ü®n, hn‚ü©\n      refine ‚ü®max k n, k, le_max_left _ _, mem_image_of_mem _ ?_‚ü©\n      exact compactCovering_subset _ (le_max_right _ _) hn\n\n"}
{"name":"Topology.IsClosedEmbedding.sigmaCompactSpace","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SigmaCompactSpace X\ne : Y ‚Üí X\nhe : Topology.IsClosedEmbedding e\n‚ä¢ SigmaCompactSpace Y","decl":"protected lemma Topology.IsClosedEmbedding.sigmaCompactSpace {e : Y ‚Üí X}\n    (he : IsClosedEmbedding e) : SigmaCompactSpace Y :=\n  ‚ü®‚ü®fun n => e ‚Åª¬π' compactCovering X n, fun _ =>\n      he.isCompact_preimage (isCompact_compactCovering _ _), by\n      rw [‚Üê preimage_iUnion, iUnion_compactCovering, preimage_univ]‚ü©‚ü©\n\n"}
{"name":"ClosedEmbedding.sigmaCompactSpace","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SigmaCompactSpace X\ne : Y ‚Üí X\nhe : Topology.IsClosedEmbedding e\n‚ä¢ SigmaCompactSpace Y","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.sigmaCompactSpace := IsClosedEmbedding.sigmaCompactSpace\n\n"}
{"name":"IsClosed.sigmaCompactSpace","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\ns : Set X\nhs : IsClosed s\n‚ä¢ SigmaCompactSpace ‚Üës","decl":"theorem IsClosed.sigmaCompactSpace {s : Set X} (hs : IsClosed s) : SigmaCompactSpace s :=\n  hs.isClosedEmbedding_subtypeVal.sigmaCompactSpace\n\n"}
{"name":"instSigmaCompactSpaceULift","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SigmaCompactSpace Y\n‚ä¢ SigmaCompactSpace (ULift.{u, u_2} Y)","decl":"instance [SigmaCompactSpace Y] : SigmaCompactSpace (ULift.{u} Y) :=\n  IsClosedEmbedding.uliftDown.sigmaCompactSpace\n\n"}
{"name":"LocallyFinite.countable_univ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\nŒπ : Type u_3\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nf : Œπ ‚Üí Set X\nhf : LocallyFinite f\nhne : ‚àÄ (i : Œπ), (f i).Nonempty\n‚ä¢ Set.univ.Countable","decl":"/-- If `X` is a `œÉ`-compact space, then a locally finite family of nonempty sets of `X` can have\nonly countably many elements, `Set.Countable` version. -/\nprotected theorem LocallyFinite.countable_univ {f : Œπ ‚Üí Set X} (hf : LocallyFinite f)\n    (hne : ‚àÄ i, (f i).Nonempty) : (univ : Set Œπ).Countable := by\n  have := fun n => hf.finite_nonempty_inter_compact (isCompact_compactCovering X n)\n  refine (countable_iUnion fun n => (this n).countable).mono fun i _ => ?_\n  rcases hne i with ‚ü®x, hx‚ü©\n  rcases iUnion_eq_univ_iff.1 (iUnion_compactCovering X) x with ‚ü®n, hn‚ü©\n  exact mem_iUnion.2 ‚ü®n, x, hx, hn‚ü©\n\n"}
{"name":"countable_cover_nhdsWithin_of_sigmaCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nf : X ‚Üí Set X\ns : Set X\nhs : IsClosed s\nhf : ‚àÄ (x : X), Membership.mem s x ‚Üí Membership.mem (nhdsWithin x s) (f x)\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => f x)))","decl":"/-- In a topological space with sigma compact topology, if `f` is a function that sends each point\n`x` of a closed set `s` to a neighborhood of `x` within `s`, then for some countable set `t ‚äÜ s`,\nthe neighborhoods `f x`, `x ‚àà t`, cover the whole set `s`. -/\ntheorem countable_cover_nhdsWithin_of_sigmaCompact {f : X ‚Üí Set X} {s : Set X} (hs : IsClosed s)\n    (hf : ‚àÄ x ‚àà s, f x ‚àà ùìù[s] x) : ‚àÉ t ‚äÜ s, t.Countable ‚àß s ‚äÜ ‚ãÉ x ‚àà t, f x := by\n  simp only [nhdsWithin, mem_inf_principal] at hf\n  choose t ht hsub using fun n =>\n    ((isCompact_compactCovering X n).inter_right hs).elim_nhds_subcover _ fun x hx => hf x hx.right\n  refine\n    ‚ü®‚ãÉ n, (t n : Set X), iUnion_subset fun n x hx => (ht n x hx).2,\n      countable_iUnion fun n => (t n).countable_toSet, fun x hx => mem_iUnion‚ÇÇ.2 ?_‚ü©\n  rcases exists_mem_compactCovering x with ‚ü®n, hn‚ü©\n  rcases mem_iUnion‚ÇÇ.1 (hsub n ‚ü®hn, hx‚ü©) with ‚ü®y, hyt : y ‚àà t n, hyf : x ‚àà s ‚Üí x ‚àà f y‚ü©\n  exact ‚ü®y, mem_iUnion.2 ‚ü®n, hyt‚ü©, hyf hx‚ü©\n\n"}
{"name":"countable_cover_nhdsWithin_of_sigma_compact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nf : X ‚Üí Set X\ns : Set X\nhs : IsClosed s\nhf : ‚àÄ (x : X), Membership.mem s x ‚Üí Membership.mem (nhdsWithin x s) (f x)\n‚ä¢ Exists fun t => And (HasSubset.Subset t s) (And t.Countable (HasSubset.Subset s (Set.iUnion fun x => Set.iUnion fun h => f x)))","decl":"@[deprecated (since := \"2024-11-13\")] alias\ncountable_cover_nhdsWithin_of_sigma_compact := countable_cover_nhdsWithin_of_sigmaCompact\n\n"}
{"name":"countable_cover_nhds_of_sigmaCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nf : X ‚Üí Set X\nhf : ‚àÄ (x : X), Membership.mem (nhds x) (f x)\n‚ä¢ Exists fun s => And s.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => f x) Set.univ)","decl":"/-- In a topological space with sigma compact topology, if `f` is a function that sends each\npoint `x` to a neighborhood of `x`, then for some countable set `s`, the neighborhoods `f x`,\n`x ‚àà s`, cover the whole space. -/\ntheorem countable_cover_nhds_of_sigmaCompact {f : X ‚Üí Set X} (hf : ‚àÄ x, f x ‚àà ùìù x) :\n    ‚àÉ s : Set X, s.Countable ‚àß ‚ãÉ x ‚àà s, f x = univ := by\n  simp only [‚Üê nhdsWithin_univ] at hf\n  rcases countable_cover_nhdsWithin_of_sigmaCompact isClosed_univ fun x _ => hf x with\n    ‚ü®s, -, hsc, hsU‚ü©\n  exact ‚ü®s, hsc, univ_subset_iff.1 hsU‚ü©\n"}
{"name":"countable_cover_nhds_of_sigma_compact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SigmaCompactSpace X\nf : X ‚Üí Set X\nhf : ‚àÄ (x : X), Membership.mem (nhds x) (f x)\n‚ä¢ Exists fun s => And s.Countable (Eq (Set.iUnion fun x => Set.iUnion fun h => f x) Set.univ)","decl":"@[deprecated (since := \"2024-11-13\")] alias\ncountable_cover_nhds_of_sigma_compact := countable_cover_nhds_of_sigmaCompact\n\n\n"}
{"name":"CompactExhaustion.iUnion_eq'","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : CompactExhaustion X\n‚ä¢ Eq (Set.iUnion fun n => self.toFun n) Set.univ","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.mk.inj","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\ntoFun‚úù : Nat ‚Üí Set X\nisCompact'‚úù : ‚àÄ (n : Nat), IsCompact (toFun‚úù n)\nsubset_interior_succ'‚úù : ‚àÄ (n : Nat), HasSubset.Subset (toFun‚úù n) (interior (toFun‚úù (HAdd.hAdd n 1)))\niUnion_eq'‚úù : Eq (Set.iUnion fun n => toFun‚úù n) Set.univ\ntoFun : Nat ‚Üí Set X\nisCompact' : ‚àÄ (n : Nat), IsCompact (toFun n)\nsubset_interior_succ' : ‚àÄ (n : Nat), HasSubset.Subset (toFun n) (interior (toFun (HAdd.hAdd n 1)))\niUnion_eq' : Eq (Set.iUnion fun n => toFun n) Set.univ\nx‚úù : Eq { toFun := toFun‚úù, isCompact' := isCompact'‚úù, subset_interior_succ' := subset_interior_succ'‚úù, iUnion_eq' := iUnion_eq'‚úù } { toFun := toFun, isCompact' := isCompact', subset_interior_succ' := subset_interior_succ', iUnion_eq' := iUnion_eq' }\n‚ä¢ Eq toFun‚úù toFun","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.mk.injEq","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\ntoFun‚úù : Nat ‚Üí Set X\nisCompact'‚úù : ‚àÄ (n : Nat), IsCompact (toFun‚úù n)\nsubset_interior_succ'‚úù : ‚àÄ (n : Nat), HasSubset.Subset (toFun‚úù n) (interior (toFun‚úù (HAdd.hAdd n 1)))\niUnion_eq'‚úù : Eq (Set.iUnion fun n => toFun‚úù n) Set.univ\ntoFun : Nat ‚Üí Set X\nisCompact' : ‚àÄ (n : Nat), IsCompact (toFun n)\nsubset_interior_succ' : ‚àÄ (n : Nat), HasSubset.Subset (toFun n) (interior (toFun (HAdd.hAdd n 1)))\niUnion_eq' : Eq (Set.iUnion fun n => toFun n) Set.univ\n‚ä¢ Eq (Eq { toFun := toFun‚úù, isCompact' := isCompact'‚úù, subset_interior_succ' := subset_interior_succ'‚úù, iUnion_eq' := iUnion_eq'‚úù } { toFun := toFun, isCompact' := isCompact', subset_interior_succ' := subset_interior_succ', iUnion_eq' := iUnion_eq' }) (Eq toFun‚úù toFun)","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.subset_interior_succ'","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : CompactExhaustion X\nn : Nat\n‚ä¢ HasSubset.Subset (self.toFun n) (interior (self.toFun (HAdd.hAdd n 1)))","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.isCompact'","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù : TopologicalSpace X\nself : CompactExhaustion X\nn : Nat\n‚ä¢ IsCompact (self.toFun n)","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.mk.sizeOf_spec","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_4\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : SizeOf X\ntoFun : Nat ‚Üí Set X\nisCompact' : ‚àÄ (n : Nat), IsCompact (toFun n)\nsubset_interior_succ' : ‚àÄ (n : Nat), HasSubset.Subset (toFun n) (interior (toFun (HAdd.hAdd n 1)))\niUnion_eq' : Eq (Set.iUnion fun n => toFun n) Set.univ\n‚ä¢ Eq (SizeOf.sizeOf { toFun := toFun, isCompact' := isCompact', subset_interior_succ' := subset_interior_succ', iUnion_eq' := iUnion_eq' }) (HAdd.hAdd 1 (SizeOf.sizeOf iUnion_eq'))","decl":"/-- An [exhaustion by compact sets](https://en.wikipedia.org/wiki/Exhaustion_by_compact_sets) of a\ntopological space is a sequence of compact sets `K n` such that `K n ‚äÜ interior (K (n + 1))` and\n`‚ãÉ n, K n = univ`.\n\nIf `X` is a locally compact sigma compact space, then `CompactExhaustion.choice X` provides\na choice of an exhaustion by compact sets. This choice is also available as\n`(default : CompactExhaustion X)`. -/\nstructure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  /-- The sequence of compact sets that form a compact exhaustion. -/\n  toFun : ‚Ñï ‚Üí Set X\n  /-- The sets in the compact exhaustion are in fact compact. -/\n  isCompact' : ‚àÄ n, IsCompact (toFun n)\n  /-- The sets in the compact exhaustion form a sequence:\n    each set is contained in the interior of the next. -/\n  subset_interior_succ' : ‚àÄ n, toFun n ‚äÜ interior (toFun (n + 1))\n  /-- The union of all sets in a compact exhaustion equals the entire space. -/\n  iUnion_eq' : ‚ãÉ n, toFun n = univ\n\n"}
{"name":"CompactExhaustion.instRelHomClassNatSetLeSubset","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ RelHomClass (CompactExhaustion X) LE.le HasSubset.Subset","decl":"instance : RelHomClass (CompactExhaustion X) LE.le HasSubset.Subset where\n  map_rel f _ _ h := monotone_nat_of_le_succ\n    (fun n ‚Ü¶ (f.subset_interior_succ' n).trans interior_subset) h\n\n"}
{"name":"CompactExhaustion.toFun_eq_coe","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\n‚ä¢ Eq K.toFun ‚áëK","decl":"@[simp]\ntheorem toFun_eq_coe : K.toFun = K := rfl\n\n"}
{"name":"CompactExhaustion.isCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nn : Nat\n‚ä¢ IsCompact (K n)","decl":"protected theorem isCompact (n : ‚Ñï) : IsCompact (K n) :=\n  K.isCompact' n\n\n"}
{"name":"CompactExhaustion.subset_interior_succ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nn : Nat\n‚ä¢ HasSubset.Subset (K n) (interior (K (HAdd.hAdd n 1)))","decl":"theorem subset_interior_succ (n : ‚Ñï) : K n ‚äÜ interior (K (n + 1)) :=\n  K.subset_interior_succ' n\n\n"}
{"name":"CompactExhaustion.subset","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nm n : Nat\nh : LE.le m n\n‚ä¢ HasSubset.Subset (K m) (K n)","decl":"@[mono]\nprotected theorem subset ‚¶Ém n : ‚Ñï‚¶Ñ (h : m ‚â§ n) : K m ‚äÜ K n :=\n  OrderHomClass.mono K h\n\n"}
{"name":"CompactExhaustion.subset_succ","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nn : Nat\n‚ä¢ HasSubset.Subset (K n) (K (HAdd.hAdd n 1))","decl":"theorem subset_succ (n : ‚Ñï) : K n ‚äÜ K (n + 1) := K.subset n.le_succ\n\n"}
{"name":"CompactExhaustion.subset_interior","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nm n : Nat\nh : LT.lt m n\n‚ä¢ HasSubset.Subset (K m) (interior (K n))","decl":"theorem subset_interior ‚¶Ém n : ‚Ñï‚¶Ñ (h : m < n) : K m ‚äÜ interior (K n) :=\n  Subset.trans (K.subset_interior_succ m) <| interior_mono <| K.subset h\n\n"}
{"name":"CompactExhaustion.iUnion_eq","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\n‚ä¢ Eq (Set.iUnion fun n => K n) Set.univ","decl":"theorem iUnion_eq : ‚ãÉ n, K n = univ :=\n  K.iUnion_eq'\n\n"}
{"name":"CompactExhaustion.exists_mem","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\n‚ä¢ Exists fun n => Membership.mem (K n) x","decl":"theorem exists_mem (x : X) : ‚àÉ n, x ‚àà K n :=\n  iUnion_eq_univ_iff.1 K.iUnion_eq x\n\n"}
{"name":"CompactExhaustion.exists_mem_nhds","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\n‚ä¢ Exists fun n => Membership.mem (nhds x) (K n)","decl":"theorem exists_mem_nhds (x : X) : ‚àÉ n, K n ‚àà ùìù x := by\n  rcases K.exists_mem x with ‚ü®n, hn‚ü©\n  exact ‚ü®n + 1, mem_interior_iff_mem_nhds.mp <| K.subset_interior_succ n hn‚ü©\n\n"}
{"name":"CompactExhaustion.exists_superset_of_isCompact","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\ns : Set X\nhs : IsCompact s\n‚ä¢ Exists fun n => HasSubset.Subset s (K n)","decl":"/-- A compact exhaustion eventually covers any compact set. -/\ntheorem exists_superset_of_isCompact {s : Set X} (hs : IsCompact s) : ‚àÉ n, s ‚äÜ K n := by\n  suffices ‚àÉ n, s ‚äÜ interior (K n) from this.imp fun _ ‚Ü¶ (Subset.trans ¬∑ interior_subset)\n  refine hs.elim_directed_cover (interior ‚àò K) (fun _ ‚Ü¶ isOpen_interior) ?_ ?_\n  ¬∑ intro x _\n    rcases K.exists_mem x with ‚ü®k, hk‚ü©\n    exact mem_iUnion.2 ‚ü®k + 1, K.subset_interior_succ _ hk‚ü©\n  ¬∑ exact Monotone.directed_le fun _ _ h ‚Ü¶ interior_mono <| K.subset h\n\n"}
{"name":"CompactExhaustion.mem_find","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\n‚ä¢ Membership.mem (K (K.find x)) x","decl":"theorem mem_find (x : X) : x ‚àà K (K.find x) := by\n  classical\n  exact Nat.find_spec (K.exists_mem x)\n\n"}
{"name":"CompactExhaustion.mem_iff_find_le","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\nn : Nat\n‚ä¢ Iff (Membership.mem (K n) x) (LE.le (K.find x) n)","decl":"theorem mem_iff_find_le {x : X} {n : ‚Ñï} : x ‚àà K n ‚Üî K.find x ‚â§ n := by\n  classical\n  exact ‚ü®fun h => Nat.find_min' (K.exists_mem x) h, fun h => K.subset h <| K.mem_find x‚ü©\n\n"}
{"name":"CompactExhaustion.find_shiftr","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\n‚ä¢ Eq (K.shiftr.find x) (HAdd.hAdd (K.find x) 1)","decl":"@[simp]\ntheorem find_shiftr (x : X) : K.shiftr.find x = K.find x + 1 := by\n  classical\n  exact Nat.find_comp_succ _ _ (not_mem_empty _)\n\n"}
{"name":"CompactExhaustion.mem_diff_shiftr_find","module":"Mathlib.Topology.Compactness.SigmaCompact","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nK : CompactExhaustion X\nx : X\n‚ä¢ Membership.mem (SDiff.sdiff (K.shiftr (HAdd.hAdd (K.find x) 1)) (K.shiftr (K.find x))) x","decl":"theorem mem_diff_shiftr_find (x : X) : x ‚àà K.shiftr (K.find x + 1) \\ K.shiftr (K.find x) :=\n  ‚ü®K.mem_find _,\n    mt K.shiftr.mem_iff_find_le.1 <| by simp only [find_shiftr, not_le, Nat.lt_succ_self]‚ü©\n\n"}
