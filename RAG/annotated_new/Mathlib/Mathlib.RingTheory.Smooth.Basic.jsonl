{"name":"Algebra.FormallySmooth.comp_surjective","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type u\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nself : Algebra.FormallySmooth R A\nB : Type u\ninst✝¹ : CommRing B\ninst✝ : Algebra R B\nI : Ideal B\nx✝ : Eq (HPow.hPow I 2) Bot.bot\n⊢ Function.Surjective (Ideal.Quotient.mkₐ R I).comp","decl":"/-- An `R` algebra `A` is formally smooth if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A →ₐ[R] B ⧸ I`, there exists at least one lift `A →ₐ[R] B`. -/\n@[mk_iff, stacks 00TI]\nclass FormallySmooth : Prop where\n  comp_surjective :\n    ∀ ⦃B : Type u⦄ [CommRing B],\n      ∀ [Algebra R B] (I : Ideal B) (_ : I ^ 2 = ⊥),\n        Function.Surjective ((Ideal.Quotient.mkₐ R I).comp : (A →ₐ[R] B) → A →ₐ[R] B ⧸ I)\n\n"}
{"name":"Algebra.formallySmooth_iff","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type u\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Iff (Algebra.FormallySmooth R A) (∀ ⦃B : Type u⦄ [inst : CommRing B] [inst_1 : Algebra R B] (I : Ideal B), Eq (HPow.hPow I 2) Bot.bot → Function.Surjective (Ideal.Quotient.mkₐ R I).comp)","decl":"/-- An `R` algebra `A` is formally smooth if for every `R`-algebra, every square-zero ideal\n`I : Ideal B` and `f : A →ₐ[R] B ⧸ I`, there exists at least one lift `A →ₐ[R] B`. -/\n@[mk_iff, stacks 00TI]\nclass FormallySmooth : Prop where\n  comp_surjective :\n    ∀ ⦃B : Type u⦄ [CommRing B],\n      ∀ [Algebra R B] (I : Ideal B) (_ : I ^ 2 = ⊥),\n        Function.Surjective ((Ideal.Quotient.mkₐ R I).comp : (A →ₐ[R] B) → A →ₐ[R] B ⧸ I)\n\n"}
{"name":"Algebra.FormallySmooth.exists_lift","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type u\ninst✝³ : Semiring A\ninst✝² : Algebra R A\nB : Type u\ninst✝¹ : CommRing B\n_RB : Algebra R B\ninst✝ : Algebra.FormallySmooth R A\nI : Ideal B\nhI : IsNilpotent I\ng : AlgHom R A (HasQuotient.Quotient B I)\n⊢ Exists fun f => Eq ((Ideal.Quotient.mkₐ R I).comp f) g","decl":"theorem exists_lift {B : Type u} [CommRing B] [_RB : Algebra R B]\n    [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I) (g : A →ₐ[R] B ⧸ I) :\n    ∃ f : A →ₐ[R] B, (Ideal.Quotient.mkₐ R I).comp f = g := by\n  revert g\n  change Function.Surjective (Ideal.Quotient.mkₐ R I).comp\n  revert _RB\n  apply Ideal.IsNilpotent.induction_on (S := B) I hI\n  · intro B _ I hI _; exact FormallySmooth.comp_surjective I hI\n  · intro B _ I J hIJ h₁ h₂ _ g\n    let this : ((B ⧸ I) ⧸ J.map (Ideal.Quotient.mk I)) ≃ₐ[R] B ⧸ J :=\n      {\n        (DoubleQuot.quotQuotEquivQuotSup I J).trans\n          (Ideal.quotEquivOfEq (sup_eq_right.mpr hIJ)) with\n        commutes' := fun x => rfl }\n    obtain ⟨g', e⟩ := h₂ (this.symm.toAlgHom.comp g)\n    obtain ⟨g', rfl⟩ := h₁ g'\n    replace e := congr_arg this.toAlgHom.comp e\n    conv_rhs at e =>\n      rw [← AlgHom.comp_assoc, AlgEquiv.toAlgHom_eq_coe, AlgEquiv.toAlgHom_eq_coe,\n        AlgEquiv.comp_symm, AlgHom.id_comp]\n    exact ⟨g', e⟩\n\n"}
{"name":"Algebra.FormallySmooth.comp_lift","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nA : Type u\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\nB : Type u\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallySmooth R A\nI : Ideal B\nhI : IsNilpotent I\ng : AlgHom R A (HasQuotient.Quotient B I)\n⊢ Eq ((Ideal.Quotient.mkₐ R I).comp (Algebra.FormallySmooth.lift I hI g)) g","decl":"@[simp]\ntheorem comp_lift [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I)\n    (g : A →ₐ[R] B ⧸ I) : (Ideal.Quotient.mkₐ R I).comp (FormallySmooth.lift I hI g) = g :=\n  (FormallySmooth.exists_lift I hI g).choose_spec\n\n"}
{"name":"Algebra.FormallySmooth.mk_lift","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nA : Type u\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\nB : Type u\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallySmooth R A\nI : Ideal B\nhI : IsNilpotent I\ng : AlgHom R A (HasQuotient.Quotient B I)\nx : A\n⊢ Eq ((Ideal.Quotient.mk I) ((Algebra.FormallySmooth.lift I hI g) x)) (g x)","decl":"@[simp]\ntheorem mk_lift [FormallySmooth R A] (I : Ideal B) (hI : IsNilpotent I)\n    (g : A →ₐ[R] B ⧸ I) (x : A) : Ideal.Quotient.mk I (FormallySmooth.lift I hI g x) = g x :=\n  AlgHom.congr_fun (FormallySmooth.comp_lift I hI g :) x\n\n"}
{"name":"Algebra.FormallySmooth.liftOfSurjective_apply","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁷ : CommSemiring R\nA : Type u\ninst✝⁶ : Semiring A\ninst✝⁵ : Algebra R A\nB : Type u\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\nC : Type u\ninst✝² : CommRing C\ninst✝¹ : Algebra R C\ninst✝ : Algebra.FormallySmooth R A\nf : AlgHom R A C\ng : AlgHom R B C\nhg : Function.Surjective ⇑g\nhg' : IsNilpotent (RingHom.ker ↑g)\nx : A\n⊢ Eq (g ((Algebra.FormallySmooth.liftOfSurjective f g hg hg') x)) (f x)","decl":"@[simp]\ntheorem liftOfSurjective_apply [FormallySmooth R A] (f : A →ₐ[R] C) (g : B →ₐ[R] C)\n    (hg : Function.Surjective g) (hg' : IsNilpotent <| RingHom.ker (g : B →+* C)) (x : A) :\n    g (FormallySmooth.liftOfSurjective f g hg hg' x) = f x := by\n  apply (Ideal.quotientKerAlgEquivOfSurjective hg).symm.injective\n  change _ = ((Ideal.quotientKerAlgEquivOfSurjective hg).symm.toAlgHom.comp f) x\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [← FormallySmooth.mk_lift _ hg'\n    ((Ideal.quotientKerAlgEquivOfSurjective hg).symm.toAlgHom.comp f)]\n  apply (Ideal.quotientKerAlgEquivOfSurjective hg).injective\n  simp only [liftOfSurjective, AlgEquiv.apply_symm_apply, AlgEquiv.toAlgHom_eq_coe,\n    Ideal.quotientKerAlgEquivOfSurjective_apply, RingHom.kerLift_mk, RingHom.coe_coe]\n\n"}
{"name":"Algebra.FormallySmooth.comp_liftOfSurjective","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁷ : CommSemiring R\nA : Type u\ninst✝⁶ : Semiring A\ninst✝⁵ : Algebra R A\nB : Type u\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R B\nC : Type u\ninst✝² : CommRing C\ninst✝¹ : Algebra R C\ninst✝ : Algebra.FormallySmooth R A\nf : AlgHom R A C\ng : AlgHom R B C\nhg : Function.Surjective ⇑g\nhg' : IsNilpotent (RingHom.ker ↑g)\n⊢ Eq (g.comp (Algebra.FormallySmooth.liftOfSurjective f g hg hg')) f","decl":"@[simp]\ntheorem comp_liftOfSurjective [FormallySmooth R A] (f : A →ₐ[R] C) (g : B →ₐ[R] C)\n    (hg : Function.Surjective g) (hg' : IsNilpotent <| RingHom.ker (g : B →+* C)) :\n    g.comp (FormallySmooth.liftOfSurjective f g hg hg') = f :=\n  AlgHom.ext (FormallySmooth.liftOfSurjective_apply f g hg hg')\n\n"}
{"name":"Algebra.FormallySmooth.of_equiv","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nA B : Type u\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : Semiring B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallySmooth R A\ne : AlgEquiv R A B\n⊢ Algebra.FormallySmooth R B","decl":"theorem of_equiv [FormallySmooth R A] (e : A ≃ₐ[R] B) : FormallySmooth R B := by\n  constructor\n  intro C _ _ I hI f\n  use (FormallySmooth.lift I ⟨2, hI⟩ (f.comp e : A →ₐ[R] C ⧸ I)).comp e.symm\n  rw [← AlgHom.comp_assoc, FormallySmooth.comp_lift, AlgHom.comp_assoc, AlgEquiv.comp_symm,\n    AlgHom.comp_id]\n\n"}
{"name":"Algebra.FormallySmooth.iff_of_equiv","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA B : Type u\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\ne : AlgEquiv R A B\n⊢ Iff (Algebra.FormallySmooth R A) (Algebra.FormallySmooth R B)","decl":"theorem iff_of_equiv (e : A ≃ₐ[R] B) : FormallySmooth R A ↔ FormallySmooth R B :=\n  ⟨fun _ ↦ of_equiv e, fun _ ↦ of_equiv e.symm⟩\n\n"}
{"name":"Algebra.FormallySmooth.mvPolynomial","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nσ : Type u\n⊢ Algebra.FormallySmooth R (MvPolynomial σ R)","decl":"instance mvPolynomial (σ : Type u) : FormallySmooth R (MvPolynomial σ R) := by\n  constructor\n  intro C _ _ I _ f\n  have : ∀ s : σ, ∃ c : C, Ideal.Quotient.mk I c = f (MvPolynomial.X s) := fun s =>\n    Ideal.Quotient.mk_surjective _\n  choose g hg using this\n  refine ⟨MvPolynomial.aeval g, ?_⟩\n  ext s\n  rw [← hg, AlgHom.comp_apply, MvPolynomial.aeval_X]\n  rfl\n\n"}
{"name":"Algebra.FormallySmooth.polynomial","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n⊢ Algebra.FormallySmooth R (Polynomial R)","decl":"instance polynomial : FormallySmooth R R[X] :=\n  FormallySmooth.of_equiv (MvPolynomial.pUnitAlgEquiv R)\n\n"}
{"name":"Algebra.FormallySmooth.comp","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁸ : CommSemiring R\nA : Type u\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\nB : Type u\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.FormallySmooth R A\ninst✝ : Algebra.FormallySmooth A B\n⊢ Algebra.FormallySmooth R B","decl":"theorem comp [FormallySmooth R A] [FormallySmooth A B] : FormallySmooth R B := by\n  constructor\n  intro C _ _ I hI f\n  obtain ⟨f', e⟩ := FormallySmooth.comp_surjective I hI (f.comp (IsScalarTower.toAlgHom R A B))\n  letI := f'.toRingHom.toAlgebra\n  obtain ⟨f'', e'⟩ :=\n    FormallySmooth.comp_surjective I hI { f.toRingHom with commutes' := AlgHom.congr_fun e.symm }\n  apply_fun AlgHom.restrictScalars R at e'\n  exact ⟨f''.restrictScalars _, e'.trans (AlgHom.ext fun _ => rfl)⟩\n\n\n"}
{"name":"Algebra.FormallySmooth.of_split","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nP A : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\nf : AlgHom R P A\ninst✝ : Algebra.FormallySmooth R P\ng : AlgHom R A (HasQuotient.Quotient P (HPow.hPow (RingHom.ker f.toRingHom) 2))\nhg : Eq (f.kerSquareLift.comp g) (AlgHom.id R A)\n⊢ Algebra.FormallySmooth R A","decl":"theorem of_split [FormallySmooth R P] (g : A →ₐ[R] P ⧸ (RingHom.ker f.toRingHom) ^ 2)\n    (hg : f.kerSquareLift.comp g = AlgHom.id R A) : FormallySmooth R A := by\n  constructor\n  intro C _ _ I hI i\n  let l : P ⧸ (RingHom.ker f.toRingHom) ^ 2 →ₐ[R] C := by\n    refine Ideal.Quotient.liftₐ _ (FormallySmooth.lift I ⟨2, hI⟩ (i.comp f)) ?_\n    have : RingHom.ker f ≤ I.comap (FormallySmooth.lift I ⟨2, hI⟩ (i.comp f)) := by\n      rintro x (hx : f x = 0)\n      have : _ = i (f x) := (FormallySmooth.mk_lift I ⟨2, hI⟩ (i.comp f) x :)\n      rwa [hx, map_zero, ← Ideal.Quotient.mk_eq_mk, Submodule.Quotient.mk_eq_zero] at this\n    intro x hx\n    have := (Ideal.pow_right_mono this 2).trans (Ideal.le_comap_pow _ 2) hx\n    rwa [hI] at this\n  have : i.comp f.kerSquareLift = (Ideal.Quotient.mkₐ R _).comp l := by\n    apply AlgHom.coe_ringHom_injective\n    apply Ideal.Quotient.ringHom_ext\n    ext x\n    exact (FormallySmooth.mk_lift I ⟨2, hI⟩ (i.comp f) x).symm\n  exact ⟨l.comp g, by rw [← AlgHom.comp_assoc, ← this, AlgHom.comp_assoc, hg, AlgHom.comp_id]⟩\n\n"}
{"name":"Algebra.FormallySmooth.iff_split_surjection","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nP A : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\nf : AlgHom R P A\nhf : Function.Surjective ⇑f\ninst✝ : Algebra.FormallySmooth R P\n⊢ Iff (Algebra.FormallySmooth R A) (Exists fun g => Eq (f.kerSquareLift.comp g) (AlgHom.id R A))","decl":"/-- Let `P →ₐ[R] A` be a surjection with kernel `J`, and `P` a formally smooth `R`-algebra,\nthen `A` is formally smooth over `R` iff the surjection `P ⧸ J ^ 2 →ₐ[R] A` has a section.\n\nGeometric intuition: we require that a first-order thickening of `Spec A` inside `Spec P` admits\na retraction. -/\ntheorem iff_split_surjection [FormallySmooth R P] :\n    FormallySmooth R A ↔ ∃ g, f.kerSquareLift.comp g = AlgHom.id R A := by\n  constructor\n  · intro\n    have surj : Function.Surjective f.kerSquareLift := fun x =>\n      ⟨Submodule.Quotient.mk (hf x).choose, (hf x).choose_spec⟩\n    have sqz : RingHom.ker f.kerSquareLift.toRingHom ^ 2 = 0 := by\n      rw [AlgHom.ker_kerSquareLift, Ideal.cotangentIdeal_square, Ideal.zero_eq_bot]\n    refine\n      ⟨FormallySmooth.lift _ ⟨2, sqz⟩ (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom,\n        ?_⟩\n    ext x\n    have :=\n      (Ideal.quotientKerAlgEquivOfSurjective surj).toAlgHom.congr_arg\n        (FormallySmooth.mk_lift _ ⟨2, sqz⟩\n          (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom x)\n    -- Porting note: was\n    -- dsimp at this\n    -- rw [AlgEquiv.apply_symm_apply] at this\n    erw [AlgEquiv.apply_symm_apply] at this\n    conv_rhs => rw [← this, AlgHom.id_apply]\n    rfl\n    -- Porting note: lean3 was not finished here:\n    -- obtain ⟨y, e⟩ :=\n    --   Ideal.Quotient.mk_surjective\n    --     (FormallySmooth.lift _ ⟨2, sqz⟩\n    --       (Ideal.quotientKerAlgEquivOfSurjective surj).symm.toAlgHom\n    --       x)\n    -- dsimp at e ⊢\n    -- rw [← e]\n    -- rfl\n  · rintro ⟨g, hg⟩; exact FormallySmooth.of_split f g hg\n\n"}
{"name":"Algebra.FormallySmooth.base_change","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nA : Type u\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\nB : Type u\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.FormallySmooth R A\n⊢ Algebra.FormallySmooth B (TensorProduct R B A)","decl":"instance base_change [FormallySmooth R A] : FormallySmooth B (B ⊗[R] A) := by\n  constructor\n  intro C _ _ I hI f\n  letI := ((algebraMap B C).comp (algebraMap R B)).toAlgebra\n  haveI : IsScalarTower R B C := IsScalarTower.of_algebraMap_eq' rfl\n  refine ⟨TensorProduct.productLeftAlgHom (Algebra.ofId B C) ?_, ?_⟩\n  · exact FormallySmooth.lift I ⟨2, hI⟩ ((f.restrictScalars R).comp TensorProduct.includeRight)\n  · apply AlgHom.restrictScalars_injective R\n    apply TensorProduct.ext'\n    intro b a\n    suffices algebraMap B _ b * f (1 ⊗ₜ[R] a) = f (b ⊗ₜ[R] a) by simpa [Algebra.ofId_apply]\n    rw [← Algebra.smul_def, ← map_smul, TensorProduct.smul_tmul', smul_eq_mul, mul_one]\n\n"}
{"name":"Algebra.FormallySmooth.of_isLocalization","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R Rₘ : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing Rₘ\nM : Submonoid R\ninst✝¹ : Algebra R Rₘ\ninst✝ : IsLocalization M Rₘ\n⊢ Algebra.FormallySmooth R Rₘ","decl":"theorem of_isLocalization : FormallySmooth R Rₘ := by\n  constructor\n  intro Q _ _ I e f\n  have : ∀ x : M, IsUnit (algebraMap R Q x) := by\n    intro x\n    apply (IsNilpotent.isUnit_quotient_mk_iff ⟨2, e⟩).mp\n    convert (IsLocalization.map_units Rₘ x).map f\n    simp only [Ideal.Quotient.mk_algebraMap, AlgHom.commutes]\n  let this : Rₘ →ₐ[R] Q :=\n    { IsLocalization.lift this with commutes' := IsLocalization.lift_eq this }\n  use this\n  apply AlgHom.coe_ringHom_injective\n  refine IsLocalization.ringHom_ext M ?_\n  ext\n  simp\n\n"}
{"name":"Algebra.FormallySmooth.localization_base","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R Rₘ Sₘ : Type u\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing Rₘ\ninst✝⁶ : CommRing Sₘ\nM : Submonoid R\ninst✝⁵ : Algebra R Sₘ\ninst✝⁴ : Algebra R Rₘ\ninst✝³ : Algebra Rₘ Sₘ\ninst✝² : IsScalarTower R Rₘ Sₘ\ninst✝¹ : IsLocalization M Rₘ\ninst✝ : Algebra.FormallySmooth R Sₘ\n⊢ Algebra.FormallySmooth Rₘ Sₘ","decl":"theorem localization_base [FormallySmooth R Sₘ] : FormallySmooth Rₘ Sₘ := by\n  constructor\n  intro Q _ _ I e f\n  letI := ((algebraMap Rₘ Q).comp (algebraMap R Rₘ)).toAlgebra\n  letI : IsScalarTower R Rₘ Q := IsScalarTower.of_algebraMap_eq' rfl\n  let f : Sₘ →ₐ[Rₘ] Q := by\n    refine { FormallySmooth.lift I ⟨2, e⟩ (f.restrictScalars R) with commutes' := ?_ }\n    intro r\n    change\n      (RingHom.comp (FormallySmooth.lift I ⟨2, e⟩ (f.restrictScalars R) : Sₘ →+* Q)\n            (algebraMap _ _))\n          r =\n        algebraMap _ _ r\n    congr 1\n    refine IsLocalization.ringHom_ext M ?_\n    rw [RingHom.comp_assoc, ← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq,\n      AlgHom.comp_algebraMap]\n  use f\n  ext\n  simp [f]\n\n"}
{"name":"Algebra.FormallySmooth.localization_map","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R S Rₘ Sₘ : Type u\ninst✝¹³ : CommRing R\ninst✝¹² : CommRing S\ninst✝¹¹ : CommRing Rₘ\ninst✝¹⁰ : CommRing Sₘ\nM : Submonoid R\ninst✝⁹ : Algebra R S\ninst✝⁸ : Algebra R Sₘ\ninst✝⁷ : Algebra S Sₘ\ninst✝⁶ : Algebra R Rₘ\ninst✝⁵ : Algebra Rₘ Sₘ\ninst✝⁴ : IsScalarTower R Rₘ Sₘ\ninst✝³ : IsScalarTower R S Sₘ\ninst✝² : IsLocalization M Rₘ\ninst✝¹ : IsLocalization (Submonoid.map (algebraMap R S) M) Sₘ\ninst✝ : Algebra.FormallySmooth R S\n⊢ Algebra.FormallySmooth Rₘ Sₘ","decl":"theorem localization_map [FormallySmooth R S] : FormallySmooth Rₘ Sₘ := by\n  haveI : FormallySmooth S Sₘ := FormallySmooth.of_isLocalization (M.map (algebraMap R S))\n  haveI : FormallySmooth R Sₘ := FormallySmooth.comp R S Sₘ\n  exact FormallySmooth.localization_base M\n\n"}
{"name":"Algebra.Smooth.formallySmooth","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type u\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nself : Algebra.Smooth R A\n⊢ Algebra.FormallySmooth R A","decl":"/-- An `R` algebra `A` is smooth if it is formally smooth and of finite presentation. -/\n@[stacks 00T2 \"In the stacks project, the definition of smooth is completely different, and tag\n<https://stacks.math.columbia.edu/tag/00TN> proves that their definition is equivalent to this.\"]\nclass Smooth [CommSemiring R] (A : Type u) [Semiring A] [Algebra R A] : Prop where\n  formallySmooth : FormallySmooth R A := by infer_instance\n  finitePresentation : FinitePresentation R A := by infer_instance\n\n"}
{"name":"Algebra.Smooth.finitePresentation","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nA : Type u\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nself : Algebra.Smooth R A\n⊢ Algebra.FinitePresentation R A","decl":"/-- An `R` algebra `A` is smooth if it is formally smooth and of finite presentation. -/\n@[stacks 00T2 \"In the stacks project, the definition of smooth is completely different, and tag\n<https://stacks.math.columbia.edu/tag/00TN> proves that their definition is equivalent to this.\"]\nclass Smooth [CommSemiring R] (A : Type u) [Semiring A] [Algebra R A] : Prop where\n  formallySmooth : FormallySmooth R A := by infer_instance\n  finitePresentation : FinitePresentation R A := by infer_instance\n\n"}
{"name":"Algebra.Smooth.of_equiv","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.Smooth R A\ne : AlgEquiv R A B\n⊢ Algebra.Smooth R B","decl":"/-- Being smooth is transported via algebra isomorphisms. -/\ntheorem of_equiv [Smooth R A] (e : A ≃ₐ[R] B) : Smooth R B where\n  formallySmooth := FormallySmooth.of_equiv e\n  finitePresentation := FinitePresentation.equiv e\n\n"}
{"name":"Algebra.Smooth.of_isLocalization_Away","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝³ : CommRing R\nA : Type u\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nr : R\ninst✝ : IsLocalization.Away r A\n⊢ Algebra.Smooth R A","decl":"/-- Localization at an element is smooth. -/\ntheorem of_isLocalization_Away (r : R) [IsLocalization.Away r A] : Smooth R A where\n  formallySmooth := Algebra.FormallySmooth.of_isLocalization (Submonoid.powers r)\n  finitePresentation := IsLocalization.Away.finitePresentation r\n\n"}
{"name":"Algebra.Smooth.comp","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁸ : CommRing R\nA B : Type u\ninst✝⁷ : CommRing A\ninst✝⁶ : Algebra R A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.Smooth R A\ninst✝ : Algebra.Smooth A B\n⊢ Algebra.Smooth R B","decl":"/-- Smooth is stable under composition. -/\ntheorem comp [Algebra A B] [IsScalarTower R A B] [Smooth R A] [Smooth A B] : Smooth R B where\n  formallySmooth := FormallySmooth.comp R A B\n  finitePresentation := FinitePresentation.trans R A B\n\n"}
{"name":"Algebra.Smooth.baseChange","module":"Mathlib.RingTheory.Smooth.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommRing R\nA B : Type u\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : CommRing B\ninst✝¹ : Algebra R B\ninst✝ : Algebra.Smooth R A\n⊢ Algebra.Smooth B (TensorProduct R B A)","decl":"/-- Smooth is stable under base change. -/\ninstance baseChange [Smooth R A] : Smooth B (B ⊗[R] A) where\n\n"}
