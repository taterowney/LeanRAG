{"name":"CategoryTheory.Limits.KernelFork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ s) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem KernelFork.condition (s : KernelFork f) : Fork.Œπ s ‚â´ f = 0 := by\n  rw [Fork.condition, HasZeroMorphisms.comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ s) f) 0","decl":"@[reassoc (attr := simp)]\ntheorem KernelFork.condition (s : KernelFork f) : Fork.Œπ s ‚â´ f = 0 := by\n  rw [Fork.condition, HasZeroMorphisms.comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\n‚ä¢ Eq (s.œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) 0","decl":"theorem KernelFork.app_one (s : KernelFork f) : s.œÄ.app one = 0 := by\n  simp [Fork.app_one_eq_Œπ_comp_right]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.Œπ_ofŒπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y P : C\nf : Quiver.Hom X Y\nŒπ : Quiver.Hom P X\nw : Eq (CategoryTheory.CategoryStruct.comp Œπ f) 0\n‚ä¢ Eq (CategoryTheory.Limits.Fork.Œπ (CategoryTheory.Limits.KernelFork.ofŒπ Œπ w)) Œπ","decl":"@[simp]\ntheorem KernelFork.Œπ_ofŒπ {X Y P : C} (f : X ‚ü∂ Y) (Œπ : P ‚ü∂ X) (w : Œπ ‚â´ f = 0) :\n    Fork.Œπ (KernelFork.ofŒπ Œπ w) = Œπ := rfl\n\n"}
{"name":"CategoryTheory.Limits.isKernelCompMono_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nZ : C\ng : Quiver.Hom Y Z\nhg : CategoryTheory.Mono g\nh : Quiver.Hom X Z\nhh : Eq h (CategoryTheory.CategoryStruct.comp f g)\ns : CategoryTheory.Limits.KernelFork h\n‚ä¢ Eq ((CategoryTheory.Limits.isKernelCompMono i g hh).lift s) (i.lift (CategoryTheory.Limits.Fork.ofŒπ (CategoryTheory.Limits.Fork.Œπ s) ‚ãØ))","decl":"theorem isKernelCompMono_lift {c : KernelFork f} (i : IsLimit c) {Z} (g : Y ‚ü∂ Z) [hg : Mono g]\n    {h : X ‚ü∂ Z} (hh : h = f ‚â´ g) (s : KernelFork h) :\n    (isKernelCompMono i g hh).lift s = i.lift (Fork.ofŒπ s.Œπ (by\n      rw [‚Üê cancel_mono g, Category.assoc, ‚Üê hh]\n      simp)) := rfl\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.IsLimit.isIso_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nhc : CategoryTheory.Limits.IsLimit c\nhf : Eq f 0\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Œπ c)","decl":"lemma KernelFork.IsLimit.isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)\n    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ := by\n  let e : c.pt ‚âÖ X := IsLimit.conePointUniqueUpToIso hc\n    (KernelFork.IsLimit.ofId (f : X ‚ü∂ Y) hf)\n  have eq : e.inv ‚â´ c.Œπ = ùüô X := Fork.IsLimit.lift_Œπ hc\n  haveI : IsIso (e.inv ‚â´ c.Œπ) := by\n    rw [eq]\n    infer_instance\n  exact IsIso.of_isIso_comp_left e.inv c.Œπ\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapOfIsLimit_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf' : CategoryTheory.Limits.IsLimit kf'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (kf.mapOfIsLimit hf' œÜ) (CategoryTheory.Limits.Fork.Œπ kf')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ kf) œÜ.left)","decl":"@[reassoc (attr := simp)]\nlemma mapOfIsLimit_Œπ (kf : KernelFork f) {kf' : KernelFork f'} (hf' : IsLimit kf')\n    (œÜ : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kf.mapOfIsLimit hf' œÜ ‚â´ kf'.Œπ = kf.Œπ ‚â´ œÜ.left :=\n  hf'.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapOfIsLimit_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf' : CategoryTheory.Limits.IsLimit kf'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f' 0).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (kf.mapOfIsLimit hf' œÜ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ kf') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ kf) (CategoryTheory.CategoryStruct.comp œÜ.left h))","decl":"@[reassoc (attr := simp)]\nlemma mapOfIsLimit_Œπ (kf : KernelFork f) {kf' : KernelFork f'} (hf' : IsLimit kf')\n    (œÜ : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    kf.mapOfIsLimit hf' œÜ ‚â´ kf'.Œπ = kf.Œπ ‚â´ œÜ.left :=\n  hf'.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf : CategoryTheory.Limits.IsLimit kf\nhf' : CategoryTheory.Limits.IsLimit kf'\nœÜ : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit hf hf' œÜ).inv (kf'.mapOfIsLimit hf œÜ.inv)","decl":"/-- The isomorphism between points of limit kernel forks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsLimit {kf : KernelFork f} {kf' : KernelFork f'}\n    (hf : IsLimit kf) (hf' : IsLimit kf')\n    (œÜ : Arrow.mk f ‚âÖ Arrow.mk f') : kf.pt ‚âÖ kf'.pt where\n  hom := kf.mapOfIsLimit hf' œÜ.hom\n  inv := kf'.mapOfIsLimit hf œÜ.inv\n  hom_inv_id := Fork.IsLimit.hom_ext hf (by simp)\n  inv_hom_id := Fork.IsLimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf : CategoryTheory.Limits.IsLimit kf\nhf' : CategoryTheory.Limits.IsLimit kf'\nœÜ : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit hf hf' œÜ).hom (kf.mapOfIsLimit hf' œÜ.hom)","decl":"/-- The isomorphism between points of limit kernel forks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsLimit {kf : KernelFork f} {kf' : KernelFork f'}\n    (hf : IsLimit kf) (hf' : IsLimit kf')\n    (œÜ : Arrow.mk f ‚âÖ Arrow.mk f') : kf.pt ‚âÖ kf'.pt where\n  hom := kf.mapOfIsLimit hf' œÜ.hom\n  inv := kf'.mapOfIsLimit hf œÜ.inv\n  hom_inv_id := Fork.IsLimit.hom_ext hf (by simp)\n  inv_hom_id := Fork.IsLimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.equalizer_as_kernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.Limits.equalizer.Œπ f 0) (CategoryTheory.Limits.kernel.Œπ f)","decl":"@[simp]\ntheorem equalizer_as_kernel : equalizer.Œπ f 0 = kernel.Œπ f := rfl\n\n"}
{"name":"CategoryTheory.Limits.kernel.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem kernel.condition : kernel.Œπ f ‚â´ f = 0 :=\n  KernelFork.condition _\n\n"}
{"name":"CategoryTheory.Limits.kernel.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) f) 0","decl":"@[reassoc (attr := simp)]\ntheorem kernel.condition : kernel.Œπ f ‚â´ f = 0 :=\n  KernelFork.condition _\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp k f) 0\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f k h‚úù) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\ntheorem kernel.lift_Œπ {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = 0) : kernel.lift f k h ‚â´ kernel.Œπ f = k :=\n  (kernelIsKernel f).fac (KernelFork.ofŒπ k h) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f k h) (CategoryTheory.Limits.kernel.Œπ f)) k","decl":"@[reassoc (attr := simp)]\ntheorem kernel.lift_Œπ {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = 0) : kernel.lift f k h ‚â´ kernel.Œπ f = k :=\n  (kernelIsKernel f).fac (KernelFork.ofŒπ k h) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nW : C\nh : Eq (CategoryTheory.CategoryStruct.comp 0 f) 0\n‚ä¢ Eq (CategoryTheory.Limits.kernel.lift f 0 h) 0","decl":"@[simp]\ntheorem kernel.lift_zero {W : C} {h} : kernel.lift f (0 : W ‚ü∂ X) h = 0 := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) 0\ninst‚úù : CategoryTheory.Mono k\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.kernel.lift f k h)","decl":"instance kernel.lift_mono {W : C} (k : W ‚ü∂ X) (h : k ‚â´ f = 0) [Mono k] : Mono (kernel.lift f k h) :=\n  ‚ü®fun {Z} g g' w => by\n    replace w := w =‚â´ kernel.Œπ f\n    simp only [Category.assoc, kernel.lift_Œπ] at w\n    exact (cancel_mono k).1 w‚ü©\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasKernel g\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom Y' Z'\ninst‚úù : CategoryTheory.Limits.HasKernel g'\nw' : Eq (CategoryTheory.CategoryStruct.comp f' g') 0\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nr : Quiver.Hom Z Z'\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.comp q g')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g f w) (CategoryTheory.Limits.kernel.map g g' q r h‚ÇÇ)) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.Limits.kernel.lift g' f' w'))","decl":"/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   X ---> kernel g\n   |         |\n   |         | kernel.map\n   |         |\n   v         v\n   X' --> kernel g'\n-/\ntheorem kernel.lift_map {X Y Z X' Y' Z' : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasKernel g] (w : f ‚â´ g = 0)\n    (f' : X' ‚ü∂ Y') (g' : Y' ‚ü∂ Z') [HasKernel g'] (w' : f' ‚â´ g' = 0) (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')\n    (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g') :\n    kernel.lift g f w ‚â´ kernel.map g g' q r h‚ÇÇ = p ‚â´ kernel.lift g' f' w' := by\n  ext; simp [h‚ÇÅ]\n\n"}
{"name":"CategoryTheory.Limits.kernel.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\n‚ä¢ Eq (CategoryTheory.Limits.kernel.mapIso f f' p q w).hom (CategoryTheory.Limits.kernel.map f f' p.hom q.hom w)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of kernels. -/\n@[simps]\ndef kernel.mapIso {X' Y' : C} (f' : X' ‚ü∂ Y') [HasKernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y')\n    (w : f ‚â´ q.hom = p.hom ‚â´ f') : kernel f ‚âÖ kernel f' where\n  hom := kernel.map f f' p.hom q.hom w\n  inv :=\n    kernel.map f' f p.inv q.inv\n      (by\n        refine (cancel_mono q.hom).1 ?_\n        simp [w])\n\n"}
{"name":"CategoryTheory.Limits.kernel.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasKernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\n‚ä¢ Eq (CategoryTheory.Limits.kernel.mapIso f f' p q w).inv (CategoryTheory.Limits.kernel.map f' f p.inv q.inv ‚ãØ)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of kernels. -/\n@[simps]\ndef kernel.mapIso {X' Y' : C} (f' : X' ‚ü∂ Y') [HasKernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y')\n    (w : f ‚â´ q.hom = p.hom ‚â´ f') : kernel f ‚âÖ kernel f' where\n  hom := kernel.map f f' p.hom q.hom w\n  inv :=\n    kernel.map f' f p.inv q.inv\n      (by\n        refine (cancel_mono q.hom).1 ?_\n        simp [w])\n\n"}
{"name":"CategoryTheory.Limits.kernel.Œπ_zero_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ 0)","decl":"/-- Every kernel of the zero morphism is an isomorphism -/\ninstance kernel.Œπ_zero_isIso : IsIso (kernel.Œπ (0 : X ‚ü∂ Y)) :=\n  equalizer.Œπ_of_self _\n\n"}
{"name":"CategoryTheory.Limits.eq_zero_of_epi_kernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.kernel.Œπ f)\n‚ä¢ Eq f 0","decl":"theorem eq_zero_of_epi_kernel [Epi (kernel.Œπ f)] : f = 0 :=\n  (cancel_epi (kernel.Œπ f)).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelZeroIsoSource_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ Eq CategoryTheory.Limits.kernelZeroIsoSource.hom (CategoryTheory.Limits.kernel.Œπ 0)","decl":"@[simp]\ntheorem kernelZeroIsoSource_hom : kernelZeroIsoSource.hom = kernel.Œπ (0 : X ‚ü∂ Y) := rfl\n\n"}
{"name":"CategoryTheory.Limits.kernelZeroIsoSource_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ Eq CategoryTheory.Limits.kernelZeroIsoSource.inv (CategoryTheory.Limits.kernel.lift 0 (CategoryTheory.CategoryStruct.id X) ‚ãØ)","decl":"@[simp]\ntheorem kernelZeroIsoSource_inv :\n    kernelZeroIsoSource.inv = kernel.lift (0 : X ‚ü∂ Y) (ùüô X) (by simp) := by\n  ext\n  simp [kernelZeroIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_refl","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nh : Eq f f\n‚ä¢ Eq (CategoryTheory.Limits.kernelIsoOfEq h) (CategoryTheory.Iso.refl (CategoryTheory.Limits.kernel f))","decl":"@[simp]\ntheorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) := by\n  ext\n  simp [kernelIsoOfEq]\n\n/- Porting note: induction on Eq is trying instantiate another g... -/\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_hom_comp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh : Eq f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h).hom (CategoryTheory.Limits.kernel.Œπ g)) (CategoryTheory.Limits.kernel.Œπ f)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_hom_comp_Œπ {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).hom ‚â´ kernel.Œπ g = kernel.Œπ f := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_hom_comp_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh‚úù : Eq f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_hom_comp_Œπ {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).hom ‚â´ kernel.Œπ g = kernel.Œπ f := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_inv_comp_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh‚úù : Eq f g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ g) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_inv_comp_Œπ {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).inv ‚â´ kernel.Œπ _ = kernel.Œπ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_inv_comp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh : Eq f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h).inv (CategoryTheory.Limits.kernel.Œπ f)) (CategoryTheory.Limits.kernel.Œπ g)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_inv_comp_Œπ {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).inv ‚â´ kernel.Œπ _ = kernel.Œπ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh : Eq f g\ne : Quiver.Hom Z X\nhe : Eq (CategoryTheory.CategoryStruct.comp e f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e he) (CategoryTheory.Limits.kernelIsoOfEq h).hom) (CategoryTheory.Limits.kernel.lift g e ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_hom {Z} {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z ‚ü∂ X) (he) :\n    kernel.lift _ e he ‚â´ (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [‚Üê h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z‚úù : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh‚úù : Eq f g\ne : Quiver.Hom Z‚úù X\nhe : Eq (CategoryTheory.CategoryStruct.comp e f) 0\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e he) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h‚úù).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_hom {Z} {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z ‚ü∂ X) (he) :\n    kernel.lift _ e he ‚â´ (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [‚Üê h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z‚úù : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh‚úù : Eq f g\ne : Quiver.Hom Z‚úù X\nhe : Eq (CategoryTheory.CategoryStruct.comp e g) 0\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e he) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h‚úù).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_inv {Z} {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z ‚ü∂ X) (he) :\n    kernel.lift _ e he ‚â´ (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel g\nh : Eq f g\ne : Quiver.Hom Z X\nhe : Eq (CategoryTheory.CategoryStruct.comp e g) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e he) (CategoryTheory.Limits.kernelIsoOfEq h).inv) (CategoryTheory.Limits.kernel.lift f e ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_inv {Z} {f g : X ‚ü∂ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z ‚ü∂ X) (he) :\n    kernel.lift _ e he ‚â´ (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_trans","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g h : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasKernel f\ninst‚úù¬π : CategoryTheory.Limits.HasKernel g\ninst‚úù : CategoryTheory.Limits.HasKernel h\nw‚ÇÅ : Eq f g\nw‚ÇÇ : Eq g h\n‚ä¢ Eq ((CategoryTheory.Limits.kernelIsoOfEq w‚ÇÅ).trans (CategoryTheory.Limits.kernelIsoOfEq w‚ÇÇ)) (CategoryTheory.Limits.kernelIsoOfEq ‚ãØ)","decl":"@[simp]\ntheorem kernelIsoOfEq_trans {f g h : X ‚ü∂ Y} [HasKernel f] [HasKernel g] [HasKernel h] (w‚ÇÅ : f = g)\n    (w‚ÇÇ : g = h) : kernelIsoOfEq w‚ÇÅ ‚â™‚â´ kernelIsoOfEq w‚ÇÇ = kernelIsoOfEq (w‚ÇÅ.trans w‚ÇÇ) := by\n  cases w‚ÇÅ; cases w‚ÇÇ; ext; simp [kernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.kernel_not_epi_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nw : Ne f 0\n‚ä¢ Not (CategoryTheory.Epi (CategoryTheory.Limits.kernel.Œπ f))","decl":"theorem kernel_not_epi_of_nonzero (w : f ‚â† 0) : ¬¨Epi (kernel.Œπ f) := fun _ =>\n  w (eq_zero_of_epi_kernel f)\n\n"}
{"name":"CategoryTheory.Limits.kernel_not_iso_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nw : Ne f 0\na‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ f)\n‚ä¢ False","decl":"theorem kernel_not_iso_of_nonzero (w : f ‚â† 0) : IsIso (kernel.Œπ f) ‚Üí False := fun _ =>\n  kernel_not_epi_of_nonzero w inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasKernel_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasKernel_comp_mono {X Y Z : C} (f : X ‚ü∂ Y) [HasKernel f] (g : Y ‚ü∂ Z) [Mono g] :\n    HasKernel (f ‚â´ g) :=\n  ‚ü®‚ü®{   cone := _\n        isLimit := isKernelCompMono (limit.isLimit _) g rfl }‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.kernelCompMono_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ Eq (CategoryTheory.Limits.kernelCompMono f g).inv (CategoryTheory.Limits.kernel.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Limits.kernel.Œπ f) ‚ãØ)","decl":"/-- When `g` is a monomorphism, the kernel of `f ‚â´ g` is isomorphic to the kernel of `f`.\n-/\n@[simps]\ndef kernelCompMono {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasKernel f] [Mono g] :\n    kernel (f ‚â´ g) ‚âÖ kernel f where\n  hom :=\n    kernel.lift _ (kernel.Œπ _)\n      (by\n        rw [‚Üê cancel_mono g]\n        simp)\n  inv := kernel.lift _ (kernel.Œπ _) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelCompMono_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ Eq (CategoryTheory.Limits.kernelCompMono f g).hom (CategoryTheory.Limits.kernel.lift f (CategoryTheory.Limits.kernel.Œπ (CategoryTheory.CategoryStruct.comp f g)) ‚ãØ)","decl":"/-- When `g` is a monomorphism, the kernel of `f ‚â´ g` is isomorphic to the kernel of `f`.\n-/\n@[simps]\ndef kernelCompMono {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasKernel f] [Mono g] :\n    kernel (f ‚â´ g) ‚âÖ kernel f where\n  hom :=\n    kernel.lift _ (kernel.Œπ _)\n      (by\n        rw [‚Üê cancel_mono g]\n        simp)\n  inv := kernel.lift _ (kernel.Œπ _) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.hasKernel_iso_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasKernel_iso_comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [HasKernel g] :\n    HasKernel (f ‚â´ g) where\n  exists_limit :=\n    ‚ü®{  cone := KernelFork.ofŒπ (kernel.Œπ g ‚â´ inv f) (by simp)\n        isLimit := isLimitAux _ (fun s => kernel.lift _ (s.Œπ ‚â´ f) (by simp))\n            (by simp) fun s m w => by\n          simp_rw [‚Üê w]\n          symm\n          apply equalizer.hom_ext\n          simp }‚ü©\n\n"}
{"name":"CategoryTheory.Limits.kernelIsIsoComp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ Eq (CategoryTheory.Limits.kernelIsIsoComp f g).inv (CategoryTheory.Limits.kernel.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ g) (CategoryTheory.inv f)) ‚ãØ)","decl":"/-- When `f` is an isomorphism, the kernel of `f ‚â´ g` is isomorphic to the kernel of `g`.\n-/\n@[simps]\ndef kernelIsIsoComp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [HasKernel g] :\n    kernel (f ‚â´ g) ‚âÖ kernel g where\n  hom := kernel.lift _ (kernel.Œπ _ ‚â´ f) (by simp)\n  inv := kernel.lift _ (kernel.Œπ _ ‚â´ inv f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelIsIsoComp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : CategoryTheory.Limits.HasKernel g\n‚ä¢ Eq (CategoryTheory.Limits.kernelIsIsoComp f g).hom (CategoryTheory.Limits.kernel.lift g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ (CategoryTheory.CategoryStruct.comp f g)) f) ‚ãØ)","decl":"/-- When `f` is an isomorphism, the kernel of `f ‚â´ g` is isomorphic to the kernel of `g`.\n-/\n@[simps]\ndef kernelIsIsoComp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [HasKernel g] :\n    kernel (f ‚â´ g) ‚âÖ kernel g where\n  hom := kernel.lift _ (kernel.Œπ _ ‚â´ f) (by simp)\n  inv := kernel.lift _ (kernel.Œπ _ ‚â´ inv f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernel.Œπ_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Limits.kernel.Œπ f) 0","decl":"/-- The kernel morphism of a monomorphism is a zero morphism -/\ntheorem kernel.Œπ_of_mono [HasKernel f] [Mono f] : kernel.Œπ f = 0 :=\n  zero_of_source_iso_zero _ (kernel.ofMono f)\n\n"}
{"name":"CategoryTheory.Limits.kernel.Œπ_of_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ 0)","decl":"/-- The kernel morphism of a zero morphism is an isomorphism -/\ntheorem kernel.Œπ_of_zero : IsIso (kernel.Œπ (0 : X ‚ü∂ Y)) :=\n  equalizer.Œπ_of_self _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Cofork.œÄ s)) 0","decl":"@[reassoc (attr := simp)]\ntheorem CokernelCofork.condition (s : CokernelCofork f) : f ‚â´ s.œÄ = 0 := by\n  rw [Cofork.condition, zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj s.pt).obj CategoryTheory.Limits.WalkingParallelPair.one) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ s) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem CokernelCofork.condition (s : CokernelCofork f) : f ‚â´ s.œÄ = 0 := by\n  rw [Cofork.condition, zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.œÄ_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\n‚ä¢ Eq (s.Œπ.app CategoryTheory.Limits.WalkingParallelPair.zero) 0","decl":"theorem CokernelCofork.œÄ_eq_zero (s : CokernelCofork f) : s.Œπ.app zero = 0 := by\n  simp [Cofork.app_zero_eq_comp_œÄ_right]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.œÄ_ofœÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y P : C\nf : Quiver.Hom X Y\nœÄ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f œÄ) 0\n‚ä¢ Eq (CategoryTheory.Limits.Cofork.œÄ (CategoryTheory.Limits.CokernelCofork.ofœÄ œÄ w)) œÄ","decl":"@[simp]\ntheorem CokernelCofork.œÄ_ofœÄ {X Y P : C} (f : X ‚ü∂ Y) (œÄ : Y ‚ü∂ P) (w : f ‚â´ œÄ = 0) :\n    Cofork.œÄ (CokernelCofork.ofœÄ œÄ w) = œÄ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.isCokernelEpiComp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nW : C\ng : Quiver.Hom W X\nhg : CategoryTheory.Epi g\nh : Quiver.Hom W Y\nhh : Eq h (CategoryTheory.CategoryStruct.comp g f)\ns : CategoryTheory.Limits.CokernelCofork h\n‚ä¢ Eq ((CategoryTheory.Limits.isCokernelEpiComp i g hh).desc s) (i.desc (CategoryTheory.Limits.Cofork.ofœÄ (CategoryTheory.Limits.Cofork.œÄ s) ‚ãØ))","decl":"@[simp]\ntheorem isCokernelEpiComp_desc {c : CokernelCofork f} (i : IsColimit c) {W} (g : W ‚ü∂ X) [hg : Epi g]\n    {h : W ‚ü∂ Y} (hh : h = g ‚â´ f) (s : CokernelCofork h) :\n    (isCokernelEpiComp i g hh).desc s =\n      i.desc\n        (Cofork.ofœÄ s.œÄ\n          (by\n            rw [‚Üê cancel_epi g, ‚Üê Category.assoc, ‚Üê hh]\n            simp)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.IsColimit.isIso_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nhc : CategoryTheory.Limits.IsColimit c\nhf : Eq f 0\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.œÄ c)","decl":"lemma CokernelCofork.IsColimit.isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)\n    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ := by\n  let e : c.pt ‚âÖ Y := IsColimit.coconePointUniqueUpToIso hc\n    (CokernelCofork.IsColimit.ofId (f : X ‚ü∂ Y) hf)\n  have eq : c.œÄ ‚â´ e.hom = ùüô Y := Cofork.IsColimit.œÄ_desc hc\n  haveI : IsIso (c.œÄ ‚â´ e.hom) := by\n    rw [eq]\n    dsimp\n    infer_instance\n  exact IsIso.of_isIso_comp_right c.œÄ e.hom\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.œÄ_mapOfIsColimit_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\nhf : CategoryTheory.Limits.IsColimit cc\ncc' : CategoryTheory.Limits.CokernelCofork f'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom cc'.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ cc) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' œÜ) h)) (CategoryTheory.CategoryStruct.comp œÜ.right (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ cc') h))","decl":"@[reassoc (attr := simp)]\nlemma œÄ_mapOfIsColimit {cc : CokernelCofork f} (hf : IsColimit cc) (cc' : CokernelCofork f')\n    (œÜ : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    cc.œÄ ‚â´ mapOfIsColimit hf cc' œÜ = œÜ.right ‚â´ cc'.œÄ :=\n  hf.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.œÄ_mapOfIsColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\nhf : CategoryTheory.Limits.IsColimit cc\ncc' : CategoryTheory.Limits.CokernelCofork f'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.œÄ cc) (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' œÜ)) (CategoryTheory.CategoryStruct.comp œÜ.right (CategoryTheory.Limits.Cofork.œÄ cc'))","decl":"@[reassoc (attr := simp)]\nlemma œÄ_mapOfIsColimit {cc : CokernelCofork f} (hf : IsColimit cc) (cc' : CokernelCofork f')\n    (œÜ : Arrow.mk f ‚ü∂ Arrow.mk f') :\n    cc.œÄ ‚â´ mapOfIsColimit hf cc' œÜ = œÜ.right ‚â´ cc'.œÄ :=\n  hf.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\ncc' : CategoryTheory.Limits.CokernelCofork f'\nhf : CategoryTheory.Limits.IsColimit cc\nhf' : CategoryTheory.Limits.IsColimit cc'\nœÜ : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit hf hf' œÜ).inv (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf' cc œÜ.inv)","decl":"/-- The isomorphism between points of limit cokernel coforks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsColimit {cc : CokernelCofork f} {cc' : CokernelCofork f'}\n    (hf : IsColimit cc) (hf' : IsColimit cc')\n    (œÜ : Arrow.mk f ‚âÖ Arrow.mk f') : cc.pt ‚âÖ cc'.pt where\n  hom := mapOfIsColimit hf cc' œÜ.hom\n  inv := mapOfIsColimit hf' cc œÜ.inv\n  hom_inv_id := Cofork.IsColimit.hom_ext hf (by simp)\n  inv_hom_id := Cofork.IsColimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\ncc' : CategoryTheory.Limits.CokernelCofork f'\nhf : CategoryTheory.Limits.IsColimit cc\nhf' : CategoryTheory.Limits.IsColimit cc'\nœÜ : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\n‚ä¢ Eq (CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit hf hf' œÜ).hom (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' œÜ.hom)","decl":"/-- The isomorphism between points of limit cokernel coforks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsColimit {cc : CokernelCofork f} {cc' : CokernelCofork f'}\n    (hf : IsColimit cc) (hf' : IsColimit cc')\n    (œÜ : Arrow.mk f ‚âÖ Arrow.mk f') : cc.pt ‚âÖ cc'.pt where\n  hom := mapOfIsColimit hf cc' œÜ.hom\n  inv := mapOfIsColimit hf' cc œÜ.inv\n  hom_inv_id := Cofork.IsColimit.hom_ext hf (by simp)\n  inv_hom_id := Cofork.IsColimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coequalizer_as_cokernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\n‚ä¢ Eq (CategoryTheory.Limits.coequalizer.œÄ f 0) (CategoryTheory.Limits.cokernel.œÄ f)","decl":"@[simp]\ntheorem coequalizer_as_cokernel : coequalizer.œÄ f 0 = cokernel.œÄ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cokernel.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.cokernel.œÄ f)) 0","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.condition : f ‚â´ cokernel.œÄ f = 0 :=\n  CokernelCofork.condition _\n\n"}
{"name":"CategoryTheory.Limits.cokernel.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.condition : f ‚â´ cokernel.œÄ f = 0 :=\n  CokernelCofork.condition _\n\n"}
{"name":"CategoryTheory.Limits.cokernel.œÄ_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp f k) 0\nZ : C\nh : Quiver.Hom W Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f k h‚úù) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.œÄ_desc {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = 0) :\n    cokernel.œÄ f ‚â´ cokernel.desc f k h = k :=\n  (cokernelIsCokernel f).fac (CokernelCofork.ofœÄ k h) WalkingParallelPair.one\n\n-- Porting note: added to ease the port of `Abelian.Exact`\n"}
{"name":"CategoryTheory.Limits.cokernel.œÄ_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) (CategoryTheory.Limits.cokernel.desc f k h)) k","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.œÄ_desc {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = 0) :\n    cokernel.œÄ f ‚â´ cokernel.desc f k h = k :=\n  (cokernelIsCokernel f).fac (CokernelCofork.ofœÄ k h) WalkingParallelPair.one\n\n-- Porting note: added to ease the port of `Abelian.Exact`\n"}
{"name":"CategoryTheory.Limits.colimit_Œπ_zero_cokernel_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ninst‚úù : CategoryTheory.Limits.HasCokernel f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.parallelPair f 0) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Limits.cokernel.desc f g h)) 0","decl":"@[reassoc (attr := simp)]\nlemma colimit_Œπ_zero_cokernel_desc {C : Type*} [Category C]\n    [HasZeroMorphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : f ‚â´ g = 0) [HasCokernel f] :\n    colimit.Œπ (parallelPair f 0) WalkingParallelPair.zero ‚â´ cokernel.desc f g h = 0 := by\n  rw [(colimit.w (parallelPair f 0) WalkingParallelPairHom.left).symm]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit_Œπ_zero_cokernel_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z‚úù : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nh‚úù : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.parallelPair f 0) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f g h‚úù) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma colimit_Œπ_zero_cokernel_desc {C : Type*} [Category C]\n    [HasZeroMorphisms C] {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (h : f ‚â´ g = 0) [HasCokernel f] :\n    colimit.Œπ (parallelPair f 0) WalkingParallelPair.zero ‚â´ cokernel.desc f g h = 0 := by\n  rw [(colimit.w (parallelPair f 0) WalkingParallelPairHom.left).symm]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.cokernel.desc_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nW : C\nh : Eq (CategoryTheory.CategoryStruct.comp f 0) 0\n‚ä¢ Eq (CategoryTheory.Limits.cokernel.desc f 0 h) 0","decl":"@[simp]\ntheorem cokernel.desc_zero {W : C} {h} : cokernel.desc f (0 : Y ‚ü∂ W) h = 0 := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernel.desc_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) 0\ninst‚úù : CategoryTheory.Epi k\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.cokernel.desc f k h)","decl":"instance cokernel.desc_epi {W : C} (k : Y ‚ü∂ W) (h : f ‚â´ k = 0) [Epi k] :\n    Epi (cokernel.desc f k h) :=\n  ‚ü®fun {Z} g g' w => by\n    replace w := cokernel.œÄ f ‚â´= w\n    simp only [cokernel.œÄ_desc_assoc] at w\n    exact (cancel_epi k).1 w‚ü©\n\n"}
{"name":"CategoryTheory.Limits.cokernel.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasCokernel f'\ng' : Quiver.Hom Y' Z'\nw' : Eq (CategoryTheory.CategoryStruct.comp f' g') 0\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nr : Quiver.Hom Z Z'\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.comp q g')\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map f f' p q h‚ÇÅ) (CategoryTheory.Limits.cokernel.desc f' g' w')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f g w) r)","decl":"/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   cokernel f ---> Z\n   |               |\n   | cokernel.map  |\n   |               |\n   v               v\n   cokernel f' --> Z'\n-/\ntheorem cokernel.map_desc {X Y Z X' Y' Z' : C} (f : X ‚ü∂ Y) [HasCokernel f] (g : Y ‚ü∂ Z)\n    (w : f ‚â´ g = 0) (f' : X' ‚ü∂ Y') [HasCokernel f'] (g' : Y' ‚ü∂ Z') (w' : f' ‚â´ g' = 0) (p : X ‚ü∂ X')\n    (q : Y ‚ü∂ Y') (r : Z ‚ü∂ Z') (h‚ÇÅ : f ‚â´ q = p ‚â´ f') (h‚ÇÇ : g ‚â´ r = q ‚â´ g') :\n    cokernel.map f f' p q h‚ÇÅ ‚â´ cokernel.desc f' g' w' = cokernel.desc f g w ‚â´ r := by\n  ext; simp [h‚ÇÇ]\n\n"}
{"name":"CategoryTheory.Limits.cokernel.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasCokernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\n‚ä¢ Eq (CategoryTheory.Limits.cokernel.mapIso f f' p q w).hom (CategoryTheory.Limits.cokernel.map f f' p.hom q.hom w)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of cokernels. -/\n@[simps]\ndef cokernel.mapIso {X' Y' : C} (f' : X' ‚ü∂ Y') [HasCokernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y')\n    (w : f ‚â´ q.hom = p.hom ‚â´ f') : cokernel f ‚âÖ cokernel f' where\n  hom := cokernel.map f f' p.hom q.hom w\n  inv := cokernel.map f' f p.inv q.inv (by\n          refine (cancel_mono q.hom).1 ?_\n          simp [w])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninst‚úù : CategoryTheory.Limits.HasCokernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\n‚ä¢ Eq (CategoryTheory.Limits.cokernel.mapIso f f' p q w).inv (CategoryTheory.Limits.cokernel.map f' f p.inv q.inv ‚ãØ)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of cokernels. -/\n@[simps]\ndef cokernel.mapIso {X' Y' : C} (f' : X' ‚ü∂ Y') [HasCokernel f'] (p : X ‚âÖ X') (q : Y ‚âÖ Y')\n    (w : f ‚â´ q.hom = p.hom ‚â´ f') : cokernel f ‚âÖ cokernel f' where\n  hom := cokernel.map f f' p.hom q.hom w\n  inv := cokernel.map f' f p.inv q.inv (by\n          refine (cancel_mono q.hom).1 ?_\n          simp [w])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.œÄ_zero_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ 0)","decl":"/-- The cokernel of the zero morphism is an isomorphism -/\ninstance cokernel.œÄ_zero_isIso : IsIso (cokernel.œÄ (0 : X ‚ü∂ Y)) :=\n  coequalizer.œÄ_of_self _\n\n"}
{"name":"CategoryTheory.Limits.eq_zero_of_mono_cokernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Mono (CategoryTheory.Limits.cokernel.œÄ f)\n‚ä¢ Eq f 0","decl":"theorem eq_zero_of_mono_cokernel [Mono (cokernel.œÄ f)] : f = 0 :=\n  (cancel_mono (cokernel.œÄ f)).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernelZeroIsoTarget_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ Eq CategoryTheory.Limits.cokernelZeroIsoTarget.hom (CategoryTheory.Limits.cokernel.desc 0 (CategoryTheory.CategoryStruct.id Y) ‚ãØ)","decl":"@[simp]\ntheorem cokernelZeroIsoTarget_hom :\n    cokernelZeroIsoTarget.hom = cokernel.desc (0 : X ‚ü∂ Y) (ùüô Y) (by simp) := by\n  ext; simp [cokernelZeroIsoTarget]\n\n"}
{"name":"CategoryTheory.Limits.cokernelZeroIsoTarget_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ Eq CategoryTheory.Limits.cokernelZeroIsoTarget.inv (CategoryTheory.Limits.cokernel.œÄ 0)","decl":"@[simp]\ntheorem cokernelZeroIsoTarget_inv : cokernelZeroIsoTarget.inv = cokernel.œÄ (0 : X ‚ü∂ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_refl","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nh : Eq f f\n‚ä¢ Eq (CategoryTheory.Limits.cokernelIsoOfEq h) (CategoryTheory.Iso.refl (CategoryTheory.Limits.cokernel f))","decl":"@[simp]\ntheorem cokernelIsoOfEq_refl {h : f = f} : cokernelIsoOfEq h = Iso.refl (cokernel f) := by\n  ext; simp [cokernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelIsoOfEq_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) (CategoryTheory.Limits.cokernelIsoOfEq h).hom) (CategoryTheory.Limits.cokernel.œÄ g)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelIsoOfEq_hom {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.œÄ f ‚â´ (cokernelIsoOfEq h).hom = cokernel.œÄ g := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelIsoOfEq_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh‚úù : Eq f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h‚úù).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ g) h)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelIsoOfEq_hom {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.œÄ f ‚â´ (cokernelIsoOfEq h).hom = cokernel.œÄ g := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelIsoOfEq_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ g) (CategoryTheory.Limits.cokernelIsoOfEq h).inv) (CategoryTheory.Limits.cokernel.œÄ f)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelIsoOfEq_inv {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.œÄ _ ‚â´ (cokernelIsoOfEq h).inv = cokernel.œÄ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelIsoOfEq_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh‚úù : Eq f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h‚úù).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelIsoOfEq_inv {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.œÄ _ ‚â´ (cokernelIsoOfEq h).inv = cokernel.œÄ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_hom_comp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\ne : Quiver.Hom Y Z\nhe : Eq (CategoryTheory.CategoryStruct.comp g e) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h).hom (CategoryTheory.Limits.cokernel.desc g e he)) (CategoryTheory.Limits.cokernel.desc f e ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_hom_comp_desc {Z} {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y ‚ü∂ Z) (he) :\n    (cokernelIsoOfEq h).hom ‚â´ cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_hom_comp_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z‚úù : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh‚úù : Eq f g\ne : Quiver.Hom Y Z‚úù\nhe : Eq (CategoryTheory.CategoryStruct.comp g e) 0\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h‚úù).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc g e he) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f e ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_hom_comp_desc {Z} {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y ‚ü∂ Z) (he) :\n    (cokernelIsoOfEq h).hom ‚â´ cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_inv_comp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\ne : Quiver.Hom Y Z\nhe : Eq (CategoryTheory.CategoryStruct.comp f e) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h).inv (CategoryTheory.Limits.cokernel.desc f e he)) (CategoryTheory.Limits.cokernel.desc g e ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_inv_comp_desc {Z} {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y ‚ü∂ Z) (he) :\n    (cokernelIsoOfEq h).inv ‚â´ cokernel.desc _ e he = cokernel.desc _ e (by simp [‚Üê h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_inv_comp_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z‚úù : C\nf g : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\nh‚úù : Eq f g\ne : Quiver.Hom Y Z‚úù\nhe : Eq (CategoryTheory.CategoryStruct.comp f e) 0\nZ : C\nh : Quiver.Hom Z‚úù Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h‚úù).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f e he) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc g e ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_inv_comp_desc {Z} {f g : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y ‚ü∂ Z) (he) :\n    (cokernelIsoOfEq h).inv ‚â´ cokernel.desc _ e he = cokernel.desc _ e (by simp [‚Üê h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_trans","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g h : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel f\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel g\ninst‚úù : CategoryTheory.Limits.HasCokernel h\nw‚ÇÅ : Eq f g\nw‚ÇÇ : Eq g h\n‚ä¢ Eq ((CategoryTheory.Limits.cokernelIsoOfEq w‚ÇÅ).trans (CategoryTheory.Limits.cokernelIsoOfEq w‚ÇÇ)) (CategoryTheory.Limits.cokernelIsoOfEq ‚ãØ)","decl":"@[simp]\ntheorem cokernelIsoOfEq_trans {f g h : X ‚ü∂ Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n    (w‚ÇÅ : f = g) (w‚ÇÇ : g = h) :\n    cokernelIsoOfEq w‚ÇÅ ‚â™‚â´ cokernelIsoOfEq w‚ÇÇ = cokernelIsoOfEq (w‚ÇÅ.trans w‚ÇÇ) := by\n  cases w‚ÇÅ; cases w‚ÇÇ; ext; simp [cokernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.cokernel_not_mono_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nw : Ne f 0\n‚ä¢ Not (CategoryTheory.Mono (CategoryTheory.Limits.cokernel.œÄ f))","decl":"theorem cokernel_not_mono_of_nonzero (w : f ‚â† 0) : ¬¨Mono (cokernel.œÄ f) := fun _ =>\n  w (eq_zero_of_mono_cokernel f)\n\n"}
{"name":"CategoryTheory.Limits.cokernel_not_iso_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasCokernel f\nw : Ne f 0\na‚úù : CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ f)\n‚ä¢ False","decl":"theorem cokernel_not_iso_of_nonzero (w : f ‚â† 0) : IsIso (cokernel.œÄ f) ‚Üí False := fun _ =>\n  cokernel_not_mono_of_nonzero w inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCokernel_comp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasCokernel_comp_iso {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasCokernel f] [IsIso g] :\n    HasCokernel (f ‚â´ g) where\n  exists_colimit :=\n    ‚ü®{  cocone := CokernelCofork.ofœÄ (inv g ‚â´ cokernel.œÄ f) (by simp)\n        isColimit :=\n          isColimitAux _\n            (fun s =>\n              cokernel.desc _ (g ‚â´ s.œÄ) (by rw [‚Üê Category.assoc, CokernelCofork.condition]))\n            (by simp) fun s m w => by\n            simp_rw [‚Üê w]\n            symm\n            apply coequalizer.hom_ext\n            simp }‚ü©\n\n"}
{"name":"CategoryTheory.Limits.cokernelCompIsIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Eq (CategoryTheory.Limits.cokernelCompIsIso f g).inv (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ)","decl":"/-- When `g` is an isomorphism, the cokernel of `f ‚â´ g` is isomorphic to the cokernel of `f`.\n-/\n@[simps]\ndef cokernelCompIsIso {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasCokernel f] [IsIso g] :\n    cokernel (f ‚â´ g) ‚âÖ cokernel f where\n  hom := cokernel.desc _ (inv g ‚â´ cokernel.œÄ f) (by simp)\n  inv := cokernel.desc _ (g ‚â´ cokernel.œÄ (f ‚â´ g)) (by rw [‚Üê Category.assoc, cokernel.condition])\n\n"}
{"name":"CategoryTheory.Limits.cokernelCompIsIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Eq (CategoryTheory.Limits.cokernelCompIsIso f g).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) (CategoryTheory.Limits.cokernel.œÄ f)) ‚ãØ)","decl":"/-- When `g` is an isomorphism, the cokernel of `f ‚â´ g` is isomorphic to the cokernel of `f`.\n-/\n@[simps]\ndef cokernelCompIsIso {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HasCokernel f] [IsIso g] :\n    cokernel (f ‚â´ g) ‚âÖ cokernel f where\n  hom := cokernel.desc _ (inv g ‚â´ cokernel.œÄ f) (by simp)\n  inv := cokernel.desc _ (g ‚â´ cokernel.œÄ (f ‚â´ g)) (by rw [‚Üê Category.assoc, cokernel.condition])\n\n"}
{"name":"CategoryTheory.Limits.hasCokernel_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\nW : C\ng : Quiver.Hom W X\ninst‚úù : CategoryTheory.Epi g\n‚ä¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.CategoryStruct.comp g f)","decl":"instance hasCokernel_epi_comp {X Y : C} (f : X ‚ü∂ Y) [HasCokernel f] {W} (g : W ‚ü∂ X) [Epi g] :\n    HasCokernel (g ‚â´ f) :=\n  ‚ü®‚ü®{   cocone := _\n        isColimit := isCokernelEpiComp (colimit.isColimit _) g rfl }‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.cokernelEpiComp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Epi f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\n‚ä¢ Eq (CategoryTheory.Limits.cokernelEpiComp f g).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Limits.cokernel.œÄ g) ‚ãØ)","decl":"/-- When `f` is an epimorphism, the cokernel of `f ‚â´ g` is isomorphic to the cokernel of `g`.\n-/\n@[simps]\ndef cokernelEpiComp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [Epi f] [HasCokernel g] :\n    cokernel (f ‚â´ g) ‚âÖ cokernel g where\n  hom := cokernel.desc _ (cokernel.œÄ g) (by simp)\n  inv :=\n    cokernel.desc _ (cokernel.œÄ (f ‚â´ g))\n      (by\n        rw [‚Üê cancel_epi f, ‚Üê Category.assoc]\n        simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernelEpiComp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Epi f\ninst‚úù : CategoryTheory.Limits.HasCokernel g\n‚ä¢ Eq (CategoryTheory.Limits.cokernelEpiComp f g).inv (CategoryTheory.Limits.cokernel.desc g (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.CategoryStruct.comp f g)) ‚ãØ)","decl":"/-- When `f` is an epimorphism, the cokernel of `f ‚â´ g` is isomorphic to the cokernel of `g`.\n-/\n@[simps]\ndef cokernelEpiComp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [Epi f] [HasCokernel g] :\n    cokernel (f ‚â´ g) ‚âÖ cokernel g where\n  hom := cokernel.desc _ (cokernel.œÄ g) (by simp)\n  inv :=\n    cokernel.desc _ (cokernel.œÄ (f ‚â´ g))\n      (by\n        rw [‚Üê cancel_epi f, ‚Üê Category.assoc]\n        simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernel.œÄ_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (CategoryTheory.Limits.cokernel.œÄ f) 0","decl":"/-- The cokernel morphism of an epimorphism is a zero morphism -/\ntheorem cokernel.œÄ_of_epi [HasCokernel f] [Epi f] : cokernel.œÄ f = 0 :=\n  zero_of_target_iso_zero _ (cokernel.ofEpi f)\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.kernel_Œπ_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\nF : CategoryTheory.Limits.MonoFactorisation f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ f) F.e) 0","decl":"@[simp]\ntheorem MonoFactorisation.kernel_Œπ_comp [HasKernel f] (F : MonoFactorisation f) :\n    kernel.Œπ f ‚â´ F.e = 0 := by\n  rw [‚Üê cancel_mono F.m, zero_comp, Category.assoc, F.fac, kernel.condition]\n\n"}
{"name":"CategoryTheory.Limits.cokernelImageŒπ_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≥ : CategoryTheory.Limits.HasImage f\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.image.Œπ f)\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\n‚ä¢ Eq (CategoryTheory.Limits.cokernelImageŒπ f).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.Limits.image.Œπ f) (CategoryTheory.Limits.cokernel.œÄ f) ‚ãØ)","decl":"/-- The cokernel of the image inclusion of a morphism `f` is isomorphic to the cokernel of `f`.\n\n(This result requires that the factorisation through the image is an epimorphism.\nThis holds in any category with equalizers.)\n-/\n@[simps]\ndef cokernelImageŒπ {X Y : C} (f : X ‚ü∂ Y) [HasImage f] [HasCokernel (image.Œπ f)] [HasCokernel f]\n    [Epi (factorThruImage f)] : cokernel (image.Œπ f) ‚âÖ cokernel f where\n  hom :=\n    cokernel.desc _ (cokernel.œÄ f)\n      (by\n        have w := cokernel.condition f\n        conv at w =>\n          lhs\n          congr\n          rw [‚Üê image.fac f]\n        rw [‚Üê HasZeroMorphisms.comp_zero (Limits.factorThruImage f), Category.assoc,\n          cancel_epi] at w\n        exact w)\n  inv :=\n    cokernel.desc _ (cokernel.œÄ _)\n      (by\n        conv =>\n          lhs\n          congr\n          rw [‚Üê image.fac f]\n        rw [Category.assoc, cokernel.condition, HasZeroMorphisms.comp_zero])\n\n"}
{"name":"CategoryTheory.Limits.cokernelImageŒπ_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≥ : CategoryTheory.Limits.HasImage f\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.image.Œπ f)\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\n‚ä¢ Eq (CategoryTheory.Limits.cokernelImageŒπ f).inv (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.Limits.image.Œπ f)) ‚ãØ)","decl":"/-- The cokernel of the image inclusion of a morphism `f` is isomorphic to the cokernel of `f`.\n\n(This result requires that the factorisation through the image is an epimorphism.\nThis holds in any category with equalizers.)\n-/\n@[simps]\ndef cokernelImageŒπ {X Y : C} (f : X ‚ü∂ Y) [HasImage f] [HasCokernel (image.Œπ f)] [HasCokernel f]\n    [Epi (factorThruImage f)] : cokernel (image.Œπ f) ‚âÖ cokernel f where\n  hom :=\n    cokernel.desc _ (cokernel.œÄ f)\n      (by\n        have w := cokernel.condition f\n        conv at w =>\n          lhs\n          congr\n          rw [‚Üê image.fac f]\n        rw [‚Üê HasZeroMorphisms.comp_zero (Limits.factorThruImage f), Category.assoc,\n          cancel_epi] at w\n        exact w)\n  inv :=\n    cokernel.desc _ (cokernel.œÄ _)\n      (by\n        conv =>\n          lhs\n          congr\n          rw [‚Üê image.fac f]\n        rw [Category.assoc, cokernel.condition, HasZeroMorphisms.comp_zero])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.œÄ_of_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ 0)","decl":"/-- The cokernel of a zero morphism is an isomorphism -/\ntheorem cokernel.œÄ_of_zero : IsIso (cokernel.œÄ (0 : X ‚ü∂ Y)) :=\n  coequalizer.œÄ_of_self _\n\n"}
{"name":"CategoryTheory.Limits.kernel.of_cokernel_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel f\ninst‚úù¬π : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.œÄ f)\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Œπ (CategoryTheory.Limits.cokernel.œÄ f))","decl":"/-- The kernel of the cokernel of an epimorphism is an isomorphism -/\ninstance kernel.of_cokernel_of_epi [HasCokernel f] [HasKernel (cokernel.œÄ f)] [Epi f] :\n    IsIso (kernel.Œπ (cokernel.œÄ f)) :=\n  equalizer.Œπ_of_eq <| cokernel.œÄ_of_epi f\n\n"}
{"name":"CategoryTheory.Limits.cokernel.of_kernel_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Limits.HasKernel f\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.Œπ f)\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.œÄ (CategoryTheory.Limits.kernel.Œπ f))","decl":"/-- The cokernel of the kernel of a monomorphism is an isomorphism -/\ninstance cokernel.of_kernel_of_mono [HasKernel f] [HasCokernel (kernel.Œπ f)] [Mono f] :\n    IsIso (cokernel.œÄ (kernel.Œπ f)) :=\n  coequalizer.œÄ_of_eq <| kernel.Œπ_of_mono f\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.Limits.kernel.Œπ (G.map f))) (G.map (CategoryTheory.Limits.kernel.Œπ f))","decl":"@[reassoc (attr := simp)]\ntheorem kernelComparison_comp_Œπ [HasKernel f] [HasKernel (G.map f)] :\n    kernelComparison f G ‚â´ kernel.Œπ (G.map f) = G.map (kernel.Œπ f) :=\n  kernel.lift_Œπ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_Œπ_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map f)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Œπ (G.map f)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.Œπ f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelComparison_comp_Œπ [HasKernel f] [HasKernel (G.map f)] :\n    kernelComparison f G ‚â´ kernel.Œπ (G.map f) = G.map (kernel.Œπ f) :=\n  kernel.lift_Œπ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.map_lift_kernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map f)\nZ‚úù : C\nh‚úù : Quiver.Hom Z‚úù X\nw : Eq (CategoryTheory.CategoryStruct.comp h‚úù f) 0\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.kernel (G.map f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.lift f h‚úù w)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift (G.map f) (G.map h‚úù) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_kernelComparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : Z ‚ü∂ X}\n    (w : h ‚â´ f = 0) :\n    G.map (kernel.lift _ h w) ‚â´ kernelComparison f G =\n      kernel.lift _ (G.map h) (by simp only [‚Üê G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_kernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasKernel f\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map f)\nZ : C\nh : Quiver.Hom Z X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.lift f h w)) (CategoryTheory.Limits.kernelComparison f G)) (CategoryTheory.Limits.kernel.lift (G.map f) (G.map h) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_kernelComparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : Z ‚ü∂ X}\n    (w : h ‚â´ f = 0) :\n    G.map (kernel.lift _ h w) ‚â´ kernelComparison f G =\n      kernel.lift _ (G.map h) (by simp only [‚Üê G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_kernel_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∑ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù‚Å¥ : G.PreservesZeroMorphisms\nX' Y' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasKernel f\ninst‚úù¬≤ : CategoryTheory.Limits.HasKernel (G.map f)\ng : Quiver.Hom X' Y'\ninst‚úù¬π : CategoryTheory.Limits.HasKernel g\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) ‚ãØ)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)) (CategoryTheory.Limits.kernelComparison g G))","decl":"@[reassoc]\ntheorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]\n    (g : X' ‚ü∂ Y') [HasKernel g] [HasKernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')\n    (hpq : f ‚â´ q = p ‚â´ g) :\n    kernelComparison f G ‚â´\n        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) =\n      G.map (kernel.map f g p q hpq) ‚â´ kernelComparison g G :=\n  kernel.lift_map _ _ (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _\n    (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _ _\n    (by simp only [‚Üê G.map_comp]; exact G.congr_map (kernel.lift_Œπ _ _ _).symm) _\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_kernel_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∑ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù‚Å¥ : G.PreservesZeroMorphisms\nX' Y' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasKernel f\ninst‚úù¬≤ : CategoryTheory.Limits.HasKernel (G.map f)\ng : Quiver.Hom X' Y'\ninst‚úù¬π : CategoryTheory.Limits.HasKernel g\ninst‚úù : CategoryTheory.Limits.HasKernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.kernel (G.map g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison g G) h))","decl":"@[reassoc]\ntheorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]\n    (g : X' ‚ü∂ Y') [HasKernel g] [HasKernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')\n    (hpq : f ‚â´ q = p ‚â´ g) :\n    kernelComparison f G ‚â´\n        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) =\n      G.map (kernel.map f g p q hpq) ‚â´ kernelComparison g G :=\n  kernel.lift_map _ _ (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _\n    (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _ _\n    (by simp only [‚Üê G.map_comp]; exact G.congr_map (kernel.lift_Œπ _ _ _).symm) _\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map f)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ (G.map f)) (CategoryTheory.Limits.cokernelComparison f G)) (G.map (CategoryTheory.Limits.cokernel.œÄ f))","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel.œÄ (G.map f) ‚â´ cokernelComparison f G = G.map (cokernel.œÄ _) :=\n  cokernel.œÄ_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.œÄ_comp_cokernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map f)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.cokernel f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.œÄ (G.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.œÄ f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem œÄ_comp_cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel.œÄ (G.map f) ‚â´ cokernelComparison f G = G.map (cokernel.œÄ _) :=\n  cokernel.œÄ_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.cokernelComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map f)\nZ‚úù : C\nh‚úù : Quiver.Hom Y Z‚úù\nw : Eq (CategoryTheory.CategoryStruct.comp f h‚úù) 0\nZ : D\nh : Quiver.Hom (G.obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.desc f h‚úù w)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc (G.map f) (G.map h‚úù) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelComparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : Y ‚ü∂ Z}\n    (w : f ‚â´ h = 0) :\n    cokernelComparison f G ‚â´ G.map (cokernel.desc _ h w) =\n      cokernel.desc _ (G.map h) (by simp only [‚Üê G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.cokernelComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.PreservesZeroMorphisms\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel f\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map f)\nZ : C\nh : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f h) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (G.map (CategoryTheory.Limits.cokernel.desc f h w))) (CategoryTheory.Limits.cokernel.desc (G.map f) (G.map h) ‚ãØ)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelComparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : Y ‚ü∂ Z}\n    (w : f ‚â´ h = 0) :\n    cokernelComparison f G ‚â´ G.map (cokernel.desc _ h w) =\n      cokernel.desc _ (G.map h) (by simp only [‚Üê G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [‚Üê G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.cokernel_map_comp_cokernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∑ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù‚Å¥ : G.PreservesZeroMorphisms\nX' Y' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasCokernel f\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel (G.map f)\ng : Quiver.Hom X' Y'\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel g\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) ‚ãØ) (CategoryTheory.Limits.cokernelComparison g G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)))","decl":"@[reassoc]\ntheorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]\n    (g : X' ‚ü∂ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')\n    (hpq : f ‚â´ q = p ‚â´ g) :\n    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) ‚â´\n        cokernelComparison _ G =\n      cokernelComparison _ G ‚â´ G.map (cokernel.map f g p q hpq) :=\n  cokernel.map_desc _ _ (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _\n    (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _\n    (by simp only [‚Üê G.map_comp]; exact G.congr_map (cokernel.œÄ_desc _ _ _))\n\n"}
{"name":"CategoryTheory.Limits.cokernel_map_comp_cokernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∑ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Åµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst‚úù‚Å¥ : G.PreservesZeroMorphisms\nX' Y' : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasCokernel f\ninst‚úù¬≤ : CategoryTheory.Limits.HasCokernel (G.map f)\ng : Quiver.Hom X' Y'\ninst‚úù¬π : CategoryTheory.Limits.HasCokernel g\ninst‚úù : CategoryTheory.Limits.HasCokernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.cokernel g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison g G) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)) h))","decl":"@[reassoc]\ntheorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]\n    (g : X' ‚ü∂ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')\n    (hpq : f ‚â´ q = p ‚â´ g) :\n    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) ‚â´\n        cokernelComparison _ G =\n      cokernelComparison _ G ‚â´ G.map (cokernel.map f g p q hpq) :=\n  cokernel.map_desc _ _ (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _\n    (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _\n    (by simp only [‚Üê G.map_comp]; exact G.congr_map (cokernel.œÄ_desc _ _ _))\n\n"}
{"name":"CategoryTheory.Limits.HasKernels.has_limit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasKernels C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasKernel f","decl":"/-- `HasKernels` represents the existence of kernels for every morphism. -/\nclass HasKernels : Prop where\n  has_limit : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasKernel f := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasCokernels.has_colimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasCokernel f","decl":"/-- `HasCokernels` represents the existence of cokernels for every morphism. -/\nclass HasCokernels : Prop where\n  has_colimit : ‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasCokernel f := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasKernels_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasEqualizers C\n‚ä¢ CategoryTheory.Limits.HasKernels C","decl":"instance (priority := 100) hasKernels_of_hasEqualizers [HasEqualizers C] : HasKernels C where\n\n"}
{"name":"CategoryTheory.Limits.hasCokernels_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasCoequalizers C\n‚ä¢ CategoryTheory.Limits.HasCokernels C","decl":"instance (priority := 100) hasCokernels_of_hasCoequalizers [HasCoequalizers C] :\n    HasCokernels C where\n\n"}
