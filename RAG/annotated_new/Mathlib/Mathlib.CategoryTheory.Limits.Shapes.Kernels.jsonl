{"name":"CategoryTheory.Limits.KernelFork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Î¹ s) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem KernelFork.condition (s : KernelFork f) : Fork.Î¹ s â‰« f = 0 := by\n  rw [Fork.condition, HasZeroMorphisms.comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Î¹ s) f) 0","decl":"@[reassoc (attr := simp)]\ntheorem KernelFork.condition (s : KernelFork f) : Fork.Î¹ s â‰« f = 0 := by\n  rw [Fork.condition, HasZeroMorphisms.comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.KernelFork f\nâŠ¢ Eq (s.Ï€.app CategoryTheory.Limits.WalkingParallelPair.one) 0","decl":"theorem KernelFork.app_one (s : KernelFork f) : s.Ï€.app one = 0 := by\n  simp [Fork.app_one_eq_Î¹_comp_right]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.Î¹_ofÎ¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y P : C\nf : Quiver.Hom X Y\nÎ¹ : Quiver.Hom P X\nw : Eq (CategoryTheory.CategoryStruct.comp Î¹ f) 0\nâŠ¢ Eq (CategoryTheory.Limits.Fork.Î¹ (CategoryTheory.Limits.KernelFork.ofÎ¹ Î¹ w)) Î¹","decl":"@[simp]\ntheorem KernelFork.Î¹_ofÎ¹ {X Y P : C} (f : X âŸ¶ Y) (Î¹ : P âŸ¶ X) (w : Î¹ â‰« f = 0) :\n    Fork.Î¹ (KernelFork.ofÎ¹ Î¹ w) = Î¹ := rfl\n\n"}
{"name":"CategoryTheory.Limits.isKernelCompMono_lift","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\ni : CategoryTheory.Limits.IsLimit c\nZ : C\ng : Quiver.Hom Y Z\nhg : CategoryTheory.Mono g\nh : Quiver.Hom X Z\nhh : Eq h (CategoryTheory.CategoryStruct.comp f g)\ns : CategoryTheory.Limits.KernelFork h\nâŠ¢ Eq ((CategoryTheory.Limits.isKernelCompMono i g hh).lift s) (i.lift (CategoryTheory.Limits.Fork.ofÎ¹ (CategoryTheory.Limits.Fork.Î¹ s) â‹¯))","decl":"theorem isKernelCompMono_lift {c : KernelFork f} (i : IsLimit c) {Z} (g : Y âŸ¶ Z) [hg : Mono g]\n    {h : X âŸ¶ Z} (hh : h = f â‰« g) (s : KernelFork h) :\n    (isKernelCompMono i g hh).lift s = i.lift (Fork.ofÎ¹ s.Î¹ (by\n      rw [â† cancel_mono g, Category.assoc, â† hh]\n      simp)) := rfl\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.IsLimit.isIso_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nhc : CategoryTheory.Limits.IsLimit c\nhf : Eq f 0\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.Fork.Î¹ c)","decl":"lemma KernelFork.IsLimit.isIso_Î¹ {X Y : C} {f : X âŸ¶ Y} (c : KernelFork f)\n    (hc : IsLimit c) (hf : f = 0) : IsIso c.Î¹ := by\n  let e : c.pt â‰… X := IsLimit.conePointUniqueUpToIso hc\n    (KernelFork.IsLimit.ofId (f : X âŸ¶ Y) hf)\n  have eq : e.inv â‰« c.Î¹ = ğŸ™ X := Fork.IsLimit.lift_Î¹ hc\n  haveI : IsIso (e.inv â‰« c.Î¹) := by\n    rw [eq]\n    infer_instance\n  exact IsIso.of_isIso_comp_left e.inv c.Î¹\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapOfIsLimit_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf' : CategoryTheory.Limits.IsLimit kf'\nÏ† : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (kf.mapOfIsLimit hf' Ï†) (CategoryTheory.Limits.Fork.Î¹ kf')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Î¹ kf) Ï†.left)","decl":"@[reassoc (attr := simp)]\nlemma mapOfIsLimit_Î¹ (kf : KernelFork f) {kf' : KernelFork f'} (hf' : IsLimit kf')\n    (Ï† : Arrow.mk f âŸ¶ Arrow.mk f') :\n    kf.mapOfIsLimit hf' Ï† â‰« kf'.Î¹ = kf.Î¹ â‰« Ï†.left :=\n  hf'.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapOfIsLimit_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf' : CategoryTheory.Limits.IsLimit kf'\nÏ† : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.parallelPair f' 0).obj CategoryTheory.Limits.WalkingParallelPair.zero) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (kf.mapOfIsLimit hf' Ï†) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Î¹ kf') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Î¹ kf) (CategoryTheory.CategoryStruct.comp Ï†.left h))","decl":"@[reassoc (attr := simp)]\nlemma mapOfIsLimit_Î¹ (kf : KernelFork f) {kf' : KernelFork f'} (hf' : IsLimit kf')\n    (Ï† : Arrow.mk f âŸ¶ Arrow.mk f') :\n    kf.mapOfIsLimit hf' Ï† â‰« kf'.Î¹ = kf.Î¹ â‰« Ï†.left :=\n  hf'.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf : CategoryTheory.Limits.IsLimit kf\nhf' : CategoryTheory.Limits.IsLimit kf'\nÏ† : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit hf hf' Ï†).inv (kf'.mapOfIsLimit hf Ï†.inv)","decl":"/-- The isomorphism between points of limit kernel forks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsLimit {kf : KernelFork f} {kf' : KernelFork f'}\n    (hf : IsLimit kf) (hf' : IsLimit kf')\n    (Ï† : Arrow.mk f â‰… Arrow.mk f') : kf.pt â‰… kf'.pt where\n  hom := kf.mapOfIsLimit hf' Ï†.hom\n  inv := kf'.mapOfIsLimit hf Ï†.inv\n  hom_inv_id := Fork.IsLimit.hom_ext hf (by simp)\n  inv_hom_id := Fork.IsLimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\nkf : CategoryTheory.Limits.KernelFork f\nkf' : CategoryTheory.Limits.KernelFork f'\nhf : CategoryTheory.Limits.IsLimit kf\nhf' : CategoryTheory.Limits.IsLimit kf'\nÏ† : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.Limits.KernelFork.mapIsoOfIsLimit hf hf' Ï†).hom (kf.mapOfIsLimit hf' Ï†.hom)","decl":"/-- The isomorphism between points of limit kernel forks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsLimit {kf : KernelFork f} {kf' : KernelFork f'}\n    (hf : IsLimit kf) (hf' : IsLimit kf')\n    (Ï† : Arrow.mk f â‰… Arrow.mk f') : kf.pt â‰… kf'.pt where\n  hom := kf.mapOfIsLimit hf' Ï†.hom\n  inv := kf'.mapOfIsLimit hf Ï†.inv\n  hom_inv_id := Fork.IsLimit.hom_ext hf (by simp)\n  inv_hom_id := Fork.IsLimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.equalizer_as_kernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nâŠ¢ Eq (CategoryTheory.Limits.equalizer.Î¹ f 0) (CategoryTheory.Limits.kernel.Î¹ f)","decl":"@[simp]\ntheorem equalizer_as_kernel : equalizer.Î¹ f 0 = kernel.Î¹ f := rfl\n\n"}
{"name":"CategoryTheory.Limits.kernel.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nZ : C\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem kernel.condition : kernel.Î¹ f â‰« f = 0 :=\n  KernelFork.condition _\n\n"}
{"name":"CategoryTheory.Limits.kernel.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) f) 0","decl":"@[reassoc (attr := simp)]\ntheorem kernel.condition : kernel.Î¹ f â‰« f = 0 :=\n  KernelFork.condition _\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nhâœ : Eq (CategoryTheory.CategoryStruct.comp k f) 0\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f k hâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\ntheorem kernel.lift_Î¹ {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : kernel.lift f k h â‰« kernel.Î¹ f = k :=\n  (kernelIsKernel f).fac (KernelFork.ofÎ¹ k h) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f k h) (CategoryTheory.Limits.kernel.Î¹ f)) k","decl":"@[reassoc (attr := simp)]\ntheorem kernel.lift_Î¹ {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) : kernel.lift f k h â‰« kernel.Î¹ f = k :=\n  (kernelIsKernel f).fac (KernelFork.ofÎ¹ k h) WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nW : C\nh : Eq (CategoryTheory.CategoryStruct.comp 0 f) 0\nâŠ¢ Eq (CategoryTheory.Limits.kernel.lift f 0 h) 0","decl":"@[simp]\ntheorem kernel.lift_zero {W : C} {h} : kernel.lift f (0 : W âŸ¶ X) h = 0 := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\nW : C\nk : Quiver.Hom W X\nh : Eq (CategoryTheory.CategoryStruct.comp k f) 0\ninstâœ : CategoryTheory.Mono k\nâŠ¢ CategoryTheory.Mono (CategoryTheory.Limits.kernel.lift f k h)","decl":"instance kernel.lift_mono {W : C} (k : W âŸ¶ X) (h : k â‰« f = 0) [Mono k] : Mono (kernel.lift f k h) :=\n  âŸ¨fun {Z} g g' w => by\n    replace w := w =â‰« kernel.Î¹ f\n    simp only [Category.assoc, kernel.lift_Î¹] at w\n    exact (cancel_mono k).1 wâŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernel.lift_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel g\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nf' : Quiver.Hom X' Y'\ng' : Quiver.Hom Y' Z'\ninstâœ : CategoryTheory.Limits.HasKernel g'\nw' : Eq (CategoryTheory.CategoryStruct.comp f' g') 0\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nr : Quiver.Hom Z Z'\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.comp q g')\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g f w) (CategoryTheory.Limits.kernel.map g g' q r hâ‚‚)) (CategoryTheory.CategoryStruct.comp p (CategoryTheory.Limits.kernel.lift g' f' w'))","decl":"/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   X ---> kernel g\n   |         |\n   |         | kernel.map\n   |         |\n   v         v\n   X' --> kernel g'\n-/\ntheorem kernel.lift_map {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasKernel g] (w : f â‰« g = 0)\n    (f' : X' âŸ¶ Y') (g' : Y' âŸ¶ Z') [HasKernel g'] (w' : f' â‰« g' = 0) (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') :\n    kernel.lift g f w â‰« kernel.map g g' q r hâ‚‚ = p â‰« kernel.lift g' f' w' := by\n  ext; simp [hâ‚]\n\n"}
{"name":"CategoryTheory.Limits.kernel.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninstâœ : CategoryTheory.Limits.HasKernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\nâŠ¢ Eq (CategoryTheory.Limits.kernel.mapIso f f' p q w).hom (CategoryTheory.Limits.kernel.map f f' p.hom q.hom w)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of kernels. -/\n@[simps]\ndef kernel.mapIso {X' Y' : C} (f' : X' âŸ¶ Y') [HasKernel f'] (p : X â‰… X') (q : Y â‰… Y')\n    (w : f â‰« q.hom = p.hom â‰« f') : kernel f â‰… kernel f' where\n  hom := kernel.map f f' p.hom q.hom w\n  inv :=\n    kernel.map f' f p.inv q.inv\n      (by\n        refine (cancel_mono q.hom).1 ?_\n        simp [w])\n\n"}
{"name":"CategoryTheory.Limits.kernel.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninstâœ : CategoryTheory.Limits.HasKernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\nâŠ¢ Eq (CategoryTheory.Limits.kernel.mapIso f f' p q w).inv (CategoryTheory.Limits.kernel.map f' f p.inv q.inv â‹¯)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of kernels. -/\n@[simps]\ndef kernel.mapIso {X' Y' : C} (f' : X' âŸ¶ Y') [HasKernel f'] (p : X â‰… X') (q : Y â‰… Y')\n    (w : f â‰« q.hom = p.hom â‰« f') : kernel f â‰… kernel f' where\n  hom := kernel.map f f' p.hom q.hom w\n  inv :=\n    kernel.map f' f p.inv q.inv\n      (by\n        refine (cancel_mono q.hom).1 ?_\n        simp [w])\n\n"}
{"name":"CategoryTheory.Limits.kernel.Î¹_zero_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Î¹ 0)","decl":"/-- Every kernel of the zero morphism is an isomorphism -/\ninstance kernel.Î¹_zero_isIso : IsIso (kernel.Î¹ (0 : X âŸ¶ Y)) :=\n  equalizer.Î¹_of_self _\n\n"}
{"name":"CategoryTheory.Limits.eq_zero_of_epi_kernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Epi (CategoryTheory.Limits.kernel.Î¹ f)\nâŠ¢ Eq f 0","decl":"theorem eq_zero_of_epi_kernel [Epi (kernel.Î¹ f)] : f = 0 :=\n  (cancel_epi (kernel.Î¹ f)).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelZeroIsoSource_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ Eq CategoryTheory.Limits.kernelZeroIsoSource.hom (CategoryTheory.Limits.kernel.Î¹ 0)","decl":"@[simp]\ntheorem kernelZeroIsoSource_hom : kernelZeroIsoSource.hom = kernel.Î¹ (0 : X âŸ¶ Y) := rfl\n\n"}
{"name":"CategoryTheory.Limits.kernelZeroIsoSource_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ Eq CategoryTheory.Limits.kernelZeroIsoSource.inv (CategoryTheory.Limits.kernel.lift 0 (CategoryTheory.CategoryStruct.id X) â‹¯)","decl":"@[simp]\ntheorem kernelZeroIsoSource_inv :\n    kernelZeroIsoSource.inv = kernel.lift (0 : X âŸ¶ Y) (ğŸ™ X) (by simp) := by\n  ext\n  simp [kernelZeroIsoSource]\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_refl","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nh : Eq f f\nâŠ¢ Eq (CategoryTheory.Limits.kernelIsoOfEq h) (CategoryTheory.Iso.refl (CategoryTheory.Limits.kernel f))","decl":"@[simp]\ntheorem kernelIsoOfEq_refl {h : f = f} : kernelIsoOfEq h = Iso.refl (kernel f) := by\n  ext\n  simp [kernelIsoOfEq]\n\n/- Porting note: induction on Eq is trying instantiate another g... -/\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_hom_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nh : Eq f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h).hom (CategoryTheory.Limits.kernel.Î¹ g)) (CategoryTheory.Limits.kernel.Î¹ f)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_hom_comp_Î¹ {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).hom â‰« kernel.Î¹ g = kernel.Î¹ f := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_hom_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nhâœ : Eq f g\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq hâœ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_hom_comp_Î¹ {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).hom â‰« kernel.Î¹ g = kernel.Î¹ f := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_inv_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nhâœ : Eq f g\nZ : C\nh : Quiver.Hom X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq hâœ).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ g) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_inv_comp_Î¹ {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).inv â‰« kernel.Î¹ _ = kernel.Î¹ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_inv_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nh : Eq f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq h).inv (CategoryTheory.Limits.kernel.Î¹ f)) (CategoryTheory.Limits.kernel.Î¹ g)","decl":"@[reassoc (attr := simp)]\ntheorem kernelIsoOfEq_inv_comp_Î¹ {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g) :\n    (kernelIsoOfEq h).inv â‰« kernel.Î¹ _ = kernel.Î¹ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nh : Eq f g\ne : Quiver.Hom Z X\nhe : Eq (CategoryTheory.CategoryStruct.comp e f) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e he) (CategoryTheory.Limits.kernelIsoOfEq h).hom) (CategoryTheory.Limits.kernel.lift g e â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_hom {Z} {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z âŸ¶ X) (he) :\n    kernel.lift _ e he â‰« (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [â† h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Zâœ : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nhâœ : Eq f g\ne : Quiver.Hom Zâœ X\nhe : Eq (CategoryTheory.CategoryStruct.comp e f) 0\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e he) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq hâœ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_hom {Z} {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z âŸ¶ X) (he) :\n    kernel.lift _ e he â‰« (kernelIsoOfEq h).hom = kernel.lift _ e (by simp [â† h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Zâœ : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nhâœ : Eq f g\ne : Quiver.Hom Zâœ X\nhe : Eq (CategoryTheory.CategoryStruct.comp e g) 0\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.kernel f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e he) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelIsoOfEq hâœ).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift f e â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_inv {Z} {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z âŸ¶ X) (he) :\n    kernel.lift _ e he â‰« (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.lift_comp_kernelIsoOfEq_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel g\nh : Eq f g\ne : Quiver.Hom Z X\nhe : Eq (CategoryTheory.CategoryStruct.comp e g) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift g e he) (CategoryTheory.Limits.kernelIsoOfEq h).inv) (CategoryTheory.Limits.kernel.lift f e â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem lift_comp_kernelIsoOfEq_inv {Z} {f g : X âŸ¶ Y} [HasKernel f] [HasKernel g] (h : f = g)\n    (e : Z âŸ¶ X) (he) :\n    kernel.lift _ e he â‰« (kernelIsoOfEq h).inv = kernel.lift _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.kernelIsoOfEq_trans","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g h : Quiver.Hom X Y\ninstâœÂ² : CategoryTheory.Limits.HasKernel f\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel g\ninstâœ : CategoryTheory.Limits.HasKernel h\nwâ‚ : Eq f g\nwâ‚‚ : Eq g h\nâŠ¢ Eq ((CategoryTheory.Limits.kernelIsoOfEq wâ‚).trans (CategoryTheory.Limits.kernelIsoOfEq wâ‚‚)) (CategoryTheory.Limits.kernelIsoOfEq â‹¯)","decl":"@[simp]\ntheorem kernelIsoOfEq_trans {f g h : X âŸ¶ Y} [HasKernel f] [HasKernel g] [HasKernel h] (wâ‚ : f = g)\n    (wâ‚‚ : g = h) : kernelIsoOfEq wâ‚ â‰ªâ‰« kernelIsoOfEq wâ‚‚ = kernelIsoOfEq (wâ‚.trans wâ‚‚) := by\n  cases wâ‚; cases wâ‚‚; ext; simp [kernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.kernel_not_epi_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nw : Ne f 0\nâŠ¢ Not (CategoryTheory.Epi (CategoryTheory.Limits.kernel.Î¹ f))","decl":"theorem kernel_not_epi_of_nonzero (w : f â‰  0) : Â¬Epi (kernel.Î¹ f) := fun _ =>\n  w (eq_zero_of_epi_kernel f)\n\n"}
{"name":"CategoryTheory.Limits.kernel_not_iso_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nw : Ne f 0\naâœ : CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Î¹ f)\nâŠ¢ False","decl":"theorem kernel_not_iso_of_nonzero (w : f â‰  0) : IsIso (kernel.Î¹ f) â†’ False := fun _ =>\n  kernel_not_epi_of_nonzero w inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasKernel_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ng : Quiver.Hom Y Z\ninstâœ : CategoryTheory.Mono g\nâŠ¢ CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasKernel_comp_mono {X Y Z : C} (f : X âŸ¶ Y) [HasKernel f] (g : Y âŸ¶ Z) [Mono g] :\n    HasKernel (f â‰« g) :=\n  âŸ¨âŸ¨{   cone := _\n        isLimit := isKernelCompMono (limit.isLimit _) g rfl }âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelCompMono_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Mono g\nâŠ¢ Eq (CategoryTheory.Limits.kernelCompMono f g).inv (CategoryTheory.Limits.kernel.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Limits.kernel.Î¹ f) â‹¯)","decl":"/-- When `g` is a monomorphism, the kernel of `f â‰« g` is isomorphic to the kernel of `f`.\n-/\n@[simps]\ndef kernelCompMono {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasKernel f] [Mono g] :\n    kernel (f â‰« g) â‰… kernel f where\n  hom :=\n    kernel.lift _ (kernel.Î¹ _)\n      (by\n        rw [â† cancel_mono g]\n        simp)\n  inv := kernel.lift _ (kernel.Î¹ _) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelCompMono_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Mono g\nâŠ¢ Eq (CategoryTheory.Limits.kernelCompMono f g).hom (CategoryTheory.Limits.kernel.lift f (CategoryTheory.Limits.kernel.Î¹ (CategoryTheory.CategoryStruct.comp f g)) â‹¯)","decl":"/-- When `g` is a monomorphism, the kernel of `f â‰« g` is isomorphic to the kernel of `f`.\n-/\n@[simps]\ndef kernelCompMono {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasKernel f] [Mono g] :\n    kernel (f â‰« g) â‰… kernel f where\n  hom :=\n    kernel.lift _ (kernel.Î¹ _)\n      (by\n        rw [â† cancel_mono g]\n        simp)\n  inv := kernel.lift _ (kernel.Î¹ _) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.hasKernel_iso_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.IsIso f\ninstâœ : CategoryTheory.Limits.HasKernel g\nâŠ¢ CategoryTheory.Limits.HasKernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasKernel_iso_comp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsIso f] [HasKernel g] :\n    HasKernel (f â‰« g) where\n  exists_limit :=\n    âŸ¨{  cone := KernelFork.ofÎ¹ (kernel.Î¹ g â‰« inv f) (by simp)\n        isLimit := isLimitAux _ (fun s => kernel.lift _ (s.Î¹ â‰« f) (by simp))\n            (by simp) fun s m w => by\n          simp_rw [â† w]\n          symm\n          apply equalizer.hom_ext\n          simp }âŸ©\n\n"}
{"name":"CategoryTheory.Limits.kernelIsIsoComp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.IsIso f\ninstâœ : CategoryTheory.Limits.HasKernel g\nâŠ¢ Eq (CategoryTheory.Limits.kernelIsIsoComp f g).inv (CategoryTheory.Limits.kernel.lift (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ g) (CategoryTheory.inv f)) â‹¯)","decl":"/-- When `f` is an isomorphism, the kernel of `f â‰« g` is isomorphic to the kernel of `g`.\n-/\n@[simps]\ndef kernelIsIsoComp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsIso f] [HasKernel g] :\n    kernel (f â‰« g) â‰… kernel g where\n  hom := kernel.lift _ (kernel.Î¹ _ â‰« f) (by simp)\n  inv := kernel.lift _ (kernel.Î¹ _ â‰« inv f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernelIsIsoComp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.IsIso f\ninstâœ : CategoryTheory.Limits.HasKernel g\nâŠ¢ Eq (CategoryTheory.Limits.kernelIsIsoComp f g).hom (CategoryTheory.Limits.kernel.lift g (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ (CategoryTheory.CategoryStruct.comp f g)) f) â‹¯)","decl":"/-- When `f` is an isomorphism, the kernel of `f â‰« g` is isomorphic to the kernel of `g`.\n-/\n@[simps]\ndef kernelIsIsoComp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsIso f] [HasKernel g] :\n    kernel (f â‰« g) â‰… kernel g where\n  hom := kernel.lift _ (kernel.Î¹ _ â‰« f) (by simp)\n  inv := kernel.lift _ (kernel.Î¹ _ â‰« inv f) (by simp)\n\n"}
{"name":"CategoryTheory.Limits.kernel.Î¹_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ² : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Mono f\nâŠ¢ Eq (CategoryTheory.Limits.kernel.Î¹ f) 0","decl":"/-- The kernel morphism of a monomorphism is a zero morphism -/\ntheorem kernel.Î¹_of_mono [HasKernel f] [Mono f] : kernel.Î¹ f = 0 :=\n  zero_of_source_iso_zero _ (kernel.ofMono f)\n\n"}
{"name":"CategoryTheory.Limits.kernel.Î¹_of_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Î¹ 0)","decl":"/-- The kernel morphism of a zero morphism is an isomorphism -/\ntheorem kernel.Î¹_of_zero : IsIso (kernel.Î¹ (0 : X âŸ¶ Y)) :=\n  equalizer.Î¹_of_self _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Cofork.Ï€ s)) 0","decl":"@[reassoc (attr := simp)]\ntheorem CokernelCofork.condition (s : CokernelCofork f) : f â‰« s.Ï€ = 0 := by\n  rw [Cofork.condition, zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\nZ : C\nh : Quiver.Hom (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj s.pt).obj CategoryTheory.Limits.WalkingParallelPair.one) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.Ï€ s) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem CokernelCofork.condition (s : CokernelCofork f) : f â‰« s.Ï€ = 0 := by\n  rw [Cofork.condition, zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.Ï€_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ns : CategoryTheory.Limits.CokernelCofork f\nâŠ¢ Eq (s.Î¹.app CategoryTheory.Limits.WalkingParallelPair.zero) 0","decl":"theorem CokernelCofork.Ï€_eq_zero (s : CokernelCofork f) : s.Î¹.app zero = 0 := by\n  simp [Cofork.app_zero_eq_comp_Ï€_right]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.Ï€_ofÏ€","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y P : C\nf : Quiver.Hom X Y\nÏ€ : Quiver.Hom Y P\nw : Eq (CategoryTheory.CategoryStruct.comp f Ï€) 0\nâŠ¢ Eq (CategoryTheory.Limits.Cofork.Ï€ (CategoryTheory.Limits.CokernelCofork.ofÏ€ Ï€ w)) Ï€","decl":"@[simp]\ntheorem CokernelCofork.Ï€_ofÏ€ {X Y P : C} (f : X âŸ¶ Y) (Ï€ : Y âŸ¶ P) (w : f â‰« Ï€ = 0) :\n    Cofork.Ï€ (CokernelCofork.ofÏ€ Ï€ w) = Ï€ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.isCokernelEpiComp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\ni : CategoryTheory.Limits.IsColimit c\nW : C\ng : Quiver.Hom W X\nhg : CategoryTheory.Epi g\nh : Quiver.Hom W Y\nhh : Eq h (CategoryTheory.CategoryStruct.comp g f)\ns : CategoryTheory.Limits.CokernelCofork h\nâŠ¢ Eq ((CategoryTheory.Limits.isCokernelEpiComp i g hh).desc s) (i.desc (CategoryTheory.Limits.Cofork.ofÏ€ (CategoryTheory.Limits.Cofork.Ï€ s) â‹¯))","decl":"@[simp]\ntheorem isCokernelEpiComp_desc {c : CokernelCofork f} (i : IsColimit c) {W} (g : W âŸ¶ X) [hg : Epi g]\n    {h : W âŸ¶ Y} (hh : h = g â‰« f) (s : CokernelCofork h) :\n    (isCokernelEpiComp i g hh).desc s =\n      i.desc\n        (Cofork.ofÏ€ s.Ï€\n          (by\n            rw [â† cancel_epi g, â† Category.assoc, â† hh]\n            simp)) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.IsColimit.isIso_Ï€","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nhc : CategoryTheory.Limits.IsColimit c\nhf : Eq f 0\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.Cofork.Ï€ c)","decl":"lemma CokernelCofork.IsColimit.isIso_Ï€ {X Y : C} {f : X âŸ¶ Y} (c : CokernelCofork f)\n    (hc : IsColimit c) (hf : f = 0) : IsIso c.Ï€ := by\n  let e : c.pt â‰… Y := IsColimit.coconePointUniqueUpToIso hc\n    (CokernelCofork.IsColimit.ofId (f : X âŸ¶ Y) hf)\n  have eq : c.Ï€ â‰« e.hom = ğŸ™ Y := Cofork.IsColimit.Ï€_desc hc\n  haveI : IsIso (c.Ï€ â‰« e.hom) := by\n    rw [eq]\n    dsimp\n    infer_instance\n  exact IsIso.of_isIso_comp_right c.Ï€ e.hom\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.Ï€_mapOfIsColimit_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\nhf : CategoryTheory.Limits.IsColimit cc\ncc' : CategoryTheory.Limits.CokernelCofork f'\nÏ† : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nZ : C\nh : Quiver.Hom cc'.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.Ï€ cc) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' Ï†) h)) (CategoryTheory.CategoryStruct.comp Ï†.right (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.Ï€ cc') h))","decl":"@[reassoc (attr := simp)]\nlemma Ï€_mapOfIsColimit {cc : CokernelCofork f} (hf : IsColimit cc) (cc' : CokernelCofork f')\n    (Ï† : Arrow.mk f âŸ¶ Arrow.mk f') :\n    cc.Ï€ â‰« mapOfIsColimit hf cc' Ï† = Ï†.right â‰« cc'.Ï€ :=\n  hf.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.Ï€_mapOfIsColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\nhf : CategoryTheory.Limits.IsColimit cc\ncc' : CategoryTheory.Limits.CokernelCofork f'\nÏ† : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.Ï€ cc) (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' Ï†)) (CategoryTheory.CategoryStruct.comp Ï†.right (CategoryTheory.Limits.Cofork.Ï€ cc'))","decl":"@[reassoc (attr := simp)]\nlemma Ï€_mapOfIsColimit {cc : CokernelCofork f} (hf : IsColimit cc) (cc' : CokernelCofork f')\n    (Ï† : Arrow.mk f âŸ¶ Arrow.mk f') :\n    cc.Ï€ â‰« mapOfIsColimit hf cc' Ï† = Ï†.right â‰« cc'.Ï€ :=\n  hf.fac _ _\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\ncc' : CategoryTheory.Limits.CokernelCofork f'\nhf : CategoryTheory.Limits.IsColimit cc\nhf' : CategoryTheory.Limits.IsColimit cc'\nÏ† : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit hf hf' Ï†).inv (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf' cc Ï†.inv)","decl":"/-- The isomorphism between points of limit cokernel coforks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsColimit {cc : CokernelCofork f} {cc' : CokernelCofork f'}\n    (hf : IsColimit cc) (hf' : IsColimit cc')\n    (Ï† : Arrow.mk f â‰… Arrow.mk f') : cc.pt â‰… cc'.pt where\n  hom := mapOfIsColimit hf cc' Ï†.hom\n  inv := mapOfIsColimit hf' cc Ï†.inv\n  hom_inv_id := Cofork.IsColimit.hom_ext hf (by simp)\n  inv_hom_id := Cofork.IsColimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nX' Y' : C\nf' : Quiver.Hom X' Y'\ncc : CategoryTheory.Limits.CokernelCofork f\ncc' : CategoryTheory.Limits.CokernelCofork f'\nhf : CategoryTheory.Limits.IsColimit cc\nhf' : CategoryTheory.Limits.IsColimit cc'\nÏ† : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nâŠ¢ Eq (CategoryTheory.Limits.CokernelCofork.mapIsoOfIsColimit hf hf' Ï†).hom (CategoryTheory.Limits.CokernelCofork.mapOfIsColimit hf cc' Ï†.hom)","decl":"/-- The isomorphism between points of limit cokernel coforks induced by an isomorphism\nin the category of arrows. -/\n@[simps]\ndef mapIsoOfIsColimit {cc : CokernelCofork f} {cc' : CokernelCofork f'}\n    (hf : IsColimit cc) (hf' : IsColimit cc')\n    (Ï† : Arrow.mk f â‰… Arrow.mk f') : cc.pt â‰… cc'.pt where\n  hom := mapOfIsColimit hf cc' Ï†.hom\n  inv := mapOfIsColimit hf' cc Ï†.inv\n  hom_inv_id := Cofork.IsColimit.hom_ext hf (by simp)\n  inv_hom_id := Cofork.IsColimit.hom_ext hf' (by simp)\n\n"}
{"name":"CategoryTheory.Limits.coequalizer_as_cokernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nâŠ¢ Eq (CategoryTheory.Limits.coequalizer.Ï€ f 0) (CategoryTheory.Limits.cokernel.Ï€ f)","decl":"@[simp]\ntheorem coequalizer_as_cokernel : coequalizer.Ï€ f 0 = cokernel.Ï€ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cokernel.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.cokernel.Ï€ f)) 0","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.condition : f â‰« cokernel.Ï€ f = 0 :=\n  CokernelCofork.condition _\n\n"}
{"name":"CategoryTheory.Limits.cokernel.condition_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.condition : f â‰« cokernel.Ï€ f = 0 :=\n  CokernelCofork.condition _\n\n"}
{"name":"CategoryTheory.Limits.cokernel.Ï€_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nhâœ : Eq (CategoryTheory.CategoryStruct.comp f k) 0\nZ : C\nh : Quiver.Hom W Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f k hâœ) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.Ï€_desc {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) :\n    cokernel.Ï€ f â‰« cokernel.desc f k h = k :=\n  (cokernelIsCokernel f).fac (CokernelCofork.ofÏ€ k h) WalkingParallelPair.one\n\n-- Porting note: added to ease the port of `Abelian.Exact`\n"}
{"name":"CategoryTheory.Limits.cokernel.Ï€_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) (CategoryTheory.Limits.cokernel.desc f k h)) k","decl":"@[reassoc (attr := simp)]\ntheorem cokernel.Ï€_desc {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) :\n    cokernel.Ï€ f â‰« cokernel.desc f k h = k :=\n  (cokernelIsCokernel f).fac (CokernelCofork.ofÏ€ k h) WalkingParallelPair.one\n\n-- Porting note: added to ease the port of `Abelian.Exact`\n"}
{"name":"CategoryTheory.Limits.colimit_Î¹_zero_cokernel_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ninstâœ : CategoryTheory.Limits.HasCokernel f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.Limits.parallelPair f 0) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Limits.cokernel.desc f g h)) 0","decl":"@[reassoc (attr := simp)]\nlemma colimit_Î¹_zero_cokernel_desc {C : Type*} [Category C]\n    [HasZeroMorphisms C] {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (h : f â‰« g = 0) [HasCokernel f] :\n    colimit.Î¹ (parallelPair f 0) WalkingParallelPair.zero â‰« cokernel.desc f g h = 0 := by\n  rw [(colimit.w (parallelPair f 0) WalkingParallelPairHom.left).symm]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit_Î¹_zero_cokernel_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Zâœ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nhâœ : Eq (CategoryTheory.CategoryStruct.comp f g) 0\ninstâœ : CategoryTheory.Limits.HasCokernel f\nZ : C\nh : Quiver.Hom Zâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.Limits.parallelPair f 0) CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f g hâœ) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma colimit_Î¹_zero_cokernel_desc {C : Type*} [Category C]\n    [HasZeroMorphisms C] {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (h : f â‰« g = 0) [HasCokernel f] :\n    colimit.Î¹ (parallelPair f 0) WalkingParallelPair.zero â‰« cokernel.desc f g h = 0 := by\n  rw [(colimit.w (parallelPair f 0) WalkingParallelPairHom.left).symm]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.cokernel.desc_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nW : C\nh : Eq (CategoryTheory.CategoryStruct.comp f 0) 0\nâŠ¢ Eq (CategoryTheory.Limits.cokernel.desc f 0 h) 0","decl":"@[simp]\ntheorem cokernel.desc_zero {W : C} {h} : cokernel.desc f (0 : Y âŸ¶ W) h = 0 := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernel.desc_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\nW : C\nk : Quiver.Hom Y W\nh : Eq (CategoryTheory.CategoryStruct.comp f k) 0\ninstâœ : CategoryTheory.Epi k\nâŠ¢ CategoryTheory.Epi (CategoryTheory.Limits.cokernel.desc f k h)","decl":"instance cokernel.desc_epi {W : C} (k : Y âŸ¶ W) (h : f â‰« k = 0) [Epi k] :\n    Epi (cokernel.desc f k h) :=\n  âŸ¨fun {Z} g g' w => by\n    replace w := cokernel.Ï€ f â‰«= w\n    simp only [cokernel.Ï€_desc_assoc] at w\n    exact (cancel_epi k).1 wâŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernel.map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z X' Y' Z' : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ng : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f g) 0\nf' : Quiver.Hom X' Y'\ninstâœ : CategoryTheory.Limits.HasCokernel f'\ng' : Quiver.Hom Y' Z'\nw' : Eq (CategoryTheory.CategoryStruct.comp f' g') 0\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nr : Quiver.Hom Z Z'\nhâ‚ : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p f')\nhâ‚‚ : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.comp q g')\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map f f' p q hâ‚) (CategoryTheory.Limits.cokernel.desc f' g' w')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f g w) r)","decl":"/-- Given a commutative diagram\n    X --f--> Y --g--> Z\n    |        |        |\n    |        |        |\n    v        v        v\n    X' -f'-> Y' -g'-> Z'\nwith horizontal arrows composing to zero,\nthen we obtain a commutative square\n   cokernel f ---> Z\n   |               |\n   | cokernel.map  |\n   |               |\n   v               v\n   cokernel f' --> Z'\n-/\ntheorem cokernel.map_desc {X Y Z X' Y' Z' : C} (f : X âŸ¶ Y) [HasCokernel f] (g : Y âŸ¶ Z)\n    (w : f â‰« g = 0) (f' : X' âŸ¶ Y') [HasCokernel f'] (g' : Y' âŸ¶ Z') (w' : f' â‰« g' = 0) (p : X âŸ¶ X')\n    (q : Y âŸ¶ Y') (r : Z âŸ¶ Z') (hâ‚ : f â‰« q = p â‰« f') (hâ‚‚ : g â‰« r = q â‰« g') :\n    cokernel.map f f' p q hâ‚ â‰« cokernel.desc f' g' w' = cokernel.desc f g w â‰« r := by\n  ext; simp [hâ‚‚]\n\n"}
{"name":"CategoryTheory.Limits.cokernel.mapIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninstâœ : CategoryTheory.Limits.HasCokernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\nâŠ¢ Eq (CategoryTheory.Limits.cokernel.mapIso f f' p q w).hom (CategoryTheory.Limits.cokernel.map f f' p.hom q.hom w)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of cokernels. -/\n@[simps]\ndef cokernel.mapIso {X' Y' : C} (f' : X' âŸ¶ Y') [HasCokernel f'] (p : X â‰… X') (q : Y â‰… Y')\n    (w : f â‰« q.hom = p.hom â‰« f') : cokernel f â‰… cokernel f' where\n  hom := cokernel.map f f' p.hom q.hom w\n  inv := cokernel.map f' f p.inv q.inv (by\n          refine (cancel_mono q.hom).1 ?_\n          simp [w])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.mapIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\nX' Y' : C\nf' : Quiver.Hom X' Y'\ninstâœ : CategoryTheory.Limits.HasCokernel f'\np : CategoryTheory.Iso X X'\nq : CategoryTheory.Iso Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f q.hom) (CategoryTheory.CategoryStruct.comp p.hom f')\nâŠ¢ Eq (CategoryTheory.Limits.cokernel.mapIso f f' p q w).inv (CategoryTheory.Limits.cokernel.map f' f p.inv q.inv â‹¯)","decl":"/-- A commuting square of isomorphisms induces an isomorphism of cokernels. -/\n@[simps]\ndef cokernel.mapIso {X' Y' : C} (f' : X' âŸ¶ Y') [HasCokernel f'] (p : X â‰… X') (q : Y â‰… Y')\n    (w : f â‰« q.hom = p.hom â‰« f') : cokernel f â‰… cokernel f' where\n  hom := cokernel.map f f' p.hom q.hom w\n  inv := cokernel.map f' f p.inv q.inv (by\n          refine (cancel_mono q.hom).1 ?_\n          simp [w])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.Ï€_zero_isIso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.Ï€ 0)","decl":"/-- The cokernel of the zero morphism is an isomorphism -/\ninstance cokernel.Ï€_zero_isIso : IsIso (cokernel.Ï€ (0 : X âŸ¶ Y)) :=\n  coequalizer.Ï€_of_self _\n\n"}
{"name":"CategoryTheory.Limits.eq_zero_of_mono_cokernel","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Mono (CategoryTheory.Limits.cokernel.Ï€ f)\nâŠ¢ Eq f 0","decl":"theorem eq_zero_of_mono_cokernel [Mono (cokernel.Ï€ f)] : f = 0 :=\n  (cancel_mono (cokernel.Ï€ f)).1 (by simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernelZeroIsoTarget_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ Eq CategoryTheory.Limits.cokernelZeroIsoTarget.hom (CategoryTheory.Limits.cokernel.desc 0 (CategoryTheory.CategoryStruct.id Y) â‹¯)","decl":"@[simp]\ntheorem cokernelZeroIsoTarget_hom :\n    cokernelZeroIsoTarget.hom = cokernel.desc (0 : X âŸ¶ Y) (ğŸ™ Y) (by simp) := by\n  ext; simp [cokernelZeroIsoTarget]\n\n"}
{"name":"CategoryTheory.Limits.cokernelZeroIsoTarget_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ Eq CategoryTheory.Limits.cokernelZeroIsoTarget.inv (CategoryTheory.Limits.cokernel.Ï€ 0)","decl":"@[simp]\ntheorem cokernelZeroIsoTarget_inv : cokernelZeroIsoTarget.inv = cokernel.Ï€ (0 : X âŸ¶ Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_refl","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nh : Eq f f\nâŠ¢ Eq (CategoryTheory.Limits.cokernelIsoOfEq h) (CategoryTheory.Iso.refl (CategoryTheory.Limits.cokernel f))","decl":"@[simp]\ntheorem cokernelIsoOfEq_refl {h : f = f} : cokernelIsoOfEq h = Iso.refl (cokernel f) := by\n  ext; simp [cokernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelIsoOfEq_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) (CategoryTheory.Limits.cokernelIsoOfEq h).hom) (CategoryTheory.Limits.cokernel.Ï€ g)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelIsoOfEq_hom {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.Ï€ f â‰« (cokernelIsoOfEq h).hom = cokernel.Ï€ g := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelIsoOfEq_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nhâœ : Eq f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel g) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq hâœ).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ g) h)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelIsoOfEq_hom {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.Ï€ f â‰« (cokernelIsoOfEq h).hom = cokernel.Ï€ g := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelIsoOfEq_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ g) (CategoryTheory.Limits.cokernelIsoOfEq h).inv) (CategoryTheory.Limits.cokernel.Ï€ f)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelIsoOfEq_inv {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.Ï€ _ â‰« (cokernelIsoOfEq h).inv = cokernel.Ï€ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelIsoOfEq_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nhâœ : Eq f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.cokernel f) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq hâœ).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ f) h)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelIsoOfEq_inv {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g) :\n    cokernel.Ï€ _ â‰« (cokernelIsoOfEq h).inv = cokernel.Ï€ _ := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_hom_comp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\ne : Quiver.Hom Y Z\nhe : Eq (CategoryTheory.CategoryStruct.comp g e) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h).hom (CategoryTheory.Limits.cokernel.desc g e he)) (CategoryTheory.Limits.cokernel.desc f e â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_hom_comp_desc {Z} {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y âŸ¶ Z) (he) :\n    (cokernelIsoOfEq h).hom â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_hom_comp_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Zâœ : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nhâœ : Eq f g\ne : Quiver.Hom Y Zâœ\nhe : Eq (CategoryTheory.CategoryStruct.comp g e) 0\nZ : C\nh : Quiver.Hom Zâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq hâœ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc g e he) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f e â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_hom_comp_desc {Z} {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y âŸ¶ Z) (he) :\n    (cokernelIsoOfEq h).hom â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_inv_comp_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nh : Eq f g\ne : Quiver.Hom Y Z\nhe : Eq (CategoryTheory.CategoryStruct.comp f e) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq h).inv (CategoryTheory.Limits.cokernel.desc f e he)) (CategoryTheory.Limits.cokernel.desc g e â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_inv_comp_desc {Z} {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y âŸ¶ Z) (he) :\n    (cokernelIsoOfEq h).inv â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [â† h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_inv_comp_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Zâœ : C\nf g : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nhâœ : Eq f g\ne : Quiver.Hom Y Zâœ\nhe : Eq (CategoryTheory.CategoryStruct.comp f e) 0\nZ : C\nh : Quiver.Hom Zâœ Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelIsoOfEq hâœ).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc f e he) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc g e â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelIsoOfEq_inv_comp_desc {Z} {f g : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] (h : f = g)\n    (e : Y âŸ¶ Z) (he) :\n    (cokernelIsoOfEq h).inv â‰« cokernel.desc _ e he = cokernel.desc _ e (by simp [â† h, he]) := by\n  cases h; simp\n\n"}
{"name":"CategoryTheory.Limits.cokernelIsoOfEq_trans","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf g h : Quiver.Hom X Y\ninstâœÂ² : CategoryTheory.Limits.HasCokernel f\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel g\ninstâœ : CategoryTheory.Limits.HasCokernel h\nwâ‚ : Eq f g\nwâ‚‚ : Eq g h\nâŠ¢ Eq ((CategoryTheory.Limits.cokernelIsoOfEq wâ‚).trans (CategoryTheory.Limits.cokernelIsoOfEq wâ‚‚)) (CategoryTheory.Limits.cokernelIsoOfEq â‹¯)","decl":"@[simp]\ntheorem cokernelIsoOfEq_trans {f g h : X âŸ¶ Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n    (wâ‚ : f = g) (wâ‚‚ : g = h) :\n    cokernelIsoOfEq wâ‚ â‰ªâ‰« cokernelIsoOfEq wâ‚‚ = cokernelIsoOfEq (wâ‚.trans wâ‚‚) := by\n  cases wâ‚; cases wâ‚‚; ext; simp [cokernelIsoOfEq]\n\n"}
{"name":"CategoryTheory.Limits.cokernel_not_mono_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nw : Ne f 0\nâŠ¢ Not (CategoryTheory.Mono (CategoryTheory.Limits.cokernel.Ï€ f))","decl":"theorem cokernel_not_mono_of_nonzero (w : f â‰  0) : Â¬Mono (cokernel.Ï€ f) := fun _ =>\n  w (eq_zero_of_mono_cokernel f)\n\n"}
{"name":"CategoryTheory.Limits.cokernel_not_iso_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasCokernel f\nw : Ne f 0\naâœ : CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.Ï€ f)\nâŠ¢ False","decl":"theorem cokernel_not_iso_of_nonzero (w : f â‰  0) : IsIso (cokernel.Ï€ f) â†’ False := fun _ =>\n  cokernel_not_mono_of_nonzero w inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCokernel_comp_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.IsIso g\nâŠ¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.CategoryStruct.comp f g)","decl":"instance hasCokernel_comp_iso {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasCokernel f] [IsIso g] :\n    HasCokernel (f â‰« g) where\n  exists_colimit :=\n    âŸ¨{  cocone := CokernelCofork.ofÏ€ (inv g â‰« cokernel.Ï€ f) (by simp)\n        isColimit :=\n          isColimitAux _\n            (fun s =>\n              cokernel.desc _ (g â‰« s.Ï€) (by rw [â† Category.assoc, CokernelCofork.condition]))\n            (by simp) fun s m w => by\n            simp_rw [â† w]\n            symm\n            apply coequalizer.hom_ext\n            simp }âŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelCompIsIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.IsIso g\nâŠ¢ Eq (CategoryTheory.Limits.cokernelCompIsIso f g).inv (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.CategoryStruct.comp f g))) â‹¯)","decl":"/-- When `g` is an isomorphism, the cokernel of `f â‰« g` is isomorphic to the cokernel of `f`.\n-/\n@[simps]\ndef cokernelCompIsIso {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasCokernel f] [IsIso g] :\n    cokernel (f â‰« g) â‰… cokernel f where\n  hom := cokernel.desc _ (inv g â‰« cokernel.Ï€ f) (by simp)\n  inv := cokernel.desc _ (g â‰« cokernel.Ï€ (f â‰« g)) (by rw [â† Category.assoc, cokernel.condition])\n\n"}
{"name":"CategoryTheory.Limits.cokernelCompIsIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.IsIso g\nâŠ¢ Eq (CategoryTheory.Limits.cokernelCompIsIso f g).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv g) (CategoryTheory.Limits.cokernel.Ï€ f)) â‹¯)","decl":"/-- When `g` is an isomorphism, the cokernel of `f â‰« g` is isomorphic to the cokernel of `f`.\n-/\n@[simps]\ndef cokernelCompIsIso {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [HasCokernel f] [IsIso g] :\n    cokernel (f â‰« g) â‰… cokernel f where\n  hom := cokernel.desc _ (inv g â‰« cokernel.Ï€ f) (by simp)\n  inv := cokernel.desc _ (g â‰« cokernel.Ï€ (f â‰« g)) (by rw [â† Category.assoc, cokernel.condition])\n\n"}
{"name":"CategoryTheory.Limits.hasCokernel_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\nW : C\ng : Quiver.Hom W X\ninstâœ : CategoryTheory.Epi g\nâŠ¢ CategoryTheory.Limits.HasCokernel (CategoryTheory.CategoryStruct.comp g f)","decl":"instance hasCokernel_epi_comp {X Y : C} (f : X âŸ¶ Y) [HasCokernel f] {W} (g : W âŸ¶ X) [Epi g] :\n    HasCokernel (g â‰« f) :=\n  âŸ¨âŸ¨{   cocone := _\n        isColimit := isCokernelEpiComp (colimit.isColimit _) g rfl }âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Limits.cokernelEpiComp_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Epi f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nâŠ¢ Eq (CategoryTheory.Limits.cokernelEpiComp f g).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Limits.cokernel.Ï€ g) â‹¯)","decl":"/-- When `f` is an epimorphism, the cokernel of `f â‰« g` is isomorphic to the cokernel of `g`.\n-/\n@[simps]\ndef cokernelEpiComp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [Epi f] [HasCokernel g] :\n    cokernel (f â‰« g) â‰… cokernel g where\n  hom := cokernel.desc _ (cokernel.Ï€ g) (by simp)\n  inv :=\n    cokernel.desc _ (cokernel.Ï€ (f â‰« g))\n      (by\n        rw [â† cancel_epi f, â† Category.assoc]\n        simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernelEpiComp_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.Epi f\ninstâœ : CategoryTheory.Limits.HasCokernel g\nâŠ¢ Eq (CategoryTheory.Limits.cokernelEpiComp f g).inv (CategoryTheory.Limits.cokernel.desc g (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.CategoryStruct.comp f g)) â‹¯)","decl":"/-- When `f` is an epimorphism, the cokernel of `f â‰« g` is isomorphic to the cokernel of `g`.\n-/\n@[simps]\ndef cokernelEpiComp {X Y Z : C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [Epi f] [HasCokernel g] :\n    cokernel (f â‰« g) â‰… cokernel g where\n  hom := cokernel.desc _ (cokernel.Ï€ g) (by simp)\n  inv :=\n    cokernel.desc _ (cokernel.Ï€ (f â‰« g))\n      (by\n        rw [â† cancel_epi f, â† Category.assoc]\n        simp)\n\n"}
{"name":"CategoryTheory.Limits.cokernel.Ï€_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{v, u} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ² : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Epi f\nâŠ¢ Eq (CategoryTheory.Limits.cokernel.Ï€ f) 0","decl":"/-- The cokernel morphism of an epimorphism is a zero morphism -/\ntheorem cokernel.Ï€_of_epi [HasCokernel f] [Epi f] : cokernel.Ï€ f = 0 :=\n  zero_of_target_iso_zero _ (cokernel.ofEpi f)\n\n"}
{"name":"CategoryTheory.Limits.MonoFactorisation.kernel_Î¹_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.Limits.HasKernel f\nF : CategoryTheory.Limits.MonoFactorisation f\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ f) F.e) 0","decl":"@[simp]\ntheorem MonoFactorisation.kernel_Î¹_comp [HasKernel f] (F : MonoFactorisation f) :\n    kernel.Î¹ f â‰« F.e = 0 := by\n  rw [â† cancel_mono F.m, zero_comp, Category.assoc, F.fac, kernel.condition]\n\n"}
{"name":"CategoryTheory.Limits.cokernelImageÎ¹_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasImage f\ninstâœÂ² : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.image.Î¹ f)\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\nâŠ¢ Eq (CategoryTheory.Limits.cokernelImageÎ¹ f).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.Limits.image.Î¹ f) (CategoryTheory.Limits.cokernel.Ï€ f) â‹¯)","decl":"/-- The cokernel of the image inclusion of a morphism `f` is isomorphic to the cokernel of `f`.\n\n(This result requires that the factorisation through the image is an epimorphism.\nThis holds in any category with equalizers.)\n-/\n@[simps]\ndef cokernelImageÎ¹ {X Y : C} (f : X âŸ¶ Y) [HasImage f] [HasCokernel (image.Î¹ f)] [HasCokernel f]\n    [Epi (factorThruImage f)] : cokernel (image.Î¹ f) â‰… cokernel f where\n  hom :=\n    cokernel.desc _ (cokernel.Ï€ f)\n      (by\n        have w := cokernel.condition f\n        conv at w =>\n          lhs\n          congr\n          rw [â† image.fac f]\n        rw [â† HasZeroMorphisms.comp_zero (Limits.factorThruImage f), Category.assoc,\n          cancel_epi] at w\n        exact w)\n  inv :=\n    cokernel.desc _ (cokernel.Ï€ _)\n      (by\n        conv =>\n          lhs\n          congr\n          rw [â† image.fac f]\n        rw [Category.assoc, cokernel.condition, HasZeroMorphisms.comp_zero])\n\n"}
{"name":"CategoryTheory.Limits.cokernelImageÎ¹_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasImage f\ninstâœÂ² : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.image.Î¹ f)\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\nâŠ¢ Eq (CategoryTheory.Limits.cokernelImageÎ¹ f).inv (CategoryTheory.Limits.cokernel.desc f (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.Limits.image.Î¹ f)) â‹¯)","decl":"/-- The cokernel of the image inclusion of a morphism `f` is isomorphic to the cokernel of `f`.\n\n(This result requires that the factorisation through the image is an epimorphism.\nThis holds in any category with equalizers.)\n-/\n@[simps]\ndef cokernelImageÎ¹ {X Y : C} (f : X âŸ¶ Y) [HasImage f] [HasCokernel (image.Î¹ f)] [HasCokernel f]\n    [Epi (factorThruImage f)] : cokernel (image.Î¹ f) â‰… cokernel f where\n  hom :=\n    cokernel.desc _ (cokernel.Ï€ f)\n      (by\n        have w := cokernel.condition f\n        conv at w =>\n          lhs\n          congr\n          rw [â† image.fac f]\n        rw [â† HasZeroMorphisms.comp_zero (Limits.factorThruImage f), Category.assoc,\n          cancel_epi] at w\n        exact w)\n  inv :=\n    cokernel.desc _ (cokernel.Ï€ _)\n      (by\n        conv =>\n          lhs\n          congr\n          rw [â† image.fac f]\n        rw [Category.assoc, cokernel.condition, HasZeroMorphisms.comp_zero])\n\n"}
{"name":"CategoryTheory.Limits.cokernel.Ï€_of_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.Ï€ 0)","decl":"/-- The cokernel of a zero morphism is an isomorphism -/\ntheorem cokernel.Ï€_of_zero : IsIso (cokernel.Ï€ (0 : X âŸ¶ Y)) :=\n  coequalizer.Ï€_of_self _\n\n"}
{"name":"CategoryTheory.Limits.kernel.of_cokernel_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.Limits.HasCokernel f\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel (CategoryTheory.Limits.cokernel.Ï€ f)\ninstâœ : CategoryTheory.Epi f\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.kernel.Î¹ (CategoryTheory.Limits.cokernel.Ï€ f))","decl":"/-- The kernel of the cokernel of an epimorphism is an isomorphism -/\ninstance kernel.of_cokernel_of_epi [HasCokernel f] [HasKernel (cokernel.Ï€ f)] [Epi f] :\n    IsIso (kernel.Î¹ (cokernel.Ï€ f)) :=\n  equalizer.Î¹_of_eq <| cokernel.Ï€_of_epi f\n\n"}
{"name":"CategoryTheory.Limits.cokernel.of_kernel_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâµ : CategoryTheory.Category.{v, u} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninstâœÂ³ : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ² : CategoryTheory.Limits.HasKernel f\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel (CategoryTheory.Limits.kernel.Î¹ f)\ninstâœ : CategoryTheory.Mono f\nâŠ¢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernel.Ï€ (CategoryTheory.Limits.kernel.Î¹ f))","decl":"/-- The cokernel of the kernel of a monomorphism is an isomorphism -/\ninstance cokernel.of_kernel_of_mono [HasKernel f] [HasCokernel (kernel.Î¹ f)] [Mono f] :\n    IsIso (cokernel.Ï€ (kernel.Î¹ f)) :=\n  coequalizer.Ï€_of_eq <| kernel.Î¹_of_mono f\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_Î¹","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel (G.map f)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.Limits.kernel.Î¹ (G.map f))) (G.map (CategoryTheory.Limits.kernel.Î¹ f))","decl":"@[reassoc (attr := simp)]\ntheorem kernelComparison_comp_Î¹ [HasKernel f] [HasKernel (G.map f)] :\n    kernelComparison f G â‰« kernel.Î¹ (G.map f) = G.map (kernel.Î¹ f) :=\n  kernel.lift_Î¹ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_Î¹_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel (G.map f)\nZ : D\nh : Quiver.Hom (G.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.Î¹ (G.map f)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.Î¹ f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem kernelComparison_comp_Î¹ [HasKernel f] [HasKernel (G.map f)] :\n    kernelComparison f G â‰« kernel.Î¹ (G.map f) = G.map (kernel.Î¹ f) :=\n  kernel.lift_Î¹ _ _ _\n\n"}
{"name":"CategoryTheory.Limits.map_lift_kernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel (G.map f)\nZâœ : C\nhâœ : Quiver.Hom Zâœ X\nw : Eq (CategoryTheory.CategoryStruct.comp hâœ f) 0\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.kernel (G.map f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.lift f hâœ w)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.lift (G.map f) (G.map hâœ) â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_kernelComparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : Z âŸ¶ X}\n    (w : h â‰« f = 0) :\n    G.map (kernel.lift _ h w) â‰« kernelComparison f G =\n      kernel.lift _ (G.map h) (by simp only [â† G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [â† G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.map_lift_kernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel f\ninstâœ : CategoryTheory.Limits.HasKernel (G.map f)\nZ : C\nh : Quiver.Hom Z X\nw : Eq (CategoryTheory.CategoryStruct.comp h f) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.lift f h w)) (CategoryTheory.Limits.kernelComparison f G)) (CategoryTheory.Limits.kernel.lift (G.map f) (G.map h) â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem map_lift_kernelComparison [HasKernel f] [HasKernel (G.map f)] {Z : C} {h : Z âŸ¶ X}\n    (w : h â‰« f = 0) :\n    G.map (kernel.lift _ h w) â‰« kernelComparison f G =\n      kernel.lift _ (G.map h) (by simp only [â† G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [â† G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_kernel_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœâ´ : G.PreservesZeroMorphisms\nX' Y' : C\ninstâœÂ³ : CategoryTheory.Limits.HasKernel f\ninstâœÂ² : CategoryTheory.Limits.HasKernel (G.map f)\ng : Quiver.Hom X' Y'\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel g\ninstâœ : CategoryTheory.Limits.HasKernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) â‹¯)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)) (CategoryTheory.Limits.kernelComparison g G))","decl":"@[reassoc]\ntheorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]\n    (g : X' âŸ¶ Y') [HasKernel g] [HasKernel (G.map g)] (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (hpq : f â‰« q = p â‰« g) :\n    kernelComparison f G â‰«\n        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [â† G.map_comp, hpq, G.map_comp]) =\n      G.map (kernel.map f g p q hpq) â‰« kernelComparison g G :=\n  kernel.lift_map _ _ (by rw [â† G.map_comp, kernel.condition, G.map_zero]) _ _\n    (by rw [â† G.map_comp, kernel.condition, G.map_zero]) _ _ _\n    (by simp only [â† G.map_comp]; exact G.congr_map (kernel.lift_Î¹ _ _ _).symm) _\n\n"}
{"name":"CategoryTheory.Limits.kernelComparison_comp_kernel_map_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœâ´ : G.PreservesZeroMorphisms\nX' Y' : C\ninstâœÂ³ : CategoryTheory.Limits.HasKernel f\ninstâœÂ² : CategoryTheory.Limits.HasKernel (G.map f)\ng : Quiver.Hom X' Y'\ninstâœÂ¹ : CategoryTheory.Limits.HasKernel g\ninstâœ : CategoryTheory.Limits.HasKernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.kernel (G.map g)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison f G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) â‹¯) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernelComparison g G) h))","decl":"@[reassoc]\ntheorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]\n    (g : X' âŸ¶ Y') [HasKernel g] [HasKernel (G.map g)] (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (hpq : f â‰« q = p â‰« g) :\n    kernelComparison f G â‰«\n        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [â† G.map_comp, hpq, G.map_comp]) =\n      G.map (kernel.map f g p q hpq) â‰« kernelComparison g G :=\n  kernel.lift_map _ _ (by rw [â† G.map_comp, kernel.condition, G.map_zero]) _ _\n    (by rw [â† G.map_comp, kernel.condition, G.map_zero]) _ _ _\n    (by simp only [â† G.map_comp]; exact G.congr_map (kernel.lift_Î¹ _ _ _).symm) _\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map f)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ (G.map f)) (CategoryTheory.Limits.cokernelComparison f G)) (G.map (CategoryTheory.Limits.cokernel.Ï€ f))","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel.Ï€ (G.map f) â‰« cokernelComparison f G = G.map (cokernel.Ï€ _) :=\n  cokernel.Ï€_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.Ï€_comp_cokernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map f)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.cokernel f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.Ï€ (G.map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.Ï€ f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Ï€_comp_cokernelComparison [HasCokernel f] [HasCokernel (G.map f)] :\n    cokernel.Ï€ (G.map f) â‰« cokernelComparison f G = G.map (cokernel.Ï€ _) :=\n  cokernel.Ï€_desc _ _ _\n\n"}
{"name":"CategoryTheory.Limits.cokernelComparison_map_desc_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map f)\nZâœ : C\nhâœ : Quiver.Hom Y Zâœ\nw : Eq (CategoryTheory.CategoryStruct.comp f hâœ) 0\nZ : D\nh : Quiver.Hom (G.obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.desc f hâœ w)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.desc (G.map f) (G.map hâœ) â‹¯) h)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelComparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : Y âŸ¶ Z}\n    (w : f â‰« h = 0) :\n    cokernelComparison f G â‰« G.map (cokernel.desc _ h w) =\n      cokernel.desc _ (G.map h) (by simp only [â† G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [â† G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.cokernelComparison_map_desc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœÂ² : G.PreservesZeroMorphisms\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel f\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map f)\nZ : C\nh : Quiver.Hom Y Z\nw : Eq (CategoryTheory.CategoryStruct.comp f h) 0\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (G.map (CategoryTheory.Limits.cokernel.desc f h w))) (CategoryTheory.Limits.cokernel.desc (G.map f) (G.map h) â‹¯)","decl":"@[reassoc (attr := simp)]\ntheorem cokernelComparison_map_desc [HasCokernel f] [HasCokernel (G.map f)] {Z : C} {h : Y âŸ¶ Z}\n    (w : f â‰« h = 0) :\n    cokernelComparison f G â‰« G.map (cokernel.desc _ h w) =\n      cokernel.desc _ (G.map h) (by simp only [â† G.map_comp, w, Functor.map_zero]) := by\n  ext; simp [â† G.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.cokernel_map_comp_cokernelComparison","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœâ´ : G.PreservesZeroMorphisms\nX' Y' : C\ninstâœÂ³ : CategoryTheory.Limits.HasCokernel f\ninstâœÂ² : CategoryTheory.Limits.HasCokernel (G.map f)\ng : Quiver.Hom X' Y'\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel g\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) â‹¯) (CategoryTheory.Limits.cokernelComparison g G)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)))","decl":"@[reassoc]\ntheorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]\n    (g : X' âŸ¶ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (hpq : f â‰« q = p â‰« g) :\n    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [â† G.map_comp, hpq, G.map_comp]) â‰«\n        cokernelComparison _ G =\n      cokernelComparison _ G â‰« G.map (cokernel.map f g p q hpq) :=\n  cokernel.map_desc _ _ (by rw [â† G.map_comp, cokernel.condition, G.map_zero]) _ _\n    (by rw [â† G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _\n    (by simp only [â† G.map_comp]; exact G.congr_map (cokernel.Ï€_desc _ _ _))\n\n"}
{"name":"CategoryTheory.Limits.cokernel_map_comp_cokernelComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœâ¸ : CategoryTheory.Category.{v, u} C\ninstâœâ· : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nD : Type uâ‚‚\ninstâœâ¶ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\ninstâœâµ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninstâœâ´ : G.PreservesZeroMorphisms\nX' Y' : C\ninstâœÂ³ : CategoryTheory.Limits.HasCokernel f\ninstâœÂ² : CategoryTheory.Limits.HasCokernel (G.map f)\ng : Quiver.Hom X' Y'\ninstâœÂ¹ : CategoryTheory.Limits.HasCokernel g\ninstâœ : CategoryTheory.Limits.HasCokernel (G.map g)\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.cokernel g)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) â‹¯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison g G) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernelComparison f G) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)) h))","decl":"@[reassoc]\ntheorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]\n    (g : X' âŸ¶ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X âŸ¶ X') (q : Y âŸ¶ Y')\n    (hpq : f â‰« q = p â‰« g) :\n    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [â† G.map_comp, hpq, G.map_comp]) â‰«\n        cokernelComparison _ G =\n      cokernelComparison _ G â‰« G.map (cokernel.map f g p q hpq) :=\n  cokernel.map_desc _ _ (by rw [â† G.map_comp, cokernel.condition, G.map_zero]) _ _\n    (by rw [â† G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _\n    (by simp only [â† G.map_comp]; exact G.congr_map (cokernel.Ï€_desc _ _ _))\n\n"}
{"name":"CategoryTheory.Limits.HasKernels.has_limit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasKernels C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.Limits.HasKernel f","decl":"/-- `HasKernels` represents the existence of kernels for every morphism. -/\nclass HasKernels : Prop where\n  has_limit : âˆ€ {X Y : C} (f : X âŸ¶ Y), HasKernel f := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasCokernels.has_colimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ CategoryTheory.Limits.HasCokernel f","decl":"/-- `HasCokernels` represents the existence of cokernels for every morphism. -/\nclass HasCokernels : Prop where\n  has_colimit : âˆ€ {X Y : C} (f : X âŸ¶ Y), HasCokernel f := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasKernels_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasEqualizers C\nâŠ¢ CategoryTheory.Limits.HasKernels C","decl":"instance (priority := 100) hasKernels_of_hasEqualizers [HasEqualizers C] : HasKernels C where\n\n"}
{"name":"CategoryTheory.Limits.hasCokernels_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Kernels","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nâŠ¢ CategoryTheory.Limits.HasCokernels C","decl":"instance (priority := 100) hasCokernels_of_hasCoequalizers [HasCoequalizers C] :\n    HasCokernels C where\n\n"}
