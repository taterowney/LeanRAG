{"name":"CategoryTheory.extendFan_π_app","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) → C\nc₁ : CategoryTheory.Limits.Fan fun i => f i.succ\nc₂ : CategoryTheory.Limits.BinaryFan (f 0) c₁.pt\nX : CategoryTheory.Discrete (Fin (HAdd.hAdd n 1))\n⊢ Eq ((CategoryTheory.extendFan c₁ c₂).π.app X) (Fin.cases c₂.fst (fun i => CategoryTheory.CategoryStruct.comp c₂.snd (c₁.π.app { as := i })) X.as)","decl":"/--\nGiven `n+1` objects of `C`, a fan for the last `n` with point `c₁.pt` and\na binary fan on `c₁.pt` and `f 0`, we can build a fan for all `n+1`.\n\nIn `extendFanIsLimit` we show that if the two given fans are limits, then this fan is also a\nlimit.\n-/\n@[simps!] -- Porting note: removed semi-reducible config\ndef extendFan {n : ℕ} {f : Fin (n + 1) → C} (c₁ : Fan fun i : Fin n => f i.succ)\n    (c₂ : BinaryFan (f 0) c₁.pt) : Fan f :=\n  Fan.mk c₂.pt\n    (by\n      refine Fin.cases ?_ ?_\n      · apply c₂.fst\n      · intro i\n        apply c₂.snd ≫ c₁.π.app ⟨i⟩)\n\n"}
{"name":"CategoryTheory.extendFan_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) → C\nc₁ : CategoryTheory.Limits.Fan fun i => f i.succ\nc₂ : CategoryTheory.Limits.BinaryFan (f 0) c₁.pt\n⊢ Eq (CategoryTheory.extendFan c₁ c₂).pt c₂.pt","decl":"/--\nGiven `n+1` objects of `C`, a fan for the last `n` with point `c₁.pt` and\na binary fan on `c₁.pt` and `f 0`, we can build a fan for all `n+1`.\n\nIn `extendFanIsLimit` we show that if the two given fans are limits, then this fan is also a\nlimit.\n-/\n@[simps!] -- Porting note: removed semi-reducible config\ndef extendFan {n : ℕ} {f : Fin (n + 1) → C} (c₁ : Fan fun i : Fin n => f i.succ)\n    (c₂ : BinaryFan (f 0) c₁.pt) : Fan f :=\n  Fan.mk c₂.pt\n    (by\n      refine Fin.cases ?_ ?_\n      · apply c₂.fst\n      · intro i\n        apply c₂.snd ≫ c₁.π.app ⟨i⟩)\n\n"}
{"name":"CategoryTheory.hasFiniteProducts_of_has_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProducts C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem hasFiniteProducts_of_has_binary_and_terminal : HasFiniteProducts C :=\n  ⟨fun n => ⟨fun K =>\n    let this := hasProduct_fin n fun n => K.obj ⟨n⟩\n    let that : (Discrete.functor fun n => K.obj ⟨n⟩) ≅ K := Discrete.natIso fun ⟨_⟩ => Iso.refl _\n    @hasLimitOfIso _ _ _ _ _ _ this that⟩⟩\n\n\n"}
{"name":"CategoryTheory.preservesFinOfPreservesBinaryAndTerminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nn : Nat\nf : Fin n → C\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F","decl":"/-- If `F` preserves the terminal object and binary products, then it preserves products indexed by\n`Fin n` for any `n`.\n-/\nlemma preservesFinOfPreservesBinaryAndTerminal :\n    ∀ (n : ℕ) (f : Fin n → C), PreservesLimit (Discrete.functor f) F\n  | 0 => fun f => by\n    letI : PreservesLimitsOfShape (Discrete (Fin 0)) F :=\n      preservesLimitsOfShape_of_equiv.{0, 0} (Discrete.equivalence finZeroEquiv'.symm) _\n    infer_instance\n  | n + 1 => by\n    haveI := preservesFinOfPreservesBinaryAndTerminal n\n    intro f\n    apply\n      preservesLimit_of_preserves_limit_cone\n        (extendFanIsLimit f (limit.isLimit _) (limit.isLimit _)) _\n    apply (isLimitMapConeFanMkEquiv _ _ _).symm _\n    let this :=\n      extendFanIsLimit (fun i => F.obj (f i)) (isLimitOfHasProductOfPreservesLimit F _)\n        (isLimitOfHasBinaryProductOfPreservesLimit F _ _)\n    refine IsLimit.ofIsoLimit this ?_\n    apply Cones.ext _ _\n    · apply Iso.refl _\n    rintro ⟨j⟩\n    refine Fin.inductionOn j ?_ ?_\n    · apply (Category.id_comp _).symm\n    · rintro i _\n      dsimp [extendFan_π_app, Iso.refl_hom, Fan.mk_π_app]\n      change F.map _ ≫ _ = 𝟙 _ ≫ _\n      simp only [id_comp, ← F.map_comp]\n      rfl\n\n"}
{"name":"CategoryTheory.preservesShape_fin_of_preserves_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\nn : Nat\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete (Fin n)) F","decl":"/-- If `F` preserves the terminal object and binary products, then it preserves limits of shape\n`Discrete (Fin n)`.\n-/\nlemma preservesShape_fin_of_preserves_binary_and_terminal (n : ℕ) :\n    PreservesLimitsOfShape (Discrete (Fin n)) F where\n  preservesLimit {K} := by\n    let that : (Discrete.functor fun n => K.obj ⟨n⟩) ≅ K := Discrete.natIso fun ⟨i⟩ => Iso.refl _\n    haveI := preservesFinOfPreservesBinaryAndTerminal F n fun n => K.obj ⟨n⟩\n    apply preservesLimit_of_iso_diagram F that\n\n"}
{"name":"CategoryTheory.preservesFiniteProducts_of_preserves_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝² : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\nJ : Type u_1\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the terminal object and binary products then it preserves finite products. -/\nlemma preservesFiniteProducts_of_preserves_binary_and_terminal (J : Type*) [Fintype J] :\n    PreservesLimitsOfShape (Discrete J) F := by\n  classical\n    let e := Fintype.equivFin J\n    haveI := preservesShape_fin_of_preserves_binary_and_terminal F (Fintype.card J)\n    apply preservesLimitsOfShape_of_equiv (Discrete.equivalence e).symm\n\n"}
{"name":"CategoryTheory.extendCofan_ι_app","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) → C\nc₁ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc₂ : CategoryTheory.Limits.BinaryCofan (f 0) c₁.pt\nX : CategoryTheory.Discrete (Fin (HAdd.hAdd n 1))\n⊢ Eq ((CategoryTheory.extendCofan c₁ c₂).ι.app X) (Fin.cases c₂.inl (fun i => CategoryTheory.CategoryStruct.comp (c₁.ι.app { as := i }) c₂.inr) X.as)","decl":"/-- Given `n+1` objects of `C`, a cofan for the last `n` with point `c₁.pt`\nand a binary cofan on `c₁.X` and `f 0`, we can build a cofan for all `n+1`.\n\nIn `extendCofanIsColimit` we show that if the two given cofans are colimits,\nthen this cofan is also a colimit.\n-/\n\n@[simps!] -- Porting note: removed semireducible config\ndef extendCofan {n : ℕ} {f : Fin (n + 1) → C} (c₁ : Cofan fun i : Fin n => f i.succ)\n    (c₂ : BinaryCofan (f 0) c₁.pt) : Cofan f :=\n  Cofan.mk c₂.pt\n    (by\n      refine Fin.cases ?_ ?_\n      · apply c₂.inl\n      · intro i\n        apply c₁.ι.app ⟨i⟩ ≫ c₂.inr)\n\n"}
{"name":"CategoryTheory.extendCofan_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) → C\nc₁ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc₂ : CategoryTheory.Limits.BinaryCofan (f 0) c₁.pt\n⊢ Eq (CategoryTheory.extendCofan c₁ c₂).pt c₂.pt","decl":"/-- Given `n+1` objects of `C`, a cofan for the last `n` with point `c₁.pt`\nand a binary cofan on `c₁.X` and `f 0`, we can build a cofan for all `n+1`.\n\nIn `extendCofanIsColimit` we show that if the two given cofans are colimits,\nthen this cofan is also a colimit.\n-/\n\n@[simps!] -- Porting note: removed semireducible config\ndef extendCofan {n : ℕ} {f : Fin (n + 1) → C} (c₁ : Cofan fun i : Fin n => f i.succ)\n    (c₂ : BinaryCofan (f 0) c₁.pt) : Cofan f :=\n  Cofan.mk c₂.pt\n    (by\n      refine Fin.cases ?_ ?_\n      · apply c₂.inl\n      · intro i\n        apply c₁.ι.app ⟨i⟩ ≫ c₂.inr)\n\n"}
{"name":"CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasBinaryCoproducts C\ninst✝ : CategoryTheory.Limits.HasInitial C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem hasFiniteCoproducts_of_has_binary_and_initial : HasFiniteCoproducts C :=\n  ⟨fun n => ⟨fun K =>\n    letI := hasCoproduct_fin n fun n => K.obj ⟨n⟩\n    let that : K ≅ Discrete.functor fun n => K.obj ⟨n⟩ := Discrete.natIso fun ⟨_⟩ => Iso.refl _\n    @hasColimitOfIso _ _ _ _ _ _ this that⟩⟩\n\n"}
{"name":"CategoryTheory.preserves_fin_of_preserves_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nn : Nat\nf : Fin n → C\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F","decl":"/-- If `F` preserves the initial object and binary coproducts, then it preserves products indexed by\n`Fin n` for any `n`.\n-/\nlemma preserves_fin_of_preserves_binary_and_initial :\n    ∀ (n : ℕ) (f : Fin n → C), PreservesColimit (Discrete.functor f) F\n  | 0 => fun f => by\n    letI : PreservesColimitsOfShape (Discrete (Fin 0)) F :=\n      preservesColimitsOfShape_of_equiv.{0, 0} (Discrete.equivalence finZeroEquiv'.symm) _\n    infer_instance\n  | n + 1 => by\n    haveI := preserves_fin_of_preserves_binary_and_initial n\n    intro f\n    apply\n      preservesColimit_of_preserves_colimit_cocone\n        (extendCofanIsColimit f (colimit.isColimit _) (colimit.isColimit _)) _\n    apply (isColimitMapCoconeCofanMkEquiv _ _ _).symm _\n    let this :=\n      extendCofanIsColimit (fun i => F.obj (f i))\n        (isColimitOfHasCoproductOfPreservesColimit F _)\n        (isColimitOfHasBinaryCoproductOfPreservesColimit F _ _)\n    refine IsColimit.ofIsoColimit this ?_\n    apply Cocones.ext _ _\n    · apply Iso.refl _\n    rintro ⟨j⟩\n    refine Fin.inductionOn j ?_ ?_\n    · apply Category.comp_id\n    · rintro i _\n      dsimp [extendCofan_ι_app, Iso.refl_hom, Cofan.mk_ι_app]\n      rw [comp_id, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.preservesShape_fin_of_preserves_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝ : CategoryTheory.Limits.HasFiniteCoproducts C\nn : Nat\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete (Fin n)) F","decl":"/-- If `F` preserves the initial object and binary coproducts, then it preserves colimits of shape\n`Discrete (Fin n)`.\n-/\nlemma preservesShape_fin_of_preserves_binary_and_initial (n : ℕ) :\n    PreservesColimitsOfShape (Discrete (Fin n)) F where\n  preservesColimit {K} := by\n    let that : (Discrete.functor fun n => K.obj ⟨n⟩) ≅ K := Discrete.natIso fun ⟨i⟩ => Iso.refl _\n    haveI := preserves_fin_of_preserves_binary_and_initial F n fun n => K.obj ⟨n⟩\n    apply preservesColimit_of_iso_diagram F that\n\n"}
{"name":"CategoryTheory.preservesFiniteCoproductsOfPreservesBinaryAndInitial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝² : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\nJ : Type u_1\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the initial object and binary coproducts then it preserves finite products. -/\nlemma preservesFiniteCoproductsOfPreservesBinaryAndInitial (J : Type*) [Fintype J] :\n    PreservesColimitsOfShape (Discrete J) F := by\n  classical\n    let e := Fintype.equivFin J\n    haveI := preservesShape_fin_of_preserves_binary_and_initial F (Fintype.card J)\n    apply preservesColimitsOfShape_of_equiv (Discrete.equivalence e).symm\n\n"}
