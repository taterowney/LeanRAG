{"name":"CategoryTheory.extendFan_œÄ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Fan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryFan (f 0) c‚ÇÅ.pt\nX : CategoryTheory.Discrete (Fin (HAdd.hAdd n 1))\n‚ä¢ Eq ((CategoryTheory.extendFan c‚ÇÅ c‚ÇÇ).œÄ.app X) (Fin.cases c‚ÇÇ.fst (fun i => CategoryTheory.CategoryStruct.comp c‚ÇÇ.snd (c‚ÇÅ.œÄ.app { as := i })) X.as)","decl":"/--\nGiven `n+1` objects of `C`, a fan for the last `n` with point `c‚ÇÅ.pt` and\na binary fan on `c‚ÇÅ.pt` and `f 0`, we can build a fan for all `n+1`.\n\nIn `extendFanIsLimit` we show that if the two given fans are limits, then this fan is also a\nlimit.\n-/\n@[simps!] -- Porting note: removed semi-reducible config\ndef extendFan {n : ‚Ñï} {f : Fin (n + 1) ‚Üí C} (c‚ÇÅ : Fan fun i : Fin n => f i.succ)\n    (c‚ÇÇ : BinaryFan (f 0) c‚ÇÅ.pt) : Fan f :=\n  Fan.mk c‚ÇÇ.pt\n    (by\n      refine Fin.cases ?_ ?_\n      ¬∑ apply c‚ÇÇ.fst\n      ¬∑ intro i\n        apply c‚ÇÇ.snd ‚â´ c‚ÇÅ.œÄ.app ‚ü®i‚ü©)\n\n"}
{"name":"CategoryTheory.extendFan_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Fan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryFan (f 0) c‚ÇÅ.pt\n‚ä¢ Eq (CategoryTheory.extendFan c‚ÇÅ c‚ÇÇ).pt c‚ÇÇ.pt","decl":"/--\nGiven `n+1` objects of `C`, a fan for the last `n` with point `c‚ÇÅ.pt` and\na binary fan on `c‚ÇÅ.pt` and `f 0`, we can build a fan for all `n+1`.\n\nIn `extendFanIsLimit` we show that if the two given fans are limits, then this fan is also a\nlimit.\n-/\n@[simps!] -- Porting note: removed semi-reducible config\ndef extendFan {n : ‚Ñï} {f : Fin (n + 1) ‚Üí C} (c‚ÇÅ : Fan fun i : Fin n => f i.succ)\n    (c‚ÇÇ : BinaryFan (f 0) c‚ÇÅ.pt) : Fan f :=\n  Fan.mk c‚ÇÇ.pt\n    (by\n      refine Fin.cases ?_ ?_\n      ¬∑ apply c‚ÇÇ.fst\n      ¬∑ intro i\n        apply c‚ÇÇ.snd ‚â´ c‚ÇÅ.œÄ.app ‚ü®i‚ü©)\n\n"}
{"name":"CategoryTheory.hasFiniteProducts_of_has_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryProducts C\ninst‚úù : CategoryTheory.Limits.HasTerminal C\n‚ä¢ CategoryTheory.Limits.HasFiniteProducts C","decl":"/-- If `C` has a terminal object and binary products, then it has finite products. -/\ntheorem hasFiniteProducts_of_has_binary_and_terminal : HasFiniteProducts C :=\n  ‚ü®fun n => ‚ü®fun K =>\n    let this := hasProduct_fin n fun n => K.obj ‚ü®n‚ü©\n    let that : (Discrete.functor fun n => K.obj ‚ü®n‚ü©) ‚âÖ K := Discrete.natIso fun ‚ü®_‚ü© => Iso.refl _\n    @hasLimitOfIso _ _ _ _ _ _ this that‚ü©‚ü©\n\n\n"}
{"name":"CategoryTheory.preservesFinOfPreservesBinaryAndTerminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\nn : Nat\nf : Fin n ‚Üí C\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) F","decl":"/-- If `F` preserves the terminal object and binary products, then it preserves products indexed by\n`Fin n` for any `n`.\n-/\nlemma preservesFinOfPreservesBinaryAndTerminal :\n    ‚àÄ (n : ‚Ñï) (f : Fin n ‚Üí C), PreservesLimit (Discrete.functor f) F\n  | 0 => fun f => by\n    letI : PreservesLimitsOfShape (Discrete (Fin 0)) F :=\n      preservesLimitsOfShape_of_equiv.{0, 0} (Discrete.equivalence finZeroEquiv'.symm) _\n    infer_instance\n  | n + 1 => by\n    haveI := preservesFinOfPreservesBinaryAndTerminal n\n    intro f\n    apply\n      preservesLimit_of_preserves_limit_cone\n        (extendFanIsLimit f (limit.isLimit _) (limit.isLimit _)) _\n    apply (isLimitMapConeFanMkEquiv _ _ _).symm _\n    let this :=\n      extendFanIsLimit (fun i => F.obj (f i)) (isLimitOfHasProductOfPreservesLimit F _)\n        (isLimitOfHasBinaryProductOfPreservesLimit F _ _)\n    refine IsLimit.ofIsoLimit this ?_\n    apply Cones.ext _ _\n    ¬∑ apply Iso.refl _\n    rintro ‚ü®j‚ü©\n    refine Fin.inductionOn j ?_ ?_\n    ¬∑ apply (Category.id_comp _).symm\n    ¬∑ rintro i _\n      dsimp [extendFan_œÄ_app, Iso.refl_hom, Fan.mk_œÄ_app]\n      change F.map _ ‚â´ _ = ùüô _ ‚â´ _\n      simp only [id_comp, ‚Üê F.map_comp]\n      rfl\n\n"}
{"name":"CategoryTheory.preservesShape_fin_of_preserves_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\nn : Nat\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete (Fin n)) F","decl":"/-- If `F` preserves the terminal object and binary products, then it preserves limits of shape\n`Discrete (Fin n)`.\n-/\nlemma preservesShape_fin_of_preserves_binary_and_terminal (n : ‚Ñï) :\n    PreservesLimitsOfShape (Discrete (Fin n)) F where\n  preservesLimit {K} := by\n    let that : (Discrete.functor fun n => K.obj ‚ü®n‚ü©) ‚âÖ K := Discrete.natIso fun ‚ü®i‚ü© => Iso.refl _\n    haveI := preservesFinOfPreservesBinaryAndTerminal F n fun n => K.obj ‚ü®n‚ü©\n    apply preservesLimit_of_iso_diagram F that\n\n"}
{"name":"CategoryTheory.preservesFiniteProducts_of_preserves_binary_and_terminal","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\nJ : Type u_1\ninst‚úù : Fintype J\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the terminal object and binary products then it preserves finite products. -/\nlemma preservesFiniteProducts_of_preserves_binary_and_terminal (J : Type*) [Fintype J] :\n    PreservesLimitsOfShape (Discrete J) F := by\n  classical\n    let e := Fintype.equivFin J\n    haveI := preservesShape_fin_of_preserves_binary_and_terminal F (Fintype.card J)\n    apply preservesLimitsOfShape_of_equiv (Discrete.equivalence e).symm\n\n"}
{"name":"CategoryTheory.extendCofan_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryCofan (f 0) c‚ÇÅ.pt\nX : CategoryTheory.Discrete (Fin (HAdd.hAdd n 1))\n‚ä¢ Eq ((CategoryTheory.extendCofan c‚ÇÅ c‚ÇÇ).Œπ.app X) (Fin.cases c‚ÇÇ.inl (fun i => CategoryTheory.CategoryStruct.comp (c‚ÇÅ.Œπ.app { as := i }) c‚ÇÇ.inr) X.as)","decl":"/-- Given `n+1` objects of `C`, a cofan for the last `n` with point `c‚ÇÅ.pt`\nand a binary cofan on `c‚ÇÅ.X` and `f 0`, we can build a cofan for all `n+1`.\n\nIn `extendCofanIsColimit` we show that if the two given cofans are colimits,\nthen this cofan is also a colimit.\n-/\n\n@[simps!] -- Porting note: removed semireducible config\ndef extendCofan {n : ‚Ñï} {f : Fin (n + 1) ‚Üí C} (c‚ÇÅ : Cofan fun i : Fin n => f i.succ)\n    (c‚ÇÇ : BinaryCofan (f 0) c‚ÇÅ.pt) : Cofan f :=\n  Cofan.mk c‚ÇÇ.pt\n    (by\n      refine Fin.cases ?_ ?_\n      ¬∑ apply c‚ÇÇ.inl\n      ¬∑ intro i\n        apply c‚ÇÅ.Œπ.app ‚ü®i‚ü© ‚â´ c‚ÇÇ.inr)\n\n"}
{"name":"CategoryTheory.extendCofan_pt","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nn : Nat\nf : Fin (HAdd.hAdd n 1) ‚Üí C\nc‚ÇÅ : CategoryTheory.Limits.Cofan fun i => f i.succ\nc‚ÇÇ : CategoryTheory.Limits.BinaryCofan (f 0) c‚ÇÅ.pt\n‚ä¢ Eq (CategoryTheory.extendCofan c‚ÇÅ c‚ÇÇ).pt c‚ÇÇ.pt","decl":"/-- Given `n+1` objects of `C`, a cofan for the last `n` with point `c‚ÇÅ.pt`\nand a binary cofan on `c‚ÇÅ.X` and `f 0`, we can build a cofan for all `n+1`.\n\nIn `extendCofanIsColimit` we show that if the two given cofans are colimits,\nthen this cofan is also a colimit.\n-/\n\n@[simps!] -- Porting note: removed semireducible config\ndef extendCofan {n : ‚Ñï} {f : Fin (n + 1) ‚Üí C} (c‚ÇÅ : Cofan fun i : Fin n => f i.succ)\n    (c‚ÇÇ : BinaryCofan (f 0) c‚ÇÅ.pt) : Cofan f :=\n  Cofan.mk c‚ÇÇ.pt\n    (by\n      refine Fin.cases ?_ ?_\n      ¬∑ apply c‚ÇÇ.inl\n      ¬∑ intro i\n        apply c‚ÇÅ.Œπ.app ‚ü®i‚ü© ‚â´ c‚ÇÇ.inr)\n\n"}
{"name":"CategoryTheory.hasFiniteCoproducts_of_has_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryCoproducts C\ninst‚úù : CategoryTheory.Limits.HasInitial C\n‚ä¢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"/-- If `C` has an initial object and binary coproducts, then it has finite coproducts. -/\ntheorem hasFiniteCoproducts_of_has_binary_and_initial : HasFiniteCoproducts C :=\n  ‚ü®fun n => ‚ü®fun K =>\n    letI := hasCoproduct_fin n fun n => K.obj ‚ü®n‚ü©\n    let that : K ‚âÖ Discrete.functor fun n => K.obj ‚ü®n‚ü© := Discrete.natIso fun ‚ü®_‚ü© => Iso.refl _\n    @hasColimitOfIso _ _ _ _ _ _ this that‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.preserves_fin_of_preserves_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù : CategoryTheory.Limits.HasFiniteCoproducts C\nn : Nat\nf : Fin n ‚Üí C\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Discrete.functor f) F","decl":"/-- If `F` preserves the initial object and binary coproducts, then it preserves products indexed by\n`Fin n` for any `n`.\n-/\nlemma preserves_fin_of_preserves_binary_and_initial :\n    ‚àÄ (n : ‚Ñï) (f : Fin n ‚Üí C), PreservesColimit (Discrete.functor f) F\n  | 0 => fun f => by\n    letI : PreservesColimitsOfShape (Discrete (Fin 0)) F :=\n      preservesColimitsOfShape_of_equiv.{0, 0} (Discrete.equivalence finZeroEquiv'.symm) _\n    infer_instance\n  | n + 1 => by\n    haveI := preserves_fin_of_preserves_binary_and_initial n\n    intro f\n    apply\n      preservesColimit_of_preserves_colimit_cocone\n        (extendCofanIsColimit f (colimit.isColimit _) (colimit.isColimit _)) _\n    apply (isColimitMapCoconeCofanMkEquiv _ _ _).symm _\n    let this :=\n      extendCofanIsColimit (fun i => F.obj (f i))\n        (isColimitOfHasCoproductOfPreservesColimit F _)\n        (isColimitOfHasBinaryCoproductOfPreservesColimit F _ _)\n    refine IsColimit.ofIsoColimit this ?_\n    apply Cocones.ext _ _\n    ¬∑ apply Iso.refl _\n    rintro ‚ü®j‚ü©\n    refine Fin.inductionOn j ?_ ?_\n    ¬∑ apply Category.comp_id\n    ¬∑ rintro i _\n      dsimp [extendCofan_Œπ_app, Iso.refl_hom, Cofan.mk_Œπ_app]\n      rw [comp_id, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.preservesShape_fin_of_preserves_binary_and_initial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬π : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù : CategoryTheory.Limits.HasFiniteCoproducts C\nn : Nat\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete (Fin n)) F","decl":"/-- If `F` preserves the initial object and binary coproducts, then it preserves colimits of shape\n`Discrete (Fin n)`.\n-/\nlemma preservesShape_fin_of_preserves_binary_and_initial (n : ‚Ñï) :\n    PreservesColimitsOfShape (Discrete (Fin n)) F where\n  preservesColimit {K} := by\n    let that : (Discrete.functor fun n => K.obj ‚ü®n‚ü©) ‚âÖ K := Discrete.natIso fun ‚ü®i‚ü© => Iso.refl _\n    haveI := preserves_fin_of_preserves_binary_and_initial F n fun n => K.obj ‚ü®n‚ü©\n    apply preservesColimit_of_iso_diagram F that\n\n"}
{"name":"CategoryTheory.preservesFiniteCoproductsOfPreservesBinaryAndInitial","module":"Mathlib.CategoryTheory.Limits.Constructions.FiniteProductsOfBinaryProducts","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù‚Å¥ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) F\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteCoproducts C\nJ : Type u_1\ninst‚úù : Fintype J\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete J) F","decl":"/-- If `F` preserves the initial object and binary coproducts then it preserves finite products. -/\nlemma preservesFiniteCoproductsOfPreservesBinaryAndInitial (J : Type*) [Fintype J] :\n    PreservesColimitsOfShape (Discrete J) F := by\n  classical\n    let e := Fintype.equivFin J\n    haveI := preservesShape_fin_of_preserves_binary_and_initial F (Fintype.card J)\n    apply preservesColimitsOfShape_of_equiv (Discrete.equivalence e).symm\n\n"}
