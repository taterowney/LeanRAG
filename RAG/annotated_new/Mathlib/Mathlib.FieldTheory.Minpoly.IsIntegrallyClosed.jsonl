{"name":"minpoly.isIntegrallyClosed_eq_field_fractions","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁵ : CommRing R\ninst✝¹⁴ : CommRing S\ninst✝¹³ : IsDomain R\ninst✝¹² : Algebra R S\nK : Type u_3\nL : Type u_4\ninst✝¹¹ : Field K\ninst✝¹⁰ : Algebra R K\ninst✝⁹ : IsFractionRing R K\ninst✝⁸ : CommRing L\ninst✝⁷ : Nontrivial L\ninst✝⁶ : Algebra R L\ninst✝⁵ : Algebra S L\ninst✝⁴ : Algebra K L\ninst✝³ : IsScalarTower R K L\ninst✝² : IsScalarTower R S L\ninst✝¹ : IsIntegrallyClosed R\ninst✝ : IsDomain S\ns : S\nhs : IsIntegral R s\n⊢ Eq (minpoly K ((algebraMap S L) s)) (Polynomial.map (algebraMap R K) (minpoly R s))","decl":"/-- For integrally closed domains, the minimal polynomial over the ring is the same as the minimal\npolynomial over the fraction field. See `minpoly.isIntegrallyClosed_eq_field_fractions'` if\n`S` is already a `K`-algebra. -/\ntheorem isIntegrallyClosed_eq_field_fractions [IsDomain S] {s : S} (hs : IsIntegral R s) :\n    minpoly K (algebraMap S L s) = (minpoly R s).map (algebraMap R K) := by\n  refine (eq_of_irreducible_of_monic ?_ ?_ ?_).symm\n  · exact ((monic hs).irreducible_iff_irreducible_map_fraction_map).1 (irreducible hs)\n  · rw [aeval_map_algebraMap, aeval_algebraMap_apply, aeval, map_zero]\n  · exact (monic hs).map _\n\n"}
{"name":"minpoly.isIntegrallyClosed_eq_field_fractions'","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : IsDomain R\ninst✝⁷ : Algebra R S\nK : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Algebra R K\ninst✝⁴ : IsFractionRing R K\ninst✝³ : IsIntegrallyClosed R\ninst✝² : IsDomain S\ninst✝¹ : Algebra K S\ninst✝ : IsScalarTower R K S\ns : S\nhs : IsIntegral R s\n⊢ Eq (minpoly K s) (Polynomial.map (algebraMap R K) (minpoly R s))","decl":"/-- For integrally closed domains, the minimal polynomial over the ring is the same as the minimal\npolynomial over the fraction field. Compared to `minpoly.isIntegrallyClosed_eq_field_fractions`,\nthis version is useful if the element is in a ring that is already a `K`-algebra. -/\ntheorem isIntegrallyClosed_eq_field_fractions' [IsDomain S] [Algebra K S] [IsScalarTower R K S]\n    {s : S} (hs : IsIntegral R s) : minpoly K s = (minpoly R s).map (algebraMap R K) := by\n  let L := FractionRing S\n  rw [← isIntegrallyClosed_eq_field_fractions K L hs, algebraMap_eq (IsFractionRing.injective S L)]\n\n"}
{"name":"minpoly.isIntegrallyClosed_dvd","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : Polynomial R\nhp : Eq ((Polynomial.aeval s) p) 0\n⊢ Dvd.dvd (minpoly R s) p","decl":"/-- For integrally closed rings, the minimal polynomial divides any polynomial that has the\n  integral element as root. See also `minpoly.dvd` which relaxes the assumptions on `S`\n  in exchange for stronger assumptions on `R`. -/\ntheorem isIntegrallyClosed_dvd {s : S} (hs : IsIntegral R s) {p : R[X]}\n    (hp : Polynomial.aeval s p = 0) : minpoly R s ∣ p := by\n  let K := FractionRing R\n  let L := FractionRing S\n  let _ : Algebra K L := FractionRing.liftAlgebra R L\n  have := FractionRing.isScalarTower_liftAlgebra R L\n  have : minpoly K (algebraMap S L s) ∣ map (algebraMap R K) (p %ₘ minpoly R s) := by\n    rw [map_modByMonic _ (minpoly.monic hs), modByMonic_eq_sub_mul_div]\n    · refine dvd_sub (minpoly.dvd K (algebraMap S L s) ?_) ?_\n      · rw [← map_aeval_eq_aeval_map, hp, map_zero]\n        rw [← IsScalarTower.algebraMap_eq, ← IsScalarTower.algebraMap_eq]\n      apply dvd_mul_of_dvd_left\n      rw [isIntegrallyClosed_eq_field_fractions K L hs]\n    exact Monic.map _ (minpoly.monic hs)\n  rw [isIntegrallyClosed_eq_field_fractions _ _ hs,\n    map_dvd_map (algebraMap R K) (IsFractionRing.injective R K) (minpoly.monic hs)] at this\n  rw [← modByMonic_eq_zero_iff_dvd (minpoly.monic hs)]\n  exact Polynomial.eq_zero_of_dvd_of_degree_lt this (degree_modByMonic_lt p <| minpoly.monic hs)\n\n"}
{"name":"minpoly.isIntegrallyClosed_dvd_iff","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : Polynomial R\n⊢ Iff (Eq ((Polynomial.aeval s) p) 0) (Dvd.dvd (minpoly R s) p)","decl":"theorem isIntegrallyClosed_dvd_iff {s : S} (hs : IsIntegral R s) (p : R[X]) :\n    Polynomial.aeval s p = 0 ↔ minpoly R s ∣ p :=\n  ⟨fun hp => isIntegrallyClosed_dvd hs hp, fun hp => by\n    simpa only [RingHom.mem_ker, RingHom.coe_comp, coe_evalRingHom, coe_mapRingHom,\n      Function.comp_apply, eval_map, ← aeval_def] using\n      aeval_eq_zero_of_dvd_aeval_eq_zero hp (minpoly.aeval R s)⟩\n\n"}
{"name":"minpoly.ker_eval","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\n⊢ Eq (RingHom.ker (Polynomial.aeval s).toRingHom) (Ideal.span (Singleton.singleton (minpoly R s)))","decl":"theorem ker_eval {s : S} (hs : IsIntegral R s) :\n    RingHom.ker ((Polynomial.aeval s).toRingHom : R[X] →+* S) =\n    Ideal.span ({minpoly R s} : Set R[X]) := by\n  ext p\n  simp_rw [RingHom.mem_ker, AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom,\n    isIntegrallyClosed_dvd_iff hs, ← Ideal.mem_span_singleton]\n\n"}
{"name":"minpoly.IsIntegrallyClosed.degree_le_of_ne_zero","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\ns : S\nhs : IsIntegral R s\np : Polynomial R\nhp0 : Ne p 0\nhp : Eq ((Polynomial.aeval s) p) 0\n⊢ LE.le (minpoly R s).degree p.degree","decl":"/-- If an element `x` is a root of a nonzero polynomial `p`, then the degree of `p` is at least the\ndegree of the minimal polynomial of `x`. See also `minpoly.degree_le_of_ne_zero` which relaxes the\nassumptions on `S` in exchange for stronger assumptions on `R`. -/\ntheorem IsIntegrallyClosed.degree_le_of_ne_zero {s : S} (hs : IsIntegral R s) {p : R[X]}\n    (hp0 : p ≠ 0) (hp : Polynomial.aeval s p = 0) : degree (minpoly R s) ≤ degree p := by\n  rw [degree_eq_natDegree (minpoly.ne_zero hs), degree_eq_natDegree hp0]\n  norm_cast\n  exact natDegree_le_of_dvd ((isIntegrallyClosed_dvd_iff hs _).mp hp) hp0\n\n"}
{"name":"IsIntegrallyClosed.minpoly.unique","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\ns : S\nP : Polynomial R\nhmo : P.Monic\nhP : Eq ((Polynomial.aeval s) P) 0\nPmin : ∀ (Q : Polynomial R), Q.Monic → Eq ((Polynomial.aeval s) Q) 0 → LE.le P.degree Q.degree\n⊢ Eq P (minpoly R s)","decl":"/-- The minimal polynomial of an element `x` is uniquely characterized by its defining property:\nif there is another monic polynomial of minimal degree that has `x` as a root, then this polynomial\nis equal to the minimal polynomial of `x`. See also `minpoly.unique` which relaxes the\nassumptions on `S` in exchange for stronger assumptions on `R`. -/\ntheorem _root_.IsIntegrallyClosed.minpoly.unique {s : S} {P : R[X]} (hmo : P.Monic)\n    (hP : Polynomial.aeval s P = 0)\n    (Pmin : ∀ Q : R[X], Q.Monic → Polynomial.aeval s Q = 0 → degree P ≤ degree Q) :\n    P = minpoly R s := by\n  have hs : IsIntegral R s := ⟨P, hmo, hP⟩\n  symm; apply eq_of_sub_eq_zero\n  by_contra hnz\n  refine IsIntegrallyClosed.degree_le_of_ne_zero hs hnz (by simp [hP]) |>.not_lt ?_\n  refine degree_sub_lt ?_ (ne_zero hs) ?_\n  · exact le_antisymm (min R s hmo hP) (Pmin (minpoly R s) (monic hs) (aeval R s))\n  · rw [(monic hs).leadingCoeff, hmo.leadingCoeff]\n\n"}
{"name":"minpoly.prime_of_isIntegrallyClosed","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n⊢ Prime (minpoly R x)","decl":"theorem prime_of_isIntegrallyClosed {x : S} (hx : IsIntegral R x) : Prime (minpoly R x) := by\n  refine\n    ⟨(minpoly.monic hx).ne_zero,\n      ⟨fun h_contra => (ne_of_lt (minpoly.degree_pos hx)) (degree_eq_zero_of_isUnit h_contra).symm,\n        fun a b h => or_iff_not_imp_left.mpr fun h' => ?_⟩⟩\n  rw [← minpoly.isIntegrallyClosed_dvd_iff hx] at h' h ⊢\n  rw [aeval_mul] at h\n  exact eq_zero_of_ne_zero_of_mul_left_eq_zero h' h\n\n"}
{"name":"minpoly.ToAdjoin.injective","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n⊢ Function.Injective ⇑(AdjoinRoot.Minpoly.toAdjoin R x)","decl":"theorem ToAdjoin.injective (hx : IsIntegral R x) : Function.Injective (Minpoly.toAdjoin R x) := by\n  refine (injective_iff_map_eq_zero _).2 fun P₁ hP₁ => ?_\n  obtain ⟨P, rfl⟩ := mk_surjective P₁\n  rwa [Minpoly.toAdjoin_apply', liftHom_mk, ← Subalgebra.coe_eq_zero, aeval_subalgebra_coe,\n    isIntegrallyClosed_dvd_iff hx, ← AdjoinRoot.mk_eq_zero] at hP₁\n\n"}
{"name":"minpoly.equivAdjoin_symm_apply","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\nb : Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1\n⊢ Eq ((minpoly.equivAdjoin hx).symm b) (Function.surjInv ⋯ b)","decl":"/-- The algebra isomorphism `AdjoinRoot (minpoly R x) ≃ₐ[R] adjoin R x` -/\n@[simps!]\ndef equivAdjoin (hx : IsIntegral R x) : AdjoinRoot (minpoly R x) ≃ₐ[R] adjoin R ({x} : Set S) :=\n  AlgEquiv.ofBijective (Minpoly.toAdjoin R x)\n    ⟨minpoly.ToAdjoin.injective hx, Minpoly.toAdjoin.surjective R x⟩\n\n"}
{"name":"minpoly.equivAdjoin_apply","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\na : AdjoinRoot (minpoly R x)\n⊢ Eq ((minpoly.equivAdjoin hx) a) ((QuotientAddGroup.lift (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton (minpoly R x)))) ↑(Polynomial.eval₂RingHom (algebraMap R (Subtype fun x_1 => Membership.mem (Algebra.adjoin R (Singleton.singleton x)) x_1)) ⟨x, ⋯⟩) ⋯) a)","decl":"/-- The algebra isomorphism `AdjoinRoot (minpoly R x) ≃ₐ[R] adjoin R x` -/\n@[simps!]\ndef equivAdjoin (hx : IsIntegral R x) : AdjoinRoot (minpoly R x) ≃ₐ[R] adjoin R ({x} : Set S) :=\n  AlgEquiv.ofBijective (Minpoly.toAdjoin R x)\n    ⟨minpoly.ToAdjoin.injective hx, Minpoly.toAdjoin.surjective R x⟩\n\n"}
{"name":"Algebra.adjoin.powerBasis'_dim","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n⊢ Eq (Algebra.adjoin.powerBasis' hx).dim (minpoly R x).natDegree","decl":"@[simp]\ntheorem _root_.Algebra.adjoin.powerBasis'_dim (hx : IsIntegral R x) :\n    (Algebra.adjoin.powerBasis' hx).dim = (minpoly R x).natDegree := rfl\n\n"}
{"name":"Algebra.adjoin.powerBasis'_gen","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nhx : IsIntegral R x\n⊢ Eq (Algebra.adjoin.powerBasis' hx).gen ⟨x, ⋯⟩","decl":"@[simp]\ntheorem _root_.Algebra.adjoin.powerBasis'_gen (hx : IsIntegral R x) :\n    (adjoin.powerBasis' hx).gen = ⟨x, SetLike.mem_coe.1 <| subset_adjoin <| mem_singleton x⟩ := by\n  rw [Algebra.adjoin.powerBasis', PowerBasis.map_gen, AdjoinRoot.powerBasis'_gen, equivAdjoin,\n    AlgEquiv.ofBijective_apply, Minpoly.toAdjoin, liftHom_root]\n\n"}
{"name":"PowerBasis.ofGenMemAdjoin'_dim","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nB : PowerBasis R S\nhint : IsIntegral R x\nhx : Membership.mem (Algebra.adjoin R (Singleton.singleton x)) B.gen\n⊢ Eq (B.ofGenMemAdjoin' hint hx).dim (minpoly R x).natDegree","decl":"@[simp]\ntheorem _root_.PowerBasis.ofGenMemAdjoin'_dim (B : PowerBasis R S) (hint : IsIntegral R x)\n    (hx : B.gen ∈ adjoin R ({x} : Set S)) :\n    (B.ofGenMemAdjoin' hint hx).dim = (minpoly R x).natDegree := rfl\n\n"}
{"name":"PowerBasis.ofGenMemAdjoin'_gen","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : IsDomain R\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsIntegrallyClosed R\nx : S\nB : PowerBasis R S\nhint : IsIntegral R x\nhx : Membership.mem (Algebra.adjoin R (Singleton.singleton x)) B.gen\n⊢ Eq (B.ofGenMemAdjoin' hint hx).gen x","decl":"@[simp]\ntheorem _root_.PowerBasis.ofGenMemAdjoin'_gen (B : PowerBasis R S) (hint : IsIntegral R x)\n    (hx : B.gen ∈ adjoin R ({x} : Set S)) :\n    (B.ofGenMemAdjoin' hint hx).gen = x := by\n  simp [PowerBasis.ofGenMemAdjoin']\n\n"}
{"name":"minpoly.instIsScalarTowerSubtypeMemSubringSubalgebraIntegralClosure","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nA : Subring K\n⊢ IsScalarTower (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (integralClosure (Subtype fun x => Membership.mem A x) L) x) L","decl":"instance : IsScalarTower A ((integralClosure A L)) L :=\n  IsScalarTower.subalgebra' A L L (integralClosure A L)\n\n"}
{"name":"minpoly.ofSubring","module":"Mathlib.FieldTheory.Minpoly.IsIntegrallyClosed","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nA : Subring K\ninst✝¹ : IsIntegrallyClosed (Subtype fun x => Membership.mem A x)\ninst✝ : IsFractionRing (Subtype fun x => Membership.mem A x) K\nx : Subtype fun x => Membership.mem (integralClosure (Subtype fun x => Membership.mem A x) L) x\n⊢ Eq (Polynomial.map (algebraMap (Subtype fun x => Membership.mem A x) K) (minpoly (Subtype fun x => Membership.mem A x) x)) (minpoly K ↑x)","decl":"/-- The minimal polynomial of `x : L` over `K` agrees with its minimal polynomial over the\nintegrally closed subring `A`. -/\ntheorem ofSubring (x : integralClosure A L) :\n    Polynomial.map (algebraMap A K) (minpoly A x) = minpoly K (x : L) :=\n  eq_comm.mpr (isIntegrallyClosed_eq_field_fractions K L (IsIntegralClosure.isIntegral A L x))\n\n"}
