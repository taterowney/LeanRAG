{"name":"smoothSheafCommRing.isUnit_stalk_iff","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nEM : Type u_1\ninst✝⁴ : NormedAddCommGroup EM\ninst✝³ : NormedSpace 𝕜 EM\nHM : Type u_2\ninst✝² : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\nM : Type u\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace HM M\nx : M\nf : ↑((smoothSheafCommRing IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜).presheaf.stalk x)\n⊢ Iff (IsUnit f) (Not (Membership.mem (RingHom.ker (smoothSheafCommRing.eval IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜 x)) f))","decl":"/-- The units of the stalk at `x` of the sheaf of smooth functions from `M` to `𝕜`, considered as a\nsheaf of commutative rings, are the functions whose values at `x` are nonzero. -/\ntheorem smoothSheafCommRing.isUnit_stalk_iff {x : M}\n    (f : (smoothSheafCommRing IM 𝓘(𝕜) M 𝕜).presheaf.stalk x) :\n    IsUnit f ↔ f ∉ RingHom.ker (smoothSheafCommRing.eval IM 𝓘(𝕜) M 𝕜 x) := by\n  constructor\n  · rintro ⟨⟨f, g, hf, hg⟩, rfl⟩ (h' : smoothSheafCommRing.eval IM 𝓘(𝕜) M 𝕜 x f = 0)\n    simpa [h'] using congr_arg (smoothSheafCommRing.eval IM 𝓘(𝕜) M 𝕜 x) hf\n  · let S := (smoothSheafCommRing IM 𝓘(𝕜) M 𝕜).presheaf\n    -- Suppose that `f`, in the stalk at `x`, is nonzero at `x`\n    rintro (hf : _ ≠ 0)\n    -- Represent `f` as the germ of some function (also called `f`) on an open neighbourhood `U` of\n    -- `x`, which is nonzero at `x`\n    obtain ⟨U : Opens M, hxU, f : C^∞⟮IM, U; 𝓘(𝕜), 𝕜⟯, rfl⟩ := S.germ_exist x f\n    have hf' : f ⟨x, hxU⟩ ≠ 0 := by\n      convert hf\n      exact (smoothSheafCommRing.eval_germ U x hxU f).symm\n    -- In fact, by continuity, `f` is nonzero on a neighbourhood `V` of `x`\n    have H :  ∀ᶠ (z : U) in 𝓝 ⟨x, hxU⟩, f z ≠ 0 := f.2.continuous.continuousAt.eventually_ne hf'\n    rw [eventually_nhds_iff] at H\n    obtain ⟨V₀, hV₀f, hV₀, hxV₀⟩ := H\n    let V : Opens M := ⟨Subtype.val '' V₀, U.2.isOpenMap_subtype_val V₀ hV₀⟩\n    have hUV : V ≤ U := Subtype.coe_image_subset (U : Set M) V₀\n    have hV : V₀ = Set.range (Set.inclusion hUV) := by\n      convert (Set.range_inclusion hUV).symm\n      ext y\n      show _ ↔ y ∈ Subtype.val ⁻¹' (Subtype.val '' V₀)\n      rw [Set.preimage_image_eq _ Subtype.coe_injective]\n    clear_value V\n    subst hV\n    have hxV : x ∈ (V : Set M) := by\n      obtain ⟨x₀, hxx₀⟩ := hxV₀\n      convert x₀.2\n      exact congr_arg Subtype.val hxx₀.symm\n    have hVf : ∀ y : V, f (Set.inclusion hUV y) ≠ 0 :=\n      fun y ↦ hV₀f (Set.inclusion hUV y) (Set.mem_range_self y)\n    -- Let `g` be the pointwise inverse of `f` on `V`, which is smooth since `f` is nonzero there\n    let g : C^∞⟮IM, V; 𝓘(𝕜), 𝕜⟯ := ⟨(f ∘ Set.inclusion hUV)⁻¹, ?_⟩\n    -- The germ of `g` is inverse to the germ of `f`, so `f` is a unit\n    · refine ⟨⟨S.germ _ x (hxV) (ContMDiffMap.restrictRingHom IM 𝓘(𝕜) 𝕜 hUV f), S.germ _ x hxV g,\n        ?_, ?_⟩, S.germ_res_apply hUV.hom x hxV f⟩\n      · rw [← map_mul]\n        -- Qualified the name to avoid Lean not finding a `OneHomClass` https://github.com/leanprover-community/mathlib4/pull/8386\n        convert RingHom.map_one _\n        apply Subtype.ext\n        ext y\n        apply mul_inv_cancel₀\n        exact hVf y\n      · rw [← map_mul]\n        -- Qualified the name to avoid Lean not finding a `OneHomClass` https://github.com/leanprover-community/mathlib4/pull/8386\n        convert RingHom.map_one _\n        apply Subtype.ext\n        ext y\n        apply inv_mul_cancel₀\n        exact hVf y\n    · intro y\n      #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n        was `exact`; somehow `convert` bypasess unification issues -/\n      convert ((contDiffAt_inv _ (hVf y)).contMDiffAt).comp y\n        (f.contMDiff.comp (contMDiff_inclusion hUV)).contMDiffAt\n\n"}
{"name":"smoothSheafCommRing.nonunits_stalk","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nEM : Type u_1\ninst✝⁴ : NormedAddCommGroup EM\ninst✝³ : NormedSpace 𝕜 EM\nHM : Type u_2\ninst✝² : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\nM : Type u\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace HM M\nx : M\n⊢ Eq (nonunits ↑((smoothSheafCommRing IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜).presheaf.stalk x)) ↑(RingHom.ker (smoothSheafCommRing.eval IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜 x))","decl":"/-- The non-units of the stalk at `x` of the sheaf of smooth functions from `M` to `𝕜`, considered\nas a sheaf of commutative rings, are the functions whose values at `x` are zero. -/\ntheorem smoothSheafCommRing.nonunits_stalk (x : M) :\n    nonunits ((smoothSheafCommRing IM 𝓘(𝕜) M 𝕜).presheaf.stalk x)\n    = RingHom.ker (smoothSheafCommRing.eval IM 𝓘(𝕜) M 𝕜 x) := by\n  ext1 f\n  rw [mem_nonunits_iff, not_iff_comm, Iff.comm]\n  apply smoothSheafCommRing.isUnit_stalk_iff\n\n"}
{"name":"smoothSheafCommRing.instLocalRing_stalk","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nEM : Type u_1\ninst✝⁴ : NormedAddCommGroup EM\ninst✝³ : NormedSpace 𝕜 EM\nHM : Type u_2\ninst✝² : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\nM : Type u\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace HM M\nx : M\n⊢ IsLocalRing ↑((smoothSheafCommRing IM (modelWithCornersSelf 𝕜 𝕜) M 𝕜).presheaf.stalk x)","decl":"/-- The stalks of the structure sheaf of a smooth manifold are local rings. -/\ninstance smoothSheafCommRing.instLocalRing_stalk (x : M) :\n    IsLocalRing ((smoothSheafCommRing IM 𝓘(𝕜) M 𝕜).presheaf.stalk x) := by\n  apply IsLocalRing.of_nonunits_add\n  rw [smoothSheafCommRing.nonunits_stalk]\n  intro f g\n  exact Ideal.add_mem _\n\n"}
