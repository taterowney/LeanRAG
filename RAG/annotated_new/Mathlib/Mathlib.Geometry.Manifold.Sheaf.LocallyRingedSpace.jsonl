{"name":"smoothSheafCommRing.isUnit_stalk_iff","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nEM : Type u_1\ninstâœâ´ : NormedAddCommGroup EM\ninstâœÂ³ : NormedSpace ğ•œ EM\nHM : Type u_2\ninstâœÂ² : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\nM : Type u\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace HM M\nx : M\nf : â†‘((smoothSheafCommRing IM (modelWithCornersSelf ğ•œ ğ•œ) M ğ•œ).presheaf.stalk x)\nâŠ¢ Iff (IsUnit f) (Not (Membership.mem (RingHom.ker (smoothSheafCommRing.eval IM (modelWithCornersSelf ğ•œ ğ•œ) M ğ•œ x)) f))","decl":"/-- The units of the stalk at `x` of the sheaf of smooth functions from `M` to `ğ•œ`, considered as a\nsheaf of commutative rings, are the functions whose values at `x` are nonzero. -/\ntheorem smoothSheafCommRing.isUnit_stalk_iff {x : M}\n    (f : (smoothSheafCommRing IM ğ“˜(ğ•œ) M ğ•œ).presheaf.stalk x) :\n    IsUnit f â†” f âˆ‰ RingHom.ker (smoothSheafCommRing.eval IM ğ“˜(ğ•œ) M ğ•œ x) := by\n  constructor\n  Â· rintro âŸ¨âŸ¨f, g, hf, hgâŸ©, rflâŸ© (h' : smoothSheafCommRing.eval IM ğ“˜(ğ•œ) M ğ•œ x f = 0)\n    simpa [h'] using congr_arg (smoothSheafCommRing.eval IM ğ“˜(ğ•œ) M ğ•œ x) hf\n  Â· let S := (smoothSheafCommRing IM ğ“˜(ğ•œ) M ğ•œ).presheaf\n    -- Suppose that `f`, in the stalk at `x`, is nonzero at `x`\n    rintro (hf : _ â‰  0)\n    -- Represent `f` as the germ of some function (also called `f`) on an open neighbourhood `U` of\n    -- `x`, which is nonzero at `x`\n    obtain âŸ¨U : Opens M, hxU, f : C^âˆâŸ®IM, U; ğ“˜(ğ•œ), ğ•œâŸ¯, rflâŸ© := S.germ_exist x f\n    have hf' : f âŸ¨x, hxUâŸ© â‰  0 := by\n      convert hf\n      exact (smoothSheafCommRing.eval_germ U x hxU f).symm\n    -- In fact, by continuity, `f` is nonzero on a neighbourhood `V` of `x`\n    have H :  âˆ€á¶  (z : U) in ğ“ âŸ¨x, hxUâŸ©, f z â‰  0 := f.2.continuous.continuousAt.eventually_ne hf'\n    rw [eventually_nhds_iff] at H\n    obtain âŸ¨Vâ‚€, hVâ‚€f, hVâ‚€, hxVâ‚€âŸ© := H\n    let V : Opens M := âŸ¨Subtype.val '' Vâ‚€, U.2.isOpenMap_subtype_val Vâ‚€ hVâ‚€âŸ©\n    have hUV : V â‰¤ U := Subtype.coe_image_subset (U : Set M) Vâ‚€\n    have hV : Vâ‚€ = Set.range (Set.inclusion hUV) := by\n      convert (Set.range_inclusion hUV).symm\n      ext y\n      show _ â†” y âˆˆ Subtype.val â»Â¹' (Subtype.val '' Vâ‚€)\n      rw [Set.preimage_image_eq _ Subtype.coe_injective]\n    clear_value V\n    subst hV\n    have hxV : x âˆˆ (V : Set M) := by\n      obtain âŸ¨xâ‚€, hxxâ‚€âŸ© := hxVâ‚€\n      convert xâ‚€.2\n      exact congr_arg Subtype.val hxxâ‚€.symm\n    have hVf : âˆ€ y : V, f (Set.inclusion hUV y) â‰  0 :=\n      fun y â†¦ hVâ‚€f (Set.inclusion hUV y) (Set.mem_range_self y)\n    -- Let `g` be the pointwise inverse of `f` on `V`, which is smooth since `f` is nonzero there\n    let g : C^âˆâŸ®IM, V; ğ“˜(ğ•œ), ğ•œâŸ¯ := âŸ¨(f âˆ˜ Set.inclusion hUV)â»Â¹, ?_âŸ©\n    -- The germ of `g` is inverse to the germ of `f`, so `f` is a unit\n    Â· refine âŸ¨âŸ¨S.germ _ x (hxV) (ContMDiffMap.restrictRingHom IM ğ“˜(ğ•œ) ğ•œ hUV f), S.germ _ x hxV g,\n        ?_, ?_âŸ©, S.germ_res_apply hUV.hom x hxV fâŸ©\n      Â· rw [â† map_mul]\n        -- Qualified the name to avoid Lean not finding a `OneHomClass` https://github.com/leanprover-community/mathlib4/pull/8386\n        convert RingHom.map_one _\n        apply Subtype.ext\n        ext y\n        apply mul_inv_cancelâ‚€\n        exact hVf y\n      Â· rw [â† map_mul]\n        -- Qualified the name to avoid Lean not finding a `OneHomClass` https://github.com/leanprover-community/mathlib4/pull/8386\n        convert RingHom.map_one _\n        apply Subtype.ext\n        ext y\n        apply inv_mul_cancelâ‚€\n        exact hVf y\n    Â· intro y\n      #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n        was `exact`; somehow `convert` bypasess unification issues -/\n      convert ((contDiffAt_inv _ (hVf y)).contMDiffAt).comp y\n        (f.contMDiff.comp (contMDiff_inclusion hUV)).contMDiffAt\n\n"}
{"name":"smoothSheafCommRing.nonunits_stalk","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nEM : Type u_1\ninstâœâ´ : NormedAddCommGroup EM\ninstâœÂ³ : NormedSpace ğ•œ EM\nHM : Type u_2\ninstâœÂ² : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\nM : Type u\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace HM M\nx : M\nâŠ¢ Eq (nonunits â†‘((smoothSheafCommRing IM (modelWithCornersSelf ğ•œ ğ•œ) M ğ•œ).presheaf.stalk x)) â†‘(RingHom.ker (smoothSheafCommRing.eval IM (modelWithCornersSelf ğ•œ ğ•œ) M ğ•œ x))","decl":"/-- The non-units of the stalk at `x` of the sheaf of smooth functions from `M` to `ğ•œ`, considered\nas a sheaf of commutative rings, are the functions whose values at `x` are zero. -/\ntheorem smoothSheafCommRing.nonunits_stalk (x : M) :\n    nonunits ((smoothSheafCommRing IM ğ“˜(ğ•œ) M ğ•œ).presheaf.stalk x)\n    = RingHom.ker (smoothSheafCommRing.eval IM ğ“˜(ğ•œ) M ğ•œ x) := by\n  ext1 f\n  rw [mem_nonunits_iff, not_iff_comm, Iff.comm]\n  apply smoothSheafCommRing.isUnit_stalk_iff\n\n"}
{"name":"smoothSheafCommRing.instLocalRing_stalk","module":"Mathlib.Geometry.Manifold.Sheaf.LocallyRingedSpace","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nEM : Type u_1\ninstâœâ´ : NormedAddCommGroup EM\ninstâœÂ³ : NormedSpace ğ•œ EM\nHM : Type u_2\ninstâœÂ² : TopologicalSpace HM\nIM : ModelWithCorners ğ•œ EM HM\nM : Type u\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace HM M\nx : M\nâŠ¢ IsLocalRing â†‘((smoothSheafCommRing IM (modelWithCornersSelf ğ•œ ğ•œ) M ğ•œ).presheaf.stalk x)","decl":"/-- The stalks of the structure sheaf of a smooth manifold are local rings. -/\ninstance smoothSheafCommRing.instLocalRing_stalk (x : M) :\n    IsLocalRing ((smoothSheafCommRing IM ğ“˜(ğ•œ) M ğ•œ).presheaf.stalk x) := by\n  apply IsLocalRing.of_nonunits_add\n  rw [smoothSheafCommRing.nonunits_stalk]\n  intro f g\n  exact Ideal.add_mem _\n\n"}
