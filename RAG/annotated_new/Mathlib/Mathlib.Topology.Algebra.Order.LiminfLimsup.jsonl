{"name":"BoundedLENhdsClass.isBounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_7\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\nself : BoundedLENhdsClass α\na : α\n⊢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"/-- Ad hoc typeclass stating that neighborhoods are eventually bounded above. -/\nclass BoundedLENhdsClass (α : Type*) [Preorder α] [TopologicalSpace α] : Prop where\n  isBounded_le_nhds (a : α) : (𝓝 a).IsBounded (· ≤ ·)\n\n"}
{"name":"BoundedGENhdsClass.isBounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_7\ninst✝¹ : Preorder α\ninst✝ : TopologicalSpace α\nself : BoundedGENhdsClass α\na : α\n⊢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"/-- Ad hoc typeclass stating that neighborhoods are eventually bounded below. -/\nclass BoundedGENhdsClass (α : Type*) [Preorder α] [TopologicalSpace α] : Prop where\n  isBounded_ge_nhds (a : α) : (𝓝 a).IsBounded (· ≥ ·)\n\n"}
{"name":"isBounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedLENhdsClass α\na : α\n⊢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"theorem isBounded_le_nhds (a : α) : (𝓝 a).IsBounded (· ≤ ·) :=\n  BoundedLENhdsClass.isBounded_le_nhds _\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedLENhdsClass α\nf : Filter ι\nu : ι → α\na : α\nh : Filter.Tendsto u f (nhds a)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Filter.Tendsto.isBoundedUnder_le (h : Tendsto u f (𝓝 a)) : f.IsBoundedUnder (· ≤ ·) u :=\n  (isBounded_le_nhds a).mono h\n\n"}
{"name":"Filter.Tendsto.bddAbove_range_of_cofinite","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedLENhdsClass α\nu : ι → α\na : α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nh : Filter.Tendsto u Filter.cofinite (nhds a)\n⊢ BddAbove (Set.range u)","decl":"theorem Filter.Tendsto.bddAbove_range_of_cofinite [IsDirected α (· ≤ ·)]\n    (h : Tendsto u cofinite (𝓝 a)) : BddAbove (Set.range u) :=\n  h.isBoundedUnder_le.bddAbove_range_of_cofinite\n\n"}
{"name":"Filter.Tendsto.bddAbove_range","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedLENhdsClass α\na : α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nu : Nat → α\nh : Filter.Tendsto u Filter.atTop (nhds a)\n⊢ BddAbove (Set.range u)","decl":"theorem Filter.Tendsto.bddAbove_range [IsDirected α (· ≤ ·)] {u : ℕ → α}\n    (h : Tendsto u atTop (𝓝 a)) : BddAbove (Set.range u) :=\n  h.isBoundedUnder_le.bddAbove_range\n\n"}
{"name":"isCobounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedLENhdsClass α\na : α\n⊢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"theorem isCobounded_ge_nhds (a : α) : (𝓝 a).IsCobounded (· ≥ ·) :=\n  (isBounded_le_nhds a).isCobounded_flip\n\n"}
{"name":"Filter.Tendsto.isCoboundedUnder_ge","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedLENhdsClass α\nf : Filter ι\nu : ι → α\na : α\ninst✝ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Filter.Tendsto.isCoboundedUnder_ge [NeBot f] (h : Tendsto u f (𝓝 a)) :\n    f.IsCoboundedUnder (· ≥ ·) u :=\n  h.isBoundedUnder_le.isCobounded_flip\n\n"}
{"name":"instBoundedGENhdsClassOrderDual","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedLENhdsClass α\n⊢ BoundedGENhdsClass (OrderDual α)","decl":"instance : BoundedGENhdsClass αᵒᵈ := ⟨@isBounded_le_nhds α _ _ _⟩\n\n"}
{"name":"Prod.instBoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ BoundedLENhdsClass (Prod α β)","decl":"instance Prod.instBoundedLENhdsClass : BoundedLENhdsClass (α × β) := by\n  refine ⟨fun x ↦ ?_⟩\n  obtain ⟨a, ha⟩ := isBounded_le_nhds x.1\n  obtain ⟨b, hb⟩ := isBounded_le_nhds x.2\n  rw [← @Prod.mk.eta _ _ x, nhds_prod_eq]\n  exact ⟨(a, b), ha.prod_mk hb⟩\n\n"}
{"name":"Pi.instBoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nπ : ι → Type u_6\ninst✝³ : Finite ι\ninst✝² : (i : ι) → Preorder (π i)\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), BoundedLENhdsClass (π i)\n⊢ BoundedLENhdsClass ((i : ι) → π i)","decl":"instance Pi.instBoundedLENhdsClass [Finite ι] [∀ i, Preorder (π i)] [∀ i, TopologicalSpace (π i)]\n    [∀ i, BoundedLENhdsClass (π i)] : BoundedLENhdsClass (∀ i, π i) := by\n  refine ⟨fun x ↦ ?_⟩\n  rw [nhds_pi]\n  choose f hf using fun i ↦ isBounded_le_nhds (x i)\n  exact ⟨f, eventually_pi hf⟩\n\n"}
{"name":"isBounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedGENhdsClass α\na : α\n⊢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"theorem isBounded_ge_nhds (a : α) : (𝓝 a).IsBounded (· ≥ ·) :=\n  BoundedGENhdsClass.isBounded_ge_nhds _\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_ge","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedGENhdsClass α\nf : Filter ι\nu : ι → α\na : α\nh : Filter.Tendsto u f (nhds a)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Filter.Tendsto.isBoundedUnder_ge (h : Tendsto u f (𝓝 a)) : f.IsBoundedUnder (· ≥ ·) u :=\n  (isBounded_ge_nhds a).mono h\n\n"}
{"name":"Filter.Tendsto.bddBelow_range_of_cofinite","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedGENhdsClass α\nu : ι → α\na : α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nh : Filter.Tendsto u Filter.cofinite (nhds a)\n⊢ BddBelow (Set.range u)","decl":"theorem Filter.Tendsto.bddBelow_range_of_cofinite [IsDirected α (· ≥ ·)]\n    (h : Tendsto u cofinite (𝓝 a)) : BddBelow (Set.range u) :=\n  h.isBoundedUnder_ge.bddBelow_range_of_cofinite\n\n"}
{"name":"Filter.Tendsto.bddBelow_range","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedGENhdsClass α\na : α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nu : Nat → α\nh : Filter.Tendsto u Filter.atTop (nhds a)\n⊢ BddBelow (Set.range u)","decl":"theorem Filter.Tendsto.bddBelow_range [IsDirected α (· ≥ ·)] {u : ℕ → α}\n    (h : Tendsto u atTop (𝓝 a)) : BddBelow (Set.range u) :=\n  h.isBoundedUnder_ge.bddBelow_range\n\n"}
{"name":"isCobounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedGENhdsClass α\na : α\n⊢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"theorem isCobounded_le_nhds (a : α) : (𝓝 a).IsCobounded (· ≤ ·) :=\n  (isBounded_ge_nhds a).isCobounded_flip\n\n"}
{"name":"Filter.Tendsto.isCoboundedUnder_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Preorder α\ninst✝² : TopologicalSpace α\ninst✝¹ : BoundedGENhdsClass α\nf : Filter ι\nu : ι → α\na : α\ninst✝ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Filter.Tendsto.isCoboundedUnder_le [NeBot f] (h : Tendsto u f (𝓝 a)) :\n    f.IsCoboundedUnder (· ≤ ·) u :=\n  h.isBoundedUnder_ge.isCobounded_flip\n\n"}
{"name":"instBoundedLENhdsClassOrderDual","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : BoundedGENhdsClass α\n⊢ BoundedLENhdsClass (OrderDual α)","decl":"instance : BoundedLENhdsClass αᵒᵈ := ⟨@isBounded_ge_nhds α _ _ _⟩\n\n"}
{"name":"Prod.instBoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ BoundedGENhdsClass (Prod α β)","decl":"instance Prod.instBoundedGENhdsClass : BoundedGENhdsClass (α × β) :=\n  ⟨(Prod.instBoundedLENhdsClass (α := αᵒᵈ) (β := βᵒᵈ)).isBounded_le_nhds⟩\n\n"}
{"name":"Pi.instBoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nπ : ι → Type u_6\ninst✝³ : Finite ι\ninst✝² : (i : ι) → Preorder (π i)\ninst✝¹ : (i : ι) → TopologicalSpace (π i)\ninst✝ : ∀ (i : ι), BoundedGENhdsClass (π i)\n⊢ BoundedGENhdsClass ((i : ι) → π i)","decl":"instance Pi.instBoundedGENhdsClass [Finite ι] [∀ i, Preorder (π i)] [∀ i, TopologicalSpace (π i)]\n    [∀ i, BoundedGENhdsClass (π i)] : BoundedGENhdsClass (∀ i, π i) :=\n  ⟨(Pi.instBoundedLENhdsClass (π := fun i ↦ (π i)ᵒᵈ)).isBounded_le_nhds⟩\n\n"}
{"name":"OrderTop.to_BoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTop α\n⊢ BoundedLENhdsClass α","decl":"instance (priority := 100) OrderTop.to_BoundedLENhdsClass [OrderTop α] : BoundedLENhdsClass α :=\n  ⟨fun _a ↦ isBounded_le_of_top⟩\n\n-- See note [lower instance priority]\n"}
{"name":"OrderBot.to_BoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : Preorder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderBot α\n⊢ BoundedGENhdsClass α","decl":"instance (priority := 100) OrderBot.to_BoundedGENhdsClass [OrderBot α] : BoundedGENhdsClass α :=\n  ⟨fun _a ↦ isBounded_ge_of_bot⟩\n\n"}
{"name":"BoundedLENhdsClass.of_closedIciTopology","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : ClosedIciTopology α\n⊢ BoundedLENhdsClass α","decl":"instance (priority := 100) BoundedLENhdsClass.of_closedIciTopology [LinearOrder α]\n    [TopologicalSpace α] [ClosedIciTopology α] : BoundedLENhdsClass α :=\n  ⟨fun a ↦ ((isTop_or_exists_gt a).elim fun h ↦ ⟨a, Eventually.of_forall h⟩) <|\n    Exists.imp fun _b ↦ eventually_le_nhds⟩\n\n-- See note [lower instance priority]\n"}
{"name":"BoundedGENhdsClass.of_closedIicTopology","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : LinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : ClosedIicTopology α\n⊢ BoundedGENhdsClass α","decl":"instance (priority := 100) BoundedGENhdsClass.of_closedIicTopology [LinearOrder α]\n    [TopologicalSpace α] [ClosedIicTopology α] : BoundedGENhdsClass α :=\n  inferInstanceAs <| BoundedGENhdsClass αᵒᵈᵒᵈ\n\n"}
{"name":"le_nhds_of_limsSup_eq_limsInf","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\nf : Filter α\na : α\nhl : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\nhg : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\nhs : Eq f.limsSup a\nhi : Eq f.limsInf a\n⊢ LE.le f (nhds a)","decl":"/-- If the liminf and the limsup of a filter coincide, then this filter converges to\ntheir common value, at least if the filter is eventually bounded above and below. -/\ntheorem le_nhds_of_limsSup_eq_limsInf {f : Filter α} {a : α} (hl : f.IsBounded (· ≤ ·))\n    (hg : f.IsBounded (· ≥ ·)) (hs : f.limsSup = a) (hi : f.limsInf = a) : f ≤ 𝓝 a :=\n  tendsto_order.2 ⟨fun _ hb ↦ gt_mem_sets_of_limsInf_gt hg <| hi.symm ▸ hb,\n    fun _ hb ↦ lt_mem_sets_of_limsSup_lt hl <| hs.symm ▸ hb⟩\n\n"}
{"name":"limsSup_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\na : α\n⊢ Eq (nhds a).limsSup a","decl":"theorem limsSup_nhds (a : α) : limsSup (𝓝 a) = a :=\n  csInf_eq_of_forall_ge_of_forall_gt_exists_lt (isBounded_le_nhds a)\n    (fun a' (h : { n : α | n ≤ a' } ∈ 𝓝 a) ↦ show a ≤ a' from @mem_of_mem_nhds α a _ _ h)\n    fun b (hba : a < b) ↦\n    show ∃ c, { n : α | n ≤ c } ∈ 𝓝 a ∧ c < b from\n      match dense_or_discrete a b with\n      | Or.inl ⟨c, hac, hcb⟩ => ⟨c, ge_mem_nhds hac, hcb⟩\n      | Or.inr ⟨_, h⟩ => ⟨a, (𝓝 a).sets_of_superset (gt_mem_nhds hba) h, hba⟩\n\n"}
{"name":"limsInf_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\na : α\n⊢ Eq (nhds a).limsInf a","decl":"theorem limsInf_nhds (a : α) : limsInf (𝓝 a) = a :=\n  limsSup_nhds (α := αᵒᵈ) a\n\n"}
{"name":"limsInf_eq_of_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\nf : Filter α\na : α\ninst✝ : f.NeBot\nh : LE.le f (nhds a)\n⊢ Eq f.limsInf a","decl":"/-- If a filter is converging, its limsup coincides with its limit. -/\ntheorem limsInf_eq_of_le_nhds {f : Filter α} {a : α} [NeBot f] (h : f ≤ 𝓝 a) : f.limsInf = a :=\n  have hb_ge : IsBounded (· ≥ ·) f := (isBounded_ge_nhds a).mono h\n  have hb_le : IsBounded (· ≤ ·) f := (isBounded_le_nhds a).mono h\n  le_antisymm\n    (calc\n      f.limsInf ≤ f.limsSup := limsInf_le_limsSup hb_le hb_ge\n      _ ≤ (𝓝 a).limsSup := limsSup_le_limsSup_of_le h hb_ge.isCobounded_flip (isBounded_le_nhds a)\n      _ = a := limsSup_nhds a)\n    (calc\n      a = (𝓝 a).limsInf := (limsInf_nhds a).symm\n      _ ≤ f.limsInf := limsInf_le_limsInf_of_le h (isBounded_ge_nhds a) hb_le.isCobounded_flip)\n\n"}
{"name":"limsSup_eq_of_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\nf : Filter α\na : α\ninst✝ : f.NeBot\nh : LE.le f (nhds a)\n⊢ Eq f.limsSup a","decl":"/-- If a filter is converging, its liminf coincides with its limit. -/\ntheorem limsSup_eq_of_le_nhds {f : Filter α} {a : α} [NeBot f] (h : f ≤ 𝓝 a) : f.limsSup = a :=\n  limsInf_eq_of_le_nhds (α := αᵒᵈ) h\n\n"}
{"name":"Filter.Tendsto.limsup_eq","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\nf : Filter β\nu : β → α\na : α\ninst✝ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\n⊢ Eq (Filter.limsup u f) a","decl":"/-- If a function has a limit, then its limsup coincides with its limit. -/\ntheorem Filter.Tendsto.limsup_eq {f : Filter β} {u : β → α} {a : α} [NeBot f]\n    (h : Tendsto u f (𝓝 a)) : limsup u f = a :=\n  limsSup_eq_of_le_nhds h\n\n"}
{"name":"Filter.Tendsto.liminf_eq","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\nf : Filter β\nu : β → α\na : α\ninst✝ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\n⊢ Eq (Filter.liminf u f) a","decl":"/-- If a function has a limit, then its liminf coincides with its limit. -/\ntheorem Filter.Tendsto.liminf_eq {f : Filter β} {u : β → α} {a : α} [NeBot f]\n    (h : Tendsto u f (𝓝 a)) : liminf u f = a :=\n  limsInf_eq_of_le_nhds h\n\n"}
{"name":"tendsto_of_liminf_eq_limsup","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\nf : Filter β\nu : β → α\na : α\nhinf : Eq (Filter.liminf u f) a\nhsup : Eq (Filter.limsup u f) a\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Filter.Tendsto u f (nhds a)","decl":"/-- If the liminf and the limsup of a function coincide, then the limit of the function\nexists and has the same value. -/\ntheorem tendsto_of_liminf_eq_limsup {f : Filter β} {u : β → α} {a : α} (hinf : liminf u f = a)\n    (hsup : limsup u f = a) (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) : Tendsto u f (𝓝 a) :=\n  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf\n\n"}
{"name":"tendsto_of_le_liminf_of_limsup_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : TopologicalSpace α\ninst✝ : OrderTopology α\nf : Filter β\nu : β → α\na : α\nhinf : LE.le a (Filter.liminf u f)\nhsup : LE.le (Filter.limsup u f) a\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Filter.Tendsto u f (nhds a)","decl":"/-- If a number `a` is less than or equal to the `liminf` of a function `f` at some filter\nand is greater than or equal to the `limsup` of `f`, then `f` tends to `a` along this filter. -/\ntheorem tendsto_of_le_liminf_of_limsup_le {f : Filter β} {u : β → α} {a : α} (hinf : a ≤ liminf u f)\n    (hsup : limsup u f ≤ a) (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) : Tendsto u f (𝓝 a) := by\n  rcases f.eq_or_neBot with rfl | _\n  · exact tendsto_bot\n  · exact tendsto_of_liminf_eq_limsup (le_antisymm (le_trans (liminf_le_limsup h h') hsup) hinf)\n      (le_antisymm hsup (le_trans hinf (liminf_le_limsup h h'))) h h'\n\n"}
{"name":"tendsto_of_no_upcrossings","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderTopology α\ninst✝ : DenselyOrdered α\nf : Filter β\nu : β → α\ns : Set α\nhs : Dense s\nH : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → LT.lt a b → Not (And (Filter.Frequently (fun n => LT.lt (u n) a) f) (Filter.Frequently (fun n => LT.lt b (u n)) f))\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Exists fun c => Filter.Tendsto u f (nhds c)","decl":"/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset.\n-/\ntheorem tendsto_of_no_upcrossings [DenselyOrdered α] {f : Filter β} {u : β → α} {s : Set α}\n    (hs : Dense s) (H : ∀ a ∈ s, ∀ b ∈ s, a < b → ¬((∃ᶠ n in f, u n < a) ∧ ∃ᶠ n in f, b < u n))\n    (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    ∃ c : α, Tendsto u f (𝓝 c) := by\n  rcases f.eq_or_neBot with rfl | hbot\n  · exact ⟨sInf ∅, tendsto_bot⟩\n  refine ⟨limsup u f, ?_⟩\n  apply tendsto_of_le_liminf_of_limsup_le _ le_rfl h h'\n  by_contra! hlt\n  obtain ⟨a, ⟨⟨la, au⟩, as⟩⟩ : ∃ a, (f.liminf u < a ∧ a < f.limsup u) ∧ a ∈ s :=\n    dense_iff_inter_open.1 hs (Set.Ioo (f.liminf u) (f.limsup u)) isOpen_Ioo\n      (Set.nonempty_Ioo.2 hlt)\n  obtain ⟨b, ⟨⟨ab, bu⟩, bs⟩⟩ : ∃ b, (a < b ∧ b < f.limsup u) ∧ b ∈ s :=\n    dense_iff_inter_open.1 hs (Set.Ioo a (f.limsup u)) isOpen_Ioo (Set.nonempty_Ioo.2 au)\n  have A : ∃ᶠ n in f, u n < a := frequently_lt_of_liminf_lt (IsBounded.isCobounded_ge h) la\n  have B : ∃ᶠ n in f, b < u n := frequently_lt_of_lt_limsup (IsBounded.isCobounded_le h') bu\n  exact H a as b bs ab ⟨A, B⟩\n\n"}
{"name":"eventually_le_limsup","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderTopology α\ninst✝¹ : FirstCountableTopology α\nf : Filter β\ninst✝ : CountableInterFilter f\nu : β → α\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\n⊢ Filter.Eventually (fun b => LE.le (u b) (Filter.limsup u f)) f","decl":"theorem eventually_le_limsup (hf : IsBoundedUnder (· ≤ ·) f u := by isBoundedDefault) :\n    ∀ᶠ b in f, u b ≤ f.limsup u := by\n  obtain ha | ha := isTop_or_exists_gt (f.limsup u)\n  · exact Eventually.of_forall fun _ => ha _\n  by_cases H : IsGLB (Set.Ioi (f.limsup u)) (f.limsup u)\n  · obtain ⟨u, -, -, hua, hu⟩ := H.exists_seq_antitone_tendsto ha\n    have := fun n => eventually_lt_of_limsup_lt (hu n) hf\n    exact\n      (eventually_countable_forall.2 this).mono fun b hb =>\n        ge_of_tendsto hua <| Eventually.of_forall fun n => (hb _).le\n  · obtain ⟨x, hx, xa⟩ : ∃ x, (∀ ⦃b⦄, f.limsup u < b → x ≤ b) ∧ f.limsup u < x := by\n      simp only [IsGLB, IsGreatest, lowerBounds, upperBounds, Set.mem_Ioi, Set.mem_setOf_eq,\n        not_and, not_forall, not_le, exists_prop] at H\n      exact H fun x => le_of_lt\n    filter_upwards [eventually_lt_of_limsup_lt xa hf] with y hy\n    contrapose! hy\n    exact hx hy\n\n"}
{"name":"eventually_liminf_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : ConditionallyCompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : OrderTopology α\ninst✝¹ : FirstCountableTopology α\nf : Filter β\ninst✝ : CountableInterFilter f\nu : β → α\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Filter.Eventually (fun b => LE.le (Filter.liminf u f) (u b)) f","decl":"theorem eventually_liminf_le (hf : IsBoundedUnder (· ≥ ·) f u := by isBoundedDefault) :\n    ∀ᶠ b in f, f.liminf u ≤ u b :=\n  eventually_le_limsup (α := αᵒᵈ) hf\n\n"}
{"name":"limsup_eq_bot","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : CompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : FirstCountableTopology α\ninst✝¹ : OrderTopology α\nf : Filter β\ninst✝ : CountableInterFilter f\nu : β → α\n⊢ Iff (Eq (Filter.limsup u f) Bot.bot) (f.EventuallyEq u Bot.bot)","decl":"@[simp]\ntheorem limsup_eq_bot : f.limsup u = ⊥ ↔ u =ᶠ[f] ⊥ :=\n  ⟨fun h =>\n    (EventuallyLE.trans eventually_le_limsup <| Eventually.of_forall fun _ => h.le).mono fun _ hx =>\n      le_antisymm hx bot_le,\n    fun h => by\n    rw [limsup_congr h]\n    exact limsup_const_bot⟩\n\n"}
{"name":"liminf_eq_top","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁴ : CompleteLinearOrder α\ninst✝³ : TopologicalSpace α\ninst✝² : FirstCountableTopology α\ninst✝¹ : OrderTopology α\nf : Filter β\ninst✝ : CountableInterFilter f\nu : β → α\n⊢ Iff (Eq (Filter.liminf u f) Top.top) (f.EventuallyEq u Top.top)","decl":"@[simp]\ntheorem liminf_eq_top : f.liminf u = ⊤ ↔ u =ᶠ[f] ⊤ :=\n  limsup_eq_bot (α := αᵒᵈ)\n\n"}
{"name":"Antitone.map_limsSup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\ninst✝³ : ConditionallyCompleteLinearOrder S\ninst✝² : TopologicalSpace S\ninst✝¹ : OrderTopology S\nF : Filter R\ninst✝ : F.NeBot\nf : R → S\nf_decr : Antitone f\nf_cont : ContinuousAt f F.limsSup\nbdd_above : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) F) _auto✝\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F) _auto✝\n⊢ Eq (f F.limsSup) (Filter.liminf f F)","decl":"/-- An antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsSup` to the `Filter.liminf` of the image if the function is continuous at the `limsSup`\n(and the filter is bounded from above and frequently bounded from below). -/\ntheorem Antitone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R → S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (· ≤ ·) := by isBoundedDefault)\n    (cobdd : F.IsCobounded (· ≤ ·) := by isBoundedDefault) :\n    f F.limsSup = F.liminf f := by\n  apply le_antisymm\n  · rw [limsSup, f_decr.map_csInf_of_continuousAt f_cont bdd_above cobdd]\n    apply le_of_forall_lt\n    intro c hc\n    simp only [liminf, limsInf, eventually_map] at hc ⊢\n    obtain ⟨d, hd, h'd⟩ :=\n      exists_lt_of_lt_csSup (bdd_above.recOn fun x hx ↦ ⟨f x, Set.mem_image_of_mem f hx⟩) hc\n    apply lt_csSup_of_lt ?_ ?_ h'd\n    · simpa only [BddAbove, upperBounds]\n        using Antitone.isCoboundedUnder_ge_of_isCobounded f_decr cobdd\n    · rcases hd with ⟨e, ⟨he, fe_eq_d⟩⟩\n      filter_upwards [he] with x hx using (fe_eq_d.symm ▸ f_decr hx)\n  · by_cases h' : ∃ c, c < F.limsSup ∧ Set.Ioo c F.limsSup = ∅\n    · rcases h' with ⟨c, c_lt, hc⟩\n      have B : ∃ᶠ n in F, F.limsSup ≤ n := by\n        apply (frequently_lt_of_lt_limsSup cobdd c_lt).mono\n        intro x hx\n        by_contra!\n        have : (Set.Ioo c F.limsSup).Nonempty := ⟨x, ⟨hx, this⟩⟩\n        simp only [hc, Set.not_nonempty_empty] at this\n      apply liminf_le_of_frequently_le _ (bdd_above.isBoundedUnder f_decr)\n      exact B.mono fun x hx ↦ f_decr hx\n    push_neg at h'\n    by_contra! H\n    have not_bot : ¬ IsBot F.limsSup := fun maybe_bot ↦\n      lt_irrefl (F.liminf f) <| lt_of_le_of_lt\n        (liminf_le_of_frequently_le (Frequently.of_forall (fun r ↦ f_decr (maybe_bot r)))\n          (bdd_above.isBoundedUnder f_decr)) H\n    obtain ⟨l, l_lt, h'l⟩ :\n        ∃ l < F.limsSup, Set.Ioc l F.limsSup ⊆ { x : R | f x < F.liminf f } := by\n      apply exists_Ioc_subset_of_mem_nhds ((tendsto_order.1 f_cont.tendsto).2 _ H)\n      simpa [IsBot] using not_bot\n    obtain ⟨m, l_m, m_lt⟩ : (Set.Ioo l F.limsSup).Nonempty := by\n      contrapose! h'\n      exact ⟨l, l_lt, h'⟩\n    have B : F.liminf f ≤ f m := by\n      apply liminf_le_of_frequently_le _ _\n      · apply (frequently_lt_of_lt_limsSup cobdd m_lt).mono\n        exact fun x hx ↦ f_decr hx.le\n      · exact IsBounded.isBoundedUnder f_decr bdd_above\n    have I : f m < F.liminf f := h'l ⟨l_m, m_lt.le⟩\n    exact lt_irrefl _ (B.trans_lt I)\n\n"}
{"name":"Antitone.map_limsup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter ι\ninst✝⁶ : F.NeBot\ninst✝⁵ : ConditionallyCompleteLinearOrder R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : OrderTopology R\ninst✝² : ConditionallyCompleteLinearOrder S\ninst✝¹ : TopologicalSpace S\ninst✝ : OrderTopology S\nf : R → S\nf_decr : Antitone f\na : ι → R\nf_cont : ContinuousAt f (Filter.limsup a F)\nbdd_above : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F a) _auto✝\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F a) _auto✝\n⊢ Eq (f (Filter.limsup a F)) (Filter.liminf (Function.comp f a) F)","decl":"/-- A continuous antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsup` to the `Filter.liminf` of the images (if the filter is bounded from above and\nfrequently bounded from below). -/\ntheorem Antitone.map_limsup_of_continuousAt {f : R → S} (f_decr : Antitone f) (a : ι → R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) a := by isBoundedDefault)\n    (cobdd : F.IsCoboundedUnder (· ≤ ·) a := by isBoundedDefault) :\n    f (F.limsup a) = F.liminf (f ∘ a) :=\n  f_decr.map_limsSup_of_continuousAt f_cont bdd_above cobdd\n\n"}
{"name":"Antitone.map_limsInf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\ninst✝³ : ConditionallyCompleteLinearOrder S\ninst✝² : TopologicalSpace S\ninst✝¹ : OrderTopology S\nF : Filter R\ninst✝ : F.NeBot\nf : R → S\nf_decr : Antitone f\nf_cont : ContinuousAt f F.limsInf\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F) _auto✝\nbdd_below : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) F) _auto✝\n⊢ Eq (f F.limsInf) (Filter.limsup f F)","decl":"/-- An antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsInf` to the `Filter.limsup` of the image if the function is continuous at the `limsInf`\n(and the filter is bounded from below and frequently bounded from above). -/\ntheorem Antitone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R → S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsInf)\n    (cobdd : F.IsCobounded (· ≥ ·) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (· ≥ ·) := by isBoundedDefault) : f F.limsInf = F.limsup f :=\n  Antitone.map_limsSup_of_continuousAt (R := Rᵒᵈ) (S := Sᵒᵈ) f_decr.dual f_cont bdd_below cobdd\n\n"}
{"name":"Antitone.map_liminf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter ι\ninst✝⁶ : F.NeBot\ninst✝⁵ : ConditionallyCompleteLinearOrder R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : OrderTopology R\ninst✝² : ConditionallyCompleteLinearOrder S\ninst✝¹ : TopologicalSpace S\ninst✝ : OrderTopology S\nf : R → S\nf_decr : Antitone f\na : ι → R\nf_cont : ContinuousAt f (Filter.liminf a F)\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _auto✝\nbdd_below : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _auto✝\n⊢ Eq (f (Filter.liminf a F)) (Filter.limsup (Function.comp f a) F)","decl":"/-- A continuous antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.liminf` to the `Filter.limsup` of the images (if the filter is bounded from below and\nfrequently bounded from above). -/\ntheorem Antitone.map_liminf_of_continuousAt {f : R → S} (f_decr : Antitone f) (a : ι → R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (· ≥ ·) a := by isBoundedDefault) :\n    f (F.liminf a) = F.limsup (f ∘ a) :=\n  f_decr.map_limsInf_of_continuousAt f_cont cobdd bdd_below\n\n"}
{"name":"Monotone.map_limsSup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\ninst✝³ : ConditionallyCompleteLinearOrder S\ninst✝² : TopologicalSpace S\ninst✝¹ : OrderTopology S\nF : Filter R\ninst✝ : F.NeBot\nf : R → S\nf_incr : Monotone f\nf_cont : ContinuousAt f F.limsSup\nbdd_above : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) F) _auto✝\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F) _auto✝\n⊢ Eq (f F.limsSup) (Filter.limsup f F)","decl":"/-- A monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsSup` to the `Filter.limsup` of the image if the function is continuous at the `limsSup`\n(and the filter is bounded from above and frequently bounded from below). -/\ntheorem Monotone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R → S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (· ≤ ·) := by isBoundedDefault)\n    (cobdd : F.IsCobounded (· ≤ ·) := by isBoundedDefault) : f F.limsSup = F.limsup f :=\n  Antitone.map_limsSup_of_continuousAt (S := Sᵒᵈ) f_incr f_cont bdd_above cobdd\n\n"}
{"name":"Monotone.map_limsup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter ι\ninst✝⁶ : F.NeBot\ninst✝⁵ : ConditionallyCompleteLinearOrder R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : OrderTopology R\ninst✝² : ConditionallyCompleteLinearOrder S\ninst✝¹ : TopologicalSpace S\ninst✝ : OrderTopology S\nf : R → S\nf_incr : Monotone f\na : ι → R\nf_cont : ContinuousAt f (Filter.limsup a F)\nbdd_above : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F a) _auto✝\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F a) _auto✝\n⊢ Eq (f (Filter.limsup a F)) (Filter.limsup (Function.comp f a) F)","decl":"/-- A continuous monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsup` to the `Filter.limsup` of the images (if the filter is bounded from above and\nfrequently bounded from below). -/\ntheorem Monotone.map_limsup_of_continuousAt {f : R → S} (f_incr : Monotone f) (a : ι → R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) a := by isBoundedDefault)\n    (cobdd : F.IsCoboundedUnder (· ≤ ·) a := by isBoundedDefault) :\n    f (F.limsup a) = F.limsup (f ∘ a) :=\n  f_incr.map_limsSup_of_continuousAt f_cont bdd_above cobdd\n\n"}
{"name":"Monotone.map_limsInf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\ninst✝³ : ConditionallyCompleteLinearOrder S\ninst✝² : TopologicalSpace S\ninst✝¹ : OrderTopology S\nF : Filter R\ninst✝ : F.NeBot\nf : R → S\nf_incr : Monotone f\nf_cont : ContinuousAt f F.limsInf\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F) _auto✝\nbdd_below : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) F) _auto✝\n⊢ Eq (f F.limsInf) (Filter.liminf f F)","decl":"/-- A monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsInf` to the `Filter.liminf` of the image if the function is continuous at the `limsInf`\n(and the filter is bounded from below and frequently bounded from above). -/\ntheorem Monotone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R → S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsInf)\n    (cobdd : F.IsCobounded (· ≥ ·) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (· ≥ ·) := by isBoundedDefault) : f F.limsInf = F.liminf f :=\n  Antitone.map_limsSup_of_continuousAt (R := Rᵒᵈ) f_incr.dual f_cont bdd_below cobdd\n\n"}
{"name":"Monotone.map_liminf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter ι\ninst✝⁶ : F.NeBot\ninst✝⁵ : ConditionallyCompleteLinearOrder R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : OrderTopology R\ninst✝² : ConditionallyCompleteLinearOrder S\ninst✝¹ : TopologicalSpace S\ninst✝ : OrderTopology S\nf : R → S\nf_incr : Monotone f\na : ι → R\nf_cont : ContinuousAt f (Filter.liminf a F)\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _auto✝\nbdd_below : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _auto✝\n⊢ Eq (f (Filter.liminf a F)) (Filter.liminf (Function.comp f a) F)","decl":"/-- A continuous monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.liminf` to the `Filter.liminf` of the images (if the filter is bounded from below and\nfrequently bounded from above). -/\ntheorem Monotone.map_liminf_of_continuousAt {f : R → S} (f_incr : Monotone f) (a : ι → R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (· ≥ ·) a := by isBoundedDefault) :\n    f (F.liminf a) = F.liminf (f ∘ a) :=\n  f_incr.map_limsInf_of_continuousAt f_cont cobdd bdd_below\n\n"}
{"name":"le_limsup_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : DenselyOrdered α\ninst✝¹ : CovariantClass α α (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → α\nh₁ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₃ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\nh₄ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\n⊢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"lemma le_limsup_add (h₁ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u := by isBoundedDefault)\n    (h₂ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u := by isBoundedDefault)\n    (h₃ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v := by isBoundedDefault)\n    (h₄ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v := by isBoundedDefault) :\n    (limsup u f) + liminf v f ≤ limsup (u + v) f := by\n  have h := isCoboundedUnder_le_add h₄ h₂ -- These `have` tactic improve performance.\n  have h' := isBoundedUnder_le_add h₃ h₁\n  rw [add_comm] at h h'\n  refine add_le_of_forall_lt fun a a_u b b_v ↦ (le_limsup_iff h h').2 fun c c_ab ↦ ?_\n  refine ((frequently_lt_of_lt_limsup h₂ a_u).and_eventually\n    (eventually_lt_of_lt_liminf b_v h₄)).mono fun _ ab_x ↦ ?_\n  exact c_ab.trans (add_lt_add ab_x.1 ab_x.2)\n\n"}
{"name":"limsup_add_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : DenselyOrdered α\ninst✝¹ : CovariantClass α α (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → α\nh₁ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₃ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\nh₄ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\n⊢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_add_le (h₁ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f u := by isBoundedDefault)\n    (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u := by isBoundedDefault)\n    (h₃ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v := by isBoundedDefault)\n    (h₄ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v := by isBoundedDefault) :\n    limsup (u + v) f ≤ (limsup u f) + limsup v f := by\n  have h := isCoboundedUnder_le_add h₁ h₃\n  have h' := isBoundedUnder_le_add h₂ h₄\n  refine le_add_of_forall_lt fun a a_u b b_v ↦ ?_\n  rw [limsup_le_iff h h']\n  intro c c_ab\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (add_lt_add a_x b_x).trans c_ab\n\n"}
{"name":"le_liminf_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : DenselyOrdered α\ninst✝¹ : CovariantClass α α (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → α\nh₁ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₃ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\nh₄ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\n⊢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma le_liminf_add (h₁ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f u := by isBoundedDefault)\n    (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u := by isBoundedDefault)\n    (h₃ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v := by isBoundedDefault)\n    (h₄ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v := by isBoundedDefault) :\n    (liminf u f) + liminf v f ≤ liminf (u + v) f := by\n  have h := isCoboundedUnder_ge_add h₂ h₄\n  have h' := isBoundedUnder_ge_add h₁ h₃\n  refine add_le_of_forall_lt fun a a_u b b_v ↦ ?_\n  rw [le_liminf_iff h h']\n  intro c c_ab\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (add_lt_add a_x b_x)\n\n"}
{"name":"liminf_add_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝⁴ : AddCommGroup α\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : DenselyOrdered α\ninst✝¹ : CovariantClass α α (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → α\nh₁ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₃ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\nh₄ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\n⊢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_add_le (h₁ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f u := by isBoundedDefault)\n    (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u := by isBoundedDefault)\n    (h₃ : IsBoundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v := by isBoundedDefault)\n    (h₄ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v := by isBoundedDefault) :\n    liminf (u + v) f ≤ (limsup u f) + liminf v f := by\n  have h := isCoboundedUnder_ge_add h₂ h₄\n  have h' := isBoundedUnder_ge_add h₁ h₃\n  refine le_add_of_forall_lt fun a a_u b b_v ↦ (liminf_le_iff h h').2 fun _ c_ab ↦ ?_\n  refine ((frequently_lt_of_liminf_lt h₄ b_v).and_eventually\n    (eventually_lt_of_limsup_lt a_u h₂)).mono fun _ ab_x ↦ ?_\n  exact (add_lt_add ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"le_limsup_mul","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → Real\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ LE.le (HMul.hMul (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HMul.hMul u v) f)","decl":"lemma le_limsup_mul (h₁ : 0 ≤ᶠ[f] u) (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v) (h₄ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v) :\n    (limsup u f) * liminf v f ≤ limsup (u * v) f := by\n  have h := (isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h₁.and h₃).mono fun x ⟨u_0, v_0⟩ ↦ mul_nonneg u_0 v_0).isCoboundedUnder_le\n  have h' := isBoundedUnder_le_mul_of_nonneg h₁ h₂ h₃ h₄\n  have u0 : 0 ≤ limsup u f := le_limsup_of_frequently_le h₁.frequently h₂\n  have uv : 0 ≤ limsup (u * v) f :=\n    le_limsup_of_frequently_le ((h₁.and h₃).mono fun _ ⟨hu, hv⟩ ↦ mul_nonneg hu hv).frequently h'\n  refine mul_le_of_forall_lt_of_nonneg u0 uv fun a _ au b b0 bv ↦ (le_limsup_iff h h').2\n    fun c c_ab ↦ ?_\n  refine ((frequently_lt_of_lt_limsup\n    (isBoundedUnder_of_eventually_ge h₁).isCoboundedUnder_le au).and_eventually\n    ((eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge h₃)).and\n    (h₁.and h₃))).mono fun x ⟨xa, ⟨xb, u0, _⟩⟩ ↦ ?_\n  exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 u0)\n\n"}
{"name":"limsup_mul_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → Real\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ LE.le (Filter.limsup (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_mul_le (h₁ : 0 ≤ᶠ[f] u) (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v) (h₄ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v) :\n    limsup (u * v) f ≤ (limsup u f) * limsup v f := by\n  have h := (isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h₁.and h₃).mono fun x ⟨u_0, v_0⟩ ↦ mul_nonneg u_0 v_0).isCoboundedUnder_le\n  have h' := isBoundedUnder_le_mul_of_nonneg h₁ h₂ h₃ h₄\n  refine le_mul_of_forall_lt₀ fun a a_u b b_v ↦ (limsup_le_iff h h').2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v, h₁, h₃]\n    with x x_a x_b u_0 v_0\n  exact (mul_le_mul x_a.le x_b.le v_0 (u_0.trans x_a.le)).trans_lt c_ab\n\n"}
{"name":"le_liminf_mul","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → Real\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ LE.le (HMul.hMul (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HMul.hMul u v) f)","decl":"lemma le_liminf_mul (h₁ : 0 ≤ᶠ[f] u) (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v) (h₄ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v) :\n    (liminf u f) * liminf v f ≤ liminf (u * v) f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg h₁ h₂ h₃ h₄\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h₁.and h₃).mono fun x ⟨u0, v0⟩ ↦ mul_nonneg u0 v0\n  apply mul_le_of_forall_lt_of_nonneg (le_liminf_of_le h₂.isCoboundedUnder_ge h₁)\n    (le_liminf_of_le h ((h₁.and h₃).mono fun x ⟨u0, v0⟩ ↦ mul_nonneg u0 v0))\n  intro a a0 au b b0 bv\n  refine (le_liminf_iff h h').2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_lt_liminf au (isBoundedUnder_of_eventually_ge h₁),\n    eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge h₃)] with x xa xb\n  exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 (a0.trans xa.le))\n\n"}
{"name":"liminf_mul_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → Real\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ LE.le (Filter.liminf (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_mul_le (h₁ : 0 ≤ᶠ[f] u) (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v) (h₄ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v) :\n    liminf (u * v) f ≤ (limsup u f) * liminf v f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg h₁ h₂ h₃ h₄\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (h₁.and h₃).mono fun x ⟨u_0, v_0⟩ ↦ mul_nonneg u_0 v_0\n  refine le_mul_of_forall_lt₀ fun a a_u b b_v ↦ (liminf_le_iff h h').2 fun c c_ab ↦ ?_\n  refine ((frequently_lt_of_liminf_lt h₄ b_v).and_eventually ((eventually_lt_of_limsup_lt a_u).and\n    (h₁.and h₃))).mono fun x ⟨x_v, x_u, u_0, v_0⟩ ↦ ?_\n  exact (mul_le_mul x_u.le x_v.le v_0 (u_0.trans x_u.le)).trans_lt c_ab\n\n"}
{"name":"limsup_const_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\nF : Filter ι\ninst✝³ : F.NeBot\ninst✝² : Add R\ninst✝¹ : ContinuousAdd R\ninst✝ : AddLeftMono R\nf : ι → R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\n⊢ Eq (Filter.limsup (fun i => HAdd.hAdd c (f i)) F) (HAdd.hAdd c (Filter.limsup f F))","decl":"/-- `liminf (c + xᵢ) = c + liminf xᵢ`. -/\nlemma limsup_const_add (F : Filter ι) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddLeftMono R] (f : ι → R) (c : R)\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) f) (cobdd : F.IsCoboundedUnder (· ≤ ·) f) :\n    Filter.limsup (fun i ↦ c + f i) F = c + Filter.limsup f F :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ c + x)\n    (fun _ _ h ↦ add_le_add_left h c) (continuous_add_left c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"limsup_add_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\nF : Filter ι\ninst✝³ : F.NeBot\ninst✝² : Add R\ninst✝¹ : ContinuousAdd R\ninst✝ : AddRightMono R\nf : ι → R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\n⊢ Eq (Filter.limsup (fun i => HAdd.hAdd (f i) c) F) (HAdd.hAdd (Filter.limsup f F) c)","decl":"/-- `limsup (xᵢ + c) = (limsup xᵢ) + c`. -/\nlemma limsup_add_const (F : Filter ι) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddRightMono R] (f : ι → R) (c : R)\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) f) (cobdd : F.IsCoboundedUnder (· ≤ ·) f) :\n    Filter.limsup (fun i ↦ f i + c) F = Filter.limsup f F + c :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ x + c)\n    (fun _ _ h ↦ add_le_add_right h c) (continuous_add_right c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"liminf_const_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\nF : Filter ι\ninst✝³ : F.NeBot\ninst✝² : Add R\ninst✝¹ : ContinuousAdd R\ninst✝ : AddLeftMono R\nf : ι → R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\n⊢ Eq (Filter.liminf (fun i => HAdd.hAdd c (f i)) F) (HAdd.hAdd c (Filter.liminf f F))","decl":"/-- `liminf (c + xᵢ) = c + limsup xᵢ`. -/\nlemma liminf_const_add (F : Filter ι) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddLeftMono R] (f : ι → R) (c : R)\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) f) (bdd_below : F.IsBoundedUnder (· ≥ ·) f) :\n    Filter.liminf (fun i ↦ c + f i) F = c + Filter.liminf f F :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ c + x)\n    (fun _ _ h ↦ add_le_add_left h c) (continuous_add_left c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"liminf_add_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\nF : Filter ι\ninst✝³ : F.NeBot\ninst✝² : Add R\ninst✝¹ : ContinuousAdd R\ninst✝ : AddRightMono R\nf : ι → R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\n⊢ Eq (Filter.liminf (fun i => HAdd.hAdd (f i) c) F) (HAdd.hAdd (Filter.liminf f F) c)","decl":"/-- `liminf (xᵢ + c) = (liminf xᵢ) + c`. -/\nlemma liminf_add_const (F : Filter ι) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddRightMono R] (f : ι → R) (c : R)\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) f) (bdd_below : F.IsBoundedUnder (· ≥ ·) f) :\n    Filter.liminf (fun i ↦ f i + c) F = Filter.liminf f F + c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ x + c)\n    (fun _ _ h ↦ add_le_add_right h c) (continuous_add_right c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"limsup_const_sub","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁷ : ConditionallyCompleteLinearOrder R\ninst✝⁶ : TopologicalSpace R\ninst✝⁵ : OrderTopology R\nF : Filter ι\ninst✝⁴ : AddCommSemigroup R\ninst✝³ : Sub R\ninst✝² : ContinuousSub R\ninst✝¹ : OrderedSub R\ninst✝ : AddLeftMono R\nf : ι → R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\n⊢ Eq (Filter.limsup (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.liminf f F))","decl":"/-- `limsup (c - xᵢ) = c - liminf xᵢ`. -/\nlemma limsup_const_sub (F : Filter ι) [AddCommSemigroup R] [Sub R] [ContinuousSub R] [OrderedSub R]\n    [AddLeftMono R] (f : ι → R) (c : R)\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) f) (bdd_below : F.IsBoundedUnder (· ≥ ·) f) :\n    Filter.limsup (fun i ↦ c - f i) F = c - Filter.liminf f F := by\n  rcases F.eq_or_neBot with rfl | _\n  · simp only [liminf, limsInf, limsup, limsSup, map_bot, eventually_bot, Set.setOf_true]\n    simp only [IsCoboundedUnder, IsCobounded, map_bot, eventually_bot, true_implies] at cobdd\n    rcases cobdd with ⟨x, hx⟩\n    refine (csInf_le ?_ (Set.mem_univ _)).antisymm\n      (tsub_le_iff_tsub_le.1 (le_csSup ?_ (Set.mem_univ _)))\n    · refine ⟨x - x, mem_lowerBounds.2 fun y ↦ ?_⟩\n      simp only [Set.mem_univ, true_implies]\n      exact tsub_le_iff_tsub_le.1 (hx (x - y))\n    · refine ⟨x, mem_upperBounds.2 fun y ↦ ?_⟩\n      simp only [Set.mem_univ, hx y, implies_true]\n  · exact (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ c - x)\n    (fun _ _ h ↦ tsub_le_tsub_left h c) (continuous_sub_left c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"limsup_sub_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : ConditionallyCompleteLinearOrder R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : OrderTopology R\nF : Filter ι\ninst✝³ : AddCommSemigroup R\ninst✝² : Sub R\ninst✝¹ : ContinuousSub R\ninst✝ : OrderedSub R\nf : ι → R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\n⊢ Eq (Filter.limsup (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.limsup f F) c)","decl":"/-- `limsup (xᵢ - c) = (limsup xᵢ) - c`. -/\nlemma limsup_sub_const (F : Filter ι) [AddCommSemigroup R] [Sub R] [ContinuousSub R] [OrderedSub R]\n    (f : ι → R) (c : R)\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) f) (cobdd : F.IsCoboundedUnder (· ≤ ·) f) :\n    Filter.limsup (fun i ↦ f i - c) F = Filter.limsup f F - c := by\n  rcases F.eq_or_neBot with rfl | _\n  · have {a : R} : sInf Set.univ ≤ a := by\n      apply csInf_le _ (Set.mem_univ a)\n      simp only [IsCoboundedUnder, IsCobounded, map_bot, eventually_bot, true_implies] at cobdd\n      rcases cobdd with ⟨x, hx⟩\n      refine ⟨x, mem_lowerBounds.2 fun y ↦ ?_⟩\n      simp only [Set.mem_univ, hx y, implies_true]\n    simp only [limsup, limsSup, map_bot, eventually_bot, Set.setOf_true]\n    exact this.antisymm (tsub_le_iff_right.2 this)\n  · apply (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ x - c) _ _).symm\n    · exact fun _ _ h ↦ tsub_le_tsub_right h c\n    · exact (continuous_sub_right c).continuousAt\n\n"}
{"name":"liminf_const_sub","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁸ : ConditionallyCompleteLinearOrder R\ninst✝⁷ : TopologicalSpace R\ninst✝⁶ : OrderTopology R\nF : Filter ι\ninst✝⁵ : F.NeBot\ninst✝⁴ : AddCommSemigroup R\ninst✝³ : Sub R\ninst✝² : ContinuousSub R\ninst✝¹ : OrderedSub R\ninst✝ : AddLeftMono R\nf : ι → R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\n⊢ Eq (Filter.liminf (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.limsup f F))","decl":"/-- `liminf (c - xᵢ) = c - limsup xᵢ`. -/\nlemma liminf_const_sub (F : Filter ι) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] [AddLeftMono R] (f : ι → R) (c : R)\n    (bdd_above : F.IsBoundedUnder (· ≤ ·) f) (cobdd : F.IsCoboundedUnder (· ≤ ·) f) :\n    Filter.liminf (fun i ↦ c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ c - x)\n    (fun _ _ h ↦ tsub_le_tsub_left h c) (continuous_sub_left c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"liminf_sub_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁷ : ConditionallyCompleteLinearOrder R\ninst✝⁶ : TopologicalSpace R\ninst✝⁵ : OrderTopology R\nF : Filter ι\ninst✝⁴ : F.NeBot\ninst✝³ : AddCommSemigroup R\ninst✝² : Sub R\ninst✝¹ : ContinuousSub R\ninst✝ : OrderedSub R\nf : ι → R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\n⊢ Eq (Filter.liminf (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.liminf f F) c)","decl":"/-- `liminf (xᵢ - c) = (liminf xᵢ) - c`. -/\nlemma liminf_sub_const (F : Filter ι) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] (f : ι → R) (c : R)\n    (cobdd : F.IsCoboundedUnder (· ≥ ·) f) (bdd_below : F.IsBoundedUnder (· ≥ ·) f) :\n    Filter.liminf (fun i ↦ f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) ↦ x - c)\n    (fun _ _ h ↦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt cobdd bdd_below).symm\n\n"}
