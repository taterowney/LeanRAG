{"name":"BoundedLENhdsClass.isBounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_7\ninstâœÂ¹ : Preorder Î±\ninstâœ : TopologicalSpace Î±\nself : BoundedLENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"/-- Ad hoc typeclass stating that neighborhoods are eventually bounded above. -/\nclass BoundedLENhdsClass (Î± : Type*) [Preorder Î±] [TopologicalSpace Î±] : Prop where\n  isBounded_le_nhds (a : Î±) : (ğ“ a).IsBounded (Â· â‰¤ Â·)\n\n"}
{"name":"BoundedGENhdsClass.isBounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_7\ninstâœÂ¹ : Preorder Î±\ninstâœ : TopologicalSpace Î±\nself : BoundedGENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"/-- Ad hoc typeclass stating that neighborhoods are eventually bounded below. -/\nclass BoundedGENhdsClass (Î± : Type*) [Preorder Î±] [TopologicalSpace Î±] : Prop where\n  isBounded_ge_nhds (a : Î±) : (ğ“ a).IsBounded (Â· â‰¥ Â·)\n\n"}
{"name":"isBounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedLENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"theorem isBounded_le_nhds (a : Î±) : (ğ“ a).IsBounded (Â· â‰¤ Â·) :=\n  BoundedLENhdsClass.isBounded_le_nhds _\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedLENhdsClass Î±\nf : Filter Î¹\nu : Î¹ â†’ Î±\na : Î±\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Filter.Tendsto.isBoundedUnder_le (h : Tendsto u f (ğ“ a)) : f.IsBoundedUnder (Â· â‰¤ Â·) u :=\n  (isBounded_le_nhds a).mono h\n\n"}
{"name":"Filter.Tendsto.bddAbove_range_of_cofinite","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedLENhdsClass Î±\nu : Î¹ â†’ Î±\na : Î±\ninstâœ : IsDirected Î± fun x1 x2 => LE.le x1 x2\nh : Filter.Tendsto u Filter.cofinite (nhds a)\nâŠ¢ BddAbove (Set.range u)","decl":"theorem Filter.Tendsto.bddAbove_range_of_cofinite [IsDirected Î± (Â· â‰¤ Â·)]\n    (h : Tendsto u cofinite (ğ“ a)) : BddAbove (Set.range u) :=\n  h.isBoundedUnder_le.bddAbove_range_of_cofinite\n\n"}
{"name":"Filter.Tendsto.bddAbove_range","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedLENhdsClass Î±\na : Î±\ninstâœ : IsDirected Î± fun x1 x2 => LE.le x1 x2\nu : Nat â†’ Î±\nh : Filter.Tendsto u Filter.atTop (nhds a)\nâŠ¢ BddAbove (Set.range u)","decl":"theorem Filter.Tendsto.bddAbove_range [IsDirected Î± (Â· â‰¤ Â·)] {u : â„• â†’ Î±}\n    (h : Tendsto u atTop (ğ“ a)) : BddAbove (Set.range u) :=\n  h.isBoundedUnder_le.bddAbove_range\n\n"}
{"name":"isCobounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedLENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"theorem isCobounded_ge_nhds (a : Î±) : (ğ“ a).IsCobounded (Â· â‰¥ Â·) :=\n  (isBounded_le_nhds a).isCobounded_flip\n\n"}
{"name":"Filter.Tendsto.isCoboundedUnder_ge","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedLENhdsClass Î±\nf : Filter Î¹\nu : Î¹ â†’ Î±\na : Î±\ninstâœ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Filter.Tendsto.isCoboundedUnder_ge [NeBot f] (h : Tendsto u f (ğ“ a)) :\n    f.IsCoboundedUnder (Â· â‰¥ Â·) u :=\n  h.isBoundedUnder_le.isCobounded_flip\n\n"}
{"name":"instBoundedGENhdsClassOrderDual","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedLENhdsClass Î±\nâŠ¢ BoundedGENhdsClass (OrderDual Î±)","decl":"instance : BoundedGENhdsClass Î±áµ’áµˆ := âŸ¨@isBounded_le_nhds Î± _ _ _âŸ©\n\n"}
{"name":"Prod.instBoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nâŠ¢ BoundedLENhdsClass (Prod Î± Î²)","decl":"instance Prod.instBoundedLENhdsClass : BoundedLENhdsClass (Î± Ã— Î²) := by\n  refine âŸ¨fun x â†¦ ?_âŸ©\n  obtain âŸ¨a, haâŸ© := isBounded_le_nhds x.1\n  obtain âŸ¨b, hbâŸ© := isBounded_le_nhds x.2\n  rw [â† @Prod.mk.eta _ _ x, nhds_prod_eq]\n  exact âŸ¨(a, b), ha.prod_mk hbâŸ©\n\n"}
{"name":"Pi.instBoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ³ : Finite Î¹\ninstâœÂ² : (i : Î¹) â†’ Preorder (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : âˆ€ (i : Î¹), BoundedLENhdsClass (Ï€ i)\nâŠ¢ BoundedLENhdsClass ((i : Î¹) â†’ Ï€ i)","decl":"instance Pi.instBoundedLENhdsClass [Finite Î¹] [âˆ€ i, Preorder (Ï€ i)] [âˆ€ i, TopologicalSpace (Ï€ i)]\n    [âˆ€ i, BoundedLENhdsClass (Ï€ i)] : BoundedLENhdsClass (âˆ€ i, Ï€ i) := by\n  refine âŸ¨fun x â†¦ ?_âŸ©\n  rw [nhds_pi]\n  choose f hf using fun i â†¦ isBounded_le_nhds (x i)\n  exact âŸ¨f, eventually_pi hfâŸ©\n\n"}
{"name":"isBounded_ge_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedGENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) (nhds a)","decl":"theorem isBounded_ge_nhds (a : Î±) : (ğ“ a).IsBounded (Â· â‰¥ Â·) :=\n  BoundedGENhdsClass.isBounded_ge_nhds _\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_ge","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedGENhdsClass Î±\nf : Filter Î¹\nu : Î¹ â†’ Î±\na : Î±\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Filter.Tendsto.isBoundedUnder_ge (h : Tendsto u f (ğ“ a)) : f.IsBoundedUnder (Â· â‰¥ Â·) u :=\n  (isBounded_ge_nhds a).mono h\n\n"}
{"name":"Filter.Tendsto.bddBelow_range_of_cofinite","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedGENhdsClass Î±\nu : Î¹ â†’ Î±\na : Î±\ninstâœ : IsDirected Î± fun x1 x2 => GE.ge x1 x2\nh : Filter.Tendsto u Filter.cofinite (nhds a)\nâŠ¢ BddBelow (Set.range u)","decl":"theorem Filter.Tendsto.bddBelow_range_of_cofinite [IsDirected Î± (Â· â‰¥ Â·)]\n    (h : Tendsto u cofinite (ğ“ a)) : BddBelow (Set.range u) :=\n  h.isBoundedUnder_ge.bddBelow_range_of_cofinite\n\n"}
{"name":"Filter.Tendsto.bddBelow_range","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedGENhdsClass Î±\na : Î±\ninstâœ : IsDirected Î± fun x1 x2 => GE.ge x1 x2\nu : Nat â†’ Î±\nh : Filter.Tendsto u Filter.atTop (nhds a)\nâŠ¢ BddBelow (Set.range u)","decl":"theorem Filter.Tendsto.bddBelow_range [IsDirected Î± (Â· â‰¥ Â·)] {u : â„• â†’ Î±}\n    (h : Tendsto u atTop (ğ“ a)) : BddBelow (Set.range u) :=\n  h.isBoundedUnder_ge.bddBelow_range\n\n"}
{"name":"isCobounded_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedGENhdsClass Î±\na : Î±\nâŠ¢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) (nhds a)","decl":"theorem isCobounded_le_nhds (a : Î±) : (ğ“ a).IsCobounded (Â· â‰¤ Â·) :=\n  (isBounded_ge_nhds a).isCobounded_flip\n\n"}
{"name":"Filter.Tendsto.isCoboundedUnder_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : BoundedGENhdsClass Î±\nf : Filter Î¹\nu : Î¹ â†’ Î±\na : Î±\ninstâœ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Filter.Tendsto.isCoboundedUnder_le [NeBot f] (h : Tendsto u f (ğ“ a)) :\n    f.IsCoboundedUnder (Â· â‰¤ Â·) u :=\n  h.isBoundedUnder_ge.isCobounded_flip\n\n"}
{"name":"instBoundedLENhdsClassOrderDual","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : BoundedGENhdsClass Î±\nâŠ¢ BoundedLENhdsClass (OrderDual Î±)","decl":"instance : BoundedLENhdsClass Î±áµ’áµˆ := âŸ¨@isBounded_ge_nhds Î± _ _ _âŸ©\n\n"}
{"name":"Prod.instBoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : Preorder Î±\ninstâœÂ² : Preorder Î²\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nâŠ¢ BoundedGENhdsClass (Prod Î± Î²)","decl":"instance Prod.instBoundedGENhdsClass : BoundedGENhdsClass (Î± Ã— Î²) :=\n  âŸ¨(Prod.instBoundedLENhdsClass (Î± := Î±áµ’áµˆ) (Î² := Î²áµ’áµˆ)).isBounded_le_nhdsâŸ©\n\n"}
{"name":"Pi.instBoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÏ€ : Î¹ â†’ Type u_6\ninstâœÂ³ : Finite Î¹\ninstâœÂ² : (i : Î¹) â†’ Preorder (Ï€ i)\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (Ï€ i)\ninstâœ : âˆ€ (i : Î¹), BoundedGENhdsClass (Ï€ i)\nâŠ¢ BoundedGENhdsClass ((i : Î¹) â†’ Ï€ i)","decl":"instance Pi.instBoundedGENhdsClass [Finite Î¹] [âˆ€ i, Preorder (Ï€ i)] [âˆ€ i, TopologicalSpace (Ï€ i)]\n    [âˆ€ i, BoundedGENhdsClass (Ï€ i)] : BoundedGENhdsClass (âˆ€ i, Ï€ i) :=\n  âŸ¨(Pi.instBoundedLENhdsClass (Ï€ := fun i â†¦ (Ï€ i)áµ’áµˆ)).isBounded_le_nhdsâŸ©\n\n"}
{"name":"OrderTop.to_BoundedLENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTop Î±\nâŠ¢ BoundedLENhdsClass Î±","decl":"instance (priority := 100) OrderTop.to_BoundedLENhdsClass [OrderTop Î±] : BoundedLENhdsClass Î± :=\n  âŸ¨fun _a â†¦ isBounded_le_of_topâŸ©\n\n-- See note [lower instance priority]\n"}
{"name":"OrderBot.to_BoundedGENhdsClass","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : Preorder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderBot Î±\nâŠ¢ BoundedGENhdsClass Î±","decl":"instance (priority := 100) OrderBot.to_BoundedGENhdsClass [OrderBot Î±] : BoundedGENhdsClass Î± :=\n  âŸ¨fun _a â†¦ isBounded_ge_of_botâŸ©\n\n"}
{"name":"BoundedLENhdsClass.of_closedIciTopology","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ClosedIciTopology Î±\nâŠ¢ BoundedLENhdsClass Î±","decl":"instance (priority := 100) BoundedLENhdsClass.of_closedIciTopology [LinearOrder Î±]\n    [TopologicalSpace Î±] [ClosedIciTopology Î±] : BoundedLENhdsClass Î± :=\n  âŸ¨fun a â†¦ ((isTop_or_exists_gt a).elim fun h â†¦ âŸ¨a, Eventually.of_forall hâŸ©) <|\n    Exists.imp fun _b â†¦ eventually_le_nhdsâŸ©\n\n-- See note [lower instance priority]\n"}
{"name":"BoundedGENhdsClass.of_closedIicTopology","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : LinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : ClosedIicTopology Î±\nâŠ¢ BoundedGENhdsClass Î±","decl":"instance (priority := 100) BoundedGENhdsClass.of_closedIicTopology [LinearOrder Î±]\n    [TopologicalSpace Î±] [ClosedIicTopology Î±] : BoundedGENhdsClass Î± :=\n  inferInstanceAs <| BoundedGENhdsClass Î±áµ’áµˆáµ’áµˆ\n\n"}
{"name":"le_nhds_of_limsSup_eq_limsInf","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\nf : Filter Î±\na : Î±\nhl : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\nhg : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\nhs : Eq f.limsSup a\nhi : Eq f.limsInf a\nâŠ¢ LE.le f (nhds a)","decl":"/-- If the liminf and the limsup of a filter coincide, then this filter converges to\ntheir common value, at least if the filter is eventually bounded above and below. -/\ntheorem le_nhds_of_limsSup_eq_limsInf {f : Filter Î±} {a : Î±} (hl : f.IsBounded (Â· â‰¤ Â·))\n    (hg : f.IsBounded (Â· â‰¥ Â·)) (hs : f.limsSup = a) (hi : f.limsInf = a) : f â‰¤ ğ“ a :=\n  tendsto_order.2 âŸ¨fun _ hb â†¦ gt_mem_sets_of_limsInf_gt hg <| hi.symm â–¸ hb,\n    fun _ hb â†¦ lt_mem_sets_of_limsSup_lt hl <| hs.symm â–¸ hbâŸ©\n\n"}
{"name":"limsSup_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\na : Î±\nâŠ¢ Eq (nhds a).limsSup a","decl":"theorem limsSup_nhds (a : Î±) : limsSup (ğ“ a) = a :=\n  csInf_eq_of_forall_ge_of_forall_gt_exists_lt (isBounded_le_nhds a)\n    (fun a' (h : { n : Î± | n â‰¤ a' } âˆˆ ğ“ a) â†¦ show a â‰¤ a' from @mem_of_mem_nhds Î± a _ _ h)\n    fun b (hba : a < b) â†¦\n    show âˆƒ c, { n : Î± | n â‰¤ c } âˆˆ ğ“ a âˆ§ c < b from\n      match dense_or_discrete a b with\n      | Or.inl âŸ¨c, hac, hcbâŸ© => âŸ¨c, ge_mem_nhds hac, hcbâŸ©\n      | Or.inr âŸ¨_, hâŸ© => âŸ¨a, (ğ“ a).sets_of_superset (gt_mem_nhds hba) h, hbaâŸ©\n\n"}
{"name":"limsInf_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\na : Î±\nâŠ¢ Eq (nhds a).limsInf a","decl":"theorem limsInf_nhds (a : Î±) : limsInf (ğ“ a) = a :=\n  limsSup_nhds (Î± := Î±áµ’áµˆ) a\n\n"}
{"name":"limsInf_eq_of_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î±\na : Î±\ninstâœ : f.NeBot\nh : LE.le f (nhds a)\nâŠ¢ Eq f.limsInf a","decl":"/-- If a filter is converging, its limsup coincides with its limit. -/\ntheorem limsInf_eq_of_le_nhds {f : Filter Î±} {a : Î±} [NeBot f] (h : f â‰¤ ğ“ a) : f.limsInf = a :=\n  have hb_ge : IsBounded (Â· â‰¥ Â·) f := (isBounded_ge_nhds a).mono h\n  have hb_le : IsBounded (Â· â‰¤ Â·) f := (isBounded_le_nhds a).mono h\n  le_antisymm\n    (calc\n      f.limsInf â‰¤ f.limsSup := limsInf_le_limsSup hb_le hb_ge\n      _ â‰¤ (ğ“ a).limsSup := limsSup_le_limsSup_of_le h hb_ge.isCobounded_flip (isBounded_le_nhds a)\n      _ = a := limsSup_nhds a)\n    (calc\n      a = (ğ“ a).limsInf := (limsInf_nhds a).symm\n      _ â‰¤ f.limsInf := limsInf_le_limsInf_of_le h (isBounded_ge_nhds a) hb_le.isCobounded_flip)\n\n"}
{"name":"limsSup_eq_of_le_nhds","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î±\na : Î±\ninstâœ : f.NeBot\nh : LE.le f (nhds a)\nâŠ¢ Eq f.limsSup a","decl":"/-- If a filter is converging, its liminf coincides with its limit. -/\ntheorem limsSup_eq_of_le_nhds {f : Filter Î±} {a : Î±} [NeBot f] (h : f â‰¤ ğ“ a) : f.limsSup = a :=\n  limsInf_eq_of_le_nhds (Î± := Î±áµ’áµˆ) h\n\n"}
{"name":"Filter.Tendsto.limsup_eq","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î²\nu : Î² â†’ Î±\na : Î±\ninstâœ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Eq (Filter.limsup u f) a","decl":"/-- If a function has a limit, then its limsup coincides with its limit. -/\ntheorem Filter.Tendsto.limsup_eq {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [NeBot f]\n    (h : Tendsto u f (ğ“ a)) : limsup u f = a :=\n  limsSup_eq_of_le_nhds h\n\n"}
{"name":"Filter.Tendsto.liminf_eq","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î²\nu : Î² â†’ Î±\na : Î±\ninstâœ : f.NeBot\nh : Filter.Tendsto u f (nhds a)\nâŠ¢ Eq (Filter.liminf u f) a","decl":"/-- If a function has a limit, then its liminf coincides with its limit. -/\ntheorem Filter.Tendsto.liminf_eq {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} [NeBot f]\n    (h : Tendsto u f (ğ“ a)) : liminf u f = a :=\n  limsInf_eq_of_le_nhds h\n\n"}
{"name":"tendsto_of_liminf_eq_limsup","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\nf : Filter Î²\nu : Î² â†’ Î±\na : Î±\nhinf : Eq (Filter.liminf u f) a\nhsup : Eq (Filter.limsup u f) a\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nâŠ¢ Filter.Tendsto u f (nhds a)","decl":"/-- If the liminf and the limsup of a function coincide, then the limit of the function\nexists and has the same value. -/\ntheorem tendsto_of_liminf_eq_limsup {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : liminf u f = a)\n    (hsup : limsup u f = a) (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) : Tendsto u f (ğ“ a) :=\n  le_nhds_of_limsSup_eq_limsInf h h' hsup hinf\n\n"}
{"name":"tendsto_of_le_liminf_of_limsup_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : ConditionallyCompleteLinearOrder Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : OrderTopology Î±\nf : Filter Î²\nu : Î² â†’ Î±\na : Î±\nhinf : LE.le a (Filter.liminf u f)\nhsup : LE.le (Filter.limsup u f) a\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nâŠ¢ Filter.Tendsto u f (nhds a)","decl":"/-- If a number `a` is less than or equal to the `liminf` of a function `f` at some filter\nand is greater than or equal to the `limsup` of `f`, then `f` tends to `a` along this filter. -/\ntheorem tendsto_of_le_liminf_of_limsup_le {f : Filter Î²} {u : Î² â†’ Î±} {a : Î±} (hinf : a â‰¤ liminf u f)\n    (hsup : limsup u f â‰¤ a) (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) : Tendsto u f (ğ“ a) := by\n  rcases f.eq_or_neBot with rfl | _\n  Â· exact tendsto_bot\n  Â· exact tendsto_of_liminf_eq_limsup (le_antisymm (le_trans (liminf_le_limsup h h') hsup) hinf)\n      (le_antisymm hsup (le_trans hinf (liminf_le_limsup h h'))) h h'\n\n"}
{"name":"tendsto_of_no_upcrossings","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : OrderTopology Î±\ninstâœ : DenselyOrdered Î±\nf : Filter Î²\nu : Î² â†’ Î±\ns : Set Î±\nhs : Dense s\nH : âˆ€ (a : Î±), Membership.mem s a â†’ âˆ€ (b : Î±), Membership.mem s b â†’ LT.lt a b â†’ Not (And (Filter.Frequently (fun n => LT.lt (u n) a) f) (Filter.Frequently (fun n => LT.lt b (u n)) f))\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nâŠ¢ Exists fun c => Filter.Tendsto u f (nhds c)","decl":"/-- Assume that, for any `a < b`, a sequence can not be infinitely many times below `a` and\nabove `b`. If it is also ultimately bounded above and below, then it has to converge. This even\nworks if `a` and `b` are restricted to a dense subset.\n-/\ntheorem tendsto_of_no_upcrossings [DenselyOrdered Î±] {f : Filter Î²} {u : Î² â†’ Î±} {s : Set Î±}\n    (hs : Dense s) (H : âˆ€ a âˆˆ s, âˆ€ b âˆˆ s, a < b â†’ Â¬((âˆƒá¶  n in f, u n < a) âˆ§ âˆƒá¶  n in f, b < u n))\n    (h : f.IsBoundedUnder (Â· â‰¤ Â·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (Â· â‰¥ Â·) u := by isBoundedDefault) :\n    âˆƒ c : Î±, Tendsto u f (ğ“ c) := by\n  rcases f.eq_or_neBot with rfl | hbot\n  Â· exact âŸ¨sInf âˆ…, tendsto_botâŸ©\n  refine âŸ¨limsup u f, ?_âŸ©\n  apply tendsto_of_le_liminf_of_limsup_le _ le_rfl h h'\n  by_contra! hlt\n  obtain âŸ¨a, âŸ¨âŸ¨la, auâŸ©, asâŸ©âŸ© : âˆƒ a, (f.liminf u < a âˆ§ a < f.limsup u) âˆ§ a âˆˆ s :=\n    dense_iff_inter_open.1 hs (Set.Ioo (f.liminf u) (f.limsup u)) isOpen_Ioo\n      (Set.nonempty_Ioo.2 hlt)\n  obtain âŸ¨b, âŸ¨âŸ¨ab, buâŸ©, bsâŸ©âŸ© : âˆƒ b, (a < b âˆ§ b < f.limsup u) âˆ§ b âˆˆ s :=\n    dense_iff_inter_open.1 hs (Set.Ioo a (f.limsup u)) isOpen_Ioo (Set.nonempty_Ioo.2 au)\n  have A : âˆƒá¶  n in f, u n < a := frequently_lt_of_liminf_lt (IsBounded.isCobounded_ge h) la\n  have B : âˆƒá¶  n in f, b < u n := frequently_lt_of_lt_limsup (IsBounded.isCobounded_le h') bu\n  exact H a as b bs ab âŸ¨A, BâŸ©\n\n"}
{"name":"eventually_le_limsup","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : FirstCountableTopology Î±\nf : Filter Î²\ninstâœ : CountableInterFilter f\nu : Î² â†’ Î±\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nâŠ¢ Filter.Eventually (fun b => LE.le (u b) (Filter.limsup u f)) f","decl":"theorem eventually_le_limsup (hf : IsBoundedUnder (Â· â‰¤ Â·) f u := by isBoundedDefault) :\n    âˆ€á¶  b in f, u b â‰¤ f.limsup u := by\n  obtain ha | ha := isTop_or_exists_gt (f.limsup u)\n  Â· exact Eventually.of_forall fun _ => ha _\n  by_cases H : IsGLB (Set.Ioi (f.limsup u)) (f.limsup u)\n  Â· obtain âŸ¨u, -, -, hua, huâŸ© := H.exists_seq_antitone_tendsto ha\n    have := fun n => eventually_lt_of_limsup_lt (hu n) hf\n    exact\n      (eventually_countable_forall.2 this).mono fun b hb =>\n        ge_of_tendsto hua <| Eventually.of_forall fun n => (hb _).le\n  Â· obtain âŸ¨x, hx, xaâŸ© : âˆƒ x, (âˆ€ â¦ƒbâ¦„, f.limsup u < b â†’ x â‰¤ b) âˆ§ f.limsup u < x := by\n      simp only [IsGLB, IsGreatest, lowerBounds, upperBounds, Set.mem_Ioi, Set.mem_setOf_eq,\n        not_and, not_forall, not_le, exists_prop] at H\n      exact H fun x => le_of_lt\n    filter_upwards [eventually_lt_of_limsup_lt xa hf] with y hy\n    contrapose! hy\n    exact hx hy\n\n"}
{"name":"eventually_liminf_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : OrderTopology Î±\ninstâœÂ¹ : FirstCountableTopology Î±\nf : Filter Î²\ninstâœ : CountableInterFilter f\nu : Î² â†’ Î±\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nâŠ¢ Filter.Eventually (fun b => LE.le (Filter.liminf u f) (u b)) f","decl":"theorem eventually_liminf_le (hf : IsBoundedUnder (Â· â‰¥ Â·) f u := by isBoundedDefault) :\n    âˆ€á¶  b in f, f.liminf u â‰¤ u b :=\n  eventually_le_limsup (Î± := Î±áµ’áµˆ) hf\n\n"}
{"name":"limsup_eq_bot","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : CompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : FirstCountableTopology Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î²\ninstâœ : CountableInterFilter f\nu : Î² â†’ Î±\nâŠ¢ Iff (Eq (Filter.limsup u f) Bot.bot) (f.EventuallyEq u Bot.bot)","decl":"@[simp]\ntheorem limsup_eq_bot : f.limsup u = âŠ¥ â†” u =á¶ [f] âŠ¥ :=\n  âŸ¨fun h =>\n    (EventuallyLE.trans eventually_le_limsup <| Eventually.of_forall fun _ => h.le).mono fun _ hx =>\n      le_antisymm hx bot_le,\n    fun h => by\n    rw [limsup_congr h]\n    exact limsup_const_botâŸ©\n\n"}
{"name":"liminf_eq_top","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : CompleteLinearOrder Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : FirstCountableTopology Î±\ninstâœÂ¹ : OrderTopology Î±\nf : Filter Î²\ninstâœ : CountableInterFilter f\nu : Î² â†’ Î±\nâŠ¢ Iff (Eq (Filter.liminf u f) Top.top) (f.EventuallyEq u Top.top)","decl":"@[simp]\ntheorem liminf_eq_top : f.liminf u = âŠ¤ â†” u =á¶ [f] âŠ¤ :=\n  limsup_eq_bot (Î± := Î±áµ’áµˆ)\n\n"}
{"name":"Antitone.map_limsSup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\ninstâœÂ³ : ConditionallyCompleteLinearOrder S\ninstâœÂ² : TopologicalSpace S\ninstâœÂ¹ : OrderTopology S\nF : Filter R\ninstâœ : F.NeBot\nf : R â†’ S\nf_decr : Antitone f\nf_cont : ContinuousAt f F.limsSup\nbdd_above : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) F) _autoâœ\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F) _autoâœ\nâŠ¢ Eq (f F.limsSup) (Filter.liminf f F)","decl":"/-- An antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsSup` to the `Filter.liminf` of the image if the function is continuous at the `limsSup`\n(and the filter is bounded from above and frequently bounded from below). -/\ntheorem Antitone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R â†’ S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (Â· â‰¤ Â·) := by isBoundedDefault)\n    (cobdd : F.IsCobounded (Â· â‰¤ Â·) := by isBoundedDefault) :\n    f F.limsSup = F.liminf f := by\n  apply le_antisymm\n  Â· rw [limsSup, f_decr.map_csInf_of_continuousAt f_cont bdd_above cobdd]\n    apply le_of_forall_lt\n    intro c hc\n    simp only [liminf, limsInf, eventually_map] at hc âŠ¢\n    obtain âŸ¨d, hd, h'dâŸ© :=\n      exists_lt_of_lt_csSup (bdd_above.recOn fun x hx â†¦ âŸ¨f x, Set.mem_image_of_mem f hxâŸ©) hc\n    apply lt_csSup_of_lt ?_ ?_ h'd\n    Â· simpa only [BddAbove, upperBounds]\n        using Antitone.isCoboundedUnder_ge_of_isCobounded f_decr cobdd\n    Â· rcases hd with âŸ¨e, âŸ¨he, fe_eq_dâŸ©âŸ©\n      filter_upwards [he] with x hx using (fe_eq_d.symm â–¸ f_decr hx)\n  Â· by_cases h' : âˆƒ c, c < F.limsSup âˆ§ Set.Ioo c F.limsSup = âˆ…\n    Â· rcases h' with âŸ¨c, c_lt, hcâŸ©\n      have B : âˆƒá¶  n in F, F.limsSup â‰¤ n := by\n        apply (frequently_lt_of_lt_limsSup cobdd c_lt).mono\n        intro x hx\n        by_contra!\n        have : (Set.Ioo c F.limsSup).Nonempty := âŸ¨x, âŸ¨hx, thisâŸ©âŸ©\n        simp only [hc, Set.not_nonempty_empty] at this\n      apply liminf_le_of_frequently_le _ (bdd_above.isBoundedUnder f_decr)\n      exact B.mono fun x hx â†¦ f_decr hx\n    push_neg at h'\n    by_contra! H\n    have not_bot : Â¬ IsBot F.limsSup := fun maybe_bot â†¦\n      lt_irrefl (F.liminf f) <| lt_of_le_of_lt\n        (liminf_le_of_frequently_le (Frequently.of_forall (fun r â†¦ f_decr (maybe_bot r)))\n          (bdd_above.isBoundedUnder f_decr)) H\n    obtain âŸ¨l, l_lt, h'lâŸ© :\n        âˆƒ l < F.limsSup, Set.Ioc l F.limsSup âŠ† { x : R | f x < F.liminf f } := by\n      apply exists_Ioc_subset_of_mem_nhds ((tendsto_order.1 f_cont.tendsto).2 _ H)\n      simpa [IsBot] using not_bot\n    obtain âŸ¨m, l_m, m_ltâŸ© : (Set.Ioo l F.limsSup).Nonempty := by\n      contrapose! h'\n      exact âŸ¨l, l_lt, h'âŸ©\n    have B : F.liminf f â‰¤ f m := by\n      apply liminf_le_of_frequently_le _ _\n      Â· apply (frequently_lt_of_lt_limsSup cobdd m_lt).mono\n        exact fun x hx â†¦ f_decr hx.le\n      Â· exact IsBounded.isBoundedUnder f_decr bdd_above\n    have I : f m < F.liminf f := h'l âŸ¨l_m, m_lt.leâŸ©\n    exact lt_irrefl _ (B.trans_lt I)\n\n"}
{"name":"Antitone.map_limsup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter Î¹\ninstâœâ¶ : F.NeBot\ninstâœâµ : ConditionallyCompleteLinearOrder R\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : OrderTopology R\ninstâœÂ² : ConditionallyCompleteLinearOrder S\ninstâœÂ¹ : TopologicalSpace S\ninstâœ : OrderTopology S\nf : R â†’ S\nf_decr : Antitone f\na : Î¹ â†’ R\nf_cont : ContinuousAt f (Filter.limsup a F)\nbdd_above : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F a) _autoâœ\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F a) _autoâœ\nâŠ¢ Eq (f (Filter.limsup a F)) (Filter.liminf (Function.comp f a) F)","decl":"/-- A continuous antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsup` to the `Filter.liminf` of the images (if the filter is bounded from above and\nfrequently bounded from below). -/\ntheorem Antitone.map_limsup_of_continuousAt {f : R â†’ S} (f_decr : Antitone f) (a : Î¹ â†’ R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) a := by isBoundedDefault)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) a := by isBoundedDefault) :\n    f (F.limsup a) = F.liminf (f âˆ˜ a) :=\n  f_decr.map_limsSup_of_continuousAt f_cont bdd_above cobdd\n\n"}
{"name":"Antitone.map_limsInf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\ninstâœÂ³ : ConditionallyCompleteLinearOrder S\ninstâœÂ² : TopologicalSpace S\ninstâœÂ¹ : OrderTopology S\nF : Filter R\ninstâœ : F.NeBot\nf : R â†’ S\nf_decr : Antitone f\nf_cont : ContinuousAt f F.limsInf\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F) _autoâœ\nbdd_below : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) F) _autoâœ\nâŠ¢ Eq (f F.limsInf) (Filter.limsup f F)","decl":"/-- An antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsInf` to the `Filter.limsup` of the image if the function is continuous at the `limsInf`\n(and the filter is bounded from below and frequently bounded from above). -/\ntheorem Antitone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R â†’ S}\n    (f_decr : Antitone f) (f_cont : ContinuousAt f F.limsInf)\n    (cobdd : F.IsCobounded (Â· â‰¥ Â·) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (Â· â‰¥ Â·) := by isBoundedDefault) : f F.limsInf = F.limsup f :=\n  Antitone.map_limsSup_of_continuousAt (R := Ráµ’áµˆ) (S := Sáµ’áµˆ) f_decr.dual f_cont bdd_below cobdd\n\n"}
{"name":"Antitone.map_liminf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter Î¹\ninstâœâ¶ : F.NeBot\ninstâœâµ : ConditionallyCompleteLinearOrder R\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : OrderTopology R\ninstâœÂ² : ConditionallyCompleteLinearOrder S\ninstâœÂ¹ : TopologicalSpace S\ninstâœ : OrderTopology S\nf : R â†’ S\nf_decr : Antitone f\na : Î¹ â†’ R\nf_cont : ContinuousAt f (Filter.liminf a F)\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _autoâœ\nbdd_below : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _autoâœ\nâŠ¢ Eq (f (Filter.liminf a F)) (Filter.limsup (Function.comp f a) F)","decl":"/-- A continuous antitone function between (conditionally) complete linear ordered spaces sends a\n`Filter.liminf` to the `Filter.limsup` of the images (if the filter is bounded from below and\nfrequently bounded from above). -/\ntheorem Antitone.map_liminf_of_continuousAt {f : R â†’ S} (f_decr : Antitone f) (a : Î¹ â†’ R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) a := by isBoundedDefault) :\n    f (F.liminf a) = F.limsup (f âˆ˜ a) :=\n  f_decr.map_limsInf_of_continuousAt f_cont cobdd bdd_below\n\n"}
{"name":"Monotone.map_limsSup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\ninstâœÂ³ : ConditionallyCompleteLinearOrder S\ninstâœÂ² : TopologicalSpace S\ninstâœÂ¹ : OrderTopology S\nF : Filter R\ninstâœ : F.NeBot\nf : R â†’ S\nf_incr : Monotone f\nf_cont : ContinuousAt f F.limsSup\nbdd_above : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) F) _autoâœ\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F) _autoâœ\nâŠ¢ Eq (f F.limsSup) (Filter.limsup f F)","decl":"/-- A monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsSup` to the `Filter.limsup` of the image if the function is continuous at the `limsSup`\n(and the filter is bounded from above and frequently bounded from below). -/\ntheorem Monotone.map_limsSup_of_continuousAt {F : Filter R} [NeBot F] {f : R â†’ S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsSup)\n    (bdd_above : F.IsBounded (Â· â‰¤ Â·) := by isBoundedDefault)\n    (cobdd : F.IsCobounded (Â· â‰¤ Â·) := by isBoundedDefault) : f F.limsSup = F.limsup f :=\n  Antitone.map_limsSup_of_continuousAt (S := Sáµ’áµˆ) f_incr f_cont bdd_above cobdd\n\n"}
{"name":"Monotone.map_limsup_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter Î¹\ninstâœâ¶ : F.NeBot\ninstâœâµ : ConditionallyCompleteLinearOrder R\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : OrderTopology R\ninstâœÂ² : ConditionallyCompleteLinearOrder S\ninstâœÂ¹ : TopologicalSpace S\ninstâœ : OrderTopology S\nf : R â†’ S\nf_incr : Monotone f\na : Î¹ â†’ R\nf_cont : ContinuousAt f (Filter.limsup a F)\nbdd_above : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F a) _autoâœ\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F a) _autoâœ\nâŠ¢ Eq (f (Filter.limsup a F)) (Filter.limsup (Function.comp f a) F)","decl":"/-- A continuous monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsup` to the `Filter.limsup` of the images (if the filter is bounded from above and\nfrequently bounded from below). -/\ntheorem Monotone.map_limsup_of_continuousAt {f : R â†’ S} (f_incr : Monotone f) (a : Î¹ â†’ R)\n    (f_cont : ContinuousAt f (F.limsup a))\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) a := by isBoundedDefault)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) a := by isBoundedDefault) :\n    f (F.limsup a) = F.limsup (f âˆ˜ a) :=\n  f_incr.map_limsSup_of_continuousAt f_cont bdd_above cobdd\n\n"}
{"name":"Monotone.map_limsInf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"R : Type u_4\nS : Type u_5\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\ninstâœÂ³ : ConditionallyCompleteLinearOrder S\ninstâœÂ² : TopologicalSpace S\ninstâœÂ¹ : OrderTopology S\nF : Filter R\ninstâœ : F.NeBot\nf : R â†’ S\nf_incr : Monotone f\nf_cont : ContinuousAt f F.limsInf\ncobdd : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F) _autoâœ\nbdd_below : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) F) _autoâœ\nâŠ¢ Eq (f F.limsInf) (Filter.liminf f F)","decl":"/-- A monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.limsInf` to the `Filter.liminf` of the image if the function is continuous at the `limsInf`\n(and the filter is bounded from below and frequently bounded from above). -/\ntheorem Monotone.map_limsInf_of_continuousAt {F : Filter R} [NeBot F] {f : R â†’ S}\n    (f_incr : Monotone f) (f_cont : ContinuousAt f F.limsInf)\n    (cobdd : F.IsCobounded (Â· â‰¥ Â·) := by isBoundedDefault)\n    (bdd_below : F.IsBounded (Â· â‰¥ Â·) := by isBoundedDefault) : f F.limsInf = F.liminf f :=\n  Antitone.map_limsSup_of_continuousAt (R := Ráµ’áµˆ) f_incr.dual f_cont bdd_below cobdd\n\n"}
{"name":"Monotone.map_liminf_of_continuousAt","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\nS : Type u_5\nF : Filter Î¹\ninstâœâ¶ : F.NeBot\ninstâœâµ : ConditionallyCompleteLinearOrder R\ninstâœâ´ : TopologicalSpace R\ninstâœÂ³ : OrderTopology R\ninstâœÂ² : ConditionallyCompleteLinearOrder S\ninstâœÂ¹ : TopologicalSpace S\ninstâœ : OrderTopology S\nf : R â†’ S\nf_incr : Monotone f\na : Î¹ â†’ R\nf_cont : ContinuousAt f (Filter.liminf a F)\ncobdd : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _autoâœ\nbdd_below : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F a) _autoâœ\nâŠ¢ Eq (f (Filter.liminf a F)) (Filter.liminf (Function.comp f a) F)","decl":"/-- A continuous monotone function between (conditionally) complete linear ordered spaces sends a\n`Filter.liminf` to the `Filter.liminf` of the images (if the filter is bounded from below and\nfrequently bounded from above). -/\ntheorem Monotone.map_liminf_of_continuousAt {f : R â†’ S} (f_incr : Monotone f) (a : Î¹ â†’ R)\n    (f_cont : ContinuousAt f (F.liminf a))\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) a := by isBoundedDefault)\n    (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) a := by isBoundedDefault) :\n    f (F.liminf a) = F.liminf (f âˆ˜ a) :=\n  f_incr.map_limsInf_of_continuousAt f_cont cobdd bdd_below\n\n"}
{"name":"le_limsup_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : DenselyOrdered Î±\ninstâœÂ¹ : CovariantClass Î± Î± (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Î±\nhâ‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nhâ‚‚ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nhâ‚ƒ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _autoâœ\nhâ‚„ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _autoâœ\nâŠ¢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"lemma le_limsup_add (hâ‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u := by isBoundedDefault)\n    (hâ‚‚ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u := by isBoundedDefault)\n    (hâ‚ƒ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f v := by isBoundedDefault)\n    (hâ‚„ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v := by isBoundedDefault) :\n    (limsup u f) + liminf v f â‰¤ limsup (u + v) f := by\n  have h := isCoboundedUnder_le_add hâ‚„ hâ‚‚ -- These `have` tactic improve performance.\n  have h' := isBoundedUnder_le_add hâ‚ƒ hâ‚\n  rw [add_comm] at h h'\n  refine add_le_of_forall_lt fun a a_u b b_v â†¦ (le_limsup_iff h h').2 fun c c_ab â†¦ ?_\n  refine ((frequently_lt_of_lt_limsup hâ‚‚ a_u).and_eventually\n    (eventually_lt_of_lt_liminf b_v hâ‚„)).mono fun _ ab_x â†¦ ?_\n  exact c_ab.trans (add_lt_add ab_x.1 ab_x.2)\n\n"}
{"name":"limsup_add_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : DenselyOrdered Î±\ninstâœÂ¹ : CovariantClass Î± Î± (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Î±\nhâ‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nhâ‚‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nhâ‚ƒ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _autoâœ\nhâ‚„ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _autoâœ\nâŠ¢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_add_le (hâ‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f u := by isBoundedDefault)\n    (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u := by isBoundedDefault)\n    (hâ‚ƒ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f v := by isBoundedDefault)\n    (hâ‚„ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f v := by isBoundedDefault) :\n    limsup (u + v) f â‰¤ (limsup u f) + limsup v f := by\n  have h := isCoboundedUnder_le_add hâ‚ hâ‚ƒ\n  have h' := isBoundedUnder_le_add hâ‚‚ hâ‚„\n  refine le_add_of_forall_lt fun a a_u b b_v â†¦ ?_\n  rw [limsup_le_iff h h']\n  intro c c_ab\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (add_lt_add a_x b_x).trans c_ab\n\n"}
{"name":"le_liminf_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : DenselyOrdered Î±\ninstâœÂ¹ : CovariantClass Î± Î± (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Î±\nhâ‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nhâ‚‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nhâ‚ƒ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _autoâœ\nhâ‚„ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _autoâœ\nâŠ¢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma le_liminf_add (hâ‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f u := by isBoundedDefault)\n    (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u := by isBoundedDefault)\n    (hâ‚ƒ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v := by isBoundedDefault)\n    (hâ‚„ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v := by isBoundedDefault) :\n    (liminf u f) + liminf v f â‰¤ liminf (u + v) f := by\n  have h := isCoboundedUnder_ge_add hâ‚‚ hâ‚„\n  have h' := isBoundedUnder_ge_add hâ‚ hâ‚ƒ\n  refine add_le_of_forall_lt fun a a_u b b_v â†¦ ?_\n  rw [le_liminf_iff h h']\n  intro c c_ab\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (add_lt_add a_x b_x)\n\n"}
{"name":"liminf_add_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\ninstâœâ´ : AddCommGroup Î±\ninstâœÂ³ : ConditionallyCompleteLinearOrder Î±\ninstâœÂ² : DenselyOrdered Î±\ninstâœÂ¹ : CovariantClass Î± Î± (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Î±\nhâ‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _autoâœ\nhâ‚‚ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _autoâœ\nhâ‚ƒ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _autoâœ\nhâ‚„ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _autoâœ\nâŠ¢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_add_le (hâ‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f u := by isBoundedDefault)\n    (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u := by isBoundedDefault)\n    (hâ‚ƒ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v := by isBoundedDefault)\n    (hâ‚„ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v := by isBoundedDefault) :\n    liminf (u + v) f â‰¤ (limsup u f) + liminf v f := by\n  have h := isCoboundedUnder_ge_add hâ‚‚ hâ‚„\n  have h' := isBoundedUnder_ge_add hâ‚ hâ‚ƒ\n  refine le_add_of_forall_lt fun a a_u b b_v â†¦ (liminf_le_iff h h').2 fun _ c_ab â†¦ ?_\n  refine ((frequently_lt_of_liminf_lt hâ‚„ b_v).and_eventually\n    (eventually_lt_of_limsup_lt a_u hâ‚‚)).mono fun _ ab_x â†¦ ?_\n  exact (add_lt_add ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"le_limsup_mul","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Real\nhâ‚ : f.EventuallyLE 0 u\nhâ‚‚ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhâ‚ƒ : f.EventuallyLE 0 v\nhâ‚„ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\nâŠ¢ LE.le (HMul.hMul (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HMul.hMul u v) f)","decl":"lemma le_limsup_mul (hâ‚ : 0 â‰¤á¶ [f] u) (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u)\n    (hâ‚ƒ : 0 â‰¤á¶ [f] v) (hâ‚„ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f v) :\n    (limsup u f) * liminf v f â‰¤ limsup (u * v) f := by\n  have h := (isBoundedUnder_of_eventually_ge (a := 0)\n    <| (hâ‚.and hâ‚ƒ).mono fun x âŸ¨u_0, v_0âŸ© â†¦ mul_nonneg u_0 v_0).isCoboundedUnder_le\n  have h' := isBoundedUnder_le_mul_of_nonneg hâ‚ hâ‚‚ hâ‚ƒ hâ‚„\n  have u0 : 0 â‰¤ limsup u f := le_limsup_of_frequently_le hâ‚.frequently hâ‚‚\n  have uv : 0 â‰¤ limsup (u * v) f :=\n    le_limsup_of_frequently_le ((hâ‚.and hâ‚ƒ).mono fun _ âŸ¨hu, hvâŸ© â†¦ mul_nonneg hu hv).frequently h'\n  refine mul_le_of_forall_lt_of_nonneg u0 uv fun a _ au b b0 bv â†¦ (le_limsup_iff h h').2\n    fun c c_ab â†¦ ?_\n  refine ((frequently_lt_of_lt_limsup\n    (isBoundedUnder_of_eventually_ge hâ‚).isCoboundedUnder_le au).and_eventually\n    ((eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge hâ‚ƒ)).and\n    (hâ‚.and hâ‚ƒ))).mono fun x âŸ¨xa, âŸ¨xb, u0, _âŸ©âŸ© â†¦ ?_\n  exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 u0)\n\n"}
{"name":"limsup_mul_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Real\nhâ‚ : f.EventuallyLE 0 u\nhâ‚‚ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhâ‚ƒ : f.EventuallyLE 0 v\nhâ‚„ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\nâŠ¢ LE.le (Filter.limsup (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_mul_le (hâ‚ : 0 â‰¤á¶ [f] u) (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u)\n    (hâ‚ƒ : 0 â‰¤á¶ [f] v) (hâ‚„ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f v) :\n    limsup (u * v) f â‰¤ (limsup u f) * limsup v f := by\n  have h := (isBoundedUnder_of_eventually_ge (a := 0)\n    <| (hâ‚.and hâ‚ƒ).mono fun x âŸ¨u_0, v_0âŸ© â†¦ mul_nonneg u_0 v_0).isCoboundedUnder_le\n  have h' := isBoundedUnder_le_mul_of_nonneg hâ‚ hâ‚‚ hâ‚ƒ hâ‚„\n  refine le_mul_of_forall_ltâ‚€ fun a a_u b b_v â†¦ (limsup_le_iff h h').2 fun c c_ab â†¦ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v, hâ‚, hâ‚ƒ]\n    with x x_a x_b u_0 v_0\n  exact (mul_le_mul x_a.le x_b.le v_0 (u_0.trans x_a.le)).trans_lt c_ab\n\n"}
{"name":"le_liminf_mul","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Real\nhâ‚ : f.EventuallyLE 0 u\nhâ‚‚ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhâ‚ƒ : f.EventuallyLE 0 v\nhâ‚„ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\nâŠ¢ LE.le (HMul.hMul (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HMul.hMul u v) f)","decl":"lemma le_liminf_mul (hâ‚ : 0 â‰¤á¶ [f] u) (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u)\n    (hâ‚ƒ : 0 â‰¤á¶ [f] v) (hâ‚„ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v) :\n    (liminf u f) * liminf v f â‰¤ liminf (u * v) f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg hâ‚ hâ‚‚ hâ‚ƒ hâ‚„\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (hâ‚.and hâ‚ƒ).mono fun x âŸ¨u0, v0âŸ© â†¦ mul_nonneg u0 v0\n  apply mul_le_of_forall_lt_of_nonneg (le_liminf_of_le hâ‚‚.isCoboundedUnder_ge hâ‚)\n    (le_liminf_of_le h ((hâ‚.and hâ‚ƒ).mono fun x âŸ¨u0, v0âŸ© â†¦ mul_nonneg u0 v0))\n  intro a a0 au b b0 bv\n  refine (le_liminf_iff h h').2 fun c c_ab â†¦ ?_\n  filter_upwards [eventually_lt_of_lt_liminf au (isBoundedUnder_of_eventually_ge hâ‚),\n    eventually_lt_of_lt_liminf bv (isBoundedUnder_of_eventually_ge hâ‚ƒ)] with x xa xb\n  exact c_ab.trans_le (mul_le_mul xa.le xb.le b0 (a0.trans xa.le))\n\n"}
{"name":"liminf_mul_le","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nf : Filter Î¹\ninstâœ : f.NeBot\nu v : Î¹ â†’ Real\nhâ‚ : f.EventuallyLE 0 u\nhâ‚‚ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhâ‚ƒ : f.EventuallyLE 0 v\nhâ‚„ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\nâŠ¢ LE.le (Filter.liminf (HMul.hMul u v) f) (HMul.hMul (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_mul_le (hâ‚ : 0 â‰¤á¶ [f] u) (hâ‚‚ : IsBoundedUnder (fun x1 x2 â†¦ x1 â‰¤ x2) f u)\n    (hâ‚ƒ : 0 â‰¤á¶ [f] v) (hâ‚„ : IsCoboundedUnder (fun x1 x2 â†¦ x1 â‰¥ x2) f v) :\n    liminf (u * v) f â‰¤ (limsup u f) * liminf v f := by\n  have h := isCoboundedUnder_ge_mul_of_nonneg hâ‚ hâ‚‚ hâ‚ƒ hâ‚„\n  have h' := isBoundedUnder_of_eventually_ge (a := 0)\n    <| (hâ‚.and hâ‚ƒ).mono fun x âŸ¨u_0, v_0âŸ© â†¦ mul_nonneg u_0 v_0\n  refine le_mul_of_forall_ltâ‚€ fun a a_u b b_v â†¦ (liminf_le_iff h h').2 fun c c_ab â†¦ ?_\n  refine ((frequently_lt_of_liminf_lt hâ‚„ b_v).and_eventually ((eventually_lt_of_limsup_lt a_u).and\n    (hâ‚.and hâ‚ƒ))).mono fun x âŸ¨x_v, x_u, u_0, v_0âŸ© â†¦ ?_\n  exact (mul_le_mul x_u.le x_v.le v_0 (u_0.trans x_u.le)).trans_lt c_ab\n\n"}
{"name":"limsup_const_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\nF : Filter Î¹\ninstâœÂ³ : F.NeBot\ninstâœÂ² : Add R\ninstâœÂ¹ : ContinuousAdd R\ninstâœ : AddLeftMono R\nf : Î¹ â†’ R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\nâŠ¢ Eq (Filter.limsup (fun i => HAdd.hAdd c (f i)) F) (HAdd.hAdd c (Filter.limsup f F))","decl":"/-- `liminf (c + xáµ¢) = c + liminf xáµ¢`. -/\nlemma limsup_const_add (F : Filter Î¹) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddLeftMono R] (f : Î¹ â†’ R) (c : R)\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) f) (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) f) :\n    Filter.limsup (fun i â†¦ c + f i) F = c + Filter.limsup f F :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ c + x)\n    (fun _ _ h â†¦ add_le_add_left h c) (continuous_add_left c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"limsup_add_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\nF : Filter Î¹\ninstâœÂ³ : F.NeBot\ninstâœÂ² : Add R\ninstâœÂ¹ : ContinuousAdd R\ninstâœ : AddRightMono R\nf : Î¹ â†’ R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\nâŠ¢ Eq (Filter.limsup (fun i => HAdd.hAdd (f i) c) F) (HAdd.hAdd (Filter.limsup f F) c)","decl":"/-- `limsup (xáµ¢ + c) = (limsup xáµ¢) + c`. -/\nlemma limsup_add_const (F : Filter Î¹) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddRightMono R] (f : Î¹ â†’ R) (c : R)\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) f) (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) f) :\n    Filter.limsup (fun i â†¦ f i + c) F = Filter.limsup f F + c :=\n  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ x + c)\n    (fun _ _ h â†¦ add_le_add_right h c) (continuous_add_right c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"liminf_const_add","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\nF : Filter Î¹\ninstâœÂ³ : F.NeBot\ninstâœÂ² : Add R\ninstâœÂ¹ : ContinuousAdd R\ninstâœ : AddLeftMono R\nf : Î¹ â†’ R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nâŠ¢ Eq (Filter.liminf (fun i => HAdd.hAdd c (f i)) F) (HAdd.hAdd c (Filter.liminf f F))","decl":"/-- `liminf (c + xáµ¢) = c + limsup xáµ¢`. -/\nlemma liminf_const_add (F : Filter Î¹) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddLeftMono R] (f : Î¹ â†’ R) (c : R)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) f) (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) f) :\n    Filter.liminf (fun i â†¦ c + f i) F = c + Filter.liminf f F :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ c + x)\n    (fun _ _ h â†¦ add_le_add_left h c) (continuous_add_left c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"liminf_add_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\nF : Filter Î¹\ninstâœÂ³ : F.NeBot\ninstâœÂ² : Add R\ninstâœÂ¹ : ContinuousAdd R\ninstâœ : AddRightMono R\nf : Î¹ â†’ R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nâŠ¢ Eq (Filter.liminf (fun i => HAdd.hAdd (f i) c) F) (HAdd.hAdd (Filter.liminf f F) c)","decl":"/-- `liminf (xáµ¢ + c) = (liminf xáµ¢) + c`. -/\nlemma liminf_add_const (F : Filter Î¹) [NeBot F] [Add R] [ContinuousAdd R]\n    [AddRightMono R] (f : Î¹ â†’ R) (c : R)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) f) (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) f) :\n    Filter.liminf (fun i â†¦ f i + c) F = Filter.liminf f F + c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ x + c)\n    (fun _ _ h â†¦ add_le_add_right h c) (continuous_add_right c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"limsup_const_sub","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ· : ConditionallyCompleteLinearOrder R\ninstâœâ¶ : TopologicalSpace R\ninstâœâµ : OrderTopology R\nF : Filter Î¹\ninstâœâ´ : AddCommSemigroup R\ninstâœÂ³ : Sub R\ninstâœÂ² : ContinuousSub R\ninstâœÂ¹ : OrderedSub R\ninstâœ : AddLeftMono R\nf : Î¹ â†’ R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nâŠ¢ Eq (Filter.limsup (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.liminf f F))","decl":"/-- `limsup (c - xáµ¢) = c - liminf xáµ¢`. -/\nlemma limsup_const_sub (F : Filter Î¹) [AddCommSemigroup R] [Sub R] [ContinuousSub R] [OrderedSub R]\n    [AddLeftMono R] (f : Î¹ â†’ R) (c : R)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) f) (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) f) :\n    Filter.limsup (fun i â†¦ c - f i) F = c - Filter.liminf f F := by\n  rcases F.eq_or_neBot with rfl | _\n  Â· simp only [liminf, limsInf, limsup, limsSup, map_bot, eventually_bot, Set.setOf_true]\n    simp only [IsCoboundedUnder, IsCobounded, map_bot, eventually_bot, true_implies] at cobdd\n    rcases cobdd with âŸ¨x, hxâŸ©\n    refine (csInf_le ?_ (Set.mem_univ _)).antisymm\n      (tsub_le_iff_tsub_le.1 (le_csSup ?_ (Set.mem_univ _)))\n    Â· refine âŸ¨x - x, mem_lowerBounds.2 fun y â†¦ ?_âŸ©\n      simp only [Set.mem_univ, true_implies]\n      exact tsub_le_iff_tsub_le.1 (hx (x - y))\n    Â· refine âŸ¨x, mem_upperBounds.2 fun y â†¦ ?_âŸ©\n      simp only [Set.mem_univ, hx y, implies_true]\n  Â· exact (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ c - x)\n    (fun _ _ h â†¦ tsub_le_tsub_left h c) (continuous_sub_left c).continuousAt cobdd bdd_below).symm\n\n"}
{"name":"limsup_sub_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¶ : ConditionallyCompleteLinearOrder R\ninstâœâµ : TopologicalSpace R\ninstâœâ´ : OrderTopology R\nF : Filter Î¹\ninstâœÂ³ : AddCommSemigroup R\ninstâœÂ² : Sub R\ninstâœÂ¹ : ContinuousSub R\ninstâœ : OrderedSub R\nf : Î¹ â†’ R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\nâŠ¢ Eq (Filter.limsup (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.limsup f F) c)","decl":"/-- `limsup (xáµ¢ - c) = (limsup xáµ¢) - c`. -/\nlemma limsup_sub_const (F : Filter Î¹) [AddCommSemigroup R] [Sub R] [ContinuousSub R] [OrderedSub R]\n    (f : Î¹ â†’ R) (c : R)\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) f) (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) f) :\n    Filter.limsup (fun i â†¦ f i - c) F = Filter.limsup f F - c := by\n  rcases F.eq_or_neBot with rfl | _\n  Â· have {a : R} : sInf Set.univ â‰¤ a := by\n      apply csInf_le _ (Set.mem_univ a)\n      simp only [IsCoboundedUnder, IsCobounded, map_bot, eventually_bot, true_implies] at cobdd\n      rcases cobdd with âŸ¨x, hxâŸ©\n      refine âŸ¨x, mem_lowerBounds.2 fun y â†¦ ?_âŸ©\n      simp only [Set.mem_univ, hx y, implies_true]\n    simp only [limsup, limsSup, map_bot, eventually_bot, Set.setOf_true]\n    exact this.antisymm (tsub_le_iff_right.2 this)\n  Â· apply (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ x - c) _ _).symm\n    Â· exact fun _ _ h â†¦ tsub_le_tsub_right h c\n    Â· exact (continuous_sub_right c).continuousAt\n\n"}
{"name":"liminf_const_sub","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ¸ : ConditionallyCompleteLinearOrder R\ninstâœâ· : TopologicalSpace R\ninstâœâ¶ : OrderTopology R\nF : Filter Î¹\ninstâœâµ : F.NeBot\ninstâœâ´ : AddCommSemigroup R\ninstâœÂ³ : Sub R\ninstâœÂ² : ContinuousSub R\ninstâœÂ¹ : OrderedSub R\ninstâœ : AddLeftMono R\nf : Î¹ â†’ R\nc : R\nbdd_above : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) F f\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f\nâŠ¢ Eq (Filter.liminf (fun i => HSub.hSub c (f i)) F) (HSub.hSub c (Filter.limsup f F))","decl":"/-- `liminf (c - xáµ¢) = c - limsup xáµ¢`. -/\nlemma liminf_const_sub (F : Filter Î¹) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] [AddLeftMono R] (f : Î¹ â†’ R) (c : R)\n    (bdd_above : F.IsBoundedUnder (Â· â‰¤ Â·) f) (cobdd : F.IsCoboundedUnder (Â· â‰¤ Â·) f) :\n    Filter.liminf (fun i â†¦ c - f i) F = c - Filter.limsup f F :=\n  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ c - x)\n    (fun _ _ h â†¦ tsub_le_tsub_left h c) (continuous_sub_left c).continuousAt bdd_above cobdd).symm\n\n"}
{"name":"liminf_sub_const","module":"Mathlib.Topology.Algebra.Order.LiminfLimsup","initialProofState":"Î¹ : Type u_1\nR : Type u_4\ninstâœâ· : ConditionallyCompleteLinearOrder R\ninstâœâ¶ : TopologicalSpace R\ninstâœâµ : OrderTopology R\nF : Filter Î¹\ninstâœâ´ : F.NeBot\ninstâœÂ³ : AddCommSemigroup R\ninstâœÂ² : Sub R\ninstâœÂ¹ : ContinuousSub R\ninstâœ : OrderedSub R\nf : Î¹ â†’ R\nc : R\ncobdd : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nbdd_below : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) F f\nâŠ¢ Eq (Filter.liminf (fun i => HSub.hSub (f i) c) F) (HSub.hSub (Filter.liminf f F) c)","decl":"/-- `liminf (xáµ¢ - c) = (liminf xáµ¢) - c`. -/\nlemma liminf_sub_const (F : Filter Î¹) [NeBot F] [AddCommSemigroup R] [Sub R] [ContinuousSub R]\n    [OrderedSub R] (f : Î¹ â†’ R) (c : R)\n    (cobdd : F.IsCoboundedUnder (Â· â‰¥ Â·) f) (bdd_below : F.IsBoundedUnder (Â· â‰¥ Â·) f) :\n    Filter.liminf (fun i â†¦ f i - c) F = Filter.liminf f F - c :=\n  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : R) â†¦ x - c)\n    (fun _ _ h â†¦ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt cobdd bdd_below).symm\n\n"}
