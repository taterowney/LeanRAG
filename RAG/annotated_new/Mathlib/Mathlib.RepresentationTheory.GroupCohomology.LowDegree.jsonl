{"name":"groupCohomology.dZero_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nm : CoeSort.coe A\ng : G\n⊢ Eq ((groupCohomology.dZero A) m g) (HSub.hSub ((A.ρ g) m) m)","decl":"/-- The 0th differential in the complex of inhomogeneous cochains of `A : Rep k G`, as a\n`k`-linear map `A → Fun(G, A)`. It sends `(a, g) ↦ ρ_A(g)(a) - a.` -/\n@[simps]\ndef dZero : A →ₗ[k] G → A where\n  toFun m g := A.ρ g m - m\n  map_add' x y := funext fun g => by simp only [map_add, add_sub_add_comm]; rfl\n  map_smul' r x := funext fun g => by dsimp; rw [map_smul, smul_sub]\n\n"}
{"name":"groupCohomology.dZero_ker_eq_invariants","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (LinearMap.ker (groupCohomology.dZero A)) A.ρ.invariants","decl":"theorem dZero_ker_eq_invariants : LinearMap.ker (dZero A) = invariants A.ρ := by\n  ext x\n  simp only [LinearMap.mem_ker, mem_invariants, ← @sub_eq_zero _ _ _ x, funext_iff]\n  rfl\n\n"}
{"name":"groupCohomology.dZero_eq_zero","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\n⊢ Eq (groupCohomology.dZero A) 0","decl":"@[simp] theorem dZero_eq_zero [A.IsTrivial] : dZero A = 0 := by\n  ext\n  simp only [dZero_apply, apply_eq_self, sub_self, LinearMap.zero_apply, Pi.zero_apply]\n\n"}
{"name":"groupCohomology.dOne_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\ng : Prod G G\n⊢ Eq ((groupCohomology.dOne A) f g) (HAdd.hAdd (HSub.hSub ((A.ρ g.1) (f g.2)) (f (HMul.hMul g.1 g.2))) (f g.1))","decl":"/-- The 1st differential in the complex of inhomogeneous cochains of `A : Rep k G`, as a\n`k`-linear map `Fun(G, A) → Fun(G × G, A)`. It sends\n`(f, (g₁, g₂)) ↦ ρ_A(g₁)(f(g₂)) - f(g₁g₂) + f(g₁).` -/\n@[simps]\ndef dOne : (G → A) →ₗ[k] G × G → A where\n  toFun f g := A.ρ g.1 (f g.2) - f (g.1 * g.2) + f g.1\n  map_add' x y := funext fun g => by dsimp; rw [map_add, add_add_add_comm, add_sub_add_comm]\n  map_smul' r x := funext fun g => by dsimp; rw [map_smul, smul_add, smul_sub]\n\n"}
{"name":"groupCohomology.dTwo_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\ng : Prod G (Prod G G)\n⊢ Eq ((groupCohomology.dTwo A) f g) (HSub.hSub (HAdd.hAdd (HSub.hSub ((A.ρ g.1) (f { fst := g.2.1, snd := g.2.2 })) (f { fst := HMul.hMul g.1 g.2.1, snd := g.2.2 })) (f { fst := g.1, snd := HMul.hMul g.2.1 g.2.2 })) (f { fst := g.1, snd := g.2.1 }))","decl":"/-- The 2nd differential in the complex of inhomogeneous cochains of `A : Rep k G`, as a\n`k`-linear map `Fun(G × G, A) → Fun(G × G × G, A)`. It sends\n`(f, (g₁, g₂, g₃)) ↦ ρ_A(g₁)(f(g₂, g₃)) - f(g₁g₂, g₃) + f(g₁, g₂g₃) - f(g₁, g₂).` -/\n@[simps]\ndef dTwo : (G × G → A) →ₗ[k] G × G × G → A where\n  toFun f g :=\n    A.ρ g.1 (f (g.2.1, g.2.2)) - f (g.1 * g.2.1, g.2.2) + f (g.1, g.2.1 * g.2.2) - f (g.1, g.2.1)\n  map_add' x y :=\n    funext fun g => by\n      dsimp\n      rw [map_add, add_sub_add_comm (A.ρ _ _), add_sub_assoc, add_sub_add_comm, add_add_add_comm,\n        add_sub_assoc, add_sub_assoc]\n  map_smul' r x := funext fun g => by dsimp; simp only [map_smul, smul_add, smul_sub]\n\n"}
{"name":"groupCohomology.dZero_comp_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dZero A).comp ↑(groupCohomology.zeroCochainsLequiv A)) ((↑(groupCohomology.oneCochainsLequiv A)).comp (ModuleCat.Hom.hom ((groupCohomology.inhomogeneousCochains A).d 0 1)))","decl":"/-- Let `C(G, A)` denote the complex of inhomogeneous cochains of `A : Rep k G`. This lemma\nsays `dZero` gives a simpler expression for the 0th differential: that is, the following\nsquare commutes:\n```\n  C⁰(G, A) ---d⁰---> C¹(G, A)\n  |                    |\n  |                    |\n  |                    |\n  v                    v\n  A ---- dZero ---> Fun(G, A)\n```\nwhere the vertical arrows are `zeroCochainsLequiv` and `oneCochainsLequiv` respectively.\n-/\ntheorem dZero_comp_eq : dZero A ∘ₗ (zeroCochainsLequiv A) =\n    oneCochainsLequiv A ∘ₗ ((inhomogeneousCochains A).d 0 1).hom := by\n  ext x y\n  show A.ρ y (x default) - x default = _ + ({0} : Finset _).sum _\n  simp_rw [Fin.val_eq_zero, zero_add, pow_one, neg_smul, one_smul,\n    Finset.sum_singleton, sub_eq_add_neg]\n  rcongr i <;> exact Fin.elim0 i\n\n"}
{"name":"groupCohomology.dOne_comp_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dOne A).comp ↑(groupCohomology.oneCochainsLequiv A)) ((↑(groupCohomology.twoCochainsLequiv A)).comp (ModuleCat.Hom.hom ((groupCohomology.inhomogeneousCochains A).d 1 2)))","decl":"/-- Let `C(G, A)` denote the complex of inhomogeneous cochains of `A : Rep k G`. This lemma\nsays `dOne` gives a simpler expression for the 1st differential: that is, the following\nsquare commutes:\n```\n  C¹(G, A) ---d¹-----> C²(G, A)\n    |                      |\n    |                      |\n    |                      |\n    v                      v\n  Fun(G, A) -dOne-> Fun(G × G, A)\n```\nwhere the vertical arrows are `oneCochainsLequiv` and `twoCochainsLequiv` respectively.\n-/\ntheorem dOne_comp_eq : dOne A ∘ₗ oneCochainsLequiv A =\n    twoCochainsLequiv A ∘ₗ ((inhomogeneousCochains A).d 1 2).hom := by\n  ext x y\n  show A.ρ y.1 (x _) - x _ + x _ =  _ + _\n  rw [Fin.sum_univ_two]\n  simp only [Fin.val_zero, zero_add, pow_one, neg_smul, one_smul, Fin.val_one,\n    Nat.one_add, neg_one_sq, sub_eq_add_neg, add_assoc]\n  rcongr i <;> rw [Subsingleton.elim i 0] <;> rfl\n\n"}
{"name":"groupCohomology.dTwo_comp_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dTwo A).comp ↑(groupCohomology.twoCochainsLequiv A)) ((↑(groupCohomology.threeCochainsLequiv A)).comp (ModuleCat.Hom.hom ((groupCohomology.inhomogeneousCochains A).d 2 3)))","decl":"/-- Let `C(G, A)` denote the complex of inhomogeneous cochains of `A : Rep k G`. This lemma\nsays `dTwo` gives a simpler expression for the 2nd differential: that is, the following\nsquare commutes:\n```\n      C²(G, A) -------d²-----> C³(G, A)\n        |                         |\n        |                         |\n        |                         |\n        v                         v\n  Fun(G × G, A) --dTwo--> Fun(G × G × G, A)\n```\nwhere the vertical arrows are `twoCochainsLequiv` and `threeCochainsLequiv` respectively.\n-/\ntheorem dTwo_comp_eq :\n    dTwo A ∘ₗ twoCochainsLequiv A =\n      threeCochainsLequiv A ∘ₗ ((inhomogeneousCochains A).d 2 3).hom := by\n  ext x y\n  show A.ρ y.1 (x _) - x _ + x _ - x _ = _ + _\n  dsimp\n  rw [Fin.sum_univ_three]\n  simp only [sub_eq_add_neg, add_assoc, Fin.val_zero, zero_add, pow_one, neg_smul,\n    one_smul, Fin.val_one, Fin.val_two, pow_succ' (-1 : k) 2, neg_sq, Nat.one_add, one_pow, mul_one]\n  rcongr i <;> fin_cases i <;> rfl\n\n"}
{"name":"groupCohomology.dOne_comp_dZero","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dOne A).comp (groupCohomology.dZero A)) 0","decl":"theorem dOne_comp_dZero : dOne A ∘ₗ dZero A = 0 := by\n  ext x g\n  simp only [LinearMap.coe_comp, Function.comp_apply, dOne_apply A, dZero_apply A, map_sub,\n    map_mul, LinearMap.mul_apply, sub_sub_sub_cancel_left, sub_add_sub_cancel, sub_self]\n  rfl\n\n"}
{"name":"groupCohomology.dTwo_comp_dOne","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dTwo A).comp (groupCohomology.dOne A)) 0","decl":"theorem dTwo_comp_dOne : dTwo A ∘ₗ dOne A = 0 := by\n  show (ModuleCat.ofHom (dOne A) ≫ ModuleCat.ofHom (dTwo A)).hom = _\n  have h1 := congr_arg ModuleCat.ofHom (dOne_comp_eq A)\n  have h2 := congr_arg ModuleCat.ofHom (dTwo_comp_eq A)\n  simp only [ModuleCat.ofHom_comp, ModuleCat.ofHom_comp, ← LinearEquiv.toModuleIso_hom] at h1 h2\n  simp only [(Iso.eq_inv_comp _).2 h2, (Iso.eq_inv_comp _).2 h1, ModuleCat.ofHom_hom,\n    ModuleCat.hom_ofHom, Category.assoc, Iso.hom_inv_id_assoc, HomologicalComplex.d_comp_d_assoc,\n    zero_comp, comp_zero, ModuleCat.hom_zero]\n\n"}
{"name":"groupCohomology.oneCocycles.coe_mk","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\nhf : Membership.mem (groupCohomology.oneCocycles A) f\n⊢ Eq (⇑⟨f, hf⟩) f","decl":"@[simp]\ntheorem oneCocycles.coe_mk (f : G → A) (hf) : ((⟨f, hf⟩ : oneCocycles A) : G → A) = f := rfl\n\n"}
{"name":"groupCohomology.oneCocycles.val_eq_coe","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\n⊢ Eq ↑f ⇑f","decl":"@[simp]\ntheorem oneCocycles.val_eq_coe (f : oneCocycles A) : f.1 = f := rfl\n\n"}
{"name":"groupCohomology.oneCocycles_ext","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf₁ f₂ : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\nh : ∀ (g : G), Eq (f₁ g) (f₂ g)\n⊢ Eq f₁ f₂","decl":"@[ext]\ntheorem oneCocycles_ext {f₁ f₂ : oneCocycles A} (h : ∀ g : G, f₁ g = f₂ g) : f₁ = f₂ :=\n  DFunLike.ext f₁ f₂ h\n\n"}
{"name":"groupCohomology.oneCocycles_ext_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf₁ f₂ : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\n⊢ Iff (Eq f₁ f₂) (∀ (g : G), Eq (f₁ g) (f₂ g))","decl":"@[ext]\ntheorem oneCocycles_ext {f₁ f₂ : oneCocycles A} (h : ∀ g : G, f₁ g = f₂ g) : f₁ = f₂ :=\n  DFunLike.ext f₁ f₂ h\n\n"}
{"name":"groupCohomology.mem_oneCocycles_def","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\n⊢ Iff (Membership.mem (groupCohomology.oneCocycles A) f) (∀ (g h : G), Eq (HAdd.hAdd (HSub.hSub ((A.ρ g) (f h)) (f (HMul.hMul g h))) (f g)) 0)","decl":"theorem mem_oneCocycles_def (f : G → A) :\n    f ∈ oneCocycles A ↔ ∀ g h : G, A.ρ g (f h) - f (g * h) + f g = 0 :=\n  LinearMap.mem_ker.trans <| by\n    rw [funext_iff]\n    simp only [dOne_apply, Pi.zero_apply, Prod.forall]\n\n"}
{"name":"groupCohomology.mem_oneCocycles_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\n⊢ Iff (Membership.mem (groupCohomology.oneCocycles A) f) (∀ (g h : G), Eq (f (HMul.hMul g h)) (HAdd.hAdd ((A.ρ g) (f h)) (f g)))","decl":"theorem mem_oneCocycles_iff (f : G → A) :\n    f ∈ oneCocycles A ↔ ∀ g h : G, f (g * h) = A.ρ g (f h) + f g := by\n  simp_rw [mem_oneCocycles_def, sub_add_eq_add_sub, sub_eq_zero, eq_comm]\n\n"}
{"name":"groupCohomology.oneCocycles_map_one","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\n⊢ Eq (f 1) 0","decl":"@[simp] theorem oneCocycles_map_one (f : oneCocycles A) : f 1 = 0 := by\n  have := (mem_oneCocycles_def f).1 f.2 1 1\n  simpa only [map_one, LinearMap.one_apply, mul_one, sub_self, zero_add] using this\n\n"}
{"name":"groupCohomology.oneCocycles_map_inv","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\ng : G\n⊢ Eq ((A.ρ g) (f (Inv.inv g))) (Neg.neg (f g))","decl":"@[simp] theorem oneCocycles_map_inv (f : oneCocycles A) (g : G) :\n    A.ρ g (f g⁻¹) = - f g := by\n  rw [← add_eq_zero_iff_eq_neg, ← oneCocycles_map_one f, ← mul_inv_cancel g,\n    (mem_oneCocycles_iff f).1 f.2 g g⁻¹]\n\n"}
{"name":"groupCohomology.oneCocycles_map_mul_of_isTrivial","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\ng h : G\n⊢ Eq (f (HMul.hMul g h)) (HAdd.hAdd (f g) (f h))","decl":"theorem oneCocycles_map_mul_of_isTrivial [A.IsTrivial] (f : oneCocycles A) (g h : G) :\n    f (g * h) = f g + f h := by\n  rw [(mem_oneCocycles_iff f).1 f.2, apply_eq_self A.ρ g (f h), add_comm]\n\n"}
{"name":"groupCohomology.mem_oneCocycles_of_addMonoidHom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nf : AddMonoidHom (Additive G) (CoeSort.coe A)\n⊢ Membership.mem (groupCohomology.oneCocycles A) (Function.comp ⇑f ⇑Additive.ofMul)","decl":"theorem mem_oneCocycles_of_addMonoidHom [A.IsTrivial] (f : Additive G →+ A) :\n    f ∘ Additive.ofMul ∈ oneCocycles A :=\n  (mem_oneCocycles_iff _).2 fun g h => by\n    simp only [Function.comp_apply, ofMul_mul, map_add,\n      oneCocycles_map_mul_of_isTrivial, apply_eq_self A.ρ g (f (Additive.ofMul h)),\n      add_comm (f (Additive.ofMul g))]\n\n"}
{"name":"groupCohomology.oneCocyclesLequivOfIsTrivial_symm_apply_coe","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nhA : A.IsTrivial\nf : AddMonoidHom (Additive G) (CoeSort.coe A)\na : Additive G\n⊢ Eq (↑((groupCohomology.oneCocyclesLequivOfIsTrivial A).symm f) a) (f a)","decl":"/-- When `A : Rep k G` is a trivial representation of `G`, `Z¹(G, A)` is isomorphic to the\ngroup homs `G → A`. -/\n@[simps] def oneCocyclesLequivOfIsTrivial [hA : A.IsTrivial] :\n    oneCocycles A ≃ₗ[k] Additive G →+ A where\n  toFun f :=\n    { toFun := f ∘ Additive.toMul\n      map_zero' := oneCocycles_map_one f\n      map_add' := oneCocycles_map_mul_of_isTrivial f }\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f :=\n    { val := f\n      property := mem_oneCocycles_of_addMonoidHom f }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"groupCohomology.oneCocyclesLequivOfIsTrivial_apply_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nhA : A.IsTrivial\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\na✝ : Additive G\n⊢ Eq (((groupCohomology.oneCocyclesLequivOfIsTrivial A) f) a✝) (Function.comp (⇑f) (⇑Additive.toMul) a✝)","decl":"/-- When `A : Rep k G` is a trivial representation of `G`, `Z¹(G, A)` is isomorphic to the\ngroup homs `G → A`. -/\n@[simps] def oneCocyclesLequivOfIsTrivial [hA : A.IsTrivial] :\n    oneCocycles A ≃ₗ[k] Additive G →+ A where\n  toFun f :=\n    { toFun := f ∘ Additive.toMul\n      map_zero' := oneCocycles_map_one f\n      map_add' := oneCocycles_map_mul_of_isTrivial f }\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f :=\n    { val := f\n      property := mem_oneCocycles_of_addMonoidHom f }\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n\n"}
{"name":"groupCohomology.twoCocycles.coe_mk","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\nhf : Membership.mem (groupCohomology.twoCocycles A) f\n⊢ Eq (⇑⟨f, hf⟩) f","decl":"@[simp]\ntheorem twoCocycles.coe_mk (f : G × G → A) (hf) : ((⟨f, hf⟩ : twoCocycles A) : G × G → A) = f := rfl\n\n"}
{"name":"groupCohomology.twoCocycles.val_eq_coe","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\n⊢ Eq ↑f ⇑f","decl":"@[simp]\ntheorem twoCocycles.val_eq_coe (f : twoCocycles A) : f.1 = f := rfl\n\n"}
{"name":"groupCohomology.twoCocycles_ext","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf₁ f₂ : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\nh : ∀ (g h : G), Eq (f₁ { fst := g, snd := h }) (f₂ { fst := g, snd := h })\n⊢ Eq f₁ f₂","decl":"@[ext]\ntheorem twoCocycles_ext {f₁ f₂ : twoCocycles A} (h : ∀ g h : G, f₁ (g, h) = f₂ (g, h)) : f₁ = f₂ :=\n  DFunLike.ext f₁ f₂ (Prod.forall.mpr h)\n\n"}
{"name":"groupCohomology.twoCocycles_ext_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf₁ f₂ : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\n⊢ Iff (Eq f₁ f₂) (∀ (g h : G), Eq (f₁ { fst := g, snd := h }) (f₂ { fst := g, snd := h }))","decl":"@[ext]\ntheorem twoCocycles_ext {f₁ f₂ : twoCocycles A} (h : ∀ g h : G, f₁ (g, h) = f₂ (g, h)) : f₁ = f₂ :=\n  DFunLike.ext f₁ f₂ (Prod.forall.mpr h)\n\n"}
{"name":"groupCohomology.mem_twoCocycles_def","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\n⊢ Iff (Membership.mem (groupCohomology.twoCocycles A) f) (∀ (g h j : G), Eq (HSub.hSub (HAdd.hAdd (HSub.hSub ((A.ρ g) (f { fst := h, snd := j })) (f { fst := HMul.hMul g h, snd := j })) (f { fst := g, snd := HMul.hMul h j })) (f { fst := g, snd := h })) 0)","decl":"theorem mem_twoCocycles_def (f : G × G → A) :\n    f ∈ twoCocycles A ↔ ∀ g h j : G,\n      A.ρ g (f (h, j)) - f (g * h, j) + f (g, h * j) - f (g, h) = 0 :=\n  LinearMap.mem_ker.trans <| by\n    rw [funext_iff]\n    simp only [dTwo_apply, Prod.mk.eta, Pi.zero_apply, Prod.forall]\n\n"}
{"name":"groupCohomology.mem_twoCocycles_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\n⊢ Iff (Membership.mem (groupCohomology.twoCocycles A) f) (∀ (g h j : G), Eq (HAdd.hAdd (f { fst := HMul.hMul g h, snd := j }) (f { fst := g, snd := h })) (HAdd.hAdd ((A.ρ g) (f { fst := h, snd := j })) (f { fst := g, snd := HMul.hMul h j })))","decl":"theorem mem_twoCocycles_iff (f : G × G → A) :\n    f ∈ twoCocycles A ↔ ∀ g h j : G,\n      f (g * h, j) + f (g, h) =\n        A.ρ g (f (h, j)) + f (g, h * j) := by\n  simp_rw [mem_twoCocycles_def, sub_eq_zero, sub_add_eq_add_sub, sub_eq_iff_eq_add, eq_comm,\n    add_comm (f (_ * _, _))]\n\n"}
{"name":"groupCohomology.twoCocycles_map_one_fst","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\ng : G\n⊢ Eq (f { fst := 1, snd := g }) (f { fst := 1, snd := 1 })","decl":"theorem twoCocycles_map_one_fst (f : twoCocycles A) (g : G) :\n    f (1, g) = f (1, 1) := by\n  have := ((mem_twoCocycles_iff f).1 f.2 1 1 g).symm\n  simpa only [map_one, LinearMap.one_apply, one_mul, add_right_inj, this]\n\n"}
{"name":"groupCohomology.twoCocycles_map_one_snd","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\ng : G\n⊢ Eq (f { fst := g, snd := 1 }) ((A.ρ g) (f { fst := 1, snd := 1 }))","decl":"theorem twoCocycles_map_one_snd (f : twoCocycles A) (g : G) :\n    f (g, 1) = A.ρ g (f (1, 1)) := by\n  have := (mem_twoCocycles_iff f).1 f.2 g 1 1\n  simpa only [mul_one, add_left_inj, this]\n\n"}
{"name":"groupCohomology.twoCocycles_ρ_map_inv_sub_map_inv","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\ng : G\n⊢ Eq (HSub.hSub ((A.ρ g) (f { fst := Inv.inv g, snd := g })) (f { fst := g, snd := Inv.inv g })) (HSub.hSub (f { fst := 1, snd := 1 }) (f { fst := g, snd := 1 }))","decl":"lemma twoCocycles_ρ_map_inv_sub_map_inv (f : twoCocycles A) (g : G) :\n    A.ρ g (f (g⁻¹, g)) - f (g, g⁻¹)\n      = f (1, 1) - f (g, 1) := by\n  have := (mem_twoCocycles_iff f).1 f.2 g g⁻¹ g\n  simp only [mul_inv_cancel, inv_mul_cancel, twoCocycles_map_one_fst _ g]\n    at this\n  exact sub_eq_sub_iff_add_eq_add.2 this.symm\n\n"}
{"name":"groupCohomology.oneCoboundaries_of_mem_range_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\nh : Membership.mem (LinearMap.range (groupCohomology.dZero A)) f\n⊢ Eq (↑↑(groupCohomology.oneCoboundariesOfMemRange h)) f","decl":"theorem oneCoboundaries_of_mem_range_apply {f : G → A} (h : f ∈ LinearMap.range (dZero A)) :\n    (oneCoboundariesOfMemRange h).1.1 = f := rfl\n\n"}
{"name":"groupCohomology.oneCoboundariesOfEq_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : G → CoeSort.coe A\nx : CoeSort.coe A\nhf : ∀ (g : G), Eq (HSub.hSub ((A.ρ g) x) x) (f g)\n⊢ Eq (↑↑(groupCohomology.oneCoboundariesOfEq hf)) f","decl":"theorem oneCoboundariesOfEq_apply {f : G → A} {x : A} (hf : ∀ g, A.ρ g x - x = f g) :\n    (oneCoboundariesOfEq hf).1.1 = f := rfl\n\n"}
{"name":"groupCohomology.mem_range_of_mem_oneCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\nh : Membership.mem (groupCohomology.oneCoboundaries A) f\n⊢ Membership.mem (LinearMap.range (groupCohomology.dZero A)) ↑f","decl":"theorem mem_range_of_mem_oneCoboundaries {f : oneCocycles A} (h : f ∈ oneCoboundaries A) :\n    f.1 ∈ LinearMap.range (dZero A) := by\n  rcases h with ⟨x, rfl⟩; exact ⟨x, rfl⟩\n\n"}
{"name":"groupCohomology.oneCoboundaries_eq_bot_of_isTrivial","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\n⊢ Eq (groupCohomology.oneCoboundaries A) Bot.bot","decl":"theorem oneCoboundaries_eq_bot_of_isTrivial (A : Rep k G) [A.IsTrivial] :\n    oneCoboundaries A = ⊥ := by\n  simp_rw [oneCoboundaries, dZero_eq_zero]\n  exact LinearMap.range_eq_bot.2 rfl\n\n"}
{"name":"groupCohomology.mem_oneCoboundaries_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\n⊢ Iff (Membership.mem (groupCohomology.oneCoboundaries A) f) (Exists fun x => ∀ (g : G), Eq (HSub.hSub ((A.ρ g) x) x) (f g))","decl":"theorem mem_oneCoboundaries_iff (f : oneCocycles A) : f ∈ oneCoboundaries A ↔\n    ∃ x : A, ∀ g : G, A.ρ g x - x = f g := exists_congr fun x ↦ by\n  simpa only [LinearMap.codRestrict, dZero, LinearMap.coe_mk, AddHom.coe_mk] using\n    groupCohomology.oneCocycles_ext_iff\n\n"}
{"name":"groupCohomology.twoCoboundariesOfMemRange_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\nh : Membership.mem (LinearMap.range (groupCohomology.dOne A)) f\n⊢ Eq (↑↑(groupCohomology.twoCoboundariesOfMemRange h)) f","decl":"theorem twoCoboundariesOfMemRange_apply {f : G × G → A} (h : f ∈ LinearMap.range (dOne A)) :\n    (twoCoboundariesOfMemRange h).1.1 = f := rfl\n\n"}
{"name":"groupCohomology.twoCoboundariesOfEq_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Prod G G → CoeSort.coe A\nx : G → CoeSort.coe A\nhf : ∀ (g h : G), Eq (HAdd.hAdd (HSub.hSub ((A.ρ g) (x h)) (x (HMul.hMul g h))) (x g)) (f { fst := g, snd := h })\n⊢ Eq (↑↑(groupCohomology.twoCoboundariesOfEq hf)) f","decl":"theorem twoCoboundariesOfEq_apply {f : G × G → A} {x : G → A}\n    (hf : ∀ g h, A.ρ g (x h) - x (g * h) + x g = f (g, h)) :\n    (twoCoboundariesOfEq hf).1.1 = f := rfl\n\n"}
{"name":"groupCohomology.mem_range_of_mem_twoCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\nh : Membership.mem (groupCohomology.twoCoboundaries A) f\n⊢ Membership.mem (LinearMap.range (groupCohomology.dOne A)) ((groupCohomology.twoCocycles A).subtype f)","decl":"theorem mem_range_of_mem_twoCoboundaries {f : twoCocycles A} (h : f ∈ twoCoboundaries A) :\n    (twoCocycles A).subtype f ∈ LinearMap.range (dOne A) := by\n  rcases h with ⟨x, rfl⟩; exact ⟨x, rfl⟩\n\n"}
{"name":"groupCohomology.mem_twoCoboundaries_iff","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles A) x\n⊢ Iff (Membership.mem (groupCohomology.twoCoboundaries A) f) (Exists fun x => ∀ (g h : G), Eq (HAdd.hAdd (HSub.hSub ((A.ρ g) (x h)) (x (HMul.hMul g h))) (x g)) (f { fst := g, snd := h }))","decl":"theorem mem_twoCoboundaries_iff (f : twoCocycles A) : f ∈ twoCoboundaries A ↔\n    ∃ x : G → A, ∀ g h : G, A.ρ g (x h) - x (g * h) + x g = f (g, h) := exists_congr fun x ↦ by\n  simpa only [LinearMap.codRestrict, dOne, LinearMap.coe_mk, AddHom.coe_mk] using\n    groupCohomology.twoCocycles_ext_iff\n\n"}
{"name":"groupCohomology.map_one_of_isOneCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝² : Monoid G\ninst✝¹ : AddCommGroup A\ninst✝ : MulAction G A\nf : G → A\nhf : groupCohomology.IsOneCocycle f\n⊢ Eq (f 1) 0","decl":"theorem map_one_of_isOneCocycle {f : G → A} (hf : IsOneCocycle f) :\n    f 1 = 0 := by\n  simpa only [mul_one, one_smul, self_eq_add_right] using hf 1 1\n\n"}
{"name":"groupCohomology.map_one_fst_of_isTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝² : Monoid G\ninst✝¹ : AddCommGroup A\ninst✝ : MulAction G A\nf : Prod G G → A\nhf : groupCohomology.IsTwoCocycle f\ng : G\n⊢ Eq (f { fst := 1, snd := g }) (f { fst := 1, snd := 1 })","decl":"theorem map_one_fst_of_isTwoCocycle {f : G × G → A} (hf : IsTwoCocycle f) (g : G) :\n    f (1, g) = f (1, 1) := by\n  simpa only [one_smul, one_mul, mul_one, add_right_inj] using (hf 1 1 g).symm\n\n"}
{"name":"groupCohomology.map_one_snd_of_isTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝² : Monoid G\ninst✝¹ : AddCommGroup A\ninst✝ : MulAction G A\nf : Prod G G → A\nhf : groupCohomology.IsTwoCocycle f\ng : G\n⊢ Eq (f { fst := g, snd := 1 }) (HSMul.hSMul g (f { fst := 1, snd := 1 }))","decl":"theorem map_one_snd_of_isTwoCocycle {f : G × G → A} (hf : IsTwoCocycle f) (g : G) :\n    f (g, 1) = g • f (1, 1) := by\n  simpa only [mul_one, add_left_inj] using hf g 1 1\n\n"}
{"name":"groupCohomology.map_inv_of_isOneCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝² : Group G\ninst✝¹ : AddCommGroup A\ninst✝ : MulAction G A\nf : G → A\nhf : groupCohomology.IsOneCocycle f\ng : G\n⊢ Eq (HSMul.hSMul g (f (Inv.inv g))) (Neg.neg (f g))","decl":"@[scoped simp] theorem map_inv_of_isOneCocycle {f : G → A} (hf : IsOneCocycle f) (g : G) :\n    g • f g⁻¹ = - f g := by\n  rw [← add_eq_zero_iff_eq_neg, ← map_one_of_isOneCocycle hf, ← mul_inv_cancel g, hf g g⁻¹]\n\n"}
{"name":"groupCohomology.smul_map_inv_sub_map_inv_of_isTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nA : Type u_2\ninst✝² : Group G\ninst✝¹ : AddCommGroup A\ninst✝ : MulAction G A\nf : Prod G G → A\nhf : groupCohomology.IsTwoCocycle f\ng : G\n⊢ Eq (HSub.hSub (HSMul.hSMul g (f { fst := Inv.inv g, snd := g })) (f { fst := g, snd := Inv.inv g })) (HSub.hSub (f { fst := 1, snd := 1 }) (f { fst := g, snd := 1 }))","decl":"theorem smul_map_inv_sub_map_inv_of_isTwoCocycle {f : G × G → A} (hf : IsTwoCocycle f) (g : G) :\n    g • f (g⁻¹, g) - f (g, g⁻¹) = f (1, 1) - f (g, 1) := by\n  have := hf g g⁻¹ g\n  simp only [mul_inv_cancel, inv_mul_cancel, map_one_fst_of_isTwoCocycle hf g] at this\n  exact sub_eq_sub_iff_add_eq_add.2 this.symm\n\n"}
{"name":"groupCohomology.isOneCocycle_of_oneCocycles","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G A : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Group G\ninst✝³ : AddCommGroup A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles (Rep.ofDistribMulAction k G A)) x\n⊢ groupCohomology.IsOneCocycle ⇑f","decl":"theorem isOneCocycle_of_oneCocycles (f : oneCocycles (Rep.ofDistribMulAction k G A)) :\n    IsOneCocycle (A := A) f := (mem_oneCocycles_iff f).1 f.2\n\n"}
{"name":"groupCohomology.isOneCoboundary_of_oneCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G A : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Group G\ninst✝³ : AddCommGroup A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\nf : Subtype fun x => Membership.mem (groupCohomology.oneCoboundaries (Rep.ofDistribMulAction k G A)) x\n⊢ groupCohomology.IsOneCoboundary ↑↑f","decl":"theorem isOneCoboundary_of_oneCoboundaries (f : oneCoboundaries (Rep.ofDistribMulAction k G A)) :\n    IsOneCoboundary (A := A) f.1.1 := by\n  rcases mem_range_of_mem_oneCoboundaries f.2 with ⟨x, hx⟩\n  exact ⟨x, by rw [← hx]; intro g; rfl⟩\n\n"}
{"name":"groupCohomology.isTwoCocycle_of_twoCocycles","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G A : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Group G\ninst✝³ : AddCommGroup A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles (Rep.ofDistribMulAction k G A)) x\n⊢ groupCohomology.IsTwoCocycle ⇑f","decl":"theorem isTwoCocycle_of_twoCocycles (f : twoCocycles (Rep.ofDistribMulAction k G A)) :\n    IsTwoCocycle (A := A) f := (mem_twoCocycles_iff f).1 f.2\n\n"}
{"name":"groupCohomology.isTwoCoboundary_of_twoCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G A : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Group G\ninst✝³ : AddCommGroup A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\nf : Subtype fun x => Membership.mem (groupCohomology.twoCoboundaries (Rep.ofDistribMulAction k G A)) x\n⊢ groupCohomology.IsTwoCoboundary ↑↑f","decl":"theorem isTwoCoboundary_of_twoCoboundaries (f : twoCoboundaries (Rep.ofDistribMulAction k G A)) :\n    IsTwoCoboundary (A := A) f.1.1 := by\n  rcases mem_range_of_mem_twoCoboundaries f.2 with ⟨x, hx⟩\n  exact ⟨x, fun g h => funext_iff.1 hx (g, h)⟩\n\n"}
{"name":"groupCohomology.map_one_of_isMulOneCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝² : Monoid G\ninst✝¹ : CommGroup M\ninst✝ : MulAction G M\nf : G → M\nhf : groupCohomology.IsMulOneCocycle f\n⊢ Eq (f 1) 1","decl":"theorem map_one_of_isMulOneCocycle {f : G → M} (hf : IsMulOneCocycle f) :\n    f 1 = 1 := by\n  simpa only [mul_one, one_smul, self_eq_mul_right] using hf 1 1\n\n"}
{"name":"groupCohomology.map_one_fst_of_isMulTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝² : Monoid G\ninst✝¹ : CommGroup M\ninst✝ : MulAction G M\nf : Prod G G → M\nhf : groupCohomology.IsMulTwoCocycle f\ng : G\n⊢ Eq (f { fst := 1, snd := g }) (f { fst := 1, snd := 1 })","decl":"theorem map_one_fst_of_isMulTwoCocycle {f : G × G → M} (hf : IsMulTwoCocycle f) (g : G) :\n    f (1, g) = f (1, 1) := by\n  simpa only [one_smul, one_mul, mul_one, mul_right_inj] using (hf 1 1 g).symm\n\n"}
{"name":"groupCohomology.map_one_snd_of_isMulTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝² : Monoid G\ninst✝¹ : CommGroup M\ninst✝ : MulAction G M\nf : Prod G G → M\nhf : groupCohomology.IsMulTwoCocycle f\ng : G\n⊢ Eq (f { fst := g, snd := 1 }) (HSMul.hSMul g (f { fst := 1, snd := 1 }))","decl":"theorem map_one_snd_of_isMulTwoCocycle {f : G × G → M} (hf : IsMulTwoCocycle f) (g : G) :\n    f (g, 1) = g • f (1, 1) := by\n  simpa only [mul_one, mul_left_inj] using hf g 1 1\n\n"}
{"name":"groupCohomology.map_inv_of_isMulOneCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulAction G M\nf : G → M\nhf : groupCohomology.IsMulOneCocycle f\ng : G\n⊢ Eq (HSMul.hSMul g (f (Inv.inv g))) (Inv.inv (f g))","decl":"@[scoped simp] theorem map_inv_of_isMulOneCocycle {f : G → M} (hf : IsMulOneCocycle f) (g : G) :\n    g • f g⁻¹ = (f g)⁻¹ := by\n  rw [← mul_eq_one_iff_eq_inv, ← map_one_of_isMulOneCocycle hf, ← mul_inv_cancel g, hf g g⁻¹]\n\n"}
{"name":"groupCohomology.smul_map_inv_div_map_inv_of_isMulTwoCocycle","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulAction G M\nf : Prod G G → M\nhf : groupCohomology.IsMulTwoCocycle f\ng : G\n⊢ Eq (HDiv.hDiv (HSMul.hSMul g (f { fst := Inv.inv g, snd := g })) (f { fst := g, snd := Inv.inv g })) (HDiv.hDiv (f { fst := 1, snd := 1 }) (f { fst := g, snd := 1 }))","decl":"theorem smul_map_inv_div_map_inv_of_isMulTwoCocycle\n    {f : G × G → M} (hf : IsMulTwoCocycle f) (g : G) :\n    g • f (g⁻¹, g) / f (g, g⁻¹) = f (1, 1) / f (g, 1) := by\n  have := hf g g⁻¹ g\n  simp only [mul_inv_cancel, inv_mul_cancel, map_one_fst_of_isMulTwoCocycle hf g] at this\n  exact div_eq_div_iff_mul_eq_mul.2 this.symm\n\n"}
{"name":"groupCohomology.isMulOneCocycle_of_oneCocycles","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G M : Type\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulDistribMulAction G M\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles (Rep.ofMulDistribMulAction G M)) x\n⊢ groupCohomology.IsMulOneCocycle (Function.comp ⇑Additive.toMul ⇑f)","decl":"theorem isMulOneCocycle_of_oneCocycles (f : oneCocycles (Rep.ofMulDistribMulAction G M)) :\n    IsMulOneCocycle (M := M) (Additive.toMul ∘ f) := (mem_oneCocycles_iff f).1 f.2\n\n"}
{"name":"groupCohomology.isMulOneCoboundary_of_oneCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G M : Type\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulDistribMulAction G M\nf : Subtype fun x => Membership.mem (groupCohomology.oneCoboundaries (Rep.ofMulDistribMulAction G M)) x\n⊢ groupCohomology.IsMulOneCoboundary (Function.comp ⇑Additive.ofMul ↑↑f)","decl":"theorem isMulOneCoboundary_of_oneCoboundaries\n    (f : oneCoboundaries (Rep.ofMulDistribMulAction G M)) :\n    IsMulOneCoboundary (M := M) (Additive.ofMul ∘ f.1.1) := by\n  rcases mem_range_of_mem_oneCoboundaries f.2 with ⟨x, hx⟩\n  exact ⟨x, by rw [← hx]; intro g; rfl⟩\n\n"}
{"name":"groupCohomology.isMulTwoCocycle_of_twoCocycles","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G M : Type\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulDistribMulAction G M\nf : Subtype fun x => Membership.mem (groupCohomology.twoCocycles (Rep.ofMulDistribMulAction G M)) x\n⊢ groupCohomology.IsMulTwoCocycle (Function.comp ⇑Additive.toMul ⇑f)","decl":"theorem isMulTwoCocycle_of_twoCocycles (f : twoCocycles (Rep.ofMulDistribMulAction G M)) :\n    IsMulTwoCocycle (M := M) (Additive.toMul ∘ f) := (mem_twoCocycles_iff f).1 f.2\n\n"}
{"name":"groupCohomology.isMulTwoCoboundary_of_twoCoboundaries","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"G M : Type\ninst✝² : Group G\ninst✝¹ : CommGroup M\ninst✝ : MulDistribMulAction G M\nf : Subtype fun x => Membership.mem (groupCohomology.twoCoboundaries (Rep.ofMulDistribMulAction G M)) x\n⊢ groupCohomology.IsMulTwoCoboundary (Function.comp ⇑Additive.toMul ↑↑f)","decl":"theorem isMulTwoCoboundary_of_twoCoboundaries\n    (f : twoCoboundaries (Rep.ofMulDistribMulAction G M)) :\n    IsMulTwoCoboundary (M := M) (Additive.toMul ∘ f.1.1) := by\n  rcases mem_range_of_mem_twoCoboundaries f.2 with ⟨x, hx⟩\n  exact ⟨x, fun g h => funext_iff.1 hx (g, h)⟩\n\n"}
{"name":"groupCohomology.H0LequivOfIsTrivial_eq_subtype","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\n⊢ Eq (↑(groupCohomology.H0LequivOfIsTrivial A)) A.ρ.invariants.subtype","decl":"@[simp] theorem H0LequivOfIsTrivial_eq_subtype [A.IsTrivial] :\n    H0LequivOfIsTrivial A = A.ρ.invariants.subtype := rfl\n\n"}
{"name":"groupCohomology.H0LequivOfIsTrivial_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nx : Subtype fun x => Membership.mem (groupCohomology.H0 A) x\n⊢ Eq ((groupCohomology.H0LequivOfIsTrivial A) x) ↑x","decl":"theorem H0LequivOfIsTrivial_apply [A.IsTrivial] (x : H0 A) :\n    H0LequivOfIsTrivial A x = x := rfl\n\n"}
{"name":"groupCohomology.H0LequivOfIsTrivial_symm_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nx : CoeSort.coe A\n⊢ Eq (↑((groupCohomology.H0LequivOfIsTrivial A).symm x)) x","decl":"@[simp] theorem H0LequivOfIsTrivial_symm_apply [A.IsTrivial] (x : A) :\n    (H0LequivOfIsTrivial A).symm x = x := rfl\n\n"}
{"name":"groupCohomology.H1LequivOfIsTrivial_comp_H1_π","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\n⊢ Eq ((↑(groupCohomology.H1LequivOfIsTrivial A)).comp (groupCohomology.H1_π A)) ↑(groupCohomology.oneCocyclesLequivOfIsTrivial A)","decl":"theorem H1LequivOfIsTrivial_comp_H1_π [A.IsTrivial] :\n    (H1LequivOfIsTrivial A).comp (H1_π A) = oneCocyclesLequivOfIsTrivial A := by\n  ext; rfl\n\n"}
{"name":"groupCohomology.H1LequivOfIsTrivial_H1_π_apply_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nf : Subtype fun x => Membership.mem (groupCohomology.oneCocycles A) x\nx : Additive G\n⊢ Eq (((groupCohomology.H1LequivOfIsTrivial A) ((groupCohomology.H1_π A) f)) x) (f (Additive.toMul x))","decl":"@[simp] theorem H1LequivOfIsTrivial_H1_π_apply_apply\n    [A.IsTrivial] (f : oneCocycles A) (x : Additive G) :\n    H1LequivOfIsTrivial A (H1_π A f) x = f x.toMul := rfl\n\n"}
{"name":"groupCohomology.H1LequivOfIsTrivial_symm_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝² : CommRing k\ninst✝¹ : Group G\nA : Rep k G\ninst✝ : A.IsTrivial\nf : AddMonoidHom (Additive G) (CoeSort.coe A)\n⊢ Eq ((groupCohomology.H1LequivOfIsTrivial A).symm f) ((groupCohomology.H1_π A) ((groupCohomology.oneCocyclesLequivOfIsTrivial A).symm f))","decl":"@[simp] theorem H1LequivOfIsTrivial_symm_apply [A.IsTrivial] (f : Additive G →+ A) :\n    (H1LequivOfIsTrivial A).symm f = H1_π A ((oneCocyclesLequivOfIsTrivial A).symm f) :=\n  rfl\n\n"}
{"name":"groupCohomology.dZero_comp_H0_subtype","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq ((groupCohomology.dZero A).comp (groupCohomology.H0 A).subtype) 0","decl":"lemma dZero_comp_H0_subtype : dZero A ∘ₗ (H0 A).subtype = 0 := by\n  ext ⟨x, hx⟩ g\n  replace hx := hx g\n  rw [← sub_eq_zero] at hx\n  exact hx\n\n"}
{"name":"groupCohomology.instMonoModuleCatFShortComplexH0","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ CategoryTheory.Mono (groupCohomology.shortComplexH0 A).f","decl":"instance : Mono (shortComplexH0 A).f := by\n  rw [ModuleCat.mono_iff_injective]\n  apply Submodule.injective_subtype\n\n"}
{"name":"groupCohomology.shortComplexH0_exact","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ (groupCohomology.shortComplexH0 A).Exact","decl":"lemma shortComplexH0_exact : (shortComplexH0 A).Exact := by\n  rw [ShortComplex.moduleCat_exact_iff]\n  intro (x : A) (hx : dZero _ x = 0)\n  refine ⟨⟨x, fun g => ?_⟩, rfl⟩\n  rw [← sub_eq_zero]\n  exact congr_fun hx g\n\n"}
{"name":"groupCohomology.dZeroArrowIso_hom_right","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.dZeroArrowIso A).hom.right (ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A))","decl":"/-- The arrow `A --dZero--> Fun(G, A)` is isomorphic to the differential\n`(inhomogeneousCochains A).d 0 1` of the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom_left hom_right inv_left inv_right]\ndef dZeroArrowIso : Arrow.mk ((inhomogeneousCochains A).d 0 1) ≅\n    Arrow.mk (ModuleCat.ofHom (dZero A)) :=\n  Arrow.isoMk (zeroCochainsLequiv A).toModuleIso\n    (oneCochainsLequiv A).toModuleIso (ModuleCat.hom_ext (dZero_comp_eq A))\n\n"}
{"name":"groupCohomology.dZeroArrowIso_hom_left","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.dZeroArrowIso A).hom.left (ModuleCat.ofHom ↑(groupCohomology.zeroCochainsLequiv A))","decl":"/-- The arrow `A --dZero--> Fun(G, A)` is isomorphic to the differential\n`(inhomogeneousCochains A).d 0 1` of the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom_left hom_right inv_left inv_right]\ndef dZeroArrowIso : Arrow.mk ((inhomogeneousCochains A).d 0 1) ≅\n    Arrow.mk (ModuleCat.ofHom (dZero A)) :=\n  Arrow.isoMk (zeroCochainsLequiv A).toModuleIso\n    (oneCochainsLequiv A).toModuleIso (ModuleCat.hom_ext (dZero_comp_eq A))\n\n"}
{"name":"groupCohomology.dZeroArrowIso_inv_left","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.dZeroArrowIso A).inv.left (ModuleCat.ofHom ↑(groupCohomology.zeroCochainsLequiv A).symm)","decl":"/-- The arrow `A --dZero--> Fun(G, A)` is isomorphic to the differential\n`(inhomogeneousCochains A).d 0 1` of the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom_left hom_right inv_left inv_right]\ndef dZeroArrowIso : Arrow.mk ((inhomogeneousCochains A).d 0 1) ≅\n    Arrow.mk (ModuleCat.ofHom (dZero A)) :=\n  Arrow.isoMk (zeroCochainsLequiv A).toModuleIso\n    (oneCochainsLequiv A).toModuleIso (ModuleCat.hom_ext (dZero_comp_eq A))\n\n"}
{"name":"groupCohomology.dZeroArrowIso_inv_right","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.dZeroArrowIso A).inv.right (ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A).symm)","decl":"/-- The arrow `A --dZero--> Fun(G, A)` is isomorphic to the differential\n`(inhomogeneousCochains A).d 0 1` of the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom_left hom_right inv_left inv_right]\ndef dZeroArrowIso : Arrow.mk ((inhomogeneousCochains A).d 0 1) ≅\n    Arrow.mk (ModuleCat.ofHom (dZero A)) :=\n  Arrow.isoMk (zeroCochainsLequiv A).toModuleIso\n    (oneCochainsLequiv A).toModuleIso (ModuleCat.hom_ext (dZero_comp_eq A))\n\n"}
{"name":"groupCohomology.isoZeroCocycles_hom_comp_subtype","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomology.isoZeroCocycles A).hom (ModuleCat.ofHom A.ρ.invariants.subtype)) (CategoryTheory.CategoryStruct.comp (groupCohomology.iCocycles A 0) (groupCohomology.zeroCochainsLequiv A).toModuleIso.hom)","decl":"lemma isoZeroCocycles_hom_comp_subtype :\n    (isoZeroCocycles A).hom ≫ ModuleCat.ofHom A.ρ.invariants.subtype =\n      iCocycles A 0 ≫ (zeroCochainsLequiv A).toModuleIso.hom := by\n  dsimp [isoZeroCocycles]\n  apply KernelFork.mapOfIsLimit_ι\n\n"}
{"name":"groupCohomology.groupCohomologyπ_comp_isoH0_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomologyπ A 0) (groupCohomology.isoH0 A).hom) (groupCohomology.isoZeroCocycles A).hom","decl":"lemma groupCohomologyπ_comp_isoH0_hom  :\n    groupCohomologyπ A 0 ≫ (isoH0 A).hom = (isoZeroCocycles A).hom := by\n  simp [isoH0]\n\n"}
{"name":"groupCohomology.shortComplexH1Iso_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.shortComplexH1Iso A).hom { τ₁ := ModuleCat.ofHom ↑(groupCohomology.zeroCochainsLequiv A), τ₂ := ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A), τ₃ := ModuleCat.ofHom ↑(groupCohomology.twoCochainsLequiv A), comm₁₂ := ⋯, comm₂₃ := ⋯ }","decl":"/-- The short complex `A --dZero--> Fun(G, A) --dOne--> Fun(G × G, A)` is isomorphic to the 1st\nshort complex associated to the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom inv]\ndef shortComplexH1Iso : (inhomogeneousCochains A).sc' 0 1 2 ≅ shortComplexH1 A :=\n    isoMk (zeroCochainsLequiv A).toModuleIso (oneCochainsLequiv A).toModuleIso\n      (twoCochainsLequiv A).toModuleIso\n        (ModuleCat.hom_ext (dZero_comp_eq A))\n        (ModuleCat.hom_ext (dOne_comp_eq A))\n\n"}
{"name":"groupCohomology.shortComplexH1Iso_inv","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.shortComplexH1Iso A).inv (CategoryTheory.ShortComplex.homMk (ModuleCat.ofHom ↑(groupCohomology.zeroCochainsLequiv A).symm) (ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A).symm) (ModuleCat.ofHom ↑(groupCohomology.twoCochainsLequiv A).symm) ⋯ ⋯)","decl":"/-- The short complex `A --dZero--> Fun(G, A) --dOne--> Fun(G × G, A)` is isomorphic to the 1st\nshort complex associated to the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom inv]\ndef shortComplexH1Iso : (inhomogeneousCochains A).sc' 0 1 2 ≅ shortComplexH1 A :=\n    isoMk (zeroCochainsLequiv A).toModuleIso (oneCochainsLequiv A).toModuleIso\n      (twoCochainsLequiv A).toModuleIso\n        (ModuleCat.hom_ext (dZero_comp_eq A))\n        (ModuleCat.hom_ext (dOne_comp_eq A))\n\n"}
{"name":"groupCohomology.isoOneCocycles_hom_comp_subtype","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomology.isoOneCocycles A).hom (ModuleCat.ofHom (groupCohomology.oneCocycles A).subtype)) (CategoryTheory.CategoryStruct.comp (groupCohomology.iCocycles A 1) (groupCohomology.oneCochainsLequiv A).toModuleIso.hom)","decl":"lemma isoOneCocycles_hom_comp_subtype :\n    (isoOneCocycles A).hom ≫ ModuleCat.ofHom (oneCocycles A).subtype =\n      iCocycles A 1 ≫ (oneCochainsLequiv A).toModuleIso.hom := by\n  dsimp [isoOneCocycles]\n  rw [Category.assoc, Category.assoc]\n  erw [(shortComplexH1 A).moduleCatCyclesIso_hom_subtype]\n  rw [cyclesMap_i, HomologicalComplex.cyclesIsoSc'_hom_iCycles_assoc]\n\n"}
{"name":"groupCohomology.toCocycles_comp_isoOneCocycles_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomology.toCocycles A 0 1) (groupCohomology.isoOneCocycles A).hom) (CategoryTheory.CategoryStruct.comp (groupCohomology.zeroCochainsLequiv A).toModuleIso.hom (ModuleCat.ofHom (groupCohomology.shortComplexH1 A).moduleCatToCycles))","decl":"lemma toCocycles_comp_isoOneCocycles_hom :\n    toCocycles A 0 1 ≫ (isoOneCocycles A).hom =\n      (zeroCochainsLequiv A).toModuleIso.hom ≫\n        ModuleCat.ofHom (shortComplexH1 A).moduleCatToCycles := by\n  simp [isoOneCocycles]\n\n"}
{"name":"groupCohomology.groupCohomologyπ_comp_isoH1_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomologyπ A 1) (groupCohomology.isoH1 A).hom) (CategoryTheory.CategoryStruct.comp (groupCohomology.isoOneCocycles A).hom (groupCohomology.shortComplexH1 A).moduleCatHomologyπ)","decl":"lemma groupCohomologyπ_comp_isoH1_hom  :\n    groupCohomologyπ A 1 ≫ (isoH1 A).hom =\n      (isoOneCocycles A).hom ≫ (shortComplexH1 A).moduleCatHomologyπ := by\n  simp [isoH1, isoOneCocycles]\n\n"}
{"name":"groupCohomology.shortComplexH2Iso_inv","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.shortComplexH2Iso A).inv (CategoryTheory.ShortComplex.homMk (ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A).symm) (ModuleCat.ofHom ↑(groupCohomology.twoCochainsLequiv A).symm) (ModuleCat.ofHom ↑(groupCohomology.threeCochainsLequiv A).symm) ⋯ ⋯)","decl":"/-- The short complex `Fun(G, A) --dOne--> Fun(G × G, A) --dTwo--> Fun(G × G × G, A)` is\nisomorphic to the 2nd short complex associated to the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom inv]\ndef shortComplexH2Iso :\n    (inhomogeneousCochains A).sc' 1 2 3 ≅ shortComplexH2 A :=\n  isoMk (oneCochainsLequiv A).toModuleIso (twoCochainsLequiv A).toModuleIso\n    (threeCochainsLequiv A).toModuleIso\n      (ModuleCat.hom_ext (dOne_comp_eq A))\n      (ModuleCat.hom_ext (dTwo_comp_eq A))\n\n"}
{"name":"groupCohomology.shortComplexH2Iso_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (groupCohomology.shortComplexH2Iso A).hom { τ₁ := ModuleCat.ofHom ↑(groupCohomology.oneCochainsLequiv A), τ₂ := ModuleCat.ofHom ↑(groupCohomology.twoCochainsLequiv A), τ₃ := ModuleCat.ofHom ↑(groupCohomology.threeCochainsLequiv A), comm₁₂ := ⋯, comm₂₃ := ⋯ }","decl":"/-- The short complex `Fun(G, A) --dOne--> Fun(G × G, A) --dTwo--> Fun(G × G × G, A)` is\nisomorphic to the 2nd short complex associated to the complex of inhomogeneous cochains of `A`. -/\n@[simps! hom inv]\ndef shortComplexH2Iso :\n    (inhomogeneousCochains A).sc' 1 2 3 ≅ shortComplexH2 A :=\n  isoMk (oneCochainsLequiv A).toModuleIso (twoCochainsLequiv A).toModuleIso\n    (threeCochainsLequiv A).toModuleIso\n      (ModuleCat.hom_ext (dOne_comp_eq A))\n      (ModuleCat.hom_ext (dTwo_comp_eq A))\n\n"}
{"name":"groupCohomology.isoTwoCocycles_hom_comp_subtype","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomology.isoTwoCocycles A).hom (ModuleCat.ofHom (groupCohomology.twoCocycles A).subtype)) (CategoryTheory.CategoryStruct.comp (groupCohomology.iCocycles A 2) (groupCohomology.twoCochainsLequiv A).toModuleIso.hom)","decl":"lemma isoTwoCocycles_hom_comp_subtype :\n    (isoTwoCocycles A).hom ≫ ModuleCat.ofHom (twoCocycles A).subtype =\n      iCocycles A 2 ≫ (twoCochainsLequiv A).toModuleIso.hom := by\n  dsimp [isoTwoCocycles]\n  rw [Category.assoc, Category.assoc]\n  erw [(shortComplexH2 A).moduleCatCyclesIso_hom_subtype]\n  rw [cyclesMap_i, HomologicalComplex.cyclesIsoSc'_hom_iCycles_assoc]\n\n"}
{"name":"groupCohomology.toCocycles_comp_isoTwoCocycles_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomology.toCocycles A 1 2) (groupCohomology.isoTwoCocycles A).hom) (CategoryTheory.CategoryStruct.comp (groupCohomology.oneCochainsLequiv A).toModuleIso.hom (ModuleCat.ofHom (groupCohomology.shortComplexH2 A).moduleCatToCycles))","decl":"lemma toCocycles_comp_isoTwoCocycles_hom :\n    toCocycles A 1 2 ≫ (isoTwoCocycles A).hom =\n      (oneCochainsLequiv A).toModuleIso.hom ≫\n        ModuleCat.ofHom (shortComplexH2 A).moduleCatToCycles := by\n  simp [isoTwoCocycles]\n\n"}
{"name":"groupCohomology.groupCohomologyπ_comp_isoH2_hom","module":"Mathlib.RepresentationTheory.GroupCohomology.LowDegree","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (groupCohomologyπ A 2) (groupCohomology.isoH2 A).hom) (CategoryTheory.CategoryStruct.comp (groupCohomology.isoTwoCocycles A).hom (groupCohomology.shortComplexH2 A).moduleCatHomologyπ)","decl":"lemma groupCohomologyπ_comp_isoH2_hom  :\n    groupCohomologyπ A 2 ≫ (isoH2 A).hom =\n      (isoTwoCocycles A).hom ≫ (shortComplexH2 A).moduleCatHomologyπ := by\n  simp [isoH2, isoTwoCocycles]\n\n"}
