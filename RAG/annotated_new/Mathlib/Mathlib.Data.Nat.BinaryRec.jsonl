{"name":"Nat.shiftRight_one","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"n : Nat\n⊢ Eq (HShiftRight.hShiftRight n 1) (HDiv.hDiv n 2)","decl":"theorem shiftRight_one (n) : n >>> 1 = n / 2 := rfl\n\n"}
{"name":"Nat.bit_decide_mod_two_eq_one_shiftRight_one","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"n : Nat\n⊢ Eq (Nat.bit (Decidable.decide (Eq (HMod.hMod n 2) 1)) (HShiftRight.hShiftRight n 1)) n","decl":"@[simp]\ntheorem bit_decide_mod_two_eq_one_shiftRight_one (n : Nat) : bit (n % 2 = 1) (n >>> 1) = n := by\n  simp only [bit, shiftRight_one]\n  cases mod_two_eq_zero_or_one n with | _ h => simpa [h] using Nat.div_add_mod n 2\n\n"}
{"name":"Nat.bit_testBit_zero_shiftRight_one","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"n : Nat\n⊢ Eq (Nat.bit (n.testBit 0) (HShiftRight.hShiftRight n 1)) n","decl":"theorem bit_testBit_zero_shiftRight_one (n : Nat) : bit (n.testBit 0) (n >>> 1) = n := by\n  simp\n\n"}
{"name":"Nat.bit_eq_zero_iff","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"n : Nat\nb : Bool\n⊢ Iff (Eq (Nat.bit b n) 0) (And (Eq n 0) (Eq b Bool.false))","decl":"@[simp]\ntheorem bit_eq_zero_iff {n : Nat} {b : Bool} : bit b n = 0 ↔ n = 0 ∧ b = false := by\n  cases n <;> cases b <;> simp [bit, Nat.shiftLeft_succ, Nat.two_mul, ← Nat.add_assoc]\n\n"}
{"name":"Nat.bit_val","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Nat.bit b n) (HAdd.hAdd (HMul.hMul 2 n) b.toNat)","decl":"theorem bit_val (b n) : bit b n = 2 * n + b.toNat := by\n  cases b <;> rfl\n\n"}
{"name":"Nat.bit_div_two","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (HDiv.hDiv (Nat.bit b n) 2) n","decl":"@[simp]\ntheorem bit_div_two (b n) : bit b n / 2 = n := by\n  rw [bit_val, Nat.add_comm, add_mul_div_left, div_eq_of_lt, Nat.zero_add]\n  · cases b <;> decide\n  · decide\n\n"}
{"name":"Nat.bit_mod_two","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (HMod.hMod (Nat.bit b n) 2) b.toNat","decl":"@[simp]\ntheorem bit_mod_two (b n) : bit b n % 2 = b.toNat := by\n  cases b <;> simp [bit_val, mul_add_mod]\n\n"}
{"name":"Nat.bit_shiftRight_one","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (HShiftRight.hShiftRight (Nat.bit b n) 1) n","decl":"@[simp]\ntheorem bit_shiftRight_one (b n) : bit b n >>> 1 = n :=\n  bit_div_two b n\n\n"}
{"name":"Nat.testBit_bit_zero","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"b : Bool\nn : Nat\n⊢ Eq ((Nat.bit b n).testBit 0) b","decl":"theorem testBit_bit_zero (b n) : (bit b n).testBit 0 = b := by\n  simp\n\n"}
{"name":"Nat.bitCasesOn_bit","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"motive : Nat → Sort u\nh : (b : Bool) → (n : Nat) → motive (Nat.bit b n)\nb : Bool\nn : Nat\n⊢ Eq (Nat.bitCasesOn (Nat.bit b n) h) (h b n)","decl":"@[simp]\ntheorem bitCasesOn_bit (h : ∀ b n, motive (bit b n)) (b : Bool) (n : Nat) :\n    bitCasesOn (bit b n) h = h b n := by\n  change congrArg motive (bit b n).bit_testBit_zero_shiftRight_one ▸ h _ _ = h b n\n  generalize congrArg motive (bit b n).bit_testBit_zero_shiftRight_one = e; revert e\n  rw [testBit_bit_zero, bit_shiftRight_one]\n  intros; rfl\n\n"}
{"name":"Nat.binaryRec_zero","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"motive : Nat → Sort u\nz : motive 0\nf : (b : Bool) → (n : Nat) → motive n → motive (Nat.bit b n)\n⊢ Eq (Nat.binaryRec z f 0) z","decl":"unseal binaryRec in\n@[simp]\ntheorem binaryRec_zero (z : motive 0) (f : ∀ b n, motive n → motive (bit b n)) :\n    binaryRec z f 0 = z :=\n  rfl\n\n"}
{"name":"Nat.binaryRec_one","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"motive : Nat → Sort u\nz : motive 0\nf : (b : Bool) → (n : Nat) → motive n → motive (Nat.bit b n)\n⊢ Eq (Nat.binaryRec z f 1) (f Bool.true 0 z)","decl":"@[simp]\ntheorem binaryRec_one (z : motive 0) (f : ∀ b n, motive n → motive (bit b n)) :\n    binaryRec (motive := motive) z f 1 = f true 0 z := by\n  rw [binaryRec]\n  simp only [add_one_ne_zero, ↓reduceDIte, Nat.reduceShiftRight, binaryRec_zero]\n  rfl\n\n"}
{"name":"Nat.binaryRec_eq","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"motive : Nat → Sort u\nz : motive 0\nf : (b : Bool) → (n : Nat) → motive n → motive (Nat.bit b n)\nb : Bool\nn : Nat\nh : Or (Eq (f Bool.false 0 z) z) (Eq n 0 → Eq b Bool.true)\n⊢ Eq (Nat.binaryRec z f (Nat.bit b n)) (f b n (Nat.binaryRec z f n))","decl":"theorem binaryRec_eq {z : motive 0} {f : ∀ b n, motive n → motive (bit b n)}\n    (b n) (h : f false 0 z = z ∨ (n = 0 → b = true)) :\n    binaryRec z f (bit b n) = f b n (binaryRec z f n) := by\n  by_cases h' : bit b n = 0\n  case pos =>\n    obtain ⟨rfl, rfl⟩ := bit_eq_zero_iff.mp h'\n    simp only [Bool.false_eq_true, imp_false, not_true_eq_false, or_false] at h\n    unfold binaryRec\n    exact h.symm\n  case neg =>\n    rw [binaryRec, dif_neg h']\n    change congrArg motive (bit b n).bit_testBit_zero_shiftRight_one ▸ f _ _ _ = _\n    generalize congrArg motive (bit b n).bit_testBit_zero_shiftRight_one = e; revert e\n    rw [testBit_bit_zero, bit_shiftRight_one]\n    intros; rfl\n\n"}
{"name":"Nat.binaryRec_eq'","module":"Mathlib.Data.Nat.BinaryRec","initialProofState":"motive : Nat → Sort u\nz : motive 0\nf : (b : Bool) → (n : Nat) → motive n → motive (Nat.bit b n)\nb : Bool\nn : Nat\nh : Or (Eq (f Bool.false 0 z) z) (Eq n 0 → Eq b Bool.true)\n⊢ Eq (Nat.binaryRec z f (Nat.bit b n)) (f b n (Nat.binaryRec z f n))","decl":"@[deprecated (since := \"2024-10-21\")] alias binaryRec_eq' := binaryRec_eq\n\n"}
