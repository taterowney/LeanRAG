{"name":"Pi.algebraMap_def","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\na : R\n⊢ Eq ((algebraMap R ((i : ι) → A i)) a) fun i => (algebraMap R (A i)) a","decl":"theorem algebraMap_def (a : R) : algebraMap R (Π i, A i) a = fun i ↦ algebraMap R (A i) a :=\n  rfl\n\n"}
{"name":"Pi.algebraMap_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\na : R\ni : ι\n⊢ Eq ((algebraMap R ((i : ι) → A i)) a i) ((algebraMap R (A i)) a)","decl":"@[simp]\ntheorem algebraMap_apply (a : R) (i : ι) : algebraMap R (Π i, A i) a i = algebraMap R (A i) a :=\n  rfl\n\n"}
{"name":"Pi.algHom_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → Semiring (A i)\ninst✝² : (i : ι) → Algebra R (A i)\nB : Type u_4\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\ng : (i : ι) → AlgHom R B (A i)\nx : B\nb : ι\n⊢ Eq ((Pi.algHom R A g) x b) ((g b) x)","decl":"/-- A family of algebra homomorphisms `g i : B →ₐ[R] A i` defines a ring homomorphism\n`Pi.algHom g : B →ₐ[R] Π i, A i` given by `Pi.algHom g x i = g i x`. -/\n@[simps!]\ndef algHom {B : Type*} [Semiring B] [Algebra R B] (g : ∀ i, B →ₐ[R] A i) : B →ₐ[R] Π i, A i where\n  __ := Pi.ringHom fun i ↦ (g i).toRingHom\n  commutes' r := by ext; simp\n\n"}
{"name":"Pi.evalAlgHom_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\ni : ι\nf : (i : ι) → A i\n⊢ Eq ((Pi.evalAlgHom R A i) f) (f i)","decl":"/-- `Function.eval` as an `AlgHom`. The name matches `Pi.evalRingHom`, `Pi.evalMonoidHom`,\netc. -/\n@[simps]\ndef evalAlgHom (i : ι) : (Π i, A i) →ₐ[R] A i :=\n  { Pi.evalRingHom A i with\n    toFun := fun f ↦ f i\n    commutes' := fun _ ↦ rfl }\n\n"}
{"name":"Pi.algHom_evalAlgHom","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\n⊢ Eq (Pi.algHom R A (Pi.evalAlgHom R A)) (AlgHom.id R ((i : ι) → A i))","decl":"@[simp]\ntheorem algHom_evalAlgHom : algHom R A (evalAlgHom R A) = AlgHom.id R (Π i, A i) := rfl\n\n"}
{"name":"Pi.algHom_comp","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"ι : Type u_1\nR : Type u_2\nA : ι → Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → Semiring (A i)\ninst✝⁴ : (i : ι) → Algebra R (A i)\nB : Type u_4\nC : Type u_5\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\ng : (i : ι) → AlgHom R C (A i)\nh : AlgHom R B C\n⊢ Eq ((Pi.algHom R A g).comp h) (Pi.algHom R A fun i => (g i).comp h)","decl":"/-- `Pi.algHom` commutes with composition. -/\ntheorem algHom_comp {B C : Type*} [Semiring B] [Algebra R B] [Semiring C] [Algebra R C]\n    (g : ∀ i, C →ₐ[R] A i) (h : B →ₐ[R] C) :\n    (algHom R A g).comp h = algHom R A (fun i ↦ (g i).comp h) := rfl\n\n"}
{"name":"Pi.constAlgHom_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_2\ninst✝² : CommSemiring R\nA : Type u_5\nB : Type u_6\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\na : B\na✝ : A\n⊢ Eq ((Pi.constAlgHom R A B) a a✝) (Function.const A a a✝)","decl":"/-- `Function.const` as an `AlgHom`. The name matches `Pi.constRingHom`, `Pi.constMonoidHom`,\netc. -/\n@[simps]\ndef constAlgHom : B →ₐ[R] A → B :=\n  { Pi.constRingHom A B with\n    toFun := Function.const _\n    commutes' := fun _ ↦ rfl }\n\n"}
{"name":"Pi.constRingHom_eq_algebraMap","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nA : Type u_5\n⊢ Eq (Pi.constRingHom A R) (algebraMap R (A → R))","decl":"/-- When `R` is commutative and permits an `algebraMap`, `Pi.constRingHom` is equal to that\nmap. -/\n@[simp]\ntheorem constRingHom_eq_algebraMap : constRingHom A R = algebraMap R (A → R) :=\n  rfl\n\n"}
{"name":"Pi.constAlgHom_eq_algebra_ofId","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_2\ninst✝ : CommSemiring R\nA : Type u_5\n⊢ Eq (Pi.constAlgHom R A R) (Algebra.ofId R (A → R))","decl":"@[simp]\ntheorem constAlgHom_eq_algebra_ofId : constAlgHom R A R = Algebra.ofId R (A → R) :=\n  rfl\n\n"}
{"name":"AlgHom.compLeft_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nι : Type u_4\nh : ι → A\na✝ : ι\n⊢ Eq ((f.compLeft ι) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- `R`-algebra homomorphism between the function spaces `ι → A` and `ι → B`, induced by an\n`R`-algebra homomorphism `f` between `A` and `B`. -/\n@[simps]\nprotected def compLeft (f : A →ₐ[R] B) (ι : Type*) : (ι → A) →ₐ[R] ι → B :=\n  { f.toRingHom.compLeft ι with\n    toFun := fun h ↦ f ∘ h\n    commutes' := fun c ↦ by\n      ext\n      exact f.commutes' c }\n\n"}
{"name":"AlgEquiv.piCongrRight_apply","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_1\nι : Type u_2\nA₁ : ι → Type u_3\nA₂ : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → Semiring (A₁ i)\ninst✝² : (i : ι) → Semiring (A₂ i)\ninst✝¹ : (i : ι) → Algebra R (A₁ i)\ninst✝ : (i : ι) → Algebra R (A₂ i)\ne : (i : ι) → AlgEquiv R (A₁ i) (A₂ i)\nx : (i : ι) → A₁ i\nj : ι\n⊢ Eq ((AlgEquiv.piCongrRight e) x j) ((e j) (x j))","decl":"/-- A family of algebra equivalences `∀ i, (A₁ i ≃ₐ A₂ i)` generates a\nmultiplicative equivalence between `Π i, A₁ i` and `Π i, A₂ i`.\n\nThis is the `AlgEquiv` version of `Equiv.piCongrRight`, and the dependent version of\n`AlgEquiv.arrowCongr`.\n-/\n@[simps apply]\ndef piCongrRight (e : ∀ i, A₁ i ≃ₐ[R] A₂ i) : (Π i, A₁ i) ≃ₐ[R] Π i, A₂ i :=\n  { @RingEquiv.piCongrRight ι A₁ A₂ _ _ fun i ↦ (e i).toRingEquiv with\n    toFun := fun x j ↦ e j (x j)\n    invFun := fun x j ↦ (e j).symm (x j)\n    commutes' := fun r ↦ by\n      ext i\n      simp }\n\n"}
{"name":"AlgEquiv.piCongrRight_refl","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_1\nι : Type u_2\nA₁ : ι → Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A₁ i)\ninst✝ : (i : ι) → Algebra R (A₁ i)\n⊢ Eq (AlgEquiv.piCongrRight fun i => AlgEquiv.refl) AlgEquiv.refl","decl":"@[simp]\ntheorem piCongrRight_refl :\n    (piCongrRight fun i ↦ (AlgEquiv.refl : A₁ i ≃ₐ[R] A₁ i)) = AlgEquiv.refl :=\n  rfl\n\n"}
{"name":"AlgEquiv.piCongrRight_symm","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_1\nι : Type u_2\nA₁ : ι → Type u_3\nA₂ : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → Semiring (A₁ i)\ninst✝² : (i : ι) → Semiring (A₂ i)\ninst✝¹ : (i : ι) → Algebra R (A₁ i)\ninst✝ : (i : ι) → Algebra R (A₂ i)\ne : (i : ι) → AlgEquiv R (A₁ i) (A₂ i)\n⊢ Eq (AlgEquiv.piCongrRight e).symm (AlgEquiv.piCongrRight fun i => (e i).symm)","decl":"@[simp]\ntheorem piCongrRight_symm (e : ∀ i, A₁ i ≃ₐ[R] A₂ i) :\n    (piCongrRight e).symm = piCongrRight fun i ↦ (e i).symm :=\n  rfl\n\n"}
{"name":"AlgEquiv.piCongrRight_trans","module":"Mathlib.Algebra.Algebra.Pi","initialProofState":"R : Type u_1\nι : Type u_2\nA₁ : ι → Type u_3\nA₂ : ι → Type u_4\nA₃ : ι → Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → Semiring (A₁ i)\ninst✝⁴ : (i : ι) → Semiring (A₂ i)\ninst✝³ : (i : ι) → Semiring (A₃ i)\ninst✝² : (i : ι) → Algebra R (A₁ i)\ninst✝¹ : (i : ι) → Algebra R (A₂ i)\ninst✝ : (i : ι) → Algebra R (A₃ i)\ne₁ : (i : ι) → AlgEquiv R (A₁ i) (A₂ i)\ne₂ : (i : ι) → AlgEquiv R (A₂ i) (A₃ i)\n⊢ Eq ((AlgEquiv.piCongrRight e₁).trans (AlgEquiv.piCongrRight e₂)) (AlgEquiv.piCongrRight fun i => (e₁ i).trans (e₂ i))","decl":"@[simp]\ntheorem piCongrRight_trans (e₁ : ∀ i, A₁ i ≃ₐ[R] A₂ i) (e₂ : ∀ i, A₂ i ≃ₐ[R] A₃ i) :\n    (piCongrRight e₁).trans (piCongrRight e₂) = piCongrRight fun i ↦ (e₁ i).trans (e₂ i) :=\n  rfl\n\n"}
