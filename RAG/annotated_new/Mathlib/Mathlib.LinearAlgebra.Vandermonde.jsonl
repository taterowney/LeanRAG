{"name":"Matrix.vandermonde_apply","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\ni j : Fin n\n⊢ Eq (Matrix.vandermonde v i j) (HPow.hPow (v i) ↑j)","decl":"@[simp]\ntheorem vandermonde_apply {n : ℕ} (v : Fin n → R) (i j) : vandermonde v i j = v i ^ (j : ℕ) :=\n  rfl\n\n"}
{"name":"Matrix.vandermonde_cons","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv0 : R\nv : Fin n → R\n⊢ Eq (Matrix.vandermonde (Fin.cons v0 v)) (Fin.cons (fun j => HPow.hPow v0 ↑j) fun i => Fin.cons 1 fun j => HMul.hMul (v i) (Matrix.vandermonde v i j))","decl":"@[simp]\ntheorem vandermonde_cons {n : ℕ} (v0 : R) (v : Fin n → R) :\n    vandermonde (Fin.cons v0 v : Fin n.succ → R) =\n      Fin.cons (fun (j : Fin n.succ) => v0 ^ (j : ℕ)) fun i => Fin.cons 1\n      fun j => v i * vandermonde v i j := by\n  ext i j\n  refine Fin.cases (by simp) (fun i => ?_) i\n  refine Fin.cases (by simp) (fun j => ?_) j\n  simp [pow_succ']\n\n"}
{"name":"Matrix.vandermonde_succ","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n.succ → R\n⊢ Eq (Matrix.vandermonde v) (Matrix.of Fin.cons (fun j => HPow.hPow (v 0) ↑j) fun i => Fin.cons 1 fun j => HMul.hMul (v i.succ) (Matrix.vandermonde (Fin.tail v) i j))","decl":"theorem vandermonde_succ {n : ℕ} (v : Fin n.succ → R) :\n    vandermonde v = .of\n      Fin.cons (fun (j : Fin n.succ) => v 0 ^ (j : ℕ)) fun i =>\n        Fin.cons 1 fun j => v i.succ * vandermonde (Fin.tail v) i j := by\n  conv_lhs => rw [← Fin.cons_self_tail v, vandermonde_cons]\n  rfl\n\n"}
{"name":"Matrix.vandermonde_mul_vandermonde_transpose","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv w : Fin n → R\ni j : Fin n\n⊢ Eq (HMul.hMul (Matrix.vandermonde v) (Matrix.vandermonde w).transpose i j) (Finset.univ.sum fun k => HPow.hPow (HMul.hMul (v i) (w j)) ↑k)","decl":"theorem vandermonde_mul_vandermonde_transpose {n : ℕ} (v w : Fin n → R) (i j) :\n    (vandermonde v * (vandermonde w)ᵀ) i j = ∑ k : Fin n, (v i * w j) ^ (k : ℕ) := by\n  simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, mul_pow]\n\n"}
{"name":"Matrix.vandermonde_transpose_mul_vandermonde","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\ni j : Fin n\n⊢ Eq (HMul.hMul (Matrix.vandermonde v).transpose (Matrix.vandermonde v) i j) (Finset.univ.sum fun k => HPow.hPow (v k) (HAdd.hAdd ↑i ↑j))","decl":"theorem vandermonde_transpose_mul_vandermonde {n : ℕ} (v : Fin n → R) (i j) :\n    ((vandermonde v)ᵀ * vandermonde v) i j = ∑ k : Fin n, v k ^ (i + j : ℕ) := by\n  simp only [vandermonde_apply, Matrix.mul_apply, Matrix.transpose_apply, pow_add]\n\n"}
{"name":"Matrix.det_vandermonde","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\n⊢ Eq (Matrix.vandermonde v).det (Finset.univ.prod fun i => (Finset.Ioi i).prod fun j => HSub.hSub (v j) (v i))","decl":"theorem det_vandermonde {n : ℕ} (v : Fin n → R) :\n    det (vandermonde v) = ∏ i : Fin n, ∏ j ∈ Ioi i, (v j - v i) := by\n  unfold vandermonde\n  induction' n with n ih\n  · exact det_eq_one_of_card_eq_zero (Fintype.card_fin 0)\n  calc\n    det (of fun i j : Fin n.succ => v i ^ (j : ℕ)) =\n        det\n          (of fun i j : Fin n.succ =>\n            Matrix.vecCons (v 0 ^ (j : ℕ)) (fun i => v (Fin.succ i) ^ (j : ℕ) - v 0 ^ (j : ℕ)) i) :=\n      det_eq_of_forall_row_eq_smul_add_const (Matrix.vecCons 0 1) 0 (Fin.cons_zero _ _) ?_\n    _ =\n        det\n          (of fun i j : Fin n =>\n            Matrix.vecCons (v 0 ^ (j.succ : ℕ))\n              (fun i : Fin n => v (Fin.succ i) ^ (j.succ : ℕ) - v 0 ^ (j.succ : ℕ))\n              (Fin.succAbove 0 i)) := by\n      simp_rw [det_succ_column_zero, Fin.sum_univ_succ, of_apply, Matrix.cons_val_zero, submatrix,\n        of_apply, Matrix.cons_val_succ, Fin.val_zero, pow_zero, one_mul, sub_self,\n        mul_zero, zero_mul, Finset.sum_const_zero, add_zero]\n    _ =\n        det\n          (of fun i j : Fin n =>\n              (v (Fin.succ i) - v 0) *\n                ∑ k ∈ Finset.range (j + 1 : ℕ), v i.succ ^ k * v 0 ^ (j - k : ℕ) :\n            Matrix _ _ R) := by\n      congr\n      ext i j\n      rw [Fin.succAbove_zero, Matrix.cons_val_succ, Fin.val_succ, mul_comm]\n      exact (geom_sum₂_mul (v i.succ) (v 0) (j + 1 : ℕ)).symm\n    _ =\n        (∏ i ∈ Finset.univ, (v (Fin.succ i) - v 0)) *\n          det fun i j : Fin n =>\n            ∑ k ∈ Finset.range (j + 1 : ℕ), v i.succ ^ k * v 0 ^ (j - k : ℕ) :=\n      (det_mul_column (fun i => v (Fin.succ i) - v 0) _)\n    _ = (∏ i ∈ Finset.univ, (v (Fin.succ i) - v 0)) *\n    det (of fun i j : Fin n => v (Fin.succ i) ^ (j : ℕ)) := congr_arg _ ?_\n    _ = ∏ i : Fin n.succ, ∏ j ∈ Ioi i, (v j - v i) := by\n      simp_rw [Fin.prod_univ_succ, Fin.prod_Ioi_zero, Fin.prod_Ioi_succ]\n      have h : (of fun i j : Fin n ↦ v i.succ ^ (j : ℕ)).det =\n          ∏ x : Fin n, ∏ y ∈ Ioi x, (v y.succ - v x.succ) := by\n        simpa using ih (v ∘ Fin.succ)\n      rw [h]\n\n  · intro i j\n    simp_rw [of_apply]\n    rw [Matrix.cons_val_zero]\n    refine Fin.cases ?_ (fun i => ?_) i\n    · simp\n    rw [Matrix.cons_val_succ, Matrix.cons_val_succ, Pi.one_apply]\n    ring\n  · cases n\n    · rw [det_eq_one_of_card_eq_zero (Fintype.card_fin 0),\n      det_eq_one_of_card_eq_zero (Fintype.card_fin 0)]\n    apply det_eq_of_forall_col_eq_smul_add_pred fun _ => v 0\n    · intro j\n      simp\n    · intro i j\n      simp only [smul_eq_mul, Pi.add_apply, Fin.val_succ, Fin.coe_castSucc, Pi.smul_apply]\n      rw [Finset.sum_range_succ, add_comm, tsub_self, pow_zero, mul_one, Finset.mul_sum]\n      congr 1\n      refine Finset.sum_congr rfl fun i' hi' => ?_\n      rw [mul_left_comm (v 0), Nat.succ_sub, pow_succ']\n      exact Nat.lt_succ_iff.mp (Finset.mem_range.mp hi')\n\n"}
{"name":"Matrix.det_vandermonde_eq_zero_iff","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nv : Fin n → R\n⊢ Iff (Eq (Matrix.vandermonde v).det 0) (Exists fun i => Exists fun j => And (Eq (v i) (v j)) (Ne i j))","decl":"theorem det_vandermonde_eq_zero_iff [IsDomain R] {n : ℕ} {v : Fin n → R} :\n    det (vandermonde v) = 0 ↔ ∃ i j : Fin n, v i = v j ∧ i ≠ j := by\n  constructor\n  · simp only [det_vandermonde v, Finset.prod_eq_zero_iff, sub_eq_zero, forall_exists_index]\n    rintro i ⟨_, j, h₁, h₂⟩\n    exact ⟨j, i, h₂, (mem_Ioi.mp h₁).ne'⟩\n  · simp only [Ne, forall_exists_index, and_imp]\n    refine fun i j h₁ h₂ => Matrix.det_zero_of_row_eq h₂ (funext fun k => ?_)\n    rw [vandermonde_apply, vandermonde_apply, h₁]\n\n"}
{"name":"Matrix.det_vandermonde_ne_zero_iff","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nv : Fin n → R\n⊢ Iff (Ne (Matrix.vandermonde v).det 0) (Function.Injective v)","decl":"theorem det_vandermonde_ne_zero_iff [IsDomain R] {n : ℕ} {v : Fin n → R} :\n    det (vandermonde v) ≠ 0 ↔ Function.Injective v := by\n  unfold Function.Injective\n  simp only [det_vandermonde_eq_zero_iff, Ne, not_exists, not_and, Classical.not_not]\n\n"}
{"name":"Matrix.det_vandermonde_add","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\na : R\n⊢ Eq (Matrix.vandermonde fun i => HAdd.hAdd (v i) a).det (Matrix.vandermonde v).det","decl":"@[simp]\ntheorem det_vandermonde_add {n : ℕ} (v : Fin n → R) (a : R) :\n    (Matrix.vandermonde fun i ↦ v i + a).det = (Matrix.vandermonde v).det := by\n  simp [Matrix.det_vandermonde]\n\n"}
{"name":"Matrix.det_vandermonde_sub","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\na : R\n⊢ Eq (Matrix.vandermonde fun i => HSub.hSub (v i) a).det (Matrix.vandermonde v).det","decl":"@[simp]\ntheorem det_vandermonde_sub {n : ℕ} (v : Fin n → R) (a : R) :\n    (Matrix.vandermonde fun i ↦ v i - a).det = (Matrix.vandermonde v).det := by\n  rw [← det_vandermonde_add v (- a)]\n  simp only [← sub_eq_add_neg]\n\n"}
{"name":"Matrix.eq_zero_of_forall_index_sum_pow_mul_eq_zero","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nf v : Fin n → R\nhf : Function.Injective f\nhfv : ∀ (j : Fin n), Eq (Finset.univ.sum fun i => HMul.hMul (HPow.hPow (f j) ↑i) (v i)) 0\n⊢ Eq v 0","decl":"theorem eq_zero_of_forall_index_sum_pow_mul_eq_zero {R : Type*} [CommRing R] [IsDomain R] {n : ℕ}\n    {f v : Fin n → R} (hf : Function.Injective f)\n    (hfv : ∀ j, (∑ i : Fin n, f j ^ (i : ℕ) * v i) = 0) : v = 0 :=\n  eq_zero_of_mulVec_eq_zero (det_vandermonde_ne_zero_iff.mpr hf) (funext hfv)\n\n"}
{"name":"Matrix.eq_zero_of_forall_index_sum_mul_pow_eq_zero","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nf v : Fin n → R\nhf : Function.Injective f\nhfv : ∀ (j : Fin n), Eq (Finset.univ.sum fun i => HMul.hMul (v i) (HPow.hPow (f j) ↑i)) 0\n⊢ Eq v 0","decl":"theorem eq_zero_of_forall_index_sum_mul_pow_eq_zero {R : Type*} [CommRing R] [IsDomain R] {n : ℕ}\n    {f v : Fin n → R} (hf : Function.Injective f) (hfv : ∀ j, (∑ i, v i * f j ^ (i : ℕ)) = 0) :\n    v = 0 := by\n  apply eq_zero_of_forall_index_sum_pow_mul_eq_zero hf\n  simp_rw [mul_comm]\n  exact hfv\n\n"}
{"name":"Matrix.eq_zero_of_forall_pow_sum_mul_pow_eq_zero","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_2\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nn : Nat\nf v : Fin n → R\nhf : Function.Injective f\nhfv : ∀ (i : Fin n), Eq (Finset.univ.sum fun j => HMul.hMul (v j) (HPow.hPow (f j) ↑i)) 0\n⊢ Eq v 0","decl":"theorem eq_zero_of_forall_pow_sum_mul_pow_eq_zero {R : Type*} [CommRing R] [IsDomain R] {n : ℕ}\n    {f v : Fin n → R} (hf : Function.Injective f)\n    (hfv : ∀ i : Fin n, (∑ j : Fin n, v j * f j ^ (i : ℕ)) = 0) : v = 0 :=\n  eq_zero_of_vecMul_eq_zero (det_vandermonde_ne_zero_iff.mpr hf) (funext hfv)\n\n"}
{"name":"Matrix.eval_matrixOfPolynomials_eq_vandermonde_mul_matrixOfPolynomials","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\np : Fin n → Polynomial R\nh_deg : ∀ (i : Fin n), LE.le (p i).natDegree ↑i\n⊢ Eq (Matrix.of fun i j => Polynomial.eval (v i) (p j)) (HMul.hMul (Matrix.vandermonde v) (Matrix.of fun i j => (p j).coeff ↑i))","decl":"theorem eval_matrixOfPolynomials_eq_vandermonde_mul_matrixOfPolynomials {n : ℕ}\n    (v : Fin n → R) (p : Fin n → R[X]) (h_deg : ∀ i, (p i).natDegree ≤ i) :\n    Matrix.of (fun i j => ((p j).eval (v i))) =\n    (Matrix.vandermonde v) * (Matrix.of (fun (i j : Fin n) => (p j).coeff i)) := by\n  ext i j\n  rw [Matrix.mul_apply, eval, Matrix.of_apply, eval₂]\n  simp only [eq_intCast, Int.cast_id, Matrix.vandermonde]\n  have : (p j).support ⊆ range n := supp_subset_range <| Nat.lt_of_le_of_lt (h_deg j) <| Fin.prop j\n  rw [sum_eq_of_subset _ (fun j => zero_mul ((v i) ^ j)) this, ← Fin.sum_univ_eq_sum_range]\n  congr\n  ext k\n  rw [mul_comm, Matrix.of_apply, RingHom.id_apply, of_apply]\n\n"}
{"name":"Matrix.det_eval_matrixOfPolynomials_eq_det_vandermonde","module":"Mathlib.LinearAlgebra.Vandermonde","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nv : Fin n → R\np : Fin n → Polynomial R\nh_deg : ∀ (i : Fin n), Eq (p i).natDegree ↑i\nh_monic : ∀ (i : Fin n), (p i).Monic\n⊢ Eq (Matrix.vandermonde v).det (Matrix.of fun i j => Polynomial.eval (v i) (p j)).det","decl":"theorem det_eval_matrixOfPolynomials_eq_det_vandermonde {n : ℕ} (v : Fin n → R) (p : Fin n → R[X])\n    (h_deg : ∀ i, (p i).natDegree = i) (h_monic : ∀ i, Monic <| p i) :\n    (Matrix.vandermonde v).det = (Matrix.of (fun i j => ((p j).eval (v i)))).det := by\n  rw [Matrix.eval_matrixOfPolynomials_eq_vandermonde_mul_matrixOfPolynomials v p (fun i ↦\n      Nat.le_of_eq (h_deg i)), Matrix.det_mul,\n      Matrix.det_matrixOfPolynomials p h_deg h_monic, mul_one]\n\n"}
