{"name":"Stream'.WSeq.not_mem_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\n⊢ Not (Membership.mem Stream'.WSeq.nil a)","decl":"theorem not_mem_nil (a : α) : a ∉ @nil α :=\n  Seq.not_mem_nil (some a)\n\n"}
{"name":"Stream'.WSeq.IsFinite.out","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nself : s.IsFinite\n⊢ s.toList.Terminates","decl":"/-- A weak sequence is finite if `toList s` terminates. Equivalently,\n  it is a finite number of `think` and `cons` applied to `nil`. -/\nclass IsFinite (s : WSeq α) : Prop where\n  out : (toList s).Terminates\n\n"}
{"name":"Stream'.WSeq.toList_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nh : s.IsFinite\n⊢ s.toList.Terminates","decl":"instance toList_terminates (s : WSeq α) [h : IsFinite s] : (toList s).Terminates :=\n  h.out\n\n"}
{"name":"Stream'.WSeq.Productive.get?_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nself : s.Productive\nn : Nat\n⊢ (s.get? n).Terminates","decl":"/-- A weak sequence is *productive* if it never stalls forever - there are\n always a finite number of `think`s between `cons` constructors.\n The sequence itself is allowed to be infinite though. -/\nclass Productive (s : WSeq α) : Prop where\n  get?_terminates : ∀ n, (get? s n).Terminates\n\n"}
{"name":"Stream'.WSeq.productive_iff","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Iff s.Productive (∀ (n : Nat), (s.get? n).Terminates)","decl":"theorem productive_iff (s : WSeq α) : Productive s ↔ ∀ n, (get? s n).Terminates :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Stream'.WSeq.get?_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nh : s.Productive\nn : Nat\n⊢ (s.get? n).Terminates","decl":"instance get?_terminates (s : WSeq α) [h : Productive s] : ∀ n, (get? s n).Terminates :=\n  h.get?_terminates\n\n"}
{"name":"Stream'.WSeq.head_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\ninst✝ : s.Productive\n⊢ s.head.Terminates","decl":"instance head_terminates (s : WSeq α) [Productive s] : (head s).Terminates :=\n  s.get?_terminates 0\n\n"}
{"name":"Stream'.WSeq.LiftRelO.imp","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR S : α → β → Prop\nC D : Stream'.WSeq α → Stream'.WSeq β → Prop\nH1 : ∀ (a : α) (b : β), R a b → S a b\nH2 : ∀ (s : Stream'.WSeq α) (t : Stream'.WSeq β), C s t → D s t\no : Option (Prod α (Stream'.WSeq α))\np : Option (Prod β (Stream'.WSeq β))\na✝ : Stream'.WSeq.LiftRelO R C o p\n⊢ Stream'.WSeq.LiftRelO S D o p","decl":"theorem LiftRelO.imp {R S : α → β → Prop} {C D : WSeq α → WSeq β → Prop} (H1 : ∀ a b, R a b → S a b)\n    (H2 : ∀ s t, C s t → D s t) : ∀ {o p}, LiftRelO R C o p → LiftRelO S D o p\n  | none, none, _ => trivial\n  | some (_, _), some (_, _), h => And.imp (H1 _ _) (H2 _ _) h\n  | none, some _, h => False.elim h\n  | some (_, _), none, h => False.elim h\n\n"}
{"name":"Stream'.WSeq.LiftRelO.imp_right","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC D : Stream'.WSeq α → Stream'.WSeq β → Prop\nH : ∀ (s : Stream'.WSeq α) (t : Stream'.WSeq β), C s t → D s t\no : Option (Prod α (Stream'.WSeq α))\np : Option (Prod β (Stream'.WSeq β))\na✝ : Stream'.WSeq.LiftRelO R C o p\n⊢ Stream'.WSeq.LiftRelO R D o p","decl":"theorem LiftRelO.imp_right (R : α → β → Prop) {C D : WSeq α → WSeq β → Prop}\n    (H : ∀ s t, C s t → D s t) {o p} : LiftRelO R C o p → LiftRelO R D o p :=\n  LiftRelO.imp (fun _ _ => id) H\n\n"}
{"name":"Stream'.WSeq.BisimO.imp","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nR S : Stream'.WSeq α → Stream'.WSeq α → Prop\nH : ∀ (s t : Stream'.WSeq α), R s t → S s t\no p : Option (Prod α (Stream'.WSeq α))\na✝ : Stream'.WSeq.BisimO R o p\n⊢ Stream'.WSeq.BisimO S o p","decl":"theorem BisimO.imp {R S : WSeq α → WSeq α → Prop} (H : ∀ s t, R s t → S s t) {o p} :\n    BisimO R o p → BisimO S o p :=\n  LiftRelO.imp_right _ H\n\n"}
{"name":"Stream'.WSeq.liftRel_destruct","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\na✝ : Stream'.WSeq.LiftRel R s t\n⊢ Computation.LiftRel (Stream'.WSeq.LiftRelO R (Stream'.WSeq.LiftRel R)) s.destruct t.destruct","decl":"theorem liftRel_destruct {R : α → β → Prop} {s : WSeq α} {t : WSeq β} :\n    LiftRel R s t → Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t)\n  | ⟨R, h1, h2⟩ => by\n    refine Computation.LiftRel.imp ?_ _ _ (h2 h1)\n    apply LiftRelO.imp_right\n    exact fun s' t' h' => ⟨R, h', @h2⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_destruct_iff","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\n⊢ Iff (Stream'.WSeq.LiftRel R s t) (Computation.LiftRel (Stream'.WSeq.LiftRelO R (Stream'.WSeq.LiftRel R)) s.destruct t.destruct)","decl":"theorem liftRel_destruct_iff {R : α → β → Prop} {s : WSeq α} {t : WSeq β} :\n    LiftRel R s t ↔ Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t) :=\n  ⟨liftRel_destruct, fun h =>\n    ⟨fun s t =>\n      LiftRel R s t ∨ Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t),\n      Or.inr h, fun {s t} h => by\n      have h : Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct s) (destruct t) := by\n        cases' h with h h\n        · exact liftRel_destruct h\n        · assumption\n      apply Computation.LiftRel.imp _ _ _ h\n      intro a b\n      apply LiftRelO.imp_right\n      intro s t\n      apply Or.inl⟩⟩\n\n-- Porting note: To avoid ambiguous notation, `~` became `~ʷ`.\n"}
{"name":"Stream'.WSeq.destruct_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\na✝ : s.Equiv t\n⊢ Computation.LiftRel (Stream'.WSeq.BisimO fun x1 x2 => x1.Equiv x2) s.destruct t.destruct","decl":"theorem destruct_congr {s t : WSeq α} :\n    s ~ʷ t → Computation.LiftRel (BisimO (· ~ʷ ·)) (destruct s) (destruct t) :=\n  liftRel_destruct\n\n"}
{"name":"Stream'.WSeq.destruct_congr_iff","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\n⊢ Iff (s.Equiv t) (Computation.LiftRel (Stream'.WSeq.BisimO fun x1 x2 => x1.Equiv x2) s.destruct t.destruct)","decl":"theorem destruct_congr_iff {s t : WSeq α} :\n    s ~ʷ t ↔ Computation.LiftRel (BisimO (· ~ʷ ·)) (destruct s) (destruct t) :=\n  liftRel_destruct_iff\n\n"}
{"name":"Stream'.WSeq.LiftRel.refl","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nR : α → α → Prop\nH : Reflexive R\n⊢ Reflexive (Stream'.WSeq.LiftRel R)","decl":"theorem LiftRel.refl (R : α → α → Prop) (H : Reflexive R) : Reflexive (LiftRel R) := fun s => by\n  refine ⟨(· = ·), rfl, fun {s t} (h : s = t) => ?_⟩\n  rw [← h]\n  apply Computation.LiftRel.refl\n  intro a\n  cases' a with a\n  · simp\n  · cases a\n    simp only [LiftRelO, and_true]\n    apply H\n\n"}
{"name":"Stream'.WSeq.LiftRelO.swap","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nC : Stream'.WSeq α → Stream'.WSeq β → Prop\n⊢ Eq (Function.swap (Stream'.WSeq.LiftRelO R C)) (Stream'.WSeq.LiftRelO (Function.swap R) (Function.swap C))","decl":"theorem LiftRelO.swap (R : α → β → Prop) (C) :\n    swap (LiftRelO R C) = LiftRelO (swap R) (swap C) := by\n  funext x y\n  rcases x with ⟨⟩ | ⟨hx, jx⟩ <;> rcases y with ⟨⟩ | ⟨hy, jy⟩ <;> rfl\n\n"}
{"name":"Stream'.WSeq.LiftRel.swap_lem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns1 : Stream'.WSeq α\ns2 : Stream'.WSeq β\nh : Stream'.WSeq.LiftRel R s1 s2\n⊢ Stream'.WSeq.LiftRel (Function.swap R) s2 s1","decl":"theorem LiftRel.swap_lem {R : α → β → Prop} {s1 s2} (h : LiftRel R s1 s2) :\n    LiftRel (swap R) s2 s1 := by\n  refine ⟨swap (LiftRel R), h, fun {s t} (h : LiftRel R t s) => ?_⟩\n  rw [← LiftRelO.swap, Computation.LiftRel.swap]\n  apply liftRel_destruct h\n\n"}
{"name":"Stream'.WSeq.LiftRel.swap","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\n⊢ Eq (Function.swap (Stream'.WSeq.LiftRel R)) (Stream'.WSeq.LiftRel (Function.swap R))","decl":"theorem LiftRel.swap (R : α → β → Prop) : swap (LiftRel R) = LiftRel (swap R) :=\n  funext fun _ => funext fun _ => propext ⟨LiftRel.swap_lem, LiftRel.swap_lem⟩\n\n"}
{"name":"Stream'.WSeq.LiftRel.symm","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nR : α → α → Prop\nH : Symmetric R\n⊢ Symmetric (Stream'.WSeq.LiftRel R)","decl":"theorem LiftRel.symm (R : α → α → Prop) (H : Symmetric R) : Symmetric (LiftRel R) :=\n  fun s1 s2 (h : Function.swap (LiftRel R) s2 s1) => by rwa [LiftRel.swap, H.swap_eq] at h\n\n"}
{"name":"Stream'.WSeq.LiftRel.trans","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nR : α → α → Prop\nH : Transitive R\n⊢ Transitive (Stream'.WSeq.LiftRel R)","decl":"theorem LiftRel.trans (R : α → α → Prop) (H : Transitive R) : Transitive (LiftRel R) :=\n  fun s t u h1 h2 => by\n  refine ⟨fun s u => ∃ t, LiftRel R s t ∧ LiftRel R t u, ⟨t, h1, h2⟩, fun {s u} h => ?_⟩\n  rcases h with ⟨t, h1, h2⟩\n  have h1 := liftRel_destruct h1\n  have h2 := liftRel_destruct h2\n  refine\n    Computation.liftRel_def.2\n      ⟨(Computation.terminates_of_liftRel h1).trans (Computation.terminates_of_liftRel h2),\n        fun {a c} ha hc => ?_⟩\n  rcases h1.left ha with ⟨b, hb, t1⟩\n  have t2 := Computation.rel_of_liftRel h2 hb hc\n  cases' a with a <;> cases' c with c\n  · trivial\n  · cases b\n    · cases t2\n    · cases t1\n  · cases a\n    cases' b with b\n    · cases t1\n    · cases b\n      cases t2\n  · cases' a with a s\n    cases' b with b\n    · cases t1\n    cases' b with b t\n    cases' c with c u\n    cases' t1 with ab st\n    cases' t2 with bc tu\n    exact ⟨H ab bc, t, st, tu⟩\n\n"}
{"name":"Stream'.WSeq.LiftRel.equiv","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nR : α → α → Prop\na✝ : Equivalence R\n⊢ Equivalence (Stream'.WSeq.LiftRel R)","decl":"theorem LiftRel.equiv (R : α → α → Prop) : Equivalence R → Equivalence (LiftRel R)\n  | ⟨refl, symm, trans⟩ => ⟨LiftRel.refl R refl, @(LiftRel.symm R @symm), @(LiftRel.trans R @trans)⟩\n\n"}
{"name":"Stream'.WSeq.Equiv.refl","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ s.Equiv s","decl":"@[refl]\ntheorem Equiv.refl : ∀ s : WSeq α, s ~ʷ s :=\n  LiftRel.refl (· = ·) Eq.refl\n\n"}
{"name":"Stream'.WSeq.Equiv.symm","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\na✝ : s.Equiv t\n⊢ t.Equiv s","decl":"@[symm]\ntheorem Equiv.symm : ∀ {s t : WSeq α}, s ~ʷ t → t ~ʷ s :=\n  @(LiftRel.symm (· = ·) (@Eq.symm _))\n\n"}
{"name":"Stream'.WSeq.Equiv.trans","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t u : Stream'.WSeq α\na✝¹ : s.Equiv t\na✝ : t.Equiv u\n⊢ s.Equiv u","decl":"@[trans]\ntheorem Equiv.trans : ∀ {s t u : WSeq α}, s ~ʷ t → t ~ʷ u → s ~ʷ u :=\n  @(LiftRel.trans (· = ·) (@Eq.trans _))\n\n"}
{"name":"Stream'.WSeq.Equiv.equivalence","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Equivalence Stream'.WSeq.Equiv","decl":"theorem Equiv.equivalence : Equivalence (@Equiv α) :=\n  ⟨@Equiv.refl _, @Equiv.symm _, @Equiv.trans _⟩\n\n"}
{"name":"Stream'.WSeq.destruct_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq Stream'.WSeq.nil.destruct (Computation.pure Option.none)","decl":"@[simp]\ntheorem destruct_nil : destruct (nil : WSeq α) = Computation.pure none :=\n  Computation.destruct_eq_pure rfl\n\n"}
{"name":"Stream'.WSeq.destruct_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.cons a s).destruct (Computation.pure (Option.some { fst := a, snd := s }))","decl":"@[simp]\ntheorem destruct_cons (a : α) (s) : destruct (cons a s) = Computation.pure (some (a, s)) :=\n  Computation.destruct_eq_pure <| by simp [destruct, cons, Computation.rmap]\n\n"}
{"name":"Stream'.WSeq.destruct_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq s.think.destruct s.destruct.think","decl":"@[simp]\ntheorem destruct_think (s : WSeq α) : destruct (think s) = (destruct s).think :=\n  Computation.destruct_eq_think <| by simp [destruct, think, Computation.rmap]\n\n"}
{"name":"Stream'.WSeq.seq_destruct_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq (Stream'.Seq.destruct Stream'.WSeq.nil) Option.none","decl":"@[simp]\ntheorem seq_destruct_nil : Seq.destruct (nil : WSeq α) = none :=\n  Seq.destruct_nil\n\n"}
{"name":"Stream'.WSeq.seq_destruct_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.Seq.destruct (Stream'.WSeq.cons a s)) (Option.some { fst := Option.some a, snd := s })","decl":"@[simp]\ntheorem seq_destruct_cons (a : α) (s) : Seq.destruct (cons a s) = some (some a, s) :=\n  Seq.destruct_cons _ _\n\n"}
{"name":"Stream'.WSeq.seq_destruct_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq (Stream'.Seq.destruct s.think) (Option.some { fst := Option.none, snd := s })","decl":"@[simp]\ntheorem seq_destruct_think (s : WSeq α) : Seq.destruct (think s) = some (none, s) :=\n  Seq.destruct_cons _ _\n\n"}
{"name":"Stream'.WSeq.head_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq Stream'.WSeq.nil.head (Computation.pure Option.none)","decl":"@[simp]\ntheorem head_nil : head (nil : WSeq α) = Computation.pure none := by simp [head]\n\n"}
{"name":"Stream'.WSeq.head_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.cons a s).head (Computation.pure (Option.some a))","decl":"@[simp]\ntheorem head_cons (a : α) (s) : head (cons a s) = Computation.pure (some a) := by simp [head]\n\n"}
{"name":"Stream'.WSeq.head_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq s.think.head s.head.think","decl":"@[simp]\ntheorem head_think (s : WSeq α) : head (think s) = (head s).think := by simp [head]\n\n"}
{"name":"Stream'.WSeq.flatten_pure","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.flatten (Computation.pure s)) s","decl":"@[simp]\ntheorem flatten_pure (s : WSeq α) : flatten (Computation.pure s) = s := by\n  refine Seq.eq_of_bisim (fun s1 s2 => flatten (Computation.pure s2) = s1) ?_ rfl\n  intro s' s h\n  rw [← h]\n  simp only [Seq.BisimO, flatten, Seq.omap, pure_def, Seq.corec_eq, destruct_pure]\n  cases Seq.destruct s with\n  | none => simp\n  | some val =>\n    cases' val with o s'\n    simp\n\n"}
{"name":"Stream'.WSeq.flatten_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nc : Computation (Stream'.WSeq α)\n⊢ Eq (Stream'.WSeq.flatten c.think) (Stream'.WSeq.flatten c).think","decl":"@[simp]\ntheorem flatten_think (c : Computation (WSeq α)) : flatten c.think = think (flatten c) :=\n  Seq.destruct_eq_cons <| by simp [flatten, think]\n\n"}
{"name":"Stream'.WSeq.destruct_flatten","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nc : Computation (Stream'.WSeq α)\n⊢ Eq (Stream'.WSeq.flatten c).destruct (Bind.bind c Stream'.WSeq.destruct)","decl":"@[simp]\ntheorem destruct_flatten (c : Computation (WSeq α)) : destruct (flatten c) = c >>= destruct := by\n  refine\n    Computation.eq_of_bisim\n      (fun c1 c2 => c1 = c2 ∨ ∃ c, c1 = destruct (flatten c) ∧ c2 = Computation.bind c destruct) ?_\n      (Or.inr ⟨c, rfl, rfl⟩)\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | c, _, Or.inl rfl => by cases c.destruct <;> simp\n    | _, _, Or.inr ⟨c, rfl, rfl⟩ => by\n      induction' c using Computation.recOn with a c'\n      · simp; cases (destruct a).destruct <;> simp\n      · simpa using Or.inr ⟨c', rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.head_terminates_iff","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Iff s.head.Terminates s.destruct.Terminates","decl":"theorem head_terminates_iff (s : WSeq α) : Terminates (head s) ↔ Terminates (destruct s) :=\n  terminates_map_iff _ (destruct s)\n\n"}
{"name":"Stream'.WSeq.tail_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq Stream'.WSeq.nil.tail Stream'.WSeq.nil","decl":"@[simp]\ntheorem tail_nil : tail (nil : WSeq α) = nil := by simp [tail]\n\n"}
{"name":"Stream'.WSeq.tail_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.cons a s).tail s","decl":"@[simp]\ntheorem tail_cons (a : α) (s) : tail (cons a s) = s := by simp [tail]\n\n"}
{"name":"Stream'.WSeq.tail_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq s.think.tail s.tail.think","decl":"@[simp]\ntheorem tail_think (s : WSeq α) : tail (think s) = (tail s).think := by simp [tail]\n\n"}
{"name":"Stream'.WSeq.dropn_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (Stream'.WSeq.nil.drop n) Stream'.WSeq.nil","decl":"@[simp]\ntheorem dropn_nil (n) : drop (nil : WSeq α) n = nil := by induction n <;> simp [*, drop]\n\n"}
{"name":"Stream'.WSeq.dropn_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\nn : Nat\n⊢ Eq ((Stream'.WSeq.cons a s).drop (HAdd.hAdd n 1)) (s.drop n)","decl":"@[simp]\ntheorem dropn_cons (a : α) (s) (n) : drop (cons a s) (n + 1) = drop s n := by\n  induction n with\n  | zero => simp [drop]\n  | succ n n_ih =>\n    simp [drop, ← n_ih]\n\n"}
{"name":"Stream'.WSeq.dropn_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\n⊢ Eq (s.think.drop n) (s.drop n).think","decl":"@[simp]\ntheorem dropn_think (s : WSeq α) (n) : drop (think s) n = (drop s n).think := by\n  induction n <;> simp [*, drop]\n\n"}
{"name":"Stream'.WSeq.dropn_add","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nm n : Nat\n⊢ Eq (s.drop (HAdd.hAdd m n)) ((s.drop m).drop n)","decl":"theorem dropn_add (s : WSeq α) (m) : ∀ n, drop s (m + n) = drop (drop s m) n\n  | 0 => rfl\n  | n + 1 => congr_arg tail (dropn_add s m n)\n\n"}
{"name":"Stream'.WSeq.dropn_tail","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\n⊢ Eq (s.tail.drop n) (s.drop (HAdd.hAdd n 1))","decl":"theorem dropn_tail (s : WSeq α) (n) : drop (tail s) n = drop s (n + 1) := by\n  rw [Nat.add_comm]\n  symm\n  apply dropn_add\n\n"}
{"name":"Stream'.WSeq.get?_add","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nm n : Nat\n⊢ Eq (s.get? (HAdd.hAdd m n)) ((s.drop m).get? n)","decl":"theorem get?_add (s : WSeq α) (m n) : get? s (m + n) = get? (drop s m) n :=\n  congr_arg head (dropn_add _ _ _)\n\n"}
{"name":"Stream'.WSeq.get?_tail","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\n⊢ Eq (s.tail.get? n) (s.get? (HAdd.hAdd n 1))","decl":"theorem get?_tail (s : WSeq α) (n) : get? (tail s) n = get? s (n + 1) :=\n  congr_arg head (dropn_tail _ _)\n\n"}
{"name":"Stream'.WSeq.join_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq Stream'.WSeq.nil.join Stream'.WSeq.nil","decl":"@[simp]\ntheorem join_nil : join nil = (nil : WSeq α) :=\n  Seq.join_nil\n\n"}
{"name":"Stream'.WSeq.join_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nS : Stream'.WSeq (Stream'.WSeq α)\n⊢ Eq S.think.join S.join.think","decl":"@[simp]\ntheorem join_think (S : WSeq (WSeq α)) : join (think S) = think (join S) := by\n  simp only [join, think]\n  dsimp only [(· <$> ·)]\n  simp [join, Seq1.ret]\n\n"}
{"name":"Stream'.WSeq.join_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nS : Stream'.WSeq (Stream'.WSeq α)\n⊢ Eq (Stream'.WSeq.cons s S).join (s.append S.join).think","decl":"@[simp]\ntheorem join_cons (s : WSeq α) (S) : join (cons s S) = think (append s (join S)) := by\n  simp only [join, think]\n  dsimp only [(· <$> ·)]\n  simp [join, cons, append]\n\n"}
{"name":"Stream'.WSeq.nil_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.nil.append s) s","decl":"@[simp]\ntheorem nil_append (s : WSeq α) : append nil s = s :=\n  Seq.nil_append _\n\n"}
{"name":"Stream'.WSeq.cons_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns t : Stream'.WSeq α\n⊢ Eq ((Stream'.WSeq.cons a s).append t) (Stream'.WSeq.cons a (s.append t))","decl":"@[simp]\ntheorem cons_append (a : α) (s t) : append (cons a s) t = cons a (append s t) :=\n  Seq.cons_append _ _ _\n\n"}
{"name":"Stream'.WSeq.think_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\n⊢ Eq (s.think.append t) (s.append t).think","decl":"@[simp]\ntheorem think_append (s t : WSeq α) : append (think s) t = think (append s t) :=\n  Seq.cons_append _ _ _\n\n"}
{"name":"Stream'.WSeq.append_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq (s.append Stream'.WSeq.nil) s","decl":"@[simp]\ntheorem append_nil (s : WSeq α) : append s nil = s :=\n  Seq.append_nil _\n\n"}
{"name":"Stream'.WSeq.append_assoc","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t u : Stream'.WSeq α\n⊢ Eq ((s.append t).append u) (s.append (t.append u))","decl":"@[simp]\ntheorem append_assoc (s t u : WSeq α) : append (append s t) u = append s (append t u) :=\n  Seq.append_assoc _ _ _\n\n"}
{"name":"Stream'.WSeq.destruct_tail","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq s.tail.destruct (Bind.bind s.destruct Stream'.WSeq.tail.aux)","decl":"theorem destruct_tail (s : WSeq α) : destruct (tail s) = destruct s >>= tail.aux := by\n  simp only [tail, destruct_flatten, tail.aux]; rw [← bind_pure_comp, LawfulMonad.bind_assoc]\n  apply congr_arg; ext1 (_ | ⟨a, s⟩) <;> apply (@pure_bind Computation _ _ _ _ _ _).trans _ <;> simp\n\n"}
{"name":"Stream'.WSeq.drop.aux_none","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (Stream'.WSeq.drop.aux n Option.none) (Computation.pure Option.none)","decl":"theorem drop.aux_none : ∀ n, @drop.aux α n none = Computation.pure none\n  | 0 => rfl\n  | n + 1 =>\n    show Computation.bind (Computation.pure none) (drop.aux n) = Computation.pure none by\n      rw [ret_bind, drop.aux_none n]\n\n"}
{"name":"Stream'.WSeq.destruct_dropn","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\n⊢ Eq (s.drop n).destruct (Bind.bind s.destruct (Stream'.WSeq.drop.aux n))","decl":"theorem destruct_dropn : ∀ (s : WSeq α) (n), destruct (drop s n) = destruct s >>= drop.aux n\n  | _, 0 => (bind_pure' _).symm\n  | s, n + 1 => by\n    rw [← dropn_tail, destruct_dropn _ n, destruct_tail, LawfulMonad.bind_assoc]\n    rfl\n\n"}
{"name":"Stream'.WSeq.head_terminates_of_head_tail_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nT : s.tail.head.Terminates\n⊢ s.head.Terminates","decl":"theorem head_terminates_of_head_tail_terminates (s : WSeq α) [T : Terminates (head (tail s))] :\n    Terminates (head s) :=\n  (head_terminates_iff _).2 <| by\n    rcases (head_terminates_iff _).1 T with ⟨⟨a, h⟩⟩\n    simp? [tail] at h says simp only [tail, destruct_flatten, bind_map_left] at h\n    rcases exists_of_mem_bind h with ⟨s', h1, _⟩\n    exact terminates_of_mem h1\n\n"}
{"name":"Stream'.WSeq.destruct_some_of_destruct_tail_some","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : Prod α (Stream'.WSeq α)\nh : Membership.mem s.tail.destruct (Option.some a)\n⊢ Exists fun a' => Membership.mem s.destruct (Option.some a')","decl":"theorem destruct_some_of_destruct_tail_some {s : WSeq α} {a} (h : some a ∈ destruct (tail s)) :\n    ∃ a', some a' ∈ destruct s := by\n  unfold tail Functor.map at h; simp only [destruct_flatten] at h\n  rcases exists_of_mem_bind h with ⟨t, tm, td⟩; clear h\n  rcases Computation.exists_of_mem_map tm with ⟨t', ht', ht2⟩; clear tm\n  cases' t' with t' <;> rw [← ht2] at td <;> simp only [destruct_nil] at td\n  · have := mem_unique td (ret_mem _)\n    contradiction\n  · exact ⟨_, ht'⟩\n\n"}
{"name":"Stream'.WSeq.head_some_of_head_tail_some","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nh : Membership.mem s.tail.head (Option.some a)\n⊢ Exists fun a' => Membership.mem s.head (Option.some a')","decl":"theorem head_some_of_head_tail_some {s : WSeq α} {a} (h : some a ∈ head (tail s)) :\n    ∃ a', some a' ∈ head s := by\n  unfold head at h\n  rcases Computation.exists_of_mem_map h with ⟨o, md, e⟩; clear h\n  cases' o with o <;> [injection e; injection e with h']; clear h'\n  cases' destruct_some_of_destruct_tail_some md with a am\n  exact ⟨_, Computation.mem_map (@Prod.fst α (WSeq α) <$> ·) am⟩\n\n"}
{"name":"Stream'.WSeq.head_some_of_get?_some","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nn : Nat\nh : Membership.mem (s.get? n) (Option.some a)\n⊢ Exists fun a' => Membership.mem s.head (Option.some a')","decl":"theorem head_some_of_get?_some {s : WSeq α} {a n} (h : some a ∈ get? s n) :\n    ∃ a', some a' ∈ head s := by\n  induction n generalizing a with\n  | zero => exact ⟨_, h⟩\n  | succ n IH =>\n      let ⟨a', h'⟩ := head_some_of_head_tail_some h\n      exact IH h'\n\n"}
{"name":"Stream'.WSeq.productive_tail","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\ninst✝ : s.Productive\n⊢ s.tail.Productive","decl":"instance productive_tail (s : WSeq α) [Productive s] : Productive (tail s) :=\n  ⟨fun n => by rw [get?_tail]; infer_instance⟩\n\n"}
{"name":"Stream'.WSeq.productive_dropn","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\ninst✝ : s.Productive\nn : Nat\n⊢ (s.drop n).Productive","decl":"instance productive_dropn (s : WSeq α) [Productive s] (n) : Productive (drop s n) :=\n  ⟨fun m => by rw [← get?_add]; infer_instance⟩\n\n"}
{"name":"Stream'.WSeq.get?_terminates_le","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nm n : Nat\nh : LE.le m n\na✝ : (s.get? n).Terminates\n⊢ (s.get? m).Terminates","decl":"theorem get?_terminates_le {s : WSeq α} {m n} (h : m ≤ n) :\n    Terminates (get? s n) → Terminates (get? s m) := by\n  induction' h with m' _ IH\n  exacts [id, fun T => IH (@head_terminates_of_head_tail_terminates _ _ T)]\n\n"}
{"name":"Stream'.WSeq.head_terminates_of_get?_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\na✝ : (s.get? n).Terminates\n⊢ s.head.Terminates","decl":"theorem head_terminates_of_get?_terminates {s : WSeq α} {n} :\n    Terminates (get? s n) → Terminates (head s) :=\n  get?_terminates_le (Nat.zero_le n)\n\n"}
{"name":"Stream'.WSeq.destruct_terminates_of_get?_terminates","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nn : Nat\nT : (s.get? n).Terminates\n⊢ s.destruct.Terminates","decl":"theorem destruct_terminates_of_get?_terminates {s : WSeq α} {n} (T : Terminates (get? s n)) :\n    Terminates (destruct s) :=\n  (head_terminates_iff _).1 <| head_terminates_of_get?_terminates T\n\n"}
{"name":"Stream'.WSeq.mem_rec_on","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nC : Stream'.WSeq α → Prop\na : α\ns : Stream'.WSeq α\nM : Membership.mem s a\nh1 : ∀ (b : α) (s' : Stream'.WSeq α), Or (Eq a b) (C s') → C (Stream'.WSeq.cons b s')\nh2 : ∀ (s : Stream'.WSeq α), C s → C s.think\n⊢ C s","decl":"theorem mem_rec_on {C : WSeq α → Prop} {a s} (M : a ∈ s) (h1 : ∀ b s', a = b ∨ C s' → C (cons b s'))\n    (h2 : ∀ s, C s → C (think s)) : C s := by\n  apply Seq.mem_rec_on M\n  intro o s' h; cases' o with b\n  · apply h2\n    cases h\n    · contradiction\n    · assumption\n  · apply h1\n    apply Or.imp_left _ h\n    intro h\n    injection h\n\n"}
{"name":"Stream'.WSeq.mem_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\n⊢ Iff (Membership.mem s.think a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_think (s : WSeq α) (a) : a ∈ think s ↔ a ∈ s := by\n  cases' s with f al\n  change (some (some a) ∈ some none::f) ↔ some (some a) ∈ f\n  constructor <;> intro h\n  · apply (Stream'.eq_or_mem_of_mem_cons h).resolve_left\n    intro\n    injections\n  · apply Stream'.mem_cons_of_mem _ h\n\n"}
{"name":"Stream'.WSeq.eq_or_mem_iff_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na a' : α\ns' : Stream'.WSeq α\na✝ : Membership.mem s.destruct (Option.some { fst := a', snd := s' })\n⊢ Iff (Membership.mem s a) (Or (Eq a a') (Membership.mem s' a))","decl":"theorem eq_or_mem_iff_mem {s : WSeq α} {a a' s'} :\n    some (a', s') ∈ destruct s → (a ∈ s ↔ a = a' ∨ a ∈ s') := by\n  generalize e : destruct s = c; intro h\n  revert s\n  apply Computation.memRecOn h <;> [skip; intro c IH] <;> intro s <;>\n    induction' s using WSeq.recOn with x s s <;>\n    intro m <;>\n    have := congr_arg Computation.destruct m <;>\n    simp at this\n  · cases' this with i1 i2\n    rw [i1, i2]\n    cases' s' with f al\n    dsimp only [cons, Membership.mem, WSeq.Mem, Seq.Mem, Seq.cons]\n    have h_a_eq_a' : a = a' ↔ some (some a) = some (some a') := by simp\n    rw [h_a_eq_a']\n    refine ⟨Stream'.eq_or_mem_of_mem_cons, fun o => ?_⟩\n    · cases' o with e m\n      · rw [e]\n        apply Stream'.mem_cons\n      · exact Stream'.mem_cons_of_mem _ m\n  · simp [IH this]\n\n"}
{"name":"Stream'.WSeq.mem_cons_iff","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nb a : α\n⊢ Iff (Membership.mem (Stream'.WSeq.cons b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_cons_iff (s : WSeq α) (b) {a} : a ∈ cons b s ↔ a = b ∨ a ∈ s :=\n  eq_or_mem_iff_mem <| by simp [ret_mem]\n\n"}
{"name":"Stream'.WSeq.mem_cons_of_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\nb a : α\nh : Membership.mem s a\n⊢ Membership.mem (Stream'.WSeq.cons b s) a","decl":"theorem mem_cons_of_mem {s : WSeq α} (b) {a} (h : a ∈ s) : a ∈ cons b s :=\n  (mem_cons_iff _ _).2 (Or.inr h)\n\n"}
{"name":"Stream'.WSeq.mem_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\n⊢ Membership.mem (Stream'.WSeq.cons a s) a","decl":"theorem mem_cons (s : WSeq α) (a) : a ∈ cons a s :=\n  (mem_cons_iff _ _).2 (Or.inl rfl)\n\n"}
{"name":"Stream'.WSeq.mem_of_mem_tail","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\na✝ : Membership.mem s.tail a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_tail {s : WSeq α} {a} : a ∈ tail s → a ∈ s := by\n  intro h; have := h; cases' h with n e; revert s; simp only [Stream'.get]\n  induction' n with n IH <;> intro s <;> induction' s using WSeq.recOn with x s s <;>\n    simp <;> intro m e <;>\n    injections\n  · exact Or.inr m\n  · exact Or.inr m\n  · apply IH m\n    rw [e]\n    cases tail s\n    rfl\n\n"}
{"name":"Stream'.WSeq.mem_of_mem_dropn","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nn : Nat\na✝ : Membership.mem (s.drop n) a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_dropn {s : WSeq α} {a} : ∀ {n}, a ∈ drop s n → a ∈ s\n  | 0, h => h\n  | n + 1, h => @mem_of_mem_dropn s a n (mem_of_mem_tail h)\n\n"}
{"name":"Stream'.WSeq.get?_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nn : Nat\na✝ : Membership.mem (s.get? n) (Option.some a)\n⊢ Membership.mem s a","decl":"theorem get?_mem {s : WSeq α} {a n} : some a ∈ get? s n → a ∈ s := by\n  revert s; induction' n with n IH <;> intro s h\n  · -- Porting note: This line is required to infer metavariables in\n    --               `Computation.exists_of_mem_map`.\n    dsimp only [get?, head] at h\n    rcases Computation.exists_of_mem_map h with ⟨o, h1, h2⟩\n    cases' o with o\n    · injection h2\n    injection h2 with h'\n    cases' o with a' s'\n    exact (eq_or_mem_iff_mem h1).2 (Or.inl h'.symm)\n  · have := @IH (tail s)\n    rw [get?_tail] at this\n    exact mem_of_mem_tail (this h)\n\n"}
{"name":"Stream'.WSeq.exists_get?_of_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nh : Membership.mem s a\n⊢ Exists fun n => Membership.mem (s.get? n) (Option.some a)","decl":"theorem exists_get?_of_mem {s : WSeq α} {a} (h : a ∈ s) : ∃ n, some a ∈ get? s n := by\n  apply mem_rec_on h\n  · intro a' s' h\n    cases' h with h h\n    · exists 0\n      simp only [get?, drop, head_cons]\n      rw [h]\n      apply ret_mem\n    · cases' h with n h\n      exists n + 1\n      simpa [get?]\n  · intro s' h\n    cases' h with n h\n    exists n\n    simp only [get?, dropn_think, head_think]\n    apply think_mem h\n\n"}
{"name":"Stream'.WSeq.exists_dropn_of_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nh : Membership.mem s a\n⊢ Exists fun n => Exists fun s' => Membership.mem (s.drop n).destruct (Option.some { fst := a, snd := s' })","decl":"theorem exists_dropn_of_mem {s : WSeq α} {a} (h : a ∈ s) :\n    ∃ n s', some (a, s') ∈ destruct (drop s n) :=\n  let ⟨n, h⟩ := exists_get?_of_mem h\n  ⟨n, by\n    rcases (head_terminates_iff _).1 ⟨⟨_, h⟩⟩ with ⟨⟨o, om⟩⟩\n    have := Computation.mem_unique (Computation.mem_map _ om) h\n    cases' o with o\n    · injection this\n    injection this with i\n    cases' o with a' s'\n    dsimp at i\n    rw [i] at om\n    exact ⟨_, om⟩⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_dropn_destruct","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\nH : Stream'.WSeq.LiftRel R s t\nn : Nat\n⊢ Computation.LiftRel (Stream'.WSeq.LiftRelO R (Stream'.WSeq.LiftRel R)) (s.drop n).destruct (t.drop n).destruct","decl":"theorem liftRel_dropn_destruct {R : α → β → Prop} {s t} (H : LiftRel R s t) :\n    ∀ n, Computation.LiftRel (LiftRelO R (LiftRel R)) (destruct (drop s n)) (destruct (drop t n))\n  | 0 => liftRel_destruct H\n  | n + 1 => by\n    simp only [LiftRelO, drop, Nat.add_eq, Nat.add_zero, destruct_tail, tail.aux]\n    apply liftRel_bind\n    · apply liftRel_dropn_destruct H n\n    exact fun {a b} o =>\n      match a, b, o with\n      | none, none, _ => by\n        -- Porting note: These 2 theorems should be excluded.\n        simp [-liftRel_pure_left, -liftRel_pure_right]\n      | some (a, s), some (b, t), ⟨_, h2⟩ => by simpa [tail.aux] using liftRel_destruct h2\n\n"}
{"name":"Stream'.WSeq.exists_of_liftRel_left","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\nH : Stream'.WSeq.LiftRel R s t\na : α\nh : Membership.mem s a\n⊢ Exists fun b => And (Membership.mem t b) (R a b)","decl":"theorem exists_of_liftRel_left {R : α → β → Prop} {s t} (H : LiftRel R s t) {a} (h : a ∈ s) :\n    ∃ b, b ∈ t ∧ R a b := by\n  let ⟨n, h⟩ := exists_get?_of_mem h\n  -- Porting note: This line is required to infer metavariables in\n  --               `Computation.exists_of_mem_map`.\n  dsimp only [get?, head] at h\n  let ⟨some (_, s'), sd, rfl⟩ := Computation.exists_of_mem_map h\n  let ⟨some (b, t'), td, ⟨ab, _⟩⟩ := (liftRel_dropn_destruct H n).left sd\n  exact ⟨b, get?_mem (Computation.mem_map (Prod.fst.{v, v} <$> ·) td), ab⟩\n\n"}
{"name":"Stream'.WSeq.exists_of_liftRel_right","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\nH : Stream'.WSeq.LiftRel R s t\nb : β\nh : Membership.mem t b\n⊢ Exists fun a => And (Membership.mem s a) (R a b)","decl":"theorem exists_of_liftRel_right {R : α → β → Prop} {s t} (H : LiftRel R s t) {b} (h : b ∈ t) :\n    ∃ a, a ∈ s ∧ R a b := by rw [← LiftRel.swap] at H; exact exists_of_liftRel_left H h\n\n"}
{"name":"Stream'.WSeq.head_terminates_of_mem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\na : α\nh : Membership.mem s a\n⊢ s.head.Terminates","decl":"theorem head_terminates_of_mem {s : WSeq α} {a} (h : a ∈ s) : Terminates (head s) :=\n  let ⟨_, h⟩ := exists_get?_of_mem h\n  head_terminates_of_get?_terminates ⟨⟨_, h⟩⟩\n\n"}
{"name":"Stream'.WSeq.of_mem_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns₁ s₂ : Stream'.WSeq α\na : α\na✝ : Membership.mem (s₁.append s₂) a\n⊢ Or (Membership.mem s₁ a) (Membership.mem s₂ a)","decl":"theorem of_mem_append {s₁ s₂ : WSeq α} {a : α} : a ∈ append s₁ s₂ → a ∈ s₁ ∨ a ∈ s₂ :=\n  Seq.of_mem_append\n\n"}
{"name":"Stream'.WSeq.mem_append_left","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns₁ s₂ : Stream'.WSeq α\na : α\na✝ : Membership.mem s₁ a\n⊢ Membership.mem (s₁.append s₂) a","decl":"theorem mem_append_left {s₁ s₂ : WSeq α} {a : α} : a ∈ s₁ → a ∈ append s₁ s₂ :=\n  Seq.mem_append_left\n\n"}
{"name":"Stream'.WSeq.exists_of_mem_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nb : β\ns : Stream'.WSeq α\na✝ : Membership.mem (Stream'.WSeq.map f s) b\n⊢ Exists fun a => And (Membership.mem s a) (Eq (f a) b)","decl":"theorem exists_of_mem_map {f} {b : β} : ∀ {s : WSeq α}, b ∈ map f s → ∃ a, a ∈ s ∧ f a = b\n  | ⟨g, al⟩, h => by\n    let ⟨o, om, oe⟩ := Seq.exists_of_mem_map h\n    cases' o with a\n    · injection oe\n    injection oe with h'\n    exact ⟨a, om, h'⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\n⊢ Stream'.WSeq.LiftRel R Stream'.WSeq.nil Stream'.WSeq.nil","decl":"@[simp]\ntheorem liftRel_nil (R : α → β → Prop) : LiftRel R nil nil := by\n  rw [liftRel_destruct_iff]\n  -- Porting note: These 2 theorems should be excluded.\n  simp [-liftRel_pure_left, -liftRel_pure_right]\n\n"}
{"name":"Stream'.WSeq.liftRel_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\na : α\nb : β\ns : Stream'.WSeq α\nt : Stream'.WSeq β\n⊢ Iff (Stream'.WSeq.LiftRel R (Stream'.WSeq.cons a s) (Stream'.WSeq.cons b t)) (And (R a b) (Stream'.WSeq.LiftRel R s t))","decl":"@[simp]\ntheorem liftRel_cons (R : α → β → Prop) (a b s t) :\n    LiftRel R (cons a s) (cons b t) ↔ R a b ∧ LiftRel R s t := by\n  rw [liftRel_destruct_iff]\n  -- Porting note: These 2 theorems should be excluded.\n  simp [-liftRel_pure_left, -liftRel_pure_right]\n\n"}
{"name":"Stream'.WSeq.liftRel_think_left","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\n⊢ Iff (Stream'.WSeq.LiftRel R s.think t) (Stream'.WSeq.LiftRel R s t)","decl":"@[simp]\ntheorem liftRel_think_left (R : α → β → Prop) (s t) : LiftRel R (think s) t ↔ LiftRel R s t := by\n  rw [liftRel_destruct_iff, liftRel_destruct_iff]; simp\n\n"}
{"name":"Stream'.WSeq.liftRel_think_right","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns : Stream'.WSeq α\nt : Stream'.WSeq β\n⊢ Iff (Stream'.WSeq.LiftRel R s t.think) (Stream'.WSeq.LiftRel R s t)","decl":"@[simp]\ntheorem liftRel_think_right (R : α → β → Prop) (s t) : LiftRel R s (think t) ↔ LiftRel R s t := by\n  rw [liftRel_destruct_iff, liftRel_destruct_iff]; simp\n\n"}
{"name":"Stream'.WSeq.cons_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\na : α\nh : s.Equiv t\n⊢ (Stream'.WSeq.cons a s).Equiv (Stream'.WSeq.cons a t)","decl":"theorem cons_congr {s t : WSeq α} (a : α) (h : s ~ʷ t) : cons a s ~ʷ cons a t := by\n  unfold Equiv; simpa using h\n\n"}
{"name":"Stream'.WSeq.think_equiv","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ s.think.Equiv s","decl":"theorem think_equiv (s : WSeq α) : think s ~ʷ s := by unfold Equiv; simpa using Equiv.refl _\n\n"}
{"name":"Stream'.WSeq.think_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\n⊢ s.think.Equiv t.think","decl":"theorem think_congr {s t : WSeq α} (h : s ~ʷ t) : think s ~ʷ think t := by\n  unfold Equiv; simpa using h\n\n"}
{"name":"Stream'.WSeq.head_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\na✝ : s.Equiv t\n⊢ s.head.Equiv t.head","decl":"theorem head_congr : ∀ {s t : WSeq α}, s ~ʷ t → head s ~ head t := by\n  suffices ∀ {s t : WSeq α}, s ~ʷ t → ∀ {o}, o ∈ head s → o ∈ head t from fun s t h o =>\n    ⟨this h, this h.symm⟩\n  intro s t h o ho\n  rcases @Computation.exists_of_mem_map _ _ _ _ (destruct s) ho with ⟨ds, dsm, dse⟩\n  rw [← dse]\n  cases' destruct_congr h with l r\n  rcases l dsm with ⟨dt, dtm, dst⟩\n  cases' ds with a <;> cases' dt with b\n  · apply Computation.mem_map _ dtm\n  · cases b\n    cases dst\n  · cases a\n    cases dst\n  · cases' a with a s'\n    cases' b with b t'\n    rw [dst.left]\n    exact @Computation.mem_map _ _ (@Functor.map _ _ (α × WSeq α) _ Prod.fst)\n      (some (b, t')) (destruct t) dtm\n\n"}
{"name":"Stream'.WSeq.flatten_equiv","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nc : Computation (Stream'.WSeq α)\ns : Stream'.WSeq α\nh : Membership.mem c s\n⊢ (Stream'.WSeq.flatten c).Equiv s","decl":"theorem flatten_equiv {c : Computation (WSeq α)} {s} (h : s ∈ c) : flatten c ~ʷ s := by\n  apply Computation.memRecOn h\n  · simp [Equiv.refl]\n  · intro s'\n    apply Equiv.trans\n    simp [think_equiv]\n\n"}
{"name":"Stream'.WSeq.liftRel_flatten","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nc1 : Computation (Stream'.WSeq α)\nc2 : Computation (Stream'.WSeq β)\nh : Computation.LiftRel (Stream'.WSeq.LiftRel R) c1 c2\n⊢ Stream'.WSeq.LiftRel R (Stream'.WSeq.flatten c1) (Stream'.WSeq.flatten c2)","decl":"theorem liftRel_flatten {R : α → β → Prop} {c1 : Computation (WSeq α)} {c2 : Computation (WSeq β)}\n    (h : c1.LiftRel (LiftRel R) c2) : LiftRel R (flatten c1) (flatten c2) :=\n  let S s t := ∃ c1 c2, s = flatten c1 ∧ t = flatten c2 ∧ Computation.LiftRel (LiftRel R) c1 c2\n  ⟨S, ⟨c1, c2, rfl, rfl, h⟩, fun {s t} h =>\n    match s, t, h with\n    | _, _, ⟨c1, c2, rfl, rfl, h⟩ => by\n      simp only [destruct_flatten]; apply liftRel_bind _ _ h\n      intro a b ab; apply Computation.LiftRel.imp _ _ _ (liftRel_destruct ab)\n      intro a b; apply LiftRelO.imp_right\n      intro s t h; refine ⟨Computation.pure s, Computation.pure t, ?_, ?_, ?_⟩ <;>\n        -- Porting note: These 2 theorems should be excluded.\n        simp [h, -liftRel_pure_left, -liftRel_pure_right]⟩\n\n"}
{"name":"Stream'.WSeq.flatten_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nc1 c2 : Computation (Stream'.WSeq α)\na✝ : Computation.LiftRel Stream'.WSeq.Equiv c1 c2\n⊢ (Stream'.WSeq.flatten c1).Equiv (Stream'.WSeq.flatten c2)","decl":"theorem flatten_congr {c1 c2 : Computation (WSeq α)} :\n    Computation.LiftRel Equiv c1 c2 → flatten c1 ~ʷ flatten c2 :=\n  liftRel_flatten\n\n"}
{"name":"Stream'.WSeq.tail_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\n⊢ s.tail.Equiv t.tail","decl":"theorem tail_congr {s t : WSeq α} (h : s ~ʷ t) : tail s ~ʷ tail t := by\n  apply flatten_congr\n  dsimp only [(· <$> ·)]; rw [← Computation.bind_pure, ← Computation.bind_pure]\n  apply liftRel_bind _ _ (destruct_congr h)\n  intro a b h; simp only [comp_apply, liftRel_pure]\n  cases' a with a <;> cases' b with b\n  · trivial\n  · cases h\n  · cases a\n    cases h\n  · cases' a with a s'\n    cases' b with b t'\n    exact h.right\n\n"}
{"name":"Stream'.WSeq.dropn_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\nn : Nat\n⊢ (s.drop n).Equiv (t.drop n)","decl":"theorem dropn_congr {s t : WSeq α} (h : s ~ʷ t) (n) : drop s n ~ʷ drop t n := by\n  induction n <;> simp [*, tail_congr, drop]\n\n"}
{"name":"Stream'.WSeq.get?_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\nn : Nat\n⊢ (s.get? n).Equiv (t.get? n)","decl":"theorem get?_congr {s t : WSeq α} (h : s ~ʷ t) (n) : get? s n ~ get? t n :=\n  head_congr (dropn_congr h _)\n\n"}
{"name":"Stream'.WSeq.mem_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\na : α\n⊢ Iff (Membership.mem s a) (Membership.mem t a)","decl":"theorem mem_congr {s t : WSeq α} (h : s ~ʷ t) (a) : a ∈ s ↔ a ∈ t :=\n  suffices ∀ {s t : WSeq α}, s ~ʷ t → a ∈ s → a ∈ t from ⟨this h, this h.symm⟩\n  fun {_ _} h as =>\n  let ⟨_, hn⟩ := exists_get?_of_mem as\n  get?_mem ((get?_congr h _ _).1 hn)\n\n"}
{"name":"Stream'.WSeq.productive_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : s.Equiv t\n⊢ Iff s.Productive t.Productive","decl":"theorem productive_congr {s t : WSeq α} (h : s ~ʷ t) : Productive s ↔ Productive t := by\n  simp only [productive_iff]; exact forall_congr' fun n => terminates_congr <| get?_congr h _\n\n"}
{"name":"Stream'.WSeq.Equiv.ext","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\nh : ∀ (n : Nat), (s.get? n).Equiv (t.get? n)\n⊢ s.Equiv t","decl":"theorem Equiv.ext {s t : WSeq α} (h : ∀ n, get? s n ~ get? t n) : s ~ʷ t :=\n  ⟨fun s t => ∀ n, get? s n ~ get? t n, h, fun {s t} h => by\n    refine liftRel_def.2 ⟨?_, ?_⟩\n    · rw [← head_terminates_iff, ← head_terminates_iff]\n      exact terminates_congr (h 0)\n    · intro a b ma mb\n      cases' a with a <;> cases' b with b\n      · trivial\n      · injection mem_unique (Computation.mem_map _ ma) ((h 0 _).2 (Computation.mem_map _ mb))\n      · injection mem_unique (Computation.mem_map _ ma) ((h 0 _).2 (Computation.mem_map _ mb))\n      · cases' a with a s'\n        cases' b with b t'\n        injection mem_unique (Computation.mem_map _ ma) ((h 0 _).2 (Computation.mem_map _ mb)) with\n          ab\n        refine ⟨ab, fun n => ?_⟩\n        refine\n          (get?_congr (flatten_equiv (Computation.mem_map _ ma)) n).symm.trans\n            ((?_ : get? (tail s) n ~ get? (tail t) n).trans\n              (get?_congr (flatten_equiv (Computation.mem_map _ mb)) n))\n        rw [get?_tail, get?_tail]\n        apply h⟩\n\n"}
{"name":"Stream'.WSeq.length_eq_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq s.length (Computation.map List.length s.toList)","decl":"theorem length_eq_map (s : WSeq α) : length s = Computation.map List.length (toList s) := by\n  refine\n    Computation.eq_of_bisim\n      (fun c1 c2 =>\n        ∃ (l : List α) (s : WSeq α),\n          c1 = Computation.corec (fun ⟨n, s⟩ =>\n            match Seq.destruct s with\n            | none => Sum.inl n\n            | some (none, s') => Sum.inr (n, s')\n            | some (some _, s') => Sum.inr (n + 1, s')) (l.length, s) ∧\n            c2 = Computation.map List.length (Computation.corec (fun ⟨l, s⟩ =>\n              match Seq.destruct s with\n              | none => Sum.inl l.reverse\n              | some (none, s') => Sum.inr (l, s')\n              | some (some a, s') => Sum.inr (a::l, s')) (l, s)))\n      ?_ ⟨[], s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨l, s, h⟩; rw [h.left, h.right]\n  induction' s using WSeq.recOn with a s s <;> simp [toList, nil, cons, think, length]\n  · refine ⟨a::l, s, ?_, ?_⟩ <;> simp\n  · refine ⟨l, s, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.WSeq.ofList_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq (↑List.nil) Stream'.WSeq.nil","decl":"@[simp]\ntheorem ofList_nil : ofList [] = (nil : WSeq α) :=\n  rfl\n\n"}
{"name":"Stream'.WSeq.ofList_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\nl : List α\n⊢ Eq (↑(List.cons a l)) (Stream'.WSeq.cons a ↑l)","decl":"@[simp]\ntheorem ofList_cons (a : α) (l) : ofList (a::l) = cons a (ofList l) :=\n  show Seq.map some (Seq.ofList (a::l)) = Seq.cons (some a) (Seq.map some (Seq.ofList l)) by simp\n\n"}
{"name":"Stream'.WSeq.toList'_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nl : List α\n⊢ Eq (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := l, snd := Stream'.WSeq.nil }) (Computation.pure l.reverse)","decl":"@[simp]\ntheorem toList'_nil (l : List α) :\n    Computation.corec (fun ⟨l, s⟩ =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, nil) = Computation.pure l.reverse :=\n  destruct_eq_pure rfl\n\n"}
{"name":"Stream'.WSeq.toList'_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nl : List α\ns : Stream'.WSeq α\na : α\n⊢ Eq (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := l, snd := Stream'.WSeq.cons a s }) (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := List.cons a l, snd := s }).think","decl":"@[simp]\ntheorem toList'_cons (l : List α) (s : WSeq α) (a : α) :\n    Computation.corec (fun ⟨l, s⟩ =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, cons a s) =\n      (Computation.corec (fun ⟨l, s⟩ =>\n        match Seq.destruct s with\n        | none => Sum.inl l.reverse\n        | some (none, s') => Sum.inr (l, s')\n        | some (some a, s') => Sum.inr (a::l, s')) (a::l, s)).think :=\n  destruct_eq_think <| by simp [toList, cons]\n\n"}
{"name":"Stream'.WSeq.toList'_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nl : List α\ns : Stream'.WSeq α\n⊢ Eq (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := l, snd := s.think }) (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := l, snd := s }).think","decl":"@[simp]\ntheorem toList'_think (l : List α) (s : WSeq α) :\n    Computation.corec (fun ⟨l, s⟩ =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a::l, s')) (l, think s) =\n      (Computation.corec (fun ⟨l, s⟩ =>\n        match Seq.destruct s with\n        | none => Sum.inl l.reverse\n        | some (none, s') => Sum.inr (l, s')\n        | some (some a, s') => Sum.inr (a::l, s')) (l, s)).think :=\n  destruct_eq_think <| by simp [toList, think]\n\n"}
{"name":"Stream'.WSeq.toList'_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nl : List α\ns : Stream'.WSeq α\n⊢ Eq (Computation.corec (fun x => Stream'.WSeq.toList.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) x fun l s => Stream'.WSeq.destruct.match_1 (fun x => Sum (List α) (Prod (List α) (Stream'.WSeq α))) (Stream'.Seq.destruct s) (fun _ => Sum.inl l.reverse) (fun s' => Sum.inr { fst := l, snd := s' }) fun a s' => Sum.inr { fst := List.cons a l, snd := s' }) { fst := l, snd := s }) (Functor.map (fun x => HAppend.hAppend l.reverse x) s.toList)","decl":"theorem toList'_map (l : List α) (s : WSeq α) :\n    Computation.corec (fun ⟨l, s⟩ =>\n      match Seq.destruct s with\n      | none => Sum.inl l.reverse\n      | some (none, s') => Sum.inr (l, s')\n      | some (some a, s') => Sum.inr (a :: l, s')) (l, s) = (l.reverse ++ ·) <$> toList s := by\n  refine\n    Computation.eq_of_bisim\n      (fun c1 c2 =>\n        ∃ (l' : List α) (s : WSeq α),\n          c1 = Computation.corec (fun ⟨l, s⟩ =>\n            match Seq.destruct s with\n            | none => Sum.inl l.reverse\n            | some (none, s') => Sum.inr (l, s')\n            | some (some a, s') => Sum.inr (a::l, s')) (l' ++ l, s) ∧\n            c2 = Computation.map (l.reverse ++ ·) (Computation.corec (fun ⟨l, s⟩ =>\n              match Seq.destruct s with\n              | none => Sum.inl l.reverse\n              | some (none, s') => Sum.inr (l, s')\n              | some (some a, s') => Sum.inr (a::l, s')) (l', s)))\n      ?_ ⟨[], s, rfl, rfl⟩\n  intro s1 s2 h; rcases h with ⟨l', s, h⟩; rw [h.left, h.right]\n  induction' s using WSeq.recOn with a s s <;> simp [toList, nil, cons, think, length]\n  · refine ⟨a::l', s, ?_, ?_⟩ <;> simp\n  · refine ⟨l', s, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.WSeq.toList_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.cons a s).toList (Functor.map (List.cons a) s.toList).think","decl":"@[simp]\ntheorem toList_cons (a : α) (s) : toList (cons a s) = (List.cons a <$> toList s).think :=\n  destruct_eq_think <| by\n    unfold toList\n    simp only [toList'_cons, Computation.destruct_think, Sum.inr.injEq]\n    rw [toList'_map]\n    simp only [List.reverse_cons, List.reverse_nil, List.nil_append, List.singleton_append]\n    rfl\n\n"}
{"name":"Stream'.WSeq.toList_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\n⊢ Eq Stream'.WSeq.nil.toList (Computation.pure List.nil)","decl":"@[simp]\ntheorem toList_nil : toList (nil : WSeq α) = Computation.pure [] :=\n  destruct_eq_pure rfl\n\n"}
{"name":"Stream'.WSeq.toList_ofList","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nl : List α\n⊢ Membership.mem (↑l).toList l","decl":"theorem toList_ofList (l : List α) : l ∈ toList (ofList l) := by\n  induction' l with a l IH\n  · simp [ret_mem]\n  · simpa [ret_mem] using think_mem (Computation.mem_map _ IH)\n\n"}
{"name":"Stream'.WSeq.destruct_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (↑s).destruct (Computation.pure (Option.map (fun a => { fst := a, snd := ↑s.tail }) s.head))","decl":"@[simp]\ntheorem destruct_ofSeq (s : Seq α) :\n    destruct (ofSeq s) = Computation.pure (s.head.map fun a => (a, ofSeq s.tail)) :=\n  destruct_eq_pure <| by\n    simp only [destruct, Seq.destruct, Option.map_eq_map, ofSeq, Computation.corec_eq, rmap,\n      Seq.head]\n    rw [show Seq.get? (some <$> s) 0 = some <$> Seq.get? s 0 by apply Seq.map_get?]\n    cases' Seq.get? s 0 with a\n    · rfl\n    dsimp only [(· <$> ·)]\n    simp [destruct]\n\n"}
{"name":"Stream'.WSeq.head_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (↑s).head (Computation.pure s.head)","decl":"@[simp]\ntheorem head_ofSeq (s : Seq α) : head (ofSeq s) = Computation.pure s.head := by\n  simp only [head, Option.map_eq_map, destruct_ofSeq, Computation.map_pure, Option.map_map]\n  cases Seq.head s <;> rfl\n\n"}
{"name":"Stream'.WSeq.tail_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (↑s).tail ↑s.tail","decl":"@[simp]\ntheorem tail_ofSeq (s : Seq α) : tail (ofSeq s) = ofSeq s.tail := by\n  simp only [tail, destruct_ofSeq, map_pure', flatten_pure]\n  induction' s using Seq.recOn with x s <;> simp only [ofSeq, Seq.tail_nil, Seq.head_nil,\n    Option.map_none', Seq.tail_cons, Seq.head_cons, Option.map_some']\n  · rfl\n\n"}
{"name":"Stream'.WSeq.dropn_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq ((↑s).drop n) ↑(s.drop n)","decl":"@[simp]\ntheorem dropn_ofSeq (s : Seq α) : ∀ n, drop (ofSeq s) n = ofSeq (s.drop n)\n  | 0 => rfl\n  | n + 1 => by\n    simp only [drop, Nat.add_eq, Nat.add_zero, Seq.drop]\n    rw [dropn_ofSeq s n, tail_ofSeq]\n\n"}
{"name":"Stream'.WSeq.get?_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\nn : Nat\n⊢ Eq ((↑s).get? n) (Computation.pure (s.get? n))","decl":"theorem get?_ofSeq (s : Seq α) (n) : get? (ofSeq s) n = Computation.pure (Seq.get? s n) := by\n  dsimp [get?]; rw [dropn_ofSeq, head_ofSeq, Seq.head_dropn]\n\n"}
{"name":"Stream'.WSeq.productive_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ (↑s).Productive","decl":"instance productive_ofSeq (s : Seq α) : Productive (ofSeq s) :=\n  ⟨fun n => by rw [get?_ofSeq]; infer_instance⟩\n\n"}
{"name":"Stream'.WSeq.toSeq_ofSeq","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.Seq α\n⊢ Eq (↑s).toSeq s","decl":"theorem toSeq_ofSeq (s : Seq α) : toSeq (ofSeq s) = s := by\n  apply Subtype.eq; funext n\n  dsimp [toSeq]; apply get_eq_of_mem\n  rw [get?_ofSeq]; apply ret_mem\n\n"}
{"name":"Stream'.WSeq.map_nil","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\n⊢ Eq (Stream'.WSeq.map f Stream'.WSeq.nil) Stream'.WSeq.nil","decl":"@[simp]\ntheorem map_nil (f : α → β) : map f nil = nil :=\n  rfl\n\n"}
{"name":"Stream'.WSeq.map_cons","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map f (Stream'.WSeq.cons a s)) (Stream'.WSeq.cons (f a) (Stream'.WSeq.map f s))","decl":"@[simp]\ntheorem map_cons (f : α → β) (a s) : map f (cons a s) = cons (f a) (map f s) :=\n  Seq.map_cons _ _ _\n\n"}
{"name":"Stream'.WSeq.map_think","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map f s.think) (Stream'.WSeq.map f s).think","decl":"@[simp]\ntheorem map_think (f : α → β) (s) : map f (think s) = think (map f s) :=\n  Seq.map_cons _ _ _\n\n"}
{"name":"Stream'.WSeq.map_id","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map id s) s","decl":"@[simp]\ntheorem map_id (s : WSeq α) : map id s = s := by simp [map]\n\n"}
{"name":"Stream'.WSeq.map_ret","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\n⊢ Eq (Stream'.WSeq.map f (Stream'.WSeq.ret a)) (Stream'.WSeq.ret (f a))","decl":"@[simp]\ntheorem map_ret (f : α → β) (a) : map f (ret a) = ret (f a) := by simp [ret]\n\n"}
{"name":"Stream'.WSeq.map_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map f (s.append t)) ((Stream'.WSeq.map f s).append (Stream'.WSeq.map f t))","decl":"@[simp]\ntheorem map_append (f : α → β) (s t) : map f (append s t) = append (map f s) (map f t) :=\n  Seq.map_append _ _ _\n\n"}
{"name":"Stream'.WSeq.map_comp","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nf : α → β\ng : β → γ\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map (Function.comp g f) s) (Stream'.WSeq.map g (Stream'.WSeq.map f s))","decl":"theorem map_comp (f : α → β) (g : β → γ) (s : WSeq α) : map (g ∘ f) s = map g (map f s) := by\n  dsimp [map]; rw [← Seq.map_comp]\n  apply congr_fun; apply congr_arg\n  ext ⟨⟩ <;> rfl\n\n"}
{"name":"Stream'.WSeq.mem_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\na : α\ns : Stream'.WSeq α\na✝ : Membership.mem s a\n⊢ Membership.mem (Stream'.WSeq.map f s) (f a)","decl":"theorem mem_map (f : α → β) {a : α} {s : WSeq α} : a ∈ s → f a ∈ map f s :=\n  Seq.mem_map (Option.map f)\n\n-- The converse is not true without additional assumptions\n"}
{"name":"Stream'.WSeq.exists_of_mem_join","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\na : α\nS : Stream'.WSeq (Stream'.WSeq α)\na✝ : Membership.mem S.join a\n⊢ Exists fun s => And (Membership.mem S s) (Membership.mem s a)","decl":"theorem exists_of_mem_join {a : α} : ∀ {S : WSeq (WSeq α)}, a ∈ join S → ∃ s, s ∈ S ∧ a ∈ s := by\n  suffices\n    ∀ ss : WSeq α,\n      a ∈ ss → ∀ s S, append s (join S) = ss → a ∈ append s (join S) → a ∈ s ∨ ∃ s, s ∈ S ∧ a ∈ s\n    from fun S h => (this _ h nil S (by simp) (by simp [h])).resolve_left (not_mem_nil _)\n  intro ss h; apply mem_rec_on h <;> [intro b ss o; intro ss IH] <;> intro s S\n  · induction' s using WSeq.recOn with b' s s <;>\n      [induction' S using WSeq.recOn with s S S; skip; skip] <;>\n      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;>\n      simp at this; cases this\n    substs b' ss\n    simp? at m ⊢ says simp only [cons_append, mem_cons_iff] at m ⊢\n    cases' o with e IH\n    · simp [e]\n    cases' m with e m\n    · simp [e]\n    exact Or.imp_left Or.inr (IH _ _ rfl m)\n  · induction' s using WSeq.recOn with b' s s <;>\n      [induction' S using WSeq.recOn with s S S; skip; skip] <;>\n      intro ej m <;> simp at ej <;> have := congr_arg Seq.destruct ej <;> simp at this <;>\n      subst ss\n    · apply Or.inr\n      -- Porting note: `exists_eq_or_imp` should be excluded.\n      simp [-exists_eq_or_imp] at m ⊢\n      cases' IH s S rfl m with as ex\n      · exact ⟨s, Or.inl rfl, as⟩\n      · rcases ex with ⟨s', sS, as⟩\n        exact ⟨s', Or.inr sS, as⟩\n    · apply Or.inr\n      simp? at m says simp only [join_think, nil_append, mem_think] at m\n      rcases (IH nil S (by simp) (by simp [m])).resolve_left (not_mem_nil _) with ⟨s, sS, as⟩\n      exact ⟨s, by simp [sS], as⟩\n    · simp only [think_append, mem_think] at m IH ⊢\n      apply IH _ _ rfl m\n\n"}
{"name":"Stream'.WSeq.exists_of_mem_bind","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\ns : Stream'.WSeq α\nf : α → Stream'.WSeq β\nb : β\nh : Membership.mem (s.bind f) b\n⊢ Exists fun a => And (Membership.mem s a) (Membership.mem (f a) b)","decl":"theorem exists_of_mem_bind {s : WSeq α} {f : α → WSeq β} {b} (h : b ∈ bind s f) :\n    ∃ a ∈ s, b ∈ f a :=\n  let ⟨t, tm, bt⟩ := exists_of_mem_join h\n  let ⟨a, as, e⟩ := exists_of_mem_map tm\n  ⟨a, as, by rwa [e]⟩\n\n"}
{"name":"Stream'.WSeq.destruct_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.WSeq α\n⊢ Eq (Stream'.WSeq.map f s).destruct (Computation.map (Option.map (Prod.map f (Stream'.WSeq.map f))) s.destruct)","decl":"theorem destruct_map (f : α → β) (s : WSeq α) :\n    destruct (map f s) = Computation.map (Option.map (Prod.map f (map f))) (destruct s) := by\n  apply\n    Computation.eq_of_bisim fun c1 c2 =>\n      ∃ s,\n        c1 = destruct (map f s) ∧\n          c2 = Computation.map (Option.map (Prod.map f (map f))) (destruct s)\n  · intro c1 c2 h\n    cases' h with s h\n    rw [h.left, h.right]\n    induction' s using WSeq.recOn with a s s <;> simp\n    exact ⟨s, rfl, rfl⟩\n  · exact ⟨s, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_map","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nR : α → β → Prop\nS : γ → δ → Prop\ns1 : Stream'.WSeq α\ns2 : Stream'.WSeq β\nf1 : α → γ\nf2 : β → δ\nh1 : Stream'.WSeq.LiftRel R s1 s2\nh2 : ∀ {a : α} {b : β}, R a b → S (f1 a) (f2 b)\n⊢ Stream'.WSeq.LiftRel S (Stream'.WSeq.map f1 s1) (Stream'.WSeq.map f2 s2)","decl":"theorem liftRel_map {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : WSeq α} {s2 : WSeq β}\n    {f1 : α → γ} {f2 : β → δ} (h1 : LiftRel R s1 s2) (h2 : ∀ {a b}, R a b → S (f1 a) (f2 b)) :\n    LiftRel S (map f1 s1) (map f2 s2) :=\n  ⟨fun s1 s2 => ∃ s t, s1 = map f1 s ∧ s2 = map f2 t ∧ LiftRel R s t, ⟨s1, s2, rfl, rfl, h1⟩,\n    fun {s1 s2} h =>\n    match s1, s2, h with\n    | _, _, ⟨s, t, rfl, rfl, h⟩ => by\n      simp only [exists_and_left, destruct_map]\n      apply Computation.liftRel_map _ _ (liftRel_destruct h)\n      intro o p h\n      cases' o with a <;> cases' p with b <;> simp\n      · cases b; cases h\n      · cases a; cases h\n      · cases' a with a s; cases' b with b t\n        cases' h with r h\n        exact ⟨h2 r, s, rfl, t, rfl, h⟩⟩\n\n"}
{"name":"Stream'.WSeq.map_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns t : Stream'.WSeq α\nh : s.Equiv t\n⊢ (Stream'.WSeq.map f s).Equiv (Stream'.WSeq.map f t)","decl":"theorem map_congr (f : α → β) {s t : WSeq α} (h : s ~ʷ t) : map f s ~ʷ map f t :=\n  liftRel_map _ _ h fun {_ _} => congr_arg _\n\n"}
{"name":"Stream'.WSeq.destruct_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns t : Stream'.WSeq α\n⊢ Eq (s.append t).destruct (s.destruct.bind (Stream'.WSeq.destruct_append.aux t))","decl":"theorem destruct_append (s t : WSeq α) :\n    destruct (append s t) = (destruct s).bind (destruct_append.aux t) := by\n  apply\n    Computation.eq_of_bisim\n      (fun c1 c2 =>\n        ∃ s t, c1 = destruct (append s t) ∧ c2 = (destruct s).bind (destruct_append.aux t))\n      _ ⟨s, t, rfl, rfl⟩\n  intro c1 c2 h; rcases h with ⟨s, t, h⟩; rw [h.left, h.right]\n  induction' s using WSeq.recOn with a s s <;> simp\n  · induction' t using WSeq.recOn with b t t <;> simp\n    · refine ⟨nil, t, ?_, ?_⟩ <;> simp\n  · exact ⟨s, t, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.destruct_join","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nS : Stream'.WSeq (Stream'.WSeq α)\n⊢ Eq S.join.destruct (S.destruct.bind Stream'.WSeq.destruct_join.aux)","decl":"theorem destruct_join (S : WSeq (WSeq α)) :\n    destruct (join S) = (destruct S).bind destruct_join.aux := by\n  apply\n    Computation.eq_of_bisim\n      (fun c1 c2 =>\n        c1 = c2 ∨ ∃ S, c1 = destruct (join S) ∧ c2 = (destruct S).bind destruct_join.aux)\n      _ (Or.inr ⟨S, rfl, rfl⟩)\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | c, _, Or.inl <| rfl => by cases c.destruct <;> simp\n    | _, _, Or.inr ⟨S, rfl, rfl⟩ => by\n      induction' S using WSeq.recOn with s S S <;> simp\n      · refine Or.inr ⟨S, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\ns1 s2 : Stream'.WSeq α\nt1 t2 : Stream'.WSeq β\nh1 : Stream'.WSeq.LiftRel R s1 t1\nh2 : Stream'.WSeq.LiftRel R s2 t2\n⊢ Stream'.WSeq.LiftRel R (s1.append s2) (t1.append t2)","decl":"theorem liftRel_append (R : α → β → Prop) {s1 s2 : WSeq α} {t1 t2 : WSeq β} (h1 : LiftRel R s1 t1)\n    (h2 : LiftRel R s2 t2) : LiftRel R (append s1 s2) (append t1 t2) :=\n  ⟨fun s t => LiftRel R s t ∨ ∃ s1 t1, s = append s1 s2 ∧ t = append t1 t2 ∧ LiftRel R s1 t1,\n    Or.inr ⟨s1, t1, rfl, rfl, h1⟩, fun {s t} h =>\n    match s, t, h with\n    | s, t, Or.inl h => by\n      apply Computation.LiftRel.imp _ _ _ (liftRel_destruct h)\n      intro a b; apply LiftRelO.imp_right\n      intro s t; apply Or.inl\n    | _, _, Or.inr ⟨s1, t1, rfl, rfl, h⟩ => by\n      simp only [LiftRelO, exists_and_left, destruct_append, destruct_append.aux]\n      apply Computation.liftRel_bind _ _ (liftRel_destruct h)\n      intro o p h\n      cases' o with a <;> cases' p with b\n      · simp only [destruct_append.aux]\n        apply Computation.LiftRel.imp _ _ _ (liftRel_destruct h2)\n        intro a b\n        apply LiftRelO.imp_right\n        intro s t\n        apply Or.inl\n      · cases b; cases h\n      · cases a; cases h\n      · cases' a with a s; cases' b with b t\n        cases' h with r h\n        -- Porting note: These 2 theorems should be excluded.\n        simpa [-liftRel_pure_left, -liftRel_pure_right] using ⟨r, Or.inr ⟨s, rfl, t, rfl, h⟩⟩⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_join.lem","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nS : Stream'.WSeq (Stream'.WSeq α)\nT : Stream'.WSeq (Stream'.WSeq β)\nU : Stream'.WSeq α → Stream'.WSeq β → Prop\nST : Stream'.WSeq.LiftRel (Stream'.WSeq.LiftRel R) S T\nHU : ∀ (s1 : Stream'.WSeq α) (s2 : Stream'.WSeq β), (Exists fun s => Exists fun t => Exists fun S => Exists fun T => And (Eq s1 (s.append S.join)) (And (Eq s2 (t.append T.join)) (And (Stream'.WSeq.LiftRel R s t) (Stream'.WSeq.LiftRel (Stream'.WSeq.LiftRel R) S T)))) → U s1 s2\na : Option (Prod α (Stream'.WSeq α))\nma : Membership.mem S.join.destruct a\n⊢ Exists fun b => And (Membership.mem T.join.destruct b) (Stream'.WSeq.LiftRelO R U a b)","decl":"theorem liftRel_join.lem (R : α → β → Prop) {S T} {U : WSeq α → WSeq β → Prop}\n    (ST : LiftRel (LiftRel R) S T)\n    (HU :\n      ∀ s1 s2,\n        (∃ s t S T,\n            s1 = append s (join S) ∧\n              s2 = append t (join T) ∧ LiftRel R s t ∧ LiftRel (LiftRel R) S T) →\n          U s1 s2)\n    {a} (ma : a ∈ destruct (join S)) : ∃ b, b ∈ destruct (join T) ∧ LiftRelO R U a b := by\n  cases' exists_results_of_mem ma with n h; clear ma; revert S T ST a\n  induction' n using Nat.strongRecOn with n IH\n  intro S T ST a ra; simp only [destruct_join] at ra\n  exact\n    let ⟨o, m, k, rs1, rs2, en⟩ := of_results_bind ra\n    let ⟨p, mT, rop⟩ := Computation.exists_of_liftRel_left (liftRel_destruct ST) rs1.mem\n    match o, p, rop, rs1, rs2, mT with\n    | none, none, _, _, rs2, mT => by\n      simp only [destruct_join]\n      exact ⟨none, mem_bind mT (ret_mem _), by rw [eq_of_pure_mem rs2.mem]; trivial⟩\n    | some (s, S'), some (t, T'), ⟨st, ST'⟩, _, rs2, mT => by\n      simp? [destruct_append]  at rs2  says simp only [destruct_join.aux, destruct_append] at rs2\n      exact\n        let ⟨k1, rs3, ek⟩ := of_results_think rs2\n        let ⟨o', m1, n1, rs4, rs5, ek1⟩ := of_results_bind rs3\n        let ⟨p', mt, rop'⟩ := Computation.exists_of_liftRel_left (liftRel_destruct st) rs4.mem\n        match o', p', rop', rs4, rs5, mt with\n        | none, none, _, _, rs5', mt => by\n          have : n1 < n := by\n            rw [en, ek, ek1]\n            apply lt_of_lt_of_le _ (Nat.le_add_right _ _)\n            apply Nat.lt_succ_of_le (Nat.le_add_right _ _)\n          let ⟨ob, mb, rob⟩ := IH _ this ST' rs5'\n          refine ⟨ob, ?_, rob⟩\n          · simp (config := { unfoldPartialApp := true }) only [destruct_join, destruct_join.aux]\n            apply mem_bind mT\n            simp only [destruct_append, destruct_append.aux]\n            apply think_mem\n            apply mem_bind mt\n            exact mb\n        | some (a, s'), some (b, t'), ⟨ab, st'⟩, _, rs5, mt => by\n          simp?  at rs5  says simp only [destruct_append.aux] at rs5\n          refine ⟨some (b, append t' (join T')), ?_, ?_⟩\n          · simp (config := { unfoldPartialApp := true }) only [destruct_join, destruct_join.aux]\n            apply mem_bind mT\n            simp only [destruct_append, destruct_append.aux]\n            apply think_mem\n            apply mem_bind mt\n            apply ret_mem\n          rw [eq_of_pure_mem rs5.mem]\n          exact ⟨ab, HU _ _ ⟨s', t', S', T', rfl, rfl, st', ST'⟩⟩\n\n"}
{"name":"Stream'.WSeq.liftRel_join","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nR : α → β → Prop\nS : Stream'.WSeq (Stream'.WSeq α)\nT : Stream'.WSeq (Stream'.WSeq β)\nh : Stream'.WSeq.LiftRel (Stream'.WSeq.LiftRel R) S T\n⊢ Stream'.WSeq.LiftRel R S.join T.join","decl":"theorem liftRel_join (R : α → β → Prop) {S : WSeq (WSeq α)} {T : WSeq (WSeq β)}\n    (h : LiftRel (LiftRel R) S T) : LiftRel R (join S) (join T) :=\n  ⟨fun s1 s2 =>\n    ∃ s t S T,\n      s1 = append s (join S) ∧ s2 = append t (join T) ∧ LiftRel R s t ∧ LiftRel (LiftRel R) S T,\n    ⟨nil, nil, S, T, by simp, by simp, by simp, h⟩, fun {s1 s2} ⟨s, t, S, T, h1, h2, st, ST⟩ => by\n    rw [h1, h2]; rw [destruct_append, destruct_append]\n    apply Computation.liftRel_bind _ _ (liftRel_destruct st)\n    exact fun {o p} h =>\n      match o, p, h with\n      | some (a, s), some (b, t), ⟨h1, h2⟩ => by\n        -- Porting note: These 2 theorems should be excluded.\n        simpa [-liftRel_pure_left, -liftRel_pure_right] using ⟨h1, s, t, S, rfl, T, rfl, h2, ST⟩\n      | none, none, _ => by\n        -- Porting note: `LiftRelO` should be excluded.\n        dsimp [destruct_append.aux, Computation.LiftRel, -LiftRelO]; constructor\n        · intro\n          apply liftRel_join.lem _ ST fun _ _ => id\n        · intro b mb\n          rw [← LiftRelO.swap]\n          apply liftRel_join.lem (swap R)\n          · rw [← LiftRel.swap R, ← LiftRel.swap]\n            apply ST\n          · rw [← LiftRel.swap R, ← LiftRel.swap (LiftRel R)]\n            exact fun s1 s2 ⟨s, t, S, T, h1, h2, st, ST⟩ => ⟨t, s, T, S, h2, h1, st, ST⟩\n          · exact mb⟩\n\n"}
{"name":"Stream'.WSeq.join_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nS T : Stream'.WSeq (Stream'.WSeq α)\nh : Stream'.WSeq.LiftRel Stream'.WSeq.Equiv S T\n⊢ S.join.Equiv T.join","decl":"theorem join_congr {S T : WSeq (WSeq α)} (h : LiftRel Equiv S T) : join S ~ʷ join T :=\n  liftRel_join _ h\n\n"}
{"name":"Stream'.WSeq.liftRel_bind","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\nδ : Type u_1\nR : α → β → Prop\nS : γ → δ → Prop\ns1 : Stream'.WSeq α\ns2 : Stream'.WSeq β\nf1 : α → Stream'.WSeq γ\nf2 : β → Stream'.WSeq δ\nh1 : Stream'.WSeq.LiftRel R s1 s2\nh2 : ∀ {a : α} {b : β}, R a b → Stream'.WSeq.LiftRel S (f1 a) (f2 b)\n⊢ Stream'.WSeq.LiftRel S (s1.bind f1) (s2.bind f2)","decl":"theorem liftRel_bind {δ} (R : α → β → Prop) (S : γ → δ → Prop) {s1 : WSeq α} {s2 : WSeq β}\n    {f1 : α → WSeq γ} {f2 : β → WSeq δ} (h1 : LiftRel R s1 s2)\n    (h2 : ∀ {a b}, R a b → LiftRel S (f1 a) (f2 b)) : LiftRel S (bind s1 f1) (bind s2 f2) :=\n  liftRel_join _ (liftRel_map _ _ h1 @h2)\n\n"}
{"name":"Stream'.WSeq.bind_congr","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\ns1 s2 : Stream'.WSeq α\nf1 f2 : α → Stream'.WSeq β\nh1 : s1.Equiv s2\nh2 : ∀ (a : α), (f1 a).Equiv (f2 a)\n⊢ (s1.bind f1).Equiv (s2.bind f2)","decl":"theorem bind_congr {s1 s2 : WSeq α} {f1 f2 : α → WSeq β} (h1 : s1 ~ʷ s2) (h2 : ∀ a, f1 a ~ʷ f2 a) :\n    bind s1 f1 ~ʷ bind s2 f2 :=\n  liftRel_bind _ _ h1 fun {a b} h => by rw [h]; apply h2\n\n"}
{"name":"Stream'.WSeq.join_ret","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ (Stream'.WSeq.ret s).join.Equiv s","decl":"@[simp]\ntheorem join_ret (s : WSeq α) : join (ret s) ~ʷ s := by simpa [ret] using think_equiv _\n\n"}
{"name":"Stream'.WSeq.join_map_ret","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\ns : Stream'.WSeq α\n⊢ (Stream'.WSeq.map Stream'.WSeq.ret s).join.Equiv s","decl":"@[simp]\ntheorem join_map_ret (s : WSeq α) : join (map ret s) ~ʷ s := by\n  refine ⟨fun s1 s2 => join (map ret s2) = s1, rfl, ?_⟩\n  intro s' s h; rw [← h]\n  apply liftRel_rec fun c1 c2 => ∃ s, c1 = destruct (join (map ret s)) ∧ c2 = destruct s\n  · exact fun {c1 c2} h =>\n      match c1, c2, h with\n      | _, _, ⟨s, rfl, rfl⟩ => by\n        clear h\n        -- Porting note: `ret` is simplified in `simp` so `ret`s become `fun a => cons a nil` here.\n        have : ∀ s, ∃ s' : WSeq α,\n            (map (fun a => cons a nil) s).join.destruct =\n              (map (fun a => cons a nil) s').join.destruct ∧ destruct s = s'.destruct :=\n          fun s => ⟨s, rfl, rfl⟩\n        induction' s using WSeq.recOn with a s s <;>\n          simp (config := { unfoldPartialApp := true }) [ret, ret_mem, this, Option.exists]\n  · exact ⟨s, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.join_append","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nS T : Stream'.WSeq (Stream'.WSeq α)\n⊢ (S.append T).join.Equiv (S.join.append T.join)","decl":"@[simp]\ntheorem join_append (S T : WSeq (WSeq α)) : join (append S T) ~ʷ append (join S) (join T) := by\n  refine\n    ⟨fun s1 s2 =>\n      ∃ s S T, s1 = append s (join (append S T)) ∧ s2 = append s (append (join S) (join T)),\n      ⟨nil, S, T, by simp, by simp⟩, ?_⟩\n  intro s1 s2 h\n  apply\n    liftRel_rec\n      (fun c1 c2 =>\n        ∃ (s : WSeq α) (S T : _),\n          c1 = destruct (append s (join (append S T))) ∧\n            c2 = destruct (append s (append (join S) (join T))))\n      _ _ _\n      (let ⟨s, S, T, h1, h2⟩ := h\n      ⟨s, S, T, congr_arg destruct h1, congr_arg destruct h2⟩)\n  rintro c1 c2 ⟨s, S, T, rfl, rfl⟩\n  induction' s using WSeq.recOn with a s s <;> simp\n  · induction' S using WSeq.recOn with s S S <;> simp\n    · induction' T using WSeq.recOn with s T T <;> simp\n      · refine ⟨s, nil, T, ?_, ?_⟩ <;> simp\n      · refine ⟨nil, nil, T, ?_, ?_⟩ <;> simp\n    · exact ⟨s, S, T, rfl, rfl⟩\n    · refine ⟨nil, S, T, ?_, ?_⟩ <;> simp\n  · exact ⟨s, S, T, rfl, rfl⟩\n  · exact ⟨s, S, T, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.bind_ret","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\ns : Stream'.WSeq α\n⊢ (s.bind (Function.comp Stream'.WSeq.ret f)).Equiv (Stream'.WSeq.map f s)","decl":"@[simp]\ntheorem bind_ret (f : α → β) (s) : bind s (ret ∘ f) ~ʷ map f s := by\n  dsimp [bind]\n  rw [map_comp]\n  apply join_map_ret\n\n"}
{"name":"Stream'.WSeq.ret_bind","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\na : α\nf : α → Stream'.WSeq β\n⊢ ((Stream'.WSeq.ret a).bind f).Equiv (f a)","decl":"@[simp]\ntheorem ret_bind (a : α) (f : α → WSeq β) : bind (ret a) f ~ʷ f a := by simp [bind]\n\n"}
{"name":"Stream'.WSeq.map_join","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nS : Stream'.WSeq (Stream'.WSeq α)\n⊢ Eq (Stream'.WSeq.map f S.join) (Stream'.WSeq.map (Stream'.WSeq.map f) S).join","decl":"@[simp]\ntheorem map_join (f : α → β) (S) : map f (join S) = join (map (map f) S) := by\n  apply\n    Seq.eq_of_bisim fun s1 s2 =>\n      ∃ s S, s1 = append s (map f (join S)) ∧ s2 = append s (join (map (map f) S))\n  · intro s1 s2 h\n    exact\n      match s1, s2, h with\n      | _, _, ⟨s, S, rfl, rfl⟩ => by\n        induction' s using WSeq.recOn with a s s <;> simp\n        · induction' S using WSeq.recOn with s S S <;> simp\n          · exact ⟨map f s, S, rfl, rfl⟩\n          · refine ⟨nil, S, ?_, ?_⟩ <;> simp\n        · exact ⟨_, _, rfl, rfl⟩\n        · exact ⟨_, _, rfl, rfl⟩\n  · refine ⟨nil, S, ?_, ?_⟩ <;> simp\n\n"}
{"name":"Stream'.WSeq.join_join","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nSS : Stream'.WSeq (Stream'.WSeq (Stream'.WSeq α))\n⊢ SS.join.join.Equiv (Stream'.WSeq.map Stream'.WSeq.join SS).join","decl":"@[simp]\ntheorem join_join (SS : WSeq (WSeq (WSeq α))) : join (join SS) ~ʷ join (map join SS) := by\n  refine\n    ⟨fun s1 s2 =>\n      ∃ s S SS,\n        s1 = append s (join (append S (join SS))) ∧\n          s2 = append s (append (join S) (join (map join SS))),\n      ⟨nil, nil, SS, by simp, by simp⟩, ?_⟩\n  intro s1 s2 h\n  apply\n    liftRel_rec\n      (fun c1 c2 =>\n        ∃ s S SS,\n          c1 = destruct (append s (join (append S (join SS)))) ∧\n            c2 = destruct (append s (append (join S) (join (map join SS)))))\n      _ (destruct s1) (destruct s2)\n      (let ⟨s, S, SS, h1, h2⟩ := h\n      ⟨s, S, SS, by simp [h1], by simp [h2]⟩)\n  intro c1 c2 h\n  exact\n    match c1, c2, h with\n    | _, _, ⟨s, S, SS, rfl, rfl⟩ => by\n      clear h\n      induction' s using WSeq.recOn with a s s <;> simp\n      · induction' S using WSeq.recOn with s S S <;> simp\n        · induction' SS using WSeq.recOn with S SS SS <;> simp\n          · refine ⟨nil, S, SS, ?_, ?_⟩ <;> simp\n          · refine ⟨nil, nil, SS, ?_, ?_⟩ <;> simp\n        · exact ⟨s, S, SS, rfl, rfl⟩\n        · refine ⟨nil, S, SS, ?_, ?_⟩ <;> simp\n      · exact ⟨s, S, SS, rfl, rfl⟩\n      · exact ⟨s, S, SS, rfl, rfl⟩\n\n"}
{"name":"Stream'.WSeq.bind_assoc","module":"Mathlib.Data.Seq.WSeq","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ns : Stream'.WSeq α\nf : α → Stream'.WSeq β\ng : β → Stream'.WSeq γ\n⊢ ((s.bind f).bind g).Equiv (s.bind fun x => (f x).bind g)","decl":"@[simp]\ntheorem bind_assoc (s : WSeq α) (f : α → WSeq β) (g : β → WSeq γ) :\n    bind (bind s f) g ~ʷ bind s fun x : α => bind (f x) g := by\n  simp only [bind, map_join]; erw [← map_comp f (map g), map_comp (map g ∘ f) join]\n  apply join_join\n\n"}
