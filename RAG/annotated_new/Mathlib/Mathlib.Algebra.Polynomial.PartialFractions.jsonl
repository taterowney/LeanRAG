{"name":"div_eq_quo_add_rem_div_add_rem_div","module":"Mathlib.Algebra.Polynomial.PartialFractions","initialProofState":"R : Type\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type\ninst✝² : Field K\ninst✝¹ : Algebra (Polynomial R) K\ninst✝ : IsFractionRing (Polynomial R) K\nf g₁ g₂ : Polynomial R\nhg₁ : g₁.Monic\nhg₂ : g₂.Monic\nhcoprime : IsCoprime g₁ g₂\n⊢ Exists fun q => Exists fun r₁ => Exists fun r₂ => And (LT.lt r₁.degree g₁.degree) (And (LT.lt r₂.degree g₂.degree) (Eq (HDiv.hDiv (↑f) (HMul.hMul ↑g₁ ↑g₂)) (HAdd.hAdd (HAdd.hAdd (↑q) (HDiv.hDiv ↑r₁ ↑g₁)) (HDiv.hDiv ↑r₂ ↑g₂))))","decl":"/-- Let R be an integral domain and f, g₁, g₂ ∈ R[X]. Let g₁ and g₂ be monic and coprime.\nThen, ∃ q, r₁, r₂ ∈ R[X] such that f / g₁g₂ = q + r₁/g₁ + r₂/g₂ and deg(r₁) < deg(g₁) and\ndeg(r₂) < deg(g₂).\n-/\ntheorem div_eq_quo_add_rem_div_add_rem_div (f : R[X]) {g₁ g₂ : R[X]} (hg₁ : g₁.Monic)\n    (hg₂ : g₂.Monic) (hcoprime : IsCoprime g₁ g₂) :\n    ∃ q r₁ r₂ : R[X],\n      r₁.degree < g₁.degree ∧\n        r₂.degree < g₂.degree ∧ (f : K) / (↑g₁ * ↑g₂) = ↑q + ↑r₁ / ↑g₁ + ↑r₂ / ↑g₂ := by\n  rcases hcoprime with ⟨c, d, hcd⟩\n  refine\n    ⟨f * d /ₘ g₁ + f * c /ₘ g₂, f * d %ₘ g₁, f * c %ₘ g₂, degree_modByMonic_lt _ hg₁,\n      degree_modByMonic_lt _ hg₂, ?_⟩\n  have hg₁' : (↑g₁ : K) ≠ 0 := by\n    norm_cast\n    exact hg₁.ne_zero\n  have hg₂' : (↑g₂ : K) ≠ 0 := by\n    norm_cast\n    exact hg₂.ne_zero\n  have hfc := modByMonic_add_div (f * c) hg₂\n  have hfd := modByMonic_add_div (f * d) hg₁\n  field_simp\n  norm_cast\n  linear_combination -1 * f * hcd + -1 * g₁ * hfc + -1 * g₂ * hfd\n\n"}
{"name":"div_eq_quo_add_sum_rem_div","module":"Mathlib.Algebra.Polynomial.PartialFractions","initialProofState":"R : Type\ninst✝⁴ : CommRing R\ninst✝³ : IsDomain R\nK : Type\ninst✝² : Field K\ninst✝¹ : Algebra (Polynomial R) K\ninst✝ : IsFractionRing (Polynomial R) K\nf : Polynomial R\nι : Type u_1\ng : ι → Polynomial R\ns : Finset ι\nhg : ∀ (i : ι), Membership.mem s i → (g i).Monic\nhcop : (↑s).Pairwise fun i j => IsCoprime (g i) (g j)\n⊢ Exists fun q => Exists fun r => And (∀ (i : ι), Membership.mem s i → LT.lt (r i).degree (g i).degree) (Eq (HDiv.hDiv (↑f) (s.prod fun i => ↑(g i))) (HAdd.hAdd (↑q) (s.sum fun i => HDiv.hDiv ↑(r i) ↑(g i))))","decl":"/-- Let R be an integral domain and f ∈ R[X]. Let s be a finite index set.\nThen, a fraction of the form f / ∏ (g i) can be rewritten as q + ∑ (r i) / (g i), where\ndeg(r i) < deg(g i), provided that the g i are monic and pairwise coprime.\n-/\ntheorem div_eq_quo_add_sum_rem_div (f : R[X]) {ι : Type*} {g : ι → R[X]} {s : Finset ι}\n    (hg : ∀ i ∈ s, (g i).Monic) (hcop : Set.Pairwise ↑s fun i j => IsCoprime (g i) (g j)) :\n    ∃ (q : R[X]) (r : ι → R[X]),\n      (∀ i ∈ s, (r i).degree < (g i).degree) ∧\n        ((↑f : K) / ∏ i ∈ s, ↑(g i)) = ↑q + ∑ i ∈ s, (r i : K) / (g i : K) := by\n  classical\n  induction' s using Finset.induction_on with a b hab Hind f generalizing f\n  · refine ⟨f, fun _ : ι => (0 : R[X]), fun i => ?_, by simp⟩\n    rintro ⟨⟩\n  obtain ⟨q₀, r₁, r₂, hdeg₁, _, hf : (↑f : K) / _ = _⟩ :=\n    div_eq_quo_add_rem_div_add_rem_div R K f\n      (hg a (b.mem_insert_self a) : Monic (g a))\n      (monic_prod_of_monic _ _ fun i hi => hg i (Finset.mem_insert_of_mem hi) :\n        Monic (∏ i ∈ b, g i))\n      (IsCoprime.prod_right fun i hi =>\n        hcop (Finset.mem_coe.2 (b.mem_insert_self a))\n          (Finset.mem_coe.2 (Finset.mem_insert_of_mem hi)) (by rintro rfl; exact hab hi))\n  obtain ⟨q, r, hrdeg, IH⟩ :=\n    Hind _ (fun i hi => hg i (Finset.mem_insert_of_mem hi))\n      (Set.Pairwise.mono (Finset.coe_subset.2 fun i hi => Finset.mem_insert_of_mem hi) hcop)\n  refine ⟨q₀ + q, fun i => if i = a then r₁ else r i, ?_, ?_⟩\n  · intro i\n    dsimp only\n    split_ifs with h1\n    · cases h1\n      intro\n      exact hdeg₁\n    · intro hi\n      exact hrdeg i (Finset.mem_of_mem_insert_of_ne hi h1)\n  norm_cast at hf IH ⊢\n  rw [Finset.prod_insert hab, hf, IH, Finset.sum_insert hab, if_pos rfl]\n  trans (↑(q₀ + q : R[X]) : K) + (↑r₁ / ↑(g a) + ∑ i ∈ b, (r i : K) / (g i : K))\n  · push_cast\n    ring\n  congr 2\n  refine Finset.sum_congr rfl fun x hxb => ?_\n  rw [if_neg]\n  rintro rfl\n  exact hab hxb\n\n"}
