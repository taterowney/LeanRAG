{"name":"factorsThrough_of_pullbackCondition","module":"Mathlib.Condensed.TopComparison","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C TopCat\nX : Type w'\ninst✝² : TopologicalSpace X\nZ B : C\nπ : Quiver.Hom Z B\ninst✝¹ : CategoryTheory.Limits.HasPullback π π\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan π π) G\na : ContinuousMap (↑(G.obj Z)) X\nha : Eq (Function.comp ⇑a ⇑(G.map (CategoryTheory.Limits.pullback.fst π π))) (Function.comp ⇑a ⇑(G.map (CategoryTheory.Limits.pullback.snd π π)))\n⊢ Function.FactorsThrough ⇑a ⇑(G.map π)","decl":"/--\nAn auxiliary lemma to that allows us to use `IsQuotientMap.lift` in the proof of\n`equalizerCondition_yonedaPresheaf`.\n-/\ntheorem factorsThrough_of_pullbackCondition {Z B : C} {π : Z ⟶ B} [HasPullback π π]\n    [PreservesLimit (cospan π π) G]\n    {a : C(G.obj Z, X)}\n    (ha : a ∘ (G.map (pullback.fst _ _)) = a ∘ (G.map (pullback.snd π π))) :\n    Function.FactorsThrough a (G.map π) := by\n  intro x y hxy\n  let xy : G.obj (pullback π π) := (PreservesPullback.iso G π π).inv <|\n    (TopCat.pullbackIsoProdSubtype (G.map π) (G.map π)).inv ⟨(x, y), hxy⟩\n  have ha' := congr_fun ha xy\n  dsimp at ha'\n  have h₁ : ∀ y, G.map (pullback.fst _ _) ((PreservesPullback.iso G π π).inv y) =\n      pullback.fst (G.map π) (G.map π) y := by\n    simp only [← PreservesPullback.iso_inv_fst]; intro y; rfl\n  have h₂ : ∀ y, G.map (pullback.snd _ _) ((PreservesPullback.iso G π π).inv y) =\n      pullback.snd (G.map π) (G.map π) y := by\n    simp only [← PreservesPullback.iso_inv_snd]; intro y; rfl\n  rw [h₁, h₂, TopCat.pullbackIsoProdSubtype_inv_fst_apply,\n    TopCat.pullbackIsoProdSubtype_inv_snd_apply] at ha'\n  simpa using ha'\n\n"}
{"name":"equalizerCondition_yonedaPresheaf","module":"Mathlib.Condensed.TopComparison","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C TopCat\nX : Type w'\ninst✝¹ : TopologicalSpace X\ninst✝ : ∀ (Z B : C) (π : Quiver.Hom Z B) [inst : CategoryTheory.EffectiveEpi π], CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan π π) G\nhq : ∀ (Z B : C) (π : Quiver.Hom Z B) [inst : CategoryTheory.EffectiveEpi π], Topology.IsQuotientMap ⇑(G.map π)\n⊢ CategoryTheory.regularTopology.EqualizerCondition (ContinuousMap.yonedaPresheaf G X)","decl":"/--\nIf `G` preserves the relevant pullbacks and every effective epi in `C` is a quotient map (which is\nthe case when `C` is `CompHaus` or `Profinite`), then `yonedaPresheaf` satisfies the equalizer\ncondition which is required to be a sheaf for the regular topology.\n-/\ntheorem equalizerCondition_yonedaPresheaf\n    [∀ (Z B : C) (π : Z ⟶ B) [EffectiveEpi π], PreservesLimit (cospan π π) G]\n    (hq : ∀ (Z B : C) (π : Z ⟶ B) [EffectiveEpi π], IsQuotientMap (G.map π)) :\n      EqualizerCondition (yonedaPresheaf G X) := by\n  apply EqualizerCondition.mk\n  intro Z B π _ _\n  refine ⟨fun a b h ↦ ?_, fun ⟨a, ha⟩ ↦ ?_⟩\n  · simp only [yonedaPresheaf, unop_op, Quiver.Hom.unop_op, Set.coe_setOf, MapToEqualizer,\n      Set.mem_setOf_eq, Subtype.mk.injEq, comp, ContinuousMap.mk.injEq] at h\n    simp only [yonedaPresheaf, unop_op]\n    ext x\n    obtain ⟨y, hy⟩ := (hq Z B π).surjective x\n    rw [← hy]\n    exact congr_fun h y\n  · simp only [yonedaPresheaf, comp, unop_op, Quiver.Hom.unop_op, Set.mem_setOf_eq,\n      ContinuousMap.mk.injEq] at ha\n    simp only [yonedaPresheaf, comp, unop_op, Quiver.Hom.unop_op, Set.coe_setOf,\n      MapToEqualizer, Set.mem_setOf_eq, Subtype.mk.injEq]\n    simp only [yonedaPresheaf, unop_op] at a\n    refine ⟨(hq Z B π).lift a (factorsThrough_of_pullbackCondition G X ha), ?_⟩\n    congr\n    exact DFunLike.ext'_iff.mp ((hq Z B π).lift_comp a (factorsThrough_of_pullbackCondition G X ha))\n\n"}
{"name":"instPreservesFiniteProductsOppositeYonedaPresheafOfPreservesFiniteCoproductsTopCat","module":"Mathlib.Condensed.TopComparison","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nG : CategoryTheory.Functor C TopCat\nX : Type w'\ninst✝¹ : TopologicalSpace X\ninst✝ : CategoryTheory.Limits.PreservesFiniteCoproducts G\n⊢ CategoryTheory.Limits.PreservesFiniteProducts (ContinuousMap.yonedaPresheaf G X)","decl":"/--\nIf `G` preserves finite coproducts (which is the case when `C` is `CompHaus`, `Profinite` or\n`Stonean`), then `yonedaPresheaf` preserves finite products, which is required to be a sheaf for\nthe extensive topology.\n-/\nnoncomputable instance [PreservesFiniteCoproducts G] :\n    PreservesFiniteProducts (yonedaPresheaf G X) :=\n  have := preservesFiniteProducts_op G\n  ⟨fun _ ↦ comp_preservesLimitsOfShape G.op (yonedaPresheaf' X)⟩\n\n"}
{"name":"TopCat.toSheafCompHausLike_val_map","module":"Mathlib.Condensed.TopComparison","initialProofState":"P : TopCat → Prop\nX : TopCat\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX✝ Y✝ : Opposite (CompHausLike P)\nf : Quiver.Hom X✝ Y✝\ng : ContinuousMap ↑((CompHausLike.compHausLikeToTop P).obj (Opposite.unop X✝)) ↑X\n⊢ Eq ((TopCat.toSheafCompHausLike P X hs).val.map f g) (g.comp f.unop)","decl":"/--\nThe sheaf on `CompHausLike P` of continuous maps to a topological space.\n-/\n@[simps! val_obj val_map]\ndef TopCat.toSheafCompHausLike :\n    have := CompHausLike.preregular hs\n    Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  val := yonedaPresheaf.{u, max u w} (CompHausLike.compHausLikeToTop.{u} P) X\n  cond := by\n    have := CompHausLike.preregular hs\n    rw [Presheaf.isSheaf_iff_preservesFiniteProducts_and_equalizerCondition]\n    refine ⟨inferInstance, ?_⟩\n    apply (config := { allowSynthFailures := true }) equalizerCondition_yonedaPresheaf\n      (CompHausLike.compHausLikeToTop.{u} P) X\n    intro Z B π he\n    apply IsQuotientMap.of_surjective_continuous (hs _ he) π.continuous\n\n"}
{"name":"TopCat.toSheafCompHausLike_val_obj","module":"Mathlib.Condensed.TopComparison","initialProofState":"P : TopCat → Prop\nX✝ : TopCat\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX : Opposite (CompHausLike P)\n⊢ Eq ((TopCat.toSheafCompHausLike P X✝ hs).val.obj X) (ContinuousMap ↑(Opposite.unop X).toTop ↑X✝)","decl":"/--\nThe sheaf on `CompHausLike P` of continuous maps to a topological space.\n-/\n@[simps! val_obj val_map]\ndef TopCat.toSheafCompHausLike :\n    have := CompHausLike.preregular hs\n    Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  val := yonedaPresheaf.{u, max u w} (CompHausLike.compHausLikeToTop.{u} P) X\n  cond := by\n    have := CompHausLike.preregular hs\n    rw [Presheaf.isSheaf_iff_preservesFiniteProducts_and_equalizerCondition]\n    refine ⟨inferInstance, ?_⟩\n    apply (config := { allowSynthFailures := true }) equalizerCondition_yonedaPresheaf\n      (CompHausLike.compHausLikeToTop.{u} P) X\n    intro Z B π he\n    apply IsQuotientMap.of_surjective_continuous (hs _ he) π.continuous\n\n"}
{"name":"topCatToSheafCompHausLike_obj","module":"Mathlib.Condensed.TopComparison","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX : TopCat\n⊢ Eq ((topCatToSheafCompHausLike P hs).obj X) (TopCat.toSheafCompHausLike P X hs)","decl":"/--\n`TopCat.toSheafCompHausLike` yields a functor from `TopCat.{max u w}` to\n`Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w))`.\n-/\n@[simps]\nnoncomputable def topCatToSheafCompHausLike :\n    have := CompHausLike.preregular hs\n    TopCat.{max u w} ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := X.toSheafCompHausLike P hs\n  map f := ⟨⟨fun _ g ↦ f.comp g, by aesop⟩⟩\n\n"}
{"name":"topCatToSheafCompHausLike_map_val_app","module":"Mathlib.Condensed.TopComparison","initialProofState":"P : TopCat → Prop\ninst✝¹ : CompHausLike.HasExplicitFiniteCoproducts P\ninst✝ : CompHausLike.HasExplicitPullbacks P\nhs : ∀ ⦃X Y : CompHausLike P⦄ (f : Quiver.Hom X Y), CategoryTheory.EffectiveEpi f → Function.Surjective ⇑f\nX✝ Y✝ : TopCat\nf : Quiver.Hom X✝ Y✝\nx✝ : Opposite (CompHausLike P)\ng : ((fun X => TopCat.toSheafCompHausLike P X hs) X✝).val.obj x✝\n⊢ Eq (((topCatToSheafCompHausLike P hs).map f).val.app x✝ g) (ContinuousMap.comp f g)","decl":"/--\n`TopCat.toSheafCompHausLike` yields a functor from `TopCat.{max u w}` to\n`Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w))`.\n-/\n@[simps]\nnoncomputable def topCatToSheafCompHausLike :\n    have := CompHausLike.preregular hs\n    TopCat.{max u w} ⥤ Sheaf (coherentTopology (CompHausLike.{u} P)) (Type (max u w)) where\n  obj X := X.toSheafCompHausLike P hs\n  map f := ⟨⟨fun _ g ↦ f.comp g, by aesop⟩⟩\n\n"}
