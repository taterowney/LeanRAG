{"name":"LightProfinite.Extend.functor_map","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nX✝ Y✝ : Opposite Nat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((LightProfinite.Extend.functor c).map f) (CategoryTheory.StructuredArrow.homMk (F.map f) ⋯)","decl":"/--\nGiven a sequential cone in `LightProfinite` consisting of finite sets,\nwe obtain a functor from the indexing category to `StructuredArrow c.pt toLightProfinite`.\n-/\n@[simps]\ndef functor : ℕᵒᵖ ⥤ StructuredArrow c.pt toLightProfinite where\n  obj i := StructuredArrow.mk (c.π.app i)\n  map f := StructuredArrow.homMk (F.map f) (c.w f)\n\n-- We check that the original diagram factors through `LightProfinite.Extend.functor`.\n"}
{"name":"LightProfinite.Extend.functor_obj","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\ni : Opposite Nat\n⊢ Eq ((LightProfinite.Extend.functor c).obj i) (CategoryTheory.StructuredArrow.mk (c.π.app i))","decl":"/--\nGiven a sequential cone in `LightProfinite` consisting of finite sets,\nwe obtain a functor from the indexing category to `StructuredArrow c.pt toLightProfinite`.\n-/\n@[simps]\ndef functor : ℕᵒᵖ ⥤ StructuredArrow c.pt toLightProfinite where\n  obj i := StructuredArrow.mk (c.π.app i)\n  map f := StructuredArrow.homMk (F.map f) (c.w f)\n\n-- We check that the original diagram factors through `LightProfinite.Extend.functor`.\n"}
{"name":"LightProfinite.Extend.functorOp_map","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nX✝ Y✝ : Nat\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((LightProfinite.Extend.functorOp c).map f) (CategoryTheory.CostructuredArrow.homMk (F.map f.op).op ⋯)","decl":"/--\nGiven a sequential cone in `LightProfinite` consisting of finite sets,\nwe obtain a functor from the opposite of the indexing category to\n`CostructuredArrow toProfinite.op ⟨c.pt⟩`.\n-/\n@[simps! obj map]\ndef functorOp : ℕ ⥤ CostructuredArrow toLightProfinite.op ⟨c.pt⟩ :=\n  (functor c).rightOp ⋙ StructuredArrow.toCostructuredArrow _ _\n\n-- We check that the opposite of the original diagram factors through `Profinite.Extend.functorOp`.\n"}
{"name":"LightProfinite.Extend.functorOp_obj","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nX : Nat\n⊢ Eq ((LightProfinite.Extend.functorOp c).obj X) (CategoryTheory.CostructuredArrow.mk (c.π.app { unop := X }).op)","decl":"/--\nGiven a sequential cone in `LightProfinite` consisting of finite sets,\nwe obtain a functor from the opposite of the indexing category to\n`CostructuredArrow toProfinite.op ⟨c.pt⟩`.\n-/\n@[simps! obj map]\ndef functorOp : ℕ ⥤ CostructuredArrow toLightProfinite.op ⟨c.pt⟩ :=\n  (functor c).rightOp ⋙ StructuredArrow.toCostructuredArrow _ _\n\n-- We check that the opposite of the original diagram factors through `Profinite.Extend.functorOp`.\n"}
{"name":"LightProfinite.Extend.functor_initial","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nhc : CategoryTheory.Limits.IsLimit c\ninst✝ : ∀ (i : Opposite Nat), CategoryTheory.Epi (c.π.app i)\n⊢ (LightProfinite.Extend.functor c).Initial","decl":"/--\nIf the projection maps in the cone are epimorphic and the cone is limiting, then\n`LightProfinite.Extend.functor` is initial.\n-/\ntheorem functor_initial (hc : IsLimit c) [∀ i, Epi (c.π.app i)] : Initial (functor c) := by\n  rw [initial_iff_comp_equivalence _ (StructuredArrow.post _ _ lightToProfinite)]\n  have : ∀ i, Epi ((lightToProfinite.mapCone c).π.app i) :=\n    fun i ↦ inferInstanceAs (Epi (lightToProfinite.map (c.π.app i)))\n  exact Profinite.Extend.functor_initial _ (isLimitOfPreserves lightToProfinite hc)\n\n"}
{"name":"LightProfinite.Extend.functorOp_final","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"F : CategoryTheory.Functor (Opposite Nat) FintypeCat\nc : CategoryTheory.Limits.Cone (F.comp FintypeCat.toLightProfinite)\nhc : CategoryTheory.Limits.IsLimit c\ninst✝ : ∀ (i : Opposite Nat), CategoryTheory.Epi (c.π.app i)\n⊢ (LightProfinite.Extend.functorOp c).Final","decl":"/--\nIf the projection maps in the cone are epimorphic and the cone is limiting, then\n`LightProfinite.Extend.functorOp` is final.\n-/\ntheorem functorOp_final (hc : IsLimit c) [∀ i, Epi (c.π.app i)] : Final (functorOp c) := by\n  have := functor_initial c hc\n  have : ((StructuredArrow.toCostructuredArrow toLightProfinite c.pt)).IsEquivalence  :=\n    (inferInstance : (structuredArrowOpEquivalence _ _).functor.IsEquivalence )\n  have : (functor c).rightOp.Final :=\n    inferInstanceAs ((opOpEquivalence ℕ).inverse ⋙ (functor c).op).Final\n  exact Functor.final_comp (functor c).rightOp _\n\n"}
{"name":"LightProfinite.Extend.cocone_pt","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor (Opposite LightProfinite) C\nS : LightProfinite\n⊢ Eq (LightProfinite.Extend.cocone G S).pt (G.obj { unop := S })","decl":"/--\nGiven a functor `G` from `LightProfiniteᵒᵖ` and `S : LightProfinite`, we obtain a cocone on\n`(CostructuredArrow.proj toLightProfinite.op ⟨S⟩ ⋙ toLightProfinite.op ⋙ G)` with cocone point\n`G.obj ⟨S⟩`.\n\nWhiskering this cocone with `LightProfinite.Extend.functorOp c` gives `G.mapCocone c.op` as we\ncheck in the example below.\n-/\n@[simps]\ndef cocone (S : LightProfinite) :\n    Cocone (CostructuredArrow.proj toLightProfinite.op ⟨S⟩ ⋙ toLightProfinite.op ⋙ G) where\n  pt := G.obj ⟨S⟩\n  ι := {\n    app := fun i ↦ G.map i.hom\n    naturality := fun _ _ f ↦ (by\n      have := f.w\n      simp only [op_obj, const_obj_obj, op_map, CostructuredArrow.right_eq_id, const_obj_map,\n        Category.comp_id] at this\n      simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, const_obj_obj, Functor.comp_map,\n        CostructuredArrow.proj_map, op_map, ← map_comp, this, const_obj_map, Category.comp_id]) }\n\n"}
{"name":"LightProfinite.Extend.cocone_ι_app","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nG : CategoryTheory.Functor (Opposite LightProfinite) C\nS : LightProfinite\ni : CategoryTheory.CostructuredArrow FintypeCat.toLightProfinite.op { unop := S }\n⊢ Eq ((LightProfinite.Extend.cocone G S).ι.app i) (G.map i.hom)","decl":"/--\nGiven a functor `G` from `LightProfiniteᵒᵖ` and `S : LightProfinite`, we obtain a cocone on\n`(CostructuredArrow.proj toLightProfinite.op ⟨S⟩ ⋙ toLightProfinite.op ⋙ G)` with cocone point\n`G.obj ⟨S⟩`.\n\nWhiskering this cocone with `LightProfinite.Extend.functorOp c` gives `G.mapCocone c.op` as we\ncheck in the example below.\n-/\n@[simps]\ndef cocone (S : LightProfinite) :\n    Cocone (CostructuredArrow.proj toLightProfinite.op ⟨S⟩ ⋙ toLightProfinite.op ⋙ G) where\n  pt := G.obj ⟨S⟩\n  ι := {\n    app := fun i ↦ G.map i.hom\n    naturality := fun _ _ f ↦ (by\n      have := f.w\n      simp only [op_obj, const_obj_obj, op_map, CostructuredArrow.right_eq_id, const_obj_map,\n        Category.comp_id] at this\n      simp only [comp_obj, CostructuredArrow.proj_obj, op_obj, const_obj_obj, Functor.comp_map,\n        CostructuredArrow.proj_map, op_map, ← map_comp, this, const_obj_map, Category.comp_id]) }\n\n"}
{"name":"LightProfinite.instEpiAppOppositeNatπAsLimitCone","module":"Mathlib.Topology.Category.LightProfinite.Extend","initialProofState":"S : LightProfinite\ni : Opposite Nat\n⊢ CategoryTheory.Epi (S.asLimitCone.π.app i)","decl":"instance (i : ℕᵒᵖ) : Epi (S.asLimitCone.π.app i) :=\n  (epi_iff_surjective _).mpr (S.proj_surjective _)\n\n"}
