{"name":"mem_approx_add_orderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddGroup A\nn : Nat\nŒ¥ : Real\na : A\n‚ä¢ Iff (Membership.mem (approxAddOrderOf A n Œ¥) a) (Exists fun b => And (Eq (addOrderOf b) n) (Membership.mem (Metric.ball b Œ¥) a))","decl":"@[to_additive mem_approx_add_orderOf_iff]\ntheorem mem_approxOrderOf_iff {A : Type*} [SeminormedGroup A] {n : ‚Ñï} {Œ¥ : ‚Ñù} {a : A} :\n    a ‚àà approxOrderOf A n Œ¥ ‚Üî ‚àÉ b : A, orderOf b = n ‚àß a ‚àà ball b Œ¥ := by\n  simp only [approxOrderOf, thickening_eq_biUnion_ball, mem_iUnion‚ÇÇ, mem_setOf_eq, exists_prop]\n\n"}
{"name":"mem_approxOrderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedGroup A\nn : Nat\nŒ¥ : Real\na : A\n‚ä¢ Iff (Membership.mem (approxOrderOf A n Œ¥) a) (Exists fun b => And (Eq (orderOf b) n) (Membership.mem (Metric.ball b Œ¥) a))","decl":"@[to_additive mem_approx_add_orderOf_iff]\ntheorem mem_approxOrderOf_iff {A : Type*} [SeminormedGroup A] {n : ‚Ñï} {Œ¥ : ‚Ñù} {a : A} :\n    a ‚àà approxOrderOf A n Œ¥ ‚Üî ‚àÉ b : A, orderOf b = n ‚àß a ‚àà ball b Œ¥ := by\n  simp only [approxOrderOf, thickening_eq_biUnion_ball, mem_iUnion‚ÇÇ, mem_setOf_eq, exists_prop]\n\n"}
{"name":"mem_add_wellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddGroup A\nŒ¥ : Nat ‚Üí Real\na : A\n‚ä¢ Iff (Membership.mem (addWellApproximable A Œ¥) a) (Membership.mem (Filter.blimsup (fun n => approxAddOrderOf A n (Œ¥ n)) Filter.atTop fun n => LT.lt 0 n) a)","decl":"@[to_additive mem_add_wellApproximable_iff]\ntheorem mem_wellApproximable_iff {A : Type*} [SeminormedGroup A] {Œ¥ : ‚Ñï ‚Üí ‚Ñù} {a : A} :\n    a ‚àà wellApproximable A Œ¥ ‚Üî\n      a ‚àà blimsup (fun n => approxOrderOf A n (Œ¥ n)) atTop fun n => 0 < n :=\n  Iff.rfl\n\n"}
{"name":"mem_wellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedGroup A\nŒ¥ : Nat ‚Üí Real\na : A\n‚ä¢ Iff (Membership.mem (wellApproximable A Œ¥) a) (Membership.mem (Filter.blimsup (fun n => approxOrderOf A n (Œ¥ n)) Filter.atTop fun n => LT.lt 0 n) a)","decl":"@[to_additive mem_add_wellApproximable_iff]\ntheorem mem_wellApproximable_iff {A : Type*} [SeminormedGroup A] {Œ¥ : ‚Ñï ‚Üí ‚Ñù} {a : A} :\n    a ‚àà wellApproximable A Œ¥ ‚Üî\n      a ‚àà blimsup (fun n => approxOrderOf A n (Œ¥ n)) atTop fun n => 0 < n :=\n  Iff.rfl\n\n"}
{"name":"approxOrderOf.image_pow_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedCommGroup A\nm n : Nat\nŒ¥ : Real\nhm : LT.lt 0 m\nhmn : n.Coprime m\n‚ä¢ HasSubset.Subset (Set.image (fun y => HPow.hPow y m) (approxOrderOf A n Œ¥)) (approxOrderOf A n (HMul.hMul (‚Üëm) Œ¥))","decl":"@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) := by\n  rintro - ‚ü®a, ha, rfl‚ü©\n  obtain ‚ü®b, hb, hab‚ü© := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ‚àà {u : A | orderOf u = n} := by\n    rw [‚Üê hb] at hmn ‚ä¢; exact hmn.orderOf_pow\n  apply ball_subset_thickening hb ((m : ‚Ñù) ‚Ä¢ Œ¥)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n\n"}
{"name":"approxAddOrderOf.image_nsmul_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddCommGroup A\nm n : Nat\nŒ¥ : Real\nhm : LT.lt 0 m\nhmn : n.Coprime m\n‚ä¢ HasSubset.Subset (Set.image (fun y => HSMul.hSMul m y) (approxAddOrderOf A n Œ¥)) (approxAddOrderOf A n (HMul.hMul (‚Üëm) Œ¥))","decl":"@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) := by\n  rintro - ‚ü®a, ha, rfl‚ü©\n  obtain ‚ü®b, hb, hab‚ü© := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ‚àà {u : A | orderOf u = n} := by\n    rw [‚Üê hb] at hmn ‚ä¢; exact hmn.orderOf_pow\n  apply ball_subset_thickening hb ((m : ‚Ñù) ‚Ä¢ Œ¥)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n\n"}
{"name":"approxOrderOf.image_pow_subset","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedCommGroup A\nm : Nat\nŒ¥ : Real\nn : Nat\nhm : LT.lt 0 m\n‚ä¢ HasSubset.Subset (Set.image (fun y => HPow.hPow y m) (approxOrderOf A (HMul.hMul n m) Œ¥)) (approxOrderOf A n (HMul.hMul (‚Üëm) Œ¥))","decl":"@[to_additive]\ntheorem image_pow_subset (n : ‚Ñï) (hm : 0 < m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A (n * m) Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) := by\n  rintro - ‚ü®a, ha, rfl‚ü©\n  obtain ‚ü®b, hb : orderOf b = n * m, hab : a ‚àà ball b Œ¥‚ü© := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ‚àà {y : A | orderOf y = n} := by\n    rw [mem_setOf_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * Œ¥)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul]\n\n"}
{"name":"approxAddOrderOf.image_nsmul_subset","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddCommGroup A\nm : Nat\nŒ¥ : Real\nn : Nat\nhm : LT.lt 0 m\n‚ä¢ HasSubset.Subset (Set.image (fun y => HSMul.hSMul m y) (approxAddOrderOf A (HMul.hMul n m) Œ¥)) (approxAddOrderOf A n (HMul.hMul (‚Üëm) Œ¥))","decl":"@[to_additive]\ntheorem image_pow_subset (n : ‚Ñï) (hm : 0 < m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A (n * m) Œ¥ ‚äÜ approxOrderOf A n (m * Œ¥) := by\n  rintro - ‚ü®a, ha, rfl‚ü©\n  obtain ‚ü®b, hb : orderOf b = n * m, hab : a ‚àà ball b Œ¥‚ü© := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ‚àà {y : A | orderOf y = n} := by\n    rw [mem_setOf_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * Œ¥)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul]\n\n"}
{"name":"approxOrderOf.smul_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedCommGroup A\na : A\nn : Nat\nŒ¥ : Real\nhan : (orderOf a).Coprime n\n‚ä¢ HasSubset.Subset (HSMul.hSMul a (approxOrderOf A n Œ¥)) (approxOrderOf A (HMul.hMul (orderOf a) n) Œ¥)","decl":"@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :\n    a ‚Ä¢ approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A (orderOf a * n) Œ¥ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ‚Üê image_smul, image_iUnion‚ÇÇ, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  refine iUnion‚ÇÇ_subset_iff.mpr fun b hb c hc => ?_\n  simp only [mem_iUnion, exists_prop]\n  refine ‚ü®a * b, ?_, hc‚ü©\n  rw [‚Üê hb] at han ‚ä¢\n  exact (Commute.all a b).orderOf_mul_eq_mul_orderOf_of_coprime han\n\n"}
{"name":"approxAddOrderOf.vadd_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddCommGroup A\na : A\nn : Nat\nŒ¥ : Real\nhan : (addOrderOf a).Coprime n\n‚ä¢ HasSubset.Subset (HVAdd.hVAdd a (approxAddOrderOf A n Œ¥)) (approxAddOrderOf A (HMul.hMul (addOrderOf a) n) Œ¥)","decl":"@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :\n    a ‚Ä¢ approxOrderOf A n Œ¥ ‚äÜ approxOrderOf A (orderOf a * n) Œ¥ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ‚Üê image_smul, image_iUnion‚ÇÇ, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  refine iUnion‚ÇÇ_subset_iff.mpr fun b hb c hc => ?_\n  simp only [mem_iUnion, exists_prop]\n  refine ‚ü®a * b, ?_, hc‚ü©\n  rw [‚Üê hb] at han ‚ä¢\n  exact (Commute.all a b).orderOf_mul_eq_mul_orderOf_of_coprime han\n\n"}
{"name":"approxAddOrderOf.vadd_eq_of_mul_dvd","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedAddCommGroup A\na : A\nn : Nat\nŒ¥ : Real\nhn : LT.lt 0 n\nhan : Dvd.dvd (HPow.hPow (addOrderOf a) 2) n\n‚ä¢ Eq (HVAdd.hVAdd a (approxAddOrderOf A n Œ¥)) (approxAddOrderOf A n Œ¥)","decl":"@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ‚à£ n) :\n    a ‚Ä¢ approxOrderOf A n Œ¥ = approxOrderOf A n Œ¥ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ‚Üê image_smul, image_iUnion‚ÇÇ, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  replace han : ‚àÄ {b : A}, orderOf b = n ‚Üí orderOf (a * b) = n := by\n    intro b hb\n    rw [‚Üê hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).orderOf_mul_eq_right_of_forall_prime_mul_dvd (orderOf_pos_iff.mp hn)\n      fun p _ hp' => dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : {b : A | orderOf b = n} ‚Üí {b : A | orderOf b = n} := fun b => ‚ü®a * b, han b.property‚ü©\n  have hf : Surjective f := by\n    rintro ‚ü®b, hb‚ü©\n    refine ‚ü®‚ü®a‚Åª¬π * b, ?_‚ü©, ?_‚ü©\n    ¬∑ rw [mem_setOf_eq, ‚Üê orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    ¬∑ simp only [f, Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [mem_setOf_eq, Subtype.coe_mk, iUnion_coe_set] using\n    hf.iUnion_comp fun b => ball (b : A) Œ¥\n\n"}
{"name":"approxOrderOf.smul_eq_of_mul_dvd","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù : SeminormedCommGroup A\na : A\nn : Nat\nŒ¥ : Real\nhn : LT.lt 0 n\nhan : Dvd.dvd (HPow.hPow (orderOf a) 2) n\n‚ä¢ Eq (HSMul.hSMul a (approxOrderOf A n Œ¥)) (approxOrderOf A n Œ¥)","decl":"@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ‚à£ n) :\n    a ‚Ä¢ approxOrderOf A n Œ¥ = approxOrderOf A n Œ¥ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ‚Üê image_smul, image_iUnion‚ÇÇ, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  replace han : ‚àÄ {b : A}, orderOf b = n ‚Üí orderOf (a * b) = n := by\n    intro b hb\n    rw [‚Üê hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).orderOf_mul_eq_right_of_forall_prime_mul_dvd (orderOf_pos_iff.mp hn)\n      fun p _ hp' => dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : {b : A | orderOf b = n} ‚Üí {b : A | orderOf b = n} := fun b => ‚ü®a * b, han b.property‚ü©\n  have hf : Surjective f := by\n    rintro ‚ü®b, hb‚ü©\n    refine ‚ü®‚ü®a‚Åª¬π * b, ?_‚ü©, ?_‚ü©\n    ¬∑ rw [mem_setOf_eq, ‚Üê orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    ¬∑ simp only [f, Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [mem_setOf_eq, Subtype.coe_mk, iUnion_coe_set] using\n    hf.iUnion_comp fun b => ball (b : A) Œ¥\n\n"}
{"name":"UnitAddCircle.mem_approxAddOrderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"Œ¥ : Real\nx : UnitAddCircle\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Iff (Membership.mem (approxAddOrderOf UnitAddCircle n Œ¥) x) (Exists fun m => And (LT.lt m n) (And (Eq (GCDMonoid.gcd m n) 1) (LT.lt (Norm.norm (HSub.hSub x ‚Üë(HDiv.hDiv ‚Üëm ‚Üën))) Œ¥)))","decl":"theorem mem_approxAddOrderOf_iff {Œ¥ : ‚Ñù} {x : UnitAddCircle} {n : ‚Ñï} (hn : 0 < n) :\n    x ‚àà approxAddOrderOf UnitAddCircle n Œ¥ ‚Üî ‚àÉ m < n, gcd m n = 1 ‚àß ‚Äñx - ‚Üë((m : ‚Ñù) / n)‚Äñ < Œ¥ := by\n  simp only [mem_approx_add_orderOf_iff, mem_setOf_eq, ball, exists_prop, dist_eq_norm,\n    AddCircle.addOrderOf_eq_pos_iff hn, mul_one]\n  constructor\n  ¬∑ rintro ‚ü®y, ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, rfl‚ü©, hx‚ü©; exact ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, hx‚ü©\n  ¬∑ rintro ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, hx‚ü©; exact ‚ü®‚Üë((m : ‚Ñù) / n), ‚ü®m, hm‚ÇÅ, hm‚ÇÇ, rfl‚ü©, hx‚ü©\n\n"}
{"name":"UnitAddCircle.mem_addWellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"Œ¥ : Nat ‚Üí Real\nx : UnitAddCircle\n‚ä¢ Iff (Membership.mem (addWellApproximable UnitAddCircle Œ¥) x) (setOf fun n => Exists fun m => And (LT.lt m n) (And (Eq (GCDMonoid.gcd m n) 1) (LT.lt (Norm.norm (HSub.hSub x ‚Üë(HDiv.hDiv ‚Üëm ‚Üën))) (Œ¥ n)))).Infinite","decl":"theorem mem_addWellApproximable_iff (Œ¥ : ‚Ñï ‚Üí ‚Ñù) (x : UnitAddCircle) :\n    x ‚àà addWellApproximable UnitAddCircle Œ¥ ‚Üî\n      {n : ‚Ñï | ‚àÉ m < n, gcd m n = 1 ‚àß ‚Äñx - ‚Üë((m : ‚Ñù) / n)‚Äñ < Œ¥ n}.Infinite := by\n  simp only [mem_add_wellApproximable_iff, ‚Üê Nat.cofinite_eq_atTop, cofinite.blimsup_set_eq,\n    mem_setOf_eq]\n  refine iff_of_eq (congr_arg Set.Infinite <| ext fun n => ‚ü®fun hn => ?_, fun hn => ?_‚ü©)\n  ¬∑ exact (mem_approxAddOrderOf_iff hn.1).mp hn.2\n  ¬∑ have h : 0 < n := by obtain ‚ü®m, hm‚ÇÅ, _, _‚ü© := hn; exact pos_of_gt hm‚ÇÅ\n    exact ‚ü®h, (mem_approxAddOrderOf_iff h).mpr hn‚ü©\n\n"}
{"name":"AddCircle.addWellApproximable_ae_empty_or_univ","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nŒ¥ : Nat ‚Üí Real\nhŒ¥ : Filter.Tendsto Œ¥ Filter.atTop (nhds 0)\n‚ä¢ Or (Filter.Eventually (fun x => Not (addWellApproximable (AddCircle T) Œ¥ x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)) (Filter.Eventually (fun x => addWellApproximable (AddCircle T) Œ¥ x) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume))","decl":"/-- **Gallagher's ergodic theorem** on Diophantine approximation. -/\ntheorem addWellApproximable_ae_empty_or_univ (Œ¥ : ‚Ñï ‚Üí ‚Ñù) (hŒ¥ : Tendsto Œ¥ atTop (ùìù 0)) :\n    (‚àÄ·µê x, ¬¨addWellApproximable ùïä Œ¥ x) ‚à® ‚àÄ·µê x, addWellApproximable ùïä Œ¥ x := by\n  /- Sketch of proof:\n\n    Let `E := addWellApproximable ùïä Œ¥`. For each prime `p : ‚Ñï`, we can partition `E` into three\n    pieces `E = (A p) ‚à™ (B p) ‚à™ (C p)` where:\n      `A p = blimsup (approxAddOrderOf ùïä n (Œ¥ n)) atTop (fun n => 0 < n ‚àß (p ‚à§ n))`\n      `B p = blimsup (approxAddOrderOf ùïä n (Œ¥ n)) atTop (fun n => 0 < n ‚àß (p ‚à£‚à£ n))`\n      `C p = blimsup (approxAddOrderOf ùïä n (Œ¥ n)) atTop (fun n => 0 < n ‚àß (p*p ‚à£ n))`.\n    In other words, `A p` is the set of points `x` for which there exist infinitely-many `n` such\n    that `x` is within a distance `Œ¥ n` of a point of order `n` and `p ‚à§ n`. Similarly for `B`, `C`.\n\n    These sets have the following key properties:\n      1. `A p` is almost invariant under the ergodic map `y ‚Ü¶ p ‚Ä¢ y`\n      2. `B p` is almost invariant under the ergodic map `y ‚Ü¶ p ‚Ä¢ y + 1/p`\n      3. `C p` is invariant under the map `y ‚Ü¶ y + 1/p`\n    To prove 1 and 2 we need the key result `blimsup_thickening_mul_ae_eq` but 3 is elementary.\n\n    It follows from `AddCircle.ergodic_nsmul_add` and `Ergodic.ae_empty_or_univ_of_image_ae_le` that\n    if either `A p` or `B p` is not almost empty for any `p`, then it is almost full and thus so is\n    `E`. We may therefore assume that `A p` and `B p` are almost empty for all `p`. We thus have\n    `E` is almost equal to `C p` for every prime. Combining this with 3 we find that `E` is almost\n    invariant under the map `y ‚Ü¶ y + 1/p` for every prime `p`. The required result then follows from\n    `AddCircle.ae_empty_or_univ_of_forall_vadd_ae_eq_self`. -/\n  letI : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup _\n  set Œº : Measure ùïä := volume\n  set u : Nat.Primes ‚Üí ùïä := fun p => ‚Üë((‚Üë(1 : ‚Ñï) : ‚Ñù) / ((p : ‚Ñï) : ‚Ñù) * T)\n  have hu‚ÇÄ : ‚àÄ p : Nat.Primes, addOrderOf (u p) = (p : ‚Ñï) := by\n    rintro ‚ü®p, hp‚ü©; exact addOrderOf_div_of_gcd_eq_one hp.pos (gcd_one_left p)\n  have hu : Tendsto (addOrderOf ‚àò u) atTop atTop := by\n    rw [(funext hu‚ÇÄ : addOrderOf ‚àò u = (‚Üë))]\n    have h_mono : Monotone ((‚Üë) : Nat.Primes ‚Üí ‚Ñï) := fun p q hpq => hpq\n    refine h_mono.tendsto_atTop_atTop fun n => ?_\n    obtain ‚ü®p, hp, hp'‚ü© := n.exists_infinite_primes\n    exact ‚ü®‚ü®p, hp'‚ü©, hp‚ü©\n  set E := addWellApproximable ùïä Œ¥\n  set X : ‚Ñï ‚Üí Set ùïä := fun n => approxAddOrderOf ùïä n (Œ¥ n)\n  set A : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X atTop fun n => 0 < n ‚àß p‚à§n\n  set B : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X atTop fun n => 0 < n ‚àß p‚à£‚à£n\n  set C : ‚Ñï ‚Üí Set ùïä := fun p => blimsup X atTop fun n => 0 < n ‚àß p ^ 2 ‚à£ n\n  have hA‚ÇÄ : ‚àÄ p, MeasurableSet (A p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n _ => isOpen_thickening.measurableSet\n  have hB‚ÇÄ : ‚àÄ p, MeasurableSet (B p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n _ => isOpen_thickening.measurableSet\n  have hE‚ÇÄ : NullMeasurableSet E Œº := by\n    refine (MeasurableSet.measurableSet_blimsup fun n hn =>\n      IsOpen.measurableSet ?_).nullMeasurableSet\n    exact isOpen_thickening\n  have hE‚ÇÅ : ‚àÄ p, E = A p ‚à™ B p ‚à™ C p := by\n    intro p\n    simp only [E, A, B, C, addWellApproximable, ‚Üê blimsup_or_eq_sup, ‚Üê and_or_left, ‚Üê sup_eq_union,\n      sq]\n    congr\n    ext n\n    tauto\n  have hE‚ÇÇ : ‚àÄ p : Nat.Primes, A p =·µê[Œº] (‚àÖ : Set ùïä) ‚àß B p =·µê[Œº] (‚àÖ : Set ùïä) ‚Üí E =·µê[Œº] C p := by\n    rintro p ‚ü®hA, hB‚ü©\n    rw [hE‚ÇÅ p]\n    exact union_ae_eq_right_of_ae_eq_empty ((union_ae_eq_right_of_ae_eq_empty hA).trans hB)\n  have hA : ‚àÄ p : Nat.Primes, A p =·µê[Œº] (‚àÖ : Set ùïä) ‚à® A p =·µê[Œº] univ := by\n    rintro ‚ü®p, hp‚ü©\n    let f : ùïä ‚Üí ùïä := fun y => (p : ‚Ñï) ‚Ä¢ y\n    suffices\n      f '' A p ‚äÜ blimsup (fun n => approxAddOrderOf ùïä n (p * Œ¥ n)) atTop fun n => 0 < n ‚àß p‚à§n by\n      apply (ergodic_nsmul hp.one_lt).ae_empty_or_univ_of_image_ae_le (hA‚ÇÄ p).nullMeasurableSet\n      apply (HasSubset.Subset.eventuallyLE this).congr EventuallyEq.rfl\n      exact blimsup_thickening_mul_ae_eq Œº (fun n => 0 < n ‚àß p‚à§n) (fun n => {y | addOrderOf y = n})\n        (Nat.cast_pos.mpr hp.pos) _ hŒ¥\n    refine (sSupHom.setImage f).apply_blimsup_le.trans (mono_blimsup fun n hn => ?_)\n    replace hn := Nat.coprime_comm.mp (hp.coprime_iff_not_dvd.2 hn.2)\n    exact approxAddOrderOf.image_nsmul_subset_of_coprime (Œ¥ n) hp.pos hn\n  have hB : ‚àÄ p : Nat.Primes, B p =·µê[Œº] (‚àÖ : Set ùïä) ‚à® B p =·µê[Œº] univ := by\n    rintro ‚ü®p, hp‚ü©\n    let x := u ‚ü®p, hp‚ü©\n    let f : ùïä ‚Üí ùïä := fun y => p ‚Ä¢ y + x\n    suffices\n      f '' B p ‚äÜ blimsup (fun n => approxAddOrderOf ùïä n (p * Œ¥ n)) atTop fun n => 0 < n ‚àß p‚à£‚à£n by\n      apply (ergodic_nsmul_add x hp.one_lt).ae_empty_or_univ_of_image_ae_le\n        (hB‚ÇÄ p).nullMeasurableSet\n      apply (HasSubset.Subset.eventuallyLE this).congr EventuallyEq.rfl\n      exact blimsup_thickening_mul_ae_eq Œº (fun n => 0 < n ‚àß p‚à£‚à£n) (fun n => {y | addOrderOf y = n})\n        (Nat.cast_pos.mpr hp.pos) _ hŒ¥\n    refine (sSupHom.setImage f).apply_blimsup_le.trans (mono_blimsup ?_)\n    rintro n ‚ü®hn, h_div, h_ndiv‚ü©\n    have h_cop : (addOrderOf x).Coprime (n / p) := by\n      obtain ‚ü®q, rfl‚ü© := h_div\n      rw [hu‚ÇÄ, Subtype.coe_mk, hp.coprime_iff_not_dvd, q.mul_div_cancel_left hp.pos]\n      exact fun contra => h_ndiv (mul_dvd_mul_left p contra)\n    replace h_div : n / p * p = n := Nat.div_mul_cancel h_div\n    have hf : f = (fun y => x + y) ‚àò fun y => p ‚Ä¢ y := by\n      ext; simp [f, add_comm x]\n    simp_rw [Function.comp_apply, le_eq_subset]\n    rw [sSupHom.setImage_toFun, hf, image_comp]\n    have := @monotone_image ùïä ùïä fun y => x + y\n    specialize this (approxAddOrderOf.image_nsmul_subset (Œ¥ n) (n / p) hp.pos)\n    simp only [h_div] at this ‚ä¢\n    refine this.trans ?_\n    convert approxAddOrderOf.vadd_subset_of_coprime (p * Œ¥ n) h_cop\n    rw [hu‚ÇÄ, Subtype.coe_mk, mul_comm p, h_div]\n  change (‚àÄ·µê x, x ‚àâ E) ‚à® E ‚àà ae volume\n  rw [‚Üê eventuallyEq_empty, ‚Üê eventuallyEq_univ]\n  have hC : ‚àÄ p : Nat.Primes, u p +·µ• C p = C p := by\n    intro p\n    let e := (AddAction.toPerm (u p) : Equiv.Perm ùïä).toOrderIsoSet\n    change e (C p) = C p\n    rw [OrderIso.apply_blimsup e, ‚Üê hu‚ÇÄ p]\n    exact blimsup_congr (Eventually.of_forall fun n hn =>\n      approxAddOrderOf.vadd_eq_of_mul_dvd (Œ¥ n) hn.1 hn.2)\n  by_cases h : ‚àÄ p : Nat.Primes, A p =·µê[Œº] (‚àÖ : Set ùïä) ‚àß B p =·µê[Œº] (‚àÖ : Set ùïä)\n  ¬∑ replace h : ‚àÄ p : Nat.Primes, (u p +·µ• E : Set _) =·µê[Œº] E := by\n      intro p\n      replace hE‚ÇÇ : E =·µê[Œº] C p := hE‚ÇÇ p (h p)\n      have h_qmp : Measure.QuasiMeasurePreserving (-u p +·µ• ¬∑) Œº Œº :=\n        (measurePreserving_vadd _ Œº).quasiMeasurePreserving\n      refine (h_qmp.vadd_ae_eq_of_ae_eq (u p) hE‚ÇÇ).trans (ae_eq_trans ?_ hE‚ÇÇ.symm)\n      rw [hC]\n    exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hE‚ÇÄ h hu\n  ¬∑ right\n    simp only [not_forall, not_and_or] at h\n    obtain ‚ü®p, hp‚ü© := h\n    rw [hE‚ÇÅ p]\n    cases hp\n    ¬∑ cases' hA p with _ h; ¬∑ contradiction\n      simp only [Œº, h, union_ae_eq_univ_of_ae_eq_univ_left]\n    ¬∑ cases' hB p with _ h; ¬∑ contradiction\n      simp only [Œº, h, union_ae_eq_univ_of_ae_eq_univ_left,\n        union_ae_eq_univ_of_ae_eq_univ_right]\n\n"}
{"name":"NormedAddCommGroup.exists_norm_nsmul_le","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst‚úù‚Åµ : NormedAddCommGroup A\ninst‚úù‚Å¥ : CompactSpace A\ninst‚úù¬≥ : ConnectedSpace A\ninst‚úù¬≤ : MeasurableSpace A\ninst‚úù¬π : BorelSpace A\nŒº : MeasureTheory.Measure A\ninst‚úù : Œº.IsAddHaarMeasure\nŒæ : A\nn : Nat\nhn : LT.lt 0 n\nŒ¥ : Real\nhŒ¥ : LE.le (Œº Set.univ) (HSMul.hSMul (HAdd.hAdd n 1) (Œº (Metric.closedBall 0 (HDiv.hDiv Œ¥ 2))))\n‚ä¢ Exists fun j => And (Membership.mem (Set.Icc 1 n) j) (LE.le (Norm.norm (HSMul.hSMul j Œæ)) Œ¥)","decl":"/-- A general version of **Dirichlet's approximation theorem**.\n\nSee also `AddCircle.exists_norm_nsmul_le`. -/\nlemma _root_.NormedAddCommGroup.exists_norm_nsmul_le {A : Type*}\n    [NormedAddCommGroup A] [CompactSpace A] [ConnectedSpace A]\n    [MeasurableSpace A] [BorelSpace A] {Œº : Measure A} [Œº.IsAddHaarMeasure]\n    (Œæ : A) {n : ‚Ñï} (hn : 0 < n) (Œ¥ : ‚Ñù) (hŒ¥ : Œº univ ‚â§ (n + 1) ‚Ä¢ Œº (closedBall (0 : A) (Œ¥/2))) :\n    ‚àÉ j ‚àà Icc 1 n, ‚Äñj ‚Ä¢ Œæ‚Äñ ‚â§ Œ¥ := by\n  have : IsFiniteMeasure Œº := CompactSpace.isFiniteMeasure\n  let B : Icc 0 n ‚Üí Set A := fun j ‚Ü¶ closedBall ((j : ‚Ñï) ‚Ä¢ Œæ) (Œ¥/2)\n  have hB : ‚àÄ j, IsClosed (B j) := fun j ‚Ü¶ isClosed_ball\n  suffices ¬¨ Pairwise (Disjoint on B) by\n    obtain ‚ü®i, j, hij, x, hx‚ü© := exists_lt_mem_inter_of_not_pairwise_disjoint this\n    refine ‚ü®j - i, ‚ü®le_tsub_of_add_le_left hij, ?_‚ü©, ?_‚ü©\n    ¬∑ simpa only [tsub_le_iff_right] using j.property.2.trans le_self_add\n    ¬∑ rw [sub_nsmul _ (Subtype.coe_le_coe.mpr hij.le), ‚Üê sub_eq_add_neg, ‚Üê dist_eq_norm]\n      exact (dist_triangle ((j : ‚Ñï) ‚Ä¢ Œæ) x ((i : ‚Ñï) ‚Ä¢ Œæ)).trans (by\n        linarith [mem_closedBall.mp hx.1, mem_closedBall'.mp hx.2])\n  by_contra h\n  apply hn.ne'\n  have h' : ‚ãÉ j, B j = univ := by\n    rw [‚Üê (isClosed_iUnion_of_finite hB).measure_eq_univ_iff_eq (Œº := Œº)]\n    refine le_antisymm (Œº.mono (subset_univ _)) ?_\n    simp_rw [measure_iUnion h (fun _ ‚Ü¶ measurableSet_closedBall), tsum_fintype,\n      B, Œº.addHaar_closedBall_center, Finset.sum_const, Finset.card_univ, Nat.card_fintypeIcc,\n      tsub_zero]\n    exact hŒ¥\n  replace hŒ¥ : 0 ‚â§ Œ¥/2 := by\n    by_contra contra\n    suffices Œº (closedBall 0 (Œ¥/2)) = 0 by\n      apply isOpen_univ.measure_ne_zero Œº univ_nonempty <| le_zero_iff.mp <| le_trans hŒ¥ _\n      simp [this]\n    rw [not_le, ‚Üê closedBall_eq_empty (x := (0 : A))] at contra\n    simp [contra]\n  have h'' : ‚àÄ j, (B j).Nonempty := by intro j; rwa [nonempty_closedBall]\n  simpa using subsingleton_of_disjoint_isClosed_iUnion_eq_univ h'' h hB h'\n\n"}
{"name":"AddCircle.exists_norm_nsmul_le","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nŒæ : AddCircle T\nn : Nat\nhn : LT.lt 0 n\n‚ä¢ Exists fun j => And (Membership.mem (Set.Icc 1 n) j) (LE.le (Norm.norm (HSMul.hSMul j Œæ)) (HDiv.hDiv T ‚Üë(HAdd.hAdd n 1)))","decl":"/-- **Dirichlet's approximation theorem**\n\nSee also `Real.exists_rat_abs_sub_le_and_den_le`. -/\nlemma exists_norm_nsmul_le (Œæ : ùïä) {n : ‚Ñï} (hn : 0 < n) :\n    ‚àÉ j ‚àà Icc 1 n, ‚Äñj ‚Ä¢ Œæ‚Äñ ‚â§ T / ‚Üë(n + 1) := by\n  apply NormedAddCommGroup.exists_norm_nsmul_le (Œº := volume) Œæ hn\n  rw [AddCircle.measure_univ, volume_closedBall, ‚Üê ENNReal.ofReal_nsmul,\n    mul_div_cancel‚ÇÄ _ two_ne_zero, min_eq_right (div_le_self hT.out.le <| by simp), nsmul_eq_mul,\n    mul_div_cancel‚ÇÄ _ (Nat.cast_ne_zero.mpr n.succ_ne_zero)]\n\n"}
