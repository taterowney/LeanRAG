{"name":"mem_approx_add_orderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddGroup A\nn : Nat\nδ : Real\na : A\n⊢ Iff (Membership.mem (approxAddOrderOf A n δ) a) (Exists fun b => And (Eq (addOrderOf b) n) (Membership.mem (Metric.ball b δ) a))","decl":"@[to_additive mem_approx_add_orderOf_iff]\ntheorem mem_approxOrderOf_iff {A : Type*} [SeminormedGroup A] {n : ℕ} {δ : ℝ} {a : A} :\n    a ∈ approxOrderOf A n δ ↔ ∃ b : A, orderOf b = n ∧ a ∈ ball b δ := by\n  simp only [approxOrderOf, thickening_eq_biUnion_ball, mem_iUnion₂, mem_setOf_eq, exists_prop]\n\n"}
{"name":"mem_approxOrderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedGroup A\nn : Nat\nδ : Real\na : A\n⊢ Iff (Membership.mem (approxOrderOf A n δ) a) (Exists fun b => And (Eq (orderOf b) n) (Membership.mem (Metric.ball b δ) a))","decl":"@[to_additive mem_approx_add_orderOf_iff]\ntheorem mem_approxOrderOf_iff {A : Type*} [SeminormedGroup A] {n : ℕ} {δ : ℝ} {a : A} :\n    a ∈ approxOrderOf A n δ ↔ ∃ b : A, orderOf b = n ∧ a ∈ ball b δ := by\n  simp only [approxOrderOf, thickening_eq_biUnion_ball, mem_iUnion₂, mem_setOf_eq, exists_prop]\n\n"}
{"name":"mem_add_wellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddGroup A\nδ : Nat → Real\na : A\n⊢ Iff (Membership.mem (addWellApproximable A δ) a) (Membership.mem (Filter.blimsup (fun n => approxAddOrderOf A n (δ n)) Filter.atTop fun n => LT.lt 0 n) a)","decl":"@[to_additive mem_add_wellApproximable_iff]\ntheorem mem_wellApproximable_iff {A : Type*} [SeminormedGroup A] {δ : ℕ → ℝ} {a : A} :\n    a ∈ wellApproximable A δ ↔\n      a ∈ blimsup (fun n => approxOrderOf A n (δ n)) atTop fun n => 0 < n :=\n  Iff.rfl\n\n"}
{"name":"mem_wellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedGroup A\nδ : Nat → Real\na : A\n⊢ Iff (Membership.mem (wellApproximable A δ) a) (Membership.mem (Filter.blimsup (fun n => approxOrderOf A n (δ n)) Filter.atTop fun n => LT.lt 0 n) a)","decl":"@[to_additive mem_add_wellApproximable_iff]\ntheorem mem_wellApproximable_iff {A : Type*} [SeminormedGroup A] {δ : ℕ → ℝ} {a : A} :\n    a ∈ wellApproximable A δ ↔\n      a ∈ blimsup (fun n => approxOrderOf A n (δ n)) atTop fun n => 0 < n :=\n  Iff.rfl\n\n"}
{"name":"approxOrderOf.image_pow_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedCommGroup A\nm n : Nat\nδ : Real\nhm : LT.lt 0 m\nhmn : n.Coprime m\n⊢ HasSubset.Subset (Set.image (fun y => HPow.hPow y m) (approxOrderOf A n δ)) (approxOrderOf A n (HMul.hMul (↑m) δ))","decl":"@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A n δ ⊆ approxOrderOf A n (m * δ) := by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb, hab⟩ := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ∈ {u : A | orderOf u = n} := by\n    rw [← hb] at hmn ⊢; exact hmn.orderOf_pow\n  apply ball_subset_thickening hb ((m : ℝ) • δ)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n\n"}
{"name":"approxAddOrderOf.image_nsmul_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddCommGroup A\nm n : Nat\nδ : Real\nhm : LT.lt 0 m\nhmn : n.Coprime m\n⊢ HasSubset.Subset (Set.image (fun y => HSMul.hSMul m y) (approxAddOrderOf A n δ)) (approxAddOrderOf A n (HMul.hMul (↑m) δ))","decl":"@[to_additive]\ntheorem image_pow_subset_of_coprime (hm : 0 < m) (hmn : n.Coprime m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A n δ ⊆ approxOrderOf A n (m * δ) := by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb, hab⟩ := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ∈ {u : A | orderOf u = n} := by\n    rw [← hb] at hmn ⊢; exact hmn.orderOf_pow\n  apply ball_subset_thickening hb ((m : ℝ) • δ)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul, Algebra.id.smul_eq_mul]\n\n"}
{"name":"approxOrderOf.image_pow_subset","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedCommGroup A\nm : Nat\nδ : Real\nn : Nat\nhm : LT.lt 0 m\n⊢ HasSubset.Subset (Set.image (fun y => HPow.hPow y m) (approxOrderOf A (HMul.hMul n m) δ)) (approxOrderOf A n (HMul.hMul (↑m) δ))","decl":"@[to_additive]\ntheorem image_pow_subset (n : ℕ) (hm : 0 < m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A (n * m) δ ⊆ approxOrderOf A n (m * δ) := by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb : orderOf b = n * m, hab : a ∈ ball b δ⟩ := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ∈ {y : A | orderOf y = n} := by\n    rw [mem_setOf_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * δ)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul]\n\n"}
{"name":"approxAddOrderOf.image_nsmul_subset","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddCommGroup A\nm : Nat\nδ : Real\nn : Nat\nhm : LT.lt 0 m\n⊢ HasSubset.Subset (Set.image (fun y => HSMul.hSMul m y) (approxAddOrderOf A (HMul.hMul n m) δ)) (approxAddOrderOf A n (HMul.hMul (↑m) δ))","decl":"@[to_additive]\ntheorem image_pow_subset (n : ℕ) (hm : 0 < m) :\n    (fun (y : A) => y ^ m) '' approxOrderOf A (n * m) δ ⊆ approxOrderOf A n (m * δ) := by\n  rintro - ⟨a, ha, rfl⟩\n  obtain ⟨b, hb : orderOf b = n * m, hab : a ∈ ball b δ⟩ := mem_approxOrderOf_iff.mp ha\n  replace hb : b ^ m ∈ {y : A | orderOf y = n} := by\n    rw [mem_setOf_eq, orderOf_pow' b hm.ne', hb, Nat.gcd_mul_left_left, n.mul_div_cancel hm]\n  apply ball_subset_thickening hb (m * δ)\n  convert pow_mem_ball hm hab using 1\n  simp only [nsmul_eq_mul]\n\n"}
{"name":"approxOrderOf.smul_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedCommGroup A\na : A\nn : Nat\nδ : Real\nhan : (orderOf a).Coprime n\n⊢ HasSubset.Subset (HSMul.hSMul a (approxOrderOf A n δ)) (approxOrderOf A (HMul.hMul (orderOf a) n) δ)","decl":"@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :\n    a • approxOrderOf A n δ ⊆ approxOrderOf A (orderOf a * n) δ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ← image_smul, image_iUnion₂, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  refine iUnion₂_subset_iff.mpr fun b hb c hc => ?_\n  simp only [mem_iUnion, exists_prop]\n  refine ⟨a * b, ?_, hc⟩\n  rw [← hb] at han ⊢\n  exact (Commute.all a b).orderOf_mul_eq_mul_orderOf_of_coprime han\n\n"}
{"name":"approxAddOrderOf.vadd_subset_of_coprime","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddCommGroup A\na : A\nn : Nat\nδ : Real\nhan : (addOrderOf a).Coprime n\n⊢ HasSubset.Subset (HVAdd.hVAdd a (approxAddOrderOf A n δ)) (approxAddOrderOf A (HMul.hMul (addOrderOf a) n) δ)","decl":"@[to_additive]\ntheorem smul_subset_of_coprime (han : (orderOf a).Coprime n) :\n    a • approxOrderOf A n δ ⊆ approxOrderOf A (orderOf a * n) δ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ← image_smul, image_iUnion₂, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  refine iUnion₂_subset_iff.mpr fun b hb c hc => ?_\n  simp only [mem_iUnion, exists_prop]\n  refine ⟨a * b, ?_, hc⟩\n  rw [← hb] at han ⊢\n  exact (Commute.all a b).orderOf_mul_eq_mul_orderOf_of_coprime han\n\n"}
{"name":"approxAddOrderOf.vadd_eq_of_mul_dvd","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedAddCommGroup A\na : A\nn : Nat\nδ : Real\nhn : LT.lt 0 n\nhan : Dvd.dvd (HPow.hPow (addOrderOf a) 2) n\n⊢ Eq (HVAdd.hVAdd a (approxAddOrderOf A n δ)) (approxAddOrderOf A n δ)","decl":"@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ∣ n) :\n    a • approxOrderOf A n δ = approxOrderOf A n δ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ← image_smul, image_iUnion₂, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  replace han : ∀ {b : A}, orderOf b = n → orderOf (a * b) = n := by\n    intro b hb\n    rw [← hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).orderOf_mul_eq_right_of_forall_prime_mul_dvd (orderOf_pos_iff.mp hn)\n      fun p _ hp' => dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : {b : A | orderOf b = n} → {b : A | orderOf b = n} := fun b => ⟨a * b, han b.property⟩\n  have hf : Surjective f := by\n    rintro ⟨b, hb⟩\n    refine ⟨⟨a⁻¹ * b, ?_⟩, ?_⟩\n    · rw [mem_setOf_eq, ← orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    · simp only [f, Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [mem_setOf_eq, Subtype.coe_mk, iUnion_coe_set] using\n    hf.iUnion_comp fun b => ball (b : A) δ\n\n"}
{"name":"approxOrderOf.smul_eq_of_mul_dvd","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝ : SeminormedCommGroup A\na : A\nn : Nat\nδ : Real\nhn : LT.lt 0 n\nhan : Dvd.dvd (HPow.hPow (orderOf a) 2) n\n⊢ Eq (HSMul.hSMul a (approxOrderOf A n δ)) (approxOrderOf A n δ)","decl":"@[to_additive vadd_eq_of_mul_dvd]\ntheorem smul_eq_of_mul_dvd (hn : 0 < n) (han : orderOf a ^ 2 ∣ n) :\n    a • approxOrderOf A n δ = approxOrderOf A n δ := by\n  simp_rw [approxOrderOf, thickening_eq_biUnion_ball, ← image_smul, image_iUnion₂, image_smul,\n    smul_ball'', smul_eq_mul, mem_setOf_eq]\n  replace han : ∀ {b : A}, orderOf b = n → orderOf (a * b) = n := by\n    intro b hb\n    rw [← hb] at han hn\n    rw [sq] at han\n    rwa [(Commute.all a b).orderOf_mul_eq_right_of_forall_prime_mul_dvd (orderOf_pos_iff.mp hn)\n      fun p _ hp' => dvd_trans (mul_dvd_mul_right hp' <| orderOf a) han]\n  let f : {b : A | orderOf b = n} → {b : A | orderOf b = n} := fun b => ⟨a * b, han b.property⟩\n  have hf : Surjective f := by\n    rintro ⟨b, hb⟩\n    refine ⟨⟨a⁻¹ * b, ?_⟩, ?_⟩\n    · rw [mem_setOf_eq, ← orderOf_inv, mul_inv_rev, inv_inv, mul_comm]\n      apply han\n      simpa\n    · simp only [f, Subtype.mk_eq_mk, Subtype.coe_mk, mul_inv_cancel_left]\n  simpa only [mem_setOf_eq, Subtype.coe_mk, iUnion_coe_set] using\n    hf.iUnion_comp fun b => ball (b : A) δ\n\n"}
{"name":"UnitAddCircle.mem_approxAddOrderOf_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"δ : Real\nx : UnitAddCircle\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (Membership.mem (approxAddOrderOf UnitAddCircle n δ) x) (Exists fun m => And (LT.lt m n) (And (Eq (GCDMonoid.gcd m n) 1) (LT.lt (Norm.norm (HSub.hSub x ↑(HDiv.hDiv ↑m ↑n))) δ)))","decl":"theorem mem_approxAddOrderOf_iff {δ : ℝ} {x : UnitAddCircle} {n : ℕ} (hn : 0 < n) :\n    x ∈ approxAddOrderOf UnitAddCircle n δ ↔ ∃ m < n, gcd m n = 1 ∧ ‖x - ↑((m : ℝ) / n)‖ < δ := by\n  simp only [mem_approx_add_orderOf_iff, mem_setOf_eq, ball, exists_prop, dist_eq_norm,\n    AddCircle.addOrderOf_eq_pos_iff hn, mul_one]\n  constructor\n  · rintro ⟨y, ⟨m, hm₁, hm₂, rfl⟩, hx⟩; exact ⟨m, hm₁, hm₂, hx⟩\n  · rintro ⟨m, hm₁, hm₂, hx⟩; exact ⟨↑((m : ℝ) / n), ⟨m, hm₁, hm₂, rfl⟩, hx⟩\n\n"}
{"name":"UnitAddCircle.mem_addWellApproximable_iff","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"δ : Nat → Real\nx : UnitAddCircle\n⊢ Iff (Membership.mem (addWellApproximable UnitAddCircle δ) x) (setOf fun n => Exists fun m => And (LT.lt m n) (And (Eq (GCDMonoid.gcd m n) 1) (LT.lt (Norm.norm (HSub.hSub x ↑(HDiv.hDiv ↑m ↑n))) (δ n)))).Infinite","decl":"theorem mem_addWellApproximable_iff (δ : ℕ → ℝ) (x : UnitAddCircle) :\n    x ∈ addWellApproximable UnitAddCircle δ ↔\n      {n : ℕ | ∃ m < n, gcd m n = 1 ∧ ‖x - ↑((m : ℝ) / n)‖ < δ n}.Infinite := by\n  simp only [mem_add_wellApproximable_iff, ← Nat.cofinite_eq_atTop, cofinite.blimsup_set_eq,\n    mem_setOf_eq]\n  refine iff_of_eq (congr_arg Set.Infinite <| ext fun n => ⟨fun hn => ?_, fun hn => ?_⟩)\n  · exact (mem_approxAddOrderOf_iff hn.1).mp hn.2\n  · have h : 0 < n := by obtain ⟨m, hm₁, _, _⟩ := hn; exact pos_of_gt hm₁\n    exact ⟨h, (mem_approxAddOrderOf_iff h).mpr hn⟩\n\n"}
{"name":"AddCircle.addWellApproximable_ae_empty_or_univ","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nδ : Nat → Real\nhδ : Filter.Tendsto δ Filter.atTop (nhds 0)\n⊢ Or (Filter.Eventually (fun x => Not (addWellApproximable (AddCircle T) δ x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)) (Filter.Eventually (fun x => addWellApproximable (AddCircle T) δ x) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume))","decl":"/-- **Gallagher's ergodic theorem** on Diophantine approximation. -/\ntheorem addWellApproximable_ae_empty_or_univ (δ : ℕ → ℝ) (hδ : Tendsto δ atTop (𝓝 0)) :\n    (∀ᵐ x, ¬addWellApproximable 𝕊 δ x) ∨ ∀ᵐ x, addWellApproximable 𝕊 δ x := by\n  /- Sketch of proof:\n\n    Let `E := addWellApproximable 𝕊 δ`. For each prime `p : ℕ`, we can partition `E` into three\n    pieces `E = (A p) ∪ (B p) ∪ (C p)` where:\n      `A p = blimsup (approxAddOrderOf 𝕊 n (δ n)) atTop (fun n => 0 < n ∧ (p ∤ n))`\n      `B p = blimsup (approxAddOrderOf 𝕊 n (δ n)) atTop (fun n => 0 < n ∧ (p ∣∣ n))`\n      `C p = blimsup (approxAddOrderOf 𝕊 n (δ n)) atTop (fun n => 0 < n ∧ (p*p ∣ n))`.\n    In other words, `A p` is the set of points `x` for which there exist infinitely-many `n` such\n    that `x` is within a distance `δ n` of a point of order `n` and `p ∤ n`. Similarly for `B`, `C`.\n\n    These sets have the following key properties:\n      1. `A p` is almost invariant under the ergodic map `y ↦ p • y`\n      2. `B p` is almost invariant under the ergodic map `y ↦ p • y + 1/p`\n      3. `C p` is invariant under the map `y ↦ y + 1/p`\n    To prove 1 and 2 we need the key result `blimsup_thickening_mul_ae_eq` but 3 is elementary.\n\n    It follows from `AddCircle.ergodic_nsmul_add` and `Ergodic.ae_empty_or_univ_of_image_ae_le` that\n    if either `A p` or `B p` is not almost empty for any `p`, then it is almost full and thus so is\n    `E`. We may therefore assume that `A p` and `B p` are almost empty for all `p`. We thus have\n    `E` is almost equal to `C p` for every prime. Combining this with 3 we find that `E` is almost\n    invariant under the map `y ↦ y + 1/p` for every prime `p`. The required result then follows from\n    `AddCircle.ae_empty_or_univ_of_forall_vadd_ae_eq_self`. -/\n  letI : SemilatticeSup Nat.Primes := Nat.Subtype.semilatticeSup _\n  set μ : Measure 𝕊 := volume\n  set u : Nat.Primes → 𝕊 := fun p => ↑((↑(1 : ℕ) : ℝ) / ((p : ℕ) : ℝ) * T)\n  have hu₀ : ∀ p : Nat.Primes, addOrderOf (u p) = (p : ℕ) := by\n    rintro ⟨p, hp⟩; exact addOrderOf_div_of_gcd_eq_one hp.pos (gcd_one_left p)\n  have hu : Tendsto (addOrderOf ∘ u) atTop atTop := by\n    rw [(funext hu₀ : addOrderOf ∘ u = (↑))]\n    have h_mono : Monotone ((↑) : Nat.Primes → ℕ) := fun p q hpq => hpq\n    refine h_mono.tendsto_atTop_atTop fun n => ?_\n    obtain ⟨p, hp, hp'⟩ := n.exists_infinite_primes\n    exact ⟨⟨p, hp'⟩, hp⟩\n  set E := addWellApproximable 𝕊 δ\n  set X : ℕ → Set 𝕊 := fun n => approxAddOrderOf 𝕊 n (δ n)\n  set A : ℕ → Set 𝕊 := fun p => blimsup X atTop fun n => 0 < n ∧ p∤n\n  set B : ℕ → Set 𝕊 := fun p => blimsup X atTop fun n => 0 < n ∧ p∣∣n\n  set C : ℕ → Set 𝕊 := fun p => blimsup X atTop fun n => 0 < n ∧ p ^ 2 ∣ n\n  have hA₀ : ∀ p, MeasurableSet (A p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n _ => isOpen_thickening.measurableSet\n  have hB₀ : ∀ p, MeasurableSet (B p) := fun p =>\n    MeasurableSet.measurableSet_blimsup fun n _ => isOpen_thickening.measurableSet\n  have hE₀ : NullMeasurableSet E μ := by\n    refine (MeasurableSet.measurableSet_blimsup fun n hn =>\n      IsOpen.measurableSet ?_).nullMeasurableSet\n    exact isOpen_thickening\n  have hE₁ : ∀ p, E = A p ∪ B p ∪ C p := by\n    intro p\n    simp only [E, A, B, C, addWellApproximable, ← blimsup_or_eq_sup, ← and_or_left, ← sup_eq_union,\n      sq]\n    congr\n    ext n\n    tauto\n  have hE₂ : ∀ p : Nat.Primes, A p =ᵐ[μ] (∅ : Set 𝕊) ∧ B p =ᵐ[μ] (∅ : Set 𝕊) → E =ᵐ[μ] C p := by\n    rintro p ⟨hA, hB⟩\n    rw [hE₁ p]\n    exact union_ae_eq_right_of_ae_eq_empty ((union_ae_eq_right_of_ae_eq_empty hA).trans hB)\n  have hA : ∀ p : Nat.Primes, A p =ᵐ[μ] (∅ : Set 𝕊) ∨ A p =ᵐ[μ] univ := by\n    rintro ⟨p, hp⟩\n    let f : 𝕊 → 𝕊 := fun y => (p : ℕ) • y\n    suffices\n      f '' A p ⊆ blimsup (fun n => approxAddOrderOf 𝕊 n (p * δ n)) atTop fun n => 0 < n ∧ p∤n by\n      apply (ergodic_nsmul hp.one_lt).ae_empty_or_univ_of_image_ae_le (hA₀ p).nullMeasurableSet\n      apply (HasSubset.Subset.eventuallyLE this).congr EventuallyEq.rfl\n      exact blimsup_thickening_mul_ae_eq μ (fun n => 0 < n ∧ p∤n) (fun n => {y | addOrderOf y = n})\n        (Nat.cast_pos.mpr hp.pos) _ hδ\n    refine (sSupHom.setImage f).apply_blimsup_le.trans (mono_blimsup fun n hn => ?_)\n    replace hn := Nat.coprime_comm.mp (hp.coprime_iff_not_dvd.2 hn.2)\n    exact approxAddOrderOf.image_nsmul_subset_of_coprime (δ n) hp.pos hn\n  have hB : ∀ p : Nat.Primes, B p =ᵐ[μ] (∅ : Set 𝕊) ∨ B p =ᵐ[μ] univ := by\n    rintro ⟨p, hp⟩\n    let x := u ⟨p, hp⟩\n    let f : 𝕊 → 𝕊 := fun y => p • y + x\n    suffices\n      f '' B p ⊆ blimsup (fun n => approxAddOrderOf 𝕊 n (p * δ n)) atTop fun n => 0 < n ∧ p∣∣n by\n      apply (ergodic_nsmul_add x hp.one_lt).ae_empty_or_univ_of_image_ae_le\n        (hB₀ p).nullMeasurableSet\n      apply (HasSubset.Subset.eventuallyLE this).congr EventuallyEq.rfl\n      exact blimsup_thickening_mul_ae_eq μ (fun n => 0 < n ∧ p∣∣n) (fun n => {y | addOrderOf y = n})\n        (Nat.cast_pos.mpr hp.pos) _ hδ\n    refine (sSupHom.setImage f).apply_blimsup_le.trans (mono_blimsup ?_)\n    rintro n ⟨hn, h_div, h_ndiv⟩\n    have h_cop : (addOrderOf x).Coprime (n / p) := by\n      obtain ⟨q, rfl⟩ := h_div\n      rw [hu₀, Subtype.coe_mk, hp.coprime_iff_not_dvd, q.mul_div_cancel_left hp.pos]\n      exact fun contra => h_ndiv (mul_dvd_mul_left p contra)\n    replace h_div : n / p * p = n := Nat.div_mul_cancel h_div\n    have hf : f = (fun y => x + y) ∘ fun y => p • y := by\n      ext; simp [f, add_comm x]\n    simp_rw [Function.comp_apply, le_eq_subset]\n    rw [sSupHom.setImage_toFun, hf, image_comp]\n    have := @monotone_image 𝕊 𝕊 fun y => x + y\n    specialize this (approxAddOrderOf.image_nsmul_subset (δ n) (n / p) hp.pos)\n    simp only [h_div] at this ⊢\n    refine this.trans ?_\n    convert approxAddOrderOf.vadd_subset_of_coprime (p * δ n) h_cop\n    rw [hu₀, Subtype.coe_mk, mul_comm p, h_div]\n  change (∀ᵐ x, x ∉ E) ∨ E ∈ ae volume\n  rw [← eventuallyEq_empty, ← eventuallyEq_univ]\n  have hC : ∀ p : Nat.Primes, u p +ᵥ C p = C p := by\n    intro p\n    let e := (AddAction.toPerm (u p) : Equiv.Perm 𝕊).toOrderIsoSet\n    change e (C p) = C p\n    rw [OrderIso.apply_blimsup e, ← hu₀ p]\n    exact blimsup_congr (Eventually.of_forall fun n hn =>\n      approxAddOrderOf.vadd_eq_of_mul_dvd (δ n) hn.1 hn.2)\n  by_cases h : ∀ p : Nat.Primes, A p =ᵐ[μ] (∅ : Set 𝕊) ∧ B p =ᵐ[μ] (∅ : Set 𝕊)\n  · replace h : ∀ p : Nat.Primes, (u p +ᵥ E : Set _) =ᵐ[μ] E := by\n      intro p\n      replace hE₂ : E =ᵐ[μ] C p := hE₂ p (h p)\n      have h_qmp : Measure.QuasiMeasurePreserving (-u p +ᵥ ·) μ μ :=\n        (measurePreserving_vadd _ μ).quasiMeasurePreserving\n      refine (h_qmp.vadd_ae_eq_of_ae_eq (u p) hE₂).trans (ae_eq_trans ?_ hE₂.symm)\n      rw [hC]\n    exact ae_empty_or_univ_of_forall_vadd_ae_eq_self hE₀ h hu\n  · right\n    simp only [not_forall, not_and_or] at h\n    obtain ⟨p, hp⟩ := h\n    rw [hE₁ p]\n    cases hp\n    · cases' hA p with _ h; · contradiction\n      simp only [μ, h, union_ae_eq_univ_of_ae_eq_univ_left]\n    · cases' hB p with _ h; · contradiction\n      simp only [μ, h, union_ae_eq_univ_of_ae_eq_univ_left,\n        union_ae_eq_univ_of_ae_eq_univ_right]\n\n"}
{"name":"NormedAddCommGroup.exists_norm_nsmul_le","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"A : Type u_1\ninst✝⁵ : NormedAddCommGroup A\ninst✝⁴ : CompactSpace A\ninst✝³ : ConnectedSpace A\ninst✝² : MeasurableSpace A\ninst✝¹ : BorelSpace A\nμ : MeasureTheory.Measure A\ninst✝ : μ.IsAddHaarMeasure\nξ : A\nn : Nat\nhn : LT.lt 0 n\nδ : Real\nhδ : LE.le (μ Set.univ) (HSMul.hSMul (HAdd.hAdd n 1) (μ (Metric.closedBall 0 (HDiv.hDiv δ 2))))\n⊢ Exists fun j => And (Membership.mem (Set.Icc 1 n) j) (LE.le (Norm.norm (HSMul.hSMul j ξ)) δ)","decl":"/-- A general version of **Dirichlet's approximation theorem**.\n\nSee also `AddCircle.exists_norm_nsmul_le`. -/\nlemma _root_.NormedAddCommGroup.exists_norm_nsmul_le {A : Type*}\n    [NormedAddCommGroup A] [CompactSpace A] [ConnectedSpace A]\n    [MeasurableSpace A] [BorelSpace A] {μ : Measure A} [μ.IsAddHaarMeasure]\n    (ξ : A) {n : ℕ} (hn : 0 < n) (δ : ℝ) (hδ : μ univ ≤ (n + 1) • μ (closedBall (0 : A) (δ/2))) :\n    ∃ j ∈ Icc 1 n, ‖j • ξ‖ ≤ δ := by\n  have : IsFiniteMeasure μ := CompactSpace.isFiniteMeasure\n  let B : Icc 0 n → Set A := fun j ↦ closedBall ((j : ℕ) • ξ) (δ/2)\n  have hB : ∀ j, IsClosed (B j) := fun j ↦ isClosed_ball\n  suffices ¬ Pairwise (Disjoint on B) by\n    obtain ⟨i, j, hij, x, hx⟩ := exists_lt_mem_inter_of_not_pairwise_disjoint this\n    refine ⟨j - i, ⟨le_tsub_of_add_le_left hij, ?_⟩, ?_⟩\n    · simpa only [tsub_le_iff_right] using j.property.2.trans le_self_add\n    · rw [sub_nsmul _ (Subtype.coe_le_coe.mpr hij.le), ← sub_eq_add_neg, ← dist_eq_norm]\n      exact (dist_triangle ((j : ℕ) • ξ) x ((i : ℕ) • ξ)).trans (by\n        linarith [mem_closedBall.mp hx.1, mem_closedBall'.mp hx.2])\n  by_contra h\n  apply hn.ne'\n  have h' : ⋃ j, B j = univ := by\n    rw [← (isClosed_iUnion_of_finite hB).measure_eq_univ_iff_eq (μ := μ)]\n    refine le_antisymm (μ.mono (subset_univ _)) ?_\n    simp_rw [measure_iUnion h (fun _ ↦ measurableSet_closedBall), tsum_fintype,\n      B, μ.addHaar_closedBall_center, Finset.sum_const, Finset.card_univ, Nat.card_fintypeIcc,\n      tsub_zero]\n    exact hδ\n  replace hδ : 0 ≤ δ/2 := by\n    by_contra contra\n    suffices μ (closedBall 0 (δ/2)) = 0 by\n      apply isOpen_univ.measure_ne_zero μ univ_nonempty <| le_zero_iff.mp <| le_trans hδ _\n      simp [this]\n    rw [not_le, ← closedBall_eq_empty (x := (0 : A))] at contra\n    simp [contra]\n  have h'' : ∀ j, (B j).Nonempty := by intro j; rwa [nonempty_closedBall]\n  simpa using subsingleton_of_disjoint_isClosed_iUnion_eq_univ h'' h hB h'\n\n"}
{"name":"AddCircle.exists_norm_nsmul_le","module":"Mathlib.NumberTheory.WellApproximable","initialProofState":"T : Real\nhT : Fact (LT.lt 0 T)\nξ : AddCircle T\nn : Nat\nhn : LT.lt 0 n\n⊢ Exists fun j => And (Membership.mem (Set.Icc 1 n) j) (LE.le (Norm.norm (HSMul.hSMul j ξ)) (HDiv.hDiv T ↑(HAdd.hAdd n 1)))","decl":"/-- **Dirichlet's approximation theorem**\n\nSee also `Real.exists_rat_abs_sub_le_and_den_le`. -/\nlemma exists_norm_nsmul_le (ξ : 𝕊) {n : ℕ} (hn : 0 < n) :\n    ∃ j ∈ Icc 1 n, ‖j • ξ‖ ≤ T / ↑(n + 1) := by\n  apply NormedAddCommGroup.exists_norm_nsmul_le (μ := volume) ξ hn\n  rw [AddCircle.measure_univ, volume_closedBall, ← ENNReal.ofReal_nsmul,\n    mul_div_cancel₀ _ two_ne_zero, min_eq_right (div_le_self hT.out.le <| by simp), nsmul_eq_mul,\n    mul_div_cancel₀ _ (Nat.cast_ne_zero.mpr n.succ_ne_zero)]\n\n"}
