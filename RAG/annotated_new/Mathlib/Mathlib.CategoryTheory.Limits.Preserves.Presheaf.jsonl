{"name":"CategoryTheory.Limits.isFiltered_costructuredArrow_yoneda_of_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type v)\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits A\n⊢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)","decl":"/-- If `C` is a finitely cocomplete category and `A : Cᵒᵖ ⥤ Type u` is a presheaf that preserves\nfinite limites, then `CostructuredArrow yoneda A` is filtered.\n\nOne direction of Proposition 3.3.13 of [Kashiwara2006].\n-/\ntheorem isFiltered_costructuredArrow_yoneda_of_preservesFiniteLimits\n    [PreservesFiniteLimits A] : IsFiltered (CostructuredArrow yoneda A) := by\n  suffices IsCofiltered A.Elements from\n    IsFiltered.of_equivalence (CategoryOfElements.costructuredArrowYonedaEquivalence _)\n  suffices HasFiniteLimits A.Elements from IsCofiltered.of_hasFiniteLimits A.Elements\n  exact ⟨fun J _ _ => inferInstance⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_inv_app_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J (Opposite C)\nX✝ : J\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na✝ : ((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchange A K).obj X✝).obj X\n⊢ Eq (((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso A K).inv.app X✝).app X a✝) a✝","decl":"/-- (Implementation) The definition of `functorToInterchange`. -/\n@[simps!]\ndef functorToInterchangeIso : functorToInterchange A K ≅\n    K ⋙ coyoneda ⋙ (whiskeringLeft _ _ _).obj (CostructuredArrow.proj _ _) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso_hom_app_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J (Opposite C)\nX✝ : J\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\na✝ : ((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchange A K).obj X✝).obj X\n⊢ Eq (((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchangeIso A K).hom.app X✝).app X a✝) a✝","decl":"/-- (Implementation) The definition of `functorToInterchange`. -/\n@[simps!]\ndef functorToInterchangeIso : functorToInterchange A K ≅\n    K ⋙ coyoneda ⋙ (whiskeringLeft _ _ _).obj (CostructuredArrow.proj _ _) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_hom_app_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J (Opposite C)\nX✝ : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nX : J\na✝ : ((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchange A K).flip.obj X✝).obj X\n⊢ Eq (((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange A K).hom.app X✝).app X a✝) a✝","decl":"/-- (Implementation) One way to express the flipped version of our functor. We choose this\nassociation because the type of `Presheaf.tautologicalCocone` is\n`Cocone (CostructuredArrow.proj yoneda P ⋙ yoneda)`, so this association will show up in the\nproof.-/\n@[simps!]\ndef flipFunctorToInterchange : (functorToInterchange A K).flip ≅\n    ((CostructuredArrow.proj yoneda A ⋙ yoneda) ⋙ (whiskeringLeft J Cᵒᵖ (Type u)).obj K) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange_inv_app_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝ : CategoryTheory.SmallCategory J\nK : CategoryTheory.Functor J (Opposite C)\nX✝ : CategoryTheory.CostructuredArrow CategoryTheory.yoneda A\nX : J\na✝ : ((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.functorToInterchange A K).flip.obj X✝).obj X\n⊢ Eq (((CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.flipFunctorToInterchange A K).inv.app X✝).app X a✝) a✝","decl":"/-- (Implementation) One way to express the flipped version of our functor. We choose this\nassociation because the type of `Presheaf.tautologicalCocone` is\n`Cocone (CostructuredArrow.proj yoneda P ⋙ yoneda)`, so this association will show up in the\nproof.-/\n@[simps!]\ndef flipFunctorToInterchange : (functorToInterchange A K).flip ≅\n    ((CostructuredArrow.proj yoneda A ⋙ yoneda) ⋙ (whiskeringLeft J Cᵒᵖ (Type u)).obj K) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.isoAux_hom_app","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.SmallCategory C\ninst✝² : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\nK : CategoryTheory.Functor J (Opposite C)\n⊢ Eq (CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.isoAux A K).hom.app fun X => CategoryTheory.CategoryStruct.id (Quiver.Hom (Opposite.unop (CategoryTheory.Limits.limit K)) X.left)","decl":"/-- (Implementation) A natural isomorphism we will need to construct `iso`. -/\n@[simps! (config := { fullyApplied := false }) hom_app]\nnoncomputable def isoAux :\n    (CostructuredArrow.proj yoneda A ⋙ yoneda ⋙ (evaluation Cᵒᵖ (Type u)).obj (limit K)) ≅\n      ((coyoneda ⋙ (whiskeringLeft (CostructuredArrow yoneda A) C (Type u)).obj\n        (CostructuredArrow.proj yoneda A)).obj (limit K)) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.SmallCategory C\ninst✝³ : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝² : CategoryTheory.SmallCategory J\ninst✝¹ : CategoryTheory.FinCategory J\nK : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n⊢ Eq (CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.iso A K).hom (CategoryTheory.Limits.limit.post K A)","decl":"theorem iso_hom [IsFiltered (CostructuredArrow yoneda A)] : (iso A K).hom = limit.post K A := by\n  -- We will have to use `ι_colimitLimitIso_limit_π` eventually, so let's start by\n  -- transforming the goal into something from a colimit to a limit so that we can apply\n  -- `limit.hom_ext` and `colimit.hom_ext`.\n  dsimp [iso, -Iso.app_hom]\n  simp only [Category.assoc]\n  rw [Eq.comm, ← Iso.inv_comp_eq, ← Iso.inv_comp_eq]\n  refine limit.hom_ext (fun j => colimit.hom_ext (fun i => ?_))\n  simp only [Category.assoc]\n\n  -- `simp` is not too helpful here because we will need to apply `NatTrans.comp_app_assoc`\n  -- backwards at certain points, so we rewrite the term manually.\n  rw [HasLimit.isoOfNatIso_hom_π, HasLimit.isoOfNatIso_hom_π_assoc, limit.post_π,\n    colimitObjIsoColimitCompEvaluation_ι_inv_assoc (CostructuredArrow.proj yoneda A ⋙ yoneda),\n    Iso.app_inv, ← NatTrans.comp_app_assoc, colimit.comp_coconePointUniqueUpToIso_inv,\n    Presheaf.tautologicalCocone_ι_app, HasColimit.isoOfNatIso_ι_hom_assoc,\n    HasLimit.isoOfNatIso_hom_π_assoc, HasColimit.isoOfNatIso_ι_hom_assoc,\n    HasColimit.isoOfNatIso_ι_hom_assoc, HasColimit.isoOfNatIso_ι_hom_assoc,\n    ι_colimitLimitIso_limit_π_assoc, isoAux_hom_app, ← NatTrans.comp_app_assoc,\n    ← NatTrans.comp_app_assoc, Category.assoc, HasLimit.isoOfNatIso_hom_π,\n    preservesLimitIso_hom_π_assoc, Iso.symm_hom,\n    ← NatTrans.comp_app_assoc, HasColimit.isoOfNatIso_ι_hom,\n    ← NatTrans.comp_app_assoc, Category.assoc,\n    ι_colimitCompWhiskeringLeftIsoCompColimit_hom,\n    NatTrans.comp_app, Category.assoc, isoWhiskerLeft_hom, NatTrans.comp_app, Category.assoc,\n    ← NatTrans.comp_app, ← whiskerLeft_comp, colimit.comp_coconePointUniqueUpToIso_hom]\n\n  have := i.hom.naturality (limit.π K j)\n  dsimp only [yoneda_obj_obj, Functor.const_obj_obj] at this\n  rw [← this]\n  ext\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteLimitsOfIsFilteredCostructuredArrowYonedaAux.isIso_post","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.SmallCategory C\ninst✝³ : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type u)\nJ : Type\ninst✝² : CategoryTheory.SmallCategory J\ninst✝¹ : CategoryTheory.FinCategory J\nK : CategoryTheory.Functor J (Opposite C)\ninst✝ : CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.limit.post K A)","decl":"theorem isIso_post [IsFiltered (CostructuredArrow yoneda A)] : IsIso (limit.post K A) :=\n  iso_hom A K ▸ inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteLimits_of_isFiltered_costructuredArrow_yoneda","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝² : CategoryTheory.SmallCategory C\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type u)\ninst✝ : CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n⊢ CategoryTheory.Limits.PreservesFiniteLimits A","decl":"/-- If `C` is a small finitely cocomplete category and `A : Cᵒᵖ ⥤ Type u` is a presheaf such that\n`CostructuredArrow yoneda A` is filtered, then `A` preserves finite limits.\n\nOne direction of Proposition 3.3.13 of [Kashiwara2006].\n-/\nlemma preservesFiniteLimits_of_isFiltered_costructuredArrow_yoneda\n    [IsFiltered (CostructuredArrow yoneda A)] : PreservesFiniteLimits A where\n  preservesFiniteLimits _ _ _ := ⟨fun {_} => preservesLimit_of_isIso_post _ _⟩\n\n"}
{"name":"CategoryTheory.Limits.isFiltered_costructuredArrow_yoneda_iff_nonempty_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Presheaf","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.SmallCategory C\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\nA : CategoryTheory.Functor (Opposite C) (Type u)\n⊢ Iff (CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (Nonempty (CategoryTheory.Limits.PreservesFiniteLimits A))","decl":"/-- If `C` is a small finitely cocomplete category and `A : Cᵒᵖ ⥤ Type u` is a presheaf, then\n`CostructuredArrow yoneda A` is filtered if and only if `A` preserves finite limits.\n\nProposition 3.3.13 of [Kashiwara2006].\n-/\ntheorem isFiltered_costructuredArrow_yoneda_iff_nonempty_preservesFiniteLimits :\n    IsFiltered (CostructuredArrow yoneda A) ↔ Nonempty (PreservesFiniteLimits A) :=\n  ⟨fun _ => ⟨preservesFiniteLimits_of_isFiltered_costructuredArrow_yoneda A⟩,\n   fun ⟨_⟩ => isFiltered_costructuredArrow_yoneda_of_preservesFiniteLimits A⟩\n\n"}
