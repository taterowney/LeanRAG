{"name":"List.sum_isAddUnit","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nL : List M\na✝ : ∀ (m : M), Membership.mem L m → IsAddUnit m\n⊢ IsAddUnit L.sum","decl":"@[to_additive]\ntheorem prod_isUnit : ∀ {L : List M}, (∀ m ∈ L, IsUnit m) → IsUnit L.prod\n  | [], _ => by simp\n  | h :: t, u => by\n    simp only [List.prod_cons]\n    exact IsUnit.mul (u h (mem_cons_self h t)) (prod_isUnit fun m mt => u m (mem_cons_of_mem h mt))\n\n"}
{"name":"List.prod_isUnit","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nL : List M\na✝ : ∀ (m : M), Membership.mem L m → IsUnit m\n⊢ IsUnit L.prod","decl":"@[to_additive]\ntheorem prod_isUnit : ∀ {L : List M}, (∀ m ∈ L, IsUnit m) → IsUnit L.prod\n  | [], _ => by simp\n  | h :: t, u => by\n    simp only [List.prod_cons]\n    exact IsUnit.mul (u h (mem_cons_self h t)) (prod_isUnit fun m mt => u m (mem_cons_of_mem h mt))\n\n"}
{"name":"List.sum_isAddUnit_iff","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_8\ninst✝ : AddCommMonoid α\nL : List α\n⊢ Iff (IsAddUnit L.sum) (∀ (m : α), Membership.mem L m → IsAddUnit m)","decl":"@[to_additive]\ntheorem prod_isUnit_iff {α : Type*} [CommMonoid α] {L : List α} :\n    IsUnit L.prod ↔ ∀ m ∈ L, IsUnit m := by\n  refine ⟨fun h => ?_, prod_isUnit⟩\n  induction L with\n  | nil => exact fun m' h' => False.elim (not_mem_nil m' h')\n  | cons m L ih =>\n    rw [prod_cons, IsUnit.mul_iff] at h\n    exact fun m' h' ↦ Or.elim (eq_or_mem_of_mem_cons h') (fun H => H.substr h.1) fun H => ih h.2 _ H\n\n"}
{"name":"List.prod_isUnit_iff","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_8\ninst✝ : CommMonoid α\nL : List α\n⊢ Iff (IsUnit L.prod) (∀ (m : α), Membership.mem L m → IsUnit m)","decl":"@[to_additive]\ntheorem prod_isUnit_iff {α : Type*} [CommMonoid α] {L : List α} :\n    IsUnit L.prod ↔ ∀ m ∈ L, IsUnit m := by\n  refine ⟨fun h => ?_, prod_isUnit⟩\n  induction L with\n  | nil => exact fun m' h' => False.elim (not_mem_nil m' h')\n  | cons m L ih =>\n    rw [prod_cons, IsUnit.mul_iff] at h\n    exact fun m' h' ↦ Or.elim (eq_or_mem_of_mem_cons h') (fun H => H.substr h.1) fun H => ih h.2 _ H\n\n"}
{"name":"List.Perm.sum_eq'","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nl₁ l₂ : List M\nh : l₁.Perm l₂\nhc : List.Pairwise AddCommute l₁\n⊢ Eq l₁.sum l₂.sum","decl":"/-- If elements of a list commute with each other, then their product does not\ndepend on the order of elements. -/\n@[to_additive \"If elements of a list additively commute with each other, then their sum does not\ndepend on the order of elements.\"]\nlemma Perm.prod_eq' (h : l₁ ~ l₂) (hc : l₁.Pairwise Commute) : l₁.prod = l₂.prod := by\n  refine h.foldr_eq' ?_ _\n  apply Pairwise.forall_of_forall\n  · intro x y h z\n    exact (h z).symm\n  · intros; rfl\n  · apply hc.imp\n    intro a b h z\n    rw [← mul_assoc, ← mul_assoc, h]\n\n"}
{"name":"List.Perm.prod_eq'","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl₁ l₂ : List M\nh : l₁.Perm l₂\nhc : List.Pairwise Commute l₁\n⊢ Eq l₁.prod l₂.prod","decl":"/-- If elements of a list commute with each other, then their product does not\ndepend on the order of elements. -/\n@[to_additive \"If elements of a list additively commute with each other, then their sum does not\ndepend on the order of elements.\"]\nlemma Perm.prod_eq' (h : l₁ ~ l₂) (hc : l₁.Pairwise Commute) : l₁.prod = l₂.prod := by\n  refine h.foldr_eq' ?_ _\n  apply Pairwise.forall_of_forall\n  · intro x y h z\n    exact (h z).symm\n  · intros; rfl\n  · apply hc.imp\n    intro a b h z\n    rw [← mul_assoc, ← mul_assoc, h]\n\n"}
{"name":"List.prod_rotate_eq_one_of_prod_eq_one","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"G : Type u_7\ninst✝ : Group G\nl : List G\nx✝ : Eq l.prod 1\nn : Nat\n⊢ Eq (l.rotate n).prod 1","decl":"lemma prod_rotate_eq_one_of_prod_eq_one :\n    ∀ {l : List G} (_ : l.prod = 1) (n : ℕ), (l.rotate n).prod = 1\n  | [], _, _ => by simp\n  | a :: l, hl, n => by\n    have : n % List.length (a :: l) ≤ List.length (a :: l) := le_of_lt (Nat.mod_lt _ (by simp))\n    rw [← List.take_append_drop (n % List.length (a :: l)) (a :: l)] at hl\n    rw [← rotate_mod, rotate_eq_drop_append_take this, List.prod_append, mul_eq_one_iff_inv_eq,\n      ← one_mul (List.prod _)⁻¹, ← hl, List.prod_append, mul_assoc, mul_inv_cancel, mul_one]\n\n"}
{"name":"List.sum_map_count_dedup_filter_eq_countP","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\np : α → Bool\nl : List α\n⊢ Eq (List.map (fun x => List.count x l) (List.filter p l.dedup)).sum (List.countP p l)","decl":"/-- Summing the count of `x` over a list filtered by some `p` is just `countP` applied to `p` -/\ntheorem sum_map_count_dedup_filter_eq_countP (p : α → Bool) (l : List α) :\n    ((l.dedup.filter p).map fun x => l.count x).sum = l.countP p := by\n  induction l with\n  | nil => simp\n  | cons a as h =>\n    simp_rw [List.countP_cons, List.count_cons, List.sum_map_add]\n    congr 1\n    · refine _root_.trans ?_ h\n      by_cases ha : a ∈ as\n      · simp [dedup_cons_of_mem ha]\n      · simp only [dedup_cons_of_not_mem ha, List.filter]\n        match p a with\n        | true => simp only [List.map_cons, List.sum_cons, List.count_eq_zero.2 ha, zero_add]\n        | false => simp only\n    · simp only [beq_iff_eq]\n      by_cases hp : p a\n      · refine _root_.trans (sum_map_eq_nsmul_single a _ fun _ h _ => by simp [h.symm]) ?_\n        simp [hp, count_dedup]\n      · refine _root_.trans (List.sum_eq_zero fun n hn => ?_) (by simp [hp])\n        obtain ⟨a', ha'⟩ := List.mem_map.1 hn\n        split_ifs at ha' with ha\n        · simp only [ha.symm, mem_filter, mem_dedup, find?, mem_cons, true_or, hp,\n            and_false, false_and, reduceCtorEq] at ha'\n        · exact ha'.2.symm\n\n"}
{"name":"List.sum_map_count_dedup_eq_length","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (List.map (fun x => List.count x l) l.dedup).sum l.length","decl":"theorem sum_map_count_dedup_eq_length (l : List α) :\n    (l.dedup.map fun x => l.count x).sum = l.length := by\n  simpa using sum_map_count_dedup_filter_eq_countP (fun _ => True) l\n\n"}
{"name":"List.length_sigma","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\nσ : α → Type u_8\nl₁ : List α\nl₂ : (a : α) → List (σ a)\n⊢ Eq (l₁.sigma l₂).length (List.map (fun a => (l₂ a).length) l₁).sum","decl":"lemma length_sigma {σ : α → Type*} (l₁ : List α) (l₂ : ∀ a, List (σ a)) :\n    length (l₁.sigma l₂) = (l₁.map fun a ↦ length (l₂ a)).sum := by\n  induction' l₁ with x l₁ IH\n  · rfl\n  · simp only [sigma_cons, length_append, length_map, IH, map, sum_cons]\n\n"}
{"name":"List.ranges_flatten","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"l : List Nat\n⊢ Eq l.ranges.flatten (List.range l.sum)","decl":"lemma ranges_flatten : ∀ (l : List ℕ), l.ranges.flatten = range l.sum\n  | [] => rfl\n  | a :: l => by simp [ranges, ← map_flatten, ranges_flatten, range_add]\n\n"}
{"name":"List.ranges_nodup","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"l s : List Nat\nhs : Membership.mem l.ranges s\n⊢ s.Nodup","decl":"/-- The members of `l.ranges` have no duplicate -/\ntheorem ranges_nodup {l s : List ℕ} (hs : s ∈ ranges l) : s.Nodup :=\n  (List.pairwise_flatten.mp <| by rw [ranges_flatten]; exact nodup_range _).1 s hs\n\n"}
{"name":"List.ranges_join","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"l : List Nat\n⊢ Eq l.ranges.flatten (List.range l.sum)","decl":"@[deprecated (since := \"2024-10-15\")] alias ranges_join := ranges_flatten\n\n"}
{"name":"List.mem_mem_ranges_iff_lt_sum","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"l : List Nat\nn : Nat\n⊢ Iff (Exists fun s => And (Membership.mem l.ranges s) (Membership.mem s n)) (LT.lt n l.sum)","decl":"/-- Any entry of any member of `l.ranges` is strictly smaller than `l.sum`. -/\nlemma mem_mem_ranges_iff_lt_sum (l : List ℕ) {n : ℕ} :\n    (∃ s ∈ l.ranges, n ∈ s) ↔ n < l.sum := by\n  rw [← mem_range, ← ranges_flatten, mem_flatten]\n\n"}
{"name":"List.drop_take_succ_flatten_eq_getElem","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\nL : List (List α)\ni : Nat\nh : LT.lt i L.length\n⊢ Eq (List.drop (List.take i (List.map List.length L)).sum (List.take (List.take (HAdd.hAdd i 1) (List.map List.length L)).sum L.flatten)) (GetElem.getElem L i ⋯)","decl":"/-- In a flatten of sublists, taking the slice between the indices `A` and `B - 1` gives back the\noriginal sublist of index `i` if `A` is the sum of the lengths of sublists of index `< i`, and\n`B` is the sum of the lengths of sublists of index `≤ i`. -/\nlemma drop_take_succ_flatten_eq_getElem (L : List (List α)) (i : Nat) (h : i < L.length) :\n    (L.flatten.take ((L.map length).take (i + 1)).sum).drop ((L.map length).take i).sum = L[i] := by\n  have : (L.map length).take i = ((L.take (i + 1)).map length).take i := by\n    simp [map_take, take_take, Nat.min_eq_left]\n  simp only [this, length_map, take_sum_flatten, drop_sum_flatten,\n    drop_take_succ_eq_cons_getElem, h, flatten, append_nil]\n\n"}
{"name":"List.neg_one_mem_of_prod_eq_neg_one","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"l : List Int\nh : Eq l.prod (-1)\n⊢ Membership.mem l (-1)","decl":"/-- If a product of integers is `-1`, then at least one factor must be `-1`. -/\ntheorem neg_one_mem_of_prod_eq_neg_one {l : List ℤ} (h : l.prod = -1) : (-1 : ℤ) ∈ l := by\n  obtain ⟨x, h₁, h₂⟩ := exists_mem_ne_one_of_prod_ne_one (ne_of_eq_of_ne h (by decide))\n  exact Or.resolve_left\n    (Int.isUnit_iff.mp (prod_isUnit_iff.mp\n      (h.symm ▸ ⟨⟨-1, -1, by decide, by decide⟩, rfl⟩ : IsUnit l.prod) x h₁)) h₂ ▸ h₁\n\n"}
{"name":"List.dvd_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\na : M\nl : List M\nha : Membership.mem l a\n⊢ Dvd.dvd a l.prod","decl":"theorem dvd_prod [CommMonoid M] {a} {l : List M} (ha : a ∈ l) : a ∣ l.prod := by\n  let ⟨s, t, h⟩ := append_of_mem ha\n  rw [h, prod_append, prod_cons, mul_left_comm]\n  exact dvd_mul_right _ _\n\n"}
{"name":"List.Sublist.prod_dvd_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\nl₁ l₂ : List M\nh : l₁.Sublist l₂\n⊢ Dvd.dvd l₁.prod l₂.prod","decl":"theorem Sublist.prod_dvd_prod [CommMonoid M] {l₁ l₂ : List M} (h : l₁ <+ l₂) :\n    l₁.prod ∣ l₂.prod := by\n  obtain ⟨l, hl⟩ := h.exists_perm_append\n  rw [hl.prod_eq, prod_append]\n  exact dvd_mul_right _ _\n\n"}
{"name":"List.alternatingSum_append","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : AddCommGroup α\nl₁ l₂ : List α\n⊢ Eq (HAppend.hAppend l₁ l₂).alternatingSum (HAdd.hAdd l₁.alternatingSum (HSMul.hSMul (HPow.hPow (-1) l₁.length) l₂.alternatingSum))","decl":"@[to_additive]\ntheorem alternatingProd_append :\n    ∀ l₁ l₂ : List α,\n      alternatingProd (l₁ ++ l₂) = alternatingProd l₁ * alternatingProd l₂ ^ (-1 : ℤ) ^ length l₁\n  | [], l₂ => by simp\n  | a :: l₁, l₂ => by\n    simp_rw [cons_append, alternatingProd_cons, alternatingProd_append, length_cons, pow_succ',\n      Int.neg_mul, one_mul, zpow_neg, ← div_eq_mul_inv, div_div]\n\n"}
{"name":"List.alternatingProd_append","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : CommGroup α\nl₁ l₂ : List α\n⊢ Eq (HAppend.hAppend l₁ l₂).alternatingProd (HMul.hMul l₁.alternatingProd (HPow.hPow l₂.alternatingProd (HPow.hPow (-1) l₁.length)))","decl":"@[to_additive]\ntheorem alternatingProd_append :\n    ∀ l₁ l₂ : List α,\n      alternatingProd (l₁ ++ l₂) = alternatingProd l₁ * alternatingProd l₂ ^ (-1 : ℤ) ^ length l₁\n  | [], l₂ => by simp\n  | a :: l₁, l₂ => by\n    simp_rw [cons_append, alternatingProd_cons, alternatingProd_append, length_cons, pow_succ',\n      Int.neg_mul, one_mul, zpow_neg, ← div_eq_mul_inv, div_div]\n\n"}
{"name":"List.alternatingSum_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : AddCommGroup α\nl : List α\n⊢ Eq l.reverse.alternatingSum (HSMul.hSMul (HPow.hPow (-1) (HAdd.hAdd l.length 1)) l.alternatingSum)","decl":"@[to_additive]\ntheorem alternatingProd_reverse :\n    ∀ l : List α, alternatingProd (reverse l) = alternatingProd l ^ (-1 : ℤ) ^ (length l + 1)\n  | [] => by simp only [alternatingProd_nil, one_zpow, reverse_nil]\n  | a :: l => by\n    simp_rw [reverse_cons, alternatingProd_append, alternatingProd_reverse,\n      alternatingProd_singleton, alternatingProd_cons, length_reverse, length, pow_succ',\n      Int.neg_mul, one_mul, zpow_neg, inv_inv]\n    rw [mul_comm, ← div_eq_mul_inv, div_zpow]\n\n"}
{"name":"List.alternatingProd_reverse","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"α : Type u_2\ninst✝ : CommGroup α\nl : List α\n⊢ Eq l.reverse.alternatingProd (HPow.hPow l.alternatingProd (HPow.hPow (-1) (HAdd.hAdd l.length 1)))","decl":"@[to_additive]\ntheorem alternatingProd_reverse :\n    ∀ l : List α, alternatingProd (reverse l) = alternatingProd l ^ (-1 : ℤ) ^ (length l + 1)\n  | [] => by simp only [alternatingProd_nil, one_zpow, reverse_nil]\n  | a :: l => by\n    simp_rw [reverse_cons, alternatingProd_append, alternatingProd_reverse,\n      alternatingProd_singleton, alternatingProd_cons, length_reverse, length, pow_succ',\n      Int.neg_mul, one_mul, zpow_neg, inv_inv]\n    rw [mul_comm, ← div_eq_mul_inv, div_zpow]\n\n"}
{"name":"MulOpposite.op_list_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List M\n⊢ Eq (MulOpposite.op l.prod) (List.map MulOpposite.op l).reverse.prod","decl":"lemma op_list_prod : ∀ l : List M, op l.prod = (l.map op).reverse.prod := by\n  intro l; induction l with\n  | nil => rfl\n  | cons x xs ih =>\n    rw [List.prod_cons, List.map_cons, List.reverse_cons', List.prod_concat, op_mul, ih]\n\n"}
{"name":"MulOpposite.unop_list_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nl : List (MulOpposite M)\n⊢ Eq (MulOpposite.unop l.prod) (List.map MulOpposite.unop l).reverse.prod","decl":"lemma unop_list_prod (l : List Mᵐᵒᵖ) : l.prod.unop = (l.map unop).reverse.prod := by\n  rw [← op_inj, op_unop, MulOpposite.op_list_prod, map_reverse, map_map, reverse_reverse,\n    op_comp_unop, map_id]\n\n"}
{"name":"unop_map_list_prod","module":"Mathlib.Algebra.BigOperators.Group.List.Lemmas","initialProofState":"M : Type u_4\nN : Type u_5\ninst✝³ : Monoid M\ninst✝² : Monoid N\nF : Type u_8\ninst✝¹ : FunLike F M (MulOpposite N)\ninst✝ : MonoidHomClass F M (MulOpposite N)\nf : F\nl : List M\n⊢ Eq (MulOpposite.unop (f l.prod)) (List.map (Function.comp MulOpposite.unop ⇑f) l).reverse.prod","decl":"/-- A morphism into the opposite monoid acts on the product by acting on the reversed elements. -/\nlemma unop_map_list_prod {F : Type*} [FunLike F M Nᵐᵒᵖ] [MonoidHomClass F M Nᵐᵒᵖ]\n    (f : F) (l : List M) :\n    (f l.prod).unop = (l.map (MulOpposite.unop ∘ f)).reverse.prod := by\n  rw [map_list_prod f l, MulOpposite.unop_list_prod, List.map_map]\n\n"}
