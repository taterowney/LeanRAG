{"name":"InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\n⊢ Eq (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y))) (HSub.hSub (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))) (HMul.hMul (HMul.hMul (HMul.hMul 2 (Norm.norm x)) (Norm.norm y)) (Real.cos (InnerProductGeometry.angle x y))))","decl":"/-- **Law of cosines** (cosine rule), vector angle form. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle (x y : V) :\n    ‖x - y‖ * ‖x - y‖ = ‖x‖ * ‖x‖ + ‖y‖ * ‖y‖ - 2 * ‖x‖ * ‖y‖ * Real.cos (angle x y) := by\n  rw [show 2 * ‖x‖ * ‖y‖ * Real.cos (angle x y) = 2 * (Real.cos (angle x y) * (‖x‖ * ‖y‖)) by ring,\n    cos_angle_mul_norm_mul_norm, ← real_inner_self_eq_norm_mul_norm, ←\n    real_inner_self_eq_norm_mul_norm, ← real_inner_self_eq_norm_mul_norm, real_inner_sub_sub_self,\n    sub_add_eq_add_sub]\n\n"}
{"name":"InnerProductGeometry.angle_sub_eq_angle_sub_rev_of_norm_eq","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nh : Eq (Norm.norm x) (Norm.norm y)\n⊢ Eq (InnerProductGeometry.angle x (HSub.hSub x y)) (InnerProductGeometry.angle y (HSub.hSub y x))","decl":"/-- **Pons asinorum**, vector angle form. -/\ntheorem angle_sub_eq_angle_sub_rev_of_norm_eq {x y : V} (h : ‖x‖ = ‖y‖) :\n    angle x (x - y) = angle y (y - x) := by\n  refine Real.injOn_cos ⟨angle_nonneg _ _, angle_le_pi _ _⟩ ⟨angle_nonneg _ _, angle_le_pi _ _⟩ ?_\n  rw [cos_angle, cos_angle, h, ← neg_sub, norm_neg, neg_sub, inner_sub_right, inner_sub_right,\n    real_inner_self_eq_norm_mul_norm, real_inner_self_eq_norm_mul_norm, h, real_inner_comm x y]\n\n"}
{"name":"InnerProductGeometry.norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nh : Eq (InnerProductGeometry.angle x (HSub.hSub x y)) (InnerProductGeometry.angle y (HSub.hSub y x))\nhpi : Ne (InnerProductGeometry.angle x y) Real.pi\n⊢ Eq (Norm.norm x) (Norm.norm y)","decl":"/-- **Converse of pons asinorum**, vector angle form. -/\ntheorem norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi {x y : V}\n    (h : angle x (x - y) = angle y (y - x)) (hpi : angle x y ≠ π) : ‖x‖ = ‖y‖ := by\n  replace h := Real.arccos_injOn (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one x (x - y)))\n    (abs_le.mp (abs_real_inner_div_norm_mul_norm_le_one y (y - x))) h\n  by_cases hxy : x = y\n  · rw [hxy]\n  · rw [← norm_neg (y - x), neg_sub, mul_comm, mul_comm ‖y‖, div_eq_mul_inv, div_eq_mul_inv,\n      mul_inv_rev, mul_inv_rev, ← mul_assoc, ← mul_assoc] at h\n    replace h :=\n      mul_right_cancel₀ (inv_ne_zero fun hz => hxy (eq_of_sub_eq_zero (norm_eq_zero.1 hz))) h\n    rw [inner_sub_right, inner_sub_right, real_inner_comm x y, real_inner_self_eq_norm_mul_norm,\n      real_inner_self_eq_norm_mul_norm, mul_sub_right_distrib, mul_sub_right_distrib,\n      mul_self_mul_inv, mul_self_mul_inv, sub_eq_sub_iff_sub_eq_sub, ← mul_sub_left_distrib] at h\n    by_cases hx0 : x = 0\n    · rw [hx0, norm_zero, inner_zero_left, zero_mul, zero_sub, neg_eq_zero] at h\n      rw [hx0, norm_zero, h]\n    · by_cases hy0 : y = 0\n      · rw [hy0, norm_zero, inner_zero_right, zero_mul, sub_zero] at h\n        rw [hy0, norm_zero, h]\n      · rw [inv_sub_inv (fun hz => hx0 (norm_eq_zero.1 hz)) fun hz => hy0 (norm_eq_zero.1 hz), ←\n          neg_sub, ← mul_div_assoc, mul_comm, mul_div_assoc, ← mul_neg_one] at h\n        symm\n        by_contra hyx\n        replace h := (mul_left_cancel₀ (sub_ne_zero_of_ne hyx) h).symm\n        rw [real_inner_div_norm_mul_norm_eq_neg_one_iff, ← angle_eq_pi_iff] at h\n        exact hpi h\n\n"}
{"name":"InnerProductGeometry.cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.cos (HAdd.hAdd (InnerProductGeometry.angle x (HSub.hSub x y)) (InnerProductGeometry.angle y (HSub.hSub y x)))) (Neg.neg (Real.cos (InnerProductGeometry.angle x y)))","decl":"/-- The cosine of the sum of two angles in a possibly degenerate\ntriangle (where two given sides are nonzero), vector angle form. -/\ntheorem cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.cos (angle x (x - y) + angle y (y - x)) = -Real.cos (angle x y) := by\n  by_cases hxy : x = y\n  · rw [hxy, angle_self hy]\n    simp\n  · rw [Real.cos_add, cos_angle, cos_angle, cos_angle]\n    have hxn : ‖x‖ ≠ 0 := fun h => hx (norm_eq_zero.1 h)\n    have hyn : ‖y‖ ≠ 0 := fun h => hy (norm_eq_zero.1 h)\n    have hxyn : ‖x - y‖ ≠ 0 := fun h => hxy (eq_of_sub_eq_zero (norm_eq_zero.1 h))\n    apply mul_right_cancel₀ hxn\n    apply mul_right_cancel₀ hyn\n    apply mul_right_cancel₀ hxyn\n    apply mul_right_cancel₀ hxyn\n    have H1 :\n      Real.sin (angle x (x - y)) * Real.sin (angle y (y - x)) * ‖x‖ * ‖y‖ * ‖x - y‖ * ‖x - y‖ =\n        Real.sin (angle x (x - y)) * (‖x‖ * ‖x - y‖) *\n          (Real.sin (angle y (y - x)) * (‖y‖ * ‖x - y‖)) := by\n      ring\n    have H2 :\n      ⟪x, x⟫ * (⟪x, x⟫ - ⟪x, y⟫ - (⟪x, y⟫ - ⟪y, y⟫)) - (⟪x, x⟫ - ⟪x, y⟫) * (⟪x, x⟫ - ⟪x, y⟫) =\n        ⟪x, x⟫ * ⟪y, y⟫ - ⟪x, y⟫ * ⟪x, y⟫ := by\n      ring\n    have H3 :\n      ⟪y, y⟫ * (⟪y, y⟫ - ⟪x, y⟫ - (⟪x, y⟫ - ⟪x, x⟫)) - (⟪y, y⟫ - ⟪x, y⟫) * (⟪y, y⟫ - ⟪x, y⟫) =\n        ⟪x, x⟫ * ⟪y, y⟫ - ⟪x, y⟫ * ⟪x, y⟫ := by\n      ring\n    rw [mul_sub_right_distrib, mul_sub_right_distrib, mul_sub_right_distrib, mul_sub_right_distrib,\n      H1, sin_angle_mul_norm_mul_norm, norm_sub_rev x y, sin_angle_mul_norm_mul_norm,\n      norm_sub_rev y x, inner_sub_left, inner_sub_left, inner_sub_right, inner_sub_right,\n      inner_sub_right, inner_sub_right, real_inner_comm x y, H2, H3,\n      Real.mul_self_sqrt (sub_nonneg_of_le (real_inner_mul_inner_self_le x y)),\n      real_inner_self_eq_norm_mul_norm, real_inner_self_eq_norm_mul_norm,\n      real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two]\n    -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp [hxn, hyn, hxyn]`, but was really slow\n    -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n    simp (disch := field_simp_discharge) only [sub_div', div_div, mul_div_assoc',\n      div_mul_eq_mul_div, div_sub', neg_div', neg_sub, eq_div_iff, div_eq_iff]\n    ring\n\n"}
{"name":"InnerProductGeometry.sin_angle_sub_add_angle_sub_rev_eq_sin_angle","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.sin (HAdd.hAdd (InnerProductGeometry.angle x (HSub.hSub x y)) (InnerProductGeometry.angle y (HSub.hSub y x)))) (Real.sin (InnerProductGeometry.angle x y))","decl":"/-- The sine of the sum of two angles in a possibly degenerate\ntriangle (where two given sides are nonzero), vector angle form. -/\ntheorem sin_angle_sub_add_angle_sub_rev_eq_sin_angle {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.sin (angle x (x - y) + angle y (y - x)) = Real.sin (angle x y) := by\n  by_cases hxy : x = y\n  · rw [hxy, angle_self hy]\n    simp\n  · rw [Real.sin_add, cos_angle, cos_angle]\n    have hxn : ‖x‖ ≠ 0 := fun h => hx (norm_eq_zero.1 h)\n    have hyn : ‖y‖ ≠ 0 := fun h => hy (norm_eq_zero.1 h)\n    have hxyn : ‖x - y‖ ≠ 0 := fun h => hxy (eq_of_sub_eq_zero (norm_eq_zero.1 h))\n    apply mul_right_cancel₀ hxn\n    apply mul_right_cancel₀ hyn\n    apply mul_right_cancel₀ hxyn\n    apply mul_right_cancel₀ hxyn\n    have H1 :\n      Real.sin (angle x (x - y)) * (⟪y, y - x⟫ / (‖y‖ * ‖y - x‖)) * ‖x‖ * ‖y‖ * ‖x - y‖ =\n        Real.sin (angle x (x - y)) * (‖x‖ * ‖x - y‖) * (⟪y, y - x⟫ / (‖y‖ * ‖y - x‖)) * ‖y‖ := by\n      ring\n    have H2 :\n      ⟪x, x - y⟫ / (‖x‖ * ‖y - x‖) * Real.sin (angle y (y - x)) * ‖x‖ * ‖y‖ * ‖y - x‖ =\n        ⟪x, x - y⟫ / (‖x‖ * ‖y - x‖) * (Real.sin (angle y (y - x)) * (‖y‖ * ‖y - x‖)) * ‖x‖ := by\n      ring\n    have H3 :\n      ⟪x, x⟫ * (⟪x, x⟫ - ⟪x, y⟫ - (⟪x, y⟫ - ⟪y, y⟫)) - (⟪x, x⟫ - ⟪x, y⟫) * (⟪x, x⟫ - ⟪x, y⟫) =\n        ⟪x, x⟫ * ⟪y, y⟫ - ⟪x, y⟫ * ⟪x, y⟫ := by\n      ring\n    have H4 :\n      ⟪y, y⟫ * (⟪y, y⟫ - ⟪x, y⟫ - (⟪x, y⟫ - ⟪x, x⟫)) - (⟪y, y⟫ - ⟪x, y⟫) * (⟪y, y⟫ - ⟪x, y⟫) =\n        ⟪x, x⟫ * ⟪y, y⟫ - ⟪x, y⟫ * ⟪x, y⟫ := by\n      ring\n    rw [right_distrib, right_distrib, right_distrib, right_distrib, H1, sin_angle_mul_norm_mul_norm,\n      norm_sub_rev x y, H2, sin_angle_mul_norm_mul_norm, norm_sub_rev y x,\n      mul_assoc (Real.sin (angle x y)), sin_angle_mul_norm_mul_norm, inner_sub_left, inner_sub_left,\n      inner_sub_right, inner_sub_right, inner_sub_right, inner_sub_right, real_inner_comm x y, H3,\n      H4, real_inner_self_eq_norm_mul_norm, real_inner_self_eq_norm_mul_norm,\n      real_inner_eq_norm_mul_self_add_norm_mul_self_sub_norm_sub_mul_self_div_two]\n    -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp [hxn, hyn, hxyn]`, but was really slow\n    -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n    simp (disch := field_simp_discharge) only [mul_div_assoc', div_mul_eq_mul_div, div_div,\n      sub_div', Real.sqrt_div', Real.sqrt_mul_self, add_div', div_add', eq_div_iff, div_eq_iff]\n    ring\n\n"}
{"name":"InnerProductGeometry.cos_angle_add_angle_sub_add_angle_sub_eq_neg_one","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.cos (HAdd.hAdd (HAdd.hAdd (InnerProductGeometry.angle x y) (InnerProductGeometry.angle x (HSub.hSub x y))) (InnerProductGeometry.angle y (HSub.hSub y x)))) (-1)","decl":"/-- The cosine of the sum of the angles of a possibly degenerate\ntriangle (where two given sides are nonzero), vector angle form. -/\ntheorem cos_angle_add_angle_sub_add_angle_sub_eq_neg_one {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.cos (angle x y + angle x (x - y) + angle y (y - x)) = -1 := by\n  rw [add_assoc, Real.cos_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy,\n    sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy, mul_neg, ← neg_add', add_comm, ← sq, ← sq,\n    Real.sin_sq_add_cos_sq]\n\n"}
{"name":"InnerProductGeometry.sin_angle_add_angle_sub_add_angle_sub_eq_zero","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.sin (HAdd.hAdd (HAdd.hAdd (InnerProductGeometry.angle x y) (InnerProductGeometry.angle x (HSub.hSub x y))) (InnerProductGeometry.angle y (HSub.hSub y x)))) 0","decl":"/-- The sine of the sum of the angles of a possibly degenerate\ntriangle (where two given sides are nonzero), vector angle form. -/\ntheorem sin_angle_add_angle_sub_add_angle_sub_eq_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    Real.sin (angle x y + angle x (x - y) + angle y (y - x)) = 0 := by\n  rw [add_assoc, Real.sin_add, cos_angle_sub_add_angle_sub_rev_eq_neg_cos_angle hx hy,\n    sin_angle_sub_add_angle_sub_rev_eq_sin_angle hx hy]\n  ring\n\n"}
{"name":"InnerProductGeometry.angle_add_angle_sub_add_angle_sub_eq_pi","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nx y : V\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (InnerProductGeometry.angle x y) (InnerProductGeometry.angle x (HSub.hSub x y))) (InnerProductGeometry.angle y (HSub.hSub y x))) Real.pi","decl":"/-- The sum of the angles of a possibly degenerate triangle (where the\ntwo given sides are nonzero), vector angle form. -/\ntheorem angle_add_angle_sub_add_angle_sub_eq_pi {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) :\n    angle x y + angle x (x - y) + angle y (y - x) = π := by\n  have hcos := cos_angle_add_angle_sub_add_angle_sub_eq_neg_one hx hy\n  have hsin := sin_angle_add_angle_sub_add_angle_sub_eq_zero hx hy\n  rw [Real.sin_eq_zero_iff] at hsin\n  cases' hsin with n hn\n  symm at hn\n  have h0 : 0 ≤ angle x y + angle x (x - y) + angle y (y - x) :=\n    add_nonneg (add_nonneg (angle_nonneg _ _) (angle_nonneg _ _)) (angle_nonneg _ _)\n  have h3lt : angle x y + angle x (x - y) + angle y (y - x) < π + π + π := by\n    by_contra hnlt\n    have hxy : angle x y = π := by\n      by_contra hxy\n      exact hnlt (add_lt_add_of_lt_of_le (add_lt_add_of_lt_of_le (lt_of_le_of_ne\n        (angle_le_pi _ _) hxy) (angle_le_pi _ _)) (angle_le_pi _ _))\n    rw [hxy] at hnlt\n    rw [angle_eq_pi_iff] at hxy\n    rcases hxy with ⟨hx, ⟨r, ⟨hr, hxr⟩⟩⟩\n    rw [hxr, ← one_smul ℝ x, ← mul_smul, mul_one, ← sub_smul, one_smul, sub_eq_add_neg,\n      angle_smul_right_of_pos _ _ (add_pos zero_lt_one (neg_pos_of_neg hr)), angle_self hx,\n      add_zero] at hnlt\n    apply hnlt\n    rw [add_assoc]\n    exact add_lt_add_left (lt_of_le_of_lt (angle_le_pi _ _) (lt_add_of_pos_right π Real.pi_pos)) _\n  have hn0 : 0 ≤ n := by\n    rw [hn, mul_nonneg_iff_left_nonneg_of_pos Real.pi_pos] at h0\n    norm_cast at h0\n  have hn3 : n < 3 := by\n    rw [hn, show π + π + π = 3 * π by ring] at h3lt\n    replace h3lt := lt_of_mul_lt_mul_right h3lt (le_of_lt Real.pi_pos)\n    norm_cast at h3lt\n  interval_cases n\n  · simp [hn] at hcos\n  · norm_num [hn]\n  · simp [hn] at hcos\n\n"}
{"name":"EuclideanGeometry.dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\n⊢ Eq (HMul.hMul (Dist.dist p1 p3) (Dist.dist p1 p3)) (HSub.hSub (HAdd.hAdd (HMul.hMul (Dist.dist p1 p2) (Dist.dist p1 p2)) (HMul.hMul (Dist.dist p3 p2) (Dist.dist p3 p2))) (HMul.hMul (HMul.hMul (HMul.hMul 2 (Dist.dist p1 p2)) (Dist.dist p3 p2)) (Real.cos (EuclideanGeometry.angle p1 p2 p3))))","decl":"/-- **Law of cosines** (cosine rule), angle-at-point form. -/\ntheorem dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle (p1 p2 p3 : P) :\n    dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 -\n      2 * dist p1 p2 * dist p3 p2 * Real.cos (∠ p1 p2 p3) := by\n  rw [dist_eq_norm_vsub V p1 p3, dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p3 p2]\n  unfold angle\n  convert norm_sub_sq_eq_norm_sq_add_norm_sq_sub_two_mul_norm_mul_norm_mul_cos_angle\n    (p1 -ᵥ p2 : V) (p3 -ᵥ p2 : V)\n  · exact (vsub_sub_vsub_cancel_right p1 p3 p2).symm\n  · exact (vsub_sub_vsub_cancel_right p1 p3 p2).symm\n\n"}
{"name":"EuclideanGeometry.law_cos","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\n⊢ Eq (HMul.hMul (Dist.dist p1 p3) (Dist.dist p1 p3)) (HSub.hSub (HAdd.hAdd (HMul.hMul (Dist.dist p1 p2) (Dist.dist p1 p2)) (HMul.hMul (Dist.dist p3 p2) (Dist.dist p3 p2))) (HMul.hMul (HMul.hMul (HMul.hMul 2 (Dist.dist p1 p2)) (Dist.dist p3 p2)) (Real.cos (EuclideanGeometry.angle p1 p2 p3))))","decl":"alias law_cos := dist_sq_eq_dist_sq_add_dist_sq_sub_two_mul_dist_mul_dist_mul_cos_angle\n\n"}
{"name":"EuclideanGeometry.angle_eq_angle_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (Dist.dist p1 p2) (Dist.dist p1 p3)\n⊢ Eq (EuclideanGeometry.angle p1 p2 p3) (EuclideanGeometry.angle p1 p3 p2)","decl":"/-- **Isosceles Triangle Theorem**: Pons asinorum, angle-at-point form. -/\ntheorem angle_eq_angle_of_dist_eq {p1 p2 p3 : P} (h : dist p1 p2 = dist p1 p3) :\n    ∠ p1 p2 p3 = ∠ p1 p3 p2 := by\n  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 p3] at h\n  unfold angle\n  convert angle_sub_eq_angle_sub_rev_of_norm_eq h\n  · exact (vsub_sub_vsub_cancel_left p3 p2 p1).symm\n  · exact (vsub_sub_vsub_cancel_left p2 p3 p1).symm\n\n"}
{"name":"EuclideanGeometry.dist_eq_of_angle_eq_angle_of_angle_ne_pi","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) (EuclideanGeometry.angle p1 p3 p2)\nhpi : Ne (EuclideanGeometry.angle p2 p1 p3) Real.pi\n⊢ Eq (Dist.dist p1 p2) (Dist.dist p1 p3)","decl":"/-- Converse of pons asinorum, angle-at-point form. -/\ntheorem dist_eq_of_angle_eq_angle_of_angle_ne_pi {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = ∠ p1 p3 p2)\n    (hpi : ∠ p2 p1 p3 ≠ π) : dist p1 p2 = dist p1 p3 := by\n  unfold angle at h hpi\n  rw [dist_eq_norm_vsub V p1 p2, dist_eq_norm_vsub V p1 p3]\n  rw [← angle_neg_neg, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev] at hpi\n  rw [← vsub_sub_vsub_cancel_left p3 p2 p1, ← vsub_sub_vsub_cancel_left p2 p3 p1] at h\n  exact norm_eq_of_angle_sub_eq_angle_sub_rev_of_angle_ne_pi h hpi\n\n"}
{"name":"EuclideanGeometry.angle_add_angle_add_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh2 : Ne p2 p1\nh3 : Ne p3 p1\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (EuclideanGeometry.angle p1 p2 p3) (EuclideanGeometry.angle p2 p3 p1)) (EuclideanGeometry.angle p3 p1 p2)) Real.pi","decl":"/-- The **sum of the angles of a triangle** (possibly degenerate, where the\ngiven vertex is distinct from the others), angle-at-point. -/\ntheorem angle_add_angle_add_angle_eq_pi {p1 p2 p3 : P} (h2 : p2 ≠ p1) (h3 : p3 ≠ p1) :\n    ∠ p1 p2 p3 + ∠ p2 p3 p1 + ∠ p3 p1 p2 = π := by\n  rw [add_assoc, add_comm, add_comm (∠ p2 p3 p1), angle_comm p2 p3 p1]\n  unfold angle\n  rw [← angle_neg_neg (p1 -ᵥ p3), ← angle_neg_neg (p1 -ᵥ p2), neg_vsub_eq_vsub_rev,\n    neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, neg_vsub_eq_vsub_rev, ←\n    vsub_sub_vsub_cancel_right p3 p2 p1, ← vsub_sub_vsub_cancel_right p2 p3 p1]\n  exact angle_add_angle_sub_add_angle_sub_eq_pi (fun he => h3 (vsub_eq_zero_iff_eq.1 he)) fun he =>\n    h2 (vsub_eq_zero_iff_eq.1 he)\n\n"}
{"name":"EuclideanGeometry.oangle_add_oangle_add_oangle_eq_pi","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ninst✝¹ : Module.Oriented Real V (Fin 2)\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\np1 p2 p3 : P\nh21 : Ne p2 p1\nh32 : Ne p3 p2\nh13 : Ne p1 p3\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (EuclideanGeometry.oangle p1 p2 p3) (EuclideanGeometry.oangle p2 p3 p1)) (EuclideanGeometry.oangle p3 p1 p2)) ↑Real.pi","decl":"/-- The **sum of the angles of a triangle** (possibly degenerate, where the triangle is a line),\noriented angles at point. -/\ntheorem oangle_add_oangle_add_oangle_eq_pi [Module.Oriented ℝ V (Fin 2)]\n    [Fact (Module.finrank ℝ V = 2)] {p1 p2 p3 : P} (h21 : p2 ≠ p1) (h32 : p3 ≠ p2)\n    (h13 : p1 ≠ p3) : ∡ p1 p2 p3 + ∡ p2 p3 p1 + ∡ p3 p1 p2 = π := by\n  simpa only [neg_vsub_eq_vsub_rev] using\n    positiveOrientation.oangle_add_cyc3_neg_left (vsub_ne_zero.mpr h21) (vsub_ne_zero.mpr h32)\n      (vsub_ne_zero.mpr h13)\n\n"}
{"name":"EuclideanGeometry.dist_sq_mul_dist_add_dist_sq_mul_dist","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\na b c p : P\nh : Eq (EuclideanGeometry.angle b p c) Real.pi\n⊢ Eq (HAdd.hAdd (HMul.hMul (HPow.hPow (Dist.dist a b) 2) (Dist.dist c p)) (HMul.hMul (HPow.hPow (Dist.dist a c) 2) (Dist.dist b p))) (HMul.hMul (Dist.dist b c) (HAdd.hAdd (HPow.hPow (Dist.dist a p) 2) (HMul.hMul (Dist.dist b p) (Dist.dist c p))))","decl":"/-- **Stewart's Theorem**. -/\ntheorem dist_sq_mul_dist_add_dist_sq_mul_dist (a b c p : P) (h : ∠ b p c = π) :\n    dist a b ^ 2 * dist c p + dist a c ^ 2 * dist b p =\n    dist b c * (dist a p ^ 2 + dist b p * dist c p) := by\n  rw [pow_two, pow_two, law_cos a p b, law_cos a p c,\n    eq_sub_of_add_eq (angle_add_angle_eq_pi_of_angle_eq_pi a h), Real.cos_pi_sub,\n    dist_eq_add_dist_of_angle_eq_pi h]\n  ring\n\n"}
{"name":"EuclideanGeometry.dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\na b c : P\n⊢ Eq (HAdd.hAdd (HPow.hPow (Dist.dist a b) 2) (HPow.hPow (Dist.dist a c) 2)) (HMul.hMul 2 (HAdd.hAdd (HPow.hPow (Dist.dist a (midpoint Real b c)) 2) (HPow.hPow (HDiv.hDiv (Dist.dist b c) 2) 2)))","decl":"/-- **Apollonius's Theorem**. -/\ntheorem dist_sq_add_dist_sq_eq_two_mul_dist_midpoint_sq_add_half_dist_sq (a b c : P) :\n    dist a b ^ 2 + dist a c ^ 2 = 2 * (dist a (midpoint ℝ b c) ^ 2 + (dist b c / 2) ^ 2) := by\n  by_cases hbc : b = c\n  · simp [hbc, midpoint_self, dist_self, two_mul]\n  · let m := midpoint ℝ b c\n    have : dist b c ≠ 0 := (dist_pos.mpr hbc).ne'\n    have hm := dist_sq_mul_dist_add_dist_sq_mul_dist a b c m (angle_midpoint_eq_pi b c hbc)\n    simp only [m, dist_left_midpoint, dist_right_midpoint, Real.norm_two] at hm\n    calc\n      dist a b ^ 2 + dist a c ^ 2 = 2 / dist b c * (dist a b ^ 2 *\n        ((2 : ℝ)⁻¹ * dist b c) + dist a c ^ 2 * (2⁻¹ * dist b c)) := by\n        -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`, but was really slow\n        -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n        simp (disch := field_simp_discharge) only [inv_eq_one_div, div_mul_eq_mul_div, one_mul,\n          mul_div_assoc', add_div', div_mul_cancel₀, div_div, eq_div_iff]\n        ring\n      _ = 2 * (dist a (midpoint ℝ b c) ^ 2 + (dist b c / 2) ^ 2) := by\n        rw [hm]\n        -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`, but was really slow\n        -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n        simp (disch := field_simp_discharge) only [inv_eq_one_div, div_mul_eq_mul_div, one_mul,\n          mul_div_assoc', div_div, add_div', div_pow, eq_div_iff, div_eq_iff]\n        ring\n\n"}
{"name":"EuclideanGeometry.dist_mul_of_eq_angle_of_dist_mul","module":"Mathlib.Geometry.Euclidean.Triangle","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\na b c a' b' c' : P\nr : Real\nh : Eq (EuclideanGeometry.angle a' b' c') (EuclideanGeometry.angle a b c)\nhab : Eq (Dist.dist a' b') (HMul.hMul r (Dist.dist a b))\nhcb : Eq (Dist.dist c' b') (HMul.hMul r (Dist.dist c b))\n⊢ Eq (Dist.dist a' c') (HMul.hMul r (Dist.dist a c))","decl":"theorem dist_mul_of_eq_angle_of_dist_mul (a b c a' b' c' : P) (r : ℝ) (h : ∠ a' b' c' = ∠ a b c)\n    (hab : dist a' b' = r * dist a b) (hcb : dist c' b' = r * dist c b) :\n    dist a' c' = r * dist a c := by\n  have h' : dist a' c' ^ 2 = (r * dist a c) ^ 2 := calc\n    dist a' c' ^ 2 =\n        dist a' b' ^ 2 + dist c' b' ^ 2 - 2 * dist a' b' * dist c' b' * Real.cos (∠ a' b' c') := by\n      simp [pow_two, law_cos a' b' c']\n    _ = r ^ 2 * (dist a b ^ 2 + dist c b ^ 2 - 2 * dist a b * dist c b * Real.cos (∠ a b c)) := by\n      rw [h, hab, hcb]; ring\n    _ = (r * dist a c) ^ 2 := by simp [pow_two, ← law_cos a b c, mul_pow]; ring\n  by_cases hab₁ : a = b\n  · have hab'₁ : a' = b' := by\n      rw [← dist_eq_zero, hab, dist_eq_zero.mpr hab₁, mul_zero r]\n    rw [hab₁, hab'₁, dist_comm b' c', dist_comm b c, hcb]\n  · have h1 : 0 ≤ r * dist a b := by rw [← hab]; exact dist_nonneg\n    have h2 : 0 ≤ r := nonneg_of_mul_nonneg_left h1 (dist_pos.mpr hab₁)\n    exact (sq_eq_sq₀ dist_nonneg (mul_nonneg h2 dist_nonneg)).mp h'\n\n"}
