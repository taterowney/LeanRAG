{"name":"CategoryTheory.Limits.DiagramOfCones.id","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCones F\nj : J\n⊢ Eq (self.map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (self.obj j)).pt)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : ∀ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (Cones.postcompose (F.map f)).obj (obj j) ⟶ obj j'\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : SizeOf J\ninst✝¹ : SizeOf K\ninst✝ : SizeOf C\nobj : (j : J) → CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map, id := id, comp := comp }) 1","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : ∀ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (Cones.postcompose (F.map f)).obj (obj j) ⟶ obj j'\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.comp","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCones F\nj₁ j₂ j₃ : J\nf : Quiver.Hom j₁ j₂\ng : Quiver.Hom j₂ j₃\n⊢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (self.map f).hom (self.map g).hom)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : ∀ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (Cones.postcompose (F.map f)).obj (obj j) ⟶ obj j'\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobj✝ : (j : J) → CategoryTheory.Limits.Cone (F.obj j)\nmap✝ : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj✝ j)) (obj✝ j')\nid✝ : autoParam (∀ (j : J), Eq (map✝ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj✝ j)).pt)) _auto✝\ncomp✝ : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map✝ f).hom (map✝ g).hom)) _auto✝\nobj : (j : J) → CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\n⊢ Eq (Eq { obj := obj✝, map := map✝, id := id✝, comp := comp✝ } { obj := obj, map := map, id := id, comp := comp }) (And (Eq obj✝ obj) (HEq map✝ map))","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : ∀ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (Cones.postcompose (F.map f)).obj (obj j) ⟶ obj j'\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.inj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobj✝ : (j : J) → CategoryTheory.Limits.Cone (F.obj j)\nmap✝ : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj✝ j)) (obj✝ j')\nid✝ : autoParam (∀ (j : J), Eq (map✝ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj✝ j)).pt)) _auto✝\ncomp✝ : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map✝ f).hom (map✝ g).hom)) _auto✝\nobj : (j : J) → CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\nx✝ : Eq { obj := obj✝, map := map✝, id := id✝, comp := comp✝ } { obj := obj, map := map, id := id, comp := comp }\n⊢ And (Eq obj✝ obj) (HEq map✝ map)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : ∀ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (Cones.postcompose (F.map f)).obj (obj j) ⟶ obj j'\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.inj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobj✝ : (j : J) → CategoryTheory.Limits.Cocone (F.obj j)\nmap✝ : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom (obj✝ j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj✝ j'))\nid✝ : autoParam (∀ (j : J), Eq (map✝ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj✝ j).pt)) _auto✝\ncomp✝ : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map✝ f).hom (map✝ g).hom)) _auto✝\nobj : (j : J) → CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\nx✝ : Eq { obj := obj✝, map := map✝, id := id✝, comp := comp✝ } { obj := obj, map := map, id := id, comp := comp }\n⊢ And (Eq obj✝ obj) (HEq map✝ map)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : ∀ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (obj j) ⟶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.id","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCocones F\nj : J\n⊢ Eq (self.map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (self.obj j).pt)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : ∀ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (obj j) ⟶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : SizeOf J\ninst✝¹ : SizeOf K\ninst✝ : SizeOf C\nobj : (j : J) → CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map, id := id, comp := comp }) 1","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : ∀ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (obj j) ⟶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobj✝ : (j : J) → CategoryTheory.Limits.Cocone (F.obj j)\nmap✝ : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom (obj✝ j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj✝ j'))\nid✝ : autoParam (∀ (j : J), Eq (map✝ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj✝ j).pt)) _auto✝\ncomp✝ : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map✝ f).hom (map✝ g).hom)) _auto✝\nobj : (j : J) → CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} → (f : Quiver.Hom j j') → Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (∀ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _auto✝\ncomp : autoParam (∀ {j₁ j₂ j₃ : J} (f : Quiver.Hom j₁ j₂) (g : Quiver.Hom j₂ j₃), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _auto✝\n⊢ Eq (Eq { obj := obj✝, map := map✝, id := id✝, comp := comp✝ } { obj := obj, map := map, id := id, comp := comp }) (And (Eq obj✝ obj) (HEq map✝ map))","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : ∀ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (obj j) ⟶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.comp","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCocones F\nj₁ j₂ j₃ : J\nf : Quiver.Hom j₁ j₂\ng : Quiver.Hom j₂ j₃\n⊢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (self.map f).hom (self.map g).hom)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : ∀ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : ∀ {j j' : J} (f : j ⟶ j'), (obj j) ⟶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : ∀ j : J, (map (𝟙 j)).hom = 𝟙 _ := by aesop_cat\n  comp : ∀ {j₁ j₂ j₃ : J} (f : j₁ ⟶ j₂) (g : j₂ ⟶ j₃),\n    (map (f ≫ g)).hom = (map f).hom ≫ (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.conePoints_map","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nX✝ Y✝ : J\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (D.conePoints.map f) (D.map f).hom","decl":"/-- Extract the functor `J ⥤ C` consisting of the cone points and the maps between them,\nfrom a `DiagramOfCones`.\n-/\n@[simps]\ndef DiagramOfCones.conePoints (D : DiagramOfCones F) : J ⥤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.conePoints_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nj : J\n⊢ Eq (D.conePoints.obj j) (D.obj j).pt","decl":"/-- Extract the functor `J ⥤ C` consisting of the cone points and the maps between them,\nfrom a `DiagramOfCones`.\n-/\n@[simps]\ndef DiagramOfCones.conePoints (D : DiagramOfCones F) : J ⥤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.coconePoints_map","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nX✝ Y✝ : J\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (D.coconePoints.map f) (D.map f).hom","decl":"/-- Extract the functor `J ⥤ C` consisting of the cocone points and the maps between them,\nfrom a `DiagramOfCocones`.\n-/\n@[simps]\ndef DiagramOfCocones.coconePoints (D : DiagramOfCocones F) : J ⥤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.coconePoints_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nj : J\n⊢ Eq (D.coconePoints.obj j) (D.obj j).pt","decl":"/-- Extract the functor `J ⥤ C` consisting of the cocone points and the maps between them,\nfrom a `DiagramOfCocones`.\n-/\n@[simps]\ndef DiagramOfCocones.coconePoints (D : DiagramOfCocones F) : J ⥤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.coneOfConeUncurry_π_app","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nQ : (j : J) → CategoryTheory.Limits.IsLimit (D.obj j)\nc : CategoryTheory.Limits.Cone (CategoryTheory.uncurry.obj F)\nj : J\n⊢ Eq ((CategoryTheory.Limits.coneOfConeUncurry Q c).π.app j) ((Q j).lift { pt := c.pt, π := { app := fun k => c.π.app { fst := j, snd := k }, naturality := ⋯ } })","decl":"/-- Given a diagram `D` of limit cones over the `F.obj j`, and a cone over `uncurry.obj F`,\nwe can construct a cone over the diagram consisting of the cone points from `D`.\n-/\n@[simps]\ndef coneOfConeUncurry {D : DiagramOfCones F} (Q : ∀ j, IsLimit (D.obj j))\n    (c : Cone (uncurry.obj F)) : Cone D.conePoints where\n  pt := c.pt\n  π :=\n    { app := fun j =>\n        (Q j).lift\n          { pt := c.pt\n            π :=\n              { app := fun k => c.π.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.id_comp]\n                  have := @NatTrans.naturality _ _ _ _ _ _ c.π (j, k) (j, k') (𝟙 j, f)\n                  dsimp at this\n                  simp? at this says\n                    simp only [Category.id_comp, Functor.map_id, NatTrans.id_app] at this\n                  exact this } }\n      naturality := fun j j' f =>\n        (Q j').hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.ConeMorphism.w, Limits.Cones.postcompose_obj_π,\n              Limits.IsLimit.fac_assoc, Limits.IsLimit.fac, NatTrans.comp_app, Category.id_comp,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.π (j, k) (j', k) (f, 𝟙 k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coneOfConeUncurry_pt","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nQ : (j : J) → CategoryTheory.Limits.IsLimit (D.obj j)\nc : CategoryTheory.Limits.Cone (CategoryTheory.uncurry.obj F)\n⊢ Eq (CategoryTheory.Limits.coneOfConeUncurry Q c).pt c.pt","decl":"/-- Given a diagram `D` of limit cones over the `F.obj j`, and a cone over `uncurry.obj F`,\nwe can construct a cone over the diagram consisting of the cone points from `D`.\n-/\n@[simps]\ndef coneOfConeUncurry {D : DiagramOfCones F} (Q : ∀ j, IsLimit (D.obj j))\n    (c : Cone (uncurry.obj F)) : Cone D.conePoints where\n  pt := c.pt\n  π :=\n    { app := fun j =>\n        (Q j).lift\n          { pt := c.pt\n            π :=\n              { app := fun k => c.π.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.id_comp]\n                  have := @NatTrans.naturality _ _ _ _ _ _ c.π (j, k) (j, k') (𝟙 j, f)\n                  dsimp at this\n                  simp? at this says\n                    simp only [Category.id_comp, Functor.map_id, NatTrans.id_app] at this\n                  exact this } }\n      naturality := fun j j' f =>\n        (Q j').hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.ConeMorphism.w, Limits.Cones.postcompose_obj_π,\n              Limits.IsLimit.fac_assoc, Limits.IsLimit.fac, NatTrans.comp_app, Category.id_comp,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.π (j, k) (j', k) (f, 𝟙 k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeUncurry_ι_app","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nQ : (j : J) → CategoryTheory.Limits.IsColimit (D.obj j)\nc : CategoryTheory.Limits.Cocone (CategoryTheory.uncurry.obj F)\nj : J\n⊢ Eq ((CategoryTheory.Limits.coconeOfCoconeUncurry Q c).ι.app j) ((Q j).desc { pt := c.pt, ι := { app := fun k => c.ι.app { fst := j, snd := k }, naturality := ⋯ } })","decl":"/-- Given a diagram `D` of colimit cocones over the `F.obj j`, and a cocone over `uncurry.obj F`,\nwe can construct a cocone over the diagram consisting of the cocone points from `D`.\n-/\n@[simps]\ndef coconeOfCoconeUncurry {D : DiagramOfCocones F} (Q : ∀ j, IsColimit (D.obj j))\n    (c : Cocone (uncurry.obj F)) : Cocone D.coconePoints where\n  pt := c.pt\n  ι :=\n    { app := fun j =>\n        (Q j).desc\n          { pt := c.pt\n            ι :=\n              { app := fun k => c.ι.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.comp_id]\n                  conv_lhs =>\n                    arg 1; equals (F.map (𝟙 _)).app _ ≫  (F.obj j).map f =>\n                      simp\n                  conv_lhs => arg 1; rw [← uncurry_obj_map F ((𝟙 j,f) : (j,k) ⟶ (j,k'))]\n                  rw [c.w] } }\n      naturality := fun j j' f =>\n        (Q j).hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.CoconeMorphism.w_assoc, Limits.Cocones.precompose_obj_ι,\n              Limits.IsColimit.fac_assoc, Limits.IsColimit.fac, NatTrans.comp_app, Category.comp_id,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.ι (j, k) (j', k) (f, 𝟙 k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeUncurry_pt","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nQ : (j : J) → CategoryTheory.Limits.IsColimit (D.obj j)\nc : CategoryTheory.Limits.Cocone (CategoryTheory.uncurry.obj F)\n⊢ Eq (CategoryTheory.Limits.coconeOfCoconeUncurry Q c).pt c.pt","decl":"/-- Given a diagram `D` of colimit cocones over the `F.obj j`, and a cocone over `uncurry.obj F`,\nwe can construct a cocone over the diagram consisting of the cocone points from `D`.\n-/\n@[simps]\ndef coconeOfCoconeUncurry {D : DiagramOfCocones F} (Q : ∀ j, IsColimit (D.obj j))\n    (c : Cocone (uncurry.obj F)) : Cocone D.coconePoints where\n  pt := c.pt\n  ι :=\n    { app := fun j =>\n        (Q j).desc\n          { pt := c.pt\n            ι :=\n              { app := fun k => c.ι.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.comp_id]\n                  conv_lhs =>\n                    arg 1; equals (F.map (𝟙 _)).app _ ≫  (F.obj j).map f =>\n                      simp\n                  conv_lhs => arg 1; rw [← uncurry_obj_map F ((𝟙 j,f) : (j,k) ⟶ (j,k'))]\n                  rw [c.w] } }\n      naturality := fun j j' f =>\n        (Q j).hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.CoconeMorphism.w_assoc, Limits.Cocones.precompose_obj_ι,\n              Limits.IsColimit.fac_assoc, Limits.IsColimit.fac, NatTrans.comp_app, Category.comp_id,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.ι (j, k) (j', k) (f, 𝟙 k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K C\nj : J\n⊢ Eq ((CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).obj j) (CategoryTheory.Limits.limit.cone (F.obj j))","decl":"/-- Given a functor `F : J ⥤ K ⥤ C`, with all needed limits,\nwe can construct a diagram consisting of the limit cone over each functor `F.obj j`,\nand the universal cone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCones.mkOfHasLimits : DiagramOfCones F where\n  obj j := limit.cone (F.obj j)\n  map f := { hom := lim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_map_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K C\nj✝ j'✝ : J\nf : Quiver.Hom j✝ j'✝\n⊢ Eq ((CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).map f).hom (CategoryTheory.Limits.lim.map (F.map f))","decl":"/-- Given a functor `F : J ⥤ K ⥤ C`, with all needed limits,\nwe can construct a diagram consisting of the limit cone over each functor `F.obj j`,\nand the universal cone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCones.mkOfHasLimits : DiagramOfCones F where\n  obj j := limit.cone (F.obj j)\n  map f := { hom := lim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_conePoints","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape K C\n⊢ Eq (CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).conePoints (F.comp CategoryTheory.Limits.lim)","decl":"@[simp]\ntheorem DiagramOfCones.mkOfHasLimits_conePoints :\n    (DiagramOfCones.mkOfHasLimits F).conePoints = F ⋙ lim :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_hom_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π (F.obj j) k))) (CategoryTheory.Limits.limit.π (CategoryTheory.uncurry.obj F) { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_hom_π_π {j} {k} :\n    (limitUncurryIsoLimitCompLim F).hom ≫ limit.π _ j ≫ limit.π _ k = limit.π _ (j, k) := by\n  dsimp [limitUncurryIsoLimitCompLim, IsLimit.conePointUniqueUpToIso, IsLimit.uniqueUpToIso]\n  simp\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_hom_π_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((F.obj j).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_hom_π_π {j} {k} :\n    (limitUncurryIsoLimitCompLim F).hom ≫ limit.π _ j ≫ limit.π _ k = limit.π _ (j, k) := by\n  dsimp [limitUncurryIsoLimitCompLim, IsLimit.conePointUniqueUpToIso, IsLimit.uniqueUpToIso]\n  simp\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_inv_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).inv (CategoryTheory.Limits.limit.π (CategoryTheory.uncurry.obj F) { fst := j, snd := k })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π (F.obj j) k))","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_inv_π {j} {k} :\n    (limitUncurryIsoLimitCompLim F).inv ≫ limit.π _ (j, k) =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  rw [← cancel_epi (limitUncurryIsoLimitCompLim F).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((CategoryTheory.uncurry.obj F).obj { fst := j, snd := k }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_inv_π {j} {k} :\n    (limitUncurryIsoLimitCompLim F).inv ≫ limit.π _ (j, k) =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  rw [← cancel_epi (limitUncurryIsoLimitCompLim F).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_map_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nj✝ j'✝ : J\nf : Quiver.Hom j✝ j'✝\n⊢ Eq ((CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).map f).hom (CategoryTheory.Limits.colim.map (F.map f))","decl":"/-- Given a functor `F : J ⥤ K ⥤ C`, with all needed colimits,\nwe can construct a diagram consisting of the colimit cocone over each functor `F.obj j`,\nand the universal cocone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCocones.mkOfHasColimits : DiagramOfCocones F where\n  obj j := colimit.cocone (F.obj j)\n  map f := { hom := colim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\n⊢ Eq ((CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).obj j) (CategoryTheory.Limits.colimit.cocone (F.obj j))","decl":"/-- Given a functor `F : J ⥤ K ⥤ C`, with all needed colimits,\nwe can construct a diagram consisting of the colimit cocone over each functor `F.obj j`,\nand the universal cocone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCocones.mkOfHasColimits : DiagramOfCocones F where\n  obj j := colimit.cocone (F.obj j)\n  map f := { hom := colim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_coconePoints","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} J\ninst✝² : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_5, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape K C\n⊢ Eq (CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).coconePoints (F.comp CategoryTheory.Limits.colim)","decl":"@[simp]\ntheorem DiagramOfCocones.mkOfHasColimits_coconePoints :\n    (DiagramOfCocones.mkOfHasColimits F).coconePoints = F ⋙ colim :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_ι_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.uncurry.obj F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_ι_ι_inv {j} {k} :\n    colimit.ι (F.obj j) k ≫ colimit.ι (F ⋙ colim) j ≫ (colimitUncurryIsoColimitCompColim F).inv =\n      colimit.ι (uncurry.obj F) (j, k) := by\n  dsimp [colimitUncurryIsoColimitCompColim, IsColimit.coconePointUniqueUpToIso,\n    IsColimit.uniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_ι_ι_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).inv)) (CategoryTheory.Limits.colimit.ι (CategoryTheory.uncurry.obj F) { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_ι_ι_inv {j} {k} :\n    colimit.ι (F.obj j) k ≫ colimit.ι (F ⋙ colim) j ≫ (colimitUncurryIsoColimitCompColim F).inv =\n      colimit.ι (uncurry.obj F) (j, k) := by\n  dsimp [colimitUncurryIsoColimitCompColim, IsColimit.coconePointUniqueUpToIso,\n    IsColimit.uniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_ι_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_ι_hom {j} {k} :\n    colimit.ι _ (j, k) ≫ (colimitUncurryIsoColimitCompColim F).hom =\n      (colimit.ι _ k ≫ colimit.ι (F ⋙ colim) j : _ ⟶ (colimit (F ⋙ colim))) := by\n  rw [← cancel_mono (colimitUncurryIsoColimitCompColim F).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_ι_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.Limits.colim)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_ι_hom {j} {k} :\n    colimit.ι _ (j, k) ≫ (colimitUncurryIsoColimitCompColim F).hom =\n      (colimit.ι _ k ≫ colimit.ι (F ⋙ colim) j : _ ⟶ (colimit (F ⋙ colim))) := by\n  rw [← cancel_mono (colimitUncurryIsoColimitCompColim F).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_hom_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π (F.obj j) k))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.π (F.flip.obj k) j))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_hom_π_π (j) (k) :\n    (limitFlipCompLimIsoLimitCompLim F).hom ≫ limit.π _ j ≫ limit.π _ k =\n      (limit.π _ k ≫ limit.π _ j : limit (_ ⋙ lim) ⟶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp [Equivalence.counit]\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_hom_π_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((F.obj j).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.obj k) j) h))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_hom_π_π (j) (k) :\n    (limitFlipCompLimIsoLimitCompLim F).hom ≫ limit.π _ j ≫ limit.π _ k =\n      (limit.π _ k ≫ limit.π _ j : limit (_ ⋙ lim) ⟶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp [Equivalence.counit]\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_inv_π_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nk : K\nj : J\nZ : C\nh : Quiver.Hom ((F.flip.obj k).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.obj k) j) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_inv_π_π (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv ≫ limit.π _ k ≫ limit.π _ j =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_inv_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nk : K\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.π (F.flip.obj k) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π (F.obj j) k))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_inv_π_π (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv ≫ limit.π _ k ≫ limit.π _ j =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_ι_ι_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.comp CategoryTheory.Limits.colim) k) (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_ι_ι_hom (j) (k) :\n    colimit.ι (F.flip.obj k) j ≫ colimit.ι (F.flip ⋙ colim) k ≫\n      (colimitFlipCompColimIsoColimitCompColim F).hom =\n        (colimit.ι _ k ≫ colimit.ι (F ⋙ colim) j : _ ⟶ colimit (F⋙ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.unit]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_ι_ι_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.Limits.colim)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.comp CategoryTheory.Limits.colim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_ι_ι_hom (j) (k) :\n    colimit.ι (F.flip.obj k) j ≫ colimit.ι (F.flip ⋙ colim) k ≫\n      (colimitFlipCompColimIsoColimitCompColim F).hom =\n        (colimit.ι _ k ≫ colimit.ι (F ⋙ colim) j : _ ⟶ colimit (F⋙ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.unit]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_ι_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nk : K\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.flip.comp CategoryTheory.Limits.colim)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.comp CategoryTheory.Limits.colim) k) h))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_ι_ι_inv (k) (j) :\n    colimit.ι (F.obj j) k ≫ colimit.ι (F ⋙ colim) j ≫\n      (colimitFlipCompColimIsoColimitCompColim F).inv =\n        (colimit.ι _ j ≫ colimit.ι (F.flip ⋙ colim) k : _ ⟶ colimit (F.flip ⋙ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.counitInv]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_ι_ι_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nk : K\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.flip.obj k) j) (CategoryTheory.Limits.colimit.ι (F.flip.comp CategoryTheory.Limits.colim) k))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_ι_ι_inv (k) (j) :\n    colimit.ι (F.obj j) k ≫ colimit.ι (F ⋙ colim) j ≫\n      (colimitFlipCompColimIsoColimitCompColim F).inv =\n        (colimit.ι _ j ≫ colimit.ι (F.flip ⋙ colim) k : _ ⟶ colimit (F.flip ⋙ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.counitInv]\n\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_hom_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k))) (CategoryTheory.Limits.limit.π G { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_hom_π_π {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom ≫ limit.π _ j ≫ limit.π _ k = limit.π _ (j, k) := by\n  simp [limitIsoLimitCurryCompLim, Trans.simple]\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_hom_π_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (((CategoryTheory.curry.obj G).obj j).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_hom_π_π {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom ≫ limit.π _ j ≫ limit.π _ k = limit.π _ (j, k) := by\n  simp [limitIsoLimitCurryCompLim, Trans.simple]\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_inv_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).inv (CategoryTheory.Limits.limit.π G { fst := j, snd := k })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k))","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_inv_π {j} {k} :\n    (limitIsoLimitCurryCompLim G).inv ≫ limit.π _ (j, k) =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  rw [← cancel_epi (limitIsoLimitCurryCompLim G).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (G.obj { fst := j, snd := k }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π G { fst := j, snd := k }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_inv_π {j} {k} :\n    (limitIsoLimitCurryCompLim G).inv ≫ limit.π _ (j, k) =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  rw [← cancel_epi (limitIsoLimitCurryCompLim G).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_ι_ι_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).inv)) (CategoryTheory.Limits.colimit.ι G { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_ι_ι_inv {j} {k} :\n    colimit.ι ((curry.obj G).obj j) k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫\n      (colimitIsoColimitCurryCompColim G).inv  = colimit.ι _ (j, k) := by\n  simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_ι_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_ι_ι_inv {j} {k} :\n    colimit.ι ((curry.obj G).obj j) k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫\n      (colimitIsoColimitCurryCompColim G).inv  = colimit.ι _ (j, k) := by\n  simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_ι_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G { fst := j, snd := k }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_ι_hom {j} {k} :\n    colimit.ι _ (j, k) ≫ (colimitIsoColimitCurryCompColim G).hom =\n      (colimit.ι (_) k ≫ colimit.ι (curry.obj G ⋙ colim) j : _ ⟶ colimit (_ ⋙ colim)) := by\n  rw [← cancel_mono (colimitIsoColimitCurryCompColim G).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_ι_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι G { fst := j, snd := k }) (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_ι_hom {j} {k} :\n    colimit.ι _ (j, k) ≫ (colimitIsoColimitCurryCompColim G).hom =\n      (colimit.ι (_) k ≫ colimit.ι (curry.obj G ⋙ colim) j : _ ⟶ colimit (_ ⋙ colim)) := by\n  rw [← cancel_mono (colimitIsoColimitCurryCompColim G).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝⁴ : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j))","decl":"@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_hom_π_π {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom ≫ limit.π _ j ≫ limit.π _ k =\n      (limit.π _ k ≫ limit.π _ j : limit (_ ⋙ lim) ⟶ _) := by\n  dsimp [limitCurrySwapCompLimIsoLimitCurryCompLim, Equivalence.counit]\n  rw [Category.assoc, Category.assoc, limitIsoLimitCurryCompLim_hom_π_π,\n    HasLimit.isoOfEquivalence_hom_π]\n  dsimp [Equivalence.counit]\n  rw [← prod_id, G.map_id]\n  simp\n\n-- Porting note: Added type annotation `limit (_ ⋙ lim) ⟶ _`\n"}
{"name":"CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_inv_π_π","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝⁴ : CategoryTheory.Limits.HasLimitsOfShape K C\ninst✝³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\ninst✝¹ : CategoryTheory.Limits.HasLimit G\ninst✝ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.π ((CategoryTheory.curry.obj G).obj j) k))","decl":"@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_inv_π_π {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).inv ≫ limit.π _ k ≫ limit.π _ j =\n      (limit.π _ j ≫ limit.π _ k : limit (_ ⋙ lim) ⟶ _) := by\n  simp [limitCurrySwapCompLimIsoLimitCurryCompLim]\n\n"}
{"name":"CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_5, u_1} J\ninst✝⁶ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝⁴ : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.colim) k) (CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim G).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j))","decl":"@[simp]\ntheorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_hom {j} {k} :\n    colimit.ι _ j ≫ colimit.ι (curry.obj (Prod.swap K J ⋙ G) ⋙ colim) k ≫\n      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).hom =\n        (colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j : _ ⟶ colimit (curry.obj G⋙ colim)) := by\n  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]\n  slice_lhs 1 3 => simp only []\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninst✝⁴ : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst✝² : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\ninst✝¹ : CategoryTheory.Limits.HasColimit G\ninst✝ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j) (CategoryTheory.Limits.colimit.ι ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.colim) k))","decl":"@[simp]\ntheorem colimitCurrySwapCompColimIsoColimitCurryCompColim_ι_ι_inv {j} {k} :\n    colimit.ι _ k ≫ colimit.ι (curry.obj G ⋙ colim) j ≫\n      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =\n        (colimit.ι _ j ≫\n          colimit.ι (curry.obj _ ⋙ colim) k :\n            _ ⟶ colimit (curry.obj (Prod.swap K J ⋙ G) ⋙ colim)) := by\n  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]\n  slice_lhs 1 3 => simp only []\n  rw [colimitIsoColimitCurryCompColim_ι_ι_inv, HasColimit.isoOfEquivalence_inv_π]\n  dsimp [Equivalence.counitInv]\n  rw [CategoryTheory.Bifunctor.map_id]\n  simp\n\n"}
