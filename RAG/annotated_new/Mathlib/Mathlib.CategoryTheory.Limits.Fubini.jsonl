{"name":"CategoryTheory.Limits.DiagramOfCones.id","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCones F\nj : J\nâŠ¢ Eq (self.map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (self.obj j)).pt)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : âˆ€ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (Cones.postcompose (F.map f)).obj (obj j) âŸ¶ obj j'\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : SizeOf J\ninstâœÂ¹ : SizeOf K\ninstâœ : SizeOf C\nobj : (j : J) â†’ CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { obj := obj, map := map, id := id, comp := comp }) 1","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : âˆ€ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (Cones.postcompose (F.map f)).obj (obj j) âŸ¶ obj j'\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.comp","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCones F\njâ‚ jâ‚‚ jâ‚ƒ : J\nf : Quiver.Hom jâ‚ jâ‚‚\ng : Quiver.Hom jâ‚‚ jâ‚ƒ\nâŠ¢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (self.map f).hom (self.map g).hom)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : âˆ€ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (Cones.postcompose (F.map f)).obj (obj j) âŸ¶ obj j'\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobjâœ : (j : J) â†’ CategoryTheory.Limits.Cone (F.obj j)\nmapâœ : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (objâœ j)) (objâœ j')\nidâœ : autoParam (âˆ€ (j : J), Eq (mapâœ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (objâœ j)).pt)) _autoâœ\ncompâœ : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (mapâœ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (mapâœ f).hom (mapâœ g).hom)) _autoâœ\nobj : (j : J) â†’ CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nâŠ¢ Eq (Eq { obj := objâœ, map := mapâœ, id := idâœ, comp := compâœ } { obj := obj, map := map, id := id, comp := comp }) (And (Eq objâœ obj) (HEq mapâœ map))","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : âˆ€ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (Cones.postcompose (F.map f)).obj (obj j) âŸ¶ obj j'\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mk.inj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobjâœ : (j : J) â†’ CategoryTheory.Limits.Cone (F.obj j)\nmapâœ : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (objâœ j)) (objâœ j')\nidâœ : autoParam (âˆ€ (j : J), Eq (mapâœ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (objâœ j)).pt)) _autoâœ\ncompâœ : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (mapâœ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (mapâœ f).hom (mapâœ g).hom)) _autoâœ\nobj : (j : J) â†’ CategoryTheory.Limits.Cone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom ((CategoryTheory.Limits.Cones.postcompose (F.map f)).obj (obj j)) (obj j')\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Limits.Cones.postcompose (F.map (CategoryTheory.CategoryStruct.id j))).obj (obj j)).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nxâœ : Eq { obj := objâœ, map := mapâœ, id := idâœ, comp := compâœ } { obj := obj, map := map, id := id, comp := comp }\nâŠ¢ And (Eq objâœ obj) (HEq mapâœ map)","decl":"/-- A structure carrying a diagram of cones over the functors `F.obj j`.\n-/\nstructure DiagramOfCones where\n  /-- For each object, a cone. -/\n  obj : âˆ€ j : J, Cone (F.obj j)\n  /-- For each map, a map of cones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (Cones.postcompose (F.map f)).obj (obj j) âŸ¶ obj j'\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.inj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobjâœ : (j : J) â†’ CategoryTheory.Limits.Cocone (F.obj j)\nmapâœ : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom (objâœ j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (objâœ j'))\nidâœ : autoParam (âˆ€ (j : J), Eq (mapâœ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (objâœ j).pt)) _autoâœ\ncompâœ : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (mapâœ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (mapâœ f).hom (mapâœ g).hom)) _autoâœ\nobj : (j : J) â†’ CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nxâœ : Eq { obj := objâœ, map := mapâœ, id := idâœ, comp := compâœ } { obj := obj, map := map, id := id, comp := comp }\nâŠ¢ And (Eq objâœ obj) (HEq mapâœ map)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : âˆ€ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (obj j) âŸ¶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.id","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCocones F\nj : J\nâŠ¢ Eq (self.map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (self.obj j).pt)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : âˆ€ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (obj j) âŸ¶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_4, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : SizeOf J\ninstâœÂ¹ : SizeOf K\ninstâœ : SizeOf C\nobj : (j : J) â†’ CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { obj := obj, map := map, id := id, comp := comp }) 1","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : âˆ€ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (obj j) âŸ¶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nobjâœ : (j : J) â†’ CategoryTheory.Limits.Cocone (F.obj j)\nmapâœ : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom (objâœ j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (objâœ j'))\nidâœ : autoParam (âˆ€ (j : J), Eq (mapâœ (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (objâœ j).pt)) _autoâœ\ncompâœ : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (mapâœ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (mapâœ f).hom (mapâœ g).hom)) _autoâœ\nobj : (j : J) â†’ CategoryTheory.Limits.Cocone (F.obj j)\nmap : {j j' : J} â†’ (f : Quiver.Hom j j') â†’ Quiver.Hom (obj j) ((CategoryTheory.Limits.Cocones.precompose (F.map f)).obj (obj j'))\nid : autoParam (âˆ€ (j : J), Eq (map (CategoryTheory.CategoryStruct.id j)).hom (CategoryTheory.CategoryStruct.id (obj j).pt)) _autoâœ\ncomp : autoParam (âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : Quiver.Hom jâ‚ jâ‚‚) (g : Quiver.Hom jâ‚‚ jâ‚ƒ), Eq (map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (map f).hom (map g).hom)) _autoâœ\nâŠ¢ Eq (Eq { obj := objâœ, map := mapâœ, id := idâœ, comp := compâœ } { obj := obj, map := map, id := id, comp := comp }) (And (Eq objâœ obj) (HEq mapâœ map))","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : âˆ€ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (obj j) âŸ¶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.comp","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nself : CategoryTheory.Limits.DiagramOfCocones F\njâ‚ jâ‚‚ jâ‚ƒ : J\nf : Quiver.Hom jâ‚ jâ‚‚\ng : Quiver.Hom jâ‚‚ jâ‚ƒ\nâŠ¢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (self.map f).hom (self.map g).hom)","decl":"/-- A structure carrying a diagram of cocones over the functors `F.obj j`.\n-/\nstructure DiagramOfCocones where\n  /-- For each object, a cocone. -/\n  obj : âˆ€ j : J, Cocone (F.obj j)\n  /-- For each map, a map of cocones. -/\n  map : âˆ€ {j j' : J} (f : j âŸ¶ j'), (obj j) âŸ¶ (Cocones.precompose (F.map f)).obj (obj j')\n  id : âˆ€ j : J, (map (ğŸ™ j)).hom = ğŸ™ _ := by aesop_cat\n  comp : âˆ€ {jâ‚ jâ‚‚ jâ‚ƒ : J} (f : jâ‚ âŸ¶ jâ‚‚) (g : jâ‚‚ âŸ¶ jâ‚ƒ),\n    (map (f â‰« g)).hom = (map f).hom â‰« (map g).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.conePoints_map","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nXâœ Yâœ : J\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (D.conePoints.map f) (D.map f).hom","decl":"/-- Extract the functor `J â¥¤ C` consisting of the cone points and the maps between them,\nfrom a `DiagramOfCones`.\n-/\n@[simps]\ndef DiagramOfCones.conePoints (D : DiagramOfCones F) : J â¥¤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.conePoints_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nj : J\nâŠ¢ Eq (D.conePoints.obj j) (D.obj j).pt","decl":"/-- Extract the functor `J â¥¤ C` consisting of the cone points and the maps between them,\nfrom a `DiagramOfCones`.\n-/\n@[simps]\ndef DiagramOfCones.conePoints (D : DiagramOfCones F) : J â¥¤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.coconePoints_map","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nXâœ Yâœ : J\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (D.coconePoints.map f) (D.map f).hom","decl":"/-- Extract the functor `J â¥¤ C` consisting of the cocone points and the maps between them,\nfrom a `DiagramOfCocones`.\n-/\n@[simps]\ndef DiagramOfCocones.coconePoints (D : DiagramOfCocones F) : J â¥¤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.coconePoints_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nj : J\nâŠ¢ Eq (D.coconePoints.obj j) (D.obj j).pt","decl":"/-- Extract the functor `J â¥¤ C` consisting of the cocone points and the maps between them,\nfrom a `DiagramOfCocones`.\n-/\n@[simps]\ndef DiagramOfCocones.coconePoints (D : DiagramOfCocones F) : J â¥¤ C where\n  obj j := (D.obj j).pt\n  map f := (D.map f).hom\n  map_id j := D.id j\n  map_comp f g := D.comp f g\n\n"}
{"name":"CategoryTheory.Limits.coneOfConeUncurry_Ï€_app","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nQ : (j : J) â†’ CategoryTheory.Limits.IsLimit (D.obj j)\nc : CategoryTheory.Limits.Cone (CategoryTheory.uncurry.obj F)\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.coneOfConeUncurry Q c).Ï€.app j) ((Q j).lift { pt := c.pt, Ï€ := { app := fun k => c.Ï€.app { fst := j, snd := k }, naturality := â‹¯ } })","decl":"/-- Given a diagram `D` of limit cones over the `F.obj j`, and a cone over `uncurry.obj F`,\nwe can construct a cone over the diagram consisting of the cone points from `D`.\n-/\n@[simps]\ndef coneOfConeUncurry {D : DiagramOfCones F} (Q : âˆ€ j, IsLimit (D.obj j))\n    (c : Cone (uncurry.obj F)) : Cone D.conePoints where\n  pt := c.pt\n  Ï€ :=\n    { app := fun j =>\n        (Q j).lift\n          { pt := c.pt\n            Ï€ :=\n              { app := fun k => c.Ï€.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.id_comp]\n                  have := @NatTrans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j, k') (ğŸ™ j, f)\n                  dsimp at this\n                  simp? at this says\n                    simp only [Category.id_comp, Functor.map_id, NatTrans.id_app] at this\n                  exact this } }\n      naturality := fun j j' f =>\n        (Q j').hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.ConeMorphism.w, Limits.Cones.postcompose_obj_Ï€,\n              Limits.IsLimit.fac_assoc, Limits.IsLimit.fac, NatTrans.comp_app, Category.id_comp,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j', k) (f, ğŸ™ k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coneOfConeUncurry_pt","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCones F\nQ : (j : J) â†’ CategoryTheory.Limits.IsLimit (D.obj j)\nc : CategoryTheory.Limits.Cone (CategoryTheory.uncurry.obj F)\nâŠ¢ Eq (CategoryTheory.Limits.coneOfConeUncurry Q c).pt c.pt","decl":"/-- Given a diagram `D` of limit cones over the `F.obj j`, and a cone over `uncurry.obj F`,\nwe can construct a cone over the diagram consisting of the cone points from `D`.\n-/\n@[simps]\ndef coneOfConeUncurry {D : DiagramOfCones F} (Q : âˆ€ j, IsLimit (D.obj j))\n    (c : Cone (uncurry.obj F)) : Cone D.conePoints where\n  pt := c.pt\n  Ï€ :=\n    { app := fun j =>\n        (Q j).lift\n          { pt := c.pt\n            Ï€ :=\n              { app := fun k => c.Ï€.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.id_comp]\n                  have := @NatTrans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j, k') (ğŸ™ j, f)\n                  dsimp at this\n                  simp? at this says\n                    simp only [Category.id_comp, Functor.map_id, NatTrans.id_app] at this\n                  exact this } }\n      naturality := fun j j' f =>\n        (Q j').hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.ConeMorphism.w, Limits.Cones.postcompose_obj_Ï€,\n              Limits.IsLimit.fac_assoc, Limits.IsLimit.fac, NatTrans.comp_app, Category.id_comp,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.Ï€ (j, k) (j', k) (f, ğŸ™ k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeUncurry_Î¹_app","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nQ : (j : J) â†’ CategoryTheory.Limits.IsColimit (D.obj j)\nc : CategoryTheory.Limits.Cocone (CategoryTheory.uncurry.obj F)\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.coconeOfCoconeUncurry Q c).Î¹.app j) ((Q j).desc { pt := c.pt, Î¹ := { app := fun k => c.Î¹.app { fst := j, snd := k }, naturality := â‹¯ } })","decl":"/-- Given a diagram `D` of colimit cocones over the `F.obj j`, and a cocone over `uncurry.obj F`,\nwe can construct a cocone over the diagram consisting of the cocone points from `D`.\n-/\n@[simps]\ndef coconeOfCoconeUncurry {D : DiagramOfCocones F} (Q : âˆ€ j, IsColimit (D.obj j))\n    (c : Cocone (uncurry.obj F)) : Cocone D.coconePoints where\n  pt := c.pt\n  Î¹ :=\n    { app := fun j =>\n        (Q j).desc\n          { pt := c.pt\n            Î¹ :=\n              { app := fun k => c.Î¹.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.comp_id]\n                  conv_lhs =>\n                    arg 1; equals (F.map (ğŸ™ _)).app _ â‰«  (F.obj j).map f =>\n                      simp\n                  conv_lhs => arg 1; rw [â† uncurry_obj_map F ((ğŸ™ j,f) : (j,k) âŸ¶ (j,k'))]\n                  rw [c.w] } }\n      naturality := fun j j' f =>\n        (Q j).hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.CoconeMorphism.w_assoc, Limits.Cocones.precompose_obj_Î¹,\n              Limits.IsColimit.fac_assoc, Limits.IsColimit.fac, NatTrans.comp_app, Category.comp_id,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.Î¹ (j, k) (j', k) (f, ğŸ™ k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.coconeOfCoconeUncurry_pt","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ² : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nD : CategoryTheory.Limits.DiagramOfCocones F\nQ : (j : J) â†’ CategoryTheory.Limits.IsColimit (D.obj j)\nc : CategoryTheory.Limits.Cocone (CategoryTheory.uncurry.obj F)\nâŠ¢ Eq (CategoryTheory.Limits.coconeOfCoconeUncurry Q c).pt c.pt","decl":"/-- Given a diagram `D` of colimit cocones over the `F.obj j`, and a cocone over `uncurry.obj F`,\nwe can construct a cocone over the diagram consisting of the cocone points from `D`.\n-/\n@[simps]\ndef coconeOfCoconeUncurry {D : DiagramOfCocones F} (Q : âˆ€ j, IsColimit (D.obj j))\n    (c : Cocone (uncurry.obj F)) : Cocone D.coconePoints where\n  pt := c.pt\n  Î¹ :=\n    { app := fun j =>\n        (Q j).desc\n          { pt := c.pt\n            Î¹ :=\n              { app := fun k => c.Î¹.app (j, k)\n                naturality := fun k k' f => by\n                  dsimp; simp only [Category.comp_id]\n                  conv_lhs =>\n                    arg 1; equals (F.map (ğŸ™ _)).app _ â‰«  (F.obj j).map f =>\n                      simp\n                  conv_lhs => arg 1; rw [â† uncurry_obj_map F ((ğŸ™ j,f) : (j,k) âŸ¶ (j,k'))]\n                  rw [c.w] } }\n      naturality := fun j j' f =>\n        (Q j).hom_ext\n          (by\n            dsimp\n            intro k\n            simp only [Limits.CoconeMorphism.w_assoc, Limits.Cocones.precompose_obj_Î¹,\n              Limits.IsColimit.fac_assoc, Limits.IsColimit.fac, NatTrans.comp_app, Category.comp_id,\n              Category.assoc]\n            have := @NatTrans.naturality _ _ _ _ _ _ c.Î¹ (j, k) (j', k) (f, ğŸ™ k)\n            dsimp at this\n            simp only [Category.id_comp, Category.comp_id, CategoryTheory.Functor.map_id,\n              NatTrans.id_app] at this\n            exact this) }\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape K C\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).obj j) (CategoryTheory.Limits.limit.cone (F.obj j))","decl":"/-- Given a functor `F : J â¥¤ K â¥¤ C`, with all needed limits,\nwe can construct a diagram consisting of the limit cone over each functor `F.obj j`,\nand the universal cone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCones.mkOfHasLimits : DiagramOfCones F where\n  obj j := limit.cone (F.obj j)\n  map f := { hom := lim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_map_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape K C\njâœ j'âœ : J\nf : Quiver.Hom jâœ j'âœ\nâŠ¢ Eq ((CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).map f).hom (CategoryTheory.Limits.lim.map (F.map f))","decl":"/-- Given a functor `F : J â¥¤ K â¥¤ C`, with all needed limits,\nwe can construct a diagram consisting of the limit cone over each functor `F.obj j`,\nand the universal cone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCones.mkOfHasLimits : DiagramOfCones F where\n  obj j := limit.cone (F.obj j)\n  map f := { hom := lim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits_conePoints","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape K C\nâŠ¢ Eq (CategoryTheory.Limits.DiagramOfCones.mkOfHasLimits F).conePoints (F.comp CategoryTheory.Limits.lim)","decl":"@[simp]\ntheorem DiagramOfCones.mkOfHasLimits_conePoints :\n    (DiagramOfCones.mkOfHasLimits F).conePoints = F â‹™ lim :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_hom_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ (F.obj j) k))) (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.uncurry.obj F) { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_hom_Ï€_Ï€ {j} {k} :\n    (limitUncurryIsoLimitCompLim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) := by\n  dsimp [limitUncurryIsoLimitCompLim, IsLimit.conePointUniqueUpToIso, IsLimit.uniqueUpToIso]\n  simp\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_hom_Ï€_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((F.obj j).obj k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_hom_Ï€_Ï€ {j} {k} :\n    (limitUncurryIsoLimitCompLim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) := by\n  dsimp [limitUncurryIsoLimitCompLim, IsLimit.conePointUniqueUpToIso, IsLimit.uniqueUpToIso]\n  simp\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).inv (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.uncurry.obj F) { fst := j, snd := k })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ (F.obj j) k))","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_inv_Ï€ {j} {k} :\n    (limitUncurryIsoLimitCompLim F).inv â‰« limit.Ï€ _ (j, k) =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  rw [â† cancel_epi (limitUncurryIsoLimitCompLim F).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitUncurryIsoLimitCompLim_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasLimit (F.comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((CategoryTheory.uncurry.obj F).obj { fst := j, snd := k }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitUncurryIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitUncurryIsoLimitCompLim_inv_Ï€ {j} {k} :\n    (limitUncurryIsoLimitCompLim F).inv â‰« limit.Ï€ _ (j, k) =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  rw [â† cancel_epi (limitUncurryIsoLimitCompLim F).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_map_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\njâœ j'âœ : J\nf : Quiver.Hom jâœ j'âœ\nâŠ¢ Eq ((CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).map f).hom (CategoryTheory.Limits.colim.map (F.map f))","decl":"/-- Given a functor `F : J â¥¤ K â¥¤ C`, with all needed colimits,\nwe can construct a diagram consisting of the colimit cocone over each functor `F.obj j`,\nand the universal cocone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCocones.mkOfHasColimits : DiagramOfCocones F where\n  obj j := colimit.cocone (F.obj j)\n  map f := { hom := colim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_obj","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_6, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nj : J\nâŠ¢ Eq ((CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).obj j) (CategoryTheory.Limits.colimit.cocone (F.obj j))","decl":"/-- Given a functor `F : J â¥¤ K â¥¤ C`, with all needed colimits,\nwe can construct a diagram consisting of the colimit cocone over each functor `F.obj j`,\nand the universal cocone morphisms between these.\n-/\n@[simps]\nnoncomputable def DiagramOfCocones.mkOfHasColimits : DiagramOfCocones F where\n  obj j := colimit.cocone (F.obj j)\n  map f := { hom := colim.map (F.map f) }\n\n-- Satisfying the inhabited linter.\n"}
{"name":"CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits_coconePoints","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape K C\nâŠ¢ Eq (CategoryTheory.Limits.DiagramOfCocones.mkOfHasColimits F).coconePoints (F.comp CategoryTheory.Limits.colim)","decl":"@[simp]\ntheorem DiagramOfCocones.mkOfHasColimits_coconePoints :\n    (DiagramOfCocones.mkOfHasColimits F).coconePoints = F â‹™ colim :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_Î¹_Î¹_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.uncurry.obj F)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_Î¹_Î¹_inv {j} {k} :\n    colimit.Î¹ (F.obj j) k â‰« colimit.Î¹ (F â‹™ colim) j â‰« (colimitUncurryIsoColimitCompColim F).inv =\n      colimit.Î¹ (uncurry.obj F) (j, k) := by\n  dsimp [colimitUncurryIsoColimitCompColim, IsColimit.coconePointUniqueUpToIso,\n    IsColimit.uniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_Î¹_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).inv)) (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.uncurry.obj F) { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_Î¹_Î¹_inv {j} {k} :\n    colimit.Î¹ (F.obj j) k â‰« colimit.Î¹ (F â‹™ colim) j â‰« (colimitUncurryIsoColimitCompColim F).inv =\n      colimit.Î¹ (uncurry.obj F) (j, k) := by\n  dsimp [colimitUncurryIsoColimitCompColim, IsColimit.coconePointUniqueUpToIso,\n    IsColimit.uniqueUpToIso]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_Î¹_hom {j} {k} :\n    colimit.Î¹ _ (j, k) â‰« (colimitUncurryIsoColimitCompColim F).hom =\n      (colimit.Î¹ _ k â‰« colimit.Î¹ (F â‹™ colim) j : _ âŸ¶ (colimit (F â‹™ colim))) := by\n  rw [â† cancel_mono (colimitUncurryIsoColimitCompColim F).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitUncurryIsoColimitCompColim_Î¹_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit (CategoryTheory.uncurry.obj F)\ninstâœ : CategoryTheory.Limits.HasColimit (F.comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.Limits.colim)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (CategoryTheory.uncurry.obj F) { fst := j, snd := k }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitUncurryIsoColimitCompColim F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitUncurryIsoColimitCompColim_Î¹_hom {j} {k} :\n    colimit.Î¹ _ (j, k) â‰« (colimitUncurryIsoColimitCompColim F).hom =\n      (colimit.Î¹ _ k â‰« colimit.Î¹ (F â‹™ colim) j : _ âŸ¶ (colimit (F â‹™ colim))) := by\n  rw [â† cancel_mono (colimitUncurryIsoColimitCompColim F).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_hom_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ (F.obj j) k))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.Ï€ (F.flip.obj k) j))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_hom_Ï€_Ï€ (j) (k) :\n    (limitFlipCompLimIsoLimitCompLim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k =\n      (limit.Ï€ _ k â‰« limit.Ï€ _ j : limit (_ â‹™ lim) âŸ¶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp [Equivalence.counit]\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_hom_Ï€_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((F.obj j).obj k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.obj k) j) h))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_hom_Ï€_Ï€ (j) (k) :\n    (limitFlipCompLimIsoLimitCompLim F).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k =\n      (limit.Ï€ _ k â‰« limit.Ï€ _ j : limit (_ â‹™ lim) âŸ¶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp [Equivalence.counit]\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n-- See note [dsimp, simp]\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_inv_Ï€_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nk : K\nj : J\nZ : C\nh : Quiver.Hom ((F.flip.obj k).obj j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.obj k) j) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_inv_Ï€_Ï€ (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv â‰« limit.Ï€ _ k â‰« limit.Ï€ _ j =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim_inv_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\nk : K\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitFlipCompLimIsoLimitCompLim F).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.flip.comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.Ï€ (F.flip.obj k) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (F.comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ (F.obj j) k))","decl":"@[simp, reassoc]\ntheorem limitFlipCompLimIsoLimitCompLim_inv_Ï€_Ï€ (k) (j) :\n    (limitFlipCompLimIsoLimitCompLim F).inv â‰« limit.Ï€ _ k â‰« limit.Ï€ _ j =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  dsimp [limitFlipCompLimIsoLimitCompLim]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.comp CategoryTheory.Limits.colim) k) (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_hom (j) (k) :\n    colimit.Î¹ (F.flip.obj k) j â‰« colimit.Î¹ (F.flip â‹™ colim) k â‰«\n      (colimitFlipCompColimIsoColimitCompColim F).hom =\n        (colimit.Î¹ _ k â‰« colimit.Î¹ (F â‹™ colim) j : _ âŸ¶ colimit (Fâ‹™ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.unit]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.Limits.colim)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.comp CategoryTheory.Limits.colim) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_hom (j) (k) :\n    colimit.Î¹ (F.flip.obj k) j â‰« colimit.Î¹ (F.flip â‹™ colim) k â‰«\n      (colimitFlipCompColimIsoColimitCompColim F).hom =\n        (colimit.Î¹ _ k â‰« colimit.Î¹ (F â‹™ colim) j : _ âŸ¶ colimit (Fâ‹™ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.unit]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nk : K\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.flip.comp CategoryTheory.Limits.colim)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.comp CategoryTheory.Limits.colim) k) h))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_inv (k) (j) :\n    colimit.Î¹ (F.obj j) k â‰« colimit.Î¹ (F â‹™ colim) j â‰«\n      (colimitFlipCompColimIsoColimitCompColim F).inv =\n        (colimit.Î¹ _ j â‰« colimit.Î¹ (F.flip â‹™ colim) k : _ âŸ¶ colimit (F.flip â‹™ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.counitInv]\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâµ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape (Prod J K) C\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\nk : K\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitFlipCompColimIsoColimitCompColim F).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (F.flip.obj k) j) (CategoryTheory.Limits.colimit.Î¹ (F.flip.comp CategoryTheory.Limits.colim) k))","decl":"@[simp, reassoc]\ntheorem colimitFlipCompColimIsoColimitCompColim_Î¹_Î¹_inv (k) (j) :\n    colimit.Î¹ (F.obj j) k â‰« colimit.Î¹ (F â‹™ colim) j â‰«\n      (colimitFlipCompColimIsoColimitCompColim F).inv =\n        (colimit.Î¹ _ j â‰« colimit.Î¹ (F.flip â‹™ colim) k : _ âŸ¶ colimit (F.flip â‹™ colim)) := by\n  dsimp [colimitFlipCompColimIsoColimitCompColim]\n  slice_lhs 1 3 => simp only []\n  simp [Equivalence.counitInv]\n\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_hom_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k))) (CategoryTheory.Limits.limit.Ï€ G { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_hom_Ï€_Ï€ {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) := by\n  simp [limitIsoLimitCurryCompLim, Trans.simple]\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_hom_Ï€_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (((CategoryTheory.curry.obj G).obj j).obj k) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_hom_Ï€_Ï€ {j} {k} :\n    (limitIsoLimitCurryCompLim G).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k = limit.Ï€ _ (j, k) := by\n  simp [limitIsoLimitCurryCompLim, Trans.simple]\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).inv (CategoryTheory.Limits.limit.Ï€ G { fst := j, snd := k })) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k))","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_inv_Ï€ {j} {k} :\n    (limitIsoLimitCurryCompLim G).inv â‰« limit.Ï€ _ (j, k) =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  rw [â† cancel_epi (limitIsoLimitCurryCompLim G).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitIsoLimitCurryCompLim_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (G.obj { fst := j, snd := k }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitIsoLimitCurryCompLim G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ G { fst := j, snd := k }) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k) h))","decl":"@[simp, reassoc]\ntheorem limitIsoLimitCurryCompLim_inv_Ï€ {j} {k} :\n    (limitIsoLimitCurryCompLim G).inv â‰« limit.Ï€ _ (j, k) =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  rw [â† cancel_epi (limitIsoLimitCurryCompLim G).hom]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_Î¹_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).inv)) (CategoryTheory.Limits.colimit.Î¹ G { fst := j, snd := k })","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_Î¹_Î¹_inv {j} {k} :\n    colimit.Î¹ ((curry.obj G).obj j) k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j â‰«\n      (colimitIsoColimitCurryCompColim G).inv  = colimit.Î¹ _ (j, k) := by\n  simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_Î¹_Î¹_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit G) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).inv h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G { fst := j, snd := k }) h)","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_Î¹_Î¹_inv {j} {k} :\n    colimit.Î¹ ((curry.obj G).obj j) k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j â‰«\n      (colimitIsoColimitCurryCompColim G).inv  = colimit.Î¹ _ (j, k) := by\n  simp [colimitIsoColimitCurryCompColim, Trans.simple, colimitUncurryIsoColimitCompColim]\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_Î¹_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G { fst := j, snd := k }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) h))","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_Î¹_hom {j} {k} :\n    colimit.Î¹ _ (j, k) â‰« (colimitIsoColimitCurryCompColim G).hom =\n      (colimit.Î¹ (_) k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j : _ âŸ¶ colimit (_ â‹™ colim)) := by\n  rw [â† cancel_mono (colimitIsoColimitCurryCompColim G).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoColimitCurryCompColim_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ G { fst := j, snd := k }) (CategoryTheory.Limits.colimitIsoColimitCurryCompColim G).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j))","decl":"@[simp, reassoc]\ntheorem colimitIsoColimitCurryCompColim_Î¹_hom {j} {k} :\n    colimit.Î¹ _ (j, k) â‰« (colimitIsoColimitCurryCompColim G).hom =\n      (colimit.Î¹ (_) k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j : _ âŸ¶ colimit (_ â‹™ colim)) := by\n  rw [â† cancel_mono (colimitIsoColimitCurryCompColim G).inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_hom_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœâ´ : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j))","decl":"@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_hom_Ï€_Ï€ {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).hom â‰« limit.Ï€ _ j â‰« limit.Ï€ _ k =\n      (limit.Ï€ _ k â‰« limit.Ï€ _ j : limit (_ â‹™ lim) âŸ¶ _) := by\n  dsimp [limitCurrySwapCompLimIsoLimitCurryCompLim, Equivalence.counit]\n  rw [Category.assoc, Category.assoc, limitIsoLimitCurryCompLim_hom_Ï€_Ï€,\n    HasLimit.isoOfEquivalence_hom_Ï€]\n  dsimp [Equivalence.counit]\n  rw [â† prod_id, G.map_id]\n  simp\n\n-- Porting note: Added type annotation `limit (_ â‹™ lim) âŸ¶ _`\n"}
{"name":"CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim_inv_Ï€_Ï€","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœâ´ : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœÂ³ : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape (Prod K J) C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimit G\ninstâœ : CategoryTheory.Limits.HasLimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCurrySwapCompLimIsoLimitCurryCompLim G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.lim) k) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.lim) j) (CategoryTheory.Limits.limit.Ï€ ((CategoryTheory.curry.obj G).obj j) k))","decl":"@[simp]\ntheorem limitCurrySwapCompLimIsoLimitCurryCompLim_inv_Ï€_Ï€ {j} {k} :\n    (limitCurrySwapCompLimIsoLimitCurryCompLim G).inv â‰« limit.Ï€ _ k â‰« limit.Ï€ _ j =\n      (limit.Ï€ _ j â‰« limit.Ï€ _ k : limit (_ â‹™ lim) âŸ¶ _) := by\n  simp [limitCurrySwapCompLimIsoLimitCurryCompLim]\n\n"}
{"name":"CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim_Î¹_Î¹_hom","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_5, u_1} J\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_2} K\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœâ´ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.colim) k) (CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim G).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j))","decl":"@[simp]\ntheorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Î¹_Î¹_hom {j} {k} :\n    colimit.Î¹ _ j â‰« colimit.Î¹ (curry.obj (Prod.swap K J â‹™ G) â‹™ colim) k â‰«\n      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).hom =\n        (colimit.Î¹ _ k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j : _ âŸ¶ colimit (curry.obj Gâ‹™ colim)) := by\n  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]\n  slice_lhs 1 3 => simp only []\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim_Î¹_Î¹_inv","module":"Mathlib.CategoryTheory.Limits.Fubini","initialProofState":"J : Type u_1\nK : Type u_2\ninstâœâ· : CategoryTheory.Category.{u_6, u_1} J\ninstâœâ¶ : CategoryTheory.Category.{u_5, u_2} K\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\nG : CategoryTheory.Functor (Prod J K) C\ninstâœâ´ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœÂ³ : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape (Prod K J) C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimit G\ninstâœ : CategoryTheory.Limits.HasColimit ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim)\nj : J\nk : K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).obj j) k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj G).comp CategoryTheory.Limits.colim) j) (CategoryTheory.Limits.colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).obj k) j) (CategoryTheory.Limits.colimit.Î¹ ((CategoryTheory.curry.obj ((CategoryTheory.Prod.swap K J).comp G)).comp CategoryTheory.Limits.colim) k))","decl":"@[simp]\ntheorem colimitCurrySwapCompColimIsoColimitCurryCompColim_Î¹_Î¹_inv {j} {k} :\n    colimit.Î¹ _ k â‰« colimit.Î¹ (curry.obj G â‹™ colim) j â‰«\n      (colimitCurrySwapCompColimIsoColimitCurryCompColim G).inv =\n        (colimit.Î¹ _ j â‰«\n          colimit.Î¹ (curry.obj _ â‹™ colim) k :\n            _ âŸ¶ colimit (curry.obj (Prod.swap K J â‹™ G) â‹™ colim)) := by\n  dsimp [colimitCurrySwapCompColimIsoColimitCurryCompColim]\n  slice_lhs 1 3 => simp only []\n  rw [colimitIsoColimitCurryCompColim_Î¹_Î¹_inv, HasColimit.isoOfEquivalence_inv_Ï€]\n  dsimp [Equivalence.counitInv]\n  rw [CategoryTheory.Bifunctor.map_id]\n  simp\n\n"}
