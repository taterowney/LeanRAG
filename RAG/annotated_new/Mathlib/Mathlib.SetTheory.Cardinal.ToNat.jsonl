{"name":"Cardinal.toNat_toENat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"a : Cardinal.{u_1}\n⊢ Eq (Cardinal.toENat a).toNat (Cardinal.toNat a)","decl":"@[simp] lemma toNat_toENat (a : Cardinal) : ENat.toNat (toENat a) = toNat a := rfl\n\n"}
{"name":"Cardinal.toNat_ofENat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"n : ENat\n⊢ Eq (Cardinal.toNat ↑n) n.toNat","decl":"@[simp]\ntheorem toNat_ofENat (n : ℕ∞) : toNat n = ENat.toNat n :=\n  congr_arg ENat.toNat <| toENat_ofENat n\n\n"}
{"name":"Cardinal.toNat_natCast","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"n : Nat\n⊢ Eq (Cardinal.toNat ↑n) n","decl":"@[simp, norm_cast] theorem toNat_natCast (n : ℕ) : toNat n = n := toNat_ofENat n\n\n"}
{"name":"Cardinal.toNat_eq_zero","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.toNat c) 0) (Or (Eq c 0) (LE.le Cardinal.aleph0 c))","decl":"@[simp]\nlemma toNat_eq_zero : toNat c = 0 ↔ c = 0 ∨ ℵ₀ ≤ c := by\n  rw [← toNat_toENat, ENat.toNat_eq_zero, toENat_eq_zero, toENat_eq_top]\n\n"}
{"name":"Cardinal.toNat_ne_zero","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Ne (Cardinal.toNat c) 0) (And (Ne c 0) (LT.lt c Cardinal.aleph0))","decl":"lemma toNat_ne_zero : toNat c ≠ 0 ↔ c ≠ 0 ∧ c < ℵ₀ := by simp [not_or]\n"}
{"name":"Cardinal.toNat_pos","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\n⊢ Iff (LT.lt 0 (Cardinal.toNat c)) (And (Ne c 0) (LT.lt c Cardinal.aleph0))","decl":"@[simp] lemma toNat_pos : 0 < toNat c ↔ c ≠ 0 ∧ c < ℵ₀ := pos_iff_ne_zero.trans toNat_ne_zero\n\n"}
{"name":"Cardinal.cast_toNat_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u_1}\nh : LT.lt c Cardinal.aleph0\n⊢ Eq (↑(Cardinal.toNat c)) c","decl":"theorem cast_toNat_of_lt_aleph0 {c : Cardinal} (h : c < ℵ₀) : ↑(toNat c) = c := by\n  lift c to ℕ using h\n  rw [toNat_natCast]\n\n"}
{"name":"Cardinal.toNat_apply_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\nh : LT.lt c Cardinal.aleph0\n⊢ Eq (Cardinal.toNat c) (Classical.choose ⋯)","decl":"theorem toNat_apply_of_lt_aleph0 {c : Cardinal.{u}} (h : c < ℵ₀) :\n    toNat c = Classical.choose (lt_aleph0.1 h) :=\n  Nat.cast_injective (R := Cardinal.{u}) <| by\n    rw [cast_toNat_of_lt_aleph0 h, ← Classical.choose_spec (lt_aleph0.1 h)]\n\n"}
{"name":"Cardinal.toNat_apply_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (Cardinal.toNat c) 0","decl":"theorem toNat_apply_of_aleph0_le {c : Cardinal} (h : ℵ₀ ≤ c) : toNat c = 0 := by simp [h]\n\n"}
{"name":"Cardinal.cast_toNat_of_aleph0_le","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (↑(Cardinal.toNat c)) 0","decl":"theorem cast_toNat_of_aleph0_le {c : Cardinal} (h : ℵ₀ ≤ c) : ↑(toNat c) = (0 : Cardinal) := by\n  rw [toNat_apply_of_aleph0_le h, Nat.cast_zero]\n\n"}
{"name":"Cardinal.toNat_strictMonoOn","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ StrictMonoOn (⇑Cardinal.toNat) (Set.Iio Cardinal.aleph0)","decl":"theorem toNat_strictMonoOn : StrictMonoOn toNat (Iio ℵ₀) := by\n  simp only [← range_natCast, StrictMonoOn, forall_mem_range, toNat_natCast, Nat.cast_lt]\n  exact fun _ _ ↦ id\n\n"}
{"name":"Cardinal.toNat_monotoneOn","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ MonotoneOn (⇑Cardinal.toNat) (Set.Iio Cardinal.aleph0)","decl":"theorem toNat_monotoneOn : MonotoneOn toNat (Iio ℵ₀) := toNat_strictMonoOn.monotoneOn\n\n"}
{"name":"Cardinal.toNat_injOn","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Set.InjOn (⇑Cardinal.toNat) (Set.Iio Cardinal.aleph0)","decl":"theorem toNat_injOn : InjOn toNat (Iio ℵ₀) := toNat_strictMonoOn.injOn\n\n"}
{"name":"Cardinal.toNat_inj_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhc : LT.lt c Cardinal.aleph0\nhd : LT.lt d Cardinal.aleph0\n⊢ Iff (Eq (Cardinal.toNat c) (Cardinal.toNat d)) (Eq c d)","decl":"/-- Two finite cardinals are equal\niff they are equal their `Cardinal.toNat` projections are equal. -/\ntheorem toNat_inj_of_lt_aleph0 (hc : c < ℵ₀) (hd : d < ℵ₀) :\n    toNat c = toNat d ↔ c = d :=\n  toNat_injOn.eq_iff hc hd\n\n"}
{"name":"Cardinal.toNat_eq_iff_eq_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhc : LT.lt c Cardinal.aleph0\nhd : LT.lt d Cardinal.aleph0\n⊢ Iff (Eq (Cardinal.toNat c) (Cardinal.toNat d)) (Eq c d)","decl":"@[deprecated (since := \"2024-12-29\")] alias toNat_eq_iff_eq_of_lt_aleph0 := toNat_inj_of_lt_aleph0\n\n"}
{"name":"Cardinal.toNat_le_iff_le_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhc : LT.lt c Cardinal.aleph0\nhd : LT.lt d Cardinal.aleph0\n⊢ Iff (LE.le (Cardinal.toNat c) (Cardinal.toNat d)) (LE.le c d)","decl":"theorem toNat_le_iff_le_of_lt_aleph0 (hc : c < ℵ₀) (hd : d < ℵ₀) :\n    toNat c ≤ toNat d ↔ c ≤ d :=\n  toNat_strictMonoOn.le_iff_le hc hd\n\n"}
{"name":"Cardinal.toNat_lt_iff_lt_of_lt_aleph0","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhc : LT.lt c Cardinal.aleph0\nhd : LT.lt d Cardinal.aleph0\n⊢ Iff (LT.lt (Cardinal.toNat c) (Cardinal.toNat d)) (LT.lt c d)","decl":"theorem toNat_lt_iff_lt_of_lt_aleph0 (hc : c < ℵ₀) (hd : d < ℵ₀) :\n    toNat c < toNat d ↔ c < d :=\n  toNat_strictMonoOn.lt_iff_lt hc hd\n\n"}
{"name":"Cardinal.toNat_le_toNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhcd : LE.le c d\nhd : LT.lt d Cardinal.aleph0\n⊢ LE.le (Cardinal.toNat c) (Cardinal.toNat d)","decl":"@[gcongr]\ntheorem toNat_le_toNat (hcd : c ≤ d) (hd : d < ℵ₀) : toNat c ≤ toNat d :=\n  toNat_monotoneOn (hcd.trans_lt hd) hd hcd\n\n"}
{"name":"Cardinal.toNat_lt_toNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhcd : LT.lt c d\nhd : LT.lt d Cardinal.aleph0\n⊢ LT.lt (Cardinal.toNat c) (Cardinal.toNat d)","decl":"theorem toNat_lt_toNat (hcd : c < d) (hd : d < ℵ₀) : toNat c < toNat d :=\n  toNat_strictMonoOn (hcd.trans hd) hd hcd\n\n"}
{"name":"Cardinal.toNat_ofNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Cardinal.toNat (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem toNat_ofNat (n : ℕ) [n.AtLeastTwo] :\n    Cardinal.toNat ofNat(n) = OfNat.ofNat n :=\n  toNat_natCast n\n\n"}
{"name":"Cardinal.toNat_rightInverse","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Function.RightInverse Nat.cast ⇑Cardinal.toNat","decl":"/-- `toNat` has a right-inverse: coercion. -/\ntheorem toNat_rightInverse : Function.RightInverse ((↑) : ℕ → Cardinal) toNat :=\n  toNat_natCast\n\n"}
{"name":"Cardinal.toNat_surjective","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Function.Surjective ⇑Cardinal.toNat","decl":"theorem toNat_surjective : Surjective toNat :=\n  toNat_rightInverse.surjective\n\n"}
{"name":"Cardinal.mk_toNat_of_infinite","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"α : Type u\nh : Infinite α\n⊢ Eq (Cardinal.toNat (Cardinal.mk α)) 0","decl":"@[simp]\ntheorem mk_toNat_of_infinite [h : Infinite α] : toNat #α = 0 := by simp\n\n"}
{"name":"Cardinal.aleph0_toNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Eq (Cardinal.toNat Cardinal.aleph0) 0","decl":"@[simp]\ntheorem aleph0_toNat : toNat ℵ₀ = 0 :=\n  toNat_apply_of_aleph0_le le_rfl\n\n"}
{"name":"Cardinal.mk_toNat_eq_card","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"α : Type u\ninst✝ : Fintype α\n⊢ Eq (Cardinal.toNat (Cardinal.mk α)) (Fintype.card α)","decl":"theorem mk_toNat_eq_card [Fintype α] : toNat #α = Fintype.card α := by simp\n\n"}
{"name":"Cardinal.zero_toNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Eq (Cardinal.toNat 0) 0","decl":"@[simp]\ntheorem zero_toNat : toNat 0 = 0 := map_zero _\n\n"}
{"name":"Cardinal.one_toNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"⊢ Eq (Cardinal.toNat 1) 1","decl":"theorem one_toNat : toNat 1 = 1 := map_one _\n\n"}
{"name":"Cardinal.toNat_eq_iff","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (Cardinal.toNat c) n) (Eq c ↑n)","decl":"theorem toNat_eq_iff {n : ℕ} (hn : n ≠ 0) : toNat c = n ↔ c = n := by\n  rw [← toNat_toENat, ENat.toNat_eq_iff hn, toENat_eq_nat]\n\n"}
{"name":"Cardinal.toNat_eq_ofNat","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Iff (Eq (Cardinal.toNat c) (OfNat.ofNat n)) (Eq c (OfNat.ofNat n))","decl":"/-- A version of `toNat_eq_iff` for literals -/\ntheorem toNat_eq_ofNat {n : ℕ} [Nat.AtLeastTwo n] :\n    toNat c = OfNat.ofNat n ↔ c = OfNat.ofNat n :=\n  toNat_eq_iff <| OfNat.ofNat_ne_zero n\n\n"}
{"name":"Cardinal.toNat_eq_one","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{u}\n⊢ Iff (Eq (Cardinal.toNat c) 1) (Eq c 1)","decl":"@[simp]\ntheorem toNat_eq_one : toNat c = 1 ↔ c = 1 := by\n  rw [toNat_eq_iff one_ne_zero, Nat.cast_one]\n\n"}
{"name":"Cardinal.toNat_eq_one_iff_unique","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"α : Type u\n⊢ Iff (Eq (Cardinal.toNat (Cardinal.mk α)) 1) (And (Subsingleton α) (Nonempty α))","decl":"theorem toNat_eq_one_iff_unique : toNat #α = 1 ↔ Subsingleton α ∧ Nonempty α :=\n  toNat_eq_one.trans eq_one_iff_unique\n\n"}
{"name":"Cardinal.toNat_lift","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c : Cardinal.{v}\n⊢ Eq (Cardinal.toNat (Cardinal.lift.{u, v} c)) (Cardinal.toNat c)","decl":"@[simp]\ntheorem toNat_lift (c : Cardinal.{v}) : toNat (lift.{u, v} c) = toNat c := by\n  simp only [← toNat_toENat, toENat_lift]\n\n"}
{"name":"Cardinal.toNat_congr","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"α : Type u\nβ : Type v\ne : Equiv α β\n⊢ Eq (Cardinal.toNat (Cardinal.mk α)) (Cardinal.toNat (Cardinal.mk β))","decl":"theorem toNat_congr {β : Type v} (e : α ≃ β) : toNat #α = toNat #β := by\n  -- Porting note: Inserted universe hint below\n  rw [← toNat_lift, (lift_mk_eq.{_,_,v}).mpr ⟨e⟩, toNat_lift]\n\n"}
{"name":"Cardinal.toNat_mul","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"x y : Cardinal.{u_1}\n⊢ Eq (Cardinal.toNat (HMul.hMul x y)) (HMul.hMul (Cardinal.toNat x) (Cardinal.toNat y))","decl":"theorem toNat_mul (x y : Cardinal) : toNat (x * y) = toNat x * toNat y := map_mul toNat x y\n\n"}
{"name":"Cardinal.toNat_add","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"c d : Cardinal.{u}\nhc : LT.lt c Cardinal.aleph0\nhd : LT.lt d Cardinal.aleph0\n⊢ Eq (Cardinal.toNat (HAdd.hAdd c d)) (HAdd.hAdd (Cardinal.toNat c) (Cardinal.toNat d))","decl":"@[simp]\ntheorem toNat_add (hc : c < ℵ₀) (hd : d < ℵ₀) : toNat (c + d) = toNat c + toNat d := by\n  lift c to ℕ using hc\n  lift d to ℕ using hd\n  norm_cast\n\n"}
{"name":"Cardinal.toNat_lift_add_lift","module":"Mathlib.SetTheory.Cardinal.ToNat","initialProofState":"a : Cardinal.{u}\nb : Cardinal.{v}\nha : LT.lt a Cardinal.aleph0\nhb : LT.lt b Cardinal.aleph0\n⊢ Eq (Cardinal.toNat (HAdd.hAdd (Cardinal.lift.{v, u} a) (Cardinal.lift.{u, v} b))) (HAdd.hAdd (Cardinal.toNat a) (Cardinal.toNat b))","decl":"@[simp]\ntheorem toNat_lift_add_lift {a : Cardinal.{u}} {b : Cardinal.{v}} (ha : a < ℵ₀) (hb : b < ℵ₀) :\n    toNat (lift.{v} a + lift.{u} b) = toNat a + toNat b := by\n  simp [*]\n\n"}
