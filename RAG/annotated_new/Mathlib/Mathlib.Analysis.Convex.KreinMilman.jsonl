{"name":"IsCompact.extremePoints_nonempty","module":"Mathlib.Analysis.Convex.KreinMilman","initialProofState":"E : Type u_1\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ninst✝⁴ : TopologicalSpace E\ninst✝³ : T2Space E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\ns : Set E\nhscomp : IsCompact s\nhsnemp : s.Nonempty\n⊢ (Set.extremePoints Real s).Nonempty","decl":"/-- **Krein-Milman lemma**: In a LCTVS, any nonempty compact set has an extreme point. -/\ntheorem IsCompact.extremePoints_nonempty (hscomp : IsCompact s) (hsnemp : s.Nonempty) :\n    (s.extremePoints ℝ).Nonempty := by\n  let S : Set (Set E) := { t | t.Nonempty ∧ IsClosed t ∧ IsExtreme ℝ s t }\n  rsuffices ⟨t, ht⟩ : ∃ t, Minimal (· ∈ S) t\n  · obtain ⟨⟨x,hxt⟩, htclos, hst⟩ := ht.prop\n    refine ⟨x, IsExtreme.mem_extremePoints ?_⟩\n    rwa [← eq_singleton_iff_unique_mem.2 ⟨hxt, fun y hyB => ?_⟩]\n    by_contra hyx\n    obtain ⟨l, hl⟩ := geometric_hahn_banach_point_point hyx\n    obtain ⟨z, hzt, hz⟩ :=\n      (hscomp.of_isClosed_subset htclos hst.1).exists_isMaxOn ⟨x, hxt⟩\n        l.continuous.continuousOn\n    have h : IsExposed ℝ t ({ z ∈ t | ∀ w ∈ t, l w ≤ l z }) := fun _ => ⟨l, rfl⟩\n    rw [ht.eq_of_ge (y := ({ z ∈ t | ∀ w ∈ t, l w ≤ l z }))\n      ⟨⟨z, hzt, hz⟩, h.isClosed htclos, hst.trans h.isExtreme⟩ (t.sep_subset _)] at hyB\n    exact hl.not_le (hyB.2 x hxt)\n  refine zorn_superset _ fun F hFS hF => ?_\n  obtain rfl | hFnemp := F.eq_empty_or_nonempty\n  · exact ⟨s, ⟨hsnemp, hscomp.isClosed, IsExtreme.rfl⟩, fun _ => False.elim⟩\n  refine ⟨⋂₀ F, ⟨?_, isClosed_sInter fun t ht => (hFS ht).2.1,\n    isExtreme_sInter hFnemp fun t ht => (hFS ht).2.2⟩, fun t ht => sInter_subset_of_mem ht⟩\n  haveI : Nonempty (↥F) := hFnemp.to_subtype\n  rw [sInter_eq_iInter]\n  refine IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ (fun t u => ?_)\n    (fun t => (hFS t.mem).1)\n    (fun t => hscomp.of_isClosed_subset (hFS t.mem).2.1 (hFS t.mem).2.2.1) fun t =>\n      (hFS t.mem).2.1\n  obtain htu | hut := hF.total t.mem u.mem\n  exacts [⟨t, Subset.rfl, htu⟩, ⟨u, hut, Subset.rfl⟩]\n\n"}
{"name":"closure_convexHull_extremePoints","module":"Mathlib.Analysis.Convex.KreinMilman","initialProofState":"E : Type u_1\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ninst✝⁴ : TopologicalSpace E\ninst✝³ : T2Space E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\ns : Set E\nhscomp : IsCompact s\nhAconv : Convex Real s\n⊢ Eq (closure ((convexHull Real) (Set.extremePoints Real s))) s","decl":"/-- **Krein-Milman theorem**: In a LCTVS, any compact convex set is the closure of the convex hull\n    of its extreme points. -/\ntheorem closure_convexHull_extremePoints (hscomp : IsCompact s) (hAconv : Convex ℝ s) :\n    closure (convexHull ℝ <| s.extremePoints ℝ) = s := by\n  apply (closure_minimal (convexHull_min extremePoints_subset hAconv) hscomp.isClosed).antisymm\n  by_contra hs\n  obtain ⟨x, hxA, hxt⟩ := not_subset.1 hs\n  obtain ⟨l, r, hlr, hrx⟩ :=\n    geometric_hahn_banach_closed_point (convex_convexHull _ _).closure isClosed_closure hxt\n  have h : IsExposed ℝ s ({ y ∈ s | ∀ z ∈ s, l z ≤ l y }) := fun _ => ⟨l, rfl⟩\n  obtain ⟨z, hzA, hz⟩ := hscomp.exists_isMaxOn ⟨x, hxA⟩ l.continuous.continuousOn\n  obtain ⟨y, hy⟩ := (h.isCompact hscomp).extremePoints_nonempty ⟨z, hzA, hz⟩\n  linarith [hlr _ (subset_closure <| subset_convexHull _ _ <|\n    h.isExtreme.extremePoints_subset_extremePoints hy), hy.1.2 x hxA]\n\n"}
{"name":"surjOn_extremePoints_image","module":"Mathlib.Analysis.Convex.KreinMilman","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : Module Real E\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : T2Space E\ninst✝⁶ : TopologicalAddGroup E\ninst✝⁵ : ContinuousSMul Real E\ninst✝⁴ : LocallyConvexSpace Real E\ns : Set E\ninst✝³ : AddCommGroup F\ninst✝² : Module Real F\ninst✝¹ : TopologicalSpace F\ninst✝ : T1Space F\nf : ContinuousAffineMap Real E F\nhs : IsCompact s\n⊢ Set.SurjOn (⇑f) (Set.extremePoints Real s) (Set.extremePoints Real (Set.image (⇑f) s))","decl":"/-- A continuous affine map is surjective from the extreme points of a compact set to the extreme\npoints of the image of that set. This inclusion is in general strict. -/\nlemma surjOn_extremePoints_image (f : E →ᴬ[ℝ] F) (hs : IsCompact s) :\n    SurjOn f (extremePoints ℝ s) (extremePoints ℝ (f '' s)) := by\n  rintro w hw\n  -- The fiber of `w` is nonempty and compact\n  have ht : IsCompact {x ∈ s | f x = w} :=\n    hs.inter_right <| isClosed_singleton.preimage f.continuous\n  have ht₀ : {x ∈ s | f x = w}.Nonempty := by simpa using extremePoints_subset hw\n  -- Hence by the Krein-Milman lemma it has an extreme point `x`\n  obtain ⟨x, ⟨hx, rfl⟩, hyt⟩ := ht.extremePoints_nonempty ht₀\n  -- `f x = w` and `x` is an extreme point of `s`, so we're done\n  refine mem_image_of_mem _ ⟨hx, fun y hy z hz hxyz ↦ ?_⟩\n  have := by simpa using image_openSegment _ f.toAffineMap y z\n  have := hw.2 (mem_image_of_mem _ hy) (mem_image_of_mem _ hz) <| by\n    rw [← this]; exact mem_image_of_mem _ hxyz\n  exact hyt ⟨hy, this.1⟩ ⟨hz, this.2⟩ hxyz\n"}
