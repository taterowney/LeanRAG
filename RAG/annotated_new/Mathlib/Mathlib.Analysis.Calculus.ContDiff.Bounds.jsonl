{"name":"ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_aux","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nDu Eu Fu Gu : Type u\ninst✝⁷ : NormedAddCommGroup Du\ninst✝⁶ : NormedSpace 𝕜 Du\ninst✝⁵ : NormedAddCommGroup Eu\ninst✝⁴ : NormedSpace 𝕜 Eu\ninst✝³ : NormedAddCommGroup Fu\ninst✝² : NormedSpace 𝕜 Fu\ninst✝¹ : NormedAddCommGroup Gu\ninst✝ : NormedSpace 𝕜 Gu\nB : ContinuousLinearMap (RingHom.id 𝕜) Eu (ContinuousLinearMap (RingHom.id 𝕜) Fu Gu)\nf : Du → Eu\ng : Du → Fu\nn : Nat\ns : Set Du\nx : Du\nhf : ContDiffOn 𝕜 (↑n) f s\nhg : ContDiffOn 𝕜 (↑n) g s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => (B (f y)) (g y)) s x)) (HMul.hMul (Norm.norm B) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x))))","decl":"/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear. This lemma is an auxiliary version\nassuming all spaces live in the same universe, to enable an induction. Use instead\n`ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear` that removes this assumption. -/\ntheorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_aux {Du Eu Fu Gu : Type u}\n    [NormedAddCommGroup Du] [NormedSpace 𝕜 Du] [NormedAddCommGroup Eu] [NormedSpace 𝕜 Eu]\n    [NormedAddCommGroup Fu] [NormedSpace 𝕜 Fu] [NormedAddCommGroup Gu] [NormedSpace 𝕜 Gu]\n    (B : Eu →L[𝕜] Fu →L[𝕜] Gu) {f : Du → Eu} {g : Du → Fu} {n : ℕ} {s : Set Du} {x : Du}\n    (hf : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤\n      ‖B‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by\n  /- We argue by induction on `n`. The bound is trivial for `n = 0`. For `n + 1`, we write\n    the `(n+1)`-th derivative as the `n`-th derivative of the derivative `B f g' + B f' g`,\n    and apply the inductive assumption to each of those two terms. For this induction to make sense,\n    the spaces of linear maps that appear in the induction should be in the same universe as the\n    original spaces, which explains why we assume in the lemma that all spaces live in the same\n    universe. -/\n  induction' n with n IH generalizing Eu Fu Gu\n  · simp only [norm_iteratedFDerivWithin_zero, zero_add, Finset.range_one,\n      Finset.sum_singleton, Nat.choose_self, Nat.cast_one, one_mul, Nat.sub_zero, ← mul_assoc]\n    apply B.le_opNorm₂\n  · have In : (n : WithTop ℕ∞) + 1 ≤ n.succ := by simp only [Nat.cast_succ, le_refl]\n    -- Porting note: the next line is a hack allowing Lean to find the operator norm instance.\n    let norm := @ContinuousLinearMap.hasOpNorm _ _ Eu ((Du →L[𝕜] Fu) →L[𝕜] Du →L[𝕜] Gu) _ _ _ _ _ _\n      (RingHom.id 𝕜)\n    have I1 :\n        ‖iteratedFDerivWithin 𝕜 n (fun y : Du => B.precompR Du (f y) (fderivWithin 𝕜 g s y)) s x‖ ≤\n          ‖B‖ * ∑ i ∈ Finset.range (n + 1), n.choose i * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n            ‖iteratedFDerivWithin 𝕜 (n + 1 - i) g s x‖ := by\n      calc\n        ‖iteratedFDerivWithin 𝕜 n (fun y : Du => B.precompR Du (f y) (fderivWithin 𝕜 g s y)) s x‖ ≤\n            ‖B.precompR Du‖ * ∑ i ∈ Finset.range (n + 1),\n              n.choose i * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n                ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 g s) s x‖ :=\n          IH _ (hf.of_le (Nat.cast_le.2 (Nat.le_succ n))) (hg.fderivWithin hs In)\n        _ ≤ ‖B‖ * ∑ i ∈ Finset.range (n + 1), n.choose i * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n              ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 g s) s x‖ :=\n            mul_le_mul_of_nonneg_right (B.norm_precompR_le Du) (by positivity)\n        _ = _ := by\n          congr 1\n          apply Finset.sum_congr rfl fun i hi => ?_\n          rw [Nat.succ_sub (Nat.lt_succ_iff.1 (Finset.mem_range.1 hi)),\n            ← norm_iteratedFDerivWithin_fderivWithin hs hx]\n    -- Porting note: the next line is a hack allowing Lean to find the operator norm instance.\n    let norm := @ContinuousLinearMap.hasOpNorm _ _ (Du →L[𝕜] Eu) (Fu →L[𝕜] Du →L[𝕜] Gu) _ _ _ _ _ _\n      (RingHom.id 𝕜)\n    have I2 :\n        ‖iteratedFDerivWithin 𝕜 n (fun y : Du => B.precompL Du (fderivWithin 𝕜 f s y) (g y)) s x‖ ≤\n        ‖B‖ * ∑ i ∈ Finset.range (n + 1), n.choose i * ‖iteratedFDerivWithin 𝕜 (i + 1) f s x‖ *\n          ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ :=\n      calc\n        ‖iteratedFDerivWithin 𝕜 n (fun y : Du => B.precompL Du (fderivWithin 𝕜 f s y) (g y)) s x‖ ≤\n            ‖B.precompL Du‖ * ∑ i ∈ Finset.range (n + 1),\n              n.choose i * ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 f s) s x‖ *\n                ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ :=\n          IH _ (hf.fderivWithin hs In) (hg.of_le (Nat.cast_le.2 (Nat.le_succ n)))\n        _ ≤ ‖B‖ * ∑ i ∈ Finset.range (n + 1),\n            n.choose i * ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 f s) s x‖ *\n              ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ :=\n            mul_le_mul_of_nonneg_right (B.norm_precompL_le Du) (by positivity)\n        _ = _ := by\n          congr 1\n          apply Finset.sum_congr rfl fun i _ => ?_\n          rw [← norm_iteratedFDerivWithin_fderivWithin hs hx]\n    have J : iteratedFDerivWithin 𝕜 n\n        (fun y : Du => fderivWithin 𝕜 (fun y : Du => B (f y) (g y)) s y) s x =\n          iteratedFDerivWithin 𝕜 n (fun y => B.precompR Du (f y)\n            (fderivWithin 𝕜 g s y) + B.precompL Du (fderivWithin 𝕜 f s y) (g y)) s x := by\n      apply iteratedFDerivWithin_congr (fun y hy => ?_) hx\n      have L : (1 : WithTop ℕ∞) ≤ n.succ := by\n        simpa only [ENat.coe_one, Nat.one_le_cast] using Nat.succ_pos n\n      exact B.fderivWithin_of_bilinear (hf.differentiableOn L y hy) (hg.differentiableOn L y hy)\n        (hs y hy)\n    rw [← norm_iteratedFDerivWithin_fderivWithin hs hx, J]\n    have A : ContDiffOn 𝕜 n (fun y => B.precompR Du (f y) (fderivWithin 𝕜 g s y)) s :=\n      (B.precompR Du).isBoundedBilinearMap.contDiff.comp₂_contDiffOn\n        (hf.of_le (Nat.cast_le.2 (Nat.le_succ n))) (hg.fderivWithin hs In)\n    have A' : ContDiffOn 𝕜 n (fun y => B.precompL Du (fderivWithin 𝕜 f s y) (g y)) s :=\n      (B.precompL Du).isBoundedBilinearMap.contDiff.comp₂_contDiffOn (hf.fderivWithin hs In)\n        (hg.of_le (Nat.cast_le.2 (Nat.le_succ n)))\n    rw [iteratedFDerivWithin_add_apply' A A' hs hx]\n    apply (norm_add_le _ _).trans ((add_le_add I1 I2).trans (le_of_eq ?_))\n    simp_rw [← mul_add, mul_assoc]\n    congr 1\n    exact (Finset.sum_choose_succ_mul\n      (fun i j => ‖iteratedFDerivWithin 𝕜 i f s x‖ * ‖iteratedFDerivWithin 𝕜 j g s x‖) n).symm\n\n"}
{"name":"ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : D → E\ng : D → F\nN : WithTop ENat\ns : Set D\nx : D\nhf : ContDiffOn 𝕜 N f s\nhg : ContDiffOn 𝕜 N g s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => (B (f y)) (g y)) s x)) (HMul.hMul (Norm.norm B) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x))))","decl":"/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear:\n`‖D^n (x ↦ B (f x) (g x))‖ ≤ ‖B‖ ∑_{k ≤ n} n.choose k ‖D^k f‖ ‖D^{n-k} g‖` -/\ntheorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear (B : E →L[𝕜] F →L[𝕜] G)\n    {f : D → E} {g : D → F} {N : WithTop ℕ∞} {s : Set D} {x : D} (hf : ContDiffOn 𝕜 N f s)\n    (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ} (hn : n ≤ N) :\n    ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤\n      ‖B‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by\n  /- We reduce the bound to the case where all spaces live in the same universe (in which we\n    already have proved the result), by using linear isometries between the spaces and their `ULift`\n    to a common universe. These linear isometries preserve the norm of the iterated derivative. -/\n  let Du : Type max uD uE uF uG := ULift.{max uE uF uG, uD} D\n  let Eu : Type max uD uE uF uG := ULift.{max uD uF uG, uE} E\n  let Fu : Type max uD uE uF uG := ULift.{max uD uE uG, uF} F\n  let Gu : Type max uD uE uF uG := ULift.{max uD uE uF, uG} G\n  have isoD : Du ≃ₗᵢ[𝕜] D := LinearIsometryEquiv.ulift 𝕜 D\n  have isoE : Eu ≃ₗᵢ[𝕜] E := LinearIsometryEquiv.ulift 𝕜 E\n  have isoF : Fu ≃ₗᵢ[𝕜] F := LinearIsometryEquiv.ulift 𝕜 F\n  have isoG : Gu ≃ₗᵢ[𝕜] G := LinearIsometryEquiv.ulift 𝕜 G\n  -- lift `f` and `g` to versions `fu` and `gu` on the lifted spaces.\n  let fu : Du → Eu := isoE.symm ∘ f ∘ isoD\n  let gu : Du → Fu := isoF.symm ∘ g ∘ isoD\n  -- lift the bilinear map `B` to a bilinear map `Bu` on the lifted spaces.\n  let Bu₀ : Eu →L[𝕜] Fu →L[𝕜] G := ((B.comp (isoE : Eu →L[𝕜] E)).flip.comp (isoF : Fu →L[𝕜] F)).flip\n  let Bu : Eu →L[𝕜] Fu →L[𝕜] Gu :=\n   ContinuousLinearMap.compL 𝕜 Eu (Fu →L[𝕜] G) (Fu →L[𝕜] Gu)\n    (ContinuousLinearMap.compL 𝕜 Fu G Gu (isoG.symm : G →L[𝕜] Gu)) Bu₀\n  have hBu : Bu = ContinuousLinearMap.compL 𝕜 Eu (Fu →L[𝕜] G) (Fu →L[𝕜] Gu)\n      (ContinuousLinearMap.compL 𝕜 Fu G Gu (isoG.symm : G →L[𝕜] Gu)) Bu₀ := rfl\n  have Bu_eq : (fun y => Bu (fu y) (gu y)) = isoG.symm ∘ (fun y => B (f y) (g y)) ∘ isoD := by\n    ext1 y\n    simp [Du, Eu, Fu, Gu, hBu, Bu₀, fu, gu]\n  -- All norms are preserved by the lifting process.\n  have Bu_le : ‖Bu‖ ≤ ‖B‖ := by\n    refine ContinuousLinearMap.opNorm_le_bound _ (norm_nonneg B) fun y => ?_\n    refine ContinuousLinearMap.opNorm_le_bound _ (by positivity) fun x => ?_\n    simp only [Du, Eu, Fu, Gu, hBu, Bu₀, compL_apply, coe_comp', Function.comp_apply,\n      ContinuousLinearEquiv.coe_coe, LinearIsometryEquiv.coe_coe, flip_apply,\n      LinearIsometryEquiv.norm_map]\n    calc\n      ‖B (isoE y) (isoF x)‖ ≤ ‖B (isoE y)‖ * ‖isoF x‖ := ContinuousLinearMap.le_opNorm _ _\n      _ ≤ ‖B‖ * ‖isoE y‖ * ‖isoF x‖ := by gcongr; apply ContinuousLinearMap.le_opNorm\n      _ = ‖B‖ * ‖y‖ * ‖x‖ := by simp only [LinearIsometryEquiv.norm_map]\n  let su := isoD ⁻¹' s\n  have hsu : UniqueDiffOn 𝕜 su := isoD.toContinuousLinearEquiv.uniqueDiffOn_preimage_iff.2 hs\n  let xu := isoD.symm x\n  have hxu : xu ∈ su := by\n    simpa only [xu, su, Set.mem_preimage, LinearIsometryEquiv.apply_symm_apply] using hx\n  have xu_x : isoD xu = x := by simp only [xu, LinearIsometryEquiv.apply_symm_apply]\n  have hfu : ContDiffOn 𝕜 n fu su :=\n    isoE.symm.contDiff.comp_contDiffOn\n      ((hf.of_le hn).comp_continuousLinearMap (isoD : Du →L[𝕜] D))\n  have hgu : ContDiffOn 𝕜 n gu su :=\n    isoF.symm.contDiff.comp_contDiffOn\n      ((hg.of_le hn).comp_continuousLinearMap (isoD : Du →L[𝕜] D))\n  have Nfu : ∀ i, ‖iteratedFDerivWithin 𝕜 i fu su xu‖ = ‖iteratedFDerivWithin 𝕜 i f s x‖ := by\n    intro i\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ hsu hxu]\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right _ _ hs, xu_x]\n    rwa [← xu_x] at hx\n  have Ngu : ∀ i, ‖iteratedFDerivWithin 𝕜 i gu su xu‖ = ‖iteratedFDerivWithin 𝕜 i g s x‖ := by\n    intro i\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ hsu hxu]\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right _ _ hs, xu_x]\n    rwa [← xu_x] at hx\n  have NBu :\n    ‖iteratedFDerivWithin 𝕜 n (fun y => Bu (fu y) (gu y)) su xu‖ =\n      ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ := by\n    rw [Bu_eq]\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ hsu hxu]\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right _ _ hs, xu_x]\n    rwa [← xu_x] at hx\n  -- state the bound for the lifted objects, and deduce the original bound from it.\n  have : ‖iteratedFDerivWithin 𝕜 n (fun y => Bu (fu y) (gu y)) su xu‖ ≤\n      ‖Bu‖ * ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i fu su xu‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) gu su xu‖ :=\n    Bu.norm_iteratedFDerivWithin_le_of_bilinear_aux hfu hgu hsu hxu\n  simp only [Nfu, Ngu, NBu] at this\n  exact this.trans (mul_le_mul_of_nonneg_right Bu_le (by positivity))\n\n"}
{"name":"ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : D → E\ng : D → F\nN : WithTop ENat\nhf : ContDiff 𝕜 N f\nhg : ContDiff 𝕜 N g\nx : D\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => (B (f y)) (g y)) x)) (HMul.hMul (Norm.norm B) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDeriv 𝕜 i f x))) (Norm.norm (iteratedFDeriv 𝕜 (HSub.hSub n i) g x))))","decl":"/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear:\n`‖D^n (x ↦ B (f x) (g x))‖ ≤ ‖B‖ ∑_{k ≤ n} n.choose k ‖D^k f‖ ‖D^{n-k} g‖` -/\ntheorem ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear (B : E →L[𝕜] F →L[𝕜] G) {f : D → E}\n    {g : D → F} {N : WithTop ℕ∞} (hf : ContDiff 𝕜 N f) (hg : ContDiff 𝕜 N g) (x : D) {n : ℕ}\n    (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (fun y => B (f y) (g y)) x‖ ≤ ‖B‖ * ∑ i ∈ Finset.range (n + 1),\n      (n.choose i : ℝ) * ‖iteratedFDeriv 𝕜 i f x‖ * ‖iteratedFDeriv 𝕜 (n - i) g x‖ := by\n  simp_rw [← iteratedFDerivWithin_univ]\n  exact B.norm_iteratedFDerivWithin_le_of_bilinear hf.contDiffOn hg.contDiffOn uniqueDiffOn_univ\n    (mem_univ x) hn\n\n"}
{"name":"ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_of_le_one","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : D → E\ng : D → F\nN : WithTop ENat\ns : Set D\nx : D\nhf : ContDiffOn 𝕜 N f s\nhg : ContDiffOn 𝕜 N g s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nn : Nat\nhn : LE.le (↑n) N\nhB : LE.le (Norm.norm B) 1\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => (B (f y)) (g y)) s x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x)))","decl":"/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` within a set in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear of norm at most `1`:\n`‖D^n (x ↦ B (f x) (g x))‖ ≤ ∑_{k ≤ n} n.choose k ‖D^k f‖ ‖D^{n-k} g‖` -/\ntheorem ContinuousLinearMap.norm_iteratedFDerivWithin_le_of_bilinear_of_le_one\n    (B : E →L[𝕜] F →L[𝕜] G) {f : D → E} {g : D → F} {N : WithTop ℕ∞} {s : Set D} {x : D}\n    (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {n : ℕ}\n    (hn : n ≤ N) (hB : ‖B‖ ≤ 1) : ‖iteratedFDerivWithin 𝕜 n (fun y => B (f y) (g y)) s x‖ ≤\n      ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by\n  apply (B.norm_iteratedFDerivWithin_le_of_bilinear hf hg hs hx hn).trans\n  exact mul_le_of_le_one_left (by positivity) hB\n\n"}
{"name":"ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear_of_le_one","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nB : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) F G)\nf : D → E\ng : D → F\nN : WithTop ENat\nhf : ContDiff 𝕜 N f\nhg : ContDiff 𝕜 N g\nx : D\nn : Nat\nhn : LE.le (↑n) N\nhB : LE.le (Norm.norm B) 1\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => (B (f y)) (g y)) x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDeriv 𝕜 i f x))) (Norm.norm (iteratedFDeriv 𝕜 (HSub.hSub n i) g x)))","decl":"/-- Bounding the norm of the iterated derivative of `B (f x) (g x)` in terms of the\niterated derivatives of `f` and `g` when `B` is bilinear of norm at most `1`:\n`‖D^n (x ↦ B (f x) (g x))‖ ≤ ∑_{k ≤ n} n.choose k ‖D^k f‖ ‖D^{n-k} g‖` -/\ntheorem ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear_of_le_one (B : E →L[𝕜] F →L[𝕜] G)\n    {f : D → E} {g : D → F} {N : WithTop ℕ∞} (hf : ContDiff 𝕜 N f) (hg : ContDiff 𝕜 N g)\n    (x : D) {n : ℕ} (hn : n ≤ N) (hB : ‖B‖ ≤ 1) :\n    ‖iteratedFDeriv 𝕜 n (fun y => B (f y) (g y)) x‖ ≤\n      ∑ i ∈ Finset.range (n + 1),\n        (n.choose i : ℝ) * ‖iteratedFDeriv 𝕜 i f x‖ * ‖iteratedFDeriv 𝕜 (n - i) g x‖ := by\n  simp_rw [← iteratedFDerivWithin_univ]\n  exact B.norm_iteratedFDerivWithin_le_of_bilinear_of_le_one hf.contDiffOn hg.contDiffOn\n    uniqueDiffOn_univ (mem_univ x) hn hB\n\n"}
{"name":"norm_iteratedFDerivWithin_smul_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ns : Set E\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → 𝕜'\ng : E → F\nN : WithTop ENat\nhf : ContDiffOn 𝕜 N f s\nhg : ContDiffOn 𝕜 N g s\nhs : UniqueDiffOn 𝕜 s\nx : E\nhx : Membership.mem s x\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => HSMul.hSMul (f y) (g y)) s x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x)))","decl":"theorem norm_iteratedFDerivWithin_smul_le {f : E → 𝕜'} {g : E → F} {N : WithTop ℕ∞}\n    (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s) {x : E} (hx : x ∈ s)\n    {n : ℕ} (hn : n ≤ N) : ‖iteratedFDerivWithin 𝕜 n (fun y => f y • g y) s x‖ ≤\n      ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ :=\n  (ContinuousLinearMap.lsmul 𝕜 𝕜' :\n    𝕜' →L[𝕜] F →L[𝕜] F).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one\n      hf hg hs hx hn ContinuousLinearMap.opNorm_lsmul_le\n\n"}
{"name":"norm_iteratedFDeriv_smul_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\n𝕜' : Type u_2\ninst✝³ : NormedField 𝕜'\ninst✝² : NormedAlgebra 𝕜 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nf : E → 𝕜'\ng : E → F\nN : WithTop ENat\nhf : ContDiff 𝕜 N f\nhg : ContDiff 𝕜 N g\nx : E\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => HSMul.hSMul (f y) (g y)) x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDeriv 𝕜 i f x))) (Norm.norm (iteratedFDeriv 𝕜 (HSub.hSub n i) g x)))","decl":"theorem norm_iteratedFDeriv_smul_le {f : E → 𝕜'} {g : E → F} {N : WithTop ℕ∞} (hf : ContDiff 𝕜 N f)\n    (hg : ContDiff 𝕜 N g) (x : E) {n : ℕ} (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (fun y => f y • g y) x‖ ≤ ∑ i ∈ Finset.range (n + 1),\n      (n.choose i : ℝ) * ‖iteratedFDeriv 𝕜 i f x‖ * ‖iteratedFDeriv 𝕜 (n - i) g x‖ :=\n  (ContinuousLinearMap.lsmul 𝕜 𝕜' : 𝕜' →L[𝕜] F →L[𝕜] F).norm_iteratedFDeriv_le_of_bilinear_of_le_one\n    hf hg x hn ContinuousLinearMap.opNorm_lsmul_le\n\n"}
{"name":"norm_iteratedFDerivWithin_mul_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nA : Type u_3\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\nN : WithTop ENat\nhf : ContDiffOn 𝕜 N f s\nhg : ContDiffOn 𝕜 N g s\nhs : UniqueDiffOn 𝕜 s\nx : E\nhx : Membership.mem s x\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => HMul.hMul (f y) (g y)) s x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x)))","decl":"theorem norm_iteratedFDerivWithin_mul_le {f : E → A} {g : E → A} {N : WithTop ℕ∞}\n    (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s) (hs : UniqueDiffOn 𝕜 s)\n    {x : E} (hx : x ∈ s) {n : ℕ} (hn : n ≤ N) :\n    ‖iteratedFDerivWithin 𝕜 n (fun y => f y * g y) s x‖ ≤\n      ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ :=\n  (ContinuousLinearMap.mul 𝕜 A :\n    A →L[𝕜] A →L[𝕜] A).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one\n      hf hg hs hx hn (ContinuousLinearMap.opNorm_mul_le _ _)\n\n"}
{"name":"norm_iteratedFDeriv_mul_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nA : Type u_3\ninst✝¹ : NormedRing A\ninst✝ : NormedAlgebra 𝕜 A\nf g : E → A\nN : WithTop ENat\nhf : ContDiff 𝕜 N f\nhg : ContDiff 𝕜 N g\nx : E\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => HMul.hMul (f y) (g y)) x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDeriv 𝕜 i f x))) (Norm.norm (iteratedFDeriv 𝕜 (HSub.hSub n i) g x)))","decl":"theorem norm_iteratedFDeriv_mul_le {f : E → A} {g : E → A} {N : WithTop ℕ∞} (hf : ContDiff 𝕜 N f)\n    (hg : ContDiff 𝕜 N g) (x : E) {n : ℕ} (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (fun y => f y * g y) x‖ ≤ ∑ i ∈ Finset.range (n + 1),\n      (n.choose i : ℝ) * ‖iteratedFDeriv 𝕜 i f x‖ * ‖iteratedFDeriv 𝕜 (n - i) g x‖ := by\n  simp_rw [← iteratedFDerivWithin_univ]\n  exact norm_iteratedFDerivWithin_mul_le\n    hf.contDiffOn hg.contDiffOn uniqueDiffOn_univ (mem_univ x) hn\n\n-- TODO: Add `norm_iteratedFDeriv[Within]_list_prod_le` for non-commutative `NormedRing A`.\n\n"}
{"name":"norm_iteratedFDerivWithin_prod_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_2\nA' : Type u_4\ninst✝³ : NormedCommRing A'\ninst✝² : NormedAlgebra 𝕜 A'\ninst✝¹ : DecidableEq ι\ninst✝ : NormOneClass A'\nu : Finset ι\nf : ι → E → A'\nN : WithTop ENat\nhf : ∀ (i : ι), Membership.mem u i → ContDiffOn 𝕜 N (f i) s\nhs : UniqueDiffOn 𝕜 s\nx : E\nhx : Membership.mem s x\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun x => u.prod fun j => f j x) s x)) ((u.sym n).sum fun p => HMul.hMul (↑(↑p).multinomial) (u.prod fun j => Norm.norm (iteratedFDerivWithin 𝕜 (Multiset.count j ↑p) (f j) s x)))","decl":"theorem norm_iteratedFDerivWithin_prod_le [DecidableEq ι] [NormOneClass A'] {u : Finset ι}\n    {f : ι → E → A'} {N : WithTop ℕ∞} (hf : ∀ i ∈ u, ContDiffOn 𝕜 N (f i) s)\n    (hs : UniqueDiffOn 𝕜 s) {x : E} (hx : x ∈ s) {n : ℕ} (hn : n ≤ N) :\n    ‖iteratedFDerivWithin 𝕜 n (∏ j ∈ u, f j ·) s x‖ ≤\n      ∑ p ∈ u.sym n, (p : Multiset ι).multinomial *\n        ∏ j ∈ u, ‖iteratedFDerivWithin 𝕜 (Multiset.count j p) (f j) s x‖ := by\n  induction u using Finset.induction generalizing n with\n  | empty =>\n    cases n with\n    | zero => simp [Sym.eq_nil_of_card_zero]\n    | succ n => simp [iteratedFDerivWithin_succ_const]\n  | @insert i u hi IH =>\n    conv => lhs; simp only [Finset.prod_insert hi]\n    simp only [Finset.mem_insert, forall_eq_or_imp] at hf\n    refine le_trans (norm_iteratedFDerivWithin_mul_le hf.1 (contDiffOn_prod hf.2) hs hx hn) ?_\n    rw [← Finset.sum_coe_sort (Finset.sym _ _)]\n    rw [Finset.sum_equiv (Finset.symInsertEquiv hi) (t := Finset.univ)\n      (g := (fun v ↦ v.multinomial *\n          ∏ j ∈ insert i u, ‖iteratedFDerivWithin 𝕜 (v.count j) (f j) s x‖) ∘\n        Sym.toMultiset ∘ Subtype.val ∘ (Finset.symInsertEquiv hi).symm)\n      (by simp) (by simp only [← comp_apply (g := Finset.symInsertEquiv hi), comp_assoc]; simp)]\n    rw [← Finset.univ_sigma_univ, Finset.sum_sigma, Finset.sum_range]\n    simp only [comp_apply, Finset.symInsertEquiv_symm_apply_coe]\n    refine Finset.sum_le_sum ?_\n    intro m _\n    specialize IH hf.2 (n := n - m) (le_trans (by exact_mod_cast n.sub_le m) hn)\n    refine le_trans (mul_le_mul_of_nonneg_left IH (by simp [mul_nonneg])) ?_\n    rw [Finset.mul_sum, ← Finset.sum_coe_sort]\n    refine Finset.sum_le_sum ?_\n    simp only [Finset.mem_univ, forall_true_left, Subtype.forall, Finset.mem_sym_iff]\n    intro p hp\n    refine le_of_eq ?_\n    rw [Finset.prod_insert hi]\n    have hip : i ∉ p := mt (hp i) hi\n    rw [Sym.count_coe_fill_self_of_not_mem hip, Sym.multinomial_coe_fill_of_not_mem hip]\n    suffices ∏ j ∈ u, ‖iteratedFDerivWithin 𝕜 (Multiset.count j p) (f j) s x‖ =\n        ∏ j ∈ u, ‖iteratedFDerivWithin 𝕜 (Multiset.count j (Sym.fill i m p)) (f j) s x‖ by\n      rw [this, Nat.cast_mul]\n      ring\n    refine Finset.prod_congr rfl ?_\n    intro j hj\n    have hji : j ≠ i := mt (· ▸ hj) hi\n    rw [Sym.count_coe_fill_of_ne hji]\n\n"}
{"name":"norm_iteratedFDeriv_prod_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nι : Type u_2\nA' : Type u_4\ninst✝³ : NormedCommRing A'\ninst✝² : NormedAlgebra 𝕜 A'\ninst✝¹ : DecidableEq ι\ninst✝ : NormOneClass A'\nu : Finset ι\nf : ι → E → A'\nN : WithTop ENat\nhf : ∀ (i : ι), Membership.mem u i → ContDiff 𝕜 N (f i)\nx : E\nn : Nat\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun x => u.prod fun j => f j x) x)) ((u.sym n).sum fun p => HMul.hMul (↑(↑p).multinomial) (u.prod fun j => Norm.norm (iteratedFDeriv 𝕜 (Multiset.count j ↑p) (f j) x)))","decl":"theorem norm_iteratedFDeriv_prod_le [DecidableEq ι] [NormOneClass A'] {u : Finset ι}\n    {f : ι → E → A'} {N : WithTop ℕ∞} (hf : ∀ i ∈ u, ContDiff 𝕜 N (f i)) {x : E} {n : ℕ}\n    (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (∏ j ∈ u, f j ·) x‖ ≤\n      ∑ p ∈ u.sym n, (p : Multiset ι).multinomial *\n        ∏ j ∈ u, ‖iteratedFDeriv 𝕜 ((p : Multiset ι).count j) (f j) x‖ := by\n  simpa [iteratedFDerivWithin_univ] using\n    norm_iteratedFDerivWithin_prod_le (fun i hi ↦ (hf i hi).contDiffOn) uniqueDiffOn_univ\n      (mem_univ x) hn\n\n"}
{"name":"norm_iteratedFDerivWithin_comp_le_aux","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nFu Gu : Type u\ninst✝³ : NormedAddCommGroup Fu\ninst✝² : NormedSpace 𝕜 Fu\ninst✝¹ : NormedAddCommGroup Gu\ninst✝ : NormedSpace 𝕜 Gu\ng : Fu → Gu\nf : E → Fu\nn : Nat\ns : Set E\nt : Set Fu\nx : E\nhg : ContDiffOn 𝕜 (↑n) g t\nhf : ContDiffOn 𝕜 (↑n) f s\nht : UniqueDiffOn 𝕜 t\nhs : UniqueDiffOn 𝕜 s\nhst : Set.MapsTo f s t\nhx : Membership.mem s x\nC D : Real\nhC : ∀ (i : Nat), LE.le i n → LE.le (Norm.norm (iteratedFDerivWithin 𝕜 i g t (f x))) C\nhD : ∀ (i : Nat), LE.le 1 i → LE.le i n → LE.le (Norm.norm (iteratedFDerivWithin 𝕜 i f s x)) (HPow.hPow D i)\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (Function.comp g f) s x)) (HMul.hMul (HMul.hMul (↑n.factorial) C) (HPow.hPow D n))","decl":"/-- If the derivatives within a set of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nwithin a set of `f` at `x` is bounded by `D^i` for all `1 ≤ i ≤ n`, then the `n`-th derivative\nof `g ∘ f` is bounded by `n! * C * D^n`.\nThis lemma proves this estimate assuming additionally that two of the spaces live in the same\nuniverse, to make an induction possible. Use instead `norm_iteratedFDerivWithin_comp_le` that\nremoves this assumption. -/\ntheorem norm_iteratedFDerivWithin_comp_le_aux {Fu Gu : Type u} [NormedAddCommGroup Fu]\n    [NormedSpace 𝕜 Fu] [NormedAddCommGroup Gu] [NormedSpace 𝕜 Gu] {g : Fu → Gu} {f : E → Fu} {n : ℕ}\n    {s : Set E} {t : Set Fu} {x : E} (hg : ContDiffOn 𝕜 n g t) (hf : ContDiffOn 𝕜 n f s)\n    (ht : UniqueDiffOn 𝕜 t) (hs : UniqueDiffOn 𝕜 s) (hst : MapsTo f s t) (hx : x ∈ s) {C : ℝ}\n    {D : ℝ} (hC : ∀ i, i ≤ n → ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ ≤ C)\n    (hD : ∀ i, 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i) :\n    ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ ≤ n ! * C * D ^ n := by\n  /- We argue by induction on `n`, using that `D^(n+1) (g ∘ f) = D^n (g ' ∘ f ⬝ f')`. The successive\n    derivatives of `g' ∘ f` are controlled thanks to the inductive assumption, and those of `f'` are\n    controlled by assumption.\n    As composition of linear maps is a bilinear map, one may use\n    `ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear_of_le_one` to get from these a bound\n    on `D^n (g ' ∘ f ⬝ f')`. -/\n  induction' n using Nat.case_strong_induction_on with n IH generalizing Gu\n  · simpa [norm_iteratedFDerivWithin_zero, Nat.factorial_zero, algebraMap.coe_one, one_mul,\n      pow_zero, mul_one, comp_apply] using hC 0 le_rfl\n  have M : (n : WithTop ℕ∞) < n.succ := Nat.cast_lt.2 n.lt_succ_self\n  have Cnonneg : 0 ≤ C := (norm_nonneg _).trans (hC 0 bot_le)\n  have Dnonneg : 0 ≤ D := by\n    have : 1 ≤ n + 1 := by simp only [le_add_iff_nonneg_left, zero_le']\n    simpa only [pow_one] using (norm_nonneg _).trans (hD 1 le_rfl this)\n  -- use the inductive assumption to bound the derivatives of `g' ∘ f`.\n  have I : ∀ i ∈ Finset.range (n + 1),\n      ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 g t ∘ f) s x‖ ≤ i ! * C * D ^ i := by\n    intro i hi\n    simp only [Finset.mem_range_succ_iff] at hi\n    apply IH i hi\n    · apply hg.fderivWithin ht\n      simp only [Nat.cast_succ]\n      exact add_le_add_right (Nat.cast_le.2 hi) _\n    · apply hf.of_le (Nat.cast_le.2 (hi.trans n.le_succ))\n    · intro j hj\n      have : ‖iteratedFDerivWithin 𝕜 j (fderivWithin 𝕜 g t) t (f x)‖ =\n          ‖iteratedFDerivWithin 𝕜 (j + 1) g t (f x)‖ := by\n        rw [iteratedFDerivWithin_succ_eq_comp_right ht (hst hx), comp_apply,\n          LinearIsometryEquiv.norm_map]\n      rw [this]\n      exact hC (j + 1) (add_le_add (hj.trans hi) le_rfl)\n    · intro j hj h'j\n      exact hD j hj (h'j.trans (hi.trans n.le_succ))\n  -- reformulate `hD` as a bound for the derivatives of `f'`.\n  have J : ∀ i, ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ ≤ D ^ (n - i + 1) := by\n    intro i\n    have : ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ =\n        ‖iteratedFDerivWithin 𝕜 (n - i + 1) f s x‖ := by\n      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply, LinearIsometryEquiv.norm_map]\n    rw [this]\n    apply hD\n    · simp only [le_add_iff_nonneg_left, zero_le']\n    · apply Nat.succ_le_succ tsub_le_self\n  -- Now put these together: first, notice that we have to bound `D^n (g' ∘ f ⬝ f')`.\n  calc\n    ‖iteratedFDerivWithin 𝕜 (n + 1) (g ∘ f) s x‖ =\n        ‖iteratedFDerivWithin 𝕜 n (fun y : E => fderivWithin 𝕜 (g ∘ f) s y) s x‖ := by\n      rw [iteratedFDerivWithin_succ_eq_comp_right hs hx, comp_apply,\n        LinearIsometryEquiv.norm_map]\n    _ = ‖iteratedFDerivWithin 𝕜 n (fun y : E => ContinuousLinearMap.compL 𝕜 E Fu Gu\n        (fderivWithin 𝕜 g t (f y)) (fderivWithin 𝕜 f s y)) s x‖ := by\n      have L : (1 : WithTop ℕ∞) ≤ n.succ := by\n        simpa only [ENat.coe_one, Nat.one_le_cast] using n.succ_pos\n      congr 1\n      refine iteratedFDerivWithin_congr (fun y hy => ?_) hx _\n      apply fderivWithin_comp _ _ _ hst (hs y hy)\n      · exact hg.differentiableOn L _ (hst hy)\n      · exact hf.differentiableOn L _ hy\n    -- bound it using the fact that the composition of linear maps is a bilinear operation,\n    -- for which we have bounds for the`n`-th derivative.\n    _ ≤ ∑ i ∈ Finset.range (n + 1),\n        (n.choose i : ℝ) * ‖iteratedFDerivWithin 𝕜 i (fderivWithin 𝕜 g t ∘ f) s x‖ *\n          ‖iteratedFDerivWithin 𝕜 (n - i) (fderivWithin 𝕜 f s) s x‖ := by\n      have A : ContDiffOn 𝕜 n (fderivWithin 𝕜 g t ∘ f) s := by\n        apply ContDiffOn.comp _ (hf.of_le M.le) hst\n        apply hg.fderivWithin ht\n        simp only [Nat.cast_succ, le_refl]\n      have B : ContDiffOn 𝕜 n (fderivWithin 𝕜 f s) s := by\n        apply hf.fderivWithin hs\n        simp only [Nat.cast_succ, le_refl]\n      exact (ContinuousLinearMap.compL 𝕜 E Fu Gu).norm_iteratedFDerivWithin_le_of_bilinear_of_le_one\n        A B hs hx le_rfl (ContinuousLinearMap.norm_compL_le 𝕜 E Fu Gu)\n    -- bound each of the terms using the estimates on previous derivatives (that use the inductive\n    -- assumption for `g' ∘ f`).\n    _ ≤ ∑ i ∈ Finset.range (n + 1), (n.choose i : ℝ) * (i ! * C * D ^ i) * D ^ (n - i + 1) := by\n      gcongr with i hi\n      · exact I i hi\n      · exact J i\n    -- We are left with trivial algebraic manipulations to see that this is smaller than\n    -- the claimed bound.\n    _ = ∑ i ∈ Finset.range (n + 1),\n      -- Porting note: had to insert a few more explicit type ascriptions in this and similar\n      -- expressions.\n        (n ! : ℝ) * ((i ! : ℝ)⁻¹ * i !) * C * (D ^ i * D ^ (n - i + 1)) * ((n - i)! : ℝ)⁻¹ := by\n      congr! 1 with i hi\n      simp only [Nat.cast_choose ℝ (Finset.mem_range_succ_iff.1 hi), div_eq_inv_mul, mul_inv]\n      ring\n    _ = ∑ i ∈ Finset.range (n + 1), (n ! : ℝ) * 1 * C * D ^ (n + 1) * ((n - i)! : ℝ)⁻¹ := by\n      congr! with i hi\n      · apply inv_mul_cancel₀\n        simpa only [Ne, Nat.cast_eq_zero] using i.factorial_ne_zero\n      · rw [← pow_add]\n        congr 1\n        rw [Nat.add_succ, Nat.succ_inj']\n        exact Nat.add_sub_of_le (Finset.mem_range_succ_iff.1 hi)\n    _ ≤ ∑ i ∈ Finset.range (n + 1), (n ! : ℝ) * 1 * C * D ^ (n + 1) * 1 := by\n      gcongr with i\n      apply inv_le_one_of_one_le₀\n      simpa only [Nat.one_le_cast] using (n - i).factorial_pos\n    _ = (n + 1)! * C * D ^ (n + 1) := by\n      simp only [mul_assoc, mul_one, Finset.sum_const, Finset.card_range, nsmul_eq_mul,\n        Nat.factorial_succ, Nat.cast_mul]\n\n"}
{"name":"norm_iteratedFDerivWithin_comp_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nn : Nat\ns : Set E\nt : Set F\nx : E\nN : WithTop ENat\nhg : ContDiffOn 𝕜 N g t\nhf : ContDiffOn 𝕜 N f s\nhn : LE.le (↑n) N\nht : UniqueDiffOn 𝕜 t\nhs : UniqueDiffOn 𝕜 s\nhst : Set.MapsTo f s t\nhx : Membership.mem s x\nC D : Real\nhC : ∀ (i : Nat), LE.le i n → LE.le (Norm.norm (iteratedFDerivWithin 𝕜 i g t (f x))) C\nhD : ∀ (i : Nat), LE.le 1 i → LE.le i n → LE.le (Norm.norm (iteratedFDerivWithin 𝕜 i f s x)) (HPow.hPow D i)\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (Function.comp g f) s x)) (HMul.hMul (HMul.hMul (↑n.factorial) C) (HPow.hPow D n))","decl":"/-- If the derivatives within a set of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nwithin a set of `f` at `x` is bounded by `D^i` for all `1 ≤ i ≤ n`, then the `n`-th derivative\nof `g ∘ f` is bounded by `n! * C * D^n`. -/\ntheorem norm_iteratedFDerivWithin_comp_le {g : F → G} {f : E → F} {n : ℕ} {s : Set E} {t : Set F}\n    {x : E} {N : WithTop ℕ∞} (hg : ContDiffOn 𝕜 N g t) (hf : ContDiffOn 𝕜 N f s) (hn : n ≤ N)\n    (ht : UniqueDiffOn 𝕜 t) (hs : UniqueDiffOn 𝕜 s) (hst : MapsTo f s t) (hx : x ∈ s) {C : ℝ}\n    {D : ℝ} (hC : ∀ i, i ≤ n → ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ ≤ C)\n    (hD : ∀ i, 1 ≤ i → i ≤ n → ‖iteratedFDerivWithin 𝕜 i f s x‖ ≤ D ^ i) :\n    ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ ≤ n ! * C * D ^ n := by\n  /- We reduce the bound to the case where all spaces live in the same universe (in which we\n    already have proved the result), by using linear isometries between the spaces and their `ULift`\n    to a common universe. These linear isometries preserve the norm of the iterated derivative. -/\n  let Fu : Type max uF uG := ULift.{uG, uF} F\n  let Gu : Type max uF uG := ULift.{uF, uG} G\n  have isoF : Fu ≃ₗᵢ[𝕜] F := LinearIsometryEquiv.ulift 𝕜 F\n  have isoG : Gu ≃ₗᵢ[𝕜] G := LinearIsometryEquiv.ulift 𝕜 G\n  -- lift `f` and `g` to versions `fu` and `gu` on the lifted spaces.\n  let fu : E → Fu := isoF.symm ∘ f\n  let gu : Fu → Gu := isoG.symm ∘ g ∘ isoF\n  let tu := isoF ⁻¹' t\n  have htu : UniqueDiffOn 𝕜 tu := isoF.toContinuousLinearEquiv.uniqueDiffOn_preimage_iff.2 ht\n  have hstu : MapsTo fu s tu := fun y hy ↦ by\n    simpa only [fu, tu, mem_preimage, comp_apply, LinearIsometryEquiv.apply_symm_apply] using hst hy\n  have Ffu : isoF (fu x) = f x := by\n    simp only [fu, comp_apply, LinearIsometryEquiv.apply_symm_apply]\n  -- All norms are preserved by the lifting process.\n  have hfu : ContDiffOn 𝕜 n fu s := isoF.symm.contDiff.comp_contDiffOn (hf.of_le hn)\n  have hgu : ContDiffOn 𝕜 n gu tu :=\n    isoG.symm.contDiff.comp_contDiffOn\n      ((hg.of_le hn).comp_continuousLinearMap (isoF : Fu →L[𝕜] F))\n  have Nfu : ∀ i, ‖iteratedFDerivWithin 𝕜 i fu s x‖ = ‖iteratedFDerivWithin 𝕜 i f s x‖ := fun i ↦ by\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ hs hx]\n  simp_rw [← Nfu] at hD\n  have Ngu : ∀ i,\n      ‖iteratedFDerivWithin 𝕜 i gu tu (fu x)‖ = ‖iteratedFDerivWithin 𝕜 i g t (f x)‖ := fun i ↦ by\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ htu (hstu hx)]\n    rw [LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right _ _ ht, Ffu]\n    rw [Ffu]\n    exact hst hx\n  simp_rw [← Ngu] at hC\n  have Nfgu :\n      ‖iteratedFDerivWithin 𝕜 n (g ∘ f) s x‖ = ‖iteratedFDerivWithin 𝕜 n (gu ∘ fu) s x‖ := by\n    have : gu ∘ fu = isoG.symm ∘ g ∘ f := by\n      ext x\n      simp only [fu, gu, comp_apply, LinearIsometryEquiv.map_eq_iff,\n        LinearIsometryEquiv.apply_symm_apply]\n    rw [this, LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left _ _ hs hx]\n  -- deduce the required bound from the one for `gu ∘ fu`.\n  rw [Nfgu]\n  exact norm_iteratedFDerivWithin_comp_le_aux hgu hfu htu hs hstu hx hC hD\n\n"}
{"name":"norm_iteratedFDeriv_comp_le","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : F → G\nf : E → F\nn : Nat\nN : WithTop ENat\nhg : ContDiff 𝕜 N g\nhf : ContDiff 𝕜 N f\nhn : LE.le (↑n) N\nx : E\nC D : Real\nhC : ∀ (i : Nat), LE.le i n → LE.le (Norm.norm (iteratedFDeriv 𝕜 i g (f x))) C\nhD : ∀ (i : Nat), LE.le 1 i → LE.le i n → LE.le (Norm.norm (iteratedFDeriv 𝕜 i f x)) (HPow.hPow D i)\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (Function.comp g f) x)) (HMul.hMul (HMul.hMul (↑n.factorial) C) (HPow.hPow D n))","decl":"/-- If the derivatives of `g` at `f x` are bounded by `C`, and the `i`-th derivative\nof `f` at `x` is bounded by `D^i` for all `1 ≤ i ≤ n`, then the `n`-th derivative\nof `g ∘ f` is bounded by `n! * C * D^n`. -/\ntheorem norm_iteratedFDeriv_comp_le {g : F → G} {f : E → F} {n : ℕ} {N : WithTop ℕ∞}\n    (hg : ContDiff 𝕜 N g) (hf : ContDiff 𝕜 N f) (hn : n ≤ N) (x : E) {C : ℝ} {D : ℝ}\n    (hC : ∀ i, i ≤ n → ‖iteratedFDeriv 𝕜 i g (f x)‖ ≤ C)\n    (hD : ∀ i, 1 ≤ i → i ≤ n → ‖iteratedFDeriv 𝕜 i f x‖ ≤ D ^ i) :\n    ‖iteratedFDeriv 𝕜 n (g ∘ f) x‖ ≤ n ! * C * D ^ n := by\n  simp_rw [← iteratedFDerivWithin_univ] at hC hD ⊢\n  exact norm_iteratedFDerivWithin_comp_le hg.contDiffOn hf.contDiffOn hn uniqueDiffOn_univ\n    uniqueDiffOn_univ (mapsTo_univ _ _) (mem_univ x) hC hD\n\n"}
{"name":"norm_iteratedFDerivWithin_clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\ns : Set E\nx : E\nN : WithTop ENat\nn : Nat\nhf : ContDiffOn 𝕜 N f s\nhg : ContDiffOn 𝕜 N g s\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => (f y) (g y)) s x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))) (Norm.norm (iteratedFDerivWithin 𝕜 (HSub.hSub n i) g s x)))","decl":"theorem norm_iteratedFDerivWithin_clm_apply {f : E → F →L[𝕜] G} {g : E → F} {s : Set E} {x : E}\n    {N : WithTop ℕ∞} {n : ℕ} (hf : ContDiffOn 𝕜 N f s) (hg : ContDiffOn 𝕜 N g s)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (hn : n ≤ N) :\n    ‖iteratedFDerivWithin 𝕜 n (fun y => (f y) (g y)) s x‖ ≤\n      ∑ i ∈ Finset.range (n + 1), ↑(n.choose i) * ‖iteratedFDerivWithin 𝕜 i f s x‖ *\n        ‖iteratedFDerivWithin 𝕜 (n - i) g s x‖ := by\n  let B : (F →L[𝕜] G) →L[𝕜] F →L[𝕜] G := ContinuousLinearMap.flip (ContinuousLinearMap.apply 𝕜 G)\n  have hB : ‖B‖ ≤ 1 := by\n    simp only [B, ContinuousLinearMap.opNorm_flip, ContinuousLinearMap.apply]\n    refine ContinuousLinearMap.opNorm_le_bound _ zero_le_one fun f => ?_\n    simp only [ContinuousLinearMap.coe_id', id, one_mul]\n    rfl\n  exact B.norm_iteratedFDerivWithin_le_of_bilinear_of_le_one hf hg hs hx hn hB\n\n"}
{"name":"norm_iteratedFDeriv_clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\nN : WithTop ENat\nn : Nat\nhf : ContDiff 𝕜 N f\nhg : ContDiff 𝕜 N g\nx : E\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => (f y) (g y)) x)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HMul.hMul (HMul.hMul (↑(n.choose i)) (Norm.norm (iteratedFDeriv 𝕜 i f x))) (Norm.norm (iteratedFDeriv 𝕜 (HSub.hSub n i) g x)))","decl":"theorem norm_iteratedFDeriv_clm_apply {f : E → F →L[𝕜] G} {g : E → F} {N : WithTop ℕ∞} {n : ℕ}\n    (hf : ContDiff 𝕜 N f) (hg : ContDiff 𝕜 N g) (x : E) (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (fun y : E => (f y) (g y)) x‖ ≤ ∑ i ∈ Finset.range (n + 1),\n      ↑(n.choose i) * ‖iteratedFDeriv 𝕜 i f x‖ * ‖iteratedFDeriv 𝕜 (n - i) g x‖ := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact norm_iteratedFDerivWithin_clm_apply hf.contDiffOn hg.contDiffOn uniqueDiffOn_univ\n    (Set.mem_univ x) hn\n\n"}
{"name":"norm_iteratedFDerivWithin_clm_apply_const","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nc : F\ns : Set E\nx : E\nN : WithTop ENat\nn : Nat\nhf : ContDiffWithinAt 𝕜 N f s x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDerivWithin 𝕜 n (fun y => (f y) c) s x)) (HMul.hMul (Norm.norm c) (Norm.norm (iteratedFDerivWithin 𝕜 n f s x)))","decl":"theorem norm_iteratedFDerivWithin_clm_apply_const {f : E → F →L[𝕜] G} {c : F} {s : Set E} {x : E}\n    {N : WithTop ℕ∞} {n : ℕ} (hf : ContDiffWithinAt 𝕜 N f s x) (hs : UniqueDiffOn 𝕜 s)\n    (hx : x ∈ s) (hn : n ≤ N) :\n    ‖iteratedFDerivWithin 𝕜 n (fun y : E => (f y) c) s x‖ ≤\n      ‖c‖ * ‖iteratedFDerivWithin 𝕜 n f s x‖ := by\n  let g : (F →L[𝕜] G) →L[𝕜] G := ContinuousLinearMap.apply 𝕜 G c\n  have h := g.norm_compContinuousMultilinearMap_le (iteratedFDerivWithin 𝕜 n f s x)\n  rw [← g.iteratedFDerivWithin_comp_left hf hs hx hn] at h\n  refine h.trans (mul_le_mul_of_nonneg_right ?_ (norm_nonneg _))\n  refine g.opNorm_le_bound (norm_nonneg _) fun f => ?_\n  rw [ContinuousLinearMap.apply_apply, mul_comm]\n  exact f.le_opNorm c\n\n"}
{"name":"norm_iteratedFDeriv_clm_apply_const","module":"Mathlib.Analysis.Calculus.ContDiff.Bounds","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nc : F\nx : E\nN : WithTop ENat\nn : Nat\nhf : ContDiffAt 𝕜 N f x\nhn : LE.le (↑n) N\n⊢ LE.le (Norm.norm (iteratedFDeriv 𝕜 n (fun y => (f y) c) x)) (HMul.hMul (Norm.norm c) (Norm.norm (iteratedFDeriv 𝕜 n f x)))","decl":"theorem norm_iteratedFDeriv_clm_apply_const {f : E → F →L[𝕜] G} {c : F} {x : E}\n    {N : WithTop ℕ∞} {n : ℕ} (hf : ContDiffAt 𝕜 N f x) (hn : n ≤ N) :\n    ‖iteratedFDeriv 𝕜 n (fun y : E => (f y) c) x‖ ≤ ‖c‖ * ‖iteratedFDeriv 𝕜 n f x‖ := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact norm_iteratedFDerivWithin_clm_apply_const hf.contDiffWithinAt uniqueDiffOn_univ\n    (Set.mem_univ x) hn\n\n"}
