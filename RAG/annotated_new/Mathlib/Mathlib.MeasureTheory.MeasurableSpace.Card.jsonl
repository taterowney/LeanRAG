{"name":"MeasurableSpace.self_subset_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{u_1}\nâŠ¢ HasSubset.Subset s (MeasurableSpace.generateMeasurableRec s i)","decl":"theorem self_subset_generateMeasurableRec (s : Set (Set Î±)) (i : Ordinal) :\n    s âŠ† generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  apply_rules [subset_union_of_subset_left]\n  exact subset_rfl\n\n"}
{"name":"MeasurableSpace.empty_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{u_1}\nâŠ¢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) EmptyCollection.emptyCollection","decl":"theorem empty_mem_generateMeasurableRec (s : Set (Set Î±)) (i : Ordinal) :\n    âˆ… âˆˆ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_left _ (mem_union_left _ (mem_union_right _ (mem_singleton âˆ…)))\n\n"}
{"name":"MeasurableSpace.compl_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni j : Ordinal.{u_1}\nh : LT.lt j i\nt : Set Î±\nht : Membership.mem (MeasurableSpace.generateMeasurableRec s j) t\nâŠ¢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) (HasCompl.compl t)","decl":"theorem compl_mem_generateMeasurableRec {s : Set (Set Î±)} {i j : Ordinal} (h : j < i) {t : Set Î±}\n    (ht : t âˆˆ generateMeasurableRec s j) : tá¶œ âˆˆ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_left _ (mem_union_right _ âŸ¨t, mem_iUnionâ‚‚.2 âŸ¨j, h, htâŸ©, rflâŸ©)\n\n"}
{"name":"MeasurableSpace.iUnion_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{u_1}\nf : Nat â†’ Set Î±\nhf : âˆ€ (n : Nat), Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) (f n))\nâŠ¢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) (Set.iUnion fun n => f n)","decl":"theorem iUnion_mem_generateMeasurableRec {s : Set (Set Î±)} {i : Ordinal} {f : â„• â†’ Set Î±}\n    (hf : âˆ€ n, âˆƒ j < i, f n âˆˆ generateMeasurableRec s j) :\n    â‹ƒ n, f n âˆˆ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_right _ âŸ¨fun n => âŸ¨f n, let âŸ¨j, hj, hfâŸ© := hf n; mem_iUnionâ‚‚.2 âŸ¨j, hj, hfâŸ©âŸ©, rflâŸ©\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ Monotone (MeasurableSpace.generateMeasurableRec s)","decl":"theorem generateMeasurableRec_mono (s : Set (Set Î±)) : Monotone (generateMeasurableRec s) := by\n  intro i j h x hx\n  rcases h.eq_or_lt with (rfl | h)\n  Â· exact hx\n  Â· convert iUnion_mem_generateMeasurableRec fun _ => âŸ¨i, h, hxâŸ©\n    exact (iUnion_const x).symm\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_induction","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{u_1}\nt : Set Î±\np : Set Î± â†’ Prop\nhs : âˆ€ (t : Set Î±), Membership.mem s t â†’ p t\nh0 : p EmptyCollection.emptyCollection\nhc : âˆ€ (u : Set Î±), p u â†’ (Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) u)) â†’ p (HasCompl.compl u)\nhn : âˆ€ (f : Nat â†’ Set Î±), (âˆ€ (n : Nat), And (p (f n)) (Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) (f n)))) â†’ p (Set.iUnion fun n => f n)\naâœ : Membership.mem (MeasurableSpace.generateMeasurableRec s i) t\nâŠ¢ p t","decl":"/-- An inductive principle for the elements of `generateMeasurableRec`. -/\n@[elab_as_elim]\ntheorem generateMeasurableRec_induction {s : Set (Set Î±)} {i : Ordinal} {t : Set Î±}\n    {p : Set Î± â†’ Prop} (hs : âˆ€ t âˆˆ s, p t) (h0 : p âˆ…)\n    (hc : âˆ€ u, p u â†’ (âˆƒ j < i, u âˆˆ generateMeasurableRec s j) â†’ p uá¶œ)\n    (hn : âˆ€ f : â„• â†’ Set Î±,\n      (âˆ€ n, p (f n) âˆ§ âˆƒ j < i, f n âˆˆ generateMeasurableRec s j) â†’ p (â‹ƒ n, f n)) :\n    t âˆˆ generateMeasurableRec s i â†’ p t := by\n  suffices H : âˆ€ k â‰¤ i, âˆ€ t âˆˆ generateMeasurableRec s k, p t from H i le_rfl t\n  intro k\n  apply WellFoundedLT.induction k\n  intro k IH hk t\n  replace IH := fun j hj => IH j hj (hj.le.trans hk)\n  unfold generateMeasurableRec\n  rintro (((ht | rfl) | ht) | âŸ¨f, rflâŸ©)\n  Â· exact hs t ht\n  Â· exact h0\n  Â· simp_rw [mem_image, mem_iUnionâ‚‚] at ht\n    obtain âŸ¨u, âŸ¨âŸ¨j, hj, hj'âŸ©, rflâŸ©âŸ© := ht\n    exact hc u (IH j hj u hj') âŸ¨j, hj.trans_le hk, hj'âŸ©\n  Â· apply hn\n    intro n\n    obtain âŸ¨j, hj, hj'âŸ© := mem_iUnionâ‚‚.1 (f n).2\n    use IH j hj _ hj', j, hj.trans_le hk\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_omega1","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ Eq (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1)) (Set.iUnion fun i => Set.iUnion fun h => MeasurableSpace.generateMeasurableRec s i)","decl":"theorem generateMeasurableRec_omega1 (s : Set (Set Î±)) :\n    generateMeasurableRec s (Ï‰â‚ : Ordinal.{v}) =\n      â‹ƒ i < (Ï‰â‚ : Ordinal.{v}), generateMeasurableRec s i := by\n  apply (iUnionâ‚‚_subset fun i h => generateMeasurableRec_mono s h.le).antisymm'\n  intro t ht\n  rw [mem_iUnionâ‚‚]\n  refine generateMeasurableRec_induction ?_ ?_ ?_ ?_ ht\n  Â· intro t ht\n    exact âŸ¨0, omega_pos 1, self_subset_generateMeasurableRec s 0 htâŸ©\n  Â· exact âŸ¨0, omega_pos 1, empty_mem_generateMeasurableRec s 0âŸ©\n  Â· rintro u - âŸ¨j, hj, hj'âŸ©\n    exact âŸ¨_, (isLimit_omega 1).succ_lt hj,\n      compl_mem_generateMeasurableRec (Order.lt_succ j) hj'âŸ©\n  Â· intro f H\n    choose I hI using fun n => (H n).1\n    simp_rw [exists_prop] at hI\n    refine âŸ¨_, Ordinal.lsub_lt_ord_lift ?_ fun n => (hI n).1,\n      iUnion_mem_generateMeasurableRec fun n => âŸ¨_, Ordinal.lt_lsub I n, (hI n).2âŸ©âŸ©\n    rw [mk_nat, lift_aleph0, isRegular_aleph_one.cof_omega_eq]\n    exact aleph0_lt_aleph_one\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_subset","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{u_1}\nâŠ¢ HasSubset.Subset (MeasurableSpace.generateMeasurableRec s i) (setOf fun t => MeasurableSpace.GenerateMeasurable s t)","decl":"theorem generateMeasurableRec_subset (s : Set (Set Î±)) (i : Ordinal) :\n    generateMeasurableRec s i âŠ† { t | GenerateMeasurable s t } := by\n  apply WellFoundedLT.induction i\n  exact fun i IH t ht => generateMeasurableRec_induction .basic .empty\n    (fun u _ âŸ¨j, hj, hj'âŸ© => .compl _ (IH j hj hj')) (fun f H => .iUnion _ fun n => (H n).1) ht\n\n"}
{"name":"MeasurableSpace.generateMeasurable_eq_rec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ Eq (setOf fun t => MeasurableSpace.GenerateMeasurable s t) (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1))","decl":"/-- `generateMeasurableRec s Ï‰â‚` generates precisely the smallest sigma-algebra containing `s`. -/\ntheorem generateMeasurable_eq_rec (s : Set (Set Î±)) :\n    { t | GenerateMeasurable s t } = generateMeasurableRec s Ï‰â‚ := by\n  apply (generateMeasurableRec_subset s _).antisymm'\n  intro t ht\n  induction' ht with u hu u _ IH f _ IH\n  Â· exact self_subset_generateMeasurableRec s _ hu\n  Â· exact empty_mem_generateMeasurableRec s _\n  Â· rw [generateMeasurableRec_omega1, mem_iUnionâ‚‚] at IH\n    obtain âŸ¨i, hi, hi'âŸ© := IH\n    exact generateMeasurableRec_mono _ ((isLimit_omega 1).succ_lt hi).le\n      (compl_mem_generateMeasurableRec (Order.lt_succ i) hi')\n  Â· simp_rw [generateMeasurableRec_omega1, mem_iUnionâ‚‚, exists_prop] at IH\n    exact iUnion_mem_generateMeasurableRec IH\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_of_omega1_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{v}\nhi : LE.le (Ordinal.omega 1) i\nâŠ¢ Eq (MeasurableSpace.generateMeasurableRec s i) (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1))","decl":"/-- `generateMeasurableRec` is constant for ordinals `â‰¥ Ï‰â‚`. -/\ntheorem generateMeasurableRec_of_omega1_le (s : Set (Set Î±)) {i : Ordinal.{v}} (hi : Ï‰â‚ â‰¤ i) :\n    generateMeasurableRec s i = generateMeasurableRec s (Ï‰â‚ : Ordinal.{v}) := by\n  apply (generateMeasurableRec_mono s hi).antisymm'\n  rw [â† generateMeasurable_eq_rec]\n  exact generateMeasurableRec_subset s i\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurableRec_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\ni : Ordinal.{v}\nâŠ¢ LE.le (Cardinal.mk â†‘(MeasurableSpace.generateMeasurableRec s i)) (HPow.hPow (Max.max (Cardinal.mk â†‘s) 2) Cardinal.aleph0)","decl":"/-- At each step of the inductive construction, the cardinality bound `â‰¤ #s ^ â„µâ‚€` holds. -/\ntheorem cardinal_generateMeasurableRec_le (s : Set (Set Î±)) (i : Ordinal.{v}) :\n    #(generateMeasurableRec s i) â‰¤ max #s 2 ^ â„µâ‚€ := by\n  suffices âˆ€ i â‰¤ Ï‰â‚, #(generateMeasurableRec s i) â‰¤ max #s 2 ^ â„µâ‚€ by\n    obtain hi | hi := le_or_lt i Ï‰â‚\n    Â· exact this i hi\n    Â· rw [generateMeasurableRec_of_omega1_le s hi.le]\n      exact this _ le_rfl\n  intro i\n  apply WellFoundedLT.induction i\n  intro i IH hi\n  have A : ğ”  â‰¤ max #s 2 ^ â„µâ‚€ := power_le_power_right (le_max_right _ _)\n  have B := aleph0_le_continuum.trans A\n  have C : #(â‹ƒ j < i, generateMeasurableRec s j) â‰¤ max #s 2 ^ â„µâ‚€ := by\n    apply mk_iUnion_Ordinal_lift_le_of_le _ B _\n    Â· intro j hj\n      exact IH j hj (hj.trans_le hi).le\n    Â· rw [lift_power, lift_aleph0]\n      rw [â† Ordinal.lift_le.{u}, lift_omega, Ordinal.lift_one, â† ord_aleph] at hi\n      have H := card_le_of_le_ord hi\n      rw [â† Ordinal.lift_card] at H\n      apply H.trans <| aleph_one_le_continuum.trans <| power_le_power_right _\n      rw [lift_max, Cardinal.lift_ofNat]\n      exact le_max_right _ _\n  rw [generateMeasurableRec]\n  apply_rules [(mk_union_le _ _).trans, add_le_of_le (aleph_one_le_continuum.trans A),\n    mk_image_le.trans]\n  Â· exact (self_le_power _ one_le_aleph0).trans (power_le_power_right (le_max_left _ _))\n  Â· rw [mk_singleton]\n    exact one_lt_aleph0.le.trans B\n  Â· apply mk_range_le.trans\n    simp only [mk_pi, prod_const, Cardinal.lift_uzero, mk_denumerable, lift_aleph0]\n    have := @power_le_power_right _ _ â„µâ‚€ C\n    rwa [â† power_mul, aleph0_mul_aleph0] at this\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurable_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ LE.le (Cardinal.mk â†‘(setOf fun t => MeasurableSpace.GenerateMeasurable s t)) (HPow.hPow (Max.max (Cardinal.mk â†‘s) 2) Cardinal.aleph0)","decl":"/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma-algebra has cardinality at\nmost `max #s 2 ^ â„µâ‚€`. -/\ntheorem cardinal_generateMeasurable_le (s : Set (Set Î±)) :\n    #{ t | GenerateMeasurable s t } â‰¤ max #s 2 ^ â„µâ‚€ := by\n  rw [generateMeasurable_eq_rec.{u, 0}]\n  exact cardinal_generateMeasurableRec_le s _\n\n"}
{"name":"MeasurableSpace.cardinal_measurableSet_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ LE.le (Cardinal.mk â†‘(setOf fun t => MeasurableSet t)) (HPow.hPow (Max.max (Cardinal.mk â†‘s) 2) Cardinal.aleph0)","decl":"/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma\nalgebra has cardinality at most `max #s 2 ^ â„µâ‚€`. -/\ntheorem cardinal_measurableSet_le (s : Set (Set Î±)) :\n    #{ t | @MeasurableSet Î± (generateFrom s) t } â‰¤ max #s 2 ^ â„µâ‚€ :=\n  cardinal_generateMeasurable_le s\n\n"}
{"name":"MeasurableSpace.cardinalMeasurableSet_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nâŠ¢ LE.le (Cardinal.mk â†‘(setOf fun t => MeasurableSet t)) (HPow.hPow (Max.max (Cardinal.mk â†‘s) 2) Cardinal.aleph0)","decl":"@[deprecated cardinal_measurableSet_le (since := \"2024-08-30\")]\nalias cardinalMeasurableSet_le := cardinal_measurableSet_le\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurable_le_continuum","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\nhs : LE.le (Cardinal.mk â†‘s) Cardinal.continuum\nâŠ¢ LE.le (Cardinal.mk â†‘(setOf fun t => MeasurableSpace.GenerateMeasurable s t)) Cardinal.continuum","decl":"/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. -/\ntheorem cardinal_generateMeasurable_le_continuum {s : Set (Set Î±)} (hs : #s â‰¤ ğ” ) :\n    #{ t | GenerateMeasurable s t } â‰¤ ğ”  := by\n  apply (cardinal_generateMeasurable_le s).trans\n  rw [â† continuum_power_aleph0]\n  exact_mod_cast power_le_power_right (max_le hs (nat_lt_continuum 2).le)\n\n"}
{"name":"MeasurableSpace.cardinal_measurableSet_le_continuum","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"Î± : Type u\ns : Set (Set Î±)\naâœ : LE.le (Cardinal.mk â†‘s) Cardinal.continuum\nâŠ¢ LE.le (Cardinal.mk â†‘(setOf fun t => MeasurableSet t)) Cardinal.continuum","decl":"/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. -/\ntheorem cardinal_measurableSet_le_continuum {s : Set (Set Î±)} :\n    #s â‰¤ ğ”  â†’ #{ t | @MeasurableSet Î± (generateFrom s) t } â‰¤ ğ”  :=\n  cardinal_generateMeasurable_le_continuum\n\n"}
