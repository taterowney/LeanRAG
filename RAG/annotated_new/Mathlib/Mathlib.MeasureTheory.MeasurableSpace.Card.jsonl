{"name":"MeasurableSpace.self_subset_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{u_1}\n⊢ HasSubset.Subset s (MeasurableSpace.generateMeasurableRec s i)","decl":"theorem self_subset_generateMeasurableRec (s : Set (Set α)) (i : Ordinal) :\n    s ⊆ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  apply_rules [subset_union_of_subset_left]\n  exact subset_rfl\n\n"}
{"name":"MeasurableSpace.empty_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{u_1}\n⊢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) EmptyCollection.emptyCollection","decl":"theorem empty_mem_generateMeasurableRec (s : Set (Set α)) (i : Ordinal) :\n    ∅ ∈ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_left _ (mem_union_left _ (mem_union_right _ (mem_singleton ∅)))\n\n"}
{"name":"MeasurableSpace.compl_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni j : Ordinal.{u_1}\nh : LT.lt j i\nt : Set α\nht : Membership.mem (MeasurableSpace.generateMeasurableRec s j) t\n⊢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) (HasCompl.compl t)","decl":"theorem compl_mem_generateMeasurableRec {s : Set (Set α)} {i j : Ordinal} (h : j < i) {t : Set α}\n    (ht : t ∈ generateMeasurableRec s j) : tᶜ ∈ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_left _ (mem_union_right _ ⟨t, mem_iUnion₂.2 ⟨j, h, ht⟩, rfl⟩)\n\n"}
{"name":"MeasurableSpace.iUnion_mem_generateMeasurableRec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{u_1}\nf : Nat → Set α\nhf : ∀ (n : Nat), Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) (f n))\n⊢ Membership.mem (MeasurableSpace.generateMeasurableRec s i) (Set.iUnion fun n => f n)","decl":"theorem iUnion_mem_generateMeasurableRec {s : Set (Set α)} {i : Ordinal} {f : ℕ → Set α}\n    (hf : ∀ n, ∃ j < i, f n ∈ generateMeasurableRec s j) :\n    ⋃ n, f n ∈ generateMeasurableRec s i := by\n  unfold generateMeasurableRec\n  exact mem_union_right _ ⟨fun n => ⟨f n, let ⟨j, hj, hf⟩ := hf n; mem_iUnion₂.2 ⟨j, hj, hf⟩⟩, rfl⟩\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ Monotone (MeasurableSpace.generateMeasurableRec s)","decl":"theorem generateMeasurableRec_mono (s : Set (Set α)) : Monotone (generateMeasurableRec s) := by\n  intro i j h x hx\n  rcases h.eq_or_lt with (rfl | h)\n  · exact hx\n  · convert iUnion_mem_generateMeasurableRec fun _ => ⟨i, h, hx⟩\n    exact (iUnion_const x).symm\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_induction","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{u_1}\nt : Set α\np : Set α → Prop\nhs : ∀ (t : Set α), Membership.mem s t → p t\nh0 : p EmptyCollection.emptyCollection\nhc : ∀ (u : Set α), p u → (Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) u)) → p (HasCompl.compl u)\nhn : ∀ (f : Nat → Set α), (∀ (n : Nat), And (p (f n)) (Exists fun j => And (LT.lt j i) (Membership.mem (MeasurableSpace.generateMeasurableRec s j) (f n)))) → p (Set.iUnion fun n => f n)\na✝ : Membership.mem (MeasurableSpace.generateMeasurableRec s i) t\n⊢ p t","decl":"/-- An inductive principle for the elements of `generateMeasurableRec`. -/\n@[elab_as_elim]\ntheorem generateMeasurableRec_induction {s : Set (Set α)} {i : Ordinal} {t : Set α}\n    {p : Set α → Prop} (hs : ∀ t ∈ s, p t) (h0 : p ∅)\n    (hc : ∀ u, p u → (∃ j < i, u ∈ generateMeasurableRec s j) → p uᶜ)\n    (hn : ∀ f : ℕ → Set α,\n      (∀ n, p (f n) ∧ ∃ j < i, f n ∈ generateMeasurableRec s j) → p (⋃ n, f n)) :\n    t ∈ generateMeasurableRec s i → p t := by\n  suffices H : ∀ k ≤ i, ∀ t ∈ generateMeasurableRec s k, p t from H i le_rfl t\n  intro k\n  apply WellFoundedLT.induction k\n  intro k IH hk t\n  replace IH := fun j hj => IH j hj (hj.le.trans hk)\n  unfold generateMeasurableRec\n  rintro (((ht | rfl) | ht) | ⟨f, rfl⟩)\n  · exact hs t ht\n  · exact h0\n  · simp_rw [mem_image, mem_iUnion₂] at ht\n    obtain ⟨u, ⟨⟨j, hj, hj'⟩, rfl⟩⟩ := ht\n    exact hc u (IH j hj u hj') ⟨j, hj.trans_le hk, hj'⟩\n  · apply hn\n    intro n\n    obtain ⟨j, hj, hj'⟩ := mem_iUnion₂.1 (f n).2\n    use IH j hj _ hj', j, hj.trans_le hk\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_omega1","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ Eq (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1)) (Set.iUnion fun i => Set.iUnion fun h => MeasurableSpace.generateMeasurableRec s i)","decl":"theorem generateMeasurableRec_omega1 (s : Set (Set α)) :\n    generateMeasurableRec s (ω₁ : Ordinal.{v}) =\n      ⋃ i < (ω₁ : Ordinal.{v}), generateMeasurableRec s i := by\n  apply (iUnion₂_subset fun i h => generateMeasurableRec_mono s h.le).antisymm'\n  intro t ht\n  rw [mem_iUnion₂]\n  refine generateMeasurableRec_induction ?_ ?_ ?_ ?_ ht\n  · intro t ht\n    exact ⟨0, omega_pos 1, self_subset_generateMeasurableRec s 0 ht⟩\n  · exact ⟨0, omega_pos 1, empty_mem_generateMeasurableRec s 0⟩\n  · rintro u - ⟨j, hj, hj'⟩\n    exact ⟨_, (isLimit_omega 1).succ_lt hj,\n      compl_mem_generateMeasurableRec (Order.lt_succ j) hj'⟩\n  · intro f H\n    choose I hI using fun n => (H n).1\n    simp_rw [exists_prop] at hI\n    refine ⟨_, Ordinal.lsub_lt_ord_lift ?_ fun n => (hI n).1,\n      iUnion_mem_generateMeasurableRec fun n => ⟨_, Ordinal.lt_lsub I n, (hI n).2⟩⟩\n    rw [mk_nat, lift_aleph0, isRegular_aleph_one.cof_omega_eq]\n    exact aleph0_lt_aleph_one\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_subset","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{u_1}\n⊢ HasSubset.Subset (MeasurableSpace.generateMeasurableRec s i) (setOf fun t => MeasurableSpace.GenerateMeasurable s t)","decl":"theorem generateMeasurableRec_subset (s : Set (Set α)) (i : Ordinal) :\n    generateMeasurableRec s i ⊆ { t | GenerateMeasurable s t } := by\n  apply WellFoundedLT.induction i\n  exact fun i IH t ht => generateMeasurableRec_induction .basic .empty\n    (fun u _ ⟨j, hj, hj'⟩ => .compl _ (IH j hj hj')) (fun f H => .iUnion _ fun n => (H n).1) ht\n\n"}
{"name":"MeasurableSpace.generateMeasurable_eq_rec","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ Eq (setOf fun t => MeasurableSpace.GenerateMeasurable s t) (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1))","decl":"/-- `generateMeasurableRec s ω₁` generates precisely the smallest sigma-algebra containing `s`. -/\ntheorem generateMeasurable_eq_rec (s : Set (Set α)) :\n    { t | GenerateMeasurable s t } = generateMeasurableRec s ω₁ := by\n  apply (generateMeasurableRec_subset s _).antisymm'\n  intro t ht\n  induction' ht with u hu u _ IH f _ IH\n  · exact self_subset_generateMeasurableRec s _ hu\n  · exact empty_mem_generateMeasurableRec s _\n  · rw [generateMeasurableRec_omega1, mem_iUnion₂] at IH\n    obtain ⟨i, hi, hi'⟩ := IH\n    exact generateMeasurableRec_mono _ ((isLimit_omega 1).succ_lt hi).le\n      (compl_mem_generateMeasurableRec (Order.lt_succ i) hi')\n  · simp_rw [generateMeasurableRec_omega1, mem_iUnion₂, exists_prop] at IH\n    exact iUnion_mem_generateMeasurableRec IH\n\n"}
{"name":"MeasurableSpace.generateMeasurableRec_of_omega1_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{v}\nhi : LE.le (Ordinal.omega 1) i\n⊢ Eq (MeasurableSpace.generateMeasurableRec s i) (MeasurableSpace.generateMeasurableRec s (Ordinal.omega 1))","decl":"/-- `generateMeasurableRec` is constant for ordinals `≥ ω₁`. -/\ntheorem generateMeasurableRec_of_omega1_le (s : Set (Set α)) {i : Ordinal.{v}} (hi : ω₁ ≤ i) :\n    generateMeasurableRec s i = generateMeasurableRec s (ω₁ : Ordinal.{v}) := by\n  apply (generateMeasurableRec_mono s hi).antisymm'\n  rw [← generateMeasurable_eq_rec]\n  exact generateMeasurableRec_subset s i\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurableRec_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\ni : Ordinal.{v}\n⊢ LE.le (Cardinal.mk ↑(MeasurableSpace.generateMeasurableRec s i)) (HPow.hPow (Max.max (Cardinal.mk ↑s) 2) Cardinal.aleph0)","decl":"/-- At each step of the inductive construction, the cardinality bound `≤ #s ^ ℵ₀` holds. -/\ntheorem cardinal_generateMeasurableRec_le (s : Set (Set α)) (i : Ordinal.{v}) :\n    #(generateMeasurableRec s i) ≤ max #s 2 ^ ℵ₀ := by\n  suffices ∀ i ≤ ω₁, #(generateMeasurableRec s i) ≤ max #s 2 ^ ℵ₀ by\n    obtain hi | hi := le_or_lt i ω₁\n    · exact this i hi\n    · rw [generateMeasurableRec_of_omega1_le s hi.le]\n      exact this _ le_rfl\n  intro i\n  apply WellFoundedLT.induction i\n  intro i IH hi\n  have A : 𝔠 ≤ max #s 2 ^ ℵ₀ := power_le_power_right (le_max_right _ _)\n  have B := aleph0_le_continuum.trans A\n  have C : #(⋃ j < i, generateMeasurableRec s j) ≤ max #s 2 ^ ℵ₀ := by\n    apply mk_iUnion_Ordinal_lift_le_of_le _ B _\n    · intro j hj\n      exact IH j hj (hj.trans_le hi).le\n    · rw [lift_power, lift_aleph0]\n      rw [← Ordinal.lift_le.{u}, lift_omega, Ordinal.lift_one, ← ord_aleph] at hi\n      have H := card_le_of_le_ord hi\n      rw [← Ordinal.lift_card] at H\n      apply H.trans <| aleph_one_le_continuum.trans <| power_le_power_right _\n      rw [lift_max, Cardinal.lift_ofNat]\n      exact le_max_right _ _\n  rw [generateMeasurableRec]\n  apply_rules [(mk_union_le _ _).trans, add_le_of_le (aleph_one_le_continuum.trans A),\n    mk_image_le.trans]\n  · exact (self_le_power _ one_le_aleph0).trans (power_le_power_right (le_max_left _ _))\n  · rw [mk_singleton]\n    exact one_lt_aleph0.le.trans B\n  · apply mk_range_le.trans\n    simp only [mk_pi, prod_const, Cardinal.lift_uzero, mk_denumerable, lift_aleph0]\n    have := @power_le_power_right _ _ ℵ₀ C\n    rwa [← power_mul, aleph0_mul_aleph0] at this\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurable_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ LE.le (Cardinal.mk ↑(setOf fun t => MeasurableSpace.GenerateMeasurable s t)) (HPow.hPow (Max.max (Cardinal.mk ↑s) 2) Cardinal.aleph0)","decl":"/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma-algebra has cardinality at\nmost `max #s 2 ^ ℵ₀`. -/\ntheorem cardinal_generateMeasurable_le (s : Set (Set α)) :\n    #{ t | GenerateMeasurable s t } ≤ max #s 2 ^ ℵ₀ := by\n  rw [generateMeasurable_eq_rec.{u, 0}]\n  exact cardinal_generateMeasurableRec_le s _\n\n"}
{"name":"MeasurableSpace.cardinal_measurableSet_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ LE.le (Cardinal.mk ↑(setOf fun t => MeasurableSet t)) (HPow.hPow (Max.max (Cardinal.mk ↑s) 2) Cardinal.aleph0)","decl":"/-- If a sigma-algebra is generated by a set of sets `s`, then the sigma\nalgebra has cardinality at most `max #s 2 ^ ℵ₀`. -/\ntheorem cardinal_measurableSet_le (s : Set (Set α)) :\n    #{ t | @MeasurableSet α (generateFrom s) t } ≤ max #s 2 ^ ℵ₀ :=\n  cardinal_generateMeasurable_le s\n\n"}
{"name":"MeasurableSpace.cardinalMeasurableSet_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\n⊢ LE.le (Cardinal.mk ↑(setOf fun t => MeasurableSet t)) (HPow.hPow (Max.max (Cardinal.mk ↑s) 2) Cardinal.aleph0)","decl":"@[deprecated cardinal_measurableSet_le (since := \"2024-08-30\")]\nalias cardinalMeasurableSet_le := cardinal_measurableSet_le\n\n"}
{"name":"MeasurableSpace.cardinal_generateMeasurable_le_continuum","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\nhs : LE.le (Cardinal.mk ↑s) Cardinal.continuum\n⊢ LE.le (Cardinal.mk ↑(setOf fun t => MeasurableSpace.GenerateMeasurable s t)) Cardinal.continuum","decl":"/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. -/\ntheorem cardinal_generateMeasurable_le_continuum {s : Set (Set α)} (hs : #s ≤ 𝔠) :\n    #{ t | GenerateMeasurable s t } ≤ 𝔠 := by\n  apply (cardinal_generateMeasurable_le s).trans\n  rw [← continuum_power_aleph0]\n  exact_mod_cast power_le_power_right (max_le hs (nat_lt_continuum 2).le)\n\n"}
{"name":"MeasurableSpace.cardinal_measurableSet_le_continuum","module":"Mathlib.MeasureTheory.MeasurableSpace.Card","initialProofState":"α : Type u\ns : Set (Set α)\na✝ : LE.le (Cardinal.mk ↑s) Cardinal.continuum\n⊢ LE.le (Cardinal.mk ↑(setOf fun t => MeasurableSet t)) Cardinal.continuum","decl":"/-- If a sigma-algebra is generated by a set of sets `s` with cardinality at most the continuum,\nthen the sigma algebra has the same cardinality bound. -/\ntheorem cardinal_measurableSet_le_continuum {s : Set (Set α)} :\n    #s ≤ 𝔠 → #{ t | @MeasurableSet α (generateFrom s) t } ≤ 𝔠 :=\n  cardinal_generateMeasurable_le_continuum\n\n"}
