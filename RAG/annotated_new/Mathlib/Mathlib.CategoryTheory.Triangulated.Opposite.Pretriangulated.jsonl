{"name":"CategoryTheory.Pretriangulated.Opposite.mem_distinguishedTriangles_iff","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Iff (Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T)))","decl":"lemma mem_distinguishedTriangles_iff (T : Triangle C·µí·µñ) :\n    T ‚àà distinguishedTriangles C ‚Üî\n      ((triangleOpEquivalence C).inverse.obj T).unop ‚àà distTriang C := by\n  rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.mem_distinguishedTriangles_iff'","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Iff (Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T) (Exists fun T' => Exists fun x => Nonempty (CategoryTheory.Iso T ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor.obj { unop := T' })))","decl":"lemma mem_distinguishedTriangles_iff' (T : Triangle C·µí·µñ) :\n    T ‚àà distinguishedTriangles C ‚Üî\n      ‚àÉ (T' : Triangle C) (_ : T' ‚àà distTriang C),\n        Nonempty (T ‚âÖ (triangleOpEquivalence C).functor.obj (Opposite.op T')) := by\n  rw [mem_distinguishedTriangles_iff]\n  constructor\n  ¬∑ intro hT\n    exact ‚ü®_ ,hT, ‚ü®(triangleOpEquivalence C).counitIso.symm.app T‚ü©‚ü©\n  ¬∑ rintro ‚ü®T', hT', ‚ü®e‚ü©‚ü©\n    refine isomorphic_distinguished _ hT' _ ?_\n    exact Iso.unop ((triangleOpEquivalence C).unitIso.app (Opposite.op T') ‚â™‚â´\n      (triangleOpEquivalence C).inverse.mapIso e.symm)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.isomorphic_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT‚ÇÅ : CategoryTheory.Pretriangulated.Triangle (Opposite C)\nhT‚ÇÅ : Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T‚ÇÅ\nT‚ÇÇ : CategoryTheory.Pretriangulated.Triangle (Opposite C)\ne : CategoryTheory.Iso T‚ÇÇ T‚ÇÅ\n‚ä¢ Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T‚ÇÇ","decl":"lemma isomorphic_distinguished (T‚ÇÅ : Triangle C·µí·µñ)\n    (hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles C) (T‚ÇÇ : Triangle C·µí·µñ) (e : T‚ÇÇ ‚âÖ T‚ÇÅ) :\n    T‚ÇÇ ‚àà distinguishedTriangles C := by\n  simp only [mem_distinguishedTriangles_iff] at hT‚ÇÅ ‚ä¢\n  exact Pretriangulated.isomorphic_distinguished _ hT‚ÇÅ _\n    ((triangleOpEquivalence C).inverse.mapIso e).unop.symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_inv_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).inv.hom‚ÇÉ (‚ãØ.iso ‚ãØ).inv","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_hom_hom‚ÇÉ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).hom.hom‚ÇÉ (‚ãØ.iso ‚ãØ).hom","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_inv_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).inv.hom‚ÇÇ (CategoryTheory.CategoryStruct.id X)","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_hom_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).hom.hom‚ÇÅ (CategoryTheory.CategoryStruct.id X)","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_inv_hom‚ÇÅ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).inv.hom‚ÇÅ (CategoryTheory.CategoryStruct.id X)","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso_hom_hom‚ÇÇ","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.HasShift C Int\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Preadditive C\nX : Opposite C\n‚ä¢ Eq (CategoryTheory.Pretriangulated.Opposite.contractibleTriangleIso X).hom.hom‚ÇÇ (CategoryTheory.CategoryStruct.id X)","decl":"/-- Up to rotation, the contractible triangle `X ‚ü∂ X ‚ü∂ 0 ‚ü∂ X‚ü¶1‚üß` for `X : C·µí·µñ` corresponds\nto the contractible triangle for `X.unop` in `C`. -/\n@[simps!]\nnoncomputable def contractibleTriangleIso (X : C·µí·µñ) :\n    contractibleTriangle X ‚âÖ (triangleOpEquivalence C).functor.obj\n      (Opposite.op (contractibleTriangle X.unop).invRotate) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _)\n    (IsZero.iso (isZero_zero _) (by\n      dsimp\n      rw [IsZero.iff_id_eq_zero]\n      change (ùüô ((0 : C)‚ü¶(-1 : ‚Ñ§)‚üß)).op = 0\n      rw [‚Üê Functor.map_id, id_zero, Functor.map_zero, op_zero]))\n    (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.contractible_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nX : Opposite C\n‚ä¢ Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"lemma contractible_distinguished (X : C·µí·µñ) :\n    contractibleTriangle X ‚àà distinguishedTriangles C := by\n  rw [mem_distinguishedTriangles_iff']\n  exact ‚ü®_, inv_rot_of_distTriang _ (Pretriangulated.contractible_distinguished X.unop),\n    ‚ü®contractibleTriangleIso X‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.rotate_distinguished_triangle","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Iff (Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T) (Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T.rotate)","decl":"lemma rotate_distinguished_triangle (T : Triangle C·µí·µñ) :\n    T ‚àà distinguishedTriangles C ‚Üî T.rotate ‚àà distinguishedTriangles C := by\n  simp only [mem_distinguishedTriangles_iff, Pretriangulated.rotate_distinguished_triangle\n    ((triangleOpEquivalence C).inverse.obj (T.rotate)).unop]\n  exact distinguished_iff_of_iso (rotateTriangleOpEquivalenceInverseObjRotateUnopIso T).symm\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.distinguished_cocone_triangle","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"lemma distinguished_cocone_triangle {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    ‚àÉ (Z : C·µí·µñ) (g : Y ‚ü∂ Z) (h : Z ‚ü∂ X‚ü¶(1 : ‚Ñ§)‚üß),\n      Triangle.mk f g h ‚àà distinguishedTriangles C := by\n  obtain ‚ü®Z, g, h, H‚ü© := Pretriangulated.distinguished_cocone_triangle‚ÇÅ f.unop\n  refine ‚ü®_, g.op, (opShiftFunctorEquivalence C 1).counitIso.inv.app (Opposite.op Z) ‚â´\n    (shiftFunctor C·µí·µñ (1 : ‚Ñ§)).map h.op, ?_‚ü©\n  simp only [mem_distinguishedTriangles_iff]\n  refine Pretriangulated.isomorphic_distinguished _ H _ ?_\n  exact Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n    (Quiver.Hom.op_inj (by simp [shift_unop_opShiftFunctorEquivalence_counitIso_inv_app]))\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.complete_distinguished_triangle_morphism","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Pretriangulated.Triangle (Opposite C)\nhT‚ÇÅ : Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T‚ÇÅ\nhT‚ÇÇ : Membership.mem (CategoryTheory.Pretriangulated.Opposite.distinguishedTriangles C) T‚ÇÇ\na : Quiver.Hom T‚ÇÅ.obj‚ÇÅ T‚ÇÇ.obj‚ÇÅ\nb : Quiver.Hom T‚ÇÅ.obj‚ÇÇ T‚ÇÇ.obj‚ÇÇ\ncomm : Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÅ b) (CategoryTheory.CategoryStruct.comp a T‚ÇÇ.mor‚ÇÅ)\n‚ä¢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÇ c) (CategoryTheory.CategoryStruct.comp b T‚ÇÇ.mor‚ÇÇ)) (Eq (CategoryTheory.CategoryStruct.comp T‚ÇÅ.mor‚ÇÉ ((CategoryTheory.shiftFunctor (Opposite C) 1).map a)) (CategoryTheory.CategoryStruct.comp c T‚ÇÇ.mor‚ÇÉ))","decl":"lemma complete_distinguished_triangle_morphism (T‚ÇÅ T‚ÇÇ : Triangle C·µí·µñ)\n    (hT‚ÇÅ : T‚ÇÅ ‚àà distinguishedTriangles C) (hT‚ÇÇ : T‚ÇÇ ‚àà distinguishedTriangles C)\n    (a : T‚ÇÅ.obj‚ÇÅ ‚ü∂ T‚ÇÇ.obj‚ÇÅ) (b : T‚ÇÅ.obj‚ÇÇ ‚ü∂ T‚ÇÇ.obj‚ÇÇ) (comm : T‚ÇÅ.mor‚ÇÅ ‚â´ b = a ‚â´ T‚ÇÇ.mor‚ÇÅ) :\n    ‚àÉ (c : T‚ÇÅ.obj‚ÇÉ ‚ü∂ T‚ÇÇ.obj‚ÇÉ), T‚ÇÅ.mor‚ÇÇ ‚â´ c = b ‚â´ T‚ÇÇ.mor‚ÇÇ ‚àß\n      T‚ÇÅ.mor‚ÇÉ ‚â´ a‚ü¶1‚üß' = c ‚â´ T‚ÇÇ.mor‚ÇÉ := by\n  rw [mem_distinguishedTriangles_iff] at hT‚ÇÅ hT‚ÇÇ\n  obtain ‚ü®c, hc‚ÇÅ, hc‚ÇÇ‚ü© :=\n    Pretriangulated.complete_distinguished_triangle_morphism‚ÇÅ _ _ hT‚ÇÇ hT‚ÇÅ\n      b.unop a.unop (Quiver.Hom.op_inj comm.symm)\n  dsimp at c hc‚ÇÅ hc‚ÇÇ\n  replace hc‚ÇÇ := ((opShiftFunctorEquivalence C 1).unitIso.hom.app T‚ÇÇ.obj‚ÇÅ).unop ‚â´= hc‚ÇÇ\n  dsimp at hc‚ÇÇ\n  simp only [assoc, Iso.unop_hom_inv_id_app_assoc] at hc‚ÇÇ\n  refine ‚ü®c.op, Quiver.Hom.unop_inj hc‚ÇÅ.symm, Quiver.Hom.unop_inj ?_‚ü©\n  apply (shiftFunctor C (1 : ‚Ñ§)).map_injective\n  rw [unop_comp, unop_comp, Functor.map_comp, Functor.map_comp,\n    Quiver.Hom.unop_op, hc‚ÇÇ, ‚Üê unop_comp_assoc, ‚Üê unop_comp_assoc,\n    ‚Üê opShiftFunctorEquivalence_unitIso_inv_naturality]\n  simp\n\n"}
{"name":"CategoryTheory.Pretriangulated.mem_distTriang_op_iff","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T) (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T)))","decl":"lemma mem_distTriang_op_iff (T : Triangle C·µí·µñ) :\n    (T ‚àà distTriang C·µí·µñ) ‚Üî ((triangleOpEquivalence C).inverse.obj T).unop ‚àà distTriang C := by\n  rfl\n\n"}
{"name":"CategoryTheory.Pretriangulated.mem_distTriang_op_iff'","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\n‚ä¢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T) (Exists fun T' => Exists fun x => Nonempty (CategoryTheory.Iso T ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor.obj { unop := T' })))","decl":"lemma mem_distTriang_op_iff' (T : Triangle C·µí·µñ) :\n    (T ‚àà distTriang C·µí·µñ) ‚Üî ‚àÉ (T' : Triangle C) (_ : T' ‚àà distTriang C),\n      Nonempty (T ‚âÖ (triangleOpEquivalence C).functor.obj (Opposite.op T')) :=\n  Opposite.mem_distinguishedTriangles_iff' T\n\n"}
{"name":"CategoryTheory.Pretriangulated.op_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n‚ä¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor.obj { unop := T })","decl":"lemma op_distinguished (T : Triangle C) (hT : T ‚àà distTriang C) :\n    ((triangleOpEquivalence C).functor.obj (Opposite.op T)) ‚àà distTriang C·µí·µñ := by\n  rw [mem_distTriang_op_iff']\n  exact ‚ü®T, hT, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Pretriangulated.unop_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.HasShift C Int\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle (Opposite C)\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n‚ä¢ Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (Opposite.unop ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).inverse.obj T))","decl":"lemma unop_distinguished (T : Triangle C·µí·µñ) (hT : T ‚àà distTriang C·µí·µñ) :\n    ((triangleOpEquivalence C).inverse.obj T).unop ‚àà distTriang C := hT\n\n"}
{"name":"CategoryTheory.Functor.map_distinguished_op_exact","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Pretriangulated","initialProofState":"C : Type u_1\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∑ : CategoryTheory.HasShift C Int\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : CategoryTheory.Preadditive C\ninst‚úù‚Å¥ : ‚àÄ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst‚úù¬≥ : CategoryTheory.Pretriangulated C\nA : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} A\ninst‚úù¬π : CategoryTheory.Abelian A\nF : CategoryTheory.Functor (Opposite C) A\ninst‚úù : F.IsHomological\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\n‚ä¢ ((CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).op.map F).Exact","decl":"lemma map_distinguished_op_exact {A : Type*} [Category A] [Abelian A] (F : C·µí·µñ ‚•§ A)\n    [F.IsHomological] (T : Triangle C) (hT : T ‚àà distTriang C) :\n    ((shortComplexOfDistTriangle T hT).op.map F).Exact :=\n  F.map_distinguished_exact _ (op_distinguished T hT)\n\n"}
