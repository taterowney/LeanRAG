{"name":"HurwitzZeta.jacobiTheta₂''_conj","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"z τ : Complex\n⊢ Eq ((starRingEnd Complex) (HurwitzZeta.jacobiTheta₂'' z τ)) (HurwitzZeta.jacobiTheta₂'' ((starRingEnd Complex) z) (Neg.neg ((starRingEnd Complex) τ)))","decl":"lemma jacobiTheta₂''_conj (z τ : ℂ) :\n    conj (jacobiTheta₂'' z τ) = jacobiTheta₂'' (conj z) (-conj τ) := by\n  simp [jacobiTheta₂'', jacobiTheta₂'_conj, jacobiTheta₂_conj, ← exp_conj, map_ofNat, div_neg,\n    neg_div, jacobiTheta₂'_neg_left]\n\n"}
{"name":"HurwitzZeta.jacobiTheta₂''_add_left","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"z τ : Complex\n⊢ Eq (HurwitzZeta.jacobiTheta₂'' (HAdd.hAdd z 1) τ) (HurwitzZeta.jacobiTheta₂'' z τ)","decl":"/-- Restatement of `jacobiTheta₂'_add_left'`: the function `jacobiTheta₂''` is 1-periodic in `z`. -/\nlemma jacobiTheta₂''_add_left (z τ : ℂ) : jacobiTheta₂'' (z + 1) τ = jacobiTheta₂'' z τ := by\n  simp only [jacobiTheta₂'', add_mul z 1, one_mul, jacobiTheta₂'_add_left', jacobiTheta₂_add_left']\n  generalize jacobiTheta₂ (z * τ) τ = J\n  generalize jacobiTheta₂' (z * τ) τ = J'\n  -- clear denominator\n  simp_rw [div_add' _ _ _ two_pi_I_ne_zero, ← mul_div_assoc]\n  refine congr_arg (· / (2 * π * I)) ?_\n  -- get all exponential terms to left\n  rw [mul_left_comm _ (cexp _), ← mul_add, mul_assoc (cexp _), ← mul_add, ← mul_assoc (cexp _),\n    ← Complex.exp_add]\n  congrm (cexp ?_ * ?_) <;> ring\n\n"}
{"name":"HurwitzZeta.jacobiTheta₂''_neg_left","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"z τ : Complex\n⊢ Eq (HurwitzZeta.jacobiTheta₂'' (Neg.neg z) τ) (Neg.neg (HurwitzZeta.jacobiTheta₂'' z τ))","decl":"lemma jacobiTheta₂''_neg_left (z τ : ℂ) : jacobiTheta₂'' (-z) τ = -jacobiTheta₂'' z τ := by\n  simp [jacobiTheta₂'', jacobiTheta₂'_neg_left, neg_div, -neg_add_rev, ← neg_add]\n\n"}
{"name":"HurwitzZeta.jacobiTheta₂'_functional_equation'","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' z τ) (HMul.hMul (HDiv.hDiv (HMul.hMul (-2) ↑Real.pi) (HPow.hPow (HMul.hMul (Neg.neg Complex.I) τ) (3 / 2))) (HurwitzZeta.jacobiTheta₂'' z (HDiv.hDiv (-1) τ)))","decl":"lemma jacobiTheta₂'_functional_equation' (z τ : ℂ) :\n    jacobiTheta₂' z τ = (-2 * π) / (-I * τ) ^ (3 / 2 : ℂ) * jacobiTheta₂'' z (-1 / τ) := by\n  rcases eq_or_ne τ 0 with rfl | hτ\n  · rw [jacobiTheta₂'_undef _ (by simp), mul_zero, zero_cpow (by norm_num), div_zero, zero_mul]\n  have aux1 : (-2 * π : ℂ) / (2 * π * I) = I := by\n    rw [div_eq_iff two_pi_I_ne_zero, mul_comm I, mul_assoc _ I I, I_mul_I, neg_mul, mul_neg,\n      mul_one]\n  rw [jacobiTheta₂'_functional_equation, ← mul_one_div _ τ, mul_right_comm _ (cexp _),\n    (by rw [cpow_one, ← div_div, div_self (neg_ne_zero.mpr I_ne_zero)] :\n      1 / τ = -I / (-I * τ) ^ (1 : ℂ)), div_mul_div_comm,\n    ← cpow_add _ _ (mul_ne_zero (neg_ne_zero.mpr I_ne_zero) hτ), ← div_mul_eq_mul_div,\n    (by norm_num : (1 / 2  + 1 : ℂ) = 3 / 2), mul_assoc (1 / _), mul_assoc (1 / _),\n    ← mul_one_div (-2 * π : ℂ), mul_comm _ (1 / _), mul_assoc (1 / _)]\n  congr 1\n  rw [jacobiTheta₂'', div_add' _ _ _ two_pi_I_ne_zero, ← mul_div_assoc, ← mul_div_assoc,\n    ← div_mul_eq_mul_div (-2 * π : ℂ), mul_assoc, aux1, mul_div z (-1), mul_neg_one, neg_div τ z,\n    jacobiTheta₂_neg_left, jacobiTheta₂'_neg_left, neg_mul, ← mul_neg, ← mul_neg,\n    mul_div, mul_neg_one, neg_div, neg_mul, neg_mul, neg_div]\n  congr 2\n  rw [neg_sub, ← sub_eq_neg_add, mul_comm _ (_ * I), ← mul_assoc]\n\n"}
{"name":"HurwitzZeta.oddKernel_def","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a x : Real\n⊢ Eq (↑(HurwitzZeta.oddKernel (↑a) x)) (HurwitzZeta.jacobiTheta₂'' (↑a) (HMul.hMul Complex.I ↑x))","decl":"lemma oddKernel_def (a x : ℝ) : ↑(oddKernel a x) = jacobiTheta₂'' a (I * x) := by\n  simp [oddKernel, ← conj_eq_iff_re, jacobiTheta₂''_conj]\n\n"}
{"name":"HurwitzZeta.oddKernel_def'","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a x : Real\n⊢ Eq (↑(HurwitzZeta.oddKernel (↑a) x)) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) (HPow.hPow (↑a) 2)) ↑x)) (HAdd.hAdd (HDiv.hDiv (jacobiTheta₂' (HMul.hMul (HMul.hMul (↑a) Complex.I) ↑x) (HMul.hMul Complex.I ↑x)) (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I)) (HMul.hMul (↑a) (jacobiTheta₂ (HMul.hMul (HMul.hMul (↑a) Complex.I) ↑x) (HMul.hMul Complex.I ↑x)))))","decl":"lemma oddKernel_def' (a x : ℝ) : ↑(oddKernel ↑a x) = cexp (-π * a ^ 2 * x) *\n    (jacobiTheta₂' (a * I * x) (I * x) / (2 * π * I) + a * jacobiTheta₂ (a * I * x) (I * x)) := by\n  rw [oddKernel_def, jacobiTheta₂'', ← mul_assoc ↑a I x,\n    (by ring : ↑π * I * ↑a ^ 2 * (I * ↑x) = I ^ 2 * ↑π * ↑a ^ 2 * x), I_sq, neg_one_mul]\n\n"}
{"name":"HurwitzZeta.oddKernel_undef","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nx : Real\nhx : LE.le x 0\n⊢ Eq (HurwitzZeta.oddKernel a x) 0","decl":"lemma oddKernel_undef (a : UnitAddCircle) {x : ℝ} (hx : x ≤ 0) : oddKernel a x = 0 := by\n  induction' a using QuotientAddGroup.induction_on with a'\n  rw [← ofReal_eq_zero, oddKernel_def', jacobiTheta₂_undef, jacobiTheta₂'_undef, zero_div, zero_add,\n    mul_zero, mul_zero] <;>\n  simpa\n\n"}
{"name":"HurwitzZeta.sinKernel_def","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a x : Real\n⊢ Eq (↑(HurwitzZeta.sinKernel (↑a) x)) (HDiv.hDiv (jacobiTheta₂' (↑a) (HMul.hMul Complex.I ↑x)) (HMul.hMul (-2) ↑Real.pi))","decl":"lemma sinKernel_def (a x : ℝ) : ↑(sinKernel ↑a x) = jacobiTheta₂' a (I * x) / (-2 * π) := by\n  simp [sinKernel, re_eq_add_conj, jacobiTheta₂'_conj, map_ofNat]\n\n"}
{"name":"HurwitzZeta.sinKernel_undef","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nx : Real\nhx : LE.le x 0\n⊢ Eq (HurwitzZeta.sinKernel a x) 0","decl":"lemma sinKernel_undef (a : UnitAddCircle) {x : ℝ} (hx : x ≤ 0) : sinKernel a x = 0 := by\n  induction a using QuotientAddGroup.induction_on with\n  | H a => rw [← ofReal_eq_zero, sinKernel_def, jacobiTheta₂'_undef _ (by simpa), zero_div]\n\n"}
{"name":"HurwitzZeta.oddKernel_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.oddKernel (Neg.neg a) x) (Neg.neg (HurwitzZeta.oddKernel a x))","decl":"lemma oddKernel_neg (a : UnitAddCircle) (x : ℝ) : oddKernel (-a) x = -oddKernel a x := by\n  induction a using QuotientAddGroup.induction_on with\n  | H a => simp [← ofReal_inj, ← QuotientAddGroup.mk_neg, oddKernel_def, jacobiTheta₂''_neg_left]\n\n"}
{"name":"HurwitzZeta.oddKernel_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"x : Real\n⊢ Eq (HurwitzZeta.oddKernel 0 x) 0","decl":"@[simp] lemma oddKernel_zero (x : ℝ) : oddKernel 0 x = 0 := by\n  simpa using oddKernel_neg 0 x\n\n"}
{"name":"HurwitzZeta.sinKernel_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.sinKernel (Neg.neg a) x) (Neg.neg (HurwitzZeta.sinKernel a x))","decl":"lemma sinKernel_neg (a : UnitAddCircle) (x : ℝ) :\n    sinKernel (-a) x = -sinKernel a x := by\n  induction a using QuotientAddGroup.induction_on with\n  | H a => simp [← ofReal_inj, ← QuotientAddGroup.mk_neg, sinKernel_def, jacobiTheta₂'_neg_left,\n      neg_div]\n\n"}
{"name":"HurwitzZeta.sinKernel_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"x : Real\n⊢ Eq (HurwitzZeta.sinKernel 0 x) 0","decl":"@[simp] lemma sinKernel_zero (x : ℝ) : sinKernel 0 x = 0 := by\n  simpa using sinKernel_neg 0 x\n\n"}
{"name":"HurwitzZeta.continuousOn_oddKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ ContinuousOn (HurwitzZeta.oddKernel a) (Set.Ioi 0)","decl":"/-- The odd kernel is continuous on `Ioi 0`. -/\nlemma continuousOn_oddKernel (a : UnitAddCircle) : ContinuousOn (oddKernel a) (Ioi 0) := by\n  induction' a using QuotientAddGroup.induction_on with a\n  suffices ContinuousOn (fun x ↦ (oddKernel a x : ℂ)) (Ioi 0) from\n    (continuous_re.comp_continuousOn this).congr fun a _ ↦ (ofReal_re _).symm\n  simp_rw [oddKernel_def' a]\n  refine fun x hx ↦ ((Continuous.continuousAt ?_).mul ?_).continuousWithinAt\n  · fun_prop\n  · have hf : Continuous fun u : ℝ ↦ (a * I * u, I * u) := by fun_prop\n    apply ContinuousAt.add\n    · exact ((continuousAt_jacobiTheta₂' (a * I * x) (by rwa [I_mul_im, ofReal_re])).comp\n        (f := fun u : ℝ ↦ (a * I * u, I * u)) hf.continuousAt).div_const _\n    · exact continuousAt_const.mul <| (continuousAt_jacobiTheta₂ (a * I * x)\n        (by rwa [I_mul_im, ofReal_re])).comp (f := fun u : ℝ ↦ (a * I * u, I * u)) hf.continuousAt\n\n"}
{"name":"HurwitzZeta.continuousOn_sinKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ ContinuousOn (HurwitzZeta.sinKernel a) (Set.Ioi 0)","decl":"lemma continuousOn_sinKernel (a : UnitAddCircle) : ContinuousOn (sinKernel a) (Ioi 0) := by\n  induction' a using QuotientAddGroup.induction_on with a\n  suffices ContinuousOn (fun x ↦ (sinKernel a x : ℂ)) (Ioi 0) from\n    (continuous_re.comp_continuousOn this).congr fun a _ ↦ (ofReal_re _).symm\n  simp_rw [sinKernel_def]\n  apply (continuousOn_of_forall_continuousAt (fun x hx ↦ ?_)).div_const\n  have h := continuousAt_jacobiTheta₂' a (by rwa [I_mul_im, ofReal_re])\n  fun_prop\n\n"}
{"name":"HurwitzZeta.oddKernel_functional_equation","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nx : Real\n⊢ Eq (HurwitzZeta.oddKernel a x) (HMul.hMul (HDiv.hDiv 1 (HPow.hPow x (3 / 2))) (HurwitzZeta.sinKernel a (HDiv.hDiv 1 x)))","decl":"lemma oddKernel_functional_equation (a : UnitAddCircle) (x : ℝ) :\n    oddKernel a x = 1 / x ^ (3 / 2 : ℝ) * sinKernel a (1 / x) := by\n  -- first reduce to `0 < x`\n  rcases le_or_lt x 0 with hx | hx\n  · rw [oddKernel_undef _ hx, sinKernel_undef _ (one_div_nonpos.mpr hx), mul_zero]\n  induction' a using QuotientAddGroup.induction_on with a\n  have h1 : -1 / (I * ↑(1 / x)) = I * x := by rw [one_div, ofReal_inv, mul_comm, ← div_div,\n    div_inv_eq_mul, div_eq_mul_inv, inv_I, mul_neg, neg_one_mul, neg_mul, neg_neg, mul_comm]\n  have h2 : (-I * (I * ↑(1 / x))) = 1 / x := by\n    rw [← mul_assoc, neg_mul, I_mul_I, neg_neg, one_mul, ofReal_div, ofReal_one]\n  have h3 : (x : ℂ) ^ (3 / 2 : ℂ) ≠ 0 := by\n    simp only [Ne, cpow_eq_zero_iff, ofReal_eq_zero, hx.ne', false_and, not_false_eq_true]\n  have h4 : arg x ≠ π := by rw [arg_ofReal_of_nonneg hx.le]; exact pi_ne_zero.symm\n  rw [← ofReal_inj, oddKernel_def, ofReal_mul, sinKernel_def, jacobiTheta₂'_functional_equation',\n    h1, h2]\n  generalize jacobiTheta₂'' a (I * ↑x) = J\n  rw [one_div (x : ℂ), inv_cpow _ _ h4, div_inv_eq_mul, one_div, ofReal_inv, ofReal_cpow hx.le,\n    ofReal_div, ofReal_ofNat, ofReal_ofNat, ← mul_div_assoc _ _ (-2 * π : ℂ),\n    eq_div_iff <| mul_ne_zero (neg_ne_zero.mpr two_ne_zero) (ofReal_ne_zero.mpr pi_ne_zero),\n    ← div_eq_inv_mul, eq_div_iff h3, mul_comm J _, mul_right_comm]\n\n"}
{"name":"HurwitzZeta.hasSum_int_oddKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a x : Real\nhx : LT.lt 0 x\n⊢ HasSum (fun n => HMul.hMul (HAdd.hAdd (↑n) a) (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (HAdd.hAdd (↑n) a) 2)) x))) (HurwitzZeta.oddKernel (↑a) x)","decl":"lemma hasSum_int_oddKernel (a : ℝ) {x : ℝ} (hx : 0 < x) :\n    HasSum (fun n : ℤ ↦ (n + a) * rexp (-π * (n + a) ^ 2 * x)) (oddKernel ↑a x) := by\n  rw [← hasSum_ofReal, oddKernel_def' a x]\n  have h1 := hasSum_jacobiTheta₂_term (a * I * x) (by rwa [I_mul_im, ofReal_re])\n  have h2 := hasSum_jacobiTheta₂'_term (a * I * x) (by rwa [I_mul_im, ofReal_re])\n  refine (((h2.div_const (2 * π * I)).add (h1.mul_left ↑a)).mul_left\n    (cexp (-π * a ^ 2 * x))).congr_fun (fun n ↦ ?_)\n  rw [jacobiTheta₂'_term, mul_assoc (2 * π * I), mul_div_cancel_left₀ _ two_pi_I_ne_zero, ← add_mul,\n    mul_left_comm, jacobiTheta₂_term, ← Complex.exp_add]\n  push_cast\n  simp only [← mul_assoc, ← add_mul]\n  congrm _ * cexp (?_ * x)\n  simp only [mul_right_comm _ I, add_mul, mul_assoc _ I, I_mul_I]\n  ring_nf\n\n"}
{"name":"HurwitzZeta.hasSum_int_sinKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => HMul.hMul (HMul.hMul (HMul.hMul (Neg.neg Complex.I) ↑n) (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n))) ↑(Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (↑n) 2)) t))) ↑(HurwitzZeta.sinKernel (↑a) t)","decl":"lemma hasSum_int_sinKernel (a : ℝ) {t : ℝ} (ht : 0 < t) : HasSum\n    (fun n : ℤ ↦ -I * n * cexp (2 * π * I * a * n) * rexp (-π * n ^ 2 * t)) ↑(sinKernel a t) := by\n  have h : -2 * (π : ℂ) ≠ (0 : ℂ) := by\n    simp only [neg_mul, ne_eq, neg_eq_zero, mul_eq_zero,\n      OfNat.ofNat_ne_zero, ofReal_eq_zero, pi_ne_zero, or_self, not_false_eq_true]\n  rw [sinKernel_def]\n  refine ((hasSum_jacobiTheta₂'_term a\n    (by rwa [I_mul_im, ofReal_re])).div_const _).congr_fun fun n ↦ ?_\n  rw [jacobiTheta₂'_term, jacobiTheta₂_term, ofReal_exp, mul_assoc (-I * n), ← Complex.exp_add,\n    eq_div_iff h, ofReal_mul, ofReal_mul, ofReal_pow, ofReal_neg, ofReal_intCast,\n    mul_comm _ (-2 * π : ℂ), ← mul_assoc]\n  congrm ?_ * cexp (?_ + ?_)\n  · simp [mul_assoc]\n  · exact mul_right_comm (2 * π * I) a n\n  · simp [← mul_assoc, mul_comm _ I]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_sinKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a t : Real\nht : LT.lt 0 t\n⊢ HasSum (fun n => HMul.hMul (HMul.hMul (HMul.hMul 2 ↑n) (Real.sin (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑n))) (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (↑n) 2)) t))) (HurwitzZeta.sinKernel (↑a) t)","decl":"lemma hasSum_nat_sinKernel (a : ℝ) {t : ℝ} (ht : 0 < t) :\n    HasSum (fun n : ℕ ↦ 2 * n * Real.sin (2 * π * a * n) * rexp (-π * n ^ 2 * t))\n    (sinKernel ↑a t) := by\n  rw [← hasSum_ofReal]\n  have := (hasSum_int_sinKernel a ht).nat_add_neg\n  simp only [Int.cast_zero, sq (0 : ℂ), zero_mul, mul_zero, add_zero] at this\n  refine this.congr_fun fun n ↦ ?_\n  simp_rw [Int.cast_neg, neg_sq, mul_neg, ofReal_mul, Int.cast_natCast, ofReal_natCast,\n      ofReal_ofNat, ← add_mul, ofReal_sin, Complex.sin]\n  push_cast\n  congr 1\n  rw [← mul_div_assoc, ← div_mul_eq_mul_div, ← div_mul_eq_mul_div, div_self two_ne_zero, one_mul,\n    neg_mul, neg_mul, neg_neg, mul_comm _ I, ← mul_assoc, mul_comm _ I, neg_mul,\n    ← sub_eq_neg_add, mul_sub]\n  congr 3 <;> ring\n\n"}
{"name":"HurwitzZeta.isBigO_atTop_oddKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (HurwitzZeta.oddKernel a) fun x => Real.exp (HMul.hMul (Neg.neg p) x))","decl":"/-- The function `oddKernel a` has exponential decay at `+∞`, for any `a`. -/\nlemma isBigO_atTop_oddKernel (a : UnitAddCircle) :\n    ∃ p, 0 < p ∧ IsBigO atTop (oddKernel a) (fun x ↦ Real.exp (-p * x)) := by\n  induction' a using QuotientAddGroup.induction_on with b\n  obtain ⟨p, hp, hp'⟩ := HurwitzKernelBounds.isBigO_atTop_F_int_one b\n  refine ⟨p, hp, (Eventually.isBigO ?_).trans hp'⟩\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  simpa [← (hasSum_int_oddKernel b ht).tsum_eq, HurwitzKernelBounds.F_int,\n    HurwitzKernelBounds.f_int, abs_of_nonneg (exp_pos _).le] using\n    norm_tsum_le_tsum_norm (hasSum_int_oddKernel b ht).summable.norm\n\n"}
{"name":"HurwitzZeta.isBigO_atTop_sinKernel","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (HurwitzZeta.sinKernel a) fun x => Real.exp (HMul.hMul (Neg.neg p) x))","decl":"/-- The function `sinKernel a` has exponential decay at `+∞`, for any `a`. -/\nlemma isBigO_atTop_sinKernel (a : UnitAddCircle) :\n    ∃ p, 0 < p ∧ IsBigO atTop (sinKernel a) (fun x ↦ Real.exp (-p * x)) := by\n  induction' a using QuotientAddGroup.induction_on with a\n  obtain ⟨p, hp, hp'⟩ := HurwitzKernelBounds.isBigO_atTop_F_nat_one (le_refl 0)\n  refine ⟨p, hp, (Eventually.isBigO ?_).trans (hp'.const_mul_left 2)⟩\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  rw [HurwitzKernelBounds.F_nat, ← (hasSum_nat_sinKernel a ht).tsum_eq]\n  apply tsum_of_norm_bounded (g := fun n ↦ 2 * HurwitzKernelBounds.f_nat 1 0 t n)\n  · exact (HurwitzKernelBounds.summable_f_nat 1 0 ht).hasSum.mul_left _\n  · intro n\n    rw [norm_mul, norm_mul, norm_mul, norm_two, mul_assoc, mul_assoc,\n      mul_le_mul_iff_of_pos_left two_pos, HurwitzKernelBounds.f_nat, pow_one, add_zero,\n      norm_of_nonneg (exp_pos _).le, Real.norm_eq_abs, Nat.abs_cast, ← mul_assoc,\n      mul_le_mul_iff_of_pos_right (exp_pos _)]\n    exact mul_le_of_le_one_right (Nat.cast_nonneg _) (abs_sin_le_one _)\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_ε","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzOddFEPair a).ε 1","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_g₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzOddFEPair a).g₀ 0","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_g","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\na✝ : Real\n⊢ Eq ((HurwitzZeta.hurwitzOddFEPair a).g a✝) (Function.comp Complex.ofReal (HurwitzZeta.sinKernel a) a✝)","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_f₀","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzOddFEPair a).f₀ 0","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_f","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\na✝ : Real\n⊢ Eq ((HurwitzZeta.hurwitzOddFEPair a).f a✝) (Function.comp Complex.ofReal (HurwitzZeta.oddKernel a) a✝)","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.hurwitzOddFEPair_k","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Eq (HurwitzZeta.hurwitzOddFEPair a).k (3 / 2)","decl":"/-- A `StrongFEPair` structure with `f = oddKernel a` and `g = sinKernel a`. -/\n@[simps]\ndef hurwitzOddFEPair (a : UnitAddCircle) : StrongFEPair ℂ where\n  f := ofReal ∘ oddKernel a\n  g := ofReal ∘ sinKernel a\n  hf_int := (continuous_ofReal.comp_continuousOn (continuousOn_oddKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  hg_int := (continuous_ofReal.comp_continuousOn (continuousOn_sinKernel a)).locallyIntegrableOn\n    measurableSet_Ioi\n  k := 3 / 2\n  hk := by norm_num\n  hε := one_ne_zero\n  f₀ := 0\n  hf₀ := rfl\n  g₀ := 0\n  hg₀ := rfl\n  hf_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_oddKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  hg_top r := by\n    let ⟨v, hv, hv'⟩ := isBigO_atTop_sinKernel a\n    rw [← isBigO_norm_left] at hv' ⊢\n    simpa using hv'.trans (isLittleO_exp_neg_mul_rpow_atTop hv _).isBigO\n  h_feq x hx := by simp [← ofReal_mul, oddKernel_functional_equation a, inv_rpow (le_of_lt hx)]\n\n"}
{"name":"HurwitzZeta.differentiable_completedHurwitzZetaOdd","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.completedHurwitzZetaOdd a)","decl":"lemma differentiable_completedHurwitzZetaOdd (a : UnitAddCircle) :\n    Differentiable ℂ (completedHurwitzZetaOdd a) :=\n  ((hurwitzOddFEPair a).differentiable_Λ.comp\n    ((differentiable_id.add_const 1).div_const 2)).div_const 2\n\n"}
{"name":"HurwitzZeta.differentiable_completedSinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.completedSinZeta a)","decl":"lemma differentiable_completedSinZeta (a : UnitAddCircle) :\n    Differentiable ℂ (completedSinZeta a) :=\n  ((hurwitzOddFEPair a).symm.differentiable_Λ.comp\n    ((differentiable_id.add_const 1).div_const 2)).div_const 2\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaOdd_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaOdd (Neg.neg a) s) (Neg.neg (HurwitzZeta.completedHurwitzZetaOdd a s))","decl":"lemma completedHurwitzZetaOdd_neg (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaOdd (-a) s = -completedHurwitzZetaOdd a s := by\n  simp [completedHurwitzZetaOdd, StrongFEPair.Λ, hurwitzOddFEPair, mellin, oddKernel_neg,\n    integral_neg, neg_div]\n\n"}
{"name":"HurwitzZeta.completedSinZeta_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedSinZeta (Neg.neg a) s) (Neg.neg (HurwitzZeta.completedSinZeta a s))","decl":"lemma completedSinZeta_neg (a : UnitAddCircle) (s : ℂ) :\n    completedSinZeta (-a) s = -completedSinZeta a s := by\n  simp [completedSinZeta, StrongFEPair.Λ, mellin, StrongFEPair.symm, WeakFEPair.symm,\n    hurwitzOddFEPair, sinKernel_neg, integral_neg, neg_div]\n\n"}
{"name":"HurwitzZeta.completedHurwitzZetaOdd_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedHurwitzZetaOdd a (HSub.hSub 1 s)) (HurwitzZeta.completedSinZeta a s)","decl":"/-- Functional equation for the odd Hurwitz zeta function. -/\ntheorem completedHurwitzZetaOdd_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedHurwitzZetaOdd a (1 - s) = completedSinZeta a s := by\n  rw [completedHurwitzZetaOdd, completedSinZeta,\n    (by { push_cast; ring } : (1 - s + 1) / 2 = ↑(3 / 2 : ℝ) - (s + 1) / 2),\n    ← hurwitzOddFEPair_k, (hurwitzOddFEPair a).functional_equation ((s + 1) / 2),\n    hurwitzOddFEPair_ε, one_smul]\n\n"}
{"name":"HurwitzZeta.completedSinZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.completedSinZeta a (HSub.hSub 1 s)) (HurwitzZeta.completedHurwitzZetaOdd a s)","decl":"/-- Functional equation for the odd Hurwitz zeta function (alternative form). -/\nlemma completedSinZeta_one_sub (a : UnitAddCircle) (s : ℂ) :\n    completedSinZeta a (1 - s) = completedHurwitzZetaOdd a s := by\n  simp [← completedHurwitzZetaOdd_one_sub]\n\n"}
{"name":"HurwitzZeta.hasSum_int_completedSinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (HAdd.hAdd s 1).Gammaℝ (Neg.neg Complex.I)) ↑n.sign) (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n))) (HPow.hPow (↑(abs n)) s)) 2) (HurwitzZeta.completedSinZeta (↑a) s)","decl":"/-- Formula for `completedSinZeta` as a Dirichlet series in the convergence range\n(first version, with sum over `ℤ`). -/\nlemma hasSum_int_completedSinZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ Gammaℝ (s + 1) * (-I) * Int.sign n *\n    cexp (2 * π * I * a * n) / (↑|n| : ℂ) ^ s / 2) (completedSinZeta a s) := by\n  let c (n : ℤ) : ℂ := -I * cexp (2 * π * I * a * n) / 2\n  have hc (n : ℤ) : ‖c n‖ = 1 / 2 := by\n    simp_rw [c, (by { push_cast; ring } : 2 * π * I * a * n = ↑(2 * π * a * n) * I), norm_div,\n      RCLike.norm_ofNat, norm_mul, norm_neg, norm_I, one_mul, norm_exp_ofReal_mul_I]\n  have hF t (ht : 0 < t) :\n      HasSum (fun n ↦ c n * n * rexp (-π * n ^ 2 * t)) (sinKernel a t / 2) := by\n    refine ((hasSum_int_sinKernel a ht).div_const 2).congr_fun fun n ↦ ?_\n    rw [div_mul_eq_mul_div, div_mul_eq_mul_div, mul_right_comm (-I)]\n  have h_sum : Summable fun i ↦ ‖c i‖ / |↑i| ^ s.re := by\n    simp_rw [hc, div_right_comm]\n    apply Summable.div_const\n    apply Summable.of_nat_of_neg <;>\n    simpa\n  refine (mellin_div_const .. ▸ hasSum_mellin_pi_mul_sq' (zero_lt_one.trans hs) hF h_sum).congr_fun\n    fun n ↦ ?_\n  simp [Int.sign_eq_sign, ← Int.cast_abs] -- non-terminal simp OK when `ring` follows\n  ring\n\n"}
{"name":"HurwitzZeta.hasSum_nat_completedSinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HMul.hMul (HAdd.hAdd s 1).Gammaℝ ↑(Real.sin (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑n))) (HPow.hPow (↑n) s)) (HurwitzZeta.completedSinZeta (↑a) s)","decl":"/-- Formula for `completedSinZeta` as a Dirichlet series in the convergence range\n(second version, with sum over `ℕ`). -/\nlemma hasSum_nat_completedSinZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ Gammaℝ (s + 1) * Real.sin (2 * π * a * n) / (n : ℂ) ^ s)\n    (completedSinZeta a s) := by\n  have := (hasSum_int_completedSinZeta a hs).nat_add_neg\n  simp_rw [Int.sign_zero, Int.cast_zero, mul_zero, zero_mul, zero_div, add_zero, abs_neg,\n    Int.sign_neg, Nat.abs_cast, Int.cast_neg, Int.cast_natCast, ← add_div] at this\n  refine this.congr_fun fun n ↦ ?_\n  rw [div_right_comm]\n  rcases eq_or_ne n 0 with rfl | h\n  · simp\n  simp_rw [Int.sign_natCast_of_ne_zero h, Int.cast_one, ofReal_sin, Complex.sin]\n  simp only [← mul_div_assoc, push_cast, mul_assoc (Gammaℝ _), ← mul_add]\n  congr 3\n  rw [mul_one, mul_neg_one, neg_neg, neg_mul I, ← sub_eq_neg_add, ← mul_sub, mul_comm,\n    mul_neg, neg_mul]\n  congr 3 <;> ring\n\n"}
{"name":"HurwitzZeta.hasSum_int_completedHurwitzZetaOdd","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (HMul.hMul (HAdd.hAdd s 1).Gammaℝ ↑(SignType.sign (HAdd.hAdd (↑n) a))) (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) 2) (HurwitzZeta.completedHurwitzZetaOdd (↑a) s)","decl":"/-- Formula for `completedHurwitzZetaOdd` as a Dirichlet series in the convergence range. -/\nlemma hasSum_int_completedHurwitzZetaOdd (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ Gammaℝ (s + 1) * SignType.sign (n + a) / (↑|n + a| : ℂ) ^ s / 2)\n    (completedHurwitzZetaOdd a s) := by\n  let r (n : ℤ) : ℝ := n + a\n  let c (n : ℤ) : ℂ := 1 / 2\n  have hF t (ht : 0 < t) : HasSum (fun n ↦ c n * r n * rexp (-π * (r n) ^ 2 * t))\n      (oddKernel a t / 2) := by\n    refine ((hasSum_ofReal.mpr (hasSum_int_oddKernel a ht)).div_const 2).congr_fun fun n ↦ ?_\n    simp [r, c, push_cast, div_mul_eq_mul_div, -one_div]\n  have h_sum : Summable fun i ↦ ‖c i‖ / |r i| ^ s.re := by\n    simp_rw [c, ← mul_one_div ‖_‖]\n    apply Summable.mul_left\n    rwa [summable_one_div_int_add_rpow]\n  have := mellin_div_const .. ▸ hasSum_mellin_pi_mul_sq' (zero_lt_one.trans hs) hF h_sum\n  refine this.congr_fun fun n ↦ ?_\n  simp only [r, c, mul_one_div, div_mul_eq_mul_div, div_right_comm]\n\n"}
{"name":"HurwitzZeta.hurwitzZetaOdd_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.hurwitzZetaOdd (Neg.neg a) s) (Neg.neg (HurwitzZeta.hurwitzZetaOdd a s))","decl":"lemma hurwitzZetaOdd_neg (a : UnitAddCircle) (s : ℂ) :\n    hurwitzZetaOdd (-a) s = -hurwitzZetaOdd a s := by\n  simp_rw [hurwitzZetaOdd, completedHurwitzZetaOdd_neg, neg_div]\n\n"}
{"name":"HurwitzZeta.differentiable_hurwitzZetaOdd","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.hurwitzZetaOdd a)","decl":"/-- The odd Hurwitz zeta function is differentiable everywhere. -/\nlemma differentiable_hurwitzZetaOdd (a : UnitAddCircle) :\n    Differentiable ℂ (hurwitzZetaOdd a) :=\n  (differentiable_completedHurwitzZetaOdd a).mul <| differentiable_Gammaℝ_inv.comp <|\n    differentiable_id.add <| differentiable_const _\n\n"}
{"name":"HurwitzZeta.sinZeta_neg","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\n⊢ Eq (HurwitzZeta.sinZeta (Neg.neg a) s) (Neg.neg (HurwitzZeta.sinZeta a s))","decl":"lemma sinZeta_neg (a : UnitAddCircle) (s : ℂ) :\n    sinZeta (-a) s = -sinZeta a s := by\n  simp_rw [sinZeta, completedSinZeta_neg, neg_div]\n\n"}
{"name":"HurwitzZeta.differentiableAt_sinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\n⊢ Differentiable Complex (HurwitzZeta.sinZeta a)","decl":"/-- The sine zeta function is differentiable everywhere. -/\nlemma differentiableAt_sinZeta (a : UnitAddCircle) :\n    Differentiable ℂ (sinZeta a) :=\n  (differentiable_completedSinZeta a).mul <| differentiable_Gammaℝ_inv.comp <|\n    differentiable_id.add <| differentiable_const _\n\n"}
{"name":"HurwitzZeta.hasSum_int_hurwitzZetaOdd","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (↑(SignType.sign (HAdd.hAdd (↑n) a))) (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) 2) (HurwitzZeta.hurwitzZetaOdd (↑a) s)","decl":"/-- Formula for `hurwitzZetaOdd` as a Dirichlet series in the convergence range (sum over `ℤ`). -/\ntheorem hasSum_int_hurwitzZetaOdd (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ SignType.sign (n + a) / (↑|n + a| : ℂ) ^ s / 2) (hurwitzZetaOdd a s) := by\n  refine ((hasSum_int_completedHurwitzZetaOdd a hs).div_const (Gammaℝ _)).congr_fun fun n ↦ ?_\n  have : 0 < re (s + 1) := by rw [add_re, one_re]; positivity\n  simp [div_right_comm _ _ (Gammaℝ _), mul_div_cancel_left₀ _ (Gammaℝ_ne_zero_of_re_pos this)]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_hurwitzZetaOdd","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HSub.hSub (HDiv.hDiv (↑(SignType.sign (HAdd.hAdd (↑n) a))) (HPow.hPow (↑(abs (HAdd.hAdd (↑n) a))) s)) (HDiv.hDiv (↑(SignType.sign (HSub.hSub (HAdd.hAdd (↑n) 1) a))) (HPow.hPow (↑(abs (HSub.hSub (HAdd.hAdd (↑n) 1) a))) s))) 2) (HurwitzZeta.hurwitzZetaOdd (↑a) s)","decl":"/-- Formula for `hurwitzZetaOdd` as a Dirichlet series in the convergence range, with sum over `ℕ`\n(version with absolute values) -/\nlemma hasSum_nat_hurwitzZetaOdd (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ (SignType.sign (n + a) / (↑|n + a| : ℂ) ^ s\n      - SignType.sign (n + 1 - a) / (↑|n + 1 - a| : ℂ) ^ s) / 2) (hurwitzZetaOdd a s) := by\n  refine (hasSum_int_hurwitzZetaOdd a hs).nat_add_neg_add_one.congr_fun fun n ↦ ?_\n  rw [Int.cast_neg, Int.cast_add, Int.cast_one, sub_div, sub_eq_add_neg, Int.cast_natCast]\n  have : -(n + 1) + a = -(n + 1 - a) := by ring_nf\n  rw [this, Left.sign_neg, abs_neg, SignType.coe_neg, neg_div, neg_div]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_hurwitzZetaOdd_of_mem_Icc","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\nha : Membership.mem (Set.Icc 0 1) a\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HSub.hSub (HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd ↑n ↑a) s)) (HDiv.hDiv 1 (HPow.hPow (HSub.hSub (HAdd.hAdd (↑n) 1) ↑a) s))) 2) (HurwitzZeta.hurwitzZetaOdd (↑a) s)","decl":"/-- Formula for `hurwitzZetaOdd` as a Dirichlet series in the convergence range, with sum over `ℕ`\n(version without absolute values, assuming `a ∈ Icc 0 1`) -/\nlemma hasSum_nat_hurwitzZetaOdd_of_mem_Icc {a : ℝ} (ha : a ∈ Icc 0 1) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ (1 / (n + a : ℂ) ^ s - 1 / (n + 1 - a : ℂ) ^ s) / 2)\n    (hurwitzZetaOdd a s) := by\n  refine (hasSum_nat_hurwitzZetaOdd a hs).congr_fun fun n ↦ ?_\n  suffices ∀ b : ℝ, 0 ≤ b → SignType.sign (n + b) / (↑|n + b| : ℂ) ^ s = 1 / (n + b) ^ s by\n    simp only [add_sub_assoc, this a ha.1, this (1 - a) (sub_nonneg.mpr ha.2), push_cast]\n  intro b hb\n  rw [abs_of_nonneg (by positivity), (by simp : (n : ℂ) + b = ↑(n + b))]\n  rcases lt_or_eq_of_le (by positivity : 0 ≤ n + b) with hb | hb\n  · simp [sign_pos hb]\n  · rw [← hb, ofReal_zero, zero_cpow ((not_lt.mpr zero_le_one) ∘ (zero_re ▸ · ▸ hs)),\n      div_zero, div_zero]\n\n"}
{"name":"HurwitzZeta.hasSum_int_sinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg Complex.I) ↑n.sign) (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) ↑a) ↑n))) (HPow.hPow (↑(abs n)) s)) 2) (HurwitzZeta.sinZeta (↑a) s)","decl":"/-- Formula for `sinZeta` as a Dirichlet series in the convergence range, with sum over `ℤ`. -/\ntheorem hasSum_int_sinZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℤ ↦ -I * n.sign * cexp (2 * π * I * a * n) / ↑|n| ^ s / 2) (sinZeta a s) := by\n  rw [sinZeta]\n  refine ((hasSum_int_completedSinZeta a hs).div_const (Gammaℝ (s + 1))).congr_fun fun n ↦ ?_\n  have : 0 < re (s + 1) := by rw [add_re, one_re]; positivity\n  simp only [mul_assoc, div_right_comm _ _ (Gammaℝ _),\n    mul_div_cancel_left₀ _ (Gammaℝ_ne_zero_of_re_pos this)]\n\n"}
{"name":"HurwitzZeta.hasSum_nat_sinZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ HasSum (fun n => HDiv.hDiv (↑(Real.sin (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑n))) (HPow.hPow (↑n) s)) (HurwitzZeta.sinZeta (↑a) s)","decl":"/-- Formula for `sinZeta` as a Dirichlet series in the convergence range, with sum over `ℕ`. -/\nlemma hasSum_nat_sinZeta (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    HasSum (fun n : ℕ ↦ Real.sin (2 * π * a * n) / (n : ℂ) ^ s) (sinZeta a s) := by\n  have := (hasSum_int_sinZeta a hs).nat_add_neg\n  simp_rw [abs_neg, Int.sign_neg, Int.cast_neg, Nat.abs_cast, Int.cast_natCast, mul_neg, abs_zero,\n    Int.cast_zero, zero_cpow (ne_zero_of_one_lt_re hs), div_zero, zero_div, add_zero] at this\n  simp_rw [push_cast, Complex.sin]\n  refine this.congr_fun fun n ↦ ?_\n  rcases ne_or_eq n 0 with h | rfl\n  · simp only [neg_mul, sub_mul, div_right_comm _ (2 : ℂ), Int.sign_natCast_of_ne_zero h,\n      Int.cast_one, mul_one, mul_comm I, neg_neg, ← add_div, ← sub_eq_neg_add]\n    congr 5 <;> ring\n  · simp\n\n"}
{"name":"HurwitzZeta.LSeriesHasSum_sin","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesHasSum (fun x => ↑(Real.sin (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) a) ↑x))) s (HurwitzZeta.sinZeta (↑a) s)","decl":"/-- Reformulation of `hasSum_nat_sinZeta` using `LSeriesHasSum`. -/\nlemma LSeriesHasSum_sin (a : ℝ) {s : ℂ} (hs : 1 < re s) :\n    LSeriesHasSum (Real.sin <| 2 * π * a * ·) s (sinZeta a s) :=\n  (hasSum_nat_sinZeta a hs).congr_fun (LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs) _)\n\n"}
{"name":"HurwitzZeta.hurwitzZetaOdd_neg_two_mul_nat_sub_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nn : Nat\n⊢ Eq (HurwitzZeta.hurwitzZetaOdd a (HSub.hSub (HMul.hMul (-2) ↑n) 1)) 0","decl":"/-- The trivial zeroes of the odd Hurwitz zeta function. -/\ntheorem hurwitzZetaOdd_neg_two_mul_nat_sub_one (a : UnitAddCircle) (n : ℕ) :\n    hurwitzZetaOdd a (-2 * n - 1) = 0 := by\n  rw [hurwitzZetaOdd, Gammaℝ_eq_zero_iff.mpr ⟨n, by rw [neg_mul, sub_add_cancel]⟩, div_zero]\n\n"}
{"name":"HurwitzZeta.sinZeta_neg_two_mul_nat_sub_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\nn : Nat\n⊢ Eq (HurwitzZeta.sinZeta a (HSub.hSub (HMul.hMul (-2) ↑n) 1)) 0","decl":"/-- The trivial zeroes of the sine zeta function. -/\ntheorem sinZeta_neg_two_mul_nat_sub_one (a : UnitAddCircle) (n : ℕ) :\n    sinZeta a (-2 * n - 1) = 0 := by\n  rw [sinZeta, Gammaℝ_eq_zero_iff.mpr ⟨n, by rw [neg_mul, sub_add_cancel]⟩, div_zero]\n\n"}
{"name":"HurwitzZeta.hurwitzZetaOdd_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ∀ (n : Nat), Ne s (Neg.neg ↑n)\n⊢ Eq (HurwitzZeta.hurwitzZetaOdd a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (HPow.hPow (HMul.hMul 2 ↑Real.pi) (Neg.neg s))) (Complex.Gamma s)) (Complex.sin (HDiv.hDiv (HMul.hMul (↑Real.pi) s) 2))) (HurwitzZeta.sinZeta a s))","decl":"/-- If `s` is not in `-ℕ`, then `hurwitzZetaOdd a (1 - s)` is an explicit multiple of\n`sinZeta s`. -/\nlemma hurwitzZetaOdd_one_sub (a : UnitAddCircle) {s : ℂ} (hs : ∀ (n : ℕ), s ≠ -n) :\n    hurwitzZetaOdd a (1 - s) = 2 * (2 * π) ^ (-s) * Gamma s * sin (π * s / 2) * sinZeta a s := by\n  rw [← Gammaℂ, hurwitzZetaOdd, (by ring : 1 - s + 1 = 2 - s), div_eq_mul_inv,\n    inv_Gammaℝ_two_sub hs, completedHurwitzZetaOdd_one_sub, sinZeta, ← div_eq_mul_inv,\n    ← mul_div_assoc, ← mul_div_assoc, mul_comm]\n\n"}
{"name":"HurwitzZeta.sinZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZetaOdd","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ∀ (n : Nat), Ne s (Neg.neg ↑n)\n⊢ Eq (HurwitzZeta.sinZeta a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 (HPow.hPow (HMul.hMul 2 ↑Real.pi) (Neg.neg s))) (Complex.Gamma s)) (Complex.sin (HDiv.hDiv (HMul.hMul (↑Real.pi) s) 2))) (HurwitzZeta.hurwitzZetaOdd a s))","decl":"/-- If `s` is not in `-ℕ`, then `sinZeta a (1 - s)` is an explicit multiple of\n`hurwitzZetaOdd s`. -/\nlemma sinZeta_one_sub (a : UnitAddCircle) {s : ℂ} (hs : ∀ (n : ℕ), s ≠ -n) :\n    sinZeta a (1 - s) = 2 * (2 * π) ^ (-s) * Gamma s * sin (π * s / 2) * hurwitzZetaOdd a s := by\n  rw [← Gammaℂ, sinZeta, (by ring : 1 - s + 1 = 2 - s), div_eq_mul_inv, inv_Gammaℝ_two_sub hs,\n    completedSinZeta_one_sub, hurwitzZetaOdd, ← div_eq_mul_inv, ← mul_div_assoc, ← mul_div_assoc,\n    mul_comm]\n\n"}
