{"name":"LieSubmodule.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : SizeOf R\ninst✝¹ : SizeOf L\ninst✝ : SizeOf M\ntoSubmodule : Submodule R M\nlie_mem : ∀ {x : L} {m : M}, Membership.mem toSubmodule.carrier m → Membership.mem toSubmodule.carrier (Bracket.bracket x m)\n⊢ Eq (SizeOf.sizeOf { toSubmodule := toSubmodule, lie_mem := lie_mem }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubmodule))","decl":"/-- A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie module. -/\nstructure LieSubmodule extends Submodule R M where\n  lie_mem : ∀ {x : L} {m : M}, m ∈ carrier → ⁅x, m⁆ ∈ carrier\n\n"}
{"name":"LieSubmodule.mk.inj","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ntoSubmodule✝ : Submodule R M\nlie_mem✝ : ∀ {x : L} {m : M}, Membership.mem toSubmodule✝.carrier m → Membership.mem toSubmodule✝.carrier (Bracket.bracket x m)\ntoSubmodule : Submodule R M\nlie_mem : ∀ {x : L} {m : M}, Membership.mem toSubmodule.carrier m → Membership.mem toSubmodule.carrier (Bracket.bracket x m)\nx✝ : Eq { toSubmodule := toSubmodule✝, lie_mem := lie_mem✝ } { toSubmodule := toSubmodule, lie_mem := lie_mem }\n⊢ Eq toSubmodule✝ toSubmodule","decl":"/-- A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie module. -/\nstructure LieSubmodule extends Submodule R M where\n  lie_mem : ∀ {x : L} {m : M}, m ∈ carrier → ⁅x, m⁆ ∈ carrier\n\n"}
{"name":"LieSubmodule.mk.injEq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ntoSubmodule✝ : Submodule R M\nlie_mem✝ : ∀ {x : L} {m : M}, Membership.mem toSubmodule✝.carrier m → Membership.mem toSubmodule✝.carrier (Bracket.bracket x m)\ntoSubmodule : Submodule R M\nlie_mem : ∀ {x : L} {m : M}, Membership.mem toSubmodule.carrier m → Membership.mem toSubmodule.carrier (Bracket.bracket x m)\n⊢ Eq (Eq { toSubmodule := toSubmodule✝, lie_mem := lie_mem✝ } { toSubmodule := toSubmodule, lie_mem := lie_mem }) (Eq toSubmodule✝ toSubmodule)","decl":"/-- A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie module. -/\nstructure LieSubmodule extends Submodule R M where\n  lie_mem : ∀ {x : L} {m : M}, m ∈ carrier → ⁅x, m⁆ ∈ carrier\n\n"}
{"name":"LieSubmodule.lie_mem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nself : LieSubmodule R L M\nx : L\nm : M\na✝ : Membership.mem self.carrier m\n⊢ Membership.mem self.carrier (Bracket.bracket x m)","decl":"/-- A Lie submodule of a Lie module is a submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie module. -/\nstructure LieSubmodule extends Submodule R M where\n  lie_mem : ∀ {x : L} {m : M}, m ∈ carrier → ⁅x, m⁆ ∈ carrier\n\n"}
{"name":"LieSubmodule.instAddSubgroupClass","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ AddSubgroupClass (LieSubmodule R L M) M","decl":"instance : AddSubgroupClass (LieSubmodule R L M) M where\n  add_mem {N} _ _ := N.add_mem'\n  zero_mem N := N.zero_mem'\n  neg_mem {N} x hx := show -x ∈ N.toSubmodule from neg_mem hx\n\n"}
{"name":"LieSubmodule.instSMulMemClass","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ SMulMemClass (LieSubmodule R L M) R M","decl":"instance instSMulMemClass : SMulMemClass (LieSubmodule R L M) R M where\n  smul_mem {s} c _ h := s.smul_mem'  c h\n\n"}
{"name":"LieSubmodule.instCanLiftSubmoduleToSubmoduleForallForallForallMemBracket","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ CanLift (Submodule R M) (LieSubmodule R L M) (fun x => ↑x) fun N => ∀ {x : L} {m : M}, Membership.mem N m → Membership.mem N (Bracket.bracket x m)","decl":"instance : CanLift (Submodule R M) (LieSubmodule R L M) (·)\n    (fun N ↦ ∀ {x : L} {m : M}, m ∈ N → ⁅x, m⁆ ∈ N) where\n  prf N hN := ⟨⟨N, hN⟩, rfl⟩\n\n"}
{"name":"LieSubmodule.coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq ↑↑N ↑N","decl":"@[norm_cast]\ntheorem coe_toSubmodule : ((N : Submodule R M) : Set M) = N :=\n  rfl\n\n-- `simp` can prove this after `mem_toSubmodule` is added to the simp set,\n-- but `dsimp` can't.\n"}
{"name":"LieSubmodule.mem_carrier","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (↑N).carrier x) (Membership.mem (↑N) x)","decl":"@[simp, nolint simpNF]\ntheorem mem_carrier {x : M} : x ∈ N.carrier ↔ x ∈ (N : Set M) :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.mem_mk_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set M\nh₁ : ∀ {a b : M}, Membership.mem S a → Membership.mem S b → Membership.mem S (HAdd.hAdd a b)\nh₂ : S 0\nh₃ : ∀ (c : R) {x : M}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier (HSMul.hSMul c x)\nh₄ : ∀ {x : L} {m : M}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier m → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier (Bracket.bracket x m)\nx : M\n⊢ Iff (Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃, lie_mem := h₄ } x) (Membership.mem S x)","decl":"theorem mem_mk_iff (S : Set M) (h₁ h₂ h₃ h₄) {x : M} :\n    x ∈ (⟨⟨⟨⟨S, h₁⟩, h₂⟩, h₃⟩, h₄⟩ : LieSubmodule R L M) ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.mem_mk_iff'","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\np : Submodule R M\nh : ∀ {x : L} {m : M}, Membership.mem p.carrier m → Membership.mem p.carrier (Bracket.bracket x m)\nx : M\n⊢ Iff (Membership.mem { toSubmodule := p, lie_mem := h } x) (Membership.mem p x)","decl":"@[simp]\ntheorem mem_mk_iff' (p : Submodule R M) (h) {x : M} :\n    x ∈ (⟨p, h⟩ : LieSubmodule R L M) ↔ x ∈ p :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.mem_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (↑N) x) (Membership.mem N x)","decl":"@[simp]\ntheorem mem_toSubmodule {x : M} : x ∈ (N : Submodule R M) ↔ x ∈ N :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.mem_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (↑N) x) (Membership.mem N x)","decl":"@[deprecated (since := \"2024-12-30\")] alias mem_coeSubmodule := mem_toSubmodule\n\n"}
{"name":"LieSubmodule.mem_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (↑N) x) (Membership.mem N x)","decl":"theorem mem_coe {x : M} : x ∈ (N : Set M) ↔ x ∈ N :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.zero_mem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Membership.mem N 0","decl":"@[simp]\nprotected theorem zero_mem : (0 : M) ∈ N :=\n  zero_mem N\n\n"}
{"name":"LieSubmodule.mk_eq_zero","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : M\nh : Membership.mem N x\n⊢ Iff (Eq ⟨x, h⟩ 0) (Eq x 0)","decl":"@[simp]\ntheorem mk_eq_zero {x} (h : x ∈ N) : (⟨x, h⟩ : N) = 0 ↔ x = 0 :=\n  Subtype.ext_iff_val\n\n"}
{"name":"LieSubmodule.coe_toSet_mk","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set M\nh₁ : ∀ {a b : M}, Membership.mem S a → Membership.mem S b → Membership.mem S (HAdd.hAdd a b)\nh₂ : S 0\nh₃ : ∀ (c : R) {x : M}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier (HSMul.hSMul c x)\nh₄ : ∀ {x : L} {m : M}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier m → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier (Bracket.bracket x m)\n⊢ Eq (↑{ carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃, lie_mem := h₄ }) S","decl":"@[simp]\ntheorem coe_toSet_mk (S : Set M) (h₁ h₂ h₃ h₄) :\n    ((⟨⟨⟨⟨S, h₁⟩, h₂⟩, h₃⟩, h₄⟩ : LieSubmodule R L M) : Set M) = S :=\n  rfl\n\n"}
{"name":"LieSubmodule.toSubmodule_mk","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\np : Submodule R M\nh : ∀ {x : L} {m : M}, Membership.mem p.carrier m → Membership.mem p.carrier (Bracket.bracket x m)\n⊢ Eq (↑{ toSubmodule := p, lie_mem := h }) p","decl":"theorem toSubmodule_mk (p : Submodule R M) (h) :\n    (({ p with lie_mem := h } : LieSubmodule R L M) : Submodule R M) = p := by cases p; rfl\n\n"}
{"name":"LieSubmodule.coe_toSubmodule_mk","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\np : Submodule R M\nh : ∀ {x : L} {m : M}, Membership.mem p.carrier m → Membership.mem p.carrier (Bracket.bracket x m)\n⊢ Eq (↑{ toSubmodule := p, lie_mem := h }) p","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_toSubmodule_mk := toSubmodule_mk\n\n"}
{"name":"LieSubmodule.toSubmodule_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Function.Injective LieSubmodule.toSubmodule","decl":"theorem toSubmodule_injective :\n    Function.Injective (toSubmodule : LieSubmodule R L M → Submodule R M) := fun x y h ↦ by\n  cases x; cases y; congr\n\n"}
{"name":"LieSubmodule.coeSubmodule_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Function.Injective LieSubmodule.toSubmodule","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_injective := toSubmodule_injective\n\n"}
{"name":"LieSubmodule.ext_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Eq N N') (∀ (m : M), Iff (Membership.mem N m) (Membership.mem N' m))","decl":"@[ext]\ntheorem ext (h : ∀ m, m ∈ N ↔ m ∈ N') : N = N' :=\n  SetLike.ext h\n\n"}
{"name":"LieSubmodule.ext","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nh : ∀ (m : M), Iff (Membership.mem N m) (Membership.mem N' m)\n⊢ Eq N N'","decl":"@[ext]\ntheorem ext (h : ∀ m, m ∈ N ↔ m ∈ N') : N = N' :=\n  SetLike.ext h\n\n"}
{"name":"LieSubmodule.toSubmodule_inj","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Eq ↑N ↑N') (Eq N N')","decl":"@[simp]\ntheorem toSubmodule_inj : (N : Submodule R M) = (N' : Submodule R M) ↔ N = N' :=\n  toSubmodule_injective.eq_iff\n\n"}
{"name":"LieSubmodule.coe_toSubmodule_inj","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Eq ↑N ↑N') (Eq N N')","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_toSubmodule_inj := toSubmodule_inj\n\n"}
{"name":"LieSubmodule.toSubmodule_eq_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Eq ↑N ↑N') (Eq N N')","decl":"@[deprecated (since := \"2024-12-29\")] alias toSubmodule_eq_iff := toSubmodule_inj\n\n"}
{"name":"LieSubmodule.coe_copy","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : LieSubmodule R L M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[simp]\ntheorem coe_copy (S : LieSubmodule R L M) (s : Set M) (hs : s = ↑S) : (S.copy s hs : Set M) = s :=\n  rfl\n\n"}
{"name":"LieSubmodule.copy_eq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : LieSubmodule R L M\ns : Set M\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq (S : LieSubmodule R L M) (s : Set M) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"LieSubmodule.coe_zero","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : N) : M) = (0 : M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_add","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm m' : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(HAdd.hAdd m m')) (HAdd.hAdd ↑m ↑m')","decl":"@[simp, norm_cast]\ntheorem coe_add (m m' : N) : (↑(m + m') : M) = (m : M) + (m' : M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_neg","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(Neg.neg m)) (Neg.neg ↑m)","decl":"@[simp, norm_cast]\ntheorem coe_neg (m : N) : (↑(-m) : M) = -(m : M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_sub","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm m' : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(HSub.hSub m m')) (HSub.hSub ↑m ↑m')","decl":"@[simp, norm_cast]\ntheorem coe_sub (m m' : N) : (↑(m - m') : M) = (m : M) - (m' : M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_smul","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nt : R\nm : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(HSMul.hSMul t m)) (HSMul.hSMul t ↑m)","decl":"@[simp, norm_cast]\ntheorem coe_smul (t : R) (m : N) : (↑(t • m) : M) = t • (m : M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.coe_bracket","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nx : L\nm : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(Bracket.bracket x m)) (Bracket.bracket x ↑m)","decl":"@[simp, norm_cast]\ntheorem coe_bracket (x : L) (m : N) :\n    (↑⁅x, m⁆ : M) = ⁅x, ↑m⁆ :=\n  rfl\n\n-- Copying instances from `Submodule` for correct discrimination keys\n"}
{"name":"LieSubmodule.instIsNoetherianSubtypeMem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsNoetherian R M\nN : LieSubmodule R L M\n⊢ IsNoetherian R (Subtype fun x => Membership.mem N x)","decl":"instance [IsNoetherian R M] (N : LieSubmodule R L M) : IsNoetherian R N :=\n  inferInstanceAs <| IsNoetherian R N.toSubmodule\n\n"}
{"name":"LieSubmodule.instIsArtinianSubtypeMem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsArtinian R M\nN : LieSubmodule R L M\n⊢ IsArtinian R (Subtype fun x => Membership.mem N x)","decl":"instance [IsArtinian R M] (N : LieSubmodule R L M) : IsArtinian R N :=\n  inferInstanceAs <| IsArtinian R N.toSubmodule\n\n"}
{"name":"LieSubmodule.instNoZeroSMulDivisorsSubtypeMem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : NoZeroSMulDivisors R M\n⊢ NoZeroSMulDivisors R (Subtype fun x => Membership.mem N x)","decl":"instance [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R N :=\n  inferInstanceAs <| NoZeroSMulDivisors R N.toSubmodule\n\n"}
{"name":"LieSubmodule.instLieModule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : LieAlgebra R L\n⊢ LieModule R L (Subtype fun x => Membership.mem N x)","decl":"instance instLieModule : LieModule R L N where\n  lie_smul := by intro t x y; apply SetCoe.ext; apply lie_smul\n  smul_lie := by intro t x y; apply SetCoe.ext; apply smul_lie\n\n"}
{"name":"lie_mem_right","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx y : L\nh : Membership.mem I y\n⊢ Membership.mem I (Bracket.bracket x y)","decl":"theorem lie_mem_right (I : LieIdeal R L) (x y : L) (h : y ∈ I) : ⁅x, y⁆ ∈ I :=\n  I.lie_mem h\n\n"}
{"name":"lie_mem_left","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx y : L\nh : Membership.mem I x\n⊢ Membership.mem I (Bracket.bracket x y)","decl":"theorem lie_mem_left (I : LieIdeal R L) (x y : L) (h : x ∈ I) : ⁅x, y⁆ ∈ I := by\n  rw [← lie_skew, ← neg_lie]; apply lie_mem_right; assumption\n\n"}
{"name":"LieIdeal.coe_toLieSubalgebra","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq ↑(LieIdeal.toLieSubalgebra R L I) ↑I","decl":"@[simp]\ntheorem LieIdeal.coe_toLieSubalgebra (I : LieIdeal R L) : ((I : LieSubalgebra R L) : Set L) = I :=\n  rfl\n\n"}
{"name":"LieIdeal.coe_toSubalgebra","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq ↑(LieIdeal.toLieSubalgebra R L I) ↑I","decl":"@[deprecated (since := \"2024-12-30\")]\nalias LieIdeal.coe_toSubalgebra := LieIdeal.coe_toLieSubalgebra\n\n"}
{"name":"LieIdeal.toLieSubalgebra_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L I).toSubmodule ↑I","decl":"@[simp]\ntheorem LieIdeal.toLieSubalgebra_toSubmodule (I : LieIdeal R L) :\n    ((I : LieSubalgebra R L) : Submodule R L) = LieSubmodule.toSubmodule I :=\n  rfl\n\n"}
{"name":"LieIdeal.coe_toLieSubalgebra_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L I).toSubmodule ↑I","decl":"@[deprecated (since := \"2025-01-02\")]\nalias LieIdeal.coe_toLieSubalgebra_toSubmodule := LieIdeal.toLieSubalgebra_toSubmodule\n\n"}
{"name":"LieIdeal.coe_to_lieSubalgebra_to_submodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L I).toSubmodule ↑I","decl":"@[deprecated (since := \"2024-12-30\")]\nalias LieIdeal.coe_to_lieSubalgebra_to_submodule := LieIdeal.toLieSubalgebra_toSubmodule\n\n"}
{"name":"LieIdeal.coe_bracket_of_module","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"M : Type w\ninst✝⁴ : AddCommGroup M\nR : Type u_1\nL : Type u_2\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nI : LieIdeal R L\ninst✝ : LieRingModule L M\nx : Subtype fun x => Membership.mem I x\nm : M\n⊢ Eq (Bracket.bracket x m) (Bracket.bracket (↑x) m)","decl":"@[simp]\ntheorem LieIdeal.coe_bracket_of_module {R L : Type*} [CommRing R] [LieRing L] [LieAlgebra R L]\n    (I : LieIdeal R L) [LieRingModule L M] (x : I) (m : M) :\n    ⁅x, m⁆ = ⁅(↑x : L), m⁆ :=\n  LieSubalgebra.coe_bracket_of_module (I : LieSubalgebra R L) x m\n\n"}
{"name":"LieIdeal.lieModule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\nI : LieIdeal R L\n⊢ LieModule R (Subtype fun x => Membership.mem I x) M","decl":"/-- Transfer the `LieModule` instance from the coercion `LieIdeal → LieSubalgebra`. -/\ninstance LieIdeal.lieModule (I : LieIdeal R L) : LieModule R I M :=\n  LieSubalgebra.lieModule (I : LieSubalgebra R L)\n\n"}
{"name":"instIsLieTowerSubtypeMemLieSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ IsLieTower (Subtype fun x => Membership.mem I x) L M","decl":"instance (I : LieIdeal R L) : IsLieTower I L M where\n  leibniz_lie x y m := leibniz_lie x.val y m\n\n"}
{"name":"instIsLieTowerSubtypeMemLieSubmodule_1","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : LieRingModule L M\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ IsLieTower L (Subtype fun x => Membership.mem I x) M","decl":"instance (I : LieIdeal R L) : IsLieTower L I M where\n  leibniz_lie x y m := leibniz_lie x y.val m\n\n"}
{"name":"Submodule.exists_lieSubmodule_coe_eq_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\np : Submodule R M\n⊢ Iff (Exists fun N => Eq (↑N) p) (∀ (x : L) (m : M), Membership.mem p m → Membership.mem p (Bracket.bracket x m))","decl":"theorem Submodule.exists_lieSubmodule_coe_eq_iff (p : Submodule R M) :\n    (∃ N : LieSubmodule R L M, ↑N = p) ↔ ∀ (x : L) (m : M), m ∈ p → ⁅x, m⁆ ∈ p := by\n  constructor\n  · rintro ⟨N, rfl⟩ _ _; exact N.lie_mem\n  · intro h; use { p with lie_mem := @h }\n\n"}
{"name":"LieSubalgebra.coe_toLieSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\n⊢ Eq (↑K.toLieSubmodule) K.toSubmodule","decl":"@[simp]\ntheorem coe_toLieSubmodule : (K.toLieSubmodule : Submodule R L) = K := rfl\n\n"}
{"name":"LieSubalgebra.mem_toLieSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem K.toLieSubmodule x) (Membership.mem K x)","decl":"@[simp]\ntheorem mem_toLieSubmodule (x : L) : x ∈ K.toLieSubmodule ↔ x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.exists_lieIdeal_coe_eq_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\n⊢ Iff (Exists fun I => Eq (LieIdeal.toLieSubalgebra R L I) K) (∀ (x y : L), Membership.mem K y → Membership.mem K (Bracket.bracket x y))","decl":"theorem exists_lieIdeal_coe_eq_iff :\n    (∃ I : LieIdeal R L, ↑I = K) ↔ ∀ x y : L, y ∈ K → ⁅x, y⁆ ∈ K := by\n  simp only [← toSubmodule_inj, LieIdeal.toLieSubalgebra_toSubmodule,\n    Submodule.exists_lieSubmodule_coe_eq_iff L]\n  exact Iff.rfl\n\n"}
{"name":"LieSubalgebra.exists_nested_lieIdeal_coe_eq_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\n⊢ Iff (Exists fun I => Eq (LieIdeal.toLieSubalgebra R (Subtype fun x => Membership.mem K' x) I) (LieSubalgebra.ofLe h)) (∀ (x y : L), Membership.mem K' x → Membership.mem K y → Membership.mem K (Bracket.bracket x y))","decl":"theorem exists_nested_lieIdeal_coe_eq_iff {K' : LieSubalgebra R L} (h : K ≤ K') :\n    (∃ I : LieIdeal R K', ↑I = ofLe h) ↔ ∀ x y : L, x ∈ K' → y ∈ K → ⁅x, y⁆ ∈ K := by\n  simp only [exists_lieIdeal_coe_eq_iff, coe_bracket, mem_ofLe]\n  constructor\n  · intro h' x y hx hy; exact h' ⟨x, hx⟩ ⟨y, h hy⟩ hy\n  · rintro h' ⟨x, hx⟩ ⟨y, hy⟩ hy'; exact h' x y hx hy'\n\n"}
{"name":"LieSubmodule.coe_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Function.Injective SetLike.coe","decl":"theorem coe_injective : Function.Injective ((↑) : LieSubmodule R L M → Set M) :=\n  SetLike.coe_injective\n\n"}
{"name":"LieSubmodule.toSubmodule_le_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (LE.le ↑N ↑N') (LE.le N N')","decl":"@[simp, norm_cast]\ntheorem toSubmodule_le_toSubmodule : (N : Submodule R M) ≤ N' ↔ N ≤ N' :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.coeSubmodule_le_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (LE.le ↑N ↑N') (LE.le N N')","decl":"@[deprecated (since := \"2024-12-30\")]\nalias coeSubmodule_le_coeSubmodule := toSubmodule_le_toSubmodule\n\n"}
{"name":"LieSubmodule.bot_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Bot.bot) (Singleton.singleton 0)","decl":"@[simp]\ntheorem bot_coe : ((⊥ : LieSubmodule R L M) : Set M) = {0} :=\n  rfl\n\n"}
{"name":"LieSubmodule.bot_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp]\ntheorem bot_toSubmodule : ((⊥ : LieSubmodule R L M) : Submodule R M) = ⊥ :=\n  rfl\n\n"}
{"name":"LieSubmodule.bot_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[deprecated (since := \"2024-12-30\")] alias bot_coeSubmodule := bot_toSubmodule\n\n"}
{"name":"LieSubmodule.toSubmodule_eq_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Eq (↑N) Bot.bot) (Eq N Bot.bot)","decl":"@[simp]\ntheorem toSubmodule_eq_bot : (N : Submodule R M) = ⊥ ↔ N = ⊥ := by\n  rw [← toSubmodule_inj, bot_toSubmodule]\n\n"}
{"name":"LieSubmodule.coeSubmodule_eq_bot_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Eq (↑N) Bot.bot) (Eq N Bot.bot)","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_eq_bot_iff := toSubmodule_eq_bot\n\n"}
{"name":"LieSubmodule.mk_eq_bot_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : Submodule R M\nh : ∀ {x : L} {m : M}, Membership.mem N.carrier m → Membership.mem N.carrier (Bracket.bracket x m)\n⊢ Iff (Eq { toSubmodule := N, lie_mem := h } Bot.bot) (Eq N Bot.bot)","decl":"@[simp] theorem mk_eq_bot_iff {N : Submodule R M} {h} :\n    (⟨N, h⟩ : LieSubmodule R L M) = ⊥ ↔ N = ⊥ := by\n  rw [← toSubmodule_inj, bot_toSubmodule]\n\n"}
{"name":"LieSubmodule.mem_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nx : M\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"@[simp]\ntheorem mem_bot (x : M) : x ∈ (⊥ : LieSubmodule R L M) ↔ x = 0 :=\n  mem_singleton_iff\n\n"}
{"name":"LieSubmodule.top_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem top_coe : ((⊤ : LieSubmodule R L M) : Set M) = univ :=\n  rfl\n\n"}
{"name":"LieSubmodule.top_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp]\ntheorem top_toSubmodule : ((⊤ : LieSubmodule R L M) : Submodule R M) = ⊤ :=\n  rfl\n\n"}
{"name":"LieSubmodule.top_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (↑Top.top) Top.top","decl":"@[deprecated (since := \"2024-12-30\")] alias top_coeSubmodule := top_toSubmodule\n\n"}
{"name":"LieSubmodule.toSubmodule_eq_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Eq (↑N) Top.top) (Eq N Top.top)","decl":"@[simp]\ntheorem toSubmodule_eq_top : (N : Submodule R M) = ⊤ ↔ N = ⊤ := by\n  rw [← toSubmodule_inj, top_toSubmodule]\n\n"}
{"name":"LieSubmodule.coeSubmodule_eq_top_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Eq (↑N) Top.top) (Eq N Top.top)","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_eq_top_iff := toSubmodule_eq_top\n\n"}
{"name":"LieSubmodule.mk_eq_top_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : Submodule R M\nh : ∀ {x : L} {m : M}, Membership.mem N.carrier m → Membership.mem N.carrier (Bracket.bracket x m)\n⊢ Iff (Eq { toSubmodule := N, lie_mem := h } Top.top) (Eq N Top.top)","decl":"@[simp] theorem mk_eq_top_iff {N : Submodule R M} {h} :\n    (⟨N, h⟩ : LieSubmodule R L M) = ⊤ ↔ N = ⊤ := by\n  rw [← toSubmodule_inj, top_toSubmodule]\n\n"}
{"name":"LieSubmodule.mem_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nx : M\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : M) : x ∈ (⊤ : LieSubmodule R L M) :=\n  mem_univ x\n\n"}
{"name":"LieSubmodule.inf_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (↑(Min.min N N')) (Inter.inter ↑N ↑N')","decl":"@[simp]\ntheorem inf_coe : (↑(N ⊓ N') : Set M) = ↑N ∩ ↑N' :=\n  rfl\n\n"}
{"name":"LieSubmodule.inf_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (↑(Min.min N N')) (Min.min ↑N ↑N')","decl":"@[norm_cast, simp]\ntheorem inf_toSubmodule :\n    (↑(N ⊓ N') : Submodule R M) = (N : Submodule R M) ⊓ (N' : Submodule R M) :=\n  rfl\n\n"}
{"name":"LieSubmodule.inf_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (↑(Min.min N N')) (Min.min ↑N ↑N')","decl":"@[deprecated (since := \"2024-12-30\")] alias inf_coe_toSubmodule := inf_toSubmodule\n\n"}
{"name":"LieSubmodule.sInf_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(InfSet.sInf S)) (InfSet.sInf (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[simp]\ntheorem sInf_toSubmodule (S : Set (LieSubmodule R L M)) :\n    (↑(sInf S) : Submodule R M) = sInf {(s : Submodule R M) | s ∈ S} :=\n  rfl\n\n"}
{"name":"LieSubmodule.sInf_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(InfSet.sInf S)) (InfSet.sInf (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[deprecated (since := \"2024-12-30\")] alias sInf_coe_toSubmodule := sInf_toSubmodule\n\n"}
{"name":"LieSubmodule.sInf_toSubmodule_eq_iInf","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(InfSet.sInf S)) (iInf fun N => iInf fun h => ↑N)","decl":"theorem sInf_toSubmodule_eq_iInf (S : Set (LieSubmodule R L M)) :\n    (↑(sInf S) : Submodule R M) = ⨅ N ∈ S, (N : Submodule R M) := by\n  rw [sInf_toSubmodule, ← Set.image, sInf_image]\n\n"}
{"name":"LieSubmodule.sInf_coe_toSubmodule'","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(InfSet.sInf S)) (iInf fun N => iInf fun h => ↑N)","decl":"@[deprecated (since := \"2024-12-30\")] alias sInf_coe_toSubmodule' := sInf_toSubmodule_eq_iInf\n\n"}
{"name":"LieSubmodule.iInf_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\n⊢ Eq (↑(iInf fun i => p i)) (iInf fun i => ↑(p i))","decl":"@[simp]\ntheorem iInf_toSubmodule {ι} (p : ι → LieSubmodule R L M) :\n    (↑(⨅ i, p i) : Submodule R M) = ⨅ i, (p i : Submodule R M) := by\n  rw [iInf, sInf_toSubmodule]; ext; simp\n\n"}
{"name":"LieSubmodule.iInf_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\n⊢ Eq (↑(iInf fun i => p i)) (iInf fun i => ↑(p i))","decl":"@[deprecated (since := \"2024-12-30\")] alias iInf_coe_toSubmodule := iInf_toSubmodule\n\n"}
{"name":"LieSubmodule.sInf_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp]\ntheorem sInf_coe (S : Set (LieSubmodule R L M)) : (↑(sInf S) : Set M) = ⋂ s ∈ S, (s : Set M) := by\n  rw [← LieSubmodule.coe_toSubmodule, sInf_toSubmodule, Submodule.sInf_coe]\n  ext m\n  simp only [mem_iInter, mem_setOf_eq, forall_apply_eq_imp_iff₂, exists_imp,\n    and_imp, SetLike.mem_coe, mem_toSubmodule]\n\n"}
{"name":"LieSubmodule.iInf_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\n⊢ Eq (↑(iInf fun i => p i)) (Set.iInter fun i => ↑(p i))","decl":"@[simp]\ntheorem iInf_coe {ι} (p : ι → LieSubmodule R L M) : (↑(⨅ i, p i) : Set M) = ⋂ i, ↑(p i) := by\n  rw [iInf, sInf_coe]; simp only [Set.mem_range, Set.iInter_exists, Set.iInter_iInter_eq']\n\n"}
{"name":"LieSubmodule.mem_iInf","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (iInf fun i => p i) x) (∀ (i : ι), Membership.mem (p i) x)","decl":"@[simp]\ntheorem mem_iInf {ι} (p : ι → LieSubmodule R L M) {x} : (x ∈ ⨅ i, p i) ↔ ∀ i, x ∈ p i := by\n  rw [← SetLike.mem_coe, iInf_coe, Set.mem_iInter]; rfl\n\n"}
{"name":"LieSubmodule.sup_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (↑(Max.max N N')) (Max.max ↑N ↑N')","decl":"@[norm_cast, simp]\ntheorem sup_toSubmodule :\n    (↑(N ⊔ N') : Submodule R M) = (N : Submodule R M) ⊔ (N' : Submodule R M) := by\n  rfl\n\n"}
{"name":"LieSubmodule.sup_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (↑(Max.max N N')) (Max.max ↑N ↑N')","decl":"@[deprecated (since := \"2024-12-30\")] alias sup_coe_toSubmodule := sup_toSubmodule\n\n"}
{"name":"LieSubmodule.sSup_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(SupSet.sSup S)) (SupSet.sSup (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[simp]\ntheorem sSup_toSubmodule (S : Set (LieSubmodule R L M)) :\n    (↑(sSup S) : Submodule R M) = sSup {(s : Submodule R M) | s ∈ S} :=\n  rfl\n\n"}
{"name":"LieSubmodule.sSup_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(SupSet.sSup S)) (SupSet.sSup (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq (↑s) x)))","decl":"@[deprecated (since := \"2024-12-30\")] alias sSup_coe_toSubmodule := sSup_toSubmodule\n\n"}
{"name":"LieSubmodule.sSup_toSubmodule_eq_iSup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(SupSet.sSup S)) (iSup fun N => iSup fun h => ↑N)","decl":"theorem sSup_toSubmodule_eq_iSup (S : Set (LieSubmodule R L M)) :\n    (↑(sSup S) : Submodule R M) = ⨆ N ∈ S, (N : Submodule R M) := by\n  rw [sSup_toSubmodule, ← Set.image, sSup_image]\n\n"}
{"name":"LieSubmodule.sSup_coe_toSubmodule'","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nS : Set (LieSubmodule R L M)\n⊢ Eq (↑(SupSet.sSup S)) (iSup fun N => iSup fun h => ↑N)","decl":"@[deprecated (since := \"2024-12-30\")] alias sSup_coe_toSubmodule' := sSup_toSubmodule_eq_iSup\n\n"}
{"name":"LieSubmodule.iSup_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\n⊢ Eq (↑(iSup fun i => p i)) (iSup fun i => ↑(p i))","decl":"@[simp]\ntheorem iSup_toSubmodule {ι} (p : ι → LieSubmodule R L M) :\n    (↑(⨆ i, p i) : Submodule R M) = ⨆ i, (p i : Submodule R M) := by\n  rw [iSup, sSup_toSubmodule]; ext; simp [Submodule.mem_sSup, Submodule.mem_iSup]\n\n"}
{"name":"LieSubmodule.iSup_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\np : ι → LieSubmodule R L M\n⊢ Eq (↑(iSup fun i => p i)) (iSup fun i => ↑(p i))","decl":"@[deprecated (since := \"2024-12-30\")] alias iSup_coe_toSubmodule := iSup_toSubmodule\n\n"}
{"name":"LieSubmodule.mem_iSup_of_mem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\nb : M\nN : ι → LieSubmodule R L M\ni : ι\nh : Membership.mem (N i) b\n⊢ Membership.mem (iSup fun i => N i) b","decl":"theorem mem_iSup_of_mem {ι} {b : M} {N : ι → LieSubmodule R L M} (i : ι) (h : b ∈ N i) :\n    b ∈ ⨆ i, N i :=\n  (le_iSup N i) h\n\n"}
{"name":"LieSubmodule.iSup_induction","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\nN : ι → LieSubmodule R L M\nC : M → Prop\nx : M\nhx : Membership.mem (iSup fun i => N i) x\nhN : ∀ (i : ι) (y : M), Membership.mem (N i) y → C y\nh0 : C 0\nhadd : ∀ (y z : M), C y → C z → C (HAdd.hAdd y z)\n⊢ C x","decl":"lemma iSup_induction {ι} (N : ι → LieSubmodule R L M) {C : M → Prop} {x : M}\n    (hx : x ∈ ⨆ i, N i) (hN : ∀ i, ∀ y ∈ N i, C y) (h0 : C 0)\n    (hadd : ∀ y z, C y → C z → C (y + z)) : C x := by\n  rw [← LieSubmodule.mem_toSubmodule, LieSubmodule.iSup_toSubmodule] at hx\n  exact Submodule.iSup_induction (C := C) (fun i ↦ (N i : Submodule R M)) hx hN h0 hadd\n\n"}
{"name":"LieSubmodule.iSup_induction'","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\nN : ι → LieSubmodule R L M\nC : (x : M) → Membership.mem (iSup fun i => N i) x → Prop\nhN : ∀ (i : ι) (x : M) (hx : Membership.mem (N i) x), C x ⋯\nh0 : C 0 ⋯\nhadd : ∀ (x y : M) (hx : Membership.mem (iSup fun i => N i) x) (hy : Membership.mem (iSup fun i => N i) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nx : M\nhx : Membership.mem (iSup fun i => N i) x\n⊢ C x hx","decl":"@[elab_as_elim]\ntheorem iSup_induction' {ι} (N : ι → LieSubmodule R L M) {C : (x : M) → (x ∈ ⨆ i, N i) → Prop}\n    (hN : ∀ (i) (x) (hx : x ∈ N i), C x (mem_iSup_of_mem i hx)) (h0 : C 0 (zero_mem _))\n    (hadd : ∀ x y hx hy, C x hx → C y hy → C (x + y) (add_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ ⨆ i, N i) : C x hx := by\n  refine Exists.elim ?_ fun (hx : x ∈ ⨆ i, N i) (hc : C x hx) => hc\n  refine iSup_induction N (C := fun x : M ↦ ∃ (hx : x ∈ ⨆ i, N i), C x hx) hx\n    (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, hN _ _ hx⟩\n  · exact ⟨_, h0⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, hadd _ _ _ _ Cx Cy⟩\n\n-- TODO(Yaël): turn around\n"}
{"name":"LieSubmodule.disjoint_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Disjoint N N') (Disjoint ↑N ↑N')","decl":"theorem disjoint_iff_toSubmodule :\n    Disjoint N N' ↔ Disjoint (N : Submodule R M) (N' : Submodule R M) := by\n  rw [disjoint_iff, disjoint_iff, ← toSubmodule_inj, inf_toSubmodule, bot_toSubmodule,\n    ← disjoint_iff]\n\n"}
{"name":"LieSubmodule.disjoint_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Disjoint N N') (Disjoint ↑N ↑N')","decl":"@[deprecated (since := \"2024-12-30\")] alias disjoint_iff_coe_toSubmodule := disjoint_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.codisjoint_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Codisjoint N N') (Codisjoint ↑N ↑N')","decl":"theorem codisjoint_iff_toSubmodule :\n    Codisjoint N N' ↔ Codisjoint (N : Submodule R M) (N' : Submodule R M) := by\n  rw [codisjoint_iff, codisjoint_iff, ← toSubmodule_inj, sup_toSubmodule,\n    top_toSubmodule, ← codisjoint_iff]\n\n"}
{"name":"LieSubmodule.codisjoint_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (Codisjoint N N') (Codisjoint ↑N ↑N')","decl":"@[deprecated (since := \"2024-12-30\")]\nalias codisjoint_iff_coe_toSubmodule := codisjoint_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.isCompl_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (IsCompl N N') (IsCompl ↑N ↑N')","decl":"theorem isCompl_iff_toSubmodule :\n    IsCompl N N' ↔ IsCompl (N : Submodule R M) (N' : Submodule R M) := by\n  simp only [isCompl_iff, disjoint_iff_toSubmodule, codisjoint_iff_toSubmodule]\n\n"}
{"name":"LieSubmodule.isCompl_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Iff (IsCompl N N') (IsCompl ↑N ↑N')","decl":"@[deprecated (since := \"2024-12-30\")] alias isCompl_iff_coe_toSubmodule := isCompl_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.iSupIndep_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Type u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (iSupIndep N) (iSupIndep fun i => ↑(N i))","decl":"theorem iSupIndep_iff_toSubmodule {ι : Type*} {N : ι → LieSubmodule R L M} :\n    iSupIndep N ↔ iSupIndep fun i ↦ (N i : Submodule R M) := by\n  simp [iSupIndep_def, disjoint_iff_toSubmodule]\n\n"}
{"name":"LieSubmodule.iSupIndep_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Type u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (iSupIndep N) (iSupIndep fun i => ↑(N i))","decl":"@[deprecated (since := \"2024-12-30\")]\nalias iSupIndep_iff_coe_toSubmodule := iSupIndep_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.independent_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Type u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (iSupIndep N) (iSupIndep fun i => ↑(N i))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_toSubmodule := iSupIndep_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.independent_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Type u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (iSupIndep N) (iSupIndep fun i => ↑(N i))","decl":"@[deprecated (since := \"2024-12-30\")]\nalias independent_iff_coe_toSubmodule := independent_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.iSup_eq_top_iff_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (Eq (iSup fun i => N i) Top.top) (Eq (iSup fun i => ↑(N i)) Top.top)","decl":"theorem iSup_eq_top_iff_toSubmodule {ι : Sort*} {N : ι → LieSubmodule R L M} :\n    ⨆ i, N i = ⊤ ↔ ⨆ i, (N i : Submodule R M) = ⊤ := by\n  rw [← iSup_toSubmodule, ← top_toSubmodule (L := L), toSubmodule_inj]\n\n"}
{"name":"LieSubmodule.iSup_eq_top_iff_coe_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\nN : ι → LieSubmodule R L M\n⊢ Iff (Eq (iSup fun i => N i) Top.top) (Eq (iSup fun i => ↑(N i)) Top.top)","decl":"@[deprecated (since := \"2024-12-30\")]\nalias iSup_eq_top_iff_coe_toSubmodule := iSup_eq_top_iff_toSubmodule\n\n"}
{"name":"LieSubmodule.add_eq_sup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\n⊢ Eq (HAdd.hAdd N N') (Max.max N N')","decl":"@[simp]\ntheorem add_eq_sup : N + N' = N ⊔ N' :=\n  rfl\n\n"}
{"name":"LieSubmodule.mem_inf","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (Min.min N N') x) (And (Membership.mem N x) (Membership.mem N' x))","decl":"@[simp]\ntheorem mem_inf (x : M) : x ∈ N ⊓ N' ↔ x ∈ N ∧ x ∈ N' := by\n  rw [← mem_toSubmodule, ← mem_toSubmodule, ← mem_toSubmodule, inf_toSubmodule,\n    Submodule.mem_inf]\n\n"}
{"name":"LieSubmodule.mem_sup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nx : M\n⊢ Iff (Membership.mem (Max.max N N') x) (Exists fun y => And (Membership.mem N y) (Exists fun z => And (Membership.mem N' z) (Eq (HAdd.hAdd y z) x)))","decl":"theorem mem_sup (x : M) : x ∈ N ⊔ N' ↔ ∃ y ∈ N, ∃ z ∈ N', y + z = x := by\n  rw [← mem_toSubmodule, sup_toSubmodule, Submodule.mem_sup]; exact Iff.rfl\n\n"}
{"name":"LieSubmodule.eq_bot_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Eq N Bot.bot) (∀ (m : M), Membership.mem N m → Eq m 0)","decl":"nonrec theorem eq_bot_iff : N = ⊥ ↔ ∀ m : M, m ∈ N → m = 0 := by rw [eq_bot_iff]; exact Iff.rfl\n\n"}
{"name":"LieSubmodule.subsingleton_of_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Subsingleton (LieSubmodule R L (Subtype fun x => Membership.mem Bot.bot x))","decl":"instance subsingleton_of_bot : Subsingleton (LieSubmodule R L (⊥ : LieSubmodule R L M)) := by\n  apply subsingleton_of_bot_eq_top\n  ext ⟨_, hx⟩\n  simp only [mem_bot, mk_eq_zero, mem_top, iff_true]\n  exact hx\n\n"}
{"name":"LieSubmodule.instIsModularLattice","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ IsModularLattice (LieSubmodule R L M)","decl":"instance : IsModularLattice (LieSubmodule R L M) where\n  sup_inf_le_assoc_of_le _ _ := by\n    simp only [← toSubmodule_le_toSubmodule, sup_toSubmodule, inf_toSubmodule]\n    exact IsModularLattice.sup_inf_le_assoc_of_le _\n\n"}
{"name":"LieSubmodule.toSubmodule_orderEmbedding_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nself : LieSubmodule R L M\n⊢ Eq ((LieSubmodule.toSubmodule_orderEmbedding R L M) self) ↑self","decl":"/-- The natural functor that forgets the action of `L` as an order embedding. -/\n@[simps] def toSubmodule_orderEmbedding : LieSubmodule R L M ↪o Submodule R M :=\n  { toFun := (↑)\n    inj' := toSubmodule_injective\n    map_rel_iff' := Iff.rfl }\n\n"}
{"name":"LieSubmodule.wellFoundedGT_of_noetherian","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsNoetherian R M\n⊢ WellFoundedGT (LieSubmodule R L M)","decl":"instance wellFoundedGT_of_noetherian [IsNoetherian R M] : WellFoundedGT (LieSubmodule R L M) :=\n  RelHomClass.isWellFounded (toSubmodule_orderEmbedding R L M).dual.ltEmbedding\n\n"}
{"name":"LieSubmodule.wellFoundedLT_of_isArtinian","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsArtinian R M\n⊢ WellFoundedLT (LieSubmodule R L M)","decl":"theorem wellFoundedLT_of_isArtinian [IsArtinian R M] : WellFoundedLT (LieSubmodule R L M) :=\n  RelHomClass.isWellFounded (toSubmodule_orderEmbedding R L M).ltEmbedding\n\n"}
{"name":"LieSubmodule.instIsAtomicOfIsArtinian","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : IsArtinian R M\n⊢ IsAtomic (LieSubmodule R L M)","decl":"instance [IsArtinian R M] : IsAtomic (LieSubmodule R L M) :=\n  isAtomic_of_orderBot_wellFounded_lt <| (wellFoundedLT_of_isArtinian R L M).wf\n\n"}
{"name":"LieSubmodule.subsingleton_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Iff (Subsingleton (LieSubmodule R L M)) (Subsingleton M)","decl":"@[simp]\ntheorem subsingleton_iff : Subsingleton (LieSubmodule R L M) ↔ Subsingleton M :=\n  have h : Subsingleton (LieSubmodule R L M) ↔ Subsingleton (Submodule R M) := by\n    rw [← subsingleton_iff_bot_eq_top, ← subsingleton_iff_bot_eq_top, ← toSubmodule_inj,\n      top_toSubmodule, bot_toSubmodule]\n  h.trans <| Submodule.subsingleton_iff R\n\n"}
{"name":"LieSubmodule.nontrivial_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Iff (Nontrivial (LieSubmodule R L M)) (Nontrivial M)","decl":"@[simp]\ntheorem nontrivial_iff : Nontrivial (LieSubmodule R L M) ↔ Nontrivial M :=\n  not_iff_not.mp\n    ((not_nontrivial_iff_subsingleton.trans <| subsingleton_iff R L M).trans\n      not_nontrivial_iff_subsingleton.symm)\n\n"}
{"name":"LieSubmodule.instNontrivial","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\ninst✝ : Nontrivial M\n⊢ Nontrivial (LieSubmodule R L M)","decl":"instance [Nontrivial M] : Nontrivial (LieSubmodule R L M) :=\n  (nontrivial_iff R L M).mpr ‹_›\n\n"}
{"name":"LieSubmodule.nontrivial_iff_ne_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Iff (Nontrivial (Subtype fun x => Membership.mem N x)) (Ne N Bot.bot)","decl":"theorem nontrivial_iff_ne_bot {N : LieSubmodule R L M} : Nontrivial N ↔ N ≠ ⊥ := by\n  constructor <;> contrapose!\n  · rintro rfl\n      ⟨⟨m₁, h₁ : m₁ ∈ (⊥ : LieSubmodule R L M)⟩, ⟨m₂, h₂ : m₂ ∈ (⊥ : LieSubmodule R L M)⟩, h₁₂⟩\n    simp [(LieSubmodule.mem_bot _).mp h₁, (LieSubmodule.mem_bot _).mp h₂] at h₁₂\n  · rw [not_nontrivial_iff_subsingleton, LieSubmodule.eq_bot_iff]\n    rintro ⟨h⟩ m hm\n    simpa using h ⟨m, hm⟩ ⟨_, N.zero_mem⟩\n\n"}
{"name":"LieSubmodule.incl_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (↑N.incl) (↑N).subtype","decl":"@[simp]\ntheorem incl_coe : (N.incl : N →ₗ[R] M) = (N : Submodule R M).subtype :=\n  rfl\n\n"}
{"name":"LieSubmodule.incl_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm : Subtype fun x => Membership.mem N x\n⊢ Eq (N.incl m) ↑m","decl":"@[simp]\ntheorem incl_apply (m : N) : N.incl m = m :=\n  rfl\n\n"}
{"name":"LieSubmodule.incl_eq_val","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (⇑N.incl) Subtype.val","decl":"theorem incl_eq_val : (N.incl : N → M) = Subtype.val :=\n  rfl\n\n"}
{"name":"LieSubmodule.injective_incl","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Function.Injective ⇑N.incl","decl":"theorem injective_incl : Function.Injective N.incl := Subtype.coe_injective\n\n"}
{"name":"LieSubmodule.coe_inclusion","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nh : LE.le N N'\nm : Subtype fun x => Membership.mem N x\n⊢ Eq ↑((LieSubmodule.inclusion h) m) ↑m","decl":"@[simp]\ntheorem coe_inclusion (m : N) : (inclusion h m : M) = m :=\n  rfl\n\n"}
{"name":"LieSubmodule.inclusion_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nh : LE.le N N'\nm : Subtype fun x => Membership.mem N x\n⊢ Eq ((LieSubmodule.inclusion h) m) ⟨↑m, ⋯⟩","decl":"theorem inclusion_apply (m : N) : inclusion h m = ⟨m.1, h m.2⟩ :=\n  rfl\n\n"}
{"name":"LieSubmodule.inclusion_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N' : LieSubmodule R L M\nh : LE.le N N'\n⊢ Function.Injective ⇑(LieSubmodule.inclusion h)","decl":"theorem inclusion_injective : Function.Injective (inclusion h) := fun x y ↦ by\n  simp only [inclusion_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe]\n\n"}
{"name":"LieSubmodule.mem_lieSpan","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns : Set M\nx : M\n⊢ Iff (Membership.mem (LieSubmodule.lieSpan R L s) x) (∀ (N : LieSubmodule R L M), HasSubset.Subset s ↑N → Membership.mem N x)","decl":"theorem mem_lieSpan {x : M} : x ∈ lieSpan R L s ↔ ∀ N : LieSubmodule R L M, s ⊆ N → x ∈ N := by\n  change x ∈ (lieSpan R L s : Set M) ↔ _; erw [sInf_coe]; exact mem_iInter₂\n\n"}
{"name":"LieSubmodule.subset_lieSpan","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns : Set M\n⊢ HasSubset.Subset s ↑(LieSubmodule.lieSpan R L s)","decl":"theorem subset_lieSpan : s ⊆ lieSpan R L s := by\n  intro m hm\n  erw [mem_lieSpan]\n  intro N hN\n  exact hN hm\n\n"}
{"name":"LieSubmodule.submodule_span_le_lieSpan","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns : Set M\n⊢ LE.le (Submodule.span R s) ↑(LieSubmodule.lieSpan R L s)","decl":"theorem submodule_span_le_lieSpan : Submodule.span R s ≤ lieSpan R L s := by\n  rw [Submodule.span_le]\n  apply subset_lieSpan\n\n"}
{"name":"LieSubmodule.lieSpan_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns : Set M\nN : LieSubmodule R L M\n⊢ Iff (LE.le (LieSubmodule.lieSpan R L s) N) (HasSubset.Subset s ↑N)","decl":"@[simp]\ntheorem lieSpan_le {N} : lieSpan R L s ≤ N ↔ s ⊆ N := by\n  constructor\n  · exact Subset.trans subset_lieSpan\n  · intro hs m hm; rw [mem_lieSpan] at hm; exact hm _ hs\n\n"}
{"name":"LieSubmodule.lieSpan_mono","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns t : Set M\nh : HasSubset.Subset s t\n⊢ LE.le (LieSubmodule.lieSpan R L s) (LieSubmodule.lieSpan R L t)","decl":"theorem lieSpan_mono {t : Set M} (h : s ⊆ t) : lieSpan R L s ≤ lieSpan R L t := by\n  rw [lieSpan_le]\n  exact Subset.trans h subset_lieSpan\n\n"}
{"name":"LieSubmodule.lieSpan_eq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.lieSpan R L ↑N) N","decl":"theorem lieSpan_eq : lieSpan R L (N : Set M) = N :=\n  le_antisymm (lieSpan_le.mpr rfl.subset) subset_lieSpan\n\n"}
{"name":"LieSubmodule.coe_lieSpan_submodule_eq_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\np : Submodule R M\n⊢ Iff (Eq (↑(LieSubmodule.lieSpan R L ↑p)) p) (Exists fun N => Eq (↑N) p)","decl":"theorem coe_lieSpan_submodule_eq_iff {p : Submodule R M} :\n    (lieSpan R L (p : Set M) : Submodule R M) = p ↔ ∃ N : LieSubmodule R L M, ↑N = p := by\n  rw [p.exists_lieSubmodule_coe_eq_iff L]; constructor <;> intro h\n  · intro x m hm; rw [← h, mem_toSubmodule]; exact lie_mem _ (subset_lieSpan hm)\n  · rw [← toSubmodule_mk p @h, coe_toSubmodule, toSubmodule_inj, lieSpan_eq]\n\n"}
{"name":"LieSubmodule.span_empty","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (LieSubmodule.lieSpan R L EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem span_empty : lieSpan R L (∅ : Set M) = ⊥ :=\n  (LieSubmodule.gi R L M).gc.l_bot\n\n"}
{"name":"LieSubmodule.span_univ","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq (LieSubmodule.lieSpan R L Set.univ) Top.top","decl":"@[simp]\ntheorem span_univ : lieSpan R L (Set.univ : Set M) = ⊤ :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_lieSpan\n\n"}
{"name":"LieSubmodule.lieSpan_eq_bot_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns : Set M\n⊢ Iff (Eq (LieSubmodule.lieSpan R L s) Bot.bot) (∀ (m : M), Membership.mem s m → Eq m 0)","decl":"theorem lieSpan_eq_bot_iff : lieSpan R L s = ⊥ ↔ ∀ m ∈ s, m = (0 : M) := by\n  rw [_root_.eq_bot_iff, lieSpan_le, bot_coe, subset_singleton_iff]\n\n"}
{"name":"LieSubmodule.span_union","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\ns t : Set M\n⊢ Eq (LieSubmodule.lieSpan R L (Union.union s t)) (Max.max (LieSubmodule.lieSpan R L s) (LieSubmodule.lieSpan R L t))","decl":"theorem span_union (s t : Set M) : lieSpan R L (s ∪ t) = lieSpan R L s ⊔ lieSpan R L t :=\n  (LieSubmodule.gi R L M).gc.l_sup\n\n"}
{"name":"LieSubmodule.span_iUnion","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nι : Sort u_1\ns : ι → Set M\n⊢ Eq (LieSubmodule.lieSpan R L (Set.iUnion fun i => s i)) (iSup fun i => LieSubmodule.lieSpan R L (s i))","decl":"theorem span_iUnion {ι} (s : ι → Set M) : lieSpan R L (⋃ i, s i) = ⨆ i, lieSpan R L (s i) :=\n  (LieSubmodule.gi R L M).gc.l_iSup\n\n"}
{"name":"LieSubmodule.isCompactElement_lieSpan_singleton","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nm : M\n⊢ CompleteLattice.IsCompactElement (LieSubmodule.lieSpan R L (Singleton.singleton m))","decl":"lemma isCompactElement_lieSpan_singleton (m : M) :\n    CompleteLattice.IsCompactElement (lieSpan R L {m}) := by\n  rw [CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le]\n  intro s hne hdir hsup\n  replace hsup : m ∈ (↑(sSup s) : Set M) := (SetLike.le_def.mp hsup) (subset_lieSpan rfl)\n  suffices (↑(sSup s) : Set M) = ⋃ N ∈ s, ↑N by\n    obtain ⟨N : LieSubmodule R L M, hN : N ∈ s, hN' : m ∈ N⟩ := by\n      simp_rw [this, Set.mem_iUnion, SetLike.mem_coe, exists_prop] at hsup; assumption\n    exact ⟨N, hN, by simpa⟩\n  replace hne : Nonempty s := Set.nonempty_coe_sort.mpr hne\n  have := Submodule.coe_iSup_of_directed _ hdir.directed_val\n  simp_rw [← iSup_toSubmodule, Set.iUnion_coe_set, coe_toSubmodule] at this\n  rw [← this, SetLike.coe_set_eq, sSup_eq_iSup, iSup_subtype]\n\n"}
{"name":"LieSubmodule.sSup_image_lieSpan_singleton","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (SupSet.sSup (Set.image (fun x => LieSubmodule.lieSpan R L (Singleton.singleton x)) ↑N)) N","decl":"@[simp]\nlemma sSup_image_lieSpan_singleton : sSup ((fun x ↦ lieSpan R L {x}) '' N) = N := by\n  refine le_antisymm (sSup_le <| by simp) ?_\n  simp_rw [← toSubmodule_le_toSubmodule, sSup_toSubmodule, Set.mem_image, SetLike.mem_coe]\n  refine fun m hm ↦ Submodule.mem_sSup.mpr fun N' hN' ↦ ?_\n  replace hN' : ∀ m ∈ N, lieSpan R L {m} ≤ N' := by simpa using hN'\n  exact hN' _ hm (subset_lieSpan rfl)\n\n"}
{"name":"LieSubmodule.instIsCompactlyGenerated","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ IsCompactlyGenerated (LieSubmodule R L M)","decl":"instance instIsCompactlyGenerated : IsCompactlyGenerated (LieSubmodule R L M) :=\n  ⟨fun N ↦ ⟨(fun x ↦ lieSpan R L {x}) '' N, fun _ ⟨m, _, hm⟩ ↦\n    hm ▸ isCompactElement_lieSpan_singleton R L m, N.sSup_image_lieSpan_singleton⟩⟩\n\n"}
{"name":"LieSubmodule.coe_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\n⊢ Eq (↑(LieSubmodule.map f N)) (Set.image ⇑f ↑N)","decl":"@[simp] theorem coe_map : (N.map f : Set M') = f '' N := rfl\n\n"}
{"name":"LieSubmodule.toSubmodule_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\n⊢ Eq (↑(LieSubmodule.map f N)) (Submodule.map ↑f ↑N)","decl":"@[simp]\ntheorem toSubmodule_map : (N.map f : Submodule R M') = (N : Submodule R M).map (f : M →ₗ[R] M') :=\n  rfl\n\n"}
{"name":"LieSubmodule.coeSubmodule_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\n⊢ Eq (↑(LieSubmodule.map f N)) (Submodule.map ↑f ↑N)","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_map := toSubmodule_map\n\n"}
{"name":"LieSubmodule.toSubmodule_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN' : LieSubmodule R L M'\n⊢ Eq (↑(LieSubmodule.comap f N')) (Submodule.comap ↑f ↑N')","decl":"@[simp]\ntheorem toSubmodule_comap :\n    (N'.comap f : Submodule R M) = (N' : Submodule R M').comap (f : M →ₗ[R] M') :=\n  rfl\n\n"}
{"name":"LieSubmodule.coeSubmodule_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN' : LieSubmodule R L M'\n⊢ Eq (↑(LieSubmodule.comap f N')) (Submodule.comap ↑f ↑N')","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_comap := toSubmodule_comap\n\n"}
{"name":"LieSubmodule.map_le_iff_le_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\nN' : LieSubmodule R L M'\n⊢ Iff (LE.le (LieSubmodule.map f N) N') (LE.le N (LieSubmodule.comap f N'))","decl":"theorem map_le_iff_le_comap : map f N ≤ N' ↔ N ≤ comap f N' :=\n  Set.image_subset_iff\n\n"}
{"name":"LieSubmodule.gc_map_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\n⊢ GaloisConnection (LieSubmodule.map f) (LieSubmodule.comap f)","decl":"theorem gc_map_comap : GaloisConnection (map f) (comap f) := fun _ _ ↦ map_le_iff_le_comap\n\n"}
{"name":"LieSubmodule.map_inf_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN N₂ : LieSubmodule R L M\n⊢ LE.le (LieSubmodule.map f (Min.min N N₂)) (Min.min (LieSubmodule.map f N) (LieSubmodule.map f N₂))","decl":"theorem map_inf_le : (N ⊓ N₂).map f ≤ N.map f ⊓ N₂.map f :=\n  Set.image_inter_subset f N N₂\n\n"}
{"name":"LieSubmodule.map_inf","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN N₂ : LieSubmodule R L M\nhf : Function.Injective ⇑f\n⊢ Eq (LieSubmodule.map f (Min.min N N₂)) (Min.min (LieSubmodule.map f N) (LieSubmodule.map f N₂))","decl":"theorem map_inf (hf : Function.Injective f) :\n    (N ⊓ N₂).map f = N.map f ⊓ N₂.map f :=\n  SetLike.coe_injective <| Set.image_inter hf\n\n"}
{"name":"LieSubmodule.map_sup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN N₂ : LieSubmodule R L M\n⊢ Eq (LieSubmodule.map f (Max.max N N₂)) (Max.max (LieSubmodule.map f N) (LieSubmodule.map f N₂))","decl":"@[simp]\ntheorem map_sup : (N ⊔ N₂).map f = N.map f ⊔ N₂.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"LieSubmodule.comap_inf","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN' N₂' : LieSubmodule R L M'\n⊢ Eq (LieSubmodule.comap f (Min.min N' N₂')) (Min.min (LieSubmodule.comap f N') (LieSubmodule.comap f N₂'))","decl":"@[simp]\ntheorem comap_inf {N₂' : LieSubmodule R L M'} :\n    (N' ⊓ N₂').comap f = N'.comap f ⊓ N₂'.comap f :=\n  rfl\n\n"}
{"name":"LieSubmodule.map_iSup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nι : Sort u_1\nN : ι → LieSubmodule R L M\n⊢ Eq (LieSubmodule.map f (iSup fun i => N i)) (iSup fun i => LieSubmodule.map f (N i))","decl":"@[simp]\ntheorem map_iSup {ι : Sort*} (N : ι → LieSubmodule R L M) :\n    (⨆ i, N i).map f = ⨆ i, (N i).map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_iSup\n\n"}
{"name":"LieSubmodule.mem_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\nm' : M'\n⊢ Iff (Membership.mem (LieSubmodule.map f N) m') (Exists fun m => And (Membership.mem N m) (Eq (f m) m'))","decl":"@[simp]\ntheorem mem_map (m' : M') : m' ∈ N.map f ↔ ∃ m, m ∈ N ∧ f m = m' :=\n  Submodule.mem_map\n\n"}
{"name":"LieSubmodule.mem_map_of_mem","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\nm : M\nh : Membership.mem N m\n⊢ Membership.mem (LieSubmodule.map f N) (f m)","decl":"theorem mem_map_of_mem {m : M} (h : m ∈ N) : f m ∈ N.map f :=\n  Set.mem_image_of_mem _ h\n\n"}
{"name":"LieSubmodule.mem_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN' : LieSubmodule R L M'\nm : M\n⊢ Iff (Membership.mem (LieSubmodule.comap f N') m) (Membership.mem N' (f m))","decl":"@[simp]\ntheorem mem_comap {m : M} : m ∈ comap f N' ↔ f m ∈ N' :=\n  Iff.rfl\n\n"}
{"name":"LieSubmodule.comap_incl_eq_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N₂ : LieSubmodule R L M\n⊢ Iff (Eq (LieSubmodule.comap N.incl N₂) Top.top) (LE.le N N₂)","decl":"theorem comap_incl_eq_top : N₂.comap N.incl = ⊤ ↔ N ≤ N₂ := by\n  rw [← LieSubmodule.toSubmodule_inj, LieSubmodule.toSubmodule_comap, LieSubmodule.incl_coe,\n    LieSubmodule.top_toSubmodule, Submodule.comap_subtype_eq_top, toSubmodule_le_toSubmodule]\n\n"}
{"name":"LieSubmodule.comap_incl_eq_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN N₂ : LieSubmodule R L M\n⊢ Iff (Eq (LieSubmodule.comap N.incl N₂) Bot.bot) (Eq (Min.min N N₂) Bot.bot)","decl":"theorem comap_incl_eq_bot : N₂.comap N.incl = ⊥ ↔ N ⊓ N₂ = ⊥ := by\n  simp only [← toSubmodule_inj, toSubmodule_comap, incl_coe, bot_toSubmodule,\n    inf_toSubmodule]\n  rw [← Submodule.disjoint_iff_comap_eq_bot, disjoint_iff]\n\n"}
{"name":"LieSubmodule.map_mono","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN N₂ : LieSubmodule R L M\nh : LE.le N N₂\n⊢ LE.le (LieSubmodule.map f N) (LieSubmodule.map f N₂)","decl":"@[gcongr, mono]\ntheorem map_mono (h : N ≤ N₂) : N.map f ≤ N₂.map f :=\n  Set.image_subset _ h\n\n"}
{"name":"LieSubmodule.map_comp","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : LieRingModule L M\ninst✝⁵ : AddCommGroup M'\ninst✝⁴ : Module R M'\ninst✝³ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN : LieSubmodule R L M\nM'' : Type u_1\ninst✝² : AddCommGroup M''\ninst✝¹ : Module R M''\ninst✝ : LieRingModule L M''\ng : LieModuleHom R L M' M''\n⊢ Eq (LieSubmodule.map (g.comp f) N) (LieSubmodule.map g (LieSubmodule.map f N))","decl":"theorem map_comp\n    {M'' : Type*} [AddCommGroup M''] [Module R M''] [LieRingModule L M''] {g : M' →ₗ⁅R,L⁆ M''} :\n    N.map (g.comp f) = (N.map f).map g :=\n  SetLike.coe_injective <| by\n    simp only [← Set.image_comp, coe_map, LinearMap.coe_comp, LieModuleHom.coe_comp]\n\n"}
{"name":"LieSubmodule.map_id","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.map LieModuleHom.id N) N","decl":"@[simp]\ntheorem map_id : N.map LieModuleHom.id = N := by ext; simp\n\n"}
{"name":"LieSubmodule.map_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\n⊢ Eq (LieSubmodule.map f Bot.bot) Bot.bot","decl":"@[simp] theorem map_bot :\n    (⊥ : LieSubmodule R L M).map f = ⊥ := by\n  ext m; simp [eq_comm]\n\n"}
{"name":"LieSubmodule.map_le_map_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nN N₂ : LieSubmodule R L M\nhf : Function.Injective ⇑f\n⊢ Iff (LE.le (LieSubmodule.map f N) (LieSubmodule.map f N₂)) (LE.le N N₂)","decl":"lemma map_le_map_iff (hf : Function.Injective f) :\n    N.map f ≤ N₂.map f ↔ N ≤ N₂ :=\n  Set.image_subset_image_iff hf\n\n"}
{"name":"LieSubmodule.map_injective_of_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nhf : Function.Injective ⇑f\n⊢ Function.Injective (LieSubmodule.map f)","decl":"lemma map_injective_of_injective (hf : Function.Injective f) :\n    Function.Injective (map f) := fun {N N'} h ↦\n  SetLike.coe_injective <| hf.image_injective <| by simp only [← coe_map, h]\n\n"}
{"name":"LieSubmodule.mapOrderEmbedding_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\nhf : Function.Injective ⇑f\nN : LieSubmodule R L M\n⊢ Eq ((LieSubmodule.mapOrderEmbedding hf) N) (LieSubmodule.map f N)","decl":"/-- An injective morphism of Lie modules embeds the lattice of submodules of the domain into that\nof the target. -/\n@[simps] def mapOrderEmbedding {f : M →ₗ⁅R,L⁆ M'} (hf : Function.Injective f) :\n  LieSubmodule R L M ↪o LieSubmodule R L M' where\n    toFun := LieSubmodule.map f\n    inj' := map_injective_of_injective hf\n    map_rel_iff' := Set.image_subset_image_iff hf\n\n"}
{"name":"LieSubmodule.orderIsoMapComap_symm_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\ne : LieModuleEquiv R L M M'\nN' : LieSubmodule R L M'\n⊢ Eq ((RelIso.symm (LieSubmodule.orderIsoMapComap e)) N') (LieSubmodule.comap e.toLieModuleHom N')","decl":"/-- An equivalence of Lie modules yields an order-preserving equivalence of their lattices of Lie\nSubmodules. -/\n@[simps] def orderIsoMapComap (e : M ≃ₗ⁅R,L⁆ M') :\n    LieSubmodule R L M ≃o LieSubmodule R L M' where\n  toFun := map e\n  invFun := comap e\n  left_inv := fun N ↦ by ext; simp\n  right_inv := fun N ↦ by ext; simp [e.apply_eq_iff_eq_symm_apply]\n  map_rel_iff' := fun {_ _} ↦ Set.image_subset_image_iff e.injective\n\n"}
{"name":"LieSubmodule.orderIsoMapComap_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nM' : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\ne : LieModuleEquiv R L M M'\nN : LieSubmodule R L M\n⊢ Eq ((LieSubmodule.orderIsoMapComap e) N) (LieSubmodule.map e.toLieModuleHom N)","decl":"/-- An equivalence of Lie modules yields an order-preserving equivalence of their lattices of Lie\nSubmodules. -/\n@[simps] def orderIsoMapComap (e : M ≃ₗ⁅R,L⁆ M') :\n    LieSubmodule R L M ≃o LieSubmodule R L M' where\n  toFun := map e\n  invFun := comap e\n  left_inv := fun N ↦ by ext; simp\n  right_inv := fun N ↦ by ext; simp [e.apply_eq_iff_eq_symm_apply]\n  map_rel_iff' := fun {_ _} ↦ Set.image_subset_image_iff e.injective\n\n"}
{"name":"LieIdeal.top_toLieSubalgebra","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L Top.top) Top.top","decl":"@[simp]\ntheorem top_toLieSubalgebra : ((⊤ : LieIdeal R L) : LieSubalgebra R L) = ⊤ :=\n  rfl\n\n"}
{"name":"LieIdeal.top_coe_lieSubalgebra","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieIdeal.toLieSubalgebra R L Top.top) Top.top","decl":"@[deprecated (since := \"2024-12-30\")] alias top_coe_lieSubalgebra := top_toLieSubalgebra\n\n"}
{"name":"LieIdeal.map_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nh : Eq (↑(LieIdeal.map f I)) (Set.image ⇑f ↑I)\n⊢ Eq (↑(LieIdeal.map f I)) (Submodule.map ↑f ↑I)","decl":"@[simp]\ntheorem map_toSubmodule (h : ↑(map f I) = f '' I) :\n    LieSubmodule.toSubmodule (map f I) = (LieSubmodule.toSubmodule I).map (f : L →ₗ[R] L') := by\n  rw [SetLike.ext'_iff, LieSubmodule.coe_toSubmodule, h, Submodule.map_coe]; rfl\n\n"}
{"name":"LieIdeal.map_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nh : Eq (↑(LieIdeal.map f I)) (Set.image ⇑f ↑I)\n⊢ Eq (↑(LieIdeal.map f I)) (Submodule.map ↑f ↑I)","decl":"@[deprecated (since := \"2024-12-30\")] alias map_coeSubmodule := map_toSubmodule\n\n"}
{"name":"LieIdeal.comap_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\n⊢ Eq (↑(LieIdeal.comap f J)) (Submodule.comap ↑f ↑J)","decl":"@[simp]\ntheorem comap_toSubmodule :\n    (LieSubmodule.toSubmodule (comap f J)) = (LieSubmodule.toSubmodule J).comap (f : L →ₗ[R] L') :=\n  rfl\n\n"}
{"name":"LieIdeal.comap_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\n⊢ Eq (↑(LieIdeal.comap f J)) (Submodule.comap ↑f ↑J)","decl":"@[deprecated (since := \"2024-12-30\")] alias comap_coeSubmodule := comap_toSubmodule\n\n"}
{"name":"LieIdeal.map_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nJ : LieIdeal R L'\n⊢ Iff (LE.le (LieIdeal.map f I) J) (HasSubset.Subset (Set.image ⇑f ↑I) ↑J)","decl":"theorem map_le : map f I ≤ J ↔ f '' I ⊆ J :=\n  LieSubmodule.lieSpan_le\n\n"}
{"name":"LieIdeal.mem_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nx : L\nhx : Membership.mem I x\n⊢ Membership.mem (LieIdeal.map f I) (f x)","decl":"theorem mem_map {x : L} (hx : x ∈ I) : f x ∈ map f I := by\n  apply LieSubmodule.subset_lieSpan\n  use x\n  exact ⟨hx, rfl⟩\n\n"}
{"name":"LieIdeal.mem_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\nx : L\n⊢ Iff (Membership.mem (LieIdeal.comap f J) x) (Membership.mem J (f x))","decl":"@[simp]\ntheorem mem_comap {x : L} : x ∈ comap f J ↔ f x ∈ J :=\n  Iff.rfl\n\n"}
{"name":"LieIdeal.map_le_iff_le_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nJ : LieIdeal R L'\n⊢ Iff (LE.le (LieIdeal.map f I) J) (LE.le I (LieIdeal.comap f J))","decl":"theorem map_le_iff_le_comap : map f I ≤ J ↔ I ≤ comap f J := by\n  rw [map_le]\n  exact Set.image_subset_iff\n\n"}
{"name":"LieIdeal.gc_map_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ GaloisConnection (LieIdeal.map f) (LieIdeal.comap f)","decl":"theorem gc_map_comap : GaloisConnection (map f) (comap f) := fun _ _ ↦ map_le_iff_le_comap\n\n"}
{"name":"LieIdeal.map_sup","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI I₂ : LieIdeal R L\n⊢ Eq (LieIdeal.map f (Max.max I I₂)) (Max.max (LieIdeal.map f I) (LieIdeal.map f I₂))","decl":"@[simp]\ntheorem map_sup : (I ⊔ I₂).map f = I.map f ⊔ I₂.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"LieIdeal.map_comap_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\n⊢ LE.le (LieIdeal.map f (LieIdeal.comap f J)) J","decl":"theorem map_comap_le : map f (comap f J) ≤ J := by rw [map_le_iff_le_comap]\n\n"}
{"name":"LieIdeal.comap_map_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ LE.le I (LieIdeal.comap f (LieIdeal.map f I))","decl":"/-- See also `LieIdeal.map_comap_eq`. -/\ntheorem comap_map_le : I ≤ comap f (map f I) := by rw [← map_le_iff_le_comap]\n\n"}
{"name":"LieIdeal.map_mono","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Monotone (LieIdeal.map f)","decl":"@[mono]\ntheorem map_mono : Monotone (map f) := fun I₁ I₂ h ↦ by\n  rw [SetLike.le_def] at h\n  apply LieSubmodule.lieSpan_mono (Set.image_subset (⇑f) h)\n\n"}
{"name":"LieIdeal.comap_mono","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Monotone (LieIdeal.comap f)","decl":"@[mono]\ntheorem comap_mono : Monotone (comap f) := fun J₁ J₂ h ↦ by\n  rw [← SetLike.coe_subset_coe] at h ⊢\n  dsimp only [SetLike.coe]\n  exact Set.preimage_mono h\n\n"}
{"name":"LieIdeal.map_of_image","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nJ : LieIdeal R L'\nh : Eq (Set.image ⇑f ↑I) ↑J\n⊢ Eq (LieIdeal.map f I) J","decl":"theorem map_of_image (h : f '' I = J) : I.map f = J := by\n  apply le_antisymm\n  · erw [LieSubmodule.lieSpan_le, Submodule.map_coe, h]\n  · rw [← SetLike.coe_subset_coe, ← h]; exact LieSubmodule.subset_lieSpan\n\n"}
{"name":"LieIdeal.subsingleton_of_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Subsingleton (LieIdeal R (Subtype fun x => Membership.mem Bot.bot x))","decl":"/-- Note that this is not a special case of `LieSubmodule.subsingleton_of_bot`. Indeed, given\n`I : LieIdeal R L`, in general the two lattices `LieIdeal R I` and `LieSubmodule R L I` are\ndifferent (though the latter does naturally inject into the former).\n\nIn other words, in general, ideals of `I`, regarded as a Lie algebra in its own right, are not the\nsame as ideals of `L` contained in `I`. -/\ninstance subsingleton_of_bot : Subsingleton (LieIdeal R (⊥ : LieIdeal R L)) := by\n  apply subsingleton_of_bot_eq_top\n  ext ⟨x, hx⟩\n  rw [LieSubmodule.mem_bot] at hx\n  subst hx\n  simp only [LieSubmodule.mk_eq_zero, LieSubmodule.mem_bot, LieSubmodule.mem_top]\n\n"}
{"name":"LieHom.idealRange_eq_lieSpan_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq f.idealRange (LieSubmodule.lieSpan R L' ↑f.range)","decl":"theorem idealRange_eq_lieSpan_range : f.idealRange = LieSubmodule.lieSpan R L' f.range :=\n  rfl\n\n"}
{"name":"LieHom.idealRange_eq_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq f.idealRange (LieIdeal.map f Top.top)","decl":"theorem idealRange_eq_map : f.idealRange = LieIdeal.map f ⊤ := by\n  ext\n  simp only [idealRange, range_eq_map]\n  rfl\n\n"}
{"name":"LieHom.isIdealMorphism_def","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Iff f.IsIdealMorphism (Eq (LieIdeal.toLieSubalgebra R L' f.idealRange) f.range)","decl":"@[simp]\ntheorem isIdealMorphism_def : f.IsIdealMorphism ↔ (f.idealRange : LieSubalgebra R L') = f.range :=\n  Iff.rfl\n\n"}
{"name":"LieHom.IsIdealMorphism.eq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nhf : f.IsIdealMorphism\n⊢ Eq (LieIdeal.toLieSubalgebra R L' f.idealRange) f.range","decl":"variable {f} in\ntheorem IsIdealMorphism.eq (hf : f.IsIdealMorphism) : f.idealRange = f.range := hf\n\n"}
{"name":"LieHom.isIdealMorphism_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Iff f.IsIdealMorphism (∀ (x : L') (y : L), Exists fun z => Eq (Bracket.bracket x (f y)) (f z))","decl":"theorem isIdealMorphism_iff : f.IsIdealMorphism ↔ ∀ (x : L') (y : L), ∃ z : L, ⁅x, f y⁆ = f z := by\n  simp only [isIdealMorphism_def, idealRange_eq_lieSpan_range, ←\n    LieSubalgebra.toSubmodule_inj, ← f.range.coe_toSubmodule,\n    LieIdeal.toLieSubalgebra_toSubmodule, LieSubmodule.coe_lieSpan_submodule_eq_iff,\n    LieSubalgebra.mem_toSubmodule, mem_range, exists_imp,\n    Submodule.exists_lieSubmodule_coe_eq_iff]\n  constructor\n  · intro h x y; obtain ⟨z, hz⟩ := h x (f y) y rfl; use z; exact hz.symm\n  · intro h x y z hz; obtain ⟨w, hw⟩ := h x z; use w; rw [← hw, hz]\n\n"}
{"name":"LieHom.range_subset_idealRange","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ HasSubset.Subset ↑f.range ↑f.idealRange","decl":"theorem range_subset_idealRange : (f.range : Set L') ⊆ f.idealRange :=\n  LieSubmodule.subset_lieSpan\n\n"}
{"name":"LieHom.map_le_idealRange","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ LE.le (LieIdeal.map f I) f.idealRange","decl":"theorem map_le_idealRange : I.map f ≤ f.idealRange := by\n  rw [f.idealRange_eq_map]\n  exact LieIdeal.map_mono le_top\n\n"}
{"name":"LieHom.ker_le_comap","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\n⊢ LE.le f.ker (LieIdeal.comap f J)","decl":"theorem ker_le_comap : f.ker ≤ J.comap f :=\n  LieIdeal.comap_mono bot_le\n\n"}
{"name":"LieHom.ker_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq (↑f.ker) (LinearMap.ker ↑f)","decl":"@[simp]\ntheorem ker_toSubmodule : LieSubmodule.toSubmodule (ker f) = LinearMap.ker (f : L →ₗ[R] L') :=\n  rfl\n\n"}
{"name":"LieHom.ker_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq (↑f.ker) (LinearMap.ker ↑f)","decl":"@[deprecated (since := \"2024-12-30\")] alias ker_coeSubmodule := ker_toSubmodule\n\n"}
{"name":"LieHom.mem_ker","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nx : L\n⊢ Iff (Membership.mem f.ker x) (Eq (f x) 0)","decl":"variable {f} in\n@[simp]\ntheorem mem_ker {x : L} : x ∈ ker f ↔ f x = 0 :=\n  show x ∈ LieSubmodule.toSubmodule (f.ker) ↔ _ by\n    simp only [ker_toSubmodule, LinearMap.mem_ker, coe_toLinearMap]\n\n"}
{"name":"LieHom.mem_idealRange","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nx : L\n⊢ Membership.mem f.idealRange (f x)","decl":"theorem mem_idealRange (x : L) : f x ∈ idealRange f := by\n  rw [idealRange_eq_map]\n  exact LieIdeal.mem_map (LieSubmodule.mem_top x)\n\n"}
{"name":"LieHom.mem_idealRange_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nh : f.IsIdealMorphism\ny : L'\n⊢ Iff (Membership.mem f.idealRange y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_idealRange_iff (h : IsIdealMorphism f) {y : L'} :\n    y ∈ idealRange f ↔ ∃ x : L, f x = y := by\n  rw [f.isIdealMorphism_def] at h\n  rw [← LieSubmodule.mem_coe, ← LieIdeal.coe_toLieSubalgebra, h, f.range_coe, Set.mem_range]\n\n"}
{"name":"LieHom.le_ker_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ Iff (LE.le I f.ker) (∀ (x : L), Membership.mem I x → Eq (f x) 0)","decl":"theorem le_ker_iff : I ≤ f.ker ↔ ∀ x, x ∈ I → f x = 0 := by\n  constructor <;> intro h x hx\n  · specialize h hx; rw [mem_ker] at h; exact h\n  · rw [mem_ker]; apply h x hx\n\n"}
{"name":"LieHom.ker_eq_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Iff (Eq f.ker Bot.bot) (Function.Injective ⇑f)","decl":"theorem ker_eq_bot : f.ker = ⊥ ↔ Function.Injective f := by\n  rw [← LieSubmodule.toSubmodule_inj, ker_toSubmodule, LieSubmodule.bot_toSubmodule,\n    LinearMap.ker_eq_bot, coe_toLinearMap]\n\n"}
{"name":"LieHom.range_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq f.range.toSubmodule (LinearMap.range ↑f)","decl":"@[simp]\ntheorem range_toSubmodule : (f.range : Submodule R L') = LinearMap.range (f : L →ₗ[R] L') :=\n  rfl\n\n"}
{"name":"LieHom.range_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Eq f.range.toSubmodule (LinearMap.range ↑f)","decl":"@[deprecated (since := \"2024-12-30\")] alias range_coeSubmodule := range_toSubmodule\n\n"}
{"name":"LieHom.range_eq_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"theorem range_eq_top : f.range = ⊤ ↔ Function.Surjective f := by\n  rw [← LieSubalgebra.toSubmodule_inj, range_toSubmodule, LieSubalgebra.top_toSubmodule]\n  exact LinearMap.range_eq_top\n\n"}
{"name":"LieHom.idealRange_eq_top_of_surjective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nh : Function.Surjective ⇑f\n⊢ Eq f.idealRange Top.top","decl":"@[simp]\ntheorem idealRange_eq_top_of_surjective (h : Function.Surjective f) : f.idealRange = ⊤ := by\n  rw [← f.range_eq_top] at h\n  rw [idealRange_eq_lieSpan_range, h, ← LieSubalgebra.coe_toSubmodule, ←\n    LieSubmodule.toSubmodule_inj, LieSubmodule.top_toSubmodule,\n    LieSubalgebra.top_toSubmodule, LieSubmodule.coe_lieSpan_submodule_eq_iff]\n  use ⊤\n  exact LieSubmodule.top_toSubmodule\n\n"}
{"name":"LieHom.isIdealMorphism_of_surjective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nh : Function.Surjective ⇑f\n⊢ f.IsIdealMorphism","decl":"theorem isIdealMorphism_of_surjective (h : Function.Surjective f) : f.IsIdealMorphism := by\n  rw [isIdealMorphism_def, f.idealRange_eq_top_of_surjective h, f.range_eq_top.mpr h,\n    LieIdeal.top_toLieSubalgebra]\n\n"}
{"name":"LieIdeal.map_eq_bot_iff","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ Iff (Eq (LieIdeal.map f I) Bot.bot) (LE.le I f.ker)","decl":"@[simp]\ntheorem map_eq_bot_iff : I.map f = ⊥ ↔ I ≤ f.ker := by\n  rw [← le_bot_iff]\n  exact LieIdeal.map_le_iff_le_comap\n\n"}
{"name":"LieIdeal.coe_map_of_surjective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nh : Function.Surjective ⇑f\n⊢ Eq (↑(LieIdeal.map f I)) (Submodule.map ↑f ↑I)","decl":"theorem coe_map_of_surjective (h : Function.Surjective f) :\n    LieSubmodule.toSubmodule (I.map f) = (LieSubmodule.toSubmodule I).map (f : L →ₗ[R] L') := by\n  let J : LieIdeal R L' :=\n    { (I : Submodule R L).map (f : L →ₗ[R] L') with\n      lie_mem := fun {x y} hy ↦ by\n        have hy' : ∃ x : L, x ∈ I ∧ f x = y := by simpa [hy]\n        obtain ⟨z₂, hz₂, rfl⟩ := hy'\n        obtain ⟨z₁, rfl⟩ := h x\n        simp only [LieHom.coe_toLinearMap, SetLike.mem_coe, Set.mem_image,\n          LieSubmodule.mem_toSubmodule, Submodule.mem_carrier, Submodule.map_coe]\n        use ⁅z₁, z₂⁆\n        exact ⟨I.lie_mem hz₂, f.map_lie z₁ z₂⟩ }\n  erw [LieSubmodule.coe_lieSpan_submodule_eq_iff]\n  use J\n\n"}
{"name":"LieIdeal.mem_map_of_surjective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\ny : L'\nh₁ : Function.Surjective ⇑f\nh₂ : Membership.mem (LieIdeal.map f I) y\n⊢ Exists fun x => Eq (f ↑x) y","decl":"theorem mem_map_of_surjective {y : L'} (h₁ : Function.Surjective f) (h₂ : y ∈ I.map f) :\n    ∃ x : I, f x = y := by\n  rw [← LieSubmodule.mem_toSubmodule, coe_map_of_surjective h₁, Submodule.mem_map] at h₂\n  obtain ⟨x, hx, rfl⟩ := h₂\n  use ⟨x, hx⟩\n  rw [LieHom.coe_toLinearMap]\n\n"}
{"name":"LieIdeal.bot_of_map_eq_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nh₁ : Function.Injective ⇑f\nh₂ : Eq (LieIdeal.map f I) Bot.bot\n⊢ Eq I Bot.bot","decl":"theorem bot_of_map_eq_bot {I : LieIdeal R L} (h₁ : Function.Injective f) (h₂ : I.map f = ⊥) :\n    I = ⊥ := by\n  rw [← f.ker_eq_bot, LieHom.ker] at h₁\n  rw [eq_bot_iff, map_le_iff_le_comap, h₁] at h₂\n  rw [eq_bot_iff]; exact h₂\n\n"}
{"name":"LieIdeal.coe_inclusion","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI₁ I₂ : LieIdeal R L\nh : LE.le I₁ I₂\nx : Subtype fun x => Membership.mem I₁ x\n⊢ Eq ↑((LieIdeal.inclusion h) x) ↑x","decl":"@[simp]\ntheorem coe_inclusion {I₁ I₂ : LieIdeal R L} (h : I₁ ≤ I₂) (x : I₁) : (inclusion h x : L) = x :=\n  rfl\n\n"}
{"name":"LieIdeal.inclusion_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI₁ I₂ : LieIdeal R L\nh : LE.le I₁ I₂\nx : Subtype fun x => Membership.mem I₁ x\n⊢ Eq ((LieIdeal.inclusion h) x) ⟨↑x, ⋯⟩","decl":"theorem inclusion_apply {I₁ I₂ : LieIdeal R L} (h : I₁ ≤ I₂) (x : I₁) :\n    inclusion h x = ⟨x.1, h x.2⟩ :=\n  rfl\n\n"}
{"name":"LieIdeal.inclusion_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI₁ I₂ : LieIdeal R L\nh : LE.le I₁ I₂\n⊢ Function.Injective ⇑(LieIdeal.inclusion h)","decl":"theorem inclusion_injective {I₁ I₂ : LieIdeal R L} (h : I₁ ≤ I₂) :\n    Function.Injective (inclusion h) :=\n  fun x y ↦ by\n  simp only [inclusion_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe]\n\n-- Porting note: LHS simplifies, so moved @[simp] to new theorem `map_sup_ker_eq_map'`\n"}
{"name":"LieIdeal.map_sup_ker_eq_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ Eq (LieIdeal.map f (Max.max I f.ker)) (LieIdeal.map f I)","decl":"theorem map_sup_ker_eq_map : LieIdeal.map f (I ⊔ f.ker) = LieIdeal.map f I := by\n  suffices LieIdeal.map f (I ⊔ f.ker) ≤ LieIdeal.map f I by\n    exact le_antisymm this (LieIdeal.map_mono le_sup_left)\n  apply LieSubmodule.lieSpan_mono\n  rintro x ⟨y, hy₁, hy₂⟩\n  rw [← hy₂]\n  erw [LieSubmodule.mem_sup] at hy₁\n  obtain ⟨z₁, hz₁, z₂, hz₂, hy⟩ := hy₁\n  rw [← hy]\n  rw [f.coe_toLinearMap, f.map_add, LieHom.mem_ker.mp hz₂, add_zero]; exact ⟨z₁, hz₁, rfl⟩\n\n"}
{"name":"LieIdeal.map_sup_ker_eq_map'","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\n⊢ Eq (Max.max (LieIdeal.map f I) (LieIdeal.map f f.ker)) (LieIdeal.map f I)","decl":"@[simp]\ntheorem map_sup_ker_eq_map' :\n    LieIdeal.map f I ⊔ LieIdeal.map f (LieHom.ker f) = LieIdeal.map f I := by\n  simpa using map_sup_ker_eq_map (f := f)\n\n"}
{"name":"LieIdeal.map_comap_eq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nJ : LieIdeal R L'\nh : f.IsIdealMorphism\n⊢ Eq (LieIdeal.map f (LieIdeal.comap f J)) (Min.min f.idealRange J)","decl":"@[simp]\ntheorem map_comap_eq (h : f.IsIdealMorphism) : map f (comap f J) = f.idealRange ⊓ J := by\n  apply le_antisymm\n  · rw [le_inf_iff]; exact ⟨f.map_le_idealRange _, map_comap_le⟩\n  · rw [f.isIdealMorphism_def] at h\n    rw [← SetLike.coe_subset_coe, LieSubmodule.inf_coe, ← coe_toLieSubalgebra, h]\n    rintro y ⟨⟨x, h₁⟩, h₂⟩; rw [← h₁] at h₂ ⊢; exact mem_map h₂\n\n"}
{"name":"LieIdeal.comap_map_eq","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nL' : Type w₂\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieRing L'\ninst✝¹ : LieAlgebra R L'\ninst✝ : LieAlgebra R L\nf : LieHom R L L'\nI : LieIdeal R L\nh : Eq (↑(LieIdeal.map f I)) (Set.image ⇑f ↑I)\n⊢ Eq (LieIdeal.comap f (LieIdeal.map f I)) (Max.max I f.ker)","decl":"@[simp]\ntheorem comap_map_eq (h : ↑(map f I) = f '' I) : comap f (map f I) = I ⊔ f.ker := by\n  rw [← LieSubmodule.toSubmodule_inj, comap_toSubmodule, I.map_toSubmodule f h,\n    LieSubmodule.sup_toSubmodule, f.ker_toSubmodule, Submodule.comap_map_eq]\n\n"}
{"name":"LieIdeal.incl_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq I.incl.range (LieIdeal.toLieSubalgebra R L I)","decl":"@[simp]\ntheorem incl_range : I.incl.range = I :=\n  (I : LieSubalgebra R L).incl_range\n\n"}
{"name":"LieIdeal.incl_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (I.incl x) ↑x","decl":"@[simp]\ntheorem incl_apply (x : I) : I.incl x = x :=\n  rfl\n\n"}
{"name":"LieIdeal.incl_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (↑I.incl) (LieIdeal.toLieSubalgebra R L I).subtype","decl":"@[simp]\ntheorem incl_coe : (I.incl.toLinearMap : I →ₗ[R] L) = (I : Submodule R L).subtype :=\n  rfl\n\n"}
{"name":"LieIdeal.incl_injective","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Function.Injective ⇑I.incl","decl":"lemma incl_injective (I : LieIdeal R L) : Function.Injective I.incl :=\n  Subtype.val_injective\n\n"}
{"name":"LieIdeal.comap_incl_self","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq (LieIdeal.comap I.incl I) Top.top","decl":"@[simp]\ntheorem comap_incl_self : comap I.incl I = ⊤ := by ext; simp\n\n"}
{"name":"LieIdeal.ker_incl","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq I.incl.ker Bot.bot","decl":"@[simp]\ntheorem ker_incl : I.incl.ker = ⊥ := by ext; simp\n\n"}
{"name":"LieIdeal.incl_idealRange","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ Eq I.incl.idealRange I","decl":"@[simp]\ntheorem incl_idealRange : I.incl.idealRange = I := by\n  rw [LieHom.idealRange_eq_lieSpan_range, ← LieSubalgebra.coe_toSubmodule, ←\n    LieSubmodule.toSubmodule_inj, incl_range, toLieSubalgebra_toSubmodule,\n    LieSubmodule.coe_lieSpan_submodule_eq_iff]\n  use I\n\n"}
{"name":"LieIdeal.incl_isIdealMorphism","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\n⊢ I.incl.IsIdealMorphism","decl":"theorem incl_isIdealMorphism : I.incl.IsIdealMorphism := by\n  rw [I.incl.isIdealMorphism_def, incl_idealRange]\n  exact (I : LieSubalgebra R L).incl_range.symm\n\n"}
{"name":"LieModuleHom.ker_toSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (↑f.ker) (LinearMap.ker ↑f)","decl":"@[simp]\ntheorem ker_toSubmodule : (f.ker : Submodule R M) = LinearMap.ker (f : M →ₗ[R] N) :=\n  rfl\n\n"}
{"name":"LieModuleHom.ker_coeSubmodule","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (↑f.ker) (LinearMap.ker ↑f)","decl":"@[deprecated (since := \"2024-12-30\")] alias ker_coeSubmodule := ker_toSubmodule\n\n"}
{"name":"LieModuleHom.ker_eq_bot","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Iff (Eq f.ker Bot.bot) (Function.Injective ⇑f)","decl":"theorem ker_eq_bot : f.ker = ⊥ ↔ Function.Injective f := by\n  rw [← LieSubmodule.toSubmodule_inj, ker_toSubmodule, LieSubmodule.bot_toSubmodule,\n    LinearMap.ker_eq_bot, coe_toLinearMap]\n\n"}
{"name":"LieModuleHom.mem_ker","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nm : M\n⊢ Iff (Membership.mem f.ker m) (Eq (f m) 0)","decl":"@[simp]\ntheorem mem_ker {m : M} : m ∈ f.ker ↔ f m = 0 :=\n  Iff.rfl\n\n"}
{"name":"LieModuleHom.ker_id","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\n⊢ Eq LieModuleHom.id.ker Bot.bot","decl":"@[simp]\ntheorem ker_id : (LieModuleHom.id : M →ₗ⁅R,L⁆ M).ker = ⊥ :=\n  rfl\n\n"}
{"name":"LieModuleHom.comp_ker_incl","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (f.comp f.ker.incl) 0","decl":"@[simp]\ntheorem comp_ker_incl : f.comp f.ker.incl = 0 := by ext ⟨m, hm⟩; exact mem_ker.mp hm\n\n"}
{"name":"LieModuleHom.le_ker_iff_map","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nM' : LieSubmodule R L M\n⊢ Iff (LE.le M' f.ker) (Eq (LieSubmodule.map f M') Bot.bot)","decl":"theorem le_ker_iff_map (M' : LieSubmodule R L M) : M' ≤ f.ker ↔ LieSubmodule.map f M' = ⊥ := by\n  rw [ker, eq_bot_iff, LieSubmodule.map_le_iff_le_comap]\n\n"}
{"name":"LieModuleHom.coe_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_range : f.range = Set.range f :=\n  rfl\n\n"}
{"name":"LieModuleHom.toSubmodule_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (↑f.range) (LinearMap.range ↑f)","decl":"@[simp]\ntheorem toSubmodule_range : f.range = LinearMap.range (f : M →ₗ[R] N) :=\n  rfl\n\n"}
{"name":"LieModuleHom.coeSubmodule_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (↑f.range) (LinearMap.range ↑f)","decl":"@[deprecated (since := \"2024-12-30\")] alias coeSubmodule_range := toSubmodule_range\n\n"}
{"name":"LieModuleHom.mem_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\nn : N\n⊢ Iff (Membership.mem f.range n) (Exists fun m => Eq (f m) n)","decl":"@[simp]\ntheorem mem_range (n : N) : n ∈ f.range ↔ ∃ m, f m = n :=\n  Iff.rfl\n\n"}
{"name":"LieModuleHom.map_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Eq (LieSubmodule.map f Top.top) f.range","decl":"@[simp]\ntheorem map_top : LieSubmodule.map f ⊤ = f.range := by ext; simp [LieSubmodule.mem_map]\n\n"}
{"name":"LieModuleHom.range_eq_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nf : LieModuleHom R L M N\n⊢ Iff (Eq f.range Top.top) (Function.Surjective ⇑f)","decl":"theorem range_eq_top : f.range = ⊤ ↔ Function.Surjective f := by\n  rw [SetLike.ext'_iff, coe_range, LieSubmodule.top_coe, Set.range_eq_univ]\n\n"}
{"name":"LieModuleHom.codRestrict_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\nN : Type w₁\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : LieRingModule L N\nP : LieSubmodule R L N\nf : LieModuleHom R L M N\nh : ∀ (m : M), Membership.mem P (f m)\nm : M\n⊢ Eq (↑((LieModuleHom.codRestrict P f h) m)) (f m)","decl":"@[simp]\nlemma codRestrict_apply (P : LieSubmodule R L N) (f : M →ₗ⁅R,L⁆ N) (h : ∀ m, f m ∈ P) (m : M) :\n    (f.codRestrict P h m : N) = f m :=\n  rfl\n\n"}
{"name":"LieSubmodule.ker_incl","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq N.incl.ker Bot.bot","decl":"@[simp]\ntheorem ker_incl : N.incl.ker = ⊥ := (LieModuleHom.ker_eq_bot N.incl).mpr <| injective_incl N\n\n"}
{"name":"LieSubmodule.range_incl","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq N.incl.range N","decl":"@[simp]\ntheorem range_incl : N.incl.range = N := by\n  simp only [← toSubmodule_inj, LieModuleHom.toSubmodule_range, incl_coe]\n  rw [Submodule.range_subtype]\n\n"}
{"name":"LieSubmodule.comap_incl_self","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.comap N.incl N) Top.top","decl":"@[simp]\ntheorem comap_incl_self : comap N.incl N = ⊤ := by\n  simp only [← toSubmodule_inj, toSubmodule_comap, incl_coe, top_toSubmodule]\n  rw [Submodule.comap_subtype_self]\n\n"}
{"name":"LieSubmodule.map_incl_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\n⊢ Eq (LieSubmodule.map N.incl Top.top) N","decl":"theorem map_incl_top : (⊤ : LieSubmodule R L N).map N.incl = N := by simp\n\n"}
{"name":"LieSubmodule.map_le_range","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\nN : LieSubmodule R L M\nM' : Type u_1\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\nf : LieModuleHom R L M M'\n⊢ LE.le (LieSubmodule.map f N) f.range","decl":"@[simp]\nlemma map_le_range {M' : Type*}\n    [AddCommGroup M'] [Module R M'] [LieRingModule L M'] (f : M →ₗ⁅R,L⁆ M') :\n    N.map f ≤ f.range := by\n  rw [← LieModuleHom.map_top]\n  exact LieSubmodule.map_mono le_top\n\n"}
{"name":"LieSubmodule.map_incl_lt_iff_lt_top","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nN' : LieSubmodule R L (Subtype fun x => Membership.mem N x)\n⊢ Iff (LT.lt (LieSubmodule.map N.incl N') N) (LT.lt N' Top.top)","decl":"@[simp]\nlemma map_incl_lt_iff_lt_top {N' : LieSubmodule R L N} :\n    N'.map (LieSubmodule.incl N) < N ↔ N' < ⊤ := by\n  convert (LieSubmodule.mapOrderEmbedding (f := N.incl) Subtype.coe_injective).lt_iff_lt\n  simp\n\n"}
{"name":"LieSubmodule.map_incl_le","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nN' : LieSubmodule R L (Subtype fun x => Membership.mem N x)\n⊢ LE.le (LieSubmodule.map N.incl N') N","decl":"@[simp]\nlemma map_incl_le {N' : LieSubmodule R L N} :\n    N'.map N.incl ≤ N := by\n  conv_rhs => rw [← N.map_incl_top]\n  exact LieSubmodule.map_mono le_top\n\n"}
{"name":"LieModuleEquiv.ofTop_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\nM : Type u_1\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq ((LieModuleEquiv.ofTop R L M) x) ↑x","decl":"@[simp, nolint simpNF] lemma LieModuleEquiv.ofTop_apply (x : (⊤ : LieSubmodule R L M)) :\n    LieModuleEquiv.ofTop R L M x = x :=\n  rfl\n\n"}
{"name":"LieModuleEquiv.range_coe","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\nM : Type u_1\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\nM' : Type u_2\ninst✝² : AddCommGroup M'\ninst✝¹ : Module R M'\ninst✝ : LieRingModule L M'\ne : LieModuleEquiv R L M M'\n⊢ Eq e.range Top.top","decl":"@[simp] lemma LieModuleEquiv.range_coe {M' : Type*}\n    [AddCommGroup M'] [Module R M'] [LieRingModule L M'] (e : M ≃ₗ⁅R,L⁆ M') :\n    LieModuleHom.range (e : M →ₗ⁅R,L⁆ M') = ⊤ := by\n  rw [LieModuleHom.range_eq_top]\n  exact e.surjective\n\n"}
{"name":"LieSubalgebra.topEquiv_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (LieSubalgebra.topEquiv x) ↑x","decl":"@[simp]\ntheorem LieSubalgebra.topEquiv_apply (x : (⊤ : LieSubalgebra R L)) : LieSubalgebra.topEquiv x = x :=\n  rfl\n\n"}
{"name":"LieIdeal.topEquiv_apply","module":"Mathlib.Algebra.Lie.Submodule","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (LieIdeal.topEquiv x) ↑x","decl":"@[simp, nolint simpNF]\ntheorem LieIdeal.topEquiv_apply (x : (⊤ : LieIdeal R L)) : LieIdeal.topEquiv x = x :=\n  rfl\n\n"}
