{"name":"Algebra.norm_apply","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nx : S\n⊢ Eq ((Algebra.norm R) x) (LinearMap.det ((Algebra.lmul R S) x))","decl":"theorem norm_apply (x : S) : norm R x = LinearMap.det (lmul R S x) := rfl\n\n"}
{"name":"Algebra.norm_eq_one_of_not_exists_basis","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nh : Not (Exists fun s => Nonempty (Basis (Subtype fun x => Membership.mem s x) R S))\nx : S\n⊢ Eq ((Algebra.norm R) x) 1","decl":"theorem norm_eq_one_of_not_exists_basis (h : ¬∃ s : Finset S, Nonempty (Basis s R S)) (x : S) :\n    norm R x = 1 := by rw [norm_apply, LinearMap.det]; split_ifs <;> trivial\n\n"}
{"name":"Algebra.norm_eq_one_of_not_module_finite","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nh : Not (Module.Finite R S)\nx : S\n⊢ Eq ((Algebra.norm R) x) 1","decl":"theorem norm_eq_one_of_not_module_finite (h : ¬Module.Finite R S) (x : S) : norm R x = 1 := by\n  refine norm_eq_one_of_not_exists_basis _ (mt ?_ h) _\n  rintro ⟨s, ⟨b⟩⟩\n  exact Module.Finite.of_basis b\n\n-- Can't be a `simp` lemma because it depends on a choice of basis\n"}
{"name":"Algebra.norm_eq_matrix_det","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nι : Type w\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R S\ns : S\n⊢ Eq ((Algebra.norm R) s) ((Algebra.leftMulMatrix b) s).det","decl":"theorem norm_eq_matrix_det [Fintype ι] [DecidableEq ι] (b : Basis ι R S) (s : S) :\n    norm R s = Matrix.det (Algebra.leftMulMatrix b s) := by\n  rw [norm_apply, ← LinearMap.det_toMatrix b, ← toMatrix_lmul_eq]; rfl\n\n"}
{"name":"Algebra.norm_algebraMap_of_basis","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nι : Type w\ninst✝ : Fintype ι\nb : Basis ι R S\nx : R\n⊢ Eq ((Algebra.norm R) ((algebraMap R S) x)) (HPow.hPow x (Fintype.card ι))","decl":"/-- If `x` is in the base ring `K`, then the norm is `x ^ [L : K]`. -/\ntheorem norm_algebraMap_of_basis [Fintype ι] (b : Basis ι R S) (x : R) :\n    norm R (algebraMap R S x) = x ^ Fintype.card ι := by\n  haveI := Classical.decEq ι\n  rw [norm_apply, ← det_toMatrix b, lmul_algebraMap]\n  convert @det_diagonal _ _ _ _ _ fun _ : ι => x\n  · ext (i j); rw [toMatrix_lsmul]\n  · rw [Finset.prod_const, Finset.card_univ]\n\n"}
{"name":"Algebra.norm_algebraMap","module":"Mathlib.RingTheory.Norm.Defs","initialProofState":"K : Type u_3\ninst✝² : Field K\nL : Type u_4\ninst✝¹ : Ring L\ninst✝ : Algebra K L\nx : K\n⊢ Eq ((Algebra.norm K) ((algebraMap K L) x)) (HPow.hPow x (Module.finrank K L))","decl":"/-- If `x` is in the base field `K`, then the norm is `x ^ [L : K]`.\n\n(If `L` is not finite-dimensional over `K`, then `norm = 1 = x ^ 0 = x ^ (finrank L K)`.)\n-/\n@[simp]\nprotected theorem norm_algebraMap {L : Type*} [Ring L] [Algebra K L] (x : K) :\n    norm K (algebraMap K L x) = x ^ finrank K L := by\n  by_cases H : ∃ s : Finset L, Nonempty (Basis s K L)\n  · rw [norm_algebraMap_of_basis H.choose_spec.some, finrank_eq_card_basis H.choose_spec.some]\n  · rw [norm_eq_one_of_not_exists_basis K H, finrank_eq_zero_of_not_exists_basis, pow_zero]\n    rintro ⟨s, ⟨b⟩⟩\n    exact H ⟨s, ⟨b⟩⟩\n\n"}
