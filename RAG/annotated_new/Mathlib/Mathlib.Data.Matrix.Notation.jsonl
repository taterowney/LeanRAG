{"name":"Matrix.cons_val'","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\nv : n' → α\nB : Fin m → n' → α\ni : Fin m.succ\nj : n'\n⊢ Eq (Matrix.vecCons v B i j) (Matrix.vecCons (v j) (fun i => B i j) i)","decl":"@[simp]\ntheorem cons_val' (v : n' → α) (B : Fin m → n' → α) (i j) :\n    vecCons v B i j = vecCons (v j) (fun i => B i j) i := by refine Fin.cases ?_ ?_ i <;> simp\n\n"}
{"name":"Matrix.head_val'","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\nB : Fin m.succ → n' → α\nj : n'\n⊢ Eq (Matrix.vecHead fun i => B i j) (Matrix.vecHead B j)","decl":"@[simp]\ntheorem head_val' (B : Fin m.succ → n' → α) (j : n') : (vecHead fun i => B i j) = vecHead B j :=\n  rfl\n\n"}
{"name":"Matrix.tail_val'","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\nB : Fin m.succ → n' → α\nj : n'\n⊢ Eq (Matrix.vecTail fun i => B i j) fun i => Matrix.vecTail B i j","decl":"@[simp]\ntheorem tail_val' (B : Fin m.succ → n' → α) (j : n') :\n    (vecTail fun i => B i j) = fun i => vecTail B i j := rfl\n\n"}
{"name":"Matrix.dotProduct_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv w : Fin 0 → α\n⊢ Eq (dotProduct v w) 0","decl":"@[simp]\ntheorem dotProduct_empty (v w : Fin 0 → α) : dotProduct v w = 0 :=\n  Finset.sum_empty\n\n"}
{"name":"Matrix.cons_dotProduct","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nx : α\nv : Fin n → α\nw : Fin n.succ → α\n⊢ Eq (dotProduct (Matrix.vecCons x v) w) (HAdd.hAdd (HMul.hMul x (Matrix.vecHead w)) (dotProduct v (Matrix.vecTail w)))","decl":"@[simp]\ntheorem cons_dotProduct (x : α) (v : Fin n → α) (w : Fin n.succ → α) :\n    dotProduct (vecCons x v) w = x * vecHead w + dotProduct v (vecTail w) := by\n  simp [dotProduct, Fin.sum_univ_succ, vecHead, vecTail]\n\n"}
{"name":"Matrix.dotProduct_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv : Fin n.succ → α\nx : α\nw : Fin n → α\n⊢ Eq (dotProduct v (Matrix.vecCons x w)) (HAdd.hAdd (HMul.hMul (Matrix.vecHead v) x) (dotProduct (Matrix.vecTail v) w))","decl":"@[simp]\ntheorem dotProduct_cons (v : Fin n.succ → α) (x : α) (w : Fin n → α) :\n    dotProduct v (vecCons x w) = vecHead v * x + dotProduct (vecTail v) w := by\n  simp [dotProduct, Fin.sum_univ_succ, vecHead, vecTail]\n\n"}
{"name":"Matrix.cons_dotProduct_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nx : α\nv : Fin n → α\ny : α\nw : Fin n → α\n⊢ Eq (dotProduct (Matrix.vecCons x v) (Matrix.vecCons y w)) (HAdd.hAdd (HMul.hMul x y) (dotProduct v w))","decl":"theorem cons_dotProduct_cons (x : α) (v : Fin n → α) (y : α) (w : Fin n → α) :\n    dotProduct (vecCons x v) (vecCons y w) = x * y + dotProduct v w := by simp\n\n"}
{"name":"Matrix.col_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nι : Type u_1\nv : Fin 0 → α\n⊢ Eq (Matrix.col ι v) Matrix.vecEmpty","decl":"@[simp]\ntheorem col_empty (v : Fin 0 → α) : col ι v = vecEmpty :=\n  empty_eq _\n\n"}
{"name":"Matrix.col_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nι : Type u_1\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.col ι (Matrix.vecCons x u)) (Matrix.of (Matrix.vecCons (fun x_1 => x) (Matrix.col ι u)))","decl":"@[simp]\ntheorem col_cons (x : α) (u : Fin m → α) :\n    col ι (vecCons x u) = of (vecCons (fun _ => x) (col ι u)) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i <;> simp [vecHead, vecTail]\n\n"}
{"name":"Matrix.row_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nι : Type u_1\n⊢ Eq (Matrix.row ι Matrix.vecEmpty) (Matrix.of fun x => Matrix.vecEmpty)","decl":"@[simp]\ntheorem row_empty : row ι (vecEmpty : Fin 0 → α) = of fun _ => vecEmpty := rfl\n\n"}
{"name":"Matrix.row_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nι : Type u_1\nx : α\nu : Fin m → α\n⊢ Eq (Matrix.row ι (Matrix.vecCons x u)) (Matrix.of fun x_1 => Matrix.vecCons x u)","decl":"@[simp]\ntheorem row_cons (x : α) (u : Fin m → α) : row ι (vecCons x u) = of fun _ => vecCons x u :=\n  rfl\n\n"}
{"name":"Matrix.transpose_empty_rows","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\nA : Matrix m' (Fin 0) α\n⊢ Eq A.transpose (Matrix.of Matrix.vecEmpty)","decl":"@[simp]\ntheorem transpose_empty_rows (A : Matrix m' (Fin 0) α) : Aᵀ = of ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.transpose_empty_cols","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\nA : Matrix (Fin 0) m' α\n⊢ Eq A.transpose (Matrix.of fun x => Matrix.vecEmpty)","decl":"@[simp]\ntheorem transpose_empty_cols (A : Matrix (Fin 0) m' α) : Aᵀ = of fun _ => ![] :=\n  funext fun _ => empty_eq _\n\n"}
{"name":"Matrix.cons_transpose","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\nv : n' → α\nA : Matrix (Fin m) n' α\n⊢ Eq (Matrix.of (Matrix.vecCons v A)).transpose (Matrix.of fun i => Matrix.vecCons (v i) (A.transpose i))","decl":"@[simp]\ntheorem cons_transpose (v : n' → α) (A : Matrix (Fin m) n' α) :\n    (of (vecCons v A))ᵀ = of fun i => vecCons (v i) (Aᵀ i) := by\n  ext i j\n  refine Fin.cases ?_ ?_ j <;> simp\n\n"}
{"name":"Matrix.head_transpose","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\nm' : Type uₘ\nA : Matrix m' (Fin n.succ) α\n⊢ Eq (Matrix.vecHead (Matrix.of.symm A.transpose)) (Function.comp Matrix.vecHead (Matrix.of.symm A))","decl":"@[simp]\ntheorem head_transpose (A : Matrix m' (Fin n.succ) α) :\n    vecHead (of.symm Aᵀ) = vecHead ∘ of.symm A :=\n  rfl\n\n"}
{"name":"Matrix.tail_transpose","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\nm' : Type uₘ\nA : Matrix m' (Fin n.succ) α\n⊢ Eq (Matrix.vecTail (Matrix.of.symm A.transpose)) (Matrix.transpose (Function.comp Matrix.vecTail A))","decl":"@[simp]\ntheorem tail_transpose (A : Matrix m' (Fin n.succ) α) : vecTail (of.symm Aᵀ) = (vecTail ∘ A)ᵀ := by\n  ext i j\n  rfl\n\n"}
{"name":"Matrix.empty_mul","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn' : Type uₙ\no' : Type uₒ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nA : Matrix (Fin 0) n' α\nB : Matrix n' o' α\n⊢ Eq (HMul.hMul A B) (Matrix.of Matrix.vecEmpty)","decl":"@[simp]\ntheorem empty_mul [Fintype n'] (A : Matrix (Fin 0) n' α) (B : Matrix n' o' α) : A * B = of ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.empty_mul_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\no' : Type uₒ\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix m' (Fin 0) α\nB : Matrix (Fin 0) o' α\n⊢ Eq (HMul.hMul A B) 0","decl":"@[simp]\ntheorem empty_mul_empty (A : Matrix m' (Fin 0) α) (B : Matrix (Fin 0) o' α) : A * B = 0 :=\n  rfl\n\n"}
{"name":"Matrix.mul_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\nn' : Type uₙ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nA : Matrix m' n' α\nB : Matrix n' (Fin 0) α\n⊢ Eq (HMul.hMul A B) (Matrix.of fun x => Matrix.vecEmpty)","decl":"@[simp]\ntheorem mul_empty [Fintype n'] (A : Matrix m' n' α) (B : Matrix n' (Fin 0) α) :\n    A * B = of fun _ => ![] :=\n  funext fun _ => empty_eq _\n\n"}
{"name":"Matrix.mul_val_succ","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\no' : Type uₒ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nA : Matrix (Fin m.succ) n' α\nB : Matrix n' o' α\ni : Fin m\nj : o'\n⊢ Eq (HMul.hMul A B i.succ j) (HMul.hMul (Matrix.of (Matrix.vecTail (Matrix.of.symm A))) B i j)","decl":"theorem mul_val_succ [Fintype n'] (A : Matrix (Fin m.succ) n' α) (B : Matrix n' o' α) (i : Fin m)\n    (j : o') : (A * B) i.succ j = (of (vecTail (of.symm A)) * B) i j :=\n  rfl\n\n"}
{"name":"Matrix.cons_mul","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\no' : Type uₒ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nv : n' → α\nA : Fin m → n' → α\nB : Matrix n' o' α\n⊢ Eq (HMul.hMul (Matrix.of (Matrix.vecCons v A)) B) (Matrix.of (Matrix.vecCons (Matrix.vecMul v B) (Matrix.of.symm (HMul.hMul (Matrix.of A) B))))","decl":"@[simp]\ntheorem cons_mul [Fintype n'] (v : n' → α) (A : Fin m → n' → α) (B : Matrix n' o' α) :\n    of (vecCons v A) * B = of (vecCons (v ᵥ* B) (of.symm (of A * B))) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i\n  · rfl\n  simp [mul_val_succ]\n\n"}
{"name":"Matrix.empty_vecMul","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\no' : Type uₒ\ninst✝ : NonUnitalNonAssocSemiring α\nv : Fin 0 → α\nB : Matrix (Fin 0) o' α\n⊢ Eq (Matrix.vecMul v B) 0","decl":"@[simp]\ntheorem empty_vecMul (v : Fin 0 → α) (B : Matrix (Fin 0) o' α) : v ᵥ* B = 0 :=\n  rfl\n\n"}
{"name":"Matrix.vecMul_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn' : Type uₙ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nv : n' → α\nB : Matrix n' (Fin 0) α\n⊢ Eq (Matrix.vecMul v B) Matrix.vecEmpty","decl":"@[simp]\ntheorem vecMul_empty [Fintype n'] (v : n' → α) (B : Matrix n' (Fin 0) α) : v ᵥ* B = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.cons_vecMul","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\no' : Type uₒ\ninst✝ : NonUnitalNonAssocSemiring α\nx : α\nv : Fin n → α\nB : Fin n.succ → o' → α\n⊢ Eq (Matrix.vecMul (Matrix.vecCons x v) (Matrix.of B)) (HAdd.hAdd (HSMul.hSMul x (Matrix.vecHead B)) (Matrix.vecMul v (Matrix.of (Matrix.vecTail B))))","decl":"@[simp]\ntheorem cons_vecMul (x : α) (v : Fin n → α) (B : Fin n.succ → o' → α) :\n    vecCons x v ᵥ* of B = x • vecHead B + v ᵥ* of (vecTail B) := by\n  ext i\n  simp [vecMul]\n\n"}
{"name":"Matrix.vecMul_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\no' : Type uₒ\ninst✝ : NonUnitalNonAssocSemiring α\nv : Fin n.succ → α\nw : o' → α\nB : Fin n → o' → α\n⊢ Eq (Matrix.vecMul v (Matrix.of (Matrix.vecCons w B))) (HAdd.hAdd (HSMul.hSMul (Matrix.vecHead v) w) (Matrix.vecMul (Matrix.vecTail v) (Matrix.of B)))","decl":"@[simp]\ntheorem vecMul_cons (v : Fin n.succ → α) (w : o' → α) (B : Fin n → o' → α) :\n    v ᵥ* of (vecCons w B) = vecHead v • w + vecTail v ᵥ* of B := by\n  ext i\n  simp [vecMul]\n\n"}
{"name":"Matrix.cons_vecMul_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\no' : Type uₒ\ninst✝ : NonUnitalNonAssocSemiring α\nx : α\nv : Fin n → α\nw : o' → α\nB : Fin n → o' → α\n⊢ Eq (Matrix.vecMul (Matrix.vecCons x v) (Matrix.of (Matrix.vecCons w B))) (HAdd.hAdd (HSMul.hSMul x w) (Matrix.vecMul v (Matrix.of B)))","decl":"theorem cons_vecMul_cons (x : α) (v : Fin n → α) (w : o' → α) (B : Fin n → o' → α) :\n    vecCons x v ᵥ* of (vecCons w B) = x • w + v ᵥ* of B := by simp\n\n"}
{"name":"Matrix.empty_mulVec","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn' : Type uₙ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nA : Matrix (Fin 0) n' α\nv : n' → α\n⊢ Eq (A.mulVec v) Matrix.vecEmpty","decl":"@[simp]\ntheorem empty_mulVec [Fintype n'] (A : Matrix (Fin 0) n' α) (v : n' → α) : A *ᵥ v = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.mulVec_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\ninst✝ : NonUnitalNonAssocSemiring α\nA : Matrix m' (Fin 0) α\nv : Fin 0 → α\n⊢ Eq (A.mulVec v) 0","decl":"@[simp]\ntheorem mulVec_empty (A : Matrix m' (Fin 0) α) (v : Fin 0 → α) : A *ᵥ v = 0 :=\n  rfl\n\n"}
{"name":"Matrix.cons_mulVec","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : Fintype n'\nv : n' → α\nA : Fin m → n' → α\nw : n' → α\n⊢ Eq ((Matrix.of (Matrix.vecCons v A)).mulVec w) (Matrix.vecCons (dotProduct v w) ((Matrix.of A).mulVec w))","decl":"@[simp]\ntheorem cons_mulVec [Fintype n'] (v : n' → α) (A : Fin m → n' → α) (w : n' → α) :\n    (of <| vecCons v A) *ᵥ w = vecCons (dotProduct v w) (of A *ᵥ w) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp [mulVec]\n\n"}
{"name":"Matrix.mulVec_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"n : Nat\nm' : Type uₘ\nα : Type u_1\ninst✝ : CommSemiring α\nA : m' → Fin n.succ → α\nx : α\nv : Fin n → α\n⊢ Eq ((Matrix.of A).mulVec (Matrix.vecCons x v)) (HAdd.hAdd (HSMul.hSMul x (Function.comp Matrix.vecHead A)) ((Matrix.of (Function.comp Matrix.vecTail A)).mulVec v))","decl":"@[simp]\ntheorem mulVec_cons {α} [CommSemiring α] (A : m' → Fin n.succ → α) (x : α) (v : Fin n → α) :\n    (of A) *ᵥ (vecCons x v) = x • vecHead ∘ A + (of (vecTail ∘ A)) *ᵥ v := by\n  ext i\n  simp [mulVec, mul_comm]\n\n"}
{"name":"Matrix.empty_vecMulVec","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn' : Type uₙ\ninst✝ : NonUnitalNonAssocSemiring α\nv : Fin 0 → α\nw : n' → α\n⊢ Eq (Matrix.vecMulVec v w) Matrix.vecEmpty","decl":"@[simp]\ntheorem empty_vecMulVec (v : Fin 0 → α) (w : n' → α) : vecMulVec v w = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.vecMulVec_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\ninst✝ : NonUnitalNonAssocSemiring α\nv : m' → α\nw : Fin 0 → α\n⊢ Eq (Matrix.vecMulVec v w) (Matrix.of fun x => Matrix.vecEmpty)","decl":"@[simp]\ntheorem vecMulVec_empty (v : m' → α) (w : Fin 0 → α) : vecMulVec v w = of fun _ => ![] :=\n  funext fun _ => empty_eq _\n\n"}
{"name":"Matrix.cons_vecMulVec","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\ninst✝ : NonUnitalNonAssocSemiring α\nx : α\nv : Fin m → α\nw : n' → α\n⊢ Eq (Matrix.vecMulVec (Matrix.vecCons x v) w) (Matrix.vecCons (HSMul.hSMul x w) (Matrix.vecMulVec v w))","decl":"@[simp]\ntheorem cons_vecMulVec (x : α) (v : Fin m → α) (w : n' → α) :\n    vecMulVec (vecCons x v) w = vecCons (x • w) (vecMulVec v w) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp [vecMulVec]\n\n"}
{"name":"Matrix.vecMulVec_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\nm' : Type uₘ\ninst✝ : NonUnitalNonAssocSemiring α\nv : m' → α\nx : α\nw : Fin n → α\n⊢ Eq (Matrix.vecMulVec v (Matrix.vecCons x w)) (Matrix.of fun i => HSMul.hSMul (v i) (Matrix.vecCons x w))","decl":"@[simp]\ntheorem vecMulVec_cons (v : m' → α) (x : α) (w : Fin n → α) :\n    vecMulVec v (vecCons x w) = of fun i => v i • vecCons x w := rfl\n\n"}
{"name":"Matrix.smul_mat_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝ : NonUnitalNonAssocSemiring α\nm' : Type u_1\nx : α\nA : Fin 0 → m' → α\n⊢ Eq (HSMul.hSMul x A) Matrix.vecEmpty","decl":"theorem smul_mat_empty {m' : Type*} (x : α) (A : Fin 0 → m' → α) : x • A = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.smul_mat_cons","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\ninst✝ : NonUnitalNonAssocSemiring α\nx : α\nv : n' → α\nA : Fin m → n' → α\n⊢ Eq (HSMul.hSMul x (Matrix.vecCons v A)) (Matrix.vecCons (HSMul.hSMul x v) (HSMul.hSMul x A))","decl":"theorem smul_mat_cons (x : α) (v : n' → α) (A : Fin m → n' → α) :\n    x • vecCons v A = vecCons (x • v) (x • A) := by\n  ext i\n  refine Fin.cases ?_ ?_ i <;> simp\n\n"}
{"name":"Matrix.submatrix_empty","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm' : Type uₘ\nn' : Type uₙ\no' : Type uₒ\nA : Matrix m' n' α\nrow : Fin 0 → m'\ncol : o' → n'\n⊢ Eq (A.submatrix row col) Matrix.vecEmpty","decl":"@[simp]\ntheorem submatrix_empty (A : Matrix m' n' α) (row : Fin 0 → m') (col : o' → n') :\n    submatrix A row col = ![] :=\n  empty_eq _\n\n"}
{"name":"Matrix.submatrix_cons_row","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nm' : Type uₘ\nn' : Type uₙ\no' : Type uₒ\nA : Matrix m' n' α\ni : m'\nrow : Fin m → m'\ncol : o' → n'\n⊢ Eq (A.submatrix (Matrix.vecCons i row) col) (Matrix.vecCons (fun j => A i (col j)) (A.submatrix row col))","decl":"@[simp]\ntheorem submatrix_cons_row (A : Matrix m' n' α) (i : m') (row : Fin m → m') (col : o' → n') :\n    submatrix A (vecCons i row) col = vecCons (fun j => A i (col j)) (submatrix A row col) := by\n  ext i j\n  refine Fin.cases ?_ ?_ i <;> simp [submatrix]\n\n"}
{"name":"Matrix.submatrix_updateRow_succAbove","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nm : Nat\nn' : Type uₙ\no' : Type uₒ\nA : Matrix (Fin m.succ) n' α\nv : n' → α\nf : o' → n'\ni : Fin m.succ\n⊢ Eq ((A.updateRow i v).submatrix i.succAbove f) (A.submatrix i.succAbove f)","decl":"/-- Updating a row then removing it is the same as removing it. -/\n@[simp]\ntheorem submatrix_updateRow_succAbove (A : Matrix (Fin m.succ) n' α) (v : n' → α) (f : o' → n')\n    (i : Fin m.succ) : (A.updateRow i v).submatrix i.succAbove f = A.submatrix i.succAbove f :=\n  ext fun r s => (congr_fun (updateRow_ne (Fin.succAbove_ne i r) : _ = A _) (f s) :)\n\n"}
{"name":"Matrix.submatrix_updateCol_succAbove","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\nm' : Type uₘ\no' : Type uₒ\nA : Matrix m' (Fin n.succ) α\nv : m' → α\nf : o' → m'\ni : Fin n.succ\n⊢ Eq ((A.updateCol i v).submatrix f i.succAbove) (A.submatrix f i.succAbove)","decl":"/-- Updating a column then removing it is the same as removing it. -/\n@[simp]\ntheorem submatrix_updateCol_succAbove (A : Matrix m' (Fin n.succ) α) (v : m' → α) (f : o' → m')\n    (i : Fin n.succ) : (A.updateCol i v).submatrix f i.succAbove = A.submatrix f i.succAbove :=\n  ext fun _r s => updateCol_ne (Fin.succAbove_ne i s)\n\n"}
{"name":"Matrix.submatrix_updateColumn_succAbove","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nn : Nat\nm' : Type uₘ\no' : Type uₒ\nA : Matrix m' (Fin n.succ) α\nv : m' → α\nf : o' → m'\ni : Fin n.succ\n⊢ Eq ((A.updateCol i v).submatrix f i.succAbove) (A.submatrix f i.succAbove)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias submatrix_updateColumn_succAbove := submatrix_updateCol_succAbove\n\n"}
{"name":"Matrix.one_fin_two","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq 1 (Matrix.of (Matrix.vecCons (Matrix.vecCons 1 (Matrix.vecCons 0 Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons 1 Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem one_fin_two : (1 : Matrix (Fin 2) (Fin 2) α) = !![1, 0; 0, 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.one_fin_three","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Eq 1 (Matrix.of (Matrix.vecCons (Matrix.vecCons 1 (Matrix.vecCons 0 (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons 1 (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons 0 (Matrix.vecCons 1 Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem one_fin_three : (1 : Matrix (Fin 3) (Fin 3) α) = !![1, 0, 0; 0, 1, 0; 0, 0, 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.natCast_fin_two","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Eq (↑n) (Matrix.of (Matrix.vecCons (Matrix.vecCons (↑n) (Matrix.vecCons 0 Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons (↑n) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem natCast_fin_two (n : ℕ) : (n : Matrix (Fin 2) (Fin 2) α) = !![↑n, 0; 0, ↑n] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.natCast_fin_three","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝ : AddMonoidWithOne α\nn : Nat\n⊢ Eq (↑n) (Matrix.of (Matrix.vecCons (Matrix.vecCons (↑n) (Matrix.vecCons 0 (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons (↑n) (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons 0 (Matrix.vecCons (↑n) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem natCast_fin_three (n : ℕ) :\n    (n : Matrix (Fin 3) (Fin 3) α) = !![↑n, 0, 0; 0, ↑n, 0; 0, 0, ↑n] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.ofNat_fin_two","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n) (Matrix.of (Matrix.vecCons (Matrix.vecCons (OfNat.ofNat n) (Matrix.vecCons 0 Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons (OfNat.ofNat n) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem ofNat_fin_two (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : Matrix (Fin 2) (Fin 2) α) =\n      !![ofNat(n), 0; 0, ofNat(n)] :=\n  natCast_fin_two _\n\n"}
{"name":"Matrix.ofNat_fin_three","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddMonoidWithOne α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n) (Matrix.of (Matrix.vecCons (Matrix.vecCons (OfNat.ofNat n) (Matrix.vecCons 0 (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons (OfNat.ofNat n) (Matrix.vecCons 0 Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons 0 (Matrix.vecCons 0 (Matrix.vecCons (OfNat.ofNat n) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem ofNat_fin_three (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : Matrix (Fin 3) (Fin 3) α) =\n      !![ofNat(n), 0, 0; 0, ofNat(n), 0; 0, 0, ofNat(n)] :=\n  natCast_fin_three _\n\n"}
{"name":"Matrix.eta_fin_two","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nA : Matrix (Fin 2) (Fin 2) α\n⊢ Eq A (Matrix.of (Matrix.vecCons (Matrix.vecCons (A 0 0) (Matrix.vecCons (A 0 1) Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons (A 1 0) (Matrix.vecCons (A 1 1) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem eta_fin_two (A : Matrix (Fin 2) (Fin 2) α) : A = !![A 0 0, A 0 1; A 1 0, A 1 1] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.eta_fin_three","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nA : Matrix (Fin 3) (Fin 3) α\n⊢ Eq A (Matrix.of (Matrix.vecCons (Matrix.vecCons (A 0 0) (Matrix.vecCons (A 0 1) (Matrix.vecCons (A 0 2) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (A 1 0) (Matrix.vecCons (A 1 1) (Matrix.vecCons (A 1 2) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (A 2 0) (Matrix.vecCons (A 2 1) (Matrix.vecCons (A 2 2) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem eta_fin_three (A : Matrix (Fin 3) (Fin 3) α) :\n    A = !![A 0 0, A 0 1, A 0 2;\n           A 1 0, A 1 1, A 1 2;\n           A 2 0, A 2 1, A 2 2] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> rfl\n\n"}
{"name":"Matrix.mul_fin_two","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\na₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α\n⊢ Eq (HMul.hMul (Matrix.of (Matrix.vecCons (Matrix.vecCons a₁₁ (Matrix.vecCons a₁₂ Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons a₂₁ (Matrix.vecCons a₂₂ Matrix.vecEmpty)) Matrix.vecEmpty))) (Matrix.of (Matrix.vecCons (Matrix.vecCons b₁₁ (Matrix.vecCons b₁₂ Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons b₂₁ (Matrix.vecCons b₂₂ Matrix.vecEmpty)) Matrix.vecEmpty)))) (Matrix.of (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (HMul.hMul a₁₁ b₁₁) (HMul.hMul a₁₂ b₂₁)) (Matrix.vecCons (HAdd.hAdd (HMul.hMul a₁₁ b₁₂) (HMul.hMul a₁₂ b₂₂)) Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (HMul.hMul a₂₁ b₁₁) (HMul.hMul a₂₂ b₂₁)) (Matrix.vecCons (HAdd.hAdd (HMul.hMul a₂₁ b₁₂) (HMul.hMul a₂₂ b₂₂)) Matrix.vecEmpty)) Matrix.vecEmpty)))","decl":"theorem mul_fin_two [AddCommMonoid α] [Mul α] (a₁₁ a₁₂ a₂₁ a₂₂ b₁₁ b₁₂ b₂₁ b₂₂ : α) :\n    !![a₁₁, a₁₂;\n       a₂₁, a₂₂] * !![b₁₁, b₁₂;\n                      b₂₁, b₂₂] = !![a₁₁ * b₁₁ + a₁₂ * b₂₁, a₁₁ * b₁₂ + a₁₂ * b₂₂;\n                                     a₂₁ * b₁₁ + a₂₂ * b₂₁, a₂₁ * b₁₂ + a₂₂ * b₂₂] := by\n  ext i j\n  fin_cases i <;> fin_cases j <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ]\n\n"}
{"name":"Matrix.mul_fin_three","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\na₁₁ a₁₂ a₁₃ a₂₁ a₂₂ a₂₃ a₃₁ a₃₂ a₃₃ b₁₁ b₁₂ b₁₃ b₂₁ b₂₂ b₂₃ b₃₁ b₃₂ b₃₃ : α\n⊢ Eq (HMul.hMul (Matrix.of (Matrix.vecCons (Matrix.vecCons a₁₁ (Matrix.vecCons a₁₂ (Matrix.vecCons a₁₃ Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons a₂₁ (Matrix.vecCons a₂₂ (Matrix.vecCons a₂₃ Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons a₃₁ (Matrix.vecCons a₃₂ (Matrix.vecCons a₃₃ Matrix.vecEmpty))) Matrix.vecEmpty)))) (Matrix.of (Matrix.vecCons (Matrix.vecCons b₁₁ (Matrix.vecCons b₁₂ (Matrix.vecCons b₁₃ Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons b₂₁ (Matrix.vecCons b₂₂ (Matrix.vecCons b₂₃ Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons b₃₁ (Matrix.vecCons b₃₂ (Matrix.vecCons b₃₃ Matrix.vecEmpty))) Matrix.vecEmpty))))) (Matrix.of (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁₁ b₁₁) (HMul.hMul a₁₂ b₂₁)) (HMul.hMul a₁₃ b₃₁)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁₁ b₁₂) (HMul.hMul a₁₂ b₂₂)) (HMul.hMul a₁₃ b₃₂)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₁₁ b₁₃) (HMul.hMul a₁₂ b₂₃)) (HMul.hMul a₁₃ b₃₃)) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₂₁ b₁₁) (HMul.hMul a₂₂ b₂₁)) (HMul.hMul a₂₃ b₃₁)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₂₁ b₁₂) (HMul.hMul a₂₂ b₂₂)) (HMul.hMul a₂₃ b₃₂)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₂₁ b₁₃) (HMul.hMul a₂₂ b₂₃)) (HMul.hMul a₂₃ b₃₃)) Matrix.vecEmpty))) (Matrix.vecCons (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₃₁ b₁₁) (HMul.hMul a₃₂ b₂₁)) (HMul.hMul a₃₃ b₃₁)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₃₁ b₁₂) (HMul.hMul a₃₂ b₂₂)) (HMul.hMul a₃₃ b₃₂)) (Matrix.vecCons (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₃₁ b₁₃) (HMul.hMul a₃₂ b₂₃)) (HMul.hMul a₃₃ b₃₃)) Matrix.vecEmpty))) Matrix.vecEmpty))))","decl":"theorem mul_fin_three [AddCommMonoid α] [Mul α]\n    (a₁₁ a₁₂ a₁₃ a₂₁ a₂₂ a₂₃ a₃₁ a₃₂ a₃₃ b₁₁ b₁₂ b₁₃ b₂₁ b₂₂ b₂₃ b₃₁ b₃₂ b₃₃ : α) :\n    !![a₁₁, a₁₂, a₁₃;\n       a₂₁, a₂₂, a₂₃;\n       a₃₁, a₃₂, a₃₃] * !![b₁₁, b₁₂, b₁₃;\n                           b₂₁, b₂₂, b₂₃;\n                           b₃₁, b₃₂, b₃₃] =\n    !![a₁₁*b₁₁ + a₁₂*b₂₁ + a₁₃*b₃₁, a₁₁*b₁₂ + a₁₂*b₂₂ + a₁₃*b₃₂, a₁₁*b₁₃ + a₁₂*b₂₃ + a₁₃*b₃₃;\n       a₂₁*b₁₁ + a₂₂*b₂₁ + a₂₃*b₃₁, a₂₁*b₁₂ + a₂₂*b₂₂ + a₂₃*b₃₂, a₂₁*b₁₃ + a₂₂*b₂₃ + a₂₃*b₃₃;\n       a₃₁*b₁₁ + a₃₂*b₂₁ + a₃₃*b₃₁, a₃₁*b₁₂ + a₃₂*b₂₂ + a₃₃*b₃₂, a₃₁*b₁₃ + a₃₂*b₂₃ + a₃₃*b₃₃] := by\n  ext i j\n  fin_cases i <;> fin_cases j\n    <;> simp [Matrix.mul_apply, dotProduct, Fin.sum_univ_succ, ← add_assoc]\n\n"}
{"name":"Matrix.vec2_eq","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\na₀ a₁ b₀ b₁ : α\nh₀ : Eq a₀ b₀\nh₁ : Eq a₁ b₁\n⊢ Eq (Matrix.vecCons a₀ (Matrix.vecCons a₁ Matrix.vecEmpty)) (Matrix.vecCons b₀ (Matrix.vecCons b₁ Matrix.vecEmpty))","decl":"theorem vec2_eq {a₀ a₁ b₀ b₁ : α} (h₀ : a₀ = b₀) (h₁ : a₁ = b₁) : ![a₀, a₁] = ![b₀, b₁] := by\n  subst_vars\n  rfl\n\n"}
{"name":"Matrix.vec3_eq","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\na₀ a₁ a₂ b₀ b₁ b₂ : α\nh₀ : Eq a₀ b₀\nh₁ : Eq a₁ b₁\nh₂ : Eq a₂ b₂\n⊢ Eq (Matrix.vecCons a₀ (Matrix.vecCons a₁ (Matrix.vecCons a₂ Matrix.vecEmpty))) (Matrix.vecCons b₀ (Matrix.vecCons b₁ (Matrix.vecCons b₂ Matrix.vecEmpty)))","decl":"theorem vec3_eq {a₀ a₁ a₂ b₀ b₁ b₂ : α} (h₀ : a₀ = b₀) (h₁ : a₁ = b₁) (h₂ : a₂ = b₂) :\n    ![a₀, a₁, a₂] = ![b₀, b₁, b₂] := by\n  subst_vars\n  rfl\n\n"}
{"name":"Matrix.vec2_add","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝ : Add α\na₀ a₁ b₀ b₁ : α\n⊢ Eq (HAdd.hAdd (Matrix.vecCons a₀ (Matrix.vecCons a₁ Matrix.vecEmpty)) (Matrix.vecCons b₀ (Matrix.vecCons b₁ Matrix.vecEmpty))) (Matrix.vecCons (HAdd.hAdd a₀ b₀) (Matrix.vecCons (HAdd.hAdd a₁ b₁) Matrix.vecEmpty))","decl":"theorem vec2_add [Add α] (a₀ a₁ b₀ b₁ : α) : ![a₀, a₁] + ![b₀, b₁] = ![a₀ + b₀, a₁ + b₁] := by\n  rw [cons_add_cons, cons_add_cons, empty_add_empty]\n\n"}
{"name":"Matrix.vec3_add","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝ : Add α\na₀ a₁ a₂ b₀ b₁ b₂ : α\n⊢ Eq (HAdd.hAdd (Matrix.vecCons a₀ (Matrix.vecCons a₁ (Matrix.vecCons a₂ Matrix.vecEmpty))) (Matrix.vecCons b₀ (Matrix.vecCons b₁ (Matrix.vecCons b₂ Matrix.vecEmpty)))) (Matrix.vecCons (HAdd.hAdd a₀ b₀) (Matrix.vecCons (HAdd.hAdd a₁ b₁) (Matrix.vecCons (HAdd.hAdd a₂ b₂) Matrix.vecEmpty)))","decl":"theorem vec3_add [Add α] (a₀ a₁ a₂ b₀ b₁ b₂ : α) :\n    ![a₀, a₁, a₂] + ![b₀, b₁, b₂] = ![a₀ + b₀, a₁ + b₁, a₂ + b₂] := by\n  rw [cons_add_cons, cons_add_cons, cons_add_cons, empty_add_empty]\n\n"}
{"name":"Matrix.smul_vec2","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nR : Type u_1\ninst✝ : SMul R α\nx : R\na₀ a₁ : α\n⊢ Eq (HSMul.hSMul x (Matrix.vecCons a₀ (Matrix.vecCons a₁ Matrix.vecEmpty))) (Matrix.vecCons (HSMul.hSMul x a₀) (Matrix.vecCons (HSMul.hSMul x a₁) Matrix.vecEmpty))","decl":"theorem smul_vec2 {R : Type*} [SMul R α] (x : R) (a₀ a₁ : α) :\n    x • ![a₀, a₁] = ![x • a₀, x • a₁] := by rw [smul_cons, smul_cons, smul_empty]\n\n"}
{"name":"Matrix.smul_vec3","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\nR : Type u_1\ninst✝ : SMul R α\nx : R\na₀ a₁ a₂ : α\n⊢ Eq (HSMul.hSMul x (Matrix.vecCons a₀ (Matrix.vecCons a₁ (Matrix.vecCons a₂ Matrix.vecEmpty)))) (Matrix.vecCons (HSMul.hSMul x a₀) (Matrix.vecCons (HSMul.hSMul x a₁) (Matrix.vecCons (HSMul.hSMul x a₂) Matrix.vecEmpty)))","decl":"theorem smul_vec3 {R : Type*} [SMul R α] (x : R) (a₀ a₁ a₂ : α) :\n    x • ![a₀, a₁, a₂] = ![x • a₀, x • a₁, x • a₂] := by\n  rw [smul_cons, smul_cons, smul_cons, smul_empty]\n\n"}
{"name":"Matrix.vec2_dotProduct'","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\na₀ a₁ b₀ b₁ : α\n⊢ Eq (dotProduct (Matrix.vecCons a₀ (Matrix.vecCons a₁ Matrix.vecEmpty)) (Matrix.vecCons b₀ (Matrix.vecCons b₁ Matrix.vecEmpty))) (HAdd.hAdd (HMul.hMul a₀ b₀) (HMul.hMul a₁ b₁))","decl":"theorem vec2_dotProduct' {a₀ a₁ b₀ b₁ : α} : ![a₀, a₁] ⬝ᵥ ![b₀, b₁] = a₀ * b₀ + a₁ * b₁ := by\n  rw [cons_dotProduct_cons, cons_dotProduct_cons, dotProduct_empty, add_zero]\n\n"}
{"name":"Matrix.vec2_dotProduct","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv w : Fin 2 → α\n⊢ Eq (dotProduct v w) (HAdd.hAdd (HMul.hMul (v 0) (w 0)) (HMul.hMul (v 1) (w 1)))","decl":"@[simp]\ntheorem vec2_dotProduct (v w : Fin 2 → α) : v ⬝ᵥ w = v 0 * w 0 + v 1 * w 1 :=\n  vec2_dotProduct'\n\n"}
{"name":"Matrix.vec3_dotProduct'","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\na₀ a₁ a₂ b₀ b₁ b₂ : α\n⊢ Eq (dotProduct (Matrix.vecCons a₀ (Matrix.vecCons a₁ (Matrix.vecCons a₂ Matrix.vecEmpty))) (Matrix.vecCons b₀ (Matrix.vecCons b₁ (Matrix.vecCons b₂ Matrix.vecEmpty)))) (HAdd.hAdd (HAdd.hAdd (HMul.hMul a₀ b₀) (HMul.hMul a₁ b₁)) (HMul.hMul a₂ b₂))","decl":"theorem vec3_dotProduct' {a₀ a₁ a₂ b₀ b₁ b₂ : α} :\n    ![a₀, a₁, a₂] ⬝ᵥ ![b₀, b₁, b₂] = a₀ * b₀ + a₁ * b₁ + a₂ * b₂ := by\n  rw [cons_dotProduct_cons, cons_dotProduct_cons, cons_dotProduct_cons, dotProduct_empty,\n    add_zero, add_assoc]\n\n"}
{"name":"Matrix.vec3_dotProduct","module":"Mathlib.Data.Matrix.Notation","initialProofState":"α : Type u\ninst✝¹ : AddCommMonoid α\ninst✝ : Mul α\nv w : Fin 3 → α\n⊢ Eq (dotProduct v w) (HAdd.hAdd (HAdd.hAdd (HMul.hMul (v 0) (w 0)) (HMul.hMul (v 1) (w 1))) (HMul.hMul (v 2) (w 2)))","decl":"@[simp]\ntheorem vec3_dotProduct (v w : Fin 3 → α) : v ⬝ᵥ w = v 0 * w 0 + v 1 * w 1 + v 2 * w 2 :=\n  vec3_dotProduct'\n\n"}
