{"name":"QuotientGroup.sound","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nU : Set (HasQuotient.Quotient G N)\ng : Subtype fun x => Membership.mem N.op x\n⊢ Eq (HSMul.hSMul g (Set.preimage (⇑(QuotientGroup.mk' N)) U)) (Set.preimage (⇑(QuotientGroup.mk' N)) U)","decl":"open scoped Pointwise in\n@[to_additive]\ntheorem sound (U : Set (G ⧸ N)) (g : N.op) :\n    g • (mk' N) ⁻¹' U = (mk' N) ⁻¹' U := by\n  ext x\n  simp only [Set.mem_preimage, Set.mem_smul_set_iff_inv_smul_mem]\n  congr! 1\n  exact Quotient.sound ⟨g⁻¹, rfl⟩\n\n-- for commutative groups we don't need normality assumption\n\n"}
{"name":"QuotientAddGroup.sound","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nU : Set (HasQuotient.Quotient G N)\ng : Subtype fun x => Membership.mem N.op x\n⊢ Eq (HVAdd.hVAdd g (Set.preimage (⇑(QuotientAddGroup.mk' N)) U)) (Set.preimage (⇑(QuotientAddGroup.mk' N)) U)","decl":"open scoped Pointwise in\n@[to_additive]\ntheorem sound (U : Set (G ⧸ N)) (g : N.op) :\n    g • (mk' N) ⁻¹' U = (mk' N) ⁻¹' U := by\n  ext x\n  simp only [Set.mem_preimage, Set.mem_smul_set_iff_inv_smul_mem]\n  congr! 1\n  exact Quotient.sound ⟨g⁻¹, rfl⟩\n\n-- for commutative groups we don't need normality assumption\n\n"}
{"name":"QuotientAddGroup.mk_sum","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u_1\nι : Type u_2\ninst✝ : AddCommGroup G\nN : AddSubgroup G\ns : Finset ι\nf : ι → G\n⊢ Eq (↑(s.sum f)) (s.sum fun i => ↑(f i))","decl":"@[to_additive (attr := simp)]\ntheorem mk_prod {G ι : Type*} [CommGroup G] (N : Subgroup G) (s : Finset ι) {f : ι → G} :\n    ((Finset.prod s f : G) : G ⧸ N) = Finset.prod s (fun i => (f i : G ⧸ N)) :=\n  map_prod (QuotientGroup.mk' N) _ _\n\n"}
{"name":"QuotientGroup.mk_prod","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u_1\nι : Type u_2\ninst✝ : CommGroup G\nN : Subgroup G\ns : Finset ι\nf : ι → G\n⊢ Eq (↑(s.prod f)) (s.prod fun i => ↑(f i))","decl":"@[to_additive (attr := simp)]\ntheorem mk_prod {G ι : Type*} [CommGroup G] (N : Subgroup G) (s : Finset ι) {f : ι → G} :\n    ((Finset.prod s f : G) : G ⧸ N) = Finset.prod s (fun i => (f i : G ⧸ N)) :=\n  map_prod (QuotientGroup.mk' N) _ _\n\n"}
{"name":"QuotientAddGroup.strictMono_comap_prod_map","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\n⊢ StrictMono fun H => { fst := AddSubgroup.comap N.subtype H, snd := AddSubgroup.map (QuotientAddGroup.mk' N) H }","decl":"@[to_additive QuotientAddGroup.strictMono_comap_prod_map]\ntheorem strictMono_comap_prod_map :\n    StrictMono fun H : Subgroup G ↦ (H.comap N.subtype, H.map (mk' N)) :=\n  strictMono_comap_prod_image N\n\n"}
{"name":"QuotientGroup.strictMono_comap_prod_map","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\n⊢ StrictMono fun H => { fst := Subgroup.comap N.subtype H, snd := Subgroup.map (QuotientGroup.mk' N) H }","decl":"@[to_additive QuotientAddGroup.strictMono_comap_prod_map]\ntheorem strictMono_comap_prod_map :\n    StrictMono fun H : Subgroup G ↦ (H.comap N.subtype, H.map (mk' N)) :=\n  strictMono_comap_prod_image N\n\n"}
{"name":"QuotientGroup.kerLift_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\ng : G\n⊢ Eq ((QuotientGroup.kerLift φ) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem kerLift_mk (g : G) : (kerLift φ) g = φ g :=\n  lift_mk _ _ _\n\n"}
{"name":"QuotientAddGroup.kerLift_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\ng : G\n⊢ Eq ((QuotientAddGroup.kerLift φ) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem kerLift_mk (g : G) : (kerLift φ) g = φ g :=\n  lift_mk _ _ _\n\n"}
{"name":"QuotientGroup.kerLift_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\ng : G\n⊢ Eq ((QuotientGroup.kerLift φ) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem kerLift_mk' (g : G) : (kerLift φ) (mk g) = φ g :=\n  lift_mk' _ _ _\n\n"}
{"name":"QuotientAddGroup.kerLift_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\ng : G\n⊢ Eq ((QuotientAddGroup.kerLift φ) ↑g) (φ g)","decl":"@[to_additive (attr := simp)]\ntheorem kerLift_mk' (g : G) : (kerLift φ) (mk g) = φ g :=\n  lift_mk' _ _ _\n\n"}
{"name":"QuotientGroup.kerLift_injective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\n⊢ Function.Injective ⇑(QuotientGroup.kerLift φ)","decl":"@[to_additive]\ntheorem kerLift_injective : Injective (kerLift φ) := fun a b =>\n  Quotient.inductionOn₂' a b fun a b (h : φ a = φ b) =>\n    Quotient.sound' <| by rw [leftRel_apply, mem_ker, φ.map_mul, ← h, φ.map_inv, inv_mul_cancel]\n\n-- Note that `ker φ` isn't definitionally `ker (φ.rangeRestrict)`\n-- so there is a bit of annoying code duplication here\n"}
{"name":"QuotientAddGroup.kerLift_injective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\n⊢ Function.Injective ⇑(QuotientAddGroup.kerLift φ)","decl":"@[to_additive]\ntheorem kerLift_injective : Injective (kerLift φ) := fun a b =>\n  Quotient.inductionOn₂' a b fun a b (h : φ a = φ b) =>\n    Quotient.sound' <| by rw [leftRel_apply, mem_ker, φ.map_mul, ← h, φ.map_inv, inv_mul_cancel]\n\n-- Note that `ker φ` isn't definitionally `ker (φ.rangeRestrict)`\n-- so there is a bit of annoying code duplication here\n"}
{"name":"QuotientGroup.rangeKerLift_injective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\n⊢ Function.Injective ⇑(QuotientGroup.rangeKerLift φ)","decl":"@[to_additive]\ntheorem rangeKerLift_injective : Injective (rangeKerLift φ) := fun a b =>\n  Quotient.inductionOn₂' a b fun a b (h : φ.rangeRestrict a = φ.rangeRestrict b) =>\n    Quotient.sound' <| by\n      rw [leftRel_apply, ← ker_rangeRestrict, mem_ker, φ.rangeRestrict.map_mul, ← h,\n        φ.rangeRestrict.map_inv, inv_mul_cancel]\n\n"}
{"name":"QuotientAddGroup.rangeKerLift_injective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\n⊢ Function.Injective ⇑(QuotientAddGroup.rangeKerLift φ)","decl":"@[to_additive]\ntheorem rangeKerLift_injective : Injective (rangeKerLift φ) := fun a b =>\n  Quotient.inductionOn₂' a b fun a b (h : φ.rangeRestrict a = φ.rangeRestrict b) =>\n    Quotient.sound' <| by\n      rw [leftRel_apply, ← ker_rangeRestrict, mem_ker, φ.rangeRestrict.map_mul, ← h,\n        φ.rangeRestrict.map_inv, inv_mul_cancel]\n\n"}
{"name":"QuotientGroup.rangeKerLift_surjective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\n⊢ Function.Surjective ⇑(QuotientGroup.rangeKerLift φ)","decl":"@[to_additive]\ntheorem rangeKerLift_surjective : Surjective (rangeKerLift φ) := by\n  rintro ⟨_, g, rfl⟩\n  use mk g\n  rfl\n\n"}
{"name":"QuotientAddGroup.rangeKerLift_surjective","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\n⊢ Function.Surjective ⇑(QuotientAddGroup.rangeKerLift φ)","decl":"@[to_additive]\ntheorem rangeKerLift_surjective : Surjective (rangeKerLift φ) := by\n  rintro ⟨_, g, rfl⟩\n  use mk g\n  rfl\n\n"}
{"name":"QuotientAddGroup.quotientKerEquivOfRightInverse_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\nψ : H → G\nhφ : Function.RightInverse ψ ⇑φ\na : HasQuotient.Quotient G φ.ker\n⊢ Eq ((QuotientAddGroup.quotientKerEquivOfRightInverse φ ψ hφ) a) ((QuotientAddGroup.kerLift φ) a)","decl":"/-- The canonical isomorphism `G/(ker φ) ≃* H` induced by a homomorphism `φ : G →* H`\nwith a right inverse `ψ : H → G`. -/\n@[to_additive (attr := simps) \"The canonical isomorphism `G/(ker φ) ≃+ H` induced by a homomorphism\n`φ : G →+ H` with a right inverse `ψ : H → G`.\"]\ndef quotientKerEquivOfRightInverse (ψ : H → G) (hφ : RightInverse ψ φ) : G ⧸ ker φ ≃* H :=\n  { kerLift φ with\n    toFun := kerLift φ\n    invFun := mk ∘ ψ\n    left_inv := fun x => kerLift_injective φ (by rw [Function.comp_apply, kerLift_mk', hφ])\n    right_inv := hφ }\n\n"}
{"name":"QuotientGroup.quotientKerEquivOfRightInverse_symm_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\nψ : H → G\nhφ : Function.RightInverse ψ ⇑φ\na✝ : H\n⊢ Eq ((QuotientGroup.quotientKerEquivOfRightInverse φ ψ hφ).symm a✝) (Function.comp QuotientGroup.mk ψ a✝)","decl":"/-- The canonical isomorphism `G/(ker φ) ≃* H` induced by a homomorphism `φ : G →* H`\nwith a right inverse `ψ : H → G`. -/\n@[to_additive (attr := simps) \"The canonical isomorphism `G/(ker φ) ≃+ H` induced by a homomorphism\n`φ : G →+ H` with a right inverse `ψ : H → G`.\"]\ndef quotientKerEquivOfRightInverse (ψ : H → G) (hφ : RightInverse ψ φ) : G ⧸ ker φ ≃* H :=\n  { kerLift φ with\n    toFun := kerLift φ\n    invFun := mk ∘ ψ\n    left_inv := fun x => kerLift_injective φ (by rw [Function.comp_apply, kerLift_mk', hφ])\n    right_inv := hφ }\n\n"}
{"name":"QuotientAddGroup.quotientKerEquivOfRightInverse_symm_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nH : Type v\ninst✝ : AddGroup H\nφ : AddMonoidHom G H\nψ : H → G\nhφ : Function.RightInverse ψ ⇑φ\na✝ : H\n⊢ Eq ((QuotientAddGroup.quotientKerEquivOfRightInverse φ ψ hφ).symm a✝) (Function.comp QuotientAddGroup.mk ψ a✝)","decl":"/-- The canonical isomorphism `G/(ker φ) ≃* H` induced by a homomorphism `φ : G →* H`\nwith a right inverse `ψ : H → G`. -/\n@[to_additive (attr := simps) \"The canonical isomorphism `G/(ker φ) ≃+ H` induced by a homomorphism\n`φ : G →+ H` with a right inverse `ψ : H → G`.\"]\ndef quotientKerEquivOfRightInverse (ψ : H → G) (hφ : RightInverse ψ φ) : G ⧸ ker φ ≃* H :=\n  { kerLift φ with\n    toFun := kerLift φ\n    invFun := mk ∘ ψ\n    left_inv := fun x => kerLift_injective φ (by rw [Function.comp_apply, kerLift_mk', hφ])\n    right_inv := hφ }\n\n"}
{"name":"QuotientGroup.quotientKerEquivOfRightInverse_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nH : Type v\ninst✝ : Group H\nφ : MonoidHom G H\nψ : H → G\nhφ : Function.RightInverse ψ ⇑φ\na : HasQuotient.Quotient G φ.ker\n⊢ Eq ((QuotientGroup.quotientKerEquivOfRightInverse φ ψ hφ) a) ((QuotientGroup.kerLift φ) a)","decl":"/-- The canonical isomorphism `G/(ker φ) ≃* H` induced by a homomorphism `φ : G →* H`\nwith a right inverse `ψ : H → G`. -/\n@[to_additive (attr := simps) \"The canonical isomorphism `G/(ker φ) ≃+ H` induced by a homomorphism\n`φ : G →+ H` with a right inverse `ψ : H → G`.\"]\ndef quotientKerEquivOfRightInverse (ψ : H → G) (hφ : RightInverse ψ φ) : G ⧸ ker φ ≃* H :=\n  { kerLift φ with\n    toFun := kerLift φ\n    invFun := mk ∘ ψ\n    left_inv := fun x => kerLift_injective φ (by rw [Function.comp_apply, kerLift_mk', hφ])\n    right_inv := hφ }\n\n"}
{"name":"QuotientAddGroup.quotientBot_symm_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\na✝ : G\n⊢ Eq (QuotientAddGroup.quotientBot.symm a✝) ↑a✝","decl":"/-- The canonical isomorphism `G/⊥ ≃* G`. -/\n@[to_additive (attr := simps!) \"The canonical isomorphism `G/⊥ ≃+ G`.\"]\ndef quotientBot : G ⧸ (⊥ : Subgroup G) ≃* G :=\n  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl\n\n"}
{"name":"QuotientAddGroup.quotientBot_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\na : HasQuotient.Quotient G (AddMonoidHom.id G).ker\n⊢ Eq (QuotientAddGroup.quotientBot a) ((QuotientAddGroup.kerLift (AddMonoidHom.id G)) a)","decl":"/-- The canonical isomorphism `G/⊥ ≃* G`. -/\n@[to_additive (attr := simps!) \"The canonical isomorphism `G/⊥ ≃+ G`.\"]\ndef quotientBot : G ⧸ (⊥ : Subgroup G) ≃* G :=\n  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl\n\n"}
{"name":"QuotientGroup.quotientBot_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\na : HasQuotient.Quotient G (MonoidHom.id G).ker\n⊢ Eq (QuotientGroup.quotientBot a) ((QuotientGroup.kerLift (MonoidHom.id G)) a)","decl":"/-- The canonical isomorphism `G/⊥ ≃* G`. -/\n@[to_additive (attr := simps!) \"The canonical isomorphism `G/⊥ ≃+ G`.\"]\ndef quotientBot : G ⧸ (⊥ : Subgroup G) ≃* G :=\n  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl\n\n"}
{"name":"QuotientGroup.quotientBot_symm_apply","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\na✝ : G\n⊢ Eq (QuotientGroup.quotientBot.symm a✝) ↑a✝","decl":"/-- The canonical isomorphism `G/⊥ ≃* G`. -/\n@[to_additive (attr := simps!) \"The canonical isomorphism `G/⊥ ≃+ G`.\"]\ndef quotientBot : G ⧸ (⊥ : Subgroup G) ≃* G :=\n  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl\n\n"}
{"name":"QuotientAddGroup.quotientAddEquivOfEq_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝² : AddGroup G\nM N : AddSubgroup G\ninst✝¹ : M.Normal\ninst✝ : N.Normal\nh : Eq M N\nx : G\n⊢ Eq ((QuotientAddGroup.quotientAddEquivOfEq h) ↑x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem quotientMulEquivOfEq_mk {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) (x : G) :\n    QuotientGroup.quotientMulEquivOfEq h (QuotientGroup.mk x) = QuotientGroup.mk x :=\n  rfl\n\n"}
{"name":"QuotientGroup.quotientMulEquivOfEq_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝² : Group G\nM N : Subgroup G\ninst✝¹ : M.Normal\ninst✝ : N.Normal\nh : Eq M N\nx : G\n⊢ Eq ((QuotientGroup.quotientMulEquivOfEq h) ↑x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem quotientMulEquivOfEq_mk {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) (x : G) :\n    QuotientGroup.quotientMulEquivOfEq h (QuotientGroup.mk x) = QuotientGroup.mk x :=\n  rfl\n\n"}
{"name":"QuotientGroup.quotientMapSubgroupOfOfLe_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nA' A B' B : Subgroup G\n_hAN : (A'.subgroupOf A).Normal\n_hBN : (B'.subgroupOf B).Normal\nh' : LE.le A' B'\nh : LE.le A B\nx : Subtype fun x => Membership.mem A x\n⊢ Eq ((QuotientGroup.quotientMapSubgroupOfOfLe h' h) ↑x) ↑((Subgroup.inclusion h) x)","decl":"@[to_additive (attr := simp)]\ntheorem quotientMapSubgroupOfOfLe_mk {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]\n    [_hBN : (B'.subgroupOf B).Normal] (h' : A' ≤ B') (h : A ≤ B) (x : A) :\n    quotientMapSubgroupOfOfLe h' h x = ↑(Subgroup.inclusion h x : B) :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.quotientMapAddSubgroupOfOfLe_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nA' A B' B : AddSubgroup G\n_hAN : (A'.addSubgroupOf A).Normal\n_hBN : (B'.addSubgroupOf B).Normal\nh' : LE.le A' B'\nh : LE.le A B\nx : Subtype fun x => Membership.mem A x\n⊢ Eq ((QuotientAddGroup.quotientMapAddSubgroupOfOfLe h' h) ↑x) ↑((AddSubgroup.inclusion h) x)","decl":"@[to_additive (attr := simp)]\ntheorem quotientMapSubgroupOfOfLe_mk {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]\n    [_hBN : (B'.subgroupOf B).Normal] (h' : A' ≤ B') (h : A ≤ B) (x : A) :\n    quotientMapSubgroupOfOfLe h' h x = ↑(Subgroup.inclusion h x : B) :=\n  rfl\n\n"}
{"name":"QuotientGroup.homQuotientZPowOfHom_id","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A : Type u\ninst✝ : CommGroup A\nn : Int\n⊢ Eq (QuotientGroup.homQuotientZPowOfHom (MonoidHom.id A) n) (MonoidHom.id (HasQuotient.Quotient A (zpowGroupHom n).range))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :=\n  monoidHom_ext _ rfl\n\n"}
{"name":"QuotientAddGroup.homQuotientZSMulOfHom_id","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A : Type u\ninst✝ : AddCommGroup A\nn : Int\n⊢ Eq (QuotientAddGroup.homQuotientZSMulOfHom (AddMonoidHom.id A) n) (AddMonoidHom.id (HasQuotient.Quotient A (zsmulAddGroupHom n).range))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :=\n  monoidHom_ext _ rfl\n\n"}
{"name":"QuotientAddGroup.homQuotientZSMulOfHom_comp","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup B\nf : AddMonoidHom A B\ng : AddMonoidHom B A\nn : Int\n⊢ Eq (QuotientAddGroup.homQuotientZSMulOfHom (f.comp g) n) ((QuotientAddGroup.homQuotientZSMulOfHom f n).comp (QuotientAddGroup.homQuotientZSMulOfHom g n))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp :\n    homQuotientZPowOfHom (f.comp g) n =\n      (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) :=\n  monoidHom_ext _ rfl\n\n"}
{"name":"QuotientGroup.homQuotientZPowOfHom_comp","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : CommGroup A\ninst✝ : CommGroup B\nf : MonoidHom A B\ng : MonoidHom B A\nn : Int\n⊢ Eq (QuotientGroup.homQuotientZPowOfHom (f.comp g) n) ((QuotientGroup.homQuotientZPowOfHom f n).comp (QuotientGroup.homQuotientZPowOfHom g n))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp :\n    homQuotientZPowOfHom (f.comp g) n =\n      (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) :=\n  monoidHom_ext _ rfl\n\n"}
{"name":"QuotientGroup.homQuotientZPowOfHom_comp_of_rightInverse","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : CommGroup A\ninst✝ : CommGroup B\nf : MonoidHom A B\ng : MonoidHom B A\nn : Int\ni : Function.RightInverse ⇑g ⇑f\n⊢ Eq ((QuotientGroup.homQuotientZPowOfHom f n).comp (QuotientGroup.homQuotientZPowOfHom g n)) (MonoidHom.id (HasQuotient.Quotient B (zpowGroupHom n).range))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp_of_rightInverse (i : Function.RightInverse g f) :\n    (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) = MonoidHom.id _ :=\n  monoidHom_ext _ <| MonoidHom.ext fun x => congrArg _ <| i x\n\n"}
{"name":"QuotientAddGroup.homQuotientZSMulOfHom_comp_of_rightInverse","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup B\nf : AddMonoidHom A B\ng : AddMonoidHom B A\nn : Int\ni : Function.RightInverse ⇑g ⇑f\n⊢ Eq ((QuotientAddGroup.homQuotientZSMulOfHom f n).comp (QuotientAddGroup.homQuotientZSMulOfHom g n)) (AddMonoidHom.id (HasQuotient.Quotient B (zsmulAddGroupHom n).range))","decl":"@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp_of_rightInverse (i : Function.RightInverse g f) :\n    (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) = MonoidHom.id _ :=\n  monoidHom_ext _ <| MonoidHom.ext fun x => congrArg _ <| i x\n\n"}
{"name":"QuotientAddGroup.equivQuotientZSMulOfEquiv_refl","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A : Type u\ninst✝ : AddCommGroup A\nn : Int\n⊢ Eq (AddEquiv.refl (HasQuotient.Quotient A (zsmulAddGroupHom n).range)) (QuotientAddGroup.equivQuotientZSMulOfEquiv (AddEquiv.refl A) n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_refl :\n    MulEquiv.refl (A ⧸ (zpowGroupHom n : A →* A).range) =\n      equivQuotientZPowOfEquiv (MulEquiv.refl A) n := by\n  ext x\n  rw [← Quotient.out_eq' x]\n  rfl\n\n"}
{"name":"QuotientGroup.equivQuotientZPowOfEquiv_refl","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A : Type u\ninst✝ : CommGroup A\nn : Int\n⊢ Eq (MulEquiv.refl (HasQuotient.Quotient A (zpowGroupHom n).range)) (QuotientGroup.equivQuotientZPowOfEquiv (MulEquiv.refl A) n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_refl :\n    MulEquiv.refl (A ⧸ (zpowGroupHom n : A →* A).range) =\n      equivQuotientZPowOfEquiv (MulEquiv.refl A) n := by\n  ext x\n  rw [← Quotient.out_eq' x]\n  rfl\n\n"}
{"name":"QuotientAddGroup.equivQuotientZSMulOfEquiv_symm","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : AddCommGroup A\ninst✝ : AddCommGroup B\ne : AddEquiv A B\nn : Int\n⊢ Eq (QuotientAddGroup.equivQuotientZSMulOfEquiv e n).symm (QuotientAddGroup.equivQuotientZSMulOfEquiv e.symm n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_symm :\n    (equivQuotientZPowOfEquiv e n).symm = equivQuotientZPowOfEquiv e.symm n :=\n  rfl\n\n"}
{"name":"QuotientGroup.equivQuotientZPowOfEquiv_symm","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B : Type u\ninst✝¹ : CommGroup A\ninst✝ : CommGroup B\ne : MulEquiv A B\nn : Int\n⊢ Eq (QuotientGroup.equivQuotientZPowOfEquiv e n).symm (QuotientGroup.equivQuotientZPowOfEquiv e.symm n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_symm :\n    (equivQuotientZPowOfEquiv e n).symm = equivQuotientZPowOfEquiv e.symm n :=\n  rfl\n\n"}
{"name":"QuotientAddGroup.equivQuotientZSMulOfEquiv_trans","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B C : Type u\ninst✝² : AddCommGroup A\ninst✝¹ : AddCommGroup B\ninst✝ : AddCommGroup C\ne : AddEquiv A B\nd : AddEquiv B C\nn : Int\n⊢ Eq ((QuotientAddGroup.equivQuotientZSMulOfEquiv e n).trans (QuotientAddGroup.equivQuotientZSMulOfEquiv d n)) (QuotientAddGroup.equivQuotientZSMulOfEquiv (e.trans d) n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_trans :\n    (equivQuotientZPowOfEquiv e n).trans (equivQuotientZPowOfEquiv d n) =\n      equivQuotientZPowOfEquiv (e.trans d) n := by\n  ext x\n  rw [← Quotient.out_eq' x]\n  rfl\n\n"}
{"name":"QuotientGroup.equivQuotientZPowOfEquiv_trans","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"A B C : Type u\ninst✝² : CommGroup A\ninst✝¹ : CommGroup B\ninst✝ : CommGroup C\ne : MulEquiv A B\nd : MulEquiv B C\nn : Int\n⊢ Eq ((QuotientGroup.equivQuotientZPowOfEquiv e n).trans (QuotientGroup.equivQuotientZPowOfEquiv d n)) (QuotientGroup.equivQuotientZPowOfEquiv (e.trans d) n)","decl":"@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_trans :\n    (equivQuotientZPowOfEquiv e n).trans (equivQuotientZPowOfEquiv d n) =\n      equivQuotientZPowOfEquiv (e.trans d) n := by\n  ext x\n  rw [← Quotient.out_eq' x]\n  rfl\n\n"}
{"name":"QuotientAddGroup.map_normal","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : AddSubgroup G\nnM : M.Normal\n⊢ (AddSubgroup.map (QuotientAddGroup.mk' N) M).Normal","decl":"@[to_additive]\ninstance map_normal : (M.map (QuotientGroup.mk' N)).Normal :=\n  nM.map _ mk_surjective\n\n"}
{"name":"QuotientGroup.map_normal","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Subgroup G\nnM : M.Normal\n⊢ (Subgroup.map (QuotientGroup.mk' N) M).Normal","decl":"@[to_additive]\ninstance map_normal : (M.map (QuotientGroup.mk' N)).Normal :=\n  nM.map _ mk_surjective\n\n"}
{"name":"QuotientGroup.quotientQuotientEquivQuotientAux_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Subgroup G\nnM : M.Normal\nh : LE.le N M\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientGroup.quotientQuotientEquivQuotientAux N M h) ↑x) ((QuotientGroup.map N M (MonoidHom.id G) h) x)","decl":"@[to_additive (attr := simp)]\ntheorem quotientQuotientEquivQuotientAux_mk (x : G ⧸ N) :\n    quotientQuotientEquivQuotientAux N M h x = QuotientGroup.map N M (MonoidHom.id G) h x :=\n  QuotientGroup.lift_mk' _ _ x\n\n"}
{"name":"QuotientAddGroup.quotientQuotientEquivQuotientAux_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : AddSubgroup G\nnM : M.Normal\nh : LE.le N M\nx : HasQuotient.Quotient G N\n⊢ Eq ((QuotientAddGroup.quotientQuotientEquivQuotientAux N M h) ↑x) ((QuotientAddGroup.map N M (AddMonoidHom.id G) h) x)","decl":"@[to_additive (attr := simp)]\ntheorem quotientQuotientEquivQuotientAux_mk (x : G ⧸ N) :\n    quotientQuotientEquivQuotientAux N M h x = QuotientGroup.map N M (MonoidHom.id G) h x :=\n  QuotientGroup.lift_mk' _ _ x\n\n"}
{"name":"QuotientAddGroup.quotientQuotientEquivQuotientAux_mk_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nN : AddSubgroup G\nnN : N.Normal\nM : AddSubgroup G\nnM : M.Normal\nh : LE.le N M\nx : G\n⊢ Eq ((QuotientAddGroup.quotientQuotientEquivQuotientAux N M h) ↑↑x) ↑x","decl":"@[to_additive]\ntheorem quotientQuotientEquivQuotientAux_mk_mk (x : G) :\n    quotientQuotientEquivQuotientAux N M h (x : G ⧸ N) = x :=\n  QuotientGroup.lift_mk' (M.map (mk' N)) _ x\n\n"}
{"name":"QuotientGroup.quotientQuotientEquivQuotientAux_mk_mk","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nN : Subgroup G\nnN : N.Normal\nM : Subgroup G\nnM : M.Normal\nh : LE.le N M\nx : G\n⊢ Eq ((QuotientGroup.quotientQuotientEquivQuotientAux N M h) ↑↑x) ↑x","decl":"@[to_additive]\ntheorem quotientQuotientEquivQuotientAux_mk_mk (x : G) :\n    quotientQuotientEquivQuotientAux N M h (x : G ⧸ N) = x :=\n  QuotientGroup.lift_mk' (M.map (mk' N)) _ x\n\n"}
{"name":"QuotientAddGroup.le_comap_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN : AddSubgroup G\ninst✝ : N.Normal\nH : AddSubgroup (HasQuotient.Quotient G N)\n⊢ LE.le N (AddSubgroup.comap (QuotientAddGroup.mk' N) H)","decl":"@[to_additive]\ntheorem le_comap_mk' (N : Subgroup G) [N.Normal] (H : Subgroup (G ⧸ N)) :\n    N ≤ Subgroup.comap (QuotientGroup.mk' N) H := by\n  simpa using Subgroup.comap_mono (f := mk' N) bot_le\n\n"}
{"name":"QuotientGroup.le_comap_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : N.Normal\nH : Subgroup (HasQuotient.Quotient G N)\n⊢ LE.le N (Subgroup.comap (QuotientGroup.mk' N) H)","decl":"@[to_additive]\ntheorem le_comap_mk' (N : Subgroup G) [N.Normal] (H : Subgroup (G ⧸ N)) :\n    N ≤ Subgroup.comap (QuotientGroup.mk' N) H := by\n  simpa using Subgroup.comap_mono (f := mk' N) bot_le\n\n"}
{"name":"QuotientAddGroup.comap_map_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : AddGroup G\nN H : AddSubgroup G\ninst✝ : N.Normal\n⊢ Eq (AddSubgroup.comap (QuotientAddGroup.mk' N) (AddSubgroup.map (QuotientAddGroup.mk' N) H)) (Max.max N H)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_mk' (N H : Subgroup G) [N.Normal] :\n    Subgroup.comap (mk' N) (Subgroup.map (mk' N) H) = N ⊔ H := by\n  simp [Subgroup.comap_map_eq, sup_comm]\n\n"}
{"name":"QuotientGroup.comap_map_mk'","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝¹ : Group G\nN H : Subgroup G\ninst✝ : N.Normal\n⊢ Eq (Subgroup.comap (QuotientGroup.mk' N) (Subgroup.map (QuotientGroup.mk' N) H)) (Max.max N H)","decl":"@[to_additive (attr := simp)]\ntheorem comap_map_mk' (N H : Subgroup G) [N.Normal] :\n    Subgroup.comap (mk' N) (Subgroup.map (mk' N) H) = N ⊔ H := by\n  simp [Subgroup.comap_map_eq, sup_comm]\n\n"}
{"name":"QuotientAddGroup.subsingleton_quotient_top","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\n⊢ Subsingleton (HasQuotient.Quotient G Top.top)","decl":"@[to_additive]\ntheorem subsingleton_quotient_top : Subsingleton (G ⧸ (⊤ : Subgroup G)) := by\n  dsimp [HasQuotient.Quotient, QuotientGroup.instHasQuotientSubgroup, Quotient]\n  rw [leftRel_eq]\n  exact Trunc.instSubsingletonTrunc\n\n"}
{"name":"QuotientGroup.subsingleton_quotient_top","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ Subsingleton (HasQuotient.Quotient G Top.top)","decl":"@[to_additive]\ntheorem subsingleton_quotient_top : Subsingleton (G ⧸ (⊤ : Subgroup G)) := by\n  dsimp [HasQuotient.Quotient, QuotientGroup.instHasQuotientSubgroup, Quotient]\n  rw [leftRel_eq]\n  exact Trunc.instSubsingletonTrunc\n\n"}
{"name":"QuotientAddGroup.addSubgroup_eq_top_of_subsingleton","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : Subsingleton (HasQuotient.Quotient G H)\n⊢ Eq H Top.top","decl":"/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\n@[to_additive \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group.\"]\ntheorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=\n  top_unique fun x _ => by\n    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)\n    rwa [inv_one, one_mul] at this\n\n"}
{"name":"QuotientGroup.subgroup_eq_top_of_subsingleton","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝ : Group G\nH : Subgroup G\nh : Subsingleton (HasQuotient.Quotient G H)\n⊢ Eq H Top.top","decl":"/-- If the quotient by a subgroup gives a singleton then the subgroup is the whole group. -/\n@[to_additive \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group.\"]\ntheorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G ⧸ H)) : H = ⊤ :=\n  top_unique fun x _ => by\n    have this : 1⁻¹ * x ∈ H := QuotientGroup.eq.1 (Subsingleton.elim _ _)\n    rwa [inv_one, one_mul] at this\n\n"}
{"name":"QuotientAddGroup.comap_comap_center","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝² : AddGroup G\nH₁ : AddSubgroup G\ninst✝¹ : H₁.Normal\nH₂ : AddSubgroup (HasQuotient.Quotient G H₁)\ninst✝ : H₂.Normal\n⊢ Eq (AddSubgroup.comap (QuotientAddGroup.mk' H₁) (AddSubgroup.comap (QuotientAddGroup.mk' H₂) (AddSubgroup.center (HasQuotient.Quotient (HasQuotient.Quotient G H₁) H₂)))) (AddSubgroup.comap (QuotientAddGroup.mk' (AddSubgroup.comap (QuotientAddGroup.mk' H₁) H₂)) (AddSubgroup.center (HasQuotient.Quotient G (AddSubgroup.comap (QuotientAddGroup.mk' H₁) H₂))))","decl":"@[to_additive]\ntheorem comap_comap_center {H₁ : Subgroup G} [H₁.Normal] {H₂ : Subgroup (G ⧸ H₁)} [H₂.Normal] :\n    ((Subgroup.center ((G ⧸ H₁) ⧸ H₂)).comap (mk' H₂)).comap (mk' H₁) =\n      (Subgroup.center (G ⧸ H₂.comap (mk' H₁))).comap (mk' (H₂.comap (mk' H₁))) := by\n  ext x\n  simp only [mk'_apply, Subgroup.mem_comap, Subgroup.mem_center_iff, forall_mk, ← mk_mul,\n    eq_iff_div_mem, mk_div]\n\n"}
{"name":"QuotientGroup.comap_comap_center","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"G : Type u\ninst✝² : Group G\nH₁ : Subgroup G\ninst✝¹ : H₁.Normal\nH₂ : Subgroup (HasQuotient.Quotient G H₁)\ninst✝ : H₂.Normal\n⊢ Eq (Subgroup.comap (QuotientGroup.mk' H₁) (Subgroup.comap (QuotientGroup.mk' H₂) (Subgroup.center (HasQuotient.Quotient (HasQuotient.Quotient G H₁) H₂)))) (Subgroup.comap (QuotientGroup.mk' (Subgroup.comap (QuotientGroup.mk' H₁) H₂)) (Subgroup.center (HasQuotient.Quotient G (Subgroup.comap (QuotientGroup.mk' H₁) H₂))))","decl":"@[to_additive]\ntheorem comap_comap_center {H₁ : Subgroup G} [H₁.Normal] {H₂ : Subgroup (G ⧸ H₁)} [H₂.Normal] :\n    ((Subgroup.center ((G ⧸ H₁) ⧸ H₂)).comap (mk' H₂)).comap (mk' H₁) =\n      (Subgroup.center (G ⧸ H₂.comap (mk' H₁))).comap (mk' (H₂.comap (mk' H₁))) := by\n  ext x\n  simp only [mk'_apply, Subgroup.mem_comap, Subgroup.mem_center_iff, forall_mk, ← mk_mul,\n    eq_iff_div_mem, mk_div]\n\n"}
{"name":"QuotientAddGroup.mk_nat_mul","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocRing R\nN : AddSubgroup R\ninst✝ : N.Normal\nn : Nat\na : R\n⊢ Eq (↑(HMul.hMul (↑n) a)) (HSMul.hSMul n ↑a)","decl":"@[simp]\ntheorem mk_nat_mul (n : ℕ) (a : R) : ((n * a : R) : R ⧸ N) = n • ↑a := by\n  rw [← nsmul_eq_mul, mk_nsmul N a n]\n\n"}
{"name":"QuotientAddGroup.mk_int_mul","module":"Mathlib.GroupTheory.QuotientGroup.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonAssocRing R\nN : AddSubgroup R\ninst✝ : N.Normal\nn : Int\na : R\n⊢ Eq (↑(HMul.hMul (↑n) a)) (HSMul.hSMul n ↑a)","decl":"@[simp]\ntheorem mk_int_mul (n : ℤ) (a : R) : ((n * a : R) : R ⧸ N) = n • ↑a := by\n  rw [← zsmul_eq_mul, mk_zsmul N a n]\n\n"}
