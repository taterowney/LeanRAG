{"name":"CategoryTheory.Adjunction.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto✝\nright_triangle_components : autoParam (∀ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto✝\n⊢ Eq (SizeOf.sizeOf { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit))","decl":"/-- `F ⊣ G` represents the data of an adjunction between two functors\n`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit and counit with the identity `F ⟶ FGF ⟶ F = 𝟙` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ≫ counit.app (F.obj X) = 𝟙 (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ⟶ GFG ⟶ G = 𝟙` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ≫ G.map (counit.app Y) = 𝟙 (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit✝.app X)) (counit✝.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto✝\nright_triangle_components✝ : autoParam (∀ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit✝.app (G.obj Y)) (G.map (counit✝.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto✝\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto✝\nright_triangle_components : autoParam (∀ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto✝\n⊢ Eq (Eq { unit := unit✝, counit := counit✝, left_triangle_components := left_triangle_components✝, right_triangle_components := right_triangle_components✝ } { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }) (And (Eq unit✝ unit) (Eq counit✝ counit))","decl":"/-- `F ⊣ G` represents the data of an adjunction between two functors\n`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit and counit with the identity `F ⟶ FGF ⟶ F = 𝟙` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ≫ counit.app (F.obj X) = 𝟙 (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ⟶ GFG ⟶ G = 𝟙` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ≫ G.map (counit.app Y) = 𝟙 (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle_components","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nY : D\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.unit.app (G.obj Y)) (G.map (self.counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))","decl":"/-- `F ⊣ G` represents the data of an adjunction between two functors\n`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit and counit with the identity `F ⟶ FGF ⟶ F = 𝟙` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ≫ counit.app (F.obj X) = 𝟙 (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ⟶ GFG ⟶ G = 𝟙` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ≫ G.map (counit.app Y) = 𝟙 (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit✝.app X)) (counit✝.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto✝\nright_triangle_components✝ : autoParam (∀ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit✝.app (G.obj Y)) (G.map (counit✝.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto✝\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto✝\nright_triangle_components : autoParam (∀ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto✝\nx✝ : Eq { unit := unit✝, counit := counit✝, left_triangle_components := left_triangle_components✝, right_triangle_components := right_triangle_components✝ } { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }\n⊢ And (Eq unit✝ unit) (Eq counit✝ counit)","decl":"/-- `F ⊣ G` represents the data of an adjunction between two functors\n`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit and counit with the identity `F ⟶ FGF ⟶ F = 𝟙` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ≫ counit.app (F.obj X) = 𝟙 (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ⟶ GFG ⟶ G = 𝟙` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ≫ G.map (counit.app Y) = 𝟙 (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle_components","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (self.unit.app X)) (self.counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- `F ⊣ G` represents the data of an adjunction between two functors\n`F : C ⥤ D` and `G : D ⥤ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit and counit with the identity `F ⟶ FGF ⟶ F = 𝟙` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ≫ counit.app (F.obj X) = 𝟙 (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ⟶ GFG ⟶ G = 𝟙` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ≫ G.map (counit.app Y) = 𝟙 (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.IsLeftAdjoint.exists_rightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nleft : CategoryTheory.Functor C D\nself : left.IsLeftAdjoint\n⊢ Exists fun right => Nonempty (CategoryTheory.Adjunction left right)","decl":"/-- A class asserting the existence of a right adjoint. -/\nclass IsLeftAdjoint (left : C ⥤ D) : Prop where\n  exists_rightAdjoint : ∃ (right : D ⥤ C), Nonempty (left ⊣ right)\n\n"}
{"name":"CategoryTheory.Functor.IsRightAdjoint.exists_leftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nright : CategoryTheory.Functor D C\nself : right.IsRightAdjoint\n⊢ Exists fun left => Nonempty (CategoryTheory.Adjunction left right)","decl":"/-- A class asserting the existence of a left adjoint. -/\nclass IsRightAdjoint (right : D ⥤ C) : Prop where\n  exists_leftAdjoint : ∃ (left : C ⥤ D), Nonempty (left ⊣ right)\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle_components_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nY : D\nZ : C\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.unit.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (G.map (self.counit.app Y)) h)) h","decl":"attribute [reassoc (attr := simp)] left_triangle_components right_triangle_components\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle_components_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (self.unit.app X)) (CategoryTheory.CategoryStruct.comp (self.counit.app (F.obj X)) h)) h","decl":"attribute [reassoc (attr := simp)] left_triangle_components right_triangle_components\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app Y))","decl":"/-- The hom set equivalence associated to an adjunction. -/\n@[simps (config := .lemmasOnly)]\ndef homEquiv {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) (X : C) (Y : D) :\n    (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y) where\n  toFun := fun f => adj.unit.app X ≫ G.map f\n  invFun := fun g => F.map g ≫ adj.counit.app Y\n  left_inv := fun f => by\n    dsimp\n    rw [F.map_comp, assoc, ← Functor.comp_map, adj.counit.naturality, ← assoc]\n    simp\n  right_inv := fun g => by\n    simp only [Functor.comp_obj, Functor.map_comp]\n    rw [← assoc, ← Functor.comp_map, ← adj.unit.naturality]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map f))","decl":"/-- The hom set equivalence associated to an adjunction. -/\n@[simps (config := .lemmasOnly)]\ndef homEquiv {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) (X : C) (Y : D) :\n    (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y) where\n  toFun := fun f => adj.unit.app X ≫ G.map f\n  invFun := fun g => F.map g ≫ adj.counit.app Y\n  left_inv := fun f => by\n    dsimp\n    rw [F.map_comp, assoc, ← Functor.comp_map, adj.counit.naturality, ← assoc]\n    simp\n  right_inv := fun g => by\n    simp only [Functor.comp_obj, Functor.map_comp]\n    rw [← assoc, ← Functor.comp_map, ← adj.unit.naturality]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map f))","decl":"alias homEquiv_unit := homEquiv_apply\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app Y))","decl":"alias homEquiv_counit := homEquiv_symm_apply\n\n"}
{"name":"CategoryTheory.Adjunction.ext_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj adj' : CategoryTheory.Adjunction F G\n⊢ Iff (Eq adj adj') (Eq adj.unit adj'.unit)","decl":"@[ext]\nlemma ext {F : C ⥤ D} {G : D ⥤ C} {adj adj' : F ⊣ G}\n    (h : adj.unit = adj'.unit) : adj = adj' := by\n  suffices h' : adj.counit = adj'.counit by cases adj; cases adj'; aesop\n  ext X\n  apply (adj.homEquiv _ _).injective\n  rw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit,\n    Adjunction.right_triangle_components, h, Adjunction.right_triangle_components]\n\n"}
{"name":"CategoryTheory.Adjunction.ext","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj adj' : CategoryTheory.Adjunction F G\nh : Eq adj.unit adj'.unit\n⊢ Eq adj adj'","decl":"@[ext]\nlemma ext {F : C ⥤ D} {G : D ⥤ C} {adj adj' : F ⊣ G}\n    (h : adj.unit = adj'.unit) : adj = adj' := by\n  suffices h' : adj.counit = adj'.counit by cases adj; cases adj'; aesop\n  ext X\n  apply (adj.homEquiv _ _).injective\n  rw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit,\n    Adjunction.right_triangle_components, h, Adjunction.right_triangle_components]\n\n"}
{"name":"CategoryTheory.Adjunction.isLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ F.IsLeftAdjoint","decl":"lemma isLeftAdjoint (adj : F ⊣ G) : F.IsLeftAdjoint := ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ G.IsRightAdjoint","decl":"lemma isRightAdjoint (adj : F ⊣ G) : G.IsRightAdjoint := ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.instIsLeftAdjointLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝ : R.IsRightAdjoint\n⊢ R.leftAdjoint.IsLeftAdjoint","decl":"instance (R : D ⥤ C) [R.IsRightAdjoint] : R.leftAdjoint.IsLeftAdjoint :=\n  (ofIsRightAdjoint R).isLeftAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.instIsRightAdjointRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\ninst✝ : L.IsLeftAdjoint\n⊢ L.rightAdjoint.IsRightAdjoint","decl":"instance (L : C ⥤ D) [L.IsLeftAdjoint] : L.rightAdjoint.IsRightAdjoint :=\n  (ofIsLeftAdjoint L).isRightAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_id","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\n⊢ Eq ((adj.homEquiv X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X))) (adj.unit.app X)","decl":"theorem homEquiv_id (X : C) : adj.homEquiv X _ (𝟙 _) = adj.unit.app X := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_symm_id","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : D\n⊢ Eq ((adj.homEquiv (G.obj X) X).symm (CategoryTheory.CategoryStruct.id (G.obj X))) (adj.counit.app X)","decl":"theorem homEquiv_symm_id (X : D) : (adj.homEquiv _ X).symm (𝟙 _) = adj.counit.app X := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y)\n⊢ Eq ((adj.homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y).symm g))","decl":"theorem homEquiv_naturality_left_symm (f : X' ⟶ X) (g : X ⟶ G.obj Y) :\n    (adj.homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (adj.homEquiv X Y).symm g := by\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y) g))","decl":"theorem homEquiv_naturality_left (f : X' ⟶ X) (g : F.obj X ⟶ Y) :\n    (adj.homEquiv X' Y) (F.map f ≫ g) = f ≫ (adj.homEquiv X Y) g := by\n  rw [← Equiv.eq_symm_apply]\n  simp only [Equiv.symm_apply_apply, eq_self_iff_true, homEquiv_naturality_left_symm]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY Y' : D\nf : Quiver.Hom (F.obj X) Y\ng : Quiver.Hom Y Y'\n⊢ Eq ((adj.homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y) f) (G.map g))","decl":"theorem homEquiv_naturality_right (f : F.obj X ⟶ Y) (g : Y ⟶ Y') :\n    (adj.homEquiv X Y') (f ≫ g) = (adj.homEquiv X Y) f ≫ G.map g := by\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY Y' : D\nf : Quiver.Hom X (G.obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq ((adj.homEquiv X Y').symm (CategoryTheory.CategoryStruct.comp f (G.map g))) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y).symm f) g)","decl":"theorem homEquiv_naturality_right_symm (f : X ⟶ G.obj Y) (g : Y ⟶ Y') :\n    (adj.homEquiv X Y').symm (f ≫ G.map g) = (adj.homEquiv X Y).symm f ≫ g := by\n  rw [Equiv.symm_apply_eq]\n  simp only [homEquiv_naturality_right, eq_self_iff_true, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh✝ : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h✝ k)\nZ : C\nh : Quiver.Hom (G.obj Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y') g) h)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h✝) (CategoryTheory.CategoryStruct.comp (G.map k) h))","decl":"@[reassoc]\ntheorem homEquiv_naturality_left_square (f : X' ⟶ X) (g : F.obj X ⟶ Y')\n    (h : F.obj X' ⟶ Y) (k : Y ⟶ Y') (w : F.map f ≫ g = h ≫ k) :\n    f ≫ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ≫ G.map k := by\n  rw [← homEquiv_naturality_left, ← homEquiv_naturality_right, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h k)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y') g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h) (G.map k))","decl":"@[reassoc]\ntheorem homEquiv_naturality_left_square (f : X' ⟶ X) (g : F.obj X ⟶ Y')\n    (h : F.obj X' ⟶ Y) (k : Y ⟶ Y') (w : F.map f ≫ g = h ≫ k) :\n    f ≫ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ≫ G.map k := by\n  rw [← homEquiv_naturality_left, ← homEquiv_naturality_right, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh✝ : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h✝ (G.map k))\nZ : D\nh : Quiver.Hom Y' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y').symm g) h)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h✝) (CategoryTheory.CategoryStruct.comp k h))","decl":"@[reassoc]\ntheorem homEquiv_naturality_right_square (f : X' ⟶ X) (g : X ⟶ G.obj Y')\n    (h : X' ⟶ G.obj Y) (k : Y ⟶ Y') (w : f ≫ g = h ≫ G.map k) :\n    F.map f ≫ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ≫ k := by\n  rw [← homEquiv_naturality_left_symm, ← homEquiv_naturality_right_symm, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h (G.map k))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y').symm g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h) k)","decl":"@[reassoc]\ntheorem homEquiv_naturality_right_square (f : X' ⟶ X) (g : X ⟶ G.obj Y')\n    (h : X' ⟶ G.obj Y) (k : Y ⟶ Y') (w : f ≫ g = h ≫ G.map k) :\n    F.map f ≫ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ≫ k := by\n  rw [← homEquiv_naturality_left_symm, ← homEquiv_naturality_right_symm, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y') g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h) (G.map k))) (Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h k))","decl":"theorem homEquiv_naturality_left_square_iff (f : X' ⟶ X) (g : F.obj X ⟶ Y')\n    (h : F.obj X' ⟶ Y) (k : Y ⟶ Y') :\n    (f ≫ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ≫ G.map k) ↔\n      (F.map f ≫ g = h ≫ k) :=\n  ⟨fun w ↦ by simpa only [Equiv.symm_apply_apply]\n      using homEquiv_naturality_right_square adj _ _ _ _ w,\n    homEquiv_naturality_left_square adj f g h k⟩\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y').symm g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h) k)) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h (G.map k)))","decl":"theorem homEquiv_naturality_right_square_iff (f : X' ⟶ X) (g : X ⟶ G.obj Y')\n    (h : X' ⟶ G.obj Y) (k : Y ⟶ Y') :\n    (F.map f ≫ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ≫ k) ↔\n      (f ≫ g = h ≫ G.map k) :=\n  ⟨fun w ↦ by simpa only [Equiv.apply_symm_apply]\n      using homEquiv_naturality_left_square adj _ _ _ _ w,\n    homEquiv_naturality_right_square adj f g h k⟩\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight adj.unit F) (CategoryTheory.whiskerLeft F adj.counit)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).comp F))","decl":"@[simp]\ntheorem left_triangle : whiskerRight adj.unit F ≫ whiskerLeft F adj.counit = 𝟙 _ := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G adj.unit) (CategoryTheory.whiskerRight adj.counit G)) (CategoryTheory.CategoryStruct.id (G.comp (CategoryTheory.Functor.id C)))","decl":"@[simp]\ntheorem right_triangle : whiskerLeft G adj.unit ≫ whiskerRight adj.counit G = 𝟙 _ := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Adjunction.counit_naturality","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : D\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map f)) (adj.counit.app Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app X) f)","decl":"@[reassoc (attr := simp)]\ntheorem counit_naturality {X Y : D} (f : X ⟶ Y) :\n    F.map (G.map f) ≫ adj.counit.app Y = adj.counit.app X ≫ f :=\n  adj.counit.naturality f\n\n"}
{"name":"CategoryTheory.Adjunction.counit_naturality_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : D\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map f)) (CategoryTheory.CategoryStruct.comp (adj.counit.app Y) h)) (CategoryTheory.CategoryStruct.comp (adj.counit.app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem counit_naturality {X Y : D} (f : X ⟶ Y) :\n    F.map (G.map f) ≫ adj.counit.app Y = adj.counit.app X ≫ f :=\n  adj.counit.naturality f\n\n"}
{"name":"CategoryTheory.Adjunction.unit_naturality","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map (F.map f))) (CategoryTheory.CategoryStruct.comp f (adj.unit.app Y))","decl":"@[reassoc (attr := simp)]\ntheorem unit_naturality {X Y : C} (f : X ⟶ Y) :\n    adj.unit.app X ≫ G.map (F.map f) = f ≫ adj.unit.app Y :=\n  (adj.unit.naturality f).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_naturality_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (G.obj (F.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (CategoryTheory.CategoryStruct.comp (G.map (F.map f)) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (adj.unit.app Y) h))","decl":"@[reassoc (attr := simp)]\ntheorem unit_naturality {X Y : C} (f : X ⟶ Y) :\n    adj.unit.app X ≫ G.map (F.map f) = f ≫ adj.unit.app Y :=\n  (adj.unit.naturality f).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_comp_map_eq_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n⊢ Iff (Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app A) (G.map f)) g) (Eq f (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app B)))","decl":"lemma unit_comp_map_eq_iff {A : C} {B : D} (f : F.obj A ⟶ B) (g : A ⟶ G.obj B) :\n    adj.unit.app A ≫ G.map f = g ↔ f = F.map g ≫ adj.counit.app B :=\n  ⟨fun h => by simp [← h], fun h => by simp [h]⟩\n\n"}
{"name":"CategoryTheory.Adjunction.eq_unit_comp_map_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n⊢ Iff (Eq g (CategoryTheory.CategoryStruct.comp (adj.unit.app A) (G.map f))) (Eq (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app B)) f)","decl":"lemma eq_unit_comp_map_iff {A : C} {B : D} (f : F.obj A ⟶ B) (g : A ⟶ G.obj B) :\n    g = adj.unit.app A ≫ G.map f ↔ F.map g ≫ adj.counit.app B = f :=\n  ⟨fun h => by simp [h], fun h => by simp [← h]⟩\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_apply_eq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n⊢ Iff (Eq ((adj.homEquiv A B) f) g) (Eq f ((adj.homEquiv A B).symm g))","decl":"theorem homEquiv_apply_eq {A : C} {B : D} (f : F.obj A ⟶ B) (g : A ⟶ G.obj B) :\n    adj.homEquiv A B f = g ↔ f = (adj.homEquiv A B).symm g :=\n  unit_comp_map_eq_iff adj f g\n\n"}
{"name":"CategoryTheory.Adjunction.eq_homEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n⊢ Iff (Eq g ((adj.homEquiv A B) f)) (Eq ((adj.homEquiv A B).symm g) f)","decl":"theorem eq_homEquiv_apply {A : C} {B : D} (f : F.obj A ⟶ B) (g : A ⟶ G.obj B) :\n    g = adj.homEquiv A B f ↔ (adj.homEquiv A B).symm g = f :=\n  eq_unit_comp_map_iff adj f g\n\n"}
{"name":"CategoryTheory.Adjunction.corepresentableBy_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY✝ : D\n⊢ Eq (adj.corepresentableBy X).homEquiv (adj.homEquiv X Y✝)","decl":"/--  If `adj : F ⊣ G`, and `X : C`, then `F.obj X` corepresents `Y ↦ (X ⟶ G.obj Y)`-/\n@[simps]\ndef corepresentableBy (X : C) :\n    (G ⋙ coyoneda.obj (Opposite.op X)).CorepresentableBy (F.obj X) where\n  homEquiv := adj.homEquiv _ _\n  homEquiv_comp := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.representableBy_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nY : D\nX✝ : C\n⊢ Eq (adj.representableBy Y).homEquiv (adj.homEquiv X✝ Y).symm","decl":"/--  If `adj : F ⊣ G`, and `Y : D`, then `G.obj Y` represents `X ↦ (F.obj X ⟶ Y)`-/\n@[simps]\ndef representableBy (Y : D) :\n    (F.op ⋙ yoneda.obj Y).RepresentableBy (G.obj Y) where\n  homEquiv := (adj.homEquiv _ _).symm\n  homEquiv_comp := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (∀ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto✝\nhomEquiv_counit : autoParam (∀ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto✝\n⊢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F ⋙ G\n  /-- The counit of an adjunction -/\n  counit : G ⋙ F ⟶ 𝟭 D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ∀ {X Y f}, (homEquiv X Y) f = unit.app X ≫ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ∀ {X Y g}, (homEquiv X Y).symm g = F.map g ≫ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv✝ : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit✝ : autoParam (∀ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv✝ X Y) f) (CategoryTheory.CategoryStruct.comp (unit✝.app X) (G.map f))) _auto✝\nhomEquiv_counit✝ : autoParam (∀ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv✝ X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit✝.app Y))) _auto✝\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (∀ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto✝\nhomEquiv_counit : autoParam (∀ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto✝\n⊢ Eq (Eq { homEquiv := homEquiv✝, unit := unit✝, counit := counit✝, homEquiv_unit := homEquiv_unit✝, homEquiv_counit := homEquiv_counit✝ } { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }) (And (Eq homEquiv✝ homEquiv) (And (Eq unit✝ unit) (Eq counit✝ counit)))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F ⋙ G\n  /-- The counit of an adjunction -/\n  counit : G ⋙ F ⟶ 𝟭 D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ∀ {X Y f}, (homEquiv X Y) f = unit.app X ≫ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ∀ {X Y g}, (homEquiv X Y).symm g = F.map g ≫ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.homEquiv_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((self.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (self.unit.app X) (G.map f))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F ⋙ G\n  /-- The counit of an adjunction -/\n  counit : G ⋙ F ⟶ 𝟭 D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ∀ {X Y f}, (homEquiv X Y) f = unit.app X ≫ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ∀ {X Y g}, (homEquiv X Y).symm g = F.map g ≫ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.homEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n⊢ Eq ((self.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (self.counit.app Y))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F ⋙ G\n  /-- The counit of an adjunction -/\n  counit : G ⋙ F ⟶ 𝟭 D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ∀ {X Y f}, (homEquiv X Y) f = unit.app X ≫ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ∀ {X Y g}, (homEquiv X Y).symm g = F.map g ≫ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv✝ : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit✝ : autoParam (∀ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv✝ X Y) f) (CategoryTheory.CategoryStruct.comp (unit✝.app X) (G.map f))) _auto✝\nhomEquiv_counit✝ : autoParam (∀ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv✝ X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit✝.app Y))) _auto✝\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (∀ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto✝\nhomEquiv_counit : autoParam (∀ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto✝\nx✝ : Eq { homEquiv := homEquiv✝, unit := unit✝, counit := counit✝, homEquiv_unit := homEquiv_unit✝, homEquiv_counit := homEquiv_counit✝ } { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }\n⊢ And (Eq homEquiv✝ homEquiv) (And (Eq unit✝ unit) (Eq counit✝ counit))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : 𝟭 C ⟶ F ⋙ G\n  /-- The counit of an adjunction -/\n  counit : G ⋙ F ⟶ 𝟭 D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ∀ {X Y f}, (homEquiv X Y) f = unit.app X ≫ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ∀ {X Y g}, (homEquiv X Y).symm g = F.map g ≫ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\nY Y' : D\nf : Quiver.Hom (F.obj X) Y\ng : Quiver.Hom Y Y'\n⊢ Eq ((self.homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((self.homEquiv X Y) f) (G.map g))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ⟶ X ⟶ G Y` -/\n  homEquiv_naturality_left_symm :\n    ∀ {X' X Y} (f : X' ⟶ X) (g : X ⟶ G.obj Y),\n      (homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ⟶ Y ⟶ Y'` -/\n  homEquiv_naturality_right :\n    ∀ {X Y Y'} (f : F.obj X ⟶ Y) (g : Y ⟶ Y'),\n      (homEquiv X Y') (f ≫ g) = (homEquiv X Y) f ≫ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (∀ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto✝\nhomEquiv_naturality_right : autoParam (∀ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto✝\n⊢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }) 1","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ⟶ X ⟶ G Y` -/\n  homEquiv_naturality_left_symm :\n    ∀ {X' X Y} (f : X' ⟶ X) (g : X ⟶ G.obj Y),\n      (homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ⟶ Y ⟶ Y'` -/\n  homEquiv_naturality_right :\n    ∀ {X Y Y'} (f : F.obj X ⟶ Y) (g : Y ⟶ Y'),\n      (homEquiv X Y') (f ≫ g) = (homEquiv X Y) f ≫ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv✝ : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm✝ : autoParam (∀ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv✝ X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv✝ X Y).symm g))) _auto✝\nhomEquiv_naturality_right✝ : autoParam (∀ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv✝ X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv✝ X Y) f) (G.map g))) _auto✝\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (∀ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto✝\nhomEquiv_naturality_right : autoParam (∀ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto✝\n⊢ Eq (Eq { homEquiv := homEquiv✝, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm✝, homEquiv_naturality_right := homEquiv_naturality_right✝ } { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }) (Eq homEquiv✝ homEquiv)","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ⟶ X ⟶ G Y` -/\n  homEquiv_naturality_left_symm :\n    ∀ {X' X Y} (f : X' ⟶ X) (g : X ⟶ G.obj Y),\n      (homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ⟶ Y ⟶ Y'` -/\n  homEquiv_naturality_right :\n    ∀ {X Y Y'} (f : F.obj X ⟶ Y) (g : Y ⟶ Y'),\n      (homEquiv X Y') (f ≫ g) = (homEquiv X Y) f ≫ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv✝ : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm✝ : autoParam (∀ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv✝ X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv✝ X Y).symm g))) _auto✝\nhomEquiv_naturality_right✝ : autoParam (∀ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv✝ X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv✝ X Y) f) (G.map g))) _auto✝\nhomEquiv : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (∀ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto✝\nhomEquiv_naturality_right : autoParam (∀ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto✝\nx✝ : Eq { homEquiv := homEquiv✝, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm✝, homEquiv_naturality_right := homEquiv_naturality_right✝ } { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }\n⊢ Eq homEquiv✝ homEquiv","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ⟶ X ⟶ G Y` -/\n  homEquiv_naturality_left_symm :\n    ∀ {X' X Y} (f : X' ⟶ X) (g : X ⟶ G.obj Y),\n      (homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ⟶ Y ⟶ Y'` -/\n  homEquiv_naturality_right :\n    ∀ {X Y Y'} (f : F.obj X ⟶ Y) (g : Y ⟶ Y'),\n      (homEquiv X Y') (f ≫ g) = (homEquiv X Y) f ≫ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquiv F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y)\n⊢ Eq ((self.homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((self.homEquiv X Y).symm g))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ∀ X Y, (F.obj X ⟶ Y) ≃ (X ⟶ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ⟶ X ⟶ G Y` -/\n  homEquiv_naturality_left_symm :\n    ∀ {X' X Y} (f : X' ⟶ X) (g : X ⟶ G.obj Y),\n      (homEquiv X' Y).symm (f ≫ g) = F.map f ≫ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ⟶ Y ⟶ Y'` -/\n  homEquiv_naturality_right :\n    ∀ {X Y Y'} (f : F.obj X ⟶ Y) (g : Y ⟶ Y'),\n      (homEquiv X Y') (f ≫ g) = (homEquiv X Y) f ≫ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y\n⊢ Eq ((adj.homEquiv X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y) g))","decl":"theorem homEquiv_naturality_left (f : X' ⟶ X) (g : F.obj X ⟶ Y) :\n    (adj.homEquiv X' Y) (F.map f ≫ g) = f ≫ (adj.homEquiv X Y) g := by\n  rw [← Equiv.eq_symm_apply]; simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\nY Y' : D\nf : Quiver.Hom X (G.obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq ((adj.homEquiv X Y').symm (CategoryTheory.CategoryStruct.comp f (G.map g))) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y).symm f) g)","decl":"theorem homEquiv_naturality_right_symm (f : X ⟶ G.obj Y) (g : Y ⟶ Y') :\n    (adj.homEquiv X Y').symm (f ≫ G.map g) = (adj.homEquiv X Y).symm f ≫ g := by\n  rw [Equiv.symm_apply_eq]; simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.right_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreUnitCounit F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G self.unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight self.counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ⟶ (F G) F ⟶ F (G F) ⟶ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ≫ (Functor.associator F G F).hom ≫ whiskerLeft F counit =\n      NatTrans.id (𝟭 C ⋙ F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ⟶ G (F G) ⟶ (F G) F ⟶ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ≫ (Functor.associator G F G).inv ≫ whiskerRight counit G =\n      NatTrans.id (G ⋙ 𝟭 C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit✝ F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit✝))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto✝\nright_triangle✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit✝) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit✝ G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto✝\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto✝\n⊢ Eq (Eq { unit := unit✝, counit := counit✝, left_triangle := left_triangle✝, right_triangle := right_triangle✝ } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (And (Eq unit✝ unit) (Eq counit✝ counit))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ⟶ (F G) F ⟶ F (G F) ⟶ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ≫ (Functor.associator F G F).hom ≫ whiskerLeft F counit =\n      NatTrans.id (𝟭 C ⋙ F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ⟶ G (F G) ⟶ (F G) F ⟶ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ≫ (Functor.associator G F G).inv ≫ whiskerRight counit G =\n      NatTrans.id (G ⋙ 𝟭 C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.left_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreUnitCounit F G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight self.unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F self.counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ⟶ (F G) F ⟶ F (G F) ⟶ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ≫ (Functor.associator F G F).hom ≫ whiskerLeft F counit =\n      NatTrans.id (𝟭 C ⋙ F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ⟶ G (F G) ⟶ (F G) F ⟶ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ≫ (Functor.associator G F G).inv ≫ whiskerRight counit G =\n      NatTrans.id (G ⋙ 𝟭 C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit✝ : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit✝ : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit✝ F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit✝))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto✝\nright_triangle✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit✝) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit✝ G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto✝\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto✝\nx✝ : Eq { unit := unit✝, counit := counit✝, left_triangle := left_triangle✝, right_triangle := right_triangle✝ } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }\n⊢ And (Eq unit✝ unit) (Eq counit✝ counit)","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ⟶ (F G) F ⟶ F (G F) ⟶ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ≫ (Functor.associator F G F).hom ≫ whiskerLeft F counit =\n      NatTrans.id (𝟭 C ⋙ F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ⟶ G (F G) ⟶ (F G) F ⟶ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ≫ (Functor.associator G F G).inv ≫ whiskerRight counit G =\n      NatTrans.id (G ⋙ 𝟭 C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto✝\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto✝\n⊢ Eq (SizeOf.sizeOf { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf left_triangle)) (SizeOf.sizeOf right_triangle))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ⥤ D) (G : D ⥤ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : 𝟭 C ⟶ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ⟶ 𝟭 D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ⟶ (F G) F ⟶ F (G F) ⟶ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ≫ (Functor.associator F G F).hom ≫ whiskerLeft F counit =\n      NatTrans.id (𝟭 C ⋙ F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ⟶ G (F G) ⟶ (F G) F ⟶ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ≫ (Functor.associator G F G).inv ≫ whiskerRight counit G =\n      NatTrans.id (G ⋙ 𝟭 C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n⊢ Eq (CategoryTheory.Adjunction.mk' adj).unit adj.unit","decl":"/--\nConstruct an adjunction from the data of a `CoreHomEquivUnitCounit`, i.e. a hom set\nequivalence, unit and counit natural transformations together with proofs of the equalities\n`homEquiv_unit` and `homEquiv_counit` relating them to each other.\n-/\n@[simps]\ndef mk' (adj : CoreHomEquivUnitCounit F G) : F ⊣ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    rw [← adj.homEquiv_counit, (adj.homEquiv _ _).symm_apply_eq, adj.homEquiv_unit]\n    simp\n  right_triangle_components Y := by\n    rw [← adj.homEquiv_unit, ← (adj.homEquiv _ _).eq_symm_apply, adj.homEquiv_counit]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n⊢ Eq (CategoryTheory.Adjunction.mk' adj).counit adj.counit","decl":"/--\nConstruct an adjunction from the data of a `CoreHomEquivUnitCounit`, i.e. a hom set\nequivalence, unit and counit natural transformations together with proofs of the equalities\n`homEquiv_unit` and `homEquiv_counit` relating them to each other.\n-/\n@[simps]\ndef mk' (adj : CoreHomEquivUnitCounit F G) : F ⊣ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    rw [← adj.homEquiv_counit, (adj.homEquiv _ _).symm_apply_eq, adj.homEquiv_unit]\n    simp\n  right_triangle_components Y := by\n    rw [← adj.homEquiv_unit, ← (adj.homEquiv _ _).eq_symm_apply, adj.homEquiv_counit]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n⊢ Eq (CategoryTheory.Adjunction.mk' adj).homEquiv adj.homEquiv","decl":"lemma mk'_homEquiv (adj : CoreHomEquivUnitCounit F G) : (mk' adj).homEquiv = adj.homEquiv := by\n  ext\n  rw [homEquiv_unit, adj.homEquiv_unit, mk'_unit]\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nY : D\n⊢ Eq ((CategoryTheory.Adjunction.mkOfHomEquiv adj).counit.app Y) ((adj.homEquiv (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)))","decl":"/-- Construct an adjunction between `F` and `G` out of a natural bijection between each\n`F.obj X ⟶ Y` and `X ⟶ G.obj Y`. -/\n@[simps!]\ndef mkOfHomEquiv (adj : CoreHomEquiv F G) : F ⊣ G :=\n  mk' {\n    unit :=\n      { app := fun X => (adj.homEquiv X (F.obj X)) (𝟙 (F.obj X))\n        naturality := by\n          intros\n          simp [← adj.homEquiv_naturality_left, ← adj.homEquiv_naturality_right] }\n    counit :=\n      { app := fun Y => (adj.homEquiv _ _).invFun (𝟙 (G.obj Y))\n        naturality := by\n          intros\n          simp [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right_symm] }\n    homEquiv := adj.homEquiv\n    homEquiv_unit := fun {X Y f} => by simp [← adj.homEquiv_naturality_right]\n    homEquiv_counit := fun {X Y f} => by simp [← adj.homEquiv_naturality_left_symm] }\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\n⊢ Eq ((CategoryTheory.Adjunction.mkOfHomEquiv adj).unit.app X) ((adj.homEquiv X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X)))","decl":"/-- Construct an adjunction between `F` and `G` out of a natural bijection between each\n`F.obj X ⟶ Y` and `X ⟶ G.obj Y`. -/\n@[simps!]\ndef mkOfHomEquiv (adj : CoreHomEquiv F G) : F ⊣ G :=\n  mk' {\n    unit :=\n      { app := fun X => (adj.homEquiv X (F.obj X)) (𝟙 (F.obj X))\n        naturality := by\n          intros\n          simp [← adj.homEquiv_naturality_left, ← adj.homEquiv_naturality_right] }\n    counit :=\n      { app := fun Y => (adj.homEquiv _ _).invFun (𝟙 (G.obj Y))\n        naturality := by\n          intros\n          simp [← adj.homEquiv_naturality_left_symm, ← adj.homEquiv_naturality_right_symm] }\n    homEquiv := adj.homEquiv\n    homEquiv_unit := fun {X Y f} => by simp [← adj.homEquiv_naturality_right]\n    homEquiv_counit := fun {X Y f} => by simp [← adj.homEquiv_naturality_left_symm] }\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\n⊢ Eq (CategoryTheory.Adjunction.mkOfHomEquiv adj).homEquiv adj.homEquiv","decl":"@[simp]\nlemma mkOfHomEquiv_homEquiv (adj : CoreHomEquiv F G) :\n    (mkOfHomEquiv adj).homEquiv = adj.homEquiv := by\n  ext X Y g\n  simp [mkOfHomEquiv, ← adj.homEquiv_naturality_right (𝟙 _) g]\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfUnitCounit_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreUnitCounit F G\n⊢ Eq (CategoryTheory.Adjunction.mkOfUnitCounit adj).unit adj.unit","decl":"/-- Construct an adjunction between functors `F` and `G` given a unit and counit for the adjunction\nsatisfying the triangle identities. -/\n@[simps!]\ndef mkOfUnitCounit (adj : CoreUnitCounit F G) : F ⊣ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    have := adj.left_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.left_triangle] using this X\n  right_triangle_components Y := by\n    have := adj.right_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.right_triangle] using this Y\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfUnitCounit_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreUnitCounit F G\n⊢ Eq (CategoryTheory.Adjunction.mkOfUnitCounit adj).counit adj.counit","decl":"/-- Construct an adjunction between functors `F` and `G` given a unit and counit for the adjunction\nsatisfying the triangle identities. -/\n@[simps!]\ndef mkOfUnitCounit (adj : CoreUnitCounit F G) : F ⊣ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    have := adj.left_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.left_triangle] using this X\n  right_triangle_components Y := by\n    have := adj.right_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.right_triangle] using this Y\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetLeftOfNatIso_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\niso : CategoryTheory.Iso F F'\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n⊢ Eq ((CategoryTheory.Adjunction.equivHomsetLeftOfNatIso iso) f) (CategoryTheory.CategoryStruct.comp (iso.inv.app X) f)","decl":"/-- If F and G are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetLeftOfNatIso {F F' : C ⥤ D} (iso : F ≅ F') {X : C} {Y : D} :\n    (F.obj X ⟶ Y) ≃ (F'.obj X ⟶ Y) where\n  toFun f := iso.inv.app _ ≫ f\n  invFun g := iso.hom.app _ ≫ g\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetLeftOfNatIso_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF F' : CategoryTheory.Functor C D\niso : CategoryTheory.Iso F F'\nX : C\nY : D\ng : Quiver.Hom (F'.obj X) Y\n⊢ Eq ((CategoryTheory.Adjunction.equivHomsetLeftOfNatIso iso).symm g) (CategoryTheory.CategoryStruct.comp (iso.hom.app X) g)","decl":"/-- If F and G are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetLeftOfNatIso {F F' : C ⥤ D} (iso : F ≅ F') {X : C} {Y : D} :\n    (F.obj X ⟶ Y) ≃ (F'.obj X ⟶ Y) where\n  toFun f := iso.inv.app _ ≫ f\n  invFun g := iso.hom.app _ ≫ g\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetRightOfNatIso_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG G' : CategoryTheory.Functor D C\niso : CategoryTheory.Iso G G'\nX : C\nY : D\ng : Quiver.Hom X (G'.obj Y)\n⊢ Eq ((CategoryTheory.Adjunction.equivHomsetRightOfNatIso iso).symm g) (CategoryTheory.CategoryStruct.comp g (iso.inv.app Y))","decl":"/-- If G and H are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetRightOfNatIso {G G' : D ⥤ C} (iso : G ≅ G') {X : C} {Y : D} :\n    (X ⟶ G.obj Y) ≃ (X ⟶ G'.obj Y) where\n  toFun f := f ≫ iso.hom.app _\n  invFun g := g ≫ iso.inv.app _\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetRightOfNatIso_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG G' : CategoryTheory.Functor D C\niso : CategoryTheory.Iso G G'\nX : C\nY : D\nf : Quiver.Hom X (G.obj Y)\n⊢ Eq ((CategoryTheory.Adjunction.equivHomsetRightOfNatIso iso) f) (CategoryTheory.CategoryStruct.comp f (iso.hom.app Y))","decl":"/-- If G and H are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetRightOfNatIso {G G' : D ⥤ C} (iso : G ≅ G') {X : C} {Y : D} :\n    (X ⟶ G.obj Y) ≃ (X ⟶ G'.obj Y) where\n  toFun f := f ≫ iso.hom.app _\n  invFun g := g ≫ iso.inv.app _\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.compYonedaIso_inv_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX✝ : D\nX : Opposite C\na✝ : ((CategoryTheory.yoneda.comp ((CategoryTheory.whiskeringLeft (Opposite C) (Opposite D) (Type v₁)).obj F.op)).obj X✝).obj X\n⊢ Eq ((adj.compYonedaIso.inv.app X✝).app X a✝) (CategoryTheory.CategoryStruct.comp (adj.unit.app (Opposite.unop X)) (G.map a✝))","decl":"/-- The isomorpism which an adjunction `F ⊣ G` induces on `G ⋙ yoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compYonedaIso {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₁} D]\n    {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    G ⋙ yoneda ≅ yoneda ⋙ (whiskeringLeft _ _ _).obj F.op :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv Y.unop X).toIso.symm\n\n"}
{"name":"CategoryTheory.Adjunction.compYonedaIso_hom_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX✝ : D\nX : Opposite C\na✝ : ((G.comp CategoryTheory.yoneda).obj X✝).obj X\n⊢ Eq ((adj.compYonedaIso.hom.app X✝).app X a✝) (CategoryTheory.CategoryStruct.comp (F.map a✝) (adj.counit.app X✝))","decl":"/-- The isomorpism which an adjunction `F ⊣ G` induces on `G ⋙ yoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compYonedaIso {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₁} D]\n    {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    G ⋙ yoneda ≅ yoneda ⋙ (whiskeringLeft _ _ _).obj F.op :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv Y.unop X).toIso.symm\n\n"}
{"name":"CategoryTheory.Adjunction.compCoyonedaIso_inv_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX✝ : Opposite C\nX : D\na✝ : ((CategoryTheory.coyoneda.comp ((CategoryTheory.whiskeringLeft D C (Type v₁)).obj G)).obj X✝).obj X\n⊢ Eq ((adj.compCoyonedaIso.inv.app X✝).app X a✝) (CategoryTheory.CategoryStruct.comp (F.map a✝) (adj.counit.app X))","decl":"/-- The isomorpism which an adjunction `F ⊣ G` induces on `F.op ⋙ coyoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compCoyonedaIso {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₁} D]\n    {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    F.op ⋙ coyoneda ≅ coyoneda ⋙ (whiskeringLeft _ _ _).obj G :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv X.unop Y).toIso\n\n"}
{"name":"CategoryTheory.Adjunction.compCoyonedaIso_hom_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX✝ : Opposite C\nX : D\na✝ : ((F.op.comp CategoryTheory.coyoneda).obj X✝).obj X\n⊢ Eq ((adj.compCoyonedaIso.hom.app X✝).app X a✝) (CategoryTheory.CategoryStruct.comp (adj.unit.app (Opposite.unop X✝)) (G.map a✝))","decl":"/-- The isomorpism which an adjunction `F ⊣ G` induces on `F.op ⋙ coyoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compCoyonedaIso {C : Type u₁} [Category.{v₁} C] {D : Type u₂} [Category.{v₁} D]\n    {F : C ⥤ D} {G : D ⥤ C} (adj : F ⊣ G) :\n    F.op ⋙ coyoneda ≅ coyoneda ⋙ (whiskeringLeft _ _ _).obj G :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv X.unop Y).toIso\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\n⊢ Eq (adj₁.comp adj₂).unit (CategoryTheory.CategoryStruct.comp adj₁.unit (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight F.rightUnitor.inv G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft F adj₂.unit) G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (F.associator H I).inv G) ((F.comp H).associator I G).hom))))","decl":"/-- Composition of adjunctions. -/\n@[simps! (config := .lemmasOnly) unit counit, stacks 0DV0]\ndef comp : F ⋙ H ⊣ I ⋙ G :=\n  mk' {\n    homEquiv := fun _ _ ↦ Equiv.trans (adj₂.homEquiv _ _) (adj₁.homEquiv _ _)\n    unit := adj₁.unit ≫ whiskerRight (F.rightUnitor.inv ≫ whiskerLeft F adj₂.unit ≫\n      (Functor.associator _ _ _ ).inv) G ≫ (Functor.associator _ _ _).hom\n    counit := (Functor.associator _ _ _ ).inv ≫ whiskerRight ((Functor.associator _ _ _ ).hom ≫\n      whiskerLeft _ adj₁.counit ≫ I.rightUnitor.hom) _ ≫ adj₂.counit }\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\n⊢ Eq (adj₁.comp adj₂).counit (CategoryTheory.CategoryStruct.comp ((I.comp G).associator F H).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (I.associator G F).hom H) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft I adj₁.counit) H) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight I.rightUnitor.hom H) adj₂.counit))))","decl":"/-- Composition of adjunctions. -/\n@[simps! (config := .lemmasOnly) unit counit, stacks 0DV0]\ndef comp : F ⋙ H ⊣ I ⋙ G :=\n  mk' {\n    homEquiv := fun _ _ ↦ Equiv.trans (adj₂.homEquiv _ _) (adj₁.homEquiv _ _)\n    unit := adj₁.unit ≫ whiskerRight (F.rightUnitor.inv ≫ whiskerLeft F adj₂.unit ≫\n      (Functor.associator _ _ _ ).inv) G ≫ (Functor.associator _ _ _).hom\n    counit := (Functor.associator _ _ _ ).inv ≫ whiskerRight ((Functor.associator _ _ _ ).hom ≫\n      whiskerLeft _ adj₁.counit ≫ I.rightUnitor.hom) _ ≫ adj₂.counit }\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\nX Z : C\nh : Quiver.Hom (G.obj (I.obj (H.obj (F.obj X)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((adj₁.comp adj₂).unit.app X) h) (CategoryTheory.CategoryStruct.comp (adj₁.unit.app X) (CategoryTheory.CategoryStruct.comp (G.map (adj₂.unit.app (F.obj X))) h))","decl":"@[simp, reassoc]\nlemma comp_unit_app (X : C) :\n    (adj₁.comp adj₂).unit.app X = adj₁.unit.app X ≫ G.map (adj₂.unit.app (F.obj X)) := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\nX : C\n⊢ Eq ((adj₁.comp adj₂).unit.app X) (CategoryTheory.CategoryStruct.comp (adj₁.unit.app X) (G.map (adj₂.unit.app (F.obj X))))","decl":"@[simp, reassoc]\nlemma comp_unit_app (X : C) :\n    (adj₁.comp adj₂).unit.app X = adj₁.unit.app X ≫ G.map (adj₂.unit.app (F.obj X)) := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\nX Z : E\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((adj₁.comp adj₂).counit.app X) h) (CategoryTheory.CategoryStruct.comp (H.map (adj₁.counit.app (I.obj X))) (CategoryTheory.CategoryStruct.comp (adj₂.counit.app X) h))","decl":"@[simp, reassoc]\nlemma comp_counit_app (X : E) :\n    (adj₁.comp adj₂).counit.app X = H.map (adj₁.counit.app (I.obj X)) ≫ adj₂.counit.app X := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\nX : E\n⊢ Eq ((adj₁.comp adj₂).counit.app X) (CategoryTheory.CategoryStruct.comp (H.map (adj₁.counit.app (I.obj X))) (adj₂.counit.app X))","decl":"@[simp, reassoc]\nlemma comp_counit_app (X : E) :\n    (adj₁.comp adj₂).counit.app X = H.map (adj₁.counit.app (I.obj X)) ≫ adj₂.counit.app X := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u₃\nℰ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj₁ : CategoryTheory.Adjunction F G\nadj₂ : CategoryTheory.Adjunction H I\n⊢ Eq (adj₁.comp adj₂).homEquiv fun x x_1 => (adj₂.homEquiv (F.obj x) x_1).trans (adj₁.homEquiv x (I.obj x_1))","decl":"lemma comp_homEquiv :  (adj₁.comp adj₂).homEquiv =\n    fun _ _ ↦ Equiv.trans (adj₂.homEquiv _ _) (adj₁.homEquiv _ _) :=\n  mk'_homEquiv _\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointOfEquiv_obj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\nF_obj : C → D\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ∀ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\na✝ : C\n⊢ Eq ((CategoryTheory.Adjunction.leftAdjointOfEquiv e he).obj a✝) (F_obj a✝)","decl":"/-- Construct a left adjoint functor to `G`, given the functor's value on objects `F_obj` and\na bijection `e` between `F_obj X ⟶ Y` and `X ⟶ G.obj Y` satisfying a naturality law\n`he : ∀ X Y Y' g h, e X Y' (h ≫ g) = e X Y h ≫ G.map g`.\nDual to `rightAdjointOfEquiv`. -/\n@[simps!]\ndef leftAdjointOfEquiv (he : ∀ X Y Y' g h, e X Y' (h ≫ g) = e X Y h ≫ G.map g) : C ⥤ D where\n  obj := F_obj\n  map {X} {X'} f := (e X (F_obj X')).symm (f ≫ e X' (F_obj X') (𝟙 _))\n  map_comp := fun f f' => by\n    rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]\n    conv =>\n      rhs\n      rw [assoc, ← he, id_comp, Equiv.apply_symm_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointOfEquiv_map","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\nF_obj : C → D\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ∀ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nX X' : C\nf : Quiver.Hom X X'\n⊢ Eq ((CategoryTheory.Adjunction.leftAdjointOfEquiv e he).map f) ((e X (F_obj X')).symm (CategoryTheory.CategoryStruct.comp f ((e X' (F_obj X')) (CategoryTheory.CategoryStruct.id (F_obj X')))))","decl":"/-- Construct a left adjoint functor to `G`, given the functor's value on objects `F_obj` and\na bijection `e` between `F_obj X ⟶ Y` and `X ⟶ G.obj Y` satisfying a naturality law\n`he : ∀ X Y Y' g h, e X Y' (h ≫ g) = e X Y h ≫ G.map g`.\nDual to `rightAdjointOfEquiv`. -/\n@[simps!]\ndef leftAdjointOfEquiv (he : ∀ X Y Y' g h, e X Y' (h ≫ g) = e X Y h ≫ G.map g) : C ⥤ D where\n  obj := F_obj\n  map {X} {X'} f := (e X (F_obj X')).symm (f ≫ e X' (F_obj X') (𝟙 _))\n  map_comp := fun f f' => by\n    rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]\n    conv =>\n      rhs\n      rw [assoc, ← he, id_comp, Equiv.apply_symm_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivLeft_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\nF_obj : C → D\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ∀ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nY : D\n⊢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivLeft e he).counit.app Y) ((e (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)))","decl":"/-- Show that the functor given by `leftAdjointOfEquiv` is indeed left adjoint to `G`. Dual\nto `adjunctionOfRightEquiv`. -/\n@[simps!]\ndef adjunctionOfEquivLeft : leftAdjointOfEquiv e he ⊣ G :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := fun {X'} {X} {Y} f g => by\n        have {X : C} {Y Y' : D} (f : X ⟶ G.obj Y) (g : Y ⟶ Y') :\n            (e X Y').symm (f ≫ G.map g) = (e X Y).symm f ≫ g := by\n          rw [Equiv.symm_apply_eq, he]; simp\n        simp [← this, ← Equiv.apply_eq_iff_eq (e X' Y), ← he] }\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivLeft_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor D C\nF_obj : C → D\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ∀ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nX : C\n⊢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivLeft e he).unit.app X) ((e X (F_obj X)) (CategoryTheory.CategoryStruct.id (F_obj X)))","decl":"/-- Show that the functor given by `leftAdjointOfEquiv` is indeed left adjoint to `G`. Dual\nto `adjunctionOfRightEquiv`. -/\n@[simps!]\ndef adjunctionOfEquivLeft : leftAdjointOfEquiv e he ⊣ G :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := fun {X'} {X} {Y} f g => by\n        have {X : C} {Y Y' : D} (f : X ⟶ G.obj Y) (g : Y ⟶ Y') :\n            (e X Y').symm (f ≫ G.map g) = (e X Y).symm f ≫ g := by\n          rw [Equiv.symm_apply_eq, he]; simp\n        simp [← this, ← Equiv.apply_eq_iff_eq (e X' Y), ← he] }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointOfEquiv_obj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG_obj : D → C\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ∀ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\na✝ : D\n⊢ Eq ((CategoryTheory.Adjunction.rightAdjointOfEquiv e he).obj a✝) (G_obj a✝)","decl":"/-- Construct a right adjoint functor to `F`, given the functor's value on objects `G_obj` and\na bijection `e` between `F.obj X ⟶ Y` and `X ⟶ G_obj Y` satisfying a naturality law\n`he : ∀ X Y Y' g h, e X' Y (F.map f ≫ g) = f ≫ e X Y g`.\nDual to `leftAdjointOfEquiv`. -/\n@[simps!]\ndef rightAdjointOfEquiv (he : ∀ X' X Y f g, e X' Y (F.map f ≫ g) = f ≫ e X Y g) : D ⥤ C where\n  obj := G_obj\n  map {Y} {Y'} g := (e (G_obj Y) Y') ((e (G_obj Y) Y).symm (𝟙 _) ≫ g)\n  map_comp := fun {Y} {Y'} {Y''} g g' => by\n    rw [← Equiv.eq_symm_apply, ← he'' e he, Equiv.symm_apply_apply]\n    conv =>\n      rhs\n      rw [← assoc, he'' e he, comp_id, Equiv.symm_apply_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointOfEquiv_map","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG_obj : D → C\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ∀ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nY Y' : D\ng : Quiver.Hom Y Y'\n⊢ Eq ((CategoryTheory.Adjunction.rightAdjointOfEquiv e he).map g) ((e (G_obj Y) Y') (CategoryTheory.CategoryStruct.comp ((e (G_obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G_obj Y))) g))","decl":"/-- Construct a right adjoint functor to `F`, given the functor's value on objects `G_obj` and\na bijection `e` between `F.obj X ⟶ Y` and `X ⟶ G_obj Y` satisfying a naturality law\n`he : ∀ X Y Y' g h, e X' Y (F.map f ≫ g) = f ≫ e X Y g`.\nDual to `leftAdjointOfEquiv`. -/\n@[simps!]\ndef rightAdjointOfEquiv (he : ∀ X' X Y f g, e X' Y (F.map f ≫ g) = f ≫ e X Y g) : D ⥤ C where\n  obj := G_obj\n  map {Y} {Y'} g := (e (G_obj Y) Y') ((e (G_obj Y) Y).symm (𝟙 _) ≫ g)\n  map_comp := fun {Y} {Y'} {Y''} g g' => by\n    rw [← Equiv.eq_symm_apply, ← he'' e he, Equiv.symm_apply_apply]\n    conv =>\n      rhs\n      rw [← assoc, he'' e he, comp_id, Equiv.symm_apply_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivRight_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG_obj : D → C\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ∀ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nX : C\n⊢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivRight e he).unit.app X) ((e X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X)))","decl":"/-- Show that the functor given by `rightAdjointOfEquiv` is indeed right adjoint to `F`. Dual\nto `adjunctionOfEquivRight`. -/\n@[simps!]\ndef adjunctionOfEquivRight (he : ∀ X' X Y f g, e X' Y (F.map f ≫ g) = f ≫ e X Y g) :\n    F ⊣ (rightAdjointOfEquiv e he) :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := by\n        intro X X' Y f g; rw [Equiv.symm_apply_eq]; simp [he]\n      homEquiv_naturality_right := by\n        intro X Y Y' g h\n        simp [← he, reassoc_of% (he'' e)] }\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivRight_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG_obj : D → C\ne : (X : C) → (Y : D) → Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ∀ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nY : D\n⊢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivRight e he).counit.app Y) ((e (G_obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G_obj Y)))","decl":"/-- Show that the functor given by `rightAdjointOfEquiv` is indeed right adjoint to `F`. Dual\nto `adjunctionOfEquivRight`. -/\n@[simps!]\ndef adjunctionOfEquivRight (he : ∀ X' X Y f g, e X' Y (F.map f ≫ g) = f ≫ e X Y g) :\n    F ⊣ (rightAdjointOfEquiv e he) :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := by\n        intro X X' Y f g; rw [Equiv.symm_apply_eq]; simp [he]\n      homEquiv_naturality_right := by\n        intro X Y Y' g h\n        simp [← he, reassoc_of% (he'' e)] }\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : D\n⊢ Eq (adj.toEquivalence.counitIso.inv.app X) (CategoryTheory.inv (adj.counit.app X))","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\n⊢ Eq adj.toEquivalence.inverse G","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_unitIso_hom_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : C\n⊢ Eq (adj.toEquivalence.unitIso.hom.app X) (adj.unit.app X)","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_unitIso_inv_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : C\n⊢ Eq (adj.toEquivalence.unitIso.inv.app X) (CategoryTheory.inv (adj.unit.app X))","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : D\n⊢ Eq (adj.toEquivalence.counitIso.hom.app X) (adj.counit.app X)","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : ∀ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst✝ : ∀ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\n⊢ Eq adj.toEquivalence.functor F","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ⊣ G) [∀ X, IsIso (adj.unit.app X)]\n    [∀ Y, IsIso (adj.counit.app Y)] : C ≌ D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝² : G.IsRightAdjoint\ninst✝¹ : ∀ (X : D), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).unit.app X)\ninst✝ : ∀ (Y : C), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).counit.app Y)\n⊢ G.IsEquivalence","decl":"/--\nIf the unit and counit for the adjunction corresponding to a right adjoint functor are (pointwise)\nisomorphisms, then the functor is an equivalence of categories.\n-/\nlemma Functor.isEquivalence_of_isRightAdjoint (G : C ⥤ D) [IsRightAdjoint G]\n    [∀ X, IsIso ((Adjunction.ofIsRightAdjoint G).unit.app X)]\n    [∀ Y, IsIso ((Adjunction.ofIsRightAdjoint G).counit.app Y)] : G.IsEquivalence :=\n  (Adjunction.ofIsRightAdjoint G).toEquivalence.isEquivalence_inverse\n\n"}
{"name":"CategoryTheory.Equivalence.toAdjunction_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq e.toAdjunction.unit e.unit","decl":"/-- The adjunction given by an equivalence of categories. (To obtain the opposite adjunction,\nsimply use `e.symm.toAdjunction`. -/\n@[simps]\ndef toAdjunction : e.functor ⊣ e.inverse where\n  unit := e.unit\n  counit := e.counit\n\n"}
{"name":"CategoryTheory.Equivalence.toAdjunction_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ Eq e.toAdjunction.counit e.counit","decl":"/-- The adjunction given by an equivalence of categories. (To obtain the opposite adjunction,\nsimply use `e.symm.toAdjunction`. -/\n@[simps]\ndef toAdjunction : e.functor ⊣ e.inverse where\n  unit := e.unit\n  counit := e.counit\n\n"}
{"name":"CategoryTheory.Equivalence.isLeftAdjoint_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ e.functor.IsLeftAdjoint","decl":"lemma isLeftAdjoint_functor : e.functor.IsLeftAdjoint where\n  exists_rightAdjoint := ⟨_, ⟨e.toAdjunction⟩⟩\n\n"}
{"name":"CategoryTheory.Equivalence.isRightAdjoint_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ e.inverse.IsRightAdjoint","decl":"lemma isRightAdjoint_inverse : e.inverse.IsRightAdjoint where\n  exists_leftAdjoint := ⟨_, ⟨e.toAdjunction⟩⟩\n\n"}
{"name":"CategoryTheory.Equivalence.isLeftAdjoint_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ e.inverse.IsLeftAdjoint","decl":"lemma isLeftAdjoint_inverse : e.inverse.IsLeftAdjoint :=\n  e.symm.isLeftAdjoint_functor\n\n"}
{"name":"CategoryTheory.Equivalence.isRightAdjoint_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\n⊢ e.functor.IsRightAdjoint","decl":"lemma isRightAdjoint_functor : e.functor.IsRightAdjoint :=\n  e.symm.isRightAdjoint_inverse\n\n"}
{"name":"CategoryTheory.Equivalence.refl_toAdjunction","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.Equivalence.refl.toAdjunction CategoryTheory.Adjunction.id","decl":"lemma refl_toAdjunction : (refl (C := C)).toAdjunction = Adjunction.id := rfl\n\n"}
{"name":"CategoryTheory.Equivalence.trans_toAdjunction","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nE : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} E\ne' : CategoryTheory.Equivalence D E\n⊢ Eq (e.trans e').toAdjunction (e.toAdjunction.comp e'.toAdjunction)","decl":"lemma trans_toAdjunction {E : Type*} [Category E] (e' : D ≌ E) :\n    (e.trans e').toAdjunction = e.toAdjunction.comp e'.toAdjunction := rfl\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_comp","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsLeftAdjoint\ninst✝ : G.IsLeftAdjoint\n⊢ (F.comp G).IsLeftAdjoint","decl":"/-- If `F` and `G` are left adjoints then `F ⋙ G` is a left adjoint too. -/\ninstance isLeftAdjoint_comp {E : Type u₃} [Category.{v₃} E] (F : C ⥤ D) (G : D ⥤ E)\n    [F.IsLeftAdjoint] [G.IsLeftAdjoint] : (F ⋙ G).IsLeftAdjoint where\n  exists_rightAdjoint :=\n    ⟨_, ⟨(Adjunction.ofIsLeftAdjoint F).comp (Adjunction.ofIsLeftAdjoint G)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_comp","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.IsRightAdjoint\ninst✝ : G.IsRightAdjoint\n⊢ (F.comp G).IsRightAdjoint","decl":"/-- If `F` and `G` are right adjoints then `F ⋙ G` is a right adjoint too. -/\ninstance isRightAdjoint_comp {E : Type u₃} [Category.{v₃} E] {F : C ⥤ D} {G : D ⥤ E}\n    [IsRightAdjoint F] [IsRightAdjoint G] : IsRightAdjoint (F ⋙ G) where\n  exists_leftAdjoint :=\n    ⟨_, ⟨(Adjunction.ofIsRightAdjoint G).comp (Adjunction.ofIsRightAdjoint F)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst✝ : F.IsRightAdjoint\n⊢ G.IsRightAdjoint","decl":"/-- Transport being a right adjoint along a natural isomorphism. -/\nlemma isRightAdjoint_of_iso {F G : C ⥤ D} (h : F ≅ G) [F.IsRightAdjoint] :\n    IsRightAdjoint G where\n  exists_leftAdjoint := ⟨_, ⟨(Adjunction.ofIsRightAdjoint F).ofNatIsoRight h⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst✝ : F.IsLeftAdjoint\n⊢ G.IsLeftAdjoint","decl":"/-- Transport being a left adjoint along a natural isomorphism. -/\nlemma isLeftAdjoint_of_iso {F G : C ⥤ D} (h : F ≅ G) [IsLeftAdjoint F] :\n    IsLeftAdjoint G where\n  exists_rightAdjoint := ⟨_, ⟨(Adjunction.ofIsLeftAdjoint F).ofNatIsoLeft h⟩⟩\n\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ F.IsLeftAdjoint","decl":"/-- If `F` is an equivalence, it's a left adjoint. -/\ninstance (priority := 10) isLeftAdjoint_of_isEquivalence {F : C ⥤ D} [F.IsEquivalence] :\n    IsLeftAdjoint F :=\n  F.asEquivalence.isLeftAdjoint_functor\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ F.IsRightAdjoint","decl":"/-- If `F` is an equivalence, it's a right adjoint. -/\ninstance (priority := 10) isRightAdjoint_of_isEquivalence {F : C ⥤ D} [F.IsEquivalence] :\n    IsRightAdjoint F :=\n  F.asEquivalence.isRightAdjoint_functor\n\n"}
