{"name":"CategoryTheory.Adjunction.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto‚úù\nright_triangle_components : autoParam (‚àÄ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit))","decl":"/-- `F ‚ä£ G` represents the data of an adjunction between two functors\n`F : C ‚•§ D` and `G : D ‚•§ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit and counit with the identity `F ‚ü∂ FGF ‚ü∂ F = ùüô` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ‚â´ counit.app (F.obj X) = ùüô (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ‚ü∂ GFG ‚ü∂ G = ùüô` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit‚úù.app X)) (counit‚úù.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto‚úù\nright_triangle_components‚úù : autoParam (‚àÄ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit‚úù.app (G.obj Y)) (G.map (counit‚úù.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto‚úù\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto‚úù\nright_triangle_components : autoParam (‚àÄ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto‚úù\n‚ä¢ Eq (Eq { unit := unit‚úù, counit := counit‚úù, left_triangle_components := left_triangle_components‚úù, right_triangle_components := right_triangle_components‚úù } { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }) (And (Eq unit‚úù unit) (Eq counit‚úù counit))","decl":"/-- `F ‚ä£ G` represents the data of an adjunction between two functors\n`F : C ‚•§ D` and `G : D ‚•§ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit and counit with the identity `F ‚ü∂ FGF ‚ü∂ F = ùüô` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ‚â´ counit.app (F.obj X) = ùüô (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ‚ü∂ GFG ‚ü∂ G = ùüô` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle_components","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.unit.app (G.obj Y)) (G.map (self.counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))","decl":"/-- `F ‚ä£ G` represents the data of an adjunction between two functors\n`F : C ‚•§ D` and `G : D ‚•§ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit and counit with the identity `F ‚ü∂ FGF ‚ü∂ F = ùüô` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ‚â´ counit.app (F.obj X) = ùüô (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ‚ü∂ GFG ‚ü∂ G = ùüô` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit‚úù.app X)) (counit‚úù.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto‚úù\nright_triangle_components‚úù : autoParam (‚àÄ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit‚úù.app (G.obj Y)) (G.map (counit‚úù.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto‚úù\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle_components : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (F.map (unit.app X)) (counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))) _auto‚úù\nright_triangle_components : autoParam (‚àÄ (Y : D), Eq (CategoryTheory.CategoryStruct.comp (unit.app (G.obj Y)) (G.map (counit.app Y))) (CategoryTheory.CategoryStruct.id (G.obj Y))) _auto‚úù\nx‚úù : Eq { unit := unit‚úù, counit := counit‚úù, left_triangle_components := left_triangle_components‚úù, right_triangle_components := right_triangle_components‚úù } { unit := unit, counit := counit, left_triangle_components := left_triangle_components, right_triangle_components := right_triangle_components }\n‚ä¢ And (Eq unit‚úù unit) (Eq counit‚úù counit)","decl":"/-- `F ‚ä£ G` represents the data of an adjunction between two functors\n`F : C ‚•§ D` and `G : D ‚•§ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit and counit with the identity `F ‚ü∂ FGF ‚ü∂ F = ùüô` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ‚â´ counit.app (F.obj X) = ùüô (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ‚ü∂ GFG ‚ü∂ G = ùüô` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle_components","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (self.unit.app X)) (self.counit.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- `F ‚ä£ G` represents the data of an adjunction between two functors\n`F : C ‚•§ D` and `G : D ‚•§ C`. `F` is the left adjoint and `G` is the right adjoint.\n\nWe use the unit-counit definition of an adjunction. There is a constructor `Adjunction.mk'`\nwhich constructs an adjunction from the data of a hom set equivalence, a unit, and a counit,\ntogether with proofs of the equalities `homEquiv_unit` and `homEquiv_counit` relating them to each\nother.\n\nThere is also a constructor `Adjunction.mkOfHomEquiv` which constructs an adjunction from a natural\nhom set equivalence.\n\nTo construct adjoints to a given functor, there are constructors `leftAdjointOfEquiv` and\n`adjunctionOfEquivLeft` (as well as their duals). -/\n@[stacks 0037]\nstructure Adjunction (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit and counit with the identity `F ‚ü∂ FGF ‚ü∂ F = ùüô` -/\n  left_triangle_components (X : C) :\n      F.map (unit.app X) ‚â´ counit.app (F.obj X) = ùüô (F.obj X) := by aesop_cat\n  /-- Equality of the composition of the unit and counit with the identity `G ‚ü∂ GFG ‚ü∂ G = ùüô` -/\n  right_triangle_components (Y : D) :\n      unit.app (G.obj Y) ‚â´ G.map (counit.app Y) = ùüô (G.obj Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.IsLeftAdjoint.exists_rightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nleft : CategoryTheory.Functor C D\nself : left.IsLeftAdjoint\n‚ä¢ Exists fun right => Nonempty (CategoryTheory.Adjunction left right)","decl":"/-- A class asserting the existence of a right adjoint. -/\nclass IsLeftAdjoint (left : C ‚•§ D) : Prop where\n  exists_rightAdjoint : ‚àÉ (right : D ‚•§ C), Nonempty (left ‚ä£ right)\n\n"}
{"name":"CategoryTheory.Functor.IsRightAdjoint.exists_leftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nright : CategoryTheory.Functor D C\nself : right.IsRightAdjoint\n‚ä¢ Exists fun left => Nonempty (CategoryTheory.Adjunction left right)","decl":"/-- A class asserting the existence of a left adjoint. -/\nclass IsRightAdjoint (right : D ‚•§ C) : Prop where\n  exists_leftAdjoint : ‚àÉ (left : C ‚•§ D), Nonempty (left ‚ä£ right)\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle_components_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nY : D\nZ : C\nh : Quiver.Hom (G.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.unit.app (G.obj Y)) (CategoryTheory.CategoryStruct.comp (G.map (self.counit.app Y)) h)) h","decl":"attribute [reassoc (attr := simp)] left_triangle_components right_triangle_components\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle_components_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction F G\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (self.unit.app X)) (CategoryTheory.CategoryStruct.comp (self.counit.app (F.obj X)) h)) h","decl":"attribute [reassoc (attr := simp)] left_triangle_components right_triangle_components\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((adj.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app Y))","decl":"/-- The hom set equivalence associated to an adjunction. -/\n@[simps (config := .lemmasOnly)]\ndef homEquiv {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) (X : C) (Y : D) :\n    (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y) where\n  toFun := fun f => adj.unit.app X ‚â´ G.map f\n  invFun := fun g => F.map g ‚â´ adj.counit.app Y\n  left_inv := fun f => by\n    dsimp\n    rw [F.map_comp, assoc, ‚Üê Functor.comp_map, adj.counit.naturality, ‚Üê assoc]\n    simp\n  right_inv := fun g => by\n    simp only [Functor.comp_obj, Functor.map_comp]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, ‚Üê adj.unit.naturality]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((adj.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map f))","decl":"/-- The hom set equivalence associated to an adjunction. -/\n@[simps (config := .lemmasOnly)]\ndef homEquiv {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) (X : C) (Y : D) :\n    (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y) where\n  toFun := fun f => adj.unit.app X ‚â´ G.map f\n  invFun := fun g => F.map g ‚â´ adj.counit.app Y\n  left_inv := fun f => by\n    dsimp\n    rw [F.map_comp, assoc, ‚Üê Functor.comp_map, adj.counit.naturality, ‚Üê assoc]\n    simp\n  right_inv := fun g => by\n    simp only [Functor.comp_obj, Functor.map_comp]\n    rw [‚Üê assoc, ‚Üê Functor.comp_map, ‚Üê adj.unit.naturality]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((adj.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map f))","decl":"alias homEquiv_unit := homEquiv_apply\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((adj.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app Y))","decl":"alias homEquiv_counit := homEquiv_symm_apply\n\n"}
{"name":"CategoryTheory.Adjunction.ext_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj adj' : CategoryTheory.Adjunction F G\n‚ä¢ Iff (Eq adj adj') (Eq adj.unit adj'.unit)","decl":"@[ext]\nlemma ext {F : C ‚•§ D} {G : D ‚•§ C} {adj adj' : F ‚ä£ G}\n    (h : adj.unit = adj'.unit) : adj = adj' := by\n  suffices h' : adj.counit = adj'.counit by cases adj; cases adj'; aesop\n  ext X\n  apply (adj.homEquiv _ _).injective\n  rw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit,\n    Adjunction.right_triangle_components, h, Adjunction.right_triangle_components]\n\n"}
{"name":"CategoryTheory.Adjunction.ext","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj adj' : CategoryTheory.Adjunction F G\nh : Eq adj.unit adj'.unit\n‚ä¢ Eq adj adj'","decl":"@[ext]\nlemma ext {F : C ‚•§ D} {G : D ‚•§ C} {adj adj' : F ‚ä£ G}\n    (h : adj.unit = adj'.unit) : adj = adj' := by\n  suffices h' : adj.counit = adj'.counit by cases adj; cases adj'; aesop\n  ext X\n  apply (adj.homEquiv _ _).injective\n  rw [Adjunction.homEquiv_unit, Adjunction.homEquiv_unit,\n    Adjunction.right_triangle_components, h, Adjunction.right_triangle_components]\n\n"}
{"name":"CategoryTheory.Adjunction.isLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ F.IsLeftAdjoint","decl":"lemma isLeftAdjoint (adj : F ‚ä£ G) : F.IsLeftAdjoint := ‚ü®_, ‚ü®adj‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ G.IsRightAdjoint","decl":"lemma isRightAdjoint (adj : F ‚ä£ G) : G.IsRightAdjoint := ‚ü®_, ‚ü®adj‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.instIsLeftAdjointLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nR : CategoryTheory.Functor D C\ninst‚úù : R.IsRightAdjoint\n‚ä¢ R.leftAdjoint.IsLeftAdjoint","decl":"instance (R : D ‚•§ C) [R.IsRightAdjoint] : R.leftAdjoint.IsLeftAdjoint :=\n  (ofIsRightAdjoint R).isLeftAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.instIsRightAdjointRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nL : CategoryTheory.Functor C D\ninst‚úù : L.IsLeftAdjoint\n‚ä¢ L.rightAdjoint.IsRightAdjoint","decl":"instance (L : C ‚•§ D) [L.IsLeftAdjoint] : L.rightAdjoint.IsRightAdjoint :=\n  (ofIsLeftAdjoint L).isRightAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_id","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\n‚ä¢ Eq ((adj.homEquiv X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X))) (adj.unit.app X)","decl":"theorem homEquiv_id (X : C) : adj.homEquiv X _ (ùüô _) = adj.unit.app X := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_symm_id","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : D\n‚ä¢ Eq ((adj.homEquiv (G.obj X) X).symm (CategoryTheory.CategoryStruct.id (G.obj X))) (adj.counit.app X)","decl":"theorem homEquiv_symm_id (X : D) : (adj.homEquiv _ X).symm (ùüô _) = adj.counit.app X := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((adj.homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y).symm g))","decl":"theorem homEquiv_naturality_left_symm (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y) :\n    (adj.homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (adj.homEquiv X Y).symm g := by\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((adj.homEquiv X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y) g))","decl":"theorem homEquiv_naturality_left (f : X' ‚ü∂ X) (g : F.obj X ‚ü∂ Y) :\n    (adj.homEquiv X' Y) (F.map f ‚â´ g) = f ‚â´ (adj.homEquiv X Y) g := by\n  rw [‚Üê Equiv.eq_symm_apply]\n  simp only [Equiv.symm_apply_apply, eq_self_iff_true, homEquiv_naturality_left_symm]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY Y' : D\nf : Quiver.Hom (F.obj X) Y\ng : Quiver.Hom Y Y'\n‚ä¢ Eq ((adj.homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y) f) (G.map g))","decl":"theorem homEquiv_naturality_right (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y') :\n    (adj.homEquiv X Y') (f ‚â´ g) = (adj.homEquiv X Y) f ‚â´ G.map g := by\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY Y' : D\nf : Quiver.Hom X (G.obj Y)\ng : Quiver.Hom Y Y'\n‚ä¢ Eq ((adj.homEquiv X Y').symm (CategoryTheory.CategoryStruct.comp f (G.map g))) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y).symm f) g)","decl":"theorem homEquiv_naturality_right_symm (f : X ‚ü∂ G.obj Y) (g : Y ‚ü∂ Y') :\n    (adj.homEquiv X Y').symm (f ‚â´ G.map g) = (adj.homEquiv X Y).symm f ‚â´ g := by\n  rw [Equiv.symm_apply_eq]\n  simp only [homEquiv_naturality_right, eq_self_iff_true, Equiv.apply_symm_apply]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh‚úù : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h‚úù k)\nZ : C\nh : Quiver.Hom (G.obj Y') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y') g) h)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h‚úù) (CategoryTheory.CategoryStruct.comp (G.map k) h))","decl":"@[reassoc]\ntheorem homEquiv_naturality_left_square (f : X' ‚ü∂ X) (g : F.obj X ‚ü∂ Y')\n    (h : F.obj X' ‚ü∂ Y) (k : Y ‚ü∂ Y') (w : F.map f ‚â´ g = h ‚â´ k) :\n    f ‚â´ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ‚â´ G.map k := by\n  rw [‚Üê homEquiv_naturality_left, ‚Üê homEquiv_naturality_right, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h k)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y') g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h) (G.map k))","decl":"@[reassoc]\ntheorem homEquiv_naturality_left_square (f : X' ‚ü∂ X) (g : F.obj X ‚ü∂ Y')\n    (h : F.obj X' ‚ü∂ Y) (k : Y ‚ü∂ Y') (w : F.map f ‚â´ g = h ‚â´ k) :\n    f ‚â´ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ‚â´ G.map k := by\n  rw [‚Üê homEquiv_naturality_left, ‚Üê homEquiv_naturality_right, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh‚úù : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h‚úù (G.map k))\nZ : D\nh : Quiver.Hom Y' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y').symm g) h)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h‚úù) (CategoryTheory.CategoryStruct.comp k h))","decl":"@[reassoc]\ntheorem homEquiv_naturality_right_square (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y')\n    (h : X' ‚ü∂ G.obj Y) (k : Y ‚ü∂ Y') (w : f ‚â´ g = h ‚â´ G.map k) :\n    F.map f ‚â´ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ‚â´ k := by\n  rw [‚Üê homEquiv_naturality_left_symm, ‚Üê homEquiv_naturality_right_symm, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\nw : Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h (G.map k))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y').symm g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h) k)","decl":"@[reassoc]\ntheorem homEquiv_naturality_right_square (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y')\n    (h : X' ‚ü∂ G.obj Y) (k : Y ‚ü∂ Y') (w : f ‚â´ g = h ‚â´ G.map k) :\n    F.map f ‚â´ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ‚â´ k := by\n  rw [‚Üê homEquiv_naturality_left_symm, ‚Üê homEquiv_naturality_right_symm, w]\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_left_square_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y'\nh : Quiver.Hom (F.obj X') Y\nk : Quiver.Hom Y Y'\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y') g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y) h) (G.map k))) (Eq (CategoryTheory.CategoryStruct.comp (F.map f) g) (CategoryTheory.CategoryStruct.comp h k))","decl":"theorem homEquiv_naturality_left_square_iff (f : X' ‚ü∂ X) (g : F.obj X ‚ü∂ Y')\n    (h : F.obj X' ‚ü∂ Y) (k : Y ‚ü∂ Y') :\n    (f ‚â´ (adj.homEquiv X Y') g = (adj.homEquiv X' Y) h ‚â´ G.map k) ‚Üî\n      (F.map f ‚â´ g = h ‚â´ k) :=\n  ‚ü®fun w ‚Ü¶ by simpa only [Equiv.symm_apply_apply]\n      using homEquiv_naturality_right_square adj _ _ _ _ w,\n    homEquiv_naturality_left_square adj f g h k‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_naturality_right_square_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX' X : C\nY Y' : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y')\nh : Quiver.Hom X' (G.obj Y)\nk : Quiver.Hom Y Y'\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (F.map f) ((adj.homEquiv X Y').symm g)) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X' Y).symm h) k)) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp h (G.map k)))","decl":"theorem homEquiv_naturality_right_square_iff (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y')\n    (h : X' ‚ü∂ G.obj Y) (k : Y ‚ü∂ Y') :\n    (F.map f ‚â´ (adj.homEquiv X Y').symm g = (adj.homEquiv X' Y).symm h ‚â´ k) ‚Üî\n      (f ‚â´ g = h ‚â´ G.map k) :=\n  ‚ü®fun w ‚Ü¶ by simpa only [Equiv.apply_symm_apply]\n      using homEquiv_naturality_left_square adj _ _ _ _ w,\n    homEquiv_naturality_right_square adj f g h k‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.left_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight adj.unit F) (CategoryTheory.whiskerLeft F adj.counit)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).comp F))","decl":"@[simp]\ntheorem left_triangle : whiskerRight adj.unit F ‚â´ whiskerLeft F adj.counit = ùüô _ := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Adjunction.right_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G adj.unit) (CategoryTheory.whiskerRight adj.counit G)) (CategoryTheory.CategoryStruct.id (G.comp (CategoryTheory.Functor.id C)))","decl":"@[simp]\ntheorem right_triangle : whiskerLeft G adj.unit ‚â´ whiskerRight adj.counit G = ùüô _ := by\n  ext; simp\n\n"}
{"name":"CategoryTheory.Adjunction.counit_naturality","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : D\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map f)) (adj.counit.app Y)) (CategoryTheory.CategoryStruct.comp (adj.counit.app X) f)","decl":"@[reassoc (attr := simp)]\ntheorem counit_naturality {X Y : D} (f : X ‚ü∂ Y) :\n    F.map (G.map f) ‚â´ adj.counit.app Y = adj.counit.app X ‚â´ f :=\n  adj.counit.naturality f\n\n"}
{"name":"CategoryTheory.Adjunction.counit_naturality_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : D\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map f)) (CategoryTheory.CategoryStruct.comp (adj.counit.app Y) h)) (CategoryTheory.CategoryStruct.comp (adj.counit.app X) (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem counit_naturality {X Y : D} (f : X ‚ü∂ Y) :\n    F.map (G.map f) ‚â´ adj.counit.app Y = adj.counit.app X ‚â´ f :=\n  adj.counit.naturality f\n\n"}
{"name":"CategoryTheory.Adjunction.unit_naturality","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (G.map (F.map f))) (CategoryTheory.CategoryStruct.comp f (adj.unit.app Y))","decl":"@[reassoc (attr := simp)]\ntheorem unit_naturality {X Y : C} (f : X ‚ü∂ Y) :\n    adj.unit.app X ‚â´ G.map (F.map f) = f ‚â´ adj.unit.app Y :=\n  (adj.unit.naturality f).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_naturality_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (G.obj (F.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app X) (CategoryTheory.CategoryStruct.comp (G.map (F.map f)) h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (adj.unit.app Y) h))","decl":"@[reassoc (attr := simp)]\ntheorem unit_naturality {X Y : C} (f : X ‚ü∂ Y) :\n    adj.unit.app X ‚â´ G.map (F.map f) = f ‚â´ adj.unit.app Y :=\n  (adj.unit.naturality f).symm\n\n"}
{"name":"CategoryTheory.Adjunction.unit_comp_map_eq_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (adj.unit.app A) (G.map f)) g) (Eq f (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app B)))","decl":"lemma unit_comp_map_eq_iff {A : C} {B : D} (f : F.obj A ‚ü∂ B) (g : A ‚ü∂ G.obj B) :\n    adj.unit.app A ‚â´ G.map f = g ‚Üî f = F.map g ‚â´ adj.counit.app B :=\n  ‚ü®fun h => by simp [‚Üê h], fun h => by simp [h]‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.eq_unit_comp_map_iff","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n‚ä¢ Iff (Eq g (CategoryTheory.CategoryStruct.comp (adj.unit.app A) (G.map f))) (Eq (CategoryTheory.CategoryStruct.comp (F.map g) (adj.counit.app B)) f)","decl":"lemma eq_unit_comp_map_iff {A : C} {B : D} (f : F.obj A ‚ü∂ B) (g : A ‚ü∂ G.obj B) :\n    g = adj.unit.app A ‚â´ G.map f ‚Üî F.map g ‚â´ adj.counit.app B = f :=\n  ‚ü®fun h => by simp [h], fun h => by simp [‚Üê h]‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.homEquiv_apply_eq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n‚ä¢ Iff (Eq ((adj.homEquiv A B) f) g) (Eq f ((adj.homEquiv A B).symm g))","decl":"theorem homEquiv_apply_eq {A : C} {B : D} (f : F.obj A ‚ü∂ B) (g : A ‚ü∂ G.obj B) :\n    adj.homEquiv A B f = g ‚Üî f = (adj.homEquiv A B).symm g :=\n  unit_comp_map_eq_iff adj f g\n\n"}
{"name":"CategoryTheory.Adjunction.eq_homEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : C\nB : D\nf : Quiver.Hom (F.obj A) B\ng : Quiver.Hom A (G.obj B)\n‚ä¢ Iff (Eq g ((adj.homEquiv A B) f)) (Eq ((adj.homEquiv A B).symm g) f)","decl":"theorem eq_homEquiv_apply {A : C} {B : D} (f : F.obj A ‚ü∂ B) (g : A ‚ü∂ G.obj B) :\n    g = adj.homEquiv A B f ‚Üî (adj.homEquiv A B).symm g = f :=\n  eq_unit_comp_map_iff adj f g\n\n"}
{"name":"CategoryTheory.Adjunction.corepresentableBy_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX : C\nY‚úù : D\n‚ä¢ Eq (adj.corepresentableBy X).homEquiv (adj.homEquiv X Y‚úù)","decl":"/--  If `adj : F ‚ä£ G`, and `X : C`, then `F.obj X` corepresents `Y ‚Ü¶ (X ‚ü∂ G.obj Y)`-/\n@[simps]\ndef corepresentableBy (X : C) :\n    (G ‚ãô coyoneda.obj (Opposite.op X)).CorepresentableBy (F.obj X) where\n  homEquiv := adj.homEquiv _ _\n  homEquiv_comp := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.representableBy_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nY : D\nX‚úù : C\n‚ä¢ Eq (adj.representableBy Y).homEquiv (adj.homEquiv X‚úù Y).symm","decl":"/--  If `adj : F ‚ä£ G`, and `Y : D`, then `G.obj Y` represents `X ‚Ü¶ (F.obj X ‚ü∂ Y)`-/\n@[simps]\ndef representableBy (Y : D) :\n    (F.op ‚ãô yoneda.obj Y).RepresentableBy (G.obj Y) where\n  homEquiv := (adj.homEquiv _ _).symm\n  homEquiv_comp := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (‚àÄ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto‚úù\nhomEquiv_counit : autoParam (‚àÄ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F ‚ãô G\n  /-- The counit of an adjunction -/\n  counit : G ‚ãô F ‚ü∂ ùü≠ D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ‚àÄ {X Y f}, (homEquiv X Y) f = unit.app X ‚â´ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ‚àÄ {X Y g}, (homEquiv X Y).symm g = F.map g ‚â´ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv‚úù : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit‚úù : autoParam (‚àÄ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv‚úù X Y) f) (CategoryTheory.CategoryStruct.comp (unit‚úù.app X) (G.map f))) _auto‚úù\nhomEquiv_counit‚úù : autoParam (‚àÄ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv‚úù X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit‚úù.app Y))) _auto‚úù\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (‚àÄ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto‚úù\nhomEquiv_counit : autoParam (‚àÄ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto‚úù\n‚ä¢ Eq (Eq { homEquiv := homEquiv‚úù, unit := unit‚úù, counit := counit‚úù, homEquiv_unit := homEquiv_unit‚úù, homEquiv_counit := homEquiv_counit‚úù } { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }) (And (Eq homEquiv‚úù homEquiv) (And (Eq unit‚úù unit) (Eq counit‚úù counit)))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F ‚ãô G\n  /-- The counit of an adjunction -/\n  counit : G ‚ãô F ‚ü∂ ùü≠ D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ‚àÄ {X Y f}, (homEquiv X Y) f = unit.app X ‚â´ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ‚àÄ {X Y g}, (homEquiv X Y).symm g = F.map g ‚â´ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.homEquiv_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((self.homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (self.unit.app X) (G.map f))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F ‚ãô G\n  /-- The counit of an adjunction -/\n  counit : G ‚ãô F ‚ü∂ ùü≠ D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ‚àÄ {X Y f}, (homEquiv X Y) f = unit.app X ‚â´ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ‚àÄ {X Y g}, (homEquiv X Y).symm g = F.map g ‚â´ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.homEquiv_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\nX : C\nY : D\ng : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((self.homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (self.counit.app Y))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F ‚ãô G\n  /-- The counit of an adjunction -/\n  counit : G ‚ãô F ‚ü∂ ùü≠ D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ‚àÄ {X Y f}, (homEquiv X Y) f = unit.app X ‚â´ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ‚àÄ {X Y g}, (homEquiv X Y).symm g = F.map g ‚â´ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquivUnitCounit.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv‚úù : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit‚úù : autoParam (‚àÄ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv‚úù X Y) f) (CategoryTheory.CategoryStruct.comp (unit‚úù.app X) (G.map f))) _auto‚úù\nhomEquiv_counit‚úù : autoParam (‚àÄ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv‚úù X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit‚úù.app Y))) _auto‚úù\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nhomEquiv_unit : autoParam (‚àÄ {X : C} {Y : D} {f : Quiver.Hom (F.obj X) Y}, Eq ((homEquiv X Y) f) (CategoryTheory.CategoryStruct.comp (unit.app X) (G.map f))) _auto‚úù\nhomEquiv_counit : autoParam (‚àÄ {X : C} {Y : D} {g : Quiver.Hom X (G.obj Y)}, Eq ((homEquiv X Y).symm g) (CategoryTheory.CategoryStruct.comp (F.map g) (counit.app Y))) _auto‚úù\nx‚úù : Eq { homEquiv := homEquiv‚úù, unit := unit‚úù, counit := counit‚úù, homEquiv_unit := homEquiv_unit‚úù, homEquiv_counit := homEquiv_counit‚úù } { homEquiv := homEquiv, unit := unit, counit := counit, homEquiv_unit := homEquiv_unit, homEquiv_counit := homEquiv_counit }\n‚ä¢ And (Eq homEquiv‚úù homEquiv) (And (Eq unit‚úù unit) (Eq counit‚úù counit))","decl":"/--\nThis is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mk'`. This structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquivUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` coming from an adjunction -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The unit of an adjunction -/\n  unit : ùü≠ C ‚ü∂ F ‚ãô G\n  /-- The counit of an adjunction -/\n  counit : G ‚ãô F ‚ü∂ ùü≠ D\n  /-- The relationship between the unit and hom set equivalence of an adjunction -/\n  homEquiv_unit : ‚àÄ {X Y f}, (homEquiv X Y) f = unit.app X ‚â´ G.map f := by aesop_cat\n  /-- The relationship between the counit and hom set equivalence of an adjunction -/\n  homEquiv_counit : ‚àÄ {X Y g}, (homEquiv X Y).symm g = F.map g ‚â´ counit.app Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\nY Y' : D\nf : Quiver.Hom (F.obj X) Y\ng : Quiver.Hom Y Y'\n‚ä¢ Eq ((self.homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((self.homEquiv X Y) f) (G.map g))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` -/\n  homEquiv_naturality_left_symm :\n    ‚àÄ {X' X Y} (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y),\n      (homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` -/\n  homEquiv_naturality_right :\n    ‚àÄ {X Y Y'} (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n      (homEquiv X Y') (f ‚â´ g) = (homEquiv X Y) f ‚â´ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (‚àÄ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto‚úù\nhomEquiv_naturality_right : autoParam (‚àÄ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }) 1","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` -/\n  homEquiv_naturality_left_symm :\n    ‚àÄ {X' X Y} (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y),\n      (homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` -/\n  homEquiv_naturality_right :\n    ‚àÄ {X Y Y'} (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n      (homEquiv X Y') (f ‚â´ g) = (homEquiv X Y) f ‚â´ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv‚úù : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm‚úù : autoParam (‚àÄ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv‚úù X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv‚úù X Y).symm g))) _auto‚úù\nhomEquiv_naturality_right‚úù : autoParam (‚àÄ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv‚úù X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv‚úù X Y) f) (G.map g))) _auto‚úù\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (‚àÄ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto‚úù\nhomEquiv_naturality_right : autoParam (‚àÄ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto‚úù\n‚ä¢ Eq (Eq { homEquiv := homEquiv‚úù, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm‚úù, homEquiv_naturality_right := homEquiv_naturality_right‚úù } { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }) (Eq homEquiv‚úù homEquiv)","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` -/\n  homEquiv_naturality_left_symm :\n    ‚àÄ {X' X Y} (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y),\n      (homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` -/\n  homEquiv_naturality_right :\n    ‚àÄ {X Y Y'} (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n      (homEquiv X Y') (f ‚â´ g) = (homEquiv X Y) f ‚â´ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nhomEquiv‚úù : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm‚úù : autoParam (‚àÄ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv‚úù X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv‚úù X Y).symm g))) _auto‚úù\nhomEquiv_naturality_right‚úù : autoParam (‚àÄ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv‚úù X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv‚úù X Y) f) (G.map g))) _auto‚úù\nhomEquiv : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G.obj Y))\nhomEquiv_naturality_left_symm : autoParam (‚àÄ {X' X : C} {Y : D} (f : Quiver.Hom X' X) (g : Quiver.Hom X (G.obj Y)), Eq ((homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((homEquiv X Y).symm g))) _auto‚úù\nhomEquiv_naturality_right : autoParam (‚àÄ {X : C} {Y Y' : D} (f : Quiver.Hom (F.obj X) Y) (g : Quiver.Hom Y Y'), Eq ((homEquiv X Y') (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ((homEquiv X Y) f) (G.map g))) _auto‚úù\nx‚úù : Eq { homEquiv := homEquiv‚úù, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm‚úù, homEquiv_naturality_right := homEquiv_naturality_right‚úù } { homEquiv := homEquiv, homEquiv_naturality_left_symm := homEquiv_naturality_left_symm, homEquiv_naturality_right := homEquiv_naturality_right }\n‚ä¢ Eq homEquiv‚úù homEquiv","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` -/\n  homEquiv_naturality_left_symm :\n    ‚àÄ {X' X Y} (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y),\n      (homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` -/\n  homEquiv_naturality_right :\n    ‚àÄ {X Y Y'} (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n      (homEquiv X Y') (f ‚â´ g) = (homEquiv X Y) f ‚â´ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreHomEquiv F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((self.homEquiv X' Y).symm (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.map f) ((self.homEquiv X Y).symm g))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfHomEquiv`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreHomEquiv (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The equivalence between `Hom (F X) Y` and `Hom X (G Y)` -/\n  homEquiv : ‚àÄ X Y, (F.obj X ‚ü∂ Y) ‚âÉ (X ‚ü∂ G.obj Y)\n  /-- The property that describes how `homEquiv.symm` transforms compositions `X' ‚ü∂ X ‚ü∂ G Y` -/\n  homEquiv_naturality_left_symm :\n    ‚àÄ {X' X Y} (f : X' ‚ü∂ X) (g : X ‚ü∂ G.obj Y),\n      (homEquiv X' Y).symm (f ‚â´ g) = F.map f ‚â´ (homEquiv X Y).symm g := by\n    aesop_cat\n  /-- The property that describes how `homEquiv` transforms compositions `F X ‚ü∂ Y ‚ü∂ Y'` -/\n  homEquiv_naturality_right :\n    ‚àÄ {X Y Y'} (f : F.obj X ‚ü∂ Y) (g : Y ‚ü∂ Y'),\n      (homEquiv X Y') (f ‚â´ g) = (homEquiv X Y) f ‚â´ G.map g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_left","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX' X : C\nY : D\nf : Quiver.Hom X' X\ng : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((adj.homEquiv X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((adj.homEquiv X Y) g))","decl":"theorem homEquiv_naturality_left (f : X' ‚ü∂ X) (g : F.obj X ‚ü∂ Y) :\n    (adj.homEquiv X' Y) (F.map f ‚â´ g) = f ‚â´ (adj.homEquiv X Y) g := by\n  rw [‚Üê Equiv.eq_symm_apply]; simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreHomEquiv.homEquiv_naturality_right_symm","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\nY Y' : D\nf : Quiver.Hom X (G.obj Y)\ng : Quiver.Hom Y Y'\n‚ä¢ Eq ((adj.homEquiv X Y').symm (CategoryTheory.CategoryStruct.comp f (G.map g))) (CategoryTheory.CategoryStruct.comp ((adj.homEquiv X Y).symm f) g)","decl":"theorem homEquiv_naturality_right_symm (f : X ‚ü∂ G.obj Y) (g : Y ‚ü∂ Y') :\n    (adj.homEquiv X Y').symm (f ‚â´ G.map g) = (adj.homEquiv X Y).symm f ‚â´ g := by\n  rw [Equiv.symm_apply_eq]; simp\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.right_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreUnitCounit F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G self.unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight self.counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ‚â´ (Functor.associator F G F).hom ‚â´ whiskerLeft F counit =\n      NatTrans.id (ùü≠ C ‚ãô F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ‚â´ (Functor.associator G F G).inv ‚â´ whiskerRight counit G =\n      NatTrans.id (G ‚ãô ùü≠ C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.injEq","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit‚úù F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit‚úù))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto‚úù\nright_triangle‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit‚úù) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit‚úù G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto‚úù\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto‚úù\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto‚úù\n‚ä¢ Eq (Eq { unit := unit‚úù, counit := counit‚úù, left_triangle := left_triangle‚úù, right_triangle := right_triangle‚úù } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (And (Eq unit‚úù unit) (Eq counit‚úù counit))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ‚â´ (Functor.associator F G F).hom ‚â´ whiskerLeft F counit =\n      NatTrans.id (ùü≠ C ‚ãô F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ‚â´ (Functor.associator G F G).inv ‚â´ whiskerRight counit G =\n      NatTrans.id (G ‚ãô ùü≠ C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.left_triangle","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Adjunction.CoreUnitCounit F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight self.unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F self.counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ‚â´ (Functor.associator F G F).hom ‚â´ whiskerLeft F counit =\n      NatTrans.id (ùü≠ C ‚ãô F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ‚â´ (Functor.associator G F G).inv ‚â´ whiskerRight counit G =\n      NatTrans.id (G ‚ãô ùü≠ C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.inj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nunit‚úù : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit‚úù : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit‚úù F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit‚úù))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto‚úù\nright_triangle‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit‚úù) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit‚úù G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto‚úù\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto‚úù\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto‚úù\nx‚úù : Eq { unit := unit‚úù, counit := counit‚úù, left_triangle := left_triangle‚úù, right_triangle := right_triangle‚úù } { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }\n‚ä¢ And (Eq unit‚úù unit) (Eq counit‚úù counit)","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ‚â´ (Functor.associator F G F).hom ‚â´ whiskerLeft F counit =\n      NatTrans.id (ùü≠ C ‚ãô F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ‚â´ (Functor.associator G F G).inv ‚â´ whiskerRight counit G =\n      NatTrans.id (G ‚ãô ùü≠ C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.CoreUnitCounit.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nunit : Quiver.Hom (CategoryTheory.Functor.id C) (F.comp G)\ncounit : Quiver.Hom (G.comp F) (CategoryTheory.Functor.id D)\nleft_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight unit F) (CategoryTheory.CategoryStruct.comp (F.associator G F).hom (CategoryTheory.whiskerLeft F counit))) (CategoryTheory.NatTrans.id ((CategoryTheory.Functor.id C).comp F))) _auto‚úù\nright_triangle : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G unit) (CategoryTheory.CategoryStruct.comp (G.associator F G).inv (CategoryTheory.whiskerRight counit G))) (CategoryTheory.NatTrans.id (G.comp (CategoryTheory.Functor.id C)))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { unit := unit, counit := counit, left_triangle := left_triangle, right_triangle := right_triangle }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf unit)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf left_triangle)) (SizeOf.sizeOf right_triangle))","decl":"/-- This is an auxiliary data structure useful for constructing adjunctions.\nSee `Adjunction.mkOfUnitCounit`.\nThis structure won't typically be used anywhere else.\n-/\nstructure CoreUnitCounit (F : C ‚•§ D) (G : D ‚•§ C) where\n  /-- The unit of an adjunction between `F` and `G` -/\n  unit : ùü≠ C ‚ü∂ F.comp G\n  /-- The counit of an adjunction between `F` and `G`s -/\n  counit : G.comp F ‚ü∂ ùü≠ D\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `F ‚ü∂ (F G) F ‚ü∂ F (G F) ‚ü∂ F = NatTrans.id F` -/\n  left_triangle :\n    whiskerRight unit F ‚â´ (Functor.associator F G F).hom ‚â´ whiskerLeft F counit =\n      NatTrans.id (ùü≠ C ‚ãô F) := by\n    aesop_cat\n  /-- Equality of the composition of the unit, associator, and counit with the identity\n  `G ‚ü∂ G (F G) ‚ü∂ (F G) F ‚ü∂ G = NatTrans.id G` -/\n  right_triangle :\n    whiskerLeft G unit ‚â´ (Functor.associator G F G).inv ‚â´ whiskerRight counit G =\n      NatTrans.id (G ‚ãô ùü≠ C) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mk' adj).unit adj.unit","decl":"/--\nConstruct an adjunction from the data of a `CoreHomEquivUnitCounit`, i.e. a hom set\nequivalence, unit and counit natural transformations together with proofs of the equalities\n`homEquiv_unit` and `homEquiv_counit` relating them to each other.\n-/\n@[simps]\ndef mk' (adj : CoreHomEquivUnitCounit F G) : F ‚ä£ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    rw [‚Üê adj.homEquiv_counit, (adj.homEquiv _ _).symm_apply_eq, adj.homEquiv_unit]\n    simp\n  right_triangle_components Y := by\n    rw [‚Üê adj.homEquiv_unit, ‚Üê (adj.homEquiv _ _).eq_symm_apply, adj.homEquiv_counit]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mk' adj).counit adj.counit","decl":"/--\nConstruct an adjunction from the data of a `CoreHomEquivUnitCounit`, i.e. a hom set\nequivalence, unit and counit natural transformations together with proofs of the equalities\n`homEquiv_unit` and `homEquiv_counit` relating them to each other.\n-/\n@[simps]\ndef mk' (adj : CoreHomEquivUnitCounit F G) : F ‚ä£ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    rw [‚Üê adj.homEquiv_counit, (adj.homEquiv _ _).symm_apply_eq, adj.homEquiv_unit]\n    simp\n  right_triangle_components Y := by\n    rw [‚Üê adj.homEquiv_unit, ‚Üê (adj.homEquiv _ _).eq_symm_apply, adj.homEquiv_counit]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.mk'_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquivUnitCounit F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mk' adj).homEquiv adj.homEquiv","decl":"lemma mk'_homEquiv (adj : CoreHomEquivUnitCounit F G) : (mk' adj).homEquiv = adj.homEquiv := by\n  ext\n  rw [homEquiv_unit, adj.homEquiv_unit, mk'_unit]\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nY : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.mkOfHomEquiv adj).counit.app Y) ((adj.homEquiv (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)))","decl":"/-- Construct an adjunction between `F` and `G` out of a natural bijection between each\n`F.obj X ‚ü∂ Y` and `X ‚ü∂ G.obj Y`. -/\n@[simps!]\ndef mkOfHomEquiv (adj : CoreHomEquiv F G) : F ‚ä£ G :=\n  mk' {\n    unit :=\n      { app := fun X => (adj.homEquiv X (F.obj X)) (ùüô (F.obj X))\n        naturality := by\n          intros\n          simp [‚Üê adj.homEquiv_naturality_left, ‚Üê adj.homEquiv_naturality_right] }\n    counit :=\n      { app := fun Y => (adj.homEquiv _ _).invFun (ùüô (G.obj Y))\n        naturality := by\n          intros\n          simp [‚Üê adj.homEquiv_naturality_left_symm, ‚Üê adj.homEquiv_naturality_right_symm] }\n    homEquiv := adj.homEquiv\n    homEquiv_unit := fun {X Y f} => by simp [‚Üê adj.homEquiv_naturality_right]\n    homEquiv_counit := fun {X Y f} => by simp [‚Üê adj.homEquiv_naturality_left_symm] }\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.mkOfHomEquiv adj).unit.app X) ((adj.homEquiv X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X)))","decl":"/-- Construct an adjunction between `F` and `G` out of a natural bijection between each\n`F.obj X ‚ü∂ Y` and `X ‚ü∂ G.obj Y`. -/\n@[simps!]\ndef mkOfHomEquiv (adj : CoreHomEquiv F G) : F ‚ä£ G :=\n  mk' {\n    unit :=\n      { app := fun X => (adj.homEquiv X (F.obj X)) (ùüô (F.obj X))\n        naturality := by\n          intros\n          simp [‚Üê adj.homEquiv_naturality_left, ‚Üê adj.homEquiv_naturality_right] }\n    counit :=\n      { app := fun Y => (adj.homEquiv _ _).invFun (ùüô (G.obj Y))\n        naturality := by\n          intros\n          simp [‚Üê adj.homEquiv_naturality_left_symm, ‚Üê adj.homEquiv_naturality_right_symm] }\n    homEquiv := adj.homEquiv\n    homEquiv_unit := fun {X Y f} => by simp [‚Üê adj.homEquiv_naturality_right]\n    homEquiv_counit := fun {X Y f} => by simp [‚Üê adj.homEquiv_naturality_left_symm] }\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfHomEquiv_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreHomEquiv F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mkOfHomEquiv adj).homEquiv adj.homEquiv","decl":"@[simp]\nlemma mkOfHomEquiv_homEquiv (adj : CoreHomEquiv F G) :\n    (mkOfHomEquiv adj).homEquiv = adj.homEquiv := by\n  ext X Y g\n  simp [mkOfHomEquiv, ‚Üê adj.homEquiv_naturality_right (ùüô _) g]\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfUnitCounit_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreUnitCounit F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mkOfUnitCounit adj).unit adj.unit","decl":"/-- Construct an adjunction between functors `F` and `G` given a unit and counit for the adjunction\nsatisfying the triangle identities. -/\n@[simps!]\ndef mkOfUnitCounit (adj : CoreUnitCounit F G) : F ‚ä£ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    have := adj.left_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.left_triangle] using this X\n  right_triangle_components Y := by\n    have := adj.right_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.right_triangle] using this Y\n\n"}
{"name":"CategoryTheory.Adjunction.mkOfUnitCounit_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction.CoreUnitCounit F G\n‚ä¢ Eq (CategoryTheory.Adjunction.mkOfUnitCounit adj).counit adj.counit","decl":"/-- Construct an adjunction between functors `F` and `G` given a unit and counit for the adjunction\nsatisfying the triangle identities. -/\n@[simps!]\ndef mkOfUnitCounit (adj : CoreUnitCounit F G) : F ‚ä£ G where\n  unit := adj.unit\n  counit := adj.counit\n  left_triangle_components X := by\n    have := adj.left_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.left_triangle] using this X\n  right_triangle_components Y := by\n    have := adj.right_triangle\n    rw [NatTrans.ext_iff, funext_iff] at this\n    simpa [-CoreUnitCounit.right_triangle] using this Y\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetLeftOfNatIso_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\niso : CategoryTheory.Iso F F'\nX : C\nY : D\nf : Quiver.Hom (F.obj X) Y\n‚ä¢ Eq ((CategoryTheory.Adjunction.equivHomsetLeftOfNatIso iso) f) (CategoryTheory.CategoryStruct.comp (iso.inv.app X) f)","decl":"/-- If F and G are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetLeftOfNatIso {F F' : C ‚•§ D} (iso : F ‚âÖ F') {X : C} {Y : D} :\n    (F.obj X ‚ü∂ Y) ‚âÉ (F'.obj X ‚ü∂ Y) where\n  toFun f := iso.inv.app _ ‚â´ f\n  invFun g := iso.hom.app _ ‚â´ g\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetLeftOfNatIso_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF F' : CategoryTheory.Functor C D\niso : CategoryTheory.Iso F F'\nX : C\nY : D\ng : Quiver.Hom (F'.obj X) Y\n‚ä¢ Eq ((CategoryTheory.Adjunction.equivHomsetLeftOfNatIso iso).symm g) (CategoryTheory.CategoryStruct.comp (iso.hom.app X) g)","decl":"/-- If F and G are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetLeftOfNatIso {F F' : C ‚•§ D} (iso : F ‚âÖ F') {X : C} {Y : D} :\n    (F.obj X ‚ü∂ Y) ‚âÉ (F'.obj X ‚ü∂ Y) where\n  toFun f := iso.inv.app _ ‚â´ f\n  invFun g := iso.hom.app _ ‚â´ g\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetRightOfNatIso_symm_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG G' : CategoryTheory.Functor D C\niso : CategoryTheory.Iso G G'\nX : C\nY : D\ng : Quiver.Hom X (G'.obj Y)\n‚ä¢ Eq ((CategoryTheory.Adjunction.equivHomsetRightOfNatIso iso).symm g) (CategoryTheory.CategoryStruct.comp g (iso.inv.app Y))","decl":"/-- If G and H are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetRightOfNatIso {G G' : D ‚•§ C} (iso : G ‚âÖ G') {X : C} {Y : D} :\n    (X ‚ü∂ G.obj Y) ‚âÉ (X ‚ü∂ G'.obj Y) where\n  toFun f := f ‚â´ iso.hom.app _\n  invFun g := g ‚â´ iso.inv.app _\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.equivHomsetRightOfNatIso_apply","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG G' : CategoryTheory.Functor D C\niso : CategoryTheory.Iso G G'\nX : C\nY : D\nf : Quiver.Hom X (G.obj Y)\n‚ä¢ Eq ((CategoryTheory.Adjunction.equivHomsetRightOfNatIso iso) f) (CategoryTheory.CategoryStruct.comp f (iso.hom.app Y))","decl":"/-- If G and H are naturally isomorphic functors, establish an equivalence of hom-sets. -/\n@[simps]\ndef equivHomsetRightOfNatIso {G G' : D ‚•§ C} (iso : G ‚âÖ G') {X : C} {Y : D} :\n    (X ‚ü∂ G.obj Y) ‚âÉ (X ‚ü∂ G'.obj Y) where\n  toFun f := f ‚â´ iso.hom.app _\n  invFun g := g ‚â´ iso.inv.app _\n  left_inv f := by simp\n  right_inv g := by simp\n\n"}
{"name":"CategoryTheory.Adjunction.compYonedaIso_inv_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX‚úù : D\nX : Opposite C\na‚úù : ((CategoryTheory.yoneda.comp ((CategoryTheory.whiskeringLeft (Opposite C) (Opposite D) (Type v‚ÇÅ)).obj F.op)).obj X‚úù).obj X\n‚ä¢ Eq ((adj.compYonedaIso.inv.app X‚úù).app X a‚úù) (CategoryTheory.CategoryStruct.comp (adj.unit.app (Opposite.unop X)) (G.map a‚úù))","decl":"/-- The isomorpism which an adjunction `F ‚ä£ G` induces on `G ‚ãô yoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compYonedaIso {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\n    {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) :\n    G ‚ãô yoneda ‚âÖ yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv Y.unop X).toIso.symm\n\n"}
{"name":"CategoryTheory.Adjunction.compYonedaIso_hom_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX‚úù : D\nX : Opposite C\na‚úù : ((G.comp CategoryTheory.yoneda).obj X‚úù).obj X\n‚ä¢ Eq ((adj.compYonedaIso.hom.app X‚úù).app X a‚úù) (CategoryTheory.CategoryStruct.comp (F.map a‚úù) (adj.counit.app X‚úù))","decl":"/-- The isomorpism which an adjunction `F ‚ä£ G` induces on `G ‚ãô yoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compYonedaIso {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\n    {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) :\n    G ‚ãô yoneda ‚âÖ yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv Y.unop X).toIso.symm\n\n"}
{"name":"CategoryTheory.Adjunction.compCoyonedaIso_inv_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX‚úù : Opposite C\nX : D\na‚úù : ((CategoryTheory.coyoneda.comp ((CategoryTheory.whiskeringLeft D C (Type v‚ÇÅ)).obj G)).obj X‚úù).obj X\n‚ä¢ Eq ((adj.compCoyonedaIso.inv.app X‚úù).app X a‚úù) (CategoryTheory.CategoryStruct.comp (F.map a‚úù) (adj.counit.app X))","decl":"/-- The isomorpism which an adjunction `F ‚ä£ G` induces on `F.op ‚ãô coyoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compCoyonedaIso {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\n    {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) :\n    F.op ‚ãô coyoneda ‚âÖ coyoneda ‚ãô (whiskeringLeft _ _ _).obj G :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv X.unop Y).toIso\n\n"}
{"name":"CategoryTheory.Adjunction.compCoyonedaIso_hom_app_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nX‚úù : Opposite C\nX : D\na‚úù : ((F.op.comp CategoryTheory.coyoneda).obj X‚úù).obj X\n‚ä¢ Eq ((adj.compCoyonedaIso.hom.app X‚úù).app X a‚úù) (CategoryTheory.CategoryStruct.comp (adj.unit.app (Opposite.unop X‚úù)) (G.map a‚úù))","decl":"/-- The isomorpism which an adjunction `F ‚ä£ G` induces on `F.op ‚ãô coyoneda`. This states that\n`Adjunction.homEquiv` is natural in both arguments. -/\n@[simps!]\ndef compCoyonedaIso {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} D]\n    {F : C ‚•§ D} {G : D ‚•§ C} (adj : F ‚ä£ G) :\n    F.op ‚ãô coyoneda ‚âÖ coyoneda ‚ãô (whiskeringLeft _ _ _).obj G :=\n  NatIso.ofComponents fun X => NatIso.ofComponents fun Y => (adj.homEquiv X.unop Y).toIso\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\n‚ä¢ Eq (adj‚ÇÅ.comp adj‚ÇÇ).unit (CategoryTheory.CategoryStruct.comp adj‚ÇÅ.unit (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight F.rightUnitor.inv G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft F adj‚ÇÇ.unit) G) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (F.associator H I).inv G) ((F.comp H).associator I G).hom))))","decl":"/-- Composition of adjunctions. -/\n@[simps! (config := .lemmasOnly) unit counit, stacks 0DV0]\ndef comp : F ‚ãô H ‚ä£ I ‚ãô G :=\n  mk' {\n    homEquiv := fun _ _ ‚Ü¶ Equiv.trans (adj‚ÇÇ.homEquiv _ _) (adj‚ÇÅ.homEquiv _ _)\n    unit := adj‚ÇÅ.unit ‚â´ whiskerRight (F.rightUnitor.inv ‚â´ whiskerLeft F adj‚ÇÇ.unit ‚â´\n      (Functor.associator _ _ _ ).inv) G ‚â´ (Functor.associator _ _ _).hom\n    counit := (Functor.associator _ _ _ ).inv ‚â´ whiskerRight ((Functor.associator _ _ _ ).hom ‚â´\n      whiskerLeft _ adj‚ÇÅ.counit ‚â´ I.rightUnitor.hom) _ ‚â´ adj‚ÇÇ.counit }\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\n‚ä¢ Eq (adj‚ÇÅ.comp adj‚ÇÇ).counit (CategoryTheory.CategoryStruct.comp ((I.comp G).associator F H).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (I.associator G F).hom H) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft I adj‚ÇÅ.counit) H) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight I.rightUnitor.hom H) adj‚ÇÇ.counit))))","decl":"/-- Composition of adjunctions. -/\n@[simps! (config := .lemmasOnly) unit counit, stacks 0DV0]\ndef comp : F ‚ãô H ‚ä£ I ‚ãô G :=\n  mk' {\n    homEquiv := fun _ _ ‚Ü¶ Equiv.trans (adj‚ÇÇ.homEquiv _ _) (adj‚ÇÅ.homEquiv _ _)\n    unit := adj‚ÇÅ.unit ‚â´ whiskerRight (F.rightUnitor.inv ‚â´ whiskerLeft F adj‚ÇÇ.unit ‚â´\n      (Functor.associator _ _ _ ).inv) G ‚â´ (Functor.associator _ _ _).hom\n    counit := (Functor.associator _ _ _ ).inv ‚â´ whiskerRight ((Functor.associator _ _ _ ).hom ‚â´\n      whiskerLeft _ adj‚ÇÅ.counit ‚â´ I.rightUnitor.hom) _ ‚â´ adj‚ÇÇ.counit }\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\nX Z : C\nh : Quiver.Hom (G.obj (I.obj (H.obj (F.obj X)))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((adj‚ÇÅ.comp adj‚ÇÇ).unit.app X) h) (CategoryTheory.CategoryStruct.comp (adj‚ÇÅ.unit.app X) (CategoryTheory.CategoryStruct.comp (G.map (adj‚ÇÇ.unit.app (F.obj X))) h))","decl":"@[simp, reassoc]\nlemma comp_unit_app (X : C) :\n    (adj‚ÇÅ.comp adj‚ÇÇ).unit.app X = adj‚ÇÅ.unit.app X ‚â´ G.map (adj‚ÇÇ.unit.app (F.obj X)) := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\nX : C\n‚ä¢ Eq ((adj‚ÇÅ.comp adj‚ÇÇ).unit.app X) (CategoryTheory.CategoryStruct.comp (adj‚ÇÅ.unit.app X) (G.map (adj‚ÇÇ.unit.app (F.obj X))))","decl":"@[simp, reassoc]\nlemma comp_unit_app (X : C) :\n    (adj‚ÇÅ.comp adj‚ÇÇ).unit.app X = adj‚ÇÅ.unit.app X ‚â´ G.map (adj‚ÇÇ.unit.app (F.obj X)) := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\nX Z : E\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((adj‚ÇÅ.comp adj‚ÇÇ).counit.app X) h) (CategoryTheory.CategoryStruct.comp (H.map (adj‚ÇÅ.counit.app (I.obj X))) (CategoryTheory.CategoryStruct.comp (adj‚ÇÇ.counit.app X) h))","decl":"@[simp, reassoc]\nlemma comp_counit_app (X : E) :\n    (adj‚ÇÅ.comp adj‚ÇÇ).counit.app X = H.map (adj‚ÇÅ.counit.app (I.obj X)) ‚â´ adj‚ÇÇ.counit.app X := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\nX : E\n‚ä¢ Eq ((adj‚ÇÅ.comp adj‚ÇÇ).counit.app X) (CategoryTheory.CategoryStruct.comp (H.map (adj‚ÇÅ.counit.app (I.obj X))) (adj‚ÇÇ.counit.app X))","decl":"@[simp, reassoc]\nlemma comp_counit_app (X : E) :\n    (adj‚ÇÅ.comp adj‚ÇÇ).counit.app X = H.map (adj‚ÇÅ.counit.app (I.obj X)) ‚â´ adj‚ÇÇ.counit.app X := by\n  simp [Adjunction.comp]\n\n"}
{"name":"CategoryTheory.Adjunction.comp_homEquiv","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nE : Type u‚ÇÉ\n‚Ñ∞ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nI : CategoryTheory.Functor E D\nadj‚ÇÅ : CategoryTheory.Adjunction F G\nadj‚ÇÇ : CategoryTheory.Adjunction H I\n‚ä¢ Eq (adj‚ÇÅ.comp adj‚ÇÇ).homEquiv fun x x_1 => (adj‚ÇÇ.homEquiv (F.obj x) x_1).trans (adj‚ÇÅ.homEquiv x (I.obj x_1))","decl":"lemma comp_homEquiv :  (adj‚ÇÅ.comp adj‚ÇÇ).homEquiv =\n    fun _ _ ‚Ü¶ Equiv.trans (adj‚ÇÇ.homEquiv _ _) (adj‚ÇÅ.homEquiv _ _) :=\n  mk'_homEquiv _\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointOfEquiv_obj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF_obj : C ‚Üí D\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ‚àÄ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\na‚úù : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.leftAdjointOfEquiv e he).obj a‚úù) (F_obj a‚úù)","decl":"/-- Construct a left adjoint functor to `G`, given the functor's value on objects `F_obj` and\na bijection `e` between `F_obj X ‚ü∂ Y` and `X ‚ü∂ G.obj Y` satisfying a naturality law\n`he : ‚àÄ X Y Y' g h, e X Y' (h ‚â´ g) = e X Y h ‚â´ G.map g`.\nDual to `rightAdjointOfEquiv`. -/\n@[simps!]\ndef leftAdjointOfEquiv (he : ‚àÄ X Y Y' g h, e X Y' (h ‚â´ g) = e X Y h ‚â´ G.map g) : C ‚•§ D where\n  obj := F_obj\n  map {X} {X'} f := (e X (F_obj X')).symm (f ‚â´ e X' (F_obj X') (ùüô _))\n  map_comp := fun f f' => by\n    rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]\n    conv =>\n      rhs\n      rw [assoc, ‚Üê he, id_comp, Equiv.apply_symm_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointOfEquiv_map","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF_obj : C ‚Üí D\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ‚àÄ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nX X' : C\nf : Quiver.Hom X X'\n‚ä¢ Eq ((CategoryTheory.Adjunction.leftAdjointOfEquiv e he).map f) ((e X (F_obj X')).symm (CategoryTheory.CategoryStruct.comp f ((e X' (F_obj X')) (CategoryTheory.CategoryStruct.id (F_obj X')))))","decl":"/-- Construct a left adjoint functor to `G`, given the functor's value on objects `F_obj` and\na bijection `e` between `F_obj X ‚ü∂ Y` and `X ‚ü∂ G.obj Y` satisfying a naturality law\n`he : ‚àÄ X Y Y' g h, e X Y' (h ‚â´ g) = e X Y h ‚â´ G.map g`.\nDual to `rightAdjointOfEquiv`. -/\n@[simps!]\ndef leftAdjointOfEquiv (he : ‚àÄ X Y Y' g h, e X Y' (h ‚â´ g) = e X Y h ‚â´ G.map g) : C ‚•§ D where\n  obj := F_obj\n  map {X} {X'} f := (e X (F_obj X')).symm (f ‚â´ e X' (F_obj X') (ùüô _))\n  map_comp := fun f f' => by\n    rw [Equiv.symm_apply_eq, he, Equiv.apply_symm_apply]\n    conv =>\n      rhs\n      rw [assoc, ‚Üê he, id_comp, Equiv.apply_symm_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivLeft_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF_obj : C ‚Üí D\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ‚àÄ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nY : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivLeft e he).counit.app Y) ((e (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)))","decl":"/-- Show that the functor given by `leftAdjointOfEquiv` is indeed left adjoint to `G`. Dual\nto `adjunctionOfRightEquiv`. -/\n@[simps!]\ndef adjunctionOfEquivLeft : leftAdjointOfEquiv e he ‚ä£ G :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := fun {X'} {X} {Y} f g => by\n        have {X : C} {Y Y' : D} (f : X ‚ü∂ G.obj Y) (g : Y ‚ü∂ Y') :\n            (e X Y').symm (f ‚â´ G.map g) = (e X Y).symm f ‚â´ g := by\n          rw [Equiv.symm_apply_eq, he]; simp\n        simp [‚Üê this, ‚Üê Equiv.apply_eq_iff_eq (e X' Y), ‚Üê he] }\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivLeft_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF_obj : C ‚Üí D\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F_obj X) Y) (Quiver.Hom X (G.obj Y))\nhe : ‚àÄ (X : C) (Y Y' : D) (g : Quiver.Hom Y Y') (h : Quiver.Hom (F_obj X) Y), Eq ((e X Y') (CategoryTheory.CategoryStruct.comp h g)) (CategoryTheory.CategoryStruct.comp ((e X Y) h) (G.map g))\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivLeft e he).unit.app X) ((e X (F_obj X)) (CategoryTheory.CategoryStruct.id (F_obj X)))","decl":"/-- Show that the functor given by `leftAdjointOfEquiv` is indeed left adjoint to `G`. Dual\nto `adjunctionOfRightEquiv`. -/\n@[simps!]\ndef adjunctionOfEquivLeft : leftAdjointOfEquiv e he ‚ä£ G :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := fun {X'} {X} {Y} f g => by\n        have {X : C} {Y Y' : D} (f : X ‚ü∂ G.obj Y) (g : Y ‚ü∂ Y') :\n            (e X Y').symm (f ‚â´ G.map g) = (e X Y).symm f ‚â´ g := by\n          rw [Equiv.symm_apply_eq, he]; simp\n        simp [‚Üê this, ‚Üê Equiv.apply_eq_iff_eq (e X' Y), ‚Üê he] }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointOfEquiv_obj","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG_obj : D ‚Üí C\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ‚àÄ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\na‚úù : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.rightAdjointOfEquiv e he).obj a‚úù) (G_obj a‚úù)","decl":"/-- Construct a right adjoint functor to `F`, given the functor's value on objects `G_obj` and\na bijection `e` between `F.obj X ‚ü∂ Y` and `X ‚ü∂ G_obj Y` satisfying a naturality law\n`he : ‚àÄ X Y Y' g h, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g`.\nDual to `leftAdjointOfEquiv`. -/\n@[simps!]\ndef rightAdjointOfEquiv (he : ‚àÄ X' X Y f g, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g) : D ‚•§ C where\n  obj := G_obj\n  map {Y} {Y'} g := (e (G_obj Y) Y') ((e (G_obj Y) Y).symm (ùüô _) ‚â´ g)\n  map_comp := fun {Y} {Y'} {Y''} g g' => by\n    rw [‚Üê Equiv.eq_symm_apply, ‚Üê he'' e he, Equiv.symm_apply_apply]\n    conv =>\n      rhs\n      rw [‚Üê assoc, he'' e he, comp_id, Equiv.symm_apply_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointOfEquiv_map","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG_obj : D ‚Üí C\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ‚àÄ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nY Y' : D\ng : Quiver.Hom Y Y'\n‚ä¢ Eq ((CategoryTheory.Adjunction.rightAdjointOfEquiv e he).map g) ((e (G_obj Y) Y') (CategoryTheory.CategoryStruct.comp ((e (G_obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G_obj Y))) g))","decl":"/-- Construct a right adjoint functor to `F`, given the functor's value on objects `G_obj` and\na bijection `e` between `F.obj X ‚ü∂ Y` and `X ‚ü∂ G_obj Y` satisfying a naturality law\n`he : ‚àÄ X Y Y' g h, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g`.\nDual to `leftAdjointOfEquiv`. -/\n@[simps!]\ndef rightAdjointOfEquiv (he : ‚àÄ X' X Y f g, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g) : D ‚•§ C where\n  obj := G_obj\n  map {Y} {Y'} g := (e (G_obj Y) Y') ((e (G_obj Y) Y).symm (ùüô _) ‚â´ g)\n  map_comp := fun {Y} {Y'} {Y''} g g' => by\n    rw [‚Üê Equiv.eq_symm_apply, ‚Üê he'' e he, Equiv.symm_apply_apply]\n    conv =>\n      rhs\n      rw [‚Üê assoc, he'' e he, comp_id, Equiv.symm_apply_apply]\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivRight_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG_obj : D ‚Üí C\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ‚àÄ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nX : C\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivRight e he).unit.app X) ((e X (F.obj X)) (CategoryTheory.CategoryStruct.id (F.obj X)))","decl":"/-- Show that the functor given by `rightAdjointOfEquiv` is indeed right adjoint to `F`. Dual\nto `adjunctionOfEquivRight`. -/\n@[simps!]\ndef adjunctionOfEquivRight (he : ‚àÄ X' X Y f g, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g) :\n    F ‚ä£ (rightAdjointOfEquiv e he) :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := by\n        intro X X' Y f g; rw [Equiv.symm_apply_eq]; simp [he]\n      homEquiv_naturality_right := by\n        intro X Y Y' g h\n        simp [‚Üê he, reassoc_of% (he'' e)] }\n\n"}
{"name":"CategoryTheory.Adjunction.adjunctionOfEquivRight_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG_obj : D ‚Üí C\ne : (X : C) ‚Üí (Y : D) ‚Üí Equiv (Quiver.Hom (F.obj X) Y) (Quiver.Hom X (G_obj Y))\nhe : ‚àÄ (X' X : C) (Y : D) (f : Quiver.Hom X' X) (g : Quiver.Hom (F.obj X) Y), Eq ((e X' Y) (CategoryTheory.CategoryStruct.comp (F.map f) g)) (CategoryTheory.CategoryStruct.comp f ((e X Y) g))\nY : D\n‚ä¢ Eq ((CategoryTheory.Adjunction.adjunctionOfEquivRight e he).counit.app Y) ((e (G_obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G_obj Y)))","decl":"/-- Show that the functor given by `rightAdjointOfEquiv` is indeed right adjoint to `F`. Dual\nto `adjunctionOfEquivRight`. -/\n@[simps!]\ndef adjunctionOfEquivRight (he : ‚àÄ X' X Y f g, e X' Y (F.map f ‚â´ g) = f ‚â´ e X Y g) :\n    F ‚ä£ (rightAdjointOfEquiv e he) :=\n  mkOfHomEquiv\n    { homEquiv := e\n      homEquiv_naturality_left_symm := by\n        intro X X' Y f g; rw [Equiv.symm_apply_eq]; simp [he]\n      homEquiv_naturality_right := by\n        intro X Y Y' g h\n        simp [‚Üê he, reassoc_of% (he'' e)] }\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : D\n‚ä¢ Eq (adj.toEquivalence.counitIso.inv.app X) (CategoryTheory.inv (adj.counit.app X))","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\n‚ä¢ Eq adj.toEquivalence.inverse G","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_unitIso_hom_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : C\n‚ä¢ Eq (adj.toEquivalence.unitIso.hom.app X) (adj.unit.app X)","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_unitIso_inv_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : C\n‚ä¢ Eq (adj.toEquivalence.unitIso.inv.app X) (CategoryTheory.inv (adj.unit.app X))","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\nX : D\n‚ä¢ Eq (adj.toEquivalence.counitIso.hom.app X) (adj.counit.app X)","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Adjunction.toEquivalence_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : ‚àÄ (X : C), CategoryTheory.IsIso (adj.unit.app X)\ninst‚úù : ‚àÄ (Y : D), CategoryTheory.IsIso (adj.counit.app Y)\n‚ä¢ Eq adj.toEquivalence.functor F","decl":"/--\nIf the unit and counit of a given adjunction are (pointwise) isomorphisms, then we can upgrade the\nadjunction to an equivalence.\n-/\n@[simps!]\nnoncomputable def toEquivalence (adj : F ‚ä£ G) [‚àÄ X, IsIso (adj.unit.app X)]\n    [‚àÄ Y, IsIso (adj.counit.app Y)] : C ‚âå D where\n  functor := F\n  inverse := G\n  unitIso := NatIso.ofComponents fun X => asIso (adj.unit.app X)\n  counitIso := NatIso.ofComponents fun Y => asIso (adj.counit.app Y)\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\ninst‚úù¬≤ : G.IsRightAdjoint\ninst‚úù¬π : ‚àÄ (X : D), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).unit.app X)\ninst‚úù : ‚àÄ (Y : C), CategoryTheory.IsIso ((CategoryTheory.Adjunction.ofIsRightAdjoint G).counit.app Y)\n‚ä¢ G.IsEquivalence","decl":"/--\nIf the unit and counit for the adjunction corresponding to a right adjoint functor are (pointwise)\nisomorphisms, then the functor is an equivalence of categories.\n-/\nlemma Functor.isEquivalence_of_isRightAdjoint (G : C ‚•§ D) [IsRightAdjoint G]\n    [‚àÄ X, IsIso ((Adjunction.ofIsRightAdjoint G).unit.app X)]\n    [‚àÄ Y, IsIso ((Adjunction.ofIsRightAdjoint G).counit.app Y)] : G.IsEquivalence :=\n  (Adjunction.ofIsRightAdjoint G).toEquivalence.isEquivalence_inverse\n\n"}
{"name":"CategoryTheory.Equivalence.toAdjunction_unit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.toAdjunction.unit e.unit","decl":"/-- The adjunction given by an equivalence of categories. (To obtain the opposite adjunction,\nsimply use `e.symm.toAdjunction`. -/\n@[simps]\ndef toAdjunction : e.functor ‚ä£ e.inverse where\n  unit := e.unit\n  counit := e.counit\n\n"}
{"name":"CategoryTheory.Equivalence.toAdjunction_counit","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.toAdjunction.counit e.counit","decl":"/-- The adjunction given by an equivalence of categories. (To obtain the opposite adjunction,\nsimply use `e.symm.toAdjunction`. -/\n@[simps]\ndef toAdjunction : e.functor ‚ä£ e.inverse where\n  unit := e.unit\n  counit := e.counit\n\n"}
{"name":"CategoryTheory.Equivalence.isLeftAdjoint_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ e.functor.IsLeftAdjoint","decl":"lemma isLeftAdjoint_functor : e.functor.IsLeftAdjoint where\n  exists_rightAdjoint := ‚ü®_, ‚ü®e.toAdjunction‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.isRightAdjoint_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ e.inverse.IsRightAdjoint","decl":"lemma isRightAdjoint_inverse : e.inverse.IsRightAdjoint where\n  exists_leftAdjoint := ‚ü®_, ‚ü®e.toAdjunction‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.isLeftAdjoint_inverse","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ e.inverse.IsLeftAdjoint","decl":"lemma isLeftAdjoint_inverse : e.inverse.IsLeftAdjoint :=\n  e.symm.isLeftAdjoint_functor\n\n"}
{"name":"CategoryTheory.Equivalence.isRightAdjoint_functor","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ e.functor.IsRightAdjoint","decl":"lemma isRightAdjoint_functor : e.functor.IsRightAdjoint :=\n  e.symm.isRightAdjoint_inverse\n\n"}
{"name":"CategoryTheory.Equivalence.refl_toAdjunction","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq CategoryTheory.Equivalence.refl.toAdjunction CategoryTheory.Adjunction.id","decl":"lemma refl_toAdjunction : (refl (C := C)).toAdjunction = Adjunction.id := rfl\n\n"}
{"name":"CategoryTheory.Equivalence.trans_toAdjunction","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nE : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} E\ne' : CategoryTheory.Equivalence D E\n‚ä¢ Eq (e.trans e').toAdjunction (e.toAdjunction.comp e'.toAdjunction)","decl":"lemma trans_toAdjunction {E : Type*} [Category E] (e' : D ‚âå E) :\n    (e.trans e').toAdjunction = e.toAdjunction.comp e'.toAdjunction := rfl\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_comp","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.IsLeftAdjoint\ninst‚úù : G.IsLeftAdjoint\n‚ä¢ (F.comp G).IsLeftAdjoint","decl":"/-- If `F` and `G` are left adjoints then `F ‚ãô G` is a left adjoint too. -/\ninstance isLeftAdjoint_comp {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E] (F : C ‚•§ D) (G : D ‚•§ E)\n    [F.IsLeftAdjoint] [G.IsLeftAdjoint] : (F ‚ãô G).IsLeftAdjoint where\n  exists_rightAdjoint :=\n    ‚ü®_, ‚ü®(Adjunction.ofIsLeftAdjoint F).comp (Adjunction.ofIsLeftAdjoint G)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_comp","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.IsRightAdjoint\ninst‚úù : G.IsRightAdjoint\n‚ä¢ (F.comp G).IsRightAdjoint","decl":"/-- If `F` and `G` are right adjoints then `F ‚ãô G` is a right adjoint too. -/\ninstance isRightAdjoint_comp {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E] {F : C ‚•§ D} {G : D ‚•§ E}\n    [IsRightAdjoint F] [IsRightAdjoint G] : IsRightAdjoint (F ‚ãô G) where\n  exists_leftAdjoint :=\n    ‚ü®_, ‚ü®(Adjunction.ofIsRightAdjoint G).comp (Adjunction.ofIsRightAdjoint F)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : F.IsRightAdjoint\n‚ä¢ G.IsRightAdjoint","decl":"/-- Transport being a right adjoint along a natural isomorphism. -/\nlemma isRightAdjoint_of_iso {F G : C ‚•§ D} (h : F ‚âÖ G) [F.IsRightAdjoint] :\n    IsRightAdjoint G where\n  exists_leftAdjoint := ‚ü®_, ‚ü®(Adjunction.ofIsRightAdjoint F).ofNatIsoRight h‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_of_iso","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nh : CategoryTheory.Iso F G\ninst‚úù : F.IsLeftAdjoint\n‚ä¢ G.IsLeftAdjoint","decl":"/-- Transport being a left adjoint along a natural isomorphism. -/\nlemma isLeftAdjoint_of_iso {F G : C ‚•§ D} (h : F ‚âÖ G) [IsLeftAdjoint F] :\n    IsLeftAdjoint G where\n  exists_rightAdjoint := ‚ü®_, ‚ü®(Adjunction.ofIsLeftAdjoint F).ofNatIsoLeft h‚ü©‚ü©\n\n\n"}
{"name":"CategoryTheory.Functor.isLeftAdjoint_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.IsLeftAdjoint","decl":"/-- If `F` is an equivalence, it's a left adjoint. -/\ninstance (priority := 10) isLeftAdjoint_of_isEquivalence {F : C ‚•§ D} [F.IsEquivalence] :\n    IsLeftAdjoint F :=\n  F.asEquivalence.isLeftAdjoint_functor\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.IsRightAdjoint","decl":"/-- If `F` is an equivalence, it's a right adjoint. -/\ninstance (priority := 10) isRightAdjoint_of_isEquivalence {F : C ‚•§ D} [F.IsEquivalence] :\n    IsRightAdjoint F :=\n  F.asEquivalence.isRightAdjoint_functor\n\n"}
