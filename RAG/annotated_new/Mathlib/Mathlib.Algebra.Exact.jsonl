{"name":"Function.Exact.apply_apply_eq_zero","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\nf : M → N\ng : N → P\ninst✝ : Zero P\nh : Function.Exact f g\nx : M\n⊢ Eq (g (f x)) 0","decl":"lemma apply_apply_eq_zero [Zero P] (h : Exact f g) (x : M) :\n    g (f x) = 0 := (h _).mpr <| Set.mem_range_self _\n\n"}
{"name":"Function.Exact.comp_eq_zero","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\nf : M → N\ng : N → P\ninst✝ : Zero P\nh : Function.Exact f g\n⊢ Eq (Function.comp g f) 0","decl":"lemma comp_eq_zero [Zero P] (h : Exact f g) : g.comp f = 0 :=\n  funext h.apply_apply_eq_zero\n\n"}
{"name":"Function.Exact.of_comp_of_mem_range","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\nf : M → N\ng : N → P\ninst✝ : Zero P\nh1 : Eq (Function.comp g f) 0\nh2 : ∀ (x : N), Eq (g x) 0 → Membership.mem (Set.range f) x\n⊢ Function.Exact f g","decl":"lemma of_comp_of_mem_range [Zero P] (h1 : g ∘ f = 0)\n    (h2 : ∀ x, g x = 0 → x ∈ Set.range f) : Exact f g :=\n  fun y => Iff.intro (h2 y) <|\n    Exists.rec ((forall_apply_eq_imp_iff (p := (g · = 0))).mpr (congrFun h1) y)\n\n"}
{"name":"Function.Exact.comp_injective","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\nP' : Type u_7\nf : M → N\ng : N → P\ng' : P → P'\ninst✝¹ : Zero P\ninst✝ : Zero P'\nexact : Function.Exact f g\ninj : Function.Injective g'\nh0 : Eq (g' 0) 0\n⊢ Function.Exact f (Function.comp g' g)","decl":"lemma comp_injective [Zero P] [Zero P'] (exact : Exact f g)\n    (inj : Function.Injective g') (h0 : g' 0 = 0) :\n    Exact f (g' ∘ g) := by\n  intro x\n  refine ⟨fun H => exact x |>.mp <| inj <| h0 ▸ H, ?_⟩\n  intro H\n  rw [Function.comp_apply, exact x |>.mpr H, h0]\n\n"}
{"name":"Function.Exact.of_comp_eq_zero_of_ker_in_range","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\nf : M → N\ng : N → P\ninst✝ : Zero P\nhc : Eq (Function.comp g f) 0\nhr : ∀ (y : N), Eq (g y) 0 → Membership.mem (Set.range f) y\n⊢ Function.Exact f g","decl":"lemma of_comp_eq_zero_of_ker_in_range [Zero P] (hc : g.comp f = 0)\n    (hr : ∀ y, g y = 0 → y ∈ Set.range f) :\n    Exact f g :=\n  fun y ↦ ⟨hr y, fun ⟨x, hx⟩ ↦ hx ▸ congrFun hc x⟩\n\n"}
{"name":"AddMonoidHom.exact_iff","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝² : AddGroup M\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\n⊢ Iff (Function.Exact ⇑f ⇑g) (Eq g.ker f.range)","decl":"lemma exact_iff :\n    Exact f g ↔ ker g = range f :=\n  Iff.symm SetLike.ext_iff\n\n"}
{"name":"AddMonoidHom.exact_of_comp_eq_zero_of_ker_le_range","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝² : AddGroup M\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\nh1 : Eq (g.comp f) 0\nh2 : LE.le g.ker f.range\n⊢ Function.Exact ⇑f ⇑g","decl":"lemma exact_of_comp_eq_zero_of_ker_le_range\n    (h1 : g.comp f = 0) (h2 : ker g ≤ range f) : Exact f g :=\n  Exact.of_comp_of_mem_range (congrArg DFunLike.coe h1) h2\n\n"}
{"name":"AddMonoidHom.exact_of_comp_of_mem_range","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝² : AddGroup M\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\nh1 : Eq (g.comp f) 0\nh2 : ∀ (x : N), Eq (g x) 0 → Membership.mem f.range x\n⊢ Function.Exact ⇑f ⇑g","decl":"lemma exact_of_comp_of_mem_range\n    (h1 : g.comp f = 0) (h2 : ∀ x, g x = 0 → x ∈ range f) : Exact f g :=\n  exact_of_comp_eq_zero_of_ker_le_range h1 h2\n\n"}
{"name":"AddMonoidHom.exact_iff_of_surjective_of_bijective_of_injective","module":"Mathlib.Algebra.Exact","initialProofState":"M₁ : Type u_8\nM₂ : Type u_9\nM₃ : Type u_10\nN₁ : Type u_11\nN₂ : Type u_12\nN₃ : Type u_13\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : AddCommMonoid N₁\ninst✝¹ : AddCommMonoid N₂\ninst✝ : AddCommMonoid N₃\nf : AddMonoidHom M₁ M₂\ng : AddMonoidHom M₂ M₃\nf' : AddMonoidHom N₁ N₂\ng' : AddMonoidHom N₂ N₃\nτ₁ : AddMonoidHom M₁ N₁\nτ₂ : AddMonoidHom M₂ N₂\nτ₃ : AddMonoidHom M₃ N₃\ncomm₁₂ : Eq (f'.comp τ₁) (τ₂.comp f)\ncomm₂₃ : Eq (g'.comp τ₂) (τ₃.comp g)\nh₁ : Function.Surjective ⇑τ₁\nh₂ : Function.Bijective ⇑τ₂\nh₃ : Function.Injective ⇑τ₃\n⊢ Iff (Function.Exact ⇑f ⇑g) (Function.Exact ⇑f' ⇑g')","decl":"/-- When we have a commutative diagram from a sequence of two maps to another,\nsuch that the left vertical map is surjective, the middle vertical map is bijective and the right\nvertical map is injective, then the upper row is exact iff the lower row is.\nSee `ShortComplex.exact_iff_of_epi_of_isIso_of_mono` in the file\n`Algebra.Homology.ShortComplex.Exact` for the categorical version of this result. -/\nlemma exact_iff_of_surjective_of_bijective_of_injective\n  {M₁ M₂ M₃ N₁ N₂ N₃ : Type*} [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]\n  [AddCommMonoid N₁] [AddCommMonoid N₂] [AddCommMonoid N₃]\n  (f : M₁ →+ M₂) (g : M₂ →+ M₃) (f' : N₁ →+ N₂) (g' : N₂ →+ N₃)\n  (τ₁ : M₁ →+ N₁) (τ₂ : M₂ →+ N₂) (τ₃ : M₃ →+ N₃)\n  (comm₁₂ : f'.comp τ₁ = τ₂.comp f)\n  (comm₂₃ : g'.comp τ₂ = τ₃.comp g)\n  (h₁ : Function.Surjective τ₁) (h₂ : Function.Bijective τ₂) (h₃ : Function.Injective τ₃) :\n    Exact f g ↔ Exact f' g' := by\n  replace comm₁₂ := DFunLike.congr_fun comm₁₂\n  replace comm₂₃ := DFunLike.congr_fun comm₂₃\n  dsimp at comm₁₂ comm₂₃\n  constructor\n  · intro h y₂\n    obtain ⟨x₂, rfl⟩ := h₂.2 y₂\n    constructor\n    · intro hx₂\n      obtain ⟨x₁, rfl⟩ := (h x₂).1 (h₃ (by simpa only [map_zero, comm₂₃] using hx₂))\n      exact ⟨τ₁ x₁, by simp only [comm₁₂]⟩\n    · rintro ⟨y₁, hy₁⟩\n      obtain ⟨x₁, rfl⟩ := h₁ y₁\n      rw [comm₂₃, (h x₂).2 _, map_zero]\n      exact ⟨x₁, h₂.1 (by simpa only [comm₁₂] using hy₁)⟩\n  · intro h x₂\n    constructor\n    · intro hx₂\n      obtain ⟨y₁, hy₁⟩ := (h (τ₂ x₂)).1 (by simp only [comm₂₃, hx₂, map_zero])\n      obtain ⟨x₁, rfl⟩ := h₁ y₁\n      exact ⟨x₁, h₂.1 (by simpa only [comm₁₂] using hy₁)⟩\n    · rintro ⟨x₁, rfl⟩\n      apply h₃\n      simp only [← comm₁₂, ← comm₂₃, h.apply_apply_eq_zero (τ₁ x₁), map_zero]\n\n"}
{"name":"Function.Exact.addMonoidHom_ker_eq","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝² : AddGroup M\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\nhfg : Function.Exact ⇑f ⇑g\n⊢ Eq g.ker f.range","decl":"lemma addMonoidHom_ker_eq (hfg : Exact f g) :\n    ker g = range f :=\n  SetLike.ext hfg\n\n"}
{"name":"Function.Exact.addMonoidHom_comp_eq_zero","module":"Mathlib.Algebra.Exact","initialProofState":"M : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝² : AddGroup M\ninst✝¹ : AddGroup N\ninst✝ : AddGroup P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\nh : Function.Exact ⇑f ⇑g\n⊢ Eq (g.comp f) 0","decl":"lemma addMonoidHom_comp_eq_zero (h : Exact f g) : g.comp f = 0 :=\n  DFunLike.coe_injective h.comp_eq_zero\n\n"}
{"name":"Function.Exact.iff_of_ladder_addEquiv","module":"Mathlib.Algebra.Exact","initialProofState":"X₁ : Type u_8\nX₂ : Type u_9\nX₃ : Type u_10\nY₁ : Type u_11\nY₂ : Type u_12\nY₃ : Type u_13\ninst✝⁵ : AddCommMonoid X₁\ninst✝⁴ : AddCommMonoid X₂\ninst✝³ : AddCommMonoid X₃\ninst✝² : AddCommMonoid Y₁\ninst✝¹ : AddCommMonoid Y₂\ninst✝ : AddCommMonoid Y₃\ne₁ : AddEquiv X₁ Y₁\ne₂ : AddEquiv X₂ Y₂\ne₃ : AddEquiv X₃ Y₃\nf₁₂ : AddMonoidHom X₁ X₂\nf₂₃ : AddMonoidHom X₂ X₃\ng₁₂ : AddMonoidHom Y₁ Y₂\ng₂₃ : AddMonoidHom Y₂ Y₃\ncomm₁₂ : Eq (g₁₂.comp ↑e₁) ((↑e₂).comp f₁₂)\ncomm₂₃ : Eq (g₂₃.comp ↑e₂) ((↑e₃).comp f₂₃)\n⊢ Iff (Function.Exact ⇑g₁₂ ⇑g₂₃) (Function.Exact ⇑f₁₂ ⇑f₂₃)","decl":"lemma iff_of_ladder_addEquiv (comm₁₂ : g₁₂.comp e₁ = AddMonoidHom.comp e₂ f₁₂)\n    (comm₂₃ : g₂₃.comp e₂ = AddMonoidHom.comp e₃ f₂₃) : Exact g₁₂ g₂₃ ↔ Exact f₁₂ f₂₃ :=\n  (exact_iff_of_surjective_of_bijective_of_injective _ _ _ _ e₁ e₂ e₃ comm₁₂ comm₂₃\n    e₁.surjective e₂.bijective e₃.injective).symm\n\n"}
{"name":"Function.Exact.of_ladder_addEquiv_of_exact","module":"Mathlib.Algebra.Exact","initialProofState":"X₁ : Type u_8\nX₂ : Type u_9\nX₃ : Type u_10\nY₁ : Type u_11\nY₂ : Type u_12\nY₃ : Type u_13\ninst✝⁵ : AddCommMonoid X₁\ninst✝⁴ : AddCommMonoid X₂\ninst✝³ : AddCommMonoid X₃\ninst✝² : AddCommMonoid Y₁\ninst✝¹ : AddCommMonoid Y₂\ninst✝ : AddCommMonoid Y₃\ne₁ : AddEquiv X₁ Y₁\ne₂ : AddEquiv X₂ Y₂\ne₃ : AddEquiv X₃ Y₃\nf₁₂ : AddMonoidHom X₁ X₂\nf₂₃ : AddMonoidHom X₂ X₃\ng₁₂ : AddMonoidHom Y₁ Y₂\ng₂₃ : AddMonoidHom Y₂ Y₃\ncomm₁₂ : Eq (g₁₂.comp ↑e₁) ((↑e₂).comp f₁₂)\ncomm₂₃ : Eq (g₂₃.comp ↑e₂) ((↑e₃).comp f₂₃)\nH : Function.Exact ⇑f₁₂ ⇑f₂₃\n⊢ Function.Exact ⇑g₁₂ ⇑g₂₃","decl":"lemma of_ladder_addEquiv_of_exact (comm₁₂ : g₁₂.comp e₁ = AddMonoidHom.comp e₂ f₁₂)\n    (comm₂₃ : g₂₃.comp e₂ = AddMonoidHom.comp e₃ f₂₃) (H : Exact f₁₂ f₂₃) : Exact g₁₂ g₂₃ :=\n  (iff_of_ladder_addEquiv _ _ _ comm₁₂ comm₂₃).2 H\n\n"}
{"name":"Function.Exact.of_ladder_addEquiv_of_exact'","module":"Mathlib.Algebra.Exact","initialProofState":"X₁ : Type u_8\nX₂ : Type u_9\nX₃ : Type u_10\nY₁ : Type u_11\nY₂ : Type u_12\nY₃ : Type u_13\ninst✝⁵ : AddCommMonoid X₁\ninst✝⁴ : AddCommMonoid X₂\ninst✝³ : AddCommMonoid X₃\ninst✝² : AddCommMonoid Y₁\ninst✝¹ : AddCommMonoid Y₂\ninst✝ : AddCommMonoid Y₃\ne₁ : AddEquiv X₁ Y₁\ne₂ : AddEquiv X₂ Y₂\ne₃ : AddEquiv X₃ Y₃\nf₁₂ : AddMonoidHom X₁ X₂\nf₂₃ : AddMonoidHom X₂ X₃\ng₁₂ : AddMonoidHom Y₁ Y₂\ng₂₃ : AddMonoidHom Y₂ Y₃\ncomm₁₂ : Eq (g₁₂.comp ↑e₁) ((↑e₂).comp f₁₂)\ncomm₂₃ : Eq (g₂₃.comp ↑e₂) ((↑e₃).comp f₂₃)\nH : Function.Exact ⇑g₁₂ ⇑g₂₃\n⊢ Function.Exact ⇑f₁₂ ⇑f₂₃","decl":"lemma of_ladder_addEquiv_of_exact' (comm₁₂ : g₁₂.comp e₁ = AddMonoidHom.comp e₂ f₁₂)\n    (comm₂₃ : g₂₃.comp e₂ = AddMonoidHom.comp e₃ f₂₃) (H : Exact g₁₂ g₂₃) : Exact f₁₂ f₂₃ :=\n  (iff_of_ladder_addEquiv _ _ _ comm₁₂ comm₂₃).1 H\n\n"}
{"name":"LinearMap.exact_iff","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\n⊢ Iff (Function.Exact ⇑f ⇑g) (Eq (LinearMap.ker g) (LinearMap.range f))","decl":"lemma exact_iff :\n    Exact f g ↔ LinearMap.ker g = LinearMap.range f :=\n  Iff.symm SetLike.ext_iff\n\n"}
{"name":"LinearMap.exact_of_comp_eq_zero_of_ker_le_range","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh1 : Eq (g.comp f) 0\nh2 : LE.le (LinearMap.ker g) (LinearMap.range f)\n⊢ Function.Exact ⇑f ⇑g","decl":"lemma exact_of_comp_eq_zero_of_ker_le_range\n    (h1 : g ∘ₗ f = 0) (h2 : ker g ≤ range f) : Exact f g :=\n  Exact.of_comp_of_mem_range (congrArg DFunLike.coe h1) h2\n\n"}
{"name":"LinearMap.exact_of_comp_of_mem_range","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh1 : Eq (g.comp f) 0\nh2 : ∀ (x : N), Eq (g x) 0 → Membership.mem (LinearMap.range f) x\n⊢ Function.Exact ⇑f ⇑g","decl":"lemma exact_of_comp_of_mem_range\n    (h1 : g ∘ₗ f = 0) (h2 : ∀ x, g x = 0 → x ∈ range f) : Exact f g :=\n  exact_of_comp_eq_zero_of_ker_le_range h1 h2\n\n"}
{"name":"LinearMap.exact_subtype_mkQ","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_8\nN : Type u_10\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nQ : Submodule R N\n⊢ Function.Exact ⇑Q.subtype ⇑Q.mkQ","decl":"lemma exact_subtype_mkQ (Q : Submodule R N) :\n    Exact (Submodule.subtype Q) (Submodule.mkQ Q) := by\n  rw [exact_iff, Submodule.ker_mkQ, Submodule.range_subtype Q]\n\n"}
{"name":"LinearMap.exact_map_mkQ_range","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_8\nM : Type u_9\nN : Type u_10\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Function.Exact ⇑f ⇑(LinearMap.range f).mkQ","decl":"lemma exact_map_mkQ_range (f : M →ₗ[R] N) :\n    Exact f (Submodule.mkQ (range f)) :=\n  exact_iff.mpr <| Submodule.ker_mkQ _\n\n"}
{"name":"LinearMap.exact_subtype_ker_map","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_8\nN : Type u_10\nP : Type u_11\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup N\ninst✝² : AddCommGroup P\ninst✝¹ : Module R N\ninst✝ : Module R P\ng : LinearMap (RingHom.id R) N P\n⊢ Function.Exact ⇑(LinearMap.ker g).subtype ⇑g","decl":"lemma exact_subtype_ker_map (g : N →ₗ[R] P) :\n    Exact (Submodule.subtype (ker g)) g :=\n  exact_iff.mpr <| (Submodule.range_subtype _).symm\n\n"}
{"name":"LinearEquiv.conj_exact_iff_exact","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nN' : Type u_5\nP : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid N'\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R N'\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\ne : LinearEquiv (RingHom.id R) N N'\n⊢ Iff (Function.Exact ⇑((↑e).comp f) ⇑(g.comp ↑e.symm)) (Function.Exact ⇑f ⇑g)","decl":"variable (f g) in\nlemma LinearEquiv.conj_exact_iff_exact (e : N ≃ₗ[R] N') :\n    Function.Exact (e ∘ₗ f) (g ∘ₗ (e.symm : N' →ₗ[R] N)) ↔ Exact f g := by\n  simp_rw [LinearMap.exact_iff, LinearMap.ker_comp, ← e.map_eq_comap, LinearMap.range_comp]\n  exact (Submodule.map_injective_of_injective e.injective).eq_iff\n\n"}
{"name":"Function.Exact.linearMap_ker_eq","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhfg : Function.Exact ⇑f ⇑g\n⊢ Eq (LinearMap.ker g) (LinearMap.range f)","decl":"lemma Exact.linearMap_ker_eq (hfg : Exact f g) : ker g = range f :=\n  SetLike.ext hfg\n\n"}
{"name":"Function.Exact.linearMap_comp_eq_zero","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\n⊢ Eq (g.comp f) 0","decl":"lemma Exact.linearMap_comp_eq_zero (h : Exact f g) : g.comp f = 0 :=\n  DFunLike.coe_injective h.comp_eq_zero\n\n"}
{"name":"Function.Surjective.comp_exact_iff_exact","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\nN : Type u_4\nP : Type u_6\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M'\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\np : LinearMap (RingHom.id R) M' M\nh : Function.Surjective ⇑p\n⊢ Iff (Function.Exact ⇑(f.comp p) ⇑g) (Function.Exact ⇑f ⇑g)","decl":"lemma Surjective.comp_exact_iff_exact {p : M' →ₗ[R] M} (h : Surjective p) :\n    Exact (f ∘ₗ p) g ↔ Exact f g :=\n  iff_of_eq <| forall_congr fun x =>\n    congrArg (g x = 0 ↔ x ∈ ·) (h.range_comp f)\n\n"}
{"name":"Function.Injective.comp_exact_iff_exact","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\nP' : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid P'\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R P'\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\ni : LinearMap (RingHom.id R) P P'\nh : Function.Injective ⇑i\n⊢ Iff (Function.Exact ⇑f ⇑(i.comp g)) (Function.Exact ⇑f ⇑g)","decl":"lemma Injective.comp_exact_iff_exact {i : P →ₗ[R] P'} (h : Injective i) :\n    Exact f (i ∘ₗ g) ↔ Exact f g :=\n  forall_congr' fun _ => iff_congr (LinearMap.map_eq_zero_iff _ h) Iff.rfl\n\n"}
{"name":"Function.Exact.iff_of_ladder_linearEquiv","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\nN : Type u_4\nN' : Type u_5\nP : Type u_6\nP' : Type u_7\ninst✝¹² : Semiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M'\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : AddCommMonoid N'\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid P'\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M'\ninst✝³ : Module R N\ninst✝² : Module R N'\ninst✝¹ : Module R P\ninst✝ : Module R P'\nf₁₂ : LinearMap (RingHom.id R) M N\nf₂₃ : LinearMap (RingHom.id R) N P\ng₁₂ : LinearMap (RingHom.id R) M' N'\ng₂₃ : LinearMap (RingHom.id R) N' P'\ne₁ : LinearEquiv (RingHom.id R) M M'\ne₂ : LinearEquiv (RingHom.id R) N N'\ne₃ : LinearEquiv (RingHom.id R) P P'\nh₁₂ : Eq (g₁₂.comp ↑e₁) ((↑e₂).comp f₁₂)\nh₂₃ : Eq (g₂₃.comp ↑e₂) ((↑e₃).comp f₂₃)\n⊢ Iff (Function.Exact ⇑g₁₂ ⇑g₂₃) (Function.Exact ⇑f₁₂ ⇑f₂₃)","decl":"lemma Exact.iff_of_ladder_linearEquiv\n    (h₁₂ : g₁₂ ∘ₗ e₁ = e₂ ∘ₗ f₁₂) (h₂₃ : g₂₃ ∘ₗ e₂ = e₃ ∘ₗ f₂₃) :\n    Exact g₁₂ g₂₃ ↔ Exact f₁₂ f₂₃ :=\n  iff_of_ladder_addEquiv e₁.toAddEquiv e₂.toAddEquiv e₃.toAddEquiv\n    (f₁₂ := f₁₂) (f₂₃ := f₂₃) (g₁₂ := g₁₂) (g₂₃ := g₂₃)\n    (congr_arg LinearMap.toAddMonoidHom h₁₂) (congr_arg LinearMap.toAddMonoidHom h₂₃)\n\n"}
{"name":"Function.Exact.of_ladder_linearEquiv_of_exact","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\nN : Type u_4\nN' : Type u_5\nP : Type u_6\nP' : Type u_7\ninst✝¹² : Semiring R\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid M'\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : AddCommMonoid N'\ninst✝⁷ : AddCommMonoid P\ninst✝⁶ : AddCommMonoid P'\ninst✝⁵ : Module R M\ninst✝⁴ : Module R M'\ninst✝³ : Module R N\ninst✝² : Module R N'\ninst✝¹ : Module R P\ninst✝ : Module R P'\nf₁₂ : LinearMap (RingHom.id R) M N\nf₂₃ : LinearMap (RingHom.id R) N P\ng₁₂ : LinearMap (RingHom.id R) M' N'\ng₂₃ : LinearMap (RingHom.id R) N' P'\ne₁ : LinearEquiv (RingHom.id R) M M'\ne₂ : LinearEquiv (RingHom.id R) N N'\ne₃ : LinearEquiv (RingHom.id R) P P'\nh₁₂ : Eq (g₁₂.comp ↑e₁) ((↑e₂).comp f₁₂)\nh₂₃ : Eq (g₂₃.comp ↑e₂) ((↑e₃).comp f₂₃)\nH : Function.Exact ⇑f₁₂ ⇑f₂₃\n⊢ Function.Exact ⇑g₁₂ ⇑g₂₃","decl":"lemma Exact.of_ladder_linearEquiv_of_exact\n    (h₁₂ : g₁₂ ∘ₗ e₁ = e₂ ∘ₗ f₁₂) (h₂₃ : g₂₃ ∘ₗ e₂ = e₃ ∘ₗ f₂₃)\n    (H : Exact f₁₂ f₂₃) : Exact g₁₂ g₂₃ := by\n  rwa [iff_of_ladder_linearEquiv h₁₂ h₂₃]\n\n"}
{"name":"Function.Exact.split_tfae'","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\n⊢ (List.cons (And (Function.Injective ⇑f) (Exists fun l => Eq (g.comp l) LinearMap.id)) (List.cons (And (Function.Surjective ⇑g) (Exists fun l => Eq (l.comp f) LinearMap.id)) (List.cons (Exists fun e => And (Eq f ((↑e.symm).comp (LinearMap.inl R M P))) (Eq g ((LinearMap.snd R M P).comp ↑e))) List.nil))).TFAE","decl":"theorem Exact.split_tfae' (h : Function.Exact f g) :\n    List.TFAE [\n      Function.Injective f ∧ ∃ l, g ∘ₗ l = LinearMap.id,\n      Function.Surjective g ∧ ∃ l, l ∘ₗ f = LinearMap.id,\n      ∃ e : N ≃ₗ[R] M × P, f = e.symm ∘ₗ LinearMap.inl R M P ∧ g = LinearMap.snd R M P ∘ₗ e] := by\n  tfae_have 1 → 3\n  | ⟨hf, l, hl⟩ => ⟨_, (h.splitSurjectiveEquiv hf ⟨l, hl⟩).2⟩\n  tfae_have 2 → 3\n  | ⟨hg, l, hl⟩ => ⟨_, (h.splitInjectiveEquiv hg ⟨l, hl⟩).2⟩\n  tfae_have 3 → 1\n  | ⟨e, e₁, e₂⟩ => by\n    have : Function.Injective f := e₁ ▸ e.symm.injective.comp LinearMap.inl_injective\n    exact ⟨this, ⟨_, ((h.splitSurjectiveEquiv this).symm ⟨e, e₁, e₂⟩).2⟩⟩\n  tfae_have 3 → 2\n  | ⟨e, e₁, e₂⟩ => by\n    have : Function.Surjective g := e₂ ▸ Prod.snd_surjective.comp e.surjective\n    exact ⟨this, ⟨_, ((h.splitInjectiveEquiv this).symm ⟨e, e₁, e₂⟩).2⟩⟩\n  tfae_finish\n\n"}
{"name":"Function.Exact.split_tfae","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_8\nM : Type u_9\nN : Type u_10\nP : Type u_11\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\nhf : Function.Injective ⇑f\nhg : Function.Surjective ⇑g\n⊢ (List.cons (Exists fun l => Eq (g.comp l) LinearMap.id) (List.cons (Exists fun l => Eq (l.comp f) LinearMap.id) (List.cons (Exists fun e => And (Eq f ((↑e.symm).comp (LinearMap.inl R M P))) (Eq g ((LinearMap.snd R M P).comp ↑e))) List.nil))).TFAE","decl":"/-- Equivalent characterizations of split exact sequences. Also known as the **Splitting lemma**. -/\ntheorem Exact.split_tfae\n    {R M N P} [Semiring R] [AddCommGroup M] [AddCommGroup N]\n    [AddCommGroup P] [Module R M] [Module R N] [Module R P] {f : M →ₗ[R] N} {g : N →ₗ[R] P}\n    (h : Function.Exact f g) (hf : Function.Injective f) (hg : Function.Surjective g) :\n    List.TFAE [\n      ∃ l, g ∘ₗ l = LinearMap.id,\n      ∃ l, l ∘ₗ f = LinearMap.id,\n      ∃ e : N ≃ₗ[R] M × P, f = e.symm ∘ₗ LinearMap.inl R M P ∧ g = LinearMap.snd R M P ∘ₗ e] := by\n  tfae_have 1 ↔ 3 := by\n    simpa using (h.splitSurjectiveEquiv hf).nonempty_congr\n  tfae_have 2 ↔ 3 := by\n    simpa using (h.splitInjectiveEquiv hg).nonempty_congr\n  tfae_finish\n\n"}
{"name":"Function.Exact.inr_fst","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Function.Exact ⇑(LinearMap.inr R M N) ⇑(LinearMap.fst R M N)","decl":"lemma Exact.inr_fst : Function.Exact (LinearMap.inr R M N) (LinearMap.fst R M N) := by\n  rintro ⟨x, y⟩\n  simp only [LinearMap.fst_apply, @eq_comm _ x, LinearMap.coe_inr, Set.mem_range, Prod.mk.injEq,\n    exists_eq_right]\n\n"}
{"name":"Function.Exact.inl_snd","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Function.Exact ⇑(LinearMap.inl R M N) ⇑(LinearMap.snd R M N)","decl":"lemma Exact.inl_snd : Function.Exact (LinearMap.inl R M N) (LinearMap.snd R M N) := by\n  rintro ⟨x, y⟩\n  simp only [LinearMap.snd_apply, @eq_comm _ y, LinearMap.coe_inl, Set.mem_range, Prod.mk.injEq,\n    exists_eq_left]\n\n"}
{"name":"Function.Exact.exact_mapQ_iff","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhfg : Function.Exact ⇑f ⇑g\np : Submodule R M\nq : Submodule R N\nr : Submodule R P\nhpq : LE.le p (Submodule.comap f q)\nhqr : LE.le q (Submodule.comap g r)\n⊢ Iff (Function.Exact ⇑(p.mapQ q f hpq) ⇑(q.mapQ r g hqr)) (LE.le (Min.min (LinearMap.range g) r) (Submodule.map g q))","decl":"/-- A necessary and sufficient condition for an exact sequence to descend to a quotient. -/\nlemma Exact.exact_mapQ_iff\n    (hfg : Exact f g) {p q r} (hpq : p ≤ comap f q) (hqr : q ≤ comap g r) :\n    Exact (mapQ p q f hpq) (mapQ q r g hqr) ↔ range g ⊓ r ≤ map g q := by\n  rw [exact_iff, ← (comap_injective_of_surjective (mkQ_surjective _)).eq_iff]\n  dsimp only [mapQ]\n  rw [← ker_comp, range_liftQ, liftQ_mkQ, ker_comp, range_comp, comap_map_eq,\n    ker_mkQ, ker_mkQ, ← hfg.linearMap_ker_eq, sup_comm,\n    ← LE.le.le_iff_eq (sup_le hqr (ker_le_comap g)),\n    ← comap_map_eq, ← map_le_iff_le_comap, map_comap_eq]\n\n"}
{"name":"LinearMap.exact_iff_of_surjective_of_bijective_of_injective","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\ninst✝¹² : Ring R\nM₁ : Type u_8\nM₂ : Type u_9\nM₃ : Type u_10\nN₁ : Type u_11\nN₂ : Type u_12\nN₃ : Type u_13\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : AddCommMonoid N₁\ninst✝⁷ : AddCommMonoid N₂\ninst✝⁶ : AddCommMonoid N₃\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R N₃\nf : LinearMap (RingHom.id R) M₁ M₂\ng : LinearMap (RingHom.id R) M₂ M₃\nf' : LinearMap (RingHom.id R) N₁ N₂\ng' : LinearMap (RingHom.id R) N₂ N₃\nτ₁ : LinearMap (RingHom.id R) M₁ N₁\nτ₂ : LinearMap (RingHom.id R) M₂ N₂\nτ₃ : LinearMap (RingHom.id R) M₃ N₃\ncomm₁₂ : Eq (f'.comp τ₁) (τ₂.comp f)\ncomm₂₃ : Eq (g'.comp τ₂) (τ₃.comp g)\nh₁ : Function.Surjective ⇑τ₁\nh₂ : Function.Bijective ⇑τ₂\nh₃ : Function.Injective ⇑τ₃\n⊢ Iff (Function.Exact ⇑f ⇑g) (Function.Exact ⇑f' ⇑g')","decl":"/-- When we have a commutative diagram from a sequence of two linear maps to another,\nsuch that the left vertical map is surjective, the middle vertical map is bijective and the right\nvertical map is injective, then the upper row is exact iff the lower row is.\nSee `ShortComplex.exact_iff_of_epi_of_isIso_of_mono` in the file\n`Algebra.Homology.ShortComplex.Exact` for the categorical version of this result. -/\nlemma exact_iff_of_surjective_of_bijective_of_injective\n  {M₁ M₂ M₃ N₁ N₂ N₃ : Type*} [AddCommMonoid M₁] [AddCommMonoid M₂] [AddCommMonoid M₃]\n  [AddCommMonoid N₁] [AddCommMonoid N₂] [AddCommMonoid N₃]\n  [Module R M₁] [Module R M₂] [Module R M₃]\n  [Module R N₁] [Module R N₂] [Module R N₃]\n  (f : M₁ →ₗ[R] M₂) (g : M₂ →ₗ[R] M₃) (f' : N₁ →ₗ[R] N₂) (g' : N₂ →ₗ[R] N₃)\n  (τ₁ : M₁ →ₗ[R] N₁) (τ₂ : M₂ →ₗ[R] N₂) (τ₃ : M₃ →ₗ[R] N₃)\n  (comm₁₂ : f'.comp τ₁ = τ₂.comp f) (comm₂₃ : g'.comp τ₂ = τ₃.comp g)\n  (h₁ : Function.Surjective τ₁) (h₂ : Function.Bijective τ₂) (h₃ : Function.Injective τ₃) :\n    Function.Exact f g ↔ Function.Exact f' g' :=\n  AddMonoidHom.exact_iff_of_surjective_of_bijective_of_injective\n    f.toAddMonoidHom g.toAddMonoidHom f'.toAddMonoidHom g'.toAddMonoidHom\n    τ₁.toAddMonoidHom τ₂.toAddMonoidHom τ₃.toAddMonoidHom\n    (by ext; apply DFunLike.congr_fun comm₁₂) (by ext; apply DFunLike.congr_fun comm₂₃) h₁ h₂ h₃\n\n"}
{"name":"LinearMap.surjective_range_liftQ","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : LE.le (LinearMap.range f) (LinearMap.ker g)\nhg : Function.Surjective ⇑g\n⊢ Function.Surjective ⇑((LinearMap.range f).liftQ g h)","decl":"lemma surjective_range_liftQ (h : range f ≤ ker g) (hg : Function.Surjective g) :\n    Function.Surjective ((range f).liftQ g h) := by\n  intro x₃\n  obtain ⟨x₂, rfl⟩ := hg x₃\n  exact ⟨Submodule.Quotient.mk x₂, rfl⟩\n\n"}
{"name":"LinearMap.ker_eq_bot_range_liftQ_iff","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : LE.le (LinearMap.range f) (LinearMap.ker g)\n⊢ Iff (Eq (LinearMap.ker ((LinearMap.range f).liftQ g h)) Bot.bot) (Eq (LinearMap.ker g) (LinearMap.range f))","decl":"lemma ker_eq_bot_range_liftQ_iff (h : range f ≤ ker g) :\n    ker ((range f).liftQ g h) = ⊥ ↔ ker g = range f := by\n  simp only [Submodule.ext_iff, mem_ker, Submodule.mem_bot, mem_range]\n  constructor\n  · intro hfg x\n    simpa using hfg (Submodule.Quotient.mk x)\n  · intro hfg x\n    obtain ⟨x, rfl⟩ := Submodule.Quotient.mk_surjective _ x\n    simpa using hfg x\n\n"}
{"name":"LinearMap.injective_range_liftQ_of_exact","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\n⊢ Function.Injective ⇑((LinearMap.range f).liftQ g ⋯)","decl":"lemma injective_range_liftQ_of_exact (h : Function.Exact f g) :\n    Function.Injective ((range f).liftQ g (h · |>.mpr)) := by\n  simpa only [← LinearMap.ker_eq_bot, ker_eq_bot_range_liftQ_iff, exact_iff] using h\n\n"}
{"name":"Function.Exact.linearEquivOfSurjective_apply","module":"Mathlib.Algebra.Exact","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nP : Type u_6\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : AddCommGroup P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nh : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\na✝ : HasQuotient.Quotient N (LinearMap.range f)\n⊢ Eq ((h.linearEquivOfSurjective hg) a✝) (((LinearMap.range f).liftQ g ⋯) a✝)","decl":"/-- The linear equivalence `(N ⧸ LinearMap.range f) ≃ₗ[A] P` associated to\nan exact sequence `M → N → P → 0` of `R`-modules. -/\n@[simps! apply]\nnoncomputable def Function.Exact.linearEquivOfSurjective (h : Function.Exact f g)\n    (hg : Function.Surjective g) : (N ⧸ LinearMap.range f) ≃ₗ[R] P :=\n  LinearEquiv.ofBijective ((LinearMap.range f).liftQ g (h · |>.mpr))\n      ⟨LinearMap.injective_range_liftQ_of_exact h,\n        LinearMap.surjective_range_liftQ _ hg⟩\n\n"}
