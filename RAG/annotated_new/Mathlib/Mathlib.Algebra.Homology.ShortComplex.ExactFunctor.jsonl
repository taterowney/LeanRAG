{"name":"CategoryTheory.Functor.preservesFiniteLimits_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.Additive\ninst✝³ : F.PreservesHomology\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasKernels C\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- An additive functor which preserves homology preserves finite limits. -/\nlemma preservesFiniteLimits_of_preservesHomology\n    [HasFiniteProducts C] [HasKernels C] : PreservesFiniteLimits F := by\n  have := fun {X Y : C} (f : X ⟶ Y) ↦ PreservesHomology.preservesKernel F f\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryProducts\n  have : HasEqualizers C := Preadditive.hasEqualizers_of_hasKernels\n  have : HasZeroObject D :=\n    ⟨F.obj 0, by rw [IsZero.iff_id_eq_zero, ← F.map_id, id_zero, F.map_zero]⟩\n  exact preservesFiniteLimits_of_preservesKernels F\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteColimits_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁴ : F.Additive\ninst✝³ : F.PreservesHomology\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝ : CategoryTheory.Limits.HasCokernels C\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- An additive which preserves homology preserves finite colimits. -/\nlemma preservesFiniteColimits_of_preservesHomology\n    [HasFiniteCoproducts C] [HasCokernels C] : PreservesFiniteColimits F := by\n  have := fun {X Y : C} (f : X ⟶ Y) ↦ PreservesHomology.preservesCokernel F f\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryCoproducts\n  have : HasCoequalizers C := Preadditive.hasCoequalizers_of_hasCokernels\n  have : HasZeroObject D :=\n    ⟨F.obj 0, by rw [IsZero.iff_id_eq_zero, ← F.map_id, id_zero, F.map_zero]⟩\n  exact preservesFiniteColimits_of_preservesCokernels F\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_preserves_shortExact_left","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nh : ∀ (S : CategoryTheory.ShortComplex C), S.ShortExact → And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))\n⊢ F.PreservesMonomorphisms","decl":"/--\nIf a functor `F : C ⥤ D` preserves short exact sequences on the left hand side, (i.e.\nif `0 ⟶ A ⟶ B ⟶ C ⟶ 0` is exact then `0 ⟶ F(A) ⟶ F(B) ⟶ F(C)` is exact)\nthen it preserves monomorphism.\n-/\nlemma preservesMonomorphisms_of_preserves_shortExact_left\n    (h : ∀ (S : ShortComplex C), S.ShortExact → (S.map F).Exact ∧ Mono (F.map S.f)) :\n    F.PreservesMonomorphisms where\n  preserves f := h _ { exact := exact_cokernel f } |>.2\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteLimits_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ (List.cons (∀ (S : CategoryTheory.ShortComplex C), S.ShortExact → And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))) (List.cons (∀ (S : CategoryTheory.ShortComplex C), And S.Exact (CategoryTheory.Mono S.f) → And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))) (List.cons (∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F) (List.cons (CategoryTheory.Limits.PreservesFiniteLimits F) List.nil)))).TFAE","decl":"/--\nFor an addivite functor `F : C ⥤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences on the left hand side, i.e. if `0 ⟶ A ⟶ B ⟶ C ⟶ 0` is exact\n  then `0 ⟶ F(A) ⟶ F(B) ⟶ F(C)` is exact.\n- `F` preserves exact sequences on the left hand side, i.e. if `A ⟶ B ⟶ C` is exact where `A ⟶ B`\n  is mono, then `F(A) ⟶ F(B) ⟶ F(C)` is exact and `F(A) ⟶ F(B)` is mono as well.\n- `F` preserves kernels.\n- `F` preserves finite limits.\n-/\nlemma preservesFiniteLimits_tfae : List.TFAE\n    [\n      ∀ (S : ShortComplex C), S.ShortExact → (S.map F).Exact ∧ Mono (F.map S.f),\n      ∀ (S : ShortComplex C), S.Exact ∧ Mono S.f → (S.map F).Exact ∧ Mono (F.map S.f),\n      ∀ ⦃X Y : C⦄ (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F,\n      PreservesFiniteLimits F\n    ] := by\n  tfae_have 1 → 2\n  | hF, S, ⟨hS, hf⟩ => by\n    have := preservesMonomorphisms_of_preserves_shortExact_left F hF\n    refine ⟨?_, inferInstance⟩\n    let T := ShortComplex.mk S.f (Abelian.coimage.π S.g) (Abelian.comp_coimage_π_eq_zero S.zero)\n    let φ : T.map F ⟶ S.map F :=\n      { τ₁ := 𝟙 _\n        τ₂ := 𝟙 _\n        τ₃ := F.map <| Abelian.factorThruCoimage S.g\n        comm₂₃ := show 𝟙 _ ≫ F.map _ = F.map (cokernel.π _) ≫ _ by\n          rw [Category.id_comp, ← F.map_comp, cokernel.π_desc] }\n    exact (exact_iff_of_epi_of_isIso_of_mono φ).1 (hF T ⟨(S.exact_iff_exact_coimage_π).1 hS⟩).1\n\n  tfae_have 2 → 3\n  | hF, X, Y, f => by\n    refine preservesLimit_of_preserves_limit_cone (kernelIsKernel f) ?_\n    apply (KernelFork.isLimitMapConeEquiv _ F).2\n    let S := ShortComplex.mk _ _ (kernel.condition f)\n    let hS := hF S ⟨exact_kernel f, inferInstance⟩\n    have : Mono (S.map F).f := hS.2\n    exact hS.1.fIsKernel\n\n  tfae_have 3 → 4\n  | hF => by\n    exact preservesFiniteLimits_of_preservesKernels F\n\n  tfae_have 4 → 1\n  | ⟨_⟩, S, hS =>\n    (S.map F).exact_and_mono_f_iff_f_is_kernel |>.2 ⟨KernelFork.mapIsLimit _ hS.fIsKernel F⟩\n\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_of_preserves_shortExact_right","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nh : ∀ (S : CategoryTheory.ShortComplex C), S.ShortExact → And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))\n⊢ F.PreservesEpimorphisms","decl":"/--\nIf a functor `F : C ⥤ D` preserves exact sequences on the right hand side (i.e.\nif `0 ⟶ A ⟶ B ⟶ C ⟶ 0` is exact then `F(A) ⟶ F(B) ⟶ F(C) ⟶ 0` is exact),\nthen it preserves epimorphisms.\n-/\nlemma preservesEpimorphisms_of_preserves_shortExact_right\n    (h : ∀ (S : ShortComplex C), S.ShortExact → (S.map F).Exact ∧ Epi (F.map S.g)) :\n    F.PreservesEpimorphisms where\n  preserves f := h _ { exact := exact_kernel f } |>.2\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteColimits_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ (List.cons (∀ (S : CategoryTheory.ShortComplex C), S.ShortExact → And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))) (List.cons (∀ (S : CategoryTheory.ShortComplex C), And S.Exact (CategoryTheory.Epi S.g) → And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))) (List.cons (∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F) (List.cons (CategoryTheory.Limits.PreservesFiniteColimits F) List.nil)))).TFAE","decl":"/--\nFor an addivite functor `F : C ⥤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences on the right hand side, i.e. if `0 ⟶ A ⟶ B ⟶ C ⟶ 0` is\n  exact then `F(A) ⟶ F(B) ⟶ F(C) ⟶ 0` is exact.\n- `F` preserves exact sequences on the right hand side, i.e. if `A ⟶ B ⟶ C` is exact where `B ⟶ C`\n  is epi, then `F(A) ⟶ F(B) ⟶ F(C) ⟶ 0` is exact and `F(B) ⟶ F(C)` is epi as well.\n- `F` preserves cokernels.\n- `F` preserves finite colimits.\n-/\nlemma preservesFiniteColimits_tfae : List.TFAE\n    [\n      ∀ (S : ShortComplex C), S.ShortExact → (S.map F).Exact ∧ Epi (F.map S.g),\n      ∀ (S : ShortComplex C), S.Exact ∧ Epi S.g → (S.map F).Exact ∧ Epi (F.map S.g),\n      ∀ ⦃X Y : C⦄ (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F,\n      PreservesFiniteColimits F\n    ] := by\n  tfae_have 1 → 2\n  | hF, S, ⟨hS, hf⟩ => by\n    have := preservesEpimorphisms_of_preserves_shortExact_right F hF\n    refine ⟨?_, inferInstance⟩\n    let T := ShortComplex.mk (Abelian.image.ι S.f) S.g (Abelian.image_ι_comp_eq_zero S.zero)\n    let φ : S.map F ⟶ T.map F :=\n      { τ₁ := F.map <| Abelian.factorThruImage S.f\n        τ₂ := 𝟙 _\n        τ₃ := 𝟙 _\n        comm₁₂ := show _ ≫ F.map (kernel.ι _) = F.map _ ≫ 𝟙 _ by\n          rw [← F.map_comp, Abelian.image.fac, Category.comp_id] }\n    exact (exact_iff_of_epi_of_isIso_of_mono φ).2 (hF T ⟨(S.exact_iff_exact_image_ι).1 hS⟩).1\n\n  tfae_have 2 → 3\n  | hF, X, Y, f => by\n    refine preservesColimit_of_preserves_colimit_cocone (cokernelIsCokernel f) ?_\n    apply (CokernelCofork.isColimitMapCoconeEquiv _ F).2\n    let S := ShortComplex.mk _ _ (cokernel.condition f)\n    let hS := hF S ⟨exact_cokernel f, inferInstance⟩\n    have : Epi (S.map F).g := hS.2\n    exact hS.1.gIsCokernel\n\n  tfae_have 3 → 4\n  | hF => by\n    exact preservesFiniteColimits_of_preservesCokernels F\n\n  tfae_have 4 → 1\n  | ⟨_⟩, S, hS => (S.map F).exact_and_epi_g_iff_g_is_cokernel |>.2\n    ⟨CokernelCofork.mapIsColimit _ hS.gIsCokernel F⟩\n\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Functor.exact_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ (List.cons (∀ (S : CategoryTheory.ShortComplex C), S.ShortExact → (S.map F).ShortExact) (List.cons (∀ (S : CategoryTheory.ShortComplex C), S.Exact → (S.map F).Exact) (List.cons F.PreservesHomology (List.cons (And (CategoryTheory.Limits.PreservesFiniteLimits F) (CategoryTheory.Limits.PreservesFiniteColimits F)) List.nil)))).TFAE","decl":"/--\nFor an additive functor `F : C ⥤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences, i.e. if `0 ⟶ A ⟶ B ⟶ C ⟶ 0` is exact then\n  `0 ⟶ F(A) ⟶ F(B) ⟶ F(C) ⟶ 0` is exact.\n- `F` preserves exact sequences, i.e. if `A ⟶ B ⟶ C` is exact then `F(A) ⟶ F(B) ⟶ F(C)` is exact.\n- `F` preserves homology.\n- `F` preserves both finite limits and finite colimits.\n-/\nlemma exact_tfae : List.TFAE\n    [\n      ∀ (S : ShortComplex C), S.ShortExact → (S.map F).ShortExact,\n      ∀ (S : ShortComplex C), S.Exact → (S.map F).Exact,\n      PreservesHomology F,\n      PreservesFiniteLimits F ∧ PreservesFiniteColimits F\n    ] := by\n  tfae_have 1 → 3\n  | hF => by\n    refine ⟨fun {X Y} f ↦ ?_, fun {X Y} f ↦ ?_⟩\n    · have h := (preservesFiniteLimits_tfae F |>.out 0 2 |>.1 fun S hS ↦\n        And.intro (hF S hS).exact (hF S hS).mono_f)\n      exact h f\n    · have h := (preservesFiniteColimits_tfae F |>.out 0 2 |>.1 fun S hS ↦\n        And.intro (hF S hS).exact (hF S hS).epi_g)\n      exact h f\n\n  tfae_have 2 → 1\n  | hF, S, hS => by\n    have : Mono (S.map F).f := exact_iff_mono _ (by simp) |>.1 <|\n      hF (.mk (0 : 0 ⟶ S.X₁) S.f <| by simp) (exact_iff_mono _ (by simp) |>.2 hS.mono_f)\n    have : Epi (S.map F).g := exact_iff_epi _ (by simp) |>.1 <|\n      hF (.mk S.g (0 : S.X₃ ⟶ 0) <| by simp) (exact_iff_epi _ (by simp) |>.2 hS.epi_g)\n    exact ⟨hF S hS.exact⟩\n\n  tfae_have 3 → 4\n  | h => ⟨preservesFiniteLimits_of_preservesHomology F,\n      preservesFiniteColimits_of_preservesHomology F⟩\n\n  tfae_have 4 → 2\n  | ⟨h1, h2⟩, _, h => h.map F\n\n  tfae_finish\n\n"}
