{"name":"CategoryTheory.Functor.preservesFiniteLimits_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¸ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_4, u_2} D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœâ´ : F.Additive\ninstâœÂ³ : F.PreservesHomology\ninstâœÂ² : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteProducts C\ninstâœ : CategoryTheory.Limits.HasKernels C\nâŠ¢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- An additive functor which preserves homology preserves finite limits. -/\nlemma preservesFiniteLimits_of_preservesHomology\n    [HasFiniteProducts C] [HasKernels C] : PreservesFiniteLimits F := by\n  have := fun {X Y : C} (f : X âŸ¶ Y) â†¦ PreservesHomology.preservesKernel F f\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryProducts\n  have : HasEqualizers C := Preadditive.hasEqualizers_of_hasKernels\n  have : HasZeroObject D :=\n    âŸ¨F.obj 0, by rw [IsZero.iff_id_eq_zero, â† F.map_id, id_zero, F.map_zero]âŸ©\n  exact preservesFiniteLimits_of_preservesKernels F\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteColimits_of_preservesHomology","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¸ : CategoryTheory.Category.{u_3, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_4, u_2} D\ninstâœâ¶ : CategoryTheory.Preadditive C\ninstâœâµ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninstâœâ´ : F.Additive\ninstâœÂ³ : F.PreservesHomology\ninstâœÂ² : CategoryTheory.Limits.HasZeroObject C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteCoproducts C\ninstâœ : CategoryTheory.Limits.HasCokernels C\nâŠ¢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- An additive which preserves homology preserves finite colimits. -/\nlemma preservesFiniteColimits_of_preservesHomology\n    [HasFiniteCoproducts C] [HasCokernels C] : PreservesFiniteColimits F := by\n  have := fun {X Y : C} (f : X âŸ¶ Y) â†¦ PreservesHomology.preservesCokernel F f\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryCoproducts\n  have : HasCoequalizers C := Preadditive.hasCoequalizers_of_hasCokernels\n  have : HasZeroObject D :=\n    âŸ¨F.obj 0, by rw [IsZero.iff_id_eq_zero, â† F.map_id, id_zero, F.map_zero]âŸ©\n  exact preservesFiniteColimits_of_preservesCokernels F\n\n"}
{"name":"CategoryTheory.Functor.preservesMonomorphisms_of_preserves_shortExact_left","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Abelian C\ninstâœÂ¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninstâœ : F.Additive\nh : âˆ€ (S : CategoryTheory.ShortComplex C), S.ShortExact â†’ And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))\nâŠ¢ F.PreservesMonomorphisms","decl":"/--\nIf a functor `F : C â¥¤ D` preserves short exact sequences on the left hand side, (i.e.\nif `0 âŸ¶ A âŸ¶ B âŸ¶ C âŸ¶ 0` is exact then `0 âŸ¶ F(A) âŸ¶ F(B) âŸ¶ F(C)` is exact)\nthen it preserves monomorphism.\n-/\nlemma preservesMonomorphisms_of_preserves_shortExact_left\n    (h : âˆ€ (S : ShortComplex C), S.ShortExact â†’ (S.map F).Exact âˆ§ Mono (F.map S.f)) :\n    F.PreservesMonomorphisms where\n  preserves f := h _ { exact := exact_cokernel f } |>.2\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteLimits_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Abelian C\ninstâœÂ¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninstâœ : F.Additive\nâŠ¢ (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), S.ShortExact â†’ And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))) (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), And S.Exact (CategoryTheory.Mono S.f) â†’ And (S.map F).Exact (CategoryTheory.Mono (F.map S.f))) (List.cons (âˆ€ â¦ƒX Y : Câ¦„ (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F) (List.cons (CategoryTheory.Limits.PreservesFiniteLimits F) List.nil)))).TFAE","decl":"/--\nFor an addivite functor `F : C â¥¤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences on the left hand side, i.e. if `0 âŸ¶ A âŸ¶ B âŸ¶ C âŸ¶ 0` is exact\n  then `0 âŸ¶ F(A) âŸ¶ F(B) âŸ¶ F(C)` is exact.\n- `F` preserves exact sequences on the left hand side, i.e. if `A âŸ¶ B âŸ¶ C` is exact where `A âŸ¶ B`\n  is mono, then `F(A) âŸ¶ F(B) âŸ¶ F(C)` is exact and `F(A) âŸ¶ F(B)` is mono as well.\n- `F` preserves kernels.\n- `F` preserves finite limits.\n-/\nlemma preservesFiniteLimits_tfae : List.TFAE\n    [\n      âˆ€ (S : ShortComplex C), S.ShortExact â†’ (S.map F).Exact âˆ§ Mono (F.map S.f),\n      âˆ€ (S : ShortComplex C), S.Exact âˆ§ Mono S.f â†’ (S.map F).Exact âˆ§ Mono (F.map S.f),\n      âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), PreservesLimit (parallelPair f 0) F,\n      PreservesFiniteLimits F\n    ] := by\n  tfae_have 1 â†’ 2\n  | hF, S, âŸ¨hS, hfâŸ© => by\n    have := preservesMonomorphisms_of_preserves_shortExact_left F hF\n    refine âŸ¨?_, inferInstanceâŸ©\n    let T := ShortComplex.mk S.f (Abelian.coimage.Ï€ S.g) (Abelian.comp_coimage_Ï€_eq_zero S.zero)\n    let Ï† : T.map F âŸ¶ S.map F :=\n      { Ï„â‚ := ğŸ™ _\n        Ï„â‚‚ := ğŸ™ _\n        Ï„â‚ƒ := F.map <| Abelian.factorThruCoimage S.g\n        commâ‚‚â‚ƒ := show ğŸ™ _ â‰« F.map _ = F.map (cokernel.Ï€ _) â‰« _ by\n          rw [Category.id_comp, â† F.map_comp, cokernel.Ï€_desc] }\n    exact (exact_iff_of_epi_of_isIso_of_mono Ï†).1 (hF T âŸ¨(S.exact_iff_exact_coimage_Ï€).1 hSâŸ©).1\n\n  tfae_have 2 â†’ 3\n  | hF, X, Y, f => by\n    refine preservesLimit_of_preserves_limit_cone (kernelIsKernel f) ?_\n    apply (KernelFork.isLimitMapConeEquiv _ F).2\n    let S := ShortComplex.mk _ _ (kernel.condition f)\n    let hS := hF S âŸ¨exact_kernel f, inferInstanceâŸ©\n    have : Mono (S.map F).f := hS.2\n    exact hS.1.fIsKernel\n\n  tfae_have 3 â†’ 4\n  | hF => by\n    exact preservesFiniteLimits_of_preservesKernels F\n\n  tfae_have 4 â†’ 1\n  | âŸ¨_âŸ©, S, hS =>\n    (S.map F).exact_and_mono_f_iff_f_is_kernel |>.2 âŸ¨KernelFork.mapIsLimit _ hS.fIsKernel FâŸ©\n\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Functor.preservesEpimorphisms_of_preserves_shortExact_right","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Abelian C\ninstâœÂ¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninstâœ : F.Additive\nh : âˆ€ (S : CategoryTheory.ShortComplex C), S.ShortExact â†’ And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))\nâŠ¢ F.PreservesEpimorphisms","decl":"/--\nIf a functor `F : C â¥¤ D` preserves exact sequences on the right hand side (i.e.\nif `0 âŸ¶ A âŸ¶ B âŸ¶ C âŸ¶ 0` is exact then `F(A) âŸ¶ F(B) âŸ¶ F(C) âŸ¶ 0` is exact),\nthen it preserves epimorphisms.\n-/\nlemma preservesEpimorphisms_of_preserves_shortExact_right\n    (h : âˆ€ (S : ShortComplex C), S.ShortExact â†’ (S.map F).Exact âˆ§ Epi (F.map S.g)) :\n    F.PreservesEpimorphisms where\n  preserves f := h _ { exact := exact_kernel f } |>.2\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteColimits_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Abelian C\ninstâœÂ¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninstâœ : F.Additive\nâŠ¢ (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), S.ShortExact â†’ And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))) (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), And S.Exact (CategoryTheory.Epi S.g) â†’ And (S.map F).Exact (CategoryTheory.Epi (F.map S.g))) (List.cons (âˆ€ â¦ƒX Y : Câ¦„ (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F) (List.cons (CategoryTheory.Limits.PreservesFiniteColimits F) List.nil)))).TFAE","decl":"/--\nFor an addivite functor `F : C â¥¤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences on the right hand side, i.e. if `0 âŸ¶ A âŸ¶ B âŸ¶ C âŸ¶ 0` is\n  exact then `F(A) âŸ¶ F(B) âŸ¶ F(C) âŸ¶ 0` is exact.\n- `F` preserves exact sequences on the right hand side, i.e. if `A âŸ¶ B âŸ¶ C` is exact where `B âŸ¶ C`\n  is epi, then `F(A) âŸ¶ F(B) âŸ¶ F(C) âŸ¶ 0` is exact and `F(B) âŸ¶ F(C)` is epi as well.\n- `F` preserves cokernels.\n- `F` preserves finite colimits.\n-/\nlemma preservesFiniteColimits_tfae : List.TFAE\n    [\n      âˆ€ (S : ShortComplex C), S.ShortExact â†’ (S.map F).Exact âˆ§ Epi (F.map S.g),\n      âˆ€ (S : ShortComplex C), S.Exact âˆ§ Epi S.g â†’ (S.map F).Exact âˆ§ Epi (F.map S.g),\n      âˆ€ â¦ƒX Y : Câ¦„ (f : X âŸ¶ Y), PreservesColimit (parallelPair f 0) F,\n      PreservesFiniteColimits F\n    ] := by\n  tfae_have 1 â†’ 2\n  | hF, S, âŸ¨hS, hfâŸ© => by\n    have := preservesEpimorphisms_of_preserves_shortExact_right F hF\n    refine âŸ¨?_, inferInstanceâŸ©\n    let T := ShortComplex.mk (Abelian.image.Î¹ S.f) S.g (Abelian.image_Î¹_comp_eq_zero S.zero)\n    let Ï† : S.map F âŸ¶ T.map F :=\n      { Ï„â‚ := F.map <| Abelian.factorThruImage S.f\n        Ï„â‚‚ := ğŸ™ _\n        Ï„â‚ƒ := ğŸ™ _\n        commâ‚â‚‚ := show _ â‰« F.map (kernel.Î¹ _) = F.map _ â‰« ğŸ™ _ by\n          rw [â† F.map_comp, Abelian.image.fac, Category.comp_id] }\n    exact (exact_iff_of_epi_of_isIso_of_mono Ï†).2 (hF T âŸ¨(S.exact_iff_exact_image_Î¹).1 hSâŸ©).1\n\n  tfae_have 2 â†’ 3\n  | hF, X, Y, f => by\n    refine preservesColimit_of_preserves_colimit_cocone (cokernelIsCokernel f) ?_\n    apply (CokernelCofork.isColimitMapCoconeEquiv _ F).2\n    let S := ShortComplex.mk _ _ (cokernel.condition f)\n    let hS := hF S âŸ¨exact_cokernel f, inferInstanceâŸ©\n    have : Epi (S.map F).g := hS.2\n    exact hS.1.gIsCokernel\n\n  tfae_have 3 â†’ 4\n  | hF => by\n    exact preservesFiniteColimits_of_preservesCokernels F\n\n  tfae_have 4 â†’ 1\n  | âŸ¨_âŸ©, S, hS => (S.map F).exact_and_epi_g_iff_g_is_cokernel |>.2\n    âŸ¨CokernelCofork.mapIsColimit _ hS.gIsCokernel FâŸ©\n\n  tfae_finish\n\n"}
{"name":"CategoryTheory.Functor.exact_tfae","module":"Mathlib.Algebra.Homology.ShortComplex.ExactFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_2} D\ninstâœÂ² : CategoryTheory.Abelian C\ninstâœÂ¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninstâœ : F.Additive\nâŠ¢ (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), S.ShortExact â†’ (S.map F).ShortExact) (List.cons (âˆ€ (S : CategoryTheory.ShortComplex C), S.Exact â†’ (S.map F).Exact) (List.cons F.PreservesHomology (List.cons (And (CategoryTheory.Limits.PreservesFiniteLimits F) (CategoryTheory.Limits.PreservesFiniteColimits F)) List.nil)))).TFAE","decl":"/--\nFor an additive functor `F : C â¥¤ D` between abelian categories, the following are equivalent:\n- `F` preserves short exact sequences, i.e. if `0 âŸ¶ A âŸ¶ B âŸ¶ C âŸ¶ 0` is exact then\n  `0 âŸ¶ F(A) âŸ¶ F(B) âŸ¶ F(C) âŸ¶ 0` is exact.\n- `F` preserves exact sequences, i.e. if `A âŸ¶ B âŸ¶ C` is exact then `F(A) âŸ¶ F(B) âŸ¶ F(C)` is exact.\n- `F` preserves homology.\n- `F` preserves both finite limits and finite colimits.\n-/\nlemma exact_tfae : List.TFAE\n    [\n      âˆ€ (S : ShortComplex C), S.ShortExact â†’ (S.map F).ShortExact,\n      âˆ€ (S : ShortComplex C), S.Exact â†’ (S.map F).Exact,\n      PreservesHomology F,\n      PreservesFiniteLimits F âˆ§ PreservesFiniteColimits F\n    ] := by\n  tfae_have 1 â†’ 3\n  | hF => by\n    refine âŸ¨fun {X Y} f â†¦ ?_, fun {X Y} f â†¦ ?_âŸ©\n    Â· have h := (preservesFiniteLimits_tfae F |>.out 0 2 |>.1 fun S hS â†¦\n        And.intro (hF S hS).exact (hF S hS).mono_f)\n      exact h f\n    Â· have h := (preservesFiniteColimits_tfae F |>.out 0 2 |>.1 fun S hS â†¦\n        And.intro (hF S hS).exact (hF S hS).epi_g)\n      exact h f\n\n  tfae_have 2 â†’ 1\n  | hF, S, hS => by\n    have : Mono (S.map F).f := exact_iff_mono _ (by simp) |>.1 <|\n      hF (.mk (0 : 0 âŸ¶ S.Xâ‚) S.f <| by simp) (exact_iff_mono _ (by simp) |>.2 hS.mono_f)\n    have : Epi (S.map F).g := exact_iff_epi _ (by simp) |>.1 <|\n      hF (.mk S.g (0 : S.Xâ‚ƒ âŸ¶ 0) <| by simp) (exact_iff_epi _ (by simp) |>.2 hS.epi_g)\n    exact âŸ¨hF S hS.exactâŸ©\n\n  tfae_have 3 â†’ 4\n  | h => âŸ¨preservesFiniteLimits_of_preservesHomology F,\n      preservesFiniteColimits_of_preservesHomology FâŸ©\n\n  tfae_have 4 â†’ 2\n  | âŸ¨h1, h2âŸ©, _, h => h.map F\n\n  tfae_finish\n\n"}
