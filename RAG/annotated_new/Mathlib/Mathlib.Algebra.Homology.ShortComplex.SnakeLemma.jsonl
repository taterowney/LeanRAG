{"name":"CategoryTheory.ShortComplex.SnakeInput.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\ninst✝ : SizeOf C\nL₀ L₁ L₂ L₃ : CategoryTheory.ShortComplex C\nv₀₁ : Quiver.Hom L₀ L₁\nv₁₂ : Quiver.Hom L₁ L₂\nv₂₃ : Quiver.Hom L₂ L₃\nw₀₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₀₁ v₁₂) 0) _auto✝\nw₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₁₂ v₂₃) 0) _auto✝\nh₀ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι v₀₁ w₀₂)\nh₃ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ v₂₃ w₁₃)\nL₁_exact : L₁.Exact\nepi_L₁_g : CategoryTheory.Epi L₁.g\nL₂_exact : L₂.Exact\nmono_L₂_f : CategoryTheory.Mono L₂.f\n⊢ Eq (SizeOf.sizeOf { L₀ := L₀, L₁ := L₁, L₂ := L₂, L₃ := L₃, v₀₁ := v₀₁, v₁₂ := v₁₂, v₂₃ := v₂₃, w₀₂ := w₀₂, w₁₃ := w₁₃, h₀ := h₀, h₃ := h₃, L₁_exact := L₁_exact, epi_L₁_g := epi_L₁_g, L₂_exact := L₂_exact, mono_L₂_f := mono_L₂_f }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf L₀)) (SizeOf.sizeOf L₁)) (SizeOf.sizeOf L₂)) (SizeOf.sizeOf L₃)) (SizeOf.sizeOf v₀₁)) (SizeOf.sizeOf v₁₂)) (SizeOf.sizeOf v₂₃)) (SizeOf.sizeOf w₀₂)) (SizeOf.sizeOf w₁₃)) (SizeOf.sizeOf h₀)) (SizeOf.sizeOf h₃)) (SizeOf.sizeOf L₁_exact)) (SizeOf.sizeOf epi_L₁_g)) (SizeOf.sizeOf L₂_exact)) (SizeOf.sizeOf mono_L₂_f))","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.v₁₂ self.v₂₃) 0","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nL₀✝ L₁✝ L₂✝ L₃✝ : CategoryTheory.ShortComplex C\nv₀₁✝ : Quiver.Hom L₀✝ L₁✝\nv₁₂✝ : Quiver.Hom L₁✝ L₂✝\nv₂₃✝ : Quiver.Hom L₂✝ L₃✝\nw₀₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₀₁✝ v₁₂✝) 0) _auto✝\nw₁₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₁₂✝ v₂₃✝) 0) _auto✝\nh₀✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι v₀₁✝ w₀₂✝)\nh₃✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ v₂₃✝ w₁₃✝)\nL₁_exact✝ : L₁✝.Exact\nepi_L₁_g✝ : CategoryTheory.Epi L₁✝.g\nL₂_exact✝ : L₂✝.Exact\nmono_L₂_f✝ : CategoryTheory.Mono L₂✝.f\nL₀ L₁ L₂ L₃ : CategoryTheory.ShortComplex C\nv₀₁ : Quiver.Hom L₀ L₁\nv₁₂ : Quiver.Hom L₁ L₂\nv₂₃ : Quiver.Hom L₂ L₃\nw₀₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₀₁ v₁₂) 0) _auto✝\nw₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₁₂ v₂₃) 0) _auto✝\nh₀ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι v₀₁ w₀₂)\nh₃ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ v₂₃ w₁₃)\nL₁_exact : L₁.Exact\nepi_L₁_g : CategoryTheory.Epi L₁.g\nL₂_exact : L₂.Exact\nmono_L₂_f : CategoryTheory.Mono L₂.f\nx✝ : Eq { L₀ := L₀✝, L₁ := L₁✝, L₂ := L₂✝, L₃ := L₃✝, v₀₁ := v₀₁✝, v₁₂ := v₁₂✝, v₂₃ := v₂₃✝, w₀₂ := w₀₂✝, w₁₃ := w₁₃✝, h₀ := h₀✝, h₃ := h₃✝, L₁_exact := L₁_exact✝, epi_L₁_g := epi_L₁_g✝, L₂_exact := L₂_exact✝, mono_L₂_f := mono_L₂_f✝ } { L₀ := L₀, L₁ := L₁, L₂ := L₂, L₃ := L₃, v₀₁ := v₀₁, v₁₂ := v₁₂, v₂₃ := v₂₃, w₀₂ := w₀₂, w₁₃ := w₁₃, h₀ := h₀, h₃ := h₃, L₁_exact := L₁_exact, epi_L₁_g := epi_L₁_g, L₂_exact := L₂_exact, mono_L₂_f := mono_L₂_f }\n⊢ And (Eq L₀✝ L₀) (And (Eq L₁✝ L₁) (And (Eq L₂✝ L₂) (And (Eq L₃✝ L₃) (And (HEq v₀₁✝ v₀₁) (And (HEq v₁₂✝ v₁₂) (And (HEq v₂₃✝ v₂₃) (And (HEq h₀✝ h₀) (HEq h₃✝ h₃))))))))","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nL₀✝ L₁✝ L₂✝ L₃✝ : CategoryTheory.ShortComplex C\nv₀₁✝ : Quiver.Hom L₀✝ L₁✝\nv₁₂✝ : Quiver.Hom L₁✝ L₂✝\nv₂₃✝ : Quiver.Hom L₂✝ L₃✝\nw₀₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₀₁✝ v₁₂✝) 0) _auto✝\nw₁₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₁₂✝ v₂₃✝) 0) _auto✝\nh₀✝ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι v₀₁✝ w₀₂✝)\nh₃✝ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ v₂₃✝ w₁₃✝)\nL₁_exact✝ : L₁✝.Exact\nepi_L₁_g✝ : CategoryTheory.Epi L₁✝.g\nL₂_exact✝ : L₂✝.Exact\nmono_L₂_f✝ : CategoryTheory.Mono L₂✝.f\nL₀ L₁ L₂ L₃ : CategoryTheory.ShortComplex C\nv₀₁ : Quiver.Hom L₀ L₁\nv₁₂ : Quiver.Hom L₁ L₂\nv₂₃ : Quiver.Hom L₂ L₃\nw₀₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₀₁ v₁₂) 0) _auto✝\nw₁₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp v₁₂ v₂₃) 0) _auto✝\nh₀ : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.KernelFork.ofι v₀₁ w₀₂)\nh₃ : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.CokernelCofork.ofπ v₂₃ w₁₃)\nL₁_exact : L₁.Exact\nepi_L₁_g : CategoryTheory.Epi L₁.g\nL₂_exact : L₂.Exact\nmono_L₂_f : CategoryTheory.Mono L₂.f\n⊢ Eq (Eq { L₀ := L₀✝, L₁ := L₁✝, L₂ := L₂✝, L₃ := L₃✝, v₀₁ := v₀₁✝, v₁₂ := v₁₂✝, v₂₃ := v₂₃✝, w₀₂ := w₀₂✝, w₁₃ := w₁₃✝, h₀ := h₀✝, h₃ := h₃✝, L₁_exact := L₁_exact✝, epi_L₁_g := epi_L₁_g✝, L₂_exact := L₂_exact✝, mono_L₂_f := mono_L₂_f✝ } { L₀ := L₀, L₁ := L₁, L₂ := L₂, L₃ := L₃, v₀₁ := v₀₁, v₁₂ := v₁₂, v₂₃ := v₂₃, w₀₂ := w₀₂, w₁₃ := w₁₃, h₀ := h₀, h₃ := h₃, L₁_exact := L₁_exact, epi_L₁_g := epi_L₁_g, L₂_exact := L₂_exact, mono_L₂_f := mono_L₂_f }) (And (Eq L₀✝ L₀) (And (Eq L₁✝ L₁) (And (Eq L₂✝ L₂) (And (Eq L₃✝ L₃) (And (HEq v₀₁✝ v₀₁) (And (HEq v₁₂✝ v₁₂) (And (HEq v₂₃✝ v₂₃) (And (HEq h₀✝ h₀) (HEq h₃✝ h₃)))))))))","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.epi_L₁_g","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Epi self.L₁.g","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ self.L₂.Exact","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.v₀₁ self.v₁₂) 0","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mono_L₂_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Mono self.L₂.f","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\n⊢ self.L₁.Exact","decl":"/-- A snake input in an abelian category `C` consists of morphisms\nof short complexes `L₀ ⟶ L₁ ⟶ L₂ ⟶ L₃` (which should be visualized vertically) such\nthat `L₀` and `L₃` are respectively the kernel and the cokernel of `L₁ ⟶ L₂`,\n`L₁` and `L₂` are exact, `L₁.g` is epi and `L₂.f` is mono. -/\nstructure SnakeInput where\n  /-- the zeroth row -/\n  L₀ : ShortComplex C\n  /-- the first row -/\n  L₁ : ShortComplex C\n  /-- the second row -/\n  L₂ : ShortComplex C\n  /-- the third row -/\n  L₃ : ShortComplex C\n  /-- the morphism from the zeroth row to the first row -/\n  v₀₁ : L₀ ⟶ L₁\n  /-- the morphism from the first row to the second row -/\n  v₁₂ : L₁ ⟶ L₂\n  /-- the morphism from the second row to the third row -/\n  v₂₃ : L₂ ⟶ L₃\n  w₀₂ : v₀₁ ≫ v₁₂ = 0 := by aesop_cat\n  w₁₃ : v₁₂ ≫ v₂₃ = 0 := by aesop_cat\n  /-- `L₀` is the kernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₀ : IsLimit (KernelFork.ofι _ w₀₂)\n  /-- `L₃` is the cokernel of `v₁₂ : L₁ ⟶ L₂`. -/\n  h₃ : IsColimit (CokernelCofork.ofπ _ w₁₃)\n  L₁_exact : L₁.Exact\n  epi_L₁_g : Epi L₁.g\n  L₂_exact : L₂.Exact\n  mono_L₂_f : Mono L₂.f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom self.L₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.v₀₁ (CategoryTheory.CategoryStruct.comp self.v₁₂ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] w₀₂ w₁₃\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nself : CategoryTheory.ShortComplex.SnakeInput C\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom self.L₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.v₁₂ (CategoryTheory.CategoryStruct.comp self.v₂₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"attribute [reassoc (attr := simp)] w₀₂ w₁₃\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_L₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.L₂ S.L₁.op","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_v₂₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.v₂₃ (CategoryTheory.ShortComplex.opMap S.v₀₁)","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_L₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.L₃ S.L₀.op","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_v₀₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.v₀₁ (CategoryTheory.ShortComplex.opMap S.v₂₃)","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_L₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.L₁ S.L₂.op","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_L₀","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.L₀ S.L₃.op","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_v₁₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.v₁₂ (CategoryTheory.ShortComplex.opMap S.v₁₂)","decl":"/-- The snake input in the opposite category that is deduced from a snake input. -/\n@[simps]\nnoncomputable def op : SnakeInput Cᵒᵖ where\n  L₀ := S.L₃.op\n  L₁ := S.L₂.op\n  L₂ := S.L₁.op\n  L₃ := S.L₀.op\n  epi_L₁_g := by dsimp; infer_instance\n  mono_L₂_f := by dsimp; infer_instance\n  v₀₁ := opMap S.v₂₃\n  v₁₂ := opMap S.v₁₂\n  v₂₃ := opMap S.v₀₁\n  w₀₂ := congr_arg opMap S.w₁₃\n  w₁₃ := congr_arg opMap S.w₀₂\n  h₀ := isLimitForkMapOfIsLimit' (ShortComplex.opEquiv C).functor _\n      (CokernelCofork.IsColimit.ofπOp _ _ S.h₃)\n  h₃ := isColimitCoforkMapOfIsColimit' (ShortComplex.opEquiv C).functor _\n      (KernelFork.IsLimit.ofιOp _ _ S.h₀)\n  L₁_exact := S.L₂_exact.op\n  L₂_exact := S.L₁_exact.op\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₁ (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₁ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₁ : S.v₀₁.τ₁ ≫ S.v₁₂.τ₁ = 0 := by\n  rw [← comp_τ₁, S.w₀₂, zero_τ₁]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₁ S.v₁₂.τ₁) 0","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₁ : S.v₀₁.τ₁ ≫ S.v₁₂.τ₁ = 0 := by\n  rw [← comp_τ₁, S.w₀₂, zero_τ₁]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₂ S.v₁₂.τ₂) 0","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₂ : S.v₀₁.τ₂ ≫ S.v₁₂.τ₂ = 0 := by\n  rw [← comp_τ₂, S.w₀₂, zero_τ₂]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₂ (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₂ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₂ : S.v₀₁.τ₂ ≫ S.v₁₂.τ₂ = 0 := by\n  rw [← comp_τ₂, S.w₀₂, zero_τ₂]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₃ S.v₁₂.τ₃) 0","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₃ : S.v₀₁.τ₃ ≫ S.v₁₂.τ₃ = 0 := by\n  rw [← comp_τ₃, S.w₀₂, zero_τ₃]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₀₂_τ₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₀₁.τ₃ (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₀₂_τ₃ : S.v₀₁.τ₃ ≫ S.v₁₂.τ₃ = 0 := by\n  rw [← comp_τ₃, S.w₀₂, zero_τ₃]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₃.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₁ (CategoryTheory.CategoryStruct.comp S.v₂₃.τ₁ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₁ : S.v₁₂.τ₁ ≫ S.v₂₃.τ₁ = 0 := by\n  rw [← comp_τ₁, S.w₁₃, zero_τ₁]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₁ S.v₂₃.τ₁) 0","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₁ : S.v₁₂.τ₁ ≫ S.v₂₃.τ₁ = 0 := by\n  rw [← comp_τ₁, S.w₁₃, zero_τ₁]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₃.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₂ (CategoryTheory.CategoryStruct.comp S.v₂₃.τ₂ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₂ : S.v₁₂.τ₂ ≫ S.v₂₃.τ₂ = 0 := by\n  rw [← comp_τ₂, S.w₁₃, zero_τ₂]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₂ S.v₂₃.τ₂) 0","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₂ : S.v₁₂.τ₂ ≫ S.v₂₃.τ₂ = 0 := by\n  rw [← comp_τ₂, S.w₁₃, zero_τ₂]\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₃.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₃ (CategoryTheory.CategoryStruct.comp S.v₂₃.τ₃ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₃ : S.v₁₂.τ₃ ≫ S.v₂₃.τ₃ = 0 := by\n  rw [← comp_τ₃, S.w₁₃, zero_τ₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.w₁₃_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₃ S.v₂₃.τ₃) 0","decl":"@[reassoc (attr := simp)] lemma w₁₃_τ₃ : S.v₁₂.τ₃ ≫ S.v₂₃.τ₃ = 0 := by\n  rw [← comp_τ₃, S.w₁₃, zero_τ₃]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mono_v₀₁_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Mono S.v₀₁.τ₁","decl":"instance mono_v₀₁_τ₁ : Mono S.v₀₁.τ₁ := mono_of_isLimit_fork S.h₀τ₁\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mono_v₀₁_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Mono S.v₀₁.τ₂","decl":"instance mono_v₀₁_τ₂ : Mono S.v₀₁.τ₂ := mono_of_isLimit_fork S.h₀τ₂\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mono_v₀₁_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Mono S.v₀₁.τ₃","decl":"instance mono_v₀₁_τ₃ : Mono S.v₀₁.τ₃ := mono_of_isLimit_fork S.h₀τ₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₁_up","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₀₁.τ₁ S.v₁₂.τ₁ ⋯).Exact","decl":"/-- The upper part of the first column of the snake diagram is exact. -/\nlemma exact_C₁_up : (ShortComplex.mk S.v₀₁.τ₁ S.v₁₂.τ₁\n    (by rw [← comp_τ₁, S.w₀₂, zero_τ₁])).Exact :=\n  exact_of_f_is_kernel _ S.h₀τ₁\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₂_up","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₀₁.τ₂ S.v₁₂.τ₂ ⋯).Exact","decl":"/-- The upper part of the second column of the snake diagram is exact. -/\nlemma exact_C₂_up : (ShortComplex.mk S.v₀₁.τ₂ S.v₁₂.τ₂\n    (by rw [← comp_τ₂, S.w₀₂, zero_τ₂])).Exact :=\n  exact_of_f_is_kernel _ S.h₀τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₃_up","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₀₁.τ₃ S.v₁₂.τ₃ ⋯).Exact","decl":"/-- The upper part of the third column of the snake diagram is exact. -/\nlemma exact_C₃_up : (ShortComplex.mk S.v₀₁.τ₃ S.v₁₂.τ₃\n    (by rw [← comp_τ₃, S.w₀₂, zero_τ₃])).Exact :=\n  exact_of_f_is_kernel _ S.h₀τ₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.mono_L₀_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\ninst✝ : CategoryTheory.Mono S.L₁.f\n⊢ CategoryTheory.Mono S.L₀.f","decl":"instance mono_L₀_f [Mono S.L₁.f] : Mono S.L₀.f := by\n  have : Mono (S.L₀.f ≫ S.v₀₁.τ₂) := by\n    rw [← S.v₀₁.comm₁₂]\n    apply mono_comp\n  exact mono_of_mono _ S.v₀₁.τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.epi_v₂₃_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Epi S.v₂₃.τ₁","decl":"instance epi_v₂₃_τ₁ : Epi S.v₂₃.τ₁ := epi_of_isColimit_cofork S.h₃τ₁\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.epi_v₂₃_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Epi S.v₂₃.τ₂","decl":"instance epi_v₂₃_τ₂ : Epi S.v₂₃.τ₂ := epi_of_isColimit_cofork S.h₃τ₂\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.epi_v₂₃_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Epi S.v₂₃.τ₃","decl":"instance epi_v₂₃_τ₃ : Epi S.v₂₃.τ₃ := epi_of_isColimit_cofork S.h₃τ₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₁_down","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₁₂.τ₁ S.v₂₃.τ₁ ⋯).Exact","decl":"/-- The lower part of the first column of the snake diagram is exact. -/\nlemma exact_C₁_down : (ShortComplex.mk S.v₁₂.τ₁ S.v₂₃.τ₁\n    (by rw [← comp_τ₁, S.w₁₃, zero_τ₁])).Exact :=\n  exact_of_g_is_cokernel _ S.h₃τ₁\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₂_down","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₁₂.τ₂ S.v₂₃.τ₂ ⋯).Exact","decl":"/-- The lower part of the second column of the snake diagram is exact. -/\nlemma exact_C₂_down : (ShortComplex.mk S.v₁₂.τ₂ S.v₂₃.τ₂\n    (by rw [← comp_τ₂, S.w₁₃, zero_τ₂])).Exact :=\n  exact_of_g_is_cokernel _ S.h₃τ₂\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.exact_C₃_down","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ (CategoryTheory.ShortComplex.mk S.v₁₂.τ₃ S.v₂₃.τ₃ ⋯).Exact","decl":"/-- The lower part of the third column of the snake diagram is exact. -/\nlemma exact_C₃_down : (ShortComplex.mk S.v₁₂.τ₃ S.v₂₃.τ₃\n    (by rw [← comp_τ₃, S.w₁₃, zero_τ₃])).Exact :=\n  exact_of_g_is_cokernel _ S.h₃τ₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.epi_L₃_g","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\ninst✝ : CategoryTheory.Epi S.L₂.g\n⊢ CategoryTheory.Epi S.L₃.g","decl":"instance epi_L₃_g [Epi S.L₂.g] : Epi S.L₃.g := by\n  have : Epi (S.v₂₃.τ₂ ≫ S.L₃.g) := by\n    rw [S.v₂₃.comm₂₃]\n    apply epi_comp\n  exact epi_of_epi S.v₂₃.τ₂ _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.L₀.Exact","decl":"lemma L₀_exact : S.L₀.Exact := by\n  rw [ShortComplex.exact_iff_exact_up_to_refinements]\n  intro A x₂ hx₂\n  obtain ⟨A₁, π₁, hπ₁, y₁, hy₁⟩ := S.L₁_exact.exact_up_to_refinements (x₂ ≫ S.v₀₁.τ₂)\n    (by rw [assoc, S.v₀₁.comm₂₃, reassoc_of% hx₂, zero_comp])\n  have hy₁' : y₁ ≫ S.v₁₂.τ₁ = 0 := by\n    simp only [← cancel_mono S.L₂.f, assoc, zero_comp, S.v₁₂.comm₁₂,\n      ← reassoc_of% hy₁, w₀₂_τ₂, comp_zero]\n  obtain ⟨x₁, hx₁⟩ : ∃ x₁, x₁ ≫ S.v₀₁.τ₁ = y₁ := ⟨_, S.exact_C₁_up.lift_f y₁ hy₁'⟩\n  refine ⟨A₁, π₁, hπ₁, x₁, ?_⟩\n  simp only [← cancel_mono S.v₀₁.τ₂, assoc, ← S.v₀₁.comm₁₂, reassoc_of% hx₁, hy₁]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₃_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.L₃.Exact","decl":"lemma L₃_exact : S.L₃.Exact := S.op.L₀_exact.unop\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.lift_φ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nA : C\na : Quiver.Hom A S.L₁.X₂\nb : Quiver.Hom A S.L₀.X₃\nh : Eq (CategoryTheory.CategoryStruct.comp a S.L₁.g) (CategoryTheory.CategoryStruct.comp b S.v₀₁.τ₃)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift a b h) S.φ₂) (CategoryTheory.CategoryStruct.comp a S.v₁₂.τ₂)","decl":"@[reassoc (attr := simp)]\nlemma lift_φ₂ {A : C} (a : A ⟶ S.L₁.X₂) (b : A ⟶ S.L₀.X₃) (h : a ≫ S.L₁.g = b ≫ S.v₀₁.τ₃) :\n    pullback.lift a b h ≫ S.φ₂ = a ≫ S.v₁₂.τ₂ := by\n  simp [φ₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.lift_φ₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nA : C\na : Quiver.Hom A S.L₁.X₂\nb : Quiver.Hom A S.L₀.X₃\nh✝ : Eq (CategoryTheory.CategoryStruct.comp a S.L₁.g) (CategoryTheory.CategoryStruct.comp b S.v₀₁.τ₃)\nZ : C\nh : Quiver.Hom S.L₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.lift a b h✝) (CategoryTheory.CategoryStruct.comp S.φ₂ h)) (CategoryTheory.CategoryStruct.comp a (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₂ h))","decl":"@[reassoc (attr := simp)]\nlemma lift_φ₂ {A : C} (a : A ⟶ S.L₁.X₂) (b : A ⟶ S.L₀.X₃) (h : a ≫ S.L₁.g = b ≫ S.v₀₁.τ₃) :\n    pullback.lift a b h ≫ S.φ₂ = a ≫ S.v₁₂.τ₂ := by\n  simp [φ₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.φ₁_L₂_f_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.φ₁ (CategoryTheory.CategoryStruct.comp S.L₂.f h)) (CategoryTheory.CategoryStruct.comp S.φ₂ h)","decl":"@[reassoc (attr := simp)] lemma φ₁_L₂_f : S.φ₁ ≫ S.L₂.f = S.φ₂ := S.L₂_exact.lift_f _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.φ₁_L₂_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.φ₁ S.L₂.f) S.φ₂","decl":"@[reassoc (attr := simp)] lemma φ₁_L₂_f : S.φ₁ ≫ S.L₂.f = S.φ₂ := S.L₂_exact.lift_f _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁_f_φ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀'.f S.φ₁) S.v₁₂.τ₁","decl":"@[reassoc (attr := simp)] lemma L₁_f_φ₁ : S.L₀'.f ≫ S.φ₁ = S.v₁₂.τ₁ := by\n  dsimp only [L₀']\n  simp only [← cancel_mono S.L₂.f, assoc, φ₁_L₂_f, φ₂, pullback.lift_fst_assoc,\n    S.v₁₂.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁_f_φ₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀'.f (CategoryTheory.CategoryStruct.comp S.φ₁ h)) (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₁ h)","decl":"@[reassoc (attr := simp)] lemma L₁_f_φ₁ : S.L₀'.f ≫ S.φ₁ = S.v₁₂.τ₁ := by\n  dsimp only [L₀']\n  simp only [← cancel_mono S.L₂.f, assoc, φ₁_L₂_f, φ₂, pullback.lift_fst_assoc,\n    S.v₁₂.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.instEpiGL₀'","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ CategoryTheory.Epi S.L₀'.g","decl":"instance : Epi S.L₀'.g := by dsimp only [L₀']; infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.instMonoFL₀'OfL₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\ninst✝ : CategoryTheory.Mono S.L₁.f\n⊢ CategoryTheory.Mono S.L₀'.f","decl":"instance [Mono S.L₁.f] : Mono S.L₀'.f :=\n  mono_of_mono_fac (show S.L₀'.f ≫ pullback.fst _ _ = S.L₁.f by simp [L₀'])\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀'_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.L₀'.Exact","decl":"lemma L₀'_exact : S.L₀'.Exact := by\n  rw [ShortComplex.exact_iff_exact_up_to_refinements]\n  intro A x₂ hx₂\n  dsimp [L₀'] at x₂ hx₂\n  obtain ⟨A', π, hπ, x₁, fac⟩ := S.L₁_exact.exact_up_to_refinements (x₂ ≫ pullback.fst _ _)\n    (by rw [assoc, pullback.condition, reassoc_of% hx₂, zero_comp])\n  exact ⟨A', π, hπ, x₁, pullback.hom_ext (by simpa [L₀'] using fac) (by simp [L₀', hx₂])⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.snd_δ","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd S.L₁.g S.v₀₁.τ₃) S.δ) (CategoryTheory.CategoryStruct.comp S.φ₁ S.v₂₃.τ₁)","decl":"@[reassoc (attr := simp)]\nlemma snd_δ : (pullback.snd _ _ : S.P ⟶ _) ≫ S.δ = S.φ₁ ≫ S.v₂₃.τ₁ :=\n  S.L₀'_exact.g_desc _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.snd_δ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₃.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd S.L₁.g S.v₀₁.τ₃) (CategoryTheory.CategoryStruct.comp S.δ h)) (CategoryTheory.CategoryStruct.comp S.φ₁ (CategoryTheory.CategoryStruct.comp S.v₂₃.τ₁ h))","decl":"@[reassoc (attr := simp)]\nlemma snd_δ : (pullback.snd _ _ : S.P ⟶ _) ≫ S.δ = S.φ₁ ≫ S.v₂₃.τ₁ :=\n  S.L₀'_exact.g_desc _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.snd_δ_inr","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd S.L₁.g S.v₀₁.τ₃) (CategoryTheory.CategoryStruct.comp S.δ (CategoryTheory.Limits.pushout.inr S.L₂.f S.v₂₃.τ₁))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst S.L₁.g S.v₀₁.τ₃) (CategoryTheory.CategoryStruct.comp S.v₁₂.τ₂ (CategoryTheory.Limits.pushout.inl S.L₂.f S.v₂₃.τ₁)))","decl":"lemma snd_δ_inr : (pullback.snd _ _ : S.P ⟶ _) ≫ S.δ ≫ (pushout.inr _ _ : _ ⟶ S.P') =\n    pullback.fst _ _ ≫ S.v₁₂.τ₂ ≫ pushout.inl _ _ := by\n  simp only [snd_δ_assoc, ← pushout.condition, φ₂, φ₁_L₂_f_assoc, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀X₂ToP_comp_pullback_snd_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₀.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀X₂ToP (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd S.L₁.g S.v₀₁.τ₃) h)) (CategoryTheory.CategoryStruct.comp S.L₀.g h)","decl":"@[reassoc]\nlemma L₀X₂ToP_comp_pullback_snd : S.L₀X₂ToP ≫ pullback.snd _ _ = S.L₀.g := by simp\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀X₂ToP_comp_pullback_snd","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀X₂ToP (CategoryTheory.Limits.pullback.snd S.L₁.g S.v₀₁.τ₃)) S.L₀.g","decl":"@[reassoc]\nlemma L₀X₂ToP_comp_pullback_snd : S.L₀X₂ToP ≫ pullback.snd _ _ = S.L₀.g := by simp\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀X₂ToP_comp_φ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀X₂ToP S.φ₁) 0","decl":"@[reassoc]\nlemma L₀X₂ToP_comp_φ₁ : S.L₀X₂ToP ≫ S.φ₁ = 0 := by\n  simp only [← cancel_mono S.L₂.f, L₀X₂ToP, assoc, φ₂, φ₁_L₂_f,\n    pullback.lift_fst_assoc, w₀₂_τ₂, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀X₂ToP_comp_φ₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nZ : C\nh : Quiver.Hom S.L₂.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀X₂ToP (CategoryTheory.CategoryStruct.comp S.φ₁ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma L₀X₂ToP_comp_φ₁ : S.L₀X₂ToP ≫ S.φ₁ = 0 := by\n  simp only [← cancel_mono S.L₂.f, L₀X₂ToP, assoc, φ₂, φ₁_L₂_f,\n    pullback.lift_fst_assoc, w₀₂_τ₂, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₀_g_δ","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.L₀.g S.δ) 0","decl":"lemma L₀_g_δ : S.L₀.g ≫ S.δ = 0 := by\n  erw [← L₀X₂ToP_comp_pullback_snd, assoc, S.L₀'_exact.g_desc,\n    L₀X₂ToP_comp_φ₁_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.δ_L₃_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.δ S.L₃.f) 0","decl":"lemma δ_L₃_f : S.δ ≫ S.L₃.f = 0 := by\n  erw [← cancel_epi S.L₀'.g, S.L₀'_exact.g_desc_assoc, assoc, S.v₂₃.comm₁₂, S.φ₁_L₂_f_assoc,\n    φ₂, assoc, w₁₃_τ₂, comp_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_X₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₁'.X₁ S.L₀.X₂","decl":"/-- The short complex `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\n@[simps]\nnoncomputable def L₁' : ShortComplex C := ShortComplex.mk _ _ S.L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_g","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₁'.g S.δ","decl":"/-- The short complex `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\n@[simps]\nnoncomputable def L₁' : ShortComplex C := ShortComplex.mk _ _ S.L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₁'.f S.L₀.g","decl":"/-- The short complex `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\n@[simps]\nnoncomputable def L₁' : ShortComplex C := ShortComplex.mk _ _ S.L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_X₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₁'.X₃ S.L₃.X₁","decl":"/-- The short complex `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\n@[simps]\nnoncomputable def L₁' : ShortComplex C := ShortComplex.mk _ _ S.L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₁'.X₂ S.L₀.X₃","decl":"/-- The short complex `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\n@[simps]\nnoncomputable def L₁' : ShortComplex C := ShortComplex.mk _ _ S.L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_X₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₂'.X₁ S.L₀.X₃","decl":"/-- The short complex `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\n@[simps]\nnoncomputable def L₂' : ShortComplex C := ShortComplex.mk _ _ S.δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_f","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₂'.f S.δ","decl":"/-- The short complex `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\n@[simps]\nnoncomputable def L₂' : ShortComplex C := ShortComplex.mk _ _ S.δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₂'.X₂ S.L₃.X₁","decl":"/-- The short complex `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\n@[simps]\nnoncomputable def L₂' : ShortComplex C := ShortComplex.mk _ _ S.δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_g","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₂'.g S.L₃.f","decl":"/-- The short complex `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\n@[simps]\nnoncomputable def L₂' : ShortComplex C := ShortComplex.mk _ _ S.δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_X₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.L₂'.X₃ S.L₃.X₂","decl":"/-- The short complex `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\n@[simps]\nnoncomputable def L₂' : ShortComplex C := ShortComplex.mk _ _ S.δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₁'_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.L₁'.Exact","decl":"/-- Exactness of `L₀.X₂ ⟶ L₀.X₃ ⟶ L₃.X₁`. -/\nlemma L₁'_exact : S.L₁'.Exact := by\n  rw [ShortComplex.exact_iff_exact_up_to_refinements]\n  intro A₀ x₃ hx₃\n  dsimp at x₃ hx₃\n  obtain ⟨A₁, π₁, hπ₁, p, hp⟩ := surjective_up_to_refinements_of_epi S.L₀'.g x₃\n  dsimp [L₀'] at p hp\n  have hp' : (p ≫ S.φ₁) ≫ S.v₂₃.τ₁ = 0 := by\n    rw [assoc, ← S.snd_δ, ← reassoc_of% hp, hx₃, comp_zero]\n  obtain ⟨A₂, π₂, hπ₂, x₁, hx₁⟩ := S.exact_C₁_down.exact_up_to_refinements (p ≫ S.φ₁) hp'\n  dsimp at x₁ hx₁\n  let x₂' := x₁ ≫ S.L₁.f\n  let x₂ := π₂ ≫ p ≫ pullback.fst _ _\n  have hx₂' : (x₂ - x₂') ≫ S.v₁₂.τ₂ = 0 := by\n    simp only [x₂, x₂', sub_comp, assoc, ← S.v₁₂.comm₁₂, ← reassoc_of% hx₁, φ₂, φ₁_L₂_f, sub_self]\n  let k₂ : A₂ ⟶ S.L₀.X₂ := S.exact_C₂_up.lift _ hx₂'\n  have hk₂ : k₂ ≫ S.v₀₁.τ₂ = x₂ - x₂' := S.exact_C₂_up.lift_f _ _\n  have hk₂' : k₂ ≫ S.L₀.g = π₂ ≫ p ≫ pullback.snd _ _ := by\n    simp only [x₂, x₂', ← cancel_mono S.v₀₁.τ₃, assoc, ← S.v₀₁.comm₂₃, reassoc_of% hk₂,\n      sub_comp, S.L₁.zero, comp_zero, sub_zero, pullback.condition]\n  exact ⟨A₂, π₂ ≫ π₁, epi_comp _ _, k₂, by simp only [assoc, L₁'_f, ← hk₂', hp]⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.op_δ","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq S.op.δ S.δ.op","decl":"lemma op_δ : S.op.δ = S.δ.op := Quiver.Hom.unop_inj (by\n  rw [Quiver.Hom.unop_op, ← cancel_mono (pushout.inr _ _ : _ ⟶ S.P'),\n    ← cancel_epi (pullback.snd _ _ : S.P ⟶ _), S.snd_δ_inr,\n    ← cancel_mono S.P'IsoUnopOpP.hom, ← cancel_epi S.PIsoUnopOpP'.inv,\n    P'IsoUnopOpP, PIsoUnopOpP', assoc, assoc, assoc, assoc,\n    pushoutIsoUnopPullback_inr_hom, pullbackIsoUnopPushout_inv_snd_assoc,\n    pushoutIsoUnopPullback_inl_hom, pullbackIsoUnopPushout_inv_fst_assoc]\n  apply Quiver.Hom.op_inj\n  simpa only [op_comp, Quiver.Hom.op_unop, assoc] using S.op.snd_δ_inr)\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.L₂'_exact","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.L₂'.Exact","decl":"/-- Exactness of `L₀.X₃ ⟶ L₃.X₁ ⟶ L₃.X₂`. -/\nlemma L₂'_exact : S.L₂'.Exact := by\n  rw [← exact_op_iff, exact_iff_of_iso S.L₂'OpIso]\n  exact S.op.L₁'_exact\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.snake_lemma","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ S.composableArrows.Exact","decl":"open ComposableArrows in\n/-- The diagram `S.L₀.X₁ ⟶ S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂ ⟶ S.L₃.X₃` is exact\nfor any `S : SnakeInput C`. -/\nlemma snake_lemma : S.composableArrows.Exact :=\n  exact_of_δ₀ S.L₀_exact.exact_toComposableArrows\n    (exact_of_δ₀ S.L₁'_exact.exact_toComposableArrows\n    (exact_of_δ₀ S.L₂'_exact.exact_toComposableArrows\n    S.L₃_exact.exact_toComposableArrows))\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.δ_eq","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\nA : C\nx₃ : Quiver.Hom A S.L₀.X₃\nx₂ : Quiver.Hom A S.L₁.X₂\nx₁ : Quiver.Hom A S.L₂.X₁\nh₂ : Eq (CategoryTheory.CategoryStruct.comp x₂ S.L₁.g) (CategoryTheory.CategoryStruct.comp x₃ S.v₀₁.τ₃)\nh₁ : Eq (CategoryTheory.CategoryStruct.comp x₁ S.L₂.f) (CategoryTheory.CategoryStruct.comp x₂ S.v₁₂.τ₂)\n⊢ Eq (CategoryTheory.CategoryStruct.comp x₃ S.δ) (CategoryTheory.CategoryStruct.comp x₁ S.v₂₃.τ₁)","decl":"lemma δ_eq {A : C} (x₃ : A ⟶ S.L₀.X₃) (x₂ : A ⟶ S.L₁.X₂) (x₁ : A ⟶ S.L₂.X₁)\n    (h₂ : x₂ ≫ S.L₁.g = x₃ ≫ S.v₀₁.τ₃) (h₁ : x₁ ≫ S.L₂.f = x₂ ≫ S.v₁₂.τ₂) :\n    x₃ ≫ S.δ = x₁ ≫ S.v₂₃.τ₁ := by\n  have H := (pullback.lift x₂ x₃ h₂) ≫= S.snd_δ\n  rw [pullback.lift_snd_assoc] at H\n  rw [H, ← assoc]\n  congr 1\n  simp only [← cancel_mono S.L₂.f, assoc, φ₁_L₂_f, lift_φ₂, h₁]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\ninst✝ : SizeOf C\nf₀ : Quiver.Hom S₁.L₀ S₂.L₀\nf₁ : Quiver.Hom S₁.L₁ S₂.L₁\nf₂ : Quiver.Hom S₁.L₂ S₂.L₂\nf₃ : Quiver.Hom S₁.L₃ S₂.L₃\ncomm₀₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₀ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ f₁)) _auto✝\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₁ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ f₂)) _auto✝\ncomm₂₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₂ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ f₃)) _auto✝\n⊢ Eq (SizeOf.sizeOf { f₀ := f₀, f₁ := f₁, f₂ := f₂, f₃ := f₃, comm₀₁ := comm₀₁, comm₁₂ := comm₁₂, comm₂₃ := comm₂₃ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f₀)) (SizeOf.sizeOf f₁)) (SizeOf.sizeOf f₂)) (SizeOf.sizeOf f₃)) (SizeOf.sizeOf comm₀₁)) (SizeOf.sizeOf comm₁₂)) (SizeOf.sizeOf comm₂₃))","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.ext_iff","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nx y : S₁.Hom S₂\n⊢ Iff (Eq x y) (And (Eq x.f₀ y.f₀) (And (Eq x.f₁ y.f₁) (And (Eq x.f₂ y.f₂) (Eq x.f₃ y.f₃))))","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf₀✝ : Quiver.Hom S₁.L₀ S₂.L₀\nf₁✝ : Quiver.Hom S₁.L₁ S₂.L₁\nf₂✝ : Quiver.Hom S₁.L₂ S₂.L₂\nf₃✝ : Quiver.Hom S₁.L₃ S₂.L₃\ncomm₀₁✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₀✝ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ f₁✝)) _auto✝\ncomm₁₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₁✝ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ f₂✝)) _auto✝\ncomm₂₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₂✝ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ f₃✝)) _auto✝\nf₀ : Quiver.Hom S₁.L₀ S₂.L₀\nf₁ : Quiver.Hom S₁.L₁ S₂.L₁\nf₂ : Quiver.Hom S₁.L₂ S₂.L₂\nf₃ : Quiver.Hom S₁.L₃ S₂.L₃\ncomm₀₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₀ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ f₁)) _auto✝\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₁ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ f₂)) _auto✝\ncomm₂₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₂ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ f₃)) _auto✝\nx✝ : Eq { f₀ := f₀✝, f₁ := f₁✝, f₂ := f₂✝, f₃ := f₃✝, comm₀₁ := comm₀₁✝, comm₁₂ := comm₁₂✝, comm₂₃ := comm₂₃✝ } { f₀ := f₀, f₁ := f₁, f₂ := f₂, f₃ := f₃, comm₀₁ := comm₀₁, comm₁₂ := comm₁₂, comm₂₃ := comm₂₃ }\n⊢ And (Eq f₀✝ f₀) (And (Eq f₁✝ f₁) (And (Eq f₂✝ f₂) (Eq f₃✝ f₃)))","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₁₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₁ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ self.f₂)","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf₀✝ : Quiver.Hom S₁.L₀ S₂.L₀\nf₁✝ : Quiver.Hom S₁.L₁ S₂.L₁\nf₂✝ : Quiver.Hom S₁.L₂ S₂.L₂\nf₃✝ : Quiver.Hom S₁.L₃ S₂.L₃\ncomm₀₁✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₀✝ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ f₁✝)) _auto✝\ncomm₁₂✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₁✝ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ f₂✝)) _auto✝\ncomm₂₃✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₂✝ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ f₃✝)) _auto✝\nf₀ : Quiver.Hom S₁.L₀ S₂.L₀\nf₁ : Quiver.Hom S₁.L₁ S₂.L₁\nf₂ : Quiver.Hom S₁.L₂ S₂.L₂\nf₃ : Quiver.Hom S₁.L₃ S₂.L₃\ncomm₀₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₀ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ f₁)) _auto✝\ncomm₁₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₁ S₂.v₁₂) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ f₂)) _auto✝\ncomm₂₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp f₂ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ f₃)) _auto✝\n⊢ Eq (Eq { f₀ := f₀✝, f₁ := f₁✝, f₂ := f₂✝, f₃ := f₃✝, comm₀₁ := comm₀₁✝, comm₁₂ := comm₁₂✝, comm₂₃ := comm₂₃✝ } { f₀ := f₀, f₁ := f₁, f₂ := f₂, f₃ := f₃, comm₀₁ := comm₀₁, comm₁₂ := comm₁₂, comm₂₃ := comm₂₃ }) (And (Eq f₀✝ f₀) (And (Eq f₁✝ f₁) (And (Eq f₂✝ f₂) (Eq f₃✝ f₃))))","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₀₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₀ S₂.v₀₁) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ self.f₁)","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.ext","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nx y : S₁.Hom S₂\nf₀ : Eq x.f₀ y.f₀\nf₁ : Eq x.f₁ y.f₁\nf₂ : Eq x.f₂ y.f₂\nf₃ : Eq x.f₃ y.f₃\n⊢ Eq x y","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₂₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₂ S₂.v₂₃) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ self.f₃)","decl":"/-- A morphism of snake inputs involve four morphisms of short complexes\nwhich make the obvious diagram commute. -/\n@[ext]\nstructure Hom where\n  /-- a morphism between the zeroth lines -/\n  f₀ : S₁.L₀ ⟶ S₂.L₀\n  /-- a morphism between the first lines -/\n  f₁ : S₁.L₁ ⟶ S₂.L₁\n  /-- a morphism between the second lines -/\n  f₂ : S₁.L₂ ⟶ S₂.L₂\n  /-- a morphism between the third lines -/\n  f₃ : S₁.L₃ ⟶ S₂.L₃\n  comm₀₁ : f₀ ≫ S₂.v₀₁ = S₁.v₀₁ ≫ f₁ := by aesop_cat\n  comm₁₂ : f₁ ≫ S₂.v₁₂ = S₁.v₁₂ ≫ f₂ := by aesop_cat\n  comm₂₃ : f₂ ≫ S₂.v₂₃ = S₁.v₂₃ ≫ f₃ := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₁₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₂.L₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₁ (CategoryTheory.CategoryStruct.comp S₂.v₁₂ h)) (CategoryTheory.CategoryStruct.comp S₁.v₁₂ (CategoryTheory.CategoryStruct.comp self.f₂ h))","decl":"attribute [reassoc] comm₀₁ comm₁₂ comm₂₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₀₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₂.L₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₀ (CategoryTheory.CategoryStruct.comp S₂.v₀₁ h)) (CategoryTheory.CategoryStruct.comp S₁.v₀₁ (CategoryTheory.CategoryStruct.comp self.f₁ h))","decl":"attribute [reassoc] comm₀₁ comm₁₂ comm₂₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comm₂₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nself : S₁.Hom S₂\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₂.L₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.f₂ (CategoryTheory.CategoryStruct.comp S₂.v₂₃ h)) (CategoryTheory.CategoryStruct.comp S₁.v₂₃ (CategoryTheory.CategoryStruct.comp self.f₃ h))","decl":"attribute [reassoc] comm₀₁ comm₁₂ comm₂₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.id_f₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.Hom.id S).f₂ (CategoryTheory.CategoryStruct.id S.L₂)","decl":"/-- The identity morphism of a snake input. -/\n@[simps]\ndef id : Hom S S where\n  f₀ := 𝟙 _\n  f₁ := 𝟙 _\n  f₂ := 𝟙 _\n  f₃ := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.id_f₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.Hom.id S).f₁ (CategoryTheory.CategoryStruct.id S.L₁)","decl":"/-- The identity morphism of a snake input. -/\n@[simps]\ndef id : Hom S S where\n  f₀ := 𝟙 _\n  f₁ := 𝟙 _\n  f₂ := 𝟙 _\n  f₃ := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.id_f₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.Hom.id S).f₃ (CategoryTheory.CategoryStruct.id S.L₃)","decl":"/-- The identity morphism of a snake input. -/\n@[simps]\ndef id : Hom S S where\n  f₀ := 𝟙 _\n  f₁ := 𝟙 _\n  f₂ := 𝟙 _\n  f₃ := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.id_f₀","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.Hom.id S).f₀ (CategoryTheory.CategoryStruct.id S.L₀)","decl":"/-- The identity morphism of a snake input. -/\n@[simps]\ndef id : Hom S S where\n  f₀ := 𝟙 _\n  f₁ := 𝟙 _\n  f₂ := 𝟙 _\n  f₃ := 𝟙 _\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comp_f₀","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : S₁.Hom S₂\ng : S₂.Hom S₃\n⊢ Eq (f.comp g).f₀ (CategoryTheory.CategoryStruct.comp f.f₀ g.f₀)","decl":"/-- The composition of morphisms of snake inputs. -/\n@[simps]\ndef comp (f : Hom S₁ S₂) (g : Hom S₂ S₃) : Hom S₁ S₃ where\n  f₀ := f.f₀ ≫ g.f₀\n  f₁ := f.f₁ ≫ g.f₁\n  f₂ := f.f₂ ≫ g.f₂\n  f₃ := f.f₃ ≫ g.f₃\n  comm₀₁ := by simp only [assoc, comm₀₁, comm₀₁_assoc]\n  comm₁₂ := by simp only [assoc, comm₁₂, comm₁₂_assoc]\n  comm₂₃ := by simp only [assoc, comm₂₃, comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comp_f₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : S₁.Hom S₂\ng : S₂.Hom S₃\n⊢ Eq (f.comp g).f₃ (CategoryTheory.CategoryStruct.comp f.f₃ g.f₃)","decl":"/-- The composition of morphisms of snake inputs. -/\n@[simps]\ndef comp (f : Hom S₁ S₂) (g : Hom S₂ S₃) : Hom S₁ S₃ where\n  f₀ := f.f₀ ≫ g.f₀\n  f₁ := f.f₁ ≫ g.f₁\n  f₂ := f.f₂ ≫ g.f₂\n  f₃ := f.f₃ ≫ g.f₃\n  comm₀₁ := by simp only [assoc, comm₀₁, comm₀₁_assoc]\n  comm₁₂ := by simp only [assoc, comm₁₂, comm₁₂_assoc]\n  comm₂₃ := by simp only [assoc, comm₂₃, comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comp_f₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : S₁.Hom S₂\ng : S₂.Hom S₃\n⊢ Eq (f.comp g).f₁ (CategoryTheory.CategoryStruct.comp f.f₁ g.f₁)","decl":"/-- The composition of morphisms of snake inputs. -/\n@[simps]\ndef comp (f : Hom S₁ S₂) (g : Hom S₂ S₃) : Hom S₁ S₃ where\n  f₀ := f.f₀ ≫ g.f₀\n  f₁ := f.f₁ ≫ g.f₁\n  f₂ := f.f₂ ≫ g.f₂\n  f₃ := f.f₃ ≫ g.f₃\n  comm₀₁ := by simp only [assoc, comm₀₁, comm₀₁_assoc]\n  comm₁₂ := by simp only [assoc, comm₁₂, comm₁₂_assoc]\n  comm₂₃ := by simp only [assoc, comm₂₃, comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.Hom.comp_f₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : S₁.Hom S₂\ng : S₂.Hom S₃\n⊢ Eq (f.comp g).f₂ (CategoryTheory.CategoryStruct.comp f.f₂ g.f₂)","decl":"/-- The composition of morphisms of snake inputs. -/\n@[simps]\ndef comp (f : Hom S₁ S₂) (g : Hom S₂ S₃) : Hom S₁ S₃ where\n  f₀ := f.f₀ ≫ g.f₀\n  f₁ := f.f₁ ≫ g.f₁\n  f₂ := f.f₂ ≫ g.f₂\n  f₃ := f.f₃ ≫ g.f₃\n  comm₀₁ := by simp only [assoc, comm₀₁, comm₀₁_assoc]\n  comm₁₂ := by simp only [assoc, comm₁₂, comm₁₂_assoc]\n  comm₂₃ := by simp only [assoc, comm₂₃, comm₂₃_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.id_f₀","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.id S).f₀ (CategoryTheory.CategoryStruct.id S.L₀)","decl":"@[simp] lemma id_f₀ : Hom.f₀ (𝟙 S) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.id_f₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.id S).f₁ (CategoryTheory.CategoryStruct.id S.L₁)","decl":"@[simp] lemma id_f₁ : Hom.f₁ (𝟙 S) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.id_f₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.id S).f₂ (CategoryTheory.CategoryStruct.id S.L₂)","decl":"@[simp] lemma id_f₂ : Hom.f₂ (𝟙 S) = 𝟙 _ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.id_f₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.CategoryStruct.id S).f₃ (CategoryTheory.CategoryStruct.id S.L₃)","decl":"@[simp] lemma id_f₃ : Hom.f₃ (𝟙 S) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₀","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f₀ (CategoryTheory.CategoryStruct.comp f.f₀ g.f₀)","decl":"@[simp, reassoc] lemma comp_f₀ : (f ≫ g).f₀ = f.f₀ ≫ g.f₀ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₀_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₃.L₀ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).f₀ h) (CategoryTheory.CategoryStruct.comp f.f₀ (CategoryTheory.CategoryStruct.comp g.f₀ h))","decl":"@[simp, reassoc] lemma comp_f₀ : (f ≫ g).f₀ = f.f₀ ≫ g.f₀ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f₁ (CategoryTheory.CategoryStruct.comp f.f₁ g.f₁)","decl":"@[simp, reassoc] lemma comp_f₁ : (f ≫ g).f₁ = f.f₁ ≫ g.f₁ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₃.L₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).f₁ h) (CategoryTheory.CategoryStruct.comp f.f₁ (CategoryTheory.CategoryStruct.comp g.f₁ h))","decl":"@[simp, reassoc] lemma comp_f₁ : (f ≫ g).f₁ = f.f₁ ≫ g.f₁ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f₂ (CategoryTheory.CategoryStruct.comp f.f₂ g.f₂)","decl":"@[simp, reassoc] lemma comp_f₂ : (f ≫ g).f₂ = f.f₂ ≫ g.f₂ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₃.L₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).f₂ h) (CategoryTheory.CategoryStruct.comp f.f₂ (CategoryTheory.CategoryStruct.comp g.f₂ h))","decl":"@[simp, reassoc] lemma comp_f₂ : (f ≫ g).f₂ = f.f₂ ≫ g.f₂ := rfl\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f₃ (CategoryTheory.CategoryStruct.comp f.f₃ g.f₃)","decl":"@[simp, reassoc] lemma comp_f₃ : (f ≫ g).f₃ = f.f₃ ≫ g.f₃ := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.comp_f₃_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\ng : Quiver.Hom S₂ S₃\nZ : CategoryTheory.ShortComplex C\nh : Quiver.Hom S₃.L₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).f₃ h) (CategoryTheory.CategoryStruct.comp f.f₃ (CategoryTheory.CategoryStruct.comp g.f₃ h))","decl":"@[simp, reassoc] lemma comp_f₃ : (f ≫ g).f₃ = f.f₃ ≫ g.f₃ := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₀_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₀.obj S) S.L₀","decl":"/-- The functor which sends `S : SnakeInput C` to its zeroth line `S.L₀`. -/\n@[simps]\ndef functorL₀ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₀\n  map f := f.f₀\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₀_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₀.map f) f.f₀","decl":"/-- The functor which sends `S : SnakeInput C` to its zeroth line `S.L₀`. -/\n@[simps]\ndef functorL₀ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₀\n  map f := f.f₀\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁.obj S) S.L₁","decl":"/-- The functor which sends `S : SnakeInput C` to its zeroth line `S.L₁`. -/\n@[simps]\ndef functorL₁ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁\n  map f := f.f₁\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁.map f) f.f₁","decl":"/-- The functor which sends `S : SnakeInput C` to its zeroth line `S.L₁`. -/\n@[simps]\ndef functorL₁ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁\n  map f := f.f₁\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂.obj S) S.L₂","decl":"/-- The functor which sends `S : SnakeInput C` to its second line `S.L₂`. -/\n@[simps]\ndef functorL₂ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂\n  map f := f.f₂\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂.map f) f.f₂","decl":"/-- The functor which sends `S : SnakeInput C` to its second line `S.L₂`. -/\n@[simps]\ndef functorL₂ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂\n  map f := f.f₂\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₃_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₃.obj S) S.L₃","decl":"/-- The functor which sends `S : SnakeInput C` to its third line `S.L₃`. -/\n@[simps]\ndef functorL₃ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₃\n  map f := f.f₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₃_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₃.map f) f.f₃","decl":"/-- The functor which sends `S : SnakeInput C` to its third line `S.L₃`. -/\n@[simps]\ndef functorL₃ : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₃\n  map f := f.f₃\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorP_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorP.map f) (CategoryTheory.Limits.pullback.map X✝.L₁.g X✝.v₀₁.τ₃ Y✝.L₁.g Y✝.v₀₁.τ₃ f.f₁.τ₂ f.f₀.τ₃ f.f₁.τ₃ ⋯ ⋯)","decl":"/-- The functor which sends `S : SnakeInput C` to the auxiliary object `S.P`,\nwhich is `pullback S.L₁.g S.v₀₁.τ₃`. -/\n@[simps]\nnoncomputable def functorP : SnakeInput C ⥤ C where\n  obj S := S.P\n  map f := pullback.map _ _ _ _ f.f₁.τ₂ f.f₀.τ₃ f.f₁.τ₃ f.f₁.comm₂₃.symm\n      (congr_arg ShortComplex.Hom.τ₃ f.comm₀₁.symm)\n  map_id _ := by dsimp [P]; simp\n  map_comp _ _ := by dsimp [P]; aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorP_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorP.obj S) S.P","decl":"/-- The functor which sends `S : SnakeInput C` to the auxiliary object `S.P`,\nwhich is `pullback S.L₁.g S.v₀₁.τ₃`. -/\n@[simps]\nnoncomputable def functorP : SnakeInput C ⥤ C where\n  obj S := S.P\n  map f := pullback.map _ _ _ _ f.f₁.τ₂ f.f₀.τ₃ f.f₁.τ₃ f.f₁.comm₂₃.symm\n      (congr_arg ShortComplex.Hom.τ₃ f.comm₀₁.symm)\n  map_id _ := by dsimp [P]; simp\n  map_comp _ _ := by dsimp [P]; aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_φ₂_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.L₂.X₂ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.φ₂ (CategoryTheory.CategoryStruct.comp f.f₂.τ₂ h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.SnakeInput.functorP.map f) (CategoryTheory.CategoryStruct.comp S₂.φ₂ h))","decl":"@[reassoc]\nlemma naturality_φ₂ (f : S₁ ⟶ S₂) : S₁.φ₂ ≫ f.f₂.τ₂ = functorP.map f ≫ S₂.φ₂ := by\n  dsimp [φ₂]\n  simp only [assoc, pullback.lift_fst_assoc, ← comp_τ₂, f.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_φ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.φ₂ f.f₂.τ₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.SnakeInput.functorP.map f) S₂.φ₂)","decl":"@[reassoc]\nlemma naturality_φ₂ (f : S₁ ⟶ S₂) : S₁.φ₂ ≫ f.f₂.τ₂ = functorP.map f ≫ S₂.φ₂ := by\n  dsimp [φ₂]\n  simp only [assoc, pullback.lift_fst_assoc, ← comp_τ₂, f.comm₁₂]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_φ₁_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.L₂.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.φ₁ (CategoryTheory.CategoryStruct.comp f.f₂.τ₁ h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.SnakeInput.functorP.map f) (CategoryTheory.CategoryStruct.comp S₂.φ₁ h))","decl":"@[reassoc]\nlemma naturality_φ₁ (f : S₁ ⟶ S₂) : S₁.φ₁ ≫ f.f₂.τ₁ = functorP.map f ≫ S₂.φ₁ := by\n  simp only [← cancel_mono S₂.L₂.f, assoc, φ₁_L₂_f, ← naturality_φ₂, f.f₂.comm₁₂, φ₁_L₂_f_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_φ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.φ₁ f.f₂.τ₁) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.SnakeInput.functorP.map f) S₂.φ₁)","decl":"@[reassoc]\nlemma naturality_φ₁ (f : S₁ ⟶ S₂) : S₁.φ₁ ≫ f.f₂.τ₁ = functorP.map f ≫ S₂.φ₁ := by\n  simp only [← cancel_mono S₂.L₂.f, assoc, φ₁_L₂_f, ← naturality_φ₂, f.f₂.comm₁₂, φ₁_L₂_f_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_δ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.L₃.X₁ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.δ (CategoryTheory.CategoryStruct.comp f.f₃.τ₁ h)) (CategoryTheory.CategoryStruct.comp f.f₀.τ₃ (CategoryTheory.CategoryStruct.comp S₂.δ h))","decl":"@[reassoc]\nlemma naturality_δ (f : S₁ ⟶ S₂) : S₁.δ ≫ f.f₃.τ₁ = f.f₀.τ₃ ≫ S₂.δ := by\n  rw [← cancel_epi (pullback.snd _ _ : S₁.P ⟶ _), S₁.snd_δ_assoc, ← comp_τ₁, ← f.comm₂₃,\n    comp_τ₁, naturality_φ₁_assoc, ← S₂.snd_δ, functorP_map, pullback.lift_snd_assoc, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.naturality_δ","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS₁ S₂ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.δ f.f₃.τ₁) (CategoryTheory.CategoryStruct.comp f.f₀.τ₃ S₂.δ)","decl":"@[reassoc]\nlemma naturality_δ (f : S₁ ⟶ S₂) : S₁.δ ≫ f.f₃.τ₁ = f.f₀.τ₃ ≫ S₂.δ := by\n  rw [← cancel_epi (pullback.snd _ _ : S₁.P ⟶ _), S₁.snd_δ_assoc, ← comp_τ₁, ← f.comm₂₃,\n    comp_τ₁, naturality_φ₁_assoc, ← S₂.snd_δ, functorP_map, pullback.lift_snd_assoc, assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁'_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁'.obj S) S.L₁'","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₁'` which is\n`S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁`. -/\n@[simps]\nnoncomputable def functorL₁' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁'\n  map f :=\n    { τ₁ := f.f₀.τ₂\n      τ₂ := f.f₀.τ₃\n      τ₃ := f.f₃.τ₁\n      comm₁₂ := f.f₀.comm₂₃\n      comm₂₃ := (naturality_δ f).symm }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁'_map_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁'.map f).τ₂ f.f₀.τ₃","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₁'` which is\n`S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁`. -/\n@[simps]\nnoncomputable def functorL₁' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁'\n  map f :=\n    { τ₁ := f.f₀.τ₂\n      τ₂ := f.f₀.τ₃\n      τ₃ := f.f₃.τ₁\n      comm₁₂ := f.f₀.comm₂₃\n      comm₂₃ := (naturality_δ f).symm }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁'_map_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁'.map f).τ₃ f.f₃.τ₁","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₁'` which is\n`S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁`. -/\n@[simps]\nnoncomputable def functorL₁' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁'\n  map f :=\n    { τ₁ := f.f₀.τ₂\n      τ₂ := f.f₀.τ₃\n      τ₃ := f.f₃.τ₁\n      comm₁₂ := f.f₀.comm₂₃\n      comm₂₃ := (naturality_δ f).symm }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₁'_map_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₁'.map f).τ₁ f.f₀.τ₂","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₁'` which is\n`S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁`. -/\n@[simps]\nnoncomputable def functorL₁' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₁'\n  map f :=\n    { τ₁ := f.f₀.τ₂\n      τ₂ := f.f₀.τ₃\n      τ₃ := f.f₃.τ₁\n      comm₁₂ := f.f₀.comm₂₃\n      comm₂₃ := (naturality_δ f).symm }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂'_map_τ₁","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂'.map f).τ₁ f.f₀.τ₃","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₂'` which is\n`S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂`. -/\n@[simps]\nnoncomputable def functorL₂' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂'\n  map f :=\n    { τ₁ := f.f₀.τ₃\n      τ₂ := f.f₃.τ₁\n      τ₃ := f.f₃.τ₂\n      comm₁₂ := (naturality_δ f).symm\n      comm₂₃ := f.f₃.comm₁₂ }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂'_map_τ₂","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂'.map f).τ₂ f.f₃.τ₁","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₂'` which is\n`S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂`. -/\n@[simps]\nnoncomputable def functorL₂' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂'\n  map f :=\n    { τ₁ := f.f₀.τ₃\n      τ₂ := f.f₃.τ₁\n      τ₃ := f.f₃.τ₂\n      comm₁₂ := (naturality_δ f).symm\n      comm₂₃ := f.f₃.comm₁₂ }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂'_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂'.obj S) S.L₂'","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₂'` which is\n`S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂`. -/\n@[simps]\nnoncomputable def functorL₂' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂'\n  map f :=\n    { τ₁ := f.f₀.τ₃\n      τ₂ := f.f₃.τ₁\n      τ₃ := f.f₃.τ₂\n      comm₁₂ := (naturality_δ f).symm\n      comm₂₃ := f.f₃.comm₁₂ }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.functorL₂'_map_τ₃","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.functorL₂'.map f).τ₃ f.f₃.τ₂","decl":"/-- The functor which sends `S : SnakeInput C` to `S.L₂'` which is\n`S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂`. -/\n@[simps]\nnoncomputable def functorL₂' : SnakeInput C ⥤ ShortComplex C where\n  obj S := S.L₂'\n  map f :=\n    { τ₁ := f.f₀.τ₃\n      τ₂ := f.f₃.τ₁\n      τ₃ := f.f₃.τ₂\n      comm₁₂ := (naturality_δ f).symm\n      comm₂₃ := f.f₃.comm₁₂ }\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.composableArrowsFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX✝ Y✝ : CategoryTheory.ShortComplex.SnakeInput C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.composableArrowsFunctor.map f) (CategoryTheory.ComposableArrows.homMk₅ f.f₀.τ₁ f.f₀.τ₂ f.f₀.τ₃ f.f₃.τ₁ f.f₃.τ₂ f.f₃.τ₃ ⋯ ⋯ ⋯ ⋯ ⋯)","decl":"/-- The functor which maps `S : SnakeInput C` to the diagram\n`S.L₀.X₁ ⟶ S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂ ⟶ S.L₃.X₃`. -/\n@[simps]\nnoncomputable def composableArrowsFunctor : SnakeInput C ⥤ ComposableArrows C 5 where\n  obj S := S.composableArrows\n  map f := ComposableArrows.homMk₅ f.f₀.τ₁ f.f₀.τ₂ f.f₀.τ₃ f.f₃.τ₁ f.f₃.τ₂ f.f₃.τ₃\n    f.f₀.comm₁₂.symm f.f₀.comm₂₃.symm (naturality_δ f) f.f₃.comm₁₂.symm f.f₃.comm₂₃.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.composableArrowsFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.SnakeLemma","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nS : CategoryTheory.ShortComplex.SnakeInput C\n⊢ Eq (CategoryTheory.ShortComplex.SnakeInput.composableArrowsFunctor.obj S) S.composableArrows","decl":"/-- The functor which maps `S : SnakeInput C` to the diagram\n`S.L₀.X₁ ⟶ S.L₀.X₂ ⟶ S.L₀.X₃ ⟶ S.L₃.X₁ ⟶ S.L₃.X₂ ⟶ S.L₃.X₃`. -/\n@[simps]\nnoncomputable def composableArrowsFunctor : SnakeInput C ⥤ ComposableArrows C 5 where\n  obj S := S.composableArrows\n  map f := ComposableArrows.homMk₅ f.f₀.τ₁ f.f₀.τ₂ f.f₀.τ₃ f.f₃.τ₁ f.f₃.τ₂ f.f₃.τ₃\n    f.f₀.comm₁₂.symm f.f₀.comm₂₃.symm (naturality_δ f) f.f₃.comm₁₂.symm f.f₃.comm₂₃.symm\n\n"}
