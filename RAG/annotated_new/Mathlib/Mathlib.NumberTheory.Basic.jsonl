{"name":"dvd_sub_pow_of_dvd_sub","module":"Mathlib.NumberTheory.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np : Nat\na b : R\nh : Dvd.dvd (↑p) (HSub.hSub a b)\nk : Nat\n⊢ Dvd.dvd (HPow.hPow (↑p) (HAdd.hAdd k 1)) (HSub.hSub (HPow.hPow a (HPow.hPow p k)) (HPow.hPow b (HPow.hPow p k)))","decl":"theorem dvd_sub_pow_of_dvd_sub {R : Type*} [CommRing R] {p : ℕ} {a b : R} (h : (p : R) ∣ a - b)\n    (k : ℕ) : (p ^ (k + 1) : R) ∣ a ^ p ^ k - b ^ p ^ k := by\n  induction' k with k ih\n  · rwa [pow_one, pow_zero, pow_one, pow_one]\n  rw [pow_succ p k, pow_mul, pow_mul, ← geom_sum₂_mul, pow_succ']\n  refine mul_dvd_mul ?_ ih\n  let f : R →+* R ⧸ span {(p : R)} := mk (span {(p : R)})\n  have hf : ∀ r : R, (p : R) ∣ r ↔ f r = 0 := fun r ↦ by rw [eq_zero_iff_mem, mem_span_singleton]\n  rw [hf, map_sub, sub_eq_zero] at h\n  rw [hf, RingHom.map_geom_sum₂, map_pow, map_pow, h, geom_sum₂_self, mul_eq_zero_of_left]\n  rw [← map_natCast f, eq_zero_iff_mem, mem_span_singleton]\n\n"}
