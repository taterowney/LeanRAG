{"name":"ProbabilityTheory.lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nf : Ω → ENNReal\nMf mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nhMf : LE.le Mf mΩ\nc : ENNReal\nT : Set Ω\nh_meas_T : MeasurableSet T\nh_ind : ProbabilityTheory.IndepSets (setOf fun s => MeasurableSet s) (Singleton.singleton T) μ\nh_meas_f : Measurable f\n⊢ Eq (MeasureTheory.lintegral μ fun ω => HMul.hMul (f ω) (T.indicator (fun x => c) ω)) (HMul.hMul (MeasureTheory.lintegral μ fun ω => f ω) (MeasureTheory.lintegral μ fun ω => T.indicator (fun x => c) ω))","decl":"/-- If a random variable `f` in `ℝ≥0∞` is independent of an event `T`, then if you restrict the\n  random variable to `T`, then `E[f * indicator T c 0]=E[f] * E[indicator T c 0]`. It is useful for\n  `lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace`. -/\ntheorem lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator {Mf mΩ : MeasurableSpace Ω}\n    {μ : Measure Ω} (hMf : Mf ≤ mΩ) (c : ℝ≥0∞) {T : Set Ω} (h_meas_T : MeasurableSet T)\n    (h_ind : IndepSets {s | MeasurableSet[Mf] s} {T} μ) (h_meas_f : Measurable[Mf] f) :\n    (∫⁻ ω, f ω * T.indicator (fun _ => c) ω ∂μ) =\n      (∫⁻ ω, f ω ∂μ) * ∫⁻ ω, T.indicator (fun _ => c) ω ∂μ := by\n  revert f\n  have h_mul_indicator : ∀ g, Measurable g → Measurable fun a => g a * T.indicator (fun _ => c) a :=\n    fun g h_mg => h_mg.mul (measurable_const.indicator h_meas_T)\n  apply @Measurable.ennreal_induction _ Mf\n  · intro c' s' h_meas_s'\n    simp_rw [← inter_indicator_mul]\n    rw [lintegral_indicator (MeasurableSet.inter (hMf _ h_meas_s') h_meas_T),\n      lintegral_indicator (hMf _ h_meas_s'), lintegral_indicator h_meas_T]\n    simp only [measurable_const, lintegral_const, univ_inter, lintegral_const_mul,\n      MeasurableSet.univ, Measure.restrict_apply]\n    rw [IndepSets_iff] at h_ind\n    rw [mul_mul_mul_comm, h_ind s' T h_meas_s' (Set.mem_singleton _)]\n  · intro f' g _ h_meas_f' _ h_ind_f' h_ind_g\n    have h_measM_f' : Measurable f' := h_meas_f'.mono hMf le_rfl\n    simp_rw [Pi.add_apply, right_distrib]\n    rw [lintegral_add_left (h_mul_indicator _ h_measM_f'), lintegral_add_left h_measM_f',\n      right_distrib, h_ind_f', h_ind_g]\n  · intro f h_meas_f h_mono_f h_ind_f\n    have h_measM_f : ∀ n, Measurable (f n) := fun n => (h_meas_f n).mono hMf le_rfl\n    simp_rw [ENNReal.iSup_mul]\n    rw [lintegral_iSup h_measM_f h_mono_f, lintegral_iSup, ENNReal.iSup_mul]\n    · simp_rw [← h_ind_f]\n    · exact fun n => h_mul_indicator _ (h_measM_f n)\n    · exact fun m n h_le a => mul_le_mul_right' (h_mono_f h_le a) _\n\n"}
{"name":"ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nf g : Ω → ENNReal\nMf Mg mΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nhMf : LE.le Mf mΩ\nhMg : LE.le Mg mΩ\nh_ind : ProbabilityTheory.Indep Mf Mg μ\nh_meas_f : Measurable f\nh_meas_g : Measurable g\n⊢ Eq (MeasureTheory.lintegral μ fun ω => HMul.hMul (f ω) (g ω)) (HMul.hMul (MeasureTheory.lintegral μ fun ω => f ω) (MeasureTheory.lintegral μ fun ω => g ω))","decl":"/-- If `f` and `g` are independent random variables with values in `ℝ≥0∞`,\n   then `E[f * g] = E[f] * E[g]`. However, instead of directly using the independence\n   of the random variables, it uses the independence of measurable spaces for the\n   domains of `f` and `g`. This is similar to the sigma-algebra approach to\n   independence. See `lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun` for\n   a more common variant of the product of independent variables. -/\ntheorem lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace\n    {Mf Mg mΩ : MeasurableSpace Ω} {μ : Measure Ω} (hMf : Mf ≤ mΩ) (hMg : Mg ≤ mΩ)\n    (h_ind : Indep Mf Mg μ) (h_meas_f : Measurable[Mf] f) (h_meas_g : Measurable[Mg] g) :\n    ∫⁻ ω, f ω * g ω ∂μ = (∫⁻ ω, f ω ∂μ) * ∫⁻ ω, g ω ∂μ := by\n  revert g\n  have h_measM_f : Measurable f := h_meas_f.mono hMf le_rfl\n  apply @Measurable.ennreal_induction _ Mg\n  · intro c s h_s\n    apply lintegral_mul_indicator_eq_lintegral_mul_lintegral_indicator hMf _ (hMg _ h_s) _ h_meas_f\n    apply indepSets_of_indepSets_of_le_right h_ind\n    rwa [singleton_subset_iff]\n  · intro f' g _ h_measMg_f' _ h_ind_f' h_ind_g'\n    have h_measM_f' : Measurable f' := h_measMg_f'.mono hMg le_rfl\n    simp_rw [Pi.add_apply, left_distrib]\n    rw [lintegral_add_left h_measM_f', lintegral_add_left (h_measM_f.mul h_measM_f'), left_distrib,\n      h_ind_f', h_ind_g']\n  · intro f' h_meas_f' h_mono_f' h_ind_f'\n    have h_measM_f' : ∀ n, Measurable (f' n) := fun n => (h_meas_f' n).mono hMg le_rfl\n    simp_rw [ENNReal.mul_iSup]\n    rw [lintegral_iSup, lintegral_iSup h_measM_f' h_mono_f', ENNReal.mul_iSup]\n    · simp_rw [← h_ind_f']\n    · exact fun n => h_measM_f.mul (h_measM_f' n)\n    · exact fun n m (h_le : n ≤ m) a => mul_le_mul_left' (h_mono_f' h_le a) _\n\n"}
{"name":"ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf g : Ω → ENNReal\nh_meas_f : Measurable f\nh_meas_g : Measurable g\nh_indep_fun : ProbabilityTheory.IndepFun f g μ\n⊢ Eq (MeasureTheory.lintegral μ fun ω => HMul.hMul f g ω) (HMul.hMul (MeasureTheory.lintegral μ fun ω => f ω) (MeasureTheory.lintegral μ fun ω => g ω))","decl":"/-- If `f` and `g` are independent random variables with values in `ℝ≥0∞`,\n   then `E[f * g] = E[f] * E[g]`. -/\ntheorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun (h_meas_f : Measurable f)\n    (h_meas_g : Measurable g) (h_indep_fun : IndepFun f g μ) :\n    (∫⁻ ω, (f * g) ω ∂μ) = (∫⁻ ω, f ω ∂μ) * ∫⁻ ω, g ω ∂μ :=\n  lintegral_mul_eq_lintegral_mul_lintegral_of_independent_measurableSpace\n    (measurable_iff_comap_le.1 h_meas_f) (measurable_iff_comap_le.1 h_meas_g) h_indep_fun\n    (Measurable.of_comap_le le_rfl) (Measurable.of_comap_le le_rfl)\n\n"}
{"name":"ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf g : Ω → ENNReal\nh_meas_f : AEMeasurable f μ\nh_meas_g : AEMeasurable g μ\nh_indep_fun : ProbabilityTheory.IndepFun f g μ\n⊢ Eq (MeasureTheory.lintegral μ fun ω => HMul.hMul f g ω) (HMul.hMul (MeasureTheory.lintegral μ fun ω => f ω) (MeasureTheory.lintegral μ fun ω => g ω))","decl":"/-- If `f` and `g` with values in `ℝ≥0∞` are independent and almost everywhere measurable,\n   then `E[f * g] = E[f] * E[g]` (slightly generalizing\n   `lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun`). -/\ntheorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun' (h_meas_f : AEMeasurable f μ)\n    (h_meas_g : AEMeasurable g μ) (h_indep_fun : IndepFun f g μ) :\n    (∫⁻ ω, (f * g) ω ∂μ) = (∫⁻ ω, f ω ∂μ) * ∫⁻ ω, g ω ∂μ := by\n  have fg_ae : f * g =ᵐ[μ] h_meas_f.mk _ * h_meas_g.mk _ := h_meas_f.ae_eq_mk.mul h_meas_g.ae_eq_mk\n  rw [lintegral_congr_ae h_meas_f.ae_eq_mk, lintegral_congr_ae h_meas_g.ae_eq_mk,\n    lintegral_congr_ae fg_ae]\n  apply lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun h_meas_f.measurable_mk\n      h_meas_g.measurable_mk\n  exact h_indep_fun.ae_eq h_meas_f.ae_eq_mk h_meas_g.ae_eq_mk\n\n"}
{"name":"ProbabilityTheory.lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun''","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nf g : Ω → ENNReal\nh_meas_f : AEMeasurable f μ\nh_meas_g : AEMeasurable g μ\nh_indep_fun : ProbabilityTheory.IndepFun f g μ\n⊢ Eq (MeasureTheory.lintegral μ fun ω => HMul.hMul (f ω) (g ω)) (HMul.hMul (MeasureTheory.lintegral μ fun ω => f ω) (MeasureTheory.lintegral μ fun ω => g ω))","decl":"theorem lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'' (h_meas_f : AEMeasurable f μ)\n    (h_meas_g : AEMeasurable g μ) (h_indep_fun : IndepFun f g μ) :\n    ∫⁻ ω, f ω * g ω ∂μ = (∫⁻ ω, f ω ∂μ) * ∫⁻ ω, g ω ∂μ :=\n  lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun' h_meas_f h_meas_g h_indep_fun\n\n"}
{"name":"ProbabilityTheory.lintegral_prod_eq_prod_lintegral_of_indepFun","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nX : ι → Ω → ENNReal\nhX : ProbabilityTheory.iIndepFun (fun x => ENNReal.measurableSpace) X μ\nx_mea : ∀ (i : ι), Measurable (X i)\n⊢ Eq (MeasureTheory.lintegral μ fun ω => s.prod fun i => X i ω) (s.prod fun i => MeasureTheory.lintegral μ fun ω => X i ω)","decl":"theorem lintegral_prod_eq_prod_lintegral_of_indepFun {ι : Type*} [DecidableEq ι]\n    (s : Finset ι) (X : ι → Ω → ℝ≥0∞)\n    (hX : iIndepFun (fun _ ↦ ENNReal.measurableSpace) X μ)\n    (x_mea : ∀ i, Measurable (X i)) :\n    ∫⁻ ω, ∏ i ∈ s, (X i ω) ∂μ = ∏ i ∈ s, ∫⁻ ω, X i ω ∂μ := by\n  have : IsProbabilityMeasure μ := hX.isProbabilityMeasure\n  induction s using Finset.induction\n  case empty => simp only [Finset.prod_empty, lintegral_const, measure_univ, mul_one]\n  case insert _ j s hj v =>\n    calc  ∫⁻ (ω : Ω), ∏ i ∈ insert j s, X i ω ∂μ\n      _ = ∫⁻ (ω : Ω), (∏ i ∈ insert j s, X i) ω ∂μ := by simp only [Finset.prod_apply]\n      _ =  ∫⁻ (ω : Ω), (X j * ∏ i ∈ s, X i) ω ∂μ :=\n        lintegral_congr fun ω ↦ congrFun (Finset.prod_insert hj) ω\n      _ = (∫⁻ ω, X j ω ∂μ) * ∫⁻ ω, (∏ i ∈ s, X i) ω ∂μ := by\n        apply lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'\n        · exact (x_mea j).aemeasurable\n        · exact s.aemeasurable_prod' (fun i _ ↦ (x_mea i).aemeasurable)\n        · exact (iIndepFun.indepFun_finset_prod_of_not_mem hX (fun i ↦ x_mea i) hj).symm\n      _ = ∏ i' ∈ insert j s, ∫⁻ ω, X i' ω ∂μ := by\n        simp only [Finset.prod_apply]\n        rw [v, Finset.prod_insert hj]\n\n"}
{"name":"ProbabilityTheory.IndepFun.integrable_mul","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nβ : Type u_2\ninst✝² : MeasurableSpace β\nX Y : Ω → β\ninst✝¹ : NormedDivisionRing β\ninst✝ : BorelSpace β\nhXY : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.Integrable X μ\nhY : MeasureTheory.Integrable Y μ\n⊢ MeasureTheory.Integrable (HMul.hMul X Y) μ","decl":"/-- The product of two independent, integrable, real-valued random variables is integrable. -/\ntheorem IndepFun.integrable_mul {β : Type*} [MeasurableSpace β] {X Y : Ω → β}\n    [NormedDivisionRing β] [BorelSpace β] (hXY : IndepFun X Y μ) (hX : Integrable X μ)\n    (hY : Integrable Y μ) : Integrable (X * Y) μ := by\n  let nX : Ω → ℝ≥0∞ := fun a => ‖X a‖ₑ\n  let nY : Ω → ℝ≥0∞ := fun a => ‖Y a‖ₑ\n  have hXY' : IndepFun nX nY μ := hXY.comp measurable_enorm measurable_enorm\n  have hnX : AEMeasurable nX μ := hX.1.aemeasurable.enorm\n  have hnY : AEMeasurable nY μ := hY.1.aemeasurable.enorm\n  have hmul : ∫⁻ a, nX a * nY a ∂μ = (∫⁻ a, nX a ∂μ) * ∫⁻ a, nY a ∂μ :=\n    lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun' hnX hnY hXY'\n  refine ⟨hX.1.mul hY.1, ?_⟩\n  simp only [nX, nY] at hmul\n  simp_rw [hasFiniteIntegral_iff_enorm, Pi.mul_apply, enorm_mul, hmul]\n  exact ENNReal.mul_lt_top hX.2 hY.2\n\n"}
{"name":"ProbabilityTheory.IndepFun.integrable_left_of_integrable_mul","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nβ : Type u_2\ninst✝² : MeasurableSpace β\nX Y : Ω → β\ninst✝¹ : NormedDivisionRing β\ninst✝ : BorelSpace β\nhXY : ProbabilityTheory.IndepFun X Y μ\nh'XY : MeasureTheory.Integrable (HMul.hMul X Y) μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhY : MeasureTheory.AEStronglyMeasurable Y μ\nh'Y : Not ((MeasureTheory.ae μ).EventuallyEq Y 0)\n⊢ MeasureTheory.Integrable X μ","decl":"/-- If the product of two independent real-valued random variables is integrable and\nthe second one is not almost everywhere zero, then the first one is integrable. -/\ntheorem IndepFun.integrable_left_of_integrable_mul {β : Type*} [MeasurableSpace β] {X Y : Ω → β}\n    [NormedDivisionRing β] [BorelSpace β] (hXY : IndepFun X Y μ) (h'XY : Integrable (X * Y) μ)\n    (hX : AEStronglyMeasurable X μ) (hY : AEStronglyMeasurable Y μ) (h'Y : ¬Y =ᵐ[μ] 0) :\n    Integrable X μ := by\n  refine ⟨hX, ?_⟩\n  have I : (∫⁻ ω, ‖Y ω‖ₑ ∂μ) ≠ 0 := fun H ↦ by\n    have I : (fun ω => ‖Y ω‖ₑ : Ω → ℝ≥0∞) =ᵐ[μ] 0 := (lintegral_eq_zero_iff' hY.enorm).1 H\n    apply h'Y\n    filter_upwards [I] with ω hω\n    simpa using hω\n  refine hasFiniteIntegral_iff_enorm.mpr <| lt_top_iff_ne_top.2 fun H => ?_\n  have J : IndepFun (‖X ·‖ₑ) (‖Y ·‖ₑ) μ := hXY.comp measurable_enorm measurable_enorm\n  have A : ∫⁻ ω, ‖X ω * Y ω‖ₑ ∂μ < ∞ := h'XY.2\n  simp only [enorm_mul, ENNReal.coe_mul] at A\n  rw [lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'' hX.enorm hY.enorm J, H] at A\n  simp only [ENNReal.top_mul I, lt_self_iff_false] at A\n\n"}
{"name":"ProbabilityTheory.IndepFun.integrable_right_of_integrable_mul","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nβ : Type u_2\ninst✝² : MeasurableSpace β\nX Y : Ω → β\ninst✝¹ : NormedDivisionRing β\ninst✝ : BorelSpace β\nhXY : ProbabilityTheory.IndepFun X Y μ\nh'XY : MeasureTheory.Integrable (HMul.hMul X Y) μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhY : MeasureTheory.AEStronglyMeasurable Y μ\nh'X : Not ((MeasureTheory.ae μ).EventuallyEq X 0)\n⊢ MeasureTheory.Integrable Y μ","decl":"/-- If the product of two independent real-valued random variables is integrable and the\nfirst one is not almost everywhere zero, then the second one is integrable. -/\ntheorem IndepFun.integrable_right_of_integrable_mul {β : Type*} [MeasurableSpace β] {X Y : Ω → β}\n    [NormedDivisionRing β] [BorelSpace β] (hXY : IndepFun X Y μ) (h'XY : Integrable (X * Y) μ)\n    (hX : AEStronglyMeasurable X μ) (hY : AEStronglyMeasurable Y μ) (h'X : ¬X =ᵐ[μ] 0) :\n    Integrable Y μ := by\n  refine ⟨hY, ?_⟩\n  have I : ∫⁻ ω, ‖X ω‖ₑ ∂μ ≠ 0 := fun H ↦ by\n    have I : ((‖X ·‖ₑ) : Ω → ℝ≥0∞) =ᵐ[μ] 0 := (lintegral_eq_zero_iff' hX.enorm).1 H\n    apply h'X\n    filter_upwards [I] with ω hω\n    simpa using hω\n  refine lt_top_iff_ne_top.2 fun H => ?_\n  have J : IndepFun (fun ω => ‖X ω‖ₑ : Ω → ℝ≥0∞) (fun ω => ‖Y ω‖ₑ : Ω → ℝ≥0∞) μ :=\n    IndepFun.comp hXY measurable_enorm measurable_enorm\n  have A : ∫⁻ ω, ‖X ω * Y ω‖ₑ ∂μ < ∞ := h'XY.2\n  simp only [enorm_mul, ENNReal.coe_mul] at A\n  rw [lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'' hX.enorm hY.enorm J, H] at A\n  simp only [ENNReal.mul_top I, lt_self_iff_false] at A\n\n"}
{"name":"ProbabilityTheory.IndepFun.integral_mul_of_nonneg","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX Y : Ω → Real\nhXY : ProbabilityTheory.IndepFun X Y μ\nhXp : LE.le 0 X\nhYp : LE.le 0 Y\nhXm : AEMeasurable X μ\nhYm : AEMeasurable Y μ\n⊢ Eq (MeasureTheory.integral μ (HMul.hMul X Y)) (HMul.hMul (MeasureTheory.integral μ X) (MeasureTheory.integral μ Y))","decl":"/-- The (Bochner) integral of the product of two independent, nonnegative random\n  variables is the product of their integrals. The proof is just plumbing around\n  `lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun'`. -/\ntheorem IndepFun.integral_mul_of_nonneg (hXY : IndepFun X Y μ) (hXp : 0 ≤ X) (hYp : 0 ≤ Y)\n    (hXm : AEMeasurable X μ) (hYm : AEMeasurable Y μ) :\n    integral μ (X * Y) = integral μ X * integral μ Y := by\n  have h1 : AEMeasurable (fun a => ENNReal.ofReal (X a)) μ :=\n    ENNReal.measurable_ofReal.comp_aemeasurable hXm\n  have h2 : AEMeasurable (fun a => ENNReal.ofReal (Y a)) μ :=\n    ENNReal.measurable_ofReal.comp_aemeasurable hYm\n  have h3 : AEMeasurable (X * Y) μ := hXm.mul hYm\n  have h4 : 0 ≤ᵐ[μ] X * Y := ae_of_all _ fun ω => mul_nonneg (hXp ω) (hYp ω)\n  rw [integral_eq_lintegral_of_nonneg_ae (ae_of_all _ hXp) hXm.aestronglyMeasurable,\n    integral_eq_lintegral_of_nonneg_ae (ae_of_all _ hYp) hYm.aestronglyMeasurable,\n    integral_eq_lintegral_of_nonneg_ae h4 h3.aestronglyMeasurable]\n  simp_rw [← ENNReal.toReal_mul, Pi.mul_apply, ENNReal.ofReal_mul (hXp _)]\n  congr\n  apply lintegral_mul_eq_lintegral_mul_lintegral_of_indepFun' h1 h2\n  exact hXY.comp ENNReal.measurable_ofReal ENNReal.measurable_ofReal\n\n"}
{"name":"ProbabilityTheory.IndepFun.integral_mul_of_integrable","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX Y : Ω → Real\nhXY : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.Integrable X μ\nhY : MeasureTheory.Integrable Y μ\n⊢ Eq (MeasureTheory.integral μ (HMul.hMul X Y)) (HMul.hMul (MeasureTheory.integral μ X) (MeasureTheory.integral μ Y))","decl":"/-- The (Bochner) integral of the product of two independent, integrable random\n  variables is the product of their integrals. The proof is pedestrian decomposition\n  into their positive and negative parts in order to apply `IndepFun.integral_mul_of_nonneg`\n  four times. -/\ntheorem IndepFun.integral_mul_of_integrable (hXY : IndepFun X Y μ) (hX : Integrable X μ)\n    (hY : Integrable Y μ) : integral μ (X * Y) = integral μ X * integral μ Y := by\n  let pos : ℝ → ℝ := fun x => max x 0\n  let neg : ℝ → ℝ := fun x => max (-x) 0\n  have posm : Measurable pos := measurable_id'.max measurable_const\n  have negm : Measurable neg := measurable_id'.neg.max measurable_const\n  let Xp := pos ∘ X\n  -- `X⁺` would look better but it makes `simp_rw` below fail\n  let Xm := neg ∘ X\n  let Yp := pos ∘ Y\n  let Ym := neg ∘ Y\n  have hXpm : X = Xp - Xm := funext fun ω => (max_zero_sub_max_neg_zero_eq_self (X ω)).symm\n  have hYpm : Y = Yp - Ym := funext fun ω => (max_zero_sub_max_neg_zero_eq_self (Y ω)).symm\n  have hp1 : 0 ≤ Xm := fun ω => le_max_right _ _\n  have hp2 : 0 ≤ Xp := fun ω => le_max_right _ _\n  have hp3 : 0 ≤ Ym := fun ω => le_max_right _ _\n  have hp4 : 0 ≤ Yp := fun ω => le_max_right _ _\n  have hm1 : AEMeasurable Xm μ := hX.1.aemeasurable.neg.max aemeasurable_const\n  have hm2 : AEMeasurable Xp μ := hX.1.aemeasurable.max aemeasurable_const\n  have hm3 : AEMeasurable Ym μ := hY.1.aemeasurable.neg.max aemeasurable_const\n  have hm4 : AEMeasurable Yp μ := hY.1.aemeasurable.max aemeasurable_const\n  have hv1 : Integrable Xm μ := hX.neg_part\n  have hv2 : Integrable Xp μ := hX.pos_part\n  have hv3 : Integrable Ym μ := hY.neg_part\n  have hv4 : Integrable Yp μ := hY.pos_part\n  have hi1 : IndepFun Xm Ym μ := hXY.comp negm negm\n  have hi2 : IndepFun Xp Ym μ := hXY.comp posm negm\n  have hi3 : IndepFun Xm Yp μ := hXY.comp negm posm\n  have hi4 : IndepFun Xp Yp μ := hXY.comp posm posm\n  have hl1 : Integrable (Xm * Ym) μ := hi1.integrable_mul hv1 hv3\n  have hl2 : Integrable (Xp * Ym) μ := hi2.integrable_mul hv2 hv3\n  have hl3 : Integrable (Xm * Yp) μ := hi3.integrable_mul hv1 hv4\n  have hl4 : Integrable (Xp * Yp) μ := hi4.integrable_mul hv2 hv4\n  have hl5 : Integrable (Xp * Yp - Xm * Yp) μ := hl4.sub hl3\n  have hl6 : Integrable (Xp * Ym - Xm * Ym) μ := hl2.sub hl1\n  rw [hXpm, hYpm, mul_sub, sub_mul, sub_mul]\n  rw [integral_sub' hl5 hl6, integral_sub' hl4 hl3, integral_sub' hl2 hl1, integral_sub' hv2 hv1,\n    integral_sub' hv4 hv3, hi1.integral_mul_of_nonneg hp1 hp3 hm1 hm3,\n    hi2.integral_mul_of_nonneg hp2 hp3 hm2 hm3, hi3.integral_mul_of_nonneg hp1 hp4 hm1 hm4,\n    hi4.integral_mul_of_nonneg hp2 hp4 hm2 hm4]\n  ring\n\n"}
{"name":"ProbabilityTheory.IndepFun.integral_mul","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX Y : Ω → Real\nhXY : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhY : MeasureTheory.AEStronglyMeasurable Y μ\n⊢ Eq (MeasureTheory.integral μ (HMul.hMul X Y)) (HMul.hMul (MeasureTheory.integral μ X) (MeasureTheory.integral μ Y))","decl":"/-- The (Bochner) integral of the product of two independent random\n  variables is the product of their integrals. -/\ntheorem IndepFun.integral_mul (hXY : IndepFun X Y μ) (hX : AEStronglyMeasurable X μ)\n    (hY : AEStronglyMeasurable Y μ) : integral μ (X * Y) = integral μ X * integral μ Y := by\n  by_cases h'X : X =ᵐ[μ] 0\n  · have h' : X * Y =ᵐ[μ] 0 := by\n      filter_upwards [h'X] with ω hω\n      simp [hω]\n    simp only [integral_congr_ae h'X, integral_congr_ae h', Pi.zero_apply, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero, zero_mul]\n  by_cases h'Y : Y =ᵐ[μ] 0\n  · have h' : X * Y =ᵐ[μ] 0 := by\n      filter_upwards [h'Y] with ω hω\n      simp [hω]\n    simp only [integral_congr_ae h'Y, integral_congr_ae h', Pi.zero_apply, integral_const,\n      Algebra.id.smul_eq_mul, mul_zero, zero_mul]\n  by_cases h : Integrable (X * Y) μ\n  · have HX : Integrable X μ := hXY.integrable_left_of_integrable_mul h hX hY h'Y\n    have HY : Integrable Y μ := hXY.integrable_right_of_integrable_mul h hX hY h'X\n    exact hXY.integral_mul_of_integrable HX HY\n  · rw [integral_undef h]\n    have I : ¬(Integrable X μ ∧ Integrable Y μ) := by\n      rintro ⟨HX, HY⟩\n      exact h (hXY.integrable_mul HX HY)\n    rw [not_and_or] at I\n    cases' I with I I <;> simp [integral_undef I]\n\n"}
{"name":"ProbabilityTheory.IndepFun.integral_mul'","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX Y : Ω → Real\nhXY : ProbabilityTheory.IndepFun X Y μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\nhY : MeasureTheory.AEStronglyMeasurable Y μ\n⊢ Eq (MeasureTheory.integral μ fun ω => HMul.hMul (X ω) (Y ω)) (HMul.hMul (MeasureTheory.integral μ X) (MeasureTheory.integral μ Y))","decl":"theorem IndepFun.integral_mul' (hXY : IndepFun X Y μ) (hX : AEStronglyMeasurable X μ)\n    (hY : AEStronglyMeasurable Y μ) :\n    (integral μ fun ω => X ω * Y ω) = integral μ X * integral μ Y :=\n  hXY.integral_mul hX hY\n\n"}
{"name":"ProbabilityTheory.indepFun_iff_integral_comp_mul","module":"Mathlib.Probability.Integration","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nβ : Type u_2\nβ' : Type u_3\nmβ : MeasurableSpace β\nmβ' : MeasurableSpace β'\nf : Ω → β\ng : Ω → β'\nhfm : Measurable f\nhgm : Measurable g\n⊢ Iff (ProbabilityTheory.IndepFun f g μ) (∀ {φ : β → Real} {ψ : β' → Real}, Measurable φ → Measurable ψ → MeasureTheory.Integrable (Function.comp φ f) μ → MeasureTheory.Integrable (Function.comp ψ g) μ → Eq (MeasureTheory.integral μ (HMul.hMul (Function.comp φ f) (Function.comp ψ g))) (HMul.hMul (MeasureTheory.integral μ (Function.comp φ f)) (MeasureTheory.integral μ (Function.comp ψ g))))","decl":"/-- Independence of functions `f` and `g` into arbitrary types is characterized by the relation\n  `E[(φ ∘ f) * (ψ ∘ g)] = E[φ ∘ f] * E[ψ ∘ g]` for all measurable `φ` and `ψ` with values in `ℝ`\n  satisfying appropriate integrability conditions. -/\ntheorem indepFun_iff_integral_comp_mul [IsFiniteMeasure μ] {β β' : Type*} {mβ : MeasurableSpace β}\n    {mβ' : MeasurableSpace β'} {f : Ω → β} {g : Ω → β'} {hfm : Measurable f} {hgm : Measurable g} :\n    IndepFun f g μ ↔ ∀ {φ : β → ℝ} {ψ : β' → ℝ}, Measurable φ → Measurable ψ →\n      Integrable (φ ∘ f) μ → Integrable (ψ ∘ g) μ →\n        integral μ (φ ∘ f * ψ ∘ g) = integral μ (φ ∘ f) * integral μ (ψ ∘ g) := by\n  refine ⟨fun hfg _ _ hφ hψ => IndepFun.integral_mul_of_integrable (hfg.comp hφ hψ), ?_⟩\n  rw [IndepFun_iff]\n  rintro h _ _ ⟨A, hA, rfl⟩ ⟨B, hB, rfl⟩\n  specialize\n    h (measurable_one.indicator hA) (measurable_one.indicator hB)\n      ((integrable_const 1).indicator (hfm.comp measurable_id hA))\n      ((integrable_const 1).indicator (hgm.comp measurable_id hB))\n  rwa [← ENNReal.toReal_eq_toReal (measure_ne_top μ _), ENNReal.toReal_mul, ←\n    integral_indicator_one ((hfm hA).inter (hgm hB)), ← integral_indicator_one (hfm hA), ←\n    integral_indicator_one (hgm hB), Set.inter_indicator_one]\n  exact ENNReal.mul_ne_top (measure_ne_top μ _) (measure_ne_top μ _)\n\n"}
