{"name":"LinearMap.iterateMapComap_le_succ","module":"Mathlib.Algebra.Module.Submodule.IterateMapComap","initialProofState":"R : Type u_1\nN : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf i : LinearMap (RingHom.id R) N M\nK : Submodule R N\nh : LE.le (Submodule.map f K) (Submodule.map i K)\nn : Nat\n⊢ LE.le (f.iterateMapComap i n K) (f.iterateMapComap i (HAdd.hAdd n 1) K)","decl":"/-- If `f(K) ≤ i(K)`, then `LinearMap.iterateMapComap` is not decreasing. -/\ntheorem iterateMapComap_le_succ (K : Submodule R N) (h : K.map f ≤ K.map i) (n : ℕ) :\n    f.iterateMapComap i n K ≤ f.iterateMapComap i (n + 1) K := by\n  nth_rw 2 [iterateMapComap]\n  rw [iterate_succ', Function.comp_apply, ← iterateMapComap, ← map_le_iff_le_comap]\n  induction n with\n  | zero => exact h\n  | succ n ih =>\n    simp_rw [iterateMapComap, iterate_succ', Function.comp_apply]\n    calc\n      _ ≤ (f.iterateMapComap i n K).map i := map_comap_le _ _\n      _ ≤ (((f.iterateMapComap i n K).map f).comap f).map i := map_mono (le_comap_map _ _)\n      _ ≤ _ := map_mono (comap_mono ih)\n\n"}
{"name":"LinearMap.iterateMapComap_eq_succ","module":"Mathlib.Algebra.Module.Submodule.IterateMapComap","initialProofState":"R : Type u_1\nN : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf i : LinearMap (RingHom.id R) N M\nK : Submodule R N\nm : Nat\nheq : Eq (f.iterateMapComap i m K) (f.iterateMapComap i (HAdd.hAdd m 1) K)\nhf : Function.Surjective ⇑f\nhi : Function.Injective ⇑i\nn : Nat\n⊢ Eq (f.iterateMapComap i n K) (f.iterateMapComap i (HAdd.hAdd n 1) K)","decl":"/-- If `f` is surjective, `i` is injective, and there exists some `m` such that\n`LinearMap.iterateMapComap f i m K = LinearMap.iterateMapComap f i (m + 1) K`,\nthen for any `n`,\n`LinearMap.iterateMapComap f i n K = LinearMap.iterateMapComap f i (n + 1) K`.\nIn particular, by taking `n = 0`, the kernel of `f` is contained in `K`\n(`LinearMap.ker_le_of_iterateMapComap_eq_succ`),\nwhich is a consequence of `LinearMap.ker_le_comap`. -/\ntheorem iterateMapComap_eq_succ (K : Submodule R N)\n    (m : ℕ) (heq : f.iterateMapComap i m K = f.iterateMapComap i (m + 1) K)\n    (hf : Surjective f) (hi : Injective i) (n : ℕ) :\n    f.iterateMapComap i n K = f.iterateMapComap i (n + 1) K := by\n  induction n with\n  | zero =>\n    contrapose! heq\n    induction m with\n    | zero => exact heq\n    | succ m ih =>\n      rw [iterateMapComap, iterateMapComap, iterate_succ', iterate_succ']\n      exact fun H ↦ ih (map_injective_of_injective hi (comap_injective_of_surjective hf H))\n  | succ n ih =>\n    rw [iterateMapComap, iterateMapComap, iterate_succ', iterate_succ',\n      Function.comp_apply, Function.comp_apply, ← iterateMapComap, ← iterateMapComap, ih]\n\n"}
{"name":"LinearMap.ker_le_of_iterateMapComap_eq_succ","module":"Mathlib.Algebra.Module.Submodule.IterateMapComap","initialProofState":"R : Type u_1\nN : Type u_2\nM : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf i : LinearMap (RingHom.id R) N M\nK : Submodule R N\nm : Nat\nheq : Eq (f.iterateMapComap i m K) (f.iterateMapComap i (HAdd.hAdd m 1) K)\nhf : Function.Surjective ⇑f\nhi : Function.Injective ⇑i\n⊢ LE.le (LinearMap.ker f) K","decl":"/-- If `f` is surjective, `i` is injective, and there exists some `m` such that\n`LinearMap.iterateMapComap f i m K = LinearMap.iterateMapComap f i (m + 1) K`,\nthen the kernel of `f` is contained in `K`.\nThis is a corollary of `LinearMap.iterateMapComap_eq_succ` and `LinearMap.ker_le_comap`.\nAs a special case, if one can take `K` to be zero,\nthen `f` is injective. This is the key result for establishing the strong rank condition\nfor noetherian rings. -/\ntheorem ker_le_of_iterateMapComap_eq_succ (K : Submodule R N)\n    (m : ℕ) (heq : f.iterateMapComap i m K = f.iterateMapComap i (m + 1) K)\n    (hf : Surjective f) (hi : Injective i) : LinearMap.ker f ≤ K := by\n  rw [show K = _ from f.iterateMapComap_eq_succ i K m heq hf hi 0]\n  exact f.ker_le_comap\n\n"}
