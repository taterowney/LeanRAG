{"name":"IsRelPrime.of_squarefree_mul","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nm n : R\nh : Squarefree (HMul.hMul m n)\n⊢ IsRelPrime m n","decl":"theorem IsRelPrime.of_squarefree_mul [CommMonoid R] {m n : R} (h : Squarefree (m * n)) :\n    IsRelPrime m n := fun c hca hcb ↦ h c (mul_dvd_mul hca hcb)\n\n"}
{"name":"IsUnit.squarefree","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nx : R\nh : IsUnit x\n⊢ Squarefree x","decl":"@[simp]\ntheorem IsUnit.squarefree [CommMonoid R] {x : R} (h : IsUnit x) : Squarefree x := fun _ hdvd =>\n  isUnit_of_mul_isUnit_left (isUnit_of_dvd_unit hdvd h)\n\n"}
{"name":"squarefree_one","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\n⊢ Squarefree 1","decl":"theorem squarefree_one [CommMonoid R] : Squarefree (1 : R) :=\n  isUnit_one.squarefree\n\n"}
{"name":"not_squarefree_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\n⊢ Not (Squarefree 0)","decl":"@[simp]\ntheorem not_squarefree_zero [MonoidWithZero R] [Nontrivial R] : ¬Squarefree (0 : R) := by\n  erw [not_forall]\n  exact ⟨0, by simp⟩\n\n"}
{"name":"Squarefree.ne_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : MonoidWithZero R\ninst✝ : Nontrivial R\nm : R\nhm : Squarefree m\n⊢ Ne m 0","decl":"theorem Squarefree.ne_zero [MonoidWithZero R] [Nontrivial R] {m : R} (hm : Squarefree (m : R)) :\n    m ≠ 0 := by\n  rintro rfl\n  exact not_squarefree_zero hm\n\n"}
{"name":"Irreducible.squarefree","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nx : R\nh : Irreducible x\n⊢ Squarefree x","decl":"@[simp]\ntheorem Irreducible.squarefree [CommMonoid R] {x : R} (h : Irreducible x) : Squarefree x := by\n  rintro y ⟨z, hz⟩\n  rw [mul_assoc] at hz\n  rcases h.isUnit_or_isUnit hz with (hu | hu)\n  · exact hu\n  · apply isUnit_of_mul_isUnit_left hu\n\n"}
{"name":"Prime.squarefree","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CancelCommMonoidWithZero R\nx : R\nh : Prime x\n⊢ Squarefree x","decl":"@[simp]\ntheorem Prime.squarefree [CancelCommMonoidWithZero R] {x : R} (h : Prime x) : Squarefree x :=\n  h.irreducible.squarefree\n\n"}
{"name":"Squarefree.of_mul_left","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nm n : R\nhmn : Squarefree (HMul.hMul m n)\n⊢ Squarefree m","decl":"theorem Squarefree.of_mul_left [Monoid R] {m n : R} (hmn : Squarefree (m * n)) : Squarefree m :=\n  fun p hp => hmn p (dvd_mul_of_dvd_left hp n)\n\n"}
{"name":"Squarefree.of_mul_right","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nm n : R\nhmn : Squarefree (HMul.hMul m n)\n⊢ Squarefree n","decl":"theorem Squarefree.of_mul_right [CommMonoid R] {m n : R} (hmn : Squarefree (m * n)) :\n    Squarefree n := fun p hp => hmn p (dvd_mul_of_dvd_right hp m)\n\n"}
{"name":"Squarefree.squarefree_of_dvd","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nx y : R\nhdvd : Dvd.dvd x y\nhsq : Squarefree y\n⊢ Squarefree x","decl":"theorem Squarefree.squarefree_of_dvd [Monoid R] {x y : R} (hdvd : x ∣ y) (hsq : Squarefree y) :\n    Squarefree x := fun _ h => hsq _ (h.trans hdvd)\n\n"}
{"name":"Squarefree.eq_zero_or_one_of_pow_of_not_isUnit","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nx : R\nn : Nat\nh : Squarefree (HPow.hPow x n)\nh' : Not (IsUnit x)\n⊢ Or (Eq n 0) (Eq n 1)","decl":"theorem Squarefree.eq_zero_or_one_of_pow_of_not_isUnit [Monoid R] {x : R} {n : ℕ}\n    (h : Squarefree (x ^ n)) (h' : ¬ IsUnit x) :\n    n = 0 ∨ n = 1 := by\n  contrapose! h'\n  replace h' : 2 ≤ n := by omega\n  have : x * x ∣ x ^ n := by rw [← sq]; exact pow_dvd_pow x h'\n  exact h.squarefree_of_dvd this x (refl _)\n\n"}
{"name":"Squarefree.pow_dvd_of_pow_dvd","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : Monoid R\nx y : R\nn : Nat\nhx : Squarefree y\nh : Dvd.dvd (HPow.hPow x n) y\n⊢ Dvd.dvd (HPow.hPow x n) x","decl":"theorem Squarefree.pow_dvd_of_pow_dvd [Monoid R] {x y : R} {n : ℕ}\n    (hx : Squarefree y) (h : x ^ n ∣ y) : x ^ n ∣ x := by\n  by_cases hu : IsUnit x\n  · exact (hu.pow n).dvd\n  · rcases (hx.squarefree_of_dvd h).eq_zero_or_one_of_pow_of_not_isUnit hu with rfl | rfl <;> simp\n\n"}
{"name":"Squarefree.gcd_right","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\nhb : Squarefree b\n⊢ Squarefree (GCDMonoid.gcd a b)","decl":"theorem Squarefree.gcd_right (a : α) {b : α} (hb : Squarefree b) : Squarefree (gcd a b) :=\n  hb.squarefree_of_dvd (gcd_dvd_right _ _)\n\n"}
{"name":"Squarefree.gcd_left","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\nha : Squarefree a\n⊢ Squarefree (GCDMonoid.gcd a b)","decl":"theorem Squarefree.gcd_left {a : α} (b : α) (ha : Squarefree a) : Squarefree (gcd a b) :=\n  ha.squarefree_of_dvd (gcd_dvd_left _ _)\n\n"}
{"name":"squarefree_iff_emultiplicity_le_one","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nr : R\n⊢ Iff (Squarefree r) (∀ (x : R), Or (LE.le (emultiplicity x r) 1) (IsUnit x))","decl":"theorem squarefree_iff_emultiplicity_le_one [CommMonoid R] (r : R) :\n    Squarefree r ↔ ∀ x : R, emultiplicity x r ≤ 1 ∨ IsUnit x := by\n  refine forall_congr' fun a => ?_\n  rw [← sq, pow_dvd_iff_le_emultiplicity, or_iff_not_imp_left, not_le, imp_congr _ Iff.rfl]\n  norm_cast\n  rw [← one_add_one_eq_two]\n  exact Order.add_one_le_iff_of_not_isMax (by simp)\n\n"}
{"name":"multiplicity.squarefree_iff_emultiplicity_le_one","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoid R\nr : R\n⊢ Iff (Squarefree r) (∀ (x : R), Or (LE.le (emultiplicity x r) 1) (IsUnit x))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias multiplicity.squarefree_iff_emultiplicity_le_one := squarefree_iff_emultiplicity_le_one\n\n"}
{"name":"squarefree_iff_no_irreducibles","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : WfDvdMonoid R\nx : R\nhx₀ : Ne x 0\n⊢ Iff (Squarefree x) (∀ (p : R), Irreducible p → Not (Dvd.dvd (HMul.hMul p p) x))","decl":"theorem squarefree_iff_no_irreducibles {x : R} (hx₀ : x ≠ 0) :\n    Squarefree x ↔ ∀ p, Irreducible p → ¬ (p * p ∣ x) := by\n  refine ⟨fun h p hp hp' ↦ hp.not_unit (h p hp'), fun h d hd ↦ by_contra fun hdu ↦ ?_⟩\n  have hd₀ : d ≠ 0 := ne_zero_of_dvd_ne_zero (ne_zero_of_dvd_ne_zero hx₀ hd) (dvd_mul_left d d)\n  obtain ⟨p, irr, dvd⟩ := WfDvdMonoid.exists_irreducible_factor hdu hd₀\n  exact h p irr ((mul_dvd_mul dvd dvd).trans hd)\n\n"}
{"name":"irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : WfDvdMonoid R\nr : R\n⊢ Iff (∀ (x : R), Irreducible x → Not (Dvd.dvd (HMul.hMul x x) r)) (Or (And (Eq r 0) (∀ (x : R), Not (Irreducible x))) (Squarefree r))","decl":"theorem irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree (r : R) :\n    (∀ x : R, Irreducible x → ¬x * x ∣ r) ↔ (r = 0 ∧ ∀ x : R, ¬Irreducible x) ∨ Squarefree r := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · rcases eq_or_ne r 0 with (rfl | hr)\n    · exact .inl (by simpa using h)\n    · exact .inr ((squarefree_iff_no_irreducibles hr).mpr h)\n  · rintro (⟨rfl, h⟩ | h)\n    · simpa using h\n    intro x hx t\n    exact hx.not_unit (h x t)\n\n"}
{"name":"squarefree_iff_irreducible_sq_not_dvd_of_ne_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : WfDvdMonoid R\nr : R\nhr : Ne r 0\n⊢ Iff (Squarefree r) (∀ (x : R), Irreducible x → Not (Dvd.dvd (HMul.hMul x x) r))","decl":"theorem squarefree_iff_irreducible_sq_not_dvd_of_ne_zero {r : R} (hr : r ≠ 0) :\n    Squarefree r ↔ ∀ x : R, Irreducible x → ¬x * x ∣ r := by\n  simpa [hr] using (irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree r).symm\n\n"}
{"name":"squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : WfDvdMonoid R\nr : R\nhr : Exists fun x => Irreducible x\n⊢ Iff (Squarefree r) (∀ (x : R), Irreducible x → Not (Dvd.dvd (HMul.hMul x x) r))","decl":"theorem squarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible {r : R}\n    (hr : ∃ x : R, Irreducible x) : Squarefree r ↔ ∀ x : R, Irreducible x → ¬x * x ∣ r := by\n  rw [irreducible_sq_not_dvd_iff_eq_zero_and_no_irreducibles_or_squarefree, ← not_exists]\n  simp only [hr, not_true, false_or, and_false]\n\n"}
{"name":"Squarefree.isRadical","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : DecompositionMonoid R\nx : R\nhx : Squarefree x\n⊢ IsRadical x","decl":"theorem Squarefree.isRadical {x : R} (hx : Squarefree x) : IsRadical x :=\n  (isRadical_iff_pow_one_lt 2 one_lt_two).2 fun y hy ↦ by\n    obtain ⟨a, b, ha, hb, rfl⟩ := exists_dvd_and_dvd_of_dvd_mul (sq y ▸ hy)\n    exact (IsRelPrime.of_squarefree_mul hx).mul_dvd ha hb\n\n"}
{"name":"Squarefree.dvd_pow_iff_dvd","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\ninst✝ : DecompositionMonoid R\nx y : R\nn : Nat\nhsq : Squarefree x\nh0 : Ne n 0\n⊢ Iff (Dvd.dvd x (HPow.hPow y n)) (Dvd.dvd x y)","decl":"theorem Squarefree.dvd_pow_iff_dvd {x y : R} {n : ℕ} (hsq : Squarefree x) (h0 : n ≠ 0) :\n    x ∣ y ^ n ↔ x ∣ y := ⟨hsq.isRadical n y, (·.pow h0)⟩\n\n"}
{"name":"IsRadical.squarefree","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CancelCommMonoidWithZero R\nx : R\nh0 : Ne x 0\nh : IsRadical x\n⊢ Squarefree x","decl":"theorem IsRadical.squarefree (h0 : x ≠ 0) (h : IsRadical x) : Squarefree x := by\n  rintro z ⟨w, rfl⟩\n  specialize h 2 (z * w) ⟨w, by simp_rw [pow_two, mul_left_comm, ← mul_assoc]⟩\n  rwa [← one_mul (z * w), mul_assoc, mul_dvd_mul_iff_right, ← isUnit_iff_dvd_one] at h\n  rw [mul_assoc, mul_ne_zero_iff] at h0; exact h0.2\n\n"}
{"name":"Squarefree.pow_dvd_of_squarefree_of_pow_succ_dvd_mul_right","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CancelCommMonoidWithZero R\nx y p : R\nk : Nat\nhx : Squarefree x\nhp : Prime p\nh : Dvd.dvd (HPow.hPow p (HAdd.hAdd k 1)) (HMul.hMul x y)\n⊢ Dvd.dvd (HPow.hPow p k) y","decl":"theorem pow_dvd_of_squarefree_of_pow_succ_dvd_mul_right {k : ℕ}\n    (hx : Squarefree x) (hp : Prime p) (h : p ^ (k + 1) ∣ x * y) :\n    p ^ k ∣ y := by\n  by_cases hxp : p ∣ x\n  · obtain ⟨x', rfl⟩ := hxp\n    have hx' : ¬ p ∣ x' := fun contra ↦ hp.not_unit <| hx p (mul_dvd_mul_left p contra)\n    replace h : p ^ k ∣ x' * y := by\n      rw [pow_succ', mul_assoc] at h\n      exact (mul_dvd_mul_iff_left hp.ne_zero).mp h\n    exact hp.pow_dvd_of_dvd_mul_left _ hx' h\n  · exact (pow_dvd_pow _ k.le_succ).trans (hp.pow_dvd_of_dvd_mul_left _ hxp h)\n\n"}
{"name":"Squarefree.pow_dvd_of_squarefree_of_pow_succ_dvd_mul_left","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝ : CancelCommMonoidWithZero R\nx y p : R\nk : Nat\nhy : Squarefree y\nhp : Prime p\nh : Dvd.dvd (HPow.hPow p (HAdd.hAdd k 1)) (HMul.hMul x y)\n⊢ Dvd.dvd (HPow.hPow p k) x","decl":"theorem pow_dvd_of_squarefree_of_pow_succ_dvd_mul_left {k : ℕ}\n    (hy : Squarefree y) (hp : Prime p) (h : p ^ (k + 1) ∣ x * y) :\n    p ^ k ∣ x := by\n  rw [mul_comm] at h\n  exact pow_dvd_of_squarefree_of_pow_succ_dvd_mul_right hy hp h\n\n"}
{"name":"Squarefree.dvd_of_squarefree_of_mul_dvd_mul_right","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\nx y d : R\ninst✝ : DecompositionMonoid R\nhx : Squarefree x\nh : Dvd.dvd (HMul.hMul d d) (HMul.hMul x y)\n⊢ Dvd.dvd d y","decl":"theorem dvd_of_squarefree_of_mul_dvd_mul_right (hx : Squarefree x) (h : d * d ∣ x * y) : d ∣ y := by\n  nontriviality R\n  obtain ⟨a, b, ha, hb, eq⟩ := exists_dvd_and_dvd_of_dvd_mul h\n  replace ha : Squarefree a := hx.squarefree_of_dvd ha\n  obtain ⟨c, hc⟩ : a ∣ d := ha.isRadical 2 d ⟨b, by rw [sq, eq]⟩\n  rw [hc, mul_assoc, (mul_right_injective₀ ha.ne_zero).eq_iff] at eq\n  exact dvd_trans ⟨c, by rw [hc, ← eq, mul_comm]⟩ hb\n\n"}
{"name":"Squarefree.dvd_of_squarefree_of_mul_dvd_mul_left","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\nx y d : R\ninst✝ : DecompositionMonoid R\nhy : Squarefree y\nh : Dvd.dvd (HMul.hMul d d) (HMul.hMul x y)\n⊢ Dvd.dvd d x","decl":"theorem dvd_of_squarefree_of_mul_dvd_mul_left (hy : Squarefree y) (h : d * d ∣ x * y) : d ∣ x :=\n  dvd_of_squarefree_of_mul_dvd_mul_right hy (mul_comm x y ▸ h)\n\n"}
{"name":"squarefree_mul_iff","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\nx y : R\ninst✝ : DecompositionMonoid R\n⊢ Iff (Squarefree (HMul.hMul x y)) (And (IsRelPrime x y) (And (Squarefree x) (Squarefree y)))","decl":"/-- `x * y` is square-free iff `x` and `y` have no common factors and are themselves square-free. -/\ntheorem squarefree_mul_iff : Squarefree (x * y) ↔ IsRelPrime x y ∧ Squarefree x ∧ Squarefree y :=\n  ⟨fun h ↦ ⟨IsRelPrime.of_squarefree_mul h, h.of_mul_left, h.of_mul_right⟩,\n    fun ⟨hp, sqx, sqy⟩ _ dvd ↦ hp (sqy.dvd_of_squarefree_of_mul_dvd_mul_left dvd)\n      (sqx.dvd_of_squarefree_of_mul_dvd_mul_right dvd)⟩\n\n"}
{"name":"isRadical_iff_squarefree_or_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\nx : R\ninst✝ : DecompositionMonoid R\n⊢ Iff (IsRadical x) (Or (Squarefree x) (Eq x 0))","decl":"theorem isRadical_iff_squarefree_or_zero : IsRadical x ↔ Squarefree x ∨ x = 0 :=\n  ⟨fun hx ↦ (em <| x = 0).elim .inr fun h ↦ .inl <| hx.squarefree h,\n    Or.rec Squarefree.isRadical <| by\n      rintro rfl\n      rw [zero_isRadical_iff]\n      infer_instance⟩\n\n"}
{"name":"isRadical_iff_squarefree_of_ne_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\nx : R\ninst✝ : DecompositionMonoid R\nh : Ne x 0\n⊢ Iff (IsRadical x) (Squarefree x)","decl":"theorem isRadical_iff_squarefree_of_ne_zero (h : x ≠ 0) : IsRadical x ↔ Squarefree x :=\n  ⟨IsRadical.squarefree h, Squarefree.isRadical⟩\n\n"}
{"name":"exists_squarefree_dvd_pow_of_ne_zero","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CancelCommMonoidWithZero R\ninst✝ : UniqueFactorizationMonoid R\nx : R\nhx : Ne x 0\n⊢ Exists fun y => Exists fun n => And (Squarefree y) (And (Dvd.dvd y x) (Dvd.dvd x (HPow.hPow y n)))","decl":"lemma _root_.exists_squarefree_dvd_pow_of_ne_zero {x : R} (hx : x ≠ 0) :\n    ∃ (y : R) (n : ℕ), Squarefree y ∧ y ∣ x ∧ x ∣ y ^ n := by\n  induction' x using WfDvdMonoid.induction_on_irreducible with u hu z p hz hp ih\n  · contradiction\n  · exact ⟨1, 0, squarefree_one, one_dvd u, hu.dvd⟩\n  · obtain ⟨y, n, hy, hyx, hy'⟩ := ih hz\n    rcases n.eq_zero_or_pos with rfl | hn\n    · exact ⟨p, 1, hp.squarefree, dvd_mul_right p z, by simp [isUnit_of_dvd_one (pow_zero y ▸ hy')]⟩\n    by_cases hp' : p ∣ y\n    · exact ⟨y, n + 1, hy, dvd_mul_of_dvd_right hyx _,\n        mul_comm p z ▸ pow_succ y n ▸ mul_dvd_mul hy' hp'⟩\n    · suffices Squarefree (p * y) from ⟨p * y, n, this,\n        mul_dvd_mul_left p hyx, mul_pow p y n ▸ mul_dvd_mul (dvd_pow_self p hn.ne') hy'⟩\n      exact squarefree_mul_iff.mpr ⟨hp.isRelPrime_iff_not_dvd.mpr hp', hp.squarefree, hy⟩\n\n"}
{"name":"UniqueFactorizationMonoid.squarefree_iff_nodup_normalizedFactors","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"R : Type u_1\ninst✝² : CancelCommMonoidWithZero R\ninst✝¹ : UniqueFactorizationMonoid R\ninst✝ : NormalizationMonoid R\nx : R\nx0 : Ne x 0\n⊢ Iff (Squarefree x) (UniqueFactorizationMonoid.normalizedFactors x).Nodup","decl":"theorem squarefree_iff_nodup_normalizedFactors [NormalizationMonoid R] {x : R}\n    (x0 : x ≠ 0) : Squarefree x ↔ Multiset.Nodup (normalizedFactors x) := by\n  classical\n  rw [squarefree_iff_emultiplicity_le_one, Multiset.nodup_iff_count_le_one]\n  haveI := nontrivial_of_ne x 0 x0\n  constructor <;> intro h a\n  · by_cases hmem : a ∈ normalizedFactors x\n    · have ha := irreducible_of_normalized_factor _ hmem\n      rcases h a with (h | h)\n      · rw [← normalize_normalized_factor _ hmem]\n        rw [emultiplicity_eq_count_normalizedFactors ha x0] at h\n        assumption_mod_cast\n      · have := ha.1\n        contradiction\n    · simp [Multiset.count_eq_zero_of_not_mem hmem]\n  · rw [or_iff_not_imp_right]\n    intro hu\n    rcases eq_or_ne a 0 with rfl | h0\n    · simp [x0]\n    rcases WfDvdMonoid.exists_irreducible_factor hu h0 with ⟨b, hib, hdvd⟩\n    apply le_trans (emultiplicity_le_emultiplicity_of_dvd_left hdvd)\n    rw [emultiplicity_eq_count_normalizedFactors hib x0]\n    exact_mod_cast h (normalize b)\n\n"}
{"name":"Int.squarefree_natAbs","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"n : Int\n⊢ Iff (Squarefree n.natAbs) (Squarefree n)","decl":"@[simp]\ntheorem squarefree_natAbs {n : ℤ} : Squarefree n.natAbs ↔ Squarefree n := by\n  simp_rw [Squarefree, natAbs_surjective.forall, ← natAbs_mul, natAbs_dvd_natAbs,\n    isUnit_iff_natAbs_eq, Nat.isUnit_iff]\n\n"}
{"name":"Int.squarefree_natCast","module":"Mathlib.Algebra.Squarefree.Basic","initialProofState":"n : Nat\n⊢ Iff (Squarefree ↑n) (Squarefree n)","decl":"@[simp]\ntheorem squarefree_natCast {n : ℕ} : Squarefree (n : ℤ) ↔ Squarefree n := by\n  rw [← squarefree_natAbs, natAbs_ofNat]\n\n"}
