{"name":"RingHom.RespectsIso.cancel_left_isIso","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso P\nR S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\ninst✝ : CategoryTheory.IsIso f\n⊢ Iff (P ((CommRingCat.Hom.hom g).comp (CommRingCat.Hom.hom f))) (P (CommRingCat.Hom.hom g))","decl":"theorem RespectsIso.cancel_left_isIso (hP : RespectsIso @P) {R S T : CommRingCat} (f : R ⟶ S)\n    (g : S ⟶ T) [IsIso f] : P (g.hom.comp f.hom) ↔ P g.hom :=\n  ⟨fun H => by\n    convert hP.2 (f ≫ g).hom (asIso f).symm.commRingCatIsoToRingEquiv H\n    simp [← CommRingCat.hom_comp], hP.2 g.hom (asIso f).commRingCatIsoToRingEquiv⟩\n\n"}
{"name":"RingHom.RespectsIso.cancel_right_isIso","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso P\nR S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom S T\ninst✝ : CategoryTheory.IsIso g\n⊢ Iff (P ((CommRingCat.Hom.hom g).comp (CommRingCat.Hom.hom f))) (P (CommRingCat.Hom.hom f))","decl":"theorem RespectsIso.cancel_right_isIso (hP : RespectsIso @P) {R S T : CommRingCat} (f : R ⟶ S)\n    (g : S ⟶ T) [IsIso g] : P (g.hom.comp f.hom) ↔ P f.hom :=\n  ⟨fun H => by\n    convert hP.1 (f ≫ g).hom (asIso g).symm.commRingCatIsoToRingEquiv H\n    simp [← CommRingCat.hom_comp], hP.1 f.hom (asIso g).commRingCatIsoToRingEquiv⟩\n\n"}
{"name":"RingHom.RespectsIso.is_localization_away_iff","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso P\nR S R' S' : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : CommRing R'\ninst✝⁴ : CommRing S'\ninst✝³ : Algebra R R'\ninst✝² : Algebra S S'\nf : RingHom R S\nr : R\ninst✝¹ : IsLocalization.Away r R'\ninst✝ : IsLocalization.Away (f r) S'\n⊢ Iff (P (Localization.awayMap f r)) (P (IsLocalization.Away.map R' S' f r))","decl":"theorem RespectsIso.is_localization_away_iff (hP : RingHom.RespectsIso @P) {R S : Type u}\n    (R' S' : Type u) [CommRing R] [CommRing S] [CommRing R'] [CommRing S'] [Algebra R R']\n    [Algebra S S'] (f : R →+* S) (r : R) [IsLocalization.Away r R'] [IsLocalization.Away (f r) S'] :\n    P (Localization.awayMap f r) ↔ P (IsLocalization.Away.map R' S' f r) := by\n  let e₁ : R' ≃+* Localization.Away r :=\n    (IsLocalization.algEquiv (Submonoid.powers r) _ _).toRingEquiv\n  let e₂ : Localization.Away (f r) ≃+* S' :=\n    (IsLocalization.algEquiv (Submonoid.powers (f r)) _ _).toRingEquiv\n  refine (hP.cancel_left_isIso e₁.toCommRingCatIso.hom (CommRingCat.ofHom _)).symm.trans ?_\n  refine (hP.cancel_right_isIso (CommRingCat.ofHom _) e₂.toCommRingCatIso.hom).symm.trans ?_\n  rw [← eq_iff_iff]\n  congr 1\n  -- Porting note: Here, the proof used to have a huge `simp` involving `[anonymous]`, which didn't\n  -- work out anymore. The issue seemed to be that it couldn't handle a term in which Ring\n  -- homomorphisms were repeatedly casted to the bundled category and back. Here we resolve the\n  -- problem by converting the goal to a more straightforward form.\n  let e := (e₂ : Localization.Away (f r) →+* S').comp\n      (((IsLocalization.map (Localization.Away (f r)) f\n            (by rintro x ⟨n, rfl⟩; use n; simp : Submonoid.powers r ≤ Submonoid.comap f\n                (Submonoid.powers (f r)))) : Localization.Away r →+* Localization.Away (f r)).comp\n                (e₁ : R' →+* Localization.Away r))\n  suffices e = IsLocalization.Away.map R' S' f r by\n    convert this\n  apply IsLocalization.ringHom_ext (Submonoid.powers r) _\n  ext1 x\n  dsimp [e, e₁, e₂, IsLocalization.Away.map]\n  simp only [IsLocalization.map_eq, id_apply, RingHomCompTriple.comp_apply]\n\n"}
{"name":"RingHom.StableUnderComposition.respectsIso","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.StableUnderComposition P\nhP' : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (e : RingEquiv R S), P e.toRingHom\n⊢ RingHom.RespectsIso P","decl":"theorem StableUnderComposition.respectsIso (hP : RingHom.StableUnderComposition @P)\n    (hP' : ∀ {R S : Type u} [CommRing R] [CommRing S] (e : R ≃+* S), P e.toRingHom) :\n    RingHom.RespectsIso @P := by\n  constructor\n  · introv H\n    apply hP\n    exacts [H, hP' e]\n  · introv H\n    apply hP\n    exacts [hP' e, H]\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.mk","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nh₁ : RingHom.RespectsIso P\nh₂ : ∀ ⦃R S T : Type u⦄ [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] [inst_3 : Algebra R S] [inst_4 : Algebra R T], P (algebraMap R T) → P Algebra.TensorProduct.includeLeftRingHom\n⊢ RingHom.IsStableUnderBaseChange P","decl":"theorem IsStableUnderBaseChange.mk (h₁ : RespectsIso @P)\n    (h₂ :\n      ∀ ⦃R S T⦄ [CommRing R] [CommRing S] [CommRing T],\n        ∀ [Algebra R S] [Algebra R T],\n          P (algebraMap R T) →\n            P (Algebra.TensorProduct.includeLeftRingHom : S →+* TensorProduct R S T)) :\n    IsStableUnderBaseChange @P := by\n  introv R h H\n  let e := h.symm.1.equiv\n  let f' :=\n    Algebra.TensorProduct.productMap (IsScalarTower.toAlgHom R R' S')\n      (IsScalarTower.toAlgHom R S S')\n  have : ∀ x, e x = f' x := by\n    intro x\n    change e.toLinearMap.restrictScalars R x = f'.toLinearMap x\n    congr 1\n    apply TensorProduct.ext'\n    intro x y\n    simp [e, f', IsBaseChange.equiv_tmul, Algebra.smul_def]\n  -- Porting Note: This had a lot of implicit inferences which didn't resolve anymore.\n  -- Added those in\n  convert h₁.1 (_ : R' →+* TensorProduct R R' S) (_ : TensorProduct R R' S ≃+* S')\n      (h₂ H : P (_ : R' →+* TensorProduct R R' S))\n  swap\n  · refine { e with map_mul' := fun x y => ?_ }\n    change e (x * y) = e x * e y\n    simp_rw [this]\n    exact map_mul f' _ _\n  · ext x\n    change _ = e (x ⊗ₜ[R] 1)\n    -- Porting note: Had `dsimp only [e]` here, which didn't work anymore\n    rw [h.symm.1.equiv_tmul, Algebra.smul_def, AlgHom.toLinearMap_apply, map_one, mul_one]\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.pushout_inl","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange P\nhP' : RingHom.RespectsIso P\nR S T : CommRingCat\nf : Quiver.Hom R S\ng : Quiver.Hom R T\nH : P (CommRingCat.Hom.hom g)\n⊢ P (CommRingCat.Hom.hom (CategoryTheory.Limits.pushout.inl f g))","decl":"theorem IsStableUnderBaseChange.pushout_inl (hP : RingHom.IsStableUnderBaseChange @P)\n    (hP' : RingHom.RespectsIso @P) {R S T : CommRingCat} (f : R ⟶ S) (g : R ⟶ T) (H : P g.hom) :\n    P (pushout.inl _ _ : S ⟶ pushout f g).hom := by\n  letI := f.hom.toAlgebra\n  letI := g.hom.toAlgebra\n  rw [← show _ = pushout.inl f g from\n      colimit.isoColimitCocone_ι_inv ⟨_, CommRingCat.pushoutCoconeIsColimit R S T⟩ WalkingSpan.left,\n    CommRingCat.hom_comp, hP'.cancel_right_isIso]\n  dsimp only [CommRingCat.pushoutCocone_inl, PushoutCocone.ι_app_left]\n  apply hP R T S (TensorProduct R S T)\n  exact H\n\n"}
{"name":"RingHom.toMorphismProperty_respectsIso_iff","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\n⊢ Iff (RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P) (RingHom.toMorphismProperty fun {R S} [CommRing R] [CommRing S] => P).RespectsIso","decl":"lemma toMorphismProperty_respectsIso_iff :\n    RespectsIso P ↔ (toMorphismProperty P).RespectsIso := by\n  refine ⟨fun h ↦ MorphismProperty.RespectsIso.mk _ ?_ ?_, fun h ↦ ⟨?_, ?_⟩⟩\n  · intro X Y Z e f hf\n    exact h.right f.hom e.commRingCatIsoToRingEquiv hf\n  · intro X Y Z e f hf\n    exact h.left f.hom e.commRingCatIsoToRingEquiv hf\n  · intro X Y Z _ _ _ f e hf\n    exact MorphismProperty.RespectsIso.postcomp (toMorphismProperty P)\n      e.toCommRingCatIso.hom (CommRingCat.ofHom f) hf\n  · intro X Y Z _ _ _ f e\n    exact MorphismProperty.RespectsIso.precomp (toMorphismProperty P)\n      e.toCommRingCatIso.hom (CommRingCat.ofHom f)\n\n"}
{"name":"RingHom.RespectsIso.arrow_mk_iso_iff","module":"Mathlib.RingTheory.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQ : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nA B A' B' : CommRingCat\nf : Quiver.Hom A B\ng : Quiver.Hom A' B'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n⊢ Iff (P (CommRingCat.Hom.hom f)) (P (CommRingCat.Hom.hom g))","decl":"/-- Variant of `MorphismProperty.arrow_mk_iso_iff` specialized to morphism properties in\n`CommRingCat` given by ring hom properties. -/\nlemma RespectsIso.arrow_mk_iso_iff (hQ : RingHom.RespectsIso P) {A B A' B' : CommRingCat}\n    {f : A ⟶ B} {g : A' ⟶ B'} (e : Arrow.mk f ≅ Arrow.mk g) :\n    P f.hom ↔ P g.hom := by\n  have : (toMorphismProperty P).RespectsIso := by\n    rwa [← toMorphismProperty_respectsIso_iff]\n  change toMorphismProperty P _ ↔ toMorphismProperty P _\n  rw [MorphismProperty.arrow_mk_iso_iff (toMorphismProperty P) e]\n\n"}
