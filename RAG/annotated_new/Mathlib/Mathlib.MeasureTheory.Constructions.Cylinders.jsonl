{"name":"MeasureTheory.squareCylinders_eq_iUnion_image","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\nC : (i : ι) → Set (Set (α i))\n⊢ Eq (MeasureTheory.squareCylinders C) (Set.iUnion fun s => Set.image (fun t => (↑s).pi t) (Set.univ.pi C))","decl":"theorem squareCylinders_eq_iUnion_image (C : ∀ i, Set (Set (α i))) :\n    squareCylinders C = ⋃ s : Finset ι, (fun t ↦ (s : Set ι).pi t) '' univ.pi C := by\n  ext1 f\n  simp only [squareCylinders, mem_iUnion, mem_image, mem_univ_pi, exists_prop, mem_setOf_eq,\n    eq_comm (a := f)]\n\n"}
{"name":"MeasureTheory.isPiSystem_squareCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\nC : (i : ι) → Set (Set (α i))\nhC : ∀ (i : ι), IsPiSystem (C i)\nhC_univ : ∀ (i : ι), Membership.mem (C i) Set.univ\n⊢ IsPiSystem (MeasureTheory.squareCylinders C)","decl":"theorem isPiSystem_squareCylinders {C : ∀ i, Set (Set (α i))} (hC : ∀ i, IsPiSystem (C i))\n    (hC_univ : ∀ i, univ ∈ C i) :\n    IsPiSystem (squareCylinders C) := by\n  rintro S₁ ⟨s₁, t₁, h₁, rfl⟩ S₂ ⟨s₂, t₂, h₂, rfl⟩ hst_nonempty\n  classical\n  let t₁' := s₁.piecewise t₁ (fun i ↦ univ)\n  let t₂' := s₂.piecewise t₂ (fun i ↦ univ)\n  have h1 : ∀ i ∈ (s₁ : Set ι), t₁ i = t₁' i :=\n    fun i hi ↦ (Finset.piecewise_eq_of_mem _ _ _ hi).symm\n  have h1' : ∀ i ∉ (s₁ : Set ι), t₁' i = univ :=\n    fun i hi ↦ Finset.piecewise_eq_of_not_mem _ _ _ hi\n  have h2 : ∀ i ∈ (s₂ : Set ι), t₂ i = t₂' i :=\n    fun i hi ↦ (Finset.piecewise_eq_of_mem _ _ _ hi).symm\n  have h2' : ∀ i ∉ (s₂ : Set ι), t₂' i = univ :=\n    fun i hi ↦ Finset.piecewise_eq_of_not_mem _ _ _ hi\n  rw [Set.pi_congr rfl h1, Set.pi_congr rfl h2, ← union_pi_inter h1' h2']\n  refine ⟨s₁ ∪ s₂, fun i ↦ t₁' i ∩ t₂' i, ?_, ?_⟩\n  · rw [mem_univ_pi]\n    intro i\n    have : (t₁' i ∩ t₂' i).Nonempty := by\n      obtain ⟨f, hf⟩ := hst_nonempty\n      rw [Set.pi_congr rfl h1, Set.pi_congr rfl h2, mem_inter_iff, mem_pi, mem_pi] at hf\n      refine ⟨f i, ⟨?_, ?_⟩⟩\n      · by_cases hi₁ : i ∈ s₁\n        · exact hf.1 i hi₁\n        · rw [h1' i hi₁]\n          exact mem_univ _\n      · by_cases hi₂ : i ∈ s₂\n        · exact hf.2 i hi₂\n        · rw [h2' i hi₂]\n          exact mem_univ _\n    refine hC i _ ?_ _ ?_ this\n    · by_cases hi₁ : i ∈ s₁\n      · rw [← h1 i hi₁]\n        exact h₁ i (mem_univ _)\n      · rw [h1' i hi₁]\n        exact hC_univ i\n    · by_cases hi₂ : i ∈ s₂\n      · rw [← h2 i hi₂]\n        exact h₂ i (mem_univ _)\n      · rw [h2' i hi₂]\n        exact hC_univ i\n  · rw [Finset.coe_union]\n\n"}
{"name":"MeasureTheory.comap_eval_le_generateFrom_squareCylinders_singleton","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\nm : (i : ι) → MeasurableSpace (α i)\ni : ι\n⊢ LE.le (MeasurableSpace.comap (Function.eval i) (m i)) (MeasurableSpace.generateFrom (Set.image (fun t => (Singleton.singleton i).pi t) (Set.univ.pi fun i => setOf fun s => MeasurableSet s)))","decl":"theorem comap_eval_le_generateFrom_squareCylinders_singleton\n    (α : ι → Type*) [m : ∀ i, MeasurableSpace (α i)] (i : ι) :\n    MeasurableSpace.comap (Function.eval i) (m i) ≤\n      MeasurableSpace.generateFrom\n        ((fun t ↦ ({i} : Set ι).pi t) '' univ.pi fun i ↦ {s : Set (α i) | MeasurableSet s}) := by\n  simp only [Function.eval, singleton_pi]\n  rw [MeasurableSpace.comap_eq_generateFrom]\n  refine MeasurableSpace.generateFrom_mono fun S ↦ ?_\n  simp only [mem_setOf_eq, mem_image, mem_univ_pi, forall_exists_index, and_imp]\n  intro t ht h\n  classical\n  refine ⟨fun j ↦ if hji : j = i then by convert t else univ, fun j ↦ ?_, ?_⟩\n  · by_cases hji : j = i\n    · simp only [hji, eq_self_iff_true, eq_mpr_eq_cast, dif_pos]\n      convert ht\n      simp only [id_eq, cast_heq]\n    · simp only [hji, not_false_iff, dif_neg, MeasurableSet.univ]\n  · simp only [id_eq, eq_mpr_eq_cast, ← h]\n    ext1 x\n    simp only [singleton_pi, Function.eval, cast_eq, dite_eq_ite, ite_true, mem_preimage]\n\n"}
{"name":"MeasureTheory.generateFrom_squareCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ Eq (MeasurableSpace.generateFrom (MeasureTheory.squareCylinders fun i => setOf fun s => MeasurableSet s)) MeasurableSpace.pi","decl":"/-- The square cylinders formed from measurable sets generate the product σ-algebra. -/\ntheorem generateFrom_squareCylinders [∀ i, MeasurableSpace (α i)] :\n    MeasurableSpace.generateFrom (squareCylinders fun i ↦ {s : Set (α i) | MeasurableSet s}) =\n      MeasurableSpace.pi := by\n  apply le_antisymm\n  · rw [MeasurableSpace.generateFrom_le_iff]\n    rintro S ⟨s, t, h, rfl⟩\n    simp only [mem_univ_pi, mem_setOf_eq] at h\n    exact MeasurableSet.pi (Finset.countable_toSet _) (fun i _ ↦ h i)\n  · refine iSup_le fun i ↦ ?_\n    refine (comap_eval_le_generateFrom_squareCylinders_singleton α i).trans ?_\n    refine MeasurableSpace.generateFrom_mono ?_\n    rw [← Finset.coe_singleton, squareCylinders_eq_iUnion_image]\n    exact subset_iUnion\n      (fun (s : Finset ι) ↦\n        (fun t : ∀ i, Set (α i) ↦ (s : Set ι).pi t) '' univ.pi (fun i ↦ setOf MeasurableSet))\n      ({i} : Finset ι)\n\n"}
{"name":"MeasureTheory.mem_cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\nf : (i : ι) → α i\n⊢ Iff (Membership.mem (MeasureTheory.cylinder s S) f) (Membership.mem S (s.restrict f))","decl":"@[simp]\ntheorem mem_cylinder (s : Finset ι) (S : Set (∀ i : s, α i)) (f : ∀ i, α i) :\n    f ∈ cylinder s S ↔ s.restrict f ∈ S :=\n  mem_preimage\n\n"}
{"name":"MeasureTheory.cylinder_empty","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\n⊢ Eq (MeasureTheory.cylinder s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem cylinder_empty (s : Finset ι) : cylinder s (∅ : Set (∀ i : s, α i)) = ∅ := by\n  rw [cylinder, preimage_empty]\n\n"}
{"name":"MeasureTheory.cylinder_univ","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\n⊢ Eq (MeasureTheory.cylinder s Set.univ) Set.univ","decl":"@[simp]\ntheorem cylinder_univ (s : Finset ι) : cylinder s (univ : Set (∀ i : s, α i)) = univ := by\n  rw [cylinder, preimage_univ]\n\n"}
{"name":"MeasureTheory.cylinder_eq_empty_iff","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nh_nonempty : Nonempty ((i : ι) → α i)\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\n⊢ Iff (Eq (MeasureTheory.cylinder s S) EmptyCollection.emptyCollection) (Eq S EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem cylinder_eq_empty_iff [h_nonempty : Nonempty (∀ i, α i)] (s : Finset ι)\n    (S : Set (∀ i : s, α i)) :\n    cylinder s S = ∅ ↔ S = ∅ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by (rw [h]; exact cylinder_empty _)⟩\n  by_contra hS\n  rw [← Ne, ← nonempty_iff_ne_empty] at hS\n  let f := hS.some\n  have hf : f ∈ S := hS.choose_spec\n  classical\n  let f' : ∀ i, α i := fun i ↦ if hi : i ∈ s then f ⟨i, hi⟩ else h_nonempty.some i\n  have hf' : f' ∈ cylinder s S := by\n    rw [mem_cylinder]\n    simpa only [Finset.restrict_def, Finset.coe_mem, dif_pos, f']\n  rw [h] at hf'\n  exact not_mem_empty _ hf'\n\n"}
{"name":"MeasureTheory.inter_cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Finset ι\nS₁ : Set ((i : Subtype fun x => Membership.mem s₁ x) → α ↑i)\nS₂ : Set ((i : Subtype fun x => Membership.mem s₂ x) → α ↑i)\ninst✝ : DecidableEq ι\n⊢ Eq (Inter.inter (MeasureTheory.cylinder s₁ S₁) (MeasureTheory.cylinder s₂ S₂)) (MeasureTheory.cylinder (Union.union s₁ s₂) (Inter.inter (Set.preimage (Finset.restrict₂ ⋯) S₁) (Set.preimage (Finset.restrict₂ ⋯) S₂)))","decl":"theorem inter_cylinder (s₁ s₂ : Finset ι) (S₁ : Set (∀ i : s₁, α i)) (S₂ : Set (∀ i : s₂, α i))\n    [DecidableEq ι] :\n    cylinder s₁ S₁ ∩ cylinder s₂ S₂ =\n      cylinder (s₁ ∪ s₂)\n        (Finset.restrict₂ Finset.subset_union_left ⁻¹' S₁ ∩\n          Finset.restrict₂ Finset.subset_union_right ⁻¹' S₂) := by\n  ext1 f; simp only [mem_inter_iff, mem_cylinder, mem_setOf_eq]; rfl\n\n"}
{"name":"MeasureTheory.inter_cylinder_same","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nS₁ S₂ : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\n⊢ Eq (Inter.inter (MeasureTheory.cylinder s S₁) (MeasureTheory.cylinder s S₂)) (MeasureTheory.cylinder s (Inter.inter S₁ S₂))","decl":"theorem inter_cylinder_same (s : Finset ι) (S₁ : Set (∀ i : s, α i)) (S₂ : Set (∀ i : s, α i)) :\n    cylinder s S₁ ∩ cylinder s S₂ = cylinder s (S₁ ∩ S₂) := by\n  classical rw [inter_cylinder]; rfl\n\n"}
{"name":"MeasureTheory.union_cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns₁ s₂ : Finset ι\nS₁ : Set ((i : Subtype fun x => Membership.mem s₁ x) → α ↑i)\nS₂ : Set ((i : Subtype fun x => Membership.mem s₂ x) → α ↑i)\ninst✝ : DecidableEq ι\n⊢ Eq (Union.union (MeasureTheory.cylinder s₁ S₁) (MeasureTheory.cylinder s₂ S₂)) (MeasureTheory.cylinder (Union.union s₁ s₂) (Union.union (Set.preimage (Finset.restrict₂ ⋯) S₁) (Set.preimage (Finset.restrict₂ ⋯) S₂)))","decl":"theorem union_cylinder (s₁ s₂ : Finset ι) (S₁ : Set (∀ i : s₁, α i)) (S₂ : Set (∀ i : s₂, α i))\n    [DecidableEq ι] :\n    cylinder s₁ S₁ ∪ cylinder s₂ S₂ =\n      cylinder (s₁ ∪ s₂)\n        (Finset.restrict₂ Finset.subset_union_left ⁻¹' S₁ ∪\n          Finset.restrict₂ Finset.subset_union_right ⁻¹' S₂) := by\n  ext1 f; simp only [mem_union, mem_cylinder, mem_setOf_eq]; rfl\n\n"}
{"name":"MeasureTheory.union_cylinder_same","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nS₁ S₂ : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\n⊢ Eq (Union.union (MeasureTheory.cylinder s S₁) (MeasureTheory.cylinder s S₂)) (MeasureTheory.cylinder s (Union.union S₁ S₂))","decl":"theorem union_cylinder_same (s : Finset ι) (S₁ : Set (∀ i : s, α i)) (S₂ : Set (∀ i : s, α i)) :\n    cylinder s S₁ ∪ cylinder s S₂ = cylinder s (S₁ ∪ S₂) := by\n  classical rw [union_cylinder]; rfl\n\n"}
{"name":"MeasureTheory.compl_cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\n⊢ Eq (HasCompl.compl (MeasureTheory.cylinder s S)) (MeasureTheory.cylinder s (HasCompl.compl S))","decl":"theorem compl_cylinder (s : Finset ι) (S : Set (∀ i : s, α i)) :\n    (cylinder s S)ᶜ = cylinder s (Sᶜ) := by\n  ext1 f; simp only [mem_compl_iff, mem_cylinder]\n\n"}
{"name":"MeasureTheory.diff_cylinder_same","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ns : Finset ι\nS T : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\n⊢ Eq (SDiff.sdiff (MeasureTheory.cylinder s S) (MeasureTheory.cylinder s T)) (MeasureTheory.cylinder s (SDiff.sdiff S T))","decl":"theorem diff_cylinder_same (s : Finset ι) (S T : Set (∀ i : s, α i)) :\n    cylinder s S \\ cylinder s T = cylinder s (S \\ T) := by\n  ext1 f; simp only [mem_diff, mem_cylinder]\n\n"}
{"name":"MeasureTheory.eq_of_cylinder_eq_of_subset","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\nh_nonempty : Nonempty ((i : ι) → α i)\nI J : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem I x) → α ↑i)\nT : Set ((i : Subtype fun x => Membership.mem J x) → α ↑i)\nh_eq : Eq (MeasureTheory.cylinder I S) (MeasureTheory.cylinder J T)\nhJI : HasSubset.Subset J I\n⊢ Eq S (Set.preimage (Finset.restrict₂ hJI) T)","decl":"theorem eq_of_cylinder_eq_of_subset [h_nonempty : Nonempty (∀ i, α i)] {I J : Finset ι}\n    {S : Set (∀ i : I, α i)} {T : Set (∀ i : J, α i)} (h_eq : cylinder I S = cylinder J T)\n    (hJI : J ⊆ I) :\n    S = Finset.restrict₂ hJI ⁻¹' T := by\n  rw [Set.ext_iff] at h_eq\n  simp only [mem_cylinder] at h_eq\n  ext1 f\n  simp only [mem_preimage]\n  classical\n  specialize h_eq fun i ↦ if hi : i ∈ I then f ⟨i, hi⟩ else h_nonempty.some i\n  have h_mem : ∀ j : J, ↑j ∈ I := fun j ↦ hJI j.prop\n  simpa only [Finset.restrict_def, Finset.coe_mem, dite_true, h_mem] using h_eq\n\n"}
{"name":"MeasureTheory.cylinder_eq_cylinder_union","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : DecidableEq ι\nI : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem I x) → α ↑i)\nJ : Finset ι\n⊢ Eq (MeasureTheory.cylinder I S) (MeasureTheory.cylinder (Union.union I J) (Set.preimage (Finset.restrict₂ ⋯) S))","decl":"theorem cylinder_eq_cylinder_union [DecidableEq ι] (I : Finset ι) (S : Set (∀ i : I, α i))\n    (J : Finset ι) :\n    cylinder I S =\n      cylinder (I ∪ J) (Finset.restrict₂ Finset.subset_union_left ⁻¹' S) := by\n  ext1 f; simp only [mem_cylinder, Finset.restrict_def, Finset.restrict₂_def, mem_preimage]\n\n"}
{"name":"MeasureTheory.disjoint_cylinder_iff","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : Nonempty ((i : ι) → α i)\ns t : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\nT : Set ((i : Subtype fun x => Membership.mem t x) → α ↑i)\ninst✝ : DecidableEq ι\n⊢ Iff (Disjoint (MeasureTheory.cylinder s S) (MeasureTheory.cylinder t T)) (Disjoint (Set.preimage (Finset.restrict₂ ⋯) S) (Set.preimage (Finset.restrict₂ ⋯) T))","decl":"theorem disjoint_cylinder_iff [Nonempty (∀ i, α i)] {s t : Finset ι} {S : Set (∀ i : s, α i)}\n    {T : Set (∀ i : t, α i)} [DecidableEq ι] :\n    Disjoint (cylinder s S) (cylinder t T) ↔\n      Disjoint\n        (Finset.restrict₂ Finset.subset_union_left ⁻¹' S)\n        (Finset.restrict₂ Finset.subset_union_right ⁻¹' T) := by\n  simp_rw [Set.disjoint_iff, subset_empty_iff, inter_cylinder, cylinder_eq_empty_iff]\n\n"}
{"name":"MeasureTheory.IsClosed.cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\ninst✝ : (i : ι) → TopologicalSpace (α i)\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\nhs : IsClosed S\n⊢ IsClosed (MeasureTheory.cylinder s S)","decl":"theorem IsClosed.cylinder [∀ i, TopologicalSpace (α i)] (s : Finset ι) {S : Set (∀ i : s, α i)}\n    (hs : IsClosed S) : IsClosed (cylinder s S) :=\n  hs.preimage (continuous_pi fun _ ↦ continuous_apply _)\n\n"}
{"name":"MeasurableSet.cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\nhS : MeasurableSet S\n⊢ MeasurableSet (MeasureTheory.cylinder s S)","decl":"theorem _root_.MeasurableSet.cylinder [∀ i, MeasurableSpace (α i)] (s : Finset ι)\n    {S : Set (∀ i : s, α i)} (hS : MeasurableSet S) :\n    MeasurableSet (cylinder s S) :=\n  measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _) hS\n\n"}
{"name":"MeasureTheory.empty_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) EmptyCollection.emptyCollection","decl":"theorem empty_mem_measurableCylinders (α : ι → Type*) [∀ i, MeasurableSpace (α i)] :\n    ∅ ∈ measurableCylinders α := by\n  simp_rw [measurableCylinders, mem_iUnion, mem_singleton_iff]\n  exact ⟨∅, ∅, MeasurableSet.empty, (cylinder_empty _).symm⟩\n\n"}
{"name":"MeasureTheory.mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nt : Set ((i : ι) → α i)\n⊢ Iff (Membership.mem (MeasureTheory.measurableCylinders α) t) (Exists fun s => Exists fun S => And (MeasurableSet S) (Eq t (MeasureTheory.cylinder s S)))","decl":"@[simp]\ntheorem mem_measurableCylinders (t : Set (∀ i, α i)) :\n    t ∈ measurableCylinders α ↔ ∃ s S, MeasurableSet S ∧ t = cylinder s S := by\n  simp_rw [measurableCylinders, mem_iUnion, exists_prop, mem_singleton_iff]\n\n"}
{"name":"MeasurableSet.of_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns : Set ((i : ι) → α i)\nhs : Membership.mem (MeasureTheory.measurableCylinders α) s\n⊢ MeasurableSet s","decl":"@[measurability]\ntheorem _root_.MeasurableSet.of_mem_measurableCylinders {s : Set (Π i, α i)}\n    (hs : s ∈ measurableCylinders α) : MeasurableSet s := by\n  obtain ⟨I, t, mt, rfl⟩ := (mem_measurableCylinders s).1 hs\n  exact mt.cylinder\n\n"}
{"name":"MeasureTheory.measurableCylinders.measurableSet","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nt : Set ((i : ι) → α i)\nht : Membership.mem (MeasureTheory.measurableCylinders α) t\n⊢ MeasurableSet (MeasureTheory.measurableCylinders.set ht)","decl":"theorem measurableCylinders.measurableSet (ht : t ∈ measurableCylinders α) :\n    MeasurableSet (measurableCylinders.set ht) :=\n  ((mem_measurableCylinders t).mp ht).choose_spec.choose_spec.left\n\n"}
{"name":"MeasureTheory.measurableCylinders.eq_cylinder","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nt : Set ((i : ι) → α i)\nht : Membership.mem (MeasureTheory.measurableCylinders α) t\n⊢ Eq t (MeasureTheory.cylinder (MeasureTheory.measurableCylinders.finset ht) (MeasureTheory.measurableCylinders.set ht))","decl":"theorem measurableCylinders.eq_cylinder (ht : t ∈ measurableCylinders α) :\n    t = cylinder (measurableCylinders.finset ht) (measurableCylinders.set ht) :=\n  ((mem_measurableCylinders t).mp ht).choose_spec.choose_spec.right\n\n"}
{"name":"MeasureTheory.cylinder_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns : Finset ι\nS : Set ((i : Subtype fun x => Membership.mem s x) → α ↑i)\nhS : MeasurableSet S\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) (MeasureTheory.cylinder s S)","decl":"theorem cylinder_mem_measurableCylinders (s : Finset ι) (S : Set (∀ i : s, α i))\n    (hS : MeasurableSet S) :\n    cylinder s S ∈ measurableCylinders α := by\n  rw [mem_measurableCylinders]; exact ⟨s, S, hS, rfl⟩\n\n"}
{"name":"MeasureTheory.inter_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns t : Set ((i : ι) → α i)\nhs : Membership.mem (MeasureTheory.measurableCylinders α) s\nht : Membership.mem (MeasureTheory.measurableCylinders α) t\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) (Inter.inter s t)","decl":"theorem inter_mem_measurableCylinders (hs : s ∈ measurableCylinders α)\n    (ht : t ∈ measurableCylinders α) :\n    s ∩ t ∈ measurableCylinders α := by\n  rw [mem_measurableCylinders] at *\n  obtain ⟨s₁, S₁, hS₁, rfl⟩ := hs\n  obtain ⟨s₂, S₂, hS₂, rfl⟩ := ht\n  classical\n  refine ⟨s₁ ∪ s₂,\n    Finset.restrict₂ Finset.subset_union_left ⁻¹' S₁ ∩\n      {f | Finset.restrict₂ Finset.subset_union_right f ∈ S₂}, ?_, ?_⟩\n  · refine MeasurableSet.inter ?_ ?_\n    · exact measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _) hS₁\n    · exact measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _) hS₂\n  · exact inter_cylinder _ _ _ _\n\n"}
{"name":"MeasureTheory.isPiSystem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ IsPiSystem (MeasureTheory.measurableCylinders α)","decl":"theorem isPiSystem_measurableCylinders : IsPiSystem (measurableCylinders α) :=\n  fun _ hS _ hT _ ↦ inter_mem_measurableCylinders hS hT\n\n"}
{"name":"MeasureTheory.compl_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns : Set ((i : ι) → α i)\nhs : Membership.mem (MeasureTheory.measurableCylinders α) s\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) (HasCompl.compl s)","decl":"theorem compl_mem_measurableCylinders (hs : s ∈ measurableCylinders α) :\n    sᶜ ∈ measurableCylinders α := by\n  rw [mem_measurableCylinders] at hs ⊢\n  obtain ⟨s, S, hS, rfl⟩ := hs\n  refine ⟨s, Sᶜ, hS.compl, ?_⟩\n  rw [compl_cylinder]\n\n"}
{"name":"MeasureTheory.univ_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nα : ι → Type u_1\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) Set.univ","decl":"theorem univ_mem_measurableCylinders (α : ι → Type*) [∀ i, MeasurableSpace (α i)] :\n    Set.univ ∈ measurableCylinders α := by\n  rw [← compl_empty]; exact compl_mem_measurableCylinders (empty_mem_measurableCylinders α)\n\n"}
{"name":"MeasureTheory.union_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns t : Set ((i : ι) → α i)\nhs : Membership.mem (MeasureTheory.measurableCylinders α) s\nht : Membership.mem (MeasureTheory.measurableCylinders α) t\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) (Union.union s t)","decl":"theorem union_mem_measurableCylinders (hs : s ∈ measurableCylinders α)\n    (ht : t ∈ measurableCylinders α) :\n    s ∪ t ∈ measurableCylinders α := by\n  rw [union_eq_compl_compl_inter_compl]\n  exact compl_mem_measurableCylinders (inter_mem_measurableCylinders\n    (compl_mem_measurableCylinders hs) (compl_mem_measurableCylinders ht))\n\n"}
{"name":"MeasureTheory.diff_mem_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\ns t : Set ((i : ι) → α i)\nhs : Membership.mem (MeasureTheory.measurableCylinders α) s\nht : Membership.mem (MeasureTheory.measurableCylinders α) t\n⊢ Membership.mem (MeasureTheory.measurableCylinders α) (SDiff.sdiff s t)","decl":"theorem diff_mem_measurableCylinders (hs : s ∈ measurableCylinders α)\n    (ht : t ∈ measurableCylinders α) :\n    s \\ t ∈ measurableCylinders α := by\n  rw [diff_eq_compl_inter]\n  exact inter_mem_measurableCylinders (compl_mem_measurableCylinders ht) hs\n\n"}
{"name":"MeasureTheory.generateFrom_measurableCylinders","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\n⊢ Eq (MeasurableSpace.generateFrom (MeasureTheory.measurableCylinders α)) MeasurableSpace.pi","decl":"/-- The measurable cylinders generate the product σ-algebra. -/\ntheorem generateFrom_measurableCylinders :\n    MeasurableSpace.generateFrom (measurableCylinders α) = MeasurableSpace.pi := by\n  apply le_antisymm\n  · refine MeasurableSpace.generateFrom_le (fun S hS ↦ ?_)\n    obtain ⟨s, S, hSm, rfl⟩ := (mem_measurableCylinders _).mp hS\n    exact hSm.cylinder\n  · refine iSup_le fun i ↦ ?_\n    refine (comap_eval_le_generateFrom_squareCylinders_singleton α i).trans ?_\n    refine MeasurableSpace.generateFrom_mono (fun x ↦ ?_)\n    simp only [singleton_pi, Function.eval, mem_image, mem_pi, mem_univ, mem_setOf_eq,\n      forall_true_left, mem_measurableCylinders, exists_prop, forall_exists_index, and_imp]\n    rintro t ht rfl\n    refine ⟨{i}, {f | f ⟨i, Finset.mem_singleton_self i⟩ ∈ t i}, measurable_pi_apply _ (ht i), ?_⟩\n    ext1 x\n    simp only [mem_preimage, Function.eval, mem_cylinder, mem_setOf_eq, Finset.restrict]\n\n"}
{"name":"MeasureTheory.cylinderEvents_univ","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\n⊢ Eq (MeasureTheory.cylinderEvents Set.univ) MeasurableSpace.pi","decl":"@[simp] lemma cylinderEvents_univ : cylinderEvents (π := π) univ = MeasurableSpace.pi := by\n  simp [cylinderEvents, MeasurableSpace.pi]\n\n"}
{"name":"MeasureTheory.cylinderEvents_mono","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ₁ Δ₂ : Set ι\nh : HasSubset.Subset Δ₁ Δ₂\n⊢ LE.le (MeasureTheory.cylinderEvents Δ₁) (MeasureTheory.cylinderEvents Δ₂)","decl":"@[gcongr]\nlemma cylinderEvents_mono (h : Δ₁ ⊆ Δ₂) : cylinderEvents (π := π) Δ₁ ≤ cylinderEvents Δ₂ :=\n  biSup_mono h\n\n"}
{"name":"MeasureTheory.cylinderEvents_le_pi","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\n⊢ LE.le (MeasureTheory.cylinderEvents Δ) MeasurableSpace.pi","decl":"lemma cylinderEvents_le_pi : cylinderEvents (π := π) Δ ≤ MeasurableSpace.pi := by\n  simpa using cylinderEvents_mono (subset_univ _)\n\n"}
{"name":"MeasureTheory.measurable_cylinderEvents_iff","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"α : Type u_1\nι : Type u_2\nπ : ι → Type u_3\nmα : MeasurableSpace α\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\ng : α → (i : ι) → π i\n⊢ Iff (Measurable g) (∀ ⦃i : ι⦄, Membership.mem Δ i → Measurable fun a => g a i)","decl":"lemma measurable_cylinderEvents_iff {g : α → ∀ i, π i} :\n    @Measurable _ _ _ (cylinderEvents Δ) g ↔ ∀ ⦃i⦄, i ∈ Δ → Measurable fun a ↦ g a i := by\n  simp_rw [measurable_iff_comap_le, cylinderEvents, MeasurableSpace.comap_iSup,\n    MeasurableSpace.comap_comp, Function.comp_def, iSup_le_iff]\n\n"}
{"name":"MeasureTheory.measurable_cylinderEvent_apply","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\ni : ι\nhi : Membership.mem Δ i\n⊢ Measurable fun f => f i","decl":"@[fun_prop, aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurable_cylinderEvent_apply (hi : i ∈ Δ) :\n    Measurable[cylinderEvents Δ] fun f : ∀ i, π i => f i :=\n  measurable_cylinderEvents_iff.1 measurable_id hi\n\n"}
{"name":"MeasureTheory.Measurable.eval_cylinderEvents","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"α : Type u_1\nι : Type u_2\nπ : ι → Type u_3\nmα : MeasurableSpace α\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\ni : ι\ng : α → (i : ι) → π i\nhi : Membership.mem Δ i\nhg : Measurable g\n⊢ Measurable fun a => g a i","decl":"@[aesop safe 100 apply (rule_sets := [Measurable])]\nlemma Measurable.eval_cylinderEvents {g : α → ∀ i, π i} (hi : i ∈ Δ)\n    (hg : @Measurable _ _ _ (cylinderEvents Δ) g) : Measurable fun a ↦ g a i :=\n  (measurable_cylinderEvent_apply hi).comp hg\n\n"}
{"name":"MeasureTheory.measurable_cylinderEvents_lambda","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"α : Type u_1\nι : Type u_2\nπ : ι → Type u_3\nmα : MeasurableSpace α\nm : (i : ι) → MeasurableSpace (π i)\nf : α → (i : ι) → π i\nhf : ∀ (i : ι), Measurable fun a => f a i\n⊢ Measurable f","decl":"@[fun_prop, aesop safe 100 apply (rule_sets := [Measurable])]\nlemma measurable_cylinderEvents_lambda (f : α → ∀ i, π i) (hf : ∀ i, Measurable fun a ↦ f a i) :\n    Measurable f :=\n  measurable_pi_iff.mpr hf\n\n"}
{"name":"MeasureTheory.measurable_update_cylinderEvents'","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\ni : ι\ninst✝ : DecidableEq ι\n⊢ Measurable fun p => Function.update p.1 i p.2","decl":"/-- The function `(f, x) ↦ update f a x : (Π a, π a) × π a → Π a, π a` is measurable. -/\nlemma measurable_update_cylinderEvents' [DecidableEq ι] :\n    @Measurable _ _ (.prod (cylinderEvents Δ) (m i)) (cylinderEvents Δ)\n      (fun p : (∀ i, π i) × π i ↦ update p.1 i p.2) := by\n  rw [measurable_cylinderEvents_iff]\n  intro j hj\n  dsimp [update]\n  split_ifs with h\n  · subst h\n    dsimp\n    exact measurable_snd\n  · exact measurable_cylinderEvents_iff.1 measurable_fst hj\n\n"}
{"name":"MeasureTheory.measurable_uniqueElim_cylinderEvents","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\ninst✝ : Unique ι\n⊢ Measurable uniqueElim","decl":"lemma measurable_uniqueElim_cylinderEvents [Unique ι] :\n    Measurable (uniqueElim : π (default : ι) → ∀ i, π i) := by\n  simp_rw [measurable_pi_iff, Unique.forall_iff, uniqueElim_default]; exact measurable_id\n\n"}
{"name":"MeasureTheory.measurable_update_cylinderEvents","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\nf : (a : ι) → π a\na : ι\ninst✝ : DecidableEq ι\n⊢ Measurable (Function.update f a)","decl":"/-- The function `update f a : π a → Π a, π a` is always measurable.\nThis doesn't require `f` to be measurable.\nThis should not be confused with the statement that `update f a x` is measurable. -/\n@[measurability]\nlemma measurable_update_cylinderEvents (f : ∀ a : ι, π a) {a : ι} [DecidableEq ι] :\n    @Measurable _ _ _ (cylinderEvents Δ) (update f a) :=\n  measurable_update_cylinderEvents'.comp measurable_prod_mk_left\n\n"}
{"name":"MeasureTheory.measurable_update_cylinderEvents_left","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\na : ι\ninst✝ : DecidableEq ι\nx : π a\n⊢ Measurable fun x_1 => Function.update x_1 a x","decl":"lemma measurable_update_cylinderEvents_left {a : ι} [DecidableEq ι] {x : π a} :\n    @Measurable _ _ (cylinderEvents Δ) (cylinderEvents Δ) (update · a x) :=\n  measurable_update_cylinderEvents'.comp measurable_prod_mk_right\n\n"}
{"name":"MeasureTheory.measurable_restrict_cylinderEvents","module":"Mathlib.MeasureTheory.Constructions.Cylinders","initialProofState":"ι : Type u_2\nπ : ι → Type u_3\nm : (i : ι) → MeasurableSpace (π i)\nΔ : Set ι\n⊢ Measurable Δ.restrict","decl":"lemma measurable_restrict_cylinderEvents (Δ : Set ι) :\n    Measurable[cylinderEvents (π := π) Δ] (restrict Δ) := by\n  rw [@measurable_pi_iff]; exact fun i ↦ measurable_cylinderEvent_apply i.2\n\n"}
