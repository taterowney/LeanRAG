{"name":"is_transcendental_of_subsingleton","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton R\nx : A\n⊢ Transcendental R x","decl":"@[nontriviality]\ntheorem is_transcendental_of_subsingleton [Subsingleton R] (x : A) : Transcendental R x :=\n  fun ⟨p, h, _⟩ => h <| Subsingleton.elim p 0\n\n"}
{"name":"IsAlgebraic.nontrivial","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\na : A\nh : IsAlgebraic R a\n⊢ Nontrivial R","decl":"theorem IsAlgebraic.nontrivial {a : A} (h : IsAlgebraic R a) : Nontrivial R := by\n  contrapose! h\n  rw [not_nontrivial_iff_subsingleton] at h\n  apply is_transcendental_of_subsingleton\n\n"}
{"name":"Algebra.IsAlgebraic.nontrivial","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nalg : Algebra.IsAlgebraic R A\n⊢ Nontrivial R","decl":"theorem Algebra.IsAlgebraic.nontrivial [alg : Algebra.IsAlgebraic R A] : Nontrivial R :=\n  (alg.1 0).nontrivial\n\n"}
{"name":"Algebra.transcendental_of_subsingleton","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Subsingleton R\n⊢ Algebra.Transcendental R A","decl":"instance (priority := low) Algebra.transcendental_of_subsingleton [Subsingleton R] :\n    Algebra.Transcendental R A :=\n  ⟨⟨0, is_transcendental_of_subsingleton R 0⟩⟩\n\n"}
{"name":"Polynomial.transcendental_X","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Transcendental R Polynomial.X","decl":"theorem Polynomial.transcendental_X : Transcendental R (X (R := R)) := by\n  simp [transcendental_iff]\n\n"}
{"name":"IsAlgebraic.of_aeval","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nf : Polynomial R\nhf : Ne f.natDegree 0\nhf' : Membership.mem (nonZeroDivisors R) f.leadingCoeff\nH : IsAlgebraic R ((Polynomial.aeval r) f)\n⊢ IsAlgebraic R r","decl":"theorem IsAlgebraic.of_aeval {r : A} (f : R[X]) (hf : f.natDegree ≠ 0)\n    (hf' : f.leadingCoeff ∈ nonZeroDivisors R) (H : IsAlgebraic R (aeval r f)) :\n    IsAlgebraic R r := by\n  obtain ⟨p, h1, h2⟩ := H\n  have : (p.comp f).coeff (p.natDegree * f.natDegree) ≠ 0 := fun h ↦ h1 <| by\n    rwa [coeff_comp_degree_mul_degree hf,\n      mul_right_mem_nonZeroDivisors_eq_zero_iff (pow_mem hf' _),\n      leadingCoeff_eq_zero] at h\n  exact ⟨p.comp f, fun h ↦ this (by simp [h]), by rwa [aeval_comp]⟩\n\n"}
{"name":"Transcendental.aeval","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nH : Transcendental R r\nf : Polynomial R\nhf : Ne f.natDegree 0\nhf' : Membership.mem (nonZeroDivisors R) f.leadingCoeff\n⊢ Transcendental R ((Polynomial.aeval r) f)","decl":"theorem Transcendental.aeval {r : A} (H : Transcendental R r) (f : R[X]) (hf : f.natDegree ≠ 0)\n    (hf' : f.leadingCoeff ∈ nonZeroDivisors R) :\n    Transcendental R (aeval r f) := fun h ↦ H (h.of_aeval f hf hf')\n\n"}
{"name":"Transcendental.aeval_of_transcendental","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nH : Transcendental R r\nf : Polynomial R\nhf : Transcendental R f\n⊢ Transcendental R ((Polynomial.aeval r) f)","decl":"/-- If `r : A` and `f : R[X]` are transcendental over `R`, then `Polynomial.aeval r f` is also\ntranscendental over `R`. For the converse, see `Transcendental.of_aeval` and\n`transcendental_aeval_iff`. -/\ntheorem Transcendental.aeval_of_transcendental {r : A} (H : Transcendental R r)\n    {f : R[X]} (hf : Transcendental R f) : Transcendental R (Polynomial.aeval r f) := by\n  rw [transcendental_iff] at H hf ⊢\n  intro p hp\n  exact hf _ (H _ (by rwa [← aeval_comp, comp_eq_aeval] at hp))\n\n"}
{"name":"Transcendental.of_aeval","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nf : Polynomial R\nH : Transcendental R ((Polynomial.aeval r) f)\n⊢ Transcendental R f","decl":"/-- If `Polynomial.aeval r f` is transcendental over `R`, then `f : R[X]` is also\ntranscendental over `R`. In fact, the `r` is also transcendental over `R` provided that `R`\nis a field (see `transcendental_aeval_iff`). -/\ntheorem Transcendental.of_aeval {r : A} {f : R[X]}\n    (H : Transcendental R (Polynomial.aeval r f)) : Transcendental R f := by\n  rw [transcendental_iff] at H ⊢\n  intro p hp\n  exact H p (by rw [← aeval_comp, comp_eq_aeval, hp, map_zero])\n\n"}
{"name":"IsAlgebraic.of_aeval_of_transcendental","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nf : Polynomial R\nH : IsAlgebraic R ((Polynomial.aeval r) f)\nhf : Transcendental R f\n⊢ IsAlgebraic R r","decl":"theorem IsAlgebraic.of_aeval_of_transcendental {r : A} {f : R[X]}\n    (H : IsAlgebraic R (aeval r f)) (hf : Transcendental R f) : IsAlgebraic R r := by\n  contrapose H\n  exact Transcendental.aeval_of_transcendental H hf\n\n"}
{"name":"Polynomial.transcendental","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nf : Polynomial R\nhf : Ne f.natDegree 0\nhf' : Membership.mem (nonZeroDivisors R) f.leadingCoeff\n⊢ Transcendental R f","decl":"theorem Polynomial.transcendental (f : R[X]) (hf : f.natDegree ≠ 0)\n    (hf' : f.leadingCoeff ∈ nonZeroDivisors R) :\n    Transcendental R f := by\n  simpa using (transcendental_X R).aeval f hf hf'\n\n"}
{"name":"isAlgebraic_iff_not_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (IsAlgebraic R x) (Not (Function.Injective ⇑(Polynomial.aeval x)))","decl":"theorem isAlgebraic_iff_not_injective {x : A} :\n    IsAlgebraic R x ↔ ¬Function.Injective (Polynomial.aeval x : R[X] →ₐ[R] A) := by\n  simp only [IsAlgebraic, injective_iff_map_eq_zero, not_forall, and_comm, exists_prop]\n\n"}
{"name":"transcendental_iff_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (Transcendental R x) (Function.Injective ⇑(Polynomial.aeval x))","decl":"/-- An element `x` is transcendental over `R` if and only if the map `Polynomial.aeval x`\nis injective. This is similar to `algebraicIndependent_iff_injective_aeval`. -/\ntheorem transcendental_iff_injective {x : A} :\n    Transcendental R x ↔ Function.Injective (Polynomial.aeval x : R[X] →ₐ[R] A) :=\n  isAlgebraic_iff_not_injective.not_left\n\n"}
{"name":"transcendental_iff_ker_eq_bot","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (Transcendental R x) (Eq (RingHom.ker (Polynomial.aeval x)) Bot.bot)","decl":"/-- An element `x` is transcendental over `R` if and only if the kernel of the ring homomorphism\n`Polynomial.aeval x` is the zero ideal. This is similar to `algebraicIndependent_iff_ker_eq_bot`. -/\ntheorem transcendental_iff_ker_eq_bot {x : A} :\n    Transcendental R x ↔ RingHom.ker (aeval (R := R) x) = ⊥ := by\n  rw [transcendental_iff_injective, RingHom.injective_iff_ker_eq_bot]\n\n"}
{"name":"Algebra.isAlgebraic_of_not_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nh : Not (Function.Injective ⇑(algebraMap R A))\n⊢ Algebra.IsAlgebraic R A","decl":"theorem Algebra.isAlgebraic_of_not_injective (h : ¬ Function.Injective (algebraMap R A)) :\n    Algebra.IsAlgebraic R A where\n  isAlgebraic a := isAlgebraic_iff_not_injective.mpr\n    fun inj ↦ h <| by convert inj.comp C_injective; ext; simp\n\n"}
{"name":"Algebra.injective_of_transcendental","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nh : Algebra.Transcendental R A\n⊢ Function.Injective ⇑(algebraMap R A)","decl":"theorem Algebra.injective_of_transcendental [h : Algebra.Transcendental R A] :\n    Function.Injective (algebraMap R A) := by\n  rw [transcendental_iff_not_isAlgebraic] at h\n  contrapose! h\n  exact isAlgebraic_of_not_injective h\n\n"}
{"name":"isAlgebraic_zero","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\n⊢ IsAlgebraic R 0","decl":"theorem isAlgebraic_zero [Nontrivial R] : IsAlgebraic R (0 : A) :=\n  ⟨_, X_ne_zero, aeval_X 0⟩\n\n"}
{"name":"isAlgebraic_algebraMap","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nx : R\n⊢ IsAlgebraic R ((algebraMap R A) x)","decl":"/-- An element of `R` is algebraic, when viewed as an element of the `R`-algebra `A`. -/\ntheorem isAlgebraic_algebraMap [Nontrivial R] (x : R) : IsAlgebraic R (algebraMap R A x) :=\n  ⟨_, X_sub_C_ne_zero x, by rw [map_sub, aeval_X, aeval_C, sub_self]⟩\n\n"}
{"name":"isAlgebraic_one","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\n⊢ IsAlgebraic R 1","decl":"theorem isAlgebraic_one [Nontrivial R] : IsAlgebraic R (1 : A) := by\n  rw [← map_one (algebraMap R A)]\n  exact isAlgebraic_algebraMap 1\n\n"}
{"name":"isAlgebraic_nat","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nn : Nat\n⊢ IsAlgebraic R ↑n","decl":"theorem isAlgebraic_nat [Nontrivial R] (n : ℕ) : IsAlgebraic R (n : A) := by\n  rw [← map_natCast (_ : R →+* A) n]\n  exact isAlgebraic_algebraMap (Nat.cast n)\n\n"}
{"name":"isAlgebraic_int","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nn : Int\n⊢ IsAlgebraic R ↑n","decl":"theorem isAlgebraic_int [Nontrivial R] (n : ℤ) : IsAlgebraic R (n : A) := by\n  rw [← map_intCast (algebraMap R A)]\n  exact isAlgebraic_algebraMap (Int.cast n)\n\n"}
{"name":"isAlgebraic_rat","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : DivisionRing A\ninst✝¹ : Field R\ninst✝ : Algebra R A\nn : Rat\n⊢ IsAlgebraic R ↑n","decl":"theorem isAlgebraic_rat (R : Type u) {A : Type v} [DivisionRing A] [Field R] [Algebra R A] (n : ℚ) :\n    IsAlgebraic R (n : A) := by\n  rw [← map_ratCast (algebraMap R A)]\n  exact isAlgebraic_algebraMap (Rat.cast n)\n\n"}
{"name":"isAlgebraic_of_mem_rootSet","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : Field R\ninst✝¹ : Field A\ninst✝ : Algebra R A\np : Polynomial R\nx : A\nhx : Membership.mem (p.rootSet A) x\n⊢ IsAlgebraic R x","decl":"theorem isAlgebraic_of_mem_rootSet {R : Type u} {A : Type v} [Field R] [Field A] [Algebra R A]\n    {p : R[X]} {x : A} (hx : x ∈ p.rootSet A) : IsAlgebraic R x :=\n  ⟨p, ne_zero_of_mem_rootSet hx, aeval_eq_zero_of_mem_rootSet hx⟩\n\n"}
{"name":"IsLocalization.isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : Nontrivial R\nM : Submonoid R\ninst✝ : IsLocalization M S\n⊢ Algebra.IsAlgebraic R S","decl":"variable (S) in\ntheorem IsLocalization.isAlgebraic [Nontrivial R] (M : Submonoid R) [IsLocalization M S] :\n    Algebra.IsAlgebraic R S where\n  isAlgebraic x := by\n    obtain rfl | hx := eq_or_ne x 0\n    · exact isAlgebraic_zero\n    have ⟨⟨r, m⟩, h⟩ := surj M x\n    refine ⟨C m.1 * X - C r, fun eq ↦ hx ?_, by simpa [sub_eq_zero, mul_comm x] using h⟩\n    rwa [← eq_mk'_iff_mul_eq, show r = 0 by simpa using congr(coeff $eq 0), mk'_zero] at h\n\n"}
{"name":"IsAlgebraic.algebraMap","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : Algebra R S\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : S\na✝ : IsAlgebraic R a\n⊢ IsAlgebraic R ((algebraMap S A) a)","decl":"protected theorem IsAlgebraic.algebraMap {a : S} :\n    IsAlgebraic R a → IsAlgebraic R (algebraMap S A a) := fun ⟨f, hf₁, hf₂⟩ =>\n  ⟨f, hf₁, by rw [aeval_algebraMap_apply, hf₂, map_zero]⟩\n\n"}
{"name":"IsAlgebraic.algHom","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\nB : Type u_2\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\na : A\nh : IsAlgebraic R a\n⊢ IsAlgebraic R (f a)","decl":"/-- This is slightly more general than `IsAlgebraic.algebraMap` in that it\n  allows noncommutative intermediate rings `A`. -/\nprotected theorem IsAlgebraic.algHom (f : A →ₐ[R] B) {a : A}\n    (h : IsAlgebraic R a) : IsAlgebraic R (f a) :=\n  let ⟨p, hp, ha⟩ := h\n  ⟨p, hp, by rw [aeval_algHom, f.comp_apply, ha, map_zero]⟩\n\n"}
{"name":"isAlgebraic_algHom_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\nB : Type u_2\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Injective ⇑f\na : A\n⊢ Iff (IsAlgebraic R (f a)) (IsAlgebraic R a)","decl":"theorem isAlgebraic_algHom_iff (f : A →ₐ[R] B) (hf : Function.Injective f)\n    {a : A} : IsAlgebraic R (f a) ↔ IsAlgebraic R a :=\n  ⟨fun ⟨p, hp0, hp⟩ ↦ ⟨p, hp0, hf <| by rwa [map_zero, ← f.comp_apply, ← aeval_algHom]⟩,\n    IsAlgebraic.algHom f⟩\n\n"}
{"name":"IsAlgebraic.ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\na : A\nhalg : IsAlgebraic R a\nhf : Function.Injective ⇑f\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ IsAlgebraic S (g a)","decl":"theorem IsAlgebraic.ringHom_of_comp_eq (halg : IsAlgebraic R a)\n    (hf : Function.Injective f)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    IsAlgebraic S (g a) := by\n  obtain ⟨p, h1, h2⟩ := halg\n  refine ⟨p.map f, (Polynomial.map_ne_zero_iff hf).2 h1, ?_⟩\n  change aeval ((g : A →+* B) a) _ = 0\n  rw [← map_aeval_eq_aeval_map h, h2, map_zero]\n\n"}
{"name":"Transcendental.of_ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\na : A\nH : Transcendental S (g a)\nhf : Function.Injective ⇑f\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Transcendental R a","decl":"theorem Transcendental.of_ringHom_of_comp_eq (H : Transcendental S (g a))\n    (hf : Function.Injective f)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Transcendental R a := fun halg ↦ H (halg.ringHom_of_comp_eq f g hf h)\n\n"}
{"name":"Algebra.IsAlgebraic.ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Ring A\ninst✝⁷ : Algebra R A\nB : Type u_2\ninst✝⁶ : Ring B\ninst✝⁵ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝⁴ : FunLike FRS R S\ninst✝³ : RingHomClass FRS R S\ninst✝² : FunLike FAB A B\ninst✝¹ : RingHomClass FAB A B\nf : FRS\ng : FAB\ninst✝ : Algebra.IsAlgebraic R A\nhf : Function.Injective ⇑f\nhg : Function.Surjective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Algebra.IsAlgebraic S B","decl":"theorem Algebra.IsAlgebraic.ringHom_of_comp_eq [Algebra.IsAlgebraic R A]\n    (hf : Function.Injective f) (hg : Function.Surjective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.IsAlgebraic S B := by\n  refine ⟨fun b ↦ ?_⟩\n  obtain ⟨a, rfl⟩ := hg b\n  exact (Algebra.IsAlgebraic.isAlgebraic a).ringHom_of_comp_eq f g hf h\n\n"}
{"name":"Algebra.Transcendental.of_ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nH : Algebra.Transcendental S B\nhf : Function.Injective ⇑f\nhg : Function.Surjective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Algebra.Transcendental R A","decl":"theorem Algebra.Transcendental.of_ringHom_of_comp_eq [H : Algebra.Transcendental S B]\n    (hf : Function.Injective f) (hg : Function.Surjective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.Transcendental R A := by\n  rw [Algebra.transcendental_iff_not_isAlgebraic] at H ⊢\n  exact fun halg ↦ H (halg.ringHom_of_comp_eq f g hf hg h)\n\n"}
{"name":"IsAlgebraic.of_ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\na : A\nhalg : IsAlgebraic S (g a)\nhf : Function.Surjective ⇑f\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ IsAlgebraic R a","decl":"theorem IsAlgebraic.of_ringHom_of_comp_eq (halg : IsAlgebraic S (g a))\n    (hf : Function.Surjective f) (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    IsAlgebraic R a := by\n  obtain ⟨p, h1, h2⟩ := halg\n  obtain ⟨q, rfl⟩ := map_surjective (f : R →+* S) hf p\n  refine ⟨q, fun h' ↦ by simp [h'] at h1, hg ?_⟩\n  change aeval ((g : A →+* B) a) _ = 0 at h2\n  change (g : A →+* B) _ = _\n  rw [map_zero, map_aeval_eq_aeval_map h, h2]\n\n"}
{"name":"Transcendental.ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\na : A\nH : Transcendental R a\nhf : Function.Surjective ⇑f\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Transcendental S (g a)","decl":"theorem Transcendental.ringHom_of_comp_eq (H : Transcendental R a)\n    (hf : Function.Surjective f) (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Transcendental S (g a) := fun halg ↦ H (halg.of_ringHom_of_comp_eq f g hf hg h)\n\n"}
{"name":"Algebra.IsAlgebraic.of_ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Ring A\ninst✝⁷ : Algebra R A\nB : Type u_2\ninst✝⁶ : Ring B\ninst✝⁵ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝⁴ : FunLike FRS R S\ninst✝³ : RingHomClass FRS R S\ninst✝² : FunLike FAB A B\ninst✝¹ : RingHomClass FAB A B\nf : FRS\ng : FAB\ninst✝ : Algebra.IsAlgebraic S B\nhf : Function.Surjective ⇑f\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Algebra.IsAlgebraic R A","decl":"theorem Algebra.IsAlgebraic.of_ringHom_of_comp_eq [Algebra.IsAlgebraic S B]\n    (hf : Function.Surjective f) (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.IsAlgebraic R A :=\n  ⟨fun a ↦ (Algebra.IsAlgebraic.isAlgebraic (g a)).of_ringHom_of_comp_eq f g hf hg h⟩\n\n"}
{"name":"Algebra.Transcendental.ringHom_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : FunLike FRS R S\ninst✝² : RingHomClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nH : Algebra.Transcendental R A\nhf : Function.Surjective ⇑f\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Algebra.Transcendental S B","decl":"theorem Algebra.Transcendental.ringHom_of_comp_eq [H : Algebra.Transcendental R A]\n    (hf : Function.Surjective f) (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.Transcendental S B := by\n  rw [Algebra.transcendental_iff_not_isAlgebraic] at H ⊢\n  exact fun halg ↦ H (halg.of_ringHom_of_comp_eq f g hf hg h)\n\n"}
{"name":"isAlgebraic_ringHom_iff_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : EquivLike FRS R S\ninst✝² : RingEquivClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\na : A\n⊢ Iff (IsAlgebraic S (g a)) (IsAlgebraic R a)","decl":"theorem isAlgebraic_ringHom_iff_of_comp_eq\n    (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) {a : A} :\n    IsAlgebraic S (g a) ↔ IsAlgebraic R a :=\n  ⟨fun H ↦ H.of_ringHom_of_comp_eq f g (EquivLike.surjective f) hg h,\n    fun H ↦ H.ringHom_of_comp_eq f g (EquivLike.injective f) h⟩\n\n"}
{"name":"transcendental_ringHom_iff_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : EquivLike FRS R S\ninst✝² : RingEquivClass FRS R S\ninst✝¹ : FunLike FAB A B\ninst✝ : RingHomClass FAB A B\nf : FRS\ng : FAB\nhg : Function.Injective ⇑g\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\na : A\n⊢ Iff (Transcendental S (g a)) (Transcendental R a)","decl":"theorem transcendental_ringHom_iff_of_comp_eq\n    (hg : Function.Injective g)\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) {a : A} :\n    Transcendental S (g a) ↔ Transcendental R a :=\n  not_congr (isAlgebraic_ringHom_iff_of_comp_eq f g hg h)\n\n"}
{"name":"Algebra.isAlgebraic_ringHom_iff_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : EquivLike FRS R S\ninst✝² : RingEquivClass FRS R S\ninst✝¹ : EquivLike FAB A B\ninst✝ : RingEquivClass FAB A B\nf : FRS\ng : FAB\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Iff (Algebra.IsAlgebraic S B) (Algebra.IsAlgebraic R A)","decl":"theorem Algebra.isAlgebraic_ringHom_iff_of_comp_eq\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.IsAlgebraic S B ↔ Algebra.IsAlgebraic R A :=\n  ⟨fun H ↦ H.of_ringHom_of_comp_eq f g (EquivLike.surjective f) (EquivLike.injective g) h,\n    fun H ↦ H.ringHom_of_comp_eq f g (EquivLike.injective f) (EquivLike.surjective g) h⟩\n\n"}
{"name":"Algebra.transcendental_ringHom_iff_of_comp_eq","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁹ : CommRing R\ninst✝⁸ : CommRing S\ninst✝⁷ : Ring A\ninst✝⁶ : Algebra R A\nB : Type u_2\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra S B\nFRS : Type u_3\nFAB : Type u_4\ninst✝³ : EquivLike FRS R S\ninst✝² : RingEquivClass FRS R S\ninst✝¹ : EquivLike FAB A B\ninst✝ : RingEquivClass FAB A B\nf : FRS\ng : FAB\nh : Eq ((algebraMap S B).comp ↑f) ((↑g).comp (algebraMap R A))\n⊢ Iff (Algebra.Transcendental S B) (Algebra.Transcendental R A)","decl":"theorem Algebra.transcendental_ringHom_iff_of_comp_eq\n    (h : RingHom.comp (algebraMap S B) f = RingHom.comp g (algebraMap R A)) :\n    Algebra.Transcendental S B ↔ Algebra.Transcendental R A := by\n  simp_rw [Algebra.transcendental_iff_not_isAlgebraic,\n    Algebra.isAlgebraic_ringHom_iff_of_comp_eq f g h]\n\n"}
{"name":"Algebra.IsAlgebraic.of_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\nB : Type u_2\ninst✝² : Ring B\ninst✝¹ : Algebra R B\nf : AlgHom R A B\nhf : Function.Injective ⇑f\ninst✝ : Algebra.IsAlgebraic R B\n⊢ Algebra.IsAlgebraic R A","decl":"theorem Algebra.IsAlgebraic.of_injective (f : A →ₐ[R] B) (hf : Function.Injective f)\n    [Algebra.IsAlgebraic R B] : Algebra.IsAlgebraic R A :=\n  ⟨fun _ ↦ (isAlgebraic_algHom_iff f hf).mp (Algebra.IsAlgebraic.isAlgebraic _)⟩\n\n"}
{"name":"AlgEquiv.isAlgebraic","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\nB : Type u_2\ninst✝² : Ring B\ninst✝¹ : Algebra R B\ne : AlgEquiv R A B\ninst✝ : Algebra.IsAlgebraic R A\n⊢ Algebra.IsAlgebraic R B","decl":"/-- Transfer `Algebra.IsAlgebraic` across an `AlgEquiv`. -/\ntheorem AlgEquiv.isAlgebraic (e : A ≃ₐ[R] B)\n    [Algebra.IsAlgebraic R A] : Algebra.IsAlgebraic R B :=\n  Algebra.IsAlgebraic.of_injective e.symm.toAlgHom e.symm.injective\n\n"}
{"name":"AlgEquiv.isAlgebraic_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\nB : Type u_2\ninst✝¹ : Ring B\ninst✝ : Algebra R B\ne : AlgEquiv R A B\n⊢ Iff (Algebra.IsAlgebraic R A) (Algebra.IsAlgebraic R B)","decl":"theorem AlgEquiv.isAlgebraic_iff (e : A ≃ₐ[R] B) :\n    Algebra.IsAlgebraic R A ↔ Algebra.IsAlgebraic R B :=\n  ⟨fun _ ↦ e.isAlgebraic, fun _ ↦ e.symm.isAlgebraic⟩\n\n"}
{"name":"isAlgebraic_algebraMap_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : Algebra R S\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : S\nh : Function.Injective ⇑(algebraMap S A)\n⊢ Iff (IsAlgebraic R ((algebraMap S A) a)) (IsAlgebraic R a)","decl":"theorem isAlgebraic_algebraMap_iff {a : S} (h : Function.Injective (algebraMap S A)) :\n    IsAlgebraic R (algebraMap S A a) ↔ IsAlgebraic R a :=\n  isAlgebraic_algHom_iff (IsScalarTower.toAlgHom R S A) h\n\n"}
{"name":"transcendental_algebraMap_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\nA : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R A\ninst✝² : Algebra R S\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : S\nh : Function.Injective ⇑(algebraMap S A)\n⊢ Iff (Transcendental R ((algebraMap S A) a)) (Transcendental R a)","decl":"theorem transcendental_algebraMap_iff {a : S} (h : Function.Injective (algebraMap S A)) :\n    Transcendental R (algebraMap S A a) ↔ Transcendental R a := by\n  simp_rw [Transcendental, isAlgebraic_algebraMap_iff h]\n\n"}
{"name":"Subalgebra.isAlgebraic_iff_isAlgebraic_val","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nS : Subalgebra R A\nx : Subtype fun x => Membership.mem S x\n⊢ Iff (IsAlgebraic R x) (IsAlgebraic R ↑x)","decl":"theorem isAlgebraic_iff_isAlgebraic_val {S : Subalgebra R A} {x : S} :\n    _root_.IsAlgebraic R x ↔ _root_.IsAlgebraic R x.1 :=\n  (isAlgebraic_algHom_iff S.val Subtype.val_injective).symm\n\n"}
{"name":"Subalgebra.isAlgebraic_of_isAlgebraic_bot","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nx : S\nhalg : IsAlgebraic (Subtype fun x => Membership.mem Bot.bot x) x\n⊢ IsAlgebraic R x","decl":"theorem isAlgebraic_of_isAlgebraic_bot {x : S} (halg : _root_.IsAlgebraic (⊥ : Subalgebra R S) x) :\n    _root_.IsAlgebraic R x :=\n  halg.of_ringHom_of_comp_eq (algebraMap R (⊥ : Subalgebra R S))\n    (RingHom.id S) (by rintro ⟨_, r, rfl⟩; exact ⟨r, rfl⟩) Function.injective_id rfl\n\n"}
{"name":"Subalgebra.isAlgebraic_bot_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Injective ⇑(algebraMap R S)\nx : S\n⊢ Iff (IsAlgebraic (Subtype fun x => Membership.mem Bot.bot x) x) (IsAlgebraic R x)","decl":"theorem isAlgebraic_bot_iff (h : Function.Injective (algebraMap R S)) {x : S} :\n    _root_.IsAlgebraic (⊥ : Subalgebra R S) x ↔ _root_.IsAlgebraic R x :=\n  isAlgebraic_ringHom_iff_of_comp_eq (Algebra.botEquivOfInjective h).symm (RingHom.id S)\n    Function.injective_id (by rfl)\n\n"}
{"name":"Subalgebra.algebra_isAlgebraic_of_algebra_isAlgebraic_bot_left","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsAlgebraic (Subtype fun x => Membership.mem Bot.bot x) S\n⊢ Algebra.IsAlgebraic R S","decl":"variable (R S) in\ntheorem algebra_isAlgebraic_of_algebra_isAlgebraic_bot_left\n    [Algebra.IsAlgebraic (⊥ : Subalgebra R S) S] : Algebra.IsAlgebraic R S :=\n  Algebra.IsAlgebraic.of_ringHom_of_comp_eq (algebraMap R (⊥ : Subalgebra R S))\n    (RingHom.id S) (by rintro ⟨_, r, rfl⟩; exact ⟨r, rfl⟩) Function.injective_id (by ext; rfl)\n\n"}
{"name":"Subalgebra.algebra_isAlgebraic_bot_left_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Injective ⇑(algebraMap R S)\n⊢ Iff (Algebra.IsAlgebraic (Subtype fun x => Membership.mem Bot.bot x) S) (Algebra.IsAlgebraic R S)","decl":"theorem algebra_isAlgebraic_bot_left_iff (h : Function.Injective (algebraMap R S)) :\n    Algebra.IsAlgebraic (⊥ : Subalgebra R S) S ↔ Algebra.IsAlgebraic R S := by\n  simp_rw [Algebra.isAlgebraic_def, isAlgebraic_bot_iff h]\n\n"}
{"name":"Subalgebra.algebra_isAlgebraic_bot_right","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial R\n⊢ Algebra.IsAlgebraic R (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance algebra_isAlgebraic_bot_right [Nontrivial R] :\n    Algebra.IsAlgebraic R (⊥ : Subalgebra R S) :=\n  ⟨by rintro ⟨_, x, rfl⟩; exact isAlgebraic_algebraMap _⟩\n\n"}
{"name":"IsAlgebraic.of_pow","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nn : Nat\nhn : LT.lt 0 n\nht : IsAlgebraic R (HPow.hPow r n)\n⊢ IsAlgebraic R r","decl":"theorem IsAlgebraic.of_pow {r : A} {n : ℕ} (hn : 0 < n) (ht : IsAlgebraic R (r ^ n)) :\n    IsAlgebraic R r :=\n  have ⟨p, p_nonzero, hp⟩ := ht\n  ⟨_, by rwa [expand_ne_zero hn], by rwa [expand_aeval n p r]⟩\n\n"}
{"name":"Transcendental.pow","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nA : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nr : A\nht : Transcendental R r\nn : Nat\nhn : LT.lt 0 n\n⊢ Transcendental R (HPow.hPow r n)","decl":"theorem Transcendental.pow {r : A} (ht : Transcendental R r) {n : ℕ} (hn : 0 < n) :\n    Transcendental R (r ^ n) := fun ht' ↦ ht <| ht'.of_pow hn\n\n"}
{"name":"IsAlgebraic.invOf","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\ninst✝ : Invertible x\nh : IsAlgebraic R x\n⊢ IsAlgebraic R (Invertible.invOf x)","decl":"lemma IsAlgebraic.invOf {x : S} [Invertible x] (h : IsAlgebraic R x) : IsAlgebraic R (⅟ x) := by\n  obtain ⟨p, hp, hp'⟩ := h\n  refine ⟨p.reverse, by simpa using hp, ?_⟩\n  rwa [Polynomial.aeval_def, Polynomial.eval₂_reverse_eq_zero_iff, ← Polynomial.aeval_def]\n\n"}
{"name":"IsAlgebraic.invOf_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\nS : Type u_1\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nx : S\ninst✝ : Invertible x\n⊢ Iff (IsAlgebraic R (Invertible.invOf x)) (IsAlgebraic R x)","decl":"lemma IsAlgebraic.invOf_iff {x : S} [Invertible x] :\n    IsAlgebraic R (⅟ x) ↔ IsAlgebraic R x :=\n  ⟨IsAlgebraic.invOf, IsAlgebraic.invOf⟩\n\n"}
{"name":"IsAlgebraic.inv_iff","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra R K\nx : K\n⊢ Iff (IsAlgebraic R (Inv.inv x)) (IsAlgebraic R x)","decl":"lemma IsAlgebraic.inv_iff {K} [Field K] [Algebra R K] {x : K} :\n    IsAlgebraic R (x⁻¹) ↔ IsAlgebraic R x := by\n  by_cases hx : x = 0\n  · simp [hx]\n  letI := invertibleOfNonzero hx\n  exact IsAlgebraic.invOf_iff (R := R) (x := x)\n\n"}
{"name":"IsAlgebraic.inv","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nK : Type u_2\ninst✝¹ : Field K\ninst✝ : Algebra R K\nx : K\na✝ : IsAlgebraic R x\n⊢ IsAlgebraic R (Inv.inv x)","decl":"alias ⟨_, IsAlgebraic.inv⟩ := IsAlgebraic.inv_iff\n\n"}
{"name":"IsAlgebraic.extendScalars","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\nx : A\nA_alg : IsAlgebraic R x\n⊢ IsAlgebraic S x","decl":"/-- If `x` is algebraic over `R`, then `x` is algebraic over `S` when `S` is an extension of `R`,\n  and the map from `R` to `S` is injective. -/\ntheorem IsAlgebraic.extendScalars (hinj : Function.Injective (algebraMap R S)) {x : A}\n    (A_alg : IsAlgebraic R x) : IsAlgebraic S x :=\n  let ⟨p, hp₁, hp₂⟩ := A_alg\n  ⟨p.map (algebraMap _ _), by\n    rwa [Ne, ← degree_eq_bot, degree_map_eq_of_injective hinj, degree_eq_bot], by simpa⟩\n\n"}
{"name":"IsAlgebraic.tower_top_of_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\nx : A\nA_alg : IsAlgebraic R x\n⊢ IsAlgebraic S x","decl":"@[deprecated (since := \"2024-11-18\")]\nalias IsAlgebraic.tower_top_of_injective := IsAlgebraic.extendScalars\n\n"}
{"name":"IsAlgebraic.tower_top_of_subalgebra_le","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nhle : LE.le A B\nx : S\nh : IsAlgebraic (Subtype fun x => Membership.mem A x) x\n⊢ IsAlgebraic (Subtype fun x => Membership.mem B x) x","decl":"/-- A special case of `IsAlgebraic.extendScalars`. This is extracted as a theorem\n  because in some cases `IsAlgebraic.extendScalars` will just runs out of memory. -/\ntheorem IsAlgebraic.tower_top_of_subalgebra_le\n    {A B : Subalgebra R S} (hle : A ≤ B) {x : S}\n    (h : IsAlgebraic A x) : IsAlgebraic B x := by\n  letI : Algebra A B := (Subalgebra.inclusion hle).toAlgebra\n  haveI : IsScalarTower A B S := .of_algebraMap_eq fun _ ↦ rfl\n  exact h.extendScalars (Subalgebra.inclusion_injective hle)\n\n"}
{"name":"Transcendental.restrictScalars","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\nx : A\nh : Transcendental S x\n⊢ Transcendental R x","decl":"/-- If `x` is transcendental over `S`, then `x` is transcendental over `R` when `S` is an extension\n  of `R`, and the map from `R` to `S` is injective. -/\ntheorem Transcendental.restrictScalars (hinj : Function.Injective (algebraMap R S)) {x : A}\n    (h : Transcendental S x) : Transcendental R x := fun H ↦ h (H.extendScalars hinj)\n\n"}
{"name":"Transcendental.of_tower_top_of_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Ring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\nx : A\nh : Transcendental S x\n⊢ Transcendental R x","decl":"@[deprecated (since := \"2024-11-18\")]\nalias Transcendental.of_tower_top_of_injective := Transcendental.restrictScalars\n\n"}
{"name":"Transcendental.of_tower_top_of_subalgebra_le","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nhle : LE.le A B\nx : S\nh : Transcendental (Subtype fun x => Membership.mem B x) x\n⊢ Transcendental (Subtype fun x => Membership.mem A x) x","decl":"/-- A special case of `Transcendental.restrictScalars`. This is extracted as a theorem\n  because in some cases `Transcendental.restrictScalars` will just runs out of memory. -/\ntheorem Transcendental.of_tower_top_of_subalgebra_le\n    {A B : Subalgebra R S} (hle : A ≤ B) {x : S}\n    (h : Transcendental B x) : Transcendental A x :=\n  fun H ↦ h (H.tower_top_of_subalgebra_le hle)\n\n"}
{"name":"Algebra.IsAlgebraic.extendScalars","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra S A\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\ninst✝ : Algebra.IsAlgebraic R A\n⊢ Algebra.IsAlgebraic S A","decl":"/-- If A is an algebraic algebra over R, then A is algebraic over S when S is an extension of R,\n  and the map from `R` to `S` is injective. -/\ntheorem Algebra.IsAlgebraic.extendScalars (hinj : Function.Injective (algebraMap R S))\n    [Algebra.IsAlgebraic R A] : Algebra.IsAlgebraic S A :=\n  ⟨fun _ ↦ _root_.IsAlgebraic.extendScalars hinj (Algebra.IsAlgebraic.isAlgebraic _)⟩\n\n"}
{"name":"Algebra.IsAlgebraic.tower_top_of_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra S A\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R S A\nhinj : Function.Injective ⇑(algebraMap R S)\ninst✝ : Algebra.IsAlgebraic R A\n⊢ Algebra.IsAlgebraic S A","decl":"@[deprecated (since := \"2024-11-18\")]\nalias Algebra.IsAlgebraic.tower_top_of_injective := Algebra.IsAlgebraic.extendScalars\n\n"}
{"name":"Algebra.IsAlgebraic.tower_bot_of_injective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_3\nS : Type u_4\nA : Type u_5\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra S A\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R S A\ninst✝ : Algebra.IsAlgebraic R A\nhinj : Function.Injective ⇑(algebraMap S A)\n⊢ Algebra.IsAlgebraic R S","decl":"theorem Algebra.IsAlgebraic.tower_bot_of_injective [Algebra.IsAlgebraic R A]\n    (hinj : Function.Injective (algebraMap S A)) :\n    Algebra.IsAlgebraic R S where\n  isAlgebraic x := by\n    simpa [isAlgebraic_algebraMap_iff hinj] using isAlgebraic (R := R) (A := A) (algebraMap _ _ x)\n\n"}
{"name":"IsAlgebraic.tower_top","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nA : Type u_5\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Ring A\ninst✝³ : Algebra K L\ninst✝² : Algebra L A\ninst✝¹ : Algebra K A\ninst✝ : IsScalarTower K L A\nx : A\nA_alg : IsAlgebraic K x\n⊢ IsAlgebraic L x","decl":"/-- If `x` is algebraic over `K`, then `x` is algebraic over `L` when `L` is an extension of `K` -/\n@[stacks 09GF \"part one\"]\ntheorem IsAlgebraic.tower_top {x : A} (A_alg : IsAlgebraic K x) :\n    IsAlgebraic L x :=\n  A_alg.extendScalars (algebraMap K L).injective\n\n"}
{"name":"Transcendental.of_tower_top","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nA : Type u_5\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Ring A\ninst✝³ : Algebra K L\ninst✝² : Algebra L A\ninst✝¹ : Algebra K A\ninst✝ : IsScalarTower K L A\nx : A\nh : Transcendental L x\n⊢ Transcendental K x","decl":"variable {L} (K) in\n/-- If `x` is transcendental over `L`, then `x` is transcendental over `K` when\n  `L` is an extension of `K` -/\ntheorem Transcendental.of_tower_top {x : A} (h : Transcendental L x) :\n    Transcendental K x := fun H ↦ h (H.tower_top L)\n\n"}
{"name":"Algebra.IsAlgebraic.tower_top","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nA : Type u_5\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra K L\ninst✝³ : Algebra L A\ninst✝² : Algebra K A\ninst✝¹ : IsScalarTower K L A\ninst✝ : Algebra.IsAlgebraic K A\n⊢ Algebra.IsAlgebraic L A","decl":"/-- If A is an algebraic algebra over K, then A is algebraic over L when L is an extension of K -/\n@[stacks 09GF \"part two\"]\ntheorem Algebra.IsAlgebraic.tower_top [Algebra.IsAlgebraic K A] : Algebra.IsAlgebraic L A :=\n  Algebra.IsAlgebraic.extendScalars (algebraMap K L).injective\n\n"}
{"name":"Algebra.IsAlgebraic.tower_bot","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_6\nL : Type u_7\nA : Type u_8\ninst✝⁸ : CommRing K\ninst✝⁷ : Field L\ninst✝⁶ : Ring A\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra L A\ninst✝³ : Algebra K A\ninst✝² : IsScalarTower K L A\ninst✝¹ : Nontrivial A\ninst✝ : Algebra.IsAlgebraic K A\n⊢ Algebra.IsAlgebraic K L","decl":"theorem Algebra.IsAlgebraic.tower_bot (K L A : Type*) [CommRing K] [Field L] [Ring A]\n    [Algebra K L] [Algebra L A] [Algebra K A] [IsScalarTower K L A]\n    [Nontrivial A] [Algebra.IsAlgebraic K A] :\n    Algebra.IsAlgebraic K L :=\n  tower_bot_of_injective (algebraMap L A).injective\n\n"}
{"name":"Algebra.IsAlgebraic.algHom_bijective","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : NoZeroSMulDivisors K L\ninst✝ : Algebra.IsAlgebraic K L\nf : AlgHom K L L\n⊢ Function.Bijective ⇑f","decl":"theorem algHom_bijective [NoZeroSMulDivisors K L] [Algebra.IsAlgebraic K L] (f : L →ₐ[K] L) :\n    Function.Bijective f := by\n  refine ⟨f.injective, fun b ↦ ?_⟩\n  obtain ⟨p, hp, he⟩ := Algebra.IsAlgebraic.isAlgebraic (R := K) b\n  let f' : p.rootSet L → p.rootSet L := (rootSet_maps_to' (fun x ↦ x) f).restrict f _ _\n  have : f'.Surjective := Finite.injective_iff_surjective.1\n    fun _ _ h ↦ Subtype.eq <| f.injective <| Subtype.ext_iff.1 h\n  obtain ⟨a, ha⟩ := this ⟨b, mem_rootSet.2 ⟨hp, he⟩⟩\n  exact ⟨a, Subtype.ext_iff.1 ha⟩\n\n"}
{"name":"Algebra.IsAlgebraic.algHom_bijective₂","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nR : Type u_3\ninst✝⁶ : CommRing K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\ninst✝³ : NoZeroSMulDivisors K L\ninst✝² : Field R\ninst✝¹ : Algebra K R\ninst✝ : Algebra.IsAlgebraic K L\nf : AlgHom K L R\ng : AlgHom K R L\n⊢ And (Function.Bijective ⇑f) (Function.Bijective ⇑g)","decl":"theorem algHom_bijective₂ [NoZeroSMulDivisors K L] [Field R] [Algebra K R]\n    [Algebra.IsAlgebraic K L] (f : L →ₐ[K] R) (g : R →ₐ[K] L) :\n    Function.Bijective f ∧ Function.Bijective g :=\n  (g.injective.bijective₂_of_surjective f.injective (algHom_bijective <| g.comp f).2).symm\n\n"}
{"name":"Algebra.IsAlgebraic.bijective_of_isScalarTower","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nR : Type u_3\ninst✝⁸ : CommRing K\ninst✝⁷ : Field L\ninst✝⁶ : Algebra K L\ninst✝⁵ : NoZeroSMulDivisors K L\ninst✝⁴ : Algebra.IsAlgebraic K L\ninst✝³ : Field R\ninst✝² : Algebra K R\ninst✝¹ : Algebra L R\ninst✝ : IsScalarTower K L R\nf : AlgHom K R L\n⊢ Function.Bijective ⇑f","decl":"theorem bijective_of_isScalarTower [NoZeroSMulDivisors K L] [Algebra.IsAlgebraic K L]\n    [Field R] [Algebra K R] [Algebra L R] [IsScalarTower K L R] (f : R →ₐ[K] L) :\n    Function.Bijective f :=\n  (algHom_bijective₂ (IsScalarTower.toAlgHom K L R) f).2\n\n"}
{"name":"Algebra.IsAlgebraic.bijective_of_isScalarTower'","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nR : Type u_3\ninst✝⁸ : CommRing K\ninst✝⁷ : Field L\ninst✝⁶ : Algebra K L\ninst✝⁵ : Field R\ninst✝⁴ : Algebra K R\ninst✝³ : NoZeroSMulDivisors K R\ninst✝² : Algebra.IsAlgebraic K R\ninst✝¹ : Algebra L R\ninst✝ : IsScalarTower K L R\nf : AlgHom K R L\n⊢ Function.Bijective ⇑f","decl":"theorem bijective_of_isScalarTower' [Field R] [Algebra K R]\n    [NoZeroSMulDivisors K R]\n    [Algebra.IsAlgebraic K R] [Algebra L R] [IsScalarTower K L R] (f : R →ₐ[K] L) :\n    Function.Bijective f :=\n  (algHom_bijective₂ f (IsScalarTower.toAlgHom K L R)).1\n\n"}
{"name":"Algebra.IsAlgebraic.algEquivEquivAlgHom_apply","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : NoZeroSMulDivisors K L\ninst✝ : Algebra.IsAlgebraic K L\nϕ : AlgEquiv K L L\n⊢ Eq ((Algebra.IsAlgebraic.algEquivEquivAlgHom K L) ϕ) ↑ϕ","decl":"/-- Bijection between algebra equivalences and algebra homomorphisms -/\n@[simps]\nnoncomputable def algEquivEquivAlgHom [NoZeroSMulDivisors K L] [Algebra.IsAlgebraic K L] :\n    (L ≃ₐ[K] L) ≃* (L →ₐ[K] L) where\n  toFun ϕ := ϕ.toAlgHom\n  invFun ϕ := AlgEquiv.ofBijective ϕ (algHom_bijective ϕ)\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Algebra.IsAlgebraic.algEquivEquivAlgHom_symm_apply","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : CommRing K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : NoZeroSMulDivisors K L\ninst✝ : Algebra.IsAlgebraic K L\nϕ : AlgHom K L L\n⊢ Eq ((Algebra.IsAlgebraic.algEquivEquivAlgHom K L).symm ϕ) (AlgEquiv.ofBijective ϕ ⋯)","decl":"/-- Bijection between algebra equivalences and algebra homomorphisms -/\n@[simps]\nnoncomputable def algEquivEquivAlgHom [NoZeroSMulDivisors K L] [Algebra.IsAlgebraic K L] :\n    (L ≃ₐ[K] L) ≃* (L →ₐ[K] L) where\n  toFun ϕ := ϕ.toAlgHom\n  invFun ϕ := AlgEquiv.ofBijective ϕ (algHom_bijective ϕ)\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"IsAlgebraic.exists_nonzero_coeff_and_aeval_eq_zero","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\ns : S\nhRs : IsAlgebraic R s\nhs : Membership.mem (nonZeroDivisors S) s\n⊢ Exists fun q => And (Ne (q.coeff 0) 0) (Eq ((Polynomial.aeval s) q) 0)","decl":"theorem IsAlgebraic.exists_nonzero_coeff_and_aeval_eq_zero\n    {s : S} (hRs : IsAlgebraic R s) (hs : s ∈ nonZeroDivisors S) :\n    ∃ q : R[X], q.coeff 0 ≠ 0 ∧ aeval s q = 0 := by\n  obtain ⟨p, hp0, hp⟩ := hRs\n  obtain ⟨q, hpq, hq⟩ := exists_eq_pow_rootMultiplicity_mul_and_not_dvd p hp0 0\n  simp only [C_0, sub_zero, X_pow_mul, X_dvd_iff] at hpq hq\n  rw [hpq, map_mul, aeval_X_pow] at hp\n  exact ⟨q, hq, (nonZeroDivisors S).pow_mem hs (rootMultiplicity 0 p) (aeval s q) hp⟩\n\n"}
{"name":"IsAlgebraic.exists_nonzero_eq_adjoin_mul","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\ns : S\nhRs : IsAlgebraic R s\nhs : Membership.mem (nonZeroDivisors S) s\n⊢ Exists fun t => And (Membership.mem (Algebra.adjoin R (Singleton.singleton s)) t) (Exists fun r => And (Ne r 0) (Eq (HMul.hMul s t) ((algebraMap R S) r)))","decl":"theorem IsAlgebraic.exists_nonzero_eq_adjoin_mul\n    {s : S} (hRs : IsAlgebraic R s) (hs : s ∈ nonZeroDivisors S) :\n    ∃ᵉ (t ∈ Algebra.adjoin R {s}) (r ≠ (0 : R)), s * t = algebraMap R S r := by\n  have ⟨q, hq0, hq⟩ := hRs.exists_nonzero_coeff_and_aeval_eq_zero hs\n  have ⟨p, hp⟩ := X_dvd_sub_C (p := q)\n  refine ⟨aeval s p, aeval_mem_adjoin_singleton _ _, _, neg_ne_zero.mpr hq0, ?_⟩\n  apply_fun aeval s at hp\n  rwa [map_sub, hq, zero_sub, map_mul, aeval_X, aeval_C, ← map_neg, eq_comm] at hp\n\n"}
{"name":"IsAlgebraic.exists_nonzero_dvd","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\ns : S\nhRs : IsAlgebraic R s\nhs : Membership.mem (nonZeroDivisors S) s\n⊢ Exists fun r => And (Ne r 0) (Dvd.dvd s ((algebraMap R S) r))","decl":"theorem IsAlgebraic.exists_nonzero_dvd\n    {s : S} (hRs : IsAlgebraic R s) (hs : s ∈ nonZeroDivisors S) :\n    ∃ r : R, r ≠ 0 ∧ s ∣ algebraMap R S r := by\n  obtain ⟨q, hq0, hq⟩ := hRs.exists_nonzero_coeff_and_aeval_eq_zero hs\n  have key := map_dvd (aeval s) (X_dvd_sub_C (p := q))\n  rw [map_sub, hq, zero_sub, dvd_neg, aeval_X, aeval_C] at key\n  exact ⟨q.coeff 0, hq0, key⟩\n\n"}
{"name":"IsAlgebraic.exists_smul_eq_mul","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\na b : S\nhRb : IsAlgebraic R b\nhb : Membership.mem (nonZeroDivisors S) b\n⊢ Exists fun c => Exists fun d => And (Ne d 0) (Eq (HSMul.hSMul d a) (HMul.hMul b c))","decl":"/-- A fraction `(a : S) / (b : S)` can be reduced to `(c : S) / (d : R)`,\nif `b` is algebraic over `R`. -/\ntheorem IsAlgebraic.exists_smul_eq_mul\n    (a : S) {b : S} (hRb : IsAlgebraic R b) (hb : b ∈ nonZeroDivisors S) :\n    ∃ᵉ (c : S) (d ≠ (0 : R)), d • a = b * c :=\n  have ⟨r, hr, s, h⟩ := hRb.exists_nonzero_dvd hb\n  ⟨s * a, r, hr, by rw [Algebra.smul_def, h, mul_assoc]⟩\n\n"}
{"name":"Algebra.IsAlgebraic.exists_smul_eq_mul","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\ninst✝¹ : NoZeroDivisors S\ninst✝ : Algebra.IsAlgebraic R S\na b : S\nhb : Ne b 0\n⊢ Exists fun c => Exists fun d => And (Ne d 0) (Eq (HSMul.hSMul d a) (HMul.hMul b c))","decl":"/-- A fraction `(a : S) / (b : S)` can be reduced to `(c : S) / (d : R)`,\nif `b` is algebraic over `R`. -/\ntheorem Algebra.IsAlgebraic.exists_smul_eq_mul [NoZeroDivisors S] [Algebra.IsAlgebraic R S]\n    (a : S) {b : S} (hb : b ≠ 0) :\n    ∃ᵉ (c : S) (d ≠ (0 : R)), d • a = b * c :=\n  (isAlgebraic b).exists_smul_eq_mul a (mem_nonZeroDivisors_of_ne_zero hb)\n\n"}
{"name":"inv_eq_of_aeval_divX_ne_zero","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\np : Polynomial K\naeval_ne : Ne ((Polynomial.aeval x) p.divX) 0\n⊢ Eq (Inv.inv x) (HDiv.hDiv ((Polynomial.aeval x) p.divX) (HSub.hSub ((Polynomial.aeval x) p) ((algebraMap K L) (p.coeff 0))))","decl":"theorem inv_eq_of_aeval_divX_ne_zero {x : L} {p : K[X]} (aeval_ne : aeval x (divX p) ≠ 0) :\n    x⁻¹ = aeval x (divX p) / (aeval x p - algebraMap _ _ (p.coeff 0)) := by\n  rw [inv_eq_iff_eq_inv, inv_div, eq_comm, div_eq_iff, sub_eq_iff_eq_add, mul_comm]\n  conv_lhs => rw [← divX_mul_X_add p]\n  · rw [map_add, map_mul, aeval_X, aeval_C]\n  · exact aeval_ne\n\n"}
{"name":"inv_eq_of_root_of_coeff_zero_ne_zero","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\np : Polynomial K\naeval_eq : Eq ((Polynomial.aeval x) p) 0\ncoeff_zero_ne : Ne (p.coeff 0) 0\n⊢ Eq (Inv.inv x) (Neg.neg (HDiv.hDiv ((Polynomial.aeval x) p.divX) ((algebraMap K L) (p.coeff 0))))","decl":"theorem inv_eq_of_root_of_coeff_zero_ne_zero {x : L} {p : K[X]} (aeval_eq : aeval x p = 0)\n    (coeff_zero_ne : p.coeff 0 ≠ 0) : x⁻¹ = -(aeval x (divX p) / algebraMap _ _ (p.coeff 0)) := by\n  convert inv_eq_of_aeval_divX_ne_zero (p := p) (L := L)\n    (mt (fun h => (algebraMap K L).injective ?_) coeff_zero_ne) using 1\n  · rw [aeval_eq, zero_sub, div_neg]\n  rw [RingHom.map_zero]\n  convert aeval_eq\n  conv_rhs => rw [← divX_mul_X_add p]\n  rw [map_add, map_mul, h, zero_mul, zero_add, aeval_C]\n\n"}
{"name":"Subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nA : Subalgebra K L\nx : Subtype fun x => Membership.mem A x\np : Polynomial K\naeval_eq : Eq ((Polynomial.aeval x) p) 0\ncoeff_zero_ne : Ne (p.coeff 0) 0\n⊢ Membership.mem A (Inv.inv ↑x)","decl":"theorem Subalgebra.inv_mem_of_root_of_coeff_zero_ne_zero {x : A} {p : K[X]}\n    (aeval_eq : aeval x p = 0) (coeff_zero_ne : p.coeff 0 ≠ 0) : (x⁻¹ : L) ∈ A := by\n  suffices (x⁻¹ : L) = (-p.coeff 0)⁻¹ • aeval x (divX p) by\n    rw [this]\n    exact A.smul_mem (aeval x _).2 _\n  have : aeval (x : L) p = 0 := by rw [Subalgebra.aeval_coe, aeval_eq, Subalgebra.coe_zero]\n  -- Porting note: this was a long sequence of `rw`.\n  rw [inv_eq_of_root_of_coeff_zero_ne_zero this coeff_zero_ne, div_eq_inv_mul, Algebra.smul_def]\n  simp only [aeval_coe, Submonoid.coe_mul, Subsemiring.coe_toSubmonoid, coe_toSubsemiring,\n    coe_algebraMap]\n  rw [map_inv₀, map_neg, inv_neg, neg_mul]\n\n"}
{"name":"Subalgebra.inv_mem_of_algebraic","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nA : Subalgebra K L\nx : Subtype fun x => Membership.mem A x\nhx : IsAlgebraic K ↑x\n⊢ Membership.mem A (Inv.inv ↑x)","decl":"theorem Subalgebra.inv_mem_of_algebraic {x : A} (hx : _root_.IsAlgebraic K (x : L)) :\n    (x⁻¹ : L) ∈ A := by\n  obtain ⟨p, ne_zero, aeval_eq⟩ := hx\n  rw [Subalgebra.aeval_coe, Subalgebra.coe_eq_zero] at aeval_eq\n  revert ne_zero aeval_eq\n  refine p.recOnHorner ?_ ?_ ?_\n  · intro h\n    contradiction\n  · intro p a hp ha _ih _ne_zero aeval_eq\n    refine A.inv_mem_of_root_of_coeff_zero_ne_zero aeval_eq ?_\n    rwa [coeff_add, hp, zero_add, coeff_C, if_pos rfl]\n  · intro p hp ih _ne_zero aeval_eq\n    rw [map_mul, aeval_X, mul_eq_zero] at aeval_eq\n    cases' aeval_eq with aeval_eq x_eq\n    · exact ih hp aeval_eq\n    · rw [x_eq, Subalgebra.coe_zero, inv_zero]\n      exact A.zero_mem\n\n"}
{"name":"Subalgebra.isField_of_algebraic","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nA : Subalgebra K L\ninst✝ : Algebra.IsAlgebraic K L\n⊢ IsField (Subtype fun x => Membership.mem A x)","decl":"/-- In an algebraic extension L/K, an intermediate subalgebra is a field. -/\n@[stacks 0BID]\ntheorem Subalgebra.isField_of_algebraic [Algebra.IsAlgebraic K L] : IsField A :=\n  { show Nontrivial A by infer_instance, Subalgebra.toCommRing A with\n    mul_inv_cancel := fun {a} ha =>\n      ⟨⟨a⁻¹, A.inv_mem_of_algebraic (Algebra.IsAlgebraic.isAlgebraic (a : L))⟩,\n        Subtype.ext (mul_inv_cancel₀ (mt (Subalgebra.coe_eq_zero _).mp ha))⟩ }\n\n"}
{"name":"Transcendental.infinite","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial R\nx : A\nhx : Transcendental R x\n⊢ Infinite A","decl":"theorem Transcendental.infinite {x : A} (hx : Transcendental R x) : Infinite A :=\n  .of_injective _ (transcendental_iff_injective.mp hx)\n\n"}
{"name":"Algebra.Transcendental.infinite","module":"Mathlib.RingTheory.Algebraic.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : Nontrivial R\ninst✝ : Algebra.Transcendental R A\n⊢ Infinite A","decl":"variable (R A) in\ntheorem Algebra.Transcendental.infinite [Algebra.Transcendental R A] : Infinite A :=\n  have ⟨x, hx⟩ := ‹Algebra.Transcendental R A›\n  hx.infinite\n\n"}
