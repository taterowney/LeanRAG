{"name":"Finsupp.linearIndependent_single","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nφ : ι → Type u_4\nf : (ι : ι) → φ ι → M\nhf : ∀ (i : ι), LinearIndependent R (f i)\n⊢ LinearIndependent R fun ix => Finsupp.single ix.fst (f ix.fst ix.snd)","decl":"theorem linearIndependent_single {φ : ι → Type*} {f : ∀ ι, φ ι → M}\n    (hf : ∀ i, LinearIndependent R (f i)) :\n    LinearIndependent R fun ix : Σi, φ i => single ix.1 (f ix.1 ix.2) := by\n  apply @linearIndependent_iUnion_finite R _ _ _ _ ι φ fun i x => single i (f i x)\n  · intro i\n    have h_disjoint : Disjoint (span R (range (f i))) (ker (lsingle i)) := by\n      rw [ker_lsingle]\n      exact disjoint_bot_right\n    apply (hf i).map h_disjoint\n  · intro i t _ hit\n    refine (disjoint_lsingle_lsingle {i} t (disjoint_singleton_left.2 hit)).mono ?_ ?_\n    · rw [span_le]\n      simp only [iSup_singleton]\n      rw [range_coe]\n      apply range_comp_subset_range _ (lsingle i)\n    · refine iSup₂_mono fun i hi => ?_\n      rw [span_le, range_coe]\n      apply range_comp_subset_range _ (lsingle i)\n\n"}
{"name":"Finsupp.basis_repr","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nφ : ι → Type u_4\nb : (i : ι) → Basis (φ i) R M\ng : Finsupp ι M\nix : Sigma fun i => φ i\n⊢ Eq (((Finsupp.basis b).repr g) ix) (((b ix.fst).repr (g ix.fst)) ix.snd)","decl":"@[simp]\ntheorem basis_repr {φ : ι → Type*} (b : ∀ i, Basis (φ i) R M) (g : ι →₀ M) (ix) :\n    (Finsupp.basis b).repr g ix = (b ix.1).repr (g ix.1) ix.2 :=\n  rfl\n\n"}
{"name":"Finsupp.coe_basis","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nφ : ι → Type u_4\nb : (i : ι) → Basis (φ i) R M\n⊢ Eq ⇑(Finsupp.basis b) fun ix => Finsupp.single ix.fst ((b ix.fst) ix.snd)","decl":"@[simp]\ntheorem coe_basis {φ : ι → Type*} (b : ∀ i, Basis (φ i) R M) :\n    ⇑(Finsupp.basis b) = fun ix : Σi, φ i => single ix.1 (b ix.1 ix.2) :=\n  funext fun ⟨i, x⟩ =>\n    Basis.apply_eq_iff.mpr <| by\n      classical\n      ext ⟨j, y⟩\n      by_cases h : i = j\n      · cases h\n        simp only [basis_repr, single_eq_same, Basis.repr_self,\n          Finsupp.single_apply_left sigma_mk_injective]\n      · have : Sigma.mk i x ≠ Sigma.mk j y := fun h' => h <| congrArg (fun s => s.fst) h'\n        -- Porting note: previously `this` not needed\n        simp only [basis_repr, single_apply, h, this, if_false, LinearEquiv.map_zero, zero_apply]\n\n"}
{"name":"Finsupp.basisSingleOne_repr","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nι : Type u_3\ninst✝ : Semiring R\n⊢ Eq Finsupp.basisSingleOne.repr (LinearEquiv.refl R (Finsupp ι R))","decl":"/-- The basis on `ι →₀ M` with basis vectors `fun i ↦ single i 1`. -/\n@[simps]\nprotected def basisSingleOne : Basis ι R (ι →₀ R) :=\n  Basis.ofRepr (LinearEquiv.refl _ _)\n\n"}
{"name":"Finsupp.coe_basisSingleOne","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nι : Type u_3\ninst✝ : Semiring R\n⊢ Eq ⇑Finsupp.basisSingleOne fun i => Finsupp.single i 1","decl":"@[simp]\ntheorem coe_basisSingleOne : (Finsupp.basisSingleOne : ι → ι →₀ R) = fun i => Finsupp.single i 1 :=\n  funext fun _ => Basis.apply_eq_iff.mpr rfl\n\n"}
{"name":"Finset.sum_single_ite","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nn : Type u_3\ninst✝² : DecidableEq n\ninst✝¹ : Semiring R\ninst✝ : Fintype n\na : R\ni : n\n⊢ Eq (Finset.univ.sum fun x => Finsupp.single x (ite (Eq i x) a 0)) (Finsupp.single i a)","decl":"theorem _root_.Finset.sum_single_ite [Fintype n] (a : R) (i : n) :\n    (∑ x : n, Finsupp.single x (if i = x then a else 0)) = Finsupp.single i a := by\n  simp only [apply_ite (Finsupp.single _), Finsupp.single_zero, Finset.sum_ite_eq,\n    if_pos (Finset.mem_univ _)]\n\n"}
{"name":"Basis.equivFun_symm_single","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nM : Type u_2\nn : Type u_3\ninst✝⁴ : DecidableEq n\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite n\nb : Basis n R M\ni : n\n⊢ Eq (b.equivFun.symm (Pi.single i 1)) (b i)","decl":"@[simp]\ntheorem equivFun_symm_single [Finite n] (b : Basis n R M) (i : n) :\n    b.equivFun.symm (Pi.single i 1) = b i := by\n  cases nonempty_fintype n\n  simp [Pi.single_apply]\n\n"}
{"name":"Basis.equivFun_symm_stdBasis","module":"Mathlib.LinearAlgebra.Finsupp.VectorSpace","initialProofState":"R : Type u_1\nM : Type u_2\nn : Type u_3\ninst✝⁴ : DecidableEq n\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite n\nb : Basis n R M\ni : n\n⊢ Eq (b.equivFun.symm ((LinearMap.stdBasis R (fun x => R) i) 1)) (b i)","decl":"set_option linter.deprecated false in\n@[deprecated equivFun_symm_single (since := \"2024-08-09\")]\ntheorem equivFun_symm_stdBasis [Finite n] (b : Basis n R M) (i : n) :\n    b.equivFun.symm (LinearMap.stdBasis R (fun _ => R) i 1) = b i :=\n  equivFun_symm_single ..\n\n"}
