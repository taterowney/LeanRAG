{"name":"DFinsupp.coe_finset_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\nα : Type u_1\ninst✝ : (i : ι) → AddCommMonoid (β i)\ns : Finset α\ng : α → DFinsupp fun i => β i\n⊢ Eq (⇑(s.sum fun a => g a)) (s.sum fun a => ⇑(g a))","decl":"@[simp, norm_cast]\ntheorem coe_finset_sum {α} [∀ i, AddCommMonoid (β i)] (s : Finset α) (g : α → Π₀ i, β i) :\n    ⇑(∑ a ∈ s, g a) = ∑ a ∈ s, ⇑(g a) :=\n  map_sum coeFnAddMonoidHom g s\n\n"}
{"name":"DFinsupp.finset_sum_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\nα : Type u_1\ninst✝ : (i : ι) → AddCommMonoid (β i)\ns : Finset α\ng : α → DFinsupp fun i => β i\ni : ι\n⊢ Eq ((s.sum fun a => g a) i) (s.sum fun a => (g a) i)","decl":"@[simp]\ntheorem finset_sum_apply {α} [∀ i, AddCommMonoid (β i)] (s : Finset α) (g : α → Π₀ i, β i) (i : ι) :\n    (∑ a ∈ s, g a) i = ∑ a ∈ s, g a i :=\n  map_sum (evalAddMonoidHom i) g s\n\n"}
{"name":"map_dfinsupp_prod","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁶ : DecidableEq ι\nR : Type u_1\nS : Type u_2\nH : Type u_3\ninst✝⁵ : (i : ι) → Zero (β i)\ninst✝⁴ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝³ : CommMonoid R\ninst✝² : CommMonoid S\ninst✝¹ : FunLike H R S\ninst✝ : MonoidHomClass H R S\nh : H\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → R\n⊢ Eq (h (f.prod g)) (f.prod fun a b => h (g a b))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.map_dfinsupp_prod\n    {R S H : Type*} [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid R] [CommMonoid S] [FunLike H R S] [MonoidHomClass H R S] (h : H) (f : Π₀ i, β i)\n    (g : ∀ i, β i → R) : h (f.prod g) = f.prod fun a b => h (g a b) :=\n  map_prod _ _ _\n\n"}
{"name":"map_dfinsupp_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁶ : DecidableEq ι\nR : Type u_1\nS : Type u_2\nH : Type u_3\ninst✝⁵ : (i : ι) → Zero (β i)\ninst✝⁴ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝³ : AddCommMonoid R\ninst✝² : AddCommMonoid S\ninst✝¹ : FunLike H R S\ninst✝ : AddMonoidHomClass H R S\nh : H\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → R\n⊢ Eq (h (f.sum g)) (f.sum fun a b => h (g a b))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.map_dfinsupp_prod\n    {R S H : Type*} [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid R] [CommMonoid S] [FunLike H R S] [MonoidHomClass H R S] (h : H) (f : Π₀ i, β i)\n    (g : ∀ i, β i → R) : h (f.prod g) = f.prod fun a b => h (g a b) :=\n  map_prod _ _ _\n\n"}
{"name":"DFinsupp.prod_mapRange_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\ninst✝⁵ : DecidableEq ι\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝⁴ : (i : ι) → Zero (β₁ i)\ninst✝³ : (i : ι) → Zero (β₂ i)\ninst✝² : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝¹ : (i : ι) → (x : β₂ i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ng : DFinsupp fun i => β₁ i\nh : (i : ι) → β₂ i → γ\nh0 : ∀ (i : ι), Eq (h i 0) 1\n⊢ Eq ((DFinsupp.mapRange f hf g).prod h) (g.prod fun i b => h i (f i b))","decl":"@[to_additive]\ntheorem prod_mapRange_index {β₁ : ι → Type v₁} {β₂ : ι → Type v₂} [∀ i, Zero (β₁ i)]\n    [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i) (x : β₂ i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} {h : ∀ i, β₂ i → γ}\n    (h0 : ∀ i, h i 0 = 1) : (mapRange f hf g).prod h = g.prod fun i b => h i (f i b) := by\n  rw [mapRange_def]\n  refine (Finset.prod_subset support_mk_subset ?_).trans ?_\n  · intro i h1 h2\n    simp only [mem_support_toFun, ne_eq] at h1\n    simp only [Finset.coe_sort_coe, mem_support_toFun, mk_apply, ne_eq, h1, not_false_iff,\n      dite_eq_ite, ite_true, not_not] at h2\n    simp [h2, h0]\n  · refine Finset.prod_congr rfl ?_\n    intro i h1\n    simp only [mem_support_toFun, ne_eq] at h1\n    simp [h1]\n\n"}
{"name":"DFinsupp.sum_mapRange_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\ninst✝⁵ : DecidableEq ι\nβ₁ : ι → Type v₁\nβ₂ : ι → Type v₂\ninst✝⁴ : (i : ι) → Zero (β₁ i)\ninst✝³ : (i : ι) → Zero (β₂ i)\ninst✝² : (i : ι) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝¹ : (i : ι) → (x : β₂ i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf : (i : ι) → β₁ i → β₂ i\nhf : ∀ (i : ι), Eq (f i 0) 0\ng : DFinsupp fun i => β₁ i\nh : (i : ι) → β₂ i → γ\nh0 : ∀ (i : ι), Eq (h i 0) 0\n⊢ Eq ((DFinsupp.mapRange f hf g).sum h) (g.sum fun i b => h i (f i b))","decl":"@[to_additive]\ntheorem prod_mapRange_index {β₁ : ι → Type v₁} {β₂ : ι → Type v₂} [∀ i, Zero (β₁ i)]\n    [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ (i) (x : β₂ i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {f : ∀ i, β₁ i → β₂ i} {hf : ∀ i, f i 0 = 0} {g : Π₀ i, β₁ i} {h : ∀ i, β₂ i → γ}\n    (h0 : ∀ i, h i 0 = 1) : (mapRange f hf g).prod h = g.prod fun i b => h i (f i b) := by\n  rw [mapRange_def]\n  refine (Finset.prod_subset support_mk_subset ?_).trans ?_\n  · intro i h1 h2\n    simp only [mem_support_toFun, ne_eq] at h1\n    simp only [Finset.coe_sort_coe, mem_support_toFun, mk_apply, ne_eq, h1, not_false_iff,\n      dite_eq_ite, ite_true, not_not] at h2\n    simp [h2, h0]\n  · refine Finset.prod_congr rfl ?_\n    intro i h1\n    simp only [mem_support_toFun, ne_eq] at h1\n    simp [h1]\n\n"}
{"name":"DFinsupp.prod_zero_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nh : (i : ι) → β i → γ\n⊢ Eq (DFinsupp.prod 0 h) 1","decl":"@[to_additive]\ntheorem prod_zero_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {h : ∀ i, β i → γ} : (0 : Π₀ i, β i).prod h = 1 :=\n  rfl\n\n"}
{"name":"DFinsupp.sum_zero_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nh : (i : ι) → β i → γ\n⊢ Eq (DFinsupp.sum 0 h) 0","decl":"@[to_additive]\ntheorem prod_zero_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {h : ∀ i, β i → γ} : (0 : Π₀ i, β i).prod h = 1 :=\n  rfl\n\n"}
{"name":"DFinsupp.prod_single_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\ni : ι\nb : β i\nh : (i : ι) → β i → γ\nh_zero : Eq (h i 0) 1\n⊢ Eq ((DFinsupp.single i b).prod h) (h i b)","decl":"@[to_additive]\ntheorem prod_single_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {i : ι} {b : β i} {h : ∀ i, β i → γ} (h_zero : h i 0 = 1) : (single i b).prod h = h i b := by\n  by_cases h : b ≠ 0\n  · simp [DFinsupp.prod, support_single_ne_zero h]\n  · rw [not_not] at h\n    simp [h, prod_zero_index, h_zero]\n    rfl\n\n"}
{"name":"DFinsupp.sum_single_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\ni : ι\nb : β i\nh : (i : ι) → β i → γ\nh_zero : Eq (h i 0) 0\n⊢ Eq ((DFinsupp.single i b).sum h) (h i b)","decl":"@[to_additive]\ntheorem prod_single_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {i : ι} {b : β i} {h : ∀ i, β i → γ} (h_zero : h i 0 = 1) : (single i b).prod h = h i b := by\n  by_cases h : b ≠ 0\n  · simp [DFinsupp.prod, support_single_ne_zero h]\n  · rw [not_not] at h\n    simp [h, prod_zero_index, h_zero]\n    rfl\n\n"}
{"name":"DFinsupp.sum_neg_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddGroup (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\ng : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh0 : ∀ (i : ι), Eq (h i 0) 0\n⊢ Eq ((Neg.neg g).sum h) (g.sum fun i b => h i (Neg.neg b))","decl":"@[to_additive]\ntheorem prod_neg_index [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {g : Π₀ i, β i} {h : ∀ i, β i → γ} (h0 : ∀ i, h i 0 = 1) :\n    (-g).prod h = g.prod fun i b => h i (-b) :=\n  prod_mapRange_index h0\n\n"}
{"name":"DFinsupp.prod_neg_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddGroup (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\ng : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh0 : ∀ (i : ι), Eq (h i 0) 1\n⊢ Eq ((Neg.neg g).prod h) (g.prod fun i b => h i (Neg.neg b))","decl":"@[to_additive]\ntheorem prod_neg_index [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {g : Π₀ i, β i} {h : ∀ i, β i → γ} (h0 : ∀ i, h i 0 = 1) :\n    (-g).prod h = g.prod fun i b => h i (-b) :=\n  prod_mapRange_index h0\n\n"}
{"name":"DFinsupp.prod_comm","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"γ : Type w\nι₁ : Type u_3\nι₂ : Type u_4\nβ₁ : ι₁ → Type u_1\nβ₂ : ι₂ → Type u_2\ninst✝⁶ : DecidableEq ι₁\ninst✝⁵ : DecidableEq ι₂\ninst✝⁴ : (i : ι₁) → Zero (β₁ i)\ninst✝³ : (i : ι₂) → Zero (β₂ i)\ninst✝² : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝¹ : (i : ι₂) → (x : β₂ i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf₁ : DFinsupp fun i => β₁ i\nf₂ : DFinsupp fun i => β₂ i\nh : (i : ι₁) → β₁ i → (i : ι₂) → β₂ i → γ\n⊢ Eq (f₁.prod fun i₁ x₁ => f₂.prod fun i₂ x₂ => h i₁ x₁ i₂ x₂) (f₂.prod fun i₂ x₂ => f₁.prod fun i₁ x₁ => h i₁ x₁ i₂ x₂)","decl":"@[to_additive]\ntheorem prod_comm {ι₁ ι₂ : Sort _} {β₁ : ι₁ → Type*} {β₂ : ι₂ → Type*} [DecidableEq ι₁]\n    [DecidableEq ι₂] [∀ i, Zero (β₁ i)] [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)]\n    [∀ (i) (x : β₂ i), Decidable (x ≠ 0)] [CommMonoid γ] (f₁ : Π₀ i, β₁ i) (f₂ : Π₀ i, β₂ i)\n    (h : ∀ i, β₁ i → ∀ i, β₂ i → γ) :\n    (f₁.prod fun i₁ x₁ => f₂.prod fun i₂ x₂ => h i₁ x₁ i₂ x₂) =\n      f₂.prod fun i₂ x₂ => f₁.prod fun i₁ x₁ => h i₁ x₁ i₂ x₂ :=\n  Finset.prod_comm\n\n"}
{"name":"DFinsupp.sum_comm","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"γ : Type w\nι₁ : Type u_3\nι₂ : Type u_4\nβ₁ : ι₁ → Type u_1\nβ₂ : ι₂ → Type u_2\ninst✝⁶ : DecidableEq ι₁\ninst✝⁵ : DecidableEq ι₂\ninst✝⁴ : (i : ι₁) → Zero (β₁ i)\ninst✝³ : (i : ι₂) → Zero (β₂ i)\ninst✝² : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝¹ : (i : ι₂) → (x : β₂ i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf₁ : DFinsupp fun i => β₁ i\nf₂ : DFinsupp fun i => β₂ i\nh : (i : ι₁) → β₁ i → (i : ι₂) → β₂ i → γ\n⊢ Eq (f₁.sum fun i₁ x₁ => f₂.sum fun i₂ x₂ => h i₁ x₁ i₂ x₂) (f₂.sum fun i₂ x₂ => f₁.sum fun i₁ x₁ => h i₁ x₁ i₂ x₂)","decl":"@[to_additive]\ntheorem prod_comm {ι₁ ι₂ : Sort _} {β₁ : ι₁ → Type*} {β₂ : ι₂ → Type*} [DecidableEq ι₁]\n    [DecidableEq ι₂] [∀ i, Zero (β₁ i)] [∀ i, Zero (β₂ i)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)]\n    [∀ (i) (x : β₂ i), Decidable (x ≠ 0)] [CommMonoid γ] (f₁ : Π₀ i, β₁ i) (f₂ : Π₀ i, β₂ i)\n    (h : ∀ i, β₁ i → ∀ i, β₂ i → γ) :\n    (f₁.prod fun i₁ x₁ => f₂.prod fun i₂ x₂ => h i₁ x₁ i₂ x₂) =\n      f₂.prod fun i₂ x₂ => f₁.prod fun i₁ x₁ => h i₁ x₁ i₂ x₂ :=\n  Finset.prod_comm\n\n"}
{"name":"DFinsupp.sum_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u_1\nβ : ι → Type v\nι₁ : Type u₁\ninst✝³ : DecidableEq ι₁\nβ₁ : ι₁ → Type v₁\ninst✝² : (i₁ : ι₁) → Zero (β₁ i₁)\ninst✝¹ : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝ : (i : ι) → AddCommMonoid (β i)\nf : DFinsupp fun i₁ => β₁ i₁\ng : (i₁ : ι₁) → β₁ i₁ → DFinsupp fun i => β i\ni₂ : ι\n⊢ Eq ((f.sum g) i₂) (f.sum fun i₁ b => (g i₁ b) i₂)","decl":"@[simp]\ntheorem sum_apply {ι} {β : ι → Type v} {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁}\n    [∀ i₁, Zero (β₁ i₁)] [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]\n    {f : Π₀ i₁, β₁ i₁} {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} {i₂ : ι} :\n    (f.sum g) i₂ = f.sum fun i₁ b => g i₁ b i₂ :=\n  map_sum (evalAddMonoidHom i₂) _ f.support\n\n"}
{"name":"DFinsupp.support_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\nι₁ : Type u₁\ninst✝⁴ : DecidableEq ι₁\nβ₁ : ι₁ → Type v₁\ninst✝³ : (i₁ : ι₁) → Zero (β₁ i₁)\ninst✝² : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i₁ => β₁ i₁\ng : (i₁ : ι₁) → β₁ i₁ → DFinsupp fun i => β i\n⊢ HasSubset.Subset (f.sum g).support (f.support.biUnion fun i => (g i (f i)).support)","decl":"theorem support_sum {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]\n    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]\n    [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i₁, β₁ i₁} {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} :\n    (f.sum g).support ⊆ f.support.biUnion fun i => (g i (f i)).support := by\n  have :\n    ∀ i₁ : ι,\n      (f.sum fun (i : ι₁) (b : β₁ i) => (g i b) i₁) ≠ 0 → ∃ i : ι₁, f i ≠ 0 ∧ ¬(g i (f i)) i₁ = 0 :=\n    fun i₁ h =>\n    let ⟨i, hi, Ne⟩ := Finset.exists_ne_zero_of_sum_ne_zero h\n    ⟨i, mem_support_iff.1 hi, Ne⟩\n  simpa [Finset.subset_iff, mem_support_iff, Finset.mem_biUnion, sum_apply] using this\n\n"}
{"name":"DFinsupp.prod_one","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf : DFinsupp fun i => β i\n⊢ Eq (f.prod fun x x => 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem prod_one [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} : (f.prod fun _ _ => (1 : γ)) = 1 :=\n  Finset.prod_const_one\n\n"}
{"name":"DFinsupp.sum_zero","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf : DFinsupp fun i => β i\n⊢ Eq (f.sum fun x x => 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem prod_one [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} : (f.prod fun _ _ => (1 : γ)) = 1 :=\n  Finset.prod_const_one\n\n"}
{"name":"DFinsupp.prod_mul","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf : DFinsupp fun i => β i\nh₁ h₂ : (i : ι) → β i → γ\n⊢ Eq (f.prod fun i b => HMul.hMul (h₁ i b) (h₂ i b)) (HMul.hMul (f.prod h₁) (f.prod h₂))","decl":"@[to_additive (attr := simp)]\ntheorem prod_mul [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} {h₁ h₂ : ∀ i, β i → γ} :\n    (f.prod fun i b => h₁ i b * h₂ i b) = f.prod h₁ * f.prod h₂ :=\n  Finset.prod_mul_distrib\n\n"}
{"name":"DFinsupp.sum_add","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf : DFinsupp fun i => β i\nh₁ h₂ : (i : ι) → β i → γ\n⊢ Eq (f.sum fun i b => HAdd.hAdd (h₁ i b) (h₂ i b)) (HAdd.hAdd (f.sum h₁) (f.sum h₂))","decl":"@[to_additive (attr := simp)]\ntheorem prod_mul [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} {h₁ h₂ : ∀ i, β i → γ} :\n    (f.prod fun i b => h₁ i b * h₂ i b) = f.prod h₁ * f.prod h₂ :=\n  Finset.prod_mul_distrib\n\n"}
{"name":"DFinsupp.prod_inv","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommGroup γ\nf : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\n⊢ Eq (f.prod fun i b => Inv.inv (h i b)) (Inv.inv (f.prod h))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommGroup γ]\n    {f : Π₀ i, β i} {h : ∀ i, β i → γ} : (f.prod fun i b => (h i b)⁻¹) = (f.prod h)⁻¹ :=\n  (map_prod (invMonoidHom : γ →* γ) _ f.support).symm\n\n"}
{"name":"DFinsupp.sum_neg","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommGroup γ\nf : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\n⊢ Eq (f.sum fun i b => Neg.neg (h i b)) (Neg.neg (f.sum h))","decl":"@[to_additive (attr := simp)]\ntheorem prod_inv [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommGroup γ]\n    {f : Π₀ i, β i} {h : ∀ i, β i → γ} : (f.prod fun i b => (h i b)⁻¹) = (f.prod h)⁻¹ :=\n  (map_prod (invMonoidHom : γ →* γ) _ f.support).symm\n\n"}
{"name":"DFinsupp.prod_eq_one","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nhyp : ∀ (i : ι), Eq (h i (f i)) 1\n⊢ Eq (f.prod h) 1","decl":"@[to_additive]\ntheorem prod_eq_one [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} {h : ∀ i, β i → γ} (hyp : ∀ i, h i (f i) = 1) : f.prod h = 1 :=\n  Finset.prod_eq_one fun i _ => hyp i\n\n"}
{"name":"DFinsupp.sum_eq_zero","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nhyp : ∀ (i : ι), Eq (h i (f i)) 0\n⊢ Eq (f.sum h) 0","decl":"@[to_additive]\ntheorem prod_eq_one [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ]\n    {f : Π₀ i, β i} {h : ∀ i, β i → γ} (hyp : ∀ i, h i (f i) = 1) : f.prod h = 1 :=\n  Finset.prod_eq_one fun i _ => hyp i\n\n"}
{"name":"DFinsupp.smul_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\nα : Type u_1\ninst✝⁴ : Monoid α\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : AddCommMonoid γ\ninst✝ : DistribMulAction α γ\nf : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nc : α\n⊢ Eq (HSMul.hSMul c (f.sum h)) (f.sum fun a b => HSMul.hSMul c (h a b))","decl":"theorem smul_sum {α : Type*} [Monoid α] [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [AddCommMonoid γ] [DistribMulAction α γ] {f : Π₀ i, β i} {h : ∀ i, β i → γ} {c : α} :\n    c • f.sum h = f.sum fun a b => c • h a b :=\n  Finset.smul_sum\n\n"}
{"name":"DFinsupp.prod_add_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf g : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 1\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HMul.hMul (h i b₁) (h i b₂))\n⊢ Eq ((HAdd.hAdd f g).prod h) (HMul.hMul (f.prod h) (g.prod h))","decl":"@[to_additive]\ntheorem prod_add_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) : (f + g).prod h = f.prod h * g.prod h :=\n  have f_eq : (∏ i ∈ f.support ∪ g.support, h i (f i)) = f.prod h :=\n    (Finset.prod_subset Finset.subset_union_left <| by\n        simp +contextual [mem_support_iff, h_zero]).symm\n  have g_eq : (∏ i ∈ f.support ∪ g.support, h i (g i)) = g.prod h :=\n    (Finset.prod_subset Finset.subset_union_right <| by\n        simp +contextual [mem_support_iff, h_zero]).symm\n  calc\n    (∏ i ∈ (f + g).support, h i ((f + g) i)) = ∏ i ∈ f.support ∪ g.support, h i ((f + g) i) :=\n      Finset.prod_subset support_add <| by\n        simp +contextual [mem_support_iff, h_zero]\n    _ = (∏ i ∈ f.support ∪ g.support, h i (f i)) * ∏ i ∈ f.support ∪ g.support, h i (g i) := by\n      { simp [h_add, Finset.prod_mul_distrib] }\n    _ = _ := by rw [f_eq, g_eq]\n\n"}
{"name":"DFinsupp.sum_add_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf g : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 0\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h i b₁) (h i b₂))\n⊢ Eq ((HAdd.hAdd f g).sum h) (HAdd.hAdd (f.sum h) (g.sum h))","decl":"@[to_additive]\ntheorem prod_add_index [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) : (f + g).prod h = f.prod h * g.prod h :=\n  have f_eq : (∏ i ∈ f.support ∪ g.support, h i (f i)) = f.prod h :=\n    (Finset.prod_subset Finset.subset_union_left <| by\n        simp +contextual [mem_support_iff, h_zero]).symm\n  have g_eq : (∏ i ∈ f.support ∪ g.support, h i (g i)) = g.prod h :=\n    (Finset.prod_subset Finset.subset_union_right <| by\n        simp +contextual [mem_support_iff, h_zero]).symm\n  calc\n    (∏ i ∈ (f + g).support, h i ((f + g) i)) = ∏ i ∈ f.support ∪ g.support, h i ((f + g) i) :=\n      Finset.prod_subset support_add <| by\n        simp +contextual [mem_support_iff, h_zero]\n    _ = (∏ i ∈ f.support ∪ g.support, h i (f i)) * ∏ i ∈ f.support ∪ g.support, h i (g i) := by\n      { simp [h_add, Finset.prod_mul_distrib] }\n    _ = _ := by rw [f_eq, g_eq]\n\n"}
{"name":"DFinsupp.sum_eq_sum_fintype","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nv : DFinsupp fun i => β i\nf : (i : ι) → β i → γ\nhf : ∀ (i : ι), Eq (f i 0) 0\n⊢ Eq (v.sum f) (Finset.univ.sum fun i => f i (DFinsupp.equivFunOnFintype v i))","decl":"@[to_additive (attr := simp)]\ntheorem prod_eq_prod_fintype [Fintype ι] [∀ i, Zero (β i)] [∀ (i : ι) (x : β i), Decidable (x ≠ 0)]\n    -- Porting note: `f` was a typeclass argument\n    [CommMonoid γ] (v : Π₀ i, β i) {f : ∀ i, β i → γ} (hf : ∀ i, f i 0 = 1) :\n    v.prod f = ∏ i, f i (DFinsupp.equivFunOnFintype v i) := by\n  suffices (∏ i ∈ v.support, f i (v i)) = ∏ i, f i (v i) by simp [DFinsupp.prod, this]\n  apply Finset.prod_subset v.support.subset_univ\n  intro i _ hi\n  rw [mem_support_iff, not_not] at hi\n  rw [hi, hf]\n\n"}
{"name":"DFinsupp.prod_eq_prod_fintype","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\ninst✝³ : Fintype ι\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nv : DFinsupp fun i => β i\nf : (i : ι) → β i → γ\nhf : ∀ (i : ι), Eq (f i 0) 1\n⊢ Eq (v.prod f) (Finset.univ.prod fun i => f i (DFinsupp.equivFunOnFintype v i))","decl":"@[to_additive (attr := simp)]\ntheorem prod_eq_prod_fintype [Fintype ι] [∀ i, Zero (β i)] [∀ (i : ι) (x : β i), Decidable (x ≠ 0)]\n    -- Porting note: `f` was a typeclass argument\n    [CommMonoid γ] (v : Π₀ i, β i) {f : ∀ i, β i → γ} (hf : ∀ i, f i 0 = 1) :\n    v.prod f = ∏ i, f i (DFinsupp.equivFunOnFintype v i) := by\n  suffices (∏ i ∈ v.support, f i (v i)) = ∏ i, f i (v i) by simp [DFinsupp.prod, this]\n  apply Finset.prod_subset v.support.subset_univ\n  intro i _ hi\n  rw [mem_support_iff, not_not] at hi\n  rw [hi, hf]\n\n"}
{"name":"DFinsupp.prod_eq_zero_iff","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → Zero (β i)\ninst✝³ : CommMonoidWithZero γ\ninst✝² : Nontrivial γ\ninst✝¹ : NoZeroDivisors γ\ninst✝ : (i : ι) → DecidableEq (β i)\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → γ\n⊢ Iff (Eq (f.prod g) 0) (Exists fun i => And (Membership.mem f.support i) (Eq (g i (f i)) 0))","decl":"@[simp]\nlemma prod_eq_zero_iff : f.prod g = 0 ↔ ∃ i ∈ f.support, g i (f i) = 0 := Finset.prod_eq_zero_iff\n"}
{"name":"DFinsupp.prod_ne_zero_iff","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : (i : ι) → Zero (β i)\ninst✝³ : CommMonoidWithZero γ\ninst✝² : Nontrivial γ\ninst✝¹ : NoZeroDivisors γ\ninst✝ : (i : ι) → DecidableEq (β i)\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → γ\n⊢ Iff (Ne (f.prod g) 0) (∀ (i : ι), Membership.mem f.support i → Ne (g i (f i)) 0)","decl":"lemma prod_ne_zero_iff : f.prod g ≠ 0 ↔ ∀ i ∈ f.support, g i (f i) ≠ 0 := Finset.prod_ne_zero_iff\n\n"}
{"name":"DFinsupp.sumAddHom_single","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nφ : (i : ι) → AddMonoidHom (β i) γ\ni : ι\nx : β i\n⊢ Eq ((DFinsupp.sumAddHom φ) (DFinsupp.single i x)) ((φ i) x)","decl":"@[simp]\ntheorem sumAddHom_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (φ : ∀ i, β i →+ γ) (i)\n    (x : β i) : sumAddHom φ (single i x) = φ i x := by\n  dsimp [sumAddHom, single, Trunc.lift_mk]\n  rw [Multiset.toFinset_singleton, Finset.sum_singleton, Pi.single_eq_same]\n\n"}
{"name":"DFinsupp.sumAddHom_comp_single","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nf : (i : ι) → AddMonoidHom (β i) γ\ni : ι\n⊢ Eq ((DFinsupp.sumAddHom f).comp (DFinsupp.singleAddHom β i)) (f i)","decl":"@[simp]\ntheorem sumAddHom_comp_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)\n    (i : ι) : (sumAddHom f).comp (singleAddHom β i) = f i :=\n  AddMonoidHom.ext fun x => sumAddHom_single f i x\n\n"}
{"name":"DFinsupp.sumAddHom_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddZeroClass (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nφ : (i : ι) → AddMonoidHom (β i) γ\nf : DFinsupp fun i => β i\n⊢ Eq ((DFinsupp.sumAddHom φ) f) (f.sum fun x => ⇑(φ x))","decl":"/-- While we didn't need decidable instances to define it, we do to reduce it to a sum -/\ntheorem sumAddHom_apply [∀ i, AddZeroClass (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [AddCommMonoid γ] (φ : ∀ i, β i →+ γ) (f : Π₀ i, β i) : sumAddHom φ f = f.sum fun x => φ x := by\n  rcases f with ⟨f, s, hf⟩\n  change (∑ i ∈ _, _) = ∑ i ∈ _ with _, _\n  rw [Finset.sum_filter, Finset.sum_congr rfl]\n  intro i _\n  dsimp only [coe_mk', Subtype.coe_mk] at *\n  split_ifs with h\n  · rfl\n  · rw [not_not.mp h, AddMonoidHom.map_zero]\n\n"}
{"name":"DFinsupp.sumAddHom_comm","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι₁ : Type u_4\nι₂ : Type u_5\nβ₁ : ι₁ → Type u_1\nβ₂ : ι₂ → Type u_2\nγ : Type u_3\ninst✝⁴ : DecidableEq ι₁\ninst✝³ : DecidableEq ι₂\ninst✝² : (i : ι₁) → AddZeroClass (β₁ i)\ninst✝¹ : (i : ι₂) → AddZeroClass (β₂ i)\ninst✝ : AddCommMonoid γ\nf₁ : DFinsupp fun i => β₁ i\nf₂ : DFinsupp fun i => β₂ i\nh : (i : ι₁) → (j : ι₂) → AddMonoidHom (β₁ i) (AddMonoidHom (β₂ j) γ)\n⊢ Eq ((DFinsupp.sumAddHom fun i₂ => (DFinsupp.sumAddHom fun i₁ => h i₁ i₂) f₁) f₂) ((DFinsupp.sumAddHom fun i₁ => (DFinsupp.sumAddHom fun i₂ => (h i₁ i₂).flip) f₂) f₁)","decl":"theorem sumAddHom_comm {ι₁ ι₂ : Sort _} {β₁ : ι₁ → Type*} {β₂ : ι₂ → Type*} {γ : Type*}\n    [DecidableEq ι₁] [DecidableEq ι₂] [∀ i, AddZeroClass (β₁ i)] [∀ i, AddZeroClass (β₂ i)]\n    [AddCommMonoid γ] (f₁ : Π₀ i, β₁ i) (f₂ : Π₀ i, β₂ i) (h : ∀ i j, β₁ i →+ β₂ j →+ γ) :\n    sumAddHom (fun i₂ => sumAddHom (fun i₁ => h i₁ i₂) f₁) f₂ =\n      sumAddHom (fun i₁ => sumAddHom (fun i₂ => (h i₁ i₂).flip) f₂) f₁ := by\n  obtain ⟨⟨f₁, s₁, h₁⟩, ⟨f₂, s₂, h₂⟩⟩ := f₁, f₂\n  simp only [sumAddHom, AddMonoidHom.finset_sum_apply, Quotient.liftOn_mk, AddMonoidHom.coe_mk,\n    AddMonoidHom.flip_apply, Trunc.lift, toFun_eq_coe, ZeroHom.coe_mk, coe_mk']\n  exact Finset.sum_comm\n\n"}
{"name":"DFinsupp.liftAddHom_symm_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nF : AddMonoidHom (DFinsupp fun i => β i) γ\ni : ι\n⊢ Eq (DFinsupp.liftAddHom.symm F i) (F.comp (DFinsupp.singleAddHom β i))","decl":"/-- The `DFinsupp` version of `Finsupp.liftAddHom`,-/\n@[simps apply symm_apply]\ndef liftAddHom [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] :\n    (∀ i, β i →+ γ) ≃+ ((Π₀ i, β i) →+ γ) where\n  toFun := sumAddHom\n  invFun F i := F.comp (singleAddHom β i)\n  left_inv x := by ext; simp\n  right_inv ψ := by ext; simp\n  map_add' F G := by ext; simp\n\n-- Porting note: The elaborator is struggling with `liftAddHom`. Passing it `β` explicitly helps.\n-- This applies to roughly the remainder of the file.\n\n"}
{"name":"DFinsupp.liftAddHom_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nφ : (i : ι) → AddMonoidHom (β i) γ\n⊢ Eq (DFinsupp.liftAddHom φ) (DFinsupp.sumAddHom φ)","decl":"/-- The `DFinsupp` version of `Finsupp.liftAddHom`,-/\n@[simps apply symm_apply]\ndef liftAddHom [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] :\n    (∀ i, β i →+ γ) ≃+ ((Π₀ i, β i) →+ γ) where\n  toFun := sumAddHom\n  invFun F i := F.comp (singleAddHom β i)\n  left_inv x := by ext; simp\n  right_inv ψ := by ext; simp\n  map_add' F G := by ext; simp\n\n-- Porting note: The elaborator is struggling with `liftAddHom`. Passing it `β` explicitly helps.\n-- This applies to roughly the remainder of the file.\n\n"}
{"name":"DFinsupp.liftAddHom_singleAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddCommMonoid (β i)\n⊢ Eq (DFinsupp.liftAddHom (DFinsupp.singleAddHom β)) (AddMonoidHom.id (DFinsupp fun i => β i))","decl":"/-- The `DFinsupp` version of `Finsupp.liftAddHom_singleAddHom`,-/\ntheorem liftAddHom_singleAddHom [∀ i, AddCommMonoid (β i)] :\n    liftAddHom (β := β) (singleAddHom β) = AddMonoidHom.id (Π₀ i, β i) :=\n  (liftAddHom (β := β)).toEquiv.apply_eq_iff_eq_symm_apply.2 rfl\n\n"}
{"name":"DFinsupp.liftAddHom_apply_single","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nf : (i : ι) → AddMonoidHom (β i) γ\ni : ι\nx : β i\n⊢ Eq ((DFinsupp.liftAddHom f) (DFinsupp.single i x)) ((f i) x)","decl":"/-- The `DFinsupp` version of `Finsupp.liftAddHom_apply_single`,-/\ntheorem liftAddHom_apply_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)\n    (i : ι) (x : β i) : liftAddHom (β := β) f (single i x) = f i x := by simp\n\n"}
{"name":"DFinsupp.liftAddHom_comp_single","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\nf : (i : ι) → AddMonoidHom (β i) γ\ni : ι\n⊢ Eq ((DFinsupp.liftAddHom f).comp (DFinsupp.singleAddHom β i)) (f i)","decl":"/-- The `DFinsupp` version of `Finsupp.liftAddHom_comp_single`,-/\ntheorem liftAddHom_comp_single [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (f : ∀ i, β i →+ γ)\n    (i : ι) : (liftAddHom (β := β) f).comp (singleAddHom β i) = f i := by simp\n\n"}
{"name":"DFinsupp.comp_liftAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nδ : Type u_1\ninst✝² : (i : ι) → AddZeroClass (β i)\ninst✝¹ : AddCommMonoid γ\ninst✝ : AddCommMonoid δ\ng : AddMonoidHom γ δ\nf : (i : ι) → AddMonoidHom (β i) γ\n⊢ Eq (g.comp (DFinsupp.liftAddHom f)) (DFinsupp.liftAddHom fun a => g.comp (f a))","decl":"/-- The `DFinsupp` version of `Finsupp.comp_liftAddHom`,-/\ntheorem comp_liftAddHom {δ : Type*} [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ]\n    (g : γ →+ δ) (f : ∀ i, β i →+ γ) :\n    g.comp (liftAddHom (β := β) f) = liftAddHom (β := β) fun a => g.comp (f a) :=\n  (liftAddHom (β := β)).symm_apply_eq.1 <|\n    funext fun a => by\n      rw [liftAddHom_symm_apply, AddMonoidHom.comp_assoc, liftAddHom_comp_single]\n\n"}
{"name":"DFinsupp.sumAddHom_zero","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\n⊢ Eq (DFinsupp.sumAddHom fun i => 0) 0","decl":"@[simp]\ntheorem sumAddHom_zero [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] :\n    (sumAddHom fun i => (0 : β i →+ γ)) = 0 :=\n  map_zero (liftAddHom (β := β))\n\n"}
{"name":"DFinsupp.sumAddHom_add","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddZeroClass (β i)\ninst✝ : AddCommMonoid γ\ng h : (i : ι) → AddMonoidHom (β i) γ\n⊢ Eq (DFinsupp.sumAddHom fun i => HAdd.hAdd (g i) (h i)) (HAdd.hAdd (DFinsupp.sumAddHom g) (DFinsupp.sumAddHom h))","decl":"@[simp]\ntheorem sumAddHom_add [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] (g : ∀ i, β i →+ γ)\n    (h : ∀ i, β i →+ γ) : (sumAddHom fun i => g i + h i) = sumAddHom g + sumAddHom h :=\n  map_add (liftAddHom (β := β)) _ _\n\n"}
{"name":"DFinsupp.sumAddHom_singleAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → AddCommMonoid (β i)\n⊢ Eq (DFinsupp.sumAddHom (DFinsupp.singleAddHom β)) (AddMonoidHom.id (DFinsupp fun i => β i))","decl":"@[simp]\ntheorem sumAddHom_singleAddHom [∀ i, AddCommMonoid (β i)] :\n    sumAddHom (singleAddHom β) = AddMonoidHom.id _ :=\n  liftAddHom_singleAddHom\n\n"}
{"name":"DFinsupp.comp_sumAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nδ : Type u_1\ninst✝² : (i : ι) → AddZeroClass (β i)\ninst✝¹ : AddCommMonoid γ\ninst✝ : AddCommMonoid δ\ng : AddMonoidHom γ δ\nf : (i : ι) → AddMonoidHom (β i) γ\n⊢ Eq (g.comp (DFinsupp.sumAddHom f)) (DFinsupp.sumAddHom fun a => g.comp (f a))","decl":"theorem comp_sumAddHom {δ : Type*} [∀ i, AddZeroClass (β i)] [AddCommMonoid γ] [AddCommMonoid δ]\n    (g : γ →+ δ) (f : ∀ i, β i →+ γ) : g.comp (sumAddHom f) = sumAddHom fun a => g.comp (f a) :=\n  comp_liftAddHom _ _\n\n"}
{"name":"DFinsupp.sum_sub_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝³ : DecidableEq ι\ninst✝² : (i : ι) → AddGroup (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommGroup γ\nf g : DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_sub : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HSub.hSub b₁ b₂)) (HSub.hSub (h i b₁) (h i b₂))\n⊢ Eq ((HSub.hSub f g).sum h) (HSub.hSub (f.sum h) (g.sum h))","decl":"theorem sum_sub_index [∀ i, AddGroup (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] [AddCommGroup γ]\n    {f g : Π₀ i, β i} {h : ∀ i, β i → γ} (h_sub : ∀ i b₁ b₂, h i (b₁ - b₂) = h i b₁ - h i b₂) :\n    (f - g).sum h = f.sum h - g.sum h := by\n  have := (liftAddHom (β := β) fun a => AddMonoidHom.ofMapSub (h a) (h_sub a)).map_sub f g\n  rw [liftAddHom_apply, sumAddHom_apply, sumAddHom_apply, sumAddHom_apply] at this\n  exact this\n\n"}
{"name":"DFinsupp.prod_finset_sum_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nγ : Type w\nα : Type x\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\ns : Finset α\ng : α → DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 1\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HMul.hMul (h i b₁) (h i b₂))\n⊢ Eq (s.prod fun i => (g i).prod h) ((s.sum fun i => g i).prod h)","decl":"@[to_additive]\ntheorem prod_finset_sum_index {γ : Type w} {α : Type x} [∀ i, AddCommMonoid (β i)]\n    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {s : Finset α} {g : α → Π₀ i, β i}\n    {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :\n    (∏ i ∈ s, (g i).prod h) = (∑ i ∈ s, g i).prod h := by\n  classical\n  exact Finset.induction_on s (by simp [prod_zero_index])\n        (by simp +contextual [prod_add_index, h_zero, h_add])\n\n"}
{"name":"DFinsupp.sum_finset_sum_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nγ : Type w\nα : Type x\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\ns : Finset α\ng : α → DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 0\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h i b₁) (h i b₂))\n⊢ Eq (s.sum fun i => (g i).sum h) ((s.sum fun i => g i).sum h)","decl":"@[to_additive]\ntheorem prod_finset_sum_index {γ : Type w} {α : Type x} [∀ i, AddCommMonoid (β i)]\n    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {s : Finset α} {g : α → Π₀ i, β i}\n    {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :\n    (∏ i ∈ s, (g i).prod h) = (∑ i ∈ s, g i).prod h := by\n  classical\n  exact Finset.induction_on s (by simp [prod_zero_index])\n        (by simp +contextual [prod_add_index, h_zero, h_add])\n\n"}
{"name":"DFinsupp.prod_sum_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁶ : DecidableEq ι\nι₁ : Type u₁\ninst✝⁵ : DecidableEq ι₁\nβ₁ : ι₁ → Type v₁\ninst✝⁴ : (i₁ : ι₁) → Zero (β₁ i₁)\ninst✝³ : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : CommMonoid γ\nf : DFinsupp fun i₁ => β₁ i₁\ng : (i₁ : ι₁) → β₁ i₁ → DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 1\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HMul.hMul (h i b₁) (h i b₂))\n⊢ Eq ((f.sum g).prod h) (f.prod fun i b => (g i b).prod h)","decl":"@[to_additive]\ntheorem prod_sum_index {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]\n    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]\n    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {f : Π₀ i₁, β₁ i₁}\n    {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :\n    (f.sum g).prod h = f.prod fun i b => (g i b).prod h :=\n  (prod_finset_sum_index h_zero h_add).symm\n\n"}
{"name":"DFinsupp.sum_sum_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁶ : DecidableEq ι\nι₁ : Type u₁\ninst✝⁵ : DecidableEq ι₁\nβ₁ : ι₁ → Type v₁\ninst✝⁴ : (i₁ : ι₁) → Zero (β₁ i₁)\ninst✝³ : (i : ι₁) → (x : β₁ i) → Decidable (Ne x 0)\ninst✝² : (i : ι) → AddCommMonoid (β i)\ninst✝¹ : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝ : AddCommMonoid γ\nf : DFinsupp fun i₁ => β₁ i₁\ng : (i₁ : ι₁) → β₁ i₁ → DFinsupp fun i => β i\nh : (i : ι) → β i → γ\nh_zero : ∀ (i : ι), Eq (h i 0) 0\nh_add : ∀ (i : ι) (b₁ b₂ : β i), Eq (h i (HAdd.hAdd b₁ b₂)) (HAdd.hAdd (h i b₁) (h i b₂))\n⊢ Eq ((f.sum g).sum h) (f.sum fun i b => (g i b).sum h)","decl":"@[to_additive]\ntheorem prod_sum_index {ι₁ : Type u₁} [DecidableEq ι₁] {β₁ : ι₁ → Type v₁} [∀ i₁, Zero (β₁ i₁)]\n    [∀ (i) (x : β₁ i), Decidable (x ≠ 0)] [∀ i, AddCommMonoid (β i)]\n    [∀ (i) (x : β i), Decidable (x ≠ 0)] [CommMonoid γ] {f : Π₀ i₁, β₁ i₁}\n    {g : ∀ i₁, β₁ i₁ → Π₀ i, β i} {h : ∀ i, β i → γ} (h_zero : ∀ i, h i 0 = 1)\n    (h_add : ∀ i b₁ b₂, h i (b₁ + b₂) = h i b₁ * h i b₂) :\n    (f.sum g).prod h = f.prod fun i b => (g i b).prod h :=\n  (prod_finset_sum_index h_zero h_add).symm\n\n"}
{"name":"DFinsupp.sum_single","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ninst✝ : (i : ι) → (x : β i) → Decidable (Ne x 0)\nf : DFinsupp fun i => β i\n⊢ Eq (f.sum DFinsupp.single) f","decl":"@[simp]\ntheorem sum_single [∀ i, AddCommMonoid (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)] {f : Π₀ i, β i} :\n    f.sum single = f := by\n  have := DFunLike.congr_fun (liftAddHom_singleAddHom (β := β)) f\n  rw [liftAddHom_apply, sumAddHom_apply] at this\n  exact this\n\n"}
{"name":"DFinsupp.prod_subtypeDomain_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : CommMonoid γ\nv : DFinsupp fun i => β i\np : ι → Prop\ninst✝ : DecidablePred p\nh : (i : ι) → β i → γ\nhp : ∀ (x : ι), Membership.mem v.support x → p x\n⊢ Eq ((DFinsupp.subtypeDomain p v).prod fun i b => h (↑i) b) (v.prod h)","decl":"@[to_additive]\ntheorem prod_subtypeDomain_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {v : Π₀ i, β i} {p : ι → Prop} [DecidablePred p] {h : ∀ i, β i → γ}\n    (hp : ∀ x ∈ v.support, p x) : (v.subtypeDomain p).prod (fun i b => h i b) = v.prod h := by\n  refine Finset.prod_bij (fun p _ ↦ p) ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"DFinsupp.sum_subtypeDomain_index","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nγ : Type w\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : AddCommMonoid γ\nv : DFinsupp fun i => β i\np : ι → Prop\ninst✝ : DecidablePred p\nh : (i : ι) → β i → γ\nhp : ∀ (x : ι), Membership.mem v.support x → p x\n⊢ Eq ((DFinsupp.subtypeDomain p v).sum fun i b => h (↑i) b) (v.sum h)","decl":"@[to_additive]\ntheorem prod_subtypeDomain_index [∀ i, Zero (β i)] [∀ (i) (x : β i), Decidable (x ≠ 0)]\n    [CommMonoid γ] {v : Π₀ i, β i} {p : ι → Prop} [DecidablePred p] {h : ∀ i, β i → γ}\n    (hp : ∀ x ∈ v.support, p x) : (v.subtypeDomain p).prod (fun i b => h i b) = v.prod h := by\n  refine Finset.prod_bij (fun p _ ↦ p) ?_ ?_ ?_ ?_ <;> aesop\n\n"}
{"name":"DFinsupp.subtypeDomain_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"γ : Type w\nι : Type u_1\nβ : ι → Type v\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\ns : Finset γ\nh : γ → DFinsupp fun i => β i\np : ι → Prop\ninst✝ : DecidablePred p\n⊢ Eq (DFinsupp.subtypeDomain p (s.sum fun c => h c)) (s.sum fun c => DFinsupp.subtypeDomain p (h c))","decl":"theorem subtypeDomain_sum {ι} {β : ι → Type v} [∀ i, AddCommMonoid (β i)] {s : Finset γ}\n    {h : γ → Π₀ i, β i} {p : ι → Prop} [DecidablePred p] :\n    (∑ c ∈ s, h c).subtypeDomain p = ∑ c ∈ s, (h c).subtypeDomain p :=\n  map_sum (subtypeDomainAddMonoidHom β p) _ s\n\n"}
{"name":"DFinsupp.subtypeDomain_finsupp_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"γ : Type w\nι : Type u_1\nβ : ι → Type v\nδ : γ → Type x\ninst✝⁴ : DecidableEq γ\ninst✝³ : (c : γ) → Zero (δ c)\ninst✝² : (c : γ) → (x : δ c) → Decidable (Ne x 0)\ninst✝¹ : (i : ι) → AddCommMonoid (β i)\np : ι → Prop\ninst✝ : DecidablePred p\ns : DFinsupp fun c => δ c\nh : (c : γ) → δ c → DFinsupp fun i => β i\n⊢ Eq (DFinsupp.subtypeDomain p (s.sum h)) (s.sum fun c d => DFinsupp.subtypeDomain p (h c d))","decl":"theorem subtypeDomain_finsupp_sum {ι} {β : ι → Type v} {δ : γ → Type x} [DecidableEq γ]\n    [∀ c, Zero (δ c)]  [∀ (c) (x : δ c), Decidable (x ≠ 0)]\n    [∀ i, AddCommMonoid (β i)] {p : ι → Prop} [DecidablePred p]\n    {s : Π₀ c, δ c} {h : ∀ c, δ c → Π₀ i, β i} :\n    (s.sum h).subtypeDomain p = s.sum fun c d => (h c d).subtypeDomain p :=\n  subtypeDomain_sum\n\n"}
{"name":"MonoidHom.coe_dfinsupp_prod","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : Monoid R\ninst✝ : CommMonoid S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → MonoidHom R S\n⊢ Eq (⇑(f.prod g)) (f.prod fun a b => ⇑(g a b))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_dfinsupp_prod [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S) :\n    ⇑(f.prod g) = f.prod fun a b => ⇑(g a b) :=\n  coe_finset_prod _ _\n\n"}
{"name":"AddMonoidHom.coe_dfinsupp_sum","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : AddMonoid R\ninst✝ : AddCommMonoid S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → AddMonoidHom R S\n⊢ Eq (⇑(f.sum g)) (f.sum fun a b => ⇑(g a b))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_dfinsupp_prod [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S) :\n    ⇑(f.prod g) = f.prod fun a b => ⇑(g a b) :=\n  coe_finset_prod _ _\n\n"}
{"name":"MonoidHom.dfinsupp_prod_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : Monoid R\ninst✝ : CommMonoid S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → MonoidHom R S\nr : R\n⊢ Eq ((f.prod g) r) (f.prod fun a b => (g a b) r)","decl":"@[to_additive]\ntheorem dfinsupp_prod_apply [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S)\n    (r : R) : (f.prod g) r = f.prod fun a b => (g a b) r :=\n  finset_prod_apply _ _ _\n\n"}
{"name":"AddMonoidHom.dfinsupp_sum_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝⁴ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝³ : (i : ι) → Zero (β i)\ninst✝² : (i : ι) → (x : β i) → Decidable (Ne x 0)\ninst✝¹ : AddMonoid R\ninst✝ : AddCommMonoid S\nf : DFinsupp fun i => β i\ng : (i : ι) → β i → AddMonoidHom R S\nr : R\n⊢ Eq ((f.sum g) r) (f.sum fun a b => (g a b) r)","decl":"@[to_additive]\ntheorem dfinsupp_prod_apply [Monoid R] [CommMonoid S] (f : Π₀ i, β i) (g : ∀ i, β i → R →* S)\n    (r : R) : (f.prod g) r = f.prod fun a b => (g a b) r :=\n  finset_prod_apply _ _ _\n\n"}
{"name":"AddMonoidHom.map_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝² : AddCommMonoid R\ninst✝¹ : AddCommMonoid S\ninst✝ : (i : ι) → AddZeroClass (β i)\nh : AddMonoidHom R S\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) R\n⊢ Eq (h ((DFinsupp.sumAddHom g) f)) ((DFinsupp.sumAddHom fun i => h.comp (g i)) f)","decl":"@[simp]\ntheorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]\n    (h : R →+ S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.comp (g i)) f :=\n  DFunLike.congr_fun (comp_liftAddHom h g) f\n\n"}
{"name":"AddMonoidHom.dfinsupp_sumAddHom_apply","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝² : AddZeroClass R\ninst✝¹ : AddCommMonoid S\ninst✝ : (i : ι) → AddZeroClass (β i)\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) (AddMonoidHom R S)\nr : R\n⊢ Eq (((DFinsupp.sumAddHom g) f) r) ((DFinsupp.sumAddHom fun i => (AddMonoidHom.eval r).comp (g i)) f)","decl":"theorem dfinsupp_sumAddHom_apply [AddZeroClass R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]\n    (f : Π₀ i, β i) (g : ∀ i, β i →+ R →+ S) (r : R) :\n    (sumAddHom g f) r = sumAddHom (fun i => (eval r).comp (g i)) f :=\n  map_dfinsupp_sumAddHom (eval r) f g\n\n"}
{"name":"AddMonoidHom.coe_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝² : AddZeroClass R\ninst✝¹ : AddCommMonoid S\ninst✝ : (i : ι) → AddZeroClass (β i)\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) (AddMonoidHom R S)\n⊢ Eq (⇑((DFinsupp.sumAddHom g) f)) ((DFinsupp.sumAddHom fun i => (AddMonoidHom.coeFn R S).comp (g i)) f)","decl":"@[simp, norm_cast]\ntheorem coe_dfinsupp_sumAddHom [AddZeroClass R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]\n    (f : Π₀ i, β i) (g : ∀ i, β i →+ R →+ S) :\n    ⇑(sumAddHom g f) = sumAddHom (fun i => (coeFn R S).comp (g i)) f :=\n  map_dfinsupp_sumAddHom (coeFn R S) f g\n\n"}
{"name":"RingHom.map_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : (i : ι) → AddZeroClass (β i)\nh : RingHom R S\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) R\n⊢ Eq (h ((DFinsupp.sumAddHom g) f)) ((DFinsupp.sumAddHom fun i => h.toAddMonoidHom.comp (g i)) f)","decl":"@[simp]\ntheorem map_dfinsupp_sumAddHom [NonAssocSemiring R] [NonAssocSemiring S] [∀ i, AddZeroClass (β i)]\n    (h : R →+* S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f :=\n  DFunLike.congr_fun (comp_liftAddHom h.toAddMonoidHom g) f\n\n"}
{"name":"AddEquiv.map_dfinsupp_sumAddHom","module":"Mathlib.Data.DFinsupp.BigOperators","initialProofState":"ι : Type u\nβ : ι → Type v\ninst✝³ : DecidableEq ι\nR : Type u_1\nS : Type u_2\ninst✝² : AddCommMonoid R\ninst✝¹ : AddCommMonoid S\ninst✝ : (i : ι) → AddZeroClass (β i)\nh : AddEquiv R S\nf : DFinsupp fun i => β i\ng : (i : ι) → AddMonoidHom (β i) R\n⊢ Eq (h ((DFinsupp.sumAddHom g) f)) ((DFinsupp.sumAddHom fun i => h.toAddMonoidHom.comp (g i)) f)","decl":"@[simp]\ntheorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [∀ i, AddZeroClass (β i)]\n    (h : R ≃+ S) (f : Π₀ i, β i) (g : ∀ i, β i →+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f :=\n  DFunLike.congr_fun (comp_liftAddHom h.toAddMonoidHom g) f\n\n"}
