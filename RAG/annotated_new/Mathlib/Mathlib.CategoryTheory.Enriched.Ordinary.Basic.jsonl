{"name":"CategoryTheory.EnrichedOrdinaryCategory.homEquiv_id","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.EnrichedOrdinaryCategory V C\nX : C\n⊢ Eq (CategoryTheory.EnrichedOrdinaryCategory.homEquiv (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.eId V X)","decl":"/-- An enriched ordinary category is a category `C` that is also enriched\nover a category `V` in such a way that morphisms `X ⟶ Y` in `C` identify\nto morphisms `𝟙_ V ⟶ (X ⟶[V] Y)` in `V`. -/\nclass EnrichedOrdinaryCategory extends EnrichedCategory V C where\n  /-- morphisms `X ⟶ Y` in the category identify morphisms\n    `𝟙_ V ⟶ (X ⟶[V] Y)` in `V` -/\n  homEquiv {X Y : C} : (X ⟶ Y) ≃ (𝟙_ V ⟶ (X ⟶[V] Y))\n  homEquiv_id (X : C) : homEquiv (𝟙 X) = eId V X := by aesop_cat\n  homEquiv_comp {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    homEquiv (f ≫ g) = (λ_ _).inv ≫ (homEquiv f ⊗ homEquiv g) ≫\n      eComp V X Y Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedOrdinaryCategory.homEquiv_comp","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.EnrichedOrdinaryCategory.homEquiv (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.EnrichedOrdinaryCategory.homEquiv f) (CategoryTheory.EnrichedOrdinaryCategory.homEquiv g)) (CategoryTheory.eComp V X Y Z)))","decl":"/-- An enriched ordinary category is a category `C` that is also enriched\nover a category `V` in such a way that morphisms `X ⟶ Y` in `C` identify\nto morphisms `𝟙_ V ⟶ (X ⟶[V] Y)` in `V`. -/\nclass EnrichedOrdinaryCategory extends EnrichedCategory V C where\n  /-- morphisms `X ⟶ Y` in the category identify morphisms\n    `𝟙_ V ⟶ (X ⟶[V] Y)` in `V` -/\n  homEquiv {X Y : C} : (X ⟶ Y) ≃ (𝟙_ V ⟶ (X ⟶[V] Y))\n  homEquiv_id (X : C) : homEquiv (𝟙 X) = eId V X := by aesop_cat\n  homEquiv_comp {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    homEquiv (f ≫ g) = (λ_ _).inv ≫ (homEquiv f ⊗ homEquiv g) ≫\n      eComp V X Y Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.eHomEquiv_id","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX : C\n⊢ Eq ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.eId V X)","decl":"@[simp]\nlemma eHomEquiv_id (X : C) : eHomEquiv V (𝟙 X) = eId V X :=\n  EnrichedOrdinaryCategory.homEquiv_id _\n\n"}
{"name":"CategoryTheory.eHomEquiv_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.eHomEquiv V) f) ((CategoryTheory.eHomEquiv V) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) h)))","decl":"@[reassoc]\nlemma eHomEquiv_comp {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    eHomEquiv V (f ≫ g) = (λ_ _).inv ≫ (eHomEquiv V f ⊗ eHomEquiv V g) ≫ eComp V X Y Z :=\n  EnrichedOrdinaryCategory.homEquiv_comp _ _\n\n"}
{"name":"CategoryTheory.eHomEquiv_comp","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq ((CategoryTheory.eHomEquiv V) (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom ((CategoryTheory.eHomEquiv V) f) ((CategoryTheory.eHomEquiv V) g)) (CategoryTheory.eComp V X Y Z)))","decl":"@[reassoc]\nlemma eHomEquiv_comp {X Y Z : C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    eHomEquiv V (f ≫ g) = (λ_ _).inv ≫ (eHomEquiv V f ⊗ eHomEquiv V g) ≫ eComp V X Y Z :=\n  EnrichedOrdinaryCategory.homEquiv_comp _ _\n\n"}
{"name":"CategoryTheory.eHomWhiskerRight_id","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.eHomWhiskerRight V (CategoryTheory.CategoryStruct.id X) Y) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[simp]\nlemma eHomWhiskerRight_id (X Y : C) : eHomWhiskerRight V (𝟙 X) Y = 𝟙 _ := by\n  simp [eHomWhiskerRight]\n\n"}
{"name":"CategoryTheory.eHomWhiskerRight_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' X'' : C\nf : Quiver.Hom X X'\nf' : Quiver.Hom X' X''\nY : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V (CategoryTheory.CategoryStruct.comp f f') Y) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f' Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f Y) h))","decl":"@[simp, reassoc]\nlemma eHomWhiskerRight_comp {X X' X'' : C} (f : X ⟶ X') (f' : X' ⟶ X'') (Y : C) :\n    eHomWhiskerRight V (f ≫ f') Y = eHomWhiskerRight V f' Y ≫ eHomWhiskerRight V f Y := by\n  dsimp [eHomWhiskerRight]\n  rw [assoc, assoc, eHomEquiv_comp, comp_whiskerRight_assoc, comp_whiskerRight_assoc, ← e_assoc',\n    tensorHom_def', comp_whiskerRight_assoc, id_whiskerLeft, comp_whiskerRight_assoc,\n    ← comp_whiskerRight_assoc, Iso.inv_hom_id, id_whiskerRight_assoc,\n    comp_whiskerRight_assoc, leftUnitor_inv_whiskerRight_assoc,\n    ← associator_inv_naturality_left_assoc, Iso.inv_hom_id_assoc,\n    ← whisker_exchange_assoc, id_whiskerLeft_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eHomWhiskerRight_comp","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' X'' : C\nf : Quiver.Hom X X'\nf' : Quiver.Hom X' X''\nY : C\n⊢ Eq (CategoryTheory.eHomWhiskerRight V (CategoryTheory.CategoryStruct.comp f f') Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f' Y) (CategoryTheory.eHomWhiskerRight V f Y))","decl":"@[simp, reassoc]\nlemma eHomWhiskerRight_comp {X X' X'' : C} (f : X ⟶ X') (f' : X' ⟶ X'') (Y : C) :\n    eHomWhiskerRight V (f ≫ f') Y = eHomWhiskerRight V f' Y ≫ eHomWhiskerRight V f Y := by\n  dsimp [eHomWhiskerRight]\n  rw [assoc, assoc, eHomEquiv_comp, comp_whiskerRight_assoc, comp_whiskerRight_assoc, ← e_assoc',\n    tensorHom_def', comp_whiskerRight_assoc, id_whiskerLeft, comp_whiskerRight_assoc,\n    ← comp_whiskerRight_assoc, Iso.inv_hom_id, id_whiskerRight_assoc,\n    comp_whiskerRight_assoc, leftUnitor_inv_whiskerRight_assoc,\n    ← associator_inv_naturality_left_assoc, Iso.inv_hom_id_assoc,\n    ← whisker_exchange_assoc, id_whiskerLeft_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eComp_eHomWhiskerRight_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' : C\nf : Quiver.Hom X X'\nY Z✝ : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X' Y Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f Z✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerRight V f Y) (CategoryTheory.EnrichedCategory.Hom Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) h))","decl":"/-- Whiskering commutes with the enriched composition. -/\n@[reassoc]\nlemma eComp_eHomWhiskerRight {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    eComp V X' Y Z ≫ eHomWhiskerRight V f Z =\n      eHomWhiskerRight V f Y ▷ _ ≫ eComp V X Y Z := by\n  dsimp [eHomWhiskerRight]\n  rw [leftUnitor_inv_naturality_assoc, whisker_exchange_assoc]\n  simp [e_assoc']\n\n"}
{"name":"CategoryTheory.eComp_eHomWhiskerRight","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' : C\nf : Quiver.Hom X X'\nY Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X' Y Z) (CategoryTheory.eHomWhiskerRight V f Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerRight V f Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.eComp V X Y Z))","decl":"/-- Whiskering commutes with the enriched composition. -/\n@[reassoc]\nlemma eComp_eHomWhiskerRight {X X' : C} (f : X ⟶ X') (Y Z : C) :\n    eComp V X' Y Z ≫ eHomWhiskerRight V f Z =\n      eHomWhiskerRight V f Y ▷ _ ≫ eComp V X Y Z := by\n  dsimp [eHomWhiskerRight]\n  rw [leftUnitor_inv_naturality_assoc, whisker_exchange_assoc]\n  simp [e_assoc']\n\n"}
{"name":"CategoryTheory.eHomWhiskerLeft_id","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.eHomWhiskerLeft V X (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[simp]\nlemma eHomWhiskerLeft_id (X Y : C) : eHomWhiskerLeft V X (𝟙 Y) = 𝟙 _ := by\n  simp [eHomWhiskerLeft]\n\n"}
{"name":"CategoryTheory.eHomWhiskerLeft_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y' Y'' : C\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X (CategoryTheory.CategoryStruct.comp g g')) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X g') h))","decl":"@[simp, reassoc]\nlemma eHomWhiskerLeft_comp (X : C) {Y Y' Y'' : C} (g : Y ⟶ Y') (g' : Y' ⟶ Y'') :\n    eHomWhiskerLeft V X (g ≫ g') = eHomWhiskerLeft V X g ≫ eHomWhiskerLeft V X g' := by\n  dsimp [eHomWhiskerLeft]\n  rw [assoc, assoc, eHomEquiv_comp, MonoidalCategory.whiskerLeft_comp_assoc,\n    MonoidalCategory.whiskerLeft_comp_assoc, ← e_assoc, tensorHom_def,\n    MonoidalCategory.whiskerRight_id_assoc, MonoidalCategory.whiskerLeft_comp_assoc,\n    MonoidalCategory.whiskerLeft_comp_assoc, MonoidalCategory.whiskerLeft_comp_assoc,\n    whiskerLeft_rightUnitor_assoc, whiskerLeft_rightUnitor_inv_assoc,\n    triangle_assoc_comp_left_inv_assoc, MonoidalCategory.whiskerRight_id_assoc,\n    Iso.hom_inv_id_assoc, Iso.inv_hom_id_assoc,\n    associator_inv_naturality_right_assoc, Iso.hom_inv_id_assoc,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eHomWhiskerLeft_comp","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y' Y'' : C\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\n⊢ Eq (CategoryTheory.eHomWhiskerLeft V X (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X g) (CategoryTheory.eHomWhiskerLeft V X g'))","decl":"@[simp, reassoc]\nlemma eHomWhiskerLeft_comp (X : C) {Y Y' Y'' : C} (g : Y ⟶ Y') (g' : Y' ⟶ Y'') :\n    eHomWhiskerLeft V X (g ≫ g') = eHomWhiskerLeft V X g ≫ eHomWhiskerLeft V X g' := by\n  dsimp [eHomWhiskerLeft]\n  rw [assoc, assoc, eHomEquiv_comp, MonoidalCategory.whiskerLeft_comp_assoc,\n    MonoidalCategory.whiskerLeft_comp_assoc, ← e_assoc, tensorHom_def,\n    MonoidalCategory.whiskerRight_id_assoc, MonoidalCategory.whiskerLeft_comp_assoc,\n    MonoidalCategory.whiskerLeft_comp_assoc, MonoidalCategory.whiskerLeft_comp_assoc,\n    whiskerLeft_rightUnitor_assoc, whiskerLeft_rightUnitor_inv_assoc,\n    triangle_assoc_comp_left_inv_assoc, MonoidalCategory.whiskerRight_id_assoc,\n    Iso.hom_inv_id_assoc, Iso.inv_hom_id_assoc,\n    associator_inv_naturality_right_assoc, Iso.hom_inv_id_assoc,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eComp_eHomWhiskerLeft","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z Z' : C\ng : Quiver.Hom Z Z'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (CategoryTheory.eHomWhiskerLeft V X g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eHomWhiskerLeft V Y g)) (CategoryTheory.eComp V X Y Z'))","decl":"/-- Whiskering commutes with the enriched composition. -/\n@[reassoc]\nlemma eComp_eHomWhiskerLeft (X Y : C) {Z Z' : C} (g : Z ⟶ Z') :\n    eComp V X Y Z ≫ eHomWhiskerLeft V X g =\n      _ ◁ eHomWhiskerLeft V Y g ≫ eComp V X Y Z' := by\n  dsimp [eHomWhiskerLeft]\n  rw [rightUnitor_inv_naturality_assoc, ← whisker_exchange_assoc]\n  simp [e_assoc']\n\n"}
{"name":"CategoryTheory.eComp_eHomWhiskerLeft_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Z✝ Z' : C\ng : Quiver.Hom Z✝ Z'\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eHomWhiskerLeft V Y g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z') h))","decl":"/-- Whiskering commutes with the enriched composition. -/\n@[reassoc]\nlemma eComp_eHomWhiskerLeft (X Y : C) {Z Z' : C} (g : Z ⟶ Z') :\n    eComp V X Y Z ≫ eHomWhiskerLeft V X g =\n      _ ◁ eHomWhiskerLeft V Y g ≫ eComp V X Y Z' := by\n  dsimp [eHomWhiskerLeft]\n  rw [rightUnitor_inv_naturality_assoc, ← whisker_exchange_assoc]\n  simp [e_assoc']\n\n"}
{"name":"CategoryTheory.eHom_whisker_cancel_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y₁ Z✝ : C\nα : CategoryTheory.Iso Y Y₁\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerLeft V X α.hom) (CategoryTheory.EnrichedCategory.Hom Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y₁) (CategoryTheory.eHomWhiskerRight V α.inv Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y₁ Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) h)","decl":"/-- Given an isomorphism `α : Y ≅ Y₁` in C, the enriched composition map\n`eComp V X Y Z : (X ⟶[V] Y) ⊗ (Y ⟶[V] Z) ⟶ (X ⟶[V] Z)` factors through the `V`\nobject `(X ⟶[V] Y₁) ⊗ (Y₁ ⟶[V] Z)` via the map defined by whiskering in the\nmiddle with `α.hom` and `α.inv`. -/\n@[reassoc]\nlemma eHom_whisker_cancel {X Y Y₁ Z : C} (α : Y  ≅ Y₁) :\n    eHomWhiskerLeft V X α.hom ▷ _ ≫ _ ◁ eHomWhiskerRight V α.inv Z ≫\n      eComp V X Y₁ Z = eComp V X Y Z := by\n  dsimp [eHomWhiskerLeft, eHomWhiskerRight]\n  simp only [MonoidalCategory.whiskerLeft_comp_assoc, whisker_assoc_symm,\n    triangle_assoc_comp_left_inv_assoc, e_assoc', assoc]\n  simp only [← comp_whiskerRight_assoc]\n  change (eHomWhiskerLeft V X α.hom ≫ eHomWhiskerLeft V X α.inv) ▷ _ ≫ _ = _\n  simp [← eHomWhiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.eHom_whisker_cancel","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y₁ Z : C\nα : CategoryTheory.Iso Y Y₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerLeft V X α.hom) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y₁) (CategoryTheory.eHomWhiskerRight V α.inv Z)) (CategoryTheory.eComp V X Y₁ Z))) (CategoryTheory.eComp V X Y Z)","decl":"/-- Given an isomorphism `α : Y ≅ Y₁` in C, the enriched composition map\n`eComp V X Y Z : (X ⟶[V] Y) ⊗ (Y ⟶[V] Z) ⟶ (X ⟶[V] Z)` factors through the `V`\nobject `(X ⟶[V] Y₁) ⊗ (Y₁ ⟶[V] Z)` via the map defined by whiskering in the\nmiddle with `α.hom` and `α.inv`. -/\n@[reassoc]\nlemma eHom_whisker_cancel {X Y Y₁ Z : C} (α : Y  ≅ Y₁) :\n    eHomWhiskerLeft V X α.hom ▷ _ ≫ _ ◁ eHomWhiskerRight V α.inv Z ≫\n      eComp V X Y₁ Z = eComp V X Y Z := by\n  dsimp [eHomWhiskerLeft, eHomWhiskerRight]\n  simp only [MonoidalCategory.whiskerLeft_comp_assoc, whisker_assoc_symm,\n    triangle_assoc_comp_left_inv_assoc, e_assoc', assoc]\n  simp only [← comp_whiskerRight_assoc]\n  change (eHomWhiskerLeft V X α.hom ≫ eHomWhiskerLeft V X α.inv) ▷ _ ≫ _ = _\n  simp [← eHomWhiskerLeft_comp]\n\n"}
{"name":"CategoryTheory.eHom_whisker_cancel_inv","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y₁ Z : C\nα : CategoryTheory.Iso Y Y₁\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerLeft V X α.inv) (CategoryTheory.EnrichedCategory.Hom Y₁ Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eHomWhiskerRight V α.hom Z)) (CategoryTheory.eComp V X Y Z))) (CategoryTheory.eComp V X Y₁ Z)","decl":"@[reassoc]\nlemma eHom_whisker_cancel_inv {X Y Y₁ Z : C} (α : Y  ≅ Y₁) :\n    eHomWhiskerLeft V X α.inv ▷ _ ≫ _ ◁ eHomWhiskerRight V α.hom Z ≫\n      eComp V X Y Z = eComp V X Y₁ Z := eHom_whisker_cancel V α.symm\n\n"}
{"name":"CategoryTheory.eHom_whisker_cancel_inv_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX Y Y₁ Z✝ : C\nα : CategoryTheory.Iso Y Y₁\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eHomWhiskerLeft V X α.inv) (CategoryTheory.EnrichedCategory.Hom Y₁ Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eHomWhiskerRight V α.hom Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y₁ Z✝) h)","decl":"@[reassoc]\nlemma eHom_whisker_cancel_inv {X Y Y₁ Z : C} (α : Y  ≅ Y₁) :\n    eHomWhiskerLeft V X α.inv ▷ _ ≫ _ ◁ eHomWhiskerRight V α.hom Z ≫\n      eComp V X Y Z = eComp V X Y₁ Z := eHom_whisker_cancel V α.symm\n\n"}
{"name":"CategoryTheory.eHom_whisker_exchange","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' Y Y' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X' g) (CategoryTheory.eHomWhiskerRight V f Y')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f Y) (CategoryTheory.eHomWhiskerLeft V X g))","decl":"@[reassoc]\nlemma eHom_whisker_exchange {X X' Y Y' : C} (f : X ⟶ X') (g : Y ⟶ Y') :\n    eHomWhiskerLeft V X' g ≫ eHomWhiskerRight V f Y' =\n      eHomWhiskerRight V f Y ≫ eHomWhiskerLeft V X g := by\n  dsimp [eHomWhiskerLeft, eHomWhiskerRight]\n  rw [assoc, assoc, assoc, assoc, leftUnitor_inv_naturality_assoc,\n    whisker_exchange_assoc, ← e_assoc, leftUnitor_tensor_inv_assoc,\n    associator_inv_naturality_left_assoc, Iso.hom_inv_id_assoc,\n    ← comp_whiskerRight_assoc, whisker_exchange_assoc,\n    MonoidalCategory.whiskerRight_id_assoc, assoc, Iso.inv_hom_id_assoc,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eHom_whisker_exchange_assoc","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX X' Y Y' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom Y Y'\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X' g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f Y') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerRight V f Y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eHomWhiskerLeft V X g) h))","decl":"@[reassoc]\nlemma eHom_whisker_exchange {X X' Y Y' : C} (f : X ⟶ X') (g : Y ⟶ Y') :\n    eHomWhiskerLeft V X' g ≫ eHomWhiskerRight V f Y' =\n      eHomWhiskerRight V f Y ≫ eHomWhiskerLeft V X g := by\n  dsimp [eHomWhiskerLeft, eHomWhiskerRight]\n  rw [assoc, assoc, assoc, assoc, leftUnitor_inv_naturality_assoc,\n    whisker_exchange_assoc, ← e_assoc, leftUnitor_tensor_inv_assoc,\n    associator_inv_naturality_left_assoc, Iso.hom_inv_id_assoc,\n    ← comp_whiskerRight_assoc, whisker_exchange_assoc,\n    MonoidalCategory.whiskerRight_id_assoc, assoc, Iso.inv_hom_id_assoc,\n    whisker_exchange_assoc, MonoidalCategory.whiskerRight_id_assoc, Iso.inv_hom_id_assoc]\n\n"}
{"name":"CategoryTheory.eHomFunctor_obj_map","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX : Opposite C\nX✝ Y✝ : C\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.eHomFunctor V C).obj X).map φ) (CategoryTheory.eHomWhiskerLeft V (Opposite.unop X) φ)","decl":"variable (C) in\n/-- The bifunctor `Cᵒᵖ ⥤ C ⥤ V` which sends `X : Cᵒᵖ` and `Y : C` to `X ⟶[V] Y`. -/\n@[simps]\ndef eHomFunctor : Cᵒᵖ ⥤ C ⥤ V where\n  obj X :=\n    { obj := fun Y => X.unop ⟶[V] Y\n      map := fun φ => eHomWhiskerLeft V X.unop φ }\n  map φ :=\n    { app := fun Y => eHomWhiskerRight V φ.unop Y }\n\n"}
{"name":"CategoryTheory.eHomFunctor_map_app","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX✝ Y✝ : Opposite C\nφ : Quiver.Hom X✝ Y✝\nY : C\n⊢ Eq (((CategoryTheory.eHomFunctor V C).map φ).app Y) (CategoryTheory.eHomWhiskerRight V φ.unop Y)","decl":"variable (C) in\n/-- The bifunctor `Cᵒᵖ ⥤ C ⥤ V` which sends `X : Cᵒᵖ` and `Y : C` to `X ⟶[V] Y`. -/\n@[simps]\ndef eHomFunctor : Cᵒᵖ ⥤ C ⥤ V where\n  obj X :=\n    { obj := fun Y => X.unop ⟶[V] Y\n      map := fun φ => eHomWhiskerLeft V X.unop φ }\n  map φ :=\n    { app := fun Y => eHomWhiskerRight V φ.unop Y }\n\n"}
{"name":"CategoryTheory.eHomFunctor_obj_obj","module":"Mathlib.CategoryTheory.Enriched.Ordinary.Basic","initialProofState":"V : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnrichedOrdinaryCategory V C\nX : Opposite C\nY : C\n⊢ Eq (((CategoryTheory.eHomFunctor V C).obj X).obj Y) (CategoryTheory.EnrichedCategory.Hom (Opposite.unop X) Y)","decl":"variable (C) in\n/-- The bifunctor `Cᵒᵖ ⥤ C ⥤ V` which sends `X : Cᵒᵖ` and `Y : C` to `X ⟶[V] Y`. -/\n@[simps]\ndef eHomFunctor : Cᵒᵖ ⥤ C ⥤ V where\n  obj X :=\n    { obj := fun Y => X.unop ⟶[V] Y\n      map := fun φ => eHomWhiskerLeft V X.unop φ }\n  map φ :=\n    { app := fun Y => eHomWhiskerRight V φ.unop Y }\n\n"}
