{"name":"Pi.vadd_def'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝ : (i : ι) → VAdd (α i) (β i)\ns : (i : ι) → α i\nx : (i : ι) → β i\n⊢ Eq (HVAdd.hVAdd s x) fun i => HVAdd.hVAdd (s i) (x i)","decl":"@[to_additive]\nlemma smul_def' [∀ i, SMul (α i) (β i)] (s : ∀ i, α i) (x : ∀ i, β i) : s • x = fun i ↦ s i • x i :=\n  rfl\n\n"}
{"name":"Pi.smul_def'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝ : (i : ι) → SMul (α i) (β i)\ns : (i : ι) → α i\nx : (i : ι) → β i\n⊢ Eq (HSMul.hSMul s x) fun i => HSMul.hSMul (s i) (x i)","decl":"@[to_additive]\nlemma smul_def' [∀ i, SMul (α i) (β i)] (s : ∀ i, α i) (x : ∀ i, β i) : s • x = fun i ↦ s i • x i :=\n  rfl\n\n"}
{"name":"Pi.vadd_apply'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\ni : ι\ninst✝ : (i : ι) → VAdd (α i) (β i)\ns : (i : ι) → α i\nx : (i : ι) → β i\n⊢ Eq (HVAdd.hVAdd s x i) (HVAdd.hVAdd (s i) (x i))","decl":"@[to_additive (attr := simp)]\nlemma smul_apply' [∀ i, SMul (α i) (β i)] (s : ∀ i, α i) (x : ∀ i, β i) : (s • x) i = s i • x i :=\n  rfl\n\n-- Porting note: `to_additive` fails to correctly translate name\n"}
{"name":"Pi.smul_apply'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\ni : ι\ninst✝ : (i : ι) → SMul (α i) (β i)\ns : (i : ι) → α i\nx : (i : ι) → β i\n⊢ Eq (HSMul.hSMul s x i) (HSMul.hSMul (s i) (x i))","decl":"@[to_additive (attr := simp)]\nlemma smul_apply' [∀ i, SMul (α i) (β i)] (s : ∀ i, α i) (x : ∀ i, β i) : (s • x) i = s i • x i :=\n  rfl\n\n-- Porting note: `to_additive` fails to correctly translate name\n"}
{"name":"Pi.vaddAssocClass","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : ι → Type u_4\ninst✝³ : VAdd M N\ninst✝² : (i : ι) → VAdd N (α i)\ninst✝¹ : (i : ι) → VAdd M (α i)\ninst✝ : ∀ (i : ι), VAddAssocClass M N (α i)\n⊢ VAddAssocClass M N ((i : ι) → α i)","decl":"@[to_additive Pi.vaddAssocClass]\ninstance isScalarTower [SMul M N] [∀ i, SMul N (α i)] [∀ i, SMul M (α i)]\n    [∀ i, IsScalarTower M N (α i)] : IsScalarTower M N (∀ i, α i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc x y (z i)\n\n"}
{"name":"Pi.isScalarTower","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : ι → Type u_4\ninst✝³ : SMul M N\ninst✝² : (i : ι) → SMul N (α i)\ninst✝¹ : (i : ι) → SMul M (α i)\ninst✝ : ∀ (i : ι), IsScalarTower M N (α i)\n⊢ IsScalarTower M N ((i : ι) → α i)","decl":"@[to_additive Pi.vaddAssocClass]\ninstance isScalarTower [SMul M N] [∀ i, SMul N (α i)] [∀ i, SMul M (α i)]\n    [∀ i, IsScalarTower M N (α i)] : IsScalarTower M N (∀ i, α i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc x y (z i)\n\n"}
{"name":"Pi.isScalarTower'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝³ : (i : ι) → SMul M (α i)\ninst✝² : (i : ι) → SMul (α i) (β i)\ninst✝¹ : (i : ι) → SMul M (β i)\ninst✝ : ∀ (i : ι), IsScalarTower M (α i) (β i)\n⊢ IsScalarTower M ((i : ι) → α i) ((i : ι) → β i)","decl":"@[to_additive Pi.vaddAssocClass']\ninstance isScalarTower' [∀ i, SMul M (α i)] [∀ i, SMul (α i) (β i)] [∀ i, SMul M (β i)]\n    [∀ i, IsScalarTower M (α i) (β i)] : IsScalarTower M (∀ i, α i) (∀ i, β i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc x (y i) (z i)\n\n"}
{"name":"Pi.vaddAssocClass'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝³ : (i : ι) → VAdd M (α i)\ninst✝² : (i : ι) → VAdd (α i) (β i)\ninst✝¹ : (i : ι) → VAdd M (β i)\ninst✝ : ∀ (i : ι), VAddAssocClass M (α i) (β i)\n⊢ VAddAssocClass M ((i : ι) → α i) ((i : ι) → β i)","decl":"@[to_additive Pi.vaddAssocClass']\ninstance isScalarTower' [∀ i, SMul M (α i)] [∀ i, SMul (α i) (β i)] [∀ i, SMul M (β i)]\n    [∀ i, IsScalarTower M (α i) (β i)] : IsScalarTower M (∀ i, α i) (∀ i, β i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc x (y i) (z i)\n\n"}
{"name":"Pi.vaddAssocClass''","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\nγ : ι → Type u_6\ninst✝³ : (i : ι) → VAdd (α i) (β i)\ninst✝² : (i : ι) → VAdd (β i) (γ i)\ninst✝¹ : (i : ι) → VAdd (α i) (γ i)\ninst✝ : ∀ (i : ι), VAddAssocClass (α i) (β i) (γ i)\n⊢ VAddAssocClass ((i : ι) → α i) ((i : ι) → β i) ((i : ι) → γ i)","decl":"@[to_additive Pi.vaddAssocClass'']\ninstance isScalarTower'' [∀ i, SMul (α i) (β i)] [∀ i, SMul (β i) (γ i)] [∀ i, SMul (α i) (γ i)]\n    [∀ i, IsScalarTower (α i) (β i) (γ i)] : IsScalarTower (∀ i, α i) (∀ i, β i) (∀ i, γ i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc (x i) (y i) (z i)\n\n"}
{"name":"Pi.isScalarTower''","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\nγ : ι → Type u_6\ninst✝³ : (i : ι) → SMul (α i) (β i)\ninst✝² : (i : ι) → SMul (β i) (γ i)\ninst✝¹ : (i : ι) → SMul (α i) (γ i)\ninst✝ : ∀ (i : ι), IsScalarTower (α i) (β i) (γ i)\n⊢ IsScalarTower ((i : ι) → α i) ((i : ι) → β i) ((i : ι) → γ i)","decl":"@[to_additive Pi.vaddAssocClass'']\ninstance isScalarTower'' [∀ i, SMul (α i) (β i)] [∀ i, SMul (β i) (γ i)] [∀ i, SMul (α i) (γ i)]\n    [∀ i, IsScalarTower (α i) (β i) (γ i)] : IsScalarTower (∀ i, α i) (∀ i, β i) (∀ i, γ i) where\n  smul_assoc x y z := funext fun i ↦ smul_assoc (x i) (y i) (z i)\n\n"}
{"name":"Pi.smulCommClass","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : ι → Type u_4\ninst✝² : (i : ι) → SMul M (α i)\ninst✝¹ : (i : ι) → SMul N (α i)\ninst✝ : ∀ (i : ι), SMulCommClass M N (α i)\n⊢ SMulCommClass M N ((i : ι) → α i)","decl":"@[to_additive]\ninstance smulCommClass [∀ i, SMul M (α i)] [∀ i, SMul N (α i)] [∀ i, SMulCommClass M N (α i)] :\n    SMulCommClass M N (∀ i, α i) where\n  smul_comm x y z := funext fun i ↦ smul_comm x y (z i)\n\n"}
{"name":"Pi.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : ι → Type u_4\ninst✝² : (i : ι) → VAdd M (α i)\ninst✝¹ : (i : ι) → VAdd N (α i)\ninst✝ : ∀ (i : ι), VAddCommClass M N (α i)\n⊢ VAddCommClass M N ((i : ι) → α i)","decl":"@[to_additive]\ninstance smulCommClass [∀ i, SMul M (α i)] [∀ i, SMul N (α i)] [∀ i, SMulCommClass M N (α i)] :\n    SMulCommClass M N (∀ i, α i) where\n  smul_comm x y z := funext fun i ↦ smul_comm x y (z i)\n\n"}
{"name":"Pi.vaddCommClass'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝² : (i : ι) → VAdd M (β i)\ninst✝¹ : (i : ι) → VAdd (α i) (β i)\ninst✝ : ∀ (i : ι), VAddCommClass M (α i) (β i)\n⊢ VAddCommClass M ((i : ι) → α i) ((i : ι) → β i)","decl":"@[to_additive]\ninstance smulCommClass' [∀ i, SMul M (β i)] [∀ i, SMul (α i) (β i)]\n    [∀ i, SMulCommClass M (α i) (β i)] : SMulCommClass M (∀ i, α i) (∀ i, β i) :=\n  ⟨fun x y z => funext fun i ↦ smul_comm x (y i) (z i)⟩\n\n"}
{"name":"Pi.smulCommClass'","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝² : (i : ι) → SMul M (β i)\ninst✝¹ : (i : ι) → SMul (α i) (β i)\ninst✝ : ∀ (i : ι), SMulCommClass M (α i) (β i)\n⊢ SMulCommClass M ((i : ι) → α i) ((i : ι) → β i)","decl":"@[to_additive]\ninstance smulCommClass' [∀ i, SMul M (β i)] [∀ i, SMul (α i) (β i)]\n    [∀ i, SMulCommClass M (α i) (β i)] : SMulCommClass M (∀ i, α i) (∀ i, β i) :=\n  ⟨fun x y z => funext fun i ↦ smul_comm x (y i) (z i)⟩\n\n"}
{"name":"Pi.smulCommClass''","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\nγ : ι → Type u_6\ninst✝² : (i : ι) → SMul (β i) (γ i)\ninst✝¹ : (i : ι) → SMul (α i) (γ i)\ninst✝ : ∀ (i : ι), SMulCommClass (α i) (β i) (γ i)\n⊢ SMulCommClass ((i : ι) → α i) ((i : ι) → β i) ((i : ι) → γ i)","decl":"@[to_additive]\ninstance smulCommClass'' [∀ i, SMul (β i) (γ i)] [∀ i, SMul (α i) (γ i)]\n    [∀ i, SMulCommClass (α i) (β i) (γ i)] : SMulCommClass (∀ i, α i) (∀ i, β i) (∀ i, γ i) where\n  smul_comm x y z := funext fun i ↦ smul_comm (x i) (y i) (z i)\n\n"}
{"name":"Pi.vaddCommClass''","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nα : ι → Type u_4\nβ : ι → Type u_5\nγ : ι → Type u_6\ninst✝² : (i : ι) → VAdd (β i) (γ i)\ninst✝¹ : (i : ι) → VAdd (α i) (γ i)\ninst✝ : ∀ (i : ι), VAddCommClass (α i) (β i) (γ i)\n⊢ VAddCommClass ((i : ι) → α i) ((i : ι) → β i) ((i : ι) → γ i)","decl":"@[to_additive]\ninstance smulCommClass'' [∀ i, SMul (β i) (γ i)] [∀ i, SMul (α i) (γ i)]\n    [∀ i, SMulCommClass (α i) (β i) (γ i)] : SMulCommClass (∀ i, α i) (∀ i, β i) (∀ i, γ i) where\n  smul_comm x y z := funext fun i ↦ smul_comm (x i) (y i) (z i)\n\n"}
{"name":"Pi.isCentralScalar","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝² : (i : ι) → SMul M (α i)\ninst✝¹ : (i : ι) → SMul (MulOpposite M) (α i)\ninst✝ : ∀ (i : ι), IsCentralScalar M (α i)\n⊢ IsCentralScalar M ((i : ι) → α i)","decl":"@[to_additive]\ninstance isCentralScalar [∀ i, SMul M (α i)] [∀ i, SMul Mᵐᵒᵖ (α i)] [∀ i, IsCentralScalar M (α i)] :\n    IsCentralScalar M (∀ i, α i) where\n  op_smul_eq_smul _ _ := funext fun _ ↦ op_smul_eq_smul _ _\n\n"}
{"name":"Pi.isCentralVAdd","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝² : (i : ι) → VAdd M (α i)\ninst✝¹ : (i : ι) → VAdd (AddOpposite M) (α i)\ninst✝ : ∀ (i : ι), IsCentralVAdd M (α i)\n⊢ IsCentralVAdd M ((i : ι) → α i)","decl":"@[to_additive]\ninstance isCentralScalar [∀ i, SMul M (α i)] [∀ i, SMul Mᵐᵒᵖ (α i)] [∀ i, IsCentralScalar M (α i)] :\n    IsCentralScalar M (∀ i, α i) where\n  op_smul_eq_smul _ _ := funext fun _ ↦ op_smul_eq_smul _ _\n\n"}
{"name":"Pi.faithfulSMul_at","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝² : (i : ι) → SMul M (α i)\ninst✝¹ : ∀ (i : ι), Nonempty (α i)\ni : ι\ninst✝ : FaithfulSMul M (α i)\n⊢ FaithfulSMul M ((i : ι) → α i)","decl":"/-- If `α i` has a faithful scalar action for a given `i`, then so does `Π i, α i`. This is\nnot an instance as `i` cannot be inferred. -/\n@[to_additive\n\"If `α i` has a faithful additive action for a given `i`, then\nso does `Π i, α i`. This is not an instance as `i` cannot be inferred\"]\nlemma faithfulSMul_at [∀ i, SMul M (α i)] [∀ i, Nonempty (α i)] (i : ι) [FaithfulSMul M (α i)] :\n    FaithfulSMul M (∀ i, α i) where\n  eq_of_smul_eq_smul h := eq_of_smul_eq_smul fun a : α i => by\n    classical\n    simpa using\n      congr_fun (h <| Function.update (fun j => Classical.choice (‹∀ i, Nonempty (α i)› j)) i a) i\n\n"}
{"name":"Pi.faithfulVAdd_at","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝² : (i : ι) → VAdd M (α i)\ninst✝¹ : ∀ (i : ι), Nonempty (α i)\ni : ι\ninst✝ : FaithfulVAdd M (α i)\n⊢ FaithfulVAdd M ((i : ι) → α i)","decl":"/-- If `α i` has a faithful scalar action for a given `i`, then so does `Π i, α i`. This is\nnot an instance as `i` cannot be inferred. -/\n@[to_additive\n\"If `α i` has a faithful additive action for a given `i`, then\nso does `Π i, α i`. This is not an instance as `i` cannot be inferred\"]\nlemma faithfulSMul_at [∀ i, SMul M (α i)] [∀ i, Nonempty (α i)] (i : ι) [FaithfulSMul M (α i)] :\n    FaithfulSMul M (∀ i, α i) where\n  eq_of_smul_eq_smul h := eq_of_smul_eq_smul fun a : α i => by\n    classical\n    simpa using\n      congr_fun (h <| Function.update (fun j => Classical.choice (‹∀ i, Nonempty (α i)› j)) i a) i\n\n"}
{"name":"Pi.faithfulSMul","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝³ : Nonempty ι\ninst✝² : (i : ι) → SMul M (α i)\ninst✝¹ : ∀ (i : ι), Nonempty (α i)\ninst✝ : ∀ (i : ι), FaithfulSMul M (α i)\n⊢ FaithfulSMul M ((i : ι) → α i)","decl":"@[to_additive]\ninstance faithfulSMul [Nonempty ι] [∀ i, SMul M (α i)] [∀ i, Nonempty (α i)]\n    [∀ i, FaithfulSMul M (α i)] : FaithfulSMul M (∀ i, α i) :=\n  let ⟨i⟩ := ‹Nonempty ι›\n  faithfulSMul_at i\n\n"}
{"name":"Pi.faithfulVAdd","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝³ : Nonempty ι\ninst✝² : (i : ι) → VAdd M (α i)\ninst✝¹ : ∀ (i : ι), Nonempty (α i)\ninst✝ : ∀ (i : ι), FaithfulVAdd M (α i)\n⊢ FaithfulVAdd M ((i : ι) → α i)","decl":"@[to_additive]\ninstance faithfulSMul [Nonempty ι] [∀ i, SMul M (α i)] [∀ i, Nonempty (α i)]\n    [∀ i, FaithfulSMul M (α i)] : FaithfulSMul M (∀ i, α i) :=\n  let ⟨i⟩ := ‹Nonempty ι›\n  faithfulSMul_at i\n\n"}
{"name":"Function.vaddCommClass","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : Type u_7\ninst✝² : VAdd M α\ninst✝¹ : VAdd N α\ninst✝ : VAddCommClass M N α\n⊢ VAddCommClass M N (ι → α)","decl":"/-- Non-dependent version of `Pi.smulCommClass`. Lean gets confused by the dependent instance if\nthis is not present. -/\n@[to_additive\n  \"Non-dependent version of `Pi.vaddCommClass`. Lean gets confused by the dependent\n  instance if this is not present.\"]\ninstance smulCommClass {α : Type*} [SMul M α] [SMul N α] [SMulCommClass M N α] :\n    SMulCommClass M N (ι → α) := Pi.smulCommClass\n\n"}
{"name":"Function.smulCommClass","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nN : Type u_3\nα : Type u_7\ninst✝² : SMul M α\ninst✝¹ : SMul N α\ninst✝ : SMulCommClass M N α\n⊢ SMulCommClass M N (ι → α)","decl":"/-- Non-dependent version of `Pi.smulCommClass`. Lean gets confused by the dependent instance if\nthis is not present. -/\n@[to_additive\n  \"Non-dependent version of `Pi.vaddCommClass`. Lean gets confused by the dependent\n  instance if this is not present.\"]\ninstance smulCommClass {α : Type*} [SMul M α] [SMul N α] [SMulCommClass M N α] :\n    SMulCommClass M N (ι → α) := Pi.smulCommClass\n\n"}
{"name":"Function.update_smul","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝¹ : (i : ι) → SMul M (α i)\ninst✝ : DecidableEq ι\nc : M\nf₁ : (i : ι) → α i\ni : ι\nx₁ : α i\n⊢ Eq (Function.update (HSMul.hSMul c f₁) i (HSMul.hSMul c x₁)) (HSMul.hSMul c (Function.update f₁ i x₁))","decl":"@[to_additive]\nlemma update_smul [∀ i, SMul M (α i)] [DecidableEq ι] (c : M) (f₁ : ∀ i, α i)\n    (i : ι) (x₁ : α i) : update (c • f₁) i (c • x₁) = c • update f₁ i x₁ :=\n  funext fun j => (apply_update (β := α) (fun _ ↦ (c • ·)) f₁ i x₁ j).symm\n\n"}
{"name":"Function.update_vadd","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝¹ : (i : ι) → VAdd M (α i)\ninst✝ : DecidableEq ι\nc : M\nf₁ : (i : ι) → α i\ni : ι\nx₁ : α i\n⊢ Eq (Function.update (HVAdd.hVAdd c f₁) i (HVAdd.hVAdd c x₁)) (HVAdd.hVAdd c (Function.update f₁ i x₁))","decl":"@[to_additive]\nlemma update_smul [∀ i, SMul M (α i)] [DecidableEq ι] (c : M) (f₁ : ∀ i, α i)\n    (i : ι) (x₁ : α i) : update (c • f₁) i (c • x₁) = c • update f₁ i x₁ :=\n  funext fun j => (apply_update (β := α) (fun _ ↦ (c • ·)) f₁ i x₁ j).symm\n\n"}
{"name":"Function.extend_vadd","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_7\nα : Type u_8\nβ : Type u_9\ninst✝ : VAdd M β\nr : M\nf : ι → α\ng : ι → β\ne : α → β\n⊢ Eq (Function.extend f (HVAdd.hVAdd r g) (HVAdd.hVAdd r e)) (HVAdd.hVAdd r (Function.extend f g e))","decl":"@[to_additive]\nlemma extend_smul {M α β : Type*} [SMul M β] (r : M) (f : ι → α) (g : ι → β) (e : α → β) :\n    extend f (r • g) (r • e) = r • extend f g e := by\n  funext x\n  classical\n  simp only [extend_def, Pi.smul_apply]\n  split_ifs <;> rfl\n\n"}
{"name":"Function.extend_smul","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_7\nα : Type u_8\nβ : Type u_9\ninst✝ : SMul M β\nr : M\nf : ι → α\ng : ι → β\ne : α → β\n⊢ Eq (Function.extend f (HSMul.hSMul r g) (HSMul.hSMul r e)) (HSMul.hSMul r (Function.extend f g e))","decl":"@[to_additive]\nlemma extend_smul {M α β : Type*} [SMul M β] (r : M) (f : ι → α) (g : ι → β) (e : α → β) :\n    extend f (r • g) (r • e) = r • extend f g e := by\n  funext x\n  classical\n  simp only [extend_def, Pi.smul_apply]\n  split_ifs <;> rfl\n\n"}
{"name":"Set.piecewise_vadd","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝¹ : (i : ι) → VAdd M (α i)\ns : Set ι\ninst✝ : (i : ι) → Decidable (Membership.mem s i)\nc : M\nf₁ g₁ : (i : ι) → α i\n⊢ Eq (s.piecewise (HVAdd.hVAdd c f₁) (HVAdd.hVAdd c g₁)) (HVAdd.hVAdd c (s.piecewise f₁ g₁))","decl":"@[to_additive]\nlemma piecewise_smul [∀ i, SMul M (α i)] (s : Set ι) [∀ i, Decidable (i ∈ s)]\n    (c : M) (f₁ g₁ : ∀ i, α i) : s.piecewise (c • f₁) (c • g₁) = c • s.piecewise f₁ g₁ :=\n  s.piecewise_op (δ' := α) f₁ _ fun _ ↦ (c • ·)\n\n"}
{"name":"Set.piecewise_smul","module":"Mathlib.Algebra.Group.Action.Pi","initialProofState":"ι : Type u_1\nM : Type u_2\nα : ι → Type u_4\ninst✝¹ : (i : ι) → SMul M (α i)\ns : Set ι\ninst✝ : (i : ι) → Decidable (Membership.mem s i)\nc : M\nf₁ g₁ : (i : ι) → α i\n⊢ Eq (s.piecewise (HSMul.hSMul c f₁) (HSMul.hSMul c g₁)) (HSMul.hSMul c (s.piecewise f₁ g₁))","decl":"@[to_additive]\nlemma piecewise_smul [∀ i, SMul M (α i)] (s : Set ι) [∀ i, Decidable (i ∈ s)]\n    (c : M) (f₁ g₁ : ∀ i, α i) : s.piecewise (c • f₁) (c • g₁) = c • s.piecewise f₁ g₁ :=\n  s.piecewise_op (δ' := α) f₁ _ fun _ ↦ (c • ·)\n\n"}
