{"name":"PerfectPairing.mk.inj","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoLin✝ : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nbijectiveLeft✝ : Function.Bijective ⇑toLin✝\nbijectiveRight✝ : Function.Bijective ⇑toLin✝.flip\ntoLin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nbijectiveLeft : Function.Bijective ⇑toLin\nbijectiveRight : Function.Bijective ⇑toLin.flip\nx✝ : Eq { toLin := toLin✝, bijectiveLeft := bijectiveLeft✝, bijectiveRight := bijectiveRight✝ } { toLin := toLin, bijectiveLeft := bijectiveLeft, bijectiveRight := bijectiveRight }\n⊢ Eq toLin✝ toLin","decl":"/-- A perfect pairing of two (left) modules over a commutative ring. -/\nstructure PerfectPairing where\n  toLin : M →ₗ[R] N →ₗ[R] R\n  bijectiveLeft : Bijective toLin\n  bijectiveRight : Bijective toLin.flip\n\n"}
{"name":"PerfectPairing.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoLin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nbijectiveLeft : Function.Bijective ⇑toLin\nbijectiveRight : Function.Bijective ⇑toLin.flip\n⊢ Eq (SizeOf.sizeOf { toLin := toLin, bijectiveLeft := bijectiveLeft, bijectiveRight := bijectiveRight }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLin)) (SizeOf.sizeOf bijectiveLeft)) (SizeOf.sizeOf bijectiveRight))","decl":"/-- A perfect pairing of two (left) modules over a commutative ring. -/\nstructure PerfectPairing where\n  toLin : M →ₗ[R] N →ₗ[R] R\n  bijectiveLeft : Bijective toLin\n  bijectiveRight : Bijective toLin.flip\n\n"}
{"name":"PerfectPairing.mk.injEq","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ntoLin✝ : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nbijectiveLeft✝ : Function.Bijective ⇑toLin✝\nbijectiveRight✝ : Function.Bijective ⇑toLin✝.flip\ntoLin : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nbijectiveLeft : Function.Bijective ⇑toLin\nbijectiveRight : Function.Bijective ⇑toLin.flip\n⊢ Eq (Eq { toLin := toLin✝, bijectiveLeft := bijectiveLeft✝, bijectiveRight := bijectiveRight✝ } { toLin := toLin, bijectiveLeft := bijectiveLeft, bijectiveRight := bijectiveRight }) (Eq toLin✝ toLin)","decl":"/-- A perfect pairing of two (left) modules over a commutative ring. -/\nstructure PerfectPairing where\n  toLin : M →ₗ[R] N →ₗ[R] R\n  bijectiveLeft : Bijective toLin\n  bijectiveRight : Bijective toLin.flip\n\n"}
{"name":"PerfectPairing.bijectiveLeft","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : PerfectPairing R M N\n⊢ Function.Bijective ⇑self.toLin","decl":"/-- A perfect pairing of two (left) modules over a commutative ring. -/\nstructure PerfectPairing where\n  toLin : M →ₗ[R] N →ₗ[R] R\n  bijectiveLeft : Bijective toLin\n  bijectiveRight : Bijective toLin.flip\n\n"}
{"name":"PerfectPairing.bijectiveRight","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nself : PerfectPairing R M N\n⊢ Function.Bijective ⇑self.toLin.flip","decl":"/-- A perfect pairing of two (left) modules over a commutative ring. -/\nstructure PerfectPairing where\n  toLin : M →ₗ[R] N →ₗ[R] R\n  bijectiveLeft : Bijective toLin\n  bijectiveRight : Bijective toLin.flip\n\n"}
{"name":"PerfectPairing.toLin_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nx : M\n⊢ Eq (p.toLin x) (p x)","decl":"@[simp]\nlemma toLin_apply (p : PerfectPairing R M N) {x : M} : p.toLin x = p x := by\n  rfl\n\n"}
{"name":"PerfectPairing.mk_apply_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M (LinearMap (RingHom.id R) N R)\nhl : Function.Bijective ⇑f\nhr : Function.Bijective ⇑f.flip\nx : M\n⊢ Eq ({ toLin := f, bijectiveLeft := hl, bijectiveRight := hr } x) (f x)","decl":"@[simp]\nlemma mk_apply_apply {f : M →ₗ[R] N →ₗ[R] R} {hl} {hr} {x : M} :\n    (⟨f, hl, hr⟩ : PerfectPairing R M N) x = f x :=\n  rfl\n\n"}
{"name":"PerfectPairing.flip_apply_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nx : M\ny : N\n⊢ Eq ((p.flip y) x) ((p x) y)","decl":"@[simp]\nlemma flip_apply_apply {x : M} {y : N} : p.flip y x = p x y :=\n  rfl\n\n"}
{"name":"PerfectPairing.flip_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\n⊢ Eq p.flip.flip p","decl":"@[simp]\nlemma flip_flip : p.flip.flip = p :=\n  rfl\n\n"}
{"name":"PerfectPairing.toDualLeft_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\na : M\n⊢ Eq (p.toDualLeft a) (p a)","decl":"@[simp]\ntheorem toDualLeft_apply (a : M) : p.toDualLeft a = p a :=\n  rfl\n\n"}
{"name":"PerfectPairing.apply_toDualLeft_symm_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nf : Module.Dual R N\nx : N\n⊢ Eq ((p (p.toDualLeft.symm f)) x) (f x)","decl":"@[simp]\ntheorem apply_toDualLeft_symm_apply (f : Dual R N) (x : N) : p (p.toDualLeft.symm f) x = f x := by\n  have h := LinearEquiv.apply_symm_apply p.toDualLeft f\n  rw [toDualLeft_apply] at h\n  exact congrFun (congrArg DFunLike.coe h) x\n\n"}
{"name":"PerfectPairing.toDualRight_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\na : N\n⊢ Eq (p.toDualRight a) (p.flip a)","decl":"@[simp]\ntheorem toDualRight_apply (a : N) : p.toDualRight a = p.flip a :=\n  rfl\n\n"}
{"name":"PerfectPairing.apply_apply_toDualRight_symm","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nx : M\nf : Module.Dual R M\n⊢ Eq ((p x) (p.toDualRight.symm f)) (f x)","decl":"@[simp]\ntheorem apply_apply_toDualRight_symm (x : M) (f : Dual R M) :\n    (p x) (p.toDualRight.symm f) = f x := by\n  have h := LinearEquiv.apply_symm_apply p.toDualRight f\n  rw [toDualRight_apply] at h\n  exact congrFun (congrArg DFunLike.coe h) x\n\n"}
{"name":"PerfectPairing.toDualLeft_of_toDualRight_symm","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nx : M\nf : Module.Dual R M\n⊢ Eq ((p.toDualLeft x) (p.toDualRight.symm f)) (f x)","decl":"theorem toDualLeft_of_toDualRight_symm (x : M) (f : Dual R M) :\n    (p.toDualLeft x) (p.toDualRight.symm f) = f x := by\n  rw [@toDualLeft_apply]\n  exact apply_apply_toDualRight_symm p x f\n\n"}
{"name":"PerfectPairing.toDualRight_symm_toDualLeft","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nx : M\n⊢ Eq (p.toDualRight.symm.dualMap (p.toDualLeft x)) ((Module.Dual.eval R M) x)","decl":"theorem toDualRight_symm_toDualLeft (x : M) :\n    p.toDualRight.symm.dualMap (p.toDualLeft x) = Dual.eval R M x := by\n  ext f\n  simp only [LinearEquiv.dualMap_apply, Dual.eval_apply]\n  exact toDualLeft_of_toDualRight_symm p x f\n\n"}
{"name":"PerfectPairing.toDualRight_symm_comp_toDualLeft","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\n⊢ Eq ((↑p.toDualRight.symm.dualMap).comp ↑p.toDualLeft) (Module.Dual.eval R M)","decl":"theorem toDualRight_symm_comp_toDualLeft :\n    p.toDualRight.symm.dualMap ∘ₗ (p.toDualLeft : M →ₗ[R] Dual R N) = Dual.eval R M := by\n  ext1 x\n  exact p.toDualRight_symm_toDualLeft x\n\n"}
{"name":"PerfectPairing.bijective_toDualRight_symm_toDualLeft","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\n⊢ Function.Bijective fun x => p.toDualRight.symm.dualMap (p.toDualLeft x)","decl":"theorem bijective_toDualRight_symm_toDualLeft :\n    Bijective (fun x => p.toDualRight.symm.dualMap (p.toDualLeft x)) :=\n  Bijective.comp (LinearEquiv.bijective p.toDualRight.symm.dualMap)\n    (LinearEquiv.bijective p.toDualLeft)\n\n"}
{"name":"PerfectPairing.reflexive_left","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\n⊢ Module.IsReflexive R M","decl":"include p in\ntheorem reflexive_left : IsReflexive R M where\n  bijective_dual_eval' := by\n    rw [← p.toDualRight_symm_comp_toDualLeft]\n    exact p.bijective_toDualRight_symm_toDualLeft\n\n"}
{"name":"PerfectPairing.reflexive_right","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\n⊢ Module.IsReflexive R N","decl":"include p in\ntheorem reflexive_right : IsReflexive R N :=\n  p.flip.reflexive_left\n\n"}
{"name":"PerfectPairing.instLinearEquivClassDual","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\n⊢ LinearEquivClass (PerfectPairing R M N) R M (Module.Dual R N)","decl":"instance : LinearEquivClass (PerfectPairing R M N) R M (Dual R N) where\n  map_add p m₁ m₂ := p.toLin.map_add m₁ m₂\n  map_smulₛₗ p t m := p.toLin.map_smul t m\n\n"}
{"name":"PerfectPairing.finrank_eq","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\np : PerfectPairing R M N\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.finrank R M) (Module.finrank R N)","decl":"include p in\ntheorem finrank_eq [Module.Finite R M] [Module.Free R M] :\n    finrank R M = finrank R N :=\n  ((Module.Free.chooseBasis R M).toDualEquiv.trans p.toDualRight.symm).finrank_eq\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.isCompl_left","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nU : Submodule R M\nV : Submodule R N\nself : p.IsPerfectCompl U V\n⊢ IsCompl U (Submodule.map p.toDualLeft.symm V.dualAnnihilator)","decl":"/-- Given a perfect pairing `p` between `M` and `N`, we say a pair of submodules `U` in `M` and\n`V` in `N` are perfectly complementary wrt `p` if their dual annihilators are complementary, using\n`p` to identify `M` and `N` with dual spaces. -/\nstructure IsPerfectCompl (U : Submodule R M) (V : Submodule R N) : Prop where\n  isCompl_left : IsCompl U (V.dualAnnihilator.map p.toDualLeft.symm)\n  isCompl_right : IsCompl V (U.dualAnnihilator.map p.toDualRight.symm)\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.isCompl_right","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nU : Submodule R M\nV : Submodule R N\nself : p.IsPerfectCompl U V\n⊢ IsCompl V (Submodule.map p.toDualRight.symm U.dualAnnihilator)","decl":"/-- Given a perfect pairing `p` between `M` and `N`, we say a pair of submodules `U` in `M` and\n`V` in `N` are perfectly complementary wrt `p` if their dual annihilators are complementary, using\n`p` to identify `M` and `N` with dual spaces. -/\nstructure IsPerfectCompl (U : Submodule R M) (V : Submodule R N) : Prop where\n  isCompl_left : IsCompl U (V.dualAnnihilator.map p.toDualLeft.symm)\n  isCompl_right : IsCompl V (U.dualAnnihilator.map p.toDualRight.symm)\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nU : Submodule R M\nV : Submodule R N\nh : p.IsPerfectCompl U V\n⊢ p.flip.IsPerfectCompl V U","decl":"protected lemma flip (h : p.IsPerfectCompl U V) :\n    p.flip.IsPerfectCompl V U where\n  isCompl_left := h.isCompl_right\n  isCompl_right := h.isCompl_left\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.flip_iff","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nU : Submodule R M\nV : Submodule R N\n⊢ Iff (p.flip.IsPerfectCompl V U) (p.IsPerfectCompl U V)","decl":"@[simp]\nprotected lemma flip_iff :\n    p.flip.IsPerfectCompl V U ↔ p.IsPerfectCompl U V :=\n  ⟨fun h ↦ h.flip, fun h ↦ h.flip⟩\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.left_top_iff","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nV : Submodule R N\n⊢ Iff (p.IsPerfectCompl Top.top V) (Eq V Top.top)","decl":"@[simp]\nlemma left_top_iff :\n    p.IsPerfectCompl ⊤ V ↔ V = ⊤ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · exact eq_top_of_isCompl_bot <| by simpa using h.isCompl_right\n  · rw [h]\n    exact\n      { isCompl_left := by simpa using isCompl_top_bot\n        isCompl_right := by simpa using isCompl_top_bot }\n\n"}
{"name":"PerfectPairing.IsPerfectCompl.right_top_iff","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\np : PerfectPairing R M N\nU : Submodule R M\n⊢ Iff (p.IsPerfectCompl U Top.top) (Eq U Top.top)","decl":"@[simp]\nlemma right_top_iff :\n    p.IsPerfectCompl U ⊤ ↔ U = ⊤ := by\n  rw [← IsPerfectCompl.flip_iff]\n  exact left_top_iff\n\n"}
{"name":"IsReflexive.toPerfectPairingDual_toLin","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\n⊢ Eq IsReflexive.toPerfectPairingDual.toLin LinearMap.id","decl":"/-- A reflexive module has a perfect pairing with its dual. -/\n@[simps]\ndef IsReflexive.toPerfectPairingDual : PerfectPairing R (Dual R M) M where\n  toLin := LinearMap.id\n  bijectiveLeft := bijective_id\n  bijectiveRight := bijective_dual_eval R M\n\n"}
{"name":"IsReflexive.toPerfectPairingDual_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Module.IsReflexive R M\nf : Module.Dual R M\nx : M\n⊢ Eq ((IsReflexive.toPerfectPairingDual f) x) (f x)","decl":"@[simp]\nlemma IsReflexive.toPerfectPairingDual_apply {f : Dual R M} {x : M} :\n    IsReflexive.toPerfectPairingDual (R := R) f x = f x :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toLinearMap_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\n⊢ Eq (↑e.flip) (↑e).flip","decl":"@[simp] lemma coe_toLinearMap_flip : e.flip = (↑e : N →ₗ[R] Dual R M).flip := rfl\n\n"}
{"name":"LinearEquiv.flip_apply","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\nm : M\nn : N\n⊢ Eq ((e.flip m) n) ((e n) m)","decl":"@[simp] lemma flip_apply (m : M) (n : N) : e.flip m n = e n m := rfl\n\n"}
{"name":"LinearEquiv.symm_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\n⊢ Eq e.flip.symm (e.symm.dualMap.trans (Module.evalEquiv R M).symm)","decl":"lemma symm_flip : e.flip.symm = e.symm.dualMap.trans (evalEquiv R M).symm := rfl\n\n"}
{"name":"LinearEquiv.trans_dualMap_symm_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\n⊢ Eq (↑(e.trans e.flip.symm.dualMap)) (Module.Dual.eval R N)","decl":"lemma trans_dualMap_symm_flip : e.trans e.flip.symm.dualMap = Dual.eval R N := by\n  ext; simp [symm_flip]\n\n"}
{"name":"LinearEquiv.isReflexive_of_equiv_dual_of_isReflexive","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\n⊢ Module.IsReflexive R N","decl":"include e in\n/-- If `N` is in perfect pairing with `M`, then it is reflexive. -/\nlemma isReflexive_of_equiv_dual_of_isReflexive : IsReflexive R N := by\n  constructor\n  rw [← trans_dualMap_symm_flip e]\n  exact LinearEquiv.bijective _\n\n"}
{"name":"LinearEquiv.flip_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\nh : optParam (Module.IsReflexive R N) ⋯\n⊢ Eq e.flip.flip e","decl":"@[simp] lemma flip_flip (h : IsReflexive R N := isReflexive_of_equiv_dual_of_isReflexive e) :\n    e.flip.flip = e := by\n  ext; rfl\n\n"}
{"name":"LinearEquiv.toPerfectPairing_toLin","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\n⊢ Eq e.toPerfectPairing.toLin ↑e","decl":"/-- If `M` is reflexive then a linear equivalence `N ≃ Dual R M` is a perfect pairing. -/\n@[simps]\ndef toPerfectPairing : PerfectPairing R N M where\n  toLin := e\n  bijectiveLeft := e.bijective\n  bijectiveRight := e.flip.bijective\n\n"}
{"name":"Submodule.dualCoannihilator_map_linearEquiv_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\np : Submodule R M\n⊢ Eq (Submodule.map e.flip p).dualCoannihilator (Submodule.map e.symm p.dualAnnihilator)","decl":"@[simp]\nlemma dualCoannihilator_map_linearEquiv_flip (p : Submodule R M) :\n    (p.map e.flip).dualCoannihilator = p.dualAnnihilator.map e.symm := by\n  ext; simp [LinearEquiv.symm_apply_eq, Submodule.mem_dualCoannihilator]\n\n"}
{"name":"Submodule.map_dualAnnihilator_linearEquiv_flip_symm","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\np : Submodule R N\n⊢ Eq (Submodule.map e.flip.symm p.dualAnnihilator) (Submodule.map e p).dualCoannihilator","decl":"@[simp]\nlemma map_dualAnnihilator_linearEquiv_flip_symm (p : Submodule R N) :\n    p.dualAnnihilator.map e.flip.symm = (p.map e).dualCoannihilator := by\n  have : IsReflexive R N := e.isReflexive_of_equiv_dual_of_isReflexive\n  rw [← dualCoannihilator_map_linearEquiv_flip, flip_flip]\n\n"}
{"name":"Submodule.map_dualCoannihilator_linearEquiv_flip","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\np : Submodule R (Module.Dual R M)\n⊢ Eq (Submodule.map e.flip p.dualCoannihilator) (Submodule.map e.symm p).dualAnnihilator","decl":"@[simp]\nlemma map_dualCoannihilator_linearEquiv_flip (p : Submodule R (Dual R M)) :\n    p.dualCoannihilator.map e.flip = (p.map e.symm).dualAnnihilator := by\n  have : IsReflexive R N := e.isReflexive_of_equiv_dual_of_isReflexive\n  suffices (p.map e.symm).dualAnnihilator.map e.flip.symm =\n      (p.dualCoannihilator.map e.flip).map e.flip.symm by\n    exact (Submodule.map_injective_of_injective e.flip.symm.injective this).symm\n  erw [← dualCoannihilator_map_linearEquiv_flip, flip_flip, ← map_comp, ← map_comp]\n  simp [-coe_toLinearMap_flip]\n\n"}
{"name":"Submodule.dualAnnihilator_map_linearEquiv_flip_symm","module":"Mathlib.LinearAlgebra.PerfectPairing.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.IsReflexive R M\ne : LinearEquiv (RingHom.id R) N (Module.Dual R M)\np : Submodule R (Module.Dual R N)\n⊢ Eq (Submodule.map e.flip.symm p).dualAnnihilator (Submodule.map e p.dualCoannihilator)","decl":"@[simp]\nlemma dualAnnihilator_map_linearEquiv_flip_symm (p : Submodule R (Dual R N)) :\n    (p.map e.flip.symm).dualAnnihilator = p.dualCoannihilator.map e := by\n  have : IsReflexive R N := e.isReflexive_of_equiv_dual_of_isReflexive\n  rw [← map_dualCoannihilator_linearEquiv_flip, flip_flip]\n\n"}
