{"name":"CategoryTheory.Adjunction.map_restrictFullyFaithful_unit_app","module":"Mathlib.CategoryTheory.Adjunction.Restrict","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\niC : CategoryTheory.Functor C C'\niD : CategoryTheory.Functor D D'\nL' : CategoryTheory.Functor C' D'\nR' : CategoryTheory.Functor D' C'\nadj : CategoryTheory.Adjunction L' R'\nhiC : iC.FullyFaithful\nhiD : iD.FullyFaithful\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ncomm1 : CategoryTheory.Iso (iC.comp L') (L.comp iD)\ncomm2 : CategoryTheory.Iso (iD.comp R') (R.comp iC)\nX : C\n⊢ Eq (iC.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).unit.app X)) (CategoryTheory.CategoryStruct.comp (adj.unit.app (iC.obj X)) (CategoryTheory.CategoryStruct.comp (R'.map (comm1.hom.app X)) (comm2.hom.app (L.obj X))))","decl":"@[simp, reassoc]\nlemma map_restrictFullyFaithful_unit_app (X : C) :\n    iC.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).unit.app X) =\n    adj.unit.app (iC.obj X) ≫ R'.map (comm1.hom.app X) ≫ comm2.hom.app (L.obj X) := by\n  simp [restrictFullyFaithful]\n\n"}
{"name":"CategoryTheory.Adjunction.map_restrictFullyFaithful_unit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Restrict","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\niC : CategoryTheory.Functor C C'\niD : CategoryTheory.Functor D D'\nL' : CategoryTheory.Functor C' D'\nR' : CategoryTheory.Functor D' C'\nadj : CategoryTheory.Adjunction L' R'\nhiC : iC.FullyFaithful\nhiD : iD.FullyFaithful\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ncomm1 : CategoryTheory.Iso (iC.comp L') (L.comp iD)\ncomm2 : CategoryTheory.Iso (iD.comp R') (R.comp iC)\nX : C\nZ : C'\nh : Quiver.Hom (iC.obj (R.obj (L.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (iC.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).unit.app X)) h) (CategoryTheory.CategoryStruct.comp (adj.unit.app (iC.obj X)) (CategoryTheory.CategoryStruct.comp (R'.map (comm1.hom.app X)) (CategoryTheory.CategoryStruct.comp (comm2.hom.app (L.obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_restrictFullyFaithful_unit_app (X : C) :\n    iC.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).unit.app X) =\n    adj.unit.app (iC.obj X) ≫ R'.map (comm1.hom.app X) ≫ comm2.hom.app (L.obj X) := by\n  simp [restrictFullyFaithful]\n\n"}
{"name":"CategoryTheory.Adjunction.map_restrictFullyFaithful_counit_app","module":"Mathlib.CategoryTheory.Adjunction.Restrict","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\niC : CategoryTheory.Functor C C'\niD : CategoryTheory.Functor D D'\nL' : CategoryTheory.Functor C' D'\nR' : CategoryTheory.Functor D' C'\nadj : CategoryTheory.Adjunction L' R'\nhiC : iC.FullyFaithful\nhiD : iD.FullyFaithful\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ncomm1 : CategoryTheory.Iso (iC.comp L') (L.comp iD)\ncomm2 : CategoryTheory.Iso (iD.comp R') (R.comp iC)\nX : D\n⊢ Eq (iD.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).counit.app X)) (CategoryTheory.CategoryStruct.comp (comm1.inv.app (R.obj X)) (CategoryTheory.CategoryStruct.comp (L'.map (comm2.inv.app X)) (adj.counit.app (iD.obj X))))","decl":"@[simp, reassoc]\nlemma map_restrictFullyFaithful_counit_app (X : D) :\n    iD.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).counit.app X) =\n    comm1.inv.app (R.obj X) ≫ L'.map (comm2.inv.app X) ≫ adj.counit.app (iD.obj X) := by\n  dsimp [restrictFullyFaithful]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.map_restrictFullyFaithful_counit_app_assoc","module":"Mathlib.CategoryTheory.Adjunction.Restrict","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\niC : CategoryTheory.Functor C C'\niD : CategoryTheory.Functor D D'\nL' : CategoryTheory.Functor C' D'\nR' : CategoryTheory.Functor D' C'\nadj : CategoryTheory.Adjunction L' R'\nhiC : iC.FullyFaithful\nhiD : iD.FullyFaithful\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ncomm1 : CategoryTheory.Iso (iC.comp L') (L.comp iD)\ncomm2 : CategoryTheory.Iso (iD.comp R') (R.comp iC)\nX : D\nZ : D'\nh : Quiver.Hom (iD.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (iD.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).counit.app X)) h) (CategoryTheory.CategoryStruct.comp (comm1.inv.app (R.obj X)) (CategoryTheory.CategoryStruct.comp (L'.map (comm2.inv.app X)) (CategoryTheory.CategoryStruct.comp (adj.counit.app (iD.obj X)) h)))","decl":"@[simp, reassoc]\nlemma map_restrictFullyFaithful_counit_app (X : D) :\n    iD.map ((adj.restrictFullyFaithful hiC hiD comm1 comm2).counit.app X) =\n    comm1.inv.app (R.obj X) ≫ L'.map (comm2.inv.app X) ≫ adj.counit.app (iD.obj X) := by\n  dsimp [restrictFullyFaithful]\n  simp\n\n"}
{"name":"CategoryTheory.Adjunction.restrictFullyFaithful_homEquiv_apply","module":"Mathlib.CategoryTheory.Adjunction.Restrict","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\niC : CategoryTheory.Functor C C'\niD : CategoryTheory.Functor D D'\nL' : CategoryTheory.Functor C' D'\nR' : CategoryTheory.Functor D' C'\nadj : CategoryTheory.Adjunction L' R'\nhiC : iC.FullyFaithful\nhiD : iD.FullyFaithful\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ncomm1 : CategoryTheory.Iso (iC.comp L') (L.comp iD)\ncomm2 : CategoryTheory.Iso (iD.comp R') (R.comp iC)\nX : C\nY : D\nf : Quiver.Hom (L.obj X) Y\n⊢ Eq (((adj.restrictFullyFaithful hiC hiD comm1 comm2).homEquiv X Y) f) (hiC.preimage (CategoryTheory.CategoryStruct.comp (adj.unit.app (iC.obj X)) (CategoryTheory.CategoryStruct.comp (R'.map (comm1.hom.app X)) (CategoryTheory.CategoryStruct.comp (R'.map (iD.map f)) (comm2.hom.app Y)))))","decl":"lemma restrictFullyFaithful_homEquiv_apply {X : C} {Y : D} (f : L.obj X ⟶ Y) :\n    (adj.restrictFullyFaithful hiC hiD comm1 comm2).homEquiv X Y f =\n      hiC.preimage (adj.unit.app (iC.obj X) ≫ R'.map (comm1.hom.app X) ≫\n        R'.map (iD.map f) ≫ comm2.hom.app Y) := by\n  -- This proof was just `simp [restrictFullyFaithful]` before https://github.com/leanprover-community/mathlib4/pull/16317\n  apply hiC.map_injective\n  simp only [homEquiv_apply, Functor.comp_obj, Functor.map_comp, map_restrictFullyFaithful_unit_app,\n    Functor.id_obj, assoc, Functor.FullyFaithful.map_preimage]\n  congr 2\n  exact (comm2.hom.naturality _).symm\n\n"}
