{"name":"Finset.HasAntidiagonal.mem_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝ : AddMonoid A\nself : Finset.HasAntidiagonal A\nn : A\na : Prod A A\n⊢ Iff (Membership.mem (Finset.HasAntidiagonal.antidiagonal n) a) (Eq (HAdd.hAdd a.1 a.2) n)","decl":"/-- The class of additive monoids with an antidiagonal -/\nclass HasAntidiagonal (A : Type*) [AddMonoid A] where\n  /-- The antidiagonal of an element `n` is the finset of pairs `(i, j)` such that `i + j = n`. -/\n  antidiagonal : A → Finset (A × A)\n  /-- A pair belongs to `antidiagonal n` iff the sum of its components is equal to `n`. -/\n  mem_antidiagonal {n} {a} : a ∈ antidiagonal n ↔ a.fst + a.snd = n\n\n"}
{"name":"Finset.instSubsingletonHasAntidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝ : AddMonoid A\n⊢ Subsingleton (Finset.HasAntidiagonal A)","decl":"/-- All `HasAntidiagonal` instances are equal -/\ninstance [AddMonoid A] : Subsingleton (HasAntidiagonal A) where\n  allEq := by\n    rintro ⟨a, ha⟩ ⟨b, hb⟩\n    congr with n xy\n    rw [ha, hb]\n\n-- The goal of this lemma is to allow to rewrite antidiagonal\n-- when the decidability instances obsucate Lean\n"}
{"name":"Finset.hasAntidiagonal_congr","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_2\ninst✝ : AddMonoid A\nH1 H2 : Finset.HasAntidiagonal A\n⊢ Eq Finset.HasAntidiagonal.antidiagonal Finset.HasAntidiagonal.antidiagonal","decl":"lemma hasAntidiagonal_congr (A : Type*) [AddMonoid A]\n    [H1 : HasAntidiagonal A] [H2 : HasAntidiagonal A] :\n    H1.antidiagonal = H2.antidiagonal := by congr!; subsingleton\n\n"}
{"name":"Finset.swap_mem_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCommMonoid A\ninst✝ : Finset.HasAntidiagonal A\nn : A\nxy : Prod A A\n⊢ Iff (Membership.mem (Finset.HasAntidiagonal.antidiagonal n) xy.swap) (Membership.mem (Finset.HasAntidiagonal.antidiagonal n) xy)","decl":"theorem swap_mem_antidiagonal [AddCommMonoid A] [HasAntidiagonal A] {n : A} {xy : A × A} :\n    xy.swap ∈ antidiagonal n ↔ xy ∈ antidiagonal n := by\n  simp [add_comm]\n\n"}
{"name":"Finset.map_prodComm_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCommMonoid A\ninst✝ : Finset.HasAntidiagonal A\nn : A\n⊢ Eq (Finset.map (Equiv.prodComm A A).toEmbedding (Finset.HasAntidiagonal.antidiagonal n)) (Finset.HasAntidiagonal.antidiagonal n)","decl":"@[simp] theorem map_prodComm_antidiagonal [AddCommMonoid A] [HasAntidiagonal A] {n : A} :\n    (antidiagonal n).map (Equiv.prodComm A A) = antidiagonal n :=\n  Finset.ext fun ⟨a, b⟩ => by simp [add_comm]\n\n"}
{"name":"Finset.map_swap_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCommMonoid A\ninst✝ : Finset.HasAntidiagonal A\nn : A\n⊢ Eq (Finset.map { toFun := Prod.swap, inj' := ⋯ } (Finset.HasAntidiagonal.antidiagonal n)) (Finset.HasAntidiagonal.antidiagonal n)","decl":"/-- See also `Finset.map_prodComm_antidiagonal`. -/\n@[simp] theorem map_swap_antidiagonal [AddCommMonoid A] [HasAntidiagonal A] {n : A} :\n    (antidiagonal n).map ⟨Prod.swap, Prod.swap_injective⟩ = antidiagonal n :=\n  map_prodComm_antidiagonal\n\n"}
{"name":"Finset.antidiagonal_congr","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCancelMonoid A\ninst✝ : Finset.HasAntidiagonal A\np q : Prod A A\nn : A\nhp : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) p\nhq : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) q\n⊢ Iff (Eq p q) (Eq p.1 q.1)","decl":"/-- A point in the antidiagonal is determined by its first coordinate.\n\nSee also `Finset.antidiagonal_congr'`. -/\ntheorem antidiagonal_congr (hp : p ∈ antidiagonal n) (hq : q ∈ antidiagonal n) :\n    p = q ↔ p.1 = q.1 := by\n  refine ⟨congr_arg Prod.fst, fun h ↦ Prod.ext h ((add_right_inj q.fst).mp ?_)⟩\n  rw [mem_antidiagonal] at hp hq\n  rw [hq, ← h, hp]\n\n"}
{"name":"Finset.antidiagonal_subtype_ext","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCancelMonoid A\ninst✝ : Finset.HasAntidiagonal A\nn : A\np q : Subtype fun x => Membership.mem (Finset.HasAntidiagonal.antidiagonal n) x\nh : Eq (↑p).1 (↑q).1\n⊢ Eq p q","decl":"/-- A point in the antidiagonal is determined by its first co-ordinate (subtype version of\n`Finset.antidiagonal_congr`). This lemma is used by the `ext` tactic. -/\n@[ext] theorem antidiagonal_subtype_ext {p q : antidiagonal n} (h : p.val.1 = q.val.1) : p = q :=\n  Subtype.ext ((antidiagonal_congr p.prop q.prop).mpr h)\n\n"}
{"name":"Finset.antidiagonal_subtype_ext_iff","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCancelMonoid A\ninst✝ : Finset.HasAntidiagonal A\nn : A\np q : Subtype fun x => Membership.mem (Finset.HasAntidiagonal.antidiagonal n) x\n⊢ Iff (Eq p q) (Eq (↑p).1 (↑q).1)","decl":"/-- A point in the antidiagonal is determined by its first co-ordinate (subtype version of\n`Finset.antidiagonal_congr`). This lemma is used by the `ext` tactic. -/\n@[ext] theorem antidiagonal_subtype_ext {p q : antidiagonal n} (h : p.val.1 = q.val.1) : p = q :=\n  Subtype.ext ((antidiagonal_congr p.prop q.prop).mpr h)\n\n"}
{"name":"Finset.antidiagonal_congr'","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddCancelCommMonoid A\ninst✝ : Finset.HasAntidiagonal A\np q : Prod A A\nn : A\nhp : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) p\nhq : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) q\n⊢ Iff (Eq p q) (Eq p.2 q.2)","decl":"/-- A point in the antidiagonal is determined by its second coordinate.\n\nSee also `Finset.antidiagonal_congr`. -/\nlemma antidiagonal_congr' (hp : p ∈ antidiagonal n) (hq : q ∈ antidiagonal n) :\n    p = q ↔ p.2 = q.2 := by\n  rw [← Prod.swap_inj]\n  exact antidiagonal_congr (swap_mem_antidiagonal.2 hp) (swap_mem_antidiagonal.2 hq)\n\n"}
{"name":"Finset.antidiagonal_zero","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝² : OrderedAddCommMonoid A\ninst✝¹ : CanonicallyOrderedAdd A\ninst✝ : Finset.HasAntidiagonal A\n⊢ Eq (Finset.HasAntidiagonal.antidiagonal 0) (Singleton.singleton { fst := 0, snd := 0 })","decl":"@[simp]\ntheorem antidiagonal_zero : antidiagonal (0 : A) = {(0, 0)} := by\n  ext ⟨x, y⟩\n  simp\n\n"}
{"name":"Finset.antidiagonal.fst_le","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝² : OrderedAddCommMonoid A\ninst✝¹ : CanonicallyOrderedAdd A\ninst✝ : Finset.HasAntidiagonal A\nn : A\nkl : Prod A A\nhlk : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) kl\n⊢ LE.le kl.1 n","decl":"theorem antidiagonal.fst_le {n : A} {kl : A × A} (hlk : kl ∈ antidiagonal n) : kl.1 ≤ n := by\n  rw [le_iff_exists_add]\n  use kl.2\n  rwa [mem_antidiagonal, eq_comm] at hlk\n\n"}
{"name":"Finset.antidiagonal.snd_le","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝² : OrderedAddCommMonoid A\ninst✝¹ : CanonicallyOrderedAdd A\ninst✝ : Finset.HasAntidiagonal A\nn : A\nkl : Prod A A\nhlk : Membership.mem (Finset.HasAntidiagonal.antidiagonal n) kl\n⊢ LE.le kl.2 n","decl":"theorem antidiagonal.snd_le {n : A} {kl : A × A} (hlk : kl ∈ antidiagonal n) : kl.2 ≤ n := by\n  rw [le_iff_exists_add]\n  use kl.1\n  rwa [mem_antidiagonal, eq_comm, add_comm] at hlk\n\n"}
{"name":"Finset.filter_fst_eq_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝⁷ : OrderedAddCommMonoid A\ninst✝⁶ : CanonicallyOrderedAdd A\ninst✝⁵ : Sub A\ninst✝⁴ : OrderedSub A\ninst✝³ : AddLeftReflectLE A\ninst✝² : Finset.HasAntidiagonal A\nn m : A\ninst✝¹ : DecidablePred fun x => Eq x m\ninst✝ : Decidable (LE.le m n)\n⊢ Eq (Finset.filter (fun x => Eq x.1 m) (Finset.HasAntidiagonal.antidiagonal n)) (ite (LE.le m n) (Singleton.singleton { fst := m, snd := HSub.hSub n m }) EmptyCollection.emptyCollection)","decl":"theorem filter_fst_eq_antidiagonal (n m : A) [DecidablePred (· = m)] [Decidable (m ≤ n)] :\n    filter (fun x : A × A ↦ x.fst = m) (antidiagonal n) = if m ≤ n then {(m, n - m)} else ∅ := by\n  ext ⟨a, b⟩\n  suffices a = m → (a + b = n ↔ m ≤ n ∧ b = n - m) by\n    rw [mem_filter, mem_antidiagonal, apply_ite (fun n ↦ (a, b) ∈ n), mem_singleton,\n      Prod.mk.inj_iff, ite_prop_iff_or]\n    simpa [← and_assoc, @and_right_comm _ (a = _), and_congr_left_iff]\n  rintro rfl\n  constructor\n  · rintro rfl\n    exact ⟨le_add_right le_rfl, (add_tsub_cancel_left _ _).symm⟩\n  · rintro ⟨h, rfl⟩\n    exact add_tsub_cancel_of_le h\n\n"}
{"name":"Finset.filter_snd_eq_antidiagonal","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝⁷ : OrderedAddCommMonoid A\ninst✝⁶ : CanonicallyOrderedAdd A\ninst✝⁵ : Sub A\ninst✝⁴ : OrderedSub A\ninst✝³ : AddLeftReflectLE A\ninst✝² : Finset.HasAntidiagonal A\nn m : A\ninst✝¹ : DecidablePred fun x => Eq x m\ninst✝ : Decidable (LE.le m n)\n⊢ Eq (Finset.filter (fun x => Eq x.2 m) (Finset.HasAntidiagonal.antidiagonal n)) (ite (LE.le m n) (Singleton.singleton { fst := HSub.hSub n m, snd := m }) EmptyCollection.emptyCollection)","decl":"theorem filter_snd_eq_antidiagonal (n m : A) [DecidablePred (· = m)] [Decidable (m ≤ n)] :\n    filter (fun x : A × A ↦ x.snd = m) (antidiagonal n) = if m ≤ n then {(n - m, m)} else ∅ := by\n  have : (fun x : A × A ↦ (x.snd = m)) ∘ Prod.swap = fun x : A × A ↦ x.fst = m := by\n    ext; simp\n  rw [← map_swap_antidiagonal, filter_map]\n  simp [this, filter_fst_eq_antidiagonal, apply_ite (Finset.map _)]\n\n"}
{"name":"Finset.sigmaAntidiagonalEquivProd_symm_apply_fst","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\ninst✝ : Finset.HasAntidiagonal A\nx : Prod A A\n⊢ Eq (Finset.sigmaAntidiagonalEquivProd.symm x).fst (HAdd.hAdd x.1 x.2)","decl":"/-- The disjoint union of antidiagonals `Σ (n : A), antidiagonal n` is equivalent to the product\n    `A × A`. This is such an equivalence, obtained by mapping `(n, (k, l))` to `(k, l)`. -/\n@[simps]\ndef sigmaAntidiagonalEquivProd [AddMonoid A] [HasAntidiagonal A] :\n    (Σ n : A, antidiagonal n) ≃ A × A where\n  toFun x := x.2\n  invFun x := ⟨x.1 + x.2, x, mem_antidiagonal.mpr rfl⟩\n  left_inv := by\n    rintro ⟨n, ⟨k, l⟩, h⟩\n    rw [mem_antidiagonal] at h\n    exact Sigma.subtype_ext h rfl\n  right_inv _ := rfl\n\n"}
{"name":"Finset.sigmaAntidiagonalEquivProd_apply","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\ninst✝ : Finset.HasAntidiagonal A\nx : Sigma fun n => Subtype fun x => Membership.mem (Finset.HasAntidiagonal.antidiagonal n) x\n⊢ Eq (Finset.sigmaAntidiagonalEquivProd x) ↑x.snd","decl":"/-- The disjoint union of antidiagonals `Σ (n : A), antidiagonal n` is equivalent to the product\n    `A × A`. This is such an equivalence, obtained by mapping `(n, (k, l))` to `(k, l)`. -/\n@[simps]\ndef sigmaAntidiagonalEquivProd [AddMonoid A] [HasAntidiagonal A] :\n    (Σ n : A, antidiagonal n) ≃ A × A where\n  toFun x := x.2\n  invFun x := ⟨x.1 + x.2, x, mem_antidiagonal.mpr rfl⟩\n  left_inv := by\n    rintro ⟨n, ⟨k, l⟩, h⟩\n    rw [mem_antidiagonal] at h\n    exact Sigma.subtype_ext h rfl\n  right_inv _ := rfl\n\n"}
{"name":"Finset.sigmaAntidiagonalEquivProd_symm_apply_snd_coe","module":"Mathlib.Algebra.Order.Antidiag.Prod","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\ninst✝ : Finset.HasAntidiagonal A\nx : Prod A A\n⊢ Eq (↑(Finset.sigmaAntidiagonalEquivProd.symm x).snd) x","decl":"/-- The disjoint union of antidiagonals `Σ (n : A), antidiagonal n` is equivalent to the product\n    `A × A`. This is such an equivalence, obtained by mapping `(n, (k, l))` to `(k, l)`. -/\n@[simps]\ndef sigmaAntidiagonalEquivProd [AddMonoid A] [HasAntidiagonal A] :\n    (Σ n : A, antidiagonal n) ≃ A × A where\n  toFun x := x.2\n  invFun x := ⟨x.1 + x.2, x, mem_antidiagonal.mpr rfl⟩\n  left_inv := by\n    rintro ⟨n, ⟨k, l⟩, h⟩\n    rw [mem_antidiagonal] at h\n    exact Sigma.subtype_ext h rfl\n  right_inv _ := rfl\n\n"}
