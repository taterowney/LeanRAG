{"name":"Module.ext","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nx y : Module R M\nsmul : Eq SMul.smul SMul.smul\n⊢ Eq x y","decl":"/-- A module is a generalization of vector spaces to a scalar semiring.\n  It consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,\n  connected by a \"scalar multiplication\" operation `r • x : M`\n  (where `r : R` and `x : M`) with some natural associativity and\n  distributivity axioms similar to those on a ring. -/\n@[ext]\nclass Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends\n  DistribMulAction R M where\n  /-- Scalar multiplication distributes over addition from the right. -/\n  protected add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x\n  /-- Scalar multiplication by zero gives zero. -/\n  protected zero_smul : ∀ x : M, (0 : R) • x = 0\n\n"}
{"name":"Module.ext_iff","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nx y : Module R M\n⊢ Iff (Eq x y) (Eq SMul.smul SMul.smul)","decl":"/-- A module is a generalization of vector spaces to a scalar semiring.\n  It consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,\n  connected by a \"scalar multiplication\" operation `r • x : M`\n  (where `r : R` and `x : M`) with some natural associativity and\n  distributivity axioms similar to those on a ring. -/\n@[ext]\nclass Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends\n  DistribMulAction R M where\n  /-- Scalar multiplication distributes over addition from the right. -/\n  protected add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x\n  /-- Scalar multiplication by zero gives zero. -/\n  protected zero_smul : ∀ x : M, (0 : R) • x = 0\n\n"}
{"name":"Module.zero_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nself : Module R M\nx : M\n⊢ Eq (HSMul.hSMul 0 x) 0","decl":"/-- A module is a generalization of vector spaces to a scalar semiring.\n  It consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,\n  connected by a \"scalar multiplication\" operation `r • x : M`\n  (where `r : R` and `x : M`) with some natural associativity and\n  distributivity axioms similar to those on a ring. -/\n@[ext]\nclass Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends\n  DistribMulAction R M where\n  /-- Scalar multiplication distributes over addition from the right. -/\n  protected add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x\n  /-- Scalar multiplication by zero gives zero. -/\n  protected zero_smul : ∀ x : M, (0 : R) • x = 0\n\n"}
{"name":"Module.add_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u\nM : Type v\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nself : Module R M\nr s : R\nx : M\n⊢ Eq (HSMul.hSMul (HAdd.hAdd r s) x) (HAdd.hAdd (HSMul.hSMul r x) (HSMul.hSMul s x))","decl":"/-- A module is a generalization of vector spaces to a scalar semiring.\n  It consists of a scalar semiring `R` and an additive monoid of \"vectors\" `M`,\n  connected by a \"scalar multiplication\" operation `r • x : M`\n  (where `r : R` and `x : M`) with some natural associativity and\n  distributivity axioms similar to those on a ring. -/\n@[ext]\nclass Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends\n  DistribMulAction R M where\n  /-- Scalar multiplication distributes over addition from the right. -/\n  protected add_smul : ∀ (r s : R) (x : M), (r + s) • x = r • x + s • x\n  /-- Scalar multiplication by zero gives zero. -/\n  protected zero_smul : ∀ x : M, (0 : R) • x = 0\n\n"}
{"name":"add_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr s : R\nx : M\n⊢ Eq (HSMul.hSMul (HAdd.hAdd r s) x) (HAdd.hAdd (HSMul.hSMul r x) (HSMul.hSMul s x))","decl":"theorem add_smul : (r + s) • x = r • x + s • x :=\n  Module.add_smul r s x\n\n"}
{"name":"Convex.combo_self","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na b : R\nh : Eq (HAdd.hAdd a b) 1\nx : M\n⊢ Eq (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b x)) x","decl":"theorem Convex.combo_self {a b : R} (h : a + b = 1) (x : M) : a • x + b • x = x := by\n  rw [← add_smul, h, one_smul]\n\n"}
{"name":"two_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Eq (HSMul.hSMul 2 x) (HAdd.hAdd x x)","decl":"theorem two_smul : (2 : R) • x = x + x := by rw [← one_add_one_eq_two, add_smul, one_smul]\n\n"}
{"name":"Module.eq_zero_of_zero_eq_one","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\nzero_eq_one : Eq 0 1\n⊢ Eq x 0","decl":"theorem Module.eq_zero_of_zero_eq_one (zero_eq_one : (0 : R) = 1) : x = 0 := by\n  rw [← one_smul R x, ← zero_eq_one, zero_smul]\n\n"}
{"name":"smul_add_one_sub_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"M : Type u_3\ninst✝² : AddCommMonoid M\nR : Type u_5\ninst✝¹ : Ring R\ninst✝ : Module R M\nr : R\nm : M\n⊢ Eq (HAdd.hAdd (HSMul.hSMul r m) (HSMul.hSMul (HSub.hSub 1 r) m)) m","decl":"@[simp]\ntheorem smul_add_one_sub_smul {R : Type*} [Ring R] [Module R M] {r : R} {m : M} :\n    r • m + (1 - r) • m = m := by rw [← add_smul, add_sub_cancel, one_smul]\n\n"}
{"name":"Convex.combo_eq_smul_sub_add","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\na b : R\nh : Eq (HAdd.hAdd a b) 1\n⊢ Eq (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y)) (HAdd.hAdd (HSMul.hSMul b (HSub.hSub y x)) x)","decl":"theorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :\n    a • x + b • y = b • (y - x) + x :=\n  calc\n    a • x + b • y = b • y - b • x + (a • x + b • x) := by rw [sub_add_add_cancel, add_comm]\n    _ = b • (y - x) + x := by rw [smul_sub, Convex.combo_self h]\n\n"}
{"name":"Module.ext'","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_5\ninst✝¹ : Semiring R\nM : Type u_6\ninst✝ : AddCommMonoid M\nP Q : Module R M\nw : ∀ (r : R) (m : M), Eq (HSMul.hSMul r m) (HSMul.hSMul r m)\n⊢ Eq P Q","decl":"/-- A variant of `Module.ext` that's convenient for term-mode. -/\ntheorem Module.ext' {R : Type*} [Semiring R] {M : Type*} [AddCommMonoid M] (P Q : Module R M)\n    (w : ∀ (r : R) (m : M), (haveI := P; r • m) = (haveI := Q; r • m)) :\n    P = Q := by\n  ext\n  exact w _ _\n\n"}
{"name":"neg_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nx : M\n⊢ Eq (HSMul.hSMul (Neg.neg r) x) (Neg.neg (HSMul.hSMul r x))","decl":"@[simp]\ntheorem neg_smul : -r • x = -(r • x) :=\n  eq_neg_of_add_eq_zero_left <| by rw [← add_smul, neg_add_cancel, zero_smul]\n\n"}
{"name":"neg_smul_neg","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nx : M\n⊢ Eq (HSMul.hSMul (Neg.neg r) (Neg.neg x)) (HSMul.hSMul r x)","decl":"theorem neg_smul_neg : -r • -x = r • x := by rw [neg_smul, smul_neg, neg_neg]\n\n"}
{"name":"neg_one_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\n⊢ Eq (HSMul.hSMul (-1) x) (Neg.neg x)","decl":"theorem neg_one_smul (x : M) : (-1 : R) • x = -x := by simp\n\n"}
{"name":"sub_smul","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr s : R\ny : M\n⊢ Eq (HSMul.hSMul (HSub.hSub r s) y) (HSub.hSub (HSMul.hSMul r y) (HSMul.hSMul s y))","decl":"theorem sub_smul (r s : R) (y : M) : (r - s) • y = r • y - s • y := by\n  simp [add_smul, sub_eq_add_neg]\n\n"}
{"name":"Module.subsingleton","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_5\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : Subsingleton R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Subsingleton M","decl":"/-- A module over a `Subsingleton` semiring is a `Subsingleton`. We cannot register this\nas an instance because Lean has no way to guess `R`. -/\nprotected theorem Module.subsingleton (R M : Type*) [Semiring R] [Subsingleton R] [AddCommMonoid M]\n    [Module R M] : Subsingleton M :=\n  MulActionWithZero.subsingleton R M\n\n"}
{"name":"Module.nontrivial","module":"Mathlib.Algebra.Module.Defs","initialProofState":"R : Type u_5\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : Nontrivial M\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Nontrivial R","decl":"/-- A semiring is `Nontrivial` provided that there exists a nontrivial module over this semiring. -/\nprotected theorem Module.nontrivial (R M : Type*) [Semiring R] [Nontrivial M] [AddCommMonoid M]\n    [Module R M] : Nontrivial R :=\n  MulActionWithZero.nontrivial R M\n\n-- see Note [lower instance priority]\n"}
