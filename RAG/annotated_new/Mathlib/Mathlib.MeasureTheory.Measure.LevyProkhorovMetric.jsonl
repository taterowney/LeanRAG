{"name":"MeasureTheory.meas_le_of_le_of_forall_le_meas_thickening_add","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒµ‚ÇÅ Œµ‚ÇÇ : ENNReal\nŒº ŒΩ : MeasureTheory.Measure Œ©\nh_le : LE.le Œµ‚ÇÅ Œµ‚ÇÇ\nB : Set Œ©\nhŒµ‚ÇÅ : LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening Œµ‚ÇÅ.toReal B)) Œµ‚ÇÅ)\n‚ä¢ LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening Œµ‚ÇÇ.toReal B)) Œµ‚ÇÇ)","decl":"lemma meas_le_of_le_of_forall_le_meas_thickening_add {Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0‚àû} (Œº ŒΩ : Measure Œ©)\n    (h_le : Œµ‚ÇÅ ‚â§ Œµ‚ÇÇ) {B : Set Œ©} (hŒµ‚ÇÅ : Œº B ‚â§ ŒΩ (thickening Œµ‚ÇÅ.toReal B) + Œµ‚ÇÅ) :\n    Œº B ‚â§ ŒΩ (thickening Œµ‚ÇÇ.toReal B) + Œµ‚ÇÇ := by\n  by_cases Œµ_top : Œµ‚ÇÇ = ‚àû\n  ¬∑ simp only [ne_eq, FiniteMeasure.ennreal_coeFn_eq_coeFn_toMeasure, Œµ_top, top_toReal,\n                add_top, le_top]\n  apply hŒµ‚ÇÅ.trans (add_le_add ?_ h_le)\n  exact measure_mono (Œº := ŒΩ) (thickening_mono (toReal_mono Œµ_top h_le) B)\n\n"}
{"name":"MeasureTheory.left_measure_le_of_levyProkhorovEDist_lt","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nc : ENNReal\nh : LT.lt (MeasureTheory.levyProkhorovEDist Œº ŒΩ) c\nB : Set Œ©\nB_mble : MeasurableSet B\n‚ä¢ LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening c.toReal B)) c)","decl":"lemma left_measure_le_of_levyProkhorovEDist_lt {Œº ŒΩ : Measure Œ©} {c : ‚Ñù‚â•0‚àû}\n    (h : levyProkhorovEDist Œº ŒΩ < c) {B : Set Œ©} (B_mble : MeasurableSet B) :\n    Œº B ‚â§ ŒΩ (thickening c.toReal B) + c := by\n  obtain ‚ü®c', ‚ü®hc', lt_c‚ü©‚ü© := sInf_lt_iff.mp h\n  exact meas_le_of_le_of_forall_le_meas_thickening_add Œº ŒΩ lt_c.le (hc' B B_mble).1\n\n"}
{"name":"MeasureTheory.right_measure_le_of_levyProkhorovEDist_lt","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nc : ENNReal\nh : LT.lt (MeasureTheory.levyProkhorovEDist Œº ŒΩ) c\nB : Set Œ©\nB_mble : MeasurableSet B\n‚ä¢ LE.le (ŒΩ B) (HAdd.hAdd (Œº (Metric.thickening c.toReal B)) c)","decl":"lemma right_measure_le_of_levyProkhorovEDist_lt {Œº ŒΩ : Measure Œ©} {c : ‚Ñù‚â•0‚àû}\n    (h : levyProkhorovEDist Œº ŒΩ < c) {B : Set Œ©} (B_mble : MeasurableSet B) :\n    ŒΩ B ‚â§ Œº (thickening c.toReal B) + c := by\n  obtain ‚ü®c', ‚ü®hc', lt_c‚ü©‚ü© := sInf_lt_iff.mp h\n  exact meas_le_of_le_of_forall_le_meas_thickening_add ŒΩ Œº lt_c.le (hc' B B_mble).2\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_le_of_forall_add_pos_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nŒ¥ : ENNReal\nh : ‚àÄ (Œµ : ENNReal) (B : Set Œ©), LT.lt 0 Œµ ‚Üí LT.lt Œµ Top.top ‚Üí MeasurableSet B ‚Üí And (LE.le (Œº B) (HAdd.hAdd (HAdd.hAdd (ŒΩ (Metric.thickening (HAdd.hAdd Œ¥ Œµ).toReal B)) Œ¥) Œµ)) (LE.le (ŒΩ B) (HAdd.hAdd (HAdd.hAdd (Œº (Metric.thickening (HAdd.hAdd Œ¥ Œµ).toReal B)) Œ¥) Œµ))\n‚ä¢ LE.le (MeasureTheory.levyProkhorovEDist Œº ŒΩ) Œ¥","decl":"/-- A general sufficient condition for bounding `levyProkhorovEDist` from above. -/\nlemma levyProkhorovEDist_le_of_forall_add_pos_le (Œº ŒΩ : Measure Œ©) (Œ¥ : ‚Ñù‚â•0‚àû)\n    (h : ‚àÄ Œµ B, 0 < Œµ ‚Üí Œµ < ‚àû ‚Üí MeasurableSet B ‚Üí\n      Œº B ‚â§ ŒΩ (thickening (Œ¥ + Œµ).toReal B) + Œ¥ + Œµ ‚àß\n      ŒΩ B ‚â§ Œº (thickening (Œ¥ + Œµ).toReal B) + Œ¥ + Œµ) :\n    levyProkhorovEDist Œº ŒΩ ‚â§ Œ¥ := by\n  apply ENNReal.le_of_forall_pos_le_add\n  intro Œµ hŒµ _\n  by_cases Œµ_top : Œµ = ‚àû\n  ¬∑ simp only [Œµ_top, add_top, le_top]\n  apply sInf_le\n  intro B B_mble\n  simpa only [add_assoc] using h Œµ B (coe_pos.mpr hŒµ) coe_lt_top B_mble\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_le_of_forall","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nŒ¥ : ENNReal\nh : ‚àÄ (Œµ : ENNReal) (B : Set Œ©), LT.lt Œ¥ Œµ ‚Üí LT.lt Œµ Top.top ‚Üí MeasurableSet B ‚Üí And (LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening Œµ.toReal B)) Œµ)) (LE.le (ŒΩ B) (HAdd.hAdd (Œº (Metric.thickening Œµ.toReal B)) Œµ))\n‚ä¢ LE.le (MeasureTheory.levyProkhorovEDist Œº ŒΩ) Œ¥","decl":"/-- A simple general sufficient condition for bounding `levyProkhorovEDist` from above. -/\nlemma levyProkhorovEDist_le_of_forall (Œº ŒΩ : Measure Œ©) (Œ¥ : ‚Ñù‚â•0‚àû)\n    (h : ‚àÄ Œµ B, Œ¥ < Œµ ‚Üí Œµ < ‚àû ‚Üí MeasurableSet B ‚Üí\n        Œº B ‚â§ ŒΩ (thickening Œµ.toReal B) + Œµ ‚àß ŒΩ B ‚â§ Œº (thickening Œµ.toReal B) + Œµ) :\n    levyProkhorovEDist Œº ŒΩ ‚â§ Œ¥ := by\n  by_cases Œ¥_top : Œ¥ = ‚àû\n  ¬∑ simp only [Œ¥_top, add_top, le_top]\n  apply levyProkhorovEDist_le_of_forall_add_pos_le\n  intro x B x_pos x_lt_top B_mble\n  simpa only [‚Üê add_assoc] using h (Œ¥ + x) B (ENNReal.lt_add_right Œ¥_top x_pos.ne.symm)\n    (by simp only [add_lt_top, Ne.lt_top Œ¥_top, x_lt_top, and_self]) B_mble\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_le_max_measure_univ","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\n‚ä¢ LE.le (MeasureTheory.levyProkhorovEDist Œº ŒΩ) (Max.max (Œº Set.univ) (ŒΩ Set.univ))","decl":"lemma levyProkhorovEDist_le_max_measure_univ (Œº ŒΩ : Measure Œ©) :\n    levyProkhorovEDist Œº ŒΩ ‚â§ max (Œº univ) (ŒΩ univ) := by\n  refine sInf_le fun B _ ‚Ü¶ ‚ü®?_, ?_‚ü© <;> apply le_add_left <;> simp [measure_mono]\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_lt_top","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≥ : MeasurableSpace Œ©\ninst‚úù¬≤ : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : MeasureTheory.IsFiniteMeasure ŒΩ\n‚ä¢ LT.lt (MeasureTheory.levyProkhorovEDist Œº ŒΩ) Top.top","decl":"lemma levyProkhorovEDist_lt_top (Œº ŒΩ : Measure Œ©) [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] :\n    levyProkhorovEDist Œº ŒΩ < ‚àû :=\n  (levyProkhorovEDist_le_max_measure_univ Œº ŒΩ).trans_lt <| by simp [measure_lt_top]\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_ne_top","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≥ : MeasurableSpace Œ©\ninst‚úù¬≤ : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : MeasureTheory.IsFiniteMeasure ŒΩ\n‚ä¢ Ne (MeasureTheory.levyProkhorovEDist Œº ŒΩ) Top.top","decl":"lemma levyProkhorovEDist_ne_top (Œº ŒΩ : Measure Œ©) [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] :\n    levyProkhorovEDist Œº ŒΩ ‚â† ‚àû := (levyProkhorovEDist_lt_top Œº ŒΩ).ne\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_self","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ Eq (MeasureTheory.levyProkhorovEDist Œº Œº) 0","decl":"lemma levyProkhorovEDist_self (Œº : Measure Œ©) :\n    levyProkhorovEDist Œº Œº = 0 := by\n  rw [‚Üê nonpos_iff_eq_zero, ‚Üê csInf_Ioo zero_lt_top]\n  refine sInf_le_sInf fun Œµ ‚ü®hŒµ‚ÇÄ, hŒµ_top‚ü© B _ ‚Ü¶ and_self_iff.2 ?_\n  refine le_add_right <| measure_mono <| self_subset_thickening ?_ _\n  exact ENNReal.toReal_pos hŒµ‚ÇÄ.ne' hŒµ_top.ne\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_comm","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\n‚ä¢ Eq (MeasureTheory.levyProkhorovEDist Œº ŒΩ) (MeasureTheory.levyProkhorovEDist ŒΩ Œº)","decl":"lemma levyProkhorovEDist_comm (Œº ŒΩ : Measure Œ©) :\n    levyProkhorovEDist Œº ŒΩ = levyProkhorovEDist ŒΩ Œº := by\n  simp only [levyProkhorovEDist, and_comm]\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_triangle","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoEMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nŒº ŒΩ Œ∫ : MeasureTheory.Measure Œ©\n‚ä¢ LE.le (MeasureTheory.levyProkhorovEDist Œº Œ∫) (HAdd.hAdd (MeasureTheory.levyProkhorovEDist Œº ŒΩ) (MeasureTheory.levyProkhorovEDist ŒΩ Œ∫))","decl":"lemma levyProkhorovEDist_triangle [OpensMeasurableSpace Œ©] (Œº ŒΩ Œ∫ : Measure Œ©) :\n    levyProkhorovEDist Œº Œ∫ ‚â§ levyProkhorovEDist Œº ŒΩ + levyProkhorovEDist ŒΩ Œ∫ := by\n  by_cases LPŒºŒΩ_finite : levyProkhorovEDist Œº ŒΩ = ‚àû\n  ¬∑ simp [LPŒºŒΩ_finite]\n  by_cases LPŒΩŒ∫_finite : levyProkhorovEDist ŒΩ Œ∫ = ‚àû\n  ¬∑ simp [LPŒΩŒ∫_finite]\n  apply levyProkhorovEDist_le_of_forall_add_pos_le\n  intro Œµ B Œµ_pos Œµ_lt_top B_mble\n  have half_Œµ_pos : 0 < Œµ / 2 := ENNReal.div_pos Œµ_pos.ne' ofNat_ne_top\n  have half_Œµ_lt_top : Œµ / 2 < ‚àû := ENNReal.div_lt_top Œµ_lt_top.ne two_ne_zero\n  let r := levyProkhorovEDist Œº ŒΩ + Œµ / 2\n  let s := levyProkhorovEDist ŒΩ Œ∫ + Œµ / 2\n  have lt_r : levyProkhorovEDist Œº ŒΩ < r := lt_add_right LPŒºŒΩ_finite half_Œµ_pos.ne'\n  have lt_s : levyProkhorovEDist ŒΩ Œ∫ < s := lt_add_right LPŒΩŒ∫_finite half_Œµ_pos.ne'\n  have hs_add_r : s + r = levyProkhorovEDist Œº ŒΩ + levyProkhorovEDist ŒΩ Œ∫ + Œµ := by\n    simp_rw [s, r, add_assoc, add_comm (Œµ / 2), add_assoc, ENNReal.add_halves, ‚Üê add_assoc,\n      add_comm (levyProkhorovEDist Œº ŒΩ)]\n  have hs_add_r' : s.toReal + r.toReal\n      = (levyProkhorovEDist Œº ŒΩ + levyProkhorovEDist ŒΩ Œ∫ + Œµ).toReal := by\n    rw [‚Üê hs_add_r, ‚Üê ENNReal.toReal_add]\n    ¬∑ exact ENNReal.add_ne_top.mpr ‚ü®LPŒΩŒ∫_finite, half_Œµ_lt_top.ne‚ü©\n    ¬∑ exact ENNReal.add_ne_top.mpr ‚ü®LPŒºŒΩ_finite, half_Œµ_lt_top.ne‚ü©\n  rw [‚Üê hs_add_r', add_assoc, ‚Üê hs_add_r, add_assoc _ _ Œµ, ‚Üê hs_add_r]\n  refine ‚ü®?_, ?_‚ü©\n  ¬∑ calc Œº B ‚â§ ŒΩ (thickening r.toReal B) + r :=\n      left_measure_le_of_levyProkhorovEDist_lt lt_r B_mble\n    _ ‚â§ Œ∫ (thickening s.toReal (thickening r.toReal B)) + s + r :=\n      add_le_add_right\n        (left_measure_le_of_levyProkhorovEDist_lt lt_s isOpen_thickening.measurableSet) _\n    _ = Œ∫ (thickening s.toReal (thickening r.toReal B)) + (s + r) := add_assoc _ _ _\n    _ ‚â§ Œ∫ (thickening (s.toReal + r.toReal) B) + (s + r) :=\n      add_le_add_right (measure_mono (thickening_thickening_subset _ _ _)) _\n  ¬∑ calc Œ∫ B ‚â§ ŒΩ (thickening s.toReal B) + s :=\n      right_measure_le_of_levyProkhorovEDist_lt lt_s B_mble\n    _ ‚â§ Œº (thickening r.toReal (thickening s.toReal B)) + r + s :=\n      add_le_add_right\n        (right_measure_le_of_levyProkhorovEDist_lt lt_r isOpen_thickening.measurableSet) s\n    _ = Œº (thickening r.toReal (thickening s.toReal B)) + (s + r) := by rw [add_assoc, add_comm r]\n    _ ‚â§ Œº (thickening (r.toReal + s.toReal) B) + (s + r) :=\n      add_le_add_right (measure_mono (thickening_thickening_subset _ _ _)) _\n    _ = Œº (thickening (s.toReal + r.toReal) B) + (s + r) := by rw [add_comm r.toReal]\n\n"}
{"name":"MeasureTheory.levyProkhorovDist_self","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº : MeasureTheory.Measure Œ©\n‚ä¢ Eq (MeasureTheory.levyProkhorovDist Œº Œº) 0","decl":"lemma levyProkhorovDist_self (Œº : Measure Œ©) :\n    levyProkhorovDist Œº Œº = 0 := by\n  simp only [levyProkhorovDist, levyProkhorovEDist_self, zero_toReal]\n\n"}
{"name":"MeasureTheory.levyProkhorovDist_comm","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : PseudoEMetricSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\n‚ä¢ Eq (MeasureTheory.levyProkhorovDist Œº ŒΩ) (MeasureTheory.levyProkhorovDist ŒΩ Œº)","decl":"lemma levyProkhorovDist_comm (Œº ŒΩ : Measure Œ©) :\n    levyProkhorovDist Œº ŒΩ = levyProkhorovDist ŒΩ Œº := by\n  simp only [levyProkhorovDist, levyProkhorovEDist_comm]\n\n"}
{"name":"MeasureTheory.levyProkhorovDist_triangle","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù‚Åµ : MeasurableSpace Œ©\ninst‚úù‚Å¥ : PseudoEMetricSpace Œ©\ninst‚úù¬≥ : OpensMeasurableSpace Œ©\nŒº ŒΩ Œ∫ : MeasureTheory.Measure Œ©\ninst‚úù¬≤ : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure ŒΩ\ninst‚úù : MeasureTheory.IsFiniteMeasure Œ∫\n‚ä¢ LE.le (MeasureTheory.levyProkhorovDist Œº Œ∫) (HAdd.hAdd (MeasureTheory.levyProkhorovDist Œº ŒΩ) (MeasureTheory.levyProkhorovDist ŒΩ Œ∫))","decl":"lemma levyProkhorovDist_triangle [OpensMeasurableSpace Œ©] (Œº ŒΩ Œ∫ : Measure Œ©)\n    [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] [IsFiniteMeasure Œ∫] :\n    levyProkhorovDist Œº Œ∫ ‚â§ levyProkhorovDist Œº ŒΩ + levyProkhorovDist ŒΩ Œ∫ := by\n  have dŒºŒΩ_finite := (levyProkhorovEDist_lt_top Œº ŒΩ).ne\n  have dŒΩŒ∫_finite := (levyProkhorovEDist_lt_top ŒΩ Œ∫).ne\n  convert ENNReal.toReal_mono ?_ <| levyProkhorovEDist_triangle Œº ŒΩ Œ∫\n  ¬∑ simp only [levyProkhorovDist, ENNReal.toReal_add dŒºŒΩ_finite dŒΩŒ∫_finite]\n  ¬∑ exact ENNReal.add_ne_top.mpr ‚ü®dŒºŒΩ_finite, dŒΩŒ∫_finite‚ü©\n\n"}
{"name":"MeasureTheory.measure_le_measure_closure_of_levyProkhorovEDist_eq_zero","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoEMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nhLP : Eq (MeasureTheory.levyProkhorovEDist Œº ŒΩ) 0\ns : Set Œ©\ns_mble : MeasurableSet s\nh_finite : Exists fun Œ¥ => And (GT.gt Œ¥ 0) (Ne (ŒΩ (Metric.thickening Œ¥ s)) Top.top)\n‚ä¢ LE.le (Œº s) (ŒΩ (closure s))","decl":"lemma measure_le_measure_closure_of_levyProkhorovEDist_eq_zero {Œº ŒΩ : Measure Œ©}\n    (hLP : levyProkhorovEDist Œº ŒΩ = 0) {s : Set Œ©} (s_mble : MeasurableSet s)\n    (h_finite : ‚àÉ Œ¥ > 0, ŒΩ (thickening Œ¥ s) ‚â† ‚àû) :\n    Œº s ‚â§ ŒΩ (closure s) := by\n  have key : Tendsto (fun Œµ ‚Ü¶ ŒΩ (thickening Œµ.toReal s)) (ùìù[>] (0 : ‚Ñù‚â•0‚àû)) (ùìù (ŒΩ (closure s))) := by\n    have aux : Tendsto ENNReal.toReal (ùìù[>] 0) (ùìù[>] 0) := by\n      apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within (s := Ioi 0) ENNReal.toReal\n      ¬∑ exact tendsto_nhdsWithin_of_tendsto_nhds (continuousAt_toReal zero_ne_top).tendsto\n      ¬∑ filter_upwards [Ioo_mem_nhdsGT zero_lt_one] with x hx\n        exact toReal_pos hx.1.ne.symm <| ne_top_of_lt hx.2\n    exact (tendsto_measure_thickening h_finite).comp aux\n  have obs := Tendsto.add key (tendsto_nhdsWithin_of_tendsto_nhds tendsto_id)\n  simp only [id_eq, add_zero] at obs\n  apply ge_of_tendsto (b := Œº s) obs\n  filter_upwards [self_mem_nhdsWithin] with Œµ Œµ_pos\n  exact left_measure_le_of_levyProkhorovEDist_lt (B_mble := s_mble) (hLP ‚ñ∏ Œµ_pos)\n\n"}
{"name":"MeasureTheory.measure_eq_measure_of_levyProkhorovEDist_eq_zero_of_isClosed","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoEMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\nhLP : Eq (MeasureTheory.levyProkhorovEDist Œº ŒΩ) 0\ns : Set Œ©\ns_closed : IsClosed s\nhŒºs : Exists fun Œ¥ => And (GT.gt Œ¥ 0) (Ne (Œº (Metric.thickening Œ¥ s)) Top.top)\nhŒΩs : Exists fun Œ¥ => And (GT.gt Œ¥ 0) (Ne (ŒΩ (Metric.thickening Œ¥ s)) Top.top)\n‚ä¢ Eq (Œº s) (ŒΩ s)","decl":"/-- Two measures at vanishing L√©vy-Prokhorov distance from each other assign the same values to all\nclosed sets. -/\nlemma measure_eq_measure_of_levyProkhorovEDist_eq_zero_of_isClosed {Œº ŒΩ : Measure Œ©}\n    (hLP : levyProkhorovEDist Œº ŒΩ = 0) {s : Set Œ©} (s_closed : IsClosed s)\n    (hŒºs : ‚àÉ Œ¥ > 0, Œº (thickening Œ¥ s) ‚â† ‚àû) (hŒΩs : ‚àÉ Œ¥ > 0, ŒΩ (thickening Œ¥ s) ‚â† ‚àû) :\n    Œº s = ŒΩ s := by\n  apply le_antisymm\n  ¬∑ exact measure_le_measure_closure_of_levyProkhorovEDist_eq_zero\n      hLP s_closed.measurableSet hŒΩs |>.trans <|\n      le_of_eq (congr_arg _ s_closed.closure_eq)\n  ¬∑ exact measure_le_measure_closure_of_levyProkhorovEDist_eq_zero\n      (levyProkhorovEDist_comm Œº ŒΩ ‚ñ∏ hLP) s_closed.measurableSet hŒºs |>.trans <|\n      le_of_eq (congr_arg _ s_closed.closure_eq)\n\n"}
{"name":"MeasureTheory.LevyProkhorov.dist_def","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoEMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.LevyProkhorov (MeasureTheory.ProbabilityMeasure Œ©)\n‚ä¢ Eq (Dist.dist Œº ŒΩ) (MeasureTheory.levyProkhorovDist ‚ÜëŒº ‚ÜëŒΩ)","decl":"lemma LevyProkhorov.dist_def (Œº ŒΩ : LevyProkhorov (ProbabilityMeasure Œ©)) :\n    dist Œº ŒΩ = levyProkhorovDist Œº.toMeasure ŒΩ.toMeasure := rfl\n\n"}
{"name":"MeasureTheory.levyProkhorovEDist_le_of_forall_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace Œ©\ninst‚úù¬≥ : PseudoEMetricSpace Œ©\ninst‚úù¬≤ : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\ninst‚úù¬π : MeasureTheory.IsProbabilityMeasure Œº\ninst‚úù : MeasureTheory.IsProbabilityMeasure ŒΩ\nŒ¥ : ENNReal\nh : ‚àÄ (Œµ : ENNReal) (B : Set Œ©), LT.lt Œ¥ Œµ ‚Üí LT.lt Œµ Top.top ‚Üí MeasurableSet B ‚Üí LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening Œµ.toReal B)) Œµ)\n‚ä¢ LE.le (MeasureTheory.levyProkhorovEDist Œº ŒΩ) Œ¥","decl":"/-- A simple sufficient condition for bounding `levyProkhorovEDist` between probability measures\nfrom above. The condition involves only one of two natural bounds, the other bound is for free. -/\nlemma levyProkhorovEDist_le_of_forall_le\n    (Œº ŒΩ : Measure Œ©) [IsProbabilityMeasure Œº] [IsProbabilityMeasure ŒΩ] (Œ¥ : ‚Ñù‚â•0‚àû)\n    (h : ‚àÄ Œµ B, Œ¥ < Œµ ‚Üí Œµ < ‚àû ‚Üí MeasurableSet B ‚Üí Œº B ‚â§ ŒΩ (thickening Œµ.toReal B) + Œµ) :\n    levyProkhorovEDist Œº ŒΩ ‚â§ Œ¥ := by\n  apply levyProkhorovEDist_le_of_forall Œº ŒΩ Œ¥\n  intro Œµ B Œµ_gt Œµ_lt_top B_mble\n  refine ‚ü®h Œµ B Œµ_gt Œµ_lt_top B_mble, ?_‚ü©\n  have B_subset := subset_compl_thickening_compl_thickening_self Œµ.toReal B\n  apply (measure_mono (Œº := ŒΩ) B_subset).trans\n  rw [prob_compl_eq_one_sub isOpen_thickening.measurableSet]\n  have Tc_mble := (isOpen_thickening (Œ¥ := Œµ.toReal) (E := B)).isClosed_compl.measurableSet\n  specialize h Œµ (thickening Œµ.toReal B)·∂ú Œµ_gt Œµ_lt_top Tc_mble\n  rw [prob_compl_eq_one_sub isOpen_thickening.measurableSet] at h\n  have almost := add_le_add (c := Œº (thickening Œµ.toReal B)) h rfl.le\n  rw [tsub_add_cancel_of_le prob_le_one, add_assoc] at almost\n  apply (tsub_le_tsub_right almost _).trans\n  rw [ENNReal.add_sub_cancel_left (measure_ne_top ŒΩ _), add_comm Œµ]\n\n"}
{"name":"MeasureTheory.levyProkhorovDist_le_of_forall_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace Œ©\ninst‚úù¬≥ : PseudoEMetricSpace Œ©\ninst‚úù¬≤ : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\ninst‚úù¬π : MeasureTheory.IsProbabilityMeasure Œº\ninst‚úù : MeasureTheory.IsProbabilityMeasure ŒΩ\nŒ¥ : Real\nŒ¥_nn : LE.le 0 Œ¥\nh : ‚àÄ (Œµ : Real) (B : Set Œ©), LT.lt Œ¥ Œµ ‚Üí MeasurableSet B ‚Üí LE.le (Œº B) (HAdd.hAdd (ŒΩ (Metric.thickening Œµ B)) (ENNReal.ofReal Œµ))\n‚ä¢ LE.le (MeasureTheory.levyProkhorovDist Œº ŒΩ) Œ¥","decl":"/-- A simple sufficient condition for bounding `levyProkhorovDist` between probability measures\nfrom above. The condition involves only one of two natural bounds, the other bound is for free. -/\nlemma levyProkhorovDist_le_of_forall_le\n    (Œº ŒΩ : Measure Œ©) [IsProbabilityMeasure Œº] [IsProbabilityMeasure ŒΩ] {Œ¥ : ‚Ñù} (Œ¥_nn : 0 ‚â§ Œ¥)\n    (h : ‚àÄ Œµ B, Œ¥ < Œµ ‚Üí MeasurableSet B ‚Üí Œº B ‚â§ ŒΩ (thickening Œµ B) + ENNReal.ofReal Œµ) :\n    levyProkhorovDist Œº ŒΩ ‚â§ Œ¥ := by\n  apply toReal_le_of_le_ofReal Œ¥_nn\n  apply levyProkhorovEDist_le_of_forall_le\n  intro Œµ B Œµ_gt Œµ_lt_top B_mble\n  have Œµ_gt' : Œ¥ < Œµ.toReal := by\n    refine (ofReal_lt_ofReal_iff ?_).mp ?_\n    ¬∑ exact ENNReal.toReal_pos (ne_zero_of_lt Œµ_gt) Œµ_lt_top.ne\n    ¬∑ simpa [ofReal_toReal_eq_iff.mpr Œµ_lt_top.ne] using Œµ_gt\n  convert h Œµ.toReal B Œµ_gt' B_mble\n  exact (ENNReal.ofReal_toReal Œµ_lt_top.ne).symm\n\n"}
{"name":"MeasureTheory.BoundedContinuousFunction.integral_eq_integral_meas_le_of_hasFiniteIntegral","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ± : Type u_2\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : OpensMeasurableSpace Œ±\nf : BoundedContinuousFunction Œ± Real\nŒº : MeasureTheory.Measure Œ±\nf_nn : (MeasureTheory.ae Œº).EventuallyLE 0 ‚áëf\nhf : MeasureTheory.HasFiniteIntegral (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun œâ => f œâ) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 (Norm.norm f))) fun t => (Œº (setOf fun a => LE.le t (f a))).toReal)","decl":"/-- A version of the layer cake formula for bounded continuous functions which have finite integral:\n‚à´ f dŒº = ‚à´ t in (0, ‚Äñf‚Äñ], Œº {x | f(x) ‚â• t} dt. -/\nlemma BoundedContinuousFunction.integral_eq_integral_meas_le_of_hasFiniteIntegral\n    {Œ± : Type*} [MeasurableSpace Œ±] [TopologicalSpace Œ±] [OpensMeasurableSpace Œ±]\n    (f : Œ± ‚Üí·µá ‚Ñù) (Œº : Measure Œ±) (f_nn : 0 ‚â§·µê[Œº] f) (hf : HasFiniteIntegral f Œº) :\n    ‚à´ œâ, f œâ ‚àÇŒº = ‚à´ t in Ioc 0 ‚Äñf‚Äñ, ENNReal.toReal (Œº {a : Œ± | t ‚â§ f a}) := by\n  rw [Integrable.integral_eq_integral_Ioc_meas_le (M := ‚Äñf‚Äñ) ?_ f_nn ?_]\n  ¬∑ refine ‚ü®f.continuous.measurable.aestronglyMeasurable, hf‚ü©\n  ¬∑ exact Eventually.of_forall (fun x ‚Ü¶ BoundedContinuousFunction.apply_le_norm f x)\n\n"}
{"name":"MeasureTheory.BoundedContinuousFunction.integral_eq_integral_meas_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ± : Type u_2\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : OpensMeasurableSpace Œ±\nf : BoundedContinuousFunction Œ± Real\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf_nn : (MeasureTheory.ae Œº).EventuallyLE 0 ‚áëf\n‚ä¢ Eq (MeasureTheory.integral Œº fun œâ => f œâ) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 (Norm.norm f))) fun t => (Œº (setOf fun a => LE.le t (f a))).toReal)","decl":"/-- A version of the layer cake formula for bounded continuous functions and finite measures:\n‚à´ f dŒº = ‚à´ t in (0, ‚Äñf‚Äñ], Œº {x | f(x) ‚â• t} dt. -/\nlemma BoundedContinuousFunction.integral_eq_integral_meas_le\n    {Œ± : Type*} [MeasurableSpace Œ±] [TopologicalSpace Œ±] [OpensMeasurableSpace Œ±]\n    (f : Œ± ‚Üí·µá ‚Ñù) (Œº : Measure Œ±) [IsFiniteMeasure Œº] (f_nn : 0 ‚â§·µê[Œº] f) :\n    ‚à´ œâ, f œâ ‚àÇŒº = ‚à´ t in Ioc 0 ‚Äñf‚Äñ, ENNReal.toReal (Œº {a : Œ± | t ‚â§ f a}) :=\n  integral_eq_integral_meas_le_of_hasFiniteIntegral _ _ f_nn (f.integrable Œº).2\n\n"}
{"name":"MeasureTheory.BoundedContinuousFunction.integral_le_of_levyProkhorovEDist_lt","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace Œ©\ninst‚úù¬≥ : PseudoMetricSpace Œ©\ninst‚úù¬≤ : OpensMeasurableSpace Œ©\nŒº ŒΩ : MeasureTheory.Measure Œ©\ninst‚úù¬π : MeasureTheory.IsFiniteMeasure Œº\ninst‚úù : MeasureTheory.IsFiniteMeasure ŒΩ\nŒµ : Real\nŒµ_pos : LT.lt 0 Œµ\nhŒºŒΩ : LT.lt (MeasureTheory.levyProkhorovEDist Œº ŒΩ) (ENNReal.ofReal Œµ)\nf : BoundedContinuousFunction Œ© Real\nf_nn : (MeasureTheory.ae Œº).EventuallyLE 0 ‚áëf\n‚ä¢ LE.le (MeasureTheory.integral Œº fun œâ => f œâ) (HAdd.hAdd (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 (Norm.norm f))) fun t => (ŒΩ (Metric.thickening Œµ (setOf fun a => LE.le t (f a)))).toReal) (HMul.hMul Œµ (Norm.norm f)))","decl":"/-- Assuming `levyProkhorovEDist Œº ŒΩ < Œµ`, we can bound `‚à´ f ‚àÇŒº` in terms of\n`‚à´ t in (0, ‚Äñf‚Äñ], ŒΩ (thickening Œµ {x | f(x) ‚â• t}) dt` and `‚Äñf‚Äñ`. -/\nlemma BoundedContinuousFunction.integral_le_of_levyProkhorovEDist_lt (Œº ŒΩ : Measure Œ©)\n    [IsFiniteMeasure Œº] [IsFiniteMeasure ŒΩ] {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ)\n    (hŒºŒΩ : levyProkhorovEDist Œº ŒΩ < ENNReal.ofReal Œµ) (f : Œ© ‚Üí·µá ‚Ñù) (f_nn : 0 ‚â§·µê[Œº] f) :\n    ‚à´ œâ, f œâ ‚àÇŒº\n      ‚â§ (‚à´ t in Ioc 0 ‚Äñf‚Äñ, ENNReal.toReal (ŒΩ (thickening Œµ {a | t ‚â§ f a}))) + Œµ * ‚Äñf‚Äñ := by\n  rw [BoundedContinuousFunction.integral_eq_integral_meas_le f Œº f_nn]\n  have key : (fun (t : ‚Ñù) ‚Ü¶ ENNReal.toReal (Œº {a | t ‚â§ f a}))\n              ‚â§ (fun (t : ‚Ñù) ‚Ü¶ ENNReal.toReal (ŒΩ (thickening Œµ {a | t ‚â§ f a})) + Œµ) := by\n    intro t\n    convert ENNReal.toReal_mono ?_ <| left_measure_le_of_levyProkhorovEDist_lt hŒºŒΩ\n      (B := {a | t ‚â§ f a}) (f.continuous.measurable measurableSet_Ici)\n    ¬∑ rw [ENNReal.toReal_add (measure_ne_top ŒΩ _) ofReal_ne_top, ENNReal.toReal_ofReal Œµ_pos.le]\n    ¬∑ exact ENNReal.add_ne_top.mpr ‚ü®measure_ne_top ŒΩ _, ofReal_ne_top‚ü©\n  have intble‚ÇÅ : IntegrableOn (fun t ‚Ü¶ ENNReal.toReal (Œº {a | t ‚â§ f a})) (Ioc 0 ‚Äñf‚Äñ) := by\n    apply Measure.integrableOn_of_bounded (M := ENNReal.toReal (Œº univ)) measure_Ioc_lt_top.ne\n    ¬∑ apply (Measurable.ennreal_toReal (Antitone.measurable ?_)).aestronglyMeasurable\n      exact fun _ _ hst ‚Ü¶ measure_mono (fun _ h ‚Ü¶ hst.trans h)\n    ¬∑ apply Eventually.of_forall <| fun t ‚Ü¶ ?_\n      simp only [Real.norm_eq_abs, abs_toReal]\n      exact ENNReal.toReal_mono (measure_ne_top _ _) <| measure_mono (subset_univ _)\n  have intble‚ÇÇ : IntegrableOn\n                  (fun t ‚Ü¶ ENNReal.toReal (ŒΩ (thickening Œµ {a | t ‚â§ f a}))) (Ioc 0 ‚Äñf‚Äñ) := by\n    apply Measure.integrableOn_of_bounded (M := ENNReal.toReal (ŒΩ univ)) measure_Ioc_lt_top.ne\n    ¬∑ apply (Measurable.ennreal_toReal (Antitone.measurable ?_)).aestronglyMeasurable\n      exact fun _ _ hst ‚Ü¶ measure_mono <| thickening_subset_of_subset Œµ (fun _ h ‚Ü¶ hst.trans h)\n    ¬∑ apply Eventually.of_forall <| fun t ‚Ü¶ ?_\n      simp only [Real.norm_eq_abs, abs_toReal]\n      exact ENNReal.toReal_mono (measure_ne_top _ _) <| measure_mono (subset_univ _)\n  apply le_trans (setIntegral_mono (s := Ioc 0 ‚Äñf‚Äñ) ?_ ?_ key)\n  ¬∑ rw [integral_add]\n    ¬∑ apply add_le_add_left\n      simp only [integral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter,\n                  Real.volume_Ioc, sub_zero, norm_nonneg, toReal_ofReal, smul_eq_mul,\n                  (mul_comm _ Œµ).le]\n    ¬∑ exact intble‚ÇÇ\n    ¬∑ exact integrable_const Œµ\n  ¬∑ exact intble‚ÇÅ\n  ¬∑ exact intble‚ÇÇ.add <| integrable_const Œµ\n\n"}
{"name":"MeasureTheory.tendsto_integral_meas_thickening_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nf : BoundedContinuousFunction Œ© Real\nA : Set Real\nA_finmeas : Ne (MeasureTheory.MeasureSpace.volume A) Top.top\nŒº : MeasureTheory.ProbabilityMeasure Œ©\n‚ä¢ Filter.Tendsto (fun Œµ => MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict A) fun t => (‚Üë(Œº (Metric.thickening Œµ (setOf fun a => LE.le t (f a))))).toReal) (nhdsWithin 0 (Set.Ioi 0)) (nhds (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict A) fun t => (‚Üë(Œº (setOf fun a => LE.le t (f a)))).toReal))","decl":"/-- A monotone decreasing convergence lemma for integrals of measures of thickenings:\n`‚à´ t in (0, ‚Äñf‚Äñ], Œº (thickening Œµ {x | f(x) ‚â• t}) dt` tends to\n`‚à´ t in (0, ‚Äñf‚Äñ], Œº {x | f(x) ‚â• t} dt` as `Œµ ‚Üí 0`. -/\nlemma tendsto_integral_meas_thickening_le (f : Œ© ‚Üí·µá ‚Ñù)\n    {A : Set ‚Ñù} (A_finmeas : volume A ‚â† ‚àû) (Œº : ProbabilityMeasure Œ©) :\n    Tendsto (fun Œµ ‚Ü¶ ‚à´ t in A, ENNReal.toReal (Œº (thickening Œµ {a | t ‚â§ f a}))) (ùìù[>] (0 : ‚Ñù))\n      (ùìù (‚à´ t in A, ENNReal.toReal (Œº {a | t ‚â§ f a}))) := by\n  apply tendsto_integral_filter_of_dominated_convergence (G := ‚Ñù) (Œº := volume.restrict A)\n        (F := fun Œµ t ‚Ü¶ (Œº (thickening Œµ {a | t ‚â§ f a}))) (f := fun t ‚Ü¶ (Œº {a | t ‚â§ f a})) 1\n  ¬∑ apply Eventually.of_forall fun n ‚Ü¶ Measurable.aestronglyMeasurable ?_\n    simp only [measurable_coe_nnreal_real_iff]\n    apply measurable_toNNReal.comp <| Antitone.measurable (fun s t hst ‚Ü¶ ?_)\n    exact measure_mono <| thickening_subset_of_subset _ <| fun œâ h ‚Ü¶ hst.trans h\n  ¬∑ apply Eventually.of_forall (fun i ‚Ü¶ ?_)\n    apply Eventually.of_forall (fun t ‚Ü¶ ?_)\n    simp only [Real.norm_eq_abs, NNReal.abs_eq, Pi.one_apply]\n    exact ENNReal.toReal_mono one_ne_top prob_le_one\n  ¬∑ have aux : IsFiniteMeasure (volume.restrict A) := ‚ü®by simp [lt_top_iff_ne_top, A_finmeas]‚ü©\n    apply integrable_const\n  ¬∑ apply Eventually.of_forall (fun t ‚Ü¶ ?_)\n    simp only [NNReal.tendsto_coe]\n    apply (ENNReal.tendsto_toNNReal _).comp\n    ¬∑ apply tendsto_measure_thickening_of_isClosed ?_ ?_\n      ¬∑ exact ‚ü®1, ‚ü®Real.zero_lt_one, measure_ne_top _ _‚ü©‚ü©\n      ¬∑ exact isClosed_le continuous_const f.continuous\n    ¬∑ exact measure_ne_top _ _\n\n"}
{"name":"MeasureTheory.LevyProkhorov.continuous_equiv_probabilityMeasure","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\n‚ä¢ Continuous ‚áë(MeasureTheory.LevyProkhorov.equiv (MeasureTheory.ProbabilityMeasure Œ©))","decl":"/-- The identity map `LevyProkhorov (ProbabilityMeasure Œ©) ‚Üí ProbabilityMeasure Œ©` is continuous. -/\nlemma LevyProkhorov.continuous_equiv_probabilityMeasure :\n    Continuous (LevyProkhorov.equiv (Œ± := ProbabilityMeasure Œ©)) := by\n  refine SeqContinuous.continuous ?_\n  intro Œºs ŒΩ hŒºs\n  set P := LevyProkhorov.equiv _ ŒΩ -- more palatable notation\n  set Ps := fun n ‚Ü¶ LevyProkhorov.equiv _ (Œºs n) -- more palatable notation\n  rw [ProbabilityMeasure.tendsto_iff_forall_integral_tendsto]\n  refine fun f ‚Ü¶ tendsto_integral_of_forall_limsup_integral_le_integral ?_ f\n  intro f f_nn\n  by_cases f_zero : ‚Äñf‚Äñ = 0\n  ¬∑ simp only [norm_eq_zero] at f_zero\n    simp [f_zero, limsup_const]\n  have norm_f_pos : 0 < ‚Äñf‚Äñ := lt_of_le_of_ne (norm_nonneg _) (fun a => f_zero a.symm)\n  apply _root_.le_of_forall_pos_le_add\n  intro Œ¥ Œ¥_pos\n  apply limsup_le_of_le ?_\n  ¬∑ obtain ‚ü®Œµs, ‚ü®_, ‚ü®Œµs_pos, Œµs_lim‚ü©‚ü©‚ü© := exists_seq_strictAnti_tendsto (0 : ‚Ñù)\n    have Œµ_of_room := Tendsto.add (tendsto_iff_dist_tendsto_zero.mp hŒºs) Œµs_lim\n    have Œµ_of_room' : Tendsto (fun n ‚Ü¶ dist (Œºs n) ŒΩ + Œµs n) atTop (ùìù[>] 0) := by\n      rw [tendsto_nhdsWithin_iff]\n      refine ‚ü®by simpa using Œµ_of_room, Eventually.of_forall fun n ‚Ü¶ ?_‚ü©\n      ¬∑ rw [mem_Ioi]\n        linarith [Œµs_pos n, dist_nonneg (x := Œºs n) (y := ŒΩ)]\n    rw [add_zero] at Œµ_of_room\n    have key := (tendsto_integral_meas_thickening_le f (A := Ioc 0 ‚Äñf‚Äñ) (by simp) P).comp Œµ_of_room'\n    have aux : ‚àÄ (z : ‚Ñù), Iio (z + Œ¥/2) ‚àà ùìù z := fun z ‚Ü¶ Iio_mem_nhds (by linarith)\n    filter_upwards [key (aux _), Œµ_of_room <| Iio_mem_nhds <| half_pos <|\n                      mul_pos (inv_pos.mpr norm_f_pos) Œ¥_pos]\n      with n hn hn'\n    simp only [mem_preimage, mem_Iio] at *\n    specialize Œµs_pos n\n    have bound := BoundedContinuousFunction.integral_le_of_levyProkhorovEDist_lt\n                    (Ps n) P (Œµ := dist (Œºs n) ŒΩ + Œµs n) ?_ ?_ f ?_\n    ¬∑ refine bound.trans ?_\n      apply (add_le_add_right hn.le _).trans\n      rw [BoundedContinuousFunction.integral_eq_integral_meas_le]\n      ¬∑ simp only [ProbabilityMeasure.ennreal_coeFn_eq_coeFn_toMeasure]\n        rw [add_assoc, mul_comm]\n        gcongr\n        calc\n          Œ¥ / 2 + ‚Äñf‚Äñ * (dist (Œºs n) ŒΩ + Œµs n)\n          _ ‚â§ Œ¥ / 2 + ‚Äñf‚Äñ * (‚Äñf‚Äñ‚Åª¬π * Œ¥ / 2) := by gcongr\n          _ = Œ¥ := by field_simp; ring\n      ¬∑ exact Eventually.of_forall f_nn\n    ¬∑ positivity\n    ¬∑ rw [ENNReal.ofReal_add (by positivity) (by positivity), ‚Üê add_zero (levyProkhorovEDist _ _)]\n      apply ENNReal.add_lt_add_of_le_of_lt (levyProkhorovEDist_ne_top _ _)\n            (le_of_eq ?_) (ofReal_pos.mpr Œµs_pos)\n      rw [LevyProkhorov.dist_def, levyProkhorovDist, ofReal_toReal (levyProkhorovEDist_ne_top _ _)]\n      rfl\n    ¬∑ exact Eventually.of_forall f_nn\n  ¬∑ simp only [IsCoboundedUnder, IsCobounded, eventually_map, eventually_atTop,\n               forall_exists_index]\n    refine ‚ü®0, fun a i hia ‚Ü¶ le_trans (integral_nonneg f_nn) (hia i le_rfl)‚ü©\n\n"}
{"name":"MeasureTheory.levyProkhorov_le_convergenceInDistribution","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : PseudoMetricSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\n‚ä¢ LE.le (TopologicalSpace.coinduced (‚áë(MeasureTheory.LevyProkhorov.equiv (MeasureTheory.ProbabilityMeasure Œ©))) inferInstance) inferInstance","decl":"/-- The topology of the L√©vy-Prokhorov metric is at least as fine as the topology of convergence in\ndistribution. -/\ntheorem levyProkhorov_le_convergenceInDistribution :\n    TopologicalSpace.coinduced (LevyProkhorov.equiv (Œ± := ProbabilityMeasure Œ©)) inferInstance\n      ‚â§ (inferInstance : TopologicalSpace (ProbabilityMeasure Œ©)) :=\n  (LevyProkhorov.continuous_equiv_probabilityMeasure).coinduced_le\n\n"}
{"name":"MeasureTheory.ProbabilityMeasure.toMeasure_add_pos_gt_mem_nhds","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≤ : PseudoMetricSpace Œ©\ninst‚úù¬π : MeasurableSpace Œ©\ninst‚úù : OpensMeasurableSpace Œ©\nP : MeasureTheory.ProbabilityMeasure Œ©\nG : Set Œ©\nG_open : IsOpen G\nŒµ : ENNReal\nŒµ_pos : LT.lt 0 Œµ\n‚ä¢ Membership.mem (nhds P) (setOf fun Q => LT.lt (‚ÜëP G) (HAdd.hAdd (‚ÜëQ G) Œµ))","decl":"lemma ProbabilityMeasure.toMeasure_add_pos_gt_mem_nhds (P : ProbabilityMeasure Œ©)\n    {G : Set Œ©} (G_open : IsOpen G) {Œµ : ‚Ñù‚â•0‚àû} (Œµ_pos : 0 < Œµ) :\n    {Q | P.toMeasure G < Q.toMeasure G + Œµ} ‚àà ùìù P := by\n  by_cases easy : P.toMeasure G < Œµ\n  ¬∑ exact Eventually.of_forall (fun _ ‚Ü¶ lt_of_lt_of_le easy le_add_self)\n  by_cases Œµ_top : Œµ = ‚àû\n  ¬∑ simp [Œµ_top, measure_lt_top]\n  simp only [not_lt] at easy\n  have aux : P.toMeasure G - Œµ < liminf (fun Q ‚Ü¶ Q.toMeasure G) (ùìù P) := by\n    apply lt_of_lt_of_le (ENNReal.sub_lt_self (measure_lt_top _ _).ne _ _)\n        <| ProbabilityMeasure.le_liminf_measure_open_of_tendsto tendsto_id G_open\n    ¬∑ exact (lt_of_lt_of_le Œµ_pos easy).ne.symm\n    ¬∑ exact Œµ_pos.ne.symm\n  filter_upwards [gt_mem_sets_of_limsInf_gt (Œ± := ‚Ñù‚â•0‚àû) isBounded_ge_of_bot\n      (show P.toMeasure G - Œµ < limsInf ((ùìù P).map (fun Q ‚Ü¶ Q.toMeasure G)) from aux)] with Q hQ\n  simp only [preimage_setOf_eq, mem_setOf_eq] at hQ\n  convert ENNReal.add_lt_add_right Œµ_top hQ\n  exact (tsub_add_cancel_of_le easy).symm\n\n"}
{"name":"MeasureTheory.SeparableSpace.exists_measurable_partition_diam_le","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≥ : PseudoMetricSpace Œ©\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : OpensMeasurableSpace Œ©\ninst‚úù : TopologicalSpace.SeparableSpace Œ©\nŒµ : Real\nŒµ_pos : LT.lt 0 Œµ\n‚ä¢ Exists fun As => And (‚àÄ (n : Nat), MeasurableSet (As n)) (And (‚àÄ (n : Nat), Bornology.IsBounded (As n)) (And (‚àÄ (n : Nat), LE.le (Metric.diam (As n)) Œµ) (And (Eq (Set.iUnion fun n => As n) Set.univ) (Pairwise fun n m => Disjoint (As n) (As m)))))","decl":"variable (Œ©) in\n/-- In a separable pseudometric space, for any Œµ > 0 there exists a countable collection of\ndisjoint Borel measurable subsets of diameter at most Œµ that cover the whole space. -/\nlemma SeparableSpace.exists_measurable_partition_diam_le {Œµ : ‚Ñù} (Œµ_pos : 0 < Œµ) :\n    ‚àÉ (As : ‚Ñï ‚Üí Set Œ©), (‚àÄ n, MeasurableSet (As n)) ‚àß (‚àÄ n, Bornology.IsBounded (As n)) ‚àß\n        (‚àÄ n, diam (As n) ‚â§ Œµ) ‚àß (‚ãÉ n, As n = univ) ‚àß\n        (Pairwise (fun (n m : ‚Ñï) ‚Ü¶ Disjoint (As n) (As m))) := by\n  by_cases X_emp : IsEmpty Œ©\n  ¬∑ refine ‚ü®fun _ ‚Ü¶ ‚àÖ, fun _ ‚Ü¶ MeasurableSet.empty, fun _ ‚Ü¶ Bornology.isBounded_empty, ?_, ?_,\n            fun _ _ _ ‚Ü¶ disjoint_of_subsingleton‚ü©\n    ¬∑ intro n\n      simpa only [diam_empty] using LT.lt.le Œµ_pos\n    ¬∑ simp only [iUnion_empty]\n      apply Eq.symm\n      simp only [univ_eq_empty_iff, X_emp]\n  rw [not_isEmpty_iff] at X_emp\n  obtain ‚ü®xs, xs_dense‚ü© := exists_dense_seq Œ©\n  have half_Œµ_pos : 0 < Œµ / 2 := half_pos Œµ_pos\n  set Bs := fun n ‚Ü¶ Metric.ball (xs n) (Œµ/2)\n  set As := disjointed Bs\n  refine ‚ü®As, ?_, ?_, ?_, ?_, ?_‚ü©\n  ¬∑ exact MeasurableSet.disjointed (fun n ‚Ü¶ measurableSet_ball)\n  ¬∑ exact fun n ‚Ü¶ Bornology.IsBounded.subset isBounded_ball <| disjointed_subset Bs n\n  ¬∑ intro n\n    apply (diam_mono (disjointed_subset Bs n) isBounded_ball).trans\n    convert diam_ball half_Œµ_pos.le\n    ring\n  ¬∑ have aux : ‚ãÉ n, Bs n = univ := by\n      convert DenseRange.iUnion_uniformity_ball xs_dense <| Metric.dist_mem_uniformity half_Œµ_pos\n      exact (ball_eq_ball' _ _).symm\n    simpa only [‚Üê aux] using iUnion_disjointed\n  ¬∑ exact disjoint_disjointed Bs\n\n"}
{"name":"MeasureTheory.LevyProkhorov.continuous_equiv_symm_probabilityMeasure","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≥ : PseudoMetricSpace Œ©\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : OpensMeasurableSpace Œ©\ninst‚úù : TopologicalSpace.SeparableSpace Œ©\n‚ä¢ Continuous ‚áë(MeasureTheory.LevyProkhorov.equiv (MeasureTheory.ProbabilityMeasure Œ©)).symm","decl":"lemma LevyProkhorov.continuous_equiv_symm_probabilityMeasure :\n    Continuous (LevyProkhorov.equiv (Œ± := ProbabilityMeasure Œ©)).symm := by\n  -- We check continuity of `id : ProbabilityMeasure Œ© ‚Üí LevyProkhorov (ProbabilityMeasure Œ©)` at\n  -- each point `P : ProbabilityMeasure Œ©`.\n  rw [continuous_iff_continuousAt]\n  intro P\n  -- To check continuity, fix `Œµ > 0`. To leave some wiggle room, be ready to use `Œµ/3 > 0` instead.\n  rw [continuousAt_iff']\n  intro Œµ Œµ_pos\n  have third_Œµ_pos : 0 < Œµ / 3 := by linarith\n  have third_Œµ_pos' : 0 < ENNReal.ofReal (Œµ / 3) := ofReal_pos.mpr third_Œµ_pos\n  -- First use separability to choose a countable partition of `Œ©` into measurable\n  -- subsets `Es n ‚äÜ Œ©` of small diameter, `diam (Es n) < Œµ/3`.\n  obtain ‚ü®Es, Es_mble, Es_bdd, Es_diam, Es_cover, Es_disjoint‚ü© :=\n    SeparableSpace.exists_measurable_partition_diam_le Œ© third_Œµ_pos\n  -- Instead of the whole space `Œ© = ‚ãÉ n ‚àà ‚Ñï, Es n`, focus on a large but finite\n  -- union `‚ãÉ n < N, Es n`, chosen in such a way that the complement has small `P`-mass,\n  -- `P (‚ãÉ n < N, Es n)·∂ú < Œµ/3`.\n  obtain ‚ü®N, hN‚ü© : ‚àÉ N, P.toMeasure (‚ãÉ j ‚àà Iio N, Es j)·∂ú < ENNReal.ofReal (Œµ/3) := by\n    have exhaust := @tendsto_measure_biUnion_Ici_zero_of_pairwise_disjoint Œ© _ P.toMeasure _\n                    Es (fun n ‚Ü¶ (Es_mble n).nullMeasurableSet) Es_disjoint\n    simp only [tendsto_atTop_nhds, Function.comp_apply] at exhaust\n    obtain ‚ü®N, hN‚ü© := exhaust (Iio (ENNReal.ofReal (Œµ / 3))) third_Œµ_pos' isOpen_Iio\n    refine ‚ü®N, ?_‚ü©\n    have rewr : ‚ãÉ i, ‚ãÉ (_ : N ‚â§ i), Es i = (‚ãÉ i, ‚ãÉ (_ : i < N), Es i)·∂ú := by\n      simpa only [mem_Iio, compl_Iio, mem_Ici] using\n        (biUnion_compl_eq_of_pairwise_disjoint_of_iUnion_eq_univ Es_cover Es_disjoint (Iio N)).symm\n    simpa only [mem_Iio, ‚Üê rewr, gt_iff_lt] using hN N le_rfl\n  -- With the finite `N` fixed above, consider the finite collection of open sets of the form\n  -- `Gs J = thickening (Œµ/3) (‚ãÉ j ‚àà J, Es j)`, where `J ‚äÜ {0, 1, ..., N-1}`.\n  have Js_finite : Set.Finite {J | J ‚äÜ Iio N} := Finite.finite_subsets <| finite_Iio N\n  set Gs := (fun (J : Set ‚Ñï) ‚Ü¶ thickening (Œµ/3) (‚ãÉ j ‚àà J, Es j)) '' {J | J ‚äÜ Iio N}\n  have Gs_open : ‚àÄ (J : Set ‚Ñï), IsOpen (thickening (Œµ/3) (‚ãÉ j ‚àà J, Es j)) :=\n    fun J ‚Ü¶ isOpen_thickening\n  -- Any open set `G ‚äÜ Œ©` determines a neighborhood of `P` consisting of those `Q` that\n  -- satisfy `P G < Q G + Œµ/3`.\n  have mem_nhds_P (G : Set Œ©) (G_open : IsOpen G) :\n      {Q | P.toMeasure G < Q.toMeasure G + ENNReal.ofReal (Œµ/3)} ‚àà ùìù P :=\n    P.toMeasure_add_pos_gt_mem_nhds G_open third_Œµ_pos'\n  -- Assume that `Q` is in the neighborhood of `P` such that for each `J ‚äÜ {0, 1, ..., N-1}`\n  -- we have `P (Gs J) < Q (Gs J) + Œµ/3`.\n  filter_upwards [(Finset.iInter_mem_sets Js_finite.toFinset).mpr <|\n                    fun J _ ‚Ü¶ mem_nhds_P _ (Gs_open J)] with Q hQ\n  simp only [Finite.mem_toFinset, mem_setOf_eq, thickening_iUnion, mem_iInter] at hQ\n  -- Note that in order to show that the L√©vy-Prokhorov distance `LPdist P Q` is small (`‚â§ 2*Œµ/3`),\n  -- it suffices to show that for arbitrary subsets `B ‚äÜ Œ©`, the measure `P B` is bounded above up\n  -- to a small error by the `Q`-measure of a small thickening of `B`.\n  apply lt_of_le_of_lt ?_ (show 2*(Œµ/3) < Œµ by linarith)\n  rw [dist_comm]\n  -- Fix an arbitrary set `B ‚äÜ Œ©`, and an arbitrary `Œ¥ > 2*Œµ/3` to gain some room for error\n  -- and for thickening.\n  apply levyProkhorovDist_le_of_forall_le _ _ (by linarith) (fun Œ¥ B Œ¥_gt _ ‚Ü¶ ?_)\n  -- Let `JB ‚äÜ {0, 1, ..., N-1}` consist of those indices `j` such that `B` intersects `Es j`.\n  -- Then the open set `Gs JB` approximates `B` rather well:\n  -- except for what happens in the small complement `(‚ãÉ n < N, Es n)·∂ú`, the set `B` is\n  -- contained in `Gs JB`, and conversely `Gs JB` only contains points within `Œ¥` from `B`.\n  set JB := {i | B ‚à© Es i ‚â† ‚àÖ ‚àß i ‚àà Iio N}\n  have B_subset : B ‚äÜ (‚ãÉ i ‚àà JB, thickening (Œµ/3) (Es i)) ‚à™ (‚ãÉ j ‚àà Iio N, Es j)·∂ú := by\n    suffices B ‚äÜ (‚ãÉ i ‚àà JB, thickening (Œµ/3) (Es i)) ‚à™ (‚ãÉ j ‚àà Ici N, Es j) by\n      refine this.trans <| union_subset_union le_rfl ?_\n      intro œâ hœâ\n      simp only [mem_Ici, mem_iUnion, exists_prop] at hœâ\n      obtain ‚ü®i, i_large, œâ_in_Esi‚ü© := hœâ\n      by_contra con\n      simp only [mem_Iio, compl_iUnion, mem_iInter, mem_compl_iff, not_forall, not_not,\n                  exists_prop] at con\n      obtain ‚ü®j, j_small, œâ_in_Esj‚ü© := con\n      exact disjoint_left.mp (Es_disjoint (show j ‚â† i by omega)) œâ_in_Esj œâ_in_Esi\n    intro œâ œâ_in_B\n    obtain ‚ü®i, hi‚ü© := show ‚àÉ n, œâ ‚àà Es n by simp only [‚Üê mem_iUnion, Es_cover, mem_univ]\n    simp only [mem_Ici, mem_union, mem_iUnion, exists_prop]\n    by_cases i_small : i ‚àà Iio N\n    ¬∑ refine Or.inl ‚ü®i, ?_, self_subset_thickening third_Œµ_pos _ hi‚ü©\n      simp only [mem_Iio, mem_setOf_eq, JB]\n      refine ‚ü®nonempty_iff_ne_empty.mp <| Set.nonempty_of_mem <| mem_inter œâ_in_B hi, i_small‚ü©\n    ¬∑ exact Or.inr ‚ü®i, by simpa only [mem_Iio, not_lt] using i_small, hi‚ü©\n  have subset_thickB : ‚ãÉ i ‚àà JB, thickening (Œµ / 3) (Es i) ‚äÜ thickening Œ¥ B := by\n    intro œâ œâ_in_U\n    simp only [mem_setOf_eq, mem_iUnion, exists_prop] at œâ_in_U\n    obtain ‚ü®k, ‚ü®B_intersects, _‚ü©, œâ_in_thEk‚ü© := œâ_in_U\n    rw [mem_thickening_iff] at œâ_in_thEk ‚ä¢\n    obtain ‚ü®w, w_in_Ek, w_near‚ü© := œâ_in_thEk\n    obtain ‚ü®z, ‚ü®z_in_B, z_in_Ek‚ü©‚ü© := nonempty_iff_ne_empty.mpr B_intersects\n    refine ‚ü®z, z_in_B, lt_of_le_of_lt (dist_triangle œâ w z) ?_‚ü©\n    apply lt_of_le_of_lt (add_le_add w_near.le <|\n            (dist_le_diam_of_mem (Es_bdd k) w_in_Ek z_in_Ek).trans <| Es_diam k)\n    linarith\n  -- We use the resulting upper bound `P B ‚â§ P (Gs JB) + P (small complement)`.\n  apply (measure_mono B_subset).trans ((measure_union_le _ _).trans ?_)\n  -- From the choice of `Q` in a suitable neighborhood, we have `P (Gs JB) < Q (Gs JB) + Œµ/3`.\n  specialize hQ _ (show JB ‚äÜ Iio N from fun _ h ‚Ü¶ h.2)\n  -- Now it remains to add the pieces and use the above estimates.\n  apply (add_le_add hQ.le hN.le).trans\n  rw [add_assoc, ‚Üê ENNReal.ofReal_add third_Œµ_pos.le third_Œµ_pos.le, ‚Üê two_mul]\n  apply add_le_add (measure_mono subset_thickB) (ofReal_le_ofReal _)\n  exact Œ¥_gt.le\n\n"}
{"name":"MeasureTheory.levyProkhorov_eq_convergenceInDistribution","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"Œ© : Type u_1\ninst‚úù¬≥ : PseudoMetricSpace Œ©\ninst‚úù¬≤ : MeasurableSpace Œ©\ninst‚úù¬π : OpensMeasurableSpace Œ©\ninst‚úù : TopologicalSpace.SeparableSpace Œ©\n‚ä¢ Eq inferInstance (TopologicalSpace.coinduced (‚áë(MeasureTheory.LevyProkhorov.equiv (MeasureTheory.ProbabilityMeasure Œ©))) inferInstance)","decl":"/-- The topology of the L√©vy-Prokhorov metric on probability measures on a separable space\ncoincides with the topology of convergence in distribution. -/\ntheorem levyProkhorov_eq_convergenceInDistribution :\n    (inferInstance : TopologicalSpace (ProbabilityMeasure Œ©))\n      = TopologicalSpace.coinduced (LevyProkhorov.equiv _) inferInstance :=\n  le_antisymm (LevyProkhorov.continuous_equiv_symm_probabilityMeasure (Œ© := Œ©)).coinduced_le\n              levyProkhorov_le_convergenceInDistribution\n\n"}
{"name":"MeasureTheory.instPseudoMetrizableSpaceProbabilityMeasureOfSeparableSpace","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"X : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace.PseudoMetrizableSpace X\ninst‚úù¬≤ : TopologicalSpace.SeparableSpace X\ninst‚úù¬π : MeasurableSpace X\ninst‚úù : OpensMeasurableSpace X\n‚ä¢ TopologicalSpace.PseudoMetrizableSpace (MeasureTheory.ProbabilityMeasure X)","decl":"/-- The topology of convergence in distribution on a separable space is pseudo-metrizable. -/\ninstance (X : Type*) [TopologicalSpace X] [PseudoMetrizableSpace X] [SeparableSpace X]\n    [MeasurableSpace X] [OpensMeasurableSpace X] :\n    PseudoMetrizableSpace (ProbabilityMeasure X) :=\n  letI : PseudoMetricSpace X := TopologicalSpace.pseudoMetrizableSpacePseudoMetric X\n  (homeomorph_probabilityMeasure_levyProkhorov (Œ© := X)).isInducing.pseudoMetrizableSpace\n\n"}
{"name":"MeasureTheory.instMetrizableSpaceProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.LevyProkhorovMetric","initialProofState":"X : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : TopologicalSpace.PseudoMetrizableSpace X\ninst‚úù¬≤ : TopologicalSpace.SeparableSpace X\ninst‚úù¬π : MeasurableSpace X\ninst‚úù : BorelSpace X\n‚ä¢ TopologicalSpace.MetrizableSpace (MeasureTheory.ProbabilityMeasure X)","decl":"/-- The topology of convergence in distribution on a separable Borel space is metrizable. -/\ninstance instMetrizableSpaceProbabilityMeasure (X : Type*) [TopologicalSpace X]\n    [PseudoMetrizableSpace X] [SeparableSpace X] [MeasurableSpace X] [BorelSpace X] :\n    MetrizableSpace (ProbabilityMeasure X) := by\n  letI : PseudoMetricSpace X := TopologicalSpace.pseudoMetrizableSpacePseudoMetric X\n  exact homeomorph_probabilityMeasure_levyProkhorov.isEmbedding.metrizableSpace\n\n"}
