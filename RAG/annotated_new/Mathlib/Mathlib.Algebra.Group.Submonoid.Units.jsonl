{"name":"AddSubmonoid.addUnits_mono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Monotone AddSubmonoid.addUnits","decl":"@[to_additive]\nlemma Submonoid.units_mono : Monotone (Submonoid.units (M := M)) :=\n  fun _ _ hST _ ⟨h₁, h₂⟩ => ⟨hST h₁, hST h₂⟩\n\n"}
{"name":"Submonoid.units_mono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Monotone Submonoid.units","decl":"@[to_additive]\nlemma Submonoid.units_mono : Monotone (Submonoid.units (M := M)) :=\n  fun _ _ hST _ ⟨h₁, h₂⟩ => ⟨hST h₁, hST h₂⟩\n\n"}
{"name":"Submonoid.ofUnits_units_le","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\n⊢ LE.le S.units.ofUnits S","decl":"@[to_additive (attr := simp)]\nlemma Submonoid.ofUnits_units_le (S : Submonoid M) : S.units.ofUnits ≤ S :=\n  fun  _ ⟨_, hm, he⟩ => he ▸ hm.1\n\n"}
{"name":"AddSubmonoid.ofAddUnits_addUnits_le","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\n⊢ LE.le S.addUnits.ofAddUnits S","decl":"@[to_additive (attr := simp)]\nlemma Submonoid.ofUnits_units_le (S : Submonoid M) : S.units.ofUnits ≤ S :=\n  fun  _ ⟨_, hm, he⟩ => he ▸ hm.1\n\n"}
{"name":"Subgroup.ofUnits_mono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Monotone Subgroup.ofUnits","decl":"@[to_additive]\nlemma Subgroup.ofUnits_mono : Monotone (Subgroup.ofUnits (M := M)) :=\n  fun _ _ hST _ ⟨x, hx, hy⟩ => ⟨x, hST hx, hy⟩\n\n"}
{"name":"AddSubgroup.ofAddUnits_mono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Monotone AddSubgroup.ofAddUnits","decl":"@[to_additive]\nlemma Subgroup.ofUnits_mono : Monotone (Subgroup.ofUnits (M := M)) :=\n  fun _ _ hST _ ⟨x, hx, hy⟩ => ⟨x, hST hx, hy⟩\n\n"}
{"name":"AddSubgroup.addUnits_ofAddUnits_eq","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\n⊢ Eq S.ofAddUnits.addUnits S","decl":"@[to_additive (attr := simp)]\nlemma Subgroup.units_ofUnits_eq (S : Subgroup Mˣ) : S.ofUnits.units = S :=\n  Subgroup.ext (fun _ =>\n  ⟨fun ⟨⟨_, hm, he⟩, _⟩ => (Units.ext he) ▸ hm, fun hm => ⟨⟨_, hm, rfl⟩, _, S.inv_mem hm, rfl⟩⟩)\n\n"}
{"name":"Subgroup.units_ofUnits_eq","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\n⊢ Eq S.ofUnits.units S","decl":"@[to_additive (attr := simp)]\nlemma Subgroup.units_ofUnits_eq (S : Subgroup Mˣ) : S.ofUnits.units = S :=\n  Subgroup.ext (fun _ =>\n  ⟨fun ⟨⟨_, hm, he⟩, _⟩ => (Units.ext he) ▸ hm, fun hm => ⟨⟨_, hm, rfl⟩, _, S.inv_mem hm, rfl⟩⟩)\n\n"}
{"name":"ofUnits_units_gc","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ GaloisConnection Subgroup.ofUnits Submonoid.units","decl":"@[to_additive]\nlemma ofUnits_units_gc : GaloisConnection (Subgroup.ofUnits (M := M)) (Submonoid.units) :=\nofUnits_units_gci.gc\n\n"}
{"name":"ofAddUnits_addUnits_gc","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ GaloisConnection AddSubgroup.ofAddUnits AddSubmonoid.addUnits","decl":"@[to_additive]\nlemma ofUnits_units_gc : GaloisConnection (Subgroup.ofUnits (M := M)) (Submonoid.units) :=\nofUnits_units_gci.gc\n\n"}
{"name":"ofAddUnits_le_iff_le_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nH : AddSubgroup (AddUnits M)\n⊢ Iff (LE.le H.ofAddUnits S) (LE.le H S.addUnits)","decl":"@[to_additive]\nlemma ofUnits_le_iff_le_units (S : Submonoid M) (H : Subgroup Mˣ) :\n    H.ofUnits ≤ S ↔ H ≤ S.units := ofUnits_units_gc _ _\n\n"}
{"name":"ofUnits_le_iff_le_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nH : Subgroup (Units M)\n⊢ Iff (LE.le H.ofUnits S) (LE.le H S.units)","decl":"@[to_additive]\nlemma ofUnits_le_iff_le_units (S : Submonoid M) (H : Subgroup Mˣ) :\n    H.ofUnits ≤ S ↔ H ≤ S.units := ofUnits_units_gc _ _\n\n"}
{"name":"Submonoid.mem_units_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\n⊢ Iff (Membership.mem S.units x) (And (Membership.mem S ↑x) (Membership.mem S ↑(Inv.inv x)))","decl":"@[to_additive]\nlemma mem_units_iff (S : Submonoid M) (x : Mˣ) : x ∈ S.units ↔\n    ((x : M) ∈ S ∧ ((x⁻¹ : Mˣ) : M) ∈ S) := Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_addUnits_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\n⊢ Iff (Membership.mem S.addUnits x) (And (Membership.mem S ↑x) (Membership.mem S ↑(Neg.neg x)))","decl":"@[to_additive]\nlemma mem_units_iff (S : Submonoid M) (x : Mˣ) : x ∈ S.units ↔\n    ((x : M) ∈ S ∧ ((x⁻¹ : Mˣ) : M) ∈ S) := Iff.rfl\n\n"}
{"name":"Submonoid.mem_units_of_val_mem_inv_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh₁ : Membership.mem S ↑x\nh₂ : Membership.mem S ↑(Inv.inv x)\n⊢ Membership.mem S.units x","decl":"@[to_additive]\nlemma mem_units_of_val_mem_inv_val_mem (S : Submonoid M) {x : Mˣ} (h₁ : (x : M) ∈ S)\n    (h₂ : ((x⁻¹ : Mˣ) : M) ∈ S) : x ∈ S.units := ⟨h₁, h₂⟩\n\n"}
{"name":"AddSubmonoid.mem_addUnits_of_val_mem_neg_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh₁ : Membership.mem S ↑x\nh₂ : Membership.mem S ↑(Neg.neg x)\n⊢ Membership.mem S.addUnits x","decl":"@[to_additive]\nlemma mem_units_of_val_mem_inv_val_mem (S : Submonoid M) {x : Mˣ} (h₁ : (x : M) ∈ S)\n    (h₂ : ((x⁻¹ : Mˣ) : M) ∈ S) : x ∈ S.units := ⟨h₁, h₂⟩\n\n"}
{"name":"AddSubmonoid.val_mem_of_mem_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh : Membership.mem S.addUnits x\n⊢ Membership.mem S ↑x","decl":"@[to_additive]\nlemma val_mem_of_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) : (x : M) ∈ S := h.1\n\n"}
{"name":"Submonoid.val_mem_of_mem_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh : Membership.mem S.units x\n⊢ Membership.mem S ↑x","decl":"@[to_additive]\nlemma val_mem_of_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) : (x : M) ∈ S := h.1\n\n"}
{"name":"AddSubmonoid.neg_val_mem_of_mem_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh : Membership.mem S.addUnits x\n⊢ Membership.mem S ↑(Neg.neg x)","decl":"@[to_additive]\nlemma inv_val_mem_of_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    ((x⁻¹ : Mˣ) : M) ∈ S := h.2\n\n"}
{"name":"Submonoid.inv_val_mem_of_mem_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh : Membership.mem S.units x\n⊢ Membership.mem S ↑(Inv.inv x)","decl":"@[to_additive]\nlemma inv_val_mem_of_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    ((x⁻¹ : Mˣ) : M) ∈ S := h.2\n\n"}
{"name":"Submonoid.coe_inv_val_mul_coe_val","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units (Subtype fun x => Membership.mem S x)\n⊢ Eq (HMul.hMul ↑↑(Inv.inv x) ↑↑x) 1","decl":"@[to_additive]\nlemma coe_inv_val_mul_coe_val (S : Submonoid M) {x : Sˣ} :\n    ((x⁻¹ : Sˣ) : M) * ((x : Sˣ) : M) = 1 := DFunLike.congr_arg S.subtype x.inv_mul\n\n"}
{"name":"AddSubmonoid.coe_neg_val_add_coe_val","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits (Subtype fun x => Membership.mem S x)\n⊢ Eq (HAdd.hAdd ↑↑(Neg.neg x) ↑↑x) 0","decl":"@[to_additive]\nlemma coe_inv_val_mul_coe_val (S : Submonoid M) {x : Sˣ} :\n    ((x⁻¹ : Sˣ) : M) * ((x : Sˣ) : M) = 1 := DFunLike.congr_arg S.subtype x.inv_mul\n\n"}
{"name":"Submonoid.coe_val_mul_coe_inv_val","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units (Subtype fun x => Membership.mem S x)\n⊢ Eq (HMul.hMul ↑↑x ↑↑(Inv.inv x)) 1","decl":"@[to_additive]\nlemma coe_val_mul_coe_inv_val (S : Submonoid M) {x : Sˣ} :\n    ((x : Sˣ) : M) * ((x⁻¹ : Sˣ) : M) = 1 := DFunLike.congr_arg S.subtype x.mul_inv\n\n"}
{"name":"AddSubmonoid.coe_val_add_coe_neg_val","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits (Subtype fun x => Membership.mem S x)\n⊢ Eq (HAdd.hAdd ↑↑x ↑↑(Neg.neg x)) 0","decl":"@[to_additive]\nlemma coe_val_mul_coe_inv_val (S : Submonoid M) {x : Sˣ} :\n    ((x : Sˣ) : M) * ((x⁻¹ : Sˣ) : M) = 1 := DFunLike.congr_arg S.subtype x.mul_inv\n\n"}
{"name":"AddSubmonoid.mk_neg_add_mk_eq_zero","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh : Membership.mem S.addUnits x\n⊢ Eq (HAdd.hAdd ⟨(AddUnits.coeHom M) (Neg.neg x), ⋯⟩ ⟨(AddUnits.coeHom M) x, ⋯⟩) 0","decl":"@[to_additive]\nlemma mk_inv_mul_mk_eq_one (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    (⟨_, h.2⟩ : S) * ⟨_, h.1⟩ = 1 := Subtype.ext x.inv_mul\n\n"}
{"name":"Submonoid.mk_inv_mul_mk_eq_one","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh : Membership.mem S.units x\n⊢ Eq (HMul.hMul ⟨(Units.coeHom M) (Inv.inv x), ⋯⟩ ⟨(Units.coeHom M) x, ⋯⟩) 1","decl":"@[to_additive]\nlemma mk_inv_mul_mk_eq_one (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    (⟨_, h.2⟩ : S) * ⟨_, h.1⟩ = 1 := Subtype.ext x.inv_mul\n\n"}
{"name":"Submonoid.mk_mul_mk_inv_eq_one","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh : Membership.mem S.units x\n⊢ Eq (HMul.hMul ⟨(Units.coeHom M) x, ⋯⟩ ⟨(Units.coeHom M) (Inv.inv x), ⋯⟩) 1","decl":"@[to_additive]\nlemma mk_mul_mk_inv_eq_one (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    (⟨_, h.1⟩ : S) * ⟨_, h.2⟩ = 1 := Subtype.ext x.mul_inv\n\n"}
{"name":"AddSubmonoid.mk_add_mk_neg_eq_zero","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh : Membership.mem S.addUnits x\n⊢ Eq (HAdd.hAdd ⟨(AddUnits.coeHom M) x, ⋯⟩ ⟨(AddUnits.coeHom M) (Neg.neg x), ⋯⟩) 0","decl":"@[to_additive]\nlemma mk_mul_mk_inv_eq_one (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) :\n    (⟨_, h.1⟩ : S) * ⟨_, h.2⟩ = 1 := Subtype.ext x.mul_inv\n\n"}
{"name":"AddSubmonoid.add_mem_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx y : AddUnits M\nh₁ : Membership.mem S.addUnits x\nh₂ : Membership.mem S.addUnits y\n⊢ Membership.mem S.addUnits (HAdd.hAdd x y)","decl":"@[to_additive]\nlemma mul_mem_units (S : Submonoid M) {x y : Mˣ} (h₁ : x ∈ S.units) (h₂ : y ∈ S.units) :\n    x * y ∈ S.units := mul_mem h₁ h₂\n\n"}
{"name":"Submonoid.mul_mem_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx y : Units M\nh₁ : Membership.mem S.units x\nh₂ : Membership.mem S.units y\n⊢ Membership.mem S.units (HMul.hMul x y)","decl":"@[to_additive]\nlemma mul_mem_units (S : Submonoid M) {x y : Mˣ} (h₁ : x ∈ S.units) (h₂ : y ∈ S.units) :\n    x * y ∈ S.units := mul_mem h₁ h₂\n\n"}
{"name":"AddSubmonoid.neg_mem_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\nh : Membership.mem S.addUnits x\n⊢ Membership.mem S.addUnits (Neg.neg x)","decl":"@[to_additive]\nlemma inv_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) : x⁻¹ ∈ S.units := inv_mem h\n\n"}
{"name":"Submonoid.inv_mem_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\nh : Membership.mem S.units x\n⊢ Membership.mem S.units (Inv.inv x)","decl":"@[to_additive]\nlemma inv_mem_units (S : Submonoid M) {x : Mˣ} (h : x ∈ S.units) : x⁻¹ ∈ S.units := inv_mem h\n\n"}
{"name":"AddSubmonoid.neg_mem_addUnits_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubmonoid M\nx : AddUnits M\n⊢ Iff (Membership.mem S.addUnits (Neg.neg x)) (Membership.mem S.addUnits x)","decl":"@[to_additive]\nlemma inv_mem_units_iff (S : Submonoid M) {x : Mˣ} : x⁻¹ ∈ S.units ↔ x ∈ S.units := inv_mem_iff\n\n"}
{"name":"Submonoid.inv_mem_units_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Submonoid M\nx : Units M\n⊢ Iff (Membership.mem S.units (Inv.inv x)) (Membership.mem S.units x)","decl":"@[to_additive]\nlemma inv_mem_units_iff (S : Submonoid M) {x : Mˣ} : x⁻¹ ∈ S.units ↔ x ∈ S.units := inv_mem_iff\n\n"}
{"name":"AddSubmonoid.addUnits_top","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq Top.top.addUnits Top.top","decl":"@[to_additive (attr := simp)]\nlemma units_top : (⊤ : Submonoid M).units = ⊤ := ofUnits_units_gc.u_top\n\n"}
{"name":"Submonoid.units_top","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq Top.top.units Top.top","decl":"@[to_additive (attr := simp)]\nlemma units_top : (⊤ : Submonoid M).units = ⊤ := ofUnits_units_gc.u_top\n\n"}
{"name":"Submonoid.units_inf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS T : Submonoid M\n⊢ Eq (Min.min S T).units (Min.min S.units T.units)","decl":"@[to_additive]\nlemma units_inf (S T : Submonoid M) : (S ⊓ T).units = S.units ⊓ T.units :=\n  ofUnits_units_gc.u_inf\n\n"}
{"name":"AddSubmonoid.addUnits_inf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS T : AddSubmonoid M\n⊢ Eq (Min.min S T).addUnits (Min.min S.addUnits T.addUnits)","decl":"@[to_additive]\nlemma units_inf (S T : Submonoid M) : (S ⊓ T).units = S.units ⊓ T.units :=\n  ofUnits_units_gc.u_inf\n\n"}
{"name":"AddSubmonoid.addUnits_sInf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set (AddSubmonoid M)\n⊢ Eq (InfSet.sInf s).addUnits (iInf fun S => iInf fun h => S.addUnits)","decl":"@[to_additive]\nlemma units_sInf {s : Set (Submonoid M)} : (sInf s).units = ⨅ S ∈ s, S.units :=\n  ofUnits_units_gc.u_sInf\n\n"}
{"name":"Submonoid.units_sInf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set (Submonoid M)\n⊢ Eq (InfSet.sInf s).units (iInf fun S => iInf fun h => S.units)","decl":"@[to_additive]\nlemma units_sInf {s : Set (Submonoid M)} : (sInf s).units = ⨅ S ∈ s, S.units :=\n  ofUnits_units_gc.u_sInf\n\n"}
{"name":"AddSubmonoid.addUnits_iInf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nι : Sort u_2\nf : ι → AddSubmonoid M\n⊢ Eq (iInf f).addUnits (iInf fun i => (f i).addUnits)","decl":"@[to_additive]\nlemma units_iInf {ι : Sort*} (f : ι → Submonoid M) : (iInf f).units = ⨅ (i : ι), (f i).units :=\n  ofUnits_units_gc.u_iInf\n\n"}
{"name":"Submonoid.units_iInf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nι : Sort u_2\nf : ι → Submonoid M\n⊢ Eq (iInf f).units (iInf fun i => (f i).units)","decl":"@[to_additive]\nlemma units_iInf {ι : Sort*} (f : ι → Submonoid M) : (iInf f).units = ⨅ (i : ι), (f i).units :=\n  ofUnits_units_gc.u_iInf\n\n"}
{"name":"Submonoid.units_iInf₂","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nι : Sort u_2\nκ : ι → Sort u_3\nf : (i : ι) → κ i → Submonoid M\n⊢ Eq (iInf fun i => iInf fun j => f i j).units (iInf fun i => iInf fun j => (f i j).units)","decl":"@[to_additive]\nlemma units_iInf₂ {ι : Sort*} {κ : ι → Sort*} (f : (i : ι) → κ i → Submonoid M) :\n    (⨅ (i : ι), ⨅ (j : κ i), f i j).units = ⨅ (i : ι), ⨅ (j : κ i), (f i j).units :=\n  ofUnits_units_gc.u_iInf₂\n\n"}
{"name":"AddSubmonoid.addUnits_iInf₂","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nι : Sort u_2\nκ : ι → Sort u_3\nf : (i : ι) → κ i → AddSubmonoid M\n⊢ Eq (iInf fun i => iInf fun j => f i j).addUnits (iInf fun i => iInf fun j => (f i j).addUnits)","decl":"@[to_additive]\nlemma units_iInf₂ {ι : Sort*} {κ : ι → Sort*} (f : (i : ι) → κ i → Submonoid M) :\n    (⨅ (i : ι), ⨅ (j : κ i), f i j).units = ⨅ (i : ι), ⨅ (j : κ i), (f i j).units :=\n  ofUnits_units_gc.u_iInf₂\n\n"}
{"name":"AddSubmonoid.addUnits_bot","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq Bot.bot.addUnits Bot.bot","decl":"@[to_additive (attr := simp)]\nlemma units_bot : (⊥ : Submonoid M).units = ⊥ := ofUnits_units_gci.u_bot\n\n"}
{"name":"Submonoid.units_bot","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq Bot.bot.units Bot.bot","decl":"@[to_additive (attr := simp)]\nlemma units_bot : (⊥ : Submonoid M).units = ⊥ := ofUnits_units_gci.u_bot\n\n"}
{"name":"Submonoid.units_surjective","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Function.Surjective Submonoid.units","decl":"@[to_additive]\nlemma units_surjective : Function.Surjective (units (M := M)) :=\n  ofUnits_units_gci.u_surjective\n\n"}
{"name":"AddSubmonoid.addUnits_surjective","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Function.Surjective AddSubmonoid.addUnits","decl":"@[to_additive]\nlemma units_surjective : Function.Surjective (units (M := M)) :=\n  ofUnits_units_gci.u_surjective\n\n"}
{"name":"AddSubmonoid.addUnits_left_inverse","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Function.LeftInverse AddSubmonoid.addUnits AddSubgroup.ofAddUnits","decl":"@[to_additive]\nlemma units_left_inverse :\n    Function.LeftInverse (units (M := M)) (Subgroup.ofUnits (M := M)) :=\n  ofUnits_units_gci.u_l_leftInverse\n\n"}
{"name":"Submonoid.units_left_inverse","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Function.LeftInverse Submonoid.units Subgroup.ofUnits","decl":"@[to_additive]\nlemma units_left_inverse :\n    Function.LeftInverse (units (M := M)) (Subgroup.ofUnits (M := M)) :=\n  ofUnits_units_gci.u_l_leftInverse\n\n"}
{"name":"AddSubgroup.mem_ofAddUnits_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\n⊢ Iff (Membership.mem S.ofAddUnits x) (Exists fun y => And (Membership.mem S y) (Eq (↑y) x))","decl":"@[to_additive]\nlemma mem_ofUnits_iff (S : Subgroup Mˣ) (x : M) : x ∈ S.ofUnits ↔ ∃ y ∈ S, y = x := Iff.rfl\n\n"}
{"name":"Subgroup.mem_ofUnits_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\n⊢ Iff (Membership.mem S.ofUnits x) (Exists fun y => And (Membership.mem S y) (Eq (↑y) x))","decl":"@[to_additive]\nlemma mem_ofUnits_iff (S : Subgroup Mˣ) (x : M) : x ∈ S.ofUnits ↔ ∃ y ∈ S, y = x := Iff.rfl\n\n"}
{"name":"Subgroup.mem_ofUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\ny : Units M\nh₁ : Membership.mem S y\nh₂ : Eq (↑y) x\n⊢ Membership.mem S.ofUnits x","decl":"@[to_additive]\nlemma mem_ofUnits (S : Subgroup Mˣ) {x : M} {y : Mˣ} (h₁ : y ∈ S) (h₂ : y = x) : x ∈ S.ofUnits :=\n  ⟨_, h₁, h₂⟩\n\n"}
{"name":"AddSubgroup.mem_ofAddUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\ny : AddUnits M\nh₁ : Membership.mem S y\nh₂ : Eq (↑y) x\n⊢ Membership.mem S.ofAddUnits x","decl":"@[to_additive]\nlemma mem_ofUnits (S : Subgroup Mˣ) {x : M} {y : Mˣ} (h₁ : y ∈ S) (h₂ : y = x) : x ∈ S.ofUnits :=\n  ⟨_, h₁, h₂⟩\n\n"}
{"name":"Subgroup.exists_mem_ofUnits_val_eq","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh : Membership.mem S.ofUnits x\n⊢ Exists fun y => And (Membership.mem S y) (Eq (↑y) x)","decl":"@[to_additive]\nlemma exists_mem_ofUnits_val_eq (S : Subgroup Mˣ) {x : M} (h : x ∈ S.ofUnits) :\n    ∃ y ∈ S, y = x := h\n\n"}
{"name":"AddSubgroup.exists_mem_ofAddUnits_val_eq","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh : Membership.mem S.ofAddUnits x\n⊢ Exists fun y => And (Membership.mem S y) (Eq (↑y) x)","decl":"@[to_additive]\nlemma exists_mem_ofUnits_val_eq (S : Subgroup Mˣ) {x : M} (h : x ∈ S.ofUnits) :\n    ∃ y ∈ S, y = x := h\n\n"}
{"name":"AddSubgroup.mem_of_mem_val_ofAddUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\ny : AddUnits M\nhy : Membership.mem S.ofAddUnits ↑y\n⊢ Membership.mem S y","decl":"@[to_additive]\nlemma mem_of_mem_val_ofUnits (S : Subgroup Mˣ) {y : Mˣ} (hy : (y : M) ∈ S.ofUnits) : y ∈ S :=\n  match hy with\n  | ⟨_, hm, he⟩ => (Units.ext he) ▸ hm\n\n"}
{"name":"Subgroup.mem_of_mem_val_ofUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\ny : Units M\nhy : Membership.mem S.ofUnits ↑y\n⊢ Membership.mem S y","decl":"@[to_additive]\nlemma mem_of_mem_val_ofUnits (S : Subgroup Mˣ) {y : Mˣ} (hy : (y : M) ∈ S.ofUnits) : y ∈ S :=\n  match hy with\n  | ⟨_, hm, he⟩ => (Units.ext he) ▸ hm\n\n"}
{"name":"AddSubgroup.isAddUnit_of_mem_ofAddUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nhx : Membership.mem S.ofAddUnits x\n⊢ IsAddUnit x","decl":"@[to_additive]\nlemma isUnit_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} (hx : x ∈ S.ofUnits) : IsUnit x :=\n  match hx with\n  | ⟨_, _, h⟩ => ⟨_, h⟩\n\n"}
{"name":"Subgroup.isUnit_of_mem_ofUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nhx : Membership.mem S.ofUnits x\n⊢ IsUnit x","decl":"@[to_additive]\nlemma isUnit_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} (hx : x ∈ S.ofUnits) : IsUnit x :=\n  match hx with\n  | ⟨_, _, h⟩ => ⟨_, h⟩\n\n"}
{"name":"Subgroup.unit_of_mem_ofUnits_spec_eq_of_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : Units M\nh : Membership.mem S.ofUnits ↑x\n⊢ Eq (S.unit_of_mem_ofUnits h) x","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_eq_of_val_mem (S : Subgroup Mˣ) {x : Mˣ} (h : (x : M) ∈ S.ofUnits) :\n    S.unit_of_mem_ofUnits h = x := Units.ext rfl\n\n"}
{"name":"AddSubgroup.addUnit_of_mem_ofAddUnits_spec_eq_of_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : AddUnits M\nh : Membership.mem S.ofAddUnits ↑x\n⊢ Eq (S.addUnit_of_mem_ofAddUnits h) x","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_eq_of_val_mem (S : Subgroup Mˣ) {x : Mˣ} (h : (x : M) ∈ S.ofUnits) :\n    S.unit_of_mem_ofUnits h = x := Units.ext rfl\n\n"}
{"name":"AddSubgroup.addUnit_of_mem_ofAddUnits_spec_val_eq_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh : Membership.mem S.ofAddUnits x\n⊢ Eq (↑(S.addUnit_of_mem_ofAddUnits h)) x","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_val_eq_of_mem (S : Subgroup Mˣ) {x : M} (h : x ∈ S.ofUnits) :\n    S.unit_of_mem_ofUnits h = x := rfl\n\n"}
{"name":"Subgroup.unit_of_mem_ofUnits_spec_val_eq_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh : Membership.mem S.ofUnits x\n⊢ Eq (↑(S.unit_of_mem_ofUnits h)) x","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_val_eq_of_mem (S : Subgroup Mˣ) {x : M} (h : x ∈ S.ofUnits) :\n    S.unit_of_mem_ofUnits h = x := rfl\n\n"}
{"name":"AddSubgroup.addUnit_of_mem_ofAddUnits_spec_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh : Membership.mem S.ofAddUnits x\n⊢ Membership.mem S (S.addUnit_of_mem_ofAddUnits h)","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_mem (S : Subgroup Mˣ) {x : M} {h : x ∈ S.ofUnits} :\n    S.unit_of_mem_ofUnits h ∈ S := S.mem_of_mem_val_ofUnits h\n\n"}
{"name":"Subgroup.unit_of_mem_ofUnits_spec_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh : Membership.mem S.ofUnits x\n⊢ Membership.mem S (S.unit_of_mem_ofUnits h)","decl":"@[to_additive]\nlemma unit_of_mem_ofUnits_spec_mem (S : Subgroup Mˣ) {x : M} {h : x ∈ S.ofUnits} :\n    S.unit_of_mem_ofUnits h ∈ S := S.mem_of_mem_val_ofUnits h\n\n"}
{"name":"AddSubgroup.addUnit_eq_addUnit_of_mem_ofAddUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh₁ : IsAddUnit x\nh₂ : Membership.mem S.ofAddUnits x\n⊢ Eq h₁.addUnit (S.addUnit_of_mem_ofAddUnits h₂)","decl":"@[to_additive]\nlemma unit_eq_unit_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} (h₁ : IsUnit x)\n    (h₂ : x ∈ S.ofUnits) : h₁.unit = S.unit_of_mem_ofUnits h₂ := Units.ext rfl\n\n"}
{"name":"Subgroup.unit_eq_unit_of_mem_ofUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh₁ : IsUnit x\nh₂ : Membership.mem S.ofUnits x\n⊢ Eq h₁.unit (S.unit_of_mem_ofUnits h₂)","decl":"@[to_additive]\nlemma unit_eq_unit_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} (h₁ : IsUnit x)\n    (h₂ : x ∈ S.ofUnits) : h₁.unit = S.unit_of_mem_ofUnits h₂ := Units.ext rfl\n\n"}
{"name":"AddSubgroup.addUnit_mem_of_mem_ofAddUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh₁ : IsAddUnit x\nh₂ : Membership.mem S.ofAddUnits x\n⊢ Membership.mem S h₁.addUnit","decl":"@[to_additive]\nlemma unit_mem_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} {h₁ : IsUnit x}\n    (h₂ : x ∈ S.ofUnits) : h₁.unit ∈ S :=\n  S.unit_eq_unit_of_mem_ofUnits h₁ h₂ ▸ (S.unit_of_mem_ofUnits_spec_mem)\n\n"}
{"name":"Subgroup.unit_mem_of_mem_ofUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh₁ : IsUnit x\nh₂ : Membership.mem S.ofUnits x\n⊢ Membership.mem S h₁.unit","decl":"@[to_additive]\nlemma unit_mem_of_mem_ofUnits (S : Subgroup Mˣ) {x : M} {h₁ : IsUnit x}\n    (h₂ : x ∈ S.ofUnits) : h₁.unit ∈ S :=\n  S.unit_eq_unit_of_mem_ofUnits h₁ h₂ ▸ (S.unit_of_mem_ofUnits_spec_mem)\n\n"}
{"name":"Subgroup.mem_ofUnits_of_isUnit_of_unit_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\nh₁ : IsUnit x\nh₂ : Membership.mem S h₁.unit\n⊢ Membership.mem S.ofUnits x","decl":"@[to_additive]\nlemma mem_ofUnits_of_isUnit_of_unit_mem (S : Subgroup Mˣ) {x : M} (h₁ : IsUnit x)\n    (h₂ : h₁.unit ∈ S) : x ∈ S.ofUnits := S.mem_ofUnits h₂ h₁.unit_spec\n\n"}
{"name":"AddSubgroup.mem_ofAddUnits_of_isAddUnit_of_addUnit_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\nh₁ : IsAddUnit x\nh₂ : Membership.mem S h₁.addUnit\n⊢ Membership.mem S.ofAddUnits x","decl":"@[to_additive]\nlemma mem_ofUnits_of_isUnit_of_unit_mem (S : Subgroup Mˣ) {x : M} (h₁ : IsUnit x)\n    (h₂ : h₁.unit ∈ S) : x ∈ S.ofUnits := S.mem_ofUnits h₂ h₁.unit_spec\n\n"}
{"name":"AddSubgroup.mem_ofAddUnits_iff_exists_isAddUnit","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS : AddSubgroup (AddUnits M)\nx : M\n⊢ Iff (Membership.mem S.ofAddUnits x) (Exists fun h => Membership.mem S h.addUnit)","decl":"@[to_additive]\nlemma mem_ofUnits_iff_exists_isUnit (S : Subgroup Mˣ) (x : M) :\n    x ∈ S.ofUnits ↔ ∃ h : IsUnit x, h.unit ∈ S :=\n  ⟨fun h => ⟨S.isUnit_of_mem_ofUnits h, S.unit_mem_of_mem_ofUnits h⟩,\n  fun ⟨hm, he⟩ => S.mem_ofUnits_of_isUnit_of_unit_mem hm he⟩\n\n"}
{"name":"Subgroup.mem_ofUnits_iff_exists_isUnit","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS : Subgroup (Units M)\nx : M\n⊢ Iff (Membership.mem S.ofUnits x) (Exists fun h => Membership.mem S h.unit)","decl":"@[to_additive]\nlemma mem_ofUnits_iff_exists_isUnit (S : Subgroup Mˣ) (x : M) :\n    x ∈ S.ofUnits ↔ ∃ h : IsUnit x, h.unit ∈ S :=\n  ⟨fun h => ⟨S.isUnit_of_mem_ofUnits h, S.unit_mem_of_mem_ofUnits h⟩,\n  fun ⟨hm, he⟩ => S.mem_ofUnits_of_isUnit_of_unit_mem hm he⟩\n\n"}
{"name":"AddSubgroup.ofAddUnits_bot","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq Bot.bot.ofAddUnits Bot.bot","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_bot : (⊥ : Subgroup Mˣ).ofUnits = ⊥ := ofUnits_units_gc.l_bot\n\n"}
{"name":"Subgroup.ofUnits_bot","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq Bot.bot.ofUnits Bot.bot","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_bot : (⊥ : Subgroup Mˣ).ofUnits = ⊥ := ofUnits_units_gc.l_bot\n\n"}
{"name":"Subgroup.ofUnits_inf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS T : Subgroup (Units M)\n⊢ Eq (Max.max S T).ofUnits (Max.max S.ofUnits T.ofUnits)","decl":"@[to_additive]\nlemma ofUnits_inf (S T : Subgroup Mˣ) : (S ⊔ T).ofUnits = S.ofUnits ⊔ T.ofUnits :=\nofUnits_units_gc.l_sup\n\n"}
{"name":"AddSubgroup.ofAddUnits_inf","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS T : AddSubgroup (AddUnits M)\n⊢ Eq (Max.max S T).ofAddUnits (Max.max S.ofAddUnits T.ofAddUnits)","decl":"@[to_additive]\nlemma ofUnits_inf (S T : Subgroup Mˣ) : (S ⊔ T).ofUnits = S.ofUnits ⊔ T.ofUnits :=\nofUnits_units_gc.l_sup\n\n"}
{"name":"AddSubgroup.ofAddUnits_sSup","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set (AddSubgroup (AddUnits M))\n⊢ Eq (SupSet.sSup s).ofAddUnits (iSup fun S => iSup fun h => S.ofAddUnits)","decl":"@[to_additive]\nlemma ofUnits_sSup (s : Set (Subgroup Mˣ)) : (sSup s).ofUnits = ⨆ S ∈ s, S.ofUnits :=\nofUnits_units_gc.l_sSup\n\n"}
{"name":"Subgroup.ofUnits_sSup","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set (Subgroup (Units M))\n⊢ Eq (SupSet.sSup s).ofUnits (iSup fun S => iSup fun h => S.ofUnits)","decl":"@[to_additive]\nlemma ofUnits_sSup (s : Set (Subgroup Mˣ)) : (sSup s).ofUnits = ⨆ S ∈ s, S.ofUnits :=\nofUnits_units_gc.l_sSup\n\n"}
{"name":"AddSubgroup.ofAddUnits_iSup","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nι : Sort u_2\nf : ι → AddSubgroup (AddUnits M)\n⊢ Eq (iSup f).ofAddUnits (iSup fun i => (f i).ofAddUnits)","decl":"@[to_additive]\nlemma ofUnits_iSup {ι : Sort*} {f : ι → Subgroup Mˣ} :\n    (iSup f).ofUnits = ⨆ (i : ι), (f i).ofUnits := ofUnits_units_gc.l_iSup\n\n"}
{"name":"Subgroup.ofUnits_iSup","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nι : Sort u_2\nf : ι → Subgroup (Units M)\n⊢ Eq (iSup f).ofUnits (iSup fun i => (f i).ofUnits)","decl":"@[to_additive]\nlemma ofUnits_iSup {ι : Sort*} {f : ι → Subgroup Mˣ} :\n    (iSup f).ofUnits = ⨆ (i : ι), (f i).ofUnits := ofUnits_units_gc.l_iSup\n\n"}
{"name":"AddSubgroup.ofAddUnits_iSup₂","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nι : Sort u_2\nκ : ι → Sort u_3\nf : (i : ι) → κ i → AddSubgroup (AddUnits M)\n⊢ Eq (iSup fun i => iSup fun j => f i j).ofAddUnits (iSup fun i => iSup fun j => (f i j).ofAddUnits)","decl":"@[to_additive]\nlemma ofUnits_iSup₂ {ι : Sort*} {κ : ι → Sort*} (f : (i : ι) → κ i → Subgroup Mˣ) :\n    (⨆ (i : ι), ⨆ (j : κ i), f i j).ofUnits = ⨆ (i : ι), ⨆ (j : κ i), (f i j).ofUnits :=\n  ofUnits_units_gc.l_iSup₂\n\n"}
{"name":"Subgroup.ofUnits_iSup₂","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nι : Sort u_2\nκ : ι → Sort u_3\nf : (i : ι) → κ i → Subgroup (Units M)\n⊢ Eq (iSup fun i => iSup fun j => f i j).ofUnits (iSup fun i => iSup fun j => (f i j).ofUnits)","decl":"@[to_additive]\nlemma ofUnits_iSup₂ {ι : Sort*} {κ : ι → Sort*} (f : (i : ι) → κ i → Subgroup Mˣ) :\n    (⨆ (i : ι), ⨆ (j : κ i), f i j).ofUnits = ⨆ (i : ι), ⨆ (j : κ i), (f i j).ofUnits :=\n  ofUnits_units_gc.l_iSup₂\n\n"}
{"name":"AddSubgroup.ofAddUnits_injective","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Function.Injective AddSubgroup.ofAddUnits","decl":"@[to_additive]\nlemma ofUnits_injective : Function.Injective (ofUnits (M := M)) :=\n  ofUnits_units_gci.l_injective\n\n"}
{"name":"Subgroup.ofUnits_injective","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Function.Injective Subgroup.ofUnits","decl":"@[to_additive]\nlemma ofUnits_injective : Function.Injective (ofUnits (M := M)) :=\n  ofUnits_units_gci.l_injective\n\n"}
{"name":"AddSubgroup.ofAddUnits_sup_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS T : AddSubgroup (AddUnits M)\n⊢ Eq (Max.max S.ofAddUnits T.ofAddUnits).addUnits (Max.max S T)","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_sup_units (S T : Subgroup Mˣ) : (S.ofUnits ⊔ T.ofUnits).units = S ⊔ T :=\n  ofUnits_units_gci.u_sup_l _ _\n\n"}
{"name":"Subgroup.ofUnits_sup_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS T : Subgroup (Units M)\n⊢ Eq (Max.max S.ofUnits T.ofUnits).units (Max.max S T)","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_sup_units (S T : Subgroup Mˣ) : (S.ofUnits ⊔ T.ofUnits).units = S ⊔ T :=\n  ofUnits_units_gci.u_sup_l _ _\n\n"}
{"name":"AddSubgroup.ofAddUnits_inf_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nS T : AddSubgroup (AddUnits M)\n⊢ Eq (Min.min S.ofAddUnits T.ofAddUnits).addUnits (Min.min S T)","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_inf_units (S T : Subgroup Mˣ) : (S.ofUnits ⊓ T.ofUnits).units = S ⊓ T :=\n  ofUnits_units_gci.u_inf_l _ _\n\n"}
{"name":"Subgroup.ofUnits_inf_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS T : Subgroup (Units M)\n⊢ Eq (Min.min S.ofUnits T.ofUnits).units (Min.min S T)","decl":"@[to_additive (attr := simp)]\nlemma ofUnits_inf_units (S T : Subgroup Mˣ) : (S.ofUnits ⊓ T.ofUnits).units = S ⊓ T :=\n  ofUnits_units_gci.u_inf_l _ _\n\n"}
{"name":"Subgroup.ofUnits_right_inverse","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Function.RightInverse Subgroup.ofUnits Submonoid.units","decl":"@[to_additive]\nlemma ofUnits_right_inverse :\n    Function.RightInverse (ofUnits (M := M)) (Submonoid.units (M := M)) :=\n  ofUnits_units_gci.u_l_leftInverse\n\n"}
{"name":"AddSubgroup.ofAddUnits_right_inverse","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Function.RightInverse AddSubgroup.ofAddUnits AddSubmonoid.addUnits","decl":"@[to_additive]\nlemma ofUnits_right_inverse :\n    Function.RightInverse (ofUnits (M := M)) (Submonoid.units (M := M)) :=\n  ofUnits_units_gci.u_l_leftInverse\n\n"}
{"name":"Subgroup.ofUnits_strictMono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ StrictMono Subgroup.ofUnits","decl":"@[to_additive]\nlemma ofUnits_strictMono : StrictMono (ofUnits (M := M)) := ofUnits_units_gci.strictMono_l\n\n"}
{"name":"AddSubgroup.ofAddUnits_strictMono","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ StrictMono AddSubgroup.ofAddUnits","decl":"@[to_additive]\nlemma ofUnits_strictMono : StrictMono (ofUnits (M := M)) := ofUnits_units_gci.strictMono_l\n\n"}
{"name":"Subgroup.ofUnits_le_ofUnits_iff","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nS T : Subgroup (Units M)\n⊢ Iff (LE.le S.ofUnits T.ofUnits) (LE.le S T)","decl":"lemma ofUnits_le_ofUnits_iff {S T : Subgroup Mˣ} : S.ofUnits ≤ T.ofUnits ↔ S ≤ T :=\n  ofUnits_units_gci.l_le_l_iff\n\n"}
{"name":"Subgroup.mem_units_iff_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nx : Units G\n⊢ Iff (Membership.mem H.units x) (Membership.mem H ↑x)","decl":"@[to_additive]\nlemma mem_units_iff_val_mem (H : Subgroup G) (x : Gˣ) : x ∈ H.units ↔ (x : G) ∈ H := by\n  simp_rw [Submonoid.mem_units_iff, mem_toSubmonoid, val_inv_eq_inv_val, inv_mem_iff, and_self]\n\n"}
{"name":"AddSubgroup.mem_addUnits_iff_val_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : AddUnits G\n⊢ Iff (Membership.mem H.addUnits x) (Membership.mem H ↑x)","decl":"@[to_additive]\nlemma mem_units_iff_val_mem (H : Subgroup G) (x : Gˣ) : x ∈ H.units ↔ (x : G) ∈ H := by\n  simp_rw [Submonoid.mem_units_iff, mem_toSubmonoid, val_inv_eq_inv_val, inv_mem_iff, and_self]\n\n"}
{"name":"Subgroup.mem_ofUnits_iff_toUnits_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup (Units G)\nx : G\n⊢ Iff (Membership.mem H.ofUnits x) (Membership.mem H (toUnits x))","decl":"@[to_additive]\nlemma mem_ofUnits_iff_toUnits_mem (H : Subgroup Gˣ) (x : G) : x ∈ H.ofUnits ↔ (toUnits x) ∈ H := by\n  simp_rw [mem_ofUnits_iff, toUnits.surjective.exists, val_toUnits_apply, exists_eq_right]\n\n"}
{"name":"AddSubgroup.mem_ofAddUnits_iff_toAddUnits_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup (AddUnits G)\nx : G\n⊢ Iff (Membership.mem H.ofAddUnits x) (Membership.mem H (toAddUnits x))","decl":"@[to_additive]\nlemma mem_ofUnits_iff_toUnits_mem (H : Subgroup Gˣ) (x : G) : x ∈ H.ofUnits ↔ (toUnits x) ∈ H := by\n  simp_rw [mem_ofUnits_iff, toUnits.surjective.exists, val_toUnits_apply, exists_eq_right]\n\n"}
{"name":"AddSubgroup.mem_iff_toAddUnits_mem_addUnits","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup G\nx : G\n⊢ Iff (Membership.mem H.addUnits (toAddUnits x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\nlemma mem_iff_toUnits_mem_units (H : Subgroup G) (x : G) : toUnits x ∈ H.units ↔ x ∈ H := by\n  simp_rw [mem_units_iff_val_mem, val_toUnits_apply]\n\n"}
{"name":"Subgroup.mem_iff_toUnits_mem_units","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup G\nx : G\n⊢ Iff (Membership.mem H.units (toUnits x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\nlemma mem_iff_toUnits_mem_units (H : Subgroup G) (x : G) : toUnits x ∈ H.units ↔ x ∈ H := by\n  simp_rw [mem_units_iff_val_mem, val_toUnits_apply]\n\n"}
{"name":"AddSubgroup.val_mem_ofAddUnits_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nH : AddSubgroup (AddUnits G)\nx : AddUnits G\n⊢ Iff (Membership.mem H.ofAddUnits ↑x) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\nlemma val_mem_ofUnits_iff_mem (H : Subgroup Gˣ) (x : Gˣ) : (x : G) ∈ H.ofUnits ↔ x ∈ H := by\n  simp_rw [mem_ofUnits_iff_toUnits_mem, toUnits_val_apply]\n\n"}
{"name":"Subgroup.val_mem_ofUnits_iff_mem","module":"Mathlib.Algebra.Group.Submonoid.Units","initialProofState":"G : Type u_2\ninst✝ : Group G\nH : Subgroup (Units G)\nx : Units G\n⊢ Iff (Membership.mem H.ofUnits ↑x) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\nlemma val_mem_ofUnits_iff_mem (H : Subgroup Gˣ) (x : Gˣ) : (x : G) ∈ H.ofUnits ↔ x ∈ H := by\n  simp_rw [mem_ofUnits_iff_toUnits_mem, toUnits_val_apply]\n\n"}
