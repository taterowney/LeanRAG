{"name":"ParacompactSpace.locallyFinite_refinement","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù : TopologicalSpace X\nself : ParacompactSpace X\nŒ± : Type v\ns : Œ± ‚Üí Set X\na‚úù¬π : ‚àÄ (a : Œ±), IsOpen (s a)\na‚úù : Eq (Set.iUnion fun a => s a) Set.univ\n‚ä¢ Exists fun Œ≤ => Exists fun t => And (‚àÄ (b : Œ≤), IsOpen (t b)) (And (Eq (Set.iUnion fun b => t b) Set.univ) (And (LocallyFinite t) (‚àÄ (b : Œ≤), Exists fun a => HasSubset.Subset (t b) (s a))))","decl":"/-- A topological space is called paracompact, if every open covering of this space admits a locally\nfinite refinement. We use the same universe for all types in the definition to avoid creating a\nclass like `ParacompactSpace.{u v}`. Due to lemma `precise_refinement` below, every open covering\n`s : Œ± ‚Üí Set X` indexed on `Œ± : Type v` has a *precise* locally finite refinement, i.e., a locally\nfinite refinement `t : Œ± ‚Üí Set X` indexed on the same type such that each `‚àÄ i, t i ‚äÜ s i`. -/\nclass ParacompactSpace (X : Type v) [TopologicalSpace X] : Prop where\n  /-- Every open cover of a paracompact space assumes a locally finite refinement. -/\n  locallyFinite_refinement :\n    ‚àÄ (Œ± : Type v) (s : Œ± ‚Üí Set X), (‚àÄ a, IsOpen (s a)) ‚Üí (‚ãÉ a, s a = univ) ‚Üí\n      ‚àÉ (Œ≤ : Type v) (t : Œ≤ ‚Üí Set X),\n        (‚àÄ b, IsOpen (t b)) ‚àß (‚ãÉ b, t b = univ) ‚àß LocallyFinite t ‚àß ‚àÄ b, ‚àÉ a, t b ‚äÜ s a\n\n"}
{"name":"precise_refinement","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"Œπ : Type u\nX : Type v\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ParacompactSpace X\nu : Œπ ‚Üí Set X\nuo : ‚àÄ (a : Œπ), IsOpen (u a)\nuc : Eq (Set.iUnion fun i => u i) Set.univ\n‚ä¢ Exists fun v => And (‚àÄ (a : Œπ), IsOpen (v a)) (And (Eq (Set.iUnion fun i => v i) Set.univ) (And (LocallyFinite v) (‚àÄ (a : Œπ), HasSubset.Subset (v a) (u a))))","decl":"/-- Any open cover of a paracompact space has a locally finite *precise* refinement, that is,\none indexed on the same type with each open set contained in the corresponding original one. -/\ntheorem precise_refinement [ParacompactSpace X] (u : Œπ ‚Üí Set X) (uo : ‚àÄ a, IsOpen (u a))\n    (uc : ‚ãÉ i, u i = univ) : ‚àÉ v : Œπ ‚Üí Set X, (‚àÄ a, IsOpen (v a)) ‚àß ‚ãÉ i, v i = univ ‚àß\n    LocallyFinite v ‚àß ‚àÄ a, v a ‚äÜ u a := by\n  -- Apply definition to `range u`, then turn existence quantifiers into functions using `choose`\n  have := ParacompactSpace.locallyFinite_refinement (range u) (fun r ‚Ü¶ (r : Set X))\n    (forall_subtype_range_iff.2 uo) (by rwa [‚Üê sUnion_range, Subtype.range_coe])\n  simp only [exists_subtype_range_iff, iUnion_eq_univ_iff] at this\n  choose Œ± t hto hXt htf ind hind using this\n  choose t_inv ht_inv using hXt\n  choose U hxU hU using htf\n  -- Send each `i` to the union of `t a` over `a ‚àà ind ‚Åª¬π' {i}`\n  refine ‚ü®fun i ‚Ü¶ ‚ãÉ (a : Œ±) (_ : ind a = i), t a, ?_, ?_, ?_, ?_‚ü©\n  ¬∑ exact fun a ‚Ü¶ isOpen_iUnion fun a ‚Ü¶ isOpen_iUnion fun _ ‚Ü¶ hto a\n  ¬∑ simp only [eq_univ_iff_forall, mem_iUnion]\n    exact fun x ‚Ü¶ ‚ü®ind (t_inv x), _, rfl, ht_inv _‚ü©\n  ¬∑ refine fun x ‚Ü¶ ‚ü®U x, hxU x, ((hU x).image ind).subset ?_‚ü©\n    simp only [subset_def, mem_iUnion, mem_setOf_eq, Set.Nonempty, mem_inter_iff]\n    rintro i ‚ü®y, ‚ü®a, rfl, hya‚ü©, hyU‚ü©\n    exact mem_image_of_mem _ ‚ü®y, hya, hyU‚ü©\n  ¬∑ simp only [subset_def, mem_iUnion]\n    rintro i x ‚ü®a, rfl, hxa‚ü©\n    exact hind _ hxa\n\n"}
{"name":"precise_refinement_set","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"Œπ : Type u\nX : Type v\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : ParacompactSpace X\ns : Set X\nhs : IsClosed s\nu : Œπ ‚Üí Set X\nuo : ‚àÄ (i : Œπ), IsOpen (u i)\nus : HasSubset.Subset s (Set.iUnion fun i => u i)\n‚ä¢ Exists fun v => And (‚àÄ (i : Œπ), IsOpen (v i)) (And (HasSubset.Subset s (Set.iUnion fun i => v i)) (And (LocallyFinite v) (‚àÄ (i : Œπ), HasSubset.Subset (v i) (u i))))","decl":"/-- In a paracompact space, every open covering of a closed set admits a locally finite refinement\nindexed by the same type. -/\ntheorem precise_refinement_set [ParacompactSpace X] {s : Set X} (hs : IsClosed s) (u : Œπ ‚Üí Set X)\n    (uo : ‚àÄ i, IsOpen (u i)) (us : s ‚äÜ ‚ãÉ i, u i) :\n    ‚àÉ v : Œπ ‚Üí Set X, (‚àÄ i, IsOpen (v i)) ‚àß (s ‚äÜ ‚ãÉ i, v i) ‚àß LocallyFinite v ‚àß ‚àÄ i, v i ‚äÜ u i := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10888): added proof of uc\n  have uc : (iUnion fun i => Option.elim' s·∂ú u i) = univ := by\n    apply Subset.antisymm (subset_univ _)\n    ¬∑ simp_rw [‚Üê compl_union_self s, Option.elim', iUnion_option]\n      apply union_subset_union_right s·∂ú us\n  rcases precise_refinement (Option.elim' s·∂ú u) (Option.forall.2 ‚ü®isOpen_compl_iff.2 hs, uo‚ü©)\n      uc with\n    ‚ü®v, vo, vc, vf, vu‚ü©\n  refine ‚ü®v ‚àò some, fun i ‚Ü¶ vo _, ?_, vf.comp_injective (Option.some_injective _), fun i ‚Ü¶ vu _‚ü©\n  ¬∑ simp only [iUnion_option, ‚Üê compl_subset_iff_union] at vc\n    exact Subset.trans (subset_compl_comm.1 <| vu Option.none) vc\n\n"}
{"name":"Topology.IsClosedEmbedding.paracompactSpace","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\nY : Type w\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : ParacompactSpace Y\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ ParacompactSpace X","decl":"theorem Topology.IsClosedEmbedding.paracompactSpace [ParacompactSpace Y] {e : X ‚Üí Y}\n    (he : IsClosedEmbedding e) : ParacompactSpace X where\n  locallyFinite_refinement Œ± s ho hu := by\n    choose U hUo hU using fun a ‚Ü¶ he.isOpen_iff.1 (ho a)\n    simp only [‚Üê hU] at hu ‚ä¢\n    have heU : range e ‚äÜ ‚ãÉ i, U i := by\n      simpa only [range_subset_iff, mem_iUnion, iUnion_eq_univ_iff] using hu\n    rcases precise_refinement_set he.isClosed_range U hUo heU with ‚ü®V, hVo, heV, hVf, hVU‚ü©\n    refine ‚ü®Œ±, fun a ‚Ü¶ e ‚Åª¬π' (V a), fun a ‚Ü¶ (hVo a).preimage he.continuous, ?_,\n      hVf.preimage_continuous he.continuous, fun a ‚Ü¶ ‚ü®a, preimage_mono (hVU a)‚ü©‚ü©\n    simpa only [range_subset_iff, mem_iUnion, iUnion_eq_univ_iff] using heV\n\n"}
{"name":"ClosedEmbedding.paracompactSpace","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\nY : Type w\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : ParacompactSpace Y\ne : X ‚Üí Y\nhe : Topology.IsClosedEmbedding e\n‚ä¢ ParacompactSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.paracompactSpace := IsClosedEmbedding.paracompactSpace\n\n"}
{"name":"Homeomorph.paracompactSpace_iff","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\nY : Type w\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Homeomorph X Y\n‚ä¢ Iff (ParacompactSpace X) (ParacompactSpace Y)","decl":"theorem Homeomorph.paracompactSpace_iff (e : X ‚âÉ‚Çú Y) : ParacompactSpace X ‚Üî ParacompactSpace Y :=\n  ‚ü®fun _ ‚Ü¶ e.symm.isClosedEmbedding.paracompactSpace, fun _ ‚Ü¶ e.isClosedEmbedding.paracompactSpace‚ü©\n\n"}
{"name":"instParacompactSpaceProdOfCompactSpace","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\nY : Type w\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : CompactSpace X\ninst‚úù : ParacompactSpace Y\n‚ä¢ ParacompactSpace (Prod X Y)","decl":"/-- The product of a compact space and a paracompact space is a paracompact space. The formalization\nis based on https://dantopology.wordpress.com/2009/10/24/compact-x-paracompact-is-paracompact/\nwith some minor modifications.\n\nThis version assumes that `X` in `X √ó Y` is compact and `Y` is paracompact, see next lemma for the\nother case. -/\ninstance (priority := 200) [CompactSpace X] [ParacompactSpace Y] : ParacompactSpace (X √ó Y) where\n  locallyFinite_refinement Œ± s ho hu := by\n    have : ‚àÄ (x : X) (y : Y), ‚àÉ (a : Œ±) (U : Set X) (V : Set Y),\n        IsOpen U ‚àß IsOpen V ‚àß x ‚àà U ‚àß y ‚àà V ‚àß U √óÀ¢ V ‚äÜ s a := fun x y ‚Ü¶\n      (iUnion_eq_univ_iff.1 hu (x, y)).imp fun a ha ‚Ü¶ isOpen_prod_iff.1 (ho a) x y ha\n    choose a U V hUo hVo hxU hyV hUV using this\n    choose T hT using fun y ‚Ü¶ CompactSpace.elim_nhds_subcover (U ¬∑ y) fun x ‚Ü¶\n      (hUo x y).mem_nhds (hxU x y)\n    set W : Y ‚Üí Set Y := fun y ‚Ü¶ ‚ãÇ x ‚àà T y, V x y\n    have hWo : ‚àÄ y, IsOpen (W y) := fun y ‚Ü¶ isOpen_biInter_finset fun _ _ ‚Ü¶ hVo _ _\n    have hW : ‚àÄ y, y ‚àà W y := fun _ ‚Ü¶ mem_iInter‚ÇÇ.2 fun _ _ ‚Ü¶ hyV _ _\n    rcases precise_refinement W hWo (iUnion_eq_univ_iff.2 fun y ‚Ü¶ ‚ü®y, hW y‚ü©)\n      with ‚ü®E, hEo, hE, hEf, hEA‚ü©\n    refine ‚ü®Œ£ y, T y, fun z ‚Ü¶ U z.2.1 z.1 √óÀ¢ E z.1, fun _ ‚Ü¶ (hUo _ _).prod (hEo _),\n      iUnion_eq_univ_iff.2 fun (x, y) ‚Ü¶ ?_, fun (x, y) ‚Ü¶ ?_, fun ‚ü®y, x, hx‚ü© ‚Ü¶ ?_‚ü©\n    ¬∑ rcases iUnion_eq_univ_iff.1 hE y with ‚ü®b, hb‚ü©\n      rcases iUnion‚ÇÇ_eq_univ_iff.1 (hT b) x with ‚ü®a, ha, hx‚ü©\n      exact ‚ü®‚ü®b, a, ha‚ü©, hx, hb‚ü©\n    ¬∑ rcases hEf y with ‚ü®t, ht, htf‚ü©\n      refine ‚ü®univ √óÀ¢ t, prod_mem_nhds univ_mem ht, ?_‚ü©\n      refine (htf.biUnion fun y _ ‚Ü¶ finite_range (Sigma.mk y)).subset ?_\n      rintro ‚ü®b, a, ha‚ü© ‚ü®‚ü®c, d‚ü©, ‚ü®-, hd : d ‚àà E b‚ü©, -, hdt : d ‚àà t‚ü©\n      exact mem_iUnion‚ÇÇ.2 ‚ü®b, ‚ü®d, hd, hdt‚ü©, mem_range_self _‚ü©\n    ¬∑ refine ‚ü®a x y, (Set.prod_mono Subset.rfl ?_).trans (hUV x y)‚ü©\n      exact (hEA _).trans (iInter‚ÇÇ_subset x hx)\n\n"}
{"name":"instParacompactSpaceProdOfCompactSpace_1","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\nY : Type w\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : ParacompactSpace X\ninst‚úù : CompactSpace Y\n‚ä¢ ParacompactSpace (Prod X Y)","decl":"instance (priority := 200) [ParacompactSpace X] [CompactSpace Y] : ParacompactSpace (X √ó Y) :=\n  (Homeomorph.prodComm X Y).paracompactSpace_iff.2 inferInstance\n\n-- See note [lower instance priority]\n"}
{"name":"paracompact_of_compact","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompactSpace X\n‚ä¢ ParacompactSpace X","decl":"/-- A compact space is paracompact. -/\ninstance (priority := 100) paracompact_of_compact [CompactSpace X] : ParacompactSpace X := by\n  -- the proof is trivial: we choose a finite subcover using compactness, and use it\n  refine ‚ü®fun Œπ s ho hu ‚Ü¶ ?_‚ü©\n  rcases isCompact_univ.elim_finite_subcover _ ho hu.ge with ‚ü®T, hT‚ü©\n  refine ‚ü®(T : Set Œπ), fun t ‚Ü¶ s t, fun t ‚Ü¶ ho _, ?_, locallyFinite_of_finite _,\n    fun t ‚Ü¶ ‚ü®t, Subset.rfl‚ü©‚ü©\n  simpa only [iUnion_coe_set, ‚Üê univ_subset_iff]\n\n"}
{"name":"refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : WeaklyLocallyCompactSpace X\ninst‚úù¬π : SigmaCompactSpace X\ninst‚úù : T2Space X\nŒπ : X ‚Üí Type u\np : (x : X) ‚Üí Œπ x ‚Üí Prop\nB : (x : X) ‚Üí Œπ x ‚Üí Set X\ns : Set X\nhs : IsClosed s\nhB : ‚àÄ (x : X), Membership.mem s x ‚Üí (nhds x).HasBasis (p x) (B x)\n‚ä¢ Exists fun Œ± => Exists fun c => Exists fun r => And (‚àÄ (a : Œ±), And (Membership.mem s (c a)) (p (c a) (r a))) (And (HasSubset.Subset s (Set.iUnion fun a => B (c a) (r a))) (LocallyFinite fun a => B (c a) (r a)))","decl":"/-- Let `X` be a locally compact sigma compact Hausdorff topological space, let `s` be a closed set\nin `X`. Suppose that for each `x ‚àà s` the sets `B x : Œπ x ‚Üí Set X` with the predicate\n`p x : Œπ x ‚Üí Prop` form a basis of the filter `ùìù x`. Then there exists a locally finite covering\n`fun i ‚Ü¶ B (c i) (r i)` of `s` such that all ‚Äúcenters‚Äù `c i` belong to `s` and each `r i` satisfies\n`p (c i)`.\n\nThe notation is inspired by the case `B x r = Metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `Filter.HasBasis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locallyCompact_sigmaCompact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis` for a version of this lemma\ndealing with a covering of the whole space.\n\nIn most cases (namely, if `B c r ‚à™ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Œ± = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set [WeaklyLocallyCompactSpace X]\n    [SigmaCompactSpace X] [T2Space X] {Œπ : X ‚Üí Type u} {p : ‚àÄ x, Œπ x ‚Üí Prop} {B : ‚àÄ x, Œπ x ‚Üí Set X}\n    {s : Set X} (hs : IsClosed s) (hB : ‚àÄ x ‚àà s, (ùìù x).HasBasis (p x) (B x)) :\n    ‚àÉ (Œ± : Type v) (c : Œ± ‚Üí X) (r : ‚àÄ a, Œπ (c a)),\n      (‚àÄ a, c a ‚àà s ‚àß p (c a) (r a)) ‚àß\n        (s ‚äÜ ‚ãÉ a, B (c a) (r a)) ‚àß LocallyFinite fun a ‚Ü¶ B (c a) (r a) := by\n  classical\n    -- For technical reasons we prepend two empty sets to the sequence `CompactExhaustion.choice X`\n    set K' : CompactExhaustion X := CompactExhaustion.choice X\n    set K : CompactExhaustion X := K'.shiftr.shiftr\n    set Kdiff := fun n ‚Ü¶ K (n + 1) \\ interior (K n)\n    -- Now we restate some properties of `CompactExhaustion` for `K`/`Kdiff`\n    have hKcov : ‚àÄ x, x ‚àà Kdiff (K'.find x + 1) := fun x ‚Ü¶ by\n      simpa only [K'.find_shiftr] using\n        diff_subset_diff_right interior_subset (K'.shiftr.mem_diff_shiftr_find x)\n    have Kdiffc : ‚àÄ n, IsCompact (Kdiff n ‚à© s) :=\n      fun n ‚Ü¶ ((K.isCompact _).diff isOpen_interior).inter_right hs\n    -- Next we choose a finite covering `B (c n i) (r n i)` of each\n    -- `Kdiff (n + 1) ‚à© s` such that `B (c n i) (r n i) ‚à© s` is disjoint with `K n`\n    have : ‚àÄ (n) (x : ‚Üë(Kdiff (n + 1) ‚à© s)), (K n)·∂ú ‚àà ùìù (x : X) :=\n      fun n x ‚Ü¶ (K.isClosed n).compl_mem_nhds fun hx' ‚Ü¶ x.2.1.2 <| K.subset_interior_succ _ hx'\n    -- Porting note: Commented out `haveI` for now.\n    --haveI : ‚àÄ (n) (x : ‚Üë(Kdiff n ‚à© s)), Nonempty (Œπ x) := fun n x ‚Ü¶ (hB x x.2.2).nonempty\n    choose! r hrp hr using fun n (x : ‚Üë(Kdiff (n + 1) ‚à© s)) ‚Ü¶ (hB x x.2.2).mem_iff.1 (this n x)\n    have hxr : ‚àÄ (n x) (hx : x ‚àà Kdiff (n + 1) ‚à© s), B x (r n ‚ü®x, hx‚ü©) ‚àà ùìù x := fun n x hx ‚Ü¶\n      (hB x hx.2).mem_of_mem (hrp _ ‚ü®x, hx‚ü©)\n    choose T hT using fun n ‚Ü¶ (Kdiffc (n + 1)).elim_nhds_subcover' _ (hxr n)\n    set T' : ‚àÄ n, Set ‚Üë(Kdiff (n + 1) ‚à© s) := fun n ‚Ü¶ T n\n    -- Finally, we take the union of all these coverings\n    refine ‚ü®Œ£n, T' n, fun a ‚Ü¶ a.2, fun a ‚Ü¶ r a.1 a.2, ?_, ?_, ?_‚ü©\n    ¬∑ rintro ‚ü®n, x, hx‚ü©\n      exact ‚ü®x.2.2, hrp _ _‚ü©\n    ¬∑ refine fun x hx ‚Ü¶ mem_iUnion.2 ?_\n      rcases mem_iUnion‚ÇÇ.1 (hT _ ‚ü®hKcov x, hx‚ü©) with ‚ü®‚ü®c, hc‚ü©, hcT, hcx‚ü©\n      exact ‚ü®‚ü®_, ‚ü®c, hc‚ü©, hcT‚ü©, hcx‚ü©\n    ¬∑ intro x\n      refine\n        ‚ü®interior (K (K'.find x + 3)),\n          IsOpen.mem_nhds isOpen_interior (K.subset_interior_succ _ (hKcov x).1), ?_‚ü©\n      have : (‚ãÉ k ‚â§ K'.find x + 2, range (Sigma.mk k) : Set (Œ£n, T' n)).Finite :=\n        (finite_le_nat _).biUnion fun k _ ‚Ü¶ finite_range _\n      apply this.subset\n      rintro ‚ü®k, c, hc‚ü©\n      simp only [mem_iUnion, mem_setOf_eq, mem_image, Subtype.coe_mk]\n      rintro ‚ü®x, hxB : x ‚àà B c (r k c), hxK‚ü©\n      refine ‚ü®k, ?_, ‚ü®c, hc‚ü©, rfl‚ü©\n      have := (mem_compl_iff _ _).1 (hr k c hxB)\n      contrapose! this with hnk\n      exact K.subset hnk (interior_subset hxK)\n\n"}
{"name":"refinement_of_locallyCompact_sigmaCompact_of_nhds_basis","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : WeaklyLocallyCompactSpace X\ninst‚úù¬π : SigmaCompactSpace X\ninst‚úù : T2Space X\nŒπ : X ‚Üí Type u\np : (x : X) ‚Üí Œπ x ‚Üí Prop\nB : (x : X) ‚Üí Œπ x ‚Üí Set X\nhB : ‚àÄ (x : X), (nhds x).HasBasis (p x) (B x)\n‚ä¢ Exists fun Œ± => Exists fun c => Exists fun r => And (‚àÄ (a : Œ±), p (c a) (r a)) (And (Eq (Set.iUnion fun a => B (c a) (r a)) Set.univ) (LocallyFinite fun a => B (c a) (r a)))","decl":"/-- Let `X` be a locally compact sigma compact Hausdorff topological space. Suppose that for each\n`x` the sets `B x : Œπ x ‚Üí Set X` with the predicate `p x : Œπ x ‚Üí Prop` form a basis of the filter\n`ùìù x`. Then there exists a locally finite covering `fun i ‚Ü¶ B (c i) (r i)` of `X` such that each\n`r i` satisfies `p (c i)`.\n\nThe notation is inspired by the case `B x r = Metric.ball x r` but the theorem applies to\n`nhds_basis_opens` as well. If the covering must be subordinate to some open covering of `s`, then\nthe user should use a basis obtained by `Filter.HasBasis.restrict_subset` or a similar lemma, see\nthe proof of `paracompact_of_locallyCompact_sigmaCompact` for an example.\n\nThe formalization is based on two [ncatlab](https://ncatlab.org/) proofs:\n* [locally compact and sigma compact spaces are paracompact](https://ncatlab.org/nlab/show/locally+compact+and+sigma-compact+spaces+are+paracompact);\n* [open cover of smooth manifold admits locally finite refinement by closed balls](https://ncatlab.org/nlab/show/partition+of+unity#ExistenceOnSmoothManifolds).\n\nSee also `refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set` for a version of this lemma\ndealing with a covering of a closed set.\n\nIn most cases (namely, if `B c r ‚à™ B c r'` is again a set of the form `B c r''`) it is possible\nto choose `Œ± = X`. This fact is not yet formalized in `mathlib`. -/\ntheorem refinement_of_locallyCompact_sigmaCompact_of_nhds_basis [WeaklyLocallyCompactSpace X]\n    [SigmaCompactSpace X] [T2Space X] {Œπ : X ‚Üí Type u} {p : ‚àÄ x, Œπ x ‚Üí Prop} {B : ‚àÄ x, Œπ x ‚Üí Set X}\n    (hB : ‚àÄ x, (ùìù x).HasBasis (p x) (B x)) :\n    ‚àÉ (Œ± : Type v) (c : Œ± ‚Üí X) (r : ‚àÄ a, Œπ (c a)),\n      (‚àÄ a, p (c a) (r a)) ‚àß ‚ãÉ a, B (c a) (r a) = univ ‚àß LocallyFinite fun a ‚Ü¶ B (c a) (r a) :=\n  let ‚ü®Œ±, c, r, hp, hU, hfin‚ü© :=\n    refinement_of_locallyCompact_sigmaCompact_of_nhds_basis_set isClosed_univ fun x _ ‚Ü¶ hB x\n  ‚ü®Œ±, c, r, fun a ‚Ü¶ (hp a).2, univ_subset_iff.1 hU, hfin‚ü©\n\n-- See note [lower instance priority]\n"}
{"name":"paracompact_of_locallyCompact_sigmaCompact","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : WeaklyLocallyCompactSpace X\ninst‚úù¬π : SigmaCompactSpace X\ninst‚úù : T2Space X\n‚ä¢ ParacompactSpace X","decl":"/-- A locally compact sigma compact Hausdorff space is paracompact. See also\n`refinement_of_locallyCompact_sigmaCompact_of_nhds_basis` for a more precise statement. -/\ninstance (priority := 100) paracompact_of_locallyCompact_sigmaCompact [WeaklyLocallyCompactSpace X]\n    [SigmaCompactSpace X] [T2Space X] : ParacompactSpace X := by\n  refine ‚ü®fun Œ± s ho hc ‚Ü¶ ?_‚ü©\n  choose i hi using iUnion_eq_univ_iff.1 hc\n  have : ‚àÄ x : X, (ùìù x).HasBasis (fun t : Set X ‚Ü¶ (x ‚àà t ‚àß IsOpen t) ‚àß t ‚äÜ s (i x)) id :=\n    fun x : X ‚Ü¶ (nhds_basis_opens x).restrict_subset (IsOpen.mem_nhds (ho (i x)) (hi x))\n  rcases refinement_of_locallyCompact_sigmaCompact_of_nhds_basis this with\n    ‚ü®Œ≤, c, t, hto, htc, htf‚ü©\n  exact ‚ü®Œ≤, t, fun x ‚Ü¶ (hto x).1.2, htc, htf, fun b ‚Ü¶ ‚ü®i <| c b, (hto b).2‚ü©‚ü©\n\n"}
{"name":"T4Space.of_paracompactSpace_t2Space","module":"Mathlib.Topology.Compactness.Paracompact","initialProofState":"X : Type v\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T2Space X\ninst‚úù : ParacompactSpace X\n‚ä¢ T4Space X","decl":"/-- **Dieudonn√©'s theorem**: a paracompact Hausdorff space is normal.\nFormalization is based on the proof\nat [ncatlab](https://ncatlab.org/nlab/show/paracompact+Hausdorff+spaces+are+normal). -/\ninstance (priority := 100) T4Space.of_paracompactSpace_t2Space [T2Space X] [ParacompactSpace X] :\n    T4Space X := by\n  -- First we show how to go from points to a set on one side.\n  have : ‚àÄ s t : Set X, IsClosed s ‚Üí\n      (‚àÄ x ‚àà s, ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß x ‚àà u ‚àß t ‚äÜ v ‚àß Disjoint u v) ‚Üí\n      ‚àÉ u v, IsOpen u ‚àß IsOpen v ‚àß s ‚äÜ u ‚àß t ‚äÜ v ‚àß Disjoint u v := fun s t hs H ‚Ü¶ by\n    /- For each `x ‚àà s` we choose open disjoint `u x ‚àã x` and `v x ‚äá t`. The sets `u x` form an\n        open covering of `s`. We choose a locally finite refinement `u' : s ‚Üí Set X`, then\n        `‚ãÉ i, u' i` and `(closure (‚ãÉ i, u' i))·∂ú` are disjoint open neighborhoods of `s` and `t`. -/\n    choose u v hu hv hxu htv huv using SetCoe.forall'.1 H\n    rcases precise_refinement_set hs u hu fun x hx ‚Ü¶ mem_iUnion.2 ‚ü®‚ü®x, hx‚ü©, hxu _‚ü© with\n      ‚ü®u', hu'o, hcov', hu'fin, hsub‚ü©\n    refine ‚ü®‚ãÉ i, u' i, (closure (‚ãÉ i, u' i))·∂ú, isOpen_iUnion hu'o, isClosed_closure.isOpen_compl,\n      hcov', ?_, disjoint_compl_right.mono le_rfl (compl_le_compl subset_closure)‚ü©\n    rw [hu'fin.closure_iUnion, compl_iUnion, subset_iInter_iff]\n    refine fun i x hxt hxu ‚Ü¶\n      absurd (htv i hxt) (closure_minimal ?_ (isClosed_compl_iff.2 <| hv _) hxu)\n    exact fun y hyu hyv ‚Ü¶ (huv i).le_bot ‚ü®hsub _ hyu, hyv‚ü©\n  -- Now we apply the lemma twice: first to `s` and `t`, then to `t` and each point of `s`.\n  refine { normal := fun s t hs ht hst ‚Ü¶ this s t hs fun x hx ‚Ü¶ ?_ }\n  rcases this t {x} ht fun y hy ‚Ü¶ (by\n    simp_rw [singleton_subset_iff]\n    exact t2_separation (hst.symm.ne_of_mem hy hx))\n    with ‚ü®v, u, hv, hu, htv, hxu, huv‚ü©\n  exact ‚ü®u, v, hu, hv, singleton_subset_iff.1 hxu, htv, huv.symm‚ü©\n"}
