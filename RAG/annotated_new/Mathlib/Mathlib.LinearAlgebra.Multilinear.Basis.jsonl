{"name":"Basis.ext_multilinear_fin","module":"Mathlib.LinearAlgebra.Multilinear.Basis","initialProofState":"R : Type u_1\nn : Nat\nM : Fin n → Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : Fin n) → AddCommMonoid (M i)\ninst✝¹ : (i : Fin n) → Module R (M i)\ninst✝ : Module R M₂\nf g : MultilinearMap R M M₂\nι₁ : Fin n → Type u_6\ne : (i : Fin n) → Basis (ι₁ i) R (M i)\nh : ∀ (v : (i : Fin n) → ι₁ i), Eq (f fun i => (e i) (v i)) (g fun i => (e i) (v i))\n⊢ Eq f g","decl":"/-- Two multilinear maps indexed by `Fin n` are equal if they are equal when all arguments are\nbasis vectors. -/\ntheorem Basis.ext_multilinear_fin {f g : MultilinearMap R M M₂} {ι₁ : Fin n → Type*}\n    (e : ∀ i, Basis (ι₁ i) R (M i))\n    (h : ∀ v : ∀ i, ι₁ i, (f fun i => e i (v i)) = g fun i => e i (v i)) : f = g := by\n  induction' n with m hm\n  · ext x\n    convert h finZeroElim\n  · apply Function.LeftInverse.injective uncurry_curryLeft\n    refine Basis.ext (e 0) ?_\n    intro i\n    apply hm (Fin.tail e)\n    intro j\n    convert h (Fin.cons i j)\n    iterate 2\n      rw [curryLeft_apply]\n      congr 1 with x\n      refine Fin.cases rfl (fun x => ?_) x\n      dsimp [Fin.tail]\n      rw [Fin.cons_succ, Fin.cons_succ]\n\n"}
{"name":"Basis.ext_multilinear","module":"Mathlib.LinearAlgebra.Multilinear.Basis","initialProofState":"R : Type u_1\nι : Type u_2\nM₂ : Type u_4\nM₃ : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Finite ι\nf g : MultilinearMap R (fun x => M₂) M₃\nι₁ : Type u_6\ne : Basis ι₁ R M₂\nh : ∀ (v : ι → ι₁), Eq (f fun i => e (v i)) (g fun i => e (v i))\n⊢ Eq f g","decl":"/-- Two multilinear maps indexed by a `Fintype` are equal if they are equal when all arguments\nare basis vectors. Unlike `Basis.ext_multilinear_fin`, this only uses a single basis; a\ndependently-typed version would still be true, but the proof would need a dependently-typed\nversion of `dom_dom_congr`. -/\ntheorem Basis.ext_multilinear [Finite ι] {f g : MultilinearMap R (fun _ : ι => M₂) M₃} {ι₁ : Type*}\n    (e : Basis ι₁ R M₂) (h : ∀ v : ι → ι₁, (f fun i => e (v i)) = g fun i => e (v i)) : f = g := by\n  cases nonempty_fintype ι\n  exact\n    (domDomCongr_eq_iff (Fintype.equivFin ι) f g).mp\n      (Basis.ext_multilinear_fin (fun _ => e) fun i => h (i ∘ _))\n"}
