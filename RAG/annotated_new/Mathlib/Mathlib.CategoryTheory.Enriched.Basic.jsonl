{"name":"CategoryTheory.EnrichedCategory.assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} V\ninst✝ : CategoryTheory.MonoidalCategory V\nC : Type u₁\nself : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.EnrichedCategory.comp W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.EnrichedCategory.comp W Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.comp X Y Z)) (CategoryTheory.EnrichedCategory.comp W X Z))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u₁) where\n  Hom : C → C → V\n  id (X : C) : 𝟙_ V ⟶ Hom X X\n  comp (X Y Z : C) : Hom X Y ⊗ Hom Y Z ⟶ Hom X Z\n  id_comp (X Y : C) : (λ_ (Hom X Y)).inv ≫ id X ▷ _ ≫ comp X X Y = 𝟙 _ := by aesop_cat\n  comp_id (X Y : C) : (ρ_ (Hom X Y)).inv ≫ _ ◁ id Y ≫ comp X Y Y = 𝟙 _ := by aesop_cat\n  assoc (W X Y Z : C) : (α_ _ _ _).inv ≫ comp W X Y ▷ _ ≫ comp W Y Z =\n    _ ◁ comp X Y Z ≫ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedCategory.id_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} V\ninst✝ : CategoryTheory.MonoidalCategory V\nC : Type u₁\nself : CategoryTheory.EnrichedCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.EnrichedCategory.id X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.EnrichedCategory.comp X X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u₁) where\n  Hom : C → C → V\n  id (X : C) : 𝟙_ V ⟶ Hom X X\n  comp (X Y Z : C) : Hom X Y ⊗ Hom Y Z ⟶ Hom X Z\n  id_comp (X Y : C) : (λ_ (Hom X Y)).inv ≫ id X ▷ _ ≫ comp X X Y = 𝟙 _ := by aesop_cat\n  comp_id (X Y : C) : (ρ_ (Hom X Y)).inv ≫ _ ◁ id Y ≫ comp X Y Y = 𝟙 _ := by aesop_cat\n  assoc (W X Y Z : C) : (α_ _ _ _).inv ≫ comp W X Y ▷ _ ≫ comp W Y Z =\n    _ ◁ comp X Y Z ≫ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedCategory.comp_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} V\ninst✝ : CategoryTheory.MonoidalCategory V\nC : Type u₁\nself : CategoryTheory.EnrichedCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.id Y)) (CategoryTheory.EnrichedCategory.comp X Y Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u₁) where\n  Hom : C → C → V\n  id (X : C) : 𝟙_ V ⟶ Hom X X\n  comp (X Y Z : C) : Hom X Y ⊗ Hom Y Z ⟶ Hom X Z\n  id_comp (X Y : C) : (λ_ (Hom X Y)).inv ≫ id X ▷ _ ≫ comp X X Y = 𝟙 _ := by aesop_cat\n  comp_id (X Y : C) : (ρ_ (Hom X Y)).inv ≫ _ ◁ id Y ≫ comp X Y Y = 𝟙 _ := by aesop_cat\n  assoc (W X Y Z : C) : (α_ _ _ _).inv ≫ comp W X Y ▷ _ ≫ comp W Y Z =\n    _ ◁ comp X Y Z ≫ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.e_id_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eId V X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.eComp V X X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[reassoc (attr := simp)]\ntheorem e_id_comp (X Y : C) :\n    (λ_ (X ⟶[V] Y)).inv ≫ eId V X ▷ _ ≫ eComp V X X Y = 𝟙 (X ⟶[V] Y) :=\n  EnrichedCategory.id_comp X Y\n\n"}
{"name":"CategoryTheory.e_id_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nX Y : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eId V X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X X Y) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem e_id_comp (X Y : C) :\n    (λ_ (X ⟶[V] Y)).inv ≫ eId V X ▷ _ ≫ eComp V X X Y = 𝟙 (X ⟶[V] Y) :=\n  EnrichedCategory.id_comp X Y\n\n"}
{"name":"CategoryTheory.e_comp_id_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nX Y : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eId V Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Y) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem e_comp_id (X Y : C) :\n    (ρ_ (X ⟶[V] Y)).inv ≫ _ ◁ eId V Y ≫ eComp V X Y Y = 𝟙 (X ⟶[V] Y) :=\n  EnrichedCategory.comp_id X Y\n\n"}
{"name":"CategoryTheory.e_comp_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eId V Y)) (CategoryTheory.eComp V X Y Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[reassoc (attr := simp)]\ntheorem e_comp_id (X Y : C) :\n    (ρ_ (X ⟶[V] Y)).inv ≫ _ ◁ eId V Y ≫ eComp V X Y Y = 𝟙 (X ⟶[V] Y) :=\n  EnrichedCategory.comp_id X Y\n\n"}
{"name":"CategoryTheory.e_assoc_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nW X Y Z✝ : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W Y Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W X Z✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem e_assoc (W X Y Z : C) :\n    (α_ _ _ _).inv ≫ eComp V W X Y ▷ _ ≫ eComp V W Y Z =\n      _ ◁ eComp V X Y Z ≫ eComp V W X Z :=\n  EnrichedCategory.assoc W X Y Z\n\n"}
{"name":"CategoryTheory.e_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.eComp V W Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z)) (CategoryTheory.eComp V W X Z))","decl":"@[reassoc (attr := simp)]\ntheorem e_assoc (W X Y Z : C) :\n    (α_ _ _ _).inv ≫ eComp V W X Y ▷ _ ≫ eComp V W Y Z =\n      _ ◁ eComp V X Y Z ≫ eComp V W X Z :=\n  EnrichedCategory.assoc W X Y Z\n\n"}
{"name":"CategoryTheory.e_assoc'_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nW X Y Z✝ : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom W Z✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W X Z✝) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W Y Z✝) h))","decl":"@[reassoc]\ntheorem e_assoc' (W X Y Z : C) :\n    (α_ _ _ _).hom ≫ _ ◁ eComp V X Y Z ≫ eComp V W X Z =\n      eComp V W X Y ▷ _ ≫ eComp V W Y Z := by\n  rw [← e_assoc V W X Y Z, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.e_assoc'","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z)) (CategoryTheory.eComp V W X Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.eComp V W Y Z))","decl":"@[reassoc]\ntheorem e_assoc' (W X Y Z : C) :\n    (α_ _ _ _).hom ≫ _ ◁ eComp V X Y Z ≫ eComp V W X Z =\n      eComp V W X Y ▷ _ ≫ eComp V W Y Z := by\n  rw [← e_assoc V W X Y Z, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.to_of","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX : C\n⊢ Eq (CategoryTheory.ForgetEnrichment.to W (CategoryTheory.ForgetEnrichment.of W X)) X","decl":"@[simp]\ntheorem ForgetEnrichment.to_of (X : C) : ForgetEnrichment.to W (ForgetEnrichment.of W X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.of_to","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX : CategoryTheory.ForgetEnrichment W C\n⊢ Eq (CategoryTheory.ForgetEnrichment.of W (CategoryTheory.ForgetEnrichment.to W X)) X","decl":"@[simp]\ntheorem ForgetEnrichment.of_to (X : ForgetEnrichment W C) :\n    ForgetEnrichment.of W (ForgetEnrichment.to W X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.homTo_homOf","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX Y : C\nf : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.EnrichedCategory.Hom X Y)\n⊢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.ForgetEnrichment.homOf W f)) f","decl":"@[simp]\ntheorem ForgetEnrichment.homTo_homOf {X Y : C} (f : 𝟙_ W ⟶ X ⟶[W] Y) :\n    ForgetEnrichment.homTo W (ForgetEnrichment.homOf W f) = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.homOf_homTo","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX Y : CategoryTheory.ForgetEnrichment W C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.ForgetEnrichment.homOf W (CategoryTheory.ForgetEnrichment.homTo W f)) f","decl":"@[simp]\ntheorem ForgetEnrichment.homOf_homTo {X Y : ForgetEnrichment W C} (f : X ⟶ Y) :\n    ForgetEnrichment.homOf W (ForgetEnrichment.homTo W f) = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.forgetEnrichment_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX : CategoryTheory.ForgetEnrichment W C\n⊢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X))","decl":"/-- The identity in the \"underlying\" category of an enriched category. -/\n@[simp]\ntheorem forgetEnrichment_id (X : ForgetEnrichment W C) :\n    ForgetEnrichment.homTo W (𝟙 X) = eId W (ForgetEnrichment.to W X : C) :=\n  Category.id_comp _\n\n"}
{"name":"CategoryTheory.forgetEnrichment_id'","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX : C\n⊢ Eq (CategoryTheory.ForgetEnrichment.homOf W (CategoryTheory.eId W X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.ForgetEnrichment.of W X))","decl":"@[simp]\ntheorem forgetEnrichment_id' (X : C) :\n    ForgetEnrichment.homOf W (eId W X) = 𝟙 (ForgetEnrichment.of W X : C) :=\n  (forgetEnrichment_id W (ForgetEnrichment.of W X)).symm\n\n"}
{"name":"CategoryTheory.forgetEnrichment_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\nW : Type v\ninst✝² : CategoryTheory.Category.{w, v} W\ninst✝¹ : CategoryTheory.MonoidalCategory W\ninst✝ : CategoryTheory.EnrichedCategory W C\nX Y Z : CategoryTheory.ForgetEnrichment W C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.ForgetEnrichment.homTo W f) (CategoryTheory.ForgetEnrichment.homTo W g))) (CategoryTheory.eComp W (CategoryTheory.ForgetEnrichment.to W X) (CategoryTheory.ForgetEnrichment.to W Y) (CategoryTheory.ForgetEnrichment.to W Z)))","decl":"/-- Composition in the \"underlying\" category of an enriched category. -/\n@[simp]\ntheorem forgetEnrichment_comp {X Y Z : ForgetEnrichment W C} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    ForgetEnrichment.homTo W (f ≫ g) =\n      ((λ_ (𝟙_ W)).inv ≫ (ForgetEnrichment.homTo W f ⊗ ForgetEnrichment.homTo W g)) ≫\n        eComp W _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (self.map X X)) (CategoryTheory.eId V (self.obj X))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ⟶[V] Y` to `F.obj X ⟶[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u₁) [EnrichedCategory V C] (D : Type u₂)\n    [EnrichedCategory V D] where\n  obj : C → D\n  map : ∀ X Y : C, (X ⟶[V] Y) ⟶ obj X ⟶[V] obj Y\n  map_id : ∀ X : C, eId V X ≫ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ∀ X Y Z : C,\n      eComp V X Y Z ≫ map X Z = (map X Y ⊗ map Y Z) ≫ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX Y Z : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (self.map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.map X Y) (self.map Y Z)) (CategoryTheory.eComp V (self.obj X) (self.obj Y) (self.obj Z)))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ⟶[V] Y` to `F.obj X ⟶[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u₁) [EnrichedCategory V C] (D : Type u₂)\n    [EnrichedCategory V D] where\n  obj : C → D\n  map : ∀ X Y : C, (X ⟶[V] Y) ⟶ obj X ⟶[V] obj Y\n  map_id : ∀ X : C, eId V X ≫ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ∀ X Y Z : C,\n      eComp V X Y Z ≫ map X Z = (map X Y ⊗ map Y Z) ≫ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁶ : CategoryTheory.Category.{w, v} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝⁴ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝³ : CategoryTheory.EnrichedCategory V D\ninst✝² : SizeOf V\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\nobj : C → D\nmap : (X Y : C) → Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto✝\nmap_comp : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto✝\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) 1","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ⟶[V] Y` to `F.obj X ⟶[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u₁) [EnrichedCategory V C] (D : Type u₂)\n    [EnrichedCategory V D] where\n  obj : C → D\n  map : ∀ X Y : C, (X ⟶[V] Y) ⟶ obj X ⟶[V] obj Y\n  map_id : ∀ X : C, eId V X ≫ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ∀ X Y Z : C,\n      eComp V X Y Z ≫ map X Z = (map X Y ⊗ map Y Z) ≫ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nobj✝ : C → D\nmap✝ : (X Y : C) → Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj✝ X) (obj✝ Y))\nmap_id✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map✝ X X)) (CategoryTheory.eId V (obj✝ X))) _auto✝\nmap_comp✝ : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map✝ X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map✝ X Y) (map✝ Y Z)) (CategoryTheory.eComp V (obj✝ X) (obj✝ Y) (obj✝ Z)))) _auto✝\nobj : C → D\nmap : (X Y : C) → Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto✝\nmap_comp : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto✝\n⊢ Eq (Eq { obj := obj✝, map := map✝, map_id := map_id✝, map_comp := map_comp✝ } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) (And (Eq obj✝ obj) (HEq map✝ map))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ⟶[V] Y` to `F.obj X ⟶[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u₁) [EnrichedCategory V C] (D : Type u₂)\n    [EnrichedCategory V D] where\n  obj : C → D\n  map : ∀ X Y : C, (X ⟶[V] Y) ⟶ obj X ⟶[V] obj Y\n  map_id : ∀ X : C, eId V X ≫ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ∀ X Y Z : C,\n      eComp V X Y Z ≫ map X Z = (map X Y ⊗ map Y Z) ≫ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.inj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nobj✝ : C → D\nmap✝ : (X Y : C) → Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj✝ X) (obj✝ Y))\nmap_id✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map✝ X X)) (CategoryTheory.eId V (obj✝ X))) _auto✝\nmap_comp✝ : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map✝ X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map✝ X Y) (map✝ Y Z)) (CategoryTheory.eComp V (obj✝ X) (obj✝ Y) (obj✝ Z)))) _auto✝\nobj : C → D\nmap : (X Y : C) → Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto✝\nmap_comp : autoParam (∀ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto✝\nx✝ : Eq { obj := obj✝, map := map✝, map_id := map_id✝, map_comp := map_comp✝ } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }\n⊢ And (Eq obj✝ obj) (HEq map✝ map)","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ⟶[V] Y` to `F.obj X ⟶[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u₁) [EnrichedCategory V C] (D : Type u₂)\n    [EnrichedCategory V D] where\n  obj : C → D\n  map : ∀ X Y : C, (X ⟶[V] Y) ⟶ obj X ⟶[V] obj Y\n  map_id : ∀ X : C, eId V X ≫ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ∀ X Y Z : C,\n      eComp V X Y Z ≫ map X Z = (map X Y ⊗ map Y Z) ≫ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_id_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (self.obj X) (self.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (CategoryTheory.CategoryStruct.comp (self.map X X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V (self.obj X)) h)","decl":"attribute [reassoc (attr := simp)] EnrichedFunctor.map_id\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX Y Z✝ : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (self.obj X) (self.obj Z✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z✝) (CategoryTheory.CategoryStruct.comp (self.map X Z✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.map X Y) (self.map Y Z✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (self.obj X) (self.obj Y) (self.obj Z✝)) h))","decl":"attribute [reassoc (attr := simp)] EnrichedFunctor.map_comp\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.id_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nx✝¹ x✝ : C\n⊢ Eq ((CategoryTheory.EnrichedFunctor.id V C).map x✝¹ x✝) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom x✝¹ x✝))","decl":"/-- The identity enriched functor. -/\n@[simps]\ndef EnrichedFunctor.id (C : Type u₁) [EnrichedCategory V C] : EnrichedFunctor V C C where\n  obj X := X\n  map _ _ := 𝟙 _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.id_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝² : CategoryTheory.Category.{w, v} V\ninst✝¹ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝ : CategoryTheory.EnrichedCategory V C\nX : C\n⊢ Eq ((CategoryTheory.EnrichedFunctor.id V C).obj X) X","decl":"/-- The identity enriched functor. -/\n@[simps]\ndef EnrichedFunctor.id (C : Type u₁) [EnrichedCategory V C] : EnrichedFunctor V C C where\n  obj X := X\n  map _ _ := 𝟙 _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.comp_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁴ : CategoryTheory.Category.{w, v} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.EnrichedCategory V C\ninst✝¹ : CategoryTheory.EnrichedCategory V D\ninst✝ : CategoryTheory.EnrichedCategory V E\nF : CategoryTheory.EnrichedFunctor V C D\nG : CategoryTheory.EnrichedFunctor V D E\nX : C\n⊢ Eq ((CategoryTheory.EnrichedFunctor.comp V F G).obj X) (G.obj (F.obj X))","decl":"/-- Composition of enriched functors. -/\n@[simps]\ndef EnrichedFunctor.comp {C : Type u₁} {D : Type u₂} {E : Type u₃} [EnrichedCategory V C]\n    [EnrichedCategory V D] [EnrichedCategory V E] (F : EnrichedFunctor V C D)\n    (G : EnrichedFunctor V D E) : EnrichedFunctor V C E where\n  obj X := G.obj (F.obj X)\n  map _ _ := F.map _ _ ≫ G.map _ _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.comp_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁴ : CategoryTheory.Category.{w, v} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₁\nD : Type u₂\nE : Type u₃\ninst✝² : CategoryTheory.EnrichedCategory V C\ninst✝¹ : CategoryTheory.EnrichedCategory V D\ninst✝ : CategoryTheory.EnrichedCategory V E\nF : CategoryTheory.EnrichedFunctor V C D\nG : CategoryTheory.EnrichedFunctor V D E\nx✝¹ x✝ : C\n⊢ Eq ((CategoryTheory.EnrichedFunctor.comp V F G).map x✝¹ x✝) (CategoryTheory.CategoryStruct.comp (F.map x✝¹ x✝) (G.map (F.obj x✝¹) (F.obj x✝)))","decl":"/-- Composition of enriched functors. -/\n@[simps]\ndef EnrichedFunctor.comp {C : Type u₁} {D : Type u₂} {E : Type u₃} [EnrichedCategory V C]\n    [EnrichedCategory V D] [EnrichedCategory V E] (F : EnrichedFunctor V C D)\n    (G : EnrichedFunctor V D E) : EnrichedFunctor V C E where\n  obj X := G.obj (F.obj X)\n  map _ _ := F.map _ _ ≫ G.map _ _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.ext","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.EnrichedCategory V C\ninst✝ : CategoryTheory.EnrichedCategory V D\nF G : CategoryTheory.EnrichedFunctor V C D\nh_obj : ∀ (X : C), Eq (F.obj X) (G.obj X)\nh_map : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (F.map X Y) (CategoryTheory.eqToHom ⋯)) (G.map X Y)\n⊢ Eq F G","decl":"lemma EnrichedFunctor.ext {C : Type u₁} {D : Type u₂} [EnrichedCategory V C]\n    [EnrichedCategory V D] {F G : EnrichedFunctor V C D} (h_obj : ∀ X, F.obj X = G.obj X)\n    (h_map : ∀ (X Y : C), F.map X Y ≫ eqToHom (by rw [h_obj, h_obj]) = G.map X Y) : F = G := by\n  match F, G with\n  | mk F_obj F_map _ _, mk G_obj G_map _ _ =>\n    obtain rfl : F_obj = G_obj := funext fun X ↦ h_obj X\n    congr\n    ext X Y\n    simpa using h_map X Y\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\napp✝ : (X : C) → Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality✝ : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app✝ Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app✝ X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\napp : (X : C) → Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\n⊢ Eq (Eq { app := app✝, naturality := naturality✝ } { app := app, naturality := naturality }) (Eq app✝ app)","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.inj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\napp✝ : (X : C) → Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality✝ : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app✝ Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app✝ X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\napp : (X : C) → Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\nx✝ : Eq { app := app✝, naturality := naturality✝ } { app := app, naturality := naturality }\n⊢ Eq app✝ app","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.ext","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nx y : CategoryTheory.GradedNatTrans A F G\napp : Eq x.app y.app\n⊢ Eq x y","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.ext_iff","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nx y : CategoryTheory.GradedNatTrans A F G\n⊢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.naturality","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝³ : CategoryTheory.Category.{w, v} V\ninst✝² : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝¹ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nself : CategoryTheory.GradedNatTrans A F G\nX Y : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (self.app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁶ : CategoryTheory.Category.{w, v} V\ninst✝⁵ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝⁴ : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝³ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\ninst✝² : SizeOf V\ninst✝¹ : SizeOf C\ninst✝ : SizeOf D\napp : (X : C) → Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ∀ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.β (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\n⊢ Eq (SizeOf.sizeOf { app := app, naturality := naturality }) 1","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ∀ X : C, A.1 ⟶ F.obj X ⟶[V] G.obj X\n  naturality :\n    ∀ X Y : C,\n      (A.2.β (X ⟶[V] Y)).hom ≫ (F.map X Y ⊗ app Y) ≫ eComp V _ _ _ =\n        (app X ⊗ G.map X Y) ≫ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.enrichedNatTransYoneda_map_app","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁴ : CategoryTheory.Category.{w, v} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝² : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝¹ : CategoryTheory.EnrichedCategory V D\ninst✝ : CategoryTheory.BraidedCategory V\nF G : CategoryTheory.EnrichedFunctor V C D\nX✝ Y✝ : Opposite V\nf : Quiver.Hom X✝ Y✝\nσ : CategoryTheory.GradedNatTrans ((CategoryTheory.Center.ofBraided V).obj (Opposite.unop X✝)) F G\nX : C\n⊢ Eq (((CategoryTheory.enrichedNatTransYoneda F G).map f σ).app X) (CategoryTheory.CategoryStruct.comp f.unop (σ.app X))","decl":"/-- A presheaf isomorphic to the Yoneda embedding of\nthe `V`-object of natural transformations from `F` to `G`.\n-/\n@[simps]\ndef enrichedNatTransYoneda (F G : EnrichedFunctor V C D) : Vᵒᵖ ⥤ Type max u₁ w where\n  obj A := GradedNatTrans ((Center.ofBraided V).obj (unop A)) F G\n  map f σ :=\n    { app := fun X => f.unop ≫ σ.app X\n      naturality := fun X Y => by\n        have p := σ.naturality X Y\n        dsimp at p ⊢\n        rw [← id_tensor_comp_tensor_id (f.unop ≫ σ.app Y) _, id_tensor_comp, Category.assoc,\n          Category.assoc, ← braiding_naturality_assoc, id_tensor_comp_tensor_id_assoc, p, ←\n          tensor_comp_assoc, Category.id_comp] }\n\n-- TODO assuming `[HasLimits C]` construct the actual object of natural transformations\n-- and show that the functor category is `V`-enriched.\n"}
{"name":"CategoryTheory.enrichedNatTransYoneda_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst✝⁴ : CategoryTheory.Category.{w, v} V\ninst✝³ : CategoryTheory.MonoidalCategory V\nC : Type u₁\ninst✝² : CategoryTheory.EnrichedCategory V C\nD : Type u₂\ninst✝¹ : CategoryTheory.EnrichedCategory V D\ninst✝ : CategoryTheory.BraidedCategory V\nF G : CategoryTheory.EnrichedFunctor V C D\nA : Opposite V\n⊢ Eq ((CategoryTheory.enrichedNatTransYoneda F G).obj A) (CategoryTheory.GradedNatTrans ((CategoryTheory.Center.ofBraided V).obj (Opposite.unop A)) F G)","decl":"/-- A presheaf isomorphic to the Yoneda embedding of\nthe `V`-object of natural transformations from `F` to `G`.\n-/\n@[simps]\ndef enrichedNatTransYoneda (F G : EnrichedFunctor V C D) : Vᵒᵖ ⥤ Type max u₁ w where\n  obj A := GradedNatTrans ((Center.ofBraided V).obj (unop A)) F G\n  map f σ :=\n    { app := fun X => f.unop ≫ σ.app X\n      naturality := fun X Y => by\n        have p := σ.naturality X Y\n        dsimp at p ⊢\n        rw [← id_tensor_comp_tensor_id (f.unop ≫ σ.app Y) _, id_tensor_comp, Category.assoc,\n          Category.assoc, ← braiding_naturality_assoc, id_tensor_comp_tensor_id_assoc, p, ←\n          tensor_comp_assoc, Category.id_comp] }\n\n-- TODO assuming `[HasLimits C]` construct the actual object of natural transformations\n-- and show that the functor category is `V`-enriched.\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_symm_apply_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\n𝒞 : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u₂\n𝒟 : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor.symm F).obj X) (F.obj X)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u₁} [𝒞 : EnrichedCategory (Type v) C] {D : Type u₂}\n    [𝒟 : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ≃ C ⥤ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ⟨f, g⟩ }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ⟨⟩; exact F.map_id X\n      map_comp := fun X Y Z => by ext ⟨f, g⟩; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_symm_apply_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\n𝒞 : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u₂\n𝒟 : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.Functor C D\nx✝¹ x✝ : C\nf : CategoryTheory.EnrichedCategory.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor.symm F).map x✝¹ x✝ f) (F.map f)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u₁} [𝒞 : EnrichedCategory (Type v) C] {D : Type u₂}\n    [𝒟 : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ≃ C ⥤ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ⟨f, g⟩ }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ⟨⟩; exact F.map_id X\n      map_comp := fun X Y Z => by ext ⟨f, g⟩; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_apply_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\n𝒞 : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u₂\n𝒟 : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.EnrichedFunctor (Type v) C D\nX : C\n⊢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor F).obj X) (F.obj X)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u₁} [𝒞 : EnrichedCategory (Type v) C] {D : Type u₂}\n    [𝒟 : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ≃ C ⥤ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ⟨f, g⟩ }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ⟨⟩; exact F.map_id X\n      map_comp := fun X Y Z => by ext ⟨f, g⟩; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_apply_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u₁\n𝒞 : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u₂\n𝒟 : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.EnrichedFunctor (Type v) C D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor F).map f) (F.map X✝ Y✝ f)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u₁} [𝒞 : EnrichedCategory (Type v) C] {D : Type u₂}\n    [𝒟 : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ≃ C ⥤ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ⟨f, g⟩ }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ⟨⟩; exact F.map_id X\n      map_comp := fun X Y Z => by ext ⟨f, g⟩; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
