{"name":"CategoryTheory.EnrichedCategory.assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} V\ninst‚úù : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nself : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.EnrichedCategory.comp W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.EnrichedCategory.comp W Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.comp X Y Z)) (CategoryTheory.EnrichedCategory.comp W X Z))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u‚ÇÅ) where\n  Hom : C ‚Üí C ‚Üí V\n  id (X : C) : ùüô_ V ‚ü∂ Hom X X\n  comp (X Y Z : C) : Hom X Y ‚äó Hom Y Z ‚ü∂ Hom X Z\n  id_comp (X Y : C) : (Œª_ (Hom X Y)).inv ‚â´ id X ‚ñ∑ _ ‚â´ comp X X Y = ùüô _ := by aesop_cat\n  comp_id (X Y : C) : (œÅ_ (Hom X Y)).inv ‚â´ _ ‚óÅ id Y ‚â´ comp X Y Y = ùüô _ := by aesop_cat\n  assoc (W X Y Z : C) : (Œ±_ _ _ _).inv ‚â´ comp W X Y ‚ñ∑ _ ‚â´ comp W Y Z =\n    _ ‚óÅ comp X Y Z ‚â´ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedCategory.id_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} V\ninst‚úù : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nself : CategoryTheory.EnrichedCategory V C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.EnrichedCategory.id X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.EnrichedCategory.comp X X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u‚ÇÅ) where\n  Hom : C ‚Üí C ‚Üí V\n  id (X : C) : ùüô_ V ‚ü∂ Hom X X\n  comp (X Y Z : C) : Hom X Y ‚äó Hom Y Z ‚ü∂ Hom X Z\n  id_comp (X Y : C) : (Œª_ (Hom X Y)).inv ‚â´ id X ‚ñ∑ _ ‚â´ comp X X Y = ùüô _ := by aesop_cat\n  comp_id (X Y : C) : (œÅ_ (Hom X Y)).inv ‚â´ _ ‚óÅ id Y ‚â´ comp X Y Y = ùüô _ := by aesop_cat\n  assoc (W X Y Z : C) : (Œ±_ _ _ _).inv ‚â´ comp W X Y ‚ñ∑ _ ‚â´ comp W Y Z =\n    _ ‚óÅ comp X Y Z ‚â´ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedCategory.comp_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬π : CategoryTheory.Category.{w, v} V\ninst‚úù : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nself : CategoryTheory.EnrichedCategory V C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.id Y)) (CategoryTheory.EnrichedCategory.comp X Y Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"/-- A `V`-category is a category enriched in a monoidal category `V`.\n\nNote that we do not assume that `V` is a concrete category,\nso there may not be an \"honest\" underlying category at all!\n-/\nclass EnrichedCategory (C : Type u‚ÇÅ) where\n  Hom : C ‚Üí C ‚Üí V\n  id (X : C) : ùüô_ V ‚ü∂ Hom X X\n  comp (X Y Z : C) : Hom X Y ‚äó Hom Y Z ‚ü∂ Hom X Z\n  id_comp (X Y : C) : (Œª_ (Hom X Y)).inv ‚â´ id X ‚ñ∑ _ ‚â´ comp X X Y = ùüô _ := by aesop_cat\n  comp_id (X Y : C) : (œÅ_ (Hom X Y)).inv ‚â´ _ ‚óÅ id Y ‚â´ comp X Y Y = ùüô _ := by aesop_cat\n  assoc (W X Y Z : C) : (Œ±_ _ _ _).inv ‚â´ comp W X Y ‚ñ∑ _ ‚â´ comp W Y Z =\n    _ ‚óÅ comp X Y Z ‚â´ comp W X Z := by aesop_cat\n\n"}
{"name":"CategoryTheory.e_id_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eId V X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.eComp V X X Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[reassoc (attr := simp)]\ntheorem e_id_comp (X Y : C) :\n    (Œª_ (X ‚ü∂[V] Y)).inv ‚â´ eId V X ‚ñ∑ _ ‚â´ eComp V X X Y = ùüô (X ‚ü∂[V] Y) :=\n  EnrichedCategory.id_comp X Y\n\n"}
{"name":"CategoryTheory.e_id_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nX Y : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eId V X) (CategoryTheory.EnrichedCategory.Hom X Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X X Y) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem e_id_comp (X Y : C) :\n    (Œª_ (X ‚ü∂[V] Y)).inv ‚â´ eId V X ‚ñ∑ _ ‚â´ eComp V X X Y = ùüô (X ‚ü∂[V] Y) :=\n  EnrichedCategory.id_comp X Y\n\n"}
{"name":"CategoryTheory.e_comp_id_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nX Y : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eId V Y)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Y) h))) h","decl":"@[reassoc (attr := simp)]\ntheorem e_comp_id (X Y : C) :\n    (œÅ_ (X ‚ü∂[V] Y)).inv ‚â´ _ ‚óÅ eId V Y ‚â´ eComp V X Y Y = ùüô (X ‚ü∂[V] Y) :=\n  EnrichedCategory.comp_id X Y\n\n"}
{"name":"CategoryTheory.e_comp_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.EnrichedCategory.Hom X Y)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.eId V Y)) (CategoryTheory.eComp V X Y Y))) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom X Y))","decl":"@[reassoc (attr := simp)]\ntheorem e_comp_id (X Y : C) :\n    (œÅ_ (X ‚ü∂[V] Y)).inv ‚â´ _ ‚óÅ eId V Y ‚â´ eComp V X Y Y = ùüô (X ‚ü∂[V] Y) :=\n  EnrichedCategory.comp_id X Y\n\n"}
{"name":"CategoryTheory.e_assoc_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nW X Y Z‚úù : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom W Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z‚úù)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W Y Z‚úù) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W X Z‚úù) h))","decl":"@[reassoc (attr := simp)]\ntheorem e_assoc (W X Y Z : C) :\n    (Œ±_ _ _ _).inv ‚â´ eComp V W X Y ‚ñ∑ _ ‚â´ eComp V W Y Z =\n      _ ‚óÅ eComp V X Y Z ‚â´ eComp V W X Z :=\n  EnrichedCategory.assoc W X Y Z\n\n"}
{"name":"CategoryTheory.e_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.eComp V W Y Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z)) (CategoryTheory.eComp V W X Z))","decl":"@[reassoc (attr := simp)]\ntheorem e_assoc (W X Y Z : C) :\n    (Œ±_ _ _ _).inv ‚â´ eComp V W X Y ‚ñ∑ _ ‚â´ eComp V W Y Z =\n      _ ‚óÅ eComp V X Y Z ‚â´ eComp V W X Z :=\n  EnrichedCategory.assoc W X Y Z\n\n"}
{"name":"CategoryTheory.e_assoc'_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nW X Y Z‚úù : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom W Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z‚úù)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W X Z‚úù) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V W Y Z‚úù) h))","decl":"@[reassoc]\ntheorem e_assoc' (W X Y Z : C) :\n    (Œ±_ _ _ _).hom ‚â´ _ ‚óÅ eComp V X Y Z ‚â´ eComp V W X Z =\n      eComp V W X Y ‚ñ∑ _ ‚â´ eComp V W Y Z := by\n  rw [‚Üê e_assoc V W X Y Z, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.e_assoc'","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nW X Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.EnrichedCategory.Hom W X) (CategoryTheory.eComp V X Y Z)) (CategoryTheory.eComp V W X Z))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.eComp V W X Y) (CategoryTheory.EnrichedCategory.Hom Y Z)) (CategoryTheory.eComp V W Y Z))","decl":"@[reassoc]\ntheorem e_assoc' (W X Y Z : C) :\n    (Œ±_ _ _ _).hom ‚â´ _ ‚óÅ eComp V X Y Z ‚â´ eComp V W X Z =\n      eComp V W X Y ‚ñ∑ _ ‚â´ eComp V W Y Z := by\n  rw [‚Üê e_assoc V W X Y Z, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.to_of","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX : C\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.to W (CategoryTheory.ForgetEnrichment.of W X)) X","decl":"@[simp]\ntheorem ForgetEnrichment.to_of (X : C) : ForgetEnrichment.to W (ForgetEnrichment.of W X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.of_to","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX : CategoryTheory.ForgetEnrichment W C\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.of W (CategoryTheory.ForgetEnrichment.to W X)) X","decl":"@[simp]\ntheorem ForgetEnrichment.of_to (X : ForgetEnrichment W C) :\n    ForgetEnrichment.of W (ForgetEnrichment.to W X) = X :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.homTo_homOf","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX Y : C\nf : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit (CategoryTheory.EnrichedCategory.Hom X Y)\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.ForgetEnrichment.homOf W f)) f","decl":"@[simp]\ntheorem ForgetEnrichment.homTo_homOf {X Y : C} (f : ùüô_ W ‚ü∂ X ‚ü∂[W] Y) :\n    ForgetEnrichment.homTo W (ForgetEnrichment.homOf W f) = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.ForgetEnrichment.homOf_homTo","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX Y : CategoryTheory.ForgetEnrichment W C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.homOf W (CategoryTheory.ForgetEnrichment.homTo W f)) f","decl":"@[simp]\ntheorem ForgetEnrichment.homOf_homTo {X Y : ForgetEnrichment W C} (f : X ‚ü∂ Y) :\n    ForgetEnrichment.homOf W (ForgetEnrichment.homTo W f) = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.forgetEnrichment_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX : CategoryTheory.ForgetEnrichment W C\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.eId W (CategoryTheory.ForgetEnrichment.to W X))","decl":"/-- The identity in the \"underlying\" category of an enriched category. -/\n@[simp]\ntheorem forgetEnrichment_id (X : ForgetEnrichment W C) :\n    ForgetEnrichment.homTo W (ùüô X) = eId W (ForgetEnrichment.to W X : C) :=\n  Category.id_comp _\n\n"}
{"name":"CategoryTheory.forgetEnrichment_id'","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX : C\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.homOf W (CategoryTheory.eId W X)) (CategoryTheory.CategoryStruct.id (CategoryTheory.ForgetEnrichment.of W X))","decl":"@[simp]\ntheorem forgetEnrichment_id' (X : C) :\n    ForgetEnrichment.homOf W (eId W X) = ùüô (ForgetEnrichment.of W X : C) :=\n  (forgetEnrichment_id W (ForgetEnrichment.of W X)).symm\n\n"}
{"name":"CategoryTheory.forgetEnrichment_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nW : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} W\ninst‚úù¬π : CategoryTheory.MonoidalCategory W\ninst‚úù : CategoryTheory.EnrichedCategory W C\nX Y Z : CategoryTheory.ForgetEnrichment W C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.ForgetEnrichment.homTo W (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.ForgetEnrichment.homTo W f) (CategoryTheory.ForgetEnrichment.homTo W g))) (CategoryTheory.eComp W (CategoryTheory.ForgetEnrichment.to W X) (CategoryTheory.ForgetEnrichment.to W Y) (CategoryTheory.ForgetEnrichment.to W Z)))","decl":"/-- Composition in the \"underlying\" category of an enriched category. -/\n@[simp]\ntheorem forgetEnrichment_comp {X Y Z : ForgetEnrichment W C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    ForgetEnrichment.homTo W (f ‚â´ g) =\n      ((Œª_ (ùüô_ W)).inv ‚â´ (ForgetEnrichment.homTo W f ‚äó ForgetEnrichment.homTo W g)) ‚â´\n        eComp W _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_id","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (self.map X X)) (CategoryTheory.eId V (self.obj X))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ‚ü∂[V] Y` to `F.obj X ‚ü∂[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u‚ÇÅ) [EnrichedCategory V C] (D : Type u‚ÇÇ)\n    [EnrichedCategory V D] where\n  obj : C ‚Üí D\n  map : ‚àÄ X Y : C, (X ‚ü∂[V] Y) ‚ü∂ obj X ‚ü∂[V] obj Y\n  map_id : ‚àÄ X : C, eId V X ‚â´ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ‚àÄ X Y Z : C,\n      eComp V X Y Z ‚â´ map X Z = (map X Y ‚äó map Y Z) ‚â´ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_comp","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (self.map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.map X Y) (self.map Y Z)) (CategoryTheory.eComp V (self.obj X) (self.obj Y) (self.obj Z)))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ‚ü∂[V] Y` to `F.obj X ‚ü∂[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u‚ÇÅ) [EnrichedCategory V C] (D : Type u‚ÇÇ)\n    [EnrichedCategory V D] where\n  obj : C ‚Üí D\n  map : ‚àÄ X Y : C, (X ‚ü∂[V] Y) ‚ü∂ obj X ‚ü∂[V] obj Y\n  map_id : ‚àÄ X : C, eId V X ‚â´ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ‚àÄ X Y Z : C,\n      eComp V X Y Z ‚â´ map X Z = (map X Y ‚äó map Y Z) ‚â´ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, v} V\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.EnrichedCategory V D\ninst‚úù¬≤ : SizeOf V\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nobj : C ‚Üí D\nmap : (X Y : C) ‚Üí Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) 1","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ‚ü∂[V] Y` to `F.obj X ‚ü∂[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u‚ÇÅ) [EnrichedCategory V C] (D : Type u‚ÇÇ)\n    [EnrichedCategory V D] where\n  obj : C ‚Üí D\n  map : ‚àÄ X Y : C, (X ‚ü∂[V] Y) ‚ü∂ obj X ‚ü∂[V] obj Y\n  map_id : ‚àÄ X : C, eId V X ‚â´ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ‚àÄ X Y Z : C,\n      eComp V X Y Z ‚â´ map X Z = (map X Y ‚äó map Y Z) ‚â´ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.injEq","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nobj‚úù : C ‚Üí D\nmap‚úù : (X Y : C) ‚Üí Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj‚úù X) (obj‚úù Y))\nmap_id‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map‚úù X X)) (CategoryTheory.eId V (obj‚úù X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map‚úù X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map‚úù X Y) (map‚úù Y Z)) (CategoryTheory.eComp V (obj‚úù X) (obj‚úù Y) (obj‚úù Z)))) _auto‚úù\nobj : C ‚Üí D\nmap : (X Y : C) ‚Üí Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto‚úù\n‚ä¢ Eq (Eq { obj := obj‚úù, map := map‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) (And (Eq obj‚úù obj) (HEq map‚úù map))","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ‚ü∂[V] Y` to `F.obj X ‚ü∂[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u‚ÇÅ) [EnrichedCategory V C] (D : Type u‚ÇÇ)\n    [EnrichedCategory V D] where\n  obj : C ‚Üí D\n  map : ‚àÄ X Y : C, (X ‚ü∂[V] Y) ‚ü∂ obj X ‚ü∂[V] obj Y\n  map_id : ‚àÄ X : C, eId V X ‚â´ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ‚àÄ X Y Z : C,\n      eComp V X Y Z ‚â´ map X Z = (map X Y ‚äó map Y Z) ‚â´ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.mk.inj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nobj‚úù : C ‚Üí D\nmap‚úù : (X Y : C) ‚Üí Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj‚úù X) (obj‚úù Y))\nmap_id‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map‚úù X X)) (CategoryTheory.eId V (obj‚úù X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map‚úù X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map‚úù X Y) (map‚úù Y Z)) (CategoryTheory.eComp V (obj‚úù X) (obj‚úù Y) (obj‚úù Z)))) _auto‚úù\nobj : C ‚Üí D\nmap : (X Y : C) ‚Üí Quiver.Hom (CategoryTheory.EnrichedCategory.Hom X Y) (CategoryTheory.EnrichedCategory.Hom (obj X) (obj Y))\nmap_id : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (map X X)) (CategoryTheory.eId V (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ (X Y Z : C), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z) (map X Z)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (map X Y) (map Y Z)) (CategoryTheory.eComp V (obj X) (obj Y) (obj Z)))) _auto‚úù\nx‚úù : Eq { obj := obj‚úù, map := map‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }\n‚ä¢ And (Eq obj‚úù obj) (HEq map‚úù map)","decl":"/-- A `V`-functor `F` between `V`-enriched categories\nhas a `V`-morphism from `X ‚ü∂[V] Y` to `F.obj X ‚ü∂[V] F.obj Y`,\nsatisfying the usual axioms.\n-/\nstructure EnrichedFunctor (C : Type u‚ÇÅ) [EnrichedCategory V C] (D : Type u‚ÇÇ)\n    [EnrichedCategory V D] where\n  obj : C ‚Üí D\n  map : ‚àÄ X Y : C, (X ‚ü∂[V] Y) ‚ü∂ obj X ‚ü∂[V] obj Y\n  map_id : ‚àÄ X : C, eId V X ‚â´ map X X = eId V (obj X) := by aesop_cat\n  map_comp :\n    ‚àÄ X Y Z : C,\n      eComp V X Y Z ‚â´ map X Z = (map X Y ‚äó map Y Z) ‚â´ eComp V (obj X) (obj Y) (obj Z) := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_id_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (self.obj X) (self.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V X) (CategoryTheory.CategoryStruct.comp (self.map X X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eId V (self.obj X)) h)","decl":"attribute [reassoc (attr := simp)] EnrichedFunctor.map_id\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.map_comp_assoc","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nself : CategoryTheory.EnrichedFunctor V C D\nX Y Z‚úù : C\nZ : V\nh : Quiver.Hom (CategoryTheory.EnrichedCategory.Hom (self.obj X) (self.obj Z‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V X Y Z‚úù) (CategoryTheory.CategoryStruct.comp (self.map X Z‚úù) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.map X Y) (self.map Y Z‚úù)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eComp V (self.obj X) (self.obj Y) (self.obj Z‚úù)) h))","decl":"attribute [reassoc (attr := simp)] EnrichedFunctor.map_comp\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.id_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nx‚úù¬π x‚úù : C\n‚ä¢ Eq ((CategoryTheory.EnrichedFunctor.id V C).map x‚úù¬π x‚úù) (CategoryTheory.CategoryStruct.id (CategoryTheory.EnrichedCategory.Hom x‚úù¬π x‚úù))","decl":"/-- The identity enriched functor. -/\n@[simps]\ndef EnrichedFunctor.id (C : Type u‚ÇÅ) [EnrichedCategory V C] : EnrichedFunctor V C C where\n  obj X := X\n  map _ _ := ùüô _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.id_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≤ : CategoryTheory.Category.{w, v} V\ninst‚úù¬π : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù : CategoryTheory.EnrichedCategory V C\nX : C\n‚ä¢ Eq ((CategoryTheory.EnrichedFunctor.id V C).obj X) X","decl":"/-- The identity enriched functor. -/\n@[simps]\ndef EnrichedFunctor.id (C : Type u‚ÇÅ) [EnrichedCategory V C] : EnrichedFunctor V C C where\n  obj X := X\n  map _ _ := ùüô _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.comp_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.EnrichedCategory V C\ninst‚úù¬π : CategoryTheory.EnrichedCategory V D\ninst‚úù : CategoryTheory.EnrichedCategory V E\nF : CategoryTheory.EnrichedFunctor V C D\nG : CategoryTheory.EnrichedFunctor V D E\nX : C\n‚ä¢ Eq ((CategoryTheory.EnrichedFunctor.comp V F G).obj X) (G.obj (F.obj X))","decl":"/-- Composition of enriched functors. -/\n@[simps]\ndef EnrichedFunctor.comp {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} {E : Type u‚ÇÉ} [EnrichedCategory V C]\n    [EnrichedCategory V D] [EnrichedCategory V E] (F : EnrichedFunctor V C D)\n    (G : EnrichedFunctor V D E) : EnrichedFunctor V C E where\n  obj X := G.obj (F.obj X)\n  map _ _ := F.map _ _ ‚â´ G.map _ _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.comp_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nD : Type u‚ÇÇ\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.EnrichedCategory V C\ninst‚úù¬π : CategoryTheory.EnrichedCategory V D\ninst‚úù : CategoryTheory.EnrichedCategory V E\nF : CategoryTheory.EnrichedFunctor V C D\nG : CategoryTheory.EnrichedFunctor V D E\nx‚úù¬π x‚úù : C\n‚ä¢ Eq ((CategoryTheory.EnrichedFunctor.comp V F G).map x‚úù¬π x‚úù) (CategoryTheory.CategoryStruct.comp (F.map x‚úù¬π x‚úù) (G.map (F.obj x‚úù¬π) (F.obj x‚úù)))","decl":"/-- Composition of enriched functors. -/\n@[simps]\ndef EnrichedFunctor.comp {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} {E : Type u‚ÇÉ} [EnrichedCategory V C]\n    [EnrichedCategory V D] [EnrichedCategory V E] (F : EnrichedFunctor V C D)\n    (G : EnrichedFunctor V D E) : EnrichedFunctor V C E where\n  obj X := G.obj (F.obj X)\n  map _ _ := F.map _ _ ‚â´ G.map _ _\n\n"}
{"name":"CategoryTheory.EnrichedFunctor.ext","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\ninst‚úù : CategoryTheory.EnrichedCategory V D\nF G : CategoryTheory.EnrichedFunctor V C D\nh_obj : ‚àÄ (X : C), Eq (F.obj X) (G.obj X)\nh_map : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (F.map X Y) (CategoryTheory.eqToHom ‚ãØ)) (G.map X Y)\n‚ä¢ Eq F G","decl":"lemma EnrichedFunctor.ext {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [EnrichedCategory V C]\n    [EnrichedCategory V D] {F G : EnrichedFunctor V C D} (h_obj : ‚àÄ X, F.obj X = G.obj X)\n    (h_map : ‚àÄ (X Y : C), F.map X Y ‚â´ eqToHom (by rw [h_obj, h_obj]) = G.map X Y) : F = G := by\n  match F, G with\n  | mk F_obj F_map _ _, mk G_obj G_map _ _ =>\n    obtain rfl : F_obj = G_obj := funext fun X ‚Ü¶ h_obj X\n    congr\n    ext X Y\n    simpa using h_map X Y\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\napp‚úù : (X : C) ‚Üí Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality‚úù : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app‚úù Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app‚úù X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\napp : (X : C) ‚Üí Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\n‚ä¢ Eq (Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }) (Eq app‚úù app)","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.inj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\napp‚úù : (X : C) ‚Üí Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality‚úù : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app‚úù Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app‚úù X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\napp : (X : C) ‚Üí Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\nx‚úù : Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }\n‚ä¢ Eq app‚úù app","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.ext","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nx y : CategoryTheory.GradedNatTrans A F G\napp : Eq x.app y.app\n‚ä¢ Eq x y","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.ext_iff","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nx y : CategoryTheory.GradedNatTrans A F G\n‚ä¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.naturality","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù¬≥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\nself : CategoryTheory.GradedNatTrans A F G\nX Y : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (self.app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (self.app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.GradedNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å∂ : CategoryTheory.Category.{w, v} V\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.EnrichedCategory V D\nA : CategoryTheory.Center V\nF G : CategoryTheory.EnrichedFunctor V C D\ninst‚úù¬≤ : SizeOf V\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\napp : (X : C) ‚Üí Quiver.Hom A.fst (CategoryTheory.EnrichedCategory.Hom (F.obj X) (G.obj X))\nnaturality : ‚àÄ (X Y : C), Eq (CategoryTheory.CategoryStruct.comp (A.snd.Œ≤ (CategoryTheory.EnrichedCategory.Hom X Y)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (F.map X Y) (app Y)) (CategoryTheory.eComp V (F.obj X) (F.obj Y) (G.obj Y)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (app X) (G.map X Y)) (CategoryTheory.eComp V (F.obj X) (G.obj X) (G.obj Y)))\n‚ä¢ Eq (SizeOf.sizeOf { app := app, naturality := naturality }) 1","decl":"/-- The type of `A`-graded natural transformations between `V`-functors `F` and `G`.\nThis is the type of morphisms in `V` from `A` to the `V`-object of natural transformations.\n-/\n@[ext]\nstructure GradedNatTrans (A : Center V) (F G : EnrichedFunctor V C D) where\n  app : ‚àÄ X : C, A.1 ‚ü∂ F.obj X ‚ü∂[V] G.obj X\n  naturality :\n    ‚àÄ X Y : C,\n      (A.2.Œ≤ (X ‚ü∂[V] Y)).hom ‚â´ (F.map X Y ‚äó app Y) ‚â´ eComp V _ _ _ =\n        (app X ‚äó G.map X Y) ‚â´ eComp V _ _ _\n\n"}
{"name":"CategoryTheory.enrichedNatTransYoneda_map_app","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V D\ninst‚úù : CategoryTheory.BraidedCategory V\nF G : CategoryTheory.EnrichedFunctor V C D\nX‚úù Y‚úù : Opposite V\nf : Quiver.Hom X‚úù Y‚úù\nœÉ : CategoryTheory.GradedNatTrans ((CategoryTheory.Center.ofBraided V).obj (Opposite.unop X‚úù)) F G\nX : C\n‚ä¢ Eq (((CategoryTheory.enrichedNatTransYoneda F G).map f œÉ).app X) (CategoryTheory.CategoryStruct.comp f.unop (œÉ.app X))","decl":"/-- A presheaf isomorphic to the Yoneda embedding of\nthe `V`-object of natural transformations from `F` to `G`.\n-/\n@[simps]\ndef enrichedNatTransYoneda (F G : EnrichedFunctor V C D) : V·µí·µñ ‚•§ Type max u‚ÇÅ w where\n  obj A := GradedNatTrans ((Center.ofBraided V).obj (unop A)) F G\n  map f œÉ :=\n    { app := fun X => f.unop ‚â´ œÉ.app X\n      naturality := fun X Y => by\n        have p := œÉ.naturality X Y\n        dsimp at p ‚ä¢\n        rw [‚Üê id_tensor_comp_tensor_id (f.unop ‚â´ œÉ.app Y) _, id_tensor_comp, Category.assoc,\n          Category.assoc, ‚Üê braiding_naturality_assoc, id_tensor_comp_tensor_id_assoc, p, ‚Üê\n          tensor_comp_assoc, Category.id_comp] }\n\n-- TODO assuming `[HasLimits C]` construct the actual object of natural transformations\n-- and show that the functor category is `V`-enriched.\n"}
{"name":"CategoryTheory.enrichedNatTransYoneda_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"V : Type v\ninst‚úù‚Å¥ : CategoryTheory.Category.{w, v} V\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory V\nC : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.EnrichedCategory V C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.EnrichedCategory V D\ninst‚úù : CategoryTheory.BraidedCategory V\nF G : CategoryTheory.EnrichedFunctor V C D\nA : Opposite V\n‚ä¢ Eq ((CategoryTheory.enrichedNatTransYoneda F G).obj A) (CategoryTheory.GradedNatTrans ((CategoryTheory.Center.ofBraided V).obj (Opposite.unop A)) F G)","decl":"/-- A presheaf isomorphic to the Yoneda embedding of\nthe `V`-object of natural transformations from `F` to `G`.\n-/\n@[simps]\ndef enrichedNatTransYoneda (F G : EnrichedFunctor V C D) : V·µí·µñ ‚•§ Type max u‚ÇÅ w where\n  obj A := GradedNatTrans ((Center.ofBraided V).obj (unop A)) F G\n  map f œÉ :=\n    { app := fun X => f.unop ‚â´ œÉ.app X\n      naturality := fun X Y => by\n        have p := œÉ.naturality X Y\n        dsimp at p ‚ä¢\n        rw [‚Üê id_tensor_comp_tensor_id (f.unop ‚â´ œÉ.app Y) _, id_tensor_comp, Category.assoc,\n          Category.assoc, ‚Üê braiding_naturality_assoc, id_tensor_comp_tensor_id_assoc, p, ‚Üê\n          tensor_comp_assoc, Category.id_comp] }\n\n-- TODO assuming `[HasLimits C]` construct the actual object of natural transformations\n-- and show that the functor category is `V`-enriched.\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_symm_apply_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nùíû : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u‚ÇÇ\nùíü : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor.symm F).obj X) (F.obj X)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u‚ÇÅ} [ùíû : EnrichedCategory (Type v) C] {D : Type u‚ÇÇ}\n    [ùíü : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ‚âÉ C ‚•§ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ‚ü®f, g‚ü© }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ‚ü®‚ü©; exact F.map_id X\n      map_comp := fun X Y Z => by ext ‚ü®f, g‚ü©; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_symm_apply_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nùíû : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u‚ÇÇ\nùíü : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.Functor C D\nx‚úù¬π x‚úù : C\nf : CategoryTheory.EnrichedCategory.Hom x‚úù¬π x‚úù\n‚ä¢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor.symm F).map x‚úù¬π x‚úù f) (F.map f)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u‚ÇÅ} [ùíû : EnrichedCategory (Type v) C] {D : Type u‚ÇÇ}\n    [ùíü : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ‚âÉ C ‚•§ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ‚ü®f, g‚ü© }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ‚ü®‚ü©; exact F.map_id X\n      map_comp := fun X Y Z => by ext ‚ü®f, g‚ü©; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_apply_obj","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nùíû : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u‚ÇÇ\nùíü : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.EnrichedFunctor (Type v) C D\nX : C\n‚ä¢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor F).obj X) (F.obj X)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u‚ÇÅ} [ùíû : EnrichedCategory (Type v) C] {D : Type u‚ÇÇ}\n    [ùíü : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ‚âÉ C ‚•§ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ‚ü®f, g‚ü© }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ‚ü®‚ü©; exact F.map_id X\n      map_comp := fun X Y Z => by ext ‚ü®f, g‚ü©; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"CategoryTheory.enrichedFunctorTypeEquivFunctor_apply_map","module":"Mathlib.CategoryTheory.Enriched.Basic","initialProofState":"C : Type u‚ÇÅ\nùíû : CategoryTheory.EnrichedCategory (Type v) C\nD : Type u‚ÇÇ\nùíü : CategoryTheory.EnrichedCategory (Type v) D\nF : CategoryTheory.EnrichedFunctor (Type v) C D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.enrichedFunctorTypeEquivFunctor F).map f) (F.map X‚úù Y‚úù f)","decl":"/-- We verify that an enriched functor between `Type v` enriched categories\nis just the same thing as an honest functor.\n-/\n@[simps]\ndef enrichedFunctorTypeEquivFunctor {C : Type u‚ÇÅ} [ùíû : EnrichedCategory (Type v) C] {D : Type u‚ÇÇ}\n    [ùíü : EnrichedCategory (Type v) D] : EnrichedFunctor (Type v) C D ‚âÉ C ‚•§ D where\n  toFun F :=\n    { obj := fun X => F.obj X\n      map := fun f => F.map _ _ f\n      map_id := fun X => congr_fun (F.map_id X) PUnit.unit\n      map_comp := fun f g => congr_fun (F.map_comp _ _ _) ‚ü®f, g‚ü© }\n  invFun F :=\n    { obj := fun X => F.obj X\n      map := fun _ _ f => F.map f\n      map_id := fun X => by ext ‚ü®‚ü©; exact F.map_id X\n      map_comp := fun X Y Z => by ext ‚ü®f, g‚ü©; exact F.map_comp f g }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
