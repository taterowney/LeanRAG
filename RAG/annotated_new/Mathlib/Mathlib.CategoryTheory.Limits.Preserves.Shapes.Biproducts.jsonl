{"name":"CategoryTheory.Functor.mapBicone_pt","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w‚ÇÅ\nf : J ‚Üí C\nb : CategoryTheory.Limits.Bicone f\n‚ä¢ Eq (F.mapBicone b).pt (F.obj b.pt)","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J ‚Üí C} (b : Bicone f) : Bicone (F.obj ‚àò f) where\n  pt := F.obj b.pt\n  œÄ j := F.map (b.œÄ j)\n  Œπ j := F.map (b.Œπ j)\n  Œπ_œÄ j j' := by\n    rw [‚Üê F.map_comp]\n    split_ifs with h\n    ¬∑ subst h\n      simp only [bicone_Œπ_œÄ_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    ¬∑ rw [bicone_Œπ_œÄ_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_Œπ","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w‚ÇÅ\nf : J ‚Üí C\nb : CategoryTheory.Limits.Bicone f\nj : J\n‚ä¢ Eq ((F.mapBicone b).Œπ j) (F.map (b.Œπ j))","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J ‚Üí C} (b : Bicone f) : Bicone (F.obj ‚àò f) where\n  pt := F.obj b.pt\n  œÄ j := F.map (b.œÄ j)\n  Œπ j := F.map (b.Œπ j)\n  Œπ_œÄ j j' := by\n    rw [‚Üê F.map_comp]\n    split_ifs with h\n    ¬∑ subst h\n      simp only [bicone_Œπ_œÄ_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    ¬∑ rw [bicone_Œπ_œÄ_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_œÄ","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w‚ÇÅ\nf : J ‚Üí C\nb : CategoryTheory.Limits.Bicone f\nj : J\n‚ä¢ Eq ((F.mapBicone b).œÄ j) (F.map (b.œÄ j))","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J ‚Üí C} (b : Bicone f) : Bicone (F.obj ‚àò f) where\n  pt := F.obj b.pt\n  œÄ j := F.map (b.œÄ j)\n  Œπ j := F.map (b.Œπ j)\n  Œπ_œÄ j j' := by\n    rw [‚Üê F.map_comp]\n    split_ifs with h\n    ¬∑ subst h\n      simp only [bicone_Œπ_œÄ_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    ¬∑ rw [bicone_Œπ_œÄ_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_whisker","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nJ : Type w‚ÇÅ\nK : Type w‚ÇÇ\ng : Equiv K J\nf : J ‚Üí C\nc : CategoryTheory.Limits.Bicone f\n‚ä¢ Eq (F.mapBicone (c.whisker g)) ((F.mapBicone c).whisker g)","decl":"theorem mapBicone_whisker {K : Type w‚ÇÇ} {g : K ‚âÉ J} {f : J ‚Üí C} (c : Bicone f) :\n    F.mapBicone (c.whisker g) = (F.mapBicone c).whisker g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_inr","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n‚ä¢ Eq (F.mapBinaryBicone b).inr (F.map b.inr)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n‚ä¢ Eq (F.mapBinaryBicone b).snd (F.map b.snd)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_inl","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n‚ä¢ Eq (F.mapBinaryBicone b).inl (F.map b.inl)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_pt","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n‚ä¢ Eq (F.mapBinaryBicone b).pt (F.obj b.pt)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n‚ä¢ Eq (F.mapBinaryBicone b).fst (F.map b.fst)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproduct.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nf : J ‚Üí C\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproduct f F\nb : CategoryTheory.Limits.Bicone f\na‚úù : b.IsBilimit\n‚ä¢ Nonempty (F.mapBicone b).IsBilimit","decl":"/-- A functor `F` preserves biproducts of `f` if `F` maps every bilimit bicone over `f` to a\n    bilimit bicone over `F.obj ‚àò f`. -/\nclass PreservesBiproduct (f : J ‚Üí C) (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {b : Bicone f}, b.IsBilimit ‚Üí Nonempty (F.mapBicone b).IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproductsOfShape.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproductsOfShape J F\nf : J ‚Üí C\n‚ä¢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor `F` preserves biproducts of shape `J` if it preserves biproducts of `f` for every\n    `f : J ‚Üí C`. -/\nclass PreservesBiproductsOfShape (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {f : J ‚Üí C}, PreservesBiproduct f F\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesFiniteBiproducts F\nJ : Type\ninst‚úù : Fintype J\n‚ä¢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever\n    `J` is a fintype. -/\nclass PreservesFiniteBiproducts (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {J : Type} [Fintype J], PreservesBiproductsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproducts F\nJ : Type w‚ÇÅ\n‚ä¢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor `F` preserves biproducts if it preserves biproducts of any shape `J` of size `w`.\n    The usual notion of preservation of biproducts is recovered by choosing `w` to be the universe\n    of the morphisms of `C`. -/\nclass PreservesBiproducts (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {J : Type w‚ÇÅ}, PreservesBiproductsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproducts_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproducts F\n‚ä¢ CategoryTheory.Limits.PreservesBiproducts F","decl":"/-- Preserving biproducts at a bigger universe level implies preserving biproducts at a\nsmaller universe level. -/\nlemma preservesBiproducts_shrink (F : C ‚•§ D) [PreservesZeroMorphisms F]\n    [PreservesBiproducts.{max w‚ÇÅ w‚ÇÇ} F] : PreservesBiproducts.{w‚ÇÅ} F :=\n  ‚ü®fun {_} =>\n    ‚ü®fun {_} =>\n      ‚ü®fun {b} ib =>\n        ‚ü®((F.mapBicone b).whiskerIsBilimitIff _).toFun\n          (isBilimitOfPreserves F ((b.whiskerIsBilimitIff Equiv.ulift.{w‚ÇÇ}).invFun ib))‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteBiproductsOfPreservesBiproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproducts F\n‚ä¢ CategoryTheory.Limits.PreservesFiniteBiproducts F","decl":"instance (priority := 100) preservesFiniteBiproductsOfPreservesBiproducts (F : C ‚•§ D)\n    [PreservesZeroMorphisms F] [PreservesBiproducts.{w‚ÇÅ} F] : PreservesFiniteBiproducts F where\n  preserves {J} _ := by letI := preservesBiproducts_shrink.{0} F; infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesBinaryBiproduct.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nb : CategoryTheory.Limits.BinaryBicone X Y\na‚úù : b.IsBilimit\n‚ä¢ Nonempty (F.mapBinaryBicone b).IsBilimit","decl":"/-- A functor `F` preserves binary biproducts of `X` and `Y` if `F` maps every bilimit bicone over\n    `X` and `Y` to a bilimit bicone over `F.obj X` and `F.obj Y`. -/\nclass PreservesBinaryBiproduct (X Y : C) (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {b : BinaryBicone X Y}, b.IsBilimit ‚Üí Nonempty ((F.mapBinaryBicone b).IsBilimit)\n\n"}
{"name":"CategoryTheory.Limits.PreservesBinaryBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBinaryBiproducts F\nX Y : C\n‚ä¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor `F` preserves binary biproducts if it preserves the binary biproduct of `X` and `Y`\n    for all `X` and `Y`. -/\nclass PreservesBinaryBiproducts (F : C ‚•§ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ‚àÄ {X Y : C}, PreservesBinaryBiproduct X Y F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\nX Y : C\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct (CategoryTheory.Limits.pairFunction X Y) F\n‚ä¢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBiproduct (F : C ‚•§ D)\n    [PreservesZeroMorphisms F] (X Y : C) [PreservesBiproduct (pairFunction X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb := ‚ü®{\n      isLimit :=\n        IsLimit.ofIsoLimit\n            ((IsLimit.postcomposeHomEquiv (diagramIsoPair _) _).symm\n              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).isLimit) <|\n          Cones.ext (Iso.refl _) fun j => by\n            rcases j with ‚ü®‚ü®‚ü©‚ü© <;> simp\n      isColimit :=\n        IsColimit.ofIsoColimit\n            ((IsColimit.precomposeInvEquiv (diagramIsoPair _) _).symm\n              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).isColimit) <|\n          Cocones.ext (Iso.refl _) fun j => by\n            rcases j with ‚ü®‚ü®‚ü©‚ü© <;> simp }‚ü©\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBiproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproductsOfShape CategoryTheory.Limits.WalkingPair F\n‚ä¢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBiproducts (F : C ‚•§ D) [PreservesZeroMorphisms F]\n    [PreservesBiproductsOfShape WalkingPair F] : PreservesBinaryBiproducts F where\n  preserves {X} Y := preservesBinaryBiproduct_of_preservesBiproduct F X Y\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\nZ : D\nh : Quiver.Hom (Function.comp F.obj f j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (Function.comp F.obj f) j) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.œÄ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproductComparison_œÄ (j : J) :\n    biproductComparison F f ‚â´ biproduct.œÄ _ j = F.map (biproduct.œÄ f j) :=\n  biproduct.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison_œÄ","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) (CategoryTheory.Limits.biproduct.œÄ (Function.comp F.obj f) j)) (F.map (CategoryTheory.Limits.biproduct.œÄ f j))","decl":"@[reassoc (attr := simp)]\ntheorem biproductComparison_œÄ (j : J) :\n    biproductComparison F f ‚â´ biproduct.œÄ _ j = F.map (biproduct.œÄ f j) :=\n  biproduct.lift_œÄ _ _\n\n"}
{"name":"CategoryTheory.Functor.Œπ_biproductComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (Function.comp F.obj f) j) (F.biproductComparison' f)) (F.map (CategoryTheory.Limits.biproduct.Œπ f j))","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_biproductComparison' (j : J) :\n    biproduct.Œπ _ j ‚â´ biproductComparison' F f = F.map (biproduct.Œπ f j) :=\n  biproduct.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.Œπ_biproductComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biproduct f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (Function.comp F.obj f) j) (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.Œπ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_biproductComparison' (j : J) :\n    biproduct.Œπ _ j ‚â´ biproductComparison' F f = F.map (biproduct.Œπ f j) :=\n  biproduct.Œπ_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison'_comp_biproductComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBiproduct f\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst‚úù : F.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Function.comp F.obj f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) h)) h","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBiproduct_of_monoBiproductComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biproductComparison'_comp_biproductComparison :\n    biproductComparison' F f ‚â´ biproductComparison F f = ùüô (‚®Å F.obj ‚àò f) := by\n  classical\n    ext\n    simp [biproduct.Œπ_œÄ, ‚Üê Functor.map_comp, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison'_comp_biproductComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBiproduct f\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst‚úù : F.PreservesZeroMorphisms\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) (F.biproductComparison f)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct (Function.comp F.obj f)))","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBiproduct_of_monoBiproductComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biproductComparison'_comp_biproductComparison :\n    biproductComparison' F f ‚â´ biproductComparison F f = ùüô (‚®Å F.obj ‚àò f) := by\n  classical\n    ext\n    simp [biproduct.Œπ_œÄ, ‚Üê Functor.map_comp, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Functor.splitEpiBiproductComparison_section_","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n‚ä¢ Eq (F.splitEpiBiproductComparison f).section_ (F.biproductComparison' f)","decl":"/-- `biproduct_comparison F f` is a split epimorphism. -/\n@[simps]\ndef splitEpiBiproductComparison : SplitEpi (biproductComparison F f) where\n  section_ := biproductComparison' F f\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitEpiBiproductComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n‚ä¢ CategoryTheory.IsSplitEpi (F.biproductComparison f)","decl":"instance : IsSplitEpi (biproductComparison F f) :=\n  IsSplitEpi.mk' (splitEpiBiproductComparison F f)\n\n"}
{"name":"CategoryTheory.Functor.splitMonoBiproductComparison'_retraction","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n‚ä¢ Eq (F.splitMonoBiproductComparison' f).retraction (F.biproductComparison f)","decl":"/-- `biproduct_comparison' F f` is a split monomorphism. -/\n@[simps]\ndef splitMonoBiproductComparison' : SplitMono (biproductComparison' F f) where\n  retraction := biproductComparison F f\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitMonoBiproductComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n‚ä¢ CategoryTheory.IsSplitMono (F.biproductComparison' f)","decl":"instance : IsSplitMono (biproductComparison' F f) :=\n  IsSplitMono.mk' (splitMonoBiproductComparison' F f)\n\n"}
{"name":"CategoryTheory.Functor.hasBiproduct_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBiproduct f\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\n‚ä¢ CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)","decl":"instance hasBiproduct_of_preserves : HasBiproduct (F.obj ‚àò f) :=\n  HasBiproduct.mk\n    { bicone := F.mapBicone (biproduct.bicone f)\n      isBilimit := isBilimitOfPreserves _ (biproduct.isBilimit _) }\n\n"}
{"name":"CategoryTheory.Functor.mapBiproduct_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBiproduct f\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\n‚ä¢ Eq (F.mapBiproduct f).hom (CategoryTheory.Limits.biproduct.lift fun j => F.map (CategoryTheory.Limits.biproduct.œÄ f j))","decl":"theorem mapBiproduct_hom :\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (mapBiproduct F f).hom = biproduct.lift fun j => F.map (biproduct.œÄ f j) := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBiproduct_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w‚ÇÅ\nF : CategoryTheory.Functor C D\nf : J ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBiproduct f\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\n‚ä¢ Eq (F.mapBiproduct f).inv (CategoryTheory.Limits.biproduct.desc fun j => F.map (CategoryTheory.Limits.biproduct.Œπ f j))","decl":"theorem mapBiproduct_inv :\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (mapBiproduct F f).inv = biproduct.desc fun j => F.map (biproduct.Œπ f j) := rfl\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.fst) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_fst : biprodComparison F X Y ‚â´ biprod.fst = F.map biprod.fst :=\n  biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) CategoryTheory.Limits.biprod.fst) (F.map CategoryTheory.Limits.biprod.fst)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_fst : biprodComparison F X Y ‚â´ biprod.fst = F.map biprod.fst :=\n  biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) CategoryTheory.Limits.biprod.snd) (F.map CategoryTheory.Limits.biprod.snd)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_snd : biprodComparison F X Y ‚â´ biprod.snd = F.map biprod.snd :=\n  biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.snd) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_snd : biprodComparison F X Y ‚â´ biprod.snd = F.map biprod.snd :=\n  biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Functor.inl_biprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (F.biprodComparison' X Y)) (F.map CategoryTheory.Limits.biprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem inl_biprodComparison' : biprod.inl ‚â´ biprodComparison' F X Y = F.map biprod.inl :=\n  biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inl_biprodComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biprod X Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.inl) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_biprodComparison' : biprod.inl ‚â´ biprodComparison' F X Y = F.map biprod.inl :=\n  biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inr_biprodComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biprod X Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.inr) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_biprodComparison' : biprod.inr ‚â´ biprodComparison' F X Y = F.map biprod.inr :=\n  biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inr_biprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (F.biprodComparison' X Y)) (F.map CategoryTheory.Limits.biprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem inr_biprodComparison' : biprod.inr ‚â´ biprodComparison' F X Y = F.map biprod.inr :=\n  biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison'_comp_biprodComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst‚úù : F.PreservesZeroMorphisms\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) (F.biprodComparison X Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod (F.obj X) (F.obj Y)))","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBinaryBiproduct_of_monoBiprodComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biprodComparison'_comp_biprodComparison :\n    biprodComparison' F X Y ‚â´ biprodComparison F X Y = ùüô (F.obj X ‚äû F.obj Y) := by\n  ext <;> simp [‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison'_comp_biprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst‚úù : F.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biprod (F.obj X) (F.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) h)) h","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBinaryBiproduct_of_monoBiprodComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biprodComparison'_comp_biprodComparison :\n    biprodComparison' F X Y ‚â´ biprodComparison F X Y = ùüô (F.obj X ‚äû F.obj Y) := by\n  ext <;> simp [‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.splitEpiBiprodComparison_section_","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.splitEpiBiprodComparison X Y).section_ (F.biprodComparison' X Y)","decl":"/-- `biprodComparison F X Y` is a split epi. -/\n@[simps]\ndef splitEpiBiprodComparison : SplitEpi (biprodComparison F X Y) where\n  section_ := biprodComparison' F X Y\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitEpiBiprodComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ CategoryTheory.IsSplitEpi (F.biprodComparison X Y)","decl":"instance : IsSplitEpi (biprodComparison F X Y) :=\n  IsSplitEpi.mk' (splitEpiBiprodComparison F X Y)\n\n"}
{"name":"CategoryTheory.Functor.splitMonoBiprodComparison'_retraction","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ Eq (F.splitMonoBiprodComparison' X Y).retraction (F.biprodComparison X Y)","decl":"/-- `biprodComparison' F X Y` is a split mono. -/\n@[simps]\ndef splitMonoBiprodComparison' : SplitMono (biprodComparison' F X Y) where\n  retraction := biprodComparison F X Y\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitMonoBiprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n‚ä¢ CategoryTheory.IsSplitMono (F.biprodComparison' X Y)","decl":"instance : IsSplitMono (biprodComparison' F X Y) :=\n  IsSplitMono.mk' (splitMonoBiprodComparison' F X Y)\n\n"}
{"name":"CategoryTheory.Functor.hasBinaryBiproduct_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n‚ä¢ CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)","decl":"instance hasBinaryBiproduct_of_preserves : HasBinaryBiproduct (F.obj X) (F.obj Y) :=\n  HasBinaryBiproduct.mk\n    { bicone := F.mapBinaryBicone (BinaryBiproduct.bicone X Y)\n      isBilimit := isBinaryBilimitOfPreserves F (BinaryBiproduct.isBilimit _ _) }\n\n"}
{"name":"CategoryTheory.Functor.mapBiprod_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n‚ä¢ Eq (F.mapBiprod X Y).hom (CategoryTheory.Limits.biprod.lift (F.map CategoryTheory.Limits.biprod.fst) (F.map CategoryTheory.Limits.biprod.snd))","decl":"theorem mapBiprod_hom : (mapBiprod F X Y).hom = biprod.lift (F.map biprod.fst) (F.map biprod.snd) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBiprod_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n‚ä¢ Eq (F.mapBiprod X Y).inv (CategoryTheory.Limits.biprod.desc (F.map CategoryTheory.Limits.biprod.inl) (F.map CategoryTheory.Limits.biprod.inr))","decl":"theorem mapBiprod_inv : (mapBiprod F X Y).inv = biprod.desc (F.map biprod.inl) (F.map biprod.inr) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nJ : Type w‚ÇÅ\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) ‚Üí Quiver.Hom W (f j)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.lift g)) (F.mapBiproduct f).hom) (CategoryTheory.Limits.biproduct.lift fun j => F.map (g j))","decl":"theorem biproduct.map_lift_mapBiprod (g : ‚àÄ j, W ‚ü∂ f j) :\n    -- Porting note: twice we need haveI to tell Lean about hasBiproduct_of_preserves F f\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    F.map (biproduct.lift g) ‚â´ (F.mapBiproduct f).hom = biproduct.lift fun j => F.map (g j) := by\n  ext j\n  dsimp only [Function.comp_def]\n  haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n  simp only [mapBiproduct_hom, Category.assoc, biproduct.lift_œÄ, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapBiproduct_inv_map_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nJ : Type w‚ÇÅ\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) ‚Üí Quiver.Hom (f j) W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiproduct f).inv (F.map (CategoryTheory.Limits.biproduct.desc g))) (CategoryTheory.Limits.biproduct.desc fun j => F.map (g j))","decl":"theorem biproduct.mapBiproduct_inv_map_desc (g : ‚àÄ j, f j ‚ü∂ W) :\n    -- Porting note: twice we need haveI to tell Lean about hasBiproduct_of_preserves F f\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (F.mapBiproduct f).inv ‚â´ F.map (biproduct.desc g) = biproduct.desc fun j => F.map (g j) := by\n  ext j\n  dsimp only [Function.comp_def]\n  haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n  simp only [mapBiproduct_inv, ‚Üê Category.assoc, biproduct.Œπ_desc ,‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapBiproduct_hom_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nJ : Type w‚ÇÅ\nf : J ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct f\ninst‚úù : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) ‚Üí Quiver.Hom (f j) W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiproduct f).hom (CategoryTheory.Limits.biproduct.desc fun j => F.map (g j))) (F.map (CategoryTheory.Limits.biproduct.desc g))","decl":"theorem biproduct.mapBiproduct_hom_desc (g : ‚àÄ j, f j ‚ü∂ W) :\n    ((F.mapBiproduct f).hom ‚â´ biproduct.desc fun j => F.map (g j)) = F.map (biproduct.desc g) := by\n  rw [‚Üê biproduct.mapBiproduct_inv_map_desc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biprod.lift f g)) (F.mapBiprod X Y).hom) (CategoryTheory.Limits.biprod.lift (F.map f) (F.map g))","decl":"theorem biprod.map_lift_mapBiprod (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    F.map (biprod.lift f g) ‚â´ (F.mapBiprod X Y).hom = biprod.lift (F.map f) (F.map g) := by\n  ext <;> simp [mapBiprod, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (F.map f) (F.map g)) (F.mapBiprod X Y).inv) (F.map (CategoryTheory.Limits.biprod.lift f g))","decl":"theorem biprod.lift_mapBiprod (f : W ‚ü∂ X) (g : W ‚ü∂ Y) :\n    biprod.lift (F.map f) (F.map g) ‚â´ (F.mapBiprod X Y).inv = F.map (biprod.lift f g) := by\n  rw [‚Üê biprod.map_lift_mapBiprod, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapBiprod_inv_map_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiprod X Y).inv (F.map (CategoryTheory.Limits.biprod.desc f g))) (CategoryTheory.Limits.biprod.desc (F.map f) (F.map g))","decl":"theorem biprod.mapBiprod_inv_map_desc (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    (F.mapBiprod X Y).inv ‚â´ F.map (biprod.desc f g) = biprod.desc (F.map f) (F.map g) := by\n  ext <;> simp [mapBiprod, ‚Üê F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapBiprod_hom_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.PreservesZeroMorphisms\nX Y : C\ninst‚úù¬π : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiprod X Y).hom (CategoryTheory.Limits.biprod.desc (F.map f) (F.map g))) (F.map (CategoryTheory.Limits.biprod.desc f g))","decl":"theorem biprod.mapBiprod_hom_desc (f : X ‚ü∂ W) (g : Y ‚ü∂ W) :\n    (F.mapBiprod X Y).hom ‚â´ biprod.desc (F.map f) (F.map g) = F.map (biprod.desc f g) := by\n  rw [‚Üê biprod.mapBiprod_inv_map_desc, Iso.hom_inv_id_assoc]\n\n"}
