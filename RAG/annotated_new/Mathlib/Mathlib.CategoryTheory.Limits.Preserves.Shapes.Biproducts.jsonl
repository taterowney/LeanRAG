{"name":"CategoryTheory.Functor.mapBicone_pt","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w₁\nf : J → C\nb : CategoryTheory.Limits.Bicone f\n⊢ Eq (F.mapBicone b).pt (F.obj b.pt)","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J → C} (b : Bicone f) : Bicone (F.obj ∘ f) where\n  pt := F.obj b.pt\n  π j := F.map (b.π j)\n  ι j := F.map (b.ι j)\n  ι_π j j' := by\n    rw [← F.map_comp]\n    split_ifs with h\n    · subst h\n      simp only [bicone_ι_π_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    · rw [bicone_ι_π_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w₁\nf : J → C\nb : CategoryTheory.Limits.Bicone f\nj : J\n⊢ Eq ((F.mapBicone b).ι j) (F.map (b.ι j))","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J → C} (b : Bicone f) : Bicone (F.obj ∘ f) where\n  pt := F.obj b.pt\n  π j := F.map (b.π j)\n  ι j := F.map (b.ι j)\n  ι_π j j' := by\n    rw [← F.map_comp]\n    split_ifs with h\n    · subst h\n      simp only [bicone_ι_π_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    · rw [bicone_ι_π_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nJ : Type w₁\nf : J → C\nb : CategoryTheory.Limits.Bicone f\nj : J\n⊢ Eq ((F.mapBicone b).π j) (F.map (b.π j))","decl":"/-- The image of a bicone under a functor. -/\n@[simps]\ndef mapBicone {f : J → C} (b : Bicone f) : Bicone (F.obj ∘ f) where\n  pt := F.obj b.pt\n  π j := F.map (b.π j)\n  ι j := F.map (b.ι j)\n  ι_π j j' := by\n    rw [← F.map_comp]\n    split_ifs with h\n    · subst h\n      simp only [bicone_ι_π_self, CategoryTheory.Functor.map_id, eqToHom_refl]; dsimp\n    · rw [bicone_ι_π_ne _ h, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapBicone_whisker","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nJ : Type w₁\nK : Type w₂\ng : Equiv K J\nf : J → C\nc : CategoryTheory.Limits.Bicone f\n⊢ Eq (F.mapBicone (c.whisker g)) ((F.mapBicone c).whisker g)","decl":"theorem mapBicone_whisker {K : Type w₂} {g : K ≃ J} {f : J → C} (c : Bicone f) :\n    F.mapBicone (c.whisker g) = (F.mapBicone c).whisker g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_inr","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (F.mapBinaryBicone b).inr (F.map b.inr)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (F.mapBinaryBicone b).snd (F.map b.snd)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_inl","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (F.mapBinaryBicone b).inl (F.map b.inl)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_pt","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (F.mapBinaryBicone b).pt (F.obj b.pt)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Functor.mapBinaryBicone_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\nb : CategoryTheory.Limits.BinaryBicone X Y\n⊢ Eq (F.mapBinaryBicone b).fst (F.map b.fst)","decl":"/-- The image of a binary bicone under a functor. -/\n@[simps!]\ndef mapBinaryBicone {X Y : C} (b : BinaryBicone X Y) : BinaryBicone (F.obj X) (F.obj Y) :=\n  (BinaryBicones.functoriality _ _ F).obj b\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproduct.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nf : J → C\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproduct f F\nb : CategoryTheory.Limits.Bicone f\na✝ : b.IsBilimit\n⊢ Nonempty (F.mapBicone b).IsBilimit","decl":"/-- A functor `F` preserves biproducts of `f` if `F` maps every bilimit bicone over `f` to a\n    bilimit bicone over `F.obj ∘ f`. -/\nclass PreservesBiproduct (f : J → C) (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {b : Bicone f}, b.IsBilimit → Nonempty (F.mapBicone b).IsBilimit\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproductsOfShape.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproductsOfShape J F\nf : J → C\n⊢ CategoryTheory.Limits.PreservesBiproduct f F","decl":"/-- A functor `F` preserves biproducts of shape `J` if it preserves biproducts of `f` for every\n    `f : J → C`. -/\nclass PreservesBiproductsOfShape (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {f : J → C}, PreservesBiproduct f F\n\n"}
{"name":"CategoryTheory.Limits.PreservesFiniteBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesFiniteBiproducts F\nJ : Type\ninst✝ : Fintype J\n⊢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor `F` preserves finite biproducts if it preserves biproducts of shape `J` whenever\n    `J` is a fintype. -/\nclass PreservesFiniteBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {J : Type} [Fintype J], PreservesBiproductsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.PreservesBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBiproducts F\nJ : Type w₁\n⊢ CategoryTheory.Limits.PreservesBiproductsOfShape J F","decl":"/-- A functor `F` preserves biproducts if it preserves biproducts of any shape `J` of size `w`.\n    The usual notion of preservation of biproducts is recovered by choosing `w` to be the universe\n    of the morphisms of `C`. -/\nclass PreservesBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {J : Type w₁}, PreservesBiproductsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.preservesBiproducts_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproducts F\n⊢ CategoryTheory.Limits.PreservesBiproducts F","decl":"/-- Preserving biproducts at a bigger universe level implies preserving biproducts at a\nsmaller universe level. -/\nlemma preservesBiproducts_shrink (F : C ⥤ D) [PreservesZeroMorphisms F]\n    [PreservesBiproducts.{max w₁ w₂} F] : PreservesBiproducts.{w₁} F :=\n  ⟨fun {_} =>\n    ⟨fun {_} =>\n      ⟨fun {b} ib =>\n        ⟨((F.mapBicone b).whiskerIsBilimitIff _).toFun\n          (isBilimitOfPreserves F ((b.whiskerIsBilimitIff Equiv.ulift.{w₂}).invFun ib))⟩⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesFiniteBiproductsOfPreservesBiproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproducts F\n⊢ CategoryTheory.Limits.PreservesFiniteBiproducts F","decl":"instance (priority := 100) preservesFiniteBiproductsOfPreservesBiproducts (F : C ⥤ D)\n    [PreservesZeroMorphisms F] [PreservesBiproducts.{w₁} F] : PreservesFiniteBiproducts F where\n  preserves {J} _ := by letI := preservesBiproducts_shrink.{0} F; infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesBinaryBiproduct.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nb : CategoryTheory.Limits.BinaryBicone X Y\na✝ : b.IsBilimit\n⊢ Nonempty (F.mapBinaryBicone b).IsBilimit","decl":"/-- A functor `F` preserves binary biproducts of `X` and `Y` if `F` maps every bilimit bicone over\n    `X` and `Y` to a bilimit bicone over `F.obj X` and `F.obj Y`. -/\nclass PreservesBinaryBiproduct (X Y : C) (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {b : BinaryBicone X Y}, b.IsBilimit → Nonempty ((F.mapBinaryBicone b).IsBilimit)\n\n"}
{"name":"CategoryTheory.Limits.PreservesBinaryBiproducts.preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nself : CategoryTheory.Limits.PreservesBinaryBiproducts F\nX Y : C\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor `F` preserves binary biproducts if it preserves the binary biproduct of `X` and `Y`\n    for all `X` and `Y`. -/\nclass PreservesBinaryBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F] : Prop where\n  preserves : ∀ {X Y : C}, PreservesBinaryBiproduct X Y F := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproduct_of_preservesBiproduct","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\nX Y : C\ninst✝ : CategoryTheory.Limits.PreservesBiproduct (CategoryTheory.Limits.pairFunction X Y) F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproduct X Y F","decl":"/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/\nlemma preservesBinaryBiproduct_of_preservesBiproduct (F : C ⥤ D)\n    [PreservesZeroMorphisms F] (X Y : C) [PreservesBiproduct (pairFunction X Y) F] :\n    PreservesBinaryBiproduct X Y F where\n  preserves {b} hb := ⟨{\n      isLimit :=\n        IsLimit.ofIsoLimit\n            ((IsLimit.postcomposeHomEquiv (diagramIsoPair _) _).symm\n              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).isLimit) <|\n          Cones.ext (Iso.refl _) fun j => by\n            rcases j with ⟨⟨⟩⟩ <;> simp\n      isColimit :=\n        IsColimit.ofIsoColimit\n            ((IsColimit.precomposeInvEquiv (diagramIsoPair _) _).symm\n              (isBilimitOfPreserves F (b.toBiconeIsBilimit.symm hb)).isColimit) <|\n          Cocones.ext (Iso.refl _) fun j => by\n            rcases j with ⟨⟨⟩⟩ <;> simp }⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesBinaryBiproducts_of_preservesBiproducts","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproductsOfShape CategoryTheory.Limits.WalkingPair F\n⊢ CategoryTheory.Limits.PreservesBinaryBiproducts F","decl":"/-- A functor that preserves biproducts of a pair preserves binary biproducts. -/\nlemma preservesBinaryBiproducts_of_preservesBiproducts (F : C ⥤ D) [PreservesZeroMorphisms F]\n    [PreservesBiproductsOfShape WalkingPair F] : PreservesBinaryBiproducts F where\n  preserves {X} Y := preservesBinaryBiproduct_of_preservesBiproduct F X Y\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison_π_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\nZ : D\nh : Quiver.Hom (Function.comp F.obj f j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.π (Function.comp F.obj f) j) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.π f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproductComparison_π (j : J) :\n    biproductComparison F f ≫ biproduct.π _ j = F.map (biproduct.π f j) :=\n  biproduct.lift_π _ _\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) (CategoryTheory.Limits.biproduct.π (Function.comp F.obj f) j)) (F.map (CategoryTheory.Limits.biproduct.π f j))","decl":"@[reassoc (attr := simp)]\ntheorem biproductComparison_π (j : J) :\n    biproductComparison F f ≫ biproduct.π _ j = F.map (biproduct.π f j) :=\n  biproduct.lift_π _ _\n\n"}
{"name":"CategoryTheory.Functor.ι_biproductComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (Function.comp F.obj f) j) (F.biproductComparison' f)) (F.map (CategoryTheory.Limits.biproduct.ι f j))","decl":"@[reassoc (attr := simp)]\ntheorem ι_biproductComparison' (j : J) :\n    biproduct.ι _ j ≫ biproductComparison' F f = F.map (biproduct.ι f j) :=\n  biproduct.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.ι_biproductComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\nj : J\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biproduct f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.ι (Function.comp F.obj f) j) (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) h)) (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.ι f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_biproductComparison' (j : J) :\n    biproduct.ι _ j ≫ biproductComparison' F f = F.map (biproduct.ι f j) :=\n  biproduct.ι_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison'_comp_biproductComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst✝ : F.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biproduct (Function.comp F.obj f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) (CategoryTheory.CategoryStruct.comp (F.biproductComparison f) h)) h","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBiproduct_of_monoBiproductComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biproductComparison'_comp_biproductComparison :\n    biproductComparison' F f ≫ biproductComparison F f = 𝟙 (⨁ F.obj ∘ f) := by\n  classical\n    ext\n    simp [biproduct.ι_π, ← Functor.map_comp, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Functor.biproductComparison'_comp_biproductComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\ninst✝ : F.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biproductComparison' f) (F.biproductComparison f)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biproduct (Function.comp F.obj f)))","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBiproduct_of_monoBiproductComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biproductComparison'_comp_biproductComparison :\n    biproductComparison' F f ≫ biproductComparison F f = 𝟙 (⨁ F.obj ∘ f) := by\n  classical\n    ext\n    simp [biproduct.ι_π, ← Functor.map_comp, eqToHom_map]\n\n"}
{"name":"CategoryTheory.Functor.splitEpiBiproductComparison_section_","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n⊢ Eq (F.splitEpiBiproductComparison f).section_ (F.biproductComparison' f)","decl":"/-- `biproduct_comparison F f` is a split epimorphism. -/\n@[simps]\ndef splitEpiBiproductComparison : SplitEpi (biproductComparison F f) where\n  section_ := biproductComparison' F f\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitEpiBiproductComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n⊢ CategoryTheory.IsSplitEpi (F.biproductComparison f)","decl":"instance : IsSplitEpi (biproductComparison F f) :=\n  IsSplitEpi.mk' (splitEpiBiproductComparison F f)\n\n"}
{"name":"CategoryTheory.Functor.splitMonoBiproductComparison'_retraction","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n⊢ Eq (F.splitMonoBiproductComparison' f).retraction (F.biproductComparison f)","decl":"/-- `biproduct_comparison' F f` is a split monomorphism. -/\n@[simps]\ndef splitMonoBiproductComparison' : SplitMono (biproductComparison' F f) where\n  retraction := biproductComparison F f\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitMonoBiproductComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)\n⊢ CategoryTheory.IsSplitMono (F.biproductComparison' f)","decl":"instance : IsSplitMono (biproductComparison' F f) :=\n  IsSplitMono.mk' (splitMonoBiproductComparison' F f)\n\n"}
{"name":"CategoryTheory.Functor.hasBiproduct_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\n⊢ CategoryTheory.Limits.HasBiproduct (Function.comp F.obj f)","decl":"instance hasBiproduct_of_preserves : HasBiproduct (F.obj ∘ f) :=\n  HasBiproduct.mk\n    { bicone := F.mapBicone (biproduct.bicone f)\n      isBilimit := isBilimitOfPreserves _ (biproduct.isBilimit _) }\n\n"}
{"name":"CategoryTheory.Functor.mapBiproduct_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\n⊢ Eq (F.mapBiproduct f).hom (CategoryTheory.Limits.biproduct.lift fun j => F.map (CategoryTheory.Limits.biproduct.π f j))","decl":"theorem mapBiproduct_hom :\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (mapBiproduct F f).hom = biproduct.lift fun j => F.map (biproduct.π f j) := rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBiproduct_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nJ : Type w₁\nF : CategoryTheory.Functor C D\nf : J → C\ninst✝² : CategoryTheory.Limits.HasBiproduct f\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\n⊢ Eq (F.mapBiproduct f).inv (CategoryTheory.Limits.biproduct.desc fun j => F.map (CategoryTheory.Limits.biproduct.ι f j))","decl":"theorem mapBiproduct_inv :\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (mapBiproduct F f).inv = biproduct.desc fun j => F.map (biproduct.ι f j) := rfl\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.fst h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.fst) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_fst : biprodComparison F X Y ≫ biprod.fst = F.map biprod.fst :=\n  biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) CategoryTheory.Limits.biprod.fst) (F.map CategoryTheory.Limits.biprod.fst)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_fst : biprodComparison F X Y ≫ biprod.fst = F.map biprod.fst :=\n  biprod.lift_fst _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) CategoryTheory.Limits.biprod.snd) (F.map CategoryTheory.Limits.biprod.snd)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_snd : biprodComparison F X Y ≫ biprod.snd = F.map biprod.snd :=\n  biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.snd h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.snd) h)","decl":"@[reassoc (attr := simp)]\ntheorem biprodComparison_snd : biprodComparison F X Y ≫ biprod.snd = F.map biprod.snd :=\n  biprod.lift_snd _ _\n\n"}
{"name":"CategoryTheory.Functor.inl_biprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (F.biprodComparison' X Y)) (F.map CategoryTheory.Limits.biprod.inl)","decl":"@[reassoc (attr := simp)]\ntheorem inl_biprodComparison' : biprod.inl ≫ biprodComparison' F X Y = F.map biprod.inl :=\n  biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inl_biprodComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biprod X Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inl (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.inl) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_biprodComparison' : biprod.inl ≫ biprodComparison' F X Y = F.map biprod.inl :=\n  biprod.inl_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inr_biprodComparison'_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\nZ : D\nh : Quiver.Hom (F.obj (CategoryTheory.Limits.biprod X Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) h)) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.biprod.inr) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_biprodComparison' : biprod.inr ≫ biprodComparison' F X Y = F.map biprod.inr :=\n  biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.inr_biprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.biprod.inr (F.biprodComparison' X Y)) (F.map CategoryTheory.Limits.biprod.inr)","decl":"@[reassoc (attr := simp)]\ntheorem inr_biprodComparison' : biprod.inr ≫ biprodComparison' F X Y = F.map biprod.inr :=\n  biprod.inr_desc _ _\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison'_comp_biprodComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst✝ : F.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) (F.biprodComparison X Y)) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.biprod (F.obj X) (F.obj Y)))","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBinaryBiproduct_of_monoBiprodComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biprodComparison'_comp_biprodComparison :\n    biprodComparison' F X Y ≫ biprodComparison F X Y = 𝟙 (F.obj X ⊞ F.obj Y) := by\n  ext <;> simp [← Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.biprodComparison'_comp_biprodComparison_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\ninst✝ : F.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.biprod (F.obj X) (F.obj Y)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.biprodComparison' X Y) (CategoryTheory.CategoryStruct.comp (F.biprodComparison X Y) h)) h","decl":"/-- The composition in the opposite direction is equal to the identity if and only if `F` preserves\n    the biproduct, see `preservesBinaryBiproduct_of_monoBiprodComparison`. -/\n@[reassoc (attr := simp)]\ntheorem biprodComparison'_comp_biprodComparison :\n    biprodComparison' F X Y ≫ biprodComparison F X Y = 𝟙 (F.obj X ⊞ F.obj Y) := by\n  ext <;> simp [← Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.splitEpiBiprodComparison_section_","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (F.splitEpiBiprodComparison X Y).section_ (F.biprodComparison' X Y)","decl":"/-- `biprodComparison F X Y` is a split epi. -/\n@[simps]\ndef splitEpiBiprodComparison : SplitEpi (biprodComparison F X Y) where\n  section_ := biprodComparison' F X Y\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitEpiBiprodComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ CategoryTheory.IsSplitEpi (F.biprodComparison X Y)","decl":"instance : IsSplitEpi (biprodComparison F X Y) :=\n  IsSplitEpi.mk' (splitEpiBiprodComparison F X Y)\n\n"}
{"name":"CategoryTheory.Functor.splitMonoBiprodComparison'_retraction","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ Eq (F.splitMonoBiprodComparison' X Y).retraction (F.biprodComparison X Y)","decl":"/-- `biprodComparison' F X Y` is a split mono. -/\n@[simps]\ndef splitMonoBiprodComparison' : SplitMono (biprodComparison' F X Y) where\n  retraction := biprodComparison F X Y\n  id := by simp\n\n"}
{"name":"CategoryTheory.Functor.instIsSplitMonoBiprodComparison'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)\n⊢ CategoryTheory.IsSplitMono (F.biprodComparison' X Y)","decl":"instance : IsSplitMono (biprodComparison' F X Y) :=\n  IsSplitMono.mk' (splitMonoBiprodComparison' F X Y)\n\n"}
{"name":"CategoryTheory.Functor.hasBinaryBiproduct_of_preserves","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n⊢ CategoryTheory.Limits.HasBinaryBiproduct (F.obj X) (F.obj Y)","decl":"instance hasBinaryBiproduct_of_preserves : HasBinaryBiproduct (F.obj X) (F.obj Y) :=\n  HasBinaryBiproduct.mk\n    { bicone := F.mapBinaryBicone (BinaryBiproduct.bicone X Y)\n      isBilimit := isBinaryBilimitOfPreserves F (BinaryBiproduct.isBilimit _ _) }\n\n"}
{"name":"CategoryTheory.Functor.mapBiprod_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n⊢ Eq (F.mapBiprod X Y).hom (CategoryTheory.Limits.biprod.lift (F.map CategoryTheory.Limits.biprod.fst) (F.map CategoryTheory.Limits.biprod.snd))","decl":"theorem mapBiprod_hom : (mapBiprod F X Y).hom = biprod.lift (F.map biprod.fst) (F.map biprod.snd) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapBiprod_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nX Y : C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\n⊢ Eq (F.mapBiprod X Y).inv (CategoryTheory.Limits.biprod.desc (F.map CategoryTheory.Limits.biprod.inl) (F.map CategoryTheory.Limits.biprod.inr))","decl":"theorem mapBiprod_inv : (mapBiprod F X Y).inv = biprod.desc (F.map biprod.inl) (F.map biprod.inr) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.biproduct.map_lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type w₁\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) → Quiver.Hom W (f j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biproduct.lift g)) (F.mapBiproduct f).hom) (CategoryTheory.Limits.biproduct.lift fun j => F.map (g j))","decl":"theorem biproduct.map_lift_mapBiprod (g : ∀ j, W ⟶ f j) :\n    -- Porting note: twice we need haveI to tell Lean about hasBiproduct_of_preserves F f\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    F.map (biproduct.lift g) ≫ (F.mapBiproduct f).hom = biproduct.lift fun j => F.map (g j) := by\n  ext j\n  dsimp only [Function.comp_def]\n  haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n  simp only [mapBiproduct_hom, Category.assoc, biproduct.lift_π, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapBiproduct_inv_map_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type w₁\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) → Quiver.Hom (f j) W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiproduct f).inv (F.map (CategoryTheory.Limits.biproduct.desc g))) (CategoryTheory.Limits.biproduct.desc fun j => F.map (g j))","decl":"theorem biproduct.mapBiproduct_inv_map_desc (g : ∀ j, f j ⟶ W) :\n    -- Porting note: twice we need haveI to tell Lean about hasBiproduct_of_preserves F f\n    haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n    (F.mapBiproduct f).inv ≫ F.map (biproduct.desc g) = biproduct.desc fun j => F.map (g j) := by\n  ext j\n  dsimp only [Function.comp_def]\n  haveI : HasBiproduct fun j => F.obj (f j) := hasBiproduct_of_preserves F f\n  simp only [mapBiproduct_inv, ← Category.assoc, biproduct.ι_desc ,← F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biproduct.mapBiproduct_hom_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nJ : Type w₁\nf : J → C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct f\ninst✝ : CategoryTheory.Limits.PreservesBiproduct f F\nW : C\ng : (j : J) → Quiver.Hom (f j) W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiproduct f).hom (CategoryTheory.Limits.biproduct.desc fun j => F.map (g j))) (F.map (CategoryTheory.Limits.biproduct.desc g))","decl":"theorem biproduct.mapBiproduct_hom_desc (g : ∀ j, f j ⟶ W) :\n    ((F.mapBiproduct f).hom ≫ biproduct.desc fun j => F.map (g j)) = F.map (biproduct.desc g) := by\n  rw [← biproduct.mapBiproduct_inv_map_desc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.Limits.biprod.map_lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.Limits.biprod.lift f g)) (F.mapBiprod X Y).hom) (CategoryTheory.Limits.biprod.lift (F.map f) (F.map g))","decl":"theorem biprod.map_lift_mapBiprod (f : W ⟶ X) (g : W ⟶ Y) :\n    F.map (biprod.lift f g) ≫ (F.mapBiprod X Y).hom = biprod.lift (F.map f) (F.map g) := by\n  ext <;> simp [mapBiprod, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.lift_mapBiprod","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biprod.lift (F.map f) (F.map g)) (F.mapBiprod X Y).inv) (F.map (CategoryTheory.Limits.biprod.lift f g))","decl":"theorem biprod.lift_mapBiprod (f : W ⟶ X) (g : W ⟶ Y) :\n    biprod.lift (F.map f) (F.map g) ≫ (F.mapBiprod X Y).inv = F.map (biprod.lift f g) := by\n  rw [← biprod.map_lift_mapBiprod, Category.assoc, Iso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapBiprod_inv_map_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiprod X Y).inv (F.map (CategoryTheory.Limits.biprod.desc f g))) (CategoryTheory.Limits.biprod.desc (F.map f) (F.map g))","decl":"theorem biprod.mapBiprod_inv_map_desc (f : X ⟶ W) (g : Y ⟶ W) :\n    (F.mapBiprod X Y).inv ≫ F.map (biprod.desc f g) = biprod.desc (F.map f) (F.map g) := by\n  ext <;> simp [mapBiprod, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Limits.biprod.mapBiprod_hom_desc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Biproducts","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\nX Y : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproduct X Y\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproduct X Y F\nW : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.mapBiprod X Y).hom (CategoryTheory.Limits.biprod.desc (F.map f) (F.map g))) (F.map (CategoryTheory.Limits.biprod.desc f g))","decl":"theorem biprod.mapBiprod_hom_desc (f : X ⟶ W) (g : Y ⟶ W) :\n    (F.mapBiprod X Y).hom ≫ biprod.desc (F.map f) (F.map g) = F.map (biprod.desc f g) := by\n  rw [← biprod.mapBiprod_inv_map_desc, Iso.hom_inv_id_assoc]\n\n"}
