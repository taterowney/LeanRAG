{"name":"MeasureTheory.withDensity_apply","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.withDensity f) s) (MeasureTheory.lintegral (μ.restrict s) fun a => f a)","decl":"@[simp]\ntheorem withDensity_apply (f : α → ℝ≥0∞) {s : Set α} (hs : MeasurableSet s) :\n    μ.withDensity f s = ∫⁻ a in s, f a ∂μ :=\n  Measure.ofMeasurable_apply s hs\n\n"}
{"name":"MeasureTheory.withDensity_apply_le","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\n⊢ LE.le (MeasureTheory.lintegral (μ.restrict s) fun a => f a) ((μ.withDensity f) s)","decl":"theorem withDensity_apply_le (f : α → ℝ≥0∞) (s : Set α) :\n    ∫⁻ a in s, f a ∂μ ≤ μ.withDensity f s := by\n  let t := toMeasurable (μ.withDensity f) s\n  calc\n  ∫⁻ a in s, f a ∂μ ≤ ∫⁻ a in t, f a ∂μ :=\n    lintegral_mono_set (subset_toMeasurable (withDensity μ f) s)\n  _ = μ.withDensity f t :=\n    (withDensity_apply f (measurableSet_toMeasurable (withDensity μ f) s)).symm\n  _ = μ.withDensity f s := measure_toMeasurable s\n\n\n"}
{"name":"MeasureTheory.withDensity_apply'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → ENNReal\ns : Set α\n⊢ Eq ((μ.withDensity f) s) (MeasureTheory.lintegral (μ.restrict s) fun a => f a)","decl":"theorem withDensity_apply' [SFinite μ] (f : α → ℝ≥0∞) (s : Set α) :\n    μ.withDensity f s = ∫⁻ a in s, f a ∂μ := by\n  apply le_antisymm ?_ (withDensity_apply_le f s)\n  let t := toMeasurable μ s\n  calc\n  μ.withDensity f s ≤ μ.withDensity f t := measure_mono (subset_toMeasurable μ s)\n  _ = ∫⁻ a in t, f a ∂μ := withDensity_apply f (measurableSet_toMeasurable μ s)\n  _ = ∫⁻ a in s, f a ∂μ := by congr 1; exact restrict_toMeasurable_of_sFinite s\n\n"}
{"name":"MeasureTheory.withDensity_zero_left","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nf : α → ENNReal\n⊢ Eq (MeasureTheory.Measure.withDensity 0 f) 0","decl":"@[simp]\nlemma withDensity_zero_left (f : α → ℝ≥0∞) : (0 : Measure α).withDensity f = 0 := by\n  ext s hs\n  rw [withDensity_apply _ hs]\n  simp\n\n"}
{"name":"MeasureTheory.withDensity_congr_ae","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (μ.withDensity f) (μ.withDensity g)","decl":"theorem withDensity_congr_ae {f g : α → ℝ≥0∞} (h : f =ᵐ[μ] g) :\n    μ.withDensity f = μ.withDensity g := by\n  refine Measure.ext fun s hs => ?_\n  rw [withDensity_apply _ hs, withDensity_apply _ hs]\n  exact lintegral_congr_ae (ae_restrict_of_ae h)\n\n"}
{"name":"MeasureTheory.withDensity_mono","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhfg : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ LE.le (μ.withDensity f) (μ.withDensity g)","decl":"lemma withDensity_mono {f g : α → ℝ≥0∞} (hfg : f ≤ᵐ[μ] g) :\n    μ.withDensity f ≤ μ.withDensity g := by\n  refine le_iff.2 fun s hs ↦ ?_\n  rw [withDensity_apply _ hs, withDensity_apply _ hs]\n  refine setLIntegral_mono_ae' hs ?_\n  filter_upwards [hfg] with x h_le using fun _ ↦ h_le\n\n"}
{"name":"MeasureTheory.withDensity_add_left","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\ng : α → ENNReal\n⊢ Eq (μ.withDensity (HAdd.hAdd f g)) (HAdd.hAdd (μ.withDensity f) (μ.withDensity g))","decl":"theorem withDensity_add_left {f : α → ℝ≥0∞} (hf : Measurable f) (g : α → ℝ≥0∞) :\n    μ.withDensity (f + g) = μ.withDensity f + μ.withDensity g := by\n  refine Measure.ext fun s hs => ?_\n  rw [withDensity_apply _ hs, Measure.add_apply, withDensity_apply _ hs, withDensity_apply _ hs,\n    ← lintegral_add_left hf]\n  simp only [Pi.add_apply]\n\n"}
{"name":"MeasureTheory.withDensity_add_right","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhg : Measurable g\n⊢ Eq (μ.withDensity (HAdd.hAdd f g)) (HAdd.hAdd (μ.withDensity f) (μ.withDensity g))","decl":"theorem withDensity_add_right (f : α → ℝ≥0∞) {g : α → ℝ≥0∞} (hg : Measurable g) :\n    μ.withDensity (f + g) = μ.withDensity f + μ.withDensity g := by\n  simpa only [add_comm] using withDensity_add_left hg f\n\n"}
{"name":"MeasureTheory.withDensity_add_measure","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq ((HAdd.hAdd μ ν).withDensity f) (HAdd.hAdd (μ.withDensity f) (ν.withDensity f))","decl":"theorem withDensity_add_measure {m : MeasurableSpace α} (μ ν : Measure α) (f : α → ℝ≥0∞) :\n    (μ + ν).withDensity f = μ.withDensity f + ν.withDensity f := by\n  ext1 s hs\n  simp only [withDensity_apply f hs, restrict_add, lintegral_add_measure, Measure.add_apply]\n\n"}
{"name":"MeasureTheory.withDensity_sum","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nι : Type u_2\nm : MeasurableSpace α\nμ : ι → MeasureTheory.Measure α\nf : α → ENNReal\n⊢ Eq ((MeasureTheory.Measure.sum μ).withDensity f) (MeasureTheory.Measure.sum fun n => (μ n).withDensity f)","decl":"theorem withDensity_sum {ι : Type*} {m : MeasurableSpace α} (μ : ι → Measure α) (f : α → ℝ≥0∞) :\n    (sum μ).withDensity f = sum fun n => (μ n).withDensity f := by\n  ext1 s hs\n  simp_rw [sum_apply _ hs, withDensity_apply f hs, restrict_sum μ hs, lintegral_sum_measure]\n\n"}
{"name":"MeasureTheory.withDensity_smul","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (μ.withDensity (HSMul.hSMul r f)) (HSMul.hSMul r (μ.withDensity f))","decl":"theorem withDensity_smul (r : ℝ≥0∞) {f : α → ℝ≥0∞} (hf : Measurable f) :\n    μ.withDensity (r • f) = r • μ.withDensity f := by\n  refine Measure.ext fun s hs => ?_\n  rw [withDensity_apply _ hs, Measure.coe_smul, Pi.smul_apply, withDensity_apply _ hs,\n    smul_eq_mul, ← lintegral_const_mul r hf]\n  simp only [Pi.smul_apply, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.withDensity_smul'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\nhr : Ne r Top.top\n⊢ Eq (μ.withDensity (HSMul.hSMul r f)) (HSMul.hSMul r (μ.withDensity f))","decl":"theorem withDensity_smul' (r : ℝ≥0∞) (f : α → ℝ≥0∞) (hr : r ≠ ∞) :\n    μ.withDensity (r • f) = r • μ.withDensity f := by\n  refine Measure.ext fun s hs => ?_\n  rw [withDensity_apply _ hs, Measure.coe_smul, Pi.smul_apply, withDensity_apply _ hs,\n    smul_eq_mul, ← lintegral_const_mul' r f hr]\n  simp only [Pi.smul_apply, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.withDensity_smul_measure","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nr : ENNReal\nf : α → ENNReal\n⊢ Eq ((HSMul.hSMul r μ).withDensity f) (HSMul.hSMul r (μ.withDensity f))","decl":"theorem withDensity_smul_measure (r : ℝ≥0∞) (f : α → ℝ≥0∞) :\n    (r • μ).withDensity f = r • μ.withDensity f := by\n  ext s hs\n  rw [withDensity_apply _ hs, Measure.coe_smul, Pi.smul_apply, withDensity_apply _ hs,\n    smul_eq_mul, setLIntegral_smul_measure]\n\n"}
{"name":"MeasureTheory.isFiniteMeasure_withDensity","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Ne (MeasureTheory.lintegral μ fun a => f a) Top.top\n⊢ MeasureTheory.IsFiniteMeasure (μ.withDensity f)","decl":"theorem isFiniteMeasure_withDensity {f : α → ℝ≥0∞} (hf : ∫⁻ a, f a ∂μ ≠ ∞) :\n    IsFiniteMeasure (μ.withDensity f) :=\n  { measure_univ_lt_top := by\n      rwa [withDensity_apply _ MeasurableSet.univ, Measure.restrict_univ, lt_top_iff_ne_top] }\n\n"}
{"name":"MeasureTheory.withDensity_absolutelyContinuous","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\n⊢ (μ.withDensity f).AbsolutelyContinuous μ","decl":"theorem withDensity_absolutelyContinuous {m : MeasurableSpace α} (μ : Measure α) (f : α → ℝ≥0∞) :\n    μ.withDensity f ≪ μ := by\n  refine AbsolutelyContinuous.mk fun s hs₁ hs₂ => ?_\n  rw [withDensity_apply _ hs₁]\n  exact setLIntegral_measure_zero _ _ hs₂\n\n"}
{"name":"MeasureTheory.withDensity_zero","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.withDensity 0) 0","decl":"@[simp]\ntheorem withDensity_zero : μ.withDensity 0 = 0 := by\n  ext1 s hs\n  simp [withDensity_apply _ hs]\n\n"}
{"name":"MeasureTheory.withDensity_one","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.withDensity 1) μ","decl":"@[simp]\ntheorem withDensity_one : μ.withDensity 1 = μ := by\n  ext1 s hs\n  simp [withDensity_apply _ hs]\n\n"}
{"name":"MeasureTheory.withDensity_const","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : ENNReal\n⊢ Eq (μ.withDensity fun x => c) (HSMul.hSMul c μ)","decl":"@[simp]\ntheorem withDensity_const (c : ℝ≥0∞) : μ.withDensity (fun _ ↦ c) = c • μ := by\n  ext1 s hs\n  simp [withDensity_apply _ hs]\n\n"}
{"name":"MeasureTheory.withDensity_tsum","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_2\ninst✝ : Countable ι\nf : ι → α → ENNReal\nh : ∀ (i : ι), Measurable (f i)\n⊢ Eq (μ.withDensity (tsum fun n => f n)) (MeasureTheory.Measure.sum fun n => μ.withDensity (f n))","decl":"theorem withDensity_tsum {ι : Type*} [Countable ι] {f : ι → α → ℝ≥0∞} (h : ∀ i, Measurable (f i)) :\n    μ.withDensity (∑' n, f n) = sum fun n => μ.withDensity (f n) := by\n  ext1 s hs\n  simp_rw [sum_apply _ hs, withDensity_apply _ hs]\n  change ∫⁻ x in s, (∑' n, f n) x ∂μ = ∑' i, ∫⁻ x, f i x ∂μ.restrict s\n  rw [← lintegral_tsum fun i => (h i).aemeasurable]\n  exact lintegral_congr fun x => tsum_apply (Pi.summable.2 fun _ => ENNReal.summable)\n\n"}
{"name":"MeasureTheory.withDensity_indicator","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\n⊢ Eq (μ.withDensity (s.indicator f)) ((μ.restrict s).withDensity f)","decl":"theorem withDensity_indicator {s : Set α} (hs : MeasurableSet s) (f : α → ℝ≥0∞) :\n    μ.withDensity (s.indicator f) = (μ.restrict s).withDensity f := by\n  ext1 t ht\n  rw [withDensity_apply _ ht, lintegral_indicator hs, restrict_comm hs, ←\n    withDensity_apply _ ht]\n\n"}
{"name":"MeasureTheory.withDensity_indicator_one","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (μ.withDensity (s.indicator 1)) (μ.restrict s)","decl":"theorem withDensity_indicator_one {s : Set α} (hs : MeasurableSet s) :\n    μ.withDensity (s.indicator 1) = μ.restrict s := by\n  rw [withDensity_indicator hs, withDensity_one]\n\n"}
{"name":"MeasureTheory.withDensity_ofReal_mutuallySingular","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : Measurable f\n⊢ (μ.withDensity fun x => ENNReal.ofReal (f x)).MutuallySingular (μ.withDensity fun x => ENNReal.ofReal (Neg.neg (f x)))","decl":"theorem withDensity_ofReal_mutuallySingular {f : α → ℝ} (hf : Measurable f) :\n    (μ.withDensity fun x => ENNReal.ofReal <| f x) ⟂ₘ\n      μ.withDensity fun x => ENNReal.ofReal <| -f x := by\n  set S : Set α := { x | f x < 0 }\n  have hS : MeasurableSet S := measurableSet_lt hf measurable_const\n  refine ⟨S, hS, ?_, ?_⟩\n  · rw [withDensity_apply _ hS, lintegral_eq_zero_iff hf.ennreal_ofReal, EventuallyEq]\n    exact (ae_restrict_mem hS).mono fun x hx => ENNReal.ofReal_eq_zero.2 (le_of_lt hx)\n  · rw [withDensity_apply _ hS.compl, lintegral_eq_zero_iff hf.neg.ennreal_ofReal, EventuallyEq]\n    exact\n      (ae_restrict_mem hS.compl).mono fun x hx =>\n        ENNReal.ofReal_eq_zero.2 (not_lt.1 <| mt neg_pos.1 hx)\n\n"}
{"name":"MeasureTheory.restrict_withDensity","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nf : α → ENNReal\n⊢ Eq ((μ.withDensity f).restrict s) ((μ.restrict s).withDensity f)","decl":"theorem restrict_withDensity {s : Set α} (hs : MeasurableSet s) (f : α → ℝ≥0∞) :\n    (μ.withDensity f).restrict s = (μ.restrict s).withDensity f := by\n  ext1 t ht\n  rw [restrict_apply ht, withDensity_apply _ ht, withDensity_apply _ (ht.inter hs),\n    restrict_restrict ht]\n\n"}
{"name":"MeasureTheory.restrict_withDensity'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\ns : Set α\nf : α → ENNReal\n⊢ Eq ((μ.withDensity f).restrict s) ((μ.restrict s).withDensity f)","decl":"theorem restrict_withDensity' [SFinite μ] (s : Set α) (f : α → ℝ≥0∞) :\n    (μ.withDensity f).restrict s = (μ.restrict s).withDensity f := by\n  ext1 t ht\n  rw [restrict_apply ht, withDensity_apply _ ht, withDensity_apply' _ (t ∩ s),\n    restrict_restrict ht]\n\n"}
{"name":"MeasureTheory.trim_withDensity","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq ((μ.withDensity f).trim hm) ((μ.trim hm).withDensity f)","decl":"lemma trim_withDensity {m m0 : MeasurableSpace α} {μ : Measure α}\n    (hm : m ≤ m0) {f : α → ℝ≥0∞} (hf : Measurable[m] f) :\n    (μ.withDensity f).trim hm = (μ.trim hm).withDensity f := by\n  refine @Measure.ext _ m _ _ (fun s hs ↦ ?_)\n  rw [withDensity_apply _ hs, restrict_trim _ _ hs, lintegral_trim _ hf, trim_measurableSet_eq _ hs,\n    withDensity_apply _ (hm s hs)]\n\n"}
{"name":"MeasureTheory.Measure.MutuallySingular.withDensity","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : α → ENNReal\nh : μ.MutuallySingular ν\n⊢ (μ.withDensity f).MutuallySingular ν","decl":"lemma Measure.MutuallySingular.withDensity {ν : Measure α} {f : α → ℝ≥0∞} (h : μ ⟂ₘ ν) :\n    μ.withDensity f ⟂ₘ ν :=\n  MutuallySingular.mono_ac h (withDensity_absolutelyContinuous _ _) AbsolutelyContinuous.rfl\n\n"}
{"name":"MeasureTheory.withDensity_eq_zero_iff","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Iff (Eq (μ.withDensity f) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"@[simp]\ntheorem withDensity_eq_zero_iff {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    μ.withDensity f = 0 ↔ f =ᵐ[μ] 0 := by\n  rw [← measure_univ_eq_zero, withDensity_apply _ .univ, restrict_univ, lintegral_eq_zero_iff' hf]\n\n"}
{"name":"MeasureTheory.withDensity_eq_zero","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\na✝ : Eq (μ.withDensity f) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq f 0","decl":"alias ⟨withDensity_eq_zero, _⟩ := withDensity_eq_zero_iff\n\n"}
{"name":"MeasureTheory.withDensity_apply_eq_zero'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhf : AEMeasurable f μ\n⊢ Iff (Eq ((μ.withDensity f) s) 0) (Eq (μ (Inter.inter (setOf fun x => Ne (f x) 0) s)) 0)","decl":"theorem withDensity_apply_eq_zero' {f : α → ℝ≥0∞} {s : Set α} (hf : AEMeasurable f μ) :\n    μ.withDensity f s = 0 ↔ μ ({ x | f x ≠ 0 } ∩ s) = 0 := by\n  constructor\n  · intro hs\n    let t := toMeasurable (μ.withDensity f) s\n    apply measure_mono_null (inter_subset_inter_right _ (subset_toMeasurable (μ.withDensity f) s))\n    have A : μ.withDensity f t = 0 := by rw [measure_toMeasurable, hs]\n    rw [withDensity_apply f (measurableSet_toMeasurable _ s),\n      lintegral_eq_zero_iff' (AEMeasurable.restrict hf),\n      EventuallyEq, ae_restrict_iff'₀, ae_iff] at A\n    swap\n    · simp only [measurableSet_toMeasurable, MeasurableSet.nullMeasurableSet]\n    simp only [Pi.zero_apply, mem_setOf_eq, Filter.mem_mk] at A\n    convert A using 2\n    ext x\n    simp only [and_comm, exists_prop, mem_inter_iff, mem_setOf_eq,\n      mem_compl_iff, not_forall]\n  · intro hs\n    let t := toMeasurable μ ({ x | f x ≠ 0 } ∩ s)\n    have A : s ⊆ t ∪ { x | f x = 0 } := by\n      intro x hx\n      rcases eq_or_ne (f x) 0 with (fx | fx)\n      · simp only [fx, mem_union, mem_setOf_eq, eq_self_iff_true, or_true]\n      · left\n        apply subset_toMeasurable _ _\n        exact ⟨fx, hx⟩\n    apply measure_mono_null A (measure_union_null _ _)\n    · apply withDensity_absolutelyContinuous\n      rwa [measure_toMeasurable]\n    rcases hf with ⟨g, hg, hfg⟩\n    have t : {x | f x = 0} =ᵐ[μ.withDensity f] {x | g x = 0} := by\n      apply withDensity_absolutelyContinuous\n      filter_upwards [hfg] with a ha\n      rw [eq_iff_iff]\n      exact ⟨fun h ↦ by rw [h] at ha; exact ha.symm,\n             fun h ↦ by rw [h] at ha; exact ha⟩\n    rw [measure_congr t, withDensity_congr_ae hfg]\n    have M : MeasurableSet { x : α | g x = 0 } := hg (measurableSet_singleton _)\n    rw [withDensity_apply _ M, lintegral_eq_zero_iff hg]\n    filter_upwards [ae_restrict_mem M]\n    simp only [imp_self, Pi.zero_apply, imp_true_iff]\n\n"}
{"name":"MeasureTheory.withDensity_apply_eq_zero","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhf : Measurable f\n⊢ Iff (Eq ((μ.withDensity f) s) 0) (Eq (μ (Inter.inter (setOf fun x => Ne (f x) 0) s)) 0)","decl":"theorem withDensity_apply_eq_zero {f : α → ℝ≥0∞} {s : Set α} (hf : Measurable f) :\n    μ.withDensity f s = 0 ↔ μ ({ x | f x ≠ 0 } ∩ s) = 0 :=\n  withDensity_apply_eq_zero' <| hf.aemeasurable\n\n"}
{"name":"MeasureTheory.ae_withDensity_iff'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.withDensity f))) (Filter.Eventually (fun x => Ne (f x) 0 → p x) (MeasureTheory.ae μ))","decl":"theorem ae_withDensity_iff' {p : α → Prop} {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    (∀ᵐ x ∂μ.withDensity f, p x) ↔ ∀ᵐ x ∂μ, f x ≠ 0 → p x := by\n  rw [ae_iff, ae_iff, withDensity_apply_eq_zero' hf, iff_iff_eq]\n  congr\n  ext x\n  simp only [exists_prop, mem_inter_iff, mem_setOf_eq, not_forall]\n\n"}
{"name":"MeasureTheory.ae_withDensity_iff","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\nf : α → ENNReal\nhf : Measurable f\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.withDensity f))) (Filter.Eventually (fun x => Ne (f x) 0 → p x) (MeasureTheory.ae μ))","decl":"theorem ae_withDensity_iff {p : α → Prop} {f : α → ℝ≥0∞} (hf : Measurable f) :\n    (∀ᵐ x ∂μ.withDensity f, p x) ↔ ∀ᵐ x ∂μ, f x ≠ 0 → p x :=\n  ae_withDensity_iff' <| hf.aemeasurable\n\n"}
{"name":"MeasureTheory.ae_withDensity_iff_ae_restrict'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.withDensity f))) (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (setOf fun x => Ne (f x) 0))))","decl":"theorem ae_withDensity_iff_ae_restrict' {p : α → Prop} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) :\n    (∀ᵐ x ∂μ.withDensity f, p x) ↔ ∀ᵐ x ∂μ.restrict { x | f x ≠ 0 }, p x := by\n  rw [ae_withDensity_iff' hf, ae_restrict_iff'₀]\n  · simp only [mem_setOf]\n  · rcases hf with ⟨g, hg, hfg⟩\n    have nonneg_eq_ae : {x | g x ≠ 0} =ᵐ[μ] {x | f x ≠ 0} := by\n      filter_upwards [hfg] with a ha\n      simp only [eq_iff_iff]\n      exact ⟨fun (h : g a ≠ 0) ↦ by rwa [← ha] at h,\n             fun (h : f a ≠ 0) ↦ by rwa [ha] at h⟩\n    exact NullMeasurableSet.congr\n      (MeasurableSet.nullMeasurableSet\n        <| hg (measurableSet_singleton _)).compl\n      nonneg_eq_ae\n\n"}
{"name":"MeasureTheory.ae_withDensity_iff_ae_restrict","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\nf : α → ENNReal\nhf : Measurable f\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.withDensity f))) (Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (setOf fun x => Ne (f x) 0))))","decl":"theorem ae_withDensity_iff_ae_restrict {p : α → Prop} {f : α → ℝ≥0∞} (hf : Measurable f) :\n    (∀ᵐ x ∂μ.withDensity f, p x) ↔ ∀ᵐ x ∂μ.restrict { x | f x ≠ 0 }, p x :=\n  ae_withDensity_iff_ae_restrict' <| hf.aemeasurable\n\n"}
{"name":"MeasureTheory.aemeasurable_withDensity_ennreal_iff'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → NNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\n⊢ Iff (AEMeasurable g (μ.withDensity fun x => ↑(f x))) (AEMeasurable (fun x => HMul.hMul (↑(f x)) (g x)) μ)","decl":"theorem aemeasurable_withDensity_ennreal_iff' {f : α → ℝ≥0}\n    (hf : AEMeasurable f μ) {g : α → ℝ≥0∞} :\n    AEMeasurable g (μ.withDensity fun x => (f x : ℝ≥0∞)) ↔\n      AEMeasurable (fun x => (f x : ℝ≥0∞) * g x) μ := by\n  have t : ∃ f', Measurable f' ∧ f =ᵐ[μ] f' := hf\n  rcases t with ⟨f', hf'_m, hf'_ae⟩\n  constructor\n  · rintro ⟨g', g'meas, hg'⟩\n    have A : MeasurableSet {x | f' x ≠ 0} := hf'_m (measurableSet_singleton _).compl\n    refine ⟨fun x => f' x * g' x, hf'_m.coe_nnreal_ennreal.smul g'meas, ?_⟩\n    apply ae_of_ae_restrict_of_ae_restrict_compl { x | f' x ≠ 0 }\n    · rw [EventuallyEq, ae_withDensity_iff' hf.coe_nnreal_ennreal] at hg'\n      rw [ae_restrict_iff' A]\n      filter_upwards [hg', hf'_ae] with a ha h'a h_a_nonneg\n      have : (f' a : ℝ≥0∞) ≠ 0 := by simpa only [Ne, ENNReal.coe_eq_zero] using h_a_nonneg\n      rw [← h'a] at this ⊢\n      rw [ha this]\n    · rw [ae_restrict_iff' A.compl]\n      filter_upwards [hf'_ae] with a ha ha_null\n      have ha_null : f' a = 0 := Function.nmem_support.mp ha_null\n      rw [ha_null] at ha ⊢\n      rw [ha]\n      simp only [ENNReal.coe_zero, zero_mul]\n  · rintro ⟨g', g'meas, hg'⟩\n    refine ⟨fun x => ((f' x)⁻¹ : ℝ≥0∞) * g' x, hf'_m.coe_nnreal_ennreal.inv.smul g'meas, ?_⟩\n    rw [EventuallyEq, ae_withDensity_iff' hf.coe_nnreal_ennreal]\n    filter_upwards [hg', hf'_ae] with a hfga hff'a h'a\n    rw [hff'a] at hfga h'a\n    rw [← hfga, ← mul_assoc, ENNReal.inv_mul_cancel h'a ENNReal.coe_ne_top, one_mul]\n\n"}
{"name":"MeasureTheory.aemeasurable_withDensity_ennreal_iff","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → NNReal\nhf : Measurable f\ng : α → ENNReal\n⊢ Iff (AEMeasurable g (μ.withDensity fun x => ↑(f x))) (AEMeasurable (fun x => HMul.hMul (↑(f x)) (g x)) μ)","decl":"theorem aemeasurable_withDensity_ennreal_iff {f : α → ℝ≥0} (hf : Measurable f) {g : α → ℝ≥0∞} :\n    AEMeasurable g (μ.withDensity fun x => (f x : ℝ≥0∞)) ↔\n      AEMeasurable (fun x => (f x : ℝ≥0∞) * g x) μ :=\n  aemeasurable_withDensity_ennreal_iff' <| hf.aemeasurable\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nh_mf : Measurable f\ng : α → ENNReal\na✝ : Measurable g\n⊢ Eq (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"/-- This is Exercise 1.2.1 from [tao2010]. It allows you to express integration of a measurable\nfunction with respect to `(μ.withDensity f)` as an integral with respect to `μ`, called the base\nmeasure. `μ` is often the Lebesgue measure, and in this circumstance `f` is the probability density\nfunction, and `(μ.withDensity f)` represents any continuous random variable as a\nprobability measure, such as the uniform distribution between 0 and 1, the Gaussian distribution,\nthe exponential distribution, the Beta distribution, or the Cauchy distribution (see Section 2.4\nof [wasserman2004]). Thus, this method shows how to one can calculate expectations, variances,\nand other moments as a function of the probability density function.\n -/\ntheorem lintegral_withDensity_eq_lintegral_mul (μ : Measure α) {f : α → ℝ≥0∞}\n    (h_mf : Measurable f) :\n    ∀ {g : α → ℝ≥0∞}, Measurable g → ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, (f * g) a ∂μ := by\n  apply Measurable.ennreal_induction\n  · intro c s h_ms\n    simp [*, mul_comm _ c, ← indicator_mul_right]\n  · intro g h _ h_mea_g _ h_ind_g h_ind_h\n    simp [mul_add, *, Measurable.mul]\n  · intro g h_mea_g h_mono_g h_ind\n    have : Monotone fun n a => f a * g n a := fun m n hmn x => mul_le_mul_left' (h_mono_g hmn x) _\n    simp [lintegral_iSup, ENNReal.mul_iSup, h_mf.mul (h_mea_g _), *]\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_setLIntegral_mul","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun x => g x) (MeasureTheory.lintegral (μ.restrict s) fun x => HMul.hMul f g x)","decl":"theorem setLIntegral_withDensity_eq_setLIntegral_mul (μ : Measure α) {f g : α → ℝ≥0∞}\n    (hf : Measurable f) (hg : Measurable g) {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ x in s, g x ∂μ.withDensity f = ∫⁻ x in s, (f * g) x ∂μ := by\n  rw [restrict_withDensity hs, lintegral_withDensity_eq_lintegral_mul _ hf hg]\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul₀'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\nhg : AEMeasurable g (μ.withDensity f)\n⊢ Eq (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"/-- The Lebesgue integral of `g` with respect to the measure `μ.withDensity f` coincides with\nthe integral of `f * g`. This version assumes that `g` is almost everywhere measurable. For a\nversion without conditions on `g` but requiring that `f` is almost everywhere finite, see\n`lintegral_withDensity_eq_lintegral_mul_non_measurable` -/\ntheorem lintegral_withDensity_eq_lintegral_mul₀' {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) {g : α → ℝ≥0∞} (hg : AEMeasurable g (μ.withDensity f)) :\n    ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, (f * g) a ∂μ := by\n  let f' := hf.mk f\n  have : μ.withDensity f = μ.withDensity f' := withDensity_congr_ae hf.ae_eq_mk\n  rw [this] at hg ⊢\n  let g' := hg.mk g\n  calc\n    ∫⁻ a, g a ∂μ.withDensity f' = ∫⁻ a, g' a ∂μ.withDensity f' := lintegral_congr_ae hg.ae_eq_mk\n    _ = ∫⁻ a, (f' * g') a ∂μ :=\n      (lintegral_withDensity_eq_lintegral_mul _ hf.measurable_mk hg.measurable_mk)\n    _ = ∫⁻ a, (f' * g) a ∂μ := by\n      apply lintegral_congr_ae\n      apply ae_of_ae_restrict_of_ae_restrict_compl { x | f' x ≠ 0 }\n      · have Z := hg.ae_eq_mk\n        rw [EventuallyEq, ae_withDensity_iff_ae_restrict hf.measurable_mk] at Z\n        filter_upwards [Z]\n        intro x hx\n        simp only [g', hx, Pi.mul_apply]\n      · have M : MeasurableSet { x : α | f' x ≠ 0 }ᶜ :=\n          (hf.measurable_mk (measurableSet_singleton 0).compl).compl\n        filter_upwards [ae_restrict_mem M]\n        intro x hx\n        simp only [Classical.not_not, mem_setOf_eq, mem_compl_iff] at hx\n        simp only [hx, zero_mul, Pi.mul_apply]\n    _ = ∫⁻ a : α, (f * g) a ∂μ := by\n      apply lintegral_congr_ae\n      filter_upwards [hf.ae_eq_mk]\n      intro x hx\n      simp only [f', hx, Pi.mul_apply]\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_lintegral_mul₀'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\nhg : AEMeasurable g (μ.withDensity f)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun a => g a) (MeasureTheory.lintegral (μ.restrict s) fun a => HMul.hMul f g a)","decl":"lemma setLIntegral_withDensity_eq_lintegral_mul₀' {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) {g : α → ℝ≥0∞} (hg : AEMeasurable g (μ.withDensity f))\n    {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ a in s, g a ∂μ.withDensity f = ∫⁻ a in s, (f * g) a ∂μ := by\n  rw [restrict_withDensity hs, lintegral_withDensity_eq_lintegral_mul₀' hf.restrict]\n  rw [← restrict_withDensity hs]\n  exact hg.restrict\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\nhg : AEMeasurable g μ\n⊢ Eq (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"theorem lintegral_withDensity_eq_lintegral_mul₀ {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) {g : α → ℝ≥0∞} (hg : AEMeasurable g μ) :\n    ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, (f * g) a ∂μ :=\n  lintegral_withDensity_eq_lintegral_mul₀' hf (hg.mono' (withDensity_absolutelyContinuous μ f))\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_lintegral_mul₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\ng : α → ENNReal\nhg : AEMeasurable g μ\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun a => g a) (MeasureTheory.lintegral (μ.restrict s) fun a => HMul.hMul f g a)","decl":"lemma setLIntegral_withDensity_eq_lintegral_mul₀ {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) {g : α → ℝ≥0∞} (hg : AEMeasurable g μ)\n    {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ a in s, g a ∂μ.withDensity f = ∫⁻ a in s, (f * g) a ∂μ :=\n  setLIntegral_withDensity_eq_lintegral_mul₀' hf\n    (hg.mono' (MeasureTheory.withDensity_absolutelyContinuous μ f)) hs\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_le_lintegral_mul","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nf_meas : Measurable f\ng : α → ENNReal\n⊢ LE.le (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"theorem lintegral_withDensity_le_lintegral_mul (μ : Measure α) {f : α → ℝ≥0∞}\n    (f_meas : Measurable f) (g : α → ℝ≥0∞) : (∫⁻ a, g a ∂μ.withDensity f) ≤ ∫⁻ a, (f * g) a ∂μ := by\n  rw [← iSup_lintegral_measurable_le_eq_lintegral, ← iSup_lintegral_measurable_le_eq_lintegral]\n  refine iSup₂_le fun i i_meas => iSup_le fun hi => ?_\n  have A : f * i ≤ f * g := fun x => mul_le_mul_left' (hi x) _\n  refine le_iSup₂_of_le (f * i) (f_meas.mul i_meas) ?_\n  exact le_iSup_of_le A (le_of_eq (lintegral_withDensity_eq_lintegral_mul _ f_meas i_meas))\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul_non_measurable","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nf_meas : Measurable f\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\ng : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"theorem lintegral_withDensity_eq_lintegral_mul_non_measurable (μ : Measure α) {f : α → ℝ≥0∞}\n    (f_meas : Measurable f) (hf : ∀ᵐ x ∂μ, f x < ∞) (g : α → ℝ≥0∞) :\n    ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, (f * g) a ∂μ := by\n  refine le_antisymm (lintegral_withDensity_le_lintegral_mul μ f_meas g) ?_\n  rw [← iSup_lintegral_measurable_le_eq_lintegral, ← iSup_lintegral_measurable_le_eq_lintegral]\n  refine iSup₂_le fun i i_meas => iSup_le fun hi => ?_\n  have A : (fun x => (f x)⁻¹ * i x) ≤ g := by\n    intro x\n    dsimp\n    rw [mul_comm, ← div_eq_mul_inv]\n    exact div_le_of_le_mul' (hi x)\n  refine le_iSup_of_le (fun x => (f x)⁻¹ * i x) (le_iSup_of_le (f_meas.inv.mul i_meas) ?_)\n  refine le_iSup_of_le A ?_\n  rw [lintegral_withDensity_eq_lintegral_mul _ f_meas (f_meas.inv.mul i_meas)]\n  apply lintegral_mono_ae\n  filter_upwards [hf]\n  intro x h'x\n  rcases eq_or_ne (f x) 0 with (hx | hx)\n  · have := hi x\n    simp only [hx, zero_mul, Pi.mul_apply, nonpos_iff_eq_zero] at this\n    simp [this]\n  · apply le_of_eq _\n    dsimp\n    rw [← mul_assoc, ENNReal.mul_inv_cancel hx h'x.ne, one_mul]\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nf_meas : Measurable f\ng : α → ENNReal\ns : Set α\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae (μ.restrict s))\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun a => g a) (MeasureTheory.lintegral (μ.restrict s) fun a => HMul.hMul f g a)","decl":"theorem setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable (μ : Measure α) {f : α → ℝ≥0∞}\n    (f_meas : Measurable f) (g : α → ℝ≥0∞) {s : Set α} (hs : MeasurableSet s)\n    (hf : ∀ᵐ x ∂μ.restrict s, f x < ∞) :\n    ∫⁻ a in s, g a ∂μ.withDensity f = ∫⁻ a in s, (f * g) a ∂μ := by\n  rw [restrict_withDensity hs, lintegral_withDensity_eq_lintegral_mul_non_measurable _ f_meas hf]\n\n"}
{"name":"MeasureTheory.lintegral_withDensity_eq_lintegral_mul_non_measurable₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nh'f : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\ng : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.withDensity f) fun a => g a) (MeasureTheory.lintegral μ fun a => HMul.hMul f g a)","decl":"theorem lintegral_withDensity_eq_lintegral_mul_non_measurable₀ (μ : Measure α) {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (h'f : ∀ᵐ x ∂μ, f x < ∞) (g : α → ℝ≥0∞) :\n    ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, (f * g) a ∂μ := by\n  let f' := hf.mk f\n  calc\n    ∫⁻ a, g a ∂μ.withDensity f = ∫⁻ a, g a ∂μ.withDensity f' := by\n      rw [withDensity_congr_ae hf.ae_eq_mk]\n    _ = ∫⁻ a, (f' * g) a ∂μ := by\n      apply lintegral_withDensity_eq_lintegral_mul_non_measurable _ hf.measurable_mk\n      filter_upwards [h'f, hf.ae_eq_mk]\n      intro x hx h'x\n      rwa [← h'x]\n    _ = ∫⁻ a, (f * g) a ∂μ := by\n      apply lintegral_congr_ae\n      filter_upwards [hf.ae_eq_mk]\n      intro x hx\n      simp only [f', hx, Pi.mul_apply]\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\ns : Set α\nhf : AEMeasurable f (μ.restrict s)\ng : α → ENNReal\nhs : MeasurableSet s\nh'f : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae (μ.restrict s))\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun a => g a) (MeasureTheory.lintegral (μ.restrict s) fun a => HMul.hMul f g a)","decl":"theorem setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀ (μ : Measure α)\n    {f : α → ℝ≥0∞} {s : Set α} (hf : AEMeasurable f (μ.restrict s)) (g : α → ℝ≥0∞)\n    (hs : MeasurableSet s) (h'f : ∀ᵐ x ∂μ.restrict s, f x < ∞) :\n    ∫⁻ a in s, g a ∂μ.withDensity f = ∫⁻ a in s, (f * g) a ∂μ := by\n  rw [restrict_withDensity hs, lintegral_withDensity_eq_lintegral_mul_non_measurable₀ _ hf h'f]\n\n"}
{"name":"MeasureTheory.setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → ENNReal\ns : Set α\nhf : AEMeasurable f (μ.restrict s)\ng : α → ENNReal\nh'f : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae (μ.restrict s))\n⊢ Eq (MeasureTheory.lintegral ((μ.withDensity f).restrict s) fun a => g a) (MeasureTheory.lintegral (μ.restrict s) fun a => HMul.hMul f g a)","decl":"theorem setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀' (μ : Measure α) [SFinite μ]\n    {f : α → ℝ≥0∞} (s : Set α) (hf : AEMeasurable f (μ.restrict s)) (g : α → ℝ≥0∞)\n    (h'f : ∀ᵐ x ∂μ.restrict s, f x < ∞) :\n    ∫⁻ a in s, g a ∂μ.withDensity f = ∫⁻ a in s, (f * g) a ∂μ := by\n  rw [restrict_withDensity' s, lintegral_withDensity_eq_lintegral_mul_non_measurable₀ _ hf h'f]\n\n"}
{"name":"MeasureTheory.withDensity_mul₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ Eq (μ.withDensity (HMul.hMul f g)) ((μ.withDensity f).withDensity g)","decl":"theorem withDensity_mul₀ {μ : Measure α} {f g : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    μ.withDensity (f * g) = (μ.withDensity f).withDensity g := by\n  ext1 s hs\n  rw [withDensity_apply _ hs, withDensity_apply _ hs, restrict_withDensity hs,\n    lintegral_withDensity_eq_lintegral_mul₀ hf.restrict hg.restrict]\n\n"}
{"name":"MeasureTheory.withDensity_mul","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\n⊢ Eq (μ.withDensity (HMul.hMul f g)) ((μ.withDensity f).withDensity g)","decl":"theorem withDensity_mul (μ : Measure α) {f g : α → ℝ≥0∞} (hf : Measurable f) (hg : Measurable g) :\n    μ.withDensity (f * g) = (μ.withDensity f).withDensity g :=\n  withDensity_mul₀ hf.aemeasurable hg.aemeasurable\n\n"}
{"name":"MeasureTheory.withDensity_inv_same_le","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\n⊢ LE.le ((μ.withDensity f).withDensity (Inv.inv f)) μ","decl":"lemma withDensity_inv_same_le {μ : Measure α} {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) :\n    (μ.withDensity f).withDensity f⁻¹ ≤ μ := by\n  change (μ.withDensity f).withDensity (fun x ↦ (f x)⁻¹) ≤ μ\n  rw [← withDensity_mul₀ hf hf.inv]\n  suffices (f * fun x ↦ (f x)⁻¹) ≤ᵐ[μ] 1 by\n    refine (withDensity_mono this).trans ?_\n    rw [withDensity_one]\n  filter_upwards with x\n  simp only [Pi.mul_apply, Pi.one_apply]\n  by_cases hx_top : f x = ∞\n  · simp only [hx_top, ENNReal.inv_top, mul_zero, zero_le]\n  by_cases hx_zero : f x = 0\n  · simp only [hx_zero, ENNReal.inv_zero, zero_mul, zero_le]\n  rw [ENNReal.mul_inv_cancel hx_zero hx_top]\n\n"}
{"name":"MeasureTheory.withDensity_inv_same₀","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae μ)\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ Eq ((μ.withDensity f).withDensity fun x => Inv.inv (f x)) μ","decl":"lemma withDensity_inv_same₀ {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hf_ne_zero : ∀ᵐ x ∂μ, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    (μ.withDensity f).withDensity (fun x ↦ (f x)⁻¹) = μ := by\n  rw [← withDensity_mul₀ hf hf.inv]\n  suffices (f * fun x ↦ (f x)⁻¹) =ᵐ[μ] 1 by\n    rw [withDensity_congr_ae this, withDensity_one]\n  filter_upwards [hf_ne_zero, hf_ne_top] with x hf_ne_zero hf_ne_top\n  simp only [Pi.mul_apply]\n  rw [ENNReal.mul_inv_cancel hf_ne_zero hf_ne_top, Pi.one_apply]\n\n"}
{"name":"MeasureTheory.withDensity_inv_same","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae μ)\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ Eq ((μ.withDensity f).withDensity fun x => Inv.inv (f x)) μ","decl":"lemma withDensity_inv_same {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : Measurable f) (hf_ne_zero : ∀ᵐ x ∂μ, f x ≠ 0) (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    (μ.withDensity f).withDensity (fun x ↦ (f x)⁻¹) = μ :=\n  withDensity_inv_same₀ hf.aemeasurable hf_ne_zero hf_ne_top\n\n"}
{"name":"MeasureTheory.withDensity_absolutelyContinuous'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhf_ne_zero : Filter.Eventually (fun x => Ne (f x) 0) (MeasureTheory.ae μ)\n⊢ μ.AbsolutelyContinuous (μ.withDensity f)","decl":"/-- If `f` is almost everywhere positive, then `μ ≪ μ.withDensity f`. See also\n`withDensity_absolutelyContinuous` for the reverse direction, which always holds. -/\nlemma withDensity_absolutelyContinuous' {μ : Measure α} {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hf_ne_zero : ∀ᵐ x ∂μ, f x ≠ 0) :\n    μ ≪ μ.withDensity f := by\n  refine Measure.AbsolutelyContinuous.mk (fun s hs hμs ↦ ?_)\n  rw [withDensity_apply _ hs, lintegral_eq_zero_iff' hf.restrict,\n    ae_eq_restrict_iff_indicator_ae_eq hs, Set.indicator_zero', Filter.EventuallyEq, ae_iff] at hμs\n  simp only [ae_iff, ne_eq, not_not] at hf_ne_zero\n  simp only [Pi.zero_apply, Set.indicator_apply_eq_zero, not_forall, exists_prop] at hμs\n  have hle : s ⊆ {a | a ∈ s ∧ ¬f a = 0} ∪ {a | f a = 0} :=\n    fun x hx ↦ or_iff_not_imp_right.mpr <| fun hnx ↦ ⟨hx, hnx⟩\n  exact measure_mono_null hle <| nonpos_iff_eq_zero.1 <| le_trans (measure_union_le _ _)\n    <| hμs.symm ▸ zero_add _ |>.symm ▸ hf_ne_zero.le\n\n"}
{"name":"MeasureTheory.withDensity_ae_eq","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type\nf g : α → β\nd : α → ENNReal\nhd : AEMeasurable d μ\nh_ae_nonneg : Filter.Eventually (fun x => Ne (d x) 0) (MeasureTheory.ae μ)\n⊢ Iff ((MeasureTheory.ae (μ.withDensity d)).EventuallyEq f g) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"theorem withDensity_ae_eq {β : Type} {f g : α → β} {d : α → ℝ≥0∞}\n    (hd : AEMeasurable d μ) (h_ae_nonneg : ∀ᵐ x ∂μ, d x ≠ 0) :\n    f =ᵐ[μ.withDensity d] g ↔ f =ᵐ[μ] g :=\n  Iff.intro\n  (fun h ↦ Measure.AbsolutelyContinuous.ae_eq\n    (withDensity_absolutelyContinuous' hd h_ae_nonneg) h)\n  (fun h ↦ Measure.AbsolutelyContinuous.ae_eq\n    (withDensity_absolutelyContinuous μ d) h)\n\n"}
{"name":"MeasureTheory.SigmaFinite.withDensity","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → NNReal\n⊢ MeasureTheory.SigmaFinite (μ.withDensity fun x => ↑(f x))","decl":"/-- If `μ` is a σ-finite measure, then so is `μ.withDensity fun x ↦ f x`\nfor any `ℝ≥0`-valued function `f`. -/\nprotected instance SigmaFinite.withDensity [SigmaFinite μ] (f : α → ℝ≥0) :\n    SigmaFinite (μ.withDensity (fun x ↦ f x)) := by\n  refine ⟨⟨⟨fun n ↦ spanningSets μ n ∩ f ⁻¹' (Iic n), fun _ ↦ trivial, fun n ↦ ?_, ?_⟩⟩⟩\n  · rw [withDensity_apply']\n    apply setLIntegral_lt_top_of_bddAbove\n    · exact ((measure_mono inter_subset_left).trans_lt (measure_spanningSets_lt_top μ n)).ne\n    · exact ⟨n, forall_mem_image.2 fun x hx ↦ hx.2⟩\n  · rw [iUnion_eq_univ_iff]\n    refine fun x ↦ ⟨max (spanningSetsIndex μ x) ⌈f x⌉₊, ?_, ?_⟩\n    · exact mem_spanningSets_of_index_le _ _ (le_max_left ..)\n    · simp [Nat.le_ceil]\n\n"}
{"name":"MeasureTheory.SigmaFinite.withDensity_of_ne_top","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → ENNReal\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ MeasureTheory.SigmaFinite (μ.withDensity f)","decl":"lemma SigmaFinite.withDensity_of_ne_top [SigmaFinite μ] {f : α → ℝ≥0∞}\n    (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) : SigmaFinite (μ.withDensity f) := by\n  have : f =ᵐ[μ] fun x ↦ (f x).toNNReal := hf_ne_top.mono fun x hx ↦ (ENNReal.coe_toNNReal hx).symm\n  rw [withDensity_congr_ae this]\n  infer_instance\n\n"}
{"name":"MeasureTheory.SigmaFinite.withDensity_of_ne_top'","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → ENNReal\nhf_ne_top : ∀ (x : α), Ne (f x) Top.top\n⊢ MeasureTheory.SigmaFinite (μ.withDensity f)","decl":"lemma SigmaFinite.withDensity_of_ne_top' [SigmaFinite μ] {f : α → ℝ≥0∞} (hf_ne_top : ∀ x, f x ≠ ∞) :\n    SigmaFinite (μ.withDensity f) :=\n  SigmaFinite.withDensity_of_ne_top <| ae_of_all _ hf_ne_top\n\n"}
{"name":"MeasureTheory.SigmaFinite.withDensity_ofReal","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf : α → Real\n⊢ MeasureTheory.SigmaFinite (μ.withDensity fun x => ENNReal.ofReal (f x))","decl":"instance SigmaFinite.withDensity_ofReal [SigmaFinite μ] (f : α → ℝ) :\n    SigmaFinite (μ.withDensity (fun x ↦ ENNReal.ofReal (f x))) :=\n  .withDensity _\n\n"}
{"name":"MeasureTheory.exists_measurable_le_withDensity_eq","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → ENNReal\n⊢ Exists fun g => And (Measurable g) (And (LE.le g f) (Eq (μ.withDensity g) (μ.withDensity f)))","decl":"variable (μ) in\ntheorem exists_measurable_le_withDensity_eq [SFinite μ] (f : α → ℝ≥0∞) :\n    ∃ g, Measurable g ∧ g ≤ f ∧ μ.withDensity g = μ.withDensity f := by\n  obtain ⟨g, hgm, hgf, hint⟩ := exists_measurable_le_forall_setLIntegral_eq μ f\n  use g, hgm, hgf\n  ext s hs\n  simp only [hint, withDensity_apply _ hs]\n\n"}
{"name":"MeasureTheory.Measure.withDensity.instSFinite","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → ENNReal\n⊢ MeasureTheory.SFinite (μ.withDensity f)","decl":"/-- If `μ` is an `s`-finite measure, then so is `μ.withDensity f`. -/\ninstance Measure.withDensity.instSFinite [SFinite μ] {f : α → ℝ≥0∞} :\n    SFinite (μ.withDensity f) := by\n  wlog hfm : Measurable f generalizing f\n  · rcases exists_measurable_le_withDensity_eq μ f with ⟨g, hgm, -, h⟩\n    exact h ▸ this hgm\n  wlog hμ : IsFiniteMeasure μ generalizing μ\n  · rw [← sum_sfiniteSeq μ, withDensity_sum]\n    have (n : ℕ) : SFinite ((sfiniteSeq μ n).withDensity f) := this inferInstance\n    infer_instance\n  set s := {x | f x = ∞}\n  have hs : MeasurableSet s := hfm (measurableSet_singleton _)\n  have key := calc\n    μ.withDensity f = μ.withDensity (sᶜ.indicator f) + μ.withDensity (s.indicator f) := by\n      simp (disch := measurability) [withDensity_indicator, ← restrict_withDensity]\n    _ = μ.withDensity (sᶜ.indicator f) + .sum fun _ : ℕ ↦ μ.withDensity (s.indicator 1) := by\n      rw [← withDensity_tsum (by measurability)]\n      congr 2 with x\n      rw [ENNReal.tsum_apply]\n      if hx : x ∈ s then simpa [hx, ENNReal.tsum_const_eq_top_of_ne_zero]\n      else simp [hx]\n  have : SigmaFinite (μ.withDensity (sᶜ.indicator f)) := by\n    refine SigmaFinite.withDensity_of_ne_top <| ae_of_all _ fun x hx ↦ ?_\n    simp [indicator_apply, ite_eq_iff, s] at hx\n  have : SigmaFinite (μ.withDensity (s.indicator 1)) := by\n    rw [withDensity_indicator hs]\n    exact SigmaFinite.withDensity 1\n  rw [key]\n  infer_instance\n\n"}
{"name":"MeasureTheory.instSFiniteHSMulENNRealMeasure","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nc : ENNReal\n⊢ MeasureTheory.SFinite (HSMul.hSMul c μ)","decl":"instance [SFinite μ] (c : ℝ≥0∞) : SFinite (c • μ) := by\n  rw [← withDensity_const]\n  infer_instance\n\n"}
{"name":"MeasureTheory.sFinite_of_absolutelyContinuous","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ MeasureTheory.SFinite μ","decl":"/-- If `μ ≪ ν` and `ν` is s-finite, then `μ` is s-finite. -/\ntheorem sFinite_of_absolutelyContinuous {ν : Measure α} [SFinite ν] (hμν : μ ≪ ν) :\n    SFinite μ := by\n  rw [← Measure.restrict_add_restrict_compl (μ := μ) measurableSet_sigmaFiniteSetWRT,\n    restrict_compl_sigmaFiniteSetWRT hμν]\n  infer_instance\n\n"}
{"name":"MeasureTheory.IsLocallyFiniteMeasure.withDensity_coe","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : TopologicalSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → NNReal\nhf : Continuous f\n⊢ MeasureTheory.IsLocallyFiniteMeasure (μ.withDensity fun x => ↑(f x))","decl":"lemma IsLocallyFiniteMeasure.withDensity_coe {f : α → ℝ≥0} (hf : Continuous f) :\n    IsLocallyFiniteMeasure (μ.withDensity fun x ↦ f x) := by\n  refine ⟨fun x ↦ ?_⟩\n  rcases (μ.finiteAt_nhds x).exists_mem_basis ((nhds_basis_opens' x).restrict_subset\n    ((hf.tendsto x).eventually_le_const (lt_add_one _))) with ⟨U, ⟨⟨hUx, hUo⟩, hUf⟩, hμU⟩\n  refine ⟨U, hUx, ?_⟩\n  rw [withDensity_apply _ hUo.measurableSet]\n  exact setLIntegral_lt_top_of_bddAbove hμU.ne ⟨f x + 1, forall_mem_image.2 hUf⟩\n\n"}
{"name":"MeasureTheory.IsLocallyFiniteMeasure.withDensity_ofReal","module":"Mathlib.MeasureTheory.Measure.WithDensity","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : TopologicalSpace α\ninst✝¹ : OpensMeasurableSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : α → Real\nhf : Continuous f\n⊢ MeasureTheory.IsLocallyFiniteMeasure (μ.withDensity fun x => ENNReal.ofReal (f x))","decl":"lemma IsLocallyFiniteMeasure.withDensity_ofReal {f : α → ℝ} (hf : Continuous f) :\n    IsLocallyFiniteMeasure (μ.withDensity fun x ↦ .ofReal (f x)) :=\n  .withDensity_coe <| continuous_real_toNNReal.comp hf\n\n"}
