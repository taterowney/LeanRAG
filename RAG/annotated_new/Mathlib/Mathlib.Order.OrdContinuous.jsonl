{"name":"LeftOrdContinuous.id","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ LeftOrdContinuous id","decl":"protected theorem id : LeftOrdContinuous (id : α → α) := fun s x h => by\n  simpa only [image_id] using h\n\n"}
{"name":"LeftOrdContinuous.order_dual","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : LeftOrdContinuous f\n⊢ RightOrdContinuous (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"protected theorem order_dual : LeftOrdContinuous f → RightOrdContinuous (toDual ∘ f ∘ ofDual) :=\n  id\n\n"}
{"name":"LeftOrdContinuous.map_isGreatest","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : LeftOrdContinuous f\ns : Set α\nx : α\nh : IsGreatest s x\n⊢ IsGreatest (Set.image f s) (f x)","decl":"theorem map_isGreatest (hf : LeftOrdContinuous f) {s : Set α} {x : α} (h : IsGreatest s x) :\n    IsGreatest (f '' s) (f x) :=\n  ⟨mem_image_of_mem f h.1, (hf h.isLUB).1⟩\n\n"}
{"name":"LeftOrdContinuous.mono","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : LeftOrdContinuous f\n⊢ Monotone f","decl":"theorem mono (hf : LeftOrdContinuous f) : Monotone f := fun a₁ a₂ h =>\n  have : IsGreatest {a₁, a₂} a₂ := ⟨Or.inr rfl, by simp [*]⟩\n  (hf.map_isGreatest this).2 <| mem_image_of_mem _ (Or.inl rfl)\n\n"}
{"name":"LeftOrdContinuous.comp","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : LeftOrdContinuous g\nhf : LeftOrdContinuous f\n⊢ LeftOrdContinuous (Function.comp g f)","decl":"theorem comp (hg : LeftOrdContinuous g) (hf : LeftOrdContinuous f) : LeftOrdContinuous (g ∘ f) :=\n  fun s x h => by simpa only [image_image] using hg (hf h)\n\n-- Porting note: how to do this in non-tactic mode?\n"}
{"name":"LeftOrdContinuous.iterate","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : α → α\nhf : LeftOrdContinuous f\nn : Nat\n⊢ LeftOrdContinuous (Nat.iterate f n)","decl":"protected theorem iterate {f : α → α} (hf : LeftOrdContinuous f) (n : ℕ) :\n    LeftOrdContinuous f^[n] := by\n  induction n with\n  | zero => exact LeftOrdContinuous.id α\n  | succ n ihn => exact ihn.comp hf\n\n"}
{"name":"LeftOrdContinuous.map_sup","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : LeftOrdContinuous f\nx y : α\n⊢ Eq (f (Max.max x y)) (Max.max (f x) (f y))","decl":"theorem map_sup (hf : LeftOrdContinuous f) (x y : α) : f (x ⊔ y) = f x ⊔ f y :=\n  (hf isLUB_pair).unique <| by simp only [image_pair, isLUB_pair]\n\n"}
{"name":"LeftOrdContinuous.le_iff","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : LeftOrdContinuous f\nh : Function.Injective f\nx y : α\n⊢ Iff (LE.le (f x) (f y)) (LE.le x y)","decl":"theorem le_iff (hf : LeftOrdContinuous f) (h : Injective f) {x y} : f x ≤ f y ↔ x ≤ y := by\n  simp only [← sup_eq_right, ← hf.map_sup, h.eq_iff]\n\n"}
{"name":"LeftOrdContinuous.lt_iff","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : LeftOrdContinuous f\nh : Function.Injective f\nx y : α\n⊢ Iff (LT.lt (f x) (f y)) (LT.lt x y)","decl":"theorem lt_iff (hf : LeftOrdContinuous f) (h : Injective f) {x y} : f x < f y ↔ x < y := by\n  simp only [lt_iff_le_not_le, hf.le_iff h]\n\n"}
{"name":"LeftOrdContinuous.coe_toOrderEmbedding","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeSup α\ninst✝ : SemilatticeSup β\nf : α → β\nhf : LeftOrdContinuous f\nh : Function.Injective f\n⊢ Eq (⇑(LeftOrdContinuous.toOrderEmbedding f hf h)) f","decl":"@[simp]\ntheorem coe_toOrderEmbedding (hf : LeftOrdContinuous f) (h : Injective f) :\n    ⇑(hf.toOrderEmbedding f h) = f :=\n  rfl\n\n"}
{"name":"LeftOrdContinuous.map_sSup'","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : LeftOrdContinuous f\ns : Set α\n⊢ Eq (f (SupSet.sSup s)) (SupSet.sSup (Set.image f s))","decl":"theorem map_sSup' (hf : LeftOrdContinuous f) (s : Set α) : f (sSup s) = sSup (f '' s) :=\n  (hf <| isLUB_sSup s).sSup_eq.symm\n\n"}
{"name":"LeftOrdContinuous.map_sSup","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : LeftOrdContinuous f\ns : Set α\n⊢ Eq (f (SupSet.sSup s)) (iSup fun x => iSup fun h => f x)","decl":"theorem map_sSup (hf : LeftOrdContinuous f) (s : Set α) : f (sSup s) = ⨆ x ∈ s, f x := by\n  rw [hf.map_sSup', sSup_image]\n\n"}
{"name":"LeftOrdContinuous.map_iSup","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : LeftOrdContinuous f\ng : ι → α\n⊢ Eq (f (iSup fun i => g i)) (iSup fun i => f (g i))","decl":"theorem map_iSup (hf : LeftOrdContinuous f) (g : ι → α) : f (⨆ i, g i) = ⨆ i, f (g i) := by\n  simp only [iSup, hf.map_sSup', ← range_comp]\n  rfl\n\n"}
{"name":"LeftOrdContinuous.map_csSup","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nhf : LeftOrdContinuous f\ns : Set α\nsne : s.Nonempty\nsbdd : BddAbove s\n⊢ Eq (f (SupSet.sSup s)) (SupSet.sSup (Set.image f s))","decl":"theorem map_csSup (hf : LeftOrdContinuous f) {s : Set α} (sne : s.Nonempty) (sbdd : BddAbove s) :\n    f (sSup s) = sSup (f '' s) :=\n  ((hf <| isLUB_csSup sne sbdd).csSup_eq <| sne.image f).symm\n\n"}
{"name":"LeftOrdContinuous.map_ciSup","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\nf : α → β\nhf : LeftOrdContinuous f\ng : ι → α\nhg : BddAbove (Set.range g)\n⊢ Eq (f (iSup fun i => g i)) (iSup fun i => f (g i))","decl":"theorem map_ciSup (hf : LeftOrdContinuous f) {g : ι → α} (hg : BddAbove (range g)) :\n    f (⨆ i, g i) = ⨆ i, f (g i) := by\n  simp only [iSup, hf.map_csSup (range_nonempty _) hg, ← range_comp]\n  rfl\n\n"}
{"name":"RightOrdContinuous.id","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ RightOrdContinuous id","decl":"protected theorem id : RightOrdContinuous (id : α → α) := fun s x h => by\n  simpa only [image_id] using h\n\n"}
{"name":"RightOrdContinuous.orderDual","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\na✝ : RightOrdContinuous f\n⊢ LeftOrdContinuous (Function.comp (⇑OrderDual.toDual) (Function.comp f ⇑OrderDual.ofDual))","decl":"protected theorem orderDual : RightOrdContinuous f → LeftOrdContinuous (toDual ∘ f ∘ ofDual) :=\n  id\n\n"}
{"name":"RightOrdContinuous.map_isLeast","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : RightOrdContinuous f\ns : Set α\nx : α\nh : IsLeast s x\n⊢ IsLeast (Set.image f s) (f x)","decl":"theorem map_isLeast (hf : RightOrdContinuous f) {s : Set α} {x : α} (h : IsLeast s x) :\n    IsLeast (f '' s) (f x) :=\n  hf.orderDual.map_isGreatest h\n\n"}
{"name":"RightOrdContinuous.mono","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : α → β\nhf : RightOrdContinuous f\n⊢ Monotone f","decl":"theorem mono (hf : RightOrdContinuous f) : Monotone f :=\n  hf.orderDual.mono.dual\n\n"}
{"name":"RightOrdContinuous.comp","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : Preorder α\ninst✝¹ : Preorder β\ninst✝ : Preorder γ\ng : β → γ\nf : α → β\nhg : RightOrdContinuous g\nhf : RightOrdContinuous f\n⊢ RightOrdContinuous (Function.comp g f)","decl":"theorem comp (hg : RightOrdContinuous g) (hf : RightOrdContinuous f) : RightOrdContinuous (g ∘ f) :=\n  hg.orderDual.comp hf.orderDual\n\n"}
{"name":"RightOrdContinuous.iterate","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\ninst✝ : Preorder α\nf : α → α\nhf : RightOrdContinuous f\nn : Nat\n⊢ RightOrdContinuous (Nat.iterate f n)","decl":"protected theorem iterate {f : α → α} (hf : RightOrdContinuous f) (n : ℕ) :\n    RightOrdContinuous f^[n] :=\n  hf.orderDual.iterate n\n\n"}
{"name":"RightOrdContinuous.map_inf","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : RightOrdContinuous f\nx y : α\n⊢ Eq (f (Min.min x y)) (Min.min (f x) (f y))","decl":"theorem map_inf (hf : RightOrdContinuous f) (x y : α) : f (x ⊓ y) = f x ⊓ f y :=\n  hf.orderDual.map_sup x y\n\n"}
{"name":"RightOrdContinuous.le_iff","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : RightOrdContinuous f\nh : Function.Injective f\nx y : α\n⊢ Iff (LE.le (f x) (f y)) (LE.le x y)","decl":"theorem le_iff (hf : RightOrdContinuous f) (h : Injective f) {x y} : f x ≤ f y ↔ x ≤ y :=\n  hf.orderDual.le_iff h\n\n"}
{"name":"RightOrdContinuous.lt_iff","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : RightOrdContinuous f\nh : Function.Injective f\nx y : α\n⊢ Iff (LT.lt (f x) (f y)) (LT.lt x y)","decl":"theorem lt_iff (hf : RightOrdContinuous f) (h : Injective f) {x y} : f x < f y ↔ x < y :=\n  hf.orderDual.lt_iff h\n\n"}
{"name":"RightOrdContinuous.coe_toOrderEmbedding","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : SemilatticeInf α\ninst✝ : SemilatticeInf β\nf : α → β\nhf : RightOrdContinuous f\nh : Function.Injective f\n⊢ Eq (⇑(RightOrdContinuous.toOrderEmbedding f hf h)) f","decl":"@[simp]\ntheorem coe_toOrderEmbedding (hf : RightOrdContinuous f) (h : Injective f) :\n    ⇑(hf.toOrderEmbedding f h) = f :=\n  rfl\n\n"}
{"name":"RightOrdContinuous.map_sInf'","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : RightOrdContinuous f\ns : Set α\n⊢ Eq (f (InfSet.sInf s)) (InfSet.sInf (Set.image f s))","decl":"theorem map_sInf' (hf : RightOrdContinuous f) (s : Set α) : f (sInf s) = sInf (f '' s) :=\n  hf.orderDual.map_sSup' s\n\n"}
{"name":"RightOrdContinuous.map_sInf","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : RightOrdContinuous f\ns : Set α\n⊢ Eq (f (InfSet.sInf s)) (iInf fun x => iInf fun h => f x)","decl":"theorem map_sInf (hf : RightOrdContinuous f) (s : Set α) : f (sInf s) = ⨅ x ∈ s, f x :=\n  hf.orderDual.map_sSup s\n\n"}
{"name":"RightOrdContinuous.map_iInf","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : α → β\nhf : RightOrdContinuous f\ng : ι → α\n⊢ Eq (f (iInf fun i => g i)) (iInf fun i => f (g i))","decl":"theorem map_iInf (hf : RightOrdContinuous f) (g : ι → α) : f (⨅ i, g i) = ⨅ i, f (g i) :=\n  hf.orderDual.map_iSup g\n\n"}
{"name":"RightOrdContinuous.map_csInf","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : ConditionallyCompleteLattice α\ninst✝ : ConditionallyCompleteLattice β\nf : α → β\nhf : RightOrdContinuous f\ns : Set α\nsne : s.Nonempty\nsbdd : BddBelow s\n⊢ Eq (f (InfSet.sInf s)) (InfSet.sInf (Set.image f s))","decl":"theorem map_csInf (hf : RightOrdContinuous f) {s : Set α} (sne : s.Nonempty) (sbdd : BddBelow s) :\n    f (sInf s) = sInf (f '' s) :=\n  hf.orderDual.map_csSup sne sbdd\n\n"}
{"name":"RightOrdContinuous.map_ciInf","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\nι : Sort x\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : Nonempty ι\nf : α → β\nhf : RightOrdContinuous f\ng : ι → α\nhg : BddBelow (Set.range g)\n⊢ Eq (f (iInf fun i => g i)) (iInf fun i => f (g i))","decl":"theorem map_ciInf (hf : RightOrdContinuous f) {g : ι → α} (hg : BddBelow (range g)) :\n    f (⨅ i, g i) = ⨅ i, f (g i) :=\n  hf.orderDual.map_ciSup hg\n\n"}
{"name":"OrderIso.leftOrdContinuous","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ LeftOrdContinuous ⇑e","decl":"protected theorem leftOrdContinuous : LeftOrdContinuous e := fun _ _ hx =>\n  ⟨Monotone.mem_upperBounds_image (fun _ _ => e.map_rel_iff.2) hx.1, fun _ hy =>\n    e.rel_symm_apply.1 <|\n      (isLUB_le_iff hx).2 fun _ hx' => e.rel_symm_apply.2 <| hy <| mem_image_of_mem _ hx'⟩\n\n"}
{"name":"OrderIso.rightOrdContinuous","module":"Mathlib.Order.OrdContinuous","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ RightOrdContinuous ⇑e","decl":"protected theorem rightOrdContinuous : RightOrdContinuous e :=\n  OrderIso.leftOrdContinuous e.dual\n\n"}
