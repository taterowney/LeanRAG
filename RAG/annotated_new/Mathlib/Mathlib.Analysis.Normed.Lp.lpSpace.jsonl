{"name":"memℓp_zero_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\n⊢ Iff (Memℓp f 0) (setOf fun i => Ne (f i) 0).Finite","decl":"theorem memℓp_zero_iff {f : ∀ i, E i} : Memℓp f 0 ↔ Set.Finite { i | f i ≠ 0 } := by\n  dsimp [Memℓp]\n  rw [if_pos rfl]\n\n"}
{"name":"memℓp_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : (setOf fun i => Ne (f i) 0).Finite\n⊢ Memℓp f 0","decl":"theorem memℓp_zero {f : ∀ i, E i} (hf : Set.Finite { i | f i ≠ 0 }) : Memℓp f 0 :=\n  memℓp_zero_iff.2 hf\n\n"}
{"name":"memℓp_infty_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\n⊢ Iff (Memℓp f Top.top) (BddAbove (Set.range fun i => Norm.norm (f i)))","decl":"theorem memℓp_infty_iff {f : ∀ i, E i} : Memℓp f ∞ ↔ BddAbove (Set.range fun i => ‖f i‖) := by\n  simp [Memℓp]\n\n"}
{"name":"memℓp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : BddAbove (Set.range fun i => Norm.norm (f i))\n⊢ Memℓp f Top.top","decl":"theorem memℓp_infty {f : ∀ i, E i} (hf : BddAbove (Set.range fun i => ‖f i‖)) : Memℓp f ∞ :=\n  memℓp_infty_iff.2 hf\n\n"}
{"name":"memℓp_gen_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : (i : α) → E i\n⊢ Iff (Memℓp f p) (Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal)","decl":"theorem memℓp_gen_iff (hp : 0 < p.toReal) {f : ∀ i, E i} :\n    Memℓp f p ↔ Summable fun i => ‖f i‖ ^ p.toReal := by\n  rw [ENNReal.toReal_pos_iff] at hp\n  dsimp [Memℓp]\n  rw [if_neg hp.1.ne', if_neg hp.2.ne]\n\n"}
{"name":"memℓp_gen","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal\n⊢ Memℓp f p","decl":"theorem memℓp_gen {f : ∀ i, E i} (hf : Summable fun i => ‖f i‖ ^ p.toReal) : Memℓp f p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    have H : Summable fun _ : α => (1 : ℝ) := by simpa using hf\n    exact (Set.Finite.of_summable_const (by norm_num) H).subset (Set.subset_univ _)\n  · apply memℓp_infty\n    have H : Summable fun _ : α => (1 : ℝ) := by simpa using hf\n    simpa using ((Set.Finite.of_summable_const (by norm_num) H).image fun i => ‖f i‖).bddAbove\n  exact (memℓp_gen_iff hp).2 hf\n\n"}
{"name":"memℓp_gen'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nC : Real\nf : (i : α) → E i\nhf : ∀ (s : Finset α), LE.le (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) C\n⊢ Memℓp f p","decl":"theorem memℓp_gen' {C : ℝ} {f : ∀ i, E i} (hf : ∀ s : Finset α, ∑ i ∈ s, ‖f i‖ ^ p.toReal ≤ C) :\n    Memℓp f p := by\n  apply memℓp_gen\n  use ⨆ s : Finset α, ∑ i ∈ s, ‖f i‖ ^ p.toReal\n  apply hasSum_of_isLUB_of_nonneg\n  · intro b\n    exact Real.rpow_nonneg (norm_nonneg _) _\n  apply isLUB_ciSup\n  use C\n  rintro - ⟨s, rfl⟩\n  exact hf s\n\n"}
{"name":"zero_memℓp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n⊢ Memℓp 0 p","decl":"theorem zero_memℓp : Memℓp (0 : ∀ i, E i) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    simp\n  · apply memℓp_infty\n    simp only [norm_zero, Pi.zero_apply]\n    exact bddAbove_singleton.mono Set.range_const_subset\n  · apply memℓp_gen\n    simp [Real.zero_rpow hp.ne', summable_zero]\n\n"}
{"name":"zero_mem_ℓp'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n⊢ Memℓp (fun i => 0) p","decl":"theorem zero_mem_ℓp' : Memℓp (fun i : α => (0 : E i)) p :=\n  zero_memℓp\n\n"}
{"name":"Memℓp.finite_dsupport","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : Memℓp f 0\n⊢ (setOf fun i => Ne (f i) 0).Finite","decl":"theorem finite_dsupport {f : ∀ i, E i} (hf : Memℓp f 0) : Set.Finite { i | f i ≠ 0 } :=\n  memℓp_zero_iff.1 hf\n\n"}
{"name":"Memℓp.bddAbove","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : Memℓp f Top.top\n⊢ BddAbove (Set.range fun i => Norm.norm (f i))","decl":"theorem bddAbove {f : ∀ i, E i} (hf : Memℓp f ∞) : BddAbove (Set.range fun i => ‖f i‖) :=\n  memℓp_infty_iff.1 hf\n\n"}
{"name":"Memℓp.summable","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : (i : α) → E i\nhf : Memℓp f p\n⊢ Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal","decl":"theorem summable (hp : 0 < p.toReal) {f : ∀ i, E i} (hf : Memℓp f p) :\n    Summable fun i => ‖f i‖ ^ p.toReal :=\n  (memℓp_gen_iff hp).1 hf\n\n"}
{"name":"Memℓp.neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\nhf : Memℓp f p\n⊢ Memℓp (Neg.neg f) p","decl":"theorem neg {f : ∀ i, E i} (hf : Memℓp f p) : Memℓp (-f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    simp [hf.finite_dsupport]\n  · apply memℓp_infty\n    simpa using hf.bddAbove\n  · apply memℓp_gen\n    simpa using hf.summable hp\n\n"}
{"name":"Memℓp.neg_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : (i : α) → E i\n⊢ Iff (Memℓp (Neg.neg f) p) (Memℓp f p)","decl":"@[simp]\ntheorem neg_iff {f : ∀ i, E i} : Memℓp (-f) p ↔ Memℓp f p :=\n  ⟨fun h => neg_neg f ▸ h.neg, Memℓp.neg⟩\n\n"}
{"name":"Memℓp.of_exponent_ge","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\np q : ENNReal\nf : (i : α) → E i\nhfq : Memℓp f q\nhpq : LE.le q p\n⊢ Memℓp f p","decl":"theorem of_exponent_ge {p q : ℝ≥0∞} {f : ∀ i, E i} (hfq : Memℓp f q) (hpq : q ≤ p) : Memℓp f p := by\n  rcases ENNReal.trichotomy₂ hpq with\n    (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩ | ⟨rfl, hp⟩ | ⟨rfl, rfl⟩ | ⟨hq, rfl⟩ | ⟨hq, _, hpq'⟩)\n  · exact hfq\n  · apply memℓp_infty\n    obtain ⟨C, hC⟩ := (hfq.finite_dsupport.image fun i => ‖f i‖).bddAbove\n    use max 0 C\n    rintro x ⟨i, rfl⟩\n    by_cases hi : f i = 0\n    · simp [hi]\n    · exact (hC ⟨i, hi, rfl⟩).trans (le_max_right _ _)\n  · apply memℓp_gen\n    have : ∀ i ∉ hfq.finite_dsupport.toFinset, ‖f i‖ ^ p.toReal = 0 := by\n      intro i hi\n      have : f i = 0 := by simpa using hi\n      simp [this, Real.zero_rpow hp.ne']\n    exact summable_of_ne_finset_zero this\n  · exact hfq\n  · apply memℓp_infty\n    obtain ⟨A, hA⟩ := (hfq.summable hq).tendsto_cofinite_zero.bddAbove_range_of_cofinite\n    use A ^ q.toReal⁻¹\n    rintro x ⟨i, rfl⟩\n    have : 0 ≤ ‖f i‖ ^ q.toReal := by positivity\n    simpa [← Real.rpow_mul, mul_inv_cancel₀ hq.ne'] using\n      Real.rpow_le_rpow this (hA ⟨i, rfl⟩) (inv_nonneg.mpr hq.le)\n  · apply memℓp_gen\n    have hf' := hfq.summable hq\n    refine .of_norm_bounded_eventually _ hf' (@Set.Finite.subset _ { i | 1 ≤ ‖f i‖ } ?_ _ ?_)\n    · have H : { x : α | 1 ≤ ‖f x‖ ^ q.toReal }.Finite := by\n        simpa using hf'.tendsto_cofinite_zero.eventually_lt_const (by norm_num)\n      exact H.subset fun i hi => Real.one_le_rpow hi hq.le\n    · show ∀ i, ¬|‖f i‖ ^ p.toReal| ≤ ‖f i‖ ^ q.toReal → 1 ≤ ‖f i‖\n      intro i hi\n      have : 0 ≤ ‖f i‖ ^ p.toReal := Real.rpow_nonneg (norm_nonneg _) p.toReal\n      simp only [abs_of_nonneg, this] at hi\n      contrapose! hi\n      exact Real.rpow_le_rpow_of_exponent_ge' (norm_nonneg _) hi.le hq.le hpq'\n\n"}
{"name":"Memℓp.add","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : (i : α) → E i\nhf : Memℓp f p\nhg : Memℓp g p\n⊢ Memℓp (HAdd.hAdd f g) p","decl":"theorem add {f g : ∀ i, E i} (hf : Memℓp f p) (hg : Memℓp g p) : Memℓp (f + g) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    refine (hf.finite_dsupport.union hg.finite_dsupport).subset fun i => ?_\n    simp only [Pi.add_apply, Ne, Set.mem_union, Set.mem_setOf_eq]\n    contrapose!\n    rintro ⟨hf', hg'⟩\n    simp [hf', hg']\n  · apply memℓp_infty\n    obtain ⟨A, hA⟩ := hf.bddAbove\n    obtain ⟨B, hB⟩ := hg.bddAbove\n    refine ⟨A + B, ?_⟩\n    rintro a ⟨i, rfl⟩\n    exact le_trans (norm_add_le _ _) (add_le_add (hA ⟨i, rfl⟩) (hB ⟨i, rfl⟩))\n  apply memℓp_gen\n  let C : ℝ := if p.toReal < 1 then 1 else (2 : ℝ) ^ (p.toReal - 1)\n  refine .of_nonneg_of_le ?_ (fun i => ?_) (((hf.summable hp).add (hg.summable hp)).mul_left C)\n  · intro; positivity\n  · refine (Real.rpow_le_rpow (norm_nonneg _) (norm_add_le _ _) hp.le).trans ?_\n    dsimp only [C]\n    split_ifs with h\n    · simpa using NNReal.coe_le_coe.2 (NNReal.rpow_add_le_add_rpow ‖f i‖₊ ‖g i‖₊ hp.le h.le)\n    · let F : Fin 2 → ℝ≥0 := ![‖f i‖₊, ‖g i‖₊]\n      simp only [not_lt] at h\n      simpa [Fin.sum_univ_succ] using\n        Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg Finset.univ h fun i _ => (F i).coe_nonneg\n\n"}
{"name":"Memℓp.sub","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : (i : α) → E i\nhf : Memℓp f p\nhg : Memℓp g p\n⊢ Memℓp (HSub.hSub f g) p","decl":"theorem sub {f g : ∀ i, E i} (hf : Memℓp f p) (hg : Memℓp g p) : Memℓp (f - g) p := by\n  rw [sub_eq_add_neg]; exact hf.add hg.neg\n\n"}
{"name":"Memℓp.finset_sum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\ns : Finset ι\nf : ι → (i : α) → E i\nhf : ∀ (i : ι), Membership.mem s i → Memℓp (f i) p\n⊢ Memℓp (fun a => s.sum fun i => f i a) p","decl":"theorem finset_sum {ι} (s : Finset ι) {f : ι → ∀ i, E i} (hf : ∀ i ∈ s, Memℓp (f i) p) :\n    Memℓp (fun a => ∑ i ∈ s, f i a) p := by\n  haveI : DecidableEq ι := Classical.decEq _\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  · simp only [zero_mem_ℓp', Finset.sum_empty, imp_true_iff]\n  · intro i s his ih hf\n    simp only [his, Finset.sum_insert, not_false_iff]\n    exact (hf i (s.mem_insert_self i)).add (ih fun j hj => hf j (Finset.mem_insert_of_mem hj))\n\n"}
{"name":"Memℓp.const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\nf : (i : α) → E i\nhf : Memℓp f p\nc : 𝕜\n⊢ Memℓp (HSMul.hSMul c f) p","decl":"theorem const_smul {f : ∀ i, E i} (hf : Memℓp f p) (c : 𝕜) : Memℓp (c • f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    refine hf.finite_dsupport.subset fun i => (?_ : ¬c • f i = 0 → ¬f i = 0)\n    exact not_imp_not.mpr fun hf' => hf'.symm ▸ smul_zero c\n  · obtain ⟨A, hA⟩ := hf.bddAbove\n    refine memℓp_infty ⟨‖c‖ * A, ?_⟩\n    rintro a ⟨i, rfl⟩\n    dsimp only [Pi.smul_apply]\n    refine (norm_smul_le _ _).trans ?_\n    gcongr\n    exact hA ⟨i, rfl⟩\n  · apply memℓp_gen\n    dsimp only [Pi.smul_apply]\n    have := (hf.summable hp).mul_left (↑(‖c‖₊ ^ p.toReal) : ℝ)\n    simp_rw [← coe_nnnorm, ← NNReal.coe_rpow, ← NNReal.coe_mul, NNReal.summable_coe,\n      ← NNReal.mul_rpow] at this ⊢\n    refine NNReal.summable_of_le ?_ this\n    intro i\n    gcongr\n    apply nnnorm_smul_le\n\n"}
{"name":"Memℓp.const_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\np : ENNReal\n𝕜 : Type u_3\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nhf : Memℓp f p\nc : 𝕜\n⊢ Memℓp (fun x => HMul.hMul c (f x)) p","decl":"theorem const_mul {f : α → 𝕜} (hf : Memℓp f p) (c : 𝕜) : Memℓp (fun x => c * f x) p :=\n  @Memℓp.const_smul α (fun _ => 𝕜) _ _ 𝕜 _ _ (fun i => by infer_instance) _ hf c\n\n"}
{"name":"lp.ext","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\nh : Eq ↑f ↑g\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : lp E p} (h : (f : ∀ i, E i) = g) : f = g :=\n  Subtype.ext h\n\n"}
{"name":"lp.ext_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n⊢ Iff (Eq f g) (Eq ↑f ↑g)","decl":"@[ext]\ntheorem ext {f g : lp E p} (h : (f : ∀ i, E i) = g) : f = g :=\n  Subtype.ext h\n\n"}
{"name":"lp.eq_zero'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : IsEmpty α\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq f 0","decl":"theorem eq_zero' [IsEmpty α] (f : lp E p) : f = 0 :=\n  Subsingleton.elim f 0\n\n"}
{"name":"lp.monotone","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\np q : ENNReal\nhpq : LE.le q p\n⊢ LE.le (lp E q) (lp E p)","decl":"protected theorem monotone {p q : ℝ≥0∞} (hpq : q ≤ p) : lp E q ≤ lp E p :=\n  fun _ hf => Memℓp.of_exponent_ge hf hpq\n\n"}
{"name":"lp.memℓp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Memℓp (↑f) p","decl":"protected theorem memℓp (f : lp E p) : Memℓp f p :=\n  f.prop\n\n"}
{"name":"lp.coeFn_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n⊢ Eq (↑0) 0","decl":"@[simp]\ntheorem coeFn_zero : ⇑(0 : lp E p) = 0 :=\n  rfl\n\n"}
{"name":"lp.coeFn_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (↑(Neg.neg f)) (Neg.neg ↑f)","decl":"@[simp]\ntheorem coeFn_neg (f : lp E p) : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"lp.coeFn_add","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (↑(HAdd.hAdd f g)) (HAdd.hAdd ↑f ↑g)","decl":"@[simp]\ntheorem coeFn_add (f g : lp E p) : ⇑(f + g) = f + g :=\n  rfl\n\n"}
{"name":"lp.coeFn_sum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\nf : ι → Subtype fun x => Membership.mem (lp E p) x\ns : Finset ι\n⊢ Eq (↑(s.sum fun i => f i)) (s.sum fun i => ↑(f i))","decl":"theorem coeFn_sum {ι : Type*} (f : ι → lp E p) (s : Finset ι) :\n    ⇑(∑ i ∈ s, f i) = ∑ i ∈ s, ⇑(f i) := by\n  simp\n\n"}
{"name":"lp.coeFn_sub","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (↑(HSub.hSub f g)) (HSub.hSub ↑f ↑g)","decl":"@[simp]\ntheorem coeFn_sub (f g : lp E p) : ⇑(f - g) = f - g :=\n  rfl\n\n"}
{"name":"lp.norm_eq_card_dsupport","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E 0) x\n⊢ Eq (Norm.norm f) ↑⋯.toFinset.card","decl":"theorem norm_eq_card_dsupport (f : lp E 0) : ‖f‖ = (lp.memℓp f).finite_dsupport.toFinset.card :=\n  dif_pos rfl\n\n"}
{"name":"lp.norm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E Top.top) x\n⊢ Eq (Norm.norm f) (iSup fun i => Norm.norm (↑f i))","decl":"theorem norm_eq_ciSup (f : lp E ∞) : ‖f‖ = ⨆ i, ‖f i‖ := rfl\n\n"}
{"name":"lp.isLUB_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : Nonempty α\nf : Subtype fun x => Membership.mem (lp E Top.top) x\n⊢ IsLUB (Set.range fun i => Norm.norm (↑f i)) (Norm.norm f)","decl":"theorem isLUB_norm [Nonempty α] (f : lp E ∞) : IsLUB (Set.range fun i => ‖f i‖) ‖f‖ := by\n  rw [lp.norm_eq_ciSup]\n  exact isLUB_ciSup (lp.memℓp f)\n\n"}
{"name":"lp.norm_eq_tsum_rpow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (Norm.norm f) (HPow.hPow (tsum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem norm_eq_tsum_rpow (hp : 0 < p.toReal) (f : lp E p) :\n    ‖f‖ = (∑' i, ‖f i‖ ^ p.toReal) ^ (1 / p.toReal) := by\n  dsimp [norm]\n  rw [ENNReal.toReal_pos_iff] at hp\n  rw [dif_neg hp.1.ne', if_neg hp.2.ne]\n\n"}
{"name":"lp.norm_rpow_eq_tsum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (HPow.hPow (Norm.norm f) p.toReal) (tsum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal)","decl":"theorem norm_rpow_eq_tsum (hp : 0 < p.toReal) (f : lp E p) :\n    ‖f‖ ^ p.toReal = ∑' i, ‖f i‖ ^ p.toReal := by\n  rw [norm_eq_tsum_rpow hp, ← Real.rpow_mul]\n  · field_simp\n  apply tsum_nonneg\n  intro i\n  calc\n    (0 : ℝ) = (0 : ℝ) ^ p.toReal := by rw [Real.zero_rpow hp.ne']\n    _ ≤ _ := by gcongr; apply norm_nonneg\n\n"}
{"name":"lp.hasSum_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ HasSum (fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal) (HPow.hPow (Norm.norm f) p.toReal)","decl":"theorem hasSum_norm (hp : 0 < p.toReal) (f : lp E p) :\n    HasSum (fun i => ‖f i‖ ^ p.toReal) (‖f‖ ^ p.toReal) := by\n  rw [norm_rpow_eq_tsum hp]\n  exact ((lp.memℓp f).summable hp).hasSum\n\n"}
{"name":"lp.norm_nonneg'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ LE.le 0 (Norm.norm f)","decl":"theorem norm_nonneg' (f : lp E p) : 0 ≤ ‖f‖ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · simp [lp.norm_eq_card_dsupport f]\n  · cases' isEmpty_or_nonempty α with _i _i\n    · rw [lp.norm_eq_ciSup]\n      simp [Real.iSup_of_isEmpty]\n    inhabit α\n    exact (norm_nonneg (f default)).trans ((lp.isLUB_norm f).1 ⟨default, rfl⟩)\n  · rw [lp.norm_eq_tsum_rpow hp f]\n    refine Real.rpow_nonneg (tsum_nonneg ?_) _\n    exact fun i => Real.rpow_nonneg (norm_nonneg _) _\n\n"}
{"name":"lp.norm_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n⊢ Eq (Norm.norm 0) 0","decl":"@[simp]\ntheorem norm_zero : ‖(0 : lp E p)‖ = 0 := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · simp [lp.norm_eq_card_dsupport]\n  · simp [lp.norm_eq_ciSup]\n  · rw [lp.norm_eq_tsum_rpow hp]\n    have hp' : 1 / p.toReal ≠ 0 := one_div_ne_zero hp.ne'\n    simpa [Real.zero_rpow hp.ne'] using Real.zero_rpow hp'\n\n"}
{"name":"lp.norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"theorem norm_eq_zero_iff {f : lp E p} : ‖f‖ = 0 ↔ f = 0 := by\n  refine ⟨fun h => ?_, by rintro rfl; exact norm_zero⟩\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · ext i\n    have : { i : α | ¬f i = 0 } = ∅ := by simpa [lp.norm_eq_card_dsupport f] using h\n    have : (¬f i = 0) = False := congr_fun this i\n    tauto\n  · cases' isEmpty_or_nonempty α with _i _i\n    · simp [eq_iff_true_of_subsingleton]\n    have H : IsLUB (Set.range fun i => ‖f i‖) 0 := by simpa [h] using lp.isLUB_norm f\n    ext i\n    have : ‖f i‖ = 0 := le_antisymm (H.1 ⟨i, rfl⟩) (norm_nonneg _)\n    simpa using this\n  · have hf : HasSum (fun i : α => ‖f i‖ ^ p.toReal) 0 := by\n      have := lp.hasSum_norm hp f\n      rwa [h, Real.zero_rpow hp.ne'] at this\n    have : ∀ i, 0 ≤ ‖f i‖ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n    rw [hasSum_zero_iff_of_nonneg this] at hf\n    ext i\n    have : f i = 0 ∧ p.toReal ≠ 0 := by\n      simpa [Real.rpow_eq_zero_iff_of_nonneg (norm_nonneg (f i))] using congr_fun hf i\n    exact this.1\n\n"}
{"name":"lp.eq_zero_iff_coeFn_eq_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Iff (Eq f 0) (Eq (↑f) 0)","decl":"theorem eq_zero_iff_coeFn_eq_zero {f : lp E p} : f = 0 ↔ ⇑f = 0 := by\n  rw [lp.ext_iff, coeFn_zero]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): this was very slow, so I squeezed the `simp` calls\n"}
{"name":"lp.norm_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_neg ⦃f : lp E p⦄ : ‖-f‖ = ‖f‖ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · simp only [norm_eq_card_dsupport, coeFn_neg, Pi.neg_apply, ne_eq, neg_eq_zero]\n  · cases isEmpty_or_nonempty α\n    · simp only [lp.eq_zero' f, neg_zero, norm_zero]\n    apply (lp.isLUB_norm (-f)).unique\n    simpa only [coeFn_neg, Pi.neg_apply, norm_neg] using lp.isLUB_norm f\n  · suffices ‖-f‖ ^ p.toReal = ‖f‖ ^ p.toReal by\n      exact Real.rpow_left_injOn hp.ne' (norm_nonneg' _) (norm_nonneg' _) this\n    apply (lp.hasSum_norm hp (-f)).unique\n    simpa only [coeFn_neg, Pi.neg_apply, _root_.norm_neg] using lp.hasSum_norm hp f\n\n"}
{"name":"lp.tsum_mul_le_mul_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n⊢ And (Summable fun i => HMul.hMul (Norm.norm (↑f i)) (Norm.norm (↑g i))) (LE.le (tsum fun i => HMul.hMul (Norm.norm (↑f i)) (Norm.norm (↑g i))) (HMul.hMul (Norm.norm f) (Norm.norm g)))","decl":"/-- Hölder inequality -/\nprotected theorem tsum_mul_le_mul_norm {p q : ℝ≥0∞} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) :\n    (Summable fun i => ‖f i‖ * ‖g i‖) ∧ ∑' i, ‖f i‖ * ‖g i‖ ≤ ‖f‖ * ‖g‖ := by\n  have hf₁ : ∀ i, 0 ≤ ‖f i‖ := fun i => norm_nonneg _\n  have hg₁ : ∀ i, 0 ≤ ‖g i‖ := fun i => norm_nonneg _\n  have hf₂ := lp.hasSum_norm hpq.pos f\n  have hg₂ := lp.hasSum_norm hpq.symm.pos g\n  obtain ⟨C, -, hC', hC⟩ :=\n    Real.inner_le_Lp_mul_Lq_hasSum_of_nonneg hpq (norm_nonneg' _) (norm_nonneg' _) hf₁ hg₁ hf₂ hg₂\n  rw [← hC.tsum_eq] at hC'\n  exact ⟨hC.summable, hC'⟩\n\n"}
{"name":"lp.summable_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n⊢ Summable fun i => HMul.hMul (Norm.norm (↑f i)) (Norm.norm (↑g i))","decl":"protected theorem summable_mul {p q : ℝ≥0∞} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) : Summable fun i => ‖f i‖ * ‖g i‖ :=\n  (lp.tsum_mul_le_mul_norm hpq f g).1\n\n"}
{"name":"lp.tsum_mul_le_mul_norm'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n⊢ LE.le (tsum fun i => HMul.hMul (Norm.norm (↑f i)) (Norm.norm (↑g i))) (HMul.hMul (Norm.norm f) (Norm.norm g))","decl":"protected theorem tsum_mul_le_mul_norm' {p q : ℝ≥0∞} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) : ∑' i, ‖f i‖ * ‖g i‖ ≤ ‖f‖ * ‖g‖ :=\n  (lp.tsum_mul_le_mul_norm hpq f g).2\n\n"}
{"name":"lp.norm_apply_le_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : Ne p 0\nf : Subtype fun x => Membership.mem (lp E p) x\ni : α\n⊢ LE.le (Norm.norm (↑f i)) (Norm.norm f)","decl":"theorem norm_apply_le_norm (hp : p ≠ 0) (f : lp E p) (i : α) : ‖f i‖ ≤ ‖f‖ := by\n  rcases eq_or_ne p ∞ with (rfl | hp')\n  · haveI : Nonempty α := ⟨i⟩\n    exact (isLUB_norm f).1 ⟨i, rfl⟩\n  have hp'' : 0 < p.toReal := ENNReal.toReal_pos hp hp'\n  have : ∀ i, 0 ≤ ‖f i‖ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n  rw [← Real.rpow_le_rpow_iff (norm_nonneg _) (norm_nonneg' _) hp'']\n  convert le_hasSum (hasSum_norm hp'' f) i fun i _ => this i\n\n"}
{"name":"lp.sum_rpow_le_norm_rpow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset α\n⊢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal) (HPow.hPow (Norm.norm f) p.toReal)","decl":"theorem sum_rpow_le_norm_rpow (hp : 0 < p.toReal) (f : lp E p) (s : Finset α) :\n    ∑ i ∈ s, ‖f i‖ ^ p.toReal ≤ ‖f‖ ^ p.toReal := by\n  rw [lp.norm_rpow_eq_tsum hp f]\n  have : ∀ i, 0 ≤ ‖f i‖ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n  refine sum_le_tsum _ (fun i _ => this i) ?_\n  exact (lp.memℓp f).summable hp\n\n"}
{"name":"lp.norm_le_of_forall_le'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : Nonempty α\nf : Subtype fun x => Membership.mem (lp E Top.top) x\nC : Real\nhCf : ∀ (i : α), LE.le (Norm.norm (↑f i)) C\n⊢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_le' [Nonempty α] {f : lp E ∞} (C : ℝ) (hCf : ∀ i, ‖f i‖ ≤ C) :\n    ‖f‖ ≤ C := by\n  refine (isLUB_norm f).2 ?_\n  rintro - ⟨i, rfl⟩\n  exact hCf i\n\n"}
{"name":"lp.norm_le_of_forall_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E Top.top) x\nC : Real\nhC : LE.le 0 C\nhCf : ∀ (i : α), LE.le (Norm.norm (↑f i)) C\n⊢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_le {f : lp E ∞} {C : ℝ} (hC : 0 ≤ C) (hCf : ∀ i, ‖f i‖ ≤ C) :\n    ‖f‖ ≤ C := by\n  cases isEmpty_or_nonempty α\n  · simpa [eq_zero' f] using hC\n  · exact norm_le_of_forall_le' C hCf\n\n"}
{"name":"lp.norm_le_of_tsum_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nC : Real\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : LE.le (tsum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal) (HPow.hPow C p.toReal)\n⊢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_tsum_le (hp : 0 < p.toReal) {C : ℝ} (hC : 0 ≤ C) {f : lp E p}\n    (hf : ∑' i, ‖f i‖ ^ p.toReal ≤ C ^ p.toReal) : ‖f‖ ≤ C := by\n  rw [← Real.rpow_le_rpow_iff (norm_nonneg' _) hC hp, norm_rpow_eq_tsum hp]\n  exact hf\n\n"}
{"name":"lp.norm_le_of_forall_sum_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nC : Real\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : ∀ (s : Finset α), LE.le (s.sum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal) (HPow.hPow C p.toReal)\n⊢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_sum_le (hp : 0 < p.toReal) {C : ℝ} (hC : 0 ≤ C) {f : lp E p}\n    (hf : ∀ s : Finset α, ∑ i ∈ s, ‖f i‖ ^ p.toReal ≤ C ^ p.toReal) : ‖f‖ ≤ C :=\n  norm_le_of_tsum_le hp hC (tsum_le_of_sum_le ((lp.memℓp f).summable hp) hf)\n\n"}
{"name":"lp.instSMulCommClassPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝⁵ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\n𝕜' : Type u_4\ninst✝⁴ : NormedRing 𝕜\ninst✝³ : NormedRing 𝕜'\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : (i : α) → Module 𝕜' (E i)\ninst✝ : ∀ (i : α), SMulCommClass 𝕜' 𝕜 (E i)\n⊢ SMulCommClass 𝕜' 𝕜 (PreLp E)","decl":"instance [∀ i, SMulCommClass 𝕜' 𝕜 (E i)] : SMulCommClass 𝕜' 𝕜 (PreLp E) :=\n  Pi.smulCommClass\n\n"}
{"name":"lp.instIsScalarTowerPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝⁶ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\n𝕜' : Type u_4\ninst✝⁵ : NormedRing 𝕜\ninst✝⁴ : NormedRing 𝕜'\ninst✝³ : (i : α) → Module 𝕜 (E i)\ninst✝² : (i : α) → Module 𝕜' (E i)\ninst✝¹ : SMul 𝕜' 𝕜\ninst✝ : ∀ (i : α), IsScalarTower 𝕜' 𝕜 (E i)\n⊢ IsScalarTower 𝕜' 𝕜 (PreLp E)","decl":"instance [SMul 𝕜' 𝕜] [∀ i, IsScalarTower 𝕜' 𝕜 (E i)] : IsScalarTower 𝕜' 𝕜 (PreLp E) :=\n  Pi.isScalarTower\n\n"}
{"name":"lp.instIsCentralScalarPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝⁴ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : (i : α) → Module (MulOpposite 𝕜) (E i)\ninst✝ : ∀ (i : α), IsCentralScalar 𝕜 (E i)\n⊢ IsCentralScalar 𝕜 (PreLp E)","decl":"instance [∀ i, Module 𝕜ᵐᵒᵖ (E i)] [∀ i, IsCentralScalar 𝕜 (E i)] : IsCentralScalar 𝕜 (PreLp E) :=\n  Pi.isCentralScalar\n\n"}
{"name":"lp.mem_lp_const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\nc : 𝕜\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Membership.mem (lp E p) (HSMul.hSMul c ↑f)","decl":"theorem mem_lp_const_smul (c : 𝕜) (f : lp E p) : c • (f : PreLp E) ∈ lp E p :=\n  (lp.memℓp f).const_smul c\n\n"}
{"name":"lp.coe_lpSubmodule","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\n⊢ Eq (lpSubmodule E p 𝕜).toAddSubgroup (lp E p)","decl":"theorem coe_lpSubmodule : (lpSubmodule E p 𝕜).toAddSubgroup = lp E p :=\n  rfl\n\n"}
{"name":"lp.coeFn_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\nc : 𝕜\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (↑(HSMul.hSMul c f)) (HSMul.hSMul c ↑f)","decl":"@[simp]\ntheorem coeFn_smul (c : 𝕜) (f : lp E p) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"lp.instSMulCommClassSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝⁵ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\n𝕜' : Type u_4\ninst✝⁴ : NormedRing 𝕜\ninst✝³ : NormedRing 𝕜'\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : (i : α) → Module 𝕜' (E i)\ninst✝ : ∀ (i : α), SMulCommClass 𝕜' 𝕜 (E i)\n⊢ SMulCommClass 𝕜' 𝕜 (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [∀ i, SMulCommClass 𝕜' 𝕜 (E i)] : SMulCommClass 𝕜' 𝕜 (lp E p) :=\n  ⟨fun _ _ _ => Subtype.ext <| smul_comm _ _ _⟩\n\n"}
{"name":"lp.instIsScalarTowerSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝⁶ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\n𝕜' : Type u_4\ninst✝⁵ : NormedRing 𝕜\ninst✝⁴ : NormedRing 𝕜'\ninst✝³ : (i : α) → Module 𝕜 (E i)\ninst✝² : (i : α) → Module 𝕜' (E i)\ninst✝¹ : SMul 𝕜' 𝕜\ninst✝ : ∀ (i : α), IsScalarTower 𝕜' 𝕜 (E i)\n⊢ IsScalarTower 𝕜' 𝕜 (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [SMul 𝕜' 𝕜] [∀ i, IsScalarTower 𝕜' 𝕜 (E i)] : IsScalarTower 𝕜' 𝕜 (lp E p) :=\n  ⟨fun _ _ _ => Subtype.ext <| smul_assoc _ _ _⟩\n\n"}
{"name":"lp.instIsCentralScalarSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝⁴ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : (i : α) → Module (MulOpposite 𝕜) (E i)\ninst✝ : ∀ (i : α), IsCentralScalar 𝕜 (E i)\n⊢ IsCentralScalar 𝕜 (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [∀ i, Module 𝕜ᵐᵒᵖ (E i)] [∀ i, IsCentralScalar 𝕜 (E i)] : IsCentralScalar 𝕜 (lp E p) :=\n  ⟨fun _ _ => Subtype.ext <| op_smul_eq_smul _ _⟩\n\n"}
{"name":"lp.norm_const_smul_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\nhp : Ne p 0\nc : 𝕜\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem norm_const_smul_le (hp : p ≠ 0) (c : 𝕜) (f : lp E p) : ‖c • f‖ ≤ ‖c‖ * ‖f‖ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · exact absurd rfl hp\n  · cases isEmpty_or_nonempty α\n    · simp [lp.eq_zero' f]\n    have hcf := lp.isLUB_norm (c • f)\n    have hfc := (lp.isLUB_norm f).mul_left (norm_nonneg c)\n    simp_rw [← Set.range_comp, Function.comp_def] at hfc\n    -- TODO: some `IsLUB` API should make it a one-liner from here.\n    refine hcf.right ?_\n    have := hfc.left\n    simp_rw [mem_upperBounds, Set.mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this ⊢\n    intro a\n    exact (norm_smul_le _ _).trans (this a)\n  · letI inst : NNNorm (lp E p) := ⟨fun f => ⟨‖f‖, norm_nonneg' _⟩⟩\n    have coe_nnnorm : ∀ f : lp E p, ↑‖f‖₊ = ‖f‖ := fun _ => rfl\n    suffices ‖c • f‖₊ ^ p.toReal ≤ (‖c‖₊ * ‖f‖₊) ^ p.toReal by\n      rwa [NNReal.rpow_le_rpow_iff hp] at this\n    clear_value inst\n    rw [NNReal.mul_rpow]\n    have hLHS := lp.hasSum_norm hp (c • f)\n    have hRHS := (lp.hasSum_norm hp f).mul_left (‖c‖ ^ p.toReal)\n    simp_rw [← coe_nnnorm, ← _root_.coe_nnnorm, ← NNReal.coe_rpow, ← NNReal.coe_mul,\n      NNReal.hasSum_coe] at hRHS hLHS\n    refine hasSum_mono hLHS hRHS fun i => ?_\n    dsimp only\n    rw [← NNReal.mul_rpow]\n    -- Porting note: added\n    rw [lp.coeFn_smul, Pi.smul_apply]\n    gcongr\n    apply nnnorm_smul_le\n\n"}
{"name":"lp.instBoundedSMulSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝⁴ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : ∀ (i : α), BoundedSMul 𝕜 (E i)\ninst✝ : Fact (LE.le 1 p)\n⊢ BoundedSMul 𝕜 (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [Fact (1 ≤ p)] : BoundedSMul 𝕜 (lp E p) :=\n  BoundedSMul.of_norm_smul_le <| norm_const_smul_le (zero_lt_one.trans_le <| Fact.out).ne'\n\n"}
{"name":"lp.norm_const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝³ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), BoundedSMul 𝕜 (E i)\nhp : Ne p 0\nc : 𝕜\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem norm_const_smul (hp : p ≠ 0) {c : 𝕜} (f : lp E p) : ‖c • f‖ = ‖c‖ * ‖f‖ := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp\n  refine le_antisymm (norm_const_smul_le hp c f) ?_\n  have := mul_le_mul_of_nonneg_left (norm_const_smul_le hp c⁻¹ (c • f)) (norm_nonneg c)\n  rwa [inv_smul_smul₀ hc, norm_inv, mul_inv_cancel_left₀ (norm_ne_zero_iff.mpr hc)] at this\n\n"}
{"name":"Memℓp.star_mem","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : (i : α) → StarAddMonoid (E i)\ninst✝ : ∀ (i : α), NormedStarGroup (E i)\nf : (i : α) → E i\nhf : Memℓp f p\n⊢ Memℓp (Star.star f) p","decl":"theorem _root_.Memℓp.star_mem {f : ∀ i, E i} (hf : Memℓp f p) : Memℓp (star f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  · apply memℓp_zero\n    simp [hf.finite_dsupport]\n  · apply memℓp_infty\n    simpa using hf.bddAbove\n  · apply memℓp_gen\n    simpa using hf.summable hp\n\n"}
{"name":"Memℓp.star_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : (i : α) → StarAddMonoid (E i)\ninst✝ : ∀ (i : α), NormedStarGroup (E i)\nf : (i : α) → E i\n⊢ Iff (Memℓp (Star.star f) p) (Memℓp f p)","decl":"@[simp]\ntheorem _root_.Memℓp.star_iff {f : ∀ i, E i} : Memℓp (star f) p ↔ Memℓp f p :=\n  ⟨fun h => star_star f ▸ Memℓp.star_mem h, Memℓp.star_mem⟩\n\n"}
{"name":"lp.coeFn_star","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : (i : α) → StarAddMonoid (E i)\ninst✝ : ∀ (i : α), NormedStarGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ Eq (↑(Star.star f)) (Star.star ↑f)","decl":"@[simp]\ntheorem coeFn_star (f : lp E p) : ⇑(star f) = star (⇑f) :=\n  rfl\n\n"}
{"name":"lp.star_apply","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : (i : α) → StarAddMonoid (E i)\ninst✝ : ∀ (i : α), NormedStarGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\ni : α\n⊢ Eq (↑(Star.star f) i) (Star.star (↑f i))","decl":"@[simp]\nprotected theorem star_apply (f : lp E p) (i : α) : star f i = star (f i) :=\n  rfl\n\n"}
{"name":"lp.instNormedStarGroupSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : (i : α) → StarAddMonoid (E i)\ninst✝ : ∀ (i : α), NormedStarGroup (E i)\nhp : Fact (LE.le 1 p)\n⊢ NormedStarGroup (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [hp : Fact (1 ≤ p)] : NormedStarGroup (lp E p) where\n  norm_star f := by\n    rcases p.trichotomy with (rfl | rfl | h)\n    · exfalso\n      have := ENNReal.toReal_mono ENNReal.zero_ne_top hp.elim\n      norm_num at this\n    · simp only [lp.norm_eq_ciSup, lp.star_apply, norm_star]\n    · simp only [lp.norm_eq_tsum_rpow h, lp.star_apply, norm_star]\n\n"}
{"name":"lp.instStarModuleSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝⁶ : (i : α) → NormedAddCommGroup (E i)\ninst✝⁵ : (i : α) → StarAddMonoid (E i)\ninst✝⁴ : ∀ (i : α), NormedStarGroup (E i)\n𝕜 : Type u_3\ninst✝³ : Star 𝕜\ninst✝² : NormedRing 𝕜\ninst✝¹ : (i : α) → Module 𝕜 (E i)\ninst✝ : ∀ (i : α), StarModule 𝕜 (E i)\n⊢ StarModule 𝕜 (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance : StarModule 𝕜 (lp E p) where\n  star_smul _r _f := ext <| star_smul (A := ∀ i, E i) _ _\n\n"}
{"name":"Memℓp.infty_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝ : (i : I) → NonUnitalNormedRing (B i)\nf g : (i : I) → B i\nhf : Memℓp f Top.top\nhg : Memℓp g Top.top\n⊢ Memℓp (HMul.hMul f g) Top.top","decl":"theorem _root_.Memℓp.infty_mul {f g : ∀ i, B i} (hf : Memℓp f ∞) (hg : Memℓp g ∞) :\n    Memℓp (f * g) ∞ := by\n  rw [memℓp_infty_iff]\n  obtain ⟨⟨Cf, hCf⟩, ⟨Cg, hCg⟩⟩ := hf.bddAbove, hg.bddAbove\n  refine ⟨Cf * Cg, ?_⟩\n  rintro _ ⟨i, rfl⟩\n  calc\n    ‖(f * g) i‖ ≤ ‖f i‖ * ‖g i‖ := norm_mul_le (f i) (g i)\n    _ ≤ Cf * Cg :=\n      mul_le_mul (hCf ⟨i, rfl⟩) (hCg ⟨i, rfl⟩) (norm_nonneg _)\n        ((norm_nonneg _).trans (hCf ⟨i, rfl⟩))\n\n"}
{"name":"lp.infty_coeFn_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝ : (i : I) → NonUnitalNormedRing (B i)\nf g : Subtype fun x => Membership.mem (lp B Top.top) x\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[simp]\ntheorem infty_coeFn_mul (f g : lp B ∞) : ⇑(f * g) = ⇑f * ⇑g :=\n  rfl\n\n"}
{"name":"lp.infty_isScalarTower","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝⁴ : (i : I) → NonUnitalNormedRing (B i)\n𝕜 : Type u_5\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : I) → Module 𝕜 (B i)\ninst✝¹ : ∀ (i : I), BoundedSMul 𝕜 (B i)\ninst✝ : ∀ (i : I), IsScalarTower 𝕜 (B i) (B i)\n⊢ IsScalarTower 𝕜 (Subtype fun x => Membership.mem (lp B Top.top) x) (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance infty_isScalarTower {𝕜} [NormedRing 𝕜] [∀ i, Module 𝕜 (B i)] [∀ i, BoundedSMul 𝕜 (B i)]\n    [∀ i, IsScalarTower 𝕜 (B i) (B i)] : IsScalarTower 𝕜 (lp B ∞) (lp B ∞) :=\n  ⟨fun r f g => lp.ext <| smul_assoc (N := ∀ i, B i) (α := ∀ i, B i) r (⇑f) (⇑g)⟩\n\n"}
{"name":"lp.infty_smulCommClass","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝⁴ : (i : I) → NonUnitalNormedRing (B i)\n𝕜 : Type u_5\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : I) → Module 𝕜 (B i)\ninst✝¹ : ∀ (i : I), BoundedSMul 𝕜 (B i)\ninst✝ : ∀ (i : I), SMulCommClass 𝕜 (B i) (B i)\n⊢ SMulCommClass 𝕜 (Subtype fun x => Membership.mem (lp B Top.top) x) (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance infty_smulCommClass {𝕜} [NormedRing 𝕜] [∀ i, Module 𝕜 (B i)] [∀ i, BoundedSMul 𝕜 (B i)]\n    [∀ i, SMulCommClass 𝕜 (B i) (B i)] : SMulCommClass 𝕜 (lp B ∞) (lp B ∞) :=\n  ⟨fun r f g => lp.ext <| smul_comm (N := ∀ i, B i) (α := ∀ i, B i) r (⇑f) (⇑g)⟩\n\n"}
{"name":"lp.inftyCStarRing","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝³ : (i : I) → NonUnitalNormedRing (B i)\ninst✝² : (i : I) → StarRing (B i)\ninst✝¹ : ∀ (i : I), NormedStarGroup (B i)\ninst✝ : ∀ (i : I), CStarRing (B i)\n⊢ CStarRing (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance inftyCStarRing [∀ i, CStarRing (B i)] : CStarRing (lp B ∞) where\n  norm_mul_self_le f := by\n    rw [← sq, ← Real.le_sqrt (norm_nonneg _) (norm_nonneg _)]\n    refine lp.norm_le_of_forall_le ‖star f * f‖.sqrt_nonneg fun i => ?_\n    rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, ← CStarRing.norm_star_mul_self]\n    exact lp.norm_apply_le_norm ENNReal.top_ne_zero (star f * f) i\n\n"}
{"name":"one_memℓp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\n⊢ Memℓp 1 Top.top","decl":"theorem _root_.one_memℓp_infty : Memℓp (1 : ∀ i, B i) ∞ :=\n  ⟨1, by rintro i ⟨i, rfl⟩; exact norm_one.le⟩\n\n"}
{"name":"Memℓp.infty_pow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nf : (i : I) → B i\nhf : Memℓp f Top.top\nn : Nat\n⊢ Memℓp (HPow.hPow f n) Top.top","decl":"theorem _root_.Memℓp.infty_pow {f : ∀ i, B i} (hf : Memℓp f ∞) (n : ℕ) : Memℓp (f ^ n) ∞ :=\n  (lpInftySubring B).pow_mem hf n\n\n"}
{"name":"natCast_memℓp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nn : Nat\n⊢ Memℓp (↑n) Top.top","decl":"theorem _root_.natCast_memℓp_infty (n : ℕ) : Memℓp (n : ∀ i, B i) ∞ :=\n  natCast_mem (lpInftySubring B) n\n\n"}
{"name":"intCast_memℓp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nz : Int\n⊢ Memℓp (↑z) Top.top","decl":"theorem _root_.intCast_memℓp_infty (z : ℤ) : Memℓp (z : ∀ i, B i) ∞ :=\n  intCast_mem (lpInftySubring B) z\n\n"}
{"name":"lp.infty_coeFn_one","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem infty_coeFn_one : ⇑(1 : lp B ∞) = 1 :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_pow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nf : Subtype fun x => Membership.mem (lp B Top.top) x\nn : Nat\n⊢ Eq (↑(HPow.hPow f n)) (HPow.hPow (↑f) n)","decl":"@[simp]\ntheorem infty_coeFn_pow (f : lp B ∞) (n : ℕ) : ⇑(f ^ n) = (⇑f) ^ n :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_natCast","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp]\ntheorem infty_coeFn_natCast (n : ℕ) : ⇑(n : lp B ∞) = n :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_intCast","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝¹ : (i : I) → NormedRing (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nz : Int\n⊢ Eq ↑↑z ↑z","decl":"@[simp]\ntheorem infty_coeFn_intCast (z : ℤ) : ⇑(z : lp B ∞) = z :=\n  rfl\n\n"}
{"name":"lp.instNormOneClassSubtypePreLpMemAddSubgroupTopENNRealOfNonempty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I → Type u_4\ninst✝² : (i : I) → NormedRing (B i)\ninst✝¹ : ∀ (i : I), NormOneClass (B i)\ninst✝ : Nonempty I\n⊢ NormOneClass (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance [Nonempty I] : NormOneClass (lp B ∞) where\n  norm_one := by simp_rw [lp.norm_eq_ciSup, infty_coeFn_one, Pi.one_apply, norm_one, ciSup_const]\n\n"}
{"name":"algebraMap_memℓp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\n𝕜 : Type u_4\nB : I → Type u_5\ninst✝³ : NormedField 𝕜\ninst✝² : (i : I) → NormedRing (B i)\ninst✝¹ : (i : I) → NormedAlgebra 𝕜 (B i)\ninst✝ : ∀ (i : I), NormOneClass (B i)\nk : 𝕜\n⊢ Memℓp ((algebraMap 𝕜 ((i : I) → B i)) k) Top.top","decl":"theorem _root_.algebraMap_memℓp_infty (k : 𝕜) : Memℓp (algebraMap 𝕜 (∀ i, B i) k) ∞ := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  exact (one_memℓp_infty.const_smul k : Memℓp (k • (1 : ∀ i, B i)) ∞)\n\n"}
{"name":"lp.single_apply","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\np : ENNReal\ni : α\na : E i\nj : α\n⊢ Eq (↑(lp.single p i a) j) (dite (Eq j i) (fun h => Eq.ndrec a ⋯) fun h => 0)","decl":"protected theorem single_apply (p) (i : α) (a : E i) (j : α) :\n    lp.single p i a j = if h : j = i then Eq.ndrec a h.symm else 0 :=\n  rfl\n\n"}
{"name":"lp.single_apply_self","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\np : ENNReal\ni : α\na : E i\n⊢ Eq (↑(lp.single p i a) i) a","decl":"protected theorem single_apply_self (p) (i : α) (a : E i) : lp.single p i a i = a := by\n  rw [lp.single_apply, dif_pos rfl]\n\n"}
{"name":"lp.single_apply_ne","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\np : ENNReal\ni : α\na : E i\nj : α\nhij : Ne j i\n⊢ Eq (↑(lp.single p i a) j) 0","decl":"protected theorem single_apply_ne (p) (i : α) (a : E i) {j : α} (hij : j ≠ i) :\n    lp.single p i a j = 0 := by\n  rw [lp.single_apply, dif_neg hij]\n\n"}
{"name":"lp.single_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\np : ENNReal\ni : α\na : E i\n⊢ Eq (lp.single p i (Neg.neg a)) (Neg.neg (lp.single p i a))","decl":"@[simp]\nprotected theorem single_neg (p) (i : α) (a : E i) : lp.single p i (-a) = -lp.single p i a := by\n  refine ext (funext (fun (j : α) => ?_))\n  by_cases hi : j = i\n  · subst hi\n    simp [lp.single_apply_self]\n  · simp [lp.single_apply_ne p i _ hi]\n\n"}
{"name":"lp.single_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝⁴ : (i : α) → NormedAddCommGroup (E i)\n𝕜 : Type u_3\ninst✝³ : NormedRing 𝕜\ninst✝² : (i : α) → Module 𝕜 (E i)\ninst✝¹ : ∀ (i : α), BoundedSMul 𝕜 (E i)\ninst✝ : DecidableEq α\np : ENNReal\ni : α\na : E i\nc : 𝕜\n⊢ Eq (lp.single p i (HSMul.hSMul c a)) (HSMul.hSMul c (lp.single p i a))","decl":"@[simp]\nprotected theorem single_smul (p) (i : α) (a : E i) (c : 𝕜) :\n    lp.single p i (c • a) = c • lp.single p i a := by\n  refine ext (funext (fun (j : α) => ?_))\n  by_cases hi : j = i\n  · subst hi\n    dsimp\n    simp [lp.single_apply_self]\n  · dsimp\n    simp [lp.single_apply_ne p i _ hi]\n\n"}
{"name":"lp.norm_sum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\nhp : LT.lt 0 p.toReal\nf : (i : α) → E i\ns : Finset α\n⊢ Eq (HPow.hPow (Norm.norm (s.sum fun i => lp.single p i (f i))) p.toReal) (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal)","decl":"protected theorem norm_sum_single (hp : 0 < p.toReal) (f : ∀ i, E i) (s : Finset α) :\n    ‖∑ i ∈ s, lp.single p i (f i)‖ ^ p.toReal = ∑ i ∈ s, ‖f i‖ ^ p.toReal := by\n  refine (hasSum_norm hp (∑ i ∈ s, lp.single p i (f i))).unique ?_\n  simp only [lp.single_apply, coeFn_sum, Finset.sum_apply, Finset.sum_dite_eq]\n  have h : ∀ i ∉ s, ‖ite (i ∈ s) (f i) 0‖ ^ p.toReal = 0 := fun i hi ↦ by\n    simp [if_neg hi, Real.zero_rpow hp.ne']\n  have h' : ∀ i ∈ s, ‖f i‖ ^ p.toReal = ‖ite (i ∈ s) (f i) 0‖ ^ p.toReal := by\n    intro i hi\n    rw [if_pos hi]\n  simpa [Finset.sum_congr rfl h'] using hasSum_sum_of_ne_finset_zero h\n\n"}
{"name":"lp.norm_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\nhp : LT.lt 0 p.toReal\nf : (i : α) → E i\ni : α\n⊢ Eq (Norm.norm (lp.single p i (f i))) (Norm.norm (f i))","decl":"protected theorem norm_single (hp : 0 < p.toReal) (f : ∀ i, E i) (i : α) :\n    ‖lp.single p i (f i)‖ = ‖f i‖ := by\n  refine Real.rpow_left_injOn hp.ne' (norm_nonneg' _) (norm_nonneg _) ?_\n  simpa using lp.norm_sum_single hp f {i}\n\n"}
{"name":"lp.norm_sub_norm_compl_sub_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset α\n⊢ Eq (HSub.hSub (HPow.hPow (Norm.norm f) p.toReal) (HPow.hPow (Norm.norm (HSub.hSub f (s.sum fun i => lp.single p i (↑f i)))) p.toReal)) (s.sum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal)","decl":"protected theorem norm_sub_norm_compl_sub_single (hp : 0 < p.toReal) (f : lp E p) (s : Finset α) :\n    ‖f‖ ^ p.toReal - ‖f - ∑ i ∈ s, lp.single p i (f i)‖ ^ p.toReal =\n      ∑ i ∈ s, ‖f i‖ ^ p.toReal := by\n  refine ((hasSum_norm hp f).sub (hasSum_norm hp (f - ∑ i ∈ s, lp.single p i (f i)))).unique ?_\n  let F : α → ℝ := fun i => ‖f i‖ ^ p.toReal - ‖(f - ∑ i ∈ s, lp.single p i (f i)) i‖ ^ p.toReal\n  have hF : ∀ i ∉ s, F i = 0 := by\n    intro i hi\n    suffices ‖f i‖ ^ p.toReal - ‖f i - ite (i ∈ s) (f i) 0‖ ^ p.toReal = 0 by\n      simpa only [F, coeFn_sum, lp.single_apply, coeFn_sub, Pi.sub_apply, Finset.sum_apply,\n        Finset.sum_dite_eq] using this\n    simp only [if_neg hi, sub_zero, sub_self]\n  have hF' : ∀ i ∈ s, F i = ‖f i‖ ^ p.toReal := by\n    intro i hi\n    simp only [F, coeFn_sum, lp.single_apply, if_pos hi, sub_self, eq_self_iff_true, coeFn_sub,\n      Pi.sub_apply, Finset.sum_apply, Finset.sum_dite_eq, sub_eq_self]\n    simp [Real.zero_rpow hp.ne']\n  have : HasSum F (∑ i ∈ s, F i) := hasSum_sum_of_ne_finset_zero hF\n  rwa [Finset.sum_congr rfl hF'] at this\n\n"}
{"name":"lp.norm_compl_sum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\ninst✝ : DecidableEq α\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset α\n⊢ Eq (HPow.hPow (Norm.norm (HSub.hSub f (s.sum fun i => lp.single p i (↑f i)))) p.toReal) (HSub.hSub (HPow.hPow (Norm.norm f) p.toReal) (s.sum fun i => HPow.hPow (Norm.norm (↑f i)) p.toReal))","decl":"protected theorem norm_compl_sum_single (hp : 0 < p.toReal) (f : lp E p) (s : Finset α) :\n    ‖f - ∑ i ∈ s, lp.single p i (f i)‖ ^ p.toReal = ‖f‖ ^ p.toReal - ∑ i ∈ s, ‖f i‖ ^ p.toReal := by\n  linarith [lp.norm_sub_norm_compl_sub_single hp f s]\n\n"}
{"name":"lp.hasSum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝² : (i : α) → NormedAddCommGroup (E i)\ninst✝¹ : DecidableEq α\ninst✝ : Fact (LE.le 1 p)\nhp : Ne p Top.top\nf : Subtype fun x => Membership.mem (lp E p) x\n⊢ HasSum (fun i => lp.single p i (↑f i)) f","decl":"/-- The canonical finitely-supported approximations to an element `f` of `lp` converge to it, in the\n`lp` topology. -/\nprotected theorem hasSum_single [Fact (1 ≤ p)] (hp : p ≠ ⊤) (f : lp E p) :\n    HasSum (fun i : α => lp.single p i (f i : E i)) f := by\n  have hp₀ : 0 < p := zero_lt_one.trans_le Fact.out\n  have hp' : 0 < p.toReal := ENNReal.toReal_pos hp₀.ne' hp\n  have := lp.hasSum_norm hp' f\n  rw [HasSum, Metric.tendsto_nhds] at this ⊢\n  intro ε hε\n  refine (this _ (Real.rpow_pos_of_pos hε p.toReal)).mono ?_\n  intro s hs\n  rw [← Real.rpow_lt_rpow_iff dist_nonneg (le_of_lt hε) hp']\n  rw [dist_comm] at hs\n  simp only [dist_eq_norm, Real.norm_eq_abs] at hs ⊢\n  have H : ‖(∑ i ∈ s, lp.single p i (f i : E i)) - f‖ ^ p.toReal =\n      ‖f‖ ^ p.toReal - ∑ i ∈ s, ‖f i‖ ^ p.toReal := by\n    simpa only [coeFn_neg, Pi.neg_apply, lp.single_neg, Finset.sum_neg_distrib, neg_sub_neg,\n      norm_neg, _root_.norm_neg] using lp.norm_compl_sum_single hp' (-f) s\n  rw [← H] at hs\n  have : |‖(∑ i ∈ s, lp.single p i (f i : E i)) - f‖ ^ p.toReal| =\n      ‖(∑ i ∈ s, lp.single p i (f i : E i)) - f‖ ^ p.toReal := by\n    simp only [Real.abs_rpow_of_nonneg (norm_nonneg _), abs_norm]\n  exact this ▸ hs\n\n"}
{"name":"lp.uniformContinuous_coe","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\n⊢ UniformContinuous Subtype.val","decl":"/-- The coercion from `lp E p` to `∀ i, E i` is uniformly continuous. -/\ntheorem uniformContinuous_coe [_i : Fact (1 ≤ p)] :\n    UniformContinuous (α := lp E p) ((↑) : lp E p → ∀ i, E i) := by\n  have hp : p ≠ 0 := (zero_lt_one.trans_le _i.elim).ne'\n  rw [uniformContinuous_pi]\n  intro i\n  rw [NormedAddCommGroup.uniformity_basis_dist.uniformContinuous_iff\n    NormedAddCommGroup.uniformity_basis_dist]\n  intro ε hε\n  refine ⟨ε, hε, ?_⟩\n  rintro f g (hfg : ‖f - g‖ < ε)\n  have : ‖f i - g i‖ ≤ ‖f - g‖ := norm_apply_le_norm hp (f - g) i\n  exact this.trans_lt hfg\n\n"}
{"name":"lp.norm_apply_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\nl : Filter ι\ninst✝ : l.NeBot\nC : Real\nF : ι → Subtype fun x => Membership.mem (lp E Top.top) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : (a : α) → E a\nhf : Filter.Tendsto (id fun i => ↑(F i)) l (nhds f)\na : α\n⊢ LE.le (Norm.norm (f a)) C","decl":"theorem norm_apply_le_of_tendsto {C : ℝ} {F : ι → lp E ∞} (hCF : ∀ᶠ k in l, ‖F k‖ ≤ C)\n    {f : ∀ a, E a} (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) (a : α) : ‖f a‖ ≤ C := by\n  have : Tendsto (fun k => ‖F k a‖) l (𝓝 ‖f a‖) :=\n    (Tendsto.comp (continuous_apply a).continuousAt hf).norm\n  refine le_of_tendsto this (hCF.mono ?_)\n  intro k hCFk\n  exact (norm_apply_le_norm ENNReal.top_ne_zero (F k) a).trans hCFk\n\n"}
{"name":"lp.sum_rpow_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\nl : Filter ι\ninst✝ : l.NeBot\n_i : Fact (LE.le 1 p)\nhp : Ne p Top.top\nC : Real\nF : ι → Subtype fun x => Membership.mem (lp E p) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : (a : α) → E a\nhf : Filter.Tendsto (id fun i => ↑(F i)) l (nhds f)\ns : Finset α\n⊢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) (HPow.hPow C p.toReal)","decl":"theorem sum_rpow_le_of_tendsto (hp : p ≠ ∞) {C : ℝ} {F : ι → lp E p} (hCF : ∀ᶠ k in l, ‖F k‖ ≤ C)\n    {f : ∀ a, E a} (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) (s : Finset α) :\n    ∑ i ∈ s, ‖f i‖ ^ p.toReal ≤ C ^ p.toReal := by\n  have hp' : p ≠ 0 := (zero_lt_one.trans_le _i.elim).ne'\n  have hp'' : 0 < p.toReal := ENNReal.toReal_pos hp' hp\n  let G : (∀ a, E a) → ℝ := fun f => ∑ a ∈ s, ‖f a‖ ^ p.toReal\n  have hG : Continuous G := by\n    refine continuous_finset_sum s ?_\n    intro a _\n    have : Continuous fun f : ∀ a, E a => f a := continuous_apply a\n    exact this.norm.rpow_const fun _ => Or.inr hp''.le\n  refine le_of_tendsto (hG.continuousAt.tendsto.comp hf) ?_\n  refine hCF.mono ?_\n  intro k hCFk\n  refine (lp.sum_rpow_le_norm_rpow hp'' (F k) s).trans ?_\n  gcongr\n\n"}
{"name":"lp.norm_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\nl : Filter ι\ninst✝ : l.NeBot\n_i : Fact (LE.le 1 p)\nC : Real\nF : ι → Subtype fun x => Membership.mem (lp E p) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : Filter.Tendsto (id fun i => ↑(F i)) l (nhds ↑f)\n⊢ LE.le (Norm.norm f) C","decl":"/-- \"Semicontinuity of the `lp` norm\": If all sufficiently large elements of a sequence in `lp E p`\n have `lp` norm `≤ C`, then the pointwise limit, if it exists, also has `lp` norm `≤ C`. -/\ntheorem norm_le_of_tendsto {C : ℝ} {F : ι → lp E p} (hCF : ∀ᶠ k in l, ‖F k‖ ≤ C) {f : lp E p}\n    (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) : ‖f‖ ≤ C := by\n  obtain ⟨i, hi⟩ := hCF.exists\n  have hC : 0 ≤ C := (norm_nonneg _).trans hi\n  rcases eq_top_or_lt_top p with (rfl | hp)\n  · apply norm_le_of_forall_le hC\n    exact norm_apply_le_of_tendsto hCF hf\n  · have : 0 < p := zero_lt_one.trans_le _i.elim\n    have hp' : 0 < p.toReal := ENNReal.toReal_pos this.ne' hp.ne\n    apply norm_le_of_forall_sum_le hp' hC\n    exact sum_rpow_le_of_tendsto hp.ne hCF hf\n\n"}
{"name":"lp.memℓp_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝¹ : (i : α) → NormedAddCommGroup (E i)\nι : Type u_3\nl : Filter ι\ninst✝ : l.NeBot\n_i : Fact (LE.le 1 p)\nF : ι → Subtype fun x => Membership.mem (lp E p) x\nhF : Bornology.IsBounded (Set.range F)\nf : (a : α) → E a\nhf : Filter.Tendsto (id fun i => ↑(F i)) l (nhds f)\n⊢ Memℓp f p","decl":"/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem memℓp_of_tendsto {F : ι → lp E p} (hF : Bornology.IsBounded (Set.range F)) {f : ∀ a, E a}\n    (hf : Tendsto (id fun i => F i : ι → ∀ a, E a) l (𝓝 f)) : Memℓp f p := by\n  obtain ⟨C, hCF⟩ : ∃ C, ∀ k, ‖F k‖ ≤ C := hF.exists_norm_le.imp fun _ ↦ Set.forall_mem_range.1\n  rcases eq_top_or_lt_top p with (rfl | hp)\n  · apply memℓp_infty\n    use C\n    rintro _ ⟨a, rfl⟩\n    exact norm_apply_le_of_tendsto (Eventually.of_forall hCF) hf a\n  · apply memℓp_gen'\n    exact sum_rpow_le_of_tendsto hp.ne (Eventually.of_forall hCF) hf\n\n"}
{"name":"lp.tendsto_lp_of_tendsto_pi","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\nF : Nat → Subtype fun x => Membership.mem (lp E p) x\nhF : CauchySeq F\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : Filter.Tendsto (id fun i => ↑(F i)) Filter.atTop (nhds ↑f)\n⊢ Filter.Tendsto F Filter.atTop (nhds f)","decl":"/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem tendsto_lp_of_tendsto_pi {F : ℕ → lp E p} (hF : CauchySeq F) {f : lp E p}\n    (hf : Tendsto (id fun i => F i : ℕ → ∀ a, E a) atTop (𝓝 f)) : Tendsto F atTop (𝓝 f) := by\n  rw [Metric.nhds_basis_closedBall.tendsto_right_iff]\n  intro ε hε\n  have hε' : { p : lp E p × lp E p | ‖p.1 - p.2‖ < ε } ∈ uniformity (lp E p) :=\n    NormedAddCommGroup.uniformity_basis_dist.mem_of_mem hε\n  refine (hF.eventually_eventually hε').mono ?_\n  rintro n (hn : ∀ᶠ l in atTop, ‖(fun f => F n - f) (F l)‖ < ε)\n  refine norm_le_of_tendsto (hn.mono fun k hk => hk.le) ?_\n  rw [tendsto_pi_nhds]\n  intro a\n  exact (hf.apply_nhds a).const_sub (F n a)\n\n"}
{"name":"lp.completeSpace","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nE : α → Type u_2\np : ENNReal\ninst✝ : (i : α) → NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\n⊢ CompleteSpace (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance completeSpace : CompleteSpace (lp E p) :=\n  Metric.complete_of_cauchySeq_tendsto (by\n    intro F hF\n    -- A Cauchy sequence in `lp E p` is pointwise convergent; let `f` be the pointwise limit.\n    obtain ⟨f, hf⟩ := cauchySeq_tendsto_of_complete\n      ((uniformContinuous_coe (p := p)).comp_cauchySeq hF)\n    -- Since the Cauchy sequence is bounded, its pointwise limit `f` is in `lp E p`.\n    have hf' : Memℓp f p := memℓp_of_tendsto hF.isBounded_range hf\n    -- And therefore `f` is its limit in the `lp E p` topology as well as pointwise.\n    exact ⟨⟨f, hf'⟩, tendsto_lp_of_tendsto_pi hF hf⟩)\n\n"}
{"name":"LipschitzWith.uniformly_bounded","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : PseudoMetricSpace α\ng : α → ι → Real\nK : NNReal\nhg : ∀ (i : ι), LipschitzWith K fun x => g x i\na₀ : α\nhga₀b : Memℓp (g a₀) Top.top\na : α\n⊢ Memℓp (g a) Top.top","decl":"lemma LipschitzWith.uniformly_bounded [PseudoMetricSpace α] (g : α → ι → ℝ) {K : ℝ≥0}\n    (hg : ∀ i, LipschitzWith K (g · i)) (a₀ : α) (hga₀b : Memℓp (g a₀) ∞) (a : α) :\n    Memℓp (g a) ∞ := by\n  rcases hga₀b with ⟨M, hM⟩\n  use ↑K * dist a a₀ + M\n  rintro - ⟨i, rfl⟩\n  calc\n    |g a i| = |g a i - g a₀ i + g a₀ i| := by simp\n    _ ≤ |g a i - g a₀ i| + |g a₀ i| := abs_add _ _\n    _ ≤ ↑K * dist a a₀ + M := by\n        gcongr\n        · exact lipschitzWith_iff_dist_le_mul.1 (hg i) a a₀\n        · exact hM ⟨i, rfl⟩\n\n"}
{"name":"LipschitzOnWith.coordinate","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : PseudoMetricSpace α\nf : α → Subtype fun x => Membership.mem (lp (fun i => Real) Top.top) x\ns : Set α\nK : NNReal\n⊢ Iff (LipschitzOnWith K f s) (∀ (i : ι), LipschitzOnWith K (fun a => ↑(f a) i) s)","decl":"theorem LipschitzOnWith.coordinate [PseudoMetricSpace α] (f : α → ℓ^∞(ι)) (s : Set α) (K : ℝ≥0) :\n    LipschitzOnWith K f s ↔ ∀ i : ι, LipschitzOnWith K (fun a : α ↦ f a i) s := by\n  simp_rw [lipschitzOnWith_iff_dist_le_mul]\n  constructor\n  · intro hfl i x hx y hy\n    calc\n      dist (f x i) (f y i) ≤ dist (f x) (f y) := lp.norm_apply_le_norm top_ne_zero (f x - f y) i\n      _ ≤ K * dist x y := hfl x hx y hy\n  · intro hgl x hx y hy\n    apply lp.norm_le_of_forall_le\n    · positivity\n    intro i\n    apply hgl i x hx y hy\n\n"}
{"name":"LipschitzWith.coordinate","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : PseudoMetricSpace α\nf : α → Subtype fun x => Membership.mem (lp (fun i => Real) Top.top) x\nK : NNReal\n⊢ Iff (LipschitzWith K f) (∀ (i : ι), LipschitzWith K fun a => ↑(f a) i)","decl":"theorem LipschitzWith.coordinate [PseudoMetricSpace α] {f : α → ℓ^∞(ι)} (K : ℝ≥0) :\n    LipschitzWith K f ↔ ∀ i : ι, LipschitzWith K (fun a : α ↦ f a i) := by\n  simp_rw [← lipschitzOnWith_univ]\n  apply LipschitzOnWith.coordinate\n\n"}
