{"name":"mem‚Ñìp_zero_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\n‚ä¢ Iff (Mem‚Ñìp f 0) (setOf fun i => Ne (f i) 0).Finite","decl":"theorem mem‚Ñìp_zero_iff {f : ‚àÄ i, E i} : Mem‚Ñìp f 0 ‚Üî Set.Finite { i | f i ‚â† 0 } := by\n  dsimp [Mem‚Ñìp]\n  rw [if_pos rfl]\n\n"}
{"name":"mem‚Ñìp_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : (setOf fun i => Ne (f i) 0).Finite\n‚ä¢ Mem‚Ñìp f 0","decl":"theorem mem‚Ñìp_zero {f : ‚àÄ i, E i} (hf : Set.Finite { i | f i ‚â† 0 }) : Mem‚Ñìp f 0 :=\n  mem‚Ñìp_zero_iff.2 hf\n\n"}
{"name":"mem‚Ñìp_infty_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\n‚ä¢ Iff (Mem‚Ñìp f Top.top) (BddAbove (Set.range fun i => Norm.norm (f i)))","decl":"theorem mem‚Ñìp_infty_iff {f : ‚àÄ i, E i} : Mem‚Ñìp f ‚àû ‚Üî BddAbove (Set.range fun i => ‚Äñf i‚Äñ) := by\n  simp [Mem‚Ñìp]\n\n"}
{"name":"mem‚Ñìp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : BddAbove (Set.range fun i => Norm.norm (f i))\n‚ä¢ Mem‚Ñìp f Top.top","decl":"theorem mem‚Ñìp_infty {f : ‚àÄ i, E i} (hf : BddAbove (Set.range fun i => ‚Äñf i‚Äñ)) : Mem‚Ñìp f ‚àû :=\n  mem‚Ñìp_infty_iff.2 hf\n\n"}
{"name":"mem‚Ñìp_gen_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : (i : Œ±) ‚Üí E i\n‚ä¢ Iff (Mem‚Ñìp f p) (Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal)","decl":"theorem mem‚Ñìp_gen_iff (hp : 0 < p.toReal) {f : ‚àÄ i, E i} :\n    Mem‚Ñìp f p ‚Üî Summable fun i => ‚Äñf i‚Äñ ^ p.toReal := by\n  rw [ENNReal.toReal_pos_iff] at hp\n  dsimp [Mem‚Ñìp]\n  rw [if_neg hp.1.ne', if_neg hp.2.ne]\n\n"}
{"name":"mem‚Ñìp_gen","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal\n‚ä¢ Mem‚Ñìp f p","decl":"theorem mem‚Ñìp_gen {f : ‚àÄ i, E i} (hf : Summable fun i => ‚Äñf i‚Äñ ^ p.toReal) : Mem‚Ñìp f p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    have H : Summable fun _ : Œ± => (1 : ‚Ñù) := by simpa using hf\n    exact (Set.Finite.of_summable_const (by norm_num) H).subset (Set.subset_univ _)\n  ¬∑ apply mem‚Ñìp_infty\n    have H : Summable fun _ : Œ± => (1 : ‚Ñù) := by simpa using hf\n    simpa using ((Set.Finite.of_summable_const (by norm_num) H).image fun i => ‚Äñf i‚Äñ).bddAbove\n  exact (mem‚Ñìp_gen_iff hp).2 hf\n\n"}
{"name":"mem‚Ñìp_gen'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nC : Real\nf : (i : Œ±) ‚Üí E i\nhf : ‚àÄ (s : Finset Œ±), LE.le (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) C\n‚ä¢ Mem‚Ñìp f p","decl":"theorem mem‚Ñìp_gen' {C : ‚Ñù} {f : ‚àÄ i, E i} (hf : ‚àÄ s : Finset Œ±, ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal ‚â§ C) :\n    Mem‚Ñìp f p := by\n  apply mem‚Ñìp_gen\n  use ‚®Ü s : Finset Œ±, ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal\n  apply hasSum_of_isLUB_of_nonneg\n  ¬∑ intro b\n    exact Real.rpow_nonneg (norm_nonneg _) _\n  apply isLUB_ciSup\n  use C\n  rintro - ‚ü®s, rfl‚ü©\n  exact hf s\n\n"}
{"name":"zero_mem‚Ñìp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n‚ä¢ Mem‚Ñìp 0 p","decl":"theorem zero_mem‚Ñìp : Mem‚Ñìp (0 : ‚àÄ i, E i) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    simp\n  ¬∑ apply mem‚Ñìp_infty\n    simp only [norm_zero, Pi.zero_apply]\n    exact bddAbove_singleton.mono Set.range_const_subset\n  ¬∑ apply mem‚Ñìp_gen\n    simp [Real.zero_rpow hp.ne', summable_zero]\n\n"}
{"name":"zero_mem_‚Ñìp'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n‚ä¢ Mem‚Ñìp (fun i => 0) p","decl":"theorem zero_mem_‚Ñìp' : Mem‚Ñìp (fun i : Œ± => (0 : E i)) p :=\n  zero_mem‚Ñìp\n\n"}
{"name":"Mem‚Ñìp.finite_dsupport","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f 0\n‚ä¢ (setOf fun i => Ne (f i) 0).Finite","decl":"theorem finite_dsupport {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f 0) : Set.Finite { i | f i ‚â† 0 } :=\n  mem‚Ñìp_zero_iff.1 hf\n\n"}
{"name":"Mem‚Ñìp.bddAbove","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f Top.top\n‚ä¢ BddAbove (Set.range fun i => Norm.norm (f i))","decl":"theorem bddAbove {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f ‚àû) : BddAbove (Set.range fun i => ‚Äñf i‚Äñ) :=\n  mem‚Ñìp_infty_iff.1 hf\n\n"}
{"name":"Mem‚Ñìp.summable","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\n‚ä¢ Summable fun i => HPow.hPow (Norm.norm (f i)) p.toReal","decl":"theorem summable (hp : 0 < p.toReal) {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) :\n    Summable fun i => ‚Äñf i‚Äñ ^ p.toReal :=\n  (mem‚Ñìp_gen_iff hp).1 hf\n\n"}
{"name":"Mem‚Ñìp.neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\n‚ä¢ Mem‚Ñìp (Neg.neg f) p","decl":"theorem neg {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) : Mem‚Ñìp (-f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    simp [hf.finite_dsupport]\n  ¬∑ apply mem‚Ñìp_infty\n    simpa using hf.bddAbove\n  ¬∑ apply mem‚Ñìp_gen\n    simpa using hf.summable hp\n\n"}
{"name":"Mem‚Ñìp.neg_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : (i : Œ±) ‚Üí E i\n‚ä¢ Iff (Mem‚Ñìp (Neg.neg f) p) (Mem‚Ñìp f p)","decl":"@[simp]\ntheorem neg_iff {f : ‚àÄ i, E i} : Mem‚Ñìp (-f) p ‚Üî Mem‚Ñìp f p :=\n  ‚ü®fun h => neg_neg f ‚ñ∏ h.neg, Mem‚Ñìp.neg‚ü©\n\n"}
{"name":"Mem‚Ñìp.of_exponent_ge","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\np q : ENNReal\nf : (i : Œ±) ‚Üí E i\nhfq : Mem‚Ñìp f q\nhpq : LE.le q p\n‚ä¢ Mem‚Ñìp f p","decl":"theorem of_exponent_ge {p q : ‚Ñù‚â•0‚àû} {f : ‚àÄ i, E i} (hfq : Mem‚Ñìp f q) (hpq : q ‚â§ p) : Mem‚Ñìp f p := by\n  rcases ENNReal.trichotomy‚ÇÇ hpq with\n    (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü© | ‚ü®rfl, hp‚ü© | ‚ü®rfl, rfl‚ü© | ‚ü®hq, rfl‚ü© | ‚ü®hq, _, hpq'‚ü©)\n  ¬∑ exact hfq\n  ¬∑ apply mem‚Ñìp_infty\n    obtain ‚ü®C, hC‚ü© := (hfq.finite_dsupport.image fun i => ‚Äñf i‚Äñ).bddAbove\n    use max 0 C\n    rintro x ‚ü®i, rfl‚ü©\n    by_cases hi : f i = 0\n    ¬∑ simp [hi]\n    ¬∑ exact (hC ‚ü®i, hi, rfl‚ü©).trans (le_max_right _ _)\n  ¬∑ apply mem‚Ñìp_gen\n    have : ‚àÄ i ‚àâ hfq.finite_dsupport.toFinset, ‚Äñf i‚Äñ ^ p.toReal = 0 := by\n      intro i hi\n      have : f i = 0 := by simpa using hi\n      simp [this, Real.zero_rpow hp.ne']\n    exact summable_of_ne_finset_zero this\n  ¬∑ exact hfq\n  ¬∑ apply mem‚Ñìp_infty\n    obtain ‚ü®A, hA‚ü© := (hfq.summable hq).tendsto_cofinite_zero.bddAbove_range_of_cofinite\n    use A ^ q.toReal‚Åª¬π\n    rintro x ‚ü®i, rfl‚ü©\n    have : 0 ‚â§ ‚Äñf i‚Äñ ^ q.toReal := by positivity\n    simpa [‚Üê Real.rpow_mul, mul_inv_cancel‚ÇÄ hq.ne'] using\n      Real.rpow_le_rpow this (hA ‚ü®i, rfl‚ü©) (inv_nonneg.mpr hq.le)\n  ¬∑ apply mem‚Ñìp_gen\n    have hf' := hfq.summable hq\n    refine .of_norm_bounded_eventually _ hf' (@Set.Finite.subset _ { i | 1 ‚â§ ‚Äñf i‚Äñ } ?_ _ ?_)\n    ¬∑ have H : { x : Œ± | 1 ‚â§ ‚Äñf x‚Äñ ^ q.toReal }.Finite := by\n        simpa using hf'.tendsto_cofinite_zero.eventually_lt_const (by norm_num)\n      exact H.subset fun i hi => Real.one_le_rpow hi hq.le\n    ¬∑ show ‚àÄ i, ¬¨|‚Äñf i‚Äñ ^ p.toReal| ‚â§ ‚Äñf i‚Äñ ^ q.toReal ‚Üí 1 ‚â§ ‚Äñf i‚Äñ\n      intro i hi\n      have : 0 ‚â§ ‚Äñf i‚Äñ ^ p.toReal := Real.rpow_nonneg (norm_nonneg _) p.toReal\n      simp only [abs_of_nonneg, this] at hi\n      contrapose! hi\n      exact Real.rpow_le_rpow_of_exponent_ge' (norm_nonneg _) hi.le hq.le hpq'\n\n"}
{"name":"Mem‚Ñìp.add","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\nhg : Mem‚Ñìp g p\n‚ä¢ Mem‚Ñìp (HAdd.hAdd f g) p","decl":"theorem add {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f + g) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    refine (hf.finite_dsupport.union hg.finite_dsupport).subset fun i => ?_\n    simp only [Pi.add_apply, Ne, Set.mem_union, Set.mem_setOf_eq]\n    contrapose!\n    rintro ‚ü®hf', hg'‚ü©\n    simp [hf', hg']\n  ¬∑ apply mem‚Ñìp_infty\n    obtain ‚ü®A, hA‚ü© := hf.bddAbove\n    obtain ‚ü®B, hB‚ü© := hg.bddAbove\n    refine ‚ü®A + B, ?_‚ü©\n    rintro a ‚ü®i, rfl‚ü©\n    exact le_trans (norm_add_le _ _) (add_le_add (hA ‚ü®i, rfl‚ü©) (hB ‚ü®i, rfl‚ü©))\n  apply mem‚Ñìp_gen\n  let C : ‚Ñù := if p.toReal < 1 then 1 else (2 : ‚Ñù) ^ (p.toReal - 1)\n  refine .of_nonneg_of_le ?_ (fun i => ?_) (((hf.summable hp).add (hg.summable hp)).mul_left C)\n  ¬∑ intro; positivity\n  ¬∑ refine (Real.rpow_le_rpow (norm_nonneg _) (norm_add_le _ _) hp.le).trans ?_\n    dsimp only [C]\n    split_ifs with h\n    ¬∑ simpa using NNReal.coe_le_coe.2 (NNReal.rpow_add_le_add_rpow ‚Äñf i‚Äñ‚Çä ‚Äñg i‚Äñ‚Çä hp.le h.le)\n    ¬∑ let F : Fin 2 ‚Üí ‚Ñù‚â•0 := ![‚Äñf i‚Äñ‚Çä, ‚Äñg i‚Äñ‚Çä]\n      simp only [not_lt] at h\n      simpa [Fin.sum_univ_succ] using\n        Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg Finset.univ h fun i _ => (F i).coe_nonneg\n\n"}
{"name":"Mem‚Ñìp.sub","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\nhg : Mem‚Ñìp g p\n‚ä¢ Mem‚Ñìp (HSub.hSub f g) p","decl":"theorem sub {f g : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (hg : Mem‚Ñìp g p) : Mem‚Ñìp (f - g) p := by\n  rw [sub_eq_add_neg]; exact hf.add hg.neg\n\n"}
{"name":"Mem‚Ñìp.finset_sum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\ns : Finset Œπ\nf : Œπ ‚Üí (i : Œ±) ‚Üí E i\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Mem‚Ñìp (f i) p\n‚ä¢ Mem‚Ñìp (fun a => s.sum fun i => f i a) p","decl":"theorem finset_sum {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí ‚àÄ i, E i} (hf : ‚àÄ i ‚àà s, Mem‚Ñìp (f i) p) :\n    Mem‚Ñìp (fun a => ‚àë i ‚àà s, f i a) p := by\n  haveI : DecidableEq Œπ := Classical.decEq _\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  ¬∑ simp only [zero_mem_‚Ñìp', Finset.sum_empty, imp_true_iff]\n  ¬∑ intro i s his ih hf\n    simp only [his, Finset.sum_insert, not_false_iff]\n    exact (hf i (s.mem_insert_self i)).add (ih fun j hj => hf j (Finset.mem_insert_of_mem hj))\n\n"}
{"name":"Mem‚Ñìp.const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\nc : ùïú\n‚ä¢ Mem‚Ñìp (HSMul.hSMul c f) p","decl":"theorem const_smul {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) (c : ùïú) : Mem‚Ñìp (c ‚Ä¢ f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    refine hf.finite_dsupport.subset fun i => (?_ : ¬¨c ‚Ä¢ f i = 0 ‚Üí ¬¨f i = 0)\n    exact not_imp_not.mpr fun hf' => hf'.symm ‚ñ∏ smul_zero c\n  ¬∑ obtain ‚ü®A, hA‚ü© := hf.bddAbove\n    refine mem‚Ñìp_infty ‚ü®‚Äñc‚Äñ * A, ?_‚ü©\n    rintro a ‚ü®i, rfl‚ü©\n    dsimp only [Pi.smul_apply]\n    refine (norm_smul_le _ _).trans ?_\n    gcongr\n    exact hA ‚ü®i, rfl‚ü©\n  ¬∑ apply mem‚Ñìp_gen\n    dsimp only [Pi.smul_apply]\n    have := (hf.summable hp).mul_left (‚Üë(‚Äñc‚Äñ‚Çä ^ p.toReal) : ‚Ñù)\n    simp_rw [‚Üê coe_nnnorm, ‚Üê NNReal.coe_rpow, ‚Üê NNReal.coe_mul, NNReal.summable_coe,\n      ‚Üê NNReal.mul_rpow] at this ‚ä¢\n    refine NNReal.summable_of_le ?_ this\n    intro i\n    gcongr\n    apply nnnorm_smul_le\n\n"}
{"name":"Mem‚Ñìp.const_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\np : ENNReal\nùïú : Type u_3\ninst‚úù : NormedRing ùïú\nf : Œ± ‚Üí ùïú\nhf : Mem‚Ñìp f p\nc : ùïú\n‚ä¢ Mem‚Ñìp (fun x => HMul.hMul c (f x)) p","decl":"theorem const_mul {f : Œ± ‚Üí ùïú} (hf : Mem‚Ñìp f p) (c : ùïú) : Mem‚Ñìp (fun x => c * f x) p :=\n  @Mem‚Ñìp.const_smul Œ± (fun _ => ùïú) _ _ ùïú _ _ (fun i => by infer_instance) _ hf c\n\n"}
{"name":"lp.ext","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\nh : Eq ‚Üëf ‚Üëg\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext {f g : lp E p} (h : (f : ‚àÄ i, E i) = g) : f = g :=\n  Subtype.ext h\n\n"}
{"name":"lp.ext_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Iff (Eq f g) (Eq ‚Üëf ‚Üëg)","decl":"@[ext]\ntheorem ext {f g : lp E p} (h : (f : ‚àÄ i, E i) = g) : f = g :=\n  Subtype.ext h\n\n"}
{"name":"lp.eq_zero'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : IsEmpty Œ±\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq f 0","decl":"theorem eq_zero' [IsEmpty Œ±] (f : lp E p) : f = 0 :=\n  Subsingleton.elim f 0\n\n"}
{"name":"lp.monotone","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\np q : ENNReal\nhpq : LE.le q p\n‚ä¢ LE.le (lp E q) (lp E p)","decl":"protected theorem monotone {p q : ‚Ñù‚â•0‚àû} (hpq : q ‚â§ p) : lp E q ‚â§ lp E p :=\n  fun _ hf => Mem‚Ñìp.of_exponent_ge hf hpq\n\n"}
{"name":"lp.mem‚Ñìp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Mem‚Ñìp (‚Üëf) p","decl":"protected theorem mem‚Ñìp (f : lp E p) : Mem‚Ñìp f p :=\n  f.prop\n\n"}
{"name":"lp.coeFn_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n‚ä¢ Eq (‚Üë0) 0","decl":"@[simp]\ntheorem coeFn_zero : ‚áë(0 : lp E p) = 0 :=\n  rfl\n\n"}
{"name":"lp.coeFn_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (‚Üë(Neg.neg f)) (Neg.neg ‚Üëf)","decl":"@[simp]\ntheorem coeFn_neg (f : lp E p) : ‚áë(-f) = -f :=\n  rfl\n\n"}
{"name":"lp.coeFn_add","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (‚Üë(HAdd.hAdd f g)) (HAdd.hAdd ‚Üëf ‚Üëg)","decl":"@[simp]\ntheorem coeFn_add (f g : lp E p) : ‚áë(f + g) = f + g :=\n  rfl\n\n"}
{"name":"lp.coeFn_sum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\nf : Œπ ‚Üí Subtype fun x => Membership.mem (lp E p) x\ns : Finset Œπ\n‚ä¢ Eq (‚Üë(s.sum fun i => f i)) (s.sum fun i => ‚Üë(f i))","decl":"theorem coeFn_sum {Œπ : Type*} (f : Œπ ‚Üí lp E p) (s : Finset Œπ) :\n    ‚áë(‚àë i ‚àà s, f i) = ‚àë i ‚àà s, ‚áë(f i) := by\n  simp\n\n"}
{"name":"lp.coeFn_sub","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf g : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (‚Üë(HSub.hSub f g)) (HSub.hSub ‚Üëf ‚Üëg)","decl":"@[simp]\ntheorem coeFn_sub (f g : lp E p) : ‚áë(f - g) = f - g :=\n  rfl\n\n"}
{"name":"lp.norm_eq_card_dsupport","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E 0) x\n‚ä¢ Eq (Norm.norm f) ‚Üë‚ãØ.toFinset.card","decl":"theorem norm_eq_card_dsupport (f : lp E 0) : ‚Äñf‚Äñ = (lp.mem‚Ñìp f).finite_dsupport.toFinset.card :=\n  dif_pos rfl\n\n"}
{"name":"lp.norm_eq_ciSup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E Top.top) x\n‚ä¢ Eq (Norm.norm f) (iSup fun i => Norm.norm (‚Üëf i))","decl":"theorem norm_eq_ciSup (f : lp E ‚àû) : ‚Äñf‚Äñ = ‚®Ü i, ‚Äñf i‚Äñ := rfl\n\n"}
{"name":"lp.isLUB_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : Nonempty Œ±\nf : Subtype fun x => Membership.mem (lp E Top.top) x\n‚ä¢ IsLUB (Set.range fun i => Norm.norm (‚Üëf i)) (Norm.norm f)","decl":"theorem isLUB_norm [Nonempty Œ±] (f : lp E ‚àû) : IsLUB (Set.range fun i => ‚Äñf i‚Äñ) ‚Äñf‚Äñ := by\n  rw [lp.norm_eq_ciSup]\n  exact isLUB_ciSup (lp.mem‚Ñìp f)\n\n"}
{"name":"lp.norm_eq_tsum_rpow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (Norm.norm f) (HPow.hPow (tsum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem norm_eq_tsum_rpow (hp : 0 < p.toReal) (f : lp E p) :\n    ‚Äñf‚Äñ = (‚àë' i, ‚Äñf i‚Äñ ^ p.toReal) ^ (1 / p.toReal) := by\n  dsimp [norm]\n  rw [ENNReal.toReal_pos_iff] at hp\n  rw [dif_neg hp.1.ne', if_neg hp.2.ne]\n\n"}
{"name":"lp.norm_rpow_eq_tsum","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (HPow.hPow (Norm.norm f) p.toReal) (tsum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal)","decl":"theorem norm_rpow_eq_tsum (hp : 0 < p.toReal) (f : lp E p) :\n    ‚Äñf‚Äñ ^ p.toReal = ‚àë' i, ‚Äñf i‚Äñ ^ p.toReal := by\n  rw [norm_eq_tsum_rpow hp, ‚Üê Real.rpow_mul]\n  ¬∑ field_simp\n  apply tsum_nonneg\n  intro i\n  calc\n    (0 : ‚Ñù) = (0 : ‚Ñù) ^ p.toReal := by rw [Real.zero_rpow hp.ne']\n    _ ‚â§ _ := by gcongr; apply norm_nonneg\n\n"}
{"name":"lp.hasSum_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ HasSum (fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal) (HPow.hPow (Norm.norm f) p.toReal)","decl":"theorem hasSum_norm (hp : 0 < p.toReal) (f : lp E p) :\n    HasSum (fun i => ‚Äñf i‚Äñ ^ p.toReal) (‚Äñf‚Äñ ^ p.toReal) := by\n  rw [norm_rpow_eq_tsum hp]\n  exact ((lp.mem‚Ñìp f).summable hp).hasSum\n\n"}
{"name":"lp.norm_nonneg'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ LE.le 0 (Norm.norm f)","decl":"theorem norm_nonneg' (f : lp E p) : 0 ‚â§ ‚Äñf‚Äñ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ simp [lp.norm_eq_card_dsupport f]\n  ¬∑ cases' isEmpty_or_nonempty Œ± with _i _i\n    ¬∑ rw [lp.norm_eq_ciSup]\n      simp [Real.iSup_of_isEmpty]\n    inhabit Œ±\n    exact (norm_nonneg (f default)).trans ((lp.isLUB_norm f).1 ‚ü®default, rfl‚ü©)\n  ¬∑ rw [lp.norm_eq_tsum_rpow hp f]\n    refine Real.rpow_nonneg (tsum_nonneg ?_) _\n    exact fun i => Real.rpow_nonneg (norm_nonneg _) _\n\n"}
{"name":"lp.norm_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n‚ä¢ Eq (Norm.norm 0) 0","decl":"@[simp]\ntheorem norm_zero : ‚Äñ(0 : lp E p)‚Äñ = 0 := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ simp [lp.norm_eq_card_dsupport]\n  ¬∑ simp [lp.norm_eq_ciSup]\n  ¬∑ rw [lp.norm_eq_tsum_rpow hp]\n    have hp' : 1 / p.toReal ‚â† 0 := one_div_ne_zero hp.ne'\n    simpa [Real.zero_rpow hp.ne'] using Real.zero_rpow hp'\n\n"}
{"name":"lp.norm_eq_zero_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Iff (Eq (Norm.norm f) 0) (Eq f 0)","decl":"theorem norm_eq_zero_iff {f : lp E p} : ‚Äñf‚Äñ = 0 ‚Üî f = 0 := by\n  refine ‚ü®fun h => ?_, by rintro rfl; exact norm_zero‚ü©\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ ext i\n    have : { i : Œ± | ¬¨f i = 0 } = ‚àÖ := by simpa [lp.norm_eq_card_dsupport f] using h\n    have : (¬¨f i = 0) = False := congr_fun this i\n    tauto\n  ¬∑ cases' isEmpty_or_nonempty Œ± with _i _i\n    ¬∑ simp [eq_iff_true_of_subsingleton]\n    have H : IsLUB (Set.range fun i => ‚Äñf i‚Äñ) 0 := by simpa [h] using lp.isLUB_norm f\n    ext i\n    have : ‚Äñf i‚Äñ = 0 := le_antisymm (H.1 ‚ü®i, rfl‚ü©) (norm_nonneg _)\n    simpa using this\n  ¬∑ have hf : HasSum (fun i : Œ± => ‚Äñf i‚Äñ ^ p.toReal) 0 := by\n      have := lp.hasSum_norm hp f\n      rwa [h, Real.zero_rpow hp.ne'] at this\n    have : ‚àÄ i, 0 ‚â§ ‚Äñf i‚Äñ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n    rw [hasSum_zero_iff_of_nonneg this] at hf\n    ext i\n    have : f i = 0 ‚àß p.toReal ‚â† 0 := by\n      simpa [Real.rpow_eq_zero_iff_of_nonneg (norm_nonneg (f i))] using congr_fun hf i\n    exact this.1\n\n"}
{"name":"lp.eq_zero_iff_coeFn_eq_zero","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Iff (Eq f 0) (Eq (‚Üëf) 0)","decl":"theorem eq_zero_iff_coeFn_eq_zero {f : lp E p} : f = 0 ‚Üî ‚áëf = 0 := by\n  rw [lp.ext_iff, coeFn_zero]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): this was very slow, so I squeezed the `simp` calls\n"}
{"name":"lp.norm_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_neg ‚¶Éf : lp E p‚¶Ñ : ‚Äñ-f‚Äñ = ‚Äñf‚Äñ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ simp only [norm_eq_card_dsupport, coeFn_neg, Pi.neg_apply, ne_eq, neg_eq_zero]\n  ¬∑ cases isEmpty_or_nonempty Œ±\n    ¬∑ simp only [lp.eq_zero' f, neg_zero, norm_zero]\n    apply (lp.isLUB_norm (-f)).unique\n    simpa only [coeFn_neg, Pi.neg_apply, norm_neg] using lp.isLUB_norm f\n  ¬∑ suffices ‚Äñ-f‚Äñ ^ p.toReal = ‚Äñf‚Äñ ^ p.toReal by\n      exact Real.rpow_left_injOn hp.ne' (norm_nonneg' _) (norm_nonneg' _) this\n    apply (lp.hasSum_norm hp (-f)).unique\n    simpa only [coeFn_neg, Pi.neg_apply, _root_.norm_neg] using lp.hasSum_norm hp f\n\n"}
{"name":"lp.tsum_mul_le_mul_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n‚ä¢ And (Summable fun i => HMul.hMul (Norm.norm (‚Üëf i)) (Norm.norm (‚Üëg i))) (LE.le (tsum fun i => HMul.hMul (Norm.norm (‚Üëf i)) (Norm.norm (‚Üëg i))) (HMul.hMul (Norm.norm f) (Norm.norm g)))","decl":"/-- H√∂lder inequality -/\nprotected theorem tsum_mul_le_mul_norm {p q : ‚Ñù‚â•0‚àû} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) :\n    (Summable fun i => ‚Äñf i‚Äñ * ‚Äñg i‚Äñ) ‚àß ‚àë' i, ‚Äñf i‚Äñ * ‚Äñg i‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ := by\n  have hf‚ÇÅ : ‚àÄ i, 0 ‚â§ ‚Äñf i‚Äñ := fun i => norm_nonneg _\n  have hg‚ÇÅ : ‚àÄ i, 0 ‚â§ ‚Äñg i‚Äñ := fun i => norm_nonneg _\n  have hf‚ÇÇ := lp.hasSum_norm hpq.pos f\n  have hg‚ÇÇ := lp.hasSum_norm hpq.symm.pos g\n  obtain ‚ü®C, -, hC', hC‚ü© :=\n    Real.inner_le_Lp_mul_Lq_hasSum_of_nonneg hpq (norm_nonneg' _) (norm_nonneg' _) hf‚ÇÅ hg‚ÇÅ hf‚ÇÇ hg‚ÇÇ\n  rw [‚Üê hC.tsum_eq] at hC'\n  exact ‚ü®hC.summable, hC'‚ü©\n\n"}
{"name":"lp.summable_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n‚ä¢ Summable fun i => HMul.hMul (Norm.norm (‚Üëf i)) (Norm.norm (‚Üëg i))","decl":"protected theorem summable_mul {p q : ‚Ñù‚â•0‚àû} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) : Summable fun i => ‚Äñf i‚Äñ * ‚Äñg i‚Äñ :=\n  (lp.tsum_mul_le_mul_norm hpq f g).1\n\n"}
{"name":"lp.tsum_mul_le_mul_norm'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\np q : ENNReal\nhpq : p.toReal.IsConjExponent q.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ng : Subtype fun x => Membership.mem (lp E q) x\n‚ä¢ LE.le (tsum fun i => HMul.hMul (Norm.norm (‚Üëf i)) (Norm.norm (‚Üëg i))) (HMul.hMul (Norm.norm f) (Norm.norm g))","decl":"protected theorem tsum_mul_le_mul_norm' {p q : ‚Ñù‚â•0‚àû} (hpq : p.toReal.IsConjExponent q.toReal)\n    (f : lp E p) (g : lp E q) : ‚àë' i, ‚Äñf i‚Äñ * ‚Äñg i‚Äñ ‚â§ ‚Äñf‚Äñ * ‚Äñg‚Äñ :=\n  (lp.tsum_mul_le_mul_norm hpq f g).2\n\n"}
{"name":"lp.norm_apply_le_norm","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : Ne p 0\nf : Subtype fun x => Membership.mem (lp E p) x\ni : Œ±\n‚ä¢ LE.le (Norm.norm (‚Üëf i)) (Norm.norm f)","decl":"theorem norm_apply_le_norm (hp : p ‚â† 0) (f : lp E p) (i : Œ±) : ‚Äñf i‚Äñ ‚â§ ‚Äñf‚Äñ := by\n  rcases eq_or_ne p ‚àû with (rfl | hp')\n  ¬∑ haveI : Nonempty Œ± := ‚ü®i‚ü©\n    exact (isLUB_norm f).1 ‚ü®i, rfl‚ü©\n  have hp'' : 0 < p.toReal := ENNReal.toReal_pos hp hp'\n  have : ‚àÄ i, 0 ‚â§ ‚Äñf i‚Äñ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n  rw [‚Üê Real.rpow_le_rpow_iff (norm_nonneg _) (norm_nonneg' _) hp'']\n  convert le_hasSum (hasSum_norm hp'' f) i fun i _ => this i\n\n"}
{"name":"lp.sum_rpow_le_norm_rpow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset Œ±\n‚ä¢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal) (HPow.hPow (Norm.norm f) p.toReal)","decl":"theorem sum_rpow_le_norm_rpow (hp : 0 < p.toReal) (f : lp E p) (s : Finset Œ±) :\n    ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal ‚â§ ‚Äñf‚Äñ ^ p.toReal := by\n  rw [lp.norm_rpow_eq_tsum hp f]\n  have : ‚àÄ i, 0 ‚â§ ‚Äñf i‚Äñ ^ p.toReal := fun i => Real.rpow_nonneg (norm_nonneg _) _\n  refine sum_le_tsum _ (fun i _ => this i) ?_\n  exact (lp.mem‚Ñìp f).summable hp\n\n"}
{"name":"lp.norm_le_of_forall_le'","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : Nonempty Œ±\nf : Subtype fun x => Membership.mem (lp E Top.top) x\nC : Real\nhCf : ‚àÄ (i : Œ±), LE.le (Norm.norm (‚Üëf i)) C\n‚ä¢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_le' [Nonempty Œ±] {f : lp E ‚àû} (C : ‚Ñù) (hCf : ‚àÄ i, ‚Äñf i‚Äñ ‚â§ C) :\n    ‚Äñf‚Äñ ‚â§ C := by\n  refine (isLUB_norm f).2 ?_\n  rintro - ‚ü®i, rfl‚ü©\n  exact hCf i\n\n"}
{"name":"lp.norm_le_of_forall_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nf : Subtype fun x => Membership.mem (lp E Top.top) x\nC : Real\nhC : LE.le 0 C\nhCf : ‚àÄ (i : Œ±), LE.le (Norm.norm (‚Üëf i)) C\n‚ä¢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_le {f : lp E ‚àû} {C : ‚Ñù} (hC : 0 ‚â§ C) (hCf : ‚àÄ i, ‚Äñf i‚Äñ ‚â§ C) :\n    ‚Äñf‚Äñ ‚â§ C := by\n  cases isEmpty_or_nonempty Œ±\n  ¬∑ simpa [eq_zero' f] using hC\n  ¬∑ exact norm_le_of_forall_le' C hCf\n\n"}
{"name":"lp.norm_le_of_tsum_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nC : Real\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : LE.le (tsum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal) (HPow.hPow C p.toReal)\n‚ä¢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_tsum_le (hp : 0 < p.toReal) {C : ‚Ñù} (hC : 0 ‚â§ C) {f : lp E p}\n    (hf : ‚àë' i, ‚Äñf i‚Äñ ^ p.toReal ‚â§ C ^ p.toReal) : ‚Äñf‚Äñ ‚â§ C := by\n  rw [‚Üê Real.rpow_le_rpow_iff (norm_nonneg' _) hC hp, norm_rpow_eq_tsum hp]\n  exact hf\n\n"}
{"name":"lp.norm_le_of_forall_sum_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nhp : LT.lt 0 p.toReal\nC : Real\nhC : LE.le 0 C\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : ‚àÄ (s : Finset Œ±), LE.le (s.sum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal) (HPow.hPow C p.toReal)\n‚ä¢ LE.le (Norm.norm f) C","decl":"theorem norm_le_of_forall_sum_le (hp : 0 < p.toReal) {C : ‚Ñù} (hC : 0 ‚â§ C) {f : lp E p}\n    (hf : ‚àÄ s : Finset Œ±, ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal ‚â§ C ^ p.toReal) : ‚Äñf‚Äñ ‚â§ C :=\n  norm_le_of_tsum_le hp hC (tsum_le_of_sum_le ((lp.mem‚Ñìp f).summable hp) hf)\n\n"}
{"name":"lp.instSMulCommClassPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù‚Åµ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\nùïú' : Type u_4\ninst‚úù‚Å¥ : NormedRing ùïú\ninst‚úù¬≥ : NormedRing ùïú'\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú' (E i)\ninst‚úù : ‚àÄ (i : Œ±), SMulCommClass ùïú' ùïú (E i)\n‚ä¢ SMulCommClass ùïú' ùïú (PreLp E)","decl":"instance [‚àÄ i, SMulCommClass ùïú' ùïú (E i)] : SMulCommClass ùïú' ùïú (PreLp E) :=\n  Pi.smulCommClass\n\n"}
{"name":"lp.instIsScalarTowerPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù‚Å∂ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\nùïú' : Type u_4\ninst‚úù‚Åµ : NormedRing ùïú\ninst‚úù‚Å¥ : NormedRing ùïú'\ninst‚úù¬≥ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú' (E i)\ninst‚úù¬π : SMul ùïú' ùïú\ninst‚úù : ‚àÄ (i : Œ±), IsScalarTower ùïú' ùïú (E i)\n‚ä¢ IsScalarTower ùïú' ùïú (PreLp E)","decl":"instance [SMul ùïú' ùïú] [‚àÄ i, IsScalarTower ùïú' ùïú (E i)] : IsScalarTower ùïú' ùïú (PreLp E) :=\n  Pi.isScalarTower\n\n"}
{"name":"lp.instIsCentralScalarPreLp","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù‚Å¥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí Module (MulOpposite ùïú) (E i)\ninst‚úù : ‚àÄ (i : Œ±), IsCentralScalar ùïú (E i)\n‚ä¢ IsCentralScalar ùïú (PreLp E)","decl":"instance [‚àÄ i, Module ùïú·µê·µí·µñ (E i)] [‚àÄ i, IsCentralScalar ùïú (E i)] : IsCentralScalar ùïú (PreLp E) :=\n  Pi.isCentralScalar\n\n"}
{"name":"lp.mem_lp_const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\nc : ùïú\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Membership.mem (lp E p) (HSMul.hSMul c ‚Üëf)","decl":"theorem mem_lp_const_smul (c : ùïú) (f : lp E p) : c ‚Ä¢ (f : PreLp E) ‚àà lp E p :=\n  (lp.mem‚Ñìp f).const_smul c\n\n"}
{"name":"lp.coe_lpSubmodule","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\n‚ä¢ Eq (lpSubmodule E p ùïú).toAddSubgroup (lp E p)","decl":"theorem coe_lpSubmodule : (lpSubmodule E p ùïú).toAddSubgroup = lp E p :=\n  rfl\n\n"}
{"name":"lp.coeFn_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\nc : ùïú\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (‚Üë(HSMul.hSMul c f)) (HSMul.hSMul c ‚Üëf)","decl":"@[simp]\ntheorem coeFn_smul (c : ùïú) (f : lp E p) : ‚áë(c ‚Ä¢ f) = c ‚Ä¢ ‚áëf :=\n  rfl\n\n"}
{"name":"lp.instSMulCommClassSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù‚Åµ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\nùïú' : Type u_4\ninst‚úù‚Å¥ : NormedRing ùïú\ninst‚úù¬≥ : NormedRing ùïú'\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú' (E i)\ninst‚úù : ‚àÄ (i : Œ±), SMulCommClass ùïú' ùïú (E i)\n‚ä¢ SMulCommClass ùïú' ùïú (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [‚àÄ i, SMulCommClass ùïú' ùïú (E i)] : SMulCommClass ùïú' ùïú (lp E p) :=\n  ‚ü®fun _ _ _ => Subtype.ext <| smul_comm _ _ _‚ü©\n\n"}
{"name":"lp.instIsScalarTowerSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù‚Å∂ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\nùïú' : Type u_4\ninst‚úù‚Åµ : NormedRing ùïú\ninst‚úù‚Å¥ : NormedRing ùïú'\ninst‚úù¬≥ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú' (E i)\ninst‚úù¬π : SMul ùïú' ùïú\ninst‚úù : ‚àÄ (i : Œ±), IsScalarTower ùïú' ùïú (E i)\n‚ä¢ IsScalarTower ùïú' ùïú (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [SMul ùïú' ùïú] [‚àÄ i, IsScalarTower ùïú' ùïú (E i)] : IsScalarTower ùïú' ùïú (lp E p) :=\n  ‚ü®fun _ _ _ => Subtype.ext <| smul_assoc _ _ _‚ü©\n\n"}
{"name":"lp.instIsCentralScalarSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù‚Å¥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí Module (MulOpposite ùïú) (E i)\ninst‚úù : ‚àÄ (i : Œ±), IsCentralScalar ùïú (E i)\n‚ä¢ IsCentralScalar ùïú (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [‚àÄ i, Module ùïú·µê·µí·µñ (E i)] [‚àÄ i, IsCentralScalar ùïú (E i)] : IsCentralScalar ùïú (lp E p) :=\n  ‚ü®fun _ _ => Subtype.ext <| op_smul_eq_smul _ _‚ü©\n\n"}
{"name":"lp.norm_const_smul_le","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\nhp : Ne p 0\nc : ùïú\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem norm_const_smul_le (hp : p ‚â† 0) (c : ùïú) (f : lp E p) : ‚Äñc ‚Ä¢ f‚Äñ ‚â§ ‚Äñc‚Äñ * ‚Äñf‚Äñ := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ exact absurd rfl hp\n  ¬∑ cases isEmpty_or_nonempty Œ±\n    ¬∑ simp [lp.eq_zero' f]\n    have hcf := lp.isLUB_norm (c ‚Ä¢ f)\n    have hfc := (lp.isLUB_norm f).mul_left (norm_nonneg c)\n    simp_rw [‚Üê Set.range_comp, Function.comp_def] at hfc\n    -- TODO: some `IsLUB` API should make it a one-liner from here.\n    refine hcf.right ?_\n    have := hfc.left\n    simp_rw [mem_upperBounds, Set.mem_range,\n      forall_exists_index, forall_apply_eq_imp_iff] at this ‚ä¢\n    intro a\n    exact (norm_smul_le _ _).trans (this a)\n  ¬∑ letI inst : NNNorm (lp E p) := ‚ü®fun f => ‚ü®‚Äñf‚Äñ, norm_nonneg' _‚ü©‚ü©\n    have coe_nnnorm : ‚àÄ f : lp E p, ‚Üë‚Äñf‚Äñ‚Çä = ‚Äñf‚Äñ := fun _ => rfl\n    suffices ‚Äñc ‚Ä¢ f‚Äñ‚Çä ^ p.toReal ‚â§ (‚Äñc‚Äñ‚Çä * ‚Äñf‚Äñ‚Çä) ^ p.toReal by\n      rwa [NNReal.rpow_le_rpow_iff hp] at this\n    clear_value inst\n    rw [NNReal.mul_rpow]\n    have hLHS := lp.hasSum_norm hp (c ‚Ä¢ f)\n    have hRHS := (lp.hasSum_norm hp f).mul_left (‚Äñc‚Äñ ^ p.toReal)\n    simp_rw [‚Üê coe_nnnorm, ‚Üê _root_.coe_nnnorm, ‚Üê NNReal.coe_rpow, ‚Üê NNReal.coe_mul,\n      NNReal.hasSum_coe] at hRHS hLHS\n    refine hasSum_mono hLHS hRHS fun i => ?_\n    dsimp only\n    rw [‚Üê NNReal.mul_rpow]\n    -- Porting note: added\n    rw [lp.coeFn_smul, Pi.smul_apply]\n    gcongr\n    apply nnnorm_smul_le\n\n"}
{"name":"lp.instBoundedSMulSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù‚Å¥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\ninst‚úù : Fact (LE.le 1 p)\n‚ä¢ BoundedSMul ùïú (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [Fact (1 ‚â§ p)] : BoundedSMul ùïú (lp E p) :=\n  BoundedSMul.of_norm_smul_le <| norm_const_smul_le (zero_lt_one.trans_le <| Fact.out).ne'\n\n"}
{"name":"lp.norm_const_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≤ : NormedDivisionRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\nhp : Ne p 0\nc : ùïú\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem norm_const_smul (hp : p ‚â† 0) {c : ùïú} (f : lp E p) : ‚Äñc ‚Ä¢ f‚Äñ = ‚Äñc‚Äñ * ‚Äñf‚Äñ := by\n  obtain rfl | hc := eq_or_ne c 0\n  ¬∑ simp\n  refine le_antisymm (norm_const_smul_le hp c f) ?_\n  have := mul_le_mul_of_nonneg_left (norm_const_smul_le hp c‚Åª¬π (c ‚Ä¢ f)) (norm_nonneg c)\n  rwa [inv_smul_smul‚ÇÄ hc, norm_inv, mul_inv_cancel_left‚ÇÄ (norm_ne_zero_iff.mpr hc)] at this\n\n"}
{"name":"Mem‚Ñìp.star_mem","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nf : (i : Œ±) ‚Üí E i\nhf : Mem‚Ñìp f p\n‚ä¢ Mem‚Ñìp (Star.star f) p","decl":"theorem _root_.Mem‚Ñìp.star_mem {f : ‚àÄ i, E i} (hf : Mem‚Ñìp f p) : Mem‚Ñìp (star f) p := by\n  rcases p.trichotomy with (rfl | rfl | hp)\n  ¬∑ apply mem‚Ñìp_zero\n    simp [hf.finite_dsupport]\n  ¬∑ apply mem‚Ñìp_infty\n    simpa using hf.bddAbove\n  ¬∑ apply mem‚Ñìp_gen\n    simpa using hf.summable hp\n\n"}
{"name":"Mem‚Ñìp.star_iff","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nf : (i : Œ±) ‚Üí E i\n‚ä¢ Iff (Mem‚Ñìp (Star.star f) p) (Mem‚Ñìp f p)","decl":"@[simp]\ntheorem _root_.Mem‚Ñìp.star_iff {f : ‚àÄ i, E i} : Mem‚Ñìp (star f) p ‚Üî Mem‚Ñìp f p :=\n  ‚ü®fun h => star_star f ‚ñ∏ Mem‚Ñìp.star_mem h, Mem‚Ñìp.star_mem‚ü©\n\n"}
{"name":"lp.coeFn_star","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ Eq (‚Üë(Star.star f)) (Star.star ‚Üëf)","decl":"@[simp]\ntheorem coeFn_star (f : lp E p) : ‚áë(star f) = star (‚áëf) :=\n  rfl\n\n"}
{"name":"lp.star_apply","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nf : Subtype fun x => Membership.mem (lp E p) x\ni : Œ±\n‚ä¢ Eq (‚Üë(Star.star f) i) (Star.star (‚Üëf i))","decl":"@[simp]\nprotected theorem star_apply (f : lp E p) (i : Œ±) : star f i = star (f i) :=\n  rfl\n\n"}
{"name":"lp.instNormedStarGroupSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nhp : Fact (LE.le 1 p)\n‚ä¢ NormedStarGroup (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance [hp : Fact (1 ‚â§ p)] : NormedStarGroup (lp E p) where\n  norm_star f := by\n    rcases p.trichotomy with (rfl | rfl | h)\n    ¬∑ exfalso\n      have := ENNReal.toReal_mono ENNReal.zero_ne_top hp.elim\n      norm_num at this\n    ¬∑ simp only [lp.norm_eq_ciSup, lp.star_apply, norm_star]\n    ¬∑ simp only [lp.norm_eq_tsum_rpow h, lp.star_apply, norm_star]\n\n"}
{"name":"lp.instStarModuleSubtypePreLpMemAddSubgroup","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù‚Å∂ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù‚Åµ : (i : Œ±) ‚Üí StarAddMonoid (E i)\ninst‚úù‚Å¥ : ‚àÄ (i : Œ±), NormedStarGroup (E i)\nùïú : Type u_3\ninst‚úù¬≥ : Star ùïú\ninst‚úù¬≤ : NormedRing ùïú\ninst‚úù¬π : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù : ‚àÄ (i : Œ±), StarModule ùïú (E i)\n‚ä¢ StarModule ùïú (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance : StarModule ùïú (lp E p) where\n  star_smul _r _f := ext <| star_smul (A := ‚àÄ i, E i) _ _\n\n"}
{"name":"Mem‚Ñìp.infty_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù : (i : I) ‚Üí NonUnitalNormedRing (B i)\nf g : (i : I) ‚Üí B i\nhf : Mem‚Ñìp f Top.top\nhg : Mem‚Ñìp g Top.top\n‚ä¢ Mem‚Ñìp (HMul.hMul f g) Top.top","decl":"theorem _root_.Mem‚Ñìp.infty_mul {f g : ‚àÄ i, B i} (hf : Mem‚Ñìp f ‚àû) (hg : Mem‚Ñìp g ‚àû) :\n    Mem‚Ñìp (f * g) ‚àû := by\n  rw [mem‚Ñìp_infty_iff]\n  obtain ‚ü®‚ü®Cf, hCf‚ü©, ‚ü®Cg, hCg‚ü©‚ü© := hf.bddAbove, hg.bddAbove\n  refine ‚ü®Cf * Cg, ?_‚ü©\n  rintro _ ‚ü®i, rfl‚ü©\n  calc\n    ‚Äñ(f * g) i‚Äñ ‚â§ ‚Äñf i‚Äñ * ‚Äñg i‚Äñ := norm_mul_le (f i) (g i)\n    _ ‚â§ Cf * Cg :=\n      mul_le_mul (hCf ‚ü®i, rfl‚ü©) (hCg ‚ü®i, rfl‚ü©) (norm_nonneg _)\n        ((norm_nonneg _).trans (hCf ‚ü®i, rfl‚ü©))\n\n"}
{"name":"lp.infty_coeFn_mul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù : (i : I) ‚Üí NonUnitalNormedRing (B i)\nf g : Subtype fun x => Membership.mem (lp B Top.top) x\n‚ä¢ Eq (‚Üë(HMul.hMul f g)) (HMul.hMul ‚Üëf ‚Üëg)","decl":"@[simp]\ntheorem infty_coeFn_mul (f g : lp B ‚àû) : ‚áë(f * g) = ‚áëf * ‚áëg :=\n  rfl\n\n"}
{"name":"lp.infty_isScalarTower","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù‚Å¥ : (i : I) ‚Üí NonUnitalNormedRing (B i)\nùïú : Type u_5\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : I) ‚Üí Module ùïú (B i)\ninst‚úù¬π : ‚àÄ (i : I), BoundedSMul ùïú (B i)\ninst‚úù : ‚àÄ (i : I), IsScalarTower ùïú (B i) (B i)\n‚ä¢ IsScalarTower ùïú (Subtype fun x => Membership.mem (lp B Top.top) x) (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance infty_isScalarTower {ùïú} [NormedRing ùïú] [‚àÄ i, Module ùïú (B i)] [‚àÄ i, BoundedSMul ùïú (B i)]\n    [‚àÄ i, IsScalarTower ùïú (B i) (B i)] : IsScalarTower ùïú (lp B ‚àû) (lp B ‚àû) :=\n  ‚ü®fun r f g => lp.ext <| smul_assoc (N := ‚àÄ i, B i) (Œ± := ‚àÄ i, B i) r (‚áëf) (‚áëg)‚ü©\n\n"}
{"name":"lp.infty_smulCommClass","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù‚Å¥ : (i : I) ‚Üí NonUnitalNormedRing (B i)\nùïú : Type u_5\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : I) ‚Üí Module ùïú (B i)\ninst‚úù¬π : ‚àÄ (i : I), BoundedSMul ùïú (B i)\ninst‚úù : ‚àÄ (i : I), SMulCommClass ùïú (B i) (B i)\n‚ä¢ SMulCommClass ùïú (Subtype fun x => Membership.mem (lp B Top.top) x) (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance infty_smulCommClass {ùïú} [NormedRing ùïú] [‚àÄ i, Module ùïú (B i)] [‚àÄ i, BoundedSMul ùïú (B i)]\n    [‚àÄ i, SMulCommClass ùïú (B i) (B i)] : SMulCommClass ùïú (lp B ‚àû) (lp B ‚àû) :=\n  ‚ü®fun r f g => lp.ext <| smul_comm (N := ‚àÄ i, B i) (Œ± := ‚àÄ i, B i) r (‚áëf) (‚áëg)‚ü©\n\n"}
{"name":"lp.inftyCStarRing","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬≥ : (i : I) ‚Üí NonUnitalNormedRing (B i)\ninst‚úù¬≤ : (i : I) ‚Üí StarRing (B i)\ninst‚úù¬π : ‚àÄ (i : I), NormedStarGroup (B i)\ninst‚úù : ‚àÄ (i : I), CStarRing (B i)\n‚ä¢ CStarRing (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance inftyCStarRing [‚àÄ i, CStarRing (B i)] : CStarRing (lp B ‚àû) where\n  norm_mul_self_le f := by\n    rw [‚Üê sq, ‚Üê Real.le_sqrt (norm_nonneg _) (norm_nonneg _)]\n    refine lp.norm_le_of_forall_le ‚Äñstar f * f‚Äñ.sqrt_nonneg fun i => ?_\n    rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, ‚Üê CStarRing.norm_star_mul_self]\n    exact lp.norm_apply_le_norm ENNReal.top_ne_zero (star f * f) i\n\n"}
{"name":"one_mem‚Ñìp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\n‚ä¢ Mem‚Ñìp 1 Top.top","decl":"theorem _root_.one_mem‚Ñìp_infty : Mem‚Ñìp (1 : ‚àÄ i, B i) ‚àû :=\n  ‚ü®1, by rintro i ‚ü®i, rfl‚ü©; exact norm_one.le‚ü©\n\n"}
{"name":"Mem‚Ñìp.infty_pow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nf : (i : I) ‚Üí B i\nhf : Mem‚Ñìp f Top.top\nn : Nat\n‚ä¢ Mem‚Ñìp (HPow.hPow f n) Top.top","decl":"theorem _root_.Mem‚Ñìp.infty_pow {f : ‚àÄ i, B i} (hf : Mem‚Ñìp f ‚àû) (n : ‚Ñï) : Mem‚Ñìp (f ^ n) ‚àû :=\n  (lpInftySubring B).pow_mem hf n\n\n"}
{"name":"natCast_mem‚Ñìp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nn : Nat\n‚ä¢ Mem‚Ñìp (‚Üën) Top.top","decl":"theorem _root_.natCast_mem‚Ñìp_infty (n : ‚Ñï) : Mem‚Ñìp (n : ‚àÄ i, B i) ‚àû :=\n  natCast_mem (lpInftySubring B) n\n\n"}
{"name":"intCast_mem‚Ñìp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nz : Int\n‚ä¢ Mem‚Ñìp (‚Üëz) Top.top","decl":"theorem _root_.intCast_mem‚Ñìp_infty (z : ‚Ñ§) : Mem‚Ñìp (z : ‚àÄ i, B i) ‚àû :=\n  intCast_mem (lpInftySubring B) z\n\n"}
{"name":"lp.infty_coeFn_one","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\n‚ä¢ Eq (‚Üë1) 1","decl":"@[simp]\ntheorem infty_coeFn_one : ‚áë(1 : lp B ‚àû) = 1 :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_pow","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nf : Subtype fun x => Membership.mem (lp B Top.top) x\nn : Nat\n‚ä¢ Eq (‚Üë(HPow.hPow f n)) (HPow.hPow (‚Üëf) n)","decl":"@[simp]\ntheorem infty_coeFn_pow (f : lp B ‚àû) (n : ‚Ñï) : ‚áë(f ^ n) = (‚áëf) ^ n :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_natCast","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nn : Nat\n‚ä¢ Eq ‚Üë‚Üën ‚Üën","decl":"@[simp]\ntheorem infty_coeFn_natCast (n : ‚Ñï) : ‚áë(n : lp B ‚àû) = n :=\n  rfl\n\n"}
{"name":"lp.infty_coeFn_intCast","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬π : (i : I) ‚Üí NormedRing (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nz : Int\n‚ä¢ Eq ‚Üë‚Üëz ‚Üëz","decl":"@[simp]\ntheorem infty_coeFn_intCast (z : ‚Ñ§) : ‚áë(z : lp B ‚àû) = z :=\n  rfl\n\n"}
{"name":"lp.instNormOneClassSubtypePreLpMemAddSubgroupTopENNRealOfNonempty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nB : I ‚Üí Type u_4\ninst‚úù¬≤ : (i : I) ‚Üí NormedRing (B i)\ninst‚úù¬π : ‚àÄ (i : I), NormOneClass (B i)\ninst‚úù : Nonempty I\n‚ä¢ NormOneClass (Subtype fun x => Membership.mem (lp B Top.top) x)","decl":"instance [Nonempty I] : NormOneClass (lp B ‚àû) where\n  norm_one := by simp_rw [lp.norm_eq_ciSup, infty_coeFn_one, Pi.one_apply, norm_one, ciSup_const]\n\n"}
{"name":"algebraMap_mem‚Ñìp_infty","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"I : Type u_3\nùïú : Type u_4\nB : I ‚Üí Type u_5\ninst‚úù¬≥ : NormedField ùïú\ninst‚úù¬≤ : (i : I) ‚Üí NormedRing (B i)\ninst‚úù¬π : (i : I) ‚Üí NormedAlgebra ùïú (B i)\ninst‚úù : ‚àÄ (i : I), NormOneClass (B i)\nk : ùïú\n‚ä¢ Mem‚Ñìp ((algebraMap ùïú ((i : I) ‚Üí B i)) k) Top.top","decl":"theorem _root_.algebraMap_mem‚Ñìp_infty (k : ùïú) : Mem‚Ñìp (algebraMap ùïú (‚àÄ i, B i) k) ‚àû := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  exact (one_mem‚Ñìp_infty.const_smul k : Mem‚Ñìp (k ‚Ä¢ (1 : ‚àÄ i, B i)) ‚àû)\n\n"}
{"name":"lp.single_apply","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\np : ENNReal\ni : Œ±\na : E i\nj : Œ±\n‚ä¢ Eq (‚Üë(lp.single p i a) j) (dite (Eq j i) (fun h => Eq.ndrec a ‚ãØ) fun h => 0)","decl":"protected theorem single_apply (p) (i : Œ±) (a : E i) (j : Œ±) :\n    lp.single p i a j = if h : j = i then Eq.ndrec a h.symm else 0 :=\n  rfl\n\n"}
{"name":"lp.single_apply_self","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\np : ENNReal\ni : Œ±\na : E i\n‚ä¢ Eq (‚Üë(lp.single p i a) i) a","decl":"protected theorem single_apply_self (p) (i : Œ±) (a : E i) : lp.single p i a i = a := by\n  rw [lp.single_apply, dif_pos rfl]\n\n"}
{"name":"lp.single_apply_ne","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\np : ENNReal\ni : Œ±\na : E i\nj : Œ±\nhij : Ne j i\n‚ä¢ Eq (‚Üë(lp.single p i a) j) 0","decl":"protected theorem single_apply_ne (p) (i : Œ±) (a : E i) {j : Œ±} (hij : j ‚â† i) :\n    lp.single p i a j = 0 := by\n  rw [lp.single_apply, dif_neg hij]\n\n"}
{"name":"lp.single_neg","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\np : ENNReal\ni : Œ±\na : E i\n‚ä¢ Eq (lp.single p i (Neg.neg a)) (Neg.neg (lp.single p i a))","decl":"@[simp]\nprotected theorem single_neg (p) (i : Œ±) (a : E i) : lp.single p i (-a) = -lp.single p i a := by\n  refine ext (funext (fun (j : Œ±) => ?_))\n  by_cases hi : j = i\n  ¬∑ subst hi\n    simp [lp.single_apply_self]\n  ¬∑ simp [lp.single_apply_ne p i _ hi]\n\n"}
{"name":"lp.single_smul","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù‚Å¥ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nùïú : Type u_3\ninst‚úù¬≥ : NormedRing ùïú\ninst‚úù¬≤ : (i : Œ±) ‚Üí Module ùïú (E i)\ninst‚úù¬π : ‚àÄ (i : Œ±), BoundedSMul ùïú (E i)\ninst‚úù : DecidableEq Œ±\np : ENNReal\ni : Œ±\na : E i\nc : ùïú\n‚ä¢ Eq (lp.single p i (HSMul.hSMul c a)) (HSMul.hSMul c (lp.single p i a))","decl":"@[simp]\nprotected theorem single_smul (p) (i : Œ±) (a : E i) (c : ùïú) :\n    lp.single p i (c ‚Ä¢ a) = c ‚Ä¢ lp.single p i a := by\n  refine ext (funext (fun (j : Œ±) => ?_))\n  by_cases hi : j = i\n  ¬∑ subst hi\n    dsimp\n    simp [lp.single_apply_self]\n  ¬∑ dsimp\n    simp [lp.single_apply_ne p i _ hi]\n\n"}
{"name":"lp.norm_sum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\nhp : LT.lt 0 p.toReal\nf : (i : Œ±) ‚Üí E i\ns : Finset Œ±\n‚ä¢ Eq (HPow.hPow (Norm.norm (s.sum fun i => lp.single p i (f i))) p.toReal) (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal)","decl":"protected theorem norm_sum_single (hp : 0 < p.toReal) (f : ‚àÄ i, E i) (s : Finset Œ±) :\n    ‚Äñ‚àë i ‚àà s, lp.single p i (f i)‚Äñ ^ p.toReal = ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal := by\n  refine (hasSum_norm hp (‚àë i ‚àà s, lp.single p i (f i))).unique ?_\n  simp only [lp.single_apply, coeFn_sum, Finset.sum_apply, Finset.sum_dite_eq]\n  have h : ‚àÄ i ‚àâ s, ‚Äñite (i ‚àà s) (f i) 0‚Äñ ^ p.toReal = 0 := fun i hi ‚Ü¶ by\n    simp [if_neg hi, Real.zero_rpow hp.ne']\n  have h' : ‚àÄ i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal = ‚Äñite (i ‚àà s) (f i) 0‚Äñ ^ p.toReal := by\n    intro i hi\n    rw [if_pos hi]\n  simpa [Finset.sum_congr rfl h'] using hasSum_sum_of_ne_finset_zero h\n\n"}
{"name":"lp.norm_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\nhp : LT.lt 0 p.toReal\nf : (i : Œ±) ‚Üí E i\ni : Œ±\n‚ä¢ Eq (Norm.norm (lp.single p i (f i))) (Norm.norm (f i))","decl":"protected theorem norm_single (hp : 0 < p.toReal) (f : ‚àÄ i, E i) (i : Œ±) :\n    ‚Äñlp.single p i (f i)‚Äñ = ‚Äñf i‚Äñ := by\n  refine Real.rpow_left_injOn hp.ne' (norm_nonneg' _) (norm_nonneg _) ?_\n  simpa using lp.norm_sum_single hp f {i}\n\n"}
{"name":"lp.norm_sub_norm_compl_sub_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset Œ±\n‚ä¢ Eq (HSub.hSub (HPow.hPow (Norm.norm f) p.toReal) (HPow.hPow (Norm.norm (HSub.hSub f (s.sum fun i => lp.single p i (‚Üëf i)))) p.toReal)) (s.sum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal)","decl":"protected theorem norm_sub_norm_compl_sub_single (hp : 0 < p.toReal) (f : lp E p) (s : Finset Œ±) :\n    ‚Äñf‚Äñ ^ p.toReal - ‚Äñf - ‚àë i ‚àà s, lp.single p i (f i)‚Äñ ^ p.toReal =\n      ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal := by\n  refine ((hasSum_norm hp f).sub (hasSum_norm hp (f - ‚àë i ‚àà s, lp.single p i (f i)))).unique ?_\n  let F : Œ± ‚Üí ‚Ñù := fun i => ‚Äñf i‚Äñ ^ p.toReal - ‚Äñ(f - ‚àë i ‚àà s, lp.single p i (f i)) i‚Äñ ^ p.toReal\n  have hF : ‚àÄ i ‚àâ s, F i = 0 := by\n    intro i hi\n    suffices ‚Äñf i‚Äñ ^ p.toReal - ‚Äñf i - ite (i ‚àà s) (f i) 0‚Äñ ^ p.toReal = 0 by\n      simpa only [F, coeFn_sum, lp.single_apply, coeFn_sub, Pi.sub_apply, Finset.sum_apply,\n        Finset.sum_dite_eq] using this\n    simp only [if_neg hi, sub_zero, sub_self]\n  have hF' : ‚àÄ i ‚àà s, F i = ‚Äñf i‚Äñ ^ p.toReal := by\n    intro i hi\n    simp only [F, coeFn_sum, lp.single_apply, if_pos hi, sub_self, eq_self_iff_true, coeFn_sub,\n      Pi.sub_apply, Finset.sum_apply, Finset.sum_dite_eq, sub_eq_self]\n    simp [Real.zero_rpow hp.ne']\n  have : HasSum F (‚àë i ‚àà s, F i) := hasSum_sum_of_ne_finset_zero hF\n  rwa [Finset.sum_congr rfl hF'] at this\n\n"}
{"name":"lp.norm_compl_sum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù : DecidableEq Œ±\nhp : LT.lt 0 p.toReal\nf : Subtype fun x => Membership.mem (lp E p) x\ns : Finset Œ±\n‚ä¢ Eq (HPow.hPow (Norm.norm (HSub.hSub f (s.sum fun i => lp.single p i (‚Üëf i)))) p.toReal) (HSub.hSub (HPow.hPow (Norm.norm f) p.toReal) (s.sum fun i => HPow.hPow (Norm.norm (‚Üëf i)) p.toReal))","decl":"protected theorem norm_compl_sum_single (hp : 0 < p.toReal) (f : lp E p) (s : Finset Œ±) :\n    ‚Äñf - ‚àë i ‚àà s, lp.single p i (f i)‚Äñ ^ p.toReal = ‚Äñf‚Äñ ^ p.toReal - ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal := by\n  linarith [lp.norm_sub_norm_compl_sub_single hp f s]\n\n"}
{"name":"lp.hasSum_single","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬≤ : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\ninst‚úù¬π : DecidableEq Œ±\ninst‚úù : Fact (LE.le 1 p)\nhp : Ne p Top.top\nf : Subtype fun x => Membership.mem (lp E p) x\n‚ä¢ HasSum (fun i => lp.single p i (‚Üëf i)) f","decl":"/-- The canonical finitely-supported approximations to an element `f` of `lp` converge to it, in the\n`lp` topology. -/\nprotected theorem hasSum_single [Fact (1 ‚â§ p)] (hp : p ‚â† ‚ä§) (f : lp E p) :\n    HasSum (fun i : Œ± => lp.single p i (f i : E i)) f := by\n  have hp‚ÇÄ : 0 < p := zero_lt_one.trans_le Fact.out\n  have hp' : 0 < p.toReal := ENNReal.toReal_pos hp‚ÇÄ.ne' hp\n  have := lp.hasSum_norm hp' f\n  rw [HasSum, Metric.tendsto_nhds] at this ‚ä¢\n  intro Œµ hŒµ\n  refine (this _ (Real.rpow_pos_of_pos hŒµ p.toReal)).mono ?_\n  intro s hs\n  rw [‚Üê Real.rpow_lt_rpow_iff dist_nonneg (le_of_lt hŒµ) hp']\n  rw [dist_comm] at hs\n  simp only [dist_eq_norm, Real.norm_eq_abs] at hs ‚ä¢\n  have H : ‚Äñ(‚àë i ‚àà s, lp.single p i (f i : E i)) - f‚Äñ ^ p.toReal =\n      ‚Äñf‚Äñ ^ p.toReal - ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal := by\n    simpa only [coeFn_neg, Pi.neg_apply, lp.single_neg, Finset.sum_neg_distrib, neg_sub_neg,\n      norm_neg, _root_.norm_neg] using lp.norm_compl_sum_single hp' (-f) s\n  rw [‚Üê H] at hs\n  have : |‚Äñ(‚àë i ‚àà s, lp.single p i (f i : E i)) - f‚Äñ ^ p.toReal| =\n      ‚Äñ(‚àë i ‚àà s, lp.single p i (f i : E i)) - f‚Äñ ^ p.toReal := by\n    simp only [Real.abs_rpow_of_nonneg (norm_nonneg _), abs_norm]\n  exact this ‚ñ∏ hs\n\n"}
{"name":"lp.uniformContinuous_coe","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\n‚ä¢ UniformContinuous Subtype.val","decl":"/-- The coercion from `lp E p` to `‚àÄ i, E i` is uniformly continuous. -/\ntheorem uniformContinuous_coe [_i : Fact (1 ‚â§ p)] :\n    UniformContinuous (Œ± := lp E p) ((‚Üë) : lp E p ‚Üí ‚àÄ i, E i) := by\n  have hp : p ‚â† 0 := (zero_lt_one.trans_le _i.elim).ne'\n  rw [uniformContinuous_pi]\n  intro i\n  rw [NormedAddCommGroup.uniformity_basis_dist.uniformContinuous_iff\n    NormedAddCommGroup.uniformity_basis_dist]\n  intro Œµ hŒµ\n  refine ‚ü®Œµ, hŒµ, ?_‚ü©\n  rintro f g (hfg : ‚Äñf - g‚Äñ < Œµ)\n  have : ‚Äñf i - g i‚Äñ ‚â§ ‚Äñf - g‚Äñ := norm_apply_le_norm hp (f - g) i\n  exact this.trans_lt hfg\n\n"}
{"name":"lp.norm_apply_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\nl : Filter Œπ\ninst‚úù : l.NeBot\nC : Real\nF : Œπ ‚Üí Subtype fun x => Membership.mem (lp E Top.top) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : (a : Œ±) ‚Üí E a\nhf : Filter.Tendsto (id fun i => ‚Üë(F i)) l (nhds f)\na : Œ±\n‚ä¢ LE.le (Norm.norm (f a)) C","decl":"theorem norm_apply_le_of_tendsto {C : ‚Ñù} {F : Œπ ‚Üí lp E ‚àû} (hCF : ‚àÄ·∂† k in l, ‚ÄñF k‚Äñ ‚â§ C)\n    {f : ‚àÄ a, E a} (hf : Tendsto (id fun i => F i : Œπ ‚Üí ‚àÄ a, E a) l (ùìù f)) (a : Œ±) : ‚Äñf a‚Äñ ‚â§ C := by\n  have : Tendsto (fun k => ‚ÄñF k a‚Äñ) l (ùìù ‚Äñf a‚Äñ) :=\n    (Tendsto.comp (continuous_apply a).continuousAt hf).norm\n  refine le_of_tendsto this (hCF.mono ?_)\n  intro k hCFk\n  exact (norm_apply_le_norm ENNReal.top_ne_zero (F k) a).trans hCFk\n\n"}
{"name":"lp.sum_rpow_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\nl : Filter Œπ\ninst‚úù : l.NeBot\n_i : Fact (LE.le 1 p)\nhp : Ne p Top.top\nC : Real\nF : Œπ ‚Üí Subtype fun x => Membership.mem (lp E p) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : (a : Œ±) ‚Üí E a\nhf : Filter.Tendsto (id fun i => ‚Üë(F i)) l (nhds f)\ns : Finset Œ±\n‚ä¢ LE.le (s.sum fun i => HPow.hPow (Norm.norm (f i)) p.toReal) (HPow.hPow C p.toReal)","decl":"theorem sum_rpow_le_of_tendsto (hp : p ‚â† ‚àû) {C : ‚Ñù} {F : Œπ ‚Üí lp E p} (hCF : ‚àÄ·∂† k in l, ‚ÄñF k‚Äñ ‚â§ C)\n    {f : ‚àÄ a, E a} (hf : Tendsto (id fun i => F i : Œπ ‚Üí ‚àÄ a, E a) l (ùìù f)) (s : Finset Œ±) :\n    ‚àë i ‚àà s, ‚Äñf i‚Äñ ^ p.toReal ‚â§ C ^ p.toReal := by\n  have hp' : p ‚â† 0 := (zero_lt_one.trans_le _i.elim).ne'\n  have hp'' : 0 < p.toReal := ENNReal.toReal_pos hp' hp\n  let G : (‚àÄ a, E a) ‚Üí ‚Ñù := fun f => ‚àë a ‚àà s, ‚Äñf a‚Äñ ^ p.toReal\n  have hG : Continuous G := by\n    refine continuous_finset_sum s ?_\n    intro a _\n    have : Continuous fun f : ‚àÄ a, E a => f a := continuous_apply a\n    exact this.norm.rpow_const fun _ => Or.inr hp''.le\n  refine le_of_tendsto (hG.continuousAt.tendsto.comp hf) ?_\n  refine hCF.mono ?_\n  intro k hCFk\n  refine (lp.sum_rpow_le_norm_rpow hp'' (F k) s).trans ?_\n  gcongr\n\n"}
{"name":"lp.norm_le_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\nl : Filter Œπ\ninst‚úù : l.NeBot\n_i : Fact (LE.le 1 p)\nC : Real\nF : Œπ ‚Üí Subtype fun x => Membership.mem (lp E p) x\nhCF : Filter.Eventually (fun k => LE.le (Norm.norm (F k)) C) l\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : Filter.Tendsto (id fun i => ‚Üë(F i)) l (nhds ‚Üëf)\n‚ä¢ LE.le (Norm.norm f) C","decl":"/-- \"Semicontinuity of the `lp` norm\": If all sufficiently large elements of a sequence in `lp E p`\n have `lp` norm `‚â§ C`, then the pointwise limit, if it exists, also has `lp` norm `‚â§ C`. -/\ntheorem norm_le_of_tendsto {C : ‚Ñù} {F : Œπ ‚Üí lp E p} (hCF : ‚àÄ·∂† k in l, ‚ÄñF k‚Äñ ‚â§ C) {f : lp E p}\n    (hf : Tendsto (id fun i => F i : Œπ ‚Üí ‚àÄ a, E a) l (ùìù f)) : ‚Äñf‚Äñ ‚â§ C := by\n  obtain ‚ü®i, hi‚ü© := hCF.exists\n  have hC : 0 ‚â§ C := (norm_nonneg _).trans hi\n  rcases eq_top_or_lt_top p with (rfl | hp)\n  ¬∑ apply norm_le_of_forall_le hC\n    exact norm_apply_le_of_tendsto hCF hf\n  ¬∑ have : 0 < p := zero_lt_one.trans_le _i.elim\n    have hp' : 0 < p.toReal := ENNReal.toReal_pos this.ne' hp.ne\n    apply norm_le_of_forall_sum_le hp' hC\n    exact sum_rpow_le_of_tendsto hp.ne hCF hf\n\n"}
{"name":"lp.mem‚Ñìp_of_tendsto","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù¬π : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\nŒπ : Type u_3\nl : Filter Œπ\ninst‚úù : l.NeBot\n_i : Fact (LE.le 1 p)\nF : Œπ ‚Üí Subtype fun x => Membership.mem (lp E p) x\nhF : Bornology.IsBounded (Set.range F)\nf : (a : Œ±) ‚Üí E a\nhf : Filter.Tendsto (id fun i => ‚Üë(F i)) l (nhds f)\n‚ä¢ Mem‚Ñìp f p","decl":"/-- If `f` is the pointwise limit of a bounded sequence in `lp E p`, then `f` is in `lp E p`. -/\ntheorem mem‚Ñìp_of_tendsto {F : Œπ ‚Üí lp E p} (hF : Bornology.IsBounded (Set.range F)) {f : ‚àÄ a, E a}\n    (hf : Tendsto (id fun i => F i : Œπ ‚Üí ‚àÄ a, E a) l (ùìù f)) : Mem‚Ñìp f p := by\n  obtain ‚ü®C, hCF‚ü© : ‚àÉ C, ‚àÄ k, ‚ÄñF k‚Äñ ‚â§ C := hF.exists_norm_le.imp fun _ ‚Ü¶ Set.forall_mem_range.1\n  rcases eq_top_or_lt_top p with (rfl | hp)\n  ¬∑ apply mem‚Ñìp_infty\n    use C\n    rintro _ ‚ü®a, rfl‚ü©\n    exact norm_apply_le_of_tendsto (Eventually.of_forall hCF) hf a\n  ¬∑ apply mem‚Ñìp_gen'\n    exact sum_rpow_le_of_tendsto hp.ne (Eventually.of_forall hCF) hf\n\n"}
{"name":"lp.tendsto_lp_of_tendsto_pi","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\nF : Nat ‚Üí Subtype fun x => Membership.mem (lp E p) x\nhF : CauchySeq F\nf : Subtype fun x => Membership.mem (lp E p) x\nhf : Filter.Tendsto (id fun i => ‚Üë(F i)) Filter.atTop (nhds ‚Üëf)\n‚ä¢ Filter.Tendsto F Filter.atTop (nhds f)","decl":"/-- If a sequence is Cauchy in the `lp E p` topology and pointwise convergent to an element `f` of\n`lp E p`, then it converges to `f` in the `lp E p` topology. -/\ntheorem tendsto_lp_of_tendsto_pi {F : ‚Ñï ‚Üí lp E p} (hF : CauchySeq F) {f : lp E p}\n    (hf : Tendsto (id fun i => F i : ‚Ñï ‚Üí ‚àÄ a, E a) atTop (ùìù f)) : Tendsto F atTop (ùìù f) := by\n  rw [Metric.nhds_basis_closedBall.tendsto_right_iff]\n  intro Œµ hŒµ\n  have hŒµ' : { p : lp E p √ó lp E p | ‚Äñp.1 - p.2‚Äñ < Œµ } ‚àà uniformity (lp E p) :=\n    NormedAddCommGroup.uniformity_basis_dist.mem_of_mem hŒµ\n  refine (hF.eventually_eventually hŒµ').mono ?_\n  rintro n (hn : ‚àÄ·∂† l in atTop, ‚Äñ(fun f => F n - f) (F l)‚Äñ < Œµ)\n  refine norm_le_of_tendsto (hn.mono fun k hk => hk.le) ?_\n  rw [tendsto_pi_nhds]\n  intro a\n  exact (hf.apply_nhds a).const_sub (F n a)\n\n"}
{"name":"lp.completeSpace","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nE : Œ± ‚Üí Type u_2\np : ENNReal\ninst‚úù : (i : Œ±) ‚Üí NormedAddCommGroup (E i)\n_i : Fact (LE.le 1 p)\n‚ä¢ CompleteSpace (Subtype fun x => Membership.mem (lp E p) x)","decl":"instance completeSpace : CompleteSpace (lp E p) :=\n  Metric.complete_of_cauchySeq_tendsto (by\n    intro F hF\n    -- A Cauchy sequence in `lp E p` is pointwise convergent; let `f` be the pointwise limit.\n    obtain ‚ü®f, hf‚ü© := cauchySeq_tendsto_of_complete\n      ((uniformContinuous_coe (p := p)).comp_cauchySeq hF)\n    -- Since the Cauchy sequence is bounded, its pointwise limit `f` is in `lp E p`.\n    have hf' : Mem‚Ñìp f p := mem‚Ñìp_of_tendsto hF.isBounded_range hf\n    -- And therefore `f` is its limit in the `lp E p` topology as well as pointwise.\n    exact ‚ü®‚ü®f, hf'‚ü©, tendsto_lp_of_tendsto_pi hF hf‚ü©)\n\n"}
{"name":"LipschitzWith.uniformly_bounded","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\ng : Œ± ‚Üí Œπ ‚Üí Real\nK : NNReal\nhg : ‚àÄ (i : Œπ), LipschitzWith K fun x => g x i\na‚ÇÄ : Œ±\nhga‚ÇÄb : Mem‚Ñìp (g a‚ÇÄ) Top.top\na : Œ±\n‚ä¢ Mem‚Ñìp (g a) Top.top","decl":"lemma LipschitzWith.uniformly_bounded [PseudoMetricSpace Œ±] (g : Œ± ‚Üí Œπ ‚Üí ‚Ñù) {K : ‚Ñù‚â•0}\n    (hg : ‚àÄ i, LipschitzWith K (g ¬∑ i)) (a‚ÇÄ : Œ±) (hga‚ÇÄb : Mem‚Ñìp (g a‚ÇÄ) ‚àû) (a : Œ±) :\n    Mem‚Ñìp (g a) ‚àû := by\n  rcases hga‚ÇÄb with ‚ü®M, hM‚ü©\n  use ‚ÜëK * dist a a‚ÇÄ + M\n  rintro - ‚ü®i, rfl‚ü©\n  calc\n    |g a i| = |g a i - g a‚ÇÄ i + g a‚ÇÄ i| := by simp\n    _ ‚â§ |g a i - g a‚ÇÄ i| + |g a‚ÇÄ i| := abs_add _ _\n    _ ‚â§ ‚ÜëK * dist a a‚ÇÄ + M := by\n        gcongr\n        ¬∑ exact lipschitzWith_iff_dist_le_mul.1 (hg i) a a‚ÇÄ\n        ¬∑ exact hM ‚ü®i, rfl‚ü©\n\n"}
{"name":"LipschitzOnWith.coordinate","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\nf : Œ± ‚Üí Subtype fun x => Membership.mem (lp (fun i => Real) Top.top) x\ns : Set Œ±\nK : NNReal\n‚ä¢ Iff (LipschitzOnWith K f s) (‚àÄ (i : Œπ), LipschitzOnWith K (fun a => ‚Üë(f a) i) s)","decl":"theorem LipschitzOnWith.coordinate [PseudoMetricSpace Œ±] (f : Œ± ‚Üí ‚Ñì^‚àû(Œπ)) (s : Set Œ±) (K : ‚Ñù‚â•0) :\n    LipschitzOnWith K f s ‚Üî ‚àÄ i : Œπ, LipschitzOnWith K (fun a : Œ± ‚Ü¶ f a i) s := by\n  simp_rw [lipschitzOnWith_iff_dist_le_mul]\n  constructor\n  ¬∑ intro hfl i x hx y hy\n    calc\n      dist (f x i) (f y i) ‚â§ dist (f x) (f y) := lp.norm_apply_le_norm top_ne_zero (f x - f y) i\n      _ ‚â§ K * dist x y := hfl x hx y hy\n  ¬∑ intro hgl x hx y hy\n    apply lp.norm_le_of_forall_le\n    ¬∑ positivity\n    intro i\n    apply hgl i x hx y hy\n\n"}
{"name":"LipschitzWith.coordinate","module":"Mathlib.Analysis.Normed.Lp.lpSpace","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : PseudoMetricSpace Œ±\nf : Œ± ‚Üí Subtype fun x => Membership.mem (lp (fun i => Real) Top.top) x\nK : NNReal\n‚ä¢ Iff (LipschitzWith K f) (‚àÄ (i : Œπ), LipschitzWith K fun a => ‚Üë(f a) i)","decl":"theorem LipschitzWith.coordinate [PseudoMetricSpace Œ±] {f : Œ± ‚Üí ‚Ñì^‚àû(Œπ)} (K : ‚Ñù‚â•0) :\n    LipschitzWith K f ‚Üî ‚àÄ i : Œπ, LipschitzWith K (fun a : Œ± ‚Ü¶ f a i) := by\n  simp_rw [‚Üê lipschitzOnWith_univ]\n  apply LipschitzOnWith.coordinate\n\n"}
