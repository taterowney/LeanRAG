{"name":"MvPolynomial.pderiv_def","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ni : σ\n⊢ Eq (MvPolynomial.pderiv i) (MvPolynomial.mkDerivation R (Pi.single i 1))","decl":"theorem pderiv_def [DecidableEq σ] (i : σ) : pderiv i = mkDerivation R (Pi.single i 1) := by\n  unfold pderiv; congr!\n\n"}
{"name":"MvPolynomial.pderiv_monomial","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\na : R\ns : Finsupp σ Nat\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) ((MvPolynomial.monomial s) a)) ((MvPolynomial.monomial (HSub.hSub s (Finsupp.single i 1))) (HMul.hMul a ↑(s i)))","decl":"@[simp]\ntheorem pderiv_monomial {i : σ} :\n    pderiv i (monomial s a) = monomial (s - single i 1) (a * s i) := by\n  classical\n  simp only [pderiv_def, mkDerivation_monomial, Finsupp.smul_sum, smul_eq_mul, ← smul_mul_assoc,\n    ← (monomial _).map_smul]\n  refine (Finset.sum_eq_single i (fun j _ hne => ?_) fun hi => ?_).trans ?_\n  · simp [Pi.single_eq_of_ne hne]\n  · rw [Finsupp.not_mem_support_iff] at hi; simp [hi]\n  · simp\n\n"}
{"name":"MvPolynomial.X_mul_pderiv_monomial","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\nm : Finsupp σ Nat\nr : R\n⊢ Eq (HMul.hMul (MvPolynomial.X i) ((MvPolynomial.pderiv i) ((MvPolynomial.monomial m) r))) (HSMul.hSMul (m i) ((MvPolynomial.monomial m) r))","decl":"lemma X_mul_pderiv_monomial {i : σ} {m : σ →₀ ℕ} {r : R} :\n    X i * pderiv i (monomial m r) = m i • monomial m r := by\n  rw [pderiv_monomial, X, monomial_mul, smul_monomial]\n  by_cases h : m i = 0\n  · simp_rw [h, Nat.cast_zero, mul_zero, zero_smul, monomial_zero]\n  rw [one_mul, mul_comm, nsmul_eq_mul, add_comm, sub_add_single_one_cancel h]\n\n"}
{"name":"MvPolynomial.pderiv_C","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\na : R\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) (MvPolynomial.C a)) 0","decl":"theorem pderiv_C {i : σ} : pderiv i (C a) = 0 :=\n  derivation_C _ _\n\n"}
{"name":"MvPolynomial.pderiv_one","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) 1) 0","decl":"theorem pderiv_one {i : σ} : pderiv i (1 : MvPolynomial σ R) = 0 := pderiv_C\n\n"}
{"name":"MvPolynomial.pderiv_X","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝¹ : CommSemiring R\ninst✝ : DecidableEq σ\ni j : σ\n⊢ Eq ((MvPolynomial.pderiv i) (MvPolynomial.X j)) (Pi.single i 1 j)","decl":"@[simp]\ntheorem pderiv_X [DecidableEq σ] (i j : σ) :\n    pderiv i (X j : MvPolynomial σ R) = Pi.single (f := fun _ => _) i 1 j := by\n  rw [pderiv_def, mkDerivation_X]\n\n"}
{"name":"MvPolynomial.pderiv_X_self","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) (MvPolynomial.X i)) 1","decl":"@[simp]\ntheorem pderiv_X_self (i : σ) : pderiv i (X i : MvPolynomial σ R) = 1 := by classical simp\n\n"}
{"name":"MvPolynomial.pderiv_X_of_ne","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni j : σ\nh : Ne j i\n⊢ Eq ((MvPolynomial.pderiv i) (MvPolynomial.X j)) 0","decl":"@[simp]\ntheorem pderiv_X_of_ne {i j : σ} (h : j ≠ i) : pderiv i (X j : MvPolynomial σ R) = 0 := by\n  classical simp [h]\n\n"}
{"name":"MvPolynomial.pderiv_eq_zero_of_not_mem_vars","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\nf : MvPolynomial σ R\nh : Not (Membership.mem f.vars i)\n⊢ Eq ((MvPolynomial.pderiv i) f) 0","decl":"theorem pderiv_eq_zero_of_not_mem_vars {i : σ} {f : MvPolynomial σ R} (h : i ∉ f.vars) :\n    pderiv i f = 0 :=\n  derivation_eq_zero_of_forall_mem_vars fun _ hj => pderiv_X_of_ne <| ne_of_mem_of_not_mem hj h\n\n"}
{"name":"MvPolynomial.pderiv_monomial_single","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\na : R\ninst✝ : CommSemiring R\ni : σ\nn : Nat\n⊢ Eq ((MvPolynomial.pderiv i) ((MvPolynomial.monomial (Finsupp.single i n)) a)) ((MvPolynomial.monomial (Finsupp.single i (HSub.hSub n 1))) (HMul.hMul a ↑n))","decl":"theorem pderiv_monomial_single {i : σ} {n : ℕ} : pderiv i (monomial (single i n) a) =\n    monomial (single i (n - 1)) (a * n) := by simp\n\n"}
{"name":"MvPolynomial.pderiv_mul","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\nf g : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.pderiv i) (HMul.hMul f g)) (HAdd.hAdd (HMul.hMul ((MvPolynomial.pderiv i) f) g) (HMul.hMul f ((MvPolynomial.pderiv i) g)))","decl":"theorem pderiv_mul {i : σ} {f g : MvPolynomial σ R} :\n    pderiv i (f * g) = pderiv i f * g + f * pderiv i g := by\n  simp only [(pderiv i).leibniz f g, smul_eq_mul, mul_comm, add_comm]\n\n"}
{"name":"MvPolynomial.pderiv_pow","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\ni : σ\nf : MvPolynomial σ R\nn : Nat\n⊢ Eq ((MvPolynomial.pderiv i) (HPow.hPow f n)) (HMul.hMul (HMul.hMul (↑n) (HPow.hPow f (HSub.hSub n 1))) ((MvPolynomial.pderiv i) f))","decl":"theorem pderiv_pow {i : σ} {f : MvPolynomial σ R} {n : ℕ} :\n    pderiv i (f ^ n) = n * f ^ (n - 1) * pderiv i f := by\n  rw [(pderiv i).leibniz_pow f n, nsmul_eq_mul, smul_eq_mul, mul_assoc]\n\n"}
{"name":"MvPolynomial.pderiv_C_mul","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\na : R\ninst✝ : CommSemiring R\nf : MvPolynomial σ R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) (HMul.hMul (MvPolynomial.C a) f)) (HMul.hMul (MvPolynomial.C a) ((MvPolynomial.pderiv i) f))","decl":"theorem pderiv_C_mul {f : MvPolynomial σ R} {i : σ} : pderiv i (C a * f) = C a * pderiv i f := by\n  rw [C_mul', Derivation.map_smul, C_mul']\n\n"}
{"name":"MvPolynomial.pderiv_map","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝¹ : CommSemiring R\nS : Type u_1\ninst✝ : CommSemiring S\nφ : RingHom R S\nf : MvPolynomial σ R\ni : σ\n⊢ Eq ((MvPolynomial.pderiv i) ((MvPolynomial.map φ) f)) ((MvPolynomial.map φ) ((MvPolynomial.pderiv i) f))","decl":"theorem pderiv_map {S} [CommSemiring S] {φ : R →+* S} {f : MvPolynomial σ R} {i : σ} :\n    pderiv i (map φ f) = map φ (pderiv i f) := by\n  apply induction_on f (fun r ↦ by simp) (fun p q hp hq ↦ by simp [hp, hq]) fun p j eq ↦ ?_\n  obtain rfl | h := eq_or_ne j i\n  · simp [eq]\n  · simp [eq, h]\n\n"}
{"name":"MvPolynomial.pderiv_rename","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝ : CommSemiring R\nτ : Type u_1\nf : σ → τ\nhf : Function.Injective f\nx : σ\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.pderiv (f x)) ((MvPolynomial.rename f) p)) ((MvPolynomial.rename f) ((MvPolynomial.pderiv x) p))","decl":"lemma pderiv_rename {τ : Type*} {f : σ → τ} (hf : Function.Injective f)\n    (x : σ) (p : MvPolynomial σ R) :\n    pderiv (f x) (rename f p) = rename f (pderiv x p) := by\n  classical\n  induction' p using MvPolynomial.induction_on with a p q hp hq p a h\n  · simp\n  · simp [hp, hq]\n  · simp only [map_mul, MvPolynomial.rename_X, Derivation.leibniz, MvPolynomial.pderiv_X,\n      Pi.single_apply, hf.eq_iff, smul_eq_mul, mul_ite, mul_one, mul_zero, h, map_add, add_left_inj]\n    split_ifs <;> simp\n\n"}
{"name":"MvPolynomial.aeval_sum_elim_pderiv_inl","module":"Mathlib.Algebra.MvPolynomial.PDeriv","initialProofState":"R : Type u\nσ : Type v\ninst✝² : CommSemiring R\nS : Type u_1\nτ : Type u_2\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\np : MvPolynomial (Sum σ τ) R\nf : τ → S\nj : σ\n⊢ Eq ((MvPolynomial.aeval (Sum.elim MvPolynomial.X (Function.comp (⇑MvPolynomial.C) f))) ((MvPolynomial.pderiv (Sum.inl j)) p)) ((MvPolynomial.pderiv j) ((MvPolynomial.aeval (Sum.elim MvPolynomial.X (Function.comp (⇑MvPolynomial.C) f))) p))","decl":"lemma aeval_sum_elim_pderiv_inl {S τ : Type*} [CommRing S] [Algebra R S]\n    (p : MvPolynomial (σ ⊕ τ) R) (f : τ → S) (j : σ) :\n    aeval (Sum.elim X (C ∘ f)) ((pderiv (Sum.inl j)) p) =\n      (pderiv j) ((aeval (Sum.elim X (C ∘ f))) p) := by\n  classical\n  induction' p using MvPolynomial.induction_on with a p q hp hq p q h\n  · simp\n  · simp [hp, hq]\n  · simp only [Derivation.leibniz, pderiv_X, smul_eq_mul, map_add, map_mul, aeval_X, h]\n    cases q <;> simp [Pi.single_apply]\n\n"}
