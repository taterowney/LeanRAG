{"name":"bernstein_apply","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"n ŒΩ : Nat\nx : ‚ÜëunitInterval\n‚ä¢ Eq ((bernstein n ŒΩ) x) (HMul.hMul (HMul.hMul (‚Üë(n.choose ŒΩ)) (HPow.hPow (‚Üëx) ŒΩ)) (HPow.hPow (HSub.hSub 1 ‚Üëx) (HSub.hSub n ŒΩ)))","decl":"@[simp]\ntheorem bernstein_apply (n ŒΩ : ‚Ñï) (x : I) :\n    bernstein n ŒΩ x = (n.choose ŒΩ : ‚Ñù) * (x : ‚Ñù) ^ ŒΩ * (1 - (x : ‚Ñù)) ^ (n - ŒΩ) := by\n  dsimp [bernstein, Polynomial.toContinuousMapOn, Polynomial.toContinuousMap, bernsteinPolynomial]\n  simp\n\n"}
{"name":"bernstein_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"n ŒΩ : Nat\nx : ‚ÜëunitInterval\n‚ä¢ LE.le 0 ((bernstein n ŒΩ) x)","decl":"theorem bernstein_nonneg {n ŒΩ : ‚Ñï} {x : I} : 0 ‚â§ bernstein n ŒΩ x := by\n  simp only [bernstein_apply]\n  have h‚ÇÅ : (0 : ‚Ñù) ‚â§ x := by unit_interval\n  have h‚ÇÇ : (0 : ‚Ñù) ‚â§ 1 - x := by unit_interval\n  positivity\n\n"}
{"name":"bernstein.probability","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"n : Nat\nx : ‚ÜëunitInterval\n‚ä¢ Eq (Finset.univ.sum fun k => (bernstein n ‚Üëk) x) 1","decl":"theorem probability (n : ‚Ñï) (x : I) : (‚àë k : Fin (n + 1), bernstein n k x) = 1 := by\n  have := bernsteinPolynomial.sum ‚Ñù n\n  apply_fun fun p => Polynomial.aeval (x : ‚Ñù) p at this\n  simp? [map_sum, Finset.sum_range] at this says\n    simp only [Finset.sum_range, map_sum, Polynomial.coe_aeval_eq_eval, Polynomial.eval_one] at this\n  exact this\n\n"}
{"name":"bernstein.variance","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"n : Nat\nh : LT.lt 0 ‚Üën\nx : ‚ÜëunitInterval\n‚ä¢ Eq (Finset.univ.sum fun k => HMul.hMul (HPow.hPow (HSub.hSub ‚Üëx ‚Üë(bernstein.z k)) 2) ((bernstein n ‚Üëk) x)) (HDiv.hDiv (HMul.hMul (‚Üëx) (HSub.hSub 1 ‚Üëx)) ‚Üën)","decl":"theorem variance {n : ‚Ñï} (h : 0 < (n : ‚Ñù)) (x : I) :\n    (‚àë k : Fin (n + 1), (x - k/‚Çô : ‚Ñù) ^ 2 * bernstein n k x) = (x : ‚Ñù) * (1 - x) / n := by\n  have h' : (n : ‚Ñù) ‚â† 0 := ne_of_gt h\n  apply_fun fun x : ‚Ñù => x * n using GroupWithZero.mul_left_injective h'\n  apply_fun fun x : ‚Ñù => x * n using GroupWithZero.mul_left_injective h'\n  dsimp\n  conv_lhs => simp only [Finset.sum_mul, z]\n  conv_rhs => rw [div_mul_cancel‚ÇÄ _ h']\n  have := bernsteinPolynomial.variance ‚Ñù n\n  apply_fun fun p => Polynomial.aeval (x : ‚Ñù) p at this\n  simp? [map_sum, Finset.sum_range, ‚Üê Polynomial.natCast_mul] at this says\n    simp only [nsmul_eq_mul, Finset.sum_range, map_sum, Polynomial.coe_aeval_eq_eval,\n      Polynomial.eval_mul, Polynomial.eval_pow, Polynomial.eval_sub, Polynomial.eval_natCast,\n      Polynomial.eval_X, Polynomial.eval_one] at this\n  convert this using 1\n  ¬∑ congr 1; funext k\n    rw [mul_comm _ (n : ‚Ñù), mul_comm _ (n : ‚Ñù), ‚Üê mul_assoc, ‚Üê mul_assoc]\n    congr 1\n    field_simp [h]\n    ring\n  ¬∑ ring\n\n"}
{"name":"bernsteinApproximation.apply","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"n : Nat\nf : ContinuousMap (‚ÜëunitInterval) Real\nx : ‚ÜëunitInterval\n‚ä¢ Eq ((bernsteinApproximation n f) x) (Finset.univ.sum fun k => HMul.hMul (f (bernstein.z k)) ((bernstein n ‚Üëk) x))","decl":"@[simp]\ntheorem apply (n : ‚Ñï) (f : C(I, ‚Ñù)) (x : I) :\n    bernsteinApproximation n f x = ‚àë k : Fin (n + 1), f k/‚Çô * bernstein n k x := by\n  simp [bernsteinApproximation]\n\n"}
{"name":"bernsteinApproximation.Œ¥_pos","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"f : ContinuousMap (‚ÜëunitInterval) Real\nŒµ : Real\nh : LT.lt 0 Œµ\n‚ä¢ LT.lt 0 (bernsteinApproximation.Œ¥ f Œµ h)","decl":"theorem Œ¥_pos {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} : 0 < Œ¥ f Œµ h :=\n  f.modulus_pos\n\n"}
{"name":"bernsteinApproximation.lt_of_mem_S","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"f : ContinuousMap (‚ÜëunitInterval) Real\nŒµ : Real\nh : LT.lt 0 Œµ\nn : Nat\nx : ‚ÜëunitInterval\nk : Fin (HAdd.hAdd n 1)\nm : Membership.mem (bernsteinApproximation.S f Œµ h n x) k\n‚ä¢ LT.lt (abs (HSub.hSub (f (bernstein.z k)) (f x))) (HDiv.hDiv Œµ 2)","decl":"/-- If `k ‚àà S`, then `f(k/n)` is close to `f x`.\n-/\ntheorem lt_of_mem_S {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} {n : ‚Ñï} {x : I} {k : Fin (n + 1)}\n    (m : k ‚àà S f Œµ h n x) : |f k/‚Çô - f x| < Œµ / 2 := by\n  apply f.dist_lt_of_dist_lt_modulus (Œµ / 2) (half_pos h)\n  -- Porting note: `simp` fails to apply `Set.mem_toFinset` on its own\n  simpa [S, (Set.mem_toFinset)] using m\n\n"}
{"name":"bernsteinApproximation.le_of_mem_S_compl","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"f : ContinuousMap (‚ÜëunitInterval) Real\nŒµ : Real\nh : LT.lt 0 Œµ\nn : Nat\nx : ‚ÜëunitInterval\nk : Fin (HAdd.hAdd n 1)\nm : Membership.mem (HasCompl.compl (bernsteinApproximation.S f Œµ h n x)) k\n‚ä¢ LE.le 1 (HMul.hMul (HPow.hPow (bernsteinApproximation.Œ¥ f Œµ h) (-2)) (HPow.hPow (HSub.hSub ‚Üëx ‚Üë(bernstein.z k)) 2))","decl":"/-- If `k ‚àâ S`, then as `Œ¥ ‚â§ |x - k/n|`, we have the inequality `1 ‚â§ Œ¥^-2 * (x - k/n)^2`.\nThis particular formulation will be helpful later.\n-/\ntheorem le_of_mem_S_compl {f : C(I, ‚Ñù)} {Œµ : ‚Ñù} {h : 0 < Œµ} {n : ‚Ñï} {x : I} {k : Fin (n + 1)}\n    (m : k ‚àà (S f Œµ h n x)·∂ú) : (1 : ‚Ñù) ‚â§ Œ¥ f Œµ h ^ (-2 : ‚Ñ§) * ((x : ‚Ñù) - k/‚Çô) ^ 2 := by\n  -- Porting note: added parentheses to help `simp`\n  simp only [Finset.mem_compl, not_lt, Set.mem_toFinset, Set.mem_setOf_eq, S] at m\n  rw [zpow_neg, ‚Üê div_eq_inv_mul, zpow_two, ‚Üê pow_two, one_le_div (pow_pos Œ¥_pos 2), sq_le_sq,\n    abs_of_pos Œ¥_pos]\n  rwa [dist_comm] at m\n\n"}
{"name":"bernsteinApproximation_uniform","module":"Mathlib.Analysis.SpecialFunctions.Bernstein","initialProofState":"f : ContinuousMap (‚ÜëunitInterval) Real\n‚ä¢ Filter.Tendsto (fun n => bernsteinApproximation n f) Filter.atTop (nhds f)","decl":"/-- The Bernstein approximations\n```\n‚àë k : Fin (n+1), f (k/n : ‚Ñù) * n.choose k * x^k * (1-x)^(n-k)\n```\nfor a continuous function `f : C([0,1], ‚Ñù)` converge uniformly to `f` as `n` tends to infinity.\n\nThis is the proof given in [Richard Beals' *Analysis, an introduction*][beals-analysis], ¬ß7D,\nand reproduced on wikipedia.\n-/\ntheorem bernsteinApproximation_uniform (f : C(I, ‚Ñù)) :\n    Tendsto (fun n : ‚Ñï => bernsteinApproximation n f) atTop (ùìù f) := by\n  simp only [Metric.nhds_basis_ball.tendsto_right_iff, Metric.mem_ball, dist_eq_norm]\n  intro Œµ h\n  let Œ¥ := Œ¥ f Œµ h\n  have nhds_zero := tendsto_const_div_atTop_nhds_zero_nat (2 * ‚Äñf‚Äñ * Œ¥ ^ (-2 : ‚Ñ§))\n  filter_upwards [nhds_zero.eventually (gt_mem_nhds (half_pos h)), eventually_gt_atTop 0] with n nh\n    npos'\n  have npos : 0 < (n : ‚Ñù) := by positivity\n  -- As `[0,1]` is compact, it suffices to check the inequality pointwise.\n  rw [ContinuousMap.norm_lt_iff _ h]\n  intro x\n  -- The idea is to split up the sum over `k` into two sets,\n  -- `S`, where `x - k/n < Œ¥`, and its complement.\n  let S := S f Œµ h n x\n  calc\n    |(bernsteinApproximation n f - f) x| = |bernsteinApproximation n f x - f x| := rfl\n    _ = |bernsteinApproximation n f x - f x * 1| := by rw [mul_one]\n    _ = |bernsteinApproximation n f x - f x * ‚àë k : Fin (n + 1), bernstein n k x| := by\n      rw [bernstein.probability]\n    _ = |‚àë k : Fin (n + 1), (f k/‚Çô - f x) * bernstein n k x| := by\n      simp [bernsteinApproximation, Finset.mul_sum, sub_mul]\n    _ ‚â§ ‚àë k : Fin (n + 1), |(f k/‚Çô - f x) * bernstein n k x| := Finset.abs_sum_le_sum_abs _ _\n    _ = ‚àë k : Fin (n + 1), |f k/‚Çô - f x| * bernstein n k x := by\n      simp_rw [abs_mul, abs_eq_self.mpr bernstein_nonneg]\n    _ = (‚àë k ‚àà S, |f k/‚Çô - f x| * bernstein n k x) + ‚àë k ‚àà S·∂ú, |f k/‚Çô - f x| * bernstein n k x :=\n      (S.sum_add_sum_compl _).symm\n    -- We'll now deal with the terms in `S` and the terms in `S·∂ú` in separate calc blocks.\n    _ < Œµ / 2 + Œµ / 2 :=\n      (add_lt_add_of_le_of_lt ?_ ?_)\n    _ = Œµ := add_halves Œµ\n  ¬∑ -- We now work on the terms in `S`: uniform continuity and `bernstein.probability`\n    -- quickly give us a bound.\n    calc\n      ‚àë k ‚àà S, |f k/‚Çô - f x| * bernstein n k x ‚â§ ‚àë k ‚àà S, Œµ / 2 * bernstein n k x := by\n        gcongr with _ m\n        exact le_of_lt (lt_of_mem_S m)\n      _ = Œµ / 2 * ‚àë k ‚àà S, bernstein n k x := by rw [Finset.mul_sum]\n      -- In this step we increase the sum over `S` back to a sum over all of `Fin (n+1)`,\n      -- so that we can use `bernstein.probability`.\n      _ ‚â§ Œµ / 2 * ‚àë k : Fin (n + 1), bernstein n k x := by gcongr; exact S.subset_univ\n      _ = Œµ / 2 := by rw [bernstein.probability, mul_one]\n  ¬∑ -- We now turn to working on `S·∂ú`: we control the difference term just using `‚Äñf‚Äñ`,\n    -- and then insert a `Œ¥^(-2) * (x - k/n)^2` factor\n    -- (which is at least one because we are not in `S`).\n    calc\n      ‚àë k ‚àà S·∂ú, |f k/‚Çô - f x| * bernstein n k x ‚â§ ‚àë k ‚àà S·∂ú, 2 * ‚Äñf‚Äñ * bernstein n k x := by\n        gcongr\n        apply f.dist_le_two_norm\n      _ = 2 * ‚Äñf‚Äñ * ‚àë k ‚àà S·∂ú, bernstein n k x := by rw [Finset.mul_sum]\n      _ ‚â§ 2 * ‚Äñf‚Äñ * ‚àë k ‚àà S·∂ú, Œ¥ ^ (-2 : ‚Ñ§) * ((x : ‚Ñù) - k/‚Çô) ^ 2 * bernstein n k x := by\n        gcongr with _ m\n        conv_lhs => rw [‚Üê one_mul (bernstein _ _ _)]\n        gcongr\n        exact le_of_mem_S_compl m\n      -- Again enlarging the sum from `S·∂ú` to all of `Fin (n+1)`\n      _ ‚â§ 2 * ‚Äñf‚Äñ * ‚àë k : Fin (n + 1), Œ¥ ^ (-2 : ‚Ñ§) * ((x : ‚Ñù) - k/‚Çô) ^ 2 * bernstein n k x := by\n        gcongr; exact S·∂ú.subset_univ\n      _ = 2 * ‚Äñf‚Äñ * Œ¥ ^ (-2 : ‚Ñ§) * ‚àë k : Fin (n + 1), ((x : ‚Ñù) - k/‚Çô) ^ 2 * bernstein n k x := by\n        conv_rhs =>\n          rw [mul_assoc, Finset.mul_sum]\n          simp only [‚Üê mul_assoc]\n      -- `bernstein.variance` and `x ‚àà [0,1]` gives the uniform bound\n      _ = 2 * ‚Äñf‚Äñ * Œ¥ ^ (-2 : ‚Ñ§) * x * (1 - x) / n := by rw [variance npos]; ring\n      _ ‚â§ 2 * ‚Äñf‚Äñ * Œ¥ ^ (-2 : ‚Ñ§) * 1 * 1 / n := by gcongr <;> unit_interval\n      _ < Œµ / 2 := by simp only [mul_one]; exact nh\n"}
