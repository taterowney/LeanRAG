{"name":"setOf_liouville_eq_iInter_iUnion","module":"Mathlib.NumberTheory.Transcendental.Liouville.Residual","initialProofState":"⊢ Eq (setOf fun x => Liouville x) (Set.iInter fun n => Set.iUnion fun a => Set.iUnion fun b => Set.iUnion fun x => SDiff.sdiff (Metric.ball (HDiv.hDiv ↑a ↑b) (HDiv.hDiv 1 (HPow.hPow (↑b) n))) (Singleton.singleton (HDiv.hDiv ↑a ↑b)))","decl":"theorem setOf_liouville_eq_iInter_iUnion :\n    { x | Liouville x } =\n      ⋂ n : ℕ, ⋃ (a : ℤ) (b : ℤ) (_ : 1 < b),\n      ball ((a : ℝ) / b) (1 / (b : ℝ) ^ n) \\ {(a : ℝ) / b} := by\n  ext x\n  simp only [mem_iInter, mem_iUnion, Liouville, mem_setOf_eq, exists_prop, mem_diff,\n    mem_singleton_iff, mem_ball, Real.dist_eq, and_comm]\n\n"}
{"name":"IsGδ.setOf_liouville","module":"Mathlib.NumberTheory.Transcendental.Liouville.Residual","initialProofState":"⊢ IsGδ (setOf fun x => Liouville x)","decl":"theorem IsGδ.setOf_liouville : IsGδ { x | Liouville x } := by\n  rw [setOf_liouville_eq_iInter_iUnion]\n  refine .iInter fun n => IsOpen.isGδ ?_\n  refine isOpen_iUnion fun a => isOpen_iUnion fun b => isOpen_iUnion fun _hb => ?_\n  exact isOpen_ball.inter isClosed_singleton.isOpen_compl\n\n\n"}
{"name":"setOf_liouville_eq_irrational_inter_iInter_iUnion","module":"Mathlib.NumberTheory.Transcendental.Liouville.Residual","initialProofState":"⊢ Eq (setOf fun x => Liouville x) (Inter.inter (setOf fun x => Irrational x) (Set.iInter fun n => Set.iUnion fun a => Set.iUnion fun b => Set.iUnion fun x => Metric.ball (HDiv.hDiv ↑a ↑b) (HDiv.hDiv 1 (HPow.hPow (↑b) n))))","decl":"theorem setOf_liouville_eq_irrational_inter_iInter_iUnion :\n    { x | Liouville x } =\n      { x | Irrational x } ∩ ⋂ n : ℕ, ⋃ (a : ℤ) (b : ℤ) (_ : 1 < b),\n      ball (a / b) (1 / (b : ℝ) ^ n) := by\n  refine Subset.antisymm ?_ ?_\n  · refine subset_inter (fun x hx => hx.irrational) ?_\n    rw [setOf_liouville_eq_iInter_iUnion]\n    exact iInter_mono fun n => iUnion₂_mono fun a b => iUnion_mono fun _hb => diff_subset\n  · simp only [inter_iInter, inter_iUnion, setOf_liouville_eq_iInter_iUnion]\n    refine iInter_mono fun n => iUnion₂_mono fun a b => iUnion_mono fun hb => ?_\n    rw [inter_comm]\n    exact diff_subset_diff Subset.rfl (singleton_subset_iff.2 ⟨a / b, by norm_cast⟩)\n\n"}
{"name":"eventually_residual_liouville","module":"Mathlib.NumberTheory.Transcendental.Liouville.Residual","initialProofState":"⊢ Filter.Eventually (fun x => Liouville x) (residual Real)","decl":"/-- The set of Liouville numbers is a residual set. -/\ntheorem eventually_residual_liouville : ∀ᶠ x in residual ℝ, Liouville x := by\n  rw [Filter.Eventually, setOf_liouville_eq_irrational_inter_iInter_iUnion]\n  refine eventually_residual_irrational.and ?_\n  refine residual_of_dense_Gδ ?_ (Rat.isDenseEmbedding_coe_real.dense.mono ?_)\n  · exact .iInter fun n => IsOpen.isGδ <|\n          isOpen_iUnion fun a => isOpen_iUnion fun b => isOpen_iUnion fun _hb => isOpen_ball\n  · rintro _ ⟨r, rfl⟩\n    simp only [mem_iInter, mem_iUnion]\n    refine fun n => ⟨r.num * 2, r.den * 2, ?_, ?_⟩\n    · have := r.pos; omega\n    · convert @mem_ball_self ℝ _ (r : ℝ) _ _\n      · push_cast\n        -- Workaround for https://github.com/leanprover/lean4/pull/6438; this eliminates an\n        -- `Expr.mdata` that would cause `norm_cast` to skip a numeral.\n        rw [Eq.refl (2 : ℝ)]\n        norm_cast\n        simp [Rat.divInt_mul_right (two_ne_zero), Rat.mkRat_self]\n      · refine one_div_pos.2 (pow_pos (Int.cast_pos.2 ?_) _)\n        exact mul_pos (Int.natCast_pos.2 r.pos) zero_lt_two\n\n"}
{"name":"dense_liouville","module":"Mathlib.NumberTheory.Transcendental.Liouville.Residual","initialProofState":"⊢ Dense (setOf fun x => Liouville x)","decl":"/-- The set of Liouville numbers in dense. -/\ntheorem dense_liouville : Dense { x | Liouville x } :=\n  dense_of_mem_residual eventually_residual_liouville\n"}
