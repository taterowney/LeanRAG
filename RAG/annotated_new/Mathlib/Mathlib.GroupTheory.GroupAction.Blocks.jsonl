{"name":"AddAction.orbit.eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na b : X\n⊢ Or (Eq (AddAction.orbit G a) (AddAction.orbit G b)) (Disjoint (AddAction.orbit G a) (AddAction.orbit G b))","decl":"@[to_additive]\ntheorem orbit.eq_or_disjoint (a b : X) :\n    orbit G a = orbit G b ∨ Disjoint (orbit G a) (orbit G b) := by\n  apply (em (Disjoint (orbit G a) (orbit G b))).symm.imp _ id\n  simp +contextual\n    only [Set.not_disjoint_iff, ← orbit_eq_iff, forall_exists_index, and_imp, eq_comm, implies_true]\n\n"}
{"name":"MulAction.orbit.eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na b : X\n⊢ Or (Eq (MulAction.orbit G a) (MulAction.orbit G b)) (Disjoint (MulAction.orbit G a) (MulAction.orbit G b))","decl":"@[to_additive]\ntheorem orbit.eq_or_disjoint (a b : X) :\n    orbit G a = orbit G b ∨ Disjoint (orbit G a) (orbit G b) := by\n  apply (em (Disjoint (orbit G a) (orbit G b))).symm.imp _ id\n  simp +contextual\n    only [Set.not_disjoint_iff, ← orbit_eq_iff, forall_exists_index, and_imp, eq_comm, implies_true]\n\n"}
{"name":"AddAction.orbit.pairwiseDisjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\n⊢ (Set.range fun x => AddAction.orbit G x).PairwiseDisjoint id","decl":"@[to_additive]\ntheorem orbit.pairwiseDisjoint :\n    (Set.range fun x : X => orbit G x).PairwiseDisjoint id := by\n  rintro s ⟨x, rfl⟩ t ⟨y, rfl⟩ h\n  contrapose! h\n  exact (orbit.eq_or_disjoint x y).resolve_right h\n\n"}
{"name":"MulAction.orbit.pairwiseDisjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\n⊢ (Set.range fun x => MulAction.orbit G x).PairwiseDisjoint id","decl":"@[to_additive]\ntheorem orbit.pairwiseDisjoint :\n    (Set.range fun x : X => orbit G x).PairwiseDisjoint id := by\n  rintro s ⟨x, rfl⟩ t ⟨y, rfl⟩ h\n  contrapose! h\n  exact (orbit.eq_or_disjoint x y).resolve_right h\n\n"}
{"name":"MulAction.IsPartition.of_orbits","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\n⊢ Setoid.IsPartition (Set.range fun a => MulAction.orbit G a)","decl":"/-- Orbits of an element form a partition -/\n@[to_additive \"Orbits of an element of a partition\"]\ntheorem IsPartition.of_orbits :\n    Setoid.IsPartition (Set.range fun a : X => orbit G a) := by\n  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty\n  · intro x\n    exact ⟨_, ⟨x, rfl⟩, mem_orbit_self x⟩\n  · rintro ⟨a, ha : orbit G a = ∅⟩\n    exact (MulAction.orbit_nonempty a).ne_empty ha\n\n"}
{"name":"AddAction.IsPartition.of_orbits","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\n⊢ Setoid.IsPartition (Set.range fun a => AddAction.orbit G a)","decl":"/-- Orbits of an element form a partition -/\n@[to_additive \"Orbits of an element of a partition\"]\ntheorem IsPartition.of_orbits :\n    Setoid.IsPartition (Set.range fun a : X => orbit G a) := by\n  apply orbit.pairwiseDisjoint.isPartition_of_exists_of_ne_empty\n  · intro x\n    exact ⟨_, ⟨x, rfl⟩, mem_orbit_self x⟩\n  · rintro ⟨a, ha : orbit G a = ∅⟩\n    exact (MulAction.orbit_nonempty a).ne_empty ha\n\n"}
{"name":"AddAction.IsTrivialBlock.image","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\nN : Type u_5\nβ : Type u_6\ninst✝³ : AddMonoid M\ninst✝² : AddAction M α\ninst✝¹ : AddMonoid N\ninst✝ : AddAction N β\nφ : M → N\nf : AddActionHom φ α β\nhf : Function.Surjective ⇑f\nB : Set α\nhB : AddAction.IsTrivialBlock B\n⊢ AddAction.IsTrivialBlock (Set.image (⇑f) B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.image {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Surjective f) {B : Set α} (hB : IsTrivialBlock B) :\n    IsTrivialBlock (f '' B) := by\n  cases' hB with hB hB\n  · apply Or.intro_left; apply Set.Subsingleton.image hB\n  · apply Or.intro_right; rw [hB]\n    simp only [Set.top_eq_univ, Set.image_univ, Set.range_eq_univ, hf]\n\n"}
{"name":"MulAction.IsTrivialBlock.image","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\nN : Type u_5\nβ : Type u_6\ninst✝³ : Monoid M\ninst✝² : MulAction M α\ninst✝¹ : Monoid N\ninst✝ : MulAction N β\nφ : M → N\nf : MulActionHom φ α β\nhf : Function.Surjective ⇑f\nB : Set α\nhB : MulAction.IsTrivialBlock B\n⊢ MulAction.IsTrivialBlock (Set.image (⇑f) B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.image {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Surjective f) {B : Set α} (hB : IsTrivialBlock B) :\n    IsTrivialBlock (f '' B) := by\n  cases' hB with hB hB\n  · apply Or.intro_left; apply Set.Subsingleton.image hB\n  · apply Or.intro_right; rw [hB]\n    simp only [Set.top_eq_univ, Set.image_univ, Set.range_eq_univ, hf]\n\n"}
{"name":"MulAction.IsTrivialBlock.preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\nN : Type u_5\nβ : Type u_6\ninst✝³ : Monoid M\ninst✝² : MulAction M α\ninst✝¹ : Monoid N\ninst✝ : MulAction N β\nφ : M → N\nf : MulActionHom φ α β\nhf : Function.Injective ⇑f\nB : Set β\nhB : MulAction.IsTrivialBlock B\n⊢ MulAction.IsTrivialBlock (Set.preimage (⇑f) B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.preimage {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Injective f) {B : Set β} (hB : IsTrivialBlock B) :\n    IsTrivialBlock (f ⁻¹' B) := by\n  cases' hB with hB hB\n  · apply Or.intro_left; exact Set.Subsingleton.preimage hB hf\n  · apply Or.intro_right; simp only [hB, Set.top_eq_univ]; apply Set.preimage_univ\n\n"}
{"name":"AddAction.IsTrivialBlock.preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\nN : Type u_5\nβ : Type u_6\ninst✝³ : AddMonoid M\ninst✝² : AddAction M α\ninst✝¹ : AddMonoid N\ninst✝ : AddAction N β\nφ : M → N\nf : AddActionHom φ α β\nhf : Function.Injective ⇑f\nB : Set β\nhB : AddAction.IsTrivialBlock B\n⊢ AddAction.IsTrivialBlock (Set.preimage (⇑f) B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.preimage {φ : M → N} {f : α →ₑ[φ] β}\n    (hf : Function.Injective f) {B : Set β} (hB : IsTrivialBlock B) :\n    IsTrivialBlock (f ⁻¹' B) := by\n  cases' hB with hB hB\n  · apply Or.intro_left; exact Set.Subsingleton.preimage hB hf\n  · apply Or.intro_right; simp only [hB, Set.top_eq_univ]; apply Set.preimage_univ\n\n"}
{"name":"AddAction.IsTrivialBlock.vadd","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\ninst✝¹ : AddGroup M\ninst✝ : AddAction M α\nB : Set α\nhB : AddAction.IsTrivialBlock B\ng : M\n⊢ AddAction.IsTrivialBlock (HVAdd.hVAdd g B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.smul {B : Set α} (hB : IsTrivialBlock B) (g : M) :\n    IsTrivialBlock (g • B) := by\n  cases hB with\n  | inl h =>\n    left\n    exact (Function.Injective.subsingleton_image_iff (MulAction.injective g)).mpr h\n  | inr h =>\n    right\n    rw [h, ← Set.image_smul, Set.image_univ_of_surjective (MulAction.surjective g)]\n\n"}
{"name":"MulAction.IsTrivialBlock.smul","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\ninst✝¹ : Group M\ninst✝ : MulAction M α\nB : Set α\nhB : MulAction.IsTrivialBlock B\ng : M\n⊢ MulAction.IsTrivialBlock (HSMul.hSMul g B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.smul {B : Set α} (hB : IsTrivialBlock B) (g : M) :\n    IsTrivialBlock (g • B) := by\n  cases hB with\n  | inl h =>\n    left\n    exact (Function.Injective.subsingleton_image_iff (MulAction.injective g)).mpr h\n  | inr h =>\n    right\n    rw [h, ← Set.image_smul, Set.image_univ_of_surjective (MulAction.surjective g)]\n\n"}
{"name":"AddAction.IsTrivialBlock.vadd_iff","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\ninst✝¹ : AddGroup M\ninst✝ : AddAction M α\nB : Set α\ng : M\n⊢ Iff (AddAction.IsTrivialBlock (HVAdd.hVAdd g B)) (AddAction.IsTrivialBlock B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.smul_iff {B : Set α} (g : M) :\n    IsTrivialBlock (g • B) ↔ IsTrivialBlock B := by\n  constructor\n  · intro H\n    convert IsTrivialBlock.smul H g⁻¹\n    simp only [inv_smul_smul]\n  · intro H\n    exact IsTrivialBlock.smul H g\n\n"}
{"name":"MulAction.IsTrivialBlock.smul_iff","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_3\nα : Type u_4\ninst✝¹ : Group M\ninst✝ : MulAction M α\nB : Set α\ng : M\n⊢ Iff (MulAction.IsTrivialBlock (HSMul.hSMul g B)) (MulAction.IsTrivialBlock B)","decl":"@[to_additive]\ntheorem IsTrivialBlock.smul_iff {B : Set α} (g : M) :\n    IsTrivialBlock (g • B) ↔ IsTrivialBlock B := by\n  constructor\n  · intro H\n    convert IsTrivialBlock.smul H g⁻¹\n    simp only [inv_smul_smul]\n  · intro H\n    exact IsTrivialBlock.smul H g\n\n"}
{"name":"MulAction.isBlock_iff_smul_eq_smul_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ ⦃g₁ g₂ : G⦄, (Inter.inter (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)).Nonempty → Eq (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_smul_of_nonempty :\n    IsBlock G B ↔ ∀ ⦃g₁ g₂ : G⦄, (g₁ • B ∩ g₂ • B).Nonempty → g₁ • B = g₂ • B := by\n  simp_rw [IsBlock, ← not_disjoint_iff_nonempty_inter, not_imp_comm]\n\n"}
{"name":"AddAction.isBlock_iff_vadd_eq_vadd_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ ⦃g₁ g₂ : G⦄, (Inter.inter (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)).Nonempty → Eq (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_smul_of_nonempty :\n    IsBlock G B ↔ ∀ ⦃g₁ g₂ : G⦄, (g₁ • B ∩ g₂ • B).Nonempty → g₁ • B = g₂ • B := by\n  simp_rw [IsBlock, ← not_disjoint_iff_nonempty_inter, not_imp_comm]\n\n"}
{"name":"AddAction.isBlock_iff_pairwiseDisjoint_range_vadd","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) ((Set.range fun g => HVAdd.hVAdd g B).PairwiseDisjoint id)","decl":"@[to_additive]\nlemma isBlock_iff_pairwiseDisjoint_range_smul :\n    IsBlock G B ↔ (range fun g : G ↦ g • B).PairwiseDisjoint id := pairwiseDisjoint_range_iff.symm\n\n"}
{"name":"MulAction.isBlock_iff_pairwiseDisjoint_range_smul","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) ((Set.range fun g => HSMul.hSMul g B).PairwiseDisjoint id)","decl":"@[to_additive]\nlemma isBlock_iff_pairwiseDisjoint_range_smul :\n    IsBlock G B ↔ (range fun g : G ↦ g • B).PairwiseDisjoint id := pairwiseDisjoint_range_iff.symm\n\n"}
{"name":"AddAction.isBlock_iff_vadd_eq_vadd_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ (g₁ g₂ : G), Or (Eq (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)) (Disjoint (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_smul_or_disjoint :\n    IsBlock G B ↔ ∀ g₁ g₂ : G, g₁ • B = g₂ • B ∨ Disjoint (g₁ • B) (g₂ • B) :=\n  forall₂_congr fun _ _ ↦ or_iff_not_imp_left.symm\n\n"}
{"name":"MulAction.isBlock_iff_smul_eq_smul_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ (g₁ g₂ : G), Or (Eq (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)) (Disjoint (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_smul_or_disjoint :\n    IsBlock G B ↔ ∀ g₁ g₂ : G, g₁ • B = g₂ • B ∨ Disjoint (g₁ • B) (g₂ • B) :=\n  forall₂_congr fun _ _ ↦ or_iff_not_imp_left.symm\n\n"}
{"name":"AddAction.IsBlock.vadd_eq_vadd_of_subset","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\ng₁ g₂ : G\nhB : AddAction.IsBlock G B\nhg : HasSubset.Subset (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)\n⊢ Eq (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)","decl":"@[to_additive]\nlemma IsBlock.smul_eq_smul_of_subset (hB : IsBlock G B) (hg : g₁ • B ⊆ g₂ • B) :\n    g₁ • B = g₂ • B := by\n  by_contra! hg'\n  obtain rfl : B = ∅ := by simpa using (hB hg').eq_bot_of_le hg\n  simp at hg'\n\n"}
{"name":"MulAction.IsBlock.smul_eq_smul_of_subset","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\ng₁ g₂ : G\nhB : MulAction.IsBlock G B\nhg : HasSubset.Subset (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)\n⊢ Eq (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)","decl":"@[to_additive]\nlemma IsBlock.smul_eq_smul_of_subset (hB : IsBlock G B) (hg : g₁ • B ⊆ g₂ • B) :\n    g₁ • B = g₂ • B := by\n  by_contra! hg'\n  obtain rfl : B = ∅ := by simpa using (hB hg').eq_bot_of_le hg\n  simp at hg'\n\n"}
{"name":"MulAction.IsBlock.not_smul_set_ssubset_smul_set","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\ng₁ g₂ : G\nhB : MulAction.IsBlock G B\n⊢ Not (HasSSubset.SSubset (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B))","decl":"@[to_additive]\nlemma IsBlock.not_smul_set_ssubset_smul_set (hB : IsBlock G B) : ¬ g₁ • B ⊂ g₂ • B :=\n  fun hab ↦ hab.ne <| hB.smul_eq_smul_of_subset hab.subset\n\n"}
{"name":"AddAction.IsBlock.not_vadd_set_ssubset_vadd_set","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\ng₁ g₂ : G\nhB : AddAction.IsBlock G B\n⊢ Not (HasSSubset.SSubset (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B))","decl":"@[to_additive]\nlemma IsBlock.not_smul_set_ssubset_smul_set (hB : IsBlock G B) : ¬ g₁ • B ⊂ g₂ • B :=\n  fun hab ↦ hab.ne <| hB.smul_eq_smul_of_subset hab.subset\n\n"}
{"name":"MulAction.IsBlock.disjoint_smul_set_smul","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\ns : Set G\ng : G\nhB : MulAction.IsBlock G B\nhgs : Not (HasSubset.Subset (HSMul.hSMul g B) (HSMul.hSMul s B))\n⊢ Disjoint (HSMul.hSMul g B) (HSMul.hSMul s B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_set_smul (hB : IsBlock G B) (hgs : ¬ g • B ⊆ s • B) :\n    Disjoint (g • B) (s • B) := by\n  rw [← iUnion_smul_set, disjoint_iUnion₂_right]\n  exact fun b hb ↦ hB fun h ↦ hgs <| h.trans_subset <| smul_set_subset_smul hb\n\n"}
{"name":"AddAction.IsBlock.disjoint_vadd_set_vadd","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\ns : Set G\ng : G\nhB : AddAction.IsBlock G B\nhgs : Not (HasSubset.Subset (HVAdd.hVAdd g B) (HVAdd.hVAdd s B))\n⊢ Disjoint (HVAdd.hVAdd g B) (HVAdd.hVAdd s B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_set_smul (hB : IsBlock G B) (hgs : ¬ g • B ⊆ s • B) :\n    Disjoint (g • B) (s • B) := by\n  rw [← iUnion_smul_set, disjoint_iUnion₂_right]\n  exact fun b hb ↦ hB fun h ↦ hgs <| h.trans_subset <| smul_set_subset_smul hb\n\n"}
{"name":"AddAction.IsBlock.disjoint_vadd_vadd_set","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\ns : Set G\ng : G\nhB : AddAction.IsBlock G B\nhgs : Not (HasSubset.Subset (HVAdd.hVAdd g B) (HVAdd.hVAdd s B))\n⊢ Disjoint (HVAdd.hVAdd s B) (HVAdd.hVAdd g B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_smul_set (hB : IsBlock G B) (hgs : ¬ g • B ⊆ s • B) :\n    Disjoint (s • B) (g • B) := (hB.disjoint_smul_set_smul hgs).symm\n\n"}
{"name":"MulAction.IsBlock.disjoint_smul_smul_set","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\ns : Set G\ng : G\nhB : MulAction.IsBlock G B\nhgs : Not (HasSubset.Subset (HSMul.hSMul g B) (HSMul.hSMul s B))\n⊢ Disjoint (HSMul.hSMul s B) (HSMul.hSMul g B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_smul_set (hB : IsBlock G B) (hgs : ¬ g • B ⊆ s • B) :\n    Disjoint (s • B) (g • B) := (hB.disjoint_smul_set_smul hgs).symm\n\n"}
{"name":"AddAction.IsBlock.vadd_eq_vadd_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\na✝¹ : AddAction.IsBlock G B\ng₁ g₂ : G\na✝ : (Inter.inter (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)).Nonempty\n⊢ Eq (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)","decl":"@[to_additive]\nalias ⟨IsBlock.smul_eq_smul_of_nonempty, _⟩ := isBlock_iff_smul_eq_smul_of_nonempty\n"}
{"name":"MulAction.IsBlock.smul_eq_smul_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\na✝¹ : MulAction.IsBlock G B\ng₁ g₂ : G\na✝ : (Inter.inter (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)).Nonempty\n⊢ Eq (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)","decl":"@[to_additive]\nalias ⟨IsBlock.smul_eq_smul_of_nonempty, _⟩ := isBlock_iff_smul_eq_smul_of_nonempty\n"}
{"name":"AddAction.IsBlock.pairwiseDisjoint_range_vadd","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\na✝ : AddAction.IsBlock G B\n⊢ (Set.range fun g => HVAdd.hVAdd g B).PairwiseDisjoint id","decl":"@[to_additive]\nalias ⟨IsBlock.pairwiseDisjoint_range_smul, _⟩ := isBlock_iff_pairwiseDisjoint_range_smul\n"}
{"name":"MulAction.IsBlock.pairwiseDisjoint_range_smul","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\na✝ : MulAction.IsBlock G B\n⊢ (Set.range fun g => HSMul.hSMul g B).PairwiseDisjoint id","decl":"@[to_additive]\nalias ⟨IsBlock.pairwiseDisjoint_range_smul, _⟩ := isBlock_iff_pairwiseDisjoint_range_smul\n"}
{"name":"MulAction.IsBlock.smul_eq_smul_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\na✝ : MulAction.IsBlock G B\ng₁ g₂ : G\n⊢ Or (Eq (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B)) (Disjoint (HSMul.hSMul g₁ B) (HSMul.hSMul g₂ B))","decl":"@[to_additive]\nalias ⟨IsBlock.smul_eq_smul_or_disjoint, _⟩ := isBlock_iff_smul_eq_smul_or_disjoint\n\n"}
{"name":"AddAction.IsBlock.vadd_eq_vadd_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\na✝ : AddAction.IsBlock G B\ng₁ g₂ : G\n⊢ Or (Eq (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B)) (Disjoint (HVAdd.hVAdd g₁ B) (HVAdd.hVAdd g₂ B))","decl":"@[to_additive]\nalias ⟨IsBlock.smul_eq_smul_or_disjoint, _⟩ := isBlock_iff_smul_eq_smul_or_disjoint\n\n"}
{"name":"MulAction.IsFixedBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\nhfB : MulAction.IsFixedBlock G B\n⊢ MulAction.IsBlock G B","decl":"/-- A fixed block is a block. -/\n@[to_additive \"A fixed block is a block.\"]\nlemma IsFixedBlock.isBlock (hfB : IsFixedBlock G B) : IsBlock G B := by simp [IsBlock, hfB _]\n\n"}
{"name":"AddAction.IsFixedBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\nhfB : AddAction.IsFixedBlock G B\n⊢ AddAction.IsBlock G B","decl":"/-- A fixed block is a block. -/\n@[to_additive \"A fixed block is a block.\"]\nlemma IsFixedBlock.isBlock (hfB : IsFixedBlock G B) : IsBlock G B := by simp [IsBlock, hfB _]\n\n"}
{"name":"AddAction.IsBlock.empty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\n⊢ AddAction.IsBlock G EmptyCollection.emptyCollection","decl":"/-- The empty set is a block. -/\n@[to_additive (attr := simp) \"The empty set is a block.\"]\nlemma IsBlock.empty : IsBlock G (∅ : Set X) := by simp [IsBlock]\n\n"}
{"name":"MulAction.IsBlock.empty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\n⊢ MulAction.IsBlock G EmptyCollection.emptyCollection","decl":"/-- The empty set is a block. -/\n@[to_additive (attr := simp) \"The empty set is a block.\"]\nlemma IsBlock.empty : IsBlock G (∅ : Set X) := by simp [IsBlock]\n\n"}
{"name":"MulAction.IsBlock.singleton","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\na : X\n⊢ MulAction.IsBlock G (Singleton.singleton a)","decl":"/-- A singleton is a block. -/\n@[to_additive \"A singleton is a block.\"]\nlemma IsBlock.singleton : IsBlock G ({a} : Set X) := by simp [IsBlock]\n\n"}
{"name":"AddAction.IsBlock.singleton","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\na : X\n⊢ AddAction.IsBlock G (Singleton.singleton a)","decl":"/-- A singleton is a block. -/\n@[to_additive \"A singleton is a block.\"]\nlemma IsBlock.singleton : IsBlock G ({a} : Set X) := by simp [IsBlock]\n\n"}
{"name":"AddAction.IsBlock.of_subsingleton","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\nhB : B.Subsingleton\n⊢ AddAction.IsBlock G B","decl":"/-- Subsingletons are (trivial) blocks. -/\n@[to_additive \"Subsingletons are (trivial) blocks.\"]\nlemma IsBlock.of_subsingleton (hB : B.Subsingleton) : IsBlock G B :=\n  hB.induction_on .empty fun _ ↦ .singleton\n\n"}
{"name":"MulAction.IsBlock.of_subsingleton","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\nhB : B.Subsingleton\n⊢ MulAction.IsBlock G B","decl":"/-- Subsingletons are (trivial) blocks. -/\n@[to_additive \"Subsingletons are (trivial) blocks.\"]\nlemma IsBlock.of_subsingleton (hB : B.Subsingleton) : IsBlock G B :=\n  hB.induction_on .empty fun _ ↦ .singleton\n\n"}
{"name":"AddAction.IsFixedBlock.isInvariantBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : VAdd G X\nB : Set X\nhB : AddAction.IsFixedBlock G B\n⊢ AddAction.IsInvariantBlock G B","decl":"/-- A fixed block is an invariant block. -/\n@[to_additive \"A fixed block is an invariant block.\"]\nlemma IsFixedBlock.isInvariantBlock (hB : IsFixedBlock G B) : IsInvariantBlock G B :=\n  fun _ ↦ (hB _).le\n\n"}
{"name":"MulAction.IsFixedBlock.isInvariantBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝ : SMul G X\nB : Set X\nhB : MulAction.IsFixedBlock G B\n⊢ MulAction.IsInvariantBlock G B","decl":"/-- A fixed block is an invariant block. -/\n@[to_additive \"A fixed block is an invariant block.\"]\nlemma IsFixedBlock.isInvariantBlock (hB : IsFixedBlock G B) : IsInvariantBlock G B :=\n  fun _ ↦ (hB _).le\n\n"}
{"name":"MulAction.IsBlock.disjoint_smul_right","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nB : Set X\ns : Set M\nhB : MulAction.IsBlock M B\nhs : Not (HasSubset.Subset B (HSMul.hSMul s B))\n⊢ Disjoint B (HSMul.hSMul s B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_right (hB : IsBlock M B) (hs : ¬ B ⊆ s • B) : Disjoint B (s • B) := by\n  simpa using hB.disjoint_smul_set_smul (g := 1) (by simpa using hs)\n\n"}
{"name":"AddAction.IsBlock.disjoint_vadd_right","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nB : Set X\ns : Set M\nhB : AddAction.IsBlock M B\nhs : Not (HasSubset.Subset B (HVAdd.hVAdd s B))\n⊢ Disjoint B (HVAdd.hVAdd s B)","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_right (hB : IsBlock M B) (hs : ¬ B ⊆ s • B) : Disjoint B (s • B) := by\n  simpa using hB.disjoint_smul_set_smul (g := 1) (by simpa using hs)\n\n"}
{"name":"MulAction.IsBlock.disjoint_smul_left","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nB : Set X\ns : Set M\nhB : MulAction.IsBlock M B\nhs : Not (HasSubset.Subset B (HSMul.hSMul s B))\n⊢ Disjoint (HSMul.hSMul s B) B","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_left (hB : IsBlock M B) (hs : ¬ B ⊆ s • B) : Disjoint (s • B) B :=\n  (hB.disjoint_smul_right hs).symm\n\n"}
{"name":"AddAction.IsBlock.disjoint_vadd_left","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nB : Set X\ns : Set M\nhB : AddAction.IsBlock M B\nhs : Not (HasSubset.Subset B (HVAdd.hVAdd s B))\n⊢ Disjoint (HVAdd.hVAdd s B) B","decl":"@[to_additive]\nlemma IsBlock.disjoint_smul_left (hB : IsBlock M B) (hs : ¬ B ⊆ s • B) : Disjoint (s • B) B :=\n  (hB.disjoint_smul_right hs).symm\n\n"}
{"name":"MulAction.isBlock_iff_disjoint_smul_of_ne","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ ⦃g : G⦄, Ne (HSMul.hSMul g B) B → Disjoint (HSMul.hSMul g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_disjoint_smul_of_ne :\n    IsBlock G B ↔ ∀ ⦃g : G⦄, g • B ≠ B → Disjoint (g • B) B := by\n  refine ⟨fun hB g ↦ by simpa using hB (g₂ := 1), fun hB g₁ g₂ h ↦ ?_⟩\n  simp only [disjoint_smul_set_right, ne_eq, ← inv_smul_eq_iff, smul_smul] at h ⊢\n  exact hB h\n\n"}
{"name":"AddAction.isBlock_iff_disjoint_vadd_of_ne","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ ⦃g : G⦄, Ne (HVAdd.hVAdd g B) B → Disjoint (HVAdd.hVAdd g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_disjoint_smul_of_ne :\n    IsBlock G B ↔ ∀ ⦃g : G⦄, g • B ≠ B → Disjoint (g • B) B := by\n  refine ⟨fun hB g ↦ by simpa using hB (g₂ := 1), fun hB g₁ g₂ h ↦ ?_⟩\n  simp only [disjoint_smul_set_right, ne_eq, ← inv_smul_eq_iff, smul_smul] at h ⊢\n  exact hB h\n\n"}
{"name":"MulAction.isBlock_iff_smul_eq_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ ⦃g : G⦄, (Inter.inter (HSMul.hSMul g B) B).Nonempty → Eq (HSMul.hSMul g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_of_nonempty :\n    IsBlock G B ↔ ∀ ⦃g : G⦄, (g • B ∩ B).Nonempty → g • B = B := by\n  simp_rw [isBlock_iff_disjoint_smul_of_ne, ← not_disjoint_iff_nonempty_inter, not_imp_comm]\n\n"}
{"name":"AddAction.isBlock_iff_vadd_eq_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ ⦃g : G⦄, (Inter.inter (HVAdd.hVAdd g B) B).Nonempty → Eq (HVAdd.hVAdd g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_of_nonempty :\n    IsBlock G B ↔ ∀ ⦃g : G⦄, (g • B ∩ B).Nonempty → g • B = B := by\n  simp_rw [isBlock_iff_disjoint_smul_of_ne, ← not_disjoint_iff_nonempty_inter, not_imp_comm]\n\n"}
{"name":"MulAction.isBlock_iff_smul_eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ (g : G), Or (Eq (HSMul.hSMul g B) B) (Disjoint (HSMul.hSMul g B) B))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_or_disjoint :\n    IsBlock G B ↔ ∀ g : G, g • B = B ∨ Disjoint (g • B) B :=\n  isBlock_iff_disjoint_smul_of_ne.trans <| forall_congr' fun _ ↦ or_iff_not_imp_left.symm\n\n"}
{"name":"AddAction.isBlock_iff_vadd_eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ (g : G), Or (Eq (HVAdd.hVAdd g B) B) (Disjoint (HVAdd.hVAdd g B) B))","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_or_disjoint :\n    IsBlock G B ↔ ∀ g : G, g • B = B ∨ Disjoint (g • B) B :=\n  isBlock_iff_disjoint_smul_of_ne.trans <| forall_congr' fun _ ↦ or_iff_not_imp_left.symm\n\n"}
{"name":"MulAction.isBlock_iff_smul_eq_of_mem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsBlock G B) (∀ ⦃g : G⦄ ⦃a : X⦄, Membership.mem B a → Membership.mem B (HSMul.hSMul g a) → Eq (HSMul.hSMul g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_of_mem :\n    IsBlock G B ↔ ∀ ⦃g : G⦄ ⦃a : X⦄, a ∈ B → g • a ∈ B → g • B = B := by\n  simp [isBlock_iff_smul_eq_of_nonempty, Set.Nonempty, mem_smul_set]\n\n"}
{"name":"AddAction.isBlock_iff_vadd_eq_of_mem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsBlock G B) (∀ ⦃g : G⦄ ⦃a : X⦄, Membership.mem B a → Membership.mem B (HVAdd.hVAdd g a) → Eq (HVAdd.hVAdd g B) B)","decl":"@[to_additive]\nlemma isBlock_iff_smul_eq_of_mem :\n    IsBlock G B ↔ ∀ ⦃g : G⦄ ⦃a : X⦄, a ∈ B → g • a ∈ B → g • B = B := by\n  simp [isBlock_iff_smul_eq_of_nonempty, Set.Nonempty, mem_smul_set]\n\n"}
{"name":"MulAction.IsBlock.disjoint_smul_of_ne","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\na✝¹ : MulAction.IsBlock G B\ng : G\na✝ : Ne (HSMul.hSMul g B) B\n⊢ Disjoint (HSMul.hSMul g B) B","decl":"@[to_additive] alias ⟨IsBlock.disjoint_smul_of_ne, _⟩ := isBlock_iff_disjoint_smul_of_ne\n"}
{"name":"AddAction.IsBlock.disjoint_vadd_of_ne","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\na✝¹ : AddAction.IsBlock G B\ng : G\na✝ : Ne (HVAdd.hVAdd g B) B\n⊢ Disjoint (HVAdd.hVAdd g B) B","decl":"@[to_additive] alias ⟨IsBlock.disjoint_smul_of_ne, _⟩ := isBlock_iff_disjoint_smul_of_ne\n"}
{"name":"MulAction.IsBlock.smul_eq_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\na✝¹ : MulAction.IsBlock G B\ng : G\na✝ : (Inter.inter (HSMul.hSMul g B) B).Nonempty\n⊢ Eq (HSMul.hSMul g B) B","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_of_nonempty, _⟩ := isBlock_iff_smul_eq_of_nonempty\n"}
{"name":"AddAction.IsBlock.vadd_eq_of_nonempty","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\na✝¹ : AddAction.IsBlock G B\ng : G\na✝ : (Inter.inter (HVAdd.hVAdd g B) B).Nonempty\n⊢ Eq (HVAdd.hVAdd g B) B","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_of_nonempty, _⟩ := isBlock_iff_smul_eq_of_nonempty\n"}
{"name":"AddAction.IsBlock.vadd_eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\na✝ : AddAction.IsBlock G B\ng : G\n⊢ Or (Eq (HVAdd.hVAdd g B) B) (Disjoint (HVAdd.hVAdd g B) B)","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_or_disjoint, _⟩ := isBlock_iff_smul_eq_or_disjoint\n"}
{"name":"MulAction.IsBlock.smul_eq_or_disjoint","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\na✝ : MulAction.IsBlock G B\ng : G\n⊢ Or (Eq (HSMul.hSMul g B) B) (Disjoint (HSMul.hSMul g B) B)","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_or_disjoint, _⟩ := isBlock_iff_smul_eq_or_disjoint\n"}
{"name":"MulAction.IsBlock.smul_eq_of_mem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\na✝² : MulAction.IsBlock G B\ng : G\na : X\na✝¹ : Membership.mem B a\na✝ : Membership.mem B (HSMul.hSMul g a)\n⊢ Eq (HSMul.hSMul g B) B","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_of_mem, _⟩ := isBlock_iff_smul_eq_of_mem\n\n-- TODO: Generalise to `SubgroupClass`\n"}
{"name":"AddAction.IsBlock.vadd_eq_of_mem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\na✝² : AddAction.IsBlock G B\ng : G\na : X\na✝¹ : Membership.mem B a\na✝ : Membership.mem B (HVAdd.hVAdd g a)\n⊢ Eq (HVAdd.hVAdd g B) B","decl":"@[to_additive] alias ⟨IsBlock.smul_eq_of_mem, _⟩ := isBlock_iff_smul_eq_of_mem\n\n-- TODO: Generalise to `SubgroupClass`\n"}
{"name":"MulAction.IsBlock.subgroup","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nH : Subgroup G\nhB : MulAction.IsBlock G B\n⊢ MulAction.IsBlock (Subtype fun x => Membership.mem H x) B","decl":"/-- If `B` is a `G`-block, then it is also a `H`-block for any subgroup `H` of `G`. -/\n@[to_additive\n\"If `B` is a `G`-block, then it is also a `H`-block for any subgroup `H` of `G`.\"]\nlemma IsBlock.subgroup {H : Subgroup G} (hB : IsBlock G B) : IsBlock H B := fun _ _ h ↦ hB h\n\n"}
{"name":"AddAction.IsBlock.addSubgroup","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nH : AddSubgroup G\nhB : AddAction.IsBlock G B\n⊢ AddAction.IsBlock (Subtype fun x => Membership.mem H x) B","decl":"/-- If `B` is a `G`-block, then it is also a `H`-block for any subgroup `H` of `G`. -/\n@[to_additive\n\"If `B` is a `G`-block, then it is also a `H`-block for any subgroup `H` of `G`.\"]\nlemma IsBlock.subgroup {H : Subgroup G} (hB : IsBlock G B) : IsBlock H B := fun _ _ h ↦ hB h\n\n"}
{"name":"AddAction.isInvariantBlock_iff_isFixedBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsInvariantBlock G B) (AddAction.IsFixedBlock G B)","decl":"/-- A block of a group action is invariant iff it is fixed. -/\n@[to_additive \"A block of a group action is invariant iff it is fixed.\"]\nlemma isInvariantBlock_iff_isFixedBlock : IsInvariantBlock G B ↔ IsFixedBlock G B :=\n  ⟨fun hB g ↦ (hB g).antisymm <| subset_smul_set_iff.2 <| hB _, IsFixedBlock.isInvariantBlock⟩\n\n"}
{"name":"MulAction.isInvariantBlock_iff_isFixedBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsInvariantBlock G B) (MulAction.IsFixedBlock G B)","decl":"/-- A block of a group action is invariant iff it is fixed. -/\n@[to_additive \"A block of a group action is invariant iff it is fixed.\"]\nlemma isInvariantBlock_iff_isFixedBlock : IsInvariantBlock G B ↔ IsFixedBlock G B :=\n  ⟨fun hB g ↦ (hB g).antisymm <| subset_smul_set_iff.2 <| hB _, IsFixedBlock.isInvariantBlock⟩\n\n"}
{"name":"MulAction.IsInvariantBlock.isFixedBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\na✝ : MulAction.IsInvariantBlock G B\n⊢ MulAction.IsFixedBlock G B","decl":"/-- An invariant block of a group action is a fixed block. -/\n@[to_additive \"An invariant block of a group action is a fixed block.\"]\nalias ⟨IsInvariantBlock.isFixedBlock, _⟩ := isInvariantBlock_iff_isFixedBlock\n\n"}
{"name":"AddAction.IsInvariantBlock.isFixedBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\na✝ : AddAction.IsInvariantBlock G B\n⊢ AddAction.IsFixedBlock G B","decl":"/-- An invariant block of a group action is a fixed block. -/\n@[to_additive \"An invariant block of a group action is a fixed block.\"]\nalias ⟨IsInvariantBlock.isFixedBlock, _⟩ := isInvariantBlock_iff_isFixedBlock\n\n"}
{"name":"MulAction.IsInvariantBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nhB : MulAction.IsInvariantBlock G B\n⊢ MulAction.IsBlock G B","decl":"/-- An invariant block  of a group action is a block. -/\n@[to_additive \"An invariant block of a group action is a block.\"]\nlemma IsInvariantBlock.isBlock (hB : IsInvariantBlock G B) : IsBlock G B := hB.isFixedBlock.isBlock\n\n"}
{"name":"AddAction.IsInvariantBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nhB : AddAction.IsInvariantBlock G B\n⊢ AddAction.IsBlock G B","decl":"/-- An invariant block  of a group action is a block. -/\n@[to_additive \"An invariant block of a group action is a block.\"]\nlemma IsInvariantBlock.isBlock (hB : IsInvariantBlock G B) : IsBlock G B := hB.isFixedBlock.isBlock\n\n"}
{"name":"MulAction.IsFixedBlock.univ","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\n⊢ MulAction.IsFixedBlock G Set.univ","decl":"/-- The full set is a fixed block. -/\n@[to_additive \"The full set is a fixed block.\"]\nlemma IsFixedBlock.univ : IsFixedBlock G (univ : Set X) := fun _ ↦ by simp\n\n"}
{"name":"AddAction.IsFixedBlock.univ","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\n⊢ AddAction.IsFixedBlock G Set.univ","decl":"/-- The full set is a fixed block. -/\n@[to_additive \"The full set is a fixed block.\"]\nlemma IsFixedBlock.univ : IsFixedBlock G (univ : Set X) := fun _ ↦ by simp\n\n"}
{"name":"AddAction.IsBlock.univ","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\n⊢ AddAction.IsBlock G Set.univ","decl":"/-- The full set is a block. -/\n@[to_additive (attr := simp) \"The full set is a block.\"]\nlemma IsBlock.univ : IsBlock G (univ : Set X) := IsFixedBlock.univ.isBlock\n\n"}
{"name":"MulAction.IsBlock.univ","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\n⊢ MulAction.IsBlock G Set.univ","decl":"/-- The full set is a block. -/\n@[to_additive (attr := simp) \"The full set is a block.\"]\nlemma IsBlock.univ : IsBlock G (univ : Set X) := IsFixedBlock.univ.isBlock\n\n"}
{"name":"AddAction.IsBlock.inter","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB₁ B₂ : Set X\nh₁ : AddAction.IsBlock G B₁\nh₂ : AddAction.IsBlock G B₂\n⊢ AddAction.IsBlock G (Inter.inter B₁ B₂)","decl":"/-- The intersection of two blocks is a block. -/\n@[to_additive \"The intersection of two blocks is a block.\"]\nlemma IsBlock.inter {B₁ B₂ : Set X} (h₁ : IsBlock G B₁) (h₂ : IsBlock G B₂) :\n    IsBlock G (B₁ ∩ B₂) := by\n  simp only [isBlock_iff_smul_eq_smul_of_nonempty, smul_set_inter] at h₁ h₂ ⊢\n  rintro g₁ g₂ ⟨a, ha₁, ha₂⟩\n  rw [h₁ ⟨a, ha₁.1, ha₂.1⟩, h₂ ⟨a, ha₁.2, ha₂.2⟩]\n\n"}
{"name":"MulAction.IsBlock.inter","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB₁ B₂ : Set X\nh₁ : MulAction.IsBlock G B₁\nh₂ : MulAction.IsBlock G B₂\n⊢ MulAction.IsBlock G (Inter.inter B₁ B₂)","decl":"/-- The intersection of two blocks is a block. -/\n@[to_additive \"The intersection of two blocks is a block.\"]\nlemma IsBlock.inter {B₁ B₂ : Set X} (h₁ : IsBlock G B₁) (h₂ : IsBlock G B₂) :\n    IsBlock G (B₁ ∩ B₂) := by\n  simp only [isBlock_iff_smul_eq_smul_of_nonempty, smul_set_inter] at h₁ h₂ ⊢\n  rintro g₁ g₂ ⟨a, ha₁, ha₂⟩\n  rw [h₁ ⟨a, ha₁.1, ha₂.1⟩, h₂ ⟨a, ha₁.2, ha₂.2⟩]\n\n"}
{"name":"MulAction.IsBlock.iInter","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nι : Sort u_3\nB : ι → Set X\nhB : ∀ (i : ι), MulAction.IsBlock G (B i)\n⊢ MulAction.IsBlock G (Set.iInter fun i => B i)","decl":"/-- An intersection of blocks is a block. -/\n@[to_additive \"An intersection of blocks is a block.\"]\nlemma IsBlock.iInter {ι : Sort*} {B : ι → Set X} (hB : ∀ i, IsBlock G (B i)) :\n    IsBlock G (⋂ i, B i) := by\n  simp only [isBlock_iff_smul_eq_smul_of_nonempty, smul_set_iInter] at hB ⊢\n  rintro g₁ g₂ ⟨a, ha₁, ha₂⟩\n  simp_rw [fun i ↦ hB i ⟨a, iInter_subset _ i ha₁, iInter_subset _ i ha₂⟩]\n\n"}
{"name":"AddAction.IsBlock.iInter","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nι : Sort u_3\nB : ι → Set X\nhB : ∀ (i : ι), AddAction.IsBlock G (B i)\n⊢ AddAction.IsBlock G (Set.iInter fun i => B i)","decl":"/-- An intersection of blocks is a block. -/\n@[to_additive \"An intersection of blocks is a block.\"]\nlemma IsBlock.iInter {ι : Sort*} {B : ι → Set X} (hB : ∀ i, IsBlock G (B i)) :\n    IsBlock G (⋂ i, B i) := by\n  simp only [isBlock_iff_smul_eq_smul_of_nonempty, smul_set_iInter] at hB ⊢\n  rintro g₁ g₂ ⟨a, ha₁, ha₂⟩\n  simp_rw [fun i ↦ hB i ⟨a, iInter_subset _ i ha₁, iInter_subset _ i ha₂⟩]\n\n"}
{"name":"AddAction.IsTrivialBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nhB : AddAction.IsTrivialBlock B\n⊢ AddAction.IsBlock G B","decl":"/-- A trivial block is a block. -/\n@[to_additive \"A trivial block is a block.\"]\nlemma IsTrivialBlock.isBlock (hB : IsTrivialBlock B) : IsBlock G B := by\n  obtain hB | rfl := hB\n  · exact .of_subsingleton hB\n  · exact .univ\n\n"}
{"name":"MulAction.IsTrivialBlock.isBlock","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nhB : MulAction.IsTrivialBlock B\n⊢ MulAction.IsBlock G B","decl":"/-- A trivial block is a block. -/\n@[to_additive \"A trivial block is a block.\"]\nlemma IsTrivialBlock.isBlock (hB : IsTrivialBlock B) : IsBlock G B := by\n  obtain hB | rfl := hB\n  · exact .of_subsingleton hB\n  · exact .univ\n\n"}
{"name":"AddAction.IsFixedBlock.orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na : X\n⊢ AddAction.IsFixedBlock G (AddAction.orbit G a)","decl":"/-- An orbit is a fixed block. -/\n@[to_additive \"An orbit is a fixed block.\"]\nprotected lemma IsFixedBlock.orbit (a : X) : IsFixedBlock G (orbit G a) := (smul_orbit · a)\n\n"}
{"name":"MulAction.IsFixedBlock.orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na : X\n⊢ MulAction.IsFixedBlock G (MulAction.orbit G a)","decl":"/-- An orbit is a fixed block. -/\n@[to_additive \"An orbit is a fixed block.\"]\nprotected lemma IsFixedBlock.orbit (a : X) : IsFixedBlock G (orbit G a) := (smul_orbit · a)\n\n"}
{"name":"AddAction.IsBlock.orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na : X\n⊢ AddAction.IsBlock G (AddAction.orbit G a)","decl":"/-- An orbit is a block. -/\n@[to_additive \"An orbit is a block.\"]\nprotected lemma IsBlock.orbit (a : X) : IsBlock G (orbit G a) := (IsFixedBlock.orbit a).isBlock\n\n"}
{"name":"MulAction.IsBlock.orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na : X\n⊢ MulAction.IsBlock G (MulAction.orbit G a)","decl":"/-- An orbit is a block. -/\n@[to_additive \"An orbit is a block.\"]\nprotected lemma IsBlock.orbit (a : X) : IsBlock G (orbit G a) := (IsFixedBlock.orbit a).isBlock\n\n"}
{"name":"MulAction.isBlock_top","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\n⊢ Iff (MulAction.IsBlock (Subtype fun x => Membership.mem Top.top x) B) (MulAction.IsBlock G B)","decl":"@[to_additive]\nlemma isBlock_top : IsBlock (⊤ : Subgroup G) B ↔ IsBlock G B :=\n  Subgroup.topEquiv.toEquiv.forall_congr fun _ ↦ Subgroup.topEquiv.toEquiv.forall_congr_left\n\n"}
{"name":"AddAction.isBlock_top","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\n⊢ Iff (AddAction.IsBlock (Subtype fun x => Membership.mem Top.top x) B) (AddAction.IsBlock G B)","decl":"@[to_additive]\nlemma isBlock_top : IsBlock (⊤ : Subgroup G) B ↔ IsBlock G B :=\n  Subgroup.topEquiv.toEquiv.forall_congr fun _ ↦ Subgroup.topEquiv.toEquiv.forall_congr_left\n\n"}
{"name":"MulAction.IsBlock.preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : Group G\nX : Type u_2\ninst✝² : MulAction G X\nB : Set X\nH : Type u_3\nY : Type u_4\ninst✝¹ : Group H\ninst✝ : MulAction H Y\nφ : H → G\nj : MulActionHom φ Y X\nhB : MulAction.IsBlock G B\n⊢ MulAction.IsBlock H (Set.preimage (⇑j) B)","decl":"@[to_additive]\nlemma IsBlock.preimage {H Y : Type*} [Group H] [MulAction H Y]\n    {φ : H → G} (j : Y →ₑ[φ] X) (hB : IsBlock G B) :\n    IsBlock H (j ⁻¹' B) := by\n  rintro g₁ g₂ hg\n  rw [← Group.preimage_smul_setₛₗ, ← Group.preimage_smul_setₛₗ] at hg ⊢\n  exact (hB <| ne_of_apply_ne _ hg).preimage _\n\n"}
{"name":"AddAction.IsBlock.preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nX : Type u_2\ninst✝² : AddAction G X\nB : Set X\nH : Type u_3\nY : Type u_4\ninst✝¹ : AddGroup H\ninst✝ : AddAction H Y\nφ : H → G\nj : AddActionHom φ Y X\nhB : AddAction.IsBlock G B\n⊢ AddAction.IsBlock H (Set.preimage (⇑j) B)","decl":"@[to_additive]\nlemma IsBlock.preimage {H Y : Type*} [Group H] [MulAction H Y]\n    {φ : H → G} (j : Y →ₑ[φ] X) (hB : IsBlock G B) :\n    IsBlock H (j ⁻¹' B) := by\n  rintro g₁ g₂ hg\n  rw [← Group.preimage_smul_setₛₗ, ← Group.preimage_smul_setₛₗ] at hg ⊢\n  exact (hB <| ne_of_apply_ne _ hg).preimage _\n\n"}
{"name":"AddAction.IsBlock.image","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nX : Type u_2\ninst✝² : AddAction G X\nB : Set X\nH : Type u_3\nY : Type u_4\ninst✝¹ : AddGroup H\ninst✝ : AddAction H Y\nφ : AddMonoidHom G H\nj : AddActionHom (⇑φ) X Y\nhφ : Function.Surjective ⇑φ\nhj : Function.Injective ⇑j\nhB : AddAction.IsBlock G B\n⊢ AddAction.IsBlock H (Set.image (⇑j) B)","decl":"@[to_additive]\ntheorem IsBlock.image {H Y : Type*} [Group H] [MulAction H Y]\n    {φ : G →* H} (j : X →ₑ[φ] Y)\n    (hφ : Function.Surjective φ) (hj : Function.Injective j)\n    (hB : IsBlock G B) :\n    IsBlock H (j '' B) := by\n  simp only [IsBlock, hφ.forall, ← image_smul_setₛₗ]\n  exact fun g₁ g₂ hg ↦ disjoint_image_of_injective hj <| hB <| ne_of_apply_ne _ hg\n\n"}
{"name":"MulAction.IsBlock.image","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : Group G\nX : Type u_2\ninst✝² : MulAction G X\nB : Set X\nH : Type u_3\nY : Type u_4\ninst✝¹ : Group H\ninst✝ : MulAction H Y\nφ : MonoidHom G H\nj : MulActionHom (⇑φ) X Y\nhφ : Function.Surjective ⇑φ\nhj : Function.Injective ⇑j\nhB : MulAction.IsBlock G B\n⊢ MulAction.IsBlock H (Set.image (⇑j) B)","decl":"@[to_additive]\ntheorem IsBlock.image {H Y : Type*} [Group H] [MulAction H Y]\n    {φ : G →* H} (j : X →ₑ[φ] Y)\n    (hφ : Function.Surjective φ) (hj : Function.Injective j)\n    (hB : IsBlock G B) :\n    IsBlock H (j '' B) := by\n  simp only [IsBlock, hφ.forall, ← image_smul_setₛₗ]\n  exact fun g₁ g₂ hg ↦ disjoint_image_of_injective hj <| hB <| ne_of_apply_ne _ hg\n\n"}
{"name":"AddAction.IsBlock.subtype_val_preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nC : SubAddAction G X\nhB : AddAction.IsBlock G B\n⊢ AddAction.IsBlock G (Set.preimage Subtype.val B)","decl":"@[to_additive]\ntheorem IsBlock.subtype_val_preimage {C : SubMulAction G X} (hB : IsBlock G B) :\n    IsBlock G (Subtype.val ⁻¹' B : Set C) :=\n  hB.preimage C.inclusion\n\n"}
{"name":"MulAction.IsBlock.subtype_val_preimage","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nC : SubMulAction G X\nhB : MulAction.IsBlock G B\n⊢ MulAction.IsBlock G (Set.preimage Subtype.val B)","decl":"@[to_additive]\ntheorem IsBlock.subtype_val_preimage {C : SubMulAction G X} (hB : IsBlock G B) :\n    IsBlock G (Subtype.val ⁻¹' B : Set C) :=\n  hB.preimage C.inclusion\n\n"}
{"name":"AddAction.isBlock_subtypeVal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nC : SubAddAction G X\nB : Set (Subtype fun x => Membership.mem C x)\n⊢ Iff (AddAction.IsBlock G (Set.image Subtype.val B)) (AddAction.IsBlock G B)","decl":"@[to_additive]\ntheorem isBlock_subtypeVal {C : SubMulAction G X} {B : Set C} :\n    IsBlock G (Subtype.val '' B : Set X) ↔ IsBlock G B := by\n  refine forall₂_congr fun g₁ g₂ ↦ ?_\n  rw [← SubMulAction.inclusion.coe_eq, ← image_smul_set, ← image_smul_set, ne_eq,\n    Set.image_eq_image C.inclusion_injective, disjoint_image_iff C.inclusion_injective]\n\n"}
{"name":"MulAction.isBlock_subtypeVal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nC : SubMulAction G X\nB : Set (Subtype fun x => Membership.mem C x)\n⊢ Iff (MulAction.IsBlock G (Set.image Subtype.val B)) (MulAction.IsBlock G B)","decl":"@[to_additive]\ntheorem isBlock_subtypeVal {C : SubMulAction G X} {B : Set C} :\n    IsBlock G (Subtype.val '' B : Set X) ↔ IsBlock G B := by\n  refine forall₂_congr fun g₁ g₂ ↦ ?_\n  rw [← SubMulAction.inclusion.coe_eq, ← image_smul_set, ← image_smul_set, ne_eq,\n    Set.image_eq_image C.inclusion_injective, disjoint_image_iff C.inclusion_injective]\n\n"}
{"name":"AddAction.IsBlock.of_addSubgroup_of_conjugate","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\nX : Type u_4\ninst✝ : AddAction G X\nB : Set X\nH : AddSubgroup G\nhB : AddAction.IsBlock (Subtype fun x => Membership.mem H x) B\ng : G\n⊢ AddAction.IsBlock (Subtype fun x => Membership.mem (AddSubgroup.map (AddEquiv.toAddMonoidHom (AddAut.conj g)) H) x) (HVAdd.hVAdd g B)","decl":"theorem _root_.AddAction.IsBlock.of_addSubgroup_of_conjugate\n    {G : Type*} [AddGroup G] {X : Type*} [AddAction G X] {B : Set X}\n    {H : AddSubgroup G} (hB : AddAction.IsBlock H B) (g : G) :\n    AddAction.IsBlock (H.map (AddAut.conj g).toAddMonoidHom) (g +ᵥ B) := by\n  rw [AddAction.isBlock_iff_vadd_eq_or_disjoint]\n  intro h'\n  obtain ⟨h, hH, hh⟩ := AddSubgroup.mem_map.mp (SetLike.coe_mem h')\n  simp only [AddEquiv.coe_toAddMonoidHom, AddAut.conj_apply] at hh\n  suffices h' +ᵥ (g +ᵥ B) = g +ᵥ (h +ᵥ B) by\n    simp only [this]\n    apply (hB.vadd_eq_or_disjoint ⟨h, hH⟩).imp\n    · intro hB'; congr\n    · exact Set.disjoint_image_of_injective (AddAction.injective g)\n  suffices (h' : G) +ᵥ (g +ᵥ B) = g +ᵥ (h +ᵥ B) by\n    exact this\n  rw [← hh, vadd_vadd, vadd_vadd]\n  erw [AddAut.conj_apply]\n  simp\n\n"}
{"name":"MulAction.IsBlock.of_subgroup_of_conjugate","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nH : Subgroup G\nhB : MulAction.IsBlock (Subtype fun x => Membership.mem H x) B\ng : G\n⊢ MulAction.IsBlock (Subtype fun x => Membership.mem (Subgroup.map (MulEquiv.toMonoidHom (MulAut.conj g)) H) x) (HSMul.hSMul g B)","decl":"@[to_additive existing]\ntheorem IsBlock.of_subgroup_of_conjugate {H : Subgroup G} (hB : IsBlock H B) (g : G) :\n    IsBlock (H.map (MulAut.conj g).toMonoidHom) (g • B) := by\n  rw [isBlock_iff_smul_eq_or_disjoint]\n  intro h'\n  obtain ⟨h, hH, hh⟩ := Subgroup.mem_map.mp (SetLike.coe_mem h')\n  simp only [MulEquiv.coe_toMonoidHom, MulAut.conj_apply] at hh\n  suffices h' • g • B = g • h • B by\n    simp only [this]\n    apply (hB.smul_eq_or_disjoint ⟨h, hH⟩).imp\n    · intro; congr\n    · exact Set.disjoint_image_of_injective (MulAction.injective g)\n  suffices (h' : G) • g • B = g • h • B by\n    rw [← this]; rfl\n  rw [← hh, smul_smul (g * h * g⁻¹) g B, smul_smul g h B, inv_mul_cancel_right]\n\n"}
{"name":"AddAction.IsBlock.translate","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\nX : Type u_4\ninst✝ : AddAction G X\nB : Set X\ng : G\nhB : AddAction.IsBlock G B\n⊢ AddAction.IsBlock G (HVAdd.hVAdd g B)","decl":"/-- A translate of a block is a block -/\ntheorem _root_.AddAction.IsBlock.translate\n    {G : Type*} [AddGroup G] {X : Type*} [AddAction G X] (B : Set X)\n    (g : G) (hB : AddAction.IsBlock G B) :\n    AddAction.IsBlock G (g +ᵥ B) := by\n  rw [← AddAction.isBlock_top] at hB ⊢\n  rw [← AddSubgroup.map_comap_eq_self_of_surjective (G := G) ?_ ⊤]\n  · apply AddAction.IsBlock.of_addSubgroup_of_conjugate\n    rwa [AddSubgroup.comap_top]\n  · exact (AddAut.conj g).surjective\n\n"}
{"name":"MulAction.IsBlock.translate","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\ng : G\nhB : MulAction.IsBlock G B\n⊢ MulAction.IsBlock G (HSMul.hSMul g B)","decl":"/-- A translate of a block is a block -/\n@[to_additive existing]\ntheorem IsBlock.translate (g : G) (hB : IsBlock G B) :\n    IsBlock G (g • B) := by\n  rw [← isBlock_top] at hB ⊢\n  rw [← Subgroup.map_comap_eq_self_of_surjective\n          (G := G) (f := MulAut.conj g) (MulAut.conj g).surjective ⊤]\n  apply IsBlock.of_subgroup_of_conjugate\n  rwa [Subgroup.comap_top]\n\n"}
{"name":"MulAction.IsBlock.isBlockSystem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nhGX : MulAction.IsPretransitive G X\nhB : MulAction.IsBlock G B\nhBe : B.Nonempty\n⊢ MulAction.IsBlockSystem G (Set.range fun g => HSMul.hSMul g B)","decl":"/-- Translates of a block form a block system -/\n@[to_additive \"Translates of a block form a block system\"]\ntheorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]\n    (hB : IsBlock G B) (hBe : B.Nonempty) :\n    IsBlockSystem G (Set.range fun g : G => g • B) := by\n  refine ⟨⟨?nonempty, ?cover⟩, ?mem_blocks⟩\n  case mem_blocks => rintro B' ⟨g, rfl⟩; exact hB.translate g\n  · simp only [Set.mem_range, not_exists]\n    intro g hg\n    apply hBe.ne_empty\n    simpa only [Set.smul_set_eq_empty] using hg\n  · intro a\n    obtain ⟨b : X, hb : b ∈ B⟩ := hBe\n    obtain ⟨g, rfl⟩ := exists_smul_eq G b a\n    use g • B\n    simp only [Set.smul_mem_smul_set_iff, hb, existsUnique_iff_exists, Set.mem_range,\n      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,\n      forall_apply_eq_imp_iff, true_and]\n    exact fun g' ha ↦ hB.smul_eq_smul_of_nonempty ⟨g • b, ha, ⟨b, hb, rfl⟩⟩\n\n"}
{"name":"AddAction.IsBlock.isBlockSystem","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nhGX : AddAction.IsPretransitive G X\nhB : AddAction.IsBlock G B\nhBe : B.Nonempty\n⊢ AddAction.IsBlockSystem G (Set.range fun g => HVAdd.hVAdd g B)","decl":"/-- Translates of a block form a block system -/\n@[to_additive \"Translates of a block form a block system\"]\ntheorem IsBlock.isBlockSystem [hGX : MulAction.IsPretransitive G X]\n    (hB : IsBlock G B) (hBe : B.Nonempty) :\n    IsBlockSystem G (Set.range fun g : G => g • B) := by\n  refine ⟨⟨?nonempty, ?cover⟩, ?mem_blocks⟩\n  case mem_blocks => rintro B' ⟨g, rfl⟩; exact hB.translate g\n  · simp only [Set.mem_range, not_exists]\n    intro g hg\n    apply hBe.ne_empty\n    simpa only [Set.smul_set_eq_empty] using hg\n  · intro a\n    obtain ⟨b : X, hb : b ∈ B⟩ := hBe\n    obtain ⟨g, rfl⟩ := exists_smul_eq G b a\n    use g • B\n    simp only [Set.smul_mem_smul_set_iff, hb, existsUnique_iff_exists, Set.mem_range,\n      exists_apply_eq_apply, exists_const, exists_prop, and_imp, forall_exists_index,\n      forall_apply_eq_imp_iff, true_and]\n    exact fun g' ha ↦ hB.smul_eq_smul_of_nonempty ⟨g • b, ha, ⟨b, hb, rfl⟩⟩\n\n"}
{"name":"MulAction.smul_orbit_eq_orbit_smul","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nN : Subgroup G\nnN : N.Normal\na : X\ng : G\n⊢ Eq (HSMul.hSMul g (MulAction.orbit (Subtype fun x => Membership.mem N x) a)) (MulAction.orbit (Subtype fun x => Membership.mem N x) (HSMul.hSMul g a))","decl":"@[to_additive]\nlemma smul_orbit_eq_orbit_smul (N : Subgroup G) [nN : N.Normal] (a : X) (g : G) :\n    g • orbit N a = orbit N (g • a) := by\n  simp only [orbit, Set.image_smul, Set.smul_set_range]\n  ext\n  simp only [Set.mem_range]\n  constructor\n  · rintro ⟨⟨k, hk⟩, rfl⟩\n    use ⟨g * k * g⁻¹, nN.conj_mem k hk g⟩\n    simp only [Subgroup.mk_smul]\n    rw [smul_smul, inv_mul_cancel_right, ← smul_smul]\n  · rintro ⟨⟨k, hk⟩, rfl⟩\n    use ⟨g⁻¹ * k * g, nN.conj_mem' k hk g⟩\n    simp only [Subgroup.mk_smul]\n    simp only [← mul_assoc, ← smul_smul, smul_inv_smul, inv_inv]\n\n"}
{"name":"AddAction.vadd_orbit_eq_orbit_vadd","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nN : AddSubgroup G\nnN : N.Normal\na : X\ng : G\n⊢ Eq (HVAdd.hVAdd g (AddAction.orbit (Subtype fun x => Membership.mem N x) a)) (AddAction.orbit (Subtype fun x => Membership.mem N x) (HVAdd.hVAdd g a))","decl":"@[to_additive]\nlemma smul_orbit_eq_orbit_smul (N : Subgroup G) [nN : N.Normal] (a : X) (g : G) :\n    g • orbit N a = orbit N (g • a) := by\n  simp only [orbit, Set.image_smul, Set.smul_set_range]\n  ext\n  simp only [Set.mem_range]\n  constructor\n  · rintro ⟨⟨k, hk⟩, rfl⟩\n    use ⟨g * k * g⁻¹, nN.conj_mem k hk g⟩\n    simp only [Subgroup.mk_smul]\n    rw [smul_smul, inv_mul_cancel_right, ← smul_smul]\n  · rintro ⟨⟨k, hk⟩, rfl⟩\n    use ⟨g⁻¹ * k * g, nN.conj_mem' k hk g⟩\n    simp only [Subgroup.mk_smul]\n    simp only [← mul_assoc, ← smul_smul, smul_inv_smul, inv_inv]\n\n"}
{"name":"AddAction.IsBlock.orbit_of_normal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\nN : AddSubgroup G\ninst✝ : N.Normal\na : X\n⊢ AddAction.IsBlock G (AddAction.orbit (Subtype fun x => Membership.mem N x) a)","decl":"/-- An orbit of a normal subgroup is a block -/\n@[to_additive \"An orbit of a normal subgroup is a block\"]\ntheorem IsBlock.orbit_of_normal {N : Subgroup G} [N.Normal] (a : X) :\n    IsBlock G (orbit N a) := by\n  rw [isBlock_iff_smul_eq_or_disjoint]\n  intro g\n  rw [smul_orbit_eq_orbit_smul]\n  apply orbit.eq_or_disjoint\n\n"}
{"name":"MulAction.IsBlock.orbit_of_normal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\nN : Subgroup G\ninst✝ : N.Normal\na : X\n⊢ MulAction.IsBlock G (MulAction.orbit (Subtype fun x => Membership.mem N x) a)","decl":"/-- An orbit of a normal subgroup is a block -/\n@[to_additive \"An orbit of a normal subgroup is a block\"]\ntheorem IsBlock.orbit_of_normal {N : Subgroup G} [N.Normal] (a : X) :\n    IsBlock G (orbit N a) := by\n  rw [isBlock_iff_smul_eq_or_disjoint]\n  intro g\n  rw [smul_orbit_eq_orbit_smul]\n  apply orbit.eq_or_disjoint\n\n"}
{"name":"AddAction.IsBlockSystem.of_normal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\nN : AddSubgroup G\ninst✝ : N.Normal\n⊢ AddAction.IsBlockSystem G (Set.range fun a => AddAction.orbit (Subtype fun x => Membership.mem N x) a)","decl":"/-- The orbits of a normal subgroup form a block system -/\n@[to_additive \"The orbits of a normal subgroup form a block system\"]\ntheorem IsBlockSystem.of_normal {N : Subgroup G} [N.Normal] :\n    IsBlockSystem G (Set.range fun a : X => orbit N a) := by\n  constructor\n  · apply IsPartition.of_orbits\n  · intro b; rintro ⟨a, rfl⟩\n    exact .orbit_of_normal a\n\n"}
{"name":"MulAction.IsBlockSystem.of_normal","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\nN : Subgroup G\ninst✝ : N.Normal\n⊢ MulAction.IsBlockSystem G (Set.range fun a => MulAction.orbit (Subtype fun x => Membership.mem N x) a)","decl":"/-- The orbits of a normal subgroup form a block system -/\n@[to_additive \"The orbits of a normal subgroup form a block system\"]\ntheorem IsBlockSystem.of_normal {N : Subgroup G} [N.Normal] :\n    IsBlockSystem G (Set.range fun a : X => orbit N a) := by\n  constructor\n  · apply IsPartition.of_orbits\n  · intro b; rintro ⟨a, rfl⟩\n    exact .orbit_of_normal a\n\n"}
{"name":"AddAction.isBlock_addSubgroup","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝⁵ : AddGroup G\nS : Type u_3\nH : Type u_4\ninst✝⁴ : AddGroup H\ninst✝³ : SetLike S H\ninst✝² : AddSubgroupClass S H\ns : S\ninst✝¹ : AddAction G H\ninst✝ : VAddAssocClass G H H\n⊢ AddAction.IsBlock G ↑s","decl":"/-- See `MulAction.isBlock_subgroup'` for a version that works for the right action of a group on\nitself. -/\n@[to_additive \"See `AddAction.isBlock_subgroup'` for a version that works for the right action\nof a group on itself.\"]\nlemma isBlock_subgroup : IsBlock G (s : Set H) := by\n  simp only [IsBlock, disjoint_left]\n  rintro a b hab _ ⟨c, hc, rfl⟩ ⟨d, hd, (hcd : b • d = a • c)⟩\n  refine hab ?_\n  rw [← smul_coe_set hc, ← smul_assoc, ← hcd, smul_assoc, smul_coe_set hc, smul_coe_set hd]\n\n"}
{"name":"MulAction.isBlock_subgroup","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝⁵ : Group G\nS : Type u_3\nH : Type u_4\ninst✝⁴ : Group H\ninst✝³ : SetLike S H\ninst✝² : SubgroupClass S H\ns : S\ninst✝¹ : MulAction G H\ninst✝ : IsScalarTower G H H\n⊢ MulAction.IsBlock G ↑s","decl":"/-- See `MulAction.isBlock_subgroup'` for a version that works for the right action of a group on\nitself. -/\n@[to_additive \"See `AddAction.isBlock_subgroup'` for a version that works for the right action\nof a group on itself.\"]\nlemma isBlock_subgroup : IsBlock G (s : Set H) := by\n  simp only [IsBlock, disjoint_left]\n  rintro a b hab _ ⟨c, hc, rfl⟩ ⟨d, hd, (hcd : b • d = a • c)⟩\n  refine hab ?_\n  rw [← smul_coe_set hc, ← smul_assoc, ← hcd, smul_assoc, smul_coe_set hc, smul_coe_set hd]\n\n"}
{"name":"AddAction.isBlock_addSubgroup'","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝⁵ : AddGroup G\nS : Type u_3\nH : Type u_4\ninst✝⁴ : AddGroup H\ninst✝³ : SetLike S H\ninst✝² : AddSubgroupClass S H\ns : S\ninst✝¹ : AddAction G H\ninst✝ : VAddAssocClass G (AddOpposite H) H\n⊢ AddAction.IsBlock G ↑s","decl":"/-- See `MulAction.isBlock_subgroup` for a version that works for the left action of a group on\nitself. -/\n@[to_additive \"See `AddAction.isBlock_subgroup` for a version that works for the left action\nof a group on itself.\"]\nlemma isBlock_subgroup' : IsBlock G (s : Set H) := by\n  simp only [IsBlock, disjoint_left]\n  rintro a b hab _ ⟨c, hc, rfl⟩ ⟨d, hd, (hcd : b • d = a • c)⟩\n  refine hab ?_\n  rw [← op_smul_coe_set hc, ← smul_assoc, ← op_smul, ← hcd, op_smul, smul_assoc, op_smul_coe_set hc,\n    op_smul_coe_set hd]\n\n"}
{"name":"MulAction.isBlock_subgroup'","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝⁵ : Group G\nS : Type u_3\nH : Type u_4\ninst✝⁴ : Group H\ninst✝³ : SetLike S H\ninst✝² : SubgroupClass S H\ns : S\ninst✝¹ : MulAction G H\ninst✝ : IsScalarTower G (MulOpposite H) H\n⊢ MulAction.IsBlock G ↑s","decl":"/-- See `MulAction.isBlock_subgroup` for a version that works for the left action of a group on\nitself. -/\n@[to_additive \"See `AddAction.isBlock_subgroup` for a version that works for the left action\nof a group on itself.\"]\nlemma isBlock_subgroup' : IsBlock G (s : Set H) := by\n  simp only [IsBlock, disjoint_left]\n  rintro a b hab _ ⟨c, hc, rfl⟩ ⟨d, hd, (hcd : b • d = a • c)⟩\n  refine hab ?_\n  rw [← op_smul_coe_set hc, ← smul_assoc, ← op_smul, ← hcd, op_smul, smul_assoc, op_smul_coe_set hc,\n    op_smul_coe_set hd]\n\n"}
{"name":"MulAction.IsBlock.of_orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nH : Subgroup G\na : X\nhH : LE.le (MulAction.stabilizer G a) H\n⊢ MulAction.IsBlock G (MulAction.orbit (Subtype fun x => Membership.mem H x) a)","decl":"/-- The orbit of `a` under a subgroup containing the stabilizer of `a` is a block -/\n@[to_additive \"The orbit of `a` under a subgroup containing the stabilizer of `a` is a block\"]\ntheorem IsBlock.of_orbit {H : Subgroup G} {a : X} (hH : stabilizer G a ≤ H) :\n    IsBlock G (MulAction.orbit H a) := by\n  rw [isBlock_iff_smul_eq_of_nonempty]\n  rintro g ⟨-, ⟨-, ⟨h₁, rfl⟩, h⟩, h₂, rfl⟩\n  suffices g ∈ H by\n    rw [← Subgroup.coe_mk H g this, ← H.toSubmonoid.smul_def, smul_orbit (⟨g, this⟩ : H) a]\n  rw [← mul_mem_cancel_left h₂⁻¹.2, ← mul_mem_cancel_right h₁.2]\n  apply hH\n  simpa only [mem_stabilizer_iff, InvMemClass.coe_inv, mul_smul, inv_smul_eq_iff]\n\n"}
{"name":"AddAction.IsBlock.of_orbit","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nH : AddSubgroup G\na : X\nhH : LE.le (AddAction.stabilizer G a) H\n⊢ AddAction.IsBlock G (AddAction.orbit (Subtype fun x => Membership.mem H x) a)","decl":"/-- The orbit of `a` under a subgroup containing the stabilizer of `a` is a block -/\n@[to_additive \"The orbit of `a` under a subgroup containing the stabilizer of `a` is a block\"]\ntheorem IsBlock.of_orbit {H : Subgroup G} {a : X} (hH : stabilizer G a ≤ H) :\n    IsBlock G (MulAction.orbit H a) := by\n  rw [isBlock_iff_smul_eq_of_nonempty]\n  rintro g ⟨-, ⟨-, ⟨h₁, rfl⟩, h⟩, h₂, rfl⟩\n  suffices g ∈ H by\n    rw [← Subgroup.coe_mk H g this, ← H.toSubmonoid.smul_def, smul_orbit (⟨g, this⟩ : H) a]\n  rw [← mul_mem_cancel_left h₂⁻¹.2, ← mul_mem_cancel_right h₁.2]\n  apply hH\n  simpa only [mem_stabilizer_iff, InvMemClass.coe_inv, mul_smul, inv_smul_eq_iff]\n\n"}
{"name":"MulAction.IsBlock.stabilizer_le","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\nB : Set X\nhB : MulAction.IsBlock G B\na : X\nha : Membership.mem B a\n⊢ LE.le (MulAction.stabilizer G a) (MulAction.stabilizer G B)","decl":"/-- If `B` is a block containing `a`, then the stabilizer of `B` contains the stabilizer of `a` -/\n@[to_additive\n  \"If `B` is a block containing `a`, then the stabilizer of `B` contains the stabilizer of `a`\"]\ntheorem IsBlock.stabilizer_le (hB : IsBlock G B) {a : X} (ha : a ∈ B) :\n    stabilizer G a ≤ stabilizer G B :=\n  fun g hg ↦ hB.smul_eq_of_nonempty ⟨a, by rwa [← hg, smul_mem_smul_set_iff], ha⟩\n\n"}
{"name":"AddAction.IsBlock.stabilizer_le","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\nB : Set X\nhB : AddAction.IsBlock G B\na : X\nha : Membership.mem B a\n⊢ LE.le (AddAction.stabilizer G a) (AddAction.stabilizer G B)","decl":"/-- If `B` is a block containing `a`, then the stabilizer of `B` contains the stabilizer of `a` -/\n@[to_additive\n  \"If `B` is a block containing `a`, then the stabilizer of `B` contains the stabilizer of `a`\"]\ntheorem IsBlock.stabilizer_le (hB : IsBlock G B) {a : X} (ha : a ∈ B) :\n    stabilizer G a ≤ stabilizer G B :=\n  fun g hg ↦ hB.smul_eq_of_nonempty ⟨a, by rwa [← hg, smul_mem_smul_set_iff], ha⟩\n\n"}
{"name":"MulAction.IsBlock.orbit_stabilizer_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\nB : Set X\ninst✝ : MulAction.IsPretransitive G X\nhB : MulAction.IsBlock G B\na : X\nha : Membership.mem B a\n⊢ Eq (MulAction.orbit (Subtype fun x => Membership.mem (MulAction.stabilizer G B) x) a) B","decl":"/-- A block containing `a` is the orbit of `a` under its stabilizer -/\n@[to_additive \"A block containing `a` is the orbit of `a` under its stabilizer\"]\ntheorem IsBlock.orbit_stabilizer_eq [IsPretransitive G X] (hB : IsBlock G B) {a : X} (ha : a ∈ B) :\n    MulAction.orbit (stabilizer G B) a = B := by\n  ext x\n  constructor\n  · rintro ⟨⟨k, k_mem⟩, rfl⟩\n    simp only [Subgroup.mk_smul]\n    rw [← k_mem, Set.smul_mem_smul_set_iff]\n    exact ha\n  · intro hx\n    obtain ⟨k, rfl⟩ := exists_smul_eq G a x\n    exact ⟨⟨k, hB.smul_eq_of_mem ha hx⟩, rfl⟩\n\n"}
{"name":"AddAction.IsBlock.orbit_stabilizer_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\nB : Set X\ninst✝ : AddAction.IsPretransitive G X\nhB : AddAction.IsBlock G B\na : X\nha : Membership.mem B a\n⊢ Eq (AddAction.orbit (Subtype fun x => Membership.mem (AddAction.stabilizer G B) x) a) B","decl":"/-- A block containing `a` is the orbit of `a` under its stabilizer -/\n@[to_additive \"A block containing `a` is the orbit of `a` under its stabilizer\"]\ntheorem IsBlock.orbit_stabilizer_eq [IsPretransitive G X] (hB : IsBlock G B) {a : X} (ha : a ∈ B) :\n    MulAction.orbit (stabilizer G B) a = B := by\n  ext x\n  constructor\n  · rintro ⟨⟨k, k_mem⟩, rfl⟩\n    simp only [Subgroup.mk_smul]\n    rw [← k_mem, Set.smul_mem_smul_set_iff]\n    exact ha\n  · intro hx\n    obtain ⟨k, rfl⟩ := exists_smul_eq G a x\n    exact ⟨⟨k, hB.smul_eq_of_mem ha hx⟩, rfl⟩\n\n"}
{"name":"AddAction.stabilizer_orbit_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na : X\nH : AddSubgroup G\nhH : LE.le (AddAction.stabilizer G a) H\n⊢ Eq (AddAction.stabilizer G (AddAction.orbit (Subtype fun x => Membership.mem H x) a)) H","decl":"/-- A subgroup containing the stabilizer of `a`\n  is the stabilizer of the orbit of `a` under that subgroup -/\n@[to_additive\n  \"A subgroup containing the stabilizer of `a`\n  is the stabilizer of the orbit of `a` under that subgroup\"]\ntheorem stabilizer_orbit_eq {a : X} {H : Subgroup G} (hH : stabilizer G a ≤ H) :\n    stabilizer G (orbit H a) = H := by\n  ext g\n  constructor\n  · intro hg\n    obtain ⟨-, ⟨b, rfl⟩, h⟩ := hg.symm ▸ mem_orbit_self a\n    simp_rw [H.toSubmonoid.smul_def, ← mul_smul, ← mem_stabilizer_iff] at h\n    exact (mul_mem_cancel_right b.2).mp (hH h)\n  · intro hg\n    rw [mem_stabilizer_iff, ← Subgroup.coe_mk H g hg, ← Submonoid.smul_def (S := H.toSubmonoid)]\n    apply smul_orbit (G := H)\n\n"}
{"name":"MulAction.stabilizer_orbit_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na : X\nH : Subgroup G\nhH : LE.le (MulAction.stabilizer G a) H\n⊢ Eq (MulAction.stabilizer G (MulAction.orbit (Subtype fun x => Membership.mem H x) a)) H","decl":"/-- A subgroup containing the stabilizer of `a`\n  is the stabilizer of the orbit of `a` under that subgroup -/\n@[to_additive\n  \"A subgroup containing the stabilizer of `a`\n  is the stabilizer of the orbit of `a` under that subgroup\"]\ntheorem stabilizer_orbit_eq {a : X} {H : Subgroup G} (hH : stabilizer G a ≤ H) :\n    stabilizer G (orbit H a) = H := by\n  ext g\n  constructor\n  · intro hg\n    obtain ⟨-, ⟨b, rfl⟩, h⟩ := hg.symm ▸ mem_orbit_self a\n    simp_rw [H.toSubmonoid.smul_def, ← mul_smul, ← mem_stabilizer_iff] at h\n    exact (mul_mem_cancel_right b.2).mp (hH h)\n  · intro hg\n    rw [mem_stabilizer_iff, ← Subgroup.coe_mk H g hg, ← Submonoid.smul_def (S := H.toSubmonoid)]\n    apply smul_orbit (G := H)\n\n"}
{"name":"MulAction.BlockMem.coe_top","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na : X\n⊢ Eq (↑Top.top) Top.top","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_top (a : X) :\n    ((⊤ : BlockMem G a) : Set X) = ⊤ :=\n  rfl\n\n"}
{"name":"AddAction.BlockMem.coe_top","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na : X\n⊢ Eq (↑Top.top) Top.top","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_top (a : X) :\n    ((⊤ : BlockMem G a) : Set X) = ⊤ :=\n  rfl\n\n"}
{"name":"AddAction.BlockMem.coe_bot","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nX : Type u_2\ninst✝ : AddAction G X\na : X\n⊢ Eq (↑Bot.bot) (Singleton.singleton a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_bot (a : X) :\n    ((⊥ : BlockMem G a) : Set X) = {a} :=\n  rfl\n\n"}
{"name":"MulAction.BlockMem.coe_bot","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nX : Type u_2\ninst✝ : MulAction G X\na : X\n⊢ Eq (↑Bot.bot) (Singleton.singleton a)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_bot (a : X) :\n    ((⊥ : BlockMem G a) : Set X) = {a} :=\n  rfl\n\n"}
{"name":"AddAction.BlockMem.instNontrivial","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : Nontrivial X\na : X\n⊢ Nontrivial (AddAction.BlockMem G a)","decl":"@[to_additive]\ninstance [Nontrivial X] (a : X) : Nontrivial (BlockMem G a) := by\n  rw [nontrivial_iff]\n  use ⊥, ⊤\n  intro h\n  rw [← Subtype.coe_inj] at h\n  simp only [coe_top, coe_bot] at h\n  obtain ⟨b, hb⟩ := exists_ne a\n  apply hb\n  rw [← Set.mem_singleton_iff, h, Set.top_eq_univ]\n  apply Set.mem_univ\n\n"}
{"name":"MulAction.BlockMem.instNontrivial","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : Nontrivial X\na : X\n⊢ Nontrivial (MulAction.BlockMem G a)","decl":"@[to_additive]\ninstance [Nontrivial X] (a : X) : Nontrivial (BlockMem G a) := by\n  rw [nontrivial_iff]\n  use ⊥, ⊤\n  intro h\n  rw [← Subtype.coe_inj] at h\n  simp only [coe_top, coe_bot] at h\n  obtain ⟨b, hb⟩ := exists_ne a\n  apply hb\n  rw [← Set.mem_singleton_iff, h, Set.top_eq_univ]\n  apply Set.mem_univ\n\n"}
{"name":"MulAction.IsBlock.ncard_block_eq_relindex","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\nhB : MulAction.IsBlock G B\nx : X\nhx : Membership.mem B x\n⊢ Eq B.ncard ((MulAction.stabilizer G x).relindex (MulAction.stabilizer G B))","decl":"@[to_additive]\ntheorem ncard_block_eq_relindex (hB : IsBlock G B) {x : X} (hx : x ∈ B) :\n    B.ncard = (stabilizer G x).relindex (stabilizer G B) := by\n  have key : (stabilizer G x).subgroupOf (stabilizer G B) = stabilizer (stabilizer G B) x := by\n    ext; rfl\n  rw [Subgroup.relindex, key, index_stabilizer, hB.orbit_stabilizer_eq hx]\n\n"}
{"name":"AddAction.IsBlock.ncard_block_eq_relindex","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nB : Set X\nhB : AddAction.IsBlock G B\nx : X\nhx : Membership.mem B x\n⊢ Eq B.ncard ((AddAction.stabilizer G x).relindex (AddAction.stabilizer G B))","decl":"@[to_additive]\ntheorem ncard_block_eq_relindex (hB : IsBlock G B) {x : X} (hx : x ∈ B) :\n    B.ncard = (stabilizer G x).relindex (stabilizer G B) := by\n  have key : (stabilizer G x).subgroupOf (stabilizer G B) = stabilizer (stabilizer G B) x := by\n    ext; rfl\n  rw [Subgroup.relindex, key, index_stabilizer, hB.orbit_stabilizer_eq hx]\n\n"}
{"name":"AddAction.IsBlock.ncard_block_add_ncard_orbit_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nB : Set X\nhB : AddAction.IsBlock G B\nhB_ne : B.Nonempty\n⊢ Eq (HMul.hMul B.ncard (AddAction.orbit G B).ncard) (Nat.card X)","decl":"/-- The cardinality of the ambient space is the product of the cardinality of a block\n  by the cardinality of the set of translates of that block -/\n@[to_additive\n  \"The cardinality of the ambient space is the product of the cardinality of a block\n  by the cardinality of the set of translates of that block\"]\ntheorem ncard_block_mul_ncard_orbit_eq (hB : IsBlock G B) (hB_ne : B.Nonempty) :\n    Set.ncard B * Set.ncard (orbit G B) = Nat.card X := by\n  obtain ⟨x, hx⟩ := hB_ne\n  rw [ncard_block_eq_relindex hB hx, ← index_stabilizer,\n      Subgroup.relindex_mul_index (hB.stabilizer_le hx), index_stabilizer_of_transitive]\n\n"}
{"name":"MulAction.IsBlock.ncard_block_mul_ncard_orbit_eq","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\nhB : MulAction.IsBlock G B\nhB_ne : B.Nonempty\n⊢ Eq (HMul.hMul B.ncard (MulAction.orbit G B).ncard) (Nat.card X)","decl":"/-- The cardinality of the ambient space is the product of the cardinality of a block\n  by the cardinality of the set of translates of that block -/\n@[to_additive\n  \"The cardinality of the ambient space is the product of the cardinality of a block\n  by the cardinality of the set of translates of that block\"]\ntheorem ncard_block_mul_ncard_orbit_eq (hB : IsBlock G B) (hB_ne : B.Nonempty) :\n    Set.ncard B * Set.ncard (orbit G B) = Nat.card X := by\n  obtain ⟨x, hx⟩ := hB_ne\n  rw [ncard_block_eq_relindex hB hx, ← index_stabilizer,\n      Subgroup.relindex_mul_index (hB.stabilizer_le hx), index_stabilizer_of_transitive]\n\n"}
{"name":"MulAction.IsBlock.ncard_dvd_card","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\nhB : MulAction.IsBlock G B\nhB_ne : B.Nonempty\n⊢ Dvd.dvd B.ncard (Nat.card X)","decl":"/-- The cardinality of a block divides the cardinality of the ambient type -/\n@[to_additive \"The cardinality of a block divides the cardinality of the ambient type\"]\ntheorem ncard_dvd_card (hB : IsBlock G B) (hB_ne : B.Nonempty) :\n    Set.ncard B ∣ Nat.card X :=\n  Dvd.intro _ (hB.ncard_block_mul_ncard_orbit_eq hB_ne)\n\n"}
{"name":"AddAction.IsBlock.ncard_dvd_card","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nB : Set X\nhB : AddAction.IsBlock G B\nhB_ne : B.Nonempty\n⊢ Dvd.dvd B.ncard (Nat.card X)","decl":"/-- The cardinality of a block divides the cardinality of the ambient type -/\n@[to_additive \"The cardinality of a block divides the cardinality of the ambient type\"]\ntheorem ncard_dvd_card (hB : IsBlock G B) (hB_ne : B.Nonempty) :\n    Set.ncard B ∣ Nat.card X :=\n  Dvd.intro _ (hB.ncard_block_mul_ncard_orbit_eq hB_ne)\n\n"}
{"name":"AddAction.IsBlock.eq_univ_of_card_lt","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nB : Set X\nhX : Finite X\nhB : AddAction.IsBlock G B\nhB' : LT.lt (Nat.card X) (HMul.hMul B.ncard 2)\n⊢ Eq B Set.univ","decl":"/-- A too large block is equal to `univ` -/\n@[to_additive \"A too large block is equal to `univ`\"]\ntheorem eq_univ_of_card_lt [hX : Finite X] (hB : IsBlock G B) (hB' : Nat.card X < Set.ncard B * 2) :\n    B = Set.univ := by\n  rcases Set.eq_empty_or_nonempty B with rfl | hB_ne\n  · simp only [Set.ncard_empty, zero_mul, not_lt_zero'] at hB'\n  have key := hB.ncard_block_mul_ncard_orbit_eq hB_ne\n  rw [← key, mul_lt_mul_iff_of_pos_left (by rwa [Set.ncard_pos])] at hB'\n  interval_cases (orbit G B).ncard\n  · rw [mul_zero, eq_comm, Nat.card_eq_zero, or_iff_left hX.not_infinite] at key\n    exact (IsEmpty.exists_iff.mp hB_ne).elim\n  · rw [mul_one, ← Set.ncard_univ] at key\n    rw [Set.eq_of_subset_of_ncard_le (Set.subset_univ B) key.ge]\n\n"}
{"name":"MulAction.IsBlock.eq_univ_of_card_lt","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\nhX : Finite X\nhB : MulAction.IsBlock G B\nhB' : LT.lt (Nat.card X) (HMul.hMul B.ncard 2)\n⊢ Eq B Set.univ","decl":"/-- A too large block is equal to `univ` -/\n@[to_additive \"A too large block is equal to `univ`\"]\ntheorem eq_univ_of_card_lt [hX : Finite X] (hB : IsBlock G B) (hB' : Nat.card X < Set.ncard B * 2) :\n    B = Set.univ := by\n  rcases Set.eq_empty_or_nonempty B with rfl | hB_ne\n  · simp only [Set.ncard_empty, zero_mul, not_lt_zero'] at hB'\n  have key := hB.ncard_block_mul_ncard_orbit_eq hB_ne\n  rw [← key, mul_lt_mul_iff_of_pos_left (by rwa [Set.ncard_pos])] at hB'\n  interval_cases (orbit G B).ncard\n  · rw [mul_zero, eq_comm, Nat.card_eq_zero, or_iff_left hX.not_infinite] at key\n    exact (IsEmpty.exists_iff.mp hB_ne).elim\n  · rw [mul_one, ← Set.ncard_univ] at key\n    rw [Set.eq_of_subset_of_ncard_le (Set.subset_univ B) key.ge]\n\n"}
{"name":"MulAction.IsBlock.eq_univ_card_lt","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\nhX : Finite X\nhB : MulAction.IsBlock G B\nhB' : LT.lt (Nat.card X) (HMul.hMul B.ncard 2)\n⊢ Eq B Set.univ","decl":"@[deprecated (since := \"2024-10-29\")] alias eq_univ_card_lt := eq_univ_of_card_lt\n\n"}
{"name":"MulAction.IsBlock.subsingleton_of_card_lt","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : Group G\nX : Type u_2\ninst✝² : MulAction G X\ninst✝¹ : MulAction.IsPretransitive G X\nB : Set X\ninst✝ : Finite X\nhB : MulAction.IsBlock G B\nhB' : LT.lt (Nat.card X) (HMul.hMul 2 (MulAction.orbit G B).ncard)\n⊢ B.Subsingleton","decl":"/-- If a block has too many translates, then it is a (sub)singleton  -/\n@[to_additive \"If a block has too many translates, then it is a (sub)singleton\"]\ntheorem subsingleton_of_card_lt [Finite X] (hB : IsBlock G B)\n    (hB' : Nat.card X < 2 * Set.ncard (orbit G B)) :\n    B.Subsingleton := by\n  suffices Set.ncard B < 2 by\n    rw [Nat.lt_succ_iff, Set.ncard_le_one_iff_eq] at this\n    cases this with\n    | inl h => rw [h]; exact Set.subsingleton_empty\n    | inr h =>\n      obtain ⟨a, ha⟩ := h; rw [ha]; exact Set.subsingleton_singleton\n  cases Set.eq_empty_or_nonempty B with\n  | inl h => rw [h, Set.ncard_empty]; norm_num\n  | inr h =>\n    rw [← hB.ncard_block_mul_ncard_orbit_eq h, lt_iff_not_ge] at hB'\n    rw [← not_le]\n    exact fun hb ↦ hB' (Nat.mul_le_mul_right _ hb)\n\n/- The assumption `B.Finite` is necessary :\n   For G = ℤ acting on itself, a = 0 and B = ℕ, the translates `k • B` of the statement\n   are just `k + ℕ`, for `k ≤ 0`, and the corresponding intersection is `ℕ`, which is not a block.\n   (Remark by Thomas Browning) -/\n"}
{"name":"AddAction.IsBlock.subsingleton_of_card_lt","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nX : Type u_2\ninst✝² : AddAction G X\ninst✝¹ : AddAction.IsPretransitive G X\nB : Set X\ninst✝ : Finite X\nhB : AddAction.IsBlock G B\nhB' : LT.lt (Nat.card X) (HMul.hMul 2 (AddAction.orbit G B).ncard)\n⊢ B.Subsingleton","decl":"/-- If a block has too many translates, then it is a (sub)singleton  -/\n@[to_additive \"If a block has too many translates, then it is a (sub)singleton\"]\ntheorem subsingleton_of_card_lt [Finite X] (hB : IsBlock G B)\n    (hB' : Nat.card X < 2 * Set.ncard (orbit G B)) :\n    B.Subsingleton := by\n  suffices Set.ncard B < 2 by\n    rw [Nat.lt_succ_iff, Set.ncard_le_one_iff_eq] at this\n    cases this with\n    | inl h => rw [h]; exact Set.subsingleton_empty\n    | inr h =>\n      obtain ⟨a, ha⟩ := h; rw [ha]; exact Set.subsingleton_singleton\n  cases Set.eq_empty_or_nonempty B with\n  | inl h => rw [h, Set.ncard_empty]; norm_num\n  | inr h =>\n    rw [← hB.ncard_block_mul_ncard_orbit_eq h, lt_iff_not_ge] at hB'\n    rw [← not_le]\n    exact fun hb ↦ hB' (Nat.mul_le_mul_right _ hb)\n\n/- The assumption `B.Finite` is necessary :\n   For G = ℤ acting on itself, a = 0 and B = ℕ, the translates `k • B` of the statement\n   are just `k + ℕ`, for `k ≤ 0`, and the corresponding intersection is `ℕ`, which is not a block.\n   (Remark by Thomas Browning) -/\n"}
{"name":"AddAction.IsBlock.of_subset","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nX : Type u_2\ninst✝¹ : AddAction G X\ninst✝ : AddAction.IsPretransitive G X\nB : Set X\na : X\nhfB : B.Finite\n⊢ AddAction.IsBlock G (Set.iInter fun k => Set.iInter fun x => HVAdd.hVAdd k B)","decl":"/-- The intersection of the translates of a *finite* subset which contain a given point\nis a block (Wielandt, th. 7.3)-/\n@[to_additive\n  \"The intersection of the translates of a *finite* subset which contain a given point\n  is a block (Wielandt, th. 7.3)\"]\ntheorem of_subset (a : X) (hfB : B.Finite) :\n    IsBlock G (⋂ (k : G) (_ : a ∈ k • B), k • B) := by\n  let B' := ⋂ (k : G) (_ : a ∈ k • B), k • B\n  cases' Set.eq_empty_or_nonempty B with hfB_e hfB_ne\n  · simp [hfB_e]\n  have hB'₀ : ∀ (k : G) (_ : a ∈ k • B), B' ≤ k • B := by\n    intro k hk\n    exact Set.biInter_subset_of_mem hk\n  have hfB' : B'.Finite := by\n    obtain ⟨b, hb : b ∈ B⟩ := hfB_ne\n    obtain ⟨k, hk : k • b = a⟩ := exists_smul_eq G b a\n    apply Set.Finite.subset (Set.Finite.map _ hfB) (hB'₀ k ⟨b, hb, hk⟩)\n  have hag : ∀ g : G, a ∈ g • B' → B' ≤ g • B' :=  by\n    intro g hg x hx\n    -- a = g • b; b ∈ B'; a ∈ k • B → b ∈ k • B\n    simp only [B', Set.mem_iInter, Set.mem_smul_set_iff_inv_smul_mem,\n      smul_smul, ← mul_inv_rev] at hg hx ⊢\n    exact fun _ ↦ hx _ ∘ hg _\n  have hag' (g : G) (hg : a ∈ g • B') : B' = g • B' := by\n    rw [eq_comm, ← mem_stabilizer_iff, mem_stabilizer_set_iff_subset_smul_set hfB']\n    exact hag g hg\n  rw [isBlock_iff_smul_eq_of_nonempty]\n  rintro g ⟨b : X, hb' : b ∈ g • B', hb : b ∈ B'⟩\n  obtain ⟨k : G, hk : k • a = b⟩ := exists_smul_eq G a b\n  have hak : a ∈ k⁻¹ • B' := by\n    refine ⟨b, hb, ?_⟩\n    simp only [← hk, inv_smul_smul]\n  have hagk : a ∈ (k⁻¹ * g) • B' := by\n    rw [mul_smul, Set.mem_smul_set_iff_inv_smul_mem, inv_inv, hk]\n    exact hb'\n  have hkB' : B' = k⁻¹ • B' := hag' k⁻¹ hak\n  have hgkB' : B' = (k⁻¹ * g) • B' := hag' (k⁻¹ * g) hagk\n  rw [mul_smul] at hgkB'\n  rw [← smul_eq_iff_eq_inv_smul] at hkB' hgkB'\n  rw [← hgkB', hkB']\n\n"}
{"name":"MulAction.IsBlock.of_subset","module":"Mathlib.GroupTheory.GroupAction.Blocks","initialProofState":"G : Type u_1\ninst✝² : Group G\nX : Type u_2\ninst✝¹ : MulAction G X\ninst✝ : MulAction.IsPretransitive G X\nB : Set X\na : X\nhfB : B.Finite\n⊢ MulAction.IsBlock G (Set.iInter fun k => Set.iInter fun x => HSMul.hSMul k B)","decl":"/-- The intersection of the translates of a *finite* subset which contain a given point\nis a block (Wielandt, th. 7.3)-/\n@[to_additive\n  \"The intersection of the translates of a *finite* subset which contain a given point\n  is a block (Wielandt, th. 7.3)\"]\ntheorem of_subset (a : X) (hfB : B.Finite) :\n    IsBlock G (⋂ (k : G) (_ : a ∈ k • B), k • B) := by\n  let B' := ⋂ (k : G) (_ : a ∈ k • B), k • B\n  cases' Set.eq_empty_or_nonempty B with hfB_e hfB_ne\n  · simp [hfB_e]\n  have hB'₀ : ∀ (k : G) (_ : a ∈ k • B), B' ≤ k • B := by\n    intro k hk\n    exact Set.biInter_subset_of_mem hk\n  have hfB' : B'.Finite := by\n    obtain ⟨b, hb : b ∈ B⟩ := hfB_ne\n    obtain ⟨k, hk : k • b = a⟩ := exists_smul_eq G b a\n    apply Set.Finite.subset (Set.Finite.map _ hfB) (hB'₀ k ⟨b, hb, hk⟩)\n  have hag : ∀ g : G, a ∈ g • B' → B' ≤ g • B' :=  by\n    intro g hg x hx\n    -- a = g • b; b ∈ B'; a ∈ k • B → b ∈ k • B\n    simp only [B', Set.mem_iInter, Set.mem_smul_set_iff_inv_smul_mem,\n      smul_smul, ← mul_inv_rev] at hg hx ⊢\n    exact fun _ ↦ hx _ ∘ hg _\n  have hag' (g : G) (hg : a ∈ g • B') : B' = g • B' := by\n    rw [eq_comm, ← mem_stabilizer_iff, mem_stabilizer_set_iff_subset_smul_set hfB']\n    exact hag g hg\n  rw [isBlock_iff_smul_eq_of_nonempty]\n  rintro g ⟨b : X, hb' : b ∈ g • B', hb : b ∈ B'⟩\n  obtain ⟨k : G, hk : k • a = b⟩ := exists_smul_eq G a b\n  have hak : a ∈ k⁻¹ • B' := by\n    refine ⟨b, hb, ?_⟩\n    simp only [← hk, inv_smul_smul]\n  have hagk : a ∈ (k⁻¹ * g) • B' := by\n    rw [mul_smul, Set.mem_smul_set_iff_inv_smul_mem, inv_inv, hk]\n    exact hb'\n  have hkB' : B' = k⁻¹ • B' := hag' k⁻¹ hak\n  have hgkB' : B' = (k⁻¹ * g) • B' := hag' (k⁻¹ * g) hagk\n  rw [mul_smul] at hgkB'\n  rw [← smul_eq_iff_eq_inv_smul] at hkB' hgkB'\n  rw [← hgkB', hkB']\n\n"}
