{"name":"Finset.Shatters.exists_inter_eq_singleton","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nhs : 𝒜.Shatters s\nha : Membership.mem s a\n⊢ Exists fun t => And (Membership.mem 𝒜 t) (Eq (Inter.inter s t) (Singleton.singleton a))","decl":"lemma Shatters.exists_inter_eq_singleton (hs : Shatters 𝒜 s) (ha : a ∈ s) : ∃ t ∈ 𝒜, s ∩ t = {a} :=\n  hs <| singleton_subset_iff.2 ha\n\n"}
{"name":"Finset.Shatters.mono_left","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\ns : Finset α\nh : HasSubset.Subset 𝒜 ℬ\nh𝒜 : 𝒜.Shatters s\n⊢ ℬ.Shatters s","decl":"lemma Shatters.mono_left (h : 𝒜 ⊆ ℬ) (h𝒜 : 𝒜.Shatters s) : ℬ.Shatters s :=\n  fun _t ht ↦ let ⟨u, hu, hut⟩ := h𝒜 ht; ⟨u, h hu, hut⟩\n\n"}
{"name":"Finset.Shatters.mono_right","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns t : Finset α\nh : HasSubset.Subset t s\nhs : 𝒜.Shatters s\n⊢ 𝒜.Shatters t","decl":"lemma Shatters.mono_right (h : t ⊆ s) (hs : 𝒜.Shatters s) : 𝒜.Shatters t := fun u hu ↦ by\n  obtain ⟨v, hv, rfl⟩ := hs (hu.trans h); exact ⟨v, hv, inf_congr_right hu <| inf_le_of_left_le h⟩\n\n"}
{"name":"Finset.Shatters.exists_superset","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\nh : 𝒜.Shatters s\n⊢ Exists fun t => And (Membership.mem 𝒜 t) (HasSubset.Subset s t)","decl":"lemma Shatters.exists_superset (h : 𝒜.Shatters s) : ∃ t ∈ 𝒜, s ⊆ t :=\n  let ⟨t, ht, hst⟩ := h Subset.rfl; ⟨t, ht, inter_eq_left.1 hst⟩\n\n"}
{"name":"Finset.shatters_of_forall_subset","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\nh : ∀ (t : Finset α), HasSubset.Subset t s → Membership.mem 𝒜 t\n⊢ 𝒜.Shatters s","decl":"lemma shatters_of_forall_subset (h : ∀ t, t ⊆ s → t ∈ 𝒜) : 𝒜.Shatters s :=\n  fun t ht ↦ ⟨t, h _ ht, inter_eq_right.2 ht⟩\n\n"}
{"name":"Finset.Shatters.nonempty","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\nh : 𝒜.Shatters s\n⊢ 𝒜.Nonempty","decl":"protected lemma Shatters.nonempty (h : 𝒜.Shatters s) : 𝒜.Nonempty :=\n  let ⟨t, ht, _⟩ := h Subset.rfl; ⟨t, ht⟩\n\n"}
{"name":"Finset.shatters_empty","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ Iff (𝒜.Shatters EmptyCollection.emptyCollection) 𝒜.Nonempty","decl":"@[simp] lemma shatters_empty : 𝒜.Shatters ∅ ↔ 𝒜.Nonempty :=\n  ⟨Shatters.nonempty, fun ⟨s, hs⟩ t ht ↦ ⟨s, hs, by rwa [empty_inter, eq_comm, ← subset_empty]⟩⟩\n\n"}
{"name":"Finset.Shatters.subset_iff","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns t : Finset α\nh : 𝒜.Shatters s\n⊢ Iff (HasSubset.Subset t s) (Exists fun u => And (Membership.mem 𝒜 u) (Eq (Inter.inter s u) t))","decl":"protected lemma Shatters.subset_iff (h : 𝒜.Shatters s) : t ⊆ s ↔ ∃ u ∈ 𝒜, s ∩ u = t :=\n  ⟨fun ht ↦ h ht, by rintro ⟨u, _, rfl⟩; exact inter_subset_left⟩\n\n"}
{"name":"Finset.shatters_iff","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\n⊢ Iff (𝒜.Shatters s) (Eq (Finset.image (fun t => Inter.inter s t) 𝒜) s.powerset)","decl":"lemma shatters_iff : 𝒜.Shatters s ↔ 𝒜.image (fun t ↦ s ∩ t) = s.powerset :=\n  ⟨fun h ↦ by ext t; rw [mem_image, mem_powerset, h.subset_iff],\n    fun h t ht ↦ by rwa [← mem_powerset, ← h, mem_image] at ht⟩\n\n"}
{"name":"Finset.univ_shatters","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns : Finset α\ninst✝ : Fintype α\n⊢ Finset.univ.Shatters s","decl":"lemma univ_shatters [Fintype α] : univ.Shatters s :=\n  shatters_of_forall_subset fun _ _ ↦ mem_univ _\n\n"}
{"name":"Finset.shatters_univ","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\n𝒜 : Finset (Finset α)\ninst✝ : Fintype α\n⊢ Iff (𝒜.Shatters Finset.univ) (Eq 𝒜 Finset.univ)","decl":"@[simp] lemma shatters_univ [Fintype α] : 𝒜.Shatters univ ↔ 𝒜 = univ := by\n  rw [shatters_iff, powerset_univ]; simp_rw [univ_inter, image_id']\n\n"}
{"name":"Finset.mem_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\n⊢ Iff (Membership.mem 𝒜.shatterer s) (𝒜.Shatters s)","decl":"@[simp] lemma mem_shatterer : s ∈ 𝒜.shatterer ↔ 𝒜.Shatters s := by\n  refine mem_filter.trans <| and_iff_right_of_imp fun h ↦ ?_\n  simp_rw [mem_biUnion, mem_powerset]\n  exact h.exists_superset\n\n"}
{"name":"Finset.shatterer_mono","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\nh : HasSubset.Subset 𝒜 ℬ\n⊢ HasSubset.Subset 𝒜.shatterer ℬ.shatterer","decl":"@[gcongr] lemma shatterer_mono (h : 𝒜 ⊆ ℬ) : 𝒜.shatterer ⊆ ℬ.shatterer :=\n  fun _ ↦ by simpa using Shatters.mono_left h\n\n"}
{"name":"Finset.subset_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nh : IsLowerSet ↑𝒜\n⊢ HasSubset.Subset 𝒜 𝒜.shatterer","decl":"lemma subset_shatterer (h : IsLowerSet (𝒜 : Set (Finset α))) : 𝒜 ⊆ 𝒜.shatterer :=\n  fun _s hs ↦ mem_shatterer.2 fun t ht ↦ ⟨t, h ht hs, inter_eq_right.2 ht⟩\n\n"}
{"name":"Finset.isLowerSet_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ IsLowerSet ↑𝒜.shatterer","decl":"@[simp] lemma isLowerSet_shatterer (𝒜 : Finset (Finset α)) :\n    IsLowerSet (𝒜.shatterer : Set (Finset α)) := fun s t ↦ by simpa using Shatters.mono_right\n\n"}
{"name":"Finset.shatterer_eq","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ Iff (Eq 𝒜.shatterer 𝒜) (IsLowerSet ↑𝒜)","decl":"@[simp] lemma shatterer_eq : 𝒜.shatterer = 𝒜 ↔ IsLowerSet (𝒜 : Set (Finset α)) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ Subset.antisymm (fun s hs ↦ ?_) <| subset_shatterer h⟩\n  · rw [← h]\n    exact isLowerSet_shatterer _\n  · obtain ⟨t, ht, hst⟩ := (mem_shatterer.1 hs).exists_superset\n    exact h hst ht\n\n"}
{"name":"Finset.shatterer_idem","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ Eq 𝒜.shatterer.shatterer 𝒜.shatterer","decl":"@[simp] lemma shatterer_idem : 𝒜.shatterer.shatterer = 𝒜.shatterer := by simp\n\n"}
{"name":"Finset.shatters_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\n⊢ Iff (𝒜.shatterer.Shatters s) (𝒜.Shatters s)","decl":"@[simp] lemma shatters_shatterer : 𝒜.shatterer.Shatters s ↔ 𝒜.Shatters s := by\n  simp_rw [← mem_shatterer, shatterer_idem]\n\n"}
{"name":"Finset.Shatters.shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na✝ : 𝒜.Shatters s\n⊢ 𝒜.shatterer.Shatters s","decl":"protected alias ⟨_, Shatters.shatterer⟩ := shatters_shatterer\n\n"}
{"name":"Finset.card_le_card_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\n⊢ LE.le 𝒜.card 𝒜.shatterer.card","decl":"/-- Pajor's variant of the **Sauer-Shelah lemma**. -/\nlemma card_le_card_shatterer (𝒜 : Finset (Finset α)) : #𝒜 ≤ #𝒜.shatterer := by\n  refine memberFamily_induction_on 𝒜 ?_ ?_ ?_\n  · simp\n  · rfl\n  intros a 𝒜 ih₀ ih₁\n  set ℬ : Finset (Finset α) :=\n    ((memberSubfamily a 𝒜).shatterer ∩ (nonMemberSubfamily a 𝒜).shatterer).image (insert a)\n  have hℬ : #ℬ = #((memberSubfamily a 𝒜).shatterer ∩ (nonMemberSubfamily a 𝒜).shatterer) := by\n    refine card_image_of_injOn <| insert_erase_invOn.2.injOn.mono ?_\n    simp only [coe_inter, Set.subset_def, Set.mem_inter_iff, mem_coe, Set.mem_setOf_eq, and_imp,\n      mem_shatterer]\n    exact fun s _ ↦ aux (fun t ht ↦ (mem_filter.1 ht).2)\n  rw [← card_memberSubfamily_add_card_nonMemberSubfamily a]\n  refine (Nat.add_le_add ih₁ ih₀).trans ?_\n  rw [← card_union_add_card_inter, ← hℬ, ← card_union_of_disjoint]\n  swap\n  · simp only [ℬ, disjoint_left, mem_union, mem_shatterer, mem_image, not_exists, not_and]\n    rintro _ (hs | hs) s - rfl\n    · exact aux (fun t ht ↦ (mem_memberSubfamily.1 ht).2) hs <| mem_insert_self _ _\n    · exact aux (fun t ht ↦ (mem_nonMemberSubfamily.1 ht).2) hs <| mem_insert_self _ _\n  refine card_mono <| union_subset (union_subset ?_ <| shatterer_mono <| filter_subset _ _) ?_\n  · simp only [subset_iff, mem_shatterer]\n    rintro s hs t ht\n    obtain ⟨u, hu, rfl⟩ := hs ht\n    rw [mem_memberSubfamily] at hu\n    refine ⟨insert a u, hu.1, inter_insert_of_not_mem fun ha ↦ ?_⟩\n    obtain ⟨v, hv, hsv⟩ := hs.exists_inter_eq_singleton ha\n    rw [mem_memberSubfamily] at hv\n    rw [← singleton_subset_iff (a := a), ← hsv] at hv\n    exact hv.2 inter_subset_right\n  · refine forall_mem_image.2 fun s hs ↦ mem_shatterer.2 fun t ht ↦ ?_\n    simp only [mem_inter, mem_shatterer] at hs\n    rw [subset_insert_iff] at ht\n    by_cases ha : a ∈ t\n    · obtain ⟨u, hu, hsu⟩ := hs.1 ht\n      rw [mem_memberSubfamily] at hu\n      refine ⟨_, hu.1, ?_⟩\n      rw [← insert_inter_distrib, hsu, insert_erase ha]\n    · obtain ⟨u, hu, hsu⟩ := hs.2 ht\n      rw [mem_nonMemberSubfamily] at hu\n      refine ⟨_, hu.1, ?_⟩\n      rwa [insert_inter_of_not_mem hu.2, hsu, erase_eq_self]\n\n"}
{"name":"Finset.Shatters.of_compression","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\na : α\nhs : (Down.compression a 𝒜).Shatters s\n⊢ 𝒜.Shatters s","decl":"lemma Shatters.of_compression (hs : (𝓓 a 𝒜).Shatters s) : 𝒜.Shatters s := by\n  intros t ht\n  obtain ⟨u, hu, rfl⟩ := hs ht\n  rw [Down.mem_compression] at hu\n  obtain hu | hu := hu\n  · exact ⟨u, hu.1, rfl⟩\n  by_cases ha : a ∈ s\n  · obtain ⟨v, hv, hsv⟩ := hs <| insert_subset ha ht\n    rw [Down.mem_compression] at hv\n    obtain hv | hv := hv\n    · refine ⟨erase v a, hv.2, ?_⟩\n      rw [inter_erase, hsv, erase_insert]\n      rintro ha\n      rw [insert_eq_self.2 (mem_inter.1 ha).2] at hu\n      exact hu.1 hu.2\n    rw [insert_eq_self.2 <| inter_subset_right (s₁ := s) ?_] at hv\n    cases hv.1 hv.2\n    rw [hsv]\n    exact mem_insert_self _ _\n  · refine ⟨insert a u, hu.2, ?_⟩\n    rw [inter_insert_of_not_mem ha]\n\n"}
{"name":"Finset.shatterer_compress_subset_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ HasSubset.Subset (Down.compression a 𝒜).shatterer 𝒜.shatterer","decl":"lemma shatterer_compress_subset_shatterer (a : α) (𝒜 : Finset (Finset α)) :\n    (𝓓 a 𝒜).shatterer ⊆ 𝒜.shatterer := by\n  simp only [subset_iff, mem_shatterer]; exact fun s hs ↦ hs.of_compression\n\n"}
{"name":"Finset.vcDim_mono","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\nh𝒜ℬ : HasSubset.Subset 𝒜 ℬ\n⊢ LE.le 𝒜.vcDim ℬ.vcDim","decl":"@[gcongr] lemma vcDim_mono (h𝒜ℬ : 𝒜 ⊆ ℬ) : 𝒜.vcDim ≤ ℬ.vcDim := by unfold vcDim; gcongr\n\n"}
{"name":"Finset.Shatters.card_le_vcDim","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\ns : Finset α\nhs : 𝒜.Shatters s\n⊢ LE.le s.card 𝒜.vcDim","decl":"lemma Shatters.card_le_vcDim (hs : 𝒜.Shatters s) : #s ≤ 𝒜.vcDim := le_sup <| mem_shatterer.2 hs\n\n"}
{"name":"Finset.vcDim_compress_le","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n𝒜 : Finset (Finset α)\n⊢ LE.le (Down.compression a 𝒜).vcDim 𝒜.vcDim","decl":"/-- Down-compressing decreases the VC-dimension. -/\nlemma vcDim_compress_le (a : α) (𝒜 : Finset (Finset α)) : (𝓓 a 𝒜).vcDim ≤ 𝒜.vcDim :=\n  sup_mono <| shatterer_compress_subset_shatterer _ _\n\n"}
{"name":"Finset.card_shatterer_le_sum_vcDim","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\n𝒜 : Finset (Finset α)\ninst✝ : Fintype α\n⊢ LE.le 𝒜.shatterer.card ((Finset.Iic 𝒜.vcDim).sum fun k => (Fintype.card α).choose k)","decl":"/-- The **Sauer-Shelah lemma**. -/\nlemma card_shatterer_le_sum_vcDim [Fintype α] :\n    #𝒜.shatterer ≤ ∑ k ∈ Iic 𝒜.vcDim, (Fintype.card α).choose k := by\n  simp_rw [← card_univ, ← card_powersetCard]\n  refine (card_le_card fun s hs ↦ mem_biUnion.2 ⟨#s, ?_⟩).trans card_biUnion_le\n  exact ⟨mem_Iic.2 (mem_shatterer.1 hs).card_le_vcDim, mem_powersetCard_univ.2 rfl⟩\n\n"}
