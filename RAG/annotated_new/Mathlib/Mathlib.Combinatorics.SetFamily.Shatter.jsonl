{"name":"Finset.Shatters.exists_inter_eq_singleton","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nhs : ğ’œ.Shatters s\nha : Membership.mem s a\nâŠ¢ Exists fun t => And (Membership.mem ğ’œ t) (Eq (Inter.inter s t) (Singleton.singleton a))","decl":"lemma Shatters.exists_inter_eq_singleton (hs : Shatters ğ’œ s) (ha : a âˆˆ s) : âˆƒ t âˆˆ ğ’œ, s âˆ© t = {a} :=\n  hs <| singleton_subset_iff.2 ha\n\n"}
{"name":"Finset.Shatters.mono_left","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\ns : Finset Î±\nh : HasSubset.Subset ğ’œ â„¬\nhğ’œ : ğ’œ.Shatters s\nâŠ¢ â„¬.Shatters s","decl":"lemma Shatters.mono_left (h : ğ’œ âŠ† â„¬) (hğ’œ : ğ’œ.Shatters s) : â„¬.Shatters s :=\n  fun _t ht â†¦ let âŸ¨u, hu, hutâŸ© := hğ’œ ht; âŸ¨u, h hu, hutâŸ©\n\n"}
{"name":"Finset.Shatters.mono_right","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns t : Finset Î±\nh : HasSubset.Subset t s\nhs : ğ’œ.Shatters s\nâŠ¢ ğ’œ.Shatters t","decl":"lemma Shatters.mono_right (h : t âŠ† s) (hs : ğ’œ.Shatters s) : ğ’œ.Shatters t := fun u hu â†¦ by\n  obtain âŸ¨v, hv, rflâŸ© := hs (hu.trans h); exact âŸ¨v, hv, inf_congr_right hu <| inf_le_of_left_le hâŸ©\n\n"}
{"name":"Finset.Shatters.exists_superset","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nh : ğ’œ.Shatters s\nâŠ¢ Exists fun t => And (Membership.mem ğ’œ t) (HasSubset.Subset s t)","decl":"lemma Shatters.exists_superset (h : ğ’œ.Shatters s) : âˆƒ t âˆˆ ğ’œ, s âŠ† t :=\n  let âŸ¨t, ht, hstâŸ© := h Subset.rfl; âŸ¨t, ht, inter_eq_left.1 hstâŸ©\n\n"}
{"name":"Finset.shatters_of_forall_subset","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nh : âˆ€ (t : Finset Î±), HasSubset.Subset t s â†’ Membership.mem ğ’œ t\nâŠ¢ ğ’œ.Shatters s","decl":"lemma shatters_of_forall_subset (h : âˆ€ t, t âŠ† s â†’ t âˆˆ ğ’œ) : ğ’œ.Shatters s :=\n  fun t ht â†¦ âŸ¨t, h _ ht, inter_eq_right.2 htâŸ©\n\n"}
{"name":"Finset.Shatters.nonempty","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nh : ğ’œ.Shatters s\nâŠ¢ ğ’œ.Nonempty","decl":"protected lemma Shatters.nonempty (h : ğ’œ.Shatters s) : ğ’œ.Nonempty :=\n  let âŸ¨t, ht, _âŸ© := h Subset.rfl; âŸ¨t, htâŸ©\n\n"}
{"name":"Finset.shatters_empty","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Iff (ğ’œ.Shatters EmptyCollection.emptyCollection) ğ’œ.Nonempty","decl":"@[simp] lemma shatters_empty : ğ’œ.Shatters âˆ… â†” ğ’œ.Nonempty :=\n  âŸ¨Shatters.nonempty, fun âŸ¨s, hsâŸ© t ht â†¦ âŸ¨s, hs, by rwa [empty_inter, eq_comm, â† subset_empty]âŸ©âŸ©\n\n"}
{"name":"Finset.Shatters.subset_iff","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns t : Finset Î±\nh : ğ’œ.Shatters s\nâŠ¢ Iff (HasSubset.Subset t s) (Exists fun u => And (Membership.mem ğ’œ u) (Eq (Inter.inter s u) t))","decl":"protected lemma Shatters.subset_iff (h : ğ’œ.Shatters s) : t âŠ† s â†” âˆƒ u âˆˆ ğ’œ, s âˆ© u = t :=\n  âŸ¨fun ht â†¦ h ht, by rintro âŸ¨u, _, rflâŸ©; exact inter_subset_leftâŸ©\n\n"}
{"name":"Finset.shatters_iff","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nâŠ¢ Iff (ğ’œ.Shatters s) (Eq (Finset.image (fun t => Inter.inter s t) ğ’œ) s.powerset)","decl":"lemma shatters_iff : ğ’œ.Shatters s â†” ğ’œ.image (fun t â†¦ s âˆ© t) = s.powerset :=\n  âŸ¨fun h â†¦ by ext t; rw [mem_image, mem_powerset, h.subset_iff],\n    fun h t ht â†¦ by rwa [â† mem_powerset, â† h, mem_image] at htâŸ©\n\n"}
{"name":"Finset.univ_shatters","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ns : Finset Î±\ninstâœ : Fintype Î±\nâŠ¢ Finset.univ.Shatters s","decl":"lemma univ_shatters [Fintype Î±] : univ.Shatters s :=\n  shatters_of_forall_subset fun _ _ â†¦ mem_univ _\n\n"}
{"name":"Finset.shatters_univ","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ninstâœ : Fintype Î±\nâŠ¢ Iff (ğ’œ.Shatters Finset.univ) (Eq ğ’œ Finset.univ)","decl":"@[simp] lemma shatters_univ [Fintype Î±] : ğ’œ.Shatters univ â†” ğ’œ = univ := by\n  rw [shatters_iff, powerset_univ]; simp_rw [univ_inter, image_id']\n\n"}
{"name":"Finset.mem_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nâŠ¢ Iff (Membership.mem ğ’œ.shatterer s) (ğ’œ.Shatters s)","decl":"@[simp] lemma mem_shatterer : s âˆˆ ğ’œ.shatterer â†” ğ’œ.Shatters s := by\n  refine mem_filter.trans <| and_iff_right_of_imp fun h â†¦ ?_\n  simp_rw [mem_biUnion, mem_powerset]\n  exact h.exists_superset\n\n"}
{"name":"Finset.shatterer_mono","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\nh : HasSubset.Subset ğ’œ â„¬\nâŠ¢ HasSubset.Subset ğ’œ.shatterer â„¬.shatterer","decl":"@[gcongr] lemma shatterer_mono (h : ğ’œ âŠ† â„¬) : ğ’œ.shatterer âŠ† â„¬.shatterer :=\n  fun _ â†¦ by simpa using Shatters.mono_left h\n\n"}
{"name":"Finset.subset_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nh : IsLowerSet â†‘ğ’œ\nâŠ¢ HasSubset.Subset ğ’œ ğ’œ.shatterer","decl":"lemma subset_shatterer (h : IsLowerSet (ğ’œ : Set (Finset Î±))) : ğ’œ âŠ† ğ’œ.shatterer :=\n  fun _s hs â†¦ mem_shatterer.2 fun t ht â†¦ âŸ¨t, h ht hs, inter_eq_right.2 htâŸ©\n\n"}
{"name":"Finset.isLowerSet_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ IsLowerSet â†‘ğ’œ.shatterer","decl":"@[simp] lemma isLowerSet_shatterer (ğ’œ : Finset (Finset Î±)) :\n    IsLowerSet (ğ’œ.shatterer : Set (Finset Î±)) := fun s t â†¦ by simpa using Shatters.mono_right\n\n"}
{"name":"Finset.shatterer_eq","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Iff (Eq ğ’œ.shatterer ğ’œ) (IsLowerSet â†‘ğ’œ)","decl":"@[simp] lemma shatterer_eq : ğ’œ.shatterer = ğ’œ â†” IsLowerSet (ğ’œ : Set (Finset Î±)) := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ Subset.antisymm (fun s hs â†¦ ?_) <| subset_shatterer hâŸ©\n  Â· rw [â† h]\n    exact isLowerSet_shatterer _\n  Â· obtain âŸ¨t, ht, hstâŸ© := (mem_shatterer.1 hs).exists_superset\n    exact h hst ht\n\n"}
{"name":"Finset.shatterer_idem","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq ğ’œ.shatterer.shatterer ğ’œ.shatterer","decl":"@[simp] lemma shatterer_idem : ğ’œ.shatterer.shatterer = ğ’œ.shatterer := by simp\n\n"}
{"name":"Finset.shatters_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nâŠ¢ Iff (ğ’œ.shatterer.Shatters s) (ğ’œ.Shatters s)","decl":"@[simp] lemma shatters_shatterer : ğ’œ.shatterer.Shatters s â†” ğ’œ.Shatters s := by\n  simp_rw [â† mem_shatterer, shatterer_idem]\n\n"}
{"name":"Finset.Shatters.shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\naâœ : ğ’œ.Shatters s\nâŠ¢ ğ’œ.shatterer.Shatters s","decl":"protected alias âŸ¨_, Shatters.shattererâŸ© := shatters_shatterer\n\n"}
{"name":"Finset.card_le_card_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ LE.le ğ’œ.card ğ’œ.shatterer.card","decl":"/-- Pajor's variant of the **Sauer-Shelah lemma**. -/\nlemma card_le_card_shatterer (ğ’œ : Finset (Finset Î±)) : #ğ’œ â‰¤ #ğ’œ.shatterer := by\n  refine memberFamily_induction_on ğ’œ ?_ ?_ ?_\n  Â· simp\n  Â· rfl\n  intros a ğ’œ ihâ‚€ ihâ‚\n  set â„¬ : Finset (Finset Î±) :=\n    ((memberSubfamily a ğ’œ).shatterer âˆ© (nonMemberSubfamily a ğ’œ).shatterer).image (insert a)\n  have hâ„¬ : #â„¬ = #((memberSubfamily a ğ’œ).shatterer âˆ© (nonMemberSubfamily a ğ’œ).shatterer) := by\n    refine card_image_of_injOn <| insert_erase_invOn.2.injOn.mono ?_\n    simp only [coe_inter, Set.subset_def, Set.mem_inter_iff, mem_coe, Set.mem_setOf_eq, and_imp,\n      mem_shatterer]\n    exact fun s _ â†¦ aux (fun t ht â†¦ (mem_filter.1 ht).2)\n  rw [â† card_memberSubfamily_add_card_nonMemberSubfamily a]\n  refine (Nat.add_le_add ihâ‚ ihâ‚€).trans ?_\n  rw [â† card_union_add_card_inter, â† hâ„¬, â† card_union_of_disjoint]\n  swap\n  Â· simp only [â„¬, disjoint_left, mem_union, mem_shatterer, mem_image, not_exists, not_and]\n    rintro _ (hs | hs) s - rfl\n    Â· exact aux (fun t ht â†¦ (mem_memberSubfamily.1 ht).2) hs <| mem_insert_self _ _\n    Â· exact aux (fun t ht â†¦ (mem_nonMemberSubfamily.1 ht).2) hs <| mem_insert_self _ _\n  refine card_mono <| union_subset (union_subset ?_ <| shatterer_mono <| filter_subset _ _) ?_\n  Â· simp only [subset_iff, mem_shatterer]\n    rintro s hs t ht\n    obtain âŸ¨u, hu, rflâŸ© := hs ht\n    rw [mem_memberSubfamily] at hu\n    refine âŸ¨insert a u, hu.1, inter_insert_of_not_mem fun ha â†¦ ?_âŸ©\n    obtain âŸ¨v, hv, hsvâŸ© := hs.exists_inter_eq_singleton ha\n    rw [mem_memberSubfamily] at hv\n    rw [â† singleton_subset_iff (a := a), â† hsv] at hv\n    exact hv.2 inter_subset_right\n  Â· refine forall_mem_image.2 fun s hs â†¦ mem_shatterer.2 fun t ht â†¦ ?_\n    simp only [mem_inter, mem_shatterer] at hs\n    rw [subset_insert_iff] at ht\n    by_cases ha : a âˆˆ t\n    Â· obtain âŸ¨u, hu, hsuâŸ© := hs.1 ht\n      rw [mem_memberSubfamily] at hu\n      refine âŸ¨_, hu.1, ?_âŸ©\n      rw [â† insert_inter_distrib, hsu, insert_erase ha]\n    Â· obtain âŸ¨u, hu, hsuâŸ© := hs.2 ht\n      rw [mem_nonMemberSubfamily] at hu\n      refine âŸ¨_, hu.1, ?_âŸ©\n      rwa [insert_inter_of_not_mem hu.2, hsu, erase_eq_self]\n\n"}
{"name":"Finset.Shatters.of_compression","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\na : Î±\nhs : (Down.compression a ğ’œ).Shatters s\nâŠ¢ ğ’œ.Shatters s","decl":"lemma Shatters.of_compression (hs : (ğ““ a ğ’œ).Shatters s) : ğ’œ.Shatters s := by\n  intros t ht\n  obtain âŸ¨u, hu, rflâŸ© := hs ht\n  rw [Down.mem_compression] at hu\n  obtain hu | hu := hu\n  Â· exact âŸ¨u, hu.1, rflâŸ©\n  by_cases ha : a âˆˆ s\n  Â· obtain âŸ¨v, hv, hsvâŸ© := hs <| insert_subset ha ht\n    rw [Down.mem_compression] at hv\n    obtain hv | hv := hv\n    Â· refine âŸ¨erase v a, hv.2, ?_âŸ©\n      rw [inter_erase, hsv, erase_insert]\n      rintro ha\n      rw [insert_eq_self.2 (mem_inter.1 ha).2] at hu\n      exact hu.1 hu.2\n    rw [insert_eq_self.2 <| inter_subset_right (sâ‚ := s) ?_] at hv\n    cases hv.1 hv.2\n    rw [hsv]\n    exact mem_insert_self _ _\n  Â· refine âŸ¨insert a u, hu.2, ?_âŸ©\n    rw [inter_insert_of_not_mem ha]\n\n"}
{"name":"Finset.shatterer_compress_subset_shatterer","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ HasSubset.Subset (Down.compression a ğ’œ).shatterer ğ’œ.shatterer","decl":"lemma shatterer_compress_subset_shatterer (a : Î±) (ğ’œ : Finset (Finset Î±)) :\n    (ğ““ a ğ’œ).shatterer âŠ† ğ’œ.shatterer := by\n  simp only [subset_iff, mem_shatterer]; exact fun s hs â†¦ hs.of_compression\n\n"}
{"name":"Finset.vcDim_mono","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\nhğ’œâ„¬ : HasSubset.Subset ğ’œ â„¬\nâŠ¢ LE.le ğ’œ.vcDim â„¬.vcDim","decl":"@[gcongr] lemma vcDim_mono (hğ’œâ„¬ : ğ’œ âŠ† â„¬) : ğ’œ.vcDim â‰¤ â„¬.vcDim := by unfold vcDim; gcongr\n\n"}
{"name":"Finset.Shatters.card_le_vcDim","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ns : Finset Î±\nhs : ğ’œ.Shatters s\nâŠ¢ LE.le s.card ğ’œ.vcDim","decl":"lemma Shatters.card_le_vcDim (hs : ğ’œ.Shatters s) : #s â‰¤ ğ’œ.vcDim := le_sup <| mem_shatterer.2 hs\n\n"}
{"name":"Finset.vcDim_compress_le","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœ : DecidableEq Î±\na : Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ LE.le (Down.compression a ğ’œ).vcDim ğ’œ.vcDim","decl":"/-- Down-compressing decreases the VC-dimension. -/\nlemma vcDim_compress_le (a : Î±) (ğ’œ : Finset (Finset Î±)) : (ğ““ a ğ’œ).vcDim â‰¤ ğ’œ.vcDim :=\n  sup_mono <| shatterer_compress_subset_shatterer _ _\n\n"}
{"name":"Finset.card_shatterer_le_sum_vcDim","module":"Mathlib.Combinatorics.SetFamily.Shatter","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ninstâœ : Fintype Î±\nâŠ¢ LE.le ğ’œ.shatterer.card ((Finset.Iic ğ’œ.vcDim).sum fun k => (Fintype.card Î±).choose k)","decl":"/-- The **Sauer-Shelah lemma**. -/\nlemma card_shatterer_le_sum_vcDim [Fintype Î±] :\n    #ğ’œ.shatterer â‰¤ âˆ‘ k âˆˆ Iic ğ’œ.vcDim, (Fintype.card Î±).choose k := by\n  simp_rw [â† card_univ, â† card_powersetCard]\n  refine (card_le_card fun s hs â†¦ mem_biUnion.2 âŸ¨#s, ?_âŸ©).trans card_biUnion_le\n  exact âŸ¨mem_Iic.2 (mem_shatterer.1 hs).card_le_vcDim, mem_powersetCard_univ.2 rflâŸ©\n\n"}
