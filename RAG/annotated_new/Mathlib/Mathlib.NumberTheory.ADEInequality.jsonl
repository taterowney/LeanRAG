{"name":"ADEInequality.sumInv_pqr","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"p q r : PNat\n⊢ Eq (ADEInequality.sumInv (Insert.insert p (Insert.insert q (Singleton.singleton r)))) (HAdd.hAdd (HAdd.hAdd (Inv.inv ↑↑p) (Inv.inv ↑↑q)) (Inv.inv ↑↑r))","decl":"theorem sumInv_pqr (p q r : ℕ+) : sumInv {p, q, r} = (p : ℚ)⁻¹ + (q : ℚ)⁻¹ + (r : ℚ)⁻¹ := by\n  simp only [sumInv, add_zero, insert_eq_cons, add_assoc, map_cons, sum_cons,\n    map_singleton, sum_singleton]\n\n"}
{"name":"ADEInequality.admissible_A'","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"q r : PNat\n⊢ ADEInequality.Admissible (ADEInequality.A' q r)","decl":"theorem admissible_A' (q r : ℕ+) : Admissible (A' q r) :=\n  Or.inl ⟨q, r, rfl⟩\n\n"}
{"name":"ADEInequality.admissible_D'","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"n : PNat\n⊢ ADEInequality.Admissible (ADEInequality.D' n)","decl":"theorem admissible_D' (n : ℕ+) : Admissible (D' n) :=\n  Or.inr <| Or.inl ⟨n, rfl⟩\n\n"}
{"name":"ADEInequality.admissible_E'3","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible (ADEInequality.E' 3)","decl":"theorem admissible_E'3 : Admissible (E' 3) :=\n  Or.inr <| Or.inr <| Or.inl rfl\n\n"}
{"name":"ADEInequality.admissible_E'4","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible (ADEInequality.E' 4)","decl":"theorem admissible_E'4 : Admissible (E' 4) :=\n  Or.inr <| Or.inr <| Or.inr <| Or.inl rfl\n\n"}
{"name":"ADEInequality.admissible_E'5","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible (ADEInequality.E' 5)","decl":"theorem admissible_E'5 : Admissible (E' 5) :=\n  Or.inr <| Or.inr <| Or.inr <| Or.inr rfl\n\n"}
{"name":"ADEInequality.admissible_E6","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible ADEInequality.E6","decl":"theorem admissible_E6 : Admissible E6 :=\n  admissible_E'3\n\n"}
{"name":"ADEInequality.admissible_E7","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible ADEInequality.E7","decl":"theorem admissible_E7 : Admissible E7 :=\n  admissible_E'4\n\n"}
{"name":"ADEInequality.admissible_E8","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"⊢ ADEInequality.Admissible ADEInequality.E8","decl":"theorem admissible_E8 : Admissible E8 :=\n  admissible_E'5\n\n"}
{"name":"ADEInequality.Admissible.one_lt_sumInv","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"pqr : Multiset PNat\na✝ : ADEInequality.Admissible pqr\n⊢ LT.lt 1 (ADEInequality.sumInv pqr)","decl":"theorem Admissible.one_lt_sumInv {pqr : Multiset ℕ+} : Admissible pqr → 1 < sumInv pqr := by\n  rw [Admissible]\n  rintro (⟨p', q', H⟩ | ⟨n, H⟩ | H | H | H)\n  · rw [← H, A', sumInv_pqr, add_assoc]\n    simp only [lt_add_iff_pos_right, PNat.one_coe, inv_one, Nat.cast_one]\n    apply add_pos <;> simp only [PNat.pos, Nat.cast_pos, inv_pos]\n  · rw [← H, D', sumInv_pqr]\n    norm_num\n  all_goals\n    rw [← H, E', sumInv_pqr]\n    norm_num\n\n"}
{"name":"ADEInequality.lt_three","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"p q r : PNat\nhpq : LE.le p q\nhqr : LE.le q r\nH : LT.lt 1 (ADEInequality.sumInv (Insert.insert p (Insert.insert q (Singleton.singleton r))))\n⊢ LT.lt p 3","decl":"theorem lt_three {p q r : ℕ+} (hpq : p ≤ q) (hqr : q ≤ r) (H : 1 < sumInv {p, q, r}) : p < 3 := by\n  have h3 : (0 : ℚ) < 3 := by norm_num\n  contrapose! H\n  rw [sumInv_pqr]\n  have h3q := H.trans hpq\n  have h3r := h3q.trans hqr\n  have hp : (p : ℚ)⁻¹ ≤ 3⁻¹ := by\n    rw [inv_le_inv₀ _ h3]\n    · assumption_mod_cast\n    · norm_num\n  have hq : (q : ℚ)⁻¹ ≤ 3⁻¹ := by\n    rw [inv_le_inv₀ _ h3]\n    · assumption_mod_cast\n    · norm_num\n  have hr : (r : ℚ)⁻¹ ≤ 3⁻¹ := by\n    rw [inv_le_inv₀ _ h3]\n    · assumption_mod_cast\n    · norm_num\n  calc\n    (p : ℚ)⁻¹ + (q : ℚ)⁻¹ + (r : ℚ)⁻¹ ≤ 3⁻¹ + 3⁻¹ + 3⁻¹ := add_le_add (add_le_add hp hq) hr\n    _ = 1 := by norm_num\n\n"}
{"name":"ADEInequality.lt_four","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"q r : PNat\nhqr : LE.le q r\nH : LT.lt 1 (ADEInequality.sumInv (Insert.insert 2 (Insert.insert q (Singleton.singleton r))))\n⊢ LT.lt q 4","decl":"theorem lt_four {q r : ℕ+} (hqr : q ≤ r) (H : 1 < sumInv {2, q, r}) : q < 4 := by\n  have h4 : (0 : ℚ) < 4 := by norm_num\n  contrapose! H\n  rw [sumInv_pqr]\n  have h4r := H.trans hqr\n  have hq : (q : ℚ)⁻¹ ≤ 4⁻¹ := by\n    rw [inv_le_inv₀ _ h4]\n    · assumption_mod_cast\n    · norm_num\n  have hr : (r : ℚ)⁻¹ ≤ 4⁻¹ := by\n    rw [inv_le_inv₀ _ h4]\n    · assumption_mod_cast\n    · norm_num\n  calc\n    (2⁻¹ + (q : ℚ)⁻¹ + (r : ℚ)⁻¹) ≤ 2⁻¹ + 4⁻¹ + 4⁻¹ := add_le_add (add_le_add le_rfl hq) hr\n    _ = 1 := by norm_num\n\n"}
{"name":"ADEInequality.lt_six","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"r : PNat\nH : LT.lt 1 (ADEInequality.sumInv (Insert.insert 2 (Insert.insert 3 (Singleton.singleton r))))\n⊢ LT.lt r 6","decl":"theorem lt_six {r : ℕ+} (H : 1 < sumInv {2, 3, r}) : r < 6 := by\n  have h6 : (0 : ℚ) < 6 := by norm_num\n  contrapose! H\n  rw [sumInv_pqr]\n  have hr : (r : ℚ)⁻¹ ≤ 6⁻¹ := by\n    rw [inv_le_inv₀ _ h6]\n    · assumption_mod_cast\n    · norm_num\n  calc\n    (2⁻¹ + 3⁻¹ + (r : ℚ)⁻¹ : ℚ) ≤ 2⁻¹ + 3⁻¹ + 6⁻¹ := add_le_add (add_le_add le_rfl le_rfl) hr\n    _ = 1 := by norm_num\n\n"}
{"name":"ADEInequality.admissible_of_one_lt_sumInv_aux'","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"p q r : PNat\nhpq : LE.le p q\nhqr : LE.le q r\nH : LT.lt 1 (ADEInequality.sumInv (Insert.insert p (Insert.insert q (Singleton.singleton r))))\n⊢ ADEInequality.Admissible (Insert.insert p (Insert.insert q (Singleton.singleton r)))","decl":"theorem admissible_of_one_lt_sumInv_aux' {p q r : ℕ+} (hpq : p ≤ q) (hqr : q ≤ r)\n    (H : 1 < sumInv {p, q, r}) : Admissible {p, q, r} := by\n  have hp3 : p < 3 := lt_three hpq hqr H\n  -- Porting note: `interval_cases` doesn't support `ℕ+` yet.\n  replace hp3 := Finset.mem_Iio.mpr hp3\n  conv at hp3 => change p ∈ ({1, 2} : Multiset ℕ+)\n  fin_cases hp3\n  · exact admissible_A' q r\n  have hq4 : q < 4 := lt_four hqr H\n  replace hq4 := Finset.mem_Ico.mpr ⟨hpq, hq4⟩; clear hpq\n  conv at hq4 => change q ∈ ({2, 3} : Multiset ℕ+)\n  fin_cases hq4\n  · exact admissible_D' r\n  have hr6 : r < 6 := lt_six H\n  replace hr6 := Finset.mem_Ico.mpr ⟨hqr, hr6⟩; clear hqr\n  conv at hr6 => change r ∈ ({3, 4, 5} : Multiset ℕ+)\n  fin_cases hr6\n  · exact admissible_E6\n  · exact admissible_E7\n  · exact admissible_E8\n\n"}
{"name":"ADEInequality.admissible_of_one_lt_sumInv_aux","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"pqr : List PNat\nx✝² : List.Sorted (fun x1 x2 => LE.le x1 x2) pqr\nx✝¹ : Eq pqr.length 3\nx✝ : LT.lt 1 (ADEInequality.sumInv ↑pqr)\n⊢ ADEInequality.Admissible ↑pqr","decl":"theorem admissible_of_one_lt_sumInv_aux :\n    ∀ {pqr : List ℕ+} (_ : pqr.Sorted (· ≤ ·)) (_ : pqr.length = 3) (_ : 1 < sumInv pqr),\n      Admissible pqr\n  | [p, q, r], hs, _, H => by\n    obtain ⟨⟨hpq, -⟩, hqr⟩ : (p ≤ q ∧ p ≤ r) ∧ q ≤ r := by simpa using hs\n    exact admissible_of_one_lt_sumInv_aux' hpq hqr H\n\n"}
{"name":"ADEInequality.admissible_of_one_lt_sumInv","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"p q r : PNat\nH : LT.lt 1 (ADEInequality.sumInv (Insert.insert p (Insert.insert q (Singleton.singleton r))))\n⊢ ADEInequality.Admissible (Insert.insert p (Insert.insert q (Singleton.singleton r)))","decl":"theorem admissible_of_one_lt_sumInv {p q r : ℕ+} (H : 1 < sumInv {p, q, r}) :\n    Admissible {p, q, r} := by\n  simp only [Admissible]\n  let S := sort ((· ≤ ·) : ℕ+ → ℕ+ → Prop) {p, q, r}\n  have hS : S.Sorted (· ≤ ·) := sort_sorted _ _\n  have hpqr : ({p, q, r} : Multiset ℕ+) = S := (sort_eq LE.le {p, q, r}).symm\n  rw [hpqr]\n  rw [hpqr] at H\n  apply admissible_of_one_lt_sumInv_aux hS _ H\n  simp only [S, insert_eq_cons, length_sort, card_cons, card_singleton]\n\n"}
{"name":"ADEInequality.classification","module":"Mathlib.NumberTheory.ADEInequality","initialProofState":"p q r : PNat\n⊢ Iff (LT.lt 1 (ADEInequality.sumInv (Insert.insert p (Insert.insert q (Singleton.singleton r))))) (ADEInequality.Admissible (Insert.insert p (Insert.insert q (Singleton.singleton r))))","decl":"/-- A multiset `{p,q,r}` of positive natural numbers\nis a solution to `(p⁻¹ + q⁻¹ + r⁻¹ : ℚ) > 1` if and only if\nit is `admissible` which means it is one of:\n\n* `A' q r := {1,q,r}`\n* `D' r := {2,2,r}`\n* `E6 := {2,3,3}`, or `E7 := {2,3,4}`, or `E8 := {2,3,5}`\n-/\ntheorem classification (p q r : ℕ+) : 1 < sumInv {p, q, r} ↔ Admissible {p, q, r} :=\n  ⟨admissible_of_one_lt_sumInv, Admissible.one_lt_sumInv⟩\n\n"}
