{"name":"commProb_def","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝ : Mul M\n⊢ Eq (commProb M) (HDiv.hDiv (↑(Nat.card (Subtype fun p => Commute p.1 p.2))) (HPow.hPow (↑(Nat.card M)) 2))","decl":"theorem commProb_def :\n    commProb M = Nat.card { p : M × M // Commute p.1 p.2 } / (Nat.card M : ℚ) ^ 2 :=\n  rfl\n\n"}
{"name":"commProb_prod","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\nM' : Type u_2\ninst✝ : Mul M'\n⊢ Eq (commProb (Prod M M')) (HMul.hMul (commProb M) (commProb M'))","decl":"theorem commProb_prod (M' : Type*) [Mul M'] : commProb (M × M') = commProb M * commProb M' := by\n  simp_rw [commProb_def, div_mul_div_comm, Nat.card_prod, Nat.cast_mul, mul_pow, ← Nat.cast_mul,\n    ← Nat.card_prod, Commute, SemiconjBy, Prod.ext_iff]\n  congr 2\n  exact Nat.card_congr ⟨fun x => ⟨⟨⟨x.1.1.1, x.1.2.1⟩, x.2.1⟩, ⟨⟨x.1.1.2, x.1.2.2⟩, x.2.2⟩⟩,\n    fun x => ⟨⟨⟨x.1.1.1, x.2.1.1⟩, ⟨x.1.1.2, x.2.1.2⟩⟩, ⟨x.1.2, x.2.2⟩⟩, fun x => rfl, fun x => rfl⟩\n\n"}
{"name":"commProb_pi","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"α : Type u_2\ni : α → Type u_3\ninst✝¹ : Fintype α\ninst✝ : (a : α) → Mul (i a)\n⊢ Eq (commProb ((a : α) → i a)) (Finset.univ.prod fun a => commProb (i a))","decl":"theorem commProb_pi {α : Type*} (i : α → Type*) [Fintype α] [∀ a, Mul (i a)] :\n    commProb (∀ a, i a) = ∏ a, commProb (i a) := by\n  simp_rw [commProb_def, Finset.prod_div_distrib, Finset.prod_pow, ← Nat.cast_prod,\n    ← Nat.card_pi, Commute, SemiconjBy, funext_iff]\n  congr 2\n  exact Nat.card_congr ⟨fun x a => ⟨⟨x.1.1 a, x.1.2 a⟩, x.2 a⟩, fun x => ⟨⟨fun a => (x a).1.1,\n    fun a => (x a).1.2⟩, fun a => (x a).2⟩, fun x => rfl, fun x => rfl⟩\n\n"}
{"name":"commProb_function","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Fintype α\ninst✝ : Mul β\n⊢ Eq (commProb (α → β)) (HPow.hPow (commProb β) (Fintype.card α))","decl":"theorem commProb_function {α β : Type*} [Fintype α] [Mul β] :\n    commProb (α → β) = (commProb β) ^ Fintype.card α := by\n  rw [commProb_pi, Finset.prod_const, Finset.card_univ]\n\n"}
{"name":"commProb_eq_zero_of_infinite","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : Infinite M\n⊢ Eq (commProb M) 0","decl":"@[simp]\ntheorem commProb_eq_zero_of_infinite [Infinite M] : commProb M = 0 :=\n  div_eq_zero_iff.2 (Or.inl (Nat.cast_eq_zero.2 Nat.card_eq_zero_of_infinite))\n\n"}
{"name":"commProb_pos","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : Finite M\nh : Nonempty M\n⊢ LT.lt 0 (commProb M)","decl":"theorem commProb_pos [h : Nonempty M] : 0 < commProb M :=\n  h.elim fun x ↦\n    div_pos (Nat.cast_pos.mpr (Finite.card_pos_iff.mpr ⟨⟨(x, x), rfl⟩⟩))\n      (pow_pos (Nat.cast_pos.mpr Finite.card_pos) 2)\n\n"}
{"name":"commProb_le_one","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : Finite M\n⊢ LE.le (commProb M) 1","decl":"theorem commProb_le_one : commProb M ≤ 1 := by\n  refine div_le_one_of_le₀ ?_ (sq_nonneg (Nat.card M : ℚ))\n  rw [← Nat.cast_pow, Nat.cast_le, sq, ← Nat.card_prod]\n  apply Finite.card_subtype_le\n\n"}
{"name":"commProb_eq_one_iff","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : Finite M\nh : Nonempty M\n⊢ Iff (Eq (commProb M) 1) (Std.Commutative fun x1 x2 => HMul.hMul x1 x2)","decl":"theorem commProb_eq_one_iff [h : Nonempty M] :\n    commProb M = 1 ↔ Std.Commutative ((· * ·) : M → M → M) := by\n  classical\n  haveI := Fintype.ofFinite M\n  rw [commProb, ← Set.coe_setOf, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  rw [div_eq_one_iff_eq, ← Nat.cast_pow, Nat.cast_inj, sq, ← card_prod,\n    set_fintype_card_eq_univ_iff, Set.eq_univ_iff_forall]\n  · exact ⟨fun h ↦ ⟨fun x y ↦ h (x, y)⟩, fun h x ↦ h.comm x.1 x.2⟩\n  · exact pow_ne_zero 2 (Nat.cast_ne_zero.mpr card_ne_zero)\n\n"}
{"name":"commProb_def'","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Eq (commProb G) (HDiv.hDiv ↑(Nat.card (ConjClasses G)) ↑(Nat.card G))","decl":"theorem commProb_def' : commProb G = Nat.card (ConjClasses G) / Nat.card G := by\n  rw [commProb, card_comm_eq_card_conjClasses_mul_card, Nat.cast_mul, sq]\n  by_cases h : (Nat.card G : ℚ) = 0\n  · rw [h, zero_mul, div_zero, div_zero]\n  · exact mul_div_mul_right _ _ h\n\n"}
{"name":"Subgroup.commProb_subgroup_le","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"G : Type u_2\ninst✝¹ : Group G\ninst✝ : Finite G\nH : Subgroup G\n⊢ LE.le (commProb (Subtype fun x => Membership.mem H x)) (HMul.hMul (commProb G) (HPow.hPow (↑H.index) 2))","decl":"theorem Subgroup.commProb_subgroup_le : commProb H ≤ commProb G * (H.index : ℚ) ^ 2 := by\n  /- After rewriting with `commProb_def`, we reduce to showing that `G` has at least as many\n      commuting pairs as `H`. -/\n  rw [commProb_def, commProb_def, div_le_iff₀, mul_assoc, ← mul_pow, ← Nat.cast_mul,\n    mul_comm H.index, H.card_mul_index, div_mul_cancel₀, Nat.cast_le]\n  · refine Finite.card_le_of_injective (fun p ↦ ⟨⟨p.1.1, p.1.2⟩, Subtype.ext_iff.mp p.2⟩) ?_\n    exact fun p q h ↦ by simpa only [Subtype.ext_iff, Prod.ext_iff] using h\n  · exact pow_ne_zero 2 (Nat.cast_ne_zero.mpr Finite.card_pos.ne')\n  · exact pow_pos (Nat.cast_pos.mpr Finite.card_pos) 2\n\n"}
{"name":"Subgroup.commProb_quotient_le","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"G : Type u_2\ninst✝² : Group G\ninst✝¹ : Finite G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ LE.le (commProb (HasQuotient.Quotient G H)) (HMul.hMul (commProb G) ↑(Nat.card (Subtype fun x => Membership.mem H x)))","decl":"theorem Subgroup.commProb_quotient_le [H.Normal] : commProb (G ⧸ H) ≤ commProb G * Nat.card H := by\n  /- After rewriting with `commProb_def'`, we reduce to showing that `G` has at least as many\n      conjugacy classes as `G ⧸ H`. -/\n  rw [commProb_def', commProb_def', div_le_iff₀, mul_assoc, ← Nat.cast_mul, ← Subgroup.index,\n    H.card_mul_index, div_mul_cancel₀, Nat.cast_le]\n  · apply Finite.card_le_of_surjective\n    show Function.Surjective (ConjClasses.map (QuotientGroup.mk' H))\n    exact ConjClasses.map_surjective Quotient.mk''_surjective\n  · exact Nat.cast_ne_zero.mpr Finite.card_pos.ne'\n  · exact Nat.cast_pos.mpr Finite.card_pos\n\n"}
{"name":"inv_card_commutator_le_commProb","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"G : Type u_2\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ LE.le (Inv.inv ↑(Nat.card (Subtype fun x => Membership.mem (commutator G) x))) (commProb G)","decl":"theorem inv_card_commutator_le_commProb : (↑(Nat.card (commutator G)))⁻¹ ≤ commProb G :=\n  (inv_le_iff_one_le_mul₀ (Nat.cast_pos.mpr Finite.card_pos)).mpr\n    (le_trans (ge_of_eq (commProb_eq_one_iff.mpr ⟨(Abelianization.commGroup G).mul_comm⟩))\n      (commutator G).commProb_quotient_le)\n\n-- Construction of group with commuting probability 1/n\n"}
{"name":"DihedralGroup.commProb_odd","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"n : Nat\nhn : Odd n\n⊢ Eq (commProb (DihedralGroup n)) (HDiv.hDiv (HAdd.hAdd (↑n) 3) (HMul.hMul 4 ↑n))","decl":"lemma commProb_odd {n : ℕ} (hn : Odd n) :\n    commProb (DihedralGroup n) = (n + 3) / (4 * n) := by\n  rw [commProb_def', DihedralGroup.card_conjClasses_odd hn, nat_card]\n  qify [show 2 ∣ n + 3 by rw [Nat.dvd_iff_mod_eq_zero, Nat.add_mod, Nat.odd_iff.mp hn]]\n  rw [div_div, ← mul_assoc]\n  congr\n  norm_num\n\n"}
{"name":"DihedralGroup.reciprocalFactors_zero","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"⊢ Eq (DihedralGroup.reciprocalFactors 0) (List.cons 0 List.nil)","decl":"@[simp] lemma reciprocalFactors_zero : reciprocalFactors 0 = [0] := by\n  unfold reciprocalFactors; rfl\n\n"}
{"name":"DihedralGroup.reciprocalFactors_one","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"⊢ Eq (DihedralGroup.reciprocalFactors 1) List.nil","decl":"@[simp] lemma reciprocalFactors_one : reciprocalFactors 1 = [] := by\n  unfold reciprocalFactors; rfl\n\n"}
{"name":"DihedralGroup.reciprocalFactors_even","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"n : Nat\nh0 : Ne n 0\nh2 : Even n\n⊢ Eq (DihedralGroup.reciprocalFactors n) (List.cons 3 (DihedralGroup.reciprocalFactors (HDiv.hDiv n 2)))","decl":"lemma reciprocalFactors_even {n : ℕ} (h0 : n ≠ 0) (h2 : Even n) :\n    reciprocalFactors n = 3 :: reciprocalFactors (n / 2) := by\n  have h1 : n ≠ 1 := by\n    rintro rfl\n    norm_num at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_pos h2]\n\n"}
{"name":"DihedralGroup.reciprocalFactors_odd","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"n : Nat\nh1 : Ne n 1\nh2 : Odd n\n⊢ Eq (DihedralGroup.reciprocalFactors n) (List.cons (HMul.hMul (HMod.hMod n 4) n) (DihedralGroup.reciprocalFactors (HAdd.hAdd (HDiv.hDiv n 4) 1)))","decl":"lemma reciprocalFactors_odd {n : ℕ} (h1 : n ≠ 1) (h2 : Odd n) :\n    reciprocalFactors n = n % 4 * n :: reciprocalFactors (n / 4 + 1) := by\n  have h0 : n ≠ 0 := by\n    rintro rfl\n    norm_num [← Nat.not_even_iff_odd] at h2\n  rw [reciprocalFactors, dif_neg h0, dif_neg h1, if_neg (Nat.not_even_iff_odd.2 h2)]\n\n"}
{"name":"DihedralGroup.commProb_nil","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"⊢ Eq (commProb (DihedralGroup.Product List.nil)) 1","decl":"lemma commProb_nil : commProb (Product []) = 1 := by\n  simp [Product, commProb_pi]\n\n"}
{"name":"DihedralGroup.commProb_cons","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"n : Nat\nl : List Nat\n⊢ Eq (commProb (DihedralGroup.Product (List.cons n l))) (HMul.hMul (commProb (DihedralGroup n)) (commProb (DihedralGroup.Product l)))","decl":"lemma commProb_cons (n : ℕ) (l : List ℕ) :\n    commProb (Product (n :: l)) = commProb (DihedralGroup n) * commProb (Product l) := by\n  simp [Product, commProb_pi, Fin.prod_univ_succ]\n\n"}
{"name":"DihedralGroup.commProb_reciprocal","module":"Mathlib.GroupTheory.CommutingProbability","initialProofState":"n : Nat\n⊢ Eq (commProb (DihedralGroup.Product (DihedralGroup.reciprocalFactors n))) (HDiv.hDiv 1 ↑n)","decl":"/-- Construction of a group with commuting probability `1 / n`. -/\ntheorem commProb_reciprocal (n : ℕ) :\n    commProb (Product (reciprocalFactors n)) = 1 / n := by\n  by_cases h0 : n = 0\n  · rw [h0, reciprocalFactors_zero, commProb_cons, commProb_nil, mul_one, Nat.cast_zero, div_zero]\n    apply commProb_eq_zero_of_infinite\n  by_cases h1 : n = 1\n  · rw [h1, reciprocalFactors_one, commProb_nil, Nat.cast_one, div_one]\n  rcases Nat.even_or_odd n with h2 | h2\n  · have := div_two_lt h0\n    rw [reciprocalFactors_even h0 h2, commProb_cons, commProb_reciprocal (n / 2),\n        commProb_odd (by decide)]\n    field_simp [h0, h2.two_dvd]\n    norm_num\n  · have := div_four_lt h0 h1\n    rw [reciprocalFactors_odd h1 h2, commProb_cons, commProb_reciprocal (n / 4 + 1)]\n    have key : n % 4 = 1 ∨ n % 4 = 3 := Nat.odd_mod_four_iff.mp (Nat.odd_iff.mp h2)\n    have hn : Odd (n % 4) := by rcases key with h | h <;> rw [h] <;> decide\n    rw [commProb_odd (hn.mul h2), div_mul_div_comm, mul_one, div_eq_div_iff, one_mul] <;> norm_cast\n    · have h0 : (n % 4) ^ 2 + 3 = n % 4 * 4 := by rcases key with h | h <;> rw [h] <;> norm_num\n      have h1 := (Nat.div_add_mod n 4).symm\n      zify at h0 h1 ⊢\n      linear_combination (h0 + h1 * (n % 4)) * n\n    · have := hn.pos.ne'\n      positivity\n\n"}
