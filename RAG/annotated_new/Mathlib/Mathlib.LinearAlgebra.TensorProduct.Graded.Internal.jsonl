{"name":"GradedTensorProduct.of_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nâŠ¢ Eq ((GradedTensorProduct.of R ğ’œ â„¬) 1) 1","decl":"@[simp]\ntheorem of_one : of R ğ’œ â„¬ 1 = 1 := rfl\n\n"}
{"name":"GradedTensorProduct.of_symm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nâŠ¢ Eq ((GradedTensorProduct.of R ğ’œ â„¬).symm 1) 1","decl":"@[simp]\ntheorem of_symm_one : (of R ğ’œ â„¬).symm 1 = 1 := rfl\n\n"}
{"name":"GradedTensorProduct.of_symm_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nx : TensorProduct R A B\nâŠ¢ Eq ((GradedTensorProduct.of R ğ’œ â„¬).symm ((GradedTensorProduct.of R ğ’œ â„¬) x)) x","decl":"@[simp]\ntheorem of_symm_of (x : A âŠ—[R] B) : (of R ğ’œ â„¬).symm (of R ğ’œ â„¬ x) = x := rfl\n\n"}
{"name":"GradedTensorProduct.symm_of_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nx : GradedTensorProduct R ğ’œ â„¬\nâŠ¢ Eq ((GradedTensorProduct.of R ğ’œ â„¬) ((GradedTensorProduct.of R ğ’œ â„¬).symm x)) x","decl":"@[simp]\ntheorem symm_of_of (x : ğ’œ áµâŠ—[R] â„¬) : of R ğ’œ â„¬ ((of R ğ’œ â„¬).symm x) = x := rfl\n\n"}
{"name":"GradedTensorProduct.hom_ext_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹â° : CommSemiring Î¹\ninstâœâ¹ : DecidableEq Î¹\ninstâœâ¸ : CommRing R\ninstâœâ· : Ring A\ninstâœâ¶ : Ring B\ninstâœâµ : Algebra R A\ninstâœâ´ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ³ : GradedAlgebra ğ’œ\ninstâœÂ² : GradedAlgebra â„¬\nM : Type u_5\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nf g : LinearMap (RingHom.id R) (GradedTensorProduct R ğ’œ â„¬) M\nâŠ¢ Iff (Eq f g) (Eq (f.comp â†‘(GradedTensorProduct.of R ğ’œ â„¬)) (g.comp â†‘(GradedTensorProduct.of R ğ’œ â„¬)))","decl":"/-- Two linear maps from the graded tensor product agree if they agree on the underlying tensor\nproduct. -/\n@[ext]\ntheorem hom_ext {M} [AddCommMonoid M] [Module R M] â¦ƒf g : ğ’œ áµâŠ—[R] â„¬ â†’â‚—[R] Mâ¦„\n    (h : f âˆ˜â‚— of R ğ’œ â„¬ = (g âˆ˜â‚— of R ğ’œ â„¬ : A âŠ—[R] B â†’â‚—[R] M)) :\n    f = g :=\n  h\n\n"}
{"name":"GradedTensorProduct.hom_ext","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹â° : CommSemiring Î¹\ninstâœâ¹ : DecidableEq Î¹\ninstâœâ¸ : CommRing R\ninstâœâ· : Ring A\ninstâœâ¶ : Ring B\ninstâœâµ : Algebra R A\ninstâœâ´ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ³ : GradedAlgebra ğ’œ\ninstâœÂ² : GradedAlgebra â„¬\nM : Type u_5\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : Module R M\nf g : LinearMap (RingHom.id R) (GradedTensorProduct R ğ’œ â„¬) M\nh : Eq (f.comp â†‘(GradedTensorProduct.of R ğ’œ â„¬)) (g.comp â†‘(GradedTensorProduct.of R ğ’œ â„¬))\nâŠ¢ Eq f g","decl":"/-- Two linear maps from the graded tensor product agree if they agree on the underlying tensor\nproduct. -/\n@[ext]\ntheorem hom_ext {M} [AddCommMonoid M] [Module R M] â¦ƒf g : ğ’œ áµâŠ—[R] â„¬ â†’â‚—[R] Mâ¦„\n    (h : f âˆ˜â‚— of R ğ’œ â„¬ = (g âˆ˜â‚— of R ğ’œ â„¬ : A âŠ—[R] B â†’â‚—[R] M)) :\n    f = g :=\n  h\n\n"}
{"name":"GradedTensorProduct.auxEquiv_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\na : A\nb : B\nâŠ¢ Eq ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) (GradedTensorProduct.tmul R a b)) (TensorProduct.tmul R ((DirectSum.decompose ğ’œ) a) ((DirectSum.decompose â„¬) b))","decl":"theorem auxEquiv_tmul (a : A) (b : B) :\n    auxEquiv R ğ’œ â„¬ (a áµâŠ—â‚œ b) = decompose ğ’œ a âŠ—â‚œ decompose â„¬ b := rfl\n\n"}
{"name":"GradedTensorProduct.auxEquiv_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nâŠ¢ Eq ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) 1) 1","decl":"theorem auxEquiv_one : auxEquiv R ğ’œ â„¬ 1 = 1 := by\n  rw [â† of_one, Algebra.TensorProduct.one_def, auxEquiv_tmul ğ’œ â„¬, DirectSum.decompose_one,\n    DirectSum.decompose_one, Algebra.TensorProduct.one_def]\n\n"}
{"name":"GradedTensorProduct.auxEquiv_symm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¸ : CommSemiring Î¹\ninstâœâ· : DecidableEq Î¹\ninstâœâ¶ : CommRing R\ninstâœâµ : Ring A\ninstâœâ´ : Ring B\ninstâœÂ³ : Algebra R A\ninstâœÂ² : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ¹ : GradedAlgebra ğ’œ\ninstâœ : GradedAlgebra â„¬\nâŠ¢ Eq ((GradedTensorProduct.auxEquiv R ğ’œ â„¬).symm 1) 1","decl":"theorem auxEquiv_symm_one : (auxEquiv R ğ’œ â„¬).symm 1 = 1 :=\n  (LinearEquiv.symm_apply_eq _).mpr (auxEquiv_one _ _).symm\n\n"}
{"name":"GradedTensorProduct.mulHom_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nx y : GradedTensorProduct R ğ’œ â„¬\nâŠ¢ Eq (((GradedTensorProduct.mulHom ğ’œ â„¬) x) y) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬).symm (((TensorProduct.gradedMul R (fun x => Subtype fun x_1 => Membership.mem (ğ’œ x) x_1) fun x => Subtype fun x_1 => Membership.mem (â„¬ x) x_1) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) x)) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) y)))","decl":"theorem mulHom_apply (x y : ğ’œ áµâŠ—[R] â„¬) :\n    mulHom ğ’œ â„¬ x y\n      = (auxEquiv R ğ’œ â„¬).symm (gradedMul R (ğ’œ Â·) (â„¬ Â·) (auxEquiv R ğ’œ â„¬ x) (auxEquiv R ğ’œ â„¬ y)) :=\n  rfl\n\n"}
{"name":"GradedTensorProduct.mul_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nx y : GradedTensorProduct R ğ’œ â„¬\nâŠ¢ Eq (HMul.hMul x y) (((GradedTensorProduct.mulHom ğ’œ â„¬) x) y)","decl":"theorem mul_def (x y : ğ’œ áµâŠ—[R] â„¬) : x * y = mulHom ğ’œ â„¬ x y := rfl\n\n-- Before https://github.com/leanprover-community/mathlib4/pull/8386 this was `@[simp]` but it times out when we try to apply it.\n"}
{"name":"GradedTensorProduct.auxEquiv_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nx y : GradedTensorProduct R ğ’œ â„¬\nâŠ¢ Eq ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) (HMul.hMul x y)) (((TensorProduct.gradedMul R (fun x => Subtype fun x_1 => Membership.mem (ğ’œ x) x_1) fun x => Subtype fun x_1 => Membership.mem (â„¬ x) x_1) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) x)) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) y))","decl":"theorem auxEquiv_mul (x y : ğ’œ áµâŠ—[R] â„¬) :\n    auxEquiv R ğ’œ â„¬ (x * y) = gradedMul R (ğ’œ Â·) (â„¬ Â·) (auxEquiv R ğ’œ â„¬ x) (auxEquiv R ğ’œ â„¬ y) :=\n  LinearEquiv.eq_symm_apply _ |>.mp rfl\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\njâ‚ iâ‚‚ : Î¹\naâ‚ : A\nbâ‚ : Subtype fun x => Membership.mem (â„¬ jâ‚) x\naâ‚‚ : Subtype fun x => Membership.mem (ğ’œ iâ‚‚) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ â†‘bâ‚) (GradedTensorProduct.tmul R (â†‘aâ‚‚) bâ‚‚)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul jâ‚ iâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ â†‘aâ‚‚) (HMul.hMul (â†‘bâ‚) bâ‚‚)))","decl":"/-- The characterization of this multiplication on partially homogeneous elements. -/\ntheorem tmul_coe_mul_coe_tmul {jâ‚ iâ‚‚ : Î¹} (aâ‚ : A) (bâ‚ : â„¬ jâ‚) (aâ‚‚ : ğ’œ iâ‚‚) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (bâ‚ : B) * (aâ‚‚ : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) =\n      (-1 : â„¤Ë£)^(jâ‚ * iâ‚‚) â€¢ ((aâ‚ * aâ‚‚ : A) áµâŠ—â‚œ (bâ‚ * bâ‚‚ : B)) := by\n  dsimp only [mul_def, mulHom_apply, of_symm_of]\n  dsimp [auxEquiv, tmul]\n  rw [decompose_coe, decompose_coe]\n  simp_rw [â† lof_eq_of R]\n  rw [tmul_of_gradedMul_of_tmul]\n  simp_rw [lof_eq_of R]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to `LinearEquiv.map_smul`\n  rw [@Units.smul_def _ _ (_) (_), â† Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, map_smul,\n    Int.cast_smul_eq_zsmul R, â† @Units.smul_def _ _ (_) (_)]\n  rw [congr_symm_tmul]\n  dsimp\n  simp_rw [decompose_symm_mul, decompose_symm_of, Equiv.symm_apply_apply]\n\n"}
{"name":"GradedTensorProduct.tmul_zero_coe_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\niâ‚‚ : Î¹\naâ‚ : A\nbâ‚ : Subtype fun x => Membership.mem (â„¬ 0) x\naâ‚‚ : Subtype fun x => Membership.mem (ğ’œ iâ‚‚) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ â†‘bâ‚) (GradedTensorProduct.tmul R (â†‘aâ‚‚) bâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ â†‘aâ‚‚) (HMul.hMul (â†‘bâ‚) bâ‚‚))","decl":"/-- A special case for when `bâ‚` has grade 0. -/\ntheorem tmul_zero_coe_mul_coe_tmul {iâ‚‚ : Î¹} (aâ‚ : A) (bâ‚ : â„¬ 0) (aâ‚‚ : ğ’œ iâ‚‚) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (bâ‚ : B) * (aâ‚‚ : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) =\n      ((aâ‚ * aâ‚‚ : A) áµâŠ—â‚œ (bâ‚ * bâ‚‚ : B)) := by\n  rw [tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul]\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_zero_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\njâ‚ : Î¹\naâ‚ : A\nbâ‚ : Subtype fun x => Membership.mem (â„¬ jâ‚) x\naâ‚‚ : Subtype fun x => Membership.mem (ğ’œ 0) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ â†‘bâ‚) (GradedTensorProduct.tmul R (â†‘aâ‚‚) bâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ â†‘aâ‚‚) (HMul.hMul (â†‘bâ‚) bâ‚‚))","decl":"/-- A special case for when `aâ‚‚` has grade 0. -/\ntheorem tmul_coe_mul_zero_coe_tmul {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â„¬ jâ‚) (aâ‚‚ : ğ’œ 0) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (bâ‚ : B) * (aâ‚‚ : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) =\n      ((aâ‚ * aâ‚‚ : A) áµâŠ—â‚œ (bâ‚ * bâ‚‚ : B)) := by\n  rw [tmul_coe_mul_coe_tmul, mul_zero, uzpow_zero, one_smul]\n\n"}
{"name":"GradedTensorProduct.tmul_one_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\niâ‚‚ : Î¹\naâ‚ : A\naâ‚‚ : Subtype fun x => Membership.mem (ğ’œ iâ‚‚) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ 1) (GradedTensorProduct.tmul R (â†‘aâ‚‚) bâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ â†‘aâ‚‚) bâ‚‚)","decl":"theorem tmul_one_mul_coe_tmul {iâ‚‚ : Î¹} (aâ‚ : A) (aâ‚‚ : ğ’œ iâ‚‚) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (1 : B) * (aâ‚‚ : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) = (aâ‚ * aâ‚‚ : A) áµâŠ—â‚œ (bâ‚‚ : B) := by\n  convert tmul_zero_coe_mul_coe_tmul ğ’œ â„¬ aâ‚ (@GradedMonoid.GOne.one _ (â„¬ Â·) _ _) aâ‚‚ bâ‚‚\n  rw [SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\njâ‚ : Î¹\naâ‚ : A\nbâ‚ : Subtype fun x => Membership.mem (â„¬ jâ‚) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ â†‘bâ‚) (GradedTensorProduct.tmul R 1 bâ‚‚)) (GradedTensorProduct.tmul R aâ‚ (HMul.hMul (â†‘bâ‚) bâ‚‚))","decl":"theorem tmul_coe_mul_one_tmul {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â„¬ jâ‚) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (bâ‚ : B) * (1 : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) = (aâ‚ : A) áµâŠ—â‚œ (bâ‚ * bâ‚‚ : B) := by\n  convert tmul_coe_mul_zero_coe_tmul ğ’œ â„¬ aâ‚ bâ‚ (@GradedMonoid.GOne.one _ (ğ’œ Â·) _ _) bâ‚‚\n  rw [SetLike.coe_gOne, mul_one]\n\n"}
{"name":"GradedTensorProduct.tmul_one_mul_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\naâ‚ : A\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ 1) (GradedTensorProduct.tmul R 1 bâ‚‚)) (GradedTensorProduct.tmul R aâ‚ bâ‚‚)","decl":"theorem tmul_one_mul_one_tmul (aâ‚ : A) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (1 : B) * (1 : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬) = (aâ‚ : A) áµâŠ—â‚œ (bâ‚‚ : B) := by\n  convert tmul_coe_mul_zero_coe_tmul ğ’œ â„¬\n    aâ‚ (GradedMonoid.GOne.one (A := (â„¬ Â·))) (GradedMonoid.GOne.one (A := (ğ’œ Â·))) bâ‚‚\n  Â· rw [SetLike.coe_gOne, mul_one]\n  Â· rw [SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.includeLeftRingHom_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\na : A\nâŠ¢ Eq ((GradedTensorProduct.includeLeftRingHom ğ’œ â„¬) a) (GradedTensorProduct.tmul R a 1)","decl":"/-- The ring morphism `A â†’+* A âŠ—[R] B` sending `a` to `a âŠ—â‚œ 1`. -/\n@[simps]\ndef includeLeftRingHom : A â†’+* ğ’œ áµâŠ—[R] â„¬ where\n  toFun a := a áµâŠ—â‚œ 1\n  map_zero' := by simp\n  map_add' := by simp [tmul, TensorProduct.add_tmul]\n  map_one' := rfl\n  map_mul' aâ‚ aâ‚‚ := by\n    dsimp\n    classical\n    rw [â† DirectSum.sum_support_decompose ğ’œ aâ‚‚, Finset.mul_sum]\n    simp_rw [tmul, sum_tmul, map_sum, Finset.mul_sum]\n    congr\n    ext i\n    rw [â† SetLike.coe_gOne â„¬, tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul,\n      SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.algebraMap_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nr : R\nâŠ¢ Eq ((algebraMap R (GradedTensorProduct R ğ’œ â„¬)) r) (GradedTensorProduct.tmul R ((algebraMap R A) r) 1)","decl":"lemma algebraMap_def (r : R) : algebraMap R (ğ’œ áµâŠ—[R] â„¬) r = algebraMap R A r áµâŠ—â‚œ[R] 1 := rfl\n\n"}
{"name":"GradedTensorProduct.tmul_algebraMap_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\niâ‚‚ : Î¹\naâ‚ : A\nr : R\naâ‚‚ : Subtype fun x => Membership.mem (ğ’œ iâ‚‚) x\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ ((algebraMap R B) r)) (GradedTensorProduct.tmul R (â†‘aâ‚‚) bâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ â†‘aâ‚‚) (HMul.hMul ((algebraMap R B) r) bâ‚‚))","decl":"theorem tmul_algebraMap_mul_coe_tmul {iâ‚‚ : Î¹} (aâ‚ : A) (r : R) (aâ‚‚ : ğ’œ iâ‚‚) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] algebraMap R B r * (aâ‚‚ : A) áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬)\n      = (aâ‚ * aâ‚‚ : A) áµâŠ—â‚œ (algebraMap R B r * bâ‚‚ : B) :=\n  tmul_zero_coe_mul_coe_tmul ğ’œ â„¬ aâ‚ (GAlgebra.toFun (A := (â„¬ Â·)) r) aâ‚‚ bâ‚‚\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_algebraMap_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\njâ‚ : Î¹\naâ‚ : A\nbâ‚ : Subtype fun x => Membership.mem (â„¬ jâ‚) x\nr : R\nbâ‚‚ : B\nâŠ¢ Eq (HMul.hMul (GradedTensorProduct.tmul R aâ‚ â†‘bâ‚) (GradedTensorProduct.tmul R ((algebraMap R A) r) bâ‚‚)) (GradedTensorProduct.tmul R (HMul.hMul aâ‚ ((algebraMap R A) r)) (HMul.hMul (â†‘bâ‚) bâ‚‚))","decl":"theorem tmul_coe_mul_algebraMap_tmul {jâ‚ : Î¹} (aâ‚ : A) (bâ‚ : â„¬ jâ‚) (r : R) (bâ‚‚ : B) :\n    (aâ‚ áµâŠ—â‚œ[R] (bâ‚ : B) * algebraMap R A r áµâŠ—â‚œ[R] bâ‚‚ : ğ’œ áµâŠ—[R] â„¬)\n      = (aâ‚ * algebraMap R A r : A) áµâŠ—â‚œ (bâ‚ * bâ‚‚ : B) :=\n  tmul_coe_mul_zero_coe_tmul ğ’œ â„¬ aâ‚ bâ‚ (GAlgebra.toFun (A := (ğ’œ Â·)) r) bâ‚‚\n\n"}
{"name":"GradedTensorProduct.includeLeft_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\na : A\nâŠ¢ Eq ((GradedTensorProduct.includeLeft ğ’œ â„¬) a) (GradedTensorProduct.tmul R a 1)","decl":"/-- The algebra morphism `A â†’â‚[R] A âŠ—[R] B` sending `a` to `a âŠ—â‚œ 1`. -/\n@[simps!]\ndef includeLeft : A â†’â‚[R] ğ’œ áµâŠ—[R] â„¬ where\n  toRingHom := includeLeftRingHom ğ’œ â„¬\n  commutes' _ := rfl\n\n"}
{"name":"GradedTensorProduct.includeRight_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\na : B\nâŠ¢ Eq ((GradedTensorProduct.includeRight ğ’œ â„¬) a) (GradedTensorProduct.tmul R 1 a)","decl":"/-- The algebra morphism `B â†’â‚[R] A âŠ—[R] B` sending `b` to `1 âŠ—â‚œ b`. -/\n@[simps!]\ndef includeRight : B â†’â‚[R] (ğ’œ áµâŠ—[R] â„¬) :=\n  AlgHom.ofLinearMap (R := R) (A := B) (B := ğ’œ áµâŠ—[R] â„¬)\n    (f := {\n       toFun := fun b => 1 áµâŠ—â‚œ b\n       map_add' := by simp [tmul, TensorProduct.tmul_add]\n       map_smul' := by simp [tmul, TensorProduct.tmul_smul] })\n    (map_one := rfl)\n    (map_mul := by\n      rw [LinearMap.map_mul_iff]\n      refine DirectSum.decompose_lhom_ext â„¬ fun iâ‚ => ?_\n      ext bâ‚ bâ‚‚ : 2\n      dsimp\n      rw [tmul_coe_mul_one_tmul])\n\n"}
{"name":"GradedTensorProduct.algebraMap_def'","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nr : R\nâŠ¢ Eq ((algebraMap R (GradedTensorProduct R ğ’œ â„¬)) r) (GradedTensorProduct.tmul R 1 ((algebraMap R B) r))","decl":"lemma algebraMap_def' (r : R) : algebraMap R (ğ’œ áµâŠ—[R] â„¬) r = 1 áµâŠ—â‚œ[R] algebraMap R B r :=\n  (includeRight ğ’œ â„¬).commutes r |>.symm\n\n"}
{"name":"GradedTensorProduct.lift_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : DecidableEq Î¹\ninstâœâ¹ : CommRing R\ninstâœâ¸ : Ring A\ninstâœâ· : Ring B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœâ´ : GradedAlgebra ğ’œ\ninstâœÂ³ : GradedAlgebra â„¬\ninstâœÂ² : Module Î¹ (Additive (Units Int))\nC : Type u_5\ninstâœÂ¹ : Ring C\ninstâœ : Algebra R C\nf : AlgHom R A C\ng : AlgHom R B C\nh_anti_commutes : âˆ€ â¦ƒi j : Î¹â¦„ (a : Subtype fun x => Membership.mem (ğ’œ i) x) (b : Subtype fun x => Membership.mem (â„¬ j) x), Eq (HMul.hMul (f â†‘a) (g â†‘b)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (HMul.hMul (g â†‘b) (f â†‘a)))\na : A\nb : B\nâŠ¢ Eq ((GradedTensorProduct.lift ğ’œ â„¬ f g h_anti_commutes) (GradedTensorProduct.tmul R a b)) (HMul.hMul (f a) (g b))","decl":"@[simp]\ntheorem lift_tmul (f : A â†’â‚[R] C) (g : B â†’â‚[R] C)\n    (h_anti_commutes : âˆ€ â¦ƒi jâ¦„ (a : ğ’œ i) (b : â„¬ j), f a * g b = (-1 : â„¤Ë£)^(j * i) â€¢ (g b * f a))\n    (a : A) (b : B) :\n    lift ğ’œ â„¬ f g h_anti_commutes (a áµâŠ—â‚œ b) = f a * g b :=\n  rfl\n\n"}
{"name":"GradedTensorProduct.algHom_ext_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : DecidableEq Î¹\ninstâœâ¹ : CommRing R\ninstâœâ¸ : Ring A\ninstâœâ· : Ring B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœâ´ : GradedAlgebra ğ’œ\ninstâœÂ³ : GradedAlgebra â„¬\ninstâœÂ² : Module Î¹ (Additive (Units Int))\nC : Type u_5\ninstâœÂ¹ : Ring C\ninstâœ : Algebra R C\nf g : AlgHom R (GradedTensorProduct R ğ’œ â„¬) C\nâŠ¢ Iff (Eq f g) (And (Eq (f.comp (GradedTensorProduct.includeLeft ğ’œ â„¬)) (g.comp (GradedTensorProduct.includeLeft ğ’œ â„¬))) (Eq (f.comp (GradedTensorProduct.includeRight ğ’œ â„¬)) (g.comp (GradedTensorProduct.includeRight ğ’œ â„¬))))","decl":"/-- Two algebra morphism from the graded tensor product agree if their compositions with the left\nand right inclusions agree. -/\n@[ext]\nlemma algHom_ext â¦ƒf g : (ğ’œ áµâŠ—[R] â„¬) â†’â‚[R] Câ¦„\n    (ha : f.comp (includeLeft ğ’œ â„¬) = g.comp (includeLeft ğ’œ â„¬))\n    (hb : f.comp (includeRight ğ’œ â„¬) = g.comp (includeRight ğ’œ â„¬)) : f = g :=\n  (liftEquiv ğ’œ â„¬).symm.injective <| Subtype.ext <| Prod.ext ha hb\n\n"}
{"name":"GradedTensorProduct.algHom_ext","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœÂ¹Â¹ : CommSemiring Î¹\ninstâœÂ¹â° : DecidableEq Î¹\ninstâœâ¹ : CommRing R\ninstâœâ¸ : Ring A\ninstâœâ· : Ring B\ninstâœâ¶ : Algebra R A\ninstâœâµ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœâ´ : GradedAlgebra ğ’œ\ninstâœÂ³ : GradedAlgebra â„¬\ninstâœÂ² : Module Î¹ (Additive (Units Int))\nC : Type u_5\ninstâœÂ¹ : Ring C\ninstâœ : Algebra R C\nf g : AlgHom R (GradedTensorProduct R ğ’œ â„¬) C\nha : Eq (f.comp (GradedTensorProduct.includeLeft ğ’œ â„¬)) (g.comp (GradedTensorProduct.includeLeft ğ’œ â„¬))\nhb : Eq (f.comp (GradedTensorProduct.includeRight ğ’œ â„¬)) (g.comp (GradedTensorProduct.includeRight ğ’œ â„¬))\nâŠ¢ Eq f g","decl":"/-- Two algebra morphism from the graded tensor product agree if their compositions with the left\nand right inclusions agree. -/\n@[ext]\nlemma algHom_ext â¦ƒf g : (ğ’œ áµâŠ—[R] â„¬) â†’â‚[R] Câ¦„\n    (ha : f.comp (includeLeft ğ’œ â„¬) = g.comp (includeLeft ğ’œ â„¬))\n    (hb : f.comp (includeRight ğ’œ â„¬) = g.comp (includeRight ğ’œ â„¬)) : f = g :=\n  (liftEquiv ğ’œ â„¬).symm.injective <| Subtype.ext <| Prod.ext ha hb\n\n"}
{"name":"GradedTensorProduct.auxEquiv_comm","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\nx : GradedTensorProduct R ğ’œ â„¬\nâŠ¢ Eq ((GradedTensorProduct.auxEquiv R â„¬ ğ’œ) ((GradedTensorProduct.comm ğ’œ â„¬) x)) ((TensorProduct.gradedComm R (fun x => Subtype fun x_1 => Membership.mem (ğ’œ x) x_1) fun x => Subtype fun x_1 => Membership.mem (â„¬ x) x_1) ((GradedTensorProduct.auxEquiv R ğ’œ â„¬) x))","decl":"lemma auxEquiv_comm (x : ğ’œ áµâŠ—[R] â„¬) :\n    auxEquiv R â„¬ ğ’œ (comm ğ’œ â„¬ x) = gradedComm R (ğ’œ Â·) (â„¬ Â·) (auxEquiv R ğ’œ â„¬ x) :=\n  LinearEquiv.eq_symm_apply _ |>.mp rfl\n\n"}
{"name":"GradedTensorProduct.comm_coe_tmul_coe","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nÎ¹ : Type u_2\nA : Type u_3\nB : Type u_4\ninstâœâ¹ : CommSemiring Î¹\ninstâœâ¸ : DecidableEq Î¹\ninstâœâ· : CommRing R\ninstâœâ¶ : Ring A\ninstâœâµ : Ring B\ninstâœâ´ : Algebra R A\ninstâœÂ³ : Algebra R B\nğ’œ : Î¹ â†’ Submodule R A\nâ„¬ : Î¹ â†’ Submodule R B\ninstâœÂ² : GradedAlgebra ğ’œ\ninstâœÂ¹ : GradedAlgebra â„¬\ninstâœ : Module Î¹ (Additive (Units Int))\ni j : Î¹\na : Subtype fun x => Membership.mem (ğ’œ i) x\nb : Subtype fun x => Membership.mem (â„¬ j) x\nâŠ¢ Eq ((GradedTensorProduct.comm ğ’œ â„¬) (GradedTensorProduct.tmul R â†‘a â†‘b)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (GradedTensorProduct.tmul R â†‘b â†‘a))","decl":"@[simp] lemma comm_coe_tmul_coe {i j : Î¹} (a : ğ’œ i) (b : â„¬ j) :\n    comm ğ’œ â„¬ (a áµâŠ—â‚œ b) = (-1 : â„¤Ë£)^(j * i) â€¢ (b áµâŠ—â‚œ a : â„¬ áµâŠ—[R] ğ’œ) :=\n  (auxEquiv R â„¬ ğ’œ).injective <| by\n    simp_rw [auxEquiv_comm, auxEquiv_tmul, decompose_coe, â† lof_eq_of R, gradedComm_of_tmul_of,\n      @Units.smul_def _ _ (_) (_), â† Int.cast_smul_eq_zsmul R]\n    -- Qualified `map_smul` to avoid a TC timeout https://github.com/leanprover-community/mathlib4/pull/8386\n    erw [LinearMap.map_smul, auxEquiv_tmul]\n    simp_rw [decompose_coe, lof_eq_of]\n\n"}
