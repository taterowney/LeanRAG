{"name":"GradedTensorProduct.of_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\n⊢ Eq ((GradedTensorProduct.of R 𝒜 ℬ) 1) 1","decl":"@[simp]\ntheorem of_one : of R 𝒜 ℬ 1 = 1 := rfl\n\n"}
{"name":"GradedTensorProduct.of_symm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\n⊢ Eq ((GradedTensorProduct.of R 𝒜 ℬ).symm 1) 1","decl":"@[simp]\ntheorem of_symm_one : (of R 𝒜 ℬ).symm 1 = 1 := rfl\n\n"}
{"name":"GradedTensorProduct.of_symm_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\nx : TensorProduct R A B\n⊢ Eq ((GradedTensorProduct.of R 𝒜 ℬ).symm ((GradedTensorProduct.of R 𝒜 ℬ) x)) x","decl":"@[simp]\ntheorem of_symm_of (x : A ⊗[R] B) : (of R 𝒜 ℬ).symm (of R 𝒜 ℬ x) = x := rfl\n\n"}
{"name":"GradedTensorProduct.symm_of_of","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\nx : GradedTensorProduct R 𝒜 ℬ\n⊢ Eq ((GradedTensorProduct.of R 𝒜 ℬ) ((GradedTensorProduct.of R 𝒜 ℬ).symm x)) x","decl":"@[simp]\ntheorem symm_of_of (x : 𝒜 ᵍ⊗[R] ℬ) : of R 𝒜 ℬ ((of R 𝒜 ℬ).symm x) = x := rfl\n\n"}
{"name":"GradedTensorProduct.hom_ext_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : CommSemiring ι\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : CommRing R\ninst✝⁷ : Ring A\ninst✝⁶ : Ring B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝³ : GradedAlgebra 𝒜\ninst✝² : GradedAlgebra ℬ\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (GradedTensorProduct R 𝒜 ℬ) M\n⊢ Iff (Eq f g) (Eq (f.comp ↑(GradedTensorProduct.of R 𝒜 ℬ)) (g.comp ↑(GradedTensorProduct.of R 𝒜 ℬ)))","decl":"/-- Two linear maps from the graded tensor product agree if they agree on the underlying tensor\nproduct. -/\n@[ext]\ntheorem hom_ext {M} [AddCommMonoid M] [Module R M] ⦃f g : 𝒜 ᵍ⊗[R] ℬ →ₗ[R] M⦄\n    (h : f ∘ₗ of R 𝒜 ℬ = (g ∘ₗ of R 𝒜 ℬ : A ⊗[R] B →ₗ[R] M)) :\n    f = g :=\n  h\n\n"}
{"name":"GradedTensorProduct.hom_ext","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : CommSemiring ι\ninst✝⁹ : DecidableEq ι\ninst✝⁸ : CommRing R\ninst✝⁷ : Ring A\ninst✝⁶ : Ring B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝³ : GradedAlgebra 𝒜\ninst✝² : GradedAlgebra ℬ\nM : Type u_5\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : LinearMap (RingHom.id R) (GradedTensorProduct R 𝒜 ℬ) M\nh : Eq (f.comp ↑(GradedTensorProduct.of R 𝒜 ℬ)) (g.comp ↑(GradedTensorProduct.of R 𝒜 ℬ))\n⊢ Eq f g","decl":"/-- Two linear maps from the graded tensor product agree if they agree on the underlying tensor\nproduct. -/\n@[ext]\ntheorem hom_ext {M} [AddCommMonoid M] [Module R M] ⦃f g : 𝒜 ᵍ⊗[R] ℬ →ₗ[R] M⦄\n    (h : f ∘ₗ of R 𝒜 ℬ = (g ∘ₗ of R 𝒜 ℬ : A ⊗[R] B →ₗ[R] M)) :\n    f = g :=\n  h\n\n"}
{"name":"GradedTensorProduct.auxEquiv_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\na : A\nb : B\n⊢ Eq ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) (GradedTensorProduct.tmul R a b)) (TensorProduct.tmul R ((DirectSum.decompose 𝒜) a) ((DirectSum.decompose ℬ) b))","decl":"theorem auxEquiv_tmul (a : A) (b : B) :\n    auxEquiv R 𝒜 ℬ (a ᵍ⊗ₜ b) = decompose 𝒜 a ⊗ₜ decompose ℬ b := rfl\n\n"}
{"name":"GradedTensorProduct.auxEquiv_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\n⊢ Eq ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) 1) 1","decl":"theorem auxEquiv_one : auxEquiv R 𝒜 ℬ 1 = 1 := by\n  rw [← of_one, Algebra.TensorProduct.one_def, auxEquiv_tmul 𝒜 ℬ, DirectSum.decompose_one,\n    DirectSum.decompose_one, Algebra.TensorProduct.one_def]\n\n"}
{"name":"GradedTensorProduct.auxEquiv_symm_one","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁸ : CommSemiring ι\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Ring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝¹ : GradedAlgebra 𝒜\ninst✝ : GradedAlgebra ℬ\n⊢ Eq ((GradedTensorProduct.auxEquiv R 𝒜 ℬ).symm 1) 1","decl":"theorem auxEquiv_symm_one : (auxEquiv R 𝒜 ℬ).symm 1 = 1 :=\n  (LinearEquiv.symm_apply_eq _).mpr (auxEquiv_one _ _).symm\n\n"}
{"name":"GradedTensorProduct.mulHom_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nx y : GradedTensorProduct R 𝒜 ℬ\n⊢ Eq (((GradedTensorProduct.mulHom 𝒜 ℬ) x) y) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ).symm (((TensorProduct.gradedMul R (fun x => Subtype fun x_1 => Membership.mem (𝒜 x) x_1) fun x => Subtype fun x_1 => Membership.mem (ℬ x) x_1) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) x)) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) y)))","decl":"theorem mulHom_apply (x y : 𝒜 ᵍ⊗[R] ℬ) :\n    mulHom 𝒜 ℬ x y\n      = (auxEquiv R 𝒜 ℬ).symm (gradedMul R (𝒜 ·) (ℬ ·) (auxEquiv R 𝒜 ℬ x) (auxEquiv R 𝒜 ℬ y)) :=\n  rfl\n\n"}
{"name":"GradedTensorProduct.mul_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nx y : GradedTensorProduct R 𝒜 ℬ\n⊢ Eq (HMul.hMul x y) (((GradedTensorProduct.mulHom 𝒜 ℬ) x) y)","decl":"theorem mul_def (x y : 𝒜 ᵍ⊗[R] ℬ) : x * y = mulHom 𝒜 ℬ x y := rfl\n\n-- Before https://github.com/leanprover-community/mathlib4/pull/8386 this was `@[simp]` but it times out when we try to apply it.\n"}
{"name":"GradedTensorProduct.auxEquiv_mul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nx y : GradedTensorProduct R 𝒜 ℬ\n⊢ Eq ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) (HMul.hMul x y)) (((TensorProduct.gradedMul R (fun x => Subtype fun x_1 => Membership.mem (𝒜 x) x_1) fun x => Subtype fun x_1 => Membership.mem (ℬ x) x_1) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) x)) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) y))","decl":"theorem auxEquiv_mul (x y : 𝒜 ᵍ⊗[R] ℬ) :\n    auxEquiv R 𝒜 ℬ (x * y) = gradedMul R (𝒜 ·) (ℬ ·) (auxEquiv R 𝒜 ℬ x) (auxEquiv R 𝒜 ℬ y) :=\n  LinearEquiv.eq_symm_apply _ |>.mp rfl\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nj₁ i₂ : ι\na₁ : A\nb₁ : Subtype fun x => Membership.mem (ℬ j₁) x\na₂ : Subtype fun x => Membership.mem (𝒜 i₂) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ↑b₁) (GradedTensorProduct.tmul R (↑a₂) b₂)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j₁ i₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ↑a₂) (HMul.hMul (↑b₁) b₂)))","decl":"/-- The characterization of this multiplication on partially homogeneous elements. -/\ntheorem tmul_coe_mul_coe_tmul {j₁ i₂ : ι} (a₁ : A) (b₁ : ℬ j₁) (a₂ : 𝒜 i₂) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (b₁ : B) * (a₂ : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) =\n      (-1 : ℤˣ)^(j₁ * i₂) • ((a₁ * a₂ : A) ᵍ⊗ₜ (b₁ * b₂ : B)) := by\n  dsimp only [mul_def, mulHom_apply, of_symm_of]\n  dsimp [auxEquiv, tmul]\n  rw [decompose_coe, decompose_coe]\n  simp_rw [← lof_eq_of R]\n  rw [tmul_of_gradedMul_of_tmul]\n  simp_rw [lof_eq_of R]\n  -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specialize `map_smul` to `LinearEquiv.map_smul`\n  rw [@Units.smul_def _ _ (_) (_), ← Int.cast_smul_eq_zsmul R, LinearEquiv.map_smul, map_smul,\n    Int.cast_smul_eq_zsmul R, ← @Units.smul_def _ _ (_) (_)]\n  rw [congr_symm_tmul]\n  dsimp\n  simp_rw [decompose_symm_mul, decompose_symm_of, Equiv.symm_apply_apply]\n\n"}
{"name":"GradedTensorProduct.tmul_zero_coe_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\ni₂ : ι\na₁ : A\nb₁ : Subtype fun x => Membership.mem (ℬ 0) x\na₂ : Subtype fun x => Membership.mem (𝒜 i₂) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ↑b₁) (GradedTensorProduct.tmul R (↑a₂) b₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ↑a₂) (HMul.hMul (↑b₁) b₂))","decl":"/-- A special case for when `b₁` has grade 0. -/\ntheorem tmul_zero_coe_mul_coe_tmul {i₂ : ι} (a₁ : A) (b₁ : ℬ 0) (a₂ : 𝒜 i₂) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (b₁ : B) * (a₂ : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) =\n      ((a₁ * a₂ : A) ᵍ⊗ₜ (b₁ * b₂ : B)) := by\n  rw [tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul]\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_zero_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nj₁ : ι\na₁ : A\nb₁ : Subtype fun x => Membership.mem (ℬ j₁) x\na₂ : Subtype fun x => Membership.mem (𝒜 0) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ↑b₁) (GradedTensorProduct.tmul R (↑a₂) b₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ↑a₂) (HMul.hMul (↑b₁) b₂))","decl":"/-- A special case for when `a₂` has grade 0. -/\ntheorem tmul_coe_mul_zero_coe_tmul {j₁ : ι} (a₁ : A) (b₁ : ℬ j₁) (a₂ : 𝒜 0) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (b₁ : B) * (a₂ : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) =\n      ((a₁ * a₂ : A) ᵍ⊗ₜ (b₁ * b₂ : B)) := by\n  rw [tmul_coe_mul_coe_tmul, mul_zero, uzpow_zero, one_smul]\n\n"}
{"name":"GradedTensorProduct.tmul_one_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\ni₂ : ι\na₁ : A\na₂ : Subtype fun x => Membership.mem (𝒜 i₂) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ 1) (GradedTensorProduct.tmul R (↑a₂) b₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ↑a₂) b₂)","decl":"theorem tmul_one_mul_coe_tmul {i₂ : ι} (a₁ : A) (a₂ : 𝒜 i₂) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (1 : B) * (a₂ : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) = (a₁ * a₂ : A) ᵍ⊗ₜ (b₂ : B) := by\n  convert tmul_zero_coe_mul_coe_tmul 𝒜 ℬ a₁ (@GradedMonoid.GOne.one _ (ℬ ·) _ _) a₂ b₂\n  rw [SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nj₁ : ι\na₁ : A\nb₁ : Subtype fun x => Membership.mem (ℬ j₁) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ↑b₁) (GradedTensorProduct.tmul R 1 b₂)) (GradedTensorProduct.tmul R a₁ (HMul.hMul (↑b₁) b₂))","decl":"theorem tmul_coe_mul_one_tmul {j₁ : ι} (a₁ : A) (b₁ : ℬ j₁) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (b₁ : B) * (1 : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) = (a₁ : A) ᵍ⊗ₜ (b₁ * b₂ : B) := by\n  convert tmul_coe_mul_zero_coe_tmul 𝒜 ℬ a₁ b₁ (@GradedMonoid.GOne.one _ (𝒜 ·) _ _) b₂\n  rw [SetLike.coe_gOne, mul_one]\n\n"}
{"name":"GradedTensorProduct.tmul_one_mul_one_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\na₁ : A\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ 1) (GradedTensorProduct.tmul R 1 b₂)) (GradedTensorProduct.tmul R a₁ b₂)","decl":"theorem tmul_one_mul_one_tmul (a₁ : A) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (1 : B) * (1 : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ) = (a₁ : A) ᵍ⊗ₜ (b₂ : B) := by\n  convert tmul_coe_mul_zero_coe_tmul 𝒜 ℬ\n    a₁ (GradedMonoid.GOne.one (A := (ℬ ·))) (GradedMonoid.GOne.one (A := (𝒜 ·))) b₂\n  · rw [SetLike.coe_gOne, mul_one]\n  · rw [SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.includeLeftRingHom_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\na : A\n⊢ Eq ((GradedTensorProduct.includeLeftRingHom 𝒜 ℬ) a) (GradedTensorProduct.tmul R a 1)","decl":"/-- The ring morphism `A →+* A ⊗[R] B` sending `a` to `a ⊗ₜ 1`. -/\n@[simps]\ndef includeLeftRingHom : A →+* 𝒜 ᵍ⊗[R] ℬ where\n  toFun a := a ᵍ⊗ₜ 1\n  map_zero' := by simp\n  map_add' := by simp [tmul, TensorProduct.add_tmul]\n  map_one' := rfl\n  map_mul' a₁ a₂ := by\n    dsimp\n    classical\n    rw [← DirectSum.sum_support_decompose 𝒜 a₂, Finset.mul_sum]\n    simp_rw [tmul, sum_tmul, map_sum, Finset.mul_sum]\n    congr\n    ext i\n    rw [← SetLike.coe_gOne ℬ, tmul_coe_mul_coe_tmul, zero_mul, uzpow_zero, one_smul,\n      SetLike.coe_gOne, one_mul]\n\n"}
{"name":"GradedTensorProduct.algebraMap_def","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nr : R\n⊢ Eq ((algebraMap R (GradedTensorProduct R 𝒜 ℬ)) r) (GradedTensorProduct.tmul R ((algebraMap R A) r) 1)","decl":"lemma algebraMap_def (r : R) : algebraMap R (𝒜 ᵍ⊗[R] ℬ) r = algebraMap R A r ᵍ⊗ₜ[R] 1 := rfl\n\n"}
{"name":"GradedTensorProduct.tmul_algebraMap_mul_coe_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\ni₂ : ι\na₁ : A\nr : R\na₂ : Subtype fun x => Membership.mem (𝒜 i₂) x\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ((algebraMap R B) r)) (GradedTensorProduct.tmul R (↑a₂) b₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ↑a₂) (HMul.hMul ((algebraMap R B) r) b₂))","decl":"theorem tmul_algebraMap_mul_coe_tmul {i₂ : ι} (a₁ : A) (r : R) (a₂ : 𝒜 i₂) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] algebraMap R B r * (a₂ : A) ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ)\n      = (a₁ * a₂ : A) ᵍ⊗ₜ (algebraMap R B r * b₂ : B) :=\n  tmul_zero_coe_mul_coe_tmul 𝒜 ℬ a₁ (GAlgebra.toFun (A := (ℬ ·)) r) a₂ b₂\n\n"}
{"name":"GradedTensorProduct.tmul_coe_mul_algebraMap_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nj₁ : ι\na₁ : A\nb₁ : Subtype fun x => Membership.mem (ℬ j₁) x\nr : R\nb₂ : B\n⊢ Eq (HMul.hMul (GradedTensorProduct.tmul R a₁ ↑b₁) (GradedTensorProduct.tmul R ((algebraMap R A) r) b₂)) (GradedTensorProduct.tmul R (HMul.hMul a₁ ((algebraMap R A) r)) (HMul.hMul (↑b₁) b₂))","decl":"theorem tmul_coe_mul_algebraMap_tmul {j₁ : ι} (a₁ : A) (b₁ : ℬ j₁) (r : R) (b₂ : B) :\n    (a₁ ᵍ⊗ₜ[R] (b₁ : B) * algebraMap R A r ᵍ⊗ₜ[R] b₂ : 𝒜 ᵍ⊗[R] ℬ)\n      = (a₁ * algebraMap R A r : A) ᵍ⊗ₜ (b₁ * b₂ : B) :=\n  tmul_coe_mul_zero_coe_tmul 𝒜 ℬ a₁ b₁ (GAlgebra.toFun (A := (𝒜 ·)) r) b₂\n\n"}
{"name":"GradedTensorProduct.includeLeft_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\na : A\n⊢ Eq ((GradedTensorProduct.includeLeft 𝒜 ℬ) a) (GradedTensorProduct.tmul R a 1)","decl":"/-- The algebra morphism `A →ₐ[R] A ⊗[R] B` sending `a` to `a ⊗ₜ 1`. -/\n@[simps!]\ndef includeLeft : A →ₐ[R] 𝒜 ᵍ⊗[R] ℬ where\n  toRingHom := includeLeftRingHom 𝒜 ℬ\n  commutes' _ := rfl\n\n"}
{"name":"GradedTensorProduct.includeRight_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\na : B\n⊢ Eq ((GradedTensorProduct.includeRight 𝒜 ℬ) a) (GradedTensorProduct.tmul R 1 a)","decl":"/-- The algebra morphism `B →ₐ[R] A ⊗[R] B` sending `b` to `1 ⊗ₜ b`. -/\n@[simps!]\ndef includeRight : B →ₐ[R] (𝒜 ᵍ⊗[R] ℬ) :=\n  AlgHom.ofLinearMap (R := R) (A := B) (B := 𝒜 ᵍ⊗[R] ℬ)\n    (f := {\n       toFun := fun b => 1 ᵍ⊗ₜ b\n       map_add' := by simp [tmul, TensorProduct.tmul_add]\n       map_smul' := by simp [tmul, TensorProduct.tmul_smul] })\n    (map_one := rfl)\n    (map_mul := by\n      rw [LinearMap.map_mul_iff]\n      refine DirectSum.decompose_lhom_ext ℬ fun i₁ => ?_\n      ext b₁ b₂ : 2\n      dsimp\n      rw [tmul_coe_mul_one_tmul])\n\n"}
{"name":"GradedTensorProduct.algebraMap_def'","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nr : R\n⊢ Eq ((algebraMap R (GradedTensorProduct R 𝒜 ℬ)) r) (GradedTensorProduct.tmul R 1 ((algebraMap R B) r))","decl":"lemma algebraMap_def' (r : R) : algebraMap R (𝒜 ᵍ⊗[R] ℬ) r = 1 ᵍ⊗ₜ[R] algebraMap R B r :=\n  (includeRight 𝒜 ℬ).commutes r |>.symm\n\n"}
{"name":"GradedTensorProduct.lift_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : CommRing R\ninst✝⁸ : Ring A\ninst✝⁷ : Ring B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝⁴ : GradedAlgebra 𝒜\ninst✝³ : GradedAlgebra ℬ\ninst✝² : Module ι (Additive (Units Int))\nC : Type u_5\ninst✝¹ : Ring C\ninst✝ : Algebra R C\nf : AlgHom R A C\ng : AlgHom R B C\nh_anti_commutes : ∀ ⦃i j : ι⦄ (a : Subtype fun x => Membership.mem (𝒜 i) x) (b : Subtype fun x => Membership.mem (ℬ j) x), Eq (HMul.hMul (f ↑a) (g ↑b)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (HMul.hMul (g ↑b) (f ↑a)))\na : A\nb : B\n⊢ Eq ((GradedTensorProduct.lift 𝒜 ℬ f g h_anti_commutes) (GradedTensorProduct.tmul R a b)) (HMul.hMul (f a) (g b))","decl":"@[simp]\ntheorem lift_tmul (f : A →ₐ[R] C) (g : B →ₐ[R] C)\n    (h_anti_commutes : ∀ ⦃i j⦄ (a : 𝒜 i) (b : ℬ j), f a * g b = (-1 : ℤˣ)^(j * i) • (g b * f a))\n    (a : A) (b : B) :\n    lift 𝒜 ℬ f g h_anti_commutes (a ᵍ⊗ₜ b) = f a * g b :=\n  rfl\n\n"}
{"name":"GradedTensorProduct.algHom_ext_iff","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : CommRing R\ninst✝⁸ : Ring A\ninst✝⁷ : Ring B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝⁴ : GradedAlgebra 𝒜\ninst✝³ : GradedAlgebra ℬ\ninst✝² : Module ι (Additive (Units Int))\nC : Type u_5\ninst✝¹ : Ring C\ninst✝ : Algebra R C\nf g : AlgHom R (GradedTensorProduct R 𝒜 ℬ) C\n⊢ Iff (Eq f g) (And (Eq (f.comp (GradedTensorProduct.includeLeft 𝒜 ℬ)) (g.comp (GradedTensorProduct.includeLeft 𝒜 ℬ))) (Eq (f.comp (GradedTensorProduct.includeRight 𝒜 ℬ)) (g.comp (GradedTensorProduct.includeRight 𝒜 ℬ))))","decl":"/-- Two algebra morphism from the graded tensor product agree if their compositions with the left\nand right inclusions agree. -/\n@[ext]\nlemma algHom_ext ⦃f g : (𝒜 ᵍ⊗[R] ℬ) →ₐ[R] C⦄\n    (ha : f.comp (includeLeft 𝒜 ℬ) = g.comp (includeLeft 𝒜 ℬ))\n    (hb : f.comp (includeRight 𝒜 ℬ) = g.comp (includeRight 𝒜 ℬ)) : f = g :=\n  (liftEquiv 𝒜 ℬ).symm.injective <| Subtype.ext <| Prod.ext ha hb\n\n"}
{"name":"GradedTensorProduct.algHom_ext","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommSemiring ι\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : CommRing R\ninst✝⁸ : Ring A\ninst✝⁷ : Ring B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝⁴ : GradedAlgebra 𝒜\ninst✝³ : GradedAlgebra ℬ\ninst✝² : Module ι (Additive (Units Int))\nC : Type u_5\ninst✝¹ : Ring C\ninst✝ : Algebra R C\nf g : AlgHom R (GradedTensorProduct R 𝒜 ℬ) C\nha : Eq (f.comp (GradedTensorProduct.includeLeft 𝒜 ℬ)) (g.comp (GradedTensorProduct.includeLeft 𝒜 ℬ))\nhb : Eq (f.comp (GradedTensorProduct.includeRight 𝒜 ℬ)) (g.comp (GradedTensorProduct.includeRight 𝒜 ℬ))\n⊢ Eq f g","decl":"/-- Two algebra morphism from the graded tensor product agree if their compositions with the left\nand right inclusions agree. -/\n@[ext]\nlemma algHom_ext ⦃f g : (𝒜 ᵍ⊗[R] ℬ) →ₐ[R] C⦄\n    (ha : f.comp (includeLeft 𝒜 ℬ) = g.comp (includeLeft 𝒜 ℬ))\n    (hb : f.comp (includeRight 𝒜 ℬ) = g.comp (includeRight 𝒜 ℬ)) : f = g :=\n  (liftEquiv 𝒜 ℬ).symm.injective <| Subtype.ext <| Prod.ext ha hb\n\n"}
{"name":"GradedTensorProduct.auxEquiv_comm","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\nx : GradedTensorProduct R 𝒜 ℬ\n⊢ Eq ((GradedTensorProduct.auxEquiv R ℬ 𝒜) ((GradedTensorProduct.comm 𝒜 ℬ) x)) ((TensorProduct.gradedComm R (fun x => Subtype fun x_1 => Membership.mem (𝒜 x) x_1) fun x => Subtype fun x_1 => Membership.mem (ℬ x) x_1) ((GradedTensorProduct.auxEquiv R 𝒜 ℬ) x))","decl":"lemma auxEquiv_comm (x : 𝒜 ᵍ⊗[R] ℬ) :\n    auxEquiv R ℬ 𝒜 (comm 𝒜 ℬ x) = gradedComm R (𝒜 ·) (ℬ ·) (auxEquiv R 𝒜 ℬ x) :=\n  LinearEquiv.eq_symm_apply _ |>.mp rfl\n\n"}
{"name":"GradedTensorProduct.comm_coe_tmul_coe","module":"Mathlib.LinearAlgebra.TensorProduct.Graded.Internal","initialProofState":"R : Type u_1\nι : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring ι\ninst✝⁸ : DecidableEq ι\ninst✝⁷ : CommRing R\ninst✝⁶ : Ring A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\n𝒜 : ι → Submodule R A\nℬ : ι → Submodule R B\ninst✝² : GradedAlgebra 𝒜\ninst✝¹ : GradedAlgebra ℬ\ninst✝ : Module ι (Additive (Units Int))\ni j : ι\na : Subtype fun x => Membership.mem (𝒜 i) x\nb : Subtype fun x => Membership.mem (ℬ j) x\n⊢ Eq ((GradedTensorProduct.comm 𝒜 ℬ) (GradedTensorProduct.tmul R ↑a ↑b)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul j i)) (GradedTensorProduct.tmul R ↑b ↑a))","decl":"@[simp] lemma comm_coe_tmul_coe {i j : ι} (a : 𝒜 i) (b : ℬ j) :\n    comm 𝒜 ℬ (a ᵍ⊗ₜ b) = (-1 : ℤˣ)^(j * i) • (b ᵍ⊗ₜ a : ℬ ᵍ⊗[R] 𝒜) :=\n  (auxEquiv R ℬ 𝒜).injective <| by\n    simp_rw [auxEquiv_comm, auxEquiv_tmul, decompose_coe, ← lof_eq_of R, gradedComm_of_tmul_of,\n      @Units.smul_def _ _ (_) (_), ← Int.cast_smul_eq_zsmul R]\n    -- Qualified `map_smul` to avoid a TC timeout https://github.com/leanprover-community/mathlib4/pull/8386\n    erw [LinearMap.map_smul, auxEquiv_tmul]\n    simp_rw [decompose_coe, lof_eq_of]\n\n"}
