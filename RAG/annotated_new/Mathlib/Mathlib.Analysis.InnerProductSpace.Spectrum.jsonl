{"name":"LinearMap.IsSymmetric.invariant_orthogonalComplement_eigenspace","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nÎ¼ : ğ•œ\nv : E\nhv : Membership.mem (Module.End.eigenspace T Î¼).orthogonal v\nâŠ¢ Membership.mem (Module.End.eigenspace T Î¼).orthogonal (T v)","decl":"/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem invariant_orthogonalComplement_eigenspace (hT : T.IsSymmetric) (Î¼ : ğ•œ)\n    (v : E) (hv : v âˆˆ (eigenspace T Î¼)á—®) : T v âˆˆ (eigenspace T Î¼)á—® := by\n  intro w hw\n  have : T w = (Î¼ : ğ•œ) â€¢ w := by rwa [mem_eigenspace_iff] at hw\n  simp [â† hT w, this, inner_smul_left, hv w hw]\n\n"}
{"name":"LinearMap.IsSymmetric.conj_eigenvalue_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nÎ¼ : ğ•œ\nhÎ¼ : Module.End.HasEigenvalue T Î¼\nâŠ¢ Eq ((starRingEnd ğ•œ) Î¼) Î¼","decl":"/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem conj_eigenvalue_eq_self (hT : T.IsSymmetric) {Î¼ : ğ•œ} (hÎ¼ : HasEigenvalue T Î¼) :\n    conj Î¼ = Î¼ := by\n  obtain âŸ¨v, hvâ‚, hvâ‚‚âŸ© := hÎ¼.exists_hasEigenvector\n  rw [mem_eigenspace_iff] at hvâ‚\n  simpa [hvâ‚‚, inner_smul_left, inner_smul_right, hvâ‚] using hT v v\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalFamily_eigenspaces","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ OrthogonalFamily ğ•œ (fun Î¼ => Subtype fun x => Membership.mem (Module.End.eigenspace T Î¼) x) fun Î¼ => (Module.End.eigenspace T Î¼).subtypeâ‚—áµ¢","decl":"/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem orthogonalFamily_eigenspaces (hT : T.IsSymmetric) :\n    OrthogonalFamily ğ•œ (fun Î¼ => eigenspace T Î¼) fun Î¼ => (eigenspace T Î¼).subtypeâ‚—áµ¢ := by\n  rintro Î¼ Î½ hÎ¼Î½ âŸ¨v, hvâŸ© âŸ¨w, hwâŸ©\n  by_cases hv' : v = 0\n  Â· simp [hv']\n  have H := hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector âŸ¨hv, hv'âŸ©)\n  rw [mem_eigenspace_iff] at hv hw\n  refine Or.resolve_left ?_ hÎ¼Î½.symm\n  simpa [inner_smul_left, inner_smul_right, hv, hw, H] using (hT v w).symm\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalFamily_eigenspaces'","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nâŠ¢ OrthogonalFamily ğ•œ (fun Î¼ => Subtype fun x => Membership.mem (Module.End.eigenspace T (â†‘T 1 Î¼)) x) fun Î¼ => (Module.End.eigenspace T (â†‘T 1 Î¼)).subtypeâ‚—áµ¢","decl":"theorem orthogonalFamily_eigenspaces' (hT : T.IsSymmetric) :\n    OrthogonalFamily ğ•œ (fun Î¼ : Eigenvalues T => eigenspace T Î¼) fun Î¼ =>\n      (eigenspace T Î¼).subtypeâ‚—áµ¢ :=\n  hT.orthogonalFamily_eigenspaces.comp Subtype.coe_injective\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_invariant","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nv : E\nhv : Membership.mem (iSup fun Î¼ => Module.End.eigenspace T Î¼).orthogonal v\nâŠ¢ Membership.mem (iSup fun Î¼ => Module.End.eigenspace T Î¼).orthogonal (T v)","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem orthogonalComplement_iSup_eigenspaces_invariant (hT : T.IsSymmetric)\n    â¦ƒv : Eâ¦„ (hv : v âˆˆ (â¨† Î¼, eigenspace T Î¼)á—®) : T v âˆˆ (â¨† Î¼, eigenspace T Î¼)á—® := by\n  rw [â† Submodule.iInf_orthogonal] at hv âŠ¢\n  exact T.iInf_invariant hT.invariant_orthogonalComplement_eigenspace v hv\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\nhT : T.IsSymmetric\nÎ¼ : ğ•œ\nâŠ¢ Eq (Module.End.eigenspace (T.restrict â‹¯) Î¼) Bot.bot","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem orthogonalComplement_iSup_eigenspaces (hT : T.IsSymmetric) (Î¼ : ğ•œ) :\n    eigenspace (T.restrict hT.orthogonalComplement_iSup_eigenspaces_invariant) Î¼ = âŠ¥ := by\n  set p : Submodule ğ•œ E := (â¨† Î¼, eigenspace T Î¼)á—®\n  refine eigenspace_restrict_eq_bot hT.orthogonalComplement_iSup_eigenspaces_invariant ?_\n  have Hâ‚‚ : eigenspace T Î¼ âŸ‚ p := (Submodule.isOrtho_orthogonal_right _).mono_left (le_iSup _ _)\n  exact Hâ‚‚.disjoint\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nâŠ¢ Eq (iSup fun Î¼ => Module.End.eigenspace T Î¼).orthogonal Bot.bot","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem orthogonalComplement_iSup_eigenspaces_eq_bot (hT : T.IsSymmetric) :\n    (â¨† Î¼, eigenspace T Î¼)á—® = âŠ¥ := by\n  have hT' : IsSymmetric _ :=\n    hT.restrict_invariant hT.orthogonalComplement_iSup_eigenspaces_invariant\n  -- a self-adjoint operator on a nontrivial inner product space has an eigenvalue\n  haveI :=\n    hT'.subsingleton_of_no_eigenvalue_finiteDimensional hT.orthogonalComplement_iSup_eigenspaces\n  exact Submodule.eq_bot_of_subsingleton\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot'","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nâŠ¢ Eq (iSup fun Î¼ => Module.End.eigenspace T (â†‘T 1 Î¼)).orthogonal Bot.bot","decl":"theorem orthogonalComplement_iSup_eigenspaces_eq_bot' (hT : T.IsSymmetric) :\n    (â¨† Î¼ : Eigenvalues T, eigenspace T Î¼)á—® = âŠ¥ :=\n  show (â¨† Î¼ : { Î¼ // eigenspace T Î¼ â‰  âŠ¥ }, eigenspace T Î¼)á—® = âŠ¥ by\n    rw [iSup_ne_bot_subtype, hT.orthogonalComplement_iSup_eigenspaces_eq_bot]\n\n"}
{"name":"LinearMap.IsSymmetric.directSum_decompose_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\n_hT : Fact T.IsSymmetric\nx : E\nÎ¼ : Module.End.Eigenvalues T\nâŠ¢ Eq (((DirectSum.decompose fun Î¼ => Module.End.eigenspace T (â†‘T 1 Î¼)) x) Î¼) ((orthogonalProjection (Module.End.eigenspace T (â†‘T 1 Î¼))) x)","decl":"theorem directSum_decompose_apply [_hT : Fact T.IsSymmetric] (x : E) (Î¼ : Eigenvalues T) :\n    DirectSum.decompose (fun Î¼ : Eigenvalues T => eigenspace T Î¼) x Î¼ =\n      orthogonalProjection (eigenspace T Î¼) x :=\n  rfl\n\n"}
{"name":"LinearMap.IsSymmetric.direct_sum_isInternal","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nâŠ¢ DirectSum.IsInternal fun Î¼ => Module.End.eigenspace T (â†‘T 1 Î¼)","decl":"/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\nan internal direct sum decomposition of `E`. -/\ntheorem direct_sum_isInternal (hT : T.IsSymmetric) :\n    DirectSum.IsInternal fun Î¼ : Eigenvalues T => eigenspace T Î¼ :=\n  hT.orthogonalFamily_eigenspaces'.isInternal_iff.mpr\n    hT.orthogonalComplement_iSup_eigenspaces_eq_bot'\n\n"}
{"name":"LinearMap.IsSymmetric.diagonalization_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nw : PiLp 2 fun Î¼ => Subtype fun x => Membership.mem (Module.End.eigenspace T (â†‘T 1 Î¼)) x\nâŠ¢ Eq (hT.diagonalization.symm w) (Finset.univ.sum fun Î¼ => â†‘(w Î¼))","decl":"@[simp]\ntheorem diagonalization_symm_apply (w : PiLp 2 fun Î¼ : Eigenvalues T => eigenspace T Î¼) :\n    hT.diagonalization.symm w = âˆ‘ Î¼, w Î¼ :=\n  hT.direct_sum_isInternal.isometryL2OfOrthogonalFamily_symm_apply\n    hT.orthogonalFamily_eigenspaces' w\n\n"}
{"name":"LinearMap.IsSymmetric.diagonalization_apply_self_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nv : E\nÎ¼ : Module.End.Eigenvalues T\nâŠ¢ Eq (hT.diagonalization (T v) Î¼) (HSMul.hSMul (â†‘T 1 Î¼) (hT.diagonalization v Î¼))","decl":"/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem diagonalization_apply_self_apply (v : E) (Î¼ : Eigenvalues T) :\n    hT.diagonalization (T v) Î¼ = (Î¼ : ğ•œ) â€¢ hT.diagonalization v Î¼ := by\n  suffices\n    âˆ€ w : PiLp 2 fun Î¼ : Eigenvalues T => eigenspace T Î¼,\n      T (hT.diagonalization.symm w) = hT.diagonalization.symm fun Î¼ => (Î¼ : ğ•œ) â€¢ w Î¼ by\n    simpa only [LinearIsometryEquiv.symm_apply_apply, LinearIsometryEquiv.apply_symm_apply] using\n      congr_arg (fun w => hT.diagonalization w Î¼) (this (hT.diagonalization v))\n  intro w\n  have hwT : âˆ€ Î¼, T (w Î¼) = (Î¼ : ğ•œ) â€¢ w Î¼ := fun Î¼ => mem_eigenspace_iff.1 (w Î¼).2\n  simp only [hwT, diagonalization_symm_apply, map_sum, Submodule.coe_smul_of_tower]\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvectorBasis_def","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\nâŠ¢ Eq (hT.eigenvectorBasis hn) (DirectSum.IsInternal.subordinateOrthonormalBasis hn â‹¯ â‹¯)","decl":"/-- A choice of orthonormal basis of eigenvectors for self-adjoint operator `T` on a\nfinite-dimensional inner product space `E`.\n\nTODO Postcompose with a permutation so that these eigenvectors are listed in increasing order of\neigenvalue. -/\nnoncomputable irreducible_def eigenvectorBasis : OrthonormalBasis (Fin n) ğ•œ E :=\n  hT.direct_sum_isInternal.subordinateOrthonormalBasis hn hT.orthogonalFamily_eigenspaces'\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvalues_def","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_3\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ni : Fin n\nâŠ¢ Eq (hT.eigenvalues hn i) (RCLike.re (â†‘T (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn â‹¯ i â‹¯)))","decl":"/-- The sequence of real eigenvalues associated to the standard orthonormal basis of eigenvectors\nfor a self-adjoint operator `T` on `E`.\n\nTODO Postcompose with a permutation so that these eigenvalues are listed in increasing order. -/\nnoncomputable irreducible_def eigenvalues (i : Fin n) : â„ :=\n  @RCLike.re ğ•œ _ <| (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i\n    hT.orthogonalFamily_eigenspaces').val\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ni : Fin n\nâŠ¢ Module.End.HasEigenvector T (â†‘(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn) i)","decl":"theorem hasEigenvector_eigenvectorBasis (i : Fin n) :\n    HasEigenvector T (hT.eigenvalues hn i) (hT.eigenvectorBasis hn i) := by\n  let v : E := hT.eigenvectorBasis hn i\n  let Î¼ : ğ•œ :=\n    (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i\n      hT.orthogonalFamily_eigenspaces').val\n  simp_rw [eigenvalues]\n  change HasEigenvector T (RCLike.re Î¼) v\n  have key : HasEigenvector T Î¼ v := by\n    have Hâ‚ : v âˆˆ eigenspace T Î¼ := by\n      simp_rw [v, eigenvectorBasis]\n      exact\n        hT.direct_sum_isInternal.subordinateOrthonormalBasis_subordinate hn i\n          hT.orthogonalFamily_eigenspaces'\n    have Hâ‚‚ : v â‰  0 := by simpa using (hT.eigenvectorBasis hn).toBasis.ne_zero i\n    exact âŸ¨Hâ‚, Hâ‚‚âŸ©\n  have re_Î¼ : â†‘(RCLike.re Î¼) = Î¼ := by\n    rw [â† RCLike.conj_eq_iff_re]\n    exact hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector key)\n  simpa [re_Î¼] using key\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_eigenvalues","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ni : Fin n\nâŠ¢ Module.End.HasEigenvalue T â†‘(hT.eigenvalues hn i)","decl":"theorem hasEigenvalue_eigenvalues (i : Fin n) : HasEigenvalue T (hT.eigenvalues hn i) :=\n  Module.End.hasEigenvalue_of_hasEigenvector (hT.hasEigenvector_eigenvectorBasis hn i)\n\n"}
{"name":"LinearMap.IsSymmetric.apply_eigenvectorBasis","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\ni : Fin n\nâŠ¢ Eq (T ((hT.eigenvectorBasis hn) i)) (HSMul.hSMul (â†‘(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn) i))","decl":"@[simp]\ntheorem apply_eigenvectorBasis (i : Fin n) :\n    T (hT.eigenvectorBasis hn i) = (hT.eigenvalues hn i : ğ•œ) â€¢ hT.eigenvectorBasis hn i :=\n  mem_eigenspace_iff.mp (hT.hasEigenvector_eigenvectorBasis hn i).1\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\nT : LinearMap (RingHom.id ğ•œ) E E\ninstâœ : FiniteDimensional ğ•œ E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank ğ•œ E) n\nv : E\ni : Fin n\nâŠ¢ Eq ((hT.eigenvectorBasis hn).repr (T v) i) (HMul.hMul (â†‘(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn).repr v i))","decl":"/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem eigenvectorBasis_apply_self_apply (v : E) (i : Fin n) :\n    (hT.eigenvectorBasis hn).repr (T v) i =\n      hT.eigenvalues hn i * (hT.eigenvectorBasis hn).repr v i := by\n  suffices\n    âˆ€ w : EuclideanSpace ğ•œ (Fin n),\n      T ((hT.eigenvectorBasis hn).repr.symm w) =\n        (hT.eigenvectorBasis hn).repr.symm fun i => hT.eigenvalues hn i * w i by\n    simpa [OrthonormalBasis.sum_repr_symm] using\n      congr_arg (fun v => (hT.eigenvectorBasis hn).repr v i)\n        (this ((hT.eigenvectorBasis hn).repr v))\n  intro w\n  simp_rw [â† OrthonormalBasis.sum_repr_symm, map_sum, map_smul, apply_eigenvectorBasis]\n  apply Fintype.sum_congr\n  intro a\n  rw [smul_smul, mul_comm]\n\n"}
{"name":"inner_product_apply_eigenvector","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¼ : ğ•œ\nv : E\nT : LinearMap (RingHom.id ğ•œ) E E\nh : Membership.mem (Module.End.eigenspace T Î¼) v\nâŠ¢ Eq (Inner.inner v (T v)) (HMul.hMul Î¼ (HPow.hPow (â†‘(Norm.norm v)) 2))","decl":"@[simp]\ntheorem inner_product_apply_eigenvector {Î¼ : ğ•œ} {v : E} {T : E â†’â‚—[ğ•œ] E}\n    (h : v âˆˆ Module.End.eigenspace T Î¼) : âŸªv, T vâŸ« = Î¼ * (â€–vâ€– : ğ•œ) ^ 2 := by\n  simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n\n"}
{"name":"eigenvalue_nonneg_of_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¼ : Real\nT : LinearMap (RingHom.id ğ•œ) E E\nhÎ¼ : Module.End.HasEigenvalue T â†‘Î¼\nhnn : âˆ€ (x : E), LE.le 0 (RCLike.re (Inner.inner x (T x)))\nâŠ¢ LE.le 0 Î¼","decl":"theorem eigenvalue_nonneg_of_nonneg {Î¼ : â„} {T : E â†’â‚—[ğ•œ] E} (hÎ¼ : HasEigenvalue T Î¼)\n    (hnn : âˆ€ x : E, 0 â‰¤ RCLike.re âŸªx, T xâŸ«) : 0 â‰¤ Î¼ := by\n  obtain âŸ¨v, hvâŸ© := hÎ¼.exists_hasEigenvector\n  have hpos : (0 : â„) < â€–vâ€– ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : RCLike.re âŸªv, T vâŸ« = Î¼ * â€–vâ€– ^ 2 := by\n    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)\n    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`\n    rw [â† RCLike.ofReal_pow, â† RCLike.ofReal_mul] at this\n    exact mod_cast this\n  exact (mul_nonneg_iff_of_pos_right hpos).mp (this â–¸ hnn v)\n\n"}
{"name":"eigenvalue_pos_of_pos","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nÎ¼ : Real\nT : LinearMap (RingHom.id ğ•œ) E E\nhÎ¼ : Module.End.HasEigenvalue T â†‘Î¼\nhnn : âˆ€ (x : E), LT.lt 0 (RCLike.re (Inner.inner x (T x)))\nâŠ¢ LT.lt 0 Î¼","decl":"theorem eigenvalue_pos_of_pos {Î¼ : â„} {T : E â†’â‚—[ğ•œ] E} (hÎ¼ : HasEigenvalue T Î¼)\n    (hnn : âˆ€ x : E, 0 < RCLike.re âŸªx, T xâŸ«) : 0 < Î¼ := by\n  obtain âŸ¨v, hvâŸ© := hÎ¼.exists_hasEigenvector\n  have hpos : (0 : â„) < â€–vâ€– ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : RCLike.re âŸªv, T vâŸ« = Î¼ * â€–vâ€– ^ 2 := by\n    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)\n    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`\n    rw [â† RCLike.ofReal_pow, â† RCLike.ofReal_mul] at this\n    exact mod_cast this\n  exact (mul_pos_iff_of_pos_right hpos).mp (this â–¸ hnn v)\n\n"}
