{"name":"LinearMap.IsSymmetric.invariant_orthogonalComplement_eigenspace","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nμ : 𝕜\nv : E\nhv : Membership.mem (Module.End.eigenspace T μ).orthogonal v\n⊢ Membership.mem (Module.End.eigenspace T μ).orthogonal (T v)","decl":"/-- A self-adjoint operator preserves orthogonal complements of its eigenspaces. -/\ntheorem invariant_orthogonalComplement_eigenspace (hT : T.IsSymmetric) (μ : 𝕜)\n    (v : E) (hv : v ∈ (eigenspace T μ)ᗮ) : T v ∈ (eigenspace T μ)ᗮ := by\n  intro w hw\n  have : T w = (μ : 𝕜) • w := by rwa [mem_eigenspace_iff] at hw\n  simp [← hT w, this, inner_smul_left, hv w hw]\n\n"}
{"name":"LinearMap.IsSymmetric.conj_eigenvalue_eq_self","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nμ : 𝕜\nhμ : Module.End.HasEigenvalue T μ\n⊢ Eq ((starRingEnd 𝕜) μ) μ","decl":"/-- The eigenvalues of a self-adjoint operator are real. -/\ntheorem conj_eigenvalue_eq_self (hT : T.IsSymmetric) {μ : 𝕜} (hμ : HasEigenvalue T μ) :\n    conj μ = μ := by\n  obtain ⟨v, hv₁, hv₂⟩ := hμ.exists_hasEigenvector\n  rw [mem_eigenspace_iff] at hv₁\n  simpa [hv₂, inner_smul_left, inner_smul_right, hv₁] using hT v v\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalFamily_eigenspaces","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\n⊢ OrthogonalFamily 𝕜 (fun μ => Subtype fun x => Membership.mem (Module.End.eigenspace T μ) x) fun μ => (Module.End.eigenspace T μ).subtypeₗᵢ","decl":"/-- The eigenspaces of a self-adjoint operator are mutually orthogonal. -/\ntheorem orthogonalFamily_eigenspaces (hT : T.IsSymmetric) :\n    OrthogonalFamily 𝕜 (fun μ => eigenspace T μ) fun μ => (eigenspace T μ).subtypeₗᵢ := by\n  rintro μ ν hμν ⟨v, hv⟩ ⟨w, hw⟩\n  by_cases hv' : v = 0\n  · simp [hv']\n  have H := hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector ⟨hv, hv'⟩)\n  rw [mem_eigenspace_iff] at hv hw\n  refine Or.resolve_left ?_ hμν.symm\n  simpa [inner_smul_left, inner_smul_right, hv, hw, H] using (hT v w).symm\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalFamily_eigenspaces'","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\n⊢ OrthogonalFamily 𝕜 (fun μ => Subtype fun x => Membership.mem (Module.End.eigenspace T (↑T 1 μ)) x) fun μ => (Module.End.eigenspace T (↑T 1 μ)).subtypeₗᵢ","decl":"theorem orthogonalFamily_eigenspaces' (hT : T.IsSymmetric) :\n    OrthogonalFamily 𝕜 (fun μ : Eigenvalues T => eigenspace T μ) fun μ =>\n      (eigenspace T μ).subtypeₗᵢ :=\n  hT.orthogonalFamily_eigenspaces.comp Subtype.coe_injective\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_invariant","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nv : E\nhv : Membership.mem (iSup fun μ => Module.End.eigenspace T μ).orthogonal v\n⊢ Membership.mem (iSup fun μ => Module.End.eigenspace T μ).orthogonal (T v)","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space is an invariant subspace of the operator. -/\ntheorem orthogonalComplement_iSup_eigenspaces_invariant (hT : T.IsSymmetric)\n    ⦃v : E⦄ (hv : v ∈ (⨆ μ, eigenspace T μ)ᗮ) : T v ∈ (⨆ μ, eigenspace T μ)ᗮ := by\n  rw [← Submodule.iInf_orthogonal] at hv ⊢\n  exact T.iInf_invariant hT.invariant_orthogonalComplement_eigenspace v hv\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\nhT : T.IsSymmetric\nμ : 𝕜\n⊢ Eq (Module.End.eigenspace (T.restrict ⋯) μ) Bot.bot","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on an inner\nproduct space has no eigenvalues. -/\ntheorem orthogonalComplement_iSup_eigenspaces (hT : T.IsSymmetric) (μ : 𝕜) :\n    eigenspace (T.restrict hT.orthogonalComplement_iSup_eigenspaces_invariant) μ = ⊥ := by\n  set p : Submodule 𝕜 E := (⨆ μ, eigenspace T μ)ᗮ\n  refine eigenspace_restrict_eq_bot hT.orthogonalComplement_iSup_eigenspaces_invariant ?_\n  have H₂ : eigenspace T μ ⟂ p := (Submodule.isOrtho_orthogonal_right _).mono_left (le_iSup _ _)\n  exact H₂.disjoint\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\n⊢ Eq (iSup fun μ => Module.End.eigenspace T μ).orthogonal Bot.bot","decl":"/-- The mutual orthogonal complement of the eigenspaces of a self-adjoint operator on a\nfinite-dimensional inner product space is trivial. -/\ntheorem orthogonalComplement_iSup_eigenspaces_eq_bot (hT : T.IsSymmetric) :\n    (⨆ μ, eigenspace T μ)ᗮ = ⊥ := by\n  have hT' : IsSymmetric _ :=\n    hT.restrict_invariant hT.orthogonalComplement_iSup_eigenspaces_invariant\n  -- a self-adjoint operator on a nontrivial inner product space has an eigenvalue\n  haveI :=\n    hT'.subsingleton_of_no_eigenvalue_finiteDimensional hT.orthogonalComplement_iSup_eigenspaces\n  exact Submodule.eq_bot_of_subsingleton\n\n"}
{"name":"LinearMap.IsSymmetric.orthogonalComplement_iSup_eigenspaces_eq_bot'","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\n⊢ Eq (iSup fun μ => Module.End.eigenspace T (↑T 1 μ)).orthogonal Bot.bot","decl":"theorem orthogonalComplement_iSup_eigenspaces_eq_bot' (hT : T.IsSymmetric) :\n    (⨆ μ : Eigenvalues T, eigenspace T μ)ᗮ = ⊥ :=\n  show (⨆ μ : { μ // eigenspace T μ ≠ ⊥ }, eigenspace T μ)ᗮ = ⊥ by\n    rw [iSup_ne_bot_subtype, hT.orthogonalComplement_iSup_eigenspaces_eq_bot]\n\n"}
{"name":"LinearMap.IsSymmetric.directSum_decompose_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\n_hT : Fact T.IsSymmetric\nx : E\nμ : Module.End.Eigenvalues T\n⊢ Eq (((DirectSum.decompose fun μ => Module.End.eigenspace T (↑T 1 μ)) x) μ) ((orthogonalProjection (Module.End.eigenspace T (↑T 1 μ))) x)","decl":"theorem directSum_decompose_apply [_hT : Fact T.IsSymmetric] (x : E) (μ : Eigenvalues T) :\n    DirectSum.decompose (fun μ : Eigenvalues T => eigenspace T μ) x μ =\n      orthogonalProjection (eigenspace T μ) x :=\n  rfl\n\n"}
{"name":"LinearMap.IsSymmetric.direct_sum_isInternal","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\n⊢ DirectSum.IsInternal fun μ => Module.End.eigenspace T (↑T 1 μ)","decl":"/-- The eigenspaces of a self-adjoint operator on a finite-dimensional inner product space `E` gives\nan internal direct sum decomposition of `E`. -/\ntheorem direct_sum_isInternal (hT : T.IsSymmetric) :\n    DirectSum.IsInternal fun μ : Eigenvalues T => eigenspace T μ :=\n  hT.orthogonalFamily_eigenspaces'.isInternal_iff.mpr\n    hT.orthogonalComplement_iSup_eigenspaces_eq_bot'\n\n"}
{"name":"LinearMap.IsSymmetric.diagonalization_symm_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nw : PiLp 2 fun μ => Subtype fun x => Membership.mem (Module.End.eigenspace T (↑T 1 μ)) x\n⊢ Eq (hT.diagonalization.symm w) (Finset.univ.sum fun μ => ↑(w μ))","decl":"@[simp]\ntheorem diagonalization_symm_apply (w : PiLp 2 fun μ : Eigenvalues T => eigenspace T μ) :\n    hT.diagonalization.symm w = ∑ μ, w μ :=\n  hT.direct_sum_isInternal.isometryL2OfOrthogonalFamily_symm_apply\n    hT.orthogonalFamily_eigenspaces' w\n\n"}
{"name":"LinearMap.IsSymmetric.diagonalization_apply_self_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nv : E\nμ : Module.End.Eigenvalues T\n⊢ Eq (hT.diagonalization (T v) μ) (HSMul.hSMul (↑T 1 μ) (hT.diagonalization v μ))","decl":"/-- *Diagonalization theorem*, *spectral theorem*; version 1: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the decomposition of `E` into the\ndirect sum of the eigenspaces of `T`. -/\ntheorem diagonalization_apply_self_apply (v : E) (μ : Eigenvalues T) :\n    hT.diagonalization (T v) μ = (μ : 𝕜) • hT.diagonalization v μ := by\n  suffices\n    ∀ w : PiLp 2 fun μ : Eigenvalues T => eigenspace T μ,\n      T (hT.diagonalization.symm w) = hT.diagonalization.symm fun μ => (μ : 𝕜) • w μ by\n    simpa only [LinearIsometryEquiv.symm_apply_apply, LinearIsometryEquiv.apply_symm_apply] using\n      congr_arg (fun w => hT.diagonalization w μ) (this (hT.diagonalization v))\n  intro w\n  have hwT : ∀ μ, T (w μ) = (μ : 𝕜) • w μ := fun μ => mem_eigenspace_iff.1 (w μ).2\n  simp only [hwT, diagonalization_symm_apply, map_sum, Submodule.coe_smul_of_tower]\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvectorBasis_def","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\n⊢ Eq (hT.eigenvectorBasis hn) (DirectSum.IsInternal.subordinateOrthonormalBasis hn ⋯ ⋯)","decl":"/-- A choice of orthonormal basis of eigenvectors for self-adjoint operator `T` on a\nfinite-dimensional inner product space `E`.\n\nTODO Postcompose with a permutation so that these eigenvectors are listed in increasing order of\neigenvalue. -/\nnoncomputable irreducible_def eigenvectorBasis : OrthonormalBasis (Fin n) 𝕜 E :=\n  hT.direct_sum_isInternal.subordinateOrthonormalBasis hn hT.orthogonalFamily_eigenspaces'\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvalues_def","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_3\ninst✝³ : RCLike 𝕜\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ni : Fin n\n⊢ Eq (hT.eigenvalues hn i) (RCLike.re (↑T (DirectSum.IsInternal.subordinateOrthonormalBasisIndex hn ⋯ i ⋯)))","decl":"/-- The sequence of real eigenvalues associated to the standard orthonormal basis of eigenvectors\nfor a self-adjoint operator `T` on `E`.\n\nTODO Postcompose with a permutation so that these eigenvalues are listed in increasing order. -/\nnoncomputable irreducible_def eigenvalues (i : Fin n) : ℝ :=\n  @RCLike.re 𝕜 _ <| (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i\n    hT.orthogonalFamily_eigenspaces').val\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvector_eigenvectorBasis","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ni : Fin n\n⊢ Module.End.HasEigenvector T (↑(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn) i)","decl":"theorem hasEigenvector_eigenvectorBasis (i : Fin n) :\n    HasEigenvector T (hT.eigenvalues hn i) (hT.eigenvectorBasis hn i) := by\n  let v : E := hT.eigenvectorBasis hn i\n  let μ : 𝕜 :=\n    (hT.direct_sum_isInternal.subordinateOrthonormalBasisIndex hn i\n      hT.orthogonalFamily_eigenspaces').val\n  simp_rw [eigenvalues]\n  change HasEigenvector T (RCLike.re μ) v\n  have key : HasEigenvector T μ v := by\n    have H₁ : v ∈ eigenspace T μ := by\n      simp_rw [v, eigenvectorBasis]\n      exact\n        hT.direct_sum_isInternal.subordinateOrthonormalBasis_subordinate hn i\n          hT.orthogonalFamily_eigenspaces'\n    have H₂ : v ≠ 0 := by simpa using (hT.eigenvectorBasis hn).toBasis.ne_zero i\n    exact ⟨H₁, H₂⟩\n  have re_μ : ↑(RCLike.re μ) = μ := by\n    rw [← RCLike.conj_eq_iff_re]\n    exact hT.conj_eigenvalue_eq_self (hasEigenvalue_of_hasEigenvector key)\n  simpa [re_μ] using key\n\n"}
{"name":"LinearMap.IsSymmetric.hasEigenvalue_eigenvalues","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ni : Fin n\n⊢ Module.End.HasEigenvalue T ↑(hT.eigenvalues hn i)","decl":"theorem hasEigenvalue_eigenvalues (i : Fin n) : HasEigenvalue T (hT.eigenvalues hn i) :=\n  Module.End.hasEigenvalue_of_hasEigenvector (hT.hasEigenvector_eigenvectorBasis hn i)\n\n"}
{"name":"LinearMap.IsSymmetric.apply_eigenvectorBasis","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\ni : Fin n\n⊢ Eq (T ((hT.eigenvectorBasis hn) i)) (HSMul.hSMul (↑(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn) i))","decl":"@[simp]\ntheorem apply_eigenvectorBasis (i : Fin n) :\n    T (hT.eigenvectorBasis hn i) = (hT.eigenvalues hn i : 𝕜) • hT.eigenvectorBasis hn i :=\n  mem_eigenspace_iff.mp (hT.hasEigenvector_eigenvectorBasis hn i).1\n\n"}
{"name":"LinearMap.IsSymmetric.eigenvectorBasis_apply_self_apply","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\nT : LinearMap (RingHom.id 𝕜) E E\ninst✝ : FiniteDimensional 𝕜 E\nhT : T.IsSymmetric\nn : Nat\nhn : Eq (Module.finrank 𝕜 E) n\nv : E\ni : Fin n\n⊢ Eq ((hT.eigenvectorBasis hn).repr (T v) i) (HMul.hMul (↑(hT.eigenvalues hn i)) ((hT.eigenvectorBasis hn).repr v i))","decl":"/-- *Diagonalization theorem*, *spectral theorem*; version 2: A self-adjoint operator `T` on a\nfinite-dimensional inner product space `E` acts diagonally on the identification of `E` with\nEuclidean space induced by an orthonormal basis of eigenvectors of `T`. -/\ntheorem eigenvectorBasis_apply_self_apply (v : E) (i : Fin n) :\n    (hT.eigenvectorBasis hn).repr (T v) i =\n      hT.eigenvalues hn i * (hT.eigenvectorBasis hn).repr v i := by\n  suffices\n    ∀ w : EuclideanSpace 𝕜 (Fin n),\n      T ((hT.eigenvectorBasis hn).repr.symm w) =\n        (hT.eigenvectorBasis hn).repr.symm fun i => hT.eigenvalues hn i * w i by\n    simpa [OrthonormalBasis.sum_repr_symm] using\n      congr_arg (fun v => (hT.eigenvectorBasis hn).repr v i)\n        (this ((hT.eigenvectorBasis hn).repr v))\n  intro w\n  simp_rw [← OrthonormalBasis.sum_repr_symm, map_sum, map_smul, apply_eigenvectorBasis]\n  apply Fintype.sum_congr\n  intro a\n  rw [smul_smul, mul_comm]\n\n"}
{"name":"inner_product_apply_eigenvector","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nμ : 𝕜\nv : E\nT : LinearMap (RingHom.id 𝕜) E E\nh : Membership.mem (Module.End.eigenspace T μ) v\n⊢ Eq (Inner.inner v (T v)) (HMul.hMul μ (HPow.hPow (↑(Norm.norm v)) 2))","decl":"@[simp]\ntheorem inner_product_apply_eigenvector {μ : 𝕜} {v : E} {T : E →ₗ[𝕜] E}\n    (h : v ∈ Module.End.eigenspace T μ) : ⟪v, T v⟫ = μ * (‖v‖ : 𝕜) ^ 2 := by\n  simp only [mem_eigenspace_iff.mp h, inner_smul_right, inner_self_eq_norm_sq_to_K]\n\n"}
{"name":"eigenvalue_nonneg_of_nonneg","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nμ : Real\nT : LinearMap (RingHom.id 𝕜) E E\nhμ : Module.End.HasEigenvalue T ↑μ\nhnn : ∀ (x : E), LE.le 0 (RCLike.re (Inner.inner x (T x)))\n⊢ LE.le 0 μ","decl":"theorem eigenvalue_nonneg_of_nonneg {μ : ℝ} {T : E →ₗ[𝕜] E} (hμ : HasEigenvalue T μ)\n    (hnn : ∀ x : E, 0 ≤ RCLike.re ⟪x, T x⟫) : 0 ≤ μ := by\n  obtain ⟨v, hv⟩ := hμ.exists_hasEigenvector\n  have hpos : (0 : ℝ) < ‖v‖ ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : RCLike.re ⟪v, T v⟫ = μ * ‖v‖ ^ 2 := by\n    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)\n    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`\n    rw [← RCLike.ofReal_pow, ← RCLike.ofReal_mul] at this\n    exact mod_cast this\n  exact (mul_nonneg_iff_of_pos_right hpos).mp (this ▸ hnn v)\n\n"}
{"name":"eigenvalue_pos_of_pos","module":"Mathlib.Analysis.InnerProductSpace.Spectrum","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nμ : Real\nT : LinearMap (RingHom.id 𝕜) E E\nhμ : Module.End.HasEigenvalue T ↑μ\nhnn : ∀ (x : E), LT.lt 0 (RCLike.re (Inner.inner x (T x)))\n⊢ LT.lt 0 μ","decl":"theorem eigenvalue_pos_of_pos {μ : ℝ} {T : E →ₗ[𝕜] E} (hμ : HasEigenvalue T μ)\n    (hnn : ∀ x : E, 0 < RCLike.re ⟪x, T x⟫) : 0 < μ := by\n  obtain ⟨v, hv⟩ := hμ.exists_hasEigenvector\n  have hpos : (0 : ℝ) < ‖v‖ ^ 2 := by simpa only [sq_pos_iff, norm_ne_zero_iff] using hv.2\n  have : RCLike.re ⟪v, T v⟫ = μ * ‖v‖ ^ 2 := by\n    have := congr_arg RCLike.re (inner_product_apply_eigenvector hv.1)\n    -- Porting note: why can't `exact_mod_cast` do this? These lemmas are marked `norm_cast`\n    rw [← RCLike.ofReal_pow, ← RCLike.ofReal_mul] at this\n    exact mod_cast this\n  exact (mul_pos_iff_of_pos_right hpos).mp (this ▸ hnn v)\n\n"}
