{"name":"Set.IsPWO.mul","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : OrderedCancelCommMonoid α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (HMul.hMul s t).IsPWO","decl":"@[to_additive]\ntheorem IsPWO.mul [OrderedCancelCommMonoid α] (hs : s.IsPWO) (ht : t.IsPWO) : IsPWO (s * t) := by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image_of_monotone (monotone_fst.mul' monotone_snd)\n\n"}
{"name":"Set.IsPWO.add","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : OrderedCancelAddCommMonoid α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (HAdd.hAdd s t).IsPWO","decl":"@[to_additive]\ntheorem IsPWO.mul [OrderedCancelCommMonoid α] (hs : s.IsPWO) (ht : t.IsPWO) : IsPWO (s * t) := by\n  rw [← image_mul_prod]\n  exact (hs.prod ht).image_of_monotone (monotone_fst.mul' monotone_snd)\n\n"}
{"name":"Set.IsWF.mul","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : LinearOrderedCancelCommMonoid α\nhs : s.IsWF\nht : t.IsWF\n⊢ (HMul.hMul s t).IsWF","decl":"@[to_additive]\ntheorem IsWF.mul (hs : s.IsWF) (ht : t.IsWF) : IsWF (s * t) :=\n  (hs.isPWO.mul ht.isPWO).isWF\n\n"}
{"name":"Set.IsWF.add","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : LinearOrderedCancelAddCommMonoid α\nhs : s.IsWF\nht : t.IsWF\n⊢ (HAdd.hAdd s t).IsWF","decl":"@[to_additive]\ntheorem IsWF.mul (hs : s.IsWF) (ht : t.IsWF) : IsWF (s * t) :=\n  (hs.isPWO.mul ht.isPWO).isWF\n\n"}
{"name":"Set.IsWF.min_mul","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : LinearOrderedCancelCommMonoid α\nhs : s.IsWF\nht : t.IsWF\nhsn : s.Nonempty\nhtn : t.Nonempty\n⊢ Eq (⋯.min ⋯) (HMul.hMul (hs.min hsn) (ht.min htn))","decl":"@[to_additive]\ntheorem IsWF.min_mul (hs : s.IsWF) (ht : t.IsWF) (hsn : s.Nonempty) (htn : t.Nonempty) :\n    (hs.mul ht).min (hsn.mul htn) = hs.min hsn * ht.min htn := by\n  refine le_antisymm (IsWF.min_le _ _ (mem_mul.2 ⟨_, hs.min_mem _, _, ht.min_mem _, rfl⟩)) ?_\n  rw [IsWF.le_min_iff]\n  rintro _ ⟨x, hx, y, hy, rfl⟩\n  exact mul_le_mul' (hs.min_le _ hx) (ht.min_le _ hy)\n\n"}
{"name":"Set.IsWF.min_add","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : LinearOrderedCancelAddCommMonoid α\nhs : s.IsWF\nht : t.IsWF\nhsn : s.Nonempty\nhtn : t.Nonempty\n⊢ Eq (⋯.min ⋯) (HAdd.hAdd (hs.min hsn) (ht.min htn))","decl":"@[to_additive]\ntheorem IsWF.min_mul (hs : s.IsWF) (ht : t.IsWF) (hsn : s.Nonempty) (htn : t.Nonempty) :\n    (hs.mul ht).min (hsn.mul htn) = hs.min hsn * ht.min htn := by\n  refine le_antisymm (IsWF.min_le _ _ (mem_mul.2 ⟨_, hs.min_mem _, _, ht.min_mem _, rfl⟩)) ?_\n  rw [IsWF.le_min_iff]\n  rintro _ ⟨x, hx, y, hy, rfl⟩\n  exact mul_le_mul' (hs.min_le _ hx) (ht.min_le _ hy)\n\n"}
{"name":"Finset.mem_mulAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (Finset.mulAntidiagonal hs ht a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HMul.hMul x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulAntidiagonal : x ∈ mulAntidiagonal hs ht a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 * x.2 = a := by\n  simp only [mulAntidiagonal, Set.Finite.mem_toFinset, Set.mem_mulAntidiagonal]\n\n"}
{"name":"Finset.mem_addAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (Finset.addAntidiagonal hs ht a) x) (And (Membership.mem s x.1) (And (Membership.mem t x.2) (Eq (HAdd.hAdd x.1 x.2) a)))","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulAntidiagonal : x ∈ mulAntidiagonal hs ht a ↔ x.1 ∈ s ∧ x.2 ∈ t ∧ x.1 * x.2 = a := by\n  simp only [mulAntidiagonal, Set.Finite.mem_toFinset, Set.mem_mulAntidiagonal]\n\n"}
{"name":"Finset.mulAntidiagonal_mono_left","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nu : Set α\nhu : u.IsPWO\nh : HasSubset.Subset u s\n⊢ HasSubset.Subset (Finset.mulAntidiagonal hu ht a) (Finset.mulAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_left (h : u ⊆ s) : mulAntidiagonal hu ht a ⊆ mulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.mulAntidiagonal_mono_left h\n\n"}
{"name":"Finset.addAntidiagonal_mono_left","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nu : Set α\nhu : u.IsPWO\nh : HasSubset.Subset u s\n⊢ HasSubset.Subset (Finset.addAntidiagonal hu ht a) (Finset.addAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_left (h : u ⊆ s) : mulAntidiagonal hu ht a ⊆ mulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.mulAntidiagonal_mono_left h\n\n"}
{"name":"Finset.mulAntidiagonal_mono_right","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nu : Set α\nhu : u.IsPWO\nh : HasSubset.Subset u t\n⊢ HasSubset.Subset (Finset.mulAntidiagonal hs hu a) (Finset.mulAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_right (h : u ⊆ t) :\n    mulAntidiagonal hs hu a ⊆ mulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.mulAntidiagonal_mono_right h\n\n"}
{"name":"Finset.addAntidiagonal_mono_right","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nu : Set α\nhu : u.IsPWO\nh : HasSubset.Subset u t\n⊢ HasSubset.Subset (Finset.addAntidiagonal hs hu a) (Finset.addAntidiagonal hs ht a)","decl":"@[to_additive]\ntheorem mulAntidiagonal_mono_right (h : u ⊆ t) :\n    mulAntidiagonal hs hu a ⊆ mulAntidiagonal hs ht a :=\n  Set.Finite.toFinset_mono <| Set.mulAntidiagonal_mono_right h\n\n"}
{"name":"Finset.swap_mem_mulAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (Finset.mulAntidiagonal hs ht a) x.swap) (Membership.mem (Finset.mulAntidiagonal ht hs a) x)","decl":"@[to_additive]\ntheorem swap_mem_mulAntidiagonal :\n    x.swap ∈ Finset.mulAntidiagonal hs ht a ↔ x ∈ Finset.mulAntidiagonal ht hs a := by\n  simp\n\n"}
{"name":"Finset.swap_mem_addAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\na : α\nx : Prod α α\n⊢ Iff (Membership.mem (Finset.addAntidiagonal hs ht a) x.swap) (Membership.mem (Finset.addAntidiagonal ht hs a) x)","decl":"@[to_additive]\ntheorem swap_mem_mulAntidiagonal :\n    x.swap ∈ Finset.mulAntidiagonal hs ht a ↔ x ∈ Finset.mulAntidiagonal ht hs a := by\n  simp\n\n"}
{"name":"Finset.support_addAntidiagonal_subset_add","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ HasSubset.Subset (setOf fun a => (Finset.addAntidiagonal hs ht a).Nonempty) (HAdd.hAdd s t)","decl":"@[to_additive]\ntheorem support_mulAntidiagonal_subset_mul : { a | (mulAntidiagonal hs ht a).Nonempty } ⊆ s * t :=\n  fun a ⟨b, hb⟩ => by\n  rw [mem_mulAntidiagonal] at hb\n  exact ⟨b.1, hb.1, b.2, hb.2⟩\n\n"}
{"name":"Finset.support_mulAntidiagonal_subset_mul","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ HasSubset.Subset (setOf fun a => (Finset.mulAntidiagonal hs ht a).Nonempty) (HMul.hMul s t)","decl":"@[to_additive]\ntheorem support_mulAntidiagonal_subset_mul : { a | (mulAntidiagonal hs ht a).Nonempty } ⊆ s * t :=\n  fun a ⟨b, hb⟩ => by\n  rw [mem_mulAntidiagonal] at hb\n  exact ⟨b.1, hb.1, b.2, hb.2⟩\n\n"}
{"name":"Finset.isPWO_support_mulAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (setOf fun a => (Finset.mulAntidiagonal hs ht a).Nonempty).IsPWO","decl":"@[to_additive]\ntheorem isPWO_support_mulAntidiagonal : { a | (mulAntidiagonal hs ht a).Nonempty }.IsPWO :=\n  (hs.mul ht).mono support_mulAntidiagonal_subset_mul\n\n"}
{"name":"Finset.isPWO_support_addAntidiagonal","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_1\ninst✝ : OrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (setOf fun a => (Finset.addAntidiagonal hs ht a).Nonempty).IsPWO","decl":"@[to_additive]\ntheorem isPWO_support_mulAntidiagonal : { a | (mulAntidiagonal hs ht a).Nonempty }.IsPWO :=\n  (hs.mul ht).mono support_mulAntidiagonal_subset_mul\n\n"}
{"name":"Finset.addAntidiagonal_min_add_min","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedCancelAddCommMonoid α\ns t : Set α\nhs : s.IsWF\nht : t.IsWF\nhns : s.Nonempty\nhnt : t.Nonempty\n⊢ Eq (Finset.addAntidiagonal ⋯ ⋯ (HAdd.hAdd (hs.min hns) (ht.min hnt))) (Singleton.singleton { fst := hs.min hns, snd := ht.min hnt })","decl":"@[to_additive]\ntheorem mulAntidiagonal_min_mul_min {α} [LinearOrderedCancelCommMonoid α] {s t : Set α}\n    (hs : s.IsWF) (ht : t.IsWF) (hns : s.Nonempty) (hnt : t.Nonempty) :\n    mulAntidiagonal hs.isPWO ht.isPWO (hs.min hns * ht.min hnt) = {(hs.min hns, ht.min hnt)} := by\n  ext ⟨a, b⟩\n  simp only [mem_mulAntidiagonal, mem_singleton, Prod.ext_iff]\n  constructor\n  · rintro ⟨has, hat, hst⟩\n    obtain rfl :=\n      (hs.min_le hns has).eq_of_not_lt fun hlt =>\n        (mul_lt_mul_of_lt_of_le hlt <| ht.min_le hnt hat).ne' hst\n    exact ⟨rfl, mul_left_cancel hst⟩\n  · rintro ⟨rfl, rfl⟩\n    exact ⟨hs.min_mem _, ht.min_mem _, rfl⟩\n\n"}
{"name":"Finset.mulAntidiagonal_min_mul_min","module":"Mathlib.Data.Finset.MulAntidiagonal","initialProofState":"α : Type u_2\ninst✝ : LinearOrderedCancelCommMonoid α\ns t : Set α\nhs : s.IsWF\nht : t.IsWF\nhns : s.Nonempty\nhnt : t.Nonempty\n⊢ Eq (Finset.mulAntidiagonal ⋯ ⋯ (HMul.hMul (hs.min hns) (ht.min hnt))) (Singleton.singleton { fst := hs.min hns, snd := ht.min hnt })","decl":"@[to_additive]\ntheorem mulAntidiagonal_min_mul_min {α} [LinearOrderedCancelCommMonoid α] {s t : Set α}\n    (hs : s.IsWF) (ht : t.IsWF) (hns : s.Nonempty) (hnt : t.Nonempty) :\n    mulAntidiagonal hs.isPWO ht.isPWO (hs.min hns * ht.min hnt) = {(hs.min hns, ht.min hnt)} := by\n  ext ⟨a, b⟩\n  simp only [mem_mulAntidiagonal, mem_singleton, Prod.ext_iff]\n  constructor\n  · rintro ⟨has, hat, hst⟩\n    obtain rfl :=\n      (hs.min_le hns has).eq_of_not_lt fun hlt =>\n        (mul_lt_mul_of_lt_of_le hlt <| ht.min_le hnt hat).ne' hst\n    exact ⟨rfl, mul_left_cancel hst⟩\n  · rintro ⟨rfl, rfl⟩\n    exact ⟨hs.min_mem _, ht.min_mem _, rfl⟩\n\n"}
