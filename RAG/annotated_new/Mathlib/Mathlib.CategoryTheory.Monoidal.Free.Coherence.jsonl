{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.unit.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\ninst‚úù : SizeOf C\n‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.unit) 1","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((ùüô_ C) ‚äó X‚ÇÅ) ‚äó X‚ÇÇ) ‚äó ‚ãØ`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject ‚Üí C ‚Üí NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.inj","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\na‚úù¬≥ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na‚úù¬≤ : C\na‚úù¬π : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na‚úù : C\nx‚úù : Eq (a‚úù¬≥.tensor a‚úù¬≤) (a‚úù¬π.tensor a‚úù)\n‚ä¢ And (Eq a‚úù¬≥ a‚úù¬π) (Eq a‚úù¬≤ a‚úù)","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((ùüô_ C) ‚äó X‚ÇÅ) ‚äó X‚ÇÇ) ‚äó ‚ãØ`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject ‚Üí C ‚Üí NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\ninst‚úù : SizeOf C\na‚úù¬π : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na‚úù : C\n‚ä¢ Eq (SizeOf.sizeOf (a‚úù¬π.tensor a‚úù)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a‚úù¬π)) (SizeOf.sizeOf a‚úù))","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((ùüô_ C) ‚äó X‚ÇÅ) ‚äó X‚ÇÇ) ‚äó ‚ãØ`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject ‚Üí C ‚Üí NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.injEq","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\na‚úù¬≥ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na‚úù¬≤ : C\na‚úù¬π : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na‚úù : C\n‚ä¢ Eq (Eq (a‚úù¬≥.tensor a‚úù¬≤) (a‚úù¬π.tensor a‚úù)) (And (Eq a‚úù¬≥ a‚úù¬π) (Eq a‚úù¬≤ a‚úù))","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((ùüô_ C) ‚äó X‚ÇÅ) ‚äó X‚ÇÇ) ‚äó ‚ãØ`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject ‚Üí C ‚Üí NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.instSubsingletonHomCompDiscreteNormalMonoidalObject","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nx y : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Subsingleton (Quiver.Hom x y)","decl":"instance (x y : N C) : Subsingleton (x ‚ü∂ y) := Discrete.instSubsingletonDiscreteHom _ _\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.inclusion_obj","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (CategoryTheory.FreeMonoidalCategory.inclusion.obj X) (CategoryTheory.FreeMonoidalCategory.inclusionObj X.as)","decl":"@[simp]\ntheorem inclusion_obj (X : N C) :\n    inclusion.obj X = inclusionObj X.as :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.inclusion_map","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.FreeMonoidalCategory.inclusion.map f) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem inclusion_map {X Y : N C} (f : X ‚ü∂ Y) :\n    inclusion.map f = eqToHom (congr_arg _ (Discrete.ext (Discrete.eq_of_hom f))) := by\n  rcases f with ‚ü®‚ü®‚ü©‚ü©\n  cases Discrete.ext (by assumption)\n  apply inclusion.map_id\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_unitor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.normalizeObj n) n","decl":"@[simp]\ntheorem normalizeObj_unitor (n : NormalMonoidalObject C) : normalizeObj (ùüô_ (F C)) n = n :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_tensor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).normalizeObj n) (Y.normalizeObj (X.normalizeObj n))","decl":"@[simp]\ntheorem normalizeObj_tensor (X Y : F C) (n : NormalMonoidalObject C) :\n    normalizeObj (X ‚äó Y) n = normalizeObj Y (normalizeObj X n) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.tensorFunc_map_app","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (((CategoryTheory.FreeMonoidalCategory.tensorFunc C).map f).app n) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }) f)","decl":"theorem tensorFunc_map_app {X Y : F C} (f : X ‚ü∂ Y) (n) : ((tensorFunc C).map f).app n = _ ‚óÅ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.tensorFunc_obj_map","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nZ : CategoryTheory.FreeMonoidalCategory C\nn n' : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nf : Quiver.Hom n n'\n‚ä¢ Eq (((CategoryTheory.FreeMonoidalCategory.tensorFunc C).obj Z).map f) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.FreeMonoidalCategory.inclusion.map f) Z)","decl":"theorem tensorFunc_obj_map (Z : F C) {n n' : N C} (f : n ‚ü∂ n') :\n    ((tensorFunc C).obj Z).map f = inclusion.map f ‚ñ∑ Z := by\n  cases n\n  cases n'\n  rcases f with ‚ü®‚ü®h‚ü©‚ü©\n  dsimp at h\n  subst h\n  simp\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_eq","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX : CategoryTheory.FreeMonoidalCategory C\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C X n) (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C X n.as)","decl":"theorem normalizeIsoApp_eq :\n    ‚àÄ (X : F C) (n : N C), normalizeIsoApp C X n = normalizeIsoApp' C X n.as\n  | of _, _ => rfl\n  | unit, _ => rfl\n  | tensor X Y, n => by\n      rw [normalizeIsoApp, normalizeIsoApp']\n      rw [normalizeIsoApp_eq X n]\n      rw [normalizeIsoApp_eq Y ‚ü®normalizeObj X n.as‚ü©]\n      rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_tensor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) n) ((CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }) X Y).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C X n) Y).trans (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C Y { as := X.normalizeObj n.as })))","decl":"@[simp]\ntheorem normalizeIsoApp_tensor (X Y : F C) (n : N C) :\n    normalizeIsoApp C (X ‚äó Y) n =\n      (Œ±_ _ _ _).symm ‚â™‚â´ whiskerRightIso (normalizeIsoApp C X n) Y ‚â™‚â´ normalizeIsoApp _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_unitor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n‚ä¢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C CategoryTheory.MonoidalCategoryStruct.tensorUnit n) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }))","decl":"@[simp]\ntheorem normalizeIsoApp_unitor (n : N C) : normalizeIsoApp C (ùüô_ (F C)) n = œÅ_ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_congr","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\n‚ä¢ Eq (X.normalizeObj n) (Y.normalizeObj n)","decl":"theorem normalizeObj_congr (n : NormalMonoidalObject C) {X Y : F C} (f : X ‚ü∂ Y) :\n    normalizeObj X n = normalizeObj Y n := by\n  rcases f with ‚ü®f'‚ü©\n  apply @congr_fun _ _ fun n => normalizeObj X n\n  clear n f\n  induction f' with\n  | comp _ _ _ _ => apply Eq.trans <;> assumption\n  | whiskerLeft  _ _ ih => funext; apply congr_fun ih\n  | whiskerRight _ _ ih => funext; apply congr_arg‚ÇÇ _ rfl (congr_fun ih _)\n  | @tensor W X Y Z _ _ ih‚ÇÅ ih‚ÇÇ =>\n      funext n\n      simp [congr_fun ih‚ÇÅ n, congr_fun ih‚ÇÇ (normalizeObj Y n)]\n  | _ => funext; rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalize_naturality","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.FreeMonoidalCategory.inclusionObj n) f) (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C Y n).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C X n).hom (CategoryTheory.FreeMonoidalCategory.inclusion.map (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem normalize_naturality (n : NormalMonoidalObject C) {X Y : F C} (f : X ‚ü∂ Y) :\n    inclusionObj n ‚óÅ f ‚â´ (normalizeIsoApp' C Y n).hom =\n      (normalizeIsoApp' C X n).hom ‚â´\n        inclusion.map (eqToHom (Discrete.ext (normalizeObj_congr n f))) := by\n  revert n\n  induction f using Hom.inductionOn\n  case comp f g ihf ihg => simp [ihg, reassoc_of% (ihf _)]\n  case whiskerLeft X' X Y f ih =>\n    intro n\n    dsimp only [normalizeObj_tensor, normalizeIsoApp', tensor_eq_tensor, Iso.trans_hom,\n      Iso.symm_hom, whiskerRightIso_hom, Function.comp_apply, inclusion_obj]\n    rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc, ih]\n    simp\n  case whiskerRight X Y h Œ∑' ih =>\n    intro n\n    dsimp only [normalizeObj_tensor, normalizeIsoApp', tensor_eq_tensor, Iso.trans_hom,\n      Iso.symm_hom, whiskerRightIso_hom, Function.comp_apply, inclusion_obj]\n    rw [associator_inv_naturality_middle_assoc, ‚Üê comp_whiskerRight_assoc, ih]\n    have := dcongr_arg (fun x => (normalizeIsoApp' C Œ∑' x).hom) (normalizeObj_congr n h)\n    simp [this]\n  all_goals simp\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.subsingleton_hom","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\n‚ä¢ Quiver.IsThin (CategoryTheory.FreeMonoidalCategory C)","decl":"/-- The monoidal coherence theorem. -/\ninstance subsingleton_hom : Quiver.IsThin (F C) := fun X Y =>\n  ‚ü®fun f g => by\n    have hfg : (fullNormalize C).map f = (fullNormalize C).map g := Subsingleton.elim _ _\n    have hf := NatIso.naturality_2 (fullNormalizeIso.{u} C) f\n    have hg := NatIso.naturality_2 (fullNormalizeIso.{u} C) g\n    exact hf.symm.trans (Eq.trans (by simp only [Functor.comp_map, hfg]) hg)‚ü©\n\n"}
