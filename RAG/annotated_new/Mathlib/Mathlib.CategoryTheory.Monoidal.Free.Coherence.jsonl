{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.unit.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\ninst✝ : SizeOf C\n⊢ Eq (SizeOf.sizeOf CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.unit) 1","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((𝟙_ C) ⊗ X₁) ⊗ X₂) ⊗ ⋯`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject → C → NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.inj","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\na✝³ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na✝² : C\na✝¹ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na✝ : C\nx✝ : Eq (a✝³.tensor a✝²) (a✝¹.tensor a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((𝟙_ C) ⊗ X₁) ⊗ X₂) ⊗ ⋯`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject → C → NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\ninst✝ : SizeOf C\na✝¹ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na✝ : C\n⊢ Eq (SizeOf.sizeOf (a✝¹.tensor a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((𝟙_ C) ⊗ X₁) ⊗ X₂) ⊗ ⋯`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject → C → NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject.tensor.injEq","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\na✝³ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na✝² : C\na✝¹ : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\na✝ : C\n⊢ Eq (Eq (a✝³.tensor a✝²) (a✝¹.tensor a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- We say an object in the free monoidal category is in normal form if it is of the form\n    `(((𝟙_ C) ⊗ X₁) ⊗ X₂) ⊗ ⋯`. -/\ninductive NormalMonoidalObject : Type u\n  | unit : NormalMonoidalObject\n  | tensor : NormalMonoidalObject → C → NormalMonoidalObject\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.instSubsingletonHomCompDiscreteNormalMonoidalObject","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nx y : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Subsingleton (Quiver.Hom x y)","decl":"instance (x y : N C) : Subsingleton (x ⟶ y) := Discrete.instSubsingletonDiscreteHom _ _\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.inclusion_obj","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (CategoryTheory.FreeMonoidalCategory.inclusion.obj X) (CategoryTheory.FreeMonoidalCategory.inclusionObj X.as)","decl":"@[simp]\ntheorem inclusion_obj (X : N C) :\n    inclusion.obj X = inclusionObj X.as :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.inclusion_map","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.FreeMonoidalCategory.inclusion.map f) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem inclusion_map {X Y : N C} (f : X ⟶ Y) :\n    inclusion.map f = eqToHom (congr_arg _ (Discrete.ext (Discrete.eq_of_hom f))) := by\n  rcases f with ⟨⟨⟩⟩\n  cases Discrete.ext (by assumption)\n  apply inclusion.map_id\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_unitor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorUnit.normalizeObj n) n","decl":"@[simp]\ntheorem normalizeObj_unitor (n : NormalMonoidalObject C) : normalizeObj (𝟙_ (F C)) n = n :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_tensor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).normalizeObj n) (Y.normalizeObj (X.normalizeObj n))","decl":"@[simp]\ntheorem normalizeObj_tensor (X Y : F C) (n : NormalMonoidalObject C) :\n    normalizeObj (X ⊗ Y) n = normalizeObj Y (normalizeObj X n) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.tensorFunc_map_app","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (((CategoryTheory.FreeMonoidalCategory.tensorFunc C).map f).app n) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }) f)","decl":"theorem tensorFunc_map_app {X Y : F C} (f : X ⟶ Y) (n) : ((tensorFunc C).map f).app n = _ ◁ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.tensorFunc_obj_map","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nZ : CategoryTheory.FreeMonoidalCategory C\nn n' : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nf : Quiver.Hom n n'\n⊢ Eq (((CategoryTheory.FreeMonoidalCategory.tensorFunc C).obj Z).map f) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.FreeMonoidalCategory.inclusion.map f) Z)","decl":"theorem tensorFunc_obj_map (Z : F C) {n n' : N C} (f : n ⟶ n') :\n    ((tensorFunc C).obj Z).map f = inclusion.map f ▷ Z := by\n  cases n\n  cases n'\n  rcases f with ⟨⟨h⟩⟩\n  dsimp at h\n  subst h\n  simp\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_eq","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX : CategoryTheory.FreeMonoidalCategory C\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C X n) (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C X n.as)","decl":"theorem normalizeIsoApp_eq :\n    ∀ (X : F C) (n : N C), normalizeIsoApp C X n = normalizeIsoApp' C X n.as\n  | of _, _ => rfl\n  | unit, _ => rfl\n  | tensor X Y, n => by\n      rw [normalizeIsoApp, normalizeIsoApp']\n      rw [normalizeIsoApp_eq X n]\n      rw [normalizeIsoApp_eq Y ⟨normalizeObj X n.as⟩]\n      rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_tensor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nX Y : CategoryTheory.FreeMonoidalCategory C\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) n) ((CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }) X Y).symm.trans ((CategoryTheory.MonoidalCategory.whiskerRightIso (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C X n) Y).trans (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C Y { as := X.normalizeObj n.as })))","decl":"@[simp]\ntheorem normalizeIsoApp_tensor (X Y : F C) (n : N C) :\n    normalizeIsoApp C (X ⊗ Y) n =\n      (α_ _ _ _).symm ≪≫ whiskerRightIso (normalizeIsoApp C X n) Y ≪≫ normalizeIsoApp _ _ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeIsoApp_unitor","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : Function.comp CategoryTheory.Discrete CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\n⊢ Eq (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp C CategoryTheory.MonoidalCategoryStruct.tensorUnit n) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (CategoryTheory.FreeMonoidalCategory.inclusion.obj { as := n.as }))","decl":"@[simp]\ntheorem normalizeIsoApp_unitor (n : N C) : normalizeIsoApp C (𝟙_ (F C)) n = ρ_ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalizeObj_congr","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\n⊢ Eq (X.normalizeObj n) (Y.normalizeObj n)","decl":"theorem normalizeObj_congr (n : NormalMonoidalObject C) {X Y : F C} (f : X ⟶ Y) :\n    normalizeObj X n = normalizeObj Y n := by\n  rcases f with ⟨f'⟩\n  apply @congr_fun _ _ fun n => normalizeObj X n\n  clear n f\n  induction f' with\n  | comp _ _ _ _ => apply Eq.trans <;> assumption\n  | whiskerLeft  _ _ ih => funext; apply congr_fun ih\n  | whiskerRight _ _ ih => funext; apply congr_arg₂ _ rfl (congr_fun ih _)\n  | @tensor W X Y Z _ _ ih₁ ih₂ =>\n      funext n\n      simp [congr_fun ih₁ n, congr_fun ih₂ (normalizeObj Y n)]\n  | _ => funext; rfl\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.normalize_naturality","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\nn : CategoryTheory.FreeMonoidalCategory.NormalMonoidalObject C\nX Y : CategoryTheory.FreeMonoidalCategory C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.FreeMonoidalCategory.inclusionObj n) f) (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C Y n).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.FreeMonoidalCategory.normalizeIsoApp' C X n).hom (CategoryTheory.FreeMonoidalCategory.inclusion.map (CategoryTheory.eqToHom ⋯)))","decl":"theorem normalize_naturality (n : NormalMonoidalObject C) {X Y : F C} (f : X ⟶ Y) :\n    inclusionObj n ◁ f ≫ (normalizeIsoApp' C Y n).hom =\n      (normalizeIsoApp' C X n).hom ≫\n        inclusion.map (eqToHom (Discrete.ext (normalizeObj_congr n f))) := by\n  revert n\n  induction f using Hom.inductionOn\n  case comp f g ihf ihg => simp [ihg, reassoc_of% (ihf _)]\n  case whiskerLeft X' X Y f ih =>\n    intro n\n    dsimp only [normalizeObj_tensor, normalizeIsoApp', tensor_eq_tensor, Iso.trans_hom,\n      Iso.symm_hom, whiskerRightIso_hom, Function.comp_apply, inclusion_obj]\n    rw [associator_inv_naturality_right_assoc, whisker_exchange_assoc, ih]\n    simp\n  case whiskerRight X Y h η' ih =>\n    intro n\n    dsimp only [normalizeObj_tensor, normalizeIsoApp', tensor_eq_tensor, Iso.trans_hom,\n      Iso.symm_hom, whiskerRightIso_hom, Function.comp_apply, inclusion_obj]\n    rw [associator_inv_naturality_middle_assoc, ← comp_whiskerRight_assoc, ih]\n    have := dcongr_arg (fun x => (normalizeIsoApp' C η' x).hom) (normalizeObj_congr n h)\n    simp [this]\n  all_goals simp\n\n"}
{"name":"CategoryTheory.FreeMonoidalCategory.subsingleton_hom","module":"Mathlib.CategoryTheory.Monoidal.Free.Coherence","initialProofState":"C : Type u\n⊢ Quiver.IsThin (CategoryTheory.FreeMonoidalCategory C)","decl":"/-- The monoidal coherence theorem. -/\ninstance subsingleton_hom : Quiver.IsThin (F C) := fun X Y =>\n  ⟨fun f g => by\n    have hfg : (fullNormalize C).map f = (fullNormalize C).map g := Subsingleton.elim _ _\n    have hf := NatIso.naturality_2 (fullNormalizeIso.{u} C) f\n    have hg := NatIso.naturality_2 (fullNormalizeIso.{u} C) g\n    exact hf.symm.trans (Eq.trans (by simp only [Functor.comp_map, hfg]) hg)⟩\n\n"}
