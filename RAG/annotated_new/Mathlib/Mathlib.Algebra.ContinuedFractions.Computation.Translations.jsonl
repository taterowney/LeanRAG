{"name":"GenContFract.IntFractPair.stream_zero","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq (GenContFract.IntFractPair.stream v 0) (Option.some (GenContFract.IntFractPair.of v))","decl":"theorem stream_zero (v : K) : IntFractPair.stream v 0 = some (IntFractPair.of v) :=\n  rfl\n\n"}
{"name":"GenContFract.IntFractPair.stream_eq_none_of_fr_eq_zero","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\nifp_n : GenContFract.IntFractPair K\nstream_nth_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\nnth_fr_eq_zero : Eq ifp_n.fr 0\n⊢ Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) Option.none","decl":"theorem stream_eq_none_of_fr_eq_zero {ifp_n : IntFractPair K}\n    (stream_nth_eq : IntFractPair.stream v n = some ifp_n) (nth_fr_eq_zero : ifp_n.fr = 0) :\n    IntFractPair.stream v (n + 1) = none := by\n  obtain ⟨_, fr⟩ := ifp_n\n  change fr = 0 at nth_fr_eq_zero\n  simp [IntFractPair.stream, stream_nth_eq, nth_fr_eq_zero]\n\n"}
{"name":"GenContFract.IntFractPair.succ_nth_stream_eq_none_iff","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Iff (Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) Option.none) (Or (Eq (GenContFract.IntFractPair.stream v n) Option.none) (Exists fun ifp => And (Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp)) (Eq ifp.fr 0)))","decl":"/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of termination.\n-/\ntheorem succ_nth_stream_eq_none_iff :\n    IntFractPair.stream v (n + 1) = none ↔\n      IntFractPair.stream v n = none ∨ ∃ ifp, IntFractPair.stream v n = some ifp ∧ ifp.fr = 0 := by\n  rw [IntFractPair.stream]\n  cases IntFractPair.stream v n <;> simp [imp_false]\n\n"}
{"name":"GenContFract.IntFractPair.succ_nth_stream_eq_some_iff","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\nifp_succ_n : GenContFract.IntFractPair K\n⊢ Iff (Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp_succ_n)) (Exists fun ifp_n => And (Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)) (And (Ne ifp_n.fr 0) (Eq (GenContFract.IntFractPair.of (Inv.inv ifp_n.fr)) ifp_succ_n)))","decl":"/-- Gives a recurrence to compute the `n + 1`th value of the sequence of integer and fractional\nparts of a value in case of non-termination.\n-/\ntheorem succ_nth_stream_eq_some_iff {ifp_succ_n : IntFractPair K} :\n    IntFractPair.stream v (n + 1) = some ifp_succ_n ↔\n      ∃ ifp_n : IntFractPair K,\n        IntFractPair.stream v n = some ifp_n ∧\n          ifp_n.fr ≠ 0 ∧ IntFractPair.of ifp_n.fr⁻¹ = ifp_succ_n := by\n  simp [IntFractPair.stream, ite_eq_iff, Option.bind_eq_some]\n\n"}
{"name":"GenContFract.IntFractPair.stream_succ_of_some","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\np : GenContFract.IntFractPair K\nh : Eq (GenContFract.IntFractPair.stream v n) (Option.some p)\nh' : Ne p.fr 0\n⊢ Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some (GenContFract.IntFractPair.of (Inv.inv p.fr)))","decl":"/-- An easier to use version of one direction of\n`GenContFract.IntFractPair.succ_nth_stream_eq_some_iff`. -/\ntheorem stream_succ_of_some {p : IntFractPair K} (h : IntFractPair.stream v n = some p)\n    (h' : p.fr ≠ 0) : IntFractPair.stream v (n + 1) = some (IntFractPair.of p.fr⁻¹) :=\n  succ_nth_stream_eq_some_iff.mpr ⟨p, h, h', rfl⟩\n\n"}
{"name":"GenContFract.IntFractPair.stream_succ_of_int","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\na : Int\nn : Nat\n⊢ Eq (GenContFract.IntFractPair.stream (↑a) (HAdd.hAdd n 1)) Option.none","decl":"/-- The stream of `IntFractPair`s of an integer stops after the first term.\n-/\ntheorem stream_succ_of_int (a : ℤ) (n : ℕ) : IntFractPair.stream (a : K) (n + 1) = none := by\n  induction n with\n  | zero =>\n    refine IntFractPair.stream_eq_none_of_fr_eq_zero (IntFractPair.stream_zero (a : K)) ?_\n    simp only [IntFractPair.of, Int.fract_intCast]\n  | succ n ih => exact IntFractPair.succ_nth_stream_eq_none_iff.mpr (Or.inl ih)\n\n"}
{"name":"GenContFract.IntFractPair.exists_succ_nth_stream_of_fr_zero","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\nifp_succ_n : GenContFract.IntFractPair K\nstream_succ_nth_eq : Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp_succ_n)\nsucc_nth_fr_eq_zero : Eq ifp_succ_n.fr 0\n⊢ Exists fun ifp_n => And (Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)) (Eq (Inv.inv ifp_n.fr) ↑(Int.floor (Inv.inv ifp_n.fr)))","decl":"theorem exists_succ_nth_stream_of_fr_zero {ifp_succ_n : IntFractPair K}\n    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n)\n    (succ_nth_fr_eq_zero : ifp_succ_n.fr = 0) :\n    ∃ ifp_n : IntFractPair K, IntFractPair.stream v n = some ifp_n ∧ ifp_n.fr⁻¹ = ⌊ifp_n.fr⁻¹⌋ := by\n  -- get the witness from `succ_nth_stream_eq_some_iff` and prove that it has the additional\n  -- properties\n  rcases succ_nth_stream_eq_some_iff.mp stream_succ_nth_eq with\n    ⟨ifp_n, seq_nth_eq, _, rfl⟩\n  refine ⟨ifp_n, seq_nth_eq, ?_⟩\n  simpa only [IntFractPair.of, Int.fract, sub_eq_zero] using succ_nth_fr_eq_zero\n\n"}
{"name":"GenContFract.IntFractPair.stream_succ","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nh : Ne (Int.fract v) 0\nn : Nat\n⊢ Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (GenContFract.IntFractPair.stream (Inv.inv (Int.fract v)) n)","decl":"/-- A recurrence relation that expresses the `(n+1)`th term of the stream of `IntFractPair`s\nof `v` for non-integer `v` in terms of the `n`th term of the stream associated to\nthe inverse of the fractional part of `v`.\n-/\ntheorem stream_succ (h : Int.fract v ≠ 0) (n : ℕ) :\n    IntFractPair.stream v (n + 1) = IntFractPair.stream (Int.fract v)⁻¹ n := by\n  induction n with\n  | zero =>\n    have H : (IntFractPair.of v).fr = Int.fract v := by simp [IntFractPair.of]\n    rw [stream_zero, stream_succ_of_some (stream_zero v) (ne_of_eq_of_ne H h), H]\n  | succ n ih =>\n    rcases eq_or_ne (IntFractPair.stream (Int.fract v)⁻¹ n) none with hnone | hsome\n    · rw [hnone] at ih\n      rw [succ_nth_stream_eq_none_iff.mpr (Or.inl hnone),\n        succ_nth_stream_eq_none_iff.mpr (Or.inl ih)]\n    · obtain ⟨p, hp⟩ := Option.ne_none_iff_exists'.mp hsome\n      rw [hp] at ih\n      rcases eq_or_ne p.fr 0 with hz | hnz\n      · rw [stream_eq_none_of_fr_eq_zero hp hz, stream_eq_none_of_fr_eq_zero ih hz]\n      · rw [stream_succ_of_some hp hnz, stream_succ_of_some ih hnz]\n\n"}
{"name":"GenContFract.IntFractPair.seq1_fst_eq_of","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq (GenContFract.IntFractPair.seq1 v).1 (GenContFract.IntFractPair.of v)","decl":"/-- The head term of the sequence with head of `v` is just the integer part of `v`. -/\n@[simp]\ntheorem IntFractPair.seq1_fst_eq_of : (IntFractPair.seq1 v).fst = IntFractPair.of v :=\n  rfl\n\n"}
{"name":"GenContFract.of_h_eq_intFractPair_seq1_fst_b","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq (GenContFract.of v).h ↑(GenContFract.IntFractPair.seq1 v).1.b","decl":"theorem of_h_eq_intFractPair_seq1_fst_b : (of v).h = (IntFractPair.seq1 v).fst.b := by\n  cases aux_seq_eq : IntFractPair.seq1 v\n  simp [of, aux_seq_eq]\n\n"}
{"name":"GenContFract.of_h_eq_floor","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq (GenContFract.of v).h ↑(Int.floor v)","decl":"/-- The head term of the gcf of `v` is `⌊v⌋`. -/\n@[simp]\ntheorem of_h_eq_floor : (of v).h = ⌊v⌋ := by\n  simp [of_h_eq_intFractPair_seq1_fst_b, IntFractPair.of]\n\n"}
{"name":"GenContFract.IntFractPair.get?_seq1_eq_succ_get?_stream","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Eq ((GenContFract.IntFractPair.seq1 v).2.get? n) (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1))","decl":"theorem IntFractPair.get?_seq1_eq_succ_get?_stream :\n    (IntFractPair.seq1 v).snd.get? n = (IntFractPair.stream v) (n + 1) :=\n  rfl\n\n"}
{"name":"GenContFract.of_terminatedAt_iff_intFractPair_seq1_terminatedAt","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Iff ((GenContFract.of v).TerminatedAt n) ((GenContFract.IntFractPair.seq1 v).2.TerminatedAt n)","decl":"theorem of_terminatedAt_iff_intFractPair_seq1_terminatedAt :\n    (of v).TerminatedAt n ↔ (IntFractPair.seq1 v).snd.TerminatedAt n :=\n  Option.map_eq_none\n\n"}
{"name":"GenContFract.of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Iff ((GenContFract.of v).TerminatedAt n) (Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) Option.none)","decl":"theorem of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none :\n    (of v).TerminatedAt n ↔ IntFractPair.stream v (n + 1) = none := by\n  rw [of_terminatedAt_iff_intFractPair_seq1_terminatedAt, Stream'.Seq.TerminatedAt,\n    IntFractPair.get?_seq1_eq_succ_get?_stream]\n\n"}
{"name":"GenContFract.IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\ngp_n : GenContFract.Pair K\ns_nth_eq : Eq ((GenContFract.of v).s.get? n) (Option.some gp_n)\n⊢ Exists fun ifp => And (Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp)) (Eq (↑ifp.b) gp_n.b)","decl":"theorem IntFractPair.exists_succ_get?_stream_of_gcf_of_get?_eq_some {gp_n : Pair K}\n    (s_nth_eq : (of v).s.get? n = some gp_n) :\n    ∃ ifp : IntFractPair K, IntFractPair.stream v (n + 1) = some ifp ∧ (ifp.b : K) = gp_n.b := by\n  obtain ⟨ifp, stream_succ_nth_eq, gp_n_eq⟩ :\n    ∃ ifp, IntFractPair.stream v (n + 1) = some ifp ∧ Pair.mk 1 (ifp.b : K) = gp_n := by\n    unfold of IntFractPair.seq1 at s_nth_eq\n    simpa [Stream'.Seq.get?_tail, Stream'.Seq.map_get?] using s_nth_eq\n  cases gp_n_eq\n  simp_all only [Option.some.injEq, exists_eq_left']\n\n"}
{"name":"GenContFract.get?_of_eq_some_of_succ_get?_intFractPair_stream","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\nifp_succ_n : GenContFract.IntFractPair K\nstream_succ_nth_eq : Eq (GenContFract.IntFractPair.stream v (HAdd.hAdd n 1)) (Option.some ifp_succ_n)\n⊢ Eq ((GenContFract.of v).s.get? n) (Option.some { a := 1, b := ↑ifp_succ_n.b })","decl":"/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\ninteger parts of the stream of integer and fractional parts.\n-/\ntheorem get?_of_eq_some_of_succ_get?_intFractPair_stream {ifp_succ_n : IntFractPair K}\n    (stream_succ_nth_eq : IntFractPair.stream v (n + 1) = some ifp_succ_n) :\n    (of v).s.get? n = some ⟨1, ifp_succ_n.b⟩ := by\n  unfold of IntFractPair.seq1\n  simp [Stream'.Seq.map_tail, Stream'.Seq.get?_tail, Stream'.Seq.map_get?, stream_succ_nth_eq]\n\n"}
{"name":"GenContFract.get?_of_eq_some_of_get?_intFractPair_stream_fr_ne_zero","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\nifp_n : GenContFract.IntFractPair K\nstream_nth_eq : Eq (GenContFract.IntFractPair.stream v n) (Option.some ifp_n)\nnth_fr_ne_zero : Ne ifp_n.fr 0\n⊢ Eq ((GenContFract.of v).s.get? n) (Option.some { a := 1, b := ↑(GenContFract.IntFractPair.of (Inv.inv ifp_n.fr)).b })","decl":"/-- Shows how the entries of the sequence of the computed continued fraction can be obtained by the\nfractional parts of the stream of integer and fractional parts.\n-/\ntheorem get?_of_eq_some_of_get?_intFractPair_stream_fr_ne_zero {ifp_n : IntFractPair K}\n    (stream_nth_eq : IntFractPair.stream v n = some ifp_n) (nth_fr_ne_zero : ifp_n.fr ≠ 0) :\n    (of v).s.get? n = some ⟨1, (IntFractPair.of ifp_n.fr⁻¹).b⟩ :=\n  have : IntFractPair.stream v (n + 1) = some (IntFractPair.of ifp_n.fr⁻¹) := by\n    cases ifp_n\n    simp only [IntFractPair.stream, Nat.add_eq, add_zero, stream_nth_eq, Option.some_bind,\n      ite_eq_right_iff]\n    intro; contradiction\n  get?_of_eq_some_of_succ_get?_intFractPair_stream this\n\n"}
{"name":"GenContFract.of_s_head_aux","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq ((GenContFract.of v).s.get? 0) ((GenContFract.IntFractPair.stream v 1).bind (Function.comp Option.some fun p => { a := 1, b := ↑p.b }))","decl":"theorem of_s_head_aux (v : K) : (of v).s.get? 0 = (IntFractPair.stream v 1).bind (some ∘ fun p =>\n    { a := 1\n      b := p.b }) := by\n  rw [of, IntFractPair.seq1]\n  simp only [of, Stream'.Seq.map_tail, Stream'.Seq.map, Stream'.Seq.tail, Stream'.Seq.head,\n    Stream'.Seq.get?, Stream'.map]\n  rw [← Stream'.get_succ, Stream'.get, Option.map.eq_def]\n  split <;> simp_all only [Option.some_bind, Option.none_bind, Function.comp_apply]\n\n"}
{"name":"GenContFract.of_s_head","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nh : Ne (Int.fract v) 0\n⊢ Eq (GenContFract.of v).s.head (Option.some { a := 1, b := ↑(Int.floor (Inv.inv (Int.fract v))) })","decl":"/-- This gives the first pair of coefficients of the continued fraction of a non-integer `v`.\n-/\ntheorem of_s_head (h : fract v ≠ 0) : (of v).s.head = some ⟨1, ⌊(fract v)⁻¹⌋⟩ := by\n  change (of v).s.get? 0 = _\n  rw [of_s_head_aux, stream_succ_of_some (stream_zero v) h, Option.bind]\n  rfl\n\n"}
{"name":"GenContFract.of_s_of_int","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\na : Int\n⊢ Eq (GenContFract.of ↑a).s Stream'.Seq.nil","decl":"/-- If `a` is an integer, then the coefficient sequence of its continued fraction is empty.\n-/\ntheorem of_s_of_int (a : ℤ) : (of (a : K)).s = Stream'.Seq.nil :=\n  haveI h : ∀ n, (of (a : K)).s.get? n = none := by\n    intro n\n    induction n with\n    | zero => rw [of_s_head_aux, stream_succ_of_int, Option.bind]\n    | succ n ih => exact (of (a : K)).s.prop ih\n  Stream'.Seq.ext fun n => (h n).trans (Stream'.Seq.get?_nil n).symm\n\n"}
{"name":"GenContFract.of_s_succ","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Eq ((GenContFract.of v).s.get? (HAdd.hAdd n 1)) ((GenContFract.of (Inv.inv (Int.fract v))).s.get? n)","decl":"/-- Recurrence for the `GenContFract.of` an element `v` of `K` in terms of that of the inverse of\nthe fractional part of `v`.\n-/\ntheorem of_s_succ (n : ℕ) : (of v).s.get? (n + 1) = (of (fract v)⁻¹).s.get? n := by\n  rcases eq_or_ne (fract v) 0 with h | h\n  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩\n    rw [fract_intCast, inv_zero, of_s_of_int, ← cast_zero, of_s_of_int,\n      Stream'.Seq.get?_nil, Stream'.Seq.get?_nil]\n  rcases eq_or_ne ((of (fract v)⁻¹).s.get? n) none with h₁ | h₁\n  · rwa [h₁, ← terminatedAt_iff_s_none,\n      of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none, stream_succ h, ←\n      of_terminatedAt_n_iff_succ_nth_intFractPair_stream_eq_none, terminatedAt_iff_s_none]\n  · obtain ⟨p, hp⟩ := Option.ne_none_iff_exists'.mp h₁\n    obtain ⟨p', hp'₁, _⟩ := exists_succ_get?_stream_of_gcf_of_get?_eq_some hp\n    have Hp := get?_of_eq_some_of_succ_get?_intFractPair_stream hp'₁\n    rw [← stream_succ h] at hp'₁\n    rw [Hp, get?_of_eq_some_of_succ_get?_intFractPair_stream hp'₁]\n\n"}
{"name":"GenContFract.of_s_tail","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\n⊢ Eq (GenContFract.of v).s.tail (GenContFract.of (Inv.inv (Int.fract v))).s","decl":"/-- This expresses the tail of the coefficient sequence of the `GenContFract.of` an element `v` of\n`K` as the coefficient sequence of that of the inverse of the fractional part of `v`.\n-/\ntheorem of_s_tail : (of v).s.tail = (of (fract v)⁻¹).s :=\n  Stream'.Seq.ext fun n => Stream'.Seq.get?_tail (of v).s n ▸ of_s_succ v n\n\n"}
{"name":"GenContFract.convs'_of_int","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nn : Nat\na : Int\n⊢ Eq ((GenContFract.of ↑a).convs' n) ↑a","decl":"/-- If `a` is an integer, then the `convs'` of its continued fraction expansion\nare all equal to `a`.\n-/\ntheorem convs'_of_int (a : ℤ) : (of (a : K)).convs' n = a := by\n  induction n with\n  | zero => simp only [zeroth_conv'_eq_h, of_h_eq_floor, floor_intCast]\n  | succ =>\n    rw [convs', of_h_eq_floor, floor_intCast, add_right_eq_self]\n    exact convs'Aux_succ_none ((of_s_of_int K a).symm ▸ Stream'.Seq.get?_nil 0) _\n\n"}
{"name":"GenContFract.convs'_succ","module":"Mathlib.Algebra.ContinuedFractions.Computation.Translations","initialProofState":"K : Type u_1\ninst✝¹ : LinearOrderedField K\ninst✝ : FloorRing K\nv : K\nn : Nat\n⊢ Eq ((GenContFract.of v).convs' (HAdd.hAdd n 1)) (HAdd.hAdd (↑(Int.floor v)) (HDiv.hDiv 1 ((GenContFract.of (Inv.inv (Int.fract v))).convs' n)))","decl":"/-- The recurrence relation for the `convs'` of the continued fraction expansion\nof an element `v` of `K` in terms of the convergents of the inverse of its fractional part.\n-/\ntheorem convs'_succ :\n    (of v).convs' (n + 1) = ⌊v⌋ + 1 / (of (fract v)⁻¹).convs' n := by\n  rcases eq_or_ne (fract v) 0 with h | h\n  · obtain ⟨a, rfl⟩ : ∃ a : ℤ, v = a := ⟨⌊v⌋, eq_of_sub_eq_zero h⟩\n    rw [convs'_of_int, fract_intCast, inv_zero, ← cast_zero, convs'_of_int, cast_zero,\n      div_zero, add_zero, floor_intCast]\n  · rw [convs', of_h_eq_floor, add_right_inj, convs'Aux_succ_some (of_s_head h)]\n    exact congr_arg (1 / ·) (by rw [convs', of_h_eq_floor, add_right_inj, of_s_tail])\n\n"}
