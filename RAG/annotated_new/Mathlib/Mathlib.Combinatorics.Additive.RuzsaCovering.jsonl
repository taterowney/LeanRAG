{"name":"Finset.ruzsa_covering_mul","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Real\ninst✝ : DecidableEq G\nA B : Finset G\nhB : B.Nonempty\nhK : LE.le (↑(HMul.hMul A B).card) (HMul.hMul K ↑B.card)\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑F.card) K) (HasSubset.Subset A (HMul.hMul F (HDiv.hDiv B B))))","decl":"/-- **Ruzsa's covering lemma**. -/\n@[to_additive \"**Ruzsa's covering lemma**\"]\ntheorem ruzsa_covering_mul (hB : B.Nonempty) (hK : #(A * B) ≤ K * #B) :\n    ∃ F ⊆ A, #F ≤ K ∧ A ⊆ F * (B / B) := by\n  haveI : ∀ F, Decidable ((F : Set G).PairwiseDisjoint (· • B)) := fun F ↦ Classical.dec _\n  set C := {F ∈ A.powerset | F.toSet.PairwiseDisjoint (· • B)}\n  obtain ⟨F, hF, hFmax⟩ := C.exists_maximal <| filter_nonempty_iff.2\n    ⟨∅, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_empty⟩\n  rw [mem_filter, mem_powerset] at hF\n  obtain ⟨hFA, hF⟩ := hF\n  refine ⟨F, hFA, le_of_mul_le_mul_right ?_ (by positivity : (0 : ℝ) < #B), fun a ha ↦ ?_⟩\n  · calc\n      (#F * #B : ℝ) = #(F * B) := by\n        rw [card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hF, Nat.cast_mul]\n      _ ≤ #(A * B) := by gcongr\n      _ ≤ K * #B := hK\n  by_cases hau : a ∈ F\n  · exact subset_mul_left _ hB.one_mem_div hau\n  by_cases H : ∀ b ∈ F, Disjoint (a • B) (b • B)\n  · refine (hFmax _ ?_ <| ssubset_insert hau).elim\n    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]\n    exact ⟨⟨ha, hFA⟩, hF.insert fun _ hb _ ↦ H _ hb⟩\n  push_neg at H\n  simp_rw [not_disjoint_iff, ← inv_smul_mem_iff] at H\n  obtain ⟨b, hb, c, hc₁, hc₂⟩ := H\n  exact mem_mul.2 ⟨b, hb, b⁻¹ * a, mem_div.2 ⟨_, hc₂, _, hc₁, by simp⟩, by simp⟩\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Finset.ruzsa_covering_add","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : Real\ninst✝ : DecidableEq G\nA B : Finset G\nhB : B.Nonempty\nhK : LE.le (↑(HAdd.hAdd A B).card) (HMul.hMul K ↑B.card)\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑F.card) K) (HasSubset.Subset A (HAdd.hAdd F (HSub.hSub B B))))","decl":"/-- **Ruzsa's covering lemma**. -/\n@[to_additive \"**Ruzsa's covering lemma**\"]\ntheorem ruzsa_covering_mul (hB : B.Nonempty) (hK : #(A * B) ≤ K * #B) :\n    ∃ F ⊆ A, #F ≤ K ∧ A ⊆ F * (B / B) := by\n  haveI : ∀ F, Decidable ((F : Set G).PairwiseDisjoint (· • B)) := fun F ↦ Classical.dec _\n  set C := {F ∈ A.powerset | F.toSet.PairwiseDisjoint (· • B)}\n  obtain ⟨F, hF, hFmax⟩ := C.exists_maximal <| filter_nonempty_iff.2\n    ⟨∅, empty_mem_powerset _, by rw [coe_empty]; exact Set.pairwiseDisjoint_empty⟩\n  rw [mem_filter, mem_powerset] at hF\n  obtain ⟨hFA, hF⟩ := hF\n  refine ⟨F, hFA, le_of_mul_le_mul_right ?_ (by positivity : (0 : ℝ) < #B), fun a ha ↦ ?_⟩\n  · calc\n      (#F * #B : ℝ) = #(F * B) := by\n        rw [card_mul_iff.2 <| pairwiseDisjoint_smul_iff.1 hF, Nat.cast_mul]\n      _ ≤ #(A * B) := by gcongr\n      _ ≤ K * #B := hK\n  by_cases hau : a ∈ F\n  · exact subset_mul_left _ hB.one_mem_div hau\n  by_cases H : ∀ b ∈ F, Disjoint (a • B) (b • B)\n  · refine (hFmax _ ?_ <| ssubset_insert hau).elim\n    rw [mem_filter, mem_powerset, insert_subset_iff, coe_insert]\n    exact ⟨⟨ha, hFA⟩, hF.insert fun _ hb _ ↦ H _ hb⟩\n  push_neg at H\n  simp_rw [not_disjoint_iff, ← inv_smul_mem_iff] at H\n  obtain ⟨b, hb, c, hc₁, hc₂⟩ := H\n  exact mem_mul.2 ⟨b, hb, b⁻¹ * a, mem_div.2 ⟨_, hc₂, _, hc₁, by simp⟩, by simp⟩\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Finset.exists_subset_mul_div","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Real\ninst✝ : DecidableEq G\nA B : Finset G\nhB : B.Nonempty\nhK : LE.le (↑(HMul.hMul A B).card) (HMul.hMul K ↑B.card)\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑F.card) K) (HasSubset.Subset A (HMul.hMul F (HDiv.hDiv B B))))","decl":"@[to_additive]\nalias exists_subset_mul_div := ruzsa_covering_mul\n"}
{"name":"Finset.exists_subset_add_sub","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : Real\ninst✝ : DecidableEq G\nA B : Finset G\nhB : B.Nonempty\nhK : LE.le (↑(HAdd.hAdd A B).card) (HMul.hMul K ↑B.card)\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑F.card) K) (HasSubset.Subset A (HAdd.hAdd F (HSub.hSub B B))))","decl":"@[to_additive]\nalias exists_subset_mul_div := ruzsa_covering_mul\n"}
{"name":"Set.ruzsa_covering_mul","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Real\nA B : Set G\nhA : A.Finite\nhB : B.Finite\nhB₀ : B.Nonempty\nhK : LE.le (↑(Nat.card ↑(HMul.hMul A B))) (HMul.hMul K ↑(Nat.card ↑B))\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑(Nat.card ↑F)) K) (And (HasSubset.Subset A (HMul.hMul F (HDiv.hDiv B B))) F.Finite))","decl":"/-- **Ruzsa's covering lemma** for sets. See also `Finset.ruzsa_covering_mul`. -/\n@[to_additive \"**Ruzsa's covering lemma** for sets. See also `Finset.ruzsa_covering_add`.\"]\nlemma ruzsa_covering_mul (hA : A.Finite) (hB : B.Finite) (hB₀ : B.Nonempty)\n    (hK : Nat.card (A * B) ≤ K * Nat.card B) :\n    ∃ F ⊆ A, Nat.card F ≤ K ∧ A ⊆ F * (B / B) ∧ F.Finite := by\n  lift A to Finset G using hA\n  lift B to Finset G using hB\n  classical\n  obtain ⟨F, hFA, hF, hAF⟩ := Finset.ruzsa_covering_mul hB₀ (by simpa [← Finset.coe_mul] using hK)\n  exact ⟨F, by norm_cast; simp [*]⟩\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.ruzsa_covering_add","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : Real\nA B : Set G\nhA : A.Finite\nhB : B.Finite\nhB₀ : B.Nonempty\nhK : LE.le (↑(Nat.card ↑(HAdd.hAdd A B))) (HMul.hMul K ↑(Nat.card ↑B))\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑(Nat.card ↑F)) K) (And (HasSubset.Subset A (HAdd.hAdd F (HSub.hSub B B))) F.Finite))","decl":"/-- **Ruzsa's covering lemma** for sets. See also `Finset.ruzsa_covering_mul`. -/\n@[to_additive \"**Ruzsa's covering lemma** for sets. See also `Finset.ruzsa_covering_add`.\"]\nlemma ruzsa_covering_mul (hA : A.Finite) (hB : B.Finite) (hB₀ : B.Nonempty)\n    (hK : Nat.card (A * B) ≤ K * Nat.card B) :\n    ∃ F ⊆ A, Nat.card F ≤ K ∧ A ⊆ F * (B / B) ∧ F.Finite := by\n  lift A to Finset G using hA\n  lift B to Finset G using hB\n  classical\n  obtain ⟨F, hFA, hF, hAF⟩ := Finset.ruzsa_covering_mul hB₀ (by simpa [← Finset.coe_mul] using hK)\n  exact ⟨F, by norm_cast; simp [*]⟩\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Set.exists_subset_mul_div","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Real\nA B : Set G\nhA : A.Finite\nhB : B.Finite\nhB₀ : B.Nonempty\nhK : LE.le (↑(Nat.card ↑(HMul.hMul A B))) (HMul.hMul K ↑(Nat.card ↑B))\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑(Nat.card ↑F)) K) (And (HasSubset.Subset A (HMul.hMul F (HDiv.hDiv B B))) F.Finite))","decl":"@[to_additive]\nalias exists_subset_mul_div := ruzsa_covering_mul\n"}
{"name":"Set.exists_subset_add_sub","module":"Mathlib.Combinatorics.Additive.RuzsaCovering","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nK : Real\nA B : Set G\nhA : A.Finite\nhB : B.Finite\nhB₀ : B.Nonempty\nhK : LE.le (↑(Nat.card ↑(HAdd.hAdd A B))) (HMul.hMul K ↑(Nat.card ↑B))\n⊢ Exists fun F => And (HasSubset.Subset F A) (And (LE.le (↑(Nat.card ↑F)) K) (And (HasSubset.Subset A (HAdd.hAdd F (HSub.hSub B B))) F.Finite))","decl":"@[to_additive]\nalias exists_subset_mul_div := ruzsa_covering_mul\n"}
