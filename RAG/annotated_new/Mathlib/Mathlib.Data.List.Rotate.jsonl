{"name":"List.rotate_mod","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate (HMod.hMod n l.length)) (l.rotate n)","decl":"theorem rotate_mod (l : List α) (n : ℕ) : l.rotate (n % l.length) = l.rotate n := by simp [rotate]\n\n"}
{"name":"List.rotate_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (List.nil.rotate n) List.nil","decl":"@[simp]\ntheorem rotate_nil (n : ℕ) : ([] : List α).rotate n = [] := by simp [rotate]\n\n"}
{"name":"List.rotate_zero","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq (l.rotate 0) l","decl":"@[simp]\ntheorem rotate_zero (l : List α) : l.rotate 0 = l := by simp [rotate]\n\n"}
{"name":"List.rotate'_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (List.nil.rotate' n) List.nil","decl":"theorem rotate'_nil (n : ℕ) : ([] : List α).rotate' n = [] := by simp\n\n"}
{"name":"List.rotate'_zero","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq (l.rotate' 0) l","decl":"@[simp]\ntheorem rotate'_zero (l : List α) : l.rotate' 0 = l := by cases l <;> rfl\n\n"}
{"name":"List.rotate'_cons_succ","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\na : α\nn : Nat\n⊢ Eq ((List.cons a l).rotate' n.succ) ((HAppend.hAppend l (List.cons a List.nil)).rotate' n)","decl":"theorem rotate'_cons_succ (l : List α) (a : α) (n : ℕ) :\n    (a :: l : List α).rotate' n.succ = (l ++ [a]).rotate' n := by simp [rotate']\n\n"}
{"name":"List.length_rotate'","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate' n).length l.length","decl":"@[simp]\ntheorem length_rotate' : ∀ (l : List α) (n : ℕ), (l.rotate' n).length = l.length\n  | [], _ => by simp\n  | _ :: _, 0 => rfl\n  | a :: l, n + 1 => by rw [List.rotate', length_rotate' (l ++ [a]) n]; simp\n\n"}
{"name":"List.rotate'_eq_drop_append_take","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\na✝ : LE.le n l.length\n⊢ Eq (l.rotate' n) (HAppend.hAppend (List.drop n l) (List.take n l))","decl":"theorem rotate'_eq_drop_append_take :\n    ∀ {l : List α} {n : ℕ}, n ≤ l.length → l.rotate' n = l.drop n ++ l.take n\n  | [], n, h => by simp [drop_append_of_le_length h]\n  | l, 0, h => by simp [take_append_of_le_length h]\n  | a :: l, n + 1, h => by\n    have hnl : n ≤ l.length := le_of_succ_le_succ h\n    have hnl' : n ≤ (l ++ [a]).length := by\n      rw [length_append, length_cons, List.length]; exact le_of_succ_le h\n    rw [rotate'_cons_succ, rotate'_eq_drop_append_take hnl', drop, take,\n        drop_append_of_le_length hnl, take_append_of_le_length hnl]; simp\n\n"}
{"name":"List.rotate'_rotate'","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn m : Nat\n⊢ Eq ((l.rotate' n).rotate' m) (l.rotate' (HAdd.hAdd n m))","decl":"theorem rotate'_rotate' : ∀ (l : List α) (n m : ℕ), (l.rotate' n).rotate' m = l.rotate' (n + m)\n  | a :: l, 0, m => by simp\n  | [], n, m => by simp\n  | a :: l, n + 1, m => by\n    rw [rotate'_cons_succ, rotate'_rotate' _ n, Nat.add_right_comm, ← rotate'_cons_succ,\n      Nat.succ_eq_add_one]\n\n"}
{"name":"List.rotate'_length","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq (l.rotate' l.length) l","decl":"@[simp]\ntheorem rotate'_length (l : List α) : rotate' l l.length = l := by\n  rw [rotate'_eq_drop_append_take le_rfl]; simp\n\n"}
{"name":"List.rotate'_length_mul","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate' (HMul.hMul l.length n)) l","decl":"@[simp]\ntheorem rotate'_length_mul (l : List α) : ∀ n : ℕ, l.rotate' (l.length * n) = l\n  | 0 => by simp\n  | n + 1 =>\n    calc\n      l.rotate' (l.length * (n + 1)) =\n          (l.rotate' (l.length * n)).rotate' (l.rotate' (l.length * n)).length := by\n        simp [-rotate'_length, Nat.mul_succ, rotate'_rotate']\n      _ = l := by rw [rotate'_length, rotate'_length_mul l n]\n\n"}
{"name":"List.rotate'_mod","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate' (HMod.hMod n l.length)) (l.rotate' n)","decl":"theorem rotate'_mod (l : List α) (n : ℕ) : l.rotate' (n % l.length) = l.rotate' n :=\n  calc\n    l.rotate' (n % l.length) =\n        (l.rotate' (n % l.length)).rotate' ((l.rotate' (n % l.length)).length * (n / l.length)) :=\n      by rw [rotate'_length_mul]\n    _ = l.rotate' n := by rw [rotate'_rotate', length_rotate', Nat.mod_add_div]\n\n"}
{"name":"List.rotate_eq_rotate'","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate n) (l.rotate' n)","decl":"theorem rotate_eq_rotate' (l : List α) (n : ℕ) : l.rotate n = l.rotate' n :=\n  if h : l.length = 0 then by simp_all [length_eq_zero]\n  else by\n    rw [← rotate'_mod,\n        rotate'_eq_drop_append_take (le_of_lt (Nat.mod_lt _ (Nat.pos_of_ne_zero h)))]\n    simp [rotate]\n\n"}
{"name":"List.rotate_cons_succ","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\na : α\nn : Nat\n⊢ Eq ((List.cons a l).rotate (HAdd.hAdd n 1)) ((HAppend.hAppend l (List.cons a List.nil)).rotate n)","decl":"@[simp] theorem rotate_cons_succ (l : List α) (a : α) (n : ℕ) :\n    (a :: l : List α).rotate (n + 1) = (l ++ [a]).rotate n := by\n  rw [rotate_eq_rotate', rotate_eq_rotate', rotate'_cons_succ]\n\n"}
{"name":"List.mem_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\na : α\nn : Nat\n⊢ Iff (Membership.mem (l.rotate n) a) (Membership.mem l a)","decl":"@[simp]\ntheorem mem_rotate : ∀ {l : List α} {a : α} {n : ℕ}, a ∈ l.rotate n ↔ a ∈ l\n  | [], _, n => by simp\n  | a :: l, _, 0 => by simp\n  | a :: l, _, n + 1 => by simp [rotate_cons_succ, mem_rotate, or_comm]\n\n"}
{"name":"List.length_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate n).length l.length","decl":"@[simp]\ntheorem length_rotate (l : List α) (n : ℕ) : (l.rotate n).length = l.length := by\n  rw [rotate_eq_rotate', length_rotate']\n\n"}
{"name":"List.rotate_replicate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\na : α\nn k : Nat\n⊢ Eq ((List.replicate n a).rotate k) (List.replicate n a)","decl":"@[simp]\ntheorem rotate_replicate (a : α) (n : ℕ) (k : ℕ) : (replicate n a).rotate k = replicate n a :=\n  eq_replicate_iff.2 ⟨by rw [length_rotate, length_replicate], fun b hb =>\n    eq_of_mem_replicate <| mem_rotate.1 hb⟩\n\n"}
{"name":"List.rotate_eq_drop_append_take","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\na✝ : LE.le n l.length\n⊢ Eq (l.rotate n) (HAppend.hAppend (List.drop n l) (List.take n l))","decl":"theorem rotate_eq_drop_append_take {l : List α} {n : ℕ} :\n    n ≤ l.length → l.rotate n = l.drop n ++ l.take n := by\n  rw [rotate_eq_rotate']; exact rotate'_eq_drop_append_take\n\n"}
{"name":"List.rotate_eq_drop_append_take_mod","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate n) (HAppend.hAppend (List.drop (HMod.hMod n l.length) l) (List.take (HMod.hMod n l.length) l))","decl":"theorem rotate_eq_drop_append_take_mod {l : List α} {n : ℕ} :\n    l.rotate n = l.drop (n % l.length) ++ l.take (n % l.length) := by\n  rcases l.length.zero_le.eq_or_lt with hl | hl\n  · simp [eq_nil_of_length_eq_zero hl.symm]\n  rw [← rotate_eq_drop_append_take (n.mod_lt hl).le, rotate_mod]\n\n"}
{"name":"List.rotate_append_length_eq","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Eq ((HAppend.hAppend l l').rotate l.length) (HAppend.hAppend l' l)","decl":"@[simp]\ntheorem rotate_append_length_eq (l l' : List α) : (l ++ l').rotate l.length = l' ++ l := by\n  rw [rotate_eq_rotate']\n  induction l generalizing l'\n  · simp\n  · simp_all [rotate']\n\n"}
{"name":"List.rotate_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn m : Nat\n⊢ Eq ((l.rotate n).rotate m) (l.rotate (HAdd.hAdd n m))","decl":"theorem rotate_rotate (l : List α) (n m : ℕ) : (l.rotate n).rotate m = l.rotate (n + m) := by\n  rw [rotate_eq_rotate', rotate_eq_rotate', rotate_eq_rotate', rotate'_rotate']\n\n"}
{"name":"List.rotate_length","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq (l.rotate l.length) l","decl":"@[simp]\ntheorem rotate_length (l : List α) : rotate l l.length = l := by\n  rw [rotate_eq_rotate', rotate'_length]\n\n"}
{"name":"List.rotate_length_mul","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate (HMul.hMul l.length n)) l","decl":"@[simp]\ntheorem rotate_length_mul (l : List α) (n : ℕ) : l.rotate (l.length * n) = l := by\n  rw [rotate_eq_rotate', rotate'_length_mul]\n\n"}
{"name":"List.rotate_perm","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ (l.rotate n).Perm l","decl":"theorem rotate_perm (l : List α) (n : ℕ) : l.rotate n ~ l := by\n  rw [rotate_eq_rotate']\n  induction' n with n hn generalizing l\n  · simp\n  · cases' l with hd tl\n    · simp\n    · rw [rotate'_cons_succ]\n      exact (hn _).trans (perm_append_singleton _ _)\n\n"}
{"name":"List.nodup_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Iff (l.rotate n).Nodup l.Nodup","decl":"@[simp]\ntheorem nodup_rotate {l : List α} {n : ℕ} : Nodup (l.rotate n) ↔ Nodup l :=\n  (rotate_perm l n).nodup_iff\n\n"}
{"name":"List.rotate_eq_nil_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Iff (Eq (l.rotate n) List.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem rotate_eq_nil_iff {l : List α} {n : ℕ} : l.rotate n = [] ↔ l = [] := by\n  induction' n with n hn generalizing l\n  · simp\n  · cases' l with hd tl\n    · simp\n    · simp [rotate_cons_succ, hn]\n\n"}
{"name":"List.nil_eq_rotate_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Iff (Eq List.nil (l.rotate n)) (Eq List.nil l)","decl":"theorem nil_eq_rotate_iff {l : List α} {n : ℕ} : [] = l.rotate n ↔ [] = l := by\n  rw [eq_comm, rotate_eq_nil_iff, eq_comm]\n\n"}
{"name":"List.rotate_singleton","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nx : α\nn : Nat\n⊢ Eq ((List.cons x List.nil).rotate n) (List.cons x List.nil)","decl":"@[simp]\ntheorem rotate_singleton (x : α) (n : ℕ) : [x].rotate n = [x] :=\n  rotate_replicate x 1 n\n\n"}
{"name":"List.zipWith_rotate_distrib","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β → γ\nl : List α\nl' : List β\nn : Nat\nh : Eq l.length l'.length\n⊢ Eq ((List.zipWith f l l').rotate n) (List.zipWith f (l.rotate n) (l'.rotate n))","decl":"theorem zipWith_rotate_distrib {β γ : Type*} (f : α → β → γ) (l : List α) (l' : List β) (n : ℕ)\n    (h : l.length = l'.length) :\n    (zipWith f l l').rotate n = zipWith f (l.rotate n) (l'.rotate n) := by\n  rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod,\n    rotate_eq_drop_append_take_mod, h, zipWith_append, ← drop_zipWith, ←\n    take_zipWith, List.length_zipWith, h, min_self]\n  rw [length_drop, length_drop, h]\n\n"}
{"name":"List.zipWith_rotate_one","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nβ : Type u_1\nf : α → α → β\nx y : α\nl : List α\n⊢ Eq (List.zipWith f (List.cons x (List.cons y l)) ((List.cons x (List.cons y l)).rotate 1)) (List.cons (f x y) (List.zipWith f (List.cons y l) (HAppend.hAppend l (List.cons x List.nil))))","decl":"theorem zipWith_rotate_one {β : Type*} (f : α → α → β) (x y : α) (l : List α) :\n    zipWith f (x :: y :: l) ((x :: y :: l).rotate 1) = f x y :: zipWith f (y :: l) (l ++ [x]) := by\n  simp\n\n"}
{"name":"List.getElem?_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn m : Nat\nhml : LT.lt m l.length\n⊢ Eq (GetElem?.getElem? (l.rotate n) m) (GetElem?.getElem? l (HMod.hMod (HAdd.hAdd m n) l.length))","decl":"theorem getElem?_rotate {l : List α} {n m : ℕ} (hml : m < l.length) :\n    (l.rotate n)[m]? = l[(m + n) % l.length]? := by\n  rw [rotate_eq_drop_append_take_mod]\n  rcases lt_or_le m (l.drop (n % l.length)).length with hm | hm\n  · rw [getElem?_append_left hm, getElem?_drop, ← add_mod_mod]\n    rw [length_drop, Nat.lt_sub_iff_add_lt] at hm\n    rw [mod_eq_of_lt hm, Nat.add_comm]\n  · have hlt : n % length l < length l := mod_lt _ (m.zero_le.trans_lt hml)\n    rw [getElem?_append_right hm, getElem?_take_of_lt, length_drop]\n    · congr 1\n      rw [length_drop] at hm\n      have hm' := Nat.sub_le_iff_le_add'.1 hm\n      have : n % length l + m - length l < length l := by\n        rw [Nat.sub_lt_iff_lt_add' hm']\n        exact Nat.add_lt_add hlt hml\n      conv_rhs => rw [Nat.add_comm m, ← mod_add_mod, mod_eq_sub_mod hm', mod_eq_of_lt this]\n      omega\n    · rwa [Nat.sub_lt_iff_lt_add hm, length_drop, Nat.sub_add_cancel hlt.le]\n\n"}
{"name":"List.getElem_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn k : Nat\nh : LT.lt k (l.rotate n).length\n⊢ Eq (GetElem.getElem (l.rotate n) k ⋯) (GetElem.getElem l (HMod.hMod (HAdd.hAdd k n) l.length) ⋯)","decl":"theorem getElem_rotate (l : List α) (n : ℕ) (k : Nat) (h : k < (l.rotate n).length) :\n    (l.rotate n)[k] =\n      l[(k + n) % l.length]'(mod_lt _ (length_rotate l n ▸ k.zero_le.trans_lt h)) := by\n  rw [← Option.some_inj, ← getElem?_eq_getElem, ← getElem?_eq_getElem, getElem?_rotate]\n  exact h.trans_eq (length_rotate _ _)\n\n"}
{"name":"List.get?_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn m : Nat\nhml : LT.lt m l.length\n⊢ Eq ((l.rotate n).get? m) (l.get? (HMod.hMod (HAdd.hAdd m n) l.length))","decl":"theorem get?_rotate {l : List α} {n m : ℕ} (hml : m < l.length) :\n    (l.rotate n).get? m = l.get? ((m + n) % l.length) := by\n  simp only [get?_eq_getElem?, length_rotate, hml, getElem?_eq_getElem, getElem_rotate]\n  rw [← getElem?_eq_getElem]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10756): new lemma\n"}
{"name":"List.get_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nk : Fin (l.rotate n).length\n⊢ Eq ((l.rotate n).get k) (l.get ⟨HMod.hMod (HAdd.hAdd (↑k) n) l.length, ⋯⟩)","decl":"theorem get_rotate (l : List α) (n : ℕ) (k : Fin (l.rotate n).length) :\n    (l.rotate n).get k = l.get ⟨(k + n) % l.length, mod_lt _ (length_rotate l n ▸ k.pos)⟩ := by\n  simp [getElem_rotate]\n\n"}
{"name":"List.head?_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nh : LT.lt n l.length\n⊢ Eq (l.rotate n).head? (GetElem?.getElem? l n)","decl":"theorem head?_rotate {l : List α} {n : ℕ} (h : n < l.length) : head? (l.rotate n) = l[n]? := by\n  rw [← get?_zero, get?_rotate (n.zero_le.trans_lt h), Nat.zero_add, Nat.mod_eq_of_lt h,\n    get?_eq_getElem?]\n\n"}
{"name":"List.get_rotate_one","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nk : Fin (l.rotate 1).length\n⊢ Eq ((l.rotate 1).get k) (l.get ⟨HMod.hMod (HAdd.hAdd (↑k) 1) l.length, ⋯⟩)","decl":"theorem get_rotate_one (l : List α) (k : Fin (l.rotate 1).length) :\n    (l.rotate 1).get k = l.get ⟨(k + 1) % l.length, mod_lt _ (length_rotate l 1 ▸ k.pos)⟩ :=\n  get_rotate l 1 k\n\n"}
{"name":"List.nthLe_rotate_one","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nk : Fin (l.rotate 1).length\n⊢ Eq ((l.rotate 1).get k) (l.get ⟨HMod.hMod (HAdd.hAdd (↑k) 1) l.length, ⋯⟩)","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_rotate_one := get_rotate_one\n\n"}
{"name":"List.get_eq_get_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nk : Fin l.length\n⊢ Eq (l.get k) ((l.rotate n).get ⟨HMod.hMod (HAdd.hAdd (HSub.hSub l.length (HMod.hMod n l.length)) ↑k) l.length, ⋯⟩)","decl":"/-- A version of `List.get_rotate` that represents `List.get l` in terms of\n`List.get (List.rotate l n)`, not vice versa. Can be used instead of rewriting `List.get_rotate`\nfrom right to left. -/\ntheorem get_eq_get_rotate (l : List α) (n : ℕ) (k : Fin l.length) :\n    l.get k = (l.rotate n).get ⟨(l.length - n % l.length + k) % l.length,\n      (Nat.mod_lt _ (k.1.zero_le.trans_lt k.2)).trans_eq (length_rotate _ _).symm⟩ := by\n  rw [get_rotate]\n  refine congr_arg l.get (Fin.eq_of_val_eq ?_)\n  simp only [mod_add_mod]\n  rw [← add_mod_mod, Nat.add_right_comm, Nat.sub_add_cancel, add_mod_left, mod_eq_of_lt]\n  exacts [k.2, (mod_lt _ (k.1.zero_le.trans_lt k.2)).le]\n\n"}
{"name":"List.rotate_eq_self_iff_eq_replicate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nhα : Nonempty α\nl : List α\n⊢ Iff (∀ (n : Nat), Eq (l.rotate n) l) (Exists fun a => Eq l (List.replicate l.length a))","decl":"theorem rotate_eq_self_iff_eq_replicate [hα : Nonempty α] :\n    ∀ {l : List α}, (∀ n, l.rotate n = l) ↔ ∃ a, l = replicate l.length a\n  | [] => by simp\n  | a :: l => ⟨fun h => ⟨a, ext_getElem (length_replicate _ _).symm fun n h₁ h₂ => by\n      rw [getElem_replicate, ← Option.some_inj, ← getElem?_eq_getElem, ← head?_rotate h₁, h,\n        head?_cons]⟩,\n    fun ⟨b, hb⟩ n => by rw [hb, rotate_replicate]⟩\n\n"}
{"name":"List.rotate_one_eq_self_iff_eq_replicate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\ninst✝ : Nonempty α\nl : List α\n⊢ Iff (Eq (l.rotate 1) l) (Exists fun a => Eq l (List.replicate l.length a))","decl":"theorem rotate_one_eq_self_iff_eq_replicate [Nonempty α] {l : List α} :\n    l.rotate 1 = l ↔ ∃ a : α, l = List.replicate l.length a :=\n  ⟨fun h =>\n    rotate_eq_self_iff_eq_replicate.mp fun n =>\n      Nat.rec l.rotate_zero (fun n hn => by rwa [Nat.succ_eq_add_one, ← l.rotate_rotate, hn]) n,\n    fun h => rotate_eq_self_iff_eq_replicate.mpr h 1⟩\n\n"}
{"name":"List.rotate_injective","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nn : Nat\n⊢ Function.Injective fun l => l.rotate n","decl":"theorem rotate_injective (n : ℕ) : Function.Injective fun l : List α => l.rotate n := by\n  rintro l l' (h : l.rotate n = l'.rotate n)\n  have hle : l.length = l'.length := (l.length_rotate n).symm.trans (h.symm ▸ l'.length_rotate n)\n  rw [rotate_eq_drop_append_take_mod, rotate_eq_drop_append_take_mod] at h\n  obtain ⟨hd, ht⟩ := append_inj h (by simp_all)\n  rw [← take_append_drop _ l, ht, hd, take_append_drop]\n\n"}
{"name":"List.rotate_eq_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nn : Nat\n⊢ Iff (Eq (l.rotate n) (l'.rotate n)) (Eq l l')","decl":"@[simp]\ntheorem rotate_eq_rotate {l l' : List α} {n : ℕ} : l.rotate n = l'.rotate n ↔ l = l' :=\n  (rotate_injective n).eq_iff\n\n"}
{"name":"List.rotate_eq_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nn : Nat\n⊢ Iff (Eq (l.rotate n) l') (Eq l (l'.rotate (HSub.hSub l'.length (HMod.hMod n l'.length))))","decl":"theorem rotate_eq_iff {l l' : List α} {n : ℕ} :\n    l.rotate n = l' ↔ l = l'.rotate (l'.length - n % l'.length) := by\n  rw [← @rotate_eq_rotate _ l _ n, rotate_rotate, ← rotate_mod l', add_mod]\n  rcases l'.length.zero_le.eq_or_lt with hl | hl\n  · rw [eq_nil_of_length_eq_zero hl.symm, rotate_nil]\n  · rcases (Nat.zero_le (n % l'.length)).eq_or_lt with hn | hn\n    · simp [← hn]\n    · rw [mod_eq_of_lt (Nat.sub_lt hl hn), Nat.sub_add_cancel, mod_self, rotate_zero]\n      exact (Nat.mod_lt _ hl).le\n\n"}
{"name":"List.rotate_eq_singleton_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nx : α\n⊢ Iff (Eq (l.rotate n) (List.cons x List.nil)) (Eq l (List.cons x List.nil))","decl":"@[simp]\ntheorem rotate_eq_singleton_iff {l : List α} {n : ℕ} {x : α} : l.rotate n = [x] ↔ l = [x] := by\n  rw [rotate_eq_iff, rotate_singleton]\n\n"}
{"name":"List.singleton_eq_rotate_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nx : α\n⊢ Iff (Eq (List.cons x List.nil) (l.rotate n)) (Eq (List.cons x List.nil) l)","decl":"@[simp]\ntheorem singleton_eq_rotate_iff {l : List α} {n : ℕ} {x : α} : [x] = l.rotate n ↔ [x] = l := by\n  rw [eq_comm, rotate_eq_singleton_iff, eq_comm]\n\n"}
{"name":"List.reverse_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.rotate n).reverse (l.reverse.rotate (HSub.hSub l.length (HMod.hMod n l.length)))","decl":"theorem reverse_rotate (l : List α) (n : ℕ) :\n    (l.rotate n).reverse = l.reverse.rotate (l.length - n % l.length) := by\n  rw [← length_reverse l, ← rotate_eq_iff]\n  induction' n with n hn generalizing l\n  · simp\n  · cases' l with hd tl\n    · simp\n    · rw [rotate_cons_succ, ← rotate_rotate, hn]\n      simp\n\n"}
{"name":"List.rotate_reverse","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ Eq (l.reverse.rotate n) (l.rotate (HSub.hSub l.length (HMod.hMod n l.length))).reverse","decl":"theorem rotate_reverse (l : List α) (n : ℕ) :\n    l.reverse.rotate n = (l.rotate (l.length - n % l.length)).reverse := by\n  rw [← reverse_reverse l]\n  simp_rw [reverse_rotate, reverse_reverse, rotate_eq_iff, rotate_rotate, length_rotate,\n    length_reverse]\n  rw [← length_reverse l]\n  let k := n % l.reverse.length\n  cases' hk' : k with k'\n  · simp_all! [k, length_reverse, ← rotate_rotate]\n  · cases' l with x l\n    · simp\n    · rw [Nat.mod_eq_of_lt, Nat.sub_add_cancel, rotate_length]\n      · exact Nat.sub_le _ _\n      · exact Nat.sub_lt (by simp) (by simp_all! [k])\n\n"}
{"name":"List.map_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nβ : Type u_1\nf : α → β\nl : List α\nn : Nat\n⊢ Eq (List.map f (l.rotate n)) ((List.map f l).rotate n)","decl":"theorem map_rotate {β : Type*} (f : α → β) (l : List α) (n : ℕ) :\n    map f (l.rotate n) = (map f l).rotate n := by\n  induction' n with n hn IH generalizing l\n  · simp\n  · cases' l with hd tl\n    · simp\n    · simp [hn]\n\n"}
{"name":"List.Nodup.rotate_congr","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nhl : l.Nodup\nhn : Ne l List.nil\ni j : Nat\nh : Eq (l.rotate i) (l.rotate j)\n⊢ Eq (HMod.hMod i l.length) (HMod.hMod j l.length)","decl":"theorem Nodup.rotate_congr {l : List α} (hl : l.Nodup) (hn : l ≠ []) (i j : ℕ)\n    (h : l.rotate i = l.rotate j) : i % l.length = j % l.length := by\n  rw [← rotate_mod l i, ← rotate_mod l j] at h\n  simpa only [head?_rotate, mod_lt, length_pos_of_ne_nil hn, getElem?_eq_getElem, Option.some_inj,\n    hl.getElem_inj_iff, Fin.ext_iff] using congr_arg head? h\n\n"}
{"name":"List.Nodup.rotate_congr_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nhl : l.Nodup\ni j : Nat\n⊢ Iff (Eq (l.rotate i) (l.rotate j)) (Or (Eq (HMod.hMod i l.length) (HMod.hMod j l.length)) (Eq l List.nil))","decl":"theorem Nodup.rotate_congr_iff {l : List α} (hl : l.Nodup) {i j : ℕ} :\n    l.rotate i = l.rotate j ↔ i % l.length = j % l.length ∨ l = [] := by\n  rcases eq_or_ne l [] with rfl | hn\n  · simp\n  · simp only [hn, or_false]\n    refine ⟨hl.rotate_congr hn _ _, fun h ↦ ?_⟩\n    rw [← rotate_mod, h, rotate_mod]\n\n"}
{"name":"List.Nodup.rotate_eq_self_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nhl : l.Nodup\nn : Nat\n⊢ Iff (Eq (l.rotate n) l) (Or (Eq (HMod.hMod n l.length) 0) (Eq l List.nil))","decl":"theorem Nodup.rotate_eq_self_iff {l : List α} (hl : l.Nodup) {n : ℕ} :\n    l.rotate n = l ↔ n % l.length = 0 ∨ l = [] := by\n  rw [← zero_mod, ← hl.rotate_congr_iff, rotate_zero]\n\n"}
{"name":"List.IsRotated.refl","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ l.IsRotated l","decl":"@[refl]\ntheorem IsRotated.refl (l : List α) : l ~r l :=\n  ⟨0, by simp⟩\n\n"}
{"name":"List.IsRotated.symm","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\n⊢ l'.IsRotated l","decl":"@[symm]\ntheorem IsRotated.symm (h : l ~r l') : l' ~r l := by\n  obtain ⟨n, rfl⟩ := h\n  cases' l with hd tl\n  · exists 0\n  · use (hd :: tl).length * n - n\n    rw [rotate_rotate, Nat.add_sub_cancel', rotate_length_mul]\n    exact Nat.le_mul_of_pos_left _ (by simp)\n\n"}
{"name":"List.isRotated_comm","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.IsRotated l') (l'.IsRotated l)","decl":"theorem isRotated_comm : l ~r l' ↔ l' ~r l :=\n  ⟨IsRotated.symm, IsRotated.symm⟩\n\n"}
{"name":"List.IsRotated.forall","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\n⊢ (l.rotate n).IsRotated l","decl":"@[simp]\nprotected theorem IsRotated.forall (l : List α) (n : ℕ) : l.rotate n ~r l :=\n  IsRotated.symm ⟨n, rfl⟩\n\n"}
{"name":"List.IsRotated.trans","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' l'' : List α\na✝¹ : l.IsRotated l'\na✝ : l'.IsRotated l''\n⊢ l.IsRotated l''","decl":"@[trans]\ntheorem IsRotated.trans : ∀ {l l' l'' : List α}, l ~r l' → l' ~r l'' → l ~r l''\n  | _, _, _, ⟨n, rfl⟩, ⟨m, rfl⟩ => ⟨n + m, by rw [rotate_rotate]⟩\n\n"}
{"name":"List.IsRotated.eqv","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\n⊢ Equivalence List.IsRotated","decl":"theorem IsRotated.eqv : Equivalence (@IsRotated α) :=\n  Equivalence.mk IsRotated.refl IsRotated.symm IsRotated.trans\n\n"}
{"name":"List.IsRotated.perm","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\n⊢ l.Perm l'","decl":"theorem IsRotated.perm (h : l ~r l') : l ~ l' :=\n  Exists.elim h fun _ hl => hl ▸ (rotate_perm _ _).symm\n\n"}
{"name":"List.IsRotated.nodup_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\n⊢ Iff l.Nodup l'.Nodup","decl":"theorem IsRotated.nodup_iff (h : l ~r l') : Nodup l ↔ Nodup l' :=\n  h.perm.nodup_iff\n\n"}
{"name":"List.IsRotated.mem_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\na : α\n⊢ Iff (Membership.mem l a) (Membership.mem l' a)","decl":"theorem IsRotated.mem_iff (h : l ~r l') {a : α} : a ∈ l ↔ a ∈ l' :=\n  h.perm.mem_iff\n\n"}
{"name":"List.isRotated_nil_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Iff (l.IsRotated List.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem isRotated_nil_iff : l ~r [] ↔ l = [] :=\n  ⟨fun ⟨n, hn⟩ => by simpa using hn, fun h => h ▸ by rfl⟩\n\n"}
{"name":"List.isRotated_nil_iff'","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Iff (List.nil.IsRotated l) (Eq List.nil l)","decl":"@[simp]\ntheorem isRotated_nil_iff' : [] ~r l ↔ [] = l := by\n  rw [isRotated_comm, isRotated_nil_iff, eq_comm]\n\n"}
{"name":"List.isRotated_singleton_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nx : α\n⊢ Iff (l.IsRotated (List.cons x List.nil)) (Eq l (List.cons x List.nil))","decl":"@[simp]\ntheorem isRotated_singleton_iff {x : α} : l ~r [x] ↔ l = [x] :=\n  ⟨fun ⟨n, hn⟩ => by simpa using hn, fun h => h ▸ by rfl⟩\n\n"}
{"name":"List.isRotated_singleton_iff'","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nx : α\n⊢ Iff ((List.cons x List.nil).IsRotated l) (Eq (List.cons x List.nil) l)","decl":"@[simp]\ntheorem isRotated_singleton_iff' {x : α} : [x] ~r l ↔ [x] = l := by\n  rw [isRotated_comm, isRotated_singleton_iff, eq_comm]\n\n"}
{"name":"List.isRotated_concat","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nhd : α\ntl : List α\n⊢ (HAppend.hAppend tl (List.cons hd List.nil)).IsRotated (List.cons hd tl)","decl":"theorem isRotated_concat (hd : α) (tl : List α) : (tl ++ [hd]) ~r (hd :: tl) :=\n  IsRotated.symm ⟨1, by simp⟩\n\n"}
{"name":"List.isRotated_append","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ (HAppend.hAppend l l').IsRotated (HAppend.hAppend l' l)","decl":"theorem isRotated_append : (l ++ l') ~r (l' ++ l) :=\n  ⟨l.length, by simp⟩\n\n"}
{"name":"List.IsRotated.reverse","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\n⊢ l.reverse.IsRotated l'.reverse","decl":"theorem IsRotated.reverse (h : l ~r l') : l.reverse ~r l'.reverse := by\n  obtain ⟨n, rfl⟩ := h\n  exact ⟨_, (reverse_rotate _ _).symm⟩\n\n"}
{"name":"List.isRotated_reverse_comm_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.reverse.IsRotated l') (l.IsRotated l'.reverse)","decl":"theorem isRotated_reverse_comm_iff : l.reverse ~r l' ↔ l ~r l'.reverse := by\n  constructor <;>\n    · intro h\n      simpa using h.reverse\n\n"}
{"name":"List.isRotated_reverse_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.reverse.IsRotated l'.reverse) (l.IsRotated l')","decl":"@[simp]\ntheorem isRotated_reverse_iff : l.reverse ~r l'.reverse ↔ l ~r l' := by\n  simp [isRotated_reverse_comm_iff]\n\n"}
{"name":"List.isRotated_iff_mod","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.IsRotated l') (Exists fun n => And (LE.le n l.length) (Eq (l.rotate n) l'))","decl":"theorem isRotated_iff_mod : l ~r l' ↔ ∃ n ≤ l.length, l.rotate n = l' := by\n  refine ⟨fun h => ?_, fun ⟨n, _, h⟩ => ⟨n, h⟩⟩\n  obtain ⟨n, rfl⟩ := h\n  cases' l with hd tl\n  · simp\n  · refine ⟨n % (hd :: tl).length, ?_, rotate_mod _ _⟩\n    refine (Nat.mod_lt _ ?_).le\n    simp\n\n"}
{"name":"List.isRotated_iff_mem_map_range","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.IsRotated l') (Membership.mem (List.map l.rotate (List.range (HAdd.hAdd l.length 1))) l')","decl":"theorem isRotated_iff_mem_map_range : l ~r l' ↔ l' ∈ (List.range (l.length + 1)).map l.rotate := by\n  simp_rw [mem_map, mem_range, isRotated_iff_mod]\n  exact\n    ⟨fun ⟨n, hn, h⟩ => ⟨n, Nat.lt_succ_of_le hn, h⟩,\n      fun ⟨n, hn, h⟩ => ⟨n, Nat.le_of_lt_succ hn, h⟩⟩\n\n-- Porting note: @[congr] only works for equality.\n-- @[congr]\n"}
{"name":"List.IsRotated.map","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nβ : Type u_1\nl₁ l₂ : List α\nh : l₁.IsRotated l₂\nf : α → β\n⊢ (List.map f l₁).IsRotated (List.map f l₂)","decl":"theorem IsRotated.map {β : Type*} {l₁ l₂ : List α} (h : l₁ ~r l₂) (f : α → β) :\n    map f l₁ ~r map f l₂ := by\n  obtain ⟨n, rfl⟩ := h\n  rw [map_rotate]\n  use n\n\n"}
{"name":"List.IsRotated.cons_getLast_dropLast","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nL : List α\nhL : Ne L List.nil\n⊢ (List.cons (L.getLast hL) L.dropLast).IsRotated L","decl":"theorem IsRotated.cons_getLast_dropLast\n    (L : List α) (hL : L ≠ []) : L.getLast hL :: L.dropLast ~r L := by\n  induction L using List.reverseRecOn with\n  | nil => simp at hL\n  | append_singleton a L _ =>\n    simp only [getLast_append, dropLast_concat]\n    apply IsRotated.symm\n    apply isRotated_concat\n\n"}
{"name":"List.IsRotated.dropLast_tail","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u_1\nL : List α\nhL : Ne L List.nil\nhL' : Eq (L.head hL) (L.getLast hL)\n⊢ L.dropLast.IsRotated L.tail","decl":"theorem IsRotated.dropLast_tail {α}\n    {L : List α} (hL : L ≠ []) (hL' : L.head hL = L.getLast hL) : L.dropLast ~r L.tail :=\n  match L with\n  | [] => by simp\n  | [_] => by simp\n  | a :: b :: L => by\n    simp only [head_cons, ne_eq, reduceCtorEq, not_false_eq_true, getLast_cons] at hL'\n    simp [hL', IsRotated.cons_getLast_dropLast]\n\n"}
{"name":"List.cyclicPermutations_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\n⊢ Eq List.nil.cyclicPermutations (List.cons List.nil List.nil)","decl":"@[simp]\ntheorem cyclicPermutations_nil : cyclicPermutations ([] : List α) = [[]] :=\n  rfl\n\n"}
{"name":"List.cyclicPermutations_cons","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nx : α\nl : List α\n⊢ Eq (List.cons x l).cyclicPermutations (List.zipWith (fun x1 x2 => HAppend.hAppend x1 x2) (List.cons x l).tails (List.cons x l).inits).dropLast","decl":"theorem cyclicPermutations_cons (x : α) (l : List α) :\n    cyclicPermutations (x :: l) = dropLast (zipWith (· ++ ·) (tails (x :: l)) (inits (x :: l))) :=\n  rfl\n\n"}
{"name":"List.cyclicPermutations_of_ne_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq l.cyclicPermutations (List.zipWith (fun x1 x2 => HAppend.hAppend x1 x2) l.tails l.inits).dropLast","decl":"theorem cyclicPermutations_of_ne_nil (l : List α) (h : l ≠ []) :\n    cyclicPermutations l = dropLast (zipWith (· ++ ·) (tails l) (inits l)) := by\n  obtain ⟨hd, tl, rfl⟩ := exists_cons_of_ne_nil h\n  exact cyclicPermutations_cons _ _\n\n"}
{"name":"List.length_cyclicPermutations_cons","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nx : α\nl : List α\n⊢ Eq (List.cons x l).cyclicPermutations.length (HAdd.hAdd l.length 1)","decl":"theorem length_cyclicPermutations_cons (x : α) (l : List α) :\n    length (cyclicPermutations (x :: l)) = length l + 1 := by simp [cyclicPermutations_cons]\n\n"}
{"name":"List.length_cyclicPermutations_of_ne_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nh : Ne l List.nil\n⊢ Eq l.cyclicPermutations.length l.length","decl":"@[simp]\ntheorem length_cyclicPermutations_of_ne_nil (l : List α) (h : l ≠ []) :\n    length (cyclicPermutations l) = length l := by simp [cyclicPermutations_of_ne_nil _ h]\n\n"}
{"name":"List.cyclicPermutations_ne_nil","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Ne l.cyclicPermutations List.nil","decl":"@[simp]\ntheorem cyclicPermutations_ne_nil : ∀ l : List α, cyclicPermutations l ≠ []\n  | a::l, h => by simpa using congr_arg length h\n\n"}
{"name":"List.getElem_cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Nat\nh : LT.lt n l.cyclicPermutations.length\n⊢ Eq (GetElem.getElem l.cyclicPermutations n ⋯) (l.rotate n)","decl":"@[simp]\ntheorem getElem_cyclicPermutations (l : List α) (n : Nat) (h : n < length (cyclicPermutations l)) :\n    (cyclicPermutations l)[n] = l.rotate n := by\n  cases l with\n  | nil => simp\n  | cons a l =>\n    simp only [cyclicPermutations_cons, getElem_dropLast, getElem_zipWith, getElem_tails,\n      getElem_inits]\n    rw [rotate_eq_drop_append_take (by simpa using h.le)]\n\n"}
{"name":"List.get_cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nn : Fin l.cyclicPermutations.length\n⊢ Eq (l.cyclicPermutations.get n) (l.rotate ↑n)","decl":"theorem get_cyclicPermutations (l : List α) (n : Fin (length (cyclicPermutations l))) :\n    (cyclicPermutations l).get n = l.rotate n := by\n  simp\n\n"}
{"name":"List.head_cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq (l.cyclicPermutations.head ⋯) l","decl":"@[simp]\ntheorem head_cyclicPermutations (l : List α) :\n    (cyclicPermutations l).head (cyclicPermutations_ne_nil l) = l := by\n  have h : 0 < length (cyclicPermutations l) := length_pos_of_ne_nil (cyclicPermutations_ne_nil _)\n  rw [← get_mk_zero h, get_cyclicPermutations, Fin.val_mk, rotate_zero]\n\n"}
{"name":"List.head?_cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Eq l.cyclicPermutations.head? (Option.some l)","decl":"@[simp]\ntheorem head?_cyclicPermutations (l : List α) : (cyclicPermutations l).head? = l := by\n  rw [head?_eq_head, head_cyclicPermutations]\n\n"}
{"name":"List.cyclicPermutations_injective","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\n⊢ Function.Injective List.cyclicPermutations","decl":"theorem cyclicPermutations_injective : Function.Injective (@cyclicPermutations α) := fun l l' h ↦ by\n  simpa using congr_arg head? h\n\n"}
{"name":"List.cyclicPermutations_inj","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (Eq l.cyclicPermutations l'.cyclicPermutations) (Eq l l')","decl":"@[simp]\ntheorem cyclicPermutations_inj {l l' : List α} :\n    cyclicPermutations l = cyclicPermutations l' ↔ l = l' :=\n  cyclicPermutations_injective.eq_iff\n\n"}
{"name":"List.length_mem_cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl' l : List α\nh : Membership.mem l.cyclicPermutations l'\n⊢ Eq l'.length l.length","decl":"theorem length_mem_cyclicPermutations (l : List α) (h : l' ∈ cyclicPermutations l) :\n    length l' = length l := by\n  obtain ⟨k, hk, rfl⟩ := get_of_mem h\n  simp\n\n"}
{"name":"List.mem_cyclicPermutations_self","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Membership.mem l.cyclicPermutations l","decl":"theorem mem_cyclicPermutations_self (l : List α) : l ∈ cyclicPermutations l := by\n  simpa using head_mem (cyclicPermutations_ne_nil l)\n\n"}
{"name":"List.cyclicPermutations_rotate","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nk : Nat\n⊢ Eq (l.rotate k).cyclicPermutations (l.cyclicPermutations.rotate k)","decl":"@[simp]\ntheorem cyclicPermutations_rotate (l : List α) (k : ℕ) :\n    (l.rotate k).cyclicPermutations = l.cyclicPermutations.rotate k := by\n  have : (l.rotate k).cyclicPermutations.length = length (l.cyclicPermutations.rotate k) := by\n    cases l\n    · simp\n    · rw [length_cyclicPermutations_of_ne_nil] <;> simp\n  refine ext_get this fun n hn hn' => ?_\n  rw [get_rotate, get_cyclicPermutations, rotate_rotate, ← rotate_mod, Nat.add_comm]\n  cases l <;> simp\n\n"}
{"name":"List.mem_cyclicPermutations_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (Membership.mem l'.cyclicPermutations l) (l.IsRotated l')","decl":"@[simp]\ntheorem mem_cyclicPermutations_iff : l ∈ cyclicPermutations l' ↔ l ~r l' := by\n  constructor\n  · simp_rw [mem_iff_get, get_cyclicPermutations]\n    rintro ⟨k, rfl⟩\n    exact .forall _ _\n  · rintro ⟨k, rfl⟩\n    rw [cyclicPermutations_rotate, mem_rotate]\n    apply mem_cyclicPermutations_self\n\n"}
{"name":"List.cyclicPermutations_eq_nil_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\n⊢ Iff (Eq l.cyclicPermutations (List.cons List.nil List.nil)) (Eq l List.nil)","decl":"@[simp]\ntheorem cyclicPermutations_eq_nil_iff {l : List α} : cyclicPermutations l = [[]] ↔ l = [] :=\n  cyclicPermutations_injective.eq_iff' rfl\n\n"}
{"name":"List.cyclicPermutations_eq_singleton_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nx : α\n⊢ Iff (Eq l.cyclicPermutations (List.cons (List.cons x List.nil) List.nil)) (Eq l (List.cons x List.nil))","decl":"@[simp]\ntheorem cyclicPermutations_eq_singleton_iff {l : List α} {x : α} :\n    cyclicPermutations l = [[x]] ↔ l = [x] :=\n  cyclicPermutations_injective.eq_iff' rfl\n\n"}
{"name":"List.Nodup.cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl : List α\nhn : l.Nodup\n⊢ l.cyclicPermutations.Nodup","decl":"/-- If a `l : List α` is `Nodup l`, then all of its cyclic permutants are distinct. -/\nprotected theorem Nodup.cyclicPermutations {l : List α} (hn : Nodup l) :\n    Nodup (cyclicPermutations l) := by\n  rcases eq_or_ne l [] with rfl | hl\n  · simp\n  · rw [nodup_iff_injective_get]\n    rintro ⟨i, hi⟩ ⟨j, hj⟩ h\n    simp only [length_cyclicPermutations_of_ne_nil l hl] at hi hj\n    simpa [hn.rotate_congr_iff, mod_eq_of_lt, *] using h\n\n"}
{"name":"List.IsRotated.cyclicPermutations","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\nh : l.IsRotated l'\n⊢ l.cyclicPermutations.IsRotated l'.cyclicPermutations","decl":"protected theorem IsRotated.cyclicPermutations {l l' : List α} (h : l ~r l') :\n    l.cyclicPermutations ~r l'.cyclicPermutations := by\n  obtain ⟨k, rfl⟩ := h\n  exact ⟨k, by simp⟩\n\n"}
{"name":"List.isRotated_cyclicPermutations_iff","module":"Mathlib.Data.List.Rotate","initialProofState":"α : Type u\nl l' : List α\n⊢ Iff (l.cyclicPermutations.IsRotated l'.cyclicPermutations) (l.IsRotated l')","decl":"@[simp]\ntheorem isRotated_cyclicPermutations_iff {l l' : List α} :\n    l.cyclicPermutations ~r l'.cyclicPermutations ↔ l ~r l' := by\n  simp only [IsRotated, ← cyclicPermutations_rotate, cyclicPermutations_inj]\n\n"}
