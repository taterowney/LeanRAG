{"name":"HomologicalComplex.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ninst‚úù¬π : SizeOf Œπ\ninst‚úù : SizeOf V\nX : Œπ ‚Üí V\nd : (i j : Œπ) ‚Üí Quiver.Hom (X i) (X j)\nshape : autoParam (‚àÄ (i j : Œπ), Not (c.Rel i j) ‚Üí Eq (d i j) 0) _auto‚úù\nd_comp_d' : autoParam (‚àÄ (i j k : Œπ), c.Rel i j ‚Üí c.Rel j k ‚Üí Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }) 1","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape Œπ`\nhas chain groups `X i` (objects in `V`) indexed by `i : Œπ`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : Œπ`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ‚â´ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape Œπ) where\n  X : Œπ ‚Üí V\n  d : ‚àÄ i j, X i ‚ü∂ X j\n  shape : ‚àÄ i j, ¬¨c.Rel i j ‚Üí d i j = 0 := by aesop_cat\n  d_comp_d' : ‚àÄ i j k, c.Rel i j ‚Üí c.Rel j k ‚Üí d i j ‚â´ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.mk.inj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nX‚úù : Œπ ‚Üí V\nd‚úù : (i j : Œπ) ‚Üí Quiver.Hom (X‚úù i) (X‚úù j)\nshape‚úù : autoParam (‚àÄ (i j : Œπ), Not (c.Rel i j) ‚Üí Eq (d‚úù i j) 0) _auto‚úù\nd_comp_d'‚úù : autoParam (‚àÄ (i j k : Œπ), c.Rel i j ‚Üí c.Rel j k ‚Üí Eq (CategoryTheory.CategoryStruct.comp (d‚úù i j) (d‚úù j k)) 0) _auto‚úù\nX : Œπ ‚Üí V\nd : (i j : Œπ) ‚Üí Quiver.Hom (X i) (X j)\nshape : autoParam (‚àÄ (i j : Œπ), Not (c.Rel i j) ‚Üí Eq (d i j) 0) _auto‚úù\nd_comp_d' : autoParam (‚àÄ (i j k : Œπ), c.Rel i j ‚Üí c.Rel j k ‚Üí Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto‚úù\nx‚úù : Eq { X := X‚úù, d := d‚úù, shape := shape‚úù, d_comp_d' := d_comp_d'‚úù } { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }\n‚ä¢ And (Eq X‚úù X) (HEq d‚úù d)","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape Œπ`\nhas chain groups `X i` (objects in `V`) indexed by `i : Œπ`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : Œπ`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ‚â´ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape Œπ) where\n  X : Œπ ‚Üí V\n  d : ‚àÄ i j, X i ‚ü∂ X j\n  shape : ‚àÄ i j, ¬¨c.Rel i j ‚Üí d i j = 0 := by aesop_cat\n  d_comp_d' : ‚àÄ i j k, c.Rel i j ‚Üí c.Rel j k ‚Üí d i j ‚â´ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.d_comp_d'","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nself : HomologicalComplex V c\ni j k : Œπ\na‚úù¬π : c.Rel i j\na‚úù : c.Rel j k\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.d i j) (self.d j k)) 0","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape Œπ`\nhas chain groups `X i` (objects in `V`) indexed by `i : Œπ`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : Œπ`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ‚â´ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape Œπ) where\n  X : Œπ ‚Üí V\n  d : ‚àÄ i j, X i ‚ü∂ X j\n  shape : ‚àÄ i j, ¬¨c.Rel i j ‚Üí d i j = 0 := by aesop_cat\n  d_comp_d' : ‚àÄ i j k, c.Rel i j ‚Üí c.Rel j k ‚Üí d i j ‚â´ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.mk.injEq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nX‚úù : Œπ ‚Üí V\nd‚úù : (i j : Œπ) ‚Üí Quiver.Hom (X‚úù i) (X‚úù j)\nshape‚úù : autoParam (‚àÄ (i j : Œπ), Not (c.Rel i j) ‚Üí Eq (d‚úù i j) 0) _auto‚úù\nd_comp_d'‚úù : autoParam (‚àÄ (i j k : Œπ), c.Rel i j ‚Üí c.Rel j k ‚Üí Eq (CategoryTheory.CategoryStruct.comp (d‚úù i j) (d‚úù j k)) 0) _auto‚úù\nX : Œπ ‚Üí V\nd : (i j : Œπ) ‚Üí Quiver.Hom (X i) (X j)\nshape : autoParam (‚àÄ (i j : Œπ), Not (c.Rel i j) ‚Üí Eq (d i j) 0) _auto‚úù\nd_comp_d' : autoParam (‚àÄ (i j k : Œπ), c.Rel i j ‚Üí c.Rel j k ‚Üí Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto‚úù\n‚ä¢ Eq (Eq { X := X‚úù, d := d‚úù, shape := shape‚úù, d_comp_d' := d_comp_d'‚úù } { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }) (And (Eq X‚úù X) (HEq d‚úù d))","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape Œπ`\nhas chain groups `X i` (objects in `V`) indexed by `i : Œπ`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : Œπ`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ‚â´ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape Œπ) where\n  X : Œπ ‚Üí V\n  d : ‚àÄ i j, X i ‚ü∂ X j\n  shape : ‚àÄ i j, ¬¨c.Rel i j ‚Üí d i j = 0 := by aesop_cat\n  d_comp_d' : ‚àÄ i j k, c.Rel i j ‚Üí c.Rel j k ‚Üí d i j ‚â´ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.shape","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nself : HomologicalComplex V c\ni j : Œπ\na‚úù : Not (c.Rel i j)\n‚ä¢ Eq (self.d i j) 0","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape Œπ`\nhas chain groups `X i` (objects in `V`) indexed by `i : Œπ`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : Œπ`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ‚â´ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape Œπ) where\n  X : Œπ ‚Üí V\n  d : ‚àÄ i j, X i ‚ü∂ X j\n  shape : ‚àÄ i j, ¬¨c.Rel i j ‚Üí d i j = 0 := by aesop_cat\n  d_comp_d' : ‚àÄ i j k, c.Rel i j ‚Üí c.Rel j k ‚Üí d i j ‚â´ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.d_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j k : Œπ\nZ : V\nh : Quiver.Hom (C.X k) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j) (CategoryTheory.CategoryStruct.comp (C.d j k) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem d_comp_d (C : HomologicalComplex V c) (i j k : Œπ) : C.d i j ‚â´ C.d j k = 0 := by\n  by_cases hij : c.Rel i j\n  ¬∑ by_cases hjk : c.Rel j k\n    ¬∑ exact C.d_comp_d' i j k hij hjk\n    ¬∑ rw [C.shape j k hjk, comp_zero]\n  ¬∑ rw [C.shape i j hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.d_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j k : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j) (C.d j k)) 0","decl":"@[reassoc (attr := simp)]\ntheorem d_comp_d (C : HomologicalComplex V c) (i j k : Œπ) : C.d i j ‚â´ C.d j k = 0 := by\n  by_cases hij : c.Rel i j\n  ¬∑ by_cases hjk : c.Rel j k\n    ¬∑ exact C.d_comp_d' i j k hij hjk\n    ¬∑ rw [C.shape j k hjk, comp_zero]\n  ¬∑ rw [C.shape i j hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nh_X : Eq C‚ÇÅ.X C‚ÇÇ.X\nh_d : ‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.d i j) (CategoryTheory.eqToHom ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (C‚ÇÇ.d i j))\n‚ä¢ Eq C‚ÇÅ C‚ÇÇ","decl":"theorem ext {C‚ÇÅ C‚ÇÇ : HomologicalComplex V c} (h_X : C‚ÇÅ.X = C‚ÇÇ.X)\n    (h_d :\n      ‚àÄ i j : Œπ,\n        c.Rel i j ‚Üí C‚ÇÅ.d i j ‚â´ eqToHom (congr_fun h_X j) = eqToHom (congr_fun h_X i) ‚â´ C‚ÇÇ.d i j) :\n    C‚ÇÅ = C‚ÇÇ := by\n  obtain ‚ü®X‚ÇÅ, d‚ÇÅ, s‚ÇÅ, h‚ÇÅ‚ü© := C‚ÇÅ\n  obtain ‚ü®X‚ÇÇ, d‚ÇÇ, s‚ÇÇ, h‚ÇÇ‚ü© := C‚ÇÇ\n  dsimp at h_X\n  subst h_X\n  simp only [mk.injEq, heq_eq_eq, true_and]\n  ext i j\n  by_cases hij : c.Rel i j\n  ¬∑ simpa only [comp_id, id_comp, eqToHom_refl] using h_d i j hij\n  ¬∑ rw [s‚ÇÅ i j hij, s‚ÇÇ i j hij]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_rfl","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np : Œπ\n‚ä¢ Eq (K.XIsoOfEq ‚ãØ) (CategoryTheory.Iso.refl (K.X p))","decl":"@[simp]\nlemma XIsoOfEq_rfl (K : HomologicalComplex V c) (p : Œπ) :\n    K.XIsoOfEq (rfl : p = p) = Iso.refl _ := rfl\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÅ‚ÇÇ : Eq p‚ÇÅ p‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq p‚ÇÇ p‚ÇÉ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ‚ãØ).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÅ‚ÇÇ : p‚ÇÅ = p‚ÇÇ) (h‚ÇÇ‚ÇÉ : p‚ÇÇ = p‚ÇÉ) :\n    (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom ‚â´ (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom = (K.XIsoOfEq (h‚ÇÅ‚ÇÇ.trans h‚ÇÇ‚ÇÉ)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÅ‚ÇÇ : Eq p‚ÇÅ p‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq p‚ÇÇ p‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom) (K.XIsoOfEq ‚ãØ).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÅ‚ÇÇ : p‚ÇÅ = p‚ÇÇ) (h‚ÇÇ‚ÇÉ : p‚ÇÇ = p‚ÇÉ) :\n    (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom ‚â´ (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom = (K.XIsoOfEq (h‚ÇÅ‚ÇÇ.trans h‚ÇÇ‚ÇÉ)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÅ‚ÇÇ : Eq p‚ÇÅ p‚ÇÇ\nh‚ÇÉ‚ÇÇ : Eq p‚ÇÉ p‚ÇÇ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ‚ãØ).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÅ‚ÇÇ : p‚ÇÅ = p‚ÇÇ) (h‚ÇÉ‚ÇÇ : p‚ÇÉ = p‚ÇÇ) :\n    (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom ‚â´ (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv = (K.XIsoOfEq (h‚ÇÅ‚ÇÇ.trans h‚ÇÉ‚ÇÇ.symm)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÅ‚ÇÇ : Eq p‚ÇÅ p‚ÇÇ\nh‚ÇÉ‚ÇÇ : Eq p‚ÇÉ p‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv) (K.XIsoOfEq ‚ãØ).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÅ‚ÇÇ : p‚ÇÅ = p‚ÇÇ) (h‚ÇÉ‚ÇÇ : p‚ÇÉ = p‚ÇÇ) :\n    (K.XIsoOfEq h‚ÇÅ‚ÇÇ).hom ‚â´ (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv = (K.XIsoOfEq (h‚ÇÅ‚ÇÇ.trans h‚ÇÉ‚ÇÇ.symm)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÇ‚ÇÅ : Eq p‚ÇÇ p‚ÇÅ\nh‚ÇÇ‚ÇÉ : Eq p‚ÇÇ p‚ÇÉ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ‚ãØ).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÇ‚ÇÅ : p‚ÇÇ = p‚ÇÅ) (h‚ÇÇ‚ÇÉ : p‚ÇÇ = p‚ÇÉ) :\n    (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv ‚â´ (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom = (K.XIsoOfEq (h‚ÇÇ‚ÇÅ.symm.trans h‚ÇÇ‚ÇÉ)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÇ‚ÇÅ : Eq p‚ÇÇ p‚ÇÅ\nh‚ÇÇ‚ÇÉ : Eq p‚ÇÇ p‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom) (K.XIsoOfEq ‚ãØ).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÇ‚ÇÅ : p‚ÇÇ = p‚ÇÅ) (h‚ÇÇ‚ÇÉ : p‚ÇÇ = p‚ÇÉ) :\n    (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv ‚â´ (K.XIsoOfEq h‚ÇÇ‚ÇÉ).hom = (K.XIsoOfEq (h‚ÇÇ‚ÇÅ.symm.trans h‚ÇÇ‚ÇÉ)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÇ‚ÇÅ : Eq p‚ÇÇ p‚ÇÅ\nh‚ÇÉ‚ÇÇ : Eq p‚ÇÉ p‚ÇÇ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ‚ãØ).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÇ‚ÇÅ : p‚ÇÇ = p‚ÇÅ) (h‚ÇÉ‚ÇÇ : p‚ÇÉ = p‚ÇÇ) :\n    (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv ‚â´ (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv = (K.XIsoOfEq (h‚ÇÉ‚ÇÇ.trans h‚ÇÇ‚ÇÅ).symm).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ\nh‚ÇÇ‚ÇÅ : Eq p‚ÇÇ p‚ÇÅ\nh‚ÇÉ‚ÇÇ : Eq p‚ÇÉ p‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv) (K.XIsoOfEq ‚ãØ).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ p‚ÇÉ : Œπ}\n    (h‚ÇÇ‚ÇÅ : p‚ÇÇ = p‚ÇÅ) (h‚ÇÉ‚ÇÇ : p‚ÇÉ = p‚ÇÇ) :\n    (K.XIsoOfEq h‚ÇÇ‚ÇÅ).inv ‚â´ (K.XIsoOfEq h‚ÇÉ‚ÇÇ).inv = (K.XIsoOfEq (h‚ÇÉ‚ÇÇ.trans h‚ÇÇ‚ÇÅ).symm).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ : Œπ\nh : Eq p‚ÇÅ p‚ÇÇ\np‚ÇÉ : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).hom (K.d p‚ÇÇ p‚ÇÉ)) (K.d p‚ÇÅ p‚ÇÉ)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_d (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ : Œπ} (h : p‚ÇÅ = p‚ÇÇ) (p‚ÇÉ : Œπ) :\n    (K.XIsoOfEq h).hom ‚â´ K.d p‚ÇÇ p‚ÇÉ = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÅ p‚ÇÇ : Œπ\nh‚úù : Eq p‚ÇÅ p‚ÇÇ\np‚ÇÉ : Œπ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).hom (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÇ p‚ÇÉ) h)) (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÉ) h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_d (K : HomologicalComplex V c) {p‚ÇÅ p‚ÇÇ : Œπ} (h : p‚ÇÅ = p‚ÇÇ) (p‚ÇÉ : Œπ) :\n    (K.XIsoOfEq h).hom ‚â´ K.d p‚ÇÇ p‚ÇÉ = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÅ : Œπ\nh : Eq p‚ÇÇ p‚ÇÅ\np‚ÇÉ : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).inv (K.d p‚ÇÇ p‚ÇÉ)) (K.d p‚ÇÅ p‚ÇÉ)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_d (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÅ : Œπ} (h : p‚ÇÇ = p‚ÇÅ) (p‚ÇÉ : Œπ) :\n    (K.XIsoOfEq h).inv ‚â´ K.d p‚ÇÇ p‚ÇÉ = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÅ : Œπ\nh‚úù : Eq p‚ÇÇ p‚ÇÅ\np‚ÇÉ : Œπ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).inv (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÇ p‚ÇÉ) h)) (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÉ) h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_d (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÅ : Œπ} (h : p‚ÇÇ = p‚ÇÅ) (p‚ÇÉ : Œπ) :\n    (K.XIsoOfEq h).inv ‚â´ K.d p‚ÇÇ p‚ÇÉ = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÉ : Œπ\nh‚úù : Eq p‚ÇÇ p‚ÇÉ\np‚ÇÅ : Œπ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÇ) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).hom h)) (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÉ) h)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÉ : Œπ} (h : p‚ÇÇ = p‚ÇÉ) (p‚ÇÅ : Œπ) :\n    K.d p‚ÇÅ p‚ÇÇ ‚â´ (K.XIsoOfEq h).hom = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÉ : Œπ\nh : Eq p‚ÇÇ p‚ÇÉ\np‚ÇÅ : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÇ) (K.XIsoOfEq h).hom) (K.d p‚ÇÅ p‚ÇÉ)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÉ : Œπ} (h : p‚ÇÇ = p‚ÇÉ) (p‚ÇÅ : Œπ) :\n    K.d p‚ÇÅ p‚ÇÇ ‚â´ (K.XIsoOfEq h).hom = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÉ : Œπ\nh‚úù : Eq p‚ÇÉ p‚ÇÇ\np‚ÇÅ : Œπ\nZ : V\nh : Quiver.Hom (K.X p‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÇ) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).inv h)) (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÉ) h)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÉ : Œπ} (h : p‚ÇÉ = p‚ÇÇ) (p‚ÇÅ : Œπ) :\n    K.d p‚ÇÅ p‚ÇÇ ‚â´ (K.XIsoOfEq h).inv = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK : HomologicalComplex V c\np‚ÇÇ p‚ÇÉ : Œπ\nh : Eq p‚ÇÉ p‚ÇÇ\np‚ÇÅ : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.d p‚ÇÅ p‚ÇÇ) (K.XIsoOfEq h).inv) (K.d p‚ÇÅ p‚ÇÉ)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p‚ÇÇ p‚ÇÉ : Œπ} (h : p‚ÇÉ = p‚ÇÇ) (p‚ÇÅ : Œπ) :\n    K.d p‚ÇÅ p‚ÇÇ ‚â´ (K.XIsoOfEq h).inv = K.d p‚ÇÅ p‚ÇÉ := by subst h; simp\n\n"}
{"name":"ChainComplex.prev","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : AddRightCancelSemigroup Œ±\ninst‚úù : One Œ±\ni : Œ±\n‚ä¢ Eq ((ComplexShape.down Œ±).prev i) (HAdd.hAdd i 1)","decl":"@[simp]\ntheorem prev (Œ± : Type*) [AddRightCancelSemigroup Œ±] [One Œ±] (i : Œ±) :\n    (ComplexShape.down Œ±).prev i = i + 1 :=\n  (ComplexShape.down Œ±).prev_eq' rfl\n\n"}
{"name":"ChainComplex.next","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : One Œ±\ni : Œ±\n‚ä¢ Eq ((ComplexShape.down Œ±).next i) (HSub.hSub i 1)","decl":"@[simp]\ntheorem next (Œ± : Type*) [AddGroup Œ±] [One Œ±] (i : Œ±) : (ComplexShape.down Œ±).next i = i - 1 :=\n  (ComplexShape.down Œ±).next_eq' <| sub_add_cancel _ _\n\n"}
{"name":"ChainComplex.next_nat_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"‚ä¢ Eq ((ComplexShape.down Nat).next 0) 0","decl":"@[simp]\ntheorem next_nat_zero : (ComplexShape.down ‚Ñï).next 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n\n"}
{"name":"ChainComplex.next_nat_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"i : Nat\n‚ä¢ Eq ((ComplexShape.down Nat).next (HAdd.hAdd i 1)) i","decl":"@[simp]\ntheorem next_nat_succ (i : ‚Ñï) : (ComplexShape.down ‚Ñï).next (i + 1) = i :=\n  (ComplexShape.down ‚Ñï).next_eq' rfl\n\n"}
{"name":"CochainComplex.prev","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : AddGroup Œ±\ninst‚úù : One Œ±\ni : Œ±\n‚ä¢ Eq ((ComplexShape.up Œ±).prev i) (HSub.hSub i 1)","decl":"@[simp]\ntheorem prev (Œ± : Type*) [AddGroup Œ±] [One Œ±] (i : Œ±) : (ComplexShape.up Œ±).prev i = i - 1 :=\n  (ComplexShape.up Œ±).prev_eq' <| sub_add_cancel _ _\n\n"}
{"name":"CochainComplex.next","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : AddRightCancelSemigroup Œ±\ninst‚úù : One Œ±\ni : Œ±\n‚ä¢ Eq ((ComplexShape.up Œ±).next i) (HAdd.hAdd i 1)","decl":"@[simp]\ntheorem next (Œ± : Type*) [AddRightCancelSemigroup Œ±] [One Œ±] (i : Œ±) :\n    (ComplexShape.up Œ±).next i = i + 1 :=\n  (ComplexShape.up Œ±).next_eq' rfl\n\n"}
{"name":"CochainComplex.prev_nat_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"‚ä¢ Eq ((ComplexShape.up Nat).prev 0) 0","decl":"@[simp]\ntheorem prev_nat_zero : (ComplexShape.up ‚Ñï).prev 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n\n"}
{"name":"CochainComplex.prev_nat_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"i : Nat\n‚ä¢ Eq ((ComplexShape.up Nat).prev (HAdd.hAdd i 1)) i","decl":"@[simp]\ntheorem prev_nat_succ (i : ‚Ñï) : (ComplexShape.up ‚Ñï).prev (i + 1) = i :=\n  (ComplexShape.up ‚Ñï).prev_eq' rfl\n\n"}
{"name":"HomologicalComplex.Hom.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\ninst‚úù¬π : SizeOf Œπ\ninst‚úù : SizeOf V\nf : (i : Œπ) ‚Üí Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { f := f, comm' := comm' }) 1","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nx y : A.Hom B\nf : Eq x.f y.f\n‚ä¢ Eq x y","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.comm'","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nself : A.Hom B\ni j : Œπ\na‚úù : c.Rel i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (self.f j))","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.ext_iff","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.mk.inj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nf‚úù : (i : Œπ) ‚Üí Quiver.Hom (A.X i) (B.X i)\ncomm'‚úù : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f‚úù i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f‚úù j))) _auto‚úù\nf : (i : Œπ) ‚Üí Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto‚úù\nx‚úù : Eq { f := f‚úù, comm' := comm'‚úù } { f := f, comm' := comm' }\n‚ä¢ Eq f‚úù f","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.mk.injEq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nf‚úù : (i : Œπ) ‚Üí Quiver.Hom (A.X i) (B.X i)\ncomm'‚úù : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f‚úù i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f‚úù j))) _auto‚úù\nf : (i : Œπ) ‚Üí Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto‚úù\n‚ä¢ Eq (Eq { f := f‚úù, comm' := comm'‚úù } { f := f, comm' := comm' }) (Eq f‚úù f)","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ‚àÄ i, A.X i ‚ü∂ B.X i\n  comm' : ‚àÄ i j, c.Rel i j ‚Üí f i ‚â´ B.d i j = A.d i j ‚â´ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.comm_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : Œπ\nZ : V\nh : Quiver.Hom (B.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (B.d i j) h)) (CategoryTheory.CategoryStruct.comp (A.d i j) (CategoryTheory.CategoryStruct.comp (f.f j) h))","decl":"@[reassoc (attr := simp)]\ntheorem Hom.comm {A B : HomologicalComplex V c} (f : A.Hom B) (i j : Œπ) :\n    f.f i ‚â´ B.d i j = A.d i j ‚â´ f.f j := by\n  by_cases hij : c.Rel i j\n  ¬∑ exact f.comm' i j hij\n  ¬∑ rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.Hom.comm","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f.f j))","decl":"@[reassoc (attr := simp)]\ntheorem Hom.comm {A B : HomologicalComplex V c} (f : A.Hom B) (i j : Œπ) :\n    f.f i ‚â´ B.d i j = A.d i j ‚â´ f.f j := by\n  by_cases hij : c.Rel i j\n  ¬∑ exact f.comm' i j hij\n  ¬∑ rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.hom_ext_iff","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\n‚ä¢ Iff (Eq f g) (‚àÄ (i : Œπ), Eq (f.f i) (g.f i))","decl":"@[ext]\nlemma hom_ext {C D : HomologicalComplex V c} (f g : C ‚ü∂ D)\n    (h : ‚àÄ i, f.f i = g.f i) : f = g := by\n  apply Hom.ext\n  funext\n  apply h\n\n"}
{"name":"HomologicalComplex.hom_ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : ‚àÄ (i : Œπ), Eq (f.f i) (g.f i)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {C D : HomologicalComplex V c} (f g : C ‚ü∂ D)\n    (h : ‚àÄ i, f.f i = g.f i) : f = g := by\n  apply Hom.ext\n  funext\n  apply h\n\n"}
{"name":"HomologicalComplex.id_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni : Œπ\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id C).f i) (CategoryTheory.CategoryStruct.id (C.X i))","decl":"@[simp]\ntheorem id_f (C : HomologicalComplex V c) (i : Œπ) : Hom.f (ùüô C) i = ùüô (C.X i) :=\n  rfl\n\n"}
{"name":"HomologicalComplex.comp_f_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c\nf : Quiver.Hom C‚ÇÅ C‚ÇÇ\ng : Quiver.Hom C‚ÇÇ C‚ÇÉ\ni : Œπ\nZ : V\nh : Quiver.Hom (C‚ÇÉ.X i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp f g).f i) h) (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (g.f i) h))","decl":"@[simp, reassoc]\ntheorem comp_f {C‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (g : C‚ÇÇ ‚ü∂ C‚ÇÉ) (i : Œπ) :\n    (f ‚â´ g).f i = f.f i ‚â´ g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.comp_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c\nf : Quiver.Hom C‚ÇÅ C‚ÇÇ\ng : Quiver.Hom C‚ÇÇ C‚ÇÉ\ni : Œπ\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g).f i) (CategoryTheory.CategoryStruct.comp (f.f i) (g.f i))","decl":"@[simp, reassoc]\ntheorem comp_f {C‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (g : C‚ÇÇ ‚ü∂ C‚ÇÉ) (i : Œπ) :\n    (f ‚â´ g).f i = f.f i ‚â´ g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.eqToHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nh : Eq C‚ÇÅ C‚ÇÇ\nn : Œπ\n‚ä¢ Eq ((CategoryTheory.eqToHom h).f n) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_f {C‚ÇÅ C‚ÇÇ : HomologicalComplex V c} (h : C‚ÇÅ = C‚ÇÇ) (n : Œπ) :\n    HomologicalComplex.Hom.f (eqToHom h) n =\n      eqToHom (congr_fun (congr_arg HomologicalComplex.X h) n) := by\n  subst h\n  rfl\n\n-- We'll use this later to show that `HomologicalComplex V c` is preadditive when `V` is.\n"}
{"name":"HomologicalComplex.hom_f_injective","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\n‚ä¢ Function.Injective fun f => f.f","decl":"theorem hom_f_injective {C‚ÇÅ C‚ÇÇ : HomologicalComplex V c} :\n    Function.Injective fun f : Hom C‚ÇÅ C‚ÇÇ => f.f := by aesop_cat\n\n"}
{"name":"HomologicalComplex.zero_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.f 0 i) 0","decl":"@[simp]\ntheorem zero_f (C D : HomologicalComplex V c) (i : Œπ) : (0 : C ‚ü∂ D).f i = 0 :=\n  rfl\n\n"}
{"name":"HomologicalComplex.isZero_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ninst‚úù : CategoryTheory.Limits.HasZeroObject V\n‚ä¢ CategoryTheory.Limits.IsZero HomologicalComplex.zero","decl":"theorem isZero_zero [HasZeroObject V] : IsZero (zero : HomologicalComplex V c) := by\n  refine ‚ü®fun X => ‚ü®‚ü®‚ü®0‚ü©, fun f => ?_‚ü©‚ü©, fun X => ‚ü®‚ü®‚ü®0‚ü©, fun f => ?_‚ü©‚ü©‚ü©\n  all_goals\n    ext\n    dsimp only [zero]\n    subsingleton\n\n"}
{"name":"HomologicalComplex.instHasZeroObject","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ninst‚úù : CategoryTheory.Limits.HasZeroObject V\n‚ä¢ CategoryTheory.Limits.HasZeroObject (HomologicalComplex V c)","decl":"instance [HasZeroObject V] : HasZeroObject (HomologicalComplex V c) :=\n  ‚ü®‚ü®zero, isZero_zero‚ü©‚ü©\n\n"}
{"name":"HomologicalComplex.congr_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nw : Eq f g\ni : Œπ\n‚ä¢ Eq (f.f i) (g.f i)","decl":"theorem congr_hom {C D : HomologicalComplex V c} {f g : C ‚ü∂ D} (w : f = g) (i : Œπ) :\n    f.f i = g.f i :=\n  congr_fun (congr_arg Hom.f w) i\n\n"}
{"name":"HomologicalComplex.mono_of_mono_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nhœÜ : ‚àÄ (i : Œπ), CategoryTheory.Mono (œÜ.f i)\n‚ä¢ CategoryTheory.Mono œÜ","decl":"lemma mono_of_mono_f {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L)\n    (hœÜ : ‚àÄ i, Mono (œÜ.f i)) : Mono œÜ where\n  right_cancellation g h eq := by\n    ext i\n    rw [‚Üê cancel_mono (œÜ.f i)]\n    exact congr_hom eq i\n\n"}
{"name":"HomologicalComplex.epi_of_epi_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nhœÜ : ‚àÄ (i : Œπ), CategoryTheory.Epi (œÜ.f i)\n‚ä¢ CategoryTheory.Epi œÜ","decl":"lemma epi_of_epi_f {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L)\n    (hœÜ : ‚àÄ i, Epi (œÜ.f i)) : Epi œÜ where\n  left_cancellation g h eq := by\n    ext i\n    rw [‚Üê cancel_epi (œÜ.f i)]\n    exact congr_hom eq i\n\n"}
{"name":"HomologicalComplex.eval_obj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ni : Œπ\nC : HomologicalComplex V c\n‚ä¢ Eq ((HomologicalComplex.eval V c i).obj C) (C.X i)","decl":"/-- The functor picking out the `i`-th object of a complex. -/\n@[simps]\ndef eval (i : Œπ) : HomologicalComplex V c ‚•§ V where\n  obj C := C.X i\n  map f := f.f i\n\n"}
{"name":"HomologicalComplex.eval_map","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ni : Œπ\nX‚úù Y‚úù : HomologicalComplex V c\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((HomologicalComplex.eval V c i).map f) (f.f i)","decl":"/-- The functor picking out the `i`-th object of a complex. -/\n@[simps]\ndef eval (i : Œπ) : HomologicalComplex V c ‚•§ V where\n  obj C := C.X i\n  map f := f.f i\n\n"}
{"name":"HomologicalComplex.instPreservesZeroMorphismsEval","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ni : Œπ\n‚ä¢ (HomologicalComplex.eval V c i).PreservesZeroMorphisms","decl":"instance (i : Œπ) : (eval V c i).PreservesZeroMorphisms where\n\n"}
{"name":"HomologicalComplex.forget_map","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nX‚úù Y‚úù : HomologicalComplex V c\nf : Quiver.Hom X‚úù Y‚úù\ni : Œπ\n‚ä¢ Eq ((HomologicalComplex.forget V c).map f i) (f.f i)","decl":"/-- The functor forgetting the differential in a complex, obtaining a graded object. -/\n@[simps]\ndef forget : HomologicalComplex V c ‚•§ GradedObject Œπ V where\n  obj C := C.X\n  map f := f.f\n\n"}
{"name":"HomologicalComplex.forget_obj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\na‚úù : Œπ\n‚ä¢ Eq ((HomologicalComplex.forget V c).obj C a‚úù) (C.X a‚úù)","decl":"/-- The functor forgetting the differential in a complex, obtaining a graded object. -/\n@[simps]\ndef forget : HomologicalComplex V c ‚•§ GradedObject Œπ V where\n  obj C := C.X\n  map f := f.f\n\n"}
{"name":"HomologicalComplex.instFaithfulGradedObjectForget","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\n‚ä¢ (HomologicalComplex.forget V c).Faithful","decl":"instance : (forget V c).Faithful where\n  map_injective h := by\n    ext i\n    exact congr_fun h i\n\n"}
{"name":"HomologicalComplex.forgetEval_hom_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ni : Œπ\nX : HomologicalComplex V c\n‚ä¢ Eq ((HomologicalComplex.forgetEval V c i).hom.app X) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- Forgetting the differentials than picking out the `i`-th object is the same as\njust picking out the `i`-th object. -/\n@[simps!]\ndef forgetEval (i : Œπ) : forget V c ‚ãô GradedObject.eval i ‚âÖ eval V c i :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"HomologicalComplex.forgetEval_inv_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\ni : Œπ\nX : HomologicalComplex V c\n‚ä¢ Eq ((HomologicalComplex.forgetEval V c i).inv.app X) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- Forgetting the differentials than picking out the `i`-th object is the same as\njust picking out the `i`-th object. -/\n@[simps!]\ndef forgetEval (i : Œπ) : forget V c ‚ãô GradedObject.eval i ‚âÖ eval V c i :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_naturality","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nn n' : Œπ\nh : Eq n n'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (œÜ.f n) (L.XIsoOfEq h).hom) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).hom (œÜ.f n'))","decl":"@[reassoc]\nlemma XIsoOfEq_hom_naturality {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L) {n n' : Œπ} (h : n = n') :\n    œÜ.f n ‚â´ (L.XIsoOfEq h).hom = (K.XIsoOfEq h).hom ‚â´ œÜ.f n' := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nn n' : Œπ\nh‚úù : Eq n n'\nZ : V\nh : Quiver.Hom (L.X n') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (œÜ.f n) (CategoryTheory.CategoryStruct.comp (L.XIsoOfEq h‚úù).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).hom (CategoryTheory.CategoryStruct.comp (œÜ.f n') h))","decl":"@[reassoc]\nlemma XIsoOfEq_hom_naturality {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L) {n n' : Œπ} (h : n = n') :\n    œÜ.f n ‚â´ (L.XIsoOfEq h).hom = (K.XIsoOfEq h).hom ‚â´ œÜ.f n' := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nn n' : Œπ\nh‚úù : Eq n n'\nZ : V\nh : Quiver.Hom (L.X n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (œÜ.f n') (CategoryTheory.CategoryStruct.comp (L.XIsoOfEq h‚úù).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h‚úù).inv (CategoryTheory.CategoryStruct.comp (œÜ.f n) h))","decl":"@[reassoc]\nlemma XIsoOfEq_inv_naturality {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L) {n n' : Œπ} (h : n = n') :\n    œÜ.f n' ‚â´ (L.XIsoOfEq h).inv = (K.XIsoOfEq h).inv ‚â´ œÜ.f n := by subst h; simp\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_naturality","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nœÜ : Quiver.Hom K L\nn n' : Œπ\nh : Eq n n'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (œÜ.f n') (L.XIsoOfEq h).inv) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).inv (œÜ.f n))","decl":"@[reassoc]\nlemma XIsoOfEq_inv_naturality {K L : HomologicalComplex V c} (œÜ : K ‚ü∂ L) {n n' : Œπ} (h : n = n') :\n    œÜ.f n' ‚â´ (L.XIsoOfEq h).inv = (K.XIsoOfEq h).inv ‚â´ œÜ.f n := by subst h; simp\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.d_comp_eqToHom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j j' : Œπ\nrij : c.Rel i j\nrij' : c.Rel i j'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j') (CategoryTheory.eqToHom ‚ãØ)) (C.d i j)","decl":"/-- If `C.d i j` and `C.d i j'` are both allowed, then we must have `j = j'`,\nand so the differentials only differ by an `eqToHom`.\n-/\ntheorem d_comp_eqToHom {i j j' : Œπ} (rij : c.Rel i j) (rij' : c.Rel i j') :\n    C.d i j' ‚â´ eqToHom (congr_arg C.X (c.next_eq rij' rij)) = C.d i j := by\n  obtain rfl := c.next_eq rij rij'\n  simp only [eqToHom_refl, comp_id]\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.eqToHom_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni i' j : Œπ\nrij : c.Rel i j\nrij' : c.Rel i' j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (C.d i' j)) (C.d i j)","decl":"/-- If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,\nand so the differentials only differ by an `eqToHom`.\n-/\ntheorem eqToHom_comp_d {i i' j : Œπ} (rij : c.Rel i j) (rij' : c.Rel i' j) :\n    eqToHom (congr_arg C.X (c.prev_eq rij rij')) ‚â´ C.d i' j = C.d i j := by\n  obtain rfl := c.prev_eq rij rij'\n  simp only [eqToHom_refl, id_comp]\n\n"}
{"name":"HomologicalComplex.kernel_eq_kernel","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ninst‚úù : CategoryTheory.Limits.HasKernels V\ni j j' : Œπ\nr : c.Rel i j\nr' : c.Rel i j'\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobject (C.d i j)) (CategoryTheory.Limits.kernelSubobject (C.d i j'))","decl":"theorem kernel_eq_kernel [HasKernels V] {i j j' : Œπ} (r : c.Rel i j) (r' : c.Rel i j') :\n    kernelSubobject (C.d i j) = kernelSubobject (C.d i j') := by\n  rw [‚Üê d_comp_eqToHom C r r']\n  apply kernelSubobject_comp_mono\n\n"}
{"name":"HomologicalComplex.image_eq_image","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ninst‚úù¬π : CategoryTheory.Limits.HasImages V\ninst‚úù : CategoryTheory.Limits.HasEqualizers V\ni i' j : Œπ\nr : c.Rel i j\nr' : c.Rel i' j\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject (C.d i j)) (CategoryTheory.Limits.imageSubobject (C.d i' j))","decl":"theorem image_eq_image [HasImages V] [HasEqualizers V] {i i' j : Œπ} (r : c.Rel i j)\n    (r' : c.Rel i' j) : imageSubobject (C.d i j) = imageSubobject (C.d i' j) := by\n  rw [‚Üê eqToHom_comp_d C r r']\n  apply imageSubobject_iso_comp\n\n"}
{"name":"HomologicalComplex.dTo_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (C.dTo j) (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).hom (C.d i j))","decl":"theorem dTo_eq {i j : Œπ} (r : c.Rel i j) : C.dTo j = (C.xPrevIso r).hom ‚â´ C.d i j := by\n  obtain rfl := c.prev_eq' r\n  exact (Category.id_comp _).symm\n\n"}
{"name":"HomologicalComplex.dTo_eq_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\nj : Œπ\nh : Not (c.Rel (c.prev j) j)\n‚ä¢ Eq (C.dTo j) 0","decl":"@[simp]\ntheorem dTo_eq_zero {j : Œπ} (h : ¬¨c.Rel (c.prev j) j) : C.dTo j = 0 :=\n  C.shape _ _ h\n\n"}
{"name":"HomologicalComplex.dFrom_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.d i j) (C.xNextIso r).inv)","decl":"theorem dFrom_eq {i j : Œπ} (r : c.Rel i j) : C.dFrom i = C.d i j ‚â´ (C.xNextIso r).inv := by\n  obtain rfl := c.next_eq' r\n  exact (Category.comp_id _).symm\n\n"}
{"name":"HomologicalComplex.dFrom_eq_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni : Œπ\nh : Not (c.Rel i (c.next i))\n‚ä¢ Eq (C.dFrom i) 0","decl":"@[simp]\ntheorem dFrom_eq_zero {i : Œπ} (h : ¬¨c.Rel i (c.next i)) : C.dFrom i = 0 :=\n  C.shape _ _ h\n\n"}
{"name":"HomologicalComplex.xPrevIso_comp_dTo","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).inv (C.dTo j)) (C.d i j)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIso_comp_dTo {i j : Œπ} (r : c.Rel i j) : (C.xPrevIso r).inv ‚â´ C.dTo j = C.d i j := by\n  simp [C.dTo_eq r]\n\n"}
{"name":"HomologicalComplex.xPrevIso_comp_dTo_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\nZ : V\nh : Quiver.Hom (C.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).inv (CategoryTheory.CategoryStruct.comp (C.dTo j) h)) (CategoryTheory.CategoryStruct.comp (C.d i j) h)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIso_comp_dTo {i j : Œπ} (r : c.Rel i j) : (C.xPrevIso r).inv ‚â´ C.dTo j = C.d i j := by\n  simp [C.dTo_eq r]\n\n"}
{"name":"HomologicalComplex.xPrevIsoSelf_comp_dTo","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\nj : Œπ\nh : Not (c.Rel (c.prev j) j)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIsoSelf h).inv (C.dTo j)) 0","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIsoSelf_comp_dTo {j : Œπ} (h : ¬¨c.Rel (c.prev j) j) :\n    (C.xPrevIsoSelf h).inv ‚â´ C.dTo j = 0 := by simp [h]\n\n"}
{"name":"HomologicalComplex.xPrevIsoSelf_comp_dTo_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\nj : Œπ\nh‚úù : Not (c.Rel (c.prev j) j)\nZ : V\nh : Quiver.Hom (C.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIsoSelf h‚úù).inv (CategoryTheory.CategoryStruct.comp (C.dTo j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIsoSelf_comp_dTo {j : Œπ} (h : ¬¨c.Rel (c.prev j) j) :\n    (C.xPrevIsoSelf h).inv ‚â´ C.dTo j = 0 := by simp [h]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIso","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (C.xNextIso r).hom) (C.d i j)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIso {i j : Œπ} (r : c.Rel i j) :\n    C.dFrom i ‚â´ (C.xNextIso r).hom = C.d i j := by\n  simp [C.dFrom_eq r]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIso_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni j : Œπ\nr : c.Rel i j\nZ : V\nh : Quiver.Hom (C.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.xNextIso r).hom h)) (CategoryTheory.CategoryStruct.comp (C.d i j) h)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIso {i j : Œπ} (r : c.Rel i j) :\n    C.dFrom i ‚â´ (C.xNextIso r).hom = C.d i j := by\n  simp [C.dFrom_eq r]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIsoSelf_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni : Œπ\nh‚úù : Not (c.Rel i (c.next i))\nZ : V\nh : Quiver.Hom (C.X i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.xNextIsoSelf h‚úù).hom h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIsoSelf {i : Œπ} (h : ¬¨c.Rel i (c.next i)) :\n    C.dFrom i ‚â´ (C.xNextIsoSelf h).hom = 0 := by simp [h]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIsoSelf","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ni : Œπ\nh : Not (c.Rel i (c.next i))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (C.xNextIsoSelf h).hom) 0","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIsoSelf {i : Œπ} (h : ¬¨c.Rel i (c.next i)) :\n    C.dFrom i ‚â´ (C.xNextIsoSelf h).hom = 0 := by simp [h]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"HomologicalComplex.dTo_comp_dFrom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\nj : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (C.dTo j) (C.dFrom j)) 0","decl":"theorem dTo_comp_dFrom (j : Œπ) : C.dTo j ‚â´ C.dFrom j = 0 :=\n  C.d_comp_d _ _ _\n\n"}
{"name":"HomologicalComplex.kernel_from_eq_kernel","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ninst‚úù : CategoryTheory.Limits.HasKernels V\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (CategoryTheory.Limits.kernelSubobject (C.dFrom i)) (CategoryTheory.Limits.kernelSubobject (C.d i j))","decl":"theorem kernel_from_eq_kernel [HasKernels V] {i j : Œπ} (r : c.Rel i j) :\n    kernelSubobject (C.dFrom i) = kernelSubobject (C.d i j) := by\n  rw [C.dFrom_eq r]\n  apply kernelSubobject_comp_mono\n\n"}
{"name":"HomologicalComplex.image_to_eq_image","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\ninst‚úù¬π : CategoryTheory.Limits.HasImages V\ninst‚úù : CategoryTheory.Limits.HasEqualizers V\ni j : Œπ\nr : c.Rel i j\n‚ä¢ Eq (CategoryTheory.Limits.imageSubobject (C.dTo j)) (CategoryTheory.Limits.imageSubobject (C.d i j))","decl":"theorem image_to_eq_image [HasImages V] [HasEqualizers V] {i j : Œπ} (r : c.Rel i j) :\n    imageSubobject (C.dTo j) = imageSubobject (C.d i j) := by\n  rw [C.dTo_eq r]\n  apply imageSubobject_iso_comp\n\n"}
{"name":"HomologicalComplex.Hom.isoApp_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : CategoryTheory.Iso C‚ÇÅ C‚ÇÇ\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.isoApp f i).inv (f.inv.f i)","decl":"/-- The `i`-th component of an isomorphism of chain complexes. -/\n@[simps!]\ndef isoApp (f : C‚ÇÅ ‚âÖ C‚ÇÇ) (i : Œπ) : C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i :=\n  (eval V c i).mapIso f\n\n"}
{"name":"HomologicalComplex.Hom.isoApp_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : CategoryTheory.Iso C‚ÇÅ C‚ÇÇ\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.isoApp f i).hom (f.hom.f i)","decl":"/-- The `i`-th component of an isomorphism of chain complexes. -/\n@[simps!]\ndef isoApp (f : C‚ÇÅ ‚âÖ C‚ÇÇ) (i : Œπ) : C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i :=\n  (eval V c i).mapIso f\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_hom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : (i : Œπ) ‚Üí CategoryTheory.Iso (C‚ÇÅ.X i) (C‚ÇÇ.X i)\nhf : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C‚ÇÇ.d i j)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.d i j) (f j).hom)) _auto‚úù\ni : Œπ\n‚ä¢ Eq ((HomologicalComplex.Hom.isoOfComponents f hf).hom.f i) (f i).hom","decl":"/-- Construct an isomorphism of chain complexes from isomorphism of the objects\nwhich commute with the differentials. -/\n@[simps]\ndef isoOfComponents (f : ‚àÄ i, C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i)\n    (hf : ‚àÄ i j, c.Rel i j ‚Üí (f i).hom ‚â´ C‚ÇÇ.d i j = C‚ÇÅ.d i j ‚â´ (f j).hom := by aesop_cat) :\n    C‚ÇÅ ‚âÖ C‚ÇÇ where\n  hom :=\n    { f := fun i => (f i).hom\n      comm' := hf }\n  inv :=\n    { f := fun i => (f i).inv\n      comm' := fun i j hij =>\n        calc\n          (f i).inv ‚â´ C‚ÇÅ.d i j = (f i).inv ‚â´ (C‚ÇÅ.d i j ‚â´ (f j).hom) ‚â´ (f j).inv := by simp\n          _ = (f i).inv ‚â´ ((f i).hom ‚â´ C‚ÇÇ.d i j) ‚â´ (f j).inv := by rw [hf i j hij]\n          _ = C‚ÇÇ.d i j ‚â´ (f j).inv := by simp }\n  hom_inv_id := by\n    ext i\n    exact (f i).hom_inv_id\n  inv_hom_id := by\n    ext i\n    exact (f i).inv_hom_id\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_inv_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : (i : Œπ) ‚Üí CategoryTheory.Iso (C‚ÇÅ.X i) (C‚ÇÇ.X i)\nhf : autoParam (‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C‚ÇÇ.d i j)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.d i j) (f j).hom)) _auto‚úù\ni : Œπ\n‚ä¢ Eq ((HomologicalComplex.Hom.isoOfComponents f hf).inv.f i) (f i).inv","decl":"/-- Construct an isomorphism of chain complexes from isomorphism of the objects\nwhich commute with the differentials. -/\n@[simps]\ndef isoOfComponents (f : ‚àÄ i, C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i)\n    (hf : ‚àÄ i j, c.Rel i j ‚Üí (f i).hom ‚â´ C‚ÇÇ.d i j = C‚ÇÅ.d i j ‚â´ (f j).hom := by aesop_cat) :\n    C‚ÇÅ ‚âÖ C‚ÇÇ where\n  hom :=\n    { f := fun i => (f i).hom\n      comm' := hf }\n  inv :=\n    { f := fun i => (f i).inv\n      comm' := fun i j hij =>\n        calc\n          (f i).inv ‚â´ C‚ÇÅ.d i j = (f i).inv ‚â´ (C‚ÇÅ.d i j ‚â´ (f j).hom) ‚â´ (f j).inv := by simp\n          _ = (f i).inv ‚â´ ((f i).hom ‚â´ C‚ÇÇ.d i j) ‚â´ (f j).inv := by rw [hf i j hij]\n          _ = C‚ÇÇ.d i j ‚â´ (f j).inv := by simp }\n  hom_inv_id := by\n    ext i\n    exact (f i).hom_inv_id\n  inv_hom_id := by\n    ext i\n    exact (f i).inv_hom_id\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : (i : Œπ) ‚Üí CategoryTheory.Iso (C‚ÇÅ.X i) (C‚ÇÇ.X i)\nhf : ‚àÄ (i j : Œπ), c.Rel i j ‚Üí Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C‚ÇÇ.d i j)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.d i j) (f j).hom)\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.isoApp (HomologicalComplex.Hom.isoOfComponents f hf) i) (f i)","decl":"@[simp]\ntheorem isoOfComponents_app (f : ‚àÄ i, C‚ÇÅ.X i ‚âÖ C‚ÇÇ.X i)\n    (hf : ‚àÄ i j, c.Rel i j ‚Üí (f i).hom ‚â´ C‚ÇÇ.d i j = C‚ÇÅ.d i j ‚â´ (f j).hom) (i : Œπ) :\n    isoApp (isoOfComponents f hf) i = f i := by\n  ext\n  simp\n\n"}
{"name":"HomologicalComplex.Hom.isIso_of_components","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : Quiver.Hom C‚ÇÅ C‚ÇÇ\ninst‚úù : ‚àÄ (n : Œπ), CategoryTheory.IsIso (f.f n)\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem isIso_of_components (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) [‚àÄ n : Œπ, IsIso (f.f n)] : IsIso f :=\n  (HomologicalComplex.Hom.isoOfComponents fun n => asIso (f.f n)).isIso_hom\n\n"}
{"name":"HomologicalComplex.Hom.prev_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni j : Œπ\nw : c.Rel i j\n‚ä¢ Eq (f.prev j) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.xPrevIso w).hom (CategoryTheory.CategoryStruct.comp (f.f i) (C‚ÇÇ.xPrevIso w).inv))","decl":"theorem prev_eq (f : Hom C‚ÇÅ C‚ÇÇ) {i j : Œπ} (w : c.Rel i j) :\n    f.prev j = (C‚ÇÅ.xPrevIso w).hom ‚â´ f.f i ‚â´ (C‚ÇÇ.xPrevIso w).inv := by\n  obtain rfl := c.prev_eq' w\n  simp only [xPrevIso, eqToIso_refl, Iso.refl_hom, Iso.refl_inv, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex.Hom.next_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni j : Œπ\nw : c.Rel i j\n‚ä¢ Eq (f.next i) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.xNextIso w).hom (CategoryTheory.CategoryStruct.comp (f.f j) (C‚ÇÇ.xNextIso w).inv))","decl":"theorem next_eq (f : Hom C‚ÇÅ C‚ÇÇ) {i j : Œπ} (w : c.Rel i j) :\n    f.next i = (C‚ÇÅ.xNextIso w).hom ‚â´ f.f j ‚â´ (C‚ÇÇ.xNextIso w).inv := by\n  obtain rfl := c.next_eq' w\n  simp only [xNextIso, eqToIso_refl, Iso.refl_hom, Iso.refl_inv, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex.Hom.comm_from_apply","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni : Œπ\ninst : CategoryTheory.HasForget V\nx : (CategoryTheory.forget V).obj (C‚ÇÅ.X i)\n‚ä¢ Eq ((C‚ÇÇ.dFrom i) ((f.f i) x)) ((f.next i) ((C‚ÇÅ.dFrom i) x))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : f.f i ‚â´ C‚ÇÇ.dFrom i = C‚ÇÅ.dFrom i ‚â´ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_from_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni : Œπ\nZ : V\nh : Quiver.Hom (C‚ÇÇ.xNext i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (C‚ÇÇ.dFrom i) h)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.dFrom i) (CategoryTheory.CategoryStruct.comp (f.next i) h))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : f.f i ‚â´ C‚ÇÇ.dFrom i = C‚ÇÅ.dFrom i ‚â´ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_from","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (C‚ÇÇ.dFrom i)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.dFrom i) (f.next i))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : f.f i ‚â´ C‚ÇÇ.dFrom i = C‚ÇÅ.dFrom i ‚â´ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to_apply","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\nj : Œπ\ninst : CategoryTheory.HasForget V\nx : (CategoryTheory.forget V).obj (C‚ÇÅ.xPrev j)\n‚ä¢ Eq ((C‚ÇÇ.dTo j) ((f.prev j) x)) ((f.f j) ((C‚ÇÅ.dTo j) x))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : f.prev j ‚â´ C‚ÇÇ.dTo j = C‚ÇÅ.dTo j ‚â´ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\nj : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.prev j) (C‚ÇÇ.dTo j)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.dTo j) (f.f j))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : f.prev j ‚â´ C‚ÇÇ.dTo j = C‚ÇÅ.dTo j ‚â´ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\nj : Œπ\nZ : V\nh : Quiver.Hom (C‚ÇÇ.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (f.prev j) (CategoryTheory.CategoryStruct.comp (C‚ÇÇ.dTo j) h)) (CategoryTheory.CategoryStruct.comp (C‚ÇÅ.dTo j) (CategoryTheory.CategoryStruct.comp (f.f j) h))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : f.prev j ‚â´ C‚ÇÇ.dTo j = C‚ÇÅ.dTo j ‚â´ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_left","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni : Œπ\n‚ä¢ Eq (f.sqFrom i).left (f.f i)","decl":"@[simp]\ntheorem sqFrom_left (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).left = f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_right","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\ni : Œπ\n‚ä¢ Eq (f.sqFrom i).right (f.next i)","decl":"@[simp]\ntheorem sqFrom_right (f : Hom C‚ÇÅ C‚ÇÇ) (i : Œπ) : (f.sqFrom i).right = f.next i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_id","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ : HomologicalComplex V c\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.sqFrom (CategoryTheory.CategoryStruct.id C‚ÇÅ) i) (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk (C‚ÇÅ.dFrom i)))","decl":"@[simp]\ntheorem sqFrom_id (C‚ÇÅ : HomologicalComplex V c) (i : Œπ) : sqFrom (ùüô C‚ÇÅ) i = ùüô _ :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_comp","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c\nf : Quiver.Hom C‚ÇÅ C‚ÇÇ\ng : Quiver.Hom C‚ÇÇ C‚ÇÉ\ni : Œπ\n‚ä¢ Eq (HomologicalComplex.Hom.sqFrom (CategoryTheory.CategoryStruct.comp f g) i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.Hom.sqFrom f i) (HomologicalComplex.Hom.sqFrom g i))","decl":"@[simp]\ntheorem sqFrom_comp (f : C‚ÇÅ ‚ü∂ C‚ÇÇ) (g : C‚ÇÇ ‚ü∂ C‚ÇÉ) (i : Œπ) :\n    sqFrom (f ‚â´ g) i = sqFrom f i ‚â´ sqFrom g i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqTo_left","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\nj : Œπ\n‚ä¢ Eq (f.sqTo j).left (f.prev j)","decl":"@[simp]\ntheorem sqTo_left (f : Hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : (f.sqTo j).left = f.prev j :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqTo_right","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ : HomologicalComplex V c\nf : C‚ÇÅ.Hom C‚ÇÇ\nj : Œπ\n‚ä¢ Eq (f.sqTo j).right (f.f j)","decl":"@[simp]\ntheorem sqTo_right (f : Hom C‚ÇÅ C‚ÇÇ) (j : Œπ) : (f.sqTo j).right = f.f j :=\n  rfl\n\n"}
{"name":"ChainComplex.of_x","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\nn : Œ±\n‚ä¢ Eq ((ChainComplex.of X d sq).X n) (X n)","decl":"@[simp]\ntheorem of_x (n : Œ±) : (of X d sq).X n = X n :=\n  rfl\n\n"}
{"name":"ChainComplex.of_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\nj : Œ±\n‚ä¢ Eq ((ChainComplex.of X d sq).d (HAdd.hAdd j 1) j) (d j)","decl":"@[simp]\ntheorem of_d (j : Œ±) : (of X d sq).d (j + 1) j = d j := by\n  dsimp [of]\n  rw [if_pos rfl, Category.id_comp]\n\n"}
{"name":"ChainComplex.of_d_ne","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\ni j : Œ±\nh : Ne i (HAdd.hAdd j 1)\n‚ä¢ Eq ((ChainComplex.of X d sq).d i j) 0","decl":"theorem of_d_ne {i j : Œ±} (h : i ‚â† j + 1) : (of X d sq).d i j = 0 := by\n  dsimp [of]\n  rw [dif_neg h]\n\n"}
{"name":"ChainComplex.ofHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd_X : (n : Œ±) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq_X : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d_X (HAdd.hAdd n 1)) (d_X n)) 0\nY : Œ± ‚Üí V\nd_Y : (n : Œ±) ‚Üí Quiver.Hom (Y (HAdd.hAdd n 1)) (Y n)\nsq_Y : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d_Y (HAdd.hAdd n 1)) (d_Y n)) 0\nf : (i : Œ±) ‚Üí Quiver.Hom (X i) (Y i)\ncomm : ‚àÄ (i : Œ±), Eq (CategoryTheory.CategoryStruct.comp (f (HAdd.hAdd i 1)) (d_Y i)) (CategoryTheory.CategoryStruct.comp (d_X i) (f i))\ni : Œ±\n‚ä¢ Eq ((ChainComplex.ofHom X d_X sq_X Y d_Y sq_Y f comm).f i) (f i)","decl":"/-- A constructor for chain maps between `Œ±`-indexed chain complexes built using `ChainComplex.of`,\nfrom a dependently typed collection of morphisms.\n-/\n@[simps]\ndef ofHom (f : ‚àÄ i : Œ±, X i ‚ü∂ Y i) (comm : ‚àÄ i : Œ±, f (i + 1) ‚â´ d_Y i = d_X i ‚â´ f i) :\n    of X d_X sq_X ‚ü∂ of Y d_Y sq_Y :=\n  { f\n    comm' := fun n m => by\n      by_cases h : n = m + 1\n      ¬∑ subst h\n        simpa using comm m\n      ¬∑ rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]\n        simp }\n\n"}
{"name":"ChainComplex.mk_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nd‚ÇÅ : Quiver.Hom X‚ÇÇ X‚ÇÅ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÅ d‚ÇÄ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÉ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp d‚ÇÇ S.f) 0\n‚ä¢ Eq ((ChainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 0) X‚ÇÄ","decl":"@[simp]\ntheorem mk_X_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 0 = X‚ÇÄ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nd‚ÇÅ : Quiver.Hom X‚ÇÇ X‚ÇÅ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÅ d‚ÇÄ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÉ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp d‚ÇÇ S.f) 0\n‚ä¢ Eq ((ChainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 1) X‚ÇÅ","decl":"@[simp]\ntheorem mk_X_1 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 1 = X‚ÇÅ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_X_2","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nd‚ÇÅ : Quiver.Hom X‚ÇÇ X‚ÇÅ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÅ d‚ÇÄ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÉ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp d‚ÇÇ S.f) 0\n‚ä¢ Eq ((ChainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 2) X‚ÇÇ","decl":"@[simp]\ntheorem mk_X_2 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 2 = X‚ÇÇ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nd‚ÇÅ : Quiver.Hom X‚ÇÇ X‚ÇÅ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÅ d‚ÇÄ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÉ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp d‚ÇÇ S.f) 0\n‚ä¢ Eq ((ChainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0) d‚ÇÄ","decl":"@[simp]\ntheorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 0 = d‚ÇÄ := by\n  change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ\n  rw [if_pos rfl, Category.id_comp]\n\n"}
{"name":"ChainComplex.mk_d_2_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nd‚ÇÅ : Quiver.Hom X‚ÇÇ X‚ÇÅ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÅ d‚ÇÄ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÉ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp d‚ÇÇ S.f) 0\n‚ä¢ Eq ((ChainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 2 1) d‚ÇÅ","decl":"@[simp]\ntheorem mk_d_2_1 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 2 1 = d‚ÇÅ := by\n  change ite (2 = 1 + 1) (ùüô X‚ÇÇ ‚â´ d‚ÇÅ) 0 = d‚ÇÅ\n  rw [if_pos rfl, Category.id_comp]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"ChainComplex.mk'_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÅ X‚ÇÄ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n‚ä¢ Eq ((ChainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').X 0) X‚ÇÄ","decl":"@[simp]\ntheorem mk'_X_0 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').X 0 = X‚ÇÄ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk'_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÅ X‚ÇÄ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n‚ä¢ Eq ((ChainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').X 1) X‚ÇÅ","decl":"@[simp]\ntheorem mk'_X_1 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').X 1 = X‚ÇÅ :=\n  rfl\n\n\n"}
{"name":"ChainComplex.mk'_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÅ X‚ÇÄ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÅ X‚ÇÄ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n‚ä¢ Eq ((ChainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').d 1 0) d‚ÇÄ","decl":"@[simp]\ntheorem mk'_d_1_0 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').d 1 0 = d‚ÇÄ := by\n  change ite (1 = 0 + 1) (ùüô X‚ÇÅ ‚â´ d‚ÇÄ) 0 = d‚ÇÄ\n  rw [if_pos rfl, Category.id_comp]\n\n/- Porting note:\nDownstream constructions using `mk'` (e.g. in `CategoryTheory.Abelian.Projective`)\nhave very slow proofs, because of bad simp lemmas.\nIt would be better to write good lemmas here if possible, such as\n\n```\ntheorem mk'_X_succ (j : ‚Ñï) :\n    (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').X (j + 2) = (succ' ‚ü®_, _, (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').d (j + 1) j‚ü©).1 := by\n  sorry\n\ntheorem mk'_d_succ {i j : ‚Ñï} :\n    (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').d (j + 2) (j + 1) =\n      eqToHom (mk'_X_succ X‚ÇÄ X‚ÇÅ d‚ÇÄ succ' j) ‚â´\n      (succ' ‚ü®_, _, (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').d (j + 1) j‚ü©).2.1 :=\n  sorry\n```\n\nThese are already tricky, and it may be better to write analogous lemmas for `mk` first.\n-/\n\n"}
{"name":"ChainComplex.mkHom_f_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 0) zero","decl":"@[simp]\ntheorem mkHom_f_0 : (mkHom P Q zero one one_zero_comm succ).f 0 = zero :=\n  rfl\n\n"}
{"name":"ChainComplex.mkHom_f_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 1) one","decl":"@[simp]\ntheorem mkHom_f_1 : (mkHom P Q zero one one_zero_comm succ).f 1 = one :=\n  rfl\n\n"}
{"name":"ChainComplex.mkHom_f_succ_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\nn : Nat\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 2)) (succ n ‚ü®(P.mkHom Q zero one one_zero_comm succ).f n, ‚ü®(P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 1), ‚ãØ‚ü©‚ü©).fst","decl":"@[simp]\ntheorem mkHom_f_succ_succ (n : ‚Ñï) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          ‚ü®(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm (n + 1) n‚ü©).1 := by\n  dsimp [mkHom, mkHomAux]\n\n"}
{"name":"CochainComplex.of_x","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\nn : Œ±\n‚ä¢ Eq ((CochainComplex.of X d sq).X n) (X n)","decl":"@[simp]\ntheorem of_x (n : Œ±) : (of X d sq).X n = X n :=\n  rfl\n\n"}
{"name":"CochainComplex.of_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\nj : Œ±\n‚ä¢ Eq ((CochainComplex.of X d sq).d j (HAdd.hAdd j 1)) (d j)","decl":"@[simp]\ntheorem of_d (j : Œ±) : (of X d sq).d j (j + 1) = d j := by\n  dsimp [of]\n  rw [if_pos rfl, Category.comp_id]\n\n"}
{"name":"CochainComplex.of_d_ne","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd : (n : Œ±) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\ni j : Œ±\nh : Ne (HAdd.hAdd i 1) j\n‚ä¢ Eq ((CochainComplex.of X d sq).d i j) 0","decl":"theorem of_d_ne {i j : Œ±} (h : i + 1 ‚â† j) : (of X d sq).d i j = 0 := by\n  dsimp [of]\n  rw [dif_neg h]\n\n"}
{"name":"CochainComplex.ofHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms V\nŒ± : Type u_2\ninst‚úù¬≤ : AddRightCancelSemigroup Œ±\ninst‚úù¬π : One Œ±\ninst‚úù : DecidableEq Œ±\nX : Œ± ‚Üí V\nd_X : (n : Œ±) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq_X : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d_X n) (d_X (HAdd.hAdd n 1))) 0\nY : Œ± ‚Üí V\nd_Y : (n : Œ±) ‚Üí Quiver.Hom (Y n) (Y (HAdd.hAdd n 1))\nsq_Y : ‚àÄ (n : Œ±), Eq (CategoryTheory.CategoryStruct.comp (d_Y n) (d_Y (HAdd.hAdd n 1))) 0\nf : (i : Œ±) ‚Üí Quiver.Hom (X i) (Y i)\ncomm : ‚àÄ (i : Œ±), Eq (CategoryTheory.CategoryStruct.comp (f i) (d_Y i)) (CategoryTheory.CategoryStruct.comp (d_X i) (f (HAdd.hAdd i 1)))\ni : Œ±\n‚ä¢ Eq ((CochainComplex.ofHom X d_X sq_X Y d_Y sq_Y f comm).f i) (f i)","decl":"/--\nA constructor for chain maps between `Œ±`-indexed cochain complexes built using `CochainComplex.of`,\nfrom a dependently typed collection of morphisms.\n-/\n@[simps]\ndef ofHom (f : ‚àÄ i : Œ±, X i ‚ü∂ Y i) (comm : ‚àÄ i : Œ±, f i ‚â´ d_Y i = d_X i ‚â´ f (i + 1)) :\n    of X d_X sq_X ‚ü∂ of Y d_Y sq_Y :=\n  { f\n    comm' := fun n m => by\n      by_cases h : n + 1 = m\n      ¬∑ subst h\n        simpa using comm n\n      ¬∑ rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]\n        simp }\n\n"}
{"name":"CochainComplex.mk_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nd‚ÇÅ : Quiver.Hom X‚ÇÅ X‚ÇÇ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÄ d‚ÇÅ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÑ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp S.g d‚ÇÇ) 0\n‚ä¢ Eq ((CochainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 0) X‚ÇÄ","decl":"@[simp]\ntheorem mk_X_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 0 = X‚ÇÄ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nd‚ÇÅ : Quiver.Hom X‚ÇÅ X‚ÇÇ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÄ d‚ÇÅ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÑ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp S.g d‚ÇÇ) 0\n‚ä¢ Eq ((CochainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 1) X‚ÇÅ","decl":"@[simp]\ntheorem mk_X_1 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 1 = X‚ÇÅ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_X_2","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nd‚ÇÅ : Quiver.Hom X‚ÇÅ X‚ÇÇ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÄ d‚ÇÅ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÑ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp S.g d‚ÇÇ) 0\n‚ä¢ Eq ((CochainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 2) X‚ÇÇ","decl":"@[simp]\ntheorem mk_X_2 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).X 2 = X‚ÇÇ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nd‚ÇÅ : Quiver.Hom X‚ÇÅ X‚ÇÇ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÄ d‚ÇÅ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÑ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp S.g d‚ÇÇ) 0\n‚ä¢ Eq ((CochainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 0 1) d‚ÇÄ","decl":"@[simp]\ntheorem mk_d_1_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 0 1 = d‚ÇÄ := by\n  change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ\n  rw [if_pos rfl, Category.comp_id]\n\n"}
{"name":"CochainComplex.mk_d_2_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ X‚ÇÇ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nd‚ÇÅ : Quiver.Hom X‚ÇÅ X‚ÇÇ\ns : Eq (CategoryTheory.CategoryStruct.comp d‚ÇÄ d‚ÇÅ) 0\nsucc : (S : CategoryTheory.ShortComplex V) ‚Üí PSigma fun X‚ÇÑ => PSigma fun d‚ÇÇ => Eq (CategoryTheory.CategoryStruct.comp S.g d‚ÇÇ) 0\n‚ä¢ Eq ((CochainComplex.mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 2) d‚ÇÅ","decl":"@[simp]\ntheorem mk_d_2_0 : (mk X‚ÇÄ X‚ÇÅ X‚ÇÇ d‚ÇÄ d‚ÇÅ s succ).d 1 2 = d‚ÇÅ := by\n  change ite (2 = 1 + 1) (d‚ÇÅ ‚â´ ùüô X‚ÇÇ) 0 = d‚ÇÅ\n  rw [if_pos rfl, Category.comp_id]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"CochainComplex.mk'_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÄ X‚ÇÅ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n‚ä¢ Eq ((CochainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').X 0) X‚ÇÄ","decl":"@[simp]\ntheorem mk'_X_0 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').X 0 = X‚ÇÄ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk'_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÄ X‚ÇÅ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n‚ä¢ Eq ((CochainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').X 1) X‚ÇÅ","decl":"@[simp]\ntheorem mk'_X_1 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').X 1 = X‚ÇÅ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk'_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nX‚ÇÄ X‚ÇÅ : V\nd‚ÇÄ : Quiver.Hom X‚ÇÄ X‚ÇÅ\nsucc' : {X‚ÇÄ X‚ÇÅ : V} ‚Üí (f : Quiver.Hom X‚ÇÄ X‚ÇÅ) ‚Üí PSigma fun X‚ÇÇ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n‚ä¢ Eq ((CochainComplex.mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ fun {X‚ÇÄ X‚ÇÅ} => succ').d 0 1) d‚ÇÄ","decl":"@[simp]\ntheorem mk'_d_1_0 : (mk' X‚ÇÄ X‚ÇÅ d‚ÇÄ succ').d 0 1 = d‚ÇÄ := by\n  change ite (1 = 0 + 1) (d‚ÇÄ ‚â´ ùüô X‚ÇÅ) 0 = d‚ÇÄ\n  rw [if_pos rfl, Category.comp_id]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"CochainComplex.mkHom_f_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 0) zero","decl":"@[simp]\ntheorem mkHom_f_0 : (mkHom P Q zero one one_zero_comm succ).f 0 = zero :=\n  rfl\n\n"}
{"name":"CochainComplex.mkHom_f_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 1) one","decl":"@[simp]\ntheorem mkHom_f_1 : (mkHom P Q zero one one_zero_comm succ).f 1 = one :=\n  rfl\n\n"}
{"name":"CochainComplex.mkHom_f_succ_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) ‚Üí (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) ‚Üí PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\nn : Nat\n‚ä¢ Eq ((P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 2)) (succ n ‚ü®(P.mkHom Q zero one one_zero_comm succ).f n, ‚ü®(P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 1), ‚ãØ‚ü©‚ü©).fst","decl":"@[simp]\ntheorem mkHom_f_succ_succ (n : ‚Ñï) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          ‚ü®(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm n (n + 1)‚ü©).1 := by\n  dsimp [mkHom, mkHomAux]\n\n"}
