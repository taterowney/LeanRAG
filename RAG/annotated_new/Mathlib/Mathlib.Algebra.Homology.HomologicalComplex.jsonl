{"name":"HomologicalComplex.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf V\nX : ι → V\nd : (i j : ι) → Quiver.Hom (X i) (X j)\nshape : autoParam (∀ (i j : ι), Not (c.Rel i j) → Eq (d i j) 0) _auto✝\nd_comp_d' : autoParam (∀ (i j k : ι), c.Rel i j → c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto✝\n⊢ Eq (SizeOf.sizeOf { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }) 1","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape ι`\nhas chain groups `X i` (objects in `V`) indexed by `i : ι`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : ι`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ≫ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape ι) where\n  X : ι → V\n  d : ∀ i j, X i ⟶ X j\n  shape : ∀ i j, ¬c.Rel i j → d i j = 0 := by aesop_cat\n  d_comp_d' : ∀ i j k, c.Rel i j → c.Rel j k → d i j ≫ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.mk.inj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nX✝ : ι → V\nd✝ : (i j : ι) → Quiver.Hom (X✝ i) (X✝ j)\nshape✝ : autoParam (∀ (i j : ι), Not (c.Rel i j) → Eq (d✝ i j) 0) _auto✝\nd_comp_d'✝ : autoParam (∀ (i j k : ι), c.Rel i j → c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp (d✝ i j) (d✝ j k)) 0) _auto✝\nX : ι → V\nd : (i j : ι) → Quiver.Hom (X i) (X j)\nshape : autoParam (∀ (i j : ι), Not (c.Rel i j) → Eq (d i j) 0) _auto✝\nd_comp_d' : autoParam (∀ (i j k : ι), c.Rel i j → c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto✝\nx✝ : Eq { X := X✝, d := d✝, shape := shape✝, d_comp_d' := d_comp_d'✝ } { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }\n⊢ And (Eq X✝ X) (HEq d✝ d)","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape ι`\nhas chain groups `X i` (objects in `V`) indexed by `i : ι`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : ι`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ≫ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape ι) where\n  X : ι → V\n  d : ∀ i j, X i ⟶ X j\n  shape : ∀ i j, ¬c.Rel i j → d i j = 0 := by aesop_cat\n  d_comp_d' : ∀ i j k, c.Rel i j → c.Rel j k → d i j ≫ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.d_comp_d'","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nself : HomologicalComplex V c\ni j k : ι\na✝¹ : c.Rel i j\na✝ : c.Rel j k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.d i j) (self.d j k)) 0","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape ι`\nhas chain groups `X i` (objects in `V`) indexed by `i : ι`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : ι`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ≫ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape ι) where\n  X : ι → V\n  d : ∀ i j, X i ⟶ X j\n  shape : ∀ i j, ¬c.Rel i j → d i j = 0 := by aesop_cat\n  d_comp_d' : ∀ i j k, c.Rel i j → c.Rel j k → d i j ≫ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.mk.injEq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nX✝ : ι → V\nd✝ : (i j : ι) → Quiver.Hom (X✝ i) (X✝ j)\nshape✝ : autoParam (∀ (i j : ι), Not (c.Rel i j) → Eq (d✝ i j) 0) _auto✝\nd_comp_d'✝ : autoParam (∀ (i j k : ι), c.Rel i j → c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp (d✝ i j) (d✝ j k)) 0) _auto✝\nX : ι → V\nd : (i j : ι) → Quiver.Hom (X i) (X j)\nshape : autoParam (∀ (i j : ι), Not (c.Rel i j) → Eq (d i j) 0) _auto✝\nd_comp_d' : autoParam (∀ (i j k : ι), c.Rel i j → c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp (d i j) (d j k)) 0) _auto✝\n⊢ Eq (Eq { X := X✝, d := d✝, shape := shape✝, d_comp_d' := d_comp_d'✝ } { X := X, d := d, shape := shape, d_comp_d' := d_comp_d' }) (And (Eq X✝ X) (HEq d✝ d))","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape ι`\nhas chain groups `X i` (objects in `V`) indexed by `i : ι`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : ι`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ≫ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape ι) where\n  X : ι → V\n  d : ∀ i j, X i ⟶ X j\n  shape : ∀ i j, ¬c.Rel i j → d i j = 0 := by aesop_cat\n  d_comp_d' : ∀ i j k, c.Rel i j → c.Rel j k → d i j ≫ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.shape","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nself : HomologicalComplex V c\ni j : ι\na✝ : Not (c.Rel i j)\n⊢ Eq (self.d i j) 0","decl":"/-- A `HomologicalComplex V c` with a \"shape\" controlled by `c : ComplexShape ι`\nhas chain groups `X i` (objects in `V`) indexed by `i : ι`,\nand a differential `d i j` whenever `c.Rel i j`.\n\nWe in fact ask for differentials `d i j` for all `i j : ι`,\nbut have a field `shape` requiring that these are zero when not allowed by `c`.\nThis avoids a lot of dependent type theory hell!\n\nThe composite of any two differentials `d i j ≫ d j k` must be zero.\n-/\nstructure HomologicalComplex (c : ComplexShape ι) where\n  X : ι → V\n  d : ∀ i j, X i ⟶ X j\n  shape : ∀ i j, ¬c.Rel i j → d i j = 0 := by aesop_cat\n  d_comp_d' : ∀ i j k, c.Rel i j → c.Rel j k → d i j ≫ d j k = 0 := by aesop_cat\n\n"}
{"name":"HomologicalComplex.d_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j k : ι\nZ : V\nh : Quiver.Hom (C.X k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j) (CategoryTheory.CategoryStruct.comp (C.d j k) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem d_comp_d (C : HomologicalComplex V c) (i j k : ι) : C.d i j ≫ C.d j k = 0 := by\n  by_cases hij : c.Rel i j\n  · by_cases hjk : c.Rel j k\n    · exact C.d_comp_d' i j k hij hjk\n    · rw [C.shape j k hjk, comp_zero]\n  · rw [C.shape i j hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.d_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j k : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j) (C.d j k)) 0","decl":"@[reassoc (attr := simp)]\ntheorem d_comp_d (C : HomologicalComplex V c) (i j k : ι) : C.d i j ≫ C.d j k = 0 := by\n  by_cases hij : c.Rel i j\n  · by_cases hjk : c.Rel j k\n    · exact C.d_comp_d' i j k hij hjk\n    · rw [C.shape j k hjk, comp_zero]\n  · rw [C.shape i j hij, zero_comp]\n\n"}
{"name":"HomologicalComplex.ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nh_X : Eq C₁.X C₂.X\nh_d : ∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (C₁.d i j) (CategoryTheory.eqToHom ⋯)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (C₂.d i j))\n⊢ Eq C₁ C₂","decl":"theorem ext {C₁ C₂ : HomologicalComplex V c} (h_X : C₁.X = C₂.X)\n    (h_d :\n      ∀ i j : ι,\n        c.Rel i j → C₁.d i j ≫ eqToHom (congr_fun h_X j) = eqToHom (congr_fun h_X i) ≫ C₂.d i j) :\n    C₁ = C₂ := by\n  obtain ⟨X₁, d₁, s₁, h₁⟩ := C₁\n  obtain ⟨X₂, d₂, s₂, h₂⟩ := C₂\n  dsimp at h_X\n  subst h_X\n  simp only [mk.injEq, heq_eq_eq, true_and]\n  ext i j\n  by_cases hij : c.Rel i j\n  · simpa only [comp_id, id_comp, eqToHom_refl] using h_d i j hij\n  · rw [s₁ i j hij, s₂ i j hij]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_rfl","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np : ι\n⊢ Eq (K.XIsoOfEq ⋯) (CategoryTheory.Iso.refl (K.X p))","decl":"@[simp]\nlemma XIsoOfEq_rfl (K : HomologicalComplex V c) (p : ι) :\n    K.XIsoOfEq (rfl : p = p) = Iso.refl _ := rfl\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₁₂ : Eq p₁ p₂\nh₂₃ : Eq p₂ p₃\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₁₂).hom (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₃).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₁₂ : p₁ = p₂) (h₂₃ : p₂ = p₃) :\n    (K.XIsoOfEq h₁₂).hom ≫ (K.XIsoOfEq h₂₃).hom = (K.XIsoOfEq (h₁₂.trans h₂₃)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₁₂ : Eq p₁ p₂\nh₂₃ : Eq p₂ p₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₁₂).hom (K.XIsoOfEq h₂₃).hom) (K.XIsoOfEq ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₁₂ : p₁ = p₂) (h₂₃ : p₂ = p₃) :\n    (K.XIsoOfEq h₁₂).hom ≫ (K.XIsoOfEq h₂₃).hom = (K.XIsoOfEq (h₁₂.trans h₂₃)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₁₂ : Eq p₁ p₂\nh₃₂ : Eq p₃ p₂\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₁₂).hom (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₃₂).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₁₂ : p₁ = p₂) (h₃₂ : p₃ = p₂) :\n    (K.XIsoOfEq h₁₂).hom ≫ (K.XIsoOfEq h₃₂).inv = (K.XIsoOfEq (h₁₂.trans h₃₂.symm)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₁₂ : Eq p₁ p₂\nh₃₂ : Eq p₃ p₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₁₂).hom (K.XIsoOfEq h₃₂).inv) (K.XIsoOfEq ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₁₂ : p₁ = p₂) (h₃₂ : p₃ = p₂) :\n    (K.XIsoOfEq h₁₂).hom ≫ (K.XIsoOfEq h₃₂).inv = (K.XIsoOfEq (h₁₂.trans h₃₂.symm)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₂₁ : Eq p₂ p₁\nh₂₃ : Eq p₂ p₃\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₁).inv (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₃).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₂₁ : p₂ = p₁) (h₂₃ : p₂ = p₃) :\n    (K.XIsoOfEq h₂₁).inv ≫ (K.XIsoOfEq h₂₃).hom = (K.XIsoOfEq (h₂₁.symm.trans h₂₃)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₂₁ : Eq p₂ p₁\nh₂₃ : Eq p₂ p₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₁).inv (K.XIsoOfEq h₂₃).hom) (K.XIsoOfEq ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₂₁ : p₂ = p₁) (h₂₃ : p₂ = p₃) :\n    (K.XIsoOfEq h₂₁).inv ≫ (K.XIsoOfEq h₂₃).hom = (K.XIsoOfEq (h₂₁.symm.trans h₂₃)).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₂₁ : Eq p₂ p₁\nh₃₂ : Eq p₃ p₂\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₁).inv (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₃₂).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq ⋯).hom h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₂₁ : p₂ = p₁) (h₃₂ : p₃ = p₂) :\n    (K.XIsoOfEq h₂₁).inv ≫ (K.XIsoOfEq h₃₂).inv = (K.XIsoOfEq (h₃₂.trans h₂₁).symm).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ p₃ : ι\nh₂₁ : Eq p₂ p₁\nh₃₂ : Eq p₃ p₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h₂₁).inv (K.XIsoOfEq h₃₂).inv) (K.XIsoOfEq ⋯).hom","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₁ p₂ p₃ : ι}\n    (h₂₁ : p₂ = p₁) (h₃₂ : p₃ = p₂) :\n    (K.XIsoOfEq h₂₁).inv ≫ (K.XIsoOfEq h₃₂).inv = (K.XIsoOfEq (h₃₂.trans h₂₁).symm).hom := by\n  dsimp [XIsoOfEq]\n  simp only [eqToHom_trans]\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ : ι\nh : Eq p₁ p₂\np₃ : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).hom (K.d p₂ p₃)) (K.d p₁ p₃)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_d (K : HomologicalComplex V c) {p₁ p₂ : ι} (h : p₁ = p₂) (p₃ : ι) :\n    (K.XIsoOfEq h).hom ≫ K.d p₂ p₃ = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₁ p₂ : ι\nh✝ : Eq p₁ p₂\np₃ : ι\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).hom (CategoryTheory.CategoryStruct.comp (K.d p₂ p₃) h)) (CategoryTheory.CategoryStruct.comp (K.d p₁ p₃) h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_hom_comp_d (K : HomologicalComplex V c) {p₁ p₂ : ι} (h : p₁ = p₂) (p₃ : ι) :\n    (K.XIsoOfEq h).hom ≫ K.d p₂ p₃ = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₁ : ι\nh : Eq p₂ p₁\np₃ : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).inv (K.d p₂ p₃)) (K.d p₁ p₃)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_d (K : HomologicalComplex V c) {p₂ p₁ : ι} (h : p₂ = p₁) (p₃ : ι) :\n    (K.XIsoOfEq h).inv ≫ K.d p₂ p₃ = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_comp_d_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₁ : ι\nh✝ : Eq p₂ p₁\np₃ : ι\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).inv (CategoryTheory.CategoryStruct.comp (K.d p₂ p₃) h)) (CategoryTheory.CategoryStruct.comp (K.d p₁ p₃) h)","decl":"@[reassoc (attr := simp)]\nlemma XIsoOfEq_inv_comp_d (K : HomologicalComplex V c) {p₂ p₁ : ι} (h : p₂ = p₁) (p₃ : ι) :\n    (K.XIsoOfEq h).inv ≫ K.d p₂ p₃ = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_hom_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₃ : ι\nh✝ : Eq p₂ p₃\np₁ : ι\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d p₁ p₂) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).hom h)) (CategoryTheory.CategoryStruct.comp (K.d p₁ p₃) h)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₂ p₃ : ι} (h : p₂ = p₃) (p₁ : ι) :\n    K.d p₁ p₂ ≫ (K.XIsoOfEq h).hom = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₃ : ι\nh : Eq p₂ p₃\np₁ : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d p₁ p₂) (K.XIsoOfEq h).hom) (K.d p₁ p₃)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_hom (K : HomologicalComplex V c) {p₂ p₃ : ι} (h : p₂ = p₃) (p₁ : ι) :\n    K.d p₁ p₂ ≫ (K.XIsoOfEq h).hom = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_inv_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₃ : ι\nh✝ : Eq p₃ p₂\np₁ : ι\nZ : V\nh : Quiver.Hom (K.X p₃) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d p₁ p₂) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).inv h)) (CategoryTheory.CategoryStruct.comp (K.d p₁ p₃) h)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₂ p₃ : ι} (h : p₃ = p₂) (p₁ : ι) :\n    K.d p₁ p₂ ≫ (K.XIsoOfEq h).inv = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"HomologicalComplex.d_comp_XIsoOfEq_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK : HomologicalComplex V c\np₂ p₃ : ι\nh : Eq p₃ p₂\np₁ : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d p₁ p₂) (K.XIsoOfEq h).inv) (K.d p₁ p₃)","decl":"@[reassoc (attr := simp)]\nlemma d_comp_XIsoOfEq_inv (K : HomologicalComplex V c) {p₂ p₃ : ι} (h : p₃ = p₂) (p₁ : ι) :\n    K.d p₁ p₂ ≫ (K.XIsoOfEq h).inv = K.d p₁ p₃ := by subst h; simp\n\n"}
{"name":"ChainComplex.prev","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"α : Type u_2\ninst✝¹ : AddRightCancelSemigroup α\ninst✝ : One α\ni : α\n⊢ Eq ((ComplexShape.down α).prev i) (HAdd.hAdd i 1)","decl":"@[simp]\ntheorem prev (α : Type*) [AddRightCancelSemigroup α] [One α] (i : α) :\n    (ComplexShape.down α).prev i = i + 1 :=\n  (ComplexShape.down α).prev_eq' rfl\n\n"}
{"name":"ChainComplex.next","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : One α\ni : α\n⊢ Eq ((ComplexShape.down α).next i) (HSub.hSub i 1)","decl":"@[simp]\ntheorem next (α : Type*) [AddGroup α] [One α] (i : α) : (ComplexShape.down α).next i = i - 1 :=\n  (ComplexShape.down α).next_eq' <| sub_add_cancel _ _\n\n"}
{"name":"ChainComplex.next_nat_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"⊢ Eq ((ComplexShape.down Nat).next 0) 0","decl":"@[simp]\ntheorem next_nat_zero : (ComplexShape.down ℕ).next 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n\n"}
{"name":"ChainComplex.next_nat_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"i : Nat\n⊢ Eq ((ComplexShape.down Nat).next (HAdd.hAdd i 1)) i","decl":"@[simp]\ntheorem next_nat_succ (i : ℕ) : (ComplexShape.down ℕ).next (i + 1) = i :=\n  (ComplexShape.down ℕ).next_eq' rfl\n\n"}
{"name":"CochainComplex.prev","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"α : Type u_2\ninst✝¹ : AddGroup α\ninst✝ : One α\ni : α\n⊢ Eq ((ComplexShape.up α).prev i) (HSub.hSub i 1)","decl":"@[simp]\ntheorem prev (α : Type*) [AddGroup α] [One α] (i : α) : (ComplexShape.up α).prev i = i - 1 :=\n  (ComplexShape.up α).prev_eq' <| sub_add_cancel _ _\n\n"}
{"name":"CochainComplex.next","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"α : Type u_2\ninst✝¹ : AddRightCancelSemigroup α\ninst✝ : One α\ni : α\n⊢ Eq ((ComplexShape.up α).next i) (HAdd.hAdd i 1)","decl":"@[simp]\ntheorem next (α : Type*) [AddRightCancelSemigroup α] [One α] (i : α) :\n    (ComplexShape.up α).next i = i + 1 :=\n  (ComplexShape.up α).next_eq' rfl\n\n"}
{"name":"CochainComplex.prev_nat_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"⊢ Eq ((ComplexShape.up Nat).prev 0) 0","decl":"@[simp]\ntheorem prev_nat_zero : (ComplexShape.up ℕ).prev 0 = 0 := by\n  classical\n    refine dif_neg ?_\n    push_neg\n    intro\n    apply Nat.noConfusion\n\n"}
{"name":"CochainComplex.prev_nat_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"i : Nat\n⊢ Eq ((ComplexShape.up Nat).prev (HAdd.hAdd i 1)) i","decl":"@[simp]\ntheorem prev_nat_succ (i : ℕ) : (ComplexShape.up ℕ).prev (i + 1) = i :=\n  (ComplexShape.up ℕ).prev_eq' rfl\n\n"}
{"name":"HomologicalComplex.Hom.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf V\nf : (i : ι) → Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, comm' := comm' }) 1","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nx y : A.Hom B\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.comm'","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nself : A.Hom B\ni j : ι\na✝ : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (self.f j))","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.ext_iff","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nx y : A.Hom B\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.mk.inj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nf✝ : (i : ι) → Quiver.Hom (A.X i) (B.X i)\ncomm'✝ : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f✝ i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f✝ j))) _auto✝\nf : (i : ι) → Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto✝\nx✝ : Eq { f := f✝, comm' := comm'✝ } { f := f, comm' := comm' }\n⊢ Eq f✝ f","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.mk.injEq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nf✝ : (i : ι) → Quiver.Hom (A.X i) (B.X i)\ncomm'✝ : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f✝ i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f✝ j))) _auto✝\nf : (i : ι) → Quiver.Hom (A.X i) (B.X i)\ncomm' : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f j))) _auto✝\n⊢ Eq (Eq { f := f✝, comm' := comm'✝ } { f := f, comm' := comm' }) (Eq f✝ f)","decl":"/-- A morphism of homological complexes consists of maps between the chain groups,\ncommuting with the differentials.\n-/\n@[ext]\nstructure Hom (A B : HomologicalComplex V c) where\n  f : ∀ i, A.X i ⟶ B.X i\n  comm' : ∀ i j, c.Rel i j → f i ≫ B.d i j = A.d i j ≫ f j := by aesop_cat\n\n"}
{"name":"HomologicalComplex.Hom.comm_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : ι\nZ : V\nh : Quiver.Hom (B.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (B.d i j) h)) (CategoryTheory.CategoryStruct.comp (A.d i j) (CategoryTheory.CategoryStruct.comp (f.f j) h))","decl":"@[reassoc (attr := simp)]\ntheorem Hom.comm {A B : HomologicalComplex V c} (f : A.Hom B) (i j : ι) :\n    f.f i ≫ B.d i j = A.d i j ≫ f.f j := by\n  by_cases hij : c.Rel i j\n  · exact f.comm' i j hij\n  · rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.Hom.comm","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nA B : HomologicalComplex V c\nf : A.Hom B\ni j : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (B.d i j)) (CategoryTheory.CategoryStruct.comp (A.d i j) (f.f j))","decl":"@[reassoc (attr := simp)]\ntheorem Hom.comm {A B : HomologicalComplex V c} (f : A.Hom B) (i j : ι) :\n    f.f i ≫ B.d i j = A.d i j ≫ f.f j := by\n  by_cases hij : c.Rel i j\n  · exact f.comm' i j hij\n  · rw [A.shape i j hij, B.shape i j hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.hom_ext_iff","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.f i) (g.f i))","decl":"@[ext]\nlemma hom_ext {C D : HomologicalComplex V c} (f g : C ⟶ D)\n    (h : ∀ i, f.f i = g.f i) : f = g := by\n  apply Hom.ext\n  funext\n  apply h\n\n"}
{"name":"HomologicalComplex.hom_ext","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : ∀ (i : ι), Eq (f.f i) (g.f i)\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {C D : HomologicalComplex V c} (f g : C ⟶ D)\n    (h : ∀ i, f.f i = g.f i) : f = g := by\n  apply Hom.ext\n  funext\n  apply h\n\n"}
{"name":"HomologicalComplex.id_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni : ι\n⊢ Eq ((CategoryTheory.CategoryStruct.id C).f i) (CategoryTheory.CategoryStruct.id (C.X i))","decl":"@[simp]\ntheorem id_f (C : HomologicalComplex V c) (i : ι) : Hom.f (𝟙 C) i = 𝟙 (C.X i) :=\n  rfl\n\n"}
{"name":"HomologicalComplex.comp_f_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ C₃ : HomologicalComplex V c\nf : Quiver.Hom C₁ C₂\ng : Quiver.Hom C₂ C₃\ni : ι\nZ : V\nh : Quiver.Hom (C₃.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp f g).f i) h) (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (g.f i) h))","decl":"@[simp, reassoc]\ntheorem comp_f {C₁ C₂ C₃ : HomologicalComplex V c} (f : C₁ ⟶ C₂) (g : C₂ ⟶ C₃) (i : ι) :\n    (f ≫ g).f i = f.f i ≫ g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.comp_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ C₃ : HomologicalComplex V c\nf : Quiver.Hom C₁ C₂\ng : Quiver.Hom C₂ C₃\ni : ι\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).f i) (CategoryTheory.CategoryStruct.comp (f.f i) (g.f i))","decl":"@[simp, reassoc]\ntheorem comp_f {C₁ C₂ C₃ : HomologicalComplex V c} (f : C₁ ⟶ C₂) (g : C₂ ⟶ C₃) (i : ι) :\n    (f ≫ g).f i = f.f i ≫ g.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.eqToHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nh : Eq C₁ C₂\nn : ι\n⊢ Eq ((CategoryTheory.eqToHom h).f n) (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_f {C₁ C₂ : HomologicalComplex V c} (h : C₁ = C₂) (n : ι) :\n    HomologicalComplex.Hom.f (eqToHom h) n =\n      eqToHom (congr_fun (congr_arg HomologicalComplex.X h) n) := by\n  subst h\n  rfl\n\n-- We'll use this later to show that `HomologicalComplex V c` is preadditive when `V` is.\n"}
{"name":"HomologicalComplex.hom_f_injective","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\n⊢ Function.Injective fun f => f.f","decl":"theorem hom_f_injective {C₁ C₂ : HomologicalComplex V c} :\n    Function.Injective fun f : Hom C₁ C₂ => f.f := by aesop_cat\n\n"}
{"name":"HomologicalComplex.zero_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC D : HomologicalComplex V c\ni : ι\n⊢ Eq (HomologicalComplex.Hom.f 0 i) 0","decl":"@[simp]\ntheorem zero_f (C D : HomologicalComplex V c) (i : ι) : (0 : C ⟶ D).f i = 0 :=\n  rfl\n\n"}
{"name":"HomologicalComplex.isZero_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroObject V\n⊢ CategoryTheory.Limits.IsZero HomologicalComplex.zero","decl":"theorem isZero_zero [HasZeroObject V] : IsZero (zero : HomologicalComplex V c) := by\n  refine ⟨fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩, fun X => ⟨⟨⟨0⟩, fun f => ?_⟩⟩⟩\n  all_goals\n    ext\n    dsimp only [zero]\n    subsingleton\n\n"}
{"name":"HomologicalComplex.instHasZeroObject","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ninst✝ : CategoryTheory.Limits.HasZeroObject V\n⊢ CategoryTheory.Limits.HasZeroObject (HomologicalComplex V c)","decl":"instance [HasZeroObject V] : HasZeroObject (HomologicalComplex V c) :=\n  ⟨⟨zero, isZero_zero⟩⟩\n\n"}
{"name":"HomologicalComplex.congr_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nw : Eq f g\ni : ι\n⊢ Eq (f.f i) (g.f i)","decl":"theorem congr_hom {C D : HomologicalComplex V c} {f g : C ⟶ D} (w : f = g) (i : ι) :\n    f.f i = g.f i :=\n  congr_fun (congr_arg Hom.f w) i\n\n"}
{"name":"HomologicalComplex.mono_of_mono_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nhφ : ∀ (i : ι), CategoryTheory.Mono (φ.f i)\n⊢ CategoryTheory.Mono φ","decl":"lemma mono_of_mono_f {K L : HomologicalComplex V c} (φ : K ⟶ L)\n    (hφ : ∀ i, Mono (φ.f i)) : Mono φ where\n  right_cancellation g h eq := by\n    ext i\n    rw [← cancel_mono (φ.f i)]\n    exact congr_hom eq i\n\n"}
{"name":"HomologicalComplex.epi_of_epi_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nhφ : ∀ (i : ι), CategoryTheory.Epi (φ.f i)\n⊢ CategoryTheory.Epi φ","decl":"lemma epi_of_epi_f {K L : HomologicalComplex V c} (φ : K ⟶ L)\n    (hφ : ∀ i, Epi (φ.f i)) : Epi φ where\n  left_cancellation g h eq := by\n    ext i\n    rw [← cancel_epi (φ.f i)]\n    exact congr_hom eq i\n\n"}
{"name":"HomologicalComplex.eval_obj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ni : ι\nC : HomologicalComplex V c\n⊢ Eq ((HomologicalComplex.eval V c i).obj C) (C.X i)","decl":"/-- The functor picking out the `i`-th object of a complex. -/\n@[simps]\ndef eval (i : ι) : HomologicalComplex V c ⥤ V where\n  obj C := C.X i\n  map f := f.f i\n\n"}
{"name":"HomologicalComplex.eval_map","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ni : ι\nX✝ Y✝ : HomologicalComplex V c\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((HomologicalComplex.eval V c i).map f) (f.f i)","decl":"/-- The functor picking out the `i`-th object of a complex. -/\n@[simps]\ndef eval (i : ι) : HomologicalComplex V c ⥤ V where\n  obj C := C.X i\n  map f := f.f i\n\n"}
{"name":"HomologicalComplex.instPreservesZeroMorphismsEval","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ni : ι\n⊢ (HomologicalComplex.eval V c i).PreservesZeroMorphisms","decl":"instance (i : ι) : (eval V c i).PreservesZeroMorphisms where\n\n"}
{"name":"HomologicalComplex.forget_map","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nX✝ Y✝ : HomologicalComplex V c\nf : Quiver.Hom X✝ Y✝\ni : ι\n⊢ Eq ((HomologicalComplex.forget V c).map f i) (f.f i)","decl":"/-- The functor forgetting the differential in a complex, obtaining a graded object. -/\n@[simps]\ndef forget : HomologicalComplex V c ⥤ GradedObject ι V where\n  obj C := C.X\n  map f := f.f\n\n"}
{"name":"HomologicalComplex.forget_obj","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\na✝ : ι\n⊢ Eq ((HomologicalComplex.forget V c).obj C a✝) (C.X a✝)","decl":"/-- The functor forgetting the differential in a complex, obtaining a graded object. -/\n@[simps]\ndef forget : HomologicalComplex V c ⥤ GradedObject ι V where\n  obj C := C.X\n  map f := f.f\n\n"}
{"name":"HomologicalComplex.instFaithfulGradedObjectForget","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\n⊢ (HomologicalComplex.forget V c).Faithful","decl":"instance : (forget V c).Faithful where\n  map_injective h := by\n    ext i\n    exact congr_fun h i\n\n"}
{"name":"HomologicalComplex.forgetEval_hom_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ni : ι\nX : HomologicalComplex V c\n⊢ Eq ((HomologicalComplex.forgetEval V c i).hom.app X) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- Forgetting the differentials than picking out the `i`-th object is the same as\njust picking out the `i`-th object. -/\n@[simps!]\ndef forgetEval (i : ι) : forget V c ⋙ GradedObject.eval i ≅ eval V c i :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"HomologicalComplex.forgetEval_inv_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\ni : ι\nX : HomologicalComplex V c\n⊢ Eq ((HomologicalComplex.forgetEval V c i).inv.app X) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- Forgetting the differentials than picking out the `i`-th object is the same as\njust picking out the `i`-th object. -/\n@[simps!]\ndef forgetEval (i : ι) : forget V c ⋙ GradedObject.eval i ≅ eval V c i :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_naturality","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nn n' : ι\nh : Eq n n'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (φ.f n) (L.XIsoOfEq h).hom) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).hom (φ.f n'))","decl":"@[reassoc]\nlemma XIsoOfEq_hom_naturality {K L : HomologicalComplex V c} (φ : K ⟶ L) {n n' : ι} (h : n = n') :\n    φ.f n ≫ (L.XIsoOfEq h).hom = (K.XIsoOfEq h).hom ≫ φ.f n' := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nn n' : ι\nh✝ : Eq n n'\nZ : V\nh : Quiver.Hom (L.X n') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (φ.f n) (CategoryTheory.CategoryStruct.comp (L.XIsoOfEq h✝).hom h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).hom (CategoryTheory.CategoryStruct.comp (φ.f n') h))","decl":"@[reassoc]\nlemma XIsoOfEq_hom_naturality {K L : HomologicalComplex V c} (φ : K ⟶ L) {n n' : ι} (h : n = n') :\n    φ.f n ≫ (L.XIsoOfEq h).hom = (K.XIsoOfEq h).hom ≫ φ.f n' := by subst h; simp\n\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nn n' : ι\nh✝ : Eq n n'\nZ : V\nh : Quiver.Hom (L.X n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (φ.f n') (CategoryTheory.CategoryStruct.comp (L.XIsoOfEq h✝).inv h)) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h✝).inv (CategoryTheory.CategoryStruct.comp (φ.f n) h))","decl":"@[reassoc]\nlemma XIsoOfEq_inv_naturality {K L : HomologicalComplex V c} (φ : K ⟶ L) {n n' : ι} (h : n = n') :\n    φ.f n' ≫ (L.XIsoOfEq h).inv = (K.XIsoOfEq h).inv ≫ φ.f n := by subst h; simp\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.XIsoOfEq_inv_naturality","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nK L : HomologicalComplex V c\nφ : Quiver.Hom K L\nn n' : ι\nh : Eq n n'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (φ.f n') (L.XIsoOfEq h).inv) (CategoryTheory.CategoryStruct.comp (K.XIsoOfEq h).inv (φ.f n))","decl":"@[reassoc]\nlemma XIsoOfEq_inv_naturality {K L : HomologicalComplex V c} (φ : K ⟶ L) {n n' : ι} (h : n = n') :\n    φ.f n' ≫ (L.XIsoOfEq h).inv = (K.XIsoOfEq h).inv ≫ φ.f n := by subst h; simp\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.d_comp_eqToHom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j j' : ι\nrij : c.Rel i j\nrij' : c.Rel i j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.d i j') (CategoryTheory.eqToHom ⋯)) (C.d i j)","decl":"/-- If `C.d i j` and `C.d i j'` are both allowed, then we must have `j = j'`,\nand so the differentials only differ by an `eqToHom`.\n-/\ntheorem d_comp_eqToHom {i j j' : ι} (rij : c.Rel i j) (rij' : c.Rel i j') :\n    C.d i j' ≫ eqToHom (congr_arg C.X (c.next_eq rij' rij)) = C.d i j := by\n  obtain rfl := c.next_eq rij rij'\n  simp only [eqToHom_refl, comp_id]\n\n-- Porting note: removed @[simp] as the linter complained\n"}
{"name":"HomologicalComplex.eqToHom_comp_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni i' j : ι\nrij : c.Rel i j\nrij' : c.Rel i' j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (C.d i' j)) (C.d i j)","decl":"/-- If `C.d i j` and `C.d i' j` are both allowed, then we must have `i = i'`,\nand so the differentials only differ by an `eqToHom`.\n-/\ntheorem eqToHom_comp_d {i i' j : ι} (rij : c.Rel i j) (rij' : c.Rel i' j) :\n    eqToHom (congr_arg C.X (c.prev_eq rij rij')) ≫ C.d i' j = C.d i j := by\n  obtain rfl := c.prev_eq rij rij'\n  simp only [eqToHom_refl, id_comp]\n\n"}
{"name":"HomologicalComplex.kernel_eq_kernel","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ninst✝ : CategoryTheory.Limits.HasKernels V\ni j j' : ι\nr : c.Rel i j\nr' : c.Rel i j'\n⊢ Eq (CategoryTheory.Limits.kernelSubobject (C.d i j)) (CategoryTheory.Limits.kernelSubobject (C.d i j'))","decl":"theorem kernel_eq_kernel [HasKernels V] {i j j' : ι} (r : c.Rel i j) (r' : c.Rel i j') :\n    kernelSubobject (C.d i j) = kernelSubobject (C.d i j') := by\n  rw [← d_comp_eqToHom C r r']\n  apply kernelSubobject_comp_mono\n\n"}
{"name":"HomologicalComplex.image_eq_image","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ninst✝¹ : CategoryTheory.Limits.HasImages V\ninst✝ : CategoryTheory.Limits.HasEqualizers V\ni i' j : ι\nr : c.Rel i j\nr' : c.Rel i' j\n⊢ Eq (CategoryTheory.Limits.imageSubobject (C.d i j)) (CategoryTheory.Limits.imageSubobject (C.d i' j))","decl":"theorem image_eq_image [HasImages V] [HasEqualizers V] {i i' j : ι} (r : c.Rel i j)\n    (r' : c.Rel i' j) : imageSubobject (C.d i j) = imageSubobject (C.d i' j) := by\n  rw [← eqToHom_comp_d C r r']\n  apply imageSubobject_iso_comp\n\n"}
{"name":"HomologicalComplex.dTo_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\n⊢ Eq (C.dTo j) (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).hom (C.d i j))","decl":"theorem dTo_eq {i j : ι} (r : c.Rel i j) : C.dTo j = (C.xPrevIso r).hom ≫ C.d i j := by\n  obtain rfl := c.prev_eq' r\n  exact (Category.id_comp _).symm\n\n"}
{"name":"HomologicalComplex.dTo_eq_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\nj : ι\nh : Not (c.Rel (c.prev j) j)\n⊢ Eq (C.dTo j) 0","decl":"@[simp]\ntheorem dTo_eq_zero {j : ι} (h : ¬c.Rel (c.prev j) j) : C.dTo j = 0 :=\n  C.shape _ _ h\n\n"}
{"name":"HomologicalComplex.dFrom_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\n⊢ Eq (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.d i j) (C.xNextIso r).inv)","decl":"theorem dFrom_eq {i j : ι} (r : c.Rel i j) : C.dFrom i = C.d i j ≫ (C.xNextIso r).inv := by\n  obtain rfl := c.next_eq' r\n  exact (Category.comp_id _).symm\n\n"}
{"name":"HomologicalComplex.dFrom_eq_zero","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni : ι\nh : Not (c.Rel i (c.next i))\n⊢ Eq (C.dFrom i) 0","decl":"@[simp]\ntheorem dFrom_eq_zero {i : ι} (h : ¬c.Rel i (c.next i)) : C.dFrom i = 0 :=\n  C.shape _ _ h\n\n"}
{"name":"HomologicalComplex.xPrevIso_comp_dTo","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).inv (C.dTo j)) (C.d i j)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIso_comp_dTo {i j : ι} (r : c.Rel i j) : (C.xPrevIso r).inv ≫ C.dTo j = C.d i j := by\n  simp [C.dTo_eq r]\n\n"}
{"name":"HomologicalComplex.xPrevIso_comp_dTo_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\nZ : V\nh : Quiver.Hom (C.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIso r).inv (CategoryTheory.CategoryStruct.comp (C.dTo j) h)) (CategoryTheory.CategoryStruct.comp (C.d i j) h)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIso_comp_dTo {i j : ι} (r : c.Rel i j) : (C.xPrevIso r).inv ≫ C.dTo j = C.d i j := by\n  simp [C.dTo_eq r]\n\n"}
{"name":"HomologicalComplex.xPrevIsoSelf_comp_dTo","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\nj : ι\nh : Not (c.Rel (c.prev j) j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIsoSelf h).inv (C.dTo j)) 0","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIsoSelf_comp_dTo {j : ι} (h : ¬c.Rel (c.prev j) j) :\n    (C.xPrevIsoSelf h).inv ≫ C.dTo j = 0 := by simp [h]\n\n"}
{"name":"HomologicalComplex.xPrevIsoSelf_comp_dTo_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\nj : ι\nh✝ : Not (c.Rel (c.prev j) j)\nZ : V\nh : Quiver.Hom (C.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.xPrevIsoSelf h✝).inv (CategoryTheory.CategoryStruct.comp (C.dTo j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem xPrevIsoSelf_comp_dTo {j : ι} (h : ¬c.Rel (c.prev j) j) :\n    (C.xPrevIsoSelf h).inv ≫ C.dTo j = 0 := by simp [h]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIso","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (C.xNextIso r).hom) (C.d i j)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIso {i j : ι} (r : c.Rel i j) :\n    C.dFrom i ≫ (C.xNextIso r).hom = C.d i j := by\n  simp [C.dFrom_eq r]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIso_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni j : ι\nr : c.Rel i j\nZ : V\nh : Quiver.Hom (C.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.xNextIso r).hom h)) (CategoryTheory.CategoryStruct.comp (C.d i j) h)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIso {i j : ι} (r : c.Rel i j) :\n    C.dFrom i ≫ (C.xNextIso r).hom = C.d i j := by\n  simp [C.dFrom_eq r]\n\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIsoSelf_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni : ι\nh✝ : Not (c.Rel i (c.next i))\nZ : V\nh : Quiver.Hom (C.X i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (CategoryTheory.CategoryStruct.comp (C.xNextIsoSelf h✝).hom h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIsoSelf {i : ι} (h : ¬c.Rel i (c.next i)) :\n    C.dFrom i ≫ (C.xNextIsoSelf h).hom = 0 := by simp [h]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"HomologicalComplex.dFrom_comp_xNextIsoSelf","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ni : ι\nh : Not (c.Rel i (c.next i))\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.dFrom i) (C.xNextIsoSelf h).hom) 0","decl":"@[reassoc (attr := simp)]\ntheorem dFrom_comp_xNextIsoSelf {i : ι} (h : ¬c.Rel i (c.next i)) :\n    C.dFrom i ≫ (C.xNextIsoSelf h).hom = 0 := by simp [h]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"HomologicalComplex.dTo_comp_dFrom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (C.dTo j) (C.dFrom j)) 0","decl":"theorem dTo_comp_dFrom (j : ι) : C.dTo j ≫ C.dFrom j = 0 :=\n  C.d_comp_d _ _ _\n\n"}
{"name":"HomologicalComplex.kernel_from_eq_kernel","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ninst✝ : CategoryTheory.Limits.HasKernels V\ni j : ι\nr : c.Rel i j\n⊢ Eq (CategoryTheory.Limits.kernelSubobject (C.dFrom i)) (CategoryTheory.Limits.kernelSubobject (C.d i j))","decl":"theorem kernel_from_eq_kernel [HasKernels V] {i j : ι} (r : c.Rel i j) :\n    kernelSubobject (C.dFrom i) = kernelSubobject (C.d i j) := by\n  rw [C.dFrom_eq r]\n  apply kernelSubobject_comp_mono\n\n"}
{"name":"HomologicalComplex.image_to_eq_image","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC : HomologicalComplex V c\ninst✝¹ : CategoryTheory.Limits.HasImages V\ninst✝ : CategoryTheory.Limits.HasEqualizers V\ni j : ι\nr : c.Rel i j\n⊢ Eq (CategoryTheory.Limits.imageSubobject (C.dTo j)) (CategoryTheory.Limits.imageSubobject (C.d i j))","decl":"theorem image_to_eq_image [HasImages V] [HasEqualizers V] {i j : ι} (r : c.Rel i j) :\n    imageSubobject (C.dTo j) = imageSubobject (C.d i j) := by\n  rw [C.dTo_eq r]\n  apply imageSubobject_iso_comp\n\n"}
{"name":"HomologicalComplex.Hom.isoApp_inv","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : CategoryTheory.Iso C₁ C₂\ni : ι\n⊢ Eq (HomologicalComplex.Hom.isoApp f i).inv (f.inv.f i)","decl":"/-- The `i`-th component of an isomorphism of chain complexes. -/\n@[simps!]\ndef isoApp (f : C₁ ≅ C₂) (i : ι) : C₁.X i ≅ C₂.X i :=\n  (eval V c i).mapIso f\n\n"}
{"name":"HomologicalComplex.Hom.isoApp_hom","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : CategoryTheory.Iso C₁ C₂\ni : ι\n⊢ Eq (HomologicalComplex.Hom.isoApp f i).hom (f.hom.f i)","decl":"/-- The `i`-th component of an isomorphism of chain complexes. -/\n@[simps!]\ndef isoApp (f : C₁ ≅ C₂) (i : ι) : C₁.X i ≅ C₂.X i :=\n  (eval V c i).mapIso f\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_hom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : (i : ι) → CategoryTheory.Iso (C₁.X i) (C₂.X i)\nhf : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C₂.d i j)) (CategoryTheory.CategoryStruct.comp (C₁.d i j) (f j).hom)) _auto✝\ni : ι\n⊢ Eq ((HomologicalComplex.Hom.isoOfComponents f hf).hom.f i) (f i).hom","decl":"/-- Construct an isomorphism of chain complexes from isomorphism of the objects\nwhich commute with the differentials. -/\n@[simps]\ndef isoOfComponents (f : ∀ i, C₁.X i ≅ C₂.X i)\n    (hf : ∀ i j, c.Rel i j → (f i).hom ≫ C₂.d i j = C₁.d i j ≫ (f j).hom := by aesop_cat) :\n    C₁ ≅ C₂ where\n  hom :=\n    { f := fun i => (f i).hom\n      comm' := hf }\n  inv :=\n    { f := fun i => (f i).inv\n      comm' := fun i j hij =>\n        calc\n          (f i).inv ≫ C₁.d i j = (f i).inv ≫ (C₁.d i j ≫ (f j).hom) ≫ (f j).inv := by simp\n          _ = (f i).inv ≫ ((f i).hom ≫ C₂.d i j) ≫ (f j).inv := by rw [hf i j hij]\n          _ = C₂.d i j ≫ (f j).inv := by simp }\n  hom_inv_id := by\n    ext i\n    exact (f i).hom_inv_id\n  inv_hom_id := by\n    ext i\n    exact (f i).inv_hom_id\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_inv_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : (i : ι) → CategoryTheory.Iso (C₁.X i) (C₂.X i)\nhf : autoParam (∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C₂.d i j)) (CategoryTheory.CategoryStruct.comp (C₁.d i j) (f j).hom)) _auto✝\ni : ι\n⊢ Eq ((HomologicalComplex.Hom.isoOfComponents f hf).inv.f i) (f i).inv","decl":"/-- Construct an isomorphism of chain complexes from isomorphism of the objects\nwhich commute with the differentials. -/\n@[simps]\ndef isoOfComponents (f : ∀ i, C₁.X i ≅ C₂.X i)\n    (hf : ∀ i j, c.Rel i j → (f i).hom ≫ C₂.d i j = C₁.d i j ≫ (f j).hom := by aesop_cat) :\n    C₁ ≅ C₂ where\n  hom :=\n    { f := fun i => (f i).hom\n      comm' := hf }\n  inv :=\n    { f := fun i => (f i).inv\n      comm' := fun i j hij =>\n        calc\n          (f i).inv ≫ C₁.d i j = (f i).inv ≫ (C₁.d i j ≫ (f j).hom) ≫ (f j).inv := by simp\n          _ = (f i).inv ≫ ((f i).hom ≫ C₂.d i j) ≫ (f j).inv := by rw [hf i j hij]\n          _ = C₂.d i j ≫ (f j).inv := by simp }\n  hom_inv_id := by\n    ext i\n    exact (f i).hom_inv_id\n  inv_hom_id := by\n    ext i\n    exact (f i).inv_hom_id\n\n"}
{"name":"HomologicalComplex.Hom.isoOfComponents_app","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : (i : ι) → CategoryTheory.Iso (C₁.X i) (C₂.X i)\nhf : ∀ (i j : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (f i).hom (C₂.d i j)) (CategoryTheory.CategoryStruct.comp (C₁.d i j) (f j).hom)\ni : ι\n⊢ Eq (HomologicalComplex.Hom.isoApp (HomologicalComplex.Hom.isoOfComponents f hf) i) (f i)","decl":"@[simp]\ntheorem isoOfComponents_app (f : ∀ i, C₁.X i ≅ C₂.X i)\n    (hf : ∀ i j, c.Rel i j → (f i).hom ≫ C₂.d i j = C₁.d i j ≫ (f j).hom) (i : ι) :\n    isoApp (isoOfComponents f hf) i = f i := by\n  ext\n  simp\n\n"}
{"name":"HomologicalComplex.Hom.isIso_of_components","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : Quiver.Hom C₁ C₂\ninst✝ : ∀ (n : ι), CategoryTheory.IsIso (f.f n)\n⊢ CategoryTheory.IsIso f","decl":"theorem isIso_of_components (f : C₁ ⟶ C₂) [∀ n : ι, IsIso (f.f n)] : IsIso f :=\n  (HomologicalComplex.Hom.isoOfComponents fun n => asIso (f.f n)).isIso_hom\n\n"}
{"name":"HomologicalComplex.Hom.prev_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni j : ι\nw : c.Rel i j\n⊢ Eq (f.prev j) (CategoryTheory.CategoryStruct.comp (C₁.xPrevIso w).hom (CategoryTheory.CategoryStruct.comp (f.f i) (C₂.xPrevIso w).inv))","decl":"theorem prev_eq (f : Hom C₁ C₂) {i j : ι} (w : c.Rel i j) :\n    f.prev j = (C₁.xPrevIso w).hom ≫ f.f i ≫ (C₂.xPrevIso w).inv := by\n  obtain rfl := c.prev_eq' w\n  simp only [xPrevIso, eqToIso_refl, Iso.refl_hom, Iso.refl_inv, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex.Hom.next_eq","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni j : ι\nw : c.Rel i j\n⊢ Eq (f.next i) (CategoryTheory.CategoryStruct.comp (C₁.xNextIso w).hom (CategoryTheory.CategoryStruct.comp (f.f j) (C₂.xNextIso w).inv))","decl":"theorem next_eq (f : Hom C₁ C₂) {i j : ι} (w : c.Rel i j) :\n    f.next i = (C₁.xNextIso w).hom ≫ f.f j ≫ (C₂.xNextIso w).inv := by\n  obtain rfl := c.next_eq' w\n  simp only [xNextIso, eqToIso_refl, Iso.refl_hom, Iso.refl_inv, comp_id, id_comp]\n\n"}
{"name":"HomologicalComplex.Hom.comm_from_apply","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni : ι\ninst : CategoryTheory.HasForget V\nx : (CategoryTheory.forget V).obj (C₁.X i)\n⊢ Eq ((C₂.dFrom i) ((f.f i) x)) ((f.next i) ((C₁.dFrom i) x))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C₁ C₂) (i : ι) : f.f i ≫ C₂.dFrom i = C₁.dFrom i ≫ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_from_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni : ι\nZ : V\nh : Quiver.Hom (C₂.xNext i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (CategoryTheory.CategoryStruct.comp (C₂.dFrom i) h)) (CategoryTheory.CategoryStruct.comp (C₁.dFrom i) (CategoryTheory.CategoryStruct.comp (f.next i) h))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C₁ C₂) (i : ι) : f.f i ≫ C₂.dFrom i = C₁.dFrom i ≫ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_from","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.f i) (C₂.dFrom i)) (CategoryTheory.CategoryStruct.comp (C₁.dFrom i) (f.next i))","decl":"@[reassoc, elementwise]\ntheorem comm_from (f : Hom C₁ C₂) (i : ι) : f.f i ≫ C₂.dFrom i = C₁.dFrom i ≫ f.next i :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to_apply","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\nj : ι\ninst : CategoryTheory.HasForget V\nx : (CategoryTheory.forget V).obj (C₁.xPrev j)\n⊢ Eq ((C₂.dTo j) ((f.prev j) x)) ((f.f j) ((C₁.dTo j) x))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C₁ C₂) (j : ι) : f.prev j ≫ C₂.dTo j = C₁.dTo j ≫ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\nj : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.prev j) (C₂.dTo j)) (CategoryTheory.CategoryStruct.comp (C₁.dTo j) (f.f j))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C₁ C₂) (j : ι) : f.prev j ≫ C₂.dTo j = C₁.dTo j ≫ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.comm_to_assoc","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\nj : ι\nZ : V\nh : Quiver.Hom (C₂.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.prev j) (CategoryTheory.CategoryStruct.comp (C₂.dTo j) h)) (CategoryTheory.CategoryStruct.comp (C₁.dTo j) (CategoryTheory.CategoryStruct.comp (f.f j) h))","decl":"@[reassoc, elementwise]\ntheorem comm_to (f : Hom C₁ C₂) (j : ι) : f.prev j ≫ C₂.dTo j = C₁.dTo j ≫ f.f j :=\n  f.comm _ _\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_left","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni : ι\n⊢ Eq (f.sqFrom i).left (f.f i)","decl":"@[simp]\ntheorem sqFrom_left (f : Hom C₁ C₂) (i : ι) : (f.sqFrom i).left = f.f i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_right","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\ni : ι\n⊢ Eq (f.sqFrom i).right (f.next i)","decl":"@[simp]\ntheorem sqFrom_right (f : Hom C₁ C₂) (i : ι) : (f.sqFrom i).right = f.next i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_id","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ : HomologicalComplex V c\ni : ι\n⊢ Eq (HomologicalComplex.Hom.sqFrom (CategoryTheory.CategoryStruct.id C₁) i) (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk (C₁.dFrom i)))","decl":"@[simp]\ntheorem sqFrom_id (C₁ : HomologicalComplex V c) (i : ι) : sqFrom (𝟙 C₁) i = 𝟙 _ :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqFrom_comp","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ C₃ : HomologicalComplex V c\nf : Quiver.Hom C₁ C₂\ng : Quiver.Hom C₂ C₃\ni : ι\n⊢ Eq (HomologicalComplex.Hom.sqFrom (CategoryTheory.CategoryStruct.comp f g) i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.Hom.sqFrom f i) (HomologicalComplex.Hom.sqFrom g i))","decl":"@[simp]\ntheorem sqFrom_comp (f : C₁ ⟶ C₂) (g : C₂ ⟶ C₃) (i : ι) :\n    sqFrom (f ≫ g) i = sqFrom f i ≫ sqFrom g i :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqTo_left","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\nj : ι\n⊢ Eq (f.sqTo j).left (f.prev j)","decl":"@[simp]\ntheorem sqTo_left (f : Hom C₁ C₂) (j : ι) : (f.sqTo j).left = f.prev j :=\n  rfl\n\n"}
{"name":"HomologicalComplex.Hom.sqTo_right","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nc : ComplexShape ι\nC₁ C₂ : HomologicalComplex V c\nf : C₁.Hom C₂\nj : ι\n⊢ Eq (f.sqTo j).right (f.f j)","decl":"@[simp]\ntheorem sqTo_right (f : Hom C₁ C₂) (j : ι) : (f.sqTo j).right = f.f j :=\n  rfl\n\n"}
{"name":"ChainComplex.of_x","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\nn : α\n⊢ Eq ((ChainComplex.of X d sq).X n) (X n)","decl":"@[simp]\ntheorem of_x (n : α) : (of X d sq).X n = X n :=\n  rfl\n\n"}
{"name":"ChainComplex.of_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\nj : α\n⊢ Eq ((ChainComplex.of X d sq).d (HAdd.hAdd j 1) j) (d j)","decl":"@[simp]\ntheorem of_d (j : α) : (of X d sq).d (j + 1) j = d j := by\n  dsimp [of]\n  rw [if_pos rfl, Category.id_comp]\n\n"}
{"name":"ChainComplex.of_d_ne","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d (HAdd.hAdd n 1)) (d n)) 0\ni j : α\nh : Ne i (HAdd.hAdd j 1)\n⊢ Eq ((ChainComplex.of X d sq).d i j) 0","decl":"theorem of_d_ne {i j : α} (h : i ≠ j + 1) : (of X d sq).d i j = 0 := by\n  dsimp [of]\n  rw [dif_neg h]\n\n"}
{"name":"ChainComplex.ofHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd_X : (n : α) → Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nsq_X : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d_X (HAdd.hAdd n 1)) (d_X n)) 0\nY : α → V\nd_Y : (n : α) → Quiver.Hom (Y (HAdd.hAdd n 1)) (Y n)\nsq_Y : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d_Y (HAdd.hAdd n 1)) (d_Y n)) 0\nf : (i : α) → Quiver.Hom (X i) (Y i)\ncomm : ∀ (i : α), Eq (CategoryTheory.CategoryStruct.comp (f (HAdd.hAdd i 1)) (d_Y i)) (CategoryTheory.CategoryStruct.comp (d_X i) (f i))\ni : α\n⊢ Eq ((ChainComplex.ofHom X d_X sq_X Y d_Y sq_Y f comm).f i) (f i)","decl":"/-- A constructor for chain maps between `α`-indexed chain complexes built using `ChainComplex.of`,\nfrom a dependently typed collection of morphisms.\n-/\n@[simps]\ndef ofHom (f : ∀ i : α, X i ⟶ Y i) (comm : ∀ i : α, f (i + 1) ≫ d_Y i = d_X i ≫ f i) :\n    of X d_X sq_X ⟶ of Y d_Y sq_Y :=\n  { f\n    comm' := fun n m => by\n      by_cases h : n = m + 1\n      · subst h\n        simpa using comm m\n      · rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]\n        simp }\n\n"}
{"name":"ChainComplex.mk_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₁ X₀\nd₁ : Quiver.Hom X₂ X₁\ns : Eq (CategoryTheory.CategoryStruct.comp d₁ d₀) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₃ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp d₂ S.f) 0\n⊢ Eq ((ChainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 0) X₀","decl":"@[simp]\ntheorem mk_X_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 0 = X₀ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₁ X₀\nd₁ : Quiver.Hom X₂ X₁\ns : Eq (CategoryTheory.CategoryStruct.comp d₁ d₀) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₃ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp d₂ S.f) 0\n⊢ Eq ((ChainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 1) X₁","decl":"@[simp]\ntheorem mk_X_1 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 1 = X₁ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_X_2","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₁ X₀\nd₁ : Quiver.Hom X₂ X₁\ns : Eq (CategoryTheory.CategoryStruct.comp d₁ d₀) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₃ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp d₂ S.f) 0\n⊢ Eq ((ChainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 2) X₂","decl":"@[simp]\ntheorem mk_X_2 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 2 = X₂ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₁ X₀\nd₁ : Quiver.Hom X₂ X₁\ns : Eq (CategoryTheory.CategoryStruct.comp d₁ d₀) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₃ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp d₂ S.f) 0\n⊢ Eq ((ChainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0) d₀","decl":"@[simp]\ntheorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 0 = d₀ := by\n  change ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀\n  rw [if_pos rfl, Category.id_comp]\n\n"}
{"name":"ChainComplex.mk_d_2_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₁ X₀\nd₁ : Quiver.Hom X₂ X₁\ns : Eq (CategoryTheory.CategoryStruct.comp d₁ d₀) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₃ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp d₂ S.f) 0\n⊢ Eq ((ChainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).d 2 1) d₁","decl":"@[simp]\ntheorem mk_d_2_1 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 2 1 = d₁ := by\n  change ite (2 = 1 + 1) (𝟙 X₂ ≫ d₁) 0 = d₁\n  rw [if_pos rfl, Category.id_comp]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"ChainComplex.mk'_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₁ X₀\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₁ X₀) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n⊢ Eq ((ChainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').X 0) X₀","decl":"@[simp]\ntheorem mk'_X_0 : (mk' X₀ X₁ d₀ succ').X 0 = X₀ :=\n  rfl\n\n"}
{"name":"ChainComplex.mk'_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₁ X₀\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₁ X₀) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n⊢ Eq ((ChainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').X 1) X₁","decl":"@[simp]\ntheorem mk'_X_1 : (mk' X₀ X₁ d₀ succ').X 1 = X₁ :=\n  rfl\n\n\n"}
{"name":"ChainComplex.mk'_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₁ X₀\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₁ X₀) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp d f) 0\n⊢ Eq ((ChainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').d 1 0) d₀","decl":"@[simp]\ntheorem mk'_d_1_0 : (mk' X₀ X₁ d₀ succ').d 1 0 = d₀ := by\n  change ite (1 = 0 + 1) (𝟙 X₁ ≫ d₀) 0 = d₀\n  rw [if_pos rfl, Category.id_comp]\n\n/- Porting note:\nDownstream constructions using `mk'` (e.g. in `CategoryTheory.Abelian.Projective`)\nhave very slow proofs, because of bad simp lemmas.\nIt would be better to write good lemmas here if possible, such as\n\n```\ntheorem mk'_X_succ (j : ℕ) :\n    (mk' X₀ X₁ d₀ succ').X (j + 2) = (succ' ⟨_, _, (mk' X₀ X₁ d₀ succ').d (j + 1) j⟩).1 := by\n  sorry\n\ntheorem mk'_d_succ {i j : ℕ} :\n    (mk' X₀ X₁ d₀ succ').d (j + 2) (j + 1) =\n      eqToHom (mk'_X_succ X₀ X₁ d₀ succ' j) ≫\n      (succ' ⟨_, _, (mk' X₀ X₁ d₀ succ').d (j + 1) j⟩).2.1 :=\n  sorry\n```\n\nThese are already tricky, and it may be better to write analogous lemmas for `mk` first.\n-/\n\n"}
{"name":"ChainComplex.mkHom_f_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 0) zero","decl":"@[simp]\ntheorem mkHom_f_0 : (mkHom P Q zero one one_zero_comm succ).f 0 = zero :=\n  rfl\n\n"}
{"name":"ChainComplex.mkHom_f_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 1) one","decl":"@[simp]\ntheorem mkHom_f_1 : (mkHom P Q zero one one_zero_comm succ).f 1 = one :=\n  rfl\n\n"}
{"name":"ChainComplex.mkHom_f_succ_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : ChainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp one (Q.d 1 0)) (CategoryTheory.CategoryStruct.comp (P.d 1 0) zero)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f' (Q.d (HAdd.hAdd n 1) n)) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) n) f)) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp f'' (Q.d (HAdd.hAdd n 2) (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 2) (HAdd.hAdd n 1)) p.snd.fst)\nn : Nat\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 2)) (succ n ⟨(P.mkHom Q zero one one_zero_comm succ).f n, ⟨(P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 1), ⋯⟩⟩).fst","decl":"@[simp]\ntheorem mkHom_f_succ_succ (n : ℕ) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          ⟨(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm (n + 1) n⟩).1 := by\n  dsimp [mkHom, mkHomAux]\n\n"}
{"name":"CochainComplex.of_x","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\nn : α\n⊢ Eq ((CochainComplex.of X d sq).X n) (X n)","decl":"@[simp]\ntheorem of_x (n : α) : (of X d sq).X n = X n :=\n  rfl\n\n"}
{"name":"CochainComplex.of_d","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\nj : α\n⊢ Eq ((CochainComplex.of X d sq).d j (HAdd.hAdd j 1)) (d j)","decl":"@[simp]\ntheorem of_d (j : α) : (of X d sq).d j (j + 1) = d j := by\n  dsimp [of]\n  rw [if_pos rfl, Category.comp_id]\n\n"}
{"name":"CochainComplex.of_d_ne","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd : (n : α) → Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d n) (d (HAdd.hAdd n 1))) 0\ni j : α\nh : Ne (HAdd.hAdd i 1) j\n⊢ Eq ((CochainComplex.of X d sq).d i j) 0","decl":"theorem of_d_ne {i j : α} (h : i + 1 ≠ j) : (of X d sq).d i j = 0 := by\n  dsimp [of]\n  rw [dif_neg h]\n\n"}
{"name":"CochainComplex.ofHom_f","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms V\nα : Type u_2\ninst✝² : AddRightCancelSemigroup α\ninst✝¹ : One α\ninst✝ : DecidableEq α\nX : α → V\nd_X : (n : α) → Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nsq_X : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d_X n) (d_X (HAdd.hAdd n 1))) 0\nY : α → V\nd_Y : (n : α) → Quiver.Hom (Y n) (Y (HAdd.hAdd n 1))\nsq_Y : ∀ (n : α), Eq (CategoryTheory.CategoryStruct.comp (d_Y n) (d_Y (HAdd.hAdd n 1))) 0\nf : (i : α) → Quiver.Hom (X i) (Y i)\ncomm : ∀ (i : α), Eq (CategoryTheory.CategoryStruct.comp (f i) (d_Y i)) (CategoryTheory.CategoryStruct.comp (d_X i) (f (HAdd.hAdd i 1)))\ni : α\n⊢ Eq ((CochainComplex.ofHom X d_X sq_X Y d_Y sq_Y f comm).f i) (f i)","decl":"/--\nA constructor for chain maps between `α`-indexed cochain complexes built using `CochainComplex.of`,\nfrom a dependently typed collection of morphisms.\n-/\n@[simps]\ndef ofHom (f : ∀ i : α, X i ⟶ Y i) (comm : ∀ i : α, f i ≫ d_Y i = d_X i ≫ f (i + 1)) :\n    of X d_X sq_X ⟶ of Y d_Y sq_Y :=\n  { f\n    comm' := fun n m => by\n      by_cases h : n + 1 = m\n      · subst h\n        simpa using comm n\n      · rw [of_d_ne X _ _ h, of_d_ne Y _ _ h]\n        simp }\n\n"}
{"name":"CochainComplex.mk_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₀ X₁\nd₁ : Quiver.Hom X₁ X₂\ns : Eq (CategoryTheory.CategoryStruct.comp d₀ d₁) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₄ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp S.g d₂) 0\n⊢ Eq ((CochainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 0) X₀","decl":"@[simp]\ntheorem mk_X_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 0 = X₀ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₀ X₁\nd₁ : Quiver.Hom X₁ X₂\ns : Eq (CategoryTheory.CategoryStruct.comp d₀ d₁) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₄ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp S.g d₂) 0\n⊢ Eq ((CochainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 1) X₁","decl":"@[simp]\ntheorem mk_X_1 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 1 = X₁ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_X_2","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₀ X₁\nd₁ : Quiver.Hom X₁ X₂\ns : Eq (CategoryTheory.CategoryStruct.comp d₀ d₁) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₄ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp S.g d₂) 0\n⊢ Eq ((CochainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).X 2) X₂","decl":"@[simp]\ntheorem mk_X_2 : (mk X₀ X₁ X₂ d₀ d₁ s succ).X 2 = X₂ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₀ X₁\nd₁ : Quiver.Hom X₁ X₂\ns : Eq (CategoryTheory.CategoryStruct.comp d₀ d₁) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₄ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp S.g d₂) 0\n⊢ Eq ((CochainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).d 0 1) d₀","decl":"@[simp]\ntheorem mk_d_1_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 0 1 = d₀ := by\n  change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀\n  rw [if_pos rfl, Category.comp_id]\n\n"}
{"name":"CochainComplex.mk_d_2_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ X₂ : V\nd₀ : Quiver.Hom X₀ X₁\nd₁ : Quiver.Hom X₁ X₂\ns : Eq (CategoryTheory.CategoryStruct.comp d₀ d₁) 0\nsucc : (S : CategoryTheory.ShortComplex V) → PSigma fun X₄ => PSigma fun d₂ => Eq (CategoryTheory.CategoryStruct.comp S.g d₂) 0\n⊢ Eq ((CochainComplex.mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 2) d₁","decl":"@[simp]\ntheorem mk_d_2_0 : (mk X₀ X₁ X₂ d₀ d₁ s succ).d 1 2 = d₁ := by\n  change ite (2 = 1 + 1) (d₁ ≫ 𝟙 X₂) 0 = d₁\n  rw [if_pos rfl, Category.comp_id]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"CochainComplex.mk'_X_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₀ X₁\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₀ X₁) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n⊢ Eq ((CochainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').X 0) X₀","decl":"@[simp]\ntheorem mk'_X_0 : (mk' X₀ X₁ d₀ succ').X 0 = X₀ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk'_X_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₀ X₁\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₀ X₁) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n⊢ Eq ((CochainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').X 1) X₁","decl":"@[simp]\ntheorem mk'_X_1 : (mk' X₀ X₁ d₀ succ').X 1 = X₁ :=\n  rfl\n\n"}
{"name":"CochainComplex.mk'_d_1_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX₀ X₁ : V\nd₀ : Quiver.Hom X₀ X₁\nsucc' : {X₀ X₁ : V} → (f : Quiver.Hom X₀ X₁) → PSigma fun X₂ => PSigma fun d => Eq (CategoryTheory.CategoryStruct.comp f d) 0\n⊢ Eq ((CochainComplex.mk' X₀ X₁ d₀ fun {X₀ X₁} => succ').d 0 1) d₀","decl":"@[simp]\ntheorem mk'_d_1_0 : (mk' X₀ X₁ d₀ succ').d 0 1 = d₀ := by\n  change ite (1 = 0 + 1) (d₀ ≫ 𝟙 X₁) 0 = d₀\n  rw [if_pos rfl, Category.comp_id]\n\n-- TODO simp lemmas for the inductive steps? It's not entirely clear that they are needed.\n"}
{"name":"CochainComplex.mkHom_f_0","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 0) zero","decl":"@[simp]\ntheorem mkHom_f_0 : (mkHom P Q zero one one_zero_comm succ).f 0 = zero :=\n  rfl\n\n"}
{"name":"CochainComplex.mkHom_f_1","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f 1) one","decl":"@[simp]\ntheorem mkHom_f_1 : (mkHom P Q zero one one_zero_comm succ).f 1 = one :=\n  rfl\n\n"}
{"name":"CochainComplex.mkHom_f_succ_succ","module":"Mathlib.Algebra.Homology.HomologicalComplex","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nP Q : CochainComplex V Nat\nzero : Quiver.Hom (P.X 0) (Q.X 0)\none : Quiver.Hom (P.X 1) (Q.X 1)\none_zero_comm : Eq (CategoryTheory.CategoryStruct.comp zero (Q.d 0 1)) (CategoryTheory.CategoryStruct.comp (P.d 0 1) one)\nsucc : (n : Nat) → (p : PSigma fun f => PSigma fun f' => Eq (CategoryTheory.CategoryStruct.comp f (Q.d n (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (P.d n (HAdd.hAdd n 1)) f')) → PSigma fun f'' => Eq (CategoryTheory.CategoryStruct.comp p.snd.fst (Q.d (HAdd.hAdd n 1) (HAdd.hAdd n 2))) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd n 1) (HAdd.hAdd n 2)) f'')\nn : Nat\n⊢ Eq ((P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 2)) (succ n ⟨(P.mkHom Q zero one one_zero_comm succ).f n, ⟨(P.mkHom Q zero one one_zero_comm succ).f (HAdd.hAdd n 1), ⋯⟩⟩).fst","decl":"@[simp]\ntheorem mkHom_f_succ_succ (n : ℕ) :\n    (mkHom P Q zero one one_zero_comm succ).f (n + 2) =\n      (succ n\n          ⟨(mkHom P Q zero one one_zero_comm succ).f n,\n            (mkHom P Q zero one one_zero_comm succ).f (n + 1),\n            (mkHom P Q zero one one_zero_comm succ).comm n (n + 1)⟩).1 := by\n  dsimp [mkHom, mkHomAux]\n\n"}
