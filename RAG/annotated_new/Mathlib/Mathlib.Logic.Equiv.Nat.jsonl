{"name":"Equiv.boolProdNatEquivNat_apply","module":"Mathlib.Logic.Equiv.Nat","initialProofState":"a✝ : Prod Bool Nat\n⊢ Eq (Equiv.boolProdNatEquivNat a✝) (Function.uncurry Nat.bit a✝)","decl":"/-- An equivalence between `Bool × ℕ` and `ℕ`, by mapping `(true, x)` to `2 * x + 1` and\n`(false, x)` to `2 * x`. -/\n@[simps]\ndef boolProdNatEquivNat : Bool × ℕ ≃ ℕ where\n  toFun := uncurry bit\n  invFun := boddDiv2\n  left_inv := fun ⟨b, n⟩ => by simp only [bodd_bit, div2_bit, uncurry_apply_pair, boddDiv2_eq]\n  right_inv n := by simp only [bit_decomp, boddDiv2_eq, uncurry_apply_pair]\n\n"}
{"name":"Equiv.boolProdNatEquivNat_symm_apply","module":"Mathlib.Logic.Equiv.Nat","initialProofState":"a✝ : Nat\n⊢ Eq (Equiv.boolProdNatEquivNat.symm a✝) a✝.boddDiv2","decl":"/-- An equivalence between `Bool × ℕ` and `ℕ`, by mapping `(true, x)` to `2 * x + 1` and\n`(false, x)` to `2 * x`. -/\n@[simps]\ndef boolProdNatEquivNat : Bool × ℕ ≃ ℕ where\n  toFun := uncurry bit\n  invFun := boddDiv2\n  left_inv := fun ⟨b, n⟩ => by simp only [bodd_bit, div2_bit, uncurry_apply_pair, boddDiv2_eq]\n  right_inv n := by simp only [bit_decomp, boddDiv2_eq, uncurry_apply_pair]\n\n"}
{"name":"Equiv.natSumNatEquivNat_symm_apply","module":"Mathlib.Logic.Equiv.Nat","initialProofState":"a✝ : Nat\n⊢ Eq (Equiv.natSumNatEquivNat.symm a✝) (Bool.rec (Sum.inl a✝.div2) (Sum.inr a✝.div2) a✝.bodd)","decl":"/-- An equivalence between `ℕ ⊕ ℕ` and `ℕ`, by mapping `(Sum.inl x)` to `2 * x` and `(Sum.inr x)` to\n`2 * x + 1`.\n-/\n@[simps! symm_apply]\ndef natSumNatEquivNat : ℕ ⊕ ℕ ≃ ℕ :=\n  (boolProdEquivSum ℕ).symm.trans boolProdNatEquivNat\n\n"}
{"name":"Equiv.natSumNatEquivNat_apply","module":"Mathlib.Logic.Equiv.Nat","initialProofState":"⊢ Eq (⇑Equiv.natSumNatEquivNat) (Sum.elim (fun x => HMul.hMul 2 x) fun x => HAdd.hAdd (HMul.hMul 2 x) 1)","decl":"@[simp]\ntheorem natSumNatEquivNat_apply : ⇑natSumNatEquivNat = Sum.elim (2 * ·) (2 * · + 1) := by\n  ext (x | x) <;> rfl\n\n"}
