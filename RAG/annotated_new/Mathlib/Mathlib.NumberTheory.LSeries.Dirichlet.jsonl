{"name":"ArithmeticFunction.one_eq_delta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (fun n => 1 n) LSeries.delta","decl":"/-- `δ` is the function underlying the arithmetic function `1`. -/\nlemma ArithmeticFunction.one_eq_delta : ↗(1 : ArithmeticFunction ℂ) = δ := by\n  ext\n  simp [one_apply, LSeries.delta]\n\n\n"}
{"name":"ArithmeticFunction.not_LSeriesSummable_moebius_at_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Not (LSeriesSummable (fun n => ↑(ArithmeticFunction.moebius n)) 1)","decl":"lemma not_LSeriesSummable_moebius_at_one : ¬ LSeriesSummable ↗μ 1 := by\n  refine fun h ↦ not_summable_one_div_on_primes <| summable_ofReal.mp <| .of_neg ?_\n  refine (h.indicator {n | n.Prime}).congr fun n ↦ ?_\n  by_cases hn : n.Prime\n  · simp [hn, hn.ne_zero, moebius_apply_prime hn, push_cast, neg_div]\n  · simp [hn]\n\n"}
{"name":"ArithmeticFunction.LSeriesSummable_moebius_iff","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\n⊢ Iff (LSeriesSummable (fun n => ↑(ArithmeticFunction.moebius n)) s) (LT.lt 1 s.re)","decl":"/-- The L-series of the Möbius function converges absolutely at `s` if and only if `re s > 1`. -/\nlemma LSeriesSummable_moebius_iff {s : ℂ} : LSeriesSummable ↗μ s ↔ 1 < s.re := by\n  refine ⟨fun H ↦ ?_, LSeriesSummable_of_bounded_of_one_lt_re (m := 1) fun n _ ↦ ?_⟩\n  · by_contra! h\n    exact not_LSeriesSummable_moebius_at_one <| LSeriesSummable.of_re_le_re (by simpa) H\n  · rw [abs_intCast] -- not done by `norm_cast`\n    norm_cast\n    exact abs_moebius_le_one\n\n"}
{"name":"ArithmeticFunction.abscissaOfAbsConv_moebius","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries.abscissaOfAbsConv fun n => ↑(ArithmeticFunction.moebius n)) 1","decl":"/-- The abscissa of absolute convergence of the L-series of the Möbius function is `1`. -/\nlemma abscissaOfAbsConv_moebius : abscissaOfAbsConv ↗μ = 1 := by\n  simpa [abscissaOfAbsConv, LSeriesSummable_moebius_iff, Set.Ioi_def, EReal.image_coe_Ioi]\n    using csInf_Ioo <| EReal.coe_lt_top 1\n\n"}
{"name":"ArithmeticFunction.const_one_eq_zeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nn : Nat\nhn : Ne n 0\n⊢ Eq (1 n) ↑((fun x => ArithmeticFunction.zeta x) n)","decl":"open scoped ArithmeticFunction.zeta in\nlemma ArithmeticFunction.const_one_eq_zeta {R : Type*} [Semiring R] {n : ℕ} (hn : n ≠ 0) :\n    (1 : ℕ → R) n = (ζ ·) n := by\n  simp [hn]\n\n"}
{"name":"LSeries.one_convolution_eq_zeta_convolution","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Nat → R\n⊢ Eq (LSeries.convolution 1 f) (LSeries.convolution (fun x => ↑(ArithmeticFunction.zeta x)) f)","decl":"lemma LSeries.one_convolution_eq_zeta_convolution {R : Type*} [Semiring R] (f : ℕ → R) :\n    (1 : ℕ → R) ⍟ f = ((ArithmeticFunction.zeta ·) : ℕ → R) ⍟ f :=\n  convolution_congr ArithmeticFunction.const_one_eq_zeta fun _ ↦ rfl\n\n"}
{"name":"LSeries.convolution_one_eq_convolution_zeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nf : Nat → R\n⊢ Eq (LSeries.convolution f 1) (LSeries.convolution f fun x => ↑(ArithmeticFunction.zeta x))","decl":"lemma LSeries.convolution_one_eq_convolution_zeta {R : Type*} [Semiring R] (f : ℕ → R) :\n    f ⍟ (1 : ℕ → R) = f ⍟ ((ArithmeticFunction.zeta ·) : ℕ → R) :=\n  convolution_congr (fun _ ↦ rfl) ArithmeticFunction.const_one_eq_zeta\n\n"}
{"name":"DirichletCharacter.isMultiplicative_toArithmeticFunction","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nR : Type u_1\ninst✝ : CommMonoidWithZero R\nχ : DirichletCharacter R N\n⊢ (toArithmeticFunction fun x => χ ↑x).IsMultiplicative","decl":"open ArithmeticFunction in\n/-- The arithmetic function associated to a Dirichlet character is multiplicative. -/\nlemma isMultiplicative_toArithmeticFunction {N : ℕ} {R : Type*} [CommMonoidWithZero R]\n    (χ : DirichletCharacter R N) :\n    (toArithmeticFunction (χ ·)).IsMultiplicative := by\n  refine IsMultiplicative.iff_ne_zero.mpr ⟨?_, fun {m} {n} hm hn _ ↦ ?_⟩\n  · simp [toArithmeticFunction]\n  · simp [toArithmeticFunction, hm, hn]\n\n"}
{"name":"DirichletCharacter.apply_eq_toArithmeticFunction_apply","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nR : Type u_1\ninst✝ : CommMonoidWithZero R\nχ : DirichletCharacter R N\nn : Nat\nhn : Ne n 0\n⊢ Eq (χ ↑n) ((toArithmeticFunction fun x => χ ↑x) n)","decl":"lemma apply_eq_toArithmeticFunction_apply {N : ℕ} {R : Type*} [CommMonoidWithZero R]\n    (χ : DirichletCharacter R N) {n : ℕ} (hn : n ≠ 0) :\n    χ n = toArithmeticFunction (χ ·) n := by\n  simp [toArithmeticFunction, hn]\n\n"}
{"name":"DirichletCharacter.mul_convolution_distrib","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nn : Nat\nχ : DirichletCharacter R n\nf g : Nat → R\n⊢ Eq (LSeries.convolution (HMul.hMul (fun x => χ ↑x) f) (HMul.hMul (fun x => χ ↑x) g)) (HMul.hMul (fun x => χ ↑x) (LSeries.convolution f g))","decl":"/-- Twisting by a Dirichlet character `χ` distributes over convolution. -/\nlemma mul_convolution_distrib {R : Type*} [CommSemiring R] {n : ℕ} (χ : DirichletCharacter R n)\n    (f g : ℕ → R) :\n    (((χ ·) : ℕ → R) * f) ⍟ (((χ ·) : ℕ → R) * g) = ((χ ·) : ℕ → R) * (f ⍟ g) := by\n  ext n\n  simp only [Pi.mul_apply, LSeries.convolution_def, Finset.mul_sum]\n  refine Finset.sum_congr rfl fun p hp ↦ ?_\n  rw [(mem_divisorsAntidiagonal.mp hp).1.symm, cast_mul, map_mul]\n  exact mul_mul_mul_comm ..\n\n"}
{"name":"DirichletCharacter.mul_delta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"n : Nat\nχ : DirichletCharacter Complex n\n⊢ Eq (HMul.hMul (fun n_1 => χ ↑n_1) LSeries.delta) LSeries.delta","decl":"lemma mul_delta {n : ℕ} (χ : DirichletCharacter ℂ n) : ↗χ * δ = δ :=\n  LSeries.mul_delta <| by rw [cast_one, map_one]\n\n"}
{"name":"DirichletCharacter.delta_mul","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"n : Nat\nχ : DirichletCharacter Complex n\n⊢ Eq (HMul.hMul LSeries.delta fun n_1 => χ ↑n_1) LSeries.delta","decl":"lemma delta_mul {n : ℕ} (χ : DirichletCharacter ℂ n) : δ * ↗χ = δ :=\n  mul_comm δ _ ▸ mul_delta ..\n\n"}
{"name":"DirichletCharacter.convolution_mul_moebius","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"n : Nat\nχ : DirichletCharacter Complex n\n⊢ Eq (LSeries.convolution (fun n_1 => χ ↑n_1) (HMul.hMul (fun n_1 => χ ↑n_1) fun n => ↑(ArithmeticFunction.moebius n))) LSeries.delta","decl":"open ArithmeticFunction in\n/-- The convolution of a Dirichlet character `χ` with the twist `χ * μ` is `δ`,\nthe indicator function of `{1}`. -/\nlemma convolution_mul_moebius {n : ℕ} (χ : DirichletCharacter ℂ n) : ↗χ ⍟ (↗χ * ↗μ) = δ := by\n  have : (1 : ℕ → ℂ) ⍟ (μ ·) = δ := by\n    rw [one_convolution_eq_zeta_convolution, ← one_eq_delta]\n    simp_rw [← natCoe_apply, ← intCoe_apply, coe_mul, coe_zeta_mul_coe_moebius]\n  nth_rewrite 1 [← mul_one ↗χ]\n  simpa only [mul_convolution_distrib χ 1 ↗μ, this] using mul_delta _\n\n"}
{"name":"DirichletCharacter.modZero_eq_delta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"χ : DirichletCharacter Complex 0\n⊢ Eq (fun n => χ ↑n) LSeries.delta","decl":"/-- The Dirichlet character mod `0` corresponds to `δ`. -/\nlemma modZero_eq_delta {χ : DirichletCharacter ℂ 0} : ↗χ = δ := by\n  ext n\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp_rw [cast_zero, χ.map_nonunit not_isUnit_zero, delta, reduceCtorEq, if_false]\n  rcases eq_or_ne n 1 with rfl | hn'\n  · simp [delta]\n  have : ¬ IsUnit (n : ZMod 0) := fun h ↦ hn' <| ZMod.eq_one_of_isUnit_natCast h\n  simp_all [χ.map_nonunit this, delta]\n\n"}
{"name":"DirichletCharacter.modOne_eq_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nχ : DirichletCharacter R 1\n⊢ Eq (fun x => χ ↑x) 1","decl":"/-- The Dirichlet character mod `1` corresponds to the constant function `1`. -/\nlemma modOne_eq_one {R : Type*} [CommSemiring R] {χ : DirichletCharacter R 1} :\n    ((χ ·) : ℕ → R) = 1 := by\n  ext\n  rw [χ.level_one, MulChar.one_apply (isUnit_of_subsingleton _), Pi.one_apply]\n\n"}
{"name":"DirichletCharacter.LSeries_modOne_eq","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries fun n => 1 ↑n) (LSeries 1)","decl":"lemma LSeries_modOne_eq : L ↗χ₁ = L 1 :=\n  congr_arg L modOne_eq_one\n\n"}
{"name":"DirichletCharacter.not_LSeriesSummable_at_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nhN : Ne N 0\nχ : DirichletCharacter Complex N\n⊢ Not (LSeriesSummable (fun n => χ ↑n) 1)","decl":"/-- The L-series of a Dirichlet character mod `N > 0` does not converge absolutely at `s = 1`. -/\nlemma not_LSeriesSummable_at_one {N : ℕ} (hN : N ≠ 0) (χ : DirichletCharacter ℂ N) :\n    ¬ LSeriesSummable ↗χ 1 := by\n  refine fun h ↦ (Real.not_summable_indicator_one_div_natCast hN 1) ?_\n  refine h.norm.of_nonneg_of_le (fun m ↦ Set.indicator_apply_nonneg (fun _ ↦ by positivity))\n    (fun n ↦ ?_)\n  simp only [norm_term_eq, Set.indicator, Set.mem_setOf_eq]\n  split_ifs with h₁ h₂\n  · simp [h₂]\n  · simp [h₁, χ.map_one]\n  all_goals positivity\n\n"}
{"name":"DirichletCharacter.LSeriesSummable_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesSummable (fun n => χ ↑n) s","decl":"/-- The L-series of a Dirichlet character converges absolutely at `s` if `re s > 1`. -/\nlemma LSeriesSummable_of_one_lt_re {N : ℕ} (χ : DirichletCharacter ℂ N) {s : ℂ} (hs : 1 < s.re) :\n    LSeriesSummable ↗χ s :=\n  LSeriesSummable_of_bounded_of_one_lt_re (fun _ _ ↦ χ.norm_le_one _) hs\n\n"}
{"name":"DirichletCharacter.LSeriesSummable_iff","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nhN : Ne N 0\nχ : DirichletCharacter Complex N\ns : Complex\n⊢ Iff (LSeriesSummable (fun n => χ ↑n) s) (LT.lt 1 s.re)","decl":"/-- The L-series of a Dirichlet character mod `N > 0` converges absolutely at `s` if and only if\n`re s > 1`. -/\nlemma LSeriesSummable_iff {N : ℕ} (hN : N ≠ 0) (χ : DirichletCharacter ℂ N) {s : ℂ} :\n    LSeriesSummable ↗χ s ↔ 1 < s.re := by\n  refine ⟨fun H ↦ ?_, LSeriesSummable_of_one_lt_re χ⟩\n  by_contra! h\n  exact not_LSeriesSummable_at_one hN χ <| LSeriesSummable.of_re_le_re (by simp [h]) H\n\n"}
{"name":"DirichletCharacter.absicssaOfAbsConv_eq_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nhn : Ne N 0\nχ : DirichletCharacter Complex N\n⊢ Eq (LSeries.abscissaOfAbsConv fun n => χ ↑n) 1","decl":"/-- The abscissa of absolute convergence of the L-series of a Dirichlet character mod `N > 0`\nis `1`. -/\nlemma absicssaOfAbsConv_eq_one {N : ℕ} (hn : N ≠ 0) (χ : DirichletCharacter ℂ N) :\n    abscissaOfAbsConv ↗χ = 1 := by\n  simpa [abscissaOfAbsConv, LSeriesSummable_iff hn χ, Set.Ioi_def, EReal.image_coe_Ioi]\n    using csInf_Ioo <| EReal.coe_lt_top 1\n\n"}
{"name":"DirichletCharacter.LSeriesSummable_mul","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\nf : Nat → Complex\ns : Complex\nh : LSeriesSummable f s\n⊢ LSeriesSummable (HMul.hMul (fun n => χ ↑n) f) s","decl":"/-- The L-series of the twist of `f` by a Dirichlet character converges at `s` if the L-series\nof `f` does. -/\nlemma LSeriesSummable_mul {N : ℕ} (χ : DirichletCharacter ℂ N) {f : ℕ → ℂ} {s : ℂ}\n    (h : LSeriesSummable f s) :\n    LSeriesSummable (↗χ * f) s := by\n  refine .of_norm <| h.norm.of_nonneg_of_le (fun _ ↦ norm_nonneg _) fun n ↦ norm_term_le s ?_\n  simpa using mul_le_of_le_one_left (norm_nonneg <| f n) <| χ.norm_le_one n\n\n"}
{"name":"DirichletCharacter.LSeries.mul_mu_eq_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (HMul.hMul (LSeries (fun n => χ ↑n) s) (LSeries (HMul.hMul (fun n => χ ↑n) fun n => ↑(ArithmeticFunction.moebius n)) s)) 1","decl":"open scoped ArithmeticFunction.Moebius in\n/-- The L-series of a Dirichlet character `χ` and of the twist of `μ` by `χ` are multiplicative\ninverses. -/\nlemma LSeries.mul_mu_eq_one {N : ℕ} (χ : DirichletCharacter ℂ N) {s : ℂ}\n    (hs : 1 < s.re) : L ↗χ s * L (↗χ * ↗μ) s = 1 := by\n  rw [← LSeries_convolution' (LSeriesSummable_of_one_lt_re χ hs) <|\n          LSeriesSummable_mul χ <| ArithmeticFunction.LSeriesSummable_moebius_iff.mpr hs,\n    convolution_mul_moebius, LSeries_delta, Pi.one_apply]\n\n\n"}
{"name":"DirichletCharacter.LSeries_ne_zero_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (LSeries (fun n => χ ↑n) s) 0","decl":"/-- The L-series of a Dirichlet character does not vanish on the right half-plane `re s > 1`. -/\nlemma LSeries_ne_zero_of_one_lt_re {N : ℕ} (χ : DirichletCharacter ℂ N) {s : ℂ} (hs : 1 < s.re) :\n    L ↗χ s ≠ 0 :=\n  fun h ↦ by simpa [h] using LSeries.mul_mu_eq_one χ hs\n\n"}
{"name":"LSeries.abscissaOfAbsConv_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries.abscissaOfAbsConv 1) 1","decl":"/-- The abscissa of (absolute) convergence of the constant sequence `1` is `1`. -/\nlemma LSeries.abscissaOfAbsConv_one : abscissaOfAbsConv 1 = 1 :=\n  modOne_eq_one (χ := χ₁) ▸ absicssaOfAbsConv_eq_one one_ne_zero χ₁\n\n"}
{"name":"LSeriesSummable_one_iff","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\n⊢ Iff (LSeriesSummable 1 s) (LT.lt 1 s.re)","decl":"/-- The `LSeries` of the constant sequence `1` converges at `s` if and only if `re s > 1`. -/\ntheorem LSeriesSummable_one_iff {s : ℂ} : LSeriesSummable 1 s ↔ 1 < s.re :=\n  modOne_eq_one (χ := χ₁) ▸ LSeriesSummable_iff one_ne_zero χ₁\n\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_eq","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries fun n => ↑(ArithmeticFunction.zeta n)) (LSeries 1)","decl":"/-- The `LSeries` of the arithmetic function `ζ` is the same as the `LSeries` associated\nto the constant sequence `1`. -/\nlemma LSeries_zeta_eq : L ↗ζ = L 1 := by\n  ext s\n  exact (LSeries_congr s const_one_eq_zeta).symm\n\n"}
{"name":"ArithmeticFunction.LSeriesSummable_zeta_iff","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\n⊢ Iff (LSeriesSummable (fun x => ↑(ArithmeticFunction.zeta x)) s) (LT.lt 1 s.re)","decl":"/-- The `LSeries` associated to the arithmetic function `ζ` converges at `s` if and only if\n`re s > 1`. -/\ntheorem LSeriesSummable_zeta_iff {s : ℂ} : LSeriesSummable (ζ ·) s ↔ 1 < s.re :=\n  (LSeriesSummable_congr s const_one_eq_zeta).symm.trans <| LSeriesSummable_one_iff\n\n"}
{"name":"ArithmeticFunction.abscissaOfAbsConv_zeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries.abscissaOfAbsConv fun n => ↑(ArithmeticFunction.zeta n)) 1","decl":"/-- The abscissa of (absolute) convergence of the arithmetic function `ζ` is `1`. -/\nlemma abscissaOfAbsConv_zeta : abscissaOfAbsConv ↗ζ = 1 := by\n  rw [abscissaOfAbsConv_congr (g := 1) fun hn ↦ by simp [hn], abscissaOfAbsConv_one]\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_eq_riemannZeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (fun n => ↑(ArithmeticFunction.zeta n)) s) (riemannZeta s)","decl":"/-- The L-series of the arithmetic function `ζ` equals the Riemann Zeta Function on its\ndomain of convergence `1 < re s`. -/\nlemma LSeries_zeta_eq_riemannZeta {s : ℂ} (hs : 1 < s.re) : L ↗ζ s = riemannZeta s := by\n  suffices ∑' n, term (fun n ↦ if n = 0 then 0 else 1) s n = ∑' n : ℕ, 1 / (n : ℂ) ^ s by\n    simpa [LSeries, zeta_eq_tsum_one_div_nat_cpow hs]\n  refine tsum_congr fun n ↦ ?_\n  rcases eq_or_ne n 0 with hn | hn <;>\n  simp [hn, ne_zero_of_one_lt_re hs]\n\n"}
{"name":"ArithmeticFunction.LSeriesHasSum_zeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesHasSum (fun n => ↑(ArithmeticFunction.zeta n)) s (riemannZeta s)","decl":"/-- The L-series of the arithmetic function `ζ` equals the Riemann Zeta Function on its\ndomain of convergence `1 < re s`. -/\nlemma LSeriesHasSum_zeta {s : ℂ} (hs : 1 < s.re) : LSeriesHasSum ↗ζ s (riemannZeta s) :=\n  LSeries_zeta_eq_riemannZeta hs ▸ (LSeriesSummable_zeta_iff.mpr hs).LSeriesHasSum\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_mul_Lseries_moebius","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (HMul.hMul (LSeries (fun n => ↑(ArithmeticFunction.zeta n)) s) (LSeries (fun n => ↑(ArithmeticFunction.moebius n)) s)) 1","decl":"/-- The L-series of the arithmetic function `ζ` and of the Möbius function are inverses. -/\nlemma LSeries_zeta_mul_Lseries_moebius {s : ℂ} (hs : 1 < s.re) : L ↗ζ s * L ↗μ s = 1 := by\n  rw [← LSeries_convolution' (LSeriesSummable_zeta_iff.mpr hs)\n    (LSeriesSummable_moebius_iff.mpr hs)]\n  simp [← natCoe_apply, ← intCoe_apply, coe_mul, one_eq_delta, LSeries_delta, -zeta_apply]\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_ne_zero_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (LSeries (fun n => ↑(ArithmeticFunction.zeta n)) s) 0","decl":"/-- The L-series of the arithmetic function `ζ` does not vanish on the right half-plane\n`re s > 1`. -/\nlemma LSeries_zeta_ne_zero_of_one_lt_re {s : ℂ} (hs : 1 < s.re) : L ↗ζ s ≠ 0 :=\n  fun h ↦ by simpa [h, -zeta_apply] using LSeries_zeta_mul_Lseries_moebius hs\n\n"}
{"name":"LSeries_one_eq_riemannZeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries 1 s) (riemannZeta s)","decl":"/-- The L-series of the constant sequence `1` equals the Riemann Zeta Function on its\ndomain of convergence `1 < re s`. -/\nlemma LSeries_one_eq_riemannZeta {s : ℂ} (hs : 1 < s.re) : L 1 s = riemannZeta s :=\n  LSeries_zeta_eq ▸ LSeries_zeta_eq_riemannZeta hs\n\n"}
{"name":"LSeriesHasSum_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesHasSum 1 s (riemannZeta s)","decl":"/-- The L-series of the constant sequence `1` equals the Riemann zeta function on its\ndomain of convergence `1 < re s`. -/\nlemma LSeriesHasSum_one {s : ℂ} (hs : 1 < s.re) : LSeriesHasSum 1 s (riemannZeta s) :=\n  LSeries_one_eq_riemannZeta hs ▸ (LSeriesSummable_one_iff.mpr hs).LSeriesHasSum\n\n"}
{"name":"LSeries_one_mul_Lseries_moebius","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (HMul.hMul (LSeries 1 s) (LSeries (fun n => ↑(ArithmeticFunction.moebius n)) s)) 1","decl":"/-- The L-series of the constant sequence `1` and of the Möbius function are inverses. -/\nlemma LSeries_one_mul_Lseries_moebius {s : ℂ} (hs : 1 < s.re) : L 1 s * L ↗μ s = 1 :=\n  LSeries_zeta_eq ▸ LSeries_zeta_mul_Lseries_moebius hs\n\n"}
{"name":"LSeries_one_ne_zero_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (LSeries 1 s) 0","decl":"/-- The L-series of the constant sequence `1` does not vanish on the right half-plane\n`re s > 1`. -/\nlemma LSeries_one_ne_zero_of_one_lt_re {s : ℂ} (hs : 1 < s.re) : L 1 s ≠ 0 :=\n  LSeries_zeta_eq ▸ LSeries_zeta_ne_zero_of_one_lt_re hs\n\n"}
{"name":"riemannZeta_ne_zero_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Ne (riemannZeta s) 0","decl":"/-- The Riemann Zeta Function does not vanish on the half-plane `re s > 1`. -/\nlemma riemannZeta_ne_zero_of_one_lt_re {s : ℂ} (hs : 1 < s.re) : riemannZeta s ≠ 0 :=\n  LSeries_one_eq_riemannZeta hs ▸ LSeries_one_ne_zero_of_one_lt_re hs\n\n"}
{"name":"ArithmeticFunction.convolution_vonMangoldt_zeta","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries.convolution (fun n => ↑(ArithmeticFunction.vonMangoldt n)) fun n => ↑(ArithmeticFunction.zeta n)) fun n => Complex.log ↑n","decl":"/-- A translation of the relation `Λ * ↑ζ = log` of (real-valued) arithmetic functions\nto an equality of complex sequences. -/\nlemma convolution_vonMangoldt_zeta : ↗Λ ⍟ ↗ζ = ↗Complex.log := by\n  ext n\n  simpa [apply_ite, LSeries.convolution_def, -vonMangoldt_mul_zeta]\n    using congr_arg (ofReal <| · n) vonMangoldt_mul_zeta\n\n"}
{"name":"ArithmeticFunction.convolution_vonMangoldt_const_one","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"⊢ Eq (LSeries.convolution (fun n => ↑(ArithmeticFunction.vonMangoldt n)) 1) fun n => Complex.log ↑n","decl":"lemma convolution_vonMangoldt_const_one : ↗Λ ⍟ 1 = ↗Complex.log :=\n  (convolution_one_eq_convolution_zeta _).trans convolution_vonMangoldt_zeta\n\n"}
{"name":"ArithmeticFunction.LSeriesSummable_vonMangoldt","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesSummable (fun n => ↑(ArithmeticFunction.vonMangoldt n)) s","decl":"/-- The L-series of the von Mangoldt function `Λ` converges at `s` when `re s > 1`. -/\nlemma LSeriesSummable_vonMangoldt {s : ℂ} (hs : 1 < s.re) : LSeriesSummable ↗Λ s := by\n  have hf := LSeriesSummable_logMul_of_lt_re\n    (show abscissaOfAbsConv 1 < s.re by rw [abscissaOfAbsConv_one]; exact_mod_cast hs)\n  rw [LSeriesSummable, ← summable_norm_iff] at hf ⊢\n  refine hf.of_nonneg_of_le (fun _ ↦ norm_nonneg _) (fun n ↦ norm_term_le s ?_)\n  have hΛ : ‖↗Λ n‖ ≤ ‖Complex.log n‖ := by\n    simpa [_root_.abs_of_nonneg, vonMangoldt_nonneg, ← natCast_log, Real.log_natCast_nonneg]\n      using vonMangoldt_le_log\n  exact hΛ.trans <| by simp\n\n"}
{"name":"DirichletCharacter.convolution_twist_vonMangoldt","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\n⊢ Eq (LSeries.convolution (HMul.hMul (fun n => χ ↑n) fun n => ↑(ArithmeticFunction.vonMangoldt n)) fun n => χ ↑n) (HMul.hMul (fun n => χ ↑n) fun n => Complex.log ↑n)","decl":"/-- A twisted version of the relation `Λ * ↑ζ = log` in terms of complex sequences. -/\nlemma convolution_twist_vonMangoldt {N : ℕ} (χ : DirichletCharacter ℂ N) :\n    (↗χ * ↗Λ) ⍟ ↗χ = ↗χ * ↗Complex.log := by\n  rw [← convolution_vonMangoldt_const_one, ← χ.mul_convolution_distrib, mul_one]\n\n"}
{"name":"DirichletCharacter.LSeriesSummable_twist_vonMangoldt","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesSummable (HMul.hMul (fun n => χ ↑n) fun n => ↑(ArithmeticFunction.vonMangoldt n)) s","decl":"/-- The L-series of the twist of the von Mangoldt function `Λ` by a Dirichlet character `χ`\nconverges at `s` when `re s > 1`. -/\nlemma LSeriesSummable_twist_vonMangoldt {N : ℕ} (χ : DirichletCharacter ℂ N) {s : ℂ}\n    (hs : 1 < s.re) :\n    LSeriesSummable (↗χ * ↗Λ) s :=\n  LSeriesSummable_mul χ <| LSeriesSummable_vonMangoldt hs\n\n"}
{"name":"DirichletCharacter.LSeries_twist_vonMangoldt_eq","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (HMul.hMul (fun n => χ ↑n) fun n => ↑(ArithmeticFunction.vonMangoldt n)) s) (HDiv.hDiv (Neg.neg (deriv (LSeries fun n => χ ↑n) s)) (LSeries (fun n => χ ↑n) s))","decl":"/-- The L-series of the twist of the von Mangoldt function `Λ` by a Dirichlet character `χ` at `s`\nequals the negative logarithmic derivative of the L-series of `χ` when `re s > 1`. -/\nlemma LSeries_twist_vonMangoldt_eq {N : ℕ} (χ : DirichletCharacter ℂ N) {s : ℂ} (hs : 1 < s.re) :\n    L (↗χ * ↗Λ) s = - deriv (L ↗χ) s / L ↗χ s := by\n  rcases eq_or_ne N 0 with rfl | hN\n  · simpa [-deriv_const', modZero_eq_delta, delta_mul_eq_smul_delta, LSeries_delta]\n      using deriv_const s (1 : ℂ)\n  -- now `N ≠ 0`\n  have hχ : LSeriesSummable ↗χ s := (LSeriesSummable_iff hN χ).mpr hs\n  have hs' : abscissaOfAbsConv ↗χ < s.re := by\n    rwa [absicssaOfAbsConv_eq_one hN, ← EReal.coe_one, EReal.coe_lt_coe_iff]\n  have hΛ : LSeriesSummable (↗χ * ↗Λ) s := LSeriesSummable_twist_vonMangoldt χ hs\n  rw [eq_div_iff <| LSeries_ne_zero_of_one_lt_re χ hs, ← LSeries_convolution' hΛ hχ,\n    convolution_twist_vonMangoldt, LSeries_deriv hs', neg_neg]\n  exact LSeries_congr s fun _ ↦ by simp [mul_comm, logMul]\n\n"}
{"name":"ArithmeticFunction.LSeries_vonMangoldt_eq","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (fun n => ↑(ArithmeticFunction.vonMangoldt n)) s) (HDiv.hDiv (Neg.neg (deriv (LSeries 1) s)) (LSeries 1 s))","decl":"open DirichletCharacter in\n/-- The L-series of the von Mangoldt function `Λ` equals the negative logarithmic derivative\nof the L-series of the constant sequence `1` on its domain of convergence `re s > 1`. -/\nlemma LSeries_vonMangoldt_eq {s : ℂ} (hs : 1 < s.re) : L ↗Λ s = - deriv (L 1) s / L 1 s := by\n  refine (LSeries_congr s fun {n} _ ↦ ?_).trans <|\n    LSeries_modOne_eq ▸ LSeries_twist_vonMangoldt_eq χ₁ hs\n  simp [Subsingleton.eq_one (n : ZMod 1)]\n\n"}
{"name":"ArithmeticFunction.LSeries_vonMangoldt_eq_deriv_riemannZeta_div","module":"Mathlib.NumberTheory.LSeries.Dirichlet","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (fun n => ↑(ArithmeticFunction.vonMangoldt n)) s) (HDiv.hDiv (Neg.neg (deriv riemannZeta s)) (riemannZeta s))","decl":"/-- The L-series of the von Mangoldt function `Λ` equals the negative logarithmic derivative\nof the Riemann zeta function on its domain of convergence `re s > 1`. -/\nlemma LSeries_vonMangoldt_eq_deriv_riemannZeta_div {s : ℂ} (hs : 1 < s.re) :\n    L ↗Λ s = - deriv riemannZeta s / riemannZeta s := by\n  suffices deriv (L 1) s = deriv riemannZeta s by\n    rw [LSeries_vonMangoldt_eq hs, ← LSeries_one_eq_riemannZeta hs, this]\n  refine Filter.EventuallyEq.deriv_eq <| Filter.eventuallyEq_iff_exists_mem.mpr ?_\n  exact ⟨{z | 1 < z.re}, (isOpen_lt continuous_const continuous_re).mem_nhds hs,\n    fun _ ↦ LSeries_one_eq_riemannZeta⟩\n\n"}
