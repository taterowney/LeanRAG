{"name":"IsArtinianRing.isNilpotent_jacobson_bot","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ IsNilpotent Bot.bot.jacobson","decl":"@[stacks 00J8]\ntheorem isNilpotent_jacobson_bot : IsNilpotent (Ideal.jacobson (⊥ : Ideal R)) := by\n  let Jac := Ideal.jacobson (⊥ : Ideal R)\n  let f : ℕ →o (Ideal R)ᵒᵈ := ⟨fun n => Jac ^ n, fun _ _ h => Ideal.pow_le_pow_right h⟩\n  obtain ⟨n, hn⟩ : ∃ n, ∀ m, n ≤ m → Jac ^ n = Jac ^ m := IsArtinian.monotone_stabilizes f\n  refine ⟨n, ?_⟩\n  let J : Ideal R := annihilator (Jac ^ n)\n  suffices J = ⊤ by\n    have hJ : J • Jac ^ n = ⊥ := annihilator_smul (Jac ^ n)\n    simpa only [this, top_smul, Ideal.zero_eq_bot] using hJ\n  by_contra hJ\n  change J ≠ ⊤ at hJ\n  rcases IsArtinian.set_has_minimal { J' : Ideal R | J < J' } ⟨⊤, hJ.lt_top⟩ with\n    ⟨J', hJJ' : J < J', hJ' : ∀ I, J < I → ¬I < J'⟩\n  rcases SetLike.exists_of_lt hJJ' with ⟨x, hxJ', hxJ⟩\n  obtain rfl : J ⊔ Ideal.span {x} = J' := by\n    apply eq_of_le_of_not_lt _ (hJ' (J ⊔ Ideal.span {x}) _)\n    · exact sup_le hJJ'.le (span_le.2 (singleton_subset_iff.2 hxJ'))\n    · rw [SetLike.lt_iff_le_and_exists]\n      exact ⟨le_sup_left, ⟨x, mem_sup_right (mem_span_singleton_self x), hxJ⟩⟩\n  have : J ⊔ Jac • Ideal.span {x} ≤ J ⊔ Ideal.span {x} :=\n    sup_le_sup_left (smul_le.2 fun _ _ _ => Submodule.smul_mem _ _) _\n  have : Jac * Ideal.span {x} ≤ J := by -- Need version 4 of Nakayama's lemma on Stacks\n    by_contra H\n    refine H (Ideal.mul_le_left.trans (le_of_le_smul_of_le_jacobson_bot (fg_span_singleton _) le_rfl\n      (le_sup_right.trans_eq (this.eq_of_not_lt (hJ' _ ?_)).symm)))\n    exact lt_of_le_of_ne le_sup_left fun h => H <| h.symm ▸ le_sup_right\n  have : Ideal.span {x} * Jac ^ (n + 1) ≤ ⊥ := calc\n    Ideal.span {x} * Jac ^ (n + 1) = Ideal.span {x} * Jac * Jac ^ n := by\n      rw [pow_succ', ← mul_assoc]\n    _ ≤ J * Jac ^ n := mul_le_mul (by rwa [mul_comm]) le_rfl\n    _ = ⊥ := by simp [J]\n  refine hxJ (mem_annihilator.2 fun y hy => (mem_bot R).1 ?_)\n  refine this (mul_mem_mul (mem_span_singleton_self x) ?_)\n  rwa [← hn (n + 1) (Nat.le_succ _)]\n\n"}
{"name":"IsArtinianRing.isField_of_isReduced_of_isLocalRing","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\ninst✝² : IsArtinianRing R\ninst✝¹ : IsReduced R\ninst✝ : IsLocalRing R\n⊢ IsField R","decl":"variable (R) in\n/-- Commutative artinian reduced local ring is a field. -/\ntheorem isField_of_isReduced_of_isLocalRing [IsReduced R] [IsLocalRing R] : IsField R :=\n  (IsArtinianRing.equivPi R).trans (RingEquiv.piUnique _) |>.toMulEquiv.isField\n    _ (Ideal.Quotient.field _).toIsField\n\n"}
{"name":"IsArtinianRing.isUnit_of_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\na : R\nha : Membership.mem (nonZeroDivisors R) a\n⊢ IsUnit a","decl":"/-- If an element of an artinian ring is not a zero divisor then it is a unit. -/\ntheorem isUnit_of_mem_nonZeroDivisors {a : R} (ha : a ∈ R⁰) : IsUnit a :=\n  IsUnit.isUnit_iff_mulLeft_bijective.mpr <|\n    IsArtinian.bijective_of_injective_endomorphism (LinearMap.mulLeft R a)\n      fun _ _ ↦ (mul_cancel_left_mem_nonZeroDivisors ha).mp\n\n"}
{"name":"IsArtinianRing.isUnit_iff_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\na : R\n⊢ Iff (IsUnit a) (Membership.mem (nonZeroDivisors R) a)","decl":"/-- In an artinian ring, an element is a unit iff it is a non-zero-divisor.\nSee also `isUnit_iff_mem_nonZeroDivisors_of_finite`.-/\ntheorem isUnit_iff_mem_nonZeroDivisors {a : R} : IsUnit a ↔ a ∈ R⁰ :=\n  ⟨IsUnit.mem_nonZeroDivisors, isUnit_of_mem_nonZeroDivisors⟩\n\n"}
{"name":"IsArtinianRing.isUnit_submonoid_eq","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\n⊢ Eq (IsUnit.submonoid R) (nonZeroDivisors R)","decl":"theorem isUnit_submonoid_eq : IsUnit.submonoid R = R⁰ := by\n  ext; simp [IsUnit.mem_submonoid_iff, isUnit_iff_mem_nonZeroDivisors]\n\n"}
{"name":"IsArtinianRing.localization_surjective","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsArtinianRing R\nS : Submonoid R\nL : Type u_2\ninst✝² : CommSemiring L\ninst✝¹ : Algebra R L\ninst✝ : IsLocalization S L\n⊢ Function.Surjective ⇑(algebraMap R L)","decl":"/-- Localizing an artinian ring can only reduce the amount of elements. -/\ntheorem localization_surjective : Function.Surjective (algebraMap R L) := by\n  intro r'\n  obtain ⟨r₁, s, rfl⟩ := IsLocalization.mk'_surjective S r'\n  -- TODO: can `rsuffices` be used to move the `exact` below before the proof of this `obtain`?\n  obtain ⟨r₂, h⟩ : ∃ r : R, IsLocalization.mk' L 1 s = algebraMap R L r := by\n    obtain ⟨n, r, hr⟩ := IsArtinian.exists_pow_succ_smul_dvd (s : R) (1 : R)\n    use r\n    rw [smul_eq_mul, smul_eq_mul, pow_succ, mul_assoc] at hr\n    apply_fun algebraMap R L at hr\n    simp only [map_mul] at hr\n    rw [← IsLocalization.mk'_one (M := S) L, IsLocalization.mk'_eq_iff_eq, mul_one,\n      Submonoid.coe_one, ← (IsLocalization.map_units L (s ^ n)).mul_left_cancel hr, map_mul]\n  exact ⟨r₁ * r₂, by rw [IsLocalization.mk'_eq_mul_mk'_one, map_mul, h]⟩\n\n"}
{"name":"IsArtinianRing.localization_artinian","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : IsArtinianRing R\nS : Submonoid R\nL : Type u_2\ninst✝² : CommSemiring L\ninst✝¹ : Algebra R L\ninst✝ : IsLocalization S L\n⊢ IsArtinianRing L","decl":"theorem localization_artinian : IsArtinianRing L :=\n  (localization_surjective S L).isArtinianRing\n\n"}
{"name":"IsArtinianRing.instLocalization","module":"Mathlib.RingTheory.Artinian.Ring","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsArtinianRing R\nS : Submonoid R\n⊢ IsArtinianRing (Localization S)","decl":"/-- `IsArtinianRing.localization_artinian` can't be made an instance, as it would make `S` + `R`\ninto metavariables. However, this is safe. -/\ninstance : IsArtinianRing (Localization S) :=\n  localization_artinian S _\n\n"}
