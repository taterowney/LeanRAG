{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) (J.isoRightDerivedToHomotopyCategoryObj F).hom) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomotopyCategory.quotient D (ComplexShape.up Nat))).map φ))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    F.rightDerivedToHomotopyCategory.map f ≫ (J.isoRightDerivedToHomotopyCategoryObj F).hom =\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ := by\n  dsimp [Functor.rightDerivedToHomotopyCategory, isoRightDerivedToHomotopyCategoryObj]\n  rw [← Functor.map_comp_assoc, iso_hom_naturality f I J φ comm, Functor.map_comp,\n    assoc, assoc]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.up ℕ)).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : HomotopyCategory D (ComplexShape.up Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient D (ComplexShape.up Nat)).obj ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj J.cocomplex)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedToHomotopyCategoryObj F).hom h)) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ)) h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    F.rightDerivedToHomotopyCategory.map f ≫ (J.isoRightDerivedToHomotopyCategoryObj F).hom =\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ := by\n  dsimp [Functor.rightDerivedToHomotopyCategory, isoRightDerivedToHomotopyCategoryObj]\n  rw [← Functor.map_comp_assoc, iso_hom_naturality f I J φ comm, Functor.map_comp,\n    assoc, assoc]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.up ℕ)).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : HomotopyCategory D (ComplexShape.up Nat)\nh : Quiver.Hom (F.rightDerivedToHomotopyCategory.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).inv (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ)) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedToHomotopyCategoryObj F).inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    (I.isoRightDerivedToHomotopyCategoryObj F).inv ≫ F.rightDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ ≫\n        (J.isoRightDerivedToHomotopyCategoryObj F).inv := by\n    rw [← cancel_epi (I.isoRightDerivedToHomotopyCategoryObj F).hom, Iso.hom_inv_id_assoc]\n    dsimp\n    rw [← isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc f I J φ comm F,\n      Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).inv (F.rightDerivedToHomotopyCategory.map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomotopyCategory.quotient D (ComplexShape.up Nat))).map φ) (J.isoRightDerivedToHomotopyCategoryObj F).inv)","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    (I.isoRightDerivedToHomotopyCategoryObj F).inv ≫ F.rightDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map φ ≫\n        (J.isoRightDerivedToHomotopyCategoryObj F).inv := by\n    rw [← cancel_epi (I.isoRightDerivedToHomotopyCategoryObj F).hom, Iso.hom_inv_id_assoc]\n    dsimp\n    rw [← isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc f I J φ comm F,\n      Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) (J.isoRightDerivedObj F n).hom) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map φ))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (F.rightDerived n).map f ≫ (J.isoRightDerivedObj F n).hom =\n      (I.isoRightDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ := by\n  dsimp [isoRightDerivedObj, Functor.rightDerived]\n  rw [assoc, ← Functor.map_comp_assoc,\n    InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality f I J φ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ℕ) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).obj ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj J.cocomplex)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedObj F n).hom h)) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ)) h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_hom_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (F.rightDerived n).map f ≫ (J.isoRightDerivedObj F n).hom =\n      (I.isoRightDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ := by\n  dsimp [isoRightDerivedObj, Functor.rightDerived]\n  rw [assoc, ← Functor.map_comp_assoc,\n    InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality f I J φ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ℕ) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).inv ((F.rightDerived n).map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map φ) (J.isoRightDerivedObj F n).inv)","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (I.isoRightDerivedObj F n).inv ≫ (F.rightDerived n).map f =\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ ≫\n          (J.isoRightDerivedObj F n).inv := by\n  rw [← cancel_mono (J.isoRightDerivedObj F n).hom, assoc, assoc,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f I J φ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((F.rightDerived n).obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).inv (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ)) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedObj F n).inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_inv_naturality\n    {X Y : C} (f : X ⟶ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (φ : I.cocomplex ⟶ J.cocomplex) (comm : I.ι.f 0 ≫ φ.f 0 = f ≫ J.ι.f 0)\n    (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    (I.isoRightDerivedObj F n).inv ≫ (F.rightDerived n).map f =\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map φ ≫\n          (J.isoRightDerivedObj F n).inv := by\n  rw [← cancel_mono (J.isoRightDerivedObj F n).hom, assoc, assoc,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f I J φ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.isZero_rightDerived_obj_injective_succ","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nn : Nat\nX : C\ninst✝ : CategoryTheory.Injective X\n⊢ CategoryTheory.Limits.IsZero ((F.rightDerived (HAdd.hAdd n 1)).obj X)","decl":"/-- The higher derived functors vanish on injective objects. -/\nlemma Functor.isZero_rightDerived_obj_injective_succ\n    (F : C ⥤ D) [F.Additive] (n : ℕ) (X : C) [Injective X] :\n    IsZero ((F.rightDerived (n+1)).obj X) := by\n  refine IsZero.of_iso ?_ ((InjectiveResolution.self X).isoRightDerivedObj F (n + 1))\n  erw [← HomologicalComplex.exactAt_iff_isZero_homology]\n  exact ShortComplex.exact_of_isZero_X₂ _ (F.map_isZero (by apply isZero_zero))\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_map_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\ng : Quiver.Hom P.cocomplex Q.cocomplex\nw : Eq (CategoryTheory.CategoryStruct.comp P.ι g) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single₀ C).map f) Q.ι)\n⊢ Eq ((F.rightDerived n).map f) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map g) (Q.isoRightDerivedObj F n).inv))","decl":"/-- We can compute a right derived functor on a morphism using a descent of that morphism\nto a cochain map between chosen injective resolutions.\n-/\ntheorem Functor.rightDerived_map_eq (F : C ⥤ D) [F.Additive] (n : ℕ) {X Y : C} (f : X ⟶ Y)\n    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ⟶ Q.cocomplex)\n    (w : P.ι ≫ g = (CochainComplex.single₀ C).map f ≫ Q.ι) :\n    (F.rightDerived n).map f =\n      (P.isoRightDerivedObj F n).hom ≫\n        (F.mapHomologicalComplex _ ⋙ HomologicalComplex.homologyFunctor _ _ n).map g ≫\n          (Q.isoRightDerivedObj F n).inv := by\n  rw [← cancel_mono (Q.isoRightDerivedObj F n).hom,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,\n    assoc, assoc, Iso.inv_hom_id, comp_id]\n  rw [← HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,\n    CochainComplex.single₀_map_f_zero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.rightDerivedToHomotopyCategory_app_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : G.Additive\nα : Quiver.Hom F G\nX : C\nP : CategoryTheory.InjectiveResolution X\n⊢ Eq ((CategoryTheory.NatTrans.rightDerivedToHomotopyCategory α).app X) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((CategoryTheory.NatTrans.mapHomologicalComplex α (ComplexShape.up Nat)).app P.cocomplex)) (P.isoRightDerivedToHomotopyCategoryObj G).inv))","decl":"lemma InjectiveResolution.rightDerivedToHomotopyCategory_app_eq\n    {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) {X : C} (P : InjectiveResolution X) :\n    (NatTrans.rightDerivedToHomotopyCategory α).app X =\n      (P.isoRightDerivedToHomotopyCategoryObj F).hom ≫\n        (HomotopyCategory.quotient _ _).map\n          ((NatTrans.mapHomologicalComplex α _).app P.cocomplex) ≫\n          (P.isoRightDerivedToHomotopyCategoryObj G).inv := by\n  rw [← cancel_mono (P.isoRightDerivedToHomotopyCategoryObj G).hom, assoc, assoc,\n      Iso.inv_hom_id, comp_id]\n  dsimp [isoRightDerivedToHomotopyCategoryObj, Functor.mapHomotopyCategoryFactors,\n    NatTrans.rightDerivedToHomotopyCategory]\n  rw [assoc]\n  erw [id_comp, comp_id]\n  obtain ⟨β, hβ⟩ := (HomotopyCategory.quotient _ _).map_surjective (iso P).hom\n  rw [← hβ]\n  dsimp\n  simp only [← Functor.map_comp, NatTrans.mapHomologicalComplex_naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.rightDerivedToHomotopyCategory)","decl":"@[simp]\nlemma NatTrans.rightDerivedToHomotopyCategory_id (F : C ⥤ D) [F.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (𝟙 F) = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_comp","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasInjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\n⊢ Eq (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp α β)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory α) (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory β))","decl":"@[simp, reassoc]\nlemma NatTrans.rightDerivedToHomotopyCategory_comp {F G H : C ⥤ D} (α : F ⟶ G) (β : G ⟶ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (α ≫ β) =\n      NatTrans.rightDerivedToHomotopyCategory α ≫\n        NatTrans.rightDerivedToHomotopyCategory β := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasInjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nZ : CategoryTheory.Functor C (HomotopyCategory D (ComplexShape.up Nat))\nh : Quiver.Hom H.rightDerivedToHomotopyCategory Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp α β)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory β) h))","decl":"@[simp, reassoc]\nlemma NatTrans.rightDerivedToHomotopyCategory_comp {F G H : C ⥤ D} (α : F ⟶ G) (β : G ⟶ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (α ≫ β) =\n      NatTrans.rightDerivedToHomotopyCategory α ≫\n        NatTrans.rightDerivedToHomotopyCategory β := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nn : Nat\n⊢ Eq (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.id F) n) (CategoryTheory.CategoryStruct.id (F.rightDerived n))","decl":"@[simp]\ntheorem NatTrans.rightDerived_id (F : C ⥤ D) [F.Additive] (n : ℕ) :\n    NatTrans.rightDerived (𝟙 F) n = 𝟙 (F.rightDerived n) := by\n  dsimp only [rightDerived]\n  simp only [rightDerivedToHomotopyCategory_id, whiskerRight_id']\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasInjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nn : Nat\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.rightDerived n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.comp α β) n) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived α n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived β n) h))","decl":"@[simp, reassoc]\ntheorem NatTrans.rightDerived_comp {F G H : C ⥤ D} [F.Additive] [G.Additive] [H.Additive]\n    (α : F ⟶ G) (β : G ⟶ H) (n : ℕ) :\n    NatTrans.rightDerived (α ≫ β) n = NatTrans.rightDerived α n ≫ NatTrans.rightDerived β n := by\n  simp [NatTrans.rightDerived]\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_comp","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁷ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁵ : CategoryTheory.Abelian C\ninst✝⁴ : CategoryTheory.HasInjectiveResolutions C\ninst✝³ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst✝² : F.Additive\ninst✝¹ : G.Additive\ninst✝ : H.Additive\nα : Quiver.Hom F G\nβ : Quiver.Hom G H\nn : Nat\n⊢ Eq (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.comp α β) n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived α n) (CategoryTheory.NatTrans.rightDerived β n))","decl":"@[simp, reassoc]\ntheorem NatTrans.rightDerived_comp {F G H : C ⥤ D} [F.Additive] [G.Additive] [H.Additive]\n    (α : F ⟶ G) (β : G ⟶ H) (n : ℕ) :\n    NatTrans.rightDerived (α ≫ β) n = NatTrans.rightDerived α n ≫ NatTrans.rightDerived β n := by\n  simp [NatTrans.rightDerived]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.rightDerived_app_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : G.Additive\nα : Quiver.Hom F G\nX : C\nP : CategoryTheory.InjectiveResolution X\nn : Nat\n⊢ Eq ((CategoryTheory.NatTrans.rightDerived α n).app X) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex α (ComplexShape.up Nat)).app P.cocomplex)) (P.isoRightDerivedObj G n).inv))","decl":"/-- A component of the natural transformation between right-derived functors can be computed\nusing a chosen injective resolution. -/\nlemma rightDerived_app_eq\n    {F G : C ⥤ D} [F.Additive] [G.Additive] (α : F ⟶ G) {X : C} (P : InjectiveResolution X)\n    (n : ℕ) : (NatTrans.rightDerived α n).app X =\n      (P.isoRightDerivedObj F n).hom ≫\n        (HomologicalComplex.homologyFunctor D (ComplexShape.up ℕ) n).map\n        ((NatTrans.mapHomologicalComplex α _).app P.cocomplex) ≫\n        (P.isoRightDerivedObj G n).inv := by\n  dsimp [NatTrans.rightDerived, isoRightDerivedObj]\n  rw [InjectiveResolution.rightDerivedToHomotopyCategory_app_eq α P,\n    Functor.map_comp, Functor.map_comp, assoc]\n  erw [← (HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ℕ) n).hom.naturality_assoc\n    ((NatTrans.mapHomologicalComplex α (ComplexShape.up ℕ)).app P.cocomplex)]\n  simp only [Functor.comp_map, Iso.hom_inv_id_app_assoc]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_comp_iCycles","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).iCycles 0)) (F.map (P.ι.f 0))","decl":"@[reassoc (attr := simp)]\nlemma toRightDerivedZero'_comp_iCycles {C} [Category C] [Abelian C] {X : C}\n    (P : InjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    P.toRightDerivedZero' F ≫\n      HomologicalComplex.iCycles _ _ = F.map (P.ι.f 0) := by\n  simp [toRightDerivedZero']\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_comp_iCycles_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : D\nh : Quiver.Hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).X 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).iCycles 0) h)) (CategoryTheory.CategoryStruct.comp (F.map (P.ι.f 0)) h)","decl":"@[reassoc (attr := simp)]\nlemma toRightDerivedZero'_comp_iCycles {C} [Category C] [Abelian C] {X : C}\n    (P : InjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    P.toRightDerivedZero' F ≫\n      HomologicalComplex.iCycles _ _ = F.map (P.ι.f 0) := by\n  simp [toRightDerivedZero']\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom P.cocomplex Q.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (P.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (Q.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (Q.toRightDerivedZero' F)) (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (HomologicalComplex.cyclesMap ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ) 0))","decl":"@[reassoc]\nlemma toRightDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ⟶ Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y)\n    (φ : P.cocomplex ⟶ Q.cocomplex) (comm : P.ι.f 0 ≫ φ.f 0 = f ≫ Q.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    F.map f ≫ Q.toRightDerivedZero' F =\n      P.toRightDerivedZero' F ≫\n        HomologicalComplex.cyclesMap ((F.mapHomologicalComplex _).map φ) 0 := by\n  simp only [← cancel_mono (HomologicalComplex.iCycles _ _),\n    Functor.mapHomologicalComplex_obj_X, assoc, toRightDerivedZero'_comp_iCycles,\n    CochainComplex.single₀_obj_zero, HomologicalComplex.cyclesMap_i,\n    Functor.mapHomologicalComplex_map_f, toRightDerivedZero'_comp_iCycles_assoc,\n    ← F.map_comp, comm]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} D\ninst✝³ : CategoryTheory.Abelian D\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\nφ : Quiver.Hom P.cocomplex Q.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (P.ι.f 0) (φ.f 0)) (CategoryTheory.CategoryStruct.comp f (Q.ι.f 0))\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nZ : D\nh : Quiver.Hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj Q.cocomplex).cycles 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (Q.toRightDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap ((F.mapHomologicalComplex (ComplexShape.up Nat)).map φ) 0) h))","decl":"@[reassoc]\nlemma toRightDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ⟶ Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y)\n    (φ : P.cocomplex ⟶ Q.cocomplex) (comm : P.ι.f 0 ≫ φ.f 0 = f ≫ Q.ι.f 0)\n    (F : C ⥤ D) [F.Additive] :\n    F.map f ≫ Q.toRightDerivedZero' F =\n      P.toRightDerivedZero' F ≫\n        HomologicalComplex.cyclesMap ((F.mapHomologicalComplex _).map φ) 0 := by\n  simp only [← cancel_mono (HomologicalComplex.iCycles _ _),\n    Functor.mapHomologicalComplex_obj_X, assoc, toRightDerivedZero'_comp_iCycles,\n    CochainComplex.single₀_obj_zero, HomologicalComplex.cyclesMap_i,\n    Functor.mapHomologicalComplex_map_f, toRightDerivedZero'_comp_iCycles_assoc,\n    ← F.map_comp, comm]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instIsIsoToRightDerivedZero'Self","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nX : C\ninst✝ : CategoryTheory.Injective X\n⊢ CategoryTheory.IsIso ((CategoryTheory.InjectiveResolution.self X).toRightDerivedZero' F)","decl":"instance (F : C ⥤ D) [F.Additive] (X : C) [Injective X] :\n    IsIso ((InjectiveResolution.self X).toRightDerivedZero' F) := by\n  dsimp [InjectiveResolution.toRightDerivedZero']\n  rw [CochainComplex.isIso_liftCycles_iff]\n  refine ⟨ShortComplex.Splitting.exact ?_, inferInstance⟩\n  exact\n    { r := 𝟙 _\n      s := 0\n      s_g := (F.map_isZero (isZero_zero _)).eq_of_src _ _ }\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nX : C\nI : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (F.toRightDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (I.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (CochainComplex.isoHomologyπ₀ ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj I.cocomplex)).hom (I.isoRightDerivedObj F 0).inv))","decl":"lemma InjectiveResolution.toRightDerivedZero_eq\n    {X : C} (I : InjectiveResolution X) (F : C ⥤ D) [F.Additive] :\n    F.toRightDerivedZero.app X = I.toRightDerivedZero' F ≫\n      (CochainComplex.isoHomologyπ₀ _).hom ≫ (I.isoRightDerivedObj F 0).inv := by\n  dsimp [Functor.toRightDerivedZero, isoRightDerivedObj]\n  have h₁ := InjectiveResolution.toRightDerivedZero'_naturality\n    (𝟙 X) (injectiveResolution X) I (desc (𝟙 X) _ _) (by simp) F\n  simp only [Functor.map_id, id_comp] at h₁\n  have h₂ : (I.isoRightDerivedToHomotopyCategoryObj F).hom =\n    (F.mapHomologicalComplex _ ⋙ HomotopyCategory.quotient _ _).map (desc (𝟙 X) _ _) :=\n    comp_id _\n  rw [← cancel_mono ((HomotopyCategory.homologyFunctor _ _ 0).map\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom),\n    assoc, assoc, assoc, assoc, assoc, ← Functor.map_comp,\n    Iso.inv_hom_id, Functor.map_id, comp_id,\n    reassoc_of% h₁, h₂, ← HomologicalComplex.homologyπ_naturality_assoc]\n  erw [← NatTrans.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.instIsIsoAppToRightDerivedZeroOfInjective","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\nX : C\ninst✝ : CategoryTheory.Injective X\n⊢ CategoryTheory.IsIso (F.toRightDerivedZero.app X)","decl":"instance (F : C ⥤ D) [F.Additive] (X : C) [Injective X] :\n    IsIso (F.toRightDerivedZero.app X) := by\n  rw [(InjectiveResolution.self X).toRightDerivedZero_eq F]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoToRightDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} D\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\nP : CategoryTheory.InjectiveResolution X\n⊢ CategoryTheory.IsIso (P.toRightDerivedZero' F)","decl":"instance {X : C} (P : InjectiveResolution X) :\n    IsIso (P.toRightDerivedZero' F) := by\n  dsimp [InjectiveResolution.toRightDerivedZero']\n  rw [CochainComplex.isIso_liftCycles_iff, ShortComplex.exact_and_mono_f_iff_f_is_kernel]\n  exact ⟨KernelFork.mapIsLimit _ (P.isLimitKernelFork) F⟩\n\n"}
{"name":"CategoryTheory.instIsIsoAppToRightDerivedZero","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX : C\n⊢ CategoryTheory.IsIso (F.toRightDerivedZero.app X)","decl":"instance (X : C) : IsIso (F.toRightDerivedZero.app X) := by\n  dsimp [Functor.toRightDerivedZero]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorToRightDerivedZero","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ CategoryTheory.IsIso F.toRightDerivedZero","decl":"instance : IsIso F.toRightDerivedZero :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_2, u_1} D\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.HasInjectiveResolutions C\ninst✝¹ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq F.rightDerivedZeroIsoSelf.inv F.toRightDerivedZero","decl":"/-- The canonical isomorphism `F.rightDerived 0 ≅ F` when `F` is left exact\n(i.e. preserves finite limits). -/\n@[simps! inv]\nnoncomputable def rightDerivedZeroIsoSelf : F.rightDerived 0 ≅ F :=\n  (asIso F.toRightDerivedZero).symm\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom F.toRightDerivedZero) (CategoryTheory.CategoryStruct.id (F.rightDerived 0))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id :\n    F.rightDerivedZeroIsoSelf.hom ≫ F.toRightDerivedZero = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.rightDerived 0) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id :\n    F.rightDerivedZeroIsoSelf.hom ≫ F.toRightDerivedZero = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id :\n    F.toRightDerivedZero ≫ F.rightDerivedZeroIsoSelf.hom = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\n⊢ Eq (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero F.rightDerivedZeroIsoSelf.hom) (CategoryTheory.CategoryStruct.id F)","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id :\n    F.toRightDerivedZero ≫ F.rightDerivedZeroIsoSelf.hom = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\nZ : D\nh : Quiver.Hom ((F.rightDerived 0).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.rightDerivedZeroIsoSelf.hom.app X ≫ F.toRightDerivedZero.app X = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_app","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) (F.toRightDerivedZero.app X)) (CategoryTheory.CategoryStruct.id ((F.rightDerived 0).obj X))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.rightDerivedZeroIsoSelf.hom.app X ≫ F.toRightDerivedZero.app X = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.toRightDerivedZero.app X ≫ F.rightDerivedZeroIsoSelf.hom.app X = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_app","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} D\ninst✝⁴ : CategoryTheory.Abelian C\ninst✝³ : CategoryTheory.HasInjectiveResolutions C\ninst✝² : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) (F.rightDerivedZeroIsoSelf.hom.app X)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.toRightDerivedZero.app X ≫ F.rightDerivedZeroIsoSelf.hom.app X = 𝟙 _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
