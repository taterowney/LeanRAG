{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) (J.isoRightDerivedToHomotopyCategoryObj F).hom) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomotopyCategory.quotient D (ComplexShape.up Nat))).map œÜ))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    F.rightDerivedToHomotopyCategory.map f ‚â´ (J.isoRightDerivedToHomotopyCategoryObj F).hom =\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ := by\n  dsimp [Functor.rightDerivedToHomotopyCategory, isoRightDerivedToHomotopyCategoryObj]\n  rw [‚Üê Functor.map_comp_assoc, iso_hom_naturality f I J œÜ comm, Functor.map_comp,\n    assoc, assoc]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.up ‚Ñï)).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : HomotopyCategory D (ComplexShape.up Nat)\nh : Quiver.Hom ((HomotopyCategory.quotient D (ComplexShape.up Nat)).obj ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj J.cocomplex)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedToHomotopyCategoryObj F).hom h)) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ)) h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    F.rightDerivedToHomotopyCategory.map f ‚â´ (J.isoRightDerivedToHomotopyCategoryObj F).hom =\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ := by\n  dsimp [Functor.rightDerivedToHomotopyCategory, isoRightDerivedToHomotopyCategoryObj]\n  rw [‚Üê Functor.map_comp_assoc, iso_hom_naturality f I J œÜ comm, Functor.map_comp,\n    assoc, assoc]\n  erw [(F.mapHomotopyCategoryFactors (ComplexShape.up ‚Ñï)).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : HomotopyCategory D (ComplexShape.up Nat)\nh : Quiver.Hom (F.rightDerivedToHomotopyCategory.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).inv (CategoryTheory.CategoryStruct.comp (F.rightDerivedToHomotopyCategory.map f) h)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ)) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedToHomotopyCategoryObj F).inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    (I.isoRightDerivedToHomotopyCategoryObj F).inv ‚â´ F.rightDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ ‚â´\n        (J.isoRightDerivedToHomotopyCategoryObj F).inv := by\n    rw [‚Üê cancel_epi (I.isoRightDerivedToHomotopyCategoryObj F).hom, Iso.hom_inv_id_assoc]\n    dsimp\n    rw [‚Üê isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc f I J œÜ comm F,\n      Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedToHomotopyCategoryObj F).inv (F.rightDerivedToHomotopyCategory.map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomotopyCategory.quotient D (ComplexShape.up Nat))).map œÜ) (J.isoRightDerivedToHomotopyCategoryObj F).inv)","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    (I.isoRightDerivedToHomotopyCategoryObj F).inv ‚â´ F.rightDerivedToHomotopyCategory.map f =\n      (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map œÜ ‚â´\n        (J.isoRightDerivedToHomotopyCategoryObj F).inv := by\n    rw [‚Üê cancel_epi (I.isoRightDerivedToHomotopyCategoryObj F).hom, Iso.hom_inv_id_assoc]\n    dsimp\n    rw [‚Üê isoRightDerivedToHomotopyCategoryObj_hom_naturality_assoc f I J œÜ comm F,\n      Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) (J.isoRightDerivedObj F n).hom) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map œÜ))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (F.rightDerived n).map f ‚â´ (J.isoRightDerivedObj F n).hom =\n      (I.isoRightDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ := by\n  dsimp [isoRightDerivedObj, Functor.rightDerived]\n  rw [assoc, ‚Üê Functor.map_comp_assoc,\n    InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality f I J œÜ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ‚Ñï) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_hom_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).obj ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj J.cocomplex)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedObj F n).hom h)) (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ)) h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_hom_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (F.rightDerived n).map f ‚â´ (J.isoRightDerivedObj F n).hom =\n      (I.isoRightDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ := by\n  dsimp [isoRightDerivedObj, Functor.rightDerived]\n  rw [assoc, ‚Üê Functor.map_comp_assoc,\n    InjectiveResolution.isoRightDerivedToHomotopyCategoryObj_hom_naturality f I J œÜ comm F,\n    Functor.map_comp, assoc]\n  erw [(HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ‚Ñï) n).hom.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_inv_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).inv ((F.rightDerived n).map f)) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map œÜ) (J.isoRightDerivedObj F n).inv)","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (I.isoRightDerivedObj F n).inv ‚â´ (F.rightDerived n).map f =\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ ‚â´\n          (J.isoRightDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (J.isoRightDerivedObj F n).hom, assoc, assoc,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f I J œÜ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.isoRightDerivedObj_inv_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX Y : C\nf : Quiver.Hom X Y\nI : CategoryTheory.InjectiveResolution X\nJ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom I.cocomplex J.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (I.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (J.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nZ : D\nh : Quiver.Hom ((F.rightDerived n).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (I.isoRightDerivedObj F n).inv (CategoryTheory.CategoryStruct.comp ((F.rightDerived n).map f) h)) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ)) (CategoryTheory.CategoryStruct.comp (J.isoRightDerivedObj F n).inv h))","decl":"@[reassoc]\nlemma InjectiveResolution.isoRightDerivedObj_inv_naturality\n    {X Y : C} (f : X ‚ü∂ Y) (I : InjectiveResolution X) (J : InjectiveResolution Y)\n    (œÜ : I.cocomplex ‚ü∂ J.cocomplex) (comm : I.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ J.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    (I.isoRightDerivedObj F n).inv ‚â´ (F.rightDerived n).map f =\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map œÜ ‚â´\n          (J.isoRightDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (J.isoRightDerivedObj F n).hom, assoc, assoc,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f I J œÜ comm F n,\n    Iso.inv_hom_id_assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.Functor.isZero_rightDerived_obj_injective_succ","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nn : Nat\nX : C\ninst‚úù : CategoryTheory.Injective X\n‚ä¢ CategoryTheory.Limits.IsZero ((F.rightDerived (HAdd.hAdd n 1)).obj X)","decl":"/-- The higher derived functors vanish on injective objects. -/\nlemma Functor.isZero_rightDerived_obj_injective_succ\n    (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) (X : C) [Injective X] :\n    IsZero ((F.rightDerived (n+1)).obj X) := by\n  refine IsZero.of_iso ?_ ((InjectiveResolution.self X).isoRightDerivedObj F (n + 1))\n  erw [‚Üê HomologicalComplex.exactAt_iff_isZero_homology]\n  exact ShortComplex.exact_of_isZero_X‚ÇÇ _ (F.map_isZero (by apply isZero_zero))\n\n"}
{"name":"CategoryTheory.Functor.rightDerived_map_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\ng : Quiver.Hom P.cocomplex Q.cocomplex\nw : Eq (CategoryTheory.CategoryStruct.comp P.Œπ g) (CategoryTheory.CategoryStruct.comp ((CochainComplex.single‚ÇÄ C).map f) Q.Œπ)\n‚ä¢ Eq ((F.rightDerived n).map f) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).comp (HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n)).map g) (Q.isoRightDerivedObj F n).inv))","decl":"/-- We can compute a right derived functor on a morphism using a descent of that morphism\nto a cochain map between chosen injective resolutions.\n-/\ntheorem Functor.rightDerived_map_eq (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) {X Y : C} (f : X ‚ü∂ Y)\n    {P : InjectiveResolution X} {Q : InjectiveResolution Y} (g : P.cocomplex ‚ü∂ Q.cocomplex)\n    (w : P.Œπ ‚â´ g = (CochainComplex.single‚ÇÄ C).map f ‚â´ Q.Œπ) :\n    (F.rightDerived n).map f =\n      (P.isoRightDerivedObj F n).hom ‚â´\n        (F.mapHomologicalComplex _ ‚ãô HomologicalComplex.homologyFunctor _ _ n).map g ‚â´\n          (Q.isoRightDerivedObj F n).inv := by\n  rw [‚Üê cancel_mono (Q.isoRightDerivedObj F n).hom,\n    InjectiveResolution.isoRightDerivedObj_hom_naturality f P Q g _ F n,\n    assoc, assoc, Iso.inv_hom_id, comp_id]\n  rw [‚Üê HomologicalComplex.comp_f, w, HomologicalComplex.comp_f,\n    CochainComplex.single‚ÇÄ_map_f_zero]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.rightDerivedToHomotopyCategory_app_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : G.Additive\nŒ± : Quiver.Hom F G\nX : C\nP : CategoryTheory.InjectiveResolution X\n‚ä¢ Eq ((CategoryTheory.NatTrans.rightDerivedToHomotopyCategory Œ±).app X) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedToHomotopyCategoryObj F).hom (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient D (ComplexShape.up Nat)).map ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± (ComplexShape.up Nat)).app P.cocomplex)) (P.isoRightDerivedToHomotopyCategoryObj G).inv))","decl":"lemma InjectiveResolution.rightDerivedToHomotopyCategory_app_eq\n    {F G : C ‚•§ D} [F.Additive] [G.Additive] (Œ± : F ‚ü∂ G) {X : C} (P : InjectiveResolution X) :\n    (NatTrans.rightDerivedToHomotopyCategory Œ±).app X =\n      (P.isoRightDerivedToHomotopyCategoryObj F).hom ‚â´\n        (HomotopyCategory.quotient _ _).map\n          ((NatTrans.mapHomologicalComplex Œ± _).app P.cocomplex) ‚â´\n          (P.isoRightDerivedToHomotopyCategoryObj G).inv := by\n  rw [‚Üê cancel_mono (P.isoRightDerivedToHomotopyCategoryObj G).hom, assoc, assoc,\n      Iso.inv_hom_id, comp_id]\n  dsimp [isoRightDerivedToHomotopyCategoryObj, Functor.mapHomotopyCategoryFactors,\n    NatTrans.rightDerivedToHomotopyCategory]\n  rw [assoc]\n  erw [id_comp, comp_id]\n  obtain ‚ü®Œ≤, hŒ≤‚ü© := (HomotopyCategory.quotient _ _).map_surjective (iso P).hom\n  rw [‚Üê hŒ≤]\n  dsimp\n  simp only [‚Üê Functor.map_comp, NatTrans.mapHomologicalComplex_naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F.rightDerivedToHomotopyCategory)","decl":"@[simp]\nlemma NatTrans.rightDerivedToHomotopyCategory_id (F : C ‚•§ D) [F.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (ùüô F) = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_comp","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\n‚ä¢ Eq (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory Œ±) (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory Œ≤))","decl":"@[simp, reassoc]\nlemma NatTrans.rightDerivedToHomotopyCategory_comp {F G H : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (Œ± ‚â´ Œ≤) =\n      NatTrans.rightDerivedToHomotopyCategory Œ± ‚â´\n        NatTrans.rightDerivedToHomotopyCategory Œ≤ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerivedToHomotopyCategory_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nZ : CategoryTheory.Functor C (HomotopyCategory D (ComplexShape.up Nat))\nh : Quiver.Hom H.rightDerivedToHomotopyCategory Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory Œ±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerivedToHomotopyCategory Œ≤) h))","decl":"@[simp, reassoc]\nlemma NatTrans.rightDerivedToHomotopyCategory_comp {F G H : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H)\n    [F.Additive] [G.Additive] [H.Additive] :\n    NatTrans.rightDerivedToHomotopyCategory (Œ± ‚â´ Œ≤) =\n      NatTrans.rightDerivedToHomotopyCategory Œ± ‚â´\n        NatTrans.rightDerivedToHomotopyCategory Œ≤ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nn : Nat\n‚ä¢ Eq (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.id F) n) (CategoryTheory.CategoryStruct.id (F.rightDerived n))","decl":"@[simp]\ntheorem NatTrans.rightDerived_id (F : C ‚•§ D) [F.Additive] (n : ‚Ñï) :\n    NatTrans.rightDerived (ùüô F) n = ùüô (F.rightDerived n) := by\n  dsimp only [rightDerived]\n  simp only [rightDerivedToHomotopyCategory_id, whiskerRight_id']\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nn : Nat\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.rightDerived n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.comp Œ± Œ≤) n) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived Œ± n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived Œ≤ n) h))","decl":"@[simp, reassoc]\ntheorem NatTrans.rightDerived_comp {F G H : C ‚•§ D} [F.Additive] [G.Additive] [H.Additive]\n    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (n : ‚Ñï) :\n    NatTrans.rightDerived (Œ± ‚â´ Œ≤) n = NatTrans.rightDerived Œ± n ‚â´ NatTrans.rightDerived Œ≤ n := by\n  simp [NatTrans.rightDerived]\n\n"}
{"name":"CategoryTheory.NatTrans.rightDerived_comp","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Åµ : CategoryTheory.Abelian C\ninst‚úù‚Å¥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≥ : CategoryTheory.Abelian D\nF G H : CategoryTheory.Functor C D\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nn : Nat\n‚ä¢ Eq (CategoryTheory.NatTrans.rightDerived (CategoryTheory.CategoryStruct.comp Œ± Œ≤) n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.rightDerived Œ± n) (CategoryTheory.NatTrans.rightDerived Œ≤ n))","decl":"@[simp, reassoc]\ntheorem NatTrans.rightDerived_comp {F G H : C ‚•§ D} [F.Additive] [G.Additive] [H.Additive]\n    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (n : ‚Ñï) :\n    NatTrans.rightDerived (Œ± ‚â´ Œ≤) n = NatTrans.rightDerived Œ± n ‚â´ NatTrans.rightDerived Œ≤ n := by\n  simp [NatTrans.rightDerived]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.rightDerived_app_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF G : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : G.Additive\nŒ± : Quiver.Hom F G\nX : C\nP : CategoryTheory.InjectiveResolution X\nn : Nat\n‚ä¢ Eq ((CategoryTheory.NatTrans.rightDerived Œ± n).app X) (CategoryTheory.CategoryStruct.comp (P.isoRightDerivedObj F n).hom (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor D (ComplexShape.up Nat) n).map ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± (ComplexShape.up Nat)).app P.cocomplex)) (P.isoRightDerivedObj G n).inv))","decl":"/-- A component of the natural transformation between right-derived functors can be computed\nusing a chosen injective resolution. -/\nlemma rightDerived_app_eq\n    {F G : C ‚•§ D} [F.Additive] [G.Additive] (Œ± : F ‚ü∂ G) {X : C} (P : InjectiveResolution X)\n    (n : ‚Ñï) : (NatTrans.rightDerived Œ± n).app X =\n      (P.isoRightDerivedObj F n).hom ‚â´\n        (HomologicalComplex.homologyFunctor D (ComplexShape.up ‚Ñï) n).map\n        ((NatTrans.mapHomologicalComplex Œ± _).app P.cocomplex) ‚â´\n        (P.isoRightDerivedObj G n).inv := by\n  dsimp [NatTrans.rightDerived, isoRightDerivedObj]\n  rw [InjectiveResolution.rightDerivedToHomotopyCategory_app_eq Œ± P,\n    Functor.map_comp, Functor.map_comp, assoc]\n  erw [‚Üê (HomotopyCategory.homologyFunctorFactors D (ComplexShape.up ‚Ñï) n).hom.naturality_assoc\n    ((NatTrans.mapHomologicalComplex Œ± (ComplexShape.up ‚Ñï)).app P.cocomplex)]\n  simp only [Functor.comp_map, Iso.hom_inv_id_app_assoc]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_comp_iCycles","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).iCycles 0)) (F.map (P.Œπ.f 0))","decl":"@[reassoc (attr := simp)]\nlemma toRightDerivedZero'_comp_iCycles {C} [Category C] [Abelian C] {X : C}\n    (P : InjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    P.toRightDerivedZero' F ‚â´\n      HomologicalComplex.iCycles _ _ = F.map (P.Œπ.f 0) := by\n  simp [toRightDerivedZero']\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_comp_iCycles_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX : C\nP : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : D\nh : Quiver.Hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).X 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj P.cocomplex).iCycles 0) h)) (CategoryTheory.CategoryStruct.comp (F.map (P.Œπ.f 0)) h)","decl":"@[reassoc (attr := simp)]\nlemma toRightDerivedZero'_comp_iCycles {C} [Category C] [Abelian C] {X : C}\n    (P : InjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    P.toRightDerivedZero' F ‚â´\n      HomologicalComplex.iCycles _ _ = F.map (P.Œπ.f 0) := by\n  simp [toRightDerivedZero']\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_naturality","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom P.cocomplex Q.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (P.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (Q.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (Q.toRightDerivedZero' F)) (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (HomologicalComplex.cyclesMap ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ) 0))","decl":"@[reassoc]\nlemma toRightDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ‚ü∂ Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y)\n    (œÜ : P.cocomplex ‚ü∂ Q.cocomplex) (comm : P.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ Q.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    F.map f ‚â´ Q.toRightDerivedZero' F =\n      P.toRightDerivedZero' F ‚â´\n        HomologicalComplex.cyclesMap ((F.mapHomologicalComplex _).map œÜ) 0 := by\n  simp only [‚Üê cancel_mono (HomologicalComplex.iCycles _ _),\n    Functor.mapHomologicalComplex_obj_X, assoc, toRightDerivedZero'_comp_iCycles,\n    CochainComplex.single‚ÇÄ_obj_zero, HomologicalComplex.cyclesMap_i,\n    Functor.mapHomologicalComplex_map_f, toRightDerivedZero'_comp_iCycles_assoc,\n    ‚Üê F.map_comp, comm]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero'_naturality_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"D : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian D\nC : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬π : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\nP : CategoryTheory.InjectiveResolution X\nQ : CategoryTheory.InjectiveResolution Y\nœÜ : Quiver.Hom P.cocomplex Q.cocomplex\ncomm : Eq (CategoryTheory.CategoryStruct.comp (P.Œπ.f 0) (œÜ.f 0)) (CategoryTheory.CategoryStruct.comp f (Q.Œπ.f 0))\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nZ : D\nh : Quiver.Hom (((F.mapHomologicalComplex (ComplexShape.up Nat)).obj Q.cocomplex).cycles 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (Q.toRightDerivedZero' F) h)) (CategoryTheory.CategoryStruct.comp (P.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap ((F.mapHomologicalComplex (ComplexShape.up Nat)).map œÜ) 0) h))","decl":"@[reassoc]\nlemma toRightDerivedZero'_naturality {C} [Category C] [Abelian C] {X Y : C} (f : X ‚ü∂ Y)\n    (P : InjectiveResolution X) (Q : InjectiveResolution Y)\n    (œÜ : P.cocomplex ‚ü∂ Q.cocomplex) (comm : P.Œπ.f 0 ‚â´ œÜ.f 0 = f ‚â´ Q.Œπ.f 0)\n    (F : C ‚•§ D) [F.Additive] :\n    F.map f ‚â´ Q.toRightDerivedZero' F =\n      P.toRightDerivedZero' F ‚â´\n        HomologicalComplex.cyclesMap ((F.mapHomologicalComplex _).map œÜ) 0 := by\n  simp only [‚Üê cancel_mono (HomologicalComplex.iCycles _ _),\n    Functor.mapHomologicalComplex_obj_X, assoc, toRightDerivedZero'_comp_iCycles,\n    CochainComplex.single‚ÇÄ_obj_zero, HomologicalComplex.cyclesMap_i,\n    Functor.mapHomologicalComplex_map_f, toRightDerivedZero'_comp_iCycles_assoc,\n    ‚Üê F.map_comp, comm]\n\n"}
{"name":"CategoryTheory.InjectiveResolution.instIsIsoToRightDerivedZero'Self","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nX : C\ninst‚úù : CategoryTheory.Injective X\n‚ä¢ CategoryTheory.IsIso ((CategoryTheory.InjectiveResolution.self X).toRightDerivedZero' F)","decl":"instance (F : C ‚•§ D) [F.Additive] (X : C) [Injective X] :\n    IsIso ((InjectiveResolution.self X).toRightDerivedZero' F) := by\n  dsimp [InjectiveResolution.toRightDerivedZero']\n  rw [CochainComplex.isIso_liftCycles_iff]\n  refine ‚ü®ShortComplex.Splitting.exact ?_, inferInstance‚ü©\n  exact\n    { r := ùüô _\n      s := 0\n      s_g := (F.map_isZero (isZero_zero _)).eq_of_src _ _ }\n\n"}
{"name":"CategoryTheory.InjectiveResolution.toRightDerivedZero_eq","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nX : C\nI : CategoryTheory.InjectiveResolution X\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (F.toRightDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (I.toRightDerivedZero' F) (CategoryTheory.CategoryStruct.comp (CochainComplex.isoHomologyœÄ‚ÇÄ ((F.mapHomologicalComplex (ComplexShape.up Nat)).obj I.cocomplex)).hom (I.isoRightDerivedObj F 0).inv))","decl":"lemma InjectiveResolution.toRightDerivedZero_eq\n    {X : C} (I : InjectiveResolution X) (F : C ‚•§ D) [F.Additive] :\n    F.toRightDerivedZero.app X = I.toRightDerivedZero' F ‚â´\n      (CochainComplex.isoHomologyœÄ‚ÇÄ _).hom ‚â´ (I.isoRightDerivedObj F 0).inv := by\n  dsimp [Functor.toRightDerivedZero, isoRightDerivedObj]\n  have h‚ÇÅ := InjectiveResolution.toRightDerivedZero'_naturality\n    (ùüô X) (injectiveResolution X) I (desc (ùüô X) _ _) (by simp) F\n  simp only [Functor.map_id, id_comp] at h‚ÇÅ\n  have h‚ÇÇ : (I.isoRightDerivedToHomotopyCategoryObj F).hom =\n    (F.mapHomologicalComplex _ ‚ãô HomotopyCategory.quotient _ _).map (desc (ùüô X) _ _) :=\n    comp_id _\n  rw [‚Üê cancel_mono ((HomotopyCategory.homologyFunctor _ _ 0).map\n      (I.isoRightDerivedToHomotopyCategoryObj F).hom),\n    assoc, assoc, assoc, assoc, assoc, ‚Üê Functor.map_comp,\n    Iso.inv_hom_id, Functor.map_id, comp_id,\n    reassoc_of% h‚ÇÅ, h‚ÇÇ, ‚Üê HomologicalComplex.homologyœÄ_naturality_assoc]\n  erw [‚Üê NatTrans.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.instIsIsoAppToRightDerivedZeroOfInjective","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\nX : C\ninst‚úù : CategoryTheory.Injective X\n‚ä¢ CategoryTheory.IsIso (F.toRightDerivedZero.app X)","decl":"instance (F : C ‚•§ D) [F.Additive] (X : C) [Injective X] :\n    IsIso (F.toRightDerivedZero.app X) := by\n  rw [(InjectiveResolution.self X).toRightDerivedZero_eq F]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoToRightDerivedZero'","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≤ : CategoryTheory.Abelian C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\nP : CategoryTheory.InjectiveResolution X\n‚ä¢ CategoryTheory.IsIso (P.toRightDerivedZero' F)","decl":"instance {X : C} (P : InjectiveResolution X) :\n    IsIso (P.toRightDerivedZero' F) := by\n  dsimp [InjectiveResolution.toRightDerivedZero']\n  rw [CochainComplex.isIso_liftCycles_iff, ShortComplex.exact_and_mono_f_iff_f_is_kernel]\n  exact ‚ü®KernelFork.mapIsLimit _ (P.isLimitKernelFork) F‚ü©\n\n"}
{"name":"CategoryTheory.instIsIsoAppToRightDerivedZero","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX : C\n‚ä¢ CategoryTheory.IsIso (F.toRightDerivedZero.app X)","decl":"instance (X : C) : IsIso (F.toRightDerivedZero.app X) := by\n  dsimp [Functor.toRightDerivedZero]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instIsIsoFunctorToRightDerivedZero","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ CategoryTheory.IsIso F.toRightDerivedZero","decl":"instance : IsIso F.toRightDerivedZero :=\n  NatIso.isIso_of_isIso_app _\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù¬≥ : CategoryTheory.Abelian C\ninst‚úù¬≤ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq F.rightDerivedZeroIsoSelf.inv F.toRightDerivedZero","decl":"/-- The canonical isomorphism `F.rightDerived 0 ‚âÖ F` when `F` is left exact\n(i.e. preserves finite limits). -/\n@[simps! inv]\nnoncomputable def rightDerivedZeroIsoSelf : F.rightDerived 0 ‚âÖ F :=\n  (asIso F.toRightDerivedZero).symm\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom F.toRightDerivedZero) (CategoryTheory.CategoryStruct.id (F.rightDerived 0))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id :\n    F.rightDerivedZeroIsoSelf.hom ‚â´ F.toRightDerivedZero = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.rightDerived 0) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id :\n    F.rightDerivedZeroIsoSelf.hom ‚â´ F.toRightDerivedZero = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom F Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero (CategoryTheory.CategoryStruct.comp F.rightDerivedZeroIsoSelf.hom h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id :\n    F.toRightDerivedZero ‚â´ F.rightDerivedZeroIsoSelf.hom = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp F.toRightDerivedZero F.rightDerivedZeroIsoSelf.hom) (CategoryTheory.CategoryStruct.id F)","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id :\n    F.toRightDerivedZero ‚â´ F.rightDerivedZeroIsoSelf.hom = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\nZ : D\nh : Quiver.Hom ((F.rightDerived 0).obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.rightDerivedZeroIsoSelf.hom.app X ‚â´ F.toRightDerivedZero.app X = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_hom_inv_id_app","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) (F.toRightDerivedZero.app X)) (CategoryTheory.CategoryStruct.id ((F.rightDerived 0).obj X))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_hom_inv_id_app (X : C) :\n    F.rightDerivedZeroIsoSelf.hom.app X ‚â´ F.toRightDerivedZero.app X = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.hom_inv_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) (CategoryTheory.CategoryStruct.comp (F.rightDerivedZeroIsoSelf.hom.app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.toRightDerivedZero.app X ‚â´ F.rightDerivedZeroIsoSelf.hom.app X = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
{"name":"CategoryTheory.Functor.rightDerivedZeroIsoSelf_inv_hom_id_app","module":"Mathlib.CategoryTheory.Abelian.RightDerived","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} D\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\ninst‚úù¬≥ : CategoryTheory.HasInjectiveResolutions C\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.toRightDerivedZero.app X) (F.rightDerivedZeroIsoSelf.hom.app X)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\nlemma rightDerivedZeroIsoSelf_inv_hom_id_app (X : C) :\n    F.toRightDerivedZero.app X ‚â´ F.rightDerivedZeroIsoSelf.hom.app X = ùüô _ :=\n  F.rightDerivedZeroIsoSelf.inv_hom_id_app X\n\n"}
