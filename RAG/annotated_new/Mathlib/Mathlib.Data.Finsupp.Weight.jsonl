{"name":"Finsupp.weight_apply","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝² : Semiring R\nw : σ → M\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Finsupp σ R\n⊢ Eq ((Finsupp.weight w) f) (f.sum fun i c => HSMul.hSMul c (w i))","decl":"theorem weight_apply (f : σ →₀ R) :\n    weight w f = Finsupp.sum f (fun i c => c • w i) := rfl\n\n"}
{"name":"Finsupp.weight_single_index","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : DecidableEq σ\ns : σ\nc : M\nf : Finsupp σ R\n⊢ Eq ((Finsupp.weight (Pi.single s c)) f) (HSMul.hSMul (f s) c)","decl":"theorem weight_single_index [DecidableEq σ] (s : σ) (c : M) (f : σ →₀ R) :\n    weight (Pi.single s c) f = f s • c :=\n  linearCombination_single_index σ M R c s f\n\n"}
{"name":"Finsupp.weight_single_one_apply","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝¹ : Semiring R\ninst✝ : DecidableEq σ\ns : σ\nf : Finsupp σ R\n⊢ Eq ((Finsupp.weight (Pi.single s 1)) f) (f s)","decl":"theorem weight_single_one_apply [DecidableEq σ] (s : σ) (f : σ →₀ R) :\n    weight (Pi.single s 1) f = f s := by\n  rw [weight_single_index, smul_eq_mul, mul_one]\n\n"}
{"name":"Finsupp.weight_single","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝² : Semiring R\nw : σ → M\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : σ\nr : R\n⊢ Eq ((Finsupp.weight w) (Finsupp.single s r)) (HSMul.hSMul r (w s))","decl":"theorem weight_single (s : σ) (r : R) :\n    weight w (Finsupp.single s r) = r • w s :=\n  Finsupp.linearCombination_single _ _ _\n\n"}
{"name":"Finsupp.NonTorsionWeight.eq_zero_of_smul_eq_zero","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nw : σ → M\nself : Finsupp.NonTorsionWeight R w\nr : R\ns : σ\nh : Eq (HSMul.hSMul r (w s)) 0\n⊢ Eq r 0","decl":"variable (R) in\n/-- A weight function is nontorsion if its values are not torsion. -/\nclass NonTorsionWeight (w : σ → M) : Prop where\n  eq_zero_of_smul_eq_zero {r : R} {s : σ} (h : r • w s = 0) : r = 0\n\n"}
{"name":"Finsupp.nonTorsionWeight_of","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝³ : Semiring R\nw : σ → M\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : NoZeroSMulDivisors R M\nhw : ∀ (i : σ), Ne (w i) 0\n⊢ Finsupp.NonTorsionWeight R w","decl":"variable (R) in\n/-- Without zero divisors, nonzero weight is a `NonTorsionWeight` -/\ntheorem nonTorsionWeight_of [NoZeroSMulDivisors R M] (hw : ∀ i : σ, w i ≠ 0) :\n    NonTorsionWeight R w where\n  eq_zero_of_smul_eq_zero {n s} h := by\n    rw [smul_eq_zero, or_iff_not_imp_right] at h\n    exact h (hw s)\n\n"}
{"name":"Finsupp.NonTorsionWeight.ne_zero","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nR : Type u_3\ninst✝⁴ : Semiring R\nw : σ → M\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Nontrivial R\ninst✝ : Finsupp.NonTorsionWeight R w\ns : σ\n⊢ Ne (w s) 0","decl":"variable (R) in\ntheorem NonTorsionWeight.ne_zero [Nontrivial R] [NonTorsionWeight R w] (s : σ) :\n    w s ≠ 0 := fun h ↦ by\n  rw [← one_smul R (w s)] at h\n  apply zero_ne_one.symm (α := R)\n  exact NonTorsionWeight.eq_zero_of_smul_eq_zero h\n\n"}
{"name":"Finsupp.weight_sub_single_add","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\nw : σ → M\ninst✝ : AddCommMonoid M\nf : Finsupp σ Nat\ni : σ\nhi : Ne (f i) 0\n⊢ Eq (HAdd.hAdd ((Finsupp.weight w) (HSub.hSub f (Finsupp.single i 1))) (w i)) ((Finsupp.weight w) f)","decl":"variable {w} in\nlemma weight_sub_single_add {f : σ →₀ ℕ} {i : σ} (hi : f i ≠ 0) :\n    (f - single i 1).weight w + w i = f.weight w := by\n  conv_rhs => rw [← sub_add_single_one_cancel hi, weight_apply]\n  rw [sum_add_index', sum_single_index, one_smul, weight_apply]\n  exacts [zero_smul .., fun _ ↦ zero_smul .., fun _ _ _ ↦ add_smul ..]\n\n"}
{"name":"Finsupp.le_weight","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nw : σ → Nat\ns : σ\nhs : Ne (w s) 0\nf : Finsupp σ Nat\n⊢ LE.le (f s) ((Finsupp.weight w) f)","decl":"theorem le_weight (w : σ → ℕ) {s : σ} (hs : w s ≠ 0) (f : σ →₀ ℕ) :\n    f s ≤ weight w f := by\n  classical\n  simp only [weight_apply, Finsupp.sum]\n  by_cases h : s ∈ f.support\n  · rw [Finset.sum_eq_add_sum_diff_singleton h]\n    refine le_trans ?_ (Nat.le_add_right _ _)\n    apply Nat.le_mul_of_pos_right\n    exact Nat.zero_lt_of_ne_zero hs\n  · simp only [not_mem_support_iff] at h\n    rw [h]\n    apply zero_le\n\n"}
{"name":"Finsupp.instSMulPosMonoNat","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"M : Type u_2\ninst✝ : OrderedAddCommMonoid M\n⊢ SMulPosMono Nat M","decl":"instance : SMulPosMono ℕ M :=\n  ⟨fun b hb m m' h ↦ by\n    rw [← Nat.add_sub_of_le h, add_smul]\n    exact le_add_of_nonneg_right (nsmul_nonneg hb (m' - m))⟩\n\n"}
{"name":"Finsupp.le_weight_of_ne_zero","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_2\ninst✝ : OrderedAddCommMonoid M\nw : σ → M\nhw : ∀ (s : σ), LE.le 0 (w s)\ns : σ\nf : Finsupp σ Nat\nhs : Ne (f s) 0\n⊢ LE.le (w s) ((Finsupp.weight w) f)","decl":"variable {w} in\ntheorem le_weight_of_ne_zero (hw : ∀ s, 0 ≤ w s) {s : σ} {f : σ →₀ ℕ} (hs : f s ≠ 0) :\n    w s ≤ weight w f := by\n  classical\n  simp only [weight_apply, Finsupp.sum]\n  trans f s • w s\n  · apply le_smul_of_one_le_left (hw s)\n    exact Nat.one_le_iff_ne_zero.mpr hs\n  · rw [← Finsupp.mem_support_iff] at hs\n    rw [Finset.sum_eq_add_sum_diff_singleton hs]\n    exact le_add_of_nonneg_right <| Finset.sum_nonneg <|\n      fun i _ ↦ nsmul_nonneg (hw i) (f i)\n\n"}
{"name":"Finsupp.le_weight_of_ne_zero'","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_4\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nw : σ → M\ns : σ\nf : Finsupp σ Nat\nhs : Ne (f s) 0\n⊢ LE.le (w s) ((Finsupp.weight w) f)","decl":"theorem le_weight_of_ne_zero' {s : σ} {f : σ →₀ ℕ} (hs : f s ≠ 0) :\n    w s ≤ weight w f :=\n  le_weight_of_ne_zero (fun _ ↦ zero_le _) hs\n\n"}
{"name":"Finsupp.weight_eq_zero_iff_eq_zero","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nM : Type u_4\ninst✝² : OrderedAddCommMonoid M\ninst✝¹ : CanonicallyOrderedAdd M\nw : σ → M\ninst✝ : Finsupp.NonTorsionWeight Nat w\nf : Finsupp σ Nat\n⊢ Iff (Eq ((Finsupp.weight w) f) 0) (Eq f 0)","decl":"/-- If `M` is a `CanonicallyOrderedAddCommMonoid`, then `weight f` is zero iff `f=0. -/\ntheorem weight_eq_zero_iff_eq_zero\n    (w : σ → M) [NonTorsionWeight ℕ w] {f : σ →₀ ℕ} :\n    weight w f = 0 ↔ f = 0 := by\n  classical\n  constructor\n  · intro h\n    ext s\n    simp only [Finsupp.coe_zero, Pi.zero_apply]\n    by_contra hs\n    apply NonTorsionWeight.ne_zero ℕ w s\n    rw [← nonpos_iff_eq_zero, ← h]\n    exact le_weight_of_ne_zero' w hs\n  · intro h\n    rw [h, map_zero]\n\n"}
{"name":"Finsupp.finite_of_nat_weight_le","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\ninst✝ : Finite σ\nw : σ → Nat\nhw : ∀ (x : σ), Ne (w x) 0\nn : Nat\n⊢ (setOf fun d => LE.le ((Finsupp.weight w) d) n).Finite","decl":"theorem finite_of_nat_weight_le [Finite σ] (w : σ → ℕ) (hw : ∀ x, w x ≠ 0) (n : ℕ) :\n    {d : σ →₀ ℕ | weight w d ≤ n}.Finite := by\n  classical\n  set fg := Finset.antidiagonal (Finsupp.equivFunOnFinite.symm (Function.const σ n)) with hfg\n  suffices {d : σ →₀ ℕ | weight w d ≤ n} ⊆ ↑(fg.image fun uv => uv.fst) by\n    exact Set.Finite.subset (Finset.finite_toSet _) this\n  intro d hd\n  rw [hfg]\n  simp only [Finset.coe_image, Set.mem_image, Finset.mem_coe,\n    Finset.mem_antidiagonal, Prod.exists, exists_and_right, exists_eq_right]\n  use Finsupp.equivFunOnFinite.symm (Function.const σ n) - d\n  ext x\n  simp only [Finsupp.coe_add, Finsupp.coe_tsub, Pi.add_apply, Pi.sub_apply,\n    Finsupp.equivFunOnFinite_symm_apply_toFun, Function.const_apply]\n  rw [add_comm]\n  apply Nat.sub_add_cancel\n  apply le_trans (le_weight w (hw x) d)\n  simpa only [Set.mem_setOf_eq] using hd\n\n"}
{"name":"Finsupp.degree_add","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : AddCommMonoid R\na b : Finsupp σ R\n⊢ Eq (HAdd.hAdd a b).degree (HAdd.hAdd a.degree b.degree)","decl":"@[simp]\ntheorem degree_add (a b : σ →₀ R) : (a + b).degree = a.degree + b.degree :=\n  sum_add_index' (h := fun _ ↦ id) (congrFun rfl) fun _ _ ↦ congrFun rfl\n\n"}
{"name":"Finsupp.degree_single","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : AddCommMonoid R\na : σ\nr : R\n⊢ Eq (Finsupp.single a r).degree r","decl":"@[simp]\ntheorem degree_single (a : σ) (r : R) : (Finsupp.single a r).degree = r :=\n  Finsupp.sum_single_index (h := fun _ => id) rfl\n\n"}
{"name":"Finsupp.degree_zero","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : AddCommMonoid R\n⊢ Eq (Finsupp.degree 0) 0","decl":"@[simp]\ntheorem degree_zero : degree (0 : σ →₀ R) = 0 := by simp [degree]\n\n"}
{"name":"Finsupp.degree_eq_zero_iff","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_5\ninst✝¹ : OrderedAddCommMonoid R\ninst✝ : CanonicallyOrderedAdd R\nd : Finsupp σ R\n⊢ Iff (Eq d.degree 0) (Eq d 0)","decl":"lemma degree_eq_zero_iff {R : Type*} [OrderedAddCommMonoid R] [CanonicallyOrderedAdd R]\n    (d : σ →₀ R) :\n    degree d = 0 ↔ d = 0 := by\n  simp only [degree, Finset.sum_eq_zero_iff, mem_support_iff, ne_eq, _root_.not_imp_self,\n    DFunLike.ext_iff, coe_zero, Pi.zero_apply]\n\n"}
{"name":"Finsupp.le_degree","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_5\ninst✝¹ : OrderedAddCommMonoid R\ninst✝ : CanonicallyOrderedAdd R\ns : σ\nf : Finsupp σ R\n⊢ LE.le (f s) f.degree","decl":"theorem le_degree {R : Type*} [OrderedAddCommMonoid R] [CanonicallyOrderedAdd R]\n    (s : σ) (f : σ →₀ R) :\n    f s ≤ degree f := by\n  by_cases h : s ∈ f.support\n  · exact CanonicallyOrderedAddCommMonoid.single_le_sum h\n  · simp only [not_mem_support_iff] at h\n    simp only [h, zero_le]\n\n"}
{"name":"Finsupp.degree_eq_weight_one","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\nR : Type u_5\ninst✝ : Semiring R\n⊢ Eq Finsupp.degree ⇑(Finsupp.weight fun x => 1)","decl":"theorem degree_eq_weight_one {R : Type*} [Semiring R] :\n    degree (R := R) (σ := σ) = weight (fun _ ↦ 1) := by\n  ext d\n  simp only [degree, weight_apply, Pi.one_apply, smul_eq_mul, mul_one, Finsupp.sum]\n\n"}
{"name":"Finsupp.finite_of_degree_le","module":"Mathlib.Data.Finsupp.Weight","initialProofState":"σ : Type u_1\ninst✝ : Finite σ\nn : Nat\n⊢ (setOf fun f => LE.le f.degree n).Finite","decl":"theorem finite_of_degree_le [Finite σ] (n : ℕ) :\n    {f : σ →₀ ℕ | degree f ≤ n}.Finite := by\n  simp_rw [degree_eq_weight_one]\n  refine finite_of_nat_weight_le (Function.const σ 1) ?_ n\n  intro _\n  simp only [Function.const_apply, ne_eq, one_ne_zero, not_false_eq_true]\n\n"}
