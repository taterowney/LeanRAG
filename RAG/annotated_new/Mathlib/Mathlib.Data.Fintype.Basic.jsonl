{"name":"Fintype.complete","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\nself : Fintype α\nx : α\n⊢ Membership.mem Fintype.elems x","decl":"/-- `Fintype α` means that `α` is finite, i.e. there are only\n  finitely many distinct elements of type `α`. The evidence of this\n  is a finset `elems` (a list up to permutation without duplicates),\n  together with a proof that everything of type `α` is in the list. -/\nclass Fintype (α : Type*) where\n  /-- The `Finset` containing all elements of a `Fintype` -/\n  elems : Finset α\n  /-- A proof that `elems` contains every element of the type -/\n  complete : ∀ x : α, x ∈ elems\n\n"}
{"name":"Finset.mem_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nx : α\n⊢ Membership.mem Finset.univ x","decl":"@[simp]\ntheorem mem_univ (x : α) : x ∈ (univ : Finset α) :=\n  Fintype.complete x\n\n"}
{"name":"Finset.mem_univ_val","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nx : α\n⊢ Membership.mem Finset.univ.val x","decl":"theorem mem_univ_val : ∀ x, x ∈ (univ : Finset α).1 := by simp\n\n"}
{"name":"Finset.eq_univ_iff_forall","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (Eq s Finset.univ) (∀ (x : α), Membership.mem s x)","decl":"theorem eq_univ_iff_forall : s = univ ↔ ∀ x, x ∈ s := by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.eq_univ_of_forall","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\na✝ : ∀ (x : α), Membership.mem s x\n⊢ Eq s Finset.univ","decl":"theorem eq_univ_of_forall : (∀ x, x ∈ s) → s = univ :=\n  eq_univ_iff_forall.2\n\n"}
{"name":"Finset.coe_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq (↑Finset.univ) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_univ : ↑(univ : Finset α) = (Set.univ : Set α) := by ext; simp\n\n"}
{"name":"Finset.coe_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (Eq (↑s) Set.univ) (Eq s Finset.univ)","decl":"@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set α) = Set.univ ↔ s = univ := by rw [← coe_univ, coe_inj]\n\n"}
{"name":"Finset.Nonempty.eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : Subsingleton α\na✝ : s.Nonempty\n⊢ Eq s Finset.univ","decl":"theorem Nonempty.eq_univ [Subsingleton α] : s.Nonempty → s = univ := by\n  rintro ⟨x, hx⟩\n  exact eq_univ_of_forall fun y => by rwa [Subsingleton.elim y x]\n\n"}
{"name":"Finset.univ_nonempty_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff Finset.univ.Nonempty (Nonempty α)","decl":"theorem univ_nonempty_iff : (univ : Finset α).Nonempty ↔ Nonempty α := by\n  rw [← coe_nonempty, coe_univ, Set.nonempty_iff_univ_nonempty]\n\n"}
{"name":"Finset.univ_nonempty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\n⊢ Finset.univ.Nonempty","decl":"@[simp, aesop unsafe apply (rule_sets := [finsetNonempty])]\ntheorem univ_nonempty [Nonempty α] : (univ : Finset α).Nonempty :=\n  univ_nonempty_iff.2 ‹_›\n\n"}
{"name":"Finset.univ_eq_empty_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (Eq Finset.univ EmptyCollection.emptyCollection) (IsEmpty α)","decl":"theorem univ_eq_empty_iff : (univ : Finset α) = ∅ ↔ IsEmpty α := by\n  rw [← not_nonempty_iff, ← univ_nonempty_iff, not_nonempty_iff_eq_empty]\n\n"}
{"name":"Finset.univ_nontrivial_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff Finset.univ.Nontrivial (Nontrivial α)","decl":"theorem univ_nontrivial_iff :\n    (Finset.univ : Finset α).Nontrivial ↔ Nontrivial α := by\n  rw [Finset.Nontrivial, Finset.coe_univ, Set.nontrivial_univ_iff]\n\n"}
{"name":"Finset.univ_nontrivial","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nh : Nontrivial α\n⊢ Finset.univ.Nontrivial","decl":"theorem univ_nontrivial [h : Nontrivial α] :\n    (Finset.univ : Finset α).Nontrivial :=\n  univ_nontrivial_iff.mpr h\n\n"}
{"name":"Finset.univ_eq_empty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : IsEmpty α\n⊢ Eq Finset.univ EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem univ_eq_empty [IsEmpty α] : (univ : Finset α) = ∅ :=\n  univ_eq_empty_iff.2 ‹_›\n\n"}
{"name":"Finset.univ_unique","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Unique α\n⊢ Eq Finset.univ (Singleton.singleton Inhabited.default)","decl":"@[simp]\ntheorem univ_unique [Unique α] : (univ : Finset α) = {default} :=\n  Finset.ext fun x => iff_of_true (mem_univ _) <| mem_singleton.2 <| Subsingleton.elim x default\n\n"}
{"name":"Finset.subset_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ HasSubset.Subset s Finset.univ","decl":"@[simp]\ntheorem subset_univ (s : Finset α) : s ⊆ univ := fun a _ => mem_univ a\n\n"}
{"name":"Finset.top_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq Top.top Finset.univ","decl":"@[simp]\ntheorem top_eq_univ : (⊤ : Finset α) = univ :=\n  rfl\n\n"}
{"name":"Finset.ssubset_univ_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (HasSSubset.SSubset s Finset.univ) (Ne s Finset.univ)","decl":"theorem ssubset_univ_iff {s : Finset α} : s ⊂ univ ↔ s ≠ univ :=\n  @lt_top_iff_ne_top _ _ _ s\n\n"}
{"name":"Finset.univ_subset_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (HasSubset.Subset Finset.univ s) (Eq s Finset.univ)","decl":"@[simp]\ntheorem univ_subset_iff {s : Finset α} : univ ⊆ s ↔ s = univ :=\n  @top_le_iff _ _ _ s\n\n"}
{"name":"Finset.codisjoint_left","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns t : Finset α\n⊢ Iff (Codisjoint s t) (∀ ⦃a : α⦄, Not (Membership.mem s a) → Membership.mem t a)","decl":"theorem codisjoint_left : Codisjoint s t ↔ ∀ ⦃a⦄, a ∉ s → a ∈ t := by\n  classical simp [codisjoint_iff, eq_univ_iff_forall, or_iff_not_imp_left]\n\n"}
{"name":"Finset.codisjoint_right","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns t : Finset α\n⊢ Iff (Codisjoint s t) (∀ ⦃a : α⦄, Not (Membership.mem t a) → Membership.mem s a)","decl":"theorem codisjoint_right : Codisjoint s t ↔ ∀ ⦃a⦄, a ∉ t → a ∈ s :=\n  codisjoint_comm.trans codisjoint_left\n\n"}
{"name":"Finset.sdiff_eq_inter_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (SDiff.sdiff s t) (Inter.inter s (HasCompl.compl t))","decl":"theorem sdiff_eq_inter_compl (s t : Finset α) : s \\ t = s ∩ tᶜ :=\n  sdiff_eq\n\n"}
{"name":"Finset.compl_eq_univ_sdiff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (HasCompl.compl s) (SDiff.sdiff Finset.univ s)","decl":"theorem compl_eq_univ_sdiff (s : Finset α) : sᶜ = univ \\ s :=\n  rfl\n\n"}
{"name":"Finset.mem_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\n⊢ Iff (Membership.mem (HasCompl.compl s) a) (Not (Membership.mem s a))","decl":"@[simp]\ntheorem mem_compl : a ∈ sᶜ ↔ a ∉ s := by simp [compl_eq_univ_sdiff]\n\n"}
{"name":"Finset.not_mem_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\n⊢ Iff (Not (Membership.mem (HasCompl.compl s) a)) (Membership.mem s a)","decl":"theorem not_mem_compl : a ∉ sᶜ ↔ a ∈ s := by rw [mem_compl, not_not]\n\n"}
{"name":"Finset.coe_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (↑(HasCompl.compl s)) (HasCompl.compl ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_compl (s : Finset α) : ↑sᶜ = (↑s : Set α)ᶜ :=\n  Set.ext fun _ => mem_compl\n\n"}
{"name":"Finset.compl_subset_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (HasSubset.Subset (HasCompl.compl s) (HasCompl.compl t)) (HasSubset.Subset t s)","decl":"@[simp] lemma compl_subset_compl : sᶜ ⊆ tᶜ ↔ t ⊆ s := @compl_le_compl_iff_le (Finset α) _ _ _\n"}
{"name":"Finset.compl_ssubset_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (HasSSubset.SSubset (HasCompl.compl s) (HasCompl.compl t)) (HasSSubset.SSubset t s)","decl":"@[simp] lemma compl_ssubset_compl : sᶜ ⊂ tᶜ ↔ t ⊂ s := @compl_lt_compl_iff_lt (Finset α) _ _ _\n\n"}
{"name":"Finset.subset_compl_comm","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl t)) (HasSubset.Subset t (HasCompl.compl s))","decl":"lemma subset_compl_comm : s ⊆ tᶜ ↔ t ⊆ sᶜ := le_compl_iff_le_compl (α := Finset α)\n\n"}
{"name":"Finset.subset_compl_singleton","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\n⊢ Iff (HasSubset.Subset s (HasCompl.compl (Singleton.singleton a))) (Not (Membership.mem s a))","decl":"@[simp] lemma subset_compl_singleton : s ⊆ {a}ᶜ ↔ a ∉ s := by\n  rw [subset_compl_comm, singleton_subset_iff, mem_compl]\n\n"}
{"name":"Finset.compl_empty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (HasCompl.compl EmptyCollection.emptyCollection) Finset.univ","decl":"@[simp]\ntheorem compl_empty : (∅ : Finset α)ᶜ = univ :=\n  compl_bot\n\n"}
{"name":"Finset.compl_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (HasCompl.compl Finset.univ) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem compl_univ : (univ : Finset α)ᶜ = ∅ :=\n  compl_top\n\n"}
{"name":"Finset.compl_eq_empty_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Iff (Eq (HasCompl.compl s) EmptyCollection.emptyCollection) (Eq s Finset.univ)","decl":"@[simp]\ntheorem compl_eq_empty_iff (s : Finset α) : sᶜ = ∅ ↔ s = univ :=\n  compl_eq_bot\n\n"}
{"name":"Finset.compl_eq_univ_iff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Iff (Eq (HasCompl.compl s) Finset.univ) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem compl_eq_univ_iff (s : Finset α) : sᶜ = univ ↔ s = ∅ :=\n  compl_eq_top\n\n"}
{"name":"Finset.union_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Union.union s (HasCompl.compl s)) Finset.univ","decl":"@[simp]\ntheorem union_compl (s : Finset α) : s ∪ sᶜ = univ :=\n  sup_compl_eq_top\n\n"}
{"name":"Finset.inter_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Inter.inter s (HasCompl.compl s)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_compl (s : Finset α) : s ∩ sᶜ = ∅ :=\n  inf_compl_eq_bot\n\n"}
{"name":"Finset.compl_union","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HasCompl.compl (Union.union s t)) (Inter.inter (HasCompl.compl s) (HasCompl.compl t))","decl":"@[simp]\ntheorem compl_union (s t : Finset α) : (s ∪ t)ᶜ = sᶜ ∩ tᶜ :=\n  compl_sup\n\n"}
{"name":"Finset.compl_inter","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Eq (HasCompl.compl (Inter.inter s t)) (Union.union (HasCompl.compl s) (HasCompl.compl t))","decl":"@[simp]\ntheorem compl_inter (s t : Finset α) : (s ∩ t)ᶜ = sᶜ ∪ tᶜ :=\n  compl_inf\n\n"}
{"name":"Finset.compl_erase","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (HasCompl.compl (s.erase a)) (Insert.insert a (HasCompl.compl s))","decl":"@[simp]\ntheorem compl_erase : (s.erase a)ᶜ = insert a sᶜ := by\n  ext\n  simp only [or_iff_not_imp_left, mem_insert, not_and, mem_compl, mem_erase]\n\n"}
{"name":"Finset.compl_insert","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (HasCompl.compl (Insert.insert a s)) ((HasCompl.compl s).erase a)","decl":"@[simp]\ntheorem compl_insert : (insert a s)ᶜ = sᶜ.erase a := by\n  ext\n  simp only [not_or, mem_insert, mem_compl, mem_erase]\n\n"}
{"name":"Finset.insert_compl_insert","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Finset α\ninst✝ : DecidableEq α\na : α\nha : Not (Membership.mem s a)\n⊢ Eq (Insert.insert a (HasCompl.compl (Insert.insert a s))) (HasCompl.compl s)","decl":"theorem insert_compl_insert (ha : a ∉ s) : insert a (insert a s)ᶜ = sᶜ := by\n  simp_rw [compl_insert, insert_erase (mem_compl.2 ha)]\n\n"}
{"name":"Finset.insert_compl_self","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nx : α\n⊢ Eq (Insert.insert x (HasCompl.compl (Singleton.singleton x))) Finset.univ","decl":"@[simp]\ntheorem insert_compl_self (x : α) : insert x ({x}ᶜ : Finset α) = univ := by\n  rw [← compl_erase, erase_singleton, compl_empty]\n\n"}
{"name":"Finset.compl_filter","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝³ : Fintype α\ninst✝² : DecidableEq α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : (x : α) → Decidable (Not (p x))\n⊢ Eq (HasCompl.compl (Finset.filter p Finset.univ)) (Finset.filter (fun x => Not (p x)) Finset.univ)","decl":"@[simp]\ntheorem compl_filter (p : α → Prop) [DecidablePred p] [∀ x, Decidable ¬p x] :\n    (univ.filter p)ᶜ = univ.filter fun x => ¬p x :=\n  ext <| by simp\n\n"}
{"name":"Finset.compl_ne_univ_iff_nonempty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Iff (Ne (HasCompl.compl s) Finset.univ) s.Nonempty","decl":"theorem compl_ne_univ_iff_nonempty (s : Finset α) : sᶜ ≠ univ ↔ s.Nonempty := by\n  simp [eq_univ_iff_forall, Finset.Nonempty]\n\n"}
{"name":"Finset.compl_singleton","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (HasCompl.compl (Singleton.singleton a)) (Finset.univ.erase a)","decl":"theorem compl_singleton (a : α) : ({a} : Finset α)ᶜ = univ.erase a := by\n  rw [compl_eq_univ_sdiff, sdiff_singleton_eq_erase]\n\n"}
{"name":"Finset.insert_inj_on'","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Set.InjOn (fun a => Insert.insert a s) ↑(HasCompl.compl s)","decl":"theorem insert_inj_on' (s : Finset α) : Set.InjOn (fun a => insert a s) (sᶜ : Finset α) := by\n  rw [coe_compl]\n  exact s.insert_inj_on\n\n"}
{"name":"Finset.image_univ_of_surjective","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype β\nf : β → α\nhf : Function.Surjective f\n⊢ Eq (Finset.image f Finset.univ) Finset.univ","decl":"theorem image_univ_of_surjective [Fintype β] {f : β → α} (hf : Surjective f) :\n    univ.image f = univ :=\n  eq_univ_of_forall <| hf.forall.2 fun _ => mem_image_of_mem _ <| mem_univ _\n\n"}
{"name":"Finset.image_univ_equiv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Fintype β\nf : Equiv β α\n⊢ Eq (Finset.image (⇑f) Finset.univ) Finset.univ","decl":"@[simp]\ntheorem image_univ_equiv [Fintype β] (f : β ≃ α) : univ.image f = univ :=\n  Finset.image_univ_of_surjective f.surjective\n\n"}
{"name":"Finset.univ_inter","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Inter.inter Finset.univ s) s","decl":"@[simp] lemma univ_inter (s : Finset α) : univ ∩ s = s := by ext a; simp\n\n"}
{"name":"Finset.inter_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Inter.inter s Finset.univ) s","decl":"@[simp] lemma inter_univ (s : Finset α) : s ∩ univ = s := by rw [inter_comm, univ_inter]\n\n"}
{"name":"Finset.inter_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (Eq (Inter.inter s t) Finset.univ) (And (Eq s Finset.univ) (Eq t Finset.univ))","decl":"@[simp] lemma inter_eq_univ : s ∩ t = univ ↔ s = univ ∧ t = univ := inf_eq_top_iff\n\n"}
{"name":"Finset.singleton_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Subsingleton α\na : α\n⊢ Eq (Singleton.singleton a) Finset.univ","decl":"lemma singleton_eq_univ [Subsingleton α] (a : α) : ({a} : Finset α) = univ := by\n  ext b; simp [Subsingleton.elim a b]\n\n\n"}
{"name":"Finset.map_univ_of_surjective","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : Function.Embedding β α\nhf : Function.Surjective ⇑f\n⊢ Eq (Finset.map f Finset.univ) Finset.univ","decl":"theorem map_univ_of_surjective [Fintype β] {f : β ↪ α} (hf : Surjective f) : univ.map f = univ :=\n  eq_univ_of_forall <| hf.forall.2 fun _ => mem_map_of_mem _ <| mem_univ _\n\n"}
{"name":"Finset.map_univ_equiv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : Equiv β α\n⊢ Eq (Finset.map f.toEmbedding Finset.univ) Finset.univ","decl":"@[simp]\ntheorem map_univ_equiv [Fintype β] (f : β ≃ α) : univ.map f.toEmbedding = univ :=\n  map_univ_of_surjective f.surjective\n\n"}
{"name":"Finset.univ_map_equiv_to_embedding","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Fintype α\ninst✝ : Fintype β\ne : Equiv α β\n⊢ Eq (Finset.map e.toEmbedding Finset.univ) Finset.univ","decl":"theorem univ_map_equiv_to_embedding {α β : Type*} [Fintype α] [Fintype β] (e : α ≃ β) :\n    univ.map e.toEmbedding = univ :=\n  eq_univ_iff_forall.mpr fun b => mem_map.mpr ⟨e.symm b, mem_univ _, by simp⟩\n\n"}
{"name":"Finset.univ_filter_exists","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Fintype α\nf : α → β\ninst✝² : Fintype β\ninst✝¹ : DecidablePred fun y => Exists fun x => Eq (f x) y\ninst✝ : DecidableEq β\n⊢ Eq (Finset.filter (fun y => Exists fun x => Eq (f x) y) Finset.univ) (Finset.image f Finset.univ)","decl":"@[simp]\ntheorem univ_filter_exists (f : α → β) [Fintype β] [DecidablePred fun y => ∃ x, f x = y]\n    [DecidableEq β] : (Finset.univ.filter fun y => ∃ x, f x = y) = Finset.univ.image f := by\n  ext\n  simp\n\n"}
{"name":"Finset.univ_filter_mem_range","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Fintype α\nf : α → β\ninst✝² : Fintype β\ninst✝¹ : DecidablePred fun y => Membership.mem (Set.range f) y\ninst✝ : DecidableEq β\n⊢ Eq (Finset.filter (fun y => Membership.mem (Set.range f) y) Finset.univ) (Finset.image f Finset.univ)","decl":"/-- Note this is a special case of `(Finset.image_preimage f univ _).symm`. -/\ntheorem univ_filter_mem_range (f : α → β) [Fintype β] [DecidablePred fun y => y ∈ Set.range f]\n    [DecidableEq β] : (Finset.univ.filter fun y => y ∈ Set.range f) = Finset.univ.image f := by\n  letI : DecidablePred (fun y => ∃ x, f x = y) := by simpa using ‹_›\n  exact univ_filter_exists f\n\n"}
{"name":"Finset.coe_filter_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (↑(Finset.filter p Finset.univ)) (setOf fun x => p x)","decl":"theorem coe_filter_univ (p : α → Prop) [DecidablePred p] :\n    (univ.filter p : Set α) = { x | p x } := by simp\n\n"}
{"name":"Finset.subtype_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype (Subtype fun a => p a)\n⊢ Iff (Eq (Finset.subtype p s) Finset.univ) (∀ ⦃a : α⦄, p a → Membership.mem s a)","decl":"@[simp] lemma subtype_eq_univ {p : α → Prop} [DecidablePred p] [Fintype {a // p a}] :\n    s.subtype p = univ ↔ ∀ ⦃a⦄, p a → a ∈ s := by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.subtype_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype (Subtype fun a => p a)\n⊢ Eq (Finset.subtype p Finset.univ) Finset.univ","decl":"@[simp] lemma subtype_univ [Fintype α] (p : α → Prop) [DecidablePred p] [Fintype {a // p a}] :\n    univ.subtype p = univ := by simp\n\n"}
{"name":"Finset.univ_map_subtype","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype (Subtype fun a => p a)\n⊢ Eq (Finset.map (Function.Embedding.subtype p) Finset.univ) (Finset.filter p Finset.univ)","decl":"lemma univ_map_subtype [Fintype α] (p : α → Prop) [DecidablePred p] [Fintype {a // p a}] :\n    univ.map (Function.Embedding.subtype p) = univ.filter p := by\n  rw [← subtype_map, subtype_univ]\n\n"}
{"name":"Finset.univ_val_map_subtype_val","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype (Subtype fun a => p a)\n⊢ Eq (Multiset.map Subtype.val Finset.univ.val) (Finset.filter p Finset.univ).val","decl":"lemma univ_val_map_subtype_val [Fintype α] (p : α → Prop) [DecidablePred p] [Fintype {a // p a}] :\n    univ.val.map ((↑) : { a // p a } → α) = (univ.filter p).val := by\n  apply (map_val (Function.Embedding.subtype p) univ).symm.trans\n  apply congr_arg\n  apply univ_map_subtype\n\n"}
{"name":"Finset.univ_val_map_subtype_restrict","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\nf : α → β\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype (Subtype fun a => p a)\n⊢ Eq (Multiset.map (Subtype.restrict p f) Finset.univ.val) (Multiset.map f (Finset.filter p Finset.univ).val)","decl":"lemma univ_val_map_subtype_restrict [Fintype α] (f : α → β)\n    (p : α → Prop) [DecidablePred p] [Fintype {a // p a}] :\n    univ.val.map (Subtype.restrict p f) = (univ.filter p).val.map f := by\n  rw [← univ_val_map_subtype_val, Multiset.map_map, Subtype.restrict_def]\n\n"}
{"name":"Fintype.subsingleton","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\n⊢ Subsingleton (Fintype α)","decl":"instance subsingleton (α : Type*) : Subsingleton (Fintype α) :=\n  ⟨fun ⟨s₁, h₁⟩ ⟨s₂, h₂⟩ => by congr; simp [Finset.ext_iff, h₁, h₂]⟩\n\n"}
{"name":"Finset.filter_univ_mem","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.filter (fun x => Membership.mem s x) Finset.univ) s","decl":"@[simp]\nlemma filter_univ_mem (s : Finset α) : univ.filter (· ∈ s) = s := by simp [filter_mem_eq_inter]\n\n"}
{"name":"Function.Injective.left_inv_of_invOfMemRange","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nb : ↑(Set.range f)\n⊢ Eq (f (hf.invOfMemRange b)) ↑b","decl":"theorem left_inv_of_invOfMemRange (b : Set.range f) : f (hf.invOfMemRange b) = b :=\n  (Finset.choose_spec (fun a => f a = b) _ _).right\n\n"}
{"name":"Function.Injective.right_inv_of_invOfMemRange","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\na : α\n⊢ Eq (hf.invOfMemRange ⟨f a, ⋯⟩) a","decl":"@[simp]\ntheorem right_inv_of_invOfMemRange (a : α) : hf.invOfMemRange ⟨f a, Set.mem_range_self a⟩ = a :=\n  hf (Finset.choose_spec (fun a' => f a' = f a) _ _).right\n\n"}
{"name":"Function.Injective.invFun_restrict","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\nf : α → β\nhf : Function.Injective f\ninst✝ : Nonempty α\n⊢ Eq ((Set.range f).restrict (Function.invFun f)) hf.invOfMemRange","decl":"theorem invFun_restrict [Nonempty α] : (Set.range f).restrict (invFun f) = hf.invOfMemRange := by\n  ext ⟨b, h⟩\n  apply hf\n  simp [hf.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]\n\n"}
{"name":"Function.Injective.invOfMemRange_surjective","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\n⊢ Function.Surjective hf.invOfMemRange","decl":"theorem invOfMemRange_surjective : Function.Surjective hf.invOfMemRange := fun a =>\n  ⟨⟨f a, Set.mem_range_self a⟩, by simp⟩\n\n"}
{"name":"Function.Embedding.left_inv_of_invOfMemRange","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\nb : ↑(Set.range ⇑f)\n⊢ Eq (f (f.invOfMemRange b)) ↑b","decl":"@[simp]\ntheorem left_inv_of_invOfMemRange : f (f.invOfMemRange b) = b :=\n  f.injective.left_inv_of_invOfMemRange b\n\n"}
{"name":"Function.Embedding.right_inv_of_invOfMemRange","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\na : α\n⊢ Eq (f.invOfMemRange ⟨f a, ⋯⟩) a","decl":"@[simp]\ntheorem right_inv_of_invOfMemRange (a : α) : f.invOfMemRange ⟨f a, Set.mem_range_self a⟩ = a :=\n  f.injective.right_inv_of_invOfMemRange a\n\n"}
{"name":"Function.Embedding.invFun_restrict","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq β\nf : Function.Embedding α β\ninst✝ : Nonempty α\n⊢ Eq ((Set.range ⇑f).restrict (Function.invFun ⇑f)) f.invOfMemRange","decl":"theorem invFun_restrict [Nonempty α] : (Set.range f).restrict (invFun f) = f.invOfMemRange := by\n  ext ⟨b, h⟩\n  apply f.injective\n  simp [f.left_inv_of_invOfMemRange, @invFun_eq _ _ _ f b (Set.mem_range.mp h)]\n\n"}
{"name":"Function.Embedding.invOfMemRange_surjective","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\n⊢ Function.Surjective f.invOfMemRange","decl":"theorem invOfMemRange_surjective : Function.Surjective f.invOfMemRange := fun a =>\n  ⟨⟨f a, Set.mem_range_self a⟩, by simp⟩\n\n"}
{"name":"Fintype.univ_ofSubsingleton","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\na : α\ninst✝ : Subsingleton α\n⊢ Eq Finset.univ (Singleton.singleton a)","decl":"theorem univ_ofSubsingleton (a : α) [Subsingleton α] : @univ _ (ofSubsingleton a) = {a} :=\n  rfl\n\n"}
{"name":"Fintype.univ_ofIsEmpty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ Eq Finset.univ EmptyCollection.emptyCollection","decl":"/-- Note: this lemma is specifically about `Fintype.ofIsEmpty`. For a statement about\narbitrary `Fintype` instances, use `Finset.univ_eq_empty`. -/\ntheorem univ_ofIsEmpty [IsEmpty α] : @univ α Fintype.ofIsEmpty = ∅ :=\n  rfl\n\n"}
{"name":"Set.toFinset_congr","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\nh : Eq s t\n⊢ Eq s.toFinset t.toFinset","decl":"@[congr]\ntheorem toFinset_congr {s t : Set α} [Fintype s] [Fintype t] (h : s = t) :\n    toFinset s = toFinset t := by subst h; congr!\n\n"}
{"name":"Set.mem_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\na : α\n⊢ Iff (Membership.mem s.toFinset a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_toFinset {s : Set α} [Fintype s] {a : α} : a ∈ s.toFinset ↔ a ∈ s := by\n  simp [toFinset]\n\n"}
{"name":"Set.toFinset_ofFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\np : Set α\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem p x)\n⊢ Eq p.toFinset s","decl":"/-- Many `Fintype` instances for sets are defined using an extensionally equal `Finset`.\nRewriting `s.toFinset` with `Set.toFinset_ofFinset` replaces the term with such a `Finset`. -/\ntheorem toFinset_ofFinset {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) :\n    @Set.toFinset _ p (Fintype.ofFinset s H) = s :=\n  Finset.ext fun x => by rw [@mem_toFinset _ _ (id _), H]\n\n"}
{"name":"Set.coe_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (↑s.toFinset) s","decl":"@[simp]\ntheorem coe_toFinset (s : Set α) [Fintype s] : (↑s.toFinset : Set α) = s :=\n  Set.ext fun _ => mem_toFinset\n\n"}
{"name":"Set.toFinset_nonempty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Iff s.toFinset.Nonempty s.Nonempty","decl":"@[simp]\ntheorem toFinset_nonempty {s : Set α} [Fintype s] : s.toFinset.Nonempty ↔ s.Nonempty := by\n  rw [← Finset.coe_nonempty, coe_toFinset]\n\n"}
{"name":"Set.Aesop.toFinset_nonempty_of_nonempty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\na✝ : s.Nonempty\n⊢ s.toFinset.Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nalias ⟨_, Aesop.toFinset_nonempty_of_nonempty⟩ := toFinset_nonempty\n\n"}
{"name":"Set.toFinset_inj","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\n⊢ Iff (Eq s.toFinset t.toFinset) (Eq s t)","decl":"@[simp]\ntheorem toFinset_inj {s t : Set α} [Fintype s] [Fintype t] : s.toFinset = t.toFinset ↔ s = t :=\n  ⟨fun h => by rw [← s.coe_toFinset, h, t.coe_toFinset], fun h => by simp [h]⟩\n\n"}
{"name":"Set.toFinset_subset_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\n⊢ Iff (HasSubset.Subset s.toFinset t.toFinset) (HasSubset.Subset s t)","decl":"@[mono]\ntheorem toFinset_subset_toFinset [Fintype s] [Fintype t] : s.toFinset ⊆ t.toFinset ↔ s ⊆ t := by\n  simp [Finset.subset_iff, Set.subset_def]\n\n"}
{"name":"Set.toFinset_ssubset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\nt : Finset α\n⊢ Iff (HasSSubset.SSubset s.toFinset t) (HasSSubset.SSubset s ↑t)","decl":"@[simp]\ntheorem toFinset_ssubset [Fintype s] {t : Finset α} : s.toFinset ⊂ t ↔ s ⊂ t := by\n  rw [← Finset.coe_ssubset, coe_toFinset]\n\n"}
{"name":"Set.subset_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nt : Set α\ns : Finset α\ninst✝ : Fintype ↑t\n⊢ Iff (HasSubset.Subset s t.toFinset) (HasSubset.Subset (↑s) t)","decl":"@[simp]\ntheorem subset_toFinset {s : Finset α} [Fintype t] : s ⊆ t.toFinset ↔ ↑s ⊆ t := by\n  rw [← Finset.coe_subset, coe_toFinset]\n\n"}
{"name":"Set.ssubset_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nt : Set α\ns : Finset α\ninst✝ : Fintype ↑t\n⊢ Iff (HasSSubset.SSubset s t.toFinset) (HasSSubset.SSubset (↑s) t)","decl":"@[simp]\ntheorem ssubset_toFinset {s : Finset α} [Fintype t] : s ⊂ t.toFinset ↔ ↑s ⊂ t := by\n  rw [← Finset.coe_ssubset, coe_toFinset]\n\n"}
{"name":"Set.toFinset_ssubset_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\n⊢ Iff (HasSSubset.SSubset s.toFinset t.toFinset) (HasSSubset.SSubset s t)","decl":"@[mono]\ntheorem toFinset_ssubset_toFinset [Fintype s] [Fintype t] : s.toFinset ⊂ t.toFinset ↔ s ⊂ t := by\n  simp only [Finset.ssubset_def, toFinset_subset_toFinset, ssubset_def]\n\n"}
{"name":"Set.toFinset_subset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\nt : Finset α\n⊢ Iff (HasSubset.Subset s.toFinset t) (HasSubset.Subset s ↑t)","decl":"@[simp]\ntheorem toFinset_subset [Fintype s] {t : Finset α} : s.toFinset ⊆ t ↔ s ⊆ t := by\n  rw [← Finset.coe_subset, coe_toFinset]\n\n"}
{"name":"Set.toFinset_mono","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset s.toFinset t.toFinset","decl":"alias ⟨_, toFinset_mono⟩ := toFinset_subset_toFinset\n\n"}
{"name":"Set.toFinset_strict_mono","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\na✝ : HasSSubset.SSubset s t\n⊢ HasSSubset.SSubset s.toFinset t.toFinset","decl":"alias ⟨_, toFinset_strict_mono⟩ := toFinset_ssubset_toFinset\n\n"}
{"name":"Set.disjoint_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑t\n⊢ Iff (Disjoint s.toFinset t.toFinset) (Disjoint s t)","decl":"@[simp]\ntheorem disjoint_toFinset [Fintype s] [Fintype t] :\n    Disjoint s.toFinset t.toFinset ↔ Disjoint s t := by simp only [← disjoint_coe, coe_toFinset]\n\n"}
{"name":"Set.toFinset_inter","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝³ : DecidableEq α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(Inter.inter s t)\n⊢ Eq (Inter.inter s t).toFinset (Inter.inter s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_inter [Fintype (s ∩ t : Set _)] : (s ∩ t).toFinset = s.toFinset ∩ t.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_union","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝³ : DecidableEq α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(Union.union s t)\n⊢ Eq (Union.union s t).toFinset (Union.union s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_union [Fintype (s ∪ t : Set _)] : (s ∪ t).toFinset = s.toFinset ∪ t.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_diff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝³ : DecidableEq α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(SDiff.sdiff s t)\n⊢ Eq (SDiff.sdiff s t).toFinset (SDiff.sdiff s.toFinset t.toFinset)","decl":"@[simp]\ntheorem toFinset_diff [Fintype (s \\ t : Set _)] : (s \\ t).toFinset = s.toFinset \\ t.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_symmDiff","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns t : Set α\ninst✝³ : DecidableEq α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(symmDiff s t)\n⊢ Eq (symmDiff s t).toFinset (symmDiff s.toFinset t.toFinset)","decl":"open scoped symmDiff in\n@[simp]\ntheorem toFinset_symmDiff [Fintype (s ∆ t : Set _)] :\n    (s ∆ t).toFinset = s.toFinset ∆ t.toFinset := by\n  ext\n  simp [mem_symmDiff, Finset.mem_symmDiff]\n\n"}
{"name":"Set.toFinset_compl","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝³ : DecidableEq α\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype α\ninst✝ : Fintype ↑(HasCompl.compl s)\n⊢ Eq (HasCompl.compl s).toFinset (HasCompl.compl s.toFinset)","decl":"@[simp]\ntheorem toFinset_compl [Fintype α] [Fintype (sᶜ : Set _)] : sᶜ.toFinset = s.toFinsetᶜ := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_empty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype ↑EmptyCollection.emptyCollection\n⊢ Eq EmptyCollection.emptyCollection.toFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem toFinset_empty [Fintype (∅ : Set α)] : (∅ : Set α).toFinset = ∅ := by\n  ext\n  simp\n\n/- TODO Without the coercion arrow (`↥`) there is an elaboration bug in the following two;\nit essentially infers `Fintype.{v} (Set.univ.{u} : Set α)` with `v` and `u` distinct.\nReported in https://github.com/leanprover-community/lean/issues/672 -/\n"}
{"name":"Set.toFinset_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Fintype ↑Set.univ\n⊢ Eq Set.univ.toFinset Finset.univ","decl":"@[simp]\ntheorem toFinset_univ [Fintype α] [Fintype (Set.univ : Set α)] :\n    (Set.univ : Set α).toFinset = Finset.univ := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_eq_empty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Iff (Eq s.toFinset EmptyCollection.emptyCollection) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem toFinset_eq_empty [Fintype s] : s.toFinset = ∅ ↔ s = ∅ := by\n  let A : Fintype (∅ : Set α) := Fintype.ofIsEmpty\n  rw [← toFinset_empty, toFinset_inj]\n\n"}
{"name":"Set.toFinset_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : Fintype α\ninst✝ : Fintype ↑s\n⊢ Iff (Eq s.toFinset Finset.univ) (Eq s Set.univ)","decl":"@[simp]\ntheorem toFinset_eq_univ [Fintype α] [Fintype s] : s.toFinset = Finset.univ ↔ s = univ := by\n  rw [← coe_inj, coe_toFinset, coe_univ]\n\n"}
{"name":"Set.toFinset_setOf","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : Fintype ↑(setOf fun x => p x)\n⊢ Eq (setOf fun x => p x).toFinset (Finset.filter p Finset.univ)","decl":"@[simp]\ntheorem toFinset_setOf [Fintype α] (p : α → Prop) [DecidablePred p] [Fintype { x | p x }] :\n    Set.toFinset {x | p x} = Finset.univ.filter p := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_ssubset_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Iff (HasSSubset.SSubset s.toFinset Finset.univ) (HasSSubset.SSubset s Set.univ)","decl":"theorem toFinset_ssubset_univ [Fintype α] {s : Set α} [Fintype s] :\n    s.toFinset ⊂ Finset.univ ↔ s ⊂ univ := by simp\n\n"}
{"name":"Set.toFinset_image","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : DecidableEq β\nf : α → β\ns : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑(Set.image f s)\n⊢ Eq (Set.image f s).toFinset (Finset.image f s.toFinset)","decl":"@[simp]\ntheorem toFinset_image [DecidableEq β] (f : α → β) (s : Set α) [Fintype s] [Fintype (f '' s)] :\n    (f '' s).toFinset = s.toFinset.image f :=\n  Finset.coe_injective <| by simp\n\n"}
{"name":"Set.toFinset_range","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Fintype β\nf : β → α\ninst✝ : Fintype ↑(Set.range f)\n⊢ Eq (Set.range f).toFinset (Finset.image f Finset.univ)","decl":"@[simp]\ntheorem toFinset_range [DecidableEq α] [Fintype β] (f : β → α) [Fintype (Set.range f)] :\n    (Set.range f).toFinset = Finset.univ.image f := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_singleton","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\na : α\ninst✝ : Fintype ↑(Singleton.singleton a)\n⊢ Eq (Singleton.singleton a).toFinset (Singleton.singleton a)","decl":"@[simp] -- Porting note: new attribute\ntheorem toFinset_singleton (a : α) [Fintype ({a} : Set α)] : ({a} : Set α).toFinset = {a} := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_insert","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\na : α\ns : Set α\ninst✝¹ : Fintype ↑(Insert.insert a s)\ninst✝ : Fintype ↑s\n⊢ Eq (Insert.insert a s).toFinset (Insert.insert a s.toFinset)","decl":"@[simp]\ntheorem toFinset_insert [DecidableEq α] {a : α} {s : Set α} [Fintype (insert a s : Set α)]\n    [Fintype s] : (insert a s).toFinset = insert a s.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.filter_mem_univ_eq_toFinset","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ns : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Finset.filter (fun x => Membership.mem s x) Finset.univ) s.toFinset","decl":"theorem filter_mem_univ_eq_toFinset [Fintype α] (s : Set α) [Fintype s] [DecidablePred (· ∈ s)] :\n    Finset.univ.filter (· ∈ s) = s.toFinset := by\n  ext\n  simp only [Finset.mem_univ, decide_eq_true_eq, forall_true_left, mem_filter,\n    true_and, mem_toFinset]\n\n"}
{"name":"Finset.toFinset_coe","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : Fintype ↑↑s\n⊢ Eq (↑s).toFinset s","decl":"@[simp]\ntheorem Finset.toFinset_coe (s : Finset α) [Fintype (s : Set α)] : (s : Set α).toFinset = s :=\n  ext fun _ => Set.mem_toFinset\n\n"}
{"name":"Fin.univ_def","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq Finset.univ { val := ↑(List.finRange n), nodup := ⋯ }","decl":"theorem Fin.univ_def (n : ℕ) : (univ : Finset (Fin n)) = ⟨List.finRange n, List.nodup_finRange n⟩ :=\n  rfl\n\n"}
{"name":"nonempty_fintype","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\ninst✝ : Finite α\n⊢ Nonempty (Fintype α)","decl":"/-- See also `nonempty_encodable`, `nonempty_denumerable`. -/\ntheorem nonempty_fintype (α : Type*) [Finite α] : Nonempty (Fintype α) := by\n  rcases Finite.exists_equiv_fin α with ⟨n, ⟨e⟩⟩\n  exact ⟨.ofEquiv _ e.symm⟩\n\n"}
{"name":"List.toFinset_finRange","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq (List.finRange n).toFinset Finset.univ","decl":"@[simp] theorem List.toFinset_finRange (n : ℕ) : (List.finRange n).toFinset = Finset.univ := by\n  ext; simp\n\n"}
{"name":"Fin.univ_val_map","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n → α\n⊢ Eq (Multiset.map f Finset.univ.val) ↑(List.ofFn f)","decl":"@[simp] theorem Fin.univ_val_map {n : ℕ} (f : Fin n → α) :\n    Finset.univ.val.map f = List.ofFn f := by\n  simp [List.ofFn_eq_map, univ_def]\n\n"}
{"name":"Fin.univ_image_def","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\nf : Fin n → α\n⊢ Eq (Finset.image f Finset.univ) (List.ofFn f).toFinset","decl":"theorem Fin.univ_image_def {n : ℕ} [DecidableEq α] (f : Fin n → α) :\n    Finset.univ.image f = (List.ofFn f).toFinset := by\n  simp [Finset.image]\n\n"}
{"name":"Fin.univ_map_def","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Function.Embedding (Fin n) α\n⊢ Eq (Finset.map f Finset.univ) { val := ↑(List.ofFn ⇑f), nodup := ⋯ }","decl":"theorem Fin.univ_map_def {n : ℕ} (f : Fin n ↪ α) :\n    Finset.univ.map f = ⟨List.ofFn f, List.nodup_ofFn.mpr f.injective⟩ := by\n  simp [Finset.map]\n\n"}
{"name":"Fin.image_succAbove_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Finset.image i.succAbove Finset.univ) (HasCompl.compl (Singleton.singleton i))","decl":"@[simp]\ntheorem Fin.image_succAbove_univ {n : ℕ} (i : Fin (n + 1)) : univ.image i.succAbove = {i}ᶜ := by\n  ext m\n  simp\n\n"}
{"name":"Fin.image_succ_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq (Finset.image Fin.succ Finset.univ) (HasCompl.compl (Singleton.singleton 0))","decl":"@[simp]\ntheorem Fin.image_succ_univ (n : ℕ) : (univ : Finset (Fin n)).image Fin.succ = {0}ᶜ := by\n  rw [← Fin.succAbove_zero, Fin.image_succAbove_univ]\n\n"}
{"name":"Fin.image_castSucc","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq (Finset.image Fin.castSucc Finset.univ) (HasCompl.compl (Singleton.singleton (Fin.last n)))","decl":"@[simp]\ntheorem Fin.image_castSucc (n : ℕ) :\n    (univ : Finset (Fin n)).image Fin.castSucc = {Fin.last n}ᶜ := by\n  rw [← Fin.succAbove_last, Fin.image_succAbove_univ]\n\n/- The following three lemmas use `Finset.cons` instead of `insert` and `Finset.map` instead of\n`Finset.image` to reduce proof obligations downstream. -/\n"}
{"name":"Fin.univ_succ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq Finset.univ (Finset.cons 0 (Finset.map { toFun := Fin.succ, inj' := ⋯ } Finset.univ) ⋯)","decl":"/-- Embed `Fin n` into `Fin (n + 1)` by prepending zero to the `univ` -/\ntheorem Fin.univ_succ (n : ℕ) :\n    (univ : Finset (Fin (n + 1))) =\n      Finset.cons 0 (univ.map ⟨Fin.succ, Fin.succ_injective _⟩) (by simp [map_eq_image]) := by\n  simp [map_eq_image]\n\n"}
{"name":"Fin.univ_castSuccEmb","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\n⊢ Eq Finset.univ (Finset.cons (Fin.last n) (Finset.map Fin.castSuccEmb Finset.univ) ⋯)","decl":"/-- Embed `Fin n` into `Fin (n + 1)` by appending a new `Fin.last n` to the `univ` -/\ntheorem Fin.univ_castSuccEmb (n : ℕ) :\n    (univ : Finset (Fin (n + 1))) =\n      Finset.cons (Fin.last n) (univ.map Fin.castSuccEmb) (by simp [map_eq_image]) := by\n  simp [map_eq_image]\n\n"}
{"name":"Fin.univ_succAbove","module":"Mathlib.Data.Fintype.Basic","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\n⊢ Eq Finset.univ (Finset.cons p (Finset.map p.succAboveEmb Finset.univ) ⋯)","decl":"/-- Embed `Fin n` into `Fin (n + 1)` by inserting\naround a specified pivot `p : Fin (n + 1)` into the `univ` -/\ntheorem Fin.univ_succAbove (n : ℕ) (p : Fin (n + 1)) :\n    (univ : Finset (Fin (n + 1))) = Finset.cons p (univ.map <| Fin.succAboveEmb p) (by simp) := by\n  simp [map_eq_image]\n\n"}
{"name":"Fin.univ_image_get","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (Finset.image l.get Finset.univ) l.toFinset","decl":"@[simp] theorem Fin.univ_image_get [DecidableEq α] (l : List α) :\n    Finset.univ.image l.get = l.toFinset := by\n  simp [univ_image_def]\n\n"}
{"name":"Fin.univ_image_getElem'","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nl : List α\nf : α → β\n⊢ Eq (Finset.image (fun i => f (GetElem.getElem l ↑i ⋯)) Finset.univ) (List.map f l).toFinset","decl":"@[simp] theorem Fin.univ_image_getElem' [DecidableEq β] (l : List α) (f : α → β) :\n    Finset.univ.image (fun i : Fin l.length => f <| l[(i : Nat)]) = (l.map f).toFinset := by\n  simp only [univ_image_def, List.ofFn_getElem_eq_map]\n\n"}
{"name":"Fin.univ_image_get'","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nl : List α\nf : α → β\n⊢ Eq (Finset.image (fun x => f (l.get x)) Finset.univ) (List.map f l).toFinset","decl":"theorem Fin.univ_image_get' [DecidableEq β] (l : List α) (f : α → β) :\n    Finset.univ.image (f <| l.get ·) = (l.map f).toFinset := by\n  simp\n\n"}
{"name":"Fintype.univ_empty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ EmptyCollection.emptyCollection","decl":"theorem Fintype.univ_empty : @univ Empty _ = ∅ :=\n  rfl\n\n"}
{"name":"Fintype.univ_pempty","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ EmptyCollection.emptyCollection","decl":"theorem Fintype.univ_pempty : @univ PEmpty _ = ∅ :=\n  rfl\n\n"}
{"name":"Fintype.univ_unit","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ (Singleton.singleton Unit.unit)","decl":"theorem Fintype.univ_unit : @univ Unit _ = {()} :=\n  rfl\n\n"}
{"name":"Fintype.univ_punit","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ (Singleton.singleton PUnit.unit)","decl":"theorem Fintype.univ_punit : @univ PUnit _ = {PUnit.unit} :=\n  rfl\n\n"}
{"name":"Fintype.univ_bool","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ (Insert.insert Bool.true (Singleton.singleton Bool.false))","decl":"@[simp]\ntheorem Fintype.univ_bool : @univ Bool _ = {true, false} :=\n  rfl\n\n"}
{"name":"OrderDual.finite","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\ninst✝ : Finite α\n⊢ Finite (OrderDual α)","decl":"instance OrderDual.finite (α : Type*) [Finite α] : Finite αᵒᵈ :=\n  ‹Finite α›\n\n"}
{"name":"Finset.univ_eq_attach","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u\ns : Finset α\n⊢ Eq Finset.univ s.attach","decl":"@[simp]\ntheorem Finset.univ_eq_attach {α : Type u} (s : Finset α) : (univ : Finset s) = s.attach :=\n  rfl\n\n"}
{"name":"Fintype.coe_image_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\n⊢ Eq (↑(Finset.image f Finset.univ)) (Set.range f)","decl":"theorem Fintype.coe_image_univ [Fintype α] [DecidableEq β] {f : α → β} :\n    ↑(Finset.image f Finset.univ) = Set.range f := by\n  ext x\n  simp\n\n"}
{"name":"Finset.attach_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq s.attach Finset.univ","decl":"theorem Finset.attach_eq_univ {s : Finset α} : s.attach = Finset.univ :=\n  rfl\n\n"}
{"name":"Fintype.univ_Prop","module":"Mathlib.Data.Fintype.Basic","initialProofState":"⊢ Eq Finset.univ (Insert.insert True (Singleton.singleton False))","decl":"@[simp]\ntheorem Fintype.univ_Prop : (Finset.univ : Finset Prop) = {True, False} :=\n  Finset.eq_of_veq <| by simp; rfl\n\n"}
{"name":"Fintype.coe_finsetEquivSet","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq (⇑Fintype.finsetEquivSet) Finset.toSet","decl":"@[simp, norm_cast] lemma coe_finsetEquivSet : ⇑finsetEquivSet = ((↑) : Finset α → Set α) := rfl\n\n"}
{"name":"Fintype.finsetEquivSet_apply","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (Fintype.finsetEquivSet s) ↑s","decl":"@[simp] lemma finsetEquivSet_apply (s : Finset α) : finsetEquivSet s = s := rfl\n\n"}
{"name":"Fintype.finsetEquivSet_symm_apply","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq (Fintype.finsetEquivSet.symm s) s.toFinset","decl":"@[simp] lemma finsetEquivSet_symm_apply (s : Set α) [Fintype s] :\n    finsetEquivSet.symm s = s.toFinset := by simp [finsetEquivSet]\n\n"}
{"name":"Fintype.finsetOrderIsoSet_toEquiv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq Fintype.finsetOrderIsoSet.toEquiv Fintype.finsetEquivSet","decl":"/-- Given a fintype `α`, `finsetOrderIsoSet` is the order isomorphism between `Finset α` and `Set α`\n(all sets on a finite type are finite). -/\n@[simps toEquiv]\nnoncomputable def finsetOrderIsoSet : Finset α ≃o Set α where\n  toEquiv := finsetEquivSet\n  map_rel_iff' := Finset.coe_subset\n\n"}
{"name":"Fintype.coe_finsetOrderIsoSet","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq (⇑Fintype.finsetOrderIsoSet) Finset.toSet","decl":"@[simp, norm_cast]\nlemma coe_finsetOrderIsoSet : ⇑finsetOrderIsoSet = ((↑) : Finset α → Set α) := rfl\n\n"}
{"name":"Fintype.coe_finsetOrderIsoSet_symm","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq ⇑Fintype.finsetOrderIsoSet.symm ⇑Fintype.finsetEquivSet.symm","decl":"@[simp] lemma coe_finsetOrderIsoSet_symm :\n    ⇑(finsetOrderIsoSet : Finset α ≃o Set α).symm = ⇑finsetEquivSet.symm := rfl\n\n"}
{"name":"mem_image_univ_iff_mem_range","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nb : β\n⊢ Iff (Membership.mem (Finset.image f Finset.univ) b) (Membership.mem (Set.range f) b)","decl":"theorem mem_image_univ_iff_mem_range {α β : Type*} [Fintype α] [DecidableEq β] {f : α → β}\n    {b : β} : b ∈ univ.image f ↔ b ∈ Set.range f := by simp\n\n"}
{"name":"Fintype.choose_spec","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nhp : ExistsUnique fun a => p a\n⊢ p (Fintype.choose p hp)","decl":"theorem choose_spec (hp : ∃! a, p a) : p (choose p hp) :=\n  (chooseX p hp).property\n\n-- @[simp] Porting note: removing simp, never applies\n"}
{"name":"Fintype.choose_subtype_eq","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\np : α → Prop\ninst✝¹ : Fintype (Subtype fun a => p a)\ninst✝ : DecidableEq α\nx : Subtype fun a => p a\nh : optParam (ExistsUnique fun a => Eq ↑a ↑x) ⋯\n⊢ Eq (Fintype.choose (fun y => Eq ↑y ↑x) h) x","decl":"theorem choose_subtype_eq {α : Type*} (p : α → Prop) [Fintype { a : α // p a }] [DecidableEq α]\n    (x : { a : α // p a })\n    (h : ∃! a : { a // p a }, (a : α) = x :=\n      ⟨x, rfl, fun y hy => by simpa [Subtype.ext_iff] using hy⟩) :\n    Fintype.choose (fun y : { a : α // p a } => (y : α) = x) h = x := by\n  rw [Subtype.ext_iff, Fintype.choose_spec (fun y : { a : α // p a } => (y : α) = x) _]\n\n"}
{"name":"Fintype.leftInverse_bijInv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nf_bij : Function.Bijective f\n⊢ Function.LeftInverse (Fintype.bijInv f_bij) f","decl":"theorem leftInverse_bijInv (f_bij : Bijective f) : LeftInverse (bijInv f_bij) f := fun a =>\n  f_bij.left (choose_spec (fun a' => f a' = f a) _)\n\n"}
{"name":"Fintype.rightInverse_bijInv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nf_bij : Function.Bijective f\n⊢ Function.RightInverse (Fintype.bijInv f_bij) f","decl":"theorem rightInverse_bijInv (f_bij : Bijective f) : RightInverse (bijInv f_bij) f := fun b =>\n  choose_spec (fun a' => f a' = b) _\n\n"}
{"name":"Fintype.bijective_bijInv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : DecidableEq β\nf : α → β\nf_bij : Function.Bijective f\n⊢ Function.Bijective (Fintype.bijInv f_bij)","decl":"theorem bijective_bijInv (f_bij : Bijective f) : Bijective (bijInv f_bij) :=\n  ⟨(rightInverse_bijInv _).injective, (leftInverse_bijInv _).surjective⟩\n\n"}
{"name":"Multiset.count_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.count a Finset.univ.val) 1","decl":"@[simp]\ntheorem count_univ [DecidableEq α] (a : α) : count a Finset.univ.val = 1 :=\n  count_eq_one_of_mem Finset.univ.nodup (Finset.mem_univ _)\n\n"}
{"name":"Multiset.map_univ_val_equiv","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\ne : Equiv α β\n⊢ Eq (Multiset.map (⇑e) Finset.univ.val) Finset.univ.val","decl":"@[simp]\ntheorem map_univ_val_equiv (e : α ≃ β) :\n    map e univ.val = univ.val := by\n  rw [← congr_arg Finset.val (Finset.map_univ_equiv e), Finset.map_val, Equiv.coe_toEmbedding]\n\n"}
{"name":"Multiset.bijective_iff_map_univ_eq_univ","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\n⊢ Iff (Function.Bijective f) (Eq (Multiset.map f Finset.univ.val) Finset.univ.val)","decl":"/-- For functions on finite sets, they are bijections iff they map universes into universes. -/\n@[simp]\ntheorem bijective_iff_map_univ_eq_univ (f : α → β) :\n    f.Bijective ↔ map f (Finset.univ : Finset α).val = univ.val :=\n  ⟨fun bij ↦ congr_arg (·.val) (map_univ_equiv <| Equiv.ofBijective f bij),\n    fun eq ↦ ⟨\n      fun a₁ a₂ ↦ inj_on_of_nodup_map (eq.symm ▸ univ.nodup) _ (mem_univ a₁) _ (mem_univ a₂),\n      fun b ↦ have ⟨a, _, h⟩ := mem_map.mp (eq.symm ▸ mem_univ_val b); ⟨a, h⟩⟩⟩\n\n"}
{"name":"exists_seq_of_forall_finset_exists","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\nP : α → Prop\nr : α → α → Prop\nh : ∀ (s : Finset α), (∀ (x : α), Membership.mem s x → P x) → Exists fun y => And (P y) (∀ (x : α), Membership.mem s x → r x y)\n⊢ Exists fun f => And (∀ (n : Nat), P (f n)) (∀ (m n : Nat), LT.lt m n → r (f m) (f n))","decl":"/-- Induction principle to build a sequence, by adding one point at a time satisfying a given\nrelation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : ℕ → α` such that `r (f m) (f n)` holds whenever `m < n`.\nWe also ensure that all constructed points satisfy a given predicate `P`. -/\ntheorem exists_seq_of_forall_finset_exists {α : Type*} (P : α → Prop) (r : α → α → Prop)\n    (h : ∀ s : Finset α, (∀ x ∈ s, P x) → ∃ y, P y ∧ ∀ x ∈ s, r x y) :\n    ∃ f : ℕ → α, (∀ n, P (f n)) ∧ ∀ m n, m < n → r (f m) (f n) := by\n  classical\n    have : Nonempty α := by\n      rcases h ∅ (by simp) with ⟨y, _⟩\n      exact ⟨y⟩\n    choose! F hF using h\n    have h' : ∀ s : Finset α, ∃ y, (∀ x ∈ s, P x) → P y ∧ ∀ x ∈ s, r x y := fun s => ⟨F s, hF s⟩\n    set f := seqOfForallFinsetExistsAux P r h' with hf\n    have A : ∀ n : ℕ, P (f n) := by\n      intro n\n      induction' n using Nat.strong_induction_on with n IH\n      have IH' : ∀ x : Fin n, P (f x) := fun n => IH n.1 n.2\n      rw [hf, seqOfForallFinsetExistsAux]\n      exact\n        (Classical.choose_spec\n            (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n))))\n            (by simp [IH'])).1\n    refine ⟨f, A, fun m n hmn => ?_⟩\n    conv_rhs => rw [hf]\n    rw [seqOfForallFinsetExistsAux]\n    apply\n      (Classical.choose_spec\n          (h' (Finset.image (fun i : Fin n => f i) (Finset.univ : Finset (Fin n)))) (by simp [A])).2\n    exact Finset.mem_image.2 ⟨⟨m, hmn⟩, Finset.mem_univ _, rfl⟩\n\n"}
{"name":"exists_seq_of_forall_finset_exists'","module":"Mathlib.Data.Fintype.Basic","initialProofState":"α : Type u_4\nP : α → Prop\nr : α → α → Prop\ninst✝ : IsSymm α r\nh : ∀ (s : Finset α), (∀ (x : α), Membership.mem s x → P x) → Exists fun y => And (P y) (∀ (x : α), Membership.mem s x → r x y)\n⊢ Exists fun f => And (∀ (n : Nat), P (f n)) (Pairwise (Function.onFun r f))","decl":"/-- Induction principle to build a sequence, by adding one point at a time satisfying a given\nsymmetric relation with respect to all the previously chosen points.\n\nMore precisely, Assume that, for any finite set `s`, one can find another point satisfying\nsome relation `r` with respect to all the points in `s`. Then one may construct a\nfunction `f : ℕ → α` such that `r (f m) (f n)` holds whenever `m ≠ n`.\nWe also ensure that all constructed points satisfy a given predicate `P`. -/\ntheorem exists_seq_of_forall_finset_exists' {α : Type*} (P : α → Prop) (r : α → α → Prop)\n    [IsSymm α r] (h : ∀ s : Finset α, (∀ x ∈ s, P x) → ∃ y, P y ∧ ∀ x ∈ s, r x y) :\n    ∃ f : ℕ → α, (∀ n, P (f n)) ∧ Pairwise (r on f) := by\n  rcases exists_seq_of_forall_finset_exists P r h with ⟨f, hf, hf'⟩\n  refine ⟨f, hf, fun m n hmn => ?_⟩\n  rcases lt_trichotomy m n with (h | rfl | h)\n  · exact hf' m n h\n  · exact (hmn rfl).elim\n  · unfold Function.onFun\n    apply symm\n    exact hf' n m h\n\n"}
