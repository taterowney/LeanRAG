{"name":"AkraBazziRecurrence.GrowsPolynomially.congr_of_eventuallyEq","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhfg : Filter.atTop.EventuallyEq f g\nhg : AkraBazziRecurrence.GrowsPolynomially g\n⊢ AkraBazziRecurrence.GrowsPolynomially f","decl":"lemma congr_of_eventuallyEq {f g : ℝ → ℝ} (hfg : f =ᶠ[atTop] g) (hg : GrowsPolynomially g) :\n    GrowsPolynomially f := by\n  intro b hb\n  have hg' := hg b hb\n  obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hg'⟩ := hg'\n  refine ⟨c₁, hc₁_mem, c₂, hc₂_mem, ?_⟩\n  filter_upwards [hg', (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hfg, hfg]\n    with x hx₁ hx₂ hx₃\n  intro u hu\n  rw [hx₂ u hu.1, hx₃]\n  exact hx₁ u hu\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.iff_eventuallyEq","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nh : Filter.atTop.EventuallyEq f g\n⊢ Iff (AkraBazziRecurrence.GrowsPolynomially f) (AkraBazziRecurrence.GrowsPolynomially g)","decl":"lemma iff_eventuallyEq {f g : ℝ → ℝ} (h : f =ᶠ[atTop] g) :\n    GrowsPolynomially f ↔ GrowsPolynomially g :=\n  ⟨fun hf => congr_of_eventuallyEq h.symm hf, fun hg => congr_of_eventuallyEq h hg⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_le","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nb : Real\nhb : Membership.mem (Set.Ioo 0 1) b\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun x => ∀ (u : Real), Membership.mem (Set.Icc (HMul.hMul b x) x) u → LE.le (f u) (HMul.hMul c (f x))) Filter.atTop)","decl":"lemma eventually_atTop_le {b : ℝ} (hb : b ∈ Set.Ioo 0 1) (hf : GrowsPolynomially f) :\n    ∃ c > 0, ∀ᶠ x in atTop, ∀ u ∈ Set.Icc (b * x) x, f u ≤ c * f x := by\n  obtain ⟨c₁, _, c₂, hc₂, h⟩ := hf b hb\n  refine ⟨c₂, hc₂, ?_⟩\n  filter_upwards [h]\n  exact fun _ H u hu => (H u hu).2\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_le_nat","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nb : Real\nhb : Membership.mem (Set.Ioo 0 1) b\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ∀ (u : Real), Membership.mem (Set.Icc (HMul.hMul b ↑n) ↑n) u → LE.le (f u) (HMul.hMul c (f ↑n))) Filter.atTop)","decl":"lemma eventually_atTop_le_nat {b : ℝ} (hb : b ∈ Set.Ioo 0 1) (hf : GrowsPolynomially f) :\n    ∃ c > 0, ∀ᶠ (n : ℕ) in atTop, ∀ u ∈ Set.Icc (b * n) n, f u ≤ c * f n := by\n  obtain ⟨c, hc_mem, hc⟩ := hf.eventually_atTop_le hb\n  exact ⟨c, hc_mem, hc.natCast_atTop⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_ge","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nb : Real\nhb : Membership.mem (Set.Ioo 0 1) b\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun x => ∀ (u : Real), Membership.mem (Set.Icc (HMul.hMul b x) x) u → LE.le (HMul.hMul c (f x)) (f u)) Filter.atTop)","decl":"lemma eventually_atTop_ge {b : ℝ} (hb : b ∈ Set.Ioo 0 1) (hf : GrowsPolynomially f) :\n    ∃ c > 0, ∀ᶠ x in atTop, ∀ u ∈ Set.Icc (b * x) x, c * f x ≤ f u := by\n  obtain ⟨c₁, hc₁, c₂, _, h⟩ := hf b hb\n  refine ⟨c₁, hc₁, ?_⟩\n  filter_upwards [h]\n  exact fun _ H u hu => (H u hu).1\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_ge_nat","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nb : Real\nhb : Membership.mem (Set.Ioo 0 1) b\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Exists fun c => And (GT.gt c 0) (Filter.Eventually (fun n => ∀ (u : Real), Membership.mem (Set.Icc (HMul.hMul b ↑n) ↑n) u → LE.le (HMul.hMul c (f ↑n)) (f u)) Filter.atTop)","decl":"lemma eventually_atTop_ge_nat {b : ℝ} (hb : b ∈ Set.Ioo 0 1) (hf : GrowsPolynomially f) :\n    ∃ c > 0, ∀ᶠ (n : ℕ) in atTop, ∀ u ∈ Set.Icc (b * n) n, c * f n ≤ f u := by\n  obtain ⟨c, hc_mem, hc⟩ := hf.eventually_atTop_ge hb\n  exact ⟨c, hc_mem, hc.natCast_atTop⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_zero_of_frequently_zero","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhf' : Filter.Frequently (fun x => Eq (f x) 0) Filter.atTop\n⊢ Filter.Eventually (fun x => Eq (f x) 0) Filter.atTop","decl":"lemma eventually_zero_of_frequently_zero (hf : GrowsPolynomially f) (hf' : ∃ᶠ x in atTop, f x = 0) :\n    ∀ᶠ x in atTop, f x = 0 := by\n  obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hf⟩ := hf (1/2) (by norm_num)\n  rw [frequently_atTop] at hf'\n  filter_upwards [eventually_forall_ge_atTop.mpr hf, eventually_gt_atTop 0] with x hx hx_pos\n  obtain ⟨x₀, hx₀_ge, hx₀⟩ := hf' (max x 1)\n  have x₀_pos := calc\n    0 < 1 := by norm_num\n    _ ≤ x₀ := le_of_max_le_right hx₀_ge\n  have hmain : ∀ (m : ℕ) (z : ℝ), x ≤ z →\n      z ∈ Set.Icc ((2 : ℝ)^(-(m : ℤ) -1) * x₀) ((2 : ℝ)^(-(m : ℤ)) * x₀) → f z = 0 := by\n    intro m\n    induction m with\n    | zero =>\n      simp only [CharP.cast_eq_zero, neg_zero, zero_sub, zpow_zero, one_mul] at *\n      specialize hx x₀ (le_of_max_le_left hx₀_ge)\n      simp only [hx₀, mul_zero, Set.Icc_self, Set.mem_singleton_iff] at hx\n      refine fun z _ hz => hx _ ?_\n      simp only [zpow_neg, zpow_one] at hz\n      simp only [one_div, hz]\n    | succ k ih =>\n      intro z hxz hz\n      simp only [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one] at *\n      have hx' : x ≤ (2 : ℝ)^(-(k : ℤ) - 1) * x₀ := by\n        calc x ≤ z := hxz\n          _ ≤ _ := by simp only [neg_add, ← sub_eq_add_neg] at hz; exact hz.2\n      specialize hx ((2 : ℝ)^(-(k : ℤ) - 1) * x₀) hx' z\n      specialize ih ((2 : ℝ)^(-(k : ℤ) - 1) * x₀) hx' ?ineq\n      case ineq =>\n        rw [Set.left_mem_Icc]\n        gcongr\n        · norm_num\n        · omega\n      simp only [ih, mul_zero, Set.Icc_self, Set.mem_singleton_iff] at hx\n      refine hx ⟨?lb₁, ?ub₁⟩\n      case lb₁ =>\n        rw [one_div, ← zpow_neg_one, ← mul_assoc, ← zpow_add₀ (by norm_num)]\n        have h₁ : (-1 : ℤ)  + (-k - 1) = -k - 2 := by ring\n        have h₂ : -(k + (1 : ℤ)) - 1 = -k - 2 := by ring\n        rw [h₁]\n        rw [h₂] at hz\n        exact hz.1\n      case ub₁ =>\n        have := hz.2\n        simp only [neg_add, ← sub_eq_add_neg] at this\n        exact this\n  refine hmain ⌊-logb 2 (x / x₀)⌋₊ x le_rfl ⟨?lb, ?ub⟩\n  case lb =>\n    rw [← le_div_iff₀ x₀_pos]\n    refine (logb_le_logb (b := 2) (by norm_num) (zpow_pos (by norm_num) _)\n      (by positivity)).mp ?_\n    rw [← rpow_intCast, logb_rpow (by norm_num) (by norm_num), ← neg_le_neg_iff]\n    simp only [Int.cast_sub, Int.cast_neg, Int.cast_natCast, Int.cast_one, neg_sub, sub_neg_eq_add]\n    calc -logb 2 (x/x₀) ≤ ⌈-logb 2 (x/x₀)⌉₊ := Nat.le_ceil (-logb 2 (x / x₀))\n         _ ≤ _ := by rw [add_comm]; exact_mod_cast Nat.ceil_le_floor_add_one _\n  case ub =>\n    rw [← div_le_iff₀ x₀_pos]\n    refine (logb_le_logb (b := 2) (by norm_num) (by positivity)\n      (zpow_pos (by norm_num) _)).mp ?_\n    rw [← rpow_intCast, logb_rpow (by norm_num) (by norm_num), ← neg_le_neg_iff]\n    simp only [Int.cast_neg, Int.cast_natCast, neg_neg]\n    have : 0 ≤ -logb 2 (x / x₀) := by\n      rw [neg_nonneg]\n      refine logb_nonpos (by norm_num) (by positivity) ?_\n      rw [div_le_one x₀_pos]\n      exact le_of_max_le_left hx₀_ge\n    exact_mod_cast Nat.floor_le this\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_nonneg_or_nonpos","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Or (Filter.Eventually (fun x => LE.le 0 (f x)) Filter.atTop) (Filter.Eventually (fun x => LE.le (f x) 0) Filter.atTop)","decl":"lemma eventually_atTop_nonneg_or_nonpos (hf : GrowsPolynomially f) :\n    (∀ᶠ x in atTop, 0 ≤ f x) ∨ (∀ᶠ x in atTop, f x ≤ 0) := by\n  obtain ⟨c₁, _, c₂, _, h⟩ := hf (1/2) (by norm_num)\n  match lt_trichotomy c₁ c₂ with\n  | .inl hlt => -- c₁ < c₂\n    left\n    filter_upwards [h, eventually_ge_atTop 0] with x hx hx_nonneg\n    have h' : 3 / 4 * x ∈ Set.Icc (1 / 2 * x) x := by\n      rw [Set.mem_Icc]\n      exact ⟨by gcongr ?_ * x; norm_num, by linarith⟩\n    have hu := hx (3/4 * x) h'\n    have hu := Set.nonempty_of_mem hu\n    rw [Set.nonempty_Icc] at hu\n    have hu' : 0 ≤ (c₂ - c₁) * f x := by linarith\n    exact nonneg_of_mul_nonneg_right hu' (by linarith)\n  | .inr (.inr hgt) => -- c₂ < c₁\n    right\n    filter_upwards [h, eventually_ge_atTop 0] with x hx hx_nonneg\n    have h' : 3 / 4 * x ∈ Set.Icc (1 / 2 * x) x := by\n      rw [Set.mem_Icc]\n      exact ⟨by gcongr ?_ * x; norm_num, by linarith⟩\n    have hu := hx (3/4 * x) h'\n    have hu := Set.nonempty_of_mem hu\n    rw [Set.nonempty_Icc] at hu\n    have hu' : (c₁ - c₂) * f x ≤ 0 := by linarith\n    exact nonpos_of_mul_nonpos_right hu' (by linarith)\n  | .inr (.inl heq) => -- c₁ = c₂\n    have hmain : ∃ c, ∀ᶠ x in atTop, f x = c := by\n      simp only [heq, Set.Icc_self, Set.mem_singleton_iff, one_mul] at h\n      rw [eventually_atTop] at h\n      obtain ⟨n₀, hn₀⟩ := h\n      refine ⟨f (max n₀ 2), ?_⟩\n      rw [eventually_atTop]\n      refine ⟨max n₀ 2, ?_⟩\n      refine Real.induction_Ico_mul _ 2 (by norm_num) (by positivity) ?base ?step\n      case base =>\n        intro x ⟨hxlb, hxub⟩\n        have h₁ := calc n₀ ≤ 1 * max n₀ 2 := by simp\n                        _ ≤ 2 * max n₀ 2 := by gcongr; norm_num\n        have h₂ := hn₀ (2 * max n₀ 2) h₁ (max n₀ 2) ⟨by simp [hxlb], by linarith⟩\n        rw [h₂]\n        exact hn₀ (2 * max n₀ 2) h₁ x ⟨by simp [hxlb], le_of_lt hxub⟩\n      case step =>\n        intro n hn hyp_ind z hz\n        have z_nonneg : 0 ≤ z := by\n          calc (0 : ℝ) ≤ (2 : ℝ)^n * max n₀ 2 := by\n                        exact mul_nonneg (pow_nonneg (by norm_num) _) (by norm_num)\n                  _ ≤ z := by exact_mod_cast hz.1\n        have le_2n : max n₀ 2 ≤ (2 : ℝ)^n * max n₀ 2 := by\n          nth_rewrite 1 [← one_mul (max n₀ 2)]\n          gcongr\n          exact one_le_pow₀ (by norm_num : (1 : ℝ) ≤ 2)\n        have n₀_le_z : n₀ ≤ z := by\n          calc n₀ ≤ max n₀ 2 := by simp\n                _ ≤ (2 : ℝ)^n * max n₀ 2 := le_2n\n                _ ≤ _ := by exact_mod_cast hz.1\n        have fz_eq_c₂fz : f z = c₂ * f z := hn₀ z n₀_le_z z ⟨by linarith, le_rfl⟩\n        have z_to_half_z' : f (1/2 * z) = c₂ * f z := hn₀ z n₀_le_z (1/2 * z) ⟨le_rfl, by linarith⟩\n        have z_to_half_z : f (1/2 * z) = f z := by rwa [← fz_eq_c₂fz] at z_to_half_z'\n        have half_z_to_base : f (1/2 * z) = f (max n₀ 2) := by\n          refine hyp_ind (1/2 * z) ⟨?lb, ?ub⟩\n          case lb =>\n            calc max n₀ 2 ≤ ((1 : ℝ)/(2 : ℝ)) * (2 : ℝ) ^ 1 * max n₀ 2 := by simp\n                        _ ≤ ((1 : ℝ)/(2 : ℝ)) * (2 : ℝ) ^ n * max n₀ 2 := by gcongr; norm_num\n                        _ ≤ _ := by rw [mul_assoc]; gcongr; exact_mod_cast hz.1\n          case ub =>\n            have h₁ : (2 : ℝ)^n = ((1 : ℝ)/(2 : ℝ)) * (2 : ℝ)^(n+1) := by\n              rw [one_div, pow_add, pow_one]\n              ring\n            rw [h₁, mul_assoc]\n            gcongr\n            exact_mod_cast hz.2\n        rw [← z_to_half_z, half_z_to_base]\n    obtain ⟨c, hc⟩ := hmain\n    cases le_or_lt 0 c with\n    | inl hpos =>\n      exact Or.inl <| by filter_upwards [hc] with _ hc; simpa only [hc]\n    | inr hneg =>\n      right\n      filter_upwards [hc] with x hc\n      exact le_of_lt <| by simpa only [hc]\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.eventually_atTop_zero_or_pos_or_neg","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ Or (Filter.Eventually (fun x => Eq (f x) 0) Filter.atTop) (Or (Filter.Eventually (fun x => LT.lt 0 (f x)) Filter.atTop) (Filter.Eventually (fun x => LT.lt (f x) 0) Filter.atTop))","decl":"lemma eventually_atTop_zero_or_pos_or_neg (hf : GrowsPolynomially f) :\n    (∀ᶠ x in atTop, f x = 0) ∨ (∀ᶠ x in atTop, 0 < f x) ∨ (∀ᶠ x in atTop, f x < 0) := by\n  if h : ∃ᶠ x in atTop, f x = 0 then\n    exact Or.inl <| eventually_zero_of_frequently_zero hf h\n  else\n    rw [not_frequently] at h\n    push_neg at h\n    cases eventually_atTop_nonneg_or_nonpos hf with\n    | inl h' =>\n      refine Or.inr (Or.inl ?_)\n      simp only [lt_iff_le_and_ne]\n      rw [eventually_and]\n      exact ⟨h', by filter_upwards [h] with x hx; exact hx.symm⟩\n    | inr h' =>\n      refine Or.inr (Or.inr ?_)\n      simp only [lt_iff_le_and_ne]\n      rw [eventually_and]\n      exact ⟨h', h⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.neg","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ AkraBazziRecurrence.GrowsPolynomially (Neg.neg f)","decl":"protected lemma neg {f : ℝ → ℝ} (hf : GrowsPolynomially f) : GrowsPolynomially (-f) := by\n  intro b hb\n  obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hf⟩ := hf b hb\n  refine ⟨c₂, hc₂_mem, c₁, hc₁_mem, ?_⟩\n  filter_upwards [hf] with x hx\n  intro u hu\n  simp only [Pi.neg_apply, Set.neg_mem_Icc_iff, neg_mul_eq_mul_neg, neg_neg]\n  exact hx u hu\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.neg_iff","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\n⊢ Iff (AkraBazziRecurrence.GrowsPolynomially f) (AkraBazziRecurrence.GrowsPolynomially (Neg.neg f))","decl":"protected lemma neg_iff {f : ℝ → ℝ} : GrowsPolynomially f ↔ GrowsPolynomially (-f) :=\n  ⟨fun hf => hf.neg, fun hf => by rw [← neg_neg f]; exact hf.neg⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.abs","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => abs (f x)","decl":"protected lemma abs (hf : GrowsPolynomially f) : GrowsPolynomially (fun x => |f x|) := by\n  cases eventually_atTop_nonneg_or_nonpos hf with\n  | inl hf' =>\n    have hmain : f =ᶠ[atTop] fun x => |f x| := by\n      filter_upwards [hf'] with x hx\n      rw [abs_of_nonneg hx]\n    rw [← iff_eventuallyEq hmain]\n    exact hf\n  | inr hf' =>\n    have hmain : -f =ᶠ[atTop] fun x => |f x| := by\n      filter_upwards [hf'] with x hx\n      simp only [Pi.neg_apply, abs_of_nonpos hx]\n\n    rw [← iff_eventuallyEq hmain]\n    exact hf.neg\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.norm","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => Norm.norm (f x)","decl":"protected lemma norm (hf : GrowsPolynomially f) : GrowsPolynomially (fun x => ‖f x‖) := by\n  simp only [norm_eq_abs]\n  exact hf.abs\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_const","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"c : Real\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => c","decl":"lemma growsPolynomially_const {c : ℝ} : GrowsPolynomially (fun _ => c) := by\n  refine fun _ _ => ⟨1, by norm_num, 1, by norm_num, ?_⟩\n  filter_upwards [] with x\n  simp\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_id","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"⊢ AkraBazziRecurrence.GrowsPolynomially fun x => x","decl":"lemma growsPolynomially_id : GrowsPolynomially (fun x => x) := by\n  intro b hb\n  refine ⟨b, hb.1, ?_⟩\n  refine ⟨1, by norm_num, ?_⟩\n  filter_upwards with x u hu\n  simp only [one_mul, gt_iff_lt, not_le, Set.mem_Icc]\n  exact ⟨hu.1, hu.2⟩\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.mul","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhg : AkraBazziRecurrence.GrowsPolynomially g\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HMul.hMul (f x) (g x)","decl":"protected lemma GrowsPolynomially.mul {f g : ℝ → ℝ} (hf : GrowsPolynomially f)\n    (hg : GrowsPolynomially g) : GrowsPolynomially fun x => f x * g x := by\n  suffices GrowsPolynomially fun x => |f x| * |g x| by\n    cases eventually_atTop_nonneg_or_nonpos hf with\n    | inl hf' =>\n      cases eventually_atTop_nonneg_or_nonpos hg with\n      | inl hg' =>\n        have hmain : (fun x => f x * g x) =ᶠ[atTop] fun x => |f x| * |g x| := by\n          filter_upwards [hf', hg'] with x hx₁ hx₂\n          rw [abs_of_nonneg hx₁, abs_of_nonneg hx₂]\n        rwa [iff_eventuallyEq hmain]\n      | inr hg' =>\n        have hmain : (fun x => f x * g x) =ᶠ[atTop] fun x => -|f x| * |g x| := by\n          filter_upwards [hf', hg'] with x hx₁ hx₂\n          simp [abs_of_nonneg hx₁, abs_of_nonpos hx₂]\n        simp only [iff_eventuallyEq hmain, neg_mul]\n        exact this.neg\n    | inr hf' =>\n      cases eventually_atTop_nonneg_or_nonpos hg with\n      | inl hg' =>\n        have hmain : (fun x => f x * g x) =ᶠ[atTop] fun x => -|f x| * |g x| := by\n          filter_upwards [hf', hg'] with x hx₁ hx₂\n          rw [abs_of_nonpos hx₁, abs_of_nonneg hx₂, neg_neg]\n        simp only [iff_eventuallyEq hmain, neg_mul]\n        exact this.neg\n      | inr hg' =>\n        have hmain : (fun x => f x * g x) =ᶠ[atTop] fun x => |f x| * |g x| := by\n          filter_upwards [hf', hg'] with x hx₁ hx₂\n          simp [abs_of_nonpos hx₁, abs_of_nonpos hx₂]\n        simp only [iff_eventuallyEq hmain, neg_mul]\n        exact this\n  intro b hb\n  have hf := hf.abs b hb\n  have hg := hg.abs b hb\n  obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hf⟩ := hf\n  obtain ⟨c₃, hc₃_mem, c₄, hc₄_mem, hg⟩ := hg\n  refine ⟨c₁ * c₃, by show 0 < c₁ * c₃; positivity, ?_⟩\n  refine ⟨c₂ * c₄, by show 0 < c₂ * c₄; positivity, ?_⟩\n  filter_upwards [hf, hg] with x hf hg\n  intro u hu\n  refine ⟨?lb, ?ub⟩\n  case lb => calc\n    c₁ * c₃ * (|f x| * |g x|) = (c₁ * |f x|) * (c₃ * |g x|) := by ring\n    _ ≤ |f u| * |g u| := by\n           gcongr\n           · exact (hf u hu).1\n           · exact (hg u hu).1\n  case ub => calc\n    |f u| * |g u| ≤ (c₂ * |f x|) * (c₄ * |g x|) := by\n           gcongr\n           · exact (hf u hu).2\n           · exact (hg u hu).2\n    _ = c₂ * c₄ * (|f x| * |g x|) := by ring\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.const_mul","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nc : Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HMul.hMul c (f x)","decl":"lemma GrowsPolynomially.const_mul {f : ℝ → ℝ} {c : ℝ} (hf : GrowsPolynomially f) :\n    GrowsPolynomially fun x => c * f x :=\n  GrowsPolynomially.mul growsPolynomially_const hf\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.add","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhg : AkraBazziRecurrence.GrowsPolynomially g\nhf' : Filter.atTop.EventuallyLE 0 f\nhg' : Filter.atTop.EventuallyLE 0 g\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HAdd.hAdd (f x) (g x)","decl":"protected lemma GrowsPolynomially.add {f g : ℝ → ℝ} (hf : GrowsPolynomially f)\n    (hg : GrowsPolynomially g) (hf' : 0 ≤ᶠ[atTop] f) (hg' : 0 ≤ᶠ[atTop] g) :\n    GrowsPolynomially fun x => f x + g x := by\n  intro b hb\n  have hf := hf b hb\n  have hg := hg b hb\n  obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hf⟩ := hf\n  obtain ⟨c₃, hc₃_mem, c₄, _, hg⟩ := hg\n  refine ⟨min c₁ c₃, by show 0 < min c₁ c₃; positivity, ?_⟩\n  refine ⟨max c₂ c₄, by show 0 < max c₂ c₄; positivity, ?_⟩\n  filter_upwards [hf, hg,\n                  (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hf',\n                  (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hg',\n                  eventually_ge_atTop 0] with x hf hg hf' hg' hx_pos\n  intro u hu\n  have hbx : b * x ≤ x := calc\n    b * x ≤ 1 * x := by gcongr; exact le_of_lt hb.2\n        _ = x := by ring\n  have fx_nonneg : 0 ≤ f x := hf' x hbx\n  have gx_nonneg : 0 ≤ g x := hg' x hbx\n  refine ⟨?lb, ?ub⟩\n  case lb => calc\n    min c₁ c₃ * (f x + g x) = min c₁ c₃ * f x + min c₁ c₃ * g x := by simp only [mul_add]\n      _ ≤ c₁ * f x + c₃ * g x := by\n              gcongr\n              · exact min_le_left _ _\n              · exact min_le_right _ _\n      _ ≤ f u + g u := by\n              gcongr\n              · exact (hf u hu).1\n              · exact (hg u hu).1\n  case ub => calc\n    max c₂ c₄ * (f x + g x) = max c₂ c₄ * f x + max c₂ c₄ * g x := by simp only [mul_add]\n      _ ≥ c₂ * f x + c₄ * g x := by gcongr\n                                    · exact le_max_left _ _\n                                    · exact le_max_right _ _\n      _ ≥ f u + g u := by gcongr\n                          · exact (hf u hu).2\n                          · exact (hg u hu).2\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.add_isLittleO","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhfg : Asymptotics.IsLittleO Filter.atTop g f\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HAdd.hAdd (f x) (g x)","decl":"lemma GrowsPolynomially.add_isLittleO {f g : ℝ → ℝ} (hf : GrowsPolynomially f)\n    (hfg : g =o[atTop] f) : GrowsPolynomially fun x => f x + g x := by\n  intro b hb\n  have hb_ub := hb.2\n  rw [isLittleO_iff] at hfg\n  cases hf.eventually_atTop_nonneg_or_nonpos with\n  | inl hf' => -- f is eventually non-negative\n    have hf := hf b hb\n    obtain ⟨c₁, hc₁_mem : 0 < c₁, c₂, hc₂_mem : 0 < c₂, hf⟩ := hf\n    specialize hfg (c := 1/2) (by norm_num)\n    refine ⟨c₁ / 3, by positivity, 3*c₂, by positivity, ?_⟩\n    filter_upwards [hf,\n                    (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hfg,\n                    (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hf',\n                    eventually_ge_atTop 0] with x hf₁ hfg' hf₂ hx_nonneg\n    have hbx : b * x ≤ x := by nth_rewrite 2 [← one_mul x]; gcongr\n    have hfg₂ : ‖g x‖ ≤ 1/2 * f x := by\n      calc ‖g x‖ ≤ 1/2 * ‖f x‖ := hfg' x hbx\n           _ = 1/2 * f x := by congr; exact norm_of_nonneg (hf₂ _ hbx)\n    have hx_ub : f x + g x ≤ 3/2 * f x := by\n      calc _ ≤ f x + ‖g x‖ := by gcongr; exact le_norm_self (g x)\n           _ ≤ f x + 1/2 * f x := by gcongr\n           _ = 3/2 * f x := by ring\n    have hx_lb : 1/2 * f x ≤ f x + g x := by\n      calc f x + g x ≥ f x - ‖g x‖ := by\n                rw [sub_eq_add_neg, norm_eq_abs]; gcongr; exact neg_abs_le (g x)\n           _ ≥ f x - 1/2 * f x := by gcongr\n           _ = 1/2 * f x := by ring\n    intro u ⟨hu_lb, hu_ub⟩\n    have hfu_nonneg : 0 ≤ f u := hf₂ _ hu_lb\n    have hfg₃ : ‖g u‖ ≤ 1/2 * f u := by\n      calc ‖g u‖ ≤ 1/2 * ‖f u‖ := hfg' _ hu_lb\n           _ = 1/2 * f u := by congr; simp only [norm_eq_abs, abs_eq_self, hfu_nonneg]\n    refine ⟨?lb, ?ub⟩\n    case lb =>\n      calc f u + g u ≥ f u - ‖g u‖ := by\n                  rw [sub_eq_add_neg, norm_eq_abs]; gcongr; exact neg_abs_le _\n           _ ≥ f u - 1/2 * f u := by gcongr\n           _ = 1/2 * f u := by ring\n           _ ≥ 1/2 * (c₁ * f x) := by gcongr; exact (hf₁ u ⟨hu_lb, hu_ub⟩).1\n           _ = c₁/3 * (3/2 * f x) := by ring\n           _ ≥ c₁/3 * (f x + g x) := by gcongr\n    case ub =>\n      calc _ ≤ f u + ‖g u‖ := by gcongr; exact le_norm_self (g u)\n           _ ≤ f u + 1/2 * f u := by gcongr\n           _ = 3/2 * f u := by ring\n           _ ≤ 3/2 * (c₂ * f x) := by gcongr; exact (hf₁ u ⟨hu_lb, hu_ub⟩).2\n           _ = 3*c₂ * (1/2 * f x) := by ring\n           _ ≤ 3*c₂ * (f x + g x) := by gcongr\n  | inr hf' => -- f is eventually nonpos\n    have hf := hf b hb\n    obtain ⟨c₁, hc₁_mem : 0 < c₁, c₂, hc₂_mem : 0 < c₂, hf⟩ := hf\n    specialize hfg (c := 1/2) (by norm_num)\n    refine ⟨3*c₁, by positivity, c₂/3, by positivity, ?_⟩\n    filter_upwards [hf,\n                    (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hfg,\n                    (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hf',\n                    eventually_ge_atTop 0] with x hf₁ hfg' hf₂ hx_nonneg\n    have hbx : b * x ≤ x := by nth_rewrite 2 [← one_mul x]; gcongr\n    have hfg₂ : ‖g x‖ ≤ -1/2 * f x := by\n      calc ‖g x‖ ≤ 1/2 * ‖f x‖ := hfg' x hbx\n           _ = 1/2 * (-f x) := by congr; exact norm_of_nonpos (hf₂ x hbx)\n           _ = _ := by ring\n    have hx_ub : f x + g x ≤ 1/2 * f x := by\n      calc _ ≤ f x + ‖g x‖ := by gcongr; exact le_norm_self (g x)\n           _ ≤ f x + (-1/2 * f x) := by gcongr\n           _ = 1/2 * f x := by ring\n    have hx_lb : 3/2 * f x ≤ f x + g x := by\n      calc f x + g x ≥ f x - ‖g x‖ := by\n                rw [sub_eq_add_neg, norm_eq_abs]; gcongr; exact neg_abs_le (g x)\n           _ ≥ f x + 1/2 * f x := by\n                  rw [sub_eq_add_neg]\n                  gcongr\n                  refine le_of_neg_le_neg ?bc.a\n                  rwa [neg_neg, ← neg_mul, ← neg_div]\n           _ = 3/2 * f x := by ring\n    intro u ⟨hu_lb, hu_ub⟩\n    have hfu_nonpos : f u ≤ 0 := hf₂ _ hu_lb\n    have hfg₃ : ‖g u‖ ≤ -1/2 * f u := by\n      calc ‖g u‖ ≤ 1/2 * ‖f u‖ := hfg' _ hu_lb\n           _ = 1/2 * (-f u) := by congr; exact norm_of_nonpos hfu_nonpos\n           _ = -1/2 * f u := by ring\n    refine ⟨?lb, ?ub⟩\n    case lb =>\n      calc f u + g u ≥ f u - ‖g u‖ := by\n                  rw [sub_eq_add_neg, norm_eq_abs]; gcongr; exact neg_abs_le _\n           _ ≥ f u + 1/2 * f u := by\n                  rw [sub_eq_add_neg]\n                  gcongr\n                  refine le_of_neg_le_neg ?_\n                  rwa [neg_neg, ← neg_mul, ← neg_div]\n           _ = 3/2 * f u := by ring\n           _ ≥ 3/2 * (c₁ * f x) := by gcongr; exact (hf₁ u ⟨hu_lb, hu_ub⟩).1\n           _ = 3*c₁ * (1/2 * f x) := by ring\n           _ ≥ 3*c₁ * (f x + g x) := by gcongr\n    case ub =>\n      calc _ ≤ f u + ‖g u‖ := by gcongr; exact le_norm_self (g u)\n           _ ≤ f u - 1/2 * f u := by\n                rw [sub_eq_add_neg]\n                gcongr\n                rwa [← neg_mul, ← neg_div]\n           _ = 1/2 * f u := by ring\n           _ ≤ 1/2 * (c₂ * f x) := by gcongr; exact (hf₁ u ⟨hu_lb, hu_ub⟩).2\n           _ = c₂/3 * (3/2 * f x) := by ring\n           _ ≤ c₂/3 * (f x + g x) := by gcongr\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.inv","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => Inv.inv (f x)","decl":"protected lemma GrowsPolynomially.inv {f : ℝ → ℝ} (hf : GrowsPolynomially f) :\n    GrowsPolynomially fun x => (f x)⁻¹ := by\n  cases hf.eventually_atTop_zero_or_pos_or_neg with\n  | inl hf' =>\n    refine fun b hb => ⟨1, by simp, 1, by simp, ?_⟩\n    have hb_pos := hb.1\n    filter_upwards [hf', (tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hf']\n      with x hx hx'\n    intro u hu\n    simp only [hx, inv_zero, mul_zero, Set.Icc_self, Set.mem_singleton_iff, hx' u hu.1]\n  | inr hf_pos_or_neg =>\n    suffices GrowsPolynomially fun x => |(f x)⁻¹| by\n      cases hf_pos_or_neg with\n      | inl hf' =>\n        have hmain : (fun x => (f x)⁻¹) =ᶠ[atTop] fun x => |(f x)⁻¹| := by\n          filter_upwards [hf'] with x hx₁\n          rw [abs_of_nonneg (inv_nonneg_of_nonneg (le_of_lt hx₁))]\n        rwa [iff_eventuallyEq hmain]\n      | inr hf' =>\n        have hmain : (fun x => (f x)⁻¹) =ᶠ[atTop] fun x => -|(f x)⁻¹| := by\n          filter_upwards [hf'] with x hx₁\n          simp [abs_of_nonpos (inv_nonpos.mpr (le_of_lt hx₁))]\n        rw [iff_eventuallyEq hmain]\n        exact this.neg\n    have hf' : ∀ᶠ x in atTop, f x ≠ 0 := by\n      cases hf_pos_or_neg with\n      | inl H => filter_upwards [H] with _ hx; exact (ne_of_lt hx).symm\n      | inr H => filter_upwards [H] with _ hx; exact (ne_of_gt hx).symm\n    simp only [abs_inv]\n    have hf := hf.abs\n    intro b hb\n    have hb_pos := hb.1\n    obtain ⟨c₁, hc₁_mem, c₂, hc₂_mem, hf⟩ := hf b hb\n    refine ⟨c₂⁻¹, by show 0 < c₂⁻¹; positivity, ?_⟩\n    refine ⟨c₁⁻¹, by show 0 < c₁⁻¹; positivity, ?_⟩\n    filter_upwards [hf, hf', (tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hf']\n      with x hx hx' hx''\n    intro u hu\n    have h₁ : 0 < |f u| := by rw [abs_pos]; exact hx'' u hu.1\n    refine ⟨?lb, ?ub⟩\n    case lb =>\n      rw [← mul_inv]\n      gcongr\n      exact (hx u hu).2\n    case ub =>\n      rw [← mul_inv]\n      gcongr\n      exact (hx u hu).1\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.div","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhg : AkraBazziRecurrence.GrowsPolynomially g\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HDiv.hDiv (f x) (g x)","decl":"protected lemma GrowsPolynomially.div {f g : ℝ → ℝ} (hf : GrowsPolynomially f)\n    (hg : GrowsPolynomially g) : GrowsPolynomially fun x => f x / g x := by\n  have : (fun x => f x / g x) = fun x => f x * (g x)⁻¹ := by ext; rw [div_eq_mul_inv]\n  rw [this]\n  exact GrowsPolynomially.mul hf (GrowsPolynomially.inv hg)\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.rpow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\np : Real\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhf_nonneg : Filter.Eventually (fun x => LE.le 0 (f x)) Filter.atTop\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow (f x) p","decl":"protected lemma GrowsPolynomially.rpow (p : ℝ) (hf : GrowsPolynomially f)\n    (hf_nonneg : ∀ᶠ x in atTop, 0 ≤ f x) : GrowsPolynomially fun x => (f x) ^ p := by\n  intro b hb\n  obtain ⟨c₁, (hc₁_mem : 0 < c₁), c₂, hc₂_mem, hfnew⟩ := hf b hb\n  have hc₁p : 0 < c₁ ^ p := Real.rpow_pos_of_pos hc₁_mem _\n  have hc₂p : 0 < c₂ ^ p := Real.rpow_pos_of_pos hc₂_mem _\n  cases le_or_lt 0 p with\n  | inl => -- 0 ≤ p\n    refine ⟨c₁^p, hc₁p, ?_⟩\n    refine ⟨c₂^p, hc₂p, ?_⟩\n    filter_upwards [eventually_gt_atTop 0, hfnew, hf_nonneg,\n        (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hf_nonneg]\n        with x _ hf₁ hf_nonneg hf_nonneg₂\n    intro u hu\n    have fu_nonneg : 0 ≤ f u := hf_nonneg₂ u hu.1\n    refine ⟨?lb, ?ub⟩\n    case lb => calc\n      c₁^p * (f x)^p = (c₁ * f x)^p := by rw [mul_rpow (le_of_lt hc₁_mem) hf_nonneg]\n        _ ≤ _ := by gcongr; exact (hf₁ u hu).1\n    case ub => calc\n      (f u)^p ≤ (c₂ * f x)^p := by gcongr; exact (hf₁ u hu).2\n        _ = _ := by rw [← mul_rpow (le_of_lt hc₂_mem) hf_nonneg]\n  | inr hp => -- p < 0\n    match hf.eventually_atTop_zero_or_pos_or_neg with\n    | .inl hzero => -- eventually zero\n      refine ⟨1, by norm_num, 1, by norm_num, ?_⟩\n      filter_upwards [hzero, hfnew] with x hx hx'\n      intro u hu\n      simp only [hx, ne_eq, zero_rpow (ne_of_lt hp), mul_zero, le_refl, not_true, lt_self_iff_false,\n        Set.Icc_self, Set.mem_singleton_iff]\n      simp only [hx, mul_zero, Set.Icc_self, Set.mem_singleton_iff] at hx'\n      rw [hx' u hu, zero_rpow (ne_of_lt hp)]\n    | .inr (.inl hpos) => -- eventually positive\n      refine ⟨c₂^p, hc₂p, ?_⟩\n      refine ⟨c₁^p, hc₁p, ?_⟩\n      filter_upwards [eventually_gt_atTop 0, hfnew, hpos,\n          (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop hpos]\n          with x _ hf₁ hf_pos hf_pos₂\n      intro u hu\n      refine ⟨?lb, ?ub⟩\n      case lb => calc\n        c₂^p * (f x)^p = (c₂ * f x)^p := by rw [mul_rpow (le_of_lt hc₂_mem) (le_of_lt hf_pos)]\n          _ ≤ _ := rpow_le_rpow_of_exponent_nonpos (hf_pos₂ u hu.1) (hf₁ u hu).2 (le_of_lt hp)\n      case ub => calc\n        (f u)^p ≤ (c₁ * f x)^p := by\n              exact rpow_le_rpow_of_exponent_nonpos (by positivity) (hf₁ u hu).1 (le_of_lt hp)\n          _ = _ := by rw [← mul_rpow (le_of_lt hc₁_mem) (le_of_lt hf_pos)]\n    | .inr (.inr hneg) => -- eventually negative (which is impossible)\n      have : ∀ᶠ (_ : ℝ) in atTop, False := by\n        filter_upwards [hf_nonneg, hneg] with x hx hx'; linarith\n      rw [Filter.eventually_false_iff_eq_bot] at this\n      exact False.elim <| (atTop_neBot).ne this\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.pow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\np : Nat\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhf_nonneg : Filter.Eventually (fun x => LE.le 0 (f x)) Filter.atTop\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow (f x) p","decl":"protected lemma GrowsPolynomially.pow (p : ℕ) (hf : GrowsPolynomially f)\n    (hf_nonneg : ∀ᶠ x in atTop, 0 ≤ f x) : GrowsPolynomially fun x => (f x) ^ p := by\n  simp_rw [← rpow_natCast]\n  exact hf.rpow p hf_nonneg\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.zpow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\np : Int\nhf : AkraBazziRecurrence.GrowsPolynomially f\nhf_nonneg : Filter.Eventually (fun x => LE.le 0 (f x)) Filter.atTop\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow (f x) p","decl":"protected lemma GrowsPolynomially.zpow (p : ℤ) (hf : GrowsPolynomially f)\n    (hf_nonneg : ∀ᶠ x in atTop, 0 ≤ f x) : GrowsPolynomially fun x => (f x) ^ p := by\n  simp_rw [← rpow_intCast]\n  exact hf.rpow p hf_nonneg\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_rpow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"p : Real\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow x p","decl":"lemma growsPolynomially_rpow (p : ℝ) : GrowsPolynomially fun x => x ^ p :=\n  (growsPolynomially_id).rpow p (eventually_ge_atTop 0)\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_pow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"p : Nat\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow x p","decl":"lemma growsPolynomially_pow (p : ℕ) : GrowsPolynomially fun x => x ^ p :=\n  (growsPolynomially_id).pow p (eventually_ge_atTop 0)\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_zpow","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"p : Int\n⊢ AkraBazziRecurrence.GrowsPolynomially fun x => HPow.hPow x p","decl":"lemma growsPolynomially_zpow (p : ℤ) : GrowsPolynomially fun x => x ^ p :=\n  (growsPolynomially_id).zpow p (eventually_ge_atTop 0)\n\n"}
{"name":"AkraBazziRecurrence.growsPolynomially_log","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"⊢ AkraBazziRecurrence.GrowsPolynomially Real.log","decl":"lemma growsPolynomially_log : GrowsPolynomially Real.log := by\n  intro b hb\n  have hb₀ : 0 < b := hb.1\n  refine ⟨1 / 2, by norm_num, ?_⟩\n  refine ⟨1, by norm_num, ?_⟩\n  have h_tendsto : Tendsto (fun x => 1 / 2 * Real.log x) atTop atTop :=\n    Tendsto.const_mul_atTop (by norm_num) Real.tendsto_log_atTop\n  filter_upwards [eventually_gt_atTop 1,\n                  (tendsto_id.const_mul_atTop hb.1).eventually_forall_ge_atTop\n                    <| h_tendsto.eventually (eventually_gt_atTop (-Real.log b)) ] with x hx_pos hx\n  intro u hu\n  refine ⟨?lb, ?ub⟩\n  case lb => calc\n    1 / 2 * Real.log x = Real.log x + (-1 / 2) * Real.log x := by ring\n      _ ≤ Real.log x + Real.log b := by\n              gcongr\n              rw [neg_div, neg_mul, ← neg_le]\n              refine le_of_lt (hx x ?_)\n              calc b * x ≤ 1 * x := by gcongr; exact le_of_lt hb.2\n                       _ = x := by rw [one_mul]\n      _ = Real.log (b * x) := by rw [← Real.log_mul (by positivity) (by positivity), mul_comm]\n      _ ≤ Real.log u := by gcongr; exact hu.1\n  case ub =>\n    rw [one_mul]\n    gcongr\n    · calc 0 < b * x := by positivity\n         _ ≤ u := by exact hu.1\n    · exact hu.2\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.of_isTheta","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhg : AkraBazziRecurrence.GrowsPolynomially g\nhf : Asymptotics.IsTheta Filter.atTop f g\nhf' : Filter.Eventually (fun x => LE.le 0 (f x)) Filter.atTop\n⊢ AkraBazziRecurrence.GrowsPolynomially f","decl":"lemma GrowsPolynomially.of_isTheta {f g : ℝ → ℝ} (hg : GrowsPolynomially g) (hf : f =Θ[atTop] g)\n    (hf' : ∀ᶠ x in atTop, 0 ≤ f x) : GrowsPolynomially f := by\n  intro b hb\n  have hb_pos := hb.1\n  have hf_lb := isBigO_iff''.mp hf.isBigO_symm\n  have hf_ub := isBigO_iff'.mp hf.isBigO\n  obtain ⟨c₁, hc₁_pos : 0 < c₁, hf_lb⟩ := hf_lb\n  obtain ⟨c₂, hc₂_pos : 0 < c₂, hf_ub⟩ := hf_ub\n  have hg := hg.norm b hb\n  obtain ⟨c₃, hc₃_pos : 0 < c₃, hg⟩ := hg\n  obtain ⟨c₄, hc₄_pos : 0 < c₄, hg⟩ := hg\n  have h_lb_pos : 0 < c₁ * c₂⁻¹ * c₃ := by positivity\n  have h_ub_pos : 0 < c₂ * c₄ * c₁⁻¹ := by positivity\n  refine ⟨c₁ * c₂⁻¹ * c₃, h_lb_pos, ?_⟩\n  refine ⟨c₂ * c₄ * c₁⁻¹, h_ub_pos, ?_⟩\n  have c₂_cancel : c₂⁻¹ * c₂ = 1 := inv_mul_cancel₀ (by positivity)\n  have c₁_cancel : c₁⁻¹ * c₁ = 1 := inv_mul_cancel₀ (by positivity)\n  filter_upwards [(tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hf',\n                  (tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hf_lb,\n                  (tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hf_ub,\n                  (tendsto_id.const_mul_atTop hb_pos).eventually_forall_ge_atTop hg,\n                  eventually_ge_atTop 0]\n    with x hf_pos h_lb h_ub hg_bound hx_pos\n  intro u hu\n  have hbx : b * x ≤ x :=\n    calc b * x ≤ 1 * x    := by gcongr; exact le_of_lt hb.2\n             _ = x        := by rw [one_mul]\n  have hg_bound := hg_bound x hbx\n  refine ⟨?lb, ?ub⟩\n  case lb => calc\n    c₁ * c₂⁻¹ * c₃ * f x ≤ c₁ * c₂⁻¹ * c₃ * (c₂ * ‖g x‖) := by\n          rw [← Real.norm_of_nonneg (hf_pos x hbx)]; gcongr; exact h_ub x hbx\n      _ = (c₂⁻¹ * c₂) * c₁ * (c₃ * ‖g x‖) := by ring\n      _ = c₁ * (c₃ * ‖g x‖) := by simp [c₂_cancel]\n      _ ≤ c₁ * ‖g u‖ := by gcongr; exact (hg_bound u hu).1\n      _ ≤ f u := by\n          rw [← Real.norm_of_nonneg (hf_pos u hu.1)]\n          exact h_lb u hu.1\n  case ub => calc\n    f u ≤ c₂ * ‖g u‖ := by rw [← Real.norm_of_nonneg (hf_pos u hu.1)]; exact h_ub u hu.1\n      _ ≤ c₂ * (c₄ * ‖g x‖) := by gcongr; exact (hg_bound u hu).2\n      _ = c₂ * c₄ * (c₁⁻¹ * c₁) * ‖g x‖ := by simp [c₁_cancel]; ring\n      _ = c₂ * c₄ * c₁⁻¹ * (c₁ * ‖g x‖) := by ring\n      _ ≤ c₂ * c₄ * c₁⁻¹ * f x := by\n                gcongr\n                rw [← Real.norm_of_nonneg (hf_pos x hbx)]\n                exact h_lb x hbx\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.of_isEquivalent","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f g : Real → Real\nhg : AkraBazziRecurrence.GrowsPolynomially g\nhf : Asymptotics.IsEquivalent Filter.atTop f g\n⊢ AkraBazziRecurrence.GrowsPolynomially f","decl":"lemma GrowsPolynomially.of_isEquivalent {f g : ℝ → ℝ} (hg : GrowsPolynomially g)\n    (hf : f ~[atTop] g) : GrowsPolynomially f := by\n  have : f = g + (f - g) := by ext; simp\n  rw [this]\n  exact add_isLittleO hg hf\n\n"}
{"name":"AkraBazziRecurrence.GrowsPolynomially.of_isEquivalent_const","module":"Mathlib.Computability.AkraBazzi.GrowsPolynomially","initialProofState":"f : Real → Real\nc : Real\nhf : Asymptotics.IsEquivalent Filter.atTop f fun x => c\n⊢ AkraBazziRecurrence.GrowsPolynomially f","decl":"lemma GrowsPolynomially.of_isEquivalent_const {f : ℝ → ℝ} {c : ℝ} (hf : f ~[atTop] fun _ => c) :\n    GrowsPolynomially f :=\n  of_isEquivalent growsPolynomially_const hf\n\n"}
