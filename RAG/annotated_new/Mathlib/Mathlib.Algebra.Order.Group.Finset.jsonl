{"name":"Multiset.toFinset_nsmul","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nn : Nat\na✝ : Ne n 0\n⊢ Eq (HSMul.hSMul n s).toFinset s.toFinset","decl":"@[simp] lemma toFinset_nsmul (s : Multiset α) : ∀ n ≠ 0, (n • s).toFinset = s.toFinset\n  | 0, h => by contradiction\n  | n + 1, _ => by\n    by_cases h : n = 0\n    · rw [h, zero_add, one_nsmul]\n    · rw [add_nsmul, toFinset_add, one_nsmul, toFinset_nsmul s n h, Finset.union_idempotent]\n\n"}
{"name":"Multiset.toFinset_eq_singleton_iff","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ Iff (Eq s.toFinset (Singleton.singleton a)) (And (Ne s.card 0) (Eq s (HSMul.hSMul s.card (Singleton.singleton a))))","decl":"lemma toFinset_eq_singleton_iff (s : Multiset α) (a : α) :\n    s.toFinset = {a} ↔ card s ≠ 0 ∧ s = card s • {a} := by\n  refine ⟨fun H ↦ ⟨fun h ↦ ?_, ext' fun x ↦ ?_⟩, fun H ↦ ?_⟩\n  · rw [card_eq_zero.1 h, toFinset_zero] at H\n    exact Finset.singleton_ne_empty _ H.symm\n  · rw [count_nsmul, count_singleton]\n    by_cases hx : x = a\n    · simp_rw [hx, ite_true, mul_one, count_eq_card]\n      intro y hy\n      rw [← mem_toFinset, H, Finset.mem_singleton] at hy\n      exact hy.symm\n    have hx' : x ∉ s := fun h' ↦ hx <| by rwa [← mem_toFinset, H, Finset.mem_singleton] at h'\n    simp_rw [count_eq_zero_of_not_mem hx', hx, ite_false, Nat.mul_zero]\n  simpa only [toFinset_nsmul _ _ H.1, toFinset_singleton] using congr($(H.2).toFinset)\n\n"}
{"name":"Multiset.toFinset_card_eq_one_iff","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Iff (Eq s.toFinset.card 1) (And (Ne s.card 0) (Exists fun a => Eq s (HSMul.hSMul s.card (Singleton.singleton a))))","decl":"lemma toFinset_card_eq_one_iff (s : Multiset α) :\n    #s.toFinset = 1 ↔ Multiset.card s ≠ 0 ∧ ∃ a : α, s = Multiset.card s • {a} := by\n  simp_rw [Finset.card_eq_one, Multiset.toFinset_eq_singleton_iff, exists_and_left]\n\n"}
{"name":"Finset.fold_max_add","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝² : LinearOrder M\ninst✝¹ : Add M\ninst✝ : AddRightMono M\ns : Finset ι\na : WithBot M\nf : ι → M\n⊢ Eq (Finset.fold Max.max Bot.bot (fun i => HAdd.hAdd (↑(f i)) a) s) (HAdd.hAdd (Finset.fold Max.max Bot.bot (Function.comp WithBot.some f) s) a)","decl":"lemma fold_max_add [LinearOrder M] [Add M] [AddRightMono M] (s : Finset ι) (a : WithBot M)\n    (f : ι → M) : s.fold max ⊥ (fun i ↦ ↑(f i) + a) = s.fold max ⊥ ((↑) ∘ f) + a := by\n  classical\n    induction' s using Finset.induction_on with a s _ ih <;> simp [*, max_add_add_right]\n\n"}
{"name":"Finset.nsmul_inf'","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : LinearOrder M\ninst✝² : AddMonoid M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\ns : Finset ι\nf : ι → M\nn : Nat\nhs : s.Nonempty\n⊢ Eq (HSMul.hSMul n (s.inf' hs f)) (s.inf' hs fun a => HSMul.hSMul n (f a))","decl":"@[to_additive nsmul_inf']\nlemma inf'_pow [LinearOrder M] [Monoid M] [MulLeftMono M] [MulRightMono M] (s : Finset ι)\n    (f : ι → M) (n : ℕ) (hs) : s.inf' hs f ^ n = s.inf' hs fun a ↦ f a ^ n :=\n  map_finset_inf' (OrderHom.mk _ <| pow_left_mono n) hs _\n\n"}
{"name":"Finset.inf'_pow","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : LinearOrder M\ninst✝² : Monoid M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\ns : Finset ι\nf : ι → M\nn : Nat\nhs : s.Nonempty\n⊢ Eq (HPow.hPow (s.inf' hs f) n) (s.inf' hs fun a => HPow.hPow (f a) n)","decl":"@[to_additive nsmul_inf']\nlemma inf'_pow [LinearOrder M] [Monoid M] [MulLeftMono M] [MulRightMono M] (s : Finset ι)\n    (f : ι → M) (n : ℕ) (hs) : s.inf' hs f ^ n = s.inf' hs fun a ↦ f a ^ n :=\n  map_finset_inf' (OrderHom.mk _ <| pow_left_mono n) hs _\n\n"}
{"name":"Finset.sup'_pow","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : LinearOrder M\ninst✝² : Monoid M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\ns : Finset ι\nf : ι → M\nn : Nat\nhs : s.Nonempty\n⊢ Eq (HPow.hPow (s.sup' hs f) n) (s.sup' hs fun a => HPow.hPow (f a) n)","decl":"@[to_additive nsmul_sup']\nlemma sup'_pow [LinearOrder M] [Monoid M] [MulLeftMono M] [MulRightMono M] (s : Finset ι)\n    (f : ι → M) (n : ℕ) (hs) : s.sup' hs f ^ n = s.sup' hs fun a ↦ f a ^ n :=\n  map_finset_sup' (OrderHom.mk _ <| pow_left_mono n) hs _\n\n"}
{"name":"Finset.nsmul_sup'","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : LinearOrder M\ninst✝² : AddMonoid M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\ns : Finset ι\nf : ι → M\nn : Nat\nhs : s.Nonempty\n⊢ Eq (HSMul.hSMul n (s.sup' hs f)) (s.sup' hs fun a => HSMul.hSMul n (f a))","decl":"@[to_additive nsmul_sup']\nlemma sup'_pow [LinearOrder M] [Monoid M] [MulLeftMono M] [MulRightMono M] (s : Finset ι)\n    (f : ι → M) (n : ℕ) (hs) : s.sup' hs f ^ n = s.sup' hs fun a ↦ f a ^ n :=\n  map_finset_sup' (OrderHom.mk _ <| pow_left_mono n) hs _\n\n"}
{"name":"Finset.sup'_mul","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : LinearOrder G\ninst✝ : MulRightMono G\ns : Finset ι\nf : ι → G\na : G\nhs : s.Nonempty\n⊢ Eq (HMul.hMul (s.sup' hs f) a) (s.sup' hs fun i => HMul.hMul (f i) a)","decl":"@[to_additive \"Also see `Finset.sup'_add'` that works for canonically ordered monoids.\"]\nlemma sup'_mul [MulRightMono G] (s : Finset ι) (f : ι → G) (a : G) (hs) :\n    s.sup' hs f * a = s.sup' hs fun i ↦ f i * a := map_finset_sup' (OrderIso.mulRight a) hs f\n\n"}
{"name":"Finset.sup'_add","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : LinearOrder G\ninst✝ : AddRightMono G\ns : Finset ι\nf : ι → G\na : G\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd (s.sup' hs f) a) (s.sup' hs fun i => HAdd.hAdd (f i) a)","decl":"@[to_additive \"Also see `Finset.sup'_add'` that works for canonically ordered monoids.\"]\nlemma sup'_mul [MulRightMono G] (s : Finset ι) (f : ι → G) (a : G) (hs) :\n    s.sup' hs f * a = s.sup' hs fun i ↦ f i * a := map_finset_sup' (OrderIso.mulRight a) hs f\n\n"}
{"name":"Finset.mul_sup'","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : Group G\ninst✝¹ : LinearOrder G\ninst✝ : MulLeftMono G\ns : Finset ι\nf : ι → G\na : G\nhs : s.Nonempty\n⊢ Eq (HMul.hMul a (s.sup' hs f)) (s.sup' hs fun i => HMul.hMul a (f i))","decl":"set_option linter.docPrime false in\n@[to_additive \"Also see `Finset.add_sup''` that works for canonically ordered monoids.\"]\nlemma mul_sup' [MulLeftMono G] (s : Finset ι) (f : ι → G) (a : G) (hs) :\n    a * s.sup' hs f = s.sup' hs fun i ↦ a * f i := map_finset_sup' (OrderIso.mulLeft a) hs f\n\n"}
{"name":"Finset.add_sup'","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nG : Type u_4\ninst✝² : AddGroup G\ninst✝¹ : LinearOrder G\ninst✝ : AddLeftMono G\ns : Finset ι\nf : ι → G\na : G\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd a (s.sup' hs f)) (s.sup' hs fun i => HAdd.hAdd a (f i))","decl":"set_option linter.docPrime false in\n@[to_additive \"Also see `Finset.add_sup''` that works for canonically ordered monoids.\"]\nlemma mul_sup' [MulLeftMono G] (s : Finset ι) (f : ι → G) (a : G) (hs) :\n    a * s.sup' hs f = s.sup' hs fun i ↦ a * f i := map_finset_sup' (OrderIso.mulLeft a) hs f\n\n"}
{"name":"Finset.sup'_add'","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : LinearOrderedAddCommMonoid M\ninst✝³ : CanonicallyOrderedAdd M\ninst✝² : Sub M\ninst✝¹ : AddLeftReflectLE M\ninst✝ : OrderedSub M\ns : Finset ι\nf : ι → M\na : M\nhs : s.Nonempty\n⊢ Eq (HAdd.hAdd (s.sup' hs f) a) (s.sup' hs fun i => HAdd.hAdd (f i) a)","decl":"/-- Also see `Finset.sup'_add` that works for ordered groups. -/\nlemma sup'_add' (s : Finset ι) (f : ι → M) (a : M) (hs : s.Nonempty) :\n    s.sup' hs f + a = s.sup' hs fun i ↦ f i + a := by\n  apply le_antisymm\n  · apply add_le_of_le_tsub_right_of_le\n    · exact Finset.le_sup'_of_le _ hs.choose_spec le_add_self\n    · exact Finset.sup'_le _ _ fun i hi ↦ le_tsub_of_add_le_right (Finset.le_sup' (f · + a) hi)\n  · exact Finset.sup'_le _ _ fun i hi ↦ add_le_add_right (Finset.le_sup' _ hi) _\n\n"}
{"name":"Finset.add_sup''","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : LinearOrderedAddCommMonoid M\ninst✝³ : CanonicallyOrderedAdd M\ninst✝² : Sub M\ninst✝¹ : AddLeftReflectLE M\ninst✝ : OrderedSub M\ns : Finset ι\nhs : s.Nonempty\nf : ι → M\na : M\n⊢ Eq (HAdd.hAdd a (s.sup' hs f)) (s.sup' hs fun i => HAdd.hAdd a (f i))","decl":"/-- Also see `Finset.add_sup'` that works for ordered groups. -/\nlemma add_sup'' (hs : s.Nonempty) (f : ι → M) (a : M) :\n    a + s.sup' hs f = s.sup' hs fun i ↦ a + f i := by simp_rw [add_comm a, Finset.sup'_add']\n\n"}
{"name":"Finset.sup_add","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : LinearOrderedAddCommMonoid M\ninst✝³ : CanonicallyOrderedAdd M\ninst✝² : Sub M\ninst✝¹ : AddLeftReflectLE M\ninst✝ : OrderedSub M\ns : Finset ι\nhs : s.Nonempty\nf : ι → M\na : M\n⊢ Eq (HAdd.hAdd (s.sup f) a) (s.sup fun i => HAdd.hAdd (f i) a)","decl":"protected lemma sup_add (hs : s.Nonempty) (f : ι → M) (a : M) :\n    s.sup f + a = s.sup fun i ↦ f i + a := by\n  rw [← Finset.sup'_eq_sup hs, ← Finset.sup'_eq_sup hs, sup'_add']\n\n"}
{"name":"Finset.add_sup","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁴ : LinearOrderedAddCommMonoid M\ninst✝³ : CanonicallyOrderedAdd M\ninst✝² : Sub M\ninst✝¹ : AddLeftReflectLE M\ninst✝ : OrderedSub M\ns : Finset ι\nhs : s.Nonempty\nf : ι → M\na : M\n⊢ Eq (HAdd.hAdd a (s.sup f)) (s.sup fun i => HAdd.hAdd a (f i))","decl":"protected lemma add_sup (hs : s.Nonempty) (f : ι → M) (a : M) :\n    a + s.sup f = s.sup fun i ↦ a + f i := by\n  rw [← Finset.sup'_eq_sup hs, ← Finset.sup'_eq_sup hs, add_sup'']\n\n"}
{"name":"Finset.sup_add_sup","module":"Mathlib.Algebra.Order.Group.Finset","initialProofState":"ι : Type u_1\nκ : Type u_2\nM : Type u_3\ninst✝⁴ : LinearOrderedAddCommMonoid M\ninst✝³ : CanonicallyOrderedAdd M\ninst✝² : Sub M\ninst✝¹ : AddLeftReflectLE M\ninst✝ : OrderedSub M\ns : Finset ι\nt : Finset κ\nhs : s.Nonempty\nht : t.Nonempty\nf : ι → M\ng : κ → M\n⊢ Eq (HAdd.hAdd (s.sup f) (t.sup g)) ((SProd.sprod s t).sup fun ij => HAdd.hAdd (f ij.1) (g ij.2))","decl":"lemma sup_add_sup (hs : s.Nonempty) (ht : t.Nonempty) (f : ι → M) (g : κ → M) :\n    s.sup f + t.sup g = (s ×ˢ t).sup fun ij ↦ f ij.1 + g ij.2 := by\n  simp only [Finset.sup_add hs, Finset.add_sup ht, Finset.sup_product_left]\n\n"}
