{"name":"integrableOn_peak_smul_of_integrableOn_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nι : Type u_3\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : TopologicalSpace α\ninst✝² : BorelSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : α → E\nl : Filter ι\nx₀ : α\ns t : Set α\nφ : ι → α → Real\na : E\nhs : MeasurableSet s\nh'st : Membership.mem (nhdsWithin x₀ s) t\nhlφ : ∀ (u : Set α), IsOpen u → Membership.mem u x₀ → TendstoUniformlyOn φ 0 l (SDiff.sdiff s u)\nhiφ : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict t) fun x => φ i x) l (nhds 1)\nh'iφ : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (φ i) (μ.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s μ\nhcg : Filter.Tendsto g (nhdsWithin x₀ s) (nhds a)\n⊢ Filter.Eventually (fun i => MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (φ i x) (g x)) s μ) l","decl":"/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀`, and\n`g` is integrable and has a limit at `x₀`, then `φᵢ • g` is eventually integrable. -/\ntheorem integrableOn_peak_smul_of_integrableOn_of_tendsto\n    (hs : MeasurableSet s) (h'st : t ∈ 𝓝[s] x₀)\n    (hlφ : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\ u))\n    (hiφ : Tendsto (fun i ↦ ∫ x in t, φ i x ∂μ) l (𝓝 1))\n    (h'iφ : ∀ᶠ i in l, AEStronglyMeasurable (φ i) (μ.restrict s))\n    (hmg : IntegrableOn g s μ) (hcg : Tendsto g (𝓝[s] x₀) (𝓝 a)) :\n    ∀ᶠ i in l, IntegrableOn (fun x => φ i x • g x) s μ := by\n  obtain ⟨u, u_open, x₀u, ut, hu⟩ :\n      ∃ u, IsOpen u ∧ x₀ ∈ u ∧ s ∩ u ⊆ t ∧ ∀ x ∈ u ∩ s, g x ∈ ball a 1 := by\n    rcases mem_nhdsWithin.1 (Filter.inter_mem h'st (hcg (ball_mem_nhds _ zero_lt_one)))\n      with ⟨u, u_open, x₀u, hu⟩\n    refine ⟨u, u_open, x₀u, ?_, hu.trans inter_subset_right⟩\n    rw [inter_comm]\n    exact hu.trans inter_subset_left\n  rw [tendsto_iff_norm_sub_tendsto_zero] at hiφ\n  filter_upwards [tendstoUniformlyOn_iff.1 (hlφ u u_open x₀u) 1 zero_lt_one,\n    (tendsto_order.1 hiφ).2 1 zero_lt_one, h'iφ] with i hi h'i h''i\n  have I : IntegrableOn (φ i) t μ := .of_integral_ne_zero (fun h ↦ by simp [h] at h'i)\n  have A : IntegrableOn (fun x => φ i x • g x) (s \\ u) μ := by\n    refine Integrable.smul_of_top_right (hmg.mono diff_subset le_rfl) ?_\n    apply memℒp_top_of_bound (h''i.mono_set diff_subset) 1\n    filter_upwards [self_mem_ae_restrict (hs.diff u_open.measurableSet)] with x hx\n    simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le\n  have B : IntegrableOn (fun x => φ i x • g x) (s ∩ u) μ := by\n    apply Integrable.smul_of_top_left\n    · exact IntegrableOn.mono_set I ut\n    · apply\n        memℒp_top_of_bound (hmg.mono_set inter_subset_left).aestronglyMeasurable (‖a‖ + 1)\n      filter_upwards [self_mem_ae_restrict (hs.inter u_open.measurableSet)] with x hx\n      rw [inter_comm] at hx\n      exact (norm_lt_of_mem_ball (hu x hx)).le\n  convert A.union B\n  simp only [diff_union_inter]\n\n"}
{"name":"tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nι : Type u_3\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : TopologicalSpace α\ninst✝² : BorelSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ng : α → E\nl : Filter ι\nx₀ : α\ns t : Set α\nφ : ι → α → Real\nhs : MeasurableSet s\nht : MeasurableSet t\nhts : HasSubset.Subset t s\nh'ts : Membership.mem (nhdsWithin x₀ s) t\nhnφ : Filter.Eventually (fun i => ∀ (x : α), Membership.mem s x → LE.le 0 (φ i x)) l\nhlφ : ∀ (u : Set α), IsOpen u → Membership.mem u x₀ → TendstoUniformlyOn φ 0 l (SDiff.sdiff s u)\nhiφ : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict t) fun x => φ i x) l (nhds 1)\nh'iφ : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (φ i) (μ.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s μ\nhcg : Filter.Tendsto g (nhdsWithin x₀ s) (nhds 0)\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (φ i x) (g x)) l (nhds 0)","decl":"/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀` and its\nintegral on some finite-measure neighborhood of `x₀` converges to `1`, and `g` is integrable and\nhas a limit `a` at `x₀`, then `∫ φᵢ • g` converges to `a`.\nAuxiliary lemma where one assumes additionally `a = 0`. -/\ntheorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t ⊆ s) (h'ts : t ∈ 𝓝[s] x₀)\n    (hnφ : ∀ᶠ i in l, ∀ x ∈ s, 0 ≤ φ i x)\n    (hlφ : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\ u))\n    (hiφ : Tendsto (fun i ↦ ∫ x in t, φ i x ∂μ) l (𝓝 1))\n    (h'iφ : ∀ᶠ i in l, AEStronglyMeasurable (φ i) (μ.restrict s))\n    (hmg : IntegrableOn g s μ) (hcg : Tendsto g (𝓝[s] x₀) (𝓝 0)) :\n    Tendsto (fun i : ι => ∫ x in s, φ i x • g x ∂μ) l (𝓝 0) := by\n  refine Metric.tendsto_nhds.2 fun ε εpos => ?_\n  obtain ⟨δ, hδ, δpos, δone⟩ : ∃ δ, (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ < ε ∧ 0 < δ ∧ δ < 1 := by\n    have A :\n      Tendsto (fun δ => (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ) (𝓝[>] 0)\n        (𝓝 ((0 * ∫ x in s, ‖g x‖ ∂μ) + 2 * 0)) := by\n      apply Tendsto.mono_left _ nhdsWithin_le_nhds\n      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)\n    rw [zero_mul, zero_add, mul_zero] at A\n    have : Ioo (0 : ℝ) 1 ∈ 𝓝[>] 0 := Ioo_mem_nhdsGT zero_lt_one\n    rcases (((tendsto_order.1 A).2 ε εpos).and this).exists with ⟨δ, hδ, h'δ⟩\n    exact ⟨δ, hδ, h'δ.1, h'δ.2⟩\n  suffices ∀ᶠ i in l, ‖∫ x in s, φ i x • g x ∂μ‖ ≤ (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ by\n    filter_upwards [this] with i hi\n    simp only [dist_zero_right]\n    exact hi.trans_lt hδ\n  obtain ⟨u, u_open, x₀u, ut, hu⟩ :\n      ∃ u, IsOpen u ∧ x₀ ∈ u ∧ s ∩ u ⊆ t ∧ ∀ x ∈ u ∩ s, g x ∈ ball 0 δ := by\n    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ δpos)))\n      with ⟨u, u_open, x₀u, hu⟩\n    refine ⟨u, u_open, x₀u, ?_, hu.trans inter_subset_right⟩\n    rw [inter_comm]\n    exact hu.trans inter_subset_left\n  filter_upwards [tendstoUniformlyOn_iff.1 (hlφ u u_open x₀u) δ δpos,\n    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiφ)).2 δ δpos, hnφ,\n    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlφ hiφ h'iφ hmg hcg]\n    with i hi h'i hφpos h''i\n  have I : IntegrableOn (φ i) t μ := by\n    apply Integrable.of_integral_ne_zero (fun h ↦ ?_)\n    simp [h] at h'i\n    linarith\n  have B : ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ ≤ 2 * δ :=\n    calc\n      ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ ≤ ∫ x in s ∩ u, ‖φ i x • g x‖ ∂μ :=\n        norm_integral_le_integral_norm _\n      _ ≤ ∫ x in s ∩ u, ‖φ i x‖ * δ ∂μ := by\n        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_\n        · exact IntegrableOn.mono_set h''i.norm inter_subset_left\n        · exact IntegrableOn.mono_set (I.norm.mul_const _) ut\n        rw [norm_smul]\n        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n        rw [inter_comm] at hu\n        exact (mem_ball_zero_iff.1 (hu x hx)).le\n      _ ≤ ∫ x in t, ‖φ i x‖ * δ ∂μ := by\n        apply setIntegral_mono_set\n        · exact I.norm.mul_const _\n        · exact Eventually.of_forall fun x => mul_nonneg (norm_nonneg _) δpos.le\n        · exact Eventually.of_forall ut\n      _ = ∫ x in t, φ i x * δ ∂μ := by\n        apply setIntegral_congr_fun ht fun x hx => ?_\n        rw [Real.norm_of_nonneg (hφpos _ (hts hx))]\n      _ = (∫ x in t, φ i x ∂μ) * δ := by rw [integral_mul_right]\n      _ ≤ 2 * δ := by gcongr; linarith [(le_abs_self _).trans h'i.le]\n  have C : ‖∫ x in s \\ u, φ i x • g x ∂μ‖ ≤ δ * ∫ x in s, ‖g x‖ ∂μ :=\n    calc\n      ‖∫ x in s \\ u, φ i x • g x ∂μ‖ ≤ ∫ x in s \\ u, ‖φ i x • g x‖ ∂μ :=\n        norm_integral_le_integral_norm _\n      _ ≤ ∫ x in s \\ u, δ * ‖g x‖ ∂μ := by\n        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_\n        · exact IntegrableOn.mono_set h''i.norm diff_subset\n        · exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset\n        rw [norm_smul]\n        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)\n        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le\n      _ ≤ δ * ∫ x in s, ‖g x‖ ∂μ := by\n        rw [integral_mul_left]\n        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) δpos.le\n        · filter_upwards with x using norm_nonneg _\n        · filter_upwards using diff_subset (s := s) (t := u)\n  calc\n    ‖∫ x in s, φ i x • g x ∂μ‖ =\n      ‖(∫ x in s \\ u, φ i x • g x ∂μ) + ∫ x in s ∩ u, φ i x • g x ∂μ‖ := by\n      conv_lhs => rw [← diff_union_inter s u]\n      rw [setIntegral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)\n          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]\n    _ ≤ ‖∫ x in s \\ u, φ i x • g x ∂μ‖ + ‖∫ x in s ∩ u, φ i x • g x ∂μ‖ := norm_add_le _ _\n    _ ≤ (δ * ∫ x in s, ‖g x‖ ∂μ) + 2 * δ := add_le_add C B\n\n"}
{"name":"tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nι : Type u_3\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : BorelSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ng : α → E\nl : Filter ι\nx₀ : α\ns : Set α\nφ : ι → α → Real\na : E\ninst✝ : CompleteSpace E\nhs : MeasurableSet s\nt : Set α\nht : MeasurableSet t\nhts : HasSubset.Subset t s\nh'ts : Membership.mem (nhdsWithin x₀ s) t\nh't : Ne (μ t) Top.top\nhnφ : Filter.Eventually (fun i => ∀ (x : α), Membership.mem s x → LE.le 0 (φ i x)) l\nhlφ : ∀ (u : Set α), IsOpen u → Membership.mem u x₀ → TendstoUniformlyOn φ 0 l (SDiff.sdiff s u)\nhiφ : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict t) fun x => φ i x) l (nhds 1)\nh'iφ : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (φ i) (μ.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s μ\nhcg : Filter.Tendsto g (nhdsWithin x₀ s) (nhds a)\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (φ i x) (g x)) l (nhds a)","decl":"/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀` and its\nintegral on some finite-measure neighborhood of `x₀` converges to `1`, and `g` is integrable and\nhas a limit `a` at `x₀`, then `∫ φᵢ • g` converges to `a`. Version localized to a subset. -/\ntheorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto\n    (hs : MeasurableSet s) {t : Set α} (ht : MeasurableSet t) (hts : t ⊆ s) (h'ts : t ∈ 𝓝[s] x₀)\n    (h't : μ t ≠ ∞) (hnφ : ∀ᶠ i in l, ∀ x ∈ s, 0 ≤ φ i x)\n    (hlφ : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l (s \\ u))\n    (hiφ : Tendsto (fun i ↦ ∫ x in t, φ i x ∂μ) l (𝓝 1))\n    (h'iφ : ∀ᶠ i in l, AEStronglyMeasurable (φ i) (μ.restrict s))\n    (hmg : IntegrableOn g s μ) (hcg : Tendsto g (𝓝[s] x₀) (𝓝 a)) :\n    Tendsto (fun i : ι ↦ ∫ x in s, φ i x • g x ∂μ) l (𝓝 a) := by\n  let h := g - t.indicator (fun _ ↦ a)\n  have A : Tendsto (fun i : ι => (∫ x in s, φ i x • h x ∂μ) + (∫ x in t, φ i x ∂μ) • a) l\n      (𝓝 (0 + (1 : ℝ) • a)) := by\n    refine Tendsto.add ?_ (Tendsto.smul hiφ tendsto_const_nhds)\n    apply tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux hs ht hts h'ts\n        hnφ hlφ hiφ h'iφ\n    · apply hmg.sub\n      simp only [integrable_indicator_iff ht, integrableOn_const, ht, Measure.restrict_apply]\n      right\n      exact lt_of_le_of_lt (measure_mono inter_subset_left) (h't.lt_top)\n    · rw [← sub_self a]\n      apply Tendsto.sub hcg\n      apply tendsto_const_nhds.congr'\n      filter_upwards [h'ts] with x hx using by simp [hx]\n  simp only [one_smul, zero_add] at A\n  refine Tendsto.congr' ?_ A\n  filter_upwards [integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts\n    hlφ hiφ h'iφ hmg hcg,\n    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiφ)).2 1 zero_lt_one] with i hi h'i\n  simp only [h, Pi.sub_apply, smul_sub, ← indicator_smul_apply]\n  rw [integral_sub hi, setIntegral_indicator ht, inter_eq_right.mpr hts,\n    integral_smul_const, sub_add_cancel]\n  rw [integrable_indicator_iff ht]\n  apply Integrable.smul_const\n  rw [restrict_restrict ht, inter_eq_left.mpr hts]\n  exact .of_integral_ne_zero (fun h ↦ by simp [h] at h'i)\n\n"}
{"name":"tendsto_integral_peak_smul_of_integrable_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nι : Type u_3\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : BorelSpace α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ng : α → E\nl : Filter ι\nx₀ : α\nφ : ι → α → Real\na : E\ninst✝ : CompleteSpace E\nt : Set α\nht : MeasurableSet t\nh'ts : Membership.mem (nhds x₀) t\nh't : Ne (μ t) Top.top\nhnφ : Filter.Eventually (fun i => ∀ (x : α), LE.le 0 (φ i x)) l\nhlφ : ∀ (u : Set α), IsOpen u → Membership.mem u x₀ → TendstoUniformlyOn φ 0 l (HasCompl.compl u)\nhiφ : Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict t) fun x => φ i x) l (nhds 1)\nh'iφ : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (φ i) μ) l\nhmg : MeasureTheory.Integrable g μ\nhcg : Filter.Tendsto g (nhds x₀) (nhds a)\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral μ fun x => HSMul.hSMul (φ i x) (g x)) l (nhds a)","decl":"/-- If a sequence of peak functions `φᵢ` converges uniformly to zero away from a point `x₀` and its\nintegral on some finite-measure neighborhood of `x₀` converges to `1`, and `g` is integrable and\nhas a limit `a` at `x₀`, then `∫ φᵢ • g` converges to `a`. -/\ntheorem tendsto_integral_peak_smul_of_integrable_of_tendsto\n    {t : Set α} (ht : MeasurableSet t) (h'ts : t ∈ 𝓝 x₀)\n    (h't : μ t ≠ ∞) (hnφ : ∀ᶠ i in l, ∀ x, 0 ≤ φ i x)\n    (hlφ : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 l uᶜ)\n    (hiφ : Tendsto (fun i ↦ ∫ x in t, φ i x ∂μ) l (𝓝 1))\n    (h'iφ : ∀ᶠ i in l, AEStronglyMeasurable (φ i) μ)\n    (hmg : Integrable g μ) (hcg : Tendsto g (𝓝 x₀) (𝓝 a)) :\n    Tendsto (fun i : ι ↦ ∫ x, φ i x • g x ∂μ) l (𝓝 a) := by\n  suffices Tendsto (fun i : ι ↦ ∫ x in univ, φ i x • g x ∂μ) l (𝓝 a) by simpa\n  exact tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto MeasurableSet.univ ht (x₀ := x₀)\n    (subset_univ _) (by simpa [nhdsWithin_univ]) h't (by simpa)\n    (by simpa [← compl_eq_univ_diff] using hlφ) hiφ\n    (by simpa) (by simpa) (by simpa [nhdsWithin_univ])\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : BorelSpace α\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ng : α → E\nx₀ : α\ns : Set α\ninst✝² : CompleteSpace E\ninst✝¹ : TopologicalSpace.MetrizableSpace α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nhs : IsCompact s\nhμ : ∀ (u : Set α), IsOpen u → Membership.mem u x₀ → LT.lt 0 (μ (Inter.inter u s))\nc : α → Real\nhc : ContinuousOn c s\nh'c : ∀ (y : α), Membership.mem s y → Ne y x₀ → LT.lt (c y) (c x₀)\nhnc : ∀ (x : α), Membership.mem s x → LE.le 0 (c x)\nhnc₀ : LT.lt 0 (c x₀)\nh₀ : Membership.mem s x₀\nhmg : MeasureTheory.IntegrableOn g s μ\nhcg : ContinuousWithinAt g s x₀\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (μ.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g x₀))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `x₀` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / ∫ (c x) ^ n` is a sequence of peak functions\nconcentrating around `x₀`. Therefore, `∫ (c x) ^ n * g / ∫ (c x) ^ n` converges to `g x₀` if `g` is\nintegrable on `s` and continuous at `x₀`.\n\nVersion assuming that `μ` gives positive mass to all neighborhoods of `x₀` within `s`.\nFor a less precise but more usable version, see\n`tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn`.\n -/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos\n    [MetrizableSpace α] [IsLocallyFiniteMeasure μ] (hs : IsCompact s)\n    (hμ : ∀ u, IsOpen u → x₀ ∈ u → 0 < μ (u ∩ s)) {c : α → ℝ} (hc : ContinuousOn c s)\n    (h'c : ∀ y ∈ s, y ≠ x₀ → c y < c x₀) (hnc : ∀ x ∈ s, 0 ≤ c x) (hnc₀ : 0 < c x₀) (h₀ : x₀ ∈ s)\n    (hmg : IntegrableOn g s μ) (hcg : ContinuousWithinAt g s x₀) :\n    Tendsto (fun n : ℕ => (∫ x in s, c x ^ n ∂μ)⁻¹ • ∫ x in s, c x ^ n • g x ∂μ)\n      atTop (𝓝 (g x₀)) := by\n  /- We apply the general result\n    `tendsto_setIntegral_peak_smul_of_integrableOn_of_continuousWithinAt` to the sequence of\n    peak functions `φₙ = (c x) ^ n / ∫ (c x) ^ n`. The only nontrivial bit is to check that this\n    sequence converges uniformly to zero on any set `s \\ u` away from `x₀`. By compactness, the\n    function `c` is bounded by `t < c x₀` there. Consider `t' ∈ (t, c x₀)`, and a neighborhood `v`\n    of `x₀` where `c x ≥ t'`, by continuity. Then `∫ (c x) ^ n` is bounded below by `t' ^ n μ v`.\n    It follows that, on `s \\ u`, then `φₙ x ≤ t ^ n / (t' ^ n μ v)`,\n    which tends (exponentially fast) to zero with `n`. -/\n  let φ : ℕ → α → ℝ := fun n x => (∫ x in s, c x ^ n ∂μ)⁻¹ * c x ^ n\n  have hnφ : ∀ n, ∀ x ∈ s, 0 ≤ φ n x := by\n    intro n x hx\n    apply mul_nonneg (inv_nonneg.2 _) (pow_nonneg (hnc x hx) _)\n    exact setIntegral_nonneg hs.measurableSet fun x hx => pow_nonneg (hnc x hx) _\n  have I : ∀ n, IntegrableOn (fun x => c x ^ n) s μ := fun n =>\n    ContinuousOn.integrableOn_compact hs (hc.pow n)\n  have J : ∀ n, 0 ≤ᵐ[μ.restrict s] fun x : α => c x ^ n := by\n    intro n\n    filter_upwards [ae_restrict_mem hs.measurableSet] with x hx\n    exact pow_nonneg (hnc x hx) n\n  have P : ∀ n, (0 : ℝ) < ∫ x in s, c x ^ n ∂μ := by\n    intro n\n    refine (setIntegral_pos_iff_support_of_nonneg_ae (J n) (I n)).2 ?_\n    obtain ⟨u, u_open, x₀_u, hu⟩ : ∃ u : Set α, IsOpen u ∧ x₀ ∈ u ∧ u ∩ s ⊆ c ⁻¹' Ioi 0 :=\n      _root_.continuousOn_iff.1 hc x₀ h₀ (Ioi (0 : ℝ)) isOpen_Ioi hnc₀\n    apply (hμ u u_open x₀_u).trans_le\n    exact measure_mono fun x hx => ⟨ne_of_gt (pow_pos (a := c x) (hu hx) _), hx.2⟩\n  have hiφ : ∀ n, ∫ x in s, φ n x ∂μ = 1 := fun n => by\n    rw [integral_mul_left, inv_mul_cancel₀ (P n).ne']\n  have A : ∀ u : Set α, IsOpen u → x₀ ∈ u → TendstoUniformlyOn φ 0 atTop (s \\ u) := by\n    intro u u_open x₀u\n    obtain ⟨t, t_pos, tx₀, ht⟩ : ∃ t, 0 ≤ t ∧ t < c x₀ ∧ ∀ x ∈ s \\ u, c x ≤ t := by\n      rcases eq_empty_or_nonempty (s \\ u) with (h | h)\n      · exact\n          ⟨0, le_rfl, hnc₀, by simp only [h, mem_empty_iff_false, IsEmpty.forall_iff, imp_true_iff]⟩\n      obtain ⟨x, hx, h'x⟩ : ∃ x ∈ s \\ u, ∀ y ∈ s \\ u, c y ≤ c x :=\n        IsCompact.exists_isMaxOn (hs.diff u_open) h (hc.mono diff_subset)\n      refine ⟨c x, hnc x hx.1, h'c x hx.1 ?_, h'x⟩\n      rintro rfl\n      exact hx.2 x₀u\n    obtain ⟨t', tt', t'x₀⟩ : ∃ t', t < t' ∧ t' < c x₀ := exists_between tx₀\n    have t'_pos : 0 < t' := t_pos.trans_lt tt'\n    obtain ⟨v, v_open, x₀_v, hv⟩ : ∃ v : Set α, IsOpen v ∧ x₀ ∈ v ∧ v ∩ s ⊆ c ⁻¹' Ioi t' :=\n      _root_.continuousOn_iff.1 hc x₀ h₀ (Ioi t') isOpen_Ioi t'x₀\n    have M : ∀ n, ∀ x ∈ s \\ u, φ n x ≤ (μ (v ∩ s)).toReal⁻¹ * (t / t') ^ n := by\n      intro n x hx\n      have B : t' ^ n * (μ (v ∩ s)).toReal ≤ ∫ y in s, c y ^ n ∂μ :=\n        calc\n          t' ^ n * (μ (v ∩ s)).toReal = ∫ _ in v ∩ s, t' ^ n ∂μ := by\n            simp only [integral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter,\n              Algebra.id.smul_eq_mul, mul_comm]\n          _ ≤ ∫ y in v ∩ s, c y ^ n ∂μ := by\n            apply setIntegral_mono_on _ _ (v_open.measurableSet.inter hs.measurableSet) _\n            · apply integrableOn_const.2 (Or.inr _)\n              exact lt_of_le_of_lt (measure_mono inter_subset_right) hs.measure_lt_top\n            · exact (I n).mono inter_subset_right le_rfl\n            · intro x hx\n              exact pow_le_pow_left₀ t'_pos.le (hv hx).le _\n          _ ≤ ∫ y in s, c y ^ n ∂μ :=\n            setIntegral_mono_set (I n) (J n) (Eventually.of_forall inter_subset_right)\n      simp_rw [φ, ← div_eq_inv_mul, div_pow, div_div]\n      have := ENNReal.toReal_pos (hμ v v_open x₀_v).ne'\n        ((measure_mono inter_subset_right).trans_lt hs.measure_lt_top).ne\n      gcongr\n      · exact hnc _ hx.1\n      · exact ht x hx\n    have N :\n      Tendsto (fun n => (μ (v ∩ s)).toReal⁻¹ * (t / t') ^ n) atTop\n        (𝓝 ((μ (v ∩ s)).toReal⁻¹ * 0)) := by\n      apply Tendsto.mul tendsto_const_nhds _\n      apply tendsto_pow_atTop_nhds_zero_of_lt_one (div_nonneg t_pos t'_pos.le)\n      exact (div_lt_one t'_pos).2 tt'\n    rw [mul_zero] at N\n    refine tendstoUniformlyOn_iff.2 fun ε εpos => ?_\n    filter_upwards [(tendsto_order.1 N).2 ε εpos] with n hn x hx\n    simp only [Pi.zero_apply, dist_zero_left, Real.norm_of_nonneg (hnφ n x hx.1)]\n    exact (M n x hx).trans_lt hn\n  have : Tendsto (fun i : ℕ => ∫ x : α in s, φ i x • g x ∂μ) atTop (𝓝 (g x₀)) := by\n    have B : Tendsto (fun i ↦ ∫ (x : α) in s, φ i x ∂μ) atTop (𝓝 1) :=\n      tendsto_const_nhds.congr (fun n ↦ (hiφ n).symm)\n    have C : ∀ᶠ (i : ℕ) in atTop, AEStronglyMeasurable (fun x ↦ φ i x) (μ.restrict s) := by\n      apply Eventually.of_forall (fun n ↦ ((I n).const_mul _).aestronglyMeasurable)\n    exact tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto hs.measurableSet\n      hs.measurableSet (Subset.rfl) (self_mem_nhdsWithin)\n      hs.measure_lt_top.ne (Eventually.of_forall hnφ) A B C hmg hcg\n  convert this\n  simp_rw [φ, ← smul_smul, integral_smul]\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ng : α → E\nx₀ : α\ns : Set α\ninst✝³ : CompleteSpace E\ninst✝² : TopologicalSpace.MetrizableSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝ : μ.IsOpenPosMeasure\nhs : IsCompact s\nc : α → Real\nhc : ContinuousOn c s\nh'c : ∀ (y : α), Membership.mem s y → Ne y x₀ → LT.lt (c y) (c x₀)\nhnc : ∀ (x : α), Membership.mem s x → LE.le 0 (c x)\nhnc₀ : LT.lt 0 (c x₀)\nh₀ : Membership.mem (closure (interior s)) x₀\nhmg : MeasureTheory.IntegrableOn g s μ\nhcg : ContinuousWithinAt g s x₀\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (μ.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g x₀))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `x₀` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / ∫ (c x) ^ n` is a sequence of peak functions\nconcentrating around `x₀`. Therefore, `∫ (c x) ^ n * g / ∫ (c x) ^ n` converges to `g x₀` if `g` is\nintegrable on `s` and continuous at `x₀`.\n\nVersion assuming that `μ` gives positive mass to all open sets.\nFor a less precise but more usable version, see\n`tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn`.\n-/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn\n    [MetrizableSpace α] [IsLocallyFiniteMeasure μ] [IsOpenPosMeasure μ] (hs : IsCompact s)\n    {c : α → ℝ} (hc : ContinuousOn c s) (h'c : ∀ y ∈ s, y ≠ x₀ → c y < c x₀)\n    (hnc : ∀ x ∈ s, 0 ≤ c x) (hnc₀ : 0 < c x₀) (h₀ : x₀ ∈ closure (interior s))\n    (hmg : IntegrableOn g s μ) (hcg : ContinuousWithinAt g s x₀) :\n    Tendsto (fun n : ℕ => (∫ x in s, c x ^ n ∂μ)⁻¹ • ∫ x in s, c x ^ n • g x ∂μ) atTop\n      (𝓝 (g x₀)) := by\n  have : x₀ ∈ s := by rw [← hs.isClosed.closure_eq]; exact closure_mono interior_subset h₀\n  apply\n    tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos hs _ hc\n      h'c hnc hnc₀ this hmg hcg\n  intro u u_open x₀_u\n  calc\n    0 < μ (u ∩ interior s) :=\n      (u_open.inter isOpen_interior).measure_pos μ (_root_.mem_closure_iff.1 h₀ u u_open x₀_u)\n    _ ≤ μ (u ∩ s) := by gcongr; apply interior_subset\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"α : Type u_1\nE : Type u_2\nhm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : BorelSpace α\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ng : α → E\nx₀ : α\ns : Set α\ninst✝³ : CompleteSpace E\ninst✝² : TopologicalSpace.MetrizableSpace α\ninst✝¹ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝ : μ.IsOpenPosMeasure\nhs : IsCompact s\nc : α → Real\nhc : ContinuousOn c s\nh'c : ∀ (y : α), Membership.mem s y → Ne y x₀ → LT.lt (c y) (c x₀)\nhnc : ∀ (x : α), Membership.mem s x → LE.le 0 (c x)\nhnc₀ : LT.lt 0 (c x₀)\nh₀ : Membership.mem (closure (interior s)) x₀\nhmg : ContinuousOn g s\n⊢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (μ.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g x₀))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `x₀` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / ∫ (c x) ^ n` is a sequence of peak functions\nconcentrating around `x₀`. Therefore, `∫ (c x) ^ n * g / ∫ (c x) ^ n` converges to `g x₀` if `g` is\ncontinuous on `s`. -/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn\n    [MetrizableSpace α] [IsLocallyFiniteMeasure μ] [IsOpenPosMeasure μ] (hs : IsCompact s)\n    {c : α → ℝ} (hc : ContinuousOn c s) (h'c : ∀ y ∈ s, y ≠ x₀ → c y < c x₀)\n    (hnc : ∀ x ∈ s, 0 ≤ c x) (hnc₀ : 0 < c x₀) (h₀ : x₀ ∈ closure (interior s))\n    (hmg : ContinuousOn g s) :\n    Tendsto (fun n : ℕ => (∫ x in s, c x ^ n ∂μ)⁻¹ • ∫ x in s, c x ^ n • g x ∂μ) atTop (𝓝 (g x₀)) :=\n  haveI : x₀ ∈ s := by rw [← hs.isClosed.closure_eq]; exact closure_mono interior_subset h₀\n  tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn hs hc h'c hnc hnc₀ h₀\n    (hmg.integrableOn_compact hs) (hmg x₀ this)\n\n"}
{"name":"tendsto_integral_comp_smul_smul_of_integrable","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"E : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : CompleteSpace E\nF : Type u_4\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace Real F\ninst✝³ : FiniteDimensional Real F\ninst✝² : MeasurableSpace F\ninst✝¹ : BorelSpace F\nμ : MeasureTheory.Measure F\ninst✝ : μ.IsAddHaarMeasure\nφ : F → Real\nhφ : ∀ (x : F), LE.le 0 (φ x)\nh'φ : Eq (MeasureTheory.integral μ fun x => φ x) 1\nh : Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (Norm.norm x) (Module.finrank Real F)) (φ x)) (Bornology.cobounded F) (nhds 0)\ng : F → E\nhg : MeasureTheory.Integrable g μ\nh'g : ContinuousAt g 0\n⊢ Filter.Tendsto (fun c => MeasureTheory.integral μ fun x => HSMul.hSMul (HMul.hMul (HPow.hPow c (Module.finrank Real F)) (φ (HSMul.hSMul c x))) (g x)) Filter.atTop (nhds (g 0))","decl":"/-- Consider a nonnegative function `φ` with integral one, decaying quickly enough at infinity.\nThen suitable renormalizations of `φ` form a sequence of peak functions around the origin:\n`∫ (c ^ d * φ (c • x)) • g x` converges to `g 0` as `c → ∞` if `g` is continuous at `0`\nand integrable. -/\ntheorem tendsto_integral_comp_smul_smul_of_integrable\n    {φ : F → ℝ} (hφ : ∀ x, 0 ≤ φ x) (h'φ : ∫ x, φ x ∂μ = 1)\n    (h : Tendsto (fun x ↦ ‖x‖ ^ finrank ℝ F * φ x) (cobounded F) (𝓝 0))\n    {g : F → E} (hg : Integrable g μ) (h'g : ContinuousAt g 0) :\n    Tendsto (fun (c : ℝ) ↦ ∫ x, (c ^ (finrank ℝ F) * φ (c • x)) • g x ∂μ) atTop (𝓝 (g 0)) := by\n  have I : Integrable φ μ := integrable_of_integral_eq_one h'φ\n  apply tendsto_integral_peak_smul_of_integrable_of_tendsto (t := closedBall 0 1) (x₀ := 0)\n  · exact isClosed_ball.measurableSet\n  · exact closedBall_mem_nhds _ zero_lt_one\n  · exact (isCompact_closedBall 0 1).measure_ne_top\n  · filter_upwards [Ici_mem_atTop 0] with c (hc : 0 ≤ c) x using mul_nonneg (by positivity) (hφ _)\n  · intro u u_open hu\n    apply tendstoUniformlyOn_iff.2 (fun ε εpos ↦ ?_)\n    obtain ⟨δ, δpos, h'u⟩ : ∃ δ > 0, ball 0 δ ⊆ u := Metric.isOpen_iff.1 u_open _ hu\n    obtain ⟨M, Mpos, hM⟩ : ∃ M > 0, ∀ ⦃x : F⦄, x ∈ (closedBall 0 M)ᶜ →\n        ‖x‖ ^ finrank ℝ F * φ x < δ ^ finrank ℝ F * ε := by\n      rcases (hasBasis_cobounded_compl_closedBall (0 : F)).eventually_iff.1\n        ((tendsto_order.1 h).2 (δ ^ finrank ℝ F * ε) (by positivity)) with ⟨M, -, hM⟩\n      refine ⟨max M 1, zero_lt_one.trans_le (le_max_right _ _), fun x hx ↦ hM ?_⟩\n      simp only [mem_compl_iff, mem_closedBall, dist_zero_right, le_max_iff, not_or, not_le] at hx\n      simpa using hx.1\n    filter_upwards [Ioi_mem_atTop (M / δ)] with c (hc : M / δ < c) x hx\n    have cpos : 0 < c := lt_trans (by positivity) hc\n    suffices c ^ finrank ℝ F * φ (c • x) < ε by simpa [abs_of_nonneg (hφ _), abs_of_nonneg cpos.le]\n    have hδx : δ ≤ ‖x‖ := by\n      have : x ∈ (ball 0 δ)ᶜ := fun h ↦ hx (h'u h)\n      simpa only [mem_compl_iff, mem_ball, dist_zero_right, not_lt]\n    suffices δ ^ finrank ℝ F * (c ^ finrank ℝ F * φ (c • x)) < δ ^ finrank ℝ F * ε by\n      rwa [mul_lt_mul_iff_of_pos_left (by positivity)] at this\n    calc\n      δ ^ finrank ℝ F * (c ^ finrank ℝ F * φ (c • x))\n      _ ≤ ‖x‖ ^ finrank ℝ F * (c ^ finrank ℝ F * φ (c • x)) := by\n        gcongr; exact mul_nonneg (by positivity) (hφ _)\n      _ = ‖c • x‖ ^ finrank ℝ F * φ (c • x) := by\n        simp [norm_smul, abs_of_pos cpos, mul_pow]; ring\n      _ < δ ^ finrank ℝ F * ε := by\n        apply hM\n        rw [div_lt_iff₀ δpos] at hc\n        simp only [mem_compl_iff, mem_closedBall, dist_zero_right, norm_smul, Real.norm_eq_abs,\n          abs_of_nonneg cpos.le, not_le, gt_iff_lt]\n        exact hc.trans_le (by gcongr)\n  · have : Tendsto (fun c ↦ ∫ (x : F) in closedBall 0 c, φ x ∂μ) atTop (𝓝 1) := by\n      rw [← h'φ]\n      exact (aecover_closedBall tendsto_id).integral_tendsto_of_countably_generated I\n    apply this.congr'\n    filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    rw [integral_mul_left, setIntegral_comp_smul_of_pos _ _ _ hc, smul_eq_mul, ← mul_assoc,\n      mul_inv_cancel₀ (by positivity), _root_.smul_closedBall _ _ zero_le_one]\n    simp [abs_of_nonneg hc.le]\n  · filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    exact (I.comp_smul hc.ne').aestronglyMeasurable.const_mul _\n  · exact hg\n  · exact h'g\n\n"}
{"name":"tendsto_integral_comp_smul_smul_of_integrable'","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"E : Type u_2\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : CompleteSpace E\nF : Type u_4\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace Real F\ninst✝³ : FiniteDimensional Real F\ninst✝² : MeasurableSpace F\ninst✝¹ : BorelSpace F\nμ : MeasureTheory.Measure F\ninst✝ : μ.IsAddHaarMeasure\nφ : F → Real\nhφ : ∀ (x : F), LE.le 0 (φ x)\nh'φ : Eq (MeasureTheory.integral μ fun x => φ x) 1\nh : Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (Norm.norm x) (Module.finrank Real F)) (φ x)) (Bornology.cobounded F) (nhds 0)\ng : F → E\nx₀ : F\nhg : MeasureTheory.Integrable g μ\nh'g : ContinuousAt g x₀\n⊢ Filter.Tendsto (fun c => MeasureTheory.integral μ fun x => HSMul.hSMul (HMul.hMul (HPow.hPow c (Module.finrank Real F)) (φ (HSMul.hSMul c (HSub.hSub x₀ x)))) (g x)) Filter.atTop (nhds (g x₀))","decl":"/-- Consider a nonnegative function `φ` with integral one, decaying quickly enough at infinity.\nThen suitable renormalizations of `φ` form a sequence of peak functions around any point:\n`∫ (c ^ d * φ (c • (x₀ - x)) • g x` converges to `g x₀` as `c → ∞` if `g` is continuous at `x₀`\nand integrable. -/\ntheorem tendsto_integral_comp_smul_smul_of_integrable'\n    {φ : F → ℝ} (hφ : ∀ x, 0 ≤ φ x) (h'φ : ∫ x, φ x ∂μ = 1)\n    (h : Tendsto (fun x ↦ ‖x‖ ^ finrank ℝ F * φ x) (cobounded F) (𝓝 0))\n    {g : F → E} {x₀ : F} (hg : Integrable g μ) (h'g : ContinuousAt g x₀) :\n    Tendsto (fun (c : ℝ) ↦ ∫ x, (c ^ (finrank ℝ F) * φ (c • (x₀ - x))) • g x ∂μ)\n      atTop (𝓝 (g x₀)) := by\n  let f := fun x ↦ g (x₀ - x)\n  have If : Integrable f μ := by simpa [f, sub_eq_add_neg] using (hg.comp_add_left x₀).comp_neg\n  have : Tendsto (fun (c : ℝ) ↦ ∫ x, (c ^ (finrank ℝ F) * φ (c • x)) • f x ∂μ)\n      atTop (𝓝 (f 0)) := by\n    apply tendsto_integral_comp_smul_smul_of_integrable hφ h'φ h If\n    have A : ContinuousAt g (x₀ - 0) := by simpa using h'g\n    exact A.comp <| by fun_prop\n  simp only [f, sub_zero] at this\n  convert this using 2 with c\n  conv_rhs => rw [← integral_add_left_eq_self x₀ (μ := μ)\n    (f := fun x ↦ (c ^ finrank ℝ F * φ (c • x)) • g (x₀ - x)), ← integral_neg_eq_self]\n  simp [smul_sub, sub_eq_add_neg]\n"}
