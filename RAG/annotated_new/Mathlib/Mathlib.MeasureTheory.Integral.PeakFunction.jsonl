{"name":"integrableOn_peak_smul_of_integrableOn_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nÎ¹ : Type u_3\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Î± â†’ E\nl : Filter Î¹\nxâ‚€ : Î±\ns t : Set Î±\nÏ† : Î¹ â†’ Î± â†’ Real\na : E\nhs : MeasurableSet s\nh'st : Membership.mem (nhdsWithin xâ‚€ s) t\nhlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ Membership.mem u xâ‚€ â†’ TendstoUniformlyOn Ï† 0 l (SDiff.sdiff s u)\nhiÏ† : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict t) fun x => Ï† i x) l (nhds 1)\nh'iÏ† : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (Ï† i) (Î¼.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s Î¼\nhcg : Filter.Tendsto g (nhdsWithin xâ‚€ s) (nhds a)\nâŠ¢ Filter.Eventually (fun i => MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (Ï† i x) (g x)) s Î¼) l","decl":"/-- If a sequence of peak functions `Ï†áµ¢` converges uniformly to zero away from a point `xâ‚€`, and\n`g` is integrable and has a limit at `xâ‚€`, then `Ï†áµ¢ â€¢ g` is eventually integrable. -/\ntheorem integrableOn_peak_smul_of_integrableOn_of_tendsto\n    (hs : MeasurableSet s) (h'st : t âˆˆ ğ“[s] xâ‚€)\n    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \\ u))\n    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))\n    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s))\n    (hmg : IntegrableOn g s Î¼) (hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ a)) :\n    âˆ€á¶  i in l, IntegrableOn (fun x => Ï† i x â€¢ g x) s Î¼ := by\n  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :\n      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball a 1 := by\n    rcases mem_nhdsWithin.1 (Filter.inter_mem h'st (hcg (ball_mem_nhds _ zero_lt_one)))\n      with âŸ¨u, u_open, xâ‚€u, huâŸ©\n    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans inter_subset_rightâŸ©\n    rw [inter_comm]\n    exact hu.trans inter_subset_left\n  rw [tendsto_iff_norm_sub_tendsto_zero] at hiÏ†\n  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) 1 zero_lt_one,\n    (tendsto_order.1 hiÏ†).2 1 zero_lt_one, h'iÏ†] with i hi h'i h''i\n  have I : IntegrableOn (Ï† i) t Î¼ := .of_integral_ne_zero (fun h â†¦ by simp [h] at h'i)\n  have A : IntegrableOn (fun x => Ï† i x â€¢ g x) (s \\ u) Î¼ := by\n    refine Integrable.smul_of_top_right (hmg.mono diff_subset le_rfl) ?_\n    apply memâ„’p_top_of_bound (h''i.mono_set diff_subset) 1\n    filter_upwards [self_mem_ae_restrict (hs.diff u_open.measurableSet)] with x hx\n    simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le\n  have B : IntegrableOn (fun x => Ï† i x â€¢ g x) (s âˆ© u) Î¼ := by\n    apply Integrable.smul_of_top_left\n    Â· exact IntegrableOn.mono_set I ut\n    Â· apply\n        memâ„’p_top_of_bound (hmg.mono_set inter_subset_left).aestronglyMeasurable (â€–aâ€– + 1)\n      filter_upwards [self_mem_ae_restrict (hs.inter u_open.measurableSet)] with x hx\n      rw [inter_comm] at hx\n      exact (norm_lt_of_mem_ball (hu x hx)).le\n  convert A.union B\n  simp only [diff_union_inter]\n\n"}
{"name":"tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nÎ¹ : Type u_3\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ng : Î± â†’ E\nl : Filter Î¹\nxâ‚€ : Î±\ns t : Set Î±\nÏ† : Î¹ â†’ Î± â†’ Real\nhs : MeasurableSet s\nht : MeasurableSet t\nhts : HasSubset.Subset t s\nh'ts : Membership.mem (nhdsWithin xâ‚€ s) t\nhnÏ† : Filter.Eventually (fun i => âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 0 (Ï† i x)) l\nhlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ Membership.mem u xâ‚€ â†’ TendstoUniformlyOn Ï† 0 l (SDiff.sdiff s u)\nhiÏ† : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict t) fun x => Ï† i x) l (nhds 1)\nh'iÏ† : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (Ï† i) (Î¼.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s Î¼\nhcg : Filter.Tendsto g (nhdsWithin xâ‚€ s) (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (Ï† i x) (g x)) l (nhds 0)","decl":"/-- If a sequence of peak functions `Ï†áµ¢` converges uniformly to zero away from a point `xâ‚€` and its\nintegral on some finite-measure neighborhood of `xâ‚€` converges to `1`, and `g` is integrable and\nhas a limit `a` at `xâ‚€`, then `âˆ« Ï†áµ¢ â€¢ g` converges to `a`.\nAuxiliary lemma where one assumes additionally `a = 0`. -/\ntheorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux\n    (hs : MeasurableSet s) (ht : MeasurableSet t) (hts : t âŠ† s) (h'ts : t âˆˆ ğ“[s] xâ‚€)\n    (hnÏ† : âˆ€á¶  i in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x)\n    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \\ u))\n    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))\n    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s))\n    (hmg : IntegrableOn g s Î¼) (hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ 0)) :\n    Tendsto (fun i : Î¹ => âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼) l (ğ“ 0) := by\n  refine Metric.tendsto_nhds.2 fun Îµ Îµpos => ?_\n  obtain âŸ¨Î´, hÎ´, Î´pos, Î´oneâŸ© : âˆƒ Î´, (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ < Îµ âˆ§ 0 < Î´ âˆ§ Î´ < 1 := by\n    have A :\n      Tendsto (fun Î´ => (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´) (ğ“[>] 0)\n        (ğ“ ((0 * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * 0)) := by\n      apply Tendsto.mono_left _ nhdsWithin_le_nhds\n      exact (tendsto_id.mul tendsto_const_nhds).add (tendsto_id.const_mul _)\n    rw [zero_mul, zero_add, mul_zero] at A\n    have : Ioo (0 : â„) 1 âˆˆ ğ“[>] 0 := Ioo_mem_nhdsGT zero_lt_one\n    rcases (((tendsto_order.1 A).2 Îµ Îµpos).and this).exists with âŸ¨Î´, hÎ´, h'Î´âŸ©\n    exact âŸ¨Î´, hÎ´, h'Î´.1, h'Î´.2âŸ©\n  suffices âˆ€á¶  i in l, â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ by\n    filter_upwards [this] with i hi\n    simp only [dist_zero_right]\n    exact hi.trans_lt hÎ´\n  obtain âŸ¨u, u_open, xâ‚€u, ut, huâŸ© :\n      âˆƒ u, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ s âˆ© u âŠ† t âˆ§ âˆ€ x âˆˆ u âˆ© s, g x âˆˆ ball 0 Î´ := by\n    rcases mem_nhdsWithin.1 (Filter.inter_mem h'ts (hcg (ball_mem_nhds _ Î´pos)))\n      with âŸ¨u, u_open, xâ‚€u, huâŸ©\n    refine âŸ¨u, u_open, xâ‚€u, ?_, hu.trans inter_subset_rightâŸ©\n    rw [inter_comm]\n    exact hu.trans inter_subset_left\n  filter_upwards [tendstoUniformlyOn_iff.1 (hlÏ† u u_open xâ‚€u) Î´ Î´pos,\n    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiÏ†)).2 Î´ Î´pos, hnÏ†,\n    integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts hlÏ† hiÏ† h'iÏ† hmg hcg]\n    with i hi h'i hÏ†pos h''i\n  have I : IntegrableOn (Ï† i) t Î¼ := by\n    apply Integrable.of_integral_ne_zero (fun h â†¦ ?_)\n    simp [h] at h'i\n    linarith\n  have B : â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ 2 * Î´ :=\n    calc\n      â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s âˆ© u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=\n        norm_integral_le_integral_norm _\n      _ â‰¤ âˆ« x in s âˆ© u, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by\n        refine setIntegral_mono_on ?_ ?_ (hs.inter u_open.measurableSet) fun x hx => ?_\n        Â· exact IntegrableOn.mono_set h''i.norm inter_subset_left\n        Â· exact IntegrableOn.mono_set (I.norm.mul_const _) ut\n        rw [norm_smul]\n        apply mul_le_mul_of_nonneg_left _ (norm_nonneg _)\n        rw [inter_comm] at hu\n        exact (mem_ball_zero_iff.1 (hu x hx)).le\n      _ â‰¤ âˆ« x in t, â€–Ï† i xâ€– * Î´ âˆ‚Î¼ := by\n        apply setIntegral_mono_set\n        Â· exact I.norm.mul_const _\n        Â· exact Eventually.of_forall fun x => mul_nonneg (norm_nonneg _) Î´pos.le\n        Â· exact Eventually.of_forall ut\n      _ = âˆ« x in t, Ï† i x * Î´ âˆ‚Î¼ := by\n        apply setIntegral_congr_fun ht fun x hx => ?_\n        rw [Real.norm_of_nonneg (hÏ†pos _ (hts hx))]\n      _ = (âˆ« x in t, Ï† i x âˆ‚Î¼) * Î´ := by rw [integral_mul_right]\n      _ â‰¤ 2 * Î´ := by gcongr; linarith [(le_abs_self _).trans h'i.le]\n  have C : â€–âˆ« x in s \\ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ :=\n    calc\n      â€–âˆ« x in s \\ u, Ï† i x â€¢ g x âˆ‚Î¼â€– â‰¤ âˆ« x in s \\ u, â€–Ï† i x â€¢ g xâ€– âˆ‚Î¼ :=\n        norm_integral_le_integral_norm _\n      _ â‰¤ âˆ« x in s \\ u, Î´ * â€–g xâ€– âˆ‚Î¼ := by\n        refine setIntegral_mono_on ?_ ?_ (hs.diff u_open.measurableSet) fun x hx => ?_\n        Â· exact IntegrableOn.mono_set h''i.norm diff_subset\n        Â· exact IntegrableOn.mono_set (hmg.norm.const_mul _) diff_subset\n        rw [norm_smul]\n        apply mul_le_mul_of_nonneg_right _ (norm_nonneg _)\n        simpa only [Pi.zero_apply, dist_zero_left] using (hi x hx).le\n      _ â‰¤ Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼ := by\n        rw [integral_mul_left]\n        apply mul_le_mul_of_nonneg_left (setIntegral_mono_set hmg.norm _ _) Î´pos.le\n        Â· filter_upwards with x using norm_nonneg _\n        Â· filter_upwards using diff_subset (s := s) (t := u)\n  calc\n    â€–âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼â€– =\n      â€–(âˆ« x in s \\ u, Ï† i x â€¢ g x âˆ‚Î¼) + âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := by\n      conv_lhs => rw [â† diff_union_inter s u]\n      rw [setIntegral_union disjoint_sdiff_inter (hs.inter u_open.measurableSet)\n          (h''i.mono_set diff_subset) (h''i.mono_set inter_subset_left)]\n    _ â‰¤ â€–âˆ« x in s \\ u, Ï† i x â€¢ g x âˆ‚Î¼â€– + â€–âˆ« x in s âˆ© u, Ï† i x â€¢ g x âˆ‚Î¼â€– := norm_add_le _ _\n    _ â‰¤ (Î´ * âˆ« x in s, â€–g xâ€– âˆ‚Î¼) + 2 * Î´ := add_le_add C B\n\n"}
{"name":"tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nÎ¹ : Type u_3\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ng : Î± â†’ E\nl : Filter Î¹\nxâ‚€ : Î±\ns : Set Î±\nÏ† : Î¹ â†’ Î± â†’ Real\na : E\ninstâœ : CompleteSpace E\nhs : MeasurableSet s\nt : Set Î±\nht : MeasurableSet t\nhts : HasSubset.Subset t s\nh'ts : Membership.mem (nhdsWithin xâ‚€ s) t\nh't : Ne (Î¼ t) Top.top\nhnÏ† : Filter.Eventually (fun i => âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 0 (Ï† i x)) l\nhlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ Membership.mem u xâ‚€ â†’ TendstoUniformlyOn Ï† 0 l (SDiff.sdiff s u)\nhiÏ† : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict t) fun x => Ï† i x) l (nhds 1)\nh'iÏ† : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (Ï† i) (Î¼.restrict s)) l\nhmg : MeasureTheory.IntegrableOn g s Î¼\nhcg : Filter.Tendsto g (nhdsWithin xâ‚€ s) (nhds a)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (Ï† i x) (g x)) l (nhds a)","decl":"/-- If a sequence of peak functions `Ï†áµ¢` converges uniformly to zero away from a point `xâ‚€` and its\nintegral on some finite-measure neighborhood of `xâ‚€` converges to `1`, and `g` is integrable and\nhas a limit `a` at `xâ‚€`, then `âˆ« Ï†áµ¢ â€¢ g` converges to `a`. Version localized to a subset. -/\ntheorem tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto\n    (hs : MeasurableSet s) {t : Set Î±} (ht : MeasurableSet t) (hts : t âŠ† s) (h'ts : t âˆˆ ğ“[s] xâ‚€)\n    (h't : Î¼ t â‰  âˆ) (hnÏ† : âˆ€á¶  i in l, âˆ€ x âˆˆ s, 0 â‰¤ Ï† i x)\n    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l (s \\ u))\n    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))\n    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) (Î¼.restrict s))\n    (hmg : IntegrableOn g s Î¼) (hcg : Tendsto g (ğ“[s] xâ‚€) (ğ“ a)) :\n    Tendsto (fun i : Î¹ â†¦ âˆ« x in s, Ï† i x â€¢ g x âˆ‚Î¼) l (ğ“ a) := by\n  let h := g - t.indicator (fun _ â†¦ a)\n  have A : Tendsto (fun i : Î¹ => (âˆ« x in s, Ï† i x â€¢ h x âˆ‚Î¼) + (âˆ« x in t, Ï† i x âˆ‚Î¼) â€¢ a) l\n      (ğ“ (0 + (1 : â„) â€¢ a)) := by\n    refine Tendsto.add ?_ (Tendsto.smul hiÏ† tendsto_const_nhds)\n    apply tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto_aux hs ht hts h'ts\n        hnÏ† hlÏ† hiÏ† h'iÏ†\n    Â· apply hmg.sub\n      simp only [integrable_indicator_iff ht, integrableOn_const, ht, Measure.restrict_apply]\n      right\n      exact lt_of_le_of_lt (measure_mono inter_subset_left) (h't.lt_top)\n    Â· rw [â† sub_self a]\n      apply Tendsto.sub hcg\n      apply tendsto_const_nhds.congr'\n      filter_upwards [h'ts] with x hx using by simp [hx]\n  simp only [one_smul, zero_add] at A\n  refine Tendsto.congr' ?_ A\n  filter_upwards [integrableOn_peak_smul_of_integrableOn_of_tendsto hs h'ts\n    hlÏ† hiÏ† h'iÏ† hmg hcg,\n    (tendsto_order.1 (tendsto_iff_norm_sub_tendsto_zero.1 hiÏ†)).2 1 zero_lt_one] with i hi h'i\n  simp only [h, Pi.sub_apply, smul_sub, â† indicator_smul_apply]\n  rw [integral_sub hi, setIntegral_indicator ht, inter_eq_right.mpr hts,\n    integral_smul_const, sub_add_cancel]\n  rw [integrable_indicator_iff ht]\n  apply Integrable.smul_const\n  rw [restrict_restrict ht, inter_eq_left.mpr hts]\n  exact .of_integral_ne_zero (fun h â†¦ by simp [h] at h'i)\n\n"}
{"name":"tendsto_integral_peak_smul_of_integrable_of_tendsto","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nÎ¹ : Type u_3\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ng : Î± â†’ E\nl : Filter Î¹\nxâ‚€ : Î±\nÏ† : Î¹ â†’ Î± â†’ Real\na : E\ninstâœ : CompleteSpace E\nt : Set Î±\nht : MeasurableSet t\nh'ts : Membership.mem (nhds xâ‚€) t\nh't : Ne (Î¼ t) Top.top\nhnÏ† : Filter.Eventually (fun i => âˆ€ (x : Î±), LE.le 0 (Ï† i x)) l\nhlÏ† : âˆ€ (u : Set Î±), IsOpen u â†’ Membership.mem u xâ‚€ â†’ TendstoUniformlyOn Ï† 0 l (HasCompl.compl u)\nhiÏ† : Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict t) fun x => Ï† i x) l (nhds 1)\nh'iÏ† : Filter.Eventually (fun i => MeasureTheory.AEStronglyMeasurable (Ï† i) Î¼) l\nhmg : MeasureTheory.Integrable g Î¼\nhcg : Filter.Tendsto g (nhds xâ‚€) (nhds a)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral Î¼ fun x => HSMul.hSMul (Ï† i x) (g x)) l (nhds a)","decl":"/-- If a sequence of peak functions `Ï†áµ¢` converges uniformly to zero away from a point `xâ‚€` and its\nintegral on some finite-measure neighborhood of `xâ‚€` converges to `1`, and `g` is integrable and\nhas a limit `a` at `xâ‚€`, then `âˆ« Ï†áµ¢ â€¢ g` converges to `a`. -/\ntheorem tendsto_integral_peak_smul_of_integrable_of_tendsto\n    {t : Set Î±} (ht : MeasurableSet t) (h'ts : t âˆˆ ğ“ xâ‚€)\n    (h't : Î¼ t â‰  âˆ) (hnÏ† : âˆ€á¶  i in l, âˆ€ x, 0 â‰¤ Ï† i x)\n    (hlÏ† : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 l uá¶œ)\n    (hiÏ† : Tendsto (fun i â†¦ âˆ« x in t, Ï† i x âˆ‚Î¼) l (ğ“ 1))\n    (h'iÏ† : âˆ€á¶  i in l, AEStronglyMeasurable (Ï† i) Î¼)\n    (hmg : Integrable g Î¼) (hcg : Tendsto g (ğ“ xâ‚€) (ğ“ a)) :\n    Tendsto (fun i : Î¹ â†¦ âˆ« x, Ï† i x â€¢ g x âˆ‚Î¼) l (ğ“ a) := by\n  suffices Tendsto (fun i : Î¹ â†¦ âˆ« x in univ, Ï† i x â€¢ g x âˆ‚Î¼) l (ğ“ a) by simpa\n  exact tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto MeasurableSet.univ ht (xâ‚€ := xâ‚€)\n    (subset_univ _) (by simpa [nhdsWithin_univ]) h't (by simpa)\n    (by simpa [â† compl_eq_univ_diff] using hlÏ†) hiÏ†\n    (by simpa) (by simpa) (by simpa [nhdsWithin_univ])\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : BorelSpace Î±\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ng : Î± â†’ E\nxâ‚€ : Î±\ns : Set Î±\ninstâœÂ² : CompleteSpace E\ninstâœÂ¹ : TopologicalSpace.MetrizableSpace Î±\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nhs : IsCompact s\nhÎ¼ : âˆ€ (u : Set Î±), IsOpen u â†’ Membership.mem u xâ‚€ â†’ LT.lt 0 (Î¼ (Inter.inter u s))\nc : Î± â†’ Real\nhc : ContinuousOn c s\nh'c : âˆ€ (y : Î±), Membership.mem s y â†’ Ne y xâ‚€ â†’ LT.lt (c y) (c xâ‚€)\nhnc : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 0 (c x)\nhncâ‚€ : LT.lt 0 (c xâ‚€)\nhâ‚€ : Membership.mem s xâ‚€\nhmg : MeasureTheory.IntegrableOn g s Î¼\nhcg : ContinuousWithinAt g s xâ‚€\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (Î¼.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g xâ‚€))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `xâ‚€` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / âˆ« (c x) ^ n` is a sequence of peak functions\nconcentrating around `xâ‚€`. Therefore, `âˆ« (c x) ^ n * g / âˆ« (c x) ^ n` converges to `g xâ‚€` if `g` is\nintegrable on `s` and continuous at `xâ‚€`.\n\nVersion assuming that `Î¼` gives positive mass to all neighborhoods of `xâ‚€` within `s`.\nFor a less precise but more usable version, see\n`tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn`.\n -/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos\n    [MetrizableSpace Î±] [IsLocallyFiniteMeasure Î¼] (hs : IsCompact s)\n    (hÎ¼ : âˆ€ u, IsOpen u â†’ xâ‚€ âˆˆ u â†’ 0 < Î¼ (u âˆ© s)) {c : Î± â†’ â„} (hc : ContinuousOn c s)\n    (h'c : âˆ€ y âˆˆ s, y â‰  xâ‚€ â†’ c y < c xâ‚€) (hnc : âˆ€ x âˆˆ s, 0 â‰¤ c x) (hncâ‚€ : 0 < c xâ‚€) (hâ‚€ : xâ‚€ âˆˆ s)\n    (hmg : IntegrableOn g s Î¼) (hcg : ContinuousWithinAt g s xâ‚€) :\n    Tendsto (fun n : â„• => (âˆ« x in s, c x ^ n âˆ‚Î¼)â»Â¹ â€¢ âˆ« x in s, c x ^ n â€¢ g x âˆ‚Î¼)\n      atTop (ğ“ (g xâ‚€)) := by\n  /- We apply the general result\n    `tendsto_setIntegral_peak_smul_of_integrableOn_of_continuousWithinAt` to the sequence of\n    peak functions `Ï†â‚™ = (c x) ^ n / âˆ« (c x) ^ n`. The only nontrivial bit is to check that this\n    sequence converges uniformly to zero on any set `s \\ u` away from `xâ‚€`. By compactness, the\n    function `c` is bounded by `t < c xâ‚€` there. Consider `t' âˆˆ (t, c xâ‚€)`, and a neighborhood `v`\n    of `xâ‚€` where `c x â‰¥ t'`, by continuity. Then `âˆ« (c x) ^ n` is bounded below by `t' ^ n Î¼ v`.\n    It follows that, on `s \\ u`, then `Ï†â‚™ x â‰¤ t ^ n / (t' ^ n Î¼ v)`,\n    which tends (exponentially fast) to zero with `n`. -/\n  let Ï† : â„• â†’ Î± â†’ â„ := fun n x => (âˆ« x in s, c x ^ n âˆ‚Î¼)â»Â¹ * c x ^ n\n  have hnÏ† : âˆ€ n, âˆ€ x âˆˆ s, 0 â‰¤ Ï† n x := by\n    intro n x hx\n    apply mul_nonneg (inv_nonneg.2 _) (pow_nonneg (hnc x hx) _)\n    exact setIntegral_nonneg hs.measurableSet fun x hx => pow_nonneg (hnc x hx) _\n  have I : âˆ€ n, IntegrableOn (fun x => c x ^ n) s Î¼ := fun n =>\n    ContinuousOn.integrableOn_compact hs (hc.pow n)\n  have J : âˆ€ n, 0 â‰¤áµ[Î¼.restrict s] fun x : Î± => c x ^ n := by\n    intro n\n    filter_upwards [ae_restrict_mem hs.measurableSet] with x hx\n    exact pow_nonneg (hnc x hx) n\n  have P : âˆ€ n, (0 : â„) < âˆ« x in s, c x ^ n âˆ‚Î¼ := by\n    intro n\n    refine (setIntegral_pos_iff_support_of_nonneg_ae (J n) (I n)).2 ?_\n    obtain âŸ¨u, u_open, xâ‚€_u, huâŸ© : âˆƒ u : Set Î±, IsOpen u âˆ§ xâ‚€ âˆˆ u âˆ§ u âˆ© s âŠ† c â»Â¹' Ioi 0 :=\n      _root_.continuousOn_iff.1 hc xâ‚€ hâ‚€ (Ioi (0 : â„)) isOpen_Ioi hncâ‚€\n    apply (hÎ¼ u u_open xâ‚€_u).trans_le\n    exact measure_mono fun x hx => âŸ¨ne_of_gt (pow_pos (a := c x) (hu hx) _), hx.2âŸ©\n  have hiÏ† : âˆ€ n, âˆ« x in s, Ï† n x âˆ‚Î¼ = 1 := fun n => by\n    rw [integral_mul_left, inv_mul_cancelâ‚€ (P n).ne']\n  have A : âˆ€ u : Set Î±, IsOpen u â†’ xâ‚€ âˆˆ u â†’ TendstoUniformlyOn Ï† 0 atTop (s \\ u) := by\n    intro u u_open xâ‚€u\n    obtain âŸ¨t, t_pos, txâ‚€, htâŸ© : âˆƒ t, 0 â‰¤ t âˆ§ t < c xâ‚€ âˆ§ âˆ€ x âˆˆ s \\ u, c x â‰¤ t := by\n      rcases eq_empty_or_nonempty (s \\ u) with (h | h)\n      Â· exact\n          âŸ¨0, le_rfl, hncâ‚€, by simp only [h, mem_empty_iff_false, IsEmpty.forall_iff, imp_true_iff]âŸ©\n      obtain âŸ¨x, hx, h'xâŸ© : âˆƒ x âˆˆ s \\ u, âˆ€ y âˆˆ s \\ u, c y â‰¤ c x :=\n        IsCompact.exists_isMaxOn (hs.diff u_open) h (hc.mono diff_subset)\n      refine âŸ¨c x, hnc x hx.1, h'c x hx.1 ?_, h'xâŸ©\n      rintro rfl\n      exact hx.2 xâ‚€u\n    obtain âŸ¨t', tt', t'xâ‚€âŸ© : âˆƒ t', t < t' âˆ§ t' < c xâ‚€ := exists_between txâ‚€\n    have t'_pos : 0 < t' := t_pos.trans_lt tt'\n    obtain âŸ¨v, v_open, xâ‚€_v, hvâŸ© : âˆƒ v : Set Î±, IsOpen v âˆ§ xâ‚€ âˆˆ v âˆ§ v âˆ© s âŠ† c â»Â¹' Ioi t' :=\n      _root_.continuousOn_iff.1 hc xâ‚€ hâ‚€ (Ioi t') isOpen_Ioi t'xâ‚€\n    have M : âˆ€ n, âˆ€ x âˆˆ s \\ u, Ï† n x â‰¤ (Î¼ (v âˆ© s)).toRealâ»Â¹ * (t / t') ^ n := by\n      intro n x hx\n      have B : t' ^ n * (Î¼ (v âˆ© s)).toReal â‰¤ âˆ« y in s, c y ^ n âˆ‚Î¼ :=\n        calc\n          t' ^ n * (Î¼ (v âˆ© s)).toReal = âˆ« _ in v âˆ© s, t' ^ n âˆ‚Î¼ := by\n            simp only [integral_const, Measure.restrict_apply, MeasurableSet.univ, univ_inter,\n              Algebra.id.smul_eq_mul, mul_comm]\n          _ â‰¤ âˆ« y in v âˆ© s, c y ^ n âˆ‚Î¼ := by\n            apply setIntegral_mono_on _ _ (v_open.measurableSet.inter hs.measurableSet) _\n            Â· apply integrableOn_const.2 (Or.inr _)\n              exact lt_of_le_of_lt (measure_mono inter_subset_right) hs.measure_lt_top\n            Â· exact (I n).mono inter_subset_right le_rfl\n            Â· intro x hx\n              exact pow_le_pow_leftâ‚€ t'_pos.le (hv hx).le _\n          _ â‰¤ âˆ« y in s, c y ^ n âˆ‚Î¼ :=\n            setIntegral_mono_set (I n) (J n) (Eventually.of_forall inter_subset_right)\n      simp_rw [Ï†, â† div_eq_inv_mul, div_pow, div_div]\n      have := ENNReal.toReal_pos (hÎ¼ v v_open xâ‚€_v).ne'\n        ((measure_mono inter_subset_right).trans_lt hs.measure_lt_top).ne\n      gcongr\n      Â· exact hnc _ hx.1\n      Â· exact ht x hx\n    have N :\n      Tendsto (fun n => (Î¼ (v âˆ© s)).toRealâ»Â¹ * (t / t') ^ n) atTop\n        (ğ“ ((Î¼ (v âˆ© s)).toRealâ»Â¹ * 0)) := by\n      apply Tendsto.mul tendsto_const_nhds _\n      apply tendsto_pow_atTop_nhds_zero_of_lt_one (div_nonneg t_pos t'_pos.le)\n      exact (div_lt_one t'_pos).2 tt'\n    rw [mul_zero] at N\n    refine tendstoUniformlyOn_iff.2 fun Îµ Îµpos => ?_\n    filter_upwards [(tendsto_order.1 N).2 Îµ Îµpos] with n hn x hx\n    simp only [Pi.zero_apply, dist_zero_left, Real.norm_of_nonneg (hnÏ† n x hx.1)]\n    exact (M n x hx).trans_lt hn\n  have : Tendsto (fun i : â„• => âˆ« x : Î± in s, Ï† i x â€¢ g x âˆ‚Î¼) atTop (ğ“ (g xâ‚€)) := by\n    have B : Tendsto (fun i â†¦ âˆ« (x : Î±) in s, Ï† i x âˆ‚Î¼) atTop (ğ“ 1) :=\n      tendsto_const_nhds.congr (fun n â†¦ (hiÏ† n).symm)\n    have C : âˆ€á¶  (i : â„•) in atTop, AEStronglyMeasurable (fun x â†¦ Ï† i x) (Î¼.restrict s) := by\n      apply Eventually.of_forall (fun n â†¦ ((I n).const_mul _).aestronglyMeasurable)\n    exact tendsto_setIntegral_peak_smul_of_integrableOn_of_tendsto hs.measurableSet\n      hs.measurableSet (Subset.rfl) (self_mem_nhdsWithin)\n      hs.measure_lt_top.ne (Eventually.of_forall hnÏ†) A B C hmg hcg\n  convert this\n  simp_rw [Ï†, â† smul_smul, integral_smul]\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : BorelSpace Î±\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ng : Î± â†’ E\nxâ‚€ : Î±\ns : Set Î±\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : TopologicalSpace.MetrizableSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœ : Î¼.IsOpenPosMeasure\nhs : IsCompact s\nc : Î± â†’ Real\nhc : ContinuousOn c s\nh'c : âˆ€ (y : Î±), Membership.mem s y â†’ Ne y xâ‚€ â†’ LT.lt (c y) (c xâ‚€)\nhnc : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 0 (c x)\nhncâ‚€ : LT.lt 0 (c xâ‚€)\nhâ‚€ : Membership.mem (closure (interior s)) xâ‚€\nhmg : MeasureTheory.IntegrableOn g s Î¼\nhcg : ContinuousWithinAt g s xâ‚€\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (Î¼.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g xâ‚€))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `xâ‚€` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / âˆ« (c x) ^ n` is a sequence of peak functions\nconcentrating around `xâ‚€`. Therefore, `âˆ« (c x) ^ n * g / âˆ« (c x) ^ n` converges to `g xâ‚€` if `g` is\nintegrable on `s` and continuous at `xâ‚€`.\n\nVersion assuming that `Î¼` gives positive mass to all open sets.\nFor a less precise but more usable version, see\n`tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn`.\n-/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn\n    [MetrizableSpace Î±] [IsLocallyFiniteMeasure Î¼] [IsOpenPosMeasure Î¼] (hs : IsCompact s)\n    {c : Î± â†’ â„} (hc : ContinuousOn c s) (h'c : âˆ€ y âˆˆ s, y â‰  xâ‚€ â†’ c y < c xâ‚€)\n    (hnc : âˆ€ x âˆˆ s, 0 â‰¤ c x) (hncâ‚€ : 0 < c xâ‚€) (hâ‚€ : xâ‚€ âˆˆ closure (interior s))\n    (hmg : IntegrableOn g s Î¼) (hcg : ContinuousWithinAt g s xâ‚€) :\n    Tendsto (fun n : â„• => (âˆ« x in s, c x ^ n âˆ‚Î¼)â»Â¹ â€¢ âˆ« x in s, c x ^ n â€¢ g x âˆ‚Î¼) atTop\n      (ğ“ (g xâ‚€)) := by\n  have : xâ‚€ âˆˆ s := by rw [â† hs.isClosed.closure_eq]; exact closure_mono interior_subset hâ‚€\n  apply\n    tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_measure_nhdsWithin_pos hs _ hc\n      h'c hnc hncâ‚€ this hmg hcg\n  intro u u_open xâ‚€_u\n  calc\n    0 < Î¼ (u âˆ© interior s) :=\n      (u_open.inter isOpen_interior).measure_pos Î¼ (_root_.mem_closure_iff.1 hâ‚€ u u_open xâ‚€_u)\n    _ â‰¤ Î¼ (u âˆ© s) := by gcongr; apply interior_subset\n\n"}
{"name":"tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"Î± : Type u_1\nE : Type u_2\nhm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : BorelSpace Î±\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ng : Î± â†’ E\nxâ‚€ : Î±\ns : Set Î±\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : TopologicalSpace.MetrizableSpace Î±\ninstâœÂ¹ : MeasureTheory.IsLocallyFiniteMeasure Î¼\ninstâœ : Î¼.IsOpenPosMeasure\nhs : IsCompact s\nc : Î± â†’ Real\nhc : ContinuousOn c s\nh'c : âˆ€ (y : Î±), Membership.mem s y â†’ Ne y xâ‚€ â†’ LT.lt (c y) (c xâ‚€)\nhnc : âˆ€ (x : Î±), Membership.mem s x â†’ LE.le 0 (c x)\nhncâ‚€ : LT.lt 0 (c xâ‚€)\nhâ‚€ : Membership.mem (closure (interior s)) xâ‚€\nhmg : ContinuousOn g s\nâŠ¢ Filter.Tendsto (fun n => HSMul.hSMul (Inv.inv (MeasureTheory.integral (Î¼.restrict s) fun x => HPow.hPow (c x) n)) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (HPow.hPow (c x) n) (g x))) Filter.atTop (nhds (g xâ‚€))","decl":"/-- If a continuous function `c` realizes its maximum at a unique point `xâ‚€` in a compact set `s`,\nthen the sequence of functions `(c x) ^ n / âˆ« (c x) ^ n` is a sequence of peak functions\nconcentrating around `xâ‚€`. Therefore, `âˆ« (c x) ^ n * g / âˆ« (c x) ^ n` converges to `g xâ‚€` if `g` is\ncontinuous on `s`. -/\ntheorem tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn\n    [MetrizableSpace Î±] [IsLocallyFiniteMeasure Î¼] [IsOpenPosMeasure Î¼] (hs : IsCompact s)\n    {c : Î± â†’ â„} (hc : ContinuousOn c s) (h'c : âˆ€ y âˆˆ s, y â‰  xâ‚€ â†’ c y < c xâ‚€)\n    (hnc : âˆ€ x âˆˆ s, 0 â‰¤ c x) (hncâ‚€ : 0 < c xâ‚€) (hâ‚€ : xâ‚€ âˆˆ closure (interior s))\n    (hmg : ContinuousOn g s) :\n    Tendsto (fun n : â„• => (âˆ« x in s, c x ^ n âˆ‚Î¼)â»Â¹ â€¢ âˆ« x in s, c x ^ n â€¢ g x âˆ‚Î¼) atTop (ğ“ (g xâ‚€)) :=\n  haveI : xâ‚€ âˆˆ s := by rw [â† hs.isClosed.closure_eq]; exact closure_mono interior_subset hâ‚€\n  tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_integrableOn hs hc h'c hnc hncâ‚€ hâ‚€\n    (hmg.integrableOn_compact hs) (hmg xâ‚€ this)\n\n"}
{"name":"tendsto_integral_comp_smul_smul_of_integrable","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"E : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : CompleteSpace E\nF : Type u_4\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : FiniteDimensional Real F\ninstâœÂ² : MeasurableSpace F\ninstâœÂ¹ : BorelSpace F\nÎ¼ : MeasureTheory.Measure F\ninstâœ : Î¼.IsAddHaarMeasure\nÏ† : F â†’ Real\nhÏ† : âˆ€ (x : F), LE.le 0 (Ï† x)\nh'Ï† : Eq (MeasureTheory.integral Î¼ fun x => Ï† x) 1\nh : Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (Norm.norm x) (Module.finrank Real F)) (Ï† x)) (Bornology.cobounded F) (nhds 0)\ng : F â†’ E\nhg : MeasureTheory.Integrable g Î¼\nh'g : ContinuousAt g 0\nâŠ¢ Filter.Tendsto (fun c => MeasureTheory.integral Î¼ fun x => HSMul.hSMul (HMul.hMul (HPow.hPow c (Module.finrank Real F)) (Ï† (HSMul.hSMul c x))) (g x)) Filter.atTop (nhds (g 0))","decl":"/-- Consider a nonnegative function `Ï†` with integral one, decaying quickly enough at infinity.\nThen suitable renormalizations of `Ï†` form a sequence of peak functions around the origin:\n`âˆ« (c ^ d * Ï† (c â€¢ x)) â€¢ g x` converges to `g 0` as `c â†’ âˆ` if `g` is continuous at `0`\nand integrable. -/\ntheorem tendsto_integral_comp_smul_smul_of_integrable\n    {Ï† : F â†’ â„} (hÏ† : âˆ€ x, 0 â‰¤ Ï† x) (h'Ï† : âˆ« x, Ï† x âˆ‚Î¼ = 1)\n    (h : Tendsto (fun x â†¦ â€–xâ€– ^ finrank â„ F * Ï† x) (cobounded F) (ğ“ 0))\n    {g : F â†’ E} (hg : Integrable g Î¼) (h'g : ContinuousAt g 0) :\n    Tendsto (fun (c : â„) â†¦ âˆ« x, (c ^ (finrank â„ F) * Ï† (c â€¢ x)) â€¢ g x âˆ‚Î¼) atTop (ğ“ (g 0)) := by\n  have I : Integrable Ï† Î¼ := integrable_of_integral_eq_one h'Ï†\n  apply tendsto_integral_peak_smul_of_integrable_of_tendsto (t := closedBall 0 1) (xâ‚€ := 0)\n  Â· exact isClosed_ball.measurableSet\n  Â· exact closedBall_mem_nhds _ zero_lt_one\n  Â· exact (isCompact_closedBall 0 1).measure_ne_top\n  Â· filter_upwards [Ici_mem_atTop 0] with c (hc : 0 â‰¤ c) x using mul_nonneg (by positivity) (hÏ† _)\n  Â· intro u u_open hu\n    apply tendstoUniformlyOn_iff.2 (fun Îµ Îµpos â†¦ ?_)\n    obtain âŸ¨Î´, Î´pos, h'uâŸ© : âˆƒ Î´ > 0, ball 0 Î´ âŠ† u := Metric.isOpen_iff.1 u_open _ hu\n    obtain âŸ¨M, Mpos, hMâŸ© : âˆƒ M > 0, âˆ€ â¦ƒx : Fâ¦„, x âˆˆ (closedBall 0 M)á¶œ â†’\n        â€–xâ€– ^ finrank â„ F * Ï† x < Î´ ^ finrank â„ F * Îµ := by\n      rcases (hasBasis_cobounded_compl_closedBall (0 : F)).eventually_iff.1\n        ((tendsto_order.1 h).2 (Î´ ^ finrank â„ F * Îµ) (by positivity)) with âŸ¨M, -, hMâŸ©\n      refine âŸ¨max M 1, zero_lt_one.trans_le (le_max_right _ _), fun x hx â†¦ hM ?_âŸ©\n      simp only [mem_compl_iff, mem_closedBall, dist_zero_right, le_max_iff, not_or, not_le] at hx\n      simpa using hx.1\n    filter_upwards [Ioi_mem_atTop (M / Î´)] with c (hc : M / Î´ < c) x hx\n    have cpos : 0 < c := lt_trans (by positivity) hc\n    suffices c ^ finrank â„ F * Ï† (c â€¢ x) < Îµ by simpa [abs_of_nonneg (hÏ† _), abs_of_nonneg cpos.le]\n    have hÎ´x : Î´ â‰¤ â€–xâ€– := by\n      have : x âˆˆ (ball 0 Î´)á¶œ := fun h â†¦ hx (h'u h)\n      simpa only [mem_compl_iff, mem_ball, dist_zero_right, not_lt]\n    suffices Î´ ^ finrank â„ F * (c ^ finrank â„ F * Ï† (c â€¢ x)) < Î´ ^ finrank â„ F * Îµ by\n      rwa [mul_lt_mul_iff_of_pos_left (by positivity)] at this\n    calc\n      Î´ ^ finrank â„ F * (c ^ finrank â„ F * Ï† (c â€¢ x))\n      _ â‰¤ â€–xâ€– ^ finrank â„ F * (c ^ finrank â„ F * Ï† (c â€¢ x)) := by\n        gcongr; exact mul_nonneg (by positivity) (hÏ† _)\n      _ = â€–c â€¢ xâ€– ^ finrank â„ F * Ï† (c â€¢ x) := by\n        simp [norm_smul, abs_of_pos cpos, mul_pow]; ring\n      _ < Î´ ^ finrank â„ F * Îµ := by\n        apply hM\n        rw [div_lt_iffâ‚€ Î´pos] at hc\n        simp only [mem_compl_iff, mem_closedBall, dist_zero_right, norm_smul, Real.norm_eq_abs,\n          abs_of_nonneg cpos.le, not_le, gt_iff_lt]\n        exact hc.trans_le (by gcongr)\n  Â· have : Tendsto (fun c â†¦ âˆ« (x : F) in closedBall 0 c, Ï† x âˆ‚Î¼) atTop (ğ“ 1) := by\n      rw [â† h'Ï†]\n      exact (aecover_closedBall tendsto_id).integral_tendsto_of_countably_generated I\n    apply this.congr'\n    filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    rw [integral_mul_left, setIntegral_comp_smul_of_pos _ _ _ hc, smul_eq_mul, â† mul_assoc,\n      mul_inv_cancelâ‚€ (by positivity), _root_.smul_closedBall _ _ zero_le_one]\n    simp [abs_of_nonneg hc.le]\n  Â· filter_upwards [Ioi_mem_atTop 0] with c (hc : 0 < c)\n    exact (I.comp_smul hc.ne').aestronglyMeasurable.const_mul _\n  Â· exact hg\n  Â· exact h'g\n\n"}
{"name":"tendsto_integral_comp_smul_smul_of_integrable'","module":"Mathlib.MeasureTheory.Integral.PeakFunction","initialProofState":"E : Type u_2\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : CompleteSpace E\nF : Type u_4\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace Real F\ninstâœÂ³ : FiniteDimensional Real F\ninstâœÂ² : MeasurableSpace F\ninstâœÂ¹ : BorelSpace F\nÎ¼ : MeasureTheory.Measure F\ninstâœ : Î¼.IsAddHaarMeasure\nÏ† : F â†’ Real\nhÏ† : âˆ€ (x : F), LE.le 0 (Ï† x)\nh'Ï† : Eq (MeasureTheory.integral Î¼ fun x => Ï† x) 1\nh : Filter.Tendsto (fun x => HMul.hMul (HPow.hPow (Norm.norm x) (Module.finrank Real F)) (Ï† x)) (Bornology.cobounded F) (nhds 0)\ng : F â†’ E\nxâ‚€ : F\nhg : MeasureTheory.Integrable g Î¼\nh'g : ContinuousAt g xâ‚€\nâŠ¢ Filter.Tendsto (fun c => MeasureTheory.integral Î¼ fun x => HSMul.hSMul (HMul.hMul (HPow.hPow c (Module.finrank Real F)) (Ï† (HSMul.hSMul c (HSub.hSub xâ‚€ x)))) (g x)) Filter.atTop (nhds (g xâ‚€))","decl":"/-- Consider a nonnegative function `Ï†` with integral one, decaying quickly enough at infinity.\nThen suitable renormalizations of `Ï†` form a sequence of peak functions around any point:\n`âˆ« (c ^ d * Ï† (c â€¢ (xâ‚€ - x)) â€¢ g x` converges to `g xâ‚€` as `c â†’ âˆ` if `g` is continuous at `xâ‚€`\nand integrable. -/\ntheorem tendsto_integral_comp_smul_smul_of_integrable'\n    {Ï† : F â†’ â„} (hÏ† : âˆ€ x, 0 â‰¤ Ï† x) (h'Ï† : âˆ« x, Ï† x âˆ‚Î¼ = 1)\n    (h : Tendsto (fun x â†¦ â€–xâ€– ^ finrank â„ F * Ï† x) (cobounded F) (ğ“ 0))\n    {g : F â†’ E} {xâ‚€ : F} (hg : Integrable g Î¼) (h'g : ContinuousAt g xâ‚€) :\n    Tendsto (fun (c : â„) â†¦ âˆ« x, (c ^ (finrank â„ F) * Ï† (c â€¢ (xâ‚€ - x))) â€¢ g x âˆ‚Î¼)\n      atTop (ğ“ (g xâ‚€)) := by\n  let f := fun x â†¦ g (xâ‚€ - x)\n  have If : Integrable f Î¼ := by simpa [f, sub_eq_add_neg] using (hg.comp_add_left xâ‚€).comp_neg\n  have : Tendsto (fun (c : â„) â†¦ âˆ« x, (c ^ (finrank â„ F) * Ï† (c â€¢ x)) â€¢ f x âˆ‚Î¼)\n      atTop (ğ“ (f 0)) := by\n    apply tendsto_integral_comp_smul_smul_of_integrable hÏ† h'Ï† h If\n    have A : ContinuousAt g (xâ‚€ - 0) := by simpa using h'g\n    exact A.comp <| by fun_prop\n  simp only [f, sub_zero] at this\n  convert this using 2 with c\n  conv_rhs => rw [â† integral_add_left_eq_self xâ‚€ (Î¼ := Î¼)\n    (f := fun x â†¦ (c ^ finrank â„ F * Ï† (c â€¢ x)) â€¢ g (xâ‚€ - x)), â† integral_neg_eq_self]\n  simp [smul_sub, sub_eq_add_neg]\n"}
