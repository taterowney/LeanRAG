{"name":"Rat.isDomain","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"⊢ IsDomain Rat","decl":"instance isDomain : IsDomain ℚ := NoZeroDivisors.to_isDomain _\n"}
{"name":"Rat.instCharZero","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"⊢ CharZero Rat","decl":"/-- The characteristic of `ℚ` is 0. -/\n@[stacks 09FS \"Second part.\"]\ninstance instCharZero : CharZero ℚ where cast_injective a b hab := by simpa using congr_arg num hab\n\n"}
{"name":"Rat.mkRat_eq_div","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"n : Int\nd : Nat\n⊢ Eq (mkRat n d) (HDiv.hDiv ↑n ↑d)","decl":"lemma mkRat_eq_div (n : ℤ) (d : ℕ) : mkRat n d = n / d := by\n  simp only [mkRat_eq_divInt, divInt_eq_div, Int.cast_natCast]\n\n"}
{"name":"Rat.divInt_div_divInt_cancel_left","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"x : Int\nhx : Ne x 0\nn d : Int\n⊢ Eq (HDiv.hDiv (Rat.divInt n x) (Rat.divInt d x)) (Rat.divInt n d)","decl":"lemma divInt_div_divInt_cancel_left {x : ℤ} (hx : x ≠ 0) (n d : ℤ) :\n    n /. x / (d /. x) = n /. d := by\n  rw [div_eq_mul_inv, inv_divInt', divInt_mul_divInt_cancel hx]\n\n"}
{"name":"Rat.divInt_div_divInt_cancel_right","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"x : Int\nhx : Ne x 0\nn d : Int\n⊢ Eq (HDiv.hDiv (Rat.divInt x n) (Rat.divInt x d)) (Rat.divInt d n)","decl":"lemma divInt_div_divInt_cancel_right {x : ℤ} (hx : x ≠ 0) (n d : ℤ) :\n    x /. n / (x /. d) = d /. n := by\n  rw [div_eq_mul_inv, inv_divInt', mul_comm, divInt_mul_divInt_cancel hx]\n\n"}
{"name":"Rat.num_div_den","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"r : Rat\n⊢ Eq (HDiv.hDiv ↑r.num ↑r.den) r","decl":"lemma num_div_den (r : ℚ) : (r.num : ℚ) / (r.den : ℚ) = r := by\n  rw [← Int.cast_natCast, ← divInt_eq_div, num_divInt_den]\n\n"}
{"name":"Rat.divInt_pow","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"num : Nat\nden : Int\nn : Nat\n⊢ Eq (HPow.hPow (Rat.divInt (↑num) den) n) (Rat.divInt (HPow.hPow (↑num) n) (HPow.hPow den n))","decl":"@[simp] lemma divInt_pow (num : ℕ) (den : ℤ) (n : ℕ) : (num /. den) ^ n = num ^ n /. den ^ n := by\n  simp [divInt_eq_div, div_pow, Int.natCast_pow]\n\n"}
{"name":"Rat.mkRat_pow","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"num den n : Nat\n⊢ Eq (HPow.hPow (mkRat (↑num) den) n) (mkRat (HPow.hPow (↑num) n) (HPow.hPow den n))","decl":"@[simp] lemma mkRat_pow (num den : ℕ) (n : ℕ) : mkRat num den ^ n = mkRat (num ^ n) (den ^ n) := by\n  rw [mkRat_eq_divInt, mkRat_eq_divInt, divInt_pow, Int.natCast_pow]\n\n"}
{"name":"Rat.natCast_eq_divInt","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"n : Nat\n⊢ Eq (↑n) (Rat.divInt (↑n) 1)","decl":"lemma natCast_eq_divInt (n : ℕ) : ↑n = n /. 1 := by rw [← Int.cast_natCast, intCast_eq_divInt]\n\n"}
{"name":"Rat.mul_den_eq_num","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"q : Rat\n⊢ Eq (HMul.hMul q ↑q.den) ↑q.num","decl":"@[simp] lemma mul_den_eq_num (q : ℚ) : q * q.den = q.num := by\n  suffices (q.num /. ↑q.den) * (↑q.den /. 1) = q.num /. 1 by\n    conv => pattern (occs := 1) q; (rw [← num_divInt_den q])\n    simp only [intCast_eq_divInt, natCast_eq_divInt, num_divInt_den] at this ⊢; assumption\n  have : (q.den : ℤ) ≠ 0 := mod_cast q.den_ne_zero\n  rw [divInt_mul_divInt _ _ this Int.one_ne_zero, mul_comm (q.den : ℤ) 1, divInt_mul_right this]\n\n"}
{"name":"Rat.den_mul_eq_num","module":"Mathlib.Algebra.Ring.Rat","initialProofState":"q : Rat\n⊢ Eq (HMul.hMul (↑q.den) q) ↑q.num","decl":"@[simp] lemma den_mul_eq_num (q : ℚ) : q.den * q = q.num := by rw [mul_comm, mul_den_eq_num]\n\n"}
