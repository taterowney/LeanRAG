{"name":"Function.Injective.leftDistribClass","module":"Mathlib.Algebra.Ring.InjSurj","initialProofState":"α : Type u_1\nβ : Type u_2\nf : β → α\nhf : Function.Injective f\ninst✝⁴ : Add β\ninst✝³ : Mul β\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : LeftDistribClass α\nadd : ∀ (x y : β), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nmul : ∀ (x y : β), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ LeftDistribClass β","decl":"/-- Pullback a `LeftDistribClass` instance along an injective function. -/\ntheorem leftDistribClass [Mul α] [Add α] [LeftDistribClass α] (add : ∀ x y, f (x + y) = f x + f y)\n    (mul : ∀ x y, f (x * y) = f x * f y) : LeftDistribClass β where\n  left_distrib x y z := hf <| by simp only [*, left_distrib]\n\n"}
{"name":"Function.Injective.rightDistribClass","module":"Mathlib.Algebra.Ring.InjSurj","initialProofState":"α : Type u_1\nβ : Type u_2\nf : β → α\nhf : Function.Injective f\ninst✝⁴ : Add β\ninst✝³ : Mul β\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : RightDistribClass α\nadd : ∀ (x y : β), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nmul : ∀ (x y : β), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ RightDistribClass β","decl":"/-- Pullback a `RightDistribClass` instance along an injective function. -/\ntheorem rightDistribClass [Mul α] [Add α] [RightDistribClass α] (add : ∀ x y, f (x + y) = f x + f y)\n    (mul : ∀ x y, f (x * y) = f x * f y) : RightDistribClass β where\n  right_distrib x y z := hf <| by simp only [*, right_distrib]\n\n"}
{"name":"Function.Surjective.leftDistribClass","module":"Mathlib.Algebra.Ring.InjSurj","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ninst✝⁴ : Add β\ninst✝³ : Mul β\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : LeftDistribClass α\nadd : ∀ (x y : α), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nmul : ∀ (x y : α), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ LeftDistribClass β","decl":"/-- Pushforward a `LeftDistribClass` instance along a surjective function. -/\ntheorem leftDistribClass [Mul α] [Add α] [LeftDistribClass α] (add : ∀ x y, f (x + y) = f x + f y)\n    (mul : ∀ x y, f (x * y) = f x * f y) : LeftDistribClass β where\n  left_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, left_distrib]\n\n"}
{"name":"Function.Surjective.rightDistribClass","module":"Mathlib.Algebra.Ring.InjSurj","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Surjective f\ninst✝⁴ : Add β\ninst✝³ : Mul β\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : RightDistribClass α\nadd : ∀ (x y : α), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nmul : ∀ (x y : α), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ RightDistribClass β","decl":"/-- Pushforward a `RightDistribClass` instance along a surjective function. -/\ntheorem rightDistribClass [Mul α] [Add α] [RightDistribClass α] (add : ∀ x y, f (x + y) = f x + f y)\n    (mul : ∀ x y, f (x * y) = f x * f y) : RightDistribClass β where\n  right_distrib := hf.forall₃.2 fun x y z => by simp only [← add, ← mul, right_distrib]\n\n"}
