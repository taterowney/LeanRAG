{"name":"MeasureTheory.AddContent.empty'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nself : MeasureTheory.AddContent C\nâŠ¢ Eq (self.toFun EmptyCollection.emptyCollection) 0","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set Î±)) where\n  /-- The value of the content on a set. -/\n  toFun : Set Î± â†’ â„â‰¥0âˆ\n  empty' : toFun âˆ… = 0\n  sUnion' (I : Finset (Set Î±)) (_h_ss : â†‘I âŠ† C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (_h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    toFun (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.inj","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ntoFunâœ : Set Î± â†’ ENNReal\nempty'âœ : Eq (toFunâœ EmptyCollection.emptyCollection) 0\nsUnion'âœ : âˆ€ (I : Finset (Set Î±)), HasSubset.Subset (â†‘I) C â†’ (â†‘I).PairwiseDisjoint id â†’ Membership.mem C (â†‘I).sUnion â†’ Eq (toFunâœ (â†‘I).sUnion) (I.sum fun u => toFunâœ u)\ntoFun : Set Î± â†’ ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : âˆ€ (I : Finset (Set Î±)), HasSubset.Subset (â†‘I) C â†’ (â†‘I).PairwiseDisjoint id â†’ Membership.mem C (â†‘I).sUnion â†’ Eq (toFun (â†‘I).sUnion) (I.sum fun u => toFun u)\nxâœ : Eq { toFun := toFunâœ, empty' := empty'âœ, sUnion' := sUnion'âœ } { toFun := toFun, empty' := empty', sUnion' := sUnion' }\nâŠ¢ Eq toFunâœ toFun","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set Î±)) where\n  /-- The value of the content on a set. -/\n  toFun : Set Î± â†’ â„â‰¥0âˆ\n  empty' : toFun âˆ… = 0\n  sUnion' (I : Finset (Set Î±)) (_h_ss : â†‘I âŠ† C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (_h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    toFun (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ninstâœÂ¹ : SizeOf Î±\ninstâœ : (a : Set Î±) â†’ SizeOf (C a)\ntoFun : Set Î± â†’ ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : âˆ€ (I : Finset (Set Î±)), HasSubset.Subset (â†‘I) C â†’ (â†‘I).PairwiseDisjoint id â†’ Membership.mem C (â†‘I).sUnion â†’ Eq (toFun (â†‘I).sUnion) (I.sum fun u => toFun u)\nâŠ¢ Eq (SizeOf.sizeOf { toFun := toFun, empty' := empty', sUnion' := sUnion' }) (HAdd.hAdd 1 (SizeOf.sizeOf empty'))","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set Î±)) where\n  /-- The value of the content on a set. -/\n  toFun : Set Î± â†’ â„â‰¥0âˆ\n  empty' : toFun âˆ… = 0\n  sUnion' (I : Finset (Set Î±)) (_h_ss : â†‘I âŠ† C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (_h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    toFun (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.injEq","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ntoFunâœ : Set Î± â†’ ENNReal\nempty'âœ : Eq (toFunâœ EmptyCollection.emptyCollection) 0\nsUnion'âœ : âˆ€ (I : Finset (Set Î±)), HasSubset.Subset (â†‘I) C â†’ (â†‘I).PairwiseDisjoint id â†’ Membership.mem C (â†‘I).sUnion â†’ Eq (toFunâœ (â†‘I).sUnion) (I.sum fun u => toFunâœ u)\ntoFun : Set Î± â†’ ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : âˆ€ (I : Finset (Set Î±)), HasSubset.Subset (â†‘I) C â†’ (â†‘I).PairwiseDisjoint id â†’ Membership.mem C (â†‘I).sUnion â†’ Eq (toFun (â†‘I).sUnion) (I.sum fun u => toFun u)\nâŠ¢ Eq (Eq { toFun := toFunâœ, empty' := empty'âœ, sUnion' := sUnion'âœ } { toFun := toFun, empty' := empty', sUnion' := sUnion' }) (Eq toFunâœ toFun)","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set Î±)) where\n  /-- The value of the content on a set. -/\n  toFun : Set Î± â†’ â„â‰¥0âˆ\n  empty' : toFun âˆ… = 0\n  sUnion' (I : Finset (Set Î±)) (_h_ss : â†‘I âŠ† C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (_h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    toFun (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.sUnion'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nself : MeasureTheory.AddContent C\nI : Finset (Set Î±)\n_h_ss : HasSubset.Subset (â†‘I) C\n_h_dis : (â†‘I).PairwiseDisjoint id\n_h_mem : Membership.mem C (â†‘I).sUnion\nâŠ¢ Eq (self.toFun (â†‘I).sUnion) (I.sum fun u => self.toFun u)","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set Î±)) where\n  /-- The value of the content on a set. -/\n  toFun : Set Î± â†’ â„â‰¥0âˆ\n  empty' : toFun âˆ… = 0\n  sUnion' (I : Finset (Set Î±)) (_h_ss : â†‘I âŠ† C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (_h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    toFun (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.ext","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm m' : MeasureTheory.AddContent C\nh : âˆ€ (s : Set Î±), Eq (m s) (m' s)\nâŠ¢ Eq m m'","decl":"@[ext] protected lemma AddContent.ext (h : âˆ€ s, m s = m' s) : m = m' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.AddContent.ext_iff","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm m' : MeasureTheory.AddContent C\nâŠ¢ Iff (Eq m m') (âˆ€ (s : Set Î±), Eq (m s) (m' s))","decl":"@[ext] protected lemma AddContent.ext (h : âˆ€ s, m s = m' s) : m = m' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.addContent_empty","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nâŠ¢ Eq (m EmptyCollection.emptyCollection) 0","decl":"@[simp] lemma addContent_empty : m âˆ… = 0 := m.empty'\n\n"}
{"name":"MeasureTheory.addContent_sUnion","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nI : Finset (Set Î±)\nm : MeasureTheory.AddContent C\nh_ss : HasSubset.Subset (â†‘I) C\nh_dis : (â†‘I).PairwiseDisjoint id\nh_mem : Membership.mem C (â†‘I).sUnion\nâŠ¢ Eq (m (â†‘I).sUnion) (I.sum fun u => m u)","decl":"lemma addContent_sUnion (h_ss : â†‘I âŠ† C)\n    (h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) (h_mem : â‹ƒâ‚€ â†‘I âˆˆ C) :\n    m (â‹ƒâ‚€ I) = âˆ‘ u âˆˆ I, m u :=\n  m.sUnion' I h_ss h_dis h_mem\n\n"}
{"name":"MeasureTheory.addContent_union'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : Membership.mem C (Union.union s t)\nh_dis : Disjoint s t\nâŠ¢ Eq (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union' (hs : s âˆˆ C) (ht : t âˆˆ C) (hst : s âˆª t âˆˆ C) (h_dis : Disjoint s t) :\n    m (s âˆª t) = m s + m t := by\n  by_cases hs_empty : s = âˆ…\n  Â· simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]\n  classical\n  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_\n  rotate_left\n  Â· simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]\n  Â· simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,\n      mem_singleton_iff, Ne, id, forall_eq, true_and]\n    exact fun _ => h_dis\n  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]\n    exact hst\n  convert h\n  Â· simp only [coe_pair, sUnion_insert, sUnion_singleton]\n  Â· rw [sum_insert, sum_singleton]\n    simp only [Finset.mem_singleton]\n    refine fun hs_eq_t => hs_empty ?_\n    rw [â† hs_eq_t] at h_dis\n    exact Disjoint.eq_bot_of_self h_dis\n\n"}
{"name":"MeasureTheory.addContent_eq_add_disjointOfDiffUnion_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns : Set Î±\nI : Finset (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (â†‘I) C\nhI_ss : âˆ€ (t : Set Î±), Membership.mem I t â†’ HasSubset.Subset t s\nh_dis : (â†‘I).PairwiseDisjoint id\nâŠ¢ Eq (m s) (HAdd.hAdd (I.sum fun i => m i) ((hC.disjointOfDiffUnion hs hI).sum fun i => m i))","decl":"lemma addContent_eq_add_disjointOfDiffUnion_of_subset (hC : IsSetSemiring C)\n    (hs : s âˆˆ C) (hI : â†‘I âŠ† C) (hI_ss : âˆ€ t âˆˆ I, t âŠ† s)\n    (h_dis : PairwiseDisjoint (I : Set (Set Î±)) id) :\n    m s = âˆ‘ i âˆˆ I, m i + âˆ‘ i âˆˆ hC.disjointOfDiffUnion hs hI, m i := by\n  classical\n  conv_lhs => rw [â† hC.sUnion_union_disjointOfDiffUnion_of_subset hs hI hI_ss]\n  rw [addContent_sUnion]\n  Â· rw [sum_union]\n    exact hC.disjoint_disjointOfDiffUnion hs hI\n  Â· rw [coe_union]\n    exact Set.union_subset hI (hC.disjointOfDiffUnion_subset hs hI)\n  Â· rw [coe_union]\n    exact hC.pairwiseDisjoint_union_disjointOfDiffUnion hs hI h_dis\n  Â· rwa [hC.sUnion_union_disjointOfDiffUnion_of_subset hs hI hI_ss]\n\n"}
{"name":"MeasureTheory.sum_addContent_le_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nt : Set Î±\nI : Finset (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nh_ss : HasSubset.Subset (â†‘I) C\nh_dis : (â†‘I).PairwiseDisjoint id\nht : Membership.mem C t\nhJt : âˆ€ (s : Set Î±), Membership.mem I s â†’ HasSubset.Subset s t\nâŠ¢ LE.le (I.sum fun u => m u) (m t)","decl":"/-- For an `m : addContent C` on a `SetSemiring C`, if `I` is a `Finset` of pairwise disjoint\n  sets in `C` and `â‹ƒâ‚€ I âŠ† t` for `t âˆˆ C`, then `âˆ‘ s âˆˆ I, m s â‰¤ m t`.-/\nlemma sum_addContent_le_of_subset (hC : IsSetSemiring C)\n    (h_ss : â†‘I âŠ† C) (h_dis : PairwiseDisjoint (I : Set (Set Î±)) id)\n    (ht : t âˆˆ C) (hJt : âˆ€ s âˆˆ I, s âŠ† t) :\n    âˆ‘ u âˆˆ I, m u â‰¤ m t := by\n  classical\n  rw [addContent_eq_add_disjointOfDiffUnion_of_subset hC ht h_ss hJt h_dis]\n  exact le_add_right le_rfl\n\n"}
{"name":"MeasureTheory.addContent_mono","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : HasSubset.Subset s t\nâŠ¢ LE.le (m s) (m t)","decl":"/-- An `addContent C` on a `SetSemiring C` is monotone. -/\nlemma addContent_mono (hC : IsSetSemiring C) (hs : s âˆˆ C) (ht : t âˆˆ C)\n    (hst : s âŠ† t) :\n    m s â‰¤ m t := by\n  have h := sum_addContent_le_of_subset (m := m) hC (I := {s}) ?_ ?_ ht ?_\n  Â· simpa only [sum_singleton] using h\n  Â· rwa [singleton_subset_set_iff]\n  Â· simp only [coe_singleton, pairwiseDisjoint_singleton]\n  Â· simp [hst]\n\n"}
{"name":"MeasureTheory.eq_add_disjointOfDiff_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : HasSubset.Subset s t\nâŠ¢ Eq (m t) (HAdd.hAdd (m s) ((hC.disjointOfDiff ht hs).sum fun i => m i))","decl":"/-- For an `m : addContent C` on a `SetSemiring C` and `s t : Set Î±` with `s âŠ† t`, we can write\n`m t = m s + âˆ‘ i in hC.disjointOfDiff ht hs, m i`.-/\ntheorem eq_add_disjointOfDiff_of_subset (hC : IsSetSemiring C)\n    (hs : s âˆˆ C) (ht : t âˆˆ C) (hst : s âŠ† t) :\n    m t = m s + âˆ‘ i âˆˆ hC.disjointOfDiff ht hs, m i := by\n  classical\n  conv_lhs => rw [â† hC.sUnion_insert_disjointOfDiff ht hs hst]\n  rw [â† coe_insert, addContent_sUnion]\n  Â· rw [sum_insert]\n    exact hC.nmem_disjointOfDiff ht hs\n  Â· rw [coe_insert]\n    exact Set.insert_subset hs (hC.subset_disjointOfDiff ht hs)\n  Â· rw [coe_insert]\n    exact hC.pairwiseDisjoint_insert_disjointOfDiff ht hs\n  Â· rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]\n\n"}
{"name":"MeasureTheory.addContent_sUnion_le_sum","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nJ : Finset (Set Î±)\nh_ss : HasSubset.Subset (â†‘J) C\nh_mem : Membership.mem C (â†‘J).sUnion\nâŠ¢ LE.le (m (â†‘J).sUnion) (J.sum fun u => m u)","decl":"/-- An `addContent C` on a `SetSemiring C` is sub-additive.-/\nlemma addContent_sUnion_le_sum {m : AddContent C} (hC : IsSetSemiring C)\n    (J : Finset (Set Î±)) (h_ss : â†‘J âŠ† C) (h_mem : â‹ƒâ‚€ â†‘J âˆˆ C) :\n    m (â‹ƒâ‚€ â†‘J) â‰¤ âˆ‘ u âˆˆ J, m u := by\n  classical\n  have h1 : (disjiUnion J (hC.disjointOfUnion h_ss)\n      (hC.pairwiseDisjoint_disjointOfUnion h_ss) : Set (Set Î±)) âŠ† C := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe, iUnion_subset_iff]\n    exact fun _ x â†¦ hC.disjointOfUnion_subset h_ss x\n  have h2 : PairwiseDisjoint (disjiUnion J (hC.disjointOfUnion h_ss)\n      ((hC.pairwiseDisjoint_disjointOfUnion h_ss)) : Set (Set Î±)) id := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe]\n    exact hC.pairwiseDisjoint_biUnion_disjointOfUnion h_ss\n  have h3 : â‹ƒâ‚€ J = â‹ƒâ‚€ ((disjiUnion J (hC.disjointOfUnion h_ss)\n      (hC.pairwiseDisjoint_disjointOfUnion h_ss)) : Set (Set Î±)) := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe]\n    exact (Exists.choose_spec (hC.disjointOfUnion_props h_ss)).2.2.2.2.2\n  rw [h3, addContent_sUnion h1 h2, sum_disjiUnion]\n  Â· apply sum_le_sum\n    intro x hx\n    refine sum_addContent_le_of_subset hC (hC.disjointOfUnion_subset h_ss hx)\n      (hC.pairwiseDisjoint_disjointOfUnion_of_mem h_ss hx) (h_ss hx)\n      (fun _ s â†¦ hC.subset_of_mem_disjointOfUnion h_ss hx s)\n  Â· simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe] at *\n    exact h3.symm â–¸ h_mem\n\n"}
{"name":"MeasureTheory.addContent_le_sum_of_subset_sUnion","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nt : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nJ : Finset (Set Î±)\nh_ss : HasSubset.Subset (â†‘J) C\nht : Membership.mem C t\nhtJ : HasSubset.Subset t (â†‘J).sUnion\nâŠ¢ LE.le (m t) (J.sum fun u => m u)","decl":"lemma addContent_le_sum_of_subset_sUnion {m : AddContent C} (hC : IsSetSemiring C)\n    {J : Finset (Set Î±)} (h_ss : â†‘J âŠ† C) (ht : t âˆˆ C) (htJ : t âŠ† â‹ƒâ‚€ â†‘J) :\n    m t â‰¤ âˆ‘ u âˆˆ J, m u := by\n  -- we can't apply `addContent_mono` and `addContent_sUnion_le_sum` because `â‹ƒâ‚€ â†‘J` might not\n  -- be in `C`\n  classical\n  let Jt := J.image (fun u â†¦ t âˆ© u)\n  have ht_eq : t = â‹ƒâ‚€ Jt := by\n    rw [coe_image, sUnion_image, â† inter_iUnionâ‚‚, inter_eq_self_of_subset_left]\n    rwa [â† sUnion_eq_biUnion]\n  rw [ht_eq]\n  refine (addContent_sUnion_le_sum hC Jt ?_ ?_).trans ?_\n  Â· intro s\n    simp only [Jt, coe_image, Set.mem_image, mem_coe, forall_exists_index, and_imp]\n    rintro u hu rfl\n    exact hC.inter_mem _ ht _ (h_ss hu)\n  Â· rwa [â† ht_eq]\n  Â· refine (Finset.sum_image_le_of_nonneg fun _ _ â†¦ zero_le _).trans (sum_le_sum fun u hu â†¦ ?_)\n    exact addContent_mono hC (hC.inter_mem _ ht _ (h_ss hu)) (h_ss hu) inter_subset_right\n\n"}
{"name":"MeasureTheory.addContent_iUnion_eq_tsum_of_disjoint_of_addContent_iUnion_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nm_subadd : âˆ€ (f : Nat â†’ Set Î±), (âˆ€ (i : Nat), Membership.mem C (f i)) â†’ Membership.mem C (Set.iUnion fun i => f i) â†’ Pairwise (Function.onFun Disjoint f) â†’ LE.le (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))\nf : Nat â†’ Set Î±\nhf : âˆ€ (i : Nat), Membership.mem C (f i)\nhf_Union : Membership.mem C (Set.iUnion fun i => f i)\nhf_disj : Pairwise (Function.onFun Disjoint f)\nâŠ¢ Eq (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))","decl":"/-- If an `AddContent` is Ïƒ-subadditive on a semi-ring of sets, then it is Ïƒ-additive. -/\ntheorem addContent_iUnion_eq_tsum_of_disjoint_of_addContent_iUnion_le {m : AddContent C}\n    (hC : IsSetSemiring C)\n    (m_subadd : âˆ€ (f : â„• â†’ Set Î±) (_ : âˆ€ i, f i âˆˆ C) (_ : â‹ƒ i, f i âˆˆ C)\n      (_hf_disj : Pairwise (Disjoint on f)), m (â‹ƒ i, f i) â‰¤ âˆ‘' i, m (f i))\n    (f : â„• â†’ Set Î±) (hf : âˆ€ i, f i âˆˆ C) (hf_Union : (â‹ƒ i, f i) âˆˆ C)\n    (hf_disj : Pairwise (Disjoint on f)) :\n    m (â‹ƒ i, f i) = âˆ‘' i, m (f i) := by\n  refine le_antisymm (m_subadd f hf hf_Union hf_disj) ?_\n  refine tsum_le_of_sum_le ENNReal.summable fun I â†¦ ?_\n  classical\n  rw [â† Finset.sum_image_of_disjoint addContent_empty (hf_disj.pairwiseDisjoint _)]\n  refine sum_addContent_le_of_subset hC (I := I.image f) ?_ ?_ hf_Union ?_\n  Â· simp only [coe_image, Set.image_subset_iff]\n    refine (subset_preimage_image f I).trans (preimage_mono ?_)\n    rintro i âŸ¨j, _, rflâŸ©\n    exact hf j\n  Â· simp only [coe_image]\n    intro s hs t ht hst\n    rw [Set.mem_image] at hs ht\n    obtain âŸ¨i, _, rflâŸ© := hs\n    obtain âŸ¨j, _, rflâŸ© := ht\n    have hij : i â‰  j := by intro h_eq; rw [h_eq] at hst; exact hst rfl\n    exact hf_disj hij\n  Â· simp only [Finset.mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iffâ‚‚]\n    exact fun i _ â†¦ subset_iUnion _ i\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq_extend","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\nâŠ¢ Eq (â‡‘(MeasureTheory.AddContent.extend hC m)) (MeasureTheory.extend fun x x_1 => m x)","decl":"protected theorem AddContent.extend_eq_extend (hC : IsSetSemiring C) (m : AddContent C) :\n    m.extend hC = extend (fun x (_ : x âˆˆ C) â†¦ m x) := rfl\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns : Set Î±\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\nhs : Membership.mem C s\nâŠ¢ Eq ((MeasureTheory.AddContent.extend hC m) s) (m s)","decl":"protected theorem AddContent.extend_eq (hC : IsSetSemiring C) (m : AddContent C) (hs : s âˆˆ C) :\n    m.extend hC s = m s := by\n  rwa [m.extend_eq_extend, extend_eq]\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq_top","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns : Set Î±\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\nhs : Not (Membership.mem C s)\nâŠ¢ Eq ((MeasureTheory.AddContent.extend hC m) s) Top.top","decl":"protected theorem AddContent.extend_eq_top (hC : IsSetSemiring C) (m : AddContent C) (hs : s âˆ‰ C) :\n    m.extend hC s = âˆ := by\n  rwa [m.extend_eq_extend, extend_eq_top]\n\n"}
{"name":"MeasureTheory.addContent_union","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\nh_dis : Disjoint s t\nâŠ¢ Eq (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union (hC : IsSetRing C) (hs : s âˆˆ C) (ht : t âˆˆ C)\n    (h_dis : Disjoint s t) :\n    m (s âˆª t) = m s + m t :=\n  addContent_union' hs ht (hC.union_mem hs ht) h_dis\n\n"}
{"name":"MeasureTheory.addContent_union_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\nâŠ¢ LE.le (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union_le (hC : IsSetRing C) (hs : s âˆˆ C) (ht : t âˆˆ C) :\n    m (s âˆª t) â‰¤ m s + m t := by\n  rw [â† union_diff_self, addContent_union hC hs (hC.diff_mem ht hs)]\n  Â· exact add_le_add le_rfl\n      (addContent_mono hC.isSetSemiring (hC.diff_mem ht hs) ht diff_subset)\n  Â· rw [Set.disjoint_iff_inter_eq_empty, inter_diff_self]\n\n"}
{"name":"MeasureTheory.addContent_biUnion_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nÎ¹ : Type u_2\nhC : MeasureTheory.IsSetRing C\ns : Î¹ â†’ Set Î±\nS : Finset Î¹\nhs : âˆ€ (n : Î¹), Membership.mem S n â†’ Membership.mem C (s n)\nâŠ¢ LE.le (m (Set.iUnion fun i => Set.iUnion fun h => s i)) (S.sum fun i => m (s i))","decl":"lemma addContent_biUnion_le {Î¹ : Type*} (hC : IsSetRing C) {s : Î¹ â†’ Set Î±}\n    {S : Finset Î¹} (hs : âˆ€ n âˆˆ S, s n âˆˆ C) :\n    m (â‹ƒ i âˆˆ S, s i) â‰¤ âˆ‘ i âˆˆ S, m (s i) := by\n  classical\n  induction S using Finset.induction with\n  | empty => simp\n  | @insert i S hiS h =>\n    rw [Finset.sum_insert hiS]\n    simp_rw [â† Finset.mem_coe, Finset.coe_insert, Set.biUnion_insert]\n    simp only [Finset.mem_insert, forall_eq_or_imp] at hs\n    refine (addContent_union_le hC hs.1 (hC.biUnion_mem S hs.2)).trans ?_\n    exact add_le_add le_rfl (h hs.2)\n\n"}
{"name":"MeasureTheory.le_addContent_diff","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\ns t : Set Î±\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\nâŠ¢ LE.le (HSub.hSub (m s) (m t)) (m (SDiff.sdiff s t))","decl":"lemma le_addContent_diff (m : AddContent C) (hC : IsSetRing C) (hs : s âˆˆ C) (ht : t âˆˆ C) :\n    m s - m t â‰¤ m (s \\ t) := by\n  conv_lhs => rw [â† inter_union_diff s t]\n  rw [addContent_union hC (hC.inter_mem hs ht) (hC.diff_mem hs ht) disjoint_inf_sdiff, add_comm]\n  refine add_tsub_le_assoc.trans_eq ?_\n  rw [tsub_eq_zero_of_le\n    (addContent_mono hC.isSetSemiring (hC.inter_mem hs ht) ht inter_subset_right), add_zero]\n\n"}
{"name":"MeasureTheory.addContent_diff_of_ne_top","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhm_ne_top : âˆ€ (s : Set Î±), Membership.mem C s â†’ Ne (m s) Top.top\ns t : Set Î±\nhs : Membership.mem C s\nht : Membership.mem C t\nhts : HasSubset.Subset t s\nâŠ¢ Eq (m (SDiff.sdiff s t)) (HSub.hSub (m s) (m t))","decl":"lemma addContent_diff_of_ne_top (m : AddContent C) (hC : IsSetRing C)\n    (hm_ne_top : âˆ€ s âˆˆ C, m s â‰  âˆ)\n    {s t : Set Î±} (hs : s âˆˆ C) (ht : t âˆˆ C) (hts : t âŠ† s) :\n    m (s \\ t) = m s - m t := by\n  have h_union : m (t âˆª s \\ t) = m t + m (s \\ t) :=\n    addContent_union hC ht (hC.diff_mem hs ht) disjoint_sdiff_self_right\n  simp_rw [Set.union_diff_self, Set.union_eq_right.mpr hts] at h_union\n  rw [h_union, ENNReal.add_sub_cancel_left (hm_ne_top _ ht)]\n\n"}
{"name":"MeasureTheory.addContent_accumulate","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\ns : Nat â†’ Set Î±\nhs_disj : Pairwise (Function.onFun Disjoint s)\nhsC : âˆ€ (i : Nat), Membership.mem C (s i)\nn : Nat\nâŠ¢ Eq (m (Set.Accumulate s n)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => m (s i))","decl":"lemma addContent_accumulate (m : AddContent C) (hC : IsSetRing C)\n    {s : â„• â†’ Set Î±} (hs_disj : Pairwise (Disjoint on s)) (hsC : âˆ€ i, s i âˆˆ C) (n : â„•) :\n      m (Set.Accumulate s n) = âˆ‘ i âˆˆ Finset.range (n + 1), m (s i) := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    rw [Finset.sum_range_succ, â† hn, Set.accumulate_succ, addContent_union hC _ (hsC _)]\n    Â· exact Set.disjoint_accumulate hs_disj (Nat.lt_succ_self n)\n    Â· exact hC.accumulate_mem hsC n\n\n"}
{"name":"MeasureTheory.addContent_iUnion_eq_sum_of_tendsto_zero","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"Î± : Type u_1\nC : Set (Set Î±)\nhC : MeasureTheory.IsSetRing C\nm : MeasureTheory.AddContent C\nhm_ne_top : âˆ€ (s : Set Î±), Membership.mem C s â†’ Ne (m s) Top.top\nhm_tendsto : âˆ€ â¦ƒs : Nat â†’ Set Î±â¦„, (âˆ€ (n : Nat), Membership.mem C (s n)) â†’ Antitone s â†’ Eq (Set.iInter fun n => s n) EmptyCollection.emptyCollection â†’ Filter.Tendsto (fun n => m (s n)) Filter.atTop (nhds 0)\nf : Nat â†’ Set Î±\nhf : âˆ€ (i : Nat), Membership.mem C (f i)\nhUf : Membership.mem C (Set.iUnion fun i => f i)\nh_disj : Pairwise (Function.onFun Disjoint f)\nâŠ¢ Eq (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))","decl":"/-- In a ring of sets, continuity of an additive content at `âˆ…` implies Ïƒ-additivity.\nThis is not true in general in semirings, or without the hypothesis that `m` is finite. See the\nexamples 7 and 8 in Halmos' book Measure Theory (1974), page 40. -/\ntheorem addContent_iUnion_eq_sum_of_tendsto_zero (hC : IsSetRing C) (m : AddContent C)\n    (hm_ne_top : âˆ€ s âˆˆ C, m s â‰  âˆ)\n    (hm_tendsto : âˆ€ â¦ƒs : â„• â†’ Set Î±â¦„ (_ : âˆ€ n, s n âˆˆ C),\n      Antitone s â†’ (â‹‚ n, s n) = âˆ… â†’ Tendsto (fun n â†¦ m (s n)) atTop (ğ“ 0))\n    â¦ƒf : â„• â†’ Set Î±â¦„ (hf : âˆ€ i, f i âˆˆ C) (hUf : (â‹ƒ i, f i) âˆˆ C)\n    (h_disj : Pairwise (Disjoint on f)) :\n    m (â‹ƒ i, f i) = âˆ‘' i, m (f i) := by\n  -- We use the continuity of `m` at `âˆ…` on the sequence `n â†¦ (â‹ƒ i, f i) \\ (set.accumulate f n)`\n  let s : â„• â†’ Set Î± := fun n â†¦ (â‹ƒ i, f i) \\ Set.Accumulate f n\n  have hCs n : s n âˆˆ C := hC.diff_mem hUf (hC.accumulate_mem hf n)\n  have h_tendsto : Tendsto (fun n â†¦ m (s n)) atTop (ğ“ 0) := by\n    refine hm_tendsto hCs ?_ ?_\n    Â· intro i j hij x hxj\n      rw [Set.mem_diff] at hxj âŠ¢\n      exact âŸ¨hxj.1, fun hxi â†¦ hxj.2 (Set.monotone_accumulate hij hxi)âŸ©\n    Â· simp_rw [s, Set.diff_eq]\n      rw [Set.iInter_inter_distrib, Set.iInter_const, â† Set.compl_iUnion, Set.iUnion_accumulate]\n      exact Set.inter_compl_self _\n  have hmsn n : m (s n) = m (â‹ƒ i, f i) - âˆ‘ i âˆˆ Finset.range (n + 1), m (f i) := by\n    rw [addContent_diff_of_ne_top m hC hm_ne_top hUf (hC.accumulate_mem hf n)\n      (Set.accumulate_subset_iUnion _), addContent_accumulate m hC h_disj hf n]\n  simp_rw [hmsn] at h_tendsto\n  refine tendsto_nhds_unique ?_ (ENNReal.tendsto_nat_tsum fun i â†¦ m (f i))\n  refine (Filter.tendsto_add_atTop_iff_nat 1).mp ?_\n  rwa [ENNReal.tendsto_const_sub_nhds_zero_iff (hm_ne_top _ hUf) (fun n â†¦ ?_)] at h_tendsto\n  rw [â† addContent_accumulate m hC h_disj hf]\n  exact addContent_mono hC.isSetSemiring (hC.accumulate_mem hf n) hUf\n    (Set.accumulate_subset_iUnion _)\n\n"}
