{"name":"MeasureTheory.AddContent.empty'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.AddContent C\n⊢ Eq (self.toFun EmptyCollection.emptyCollection) 0","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set α)) where\n  /-- The value of the content on a set. -/\n  toFun : Set α → ℝ≥0∞\n  empty' : toFun ∅ = 0\n  sUnion' (I : Finset (Set α)) (_h_ss : ↑I ⊆ C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set α)) id) (_h_mem : ⋃₀ ↑I ∈ C) :\n    toFun (⋃₀ I) = ∑ u ∈ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.inj","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ntoFun✝ : Set α → ENNReal\nempty'✝ : Eq (toFun✝ EmptyCollection.emptyCollection) 0\nsUnion'✝ : ∀ (I : Finset (Set α)), HasSubset.Subset (↑I) C → (↑I).PairwiseDisjoint id → Membership.mem C (↑I).sUnion → Eq (toFun✝ (↑I).sUnion) (I.sum fun u => toFun✝ u)\ntoFun : Set α → ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : ∀ (I : Finset (Set α)), HasSubset.Subset (↑I) C → (↑I).PairwiseDisjoint id → Membership.mem C (↑I).sUnion → Eq (toFun (↑I).sUnion) (I.sum fun u => toFun u)\nx✝ : Eq { toFun := toFun✝, empty' := empty'✝, sUnion' := sUnion'✝ } { toFun := toFun, empty' := empty', sUnion' := sUnion' }\n⊢ Eq toFun✝ toFun","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set α)) where\n  /-- The value of the content on a set. -/\n  toFun : Set α → ℝ≥0∞\n  empty' : toFun ∅ = 0\n  sUnion' (I : Finset (Set α)) (_h_ss : ↑I ⊆ C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set α)) id) (_h_mem : ⋃₀ ↑I ∈ C) :\n    toFun (⋃₀ I) = ∑ u ∈ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ninst✝¹ : SizeOf α\ninst✝ : (a : Set α) → SizeOf (C a)\ntoFun : Set α → ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : ∀ (I : Finset (Set α)), HasSubset.Subset (↑I) C → (↑I).PairwiseDisjoint id → Membership.mem C (↑I).sUnion → Eq (toFun (↑I).sUnion) (I.sum fun u => toFun u)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, empty' := empty', sUnion' := sUnion' }) (HAdd.hAdd 1 (SizeOf.sizeOf empty'))","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set α)) where\n  /-- The value of the content on a set. -/\n  toFun : Set α → ℝ≥0∞\n  empty' : toFun ∅ = 0\n  sUnion' (I : Finset (Set α)) (_h_ss : ↑I ⊆ C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set α)) id) (_h_mem : ⋃₀ ↑I ∈ C) :\n    toFun (⋃₀ I) = ∑ u ∈ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.mk.injEq","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ntoFun✝ : Set α → ENNReal\nempty'✝ : Eq (toFun✝ EmptyCollection.emptyCollection) 0\nsUnion'✝ : ∀ (I : Finset (Set α)), HasSubset.Subset (↑I) C → (↑I).PairwiseDisjoint id → Membership.mem C (↑I).sUnion → Eq (toFun✝ (↑I).sUnion) (I.sum fun u => toFun✝ u)\ntoFun : Set α → ENNReal\nempty' : Eq (toFun EmptyCollection.emptyCollection) 0\nsUnion' : ∀ (I : Finset (Set α)), HasSubset.Subset (↑I) C → (↑I).PairwiseDisjoint id → Membership.mem C (↑I).sUnion → Eq (toFun (↑I).sUnion) (I.sum fun u => toFun u)\n⊢ Eq (Eq { toFun := toFun✝, empty' := empty'✝, sUnion' := sUnion'✝ } { toFun := toFun, empty' := empty', sUnion' := sUnion' }) (Eq toFun✝ toFun)","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set α)) where\n  /-- The value of the content on a set. -/\n  toFun : Set α → ℝ≥0∞\n  empty' : toFun ∅ = 0\n  sUnion' (I : Finset (Set α)) (_h_ss : ↑I ⊆ C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set α)) id) (_h_mem : ⋃₀ ↑I ∈ C) :\n    toFun (⋃₀ I) = ∑ u ∈ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.sUnion'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.AddContent C\nI : Finset (Set α)\n_h_ss : HasSubset.Subset (↑I) C\n_h_dis : (↑I).PairwiseDisjoint id\n_h_mem : Membership.mem C (↑I).sUnion\n⊢ Eq (self.toFun (↑I).sUnion) (I.sum fun u => self.toFun u)","decl":"/-- An additive content is a set function with value 0 at the empty set which is finitely additive\non a given set of sets. -/\nstructure AddContent (C : Set (Set α)) where\n  /-- The value of the content on a set. -/\n  toFun : Set α → ℝ≥0∞\n  empty' : toFun ∅ = 0\n  sUnion' (I : Finset (Set α)) (_h_ss : ↑I ⊆ C)\n      (_h_dis : PairwiseDisjoint (I : Set (Set α)) id) (_h_mem : ⋃₀ ↑I ∈ C) :\n    toFun (⋃₀ I) = ∑ u ∈ I, toFun u\n\n"}
{"name":"MeasureTheory.AddContent.ext","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm m' : MeasureTheory.AddContent C\nh : ∀ (s : Set α), Eq (m s) (m' s)\n⊢ Eq m m'","decl":"@[ext] protected lemma AddContent.ext (h : ∀ s, m s = m' s) : m = m' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.AddContent.ext_iff","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm m' : MeasureTheory.AddContent C\n⊢ Iff (Eq m m') (∀ (s : Set α), Eq (m s) (m' s))","decl":"@[ext] protected lemma AddContent.ext (h : ∀ s, m s = m' s) : m = m' :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"MeasureTheory.addContent_empty","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\n⊢ Eq (m EmptyCollection.emptyCollection) 0","decl":"@[simp] lemma addContent_empty : m ∅ = 0 := m.empty'\n\n"}
{"name":"MeasureTheory.addContent_sUnion","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nI : Finset (Set α)\nm : MeasureTheory.AddContent C\nh_ss : HasSubset.Subset (↑I) C\nh_dis : (↑I).PairwiseDisjoint id\nh_mem : Membership.mem C (↑I).sUnion\n⊢ Eq (m (↑I).sUnion) (I.sum fun u => m u)","decl":"lemma addContent_sUnion (h_ss : ↑I ⊆ C)\n    (h_dis : PairwiseDisjoint (I : Set (Set α)) id) (h_mem : ⋃₀ ↑I ∈ C) :\n    m (⋃₀ I) = ∑ u ∈ I, m u :=\n  m.sUnion' I h_ss h_dis h_mem\n\n"}
{"name":"MeasureTheory.addContent_union'","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : Membership.mem C (Union.union s t)\nh_dis : Disjoint s t\n⊢ Eq (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union' (hs : s ∈ C) (ht : t ∈ C) (hst : s ∪ t ∈ C) (h_dis : Disjoint s t) :\n    m (s ∪ t) = m s + m t := by\n  by_cases hs_empty : s = ∅\n  · simp only [hs_empty, Set.empty_union, addContent_empty, zero_add]\n  classical\n  have h := addContent_sUnion (m := m) (I := {s, t}) ?_ ?_ ?_\n  rotate_left\n  · simp only [coe_pair, Set.insert_subset_iff, hs, ht, Set.singleton_subset_iff, and_self_iff]\n  · simp only [coe_pair, Set.pairwiseDisjoint_insert, pairwiseDisjoint_singleton,\n      mem_singleton_iff, Ne, id, forall_eq, true_and]\n    exact fun _ => h_dis\n  · simp only [coe_pair, sUnion_insert, sUnion_singleton]\n    exact hst\n  convert h\n  · simp only [coe_pair, sUnion_insert, sUnion_singleton]\n  · rw [sum_insert, sum_singleton]\n    simp only [Finset.mem_singleton]\n    refine fun hs_eq_t => hs_empty ?_\n    rw [← hs_eq_t] at h_dis\n    exact Disjoint.eq_bot_of_self h_dis\n\n"}
{"name":"MeasureTheory.addContent_eq_add_disjointOfDiffUnion_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nhI_ss : ∀ (t : Set α), Membership.mem I t → HasSubset.Subset t s\nh_dis : (↑I).PairwiseDisjoint id\n⊢ Eq (m s) (HAdd.hAdd (I.sum fun i => m i) ((hC.disjointOfDiffUnion hs hI).sum fun i => m i))","decl":"lemma addContent_eq_add_disjointOfDiffUnion_of_subset (hC : IsSetSemiring C)\n    (hs : s ∈ C) (hI : ↑I ⊆ C) (hI_ss : ∀ t ∈ I, t ⊆ s)\n    (h_dis : PairwiseDisjoint (I : Set (Set α)) id) :\n    m s = ∑ i ∈ I, m i + ∑ i ∈ hC.disjointOfDiffUnion hs hI, m i := by\n  classical\n  conv_lhs => rw [← hC.sUnion_union_disjointOfDiffUnion_of_subset hs hI hI_ss]\n  rw [addContent_sUnion]\n  · rw [sum_union]\n    exact hC.disjoint_disjointOfDiffUnion hs hI\n  · rw [coe_union]\n    exact Set.union_subset hI (hC.disjointOfDiffUnion_subset hs hI)\n  · rw [coe_union]\n    exact hC.pairwiseDisjoint_union_disjointOfDiffUnion hs hI h_dis\n  · rwa [hC.sUnion_union_disjointOfDiffUnion_of_subset hs hI hI_ss]\n\n"}
{"name":"MeasureTheory.sum_addContent_le_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nt : Set α\nI : Finset (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nh_ss : HasSubset.Subset (↑I) C\nh_dis : (↑I).PairwiseDisjoint id\nht : Membership.mem C t\nhJt : ∀ (s : Set α), Membership.mem I s → HasSubset.Subset s t\n⊢ LE.le (I.sum fun u => m u) (m t)","decl":"/-- For an `m : addContent C` on a `SetSemiring C`, if `I` is a `Finset` of pairwise disjoint\n  sets in `C` and `⋃₀ I ⊆ t` for `t ∈ C`, then `∑ s ∈ I, m s ≤ m t`.-/\nlemma sum_addContent_le_of_subset (hC : IsSetSemiring C)\n    (h_ss : ↑I ⊆ C) (h_dis : PairwiseDisjoint (I : Set (Set α)) id)\n    (ht : t ∈ C) (hJt : ∀ s ∈ I, s ⊆ t) :\n    ∑ u ∈ I, m u ≤ m t := by\n  classical\n  rw [addContent_eq_add_disjointOfDiffUnion_of_subset hC ht h_ss hJt h_dis]\n  exact le_add_right le_rfl\n\n"}
{"name":"MeasureTheory.addContent_mono","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : HasSubset.Subset s t\n⊢ LE.le (m s) (m t)","decl":"/-- An `addContent C` on a `SetSemiring C` is monotone. -/\nlemma addContent_mono (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C)\n    (hst : s ⊆ t) :\n    m s ≤ m t := by\n  have h := sum_addContent_le_of_subset (m := m) hC (I := {s}) ?_ ?_ ht ?_\n  · simpa only [sum_singleton] using h\n  · rwa [singleton_subset_set_iff]\n  · simp only [coe_singleton, pairwiseDisjoint_singleton]\n  · simp [hst]\n\n"}
{"name":"MeasureTheory.eq_add_disjointOfDiff_of_subset","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : HasSubset.Subset s t\n⊢ Eq (m t) (HAdd.hAdd (m s) ((hC.disjointOfDiff ht hs).sum fun i => m i))","decl":"/-- For an `m : addContent C` on a `SetSemiring C` and `s t : Set α` with `s ⊆ t`, we can write\n`m t = m s + ∑ i in hC.disjointOfDiff ht hs, m i`.-/\ntheorem eq_add_disjointOfDiff_of_subset (hC : IsSetSemiring C)\n    (hs : s ∈ C) (ht : t ∈ C) (hst : s ⊆ t) :\n    m t = m s + ∑ i ∈ hC.disjointOfDiff ht hs, m i := by\n  classical\n  conv_lhs => rw [← hC.sUnion_insert_disjointOfDiff ht hs hst]\n  rw [← coe_insert, addContent_sUnion]\n  · rw [sum_insert]\n    exact hC.nmem_disjointOfDiff ht hs\n  · rw [coe_insert]\n    exact Set.insert_subset hs (hC.subset_disjointOfDiff ht hs)\n  · rw [coe_insert]\n    exact hC.pairwiseDisjoint_insert_disjointOfDiff ht hs\n  · rw [coe_insert]\n    rwa [hC.sUnion_insert_disjointOfDiff ht hs hst]\n\n"}
{"name":"MeasureTheory.addContent_sUnion_le_sum","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nJ : Finset (Set α)\nh_ss : HasSubset.Subset (↑J) C\nh_mem : Membership.mem C (↑J).sUnion\n⊢ LE.le (m (↑J).sUnion) (J.sum fun u => m u)","decl":"/-- An `addContent C` on a `SetSemiring C` is sub-additive.-/\nlemma addContent_sUnion_le_sum {m : AddContent C} (hC : IsSetSemiring C)\n    (J : Finset (Set α)) (h_ss : ↑J ⊆ C) (h_mem : ⋃₀ ↑J ∈ C) :\n    m (⋃₀ ↑J) ≤ ∑ u ∈ J, m u := by\n  classical\n  have h1 : (disjiUnion J (hC.disjointOfUnion h_ss)\n      (hC.pairwiseDisjoint_disjointOfUnion h_ss) : Set (Set α)) ⊆ C := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe, iUnion_subset_iff]\n    exact fun _ x ↦ hC.disjointOfUnion_subset h_ss x\n  have h2 : PairwiseDisjoint (disjiUnion J (hC.disjointOfUnion h_ss)\n      ((hC.pairwiseDisjoint_disjointOfUnion h_ss)) : Set (Set α)) id := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe]\n    exact hC.pairwiseDisjoint_biUnion_disjointOfUnion h_ss\n  have h3 : ⋃₀ J = ⋃₀ ((disjiUnion J (hC.disjointOfUnion h_ss)\n      (hC.pairwiseDisjoint_disjointOfUnion h_ss)) : Set (Set α)) := by\n    simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe]\n    exact (Exists.choose_spec (hC.disjointOfUnion_props h_ss)).2.2.2.2.2\n  rw [h3, addContent_sUnion h1 h2, sum_disjiUnion]\n  · apply sum_le_sum\n    intro x hx\n    refine sum_addContent_le_of_subset hC (hC.disjointOfUnion_subset h_ss hx)\n      (hC.pairwiseDisjoint_disjointOfUnion_of_mem h_ss hx) (h_ss hx)\n      (fun _ s ↦ hC.subset_of_mem_disjointOfUnion h_ss hx s)\n  · simp only [disjiUnion_eq_biUnion, coe_biUnion, mem_coe] at *\n    exact h3.symm ▸ h_mem\n\n"}
{"name":"MeasureTheory.addContent_le_sum_of_subset_sUnion","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nt : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nJ : Finset (Set α)\nh_ss : HasSubset.Subset (↑J) C\nht : Membership.mem C t\nhtJ : HasSubset.Subset t (↑J).sUnion\n⊢ LE.le (m t) (J.sum fun u => m u)","decl":"lemma addContent_le_sum_of_subset_sUnion {m : AddContent C} (hC : IsSetSemiring C)\n    {J : Finset (Set α)} (h_ss : ↑J ⊆ C) (ht : t ∈ C) (htJ : t ⊆ ⋃₀ ↑J) :\n    m t ≤ ∑ u ∈ J, m u := by\n  -- we can't apply `addContent_mono` and `addContent_sUnion_le_sum` because `⋃₀ ↑J` might not\n  -- be in `C`\n  classical\n  let Jt := J.image (fun u ↦ t ∩ u)\n  have ht_eq : t = ⋃₀ Jt := by\n    rw [coe_image, sUnion_image, ← inter_iUnion₂, inter_eq_self_of_subset_left]\n    rwa [← sUnion_eq_biUnion]\n  rw [ht_eq]\n  refine (addContent_sUnion_le_sum hC Jt ?_ ?_).trans ?_\n  · intro s\n    simp only [Jt, coe_image, Set.mem_image, mem_coe, forall_exists_index, and_imp]\n    rintro u hu rfl\n    exact hC.inter_mem _ ht _ (h_ss hu)\n  · rwa [← ht_eq]\n  · refine (Finset.sum_image_le_of_nonneg fun _ _ ↦ zero_le _).trans (sum_le_sum fun u hu ↦ ?_)\n    exact addContent_mono hC (hC.inter_mem _ ht _ (h_ss hu)) (h_ss hu) inter_subset_right\n\n"}
{"name":"MeasureTheory.addContent_iUnion_eq_tsum_of_disjoint_of_addContent_iUnion_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetSemiring C\nm_subadd : ∀ (f : Nat → Set α), (∀ (i : Nat), Membership.mem C (f i)) → Membership.mem C (Set.iUnion fun i => f i) → Pairwise (Function.onFun Disjoint f) → LE.le (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))\nf : Nat → Set α\nhf : ∀ (i : Nat), Membership.mem C (f i)\nhf_Union : Membership.mem C (Set.iUnion fun i => f i)\nhf_disj : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))","decl":"/-- If an `AddContent` is σ-subadditive on a semi-ring of sets, then it is σ-additive. -/\ntheorem addContent_iUnion_eq_tsum_of_disjoint_of_addContent_iUnion_le {m : AddContent C}\n    (hC : IsSetSemiring C)\n    (m_subadd : ∀ (f : ℕ → Set α) (_ : ∀ i, f i ∈ C) (_ : ⋃ i, f i ∈ C)\n      (_hf_disj : Pairwise (Disjoint on f)), m (⋃ i, f i) ≤ ∑' i, m (f i))\n    (f : ℕ → Set α) (hf : ∀ i, f i ∈ C) (hf_Union : (⋃ i, f i) ∈ C)\n    (hf_disj : Pairwise (Disjoint on f)) :\n    m (⋃ i, f i) = ∑' i, m (f i) := by\n  refine le_antisymm (m_subadd f hf hf_Union hf_disj) ?_\n  refine tsum_le_of_sum_le ENNReal.summable fun I ↦ ?_\n  classical\n  rw [← Finset.sum_image_of_disjoint addContent_empty (hf_disj.pairwiseDisjoint _)]\n  refine sum_addContent_le_of_subset hC (I := I.image f) ?_ ?_ hf_Union ?_\n  · simp only [coe_image, Set.image_subset_iff]\n    refine (subset_preimage_image f I).trans (preimage_mono ?_)\n    rintro i ⟨j, _, rfl⟩\n    exact hf j\n  · simp only [coe_image]\n    intro s hs t ht hst\n    rw [Set.mem_image] at hs ht\n    obtain ⟨i, _, rfl⟩ := hs\n    obtain ⟨j, _, rfl⟩ := ht\n    have hij : i ≠ j := by intro h_eq; rw [h_eq] at hst; exact hst rfl\n    exact hf_disj hij\n  · simp only [Finset.mem_image, forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]\n    exact fun i _ ↦ subset_iUnion _ i\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq_extend","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\n⊢ Eq (⇑(MeasureTheory.AddContent.extend hC m)) (MeasureTheory.extend fun x x_1 => m x)","decl":"protected theorem AddContent.extend_eq_extend (hC : IsSetSemiring C) (m : AddContent C) :\n    m.extend hC = extend (fun x (_ : x ∈ C) ↦ m x) := rfl\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\nhs : Membership.mem C s\n⊢ Eq ((MeasureTheory.AddContent.extend hC m) s) (m s)","decl":"protected theorem AddContent.extend_eq (hC : IsSetSemiring C) (m : AddContent C) (hs : s ∈ C) :\n    m.extend hC s = m s := by\n  rwa [m.extend_eq_extend, extend_eq]\n\n"}
{"name":"MeasureTheory.AddContent.extend_eq_top","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nhC : MeasureTheory.IsSetSemiring C\nm : MeasureTheory.AddContent C\nhs : Not (Membership.mem C s)\n⊢ Eq ((MeasureTheory.AddContent.extend hC m) s) Top.top","decl":"protected theorem AddContent.extend_eq_top (hC : IsSetSemiring C) (m : AddContent C) (hs : s ∉ C) :\n    m.extend hC s = ∞ := by\n  rwa [m.extend_eq_extend, extend_eq_top]\n\n"}
{"name":"MeasureTheory.addContent_union","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\nh_dis : Disjoint s t\n⊢ Eq (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union (hC : IsSetRing C) (hs : s ∈ C) (ht : t ∈ C)\n    (h_dis : Disjoint s t) :\n    m (s ∪ t) = m s + m t :=\n  addContent_union' hs ht (hC.union_mem hs ht) h_dis\n\n"}
{"name":"MeasureTheory.addContent_union_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ LE.le (m (Union.union s t)) (HAdd.hAdd (m s) (m t))","decl":"lemma addContent_union_le (hC : IsSetRing C) (hs : s ∈ C) (ht : t ∈ C) :\n    m (s ∪ t) ≤ m s + m t := by\n  rw [← union_diff_self, addContent_union hC hs (hC.diff_mem ht hs)]\n  · exact add_le_add le_rfl\n      (addContent_mono hC.isSetSemiring (hC.diff_mem ht hs) ht diff_subset)\n  · rw [Set.disjoint_iff_inter_eq_empty, inter_diff_self]\n\n"}
{"name":"MeasureTheory.addContent_biUnion_le","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\nι : Type u_2\nhC : MeasureTheory.IsSetRing C\ns : ι → Set α\nS : Finset ι\nhs : ∀ (n : ι), Membership.mem S n → Membership.mem C (s n)\n⊢ LE.le (m (Set.iUnion fun i => Set.iUnion fun h => s i)) (S.sum fun i => m (s i))","decl":"lemma addContent_biUnion_le {ι : Type*} (hC : IsSetRing C) {s : ι → Set α}\n    {S : Finset ι} (hs : ∀ n ∈ S, s n ∈ C) :\n    m (⋃ i ∈ S, s i) ≤ ∑ i ∈ S, m (s i) := by\n  classical\n  induction S using Finset.induction with\n  | empty => simp\n  | @insert i S hiS h =>\n    rw [Finset.sum_insert hiS]\n    simp_rw [← Finset.mem_coe, Finset.coe_insert, Set.biUnion_insert]\n    simp only [Finset.mem_insert, forall_eq_or_imp] at hs\n    refine (addContent_union_le hC hs.1 (hC.biUnion_mem S hs.2)).trans ?_\n    exact add_le_add le_rfl (h hs.2)\n\n"}
{"name":"MeasureTheory.le_addContent_diff","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ LE.le (HSub.hSub (m s) (m t)) (m (SDiff.sdiff s t))","decl":"lemma le_addContent_diff (m : AddContent C) (hC : IsSetRing C) (hs : s ∈ C) (ht : t ∈ C) :\n    m s - m t ≤ m (s \\ t) := by\n  conv_lhs => rw [← inter_union_diff s t]\n  rw [addContent_union hC (hC.inter_mem hs ht) (hC.diff_mem hs ht) disjoint_inf_sdiff, add_comm]\n  refine add_tsub_le_assoc.trans_eq ?_\n  rw [tsub_eq_zero_of_le\n    (addContent_mono hC.isSetSemiring (hC.inter_mem hs ht) ht inter_subset_right), add_zero]\n\n"}
{"name":"MeasureTheory.addContent_diff_of_ne_top","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\nhm_ne_top : ∀ (s : Set α), Membership.mem C s → Ne (m s) Top.top\ns t : Set α\nhs : Membership.mem C s\nht : Membership.mem C t\nhts : HasSubset.Subset t s\n⊢ Eq (m (SDiff.sdiff s t)) (HSub.hSub (m s) (m t))","decl":"lemma addContent_diff_of_ne_top (m : AddContent C) (hC : IsSetRing C)\n    (hm_ne_top : ∀ s ∈ C, m s ≠ ∞)\n    {s t : Set α} (hs : s ∈ C) (ht : t ∈ C) (hts : t ⊆ s) :\n    m (s \\ t) = m s - m t := by\n  have h_union : m (t ∪ s \\ t) = m t + m (s \\ t) :=\n    addContent_union hC ht (hC.diff_mem hs ht) disjoint_sdiff_self_right\n  simp_rw [Set.union_diff_self, Set.union_eq_right.mpr hts] at h_union\n  rw [h_union, ENNReal.add_sub_cancel_left (hm_ne_top _ ht)]\n\n"}
{"name":"MeasureTheory.addContent_accumulate","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nm : MeasureTheory.AddContent C\nhC : MeasureTheory.IsSetRing C\ns : Nat → Set α\nhs_disj : Pairwise (Function.onFun Disjoint s)\nhsC : ∀ (i : Nat), Membership.mem C (s i)\nn : Nat\n⊢ Eq (m (Set.Accumulate s n)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => m (s i))","decl":"lemma addContent_accumulate (m : AddContent C) (hC : IsSetRing C)\n    {s : ℕ → Set α} (hs_disj : Pairwise (Disjoint on s)) (hsC : ∀ i, s i ∈ C) (n : ℕ) :\n      m (Set.Accumulate s n) = ∑ i ∈ Finset.range (n + 1), m (s i) := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    rw [Finset.sum_range_succ, ← hn, Set.accumulate_succ, addContent_union hC _ (hsC _)]\n    · exact Set.disjoint_accumulate hs_disj (Nat.lt_succ_self n)\n    · exact hC.accumulate_mem hsC n\n\n"}
{"name":"MeasureTheory.addContent_iUnion_eq_sum_of_tendsto_zero","module":"Mathlib.MeasureTheory.Measure.AddContent","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\nm : MeasureTheory.AddContent C\nhm_ne_top : ∀ (s : Set α), Membership.mem C s → Ne (m s) Top.top\nhm_tendsto : ∀ ⦃s : Nat → Set α⦄, (∀ (n : Nat), Membership.mem C (s n)) → Antitone s → Eq (Set.iInter fun n => s n) EmptyCollection.emptyCollection → Filter.Tendsto (fun n => m (s n)) Filter.atTop (nhds 0)\nf : Nat → Set α\nhf : ∀ (i : Nat), Membership.mem C (f i)\nhUf : Membership.mem C (Set.iUnion fun i => f i)\nh_disj : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (m (Set.iUnion fun i => f i)) (tsum fun i => m (f i))","decl":"/-- In a ring of sets, continuity of an additive content at `∅` implies σ-additivity.\nThis is not true in general in semirings, or without the hypothesis that `m` is finite. See the\nexamples 7 and 8 in Halmos' book Measure Theory (1974), page 40. -/\ntheorem addContent_iUnion_eq_sum_of_tendsto_zero (hC : IsSetRing C) (m : AddContent C)\n    (hm_ne_top : ∀ s ∈ C, m s ≠ ∞)\n    (hm_tendsto : ∀ ⦃s : ℕ → Set α⦄ (_ : ∀ n, s n ∈ C),\n      Antitone s → (⋂ n, s n) = ∅ → Tendsto (fun n ↦ m (s n)) atTop (𝓝 0))\n    ⦃f : ℕ → Set α⦄ (hf : ∀ i, f i ∈ C) (hUf : (⋃ i, f i) ∈ C)\n    (h_disj : Pairwise (Disjoint on f)) :\n    m (⋃ i, f i) = ∑' i, m (f i) := by\n  -- We use the continuity of `m` at `∅` on the sequence `n ↦ (⋃ i, f i) \\ (set.accumulate f n)`\n  let s : ℕ → Set α := fun n ↦ (⋃ i, f i) \\ Set.Accumulate f n\n  have hCs n : s n ∈ C := hC.diff_mem hUf (hC.accumulate_mem hf n)\n  have h_tendsto : Tendsto (fun n ↦ m (s n)) atTop (𝓝 0) := by\n    refine hm_tendsto hCs ?_ ?_\n    · intro i j hij x hxj\n      rw [Set.mem_diff] at hxj ⊢\n      exact ⟨hxj.1, fun hxi ↦ hxj.2 (Set.monotone_accumulate hij hxi)⟩\n    · simp_rw [s, Set.diff_eq]\n      rw [Set.iInter_inter_distrib, Set.iInter_const, ← Set.compl_iUnion, Set.iUnion_accumulate]\n      exact Set.inter_compl_self _\n  have hmsn n : m (s n) = m (⋃ i, f i) - ∑ i ∈ Finset.range (n + 1), m (f i) := by\n    rw [addContent_diff_of_ne_top m hC hm_ne_top hUf (hC.accumulate_mem hf n)\n      (Set.accumulate_subset_iUnion _), addContent_accumulate m hC h_disj hf n]\n  simp_rw [hmsn] at h_tendsto\n  refine tendsto_nhds_unique ?_ (ENNReal.tendsto_nat_tsum fun i ↦ m (f i))\n  refine (Filter.tendsto_add_atTop_iff_nat 1).mp ?_\n  rwa [ENNReal.tendsto_const_sub_nhds_zero_iff (hm_ne_top _ hUf) (fun n ↦ ?_)] at h_tendsto\n  rw [← addContent_accumulate m hC h_disj hf]\n  exact addContent_mono hC.isSetSemiring (hC.accumulate_mem hf n) hUf\n    (Set.accumulate_subset_iUnion _)\n\n"}
