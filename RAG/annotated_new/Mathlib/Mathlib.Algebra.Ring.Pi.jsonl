{"name":"Pi.nonUnitalRingHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → NonUnitalNonAssocSemiring (f i)\ninst✝ : NonUnitalNonAssocSemiring γ\ng : (i : I) → NonUnitalRingHom γ (f i)\nx : γ\nb : I\n⊢ Eq ((Pi.nonUnitalRingHom g) x b) ((g b) x)","decl":"/-- A family of non-unital ring homomorphisms `f a : γ →ₙ+* β a` defines a non-unital ring\nhomomorphism `Pi.nonUnitalRingHom f : γ →+* Π a, β a` given by\n`Pi.nonUnitalRingHom f x b = f b x`. -/\n@[simps]\nprotected def nonUnitalRingHom {γ : Type w} [∀ i, NonUnitalNonAssocSemiring (f i)]\n    [NonUnitalNonAssocSemiring γ] (g : ∀ i, γ →ₙ+* f i) : γ →ₙ+* ∀ i, f i :=\n  { Pi.mulHom fun i => (g i).toMulHom, Pi.addMonoidHom fun i => (g i).toAddMonoidHom with\n    toFun := fun x b => g b x }\n\n"}
{"name":"Pi.nonUnitalRingHom_injective","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → NonUnitalNonAssocSemiring (f i)\ninst✝ : NonUnitalNonAssocSemiring γ\ng : (i : I) → NonUnitalRingHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.nonUnitalRingHom g)","decl":"theorem nonUnitalRingHom_injective {γ : Type w} [Nonempty I]\n    [∀ i, NonUnitalNonAssocSemiring (f i)] [NonUnitalNonAssocSemiring γ] (g : ∀ i, γ →ₙ+* f i)\n    (hg : ∀ i, Function.Injective (g i)) : Function.Injective (Pi.nonUnitalRingHom g) :=\n  mulHom_injective (fun i => (g i).toMulHom) hg\n\n"}
{"name":"Pi.ringHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝¹ : (i : I) → NonAssocSemiring (f i)\ninst✝ : NonAssocSemiring γ\ng : (i : I) → RingHom γ (f i)\nx : γ\nb : I\n⊢ Eq ((Pi.ringHom g) x b) ((g b) x)","decl":"/-- A family of ring homomorphisms `f a : γ →+* β a` defines a ring homomorphism\n`Pi.ringHom f : γ →+* Π a, β a` given by `Pi.ringHom f x b = f b x`. -/\n@[simps]\nprotected def ringHom {γ : Type w} [∀ i, NonAssocSemiring (f i)] [NonAssocSemiring γ]\n    (g : ∀ i, γ →+* f i) : γ →+* ∀ i, f i :=\n  { Pi.monoidHom fun i => (g i).toMonoidHom, Pi.addMonoidHom fun i => (g i).toAddMonoidHom with\n    toFun := fun x b => g b x }\n\n"}
{"name":"Pi.ringHom_injective","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\nγ : Type w\ninst✝² : Nonempty I\ninst✝¹ : (i : I) → NonAssocSemiring (f i)\ninst✝ : NonAssocSemiring γ\ng : (i : I) → RingHom γ (f i)\nhg : ∀ (i : I), Function.Injective ⇑(g i)\n⊢ Function.Injective ⇑(Pi.ringHom g)","decl":"theorem ringHom_injective {γ : Type w} [Nonempty I] [∀ i, NonAssocSemiring (f i)]\n    [NonAssocSemiring γ] (g : ∀ i, γ →+* f i) (hg : ∀ i, Function.Injective (g i)) :\n    Function.Injective (Pi.ringHom g) :=\n  monoidHom_injective (fun i => (g i).toMonoidHom) hg\n\n"}
{"name":"Pi.evalNonUnitalRingHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → NonUnitalNonAssocSemiring (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalNonUnitalRingHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of non-unital rings at a point is a\nnon-unital ring homomorphism. This is `Function.eval` as a `NonUnitalRingHom`. -/\n@[simps!]\ndef Pi.evalNonUnitalRingHom (f : I → Type v) [∀ i, NonUnitalNonAssocSemiring (f i)] (i : I) :\n    (∀ i, f i) →ₙ+* f i :=\n  { Pi.evalMulHom f i, Pi.evalAddMonoidHom f i with }\n\n"}
{"name":"Pi.constNonUnitalRingHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : NonUnitalNonAssocSemiring β\na : β\na✝ : α\n⊢ Eq ((Pi.constNonUnitalRingHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `NonUnitalRingHom`. -/\n@[simps]\ndef Pi.constNonUnitalRingHom (α β : Type*) [NonUnitalNonAssocSemiring β] : β →ₙ+* α → β :=\n  { Pi.nonUnitalRingHom fun _ => NonUnitalRingHom.id β with toFun := Function.const _ }\n\n"}
{"name":"NonUnitalRingHom.compLeft_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : NonUnitalNonAssocSemiring α\ninst✝ : NonUnitalNonAssocSemiring β\nf : NonUnitalRingHom α β\nI : Type u_3\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Non-unital ring homomorphism between the function spaces `I → α` and `I → β`, induced by a\nnon-unital ring homomorphism `f` between `α` and `β`. -/\n@[simps]\nprotected def NonUnitalRingHom.compLeft {α β : Type*} [NonUnitalNonAssocSemiring α]\n    [NonUnitalNonAssocSemiring β] (f : α →ₙ+* β) (I : Type*) : (I → α) →ₙ+* I → β :=\n  { f.toMulHom.compLeft I, f.toAddMonoidHom.compLeft I with toFun := fun h => f ∘ h }\n\n"}
{"name":"Pi.evalRingHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type v\ninst✝ : (i : I) → NonAssocSemiring (f i)\ni : I\ng : (i : I) → f i\n⊢ Eq ((Pi.evalRingHom f i) g) (g i)","decl":"/-- Evaluation of functions into an indexed collection of rings at a point is a ring\nhomomorphism. This is `Function.eval` as a `RingHom`. -/\n@[simps!]\ndef Pi.evalRingHom (f : I → Type v) [∀ i, NonAssocSemiring (f i)] (i : I) : (∀ i, f i) →+* f i :=\n  { Pi.evalMonoidHom f i, Pi.evalAddMonoidHom f i with }\n\n"}
{"name":"instRingHomSurjectiveForallEvalRingHom","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"I : Type u\nf : I → Type u_1\ninst✝ : (i : I) → Semiring (f i)\ni : I\n⊢ RingHomSurjective (Pi.evalRingHom f i)","decl":"instance (f : I → Type*) [∀ i, Semiring (f i)] (i) :\n    RingHomSurjective (Pi.evalRingHom f i) where\n  is_surjective x := ⟨by classical exact (if h : · = i then h ▸ x else 0), by simp⟩\n\n"}
{"name":"Pi.constRingHom_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : NonAssocSemiring β\na : β\na✝ : α\n⊢ Eq ((Pi.constRingHom α β) a a✝) (Function.const α a a✝)","decl":"/-- `Function.const` as a `RingHom`. -/\n@[simps]\ndef Pi.constRingHom (α β : Type*) [NonAssocSemiring β] : β →+* α → β :=\n  { Pi.ringHom fun _ => RingHom.id β with toFun := Function.const _ }\n\n"}
{"name":"RingHom.compLeft_apply","module":"Mathlib.Algebra.Ring.Pi","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : NonAssocSemiring β\nf : RingHom α β\nI : Type u_3\nh : I → α\na✝ : I\n⊢ Eq ((f.compLeft I) h a✝) (Function.comp (⇑f) h a✝)","decl":"/-- Ring homomorphism between the function spaces `I → α` and `I → β`, induced by a ring\nhomomorphism `f` between `α` and `β`. -/\n@[simps]\nprotected def RingHom.compLeft {α β : Type*} [NonAssocSemiring α] [NonAssocSemiring β]\n    (f : α →+* β) (I : Type*) : (I → α) →+* I → β :=\n  { f.toMonoidHom.compLeft I, f.toAddMonoidHom.compLeft I with toFun := fun h => f ∘ h }\n\n"}
