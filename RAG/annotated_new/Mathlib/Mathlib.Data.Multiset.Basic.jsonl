{"name":"Multiset.quot_mk_to_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Quotient.mk (List.isSetoid α) l) ↑l","decl":"@[simp]\ntheorem quot_mk_to_coe (l : List α) : @Eq (Multiset α) ⟦l⟧ l :=\n  rfl\n\n"}
{"name":"Multiset.quot_mk_to_coe'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Quot.mk (fun x1 x2 => HasEquiv.Equiv x1 x2) l) ↑l","decl":"@[simp]\ntheorem quot_mk_to_coe' (l : List α) : @Eq (Multiset α) (Quot.mk (· ≈ ·) l) l :=\n  rfl\n\n"}
{"name":"Multiset.quot_mk_to_coe''","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Quot.mk (⇑(List.isSetoid α)) l) ↑l","decl":"@[simp]\ntheorem quot_mk_to_coe'' (l : List α) : @Eq (Multiset α) (Quot.mk Setoid.r l) l :=\n  rfl\n\n"}
{"name":"Multiset.lift_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nx : List α\nf : List α → β\nh : ∀ (a b : List α), HasEquiv.Equiv a b → Eq (f a) (f b)\n⊢ Eq (Quotient.lift f h ↑x) (f x)","decl":"@[simp]\ntheorem lift_coe {α β : Type*} (x : List α) (f : List α → β)\n    (h : ∀ a b : List α, a ≈ b → f a = f b) : Quotient.lift f h (x : Multiset α) = f x :=\n  Quotient.lift_mk _ _ _\n\n"}
{"name":"Multiset.coe_eq_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (Eq ↑l₁ ↑l₂) (l₁.Perm l₂)","decl":"@[simp]\ntheorem coe_eq_coe {l₁ l₂ : List α} : (l₁ : Multiset α) = l₂ ↔ l₁ ~ l₂ :=\n  Quotient.eq\n\n-- Porting note: new instance;\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: move to better place\n"}
{"name":"Multiset.coe_nil","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq (↑List.nil) 0","decl":"@[simp]\ntheorem coe_nil : (@nil α : Multiset α) = 0 :=\n  rfl\n\n"}
{"name":"Multiset.empty_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq EmptyCollection.emptyCollection 0","decl":"@[simp]\ntheorem empty_eq_zero : (∅ : Multiset α) = 0 :=\n  rfl\n\n"}
{"name":"Multiset.coe_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (Eq (↑l) 0) (Eq l List.nil)","decl":"@[simp]\ntheorem coe_eq_zero (l : List α) : (l : Multiset α) = 0 ↔ l = [] :=\n  Iff.trans coe_eq_coe perm_nil\n\n"}
{"name":"Multiset.coe_eq_zero_iff_isEmpty","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Iff (Eq (↑l) 0) (Eq l.isEmpty Bool.true)","decl":"theorem coe_eq_zero_iff_isEmpty (l : List α) : (l : Multiset α) = 0 ↔ l.isEmpty :=\n  Iff.trans (coe_eq_zero l) isEmpty_iff.symm\n\n"}
{"name":"Multiset.insert_eq_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Eq (Insert.insert a s) (Multiset.cons a s)","decl":"@[simp]\ntheorem insert_eq_cons (a : α) (s : Multiset α) : insert a s = a ::ₘ s :=\n  rfl\n\n"}
{"name":"Multiset.cons_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Eq (Multiset.cons a ↑l) ↑(List.cons a l)","decl":"@[simp]\ntheorem cons_coe (a : α) (l : List α) : (a ::ₘ l : Multiset α) = (a :: l : List α) :=\n  rfl\n\n"}
{"name":"Multiset.cons_inj_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\ns : Multiset α\n⊢ Iff (Eq (Multiset.cons a s) (Multiset.cons b s)) (Eq a b)","decl":"@[simp]\ntheorem cons_inj_left {a b : α} (s : Multiset α) : a ::ₘ s = b ::ₘ s ↔ a = b :=\n  ⟨Quot.inductionOn s fun l e =>\n      have : [a] ++ l ~ [b] ++ l := Quotient.exact e\n      singleton_perm_singleton.1 <| (perm_append_right_iff _).1 this,\n    congr_arg (· ::ₘ _)⟩\n\n"}
{"name":"Multiset.cons_inj_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Iff (Eq (Multiset.cons a s) (Multiset.cons a t)) (Eq s t)","decl":"@[simp]\ntheorem cons_inj_right (a : α) : ∀ {s t : Multiset α}, a ::ₘ s = a ::ₘ t ↔ s = t := by\n  rintro ⟨l₁⟩ ⟨l₂⟩; simp\n\n"}
{"name":"Multiset.induction","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Prop\nempty : p 0\ncons : ∀ (a : α) (s : Multiset α), p s → p (Multiset.cons a s)\ns : Multiset α\n⊢ p s","decl":"@[elab_as_elim]\nprotected theorem induction {p : Multiset α → Prop} (empty : p 0)\n    (cons : ∀ (a : α) (s : Multiset α), p s → p (a ::ₘ s)) : ∀ s, p s := by\n  rintro ⟨l⟩; induction l with | nil => exact empty | cons _ _ ih => exact cons _ _ ih\n\n"}
{"name":"Multiset.induction_on","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Prop\ns : Multiset α\nempty : p 0\ncons : ∀ (a : α) (s : Multiset α), p s → p (Multiset.cons a s)\n⊢ p s","decl":"@[elab_as_elim]\nprotected theorem induction_on {p : Multiset α → Prop} (s : Multiset α) (empty : p 0)\n    (cons : ∀ (a : α) (s : Multiset α), p s → p (a ::ₘ s)) : p s :=\n  Multiset.induction empty cons s\n\n"}
{"name":"Multiset.cons_swap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\ns : Multiset α\n⊢ Eq (Multiset.cons a (Multiset.cons b s)) (Multiset.cons b (Multiset.cons a s))","decl":"theorem cons_swap (a b : α) (s : Multiset α) : a ::ₘ b ::ₘ s = b ::ₘ a ::ₘ s :=\n  Quot.inductionOn s fun _ => Quotient.sound <| Perm.swap _ _ _\n\n"}
{"name":"Multiset.recOn_0","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nC : Multiset α → Sort u_3\nC_0 : C 0\nC_cons : (a : α) → (m : Multiset α) → C m → C (Multiset.cons a m)\nC_cons_heq : ∀ (a a' : α) (m : Multiset α) (b : C m), HEq (C_cons a (Multiset.cons a' m) (C_cons a' m b)) (C_cons a' (Multiset.cons a m) (C_cons a m b))\n⊢ Eq (Multiset.recOn 0 C_0 C_cons C_cons_heq) C_0","decl":"@[simp]\ntheorem recOn_0 : @Multiset.recOn α C (0 : Multiset α) C_0 C_cons C_cons_heq = C_0 :=\n  rfl\n\n"}
{"name":"Multiset.recOn_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nC : Multiset α → Sort u_3\nC_0 : C 0\nC_cons : (a : α) → (m : Multiset α) → C m → C (Multiset.cons a m)\nC_cons_heq : ∀ (a a' : α) (m : Multiset α) (b : C m), HEq (C_cons a (Multiset.cons a' m) (C_cons a' m b)) (C_cons a' (Multiset.cons a m) (C_cons a m b))\na : α\nm : Multiset α\n⊢ Eq ((Multiset.cons a m).recOn C_0 C_cons C_cons_heq) (C_cons a m (m.recOn C_0 C_cons C_cons_heq))","decl":"@[simp]\ntheorem recOn_cons (a : α) (m : Multiset α) :\n    (a ::ₘ m).recOn C_0 C_cons C_cons_heq = C_cons a m (m.recOn C_0 C_cons C_cons_heq) :=\n  Quotient.inductionOn m fun _ => rfl\n\n"}
{"name":"Multiset.mem_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Iff (Membership.mem (↑l) a) (Membership.mem l a)","decl":"@[simp]\ntheorem mem_coe {a : α} {l : List α} : a ∈ (l : Multiset α) ↔ a ∈ l :=\n  Iff.rfl\n\n"}
{"name":"Multiset.mem_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.cons b s) a) (Or (Eq a b) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_cons {a b : α} {s : Multiset α} : a ∈ b ::ₘ s ↔ a = b ∨ a ∈ s :=\n  Quot.inductionOn s fun _ => List.mem_cons\n\n"}
{"name":"Multiset.mem_cons_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\ns : Multiset α\nh : Membership.mem s a\n⊢ Membership.mem (Multiset.cons b s) a","decl":"theorem mem_cons_of_mem {a b : α} {s : Multiset α} (h : a ∈ s) : a ∈ b ::ₘ s :=\n  mem_cons.2 <| Or.inr h\n\n"}
{"name":"Multiset.mem_cons_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Membership.mem (Multiset.cons a s) a","decl":"theorem mem_cons_self (a : α) (s : Multiset α) : a ∈ a ::ₘ s :=\n  mem_cons.2 (Or.inl rfl)\n\n"}
{"name":"Multiset.forall_mem_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\na : α\ns : Multiset α\n⊢ Iff (∀ (x : α), Membership.mem (Multiset.cons a s) x → p x) (And (p a) (∀ (x : α), Membership.mem s x → p x))","decl":"theorem forall_mem_cons {p : α → Prop} {a : α} {s : Multiset α} :\n    (∀ x ∈ a ::ₘ s, p x) ↔ p a ∧ ∀ x ∈ s, p x :=\n  Quotient.inductionOn' s fun _ => List.forall_mem_cons\n\n"}
{"name":"Multiset.exists_cons_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\na✝ : Membership.mem s a\n⊢ Exists fun t => Eq s (Multiset.cons a t)","decl":"theorem exists_cons_of_mem {s : Multiset α} {a : α} : a ∈ s → ∃ t, s = a ::ₘ t :=\n  Quot.inductionOn s fun l (h : a ∈ l) =>\n    let ⟨l₁, l₂, e⟩ := append_of_mem h\n    e.symm ▸ ⟨(l₁ ++ l₂ : List α), Quot.sound perm_middle⟩\n\n"}
{"name":"Multiset.not_mem_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Not (Membership.mem 0 a)","decl":"@[simp]\ntheorem not_mem_zero (a : α) : a ∉ (0 : Multiset α) :=\n  List.not_mem_nil _\n\n"}
{"name":"Multiset.eq_zero_of_forall_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na✝ : ∀ (x : α), Not (Membership.mem s x)\n⊢ Eq s 0","decl":"theorem eq_zero_of_forall_not_mem {s : Multiset α} : (∀ x, x ∉ s) → s = 0 :=\n  Quot.inductionOn s fun l H => by rw [eq_nil_iff_forall_not_mem.mpr H]; rfl\n\n"}
{"name":"Multiset.eq_zero_iff_forall_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s 0) (∀ (a : α), Not (Membership.mem s a))","decl":"theorem eq_zero_iff_forall_not_mem {s : Multiset α} : s = 0 ↔ ∀ a, a ∉ s :=\n  ⟨fun h => h.symm ▸ fun _ => not_mem_zero _, eq_zero_of_forall_not_mem⟩\n\n"}
{"name":"Multiset.exists_mem_of_ne_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na✝ : Ne s 0\n⊢ Exists fun a => Membership.mem s a","decl":"theorem exists_mem_of_ne_zero {s : Multiset α} : s ≠ 0 → ∃ a : α, a ∈ s :=\n  Quot.inductionOn s fun l hl =>\n    match l, hl with\n    | [], h => False.elim <| h rfl\n    | a :: l, _ => ⟨a, by simp⟩\n\n"}
{"name":"Multiset.empty_or_exists_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Or (Eq s 0) (Exists fun a => Membership.mem s a)","decl":"theorem empty_or_exists_mem (s : Multiset α) : s = 0 ∨ ∃ a, a ∈ s :=\n  or_iff_not_imp_left.mpr Multiset.exists_mem_of_ne_zero\n\n"}
{"name":"Multiset.zero_ne_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nm : Multiset α\n⊢ Ne 0 (Multiset.cons a m)","decl":"@[simp]\ntheorem zero_ne_cons {a : α} {m : Multiset α} : 0 ≠ a ::ₘ m := fun h =>\n  have : a ∈ (0 : Multiset α) := h.symm ▸ mem_cons_self _ _\n  not_mem_zero _ this\n\n"}
{"name":"Multiset.cons_ne_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nm : Multiset α\n⊢ Ne (Multiset.cons a m) 0","decl":"@[simp]\ntheorem cons_ne_zero {a : α} {m : Multiset α} : a ::ₘ m ≠ 0 :=\n  zero_ne_cons.symm\n\n"}
{"name":"Multiset.cons_eq_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\nas bs : Multiset α\n⊢ Iff (Eq (Multiset.cons a as) (Multiset.cons b bs)) (Or (And (Eq a b) (Eq as bs)) (And (Ne a b) (Exists fun cs => And (Eq as (Multiset.cons b cs)) (Eq bs (Multiset.cons a cs)))))","decl":"theorem cons_eq_cons {a b : α} {as bs : Multiset α} :\n    a ::ₘ as = b ::ₘ bs ↔ a = b ∧ as = bs ∨ a ≠ b ∧ ∃ cs, as = b ::ₘ cs ∧ bs = a ::ₘ cs := by\n  haveI : DecidableEq α := Classical.decEq α\n  constructor\n  · intro eq\n    by_cases h : a = b\n    · subst h\n      simp_all\n    · have : a ∈ b ::ₘ bs := eq ▸ mem_cons_self _ _\n      have : a ∈ bs := by simpa [h]\n      rcases exists_cons_of_mem this with ⟨cs, hcs⟩\n      simp only [h, hcs, false_and, ne_eq, not_false_eq_true, cons_inj_right, exists_eq_right',\n        true_and, false_or]\n      have : a ::ₘ as = b ::ₘ a ::ₘ cs := by simp [eq, hcs]\n      have : a ::ₘ as = a ::ₘ b ::ₘ cs := by rwa [cons_swap]\n      simpa using this\n  · intro h\n    rcases h with (⟨eq₁, eq₂⟩ | ⟨_, cs, eq₁, eq₂⟩)\n    · simp [*]\n    · simp [*, cons_swap a b]\n\n"}
{"name":"Multiset.instLawfulSingleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ LawfulSingleton α (Multiset α)","decl":"instance : LawfulSingleton α (Multiset α) :=\n  ⟨fun _ => rfl⟩\n\n"}
{"name":"Multiset.cons_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Multiset.cons a 0) (Singleton.singleton a)","decl":"@[simp]\ntheorem cons_zero (a : α) : a ::ₘ 0 = {a} :=\n  rfl\n\n"}
{"name":"Multiset.coe_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (↑(List.cons a List.nil)) (Singleton.singleton a)","decl":"@[simp, norm_cast]\ntheorem coe_singleton (a : α) : ([a] : Multiset α) = {a} :=\n  rfl\n\n"}
{"name":"Multiset.mem_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Membership.mem (Singleton.singleton a) b) (Eq b a)","decl":"@[simp]\ntheorem mem_singleton {a b : α} : b ∈ ({a} : Multiset α) ↔ b = a := by\n  simp only [← cons_zero, mem_cons, iff_self, or_false, not_mem_zero]\n\n"}
{"name":"Multiset.mem_singleton_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Membership.mem (Singleton.singleton a) a","decl":"theorem mem_singleton_self (a : α) : a ∈ ({a} : Multiset α) := by\n  rw [← cons_zero]\n  exact mem_cons_self _ _\n\n"}
{"name":"Multiset.singleton_inj","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\n⊢ Iff (Eq (Singleton.singleton a) (Singleton.singleton b)) (Eq a b)","decl":"@[simp]\ntheorem singleton_inj {a b : α} : ({a} : Multiset α) = {b} ↔ a = b := by\n  simp_rw [← cons_zero]\n  exact cons_inj_left _\n\n"}
{"name":"Multiset.coe_eq_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\na : α\n⊢ Iff (Eq (↑l) (Singleton.singleton a)) (Eq l (List.cons a List.nil))","decl":"@[simp, norm_cast]\ntheorem coe_eq_singleton {l : List α} {a : α} : (l : Multiset α) = {a} ↔ l = [a] := by\n  rw [← coe_singleton, coe_eq_coe, List.perm_singleton]\n\n"}
{"name":"Multiset.singleton_eq_cons_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\nm : Multiset α\n⊢ Iff (Eq (Singleton.singleton a) (Multiset.cons b m)) (And (Eq a b) (Eq m 0))","decl":"@[simp]\ntheorem singleton_eq_cons_iff {a b : α} (m : Multiset α) : {a} = b ::ₘ m ↔ a = b ∧ m = 0 := by\n  rw [← cons_zero, cons_eq_cons]\n  simp [eq_comm]\n\n"}
{"name":"Multiset.pair_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nx y : α\n⊢ Eq (Insert.insert x (Singleton.singleton y)) (Insert.insert y (Singleton.singleton x))","decl":"theorem pair_comm (x y : α) : ({x, y} : Multiset α) = {y, x} :=\n  cons_swap x y 0\n\n"}
{"name":"Multiset.instIsNonstrictStrictOrder","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ IsNonstrictStrictOrder (Multiset α) (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2","decl":"instance instIsNonstrictStrictOrder : IsNonstrictStrictOrder (Multiset α) (· ⊆ ·) (· ⊂ ·) where\n  right_iff_left_not_left _ _ := Iff.rfl\n\n"}
{"name":"Multiset.coe_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (HasSubset.Subset ↑l₁ ↑l₂) (HasSubset.Subset l₁ l₂)","decl":"@[simp]\ntheorem coe_subset {l₁ l₂ : List α} : (l₁ : Multiset α) ⊆ l₂ ↔ l₁ ⊆ l₂ :=\n  Iff.rfl\n\n"}
{"name":"Multiset.Subset.refl","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ HasSubset.Subset s s","decl":"@[simp]\ntheorem Subset.refl (s : Multiset α) : s ⊆ s := fun _ h => h\n\n"}
{"name":"Multiset.Subset.trans","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\na✝¹ : HasSubset.Subset s t\na✝ : HasSubset.Subset t u\n⊢ HasSubset.Subset s u","decl":"theorem Subset.trans {s t u : Multiset α} : s ⊆ t → t ⊆ u → s ⊆ u := fun h₁ h₂ _ m => h₂ (h₁ m)\n\n"}
{"name":"Multiset.subset_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (HasSubset.Subset s t) (∀ ⦃x : α⦄, Membership.mem s x → Membership.mem t x)","decl":"theorem subset_iff {s t : Multiset α} : s ⊆ t ↔ ∀ ⦃x⦄, x ∈ s → x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Multiset.mem_of_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nh : HasSubset.Subset s t\na✝ : Membership.mem s a\n⊢ Membership.mem t a","decl":"theorem mem_of_subset {s t : Multiset α} {a : α} (h : s ⊆ t) : a ∈ s → a ∈ t :=\n  @h _\n\n"}
{"name":"Multiset.zero_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ HasSubset.Subset 0 s","decl":"@[simp]\ntheorem zero_subset (s : Multiset α) : 0 ⊆ s := fun a => (not_mem_nil a).elim\n\n"}
{"name":"Multiset.subset_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ HasSubset.Subset s (Multiset.cons a s)","decl":"theorem subset_cons (s : Multiset α) (a : α) : s ⊆ a ::ₘ s := fun _ => mem_cons_of_mem\n\n"}
{"name":"Multiset.ssubset_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\nha : Not (Membership.mem s a)\n⊢ HasSSubset.SSubset s (Multiset.cons a s)","decl":"theorem ssubset_cons {s : Multiset α} {a : α} (ha : a ∉ s) : s ⊂ a ::ₘ s :=\n  ⟨subset_cons _ _, fun h => ha <| h <| mem_cons_self _ _⟩\n\n"}
{"name":"Multiset.cons_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Iff (HasSubset.Subset (Multiset.cons a s) t) (And (Membership.mem t a) (HasSubset.Subset s t))","decl":"@[simp]\ntheorem cons_subset {a : α} {s t : Multiset α} : a ::ₘ s ⊆ t ↔ a ∈ t ∧ s ⊆ t := by\n  simp [subset_iff, or_imp, forall_and]\n\n"}
{"name":"Multiset.cons_subset_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\na✝ : HasSubset.Subset s t\n⊢ HasSubset.Subset (Multiset.cons a s) (Multiset.cons a t)","decl":"theorem cons_subset_cons {a : α} {s t : Multiset α} : s ⊆ t → a ::ₘ s ⊆ a ::ₘ t :=\n  Quotient.inductionOn₂ s t fun _ _ => List.cons_subset_cons _\n\n"}
{"name":"Multiset.eq_zero_of_subset_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\nh : HasSubset.Subset s 0\n⊢ Eq s 0","decl":"theorem eq_zero_of_subset_zero {s : Multiset α} (h : s ⊆ 0) : s = 0 :=\n  eq_zero_of_forall_not_mem fun _ hx ↦ not_mem_zero _ (h hx)\n\n"}
{"name":"Multiset.subset_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (HasSubset.Subset s 0) (Eq s 0)","decl":"@[simp] lemma subset_zero : s ⊆ 0 ↔ s = 0 :=\n  ⟨eq_zero_of_subset_zero, fun xeq => xeq.symm ▸ Subset.refl 0⟩\n\n"}
{"name":"Multiset.zero_ssubset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (HasSSubset.SSubset 0 s) (Ne s 0)","decl":"@[simp] lemma zero_ssubset : 0 ⊂ s ↔ s ≠ 0 := by simp [ssubset_iff_subset_not_subset]\n\n"}
{"name":"Multiset.singleton_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ Iff (HasSubset.Subset (Singleton.singleton a) s) (Membership.mem s a)","decl":"@[simp] lemma singleton_subset : {a} ⊆ s ↔ a ∈ s := by simp [subset_iff]\n\n"}
{"name":"Multiset.induction_on'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Prop\nS : Multiset α\nh₁ : p 0\nh₂ : ∀ {a : α} {s : Multiset α}, Membership.mem S a → HasSubset.Subset s S → p s → p (Insert.insert a s)\n⊢ p S","decl":"theorem induction_on' {p : Multiset α → Prop} (S : Multiset α) (h₁ : p 0)\n    (h₂ : ∀ {a s}, a ∈ S → s ⊆ S → p s → p (insert a s)) : p S :=\n  @Multiset.induction_on α (fun T => T ⊆ S → p T) S (fun _ => h₁)\n    (fun _ _ hps hs =>\n      let ⟨hS, sS⟩ := cons_subset.1 hs\n      h₂ hS sS (hps sS))\n    (Subset.refl S)\n\n"}
{"name":"Multiset.coe_toList","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (↑s.toList) s","decl":"@[simp, norm_cast]\ntheorem coe_toList (s : Multiset α) : (s.toList : Multiset α) = s :=\n  s.out_eq'\n\n"}
{"name":"Multiset.toList_eq_nil","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.toList List.nil) (Eq s 0)","decl":"@[simp]\ntheorem toList_eq_nil {s : Multiset α} : s.toList = [] ↔ s = 0 := by\n  rw [← coe_eq_zero, coe_toList]\n\n"}
{"name":"Multiset.empty_toList","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.toList.isEmpty Bool.true) (Eq s 0)","decl":"theorem empty_toList {s : Multiset α} : s.toList.isEmpty ↔ s = 0 := by simp\n\n"}
{"name":"Multiset.toList_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.toList 0) List.nil","decl":"@[simp]\ntheorem toList_zero : (Multiset.toList 0 : List α) = [] :=\n  toList_eq_nil.mpr rfl\n\n"}
{"name":"Multiset.mem_toList","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Iff (Membership.mem s.toList a) (Membership.mem s a)","decl":"@[simp]\ntheorem mem_toList {a : α} {s : Multiset α} : a ∈ s.toList ↔ a ∈ s := by\n  rw [← mem_coe, coe_toList]\n\n"}
{"name":"Multiset.toList_eq_singleton_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nm : Multiset α\n⊢ Iff (Eq m.toList (List.cons a List.nil)) (Eq m (Singleton.singleton a))","decl":"@[simp]\ntheorem toList_eq_singleton_iff {a : α} {m : Multiset α} : m.toList = [a] ↔ m = {a} := by\n  rw [← perm_singleton, ← coe_eq_coe, coe_toList, coe_singleton]\n\n"}
{"name":"Multiset.toList_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).toList (List.cons a List.nil)","decl":"@[simp]\ntheorem toList_singleton (a : α) : ({a} : Multiset α).toList = [a] :=\n  Multiset.toList_eq_singleton_iff.2 rfl\n\n"}
{"name":"Multiset.subset_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na✝ : LE.le s t\n⊢ HasSubset.Subset s t","decl":"theorem subset_of_le : s ≤ t → s ⊆ t :=\n  Quotient.inductionOn₂ s t fun _ _ => Subperm.subset\n\n"}
{"name":"Multiset.Le.subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na✝ : LE.le s t\n⊢ HasSubset.Subset s t","decl":"alias Le.subset := subset_of_le\n\n"}
{"name":"Multiset.mem_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nh : LE.le s t\na✝ : Membership.mem s a\n⊢ Membership.mem t a","decl":"theorem mem_of_le (h : s ≤ t) : a ∈ s → a ∈ t :=\n  mem_of_subset (subset_of_le h)\n\n"}
{"name":"Multiset.not_mem_mono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nh : HasSubset.Subset s t\na✝ : Not (Membership.mem t a)\n⊢ Not (Membership.mem s a)","decl":"theorem not_mem_mono (h : s ⊆ t) : a ∉ t → a ∉ s :=\n  mt <| @h _\n\n"}
{"name":"Multiset.coe_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (LE.le ↑l₁ ↑l₂) (l₁.Subperm l₂)","decl":"@[simp]\ntheorem coe_le {l₁ l₂ : List α} : (l₁ : Multiset α) ≤ l₂ ↔ l₁ <+~ l₂ :=\n  Iff.rfl\n\n"}
{"name":"Multiset.leInductionOn","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nC : Multiset α → Multiset α → Prop\ns t : Multiset α\nh : LE.le s t\nH : ∀ {l₁ l₂ : List α}, l₁.Sublist l₂ → C ↑l₁ ↑l₂\n⊢ C s t","decl":"@[elab_as_elim]\ntheorem leInductionOn {C : Multiset α → Multiset α → Prop} {s t : Multiset α} (h : s ≤ t)\n    (H : ∀ {l₁ l₂ : List α}, l₁ <+ l₂ → C l₁ l₂) : C s t :=\n  Quotient.inductionOn₂ s t (fun l₁ _ ⟨l, p, s⟩ => (show ⟦l⟧ = ⟦l₁⟧ from Quot.sound p) ▸ H s) h\n\n"}
{"name":"Multiset.zero_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ LE.le 0 s","decl":"theorem zero_le (s : Multiset α) : 0 ≤ s :=\n  Quot.inductionOn s fun l => (nil_sublist l).subperm\n\n"}
{"name":"Multiset.bot_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq Bot.bot 0","decl":"/-- This is a `rfl` and `simp` version of `bot_eq_zero`. -/\n@[simp]\ntheorem bot_eq_zero : (⊥ : Multiset α) = 0 :=\n  rfl\n\n"}
{"name":"Multiset.le_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (LE.le s 0) (Eq s 0)","decl":"theorem le_zero : s ≤ 0 ↔ s = 0 :=\n  le_bot_iff\n\n"}
{"name":"Multiset.lt_cons_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ LT.lt s (Multiset.cons a s)","decl":"theorem lt_cons_self (s : Multiset α) (a : α) : s < a ::ₘ s :=\n  Quot.inductionOn s fun l =>\n    suffices l <+~ a :: l ∧ ¬l ~ a :: l by simpa [lt_iff_le_and_ne]\n    ⟨(sublist_cons_self _ _).subperm,\n      fun p => _root_.ne_of_lt (lt_succ_self (length l)) p.length_eq⟩\n\n"}
{"name":"Multiset.le_cons_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ LE.le s (Multiset.cons a s)","decl":"theorem le_cons_self (s : Multiset α) (a : α) : s ≤ a ::ₘ s :=\n  le_of_lt <| lt_cons_self _ _\n\n"}
{"name":"Multiset.cons_le_cons_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\n⊢ Iff (LE.le (Multiset.cons a s) (Multiset.cons a t)) (LE.le s t)","decl":"theorem cons_le_cons_iff (a : α) : a ::ₘ s ≤ a ::ₘ t ↔ s ≤ t :=\n  Quotient.inductionOn₂ s t fun _ _ => subperm_cons a\n\n"}
{"name":"Multiset.cons_le_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\na✝ : LE.le s t\n⊢ LE.le (Multiset.cons a s) (Multiset.cons a t)","decl":"theorem cons_le_cons (a : α) : s ≤ t → a ::ₘ s ≤ a ::ₘ t :=\n  (cons_le_cons_iff a).2\n\n"}
{"name":"Multiset.cons_lt_cons_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\n⊢ Iff (LT.lt (Multiset.cons a s) (Multiset.cons a t)) (LT.lt s t)","decl":"@[simp] lemma cons_lt_cons_iff : a ::ₘ s < a ::ₘ t ↔ s < t :=\n  lt_iff_lt_of_le_iff_le' (cons_le_cons_iff _) (cons_le_cons_iff _)\n\n"}
{"name":"Multiset.cons_lt_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nh : LT.lt s t\n⊢ LT.lt (Multiset.cons a s) (Multiset.cons a t)","decl":"lemma cons_lt_cons (a : α) (h : s < t) : a ::ₘ s < a ::ₘ t := cons_lt_cons_iff.2 h\n\n"}
{"name":"Multiset.le_cons_of_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nm : Not (Membership.mem s a)\n⊢ Iff (LE.le s (Multiset.cons a t)) (LE.le s t)","decl":"theorem le_cons_of_not_mem (m : a ∉ s) : s ≤ a ::ₘ t ↔ s ≤ t := by\n  refine ⟨?_, fun h => le_trans h <| le_cons_self _ _⟩\n  suffices ∀ {t'}, s ≤ t' → a ∈ t' → a ::ₘ s ≤ t' by\n    exact fun h => (cons_le_cons_iff a).1 (this h (mem_cons_self _ _))\n  introv h\n  revert m\n  refine leInductionOn h ?_\n  introv s m₁ m₂\n  rcases append_of_mem m₂ with ⟨r₁, r₂, rfl⟩\n  exact\n    perm_middle.subperm_left.2\n      ((subperm_cons _).2 <| ((sublist_or_mem_of_sublist s).resolve_right m₁).subperm)\n\n"}
{"name":"Multiset.cons_le_of_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\na : α\nhs : Not (Membership.mem s a)\n⊢ Iff (LE.le (Multiset.cons a s) t) (And (Membership.mem t a) (LE.le s t))","decl":"theorem cons_le_of_not_mem (hs : a ∉ s) : a ::ₘ s ≤ t ↔ a ∈ t ∧ s ≤ t := by\n  apply Iff.intro (fun h ↦ ⟨subset_of_le h (mem_cons_self a s), le_trans (le_cons_self s a) h⟩)\n  rintro ⟨h₁, h₂⟩; rcases exists_cons_of_mem h₁ with ⟨_, rfl⟩\n  exact cons_le_cons _ ((le_cons_of_not_mem hs).mp h₂)\n\n"}
{"name":"Multiset.singleton_ne_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne (Singleton.singleton a) 0","decl":"@[simp]\ntheorem singleton_ne_zero (a : α) : ({a} : Multiset α) ≠ 0 :=\n  ne_of_gt (lt_cons_self _ _)\n\n"}
{"name":"Multiset.zero_ne_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Ne 0 (Singleton.singleton a)","decl":"@[simp]\ntheorem zero_ne_singleton (a : α) : 0 ≠ ({a} : Multiset α) := singleton_ne_zero _ |>.symm\n\n"}
{"name":"Multiset.singleton_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Iff (LE.le (Singleton.singleton a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem singleton_le {a : α} {s : Multiset α} : {a} ≤ s ↔ a ∈ s :=\n  ⟨fun h => mem_of_le h (mem_singleton_self _), fun h =>\n    let ⟨_t, e⟩ := exists_cons_of_mem h\n    e.symm ▸ cons_le_cons _ (zero_le _)⟩\n\n"}
{"name":"Multiset.le_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ Iff (LE.le s (Singleton.singleton a)) (Or (Eq s 0) (Eq s (Singleton.singleton a)))","decl":"@[simp] lemma le_singleton : s ≤ {a} ↔ s = 0 ∨ s = {a} :=\n  Quot.induction_on s fun l ↦ by simp only [cons_zero, ← coe_singleton, quot_mk_to_coe'', coe_le,\n    coe_eq_zero, coe_eq_coe, perm_singleton, subperm_singleton_iff]\n\n"}
{"name":"Multiset.lt_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ Iff (LT.lt s (Singleton.singleton a)) (Eq s 0)","decl":"@[simp] lemma lt_singleton : s < {a} ↔ s = 0 := by\n  simp only [lt_iff_le_and_ne, le_singleton, or_and_right, Ne, and_not_self, or_false,\n    and_iff_left_iff_imp]\n  rintro rfl\n  exact (singleton_ne_zero _).symm\n\n"}
{"name":"Multiset.ssubset_singleton_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ Iff (HasSSubset.SSubset s (Singleton.singleton a)) (Eq s 0)","decl":"@[simp] lemma ssubset_singleton_iff : s ⊂ {a} ↔ s = 0 := by\n  refine ⟨fun hs ↦ eq_zero_of_subset_zero fun b hb ↦ (hs.2 ?_).elim, ?_⟩\n  · obtain rfl := mem_singleton.1 (hs.1 hb)\n    rwa [singleton_subset]\n  · rintro rfl\n    simp\n\n"}
{"name":"Multiset.coe_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : List α\n⊢ Eq (HAdd.hAdd ↑s ↑t) ↑(HAppend.hAppend s t)","decl":"@[simp]\ntheorem coe_add (s t : List α) : (s + t : Multiset α) = (s ++ t : List α) :=\n  rfl\n\n"}
{"name":"Multiset.singleton_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Eq (HAdd.hAdd (Singleton.singleton a) s) (Multiset.cons a s)","decl":"@[simp]\ntheorem singleton_add (a : α) (s : Multiset α) : {a} + s = a ::ₘ s :=\n  rfl\n\n"}
{"name":"Multiset.add_le_add_iff_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (LE.le (HAdd.hAdd s t) (HAdd.hAdd s u)) (LE.le t u)","decl":"protected lemma add_le_add_iff_left : s + t ≤ s + u ↔ t ≤ u :=\n  Quotient.inductionOn₃ s t u fun _ _ _ => subperm_append_left _\n\n"}
{"name":"Multiset.add_le_add_iff_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (LE.le (HAdd.hAdd s u) (HAdd.hAdd t u)) (LE.le s t)","decl":"protected lemma add_le_add_iff_right : s + u ≤ t + u ↔ s ≤ t :=\n  Quotient.inductionOn₃ s t u fun _ _ _ => subperm_append_right _\n\n"}
{"name":"Multiset.le_of_add_le_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\na✝ : LE.le (HAdd.hAdd s t) (HAdd.hAdd s u)\n⊢ LE.le t u","decl":"protected alias ⟨le_of_add_le_add_left, add_le_add_left⟩ := Multiset.add_le_add_iff_left\n"}
{"name":"Multiset.add_le_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\na✝ : LE.le t u\n⊢ LE.le (HAdd.hAdd s t) (HAdd.hAdd s u)","decl":"protected alias ⟨le_of_add_le_add_left, add_le_add_left⟩ := Multiset.add_le_add_iff_left\n"}
{"name":"Multiset.add_le_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\na✝ : LE.le s t\n⊢ LE.le (HAdd.hAdd s u) (HAdd.hAdd t u)","decl":"protected alias ⟨le_of_add_le_add_right, add_le_add_right⟩ := Multiset.add_le_add_iff_right\n\n"}
{"name":"Multiset.le_of_add_le_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\na✝ : LE.le (HAdd.hAdd s u) (HAdd.hAdd t u)\n⊢ LE.le s t","decl":"protected alias ⟨le_of_add_le_add_right, add_le_add_right⟩ := Multiset.add_le_add_iff_right\n\n"}
{"name":"Multiset.add_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t) (HAdd.hAdd t s)","decl":"protected lemma add_comm (s t : Multiset α) : s + t = t + s :=\n  Quotient.inductionOn₂ s t fun _ _ ↦ Quot.sound perm_append_comm\n\n"}
{"name":"Multiset.add_assoc","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Eq (HAdd.hAdd (HAdd.hAdd s t) u) (HAdd.hAdd s (HAdd.hAdd t u))","decl":"protected lemma add_assoc (s t u : Multiset α) : s + t + u = s + (t + u) :=\n  Quotient.inductionOn₃ s t u fun _ _ _ ↦ congr_arg _ <| append_assoc ..\n\n"}
{"name":"Multiset.zero_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (HAdd.hAdd 0 s) s","decl":"@[simp, nolint simpNF] -- We want to use this lemma earlier than `zero_add`\nprotected lemma zero_add (s : Multiset α) : 0 + s = s := Quotient.inductionOn s fun _ ↦ rfl\n\n"}
{"name":"Multiset.add_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (HAdd.hAdd s 0) s","decl":"@[simp, nolint simpNF] -- We want to use this lemma earlier than `add_zero`\nprotected lemma add_zero (s : Multiset α) : s + 0 = s :=\n  Quotient.inductionOn s fun l ↦ congr_arg _ <| append_nil l\n\n"}
{"name":"Multiset.le_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ LE.le s (HAdd.hAdd s t)","decl":"lemma le_add_right (s t : Multiset α) : s ≤ s + t := by\n  simpa using Multiset.add_le_add_left (zero_le t)\n\n"}
{"name":"Multiset.le_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ LE.le s (HAdd.hAdd t s)","decl":"lemma le_add_left (s t : Multiset α) : s ≤ t + s := by\n  simpa using Multiset.add_le_add_right (zero_le t)\n\n"}
{"name":"Multiset.subset_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ HasSubset.Subset s (HAdd.hAdd s t)","decl":"lemma subset_add_left {s t : Multiset α} : s ⊆ s + t := subset_of_le <| le_add_right s t\n\n"}
{"name":"Multiset.subset_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ HasSubset.Subset s (HAdd.hAdd t s)","decl":"lemma subset_add_right {s t : Multiset α} : s ⊆ t + s := subset_of_le <| le_add_left s t\n\n"}
{"name":"Multiset.le_iff_exists_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (LE.le s t) (Exists fun u => Eq t (HAdd.hAdd s u))","decl":"theorem le_iff_exists_add {s t : Multiset α} : s ≤ t ↔ ∃ u, t = s + u :=\n  ⟨fun h =>\n    leInductionOn h fun s =>\n      let ⟨l, p⟩ := s.exists_perm_append\n      ⟨l, Quot.sound p⟩,\n    fun ⟨_u, e⟩ => e.symm ▸ le_add_right _ _⟩\n\n"}
{"name":"Multiset.cons_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd (Multiset.cons a s) t) (Multiset.cons a (HAdd.hAdd s t))","decl":"@[simp]\ntheorem cons_add (a : α) (s t : Multiset α) : a ::ₘ s + t = a ::ₘ (s + t) := by\n  rw [← singleton_add, ← singleton_add, Multiset.add_assoc]\n\n"}
{"name":"Multiset.add_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s (Multiset.cons a t)) (Multiset.cons a (HAdd.hAdd s t))","decl":"@[simp]\ntheorem add_cons (a : α) (s t : Multiset α) : s + a ::ₘ t = a ::ₘ (s + t) := by\n  rw [Multiset.add_comm, cons_add, Multiset.add_comm]\n\n"}
{"name":"Multiset.mem_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Iff (Membership.mem (HAdd.hAdd s t) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\ntheorem mem_add {a : α} {s t : Multiset α} : a ∈ s + t ↔ a ∈ s ∨ a ∈ t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => mem_append\n\n"}
{"name":"Multiset.coe_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).card l.length","decl":"@[simp]\ntheorem coe_card (l : List α) : card (l : Multiset α) = length l :=\n  rfl\n\n"}
{"name":"Multiset.length_toList","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq s.toList.length s.card","decl":"@[simp]\ntheorem length_toList (s : Multiset α) : s.toList.length = card s := by\n  rw [← coe_card, coe_toList]\n\n"}
{"name":"Multiset.card_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.card 0) 0","decl":"@[simp]\ntheorem card_zero : @card α 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.card_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t).card (HAdd.hAdd s.card t.card)","decl":"@[simp]\ntheorem card_add (s t : Multiset α) : card (s + t) = card s + card t :=\n  Quotient.inductionOn₂ s t length_append\n\n"}
{"name":"Multiset.card_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).card (HAdd.hAdd s.card 1)","decl":"@[simp]\ntheorem card_cons (a : α) (s : Multiset α) : card (a ::ₘ s) = card s + 1 :=\n  Quot.inductionOn s fun _l => rfl\n\n"}
{"name":"Multiset.card_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Singleton.singleton a).card 1","decl":"@[simp]\ntheorem card_singleton (a : α) : card ({a} : Multiset α) = 1 := by\n  simp only [← cons_zero, card_zero, eq_self_iff_true, Multiset.zero_add, card_cons]\n\n"}
{"name":"Multiset.card_pair","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\n⊢ Eq (Insert.insert a (Singleton.singleton b)).card 2","decl":"theorem card_pair (a b : α) : card {a, b} = 2 := by\n  rw [insert_eq_cons, card_cons, card_singleton]\n\n"}
{"name":"Multiset.card_eq_one","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.card 1) (Exists fun a => Eq s (Singleton.singleton a))","decl":"theorem card_eq_one {s : Multiset α} : card s = 1 ↔ ∃ a, s = {a} :=\n  ⟨Quot.inductionOn s fun _l h => (List.length_eq_one.1 h).imp fun _a => congr_arg _,\n    fun ⟨_a, e⟩ => e.symm ▸ rfl⟩\n\n"}
{"name":"Multiset.card_le_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le s.card t.card","decl":"theorem card_le_card {s t : Multiset α} (h : s ≤ t) : card s ≤ card t :=\n  leInductionOn h Sublist.length_le\n\n"}
{"name":"Multiset.card_mono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Monotone Multiset.card","decl":"@[mono]\ntheorem card_mono : Monotone (@card α) := fun _a _b => card_le_card\n\n"}
{"name":"Multiset.eq_of_le_of_card_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\nh : LE.le s t\na✝ : LE.le t.card s.card\n⊢ Eq s t","decl":"theorem eq_of_le_of_card_le {s t : Multiset α} (h : s ≤ t) : card t ≤ card s → s = t :=\n  leInductionOn h fun s h₂ => congr_arg _ <| s.eq_of_length_le h₂\n\n"}
{"name":"Multiset.card_lt_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\nh : LT.lt s t\n⊢ LT.lt s.card t.card","decl":"theorem card_lt_card {s t : Multiset α} (h : s < t) : card s < card t :=\n  lt_of_not_ge fun h₂ => _root_.ne_of_lt h <| eq_of_le_of_card_le (le_of_lt h) h₂\n\n"}
{"name":"Multiset.card_strictMono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ StrictMono Multiset.card","decl":"lemma card_strictMono : StrictMono (card : Multiset α → ℕ) := fun _ _ ↦ card_lt_card\n\n"}
{"name":"Multiset.lt_iff_cons_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (LT.lt s t) (Exists fun a => LE.le (Multiset.cons a s) t)","decl":"theorem lt_iff_cons_le {s t : Multiset α} : s < t ↔ ∃ a, a ::ₘ s ≤ t :=\n  ⟨Quotient.inductionOn₂ s t fun _l₁ _l₂ h =>\n      Subperm.exists_of_length_lt (le_of_lt h) (card_lt_card h),\n    fun ⟨_a, h⟩ => lt_of_lt_of_le (lt_cons_self _ _) h⟩\n\n"}
{"name":"Multiset.card_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.card 0) (Eq s 0)","decl":"@[simp]\ntheorem card_eq_zero {s : Multiset α} : card s = 0 ↔ s = 0 :=\n  ⟨fun h => (eq_of_le_of_card_le (zero_le _) (le_of_eq h)).symm, fun e => by simp [e]⟩\n\n"}
{"name":"Multiset.card_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (LT.lt 0 s.card) (Ne s 0)","decl":"theorem card_pos {s : Multiset α} : 0 < card s ↔ s ≠ 0 :=\n  Nat.pos_iff_ne_zero.trans <| not_congr card_eq_zero\n\n"}
{"name":"Multiset.card_pos_iff_exists_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (LT.lt 0 s.card) (Exists fun a => Membership.mem s a)","decl":"theorem card_pos_iff_exists_mem {s : Multiset α} : 0 < card s ↔ ∃ a, a ∈ s :=\n  Quot.inductionOn s fun _l => length_pos_iff_exists_mem\n\n"}
{"name":"Multiset.card_eq_two","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.card 2) (Exists fun x => Exists fun y => Eq s (Insert.insert x (Singleton.singleton y)))","decl":"theorem card_eq_two {s : Multiset α} : card s = 2 ↔ ∃ x y, s = {x, y} :=\n  ⟨Quot.inductionOn s fun _l h =>\n      (List.length_eq_two.mp h).imp fun _a => Exists.imp fun _b => congr_arg _,\n    fun ⟨_a, _b, e⟩ => e.symm ▸ rfl⟩\n\n"}
{"name":"Multiset.card_eq_three","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (Eq s.card 3) (Exists fun x => Exists fun y => Exists fun z => Eq s (Insert.insert x (Insert.insert y (Singleton.singleton z))))","decl":"theorem card_eq_three {s : Multiset α} : card s = 3 ↔ ∃ x y z, s = {x, y, z} :=\n  ⟨Quot.inductionOn s fun _l h =>\n      (List.length_eq_three.mp h).imp fun _a =>\n        Exists.imp fun _b => Exists.imp fun _c => congr_arg _,\n    fun ⟨_a, _b, _c, e⟩ => e.symm ▸ rfl⟩\n\n"}
{"name":"Multiset.strongInductionOn_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Sort u_3\ns : Multiset α\nH : (s : Multiset α) → ((t : Multiset α) → LT.lt t s → p t) → p s\n⊢ Eq (s.strongInductionOn H) (H s fun t _h => t.strongInductionOn H)","decl":"theorem strongInductionOn_eq {p : Multiset α → Sort*} (s : Multiset α) (H) :\n    @strongInductionOn _ p s H = H s fun t _h => @strongInductionOn _ p t H := by\n  rw [strongInductionOn]\n\n"}
{"name":"Multiset.case_strongInductionOn","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Prop\ns : Multiset α\nh₀ : p 0\nh₁ : ∀ (a : α) (s : Multiset α), (∀ (t : Multiset α), LE.le t s → p t) → p (Multiset.cons a s)\n⊢ p s","decl":"@[elab_as_elim]\ntheorem case_strongInductionOn {p : Multiset α → Prop} (s : Multiset α) (h₀ : p 0)\n    (h₁ : ∀ a s, (∀ t ≤ s, p t) → p (a ::ₘ s)) : p s :=\n  Multiset.strongInductionOn s fun s =>\n    Multiset.induction_on s (fun _ => h₀) fun _a _s _ ih =>\n      (h₁ _ _) fun _t h => ih _ <| lt_of_le_of_lt h <| lt_cons_self _ _\n\n"}
{"name":"Multiset.strongDownwardInduction_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Sort u_3\nn : Nat\nH : (t₁ : Multiset α) → ({t₂ : Multiset α} → LE.le t₂.card n → LT.lt t₁ t₂ → p t₂) → LE.le t₁.card n → p t₁\ns : Multiset α\n⊢ Eq (Multiset.strongDownwardInduction H s) (H s fun {t₂} ht _hst => Multiset.strongDownwardInduction H t₂ ht)","decl":"theorem strongDownwardInduction_eq {p : Multiset α → Sort*} {n : ℕ}\n    (H : ∀ t₁, (∀ {t₂ : Multiset α}, card t₂ ≤ n → t₁ < t₂ → p t₂) → card t₁ ≤ n → p t₁)\n    (s : Multiset α) :\n    strongDownwardInduction H s = H s fun ht _hst => strongDownwardInduction H _ ht := by\n  rw [strongDownwardInduction]\n\n"}
{"name":"Multiset.strongDownwardInductionOn_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : Multiset α → Sort u_3\ns : Multiset α\nn : Nat\nH : (t₁ : Multiset α) → ({t₂ : Multiset α} → LE.le t₂.card n → LT.lt t₁ t₂ → p t₂) → LE.le t₁.card n → p t₁\n⊢ Eq (fun a => s.strongDownwardInductionOn H a) (H s fun {t} ht _h => t.strongDownwardInductionOn H ht)","decl":"theorem strongDownwardInductionOn_eq {p : Multiset α → Sort*} (s : Multiset α) {n : ℕ}\n    (H : ∀ t₁, (∀ {t₂ : Multiset α}, card t₂ ≤ n → t₁ < t₂ → p t₂) → card t₁ ≤ n → p t₁) :\n    s.strongDownwardInductionOn H = H s fun {t} ht _h => t.strongDownwardInductionOn H ht := by\n  dsimp only [strongDownwardInductionOn]\n  rw [strongDownwardInduction]\n\n"}
{"name":"Multiset.instWellFoundedLT","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ WellFoundedLT (Multiset α)","decl":"/-- Another way of expressing `strongInductionOn`: the `(<)` relation is well-founded. -/\ninstance instWellFoundedLT : WellFoundedLT (Multiset α) :=\n  ⟨Subrelation.wf Multiset.card_lt_card (measure Multiset.card).2⟩\n\n"}
{"name":"Multiset.coe_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\n⊢ Eq (↑(List.replicate n a)) (Multiset.replicate n a)","decl":"theorem coe_replicate (n : ℕ) (a : α) : (List.replicate n a : Multiset α) = replicate n a := rfl\n\n"}
{"name":"Multiset.replicate_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Multiset.replicate 0 a) 0","decl":"@[simp] theorem replicate_zero (a : α) : replicate 0 a = 0 := rfl\n\n"}
{"name":"Multiset.replicate_succ","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nn : Nat\n⊢ Eq (Multiset.replicate (HAdd.hAdd n 1) a) (Multiset.cons a (Multiset.replicate n a))","decl":"@[simp] theorem replicate_succ (a : α) (n) : replicate (n + 1) a = a ::ₘ replicate n a := rfl\n\n"}
{"name":"Multiset.replicate_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm n : Nat\na : α\n⊢ Eq (Multiset.replicate (HAdd.hAdd m n) a) (HAdd.hAdd (Multiset.replicate m a) (Multiset.replicate n a))","decl":"theorem replicate_add (m n : ℕ) (a : α) : replicate (m + n) a = replicate m a + replicate n a :=\n  congr_arg _ <| List.replicate_add ..\n\n"}
{"name":"Multiset.replicate_one","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Eq (Multiset.replicate 1 a) (Singleton.singleton a)","decl":"theorem replicate_one (a : α) : replicate 1 a = {a} := rfl\n\n"}
{"name":"Multiset.card_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\n⊢ Eq (Multiset.replicate n a).card n","decl":"@[simp] theorem card_replicate (n) (a : α) : card (replicate n a) = n :=\n  length_replicate n a\n\n"}
{"name":"Multiset.mem_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\nn : Nat\n⊢ Iff (Membership.mem (Multiset.replicate n a) b) (And (Ne n 0) (Eq b a))","decl":"theorem mem_replicate {a b : α} {n : ℕ} : b ∈ replicate n a ↔ n ≠ 0 ∧ b = a :=\n  List.mem_replicate\n\n"}
{"name":"Multiset.eq_of_mem_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\nn : Nat\na✝ : Membership.mem (Multiset.replicate n a) b\n⊢ Eq b a","decl":"theorem eq_of_mem_replicate {a b : α} {n} : b ∈ replicate n a → b = a :=\n  List.eq_of_mem_replicate\n\n"}
{"name":"Multiset.eq_replicate_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Iff (Eq s (Multiset.replicate s.card a)) (∀ (b : α), Membership.mem s b → Eq b a)","decl":"theorem eq_replicate_card {a : α} {s : Multiset α} : s = replicate (card s) a ↔ ∀ b ∈ s, b = a :=\n  Quot.inductionOn s fun _l => coe_eq_coe.trans <| perm_replicate.trans eq_replicate_length\n\n"}
{"name":"Multiset.eq_replicate_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns : Multiset α\na✝ : ∀ (b : α), Membership.mem s b → Eq b a\n⊢ Eq s (Multiset.replicate s.card a)","decl":"alias ⟨_, eq_replicate_of_mem⟩ := eq_replicate_card\n\n"}
{"name":"Multiset.eq_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nn : Nat\ns : Multiset α\n⊢ Iff (Eq s (Multiset.replicate n a)) (And (Eq s.card n) (∀ (b : α), Membership.mem s b → Eq b a))","decl":"theorem eq_replicate {a : α} {n} {s : Multiset α} :\n    s = replicate n a ↔ card s = n ∧ ∀ b ∈ s, b = a :=\n  ⟨fun h => h.symm ▸ ⟨card_replicate _ _, fun _b => eq_of_mem_replicate⟩,\n    fun ⟨e, al⟩ => e ▸ eq_replicate_of_mem al⟩\n\n"}
{"name":"Multiset.replicate_right_injective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nn : Nat\nhn : Ne n 0\n⊢ Function.Injective (Multiset.replicate n)","decl":"theorem replicate_right_injective {n : ℕ} (hn : n ≠ 0) : Injective (@replicate α n) :=\n  fun _ _ h => (eq_replicate.1 h).2 _ <| mem_replicate.2 ⟨hn, rfl⟩\n\n"}
{"name":"Multiset.replicate_right_inj","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na b : α\nn : Nat\nh : Ne n 0\n⊢ Iff (Eq (Multiset.replicate n a) (Multiset.replicate n b)) (Eq a b)","decl":"@[simp] theorem replicate_right_inj {a b : α} {n : ℕ} (h : n ≠ 0) :\n    replicate n a = replicate n b ↔ a = b :=\n  (replicate_right_injective h).eq_iff\n\n"}
{"name":"Multiset.replicate_left_injective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\n⊢ Function.Injective fun x => Multiset.replicate x a","decl":"theorem replicate_left_injective (a : α) : Injective (replicate · a) :=\n  -- Porting note: was `fun m n h => by rw [← (eq_replicate.1 h).1, card_replicate]`\n  LeftInverse.injective (card_replicate · a)\n\n"}
{"name":"Multiset.replicate_subset_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\n⊢ HasSubset.Subset (Multiset.replicate n a) (Singleton.singleton a)","decl":"theorem replicate_subset_singleton (n : ℕ) (a : α) : replicate n a ⊆ {a} :=\n  List.replicate_subset_singleton n a\n\n"}
{"name":"Multiset.replicate_le_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nn : Nat\nl : List α\n⊢ Iff (LE.le (Multiset.replicate n a) ↑l) ((List.replicate n a).Sublist l)","decl":"theorem replicate_le_coe {a : α} {n} {l : List α} : replicate n a ≤ l ↔ List.replicate n a <+ l :=\n  ⟨fun ⟨_l', p, s⟩ => perm_replicate.1 p ▸ s, Sublist.subperm⟩\n\n"}
{"name":"Multiset.replicate_le_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nk n : Nat\n⊢ Iff (LE.le (Multiset.replicate k a) (Multiset.replicate n a)) (LE.le k n)","decl":"theorem replicate_le_replicate (a : α) {k n : ℕ} : replicate k a ≤ replicate n a ↔ k ≤ n :=\n  _root_.trans (by rw [← replicate_le_coe, coe_replicate]) (List.replicate_sublist_replicate a)\n\n"}
{"name":"Multiset.replicate_mono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nk n : Nat\nh : LE.le k n\n⊢ LE.le (Multiset.replicate k a) (Multiset.replicate n a)","decl":"@[gcongr]\ntheorem replicate_mono (a : α) {k n : ℕ} (h : k ≤ n) : replicate k a ≤ replicate n a :=\n  (replicate_le_replicate a).2 h\n\n"}
{"name":"Multiset.le_replicate_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\na : α\nn : Nat\n⊢ Iff (LE.le m (Multiset.replicate n a)) (Exists fun k => And (LE.le k n) (Eq m (Multiset.replicate k a)))","decl":"theorem le_replicate_iff {m : Multiset α} {a : α} {n : ℕ} :\n    m ≤ replicate n a ↔ ∃ k ≤ n, m = replicate k a :=\n  ⟨fun h => ⟨card m, (card_mono h).trans_eq (card_replicate _ _),\n      eq_replicate_card.2 fun _ hb => eq_of_mem_replicate <| subset_of_le h hb⟩,\n    fun ⟨_, hkn, hm⟩ => hm.symm ▸ (replicate_le_replicate _).2 hkn⟩\n\n"}
{"name":"Multiset.lt_replicate_succ","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\nx : α\nn : Nat\n⊢ Iff (LT.lt m (Multiset.replicate (HAdd.hAdd n 1) x)) (LE.le m (Multiset.replicate n x))","decl":"theorem lt_replicate_succ {m : Multiset α} {x : α} {n : ℕ} :\n    m < replicate (n + 1) x ↔ m ≤ replicate n x := by\n  rw [lt_iff_cons_le]\n  constructor\n  · rintro ⟨x', hx'⟩\n    have := eq_of_mem_replicate (mem_of_le hx' (mem_cons_self _ _))\n    rwa [this, replicate_succ, cons_le_cons_iff] at hx'\n  · intro h\n    rw [replicate_succ]\n    exact ⟨x, cons_le_cons _ h⟩\n\n"}
{"name":"Multiset.coe_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na : α\n⊢ Eq ((↑l).erase a) ↑(l.erase a)","decl":"@[simp]\ntheorem coe_erase (l : List α) (a : α) : erase (l : Multiset α) a = l.erase a :=\n  rfl\n\n"}
{"name":"Multiset.erase_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.erase 0 a) 0","decl":"@[simp]\ntheorem erase_zero (a : α) : (0 : Multiset α).erase a = 0 :=\n  rfl\n\n"}
{"name":"Multiset.erase_cons_head","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq ((Multiset.cons a s).erase a) s","decl":"@[simp]\ntheorem erase_cons_head (a : α) (s : Multiset α) : (a ::ₘ s).erase a = s :=\n  Quot.inductionOn s fun l => congr_arg _ <| List.erase_cons_head a l\n\n"}
{"name":"Multiset.erase_cons_tail","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\nh : Ne b a\n⊢ Eq ((Multiset.cons b s).erase a) (Multiset.cons b (s.erase a))","decl":"@[simp]\ntheorem erase_cons_tail {a b : α} (s : Multiset α) (h : b ≠ a) :\n    (b ::ₘ s).erase a = b ::ₘ s.erase a :=\n  Quot.inductionOn s fun _ => congr_arg _ <| List.erase_cons_tail (not_beq_of_ne h)\n\n"}
{"name":"Multiset.erase_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Singleton.singleton a).erase a) 0","decl":"@[simp]\ntheorem erase_singleton (a : α) : ({a} : Multiset α).erase a = 0 :=\n  erase_cons_head a 0\n\n"}
{"name":"Multiset.erase_of_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Not (Membership.mem s a)\n⊢ Eq (s.erase a) s","decl":"@[simp]\ntheorem erase_of_not_mem {a : α} {s : Multiset α} : a ∉ s → s.erase a = s :=\n  Quot.inductionOn s fun _l h => congr_arg _ <| List.erase_of_not_mem h\n\n"}
{"name":"Multiset.cons_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\na✝ : Membership.mem s a\n⊢ Eq (Multiset.cons a (s.erase a)) s","decl":"@[simp]\ntheorem cons_erase {s : Multiset α} {a : α} : a ∈ s → a ::ₘ s.erase a = s :=\n  Quot.inductionOn s fun _l h => Quot.sound (perm_cons_erase h).symm\n\n"}
{"name":"Multiset.erase_cons_tail_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na b : α\nh : Membership.mem s a\n⊢ Eq ((Multiset.cons b s).erase a) (Multiset.cons b (s.erase a))","decl":"theorem erase_cons_tail_of_mem (h : a ∈ s) :\n    (b ::ₘ s).erase a = b ::ₘ s.erase a := by\n  rcases eq_or_ne a b with rfl | hab\n  · simp [cons_erase h]\n  · exact s.erase_cons_tail hab.symm\n\n"}
{"name":"Multiset.le_cons_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ LE.le s (Multiset.cons a (s.erase a))","decl":"theorem le_cons_erase (s : Multiset α) (a : α) : s ≤ a ::ₘ s.erase a :=\n  if h : a ∈ s then le_of_eq (cons_erase h).symm\n  else by rw [erase_of_not_mem h]; apply le_cons_self\n\n"}
{"name":"Multiset.add_singleton_eq_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (Eq (HAdd.hAdd s (Singleton.singleton a)) t) (And (Membership.mem t a) (Eq s (t.erase a)))","decl":"theorem add_singleton_eq_iff {s t : Multiset α} {a : α} : s + {a} = t ↔ a ∈ t ∧ s = t.erase a := by\n  rw [Multiset.add_comm, singleton_add]\n  constructor\n  · rintro rfl\n    exact ⟨s.mem_cons_self a, (s.erase_cons_head a).symm⟩\n  · rintro ⟨h, rfl⟩\n    exact cons_erase h\n\n"}
{"name":"Multiset.erase_add_left_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\na✝ : Membership.mem s a\n⊢ Eq ((HAdd.hAdd s t).erase a) (HAdd.hAdd (s.erase a) t)","decl":"theorem erase_add_left_pos {a : α} {s : Multiset α} (t) : a ∈ s → (s + t).erase a = s.erase a + t :=\n  Quotient.inductionOn₂ s t fun _l₁ l₂ h => congr_arg _ <| erase_append_left l₂ h\n\n"}
{"name":"Multiset.erase_add_right_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Multiset α\na : α\ns : Multiset α\nh : Membership.mem t a\n⊢ Eq ((HAdd.hAdd s t).erase a) (HAdd.hAdd s (t.erase a))","decl":"theorem erase_add_right_pos {a : α} (s) (h : a ∈ t) : (s + t).erase a = s + t.erase a := by\n  rw [Multiset.add_comm, erase_add_left_pos s h, Multiset.add_comm]\n\n"}
{"name":"Multiset.erase_add_right_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\na✝ : Not (Membership.mem s a)\n⊢ Eq ((HAdd.hAdd s t).erase a) (HAdd.hAdd s (t.erase a))","decl":"theorem erase_add_right_neg {a : α} {s : Multiset α} (t) :\n    a ∉ s → (s + t).erase a = s + t.erase a :=\n  Quotient.inductionOn₂ s t fun _l₁ l₂ h => congr_arg _ <| erase_append_right l₂ h\n\n"}
{"name":"Multiset.erase_add_left_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Multiset α\na : α\ns : Multiset α\nh : Not (Membership.mem t a)\n⊢ Eq ((HAdd.hAdd s t).erase a) (HAdd.hAdd (s.erase a) t)","decl":"theorem erase_add_left_neg {a : α} (s) (h : a ∉ t) : (s + t).erase a = s.erase a + t := by\n  rw [Multiset.add_comm, erase_add_right_neg s h, Multiset.add_comm]\n\n"}
{"name":"Multiset.erase_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ LE.le (s.erase a) s","decl":"theorem erase_le (a : α) (s : Multiset α) : s.erase a ≤ s :=\n  Quot.inductionOn s fun l => (erase_sublist a l).subperm\n\n"}
{"name":"Multiset.erase_lt","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (LT.lt (s.erase a) s) (Membership.mem s a)","decl":"@[simp]\ntheorem erase_lt {a : α} {s : Multiset α} : s.erase a < s ↔ a ∈ s :=\n  ⟨fun h => not_imp_comm.1 erase_of_not_mem (ne_of_lt h), fun h => by\n    simpa [h] using lt_cons_self (s.erase a) a⟩\n\n"}
{"name":"Multiset.erase_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ HasSubset.Subset (s.erase a) s","decl":"theorem erase_subset (a : α) (s : Multiset α) : s.erase a ⊆ s :=\n  subset_of_le (erase_le a s)\n\n"}
{"name":"Multiset.mem_erase_of_ne","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\nab : Ne a b\n⊢ Iff (Membership.mem (s.erase b) a) (Membership.mem s a)","decl":"theorem mem_erase_of_ne {a b : α} {s : Multiset α} (ab : a ≠ b) : a ∈ s.erase b ↔ a ∈ s :=\n  Quot.inductionOn s fun _l => List.mem_erase_of_ne ab\n\n"}
{"name":"Multiset.mem_of_mem_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\na✝ : Membership.mem (s.erase b) a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_erase {a b : α} {s : Multiset α} : a ∈ s.erase b → a ∈ s :=\n  mem_of_subset (erase_subset _ _)\n\n"}
{"name":"Multiset.erase_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na b : α\n⊢ Eq ((s.erase a).erase b) ((s.erase b).erase a)","decl":"theorem erase_comm (s : Multiset α) (a b : α) : (s.erase a).erase b = (s.erase b).erase a :=\n  Quot.inductionOn s fun l => congr_arg _ <| l.erase_comm a b\n\n"}
{"name":"Multiset.instRightCommutativeErase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ RightCommutative Multiset.erase","decl":"instance : RightCommutative erase (α := α) := ⟨erase_comm⟩\n\n"}
{"name":"Multiset.erase_le_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\nh : LE.le s t\n⊢ LE.le (s.erase a) (t.erase a)","decl":"@[gcongr]\ntheorem erase_le_erase {s t : Multiset α} (a : α) (h : s ≤ t) : s.erase a ≤ t.erase a :=\n  leInductionOn h fun h => (h.erase _).subperm\n\n"}
{"name":"Multiset.erase_le_iff_le_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (LE.le (s.erase a) t) (LE.le s (Multiset.cons a t))","decl":"theorem erase_le_iff_le_cons {s t : Multiset α} {a : α} : s.erase a ≤ t ↔ s ≤ a ::ₘ t :=\n  ⟨fun h => le_trans (le_cons_erase _ _) (cons_le_cons _ h), fun h =>\n    if m : a ∈ s then by rw [← cons_erase m] at h; exact (cons_le_cons_iff _).1 h\n    else le_trans (erase_le _ _) ((le_cons_of_not_mem m).1 h)⟩\n\n"}
{"name":"Multiset.card_erase_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Membership.mem s a\n⊢ Eq (s.erase a).card s.card.pred","decl":"@[simp]\ntheorem card_erase_of_mem {a : α} {s : Multiset α} : a ∈ s → card (s.erase a) = pred (card s) :=\n  Quot.inductionOn s fun _l => length_erase_of_mem\n\n"}
{"name":"Multiset.card_erase_add_one","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Membership.mem s a\n⊢ Eq (HAdd.hAdd (s.erase a).card 1) s.card","decl":"@[simp]\ntheorem card_erase_add_one {a : α} {s : Multiset α} : a ∈ s → card (s.erase a) + 1 = card s :=\n  Quot.inductionOn s fun _l => length_erase_add_one\n\n"}
{"name":"Multiset.card_erase_lt_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\na✝ : Membership.mem s a\n⊢ LT.lt (s.erase a).card s.card","decl":"theorem card_erase_lt_of_mem {a : α} {s : Multiset α} : a ∈ s → card (s.erase a) < card s :=\n  fun h => card_lt_card (erase_lt.mpr h)\n\n"}
{"name":"Multiset.card_erase_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ LE.le (s.erase a).card s.card","decl":"theorem card_erase_le {a : α} {s : Multiset α} : card (s.erase a) ≤ card s :=\n  card_le_card (erase_le a s)\n\n"}
{"name":"Multiset.card_erase_eq_ite","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (s.erase a).card (ite (Membership.mem s a) s.card.pred s.card)","decl":"theorem card_erase_eq_ite {a : α} {s : Multiset α} :\n    card (s.erase a) = if a ∈ s then pred (card s) else card s := by\n  by_cases h : a ∈ s\n  · rwa [card_erase_of_mem h, if_pos]\n  · rwa [erase_of_not_mem h, if_neg]\n\n"}
{"name":"Multiset.coe_reverse","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq ↑l.reverse ↑l","decl":"@[simp]\ntheorem coe_reverse (l : List α) : (reverse l : Multiset α) = l :=\n  Quot.sound <| reverse_perm _\n\n"}
{"name":"Multiset.map_congr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf g : α → β\ns t : Multiset α\na✝¹ : Eq s t\na✝ : ∀ (x : α), Membership.mem t x → Eq (f x) (g x)\n⊢ Eq (Multiset.map f s) (Multiset.map g t)","decl":"@[congr]\ntheorem map_congr {f g : α → β} {s t : Multiset α} :\n    s = t → (∀ x ∈ t, f x = g x) → map f s = map g t := by\n  rintro rfl h\n  induction s using Quot.inductionOn\n  exact congr_arg _ (List.map_congr_left h)\n\n"}
{"name":"Multiset.map_hcongr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ β' : Type v\nm : Multiset α\nf : α → β\nf' : α → β'\nh : Eq β β'\nhf : ∀ (a : α), Membership.mem m a → HEq (f a) (f' a)\n⊢ HEq (Multiset.map f m) (Multiset.map f' m)","decl":"theorem map_hcongr {β' : Type v} {m : Multiset α} {f : α → β} {f' : α → β'} (h : β = β')\n    (hf : ∀ a ∈ m, HEq (f a) (f' a)) : HEq (map f m) (map f' m) := by\n  subst h; simp at hf\n  simp [map_congr rfl hf]\n\n"}
{"name":"Multiset.forall_mem_map_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\np : β → Prop\ns : Multiset α\n⊢ Iff (∀ (y : β), Membership.mem (Multiset.map f s) y → p y) (∀ (x : α), Membership.mem s x → p (f x))","decl":"theorem forall_mem_map_iff {f : α → β} {p : β → Prop} {s : Multiset α} :\n    (∀ y ∈ s.map f, p y) ↔ ∀ x ∈ s, p (f x) :=\n  Quotient.inductionOn' s fun _L => List.forall_mem_map\n\n"}
{"name":"Multiset.map_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nl : List α\n⊢ Eq (Multiset.map f ↑l) ↑(List.map f l)","decl":"@[simp, norm_cast] lemma map_coe (f : α → β) (l : List α) : map f l = l.map f := rfl\n\n"}
{"name":"Multiset.map_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\n⊢ Eq (Multiset.map f 0) 0","decl":"@[simp]\ntheorem map_zero (f : α → β) : map f 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.map_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\na : α\ns : Multiset α\n⊢ Eq (Multiset.map f (Multiset.cons a s)) (Multiset.cons (f a) (Multiset.map f s))","decl":"@[simp]\ntheorem map_cons (f : α → β) (a s) : map f (a ::ₘ s) = f a ::ₘ map f s :=\n  Quot.inductionOn s fun _l => rfl\n\n"}
{"name":"Multiset.map_comp_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nt : α\n⊢ Eq (Function.comp (Multiset.map f) (Multiset.cons t)) (Function.comp (Multiset.cons (f t)) (Multiset.map f))","decl":"theorem map_comp_cons (f : α → β) (t) : map f ∘ cons t = cons (f t) ∘ map f := by\n  ext\n  simp\n\n"}
{"name":"Multiset.map_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\na : α\n⊢ Eq (Multiset.map f (Singleton.singleton a)) (Singleton.singleton (f a))","decl":"@[simp]\ntheorem map_singleton (f : α → β) (a : α) : ({a} : Multiset α).map f = {f a} :=\n  rfl\n\n"}
{"name":"Multiset.map_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nk : Nat\na : α\n⊢ Eq (Multiset.map f (Multiset.replicate k a)) (Multiset.replicate k (f a))","decl":"@[simp]\ntheorem map_replicate (f : α → β) (k : ℕ) (a : α) : (replicate k a).map f = replicate k (f a) := by\n  simp only [← coe_replicate, map_coe, List.map_replicate]\n\n"}
{"name":"Multiset.map_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns t : Multiset α\n⊢ Eq (Multiset.map f (HAdd.hAdd s t)) (HAdd.hAdd (Multiset.map f s) (Multiset.map f t))","decl":"@[simp]\ntheorem map_add (f : α → β) (s t) : map f (s + t) = map f s + map f t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => congr_arg _ <| map_append _ _ _\n\n"}
{"name":"Multiset.canLift","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nc : β → α\np : α → Prop\ninst✝ : CanLift α β c p\n⊢ CanLift (Multiset α) (Multiset β) (Multiset.map c) fun s => ∀ (x : α), Membership.mem s x → p x","decl":"/-- If each element of `s : Multiset α` can be lifted to `β`, then `s` can be lifted to\n`Multiset β`. -/\ninstance canLift (c) (p) [CanLift α β c p] :\n    CanLift (Multiset α) (Multiset β) (map c) fun s => ∀ x ∈ s, p x where\n  prf := by\n    rintro ⟨l⟩ hl\n    lift l to List β using hl\n    exact ⟨l, map_coe _ _⟩\n\n"}
{"name":"Multiset.mem_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nb : β\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.map f s) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) b))","decl":"@[simp]\ntheorem mem_map {f : α → β} {b : β} {s : Multiset α} : b ∈ map f s ↔ ∃ a, a ∈ s ∧ f a = b :=\n  Quot.inductionOn s fun _l => List.mem_map\n\n"}
{"name":"Multiset.card_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns : Multiset α\n⊢ Eq (Multiset.map f s).card s.card","decl":"@[simp]\ntheorem card_map (f : α → β) (s) : card (map f s) = card s :=\n  Quot.inductionOn s fun _l => length_map _ _\n\n"}
{"name":"Multiset.map_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → β\n⊢ Iff (Eq (Multiset.map f s) 0) (Eq s 0)","decl":"@[simp]\ntheorem map_eq_zero {s : Multiset α} {f : α → β} : s.map f = 0 ↔ s = 0 := by\n  rw [← Multiset.card_eq_zero, Multiset.card_map, Multiset.card_eq_zero]\n\n"}
{"name":"Multiset.mem_map_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\na : α\ns : Multiset α\nh : Membership.mem s a\n⊢ Membership.mem (Multiset.map f s) (f a)","decl":"theorem mem_map_of_mem (f : α → β) {a : α} {s : Multiset α} (h : a ∈ s) : f a ∈ map f s :=\n  mem_map.2 ⟨_, h, rfl⟩\n\n"}
{"name":"Multiset.map_eq_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns : Multiset α\nb : β\n⊢ Iff (Eq (Multiset.map f s) (Singleton.singleton b)) (Exists fun a => And (Eq s (Singleton.singleton a)) (Eq (f a) b))","decl":"theorem map_eq_singleton {f : α → β} {s : Multiset α} {b : β} :\n    map f s = {b} ↔ ∃ a : α, s = {a} ∧ f a = b := by\n  constructor\n  · intro h\n    obtain ⟨a, ha⟩ : ∃ a, s = {a} := by rw [← card_eq_one, ← card_map, h, card_singleton]\n    refine ⟨a, ha, ?_⟩\n    rw [← mem_singleton, ← h, ha, map_singleton, mem_singleton]\n  · rintro ⟨a, rfl, rfl⟩\n    simp\n\n"}
{"name":"Multiset.map_eq_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : DecidableEq α\nf : α → β\ns : Multiset α\nt : Multiset β\nb : β\n⊢ Iff (Exists fun a => And (Membership.mem s a) (And (Eq (f a) b) (Eq (Multiset.map f (s.erase a)) t))) (Eq (Multiset.map f s) (Multiset.cons b t))","decl":"theorem map_eq_cons [DecidableEq α] (f : α → β) (s : Multiset α) (t : Multiset β) (b : β) :\n    (∃ a ∈ s, f a = b ∧ (s.erase a).map f = t) ↔ s.map f = b ::ₘ t := by\n  constructor\n  · rintro ⟨a, ha, rfl, rfl⟩\n    rw [← map_cons, Multiset.cons_erase ha]\n  · intro h\n    have : b ∈ s.map f := by\n      rw [h]\n      exact mem_cons_self _ _\n    obtain ⟨a, h1, rfl⟩ := mem_map.mp this\n    obtain ⟨u, rfl⟩ := exists_cons_of_mem h1\n    rw [map_cons, cons_inj_right] at h\n    refine ⟨a, mem_cons_self _ _, rfl, ?_⟩\n    rw [Multiset.erase_cons_head, h]\n\n-- The simpNF linter says that the LHS can be simplified via `Multiset.mem_map`.\n-- However this is a higher priority lemma.\n-- https://github.com/leanprover/std4/issues/207\n"}
{"name":"Multiset.mem_map_of_injective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nH : Function.Injective f\na : α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.map f s) (f a)) (Membership.mem s a)","decl":"@[simp 1100, nolint simpNF]\ntheorem mem_map_of_injective {f : α → β} (H : Function.Injective f) {a : α} {s : Multiset α} :\n    f a ∈ map f s ↔ a ∈ s :=\n  Quot.inductionOn s fun _l => List.mem_map_of_injective H\n\n"}
{"name":"Multiset.map_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\ng : β → γ\nf : α → β\ns : Multiset α\n⊢ Eq (Multiset.map g (Multiset.map f s)) (Multiset.map (Function.comp g f) s)","decl":"@[simp]\ntheorem map_map (g : β → γ) (f : α → β) (s : Multiset α) : map g (map f s) = map (g ∘ f) s :=\n  Quot.inductionOn s fun _l => congr_arg _ <| List.map_map _ _ _\n\n"}
{"name":"Multiset.map_id","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.map id s) s","decl":"theorem map_id (s : Multiset α) : map id s = s :=\n  Quot.inductionOn s fun _l => congr_arg _ <| List.map_id _\n\n"}
{"name":"Multiset.map_id'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.map (fun x => x) s) s","decl":"@[simp]\ntheorem map_id' (s : Multiset α) : map (fun x => x) s = s :=\n  map_id s\n\n-- Porting note: was a `simp` lemma in mathlib3\n"}
{"name":"Multiset.map_const","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nb : β\n⊢ Eq (Multiset.map (Function.const α b) s) (Multiset.replicate s.card b)","decl":"theorem map_const (s : Multiset α) (b : β) : map (const α b) s = replicate (card s) b :=\n  Quot.inductionOn s fun _ => congr_arg _ <| List.map_const' _ _\n\n-- Porting note: was not a `simp` lemma in mathlib3 because `Function.const` was reducible\n"}
{"name":"Multiset.map_const'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nb : β\n⊢ Eq (Multiset.map (fun x => b) s) (Multiset.replicate s.card b)","decl":"@[simp] theorem map_const' (s : Multiset α) (b : β) : map (fun _ ↦ b) s = replicate (card s) b :=\n  map_const _ _\n\n"}
{"name":"Multiset.eq_of_mem_map_const","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nb₁ b₂ : β\nl : List α\nh : Membership.mem (Multiset.map (Function.const α b₂) ↑l) b₁\n⊢ Eq b₁ b₂","decl":"theorem eq_of_mem_map_const {b₁ b₂ : β} {l : List α} (h : b₁ ∈ map (Function.const α b₂) l) :\n    b₁ = b₂ :=\n  eq_of_mem_replicate (n := card (l : Multiset α)) <| by rwa [map_const] at h\n\n"}
{"name":"Multiset.map_le_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le (Multiset.map f s) (Multiset.map f t)","decl":"@[simp, gcongr]\ntheorem map_le_map {f : α → β} {s t : Multiset α} (h : s ≤ t) : map f s ≤ map f t :=\n  leInductionOn h fun h => (h.map f).subperm\n\n"}
{"name":"Multiset.map_lt_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns t : Multiset α\nh : LT.lt s t\n⊢ LT.lt (Multiset.map f s) (Multiset.map f t)","decl":"@[simp, gcongr]\ntheorem map_lt_map {f : α → β} {s t : Multiset α} (h : s < t) : s.map f < t.map f := by\n  refine (map_le_map h.le).lt_of_not_le fun H => h.ne <| eq_of_le_of_card_le h.le ?_\n  rw [← s.card_map f, ← t.card_map f]\n  exact card_le_card H\n\n"}
{"name":"Multiset.map_mono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\n⊢ Monotone (Multiset.map f)","decl":"theorem map_mono (f : α → β) : Monotone (map f) := fun _ _ => map_le_map\n\n"}
{"name":"Multiset.map_strictMono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\n⊢ StrictMono (Multiset.map f)","decl":"theorem map_strictMono (f : α → β) : StrictMono (map f) := fun _ _ => map_lt_map\n\n"}
{"name":"Multiset.map_subset_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns t : Multiset α\nH : HasSubset.Subset s t\n⊢ HasSubset.Subset (Multiset.map f s) (Multiset.map f t)","decl":"@[simp, gcongr]\ntheorem map_subset_map {f : α → β} {s t : Multiset α} (H : s ⊆ t) : map f s ⊆ map f t := fun _b m =>\n  let ⟨a, h, e⟩ := mem_map.1 m\n  mem_map.2 ⟨a, H h, e⟩\n\n"}
{"name":"Multiset.map_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nx : α\ns : Multiset α\n⊢ Eq (Multiset.map f (s.erase x)) ((Multiset.map f s).erase (f x))","decl":"theorem map_erase [DecidableEq α] [DecidableEq β] (f : α → β) (hf : Function.Injective f) (x : α)\n    (s : Multiset α) : (s.erase x).map f = (s.map f).erase (f x) := by\n  induction' s using Multiset.induction_on with y s ih\n  · simp\n  by_cases hxy : y = x\n  · cases hxy\n    simp\n  · rw [s.erase_cons_tail hxy, map_cons, map_cons, (s.map f).erase_cons_tail (hf.ne hxy), ih]\n\n"}
{"name":"Multiset.map_erase_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns : Multiset α\nx : α\nh : Membership.mem s x\n⊢ Eq (Multiset.map f (s.erase x)) ((Multiset.map f s).erase (f x))","decl":"theorem map_erase_of_mem [DecidableEq α] [DecidableEq β] (f : α → β)\n    (s : Multiset α) {x : α} (h : x ∈ s) : (s.erase x).map f = (s.map f).erase (f x) := by\n  induction' s using Multiset.induction_on with y s ih\n  · simp\n  rcases eq_or_ne y x with rfl | hxy\n  · simp\n  replace h : x ∈ s := by simpa [hxy.symm] using h\n  rw [s.erase_cons_tail hxy, map_cons, map_cons, ih h, erase_cons_tail_of_mem (mem_map_of_mem f h)]\n\n"}
{"name":"Multiset.map_surjective_of_surjective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nhf : Function.Surjective f\n⊢ Function.Surjective (Multiset.map f)","decl":"theorem map_surjective_of_surjective {f : α → β} (hf : Function.Surjective f) :\n    Function.Surjective (map f) := by\n  intro s\n  induction' s using Multiset.induction_on with x s ih\n  · exact ⟨0, map_zero _⟩\n  · obtain ⟨y, rfl⟩ := hf x\n    obtain ⟨t, rfl⟩ := ih\n    exact ⟨y ::ₘ t, map_cons _ _ _⟩\n\n"}
{"name":"Multiset.foldl_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nb : β\n⊢ Eq (Multiset.foldl f b 0) b","decl":"@[simp]\ntheorem foldl_zero (b) : foldl f b 0 = b :=\n  rfl\n\n"}
{"name":"Multiset.foldl_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nb : β\na : α\ns : Multiset α\n⊢ Eq (Multiset.foldl f b (Multiset.cons a s)) (Multiset.foldl f (f b a) s)","decl":"@[simp]\ntheorem foldl_cons (b a s) : foldl f b (a ::ₘ s) = foldl f (f b a) s :=\n  Quot.inductionOn s fun _l => rfl\n\n"}
{"name":"Multiset.foldl_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nb : β\ns t : Multiset α\n⊢ Eq (Multiset.foldl f b (HAdd.hAdd s t)) (Multiset.foldl f (Multiset.foldl f b s) t)","decl":"@[simp]\ntheorem foldl_add (b s t) : foldl f b (s + t) = foldl f (foldl f b s) t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => foldl_append _ _ _ _\n\n"}
{"name":"Multiset.foldr_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\n⊢ Eq (Multiset.foldr f b 0) b","decl":"@[simp]\ntheorem foldr_zero (b) : foldr f b 0 = b :=\n  rfl\n\n"}
{"name":"Multiset.foldr_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\na : α\ns : Multiset α\n⊢ Eq (Multiset.foldr f b (Multiset.cons a s)) (f a (Multiset.foldr f b s))","decl":"@[simp]\ntheorem foldr_cons (b a s) : foldr f b (a ::ₘ s) = f a (foldr f b s) :=\n  Quot.inductionOn s fun _l => rfl\n\n"}
{"name":"Multiset.foldr_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\na : α\n⊢ Eq (Multiset.foldr f b (Singleton.singleton a)) (f a b)","decl":"@[simp]\ntheorem foldr_singleton (b a) : foldr f b ({a} : Multiset α) = f a b :=\n  rfl\n\n"}
{"name":"Multiset.foldr_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\ns t : Multiset α\n⊢ Eq (Multiset.foldr f b (HAdd.hAdd s t)) (Multiset.foldr f (Multiset.foldr f b t) s)","decl":"@[simp]\ntheorem foldr_add (b s t) : foldr f b (s + t) = foldr f (foldr f b t) s :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => foldr_append _ _ _ _\n\n"}
{"name":"Multiset.coe_foldr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\nl : List α\n⊢ Eq (Multiset.foldr f b ↑l) (List.foldr f b l)","decl":"@[simp]\ntheorem coe_foldr (f : α → β → β) [LeftCommutative f] (b : β) (l : List α) :\n    foldr f b l = l.foldr f b :=\n  rfl\n\n"}
{"name":"Multiset.coe_foldl","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nb : β\nl : List α\n⊢ Eq (Multiset.foldl f b ↑l) (List.foldl f b l)","decl":"@[simp]\ntheorem coe_foldl (f : β → α → β) [RightCommutative f] (b : β) (l : List α) :\n    foldl f b l = l.foldl f b :=\n  rfl\n\n"}
{"name":"Multiset.coe_foldr_swap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\nl : List α\n⊢ Eq (Multiset.foldr f b ↑l) (List.foldl (fun x y => f y x) b l)","decl":"theorem coe_foldr_swap (f : α → β → β) [LeftCommutative f] (b : β) (l : List α) :\n    foldr f b l = l.foldl (fun x y => f y x) b :=\n  (congr_arg (foldr f b) (coe_reverse l)).symm.trans <| foldr_reverse _ _ _\n\n"}
{"name":"Multiset.foldr_swap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nb : β\ns : Multiset α\n⊢ Eq (Multiset.foldr f b s) (Multiset.foldl (fun x y => f y x) b s)","decl":"theorem foldr_swap (f : α → β → β) [LeftCommutative f] (b : β) (s : Multiset α) :\n    foldr f b s = foldl (fun x y => f y x) b s :=\n  Quot.inductionOn s fun _l => coe_foldr_swap _ _ _\n\n"}
{"name":"Multiset.foldl_swap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nb : β\ns : Multiset α\n⊢ Eq (Multiset.foldl f b s) (Multiset.foldr (fun x y => f y x) b s)","decl":"theorem foldl_swap (f : β → α → β) [RightCommutative f] (b : β) (s : Multiset α) :\n    foldl f b s = foldr (fun x y => f y x) b s :=\n  (foldr_swap _ _ _).symm\n\n"}
{"name":"Multiset.foldr_induction'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β → β\ninst✝ : LeftCommutative f\nx : β\nq : α → Prop\np : β → Prop\ns : Multiset α\nhpqf : ∀ (a : α) (b : β), q a → p b → p (f a b)\npx : p x\nq_s : ∀ (a : α), Membership.mem s a → q a\n⊢ p (Multiset.foldr f x s)","decl":"theorem foldr_induction' (f : α → β → β) [LeftCommutative f] (x : β) (q : α → Prop)\n    (p : β → Prop) (s : Multiset α) (hpqf : ∀ a b, q a → p b → p (f a b)) (px : p x)\n    (q_s : ∀ a ∈ s, q a) : p (foldr f x s) := by\n  induction s using Multiset.induction with\n  | empty => simpa\n  | cons a s ihs =>\n    simp only [forall_mem_cons, foldr_cons] at q_s ⊢\n    exact hpqf _ _ q_s.1 (ihs q_s.2)\n\n"}
{"name":"Multiset.foldr_induction","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nf : α → α → α\ninst✝ : LeftCommutative f\nx : α\np : α → Prop\ns : Multiset α\np_f : ∀ (a b : α), p a → p b → p (f a b)\npx : p x\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p (Multiset.foldr f x s)","decl":"theorem foldr_induction (f : α → α → α) [LeftCommutative f] (x : α) (p : α → Prop)\n    (s : Multiset α) (p_f : ∀ a b, p a → p b → p (f a b)) (px : p x) (p_s : ∀ a ∈ s, p a) :\n    p (foldr f x s) :=\n  foldr_induction' f x p p s p_f px p_s\n\n"}
{"name":"Multiset.foldl_induction'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : β → α → β\ninst✝ : RightCommutative f\nx : β\nq : α → Prop\np : β → Prop\ns : Multiset α\nhpqf : ∀ (a : α) (b : β), q a → p b → p (f b a)\npx : p x\nq_s : ∀ (a : α), Membership.mem s a → q a\n⊢ p (Multiset.foldl f x s)","decl":"theorem foldl_induction' (f : β → α → β) [RightCommutative f] (x : β) (q : α → Prop)\n    (p : β → Prop) (s : Multiset α) (hpqf : ∀ a b, q a → p b → p (f b a)) (px : p x)\n    (q_s : ∀ a ∈ s, q a) : p (foldl f x s) := by\n  rw [foldl_swap]\n  exact foldr_induction' (fun x y => f y x) x q p s hpqf px q_s\n\n"}
{"name":"Multiset.foldl_induction","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nf : α → α → α\ninst✝ : RightCommutative f\nx : α\np : α → Prop\ns : Multiset α\np_f : ∀ (a b : α), p a → p b → p (f b a)\npx : p x\np_s : ∀ (a : α), Membership.mem s a → p a\n⊢ p (Multiset.foldl f x s)","decl":"theorem foldl_induction (f : α → α → α) [RightCommutative f] (x : α) (p : α → Prop)\n    (s : Multiset α) (p_f : ∀ a b, p a → p b → p (f b a)) (px : p x) (p_s : ∀ a ∈ s, p a) :\n    p (foldl f x s) :=\n  foldl_induction' f x p p s p_f px p_s\n\n"}
{"name":"Multiset.coe_pmap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\nl : List α\nH : ∀ (a : α), Membership.mem l a → p a\n⊢ Eq (Multiset.pmap f (↑l) H) ↑(List.pmap f l H)","decl":"@[simp]\ntheorem coe_pmap {p : α → Prop} (f : ∀ a, p a → β) (l : List α) (H : ∀ a ∈ l, p a) :\n    pmap f l H = l.pmap f H :=\n  rfl\n\n"}
{"name":"Multiset.pmap_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\nh : ∀ (a : α), Membership.mem 0 a → p a\n⊢ Eq (Multiset.pmap f 0 h) 0","decl":"@[simp]\ntheorem pmap_zero {p : α → Prop} (f : ∀ a, p a → β) (h : ∀ a ∈ (0 : Multiset α), p a) :\n    pmap f 0 h = 0 :=\n  rfl\n\n"}
{"name":"Multiset.pmap_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\na : α\nm : Multiset α\nh : ∀ (b : α), Membership.mem (Multiset.cons a m) b → p b\n⊢ Eq (Multiset.pmap f (Multiset.cons a m) h) (Multiset.cons (f a ⋯) (Multiset.pmap f m ⋯))","decl":"@[simp]\ntheorem pmap_cons {p : α → Prop} (f : ∀ a, p a → β) (a : α) (m : Multiset α) :\n    ∀ h : ∀ b ∈ a ::ₘ m, p b,\n      pmap f (a ::ₘ m) h =\n        f a (h a (mem_cons_self a m)) ::ₘ pmap f m fun a ha => h a <| mem_cons_of_mem ha :=\n  Quotient.inductionOn m fun _l _h => rfl\n\n"}
{"name":"Multiset.coe_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).attach ↑l.attach","decl":"@[simp]\ntheorem coe_attach (l : List α) : @Eq (Multiset { x // x ∈ l }) (@attach α l) l.attach :=\n  rfl\n\n"}
{"name":"Multiset.sizeOf_lt_sizeOf_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\nx : α\ns : Multiset α\nhx : Membership.mem s x\n⊢ LT.lt (SizeOf.sizeOf x) (SizeOf.sizeOf s)","decl":"theorem sizeOf_lt_sizeOf_of_mem [SizeOf α] {x : α} {s : Multiset α} (hx : x ∈ s) :\n    SizeOf.sizeOf x < SizeOf.sizeOf s := by\n  induction' s using Quot.inductionOn with l a b\n  exact List.sizeOf_lt_sizeOf_of_mem hx\n\n"}
{"name":"Multiset.pmap_eq_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : α → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\n⊢ Eq (Multiset.pmap (fun a x => f a) s H) (Multiset.map f s)","decl":"theorem pmap_eq_map (p : α → Prop) (f : α → β) (s : Multiset α) :\n    ∀ H, @pmap _ _ p (fun a _ => f a) s H = map f s :=\n  Quot.inductionOn s fun l H => congr_arg _ <| List.pmap_eq_map p f l H\n\n"}
{"name":"Multiset.pmap_congr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np q : α → Prop\nf : (a : α) → p a → β\ng : (a : α) → q a → β\ns : Multiset α\nH₁ : ∀ (a : α), Membership.mem s a → p a\nH₂ : ∀ (a : α), Membership.mem s a → q a\na✝ : ∀ (a : α), Membership.mem s a → ∀ (h₁ : p a) (h₂ : q a), Eq (f a h₁) (g a h₂)\n⊢ Eq (Multiset.pmap f s H₁) (Multiset.pmap g s H₂)","decl":"theorem pmap_congr {p q : α → Prop} {f : ∀ a, p a → β} {g : ∀ a, q a → β} (s : Multiset α) :\n    ∀ {H₁ H₂}, (∀ a ∈ s, ∀ (h₁ h₂), f a h₁ = g a h₂) → pmap f s H₁ = pmap g s H₂ :=\n  @(Quot.inductionOn s (fun l _H₁ _H₂ h => congr_arg _ <| List.pmap_congr_left l h))\n\n"}
{"name":"Multiset.map_pmap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\np : α → Prop\ng : β → γ\nf : (a : α) → p a → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\n⊢ Eq (Multiset.map g (Multiset.pmap f s H)) (Multiset.pmap (fun a h => g (f a h)) s H)","decl":"theorem map_pmap {p : α → Prop} (g : β → γ) (f : ∀ a, p a → β) (s) :\n    ∀ H, map g (pmap f s H) = pmap (fun a h => g (f a h)) s H :=\n  Quot.inductionOn s fun l H => congr_arg _ <| List.map_pmap g f l H\n\n"}
{"name":"Multiset.pmap_eq_map_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\n⊢ Eq (Multiset.pmap f s H) (Multiset.map (fun x => f ↑x ⋯) s.attach)","decl":"theorem pmap_eq_map_attach {p : α → Prop} (f : ∀ a, p a → β) (s) :\n    ∀ H, pmap f s H = s.attach.map fun x => f x.1 (H _ x.2) :=\n  Quot.inductionOn s fun l H => congr_arg _ <| List.pmap_eq_map_attach f l H\n\n-- @[simp] -- Porting note: Left hand does not simplify\n"}
{"name":"Multiset.attach_map_val'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → β\n⊢ Eq (Multiset.map (fun i => f ↑i) s.attach) (Multiset.map f s)","decl":"theorem attach_map_val' (s : Multiset α) (f : α → β) : (s.attach.map fun i => f i.val) = s.map f :=\n  Quot.inductionOn s fun l => congr_arg _ <| List.attach_map_coe l f\n\n"}
{"name":"Multiset.attach_map_val","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.map Subtype.val s.attach) s","decl":"@[simp]\ntheorem attach_map_val (s : Multiset α) : s.attach.map Subtype.val = s :=\n  (attach_map_val' _ _).trans s.map_id\n\n"}
{"name":"Multiset.mem_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\nx : Subtype fun x => Membership.mem s x\n⊢ Membership.mem s.attach x","decl":"@[simp]\ntheorem mem_attach (s : Multiset α) : ∀ x, x ∈ s.attach :=\n  Quot.inductionOn s fun _l => List.mem_attach _\n\n"}
{"name":"Multiset.mem_pmap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\nb : β\n⊢ Iff (Membership.mem (Multiset.pmap f s H) b) (Exists fun a => Exists fun h => Eq (f a ⋯) b)","decl":"@[simp]\ntheorem mem_pmap {p : α → Prop} {f : ∀ a, p a → β} {s H b} :\n    b ∈ pmap f s H ↔ ∃ (a : _) (h : a ∈ s), f a (H a h) = b :=\n  Quot.inductionOn s (fun _l _H => List.mem_pmap) H\n\n"}
{"name":"Multiset.card_pmap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\nf : (a : α) → p a → β\ns : Multiset α\nH : ∀ (a : α), Membership.mem s a → p a\n⊢ Eq (Multiset.pmap f s H).card s.card","decl":"@[simp]\ntheorem card_pmap {p : α → Prop} (f : ∀ a, p a → β) (s H) : card (pmap f s H) = card s :=\n  Quot.inductionOn s (fun _l _H => length_pmap) H\n\n"}
{"name":"Multiset.card_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\n⊢ Eq m.attach.card m.card","decl":"@[simp]\ntheorem card_attach {m : Multiset α} : card (attach m) = card m :=\n  card_pmap _ _ _\n\n"}
{"name":"Multiset.attach_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.attach 0) 0","decl":"@[simp]\ntheorem attach_zero : (0 : Multiset α).attach = 0 :=\n  rfl\n\n"}
{"name":"Multiset.attach_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\nm : Multiset α\n⊢ Eq (Multiset.cons a m).attach (Multiset.cons ⟨a, ⋯⟩ (Multiset.map (fun p => ⟨↑p, ⋯⟩) m.attach))","decl":"theorem attach_cons (a : α) (m : Multiset α) :\n    (a ::ₘ m).attach =\n      ⟨a, mem_cons_self a m⟩ ::ₘ m.attach.map fun p => ⟨p.1, mem_cons_of_mem p.2⟩ :=\n  Quotient.inductionOn m fun l =>\n    congr_arg _ <|\n      congr_arg (List.cons _) <| by\n        rw [List.map_pmap]; exact List.pmap_congr_left _ fun _ _ _ _ => Subtype.eq rfl\n\n"}
{"name":"Multiset.filter_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\n⊢ Eq (Multiset.filter p ↑l) ↑(List.filter (fun b => Decidable.decide (p b)) l)","decl":"@[simp, norm_cast] lemma filter_coe (l : List α) : filter p l = l.filter p := rfl\n\n"}
{"name":"Multiset.filter_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filter p 0) 0","decl":"@[simp]\ntheorem filter_zero : filter p 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.filter_congr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Multiset α\na✝ : ∀ (x : α), Membership.mem s x → Iff (p x) (q x)\n⊢ Eq (Multiset.filter p s) (Multiset.filter q s)","decl":"@[congr]\ntheorem filter_congr {p q : α → Prop} [DecidablePred p] [DecidablePred q] {s : Multiset α} :\n    (∀ x ∈ s, p x ↔ q x) → filter p s = filter q s :=\n  Quot.inductionOn s fun _l h => congr_arg ofList <| List.filter_congr <| by simpa using h\n\n"}
{"name":"Multiset.filter_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Eq (Multiset.filter p (HAdd.hAdd s t)) (HAdd.hAdd (Multiset.filter p s) (Multiset.filter p t))","decl":"@[simp]\ntheorem filter_add (s t : Multiset α) : filter p (s + t) = filter p s + filter p t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => congr_arg ofList <| filter_append _ _\n\n"}
{"name":"Multiset.filter_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ LE.le (Multiset.filter p s) s","decl":"@[simp]\ntheorem filter_le (s : Multiset α) : filter p s ≤ s :=\n  Quot.inductionOn s fun _l => (filter_sublist _).subperm\n\n"}
{"name":"Multiset.filter_subset","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ HasSubset.Subset (Multiset.filter p s) s","decl":"@[simp]\ntheorem filter_subset (s : Multiset α) : filter p s ⊆ s :=\n  subset_of_le <| filter_le _ _\n\n"}
{"name":"Multiset.filter_le_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le (Multiset.filter p s) (Multiset.filter p t)","decl":"@[gcongr]\ntheorem filter_le_filter {s t} (h : s ≤ t) : filter p s ≤ filter p t :=\n  leInductionOn h fun h => (h.filter (p ·)).subperm\n\n"}
{"name":"Multiset.monotone_filter_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Monotone (Multiset.filter p)","decl":"theorem monotone_filter_left : Monotone (filter p) := fun _s _t => filter_le_filter p\n\n"}
{"name":"Multiset.monotone_filter_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nh : ∀ (b : α), p b → q b\n⊢ LE.le (Multiset.filter p s) (Multiset.filter q s)","decl":"theorem monotone_filter_right (s : Multiset α) ⦃p q : α → Prop⦄ [DecidablePred p] [DecidablePred q]\n    (h : ∀ b, p b → q b) :\n    s.filter p ≤ s.filter q :=\n  Quotient.inductionOn s fun l => (l.monotone_filter_right <| by simpa using h).subperm\n\n"}
{"name":"Multiset.filter_cons_of_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\na✝ : p a\n⊢ Eq (Multiset.filter p (Multiset.cons a s)) (Multiset.cons a (Multiset.filter p s))","decl":"@[simp]\ntheorem filter_cons_of_pos {a : α} (s) : p a → filter p (a ::ₘ s) = a ::ₘ filter p s :=\n  Quot.inductionOn s fun _ h => congr_arg ofList <| List.filter_cons_of_pos <| by simpa using h\n\n"}
{"name":"Multiset.filter_cons_of_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\na✝ : Not (p a)\n⊢ Eq (Multiset.filter p (Multiset.cons a s)) (Multiset.filter p s)","decl":"@[simp]\ntheorem filter_cons_of_neg {a : α} (s) : ¬p a → filter p (a ::ₘ s) = filter p s :=\n  Quot.inductionOn s fun _ h => congr_arg ofList <| List.filter_cons_of_neg <| by simpa using h\n\n"}
{"name":"Multiset.mem_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.filter p s) a) (And (Membership.mem s a) (p a))","decl":"@[simp]\ntheorem mem_filter {a : α} {s} : a ∈ filter p s ↔ a ∈ s ∧ p a :=\n  Quot.inductionOn s fun _l => by simp\n\n"}
{"name":"Multiset.of_mem_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\nh : Membership.mem (Multiset.filter p s) a\n⊢ p a","decl":"theorem of_mem_filter {a : α} {s} (h : a ∈ filter p s) : p a :=\n  (mem_filter.1 h).2\n\n"}
{"name":"Multiset.mem_of_mem_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\nh : Membership.mem (Multiset.filter p s) a\n⊢ Membership.mem s a","decl":"theorem mem_of_mem_filter {a : α} {s} (h : a ∈ filter p s) : a ∈ s :=\n  (mem_filter.1 h).1\n\n"}
{"name":"Multiset.mem_filter_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\nl : Multiset α\nm : Membership.mem l a\nh : p a\n⊢ Membership.mem (Multiset.filter p l) a","decl":"theorem mem_filter_of_mem {a : α} {l} (m : a ∈ l) (h : p a) : a ∈ filter p l :=\n  mem_filter.2 ⟨m, h⟩\n\n"}
{"name":"Multiset.filter_eq_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Iff (Eq (Multiset.filter p s) s) (∀ (a : α), Membership.mem s a → p a)","decl":"theorem filter_eq_self {s} : filter p s = s ↔ ∀ a ∈ s, p a :=\n  Quot.inductionOn s fun _l =>\n    Iff.trans ⟨fun h => (filter_sublist _).eq_of_length (congr_arg card h),\n      congr_arg ofList⟩ <| by simp\n\n"}
{"name":"Multiset.filter_eq_nil","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Iff (Eq (Multiset.filter p s) 0) (∀ (a : α), Membership.mem s a → Not (p a))","decl":"theorem filter_eq_nil {s} : filter p s = 0 ↔ ∀ a ∈ s, ¬p a :=\n  Quot.inductionOn s fun _l =>\n    Iff.trans ⟨fun h => eq_nil_of_length_eq_zero (congr_arg card h), congr_arg ofList⟩ (by simp)\n\n"}
{"name":"Multiset.le_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Iff (LE.le s (Multiset.filter p t)) (And (LE.le s t) (∀ (a : α), Membership.mem s a → p a))","decl":"theorem le_filter {s t} : s ≤ filter p t ↔ s ≤ t ∧ ∀ a ∈ s, p a :=\n  ⟨fun h => ⟨le_trans h (filter_le _ _), fun _a m => of_mem_filter (mem_of_le h m)⟩, fun ⟨h, al⟩ =>\n    filter_eq_self.2 al ▸ filter_le_filter p h⟩\n\n"}
{"name":"Multiset.filter_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\n⊢ Eq (Multiset.filter p (Multiset.cons a s)) (HAdd.hAdd (ite (p a) (Singleton.singleton a) 0) (Multiset.filter p s))","decl":"theorem filter_cons {a : α} (s : Multiset α) :\n    filter p (a ::ₘ s) = (if p a then {a} else 0) + filter p s := by\n  split_ifs with h\n  · rw [filter_cons_of_pos _ h, singleton_add]\n  · rw [filter_cons_of_neg _ h, Multiset.zero_add]\n\n"}
{"name":"Multiset.filter_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filter p (Singleton.singleton a)) (ite (p a) (Singleton.singleton a) EmptyCollection.emptyCollection)","decl":"theorem filter_singleton {a : α} (p : α → Prop) [DecidablePred p] :\n    filter p {a} = if p a then {a} else ∅ := by\n  simp only [singleton, filter_cons, filter_zero, Multiset.add_zero, empty_eq_zero]\n\n"}
{"name":"Multiset.filter_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\nq : α → Prop\ninst✝ : DecidablePred q\ns : Multiset α\n⊢ Eq (Multiset.filter p (Multiset.filter q s)) (Multiset.filter (fun a => And (p a) (q a)) s)","decl":"@[simp]\ntheorem filter_filter (q) [DecidablePred q] (s : Multiset α) :\n    filter p (filter q s) = filter (fun a => p a ∧ q a) s :=\n  Quot.inductionOn s fun l => by simp\n\n"}
{"name":"Multiset.filter_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\nq : α → Prop\ninst✝ : DecidablePred q\ns : Multiset α\n⊢ Eq (Multiset.filter p (Multiset.filter q s)) (Multiset.filter q (Multiset.filter p s))","decl":"lemma filter_comm (q) [DecidablePred q] (s : Multiset α) :\n    filter p (filter q s) = filter q (filter p s) := by simp [and_comm]\n\n"}
{"name":"Multiset.filter_add_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\nq : α → Prop\ninst✝ : DecidablePred q\ns : Multiset α\n⊢ Eq (HAdd.hAdd (Multiset.filter p s) (Multiset.filter q s)) (HAdd.hAdd (Multiset.filter (fun a => Or (p a) (q a)) s) (Multiset.filter (fun a => And (p a) (q a)) s))","decl":"theorem filter_add_filter (q) [DecidablePred q] (s : Multiset α) :\n    filter p s + filter q s = filter (fun a => p a ∨ q a) s + filter (fun a => p a ∧ q a) s :=\n  Multiset.induction_on s rfl fun a s IH => by by_cases p a <;> by_cases q a <;> simp [*]\n\n"}
{"name":"Multiset.filter_add_not","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq (HAdd.hAdd (Multiset.filter p s) (Multiset.filter (fun a => Not (p a)) s)) s","decl":"theorem filter_add_not (s : Multiset α) : filter p s + filter (fun a => ¬p a) s = s := by\n  rw [filter_add_filter, filter_eq_self.2, filter_eq_nil.2]\n  · simp only [Multiset.add_zero]\n  · simp [Decidable.em, -Bool.not_eq_true, -not_and, not_and_or, or_comm]\n  · simp only [Bool.not_eq_true, decide_eq_true_eq, Bool.eq_false_or_eq_true,\n      decide_true, implies_true, Decidable.em]\n\n"}
{"name":"Multiset.filter_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\ninst✝ : DecidablePred p\nf : β → α\ns : Multiset β\n⊢ Eq (Multiset.filter p (Multiset.map f s)) (Multiset.map f (Multiset.filter (Function.comp p f) s))","decl":"theorem filter_map (f : β → α) (s : Multiset β) : filter p (map f s) = map f (filter (p ∘ f) s) :=\n  Quot.inductionOn s fun l => by simp [List.filter_map]; rfl\n\n-- TODO: rename to `map_filter` when the deprecated alias above is removed.\n"}
{"name":"Multiset.map_filter'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\ninst✝¹ : DecidablePred p\nf : α → β\nhf : Function.Injective f\ns : Multiset α\ninst✝ : DecidablePred fun b => Exists fun a => And (p a) (Eq (f a) b)\n⊢ Eq (Multiset.map f (Multiset.filter p s)) (Multiset.filter (fun b => Exists fun a => And (p a) (Eq (f a) b)) (Multiset.map f s))","decl":"lemma map_filter' {f : α → β} (hf : Injective f) (s : Multiset α)\n    [DecidablePred fun b => ∃ a, p a ∧ f a = b] :\n    (s.filter p).map f = (s.map f).filter fun b => ∃ a, p a ∧ f a = b := by\n  simp [comp_def, filter_map, hf.eq_iff]\n\n"}
{"name":"Multiset.card_filter_le_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\nP : α → Prop\ninst✝ : DecidablePred P\nn : Nat\n⊢ Iff (LE.le (Multiset.filter P s).card n) (∀ (s' : Multiset α), LE.le s' s → LT.lt n s'.card → Exists fun a => And (Membership.mem s' a) (Not (P a)))","decl":"lemma card_filter_le_iff (s : Multiset α) (P : α → Prop) [DecidablePred P] (n : ℕ) :\n    card (s.filter P) ≤ n ↔ ∀ s' ≤ s, n < card s' → ∃ a ∈ s', ¬ P a := by\n  fconstructor\n  · intro H s' hs' s'_card\n    by_contra! rid\n    have card := card_le_card (monotone_filter_left P hs') |>.trans H\n    exact s'_card.not_le (filter_eq_self.mpr rid ▸ card)\n  · contrapose!\n    exact fun H ↦ ⟨s.filter P, filter_le _ _, H, fun a ha ↦ (mem_filter.mp ha).2⟩\n\n"}
{"name":"Multiset.filterMap_coe","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\nl : List α\n⊢ Eq (Multiset.filterMap f ↑l) ↑(List.filterMap f l)","decl":"@[simp, norm_cast]\nlemma filterMap_coe (f : α → Option β) (l : List α) : filterMap f l = l.filterMap f := rfl\n\n"}
{"name":"Multiset.filterMap_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\n⊢ Eq (Multiset.filterMap f 0) 0","decl":"@[simp]\ntheorem filterMap_zero (f : α → Option β) : filterMap f 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.filterMap_cons_none","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\na : α\ns : Multiset α\nh : Eq (f a) Option.none\n⊢ Eq (Multiset.filterMap f (Multiset.cons a s)) (Multiset.filterMap f s)","decl":"@[simp]\ntheorem filterMap_cons_none {f : α → Option β} (a : α) (s : Multiset α) (h : f a = none) :\n    filterMap f (a ::ₘ s) = filterMap f s :=\n  Quot.inductionOn s fun _ => congr_arg ofList <| List.filterMap_cons_none h\n\n"}
{"name":"Multiset.filterMap_cons_some","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\na : α\ns : Multiset α\nb : β\nh : Eq (f a) (Option.some b)\n⊢ Eq (Multiset.filterMap f (Multiset.cons a s)) (Multiset.cons b (Multiset.filterMap f s))","decl":"@[simp]\ntheorem filterMap_cons_some (f : α → Option β) (a : α) (s : Multiset α) {b : β}\n    (h : f a = some b) : filterMap f (a ::ₘ s) = b ::ₘ filterMap f s :=\n  Quot.inductionOn s fun _ => congr_arg ofList <| List.filterMap_cons_some h\n\n"}
{"name":"Multiset.filterMap_eq_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\n⊢ Eq (Multiset.filterMap (Function.comp Option.some f)) (Multiset.map f)","decl":"theorem filterMap_eq_map (f : α → β) : filterMap (some ∘ f) = map f :=\n  funext fun s =>\n    Quot.inductionOn s fun l => congr_arg ofList <| congr_fun (List.filterMap_eq_map f) l\n\n"}
{"name":"Multiset.filterMap_eq_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filterMap (Option.guard p)) (Multiset.filter p)","decl":"theorem filterMap_eq_filter : filterMap (Option.guard p) = filter p :=\n  funext fun s =>\n    Quot.inductionOn s fun l => congr_arg ofList <| by\n      rw [← List.filterMap_eq_filter]\n      congr; funext a; simp\n\n"}
{"name":"Multiset.filterMap_filterMap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nf : α → Option β\ng : β → Option γ\ns : Multiset α\n⊢ Eq (Multiset.filterMap g (Multiset.filterMap f s)) (Multiset.filterMap (fun x => (f x).bind g) s)","decl":"theorem filterMap_filterMap (f : α → Option β) (g : β → Option γ) (s : Multiset α) :\n    filterMap g (filterMap f s) = filterMap (fun x => (f x).bind g) s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.filterMap_filterMap f g l\n\n"}
{"name":"Multiset.map_filterMap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nf : α → Option β\ng : β → γ\ns : Multiset α\n⊢ Eq (Multiset.map g (Multiset.filterMap f s)) (Multiset.filterMap (fun x => Option.map g (f x)) s)","decl":"theorem map_filterMap (f : α → Option β) (g : β → γ) (s : Multiset α) :\n    map g (filterMap f s) = filterMap (fun x => (f x).map g) s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.map_filterMap f g l\n\n"}
{"name":"Multiset.filterMap_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nf : α → β\ng : β → Option γ\ns : Multiset α\n⊢ Eq (Multiset.filterMap g (Multiset.map f s)) (Multiset.filterMap (Function.comp g f) s)","decl":"theorem filterMap_map (f : α → β) (g : β → Option γ) (s : Multiset α) :\n    filterMap g (map f s) = filterMap (g ∘ f) s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.filterMap_map f g l\n\n"}
{"name":"Multiset.filter_filterMap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\np : β → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq (Multiset.filter p (Multiset.filterMap f s)) (Multiset.filterMap (fun x => Option.filter (fun b => Decidable.decide (p b)) (f x)) s)","decl":"theorem filter_filterMap (f : α → Option β) (p : β → Prop) [DecidablePred p] (s : Multiset α) :\n    filter p (filterMap f s) = filterMap (fun x => (f x).filter p) s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.filter_filterMap f p l\n\n"}
{"name":"Multiset.filterMap_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\np : α → Prop\ninst✝ : DecidablePred p\nf : α → Option β\ns : Multiset α\n⊢ Eq (Multiset.filterMap f (Multiset.filter p s)) (Multiset.filterMap (fun x => ite (p x) (f x) Option.none) s)","decl":"theorem filterMap_filter (f : α → Option β) (s : Multiset α) :\n    filterMap f (filter p s) = filterMap (fun x => if p x then f x else none) s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| by simpa using List.filterMap_filter p f l\n\n"}
{"name":"Multiset.filterMap_some","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.filterMap Option.some s) s","decl":"@[simp]\ntheorem filterMap_some (s : Multiset α) : filterMap some s = s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.filterMap_some l\n\n"}
{"name":"Multiset.mem_filterMap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\ns : Multiset α\nb : β\n⊢ Iff (Membership.mem (Multiset.filterMap f s) b) (Exists fun a => And (Membership.mem s a) (Eq (f a) (Option.some b)))","decl":"@[simp]\ntheorem mem_filterMap (f : α → Option β) (s : Multiset α) {b : β} :\n    b ∈ filterMap f s ↔ ∃ a, a ∈ s ∧ f a = some b :=\n  Quot.inductionOn s fun _ => List.mem_filterMap\n\n"}
{"name":"Multiset.map_filterMap_of_inv","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\ng : β → α\nH : ∀ (x : α), Eq (Option.map g (f x)) (Option.some x)\ns : Multiset α\n⊢ Eq (Multiset.map g (Multiset.filterMap f s)) s","decl":"theorem map_filterMap_of_inv (f : α → Option β) (g : β → α) (H : ∀ x : α, (f x).map g = some x)\n    (s : Multiset α) : map g (filterMap f s) = s :=\n  Quot.inductionOn s fun l => congr_arg ofList <| List.map_filterMap_of_inv f g H l\n\n"}
{"name":"Multiset.filterMap_le_filterMap","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Option β\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le (Multiset.filterMap f s) (Multiset.filterMap f t)","decl":"@[gcongr]\ntheorem filterMap_le_filterMap (f : α → Option β) {s t : Multiset α} (h : s ≤ t) :\n    filterMap f s ≤ filterMap f t :=\n  leInductionOn h fun h => (h.filterMap _).subperm\n\n"}
{"name":"Multiset.coe_countP","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : List α\n⊢ Eq (Multiset.countP p ↑l) (List.countP (fun b => Decidable.decide (p b)) l)","decl":"@[simp]\ntheorem coe_countP (l : List α) : countP p l = l.countP p :=\n  rfl\n\n"}
{"name":"Multiset.countP_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.countP p 0) 0","decl":"@[simp]\ntheorem countP_zero : countP p 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.countP_cons_of_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\na✝ : p a\n⊢ Eq (Multiset.countP p (Multiset.cons a s)) (HAdd.hAdd (Multiset.countP p s) 1)","decl":"@[simp]\ntheorem countP_cons_of_pos {a : α} (s) : p a → countP p (a ::ₘ s) = countP p s + 1 :=\n  Quot.inductionOn s <| by simpa using List.countP_cons_of_pos (p ·)\n\n"}
{"name":"Multiset.countP_cons_of_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\na✝ : Not (p a)\n⊢ Eq (Multiset.countP p (Multiset.cons a s)) (Multiset.countP p s)","decl":"@[simp]\ntheorem countP_cons_of_neg {a : α} (s) : ¬p a → countP p (a ::ₘ s) = countP p s :=\n  Quot.inductionOn s <| by simpa using List.countP_cons_of_neg (p ·)\n\n"}
{"name":"Multiset.countP_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nb : α\ns : Multiset α\n⊢ Eq (Multiset.countP p (Multiset.cons b s)) (HAdd.hAdd (Multiset.countP p s) (ite (p b) 1 0))","decl":"theorem countP_cons (b : α) (s) : countP p (b ::ₘ s) = countP p s + if p b then 1 else 0 :=\n  Quot.inductionOn s <| by simp [List.countP_cons]\n\n"}
{"name":"Multiset.countP_eq_card_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq (Multiset.countP p s) (Multiset.filter p s).card","decl":"theorem countP_eq_card_filter (s) : countP p s = card (filter p s) :=\n  Quot.inductionOn s fun l => l.countP_eq_length_filter (p ·)\n\n"}
{"name":"Multiset.countP_le_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ LE.le (Multiset.countP p s) s.card","decl":"theorem countP_le_card (s) : countP p s ≤ card s :=\n  Quot.inductionOn s fun _l => countP_le_length (p ·)\n\n"}
{"name":"Multiset.countP_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Eq (Multiset.countP p (HAdd.hAdd s t)) (HAdd.hAdd (Multiset.countP p s) (Multiset.countP p t))","decl":"@[simp]\ntheorem countP_add (s t) : countP p (s + t) = countP p s + countP p t := by\n  simp [countP_eq_card_filter]\n\n"}
{"name":"Multiset.card_eq_countP_add_countP","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq s.card (HAdd.hAdd (Multiset.countP p s) (Multiset.countP (fun x => Not (p x)) s))","decl":"theorem card_eq_countP_add_countP (s) : card s = countP p s + countP (fun x => ¬p x) s :=\n  Quot.inductionOn s fun l => by simp [l.length_eq_countP_add_countP p]\n\n"}
{"name":"Multiset.countP_le_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le (Multiset.countP p s) (Multiset.countP p t)","decl":"@[gcongr]\ntheorem countP_le_of_le {s t} (h : s ≤ t) : countP p s ≤ countP p t := by\n  simpa [countP_eq_card_filter] using card_le_card (filter_le_filter p h)\n\n"}
{"name":"Multiset.countP_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝¹ : DecidablePred p\nq : α → Prop\ninst✝ : DecidablePred q\ns : Multiset α\n⊢ Eq (Multiset.countP p (Multiset.filter q s)) (Multiset.countP (fun a => And (p a) (q a)) s)","decl":"@[simp]\ntheorem countP_filter (q) [DecidablePred q] (s : Multiset α) :\n    countP p (filter q s) = countP (fun a => p a ∧ q a) s := by simp [countP_eq_card_filter]\n\n"}
{"name":"Multiset.countP_eq_countP_filter_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\n⊢ Eq (Multiset.countP p s) (HAdd.hAdd (Multiset.countP p (Multiset.filter q s)) (Multiset.countP p (Multiset.filter (fun a => Not (q a)) s)))","decl":"theorem countP_eq_countP_filter_add (s) (p q : α → Prop) [DecidablePred p] [DecidablePred q] :\n    countP p s = (filter q s).countP p + (filter (fun a => ¬q a) s).countP p :=\n  Quot.inductionOn s fun l => by\n    convert l.countP_eq_countP_filter_add (p ·) (q ·)\n    simp [countP_filter]\n\n"}
{"name":"Multiset.countP_True","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.countP (fun x => True) s) s.card","decl":"@[simp]\ntheorem countP_True {s : Multiset α} : countP (fun _ => True) s = card s :=\n  Quot.inductionOn s fun _l => congrFun List.countP_true _\n\n"}
{"name":"Multiset.countP_False","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.countP (fun x => False) s) 0","decl":"@[simp]\ntheorem countP_False {s : Multiset α} : countP (fun _ => False) s = 0 :=\n  Quot.inductionOn s fun _l => congrFun List.countP_false _\n\n"}
{"name":"Multiset.countP_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\ns : Multiset α\np : β → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.countP p (Multiset.map f s)) (Multiset.filter (fun a => p (f a)) s).card","decl":"theorem countP_map (f : α → β) (s : Multiset α) (p : β → Prop) [DecidablePred p] :\n    countP p (map f s) = card (s.filter fun a => p (f a)) := by\n  refine Multiset.induction_on s ?_ fun a t IH => ?_\n  · rw [map_zero, countP_zero, filter_zero, card_zero]\n  · rw [map_cons, countP_cons, IH, filter_cons, card_add, apply_ite card, card_zero, card_singleton,\n      Nat.add_comm]\n\n-- Porting note: `Lean.Internal.coeM` forces us to type-ascript `{a // a ∈ s}`\n"}
{"name":"Multiset.countP_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq (Multiset.countP (fun a => p ↑a) s.attach) (Multiset.countP p s)","decl":"lemma countP_attach (s : Multiset α) : s.attach.countP (fun a : {a // a ∈ s} ↦ p a) = s.countP p :=\n  Quotient.inductionOn s fun l => by\n    simp only [quot_mk_to_coe, coe_countP]\n    -- Porting note: was\n    -- rw [quot_mk_to_coe, coe_attach, coe_countP]\n    -- exact List.countP_attach _ _\n    rw [coe_attach]\n    refine (coe_countP _ _).trans ?_\n    convert List.countP_attach _ _\n    rfl\n\n"}
{"name":"Multiset.filter_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filter (fun a => p ↑a) s.attach) (Multiset.map (Subtype.map id ⋯) (Multiset.filter p s).attach)","decl":"lemma filter_attach (s : Multiset α) (p : α → Prop) [DecidablePred p] :\n    (s.attach.filter fun a : {a // a ∈ s} ↦ p ↑a) =\n      (s.filter p).attach.map (Subtype.map id fun _ ↦ Multiset.mem_of_mem_filter) :=\n  Quotient.inductionOn s fun l ↦ congr_arg _ (List.filter_attach l p)\n\n"}
{"name":"Multiset.countP_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Iff (LT.lt 0 (Multiset.countP p s)) (Exists fun a => And (Membership.mem s a) (p a))","decl":"theorem countP_pos {s} : 0 < countP p s ↔ ∃ a ∈ s, p a :=\n  Quot.inductionOn s fun _l => by simp\n\n"}
{"name":"Multiset.countP_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Iff (Eq (Multiset.countP p s) 0) (∀ (a : α), Membership.mem s a → Not (p a))","decl":"theorem countP_eq_zero {s} : countP p s = 0 ↔ ∀ a ∈ s, ¬p a :=\n  Quot.inductionOn s fun _l => by simp [List.countP_eq_zero]\n\n"}
{"name":"Multiset.countP_eq_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Iff (Eq (Multiset.countP p s) s.card) (∀ (a : α), Membership.mem s a → p a)","decl":"theorem countP_eq_card {s} : countP p s = card s ↔ ∀ a ∈ s, p a :=\n  Quot.inductionOn s fun _l => by simp [List.countP_eq_length]\n\n"}
{"name":"Multiset.countP_pos_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\na : α\nh : Membership.mem s a\npa : p a\n⊢ LT.lt 0 (Multiset.countP p s)","decl":"theorem countP_pos_of_mem {s a} (h : a ∈ s) (pa : p a) : 0 < countP p s :=\n  countP_pos.2 ⟨_, h, pa⟩\n\n"}
{"name":"Multiset.countP_congr","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns s' : Multiset α\nhs : Eq s s'\np p' : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred p'\nhp : ∀ (x : α), Membership.mem s x → Eq (p x) (p' x)\n⊢ Eq (Multiset.countP p s) (Multiset.countP p' s')","decl":"@[congr]\ntheorem countP_congr {s s' : Multiset α} (hs : s = s')\n    {p p' : α → Prop} [DecidablePred p] [DecidablePred p']\n    (hp : ∀ x ∈ s, p x = p' x) : s.countP p = s'.countP p' := by\n  revert hs hp\n  exact Quot.induction_on₂ s s'\n    (fun l l' hs hp => by\n      simp only [quot_mk_to_coe'', coe_eq_coe] at hs\n      apply hs.countP_congr\n      simpa using hp)\n\n"}
{"name":"Multiset.coe_count","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Eq (Multiset.count a ↑l) (List.count a l)","decl":"@[simp]\ntheorem coe_count (a : α) (l : List α) : count a (ofList l) = l.count a := by\n  simp_rw [count, List.count, coe_countP (a = ·) l, @eq_comm _ a]\n  rfl\n\n"}
{"name":"Multiset.count_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.count a 0) 0","decl":"@[simp]\ntheorem count_zero (a : α) : count a 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.count_cons_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.count a (Multiset.cons a s)) (HAdd.hAdd (Multiset.count a s) 1)","decl":"@[simp]\ntheorem count_cons_self (a : α) (s : Multiset α) : count a (a ::ₘ s) = count a s + 1 :=\n  countP_cons_of_pos _ <| rfl\n\n"}
{"name":"Multiset.count_cons_of_ne","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\nh : Ne a b\ns : Multiset α\n⊢ Eq (Multiset.count a (Multiset.cons b s)) (Multiset.count a s)","decl":"@[simp]\ntheorem count_cons_of_ne {a b : α} (h : a ≠ b) (s : Multiset α) : count a (b ::ₘ s) = count a s :=\n  countP_cons_of_neg _ <| h\n\n"}
{"name":"Multiset.count_le_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ LE.le (Multiset.count a s) s.card","decl":"theorem count_le_card (a : α) (s) : count a s ≤ card s :=\n  countP_le_card _ _\n\n"}
{"name":"Multiset.count_le_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\na✝ : LE.le s t\n⊢ LE.le (Multiset.count a s) (Multiset.count a t)","decl":"@[gcongr]\ntheorem count_le_of_le (a : α) {s t} : s ≤ t → count a s ≤ count a t :=\n  countP_le_of_le _\n\n"}
{"name":"Multiset.count_le_count_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\n⊢ LE.le (Multiset.count a s) (Multiset.count a (Multiset.cons b s))","decl":"theorem count_le_count_cons (a b : α) (s : Multiset α) : count a s ≤ count a (b ::ₘ s) :=\n  count_le_of_le _ (le_cons_self _ _)\n\n"}
{"name":"Multiset.count_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Multiset α\n⊢ Eq (Multiset.count a (Multiset.cons b s)) (HAdd.hAdd (Multiset.count a s) (ite (Eq a b) 1 0))","decl":"theorem count_cons (a b : α) (s : Multiset α) :\n    count a (b ::ₘ s) = count a s + if a = b then 1 else 0 :=\n  countP_cons (a = ·) _ _\n\n"}
{"name":"Multiset.count_singleton_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (Multiset.count a (Singleton.singleton a)) 1","decl":"theorem count_singleton_self (a : α) : count a ({a} : Multiset α) = 1 :=\n  count_eq_one_of_mem (nodup_singleton a) <| mem_singleton_self a\n\n"}
{"name":"Multiset.count_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq (Multiset.count a (Singleton.singleton b)) (ite (Eq a b) 1 0)","decl":"theorem count_singleton (a b : α) : count a ({b} : Multiset α) = if a = b then 1 else 0 := by\n  simp only [count_cons, ← cons_zero, count_zero, Nat.zero_add]\n\n"}
{"name":"Multiset.count_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.count a (HAdd.hAdd s t)) (HAdd.hAdd (Multiset.count a s) (Multiset.count a t))","decl":"@[simp]\ntheorem count_add (a : α) : ∀ s t, count a (s + t) = count a s + count a t :=\n  countP_add _\n\n"}
{"name":"Multiset.count_attach","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : Subtype fun x => Membership.mem s x\n⊢ Eq (Multiset.count a s.attach) (Multiset.count (↑a) s)","decl":"@[simp]\nlemma count_attach (a : {x // x ∈ s}) : s.attach.count a = s.count ↑a :=\n  Eq.trans (countP_congr rfl fun _ _ => by simp [Subtype.ext_iff]) <| countP_attach _ _\n\n"}
{"name":"Multiset.count_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (LT.lt 0 (Multiset.count a s)) (Membership.mem s a)","decl":"theorem count_pos {a : α} {s : Multiset α} : 0 < count a s ↔ a ∈ s := by simp [count, countP_pos]\n\n"}
{"name":"Multiset.one_le_count_iff_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (LE.le 1 (Multiset.count a s)) (Membership.mem s a)","decl":"theorem one_le_count_iff_mem {a : α} {s : Multiset α} : 1 ≤ count a s ↔ a ∈ s := by\n  rw [succ_le_iff, count_pos]\n\n"}
{"name":"Multiset.count_eq_zero_of_not_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nh : Not (Membership.mem s a)\n⊢ Eq (Multiset.count a s) 0","decl":"@[simp]\ntheorem count_eq_zero_of_not_mem {a : α} {s : Multiset α} (h : a ∉ s) : count a s = 0 :=\n  by_contradiction fun h' => h <| count_pos.1 (Nat.pos_of_ne_zero h')\n\n"}
{"name":"Multiset.count_ne_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ Iff (Ne (Multiset.count a s) 0) (Membership.mem s a)","decl":"lemma count_ne_zero {a : α} : count a s ≠ 0 ↔ a ∈ s := Nat.pos_iff_ne_zero.symm.trans count_pos\n\n"}
{"name":"Multiset.count_eq_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ Iff (Eq (Multiset.count a s) 0) (Not (Membership.mem s a))","decl":"@[simp] lemma count_eq_zero {a : α} : count a s = 0 ↔ a ∉ s := count_ne_zero.not_right\n\n"}
{"name":"Multiset.count_eq_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Iff (Eq (Multiset.count a s) s.card) (∀ (x : α), Membership.mem s x → Eq a x)","decl":"theorem count_eq_card {a : α} {s} : count a s = card s ↔ ∀ x ∈ s, a = x := by\n  simp [countP_eq_card, count, @eq_comm _ a]\n\n"}
{"name":"Multiset.count_replicate_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nn : Nat\n⊢ Eq (Multiset.count a (Multiset.replicate n a)) n","decl":"@[simp]\ntheorem count_replicate_self (a : α) (n : ℕ) : count a (replicate n a) = n := by\n  convert List.count_replicate_self a n\n  rw [← coe_count, coe_replicate]\n\n"}
{"name":"Multiset.count_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\nn : Nat\n⊢ Eq (Multiset.count a (Multiset.replicate n b)) (ite (Eq b a) n 0)","decl":"theorem count_replicate (a b : α) (n : ℕ) : count a (replicate n b) = if b = a then n else 0 := by\n  convert List.count_replicate a b n\n  · rw [← coe_count, coe_replicate]\n  · simp\n\n"}
{"name":"Multiset.count_erase_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (Multiset.count a (s.erase a)) (HSub.hSub (Multiset.count a s) 1)","decl":"@[simp]\ntheorem count_erase_self (a : α) (s : Multiset α) : count a (erase s a) = count a s - 1 :=\n  Quotient.inductionOn s fun l => by\n    convert List.count_erase_self a l <;> rw [← coe_count] <;> simp\n\n"}
{"name":"Multiset.count_erase_of_ne","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\nab : Ne a b\ns : Multiset α\n⊢ Eq (Multiset.count a (s.erase b)) (Multiset.count a s)","decl":"@[simp]\ntheorem count_erase_of_ne {a b : α} (ab : a ≠ b) (s : Multiset α) :\n    count a (erase s b) = count a s :=\n  Quotient.inductionOn s fun l => by\n    convert List.count_erase_of_ne ab l <;> rw [← coe_count] <;> simp\n\n"}
{"name":"Multiset.le_count_iff_replicate_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\nn : Nat\n⊢ Iff (LE.le n (Multiset.count a s)) (LE.le (Multiset.replicate n a) s)","decl":"theorem le_count_iff_replicate_le {a : α} {s : Multiset α} {n : ℕ} :\n    n ≤ count a s ↔ replicate n a ≤ s :=\n  Quot.inductionOn s fun _l => by\n    simp only [quot_mk_to_coe'', mem_coe, coe_count]\n    exact le_count_iff_replicate_sublist.trans replicate_le_coe.symm\n\n"}
{"name":"Multiset.count_filter_of_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\nh : p a\n⊢ Eq (Multiset.count a (Multiset.filter p s)) (Multiset.count a s)","decl":"@[simp]\ntheorem count_filter_of_pos {p} [DecidablePred p] {a} {s : Multiset α} (h : p a) :\n    count a (filter p s) = count a s :=\n  Quot.inductionOn s fun _l => by\n    simp only [quot_mk_to_coe'', filter_coe, mem_coe, coe_count, decide_eq_true_eq]\n    apply count_filter\n    simpa using h\n\n"}
{"name":"Multiset.count_filter_of_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\nh : Not (p a)\n⊢ Eq (Multiset.count a (Multiset.filter p s)) 0","decl":"@[simp]\ntheorem count_filter_of_neg {p} [DecidablePred p] {a} {s : Multiset α} (h : ¬p a) :\n    count a (filter p s) = 0 :=\n  Multiset.count_eq_zero_of_not_mem fun t => h (of_mem_filter t)\n\n"}
{"name":"Multiset.count_filter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\na : α\ns : Multiset α\n⊢ Eq (Multiset.count a (Multiset.filter p s)) (ite (p a) (Multiset.count a s) 0)","decl":"theorem count_filter {p} [DecidablePred p] {a} {s : Multiset α} :\n    count a (filter p s) = if p a then count a s else 0 := by\n  split_ifs with h\n  · exact count_filter_of_pos h\n  · exact count_filter_of_neg h\n\n"}
{"name":"Multiset.ext","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq s t) (∀ (a : α), Eq (Multiset.count a s) (Multiset.count a t))","decl":"theorem ext {s t : Multiset α} : s = t ↔ ∀ a, count a s = count a t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => Quotient.eq.trans <| by\n    simp only [quot_mk_to_coe, filter_coe, mem_coe, coe_count, decide_eq_true_eq]\n    apply perm_iff_count\n\n"}
{"name":"Multiset.ext'_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq s t) (∀ (a : α), Eq (Multiset.count a s) (Multiset.count a t))","decl":"@[ext]\ntheorem ext' {s t : Multiset α} : (∀ a, count a s = count a t) → s = t :=\n  ext.2\n\n"}
{"name":"Multiset.ext'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na✝ : ∀ (a : α), Eq (Multiset.count a s) (Multiset.count a t)\n⊢ Eq s t","decl":"@[ext]\ntheorem ext' {s t : Multiset α} : (∀ a, count a s = count a t) → s = t :=\n  ext.2\n\n"}
{"name":"Multiset.count_injective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Function.Injective fun s a => Multiset.count a s","decl":"lemma count_injective : Injective fun (s : Multiset α) a ↦ s.count a :=\n  fun _s _t hst ↦ ext' <| congr_fun hst\n\n"}
{"name":"Multiset.le_iff_count","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (LE.le s t) (∀ (a : α), LE.le (Multiset.count a s) (Multiset.count a t))","decl":"theorem le_iff_count {s t : Multiset α} : s ≤ t ↔ ∀ a, count a s ≤ count a t :=\n  Quotient.inductionOn₂ s t fun _ _ ↦ by simp [subperm_iff_count]\n\n"}
{"name":"Multiset.count_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\nf : α → β\ns : Multiset α\ninst✝ : DecidableEq β\nb : β\n⊢ Eq (Multiset.count b (Multiset.map f s)) (Multiset.filter (fun a => Eq b (f a)) s).card","decl":"theorem count_map {α β : Type*} (f : α → β) (s : Multiset α) [DecidableEq β] (b : β) :\n    count b (map f s) = card (s.filter fun a => b = f a) := by\n  simp [Bool.beq_eq_decide_eq, eq_comm, count, countP_map]\n\n"}
{"name":"Multiset.count_map_eq_count","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns : Multiset α\nhf : Set.InjOn f (setOf fun x => Membership.mem s x)\nx : α\nH : Membership.mem s x\n⊢ Eq (Multiset.count (f x) (Multiset.map f s)) (Multiset.count x s)","decl":"/-- `Multiset.map f` preserves `count` if `f` is injective on the set of elements contained in\nthe multiset -/\ntheorem count_map_eq_count [DecidableEq β] (f : α → β) (s : Multiset α)\n    (hf : Set.InjOn f { x : α | x ∈ s }) (x) (H : x ∈ s) : (s.map f).count (f x) = s.count x := by\n  suffices (filter (fun a : α => f x = f a) s).count x = card (filter (fun a : α => f x = f a) s) by\n    rw [count, countP_map, ← this]\n    exact count_filter_of_pos <| rfl\n  · rw [eq_replicate_card.2 fun b hb => (hf H (mem_filter.1 hb).left _).symm]\n    · simp only [count_replicate, eq_self_iff_true, if_true, card_replicate]\n    · simp only [mem_filter, beq_iff_eq, and_imp, @eq_comm _ (f x), imp_self, implies_true]\n\n"}
{"name":"Multiset.count_map_eq_count'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\ns : Multiset α\nhf : Function.Injective f\nx : α\n⊢ Eq (Multiset.count (f x) (Multiset.map f s)) (Multiset.count x s)","decl":"/-- `Multiset.map f` preserves `count` if `f` is injective -/\ntheorem count_map_eq_count' [DecidableEq β] (f : α → β) (s : Multiset α) (hf : Function.Injective f)\n    (x : α) : (s.map f).count (f x) = s.count x := by\n  by_cases H : x ∈ s\n  · exact count_map_eq_count f _ hf.injOn _ H\n  · rw [count_eq_zero_of_not_mem H, count_eq_zero, mem_map]\n    rintro ⟨k, hks, hkx⟩\n    rw [hf hkx] at hks\n    contradiction\n\n"}
{"name":"Multiset.filter_eq'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nb : α\n⊢ Eq (Multiset.filter (fun x => Eq x b) s) (Multiset.replicate (Multiset.count b s) b)","decl":"theorem filter_eq' (s : Multiset α) (b : α) : s.filter (· = b) = replicate (count b s) b :=\n  Quotient.inductionOn s fun l => by\n    simp only [quot_mk_to_coe, filter_coe, mem_coe, coe_count]\n    rw [List.filter_eq l b, coe_replicate]\n\n"}
{"name":"Multiset.filter_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nb : α\n⊢ Eq (Multiset.filter (Eq b) s) (Multiset.replicate (Multiset.count b s) b)","decl":"theorem filter_eq (s : Multiset α) (b : α) : s.filter (Eq b) = replicate (count b s) b := by\n  simp_rw [← filter_eq', eq_comm]\n\n"}
{"name":"Multiset.erase_attach_map_val","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Multiset.map Subtype.val (s.attach.erase x)) (s.erase ↑x)","decl":"lemma erase_attach_map_val (s : Multiset α) (x : {x // x ∈ s}) :\n    (s.attach.erase x).map (↑) = s.erase x := by\n  rw [Multiset.map_erase _ val_injective, attach_map_val]\n\n"}
{"name":"Multiset.erase_attach_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : DecidableEq α\ns : Multiset α\nf : α → β\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (Multiset.map (fun j => f ↑j) (s.attach.erase x)) (Multiset.map f (s.erase ↑x))","decl":"lemma erase_attach_map (s : Multiset α) (f : α → β) (x : {x // x ∈ s}) :\n    (s.attach.erase x).map (fun j : {x // x ∈ s} ↦ f j) = (s.erase x).map f := by\n  simp only [← Function.comp_apply (f := f)]\n  rw [← map_map, erase_attach_map_val]\n\n"}
{"name":"Multiset.add_left_inj","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (Eq (HAdd.hAdd s u) (HAdd.hAdd t u)) (Eq s t)","decl":"omit [DecidableEq α] in\nprotected lemma add_left_inj : s + u = t + u ↔ s = t := by classical simp [Multiset.ext]\n\n"}
{"name":"Multiset.add_right_inj","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (Eq (HAdd.hAdd s t) (HAdd.hAdd s u)) (Eq t u)","decl":"omit [DecidableEq α] in\nprotected lemma add_right_inj : s + t = s + u ↔ t = u := by classical simp [Multiset.ext]\n\n"}
{"name":"Multiset.coe_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : List α\n⊢ Eq (HSub.hSub ↑s ↑t) ↑(s.diff t)","decl":"@[simp]\nlemma coe_sub (s t : List α) : (s - t : Multiset α) = s.diff t :=\n  rfl\n\n"}
{"name":"Multiset.sub_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (HSub.hSub s 0) s","decl":"/-- This is a special case of `tsub_zero`, which should be used instead of this.\nThis is needed to prove `OrderedSub (Multiset α)`. -/\n@[simp, nolint simpNF] -- We want to use this lemma earlier than the lemma simp can prove it with\nprotected lemma sub_zero (s : Multiset α) : s - 0 = s :=\n  Quot.inductionOn s fun _l => rfl\n\n"}
{"name":"Multiset.sub_cons","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (HSub.hSub s (Multiset.cons a t)) (HSub.hSub (s.erase a) t)","decl":"@[simp]\nlemma sub_cons (a : α) (s t : Multiset α) : s - a ::ₘ t = s.erase a - t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => congr_arg _ <| diff_cons _ _ _\n\n"}
{"name":"Multiset.zero_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Multiset α\n⊢ Eq (HSub.hSub 0 t) 0","decl":"protected lemma zero_sub (t : Multiset α) : 0 - t = 0 :=\n  Multiset.induction_on t rfl fun a s ih => by simp [ih]\n\n"}
{"name":"Multiset.countP_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ns t : Multiset α\na✝ : LE.le t s\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.countP p (HSub.hSub s t)) (HSub.hSub (Multiset.countP p s) (Multiset.countP p t))","decl":"@[simp]\nlemma countP_sub {s t : Multiset α} :\n    t ≤ s → ∀ (p : α → Prop) [DecidablePred p], countP p (s - t) = countP p s - countP p t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ hl _ _ ↦ List.countP_diff hl _\n\n"}
{"name":"Multiset.count_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.count a (HSub.hSub s t)) (HSub.hSub (Multiset.count a s) (Multiset.count a t))","decl":"@[simp]\nlemma count_sub (a : α) (s t : Multiset α) : count a (s - t) = count a s - count a t :=\n  Quotient.inductionOn₂ s t <| by simp [List.count_diff]\n\n"}
{"name":"Multiset.sub_le_iff_le_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le (HSub.hSub s t) u) (LE.le s (HAdd.hAdd u t))","decl":"/-- This is a special case of `tsub_le_iff_right`, which should be used instead of this.\nThis is needed to prove `OrderedSub (Multiset α)`. -/\nprotected lemma sub_le_iff_le_add : s - t ≤ u ↔ s ≤ u + t := by\n  revert s\n  exact @(Multiset.induction_on t (by simp [Multiset.sub_zero]) fun a t IH s => by\n      simp [IH, erase_le_iff_le_cons])\n\n"}
{"name":"Multiset.sub_le_iff_le_add'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le (HSub.hSub s t) u) (LE.le s (HAdd.hAdd t u))","decl":"/-- This is a special case of `tsub_le_iff_left`, which should be used instead of this. -/\nprotected lemma sub_le_iff_le_add' : s - t ≤ u ↔ s ≤ t + u := by\n  rw [Multiset.sub_le_iff_le_add, Multiset.add_comm]\n\n"}
{"name":"Multiset.sub_le_self","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (HSub.hSub s t) s","decl":"protected theorem sub_le_self (s t : Multiset α) : s - t ≤ s := by\n  rw [Multiset.sub_le_iff_le_add]\n  exact le_add_right _ _\n\n"}
{"name":"Multiset.add_sub_assoc","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nhut : LE.le u t\n⊢ Eq (HSub.hSub (HAdd.hAdd s t) u) (HAdd.hAdd s (HSub.hSub t u))","decl":"protected lemma add_sub_assoc (hut : u ≤ t) : s + t - u = s + (t - u) := by\n  ext a; simp [Nat.add_sub_assoc <| count_le_of_le _ hut]\n\n"}
{"name":"Multiset.add_sub_cancel","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nhts : LE.le t s\n⊢ Eq (HAdd.hAdd (HSub.hSub s t) t) s","decl":"protected lemma add_sub_cancel (hts : t ≤ s) : s - t + t = s := by\n  ext a; simp [Nat.sub_add_cancel <| count_le_of_le _ hts]\n\n"}
{"name":"Multiset.sub_add_cancel","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nhts : LE.le t s\n⊢ Eq (HAdd.hAdd (HSub.hSub s t) t) s","decl":"protected lemma sub_add_cancel (hts : t ≤ s) : s - t + t = s := by\n  ext a; simp [Nat.sub_add_cancel <| count_le_of_le _ hts]\n\n"}
{"name":"Multiset.sub_add_eq_sub_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Eq (HSub.hSub s (HAdd.hAdd t u)) (HSub.hSub (HSub.hSub s t) u)","decl":"protected lemma sub_add_eq_sub_sub : s - (t + u) = s - t - u := by ext; simp [Nat.sub_add_eq]\n\n"}
{"name":"Multiset.le_sub_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le s (HAdd.hAdd (HSub.hSub s t) t)","decl":"protected lemma le_sub_add : s ≤ s - t + t := Multiset.sub_le_iff_le_add.1 le_rfl\n"}
{"name":"Multiset.le_add_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le s (HAdd.hAdd t (HSub.hSub s t))","decl":"protected lemma le_add_sub : s ≤ t + (s - t) := Multiset.sub_le_iff_le_add'.1 le_rfl\n\n"}
{"name":"Multiset.sub_le_sub_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nhst : LE.le s t\n⊢ LE.le (HSub.hSub s u) (HSub.hSub t u)","decl":"protected lemma sub_le_sub_right (hst : s ≤ t) : s - u ≤ t - u :=\n  Multiset.sub_le_iff_le_add'.mpr <| hst.trans Multiset.le_add_sub\n\n"}
{"name":"Multiset.add_sub_cancel_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HSub.hSub (HAdd.hAdd s t) t) s","decl":"protected lemma add_sub_cancel_right : s + t - t = s := by ext a; simp\n\n"}
{"name":"Multiset.eq_sub_of_add_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nhstu : Eq (HAdd.hAdd s t) u\n⊢ Eq s (HSub.hSub u t)","decl":"protected lemma eq_sub_of_add_eq (hstu : s + t = u) : s = u - t := by\n  rw [← hstu, Multiset.add_sub_cancel_right]\n\n"}
{"name":"Multiset.filter_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Eq (Multiset.filter p (HSub.hSub s t)) (HSub.hSub (Multiset.filter p s) (Multiset.filter p t))","decl":"@[simp]\nlemma filter_sub (p : α → Prop) [DecidablePred p] (s t : Multiset α) :\n    filter p (s - t) = filter p s - filter p t := by\n  revert s; refine Multiset.induction_on t (by simp) fun a t IH s => ?_\n  rw [sub_cons, IH]\n  by_cases h : p a\n  · rw [filter_cons_of_pos _ h, sub_cons]\n    congr\n    by_cases m : a ∈ s\n    · rw [← cons_inj_right a, ← filter_cons_of_pos _ h, cons_erase (mem_filter_of_mem m h),\n        cons_erase m]\n    · rw [erase_of_not_mem m, erase_of_not_mem (mt mem_of_mem_filter m)]\n  · rw [filter_cons_of_neg _ h]\n    by_cases m : a ∈ s\n    · rw [(by rw [filter_cons_of_neg _ h] : filter p (erase s a) = filter p (a ::ₘ erase s a)),\n        cons_erase m]\n    · rw [erase_of_not_mem m]\n\n"}
{"name":"Multiset.sub_filter_eq_filter_not","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\ns : Multiset α\n⊢ Eq (HSub.hSub s (Multiset.filter p s)) (Multiset.filter (fun a => Not (p a)) s)","decl":"@[simp]\nlemma sub_filter_eq_filter_not (p : α → Prop) [DecidablePred p] (s : Multiset α) :\n    s - s.filter p = s.filter fun a ↦ ¬ p a := by ext a; by_cases h : p a <;> simp [h]\n\n"}
{"name":"Multiset.cons_sub_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\nh : LE.le t s\n⊢ Eq (HSub.hSub (Multiset.cons a s) t) (Multiset.cons a (HSub.hSub s t))","decl":"lemma cons_sub_of_le (a : α) {s t : Multiset α} (h : t ≤ s) : a ::ₘ s - t = a ::ₘ (s - t) := by\n  rw [← singleton_add, ← singleton_add, Multiset.add_sub_assoc h]\n\n"}
{"name":"Multiset.sub_eq_fold_erase","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HSub.hSub s t) (Multiset.foldl Multiset.erase s t)","decl":"lemma sub_eq_fold_erase (s t : Multiset α) : s - t = foldl erase s t :=\n  Quotient.inductionOn₂ s t fun l₁ l₂ => by\n    show ofList (l₁.diff l₂) = foldl erase l₁ l₂\n    rw [diff_eq_foldl l₁ l₂]\n    symm\n    exact foldl_hom _ _ _ _ _ fun x y => rfl\n\n"}
{"name":"Multiset.card_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : LE.le t s\n⊢ Eq (HSub.hSub s t).card (HSub.hSub s.card t.card)","decl":"@[simp]\nlemma card_sub {s t : Multiset α} (h : t ≤ s) : card (s - t) = card s - card t :=\n  Nat.eq_sub_of_add_eq <| by rw [← card_add, Multiset.sub_add_cancel h]\n\n"}
{"name":"Multiset.union_def","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Union.union s t) (HAdd.hAdd (HSub.hSub s t) t)","decl":"lemma union_def (s t : Multiset α) : s ∪ t = s - t + t := rfl\n\n"}
{"name":"Multiset.le_union_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le s (Union.union s t)","decl":"lemma le_union_left : s ≤ s ∪ t := Multiset.le_sub_add\n"}
{"name":"Multiset.le_union_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le t (Union.union s t)","decl":"lemma le_union_right : t ≤ s ∪ t := le_add_left _ _\n"}
{"name":"Multiset.eq_union_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na✝ : LE.le t s\n⊢ Eq (Union.union s t) s","decl":"lemma eq_union_left : t ≤ s → s ∪ t = s := Multiset.sub_add_cancel\n\n"}
{"name":"Multiset.union_le_union_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : LE.le s t\nu : Multiset α\n⊢ LE.le (Union.union s u) (Union.union t u)","decl":"@[gcongr]\nlemma union_le_union_right (h : s ≤ t) (u) : s ∪ u ≤ t ∪ u :=\n  Multiset.add_le_add_right <| Multiset.sub_le_sub_right h\n\n"}
{"name":"Multiset.union_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nh₁ : LE.le s u\nh₂ : LE.le t u\n⊢ LE.le (Union.union s t) u","decl":"lemma union_le (h₁ : s ≤ u) (h₂ : t ≤ u) : s ∪ t ≤ u := by\n  rw [← eq_union_left h₂]; exact union_le_union_right h₁ t\n\n"}
{"name":"Multiset.mem_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (Membership.mem (Union.union s t) a) (Or (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\nlemma mem_union : a ∈ s ∪ t ↔ a ∈ s ∨ a ∈ t :=\n  ⟨fun h => (mem_add.1 h).imp_left (mem_of_le <| Multiset.sub_le_self _ _),\n    (Or.elim · (mem_of_le le_union_left) (mem_of_le le_union_right))⟩\n\n"}
{"name":"Multiset.map_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nfinj : Function.Injective f\ns t : Multiset α\n⊢ Eq (Multiset.map f (Union.union s t)) (Union.union (Multiset.map f s) (Multiset.map f t))","decl":"@[simp]\nlemma map_union [DecidableEq β] {f : α → β} (finj : Function.Injective f) {s t : Multiset α} :\n    map f (s ∪ t) = map f s ∪ map f t :=\n  Quotient.inductionOn₂ s t fun l₁ l₂ =>\n    congr_arg ofList (by rw [List.map_append f, List.map_diff finj])\n\n"}
{"name":"Multiset.zero_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Union.union 0 s) s","decl":"@[simp] lemma zero_union : 0 ∪ s = s := by simp [union_def, Multiset.zero_sub]\n"}
{"name":"Multiset.union_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Union.union s 0) s","decl":"@[simp] lemma union_zero : s ∪ 0 = s := by simp [union_def]\n\n"}
{"name":"Multiset.count_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.count a (Union.union s t)) (Max.max (Multiset.count a s) (Multiset.count a t))","decl":"@[simp]\nlemma count_union (a : α) (s t : Multiset α) : count a (s ∪ t) = max (count a s) (count a t) := by\n  simp [(· ∪ ·), union, Nat.sub_add_eq_max]\n\n"}
{"name":"Multiset.filter_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Eq (Multiset.filter p (Union.union s t)) (Union.union (Multiset.filter p s) (Multiset.filter p t))","decl":"@[simp] lemma filter_union (p : α → Prop) [DecidablePred p] (s t : Multiset α) :\n    filter p (s ∪ t) = filter p s ∪ filter p t := by simp [(· ∪ ·), union]\n\n"}
{"name":"Multiset.inter_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Inter.inter s 0) 0","decl":"@[simp] lemma inter_zero (s : Multiset α) : s ∩ 0 = 0 :=\n  Quot.inductionOn s fun l => congr_arg ofList l.bagInter_nil\n\n"}
{"name":"Multiset.zero_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Eq (Inter.inter 0 s) 0","decl":"@[simp] lemma zero_inter (s : Multiset α) : 0 ∩ s = 0 :=\n  Quot.inductionOn s fun l => congr_arg ofList l.nil_bagInter\n\n"}
{"name":"Multiset.cons_inter_of_pos","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Multiset α\na : α\ns : Multiset α\na✝ : Membership.mem t a\n⊢ Eq (Inter.inter (Multiset.cons a s) t) (Multiset.cons a (Inter.inter s (t.erase a)))","decl":"@[simp]\nlemma cons_inter_of_pos (s : Multiset α) : a ∈ t → (a ::ₘ s) ∩ t = a ::ₘ s ∩ t.erase a :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ h => congr_arg ofList <| cons_bagInter_of_pos _ h\n\n"}
{"name":"Multiset.cons_inter_of_neg","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nt : Multiset α\na : α\ns : Multiset α\na✝ : Not (Membership.mem t a)\n⊢ Eq (Inter.inter (Multiset.cons a s) t) (Inter.inter s t)","decl":"@[simp]\nlemma cons_inter_of_neg (s : Multiset α) : a ∉ t → (a ::ₘ s) ∩ t = s ∩ t :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ h => congr_arg ofList <| cons_bagInter_of_neg _ h\n\n"}
{"name":"Multiset.inter_le_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (Inter.inter s t) s","decl":"lemma inter_le_left : s ∩ t ≤ s :=\n  Quotient.inductionOn₂ s t fun _l₁ _l₂ => (bagInter_sublist_left _ _).subperm\n\n"}
{"name":"Multiset.inter_le_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (Inter.inter s t) t","decl":"lemma inter_le_right : s ∩ t ≤ t := by\n  induction' s using Multiset.induction_on with a s IH generalizing t\n  · exact (zero_inter t).symm ▸ zero_le _\n  by_cases h : a ∈ t\n  · simpa [h] using cons_le_cons a (IH (t := t.erase a))\n  · simp [h, IH]\n\n"}
{"name":"Multiset.le_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nh₁ : LE.le s t\nh₂ : LE.le s u\n⊢ LE.le s (Inter.inter t u)","decl":"lemma le_inter (h₁ : s ≤ t) (h₂ : s ≤ u) : s ≤ t ∩ u := by\n  revert s u; refine @(Multiset.induction_on t ?_ fun a t IH => ?_) <;> intros s u h₁ h₂\n  · simpa only [zero_inter] using h₁\n  by_cases h : a ∈ u\n  · rw [cons_inter_of_pos _ h, ← erase_le_iff_le_cons]\n    exact IH (erase_le_iff_le_cons.2 h₁) (erase_le_erase _ h₂)\n  · rw [cons_inter_of_neg _ h]\n    exact IH ((le_cons_of_not_mem <| mt (mem_of_le h₂) h).1 h₁) h₂\n\n"}
{"name":"Multiset.mem_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\na : α\n⊢ Iff (Membership.mem (Inter.inter s t) a) (And (Membership.mem s a) (Membership.mem t a))","decl":"@[simp]\nlemma mem_inter : a ∈ s ∩ t ↔ a ∈ s ∧ a ∈ t :=\n  ⟨fun h => ⟨mem_of_le inter_le_left h, mem_of_le inter_le_right h⟩, fun ⟨h₁, h₂⟩ => by\n    rw [← cons_erase h₁, cons_inter_of_pos _ h₂]; apply mem_cons_self⟩\n\n"}
{"name":"Multiset.sup_eq_union","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Max.max s t) (Union.union s t)","decl":"@[simp] lemma sup_eq_union (s t : Multiset α) : s ⊔ t = s ∪ t := rfl\n"}
{"name":"Multiset.inf_eq_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Min.min s t) (Inter.inter s t)","decl":"@[simp] lemma inf_eq_inter (s t : Multiset α) : s ⊓ t = s ∩ t := rfl\n\n"}
{"name":"Multiset.le_inter_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le s (Inter.inter t u)) (And (LE.le s t) (LE.le s u))","decl":"@[simp] lemma le_inter_iff : s ≤ t ∩ u ↔ s ≤ t ∧ s ≤ u := le_inf_iff\n"}
{"name":"Multiset.union_le_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (LE.le (Union.union s t) u) (And (LE.le s u) (LE.le t u))","decl":"@[simp] lemma union_le_iff : s ∪ t ≤ u ↔ s ≤ u ∧ t ≤ u := sup_le_iff\n\n"}
{"name":"Multiset.union_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Union.union s t) (Union.union t s)","decl":"lemma union_comm (s t : Multiset α) : s ∪ t = t ∪ s := sup_comm ..\n"}
{"name":"Multiset.inter_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (Inter.inter s t) (Inter.inter t s)","decl":"lemma inter_comm (s t : Multiset α) : s ∩ t = t ∩ s := inf_comm ..\n\n"}
{"name":"Multiset.eq_union_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : LE.le s t\n⊢ Eq (Union.union s t) t","decl":"lemma eq_union_right (h : s ≤ t) : s ∪ t = t := by rw [union_comm, eq_union_left h]\n\n"}
{"name":"Multiset.union_le_union_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\nh : LE.le s t\nu : Multiset α\n⊢ LE.le (Union.union u s) (Union.union u t)","decl":"@[gcongr] lemma union_le_union_left (h : s ≤ t) (u) : u ∪ s ≤ u ∪ t := sup_le_sup_left h _\n\n"}
{"name":"Multiset.union_le_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ LE.le (Union.union s t) (HAdd.hAdd s t)","decl":"lemma union_le_add (s t : Multiset α) : s ∪ t ≤ s + t := union_le (le_add_right ..) (le_add_left ..)\n\n"}
{"name":"Multiset.union_add_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Eq (HAdd.hAdd (Union.union s t) u) (Union.union (HAdd.hAdd s u) (HAdd.hAdd t u))","decl":"lemma union_add_distrib (s t u : Multiset α) : s ∪ t + u = s + u ∪ (t + u) := by\n  simpa [(· ∪ ·), union, eq_comm, Multiset.add_assoc, Multiset.add_left_inj] using\n    show s + u - (t + u) = s - t by\n      rw [t.add_comm, Multiset.sub_add_eq_sub_sub, Multiset.add_sub_cancel_right]\n\n"}
{"name":"Multiset.add_union_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Eq (HAdd.hAdd s (Union.union t u)) (Union.union (HAdd.hAdd s t) (HAdd.hAdd s u))","decl":"lemma add_union_distrib (s t u : Multiset α) : s + (t ∪ u) = s + t ∪ (s + u) := by\n  rw [Multiset.add_comm, union_add_distrib, s.add_comm, s.add_comm]\n\n"}
{"name":"Multiset.cons_union_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.cons a (Union.union s t)) (Union.union (Multiset.cons a s) (Multiset.cons a t))","decl":"lemma cons_union_distrib (a : α) (s t : Multiset α) : a ::ₘ (s ∪ t) = a ::ₘ s ∪ a ::ₘ t := by\n  simpa using add_union_distrib (a ::ₘ 0) s t\n\n"}
{"name":"Multiset.inter_add_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Eq (HAdd.hAdd (Inter.inter s t) u) (Inter.inter (HAdd.hAdd s u) (HAdd.hAdd t u))","decl":"lemma inter_add_distrib (s t u : Multiset α) : s ∩ t + u = (s + u) ∩ (t + u) := by\n  by_contra! h\n  obtain ⟨a, ha⟩ := lt_iff_cons_le.1 <| h.lt_of_le <| le_inter\n    (Multiset.add_le_add_right inter_le_left) (Multiset.add_le_add_right inter_le_right)\n  rw [← cons_add] at ha\n  exact (lt_cons_self (s ∩ t) a).not_le <| le_inter\n    (Multiset.le_of_add_le_add_right (ha.trans inter_le_left))\n    (Multiset.le_of_add_le_add_right (ha.trans inter_le_right))\n\n"}
{"name":"Multiset.add_inter_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Eq (HAdd.hAdd s (Inter.inter t u)) (Inter.inter (HAdd.hAdd s t) (HAdd.hAdd s u))","decl":"lemma add_inter_distrib (s t u : Multiset α) : s + t ∩ u = (s + t) ∩ (s + u) := by\n  rw [Multiset.add_comm, inter_add_distrib, s.add_comm, s.add_comm]\n\n"}
{"name":"Multiset.cons_inter_distrib","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.cons a (Inter.inter s t)) (Inter.inter (Multiset.cons a s) (Multiset.cons a t))","decl":"lemma cons_inter_distrib (a : α) (s t : Multiset α) : a ::ₘ s ∩ t = (a ::ₘ s) ∩ (a ::ₘ t) := by\n  simp\n\n"}
{"name":"Multiset.union_add_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd (Union.union s t) (Inter.inter s t)) (HAdd.hAdd s t)","decl":"lemma union_add_inter (s t : Multiset α) : s ∪ t + s ∩ t = s + t := by\n  apply _root_.le_antisymm\n  · rw [union_add_distrib]\n    refine union_le (Multiset.add_le_add_left inter_le_right) ?_\n    rw [Multiset.add_comm]\n    exact Multiset.add_le_add_right inter_le_left\n  · rw [Multiset.add_comm, add_inter_distrib]\n    refine le_inter (Multiset.add_le_add_right le_union_right) ?_\n    rw [Multiset.add_comm]\n    exact Multiset.add_le_add_right le_union_left\n\n"}
{"name":"Multiset.sub_add_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd (HSub.hSub s t) (Inter.inter s t)) s","decl":"lemma sub_add_inter (s t : Multiset α) : s - t + s ∩ t = s := by\n  rw [inter_comm]\n  revert s; refine Multiset.induction_on t (by simp) fun a t IH s => ?_\n  by_cases h : a ∈ s\n  · rw [cons_inter_of_pos _ h, sub_cons, add_cons, IH, cons_erase h]\n  · rw [cons_inter_of_neg _ h, sub_cons, erase_of_not_mem h, IH]\n\n"}
{"name":"Multiset.sub_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Eq (HSub.hSub s (Inter.inter s t)) (HSub.hSub s t)","decl":"lemma sub_inter (s t : Multiset α) : s - s ∩ t = s - t :=\n  (Multiset.eq_sub_of_add_eq <| sub_add_inter ..).symm\n\n"}
{"name":"Multiset.count_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Eq (Multiset.count a (Inter.inter s t)) (Min.min (Multiset.count a s) (Multiset.count a t))","decl":"@[simp]\nlemma count_inter (a : α) (s t : Multiset α) : count a (s ∩ t) = min (count a s) (count a t) := by\n  apply @Nat.add_left_cancel (count a (s - t))\n  rw [← count_add, sub_add_inter, count_sub, Nat.sub_add_min_cancel]\n\n"}
{"name":"Multiset.coe_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : List α\n⊢ Eq (Inter.inter ↑s ↑t) ↑(s.bagInter t)","decl":"@[simp]\nlemma coe_inter (s t : List α) : (s ∩ t : Multiset α) = (s.bagInter t : List α) := by ext; simp\n\n"}
{"name":"Multiset.filter_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\ns t : Multiset α\n⊢ Eq (Multiset.filter p (Inter.inter s t)) (Inter.inter (Multiset.filter p s) (Multiset.filter p t))","decl":"@[simp] lemma filter_inter (p : α → Prop) [DecidablePred p] (s t : Multiset α) :\n    filter p (s ∩ t) = filter p s ∩ filter p t :=\n  le_antisymm (le_inter (filter_le_filter _ inter_le_left) (filter_le_filter _ inter_le_right)) <|\n    le_filter.2 ⟨inf_le_inf (filter_le _ _) (filter_le _ _), fun _a h =>\n      of_mem_filter (mem_of_le inter_le_left h)⟩\n\n"}
{"name":"Multiset.replicate_inter","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nn : Nat\nx : α\ns : Multiset α\n⊢ Eq (Inter.inter (Multiset.replicate n x) s) (Multiset.replicate (Min.min n (Multiset.count x s)) x)","decl":"@[simp]\ntheorem replicate_inter (n : ℕ) (x : α) (s : Multiset α) :\n    replicate n x ∩ s = replicate (min n (s.count x)) x := by\n  ext y\n  rw [count_inter, count_replicate, count_replicate]\n  by_cases h : x = y\n  · simp only [h, if_true]\n  · simp only [h, if_false, Nat.zero_min]\n\n"}
{"name":"Multiset.inter_replicate","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\nn : Nat\nx : α\n⊢ Eq (Inter.inter s (Multiset.replicate n x)) (Multiset.replicate (Min.min (Multiset.count x s) n) x)","decl":"@[simp]\ntheorem inter_replicate (s : Multiset α) (n : ℕ) (x : α) :\n    s ∩ replicate n x = replicate (min (s.count x) n) x := by\n  rw [inter_comm, replicate_inter, min_comm]\n\n"}
{"name":"Multiset.map_le_map_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nhf : Function.Injective f\ns t : Multiset α\n⊢ Iff (LE.le (Multiset.map f s) (Multiset.map f t)) (LE.le s t)","decl":"@[simp]\ntheorem map_le_map_iff {f : α → β} (hf : Function.Injective f) {s t : Multiset α} :\n    s.map f ≤ t.map f ↔ s ≤ t := by\n  classical\n    refine ⟨fun h => le_iff_count.mpr fun a => ?_, map_le_map⟩\n    simpa [count_map_eq_count' f _ hf] using le_iff_count.mp h (f a)\n\n"}
{"name":"Multiset.mapEmbedding_apply","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : Function.Embedding α β\ns : Multiset α\n⊢ Eq ((Multiset.mapEmbedding f) s) (Multiset.map (⇑f) s)","decl":"/-- Associate to an embedding `f` from `α` to `β` the order embedding that maps a multiset to its\nimage under `f`. -/\n@[simps!]\ndef mapEmbedding (f : α ↪ β) : Multiset α ↪o Multiset β :=\n  OrderEmbedding.ofMapLEIff (map f) fun _ _ => map_le_map_iff f.inj'\n\n"}
{"name":"Multiset.count_eq_card_filter_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\na : α\n⊢ Eq (Multiset.count a s) (Multiset.filter (fun x => Eq a x) s).card","decl":"theorem count_eq_card_filter_eq [DecidableEq α] (s : Multiset α) (a : α) :\n    s.count a = card (s.filter (a = ·)) := by rw [count, countP_eq_card_filter]\n\n"}
{"name":"Multiset.map_count_True_eq_filter_card","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.count True (Multiset.map p s)) (Multiset.filter p s).card","decl":"/--\nMapping a multiset through a predicate and counting the `True`s yields the cardinality of the set\nfiltered by the predicate. Note that this uses the notion of a multiset of `Prop`s - due to the\ndecidability requirements of `count`, the decidability instance on the LHS is different from the\nRHS. In particular, the decidability instance on the left leaks `Classical.decEq`.\nSee [here](https://github.com/leanprover-community/mathlib/pull/11306#discussion_r782286812)\nfor more discussion.\n-/\n@[simp]\ntheorem map_count_True_eq_filter_card (s : Multiset α) (p : α → Prop) [DecidablePred p] :\n    (s.map p).count True = card (s.filter p) := by\n  simp only [count_eq_card_filter_eq, filter_map, card_map, Function.id_comp,\n    eq_true_eq_id, Function.comp_apply]\n\n"}
{"name":"Multiset.sub_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Multiset α\n⊢ Eq (HSub.hSub s (Singleton.singleton a)) (s.erase a)","decl":"@[simp] theorem sub_singleton [DecidableEq α] (a : α) (s : Multiset α) : s - {a} = s.erase a := by\n  ext\n  simp only [count_sub, count_singleton]\n  split <;> simp_all\n\n"}
{"name":"Multiset.mem_sub","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Multiset α\n⊢ Iff (Membership.mem (HSub.hSub s t) a) (LT.lt (Multiset.count a t) (Multiset.count a s))","decl":"theorem mem_sub [DecidableEq α] {a : α} {s t : Multiset α} :\n    a ∈ s - t ↔ t.count a < s.count a := by\n  rw [← count_pos, count_sub, Nat.sub_pos_iff_lt]\n\n"}
{"name":"Multiset.inter_add_sub_of_add_eq_add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nM N P Q : Multiset α\nh : Eq (HAdd.hAdd M N) (HAdd.hAdd P Q)\n⊢ Eq (HAdd.hAdd (Inter.inter N Q) (HSub.hSub P M)) N","decl":"theorem inter_add_sub_of_add_eq_add [DecidableEq α] {M N P Q : Multiset α} (h : M + N = P + Q) :\n    (N ∩ Q) + (P - M) = N := by\n  ext x\n  rw [Multiset.count_add, Multiset.count_inter, Multiset.count_sub]\n  have h0 : M.count x + N.count x = P.count x + Q.count x := by\n    rw [Multiset.ext] at h\n    simp_all only [Multiset.mem_add, Multiset.count_add]\n  omega\n\n"}
{"name":"Multiset.rel_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\na✝¹ : Multiset α\na✝ : Multiset β\n⊢ Iff (Multiset.Rel r a✝¹ a✝) (Or (And (Eq a✝¹ 0) (Eq a✝ 0)) (Exists fun a => Exists fun b => Exists fun as => Exists fun bs => And (r a b) (And (Multiset.Rel r as bs) (And (Eq a✝¹ (Multiset.cons a as)) (Eq a✝ (Multiset.cons b bs))))))","decl":"/-- `Rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`,\ns.t. there is a one-to-one mapping between elements in `s` and `t` following `r`. -/\n@[mk_iff]\ninductive Rel (r : α → β → Prop) : Multiset α → Multiset β → Prop\n  | zero : Rel r 0 0\n  | cons {a b as bs} : r a b → Rel r as bs → Rel r (a ::ₘ as) (b ::ₘ bs)\n\n"}
{"name":"Multiset.Rel.brecOn","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\nmotive✝ : (a : Multiset α) → (a_1 : Multiset β) → Multiset.Rel r a a_1 → Prop\na✝¹ : Multiset α\na✝ : Multiset β\nx✝ : Multiset.Rel r a✝¹ a✝\nih✝ : ∀ (a : Multiset α) (a_1 : Multiset β) (x : Multiset.Rel r a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- `Rel r s t` -- lift the relation `r` between two elements to a relation between `s` and `t`,\ns.t. there is a one-to-one mapping between elements in `s` and `t` following `r`. -/\n@[mk_iff]\ninductive Rel (r : α → β → Prop) : Multiset α → Multiset β → Prop\n  | zero : Rel r 0 0\n  | cons {a b as bs} : r a b → Rel r as bs → Rel r (a ::ₘ as) (b ::ₘ bs)\n\n"}
{"name":"Multiset.rel_flip","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\ns : Multiset β\nt : Multiset α\n⊢ Iff (Multiset.Rel (flip r) s t) (Multiset.Rel r t s)","decl":"theorem rel_flip {s t} : Rel (flip r) s t ↔ Rel r t s :=\n  ⟨rel_flip_aux, rel_flip_aux⟩\n\n"}
{"name":"Multiset.rel_refl_of_refl_on","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\nr : α → α → Prop\na✝ : ∀ (x : α), Membership.mem m x → r x x\n⊢ Multiset.Rel r m m","decl":"theorem rel_refl_of_refl_on {m : Multiset α} {r : α → α → Prop} : (∀ x ∈ m, r x x) → Rel r m m := by\n  refine m.induction_on ?_ ?_\n  · intros\n    apply Rel.zero\n  · intro a m ih h\n    exact Rel.cons (h _ (mem_cons_self _ _)) (ih fun _ ha => h _ (mem_cons_of_mem ha))\n\n"}
{"name":"Multiset.rel_eq_refl","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Multiset.Rel (fun x1 x2 => Eq x1 x2) s s","decl":"theorem rel_eq_refl {s : Multiset α} : Rel (· = ·) s s :=\n  rel_refl_of_refl_on fun _x _hx => rfl\n\n"}
{"name":"Multiset.rel_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Multiset.Rel (fun x1 x2 => Eq x1 x2) s t) (Eq s t)","decl":"theorem rel_eq {s t : Multiset α} : Rel (· = ·) s t ↔ s = t := by\n  constructor\n  · intro h\n    induction h <;> simp [*]\n  · intro h\n    subst h\n    exact rel_eq_refl\n\n"}
{"name":"Multiset.Rel.mono","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr p : α → β → Prop\ns : Multiset α\nt : Multiset β\nhst : Multiset.Rel r s t\nh : ∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → r a b → p a b\n⊢ Multiset.Rel p s t","decl":"theorem Rel.mono {r p : α → β → Prop} {s t} (hst : Rel r s t)\n    (h : ∀ a ∈ s, ∀ b ∈ t, r a b → p a b) : Rel p s t := by\n  induction hst with\n  | zero => exact Rel.zero\n  | @cons a b s t hab _hst ih =>\n    apply Rel.cons (h a (mem_cons_self _ _) b (mem_cons_self _ _) hab)\n    exact ih fun a' ha' b' hb' h' => h a' (mem_cons_of_mem ha') b' (mem_cons_of_mem hb') h'\n\n"}
{"name":"Multiset.Rel.add","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\ns : Multiset α\nt : Multiset β\nu : Multiset α\nv : Multiset β\nhst : Multiset.Rel r s t\nhuv : Multiset.Rel r u v\n⊢ Multiset.Rel r (HAdd.hAdd s u) (HAdd.hAdd t v)","decl":"theorem Rel.add {s t u v} (hst : Rel r s t) (huv : Rel r u v) : Rel r (s + u) (t + v) := by\n  induction hst with\n  | zero => simpa using huv\n  | cons hab hst ih => simpa using ih.cons hab\n\n"}
{"name":"Multiset.rel_flip_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Multiset.Rel (fun a b => Eq b a) s t) (Eq s t)","decl":"theorem rel_flip_eq {s t : Multiset α} : Rel (fun a b => b = a) s t ↔ s = t :=\n  show Rel (flip (· = ·)) s t ↔ s = t by rw [rel_flip, rel_eq, eq_comm]\n\n"}
{"name":"Multiset.rel_zero_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\nb : Multiset β\n⊢ Iff (Multiset.Rel r 0 b) (Eq b 0)","decl":"@[simp]\ntheorem rel_zero_left {b : Multiset β} : Rel r 0 b ↔ b = 0 := by rw [rel_iff]; simp\n\n"}
{"name":"Multiset.rel_zero_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\na : Multiset α\n⊢ Iff (Multiset.Rel r a 0) (Eq a 0)","decl":"@[simp]\ntheorem rel_zero_right {a : Multiset α} : Rel r a 0 ↔ a = 0 := by rw [rel_iff]; simp\n\n"}
{"name":"Multiset.rel_cons_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\na : α\nas : Multiset α\nbs : Multiset β\n⊢ Iff (Multiset.Rel r (Multiset.cons a as) bs) (Exists fun b => Exists fun bs' => And (r a b) (And (Multiset.Rel r as bs') (Eq bs (Multiset.cons b bs'))))","decl":"theorem rel_cons_left {a as bs} :\n    Rel r (a ::ₘ as) bs ↔ ∃ b bs', r a b ∧ Rel r as bs' ∧ bs = b ::ₘ bs' := by\n  constructor\n  · generalize hm : a ::ₘ as = m\n    intro h\n    induction h generalizing as with\n    | zero => simp at hm\n    | @cons a' b as' bs ha'b h ih =>\n      rcases cons_eq_cons.1 hm with (⟨eq₁, eq₂⟩ | ⟨_h, cs, eq₁, eq₂⟩)\n      · subst eq₁\n        subst eq₂\n        exact ⟨b, bs, ha'b, h, rfl⟩\n      · rcases ih eq₂.symm with ⟨b', bs', h₁, h₂, eq⟩\n        exact ⟨b', b ::ₘ bs', h₁, eq₁.symm ▸ Rel.cons ha'b h₂, eq.symm ▸ cons_swap _ _ _⟩\n  · exact fun ⟨b, bs', hab, h, Eq⟩ => Eq.symm ▸ Rel.cons hab h\n\n"}
{"name":"Multiset.rel_cons_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\nas : Multiset α\nb : β\nbs : Multiset β\n⊢ Iff (Multiset.Rel r as (Multiset.cons b bs)) (Exists fun a => Exists fun as' => And (r a b) (And (Multiset.Rel r as' bs) (Eq as (Multiset.cons a as'))))","decl":"theorem rel_cons_right {as b bs} :\n    Rel r as (b ::ₘ bs) ↔ ∃ a as', r a b ∧ Rel r as' bs ∧ as = a ::ₘ as' := by\n  rw [← rel_flip, rel_cons_left]\n  refine exists₂_congr fun a as' => ?_\n  rw [rel_flip, flip]\n\n"}
{"name":"Multiset.rel_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\nas₀ as₁ : Multiset α\nbs : Multiset β\n⊢ Iff (Multiset.Rel r (HAdd.hAdd as₀ as₁) bs) (Exists fun bs₀ => Exists fun bs₁ => And (Multiset.Rel r as₀ bs₀) (And (Multiset.Rel r as₁ bs₁) (Eq bs (HAdd.hAdd bs₀ bs₁))))","decl":"theorem rel_add_left {as₀ as₁} :\n    ∀ {bs}, Rel r (as₀ + as₁) bs ↔ ∃ bs₀ bs₁, Rel r as₀ bs₀ ∧ Rel r as₁ bs₁ ∧ bs = bs₀ + bs₁ :=\n  @(Multiset.induction_on as₀ (by simp) fun a s ih bs ↦ by\n      simp only [ih, cons_add, rel_cons_left]\n      constructor\n      · intro h\n        rcases h with ⟨b, bs', hab, h, rfl⟩\n        rcases h with ⟨bs₀, bs₁, h₀, h₁, rfl⟩\n        exact ⟨b ::ₘ bs₀, bs₁, ⟨b, bs₀, hab, h₀, rfl⟩, h₁, by simp⟩\n      · intro h\n        rcases h with ⟨bs₀, bs₁, h, h₁, rfl⟩\n        rcases h with ⟨b, bs, hab, h₀, rfl⟩\n        exact ⟨b, bs + bs₁, hab, ⟨bs, bs₁, h₀, h₁, rfl⟩, by simp⟩)\n\n"}
{"name":"Multiset.rel_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\nas : Multiset α\nbs₀ bs₁ : Multiset β\n⊢ Iff (Multiset.Rel r as (HAdd.hAdd bs₀ bs₁)) (Exists fun as₀ => Exists fun as₁ => And (Multiset.Rel r as₀ bs₀) (And (Multiset.Rel r as₁ bs₁) (Eq as (HAdd.hAdd as₀ as₁))))","decl":"theorem rel_add_right {as bs₀ bs₁} :\n    Rel r as (bs₀ + bs₁) ↔ ∃ as₀ as₁, Rel r as₀ bs₀ ∧ Rel r as₁ bs₁ ∧ as = as₀ + as₁ := by\n  rw [← rel_flip, rel_add_left]; simp [rel_flip]\n\n"}
{"name":"Multiset.rel_map_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nr : α → β → Prop\ns : Multiset γ\nf : γ → α\nt : Multiset β\n⊢ Iff (Multiset.Rel r (Multiset.map f s) t) (Multiset.Rel (fun a b => r (f a) b) s t)","decl":"theorem rel_map_left {s : Multiset γ} {f : γ → α} :\n    ∀ {t}, Rel r (s.map f) t ↔ Rel (fun a b => r (f a) b) s t :=\n  @(Multiset.induction_on s (by simp) (by simp +contextual [rel_cons_left]))\n\n"}
{"name":"Multiset.rel_map_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nr : α → β → Prop\ns : Multiset α\nt : Multiset γ\nf : γ → β\n⊢ Iff (Multiset.Rel r s (Multiset.map f t)) (Multiset.Rel (fun a b => r a (f b)) s t)","decl":"theorem rel_map_right {s : Multiset α} {t : Multiset γ} {f : γ → β} :\n    Rel r s (t.map f) ↔ Rel (fun a b => r a (f b)) s t := by\n  rw [← rel_flip, rel_map_left, ← rel_flip]; rfl\n\n"}
{"name":"Multiset.rel_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nδ : Type u_3\np : γ → δ → Prop\ns : Multiset α\nt : Multiset β\nf : α → γ\ng : β → δ\n⊢ Iff (Multiset.Rel p (Multiset.map f s) (Multiset.map g t)) (Multiset.Rel (fun a b => p (f a) (g b)) s t)","decl":"theorem rel_map {s : Multiset α} {t : Multiset β} {f : α → γ} {g : β → δ} :\n    Rel p (s.map f) (t.map g) ↔ Rel (fun a b => p (f a) (g b)) s t :=\n  rel_map_left.trans rel_map_right\n\n"}
{"name":"Multiset.card_eq_card_of_rel","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\ns : Multiset α\nt : Multiset β\nh : Multiset.Rel r s t\n⊢ Eq s.card t.card","decl":"theorem card_eq_card_of_rel {r : α → β → Prop} {s : Multiset α} {t : Multiset β} (h : Rel r s t) :\n    card s = card t := by induction h <;> simp [*]\n\n"}
{"name":"Multiset.exists_mem_of_rel_of_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\ns : Multiset α\nt : Multiset β\nh : Multiset.Rel r s t\na : α\na✝ : Membership.mem s a\n⊢ Exists fun b => And (Membership.mem t b) (r a b)","decl":"theorem exists_mem_of_rel_of_mem {r : α → β → Prop} {s : Multiset α} {t : Multiset β}\n    (h : Rel r s t) : ∀ {a : α}, a ∈ s → ∃ b ∈ t, r a b := by\n  induction' h with x y s t hxy _hst ih\n  · simp\n  · intro a ha\n    cases' mem_cons.1 ha with ha ha\n    · exact ⟨y, mem_cons_self _ _, ha.symm ▸ hxy⟩\n    · rcases ih ha with ⟨b, hbt, hab⟩\n      exact ⟨b, mem_cons.2 (Or.inr hbt), hab⟩\n\n"}
{"name":"Multiset.rel_of_forall","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm1 m2 : Multiset α\nr : α → α → Prop\nh : ∀ (a b : α), Membership.mem m1 a → Membership.mem m2 b → r a b\nhc : Eq m1.card m2.card\n⊢ Multiset.Rel r m1 m2","decl":"theorem rel_of_forall {m1 m2 : Multiset α} {r : α → α → Prop} (h : ∀ a b, a ∈ m1 → b ∈ m2 → r a b)\n    (hc : card m1 = card m2) : m1.Rel r m2 := by\n  revert m1\n  refine @(m2.induction_on ?_ ?_)\n  · intro m _h hc\n    rw [rel_zero_right, ← card_eq_zero, hc, card_zero]\n  · intro a t ih m h hc\n    rw [card_cons] at hc\n    obtain ⟨b, hb⟩ := card_pos_iff_exists_mem.1 (show 0 < card m from hc.symm ▸ Nat.succ_pos _)\n    obtain ⟨m', rfl⟩ := exists_cons_of_mem hb\n    refine rel_cons_right.mpr ⟨b, m', h _ _ hb (mem_cons_self _ _), ih ?_ ?_, rfl⟩\n    · exact fun _ _ ha hb => h _ _ (mem_cons_of_mem ha) (mem_cons_of_mem hb)\n    · simpa using hc\n\n"}
{"name":"Multiset.rel_replicate_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\na : α\nr : α → α → Prop\nn : Nat\n⊢ Iff (Multiset.Rel r (Multiset.replicate n a) m) (And (Eq m.card n) (∀ (x : α), Membership.mem m x → r a x))","decl":"theorem rel_replicate_left {m : Multiset α} {a : α} {r : α → α → Prop} {n : ℕ} :\n    (replicate n a).Rel r m ↔ card m = n ∧ ∀ x, x ∈ m → r a x :=\n  ⟨fun h =>\n    ⟨(card_eq_card_of_rel h).symm.trans (card_replicate _ _), fun x hx => by\n      obtain ⟨b, hb1, hb2⟩ := exists_mem_of_rel_of_mem (rel_flip.2 h) hx\n      rwa [eq_of_mem_replicate hb1] at hb2⟩,\n    fun h =>\n    rel_of_forall (fun _ _ hx hy => (eq_of_mem_replicate hx).symm ▸ h.2 _ hy)\n      (Eq.trans (card_replicate _ _) h.1.symm)⟩\n\n"}
{"name":"Multiset.rel_replicate_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nm : Multiset α\na : α\nr : α → α → Prop\nn : Nat\n⊢ Iff (Multiset.Rel r m (Multiset.replicate n a)) (And (Eq m.card n) (∀ (x : α), Membership.mem m x → r x a))","decl":"theorem rel_replicate_right {m : Multiset α} {a : α} {r : α → α → Prop} {n : ℕ} :\n    m.Rel r (replicate n a) ↔ card m = n ∧ ∀ x, x ∈ m → r x a :=\n  rel_flip.trans rel_replicate_left\n\n"}
{"name":"Multiset.Rel.trans","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsTrans α r\ns t u : Multiset α\nr1 : Multiset.Rel r s t\nr2 : Multiset.Rel r t u\n⊢ Multiset.Rel r s u","decl":"protected nonrec -- Porting note: added\ntheorem Rel.trans (r : α → α → Prop) [IsTrans α r] {s t u : Multiset α} (r1 : Rel r s t)\n    (r2 : Rel r t u) : Rel r s u := by\n  induction' t using Multiset.induction_on with x t ih generalizing s u\n  · rw [rel_zero_right.mp r1, rel_zero_left.mp r2, rel_zero_left]\n  · obtain ⟨a, as, ha1, ha2, rfl⟩ := rel_cons_right.mp r1\n    obtain ⟨b, bs, hb1, hb2, rfl⟩ := rel_cons_left.mp r2\n    exact Multiset.Rel.cons (_root_.trans ha1 hb1) (ih ha2 hb2)\n\n"}
{"name":"Multiset.Rel.countP_eq","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝² : IsTrans α r\ninst✝¹ : IsSymm α r\ns t : Multiset α\nx : α\ninst✝ : DecidablePred (r x)\nh : Multiset.Rel r s t\n⊢ Eq (Multiset.countP (r x) s) (Multiset.countP (r x) t)","decl":"theorem Rel.countP_eq (r : α → α → Prop) [IsTrans α r] [IsSymm α r] {s t : Multiset α} (x : α)\n    [DecidablePred (r x)] (h : Rel r s t) : countP (r x) s = countP (r x) t := by\n  induction' s using Multiset.induction_on with y s ih generalizing t\n  · rw [rel_zero_left.mp h]\n  · obtain ⟨b, bs, hb1, hb2, rfl⟩ := rel_cons_left.mp h\n    rw [countP_cons, countP_cons, ih hb2]\n    simp only [decide_eq_true_eq, Nat.add_right_inj]\n    exact (if_congr ⟨fun h => _root_.trans h hb1, fun h => _root_.trans h (symm hb1)⟩ rfl rfl)\n\n"}
{"name":"Multiset.map_eq_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nhf : Function.Injective f\ns t : Multiset α\n⊢ Iff (Eq (Multiset.map f s) (Multiset.map f t)) (Eq s t)","decl":"theorem map_eq_map {f : α → β} (hf : Function.Injective f) {s t : Multiset α} :\n    s.map f = t.map f ↔ s = t := by\n  rw [← rel_eq, ← rel_eq, rel_map]\n  simp only [hf.eq_iff]\n\n"}
{"name":"Multiset.map_injective","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective (Multiset.map f)","decl":"theorem map_injective {f : α → β} (hf : Function.Injective f) :\n    Function.Injective (Multiset.map f) := fun _x _y => (map_eq_map hf).1\n\n"}
{"name":"Multiset.filter_attach'","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns : Multiset α\np : (Subtype fun a => Membership.mem s a) → Prop\ninst✝¹ : DecidableEq α\ninst✝ : DecidablePred p\n⊢ Eq (Multiset.filter p s.attach) (Multiset.map (Subtype.map id ⋯) (Multiset.filter (fun x => Exists fun h => p ⟨x, h⟩) s).attach)","decl":"lemma filter_attach' (s : Multiset α) (p : {a // a ∈ s} → Prop) [DecidableEq α]\n    [DecidablePred p] :\n    s.attach.filter p =\n      (s.filter fun x ↦ ∃ h, p ⟨x, h⟩).attach.map (Subtype.map id fun _ ↦ mem_of_mem_filter) := by\n  classical\n  refine Multiset.map_injective Subtype.val_injective ?_\n  rw [map_filter' _ Subtype.val_injective]\n  simp only [Function.comp, Subtype.exists, coe_mk, Subtype.map,\n    exists_and_right, exists_eq_right, attach_map_val, map_map, map_coe, id]\n\n"}
{"name":"Multiset.map_mk_eq_map_mk_of_rel","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Multiset α\nhst : Multiset.Rel r s t\n⊢ Eq (Multiset.map (Quot.mk r) s) (Multiset.map (Quot.mk r) t)","decl":"theorem map_mk_eq_map_mk_of_rel {r : α → α → Prop} {s t : Multiset α} (hst : s.Rel r t) :\n    s.map (Quot.mk r) = t.map (Quot.mk r) :=\n  Rel.recOn hst rfl fun hab _hst ih => by simp [ih, Quot.sound hab]\n\n"}
{"name":"Multiset.exists_multiset_eq_map_quot_mk","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Multiset (Quot r)\n⊢ Exists fun t => Eq s (Multiset.map (Quot.mk r) t)","decl":"theorem exists_multiset_eq_map_quot_mk {r : α → α → Prop} (s : Multiset (Quot r)) :\n    ∃ t : Multiset α, s = t.map (Quot.mk r) :=\n  Multiset.induction_on s ⟨0, rfl⟩ fun a _s ⟨t, ht⟩ =>\n    Quot.inductionOn a fun a => ht.symm ▸ ⟨a ::ₘ t, (map_cons _ _ _).symm⟩\n\n"}
{"name":"Multiset.induction_on_multiset_quot","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\np : Multiset (Quot r) → Prop\ns : Multiset (Quot r)\na✝ : ∀ (s : Multiset α), p (Multiset.map (Quot.mk r) s)\n⊢ p s","decl":"theorem induction_on_multiset_quot {r : α → α → Prop} {p : Multiset (Quot r) → Prop}\n    (s : Multiset (Quot r)) : (∀ s : Multiset α, p (s.map (Quot.mk r))) → p s :=\n  match s, exists_multiset_eq_map_quot_mk s with\n  | _, ⟨_t, rfl⟩ => fun h => h _\n\n"}
{"name":"Multiset.disjoint_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Disjoint s t) (∀ {a : α}, Membership.mem s a → Not (Membership.mem t a))","decl":"theorem disjoint_left {s t : Multiset α} : Disjoint s t ↔ ∀ {a}, a ∈ s → a ∉ t := by\n  refine ⟨fun h a hs ht ↦ ?_, fun h u hs ht ↦ ?_⟩\n  · simpa using h (singleton_le.mpr hs) (singleton_le.mpr ht)\n  · rw [le_bot_iff, bot_eq_zero, eq_zero_iff_forall_not_mem]\n    exact fun a ha ↦ h (subset_of_le hs ha) (subset_of_le ht ha)\n\n"}
{"name":"Multiset.coe_disjoint","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl₁ l₂ : List α\n⊢ Iff (Disjoint ↑l₁ ↑l₂) (l₁.Disjoint l₂)","decl":"@[simp, norm_cast]\ntheorem coe_disjoint (l₁ l₂ : List α) : Disjoint (l₁ : Multiset α) l₂ ↔ l₁.Disjoint l₂ :=\n  disjoint_left\n\n"}
{"name":"Multiset.Disjoint.symm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\na✝ : Disjoint a b\n⊢ Disjoint b a","decl":"@[deprecated (since := \"2024-11-01\")] protected alias Disjoint.symm := _root_.Disjoint.symm\n"}
{"name":"Multiset.disjoint_comm","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\n⊢ Iff (Disjoint a b) (Disjoint b a)","decl":"@[deprecated (since := \"2024-11-01\")] protected alias disjoint_comm := _root_.disjoint_comm\n\n"}
{"name":"Multiset.disjoint_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Disjoint s t) (∀ {a : α}, Membership.mem t a → Not (Membership.mem s a))","decl":"theorem disjoint_right {s t : Multiset α} : Disjoint s t ↔ ∀ {a}, a ∈ t → a ∉ s :=\n  disjoint_comm.trans disjoint_left\n\n"}
{"name":"Multiset.disjoint_iff_ne","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Disjoint s t) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → Ne a b)","decl":"theorem disjoint_iff_ne {s t : Multiset α} : Disjoint s t ↔ ∀ a ∈ s, ∀ b ∈ t, a ≠ b := by\n  simp [disjoint_left, imp_not_comm]\n\n"}
{"name":"Multiset.disjoint_of_subset_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\nh : HasSubset.Subset s u\nd : Disjoint u t\n⊢ Disjoint s t","decl":"theorem disjoint_of_subset_left {s t u : Multiset α} (h : s ⊆ u) (d : Disjoint u t) :\n    Disjoint s t :=\n  disjoint_left.mpr fun ha ↦ disjoint_left.mp d <| h ha\n\n"}
{"name":"Multiset.disjoint_of_subset_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\nh : HasSubset.Subset t u\nd : Disjoint s u\n⊢ Disjoint s t","decl":"theorem disjoint_of_subset_right {s t u : Multiset α} (h : t ⊆ u) (d : Disjoint s u) :\n    Disjoint s t :=\n  (disjoint_of_subset_left h d.symm).symm\n\n"}
{"name":"Multiset.disjoint_of_le_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b c : α\nh : LE.le a b\na✝ : Disjoint b c\n⊢ Disjoint a c","decl":"@[deprecated (since := \"2024-11-01\")] protected alias disjoint_of_le_left := Disjoint.mono_left\n"}
{"name":"Multiset.disjoint_of_le_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b c : α\na✝¹ : LE.le b c\na✝ : Disjoint a c\n⊢ Disjoint a b","decl":"@[deprecated (since := \"2024-11-01\")] protected alias disjoint_of_le_right := Disjoint.mono_right\n\n"}
{"name":"Multiset.zero_disjoint","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : Multiset α\n⊢ Disjoint 0 l","decl":"@[simp]\ntheorem zero_disjoint (l : Multiset α) : Disjoint 0 l := disjoint_bot_left\n\n"}
{"name":"Multiset.singleton_disjoint","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : Multiset α\na : α\n⊢ Iff (Disjoint (Singleton.singleton a) l) (Not (Membership.mem l a))","decl":"@[simp]\ntheorem singleton_disjoint {l : Multiset α} {a : α} : Disjoint {a} l ↔ a ∉ l := by\n  simp [disjoint_left]\n\n"}
{"name":"Multiset.disjoint_singleton","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nl : Multiset α\na : α\n⊢ Iff (Disjoint l (Singleton.singleton a)) (Not (Membership.mem l a))","decl":"@[simp]\ntheorem disjoint_singleton {l : Multiset α} {a : α} : Disjoint l {a} ↔ a ∉ l := by\n  rw [_root_.disjoint_comm, singleton_disjoint]\n\n"}
{"name":"Multiset.disjoint_add_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (Disjoint (HAdd.hAdd s t) u) (And (Disjoint s u) (Disjoint t u))","decl":"@[simp]\ntheorem disjoint_add_left {s t u : Multiset α} :\n    Disjoint (s + t) u ↔ Disjoint s u ∧ Disjoint t u := by simp [disjoint_left, or_imp, forall_and]\n\n"}
{"name":"Multiset.disjoint_add_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ns t u : Multiset α\n⊢ Iff (Disjoint s (HAdd.hAdd t u)) (And (Disjoint s t) (Disjoint s u))","decl":"@[simp]\ntheorem disjoint_add_right {s t u : Multiset α} :\n    Disjoint s (t + u) ↔ Disjoint s t ∧ Disjoint s u := by\n  rw [_root_.disjoint_comm, disjoint_add_left]; tauto\n\n"}
{"name":"Multiset.disjoint_cons_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Iff (Disjoint (Multiset.cons a s) t) (And (Not (Membership.mem t a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_cons_left {a : α} {s t : Multiset α} :\n    Disjoint (a ::ₘ s) t ↔ a ∉ t ∧ Disjoint s t :=\n  (@disjoint_add_left _ {a} s t).trans <| by rw [singleton_disjoint]\n\n"}
{"name":"Multiset.disjoint_cons_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\na : α\ns t : Multiset α\n⊢ Iff (Disjoint s (Multiset.cons a t)) (And (Not (Membership.mem s a)) (Disjoint s t))","decl":"@[simp]\ntheorem disjoint_cons_right {a : α} {s t : Multiset α} :\n    Disjoint s (a ::ₘ t) ↔ a ∉ s ∧ Disjoint s t := by\n  rw [_root_.disjoint_comm, disjoint_cons_left]; tauto\n\n"}
{"name":"Multiset.inter_eq_zero_iff_disjoint","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq (Inter.inter s t) 0) (Disjoint s t)","decl":"theorem inter_eq_zero_iff_disjoint [DecidableEq α] {s t : Multiset α} :\n    s ∩ t = 0 ↔ Disjoint s t := by rw [← subset_zero]; simp [subset_iff, disjoint_left]\n\n"}
{"name":"Multiset.disjoint_union_left","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (Disjoint (Union.union s t) u) (And (Disjoint s u) (Disjoint t u))","decl":"@[simp]\ntheorem disjoint_union_left [DecidableEq α] {s t u : Multiset α} :\n    Disjoint (s ∪ t) u ↔ Disjoint s u ∧ Disjoint t u :=  disjoint_sup_left\n\n"}
{"name":"Multiset.disjoint_union_right","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\n⊢ Iff (Disjoint s (Union.union t u)) (And (Disjoint s t) (Disjoint s u))","decl":"@[simp]\ntheorem disjoint_union_right [DecidableEq α] {s t u : Multiset α} :\n    Disjoint s (t ∪ u) ↔ Disjoint s t ∧ Disjoint s u := disjoint_sup_right\n\n"}
{"name":"Multiset.add_eq_union_iff_disjoint","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Multiset α\n⊢ Iff (Eq (HAdd.hAdd s t) (Union.union s t)) (Disjoint s t)","decl":"theorem add_eq_union_iff_disjoint [DecidableEq α] {s t : Multiset α} :\n    s + t = s ∪ t ↔ Disjoint s t := by\n  simp_rw [← inter_eq_zero_iff_disjoint, ext, count_add, count_union, count_inter, count_zero,\n    Nat.min_eq_zero_iff, Nat.add_eq_max_iff]\n\n"}
{"name":"Multiset.add_eq_union_left_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t u : Multiset α\nh : LE.le t s\n⊢ Iff (Eq (HAdd.hAdd u s) (Union.union u t)) (And (Disjoint u s) (Eq s t))","decl":"lemma add_eq_union_left_of_le [DecidableEq α] {s t u : Multiset α} (h : t ≤ s) :\n    u + s = u ∪ t ↔ Disjoint u s ∧ s = t := by\n  rw [← add_eq_union_iff_disjoint]\n  refine ⟨fun h0 ↦ ?_, ?_⟩\n  · rw [and_iff_right_of_imp]\n    · exact (Multiset.le_of_add_le_add_left <| h0.trans_le <| union_le_add u t).antisymm h\n    · rintro rfl\n      exact h0\n  · rintro ⟨h0, rfl⟩\n    exact h0\n\n"}
{"name":"Multiset.add_eq_union_right_of_le","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx y z : Multiset α\nh : LE.le z y\n⊢ Iff (Eq (HAdd.hAdd x y) (Union.union x z)) (And (Eq y z) (Disjoint x y))","decl":"lemma add_eq_union_right_of_le [DecidableEq α] {x y z : Multiset α} (h : z ≤ y) :\n    x + y = x ∪ z ↔ y = z ∧ Disjoint x y := by\n  simpa only [and_comm] using add_eq_union_left_of_le h\n\n"}
{"name":"Multiset.disjoint_map_map","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nf : α → γ\ng : β → γ\ns : Multiset α\nt : Multiset β\n⊢ Iff (Disjoint (Multiset.map f s) (Multiset.map g t)) (∀ (a : α), Membership.mem s a → ∀ (b : β), Membership.mem t b → Ne (f a) (g b))","decl":"theorem disjoint_map_map {f : α → γ} {g : β → γ} {s : Multiset α} {t : Multiset β} :\n    Disjoint (s.map f) (t.map g) ↔ ∀ a ∈ s, ∀ b ∈ t, f a ≠ g b := by\n  simp [disjoint_iff_ne]\n\n"}
{"name":"Multiset.pairwise_zero","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Multiset.Pairwise r 0","decl":"@[simp]\ntheorem pairwise_zero (r : α → α → Prop) : Multiset.Pairwise r 0 :=\n  ⟨[], rfl, List.Pairwise.nil⟩\n\n"}
{"name":"Multiset.pairwise_coe_iff","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\nl : List α\n⊢ Iff (Multiset.Pairwise r ↑l) (Exists fun l' => And (l.Perm l') (List.Pairwise r l'))","decl":"theorem pairwise_coe_iff {r : α → α → Prop} {l : List α} :\n    Multiset.Pairwise r l ↔ ∃ l' : List α, l ~ l' ∧ l'.Pairwise r :=\n  exists_congr <| by simp\n\n"}
{"name":"Multiset.pairwise_coe_iff_pairwise","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nr : α → α → Prop\nhr : Symmetric r\nl : List α\n⊢ Iff (Multiset.Pairwise r ↑l) (List.Pairwise r l)","decl":"theorem pairwise_coe_iff_pairwise {r : α → α → Prop} (hr : Symmetric r) {l : List α} :\n    Multiset.Pairwise r l ↔ l.Pairwise r :=\n  Iff.intro (fun ⟨_l', Eq, h⟩ => ((Quotient.exact Eq).pairwise_iff @hr).2 h) fun h => ⟨l, rfl, h⟩\n\n"}
{"name":"Multiset.map_set_pairwise","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nr : β → β → Prop\nm : Multiset α\nh : (setOf fun a => Membership.mem m a).Pairwise fun a₁ a₂ => r (f a₁) (f a₂)\n⊢ (setOf fun b => Membership.mem (Multiset.map f m) b).Pairwise r","decl":"theorem map_set_pairwise {f : α → β} {r : β → β → Prop} {m : Multiset α}\n    (h : { a | a ∈ m }.Pairwise fun a₁ a₂ => r (f a₁) (f a₂)) : { b | b ∈ m.map f }.Pairwise r :=\n  fun b₁ h₁ b₂ h₂ hn => by\n    obtain ⟨⟨a₁, H₁, rfl⟩, a₂, H₂, rfl⟩ := Multiset.mem_map.1 h₁, Multiset.mem_map.1 h₂\n    exact h H₁ H₂ (mt (congr_arg f) hn)\n\n"}
{"name":"Multiset.choose_spec","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Multiset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ And (Membership.mem l (Multiset.choose p l hp)) (p (Multiset.choose p l hp))","decl":"theorem choose_spec (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l ∧ p (choose p l hp) :=\n  (chooseX p l hp).property\n\n"}
{"name":"Multiset.choose_mem","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Multiset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ Membership.mem l (Multiset.choose p l hp)","decl":"theorem choose_mem (hp : ∃! a, a ∈ l ∧ p a) : choose p l hp ∈ l :=\n  (choose_spec _ _ _).1\n\n"}
{"name":"Multiset.choose_property","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\nl : Multiset α\nhp : ExistsUnique fun a => And (Membership.mem l a) (p a)\n⊢ p (Multiset.choose p l hp)","decl":"theorem choose_property (hp : ∃! a, a ∈ l ∧ p a) : p (choose p l hp) :=\n  (choose_spec _ _ _).2\n\n"}
{"name":"Multiset.coe_subsingletonEquiv","module":"Mathlib.Data.Multiset.Basic","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\n⊢ Eq (⇑(Multiset.subsingletonEquiv α)) Multiset.ofList","decl":"@[simp]\ntheorem coe_subsingletonEquiv [Subsingleton α] :\n    (subsingletonEquiv α : List α → Multiset α) = ofList :=\n  rfl\n\n"}
