{"name":"Polynomial.int_coeff_eq","module":"Mathlib.Algebra.Ring.Subring.IntPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nR : Subring K\nP : Polynomial K\nhP : ∀ (n : Nat), Membership.mem R (P.coeff n)\nn : Nat\n⊢ Eq (↑((Polynomial.int R P hP).coeff n)) (P.coeff n)","decl":"@[simp]\ntheorem int_coeff_eq  (n : ℕ) : ↑((P.int R hP).coeff n) = P.coeff n := rfl\n\n"}
{"name":"Polynomial.int_leadingCoeff_eq","module":"Mathlib.Algebra.Ring.Subring.IntPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nR : Subring K\nP : Polynomial K\nhP : ∀ (n : Nat), Membership.mem R (P.coeff n)\n⊢ Eq (↑(Polynomial.int R P hP).leadingCoeff) P.leadingCoeff","decl":"@[simp]\ntheorem int_leadingCoeff_eq : ↑(P.int R hP).leadingCoeff = P.leadingCoeff := rfl\n\n"}
{"name":"Polynomial.int_monic_iff","module":"Mathlib.Algebra.Ring.Subring.IntPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nR : Subring K\nP : Polynomial K\nhP : ∀ (n : Nat), Membership.mem R (P.coeff n)\n⊢ Iff (Polynomial.int R P hP).Monic P.Monic","decl":"@[simp]\ntheorem int_monic_iff : (P.int R hP).Monic ↔ P.Monic := by\n  rw [Monic, Monic, ← int_leadingCoeff_eq, OneMemClass.coe_eq_one]\n\n"}
{"name":"Polynomial.int_natDegree","module":"Mathlib.Algebra.Ring.Subring.IntPolynomial","initialProofState":"K : Type u_1\ninst✝ : Field K\nR : Subring K\nP : Polynomial K\nhP : ∀ (n : Nat), Membership.mem R (P.coeff n)\n⊢ Eq (Polynomial.int R P hP).natDegree P.natDegree","decl":"@[simp]\ntheorem int_natDegree : (P.int R hP).natDegree = P.natDegree := rfl\n\n"}
{"name":"Polynomial.int_eval₂_eq","module":"Mathlib.Algebra.Ring.Subring.IntPolynomial","initialProofState":"K : Type u_1\ninst✝² : Field K\nR : Subring K\nP : Polynomial K\nhP : ∀ (n : Nat), Membership.mem R (P.coeff n)\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\n⊢ Eq (Polynomial.eval₂ (algebraMap (Subtype fun x => Membership.mem R x) L) x (Polynomial.int R P hP)) ((Polynomial.aeval x) P)","decl":"@[simp]\ntheorem int_eval₂_eq (x : L) :\n    eval₂ (algebraMap R L) x (P.int R hP) = aeval x P := by\n  rw [aeval_eq_sum_range, eval₂_eq_sum_range]\n  exact Finset.sum_congr rfl (fun n _ => by rw [Algebra.smul_def]; rfl)\n\n"}
