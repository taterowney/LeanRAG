{"name":"Multiset.covBy_cons","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Multiset α\na : α\n⊢ CovBy s (Multiset.cons a s)","decl":"@[simp] lemma covBy_cons (s : Multiset α) (a : α) : s ⋖ a ::ₘ s :=\n  ⟨lt_cons_self _ _, fun t hst hts ↦ (covBy_succ _).2 (card_lt_card hst) <| by\n    simpa using card_lt_card hts⟩\n\n"}
{"name":"CovBy.exists_multiset_cons","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Multiset α\nh : CovBy s t\n⊢ Exists fun a => Eq (Multiset.cons a s) t","decl":"lemma _root_.CovBy.exists_multiset_cons (h : s ⋖ t) : ∃ a, a ::ₘ s = t :=\n  (lt_iff_cons_le.1 h.lt).imp fun _a ha ↦ ha.eq_of_not_lt <| h.2 <| lt_cons_self _ _\n\n"}
{"name":"Multiset.covBy_iff","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (CovBy s t) (Exists fun a => Eq (Multiset.cons a s) t)","decl":"lemma covBy_iff : s ⋖ t ↔ ∃ a, a ::ₘ s = t :=\n  ⟨CovBy.exists_multiset_cons, by rintro ⟨a, rfl⟩; exact covBy_cons _ _⟩\n\n"}
{"name":"CovBy.card_multiset","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Multiset α\nh : CovBy s t\n⊢ CovBy s.card t.card","decl":"lemma _root_.CovBy.card_multiset (h : s ⋖ t) : card s ⋖ card t := by\n  obtain ⟨a, rfl⟩ := h.exists_multiset_cons; rw [card_cons]; exact covBy_succ _\n\n"}
{"name":"Multiset.isAtom_iff","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff (IsAtom s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"lemma isAtom_iff : IsAtom s ↔ ∃ a, s = {a} := by simp [← bot_covBy_iff, covBy_iff, eq_comm]\n\n"}
{"name":"Multiset.isAtom_singleton","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\na : α\n⊢ IsAtom (Singleton.singleton a)","decl":"@[simp] lemma isAtom_singleton (a : α) : IsAtom ({a} : Multiset α) := isAtom_iff.2 ⟨_, rfl⟩\n\n"}
{"name":"Multiset.grade_eq","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\nm : Multiset α\n⊢ Eq (grade Nat m) m.card","decl":"@[simp] lemma grade_eq (m : Multiset α) : grade ℕ m = card m := rfl\n\n"}
{"name":"Finset.ordConnected_range_val","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\n⊢ (Set.range Finset.val).OrdConnected","decl":"/-- Finsets form an order-connected suborder of multisets. -/\nlemma ordConnected_range_val : Set.OrdConnected (Set.range val : Set <| Multiset α) :=\n  ⟨by rintro _ _ _ ⟨s, rfl⟩ t ht; exact ⟨⟨t, Multiset.nodup_of_le ht.2 s.2⟩, rfl⟩⟩\n\n"}
{"name":"Finset.ordConnected_range_coe","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\n⊢ (Set.range Finset.toSet).OrdConnected","decl":"/-- Finsets form an order-connected suborder of sets. -/\nlemma ordConnected_range_coe : Set.OrdConnected (Set.range ((↑) : Finset α → Set α)) :=\n  ⟨by rintro _ _ _ ⟨s, rfl⟩ t ht; exact ⟨_, (s.finite_toSet.subset ht.2).coe_toFinset⟩⟩\n\n"}
{"name":"Finset.val_wcovBy_val","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (WCovBy s.val t.val) (WCovBy s t)","decl":"@[simp] lemma val_wcovBy_val : s.1 ⩿ t.1 ↔ s ⩿ t :=\n  ordConnected_range_val.apply_wcovBy_apply_iff ⟨⟨_, val_injective⟩, val_le_iff⟩\n\n"}
{"name":"Finset.val_covBy_val","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (CovBy s.val t.val) (CovBy s t)","decl":"@[simp] lemma val_covBy_val : s.1 ⋖ t.1 ↔ s ⋖ t :=\n  ordConnected_range_val.apply_covBy_apply_iff ⟨⟨_, val_injective⟩, val_le_iff⟩\n\n"}
{"name":"Finset.coe_wcovBy_coe","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (WCovBy ↑s ↑t) (WCovBy s t)","decl":"@[simp] lemma coe_wcovBy_coe : (s : Set α) ⩿ t ↔ s ⩿ t :=\n  ordConnected_range_coe.apply_wcovBy_apply_iff ⟨⟨_, coe_injective⟩, coe_subset⟩\n\n"}
{"name":"Finset.coe_covBy_coe","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (CovBy ↑s ↑t) (CovBy s t)","decl":"@[simp] lemma coe_covBy_coe : (s : Set α) ⋖ t ↔ s ⋖ t :=\n  ordConnected_range_coe.apply_covBy_apply_iff ⟨⟨_, coe_injective⟩, coe_subset⟩\n\n"}
{"name":"WCovBy.finset_val","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : WCovBy s t\n⊢ WCovBy s.val t.val","decl":"alias ⟨_, _root_.WCovBy.finset_val⟩ := val_wcovBy_val\n"}
{"name":"CovBy.finset_val","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : CovBy s t\n⊢ CovBy s.val t.val","decl":"alias ⟨_, _root_.CovBy.finset_val⟩ := val_covBy_val\n"}
{"name":"WCovBy.finset_coe","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : WCovBy s t\n⊢ WCovBy ↑s ↑t","decl":"alias ⟨_, _root_.WCovBy.finset_coe⟩ := coe_wcovBy_coe\n"}
{"name":"CovBy.finset_coe","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\na✝ : CovBy s t\n⊢ CovBy ↑s ↑t","decl":"alias ⟨_, _root_.CovBy.finset_coe⟩ := coe_covBy_coe\n\n"}
{"name":"Finset.covBy_cons","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\na : α\nha : Not (Membership.mem s a)\n⊢ CovBy s (Finset.cons a s ha)","decl":"@[simp] lemma covBy_cons (ha : a ∉ s) : s ⋖ s.cons a ha := by simp [← val_covBy_val]\n\n"}
{"name":"CovBy.exists_finset_cons","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\nh : CovBy s t\n⊢ Exists fun a => Exists fun ha => Eq (Finset.cons a s ha) t","decl":"lemma _root_.CovBy.exists_finset_cons (h : s ⋖ t) : ∃ a, ∃ ha : a ∉ s, s.cons a ha = t :=\n  let ⟨a, ha, hst⟩ := ssubset_iff_exists_cons_subset.1 h.lt\n  ⟨a, ha, (hst.eq_of_not_ssuperset <| h.2 <| ssubset_cons _).symm⟩\n\n"}
{"name":"Finset.covBy_iff_exists_cons","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\n⊢ Iff (CovBy s t) (Exists fun a => Exists fun ha => Eq (Finset.cons a s ha) t)","decl":"lemma covBy_iff_exists_cons : s ⋖ t ↔ ∃ a, ∃ ha : a ∉ s, s.cons a ha = t :=\n  ⟨CovBy.exists_finset_cons, by rintro ⟨a, ha, rfl⟩; exact covBy_cons _⟩\n\n"}
{"name":"CovBy.card_finset","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\nh : CovBy s t\n⊢ CovBy s.card t.card","decl":"lemma _root_.CovBy.card_finset (h : s ⋖ t) : s.card ⋖ t.card := (val_covBy_val.2 h).card_multiset\n\n"}
{"name":"Finset.wcovBy_insert","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ WCovBy s (Insert.insert a s)","decl":"@[simp] lemma wcovBy_insert (s : Finset α) (a : α) : s ⩿ insert a s := by simp [← coe_wcovBy_coe]\n"}
{"name":"Finset.erase_wcovBy","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\na : α\n⊢ WCovBy (s.erase a) s","decl":"@[simp] lemma erase_wcovBy (s : Finset α) (a : α) : s.erase a ⩿ s := by simp [← coe_wcovBy_coe]\n\n"}
{"name":"Finset.covBy_insert","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nha : Not (Membership.mem s a)\n⊢ CovBy s (Insert.insert a s)","decl":"lemma covBy_insert (ha : a ∉ s) : s ⋖ insert a s :=\n  (wcovBy_insert _ _).covBy_of_lt <| ssubset_insert ha\n\n"}
{"name":"Finset.erase_covBy","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\na : α\ninst✝ : DecidableEq α\nha : Membership.mem s a\n⊢ CovBy (s.erase a) s","decl":"@[simp] lemma erase_covBy (ha : a ∈ s) : s.erase a ⋖ s := ⟨erase_ssubset ha, (erase_wcovBy _ _).2⟩\n\n"}
{"name":"CovBy.exists_finset_insert","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\nh : CovBy s t\n⊢ Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t)","decl":"lemma _root_.CovBy.exists_finset_insert (h : s ⋖ t) : ∃ a ∉ s, insert a s = t := by\n  simpa using h.exists_finset_cons\n\n"}
{"name":"CovBy.exists_finset_erase","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\nh : CovBy s t\n⊢ Exists fun a => And (Membership.mem t a) (Eq (t.erase a) s)","decl":"lemma _root_.CovBy.exists_finset_erase (h : s ⋖ t) : ∃ a ∈ t, t.erase a = s := by\n  simpa only [← coe_inj, coe_erase] using h.finset_coe.exists_set_sdiff_singleton\n\n"}
{"name":"Finset.covBy_iff_exists_insert","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (CovBy s t) (Exists fun a => And (Not (Membership.mem s a)) (Eq (Insert.insert a s) t))","decl":"lemma covBy_iff_exists_insert : s ⋖ t ↔ ∃ a ∉ s, insert a s = t := by\n  simp only [← coe_covBy_coe, Set.covBy_iff_exists_insert, ← coe_inj, coe_insert, mem_coe]\n\n"}
{"name":"Finset.covBy_iff_card_sdiff_eq_one","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (CovBy t s) (And (HasSubset.Subset t s) (Eq (SDiff.sdiff s t).card 1))","decl":"lemma covBy_iff_card_sdiff_eq_one : t ⋖ s ↔ t ⊆ s ∧ (s \\ t).card = 1 := by\n  rw [covBy_iff_exists_insert]\n  constructor\n  · rintro ⟨a, ha, rfl⟩\n    simp [*]\n  · simp_rw [card_eq_one]\n    rintro ⟨hts, a, ha⟩\n    refine ⟨a, (mem_sdiff.1 <| superset_of_eq ha <| mem_singleton_self _).2, ?_⟩\n    rw [insert_eq, ← ha, sdiff_union_of_subset hts]\n\n"}
{"name":"Finset.covBy_iff_exists_erase","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns t : Finset α\ninst✝ : DecidableEq α\n⊢ Iff (CovBy s t) (Exists fun a => And (Membership.mem t a) (Eq (t.erase a) s))","decl":"lemma covBy_iff_exists_erase : s ⋖ t ↔ ∃ a ∈ t, t.erase a = s := by\n  simp only [← coe_covBy_coe, Set.covBy_iff_exists_sdiff_singleton, ← coe_inj, coe_erase, mem_coe]\n\n"}
{"name":"Finset.isAtom_singleton","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\na : α\n⊢ IsAtom (Singleton.singleton a)","decl":"@[simp] lemma isAtom_singleton (a : α) : IsAtom ({a} : Finset α) :=\n  ⟨singleton_ne_empty a, fun _ ↦ eq_empty_of_ssubset_singleton⟩\n\n"}
{"name":"Finset.isAtom_iff","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Iff (IsAtom s) (Exists fun a => Eq s (Singleton.singleton a))","decl":"protected lemma isAtom_iff : IsAtom s ↔ ∃ a, s = {a} := by\n  simp [← bot_covBy_iff, covBy_iff_exists_cons, eq_comm]\n\n"}
{"name":"Finset.isCoatom_compl_singleton","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na : α\n⊢ IsCoatom (HasCompl.compl (Singleton.singleton a))","decl":"lemma isCoatom_compl_singleton (a : α) : IsCoatom ({a}ᶜ : Finset α) := (isAtom_singleton a).compl\n\n"}
{"name":"Finset.isCoatom_iff","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Iff (IsCoatom s) (Exists fun a => Eq s (HasCompl.compl (Singleton.singleton a)))","decl":"protected lemma isCoatom_iff : IsCoatom s ↔ ∃ a, s = {a}ᶜ := by\n  simp_rw [← isAtom_compl, Finset.isAtom_iff, compl_eq_iff_isCompl, eq_compl_iff_isCompl]\n\n"}
{"name":"Finset.grade_multiset_eq","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (grade (Multiset α) s) s.val","decl":"@[simp] lemma grade_multiset_eq (s : Finset α) : grade (Multiset α) s = s.1 := rfl\n\n"}
{"name":"Finset.grade_eq","module":"Mathlib.Data.Finset.Grade","initialProofState":"α : Type u_1\ns : Finset α\n⊢ Eq (grade Nat s) s.card","decl":"@[simp] lemma grade_eq (s : Finset α) : grade ℕ s = s.card := rfl\n\n"}
