{"name":"functionField_iff","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁹ : Field Fq\ninst✝⁸ : Field F\nFqt : Type u_3\ninst✝⁷ : Field Fqt\ninst✝⁶ : Algebra (Polynomial Fq) Fqt\ninst✝⁵ : IsFractionRing (Polynomial Fq) Fqt\ninst✝⁴ : Algebra (RatFunc Fq) F\ninst✝³ : Algebra Fqt F\ninst✝² : Algebra (Polynomial Fq) F\ninst✝¹ : IsScalarTower (Polynomial Fq) Fqt F\ninst✝ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\n⊢ Iff (FunctionField Fq F) (FiniteDimensional Fqt F)","decl":"/-- `F` is a function field over `Fq` iff it is a finite extension of `Fq(t)`. -/\ntheorem functionField_iff (Fqt : Type*) [Field Fqt] [Algebra Fq[X] Fqt]\n    [IsFractionRing Fq[X] Fqt] [Algebra (RatFunc Fq) F] [Algebra Fqt F] [Algebra Fq[X] F]\n    [IsScalarTower Fq[X] Fqt F] [IsScalarTower Fq[X] (RatFunc Fq) F] :\n    FunctionField Fq F ↔ FiniteDimensional Fqt F := by\n  let e := IsLocalization.algEquiv Fq[X]⁰ (RatFunc Fq) Fqt\n  have : ∀ (c) (x : F), e c • x = c • x := by\n    intro c x\n    rw [Algebra.smul_def, Algebra.smul_def]\n    congr\n    refine congr_fun (f := fun c => algebraMap Fqt F (e c)) ?_ c -- Porting note: Added `(f := _)`\n    refine IsLocalization.ext (nonZeroDivisors Fq[X]) _ _ ?_ ?_ ?_ ?_ ?_ <;> intros <;>\n      simp only [map_one, map_mul, AlgEquiv.commutes, ← IsScalarTower.algebraMap_apply]\n  constructor <;> intro h\n  · let b := Module.finBasis (RatFunc Fq) F\n    exact FiniteDimensional.of_fintype_basis (b.mapCoeffs e this)\n  · let b := Module.finBasis Fqt F\n    refine FiniteDimensional.of_fintype_basis (b.mapCoeffs e.symm ?_)\n    intro c x; convert (this (e.symm c) x).symm; simp only [e.apply_symm_apply]\n\n"}
{"name":"algebraMap_injective","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁴ : Field Fq\ninst✝³ : Field F\ninst✝² : Algebra (Polynomial Fq) F\ninst✝¹ : Algebra (RatFunc Fq) F\ninst✝ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\n⊢ Function.Injective ⇑(algebraMap (Polynomial Fq) F)","decl":"theorem algebraMap_injective [Algebra Fq[X] F] [Algebra (RatFunc Fq) F]\n    [IsScalarTower Fq[X] (RatFunc Fq) F] : Function.Injective (⇑(algebraMap Fq[X] F)) := by\n  rw [IsScalarTower.algebraMap_eq Fq[X] (RatFunc Fq) F]\n  exact (algebraMap (RatFunc Fq) F).injective.comp (IsFractionRing.injective Fq[X] (RatFunc Fq))\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsDomainSubtypeMemSubalgebraPolynomial","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝² : Field Fq\ninst✝¹ : Field F\ninst✝ : Algebra (Polynomial Fq) F\n⊢ IsDomain (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x)","decl":"instance : IsDomain (ringOfIntegers Fq F) :=\n  (ringOfIntegers Fq F).isDomain\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsIntegralClosureSubtypeMemSubalgebraPolynomial","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝² : Field Fq\ninst✝¹ : Field F\ninst✝ : Algebra (Polynomial Fq) F\n⊢ IsIntegralClosure (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x) (Polynomial Fq) F","decl":"instance : IsIntegralClosure (ringOfIntegers Fq F) Fq[X] F :=\n  integralClosure.isIntegralClosure _ _\n\n"}
{"name":"FunctionField.ringOfIntegers.algebraMap_injective","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁴ : Field Fq\ninst✝³ : Field F\ninst✝² : Algebra (Polynomial Fq) F\ninst✝¹ : Algebra (RatFunc Fq) F\ninst✝ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\n⊢ Function.Injective ⇑(algebraMap (Polynomial Fq) (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x))","decl":"theorem algebraMap_injective : Function.Injective (⇑(algebraMap Fq[X] (ringOfIntegers Fq F))) := by\n  have hinj : Function.Injective (⇑(algebraMap Fq[X] F)) := by\n    rw [IsScalarTower.algebraMap_eq Fq[X] (RatFunc Fq) F]\n    exact (algebraMap (RatFunc Fq) F).injective.comp (IsFractionRing.injective Fq[X] (RatFunc Fq))\n  rw [injective_iff_map_eq_zero (algebraMap Fq[X] (↥(ringOfIntegers Fq F)))]\n  intro p hp\n  rw [← Subtype.coe_inj, Subalgebra.coe_zero] at hp\n  rw [injective_iff_map_eq_zero (algebraMap Fq[X] F)] at hinj\n  exact hinj p hp\n\n"}
{"name":"FunctionField.ringOfIntegers.not_isField","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁴ : Field Fq\ninst✝³ : Field F\ninst✝² : Algebra (Polynomial Fq) F\ninst✝¹ : Algebra (RatFunc Fq) F\ninst✝ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\n⊢ Not (IsField (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x))","decl":"theorem not_isField : ¬IsField (ringOfIntegers Fq F) := by\n  simpa [← (IsIntegralClosure.isIntegral_algebra Fq[X] F).isField_iff_isField\n      (algebraMap_injective Fq F)] using\n    Polynomial.not_isField Fq\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsFractionRingSubtypeMemSubalgebraPolynomial","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁵ : Field Fq\ninst✝⁴ : Field F\ninst✝³ : Algebra (Polynomial Fq) F\ninst✝² : Algebra (RatFunc Fq) F\ninst✝¹ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\ninst✝ : FunctionField Fq F\n⊢ IsFractionRing (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x) F","decl":"instance : IsFractionRing (ringOfIntegers Fq F) F :=\n  integralClosure.isFractionRing_of_finite_extension (RatFunc Fq) F\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsIntegrallyClosedSubtypeMemSubalgebraPolynomial","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁵ : Field Fq\ninst✝⁴ : Field F\ninst✝³ : Algebra (Polynomial Fq) F\ninst✝² : Algebra (RatFunc Fq) F\ninst✝¹ : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\ninst✝ : FunctionField Fq F\n⊢ IsIntegrallyClosed (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x)","decl":"instance : IsIntegrallyClosed (ringOfIntegers Fq F) :=\n  integralClosure.isIntegrallyClosedOfFiniteExtension (RatFunc Fq)\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsNoetherianPolynomialSubtypeMemSubalgebraOfIsSeparableRatFunc","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁶ : Field Fq\ninst✝⁵ : Field F\ninst✝⁴ : Algebra (Polynomial Fq) F\ninst✝³ : Algebra (RatFunc Fq) F\ninst✝² : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\ninst✝¹ : FunctionField Fq F\ninst✝ : Algebra.IsSeparable (RatFunc Fq) F\n⊢ IsNoetherian (Polynomial Fq) (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x)","decl":"instance [Algebra.IsSeparable (RatFunc Fq) F] : IsNoetherian Fq[X] (ringOfIntegers Fq F) :=\n  IsIntegralClosure.isNoetherian _ (RatFunc Fq) F _\n\n"}
{"name":"FunctionField.ringOfIntegers.instIsDedekindDomainSubtypeMemSubalgebraPolynomialOfIsSeparableRatFunc","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\nF : Type u_2\ninst✝⁶ : Field Fq\ninst✝⁵ : Field F\ninst✝⁴ : Algebra (Polynomial Fq) F\ninst✝³ : Algebra (RatFunc Fq) F\ninst✝² : IsScalarTower (Polynomial Fq) (RatFunc Fq) F\ninst✝¹ : FunctionField Fq F\ninst✝ : Algebra.IsSeparable (RatFunc Fq) F\n⊢ IsDedekindDomain (Subtype fun x => Membership.mem (FunctionField.ringOfIntegers Fq F) x)","decl":"instance [Algebra.IsSeparable (RatFunc Fq) F] : IsDedekindDomain (ringOfIntegers Fq F) :=\n  IsIntegralClosure.isDedekindDomain Fq[X] (RatFunc Fq) F _\n\n"}
{"name":"FunctionField.InftyValuation.map_zero'","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\n⊢ Eq (FunctionField.inftyValuationDef Fq 0) 0","decl":"theorem InftyValuation.map_zero' : inftyValuationDef Fq 0 = 0 :=\n  if_pos rfl\n\n"}
{"name":"FunctionField.InftyValuation.map_one'","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\n⊢ Eq (FunctionField.inftyValuationDef Fq 1) 1","decl":"theorem InftyValuation.map_one' : inftyValuationDef Fq 1 = 1 :=\n  (if_neg one_ne_zero).trans <| by rw [RatFunc.intDegree_one, ofAdd_zero, WithZero.coe_one]\n\n"}
{"name":"FunctionField.InftyValuation.map_mul'","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx y : RatFunc Fq\n⊢ Eq (FunctionField.inftyValuationDef Fq (HMul.hMul x y)) (HMul.hMul (FunctionField.inftyValuationDef Fq x) (FunctionField.inftyValuationDef Fq y))","decl":"theorem InftyValuation.map_mul' (x y : RatFunc Fq) :\n    inftyValuationDef Fq (x * y) = inftyValuationDef Fq x * inftyValuationDef Fq y := by\n  rw [inftyValuationDef, inftyValuationDef, inftyValuationDef]\n  by_cases hx : x = 0\n  · rw [hx, zero_mul, if_pos (Eq.refl _), zero_mul]\n  · by_cases hy : y = 0\n    · rw [hy, mul_zero, if_pos (Eq.refl _), mul_zero]\n    · rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ← WithZero.coe_mul, WithZero.coe_inj,\n        ← ofAdd_add, RatFunc.intDegree_mul hx hy]\n\n"}
{"name":"FunctionField.InftyValuation.map_add_le_max'","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx y : RatFunc Fq\n⊢ LE.le (FunctionField.inftyValuationDef Fq (HAdd.hAdd x y)) (Max.max (FunctionField.inftyValuationDef Fq x) (FunctionField.inftyValuationDef Fq y))","decl":"theorem InftyValuation.map_add_le_max' (x y : RatFunc Fq) :\n    inftyValuationDef Fq (x + y) ≤ max (inftyValuationDef Fq x) (inftyValuationDef Fq y) := by\n  by_cases hx : x = 0\n  · rw [hx, zero_add]\n    conv_rhs => rw [inftyValuationDef, if_pos (Eq.refl _)]\n    rw [max_eq_right (WithZero.zero_le (inftyValuationDef Fq y))]\n  · by_cases hy : y = 0\n    · rw [hy, add_zero]\n      conv_rhs => rw [max_comm, inftyValuationDef, if_pos (Eq.refl _)]\n      rw [max_eq_right (WithZero.zero_le (inftyValuationDef Fq x))]\n    · by_cases hxy : x + y = 0\n      · rw [inftyValuationDef, if_pos hxy]; exact zero_le'\n      · rw [inftyValuationDef, inftyValuationDef, inftyValuationDef, if_neg hx, if_neg hy,\n          if_neg hxy]\n        rw [le_max_iff, WithZero.coe_le_coe, Multiplicative.ofAdd_le, WithZero.coe_le_coe,\n          Multiplicative.ofAdd_le, ← le_max_iff]\n        exact RatFunc.intDegree_add_le hy hxy\n\n"}
{"name":"FunctionField.inftyValuation_of_nonzero","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx : RatFunc Fq\nhx : Ne x 0\n⊢ Eq (FunctionField.inftyValuationDef Fq x) ↑(Multiplicative.ofAdd x.intDegree)","decl":"@[simp]\ntheorem inftyValuation_of_nonzero {x : RatFunc Fq} (hx : x ≠ 0) :\n    inftyValuationDef Fq x = Multiplicative.ofAdd x.intDegree := by\n  rw [inftyValuationDef, if_neg hx]\n\n"}
{"name":"FunctionField.inftyValuation_apply","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx : RatFunc Fq\n⊢ Eq ((FunctionField.inftyValuation Fq) x) (FunctionField.inftyValuationDef Fq x)","decl":"@[simp]\ntheorem inftyValuation_apply {x : RatFunc Fq} : inftyValuation Fq x = inftyValuationDef Fq x :=\n  rfl\n\n"}
{"name":"FunctionField.inftyValuation.C","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nk : Fq\nhk : Ne k 0\n⊢ Eq (FunctionField.inftyValuationDef Fq (RatFunc.C k)) ↑(Multiplicative.ofAdd 0)","decl":"@[simp]\ntheorem inftyValuation.C {k : Fq} (hk : k ≠ 0) :\n    inftyValuationDef Fq (RatFunc.C k) = Multiplicative.ofAdd (0 : ℤ) := by\n  have hCk : RatFunc.C k ≠ 0 := (map_ne_zero _).mpr hk\n  rw [inftyValuationDef, if_neg hCk, RatFunc.intDegree_C]\n\n"}
{"name":"FunctionField.inftyValuation.X","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\n⊢ Eq (FunctionField.inftyValuationDef Fq RatFunc.X) ↑(Multiplicative.ofAdd 1)","decl":"@[simp]\ntheorem inftyValuation.X : inftyValuationDef Fq RatFunc.X = Multiplicative.ofAdd (1 : ℤ) := by\n  rw [inftyValuationDef, if_neg RatFunc.X_ne_zero, RatFunc.intDegree_X]\n\n"}
{"name":"FunctionField.inftyValuation.polynomial","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\np : Polynomial Fq\nhp : Ne p 0\n⊢ Eq (FunctionField.inftyValuationDef Fq ((algebraMap (Polynomial Fq) (RatFunc Fq)) p)) ↑(Multiplicative.ofAdd ↑p.natDegree)","decl":"@[simp]\ntheorem inftyValuation.polynomial {p : Fq[X]} (hp : p ≠ 0) :\n    inftyValuationDef Fq (algebraMap Fq[X] (RatFunc Fq) p) =\n      Multiplicative.ofAdd (p.natDegree : ℤ) := by\n  have hp' : algebraMap Fq[X] (RatFunc Fq) p ≠ 0 := by\n    rw [Ne, NoZeroSMulDivisors.algebraMap_eq_zero_iff]; exact hp\n  rw [inftyValuationDef, if_neg hp', RatFunc.intDegree_polynomial]\n\n"}
{"name":"FunctionField.inftyValuedFqt.def","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx : RatFunc Fq\n⊢ Eq (Valued.v x) (FunctionField.inftyValuationDef Fq x)","decl":"theorem inftyValuedFqt.def {x : RatFunc Fq} :\n    @Valued.v (RatFunc Fq) _ _ _ (inftyValuedFqt Fq) x = inftyValuationDef Fq x :=\n  rfl\n\n"}
{"name":"FunctionField.valuedFqtInfty.def","module":"Mathlib.NumberTheory.FunctionField","initialProofState":"Fq : Type u_1\ninst✝¹ : Field Fq\ninst✝ : DecidableEq (RatFunc Fq)\nx : FunctionField.FqtInfty Fq\n⊢ Eq (Valued.v x) (Valued.extension x)","decl":"theorem valuedFqtInfty.def {x : FqtInfty Fq} :\n    Valued.v x = @Valued.extension (RatFunc Fq) _ _ _ (inftyValuedFqt Fq) x :=\n  rfl\n\n"}
