{"name":"AddConstEquiv.mk.inj","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ntoEquiv✝ : Equiv G H\nmap_add_const'✝ : ∀ (x : G), Eq (toEquiv✝.toFun (HAdd.hAdd x a)) (HAdd.hAdd (toEquiv✝.toFun x) b)\ntoEquiv : Equiv G H\nmap_add_const' : ∀ (x : G), Eq (toEquiv.toFun (HAdd.hAdd x a)) (HAdd.hAdd (toEquiv.toFun x) b)\nx✝ : Eq { toEquiv := toEquiv✝, map_add_const' := map_add_const'✝ } { toEquiv := toEquiv, map_add_const' := map_add_const' }\n⊢ Eq toEquiv✝ toEquiv","decl":"/-- An equivalence between `G` and `H` conjugating `(· + a)` to `(· + b)`,\ndenoted as `G ≃+c[a, b] H`. -/\nstructure AddConstEquiv (G H : Type*) [Add G] [Add H] (a : G) (b : H)\n  extends G ≃ H, G →+c[a, b] H\n\n"}
{"name":"AddConstEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝³ : Add G\ninst✝² : Add H\na : G\nb : H\ninst✝¹ : SizeOf G\ninst✝ : SizeOf H\ntoEquiv : Equiv G H\nmap_add_const' : ∀ (x : G), Eq (toEquiv.toFun (HAdd.hAdd x a)) (HAdd.hAdd (toEquiv.toFun x) b)\n⊢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, map_add_const' := map_add_const' }) (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv))","decl":"/-- An equivalence between `G` and `H` conjugating `(· + a)` to `(· + b)`,\ndenoted as `G ≃+c[a, b] H`. -/\nstructure AddConstEquiv (G H : Type*) [Add G] [Add H] (a : G) (b : H)\n  extends G ≃ H, G →+c[a, b] H\n\n"}
{"name":"AddConstEquiv.mk.injEq","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ntoEquiv✝ : Equiv G H\nmap_add_const'✝ : ∀ (x : G), Eq (toEquiv✝.toFun (HAdd.hAdd x a)) (HAdd.hAdd (toEquiv✝.toFun x) b)\ntoEquiv : Equiv G H\nmap_add_const' : ∀ (x : G), Eq (toEquiv.toFun (HAdd.hAdd x a)) (HAdd.hAdd (toEquiv.toFun x) b)\n⊢ Eq (Eq { toEquiv := toEquiv✝, map_add_const' := map_add_const'✝ } { toEquiv := toEquiv, map_add_const' := map_add_const' }) (Eq toEquiv✝ toEquiv)","decl":"/-- An equivalence between `G` and `H` conjugating `(· + a)` to `(· + b)`,\ndenoted as `G ≃+c[a, b] H`. -/\nstructure AddConstEquiv (G H : Type*) [Add G] [Add H] (a : G) (b : H)\n  extends G ≃ H, G →+c[a, b] H\n\n"}
{"name":"AddConstEquiv.map_add_const'","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\nself : AddConstEquiv G H a b\nx : G\n⊢ Eq (self.toFun (HAdd.hAdd x a)) (HAdd.hAdd (self.toFun x) b)","decl":"/-- An equivalence between `G` and `H` conjugating `(· + a)` to `(· + b)`,\ndenoted as `G ≃+c[a, b] H`. -/\nstructure AddConstEquiv (G H : Type*) [Add G] [Add H] (a : G) (b : H)\n  extends G ≃ H, G →+c[a, b] H\n\n"}
{"name":"AddConstEquiv.toEquiv_injective","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\n⊢ Function.Injective AddConstEquiv.toEquiv","decl":"lemma toEquiv_injective : Injective (toEquiv : (G ≃+c[a, b] H) → G ≃ H)\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"AddConstEquiv.instAddConstMapClass","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_4\nH : Type u_5\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\n⊢ AddConstMapClass (AddConstEquiv G H a b) G H a b","decl":"instance {G H : Type*} [Add G] [Add H] {a : G} {b : H} :\n    AddConstMapClass (G ≃+c[a, b] H) G H a b where\n  map_add_const f x := f.map_add_const' x\n\n"}
{"name":"AddConstEquiv.ext_iff","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne₁ e₂ : AddConstEquiv G H a b\n⊢ Iff (Eq e₁ e₂) (∀ (x : G), Eq (e₁ x) (e₂ x))","decl":"@[ext] lemma ext {e₁ e₂ : G ≃+c[a, b] H} (h : ∀ x, e₁ x = e₂ x) : e₁ = e₂ := DFunLike.ext _ _ h\n\n"}
{"name":"AddConstEquiv.ext","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne₁ e₂ : AddConstEquiv G H a b\nh : ∀ (x : G), Eq (e₁ x) (e₂ x)\n⊢ Eq e₁ e₂","decl":"@[ext] lemma ext {e₁ e₂ : G ≃+c[a, b] H} (h : ∀ x, e₁ x = e₂ x) : e₁ = e₂ := DFunLike.ext _ _ h\n\n"}
{"name":"AddConstEquiv.toEquiv_inj","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne₁ e₂ : AddConstEquiv G H a b\n⊢ Iff (Eq e₁.toEquiv e₂.toEquiv) (Eq e₁ e₂)","decl":"@[simp]\nlemma toEquiv_inj {e₁ e₂ : G ≃+c[a, b] H} : e₁.toEquiv = e₂.toEquiv ↔ e₁ = e₂ :=\n  toEquiv_injective.eq_iff\n\n"}
{"name":"AddConstEquiv.coe_toEquiv","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq ⇑e.toEquiv ⇑e","decl":"@[simp] lemma coe_toEquiv (e : G ≃+c[a, b] H) : ⇑e.toEquiv = e := rfl\n\n"}
{"name":"AddConstEquiv.symm_symm","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq e.symm.symm e","decl":"@[simp] lemma symm_symm (e : G ≃+c[a, b] H) : e.symm.symm = e := rfl\n\n"}
{"name":"AddConstEquiv.refl_toEquiv","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq (AddConstEquiv.refl a).toEquiv (Equiv.refl G)","decl":"/-- The identity map as an `AddConstEquiv`. -/\n@[simps! toEquiv apply]\ndef refl (a : G) : G ≃+c[a, a] G where\n  toEquiv := .refl G\n  map_add_const' _ := rfl\n\n"}
{"name":"AddConstEquiv.refl_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na✝ a : G\n⊢ Eq ((AddConstEquiv.refl a✝) a) a","decl":"/-- The identity map as an `AddConstEquiv`. -/\n@[simps! toEquiv apply]\ndef refl (a : G) : G ≃+c[a, a] G where\n  toEquiv := .refl G\n  map_add_const' _ := rfl\n\n"}
{"name":"AddConstEquiv.symm_refl","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\n⊢ Eq (AddConstEquiv.refl a).symm (AddConstEquiv.refl a)","decl":"@[simp] lemma symm_refl (a : G) : (refl a).symm = refl a := rfl\n\n"}
{"name":"AddConstEquiv.trans_toEquiv","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\nK : Type u_3\ninst✝² : Add G\ninst✝¹ : Add H\ninst✝ : Add K\na : G\nb : H\nc : K\ne₁ : AddConstEquiv G H a b\ne₂ : AddConstEquiv H K b c\n⊢ Eq (e₁.trans e₂).toEquiv (e₁.trans e₂.toEquiv)","decl":"/-- Composition of `AddConstEquiv`s, as an `AddConstEquiv`. -/\n@[simps! (config := { simpRhs := true }) toEquiv apply]\ndef trans (e₁ : G ≃+c[a, b] H) (e₂ : H ≃+c[b, c] K) : G ≃+c[a, c] K where\n  toEquiv := e₁.toEquiv.trans e₂.toEquiv\n  map_add_const' := (AddConstMapClass.semiconj e₁).trans (AddConstMapClass.semiconj e₂)\n\n"}
{"name":"AddConstEquiv.trans_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\nK : Type u_3\ninst✝² : Add G\ninst✝¹ : Add H\ninst✝ : Add K\na : G\nb : H\nc : K\ne₁ : AddConstEquiv G H a b\ne₂ : AddConstEquiv H K b c\na✝ : G\n⊢ Eq ((e₁.trans e₂) a✝) (e₂ (e₁ a✝))","decl":"/-- Composition of `AddConstEquiv`s, as an `AddConstEquiv`. -/\n@[simps! (config := { simpRhs := true }) toEquiv apply]\ndef trans (e₁ : G ≃+c[a, b] H) (e₂ : H ≃+c[b, c] K) : G ≃+c[a, c] K where\n  toEquiv := e₁.toEquiv.trans e₂.toEquiv\n  map_add_const' := (AddConstMapClass.semiconj e₁).trans (AddConstMapClass.semiconj e₂)\n\n"}
{"name":"AddConstEquiv.trans_refl","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq (e.trans (AddConstEquiv.refl b)) e","decl":"@[simp] lemma trans_refl (e : G ≃+c[a, b] H) : e.trans (.refl b) = e := rfl\n"}
{"name":"AddConstEquiv.refl_trans","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq ((AddConstEquiv.refl a).trans e) e","decl":"@[simp] lemma refl_trans (e : G ≃+c[a, b] H) : (refl a).trans e = e := rfl\n\n"}
{"name":"AddConstEquiv.self_trans_symm","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq (e.trans e.symm) (AddConstEquiv.refl a)","decl":"@[simp]\nlemma self_trans_symm (e : G ≃+c[a, b] H) : e.trans e.symm = .refl a :=\n  toEquiv_injective e.toEquiv.self_trans_symm\n\n"}
{"name":"AddConstEquiv.symm_trans_self","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Add G\ninst✝ : Add H\na : G\nb : H\ne : AddConstEquiv G H a b\n⊢ Eq (e.symm.trans e) (AddConstEquiv.refl b)","decl":"@[simp]\nlemma symm_trans_self (e : G ≃+c[a, b] H) : e.symm.trans e = .refl b :=\n  toEquiv_injective e.toEquiv.symm_trans_self\n\n"}
{"name":"AddConstEquiv.toPerm_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nself : AddConstEquiv G G a a\n⊢ Eq (AddConstEquiv.toPerm self) self.toEquiv","decl":"/-- Projection from `G ≃+c[a, a] G` to permutations `G ≃ G`, as a monoid homomorphism. -/\n@[simps! apply]\ndef toPerm : (G ≃+c[a, a] G) →* Equiv.Perm G :=\n  .mk' toEquiv fun _ _ ↦ rfl\n\n"}
{"name":"AddConstEquiv.toAddConstMapHom_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nself : AddConstEquiv G G a a\n⊢ Eq (AddConstEquiv.toAddConstMapHom self) self.toAddConstMap","decl":"/-- Projection from `G ≃+c[a, a] G` to `G →+c[a, a] G`, as a monoid homomorphism. -/\n@[simps! apply]\ndef toAddConstMapHom : (G ≃+c[a, a] G) →* (G →+c[a, a] G) where\n  toFun := toAddConstMap\n  map_mul' _ _ := rfl\n  map_one' := rfl\n\n"}
{"name":"AddConstEquiv.coe_val_equivUnits_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na✝¹ : G\na : AddConstEquiv G G a✝¹ a✝¹\na✝ : G\n⊢ Eq (↑(AddConstEquiv.equivUnits a) a✝) (a a✝)","decl":"/-- Group equivalence between `G ≃+c[a, a] G` and the units of `G →+c[a, a] G`. -/\n@[simps!]\ndef equivUnits : (G ≃+c[a, a] G) ≃* (G →+c[a, a] G)ˣ where\n  toFun := toAddConstMapHom.toHomUnits\n  invFun u :=\n    { toEquiv := Equiv.Perm.equivUnitsEnd.symm <| Units.map AddConstMap.toEnd u\n      map_add_const' := u.1.2 }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddConstEquiv.equivUnits_symm_apply_symm_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nu : Units (AddConstMap G G a a)\n⊢ Eq ⇑(AddConstEquiv.equivUnits.symm u).symm ⇑↑(Inv.inv u)","decl":"/-- Group equivalence between `G ≃+c[a, a] G` and the units of `G →+c[a, a] G`. -/\n@[simps!]\ndef equivUnits : (G ≃+c[a, a] G) ≃* (G →+c[a, a] G)ˣ where\n  toFun := toAddConstMapHom.toHomUnits\n  invFun u :=\n    { toEquiv := Equiv.Perm.equivUnitsEnd.symm <| Units.map AddConstMap.toEnd u\n      map_add_const' := u.1.2 }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddConstEquiv.equivUnits_symm_apply_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na : G\nu : Units (AddConstMap G G a a)\n⊢ Eq ⇑(AddConstEquiv.equivUnits.symm u) ⇑↑u","decl":"/-- Group equivalence between `G ≃+c[a, a] G` and the units of `G →+c[a, a] G`. -/\n@[simps!]\ndef equivUnits : (G ≃+c[a, a] G) ≃* (G →+c[a, a] G)ˣ where\n  toFun := toAddConstMapHom.toHomUnits\n  invFun u :=\n    { toEquiv := Equiv.Perm.equivUnitsEnd.symm <| Units.map AddConstMap.toEnd u\n      map_add_const' := u.1.2 }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddConstEquiv.coe_val_inv_equivUnits_apply","module":"Mathlib.Algebra.AddConstMap.Equiv","initialProofState":"G : Type u_1\ninst✝ : Add G\na✝¹ : G\na : AddConstEquiv G G a✝¹ a✝¹\na✝ : G\n⊢ Eq (↑(Inv.inv (AddConstEquiv.equivUnits a)) a✝) ((Inv.inv a) a✝)","decl":"/-- Group equivalence between `G ≃+c[a, a] G` and the units of `G →+c[a, a] G`. -/\n@[simps!]\ndef equivUnits : (G ≃+c[a, a] G) ≃* (G →+c[a, a] G)ˣ where\n  toFun := toAddConstMapHom.toHomUnits\n  invFun u :=\n    { toEquiv := Equiv.Perm.equivUnitsEnd.symm <| Units.map AddConstMap.toEnd u\n      map_add_const' := u.1.2 }\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
