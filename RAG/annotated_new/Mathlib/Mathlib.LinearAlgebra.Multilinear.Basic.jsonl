{"name":"MultilinearMap.map_update_smul'","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nself : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (self.toFun (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (self.toFun (Function.update m i x)))","decl":"set_option genInjectivity false in\n/-- Multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂` are modules\nover `R`. -/\nstructure MultilinearMap (R : Type uR) {ι : Type uι} (M₁ : ι → Type v₁) (M₂ : Type v₂) [Semiring R]\n  [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂] where\n  /-- The underlying multivariate function of a multilinear map. -/\n  toFun : (∀ i, M₁ i) → M₂\n  /-- A multilinear map is additive in every argument. -/\n  map_update_add' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i),\n      toFun (update m i (x + y)) = toFun (update m i x) + toFun (update m i y)\n  /-- A multilinear map is compatible with scalar multiplication in every argument. -/\n  map_update_smul' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i),\n      toFun (update m i (c • x)) = c • toFun (update m i x)\n\n"}
{"name":"MultilinearMap.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : SizeOf R\ninst✝² : SizeOf ι\ninst✝¹ : (a : ι) → SizeOf (M₁ a)\ninst✝ : SizeOf M₂\ntoFun : ((i : ι) → M₁ i) → M₂\nmap_update_add' : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (x y : M₁ i), Eq (toFun (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (toFun (Function.update m i x)) (toFun (Function.update m i y)))\nmap_update_smul' : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (c : R) (x : M₁ i), Eq (toFun (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (toFun (Function.update m i x)))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_update_add' := map_update_add', map_update_smul' := map_update_smul' }) 1","decl":"set_option genInjectivity false in\n/-- Multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂` are modules\nover `R`. -/\nstructure MultilinearMap (R : Type uR) {ι : Type uι} (M₁ : ι → Type v₁) (M₂ : Type v₂) [Semiring R]\n  [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂] where\n  /-- The underlying multivariate function of a multilinear map. -/\n  toFun : (∀ i, M₁ i) → M₂\n  /-- A multilinear map is additive in every argument. -/\n  map_update_add' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i),\n      toFun (update m i (x + y)) = toFun (update m i x) + toFun (update m i y)\n  /-- A multilinear map is compatible with scalar multiplication in every argument. -/\n  map_update_smul' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i),\n      toFun (update m i (c • x)) = c • toFun (update m i x)\n\n"}
{"name":"MultilinearMap.map_update_add'","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nself : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (self.toFun (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (self.toFun (Function.update m i x)) (self.toFun (Function.update m i y)))","decl":"set_option genInjectivity false in\n/-- Multilinear maps over the ring `R`, from `∀ i, M₁ i` to `M₂` where `M₁ i` and `M₂` are modules\nover `R`. -/\nstructure MultilinearMap (R : Type uR) {ι : Type uι} (M₁ : ι → Type v₁) (M₂ : Type v₂) [Semiring R]\n  [∀ i, AddCommMonoid (M₁ i)] [AddCommMonoid M₂] [∀ i, Module R (M₁ i)] [Module R M₂] where\n  /-- The underlying multivariate function of a multilinear map. -/\n  toFun : (∀ i, M₁ i) → M₂\n  /-- A multilinear map is additive in every argument. -/\n  map_update_add' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i),\n      toFun (update m i (x + y)) = toFun (update m i x) + toFun (update m i y)\n  /-- A multilinear map is compatible with scalar multiplication in every argument. -/\n  map_update_smul' :\n    ∀ [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i),\n      toFun (update m i (c • x)) = c • toFun (update m i x)\n\n"}
{"name":"MultilinearMap.toFun_eq_coe","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe : f.toFun = ⇑f :=\n  rfl\n\n"}
{"name":"MultilinearMap.coe_mk","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : ((i : ι) → M₁ i) → M₂\nh₁ : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (x y : M₁ i), Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))\nh₂ : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (c : R) (x : M₁ i), Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))\n⊢ Eq (⇑{ toFun := f, map_update_add' := h₁, map_update_smul' := h₂ }) f","decl":"@[simp]\ntheorem coe_mk (f : (∀ i, M₁ i) → M₂) (h₁ h₂) : ⇑(⟨f, h₁, h₂⟩ : MultilinearMap R M₁ M₂) = f :=\n  rfl\n\n"}
{"name":"MultilinearMap.congr_fun","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf g : MultilinearMap R M₁ M₂\nh : Eq f g\nx : (i : ι) → M₁ i\n⊢ Eq (f x) (g x)","decl":"theorem congr_fun {f g : MultilinearMap R M₁ M₂} (h : f = g) (x : ∀ i, M₁ i) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"MultilinearMap.congr_arg","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\nx y : (i : ι) → M₁ i\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"nonrec theorem congr_arg (f : MultilinearMap R M₁ M₂) {x y : ∀ i, M₁ i} (h : x = y) : f x = f y :=\n  DFunLike.congr_arg f h\n\n"}
{"name":"MultilinearMap.coe_injective","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\n⊢ Function.Injective DFunLike.coe","decl":"theorem coe_injective : Injective ((↑) : MultilinearMap R M₁ M₂ → (∀ i, M₁ i) → M₂) :=\n  DFunLike.coe_injective\n\n"}
{"name":"MultilinearMap.coe_inj","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf g : MultilinearMap R M₁ M₂\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"@[norm_cast]\ntheorem coe_inj {f g : MultilinearMap R M₁ M₂} : (f : (∀ i, M₁ i) → M₂) = g ↔ f = g :=\n  DFunLike.coe_fn_eq\n\n"}
{"name":"MultilinearMap.ext","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf f' : MultilinearMap R M₁ M₂\nH : ∀ (x : (i : ι) → M₁ i), Eq (f x) (f' x)\n⊢ Eq f f'","decl":"@[ext]\ntheorem ext {f f' : MultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"MultilinearMap.ext_iff","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf f' : MultilinearMap R M₁ M₂\n⊢ Iff (Eq f f') (∀ (x : (i : ι) → M₁ i), Eq (f x) (f' x))","decl":"@[ext]\ntheorem ext {f f' : MultilinearMap R M₁ M₂} (H : ∀ x, f x = f' x) : f = f' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"MultilinearMap.mk_coe","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\nh₁ : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (x y : M₁ i), Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))\nh₂ : ∀ [inst : DecidableEq ι] (m : (i : ι) → M₁ i) (i : ι) (c : R) (x : M₁ i), Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))\n⊢ Eq { toFun := ⇑f, map_update_add' := h₁, map_update_smul' := h₂ } f","decl":"@[simp]\ntheorem mk_coe (f : MultilinearMap R M₁ M₂) (h₁ h₂) :\n    (⟨f, h₁, h₂⟩ : MultilinearMap R M₁ M₂) = f := rfl\n\n"}
{"name":"MultilinearMap.map_update_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\nprotected theorem map_update_add [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x + y)) = f (update m i x) + f (update m i y) :=\n  f.map_update_add' m i x y\n\n"}
{"name":"MultilinearMap.map_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_add := MultilinearMap.map_update_add\n"}
{"name":"MultilinearMap.map_add'","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HAdd.hAdd x y))) (HAdd.hAdd (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_add' := MultilinearMap.map_update_add\n\n"}
{"name":"MultilinearMap.map_update_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"/-- Earlier, this name was used by what is now called `MultilinearMap.map_update_smul_left`. -/\n@[simp]\nprotected theorem map_update_smul [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update m i (c • x)) = c • f (update m i x) :=\n  f.map_update_smul' m i c x\n\n"}
{"name":"MultilinearMap.map_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_smul := MultilinearMap.map_update_smul\n"}
{"name":"MultilinearMap.map_smul'","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update m i (HSMul.hSMul c x))) (HSMul.hSMul c (f (Function.update m i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_smul' := MultilinearMap.map_update_smul\n\n"}
{"name":"MultilinearMap.map_coord_zero","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\ni : ι\nh : Eq (m i) 0\n⊢ Eq (f m) 0","decl":"theorem map_coord_zero {m : ∀ i, M₁ i} (i : ι) (h : m i = 0) : f m = 0 := by\n  classical\n    have : (0 : R) • (0 : M₁ i) = 0 := by simp\n    rw [← update_eq_self i m, h, ← this, f.map_update_smul, zero_smul R (M := M₂)]\n\n"}
{"name":"MultilinearMap.map_update_zero","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\n⊢ Eq (f (Function.update m i 0)) 0","decl":"@[simp]\ntheorem map_update_zero [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) : f (update m i 0) = 0 :=\n  f.map_coord_zero i (update_self i 0 m)\n\n"}
{"name":"MultilinearMap.map_zero","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : Nonempty ι\n⊢ Eq (f 0) 0","decl":"@[simp]\ntheorem map_zero [Nonempty ι] : f 0 = 0 := by\n  obtain ⟨i, _⟩ : ∃ i : ι, i ∈ Set.univ := Set.exists_mem_of_nonempty ι\n  exact map_coord_zero f i rfl\n\n"}
{"name":"MultilinearMap.add_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf f' : MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((HAdd.hAdd f f') m) (HAdd.hAdd (f m) (f' m))","decl":"@[simp]\ntheorem add_apply (m : ∀ i, M₁ i) : (f + f') m = f m + f' m :=\n  rfl\n\n"}
{"name":"MultilinearMap.zero_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nm : (i : ι) → M₁ i\n⊢ Eq (0 m) 0","decl":"@[simp]\ntheorem zero_apply (m : ∀ i, M₁ i) : (0 : MultilinearMap R M₁ M₂) m = 0 :=\n  rfl\n\n"}
{"name":"MultilinearMap.smul_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : DistribSMul S M₂\ninst✝ : SMulCommClass R S M₂\nf : MultilinearMap R M₁ M₂\nc : S\nm : (i : ι) → M₁ i\n⊢ Eq ((HSMul.hSMul c f) m) (HSMul.hSMul c (f m))","decl":"@[simp]\ntheorem smul_apply (f : MultilinearMap R M₁ M₂) (c : S) (m : ∀ i, M₁ i) : (c • f) m = c • f m :=\n  rfl\n\n"}
{"name":"MultilinearMap.coe_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : DistribSMul S M₂\ninst✝ : SMulCommClass R S M₂\nc : S\nf : MultilinearMap R M₁ M₂\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"theorem coe_smul (c : S) (f : MultilinearMap R M₁ M₂) : ⇑(c • f) = c • (⇑ f) := rfl\n\n"}
{"name":"MultilinearMap.coeAddMonoidHom_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\na✝ : MultilinearMap R M₁ M₂\na : (i : ι) → M₁ i\n⊢ Eq (MultilinearMap.coeAddMonoidHom a✝ a) (a✝ a)","decl":"/-- Coercion of a multilinear map to a function as an additive monoid homomorphism. -/\n@[simps] def coeAddMonoidHom : MultilinearMap R M₁ M₂ →+ (((i : ι) → M₁ i) → M₂) where\n  toFun := DFunLike.coe; map_zero' := rfl; map_add' _ _ := rfl\n\n"}
{"name":"MultilinearMap.coe_sum","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nα : Type u_1\nf : α → MultilinearMap R M₁ M₂\ns : Finset α\n⊢ Eq (⇑(s.sum fun a => f a)) (s.sum fun a => ⇑(f a))","decl":"@[simp]\ntheorem coe_sum {α : Type*} (f : α → MultilinearMap R M₁ M₂) (s : Finset α) :\n    ⇑(∑ a ∈ s, f a) = ∑ a ∈ s, ⇑(f a) :=\n  map_sum coeAddMonoidHom f s\n\n"}
{"name":"MultilinearMap.sum_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nα : Type u_1\nf : α → MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\ns : Finset α\n⊢ Eq ((s.sum fun a => f a) m) (s.sum fun a => (f a) m)","decl":"theorem sum_apply {α : Type*} (f : α → MultilinearMap R M₁ M₂) (m : ∀ i, M₁ i) {s : Finset α} :\n    (∑ a ∈ s, f a) m = ∑ a ∈ s, f a m := by simp\n\n"}
{"name":"MultilinearMap.toLinearMap_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx : M₁ i\n⊢ Eq ((f.toLinearMap m i) x) (f (Function.update m i x))","decl":"/-- If `f` is a multilinear map, then `f.toLinearMap m i` is the linear map obtained by fixing all\ncoordinates but `i` equal to those of `m`, and varying the `i`-th coordinate. -/\n@[simps]\ndef toLinearMap [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) : M₁ i →ₗ[R] M₂ where\n  toFun x := f (update m i x)\n  map_add' x y := by simp\n  map_smul' c x := by simp\n\n"}
{"name":"MultilinearMap.prod_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : MultilinearMap R M₁ M₂\ng : MultilinearMap R M₁ M₃\nm : (i : ι) → M₁ i\n⊢ Eq ((f.prod g) m) { fst := f m, snd := g m }","decl":"/-- The cartesian product of two multilinear maps, as a multilinear map. -/\n@[simps]\ndef prod (f : MultilinearMap R M₁ M₂) (g : MultilinearMap R M₁ M₃) :\n    MultilinearMap R M₁ (M₂ × M₃) where\n  toFun m := (f m, g m)\n  map_update_add' m i x y := by simp\n  map_update_smul' m i c x := by simp\n\n"}
{"name":"MultilinearMap.pi_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : (i : ι) → Module R (M₁ i)\nι' : Type u_1\nM' : ι' → Type u_2\ninst✝¹ : (i : ι') → AddCommMonoid (M' i)\ninst✝ : (i : ι') → Module R (M' i)\nf : (i : ι') → MultilinearMap R M₁ (M' i)\nm : (i : ι) → M₁ i\ni : ι'\n⊢ Eq ((MultilinearMap.pi f) m i) ((f i) m)","decl":"/-- Combine a family of multilinear maps with the same domain and codomains `M' i` into a\nmultilinear map taking values in the space of functions `∀ i, M' i`. -/\n@[simps]\ndef pi {ι' : Type*} {M' : ι' → Type*} [∀ i, AddCommMonoid (M' i)] [∀ i, Module R (M' i)]\n    (f : ∀ i, MultilinearMap R M₁ (M' i)) : MultilinearMap R M₁ (∀ i, M' i) where\n  toFun m i := f i m\n  map_update_add' _ _ _ _ := funext fun j => (f j).map_update_add _ _ _ _\n  map_update_smul' _ _ _ _ := funext fun j => (f j).map_update_smul _ _ _ _\n\n"}
{"name":"MultilinearMap.ofSubsingleton_symm_apply_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Subsingleton ι\ni : ι\nf : MultilinearMap R (fun x => M₂) M₃\nx : M₂\n⊢ Eq (((MultilinearMap.ofSubsingleton R M₂ M₃ i).symm f) x) (f fun x_1 => x)","decl":"/-- Equivalence between linear maps `M₂ →ₗ[R] M₃` and one-multilinear maps. -/\n@[simps]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M₂ →ₗ[R] M₃) ≃ MultilinearMap R (fun _ : ι ↦ M₂) M₃ where\n  toFun f :=\n    { toFun := fun x ↦ f (x i)\n      map_update_add' := by intros; simp [update_eq_const_of_subsingleton]\n      map_update_smul' := by intros; simp [update_eq_const_of_subsingleton] }\n  invFun f :=\n    { toFun := fun x ↦ f fun _ ↦ x\n      map_add' := fun x y ↦ by\n        simpa [update_eq_const_of_subsingleton] using f.map_update_add 0 i x y\n      map_smul' := fun c x ↦ by\n        simpa [update_eq_const_of_subsingleton] using f.map_update_smul 0 i c x }\n  left_inv _ := rfl\n  right_inv f := by ext x; refine congr_arg f ?_; exact (eq_const_of_subsingleton _ _).symm\n\n"}
{"name":"MultilinearMap.ofSubsingleton_apply_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Subsingleton ι\ni : ι\nf : LinearMap (RingHom.id R) M₂ M₃\nx : ι → M₂\n⊢ Eq (((MultilinearMap.ofSubsingleton R M₂ M₃ i) f) x) (f (x i))","decl":"/-- Equivalence between linear maps `M₂ →ₗ[R] M₃` and one-multilinear maps. -/\n@[simps]\ndef ofSubsingleton [Subsingleton ι] (i : ι) :\n    (M₂ →ₗ[R] M₃) ≃ MultilinearMap R (fun _ : ι ↦ M₂) M₃ where\n  toFun f :=\n    { toFun := fun x ↦ f (x i)\n      map_update_add' := by intros; simp [update_eq_const_of_subsingleton]\n      map_update_smul' := by intros; simp [update_eq_const_of_subsingleton] }\n  invFun f :=\n    { toFun := fun x ↦ f fun _ ↦ x\n      map_add' := fun x y ↦ by\n        simpa [update_eq_const_of_subsingleton] using f.map_update_add 0 i x y\n      map_smul' := fun c x ↦ by\n        simpa [update_eq_const_of_subsingleton] using f.map_update_smul 0 i c x }\n  left_inv _ := rfl\n  right_inv f := by ext x; refine congr_arg f ?_; exact (eq_const_of_subsingleton _ _).symm\n\n"}
{"name":"MultilinearMap.constOfIsEmpty_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : IsEmpty ι\nm : M₂\n⊢ Eq (⇑(MultilinearMap.constOfIsEmpty R M₁ m)) (Function.const ((i : ι) → M₁ i) m)","decl":"/-- The constant map is multilinear when `ι` is empty. -/\n@[simps (config := .asFn)]\ndef constOfIsEmpty [IsEmpty ι] (m : M₂) : MultilinearMap R M₁ M₂ where\n  toFun := Function.const _ m\n  map_update_add' _ := isEmptyElim\n  map_update_smul' _ := isEmptyElim\n\n"}
{"name":"MultilinearMap.cons_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nm : (i : Fin n) → M i.succ\nx y : M 0\n⊢ Eq (f (Fin.cons (HAdd.hAdd x y) m)) (HAdd.hAdd (f (Fin.cons x m)) (f (Fin.cons y m)))","decl":"/-- In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `∀ (i : Fin (n+1)), M i` using `cons`, one can express directly the additivity of a\nmultilinear map along the first variable. -/\ntheorem cons_add (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (x y : M 0) :\n    f (cons (x + y) m) = f (cons x m) + f (cons y m) := by\n  simp_rw [← update_cons_zero x m (x + y), f.map_update_add, update_cons_zero]\n\n"}
{"name":"MultilinearMap.cons_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nm : (i : Fin n) → M i.succ\nc : R\nx : M 0\n⊢ Eq (f (Fin.cons (HSMul.hSMul c x) m)) (HSMul.hSMul c (f (Fin.cons x m)))","decl":"/-- In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `∀ (i : Fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. -/\ntheorem cons_smul (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M i.succ) (c : R) (x : M 0) :\n    f (cons (c • x) m) = c • f (cons x m) := by\n  simp_rw [← update_cons_zero x m (c • x), f.map_update_smul, update_cons_zero]\n\n"}
{"name":"MultilinearMap.snoc_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nm : (i : Fin n) → M i.castSucc\nx y : M (Fin.last n)\n⊢ Eq (f (Fin.snoc m (HAdd.hAdd x y))) (HAdd.hAdd (f (Fin.snoc m x)) (f (Fin.snoc m y)))","decl":"/-- In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `∀ (i : Fin (n+1)), M i` using `snoc`, one can express directly the additivity of a\nmultilinear map along the first variable. -/\ntheorem snoc_add (f : MultilinearMap R M M₂)\n    (m : ∀ i : Fin n, M (castSucc i)) (x y : M (last n)) :\n    f (snoc m (x + y)) = f (snoc m x) + f (snoc m y) := by\n  simp_rw [← update_snoc_last x m (x + y), f.map_update_add, update_snoc_last]\n\n"}
{"name":"MultilinearMap.snoc_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nm : (i : Fin n) → M i.castSucc\nc : R\nx : M (Fin.last n)\n⊢ Eq (f (Fin.snoc m (HSMul.hSMul c x))) (HSMul.hSMul c (f (Fin.snoc m x)))","decl":"/-- In the specific case of multilinear maps on spaces indexed by `Fin (n+1)`, where one can build\nan element of `∀ (i : Fin (n+1)), M i` using `cons`, one can express directly the multiplicativity\nof a multilinear map along the first variable. -/\ntheorem snoc_smul (f : MultilinearMap R M M₂) (m : ∀ i : Fin n, M (castSucc i)) (c : R)\n    (x : M (last n)) : f (snoc m (c • x)) = c • f (snoc m x) := by\n  simp_rw [← update_snoc_last x m (c • x), f.map_update_smul, update_snoc_last]\n\n"}
{"name":"MultilinearMap.compLinearMap_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\ng : MultilinearMap R M₁' M₂\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\nm : (i : ι) → M₁ i\n⊢ Eq ((g.compLinearMap f) m) (g fun i => (f i) (m i))","decl":"@[simp]\ntheorem compLinearMap_apply (g : MultilinearMap R M₁' M₂) (f : ∀ i, M₁ i →ₗ[R] M₁' i)\n    (m : ∀ i, M₁ i) : g.compLinearMap f m = g fun i => f i (m i) :=\n  rfl\n\n"}
{"name":"MultilinearMap.compLinearMap_assoc","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\nM₁' : ι → Type u_1\ninst✝³ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝² : (i : ι) → Module R (M₁' i)\nM₁'' : ι → Type u_2\ninst✝¹ : (i : ι) → AddCommMonoid (M₁'' i)\ninst✝ : (i : ι) → Module R (M₁'' i)\ng : MultilinearMap R M₁'' M₂\nf₁ : (i : ι) → LinearMap (RingHom.id R) (M₁' i) (M₁'' i)\nf₂ : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\n⊢ Eq ((g.compLinearMap f₁).compLinearMap f₂) (g.compLinearMap fun i => (f₁ i).comp (f₂ i))","decl":"/-- Composing a multilinear map twice with a linear map in each argument is\nthe same as composing with their composition. -/\ntheorem compLinearMap_assoc (g : MultilinearMap R M₁'' M₂) (f₁ : ∀ i, M₁' i →ₗ[R] M₁'' i)\n    (f₂ : ∀ i, M₁ i →ₗ[R] M₁' i) :\n    (g.compLinearMap f₁).compLinearMap f₂ = g.compLinearMap fun i => f₁ i ∘ₗ f₂ i :=\n  rfl\n\n"}
{"name":"MultilinearMap.zero_compLinearMap","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\n⊢ Eq (MultilinearMap.compLinearMap 0 f) 0","decl":"/-- Composing the zero multilinear map with a linear map in each argument. -/\n@[simp]\ntheorem zero_compLinearMap (f : ∀ i, M₁ i →ₗ[R] M₁' i) :\n    (0 : MultilinearMap R M₁' M₂).compLinearMap f = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"MultilinearMap.compLinearMap_id","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\ng : MultilinearMap R M₁' M₂\n⊢ Eq (g.compLinearMap fun x => LinearMap.id) g","decl":"/-- Composing a multilinear map with the identity linear map in each argument. -/\n@[simp]\ntheorem compLinearMap_id (g : MultilinearMap R M₁' M₂) :\n    (g.compLinearMap fun _ => LinearMap.id) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"MultilinearMap.compLinearMap_injective","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\nhf : ∀ (i : ι), Function.Surjective ⇑(f i)\n⊢ Function.Injective fun g => g.compLinearMap f","decl":"/-- Composing with a family of surjective linear maps is injective. -/\ntheorem compLinearMap_injective (f : ∀ i, M₁ i →ₗ[R] M₁' i) (hf : ∀ i, Surjective (f i)) :\n    Injective fun g : MultilinearMap R M₁' M₂ => g.compLinearMap f := fun g₁ g₂ h =>\n  ext fun x => by\n    simpa [fun i => surjInv_eq (hf i)]\n      using MultilinearMap.ext_iff.mp h fun i => surjInv (hf i) (x i)\n\n"}
{"name":"MultilinearMap.compLinearMap_inj","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\nhf : ∀ (i : ι), Function.Surjective ⇑(f i)\ng₁ g₂ : MultilinearMap R M₁' M₂\n⊢ Iff (Eq (g₁.compLinearMap f) (g₂.compLinearMap f)) (Eq g₁ g₂)","decl":"theorem compLinearMap_inj (f : ∀ i, M₁ i →ₗ[R] M₁' i) (hf : ∀ i, Surjective (f i))\n    (g₁ g₂ : MultilinearMap R M₁' M₂) : g₁.compLinearMap f = g₂.compLinearMap f ↔ g₁ = g₂ :=\n  (compLinearMap_injective _ hf).eq_iff\n\n"}
{"name":"MultilinearMap.comp_linearEquiv_eq_zero_iff","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\ng : MultilinearMap R M₁' M₂\nf : (i : ι) → LinearEquiv (RingHom.id R) (M₁ i) (M₁' i)\n⊢ Iff (Eq (g.compLinearMap fun i => ↑(f i)) 0) (Eq g 0)","decl":"/-- Composing a multilinear map with a linear equiv on each argument gives the zero map\nif and only if the multilinear map is the zero map. -/\n@[simp]\ntheorem comp_linearEquiv_eq_zero_iff (g : MultilinearMap R M₁' M₂) (f : ∀ i, M₁ i ≃ₗ[R] M₁' i) :\n    (g.compLinearMap fun i => (f i : M₁ i →ₗ[R] M₁' i)) = 0 ↔ g = 0 := by\n  set f' := fun i => (f i : M₁ i →ₗ[R] M₁' i)\n  rw [← zero_compLinearMap f', compLinearMap_inj f' fun i => (f i).surjective]\n\n"}
{"name":"MultilinearMap.map_piecewise_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm m' : (i : ι) → M₁ i\nt : Finset ι\n⊢ Eq (f (t.piecewise (HAdd.hAdd m m') m')) (t.powerset.sum fun s => f (s.piecewise m m'))","decl":"/-- If one adds to a vector `m'` another vector `m`, but only for coordinates in a finset `t`, then\nthe image under a multilinear map `f` is the sum of `f (s.piecewise m m')` along all subsets `s` of\n`t`. This is mainly an auxiliary statement to prove the result when `t = univ`, given in\n`map_add_univ`, although it can be useful in its own right as it does not require the index set `ι`\nto be finite. -/\ntheorem map_piecewise_add [DecidableEq ι] (m m' : ∀ i, M₁ i) (t : Finset ι) :\n    f (t.piecewise (m + m') m') = ∑ s ∈ t.powerset, f (s.piecewise m m') := by\n  revert m'\n  refine Finset.induction_on t (by simp) ?_\n  intro i t hit Hrec m'\n  have A : (insert i t).piecewise (m + m') m' = update (t.piecewise (m + m') m') i (m i + m' i) :=\n    t.piecewise_insert _ _ _\n  have B : update (t.piecewise (m + m') m') i (m' i) = t.piecewise (m + m') m' := by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [hit]\n    · simp [h]\n  let m'' := update m' i (m i)\n  have C : update (t.piecewise (m + m') m') i (m i) = t.piecewise (m + m'') m'' := by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [m'', hit]\n    · by_cases h' : j ∈ t <;> simp [m'', h, hit, h']\n  rw [A, f.map_update_add, B, C, Finset.sum_powerset_insert hit, Hrec, Hrec, add_comm (_ : M₂)]\n  congr 1\n  refine Finset.sum_congr rfl fun s hs => ?_\n  have : (insert i s).piecewise m m' = s.piecewise m m'' := by\n    ext j\n    by_cases h : j = i\n    · rw [h]\n      simp [m'', Finset.not_mem_of_mem_powerset_of_not_mem hs hit]\n    · by_cases h' : j ∈ s <;> simp [m'', h, h']\n  rw [this]\n\n"}
{"name":"MultilinearMap.map_add_univ","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm m' : (i : ι) → M₁ i\n⊢ Eq (f (HAdd.hAdd m m')) (Finset.univ.sum fun s => f (s.piecewise m m'))","decl":"/-- Additivity of a multilinear map along all coordinates at the same time,\nwriting `f (m + m')` as the sum of `f (s.piecewise m m')` over all sets `s`. -/\ntheorem map_add_univ [DecidableEq ι] [Fintype ι] (m m' : ∀ i, M₁ i) :\n    f (m + m') = ∑ s : Finset ι, f (s.piecewise m m') := by\n  simpa using f.map_piecewise_add m m' Finset.univ\n\n"}
{"name":"MultilinearMap.map_sum_finset_aux","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\nα : ι → Type u_1\ng : (i : ι) → α i → M₁ i\nA : (i : ι) → Finset (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nn : Nat\nh : Eq (Finset.univ.sum fun i => (A i).card) n\n⊢ Eq (f fun i => (A i).sum fun j => g i j) ((Fintype.piFinset A).sum fun r => f fun i => g i (r i))","decl":"/-- If `f` is multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. Here, we give an auxiliary statement tailored for an inductive proof. Use instead\n`map_sum_finset`. -/\ntheorem map_sum_finset_aux [DecidableEq ι] [Fintype ι] {n : ℕ} (h : (∑ i, #(A i)) = n) :\n    (f fun i => ∑ j ∈ A i, g i j) = ∑ r ∈ piFinset A, f fun i => g i (r i) := by\n  letI := fun i => Classical.decEq (α i)\n  induction' n using Nat.strong_induction_on with n IH generalizing A\n  -- If one of the sets is empty, then all the sums are zero\n  by_cases Ai_empty : ∃ i, A i = ∅\n  · obtain ⟨i, hi⟩ : ∃ i, ∑ j ∈ A i, g i j = 0 := Ai_empty.imp fun i hi ↦ by simp [hi]\n    have hpi : piFinset A = ∅ := by simpa\n    rw [f.map_coord_zero i hi, hpi, Finset.sum_empty]\n  push_neg at Ai_empty\n  -- Otherwise, if all sets are at most singletons, then they are exactly singletons and the result\n  -- is again straightforward\n  by_cases Ai_singleton : ∀ i, #(A i) ≤ 1\n  · have Ai_card : ∀ i, #(A i) = 1 := by\n      intro i\n      have pos : #(A i) ≠ 0 := by simp [Finset.card_eq_zero, Ai_empty i]\n      have : #(A i) ≤ 1 := Ai_singleton i\n      exact le_antisymm this (Nat.succ_le_of_lt (_root_.pos_iff_ne_zero.mpr pos))\n    have :\n      ∀ r : ∀ i, α i, r ∈ piFinset A → (f fun i => g i (r i)) = f fun i => ∑ j ∈ A i, g i j := by\n      intro r hr\n      congr with i\n      have : ∀ j ∈ A i, g i j = g i (r i) := by\n        intro j hj\n        congr\n        apply Finset.card_le_one_iff.1 (Ai_singleton i) hj\n        exact mem_piFinset.mp hr i\n      simp only [Finset.sum_congr rfl this, Finset.mem_univ, Finset.sum_const, Ai_card i, one_nsmul]\n    simp only [Finset.sum_congr rfl this, Ai_card, card_piFinset, prod_const_one, one_nsmul,\n      Finset.sum_const]\n  -- Remains the interesting case where one of the `A i`, say `A i₀`, has cardinality at least 2.\n  -- We will split into two parts `B i₀` and `C i₀` of smaller cardinality, let `B i = C i = A i`\n  -- for `i ≠ i₀`, apply the inductive assumption to `B` and `C`, and add up the corresponding\n  -- parts to get the sum for `A`.\n  push_neg at Ai_singleton\n  obtain ⟨i₀, hi₀⟩ : ∃ i, 1 < #(A i) := Ai_singleton\n  obtain ⟨j₁, j₂, _, hj₂, _⟩ : ∃ j₁ j₂, j₁ ∈ A i₀ ∧ j₂ ∈ A i₀ ∧ j₁ ≠ j₂ :=\n    Finset.one_lt_card_iff.1 hi₀\n  let B := Function.update A i₀ (A i₀ \\ {j₂})\n  let C := Function.update A i₀ {j₂}\n  have B_subset_A : ∀ i, B i ⊆ A i := by\n    intro i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [B, sdiff_subset, update_self]\n    · simp only [B, hi, update_of_ne, Ne, not_false_iff, Finset.Subset.refl]\n  have C_subset_A : ∀ i, C i ⊆ A i := by\n    intro i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [C, hj₂, Finset.singleton_subset_iff, update_self]\n    · simp only [C, hi, update_of_ne, Ne, not_false_iff, Finset.Subset.refl]\n  -- split the sum at `i₀` as the sum over `B i₀` plus the sum over `C i₀`, to use additivity.\n  have A_eq_BC :\n    (fun i => ∑ j ∈ A i, g i j) =\n      Function.update (fun i => ∑ j ∈ A i, g i j) i₀\n        ((∑ j ∈ B i₀, g i₀ j) + ∑ j ∈ C i₀, g i₀ j) := by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi, update_self]\n      have : A i₀ = B i₀ ∪ C i₀ := by\n        simp only [B, C, Function.update_self, Finset.sdiff_union_self_eq_union]\n        symm\n        simp only [hj₂, Finset.singleton_subset_iff, Finset.union_eq_left]\n      rw [this]\n      refine Finset.sum_union <| Finset.disjoint_right.2 fun j hj => ?_\n      have : j = j₂ := by\n        simpa [C] using hj\n      rw [this]\n      simp only [B, mem_sdiff, eq_self_iff_true, not_true, not_false_iff, Finset.mem_singleton,\n        update_self, and_false]\n    · simp [hi]\n  have Beq :\n    Function.update (fun i => ∑ j ∈ A i, g i j) i₀ (∑ j ∈ B i₀, g i₀ j) = fun i =>\n      ∑ j ∈ B i, g i j := by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [update_self]\n    · simp only [B, hi, update_of_ne, Ne, not_false_iff]\n  have Ceq :\n    Function.update (fun i => ∑ j ∈ A i, g i j) i₀ (∑ j ∈ C i₀, g i₀ j) = fun i =>\n      ∑ j ∈ C i, g i j := by\n    ext i\n    by_cases hi : i = i₀\n    · rw [hi]\n      simp only [update_self]\n    · simp only [C, hi, update_of_ne, Ne, not_false_iff]\n  -- Express the inductive assumption for `B`\n  have Brec : (f fun i => ∑ j ∈ B i, g i j) = ∑ r ∈ piFinset B, f fun i => g i (r i) := by\n    have : ∑ i, #(B i) < ∑ i, #(A i) := by\n      refine sum_lt_sum (fun i _ => card_le_card (B_subset_A i)) ⟨i₀, mem_univ _, ?_⟩\n      have : {j₂} ⊆ A i₀ := by simp [hj₂]\n      simp only [B, Finset.card_sdiff this, Function.update_self, Finset.card_singleton]\n      exact Nat.pred_lt (ne_of_gt (lt_trans Nat.zero_lt_one hi₀))\n    rw [h] at this\n    exact IH _ this B rfl\n  -- Express the inductive assumption for `C`\n  have Crec : (f fun i => ∑ j ∈ C i, g i j) = ∑ r ∈ piFinset C, f fun i => g i (r i) := by\n    have : (∑ i, #(C i)) < ∑ i, #(A i) :=\n      Finset.sum_lt_sum (fun i _ => Finset.card_le_card (C_subset_A i))\n        ⟨i₀, Finset.mem_univ _, by simp [C, hi₀]⟩\n    rw [h] at this\n    exact IH _ this C rfl\n  have D : Disjoint (piFinset B) (piFinset C) :=\n    haveI : Disjoint (B i₀) (C i₀) := by simp [B, C]\n    piFinset_disjoint_of_disjoint B C this\n  have pi_BC : piFinset A = piFinset B ∪ piFinset C := by\n    apply Finset.Subset.antisymm\n    · intro r hr\n      by_cases hri₀ : r i₀ = j₂\n      · apply Finset.mem_union_right\n        refine mem_piFinset.2 fun i => ?_\n        by_cases hi : i = i₀\n        · have : r i₀ ∈ C i₀ := by simp [C, hri₀]\n          rwa [hi]\n        · simp [C, hi, mem_piFinset.1 hr i]\n      · apply Finset.mem_union_left\n        refine mem_piFinset.2 fun i => ?_\n        by_cases hi : i = i₀\n        · have : r i₀ ∈ B i₀ := by simp [B, hri₀, mem_piFinset.1 hr i₀]\n          rwa [hi]\n        · simp [B, hi, mem_piFinset.1 hr i]\n    · exact\n        Finset.union_subset (piFinset_subset _ _ fun i => B_subset_A i)\n          (piFinset_subset _ _ fun i => C_subset_A i)\n  rw [A_eq_BC]\n  simp only [MultilinearMap.map_update_add, Beq, Ceq, Brec, Crec, pi_BC]\n  rw [← Finset.sum_union D]\n\n"}
{"name":"MultilinearMap.map_sum_finset","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\nα : ι → Type u_1\ng : (i : ι) → α i → M₁ i\nA : (i : ι) → Finset (α i)\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\n⊢ Eq (f fun i => (A i).sum fun j => g i j) ((Fintype.piFinset A).sum fun r => f fun i => g i (r i))","decl":"/-- If `f` is multilinear, then `f (Σ_{j₁ ∈ A₁} g₁ j₁, ..., Σ_{jₙ ∈ Aₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions with `r 1 ∈ A₁`, ...,\n`r n ∈ Aₙ`. This follows from multilinearity by expanding successively with respect to each\ncoordinate. -/\ntheorem map_sum_finset [DecidableEq ι] [Fintype ι] :\n    (f fun i => ∑ j ∈ A i, g i j) = ∑ r ∈ piFinset A, f fun i => g i (r i) :=\n  f.map_sum_finset_aux _ _ rfl\n\n"}
{"name":"MultilinearMap.map_sum","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : Module R M₂\nf : MultilinearMap R M₁ M₂\nα : ι → Type u_1\ng : (i : ι) → α i → M₁ i\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → Fintype (α i)\n⊢ Eq (f fun i => Finset.univ.sum fun j => g i j) (Finset.univ.sum fun r => f fun i => g i (r i))","decl":"/-- If `f` is multilinear, then `f (Σ_{j₁} g₁ j₁, ..., Σ_{jₙ} gₙ jₙ)` is the sum of\n`f (g₁ (r 1), ..., gₙ (r n))` where `r` ranges over all functions `r`. This follows from\nmultilinearity by expanding successively with respect to each coordinate. -/\ntheorem map_sum [DecidableEq ι] [Fintype ι] [∀ i, Fintype (α i)] :\n    (f fun i => ∑ j, g i j) = ∑ r : ∀ i, α i, f fun i => g i (r i) :=\n  f.map_sum_finset g fun _ => Finset.univ\n\n"}
{"name":"MultilinearMap.map_update_sum","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\nα : Type u_2\ninst✝ : DecidableEq ι\nt : Finset α\ni : ι\ng : α → M₁ i\nm : (i : ι) → M₁ i\n⊢ Eq (f (Function.update m i (t.sum fun a => g a))) (t.sum fun a => f (Function.update m i (g a)))","decl":"theorem map_update_sum {α : Type*} [DecidableEq ι] (t : Finset α) (i : ι) (g : α → M₁ i)\n    (m : ∀ i, M₁ i) : f (update m i (∑ a ∈ t, g a)) = ∑ a ∈ t, f (update m i (g a)) := by\n  classical\n    induction' t using Finset.induction with a t has ih h\n    · simp\n    · simp [Finset.sum_insert has, ih]\n\n"}
{"name":"MultilinearMap.codRestrict_apply_coe","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\np : Submodule R M₂\nh : ∀ (v : (i : ι) → M₁ i), Membership.mem p (f v)\nv : (i : ι) → M₁ i\n⊢ Eq (↑((f.codRestrict p h) v)) (f v)","decl":"/-- Restrict the codomain of a multilinear map to a submodule.\n\nThis is the multilinear version of `LinearMap.codRestrict`. -/\n@[simps]\ndef codRestrict (f : MultilinearMap R M₁ M₂) (p : Submodule R M₂) (h : ∀ v, f v ∈ p) :\n    MultilinearMap R M₁ p where\n  toFun v := ⟨f v, h v⟩\n  map_update_add' _ _ _ _ := Subtype.ext <| MultilinearMap.map_update_add _ _ _ _ _\n  map_update_smul' _ _ _ _ := Subtype.ext <| MultilinearMap.map_update_smul _ _ _ _ _\n\n"}
{"name":"MultilinearMap.coe_restrictScalars","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝¹⁰ : Semiring R\ninst✝⁹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁸ : AddCommMonoid M₂\ninst✝⁷ : (i : ι) → Module R (M₁ i)\ninst✝⁶ : Module R M₂\nA : Type u_1\ninst✝⁵ : Semiring A\ninst✝⁴ : SMul R A\ninst✝³ : (i : ι) → Module A (M₁ i)\ninst✝² : Module A M₂\ninst✝¹ : ∀ (i : ι), IsScalarTower R A (M₁ i)\ninst✝ : IsScalarTower R A M₂\nf : MultilinearMap A M₁ M₂\n⊢ Eq ⇑(MultilinearMap.restrictScalars R f) ⇑f","decl":"@[simp]\ntheorem coe_restrictScalars (f : MultilinearMap A M₁ M₂) : ⇑(f.restrictScalars R) = f :=\n  rfl\n\n"}
{"name":"MultilinearMap.domDomCongr_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\nm : MultilinearMap R (fun x => M₂) M₃\nv : ι₂ → M₂\n⊢ Eq ((MultilinearMap.domDomCongr σ m) v) (m fun i => v (σ i))","decl":"/-- Transfer the arguments to a map along an equivalence between argument indices.\n\nThe naming is derived from `Finsupp.domCongr`, noting that here the permutation applies to the\ndomain of the domain. -/\n@[simps apply]\ndef domDomCongr (σ : ι₁ ≃ ι₂) (m : MultilinearMap R (fun _ : ι₁ => M₂) M₃) :\n    MultilinearMap R (fun _ : ι₂ => M₂) M₃ where\n  toFun v := m fun i => v (σ i)\n  map_update_add' v i a b := by\n    letI := σ.injective.decidableEq\n    simp_rw [Function.update_apply_equiv_apply v]\n    rw [m.map_update_add]\n  map_update_smul' v i a b := by\n    letI := σ.injective.decidableEq\n    simp_rw [Function.update_apply_equiv_apply v]\n    rw [m.map_update_smul]\n\n"}
{"name":"MultilinearMap.domDomCongr_trans","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nι₃ : Type u_3\nσ₁ : Equiv ι₁ ι₂\nσ₂ : Equiv ι₂ ι₃\nm : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq (MultilinearMap.domDomCongr (σ₁.trans σ₂) m) (MultilinearMap.domDomCongr σ₂ (MultilinearMap.domDomCongr σ₁ m))","decl":"theorem domDomCongr_trans (σ₁ : ι₁ ≃ ι₂) (σ₂ : ι₂ ≃ ι₃)\n    (m : MultilinearMap R (fun _ : ι₁ => M₂) M₃) :\n    m.domDomCongr (σ₁.trans σ₂) = (m.domDomCongr σ₁).domDomCongr σ₂ :=\n  rfl\n\n"}
{"name":"MultilinearMap.domDomCongr_mul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nσ₁ σ₂ : Equiv.Perm ι₁\nm : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq (MultilinearMap.domDomCongr (HMul.hMul σ₂ σ₁) m) (MultilinearMap.domDomCongr σ₂ (MultilinearMap.domDomCongr σ₁ m))","decl":"theorem domDomCongr_mul (σ₁ : Equiv.Perm ι₁) (σ₂ : Equiv.Perm ι₁)\n    (m : MultilinearMap R (fun _ : ι₁ => M₂) M₃) :\n    m.domDomCongr (σ₂ * σ₁) = (m.domDomCongr σ₁).domDomCongr σ₂ :=\n  rfl\n\n"}
{"name":"MultilinearMap.domDomCongrEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\nm : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((MultilinearMap.domDomCongrEquiv σ).symm m) (MultilinearMap.domDomCongr σ.symm m)","decl":"/-- `MultilinearMap.domDomCongr` as an equivalence.\n\nThis is declared separately because it does not work with dot notation. -/\n@[simps apply symm_apply]\ndef domDomCongrEquiv (σ : ι₁ ≃ ι₂) :\n    MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃+ MultilinearMap R (fun _ : ι₂ => M₂) M₃ where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv m := by\n    ext\n    simp [domDomCongr]\n  right_inv m := by\n    ext\n    simp [domDomCongr]\n  map_add' a b := by\n    ext\n    simp [domDomCongr]\n\n"}
{"name":"MultilinearMap.domDomCongrEquiv_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\nm : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((MultilinearMap.domDomCongrEquiv σ) m) (MultilinearMap.domDomCongr σ m)","decl":"/-- `MultilinearMap.domDomCongr` as an equivalence.\n\nThis is declared separately because it does not work with dot notation. -/\n@[simps apply symm_apply]\ndef domDomCongrEquiv (σ : ι₁ ≃ ι₂) :\n    MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃+ MultilinearMap R (fun _ : ι₂ => M₂) M₃ where\n  toFun := domDomCongr σ\n  invFun := domDomCongr σ.symm\n  left_inv m := by\n    ext\n    simp [domDomCongr]\n  right_inv m := by\n    ext\n    simp [domDomCongr]\n  map_add' a b := by\n    ext\n    simp [domDomCongr]\n\n"}
{"name":"MultilinearMap.domDomCongr_eq_iff","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M₂\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\nf g : MultilinearMap R (fun x => M₂) M₃\n⊢ Iff (Eq (MultilinearMap.domDomCongr σ f) (MultilinearMap.domDomCongr σ g)) (Eq f g)","decl":"/-- The results of applying `domDomCongr` to two maps are equal if\nand only if those maps are. -/\n@[simp]\ntheorem domDomCongr_eq_iff (σ : ι₁ ≃ ι₂) (f g : MultilinearMap R (fun _ : ι₁ => M₂) M₃) :\n    f.domDomCongr σ = g.domDomCongr σ ↔ f = g :=\n  (domDomCongrEquiv σ : _ ≃+ MultilinearMap R (fun _ => M₂) M₃).apply_eq_iff_eq\n\n"}
{"name":"MultilinearMap.domDomRestrict_aux","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"ι : Sort u_2\ninst✝² : DecidableEq ι\nP : ι → Prop\ninst✝¹ : DecidablePred P\nM₁ : ι → Type u_1\ninst✝ : DecidableEq (Subtype fun a => P a)\nx : (i : Subtype fun a => P a) → M₁ ↑i\nz : (i : Subtype fun a => Not (P a)) → M₁ ↑i\ni : Subtype fun a => P a\nc : M₁ ↑i\n⊢ Eq (fun j => dite (P j) (fun h => Function.update x i c ⟨j, h⟩) fun h => z ⟨j, h⟩) (Function.update (fun j => dite (P j) (fun h => x ⟨j, h⟩) fun h => z ⟨j, h⟩) (↑i) c)","decl":"lemma domDomRestrict_aux {ι} [DecidableEq ι] (P : ι → Prop) [DecidablePred P] {M₁ : ι → Type*}\n    [DecidableEq {a // P a}]\n    (x : (i : {a // P a}) → M₁ i) (z : (i : {a // ¬ P a}) → M₁ i) (i : {a : ι // P a})\n    (c : M₁ i) : (fun j ↦ if h : P j then Function.update x i c ⟨j, h⟩ else z ⟨j, h⟩) =\n    Function.update (fun j => if h : P j then x ⟨j, h⟩ else z ⟨j, h⟩) i c := by\n  ext j\n  by_cases h : j = i\n  · rw [h, Function.update_self]\n    simp only [i.2, update_self, dite_true]\n  · rw [Function.update_of_ne h]\n    by_cases h' : P j\n    · simp only [h', ne_eq, Subtype.mk.injEq, dite_true]\n      have h'' : ¬ ⟨j, h'⟩ = i :=\n        fun he => by apply_fun (fun x => x.1) at he; exact h he\n      rw [Function.update_of_ne h'']\n    · simp only [h', ne_eq, Subtype.mk.injEq, dite_false]\n\n"}
{"name":"MultilinearMap.domDomRestrict_aux_right","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"ι : Sort u_2\ninst✝² : DecidableEq ι\nP : ι → Prop\ninst✝¹ : DecidablePred P\nM₁ : ι → Type u_1\ninst✝ : DecidableEq (Subtype fun a => Not (P a))\nx : (i : Subtype fun a => P a) → M₁ ↑i\nz : (i : Subtype fun a => Not (P a)) → M₁ ↑i\ni : Subtype fun a => Not (P a)\nc : M₁ ↑i\n⊢ Eq (fun j => dite (P j) (fun h => x ⟨j, h⟩) fun h => Function.update z i c ⟨j, h⟩) (Function.update (fun j => dite (P j) (fun h => x ⟨j, h⟩) fun h => z ⟨j, h⟩) (↑i) c)","decl":"lemma domDomRestrict_aux_right {ι} [DecidableEq ι] (P : ι → Prop) [DecidablePred P] {M₁ : ι → Type*}\n    [DecidableEq {a // ¬ P a}]\n    (x : (i : {a // P a}) → M₁ i) (z : (i : {a // ¬ P a}) → M₁ i) (i : {a : ι // ¬ P a})\n    (c : M₁ i) : (fun j ↦ if h : P j then x ⟨j, h⟩ else Function.update z i c ⟨j, h⟩) =\n    Function.update (fun j => if h : P j then x ⟨j, h⟩ else z ⟨j, h⟩) i c := by\n  simpa only [dite_not] using domDomRestrict_aux _ z (fun j ↦ x ⟨j.1, not_not.mp j.2⟩) i c\n\n"}
{"name":"MultilinearMap.domDomRestrict_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\nP : ι → Prop\ninst✝ : DecidablePred P\nx : (i : Subtype fun a => P a) → M₁ ↑i\nz : (i : Subtype fun a => Not (P a)) → M₁ ↑i\n⊢ Eq ((f.domDomRestrict P z) x) (f fun j => dite (P j) (fun h => x ⟨j, h⟩) fun h => z ⟨j, h⟩)","decl":"@[simp]\nlemma domDomRestrict_apply (f : MultilinearMap R M₁ M₂) (P : ι → Prop)\n    [DecidablePred P] (x : (i : {a // P a}) → M₁ i) (z : (i : {a // ¬ P a}) → M₁ i) :\n    f.domDomRestrict P z x = f (fun j => if h : P j then x ⟨j, h⟩ else z ⟨j, h⟩) := rfl\n\n-- TODO: Should add a ref here when available.\n"}
{"name":"MultilinearMap.linearDeriv_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nf : MultilinearMap R M₁ M₂\nx y : (i : ι) → M₁ i\n⊢ Eq ((f.linearDeriv x) y) (Finset.univ.sum fun i => f (Function.update x i (y i)))","decl":"@[simp]\nlemma linearDeriv_apply [DecidableEq ι] [Fintype ι] (f : MultilinearMap R M₁ M₂)\n    (x y : (i : ι) → M₁ i) :\n    f.linearDeriv x y = ∑ i, f (update x i (y i)) := by\n  unfold linearDeriv\n  simp only [LinearMap.coeFn_sum, LinearMap.coe_comp, LinearMap.coe_proj, Finset.sum_apply,\n    Function.comp_apply, Function.eval, toLinearMap_apply]\n\n"}
{"name":"LinearMap.coe_compMultilinearMap","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R M₁ M₂\n⊢ Eq (⇑(g.compMultilinearMap f)) (Function.comp ⇑g ⇑f)","decl":"@[simp]\ntheorem coe_compMultilinearMap (g : M₂ →ₗ[R] M₃) (f : MultilinearMap R M₁ M₂) :\n    ⇑(g.compMultilinearMap f) = g ∘ f :=\n  rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((g.compMultilinearMap f) m) (g (f m))","decl":"@[simp]\ntheorem compMultilinearMap_apply (g : M₂ →ₗ[R] M₃) (f : MultilinearMap R M₁ M₂) (m : ∀ i, M₁ i) :\n    g.compMultilinearMap f m = g (f m) :=\n  rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_zero","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq (g.compMultilinearMap 0) 0","decl":"@[simp]\ntheorem compMultilinearMap_zero (g : M₂ →ₗ[R] M₃) :\n    g.compMultilinearMap (0 : MultilinearMap R M₁ M₂) = 0 :=\n  MultilinearMap.ext fun _ => map_zero g\n\n"}
{"name":"LinearMap.zero_compMultilinearMap","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : MultilinearMap R M₁ M₂\n⊢ Eq (LinearMap.compMultilinearMap 0 f) 0","decl":"@[simp]\ntheorem zero_compMultilinearMap (f: MultilinearMap R M₁ M₂) :\n    (0 : M₂ →ₗ[R] M₃).compMultilinearMap f = 0 := rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nf₁ f₂ : MultilinearMap R M₁ M₂\n⊢ Eq (g.compMultilinearMap (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (g.compMultilinearMap f₁) (g.compMultilinearMap f₂))","decl":"@[simp]\ntheorem compMultilinearMap_add (g : M₂ →ₗ[R] M₃) (f₁ f₂ : MultilinearMap R M₁ M₂) :\n    g.compMultilinearMap (f₁ + f₂) = g.compMultilinearMap f₁ + g.compMultilinearMap f₂ :=\n  MultilinearMap.ext fun _ => map_add g _ _\n\n"}
{"name":"LinearMap.add_compMultilinearMap","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng₁ g₂ : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R M₁ M₂\n⊢ Eq ((HAdd.hAdd g₁ g₂).compMultilinearMap f) (HAdd.hAdd (g₁.compMultilinearMap f) (g₂.compMultilinearMap f))","decl":"@[simp]\ntheorem add_compMultilinearMap (g₁ g₂ : M₂ →ₗ[R] M₃) (f: MultilinearMap R M₁ M₂) :\n    (g₁ + g₂).compMultilinearMap f = g₁.compMultilinearMap f + g₂.compMultilinearMap f := rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝¹² : Semiring R\ninst✝¹¹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M₃\ninst✝⁸ : (i : ι) → Module R (M₁ i)\ninst✝⁷ : Module R M₂\ninst✝⁶ : Module R M₃\ninst✝⁵ : Monoid S\ninst✝⁴ : DistribMulAction S M₂\ninst✝³ : DistribMulAction S M₃\ninst✝² : SMulCommClass R S M₂\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : LinearMap.CompatibleSMul M₂ M₃ S R\ng : LinearMap (RingHom.id R) M₂ M₃\ns : S\nf : MultilinearMap R M₁ M₂\n⊢ Eq (g.compMultilinearMap (HSMul.hSMul s f)) (HSMul.hSMul s (g.compMultilinearMap f))","decl":"@[simp]\ntheorem compMultilinearMap_smul [Monoid S] [DistribMulAction S M₂] [DistribMulAction S M₃]\n    [SMulCommClass R S M₂] [SMulCommClass R S M₃] [CompatibleSMul M₂ M₃ S R]\n    (g : M₂ →ₗ[R] M₃) (s : S) (f : MultilinearMap R M₁ M₂) :\n    g.compMultilinearMap (s • f) = s • g.compMultilinearMap f :=\n  MultilinearMap.ext fun _ => g.map_smul_of_tower _ _\n\n"}
{"name":"LinearMap.smul_compMultilinearMap","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁹ : Semiring R\ninst✝⁸ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : AddCommMonoid M₃\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : Module R M₂\ninst✝³ : Module R M₃\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M₃\ninst✝ : SMulCommClass R S M₃\ng : LinearMap (RingHom.id R) M₂ M₃\ns : S\nf : MultilinearMap R M₁ M₂\n⊢ Eq ((HSMul.hSMul s g).compMultilinearMap f) (HSMul.hSMul s (g.compMultilinearMap f))","decl":"@[simp]\ntheorem smul_compMultilinearMap [Monoid S] [DistribMulAction S M₃] [SMulCommClass R S M₃]\n    (g : M₂ →ₗ[R] M₃) (s : S) (f : MultilinearMap R M₁ M₂) :\n    (s • g).compMultilinearMap f = s • g.compMultilinearMap f := rfl\n\n"}
{"name":"LinearMap.subtype_compMultilinearMap_codRestrict","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\np : Submodule R M₂\nh : ∀ (v : (i : ι) → M₁ i), Membership.mem p (f v)\n⊢ Eq (p.subtype.compMultilinearMap (f.codRestrict p h)) f","decl":"/-- The multilinear version of `LinearMap.subtype_comp_codRestrict` -/\n@[simp]\ntheorem subtype_compMultilinearMap_codRestrict (f : MultilinearMap R M₁ M₂) (p : Submodule R M₂)\n    (h) : p.subtype.compMultilinearMap (f.codRestrict p h) = f :=\n  rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_codRestrict","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\ng : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R M₁ M₂\np : Submodule R M₃\nh : ∀ (c : M₂), Membership.mem p (g c)\n⊢ Eq ((LinearMap.codRestrict p g h).compMultilinearMap f) ((g.compMultilinearMap f).codRestrict p ⋯)","decl":"/-- The multilinear version of `LinearMap.comp_codRestrict` -/\n@[simp]\ntheorem compMultilinearMap_codRestrict (g : M₂ →ₗ[R] M₃) (f : MultilinearMap R M₁ M₂)\n    (p : Submodule R M₃) (h) :\n    (g.codRestrict p h).compMultilinearMap f =\n      (g.compMultilinearMap f).codRestrict p fun v => h (f v) :=\n  rfl\n\n"}
{"name":"LinearMap.compMultilinearMap_domDomCongr","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM₃ : Type v₃\nM' : Type v'\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M'\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\ng : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R (fun x => M') M₂\n⊢ Eq (MultilinearMap.domDomCongr σ (g.compMultilinearMap f)) (g.compMultilinearMap (MultilinearMap.domDomCongr σ f))","decl":"@[simp]\ntheorem compMultilinearMap_domDomCongr (σ : ι₁ ≃ ι₂) (g : M₂ →ₗ[R] M₃)\n    (f : MultilinearMap R (fun _ : ι₁ => M') M₂) :\n    (g.compMultilinearMap f).domDomCongr σ = g.compMultilinearMap (f.domDomCongr σ) := by\n  ext\n  simp [MultilinearMap.domDomCongr]\n\n"}
{"name":"MultilinearMap.instNoZeroSMulDivisors","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁸ : Semiring R\ninst✝⁷ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁶ : (i : ι) → Module R (M₁ i)\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\ninst✝³ : Semiring S\ninst✝² : Module S M₂\ninst✝¹ : SMulCommClass R S M₂\ninst✝ : NoZeroSMulDivisors S M₂\n⊢ NoZeroSMulDivisors S (MultilinearMap R M₁ M₂)","decl":"instance [NoZeroSMulDivisors S M₂] : NoZeroSMulDivisors S (MultilinearMap R M₁ M₂) :=\n  coe_injective.noZeroSMulDivisors _ rfl coe_smul\n\n"}
{"name":"LinearMap.compMultilinearMapₗ_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝¹² : Semiring R\ninst✝¹¹ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝¹⁰ : (i : ι) → Module R (M₁ i)\ninst✝⁹ : AddCommMonoid M₂\ninst✝⁸ : Module R M₂\ninst✝⁷ : AddCommMonoid M₃\ninst✝⁶ : Module R M₃\ninst✝⁵ : Semiring S\ninst✝⁴ : Module S M₂\ninst✝³ : Module S M₃\ninst✝² : SMulCommClass R S M₂\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : LinearMap.CompatibleSMul M₂ M₃ S R\ng : LinearMap (RingHom.id R) M₂ M₃\nf : MultilinearMap R M₁ M₂\n⊢ Eq ((LinearMap.compMultilinearMapₗ S g) f) (g.compMultilinearMap f)","decl":"variable (S) in\n/-- `LinearMap.compMultilinearMap` as an `S`-linear map. -/\n@[simps]\ndef _root_.LinearMap.compMultilinearMapₗ [Semiring S] [Module S M₂] [Module S M₃]\n    [SMulCommClass R S M₂] [SMulCommClass R S M₃] [LinearMap.CompatibleSMul M₂ M₃ S R]\n    (g : M₂ →ₗ[R] M₃) :\n    MultilinearMap R M₁ M₂ →ₗ[S] MultilinearMap R M₁ M₃ where\n  toFun := g.compMultilinearMap\n  map_add' := g.compMultilinearMap_add\n  map_smul' := g.compMultilinearMap_smul\n\n"}
{"name":"MultilinearMap.ofSubsingletonₗ_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module S M₃\ninst✝² : Module R M₃\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : Subsingleton ι\ni : ι\na✝ : LinearMap (RingHom.id R) M₂ M₃\n⊢ Eq ((MultilinearMap.ofSubsingletonₗ R S M₂ M₃ i) a✝) ((MultilinearMap.ofSubsingleton R M₂ M₃ i) a✝)","decl":"/-- Linear equivalence between linear maps `M₂ →ₗ[R] M₃`\nand one-multilinear maps `MultilinearMap R (fun _ : ι ↦ M₂) M₃`. -/\n@[simps (config := { simpRhs := true })]\ndef ofSubsingletonₗ [Subsingleton ι] (i : ι) :\n    (M₂ →ₗ[R] M₃) ≃ₗ[S] MultilinearMap R (fun _ : ι ↦ M₂) M₃ :=\n  { ofSubsingleton R M₂ M₃ i with\n    map_add' := fun _ _ ↦ rfl\n    map_smul' := fun _ _ ↦ rfl }\n\n"}
{"name":"MultilinearMap.ofSubsingletonₗ_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M₂\ninst✝⁶ : Module R M₂\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module S M₃\ninst✝² : Module R M₃\ninst✝¹ : SMulCommClass R S M₃\ninst✝ : Subsingleton ι\ni : ι\na✝ : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((MultilinearMap.ofSubsingletonₗ R S M₂ M₃ i).symm a✝) ((MultilinearMap.ofSubsingleton R M₂ M₃ i).symm a✝)","decl":"/-- Linear equivalence between linear maps `M₂ →ₗ[R] M₃`\nand one-multilinear maps `MultilinearMap R (fun _ : ι ↦ M₂) M₃`. -/\n@[simps (config := { simpRhs := true })]\ndef ofSubsingletonₗ [Subsingleton ι] (i : ι) :\n    (M₂ →ₗ[R] M₃) ≃ₗ[S] MultilinearMap R (fun _ : ι ↦ M₂) M₃ :=\n  { ofSubsingleton R M₂ M₃ i with\n    map_add' := fun _ _ ↦ rfl\n    map_smul' := fun _ _ ↦ rfl }\n\n"}
{"name":"MultilinearMap.domDomCongrLinearEquiv'_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\ninst✝¹ : Semiring S\ninst✝ : Module S M₂\nι' : Type u_1\nσ : Equiv ι ι'\nf : MultilinearMap R M₁ M₂\n⊢ Eq ((MultilinearMap.domDomCongrLinearEquiv' R S M₁ M₂ σ) f) { toFun := Function.comp ⇑f ⇑(Equiv.piCongrLeft' M₁ σ).symm, map_update_add' := ⋯, map_update_smul' := ⋯ }","decl":"/-- The dependent version of `MultilinearMap.domDomCongrLinearEquiv`. -/\n@[simps apply symm_apply]\ndef domDomCongrLinearEquiv' {ι' : Type*} (σ : ι ≃ ι') :\n    MultilinearMap R M₁ M₂ ≃ₗ[S] MultilinearMap R (fun i => M₁ (σ.symm i)) M₂ where\n  toFun f :=\n    { toFun := f ∘ (σ.piCongrLeft' M₁).symm\n      map_update_add' := fun m i => by\n        letI := σ.decidableEq\n        rw [← σ.apply_symm_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_symm_update, f.map_update_add]\n      map_update_smul' := fun m i c => by\n        letI := σ.decidableEq\n        rw [← σ.apply_symm_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_symm_update, f.map_update_smul] }\n  invFun f :=\n    { toFun := f ∘ σ.piCongrLeft' M₁\n      map_update_add' := fun m i => by\n        letI := σ.symm.decidableEq\n        rw [← σ.symm_apply_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_update, f.map_update_add]\n      map_update_smul' := fun m i c => by\n        letI := σ.symm.decidableEq\n        rw [← σ.symm_apply_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_update, f.map_update_smul] }\n  map_add' f₁ f₂ := by\n    ext\n    simp only [Function.comp, coe_mk, add_apply]\n  map_smul' c f := by\n    ext\n    simp only [Function.comp, coe_mk, smul_apply, RingHom.id_apply]\n  left_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"MultilinearMap.domDomCongrLinearEquiv'_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : (i : ι) → Module R (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₂\ninst✝¹ : Semiring S\ninst✝ : Module S M₂\nι' : Type u_1\nσ : Equiv ι ι'\nf : MultilinearMap R (fun i => M₁ (σ.symm i)) M₂\n⊢ Eq ((MultilinearMap.domDomCongrLinearEquiv' R S M₁ M₂ σ).symm f) { toFun := Function.comp ⇑f ⇑(Equiv.piCongrLeft' M₁ σ), map_update_add' := ⋯, map_update_smul' := ⋯ }","decl":"/-- The dependent version of `MultilinearMap.domDomCongrLinearEquiv`. -/\n@[simps apply symm_apply]\ndef domDomCongrLinearEquiv' {ι' : Type*} (σ : ι ≃ ι') :\n    MultilinearMap R M₁ M₂ ≃ₗ[S] MultilinearMap R (fun i => M₁ (σ.symm i)) M₂ where\n  toFun f :=\n    { toFun := f ∘ (σ.piCongrLeft' M₁).symm\n      map_update_add' := fun m i => by\n        letI := σ.decidableEq\n        rw [← σ.apply_symm_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_symm_update, f.map_update_add]\n      map_update_smul' := fun m i c => by\n        letI := σ.decidableEq\n        rw [← σ.apply_symm_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_symm_update, f.map_update_smul] }\n  invFun f :=\n    { toFun := f ∘ σ.piCongrLeft' M₁\n      map_update_add' := fun m i => by\n        letI := σ.symm.decidableEq\n        rw [← σ.symm_apply_apply i]\n        intro x y\n        simp only [comp_apply, piCongrLeft'_update, f.map_update_add]\n      map_update_smul' := fun m i c => by\n        letI := σ.symm.decidableEq\n        rw [← σ.symm_apply_apply i]\n        intro x\n        simp only [Function.comp, piCongrLeft'_update, f.map_update_smul] }\n  map_add' f₁ f₂ := by\n    ext\n    simp only [Function.comp, coe_mk, add_apply]\n  map_smul' c f := by\n    ext\n    simp only [Function.comp, coe_mk, smul_apply, RingHom.id_apply]\n  left_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.symm_apply_apply]\n  right_inv f := by\n    ext\n    simp only [coe_mk, comp_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"MultilinearMap.constLinearEquivOfIsEmpty_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\ninst✝² : Semiring S\ninst✝¹ : Module S M₂\ninst✝ : IsEmpty ι\nm : M₂\n⊢ Eq ((MultilinearMap.constLinearEquivOfIsEmpty R S M₁ M₂) m) (MultilinearMap.constOfIsEmpty R M₁ m)","decl":"/-- The space of constant maps is equivalent to the space of maps that are multilinear with respect\nto an empty family. -/\n@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty ι] : M₂ ≃ₗ[S] MultilinearMap R M₁ M₂ where\n  toFun := MultilinearMap.constOfIsEmpty R _\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => MultilinearMap.congr_arg f <| Subsingleton.elim _ _\n\n"}
{"name":"MultilinearMap.constLinearEquivOfIsEmpty_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁷ : Semiring R\ninst✝⁶ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁵ : (i : ι) → Module R (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₂\ninst✝² : Semiring S\ninst✝¹ : Module S M₂\ninst✝ : IsEmpty ι\nf : MultilinearMap R M₁ M₂\n⊢ Eq ((MultilinearMap.constLinearEquivOfIsEmpty R S M₁ M₂).symm f) (f 0)","decl":"/-- The space of constant maps is equivalent to the space of maps that are multilinear with respect\nto an empty family. -/\n@[simps]\ndef constLinearEquivOfIsEmpty [IsEmpty ι] : M₂ ≃ₗ[S] MultilinearMap R M₁ M₂ where\n  toFun := MultilinearMap.constOfIsEmpty R _\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun f := f 0\n  left_inv _ := rfl\n  right_inv f := ext fun _ => MultilinearMap.congr_arg f <| Subsingleton.elim _ _\n\n"}
{"name":"MultilinearMap.domDomCongrLinearEquiv_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\ninst✝³ : Semiring S\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module S M₃\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\na✝ : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((MultilinearMap.domDomCongrLinearEquiv R S M₂ M₃ σ).symm a✝) ((MultilinearMap.domDomCongrEquiv σ).invFun a✝)","decl":"/-- `MultilinearMap.domDomCongr` as a `LinearEquiv`. -/\n@[simps apply symm_apply]\ndef domDomCongrLinearEquiv {ι₁ ι₂} (σ : ι₁ ≃ ι₂) :\n    MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃ₗ[S] MultilinearMap R (fun _ : ι₂ => M₂) M₃ :=\n  { (domDomCongrEquiv σ :\n      MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃+ MultilinearMap R (fun _ : ι₂ => M₂) M₃) with\n    map_smul' := fun c f => by\n      ext\n      simp [MultilinearMap.domDomCongr] }\n\n"}
{"name":"MultilinearMap.domDomCongrLinearEquiv_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nS : Type uS\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₂\ninst✝³ : Semiring S\ninst✝² : AddCommMonoid M₃\ninst✝¹ : Module S M₃\ninst✝ : Module R M₃\nι₁ : Type u_1\nι₂ : Type u_2\nσ : Equiv ι₁ ι₂\na✝ : MultilinearMap R (fun x => M₂) M₃\n⊢ Eq ((MultilinearMap.domDomCongrLinearEquiv R S M₂ M₃ σ) a✝) ((MultilinearMap.domDomCongrEquiv σ).toFun a✝)","decl":"/-- `MultilinearMap.domDomCongr` as a `LinearEquiv`. -/\n@[simps apply symm_apply]\ndef domDomCongrLinearEquiv {ι₁ ι₂} (σ : ι₁ ≃ ι₂) :\n    MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃ₗ[S] MultilinearMap R (fun _ : ι₂ => M₂) M₃ :=\n  { (domDomCongrEquiv σ :\n      MultilinearMap R (fun _ : ι₁ => M₂) M₃ ≃+ MultilinearMap R (fun _ : ι₂ => M₂) M₃) with\n    map_smul' := fun c f => by\n      ext\n      simp [MultilinearMap.domDomCongr] }\n\n"}
{"name":"MultilinearMap.iteratedFDeriv_aux","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"ι : Type u_4\nM₁ : ι → Type u_2\nα : Type u_3\ninst✝¹ : DecidableEq α\ns : Set ι\ninst✝ : DecidableEq (Subtype fun x => Membership.mem s x)\ne : Equiv α ↑s\nm : α → (i : ι) → M₁ i\na : α\nz : (i : ι) → M₁ i\n⊢ Eq (fun i => Function.update m a z (e.symm i) ↑i) fun i => Function.update (fun j => m (e.symm j) ↑j) (e a) (z ↑(e a)) i","decl":"lemma iteratedFDeriv_aux {ι} {M₁ : ι → Type*} {α : Type*} [DecidableEq α]\n    (s : Set ι) [DecidableEq { x // x ∈ s }] (e : α ≃ s)\n    (m : α → ((i : ι) → M₁ i)) (a : α) (z : (i : ι) → M₁ i) :\n    (fun i ↦ update m a z (e.symm i) i) =\n      (fun i ↦ update (fun j ↦ m (e.symm j) j) (e a) (z (e a)) i) := by\n  ext i\n  rcases eq_or_ne a (e.symm i) with rfl | hne\n  · rw [Equiv.apply_symm_apply e i, update_self, update_self]\n  · rw [update_of_ne hne.symm, update_of_ne fun h ↦ (Equiv.symm_apply_apply .. ▸ h ▸ hne) rfl]\n\n"}
{"name":"MultilinearMap.compLinearMapₗ_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\ng : MultilinearMap R M₁' M₂\n⊢ Eq ((MultilinearMap.compLinearMapₗ f) g) (g.compLinearMap f)","decl":"/-- If `f` is a collection of linear maps, then the construction `MultilinearMap.compLinearMap`\nsending a multilinear map `g` to `g (f₁ ⬝ , ..., fₙ ⬝ )` is linear in `g`. -/\n@[simps] def compLinearMapₗ (f : Π (i : ι), M₁ i →ₗ[R] M₁' i) :\n    (MultilinearMap R M₁' M₂) →ₗ[R] MultilinearMap R M₁ M₂ where\n  toFun := fun g ↦ g.compLinearMap f\n  map_add' := fun _ _ ↦ rfl\n  map_smul' := fun _ _ ↦ rfl\n\n"}
{"name":"MultilinearMap.compLinearMapMultilinear_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\nf : (i : ι) → LinearMap (RingHom.id R) (M₁ i) (M₁' i)\n⊢ Eq (MultilinearMap.compLinearMapMultilinear f) (MultilinearMap.compLinearMapₗ f)","decl":"/-- If `f` is a collection of linear maps, then the construction `MultilinearMap.compLinearMap`\nsending a multilinear map `g` to `g (f₁ ⬝ , ..., fₙ ⬝ )` is linear in `g` and multilinear in\n`f₁, ..., fₙ`. -/\n@[simps] def compLinearMapMultilinear :\n  @MultilinearMap R ι (fun i ↦ M₁ i →ₗ[R] M₁' i)\n    ((MultilinearMap R M₁' M₂) →ₗ[R] MultilinearMap R M₁ M₂) _ _ _\n      (fun _ ↦ LinearMap.module) _ where\n  toFun := MultilinearMap.compLinearMapₗ\n  map_update_add' := by\n    intro _ f i f₁ f₂\n    ext g x\n    change (g fun j ↦ update f i (f₁ + f₂) j <| x j) =\n        (g fun j ↦ update f i f₁ j <|x j) + g fun j ↦ update f i f₂ j (x j)\n    let c : Π (i : ι), (M₁ i →ₗ[R] M₁' i) → M₁' i := fun i f ↦ f (x i)\n    convert g.map_update_add (fun j ↦ f j (x j)) i (f₁ (x i)) (f₂ (x i)) with j j j\n    · exact Function.apply_update c f i (f₁ + f₂) j\n    · exact Function.apply_update c f i f₁ j\n    · exact Function.apply_update c f i f₂ j\n  map_update_smul' := by\n    intro _ f i a f₀\n    ext g x\n    change (g fun j ↦ update f i (a • f₀) j <| x j) = a • g fun j ↦ update f i f₀ j (x j)\n    let c : Π (i : ι), (M₁ i →ₗ[R] M₁' i) → M₁' i := fun i f ↦ f (x i)\n    convert g.map_update_smul (fun j ↦ f j (x j)) i a (f₀ (x i)) with j j j\n    · exact Function.apply_update c f i (a • f₀) j\n    · exact Function.apply_update c f i f₀ j\n\n"}
{"name":"MultilinearMap.piLinearMap_apply_apply_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nM₁' : ι → Type u_1\ninst✝¹ : (i : ι) → AddCommMonoid (M₁' i)\ninst✝ : (i : ι) → Module R (M₁' i)\ng : MultilinearMap R M₁' M₂\na✝ : (i : ι) → (fun i => LinearMap (RingHom.id R) (M₁ i) (M₁' i)) i\nm : (i : ι) → M₁ i\n⊢ Eq (((MultilinearMap.piLinearMap g) a✝) m) (g fun i => (a✝ i) (m i))","decl":"/--\nLet `M₁ᵢ` and `M₁ᵢ'` be two families of `R`-modules and `M₂` an `R`-module.\nLet us denote `Π i, M₁ᵢ` and `Π i, M₁ᵢ'` by `M` and `M'` respectively.\nIf `g` is a multilinear map `M' → M₂`, then `g` can be reinterpreted as a multilinear\nmap from `Π i, M₁ᵢ ⟶ M₁ᵢ'` to `M ⟶ M₂` via `(fᵢ) ↦ v ↦ g(fᵢ vᵢ)`.\n-/\n@[simps!] def piLinearMap :\n    MultilinearMap R M₁' M₂ →ₗ[R]\n    MultilinearMap R (fun i ↦ M₁ i →ₗ[R] M₁' i) (MultilinearMap R M₁ M₂) where\n  toFun g := (LinearMap.applyₗ g).compMultilinearMap compLinearMapMultilinear\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"MultilinearMap.map_piecewise_smul","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nc : ι → R\nm : (i : ι) → M₁ i\ns : Finset ι\n⊢ Eq (f (s.piecewise (fun i => HSMul.hSMul (c i) (m i)) m)) (HSMul.hSMul (s.prod fun i => c i) (f m))","decl":"/-- If one multiplies by `c i` the coordinates in a finset `s`, then the image under a multilinear\nmap is multiplied by `∏ i ∈ s, c i`. This is mainly an auxiliary statement to prove the result when\n`s = univ`, given in `map_smul_univ`, although it can be useful in its own right as it does not\nrequire the index set `ι` to be finite. -/\ntheorem map_piecewise_smul [DecidableEq ι] (c : ι → R) (m : ∀ i, M₁ i) (s : Finset ι) :\n    f (s.piecewise (fun i => c i • m i) m) = (∏ i ∈ s, c i) • f m := by\n  refine s.induction_on (by simp) ?_\n  intro j s j_not_mem_s Hrec\n  have A :\n    Function.update (s.piecewise (fun i => c i • m i) m) j (m j) =\n      s.piecewise (fun i => c i • m i) m := by\n    ext i\n    by_cases h : i = j\n    · rw [h]\n      simp [j_not_mem_s]\n    · simp [h]\n  rw [s.piecewise_insert, f.map_update_smul, A, Hrec]\n  simp [j_not_mem_s, mul_smul]\n\n"}
{"name":"MultilinearMap.map_smul_univ","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : CommSemiring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : Fintype ι\nc : ι → R\nm : (i : ι) → M₁ i\n⊢ Eq (f fun i => HSMul.hSMul (c i) (m i)) (HSMul.hSMul (Finset.univ.prod fun i => c i) (f m))","decl":"/-- Multiplicativity of a multilinear map along all coordinates at the same time,\nwriting `f (fun i => c i • m i)` as `(∏ i, c i) • f m`. -/\ntheorem map_smul_univ [Fintype ι] (c : ι → R) (m : ∀ i, M₁ i) :\n    (f fun i => c i • m i) = (∏ i, c i) • f m := by\n  classical simpa using map_piecewise_smul f c m Finset.univ\n\n"}
{"name":"MultilinearMap.map_update_smul_left","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nm : (i : ι) → M₁ i\ni : ι\nc : R\nx : M₁ i\n⊢ Eq (f (Function.update (HSMul.hSMul c m) i x)) (HSMul.hSMul (HPow.hPow c (HSub.hSub (Fintype.card ι) 1)) (f (Function.update m i x)))","decl":"@[simp]\ntheorem map_update_smul_left [DecidableEq ι] [Fintype ι]\n    (m : ∀ i, M₁ i) (i : ι) (c : R) (x : M₁ i) :\n    f (update (c • m) i x) = c ^ (Fintype.card ι - 1) • f (update m i x) := by\n  have :\n    f ((Finset.univ.erase i).piecewise (c • update m i x) (update m i x)) =\n      (∏ _i ∈ Finset.univ.erase i, c) • f (update m i x) :=\n    map_piecewise_smul f _ _ _\n  simpa [← Function.update_smul c m] using this\n\n"}
{"name":"MultilinearMap.mkPiAlgebra_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\ninst✝³ : CommSemiring R\nA : Type u_1\ninst✝² : CommSemiring A\ninst✝¹ : Algebra R A\ninst✝ : Fintype ι\nm : ι → A\n⊢ Eq ((MultilinearMap.mkPiAlgebra R ι A) m) (Finset.univ.prod fun i => m i)","decl":"@[simp]\ntheorem mkPiAlgebra_apply (m : ι → A) : MultilinearMap.mkPiAlgebra R ι A m = ∏ i, m i :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkPiAlgebraFin_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\ninst✝² : CommSemiring R\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nm : Fin n → A\n⊢ Eq ((MultilinearMap.mkPiAlgebraFin R n A) m) (List.ofFn m).prod","decl":"@[simp]\ntheorem mkPiAlgebraFin_apply (m : Fin n → A) :\n    MultilinearMap.mkPiAlgebraFin R n A m = (List.ofFn m).prod :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkPiAlgebraFin_apply_const","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\ninst✝² : CommSemiring R\nA : Type u_1\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\n⊢ Eq ((MultilinearMap.mkPiAlgebraFin R n A) fun x => a) (HPow.hPow a n)","decl":"theorem mkPiAlgebraFin_apply_const (a : A) :\n    (MultilinearMap.mkPiAlgebraFin R n A fun _ => a) = a ^ n := by simp\n\n"}
{"name":"MultilinearMap.smulRight_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ R\nz : M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((f.smulRight z) m) (HSMul.hSMul (f m) z)","decl":"@[simp]\ntheorem smulRight_apply (f : MultilinearMap R M₁ R) (z : M₂) (m : ∀ i, M₁ i) :\n    f.smulRight z m = f m • z :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkPiRing_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Fintype ι\nz : M₂\nm : ι → R\n⊢ Eq ((MultilinearMap.mkPiRing R ι z) m) (HSMul.hSMul (Finset.univ.prod fun i => m i) z)","decl":"@[simp]\ntheorem mkPiRing_apply [Fintype ι] (z : M₂) (m : ι → R) :\n    (MultilinearMap.mkPiRing R ι z : (ι → R) → M₂) m = (∏ i, m i) • z :=\n  rfl\n\n"}
{"name":"MultilinearMap.mkPiRing_apply_one_eq_self","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Fintype ι\nf : MultilinearMap R (fun x => R) M₂\n⊢ Eq (MultilinearMap.mkPiRing R ι (f fun x => 1)) f","decl":"theorem mkPiRing_apply_one_eq_self [Fintype ι] (f : MultilinearMap R (fun _ : ι => R) M₂) :\n    MultilinearMap.mkPiRing R ι (f fun _ => 1) = f := by\n  ext m\n  have : m = fun i => m i • (1 : R) := by\n    ext j\n    simp\n  conv_rhs => rw [this, f.map_smul_univ]\n  rfl\n\n"}
{"name":"MultilinearMap.mkPiRing_eq_iff","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Fintype ι\nz₁ z₂ : M₂\n⊢ Iff (Eq (MultilinearMap.mkPiRing R ι z₁) (MultilinearMap.mkPiRing R ι z₂)) (Eq z₁ z₂)","decl":"theorem mkPiRing_eq_iff [Fintype ι] {z₁ z₂ : M₂} :\n    MultilinearMap.mkPiRing R ι z₁ = MultilinearMap.mkPiRing R ι z₂ ↔ z₁ = z₂ := by\n  simp_rw [MultilinearMap.ext_iff, mkPiRing_apply]\n  constructor <;> intro h\n  · simpa using h fun _ => 1\n  · intro x\n    simp [h]\n\n"}
{"name":"MultilinearMap.mkPiRing_zero","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Fintype ι\n⊢ Eq (MultilinearMap.mkPiRing R ι 0) 0","decl":"theorem mkPiRing_zero [Fintype ι] : MultilinearMap.mkPiRing R ι (0 : M₂) = 0 := by\n  ext; rw [mkPiRing_apply, smul_zero, MultilinearMap.zero_apply]\n\n"}
{"name":"MultilinearMap.mkPiRing_eq_zero_iff","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₂\ninst✝ : Fintype ι\nz : M₂\n⊢ Iff (Eq (MultilinearMap.mkPiRing R ι z) 0) (Eq z 0)","decl":"theorem mkPiRing_eq_zero_iff [Fintype ι] (z : M₂) : MultilinearMap.mkPiRing R ι z = 0 ↔ z = 0 := by\n  rw [← mkPiRing_zero, mkPiRing_eq_iff]\n\n"}
{"name":"MultilinearMap.neg_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommGroup M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf : MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((Neg.neg f) m) (Neg.neg (f m))","decl":"@[simp]\ntheorem neg_apply (m : ∀ i, M₁ i) : (-f) m = -f m :=\n  rfl\n\n"}
{"name":"MultilinearMap.sub_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝² : AddCommGroup M₂\ninst✝¹ : (i : ι) → Module R (M₁ i)\ninst✝ : Module R M₂\nf g : MultilinearMap R M₁ M₂\nm : (i : ι) → M₁ i\n⊢ Eq ((HSub.hSub f g) m) (HSub.hSub (f m) (g m))","decl":"@[simp]\ntheorem sub_apply (m : ∀ i, M₁ i) : (f - g) m = f m - g m :=\n  rfl\n\n"}
{"name":"MultilinearMap.map_update_neg","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx : M₁ i\n⊢ Eq (f (Function.update m i (Neg.neg x))) (Neg.neg (f (Function.update m i x)))","decl":"@[simp]\ntheorem map_update_neg [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x : M₁ i) :\n    f (update m i (-x)) = -f (update m i x) :=\n  eq_neg_of_add_eq_zero_left <| by\n    rw [← MultilinearMap.map_update_add, neg_add_cancel, f.map_coord_zero i (update_self i 0 m)]\n\n\n"}
{"name":"MultilinearMap.map_neg","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx : M₁ i\n⊢ Eq (f (Function.update m i (Neg.neg x))) (Neg.neg (f (Function.update m i x)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_neg := MultilinearMap.map_update_neg\n\n"}
{"name":"MultilinearMap.map_update_sub","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[simp]\ntheorem map_update_sub [DecidableEq ι] (m : ∀ i, M₁ i) (i : ι) (x y : M₁ i) :\n    f (update m i (x - y)) = f (update m i x) - f (update m i y) := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, MultilinearMap.map_update_add, map_update_neg]\n\n"}
{"name":"MultilinearMap.map_sub","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nm : (i : ι) → M₁ i\ni : ι\nx y : M₁ i\n⊢ Eq (f (Function.update m i (HSub.hSub x y))) (HSub.hSub (f (Function.update m i x)) (f (Function.update m i y)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_sub := MultilinearMap.map_update_sub\n\n"}
{"name":"MultilinearMap.map_update","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : DecidableEq ι\nx : (i : ι) → M₁ i\ni : ι\nv : M₁ i\n⊢ Eq (f (Function.update x i v)) (HSub.hSub (f x) (f (Function.update x i (HSub.hSub (x i) v))))","decl":"lemma map_update [DecidableEq ι] (x : (i : ι) → M₁ i) (i : ι) (v : M₁ i)  :\n    f (update x i v) = f x - f (update x i (x i - v)) := by\n  rw [map_update_sub, update_eq_self, sub_sub_cancel]\n\n"}
{"name":"MultilinearMap.map_sub_map_piecewise","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : LinearOrder ι\na b : (i : ι) → M₁ i\ns : Finset ι\n⊢ Eq (HSub.hSub (f a) (f (s.piecewise b a))) (s.sum fun i => f fun j => ite (Membership.mem s j → LT.lt j i) (a j) (ite (Eq i j) (HSub.hSub (a j) (b j)) (b j)))","decl":"open Finset in\nlemma map_sub_map_piecewise [LinearOrder ι] (a b : (i : ι) → M₁ i) (s : Finset ι) :\n    f a - f (s.piecewise b a) =\n    ∑ i ∈ s, f (fun j ↦ if j ∈ s → j < i then a j else if i = j then a j - b j else b j) := by\n  refine s.induction_on_min ?_ fun k s hk ih ↦ ?_\n  · rw [Finset.piecewise_empty, sum_empty, sub_self]\n  rw [Finset.piecewise_insert, map_update, ← sub_add, ih,\n      add_comm, sum_insert (lt_irrefl _ <| hk k ·)]\n  simp_rw [s.mem_insert]\n  congr 1\n  · congr; ext i; split_ifs with h₁ h₂\n    · rw [update_of_ne, Finset.piecewise_eq_of_not_mem]\n      · exact fun h ↦ (hk i h).not_lt (h₁ <| .inr h)\n      · exact fun h ↦ (h₁ <| .inl h).ne h\n    · cases h₂\n      rw [update_self, s.piecewise_eq_of_not_mem _ _ (lt_irrefl _ <| hk k ·)]\n    · push_neg at h₁\n      rw [update_of_ne (Ne.symm h₂), s.piecewise_eq_of_mem _ _ (h₁.1.resolve_left <| Ne.symm h₂)]\n  · apply sum_congr rfl; intro i hi; congr; ext j; congr 1; apply propext\n    simp_rw [imp_iff_not_or, not_or]; apply or_congr_left'\n    intro h; rw [and_iff_right]; rintro rfl; exact h (hk i hi)\n\n"}
{"name":"MultilinearMap.map_piecewise_sub_map_piecewise","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Semiring R\ninst✝⁴ : (i : ι) → AddCommGroup (M₁ i)\ninst✝³ : AddCommGroup M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝ : LinearOrder ι\na b v : (i : ι) → M₁ i\ns : Finset ι\n⊢ Eq (HSub.hSub (f (s.piecewise a v)) (f (s.piecewise b v))) (s.sum fun i => f fun j => ite (Membership.mem s j) (ite (LT.lt j i) (a j) (ite (Eq j i) (HSub.hSub (a j) (b j)) (b j))) (v j))","decl":"/-- This calculates the differences between the values of a multilinear map at\ntwo arguments that differ on a finset `s` of `ι`. It requires a\nlinear order on `ι` in order to express the result. -/\nlemma map_piecewise_sub_map_piecewise [LinearOrder ι] (a b v : (i : ι) → M₁ i) (s : Finset ι) :\n    f (s.piecewise a v) - f (s.piecewise b v) = ∑ i ∈ s, f\n      fun j ↦ if j ∈ s then if j < i then a j else if j = i then a j - b j else b j else v j := by\n  rw [← s.piecewise_idem_right b a, map_sub_map_piecewise]\n  refine Finset.sum_congr rfl fun i hi ↦ congr_arg f <| funext fun j ↦ ?_\n  by_cases hjs : j ∈ s\n  · rw [if_pos hjs]; by_cases hji : j < i\n    · rw [if_pos fun _ ↦ hji, if_pos hji, s.piecewise_eq_of_mem _ _ hjs]\n    rw [if_neg (Classical.not_imp.mpr ⟨hjs, hji⟩), if_neg hji]\n    obtain rfl | hij := eq_or_ne i j\n    · rw [if_pos rfl, if_pos rfl, s.piecewise_eq_of_mem _ _ hi]\n    · rw [if_neg hij, if_neg hij.symm]\n  · rw [if_neg hjs, if_pos fun h ↦ (hjs h).elim, s.piecewise_eq_of_not_mem _ _ hjs]\n\n"}
{"name":"MultilinearMap.map_add_eq_map_add_linearDeriv_add","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx h : (i : ι) → M₁ i\n⊢ Eq (f (HAdd.hAdd x h)) (HAdd.hAdd (HAdd.hAdd (f x) ((f.linearDeriv x) h)) ((Finset.filter (fun s => LE.le 2 s.card) Finset.univ).sum fun s => f (s.piecewise h x)))","decl":"open Finset in\nlemma map_add_eq_map_add_linearDeriv_add [DecidableEq ι] [Fintype ι] (x h : (i : ι) → M₁ i) :\n    f (x + h) = f x + f.linearDeriv x h + ∑ s with 2 ≤ #s, f (s.piecewise h x) := by\n  rw [add_comm, map_add_univ, ← Finset.powerset_univ,\n      ← sum_filter_add_sum_filter_not _ (2 ≤ #·)]\n  simp_rw [not_le, Nat.lt_succ, le_iff_lt_or_eq (b := 1), Nat.lt_one_iff, filter_or,\n    ← powersetCard_eq_filter, sum_union (univ.pairwise_disjoint_powersetCard zero_ne_one),\n    powersetCard_zero, powersetCard_one, sum_singleton, Finset.piecewise_empty, sum_map,\n    Function.Embedding.coeFn_mk, Finset.piecewise_singleton, linearDeriv_apply, add_comm]\n\n"}
{"name":"MultilinearMap.map_add_sub_map_add_sub_linearDeriv","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommGroup (M₁ i)\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : (i : ι) → Module R (M₁ i)\ninst✝² : Module R M₂\nf : MultilinearMap R M₁ M₂\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nx h h' : (i : ι) → M₁ i\n⊢ Eq (HSub.hSub (HSub.hSub (f (HAdd.hAdd x h)) (f (HAdd.hAdd x h'))) ((f.linearDeriv x) (HSub.hSub h h'))) ((Finset.filter (fun s => LE.le 2 s.card) Finset.univ).sum fun s => HSub.hSub (f (s.piecewise h x)) (f (s.piecewise h' x)))","decl":"open Finset in\n/-- This expresses the difference between the values of a multilinear map\nat two points \"close to `x`\" in terms of the \"derivative\" of the multilinear map at `x`\nand of \"second-order\" terms. -/\nlemma map_add_sub_map_add_sub_linearDeriv [DecidableEq ι] [Fintype ι] (x h h' : (i : ι) → M₁ i) :\n    f (x + h) - f (x + h') - f.linearDeriv x (h - h') =\n    ∑ s with 2 ≤ #s, (f (s.piecewise h x) - f (s.piecewise h' x)) := by\n  simp_rw [map_add_eq_map_add_linearDeriv_add, add_assoc, add_sub_add_comm, sub_self, zero_add,\n    ← LinearMap.map_sub, add_sub_cancel_left, sum_sub_distrib]\n\n"}
{"name":"LinearMap.uncurryLeft_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) (M 0) (MultilinearMap R (fun i => M i.succ) M₂)\nm : (i : Fin n.succ) → M i\n⊢ Eq (f.uncurryLeft m) ((f (m 0)) (Fin.tail m))","decl":"@[simp]\ntheorem LinearMap.uncurryLeft_apply (f : M 0 →ₗ[R] MultilinearMap R (fun i : Fin n => M i.succ) M₂)\n    (m : ∀ i, M i) : f.uncurryLeft m = f (m 0) (tail m) :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryLeft_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nx : M 0\nm : (i : Fin n) → M i.succ\n⊢ Eq ((f.curryLeft x) m) (f (Fin.cons x m))","decl":"@[simp]\ntheorem MultilinearMap.curryLeft_apply (f : MultilinearMap R M M₂) (x : M 0)\n    (m : ∀ i : Fin n, M i.succ) : f.curryLeft x m = f (cons x m) :=\n  rfl\n\n"}
{"name":"LinearMap.curry_uncurryLeft","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : LinearMap (RingHom.id R) (M 0) (MultilinearMap R (fun i => M i.succ) M₂)\n⊢ Eq f.uncurryLeft.curryLeft f","decl":"@[simp]\ntheorem LinearMap.curry_uncurryLeft (f : M 0 →ₗ[R] MultilinearMap R (fun i :\n    Fin n => M i.succ) M₂) : f.uncurryLeft.curryLeft = f := by\n  ext m x\n  simp only [tail_cons, LinearMap.uncurryLeft_apply, MultilinearMap.curryLeft_apply]\n  rw [cons_zero]\n\n"}
{"name":"MultilinearMap.uncurry_curryLeft","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\n⊢ Eq f.curryLeft.uncurryLeft f","decl":"@[simp]\ntheorem MultilinearMap.uncurry_curryLeft (f : MultilinearMap R M M₂) :\n    f.curryLeft.uncurryLeft = f := by\n  ext m\n  simp\n\n"}
{"name":"MultilinearMap.uncurryRight_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R (fun i => M i.castSucc) (LinearMap (RingHom.id R) (M (Fin.last n)) M₂)\nm : (i : Fin n.succ) → M i\n⊢ Eq (f.uncurryRight m) ((f (Fin.init m)) (m (Fin.last n)))","decl":"@[simp]\ntheorem MultilinearMap.uncurryRight_apply\n    (f : MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) →ₗ[R] M₂))\n    (m : ∀ i, M i) : f.uncurryRight m = f (init m) (m (last n)) :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryRight_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\nm : (i : Fin n) → M i.castSucc\nx : M (Fin.last n)\n⊢ Eq ((f.curryRight m) x) (f (Fin.snoc m x))","decl":"@[simp]\ntheorem MultilinearMap.curryRight_apply (f : MultilinearMap R M M₂)\n    (m : ∀ i : Fin n, M (castSucc i)) (x : M (last n)) : f.curryRight m x = f (snoc m x) :=\n  rfl\n\n"}
{"name":"MultilinearMap.curry_uncurryRight","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R (fun i => M i.castSucc) (LinearMap (RingHom.id R) (M (Fin.last n)) M₂)\n⊢ Eq f.uncurryRight.curryRight f","decl":"@[simp]\ntheorem MultilinearMap.curry_uncurryRight\n    (f : MultilinearMap R (fun i : Fin n => M (castSucc i)) (M (last n) →ₗ[R] M₂)) :\n    f.uncurryRight.curryRight = f := by\n  ext m x\n  simp only [snoc_last, MultilinearMap.curryRight_apply, MultilinearMap.uncurryRight_apply]\n  rw [init_snoc]\n\n"}
{"name":"MultilinearMap.uncurry_curryRight","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nn : Nat\nM : Fin n.succ → Type v\nM₂ : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : Fin n.succ) → AddCommMonoid (M i)\ninst✝² : AddCommMonoid M₂\ninst✝¹ : (i : Fin n.succ) → Module R (M i)\ninst✝ : Module R M₂\nf : MultilinearMap R M M₂\n⊢ Eq f.curryRight.uncurryRight f","decl":"@[simp]\ntheorem MultilinearMap.uncurry_curryRight (f : MultilinearMap R M M₂) :\n    f.curryRight.uncurryRight = f := by\n  ext m\n  simp\n\n"}
{"name":"MultilinearMap.currySum_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nι' : Type u_1\nf : MultilinearMap R (fun x => M') M₂\nu : ι → M'\nv : ι' → M'\n⊢ Eq ((f.currySum u) v) (f (Sum.elim u v))","decl":"@[simp]\ntheorem currySum_apply (f : MultilinearMap R (fun _ : ι ⊕ ι' => M') M₂) (u : ι → M')\n    (v : ι' → M') : f.currySum u v = f (Sum.elim u v) :=\n  rfl\n\n"}
{"name":"MultilinearMap.uncurrySum_aux_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nι' : Type u_1\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M₂)\nu : Sum ι ι' → M'\n⊢ Eq (f.uncurrySum u) ((f (Function.comp u Sum.inl)) (Function.comp u Sum.inr))","decl":"@[simp]\ntheorem uncurrySum_aux_apply\n    (f : MultilinearMap R (fun _ : ι => M') (MultilinearMap R (fun _ : ι' => M') M₂))\n    (u : ι ⊕ ι' → M') : f.uncurrySum u = f (u ∘ Sum.inl) (u ∘ Sum.inr) :=\n  rfl\n\n"}
{"name":"MultilinearMap.coe_currySumEquiv","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nι' : Type u_1\n⊢ Eq (⇑(MultilinearMap.currySumEquiv R ι M₂ M' ι')) MultilinearMap.currySum","decl":"@[simp]\ntheorem coe_currySumEquiv : ⇑(currySumEquiv R ι M₂ M' ι') = currySum :=\n  rfl\n\n-- Porting note: fixed missing letter `y` in name\n"}
{"name":"MultilinearMap.coe_currySumEquiv_symm","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nι' : Type u_1\n⊢ Eq (⇑(MultilinearMap.currySumEquiv R ι M₂ M' ι').symm) MultilinearMap.uncurrySum","decl":"@[simp]\ntheorem coe_currySumEquiv_symm : ⇑(currySumEquiv R ι M₂ M' ι').symm = uncurrySum :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryFinFinset_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nk l n : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : MultilinearMap R (fun x => M') M₂\nmk : Fin k → M'\nml : Fin l → M'\n⊢ Eq ((((MultilinearMap.curryFinFinset R M₂ M' hk hl) f) mk) ml) (f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i))","decl":"@[simp]\ntheorem curryFinFinset_apply {k l n : ℕ} {s : Finset (Fin n)} (hk : #s = k) (hl : #sᶜ = l)\n    (f : MultilinearMap R (fun _ : Fin n => M') M₂) (mk : Fin k → M') (ml : Fin l → M') :\n    curryFinFinset R M₂ M' hk hl f mk ml =\n      f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i) :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryFinFinset_symm_apply","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nk l n : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M₂)\nm : Fin n → M'\n⊢ Eq (((MultilinearMap.curryFinFinset R M₂ M' hk hl).symm f) m) ((f fun i => m ((finSumEquivOfFinset hk hl) (Sum.inl i))) fun i => m ((finSumEquivOfFinset hk hl) (Sum.inr i)))","decl":"@[simp]\ntheorem curryFinFinset_symm_apply {k l n : ℕ} {s : Finset (Fin n)} (hk : #s = k)\n    (hl : #sᶜ = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M₂))\n    (m : Fin n → M') :\n    (curryFinFinset R M₂ M' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i =>\n        m <| finSumEquivOfFinset hk hl (Sum.inr i) :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryFinFinset_symm_apply_piecewise_const","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nk l n : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M₂)\nx y : M'\n⊢ Eq (((MultilinearMap.curryFinFinset R M₂ M' hk hl).symm f) (s.piecewise (fun x_1 => x) fun x => y)) ((f fun x_1 => x) fun x => y)","decl":"theorem curryFinFinset_symm_apply_piecewise_const {k l n : ℕ} {s : Finset (Fin n)} (hk : #s = k)\n    (hl : #sᶜ = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M₂))\n    (x y : M') :\n    (curryFinFinset R M₂ M' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) =\n      f (fun _ => x) fun _ => y := by\n  rw [curryFinFinset_symm_apply]; congr\n  · ext\n    rw [finSumEquivOfFinset_inl, Finset.piecewise_eq_of_mem]\n    apply Finset.orderEmbOfFin_mem\n  · ext\n    rw [finSumEquivOfFinset_inr, Finset.piecewise_eq_of_not_mem]\n    exact Finset.mem_compl.1 (Finset.orderEmbOfFin_mem _ _ _)\n\n"}
{"name":"MultilinearMap.curryFinFinset_symm_apply_const","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nk l n : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : MultilinearMap R (fun x => M') (MultilinearMap R (fun x => M') M₂)\nx : M'\n⊢ Eq (((MultilinearMap.curryFinFinset R M₂ M' hk hl).symm f) fun x_1 => x) ((f fun x_1 => x) fun x_1 => x)","decl":"@[simp]\ntheorem curryFinFinset_symm_apply_const {k l n : ℕ} {s : Finset (Fin n)} (hk : #s = k)\n    (hl : #sᶜ = l)\n    (f : MultilinearMap R (fun _ : Fin k => M') (MultilinearMap R (fun _ : Fin l => M') M₂))\n    (x : M') : ((curryFinFinset R M₂ M' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x :=\n  rfl\n\n"}
{"name":"MultilinearMap.curryFinFinset_apply_const","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nM₂ : Type v₂\nM' : Type v'\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M'\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M'\ninst✝ : Module R M₂\nk l n : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : MultilinearMap R (fun x => M') M₂\nx y : M'\n⊢ Eq ((((MultilinearMap.curryFinFinset R M₂ M' hk hl) f) fun x_1 => x) fun x => y) (f (s.piecewise (fun x_1 => x) fun x => y))","decl":"theorem curryFinFinset_apply_const {k l n : ℕ} {s : Finset (Fin n)} (hk : #s = k)\n    (hl : #sᶜ = l) (f : MultilinearMap R (fun _ : Fin n => M') M₂) (x y : M') :\n    (curryFinFinset R M₂ M' hk hl f (fun _ => x) fun _ => y) =\n      f (s.piecewise (fun _ => x) fun _ => y) := by\n  -- Porting note: `rw` fails\n  refine (curryFinFinset_symm_apply_piecewise_const hk hl _ _ _).symm.trans ?_\n  rw [LinearEquiv.symm_apply_apply]\n\n"}
{"name":"MultilinearMap.map_nonempty","module":"Mathlib.LinearAlgebra.Multilinear.Basic","initialProofState":"R : Type uR\nι : Type uι\nM₁ : ι → Type v₁\nM₂ : Type v₂\ninst✝⁵ : Ring R\ninst✝⁴ : (i : ι) → AddCommMonoid (M₁ i)\ninst✝³ : AddCommMonoid M₂\ninst✝² : (i : ι) → Module R (M₁ i)\ninst✝¹ : Module R M₂\ninst✝ : Nonempty ι\nf : MultilinearMap R M₁ M₂\np : (i : ι) → Submodule R (M₁ i)\n⊢ (↑(f.map p)).Nonempty","decl":"/-- The map is always nonempty. This lemma is needed to apply `SubMulAction.zero_mem`. -/\ntheorem map_nonempty [Nonempty ι] (f : MultilinearMap R M₁ M₂) (p : ∀ i, Submodule R (M₁ i)) :\n    (map f p : Set M₂).Nonempty :=\n  ⟨f 0, 0, fun i => (p i).zero_mem, rfl⟩\n\n"}
