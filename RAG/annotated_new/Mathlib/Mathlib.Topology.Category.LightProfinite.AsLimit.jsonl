{"name":"LightProfinite.lightToProfinite_map_proj_eq","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn : Nat\n⊢ Eq (lightToProfinite.map (S.proj n)) ((lightToProfinite.obj S).asLimitCone.π.app ((CategoryTheory.Limits.IsCofiltered.sequentialFunctor (DiscreteQuotient ↑(lightToProfinite.obj S).toTop)).obj { unop := n }))","decl":"lemma lightToProfinite_map_proj_eq (n : ℕ) : lightToProfinite.map (S.proj n) =\n    (lightToProfinite.obj S).asLimitCone.π.app _ := by\n  simp only [toCompHausLike_obj, Functor.comp_obj, toCompHausLike_map, coe_of]\n  let c : Cone (S.diagram ⋙ lightToProfinite) := S.toLightDiagram.cone\n  let hc : IsLimit c := S.toLightDiagram.isLimit\n  exact liftedLimitMapsToOriginal_inv_map_π hc _\n\n"}
{"name":"LightProfinite.proj_surjective","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn : Nat\n⊢ Function.Surjective ⇑(S.proj n)","decl":"lemma proj_surjective (n : ℕ) : Function.Surjective (S.proj n) := by\n  change Function.Surjective (lightToProfinite.map (S.proj n))\n  rw [lightToProfinite_map_proj_eq]\n  exact DiscreteQuotient.proj_surjective _\n\n"}
{"name":"LightProfinite.proj_comp_transitionMap","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.proj (HAdd.hAdd n 1)) (S.diagram.map { unop := CategoryTheory.homOfLE ⋯ })) (S.proj n)","decl":"lemma proj_comp_transitionMap (n : ℕ) :\n    S.proj (n + 1) ≫ S.diagram.map ⟨homOfLE (Nat.le_succ _)⟩ = S.proj n :=\n  S.asLimitCone.w (homOfLE (Nat.le_succ n)).op\n\n"}
{"name":"LightProfinite.proj_comp_transitionMap'","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn : Nat\n⊢ Eq (Function.comp ⇑(S.transitionMap n) ⇑(S.proj (HAdd.hAdd n 1))) ⇑(S.proj n)","decl":"lemma proj_comp_transitionMap' (n : ℕ) : S.transitionMap n ∘ S.proj (n + 1) = S.proj n := by\n  rw [← S.proj_comp_transitionMap n]\n  rfl\n\n"}
{"name":"LightProfinite.proj_comp_transitionMapLE","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn m : Nat\nh : LE.le n m\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.proj m) (S.diagram.map { unop := CategoryTheory.homOfLE h })) (S.proj n)","decl":"lemma proj_comp_transitionMapLE {n m : ℕ} (h : n ≤ m) :\n    S.proj m ≫ S.diagram.map ⟨homOfLE h⟩ = S.proj n :=\n  S.asLimitCone.w (homOfLE h).op\n\n"}
{"name":"LightProfinite.proj_comp_transitionMapLE'","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn m : Nat\nh : LE.le n m\n⊢ Eq (Function.comp ⇑(S.transitionMapLE h) ⇑(S.proj m)) ⇑(S.proj n)","decl":"lemma proj_comp_transitionMapLE' {n m : ℕ} (h : n ≤ m) :\n    S.transitionMapLE h ∘ S.proj m  = S.proj n := by\n  rw [← S.proj_comp_transitionMapLE h]\n  rfl\n\n"}
{"name":"LightProfinite.surjective_transitionMap","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn : Nat\n⊢ Function.Surjective ⇑(S.transitionMap n)","decl":"lemma surjective_transitionMap (n : ℕ) : Function.Surjective (S.transitionMap n) := by\n  apply Function.Surjective.of_comp (g := S.proj (n + 1))\n  simpa only [proj_comp_transitionMap'] using S.proj_surjective n\n\n"}
{"name":"LightProfinite.surjective_transitionMapLE","module":"Mathlib.Topology.Category.LightProfinite.AsLimit","initialProofState":"S : LightProfinite\nn m : Nat\nh : LE.le n m\n⊢ Function.Surjective ⇑(S.transitionMapLE h)","decl":"lemma surjective_transitionMapLE {n m : ℕ} (h : n ≤ m) :\n    Function.Surjective (S.transitionMapLE h) := by\n  apply Function.Surjective.of_comp (g := S.proj m)\n  simpa only [proj_comp_transitionMapLE'] using S.proj_surjective n\n\n"}
