{"name":"Fin.rev_involutive","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\n⊢ Function.Involutive Fin.rev","decl":"theorem rev_involutive : Involutive (rev : Fin n → Fin n) := rev_rev\n\n"}
{"name":"Fin.revPerm_apply","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Fin.revPerm i) i.rev","decl":"/-- `Fin.rev` as an `Equiv.Perm`, the antitone involution `Fin n → Fin n` given by\n`i ↦ n-(i+1)`. -/\n@[simps! apply symm_apply]\ndef revPerm : Equiv.Perm (Fin n) :=\n  Involutive.toPerm rev rev_involutive\n\n"}
{"name":"Fin.revPerm_symm_apply","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq ((Equiv.symm Fin.revPerm) i) i.rev","decl":"/-- `Fin.rev` as an `Equiv.Perm`, the antitone involution `Fin n → Fin n` given by\n`i ↦ n-(i+1)`. -/\n@[simps! apply symm_apply]\ndef revPerm : Equiv.Perm (Fin n) :=\n  Involutive.toPerm rev rev_involutive\n\n"}
{"name":"Fin.rev_injective","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\n⊢ Function.Injective Fin.rev","decl":"theorem rev_injective : Injective (@rev n) :=\n  rev_involutive.injective\n\n"}
{"name":"Fin.rev_surjective","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\n⊢ Function.Surjective Fin.rev","decl":"theorem rev_surjective : Surjective (@rev n) :=\n  rev_involutive.surjective\n\n"}
{"name":"Fin.rev_bijective","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\n⊢ Function.Bijective Fin.rev","decl":"theorem rev_bijective : Bijective (@rev n) :=\n  rev_involutive.bijective\n\n"}
{"name":"Fin.revPerm_symm","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\n⊢ Eq (Equiv.symm Fin.revPerm) Fin.revPerm","decl":"@[simp]\ntheorem revPerm_symm : (@revPerm n).symm = revPerm :=\n  rfl\n\n"}
{"name":"Fin.cast_rev","module":"Mathlib.Data.Fin.Rev","initialProofState":"n m : Nat\ni : Fin n\nh : Eq n m\n⊢ Eq (Fin.cast h i.rev) (Fin.cast h i).rev","decl":"theorem cast_rev (i : Fin n) (h : n = m) :\n    i.rev.cast h = (i.cast h).rev := by\n  subst h; simp\n\n"}
{"name":"Fin.rev_eq_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (Eq i.rev j) (Eq i j.rev)","decl":"theorem rev_eq_iff {i j : Fin n} : rev i = j ↔ i = rev j := by\n  rw [← rev_inj, rev_rev]\n\n"}
{"name":"Fin.rev_ne_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (Ne i.rev j) (Ne i j.rev)","decl":"theorem rev_ne_iff {i j : Fin n} : rev i ≠ j ↔ i ≠ rev j := rev_eq_iff.not\n\n"}
{"name":"Fin.rev_lt_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (LT.lt i.rev j) (LT.lt j.rev i)","decl":"theorem rev_lt_iff {i j : Fin n} : rev i < j ↔ rev j < i := by\n  rw [← rev_lt_rev, rev_rev]\n\n"}
{"name":"Fin.rev_le_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (LE.le i.rev j) (LE.le j.rev i)","decl":"theorem rev_le_iff {i j : Fin n} : rev i ≤ j ↔ rev j ≤ i := by\n  rw [← rev_le_rev, rev_rev]\n\n"}
{"name":"Fin.lt_rev_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (LT.lt i j.rev) (LT.lt j i.rev)","decl":"theorem lt_rev_iff {i j : Fin n} : i < rev j ↔ j < rev i := by\n  rw [← rev_lt_rev, rev_rev]\n\n"}
{"name":"Fin.le_rev_iff","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni j : Fin n\n⊢ Iff (LE.le i j.rev) (LE.le j i.rev)","decl":"theorem le_rev_iff {i j : Fin n} : i ≤ rev j ↔ j ≤ rev i := by\n  rw [← rev_le_rev, rev_rev]\n\n-- Porting note: this is now syntactically equal to `val_last`\n\n"}
{"name":"Fin.val_rev_zero","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ Eq (↑(Fin.rev 0)) n.pred","decl":"@[simp] theorem val_rev_zero [NeZero n] : ((rev 0 : Fin n) : ℕ) = n.pred := rfl\n\n"}
{"name":"Fin.rev_pred","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : Ne i 0\nh' : optParam (Ne i.rev (Fin.last n)) ⋯\n⊢ Eq (i.pred h).rev (i.rev.castPred h')","decl":"theorem rev_pred {i : Fin (n + 1)} (h : i ≠ 0) (h' := rev_ne_iff.mpr ((rev_last _).symm ▸ h)) :\n    rev (pred i h) = castPred (rev i) h' := by\n  rw [← castSucc_inj, castSucc_castPred, ← rev_succ, succ_pred]\n\n"}
{"name":"Fin.rev_castPred","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : Ne i (Fin.last n)\nh' : optParam (Ne i.rev 0) ⋯\n⊢ Eq (i.castPred h).rev (i.rev.pred h')","decl":"theorem rev_castPred {i : Fin (n + 1)}\n    (h : i ≠ last n) (h' := rev_ne_iff.mpr ((rev_zero _).symm ▸ h)) :\n    rev (castPred i h) = pred (rev i) h' := by\n  rw [← succ_inj, succ_pred, ← rev_castSucc, castSucc_castPred]\n\n"}
{"name":"Fin.succAbove_rev_left","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq (p.rev.succAbove i) (p.succAbove i.rev).rev","decl":"lemma succAbove_rev_left (p : Fin (n + 1)) (i : Fin n) :\n    p.rev.succAbove i = (p.succAbove i.rev).rev := by\n  obtain h | h := (rev p).succ_le_or_le_castSucc i\n  · rw [succAbove_of_succ_le _ _ h,\n      succAbove_of_le_castSucc _ _ (rev_succ _ ▸ (le_rev_iff.mpr h)), rev_succ, rev_rev]\n  · rw [succAbove_of_le_castSucc _ _ h,\n      succAbove_of_succ_le _ _ (rev_castSucc _ ▸ (rev_le_iff.mpr h)), rev_castSucc, rev_rev]\n\n"}
{"name":"Fin.succAbove_rev_right","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq (p.succAbove i.rev) (p.rev.succAbove i).rev","decl":"lemma succAbove_rev_right (p : Fin (n + 1)) (i : Fin n) :\n    p.succAbove i.rev = (p.rev.succAbove i).rev := by rw [succAbove_rev_left, rev_rev]\n\n"}
{"name":"Fin.rev_succAbove","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq (p.succAbove i).rev (p.rev.succAbove i.rev)","decl":"/-- `rev` commutes with `succAbove`. -/\nlemma rev_succAbove (p : Fin (n + 1)) (i : Fin n) :\n    rev (succAbove p i) = succAbove (rev p) (rev i) := by\n  rw [succAbove_rev_left, rev_rev]\n\n"}
{"name":"Fin.predAbove_rev_left","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (p.rev.predAbove i) (p.predAbove i.rev).rev","decl":"lemma predAbove_rev_left (p : Fin n) (i : Fin (n + 1)) :\n    p.rev.predAbove i = (p.predAbove i.rev).rev := by\n  obtain h | h := (rev i).succ_le_or_le_castSucc p\n  · rw [predAbove_of_succ_le _ _ h, rev_pred,\n      predAbove_of_le_castSucc _ _ (rev_succ _ ▸ (le_rev_iff.mpr h)), castPred_inj, rev_rev]\n  · rw [predAbove_of_le_castSucc _ _ h, rev_castPred,\n      predAbove_of_succ_le _ _ (rev_castSucc _ ▸ (rev_le_iff.mpr h)), pred_inj, rev_rev]\n\n"}
{"name":"Fin.predAbove_rev_right","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (p.predAbove i.rev) (p.rev.predAbove i).rev","decl":"lemma predAbove_rev_right (p : Fin n) (i : Fin (n + 1)) :\n    p.predAbove i.rev = (p.rev.predAbove i).rev := by rw [predAbove_rev_left, rev_rev]\n\n"}
{"name":"Fin.rev_predAbove","module":"Mathlib.Data.Fin.Rev","initialProofState":"n : Nat\np : Fin n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (p.predAbove i).rev (p.rev.predAbove i.rev)","decl":"/-- `rev` commutes with `predAbove`. -/\nlemma rev_predAbove {n : ℕ} (p : Fin n) (i : Fin (n + 1)) :\n    (predAbove p i).rev = predAbove p.rev i.rev := by rw [predAbove_rev_left, rev_rev]\n\n"}
