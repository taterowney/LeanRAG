{"name":"CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_map","module":"Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\ninst‚úù¬≤ : W‚ÇÅ.IsMultiplicative\nD : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} D\nL : CategoryTheory.Functor C‚ÇÇ D\ninst‚úù : L.IsLocalization W‚ÇÇ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : D\ny : Quiver.Hom (L.obj X‚ÇÇ) X‚ÇÉ\nR R' : Œ¶.RightResolution X‚ÇÇ\nœÜ : Quiver.Hom R R'\n‚ä¢ Eq ((CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution Œ¶ L y).map œÜ) (CategoryTheory.CostructuredArrow.homMk (CategoryTheory.StructuredArrow.homMk œÜ.f ‚ãØ) ‚ãØ)","decl":"/-- Given `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`, `L : C‚ÇÇ ‚•§ D` a localization functor for `W‚ÇÇ` and\na morphism `y : L.obj X‚ÇÇ ‚ü∂ X‚ÇÉ`, this is the functor which sends `R : Œ¶.RightResolution d` to\n`(isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y` in the category `w.CostructuredArrowDownwards y`\nwhere `w` is `TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _) (Functor.rightUnitor _).inv`. -/\n@[simps]\nnoncomputable def fromRightResolution :\n    Œ¶.RightResolution X‚ÇÇ ‚•§ (TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _)\n      (Functor.rightUnitor _).inv).CostructuredArrowDownwards y where\n  obj R := CostructuredArrow.mk (Y := StructuredArrow.mk R.w)\n    (StructuredArrow.homMk ((isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y))\n  map {R R'} œÜ := CostructuredArrow.homMk (StructuredArrow.homMk œÜ.f) (by\n    ext\n    dsimp\n    rw [‚Üê assoc, ‚Üê cancel_epi (isoOfHom L W‚ÇÇ R.w R.hw).hom,\n      isoOfHom_hom, isoOfHom_hom_inv_id_assoc, assoc, ‚Üê L.map_comp_assoc,\n      œÜ.comm, isoOfHom_hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution_obj","module":"Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\ninst‚úù¬≤ : W‚ÇÅ.IsMultiplicative\nD : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} D\nL : CategoryTheory.Functor C‚ÇÇ D\ninst‚úù : L.IsLocalization W‚ÇÇ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : D\ny : Quiver.Hom (L.obj X‚ÇÇ) X‚ÇÉ\nR : Œ¶.RightResolution X‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.fromRightResolution Œ¶ L y).obj R) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.StructuredArrow.homMk (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W‚ÇÇ R.w ‚ãØ).inv y) ‚ãØ))","decl":"/-- Given `Œ¶ : LocalizerMorphism W‚ÇÅ W‚ÇÇ`, `L : C‚ÇÇ ‚•§ D` a localization functor for `W‚ÇÇ` and\na morphism `y : L.obj X‚ÇÇ ‚ü∂ X‚ÇÉ`, this is the functor which sends `R : Œ¶.RightResolution d` to\n`(isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y` in the category `w.CostructuredArrowDownwards y`\nwhere `w` is `TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _) (Functor.rightUnitor _).inv`. -/\n@[simps]\nnoncomputable def fromRightResolution :\n    Œ¶.RightResolution X‚ÇÇ ‚•§ (TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _)\n      (Functor.rightUnitor _).inv).CostructuredArrowDownwards y where\n  obj R := CostructuredArrow.mk (Y := StructuredArrow.mk R.w)\n    (StructuredArrow.homMk ((isoOfHom L W‚ÇÇ R.w R.hw).inv ‚â´ y))\n  map {R R'} œÜ := CostructuredArrow.homMk (StructuredArrow.homMk œÜ.f) (by\n    ext\n    dsimp\n    rw [‚Üê assoc, ‚Üê cancel_epi (isoOfHom L W‚ÇÇ R.w R.hw).hom,\n      isoOfHom_hom, isoOfHom_hom_inv_id_assoc, assoc, ‚Üê L.map_comp_assoc,\n      œÜ.comm, isoOfHom_hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.Constructor.isConnected","module":"Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_4, u_1} C‚ÇÅ\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_5, u_2} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\ninst‚úù‚Åµ : W‚ÇÅ.IsMultiplicative\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÇ : C‚ÇÇ), CategoryTheory.IsConnected (Œ¶.RightResolution X‚ÇÇ)\ninst‚úù¬≥ : Œ¶.arrow.HasRightResolutions\ninst‚úù¬≤ : W‚ÇÇ.ContainsIdentities\nD : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} D\nL : CategoryTheory.Functor C‚ÇÇ D\ninst‚úù : L.IsLocalization W‚ÇÇ\nX‚ÇÇ : C‚ÇÇ\nX‚ÇÉ : D\ny : Quiver.Hom (L.obj X‚ÇÇ) X‚ÇÉ\n‚ä¢ CategoryTheory.IsConnected ((CategoryTheory.TwoSquare.mk Œ¶.functor (Œ¶.functor.comp L) L (CategoryTheory.Functor.id D) (Œ¶.functor.comp L).rightUnitor.inv).CostructuredArrowDownwards y)","decl":"lemma isConnected :\n    IsConnected ((TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _)\n      (Functor.rightUnitor _).inv).CostructuredArrowDownwards y) := by\n  let w := (TwoSquare.mk Œ¶.functor (Œ¶.functor ‚ãô L) L (ùü≠ _) (Functor.rightUnitor _).inv)\n  have : Nonempty (w.CostructuredArrowDownwards y) :=\n    ‚ü®(fromRightResolution Œ¶ L y).obj (Classical.arbitrary _)‚ü©\n  suffices ‚àÄ (X : w.CostructuredArrowDownwards y),\n      ‚àÉ Y, Zigzag X ((fromRightResolution Œ¶ L y).obj Y) by\n    refine zigzag_isConnected (fun X X' => ?_)\n    obtain ‚ü®Y, hX‚ü© := this X\n    obtain ‚ü®Y', hX'‚ü© := this X'\n    exact hX.trans ((zigzag_obj_of_zigzag _ (isPreconnected_zigzag Y Y')).trans hX'.symm)\n  intro X\n  obtain ‚ü®c, g, x, fac, rfl‚ü© := TwoSquare.CostructuredArrowDownwards.mk_surjective X\n  dsimp [w] at x fac\n  rw [id_comp] at fac\n  let œÅ : Œ¶.arrow.RightResolution (Arrow.mk g) := Classical.arbitrary _\n  refine ‚ü®RightResolution.mk œÅ.w.left œÅ.hw.1, ?_‚ü©\n  have := zigzag_obj_of_zigzag\n    (fromRightResolution Œ¶ L x ‚ãô w.costructuredArrowDownwardsPrecomp x y g fac)\n      (isPreconnected_zigzag (RightResolution.mk (ùüô _) (W‚ÇÇ.id_mem _))\n        (RightResolution.mk œÅ.w.right œÅ.hw.2))\n  refine Zigzag.trans ?_ (Zigzag.trans this ?_)\n  ¬∑ exact Zigzag.of_hom (eqToHom (by simp))\n  ¬∑ apply Zigzag.of_inv\n    refine CostructuredArrow.homMk (StructuredArrow.homMk œÅ.X‚ÇÅ.hom (by simp)) ?_\n    ext\n    dsimp\n    rw [‚Üê cancel_epi (isoOfHom L W‚ÇÇ œÅ.w.left œÅ.hw.1).hom, isoOfHom_hom,\n      isoOfHom_hom_inv_id_assoc, ‚Üê L.map_comp_assoc, Arrow.w_mk_right, Arrow.mk_hom,\n      L.map_comp, assoc, isoOfHom_hom_inv_id_assoc, fac]\n\n"}
{"name":"CategoryTheory.LocalizerMorphism.IsRightDerivabilityStructure.mk'","module":"Mathlib.CategoryTheory.Localization.DerivabilityStructure.Constructor","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_2} C‚ÇÇ\nW‚ÇÅ : CategoryTheory.MorphismProperty C‚ÇÅ\nW‚ÇÇ : CategoryTheory.MorphismProperty C‚ÇÇ\nŒ¶ : CategoryTheory.LocalizerMorphism W‚ÇÅ W‚ÇÇ\ninst‚úù‚Å¥ : W‚ÇÅ.IsMultiplicative\ninst‚úù¬≥ : ‚àÄ (X‚ÇÇ : C‚ÇÇ), CategoryTheory.IsConnected (Œ¶.RightResolution X‚ÇÇ)\ninst‚úù¬≤ : Œ¶.arrow.HasRightResolutions\ninst‚úù¬π : W‚ÇÇ.ContainsIdentities\ninst‚úù : Œ¶.IsLocalizedEquivalence\n‚ä¢ Œ¶.IsRightDerivabilityStructure","decl":"/-- If a localizer morphism `Œ¶` is a localized equivalence, then it is a right\nderivability structure if the categories of right resolutions are connected and the\ncategories of right resolutions of arrows are nonempty. -/\nlemma mk' [Œ¶.IsLocalizedEquivalence] : Œ¶.IsRightDerivabilityStructure := by\n  rw [Œ¶.isRightDerivabilityStructure_iff (Œ¶.functor ‚ãô W‚ÇÇ.Q) W‚ÇÇ.Q (ùü≠ _)\n    (Functor.rightUnitor _).symm, TwoSquare.guitartExact_iff_isConnected_downwards]\n  intro X‚ÇÇ X‚ÇÉ g\n  apply Constructor.isConnected\n\n"}
