{"name":"AddOpposite.instIsAddRightCancel","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : IsLeftCancelAdd α\n⊢ IsRightCancelAdd (AddOpposite α)","decl":"@[to_additive]\ninstance instIsRightCancelMul [Mul α] [IsLeftCancelMul α] : IsRightCancelMul αᵐᵒᵖ where\n  mul_right_cancel _ _ _ h := unop_injective <| mul_left_cancel <| op_injective h\n\n"}
{"name":"MulOpposite.instIsRightCancelMul","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : IsLeftCancelMul α\n⊢ IsRightCancelMul (MulOpposite α)","decl":"@[to_additive]\ninstance instIsRightCancelMul [Mul α] [IsLeftCancelMul α] : IsRightCancelMul αᵐᵒᵖ where\n  mul_right_cancel _ _ _ h := unop_injective <| mul_left_cancel <| op_injective h\n\n"}
{"name":"AddOpposite.instIsAddLeftCancel","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : IsRightCancelAdd α\n⊢ IsLeftCancelAdd (AddOpposite α)","decl":"@[to_additive]\ninstance instIsLeftCancelMul [Mul α] [IsRightCancelMul α] : IsLeftCancelMul αᵐᵒᵖ where\n  mul_left_cancel _ _ _ h := unop_injective <| mul_right_cancel <| op_injective h\n\n"}
{"name":"MulOpposite.instIsLeftCancelMul","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : IsRightCancelMul α\n⊢ IsLeftCancelMul (MulOpposite α)","decl":"@[to_additive]\ninstance instIsLeftCancelMul [Mul α] [IsRightCancelMul α] : IsLeftCancelMul αᵐᵒᵖ where\n  mul_left_cancel _ _ _ h := unop_injective <| mul_right_cancel <| op_injective h\n\n"}
{"name":"MulOpposite.op_pow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nx : α\nn : Nat\n⊢ Eq (MulOpposite.op (HPow.hPow x n)) (HPow.hPow (MulOpposite.op x) n)","decl":"@[simp] lemma op_pow (x : α) (n : ℕ) : op (x ^ n) = op x ^ n := rfl\n\n"}
{"name":"MulOpposite.unop_pow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nx : MulOpposite α\nn : Nat\n⊢ Eq (MulOpposite.unop (HPow.hPow x n)) (HPow.hPow (MulOpposite.unop x) n)","decl":"@[simp] lemma unop_pow (x : αᵐᵒᵖ) (n : ℕ) : unop (x ^ n) = unop x ^ n := rfl\n\n"}
{"name":"MulOpposite.op_zpow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : DivInvMonoid α\nx : α\nz : Int\n⊢ Eq (MulOpposite.op (HPow.hPow x z)) (HPow.hPow (MulOpposite.op x) z)","decl":"@[simp] lemma op_zpow (x : α) (z : ℤ) : op (x ^ z) = op x ^ z := rfl\n\n"}
{"name":"MulOpposite.unop_zpow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : DivInvMonoid α\nx : MulOpposite α\nz : Int\n⊢ Eq (MulOpposite.unop (HPow.hPow x z)) (HPow.hPow (MulOpposite.unop x) z)","decl":"@[simp] lemma unop_zpow (x : αᵐᵒᵖ) (z : ℤ) : unop (x ^ z) = unop x ^ z := rfl\n\n"}
{"name":"MulOpposite.op_natCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (MulOpposite.op ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem op_natCast [NatCast α] (n : ℕ) : op (n : α) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.op_natCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (AddOpposite.op ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem op_natCast [NatCast α] (n : ℕ) : op (n : α) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.op_ofNat","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (AddOpposite.op (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[to_additive (attr := simp)]\ntheorem op_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    op (ofNat(n) : α) = ofNat(n) :=\n  rfl\n\n"}
{"name":"MulOpposite.op_ofNat","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (MulOpposite.op (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[to_additive (attr := simp)]\ntheorem op_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    op (ofNat(n) : α) = ofNat(n) :=\n  rfl\n\n"}
{"name":"MulOpposite.op_intCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : IntCast α\nn : Int\n⊢ Eq (MulOpposite.op ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem op_intCast [IntCast α] (n : ℤ) : op (n : α) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.op_intCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : IntCast α\nn : Int\n⊢ Eq (AddOpposite.op ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem op_intCast [IntCast α] (n : ℤ) : op (n : α) = n :=\n  rfl\n\n"}
{"name":"MulOpposite.unop_natCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (MulOpposite.unop ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem unop_natCast [NatCast α] (n : ℕ) : unop (n : αᵐᵒᵖ) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_natCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : NatCast α\nn : Nat\n⊢ Eq (AddOpposite.unop ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem unop_natCast [NatCast α] (n : ℕ) : unop (n : αᵐᵒᵖ) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_ofNat","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (AddOpposite.unop (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[to_additive (attr := simp)]\ntheorem unop_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    unop (ofNat(n) : αᵐᵒᵖ) = ofNat(n) :=\n  rfl\n\n"}
{"name":"MulOpposite.unop_ofNat","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝¹ : NatCast α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (MulOpposite.unop (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[to_additive (attr := simp)]\ntheorem unop_ofNat [NatCast α] (n : ℕ) [n.AtLeastTwo] :\n    unop (ofNat(n) : αᵐᵒᵖ) = ofNat(n) :=\n  rfl\n\n"}
{"name":"MulOpposite.unop_intCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : IntCast α\nn : Int\n⊢ Eq (MulOpposite.unop ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem unop_intCast [IntCast α] (n : ℤ) : unop (n : αᵐᵒᵖ) = n :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_intCast","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : IntCast α\nn : Int\n⊢ Eq (AddOpposite.unop ↑n) ↑n","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem unop_intCast [IntCast α] (n : ℤ) : unop (n : αᵐᵒᵖ) = n :=\n  rfl\n\n"}
{"name":"MulOpposite.unop_div","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : DivInvMonoid α\nx y : MulOpposite α\n⊢ Eq (MulOpposite.unop (HDiv.hDiv x y)) (HMul.hMul (Inv.inv (MulOpposite.unop y)) (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem unop_div [DivInvMonoid α] (x y : αᵐᵒᵖ) : unop (x / y) = (unop y)⁻¹ * unop x :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_sub","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : SubNegMonoid α\nx y : AddOpposite α\n⊢ Eq (AddOpposite.unop (HSub.hSub x y)) (HAdd.hAdd (Neg.neg (AddOpposite.unop y)) (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem unop_div [DivInvMonoid α] (x y : αᵐᵒᵖ) : unop (x / y) = (unop y)⁻¹ * unop x :=\n  rfl\n\n"}
{"name":"AddOpposite.op_sub","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : SubNegMonoid α\nx y : α\n⊢ Eq (AddOpposite.op (HSub.hSub x y)) (HAdd.hAdd (Neg.neg (AddOpposite.op y)) (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem op_div [DivInvMonoid α] (x y : α) : op (x / y) = (op y)⁻¹ * op x := by simp [div_eq_mul_inv]\n\n"}
{"name":"MulOpposite.op_div","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : DivInvMonoid α\nx y : α\n⊢ Eq (MulOpposite.op (HDiv.hDiv x y)) (HMul.hMul (Inv.inv (MulOpposite.op y)) (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem op_div [DivInvMonoid α] (x y : α) : op (x / y) = (op y)⁻¹ * op x := by simp [div_eq_mul_inv]\n\n"}
{"name":"MulOpposite.semiconjBy_op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\na x y : α\n⊢ Iff (SemiconjBy (MulOpposite.op a) (MulOpposite.op y) (MulOpposite.op x)) (SemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem semiconjBy_op [Mul α] {a x y : α} : SemiconjBy (op a) (op y) (op x) ↔ SemiconjBy a x y := by\n  simp only [SemiconjBy, ← op_mul, op_inj, eq_comm]\n\n"}
{"name":"AddOpposite.addSemiconjBy_op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\na x y : α\n⊢ Iff (AddSemiconjBy (AddOpposite.op a) (AddOpposite.op y) (AddOpposite.op x)) (AddSemiconjBy a x y)","decl":"@[to_additive (attr := simp)]\ntheorem semiconjBy_op [Mul α] {a x y : α} : SemiconjBy (op a) (op y) (op x) ↔ SemiconjBy a x y := by\n  simp only [SemiconjBy, ← op_mul, op_inj, eq_comm]\n\n"}
{"name":"MulOpposite.semiconjBy_unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\na x y : MulOpposite α\n⊢ Iff (SemiconjBy (MulOpposite.unop a) (MulOpposite.unop y) (MulOpposite.unop x)) (SemiconjBy a x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem semiconjBy_unop [Mul α] {a x y : αᵐᵒᵖ} :\n    SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y := by\n  conv_rhs => rw [← op_unop a, ← op_unop x, ← op_unop y, semiconjBy_op]\n\n"}
{"name":"AddOpposite.addSemiconjBy_unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\na x y : AddOpposite α\n⊢ Iff (AddSemiconjBy (AddOpposite.unop a) (AddOpposite.unop y) (AddOpposite.unop x)) (AddSemiconjBy a x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem semiconjBy_unop [Mul α] {a x y : αᵐᵒᵖ} :\n    SemiconjBy (unop a) (unop y) (unop x) ↔ SemiconjBy a x y := by\n  conv_rhs => rw [← op_unop a, ← op_unop x, ← op_unop y, semiconjBy_op]\n\n"}
{"name":"AddSemiconjBy.op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\na x y : α\nh : AddSemiconjBy a x y\n⊢ AddSemiconjBy (AddOpposite.op a) (AddOpposite.op y) (AddOpposite.op x)","decl":"@[to_additive]\ntheorem _root_.SemiconjBy.op [Mul α] {a x y : α} (h : SemiconjBy a x y) :\n    SemiconjBy (op a) (op y) (op x) :=\n  semiconjBy_op.2 h\n\n"}
{"name":"SemiconjBy.op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\na x y : α\nh : SemiconjBy a x y\n⊢ SemiconjBy (MulOpposite.op a) (MulOpposite.op y) (MulOpposite.op x)","decl":"@[to_additive]\ntheorem _root_.SemiconjBy.op [Mul α] {a x y : α} (h : SemiconjBy a x y) :\n    SemiconjBy (op a) (op y) (op x) :=\n  semiconjBy_op.2 h\n\n"}
{"name":"SemiconjBy.unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\na x y : MulOpposite α\nh : SemiconjBy a x y\n⊢ SemiconjBy (MulOpposite.unop a) (MulOpposite.unop y) (MulOpposite.unop x)","decl":"@[to_additive]\ntheorem _root_.SemiconjBy.unop [Mul α] {a x y : αᵐᵒᵖ} (h : SemiconjBy a x y) :\n    SemiconjBy (unop a) (unop y) (unop x) :=\n  semiconjBy_unop.2 h\n\n"}
{"name":"AddSemiconjBy.unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\na x y : AddOpposite α\nh : AddSemiconjBy a x y\n⊢ AddSemiconjBy (AddOpposite.unop a) (AddOpposite.unop y) (AddOpposite.unop x)","decl":"@[to_additive]\ntheorem _root_.SemiconjBy.unop [Mul α] {a x y : αᵐᵒᵖ} (h : SemiconjBy a x y) :\n    SemiconjBy (unop a) (unop y) (unop x) :=\n  semiconjBy_unop.2 h\n\n"}
{"name":"AddCommute.op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : α\nh : AddCommute x y\n⊢ AddCommute (AddOpposite.op x) (AddOpposite.op y)","decl":"@[to_additive]\ntheorem _root_.Commute.op [Mul α] {x y : α} (h : Commute x y) : Commute (op x) (op y) :=\n  SemiconjBy.op h\n\n"}
{"name":"Commute.op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : α\nh : Commute x y\n⊢ Commute (MulOpposite.op x) (MulOpposite.op y)","decl":"@[to_additive]\ntheorem _root_.Commute.op [Mul α] {x y : α} (h : Commute x y) : Commute (op x) (op y) :=\n  SemiconjBy.op h\n\n"}
{"name":"AddCommute.unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : AddOpposite α\nh : AddCommute x y\n⊢ AddCommute (AddOpposite.unop x) (AddOpposite.unop y)","decl":"@[to_additive]\nnonrec theorem _root_.Commute.unop [Mul α] {x y : αᵐᵒᵖ} (h : Commute x y) :\n    Commute (unop x) (unop y) :=\n  h.unop\n\n"}
{"name":"Commute.unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : MulOpposite α\nh : Commute x y\n⊢ Commute (MulOpposite.unop x) (MulOpposite.unop y)","decl":"@[to_additive]\nnonrec theorem _root_.Commute.unop [Mul α] {x y : αᵐᵒᵖ} (h : Commute x y) :\n    Commute (unop x) (unop y) :=\n  h.unop\n\n"}
{"name":"AddOpposite.addCommute_op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : α\n⊢ Iff (AddCommute (AddOpposite.op x) (AddOpposite.op y)) (AddCommute x y)","decl":"@[to_additive (attr := simp)]\ntheorem commute_op [Mul α] {x y : α} : Commute (op x) (op y) ↔ Commute x y :=\n  semiconjBy_op\n\n"}
{"name":"MulOpposite.commute_op","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : α\n⊢ Iff (Commute (MulOpposite.op x) (MulOpposite.op y)) (Commute x y)","decl":"@[to_additive (attr := simp)]\ntheorem commute_op [Mul α] {x y : α} : Commute (op x) (op y) ↔ Commute x y :=\n  semiconjBy_op\n\n"}
{"name":"AddOpposite.addCommute_unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\nx y : AddOpposite α\n⊢ Iff (AddCommute (AddOpposite.unop x) (AddOpposite.unop y)) (AddCommute x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem commute_unop [Mul α] {x y : αᵐᵒᵖ} : Commute (unop x) (unop y) ↔ Commute x y :=\n  semiconjBy_unop\n\n"}
{"name":"MulOpposite.commute_unop","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\nx y : MulOpposite α\n⊢ Iff (Commute (MulOpposite.unop x) (MulOpposite.unop y)) (Commute x y)","decl":"@[to_additive (attr := simp, nolint simpComm)]\ntheorem commute_unop [Mul α] {x y : αᵐᵒᵖ} : Commute (unop x) (unop y) ↔ Commute x y :=\n  semiconjBy_unop\n\n"}
{"name":"MulOpposite.opAddEquiv_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\n⊢ Eq (⇑MulOpposite.opAddEquiv.symm) MulOpposite.unop","decl":"/-- The function `MulOpposite.op` is an additive equivalence. -/\n@[simps! (config := { fullyApplied := false, simpRhs := true }) apply symm_apply]\ndef opAddEquiv [Add α] : α ≃+ αᵐᵒᵖ :=\n  { opEquiv with map_add' := fun _ _ => rfl }\n\n"}
{"name":"MulOpposite.opAddEquiv_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\n⊢ Eq (⇑MulOpposite.opAddEquiv) MulOpposite.op","decl":"/-- The function `MulOpposite.op` is an additive equivalence. -/\n@[simps! (config := { fullyApplied := false, simpRhs := true }) apply symm_apply]\ndef opAddEquiv [Add α] : α ≃+ αᵐᵒᵖ :=\n  { opEquiv with map_add' := fun _ _ => rfl }\n\n"}
{"name":"MulOpposite.opAddEquiv_toEquiv","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Add α\n⊢ Eq (↑MulOpposite.opAddEquiv) MulOpposite.opEquiv","decl":"@[simp]\ntheorem opAddEquiv_toEquiv [Add α] : ((opAddEquiv : α ≃+ αᵐᵒᵖ) : α ≃ αᵐᵒᵖ) = opEquiv := rfl\n\n"}
{"name":"AddOpposite.op_pow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Pow α β\na : α\nb : β\n⊢ Eq (AddOpposite.op (HPow.hPow a b)) (HPow.hPow (AddOpposite.op a) b)","decl":"@[simp]\ntheorem op_pow {β} [Pow α β] (a : α) (b : β) : op (a ^ b) = op a ^ b :=\n  rfl\n\n"}
{"name":"AddOpposite.unop_pow","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Pow α β\na : AddOpposite α\nb : β\n⊢ Eq (AddOpposite.unop (HPow.hPow a b)) (HPow.hPow (AddOpposite.unop a) b)","decl":"@[simp]\ntheorem unop_pow {β} [Pow α β] (a : αᵃᵒᵖ) (b : β) : unop (a ^ b) = unop a ^ b :=\n  rfl\n\n"}
{"name":"AddOpposite.opMulEquiv_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ Eq (⇑AddOpposite.opMulEquiv) AddOpposite.op","decl":"/-- The function `AddOpposite.op` is a multiplicative equivalence. -/\n@[simps! (config := { fullyApplied := false, simpRhs := true })]\ndef opMulEquiv [Mul α] : α ≃* αᵃᵒᵖ :=\n  { opEquiv with map_mul' := fun _ _ => rfl }\n\n"}
{"name":"AddOpposite.opMulEquiv_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ Eq (⇑AddOpposite.opMulEquiv.symm) AddOpposite.unop","decl":"/-- The function `AddOpposite.op` is a multiplicative equivalence. -/\n@[simps! (config := { fullyApplied := false, simpRhs := true })]\ndef opMulEquiv [Mul α] : α ≃* αᵃᵒᵖ :=\n  { opEquiv with map_mul' := fun _ _ => rfl }\n\n"}
{"name":"AddOpposite.opMulEquiv_toEquiv","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ Eq (↑AddOpposite.opMulEquiv) AddOpposite.opEquiv","decl":"@[simp]\ntheorem opMulEquiv_toEquiv [Mul α] : ((opMulEquiv : α ≃* αᵃᵒᵖ) : α ≃ αᵃᵒᵖ) = opEquiv :=\n  rfl\n\n"}
{"name":"AddEquiv.neg'_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"G : Type u_2\ninst✝ : SubtractionMonoid G\n⊢ Eq (⇑(AddEquiv.neg' G).symm) (Function.comp Neg.neg AddOpposite.unop)","decl":"/-- Inversion on a group is a `MulEquiv` to the opposite group. When `G` is commutative, there is\n`MulEquiv.inv`. -/\n@[to_additive (attr := simps! (config := { fullyApplied := false, simpRhs := true }))\n      \"Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\n      is commutative, there is `AddEquiv.inv`.\"]\ndef MulEquiv.inv' (G : Type*) [DivisionMonoid G] : G ≃* Gᵐᵒᵖ :=\n  { (Equiv.inv G).trans opEquiv with map_mul' := fun x y => unop_injective <| mul_inv_rev x y }\n\n"}
{"name":"MulEquiv.inv'_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"G : Type u_2\ninst✝ : DivisionMonoid G\n⊢ Eq (⇑(MulEquiv.inv' G)) (Function.comp MulOpposite.op Inv.inv)","decl":"/-- Inversion on a group is a `MulEquiv` to the opposite group. When `G` is commutative, there is\n`MulEquiv.inv`. -/\n@[to_additive (attr := simps! (config := { fullyApplied := false, simpRhs := true }))\n      \"Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\n      is commutative, there is `AddEquiv.inv`.\"]\ndef MulEquiv.inv' (G : Type*) [DivisionMonoid G] : G ≃* Gᵐᵒᵖ :=\n  { (Equiv.inv G).trans opEquiv with map_mul' := fun x y => unop_injective <| mul_inv_rev x y }\n\n"}
{"name":"MulEquiv.inv'_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"G : Type u_2\ninst✝ : DivisionMonoid G\n⊢ Eq (⇑(MulEquiv.inv' G).symm) (Function.comp Inv.inv MulOpposite.unop)","decl":"/-- Inversion on a group is a `MulEquiv` to the opposite group. When `G` is commutative, there is\n`MulEquiv.inv`. -/\n@[to_additive (attr := simps! (config := { fullyApplied := false, simpRhs := true }))\n      \"Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\n      is commutative, there is `AddEquiv.inv`.\"]\ndef MulEquiv.inv' (G : Type*) [DivisionMonoid G] : G ≃* Gᵐᵒᵖ :=\n  { (Equiv.inv G).trans opEquiv with map_mul' := fun x y => unop_injective <| mul_inv_rev x y }\n\n"}
{"name":"AddEquiv.neg'_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"G : Type u_2\ninst✝ : SubtractionMonoid G\n⊢ Eq (⇑(AddEquiv.neg' G)) (Function.comp AddOpposite.op Neg.neg)","decl":"/-- Inversion on a group is a `MulEquiv` to the opposite group. When `G` is commutative, there is\n`MulEquiv.inv`. -/\n@[to_additive (attr := simps! (config := { fullyApplied := false, simpRhs := true }))\n      \"Negation on an additive group is an `AddEquiv` to the opposite group. When `G`\n      is commutative, there is `AddEquiv.inv`.\"]\ndef MulEquiv.inv' (G : Type*) [DivisionMonoid G] : G ≃* Gᵐᵒᵖ :=\n  { (Equiv.inv G).trans opEquiv with map_mul' := fun x y => unop_injective <| mul_inv_rev x y }\n\n"}
{"name":"MulHom.toOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : ∀ (x y : M), Commute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp MulOpposite.op ⇑f)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism to `Nᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `Sᵃᵒᵖ`.\"]\ndef MulHom.toOpposite {M N : Type*} [Mul M] [Mul N] (f : M →ₙ* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : M →ₙ* Nᵐᵒᵖ where\n  toFun := op ∘ f\n  map_mul' x y := by simp [(hf x y).eq]\n\n"}
{"name":"AddHom.toOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : ∀ (x y : M), AddCommute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp AddOpposite.op ⇑f)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism to `Nᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x, y` defines an additive semigroup homomorphism to `Sᵃᵒᵖ`.\"]\ndef MulHom.toOpposite {M N : Type*} [Mul M] [Mul N] (f : M →ₙ* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : M →ₙ* Nᵐᵒᵖ where\n  toFun := op ∘ f\n  map_mul' x y := by simp [(hf x y).eq]\n\n"}
{"name":"MulHom.fromOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\nhf : ∀ (x y : M), Commute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) MulOpposite.unop)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism from `Mᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x`, `y` defines an additive semigroup homomorphism from `Mᵃᵒᵖ`.\"]\ndef MulHom.fromOpposite {M N : Type*} [Mul M] [Mul N] (f : M →ₙ* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : Mᵐᵒᵖ →ₙ* N where\n  toFun := f ∘ MulOpposite.unop\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq\n\n"}
{"name":"AddHom.fromOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\nhf : ∀ (x y : M), AddCommute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) AddOpposite.unop)","decl":"/-- A semigroup homomorphism `f : M →ₙ* N` such that `f x` commutes with `f y` for all `x, y`\ndefines a semigroup homomorphism from `Mᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive semigroup homomorphism `f : AddHom M N` such that `f x` additively\n      commutes with `f y` for all `x`, `y` defines an additive semigroup homomorphism from `Mᵃᵒᵖ`.\"]\ndef MulHom.fromOpposite {M N : Type*} [Mul M] [Mul N] (f : M →ₙ* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : Mᵐᵒᵖ →ₙ* N where\n  toFun := f ∘ MulOpposite.unop\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq\n\n"}
{"name":"MonoidHom.toOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nhf : ∀ (x y : M), Commute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp MulOpposite.op ⇑f)","decl":"/-- A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism to `Nᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\n      with `f y` for all `x, y` defines an additive monoid homomorphism to `Sᵃᵒᵖ`.\"]\ndef MonoidHom.toOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : M →* Nᵐᵒᵖ where\n  toFun := op ∘ f\n  map_one' := congrArg op f.map_one\n  map_mul' x y := by simp [(hf x y).eq]\n\n"}
{"name":"AddMonoidHom.toOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nhf : ∀ (x y : M), AddCommute (f x) (f y)\n⊢ Eq (⇑(f.toOpposite hf)) (Function.comp AddOpposite.op ⇑f)","decl":"/-- A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism to `Nᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\n      with `f y` for all `x, y` defines an additive monoid homomorphism to `Sᵃᵒᵖ`.\"]\ndef MonoidHom.toOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : M →* Nᵐᵒᵖ where\n  toFun := op ∘ f\n  map_one' := congrArg op f.map_one\n  map_mul' x y := by simp [(hf x y).eq]\n\n"}
{"name":"MonoidHom.fromOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\nhf : ∀ (x y : M), Commute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) MulOpposite.unop)","decl":"/-- A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism from `Mᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\n      with `f y` for all `x`, `y` defines an additive monoid homomorphism from `Mᵃᵒᵖ`.\"]\ndef MonoidHom.fromOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : Mᵐᵒᵖ →* N where\n  toFun := f ∘ MulOpposite.unop\n  map_one' := f.map_one\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq\n\n"}
{"name":"AddMonoidHom.fromOpposite_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\nhf : ∀ (x y : M), AddCommute (f x) (f y)\n⊢ Eq (⇑(f.fromOpposite hf)) (Function.comp (⇑f) AddOpposite.unop)","decl":"/-- A monoid homomorphism `f : M →* N` such that `f x` commutes with `f y` for all `x, y` defines\na monoid homomorphism from `Mᵐᵒᵖ`. -/\n@[to_additive (attr := simps (config := .asFn))\n      \"An additive monoid homomorphism `f : M →+ N` such that `f x` additively commutes\n      with `f y` for all `x`, `y` defines an additive monoid homomorphism from `Mᵃᵒᵖ`.\"]\ndef MonoidHom.fromOpposite {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M →* N)\n    (hf : ∀ x y, Commute (f x) (f y)) : Mᵐᵒᵖ →* N where\n  toFun := f ∘ MulOpposite.unop\n  map_one' := f.map_one\n  map_mul' _ _ := (f.map_mul _ _).trans (hf _ _).eq\n\n"}
{"name":"AddHom.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom (AddOpposite M) (AddOpposite N)\na✝ : M\n⊢ Eq ((AddHom.op.symm f) a✝) (Function.comp AddOpposite.unop (Function.comp (⇑f) AddOpposite.op) a✝)","decl":"/-- A semigroup homomorphism `M →ₙ* N` can equivalently be viewed as a semigroup homomorphism\n`Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\n      additive semigroup homomorphism `AddHom Mᵃᵒᵖ Nᵃᵒᵖ`. This is the action of the\n      (fully faithful)`ᵃᵒᵖ`-functor on morphisms.\"]\ndef MulHom.op {M N} [Mul M] [Mul N] : (M →ₙ* N) ≃ (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddHom.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\na✝ : AddOpposite M\n⊢ Eq ((AddHom.op f) a✝) (Function.comp AddOpposite.op (Function.comp (⇑f) AddOpposite.unop) a✝)","decl":"/-- A semigroup homomorphism `M →ₙ* N` can equivalently be viewed as a semigroup homomorphism\n`Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\n      additive semigroup homomorphism `AddHom Mᵃᵒᵖ Nᵃᵒᵖ`. This is the action of the\n      (fully faithful)`ᵃᵒᵖ`-functor on morphisms.\"]\ndef MulHom.op {M N} [Mul M] [Mul N] : (M →ₙ* N) ≃ (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulHom.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom M N\na✝ : MulOpposite M\n⊢ Eq ((MulHom.op f) a✝) (Function.comp MulOpposite.op (Function.comp (⇑f) MulOpposite.unop) a✝)","decl":"/-- A semigroup homomorphism `M →ₙ* N` can equivalently be viewed as a semigroup homomorphism\n`Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\n      additive semigroup homomorphism `AddHom Mᵃᵒᵖ Nᵃᵒᵖ`. This is the action of the\n      (fully faithful)`ᵃᵒᵖ`-functor on morphisms.\"]\ndef MulHom.op {M N} [Mul M] [Mul N] : (M →ₙ* N) ≃ (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulHom.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulHom (MulOpposite M) (MulOpposite N)\na✝ : M\n⊢ Eq ((MulHom.op.symm f) a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f) MulOpposite.op) a✝)","decl":"/-- A semigroup homomorphism `M →ₙ* N` can equivalently be viewed as a semigroup homomorphism\n`Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an\n      additive semigroup homomorphism `AddHom Mᵃᵒᵖ Nᵃᵒᵖ`. This is the action of the\n      (fully faithful)`ᵃᵒᵖ`-functor on morphisms.\"]\ndef MulHom.op {M N} [Mul M] [Mul N] : (M →ₙ* N) ≃ (Mᵐᵒᵖ →ₙ* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddHom.mulOp_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom (MulOpposite M) (MulOpposite N)\na✝ : M\n⊢ Eq ((AddHom.mulOp.symm f) a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f) MulOpposite.op) a✝)","decl":"/-- An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an additive\nhomomorphism `AddHom Mᵐᵒᵖ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on\nmorphisms. -/\n@[simps]\ndef AddHom.mulOp {M N} [Add M] [Add N] : AddHom M N ≃ AddHom Mᵐᵒᵖ Nᵐᵒᵖ where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ MulOpposite.unop,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop ∘ f ∘ MulOpposite.op,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddHom.mulOp_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddHom M N\na✝ : MulOpposite M\n⊢ Eq ((AddHom.mulOp f) a✝) (Function.comp MulOpposite.op (Function.comp (⇑f) MulOpposite.unop) a✝)","decl":"/-- An additive semigroup homomorphism `AddHom M N` can equivalently be viewed as an additive\nhomomorphism `AddHom Mᵐᵒᵖ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on\nmorphisms. -/\n@[simps]\ndef AddHom.mulOp {M N} [Add M] [Add N] : AddHom M N ≃ AddHom Mᵐᵒᵖ Nᵐᵒᵖ where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ MulOpposite.unop,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop ∘ f ∘ MulOpposite.op,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddMonoidHom.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\na✝ : AddOpposite M\n⊢ Eq ((AddMonoidHom.op f) a✝) (Function.comp AddOpposite.op (Function.comp (⇑f) AddOpposite.unop) a✝)","decl":"/-- A monoid homomorphism `M →* N` can equivalently be viewed as a monoid homomorphism\n`Mᵐᵒᵖ →* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive monoid homomorphism `M →+ N` can equivalently be viewed as an\n      additive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. This is the action of the (fully faithful)\n      `ᵃᵒᵖ`-functor on morphisms.\"]\ndef MonoidHom.op {M N} [MulOneClass M] [MulOneClass N] : (M →* N) ≃ (Mᵐᵒᵖ →* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, map_one' := congrArg MulOpposite.op f.map_one,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, map_one' := congrArg unop f.map_one,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MonoidHom.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom M N\na✝ : MulOpposite M\n⊢ Eq ((MonoidHom.op f) a✝) (Function.comp MulOpposite.op (Function.comp (⇑f) MulOpposite.unop) a✝)","decl":"/-- A monoid homomorphism `M →* N` can equivalently be viewed as a monoid homomorphism\n`Mᵐᵒᵖ →* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive monoid homomorphism `M →+ N` can equivalently be viewed as an\n      additive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. This is the action of the (fully faithful)\n      `ᵃᵒᵖ`-functor on morphisms.\"]\ndef MonoidHom.op {M N} [MulOneClass M] [MulOneClass N] : (M →* N) ≃ (Mᵐᵒᵖ →* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, map_one' := congrArg MulOpposite.op f.map_one,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, map_one' := congrArg unop f.map_one,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddMonoidHom.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom (AddOpposite M) (AddOpposite N)\na✝ : M\n⊢ Eq ((AddMonoidHom.op.symm f) a✝) (Function.comp AddOpposite.unop (Function.comp (⇑f) AddOpposite.op) a✝)","decl":"/-- A monoid homomorphism `M →* N` can equivalently be viewed as a monoid homomorphism\n`Mᵐᵒᵖ →* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive monoid homomorphism `M →+ N` can equivalently be viewed as an\n      additive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. This is the action of the (fully faithful)\n      `ᵃᵒᵖ`-functor on morphisms.\"]\ndef MonoidHom.op {M N} [MulOneClass M] [MulOneClass N] : (M →* N) ≃ (Mᵐᵒᵖ →* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, map_one' := congrArg MulOpposite.op f.map_one,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, map_one' := congrArg unop f.map_one,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MonoidHom.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : MulOneClass N\nf : MonoidHom (MulOpposite M) (MulOpposite N)\na✝ : M\n⊢ Eq ((MonoidHom.op.symm f) a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f) MulOpposite.op) a✝)","decl":"/-- A monoid homomorphism `M →* N` can equivalently be viewed as a monoid homomorphism\n`Mᵐᵒᵖ →* Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[to_additive (attr := simps)\n      \"An additive monoid homomorphism `M →+ N` can equivalently be viewed as an\n      additive monoid homomorphism `Mᵃᵒᵖ →+ Nᵃᵒᵖ`. This is the action of the (fully faithful)\n      `ᵃᵒᵖ`-functor on morphisms.\"]\ndef MonoidHom.op {M N} [MulOneClass M] [MulOneClass N] : (M →* N) ≃ (Mᵐᵒᵖ →* Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, map_one' := congrArg MulOpposite.op f.map_one,\n      map_mul' := fun x y => unop_injective (f.map_mul y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, map_one' := congrArg unop f.map_one,\n      map_mul' := fun x y => congrArg unop (f.map_mul (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulEquiv.opOp_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\ninst✝ : Mul M\na✝ : M\n⊢ Eq ((MulEquiv.opOp M) a✝) (MulOpposite.op (MulOpposite.op a✝))","decl":"/-- A monoid is isomorphic to the opposite of its opposite. -/\n@[to_additive (attr := simps!)\n      \"A additive monoid is isomorphic to the opposite of its opposite.\"]\ndef MulEquiv.opOp (M : Type*) [Mul M] : M ≃* Mᵐᵒᵖᵐᵒᵖ where\n  __ := MulOpposite.opEquiv.trans MulOpposite.opEquiv\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.opOp_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\ninst✝ : Mul M\na✝ : MulOpposite (MulOpposite M)\n⊢ Eq ((MulEquiv.opOp M).symm a✝) (MulOpposite.unop (MulOpposite.unop a✝))","decl":"/-- A monoid is isomorphic to the opposite of its opposite. -/\n@[to_additive (attr := simps!)\n      \"A additive monoid is isomorphic to the opposite of its opposite.\"]\ndef MulEquiv.opOp (M : Type*) [Mul M] : M ≃* Mᵐᵒᵖᵐᵒᵖ where\n  __ := MulOpposite.opEquiv.trans MulOpposite.opEquiv\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.opOp_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\ninst✝ : Add M\na✝ : M\n⊢ Eq ((AddEquiv.opOp M) a✝) (AddOpposite.op (AddOpposite.op a✝))","decl":"/-- A monoid is isomorphic to the opposite of its opposite. -/\n@[to_additive (attr := simps!)\n      \"A additive monoid is isomorphic to the opposite of its opposite.\"]\ndef MulEquiv.opOp (M : Type*) [Mul M] : M ≃* Mᵐᵒᵖᵐᵒᵖ where\n  __ := MulOpposite.opEquiv.trans MulOpposite.opEquiv\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.opOp_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\ninst✝ : Add M\na✝ : AddOpposite (AddOpposite M)\n⊢ Eq ((AddEquiv.opOp M).symm a✝) (AddOpposite.unop (AddOpposite.unop a✝))","decl":"/-- A monoid is isomorphic to the opposite of its opposite. -/\n@[to_additive (attr := simps!)\n      \"A additive monoid is isomorphic to the opposite of its opposite.\"]\ndef MulEquiv.opOp (M : Type*) [Mul M] : M ≃* Mᵐᵒᵖᵐᵒᵖ where\n  __ := MulOpposite.opEquiv.trans MulOpposite.opEquiv\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddMonoidHom.mulOp_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom M N\na✝ : MulOpposite M\n⊢ Eq ((AddMonoidHom.mulOp f) a✝) (Function.comp MulOpposite.op (Function.comp (⇑f) MulOpposite.unop) a✝)","decl":"/-- An additive homomorphism `M →+ N` can equivalently be viewed as an additive homomorphism\n`Mᵐᵒᵖ →+ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps]\ndef AddMonoidHom.mulOp {M N} [AddZeroClass M] [AddZeroClass N] : (M →+ N) ≃ (Mᵐᵒᵖ →+ Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ MulOpposite.unop, map_zero' := unop_injective f.map_zero,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop ∘ f ∘ MulOpposite.op,\n      map_zero' := congrArg MulOpposite.unop f.map_zero,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddMonoidHom.mulOp_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddZeroClass N\nf : AddMonoidHom (MulOpposite M) (MulOpposite N)\na✝ : M\n⊢ Eq ((AddMonoidHom.mulOp.symm f) a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f) MulOpposite.op) a✝)","decl":"/-- An additive homomorphism `M →+ N` can equivalently be viewed as an additive homomorphism\n`Mᵐᵒᵖ →+ Nᵐᵒᵖ`. This is the action of the (fully faithful) `ᵐᵒᵖ`-functor on morphisms. -/\n@[simps]\ndef AddMonoidHom.mulOp {M N} [AddZeroClass M] [AddZeroClass N] : (M →+ N) ≃ (Mᵐᵒᵖ →+ Nᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ MulOpposite.unop, map_zero' := unop_injective f.map_zero,\n      map_add' := fun x y => unop_injective (f.map_add x.unop y.unop) }\n  invFun f :=\n    { toFun := MulOpposite.unop ∘ f ∘ MulOpposite.op,\n      map_zero' := congrArg MulOpposite.unop f.map_zero,\n      map_add' :=\n        fun x y => congrArg MulOpposite.unop (f.map_add (MulOpposite.op x) (MulOpposite.op y)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.mulOp_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv (MulOpposite α) (MulOpposite β)\n⊢ Eq (AddEquiv.mulOp.symm f) (MulOpposite.opAddEquiv.trans (f.trans MulOpposite.opAddEquiv.symm))","decl":"/-- An iso `α ≃+ β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃+ βᵐᵒᵖ`. -/\n@[simps]\ndef AddEquiv.mulOp {α β} [Add α] [Add β] : α ≃+ β ≃ (αᵐᵒᵖ ≃+ βᵐᵒᵖ) where\n  toFun f := opAddEquiv.symm.trans (f.trans opAddEquiv)\n  invFun f := opAddEquiv.trans (f.trans opAddEquiv.symm)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.mulOp_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\n⊢ Eq (AddEquiv.mulOp f) (MulOpposite.opAddEquiv.symm.trans (f.trans MulOpposite.opAddEquiv))","decl":"/-- An iso `α ≃+ β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃+ βᵐᵒᵖ`. -/\n@[simps]\ndef AddEquiv.mulOp {α β} [Add α] [Add β] : α ≃+ β ≃ (αᵐᵒᵖ ≃+ βᵐᵒᵖ) where\n  toFun f := opAddEquiv.symm.trans (f.trans opAddEquiv)\n  invFun f := opAddEquiv.trans (f.trans opAddEquiv.symm)\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.op_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv (AddOpposite α) (AddOpposite β)\na✝ : β\n⊢ Eq ((AddEquiv.op.symm f).symm a✝) (Function.comp AddOpposite.unop (Function.comp (⇑f.symm) AddOpposite.op) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.op_apply_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\na✝ : AddOpposite β\n⊢ Eq ((AddEquiv.op f).symm a✝) (Function.comp AddOpposite.op (Function.comp (⇑f.symm) AddOpposite.unop) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulEquiv.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulEquiv α β\na✝ : MulOpposite α\n⊢ Eq ((MulEquiv.op f) a✝) (Function.comp MulOpposite.op (Function.comp (⇑f) MulOpposite.unop) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulEquiv.op_symm_apply_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulEquiv (MulOpposite α) (MulOpposite β)\na✝ : β\n⊢ Eq ((MulEquiv.op.symm f).symm a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f.symm) MulOpposite.op) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulEquiv.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulEquiv (MulOpposite α) (MulOpposite β)\na✝ : α\n⊢ Eq ((MulEquiv.op.symm f) a✝) (Function.comp MulOpposite.unop (Function.comp (⇑f) MulOpposite.op) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.op_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv α β\na✝ : AddOpposite α\n⊢ Eq ((AddEquiv.op f) a✝) (Function.comp AddOpposite.op (Function.comp (⇑f) AddOpposite.unop) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"MulEquiv.op_apply_symm_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : MulEquiv α β\na✝ : MulOpposite β\n⊢ Eq ((MulEquiv.op f).symm a✝) (Function.comp MulOpposite.op (Function.comp (⇑f.symm) MulOpposite.unop) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddEquiv.op_symm_apply_apply","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Add α\ninst✝ : Add β\nf : AddEquiv (AddOpposite α) (AddOpposite β)\na✝ : α\n⊢ Eq ((AddEquiv.op.symm f) a✝) (Function.comp AddOpposite.unop (Function.comp (⇑f) AddOpposite.op) a✝)","decl":"/-- An iso `α ≃* β` can equivalently be viewed as an iso `αᵐᵒᵖ ≃* βᵐᵒᵖ`. -/\n@[to_additive (attr := simps)\n  \"An iso `α ≃+ β` can equivalently be viewed as an iso `αᵃᵒᵖ ≃+ βᵃᵒᵖ`.\"]\ndef MulEquiv.op {α β} [Mul α] [Mul β] : α ≃* β ≃ (αᵐᵒᵖ ≃* βᵐᵒᵖ) where\n  toFun f :=\n    { toFun := MulOpposite.op ∘ f ∘ unop, invFun := MulOpposite.op ∘ f.symm ∘ unop,\n      left_inv := fun x => unop_injective (f.symm_apply_apply x.unop),\n      right_inv := fun x => unop_injective (f.apply_symm_apply x.unop),\n      map_mul' := fun x y => unop_injective (map_mul f y.unop x.unop) }\n  invFun f :=\n    { toFun := unop ∘ f ∘ MulOpposite.op, invFun := unop ∘ f.symm ∘ MulOpposite.op,\n      left_inv := fun x => by simp,\n      right_inv := fun x => by simp,\n      map_mul' := fun x y => congr_arg unop (map_mul f (MulOpposite.op y) (MulOpposite.op x)) }\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"AddMonoidHom.mul_op_ext","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf g : AddMonoidHom (MulOpposite α) β\nh : Eq (f.comp MulOpposite.opAddEquiv.toAddMonoidHom) (g.comp MulOpposite.opAddEquiv.toAddMonoidHom)\n⊢ Eq f g","decl":"/-- This ext lemma changes equalities on `αᵐᵒᵖ →+ β` to equalities on `α →+ β`.\nThis is useful because there are often ext lemmas for specific `α`s that will apply\nto an equality of `α →+ β` such as `Finsupp.addHom_ext'`. -/\n@[ext]\ntheorem AddMonoidHom.mul_op_ext {α β} [AddZeroClass α] [AddZeroClass β] (f g : αᵐᵒᵖ →+ β)\n    (h :\n      f.comp (opAddEquiv : α ≃+ αᵐᵒᵖ).toAddMonoidHom =\n        g.comp (opAddEquiv : α ≃+ αᵐᵒᵖ).toAddMonoidHom) :\n    f = g :=\n  AddMonoidHom.ext <| MulOpposite.rec' fun x => (DFunLike.congr_fun h :) x\n\n"}
{"name":"AddMonoidHom.mul_op_ext_iff","module":"Mathlib.Algebra.Group.Opposite","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddZeroClass α\ninst✝ : AddZeroClass β\nf g : AddMonoidHom (MulOpposite α) β\n⊢ Iff (Eq f g) (Eq (f.comp MulOpposite.opAddEquiv.toAddMonoidHom) (g.comp MulOpposite.opAddEquiv.toAddMonoidHom))","decl":"/-- This ext lemma changes equalities on `αᵐᵒᵖ →+ β` to equalities on `α →+ β`.\nThis is useful because there are often ext lemmas for specific `α`s that will apply\nto an equality of `α →+ β` such as `Finsupp.addHom_ext'`. -/\n@[ext]\ntheorem AddMonoidHom.mul_op_ext {α β} [AddZeroClass α] [AddZeroClass β] (f g : αᵐᵒᵖ →+ β)\n    (h :\n      f.comp (opAddEquiv : α ≃+ αᵐᵒᵖ).toAddMonoidHom =\n        g.comp (opAddEquiv : α ≃+ αᵐᵒᵖ).toAddMonoidHom) :\n    f = g :=\n  AddMonoidHom.ext <| MulOpposite.rec' fun x => (DFunLike.congr_fun h :) x\n\n"}
