{"name":"HolorIndex.cast_type","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ is : List Nat\neq : Eq ds₁ ds₂\nh : List.Forall₂ (fun x1 x2 => LT.lt x1 x2) is ds₁\n⊢ Eq (↑(cast ⋯ ⟨is, h⟩)) is","decl":"theorem cast_type (is : List ℕ) (eq : ds₁ = ds₂) (h : Forall₂ (· < ·) is ds₁) :\n    (cast (congr_arg HolorIndex eq) ⟨is, h⟩).val = is := by subst eq; rfl\n\n"}
{"name":"HolorIndex.take_take","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ ds₃ : List Nat\nt : HolorIndex (HAppend.hAppend (HAppend.hAppend ds₁ ds₂) ds₃)\n⊢ Eq t.assocRight.take t.take.take","decl":"theorem take_take : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assocRight.take = t.take.take\n  | ⟨is, h⟩ =>\n    Subtype.eq <| by\n      simp [assocRight, take, cast_type, List.take_take, Nat.le_add_right, min_eq_left]\n\n"}
{"name":"HolorIndex.drop_take","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ ds₃ : List Nat\nt : HolorIndex (HAppend.hAppend (HAppend.hAppend ds₁ ds₂) ds₃)\n⊢ Eq t.assocRight.drop.take t.take.drop","decl":"theorem drop_take : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assocRight.drop.take = t.take.drop\n  | ⟨is, h⟩ => Subtype.eq (by simp [assocRight, take, drop, cast_type, List.drop_take])\n\n"}
{"name":"HolorIndex.drop_drop","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ ds₃ : List Nat\nt : HolorIndex (HAppend.hAppend (HAppend.hAppend ds₁ ds₂) ds₃)\n⊢ Eq t.assocRight.drop.drop t.drop","decl":"theorem drop_drop : ∀ t : HolorIndex (ds₁ ++ ds₂ ++ ds₃), t.assocRight.drop.drop = t.drop\n  | ⟨is, h⟩ => Subtype.eq (by simp [add_comm, assocRight, drop, cast_type, List.drop_drop])\n\n"}
{"name":"Holor.cast_type","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds₁ ds₂ : List Nat\neq : Eq ds₁ ds₂\na : Holor α ds₁\n⊢ Eq (cast ⋯ a) fun t => a (cast ⋯ t)","decl":"theorem cast_type (eq : ds₁ = ds₂) (a : Holor α ds₁) :\n    cast (congr_arg (Holor α) eq) a = fun t => a (cast (congr_arg HolorIndex eq.symm) t) := by\n  subst eq; rfl\n\n"}
{"name":"Holor.mul_assoc0","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds₁ ds₂ ds₃ : List Nat\ninst✝ : Semigroup α\nx : Holor α ds₁\ny : Holor α ds₂\nz : Holor α ds₃\n⊢ Eq ((x.mul y).mul z) (x.mul (y.mul z)).assocLeft","decl":"theorem mul_assoc0 [Semigroup α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₃) :\n    x ⊗ y ⊗ z = (x ⊗ (y ⊗ z)).assocLeft :=\n  funext fun t : HolorIndex (ds₁ ++ ds₂ ++ ds₃) => by\n    rw [assocLeft]\n    unfold mul\n    rw [mul_assoc, ← HolorIndex.take_take, ← HolorIndex.drop_take, ← HolorIndex.drop_drop,\n      cast_type]\n    · rfl\n    rw [append_assoc]\n\n"}
{"name":"Holor.mul_assoc","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds₁ ds₂ ds₃ : List Nat\ninst✝ : Semigroup α\nx : Holor α ds₁\ny : Holor α ds₂\nz : Holor α ds₃\n⊢ HEq ((x.mul y).mul z) (x.mul (y.mul z))","decl":"theorem mul_assoc [Semigroup α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₃) :\n    HEq (mul (mul x y) z) (mul x (mul y z)) := by simp [cast_heq, mul_assoc0, assocLeft]\n\n"}
{"name":"Holor.mul_left_distrib","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds₁ ds₂ : List Nat\ninst✝ : Distrib α\nx : Holor α ds₁\ny z : Holor α ds₂\n⊢ Eq (x.mul (HAdd.hAdd y z)) (HAdd.hAdd (x.mul y) (x.mul z))","decl":"theorem mul_left_distrib [Distrib α] (x : Holor α ds₁) (y : Holor α ds₂) (z : Holor α ds₂) :\n    x ⊗ (y + z) = x ⊗ y + x ⊗ z := funext fun t => left_distrib (x t.take) (y t.drop) (z t.drop)\n\n"}
{"name":"Holor.mul_right_distrib","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds₁ ds₂ : List Nat\ninst✝ : Distrib α\nx y : Holor α ds₁\nz : Holor α ds₂\n⊢ Eq ((HAdd.hAdd x y).mul z) (HAdd.hAdd (x.mul z) (y.mul z))","decl":"theorem mul_right_distrib [Distrib α] (x : Holor α ds₁) (y : Holor α ds₁) (z : Holor α ds₂) :\n    (x + y) ⊗ z = x ⊗ z + y ⊗ z := funext fun t => add_mul (x t.take) (y t.take) (z t.drop)\n\n"}
{"name":"Holor.zero_mul","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ : List Nat\nα : Type\ninst✝ : Ring α\nx : Holor α ds₂\n⊢ Eq (Holor.mul 0 x) 0","decl":"@[simp]\nnonrec theorem zero_mul {α : Type} [Ring α] (x : Holor α ds₂) : (0 : Holor α ds₁) ⊗ x = 0 :=\n  funext fun t => zero_mul (x (HolorIndex.drop t))\n\n"}
{"name":"Holor.mul_zero","module":"Mathlib.Data.Holor","initialProofState":"ds₁ ds₂ : List Nat\nα : Type\ninst✝ : Ring α\nx : Holor α ds₁\n⊢ Eq (x.mul 0) 0","decl":"@[simp]\nnonrec theorem mul_zero {α : Type} [Ring α] (x : Holor α ds₁) : x ⊗ (0 : Holor α ds₂) = 0 :=\n  funext fun t => mul_zero (x (HolorIndex.take t))\n\n"}
{"name":"Holor.mul_scalar_mul","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds : List Nat\ninst✝ : Monoid α\nx : Holor α List.nil\ny : Holor α ds\n⊢ Eq (x.mul y) (HSMul.hSMul (x ⟨List.nil, ⋯⟩) y)","decl":"theorem mul_scalar_mul [Monoid α] (x : Holor α []) (y : Holor α ds) :\n    x ⊗ y = x ⟨[], Forall₂.nil⟩ • y := by\n  simp (config := { unfoldPartialApp := true }) [mul, SMul.smul, HolorIndex.take, HolorIndex.drop,\n    HSMul.hSMul]\n\n-- holor slices\n"}
{"name":"Holor.holor_index_cons_decomp","module":"Mathlib.Data.Holor","initialProofState":"d : Nat\nds : List Nat\np : HolorIndex (List.cons d ds) → Prop\nt : HolorIndex (List.cons d ds)\na✝ : ∀ (i : Nat) (is : List Nat), Eq (↑t) (List.cons i is) → p ⟨List.cons i is, ⋯⟩\n⊢ p t","decl":"theorem holor_index_cons_decomp (p : HolorIndex (d :: ds) → Prop) :\n    ∀ t : HolorIndex (d :: ds),\n      (∀ i is, ∀ h : t.1 = i :: is, p ⟨i :: is, by rw [← h]; exact t.2⟩) → p t\n  | ⟨[], hforall₂⟩, _ => absurd (forall₂_nil_left_iff.1 hforall₂) (cons_ne_nil d ds)\n  | ⟨i :: is, _⟩, hp => hp i is rfl\n\n"}
{"name":"Holor.slice_eq","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\nx y : Holor α (List.cons d ds)\nh : Eq x.slice y.slice\n⊢ Eq x y","decl":"/-- Two holors are equal if all their slices are equal. -/\ntheorem slice_eq (x : Holor α (d :: ds)) (y : Holor α (d :: ds)) (h : slice x = slice y) : x = y :=\n  funext fun t : HolorIndex (d :: ds) =>\n    holor_index_cons_decomp (fun t => x t = y t) t fun i is hiis =>\n      have hiisdds : Forall₂ (· < ·) (i :: is) (d :: ds) := by rw [← hiis]; exact t.2\n      have hid : i < d := (forall₂_cons.1 hiisdds).1\n      have hisds : Forall₂ (· < ·) is ds := (forall₂_cons.1 hiisdds).2\n      calc\n        x ⟨i :: is, _⟩ = slice x i hid ⟨is, hisds⟩ := congr_arg x (Subtype.eq rfl)\n        _ = slice y i hid ⟨is, hisds⟩ := by rw [h]\n        _ = y ⟨i :: is, _⟩ := congr_arg y (Subtype.eq rfl)\n\n"}
{"name":"Holor.slice_unitVec_mul","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : Ring α\ni j : Nat\nhid : LT.lt i d\nx : Holor α ds\n⊢ Eq (((Holor.unitVec d j).mul x).slice i hid) (ite (Eq i j) x 0)","decl":"theorem slice_unitVec_mul [Ring α] {i : ℕ} {j : ℕ} (hid : i < d) (x : Holor α ds) :\n    slice (unitVec d j ⊗ x) i hid = if i = j then x else 0 :=\n  funext fun t : HolorIndex ds =>\n    if h : i = j then by simp [slice, mul, HolorIndex.take, unitVec, HolorIndex.drop, h]\n    else by simp [slice, mul, HolorIndex.take, unitVec, HolorIndex.drop, h]; rfl\n\n"}
{"name":"Holor.slice_add","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : Add α\ni : Nat\nhid : LT.lt i d\nx y : Holor α (List.cons d ds)\n⊢ Eq (HAdd.hAdd (x.slice i hid) (y.slice i hid)) ((HAdd.hAdd x y).slice i hid)","decl":"theorem slice_add [Add α] (i : ℕ) (hid : i < d) (x : Holor α (d :: ds)) (y : Holor α (d :: ds)) :\n    slice x i hid + slice y i hid = slice (x + y) i hid :=\n  funext fun t => by simp [slice, (· + ·), Add.add]\n\n"}
{"name":"Holor.slice_zero","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : Zero α\ni : Nat\nhid : LT.lt i d\n⊢ Eq (Holor.slice 0 i hid) 0","decl":"theorem slice_zero [Zero α] (i : ℕ) (hid : i < d) : slice (0 : Holor α (d :: ds)) i hid = 0 :=\n  rfl\n\n"}
{"name":"Holor.slice_sum","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : AddCommMonoid α\nβ : Type\ni : Nat\nhid : LT.lt i d\ns : Finset β\nf : β → Holor α (List.cons d ds)\n⊢ Eq (s.sum fun x => (f x).slice i hid) ((s.sum fun x => f x).slice i hid)","decl":"theorem slice_sum [AddCommMonoid α] {β : Type} (i : ℕ) (hid : i < d) (s : Finset β)\n    (f : β → Holor α (d :: ds)) : (∑ x ∈ s, slice (f x) i hid) = slice (∑ x ∈ s, f x) i hid := by\n  letI := Classical.decEq β\n  refine Finset.induction_on s ?_ ?_\n  · simp [slice_zero]\n  · intro _ _ h_not_in ih\n    rw [Finset.sum_insert h_not_in, ih, slice_add, Finset.sum_insert h_not_in]\n\n"}
{"name":"Holor.sum_unitVec_mul_slice","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : Ring α\nx : Holor α (List.cons d ds)\n⊢ Eq ((Finset.range d).attach.sum fun i => (Holor.unitVec d ↑i).mul (x.slice ↑i ⋯)) x","decl":"/-- The original holor can be recovered from its slices by multiplying with unit vectors and\nsumming up. -/\n@[simp]\ntheorem sum_unitVec_mul_slice [Ring α] (x : Holor α (d :: ds)) :\n    (∑ i ∈ (Finset.range d).attach,\n        unitVec d i ⊗ slice x i (Nat.succ_le_of_lt (Finset.mem_range.1 i.prop))) =\n      x := by\n  apply slice_eq _ _ _\n  ext i hid\n  rw [← slice_sum]\n  simp only [slice_unitVec_mul hid]\n  rw [Finset.sum_eq_single (Subtype.mk i <| Finset.mem_range.2 hid)]\n  · simp\n  · intro (b : { x // x ∈ Finset.range d }) (_ : b ∈ (Finset.range d).attach) (hbi : b ≠ ⟨i, _⟩)\n    have hbi' : i ≠ b := by simpa only [Ne, Subtype.ext_iff, Subtype.coe_mk] using hbi.symm\n    simp [hbi']\n  · intro (hid' : Subtype.mk i _ ∉ Finset.attach (Finset.range d))\n    exfalso\n    exact absurd (Finset.mem_attach _ _) hid'\n\n-- CP rank\n"}
{"name":"Holor.CPRankMax1.brecOn","module":"Mathlib.Data.Holor","initialProofState":"α : Type\ninst✝ : Mul α\nmotive✝ : {ds : List Nat} → (a : Holor α ds) → a.CPRankMax1 → Prop\nds : List Nat\na✝ : Holor α ds\nx✝ : a✝.CPRankMax1\nih✝ : ∀ {ds : List Nat} (a : Holor α ds) (x : a.CPRankMax1), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- `CPRankMax1 x` means `x` has CP rank at most 1, that is,\n  it is the tensor product of 1-dimensional holors. -/\ninductive CPRankMax1 [Mul α] : ∀ {ds}, Holor α ds → Prop\n  | nil (x : Holor α []) : CPRankMax1 x\n  | cons {d} {ds} (x : Holor α [d]) (y : Holor α ds) : CPRankMax1 y → CPRankMax1 (x ⊗ y)\n\n"}
{"name":"Holor.CPRankMax.brecOn","module":"Mathlib.Data.Holor","initialProofState":"α : Type\ninst✝¹ : Mul α\ninst✝ : AddMonoid α\nmotive✝ : (a : Nat) → {ds : List Nat} → (a_1 : Holor α ds) → Holor.CPRankMax a a_1 → Prop\na✝¹ : Nat\nds : List Nat\na✝ : Holor α ds\nx✝ : Holor.CPRankMax a✝¹ a✝\nih✝ : ∀ (a : Nat) {ds : List Nat} (a_1 : Holor α ds) (x : Holor.CPRankMax a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- `CPRankMax N x` means `x` has CP rank at most `N`, that is,\n  it can be written as the sum of N holors of rank at most 1. -/\ninductive CPRankMax [Mul α] [AddMonoid α] : ℕ → ∀ {ds}, Holor α ds → Prop\n  | zero {ds} : CPRankMax 0 (0 : Holor α ds)\n  | succ (n) {ds} (x : Holor α ds) (y : Holor α ds) :\n    CPRankMax1 x → CPRankMax n y → CPRankMax (n + 1) (x + y)\n\n"}
{"name":"Holor.cprankMax_nil","module":"Mathlib.Data.Holor","initialProofState":"α : Type\ninst✝¹ : Monoid α\ninst✝ : AddMonoid α\nx : Holor α List.nil\n⊢ Holor.CPRankMax 1 x","decl":"theorem cprankMax_nil [Monoid α] [AddMonoid α] (x : Holor α nil) : CPRankMax 1 x := by\n  have h := CPRankMax.succ 0 x 0 (CPRankMax1.nil x) CPRankMax.zero\n  rwa [add_zero x, zero_add] at h\n\n"}
{"name":"Holor.cprankMax_1","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds : List Nat\ninst✝¹ : Monoid α\ninst✝ : AddMonoid α\nx : Holor α ds\nh : x.CPRankMax1\n⊢ Holor.CPRankMax 1 x","decl":"theorem cprankMax_1 [Monoid α] [AddMonoid α] {x : Holor α ds} (h : CPRankMax1 x) :\n    CPRankMax 1 x := by\n  have h' := CPRankMax.succ 0 x 0 h CPRankMax.zero\n  rwa [zero_add, add_zero] at h'\n\n"}
{"name":"Holor.cprankMax_add","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds : List Nat\ninst✝¹ : Monoid α\ninst✝ : AddMonoid α\nm n : Nat\nx y : Holor α ds\na✝¹ : Holor.CPRankMax m x\na✝ : Holor.CPRankMax n y\n⊢ Holor.CPRankMax (HAdd.hAdd m n) (HAdd.hAdd x y)","decl":"theorem cprankMax_add [Monoid α] [AddMonoid α] :\n    ∀ {m : ℕ} {n : ℕ} {x : Holor α ds} {y : Holor α ds},\n      CPRankMax m x → CPRankMax n y → CPRankMax (m + n) (x + y)\n  | 0, n, x, y, hx, hy => by\n    match hx with\n    | CPRankMax.zero => simp only [zero_add, hy]\n  | m + 1, n, _, y, CPRankMax.succ _ x₁ x₂ hx₁ hx₂, hy => by\n    simp only [add_comm, add_assoc]\n    apply CPRankMax.succ\n    · assumption\n    · -- Porting note: Single line is added.\n      simp only [Nat.add_eq, add_zero, add_comm n m]\n      exact cprankMax_add hx₂ hy\n\n"}
{"name":"Holor.cprankMax_mul","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nd : Nat\nds : List Nat\ninst✝ : Ring α\nn : Nat\nx : Holor α (List.cons d List.nil)\ny : Holor α ds\na✝ : Holor.CPRankMax n y\n⊢ Holor.CPRankMax n (x.mul y)","decl":"theorem cprankMax_mul [Ring α] :\n    ∀ (n : ℕ) (x : Holor α [d]) (y : Holor α ds), CPRankMax n y → CPRankMax n (x ⊗ y)\n  | 0, x, _, CPRankMax.zero => by simp [mul_zero x, CPRankMax.zero]\n  | n + 1, x, _, CPRankMax.succ _ y₁ y₂ hy₁ hy₂ => by\n    rw [mul_left_distrib]\n    rw [Nat.add_comm]\n    apply cprankMax_add\n    · exact cprankMax_1 (CPRankMax1.cons _ _ hy₁)\n    · exact cprankMax_mul _ x y₂ hy₂\n\n"}
{"name":"Holor.cprankMax_sum","module":"Mathlib.Data.Holor","initialProofState":"α : Type\nds : List Nat\ninst✝ : Ring α\nβ : Type u_1\nn : Nat\ns : Finset β\nf : β → Holor α ds\na✝ : ∀ (x : β), Membership.mem s x → Holor.CPRankMax n (f x)\n⊢ Holor.CPRankMax (HMul.hMul s.card n) (s.sum fun x => f x)","decl":"theorem cprankMax_sum [Ring α] {β} {n : ℕ} (s : Finset β) (f : β → Holor α ds) :\n    (∀ x ∈ s, CPRankMax n (f x)) → CPRankMax (s.card * n) (∑ x ∈ s, f x) :=\n  letI := Classical.decEq β\n  Finset.induction_on s (by simp [CPRankMax.zero])\n    (by\n      intro x s (h_x_notin_s : x ∉ s) ih h_cprank\n      simp only [Finset.sum_insert h_x_notin_s, Finset.card_insert_of_not_mem h_x_notin_s]\n      rw [Nat.right_distrib]\n      simp only [Nat.one_mul, Nat.add_comm]\n      have ih' : CPRankMax (Finset.card s * n) (∑ x ∈ s, f x) := by\n        apply ih\n        intro (x : β) (h_x_in_s : x ∈ s)\n        simp only [h_cprank, Finset.mem_insert_of_mem, h_x_in_s]\n      exact cprankMax_add (h_cprank x (Finset.mem_insert_self x s)) ih')\n\n"}
{"name":"Holor.cprankMax_upper_bound","module":"Mathlib.Data.Holor","initialProofState":"α : Type\ninst✝ : Ring α\nds : List Nat\nx : Holor α ds\n⊢ Holor.CPRankMax ds.prod x","decl":"theorem cprankMax_upper_bound [Ring α] : ∀ {ds}, ∀ x : Holor α ds, CPRankMax ds.prod x\n  | [], x => cprankMax_nil x\n  | d :: ds, x => by\n    have h_summands :\n      ∀ i : { x // x ∈ Finset.range d },\n        CPRankMax ds.prod (unitVec d i.1 ⊗ slice x i.1 (mem_range.1 i.2)) :=\n      fun i => cprankMax_mul _ _ _ (cprankMax_upper_bound (slice x i.1 (mem_range.1 i.2)))\n    have h_dds_prod : (List.cons d ds).prod = Finset.card (Finset.range d) * prod ds := by\n      simp [Finset.card_range]\n    have :\n      CPRankMax (Finset.card (Finset.attach (Finset.range d)) * prod ds)\n        (∑ i ∈ Finset.attach (Finset.range d),\n          unitVec d i.val ⊗ slice x i.val (mem_range.1 i.2)) :=\n      cprankMax_sum (Finset.range d).attach _ fun i _ => h_summands i\n    have h_cprankMax_sum :\n      CPRankMax (Finset.card (Finset.range d) * prod ds)\n        (∑ i ∈ Finset.attach (Finset.range d),\n          unitVec d i.val ⊗ slice x i.val (mem_range.1 i.2)) := by rwa [Finset.card_attach] at this\n    rw [← sum_unitVec_mul_slice x]\n    rw [h_dds_prod]\n    exact h_cprankMax_sum\n\n"}
{"name":"Holor.cprank_upper_bound","module":"Mathlib.Data.Holor","initialProofState":"α : Type\ninst✝ : Ring α\nds : List Nat\nx : Holor α ds\n⊢ LE.le x.cprank ds.prod","decl":"theorem cprank_upper_bound [Ring α] : ∀ {ds}, ∀ x : Holor α ds, cprank x ≤ ds.prod :=\n  fun {ds} x =>\n  letI := Classical.decPred fun n : ℕ => CPRankMax n x\n  Nat.find_min' ⟨ds.prod, show (fun n => CPRankMax n x) ds.prod from cprankMax_upper_bound x⟩\n    (cprankMax_upper_bound x)\n\n"}
