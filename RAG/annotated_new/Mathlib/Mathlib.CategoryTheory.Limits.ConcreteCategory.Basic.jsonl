{"name":"CategoryTheory.Limits.Concrete.small_sections_of_hasLimit","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : (CategoryTheory.forget C).IsCorepresentable\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{t, w} J\nG : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit G\n⊢ Small.{v, max v w} ↑(G.comp (CategoryTheory.forget C)).sections","decl":"/-- If a functor `G : J ⥤ C` to a concrete category has a limit and that `forget C`\nis corepresentable, then `(G ⋙ forget C).sections` is small. -/\nlemma small_sections_of_hasLimit\n    {C : Type u} [Category.{v} C] [HasForget.{v} C]\n    [(forget C).IsCorepresentable] {J : Type w} [Category.{t} J] (G : J ⥤ C) [HasLimit G] :\n    Small.{v} (G ⋙ forget C).sections := by\n  rw [← Types.hasLimit_iff_small_sections]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.Concrete.to_product_injective_of_isLimit","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget C)\nD : CategoryTheory.Limits.Cone F\nhD : CategoryTheory.Limits.IsLimit D\n⊢ Function.Injective fun x j => (D.π.app j) x","decl":"theorem to_product_injective_of_isLimit {D : Cone F} (hD : IsLimit D) :\n    Function.Injective fun (x : D.pt) (j : J) => D.π.app j x := by\n  let E := (forget C).mapCone D\n  let hE : IsLimit E := isLimitOfPreserves _ hD\n  let G := Types.limitCone.{w, v} (F ⋙ forget C)\n  let hG := Types.limitConeIsLimit.{w, v} (F ⋙ forget C)\n  let T : E.pt ≅ G.pt := hE.conePointUniqueUpToIso hG\n  change Function.Injective (T.hom ≫ fun x j => G.π.app j x)\n  have h : Function.Injective T.hom := by\n    intro a b h\n    suffices T.inv (T.hom a) = T.inv (T.hom b) by simpa\n    rw [h]\n  suffices Function.Injective fun (x : G.pt) j => G.π.app j x by exact this.comp h\n  apply Subtype.ext\n\n"}
{"name":"CategoryTheory.Limits.Concrete.isLimit_ext","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget C)\nD : CategoryTheory.Limits.Cone F\nhD : CategoryTheory.Limits.IsLimit D\nx y : (CategoryTheory.forget C).obj D.pt\na✝ : ∀ (j : J), Eq ((D.π.app j) x) ((D.π.app j) y)\n⊢ Eq x y","decl":"theorem isLimit_ext {D : Cone F} (hD : IsLimit D) (x y : D.pt) :\n    (∀ j, D.π.app j x = D.π.app j y) → x = y := fun h =>\n  Concrete.to_product_injective_of_isLimit _ hD (funext h)\n\n"}
{"name":"CategoryTheory.Limits.Concrete.limit_ext","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nJ : Type w\ninst✝² : CategoryTheory.Category.{t, w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget C)\ninst✝ : CategoryTheory.Limits.HasLimit F\nx y : (CategoryTheory.forget C).obj (CategoryTheory.Limits.limit F)\na✝ : ∀ (j : J), Eq ((CategoryTheory.Limits.limit.π F j) x) ((CategoryTheory.Limits.limit.π F j) y)\n⊢ Eq x y","decl":"theorem limit_ext [HasLimit F] (x y : ↑(limit F)) :\n    (∀ j, limit.π F j x = limit.π F j y) → x = y :=\n  Concrete.isLimit_ext F (limit.isLimit _) _ _\n\n"}
{"name":"CategoryTheory.Limits.Concrete.surjective_π_app_zero_of_surjective_map","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfShape (Opposite Nat) (CategoryTheory.forget C)\nF : CategoryTheory.Functor (Opposite Nat) C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nhF : ∀ (n : Nat), Function.Surjective ⇑(F.map (CategoryTheory.homOfLE ⋯).op)\n⊢ Function.Surjective ⇑(c.π.app { unop := 0 })","decl":"/--\nGiven surjections `⋯ ⟶ Xₙ₊₁ ⟶ Xₙ ⟶ ⋯ ⟶ X₀` in a concrete category whose forgetful functor\npreserves sequential limits, the projection map `lim Xₙ ⟶ X₀` is surjective.\n-/\nlemma surjective_π_app_zero_of_surjective_map {C : Type u} [Category.{v} C] [HasForget.{v} C]\n    [PreservesLimitsOfShape ℕᵒᵖ (forget C)] {F : ℕᵒᵖ ⥤ C} {c : Cone F}\n    (hc : IsLimit c) (hF : ∀ n, Function.Surjective (F.map (homOfLE (Nat.le_succ n)).op)) :\n    Function.Surjective (c.π.app ⟨0⟩) :=\n  Types.surjective_π_app_zero_of_surjective_map (isLimitOfPreserves _ hc) hF\n\n"}
{"name":"CategoryTheory.Limits.Concrete.from_union_surjective_of_isColimit","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\nD : CategoryTheory.Limits.Cocone F\nhD : CategoryTheory.Limits.IsColimit D\n⊢ let ff := fun a => (D.ι.app a.fst) a.snd;\n  Function.Surjective ff","decl":"theorem from_union_surjective_of_isColimit {D : Cocone F} (hD : IsColimit D) :\n    let ff : (Σj : J, F.obj j) → D.pt := fun a => D.ι.app a.1 a.2\n    Function.Surjective ff := by\n  intro ff x\n  let E : Cocone (F ⋙ forget C) := (forget C).mapCocone D\n  let hE : IsColimit E := isColimitOfPreserves (forget C) hD\n  obtain ⟨j, y, hy⟩ := Types.jointly_surjective_of_isColimit hE x\n  exact ⟨⟨j, y⟩, hy⟩\n\n"}
{"name":"CategoryTheory.Limits.Concrete.isColimit_exists_rep","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\nD : CategoryTheory.Limits.Cocone F\nhD : CategoryTheory.Limits.IsColimit D\nx : (CategoryTheory.forget C).obj D.pt\n⊢ Exists fun j => Exists fun y => Eq ((D.ι.app j) y) x","decl":"theorem isColimit_exists_rep {D : Cocone F} (hD : IsColimit D) (x : D.pt) :\n    ∃ (j : J) (y : F.obj j), D.ι.app j y = x := by\n  obtain ⟨a, rfl⟩ := Concrete.from_union_surjective_of_isColimit F hD x\n  exact ⟨a.1, a.2, rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.Concrete.colimit_exists_rep","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nJ : Type w\ninst✝² : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\ninst✝ : CategoryTheory.Limits.HasColimit F\nx : (CategoryTheory.forget C).obj (CategoryTheory.Limits.colimit F)\n⊢ Exists fun j => Exists fun y => Eq ((CategoryTheory.Limits.colimit.ι F j) y) x","decl":"theorem colimit_exists_rep [HasColimit F] (x : ↑(colimit F)) :\n    ∃ (j : J) (y : F.obj j), colimit.ι F j y = x :=\n  Concrete.isColimit_exists_rep F (colimit.isColimit _) x\n\n"}
{"name":"CategoryTheory.Limits.Concrete.isColimit_rep_eq_of_exists","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.HasForget C\nJ : Type w\ninst✝ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\nD : CategoryTheory.Limits.Cocone F\ni j : J\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y)\n⊢ Eq ((D.ι.app i) x) ((D.ι.app j) y)","decl":"theorem isColimit_rep_eq_of_exists {D : Cocone F} {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y) :\n    D.ι.app i x = D.ι.app j y := by\n  let E := (forget C).mapCocone D\n  obtain ⟨k, f, g, (hfg : (F ⋙ forget C).map f x = F.map g y)⟩ := h\n  let h1 : (F ⋙ forget C).map f ≫ E.ι.app k = E.ι.app i := E.ι.naturality f\n  let h2 : (F ⋙ forget C).map g ≫ E.ι.app k = E.ι.app j := E.ι.naturality g\n  show E.ι.app i x = E.ι.app j y\n  rw [← h1, types_comp_apply, hfg]\n  exact congrFun h2 y\n\n"}
{"name":"CategoryTheory.Limits.Concrete.colimit_rep_eq_of_exists","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasColimit F\ni j : J\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y)\n⊢ Eq ((CategoryTheory.Limits.colimit.ι F i) x) ((CategoryTheory.Limits.colimit.ι F j) y)","decl":"theorem colimit_rep_eq_of_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y) :\n    colimit.ι F i x = colimit.ι F j y :=\n  Concrete.isColimit_rep_eq_of_exists F x y h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.isColimit_exists_of_rep_eq","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nJ : Type w\ninst✝² : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\ninst✝ : CategoryTheory.IsFiltered J\nD : CategoryTheory.Limits.Cocone F\ni j : J\nhD : CategoryTheory.Limits.IsColimit D\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\nh : Eq ((D.ι.app i) x) ((D.ι.app j) y)\n⊢ Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y)","decl":"theorem isColimit_exists_of_rep_eq {D : Cocone F} {i j : J} (hD : IsColimit D)\n    (x : F.obj i) (y : F.obj j) (h : D.ι.app _ x = D.ι.app _ y) :\n    ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y := by\n  let E := (forget C).mapCocone D\n  let hE : IsColimit E := isColimitOfPreserves _ hD\n  exact (Types.FilteredColimit.isColimit_eq_iff (F ⋙ forget C) hE).mp h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.isColimit_rep_eq_iff_exists","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\nJ : Type w\ninst✝² : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝¹ : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\ninst✝ : CategoryTheory.IsFiltered J\nD : CategoryTheory.Limits.Cocone F\ni j : J\nhD : CategoryTheory.Limits.IsColimit D\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\n⊢ Iff (Eq ((D.ι.app i) x) ((D.ι.app j) y)) (Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y))","decl":"theorem isColimit_rep_eq_iff_exists {D : Cocone F} {i j : J} (hD : IsColimit D)\n    (x : F.obj i) (y : F.obj j) :\n    D.ι.app i x = D.ι.app j y ↔ ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y :=\n  ⟨Concrete.isColimit_exists_of_rep_eq.{t} _ hD _ _,\n   Concrete.isColimit_rep_eq_of_exists _ _ _⟩\n\n"}
{"name":"CategoryTheory.Limits.Concrete.colimit_exists_of_rep_eq","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\nJ : Type w\ninst✝³ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\ninst✝¹ : CategoryTheory.IsFiltered J\ninst✝ : CategoryTheory.Limits.HasColimit F\ni j : J\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\nh : Eq ((CategoryTheory.Limits.colimit.ι F i) x) ((CategoryTheory.Limits.colimit.ι F j) y)\n⊢ Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y)","decl":"theorem colimit_exists_of_rep_eq [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j)\n    (h : colimit.ι F _ x = colimit.ι F _ y) :\n    ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y :=\n  Concrete.isColimit_exists_of_rep_eq.{t} F (colimit.isColimit _) x y h\n\n"}
{"name":"CategoryTheory.Limits.Concrete.colimit_rep_eq_iff_exists","module":"Mathlib.CategoryTheory.Limits.ConcreteCategory.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\nJ : Type w\ninst✝³ : CategoryTheory.Category.{r, w} J\nF : CategoryTheory.Functor J C\ninst✝² : CategoryTheory.Limits.PreservesColimit F (CategoryTheory.forget C)\ninst✝¹ : CategoryTheory.IsFiltered J\ninst✝ : CategoryTheory.Limits.HasColimit F\ni j : J\nx : (CategoryTheory.forget C).obj (F.obj i)\ny : (CategoryTheory.forget C).obj (F.obj j)\n⊢ Iff (Eq ((CategoryTheory.Limits.colimit.ι F i) x) ((CategoryTheory.Limits.colimit.ι F j) y)) (Exists fun k => Exists fun f => Exists fun g => Eq ((F.map f) x) ((F.map g) y))","decl":"theorem colimit_rep_eq_iff_exists [HasColimit F] {i j : J} (x : F.obj i) (y : F.obj j) :\n    colimit.ι F i x = colimit.ι F j y ↔ ∃ (k : _) (f : i ⟶ k) (g : j ⟶ k), F.map f x = F.map g y :=\n  ⟨Concrete.colimit_exists_of_rep_eq.{t} _ _ _, Concrete.colimit_rep_eq_of_exists _ _ _⟩\n\n"}
