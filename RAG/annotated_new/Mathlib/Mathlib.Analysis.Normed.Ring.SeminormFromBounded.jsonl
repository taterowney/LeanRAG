{"name":"map_one_ne_zero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_ne_zero : Ne f 0\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ Ne (f 1) 0","decl":"/-- If `f : R → ℝ` is a nonzero, nonnegative, multiplicatively bounded function, then `f 1 ≠ 0`. -/\ntheorem map_one_ne_zero (f_ne_zero : f ≠ 0) (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) : f 1 ≠ 0 := by\n  intro h1\n  specialize f_mul 1\n  simp_rw [h1, one_mul, mul_zero, zero_mul] at f_mul\n  obtain ⟨z, hz⟩ := Function.ne_iff.mp f_ne_zero\n  exact hz <| (f_mul z).antisymm (f_nonneg z)\n\n"}
{"name":"map_pow_ne_zero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nx : R\nhx : IsUnit x\nhfx : Ne (f x) 0\nn : Nat\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ Ne (f (HPow.hPow x n)) 0","decl":"/-- If `f : R → ℝ` is a nonnegative multiplicatively bounded function and `x : R` is a unit with\n  `f x ≠ 0`, then for every `n : ℕ`, we have `f (x ^ n) ≠ 0`. -/\ntheorem map_pow_ne_zero (f_nonneg : 0 ≤ f) {x : R} (hx : IsUnit x) (hfx : f x ≠ 0) (n : ℕ)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) : f (x ^ n) ≠ 0 := by\n  have h1 : f 1 ≠ 0 := map_one_ne_zero (Function.ne_iff.mpr ⟨x, hfx⟩) f_nonneg f_mul\n  intro hxn\n  have : f 1 ≤ 0 := by simpa [← mul_pow, hxn] using f_mul (x ^ n) (hx.unit⁻¹ ^ n)\n  exact h1 <| this.antisymm (f_nonneg 1)\n\n"}
{"name":"map_mul_zero_of_map_zero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\nhx : Eq (f x) 0\ny : R\n⊢ Eq (f (HMul.hMul x y)) 0","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then given `x y : R` with\n  `f x = 0`, we have `f (x * y) = 0`. -/\ntheorem map_mul_zero_of_map_zero (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) {x : R} (hx : f x = 0)\n    (y : R) : f (x * y) = 0 := by\n  replace f_mul : f (x * y) ≤ 0 := by simpa [hx] using f_mul x y\n  exact le_antisymm f_mul (f_nonneg _)\n\n"}
{"name":"seminormFromBounded_zero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nf_zero : Eq (f 0) 0\n⊢ Eq (seminormFromBounded' f 0) 0","decl":"/-- `seminormFromBounded' f` preserves `0`. -/\ntheorem seminormFromBounded_zero (f_zero : f 0 = 0) : seminormFromBounded' f (0 : R) = 0 := by\n  simp_rw [seminormFromBounded', zero_mul, f_zero, zero_div, ciSup_const]\n\n"}
{"name":"seminormFromBounded_aux","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\n⊢ LE.le 0 (HMul.hMul c (f x))","decl":"theorem seminormFromBounded_aux (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x : R) : 0 ≤ c * f x := by\n  rcases (f_nonneg x).eq_or_gt with hx | hx\n  · simp [hx]\n  · change 0 < f x at hx\n    have hc : 0 ≤ c := by\n      specialize f_mul x 1\n      rw [mul_one, show c * f x * f 1 = c * f 1 * f x by ring, le_mul_iff_one_le_left hx] at f_mul\n      replace f_nonneg : 0 ≤ f 1 := f_nonneg 1\n      rcases f_nonneg.eq_or_gt with h1 | h1\n      · linarith [show (1 : ℝ) ≤ 0 by simpa [h1] using f_mul]\n      · rw [← div_le_iff₀ h1] at f_mul\n        linarith [one_div_pos.mpr h1]\n    positivity\n\n"}
{"name":"seminormFromBounded_bddAbove_range","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\n⊢ BddAbove (Set.range fun y => HDiv.hDiv (f (HMul.hMul x y)) (f y))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then for every `x : R`,\n  the image of `y ↦ f (x * y) / f y` is bounded above. -/\ntheorem seminormFromBounded_bddAbove_range (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x : R) :\n    BddAbove (Set.range fun y ↦ f (x * y) / f y) := by\n  use c * f x\n  rintro r ⟨y, rfl⟩\n  rcases (f_nonneg y).eq_or_gt with hy0 | hy0\n  · simpa [hy0] using seminormFromBounded_aux f_nonneg f_mul x\n  · simpa [div_le_iff₀ hy0] using f_mul x y\n\n"}
{"name":"seminormFromBounded_le","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\n⊢ LE.le (seminormFromBounded' f x) (HMul.hMul c (f x))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then for every `x : R`,\n  `seminormFromBounded' f x` is bounded above by some multiple of `f x`. -/\ntheorem seminormFromBounded_le (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x : R) :\n    seminormFromBounded' f x ≤ c * f x := by\n  refine ciSup_le (fun y ↦ ?_)\n  rcases (f_nonneg y).eq_or_gt with hy | hy\n  · simpa [hy] using seminormFromBounded_aux f_nonneg f_mul x\n  · rw [div_le_iff₀ hy]\n    apply f_mul\n\n"}
{"name":"seminormFromBounded_ge","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\n⊢ LE.le (f x) (HMul.hMul (f 1) (seminormFromBounded' f x))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then for every `x : R`,\n  `f x ≤ f 1 * seminormFromBounded' f x`. -/\ntheorem seminormFromBounded_ge (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x : R) :\n    f x ≤ f 1 * seminormFromBounded' f x := by\n  by_cases h1 : f 1 = 0\n  · specialize f_mul x 1\n    rw [mul_one, h1, mul_zero] at f_mul\n    have hx0 : f x = 0 := f_mul.antisymm (f_nonneg _)\n    rw [hx0, h1, zero_mul]\n  · rw [mul_comm, ← div_le_iff₀ (lt_of_le_of_ne' (f_nonneg _) h1)]\n    conv_lhs => rw [← mul_one x]\n    exact le_ciSup (seminormFromBounded_bddAbove_range f_nonneg f_mul x) (1 : R)\n\n"}
{"name":"seminormFromBounded_nonneg","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ LE.le 0 (seminormFromBounded' f)","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f` is nonnegative. -/\ntheorem seminormFromBounded_nonneg (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y)  :\n    0 ≤ seminormFromBounded' f := fun x ↦\n  le_csSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul x) ⟨1, rfl⟩\n    (div_nonneg (f_nonneg _) (f_nonneg _))\n\n"}
{"name":"seminormFromBounded_eq_zero_iff","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\n⊢ Iff (Eq (seminormFromBounded' f x) 0) (Eq (f x) 0)","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f x = 0` if and only if `f x = 0`. -/\ntheorem seminormFromBounded_eq_zero_iff (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x : R) :\n    seminormFromBounded' f x = 0 ↔ f x = 0 := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · have hf := seminormFromBounded_ge f_nonneg f_mul x\n    rw [h, mul_zero] at hf\n    exact hf.antisymm (f_nonneg _)\n  · have hf : seminormFromBounded' f x ≤ c * f x :=\n      seminormFromBounded_le f_nonneg f_mul x\n    rw [h, mul_zero] at hf\n    exact hf.antisymm (seminormFromBounded_nonneg f_nonneg f_mul x)\n\n"}
{"name":"seminormFromBounded_neg","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nf_neg : ∀ (x : R), Eq (f (Neg.neg x)) (f x)\nx : R\n⊢ Eq (seminormFromBounded' f (Neg.neg x)) (seminormFromBounded' f x)","decl":"/-- If `f` is invariant under negation of `x`, then so is `seminormFromBounded'`.-/\ntheorem seminormFromBounded_neg (f_neg : ∀ x : R, f (-x) = f x) (x : R) :\n    seminormFromBounded' f (-x) = seminormFromBounded' f x := by\n  suffices ⨆ y, f (-x * y) / f y = ⨆ y, f (x * y) / f y by simpa only [seminormFromBounded']\n  congr\n  ext y\n  rw [neg_mul, f_neg]\n\n"}
{"name":"seminormFromBounded_mul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx y : R\n⊢ LE.le (seminormFromBounded' f (HMul.hMul x y)) (HMul.hMul (seminormFromBounded' f x) (seminormFromBounded' f y))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f` is submultiplicative. -/\ntheorem seminormFromBounded_mul (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) (x y : R) :\n    seminormFromBounded' f (x * y) ≤ seminormFromBounded' f x * seminormFromBounded' f y := by\n  apply ciSup_le\n  by_cases hy : seminormFromBounded' f y = 0\n  · rw [seminormFromBounded_eq_zero_iff f_nonneg f_mul] at hy\n    intro z\n    rw [mul_comm x y, mul_assoc, map_mul_zero_of_map_zero f_nonneg f_mul hy (x * z), zero_div]\n    exact mul_nonneg (seminormFromBounded_nonneg f_nonneg f_mul x)\n      (seminormFromBounded_nonneg f_nonneg f_mul y)\n  · intro z\n    rw [← div_le_iff₀ (lt_of_le_of_ne' (seminormFromBounded_nonneg f_nonneg f_mul _) hy)]\n    apply le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul x) z\n    rw [div_le_iff₀ (lt_of_le_of_ne' (seminormFromBounded_nonneg f_nonneg f_mul _) hy),\n      div_mul_eq_mul_div]\n    by_cases hz : f z = 0\n    · have hxyz : f (z * (x * y)) = 0 := map_mul_zero_of_map_zero f_nonneg f_mul hz _\n      simp_rw [mul_comm, hxyz, zero_div]\n      exact div_nonneg (mul_nonneg (seminormFromBounded_nonneg f_nonneg f_mul y) (f_nonneg _))\n        (f_nonneg _)\n    · rw [div_le_div_iff_of_pos_right (lt_of_le_of_ne' (f_nonneg _) hz), mul_comm (f (x * z))]\n      by_cases hxz : f (x * z) = 0\n      · rw [mul_comm x y, mul_assoc, mul_comm y, map_mul_zero_of_map_zero f_nonneg f_mul hxz y]\n        exact mul_nonneg (seminormFromBounded_nonneg f_nonneg f_mul y) (f_nonneg _)\n      · rw [← div_le_iff₀ (lt_of_le_of_ne' (f_nonneg _) hxz)]\n        apply le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul y) (x * z)\n        rw [div_le_div_iff_of_pos_right (lt_of_le_of_ne' (f_nonneg _) hxz), mul_comm x y, mul_assoc]\n\n"}
{"name":"seminormFromBounded_one","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_ne_zero : Ne f 0\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ Eq (seminormFromBounded' f 1) 1","decl":"/-- If `f : R → ℝ` is a nonzero, nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f 1 = 1`. -/\ntheorem seminormFromBounded_one (f_ne_zero : f ≠ 0) (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) :\n    seminormFromBounded' f 1 = 1 := by\n  simp_rw [seminormFromBounded', one_mul]\n  apply le_antisymm\n  · refine ciSup_le (fun x ↦ ?_)\n    by_cases hx : f x = 0\n    · rw [hx, div_zero]; exact zero_le_one\n    · rw [div_self hx]\n  · rw [← div_self (map_one_ne_zero f_ne_zero f_nonneg f_mul)]\n    have h_bdd : BddAbove (Set.range fun y ↦ f y / f y) := by\n      use (1 : ℝ)\n      rintro r ⟨y, rfl⟩\n      by_cases hy : f y = 0\n      · simp only [hy, div_zero, zero_le_one]\n      · simp only [div_self hy, le_refl]\n    exact le_ciSup h_bdd (1 : R)\n\n"}
{"name":"seminormFromBounded_one_le","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ LE.le (seminormFromBounded' f 1) 1","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f 1 ≤ 1`. -/\ntheorem seminormFromBounded_one_le (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) :\n    seminormFromBounded' f 1 ≤ 1 := by\n  by_cases f_ne_zero : f ≠ 0\n  · exact le_of_eq (seminormFromBounded_one f_ne_zero f_nonneg f_mul)\n  · simp_rw [seminormFromBounded', one_mul]\n    refine ciSup_le (fun _ ↦ ?_)\n    push_neg at f_ne_zero\n    simp only [f_ne_zero, Pi.zero_apply, div_zero, zero_le_one]\n\n"}
{"name":"seminormFromBounded_add","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nf_add : ∀ (a b : R), LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\nx y : R\n⊢ LE.le (seminormFromBounded' f (HAdd.hAdd x y)) (HAdd.hAdd (seminormFromBounded' f x) (seminormFromBounded' f y))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded, subadditive function, then\n  `seminormFromBounded' f` is subadditive. -/\ntheorem seminormFromBounded_add (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y)\n    (f_add : ∀ a b, f (a + b) ≤ f a + f b) (x y : R) :\n    seminormFromBounded' f (x + y) ≤ seminormFromBounded' f x + seminormFromBounded' f y := by\n  refine ciSup_le (fun z ↦ ?_)\n  suffices hf : f ((x + y) * z) / f z ≤ f (x * z) / f z + f (y * z) / f z by\n    exact le_trans hf (add_le_add\n      (le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul x) z (le_refl _))\n      (le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul y) z (le_refl _)))\n  by_cases hz : f z = 0\n  · simp only [hz, div_zero, zero_add, le_refl, or_self_iff]\n  · rw [div_add_div_same, div_le_div_iff_of_pos_right (lt_of_le_of_ne' (f_nonneg _) hz), add_mul]\n    exact f_add _ _\n\n"}
{"name":"seminormFromBounded_isNonarchimedean","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nhna : IsNonarchimedean f\n⊢ IsNonarchimedean (seminormFromBounded' f)","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded, nonarchimedean function, then\n  `seminormFromBounded' f` is nonarchimedean. -/\ntheorem seminormFromBounded_isNonarchimedean (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y)\n    (hna : IsNonarchimedean f) : IsNonarchimedean (seminormFromBounded' f) := by\n  refine fun x y ↦ ciSup_le (fun z ↦ ?_)\n  rw [le_max_iff]\n  suffices hf : f ((x + y) * z) / f z ≤ f (x * z) / f z ∨ f ((x + y) * z) / f z ≤ f (y * z) / f z by\n    rcases hf with hfx | hfy\n    · exact Or.inl <| le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul x) z hfx\n    · exact Or.inr <| le_ciSup_of_le (seminormFromBounded_bddAbove_range f_nonneg f_mul y) z hfy\n  by_cases hz : f z = 0\n  · simp only [hz, div_zero, le_refl, or_self_iff]\n  · rw [div_le_div_iff_of_pos_right (lt_of_le_of_ne' (f_nonneg _) hz),\n      div_le_div_iff_of_pos_right (lt_of_le_of_ne' (f_nonneg _) hz), add_mul, ← le_max_iff]\n    exact hna _ _\n\n"}
{"name":"seminormFromBounded_of_mul_apply","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\nhx : ∀ (y : R), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq (seminormFromBounded' f x) (f x)","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function and `x : R` is\n  multiplicative for `f`, then `seminormFromBounded' f x = f x`. -/\ntheorem seminormFromBounded_of_mul_apply (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) {x : R}\n    (hx : ∀ y : R, f (x * y) = f x * f y) : seminormFromBounded' f x = f x := by\n  simp_rw [seminormFromBounded', hx, ← mul_div_assoc']\n  apply le_antisymm\n  · refine ciSup_le (fun x ↦ ?_)\n    by_cases hx : f x = 0\n    · rw [hx, div_zero, mul_zero]; exact f_nonneg _\n    · rw [div_self hx, mul_one]\n  · by_cases f_ne_zero : f ≠ 0\n    · conv_lhs => rw [← mul_one (f x)]\n      rw [← div_self (map_one_ne_zero f_ne_zero f_nonneg f_mul)]\n      have h_bdd : BddAbove (Set.range fun y ↦ f x * (f y / f y)) := by\n        use f x\n        rintro r ⟨y, rfl⟩\n        by_cases hy0 : f y = 0\n        · simp only [hy0, div_zero, mul_zero]; exact f_nonneg _\n        · simp only [div_self hy0, mul_one, le_refl]\n      exact le_ciSup h_bdd (1 : R)\n    · push_neg at f_ne_zero\n      simp_rw [f_ne_zero, Pi.zero_apply, zero_div, zero_mul, ciSup_const]; rfl\n\n"}
{"name":"seminormFromBounded_of_mul_le","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nf_nonneg : LE.le 0 f\nx : R\nhx : ∀ (y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh_one : LE.le (f 1) 1\n⊢ Eq (seminormFromBounded' f x) (f x)","decl":"/-- If `f : R → ℝ` is a nonnegative function and `x : R` is submultiplicative for `f`, then\n  `seminormFromBounded' f x = f x`. -/\ntheorem seminormFromBounded_of_mul_le (f_nonneg : 0 ≤ f) {x : R}\n    (hx : ∀ y : R, f (x * y) ≤ f x * f y) (h_one : f 1 ≤ 1) : seminormFromBounded' f x = f x := by\n  simp_rw [seminormFromBounded']\n  apply le_antisymm\n  · refine ciSup_le (fun y ↦ ?_)\n    by_cases hy : f y = 0\n    · rw [hy, div_zero]; exact f_nonneg _\n    · rw [div_le_iff₀ (lt_of_le_of_ne' (f_nonneg _) hy)]; exact hx _\n  · have h_bdd : BddAbove (Set.range fun y ↦ f (x * y) / f y) := by\n      use f x\n      rintro r ⟨y, rfl⟩\n      by_cases hy0 : f y = 0\n      · simp only [hy0, div_zero]\n        exact f_nonneg _\n      · rw [← mul_one (f x), ← div_self hy0, ← mul_div_assoc,\n          div_le_iff₀ (lt_of_le_of_ne' (f_nonneg _) hy0), mul_div_assoc, div_self hy0, mul_one]\n        exact hx y\n    convert le_ciSup h_bdd (1 : R)\n    by_cases h0 : f x = 0\n    · rw [mul_one, h0, zero_div]\n    · have heq : f 1 = 1 := by\n        apply h_one.antisymm\n        specialize hx 1\n        rw [mul_one, le_mul_iff_one_le_right (lt_of_le_of_ne (f_nonneg _) (Ne.symm h0))] at hx\n        exact hx\n      rw [heq, mul_one, div_one]\n\n"}
{"name":"seminormFromBounded_nonzero","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_ne_zero : Ne f 0\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ Ne (seminormFromBounded' f) 0","decl":"/-- If `f : R → ℝ` is a nonzero, nonnegative, multiplicatively bounded function, then\n  `seminormFromBounded' f` is nonzero. -/\ntheorem seminormFromBounded_nonzero (f_ne_zero : f ≠ 0) (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) :\n    seminormFromBounded' f ≠ 0 := by\n  obtain ⟨x, hx⟩ := Function.ne_iff.mp f_ne_zero\n  rw [Function.ne_iff]\n  use x\n  rw [ne_eq, Pi.zero_apply, seminormFromBounded_eq_zero_iff f_nonneg f_mul x]\n  exact hx\n\n"}
{"name":"seminormFromBounded_ker","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\n⊢ Eq (Set.preimage (seminormFromBounded' f) (Singleton.singleton 0)) (Set.preimage f (Singleton.singleton 0))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function, then the kernel of\n  `seminormFromBounded' f` equals the kernel of `f`. -/\ntheorem seminormFromBounded_ker (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) :\n    seminormFromBounded' f ⁻¹' {0} = f ⁻¹' {0} := by\n  ext x\n  exact seminormFromBounded_eq_zero_iff f_nonneg f_mul x\n\n"}
{"name":"seminormFromBounded_is_norm_iff","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_zero : Eq (f 0) 0\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nf_add : ∀ (a b : R), LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))\nf_neg : ∀ (x : R), Eq (f (Neg.neg x)) (f x)\n⊢ Iff (∀ (x : R), Eq ((seminormFromBounded f_zero f_nonneg f_mul f_add f_neg).toFun x) 0 → Eq x 0) (Eq (Set.preimage f (Singleton.singleton 0)) (Singleton.singleton 0))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded, subadditive function that preserves\n  zero and negation, then `seminormFromBounded' f` is a norm if and only if `f⁻¹' {0} = {0}`. -/\ntheorem seminormFromBounded_is_norm_iff (f_zero : f 0 = 0) (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y)\n    (f_add : ∀ a b, f (a + b) ≤ f a + f b) (f_neg : ∀ x : R, f (-x) = f x) :\n    (∀ x : R, (seminormFromBounded f_zero f_nonneg f_mul f_add f_neg).toFun x = 0 → x = 0) ↔\n      f ⁻¹' {0} = {0} := by\n  refine ⟨fun h0 ↦ ?_, fun h_ker x hx ↦ ?_⟩\n  · rw [← seminormFromBounded_ker f_nonneg f_mul]\n    ext x\n    simp only [Set.mem_preimage, Set.mem_singleton_iff]\n    exact ⟨fun h ↦ h0 x h, fun h ↦ by rw [h]; exact seminormFromBounded_zero f_zero⟩\n  · rw [← Set.mem_singleton_iff, ← h_ker, Set.mem_preimage, Set.mem_singleton_iff,\n      ← seminormFromBounded_eq_zero_iff f_nonneg f_mul x]\n    exact hx\n\n"}
{"name":"seminormFromBounded_of_mul_is_mul","module":"Mathlib.Analysis.Normed.Ring.SeminormFromBounded","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : R → Real\nc : Real\nf_nonneg : LE.le 0 f\nf_mul : ∀ (x y : R), LE.le (f (HMul.hMul x y)) (HMul.hMul (HMul.hMul c (f x)) (f y))\nx : R\nhx : ∀ (y : R), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ny : R\n⊢ Eq (seminormFromBounded' f (HMul.hMul x y)) (HMul.hMul (seminormFromBounded' f x) (seminormFromBounded' f y))","decl":"/-- If `f : R → ℝ` is a nonnegative, multiplicatively bounded function and `x : R` is\n  multiplicative for `f`, then `x` is multiplicative for `seminormFromBounded' f`. -/\ntheorem seminormFromBounded_of_mul_is_mul (f_nonneg : 0 ≤ f)\n    (f_mul : ∀ x y : R, f (x * y) ≤ c * f x * f y) {x : R}\n    (hx : ∀ y : R, f (x * y) = f x * f y) (y : R) :\n    seminormFromBounded' f (x * y) = seminormFromBounded' f x * seminormFromBounded' f y := by\n  rw [seminormFromBounded_of_mul_apply f_nonneg f_mul hx]\n  simp only [seminormFromBounded', mul_assoc, hx, mul_div_assoc,\n    Real.mul_iSup_of_nonneg (f_nonneg _)]\n\n"}
