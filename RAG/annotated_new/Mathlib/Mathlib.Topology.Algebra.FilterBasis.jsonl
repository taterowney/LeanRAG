{"name":"GroupFilterBasis.inv'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nself : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => Inv.inv x) U))","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ‚àÄ {U}, U ‚àà sets ‚Üí (1 : G) ‚àà U\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  inv' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U\n\n"}
{"name":"GroupFilterBasis.conj'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nself : GroupFilterBasis G\nx‚ÇÄ : G\nU : Set G\na‚úù : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul (HMul.hMul x‚ÇÄ x) (Inv.inv x‚ÇÄ)) U))","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ‚àÄ {U}, U ‚àà sets ‚Üí (1 : G) ‚àà U\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  inv' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U\n\n"}
{"name":"GroupFilterBasis.mul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nself : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ‚àÄ {U}, U ‚àà sets ‚Üí (1 : G) ‚àà U\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  inv' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U\n\n"}
{"name":"GroupFilterBasis.one'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nself : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Membership.mem U 1","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ‚àÄ {U}, U ‚àà sets ‚Üí (1 : G) ‚àà U\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  inv' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U\n\n"}
{"name":"AddGroupFilterBasis.zero'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst‚úù : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Membership.mem U 0","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ‚àÄ {U}, U ‚àà sets ‚Üí (0 : A) ‚àà U\n  add' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V + V ‚äÜ U\n  neg' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ -x) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ + x + -x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"AddGroupFilterBasis.add'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst‚úù : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HAdd.hAdd V V) U)","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ‚àÄ {U}, U ‚àà sets ‚Üí (0 : A) ‚àà U\n  add' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V + V ‚äÜ U\n  neg' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ -x) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ + x + -x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"AddGroupFilterBasis.neg'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst‚úù : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => Neg.neg x) U))","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ‚àÄ {U}, U ‚àà sets ‚Üí (0 : A) ‚àà U\n  add' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V + V ‚äÜ U\n  neg' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ -x) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ + x + -x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"AddGroupFilterBasis.conj'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst‚úù : AddGroup A\nself : AddGroupFilterBasis A\nx‚ÇÄ : A\nU : Set A\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HAdd.hAdd (HAdd.hAdd x‚ÇÄ x) (Neg.neg x‚ÇÄ)) U))","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ‚àÄ {U}, U ‚àà sets ‚Üí (0 : A) ‚àà U\n  add' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V + V ‚äÜ U\n  neg' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ -x) ‚Åª¬π' U\n  conj' : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ + x + -x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"GroupFilterBasis.one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Membership.mem U 1","decl":"@[to_additive]\ntheorem one {U : Set G} : U ‚àà B ‚Üí (1 : G) ‚àà U :=\n  GroupFilterBasis.one'\n\n"}
{"name":"AddGroupFilterBasis.zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Membership.mem U 0","decl":"@[to_additive]\ntheorem one {U : Set G} : U ‚àà B ‚Üí (1 : G) ‚àà U :=\n  GroupFilterBasis.one'\n\n"}
{"name":"GroupFilterBasis.mul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"@[to_additive]\ntheorem mul {U : Set G} : U ‚àà B ‚Üí ‚àÉ V ‚àà B, V * V ‚äÜ U :=\n  GroupFilterBasis.mul'\n\n"}
{"name":"AddGroupFilterBasis.add","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HAdd.hAdd V V) U)","decl":"@[to_additive]\ntheorem mul {U : Set G} : U ‚àà B ‚Üí ‚àÉ V ‚àà B, V * V ‚äÜ U :=\n  GroupFilterBasis.mul'\n\n"}
{"name":"GroupFilterBasis.inv","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => Inv.inv x) U))","decl":"@[to_additive]\ntheorem inv {U : Set G} : U ‚àà B ‚Üí ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U :=\n  GroupFilterBasis.inv'\n\n"}
{"name":"AddGroupFilterBasis.neg","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => Neg.neg x) U))","decl":"@[to_additive]\ntheorem inv {U : Set G} : U ‚àà B ‚Üí ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚Åª¬π) ‚Åª¬π' U :=\n  GroupFilterBasis.inv'\n\n"}
{"name":"GroupFilterBasis.conj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nx‚ÇÄ : G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul (HMul.hMul x‚ÇÄ x) (Inv.inv x‚ÇÄ)) U))","decl":"@[to_additive]\ntheorem conj : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà B ‚Üí ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U :=\n  GroupFilterBasis.conj'\n\n"}
{"name":"AddGroupFilterBasis.conj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nx‚ÇÄ : G\nU : Set G\na‚úù : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HAdd.hAdd (HAdd.hAdd x‚ÇÄ x) (Neg.neg x‚ÇÄ)) U))","decl":"@[to_additive]\ntheorem conj : ‚àÄ x‚ÇÄ, ‚àÄ {U}, U ‚àà B ‚Üí ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x * x‚ÇÄ‚Åª¬π) ‚Åª¬π' U :=\n  GroupFilterBasis.conj'\n\n"}
{"name":"AddGroupFilterBasis.subset_add_self","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\nh : Membership.mem B U\n‚ä¢ HasSubset.Subset U (HAdd.hAdd U U)","decl":"@[to_additive]\ntheorem subset_mul_self (B : GroupFilterBasis G) {U : Set G} (h : U ‚àà B) : U ‚äÜ U * U :=\n  fun x x_in ‚Ü¶ ‚ü®1, one h, x, x_in, one_mul x‚ü©\n\n"}
{"name":"GroupFilterBasis.subset_mul_self","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nU : Set G\nh : Membership.mem B U\n‚ä¢ HasSubset.Subset U (HMul.hMul U U)","decl":"@[to_additive]\ntheorem subset_mul_self (B : GroupFilterBasis G) {U : Set G} (h : U ‚àà B) : U ‚äÜ U * U :=\n  fun x x_in ‚Ü¶ ‚ü®1, one h, x, x_in, one_mul x‚ü©\n\n"}
{"name":"AddGroupFilterBasis.N_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\n‚ä¢ Eq (B.N 0) AddGroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive (attr := simp)]\ntheorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by\n  simp only [N, one_mul, map_id']\n\n"}
{"name":"GroupFilterBasis.N_one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\n‚ä¢ Eq (B.N 1) GroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive (attr := simp)]\ntheorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by\n  simp only [N, one_mul, map_id']\n\n"}
{"name":"AddGroupFilterBasis.hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nx : G\n‚ä¢ (B.N x).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HAdd.hAdd x y) V","decl":"@[to_additive]\nprotected theorem hasBasis (B : GroupFilterBasis G) (x : G) :\n    HasBasis (B.N x) (fun V : Set G ‚Ü¶ V ‚àà B) fun V ‚Ü¶ (fun y ‚Ü¶ x * y) '' V :=\n  HasBasis.map (fun y ‚Ü¶ x * y) toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nx : G\n‚ä¢ (B.N x).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HMul.hMul x y) V","decl":"@[to_additive]\nprotected theorem hasBasis (B : GroupFilterBasis G) (x : G) :\n    HasBasis (B.N x) (fun V : Set G ‚Ü¶ V ‚àà B) fun V ‚Ü¶ (fun y ‚Ü¶ x * y) '' V :=\n  HasBasis.map (fun y ‚Ü¶ x * y) toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nx‚ÇÄ : G\n‚ä¢ Eq (nhds x‚ÇÄ) (B.N x‚ÇÄ)","decl":"@[to_additive]\ntheorem nhds_eq (B : GroupFilterBasis G) {x‚ÇÄ : G} : @nhds G B.topology x‚ÇÄ = B.N x‚ÇÄ := by\n  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis (fun x ‚Ü¶ (FilterBasis.hasBasis _).map _)\n  ¬∑ intro a U U_in\n    exact ‚ü®1, B.one U_in, mul_one a‚ü©\n  ¬∑ intro a U U_in\n    rcases GroupFilterBasis.mul U_in with ‚ü®V, V_in, hVU‚ü©\n    filter_upwards [image_mem_map (B.mem_filter_of_mem V_in)]\n    rintro _ ‚ü®x, hx, rfl‚ü©\n    calc\n      (a * x) ‚Ä¢ V ‚àà (a * x) ‚Ä¢ B.filter := smul_set_mem_smul_filter <| B.mem_filter_of_mem V_in\n      _ = a ‚Ä¢ x ‚Ä¢ V := smul_smul .. |>.symm\n      _ ‚äÜ a ‚Ä¢ (V * V) := smul_set_mono <| smul_set_subset_smul hx\n      _ ‚äÜ a ‚Ä¢ U := smul_set_mono hVU\n\n"}
{"name":"AddGroupFilterBasis.nhds_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nx‚ÇÄ : G\n‚ä¢ Eq (nhds x‚ÇÄ) (B.N x‚ÇÄ)","decl":"@[to_additive]\ntheorem nhds_eq (B : GroupFilterBasis G) {x‚ÇÄ : G} : @nhds G B.topology x‚ÇÄ = B.N x‚ÇÄ := by\n  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis (fun x ‚Ü¶ (FilterBasis.hasBasis _).map _)\n  ¬∑ intro a U U_in\n    exact ‚ü®1, B.one U_in, mul_one a‚ü©\n  ¬∑ intro a U U_in\n    rcases GroupFilterBasis.mul U_in with ‚ü®V, V_in, hVU‚ü©\n    filter_upwards [image_mem_map (B.mem_filter_of_mem V_in)]\n    rintro _ ‚ü®x, hx, rfl‚ü©\n    calc\n      (a * x) ‚Ä¢ V ‚àà (a * x) ‚Ä¢ B.filter := smul_set_mem_smul_filter <| B.mem_filter_of_mem V_in\n      _ = a ‚Ä¢ x ‚Ä¢ V := smul_smul .. |>.symm\n      _ ‚äÜ a ‚Ä¢ (V * V) := smul_set_mono <| smul_set_subset_smul hx\n      _ ‚äÜ a ‚Ä¢ U := smul_set_mono hVU\n\n"}
{"name":"AddGroupFilterBasis.nhds_zero_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\n‚ä¢ Eq (nhds 0) AddGroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive]\ntheorem nhds_one_eq (B : GroupFilterBasis G) :\n    @nhds G B.topology (1 : G) = B.toFilterBasis.filter := by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n\n"}
{"name":"GroupFilterBasis.nhds_one_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\n‚ä¢ Eq (nhds 1) GroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive]\ntheorem nhds_one_eq (B : GroupFilterBasis G) :\n    @nhds G B.topology (1 : G) = B.toFilterBasis.filter := by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n\n"}
{"name":"AddGroupFilterBasis.nhds_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nx‚ÇÄ : G\n‚ä¢ (nhds x‚ÇÄ).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HAdd.hAdd x‚ÇÄ y) V","decl":"@[to_additive]\ntheorem nhds_hasBasis (B : GroupFilterBasis G) (x‚ÇÄ : G) :\n    HasBasis (@nhds G B.topology x‚ÇÄ) (fun V : Set G ‚Ü¶ V ‚àà B) fun V ‚Ü¶ (fun y ‚Ü¶ x‚ÇÄ * y) '' V := by\n  rw [B.nhds_eq]\n  apply B.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nx‚ÇÄ : G\n‚ä¢ (nhds x‚ÇÄ).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HMul.hMul x‚ÇÄ y) V","decl":"@[to_additive]\ntheorem nhds_hasBasis (B : GroupFilterBasis G) (x‚ÇÄ : G) :\n    HasBasis (@nhds G B.topology x‚ÇÄ) (fun V : Set G ‚Ü¶ V ‚àà B) fun V ‚Ü¶ (fun y ‚Ü¶ x‚ÇÄ * y) '' V := by\n  rw [B.nhds_eq]\n  apply B.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_one_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\n‚ä¢ (nhds 1).HasBasis (fun V => Membership.mem B V) id","decl":"@[to_additive]\ntheorem nhds_one_hasBasis (B : GroupFilterBasis G) :\n    HasBasis (@nhds G B.topology 1) (fun V : Set G ‚Ü¶ V ‚àà B) id := by\n  rw [B.nhds_one_eq]\n  exact B.toFilterBasis.hasBasis\n\n"}
{"name":"AddGroupFilterBasis.nhds_zero_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\n‚ä¢ (nhds 0).HasBasis (fun V => Membership.mem B V) id","decl":"@[to_additive]\ntheorem nhds_one_hasBasis (B : GroupFilterBasis G) :\n    HasBasis (@nhds G B.topology 1) (fun V : Set G ‚Ü¶ V ‚àà B) id := by\n  rw [B.nhds_one_eq]\n  exact B.toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.mem_nhds_one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\nU : Set G\nhU : Membership.mem B U\n‚ä¢ Membership.mem (nhds 1) U","decl":"@[to_additive]\ntheorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ‚àà B) :\n    U ‚àà @nhds G B.topology 1 := by\n  rw [B.nhds_one_hasBasis.mem_iff]\n  exact ‚ü®U, hU, rfl.subset‚ü©\n\n-- See note [lower instance priority]\n"}
{"name":"AddGroupFilterBasis.mem_nhds_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\nhU : Membership.mem B U\n‚ä¢ Membership.mem (nhds 0) U","decl":"@[to_additive]\ntheorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ‚àà B) :\n    U ‚àà @nhds G B.topology 1 := by\n  rw [B.nhds_one_hasBasis.mem_iff]\n  exact ‚ü®U, hU, rfl.subset‚ü©\n\n-- See note [lower instance priority]\n"}
{"name":"AddGroupFilterBasis.isTopologicalAddGroup","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : AddGroup G\nB : AddGroupFilterBasis G\n‚ä¢ TopologicalAddGroup G","decl":"/-- If a group is endowed with a topological structure coming from a group filter basis then it's a\ntopological group. -/\n@[to_additive \"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group.\"]\ninstance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :\n    @TopologicalGroup G B.topology _ := by\n  letI := B.topology\n  have basis := B.nhds_one_hasBasis\n  have basis' := basis.prod basis\n  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_\n  ¬∑ rw [basis'.tendsto_iff basis]\n    suffices ‚àÄ U ‚àà B, ‚àÉ V W, (V ‚àà B ‚àß W ‚àà B) ‚àß ‚àÄ a b, a ‚àà V ‚Üí b ‚àà W ‚Üí a * b ‚àà U by simpa\n    intro U U_in\n    rcases mul U_in with ‚ü®V, V_in, hV‚ü©\n    refine ‚ü®V, V, ‚ü®V_in, V_in‚ü©, ?_‚ü©\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  ¬∑ rw [basis.tendsto_iff basis]\n    intro U U_in\n    simpa using inv U_in\n  ¬∑ intro x‚ÇÄ\n    rw [nhds_eq, nhds_one_eq]\n    rfl\n  ¬∑ intro x‚ÇÄ\n    rw [basis.tendsto_iff basis]\n    intro U U_in\n    exact conj x‚ÇÄ U_in\n\n"}
{"name":"GroupFilterBasis.isTopologicalGroup","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst‚úù : Group G\nB : GroupFilterBasis G\n‚ä¢ TopologicalGroup G","decl":"/-- If a group is endowed with a topological structure coming from a group filter basis then it's a\ntopological group. -/\n@[to_additive \"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group.\"]\ninstance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :\n    @TopologicalGroup G B.topology _ := by\n  letI := B.topology\n  have basis := B.nhds_one_hasBasis\n  have basis' := basis.prod basis\n  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_\n  ¬∑ rw [basis'.tendsto_iff basis]\n    suffices ‚àÄ U ‚àà B, ‚àÉ V W, (V ‚àà B ‚àß W ‚àà B) ‚àß ‚àÄ a b, a ‚àà V ‚Üí b ‚àà W ‚Üí a * b ‚àà U by simpa\n    intro U U_in\n    rcases mul U_in with ‚ü®V, V_in, hV‚ü©\n    refine ‚ü®V, V, ‚ü®V_in, V_in‚ü©, ?_‚ü©\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  ¬∑ rw [basis.tendsto_iff basis]\n    intro U U_in\n    simpa using inv U_in\n  ¬∑ intro x‚ÇÄ\n    rw [nhds_eq, nhds_one_eq]\n    rfl\n  ¬∑ intro x‚ÇÄ\n    rw [basis.tendsto_iff basis]\n    intro U U_in\n    exact conj x‚ÇÄ U_in\n\n"}
{"name":"RingFilterBasis.mul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nself : RingFilterBasis R\nU : Set R\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  mul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x) ‚Åª¬π' U\n  mul_right' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x * x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"RingFilterBasis.mul_left'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nself : RingFilterBasis R\nx‚ÇÄ : R\nU : Set R\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x‚ÇÄ x) U))","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  mul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x) ‚Åª¬π' U\n  mul_right' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x * x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"RingFilterBasis.mul_right'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nself : RingFilterBasis R\nx‚ÇÄ : R\nU : Set R\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x x‚ÇÄ) U))","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V * V ‚äÜ U\n  mul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x) ‚Åª¬π' U\n  mul_right' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x * x‚ÇÄ) ‚Åª¬π' U\n\n"}
{"name":"RingFilterBasis.mul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nB : RingFilterBasis R\nU : Set R\nhU : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"theorem mul {U : Set R} (hU : U ‚àà B) : ‚àÉ V ‚àà B, V * V ‚äÜ U :=\n  mul' hU\n\n"}
{"name":"RingFilterBasis.mul_left","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nB : RingFilterBasis R\nx‚ÇÄ : R\nU : Set R\nhU : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x‚ÇÄ x) U))","decl":"theorem mul_left (x‚ÇÄ : R) {U : Set R} (hU : U ‚àà B) : ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ * x) ‚Åª¬π' U :=\n  mul_left' x‚ÇÄ hU\n\n"}
{"name":"RingFilterBasis.mul_right","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nB : RingFilterBasis R\nx‚ÇÄ : R\nU : Set R\nhU : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x x‚ÇÄ) U))","decl":"theorem mul_right (x‚ÇÄ : R) {U : Set R} (hU : U ‚àà B) : ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x * x‚ÇÄ) ‚Åª¬π' U :=\n  mul_right' x‚ÇÄ hU\n\n"}
{"name":"RingFilterBasis.isTopologicalRing","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst‚úù : Ring R\nB : RingFilterBasis R\n‚ä¢ TopologicalRing R","decl":"/-- If a ring is endowed with a topological structure coming from\na ring filter basis then it's a topological ring. -/\ninstance (priority := 100) isTopologicalRing {R : Type u} [Ring R] (B : RingFilterBasis R) :\n    @TopologicalRing R B.topology _ := by\n  let B' := B.toAddGroupFilterBasis\n  letI := B'.topology\n  have basis := B'.nhds_zero_hasBasis\n  have basis' := basis.prod basis\n  haveI := B'.isTopologicalAddGroup\n  apply TopologicalRing.of_addGroup_of_nhds_zero\n  ¬∑ rw [basis'.tendsto_iff basis]\n    suffices ‚àÄ U ‚àà B', ‚àÉ V W, (V ‚àà B' ‚àß W ‚àà B') ‚àß ‚àÄ a b, a ‚àà V ‚Üí b ‚àà W ‚Üí a * b ‚àà U by simpa\n    intro U U_in\n    rcases B.mul U_in with ‚ü®V, V_in, hV‚ü©\n    refine ‚ü®V, V, ‚ü®V_in, V_in‚ü©, ?_‚ü©\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  ¬∑ intro x‚ÇÄ\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_left x‚ÇÄ\n  ¬∑ intro x‚ÇÄ\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_right x‚ÇÄ\n\n"}
{"name":"ModuleFilterBasis.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù‚Åµ : CommRing R\ninst‚úù‚Å¥ : TopologicalSpace R\ninst‚úù¬≥ : AddCommGroup M\ninst‚úù¬≤ : Module R M\ninst‚úù¬π : SizeOf R\ninst‚úù : SizeOf M\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ‚àÄ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ‚àÄ (x‚ÇÄ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))\nsmul_right' : ‚àÄ (m‚ÇÄ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\n‚ä¢ Eq (SizeOf.sizeOf { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupFilterBasis))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.smul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nself : ModuleFilterBasis R M\nU : Set M\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.smul_left'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nself : ModuleFilterBasis R M\nx‚ÇÄ : R\nU : Set M\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.mk.inj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\ntoAddGroupFilterBasis‚úù : AddGroupFilterBasis M\nsmul'‚úù : ‚àÄ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left'‚úù : ‚àÄ (x‚ÇÄ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))\nsmul_right'‚úù : ‚àÄ (m‚ÇÄ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ‚àÄ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ‚àÄ (x‚ÇÄ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))\nsmul_right' : ‚àÄ (m‚ÇÄ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\nx‚úù : Eq { toAddGroupFilterBasis := toAddGroupFilterBasis‚úù, smul' := smul'‚úù, smul_left' := smul_left'‚úù, smul_right' := smul_right'‚úù } { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }\n‚ä¢ Eq toAddGroupFilterBasis‚úù toAddGroupFilterBasis","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.smul_right'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nself : ModuleFilterBasis R M\nm‚ÇÄ : M\nU : Set M\na‚úù : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n‚ä¢ Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.mk.injEq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\ntoAddGroupFilterBasis‚úù : AddGroupFilterBasis M\nsmul'‚úù : ‚àÄ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left'‚úù : ‚àÄ (x‚ÇÄ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))\nsmul_right'‚úù : ‚àÄ (m‚ÇÄ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ‚àÄ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ‚àÄ (x‚ÇÄ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))\nsmul_right' : ‚àÄ (m‚ÇÄ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U ‚Üí Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\n‚ä¢ Eq (Eq { toAddGroupFilterBasis := toAddGroupFilterBasis‚úù, smul' := smul'‚úù, smul_left' := smul_left'‚úù, smul_right' := smul_right'‚úù } { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }) (Eq toAddGroupFilterBasis‚úù toAddGroupFilterBasis)","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ‚àÄ {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà sets, V ‚Ä¢ W ‚äÜ U\n  smul_left' : ‚àÄ (x‚ÇÄ : R) {U}, U ‚àà sets ‚Üí ‚àÉ V ‚àà sets, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U\n  smul_right' : ‚àÄ (m‚ÇÄ : M) {U}, U ‚àà sets ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U\n\n"}
{"name":"ModuleFilterBasis.smul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nB : ModuleFilterBasis R M\nU : Set M\nhU : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem B W) (HasSubset.Subset (HSMul.hSMul V W) U))","decl":"theorem smul {U : Set M} (hU : U ‚àà B) : ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ W ‚àà B, V ‚Ä¢ W ‚äÜ U :=\n  B.smul' hU\n\n"}
{"name":"ModuleFilterBasis.smul_left","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nB : ModuleFilterBasis R M\nx‚ÇÄ : R\nU : Set M\nhU : Membership.mem B U\n‚ä¢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x‚ÇÄ x) U))","decl":"theorem smul_left (x‚ÇÄ : R) {U : Set M} (hU : U ‚àà B) : ‚àÉ V ‚àà B, V ‚äÜ (fun x ‚Ü¶ x‚ÇÄ ‚Ä¢ x) ‚Åª¬π' U :=\n  B.smul_left' x‚ÇÄ hU\n\n"}
{"name":"ModuleFilterBasis.smul_right","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≥ : CommRing R\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nB : ModuleFilterBasis R M\nm‚ÇÄ : M\nU : Set M\nhU : Membership.mem B U\n‚ä¢ Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m‚ÇÄ)) (nhds 0)","decl":"theorem smul_right (m‚ÇÄ : M) {U : Set M} (hU : U ‚àà B) : ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà U :=\n  B.smul_right' m‚ÇÄ hU\n\n"}
{"name":"ContinuousSMul.of_basis_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù‚Å∂ : CommRing R\ninst‚úù‚Åµ : TopologicalSpace R\ninst‚úù‚Å¥ : AddCommGroup M\ninst‚úù¬≥ : Module R M\nŒπ : Type u_3\ninst‚úù¬≤ : TopologicalRing R\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : TopologicalAddGroup M\np : Œπ ‚Üí Prop\nb : Œπ ‚Üí Set M\nh : (nhds 0).HasBasis p b\nhsmul : ‚àÄ {i : Œπ}, p i ‚Üí Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun j => And (p j) (HasSubset.Subset (HSMul.hSMul V (b j)) (b i)))\nhsmul_left : ‚àÄ (x‚ÇÄ : R) {i : Œπ}, p i ‚Üí Exists fun j => And (p j) (Set.MapsTo (fun x => HSMul.hSMul x‚ÇÄ x) (b j) (b i))\nhsmul_right : ‚àÄ (m‚ÇÄ : M) {i : Œπ}, p i ‚Üí Filter.Eventually (fun x => Membership.mem (b i) (HSMul.hSMul x m‚ÇÄ)) (nhds 0)\n‚ä¢ ContinuousSMul R M","decl":"/-- A topological add group with a basis of `ùìù 0` satisfying the axioms of `ModuleFilterBasis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a byproduct of the proof, so this is just a free\nquality-of-life improvement. -/\ntheorem _root_.ContinuousSMul.of_basis_zero {Œπ : Type*} [TopologicalRing R] [TopologicalSpace M]\n    [TopologicalAddGroup M] {p : Œπ ‚Üí Prop} {b : Œπ ‚Üí Set M} (h : HasBasis (ùìù 0) p b)\n    (hsmul : ‚àÄ {i}, p i ‚Üí ‚àÉ V ‚àà ùìù (0 : R), ‚àÉ j, p j ‚àß V ‚Ä¢ b j ‚äÜ b i)\n    (hsmul_left : ‚àÄ (x‚ÇÄ : R) {i}, p i ‚Üí ‚àÉ j, p j ‚àß MapsTo (x‚ÇÄ ‚Ä¢ ¬∑) (b j) (b i))\n    (hsmul_right : ‚àÄ (m‚ÇÄ : M) {i}, p i ‚Üí ‚àÄ·∂† x in ùìù (0 : R), x ‚Ä¢ m‚ÇÄ ‚àà b i) : ContinuousSMul R M := by\n  apply ContinuousSMul.of_nhds_zero\n  ¬∑ rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul hi with ‚ü®V, V_in, j, hj, hVj‚ü©\n    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)\n    rintro ‚ü®v, w‚ü© ‚ü®v_in : v ‚àà V, w_in : w ‚àà b j‚ü©\n    exact hVj (Set.smul_mem_smul v_in w_in)\n  ¬∑ intro m‚ÇÄ\n    rw [h.tendsto_right_iff]\n    intro i hi\n    exact hsmul_right m‚ÇÄ hi\n  ¬∑ intro x‚ÇÄ\n    rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul_left x‚ÇÄ hi with ‚ü®j, hj, hji‚ü©\n    exact mem_of_superset (h.mem_of_mem hj) hji\n\n"}
{"name":"ModuleFilterBasis.continuousSMul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù‚Å¥ : CommRing R\ninst‚úù¬≥ : TopologicalSpace R\ninst‚úù¬≤ : AddCommGroup M\ninst‚úù¬π : Module R M\nB : ModuleFilterBasis R M\ninst‚úù : TopologicalRing R\n‚ä¢ ContinuousSMul R M","decl":"/-- If a module is endowed with a topological structure coming from\na module filter basis then it's a topological module. -/\ninstance (priority := 100) continuousSMul [TopologicalRing R] :\n    @ContinuousSMul R M _ _ B.topology := by\n  let B' := B.toAddGroupFilterBasis\n  let _ := B'.topology\n  have _ := B'.isTopologicalAddGroup\n  exact ContinuousSMul.of_basis_zero B'.nhds_zero_hasBasis\n      (fun {_} => by simpa using B.smul)\n      (by simpa using B.smul_left) B.smul_right\n\n"}
