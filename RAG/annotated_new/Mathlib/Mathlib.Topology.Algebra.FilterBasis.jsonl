{"name":"GroupFilterBasis.inv'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nself : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => Inv.inv x) U))","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  inv' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U\n\n"}
{"name":"GroupFilterBasis.conj'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nself : GroupFilterBasis G\nx₀ : G\nU : Set G\na✝ : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul (HMul.hMul x₀ x) (Inv.inv x₀)) U))","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  inv' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U\n\n"}
{"name":"GroupFilterBasis.mul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nself : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem GroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  inv' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U\n\n"}
{"name":"GroupFilterBasis.one'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nself : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem GroupFilterBasis.toFilterBasis.sets U\n⊢ Membership.mem U 1","decl":"/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.\n  Example : if `G` is a topological group then the neighbourhoods of the identity are a\n  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass GroupFilterBasis (G : Type u) [Group G] extends FilterBasis G where\n  one' : ∀ {U}, U ∈ sets → (1 : G) ∈ U\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  inv' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U\n\n"}
{"name":"AddGroupFilterBasis.zero'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst✝ : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Membership.mem U 0","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U\n  add' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V + V ⊆ U\n  neg' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ -x) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ + x + -x₀) ⁻¹' U\n\n"}
{"name":"AddGroupFilterBasis.add'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst✝ : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HAdd.hAdd V V) U)","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U\n  add' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V + V ⊆ U\n  neg' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ -x) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ + x + -x₀) ⁻¹' U\n\n"}
{"name":"AddGroupFilterBasis.neg'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst✝ : AddGroup A\nself : AddGroupFilterBasis A\nU : Set A\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => Neg.neg x) U))","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U\n  add' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V + V ⊆ U\n  neg' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ -x) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ + x + -x₀) ⁻¹' U\n\n"}
{"name":"AddGroupFilterBasis.conj'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"A : Type u\ninst✝ : AddGroup A\nself : AddGroupFilterBasis A\nx₀ : A\nU : Set A\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HAdd.hAdd (HAdd.hAdd x₀ x) (Neg.neg x₀)) U))","decl":"/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional\n  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an\n  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology\n  compatible with the group structure on `G`. -/\nclass AddGroupFilterBasis (A : Type u) [AddGroup A] extends FilterBasis A where\n  zero' : ∀ {U}, U ∈ sets → (0 : A) ∈ U\n  add' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V + V ⊆ U\n  neg' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ -x) ⁻¹' U\n  conj' : ∀ x₀, ∀ {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ + x + -x₀) ⁻¹' U\n\n"}
{"name":"GroupFilterBasis.one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Membership.mem U 1","decl":"@[to_additive]\ntheorem one {U : Set G} : U ∈ B → (1 : G) ∈ U :=\n  GroupFilterBasis.one'\n\n"}
{"name":"AddGroupFilterBasis.zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Membership.mem U 0","decl":"@[to_additive]\ntheorem one {U : Set G} : U ∈ B → (1 : G) ∈ U :=\n  GroupFilterBasis.one'\n\n"}
{"name":"GroupFilterBasis.mul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"@[to_additive]\ntheorem mul {U : Set G} : U ∈ B → ∃ V ∈ B, V * V ⊆ U :=\n  GroupFilterBasis.mul'\n\n"}
{"name":"AddGroupFilterBasis.add","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HAdd.hAdd V V) U)","decl":"@[to_additive]\ntheorem mul {U : Set G} : U ∈ B → ∃ V ∈ B, V * V ⊆ U :=\n  GroupFilterBasis.mul'\n\n"}
{"name":"GroupFilterBasis.inv","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => Inv.inv x) U))","decl":"@[to_additive]\ntheorem inv {U : Set G} : U ∈ B → ∃ V ∈ B, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U :=\n  GroupFilterBasis.inv'\n\n"}
{"name":"AddGroupFilterBasis.neg","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => Neg.neg x) U))","decl":"@[to_additive]\ntheorem inv {U : Set G} : U ∈ B → ∃ V ∈ B, V ⊆ (fun x ↦ x⁻¹) ⁻¹' U :=\n  GroupFilterBasis.inv'\n\n"}
{"name":"GroupFilterBasis.conj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nx₀ : G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul (HMul.hMul x₀ x) (Inv.inv x₀)) U))","decl":"@[to_additive]\ntheorem conj : ∀ x₀, ∀ {U}, U ∈ B → ∃ V ∈ B, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U :=\n  GroupFilterBasis.conj'\n\n"}
{"name":"AddGroupFilterBasis.conj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nx₀ : G\nU : Set G\na✝ : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HAdd.hAdd (HAdd.hAdd x₀ x) (Neg.neg x₀)) U))","decl":"@[to_additive]\ntheorem conj : ∀ x₀, ∀ {U}, U ∈ B → ∃ V ∈ B, V ⊆ (fun x ↦ x₀ * x * x₀⁻¹) ⁻¹' U :=\n  GroupFilterBasis.conj'\n\n"}
{"name":"AddGroupFilterBasis.subset_add_self","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\nh : Membership.mem B U\n⊢ HasSubset.Subset U (HAdd.hAdd U U)","decl":"@[to_additive]\ntheorem subset_mul_self (B : GroupFilterBasis G) {U : Set G} (h : U ∈ B) : U ⊆ U * U :=\n  fun x x_in ↦ ⟨1, one h, x, x_in, one_mul x⟩\n\n"}
{"name":"GroupFilterBasis.subset_mul_self","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nU : Set G\nh : Membership.mem B U\n⊢ HasSubset.Subset U (HMul.hMul U U)","decl":"@[to_additive]\ntheorem subset_mul_self (B : GroupFilterBasis G) {U : Set G} (h : U ∈ B) : U ⊆ U * U :=\n  fun x x_in ↦ ⟨1, one h, x, x_in, one_mul x⟩\n\n"}
{"name":"AddGroupFilterBasis.N_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\n⊢ Eq (B.N 0) AddGroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive (attr := simp)]\ntheorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by\n  simp only [N, one_mul, map_id']\n\n"}
{"name":"GroupFilterBasis.N_one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\n⊢ Eq (B.N 1) GroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive (attr := simp)]\ntheorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter := by\n  simp only [N, one_mul, map_id']\n\n"}
{"name":"AddGroupFilterBasis.hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nx : G\n⊢ (B.N x).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HAdd.hAdd x y) V","decl":"@[to_additive]\nprotected theorem hasBasis (B : GroupFilterBasis G) (x : G) :\n    HasBasis (B.N x) (fun V : Set G ↦ V ∈ B) fun V ↦ (fun y ↦ x * y) '' V :=\n  HasBasis.map (fun y ↦ x * y) toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nx : G\n⊢ (B.N x).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HMul.hMul x y) V","decl":"@[to_additive]\nprotected theorem hasBasis (B : GroupFilterBasis G) (x : G) :\n    HasBasis (B.N x) (fun V : Set G ↦ V ∈ B) fun V ↦ (fun y ↦ x * y) '' V :=\n  HasBasis.map (fun y ↦ x * y) toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nx₀ : G\n⊢ Eq (nhds x₀) (B.N x₀)","decl":"@[to_additive]\ntheorem nhds_eq (B : GroupFilterBasis G) {x₀ : G} : @nhds G B.topology x₀ = B.N x₀ := by\n  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis (fun x ↦ (FilterBasis.hasBasis _).map _)\n  · intro a U U_in\n    exact ⟨1, B.one U_in, mul_one a⟩\n  · intro a U U_in\n    rcases GroupFilterBasis.mul U_in with ⟨V, V_in, hVU⟩\n    filter_upwards [image_mem_map (B.mem_filter_of_mem V_in)]\n    rintro _ ⟨x, hx, rfl⟩\n    calc\n      (a * x) • V ∈ (a * x) • B.filter := smul_set_mem_smul_filter <| B.mem_filter_of_mem V_in\n      _ = a • x • V := smul_smul .. |>.symm\n      _ ⊆ a • (V * V) := smul_set_mono <| smul_set_subset_smul hx\n      _ ⊆ a • U := smul_set_mono hVU\n\n"}
{"name":"AddGroupFilterBasis.nhds_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nx₀ : G\n⊢ Eq (nhds x₀) (B.N x₀)","decl":"@[to_additive]\ntheorem nhds_eq (B : GroupFilterBasis G) {x₀ : G} : @nhds G B.topology x₀ = B.N x₀ := by\n  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis (fun x ↦ (FilterBasis.hasBasis _).map _)\n  · intro a U U_in\n    exact ⟨1, B.one U_in, mul_one a⟩\n  · intro a U U_in\n    rcases GroupFilterBasis.mul U_in with ⟨V, V_in, hVU⟩\n    filter_upwards [image_mem_map (B.mem_filter_of_mem V_in)]\n    rintro _ ⟨x, hx, rfl⟩\n    calc\n      (a * x) • V ∈ (a * x) • B.filter := smul_set_mem_smul_filter <| B.mem_filter_of_mem V_in\n      _ = a • x • V := smul_smul .. |>.symm\n      _ ⊆ a • (V * V) := smul_set_mono <| smul_set_subset_smul hx\n      _ ⊆ a • U := smul_set_mono hVU\n\n"}
{"name":"AddGroupFilterBasis.nhds_zero_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\n⊢ Eq (nhds 0) AddGroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive]\ntheorem nhds_one_eq (B : GroupFilterBasis G) :\n    @nhds G B.topology (1 : G) = B.toFilterBasis.filter := by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n\n"}
{"name":"GroupFilterBasis.nhds_one_eq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\n⊢ Eq (nhds 1) GroupFilterBasis.toFilterBasis.filter","decl":"@[to_additive]\ntheorem nhds_one_eq (B : GroupFilterBasis G) :\n    @nhds G B.topology (1 : G) = B.toFilterBasis.filter := by\n  rw [B.nhds_eq]\n  simp only [N, one_mul]\n  exact map_id\n\n"}
{"name":"AddGroupFilterBasis.nhds_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nx₀ : G\n⊢ (nhds x₀).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HAdd.hAdd x₀ y) V","decl":"@[to_additive]\ntheorem nhds_hasBasis (B : GroupFilterBasis G) (x₀ : G) :\n    HasBasis (@nhds G B.topology x₀) (fun V : Set G ↦ V ∈ B) fun V ↦ (fun y ↦ x₀ * y) '' V := by\n  rw [B.nhds_eq]\n  apply B.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nx₀ : G\n⊢ (nhds x₀).HasBasis (fun V => Membership.mem B V) fun V => Set.image (fun y => HMul.hMul x₀ y) V","decl":"@[to_additive]\ntheorem nhds_hasBasis (B : GroupFilterBasis G) (x₀ : G) :\n    HasBasis (@nhds G B.topology x₀) (fun V : Set G ↦ V ∈ B) fun V ↦ (fun y ↦ x₀ * y) '' V := by\n  rw [B.nhds_eq]\n  apply B.hasBasis\n\n"}
{"name":"GroupFilterBasis.nhds_one_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\n⊢ (nhds 1).HasBasis (fun V => Membership.mem B V) id","decl":"@[to_additive]\ntheorem nhds_one_hasBasis (B : GroupFilterBasis G) :\n    HasBasis (@nhds G B.topology 1) (fun V : Set G ↦ V ∈ B) id := by\n  rw [B.nhds_one_eq]\n  exact B.toFilterBasis.hasBasis\n\n"}
{"name":"AddGroupFilterBasis.nhds_zero_hasBasis","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\n⊢ (nhds 0).HasBasis (fun V => Membership.mem B V) id","decl":"@[to_additive]\ntheorem nhds_one_hasBasis (B : GroupFilterBasis G) :\n    HasBasis (@nhds G B.topology 1) (fun V : Set G ↦ V ∈ B) id := by\n  rw [B.nhds_one_eq]\n  exact B.toFilterBasis.hasBasis\n\n"}
{"name":"GroupFilterBasis.mem_nhds_one","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\nU : Set G\nhU : Membership.mem B U\n⊢ Membership.mem (nhds 1) U","decl":"@[to_additive]\ntheorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ∈ B) :\n    U ∈ @nhds G B.topology 1 := by\n  rw [B.nhds_one_hasBasis.mem_iff]\n  exact ⟨U, hU, rfl.subset⟩\n\n-- See note [lower instance priority]\n"}
{"name":"AddGroupFilterBasis.mem_nhds_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\nU : Set G\nhU : Membership.mem B U\n⊢ Membership.mem (nhds 0) U","decl":"@[to_additive]\ntheorem mem_nhds_one (B : GroupFilterBasis G) {U : Set G} (hU : U ∈ B) :\n    U ∈ @nhds G B.topology 1 := by\n  rw [B.nhds_one_hasBasis.mem_iff]\n  exact ⟨U, hU, rfl.subset⟩\n\n-- See note [lower instance priority]\n"}
{"name":"AddGroupFilterBasis.isTopologicalAddGroup","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : AddGroup G\nB : AddGroupFilterBasis G\n⊢ TopologicalAddGroup G","decl":"/-- If a group is endowed with a topological structure coming from a group filter basis then it's a\ntopological group. -/\n@[to_additive \"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group.\"]\ninstance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :\n    @TopologicalGroup G B.topology _ := by\n  letI := B.topology\n  have basis := B.nhds_one_hasBasis\n  have basis' := basis.prod basis\n  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_\n  · rw [basis'.tendsto_iff basis]\n    suffices ∀ U ∈ B, ∃ V W, (V ∈ B ∧ W ∈ B) ∧ ∀ a b, a ∈ V → b ∈ W → a * b ∈ U by simpa\n    intro U U_in\n    rcases mul U_in with ⟨V, V_in, hV⟩\n    refine ⟨V, V, ⟨V_in, V_in⟩, ?_⟩\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  · rw [basis.tendsto_iff basis]\n    intro U U_in\n    simpa using inv U_in\n  · intro x₀\n    rw [nhds_eq, nhds_one_eq]\n    rfl\n  · intro x₀\n    rw [basis.tendsto_iff basis]\n    intro U U_in\n    exact conj x₀ U_in\n\n"}
{"name":"GroupFilterBasis.isTopologicalGroup","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"G : Type u\ninst✝ : Group G\nB : GroupFilterBasis G\n⊢ TopologicalGroup G","decl":"/-- If a group is endowed with a topological structure coming from a group filter basis then it's a\ntopological group. -/\n@[to_additive \"If a group is endowed with a topological structure coming from a group filter basis\nthen it's a topological group.\"]\ninstance (priority := 100) isTopologicalGroup (B : GroupFilterBasis G) :\n    @TopologicalGroup G B.topology _ := by\n  letI := B.topology\n  have basis := B.nhds_one_hasBasis\n  have basis' := basis.prod basis\n  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_\n  · rw [basis'.tendsto_iff basis]\n    suffices ∀ U ∈ B, ∃ V W, (V ∈ B ∧ W ∈ B) ∧ ∀ a b, a ∈ V → b ∈ W → a * b ∈ U by simpa\n    intro U U_in\n    rcases mul U_in with ⟨V, V_in, hV⟩\n    refine ⟨V, V, ⟨V_in, V_in⟩, ?_⟩\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  · rw [basis.tendsto_iff basis]\n    intro U U_in\n    simpa using inv U_in\n  · intro x₀\n    rw [nhds_eq, nhds_one_eq]\n    rfl\n  · intro x₀\n    rw [basis.tendsto_iff basis]\n    intro U U_in\n    exact conj x₀ U_in\n\n"}
{"name":"RingFilterBasis.mul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nself : RingFilterBasis R\nU : Set R\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  mul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x) ⁻¹' U\n  mul_right' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x * x₀) ⁻¹' U\n\n"}
{"name":"RingFilterBasis.mul_left'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nself : RingFilterBasis R\nx₀ : R\nU : Set R\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x₀ x) U))","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  mul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x) ⁻¹' U\n  mul_right' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x * x₀) ⁻¹' U\n\n"}
{"name":"RingFilterBasis.mul_right'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nself : RingFilterBasis R\nx₀ : R\nU : Set R\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x x₀) U))","decl":"/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.\n  Example : if `R` is a topological ring then the neighbourhoods of the identity are a\n  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a\n  topology on `R` which is compatible with the ring structure. -/\nclass RingFilterBasis (R : Type u) [Ring R] extends AddGroupFilterBasis R where\n  mul' : ∀ {U}, U ∈ sets → ∃ V ∈ sets, V * V ⊆ U\n  mul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ * x) ⁻¹' U\n  mul_right' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x * x₀) ⁻¹' U\n\n"}
{"name":"RingFilterBasis.mul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nB : RingFilterBasis R\nU : Set R\nhU : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset (HMul.hMul V V) U)","decl":"theorem mul {U : Set R} (hU : U ∈ B) : ∃ V ∈ B, V * V ⊆ U :=\n  mul' hU\n\n"}
{"name":"RingFilterBasis.mul_left","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nB : RingFilterBasis R\nx₀ : R\nU : Set R\nhU : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x₀ x) U))","decl":"theorem mul_left (x₀ : R) {U : Set R} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ (fun x ↦ x₀ * x) ⁻¹' U :=\n  mul_left' x₀ hU\n\n"}
{"name":"RingFilterBasis.mul_right","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nB : RingFilterBasis R\nx₀ : R\nU : Set R\nhU : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HMul.hMul x x₀) U))","decl":"theorem mul_right (x₀ : R) {U : Set R} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ (fun x ↦ x * x₀) ⁻¹' U :=\n  mul_right' x₀ hU\n\n"}
{"name":"RingFilterBasis.isTopologicalRing","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u\ninst✝ : Ring R\nB : RingFilterBasis R\n⊢ TopologicalRing R","decl":"/-- If a ring is endowed with a topological structure coming from\na ring filter basis then it's a topological ring. -/\ninstance (priority := 100) isTopologicalRing {R : Type u} [Ring R] (B : RingFilterBasis R) :\n    @TopologicalRing R B.topology _ := by\n  let B' := B.toAddGroupFilterBasis\n  letI := B'.topology\n  have basis := B'.nhds_zero_hasBasis\n  have basis' := basis.prod basis\n  haveI := B'.isTopologicalAddGroup\n  apply TopologicalRing.of_addGroup_of_nhds_zero\n  · rw [basis'.tendsto_iff basis]\n    suffices ∀ U ∈ B', ∃ V W, (V ∈ B' ∧ W ∈ B') ∧ ∀ a b, a ∈ V → b ∈ W → a * b ∈ U by simpa\n    intro U U_in\n    rcases B.mul U_in with ⟨V, V_in, hV⟩\n    refine ⟨V, V, ⟨V_in, V_in⟩, ?_⟩\n    intro a b a_in b_in\n    exact hV <| mul_mem_mul a_in b_in\n  · intro x₀\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_left x₀\n  · intro x₀\n    rw [basis.tendsto_iff basis]\n    intro U\n    simpa using B.mul_right x₀\n\n"}
{"name":"ModuleFilterBasis.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : TopologicalSpace R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ∀ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ∀ (x₀ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))\nsmul_right' : ∀ (m₀ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)\n⊢ Eq (SizeOf.sizeOf { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupFilterBasis))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.smul'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : ModuleFilterBasis R M\nU : Set M\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.smul_left'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : ModuleFilterBasis R M\nx₀ : R\nU : Set M\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.mk.inj","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ntoAddGroupFilterBasis✝ : AddGroupFilterBasis M\nsmul'✝ : ∀ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left'✝ : ∀ (x₀ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))\nsmul_right'✝ : ∀ (m₀ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ∀ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ∀ (x₀ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))\nsmul_right' : ∀ (m₀ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)\nx✝ : Eq { toAddGroupFilterBasis := toAddGroupFilterBasis✝, smul' := smul'✝, smul_left' := smul_left'✝, smul_right' := smul_right'✝ } { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }\n⊢ Eq toAddGroupFilterBasis✝ toAddGroupFilterBasis","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.smul_right'","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nself : ModuleFilterBasis R M\nm₀ : M\nU : Set M\na✝ : Membership.mem AddGroupFilterBasis.toFilterBasis.sets U\n⊢ Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.mk.injEq","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ntoAddGroupFilterBasis✝ : AddGroupFilterBasis M\nsmul'✝ : ∀ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left'✝ : ∀ (x₀ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))\nsmul_right'✝ : ∀ (m₀ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)\ntoAddGroupFilterBasis : AddGroupFilterBasis M\nsmul' : ∀ {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets W) (HasSubset.Subset (HSMul.hSMul V W) U))\nsmul_left' : ∀ (x₀ : R) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Exists fun V => And (Membership.mem AddGroupFilterBasis.toFilterBasis.sets V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))\nsmul_right' : ∀ (m₀ : M) {U : Set M}, Membership.mem AddGroupFilterBasis.toFilterBasis.sets U → Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)\n⊢ Eq (Eq { toAddGroupFilterBasis := toAddGroupFilterBasis✝, smul' := smul'✝, smul_left' := smul_left'✝, smul_right' := smul_right'✝ } { toAddGroupFilterBasis := toAddGroupFilterBasis, smul' := smul', smul_left' := smul_left', smul_right' := smul_right' }) (Eq toAddGroupFilterBasis✝ toAddGroupFilterBasis)","decl":"/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.\n  Example : if `M` is a topological module then the neighbourhoods of zero are a\n  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology\n  compatible with the module structure on `M`. -/\nstructure ModuleFilterBasis (R M : Type*) [CommRing R] [TopologicalSpace R] [AddCommGroup M]\n  [Module R M] extends AddGroupFilterBasis M where\n  smul' : ∀ {U}, U ∈ sets → ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ sets, V • W ⊆ U\n  smul_left' : ∀ (x₀ : R) {U}, U ∈ sets → ∃ V ∈ sets, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U\n  smul_right' : ∀ (m₀ : M) {U}, U ∈ sets → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U\n\n"}
{"name":"ModuleFilterBasis.smul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : ModuleFilterBasis R M\nU : Set M\nhU : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun W => And (Membership.mem B W) (HasSubset.Subset (HSMul.hSMul V W) U))","decl":"theorem smul {U : Set M} (hU : U ∈ B) : ∃ V ∈ 𝓝 (0 : R), ∃ W ∈ B, V • W ⊆ U :=\n  B.smul' hU\n\n"}
{"name":"ModuleFilterBasis.smul_left","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : ModuleFilterBasis R M\nx₀ : R\nU : Set M\nhU : Membership.mem B U\n⊢ Exists fun V => And (Membership.mem B V) (HasSubset.Subset V (Set.preimage (fun x => HSMul.hSMul x₀ x) U))","decl":"theorem smul_left (x₀ : R) {U : Set M} (hU : U ∈ B) : ∃ V ∈ B, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U :=\n  B.smul_left' x₀ hU\n\n"}
{"name":"ModuleFilterBasis.smul_right","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : TopologicalSpace R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : ModuleFilterBasis R M\nm₀ : M\nU : Set M\nhU : Membership.mem B U\n⊢ Filter.Eventually (fun x => Membership.mem U (HSMul.hSMul x m₀)) (nhds 0)","decl":"theorem smul_right (m₀ : M) {U : Set M} (hU : U ∈ B) : ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ U :=\n  B.smul_right' m₀ hU\n\n"}
{"name":"ContinuousSMul.of_basis_zero","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : TopologicalSpace R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nι : Type u_3\ninst✝² : TopologicalRing R\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalAddGroup M\np : ι → Prop\nb : ι → Set M\nh : (nhds 0).HasBasis p b\nhsmul : ∀ {i : ι}, p i → Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun j => And (p j) (HasSubset.Subset (HSMul.hSMul V (b j)) (b i)))\nhsmul_left : ∀ (x₀ : R) {i : ι}, p i → Exists fun j => And (p j) (Set.MapsTo (fun x => HSMul.hSMul x₀ x) (b j) (b i))\nhsmul_right : ∀ (m₀ : M) {i : ι}, p i → Filter.Eventually (fun x => Membership.mem (b i) (HSMul.hSMul x m₀)) (nhds 0)\n⊢ ContinuousSMul R M","decl":"/-- A topological add group with a basis of `𝓝 0` satisfying the axioms of `ModuleFilterBasis`\nis a topological module.\n\nThis lemma is mathematically useless because one could obtain such a result by applying\n`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized\nby their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.\n\nBut it turns out it's just easier to get it as a byproduct of the proof, so this is just a free\nquality-of-life improvement. -/\ntheorem _root_.ContinuousSMul.of_basis_zero {ι : Type*} [TopologicalRing R] [TopologicalSpace M]\n    [TopologicalAddGroup M] {p : ι → Prop} {b : ι → Set M} (h : HasBasis (𝓝 0) p b)\n    (hsmul : ∀ {i}, p i → ∃ V ∈ 𝓝 (0 : R), ∃ j, p j ∧ V • b j ⊆ b i)\n    (hsmul_left : ∀ (x₀ : R) {i}, p i → ∃ j, p j ∧ MapsTo (x₀ • ·) (b j) (b i))\n    (hsmul_right : ∀ (m₀ : M) {i}, p i → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ b i) : ContinuousSMul R M := by\n  apply ContinuousSMul.of_nhds_zero\n  · rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul hi with ⟨V, V_in, j, hj, hVj⟩\n    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)\n    rintro ⟨v, w⟩ ⟨v_in : v ∈ V, w_in : w ∈ b j⟩\n    exact hVj (Set.smul_mem_smul v_in w_in)\n  · intro m₀\n    rw [h.tendsto_right_iff]\n    intro i hi\n    exact hsmul_right m₀ hi\n  · intro x₀\n    rw [h.tendsto_right_iff]\n    intro i hi\n    rcases hsmul_left x₀ hi with ⟨j, hj, hji⟩\n    exact mem_of_superset (h.mem_of_mem hj) hji\n\n"}
{"name":"ModuleFilterBasis.continuousSMul","module":"Mathlib.Topology.Algebra.FilterBasis","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : TopologicalSpace R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nB : ModuleFilterBasis R M\ninst✝ : TopologicalRing R\n⊢ ContinuousSMul R M","decl":"/-- If a module is endowed with a topological structure coming from\na module filter basis then it's a topological module. -/\ninstance (priority := 100) continuousSMul [TopologicalRing R] :\n    @ContinuousSMul R M _ _ B.topology := by\n  let B' := B.toAddGroupFilterBasis\n  let _ := B'.topology\n  have _ := B'.isTopologicalAddGroup\n  exact ContinuousSMul.of_basis_zero B'.nhds_zero_hasBasis\n      (fun {_} => by simpa using B.smul)\n      (by simpa using B.smul_left) B.smul_right\n\n"}
