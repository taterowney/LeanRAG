{"name":"Field.instNeZeroFinSepDegree","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\n⊢ NeZero (Field.finSepDegree F E)","decl":"instance instNeZeroFinSepDegree [FiniteDimensional F E] : NeZero (finSepDegree F E) :=\n  ⟨Nat.card_ne_zero.2 ⟨inferInstance, Fintype.finite <| minpoly.AlgHom.fintype _ _ _⟩⟩\n\n"}
{"name":"Field.finSepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Field.finSepDegree F E) (Field.finSepDegree F K)","decl":"/-- If `E` and `K` are isomorphic as `F`-algebras, then they have the same `Field.finSepDegree`\nover `F`. -/\ntheorem finSepDegree_eq_of_equiv (i : E ≃ₐ[F] K) :\n    finSepDegree F E = finSepDegree F K := Nat.card_congr (embEquivOfEquiv F E K i)\n\n"}
{"name":"Field.finSepDegree_self","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Field.finSepDegree F F) 1","decl":"@[simp]\ntheorem finSepDegree_self : finSepDegree F F = 1 := by\n  have : Cardinal.mk (Emb F F) = 1 := le_antisymm\n    (Cardinal.le_one_iff_subsingleton.2 AlgHom.subsingleton)\n    (Cardinal.one_le_iff_ne_zero.2 <| Cardinal.mk_ne_zero _)\n  rw [finSepDegree, Nat.card, this, Cardinal.one_toNat]\n\n"}
{"name":"IntermediateField.finSepDegree_bot","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Field.finSepDegree F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem finSepDegree_bot : finSepDegree F (⊥ : IntermediateField F E) = 1 := by\n  rw [finSepDegree_eq_of_equiv _ _ _ (botEquiv F E), finSepDegree_self]\n\n"}
{"name":"IntermediateField.finSepDegree_bot'","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.finSepDegree F (Subtype fun x => Membership.mem Bot.bot x)) (Field.finSepDegree F E)","decl":"@[simp]\ntheorem finSepDegree_bot' : finSepDegree F (⊥ : IntermediateField E K) = finSepDegree F E :=\n  finSepDegree_eq_of_equiv _ _ _ ((botEquiv E K).restrictScalars F)\n\n"}
{"name":"IntermediateField.finSepDegree_top","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.finSepDegree F (Subtype fun x => Membership.mem Top.top x)) (Field.finSepDegree F K)","decl":"@[simp]\ntheorem finSepDegree_top : finSepDegree F (⊤ : IntermediateField E K) = finSepDegree F K :=\n  finSepDegree_eq_of_equiv _ _ _ ((topEquiv (F := E) (E := K)).restrictScalars F)\n\n"}
{"name":"Field.finSepDegree_eq_of_adjoin_splits","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\nS : Set E\nhS : Eq (IntermediateField.adjoin F S) Top.top\nhK : ∀ (s : E), Membership.mem S s → And (IsIntegral F s) (Polynomial.Splits (algebraMap F K) (minpoly F s))\n⊢ Eq (Field.finSepDegree F E) (Nat.card (AlgHom F E K))","decl":"/-- The `Field.finSepDegree F E` is equal to the cardinality of `E →ₐ[F] K`\nif `E = F(S)` such that every element\n`s` of `S` is integral (= algebraic) over `F` and whose minimal polynomial splits in `K`. -/\ntheorem finSepDegree_eq_of_adjoin_splits {S : Set E} (hS : adjoin F S = ⊤)\n    (hK : ∀ s ∈ S, IsIntegral F s ∧ Splits (algebraMap F K) (minpoly F s)) :\n    finSepDegree F E = Nat.card (E →ₐ[F] K) := Nat.card_congr (embEquivOfAdjoinSplits F E K hS hK)\n\n"}
{"name":"Field.finSepDegree_eq_of_isAlgClosed","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra.IsAlgebraic F E\ninst✝ : IsAlgClosed K\n⊢ Eq (Field.finSepDegree F E) (Nat.card (AlgHom F E K))","decl":"/-- The `Field.finSepDegree F E` is equal to the cardinality of `E →ₐ[F] K` as a natural number,\nwhen `E / F` is algebraic and `K / F` is algebraically closed. -/\n@[stacks 09HJ \"We use `finSepDegree` to state a more general result.\"]\ntheorem finSepDegree_eq_of_isAlgClosed [Algebra.IsAlgebraic F E] [IsAlgClosed K] :\n    finSepDegree F E = Nat.card (E →ₐ[F] K) := Nat.card_congr (embEquivOfIsAlgClosed F E K)\n\n"}
{"name":"Field.infinite_emb_of_transcendental","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nH : Algebra.Transcendental F E\n⊢ Infinite (Field.Emb F E)","decl":"/-- If the field extension `E / F` is transcendental, then `Field.Emb F E` is infinite. -/\ninstance infinite_emb_of_transcendental [H : Algebra.Transcendental F E] : Infinite (Emb F E) := by\n  obtain ⟨ι, x, hx⟩ := exists_isTranscendenceBasis' _ (algebraMap F E).injective\n  have := hx.isAlgebraic_field\n  rw [← (embProdEmbOfIsAlgebraic F (adjoin F (Set.range x)) E).infinite_iff]\n  refine @Prod.infinite_of_left _ _ ?_ _\n  rw [← (embEquivOfEquiv _ _ _ hx.1.aevalEquivField).infinite_iff]\n  obtain ⟨i⟩ := hx.nonempty_iff_transcendental.2 H\n  let K := FractionRing (MvPolynomial ι F)\n  let i1 := IsScalarTower.toAlgHom F (MvPolynomial ι F) (AlgebraicClosure K)\n  have hi1 : Function.Injective i1 := by\n    rw [IsScalarTower.coe_toAlgHom', IsScalarTower.algebraMap_eq _ K]\n    exact (algebraMap K (AlgebraicClosure K)).injective.comp (IsFractionRing.injective _ _)\n  let f (n : ℕ) : Emb F K := IsFractionRing.liftAlgHom\n    (g := i1.comp <| MvPolynomial.aeval fun i : ι ↦ MvPolynomial.X i ^ (n + 1)) <| hi1.comp <| by\n      simpa [algebraicIndependent_iff_injective_aeval] using\n        MvPolynomial.algebraicIndependent_polynomial_aeval_X _\n          fun i : ι ↦ (Polynomial.transcendental_X F).pow n.succ_pos\n  refine Infinite.of_injective f fun m n h ↦ ?_\n  replace h : (MvPolynomial.X i) ^ (m + 1) = (MvPolynomial.X i) ^ (n + 1) := hi1 <| by\n    simpa [f, -map_pow] using congr($h (algebraMap _ K (MvPolynomial.X (R := F) i)))\n  simpa using congr(MvPolynomial.totalDegree $h)\n\n"}
{"name":"Field.finSepDegree_eq_zero_of_transcendental","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.Transcendental F E\n⊢ Eq (Field.finSepDegree F E) 0","decl":"/-- If the field extension `E / F` is transcendental, then `Field.finSepDegree F E = 0`, which\nactually means that `Field.Emb F E` is infinite (see `Field.infinite_emb_of_transcendental`). -/\ntheorem finSepDegree_eq_zero_of_transcendental [Algebra.Transcendental F E] :\n    finSepDegree F E = 0 := Nat.card_eq_zero_of_infinite\n\n"}
{"name":"Field.finSepDegree_mul_finSepDegree_of_isAlgebraic","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsAlgebraic E K\n⊢ Eq (HMul.hMul (Field.finSepDegree F E) (Field.finSepDegree E K)) (Field.finSepDegree F K)","decl":"/-- If `K / E / F` is a field extension tower, such that `K / E` is algebraic, then their\nseparable degrees satisfy the tower law\n$[E:F]_s [K:E]_s = [K:F]_s$. See also `Module.finrank_mul_finrank`. -/\n@[stacks 09HK \"Part 1, `finSepDegree` variant\"]\ntheorem finSepDegree_mul_finSepDegree_of_isAlgebraic\n    [Algebra E K] [IsScalarTower F E K] [Algebra.IsAlgebraic E K] :\n    finSepDegree F E * finSepDegree E K = finSepDegree F K := by\n  simpa only [Nat.card_prod] using Nat.card_congr (embProdEmbOfIsAlgebraic F E K)\n\n"}
{"name":"Polynomial.natSepDegree_le_natDegree","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\n⊢ LE.le f.natSepDegree f.natDegree","decl":"/-- The separable degree of a polynomial is smaller than its degree. -/\ntheorem natSepDegree_le_natDegree : f.natSepDegree ≤ f.natDegree := by\n  have := f.map (algebraMap F f.SplittingField) |>.card_roots'\n  rw [← aroots_def, natDegree_map] at this\n  classical\n  exact (f.aroots f.SplittingField).toFinset_card_le.trans this\n\n"}
{"name":"Polynomial.natSepDegree_X_sub_C","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nx : F\n⊢ Eq (HSub.hSub Polynomial.X (Polynomial.C x)).natSepDegree 1","decl":"@[simp]\ntheorem natSepDegree_X_sub_C (x : F) : (X - C x).natSepDegree = 1 := by\n  simp only [natSepDegree, aroots_X_sub_C, Multiset.toFinset_singleton, Finset.card_singleton]\n\n"}
{"name":"Polynomial.natSepDegree_X","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq Polynomial.X.natSepDegree 1","decl":"@[simp]\ntheorem natSepDegree_X : (X : F[X]).natSepDegree = 1 := by\n  simp only [natSepDegree, aroots_X, Multiset.toFinset_singleton, Finset.card_singleton]\n\n"}
{"name":"Polynomial.natSepDegree_eq_zero","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nh : Eq f.natDegree 0\n⊢ Eq f.natSepDegree 0","decl":"/-- A constant polynomial has zero separable degree. -/\ntheorem natSepDegree_eq_zero (h : f.natDegree = 0) : f.natSepDegree = 0 := by\n  linarith only [natSepDegree_le_natDegree f, h]\n\n"}
{"name":"Polynomial.natSepDegree_C","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nx : F\n⊢ Eq (Polynomial.C x).natSepDegree 0","decl":"@[simp]\ntheorem natSepDegree_C (x : F) : (C x).natSepDegree = 0 := natSepDegree_eq_zero _ (natDegree_C _)\n\n"}
{"name":"Polynomial.natSepDegree_zero","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Polynomial.natSepDegree 0) 0","decl":"@[simp]\ntheorem natSepDegree_zero : (0 : F[X]).natSepDegree = 0 := by\n  rw [← C_0, natSepDegree_C]\n\n"}
{"name":"Polynomial.natSepDegree_one","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Polynomial.natSepDegree 1) 0","decl":"@[simp]\ntheorem natSepDegree_one : (1 : F[X]).natSepDegree = 0 := by\n  rw [← C_1, natSepDegree_C]\n\n"}
{"name":"Polynomial.natSepDegree_ne_zero","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nh : Ne f.natDegree 0\n⊢ Ne f.natSepDegree 0","decl":"/-- A non-constant polynomial has non-zero separable degree. -/\ntheorem natSepDegree_ne_zero (h : f.natDegree ≠ 0) : f.natSepDegree ≠ 0 := by\n  rw [natSepDegree, ne_eq, Finset.card_eq_zero, ← ne_eq, ← Finset.nonempty_iff_ne_empty]\n  use rootOfSplits _ (SplittingField.splits f) (ne_of_apply_ne _ h)\n  classical\n  rw [Multiset.mem_toFinset, mem_aroots]\n  exact ⟨ne_of_apply_ne _ h, map_rootOfSplits _ (SplittingField.splits f) (ne_of_apply_ne _ h)⟩\n\n"}
{"name":"Polynomial.natSepDegree_eq_zero_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\n⊢ Iff (Eq f.natSepDegree 0) (Eq f.natDegree 0)","decl":"/-- A polynomial has zero separable degree if and only if it is constant. -/\ntheorem natSepDegree_eq_zero_iff : f.natSepDegree = 0 ↔ f.natDegree = 0 :=\n  ⟨(natSepDegree_ne_zero f).mtr, natSepDegree_eq_zero f⟩\n\n"}
{"name":"Polynomial.natSepDegree_ne_zero_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\n⊢ Iff (Ne f.natSepDegree 0) (Ne f.natDegree 0)","decl":"/-- A polynomial has non-zero separable degree if and only if it is non-constant. -/\ntheorem natSepDegree_ne_zero_iff : f.natSepDegree ≠ 0 ↔ f.natDegree ≠ 0 :=\n  Iff.not <| natSepDegree_eq_zero_iff f\n\n"}
{"name":"Polynomial.natSepDegree_eq_natDegree_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nhf : Ne f 0\n⊢ Iff (Eq f.natSepDegree f.natDegree) f.Separable","decl":"/-- The separable degree of a non-zero polynomial is equal to its degree if and only if\nit is separable. -/\ntheorem natSepDegree_eq_natDegree_iff (hf : f ≠ 0) :\n    f.natSepDegree = f.natDegree ↔ f.Separable := by\n  classical\n  simp_rw [← card_rootSet_eq_natDegree_iff_of_splits hf (SplittingField.splits f),\n    rootSet_def, Finset.coe_sort_coe, Fintype.card_coe]\n  rfl\n\n"}
{"name":"Polynomial.natSepDegree_eq_natDegree_of_separable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nh : f.Separable\n⊢ Eq f.natSepDegree f.natDegree","decl":"/-- If a polynomial is separable, then its separable degree is equal to its degree. -/\ntheorem natSepDegree_eq_natDegree_of_separable (h : f.Separable) :\n    f.natSepDegree = f.natDegree := (natSepDegree_eq_natDegree_iff f h.ne_zero).2 h\n\n"}
{"name":"Polynomial.Separable.natSepDegree_eq_natDegree","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nh : f.Separable\n⊢ Eq f.natSepDegree f.natDegree","decl":"variable {f} in\n/-- Same as `Polynomial.natSepDegree_eq_natDegree_of_separable`, but enables the use of\ndot notation. -/\ntheorem Separable.natSepDegree_eq_natDegree (h : f.Separable) :\n    f.natSepDegree = f.natDegree := natSepDegree_eq_natDegree_of_separable f h\n\n"}
{"name":"Polynomial.natSepDegree_eq_of_splits","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nf : Polynomial F\ninst✝ : DecidableEq E\nh : Polynomial.Splits (algebraMap F E) f\n⊢ Eq f.natSepDegree (f.aroots E).toFinset.card","decl":"/-- If a polynomial splits over `E`, then its separable degree is equal to\nthe number of distinct roots of it over `E`. -/\ntheorem natSepDegree_eq_of_splits [DecidableEq E] (h : f.Splits (algebraMap F E)) :\n    f.natSepDegree = (f.aroots E).toFinset.card := by\n  classical\n  rw [aroots, ← (SplittingField.lift f h).comp_algebraMap, ← map_map,\n    roots_map _ ((splits_id_iff_splits _).mpr <| SplittingField.splits f),\n    Multiset.toFinset_map, Finset.card_image_of_injective _ (RingHom.injective _), natSepDegree]\n\n"}
{"name":"Polynomial.natSepDegree_eq_of_isAlgClosed","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nf : Polynomial F\ninst✝¹ : DecidableEq E\ninst✝ : IsAlgClosed E\n⊢ Eq f.natSepDegree (f.aroots E).toFinset.card","decl":"variable (E) in\n/-- The separable degree of a polynomial is equal to\nthe number of distinct roots of it over any algebraically closed field. -/\ntheorem natSepDegree_eq_of_isAlgClosed [DecidableEq E] [IsAlgClosed E] :\n    f.natSepDegree = (f.aroots E).toFinset.card :=\n  natSepDegree_eq_of_splits f (IsAlgClosed.splits_codomain f)\n\n"}
{"name":"Polynomial.natSepDegree_map","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"E : Type v\ninst✝¹ : Field E\nK : Type w\ninst✝ : Field K\nf : Polynomial E\ni : RingHom E K\n⊢ Eq (Polynomial.map i f).natSepDegree f.natSepDegree","decl":"theorem natSepDegree_map (f : E[X]) (i : E →+* K) : (f.map i).natSepDegree = f.natSepDegree := by\n  classical\n  let _ := i.toAlgebra\n  simp_rw [show i = algebraMap E K by rfl, natSepDegree_eq_of_isAlgClosed (AlgebraicClosure K),\n    aroots_def, map_map, ← IsScalarTower.algebraMap_eq]\n\n"}
{"name":"Polynomial.natSepDegree_C_mul","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nx : F\nhx : Ne x 0\n⊢ Eq (HMul.hMul (Polynomial.C x) f).natSepDegree f.natSepDegree","decl":"@[simp]\ntheorem natSepDegree_C_mul {x : F} (hx : x ≠ 0) :\n    (C x * f).natSepDegree = f.natSepDegree := by\n  classical\n  simp only [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_C_mul _ hx]\n\n"}
{"name":"Polynomial.natSepDegree_smul_nonzero","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nx : F\nhx : Ne x 0\n⊢ Eq (HSMul.hSMul x f).natSepDegree f.natSepDegree","decl":"@[simp]\ntheorem natSepDegree_smul_nonzero {x : F} (hx : x ≠ 0) :\n    (x • f).natSepDegree = f.natSepDegree := by\n  classical\n  simp only [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_smul_nonzero _ hx]\n\n"}
{"name":"Polynomial.natSepDegree_pow","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nn : Nat\n⊢ Eq (HPow.hPow f n).natSepDegree (ite (Eq n 0) 0 f.natSepDegree)","decl":"@[simp]\ntheorem natSepDegree_pow {n : ℕ} : (f ^ n).natSepDegree = if n = 0 then 0 else f.natSepDegree := by\n  classical\n  simp only [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_pow]\n  by_cases h : n = 0\n  · simp only [h, zero_smul, Multiset.toFinset_zero, Finset.card_empty, ite_true]\n  simp only [h, Multiset.toFinset_nsmul _ n h, ite_false]\n\n"}
{"name":"Polynomial.natSepDegree_pow_of_ne_zero","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow f n).natSepDegree f.natSepDegree","decl":"theorem natSepDegree_pow_of_ne_zero {n : ℕ} (hn : n ≠ 0) :\n    (f ^ n).natSepDegree = f.natSepDegree := by simp_rw [natSepDegree_pow, hn, ite_false]\n\n"}
{"name":"Polynomial.natSepDegree_X_pow","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nn : Nat\n⊢ Eq (HPow.hPow Polynomial.X n).natSepDegree (ite (Eq n 0) 0 1)","decl":"theorem natSepDegree_X_pow {n : ℕ} : (X ^ n : F[X]).natSepDegree = if n = 0 then 0 else 1 := by\n  simp only [natSepDegree_pow, natSepDegree_X]\n\n"}
{"name":"Polynomial.natSepDegree_X_sub_C_pow","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nx : F\nn : Nat\n⊢ Eq (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) n).natSepDegree (ite (Eq n 0) 0 1)","decl":"theorem natSepDegree_X_sub_C_pow {x : F} {n : ℕ} :\n    ((X - C x) ^ n).natSepDegree = if n = 0 then 0 else 1 := by\n  simp only [natSepDegree_pow, natSepDegree_X_sub_C]\n\n"}
{"name":"Polynomial.natSepDegree_C_mul_X_sub_C_pow","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nx y : F\nn : Nat\nhx : Ne x 0\n⊢ Eq (HMul.hMul (Polynomial.C x) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C y)) n)).natSepDegree (ite (Eq n 0) 0 1)","decl":"theorem natSepDegree_C_mul_X_sub_C_pow {x y : F} {n : ℕ} (hx : x ≠ 0) :\n    (C x * (X - C y) ^ n).natSepDegree = if n = 0 then 0 else 1 := by\n  simp only [natSepDegree_C_mul _ hx, natSepDegree_X_sub_C_pow]\n\n"}
{"name":"Polynomial.natSepDegree_mul","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf g : Polynomial F\n⊢ LE.le (HMul.hMul f g).natSepDegree (HAdd.hAdd f.natSepDegree g.natSepDegree)","decl":"theorem natSepDegree_mul (g : F[X]) :\n    (f * g).natSepDegree ≤ f.natSepDegree + g.natSepDegree := by\n  by_cases h : f * g = 0\n  · simp only [h, natSepDegree_zero, zero_le]\n  classical\n  simp_rw [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_mul h, Multiset.toFinset_add]\n  exact Finset.card_union_le _ _\n\n"}
{"name":"Polynomial.natSepDegree_mul_eq_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf g : Polynomial F\n⊢ Iff (Eq (HMul.hMul f g).natSepDegree (HAdd.hAdd f.natSepDegree g.natSepDegree)) (Or (And (Eq f 0) (Eq g 0)) (IsCoprime f g))","decl":"theorem natSepDegree_mul_eq_iff (g : F[X]) :\n    (f * g).natSepDegree = f.natSepDegree + g.natSepDegree ↔ (f = 0 ∧ g = 0) ∨ IsCoprime f g := by\n  by_cases h : f * g = 0\n  · rw [mul_eq_zero] at h\n    wlog hf : f = 0 generalizing f g\n    · simpa only [mul_comm, add_comm, and_comm,\n        isCoprime_comm] using this g f h.symm (h.resolve_left hf)\n    rw [hf, zero_mul, natSepDegree_zero, zero_add, isCoprime_zero_left, isUnit_iff, eq_comm,\n      natSepDegree_eq_zero_iff, natDegree_eq_zero]\n    refine ⟨fun ⟨x, h⟩ ↦ ?_, ?_⟩\n    · by_cases hx : x = 0\n      · exact .inl ⟨rfl, by rw [← h, hx, map_zero]⟩\n      exact .inr ⟨x, Ne.isUnit hx, h⟩\n    rintro (⟨-, h⟩ | ⟨x, -, h⟩)\n    · exact ⟨0, by rw [h, map_zero]⟩\n    exact ⟨x, h⟩\n  classical\n  simp_rw [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_mul h, Multiset.toFinset_add,\n    Finset.card_union_eq_card_add_card, Finset.disjoint_iff_ne, Multiset.mem_toFinset, mem_aroots]\n  rw [mul_eq_zero, not_or] at h\n  refine ⟨fun H ↦ .inr (isCoprime_of_irreducible_dvd (not_and.2 fun _ ↦ h.2)\n    fun u hu ⟨v, hf⟩ ⟨w, hg⟩ ↦ ?_), ?_⟩\n  · obtain ⟨x, hx⟩ := IsAlgClosed.exists_aeval_eq_zero\n      (AlgebraicClosure F) _ (degree_pos_of_irreducible hu).ne'\n    exact H x ⟨h.1, by simpa only [map_mul, hx, zero_mul] using congr(aeval x $hf)⟩\n      x ⟨h.2, by simpa only [map_mul, hx, zero_mul] using congr(aeval x $hg)⟩ rfl\n  rintro (⟨rfl, rfl⟩ | hc)\n  · exact (h.1 rfl).elim\n  rintro x hf _ hg rfl\n  obtain ⟨u, v, hfg⟩ := hc\n  simpa only [map_add, map_mul, map_one, hf.2, hg.2, mul_zero, add_zero,\n    zero_ne_one] using congr(aeval x $hfg)\n\n"}
{"name":"Polynomial.natSepDegree_mul_of_isCoprime","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf g : Polynomial F\nhc : IsCoprime f g\n⊢ Eq (HMul.hMul f g).natSepDegree (HAdd.hAdd f.natSepDegree g.natSepDegree)","decl":"theorem natSepDegree_mul_of_isCoprime (g : F[X]) (hc : IsCoprime f g) :\n    (f * g).natSepDegree = f.natSepDegree + g.natSepDegree :=\n  (natSepDegree_mul_eq_iff f g).2 (.inr hc)\n\n"}
{"name":"Polynomial.natSepDegree_le_of_dvd","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf g : Polynomial F\nh1 : Dvd.dvd f g\nh2 : Ne g 0\n⊢ LE.le f.natSepDegree g.natSepDegree","decl":"theorem natSepDegree_le_of_dvd (g : F[X]) (h1 : f ∣ g) (h2 : g ≠ 0) :\n    f.natSepDegree ≤ g.natSepDegree := by\n  classical\n  simp_rw [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F)]\n  exact Finset.card_le_card <| Multiset.toFinset_subset.mpr <|\n    Multiset.Le.subset <| roots.le_of_dvd (map_ne_zero h2) <| map_dvd _ h1\n\n"}
{"name":"Polynomial.natSepDegree_expand","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nq : Nat\nhF : ExpChar F q\nn : Nat\n⊢ Eq ((Polynomial.expand F (HPow.hPow q n)) f).natSepDegree f.natSepDegree","decl":"/-- If a field `F` is of exponential characteristic `q`, then `Polynomial.expand F (q ^ n) f`\nand `f` have the same separable degree. -/\ntheorem natSepDegree_expand (q : ℕ) [hF : ExpChar F q] {n : ℕ} :\n    (expand F (q ^ n) f).natSepDegree = f.natSepDegree := by\n  cases' hF with _ _ hprime _\n  · simp only [one_pow, expand_one]\n  haveI := Fact.mk hprime\n  classical\n  simpa only [natSepDegree_eq_of_isAlgClosed (AlgebraicClosure F), aroots_def, map_expand,\n    Fintype.card_coe] using Fintype.card_eq.2\n      ⟨(f.map (algebraMap F (AlgebraicClosure F))).rootsExpandPowEquivRoots q n⟩\n\n"}
{"name":"Polynomial.natSepDegree_X_pow_char_pow_sub_C","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nq : Nat\ninst✝ : ExpChar F q\nn : Nat\ny : F\n⊢ Eq (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)).natSepDegree 1","decl":"theorem natSepDegree_X_pow_char_pow_sub_C (q : ℕ) [ExpChar F q] (n : ℕ) (y : F) :\n    (X ^ q ^ n - C y).natSepDegree = 1 := by\n  rw [← expand_X, ← expand_C (q ^ n), ← map_sub, natSepDegree_expand, natSepDegree_X_sub_C]\n\n"}
{"name":"Polynomial.IsSeparableContraction.natSepDegree_eq","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf g : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nh : Polynomial.IsSeparableContraction q f g\n⊢ Eq f.natSepDegree g.natDegree","decl":"variable {f} in\n/-- If `g` is a separable contraction of `f`, then the separable degree of `f` is equal to\nthe degree of `g`. -/\ntheorem IsSeparableContraction.natSepDegree_eq {g : Polynomial F} {q : ℕ} [ExpChar F q]\n    (h : IsSeparableContraction q f g) : f.natSepDegree = g.natDegree := by\n  obtain ⟨h1, m, h2⟩ := h\n  rw [← h2, natSepDegree_expand, h1.natSepDegree_eq_natDegree]\n\n"}
{"name":"Polynomial.HasSeparableContraction.natSepDegree_eq","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhf : Polynomial.HasSeparableContraction q f\n⊢ Eq f.natSepDegree hf.degree","decl":"variable {f} in\n/-- If a polynomial has separable contraction, then its separable degree is equal to the degree of\nthe given separable contraction. -/\ntheorem HasSeparableContraction.natSepDegree_eq\n    {q : ℕ} [ExpChar F q] (hf : f.HasSeparableContraction q) :\n    f.natSepDegree = hf.degree := hf.isSeparableContraction.natSepDegree_eq\n\n"}
{"name":"Irreducible.natSepDegree_dvd_natDegree","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nh : Irreducible f\n⊢ Dvd.dvd f.natSepDegree f.natDegree","decl":"/-- The separable degree of an irreducible polynomial divides its degree. -/\ntheorem natSepDegree_dvd_natDegree (h : Irreducible f) :\n    f.natSepDegree ∣ f.natDegree := by\n  obtain ⟨q, _⟩ := ExpChar.exists F\n  have hf := h.hasSeparableContraction q\n  rw [hf.natSepDegree_eq]\n  exact hf.dvd_degree\n\n"}
{"name":"Irreducible.natSepDegree_eq_one_iff_of_monic'","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nhi : Irreducible f\n⊢ Iff (Eq f.natSepDegree 1) (Exists fun n => Exists fun y => Eq f ((Polynomial.expand F (HPow.hPow q n)) (HSub.hSub Polynomial.X (Polynomial.C y))))","decl":"/-- A monic irreducible polynomial over a field `F` of exponential characteristic `q` has\nseparable degree one if and only if it is of the form `Polynomial.expand F (q ^ n) (X - C y)`\nfor some `n : ℕ` and `y : F`. -/\ntheorem natSepDegree_eq_one_iff_of_monic' (q : ℕ) [ExpChar F q] (hm : f.Monic)\n    (hi : Irreducible f) : f.natSepDegree = 1 ↔\n    ∃ (n : ℕ) (y : F), f = expand F (q ^ n) (X - C y) := by\n  refine ⟨fun h ↦ ?_, fun ⟨n, y, h⟩ ↦ ?_⟩\n  · obtain ⟨g, h1, n, rfl⟩ := hi.hasSeparableContraction q\n    have h2 : g.natDegree = 1 := by\n      rwa [natSepDegree_expand _ q, h1.natSepDegree_eq_natDegree] at h\n    rw [((monic_expand_iff <| expChar_pow_pos F q n).mp hm).eq_X_add_C h2]\n    exact ⟨n, -(g.coeff 0), by rw [map_neg, sub_neg_eq_add]⟩\n  rw [h, natSepDegree_expand _ q, natSepDegree_X_sub_C]\n\n"}
{"name":"Irreducible.natSepDegree_eq_one_iff_of_monic","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nhi : Irreducible f\n⊢ Iff (Eq f.natSepDegree 1) (Exists fun n => Exists fun y => Eq f (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)))","decl":"/-- A monic irreducible polynomial over a field `F` of exponential characteristic `q` has\nseparable degree one if and only if it is of the form `X ^ (q ^ n) - C y`\nfor some `n : ℕ` and `y : F`. -/\ntheorem natSepDegree_eq_one_iff_of_monic (q : ℕ) [ExpChar F q] (hm : f.Monic)\n    (hi : Irreducible f) : f.natSepDegree = 1 ↔ ∃ (n : ℕ) (y : F), f = X ^ q ^ n - C y := by\n  simp_rw [hi.natSepDegree_eq_one_iff_of_monic' q hm, map_sub, expand_X, expand_C]\n\n"}
{"name":"Polynomial.Monic.natSepDegree_eq_one_iff_of_irreducible'","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nhi : Irreducible f\n⊢ Iff (Eq f.natSepDegree 1) (Exists fun n => Exists fun y => Eq f ((Polynomial.expand F (HPow.hPow q n)) (HSub.hSub Polynomial.X (Polynomial.C y))))","decl":"alias natSepDegree_eq_one_iff_of_irreducible' := Irreducible.natSepDegree_eq_one_iff_of_monic'\n\n"}
{"name":"Polynomial.Monic.natSepDegree_eq_one_iff_of_irreducible","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nhi : Irreducible f\n⊢ Iff (Eq f.natSepDegree 1) (Exists fun n => Exists fun y => Eq f (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)))","decl":"alias natSepDegree_eq_one_iff_of_irreducible := Irreducible.natSepDegree_eq_one_iff_of_monic\n\n"}
{"name":"Polynomial.Monic.eq_X_sub_C_pow_of_natSepDegree_eq_one_of_splits","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝ : Field F\nf : Polynomial F\nhm : f.Monic\nhs : Polynomial.Splits (RingHom.id F) f\nh : Eq f.natSepDegree 1\n⊢ Exists fun m => Exists fun y => And (Ne m 0) (Eq f (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C y)) m))","decl":"/-- If a monic polynomial of separable degree one splits, then it is of form `(X - C y) ^ m` for\nsome non-zero natural number `m` and some element `y` of `F`. -/\ntheorem eq_X_sub_C_pow_of_natSepDegree_eq_one_of_splits (hm : f.Monic)\n    (hs : f.Splits (RingHom.id F))\n    (h : f.natSepDegree = 1) : ∃ (m : ℕ) (y : F), m ≠ 0 ∧ f = (X - C y) ^ m := by\n  classical\n  have h1 := eq_prod_roots_of_monic_of_splits_id hm hs\n  have h2 := (natSepDegree_eq_of_splits f hs).symm\n  rw [h, aroots_def, Algebra.id.map_eq_id, map_id, Multiset.toFinset_card_eq_one_iff] at h2\n  obtain ⟨h2, y, h3⟩ := h2\n  exact ⟨_, y, h2, by rwa [h3, Multiset.map_nsmul, Multiset.map_singleton, Multiset.prod_nsmul,\n    Multiset.prod_singleton] at h1⟩\n\n"}
{"name":"Polynomial.Monic.eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nhi : Irreducible f\nh : Eq f.natSepDegree 1\n⊢ Exists fun n => Exists fun y => And (Or (Eq n 0) (Not (Membership.mem (frobenius F q).range y))) (Eq f (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)))","decl":"/-- If a monic irreducible polynomial over a field `F` of exponential characteristic `q` has\nseparable degree one, then it is of the form `X ^ (q ^ n) - C y` for some natural number `n`,\nand some element `y` of `F`, such that either `n = 0` or `y` has no `q`-th root in `F`. -/\ntheorem eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible (q : ℕ) [ExpChar F q]\n    (hm : f.Monic) (hi : Irreducible f) (h : f.natSepDegree = 1) : ∃ (n : ℕ) (y : F),\n      (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = X ^ q ^ n - C y := by\n  obtain ⟨n, y, hf⟩ := (hm.natSepDegree_eq_one_iff_of_irreducible q hi).1 h\n  cases id ‹ExpChar F q› with\n  | zero =>\n    simp_rw [one_pow, pow_one] at hf ⊢\n    exact ⟨0, y, .inl rfl, hf⟩\n  | prime hq =>\n    refine ⟨n, y, (em _).imp id fun hn ⟨z, hy⟩ ↦ ?_, hf⟩\n    haveI := expChar_of_injective_ringHom (R := F) C_injective q\n    rw [hf, ← Nat.succ_pred hn, pow_succ, pow_mul, ← hy, frobenius_def, map_pow,\n      ← sub_pow_expChar] at hi\n    exact not_irreducible_pow hq.ne_one hi\n\n"}
{"name":"Polynomial.Monic.eq_X_pow_char_pow_sub_C_pow_of_natSepDegree_eq_one","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\nh : Eq f.natSepDegree 1\n⊢ Exists fun m => Exists fun n => Exists fun y => And (Ne m 0) (And (Or (Eq n 0) (Not (Membership.mem (frobenius F q).range y))) (Eq f (HPow.hPow (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)) m)))","decl":"/-- If a monic polynomial over a field `F` of exponential characteristic `q` has separable degree\none, then it is of the form `(X ^ (q ^ n) - C y) ^ m` for some non-zero natural number `m`,\nsome natural number `n`, and some element `y` of `F`, such that either `n = 0` or `y` has no\n`q`-th root in `F`. -/\ntheorem eq_X_pow_char_pow_sub_C_pow_of_natSepDegree_eq_one (q : ℕ) [ExpChar F q] (hm : f.Monic)\n    (h : f.natSepDegree = 1) : ∃ (m n : ℕ) (y : F),\n      m ≠ 0 ∧ (n = 0 ∨ y ∉ (frobenius F q).range) ∧ f = (X ^ q ^ n - C y) ^ m := by\n  obtain ⟨p, hM, hI, hf⟩ := exists_monic_irreducible_factor _ <| not_isUnit_of_natDegree_pos _\n    <| Nat.pos_of_ne_zero <| (natSepDegree_ne_zero_iff _).1 (h.symm ▸ Nat.one_ne_zero)\n  have hD := (h ▸ natSepDegree_le_of_dvd p f hf hm.ne_zero).antisymm <|\n    Nat.pos_of_ne_zero <| (natSepDegree_ne_zero_iff _).2 hI.natDegree_pos.ne'\n  obtain ⟨n, y, H, hp⟩ := hM.eq_X_pow_char_pow_sub_C_of_natSepDegree_eq_one_of_irreducible q hI hD\n  have hF := finiteMultiplicity_of_degree_pos_of_monic (degree_pos_of_irreducible hI) hM hm.ne_zero\n  classical\n  have hne := (multiplicity_pos_of_dvd hf).ne'\n  refine ⟨_, n, y, hne, H, ?_⟩\n  obtain ⟨c, hf, H⟩ := hF.exists_eq_pow_mul_and_not_dvd\n  rw [hf, natSepDegree_mul_of_isCoprime _ c <| IsCoprime.pow_left <|\n    (hI.isCoprime_or_dvd c).resolve_right H, natSepDegree_pow_of_ne_zero _ hne, hD,\n    add_right_eq_self, natSepDegree_eq_zero_iff] at h\n  simpa only [eq_one_of_monic_natDegree_zero ((hM.pow _).of_mul_monic_left (hf ▸ hm)) h,\n    mul_one, ← hp] using hf\n\n"}
{"name":"Polynomial.Monic.natSepDegree_eq_one_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\ninst✝¹ : Field F\nf : Polynomial F\nq : Nat\ninst✝ : ExpChar F q\nhm : f.Monic\n⊢ Iff (Eq f.natSepDegree 1) (Exists fun m => Exists fun n => Exists fun y => And (Ne m 0) (Eq f (HPow.hPow (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)) m)))","decl":"/-- A monic polynomial over a field `F` of exponential characteristic `q` has separable degree one\nif and only if it is of the form `(X ^ (q ^ n) - C y) ^ m` for some non-zero natural number `m`,\nsome natural number `n`, and some element `y` of `F`. -/\ntheorem natSepDegree_eq_one_iff (q : ℕ) [ExpChar F q] (hm : f.Monic) :\n    f.natSepDegree = 1 ↔ ∃ (m n : ℕ) (y : F), m ≠ 0 ∧ f = (X ^ q ^ n - C y) ^ m := by\n  refine ⟨fun h ↦ ?_, fun ⟨m, n, y, hm, h⟩ ↦ ?_⟩\n  · obtain ⟨m, n, y, hm, -, h⟩ := hm.eq_X_pow_char_pow_sub_C_pow_of_natSepDegree_eq_one q h\n    exact ⟨m, n, y, hm, h⟩\n  simp_rw [h, natSepDegree_pow, hm, ite_false, natSepDegree_X_pow_char_pow_sub_C]\n\n"}
{"name":"minpoly.natSepDegree_eq_one_iff_eq_expand_X_sub_C","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Ring E\ninst✝¹ : IsDomain E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nx : E\n⊢ Iff (Eq (minpoly F x).natSepDegree 1) (Exists fun n => Exists fun y => Eq (minpoly F x) ((Polynomial.expand F (HPow.hPow q n)) (HSub.hSub Polynomial.X (Polynomial.C y))))","decl":"/-- The minimal polynomial of an element of `E / F` of exponential characteristic `q` has\nseparable degree one if and only if the minimal polynomial is of the form\n`Polynomial.expand F (q ^ n) (X - C y)` for some `n : ℕ` and `y : F`. -/\ntheorem natSepDegree_eq_one_iff_eq_expand_X_sub_C : (minpoly F x).natSepDegree = 1 ↔\n    ∃ (n : ℕ) (y : F), minpoly F x = expand F (q ^ n) (X - C y) := by\n  refine ⟨fun h ↦ ?_, fun ⟨n, y, h⟩ ↦ ?_⟩\n  · have halg : IsIntegral F x := by_contra fun h' ↦ by\n      simp only [eq_zero h', natSepDegree_zero, zero_ne_one] at h\n    exact (minpoly.irreducible halg).natSepDegree_eq_one_iff_of_monic' q\n      (minpoly.monic halg) |>.1 h\n  rw [h, natSepDegree_expand _ q, natSepDegree_X_sub_C]\n\n"}
{"name":"minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Ring E\ninst✝¹ : IsDomain E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nx : E\n⊢ Iff (Eq (minpoly F x).natSepDegree 1) (Exists fun n => Exists fun y => Eq (minpoly F x) (HSub.hSub (HPow.hPow Polynomial.X (HPow.hPow q n)) (Polynomial.C y)))","decl":"/-- The minimal polynomial of an element of `E / F` of exponential characteristic `q` has\nseparable degree one if and only if the minimal polynomial is of the form\n`X ^ (q ^ n) - C y` for some `n : ℕ` and `y : F`. -/\ntheorem natSepDegree_eq_one_iff_eq_X_pow_sub_C : (minpoly F x).natSepDegree = 1 ↔\n    ∃ (n : ℕ) (y : F), minpoly F x = X ^ q ^ n - C y := by\n  simp only [minpoly.natSepDegree_eq_one_iff_eq_expand_X_sub_C q, map_sub, expand_X, expand_C]\n\n"}
{"name":"minpoly.natSepDegree_eq_one_iff_pow_mem","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Ring E\ninst✝¹ : IsDomain E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nx : E\n⊢ Iff (Eq (minpoly F x).natSepDegree 1) (Exists fun n => Membership.mem (algebraMap F E).range (HPow.hPow x (HPow.hPow q n)))","decl":"/-- The minimal polynomial of an element `x` of `E / F` of exponential characteristic `q` has\nseparable degree one if and only if `x ^ (q ^ n) ∈ F` for some `n : ℕ`. -/\ntheorem natSepDegree_eq_one_iff_pow_mem : (minpoly F x).natSepDegree = 1 ↔\n    ∃ n : ℕ, x ^ q ^ n ∈ (algebraMap F E).range := by\n  convert_to _ ↔ ∃ (n : ℕ) (y : F), Polynomial.aeval x (X ^ q ^ n - C y) = 0\n  · simp_rw [RingHom.mem_range, map_sub, map_pow, aeval_C, aeval_X, sub_eq_zero, eq_comm]\n  refine ⟨fun h ↦ ?_, fun ⟨n, y, h⟩ ↦ ?_⟩\n  · obtain ⟨n, y, hx⟩ := (minpoly.natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h\n    exact ⟨n, y, hx ▸ aeval F x⟩\n  have hnezero := X_pow_sub_C_ne_zero (expChar_pow_pos F q n) y\n  refine ((natSepDegree_le_of_dvd _ _ (minpoly.dvd F x h) hnezero).trans_eq <|\n    natSepDegree_X_pow_char_pow_sub_C q n y).antisymm ?_\n  rw [Nat.one_le_iff_ne_zero, natSepDegree_ne_zero_iff, ← Nat.one_le_iff_ne_zero]\n  exact minpoly.natDegree_pos <| IsAlgebraic.isIntegral ⟨_, hnezero, h⟩\n\n"}
{"name":"minpoly.natSepDegree_eq_one_iff_eq_X_sub_C_pow","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Ring E\ninst✝¹ : IsDomain E\ninst✝ : Algebra F E\nq : Nat\nhF : ExpChar F q\nx : E\n⊢ Iff (Eq (minpoly F x).natSepDegree 1) (Exists fun n => Eq (Polynomial.map (algebraMap F E) (minpoly F x)) (HPow.hPow (HSub.hSub Polynomial.X (Polynomial.C x)) (HPow.hPow q n)))","decl":"/-- The minimal polynomial of an element `x` of `E / F` of exponential characteristic `q` has\nseparable degree one if and only if the minimal polynomial is of the form\n`(X - x) ^ (q ^ n)` for some `n : ℕ`. -/\ntheorem natSepDegree_eq_one_iff_eq_X_sub_C_pow : (minpoly F x).natSepDegree = 1 ↔\n    ∃ n : ℕ, (minpoly F x).map (algebraMap F E) = (X - C x) ^ q ^ n := by\n  haveI := expChar_of_injective_algebraMap (algebraMap F E).injective q\n  haveI := expChar_of_injective_ringHom (C_injective (R := E)) q\n  refine ⟨fun h ↦ ?_, fun ⟨n, h⟩ ↦ (natSepDegree_eq_one_iff_pow_mem q).2 ?_⟩\n  · obtain ⟨n, y, h⟩ := (natSepDegree_eq_one_iff_eq_X_pow_sub_C q).1 h\n    have hx := congr_arg (Polynomial.aeval x) h.symm\n    rw [minpoly.aeval, map_sub, map_pow, aeval_X, aeval_C, sub_eq_zero, eq_comm] at hx\n    use n\n    rw [h, Polynomial.map_sub, Polynomial.map_pow, map_X, map_C, hx, map_pow,\n      ← sub_pow_expChar_pow_of_commute _ _ (commute_X _)]\n  apply_fun constantCoeff at h\n  simp_rw [map_pow, map_sub, constantCoeff_apply, coeff_map, coeff_X_zero, coeff_C_zero] at h\n  rw [zero_sub, neg_pow, neg_one_pow_expChar_pow] at h\n  exact ⟨n, -(minpoly F x).coeff 0, by rw [map_neg, h, neg_mul, one_mul, neg_neg]⟩\n\n"}
{"name":"IntermediateField.finSepDegree_adjoin_simple_eq_natSepDegree","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nhalg : IsAlgebraic F α\n⊢ Eq (Field.finSepDegree F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) (minpoly F α).natSepDegree","decl":"/-- The separable degree of `F⟮α⟯ / F` is equal to the separable degree of the\nminimal polynomial of `α` over `F`. -/\ntheorem finSepDegree_adjoin_simple_eq_natSepDegree {α : E} (halg : IsAlgebraic F α) :\n    finSepDegree F F⟮α⟯ = (minpoly F α).natSepDegree := by\n  have : finSepDegree F F⟮α⟯ = _ := Nat.card_congr\n    (algHomAdjoinIntegralEquiv F (K := AlgebraicClosure F⟮α⟯) halg.isIntegral)\n  classical\n  rw [this, Nat.card_eq_fintype_card, natSepDegree_eq_of_isAlgClosed (E := AlgebraicClosure F⟮α⟯),\n    ← Fintype.card_coe]\n  simp_rw [Multiset.mem_toFinset]\n\n-- The separable degree of `F⟮α⟯ / F` divides the degree of `F⟮α⟯ / F`.\n-- Marked as `private` because it is a special case of `finSepDegree_dvd_finrank`.\n"}
{"name":"IntermediateField.finSepDegree_adjoin_simple_le_finrank","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nhalg : IsAlgebraic F α\n⊢ LE.le (Field.finSepDegree F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) (Module.finrank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x))","decl":"/-- The separable degree of `F⟮α⟯ / F` is smaller than the degree of `F⟮α⟯ / F` if `α` is\nalgebraic over `F`. -/\ntheorem finSepDegree_adjoin_simple_le_finrank (α : E) (halg : IsAlgebraic F α) :\n    finSepDegree F F⟮α⟯ ≤ finrank F F⟮α⟯ := by\n  haveI := adjoin.finiteDimensional halg.isIntegral\n  exact Nat.le_of_dvd finrank_pos <| finSepDegree_adjoin_simple_dvd_finrank F E α\n\n"}
{"name":"IntermediateField.finSepDegree_adjoin_simple_eq_finrank_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nhalg : IsAlgebraic F α\n⊢ Iff (Eq (Field.finSepDegree F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) (Module.finrank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x))) (IsSeparable F α)","decl":"/-- If `α` is algebraic over `F`, then the separable degree of `F⟮α⟯ / F` is equal to the degree\nof `F⟮α⟯ / F` if and only if `α` is a separable element. -/\ntheorem finSepDegree_adjoin_simple_eq_finrank_iff (α : E) (halg : IsAlgebraic F α) :\n    finSepDegree F F⟮α⟯ = finrank F F⟮α⟯ ↔ IsSeparable F α := by\n  rw [finSepDegree_adjoin_simple_eq_natSepDegree F E halg, adjoin.finrank halg.isIntegral,\n    natSepDegree_eq_natDegree_iff _ (minpoly.ne_zero halg.isIntegral), IsSeparable]\n\n"}
{"name":"Field.finSepDegree_dvd_finrank","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Dvd.dvd (Field.finSepDegree F E) (Module.finrank F E)","decl":"/-- The separable degree of any field extension `E / F` divides the degree of `E / F`. -/\ntheorem finSepDegree_dvd_finrank : finSepDegree F E ∣ finrank F E := by\n  by_cases hfd : FiniteDimensional F E\n  · rw [← finSepDegree_top F, ← finrank_top F E]\n    refine induction_on_adjoin (fun K : IntermediateField F E ↦ finSepDegree F K ∣ finrank F K)\n      (by simp_rw [finSepDegree_bot, IntermediateField.finrank_bot, one_dvd]) (fun L x h ↦ ?_) ⊤\n    simp only at h ⊢\n    have hdvd := mul_dvd_mul h <| finSepDegree_adjoin_simple_dvd_finrank L E x\n    set M := L⟮x⟯\n    have := Algebra.IsAlgebraic.of_finite L M\n    rwa [finSepDegree_mul_finSepDegree_of_isAlgebraic F L M,\n      Module.finrank_mul_finrank F L M] at hdvd\n  rw [finrank_of_infinite_dimensional hfd]\n  exact dvd_zero _\n\n"}
{"name":"Field.finSepDegree_le_finrank","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\n⊢ LE.le (Field.finSepDegree F E) (Module.finrank F E)","decl":"/-- The separable degree of a finite extension `E / F` is smaller than the degree of `E / F`. -/\n@[stacks 09HA \"The inequality\"]\ntheorem finSepDegree_le_finrank [FiniteDimensional F E] :\n    finSepDegree F E ≤ finrank F E := Nat.le_of_dvd finrank_pos <| finSepDegree_dvd_finrank F E\n\n"}
{"name":"Field.finSepDegree_eq_finrank_of_isSeparable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Field.finSepDegree F E) (Module.finrank F E)","decl":"/-- If `E / F` is a separable extension, then its separable degree is equal to its degree.\nWhen `E / F` is infinite, it means that `Field.Emb F E` has infinitely many elements.\n(But the cardinality of `Field.Emb F E` is not equal to `Module.rank F E` in general!) -/\ntheorem finSepDegree_eq_finrank_of_isSeparable [Algebra.IsSeparable F E] :\n    finSepDegree F E = finrank F E := by\n  wlog hfd : FiniteDimensional F E generalizing E with H\n  · rw [finrank_of_infinite_dimensional hfd]\n    have halg := Algebra.IsSeparable.isAlgebraic F E\n    obtain ⟨L, h, h'⟩ := exists_lt_finrank_of_infinite_dimensional hfd (finSepDegree F E)\n    have : Algebra.IsSeparable F L := Algebra.isSeparable_tower_bot_of_isSeparable F L E\n    have := (halg.tower_top L)\n    have hd := finSepDegree_mul_finSepDegree_of_isAlgebraic F L E\n    rw [H L h] at hd\n    by_cases hd' : finSepDegree L E = 0\n    · rw [← hd, hd', mul_zero]\n    linarith only [h', hd, Nat.le_mul_of_pos_right (finrank F L) (Nat.pos_of_ne_zero hd')]\n  rw [← finSepDegree_top F, ← finrank_top F E]\n  refine induction_on_adjoin (fun K : IntermediateField F E ↦ finSepDegree F K = finrank F K)\n    (by simp_rw [finSepDegree_bot, IntermediateField.finrank_bot]) (fun L x h ↦ ?_) ⊤\n  simp only at h ⊢\n  have heq : _ * _ = _ * _ := congr_arg₂ (· * ·) h <|\n    (finSepDegree_adjoin_simple_eq_finrank_iff L E x (IsAlgebraic.of_finite L x)).2 <|\n      IsSeparable.tower_top L (Algebra.IsSeparable.isSeparable F x)\n  set M := L⟮x⟯\n  have := Algebra.IsAlgebraic.of_finite L M\n  rwa [finSepDegree_mul_finSepDegree_of_isAlgebraic F L M,\n    Module.finrank_mul_finrank F L M] at heq\n\n"}
{"name":"Field.Algebra.IsSeparable.finSepDegree_eq","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Field.finSepDegree F E) (Module.finrank F E)","decl":"alias Algebra.IsSeparable.finSepDegree_eq := finSepDegree_eq_finrank_of_isSeparable\n\n"}
{"name":"Field.finSepDegree_eq_finrank_iff","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\n⊢ Iff (Eq (Field.finSepDegree F E) (Module.finrank F E)) (Algebra.IsSeparable F E)","decl":"/-- If `E / F` is a finite extension, then its separable degree is equal to its degree if and\nonly if it is a separable extension. -/\n@[stacks 09HA \"The equality condition\"]\ntheorem finSepDegree_eq_finrank_iff [FiniteDimensional F E] :\n    finSepDegree F E = finrank F E ↔ Algebra.IsSeparable F E :=\n  ⟨fun heq ↦ ⟨fun x ↦ by\n    have halg := IsAlgebraic.of_finite F x\n    refine (finSepDegree_adjoin_simple_eq_finrank_iff F E x halg).1 <| le_antisymm\n      (finSepDegree_adjoin_simple_le_finrank F E x halg) <| le_of_not_lt fun h ↦ ?_\n    have := Nat.mul_lt_mul_of_lt_of_le' h (finSepDegree_le_finrank F⟮x⟯ E) Fin.pos'\n    rw [finSepDegree_mul_finSepDegree_of_isAlgebraic F F⟮x⟯ E,\n      Module.finrank_mul_finrank F F⟮x⟯ E] at this\n    linarith only [heq, this]⟩, fun _ ↦ finSepDegree_eq_finrank_of_isSeparable F E⟩\n\n"}
{"name":"IntermediateField.isSeparable_of_mem_isSeparable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nL : IntermediateField F E\ninst✝ : Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)\nx : E\nh : Membership.mem L x\n⊢ IsSeparable F x","decl":"lemma IntermediateField.isSeparable_of_mem_isSeparable {L : IntermediateField F E}\n    [Algebra.IsSeparable F L] {x : E} (h : x ∈ L) : IsSeparable F x := by\n  simpa only [IsSeparable, minpoly_eq] using Algebra.IsSeparable.isSeparable F (K := L) ⟨x, h⟩\n\n"}
{"name":"IntermediateField.isSeparable_adjoin_simple_iff_isSeparable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Algebra.IsSeparable F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) (IsSeparable F x)","decl":"/-- `F⟮x⟯ / F` is a separable extension if and only if `x` is a separable element.\nAs a consequence, any rational function of `x` is also a separable element. -/\ntheorem IntermediateField.isSeparable_adjoin_simple_iff_isSeparable {x : E} :\n    Algebra.IsSeparable F F⟮x⟯ ↔ IsSeparable F x := by\n  refine ⟨fun _ ↦ ?_, fun hsep ↦ ?_⟩\n  · exact isSeparable_of_mem_isSeparable F E <| mem_adjoin_simple_self F x\n  · have h := IsSeparable.isIntegral hsep\n    haveI := adjoin.finiteDimensional h\n    rwa [← finSepDegree_eq_finrank_iff,\n      finSepDegree_adjoin_simple_eq_finrank_iff F E x h.isAlgebraic]\n\n"}
{"name":"IsSeparable.of_algebra_isSeparable_of_isSeparable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsSeparable F E\nx : K\nhsep : IsSeparable E x\n⊢ IsSeparable F x","decl":"variable {E K} in\n/-- If `K / E / F` is an extension tower such that `E / F` is separable,\n`x : K` is separable over `E`, then it's also separable over `F`. -/\ntheorem IsSeparable.of_algebra_isSeparable_of_isSeparable [Algebra E K] [IsScalarTower F E K]\n    [Algebra.IsSeparable F E] {x : K} (hsep : IsSeparable E x) : IsSeparable F x := by\n  set f := minpoly E x with hf\n  let E' : IntermediateField F E := adjoin F f.coeffs\n  haveI : FiniteDimensional F E' :=\n    finiteDimensional_adjoin fun x _ ↦ Algebra.IsSeparable.isIntegral F x\n  let g : E'[X] := f.toSubring E'.toSubring (subset_adjoin F _)\n  have h : g.map (algebraMap E' E) = f := f.map_toSubring E'.toSubring (subset_adjoin F _)\n  clear_value g\n  have hx : x ∈ restrictScalars F E'⟮x⟯ := mem_adjoin_simple_self _ x\n  have hzero : aeval x g = 0 := by\n    simpa only [← hf, ← h, aeval_map_algebraMap] using minpoly.aeval E x\n  have halg : IsIntegral E' x :=\n    isIntegral_trans (R := F) (A := E) _ (IsSeparable.isIntegral hsep) |>.tower_top\n  simp only [IsSeparable, ← hf, ← h, separable_map] at hsep\n  replace hsep := hsep.of_dvd <| minpoly.dvd E' x hzero\n  haveI : Algebra.IsSeparable F E' := Algebra.isSeparable_tower_bot_of_isSeparable F E' E\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable _ _).2 hsep\n  haveI := adjoin.finiteDimensional halg\n  haveI : FiniteDimensional F E'⟮x⟯ := FiniteDimensional.trans F E' E'⟮x⟯\n  have : Algebra.IsAlgebraic E' E'⟮x⟯ := Algebra.IsSeparable.isAlgebraic _ _\n  have := finSepDegree_mul_finSepDegree_of_isAlgebraic F E' E'⟮x⟯\n  rw [finSepDegree_eq_finrank_of_isSeparable F E',\n    finSepDegree_eq_finrank_of_isSeparable E' E'⟮x⟯,\n    Module.finrank_mul_finrank F E' E'⟮x⟯,\n    eq_comm, finSepDegree_eq_finrank_iff F E'⟮x⟯] at this\n  change Algebra.IsSeparable F (restrictScalars F E'⟮x⟯) at this\n  exact isSeparable_of_mem_isSeparable F K hx\n\n"}
{"name":"Algebra.IsSeparable.trans","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝⁸ : Field F\ninst✝⁷ : Field E\ninst✝⁶ : Algebra F E\nK : Type w\ninst✝⁵ : Field K\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\ninst✝¹ : Algebra.IsSeparable F E\ninst✝ : Algebra.IsSeparable E K\n⊢ Algebra.IsSeparable F K","decl":"/-- If `E / F` and `K / E` are both separable extensions, then `K / F` is also separable. -/\n@[stacks 09HB]\ntheorem Algebra.IsSeparable.trans [Algebra E K] [IsScalarTower F E K]\n    [Algebra.IsSeparable F E] [Algebra.IsSeparable E K] : Algebra.IsSeparable F K :=\n  ⟨fun x ↦ IsSeparable.of_algebra_isSeparable_of_isSeparable F\n    (Algebra.IsSeparable.isSeparable E x)⟩\n\n"}
{"name":"IntermediateField.isSeparable_adjoin_pair_of_isSeparable","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx y : E\nhx : IsSeparable F x\nhy : IsSeparable F y\n⊢ Algebra.IsSeparable F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Insert.insert x (Singleton.singleton y))) x_1)","decl":"/-- If `x` and `y` are both separable elements, then `F⟮x, y⟯ / F` is a separable extension.\nAs a consequence, any rational function of `x` and `y` is also a separable element. -/\ntheorem IntermediateField.isSeparable_adjoin_pair_of_isSeparable {x y : E}\n    (hx : IsSeparable F x) (hy : IsSeparable F y) :\n    Algebra.IsSeparable F F⟮x, y⟯ := by\n  rw [← adjoin_simple_adjoin_simple]\n  replace hy := IsSeparable.tower_top F⟮x⟯ hy\n  rw [← isSeparable_adjoin_simple_iff_isSeparable] at hx hy\n  exact Algebra.IsSeparable.trans F F⟮x⟯ F⟮x⟯⟮y⟯\n\n"}
{"name":"Field.isSeparable_algebraMap","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : F\n⊢ IsSeparable F ((algebraMap F E) x)","decl":"/-- Any element `x` of `F` is a separable element of `E / F` when embedded into `E`. -/\ntheorem isSeparable_algebraMap (x : F) : IsSeparable F ((algebraMap F E) x) := by\n  rw [IsSeparable, minpoly.algebraMap_eq (algebraMap F E).injective]\n  exact Algebra.IsSeparable.isSeparable F x\n\n"}
{"name":"Field.isSeparable_mul","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx y : E\nhx : IsSeparable F x\nhy : IsSeparable F y\n⊢ IsSeparable F (HMul.hMul x y)","decl":"/-- If `x` and `y` are both separable elements, then `x * y` is also a separable element. -/\ntheorem isSeparable_mul {x y : E} (hx : IsSeparable F x) (hy : IsSeparable F y) :\n    IsSeparable F (x * y) :=\n  haveI := isSeparable_adjoin_pair_of_isSeparable F E hx hy\n  isSeparable_of_mem_isSeparable F E <| F⟮x, y⟯.mul_mem (subset_adjoin F _ (.inl rfl))\n    (subset_adjoin F _ (.inr rfl))\n\n"}
{"name":"Field.isSeparable_add","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx y : E\nhx : IsSeparable F x\nhy : IsSeparable F y\n⊢ IsSeparable F (HAdd.hAdd x y)","decl":"/-- If `x` and `y` are both separable elements, then `x + y` is also a separable element. -/\ntheorem isSeparable_add {x y : E} (hx : IsSeparable F x) (hy : IsSeparable F y) :\n    IsSeparable F (x + y) :=\n  haveI := isSeparable_adjoin_pair_of_isSeparable F E hx hy\n  isSeparable_of_mem_isSeparable F E <| F⟮x, y⟯.add_mem (subset_adjoin F _ (.inl rfl))\n    (subset_adjoin F _ (.inr rfl))\n\n"}
{"name":"Field.isSeparable_neg","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\nhx : IsSeparable F x\n⊢ IsSeparable F (Neg.neg x)","decl":"/-- If `x` is a separable elements, then `-x` is also a separable element. -/\ntheorem isSeparable_neg {x : E} (hx : IsSeparable F x) :\n    IsSeparable F (-x) :=\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable F E).2 hx\n  isSeparable_of_mem_isSeparable F E <| F⟮x⟯.neg_mem <| mem_adjoin_simple_self F x\n\n"}
{"name":"Field.isSeparable_sub","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx y : E\nhx : IsSeparable F x\nhy : IsSeparable F y\n⊢ IsSeparable F (HSub.hSub x y)","decl":"/-- If `x` and `y` are both separable elements, then `x - y` is also a separable element. -/\ntheorem isSeparable_sub {x y : E} (hx : IsSeparable F x) (hy : IsSeparable F y) :\n    IsSeparable F (x - y) :=\n  haveI := isSeparable_adjoin_pair_of_isSeparable F E hx hy\n  isSeparable_of_mem_isSeparable F E <| F⟮x, y⟯.sub_mem (subset_adjoin F _ (.inl rfl))\n    (subset_adjoin F _ (.inr rfl))\n\n"}
{"name":"Field.isSeparable_inv","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\nhx : IsSeparable F x\n⊢ IsSeparable F (Inv.inv x)","decl":"/-- If `x` is a separable element, then `x⁻¹` is also a separable element. -/\ntheorem isSeparable_inv {x : E} (hx : IsSeparable F x) : IsSeparable F x⁻¹ :=\n  haveI := (isSeparable_adjoin_simple_iff_isSeparable F E).2 hx\n  isSeparable_of_mem_isSeparable F E <| F⟮x⟯.inv_mem <| mem_adjoin_simple_self F x\n\n"}
{"name":"perfectField_iff_splits_of_natSepDegree_eq_one","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"F : Type u_1\ninst✝ : Field F\n⊢ Iff (PerfectField F) (∀ (f : Polynomial F), Eq f.natSepDegree 1 → Polynomial.Splits (RingHom.id F) f)","decl":"/-- A field is a perfect field (which means that any irreducible polynomial is separable)\nif and only if every separable degree one polynomial splits. -/\ntheorem perfectField_iff_splits_of_natSepDegree_eq_one (F : Type*) [Field F] :\n    PerfectField F ↔ ∀ f : F[X], f.natSepDegree = 1 → f.Splits (RingHom.id F) := by\n  refine ⟨fun ⟨h⟩ f hf ↦ or_iff_not_imp_left.2 fun hn g hg hd ↦ ?_, fun h ↦ ?_⟩\n  · rw [map_id] at hn hd\n    have := natSepDegree_le_of_dvd g f hd hn\n    rw [hf, (h hg).natSepDegree_eq_natDegree] at this\n    exact (degree_eq_iff_natDegree_eq_of_pos one_pos).2 <| this.antisymm <|\n      natDegree_pos_iff_degree_pos.2 (degree_pos_of_irreducible hg)\n  obtain ⟨p, _⟩ := ExpChar.exists F\n  haveI := PerfectRing.ofSurjective F p fun x ↦ by\n    obtain ⟨y, hy⟩ := exists_root_of_splits _\n      (h _ (pow_one p ▸ natSepDegree_X_pow_char_pow_sub_C p 1 x))\n      ((degree_X_pow_sub_C (expChar_pos F p) x).symm ▸ Nat.cast_pos.2 (expChar_pos F p)).ne'\n    exact ⟨y, by rwa [← eval, eval_sub, eval_pow, eval_X, eval_C, sub_eq_zero] at hy⟩\n  exact PerfectRing.toPerfectField F p\n\n"}
{"name":"PerfectField.splits_of_natSepDegree_eq_one","module":"Mathlib.FieldTheory.SeparableDegree","initialProofState":"E : Type v\ninst✝² : Field E\nK : Type w\ninst✝¹ : Field K\ninst✝ : PerfectField K\nf : Polynomial E\ni : RingHom E K\nhf : Eq f.natSepDegree 1\n⊢ Polynomial.Splits i f","decl":"variable {E K} in\ntheorem PerfectField.splits_of_natSepDegree_eq_one [PerfectField K] {f : E[X]}\n    (i : E →+* K) (hf : f.natSepDegree = 1) : f.Splits i :=\n  (splits_id_iff_splits _).mp <| (perfectField_iff_splits_of_natSepDegree_eq_one K).mp ‹_› _\n    (natSepDegree_map K f i ▸ hf)\n"}
