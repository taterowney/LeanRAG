{"name":"IsLocalExtrOn.range_ne_top_of_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.LagrangeMultipliers","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace F\nf : E â†’ F\nÏ† : E â†’ Real\nxâ‚€ : E\nf' : ContinuousLinearMap (RingHom.id Real) E F\nÏ†' : ContinuousLinearMap (RingHom.id Real) E Real\nhextr : IsLocalExtrOn Ï† (setOf fun x => Eq (f x) (f xâ‚€)) xâ‚€\nhf' : HasStrictFDerivAt f f' xâ‚€\nhÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€\nâŠ¢ Ne (LinearMap.range (f'.prod Ï†')) Top.top","decl":"/-- Lagrange multipliers theorem: if `Ï† : E â†’ â„` has a local extremum on the set `{x | f x = f xâ‚€}`\nat `xâ‚€`, both `f : E â†’ F` and `Ï†` are strictly differentiable at `xâ‚€`, and the codomain of `f` is\na complete space, then the linear map `x â†¦ (f' x, Ï†' x)` is not surjective. -/\ntheorem IsLocalExtrOn.range_ne_top_of_hasStrictFDerivAt\n    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)\n    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : LinearMap.range (f'.prod Ï†') â‰  âŠ¤ := by\n  intro htop\n  set fÏ† := fun x => (f x, Ï† x)\n  have A : map Ï† (ğ“[f â»Â¹' {f xâ‚€}] xâ‚€) = ğ“ (Ï† xâ‚€) := by\n    change map (Prod.snd âˆ˜ fÏ†) (ğ“[fÏ† â»Â¹' {p | p.1 = f xâ‚€}] xâ‚€) = ğ“ (Ï† xâ‚€)\n    rw [â† map_map, nhdsWithin, map_inf_principal_preimage, (hf'.prod hÏ†').map_nhds_eq_of_surj htop]\n    exact map_snd_nhdsWithin _\n  exact hextr.not_nhds_le_map A.ge\n\n"}
{"name":"IsLocalExtrOn.exists_linear_map_of_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.LagrangeMultipliers","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace F\nf : E â†’ F\nÏ† : E â†’ Real\nxâ‚€ : E\nf' : ContinuousLinearMap (RingHom.id Real) E F\nÏ†' : ContinuousLinearMap (RingHom.id Real) E Real\nhextr : IsLocalExtrOn Ï† (setOf fun x => Eq (f x) (f xâ‚€)) xâ‚€\nhf' : HasStrictFDerivAt f f' xâ‚€\nhÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€\nâŠ¢ Exists fun Î› => Exists fun Î›â‚€ => And (Ne { fst := Î›, snd := Î›â‚€ } 0) (âˆ€ (x : E), Eq (HAdd.hAdd (Î› (f' x)) (HSMul.hSMul Î›â‚€ (Ï†' x))) 0)","decl":"/-- Lagrange multipliers theorem: if `Ï† : E â†’ â„` has a local extremum on the set `{x | f x = f xâ‚€}`\nat `xâ‚€`, both `f : E â†’ F` and `Ï†` are strictly differentiable at `xâ‚€`, and the codomain of `f` is\na complete space, then there exist `Î› : dual â„ F` and `Î›â‚€ : â„` such that `(Î›, Î›â‚€) â‰  0` and\n`Î› (f' x) + Î›â‚€ â€¢ Ï†' x = 0` for all `x`. -/\ntheorem IsLocalExtrOn.exists_linear_map_of_hasStrictFDerivAt\n    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)\n    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) :\n    âˆƒ (Î› : Module.Dual â„ F) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ âˆ€ x, Î› (f' x) + Î›â‚€ â€¢ Ï†' x = 0 := by\n  rcases Submodule.exists_le_ker_of_lt_top _\n      (lt_top_iff_ne_top.2 <| hextr.range_ne_top_of_hasStrictFDerivAt hf' hÏ†') with\n    âŸ¨Î›', h0, hÎ›'âŸ©\n  set e : ((F â†’â‚—[â„] â„) Ã— â„) â‰ƒâ‚—[â„] F Ã— â„ â†’â‚—[â„] â„ :=\n    ((LinearEquiv.refl â„ (F â†’â‚—[â„] â„)).prod (LinearMap.ringLmapEquivSelf â„ â„ â„).symm).trans\n      (LinearMap.coprodEquiv â„)\n  rcases e.surjective Î›' with âŸ¨âŸ¨Î›, Î›â‚€âŸ©, rflâŸ©\n  refine âŸ¨Î›, Î›â‚€, e.map_ne_zero_iff.1 h0, fun x => ?_âŸ©\n  convert LinearMap.congr_fun (LinearMap.range_le_ker_iff.1 hÎ›') x using 1\n  -- squeezed `simp [mul_comm]` to speed up elaboration\n  simp only [e, smul_eq_mul, LinearEquiv.trans_apply, LinearEquiv.prod_apply,\n    LinearEquiv.refl_apply, LinearMap.ringLmapEquivSelf_symm_apply, LinearMap.coprodEquiv_apply,\n    ContinuousLinearMap.coe_prod, LinearMap.coprod_comp_prod, LinearMap.add_apply,\n    LinearMap.coe_comp, ContinuousLinearMap.coe_coe, Function.comp_apply, LinearMap.coe_smulRight,\n    LinearMap.one_apply, mul_comm]\n\n"}
{"name":"IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d","module":"Mathlib.Analysis.Calculus.LagrangeMultipliers","initialProofState":"E : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nÏ† : E â†’ Real\nxâ‚€ : E\nÏ†' : ContinuousLinearMap (RingHom.id Real) E Real\nf : E â†’ Real\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nhextr : IsLocalExtrOn Ï† (setOf fun x => Eq (f x) (f xâ‚€)) xâ‚€\nhf' : HasStrictFDerivAt f f' xâ‚€\nhÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€\nâŠ¢ Exists fun a => Exists fun b => And (Ne { fst := a, snd := b } 0) (Eq (HAdd.hAdd (HSMul.hSMul a f') (HSMul.hSMul b Ï†')) 0)","decl":"/-- Lagrange multipliers theorem: if `Ï† : E â†’ â„` has a local extremum on the set `{x | f x = f xâ‚€}`\nat `xâ‚€`, and both `f : E â†’ â„` and `Ï†` are strictly differentiable at `xâ‚€`, then there exist\n`a b : â„` such that `(a, b) â‰  0` and `a â€¢ f' + b â€¢ Ï†' = 0`. -/\ntheorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt_1d {f : E â†’ â„} {f' : E â†’L[â„] â„}\n    (hextr : IsLocalExtrOn Ï† {x | f x = f xâ‚€} xâ‚€) (hf' : HasStrictFDerivAt f f' xâ‚€)\n    (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) : âˆƒ a b : â„, (a, b) â‰  0 âˆ§ a â€¢ f' + b â€¢ Ï†' = 0 := by\n  obtain âŸ¨Î›, Î›â‚€, hÎ›, hfÎ›âŸ© := hextr.exists_linear_map_of_hasStrictFDerivAt hf' hÏ†'\n  refine âŸ¨Î› 1, Î›â‚€, ?_, ?_âŸ©\n  Â· contrapose! hÎ›\n    simp only [Prod.mk_eq_zero] at hÎ› âŠ¢\n    refine âŸ¨LinearMap.ext fun x => ?_, hÎ›.2âŸ©\n    simpa [hÎ›.1] using Î›.map_smul x 1\n  Â· ext x\n    have Hâ‚ : Î› (f' x) = f' x * Î› 1 := by\n      simpa only [mul_one, Algebra.id.smul_eq_mul] using Î›.map_smul (f' x) 1\n    have Hâ‚‚ : f' x * Î› 1 + Î›â‚€ * Ï†' x = 0 := by simpa only [Algebra.id.smul_eq_mul, Hâ‚] using hfÎ› x\n    simpa [mul_comm] using Hâ‚‚\n\n"}
{"name":"IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.LagrangeMultipliers","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nÏ† : E â†’ Real\nxâ‚€ : E\nÏ†' : ContinuousLinearMap (RingHom.id Real) E Real\nÎ¹ : Type u_3\ninstâœ : Fintype Î¹\nf : Î¹ â†’ E â†’ Real\nf' : Î¹ â†’ ContinuousLinearMap (RingHom.id Real) E Real\nhextr : IsLocalExtrOn Ï† (setOf fun x => âˆ€ (i : Î¹), Eq (f i x) (f i xâ‚€)) xâ‚€\nhf' : âˆ€ (i : Î¹), HasStrictFDerivAt (f i) (f' i) xâ‚€\nhÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€\nâŠ¢ Exists fun Î› => Exists fun Î›â‚€ => And (Ne { fst := Î›, snd := Î›â‚€ } 0) (Eq (HAdd.hAdd (Finset.univ.sum fun i => HSMul.hSMul (Î› i) (f' i)) (HSMul.hSMul Î›â‚€ Ï†')) 0)","decl":"/-- Lagrange multipliers theorem, 1d version. Let `f : Î¹ â†’ E â†’ â„` be a finite family of functions.\nSuppose that `Ï† : E â†’ â„` has a local extremum on the set `{x | âˆ€ i, f i x = f i xâ‚€}` at `xâ‚€`.\nSuppose that all functions `f i` as well as `Ï†` are strictly differentiable at `xâ‚€`.\nThen the derivatives `f' i : E â†’ L[â„] â„` and `Ï†' : E â†’L[â„] â„` are linearly dependent:\nthere exist `Î› : Î¹ â†’ â„` and `Î›â‚€ : â„`, `(Î›, Î›â‚€) â‰  0`, such that `âˆ‘ i, Î› i â€¢ f' i + Î›â‚€ â€¢ Ï†' = 0`.\n\nSee also `IsLocalExtrOn.linear_dependent_of_hasStrictFDerivAt` for a version that\nstates `Â¬LinearIndependent â„ _` instead of existence of `Î›` and `Î›â‚€`. -/\ntheorem IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt {Î¹ : Type*} [Fintype Î¹]\n    {f : Î¹ â†’ E â†’ â„} {f' : Î¹ â†’ E â†’L[â„] â„} (hextr : IsLocalExtrOn Ï† {x | âˆ€ i, f i x = f i xâ‚€} xâ‚€)\n    (hf' : âˆ€ i, HasStrictFDerivAt (f i) (f' i) xâ‚€) (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) :\n    âˆƒ (Î› : Î¹ â†’ â„) (Î›â‚€ : â„), (Î›, Î›â‚€) â‰  0 âˆ§ (âˆ‘ i, Î› i â€¢ f' i) + Î›â‚€ â€¢ Ï†' = 0 := by\n  letI := Classical.decEq Î¹\n  replace hextr : IsLocalExtrOn Ï† {x | (fun i => f i x) = fun i => f i xâ‚€} xâ‚€ := by\n    simpa only [funext_iff] using hextr\n  rcases hextr.exists_linear_map_of_hasStrictFDerivAt (hasStrictFDerivAt_pi.2 fun i => hf' i)\n      hÏ†' with\n    âŸ¨Î›, Î›â‚€, h0, hsumâŸ©\n  rcases (LinearEquiv.piRing â„ â„ Î¹ â„).symm.surjective Î› with âŸ¨Î›, rflâŸ©\n  refine âŸ¨Î›, Î›â‚€, ?_, ?_âŸ©\n  Â· simpa only [Ne, Prod.ext_iff, LinearEquiv.map_eq_zero_iff, Prod.fst_zero] using h0\n  Â· ext x; simpa [mul_comm] using hsum x\n\n"}
{"name":"IsLocalExtrOn.linear_dependent_of_hasStrictFDerivAt","module":"Mathlib.Analysis.Calculus.LagrangeMultipliers","initialProofState":"E : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nÏ† : E â†’ Real\nxâ‚€ : E\nÏ†' : ContinuousLinearMap (RingHom.id Real) E Real\nÎ¹ : Type u_3\ninstâœ : Finite Î¹\nf : Î¹ â†’ E â†’ Real\nf' : Î¹ â†’ ContinuousLinearMap (RingHom.id Real) E Real\nhextr : IsLocalExtrOn Ï† (setOf fun x => âˆ€ (i : Î¹), Eq (f i x) (f i xâ‚€)) xâ‚€\nhf' : âˆ€ (i : Î¹), HasStrictFDerivAt (f i) (f' i) xâ‚€\nhÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€\nâŠ¢ Not (LinearIndependent Real (Option.elim' Ï†' f'))","decl":"/-- Lagrange multipliers theorem. Let `f : Î¹ â†’ E â†’ â„` be a finite family of functions.\nSuppose that `Ï† : E â†’ â„` has a local extremum on the set `{x | âˆ€ i, f i x = f i xâ‚€}` at `xâ‚€`.\nSuppose that all functions `f i` as well as `Ï†` are strictly differentiable at `xâ‚€`.\nThen the derivatives `f' i : E â†’ L[â„] â„` and `Ï†' : E â†’L[â„] â„` are linearly dependent.\n\nSee also `IsLocalExtrOn.exists_multipliers_of_hasStrictFDerivAt` for a version that\nthat states existence of Lagrange multipliers `Î›` and `Î›â‚€` instead of using\n`Â¬LinearIndependent â„ _` -/\ntheorem IsLocalExtrOn.linear_dependent_of_hasStrictFDerivAt {Î¹ : Type*} [Finite Î¹] {f : Î¹ â†’ E â†’ â„}\n    {f' : Î¹ â†’ E â†’L[â„] â„} (hextr : IsLocalExtrOn Ï† {x | âˆ€ i, f i x = f i xâ‚€} xâ‚€)\n    (hf' : âˆ€ i, HasStrictFDerivAt (f i) (f' i) xâ‚€) (hÏ†' : HasStrictFDerivAt Ï† Ï†' xâ‚€) :\n    Â¬LinearIndependent â„ (Option.elim' Ï†' f' : Option Î¹ â†’ E â†’L[â„] â„) := by\n  cases nonempty_fintype Î¹\n  rw [Fintype.linearIndependent_iff]; push_neg\n  rcases hextr.exists_multipliers_of_hasStrictFDerivAt hf' hÏ†' with âŸ¨Î›, Î›â‚€, hÎ›, hÎ›fâŸ©\n  refine âŸ¨Option.elim' Î›â‚€ Î›, ?_, ?_âŸ©\n  Â· simpa [add_comm] using hÎ›f\n  Â· simpa only [funext_iff, not_and_or, or_comm, Option.exists, Prod.mk_eq_zero, Ne,\n      not_forall] using hÎ›\n"}
