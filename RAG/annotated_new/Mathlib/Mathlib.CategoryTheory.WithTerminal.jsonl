{"name":"CategoryTheory.WithTerminal.of.injEq","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na‚úù¬π a‚úù : C\n‚ä¢ Eq (Eq (CategoryTheory.WithTerminal.of a‚úù¬π) (CategoryTheory.WithTerminal.of a‚úù)) (Eq a‚úù¬π a‚úù)","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C ‚Üí WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.of.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : SizeOf C\na‚úù : C\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.WithTerminal.of a‚úù)) (HAdd.hAdd 1 (SizeOf.sizeOf a‚úù))","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C ‚Üí WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.of.inj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na‚úù¬π a‚úù : C\nx‚úù : Eq (CategoryTheory.WithTerminal.of a‚úù¬π) (CategoryTheory.WithTerminal.of a‚úù)\n‚ä¢ Eq a‚úù¬π a‚úù","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C ‚Üí WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.star.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : SizeOf C\n‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.WithTerminal.star) 1","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C ‚Üí WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.star.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : SizeOf C\n‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.WithInitial.star) 1","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C ‚Üí WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.inj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na‚úù¬π a‚úù : C\nx‚úù : Eq (CategoryTheory.WithInitial.of a‚úù¬π) (CategoryTheory.WithInitial.of a‚úù)\n‚ä¢ Eq a‚úù¬π a‚úù","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C ‚Üí WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : SizeOf C\na‚úù : C\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.WithInitial.of a‚úù)) (HAdd.hAdd 1 (SizeOf.sizeOf a‚úù))","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C ‚Üí WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.injEq","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na‚úù¬π a‚úù : C\n‚ä¢ Eq (Eq (CategoryTheory.WithInitial.of a‚úù¬π) (CategoryTheory.WithInitial.of a‚úù)) (Eq a‚úù¬π a‚úù)","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C ‚Üí WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.down_id","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.WithTerminal.down (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.of X))) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] lemma down_id {X : C} : down (ùüô (of X)) = ùüô X := rfl\n"}
{"name":"CategoryTheory.WithTerminal.down_comp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom (CategoryTheory.WithTerminal.of X) (CategoryTheory.WithTerminal.of Y)\ng : Quiver.Hom (CategoryTheory.WithTerminal.of Y) (CategoryTheory.WithTerminal.of Z)\n‚ä¢ Eq (CategoryTheory.WithTerminal.down (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithTerminal.down f) (CategoryTheory.WithTerminal.down g))","decl":"@[simp] lemma down_comp {X Y Z : C} (f : of X ‚ü∂ of Y) (g : of Y ‚ü∂ of Z) :\n    down (f ‚â´ g) = down f ‚â´ down g :=\n  rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.false_of_from_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom CategoryTheory.WithTerminal.star (CategoryTheory.WithTerminal.of X)\n‚ä¢ False","decl":"@[aesop safe destruct (rule_sets := [CategoryTheory])]\nlemma false_of_from_star {X : C} (f : star ‚ü∂ of X) : False := (f : PEmpty).elim\n\n"}
{"name":"CategoryTheory.WithTerminal.instFullIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.WithTerminal.incl.Full","decl":"instance : (incl : C ‚•§ _).Full where\n  map_surjective f := ‚ü®f, rfl‚ü©\n\n"}
{"name":"CategoryTheory.WithTerminal.instFaithfulIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.WithTerminal.incl.Faithful","decl":"instance : (incl : C ‚•§ _).Faithful where\n\n"}
{"name":"CategoryTheory.WithTerminal.map_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithTerminal.map F).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) X) ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun a x => PUnit.unit) fun x => PUnit.unit)","decl":"/-- Map `WithTerminal` with respect to a functor `F : C ‚•§ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ‚•§ D) : WithTerminal C ‚•§ WithTerminal D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of _, star, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithTerminal.map_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.map F).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star)","decl":"/-- Map `WithTerminal` with respect to a functor `F : C ‚•§ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ‚•§ D) : WithTerminal C ‚•§ WithTerminal D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of _, star, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithTerminal.mapId_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.mapId C).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal C) X (fun x => CategoryTheory.WithTerminal.of x) fun _ => CategoryTheory.WithTerminal.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).inv","decl":"/-- A natural isomorphism between the functor `map (ùü≠ C)` and `ùü≠ (WithTerminal C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (ùü≠ C) ‚âÖ ùü≠ (WithTerminal C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapId_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.mapId C).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal C) X (fun x => CategoryTheory.WithTerminal.of x) fun _ => CategoryTheory.WithTerminal.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).hom","decl":"/-- A natural isomorphism between the functor `map (ùü≠ C)` and `ùü≠ (WithTerminal C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (ùü≠ C) ‚âÖ ùü≠ (WithTerminal C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapComp_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.mapComp F G).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) X (fun x => CategoryTheory.WithTerminal.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithTerminal.star) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) (fun x => CategoryTheory.WithTerminal.of (G.obj x)) fun _ => CategoryTheory.WithTerminal.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).hom","decl":"/-- A natural isomorphism between the functor `map (F ‚ãô G) ` and `map F ‚ãô map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ‚•§ D) (G : D ‚•§ E) :\n    map (F ‚ãô G) ‚âÖ map F ‚ãô map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapComp_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.mapComp F G).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) X (fun x => CategoryTheory.WithTerminal.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithTerminal.star) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) (fun x => CategoryTheory.WithTerminal.of (G.obj x)) fun _ => CategoryTheory.WithTerminal.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).inv","decl":"/-- A natural isomorphism between the functor `map (F ‚ãô G) ` and `map F ‚ãô map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ‚•§ D) (G : D ‚•§ E) :\n    map (F ‚ãô G) ‚âÖ map F ‚ãô map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.map‚ÇÇ_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom F G\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.map‚ÇÇ Œ∑).app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => Quiver.Hom ((CategoryTheory.WithTerminal.map F).obj X) ((CategoryTheory.WithTerminal.map G).obj X)) X (fun x => Œ∑.app x) fun _ => CategoryTheory.CategoryStruct.id CategoryTheory.WithTerminal.star)","decl":"/-- From a natural transformation of functors `C ‚•§ D`, the induced natural transformation\nof functors `WithTerminal C ‚•§ WithTerminal D`. -/\n@[simps]\ndef map‚ÇÇ {D : Type*} [Category D] {F G : C ‚•§ D} (Œ∑ : F ‚ü∂ G) : map F ‚ü∂ map G where\n  app := fun X => match X with\n    | of x => Œ∑.app x\n    | star => ùüô star\n  naturality := by\n    intro X Y f\n    match X, Y, f with\n    | of x, of y, f => exact Œ∑.naturality f\n    | of x, star, _ => rfl\n    | star, star, _ => rfl\n\n-- Note: ...\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.obj C) (CategoryTheory.Cat.of (CategoryTheory.WithTerminal ‚ÜëC))","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"X‚úù Y‚úù : CategoryTheory.Cat\nF : CategoryTheory.Functor ‚ÜëX‚úù ‚ÜëY‚úù\n‚ä¢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.map F) (CategoryTheory.WithTerminal.map F)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a‚úù b‚úù : CategoryTheory.Cat\nf‚úù g‚úù : Quiver.Hom a‚úù b‚úù\nŒ∑ : Quiver.Hom f‚úù g‚úù\n‚ä¢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.map‚ÇÇ Œ∑) (CategoryTheory.WithTerminal.map‚ÇÇ Œ∑)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_mapId","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.WithTerminal.pseudofunctor.mapId C) (CategoryTheory.WithTerminal.mapId ‚ÜëC)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_mapComp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a‚úù b‚úù c‚úù : CategoryTheory.Cat\nF : CategoryTheory.Functor ‚Üëa‚úù ‚Üëb‚úù\nG : CategoryTheory.Functor ‚Üëb‚úù ‚Üëc‚úù\n‚ä¢ Eq (CategoryTheory.WithTerminal.pseudofunctor.mapComp F G) (CategoryTheory.WithTerminal.mapComp F G)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_toPrelaxFunctor","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"‚ä¢ Eq CategoryTheory.WithTerminal.pseudofunctor.toPrelaxFunctor CategoryTheory.WithTerminal.prelaxfunctor","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithTerminal.lift F M hM).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) X) ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun x x_1 => M x) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- Lift a functor `F : C ‚•§ D` to `WithTerminal C ‚•§ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : WithTerminal C ‚•§ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of x, star, _ => M x\n    | star, star, _ => ùüô Z\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.lift F M hM).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- Lift a functor `F : C ‚•§ D` to `WithTerminal C ‚•§ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : WithTerminal C ‚•§ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of x, star, _ => M x\n    | star, star, _ => ùüô Z\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLift_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.inclLift F M hM).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (F.obj x‚úù))","decl":"/-- The isomorphism between `incl ‚ãô lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : incl ‚ãô lift F M hM ‚âÖ F where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLift_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.inclLift F M hM).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.id.match_1 (fun X => D) (CategoryTheory.WithTerminal.incl.obj x‚úù) (fun x => F.obj x) fun _ => Z))","decl":"/-- The isomorphism between `incl ‚ãô lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : incl ‚ãô lift F M hM ‚âÖ F where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.WithTerminal.liftStar_inv","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\n‚ä¢ Eq (CategoryTheory.WithTerminal.liftStar F M hM).inv (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithTerminal.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : (lift F M hM).obj star ‚âÖ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.liftStar_hom","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\n‚ä¢ Eq (CategoryTheory.WithTerminal.liftStar F M hM).hom (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithTerminal.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) : (lift F M hM).obj star ‚âÖ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_map_liftStar","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom (F.obj x) Z\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.WithTerminal.lift F M hM).map (CategoryTheory.WithTerminal.starTerminal.from (CategoryTheory.WithTerminal.incl.obj x))) (CategoryTheory.WithTerminal.liftStar F M hM).hom) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.WithTerminal.inclLift F M hM).hom.app x) (M x))","decl":"theorem lift_map_liftStar {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, F.obj x ‚ü∂ Z)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), F.map f ‚â´ M y = M x) (x : C) :\n    (lift F M hM).map (starTerminal.from (incl.obj x)) ‚â´ (liftStar F M hM).hom =\n      (inclLift F M hM).hom.app x ‚â´ M x := by\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminal_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.liftToTerminal F hZ).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- A variant of `lift` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminal {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z) :\n    WithTerminal C ‚•§ D :=\n  lift F (fun _x => hZ.from _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminal_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithTerminal.liftToTerminal F hZ).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) Y (fun x => F.obj x) fun _ => Z)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun x x_1 => hZ.from (F.obj x)) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- A variant of `lift` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminal {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z) :\n    WithTerminal C ‚•§ D :=\n  lift F (fun _x => hZ.from _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLiftToTerminal_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.inclLiftToTerminal F hZ).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.id.match_1 (fun X => D) (CategoryTheory.WithTerminal.incl.obj x‚úù) (fun x => F.obj x) fun _ => Z))","decl":"/-- A variant of `incl_lift` with `Z` a terminal object. -/\n@[simps!]\ndef inclLiftToTerminal {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z) :\n    incl ‚ãô liftToTerminal F hZ ‚âÖ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLiftToTerminal_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.inclLiftToTerminal F hZ).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (F.obj x‚úù))","decl":"/-- A variant of `incl_lift` with `Z` a terminal object. -/\n@[simps!]\ndef inclLiftToTerminal {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z) :\n    incl ‚ãô liftToTerminal F hZ ‚âÖ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminalUnique_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nG : CategoryTheory.Functor (CategoryTheory.WithTerminal C) D\nh : CategoryTheory.Iso (CategoryTheory.WithTerminal.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithTerminal.star) Z\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.liftToTerminalUnique F hZ G h hG).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).inv","decl":"/-- A variant of `lift_unique` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminalUnique {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z)\n    (G : WithTerminal C ‚•§ D) (h : incl ‚ãô G ‚âÖ F) (hG : G.obj star ‚âÖ Z) : G ‚âÖ liftToTerminal F hZ :=\n  liftUnique F (fun _z => hZ.from _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x =>\n    hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminalUnique_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nG : CategoryTheory.Functor (CategoryTheory.WithTerminal C) D\nh : CategoryTheory.Iso (CategoryTheory.WithTerminal.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithTerminal.star) Z\nX : CategoryTheory.WithTerminal C\n‚ä¢ Eq ((CategoryTheory.WithTerminal.liftToTerminalUnique F hZ G h hG).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).hom","decl":"/-- A variant of `lift_unique` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminalUnique {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsTerminal Z)\n    (G : WithTerminal C ‚•§ D) (h : incl ‚ãô G ‚âÖ F) (hG : G.obj star ‚âÖ Z) : G ‚âÖ liftToTerminal F hZ :=\n  liftUnique F (fun _z => hZ.from _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x =>\n    hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.isIso_of_from_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.WithTerminal C\nf : Quiver.Hom CategoryTheory.WithTerminal.star X\n‚ä¢ CategoryTheory.IsIso f","decl":"instance isIso_of_from_star {X : WithTerminal C} (f : star ‚ü∂ X) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => ‚ü®f, rfl, rfl‚ü©\n\n"}
{"name":"CategoryTheory.WithInitial.down_id","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.WithInitial.down (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.of X))) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] lemma down_id {X : C} : down (ùüô (of X)) = ùüô X := rfl\n"}
{"name":"CategoryTheory.WithInitial.down_comp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom (CategoryTheory.WithInitial.of X) (CategoryTheory.WithInitial.of Y)\ng : Quiver.Hom (CategoryTheory.WithInitial.of Y) (CategoryTheory.WithInitial.of Z)\n‚ä¢ Eq (CategoryTheory.WithInitial.down (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithInitial.down f) (CategoryTheory.WithInitial.down g))","decl":"@[simp] lemma down_comp {X Y Z : C} (f : of X ‚ü∂ of Y) (g : of Y ‚ü∂ of Z) :\n    down (f ‚â´ g) = down f ‚â´ down g :=\n  rfl\n\n"}
{"name":"CategoryTheory.WithInitial.false_of_to_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom (CategoryTheory.WithInitial.of X) CategoryTheory.WithInitial.star\n‚ä¢ False","decl":"@[aesop safe destruct (rule_sets := [CategoryTheory])]\nlemma false_of_to_star {X : C} (f : of X ‚ü∂ star) : False := (f : PEmpty).elim\n\n"}
{"name":"CategoryTheory.WithInitial.instFullIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.WithInitial.incl.Full","decl":"instance : (incl : C ‚•§ _).Full where\n  map_surjective f := ‚ü®f, rfl‚ü©\n\n"}
{"name":"CategoryTheory.WithInitial.instFaithfulIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.WithInitial.incl.Faithful","decl":"instance : (incl : C ‚•§ _).Faithful where\n\n"}
{"name":"CategoryTheory.WithInitial.map_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithInitial.map F).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) X) ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => PUnit.unit) fun x => PUnit.unit)","decl":"/-- Map `WithInitial` with respect to a functor `F : C ‚•§ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ‚•§ D) : WithInitial C ‚•§ WithInitial D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithInitial.map_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.map F).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star)","decl":"/-- Map `WithInitial` with respect to a functor `F : C ‚•§ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ‚•§ D) : WithInitial C ‚•§ WithInitial D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithInitial.mapId_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.mapId C).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial C) X (fun x => CategoryTheory.WithInitial.of x) fun _ => CategoryTheory.WithInitial.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).hom","decl":"/-- A natural isomorphism between the functor `map (ùü≠ C)` and `ùü≠ (WithInitial C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (ùü≠ C) ‚âÖ ùü≠ (WithInitial C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapId_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.mapId C).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial C) X (fun x => CategoryTheory.WithInitial.of x) fun _ => CategoryTheory.WithInitial.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).inv","decl":"/-- A natural isomorphism between the functor `map (ùü≠ C)` and `ùü≠ (WithInitial C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (ùü≠ C) ‚âÖ ùü≠ (WithInitial C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapComp_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.mapComp F G).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) X (fun x => CategoryTheory.WithInitial.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithInitial.star) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) (fun x => CategoryTheory.WithInitial.of (G.obj x)) fun _ => CategoryTheory.WithInitial.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).hom","decl":"/-- A natural isomorphism between the functor `map (F ‚ãô G) ` and `map F ‚ãô map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ‚•§ D) (G : D ‚•§ E) :\n    map (F ‚ãô G) ‚âÖ map F ‚ãô map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapComp_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.mapComp F G).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) X (fun x => CategoryTheory.WithInitial.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithInitial.star) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) (fun x => CategoryTheory.WithInitial.of (G.obj x)) fun _ => CategoryTheory.WithInitial.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).inv","decl":"/-- A natural isomorphism between the functor `map (F ‚ãô G) ` and `map F ‚ãô map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ‚•§ D) (G : D ‚•§ E) :\n    map (F ‚ãô G) ‚âÖ map F ‚ãô map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.map‚ÇÇ_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom F G\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.map‚ÇÇ Œ∑).app X) (CategoryTheory.WithInitial.id.match_1 (fun X => Quiver.Hom ((CategoryTheory.WithInitial.map F).obj X) ((CategoryTheory.WithInitial.map G).obj X)) X (fun x => Œ∑.app x) fun _ => CategoryTheory.CategoryStruct.id CategoryTheory.WithInitial.star)","decl":"/-- From a natural transformation of functors `C ‚•§ D`, the induced natural transformation\nof functors `WithInitial C ‚•§ WithInitial D`. -/\n@[simps]\ndef map‚ÇÇ {D : Type*} [Category D] {F G : C ‚•§ D} (Œ∑ : F ‚ü∂ G) : map F ‚ü∂ map G where\n  app := fun X => match X with\n    | of x => Œ∑.app x\n    | star => ùüô star\n  naturality := by\n    intro X Y f\n    match X, Y, f with\n    | of x, of y, f => exact Œ∑.naturality f\n    | star, of x, _ => rfl\n    | star, star, _ => rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"X‚úù Y‚úù : CategoryTheory.Cat\nF : CategoryTheory.Functor ‚ÜëX‚úù ‚ÜëY‚úù\n‚ä¢ Eq (CategoryTheory.WithInitial.prelaxfunctor.map F) (CategoryTheory.WithInitial.map F)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.WithInitial.prelaxfunctor.obj C) (CategoryTheory.Cat.of (CategoryTheory.WithInitial ‚ÜëC))","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a‚úù b‚úù : CategoryTheory.Cat\nf‚úù g‚úù : Quiver.Hom a‚úù b‚úù\nŒ∑ : Quiver.Hom f‚úù g‚úù\n‚ä¢ Eq (CategoryTheory.WithInitial.prelaxfunctor.map‚ÇÇ Œ∑) (CategoryTheory.WithInitial.map‚ÇÇ Œ∑)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map‚ÇÇ := map‚ÇÇ\n  map‚ÇÇ_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map‚ÇÇ_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_toPrelaxFunctor","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"‚ä¢ Eq CategoryTheory.WithInitial.pseudofunctor.toPrelaxFunctor CategoryTheory.WithInitial.prelaxfunctor","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id, Cat.id_map]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_mapId","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n‚ä¢ Eq (CategoryTheory.WithInitial.pseudofunctor.mapId C) (CategoryTheory.WithInitial.mapId ‚ÜëC)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id, Cat.id_map]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_mapComp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a‚úù b‚úù c‚úù : CategoryTheory.Cat\nF : CategoryTheory.Functor ‚Üëa‚úù ‚Üëb‚úù\nG : CategoryTheory.Functor ‚Üëb‚úù ‚Üëc‚úù\n‚ä¢ Eq (CategoryTheory.WithInitial.pseudofunctor.mapComp F G) (CategoryTheory.WithInitial.mapComp F G)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map‚ÇÇ_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    ¬∑ rfl\n  map‚ÇÇ_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id]\n      rfl\n    ¬∑ rfl\n  map‚ÇÇ_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    ¬∑ rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map‚ÇÇ, map‚ÇÇ_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [‚Üê Functor.map_id, Cat.id_map]\n      rfl\n    ¬∑ rfl\n\n"}
{"name":"CategoryTheory.WithInitial.lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithInitial.lift F M hM).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) X) ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => M a) fun x => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) CategoryTheory.WithInitial.star))","decl":"/-- Lift a functor `F : C ‚•§ D` to `WithInitial C ‚•§ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : WithInitial C ‚•§ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => M _\n    | star, star, _ => ùüô _\n\n"}
{"name":"CategoryTheory.WithInitial.lift_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.lift F M hM).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- Lift a functor `F : C ‚•§ D` to `WithInitial C ‚•§ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : WithInitial C ‚•§ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => M _\n    | star, star, _ => ùüô _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLift_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithInitial.inclLift F M hM).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (F.obj x‚úù))","decl":"/-- The isomorphism between `incl ‚ãô lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : incl ‚ãô lift F M hM ‚âÖ F where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.WithInitial.inclLift_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithInitial.inclLift F M hM).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.id.match_1 (fun X => D) (CategoryTheory.WithInitial.incl.obj x‚úù) (fun x => F.obj x) fun _ => Z))","decl":"/-- The isomorphism between `incl ‚ãô lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : incl ‚ãô lift F M hM ‚âÖ F where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_hom","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\n‚ä¢ Eq (CategoryTheory.WithInitial.liftStar F M hM).hom (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithInitial.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : (lift F M hM).obj star ‚âÖ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_inv","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\n‚ä¢ Eq (CategoryTheory.WithInitial.liftStar F M hM).inv (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithInitial.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) : (lift F M hM).obj star ‚âÖ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) ‚Üí Quiver.Hom Z (F.obj x)\nhM : ‚àÄ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithInitial.liftStar F M hM).hom ((CategoryTheory.WithInitial.lift F M hM).map (CategoryTheory.WithInitial.starInitial.to (CategoryTheory.WithInitial.incl.obj x)))) (CategoryTheory.CategoryStruct.comp (M x) ((CategoryTheory.WithInitial.inclLift F M hM).hom.app x))","decl":"theorem liftStar_lift_map {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (M : ‚àÄ x : C, Z ‚ü∂ F.obj x)\n    (hM : ‚àÄ (x y : C) (f : x ‚ü∂ y), M x ‚â´ F.map f = M y) (x : C) :\n    (liftStar F M hM).hom ‚â´ (lift F M hM).map (starInitial.to (incl.obj x)) =\n      M x ‚â´ (inclLift F M hM).hom.app x := by\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitial_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.WithInitial.liftToInitial F hZ).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) (CategoryTheory.WithInitial.id.match_1 (fun X => D) Y (fun x => F.obj x) fun _ => Z)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => hZ.to (F.obj a)) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- A variant of `lift` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitial {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z) :\n    WithInitial C ‚•§ D :=\n  lift F (fun _x => hZ.to _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitial_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.liftToInitial F hZ).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- A variant of `lift` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitial {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z) :\n    WithInitial C ‚•§ D :=\n  lift F (fun _x => hZ.to _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLiftToInitial_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithInitial.inclLiftToInitial F hZ).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.id.match_1 (fun X => D) (CategoryTheory.WithInitial.incl.obj x‚úù) (fun x => F.obj x) fun _ => Z))","decl":"/-- A variant of `incl_lift` with `Z` an initial object. -/\n@[simps!]\ndef inclLiftToInitial {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z) :\n    incl ‚ãô liftToInitial F hZ ‚âÖ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLiftToInitial_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nx‚úù : C\n‚ä¢ Eq ((CategoryTheory.WithInitial.inclLiftToInitial F hZ).inv.app x‚úù) (CategoryTheory.CategoryStruct.id (F.obj x‚úù))","decl":"/-- A variant of `incl_lift` with `Z` an initial object. -/\n@[simps!]\ndef inclLiftToInitial {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z) :\n    incl ‚ãô liftToInitial F hZ ‚âÖ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitialUnique_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nG : CategoryTheory.Functor (CategoryTheory.WithInitial C) D\nh : CategoryTheory.Iso (CategoryTheory.WithInitial.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithInitial.star) Z\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.liftToInitialUnique F hZ G h hG).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).inv","decl":"/-- A variant of `lift_unique` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitialUnique {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z)\n    (G : WithInitial C ‚•§ D) (h : incl ‚ãô G ‚âÖ F) (hG : G.obj star ‚âÖ Z) : G ‚âÖ liftToInitial F hZ :=\n  liftUnique F (fun _z => hZ.to _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitialUnique_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nG : CategoryTheory.Functor (CategoryTheory.WithInitial C) D\nh : CategoryTheory.Iso (CategoryTheory.WithInitial.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithInitial.star) Z\nX : CategoryTheory.WithInitial C\n‚ä¢ Eq ((CategoryTheory.WithInitial.liftToInitialUnique F hZ G h hG).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).hom","decl":"/-- A variant of `lift_unique` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitialUnique {D : Type*} [Category D] {Z : D} (F : C ‚•§ D) (hZ : Limits.IsInitial Z)\n    (G : WithInitial C ‚•§ D) (h : incl ‚ãô G ‚âÖ F) (hG : G.obj star ‚âÖ Z) : G ‚âÖ liftToInitial F hZ :=\n  liftUnique F (fun _z => hZ.to _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.isIso_of_to_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.WithInitial C\nf : Quiver.Hom X CategoryTheory.WithInitial.star\n‚ä¢ CategoryTheory.IsIso f","decl":"instance isIso_of_to_star {X : WithInitial C} (f : X ‚ü∂ star) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => ‚ü®f, rfl, rfl‚ü©\n\n"}
