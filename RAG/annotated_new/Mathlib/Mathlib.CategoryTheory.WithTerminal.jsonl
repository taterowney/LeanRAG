{"name":"CategoryTheory.WithTerminal.of.injEq","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na✝¹ a✝ : C\n⊢ Eq (Eq (CategoryTheory.WithTerminal.of a✝¹) (CategoryTheory.WithTerminal.of a✝)) (Eq a✝¹ a✝)","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C → WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.of.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : SizeOf C\na✝ : C\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.WithTerminal.of a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C → WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.of.inj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na✝¹ a✝ : C\nx✝ : Eq (CategoryTheory.WithTerminal.of a✝¹) (CategoryTheory.WithTerminal.of a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C → WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.star.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : SizeOf C\n⊢ Eq (SizeOf.sizeOf CategoryTheory.WithTerminal.star) 1","decl":"/-- Formally adjoin a terminal object to a category. -/\ninductive WithTerminal : Type u\n  | of : C → WithTerminal\n  | star : WithTerminal\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.star.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : SizeOf C\n⊢ Eq (SizeOf.sizeOf CategoryTheory.WithInitial.star) 1","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C → WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.inj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na✝¹ a✝ : C\nx✝ : Eq (CategoryTheory.WithInitial.of a✝¹) (CategoryTheory.WithInitial.of a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C → WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.sizeOf_spec","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : SizeOf C\na✝ : C\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.WithInitial.of a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C → WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithInitial.of.injEq","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\na✝¹ a✝ : C\n⊢ Eq (Eq (CategoryTheory.WithInitial.of a✝¹) (CategoryTheory.WithInitial.of a✝)) (Eq a✝¹ a✝)","decl":"/-- Formally adjoin an initial object to a category. -/\ninductive WithInitial : Type u\n  | of : C → WithInitial\n  | star : WithInitial\n  deriving Inhabited\n\n"}
{"name":"CategoryTheory.WithTerminal.down_id","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.WithTerminal.down (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.of X))) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] lemma down_id {X : C} : down (𝟙 (of X)) = 𝟙 X := rfl\n"}
{"name":"CategoryTheory.WithTerminal.down_comp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom (CategoryTheory.WithTerminal.of X) (CategoryTheory.WithTerminal.of Y)\ng : Quiver.Hom (CategoryTheory.WithTerminal.of Y) (CategoryTheory.WithTerminal.of Z)\n⊢ Eq (CategoryTheory.WithTerminal.down (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithTerminal.down f) (CategoryTheory.WithTerminal.down g))","decl":"@[simp] lemma down_comp {X Y Z : C} (f : of X ⟶ of Y) (g : of Y ⟶ of Z) :\n    down (f ≫ g) = down f ≫ down g :=\n  rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.false_of_from_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom CategoryTheory.WithTerminal.star (CategoryTheory.WithTerminal.of X)\n⊢ False","decl":"@[aesop safe destruct (rule_sets := [CategoryTheory])]\nlemma false_of_from_star {X : C} (f : star ⟶ of X) : False := (f : PEmpty).elim\n\n"}
{"name":"CategoryTheory.WithTerminal.instFullIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.WithTerminal.incl.Full","decl":"instance : (incl : C ⥤ _).Full where\n  map_surjective f := ⟨f, rfl⟩\n\n"}
{"name":"CategoryTheory.WithTerminal.instFaithfulIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.WithTerminal.incl.Faithful","decl":"instance : (incl : C ⥤ _).Faithful where\n\n"}
{"name":"CategoryTheory.WithTerminal.map_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithTerminal.map F).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) X) ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun a x => PUnit.unit) fun x => PUnit.unit)","decl":"/-- Map `WithTerminal` with respect to a functor `F : C ⥤ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ⥤ D) : WithTerminal C ⥤ WithTerminal D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of _, star, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithTerminal.map_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.map F).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star)","decl":"/-- Map `WithTerminal` with respect to a functor `F : C ⥤ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ⥤ D) : WithTerminal C ⥤ WithTerminal D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of _, star, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithTerminal.mapId_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.mapId C).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal C) X (fun x => CategoryTheory.WithTerminal.of x) fun _ => CategoryTheory.WithTerminal.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).inv","decl":"/-- A natural isomorphism between the functor `map (𝟭 C)` and `𝟭 (WithTerminal C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (𝟭 C) ≅ 𝟭 (WithTerminal C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapId_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.mapId C).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal C) X (fun x => CategoryTheory.WithTerminal.of x) fun _ => CategoryTheory.WithTerminal.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).hom","decl":"/-- A natural isomorphism between the functor `map (𝟭 C)` and `𝟭 (WithTerminal C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (𝟭 C) ≅ 𝟭 (WithTerminal C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapComp_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} D\ninst✝ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.mapComp F G).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) X (fun x => CategoryTheory.WithTerminal.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithTerminal.star) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) (fun x => CategoryTheory.WithTerminal.of (G.obj x)) fun _ => CategoryTheory.WithTerminal.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).hom","decl":"/-- A natural isomorphism between the functor `map (F ⋙ G) ` and `map F ⋙ map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ⥤ D) (G : D ⥤ E) :\n    map (F ⋙ G) ≅ map F ⋙ map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.mapComp_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} D\ninst✝ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.mapComp F G).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) X (fun x => CategoryTheory.WithTerminal.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithTerminal.star) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal E) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.WithTerminal D) X (fun x => CategoryTheory.WithTerminal.of (F.obj x)) fun _ => CategoryTheory.WithTerminal.star) (fun x => CategoryTheory.WithTerminal.of (G.obj x)) fun _ => CategoryTheory.WithTerminal.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithTerminal.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithTerminal.star).inv","decl":"/-- A natural isomorphism between the functor `map (F ⋙ G) ` and `map F ⋙ map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ⥤ D) (G : D ⥤ E) :\n    map (F ⋙ G) ≅ map F ⋙ map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithTerminal.map₂_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nη : Quiver.Hom F G\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.map₂ η).app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => Quiver.Hom ((CategoryTheory.WithTerminal.map F).obj X) ((CategoryTheory.WithTerminal.map G).obj X)) X (fun x => η.app x) fun _ => CategoryTheory.CategoryStruct.id CategoryTheory.WithTerminal.star)","decl":"/-- From a natural transformation of functors `C ⥤ D`, the induced natural transformation\nof functors `WithTerminal C ⥤ WithTerminal D`. -/\n@[simps]\ndef map₂ {D : Type*} [Category D] {F G : C ⥤ D} (η : F ⟶ G) : map F ⟶ map G where\n  app := fun X => match X with\n    | of x => η.app x\n    | star => 𝟙 star\n  naturality := by\n    intro X Y f\n    match X, Y, f with\n    | of x, of y, f => exact η.naturality f\n    | of x, star, _ => rfl\n    | star, star, _ => rfl\n\n-- Note: ...\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.obj C) (CategoryTheory.Cat.of (CategoryTheory.WithTerminal ↑C))","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"X✝ Y✝ : CategoryTheory.Cat\nF : CategoryTheory.Functor ↑X✝ ↑Y✝\n⊢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.map F) (CategoryTheory.WithTerminal.map F)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.prelaxfunctor_toPrelaxFunctorStruct_map₂","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a✝ b✝ : CategoryTheory.Cat\nf✝ g✝ : Quiver.Hom a✝ b✝\nη : Quiver.Hom f✝ g✝\n⊢ Eq (CategoryTheory.WithTerminal.prelaxfunctor.map₂ η) (CategoryTheory.WithTerminal.map₂ η)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithTerminal C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_mapId","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq (CategoryTheory.WithTerminal.pseudofunctor.mapId C) (CategoryTheory.WithTerminal.mapId ↑C)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_mapComp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a✝ b✝ c✝ : CategoryTheory.Cat\nF : CategoryTheory.Functor ↑a✝ ↑b✝\nG : CategoryTheory.Functor ↑b✝ ↑c✝\n⊢ Eq (CategoryTheory.WithTerminal.pseudofunctor.mapComp F G) (CategoryTheory.WithTerminal.mapComp F G)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.pseudofunctor_toPrelaxFunctor","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"⊢ Eq CategoryTheory.WithTerminal.pseudofunctor.toPrelaxFunctor CategoryTheory.WithTerminal.prelaxfunctor","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithTerminal`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    dsimp\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, Bicategory.whiskerRight, whiskerRight_app, map_obj, mapComp_hom_app,\n        Iso.refl_hom, map_map, down_id, Functor.map_id, Bicategory.whiskerLeft, whiskerLeft_app,\n        mapComp_inv_app, Iso.refl_inv, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithTerminal.lift F M hM).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) X) ((fun X => CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun x x_1 => M x) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- Lift a functor `F : C ⥤ D` to `WithTerminal C ⥤ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : WithTerminal C ⥤ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of x, star, _ => M x\n    | star, star, _ => 𝟙 Z\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.lift F M hM).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- Lift a functor `F : C ⥤ D` to `WithTerminal C ⥤ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : WithTerminal C ⥤ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | of x, star, _ => M x\n    | star, star, _ => 𝟙 Z\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLift_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx✝ : C\n⊢ Eq ((CategoryTheory.WithTerminal.inclLift F M hM).inv.app x✝) (CategoryTheory.CategoryStruct.id (F.obj x✝))","decl":"/-- The isomorphism between `incl ⋙ lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : incl ⋙ lift F M hM ≅ F where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLift_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx✝ : C\n⊢ Eq ((CategoryTheory.WithTerminal.inclLift F M hM).hom.app x✝) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.id.match_1 (fun X => D) (CategoryTheory.WithTerminal.incl.obj x✝) (fun x => F.obj x) fun _ => Z))","decl":"/-- The isomorphism between `incl ⋙ lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : incl ⋙ lift F M hM ≅ F where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.WithTerminal.liftStar_inv","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\n⊢ Eq (CategoryTheory.WithTerminal.liftStar F M hM).inv (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithTerminal.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : (lift F M hM).obj star ≅ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.liftStar_hom","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\n⊢ Eq (CategoryTheory.WithTerminal.liftStar F M hM).hom (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithTerminal.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) : (lift F M hM).obj star ≅ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.lift_map_liftStar","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom (F.obj x) Z\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (M y)) (M x)\nx : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.WithTerminal.lift F M hM).map (CategoryTheory.WithTerminal.starTerminal.from (CategoryTheory.WithTerminal.incl.obj x))) (CategoryTheory.WithTerminal.liftStar F M hM).hom) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.WithTerminal.inclLift F M hM).hom.app x) (M x))","decl":"theorem lift_map_liftStar {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, F.obj x ⟶ Z)\n    (hM : ∀ (x y : C) (f : x ⟶ y), F.map f ≫ M y = M x) (x : C) :\n    (lift F M hM).map (starTerminal.from (incl.obj x)) ≫ (liftStar F M hM).hom =\n      (inclLift F M hM).hom.app x ≫ M x := by\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminal_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.liftToTerminal F hZ).obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- A variant of `lift` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminal {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z) :\n    WithTerminal C ⥤ D :=\n  lift F (fun _x => hZ.from _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminal_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nX Y : CategoryTheory.WithTerminal C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithTerminal.liftToTerminal F hZ).map f) (CategoryTheory.WithTerminal.map.match_1 (fun X Y f => Quiver.Hom (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) Y (fun x => F.obj x) fun _ => Z)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithTerminal.down f)) (fun x x_1 => hZ.from (F.obj x)) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- A variant of `lift` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminal {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z) :\n    WithTerminal C ⥤ D :=\n  lift F (fun _x => hZ.from _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLiftToTerminal_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nx✝ : C\n⊢ Eq ((CategoryTheory.WithTerminal.inclLiftToTerminal F hZ).hom.app x✝) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithTerminal.id.match_1 (fun X => D) (CategoryTheory.WithTerminal.incl.obj x✝) (fun x => F.obj x) fun _ => Z))","decl":"/-- A variant of `incl_lift` with `Z` a terminal object. -/\n@[simps!]\ndef inclLiftToTerminal {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z) :\n    incl ⋙ liftToTerminal F hZ ≅ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.inclLiftToTerminal_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nx✝ : C\n⊢ Eq ((CategoryTheory.WithTerminal.inclLiftToTerminal F hZ).inv.app x✝) (CategoryTheory.CategoryStruct.id (F.obj x✝))","decl":"/-- A variant of `incl_lift` with `Z` a terminal object. -/\n@[simps!]\ndef inclLiftToTerminal {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z) :\n    incl ⋙ liftToTerminal F hZ ≅ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminalUnique_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nG : CategoryTheory.Functor (CategoryTheory.WithTerminal C) D\nh : CategoryTheory.Iso (CategoryTheory.WithTerminal.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithTerminal.star) Z\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.liftToTerminalUnique F hZ G h hG).inv.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).inv","decl":"/-- A variant of `lift_unique` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminalUnique {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z)\n    (G : WithTerminal C ⥤ D) (h : incl ⋙ G ≅ F) (hG : G.obj star ≅ Z) : G ≅ liftToTerminal F hZ :=\n  liftUnique F (fun _z => hZ.from _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x =>\n    hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.liftToTerminalUnique_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsTerminal Z\nG : CategoryTheory.Functor (CategoryTheory.WithTerminal C) D\nh : CategoryTheory.Iso (CategoryTheory.WithTerminal.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithTerminal.star) Z\nX : CategoryTheory.WithTerminal C\n⊢ Eq ((CategoryTheory.WithTerminal.liftToTerminalUnique F hZ G h hG).hom.app X) (CategoryTheory.WithTerminal.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithTerminal.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).hom","decl":"/-- A variant of `lift_unique` with `Z` a terminal object. -/\n@[simps!]\ndef liftToTerminalUnique {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsTerminal Z)\n    (G : WithTerminal C ⥤ D) (h : incl ⋙ G ≅ F) (hG : G.obj star ≅ Z) : G ≅ liftToTerminal F hZ :=\n  liftUnique F (fun _z => hZ.from _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x =>\n    hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithTerminal.isIso_of_from_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.WithTerminal C\nf : Quiver.Hom CategoryTheory.WithTerminal.star X\n⊢ CategoryTheory.IsIso f","decl":"instance isIso_of_from_star {X : WithTerminal C} (f : star ⟶ X) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => ⟨f, rfl, rfl⟩\n\n"}
{"name":"CategoryTheory.WithInitial.down_id","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.WithInitial.down (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.of X))) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] lemma down_id {X : C} : down (𝟙 (of X)) = 𝟙 X := rfl\n"}
{"name":"CategoryTheory.WithInitial.down_comp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom (CategoryTheory.WithInitial.of X) (CategoryTheory.WithInitial.of Y)\ng : Quiver.Hom (CategoryTheory.WithInitial.of Y) (CategoryTheory.WithInitial.of Z)\n⊢ Eq (CategoryTheory.WithInitial.down (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithInitial.down f) (CategoryTheory.WithInitial.down g))","decl":"@[simp] lemma down_comp {X Y Z : C} (f : of X ⟶ of Y) (g : of Y ⟶ of Z) :\n    down (f ≫ g) = down f ≫ down g :=\n  rfl\n\n"}
{"name":"CategoryTheory.WithInitial.false_of_to_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nf : Quiver.Hom (CategoryTheory.WithInitial.of X) CategoryTheory.WithInitial.star\n⊢ False","decl":"@[aesop safe destruct (rule_sets := [CategoryTheory])]\nlemma false_of_to_star {X : C} (f : of X ⟶ star) : False := (f : PEmpty).elim\n\n"}
{"name":"CategoryTheory.WithInitial.instFullIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.WithInitial.incl.Full","decl":"instance : (incl : C ⥤ _).Full where\n  map_surjective f := ⟨f, rfl⟩\n\n"}
{"name":"CategoryTheory.WithInitial.instFaithfulIncl","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.WithInitial.incl.Faithful","decl":"instance : (incl : C ⥤ _).Faithful where\n\n"}
{"name":"CategoryTheory.WithInitial.map_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithInitial.map F).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) X) ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => PUnit.unit) fun x => PUnit.unit)","decl":"/-- Map `WithInitial` with respect to a functor `F : C ⥤ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ⥤ D) : WithInitial C ⥤ WithInitial D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithInitial.map_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.map F).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star)","decl":"/-- Map `WithInitial` with respect to a functor `F : C ⥤ D`. -/\n@[simps]\ndef map {D : Type*} [Category D] (F : C ⥤ D) : WithInitial C ⥤ WithInitial D where\n  obj X :=\n    match X with\n    | of x => of <| F.obj x\n    | star => star\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => PUnit.unit\n    | star, star, _ => PUnit.unit\n\n"}
{"name":"CategoryTheory.WithInitial.mapId_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.mapId C).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial C) X (fun x => CategoryTheory.WithInitial.of x) fun _ => CategoryTheory.WithInitial.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).hom","decl":"/-- A natural isomorphism between the functor `map (𝟭 C)` and `𝟭 (WithInitial C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (𝟭 C) ≅ 𝟭 (WithInitial C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapId_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.mapId C).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial C) X (fun x => CategoryTheory.WithInitial.of x) fun _ => CategoryTheory.WithInitial.star) X) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of a)) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).inv","decl":"/-- A natural isomorphism between the functor `map (𝟭 C)` and `𝟭 (WithInitial C)`. -/\n@[simps!]\ndef mapId (C : Type*) [Category C] : map (𝟭 C) ≅ 𝟭 (WithInitial C) :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapComp_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} D\ninst✝ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.mapComp F G).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) X (fun x => CategoryTheory.WithInitial.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithInitial.star) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) (fun x => CategoryTheory.WithInitial.of (G.obj x)) fun _ => CategoryTheory.WithInitial.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).hom","decl":"/-- A natural isomorphism between the functor `map (F ⋙ G) ` and `map F ⋙ map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ⥤ D) (G : D ⥤ E) :\n    map (F ⋙ G) ≅ map F ⋙ map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.mapComp_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\nE : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} D\ninst✝ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.mapComp F G).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) X (fun x => CategoryTheory.WithInitial.of (G.obj (F.obj x))) fun _ => CategoryTheory.WithInitial.star) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial E) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.WithInitial D) X (fun x => CategoryTheory.WithInitial.of (F.obj x)) fun _ => CategoryTheory.WithInitial.star) (fun x => CategoryTheory.WithInitial.of (G.obj x)) fun _ => CategoryTheory.WithInitial.star)) X (fun a => CategoryTheory.Iso.refl (CategoryTheory.WithInitial.of (G.obj (F.obj a)))) fun _ => CategoryTheory.Iso.refl CategoryTheory.WithInitial.star).inv","decl":"/-- A natural isomorphism between the functor `map (F ⋙ G) ` and `map F ⋙ map G `. -/\n@[simps!]\ndef mapComp {D E : Type*} [Category D] [Category E] (F : C ⥤ D) (G : D ⥤ E) :\n    map (F ⋙ G) ≅ map F ⋙ map G :=\n  NatIso.ofComponents (fun X => match X with\n    | of _ => Iso.refl _\n    | star => Iso.refl _) (by aesop_cat)\n\n"}
{"name":"CategoryTheory.WithInitial.map₂_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nη : Quiver.Hom F G\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.map₂ η).app X) (CategoryTheory.WithInitial.id.match_1 (fun X => Quiver.Hom ((CategoryTheory.WithInitial.map F).obj X) ((CategoryTheory.WithInitial.map G).obj X)) X (fun x => η.app x) fun _ => CategoryTheory.CategoryStruct.id CategoryTheory.WithInitial.star)","decl":"/-- From a natural transformation of functors `C ⥤ D`, the induced natural transformation\nof functors `WithInitial C ⥤ WithInitial D`. -/\n@[simps]\ndef map₂ {D : Type*} [Category D] {F G : C ⥤ D} (η : F ⟶ G) : map F ⟶ map G where\n  app := fun X => match X with\n    | of x => η.app x\n    | star => 𝟙 star\n  naturality := by\n    intro X Y f\n    match X, Y, f with\n    | of x, of y, f => exact η.naturality f\n    | star, of x, _ => rfl\n    | star, star, _ => rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"X✝ Y✝ : CategoryTheory.Cat\nF : CategoryTheory.Functor ↑X✝ ↑Y✝\n⊢ Eq (CategoryTheory.WithInitial.prelaxfunctor.map F) (CategoryTheory.WithInitial.map F)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq (CategoryTheory.WithInitial.prelaxfunctor.obj C) (CategoryTheory.Cat.of (CategoryTheory.WithInitial ↑C))","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.prelaxfunctor_toPrelaxFunctorStruct_map₂","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a✝ b✝ : CategoryTheory.Cat\nf✝ g✝ : Quiver.Hom a✝ b✝\nη : Quiver.Hom f✝ g✝\n⊢ Eq (CategoryTheory.WithInitial.prelaxfunctor.map₂ η) (CategoryTheory.WithInitial.map₂ η)","decl":"/-- The prelax functor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef prelaxfunctor : PrelaxFunctor Cat Cat where\n  obj C := Cat.of (WithInitial C)\n  map := map\n  map₂ := map₂\n  map₂_id := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n  map₂_comp := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X <;> rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_toPrelaxFunctor","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"⊢ Eq CategoryTheory.WithInitial.pseudofunctor.toPrelaxFunctor CategoryTheory.WithInitial.prelaxfunctor","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id, Cat.id_map]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_mapId","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : CategoryTheory.Cat\n⊢ Eq (CategoryTheory.WithInitial.pseudofunctor.mapId C) (CategoryTheory.WithInitial.mapId ↑C)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id, Cat.id_map]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithInitial.pseudofunctor_mapComp","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"a✝ b✝ c✝ : CategoryTheory.Cat\nF : CategoryTheory.Functor ↑a✝ ↑b✝\nG : CategoryTheory.Functor ↑b✝ ↑c✝\n⊢ Eq (CategoryTheory.WithInitial.pseudofunctor.mapComp F G) (CategoryTheory.WithInitial.mapComp F G)","decl":"/-- The pseudofunctor from `Cat` to `Cat` defined with `WithInitial`. -/\n@[simps]\ndef pseudofunctor : Pseudofunctor Cat Cat where\n  toPrelaxFunctor := prelaxfunctor\n  mapId C := mapId C\n  mapComp := mapComp\n  map₂_whisker_left := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerLeft_app, mapComp_hom_app,\n        Iso.refl_hom, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n    · rfl\n  map₂_whisker_right := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, Cat.whiskerRight_app, mapComp_hom_app,\n        Iso.refl_hom, map_map, mapComp_inv_app, Iso.refl_inv, Category.comp_id, Category.id_comp]\n      rfl\n    · rfl\n  map₂_associator := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app,NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        map_map, down_id, Functor.map_id, Cat.whiskerLeft_app, mapComp_inv_app, Iso.refl_inv,\n        Category.comp_id, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n    · rfl\n  map₂_left_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.leftUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerRight_app,\n        mapId_hom_app, map_map, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id]\n      rfl\n    · rfl\n  map₂_right_unitor := by\n    intros\n    apply NatTrans.ext\n    funext X\n    cases X\n    · rw [NatTrans.comp_app, NatTrans.comp_app]\n      simp only [prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_obj,\n        prelaxfunctor_toPrelaxFunctorStruct_toPrefunctor_map, map_obj, Cat.comp_obj,\n        Bicategory.Strict.rightUnitor_eqToIso, eqToIso_refl, Iso.refl_hom,\n        prelaxfunctor_toPrelaxFunctorStruct_map₂, map₂_app, mapComp_hom_app, Cat.whiskerLeft_app,\n        mapId_hom_app, Category.id_comp]\n      rw [NatTrans.id_app, NatTrans.id_app]\n      simp only [Cat.comp_obj, map_obj, Category.comp_id]\n      rw [← Functor.map_id, Cat.id_map]\n      rfl\n    · rfl\n\n"}
{"name":"CategoryTheory.WithInitial.lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithInitial.lift F M hM).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) X) ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) Y)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => M a) fun x => CategoryTheory.CategoryStruct.id ((fun X => CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) CategoryTheory.WithInitial.star))","decl":"/-- Lift a functor `F : C ⥤ D` to `WithInitial C ⥤ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : WithInitial C ⥤ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => M _\n    | star, star, _ => 𝟙 _\n\n"}
{"name":"CategoryTheory.WithInitial.lift_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.lift F M hM).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- Lift a functor `F : C ⥤ D` to `WithInitial C ⥤ D`. -/\n@[simps]\ndef lift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : WithInitial C ⥤ D where\n  obj X :=\n    match X with\n    | of x => F.obj x\n    | star => Z\n  map {X Y} f :=\n    match X, Y, f with\n    | of _, of _, f => F.map (down f)\n    | star, of _, _ => M _\n    | star, star, _ => 𝟙 _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLift_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx✝ : C\n⊢ Eq ((CategoryTheory.WithInitial.inclLift F M hM).inv.app x✝) (CategoryTheory.CategoryStruct.id (F.obj x✝))","decl":"/-- The isomorphism between `incl ⋙ lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : incl ⋙ lift F M hM ≅ F where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.WithInitial.inclLift_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx✝ : C\n⊢ Eq ((CategoryTheory.WithInitial.inclLift F M hM).hom.app x✝) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.id.match_1 (fun X => D) (CategoryTheory.WithInitial.incl.obj x✝) (fun x => F.obj x) fun _ => Z))","decl":"/-- The isomorphism between `incl ⋙ lift F _ _` with `F`. -/\n@[simps!]\ndef inclLift {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : incl ⋙ lift F M hM ≅ F where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_hom","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\n⊢ Eq (CategoryTheory.WithInitial.liftStar F M hM).hom (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithInitial.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : (lift F M hM).obj star ≅ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_inv","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\n⊢ Eq (CategoryTheory.WithInitial.liftStar F M hM).inv (CategoryTheory.CategoryStruct.id Z)","decl":"/-- The isomorphism between `(lift F _ _).obj WithInitial.star` with `Z`. -/\n@[simps!]\ndef liftStar {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) : (lift F M hM).obj star ≅ Z :=\n  eqToIso rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftStar_lift_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nM : (x : C) → Quiver.Hom Z (F.obj x)\nhM : ∀ (x y : C) (f : Quiver.Hom x y), Eq (CategoryTheory.CategoryStruct.comp (M x) (F.map f)) (M y)\nx : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.WithInitial.liftStar F M hM).hom ((CategoryTheory.WithInitial.lift F M hM).map (CategoryTheory.WithInitial.starInitial.to (CategoryTheory.WithInitial.incl.obj x)))) (CategoryTheory.CategoryStruct.comp (M x) ((CategoryTheory.WithInitial.inclLift F M hM).hom.app x))","decl":"theorem liftStar_lift_map {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (M : ∀ x : C, Z ⟶ F.obj x)\n    (hM : ∀ (x y : C) (f : x ⟶ y), M x ≫ F.map f = M y) (x : C) :\n    (liftStar F M hM).hom ≫ (lift F M hM).map (starInitial.to (incl.obj x)) =\n      M x ≫ (inclLift F M hM).hom.app x := by\n  erw [Category.id_comp, Category.comp_id]\n  rfl\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitial_map","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nX Y : CategoryTheory.WithInitial C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.WithInitial.liftToInitial F hZ).map f) (CategoryTheory.WithInitial.map.match_1 (fun X Y f => Quiver.Hom (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z) (CategoryTheory.WithInitial.id.match_1 (fun X => D) Y (fun x => F.obj x) fun _ => Z)) X Y f (fun a a_1 f => F.map (CategoryTheory.WithInitial.down f)) (fun a x => hZ.to (F.obj a)) fun x => CategoryTheory.CategoryStruct.id Z)","decl":"/-- A variant of `lift` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitial {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z) :\n    WithInitial C ⥤ D :=\n  lift F (fun _x => hZ.to _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitial_obj","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.liftToInitial F hZ).obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)","decl":"/-- A variant of `lift` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitial {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z) :\n    WithInitial C ⥤ D :=\n  lift F (fun _x => hZ.to _) fun _x _y _f => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLiftToInitial_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nx✝ : C\n⊢ Eq ((CategoryTheory.WithInitial.inclLiftToInitial F hZ).hom.app x✝) (CategoryTheory.CategoryStruct.id (CategoryTheory.WithInitial.id.match_1 (fun X => D) (CategoryTheory.WithInitial.incl.obj x✝) (fun x => F.obj x) fun _ => Z))","decl":"/-- A variant of `incl_lift` with `Z` an initial object. -/\n@[simps!]\ndef inclLiftToInitial {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z) :\n    incl ⋙ liftToInitial F hZ ≅ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithInitial.inclLiftToInitial_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nx✝ : C\n⊢ Eq ((CategoryTheory.WithInitial.inclLiftToInitial F hZ).inv.app x✝) (CategoryTheory.CategoryStruct.id (F.obj x✝))","decl":"/-- A variant of `incl_lift` with `Z` an initial object. -/\n@[simps!]\ndef inclLiftToInitial {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z) :\n    incl ⋙ liftToInitial F hZ ≅ F :=\n  inclLift _ _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitialUnique_inv_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nG : CategoryTheory.Functor (CategoryTheory.WithInitial C) D\nh : CategoryTheory.Iso (CategoryTheory.WithInitial.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithInitial.star) Z\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.liftToInitialUnique F hZ G h hG).inv.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).inv","decl":"/-- A variant of `lift_unique` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitialUnique {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z)\n    (G : WithInitial C ⥤ D) (h : incl ⋙ G ≅ F) (hG : G.obj star ≅ Z) : G ≅ liftToInitial F hZ :=\n  liftUnique F (fun _z => hZ.to _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.liftToInitialUnique_hom_app","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nZ : D\nF : CategoryTheory.Functor C D\nhZ : CategoryTheory.Limits.IsInitial Z\nG : CategoryTheory.Functor (CategoryTheory.WithInitial C) D\nh : CategoryTheory.Iso (CategoryTheory.WithInitial.incl.comp G) F\nhG : CategoryTheory.Iso (G.obj CategoryTheory.WithInitial.star) Z\nX : CategoryTheory.WithInitial C\n⊢ Eq ((CategoryTheory.WithInitial.liftToInitialUnique F hZ G h hG).hom.app X) (CategoryTheory.WithInitial.id.match_1 (fun X => CategoryTheory.Iso (G.obj X) (CategoryTheory.WithInitial.id.match_1 (fun X => D) X (fun x => F.obj x) fun _ => Z)) X (fun x => h.app x) fun _ => hG).hom","decl":"/-- A variant of `lift_unique` with `Z` an initial object. -/\n@[simps!]\ndef liftToInitialUnique {D : Type*} [Category D] {Z : D} (F : C ⥤ D) (hZ : Limits.IsInitial Z)\n    (G : WithInitial C ⥤ D) (h : incl ⋙ G ≅ F) (hG : G.obj star ≅ Z) : G ≅ liftToInitial F hZ :=\n  liftUnique F (fun _z => hZ.to _) (fun _x _y _f => hZ.hom_ext _ _) G h hG fun _x => hZ.hom_ext _ _\n\n"}
{"name":"CategoryTheory.WithInitial.isIso_of_to_star","module":"Mathlib.CategoryTheory.WithTerminal","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.WithInitial C\nf : Quiver.Hom X CategoryTheory.WithInitial.star\n⊢ CategoryTheory.IsIso f","decl":"instance isIso_of_to_star {X : WithInitial C} (f : X ⟶ star) : IsIso f :=\n  match X with\n  | of _X => f.elim\n  | star => ⟨f, rfl, rfl⟩\n\n"}
