{"name":"PadicInt.norm_ascPochhammer_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nx : PadicInt p\n⊢ LE.le (Norm.norm (Polynomial.eval x (ascPochhammer (PadicInt p) k))) (Norm.norm ↑k.factorial)","decl":"/-- Bound for norms of ascending Pochhammer symbols. -/\nlemma norm_ascPochhammer_le (k : ℕ) (x : ℤ_[p]) :\n    ‖(ascPochhammer ℤ_[p] k).eval x‖ ≤ ‖(k.factorial : ℤ_[p])‖ := by\n  let f := (ascPochhammer ℤ_[p] k).eval\n  change ‖f x‖ ≤ ‖_‖\n  have hC : (k.factorial : ℤ_[p]) ≠ 0 := Nat.cast_ne_zero.mpr k.factorial_ne_zero\n  have hf : ContinuousAt f x := Polynomial.continuousAt _\n  -- find `n : ℕ` such that `‖f x - f n‖ ≤ ‖k!‖`\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, ‖f x - f n‖ ≤ ‖(k.factorial : ℤ_[p])‖ := by\n    obtain ⟨δ, hδp, hδ⟩ := Metric.continuousAt_iff.mp hf _ (norm_pos_iff.mpr hC)\n    obtain ⟨n, hn'⟩ := PadicInt.denseRange_natCast.exists_dist_lt x hδp\n    simpa only [← dist_eq_norm_sub'] using ⟨n, (hδ (dist_comm x n ▸ hn')).le⟩\n  -- use ultrametric property to show that `‖f n‖ ≤ ‖k!‖` implies `‖f x‖ ≤ ‖k!‖`\n  refine sub_add_cancel (f x) _ ▸ (IsUltrametricDist.norm_add_le_max _ (f n)).trans (max_le hn ?_)\n  -- finish using the fact that `n.multichoose k ∈ ℤ`\n  simp_rw [f, ← ascPochhammer_eval_cast, Polynomial.eval_eq_smeval,\n    ← Ring.factorial_nsmul_multichoose_eq_ascPochhammer, smul_eq_mul, Nat.cast_mul, norm_mul]\n  exact mul_le_of_le_one_right (norm_nonneg _) (norm_le_one _)\n\n"}
{"name":"PadicInt.continuous_multichoose","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\n⊢ Continuous fun x => Ring.multichoose x k","decl":"@[fun_prop]\nlemma continuous_multichoose (k : ℕ) : Continuous (fun x : ℤ_[p] ↦ Ring.multichoose x k) := by\n  simp only [Ring.multichoose, BinomialRing.multichoose, continuous_induced_rng]\n  fun_prop\n\n"}
{"name":"PadicInt.continuous_choose","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\n⊢ Continuous fun x => Ring.choose x k","decl":"@[fun_prop]\nlemma continuous_choose (k : ℕ) : Continuous (fun x : ℤ_[p] ↦ Ring.choose x k) := by\n  simp only [Ring.choose]\n  fun_prop\n\n"}
{"name":"mahler_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nx : PadicInt p\n⊢ Eq ((mahler k) x) ↑(Ring.choose x k)","decl":"lemma mahler_apply (k : ℕ) (x : ℤ_[p]) : mahler k x = Ring.choose x k := rfl\n\n"}
{"name":"mahler_natCast_eq","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk n : Nat\n⊢ Eq ((mahler k) ↑n) ↑(n.choose k)","decl":"/-- The function `mahler k` extends `n ↦ n.choose k` on `ℕ`. -/\nlemma mahler_natCast_eq (k n : ℕ) : mahler k (n : ℤ_[p]) = n.choose k := by\n  simp only [mahler_apply, Ring.choose_natCast, PadicInt.coe_natCast]\n\n"}
{"name":"norm_mahler_eq","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\n⊢ Eq (Norm.norm (mahler k)) 1","decl":"/--\nThe uniform norm of the `k`-th Mahler basis function is 1, for every `k`.\n-/\n@[simp] lemma norm_mahler_eq (k : ℕ) : ‖(mahler k : C(ℤ_[p], ℚ_[p]))‖ = 1 := by\n  apply le_antisymm\n  · -- Show all values have norm ≤ 1\n    exact (mahler k).norm_le_of_nonempty.mpr (fun _ ↦ PadicInt.norm_le_one _)\n  · -- Show norm 1 is attained at `x = k`\n    refine (le_of_eq ?_).trans ((mahler k).norm_coe_le_norm k)\n    rw [mahler_natCast_eq, Nat.choose_self, Nat.cast_one, norm_one]\n\n"}
{"name":"IsUltrametricDist.norm_fwdDiff_iter_apply_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : CompactSpace M\ninst✝² : AddCommMonoid M\ninst✝¹ : SeminormedAddCommGroup G\ninst✝ : IsUltrametricDist G\nh : M\nf : ContinuousMap M G\nm : M\nn : Nat\n⊢ LE.le (Norm.norm (Nat.iterate (fwdDiff h) n (⇑f) m)) (Norm.norm f)","decl":"/-- Bound for iterated forward differences of a continuous function from a compact space to a\nnonarchimedean seminormed group. -/\nlemma IsUltrametricDist.norm_fwdDiff_iter_apply_le [TopologicalSpace M] [CompactSpace M]\n    [AddCommMonoid M] [SeminormedAddCommGroup G] [IsUltrametricDist G]\n    (h : M) (f : C(M, G)) (m : M) (n : ℕ) : ‖Δ_[h]^[n] f m‖ ≤ ‖f‖ := by\n  -- A proof by induction on `n` would be possible but would involve some messing around to\n  -- define `Δ_[h]` as an operator on continuous maps (not just on bare functions). So instead we\n  -- use the formula for `Δ_[h]^[n] f` as a sum.\n  rw [fwdDiff_iter_eq_sum_shift]\n  refine norm_sum_le_of_forall_le_of_nonneg (norm_nonneg f) fun i _ ↦ ?_\n  exact (norm_zsmul_le _ _).trans (f.norm_coe_le_norm _)\n\n"}
{"name":"PadicInt.fwdDiff_iter_le_of_forall_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace (Padic p) E\ninst✝ : IsUltrametricDist E\nf : ContinuousMap (PadicInt p) E\ns t : Nat\nhst : ∀ (x y : PadicInt p), LE.le (Norm.norm (HSub.hSub x y)) (HPow.hPow (↑p) (Neg.neg ↑t)) → LE.le (Norm.norm (HSub.hSub (f x) (f y))) (HDiv.hDiv (Norm.norm f) (HPow.hPow (↑p) s))\nn : Nat\n⊢ LE.le (Norm.norm (Nat.iterate (fwdDiff 1) (HAdd.hAdd n (HMul.hMul s (HPow.hPow p t))) (⇑f) 0)) (HDiv.hDiv (Norm.norm f) (HPow.hPow (↑p) s))","decl":"/--\nExplicit bound for the decay rate of the Mahler coefficients of a continuous function on `ℤ_[p]`.\nThis will be used to prove Mahler's theorem.\n -/\nlemma fwdDiff_iter_le_of_forall_le {f : C(ℤ_[p], E)} {s t : ℕ}\n    (hst : ∀ x y : ℤ_[p], ‖x - y‖ ≤ p ^ (-t : ℤ) → ‖f x - f y‖ ≤ ‖f‖ / p ^ s) (n : ℕ) :\n    ‖Δ_[1]^[n + s * p ^ t] f 0‖ ≤ ‖f‖ / p ^ s := by\n  -- We show the following more general statement by induction on `k`:\n  suffices ∀ {k : ℕ}, k ≤ s → ‖Δ_[1]^[n + k * p ^ t] f 0‖ ≤ ‖f‖ / p ^ k from this le_rfl\n  intro k hk\n  induction' k with k IH generalizing n\n  · -- base case just says that `‖Δ^[·] (⇑f) 0‖` is bounded by `‖f‖`\n    simpa only [zero_mul, pow_zero, add_zero, div_one] using norm_fwdDiff_iter_apply_le 1 f 0 n\n  · -- induction is the \"step 2\" lemma above\n    rw [add_mul, one_mul, ← add_assoc]\n    refine (bojanic_mahler_step2 hst (n + k * p ^ t)).trans (max_le ?_ ?_)\n    · rw [← coe_nnnorm, ← NNReal.coe_natCast, ← NNReal.coe_pow, ← NNReal.coe_div, NNReal.coe_le_coe]\n      refine Finset.sup_le fun j _ ↦ ?_\n      rw [pow_succ, ← div_div, div_le_div_iff_of_pos_right (mod_cast hp.out.pos), add_right_comm]\n      exact_mod_cast IH (n + (j + 1)) (by omega)\n    · exact div_le_div_of_nonneg_left (norm_nonneg _)\n        (mod_cast pow_pos hp.out.pos _) (mod_cast pow_le_pow_right₀ hp.out.one_le hk)\n\n"}
{"name":"PadicInt.fwdDiff_tendsto_zero","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace (Padic p) E\ninst✝ : IsUltrametricDist E\nf : ContinuousMap (PadicInt p) E\n⊢ Filter.Tendsto (fun x => Nat.iterate (fwdDiff 1) x (⇑f) 0) Filter.atTop (nhds 0)","decl":"/-- Key lemma for Mahler's theorem: for `f` a continuous function on `ℤ_[p]`, the sequence\n`n ↦ Δ^[n] f 0` tends to 0. See `PadicInt.fwdDiff_iter_le_of_forall_le` for an explicit\nestimate of the decay rate. -/\nlemma fwdDiff_tendsto_zero (f : C(ℤ_[p], E)) : Tendsto (Δ_[1]^[·] f 0) atTop (𝓝 0) := by\n  -- first extract an `s`\n  refine NormedAddCommGroup.tendsto_nhds_zero.mpr (fun ε hε ↦ ?_)\n  have : Tendsto (fun s ↦ ‖f‖ / p ^ s) _ _ := tendsto_const_nhds.div_atTop\n    (tendsto_pow_atTop_atTop_of_one_lt (mod_cast hp.out.one_lt))\n  obtain ⟨s, hs⟩ := (this.eventually_lt_const hε).exists\n  refine .mp ?_ (.of_forall fun x hx ↦ lt_of_le_of_lt hx hs)\n  -- use uniform continuity to find `t`\n  obtain ⟨t, ht⟩ : ∃ t : ℕ, ∀ x y, ‖x - y‖ ≤ p ^ (-t : ℤ) → ‖f x - f y‖ ≤ ‖f‖ / p ^ s := by\n    rcases eq_or_ne f 0 with rfl | hf\n    · -- silly case : f = 0\n      simp\n    have : 0 < ‖f‖ / p ^ s := div_pos (norm_pos_iff.mpr hf) (mod_cast pow_pos hp.out.pos _)\n    obtain ⟨δ, hδpos, hδf⟩ := f.uniform_continuity _ this\n    obtain ⟨t, ht⟩ := PadicInt.exists_pow_neg_lt p hδpos\n    exact ⟨t, fun x y hxy ↦  by simpa only [dist_eq_norm_sub] using (hδf (hxy.trans_lt ht)).le⟩\n  filter_upwards [eventually_ge_atTop (s * p ^ t)] with m hm\n  simpa only [Nat.sub_add_cancel hm] using fwdDiff_iter_le_of_forall_le ht (m - s * p ^ t)\n\n"}
{"name":"PadicInt.mahlerTerm_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace (Padic p) E\na : E\nn : Nat\nx : PadicInt p\n⊢ Eq ((PadicInt.mahlerTerm a n) x) (HSMul.hSMul ((mahler n) x) a)","decl":"lemma mahlerTerm_apply : mahlerTerm a n x = mahler n x • a := by\n  simp only [mahlerTerm, ContinuousMap.smul_apply', ContinuousMap.const_apply]\n\n"}
{"name":"PadicInt.norm_mahlerTerm","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace (Padic p) E\na : E\nn : Nat\n⊢ Eq (Norm.norm (PadicInt.mahlerTerm a n)) (Norm.norm a)","decl":"lemma norm_mahlerTerm : ‖(mahlerTerm a n : C(ℤ_[p], E))‖ = ‖a‖ := by\n  simp only [mahlerTerm, ContinuousMap.norm_smul_const, norm_mahler_eq, one_mul]\n\n"}
{"name":"PadicInt.hasSum_mahlerSeries","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\na : Nat → E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\n⊢ HasSum (fun n => PadicInt.mahlerTerm (a n) n) (PadicInt.mahlerSeries a)","decl":"/-- A Mahler series whose coefficients tend to 0 is convergent. -/\nlemma hasSum_mahlerSeries (ha : Tendsto a atTop (𝓝 0)) :\n    HasSum (fun n ↦ mahlerTerm (a n) n) (mahlerSeries a : C(ℤ_[p], E)) := by\n  refine (NonarchimedeanAddGroup.summable_of_tendsto_cofinite_zero ?_).hasSum\n  rw [tendsto_zero_iff_norm_tendsto_zero] at ha ⊢\n  simpa only [norm_mahlerTerm, Nat.cofinite_eq_atTop] using ha\n\n"}
{"name":"PadicInt.mahlerSeries_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\na : Nat → E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nx : PadicInt p\n⊢ Eq ((PadicInt.mahlerSeries a) x) (tsum fun n => HSMul.hSMul ((mahler n) x) (a n))","decl":"/-- Evaluation of a Mahler series is just the pointwise sum. -/\nlemma mahlerSeries_apply (ha : Tendsto a atTop (𝓝 0)) (x : ℤ_[p]) :\n    mahlerSeries a x = ∑' n, mahler n x • a n := by\n  simp only [mahlerSeries, ← ContinuousMap.tsum_apply (hasSum_mahlerSeries ha).summable,\n    mahlerTerm_apply]\n\n"}
{"name":"PadicInt.mahlerSeries_apply_nat","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\na : Nat → E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nm n : Nat\nhmn : LE.le m n\n⊢ Eq ((PadicInt.mahlerSeries a) ↑m) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HSMul.hSMul (m.choose i) (a i))","decl":"/--\nThe value of a Mahler series at a natural number `n` is given by the finite sum of the first `m`\nterms, for any `n ≤ m`.\n-/\nlemma mahlerSeries_apply_nat (ha : Tendsto a atTop (𝓝 0)) {m n : ℕ} (hmn : m ≤ n) :\n    mahlerSeries a (m : ℤ_[p]) = ∑ i ∈ range (n + 1), m.choose i • a i := by\n  have h_van (i) : m.choose (i + (n + 1)) = 0 := Nat.choose_eq_zero_of_lt (by omega)\n  have aux : Summable fun i ↦ m.choose (i + (n + 1)) • a (i + (n + 1)) := by\n    simpa only [h_van, zero_smul] using summable_zero\n  simp only [mahlerSeries_apply ha, mahler_natCast_eq, Nat.cast_smul_eq_nsmul, add_zero,\n    ← sum_add_tsum_nat_add' (f := fun i ↦ m.choose i • a i) aux, h_van, zero_smul, tsum_zero]\n\n"}
{"name":"PadicInt.fwdDiff_mahlerSeries","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\na : Nat → E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nn : Nat\n⊢ Eq (Nat.iterate (fwdDiff 1) n (⇑(PadicInt.mahlerSeries a)) 0) (a n)","decl":"/--\nThe coefficients of a Mahler series can be recovered from the sum by taking forward differences at\n`0`.\n-/\nlemma fwdDiff_mahlerSeries (ha : Tendsto a atTop (𝓝 0)) (n) :\n    Δ_[1]^[n] (mahlerSeries a) (0 : ℤ_[p]) = a n :=\n  calc Δ_[1]^[n] (mahlerSeries a) 0\n  -- throw away terms after the n'th\n  _ = Δ_[1]^[n] (fun k ↦ ∑ j ∈ range (n + 1), k.choose j • (a j)) 0 := by\n    simp only [fwdDiff_iter_eq_sum_shift, zero_add]\n    refine Finset.sum_congr rfl fun j hj ↦ ?_\n    rw [nsmul_one, nsmul_one,\n      mahlerSeries_apply_nat ha (Nat.lt_succ.mp <| Finset.mem_range.mp hj), Nat.cast_id]\n  -- bring `Δ_[1]` inside sum\n  _ = ∑ j ∈ range (n + 1), Δ_[1]^[n] (fun k ↦ k.choose j • (a j)) 0 := by\n    simp only [fwdDiff_iter_eq_sum_shift, smul_sum]\n    rw [sum_comm]\n  -- bring `Δ_[1]` inside scalar-mult\n  _ = ∑ j ∈ range (n + 1), (Δ_[1]^[n] (fun k ↦ k.choose j : ℕ → ℤ) 0) • (a j) := by\n    simp only [fwdDiff_iter_eq_sum_shift, zero_add, sum_smul, smul_assoc, Nat.cast_id,\n      natCast_zsmul]\n  -- finish using `fwdDiff_iter_choose_zero`\n  _ = a n := by\n    simp only [fwdDiff_iter_choose_zero, ite_smul, one_smul, zero_smul, sum_ite_eq,\n      Finset.mem_range, lt_add_iff_pos_right, zero_lt_one, ↓reduceIte]\n\n"}
{"name":"PadicInt.hasSum_mahler","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\nf : ContinuousMap (PadicInt p) E\n⊢ HasSum (fun n => PadicInt.mahlerTerm (Nat.iterate (fwdDiff 1) n (⇑f) 0) n) f","decl":"/--\n**Mahler's theorem**: for any continuous function `f` from `ℤ_[p]` to a `p`-adic Banach space, the\nMahler series with coefficients `n ↦ Δ_[1]^[n] f 0` converges to the original function `f`.\n-/\nlemma hasSum_mahler (f : C(ℤ_[p], E)) : HasSum (fun n ↦ mahlerTerm (Δ_[1]^[n] f 0) n) f := by\n  -- First show `∑' n, mahler_term f n` converges to *something*.\n  have : HasSum (fun n ↦ mahlerTerm (Δ_[1]^[n] f 0) n)\n      (mahlerSeries (Δ_[1]^[·] f 0) : C(ℤ_[p], E)) :=\n    hasSum_mahlerSeries (PadicInt.fwdDiff_tendsto_zero f)\n  -- Now show that the sum of the Mahler terms must equal `f` on a dense set, so it is actually `f`.\n  convert this using 1\n  refine ContinuousMap.coe_injective (PadicInt.denseRange_natCast.equalizer\n    (map_continuous f) (map_continuous _) (funext fun n ↦ ?_))\n  simpa only [Function.comp_apply, mahlerSeries_apply_nat (fwdDiff_tendsto_zero f) le_rfl,\n    zero_add, sum_apply, Pi.smul_apply, nsmul_one] using (shift_eq_sum_fwdDiff_iter 1 f n 0)\n\n"}
{"name":"PadicInt.mahlerEquiv_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\nf : ContinuousMap (PadicInt p) E\n⊢ Eq ⇑((PadicInt.mahlerEquiv E) f) fun n => Nat.iterate (fwdDiff 1) n (⇑f) 0","decl":"lemma mahlerEquiv_apply (f : C(ℤ_[p], E)) : mahlerEquiv E f = fun n ↦ Δ_[1]^[n] f 0 := rfl\n\n"}
{"name":"PadicInt.mahlerEquiv_symm_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace (Padic p) E\ninst✝¹ : IsUltrametricDist E\ninst✝ : CompleteSpace E\na : ZeroAtInftyContinuousMap Nat E\n⊢ Eq ((PadicInt.mahlerEquiv E).symm a) (PadicInt.mahlerSeries ⇑a)","decl":"lemma mahlerEquiv_symm_apply (a : C₀(ℕ, E)) : (mahlerEquiv E).symm a = (mahlerSeries (p := p) a) :=\n  rfl\n\n"}
