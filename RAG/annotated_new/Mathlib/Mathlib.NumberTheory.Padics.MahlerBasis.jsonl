{"name":"PadicInt.norm_ascPochhammer_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nx : PadicInt p\nâŠ¢ LE.le (Norm.norm (Polynomial.eval x (ascPochhammer (PadicInt p) k))) (Norm.norm â†‘k.factorial)","decl":"/-- Bound for norms of ascending Pochhammer symbols. -/\nlemma norm_ascPochhammer_le (k : â„•) (x : â„¤_[p]) :\n    â€–(ascPochhammer â„¤_[p] k).eval xâ€– â‰¤ â€–(k.factorial : â„¤_[p])â€– := by\n  let f := (ascPochhammer â„¤_[p] k).eval\n  change â€–f xâ€– â‰¤ â€–_â€–\n  have hC : (k.factorial : â„¤_[p]) â‰  0 := Nat.cast_ne_zero.mpr k.factorial_ne_zero\n  have hf : ContinuousAt f x := Polynomial.continuousAt _\n  -- find `n : â„•` such that `â€–f x - f nâ€– â‰¤ â€–k!â€–`\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, â€–f x - f nâ€– â‰¤ â€–(k.factorial : â„¤_[p])â€– := by\n    obtain âŸ¨Î´, hÎ´p, hÎ´âŸ© := Metric.continuousAt_iff.mp hf _ (norm_pos_iff.mpr hC)\n    obtain âŸ¨n, hn'âŸ© := PadicInt.denseRange_natCast.exists_dist_lt x hÎ´p\n    simpa only [â† dist_eq_norm_sub'] using âŸ¨n, (hÎ´ (dist_comm x n â–¸ hn')).leâŸ©\n  -- use ultrametric property to show that `â€–f nâ€– â‰¤ â€–k!â€–` implies `â€–f xâ€– â‰¤ â€–k!â€–`\n  refine sub_add_cancel (f x) _ â–¸ (IsUltrametricDist.norm_add_le_max _ (f n)).trans (max_le hn ?_)\n  -- finish using the fact that `n.multichoose k âˆˆ â„¤`\n  simp_rw [f, â† ascPochhammer_eval_cast, Polynomial.eval_eq_smeval,\n    â† Ring.factorial_nsmul_multichoose_eq_ascPochhammer, smul_eq_mul, Nat.cast_mul, norm_mul]\n  exact mul_le_of_le_one_right (norm_nonneg _) (norm_le_one _)\n\n"}
{"name":"PadicInt.continuous_multichoose","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nâŠ¢ Continuous fun x => Ring.multichoose x k","decl":"@[fun_prop]\nlemma continuous_multichoose (k : â„•) : Continuous (fun x : â„¤_[p] â†¦ Ring.multichoose x k) := by\n  simp only [Ring.multichoose, BinomialRing.multichoose, continuous_induced_rng]\n  fun_prop\n\n"}
{"name":"PadicInt.continuous_choose","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nâŠ¢ Continuous fun x => Ring.choose x k","decl":"@[fun_prop]\nlemma continuous_choose (k : â„•) : Continuous (fun x : â„¤_[p] â†¦ Ring.choose x k) := by\n  simp only [Ring.choose]\n  fun_prop\n\n"}
{"name":"mahler_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nx : PadicInt p\nâŠ¢ Eq ((mahler k) x) â†‘(Ring.choose x k)","decl":"lemma mahler_apply (k : â„•) (x : â„¤_[p]) : mahler k x = Ring.choose x k := rfl\n\n"}
{"name":"mahler_natCast_eq","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk n : Nat\nâŠ¢ Eq ((mahler k) â†‘n) â†‘(n.choose k)","decl":"/-- The function `mahler k` extends `n â†¦ n.choose k` on `â„•`. -/\nlemma mahler_natCast_eq (k n : â„•) : mahler k (n : â„¤_[p]) = n.choose k := by\n  simp only [mahler_apply, Ring.choose_natCast, PadicInt.coe_natCast]\n\n"}
{"name":"norm_mahler_eq","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk : Nat\nâŠ¢ Eq (Norm.norm (mahler k)) 1","decl":"/--\nThe uniform norm of the `k`-th Mahler basis function is 1, for every `k`.\n-/\n@[simp] lemma norm_mahler_eq (k : â„•) : â€–(mahler k : C(â„¤_[p], â„š_[p]))â€– = 1 := by\n  apply le_antisymm\n  Â· -- Show all values have norm â‰¤ 1\n    exact (mahler k).norm_le_of_nonempty.mpr (fun _ â†¦ PadicInt.norm_le_one _)\n  Â· -- Show norm 1 is attained at `x = k`\n    refine (le_of_eq ?_).trans ((mahler k).norm_coe_le_norm k)\n    rw [mahler_natCast_eq, Nat.choose_self, Nat.cast_one, norm_one]\n\n"}
{"name":"IsUltrametricDist.norm_fwdDiff_iter_apply_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"M : Type u_1\nG : Type u_2\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : CompactSpace M\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : SeminormedAddCommGroup G\ninstâœ : IsUltrametricDist G\nh : M\nf : ContinuousMap M G\nm : M\nn : Nat\nâŠ¢ LE.le (Norm.norm (Nat.iterate (fwdDiff h) n (â‡‘f) m)) (Norm.norm f)","decl":"/-- Bound for iterated forward differences of a continuous function from a compact space to a\nnonarchimedean seminormed group. -/\nlemma IsUltrametricDist.norm_fwdDiff_iter_apply_le [TopologicalSpace M] [CompactSpace M]\n    [AddCommMonoid M] [SeminormedAddCommGroup G] [IsUltrametricDist G]\n    (h : M) (f : C(M, G)) (m : M) (n : â„•) : â€–Î”_[h]^[n] f mâ€– â‰¤ â€–fâ€– := by\n  -- A proof by induction on `n` would be possible but would involve some messing around to\n  -- define `Î”_[h]` as an operator on continuous maps (not just on bare functions). So instead we\n  -- use the formula for `Î”_[h]^[n] f` as a sum.\n  rw [fwdDiff_iter_eq_sum_shift]\n  refine norm_sum_le_of_forall_le_of_nonneg (norm_nonneg f) fun i _ â†¦ ?_\n  exact (norm_zsmul_le _ _).trans (f.norm_coe_le_norm _)\n\n"}
{"name":"PadicInt.fwdDiff_iter_le_of_forall_le","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace (Padic p) E\ninstâœ : IsUltrametricDist E\nf : ContinuousMap (PadicInt p) E\ns t : Nat\nhst : âˆ€ (x y : PadicInt p), LE.le (Norm.norm (HSub.hSub x y)) (HPow.hPow (â†‘p) (Neg.neg â†‘t)) â†’ LE.le (Norm.norm (HSub.hSub (f x) (f y))) (HDiv.hDiv (Norm.norm f) (HPow.hPow (â†‘p) s))\nn : Nat\nâŠ¢ LE.le (Norm.norm (Nat.iterate (fwdDiff 1) (HAdd.hAdd n (HMul.hMul s (HPow.hPow p t))) (â‡‘f) 0)) (HDiv.hDiv (Norm.norm f) (HPow.hPow (â†‘p) s))","decl":"/--\nExplicit bound for the decay rate of the Mahler coefficients of a continuous function on `â„¤_[p]`.\nThis will be used to prove Mahler's theorem.\n -/\nlemma fwdDiff_iter_le_of_forall_le {f : C(â„¤_[p], E)} {s t : â„•}\n    (hst : âˆ€ x y : â„¤_[p], â€–x - yâ€– â‰¤ p ^ (-t : â„¤) â†’ â€–f x - f yâ€– â‰¤ â€–fâ€– / p ^ s) (n : â„•) :\n    â€–Î”_[1]^[n + s * p ^ t] f 0â€– â‰¤ â€–fâ€– / p ^ s := by\n  -- We show the following more general statement by induction on `k`:\n  suffices âˆ€ {k : â„•}, k â‰¤ s â†’ â€–Î”_[1]^[n + k * p ^ t] f 0â€– â‰¤ â€–fâ€– / p ^ k from this le_rfl\n  intro k hk\n  induction' k with k IH generalizing n\n  Â· -- base case just says that `â€–Î”^[Â·] (â‡‘f) 0â€–` is bounded by `â€–fâ€–`\n    simpa only [zero_mul, pow_zero, add_zero, div_one] using norm_fwdDiff_iter_apply_le 1 f 0 n\n  Â· -- induction is the \"step 2\" lemma above\n    rw [add_mul, one_mul, â† add_assoc]\n    refine (bojanic_mahler_step2 hst (n + k * p ^ t)).trans (max_le ?_ ?_)\n    Â· rw [â† coe_nnnorm, â† NNReal.coe_natCast, â† NNReal.coe_pow, â† NNReal.coe_div, NNReal.coe_le_coe]\n      refine Finset.sup_le fun j _ â†¦ ?_\n      rw [pow_succ, â† div_div, div_le_div_iff_of_pos_right (mod_cast hp.out.pos), add_right_comm]\n      exact_mod_cast IH (n + (j + 1)) (by omega)\n    Â· exact div_le_div_of_nonneg_left (norm_nonneg _)\n        (mod_cast pow_pos hp.out.pos _) (mod_cast pow_le_pow_rightâ‚€ hp.out.one_le hk)\n\n"}
{"name":"PadicInt.fwdDiff_tendsto_zero","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace (Padic p) E\ninstâœ : IsUltrametricDist E\nf : ContinuousMap (PadicInt p) E\nâŠ¢ Filter.Tendsto (fun x => Nat.iterate (fwdDiff 1) x (â‡‘f) 0) Filter.atTop (nhds 0)","decl":"/-- Key lemma for Mahler's theorem: for `f` a continuous function on `â„¤_[p]`, the sequence\n`n â†¦ Î”^[n] f 0` tends to 0. See `PadicInt.fwdDiff_iter_le_of_forall_le` for an explicit\nestimate of the decay rate. -/\nlemma fwdDiff_tendsto_zero (f : C(â„¤_[p], E)) : Tendsto (Î”_[1]^[Â·] f 0) atTop (ğ“ 0) := by\n  -- first extract an `s`\n  refine NormedAddCommGroup.tendsto_nhds_zero.mpr (fun Îµ hÎµ â†¦ ?_)\n  have : Tendsto (fun s â†¦ â€–fâ€– / p ^ s) _ _ := tendsto_const_nhds.div_atTop\n    (tendsto_pow_atTop_atTop_of_one_lt (mod_cast hp.out.one_lt))\n  obtain âŸ¨s, hsâŸ© := (this.eventually_lt_const hÎµ).exists\n  refine .mp ?_ (.of_forall fun x hx â†¦ lt_of_le_of_lt hx hs)\n  -- use uniform continuity to find `t`\n  obtain âŸ¨t, htâŸ© : âˆƒ t : â„•, âˆ€ x y, â€–x - yâ€– â‰¤ p ^ (-t : â„¤) â†’ â€–f x - f yâ€– â‰¤ â€–fâ€– / p ^ s := by\n    rcases eq_or_ne f 0 with rfl | hf\n    Â· -- silly case : f = 0\n      simp\n    have : 0 < â€–fâ€– / p ^ s := div_pos (norm_pos_iff.mpr hf) (mod_cast pow_pos hp.out.pos _)\n    obtain âŸ¨Î´, hÎ´pos, hÎ´fâŸ© := f.uniform_continuity _ this\n    obtain âŸ¨t, htâŸ© := PadicInt.exists_pow_neg_lt p hÎ´pos\n    exact âŸ¨t, fun x y hxy â†¦  by simpa only [dist_eq_norm_sub] using (hÎ´f (hxy.trans_lt ht)).leâŸ©\n  filter_upwards [eventually_ge_atTop (s * p ^ t)] with m hm\n  simpa only [Nat.sub_add_cancel hm] using fwdDiff_iter_le_of_forall_le ht (m - s * p ^ t)\n\n"}
{"name":"PadicInt.mahlerTerm_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace (Padic p) E\na : E\nn : Nat\nx : PadicInt p\nâŠ¢ Eq ((PadicInt.mahlerTerm a n) x) (HSMul.hSMul ((mahler n) x) a)","decl":"lemma mahlerTerm_apply : mahlerTerm a n x = mahler n x â€¢ a := by\n  simp only [mahlerTerm, ContinuousMap.smul_apply', ContinuousMap.const_apply]\n\n"}
{"name":"PadicInt.norm_mahlerTerm","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace (Padic p) E\na : E\nn : Nat\nâŠ¢ Eq (Norm.norm (PadicInt.mahlerTerm a n)) (Norm.norm a)","decl":"lemma norm_mahlerTerm : â€–(mahlerTerm a n : C(â„¤_[p], E))â€– = â€–aâ€– := by\n  simp only [mahlerTerm, ContinuousMap.norm_smul_const, norm_mahler_eq, one_mul]\n\n"}
{"name":"PadicInt.hasSum_mahlerSeries","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\na : Nat â†’ E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nâŠ¢ HasSum (fun n => PadicInt.mahlerTerm (a n) n) (PadicInt.mahlerSeries a)","decl":"/-- A Mahler series whose coefficients tend to 0 is convergent. -/\nlemma hasSum_mahlerSeries (ha : Tendsto a atTop (ğ“ 0)) :\n    HasSum (fun n â†¦ mahlerTerm (a n) n) (mahlerSeries a : C(â„¤_[p], E)) := by\n  refine (NonarchimedeanAddGroup.summable_of_tendsto_cofinite_zero ?_).hasSum\n  rw [tendsto_zero_iff_norm_tendsto_zero] at ha âŠ¢\n  simpa only [norm_mahlerTerm, Nat.cofinite_eq_atTop] using ha\n\n"}
{"name":"PadicInt.mahlerSeries_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\na : Nat â†’ E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nx : PadicInt p\nâŠ¢ Eq ((PadicInt.mahlerSeries a) x) (tsum fun n => HSMul.hSMul ((mahler n) x) (a n))","decl":"/-- Evaluation of a Mahler series is just the pointwise sum. -/\nlemma mahlerSeries_apply (ha : Tendsto a atTop (ğ“ 0)) (x : â„¤_[p]) :\n    mahlerSeries a x = âˆ‘' n, mahler n x â€¢ a n := by\n  simp only [mahlerSeries, â† ContinuousMap.tsum_apply (hasSum_mahlerSeries ha).summable,\n    mahlerTerm_apply]\n\n"}
{"name":"PadicInt.mahlerSeries_apply_nat","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\na : Nat â†’ E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nm n : Nat\nhmn : LE.le m n\nâŠ¢ Eq ((PadicInt.mahlerSeries a) â†‘m) ((Finset.range (HAdd.hAdd n 1)).sum fun i => HSMul.hSMul (m.choose i) (a i))","decl":"/--\nThe value of a Mahler series at a natural number `n` is given by the finite sum of the first `m`\nterms, for any `n â‰¤ m`.\n-/\nlemma mahlerSeries_apply_nat (ha : Tendsto a atTop (ğ“ 0)) {m n : â„•} (hmn : m â‰¤ n) :\n    mahlerSeries a (m : â„¤_[p]) = âˆ‘ i âˆˆ range (n + 1), m.choose i â€¢ a i := by\n  have h_van (i) : m.choose (i + (n + 1)) = 0 := Nat.choose_eq_zero_of_lt (by omega)\n  have aux : Summable fun i â†¦ m.choose (i + (n + 1)) â€¢ a (i + (n + 1)) := by\n    simpa only [h_van, zero_smul] using summable_zero\n  simp only [mahlerSeries_apply ha, mahler_natCast_eq, Nat.cast_smul_eq_nsmul, add_zero,\n    â† sum_add_tsum_nat_add' (f := fun i â†¦ m.choose i â€¢ a i) aux, h_van, zero_smul, tsum_zero]\n\n"}
{"name":"PadicInt.fwdDiff_mahlerSeries","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\na : Nat â†’ E\nha : Filter.Tendsto a Filter.atTop (nhds 0)\nn : Nat\nâŠ¢ Eq (Nat.iterate (fwdDiff 1) n (â‡‘(PadicInt.mahlerSeries a)) 0) (a n)","decl":"/--\nThe coefficients of a Mahler series can be recovered from the sum by taking forward differences at\n`0`.\n-/\nlemma fwdDiff_mahlerSeries (ha : Tendsto a atTop (ğ“ 0)) (n) :\n    Î”_[1]^[n] (mahlerSeries a) (0 : â„¤_[p]) = a n :=\n  calc Î”_[1]^[n] (mahlerSeries a) 0\n  -- throw away terms after the n'th\n  _ = Î”_[1]^[n] (fun k â†¦ âˆ‘ j âˆˆ range (n + 1), k.choose j â€¢ (a j)) 0 := by\n    simp only [fwdDiff_iter_eq_sum_shift, zero_add]\n    refine Finset.sum_congr rfl fun j hj â†¦ ?_\n    rw [nsmul_one, nsmul_one,\n      mahlerSeries_apply_nat ha (Nat.lt_succ.mp <| Finset.mem_range.mp hj), Nat.cast_id]\n  -- bring `Î”_[1]` inside sum\n  _ = âˆ‘ j âˆˆ range (n + 1), Î”_[1]^[n] (fun k â†¦ k.choose j â€¢ (a j)) 0 := by\n    simp only [fwdDiff_iter_eq_sum_shift, smul_sum]\n    rw [sum_comm]\n  -- bring `Î”_[1]` inside scalar-mult\n  _ = âˆ‘ j âˆˆ range (n + 1), (Î”_[1]^[n] (fun k â†¦ k.choose j : â„• â†’ â„¤) 0) â€¢ (a j) := by\n    simp only [fwdDiff_iter_eq_sum_shift, zero_add, sum_smul, smul_assoc, Nat.cast_id,\n      natCast_zsmul]\n  -- finish using `fwdDiff_iter_choose_zero`\n  _ = a n := by\n    simp only [fwdDiff_iter_choose_zero, ite_smul, one_smul, zero_smul, sum_ite_eq,\n      Finset.mem_range, lt_add_iff_pos_right, zero_lt_one, â†“reduceIte]\n\n"}
{"name":"PadicInt.hasSum_mahler","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\nf : ContinuousMap (PadicInt p) E\nâŠ¢ HasSum (fun n => PadicInt.mahlerTerm (Nat.iterate (fwdDiff 1) n (â‡‘f) 0) n) f","decl":"/--\n**Mahler's theorem**: for any continuous function `f` from `â„¤_[p]` to a `p`-adic Banach space, the\nMahler series with coefficients `n â†¦ Î”_[1]^[n] f 0` converges to the original function `f`.\n-/\nlemma hasSum_mahler (f : C(â„¤_[p], E)) : HasSum (fun n â†¦ mahlerTerm (Î”_[1]^[n] f 0) n) f := by\n  -- First show `âˆ‘' n, mahler_term f n` converges to *something*.\n  have : HasSum (fun n â†¦ mahlerTerm (Î”_[1]^[n] f 0) n)\n      (mahlerSeries (Î”_[1]^[Â·] f 0) : C(â„¤_[p], E)) :=\n    hasSum_mahlerSeries (PadicInt.fwdDiff_tendsto_zero f)\n  -- Now show that the sum of the Mahler terms must equal `f` on a dense set, so it is actually `f`.\n  convert this using 1\n  refine ContinuousMap.coe_injective (PadicInt.denseRange_natCast.equalizer\n    (map_continuous f) (map_continuous _) (funext fun n â†¦ ?_))\n  simpa only [Function.comp_apply, mahlerSeries_apply_nat (fwdDiff_tendsto_zero f) le_rfl,\n    zero_add, sum_apply, Pi.smul_apply, nsmul_one] using (shift_eq_sum_fwdDiff_iter 1 f n 0)\n\n"}
{"name":"PadicInt.mahlerEquiv_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\nf : ContinuousMap (PadicInt p) E\nâŠ¢ Eq â‡‘((PadicInt.mahlerEquiv E) f) fun n => Nat.iterate (fwdDiff 1) n (â‡‘f) 0","decl":"lemma mahlerEquiv_apply (f : C(â„¤_[p], E)) : mahlerEquiv E f = fun n â†¦ Î”_[1]^[n] f 0 := rfl\n\n"}
{"name":"PadicInt.mahlerEquiv_symm_apply","module":"Mathlib.NumberTheory.Padics.MahlerBasis","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nE : Type u_1\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace (Padic p) E\ninstâœÂ¹ : IsUltrametricDist E\ninstâœ : CompleteSpace E\na : ZeroAtInftyContinuousMap Nat E\nâŠ¢ Eq ((PadicInt.mahlerEquiv E).symm a) (PadicInt.mahlerSeries â‡‘a)","decl":"lemma mahlerEquiv_symm_apply (a : Câ‚€(â„•, E)) : (mahlerEquiv E).symm a = (mahlerSeries (p := p) a) :=\n  rfl\n\n"}
