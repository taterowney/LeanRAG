{"name":"Polynomial.EisensteinCriterionAux.map_eq_C_mul_X_pow_of_forall_coeff_mem","module":"Mathlib.RingTheory.EisensteinCriterion","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nf : Polynomial R\nP : Ideal R\nhfP : ∀ (n : Nat), LT.lt (↑n) f.degree → Membership.mem P (f.coeff n)\n⊢ Eq (Polynomial.map (Ideal.Quotient.mk P) f) (HMul.hMul (Polynomial.C ((Ideal.Quotient.mk P) f.leadingCoeff)) (HPow.hPow Polynomial.X f.natDegree))","decl":"theorem map_eq_C_mul_X_pow_of_forall_coeff_mem {f : R[X]} {P : Ideal R}\n    (hfP : ∀ n : ℕ, ↑n < f.degree → f.coeff n ∈ P) :\n    map (mk P) f = C ((mk P) f.leadingCoeff) * X ^ f.natDegree :=\n  Polynomial.ext fun n => by\n    by_cases hf0 : f = 0\n    · simp [hf0]\n    rcases lt_trichotomy (n : WithBot ℕ) (degree f) with (h | h | h)\n    · rw [coeff_map, eq_zero_iff_mem.2 (hfP n h), coeff_C_mul, coeff_X_pow, if_neg, mul_zero]\n      rintro rfl\n      exact not_lt_of_ge degree_le_natDegree h\n    · have : natDegree f = n := natDegree_eq_of_degree_eq_some h.symm\n      rw [coeff_C_mul, coeff_X_pow, if_pos this.symm, mul_one, leadingCoeff, this, coeff_map]\n    · rw [coeff_eq_zero_of_degree_lt, coeff_eq_zero_of_degree_lt]\n      · refine lt_of_le_of_lt (degree_C_mul_X_pow_le _ _) ?_\n        rwa [← degree_eq_natDegree hf0]\n      · exact lt_of_le_of_lt degree_map_le h\n\n"}
{"name":"Polynomial.EisensteinCriterionAux.le_natDegree_of_map_eq_mul_X_pow","module":"Mathlib.RingTheory.EisensteinCriterion","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nP : Ideal R\nhP : P.IsPrime\nq : Polynomial R\nc : Polynomial (HasQuotient.Quotient R P)\nhq : Eq (Polynomial.map (Ideal.Quotient.mk P) q) (HMul.hMul c (HPow.hPow Polynomial.X n))\nhc0 : Eq c.degree 0\n⊢ LE.le n q.natDegree","decl":"theorem le_natDegree_of_map_eq_mul_X_pow {n : ℕ} {P : Ideal R} (hP : P.IsPrime) {q : R[X]}\n    {c : Polynomial (R ⧸ P)} (hq : map (mk P) q = c * X ^ n) (hc0 : c.degree = 0) :\n    n ≤ q.natDegree :=\n  Nat.cast_le.1\n    (calc\n      ↑n = degree (q.map (mk P)) := by\n        rw [hq, degree_mul, hc0, zero_add, degree_pow, degree_X, nsmul_one]\n      _ ≤ degree q := degree_map_le\n      _ ≤ natDegree q := degree_le_natDegree\n      )\n\n"}
{"name":"Polynomial.EisensteinCriterionAux.eval_zero_mem_ideal_of_eq_mul_X_pow","module":"Mathlib.RingTheory.EisensteinCriterion","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Nat\nP : Ideal R\nq : Polynomial R\nc : Polynomial (HasQuotient.Quotient R P)\nhq : Eq (Polynomial.map (Ideal.Quotient.mk P) q) (HMul.hMul c (HPow.hPow Polynomial.X n))\nhn0 : Ne n 0\n⊢ Membership.mem P (Polynomial.eval 0 q)","decl":"theorem eval_zero_mem_ideal_of_eq_mul_X_pow {n : ℕ} {P : Ideal R} {q : R[X]}\n    {c : Polynomial (R ⧸ P)} (hq : map (mk P) q = c * X ^ n) (hn0 : n ≠ 0) : eval 0 q ∈ P := by\n  rw [← coeff_zero_eq_eval_zero, ← eq_zero_iff_mem, ← coeff_map, hq,\n    coeff_zero_eq_eval_zero, eval_mul, eval_pow, eval_X, zero_pow hn0, mul_zero]\n\n"}
{"name":"Polynomial.EisensteinCriterionAux.isUnit_of_natDegree_eq_zero_of_isPrimitive","module":"Mathlib.RingTheory.EisensteinCriterion","initialProofState":"R : Type u_1\ninst✝ : CommRing R\np q : Polynomial R\nhu : (HMul.hMul p q).IsPrimitive\nhpm : Eq p.natDegree 0\n⊢ IsUnit p","decl":"theorem isUnit_of_natDegree_eq_zero_of_isPrimitive {p q : R[X]}\n    -- Porting note: stated using `IsPrimitive` which is defeq to old statement.\n    (hu : IsPrimitive (p * q)) (hpm : p.natDegree = 0) : IsUnit p := by\n  rw [eq_C_of_degree_le_zero (natDegree_eq_zero_iff_degree_le_zero.1 hpm), isUnit_C]\n  refine hu _ ?_\n  rw [← eq_C_of_degree_le_zero (natDegree_eq_zero_iff_degree_le_zero.1 hpm)]\n  exact dvd_mul_right _ _\n\n"}
{"name":"Polynomial.irreducible_of_eisenstein_criterion","module":"Mathlib.RingTheory.EisensteinCriterion","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nf : Polynomial R\nP : Ideal R\nhP : P.IsPrime\nhfl : Not (Membership.mem P f.leadingCoeff)\nhfP : ∀ (n : Nat), LT.lt (↑n) f.degree → Membership.mem P (f.coeff n)\nhfd0 : LT.lt 0 f.degree\nh0 : Not (Membership.mem (HPow.hPow P 2) (f.coeff 0))\nhu : f.IsPrimitive\n⊢ Irreducible f","decl":"/-- If `f` is a non constant polynomial with coefficients in `R`, and `P` is a prime ideal in `R`,\nthen if every coefficient in `R` except the leading coefficient is in `P`, and\nthe trailing coefficient is not in `P^2` and no non units in `R` divide `f`, then `f` is\nirreducible. -/\ntheorem irreducible_of_eisenstein_criterion {f : R[X]} {P : Ideal R} (hP : P.IsPrime)\n    (hfl : f.leadingCoeff ∉ P) (hfP : ∀ n : ℕ, ↑n < degree f → f.coeff n ∈ P) (hfd0 : 0 < degree f)\n    (h0 : f.coeff 0 ∉ P ^ 2) (hu : f.IsPrimitive) : Irreducible f :=\n  have hf0 : f ≠ 0 := fun _ => by simp_all only [not_true, Submodule.zero_mem, coeff_zero]\n  have hf : f.map (mk P) = C (mk P (leadingCoeff f)) * X ^ natDegree f :=\n    map_eq_C_mul_X_pow_of_forall_coeff_mem hfP\n  have hfd0 : 0 < f.natDegree := WithBot.coe_lt_coe.1 (lt_of_lt_of_le hfd0 degree_le_natDegree)\n  ⟨mt degree_eq_zero_of_isUnit fun h => by simp_all only [lt_irrefl], by\n    rintro p q rfl\n    rw [Polynomial.map_mul] at hf\n    rcases mul_eq_mul_prime_pow\n        (show Prime (X : Polynomial (R ⧸ P)) from monic_X.prime_of_degree_eq_one degree_X) hf with\n      ⟨m, n, b, c, hmnd, hbc, hp, hq⟩\n    have hmn : 0 < m → 0 < n → False := by\n      intro hm0 hn0\n      refine h0 ?_\n      rw [coeff_zero_eq_eval_zero, eval_mul, sq]\n      exact\n        Ideal.mul_mem_mul (eval_zero_mem_ideal_of_eq_mul_X_pow hp hm0.ne')\n          (eval_zero_mem_ideal_of_eq_mul_X_pow hq hn0.ne')\n    have hpql0 : (mk P) (p * q).leadingCoeff ≠ 0 := by rwa [Ne, eq_zero_iff_mem]\n    have hp0 : p ≠ 0 := fun h => by\n      simp_all only [zero_mul, eq_self_iff_true, not_true, Ne]\n    have hq0 : q ≠ 0 := fun h => by\n      simp_all only [eq_self_iff_true, not_true, Ne, mul_zero]\n    have hbc0 : degree b = 0 ∧ degree c = 0 := by\n      apply_fun degree at hbc\n      rwa [degree_C hpql0, degree_mul, eq_comm, Nat.WithBot.add_eq_zero_iff] at hbc\n    have hmp : m ≤ natDegree p := le_natDegree_of_map_eq_mul_X_pow hP hp hbc0.1\n    have hnq : n ≤ natDegree q := le_natDegree_of_map_eq_mul_X_pow hP hq hbc0.2\n    have hpmqn : p.natDegree = m ∧ q.natDegree = n := by\n      rw [natDegree_mul hp0 hq0] at hmnd\n      contrapose hmnd\n      apply ne_of_lt\n      rw [not_and_or] at hmnd\n      cases' hmnd with hmnd hmnd\n      · exact add_lt_add_of_lt_of_le (lt_of_le_of_ne hmp (Ne.symm hmnd)) hnq\n      · exact add_lt_add_of_le_of_lt hmp (lt_of_le_of_ne hnq (Ne.symm hmnd))\n    obtain rfl | rfl : m = 0 ∨ n = 0 := by\n      rwa [pos_iff_ne_zero, pos_iff_ne_zero, imp_false, Classical.not_not, ← or_iff_not_imp_left]\n        at hmn\n    · exact Or.inl (isUnit_of_natDegree_eq_zero_of_isPrimitive hu hpmqn.1)\n    · exact Or.inr\n          (isUnit_of_natDegree_eq_zero_of_isPrimitive\n            (show IsPrimitive (q * p) by simpa [mul_comm] using hu)\n            hpmqn.2)⟩\n\n"}
