{"name":"CategoryTheory.Monad.MonadicityInternal.main_pair_reflexive","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\n‚ä¢ CategoryTheory.IsReflexivePair (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"/-- The \"main pair\" for an algebra `(A, Œ±)` is the pair of morphisms `(F Œ±, Œµ_FA)`. It is always a\nreflexive pair, and will be used to construct the left adjoint to the comparison functor and show it\nis an equivalence.\n-/\ninstance main_pair_reflexive (A : adj.toMonad.Algebra) :\n    IsReflexivePair (F.map A.a) (adj.counit.app (F.obj A.A)) := by\n  apply IsReflexivePair.mk' (F.map (adj.unit.app _)) _ _\n  ¬∑ rw [‚Üê F.map_comp, ‚Üê F.map_id]\n    exact congr_arg F.map A.unit\n  ¬∑ rw [adj.left_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.main_pair_G_split","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\n‚ä¢ G.IsSplitPair (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"/-- The \"main pair\" for an algebra `(A, Œ±)` is the pair of morphisms `(F Œ±, Œµ_FA)`. It is always a\n`G`-split pair, and will be used to construct the left adjoint to the comparison functor and show it\nis an equivalence.\n-/\ninstance main_pair_G_split (A : adj.toMonad.Algebra) :\n    G.IsSplitPair (F.map A.a)\n      (adj.counit.app (F.obj A.A)) where\n  splittable := ‚ü®_, _, ‚ü®beckSplitCoequalizer A‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv_apply_f","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\nB : D\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\na‚úù : Quiver.Hom (CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointObj adj A) B\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv adj A B) a‚úù).f ((adj.homEquiv A.A B) ‚Üë((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A)))) B) a‚úù))","decl":"/--\nWe have a bijection of homsets which will be used to construct the left adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonLeftAdjointHomEquiv (A : adj.toMonad.Algebra) (B : D)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (comparisonLeftAdjointObj adj A ‚ü∂ B) ‚âÉ (A ‚ü∂ (comparison adj).obj B) :=\n  calc\n    (comparisonLeftAdjointObj adj A ‚ü∂ B) ‚âÉ { f : F.obj A.A ‚ü∂ B // _ } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) B\n    _ ‚âÉ { g : A.A ‚ü∂ G.obj B // G.map (F.map g) ‚â´ G.map (adj.counit.app B) = A.a ‚â´ g } := by\n      refine (adj.homEquiv _ _).subtypeEquiv ?_\n      intro f\n      rw [‚Üê (adj.homEquiv _ _).injective.eq_iff, Adjunction.homEquiv_naturality_left,\n        adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp]\n      dsimp\n      rw [adj.right_triangle_components_assoc, ‚Üê G.map_comp, F.map_comp, Category.assoc,\n        adj.counit_naturality, adj.left_triangle_components_assoc]\n      apply eq_comm\n    _ ‚âÉ (A ‚ü∂ (comparison adj).obj B) :=\n      { toFun := fun g =>\n          { f := _\n            h := g.prop }\n        invFun := fun f => ‚ü®f.f, f.h‚ü©\n        left_inv := fun g => by ext; rfl\n        right_inv := fun f => by ext; rfl }\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv_symm_apply","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\nB : D\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\na‚úù : Quiver.Hom A ((CategoryTheory.Monad.comparison adj).obj B)\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv adj A B).symm a‚úù) ((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A)))) B).symm ‚ü®(adj.homEquiv A.A B).symm a‚úù.f, ‚ãØ‚ü©)","decl":"/--\nWe have a bijection of homsets which will be used to construct the left adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonLeftAdjointHomEquiv (A : adj.toMonad.Algebra) (B : D)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (comparisonLeftAdjointObj adj A ‚ü∂ B) ‚âÉ (A ‚ü∂ (comparison adj).obj B) :=\n  calc\n    (comparisonLeftAdjointObj adj A ‚ü∂ B) ‚âÉ { f : F.obj A.A ‚ü∂ B // _ } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) B\n    _ ‚âÉ { g : A.A ‚ü∂ G.obj B // G.map (F.map g) ‚â´ G.map (adj.counit.app B) = A.a ‚â´ g } := by\n      refine (adj.homEquiv _ _).subtypeEquiv ?_\n      intro f\n      rw [‚Üê (adj.homEquiv _ _).injective.eq_iff, Adjunction.homEquiv_naturality_left,\n        adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp]\n      dsimp\n      rw [adj.right_triangle_components_assoc, ‚Üê G.map_comp, F.map_comp, Category.assoc,\n        adj.counit_naturality, adj.left_triangle_components_assoc]\n      apply eq_comm\n    _ ‚âÉ (A ‚ü∂ (comparison adj).obj B) :=\n      { toFun := fun g =>\n          { f := _\n            h := g.prop }\n        invFun := fun f => ‚ü®f.f, f.h‚ü©\n        left_inv := fun g => by ext; rfl\n        right_inv := fun f => by ext; rfl }\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_counit","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n‚ä¢ Eq (CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).counit { app := fun Y => (CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app Y))) (adj.counit.app (F.obj (G.obj Y))))) Y).symm ‚ü®(adj.homEquiv (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)), ‚ãØ‚ü©, naturality := ‚ãØ }","decl":"/-- Provided we have the appropriate coequalizers, we have an adjunction to the comparison functor.\n-/\n@[simps! counit]\ndef comparisonAdjunction\n    [‚àÄ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))] :\n    leftAdjointComparison adj ‚ä£ comparison adj :=\n  Adjunction.adjunctionOfEquivLeft _ _\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f_aux","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nA : adj.toMonad.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).unit.app A).f ((adj.homEquiv A.A (CategoryTheory.Limits.coequalizer (F.map A.a) (adj.counit.app (F.obj A.A)))) (CategoryTheory.Limits.coequalizer.œÄ (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"theorem comparisonAdjunction_unit_f_aux\n    [‚àÄ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))]\n    (A : adj.toMonad.Algebra) :\n    ((comparisonAdjunction adj).unit.app A).f =\n      adj.homEquiv A.A _\n        (coequalizer.œÄ (F.map A.a) (adj.counit.app (F.obj A.A))) :=\n  congr_arg (adj.homEquiv _ _) (Category.comp_id _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.unitCofork_pt","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n‚ä¢ Eq (CategoryTheory.Monad.MonadicityInternal.unitCofork A).pt (G.obj (CategoryTheory.Limits.coequalizer (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"/-- This is a cofork which is helpful for establishing monadicity: the morphism from the Beck\ncoequalizer to this cofork is the unit for the adjunction on the comparison functor.\n-/\n@[simps! pt]\ndef unitCofork (A : adj.toMonad.Algebra)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    Cofork (G.map (F.map A.a)) (G.map (adj.counit.app (F.obj A.A))) :=\n  Cofork.ofœÄ (G.map (coequalizer.œÄ (F.map A.a) (adj.counit.app (F.obj A.A))))\n    (by rw [‚Üê G.map_comp, coequalizer.condition, G.map_comp])\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.unitCofork_œÄ","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n‚ä¢ Eq (CategoryTheory.Monad.MonadicityInternal.unitCofork A).œÄ (G.map (CategoryTheory.Limits.coequalizer.œÄ (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"@[simp]\ntheorem unitCofork_œÄ (A : adj.toMonad.Algebra)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (unitCofork A).œÄ = G.map (coequalizer.œÄ (F.map A.a) (adj.counit.app (F.obj A.A))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nA : adj.toMonad.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).unit.app A).f ((CategoryTheory.Monad.beckCoequalizer A).desc (CategoryTheory.Monad.MonadicityInternal.unitCofork A))","decl":"theorem comparisonAdjunction_unit_f\n    [‚àÄ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))]\n    (A : adj.toMonad.Algebra) :\n    ((comparisonAdjunction adj).unit.app A).f = (beckCoequalizer A).desc (unitCofork A) := by\n  apply Limits.Cofork.IsColimit.hom_ext (beckCoequalizer A)\n  rw [Cofork.IsColimit.œÄ_desc]\n  dsimp only [beckCofork_œÄ, unitCofork_œÄ]\n  rw [comparisonAdjunction_unit_f_aux, ‚Üê adj.homEquiv_naturality_left A.a, coequalizer.condition,\n    adj.homEquiv_naturality_right, adj.homEquiv_unit, Category.assoc]\n  apply adj.right_triangle_components_assoc\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.counitCofork_Œπ_app","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nB : D\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.counitCofork adj B).Œπ.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.CategoryStruct.comp (adj.counit.app (F.obj (G.obj B))) (adj.counit.app B)) (adj.counit.app B) X)","decl":"/-- The cofork which describes the counit of the adjunction: the morphism from the coequalizer of\nthis pair to this morphism is the counit.\n-/\n@[simps!]\ndef counitCofork (B : D) :\n    Cofork (F.map (G.map (adj.counit.app B)))\n      (adj.counit.app (F.obj (G.obj B))) :=\n  Cofork.ofœÄ (adj.counit.app B) (adj.counit_naturality _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.counitCofork_pt","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nB : D\n‚ä¢ Eq (CategoryTheory.Monad.MonadicityInternal.counitCofork adj B).pt B","decl":"/-- The cofork which describes the counit of the adjunction: the morphism from the coequalizer of\nthis pair to this morphism is the counit.\n-/\n@[simps!]\ndef counitCofork (B : D) :\n    Cofork (F.map (G.map (adj.counit.app B)))\n      (adj.counit.app (F.obj (G.obj B))) :=\n  Cofork.ofœÄ (adj.counit.app B) (adj.counit_naturality _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.instHasColimitWalkingParallelPairParallelPairMapAppCounitObjOfHasCoequalizerAA","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nB : D\n‚ä¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B))))","decl":"instance\n    [‚àÄ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))]\n    (B : D) : HasColimit (parallelPair\n      (F.map (G.map (NatTrans.app adj.counit B)))\n      (NatTrans.app adj.counit (F.obj (G.obj B)))) :=\n  inferInstanceAs <| HasCoequalizer\n    (F.map ((comparison adj).obj B).a)\n    (adj.counit.app (F.obj ((comparison adj).obj B).A))\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_counit_app","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nB : D\n‚ä¢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).counit.app B) (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B)))) (CategoryTheory.Monad.MonadicityInternal.counitCofork adj B))","decl":"theorem comparisonAdjunction_counit_app\n    [‚àÄ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] (B : D) :\n    (comparisonAdjunction adj).counit.app B = colimit.desc _ (counitCofork adj B) := by\n  apply coequalizer.hom_ext\n  change\n    coequalizer.œÄ _ _ ‚â´ coequalizer.desc ((adj.homEquiv _ B).symm (ùüô _)) _ =\n      coequalizer.œÄ _ _ ‚â´ coequalizer.desc _ _\n  simp [Adjunction.homEquiv_counit]\n\n"}
{"name":"CategoryTheory.Monad.HasCoequalizerOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.HasCoequalizerOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst‚úù : G.IsSplitPair f g\n‚ä¢ CategoryTheory.Limits.HasCoequalizer f g","decl":"class HasCoequalizerOfIsSplitPair (G : D ‚•§ C) : Prop where\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g], HasCoequalizer f g\n\n-- Porting note: cannot find synth order\n-- instance {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g] [HasCoequalizerOfIsSplitPair G] :\n--     HasCoequalizer f g := HasCoequalizerOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instHasCoequalizerMapAAppCounitObjAOfHasCoequalizerOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Monad.HasCoequalizerOfIsSplitPair G\nA : adj.toMonad.Algebra\n‚ä¢ CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"instance [HasCoequalizerOfIsSplitPair G] : ‚àÄ (A : Algebra adj.toMonad),\n    HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A)) :=\n  fun _ => HasCoequalizerOfIsSplitPair.out G _ _\n\n-- Porting note: added these to replace parametric instances https://github.com/leanprover/lean4/issues/2311\n-- [‚àÄ ‚¶ÉA B‚¶Ñ (f g : A ‚ü∂ B) [G.IsSplitPair f g], PreservesColimit (parallelPair f g) G]\n"}
{"name":"CategoryTheory.Monad.PreservesColimitOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst‚úù : G.IsSplitPair f g\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class PreservesColimitOfIsSplitPair (G : D ‚•§ C) where\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g], PreservesColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairOfIsSplitPairOfPreservesColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst‚úù¬π : G.IsSplitPair f g\ninst‚úù : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g] [PreservesColimitOfIsSplitPair G] :\n    PreservesColimit (parallelPair f g) G := PreservesColimitOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfPreservesColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\nA : adj.toMonad.Algebra\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A))) G","decl":"instance [PreservesColimitOfIsSplitPair G] : ‚àÄ (A : Algebra adj.toMonad),\n   PreservesColimit (parallelPair (F.map A.a)\n      (NatTrans.app adj.counit (F.obj A.A))) G :=\n  fun _ => PreservesColimitOfIsSplitPair.out _ _\n\n-- Porting note: added these to replace parametric instances https://github.com/leanprover/lean4/issues/2311\n-- [‚àÄ ‚¶ÉA B‚¶Ñ (f g : A ‚ü∂ B) [G.IsSplitPair f g], ReflectsColimit (parallelPair f g) G] :\n"}
{"name":"CategoryTheory.Monad.ReflectsColimitOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst‚úù : G.IsSplitPair f g\n‚ä¢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class ReflectsColimitOfIsSplitPair (G : D ‚•§ C) where\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g], ReflectsColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instReflectsColimitWalkingParallelPairParallelPairOfIsSplitPairOfReflectsColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst‚úù¬π : G.IsSplitPair f g\ninst‚úù : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\n‚ä¢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ‚ü∂ B) [G.IsSplitPair f g] [ReflectsColimitOfIsSplitPair G] :\n    ReflectsColimit (parallelPair f g) G := ReflectsColimitOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instReflectsColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfReflectsColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\nA : adj.toMonad.Algebra\n‚ä¢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A))) G","decl":"instance [ReflectsColimitOfIsSplitPair G] : ‚àÄ (A : Algebra adj.toMonad),\n    ReflectsColimit (parallelPair (F.map A.a)\n      (NatTrans.app adj.counit (F.obj A.A))) G :=\n  fun _ => ReflectsColimitOfIsSplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Monad.PreservesColimitOfIsReflexivePair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class PreservesColimitOfIsReflexivePair (G : C ‚•§ D) where\n  out : ‚àÄ ‚¶ÉA B‚¶Ñ (f g : A ‚ü∂ B) [IsReflexivePair f g], PreservesColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairOfIsReflexivePairOfPreservesColimitOfIsReflexivePair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst‚úù¬π : CategoryTheory.IsReflexivePair f g\ninst‚úù : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ‚ü∂ B) [IsReflexivePair f g] [PreservesColimitOfIsReflexivePair G] :\n  PreservesColimit (parallelPair f g) G := PreservesColimitOfIsReflexivePair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfPreservesColimitOfIsReflexivePair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\nX : adj.toMonad.Algebra\n‚ä¢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair (F.map X.a) (adj.counit.app (F.obj X.A))) G","decl":"instance [PreservesColimitOfIsReflexivePair G] : ‚àÄ X : Algebra adj.toMonad,\n    PreservesColimit (parallelPair (F.map X.a)\n      (NatTrans.app adj.counit (F.obj X.A))) G :=\n fun _ => PreservesColimitOfIsReflexivePair.out _ _\n\n"}
