{"name":"CategoryTheory.Monad.MonadicityInternal.main_pair_reflexive","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\n⊢ CategoryTheory.IsReflexivePair (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"/-- The \"main pair\" for an algebra `(A, α)` is the pair of morphisms `(F α, ε_FA)`. It is always a\nreflexive pair, and will be used to construct the left adjoint to the comparison functor and show it\nis an equivalence.\n-/\ninstance main_pair_reflexive (A : adj.toMonad.Algebra) :\n    IsReflexivePair (F.map A.a) (adj.counit.app (F.obj A.A)) := by\n  apply IsReflexivePair.mk' (F.map (adj.unit.app _)) _ _\n  · rw [← F.map_comp, ← F.map_id]\n    exact congr_arg F.map A.unit\n  · rw [adj.left_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.main_pair_G_split","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\n⊢ G.IsSplitPair (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"/-- The \"main pair\" for an algebra `(A, α)` is the pair of morphisms `(F α, ε_FA)`. It is always a\n`G`-split pair, and will be used to construct the left adjoint to the comparison functor and show it\nis an equivalence.\n-/\ninstance main_pair_G_split (A : adj.toMonad.Algebra) :\n    G.IsSplitPair (F.map A.a)\n      (adj.counit.app (F.obj A.A)) where\n  splittable := ⟨_, _, ⟨beckSplitCoequalizer A⟩⟩\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv_apply_f","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\nB : D\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\na✝ : Quiver.Hom (CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointObj adj A) B\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv adj A B) a✝).f ((adj.homEquiv A.A B) ↑((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A)))) B) a✝))","decl":"/--\nWe have a bijection of homsets which will be used to construct the left adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonLeftAdjointHomEquiv (A : adj.toMonad.Algebra) (B : D)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (comparisonLeftAdjointObj adj A ⟶ B) ≃ (A ⟶ (comparison adj).obj B) :=\n  calc\n    (comparisonLeftAdjointObj adj A ⟶ B) ≃ { f : F.obj A.A ⟶ B // _ } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) B\n    _ ≃ { g : A.A ⟶ G.obj B // G.map (F.map g) ≫ G.map (adj.counit.app B) = A.a ≫ g } := by\n      refine (adj.homEquiv _ _).subtypeEquiv ?_\n      intro f\n      rw [← (adj.homEquiv _ _).injective.eq_iff, Adjunction.homEquiv_naturality_left,\n        adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp]\n      dsimp\n      rw [adj.right_triangle_components_assoc, ← G.map_comp, F.map_comp, Category.assoc,\n        adj.counit_naturality, adj.left_triangle_components_assoc]\n      apply eq_comm\n    _ ≃ (A ⟶ (comparison adj).obj B) :=\n      { toFun := fun g =>\n          { f := _\n            h := g.prop }\n        invFun := fun f => ⟨f.f, f.h⟩\n        left_inv := fun g => by ext; rfl\n        right_inv := fun f => by ext; rfl }\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv_symm_apply","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\nB : D\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\na✝ : Quiver.Hom A ((CategoryTheory.Monad.comparison adj).obj B)\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonLeftAdjointHomEquiv adj A B).symm a✝) ((CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A)))) B).symm ⟨(adj.homEquiv A.A B).symm a✝.f, ⋯⟩)","decl":"/--\nWe have a bijection of homsets which will be used to construct the left adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonLeftAdjointHomEquiv (A : adj.toMonad.Algebra) (B : D)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (comparisonLeftAdjointObj adj A ⟶ B) ≃ (A ⟶ (comparison adj).obj B) :=\n  calc\n    (comparisonLeftAdjointObj adj A ⟶ B) ≃ { f : F.obj A.A ⟶ B // _ } :=\n      Cofork.IsColimit.homIso (colimit.isColimit _) B\n    _ ≃ { g : A.A ⟶ G.obj B // G.map (F.map g) ≫ G.map (adj.counit.app B) = A.a ≫ g } := by\n      refine (adj.homEquiv _ _).subtypeEquiv ?_\n      intro f\n      rw [← (adj.homEquiv _ _).injective.eq_iff, Adjunction.homEquiv_naturality_left,\n        adj.homEquiv_unit, adj.homEquiv_unit, G.map_comp]\n      dsimp\n      rw [adj.right_triangle_components_assoc, ← G.map_comp, F.map_comp, Category.assoc,\n        adj.counit_naturality, adj.left_triangle_components_assoc]\n      apply eq_comm\n    _ ≃ (A ⟶ (comparison adj).obj B) :=\n      { toFun := fun g =>\n          { f := _\n            h := g.prop }\n        invFun := fun f => ⟨f.f, f.h⟩\n        left_inv := fun g => by ext; rfl\n        right_inv := fun f => by ext; rfl }\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_counit","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n⊢ Eq (CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).counit { app := fun Y => (CategoryTheory.Limits.Cofork.IsColimit.homIso (CategoryTheory.Limits.colimit.isColimit (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app Y))) (adj.counit.app (F.obj (G.obj Y))))) Y).symm ⟨(adj.homEquiv (G.obj Y) Y).symm (CategoryTheory.CategoryStruct.id (G.obj Y)), ⋯⟩, naturality := ⋯ }","decl":"/-- Provided we have the appropriate coequalizers, we have an adjunction to the comparison functor.\n-/\n@[simps! counit]\ndef comparisonAdjunction\n    [∀ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))] :\n    leftAdjointComparison adj ⊣ comparison adj :=\n  Adjunction.adjunctionOfEquivLeft _ _\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f_aux","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nA : adj.toMonad.Algebra\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).unit.app A).f ((adj.homEquiv A.A (CategoryTheory.Limits.coequalizer (F.map A.a) (adj.counit.app (F.obj A.A)))) (CategoryTheory.Limits.coequalizer.π (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"theorem comparisonAdjunction_unit_f_aux\n    [∀ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))]\n    (A : adj.toMonad.Algebra) :\n    ((comparisonAdjunction adj).unit.app A).f =\n      adj.homEquiv A.A _\n        (coequalizer.π (F.map A.a) (adj.counit.app (F.obj A.A))) :=\n  congr_arg (adj.homEquiv _ _) (Category.comp_id _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.unitCofork_pt","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n⊢ Eq (CategoryTheory.Monad.MonadicityInternal.unitCofork A).pt (G.obj (CategoryTheory.Limits.coequalizer (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"/-- This is a cofork which is helpful for establishing monadicity: the morphism from the Beck\ncoequalizer to this cofork is the unit for the adjunction on the comparison functor.\n-/\n@[simps! pt]\ndef unitCofork (A : adj.toMonad.Algebra)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    Cofork (G.map (F.map A.a)) (G.map (adj.counit.app (F.obj A.A))) :=\n  Cofork.ofπ (G.map (coequalizer.π (F.map A.a) (adj.counit.app (F.obj A.A))))\n    (by rw [← G.map_comp, coequalizer.condition, G.map_comp])\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.unitCofork_π","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nA : adj.toMonad.Algebra\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\n⊢ Eq (CategoryTheory.Monad.MonadicityInternal.unitCofork A).π (G.map (CategoryTheory.Limits.coequalizer.π (F.map A.a) (adj.counit.app (F.obj A.A))))","decl":"@[simp]\ntheorem unitCofork_π (A : adj.toMonad.Algebra)\n    [HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] :\n    (unitCofork A).π = G.map (coequalizer.π (F.map A.a) (adj.counit.app (F.obj A.A))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_unit_f","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nA : adj.toMonad.Algebra\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).unit.app A).f ((CategoryTheory.Monad.beckCoequalizer A).desc (CategoryTheory.Monad.MonadicityInternal.unitCofork A))","decl":"theorem comparisonAdjunction_unit_f\n    [∀ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A))]\n    (A : adj.toMonad.Algebra) :\n    ((comparisonAdjunction adj).unit.app A).f = (beckCoequalizer A).desc (unitCofork A) := by\n  apply Limits.Cofork.IsColimit.hom_ext (beckCoequalizer A)\n  rw [Cofork.IsColimit.π_desc]\n  dsimp only [beckCofork_π, unitCofork_π]\n  rw [comparisonAdjunction_unit_f_aux, ← adj.homEquiv_naturality_left A.a, coequalizer.condition,\n    adj.homEquiv_naturality_right, adj.homEquiv_unit, Category.assoc]\n  apply adj.right_triangle_components_assoc\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.counitCofork_ι_app","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nB : D\nX : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.counitCofork adj B).ι.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.CategoryStruct.comp (adj.counit.app (F.obj (G.obj B))) (adj.counit.app B)) (adj.counit.app B) X)","decl":"/-- The cofork which describes the counit of the adjunction: the morphism from the coequalizer of\nthis pair to this morphism is the counit.\n-/\n@[simps!]\ndef counitCofork (B : D) :\n    Cofork (F.map (G.map (adj.counit.app B)))\n      (adj.counit.app (F.obj (G.obj B))) :=\n  Cofork.ofπ (adj.counit.app B) (adj.counit_naturality _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.counitCofork_pt","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\nB : D\n⊢ Eq (CategoryTheory.Monad.MonadicityInternal.counitCofork adj B).pt B","decl":"/-- The cofork which describes the counit of the adjunction: the morphism from the coequalizer of\nthis pair to this morphism is the counit.\n-/\n@[simps!]\ndef counitCofork (B : D) :\n    Cofork (F.map (G.map (adj.counit.app B)))\n      (adj.counit.app (F.obj (G.obj B))) :=\n  Cofork.ofπ (adj.counit.app B) (adj.counit_naturality _)\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.instHasColimitWalkingParallelPairParallelPairMapAppCounitObjOfHasCoequalizerAA","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nB : D\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B))))","decl":"instance\n    [∀ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))]\n    (B : D) : HasColimit (parallelPair\n      (F.map (G.map (NatTrans.app adj.counit B)))\n      (NatTrans.app adj.counit (F.obj (G.obj B)))) :=\n  inferInstanceAs <| HasCoequalizer\n    (F.map ((comparison adj).obj B).a)\n    (adj.counit.app (F.obj ((comparison adj).obj B).A))\n\n"}
{"name":"CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction_counit_app","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toMonad.Algebra), CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))\nB : D\n⊢ Eq ((CategoryTheory.Monad.MonadicityInternal.comparisonAdjunction adj).counit.app B) (CategoryTheory.Limits.colimit.desc (CategoryTheory.Limits.parallelPair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B)))) (CategoryTheory.Monad.MonadicityInternal.counitCofork adj B))","decl":"theorem comparisonAdjunction_counit_app\n    [∀ A : adj.toMonad.Algebra, HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))] (B : D) :\n    (comparisonAdjunction adj).counit.app B = colimit.desc _ (counitCofork adj B) := by\n  apply coequalizer.hom_ext\n  change\n    coequalizer.π _ _ ≫ coequalizer.desc ((adj.homEquiv _ B).symm (𝟙 _)) _ =\n      coequalizer.π _ _ ≫ coequalizer.desc _ _\n  simp [Adjunction.homEquiv_counit]\n\n"}
{"name":"CategoryTheory.Monad.HasCoequalizerOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.HasCoequalizerOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst✝ : G.IsSplitPair f g\n⊢ CategoryTheory.Limits.HasCoequalizer f g","decl":"class HasCoequalizerOfIsSplitPair (G : D ⥤ C) : Prop where\n  out : ∀ {A B} (f g : A ⟶ B) [G.IsSplitPair f g], HasCoequalizer f g\n\n-- Porting note: cannot find synth order\n-- instance {A B} (f g : A ⟶ B) [G.IsSplitPair f g] [HasCoequalizerOfIsSplitPair G] :\n--     HasCoequalizer f g := HasCoequalizerOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instHasCoequalizerMapAAppCounitObjAOfHasCoequalizerOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Monad.HasCoequalizerOfIsSplitPair G\nA : adj.toMonad.Algebra\n⊢ CategoryTheory.Limits.HasCoequalizer (F.map A.a) (adj.counit.app (F.obj A.A))","decl":"instance [HasCoequalizerOfIsSplitPair G] : ∀ (A : Algebra adj.toMonad),\n    HasCoequalizer (F.map A.a)\n      (adj.counit.app (F.obj A.A)) :=\n  fun _ => HasCoequalizerOfIsSplitPair.out G _ _\n\n-- Porting note: added these to replace parametric instances https://github.com/leanprover/lean4/issues/2311\n-- [∀ ⦃A B⦄ (f g : A ⟶ B) [G.IsSplitPair f g], PreservesColimit (parallelPair f g) G]\n"}
{"name":"CategoryTheory.Monad.PreservesColimitOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst✝ : G.IsSplitPair f g\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class PreservesColimitOfIsSplitPair (G : D ⥤ C) where\n  out : ∀ {A B} (f g : A ⟶ B) [G.IsSplitPair f g], PreservesColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairOfIsSplitPairOfPreservesColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst✝¹ : G.IsSplitPair f g\ninst✝ : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ⟶ B) [G.IsSplitPair f g] [PreservesColimitOfIsSplitPair G] :\n    PreservesColimit (parallelPair f g) G := PreservesColimitOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfPreservesColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Monad.PreservesColimitOfIsSplitPair G\nA : adj.toMonad.Algebra\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A))) G","decl":"instance [PreservesColimitOfIsSplitPair G] : ∀ (A : Algebra adj.toMonad),\n   PreservesColimit (parallelPair (F.map A.a)\n      (NatTrans.app adj.counit (F.obj A.A))) G :=\n  fun _ => PreservesColimitOfIsSplitPair.out _ _\n\n-- Porting note: added these to replace parametric instances https://github.com/leanprover/lean4/issues/2311\n-- [∀ ⦃A B⦄ (f g : A ⟶ B) [G.IsSplitPair f g], ReflectsColimit (parallelPair f g) G] :\n"}
{"name":"CategoryTheory.Monad.ReflectsColimitOfIsSplitPair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nself : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\nA B : D\nf g : Quiver.Hom A B\ninst✝ : G.IsSplitPair f g\n⊢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class ReflectsColimitOfIsSplitPair (G : D ⥤ C) where\n  out : ∀ {A B} (f g : A ⟶ B) [G.IsSplitPair f g], ReflectsColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instReflectsColimitWalkingParallelPairParallelPairOfIsSplitPairOfReflectsColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst✝¹ : G.IsSplitPair f g\ninst✝ : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\n⊢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ⟶ B) [G.IsSplitPair f g] [ReflectsColimitOfIsSplitPair G] :\n    ReflectsColimit (parallelPair f g) G := ReflectsColimitOfIsSplitPair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instReflectsColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfReflectsColimitOfIsSplitPair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Monad.ReflectsColimitOfIsSplitPair G\nA : adj.toMonad.Algebra\n⊢ CategoryTheory.Limits.ReflectsColimit (CategoryTheory.Limits.parallelPair (F.map A.a) (adj.counit.app (F.obj A.A))) G","decl":"instance [ReflectsColimitOfIsSplitPair G] : ∀ (A : Algebra adj.toMonad),\n    ReflectsColimit (parallelPair (F.map A.a)\n      (NatTrans.app adj.counit (F.obj A.A))) G :=\n  fun _ => ReflectsColimitOfIsSplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Monad.PreservesColimitOfIsReflexivePair.out","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"class PreservesColimitOfIsReflexivePair (G : C ⥤ D) where\n  out : ∀ ⦃A B⦄ (f g : A ⟶ B) [IsReflexivePair f g], PreservesColimit (parallelPair f g) G\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairOfIsReflexivePairOfPreservesColimitOfIsReflexivePair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nA B : D\nf g : Quiver.Hom A B\ninst✝¹ : CategoryTheory.IsReflexivePair f g\ninst✝ : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) G","decl":"instance {A B} (f g : A ⟶ B) [IsReflexivePair f g] [PreservesColimitOfIsReflexivePair G] :\n  PreservesColimit (parallelPair f g) G := PreservesColimitOfIsReflexivePair.out f g\n\n"}
{"name":"CategoryTheory.Monad.instPreservesColimitWalkingParallelPairParallelPairMapAAppCounitObjAOfPreservesColimitOfIsReflexivePair","module":"Mathlib.CategoryTheory.Monad.Monadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nG : CategoryTheory.Functor D C\nF : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Monad.PreservesColimitOfIsReflexivePair G\nX : adj.toMonad.Algebra\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair (F.map X.a) (adj.counit.app (F.obj X.A))) G","decl":"instance [PreservesColimitOfIsReflexivePair G] : ∀ X : Algebra adj.toMonad,\n    PreservesColimit (parallelPair (F.map X.a)\n      (NatTrans.app adj.counit (F.obj X.A))) G :=\n fun _ => PreservesColimitOfIsReflexivePair.out _ _\n\n"}
