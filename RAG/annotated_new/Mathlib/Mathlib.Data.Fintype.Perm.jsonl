{"name":"length_permsOfList","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (permsOfList l).length l.length.factorial","decl":"theorem length_permsOfList : ∀ l : List α, length (permsOfList l) = l.length !\n  | [] => rfl\n  | a :: l => by\n    rw [length_cons, Nat.factorial_succ]\n    simp only [permsOfList, length_append, length_permsOfList, length_flatMap, comp_def,\n     length_map, map_const', sum_replicate, smul_eq_mul, succ_mul]\n    ring\n\n"}
{"name":"mem_permsOfList_of_mem","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nf : Equiv.Perm α\nh : ∀ (x : α), Ne (f x) x → Membership.mem l x\n⊢ Membership.mem (permsOfList l) f","decl":"theorem mem_permsOfList_of_mem {l : List α} {f : Perm α} (h : ∀ x, f x ≠ x → x ∈ l) :\n    f ∈ permsOfList l := by\n  induction l generalizing f with\n  | nil =>\n    -- Porting note: applied `not_mem_nil` because it is no longer true definitionally.\n    simp only [not_mem_nil] at h\n    exact List.mem_singleton.2 (Equiv.ext fun x => Decidable.byContradiction <| h x)\n  | cons a l IH =>\n  by_cases hfa : f a = a\n  · refine mem_append_left _ (IH fun x hx => mem_of_ne_of_mem ?_ (h x hx))\n    rintro rfl\n    exact hx hfa\n  have hfa' : f (f a) ≠ f a := mt (fun h => f.injective h) hfa\n  have : ∀ x : α, (Equiv.swap a (f a) * f) x ≠ x → x ∈ l := by\n    intro x hx\n    have hxa : x ≠ a := by\n      rintro rfl\n      apply hx\n      simp only [mul_apply, swap_apply_right]\n    refine List.mem_of_ne_of_mem hxa (h x fun h => ?_)\n    simp only [mul_apply, swap_apply_def, mul_apply, Ne, apply_eq_iff_eq] at hx\n    split_ifs at hx with h_1\n    exacts [hxa (h.symm.trans h_1), hx h]\n  suffices f ∈ permsOfList l ∨ ∃ b ∈ l, ∃ g ∈ permsOfList l, Equiv.swap a b * g = f by\n    simpa only [permsOfList, exists_prop, List.mem_map, mem_append, List.mem_flatMap]\n  refine or_iff_not_imp_left.2 fun _hfl => ⟨f a, ?_, Equiv.swap a (f a) * f, IH this, ?_⟩\n  · exact mem_of_ne_of_mem hfa (h _ hfa')\n  · rw [← mul_assoc, mul_def (swap a (f a)) (swap a (f a)), swap_swap, ← Perm.one_def, one_mul]\n\n"}
{"name":"mem_of_mem_permsOfList","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nf : Equiv.Perm α\na✝¹ : Membership.mem (permsOfList l) f\nx : α\na✝ : Ne (f x) x\n⊢ Membership.mem l x","decl":"theorem mem_of_mem_permsOfList :\n    -- Porting note: was `∀ {x}` but need to capture the `x`\n    ∀ {l : List α} {f : Perm α}, f ∈ permsOfList l → (x : α ) → f x ≠ x → x ∈ l\n  | [], f, h, heq_iff_eq => by\n    have : f = 1 := by simpa [permsOfList] using h\n    rw [this]; simp\n  | a :: l, f, h, x =>\n    (mem_append.1 h).elim (fun h hx => mem_cons_of_mem _ (mem_of_mem_permsOfList h x hx))\n      fun h hx =>\n      let ⟨y, hy, hy'⟩ := List.mem_flatMap.1 h\n      let ⟨g, hg₁, hg₂⟩ := List.mem_map.1 hy'\n      -- Porting note: Seems like the implicit variable `x` of type `α` is needed.\n      if hxa : x = a then by simp [hxa]\n      else\n        if hxy : x = y then mem_cons_of_mem _ <| by rwa [hxy]\n        else mem_cons_of_mem a <| mem_of_mem_permsOfList hg₁ _ <| by\n              rw [eq_inv_mul_iff_mul_eq.2 hg₂, mul_apply, swap_inv, swap_apply_def]\n              split_ifs <;> [exact Ne.symm hxy; exact Ne.symm hxa; exact hx]\n\n"}
{"name":"mem_permsOfList_iff","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (permsOfList l) f) (∀ {x : α}, Ne (f x) x → Membership.mem l x)","decl":"theorem mem_permsOfList_iff {l : List α} {f : Perm α} :\n    f ∈ permsOfList l ↔ ∀ {x}, f x ≠ x → x ∈ l :=\n  ⟨mem_of_mem_permsOfList, mem_permsOfList_of_mem⟩\n\n"}
{"name":"nodup_permsOfList","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na✝ : l.Nodup\n⊢ (permsOfList l).Nodup","decl":"theorem nodup_permsOfList : ∀ {l : List α}, l.Nodup → (permsOfList l).Nodup\n  | [], _ => by simp [permsOfList]\n  | a :: l, hl => by\n    have hl' : l.Nodup := hl.of_cons\n    have hln' : (permsOfList l).Nodup := nodup_permsOfList hl'\n    have hmeml : ∀ {f : Perm α}, f ∈ permsOfList l → f a = a := fun {f} hf =>\n      not_not.1 (mt (mem_of_mem_permsOfList hf _) (nodup_cons.1 hl).1)\n    rw [permsOfList, List.nodup_append, List.nodup_flatMap, pairwise_iff_getElem]\n    refine ⟨?_, ⟨⟨?_,?_ ⟩, ?_⟩⟩\n    · exact hln'\n    · exact fun _ _ => hln'.map fun _ _ => mul_left_cancel\n    · intros i j hi hj hij x hx₁ hx₂\n      let ⟨f, hf⟩ := List.mem_map.1 hx₁\n      let ⟨g, hg⟩ := List.mem_map.1 hx₂\n      have hix : x a = l[i] := by\n        rw [← hf.2, mul_apply, hmeml hf.1, swap_apply_left]\n      have hiy : x a = l[j] := by\n        rw [← hg.2, mul_apply, hmeml hg.1, swap_apply_left]\n      have hieqj : i = j := hl'.getElem_inj_iff.1 (hix.symm.trans hiy)\n      exact absurd hieqj (_root_.ne_of_lt hij)\n    · intros f hf₁ hf₂\n      let ⟨x, hx, hx'⟩ := List.mem_flatMap.1 hf₂\n      let ⟨g, hg⟩ := List.mem_map.1 hx'\n      have hgxa : g⁻¹ x = a := f.injective <| by rw [hmeml hf₁, ← hg.2]; simp\n      have hxa : x ≠ a := fun h => (List.nodup_cons.1 hl).1 (h ▸ hx)\n      exact (List.nodup_cons.1 hl).1 <|\n          hgxa ▸ mem_of_mem_permsOfList hg.1 _ (by rwa [apply_inv_self, hgxa])\n\n"}
{"name":"mem_perms_of_finset_iff","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (permsOfFinset s) f) (∀ {x : α}, Ne (f x) x → Membership.mem s x)","decl":"theorem mem_perms_of_finset_iff :\n    ∀ {s : Finset α} {f : Perm α}, f ∈ permsOfFinset s ↔ ∀ {x}, f x ≠ x → x ∈ s := by\n  rintro ⟨⟨l⟩, hs⟩ f; exact mem_permsOfList_iff\n\n"}
{"name":"card_perms_of_finset","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (permsOfFinset s).card s.card.factorial","decl":"theorem card_perms_of_finset : ∀ s : Finset α, #(permsOfFinset s) = (#s)! := by\n  rintro ⟨⟨l⟩, hs⟩; exact length_permsOfList l\n\n"}
{"name":"Fintype.card_perm","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Equiv.Perm α)) (Fintype.card α).factorial","decl":"theorem Fintype.card_perm [Fintype α] : Fintype.card (Perm α) = (Fintype.card α)! :=\n  Subsingleton.elim (@fintypePerm α _ _) (@Equiv.instFintype α α _ _ _ _) ▸ card_perms_of_finset _\n\n"}
{"name":"Fintype.card_equiv","module":"Mathlib.Data.Fintype.Perm","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : DecidableEq α\ninst✝² : DecidableEq β\ninst✝¹ : Fintype α\ninst✝ : Fintype β\ne : Equiv α β\n⊢ Eq (Fintype.card (Equiv α β)) (Fintype.card α).factorial","decl":"theorem Fintype.card_equiv [Fintype α] [Fintype β] (e : α ≃ β) :\n    Fintype.card (α ≃ β) = (Fintype.card α)! :=\n  Fintype.card_congr (equivCongr (Equiv.refl α) e) ▸ Fintype.card_perm\n"}
