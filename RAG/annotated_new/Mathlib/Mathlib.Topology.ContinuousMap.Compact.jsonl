{"name":"ContinuousMap.equivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (⇑(ContinuousMap.equivBoundedOfCompact α β)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `α` is compact, the bounded continuous maps `α →ᵇ β` are\nequivalent to `C(α, β)`.\n-/\n@[simps (config := .asFn)]\ndef equivBoundedOfCompact : C(α, β) ≃ (α →ᵇ β) :=\n  ⟨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by\n    ext\n    rfl, fun f => by\n    ext\n    rfl⟩\n\n"}
{"name":"ContinuousMap.equivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (⇑(ContinuousMap.equivBoundedOfCompact α β).symm) BoundedContinuousFunction.toContinuousMap","decl":"/-- When `α` is compact, the bounded continuous maps `α →ᵇ β` are\nequivalent to `C(α, β)`.\n-/\n@[simps (config := .asFn)]\ndef equivBoundedOfCompact : C(α, β) ≃ (α →ᵇ β) :=\n  ⟨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by\n    ext\n    rfl, fun f => by\n    ext\n    rfl⟩\n\n"}
{"name":"ContinuousMap.isUniformInducing_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ IsUniformInducing ⇑(ContinuousMap.equivBoundedOfCompact α β)","decl":"theorem isUniformInducing_equivBoundedOfCompact : IsUniformInducing (equivBoundedOfCompact α β) :=\n  IsUniformInducing.mk'\n    (by\n      simp only [hasBasis_compactConvergenceUniformity.mem_iff, uniformity_basis_dist_le.mem_iff]\n      exact fun s =>\n        ⟨fun ⟨⟨a, b⟩, ⟨_, ⟨ε, hε, hb⟩⟩, hs⟩ =>\n          ⟨{ p | ∀ x, (p.1 x, p.2 x) ∈ b }, ⟨ε, hε, fun _ h x => hb ((dist_le hε.le).mp h x)⟩,\n            fun f g h => hs fun x _ => h x⟩,\n          fun ⟨_, ⟨ε, hε, ht⟩, hs⟩ =>\n          ⟨⟨Set.univ, { p | dist p.1 p.2 ≤ ε }⟩, ⟨isCompact_univ, ⟨ε, hε, fun _ h => h⟩⟩,\n            fun ⟨f, g⟩ h => hs _ _ (ht ((dist_le hε.le).mpr fun x => h x (mem_univ x)))⟩⟩)\n\n"}
{"name":"ContinuousMap.uniformInducing_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ IsUniformInducing ⇑(ContinuousMap.equivBoundedOfCompact α β)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_equivBoundedOfCompact := isUniformInducing_equivBoundedOfCompact\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ IsUniformEmbedding ⇑(ContinuousMap.equivBoundedOfCompact α β)","decl":"theorem isUniformEmbedding_equivBoundedOfCompact : IsUniformEmbedding (equivBoundedOfCompact α β) :=\n  { isUniformInducing_equivBoundedOfCompact α β with\n    injective := (equivBoundedOfCompact α β).injective }\n\n"}
{"name":"ContinuousMap.uniformEmbedding_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ IsUniformEmbedding ⇑(ContinuousMap.equivBoundedOfCompact α β)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_equivBoundedOfCompact := isUniformEmbedding_equivBoundedOfCompact\n\n"}
{"name":"ContinuousMap.addEquivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\n⊢ Eq (⇑(ContinuousMap.addEquivBoundedOfCompact α β)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `α` is compact, the bounded continuous maps `α →ᵇ 𝕜` are\nadditively equivalent to `C(α, 𝕜)`.\n-/\n@[simps! (config := .asFn) apply symm_apply]\ndef addEquivBoundedOfCompact [AddMonoid β] [LipschitzAdd β] : C(α, β) ≃+ (α →ᵇ β) :=\n  ({ toContinuousMapAddHom α β, (equivBoundedOfCompact α β).symm with } : (α →ᵇ β) ≃+ C(α, β)).symm\n\n"}
{"name":"ContinuousMap.addEquivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\n⊢ Eq ⇑(ContinuousMap.addEquivBoundedOfCompact α β).symm ⇑(BoundedContinuousFunction.toContinuousMapAddHom α β)","decl":"/-- When `α` is compact, the bounded continuous maps `α →ᵇ 𝕜` are\nadditively equivalent to `C(α, 𝕜)`.\n-/\n@[simps! (config := .asFn) apply symm_apply]\ndef addEquivBoundedOfCompact [AddMonoid β] [LipschitzAdd β] : C(α, β) ≃+ (α →ᵇ β) :=\n  ({ toContinuousMapAddHom α β, (equivBoundedOfCompact α β).symm with } : (α →ᵇ β) ≃+ C(α, β)).symm\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (⇑(ContinuousMap.isometryEquivBoundedOfCompact α β).symm) BoundedContinuousFunction.toContinuousMap","decl":"/-- When `α` is compact, and `β` is a metric space, the bounded continuous maps `α →ᵇ β` are\nisometric to `C(α, β)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(α, β) ≃ᵢ (α →ᵇ β) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact α β\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_toEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (ContinuousMap.isometryEquivBoundedOfCompact α β).toEquiv (ContinuousMap.equivBoundedOfCompact α β)","decl":"/-- When `α` is compact, and `β` is a metric space, the bounded continuous maps `α →ᵇ β` are\nisometric to `C(α, β)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(α, β) ≃ᵢ (α →ᵇ β) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact α β\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (⇑(ContinuousMap.isometryEquivBoundedOfCompact α β)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `α` is compact, and `β` is a metric space, the bounded continuous maps `α →ᵇ β` are\nisometric to `C(α, β)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(α, β) ≃ᵢ (α →ᵇ β) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact α β\n\n"}
{"name":"BoundedContinuousFunction.dist_mkOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf g : ContinuousMap α β\n⊢ Eq (Dist.dist (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g)) (Dist.dist f g)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_mkOfCompact (f g : C(α, β)) :\n    dist (mkOfCompact f) (mkOfCompact g) = dist f g :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.dist_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf g : BoundedContinuousFunction α β\n⊢ Eq (Dist.dist f.toContinuousMap g.toContinuousMap) (Dist.dist f g)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_toContinuousMap (f g : α →ᵇ β) :\n    dist f.toContinuousMap g.toContinuousMap = dist f g :=\n  rfl\n\n"}
{"name":"ContinuousMap.dist_apply_le_dist","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf g : ContinuousMap α β\nx : α\n⊢ LE.le (Dist.dist (f x) (g x)) (Dist.dist f g)","decl":"/-- The pointwise distance is controlled by the distance between functions, by definition. -/\ntheorem dist_apply_le_dist (x : α) : dist (f x) (g x) ≤ dist f g := by\n  simp only [← dist_mkOfCompact, dist_coe_le_dist, ← mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_le","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf g : ContinuousMap α β\nC : Real\nC0 : LE.le 0 C\n⊢ Iff (LE.le (Dist.dist f g) C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)","decl":"/-- The distance between two functions is controlled by the supremum of the pointwise distances. -/\ntheorem dist_le (C0 : (0 : ℝ) ≤ C) : dist f g ≤ C ↔ ∀ x : α, dist (f x) (g x) ≤ C := by\n  simp only [← dist_mkOfCompact, BoundedContinuousFunction.dist_le C0, mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_le_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : ContinuousMap α β\nC : Real\ninst✝ : Nonempty α\n⊢ Iff (LE.le (Dist.dist f g) C) (∀ (x : α), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_le_iff_of_nonempty [Nonempty α] : dist f g ≤ C ↔ ∀ x, dist (f x) (g x) ≤ C := by\n  simp only [← dist_mkOfCompact, BoundedContinuousFunction.dist_le_iff_of_nonempty,\n    mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : ContinuousMap α β\nC : Real\ninst✝ : Nonempty α\n⊢ Iff (LT.lt (Dist.dist f g) C) (∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_nonempty [Nonempty α] : dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C := by\n  simp only [← dist_mkOfCompact, dist_lt_iff_of_nonempty_compact, mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_lt_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : PseudoMetricSpace β\nf g : ContinuousMap α β\nC : Real\ninst✝ : Nonempty α\nw : ∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C\n⊢ LT.lt (Dist.dist f g) C","decl":"theorem dist_lt_of_nonempty [Nonempty α] (w : ∀ x : α, dist (f x) (g x) < C) : dist f g < C :=\n  dist_lt_iff_of_nonempty.2 w\n\n"}
{"name":"ContinuousMap.dist_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf g : ContinuousMap α β\nC : Real\nC0 : LT.lt 0 C\n⊢ Iff (LT.lt (Dist.dist f g) C) (∀ (x : α), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff (C0 : (0 : ℝ) < C) : dist f g < C ↔ ∀ x : α, dist (f x) (g x) < C := by\n  rw [← dist_mkOfCompact, dist_lt_iff_of_compact C0]\n  simp only [mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.instBoundedSMul","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁷ : TopologicalSpace α\ninst✝⁶ : CompactSpace α\ninst✝⁵ : PseudoMetricSpace β\nR : Type u_4\ninst✝⁴ : Zero R\ninst✝³ : Zero β\ninst✝² : PseudoMetricSpace R\ninst✝¹ : SMul R β\ninst✝ : BoundedSMul R β\n⊢ BoundedSMul R (ContinuousMap α β)","decl":"instance {R} [Zero R] [Zero β] [PseudoMetricSpace R] [SMul R β] [BoundedSMul R β] :\n    BoundedSMul R C(α, β) where\n  dist_smul_pair' r f g := by\n    simpa only [← dist_mkOfCompact] using dist_smul_pair r (mkOfCompact f) (mkOfCompact g)\n  dist_pair_smul' r₁ r₂ f := by\n    simpa only [← dist_mkOfCompact] using dist_pair_smul r₁ r₂ (mkOfCompact f)\n\n"}
{"name":"BoundedContinuousFunction.norm_mkOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\n⊢ Eq (Norm.norm (BoundedContinuousFunction.mkOfCompact f)) (Norm.norm f)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_mkOfCompact (f : C(α, E)) : ‖mkOfCompact f‖ = ‖f‖ :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_toContinuousMap_eq","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : BoundedContinuousFunction α E\n⊢ Eq (Norm.norm f.toContinuousMap) (Norm.norm f)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_toContinuousMap_eq (f : α →ᵇ E) :\n    ‖f.toContinuousMap‖ = ‖f‖ :=\n  rfl\n\n"}
{"name":"ContinuousMap.instNormOneClassOfNonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : CompactSpace α\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : Nonempty α\ninst✝¹ : One E\ninst✝ : NormOneClass E\n⊢ NormOneClass (ContinuousMap α E)","decl":"instance [Nonempty α] [One E] [NormOneClass E] : NormOneClass C(α, E) where\n  norm_one := by simp only [← norm_mkOfCompact, mkOfCompact_one, norm_one]\n\n"}
{"name":"ContinuousMap.norm_coe_le_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\nx : α\n⊢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"theorem norm_coe_le_norm (x : α) : ‖f x‖ ≤ ‖f‖ :=\n  (mkOfCompact f).norm_coe_le_norm x\n\n"}
{"name":"ContinuousMap.dist_le_two_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\nx y : α\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 (Norm.norm f))","decl":"/-- Distance between the images of any two points is at most twice the norm of the function. -/\ntheorem dist_le_two_norm (x y : α) : dist (f x) (f y) ≤ 2 * ‖f‖ :=\n  (mkOfCompact f).dist_le_two_norm x y\n\n"}
{"name":"ContinuousMap.norm_le","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\nC : Real\nC0 : LE.le 0 C\n⊢ Iff (LE.le (Norm.norm f) C) (∀ (x : α), LE.le (Norm.norm (f x)) C)","decl":"/-- The norm of a function is controlled by the supremum of the pointwise norms. -/\ntheorem norm_le {C : ℝ} (C0 : (0 : ℝ) ≤ C) : ‖f‖ ≤ C ↔ ∀ x : α, ‖f x‖ ≤ C :=\n  @BoundedContinuousFunction.norm_le _ _ _ _ (mkOfCompact f) _ C0\n\n"}
{"name":"ContinuousMap.norm_le_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : SeminormedAddCommGroup E\nf : ContinuousMap α E\ninst✝ : Nonempty α\nM : Real\n⊢ Iff (LE.le (Norm.norm f) M) (∀ (x : α), LE.le (Norm.norm (f x)) M)","decl":"theorem norm_le_of_nonempty [Nonempty α] {M : ℝ} : ‖f‖ ≤ M ↔ ∀ x, ‖f x‖ ≤ M :=\n  @BoundedContinuousFunction.norm_le_of_nonempty _ _ _ _ _ (mkOfCompact f) _\n\n"}
{"name":"ContinuousMap.norm_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\nM : Real\nM0 : LT.lt 0 M\n⊢ Iff (LT.lt (Norm.norm f) M) (∀ (x : α), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff {M : ℝ} (M0 : 0 < M) : ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=\n  @BoundedContinuousFunction.norm_lt_iff_of_compact _ _ _ _ _ (mkOfCompact f) _ M0\n\n"}
{"name":"ContinuousMap.nnnorm_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\nM : NNReal\nM0 : LT.lt 0 M\n⊢ Iff (LT.lt (NNNorm.nnnorm f) M) (∀ (x : α), LT.lt (NNNorm.nnnorm (f x)) M)","decl":"theorem nnnorm_lt_iff {M : ℝ≥0} (M0 : 0 < M) : ‖f‖₊ < M ↔ ∀ x : α, ‖f x‖₊ < M :=\n  f.norm_lt_iff M0\n\n"}
{"name":"ContinuousMap.norm_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : SeminormedAddCommGroup E\nf : ContinuousMap α E\ninst✝ : Nonempty α\nM : Real\n⊢ Iff (LT.lt (Norm.norm f) M) (∀ (x : α), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_nonempty [Nonempty α] {M : ℝ} : ‖f‖ < M ↔ ∀ x, ‖f x‖ < M :=\n  @BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact _ _ _ _ _ _ (mkOfCompact f) _\n\n"}
{"name":"ContinuousMap.nnnorm_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : CompactSpace α\ninst✝¹ : SeminormedAddCommGroup E\nf : ContinuousMap α E\ninst✝ : Nonempty α\nM : NNReal\n⊢ Iff (LT.lt (NNNorm.nnnorm f) M) (∀ (x : α), LT.lt (NNNorm.nnnorm (f x)) M)","decl":"theorem nnnorm_lt_iff_of_nonempty [Nonempty α] {M : ℝ≥0} : ‖f‖₊ < M ↔ ∀ x, ‖f x‖₊ < M :=\n  f.norm_lt_iff_of_nonempty\n\n"}
{"name":"ContinuousMap.apply_le_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : CompactSpace α\nf : ContinuousMap α Real\nx : α\n⊢ LE.le (f x) (Norm.norm f)","decl":"theorem apply_le_norm (f : C(α, ℝ)) (x : α) : f x ≤ ‖f‖ :=\n  le_trans (le_abs.mpr (Or.inl (le_refl (f x)))) (f.norm_coe_le_norm x)\n\n"}
{"name":"ContinuousMap.neg_norm_le_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : CompactSpace α\nf : ContinuousMap α Real\nx : α\n⊢ LE.le (Neg.neg (Norm.norm f)) (f x)","decl":"theorem neg_norm_le_apply (f : C(α, ℝ)) (x : α) : -‖f‖ ≤ f x :=\n  le_trans (neg_le_neg (f.norm_coe_le_norm x)) (neg_le.mp (neg_le_abs (f x)))\n\n"}
{"name":"ContinuousMap.nnnorm_eq_iSup_nnnorm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\n⊢ Eq (NNNorm.nnnorm f) (iSup fun x => NNNorm.nnnorm (f x))","decl":"theorem nnnorm_eq_iSup_nnnorm : ‖f‖₊ = ⨆ x : α, ‖f x‖₊ :=\n  (mkOfCompact f).nnnorm_eq_iSup_nnnorm\n\n"}
{"name":"ContinuousMap.norm_eq_iSup_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝² : TopologicalSpace α\ninst✝¹ : CompactSpace α\ninst✝ : SeminormedAddCommGroup E\nf : ContinuousMap α E\n⊢ Eq (Norm.norm f) (iSup fun x => Norm.norm (f x))","decl":"theorem norm_eq_iSup_norm : ‖f‖ = ⨆ x : α, ‖f x‖ :=\n  (mkOfCompact f).norm_eq_iSup_norm\n\n-- A version with better keys\n"}
{"name":"ContinuousMap.instCompactSpaceElemCoeCompacts","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_4\ninst✝ : TopologicalSpace X\nK : TopologicalSpace.Compacts X\n⊢ CompactSpace ↑↑K","decl":"instance {X : Type*} [TopologicalSpace X] (K : TopologicalSpace.Compacts X) :\n    CompactSpace (K : Set X) :=\n  TopologicalSpace.Compacts.instCompactSpaceSubtypeMem ..\n\n"}
{"name":"ContinuousMap.norm_restrict_mono_set","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"E : Type u_3\ninst✝¹ : SeminormedAddCommGroup E\nX : Type u_4\ninst✝ : TopologicalSpace X\nf : ContinuousMap X E\nK L : TopologicalSpace.Compacts X\nhKL : LE.le K L\n⊢ LE.le (Norm.norm (ContinuousMap.restrict (↑K) f)) (Norm.norm (ContinuousMap.restrict (↑L) f))","decl":"theorem norm_restrict_mono_set {X : Type*} [TopologicalSpace X] (f : C(X, E))\n    {K L : TopologicalSpace.Compacts X} (hKL : K ≤ L) : ‖f.restrict K‖ ≤ ‖f.restrict L‖ :=\n  (norm_le _ (norm_nonneg _)).mpr fun x => norm_coe_le_norm (f.restrict L) <| Set.inclusion hKL x\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : SeminormedAddCommGroup E\n𝕜 : Type u_4\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : BoundedContinuousFunction α E\n⊢ Eq ((ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜).symm f) f.toContinuousMap","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_symm_apply (f : α →ᵇ E) :\n    (linearIsometryBoundedOfCompact α E 𝕜).symm f = f.toContinuousMap :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_apply_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : SeminormedAddCommGroup E\n𝕜 : Type u_4\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nf : ContinuousMap α E\na : α\n⊢ Eq (((ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜) f) a) (f a)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_apply_apply (f : C(α, E)) (a : α) :\n    (linearIsometryBoundedOfCompact α E 𝕜 f) a = f a :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : SeminormedAddCommGroup E\n𝕜 : Type u_4\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜).toIsometryEquiv (ContinuousMap.isometryEquivBoundedOfCompact α E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_toIsometryEquiv :\n    (linearIsometryBoundedOfCompact α E 𝕜).toIsometryEquiv = isometryEquivBoundedOfCompact α E :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : SeminormedAddCommGroup E\n𝕜 : Type u_4\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (↑(ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜).toLinearEquiv) (ContinuousMap.addEquivBoundedOfCompact α E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_toAddEquiv :\n    ((linearIsometryBoundedOfCompact α E 𝕜).toLinearEquiv : C(α, E) ≃+ (α →ᵇ E)) =\n      addEquivBoundedOfCompact α E :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nE : Type u_3\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : SeminormedAddCommGroup E\n𝕜 : Type u_4\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (ContinuousMap.linearIsometryBoundedOfCompact α E 𝕜).toEquiv (ContinuousMap.equivBoundedOfCompact α E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_of_compact_toEquiv :\n    (linearIsometryBoundedOfCompact α E 𝕜).toLinearEquiv.toEquiv = equivBoundedOfCompact α E :=\n  rfl\n\n"}
{"name":"ContinuousMap.nnnorm_smul_const","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : CompactSpace α\nR : Type u_4\nβ : Type u_5\ninst✝³ : NormedAddCommGroup β\ninst✝² : NormedDivisionRing R\ninst✝¹ : Module R β\ninst✝ : BoundedSMul R β\nf : ContinuousMap α R\nb : β\n⊢ Eq (NNNorm.nnnorm (HSMul.hSMul f (ContinuousMap.const α b))) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm b))","decl":"@[simp] lemma nnnorm_smul_const {R β : Type*} [NormedAddCommGroup β] [NormedDivisionRing R]\n    [Module R β] [BoundedSMul R β] (f : C(α, R)) (b : β) :\n    ‖f • const α b‖₊ = ‖f‖₊ * ‖b‖₊ := by\n  simp only [nnnorm_eq_iSup_nnnorm, smul_apply', const_apply, nnnorm_smul, iSup_mul]\n\n"}
{"name":"ContinuousMap.norm_smul_const","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : CompactSpace α\nR : Type u_4\nβ : Type u_5\ninst✝³ : NormedAddCommGroup β\ninst✝² : NormedDivisionRing R\ninst✝¹ : Module R β\ninst✝ : BoundedSMul R β\nf : ContinuousMap α R\nb : β\n⊢ Eq (Norm.norm (HSMul.hSMul f (ContinuousMap.const α b))) (HMul.hMul (Norm.norm f) (Norm.norm b))","decl":"@[simp] lemma norm_smul_const {R β : Type*} [NormedAddCommGroup β] [NormedDivisionRing R]\n    [Module R β] [BoundedSMul R β] (f : C(α, R)) (b : β) :\n    ‖f • const α b‖ = ‖f‖ * ‖b‖ := by\n  simp only [← coe_nnnorm, NNReal.coe_mul, nnnorm_smul_const]\n\n"}
{"name":"ContinuousMap.uniform_continuity","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf : ContinuousMap α β\nε : Real\nh : LT.lt 0 ε\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ {x y : α}, LT.lt (Dist.dist x y) δ → LT.lt (Dist.dist (f x) (f y)) ε)","decl":"theorem uniform_continuity (f : C(α, β)) (ε : ℝ) (h : 0 < ε) :\n    ∃ δ > 0, ∀ {x y}, dist x y < δ → dist (f x) (f y) < ε :=\n  Metric.uniformContinuous_iff.mp (CompactSpace.uniformContinuous_of_continuous f.continuous) ε h\n\n-- This definition allows us to separate the choice of some `δ`,\n-- and the corresponding use of `dist a b < δ → dist (f a) (f b) < ε`,\n-- even across different declarations.\n"}
{"name":"ContinuousMap.modulus_pos","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf : ContinuousMap α β\nε : Real\nh : LT.lt 0 ε\n⊢ LT.lt 0 (f.modulus ε h)","decl":"theorem modulus_pos (f : C(α, β)) {ε : ℝ} {h : 0 < ε} : 0 < f.modulus ε h :=\n  (Classical.choose_spec (uniform_continuity f ε h)).1\n\n"}
{"name":"ContinuousMap.dist_lt_of_dist_lt_modulus","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : CompactSpace α\ninst✝ : PseudoMetricSpace β\nf : ContinuousMap α β\nε : Real\nh : LT.lt 0 ε\na b : α\nw : LT.lt (Dist.dist a b) (f.modulus ε h)\n⊢ LT.lt (Dist.dist (f a) (f b)) ε","decl":"theorem dist_lt_of_dist_lt_modulus (f : C(α, β)) (ε : ℝ) (h : 0 < ε) {a b : α}\n    (w : dist a b < f.modulus ε h) : dist (f a) (f b) < ε :=\n  (Classical.choose_spec (uniform_continuity f ε h)).2 w\n\n"}
{"name":"ContinuousLinearMap.toLinear_compLeftContinuousCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\n𝕜 : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : CompactSpace X\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : NormedSpace 𝕜 β\ninst✝¹ : SeminormedAddCommGroup γ\ninst✝ : NormedSpace 𝕜 γ\ng : ContinuousLinearMap (RingHom.id 𝕜) β γ\n⊢ Eq (↑(ContinuousLinearMap.compLeftContinuousCompact X g)) (ContinuousLinearMap.compLeftContinuous 𝕜 X g)","decl":"@[simp]\ntheorem ContinuousLinearMap.toLinear_compLeftContinuousCompact (g : β →L[𝕜] γ) :\n    (g.compLeftContinuousCompact X : C(X, β) →ₗ[𝕜] C(X, γ)) = g.compLeftContinuous 𝕜 X := by\n  ext f\n  rfl\n\n"}
{"name":"ContinuousLinearMap.compLeftContinuousCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\n𝕜 : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : CompactSpace X\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : NormedSpace 𝕜 β\ninst✝¹ : SeminormedAddCommGroup γ\ninst✝ : NormedSpace 𝕜 γ\ng : ContinuousLinearMap (RingHom.id 𝕜) β γ\nf : ContinuousMap X β\nx : X\n⊢ Eq (((ContinuousLinearMap.compLeftContinuousCompact X g) f) x) (g (f x))","decl":"@[simp]\ntheorem ContinuousLinearMap.compLeftContinuousCompact_apply (g : β →L[𝕜] γ) (f : C(X, β)) (x : X) :\n    g.compLeftContinuousCompact X f x = g (f x) :=\n  rfl\n\n"}
{"name":"ContinuousMap.summable_of_locally_summable_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\ninst✝² : LocallyCompactSpace X\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : CompleteSpace E\nι : Type u_3\nF : ι → ContinuousMap X E\nhF : ∀ (K : TopologicalSpace.Compacts X), Summable fun i => Norm.norm (ContinuousMap.restrict (↑K) (F i))\n⊢ Summable F","decl":"theorem summable_of_locally_summable_norm {ι : Type*} {F : ι → C(X, E)}\n    (hF : ∀ K : Compacts X, Summable fun i => ‖(F i).restrict K‖) : Summable F := by\n  classical\n  refine (ContinuousMap.exists_tendsto_compactOpen_iff_forall _).2 fun K hK => ?_\n  lift K to Compacts X using hK\n  have A : ∀ s : Finset ι, restrict (↑K) (∑ i ∈ s, F i) = ∑ i ∈ s, restrict K (F i) := by\n    intro s\n    ext1 x\n    simp\n    -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n    erw [restrict_apply, restrict_apply, restrict_apply, restrict_apply]\n    simp? says simp only [coe_sum, Finset.sum_apply]\n    congr!\n  simpa only [HasSum, A] using (hF K).of_norm\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_star","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : StarAddMonoid β\ninst✝¹ : NormedStarGroup β\ninst✝ : CompactSpace α\nf : ContinuousMap α β\n⊢ Eq (BoundedContinuousFunction.mkOfCompact (Star.star f)) (Star.star (BoundedContinuousFunction.mkOfCompact f))","decl":"theorem _root_.BoundedContinuousFunction.mkOfCompact_star [CompactSpace α] (f : C(α, β)) :\n    mkOfCompact (star f) = star (mkOfCompact f) :=\n  rfl\n\n"}
{"name":"ContinuousMap.instNormedStarGroup","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : StarAddMonoid β\ninst✝¹ : NormedStarGroup β\ninst✝ : CompactSpace α\n⊢ NormedStarGroup (ContinuousMap α β)","decl":"instance [CompactSpace α] : NormedStarGroup C(α, β) where\n  norm_star f := by\n    rw [← BoundedContinuousFunction.norm_mkOfCompact, BoundedContinuousFunction.mkOfCompact_star,\n      norm_star, BoundedContinuousFunction.norm_mkOfCompact]\n\n"}
{"name":"ContinuousMap.instCStarRing","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CompactSpace α\ninst✝² : NonUnitalNormedRing β\ninst✝¹ : StarRing β\ninst✝ : CStarRing β\n⊢ CStarRing (ContinuousMap α β)","decl":"instance [NonUnitalNormedRing β] [StarRing β] [CStarRing β] : CStarRing C(α, β) where\n  norm_mul_self_le f := by\n    rw [← sq, ← Real.le_sqrt (norm_nonneg _) (norm_nonneg _),\n      ContinuousMap.norm_le _ (Real.sqrt_nonneg _)]\n    intro x\n    rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, ← CStarRing.norm_star_mul_self]\n    exact ContinuousMap.norm_coe_le_norm (star f * f) x\n\n"}
