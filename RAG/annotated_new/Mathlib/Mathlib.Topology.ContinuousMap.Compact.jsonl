{"name":"ContinuousMap.equivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ Î²` are\nequivalent to `C(Î±, Î²)`.\n-/\n@[simps (config := .asFn)]\ndef equivBoundedOfCompact : C(Î±, Î²) â‰ƒ (Î± â†’áµ‡ Î²) :=\n  âŸ¨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by\n    ext\n    rfl, fun f => by\n    ext\n    rflâŸ©\n\n"}
{"name":"ContinuousMap.equivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²).symm) BoundedContinuousFunction.toContinuousMap","decl":"/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ Î²` are\nequivalent to `C(Î±, Î²)`.\n-/\n@[simps (config := .asFn)]\ndef equivBoundedOfCompact : C(Î±, Î²) â‰ƒ (Î± â†’áµ‡ Î²) :=\n  âŸ¨mkOfCompact, BoundedContinuousFunction.toContinuousMap, fun f => by\n    ext\n    rfl, fun f => by\n    ext\n    rflâŸ©\n\n"}
{"name":"ContinuousMap.isUniformInducing_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ IsUniformInducing â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²)","decl":"theorem isUniformInducing_equivBoundedOfCompact : IsUniformInducing (equivBoundedOfCompact Î± Î²) :=\n  IsUniformInducing.mk'\n    (by\n      simp only [hasBasis_compactConvergenceUniformity.mem_iff, uniformity_basis_dist_le.mem_iff]\n      exact fun s =>\n        âŸ¨fun âŸ¨âŸ¨a, bâŸ©, âŸ¨_, âŸ¨Îµ, hÎµ, hbâŸ©âŸ©, hsâŸ© =>\n          âŸ¨{ p | âˆ€ x, (p.1 x, p.2 x) âˆˆ b }, âŸ¨Îµ, hÎµ, fun _ h x => hb ((dist_le hÎµ.le).mp h x)âŸ©,\n            fun f g h => hs fun x _ => h xâŸ©,\n          fun âŸ¨_, âŸ¨Îµ, hÎµ, htâŸ©, hsâŸ© =>\n          âŸ¨âŸ¨Set.univ, { p | dist p.1 p.2 â‰¤ Îµ }âŸ©, âŸ¨isCompact_univ, âŸ¨Îµ, hÎµ, fun _ h => hâŸ©âŸ©,\n            fun âŸ¨f, gâŸ© h => hs _ _ (ht ((dist_le hÎµ.le).mpr fun x => h x (mem_univ x)))âŸ©âŸ©)\n\n"}
{"name":"ContinuousMap.uniformInducing_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ IsUniformInducing â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²)","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing_equivBoundedOfCompact := isUniformInducing_equivBoundedOfCompact\n\n"}
{"name":"ContinuousMap.isUniformEmbedding_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ IsUniformEmbedding â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²)","decl":"theorem isUniformEmbedding_equivBoundedOfCompact : IsUniformEmbedding (equivBoundedOfCompact Î± Î²) :=\n  { isUniformInducing_equivBoundedOfCompact Î± Î² with\n    injective := (equivBoundedOfCompact Î± Î²).injective }\n\n"}
{"name":"ContinuousMap.uniformEmbedding_equivBoundedOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ IsUniformEmbedding â‡‘(ContinuousMap.equivBoundedOfCompact Î± Î²)","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_equivBoundedOfCompact := isUniformEmbedding_equivBoundedOfCompact\n\n"}
{"name":"ContinuousMap.addEquivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : LipschitzAdd Î²\nâŠ¢ Eq (â‡‘(ContinuousMap.addEquivBoundedOfCompact Î± Î²)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ ğ•œ` are\nadditively equivalent to `C(Î±, ğ•œ)`.\n-/\n@[simps! (config := .asFn) apply symm_apply]\ndef addEquivBoundedOfCompact [AddMonoid Î²] [LipschitzAdd Î²] : C(Î±, Î²) â‰ƒ+ (Î± â†’áµ‡ Î²) :=\n  ({ toContinuousMapAddHom Î± Î², (equivBoundedOfCompact Î± Î²).symm with } : (Î± â†’áµ‡ Î²) â‰ƒ+ C(Î±, Î²)).symm\n\n"}
{"name":"ContinuousMap.addEquivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : PseudoMetricSpace Î²\ninstâœÂ¹ : AddMonoid Î²\ninstâœ : LipschitzAdd Î²\nâŠ¢ Eq â‡‘(ContinuousMap.addEquivBoundedOfCompact Î± Î²).symm â‡‘(BoundedContinuousFunction.toContinuousMapAddHom Î± Î²)","decl":"/-- When `Î±` is compact, the bounded continuous maps `Î± â†’áµ‡ ğ•œ` are\nadditively equivalent to `C(Î±, ğ•œ)`.\n-/\n@[simps! (config := .asFn) apply symm_apply]\ndef addEquivBoundedOfCompact [AddMonoid Î²] [LipschitzAdd Î²] : C(Î±, Î²) â‰ƒ+ (Î± â†’áµ‡ Î²) :=\n  ({ toContinuousMapAddHom Î± Î², (equivBoundedOfCompact Î± Î²).symm with } : (Î± â†’áµ‡ Î²) â‰ƒ+ C(Î±, Î²)).symm\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (â‡‘(ContinuousMap.isometryEquivBoundedOfCompact Î± Î²).symm) BoundedContinuousFunction.toContinuousMap","decl":"/-- When `Î±` is compact, and `Î²` is a metric space, the bounded continuous maps `Î± â†’áµ‡ Î²` are\nisometric to `C(Î±, Î²)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(Î±, Î²) â‰ƒáµ¢ (Î± â†’áµ‡ Î²) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact Î± Î²\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_toEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (ContinuousMap.isometryEquivBoundedOfCompact Î± Î²).toEquiv (ContinuousMap.equivBoundedOfCompact Î± Î²)","decl":"/-- When `Î±` is compact, and `Î²` is a metric space, the bounded continuous maps `Î± â†’áµ‡ Î²` are\nisometric to `C(Î±, Î²)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(Î±, Î²) â‰ƒáµ¢ (Î± â†’áµ‡ Î²) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact Î± Î²\n\n"}
{"name":"ContinuousMap.isometryEquivBoundedOfCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (â‡‘(ContinuousMap.isometryEquivBoundedOfCompact Î± Î²)) BoundedContinuousFunction.mkOfCompact","decl":"/-- When `Î±` is compact, and `Î²` is a metric space, the bounded continuous maps `Î± â†’áµ‡ Î²` are\nisometric to `C(Î±, Î²)`.\n-/\n@[simps! (config := .asFn) toEquiv apply symm_apply]\ndef isometryEquivBoundedOfCompact : C(Î±, Î²) â‰ƒáµ¢ (Î± â†’áµ‡ Î²) where\n  isometry_toFun _ _ := rfl\n  toEquiv := equivBoundedOfCompact Î± Î²\n\n"}
{"name":"BoundedContinuousFunction.dist_mkOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nâŠ¢ Eq (Dist.dist (BoundedContinuousFunction.mkOfCompact f) (BoundedContinuousFunction.mkOfCompact g)) (Dist.dist f g)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_mkOfCompact (f g : C(Î±, Î²)) :\n    dist (mkOfCompact f) (mkOfCompact g) = dist f g :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.dist_toContinuousMap","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : BoundedContinuousFunction Î± Î²\nâŠ¢ Eq (Dist.dist f.toContinuousMap g.toContinuousMap) (Dist.dist f g)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.dist_toContinuousMap (f g : Î± â†’áµ‡ Î²) :\n    dist f.toContinuousMap g.toContinuousMap = dist f g :=\n  rfl\n\n"}
{"name":"ContinuousMap.dist_apply_le_dist","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nx : Î±\nâŠ¢ LE.le (Dist.dist (f x) (g x)) (Dist.dist f g)","decl":"/-- The pointwise distance is controlled by the distance between functions, by definition. -/\ntheorem dist_apply_le_dist (x : Î±) : dist (f x) (g x) â‰¤ dist f g := by\n  simp only [â† dist_mkOfCompact, dist_coe_le_dist, â† mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_le","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nC : Real\nC0 : LE.le 0 C\nâŠ¢ Iff (LE.le (Dist.dist f g) C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)","decl":"/-- The distance between two functions is controlled by the supremum of the pointwise distances. -/\ntheorem dist_le (C0 : (0 : â„) â‰¤ C) : dist f g â‰¤ C â†” âˆ€ x : Î±, dist (f x) (g x) â‰¤ C := by\n  simp only [â† dist_mkOfCompact, BoundedContinuousFunction.dist_le C0, mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_le_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nC : Real\ninstâœ : Nonempty Î±\nâŠ¢ Iff (LE.le (Dist.dist f g) C) (âˆ€ (x : Î±), LE.le (Dist.dist (f x) (g x)) C)","decl":"theorem dist_le_iff_of_nonempty [Nonempty Î±] : dist f g â‰¤ C â†” âˆ€ x, dist (f x) (g x) â‰¤ C := by\n  simp only [â† dist_mkOfCompact, BoundedContinuousFunction.dist_le_iff_of_nonempty,\n    mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nC : Real\ninstâœ : Nonempty Î±\nâŠ¢ Iff (LT.lt (Dist.dist f g) C) (âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff_of_nonempty [Nonempty Î±] : dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C := by\n  simp only [â† dist_mkOfCompact, dist_lt_iff_of_nonempty_compact, mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.dist_lt_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nC : Real\ninstâœ : Nonempty Î±\nw : âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C\nâŠ¢ LT.lt (Dist.dist f g) C","decl":"theorem dist_lt_of_nonempty [Nonempty Î±] (w : âˆ€ x : Î±, dist (f x) (g x) < C) : dist f g < C :=\n  dist_lt_iff_of_nonempty.2 w\n\n"}
{"name":"ContinuousMap.dist_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : ContinuousMap Î± Î²\nC : Real\nC0 : LT.lt 0 C\nâŠ¢ Iff (LT.lt (Dist.dist f g) C) (âˆ€ (x : Î±), LT.lt (Dist.dist (f x) (g x)) C)","decl":"theorem dist_lt_iff (C0 : (0 : â„) < C) : dist f g < C â†” âˆ€ x : Î±, dist (f x) (g x) < C := by\n  rw [â† dist_mkOfCompact, dist_lt_iff_of_compact C0]\n  simp only [mkOfCompact_apply]\n\n"}
{"name":"ContinuousMap.instBoundedSMul","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : TopologicalSpace Î±\ninstâœâ¶ : CompactSpace Î±\ninstâœâµ : PseudoMetricSpace Î²\nR : Type u_4\ninstâœâ´ : Zero R\ninstâœÂ³ : Zero Î²\ninstâœÂ² : PseudoMetricSpace R\ninstâœÂ¹ : SMul R Î²\ninstâœ : BoundedSMul R Î²\nâŠ¢ BoundedSMul R (ContinuousMap Î± Î²)","decl":"instance {R} [Zero R] [Zero Î²] [PseudoMetricSpace R] [SMul R Î²] [BoundedSMul R Î²] :\n    BoundedSMul R C(Î±, Î²) where\n  dist_smul_pair' r f g := by\n    simpa only [â† dist_mkOfCompact] using dist_smul_pair r (mkOfCompact f) (mkOfCompact g)\n  dist_pair_smul' râ‚ râ‚‚ f := by\n    simpa only [â† dist_mkOfCompact] using dist_pair_smul râ‚ râ‚‚ (mkOfCompact f)\n\n"}
{"name":"BoundedContinuousFunction.norm_mkOfCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nâŠ¢ Eq (Norm.norm (BoundedContinuousFunction.mkOfCompact f)) (Norm.norm f)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_mkOfCompact (f : C(Î±, E)) : â€–mkOfCompact fâ€– = â€–fâ€– :=\n  rfl\n\n"}
{"name":"BoundedContinuousFunction.norm_toContinuousMap_eq","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : BoundedContinuousFunction Î± E\nâŠ¢ Eq (Norm.norm f.toContinuousMap) (Norm.norm f)","decl":"@[simp]\ntheorem _root_.BoundedContinuousFunction.norm_toContinuousMap_eq (f : Î± â†’áµ‡ E) :\n    â€–f.toContinuousMapâ€– = â€–fâ€– :=\n  rfl\n\n"}
{"name":"ContinuousMap.instNormOneClassOfNonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : CompactSpace Î±\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : Nonempty Î±\ninstâœÂ¹ : One E\ninstâœ : NormOneClass E\nâŠ¢ NormOneClass (ContinuousMap Î± E)","decl":"instance [Nonempty Î±] [One E] [NormOneClass E] : NormOneClass C(Î±, E) where\n  norm_one := by simp only [â† norm_mkOfCompact, mkOfCompact_one, norm_one]\n\n"}
{"name":"ContinuousMap.norm_coe_le_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nx : Î±\nâŠ¢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"theorem norm_coe_le_norm (x : Î±) : â€–f xâ€– â‰¤ â€–fâ€– :=\n  (mkOfCompact f).norm_coe_le_norm x\n\n"}
{"name":"ContinuousMap.dist_le_two_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nx y : Î±\nâŠ¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul 2 (Norm.norm f))","decl":"/-- Distance between the images of any two points is at most twice the norm of the function. -/\ntheorem dist_le_two_norm (x y : Î±) : dist (f x) (f y) â‰¤ 2 * â€–fâ€– :=\n  (mkOfCompact f).dist_le_two_norm x y\n\n"}
{"name":"ContinuousMap.norm_le","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nC : Real\nC0 : LE.le 0 C\nâŠ¢ Iff (LE.le (Norm.norm f) C) (âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C)","decl":"/-- The norm of a function is controlled by the supremum of the pointwise norms. -/\ntheorem norm_le {C : â„} (C0 : (0 : â„) â‰¤ C) : â€–fâ€– â‰¤ C â†” âˆ€ x : Î±, â€–f xâ€– â‰¤ C :=\n  @BoundedContinuousFunction.norm_le _ _ _ _ (mkOfCompact f) _ C0\n\n"}
{"name":"ContinuousMap.norm_le_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\ninstâœ : Nonempty Î±\nM : Real\nâŠ¢ Iff (LE.le (Norm.norm f) M) (âˆ€ (x : Î±), LE.le (Norm.norm (f x)) M)","decl":"theorem norm_le_of_nonempty [Nonempty Î±] {M : â„} : â€–fâ€– â‰¤ M â†” âˆ€ x, â€–f xâ€– â‰¤ M :=\n  @BoundedContinuousFunction.norm_le_of_nonempty _ _ _ _ _ (mkOfCompact f) _\n\n"}
{"name":"ContinuousMap.norm_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nM : Real\nM0 : LT.lt 0 M\nâŠ¢ Iff (LT.lt (Norm.norm f) M) (âˆ€ (x : Î±), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff {M : â„} (M0 : 0 < M) : â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M :=\n  @BoundedContinuousFunction.norm_lt_iff_of_compact _ _ _ _ _ (mkOfCompact f) _ M0\n\n"}
{"name":"ContinuousMap.nnnorm_lt_iff","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nM : NNReal\nM0 : LT.lt 0 M\nâŠ¢ Iff (LT.lt (NNNorm.nnnorm f) M) (âˆ€ (x : Î±), LT.lt (NNNorm.nnnorm (f x)) M)","decl":"theorem nnnorm_lt_iff {M : â„â‰¥0} (M0 : 0 < M) : â€–fâ€–â‚Š < M â†” âˆ€ x : Î±, â€–f xâ€–â‚Š < M :=\n  f.norm_lt_iff M0\n\n"}
{"name":"ContinuousMap.norm_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\ninstâœ : Nonempty Î±\nM : Real\nâŠ¢ Iff (LT.lt (Norm.norm f) M) (âˆ€ (x : Î±), LT.lt (Norm.norm (f x)) M)","decl":"theorem norm_lt_iff_of_nonempty [Nonempty Î±] {M : â„} : â€–fâ€– < M â†” âˆ€ x, â€–f xâ€– < M :=\n  @BoundedContinuousFunction.norm_lt_iff_of_nonempty_compact _ _ _ _ _ _ (mkOfCompact f) _\n\n"}
{"name":"ContinuousMap.nnnorm_lt_iff_of_nonempty","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : CompactSpace Î±\ninstâœÂ¹ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\ninstâœ : Nonempty Î±\nM : NNReal\nâŠ¢ Iff (LT.lt (NNNorm.nnnorm f) M) (âˆ€ (x : Î±), LT.lt (NNNorm.nnnorm (f x)) M)","decl":"theorem nnnorm_lt_iff_of_nonempty [Nonempty Î±] {M : â„â‰¥0} : â€–fâ€–â‚Š < M â†” âˆ€ x, â€–f xâ€–â‚Š < M :=\n  f.norm_lt_iff_of_nonempty\n\n"}
{"name":"ContinuousMap.apply_le_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : CompactSpace Î±\nf : ContinuousMap Î± Real\nx : Î±\nâŠ¢ LE.le (f x) (Norm.norm f)","decl":"theorem apply_le_norm (f : C(Î±, â„)) (x : Î±) : f x â‰¤ â€–fâ€– :=\n  le_trans (le_abs.mpr (Or.inl (le_refl (f x)))) (f.norm_coe_le_norm x)\n\n"}
{"name":"ContinuousMap.neg_norm_le_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : CompactSpace Î±\nf : ContinuousMap Î± Real\nx : Î±\nâŠ¢ LE.le (Neg.neg (Norm.norm f)) (f x)","decl":"theorem neg_norm_le_apply (f : C(Î±, â„)) (x : Î±) : -â€–fâ€– â‰¤ f x :=\n  le_trans (neg_le_neg (f.norm_coe_le_norm x)) (neg_le.mp (neg_le_abs (f x)))\n\n"}
{"name":"ContinuousMap.nnnorm_eq_iSup_nnnorm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nâŠ¢ Eq (NNNorm.nnnorm f) (iSup fun x => NNNorm.nnnorm (f x))","decl":"theorem nnnorm_eq_iSup_nnnorm : â€–fâ€–â‚Š = â¨† x : Î±, â€–f xâ€–â‚Š :=\n  (mkOfCompact f).nnnorm_eq_iSup_nnnorm\n\n"}
{"name":"ContinuousMap.norm_eq_iSup_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœÂ² : TopologicalSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : SeminormedAddCommGroup E\nf : ContinuousMap Î± E\nâŠ¢ Eq (Norm.norm f) (iSup fun x => Norm.norm (f x))","decl":"theorem norm_eq_iSup_norm : â€–fâ€– = â¨† x : Î±, â€–f xâ€– :=\n  (mkOfCompact f).norm_eq_iSup_norm\n\n-- A version with better keys\n"}
{"name":"ContinuousMap.instCompactSpaceElemCoeCompacts","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_4\ninstâœ : TopologicalSpace X\nK : TopologicalSpace.Compacts X\nâŠ¢ CompactSpace â†‘â†‘K","decl":"instance {X : Type*} [TopologicalSpace X] (K : TopologicalSpace.Compacts X) :\n    CompactSpace (K : Set X) :=\n  TopologicalSpace.Compacts.instCompactSpaceSubtypeMem ..\n\n"}
{"name":"ContinuousMap.norm_restrict_mono_set","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"E : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\nX : Type u_4\ninstâœ : TopologicalSpace X\nf : ContinuousMap X E\nK L : TopologicalSpace.Compacts X\nhKL : LE.le K L\nâŠ¢ LE.le (Norm.norm (ContinuousMap.restrict (â†‘K) f)) (Norm.norm (ContinuousMap.restrict (â†‘L) f))","decl":"theorem norm_restrict_mono_set {X : Type*} [TopologicalSpace X] (f : C(X, E))\n    {K L : TopologicalSpace.Compacts X} (hKL : K â‰¤ L) : â€–f.restrict Kâ€– â‰¤ â€–f.restrict Lâ€– :=\n  (norm_le _ (norm_nonneg _)).mpr fun x => norm_coe_le_norm (f.restrict L) <| Set.inclusion hKL x\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_symm_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : SeminormedAddCommGroup E\nğ•œ : Type u_4\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nf : BoundedContinuousFunction Î± E\nâŠ¢ Eq ((ContinuousMap.linearIsometryBoundedOfCompact Î± E ğ•œ).symm f) f.toContinuousMap","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_symm_apply (f : Î± â†’áµ‡ E) :\n    (linearIsometryBoundedOfCompact Î± E ğ•œ).symm f = f.toContinuousMap :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_apply_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : SeminormedAddCommGroup E\nğ•œ : Type u_4\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nf : ContinuousMap Î± E\na : Î±\nâŠ¢ Eq (((ContinuousMap.linearIsometryBoundedOfCompact Î± E ğ•œ) f) a) (f a)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_apply_apply (f : C(Î±, E)) (a : Î±) :\n    (linearIsometryBoundedOfCompact Î± E ğ•œ f) a = f a :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_toIsometryEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : SeminormedAddCommGroup E\nğ•œ : Type u_4\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (ContinuousMap.linearIsometryBoundedOfCompact Î± E ğ•œ).toIsometryEquiv (ContinuousMap.isometryEquivBoundedOfCompact Î± E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_toIsometryEquiv :\n    (linearIsometryBoundedOfCompact Î± E ğ•œ).toIsometryEquiv = isometryEquivBoundedOfCompact Î± E :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_toAddEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : SeminormedAddCommGroup E\nğ•œ : Type u_4\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (â†‘(ContinuousMap.linearIsometryBoundedOfCompact Î± E ğ•œ).toLinearEquiv) (ContinuousMap.addEquivBoundedOfCompact Î± E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_toAddEquiv :\n    ((linearIsometryBoundedOfCompact Î± E ğ•œ).toLinearEquiv : C(Î±, E) â‰ƒ+ (Î± â†’áµ‡ E)) =\n      addEquivBoundedOfCompact Î± E :=\n  rfl\n\n"}
{"name":"ContinuousMap.linearIsometryBoundedOfCompact_of_compact_toEquiv","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nE : Type u_3\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : SeminormedAddCommGroup E\nğ•œ : Type u_4\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (ContinuousMap.linearIsometryBoundedOfCompact Î± E ğ•œ).toEquiv (ContinuousMap.equivBoundedOfCompact Î± E)","decl":"@[simp]\ntheorem linearIsometryBoundedOfCompact_of_compact_toEquiv :\n    (linearIsometryBoundedOfCompact Î± E ğ•œ).toLinearEquiv.toEquiv = equivBoundedOfCompact Î± E :=\n  rfl\n\n"}
{"name":"ContinuousMap.nnnorm_smul_const","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : CompactSpace Î±\nR : Type u_4\nÎ² : Type u_5\ninstâœÂ³ : NormedAddCommGroup Î²\ninstâœÂ² : NormedDivisionRing R\ninstâœÂ¹ : Module R Î²\ninstâœ : BoundedSMul R Î²\nf : ContinuousMap Î± R\nb : Î²\nâŠ¢ Eq (NNNorm.nnnorm (HSMul.hSMul f (ContinuousMap.const Î± b))) (HMul.hMul (NNNorm.nnnorm f) (NNNorm.nnnorm b))","decl":"@[simp] lemma nnnorm_smul_const {R Î² : Type*} [NormedAddCommGroup Î²] [NormedDivisionRing R]\n    [Module R Î²] [BoundedSMul R Î²] (f : C(Î±, R)) (b : Î²) :\n    â€–f â€¢ const Î± bâ€–â‚Š = â€–fâ€–â‚Š * â€–bâ€–â‚Š := by\n  simp only [nnnorm_eq_iSup_nnnorm, smul_apply', const_apply, nnnorm_smul, iSup_mul]\n\n"}
{"name":"ContinuousMap.norm_smul_const","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : CompactSpace Î±\nR : Type u_4\nÎ² : Type u_5\ninstâœÂ³ : NormedAddCommGroup Î²\ninstâœÂ² : NormedDivisionRing R\ninstâœÂ¹ : Module R Î²\ninstâœ : BoundedSMul R Î²\nf : ContinuousMap Î± R\nb : Î²\nâŠ¢ Eq (Norm.norm (HSMul.hSMul f (ContinuousMap.const Î± b))) (HMul.hMul (Norm.norm f) (Norm.norm b))","decl":"@[simp] lemma norm_smul_const {R Î² : Type*} [NormedAddCommGroup Î²] [NormedDivisionRing R]\n    [Module R Î²] [BoundedSMul R Î²] (f : C(Î±, R)) (b : Î²) :\n    â€–f â€¢ const Î± bâ€– = â€–fâ€– * â€–bâ€– := by\n  simp only [â† coe_nnnorm, NNReal.coe_mul, nnnorm_smul_const]\n\n"}
{"name":"ContinuousMap.uniform_continuity","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : ContinuousMap Î± Î²\nÎµ : Real\nh : LT.lt 0 Îµ\nâŠ¢ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ {x y : Î±}, LT.lt (Dist.dist x y) Î´ â†’ LT.lt (Dist.dist (f x) (f y)) Îµ)","decl":"theorem uniform_continuity (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) :\n    âˆƒ Î´ > 0, âˆ€ {x y}, dist x y < Î´ â†’ dist (f x) (f y) < Îµ :=\n  Metric.uniformContinuous_iff.mp (CompactSpace.uniformContinuous_of_continuous f.continuous) Îµ h\n\n-- This definition allows us to separate the choice of some `Î´`,\n-- and the corresponding use of `dist a b < Î´ â†’ dist (f a) (f b) < Îµ`,\n-- even across different declarations.\n"}
{"name":"ContinuousMap.modulus_pos","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : ContinuousMap Î± Î²\nÎµ : Real\nh : LT.lt 0 Îµ\nâŠ¢ LT.lt 0 (f.modulus Îµ h)","decl":"theorem modulus_pos (f : C(Î±, Î²)) {Îµ : â„} {h : 0 < Îµ} : 0 < f.modulus Îµ h :=\n  (Classical.choose_spec (uniform_continuity f Îµ h)).1\n\n"}
{"name":"ContinuousMap.dist_lt_of_dist_lt_modulus","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœÂ² : PseudoMetricSpace Î±\ninstâœÂ¹ : CompactSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf : ContinuousMap Î± Î²\nÎµ : Real\nh : LT.lt 0 Îµ\na b : Î±\nw : LT.lt (Dist.dist a b) (f.modulus Îµ h)\nâŠ¢ LT.lt (Dist.dist (f a) (f b)) Îµ","decl":"theorem dist_lt_of_dist_lt_modulus (f : C(Î±, Î²)) (Îµ : â„) (h : 0 < Îµ) {a b : Î±}\n    (w : dist a b < f.modulus Îµ h) : dist (f a) (f b) < Îµ :=\n  (Classical.choose_spec (uniform_continuity f Îµ h)).2 w\n\n"}
{"name":"ContinuousLinearMap.toLinear_compLeftContinuousCompact","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\nğ•œ : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : CompactSpace X\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : NormedSpace ğ•œ Î²\ninstâœÂ¹ : SeminormedAddCommGroup Î³\ninstâœ : NormedSpace ğ•œ Î³\ng : ContinuousLinearMap (RingHom.id ğ•œ) Î² Î³\nâŠ¢ Eq (â†‘(ContinuousLinearMap.compLeftContinuousCompact X g)) (ContinuousLinearMap.compLeftContinuous ğ•œ X g)","decl":"@[simp]\ntheorem ContinuousLinearMap.toLinear_compLeftContinuousCompact (g : Î² â†’L[ğ•œ] Î³) :\n    (g.compLeftContinuousCompact X : C(X, Î²) â†’â‚—[ğ•œ] C(X, Î³)) = g.compLeftContinuous ğ•œ X := by\n  ext f\n  rfl\n\n"}
{"name":"ContinuousLinearMap.compLeftContinuousCompact_apply","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\nğ•œ : Type u_2\nÎ² : Type u_3\nÎ³ : Type u_4\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : CompactSpace X\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : NormedSpace ğ•œ Î²\ninstâœÂ¹ : SeminormedAddCommGroup Î³\ninstâœ : NormedSpace ğ•œ Î³\ng : ContinuousLinearMap (RingHom.id ğ•œ) Î² Î³\nf : ContinuousMap X Î²\nx : X\nâŠ¢ Eq (((ContinuousLinearMap.compLeftContinuousCompact X g) f) x) (g (f x))","decl":"@[simp]\ntheorem ContinuousLinearMap.compLeftContinuousCompact_apply (g : Î² â†’L[ğ•œ] Î³) (f : C(X, Î²)) (x : X) :\n    g.compLeftContinuousCompact X f x = g (f x) :=\n  rfl\n\n"}
{"name":"ContinuousMap.summable_of_locally_summable_norm","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : LocallyCompactSpace X\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : CompleteSpace E\nÎ¹ : Type u_3\nF : Î¹ â†’ ContinuousMap X E\nhF : âˆ€ (K : TopologicalSpace.Compacts X), Summable fun i => Norm.norm (ContinuousMap.restrict (â†‘K) (F i))\nâŠ¢ Summable F","decl":"theorem summable_of_locally_summable_norm {Î¹ : Type*} {F : Î¹ â†’ C(X, E)}\n    (hF : âˆ€ K : Compacts X, Summable fun i => â€–(F i).restrict Kâ€–) : Summable F := by\n  classical\n  refine (ContinuousMap.exists_tendsto_compactOpen_iff_forall _).2 fun K hK => ?_\n  lift K to Compacts X using hK\n  have A : âˆ€ s : Finset Î¹, restrict (â†‘K) (âˆ‘ i âˆˆ s, F i) = âˆ‘ i âˆˆ s, restrict K (F i) := by\n    intro s\n    ext1 x\n    simp\n    -- This used to be the end of the proof before https://github.com/leanprover/lean4/pull/2644\n    erw [restrict_apply, restrict_apply, restrict_apply, restrict_apply]\n    simp? says simp only [coe_sum, Finset.sum_apply]\n    congr!\n  simpa only [HasSum, A] using (hF K).of_norm\n\n"}
{"name":"BoundedContinuousFunction.mkOfCompact_star","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : StarAddMonoid Î²\ninstâœÂ¹ : NormedStarGroup Î²\ninstâœ : CompactSpace Î±\nf : ContinuousMap Î± Î²\nâŠ¢ Eq (BoundedContinuousFunction.mkOfCompact (Star.star f)) (Star.star (BoundedContinuousFunction.mkOfCompact f))","decl":"theorem _root_.BoundedContinuousFunction.mkOfCompact_star [CompactSpace Î±] (f : C(Î±, Î²)) :\n    mkOfCompact (star f) = star (mkOfCompact f) :=\n  rfl\n\n"}
{"name":"ContinuousMap.instNormedStarGroup","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : StarAddMonoid Î²\ninstâœÂ¹ : NormedStarGroup Î²\ninstâœ : CompactSpace Î±\nâŠ¢ NormedStarGroup (ContinuousMap Î± Î²)","decl":"instance [CompactSpace Î±] : NormedStarGroup C(Î±, Î²) where\n  norm_star f := by\n    rw [â† BoundedContinuousFunction.norm_mkOfCompact, BoundedContinuousFunction.mkOfCompact_star,\n      norm_star, BoundedContinuousFunction.norm_mkOfCompact]\n\n"}
{"name":"ContinuousMap.instCStarRing","module":"Mathlib.Topology.ContinuousMap.Compact","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : CompactSpace Î±\ninstâœÂ² : NonUnitalNormedRing Î²\ninstâœÂ¹ : StarRing Î²\ninstâœ : CStarRing Î²\nâŠ¢ CStarRing (ContinuousMap Î± Î²)","decl":"instance [NonUnitalNormedRing Î²] [StarRing Î²] [CStarRing Î²] : CStarRing C(Î±, Î²) where\n  norm_mul_self_le f := by\n    rw [â† sq, â† Real.le_sqrt (norm_nonneg _) (norm_nonneg _),\n      ContinuousMap.norm_le _ (Real.sqrt_nonneg _)]\n    intro x\n    rw [Real.le_sqrt (norm_nonneg _) (norm_nonneg _), sq, â† CStarRing.norm_star_mul_self]\n    exact ContinuousMap.norm_coe_le_norm (star f * f) x\n\n"}
