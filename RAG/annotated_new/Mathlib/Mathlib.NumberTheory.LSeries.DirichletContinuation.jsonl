{"name":"DirichletCharacter.LFunction_modOne_eq","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"Ï‡ : DirichletCharacter Complex 1\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡) riemannZeta","decl":"/--\nThe L-function of the (unique) Dirichlet character mod 1 is the Riemann zeta function.\n(Compare `DirichletCharacter.LSeries_modOne_eq`.)\n-/\n@[simp] lemma LFunction_modOne_eq {Ï‡ : DirichletCharacter â„‚ 1} :\n    LFunction Ï‡ = riemannZeta := by\n  ext; rw [LFunction, ZMod.LFunction_modOne_eq, (by rfl : (0 : ZMod 1) = 1), map_one, one_mul]\n\n"}
{"name":"DirichletCharacter.LFunction_eq_LSeries","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡ s) (LSeries (fun x => Ï‡ â†‘x) s)","decl":"/--\nFor `1 < re s` the L-function of a Dirichlet character agrees with the sum of the naive Dirichlet\nseries.\n-/\nlemma LFunction_eq_LSeries (Ï‡ : DirichletCharacter â„‚ N) {s : â„‚} (hs : 1 < re s) :\n    LFunction Ï‡ s = LSeries (Ï‡ Â·) s :=\n  ZMod.LFunction_eq_LSeries Ï‡ hs\n\n"}
{"name":"DirichletCharacter.deriv_LFunction_eq_deriv_LSeries","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\nâŠ¢ Eq (deriv (DirichletCharacter.LFunction Ï‡) s) (deriv (LSeries fun x => Ï‡ â†‘x) s)","decl":"lemma deriv_LFunction_eq_deriv_LSeries (Ï‡ : DirichletCharacter â„‚ N) {s : â„‚} (hs : 1 < s.re) :\n    deriv (LFunction Ï‡) s = deriv (LSeries (Ï‡ Â·)) s := by\n  refine Filter.EventuallyEq.deriv_eq ?_\n  have h : {z | 1 < z.re} âˆˆ nhds s :=\n    (isOpen_lt continuous_const continuous_re).mem_nhds hs\n  filter_upwards [h] with z hz\n  exact LFunction_eq_LSeries Ï‡ hz\n\n"}
{"name":"DirichletCharacter.differentiableAt_LFunction","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhs : Or (Ne s 1) (Ne Ï‡ 1)\nâŠ¢ DifferentiableAt Complex (DirichletCharacter.LFunction Ï‡) s","decl":"/--\nThe L-function of a Dirichlet character is differentiable, except at `s = 1` if the character is\ntrivial.\n-/\n@[fun_prop]\nlemma differentiableAt_LFunction (Ï‡ : DirichletCharacter â„‚ N) (s : â„‚) (hs : s â‰  1 âˆ¨ Ï‡ â‰  1) :\n    DifferentiableAt â„‚ (LFunction Ï‡) s :=\n  ZMod.differentiableAt_LFunction Ï‡ s (hs.imp_right Ï‡.sum_eq_zero_of_ne_one)\n\n"}
{"name":"DirichletCharacter.differentiable_LFunction","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ne Ï‡ 1\nâŠ¢ Differentiable Complex (DirichletCharacter.LFunction Ï‡)","decl":"/-- The L-function of a non-trivial Dirichlet character is differentiable everywhere. -/\n@[fun_prop]\nlemma differentiable_LFunction {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡ â‰  1) :\n    Differentiable â„‚ (LFunction Ï‡) :=\n  (differentiableAt_LFunction _ Â· <| Or.inr hÏ‡)\n\n"}
{"name":"DirichletCharacter.Even.LFunction_neg_two_mul_nat_add_one","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.Even\nn : Nat\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡ (Neg.neg (HMul.hMul 2 (HAdd.hAdd (â†‘n) 1)))) 0","decl":"/-- The L-function of an even Dirichlet character vanishes at strictly negative even integers. -/\n@[simp]\nlemma Even.LFunction_neg_two_mul_nat_add_one {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Even Ï‡) (n : â„•) :\n    LFunction Ï‡ (-(2 * (n + 1))) = 0 :=\n  ZMod.LFunction_neg_two_mul_nat_add_one hÏ‡.to_fun n\n\n"}
{"name":"DirichletCharacter.Even.LFunction_neg_two_mul_nat","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœÂ¹ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.Even\nn : Nat\ninstâœ : NeZero n\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡ (Neg.neg (HMul.hMul 2 â†‘n))) 0","decl":"/-- The L-function of an even Dirichlet character vanishes at strictly negative even integers. -/\n@[simp]\nlemma Even.LFunction_neg_two_mul_nat {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Even Ï‡) (n : â„•) [NeZero n] :\n    LFunction Ï‡ (-(2 * n)) = 0 := by\n  obtain âŸ¨m, rflâŸ© := Nat.exists_eq_succ_of_ne_zero (NeZero.ne n)\n  exact_mod_cast hÏ‡.LFunction_neg_two_mul_nat_add_one m\n\n"}
{"name":"DirichletCharacter.Odd.LFunction_neg_two_mul_nat_sub_one","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.Odd\nn : Nat\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡ (HSub.hSub (Neg.neg (HMul.hMul 2 â†‘n)) 1)) 0","decl":"/-- The L-function of an odd Dirichlet character vanishes at negative odd integers. -/\n@[simp] lemma Odd.LFunction_neg_two_mul_nat_sub_one\n  {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Odd Ï‡) (n : â„•) :\n    LFunction Ï‡ (-(2 * n) - 1) = 0 :=\n  ZMod.LFunction_neg_two_mul_nat_sub_one hÏ‡.to_fun n\n\n"}
{"name":"DirichletCharacter.LFunction_changeLevel","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"M N : Nat\ninstâœÂ¹ : NeZero M\ninstâœ : NeZero N\nhMN : Dvd.dvd M N\nÏ‡ : DirichletCharacter Complex M\ns : Complex\nh : Or (Ne Ï‡ 1) (Ne s 1)\nâŠ¢ Eq (DirichletCharacter.LFunction ((DirichletCharacter.changeLevel hMN) Ï‡) s) (HMul.hMul (DirichletCharacter.LFunction Ï‡ s) (N.primeFactors.prod fun p => HSub.hSub 1 (HMul.hMul (Ï‡ â†‘p) (HPow.hPow (â†‘p) (Neg.neg s)))))","decl":"/-- If `Ï‡` is a Dirichlet character and its level `M` divides `N`, then we obtain the L function\nof `Ï‡` considered as a Dirichlet character of level `N` from the L function of `Ï‡` by multiplying\nwith `âˆ p âˆˆ N.primeFactors, (1 - Ï‡ p * p ^ (-s))`.\n(Note that `1 - Ï‡ p * p ^ (-s) = 1` when `p` divides `M`). -/\nlemma LFunction_changeLevel {M N : â„•} [NeZero M] [NeZero N] (hMN : M âˆ£ N)\n    (Ï‡ : DirichletCharacter â„‚ M) {s : â„‚} (h : Ï‡ â‰  1 âˆ¨ s â‰  1) :\n    LFunction (changeLevel hMN Ï‡) s =\n      LFunction Ï‡ s * âˆ p âˆˆ N.primeFactors, (1 - Ï‡ p * p ^ (-s)) := by\n  rcases h with h | h\n  Â· have hÏ‡ : changeLevel hMN Ï‡ â‰  1 := h âˆ˜ (changeLevel_eq_one_iff hMN).mp\n    have h' : Continuous fun s â†¦ LFunction Ï‡ s * âˆ p âˆˆ N.primeFactors, (1 - Ï‡ p * â†‘p ^ (-s)) :=\n      (differentiable_LFunction h).continuous.mul <| continuous_finset_prod _ fun p hp â†¦ by\n        have : NeZero p := âŸ¨(Nat.prime_of_mem_primeFactors hp).ne_zeroâŸ©\n        fun_prop\n    exact congrFun ((differentiable_LFunction hÏ‡).continuous.ext_on\n      (dense_compl_singleton 1) h' (fun _ h â†¦ LFunction_changeLevel_aux hMN Ï‡ h)) s\n  Â· exact LFunction_changeLevel_aux hMN Ï‡ h\n\n"}
{"name":"DirichletCharacter.LFunctionTrivChar_eq_mul_riemannZeta","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\ns : Complex\nhs : Ne s 1\nâŠ¢ Eq (DirichletCharacter.LFunctionTrivChar N s) (HMul.hMul (N.primeFactors.prod fun p => HSub.hSub 1 (HPow.hPow (â†‘p) (Neg.neg s))) (riemannZeta s))","decl":"/-- The L function of the trivial Dirichlet character mod `N` is obtained from the Riemann\nzeta function by multiplying with `âˆ p âˆˆ N.primeFactors, (1 - (p : â„‚) ^ (-s))`. -/\nlemma LFunctionTrivChar_eq_mul_riemannZeta {s : â„‚} (hs : s â‰  1) :\n    LFunctionTrivChar N s = (âˆ p âˆˆ N.primeFactors, (1 - (p : â„‚) ^ (-s))) * riemannZeta s := by\n  rw [â† LFunction_modOne_eq (Ï‡ := 1), LFunctionTrivChar, â† changeLevel_one N.one_dvd, mul_comm]\n  convert LFunction_changeLevel N.one_dvd 1 (.inr hs) using 4 with p\n  rw [MulChar.one_apply <| isUnit_of_subsingleton _, one_mul]\n\n"}
{"name":"DirichletCharacter.LFunctionTrivChar_residue_one","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nâŠ¢ Filter.Tendsto (fun s => HMul.hMul (HSub.hSub s 1) (DirichletCharacter.LFunctionTrivChar N s)) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (N.primeFactors.prod fun p => HSub.hSub 1 (Inv.inv â†‘p)))","decl":"/-- The L function of the trivial Dirichlet character mod `N` has a simple pole with\nresidue `âˆ p âˆˆ N.primeFactors, (1 - pâ»Â¹)` at `s = 1`. -/\nlemma LFunctionTrivChar_residue_one :\n    Tendsto (fun s â†¦ (s - 1) * LFunctionTrivChar N s) (ğ“[â‰ ] 1)\n      (ğ“ <| âˆ p âˆˆ N.primeFactors, (1 - (p : â„‚)â»Â¹)) := by\n  have H : (fun s â†¦ (s - 1) * LFunctionTrivChar N s) =á¶ [ğ“[â‰ ] 1]\n        fun s â†¦ (âˆ p âˆˆ N.primeFactors, (1 - (p : â„‚) ^ (-s))) * ((s - 1) * riemannZeta s) := by\n    refine Set.EqOn.eventuallyEq_nhdsWithin fun s hs â†¦ ?_\n    rw [mul_left_comm, LFunctionTrivChar_eq_mul_riemannZeta hs]\n  rw [tendsto_congr' H]\n  conv => enter [3, 1]; rw [â† mul_one <| Finset.prod ..]; enter [1, 2, p]; rw [â† cpow_neg_one]\n  refine .mul (f := fun s â†¦ âˆ p âˆˆ N.primeFactors, _) ?_ riemannZeta_residue_one\n  refine tendsto_nhdsWithin_of_tendsto_nhds <| Continuous.tendsto ?_ 1\n  exact continuous_finset_prod _ fun p hp â†¦ by\n    have : NeZero p := âŸ¨(Nat.prime_of_mem_primeFactors hp).ne_zeroâŸ©\n    fun_prop\n\n"}
{"name":"DirichletCharacter.Even.gammaFactor_def","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.Even\ns : Complex\nâŠ¢ Eq (Ï‡.gammaFactor s) s.Gammaâ„","decl":"lemma Even.gammaFactor_def {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡.Even) (s : â„‚) :\n    gammaFactor Ï‡ s = Gammaâ„ s := by\n  simp [gammaFactor, hÏ‡]\n\n"}
{"name":"DirichletCharacter.Odd.gammaFactor_def","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.Odd\ns : Complex\nâŠ¢ Eq (Ï‡.gammaFactor s) (HAdd.hAdd s 1).Gammaâ„","decl":"lemma Odd.gammaFactor_def {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡.Odd) (s : â„‚) :\n    gammaFactor Ï‡ s = Gammaâ„ (s + 1) := by\n  simp [gammaFactor, hÏ‡.not_even]\n\n"}
{"name":"DirichletCharacter.completedLFunction_modOne_eq","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"Ï‡ : DirichletCharacter Complex 1\nâŠ¢ Eq (DirichletCharacter.completedLFunction Ï‡) completedRiemannZeta","decl":"/--\nThe completed L-function of the (unique) Dirichlet character mod 1 is the completed Riemann zeta\nfunction.\n-/\nlemma completedLFunction_modOne_eq {Ï‡ : DirichletCharacter â„‚ 1} :\n    completedLFunction Ï‡ = completedRiemannZeta := by\n  ext; rw [completedLFunction, ZMod.completedLFunction_modOne_eq, map_one, one_mul]\n\n"}
{"name":"DirichletCharacter.differentiableAt_completedLFunction","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nhsâ‚€ : Or (Ne s 0) (Ne N 1)\nhsâ‚ : Or (Ne s 1) (Ne Ï‡ 1)\nâŠ¢ DifferentiableAt Complex (DirichletCharacter.completedLFunction Ï‡) s","decl":"/--\nThe completed L-function of a Dirichlet character is differentiable, with the following\nexceptions: at `s = 1` if `Ï‡` is the trivial character (to any modulus); and at `s = 0` if the\nmodulus is 1. This result is best possible.\n\nNote both `Ï‡` and `s` are explicit arguments: we will always be able to infer one or other\nof them from the hypotheses, but it's not clear which!\n-/\nlemma differentiableAt_completedLFunction (Ï‡ : DirichletCharacter â„‚ N) (s : â„‚)\n    (hsâ‚€ : s â‰  0 âˆ¨ N â‰  1) (hsâ‚ : s â‰  1 âˆ¨ Ï‡ â‰  1) :\n    DifferentiableAt â„‚ (completedLFunction Ï‡) s :=\n  ZMod.differentiableAt_completedLFunction _ _ (by have := Ï‡.map_zero'; tauto)\n    (by have := Ï‡.sum_eq_zero_of_ne_one; tauto)\n\n"}
{"name":"DirichletCharacter.differentiable_completedLFunction","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ne Ï‡ 1\nâŠ¢ Differentiable Complex (DirichletCharacter.completedLFunction Ï‡)","decl":"/-- The completed L-function of a non-trivial Dirichlet character is differentiable everywhere. -/\nlemma differentiable_completedLFunction {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : Ï‡ â‰  1) :\n    Differentiable â„‚ (completedLFunction Ï‡) := by\n  refine fun s â†¦ differentiableAt_completedLFunction _ _ (Or.inr ?_) (Or.inr hÏ‡)\n  exact hÏ‡ âˆ˜ level_one' _\n\n"}
{"name":"DirichletCharacter.LFunction_eq_completed_div_gammaFactor","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\ns : Complex\nh : Or (Ne s 0) (Ne N 1)\nâŠ¢ Eq (DirichletCharacter.LFunction Ï‡ s) (HDiv.hDiv (DirichletCharacter.completedLFunction Ï‡ s) (Ï‡.gammaFactor s))","decl":"/--\nRelation between the completed L-function and the usual one. We state it this way around so\nit holds at the poles of the gamma factor as well.\n-/\nlemma LFunction_eq_completed_div_gammaFactor (Ï‡ : DirichletCharacter â„‚ N) (s : â„‚)\n    (h : s â‰  0 âˆ¨ N â‰  1) : LFunction Ï‡ s = completedLFunction Ï‡ s / gammaFactor Ï‡ s := by\n  rcases Ï‡.even_or_odd with hÏ‡ | hÏ‡ <;>\n  rw [hÏ‡.gammaFactor_def]\n  Â· exact LFunction_eq_completed_div_gammaFactor_even hÏ‡.to_fun _ (h.imp_right Ï‡.map_zero')\n  Â· apply LFunction_eq_completed_div_gammaFactor_odd hÏ‡.to_fun\n\n"}
{"name":"DirichletCharacter.rootNumber_modOne","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"Ï‡ : DirichletCharacter Complex 1\nâŠ¢ Eq Ï‡.rootNumber 1","decl":"/-- The root number of the unique Dirichlet character modulo 1 is 1. -/\nlemma rootNumber_modOne (Ï‡ : DirichletCharacter â„‚ 1) : rootNumber Ï‡ = 1 := by\n  simp [rootNumber, gaussSum, -univ_unique, â† singleton_eq_univ (1 : ZMod 1),\n    (show stdAddChar (1 : ZMod 1) = 1 from AddChar.map_zero_eq_one _),\n    (show Ï‡.Even from map_one _)]\n\n"}
{"name":"DirichletCharacter.IsPrimitive.completedLFunction_one_sub","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"N : Nat\ninstâœ : NeZero N\nÏ‡ : DirichletCharacter Complex N\nhÏ‡ : Ï‡.IsPrimitive\ns : Complex\nâŠ¢ Eq (DirichletCharacter.completedLFunction Ï‡ (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HPow.hPow (â†‘N) (HSub.hSub s (1 / 2))) Ï‡.rootNumber) (DirichletCharacter.completedLFunction (Inv.inv Ï‡) s))","decl":"/-- **Functional equation** for primitive Dirichlet L-functions. -/\ntheorem completedLFunction_one_sub {Ï‡ : DirichletCharacter â„‚ N} (hÏ‡ : IsPrimitive Ï‡) (s : â„‚) :\n    completedLFunction Ï‡ (1 - s) = N ^ (s - 1 / 2) * rootNumber Ï‡ * completedLFunction Ï‡â»Â¹ s := by\n  classical\n  -- First handle special case of Riemann zeta\n  rcases eq_or_ne N 1 with rfl | hN\n  Â· simp [completedLFunction_modOne_eq, completedRiemannZeta_one_sub, rootNumber_modOne]\n  -- facts about `Ï‡` as function\n  have h_sum : âˆ‘ j, Ï‡ j = 0 := by\n    refine Ï‡.sum_eq_zero_of_ne_one (fun h â†¦ hN.symm ?_)\n    rwa [IsPrimitive, h, conductor_one (NeZero.ne _)] at hÏ‡\n  let Îµ := I ^ (if Ï‡.Even then 0 else 1)\n  -- gather up powers of N\n  rw [rootNumber, â† mul_comm_div, â† mul_comm_div, â† cpow_sub _ _ (NeZero.ne _), sub_sub, add_halves]\n  calc completedLFunction Ï‡ (1 - s)\n  _ = N ^ (s - 1) * Ï‡ (-1) /  Îµ * ZMod.completedLFunction (ğ“• Ï‡) s := by\n    simp only [Îµ]\n    split_ifs with h\n    Â· rw [pow_zero, div_one, h, mul_one, completedLFunction,\n        completedLFunction_one_sub_even h.to_fun _ (.inr h_sum) (.inr <| Ï‡.map_zero' hN)]\n    Â· replace h : Ï‡.Odd := Ï‡.even_or_odd.resolve_left h\n      rw [completedLFunction, completedLFunction_one_sub_odd h.to_fun,\n        pow_one, h, div_I, mul_neg_one, â† neg_mul, neg_neg]\n  _ = (_) * ZMod.completedLFunction (fun j â†¦ Ï‡â»Â¹ (-1) * gaussSum Ï‡ stdAddChar * Ï‡â»Â¹ j) s := by\n    congr 2 with j\n    rw [hÏ‡.fourierTransform_eq_inv_mul_gaussSum, â† neg_one_mul j, map_mul, mul_right_comm]\n  _ = N ^ (s - 1) / Îµ * gaussSum Ï‡ stdAddChar * completedLFunction Ï‡â»Â¹ s * (Ï‡ (-1) * Ï‡â»Â¹ (-1)):= by\n    rw [completedLFunction, completedLFunction_const_mul]\n    ring\n  _ = N ^ (s - 1) / Îµ * gaussSum Ï‡ stdAddChar * completedLFunction Ï‡â»Â¹ s := by\n    rw [â† MulChar.mul_apply, mul_inv_cancel, MulChar.one_apply (isUnit_one.neg), mul_one]\n\n"}
{"name":"DirichletCharacter.LFunctionTrivCharâ‚_apply_one_ne_zero","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"n : Nat\ninstâœ : NeZero n\nâŠ¢ Ne (DirichletCharacter.LFunctionTrivCharâ‚ n 1) 0","decl":"lemma LFunctionTrivCharâ‚_apply_one_ne_zero : LFunctionTrivCharâ‚ n 1 â‰  0 := by\n  simp only [Function.update_self]\n  refine Finset.prod_ne_zero_iff.mpr fun p hp â†¦ ?_\n  simpa [sub_ne_zero] using (Nat.prime_of_mem_primeFactors hp).ne_one\n\n"}
{"name":"DirichletCharacter.differentiable_LFunctionTrivCharâ‚","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"n : Nat\ninstâœ : NeZero n\nâŠ¢ Differentiable Complex (DirichletCharacter.LFunctionTrivCharâ‚ n)","decl":"/-- `s â†¦ (s - 1) * L Ï‡ s` is an entire function when `Ï‡` is a trivial Dirichlet character. -/\nlemma differentiable_LFunctionTrivCharâ‚ : Differentiable â„‚ (LFunctionTrivCharâ‚ n) := by\n  rw [â† differentiableOn_univ,\n    â† differentiableOn_compl_singleton_and_continuousAt_iff (c := 1) Filter.univ_mem]\n  refine âŸ¨DifferentiableOn.congr (f := fun s â†¦ (s - 1) * LFunctionTrivChar n s)\n    (fun _ hs â†¦ DifferentiableAt.differentiableWithinAt <| by fun_prop (disch := simp_all [hs]))\n   fun _ hs â†¦ Function.update_of_ne (Set.mem_diff_singleton.mp hs).2 ..,\n    continuousWithinAt_compl_self.mp ?_âŸ©\n  simpa using LFunctionTrivChar_residue_one\n\n"}
{"name":"DirichletCharacter.deriv_LFunctionTrivCharâ‚_apply_of_ne_one","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"n : Nat\ninstâœ : NeZero n\ns : Complex\nhs : Ne s 1\nâŠ¢ Eq (deriv (DirichletCharacter.LFunctionTrivCharâ‚ n) s) (HAdd.hAdd (HMul.hMul (HSub.hSub s 1) (deriv (DirichletCharacter.LFunctionTrivChar n) s)) (DirichletCharacter.LFunctionTrivChar n s))","decl":"lemma deriv_LFunctionTrivCharâ‚_apply_of_ne_one {s : â„‚} (hs : s â‰  1) :\n    deriv (LFunctionTrivCharâ‚ n) s =\n      (s - 1) * deriv (LFunctionTrivChar n) s + LFunctionTrivChar n s := by\n  have H : deriv (LFunctionTrivCharâ‚ n) s =\n      deriv (fun w â†¦ (w - 1) * LFunctionTrivChar n w) s := by\n    refine eventuallyEq_iff_exists_mem.mpr ?_ |>.deriv_eq\n    exact âŸ¨_, isOpen_ne.mem_nhds hs, fun _ hw â†¦ Function.update_of_ne (Set.mem_setOf.mp hw) ..âŸ©\n  rw [H, deriv_mul (by fun_prop) (differentiableAt_LFunction _ s (.inl hs)), deriv_sub_const,\n    deriv_id'', one_mul, add_comm]\n\n"}
{"name":"DirichletCharacter.continuousOn_neg_logDeriv_LFunctionTrivCharâ‚","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"n : Nat\ninstâœ : NeZero n\nâŠ¢ ContinuousOn (fun s => HDiv.hDiv (Neg.neg (deriv (DirichletCharacter.LFunctionTrivCharâ‚ n) s)) (DirichletCharacter.LFunctionTrivCharâ‚ n s)) (setOf fun s => Or (Eq s 1) (Ne (DirichletCharacter.LFunctionTrivChar n s) 0))","decl":"/-- The negative logarithmtic derivative of `s â†¦ (s - 1) * L Ï‡ s` for a trivial\nDirichlet character `Ï‡` is continuous away from the zeros of `L Ï‡` (including at `s = 1`). -/\nlemma continuousOn_neg_logDeriv_LFunctionTrivCharâ‚ :\n    ContinuousOn (fun s â†¦ -deriv (LFunctionTrivCharâ‚ n) s / LFunctionTrivCharâ‚ n s)\n      {s | s = 1 âˆ¨ LFunctionTrivChar n s â‰  0} := by\n  simp_rw [neg_div]\n  have h := differentiable_LFunctionTrivCharâ‚ n\n  refine ((h.contDiff.continuous_deriv le_rfl).continuousOn.div\n    h.continuous.continuousOn fun w hw â†¦ ?_).neg\n  rcases eq_or_ne w 1 with rfl | hw'\n  Â· exact LFunctionTrivCharâ‚_apply_one_ne_zero _\n  Â· rw [LFunctionTrivCharâ‚, Function.update_of_ne hw', mul_ne_zero_iff]\n    exact âŸ¨sub_ne_zero_of_ne hw', (Set.mem_setOf.mp hw).resolve_left hw'âŸ©\n\n"}
{"name":"DirichletCharacter.continuousOn_neg_logDeriv_LFunction_of_nontriv","module":"Mathlib.NumberTheory.LSeries.DirichletContinuation","initialProofState":"n : Nat\ninstâœ : NeZero n\nÏ‡ : DirichletCharacter Complex n\nhÏ‡ : Ne Ï‡ 1\nâŠ¢ ContinuousOn (fun s => HDiv.hDiv (Neg.neg (deriv (DirichletCharacter.LFunction Ï‡) s)) (DirichletCharacter.LFunction Ï‡ s)) (setOf fun s => Ne (DirichletCharacter.LFunction Ï‡ s) 0)","decl":"/-- The negative logarithmic derivative of the L-function of a nontrivial Dirichlet character\nis continuous away from the zeros of the L-function. -/\nlemma continuousOn_neg_logDeriv_LFunction_of_nontriv (hÏ‡ : Ï‡ â‰  1) :\n    ContinuousOn (fun s â†¦ -deriv (LFunction Ï‡) s / LFunction Ï‡ s) {s | LFunction Ï‡ s â‰  0} := by\n  have h := differentiable_LFunction hÏ‡\n  simpa [neg_div] using ((h.contDiff.continuous_deriv le_rfl).continuousOn.div\n    h.continuous.continuousOn fun _ hw â†¦ hw).neg\n\n"}
