{"name":"CategoryTheory.Adjunction.Localization.ε_app","module":"Mathlib.CategoryTheory.Localization.Adjunction","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_5, u_3} D₁\ninst✝³ : CategoryTheory.Category.{u_7, u_4} D₂\nG : CategoryTheory.Functor C₁ C₂\nF : CategoryTheory.Functor C₂ C₁\nadj : CategoryTheory.Adjunction G F\nL₁ : CategoryTheory.Functor C₁ D₁\nW₁ : CategoryTheory.MorphismProperty C₁\ninst✝² : L₁.IsLocalization W₁\nL₂ : CategoryTheory.Functor C₂ D₂\nG' : CategoryTheory.Functor D₁ D₂\nF' : CategoryTheory.Functor D₂ D₁\ninst✝¹ : CategoryTheory.CatCommSq G L₁ L₂ G'\ninst✝ : CategoryTheory.CatCommSq F L₂ L₁ F'\nX₁ : C₁\n⊢ Eq ((CategoryTheory.Adjunction.Localization.ε adj L₁ W₁ L₂ G' F').app (L₁.obj X₁)) (CategoryTheory.CategoryStruct.comp (L₁.map (adj.unit.app X₁)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso F L₂ L₁ F').hom.app (G.obj X₁)) (F'.map ((CategoryTheory.CatCommSq.iso G L₁ L₂ G').hom.app X₁))))","decl":"lemma ε_app (X₁ : C₁) :\n    (ε adj L₁ W₁ L₂ G' F').app (L₁.obj X₁) =\n      L₁.map (adj.unit.app X₁) ≫ (CatCommSq.iso F L₂ L₁ F').hom.app (G.obj X₁) ≫\n        F'.map ((CatCommSq.iso G L₁ L₂ G').hom.app X₁) := by\n  letI : Lifting L₁ W₁ ((G ⋙ F) ⋙ L₁) (G' ⋙ F') :=\n    Lifting.mk (CatCommSq.hComp G F L₁ L₂ L₁ G' F').iso'.symm\n  simp only [ε, liftNatTrans_app, Lifting.iso, Iso.symm,\n    Functor.id_obj, Functor.comp_obj, Lifting.id_iso', Functor.rightUnitor_hom_app,\n      whiskerRight_app, CatCommSq.hComp_iso'_hom_app, id_comp]\n\n"}
{"name":"CategoryTheory.Adjunction.Localization.η_app","module":"Mathlib.CategoryTheory.Localization.Adjunction","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} D₁\ninst✝³ : CategoryTheory.Category.{u_5, u_4} D₂\nG : CategoryTheory.Functor C₁ C₂\nF : CategoryTheory.Functor C₂ C₁\nadj : CategoryTheory.Adjunction G F\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝² : L₂.IsLocalization W₂\nG' : CategoryTheory.Functor D₁ D₂\nF' : CategoryTheory.Functor D₂ D₁\ninst✝¹ : CategoryTheory.CatCommSq G L₁ L₂ G'\ninst✝ : CategoryTheory.CatCommSq F L₂ L₁ F'\nX₂ : C₂\n⊢ Eq ((CategoryTheory.Adjunction.Localization.η adj L₁ L₂ W₂ G' F').app (L₂.obj X₂)) (CategoryTheory.CategoryStruct.comp (G'.map ((CategoryTheory.CatCommSq.iso F L₂ L₁ F').inv.app X₂)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso G L₁ L₂ G').inv.app (F.obj X₂)) (L₂.map (adj.counit.app X₂))))","decl":"lemma η_app (X₂ : C₂) :\n    (η adj L₁ L₂ W₂ G' F').app (L₂.obj X₂) =\n      G'.map ((CatCommSq.iso F L₂ L₁ F').inv.app X₂) ≫\n        (CatCommSq.iso G L₁ L₂ G').inv.app (F.obj X₂) ≫\n        L₂.map (adj.counit.app X₂) := by\n  letI : Lifting L₂ W₂ ((F ⋙ G) ⋙ L₂) (F' ⋙ G') :=\n    Lifting.mk (CatCommSq.hComp F G L₂ L₁ L₂ F' G').iso'.symm\n  simp only [η, liftNatTrans_app, Lifting.iso, Iso.symm, CatCommSq.hComp_iso'_inv_app,\n    whiskerRight_app, Lifting.id_iso', Functor.rightUnitor_inv_app, comp_id, assoc]\n\n"}
{"name":"CategoryTheory.Adjunction.localization_unit_app","module":"Mathlib.CategoryTheory.Localization.Adjunction","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_5, u_3} D₁\ninst✝⁴ : CategoryTheory.Category.{u_7, u_4} D₂\nG : CategoryTheory.Functor C₁ C₂\nF : CategoryTheory.Functor C₂ C₁\nadj : CategoryTheory.Adjunction G F\nL₁ : CategoryTheory.Functor C₁ D₁\nW₁ : CategoryTheory.MorphismProperty C₁\ninst✝³ : L₁.IsLocalization W₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝² : L₂.IsLocalization W₂\nG' : CategoryTheory.Functor D₁ D₂\nF' : CategoryTheory.Functor D₂ D₁\ninst✝¹ : CategoryTheory.CatCommSq G L₁ L₂ G'\ninst✝ : CategoryTheory.CatCommSq F L₂ L₁ F'\nX₁ : C₁\n⊢ Eq ((adj.localization L₁ W₁ L₂ W₂ G' F').unit.app (L₁.obj X₁)) (CategoryTheory.CategoryStruct.comp (L₁.map (adj.unit.app X₁)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso F L₂ L₁ F').hom.app (G.obj X₁)) (F'.map ((CategoryTheory.CatCommSq.iso G L₁ L₂ G').hom.app X₁))))","decl":"@[simp]\nlemma localization_unit_app (X₁ : C₁) :\n    (adj.localization L₁ W₁ L₂ W₂ G' F').unit.app (L₁.obj X₁) =\n    L₁.map (adj.unit.app X₁) ≫ (CatCommSq.iso F L₂ L₁ F').hom.app (G.obj X₁) ≫\n      F'.map ((CatCommSq.iso G L₁ L₂ G').hom.app X₁) := by\n  apply Localization.ε_app\n\n"}
{"name":"CategoryTheory.Adjunction.localization_counit_app","module":"Mathlib.CategoryTheory.Localization.Adjunction","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\ninst✝⁷ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁶ : CategoryTheory.Category.{u_7, u_2} C₂\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} D₁\ninst✝⁴ : CategoryTheory.Category.{u_5, u_4} D₂\nG : CategoryTheory.Functor C₁ C₂\nF : CategoryTheory.Functor C₂ C₁\nadj : CategoryTheory.Adjunction G F\nL₁ : CategoryTheory.Functor C₁ D₁\nW₁ : CategoryTheory.MorphismProperty C₁\ninst✝³ : L₁.IsLocalization W₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝² : L₂.IsLocalization W₂\nG' : CategoryTheory.Functor D₁ D₂\nF' : CategoryTheory.Functor D₂ D₁\ninst✝¹ : CategoryTheory.CatCommSq G L₁ L₂ G'\ninst✝ : CategoryTheory.CatCommSq F L₂ L₁ F'\nX₂ : C₂\n⊢ Eq ((adj.localization L₁ W₁ L₂ W₂ G' F').counit.app (L₂.obj X₂)) (CategoryTheory.CategoryStruct.comp (G'.map ((CategoryTheory.CatCommSq.iso F L₂ L₁ F').inv.app X₂)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CatCommSq.iso G L₁ L₂ G').inv.app (F.obj X₂)) (L₂.map (adj.counit.app X₂))))","decl":"@[simp]\nlemma localization_counit_app (X₂ : C₂) :\n    (adj.localization L₁ W₁ L₂ W₂ G' F').counit.app (L₂.obj X₂) =\n    G'.map ((CatCommSq.iso F L₂ L₁ F').inv.app X₂) ≫\n      (CatCommSq.iso G L₁ L₂ G').inv.app (F.obj X₂) ≫\n      L₂.map (adj.counit.app X₂) := by\n  apply Localization.η_app\n\n"}
{"name":"CategoryTheory.Adjunction.isLocalization","module":"Mathlib.CategoryTheory.Localization.Adjunction","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_5, u_2} C₂\nG : CategoryTheory.Functor C₁ C₂\nF : CategoryTheory.Functor C₂ C₁\nadj : CategoryTheory.Adjunction G F\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ G.IsLocalization ((CategoryTheory.MorphismProperty.isomorphisms C₂).inverseImage G)","decl":"include adj in\nlemma isLocalization [F.Full] [F.Faithful] :\n    G.IsLocalization ((MorphismProperty.isomorphisms C₂).inverseImage G) := by\n  let W := ((MorphismProperty.isomorphisms C₂).inverseImage G)\n  have hG : W.IsInvertedBy G := fun _ _ _ hf => hf\n  have : ∀ (X : C₁), IsIso ((whiskerRight adj.unit W.Q).app X) := fun X =>\n    Localization.inverts W.Q W _ (by\n      change IsIso _\n      infer_instance)\n  have : IsIso (whiskerRight adj.unit W.Q) := NatIso.isIso_of_isIso_app _\n  let e : W.Localization ≌ C₂ := Equivalence.mk (Localization.lift G hG W.Q) (F ⋙ W.Q)\n    (liftNatIso W.Q W W.Q (G ⋙ F ⋙ W.Q) _ _\n    (W.Q.leftUnitor.symm ≪≫ asIso (whiskerRight adj.unit W.Q)))\n    (Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (Localization.fac G hG W.Q) ≪≫\n      asIso adj.counit)\n  apply Functor.IsLocalization.of_equivalence_target W.Q W G e\n    (Localization.fac G hG W.Q)\n\n"}
