{"name":"HasDerivAtFilter.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœâ´ : NontriviallyNormedField ð•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nfâ‚ : ð•œ â†’ F\nfâ‚' : F\nx : ð•œ\nL : Filter ð•œ\nG : Type w\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ð•œ G\nfâ‚‚ : ð•œ â†’ G\nfâ‚‚' : G\nhfâ‚ : HasDerivAtFilter fâ‚ fâ‚' x L\nhfâ‚‚ : HasDerivAtFilter fâ‚‚ fâ‚‚' x L\nâŠ¢ HasDerivAtFilter (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) { fst := fâ‚', snd := fâ‚‚' } x L","decl":"nonrec theorem HasDerivAtFilter.prod (hfâ‚ : HasDerivAtFilter fâ‚ fâ‚' x L)\n    (hfâ‚‚ : HasDerivAtFilter fâ‚‚ fâ‚‚' x L) : HasDerivAtFilter (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚', fâ‚‚') x L :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"HasDerivWithinAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœâ´ : NontriviallyNormedField ð•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nfâ‚ : ð•œ â†’ F\nfâ‚' : F\nx : ð•œ\ns : Set ð•œ\nG : Type w\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ð•œ G\nfâ‚‚ : ð•œ â†’ G\nfâ‚‚' : G\nhfâ‚ : HasDerivWithinAt fâ‚ fâ‚' s x\nhfâ‚‚ : HasDerivWithinAt fâ‚‚ fâ‚‚' s x\nâŠ¢ HasDerivWithinAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) { fst := fâ‚', snd := fâ‚‚' } s x","decl":"nonrec theorem HasDerivWithinAt.prod (hfâ‚ : HasDerivWithinAt fâ‚ fâ‚' s x)\n    (hfâ‚‚ : HasDerivWithinAt fâ‚‚ fâ‚‚' s x) : HasDerivWithinAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚', fâ‚‚') s x :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"HasDerivAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœâ´ : NontriviallyNormedField ð•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nfâ‚ : ð•œ â†’ F\nfâ‚' : F\nx : ð•œ\nG : Type w\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ð•œ G\nfâ‚‚ : ð•œ â†’ G\nfâ‚‚' : G\nhfâ‚ : HasDerivAt fâ‚ fâ‚' x\nhfâ‚‚ : HasDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasDerivAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) { fst := fâ‚', snd := fâ‚‚' } x","decl":"nonrec theorem HasDerivAt.prod (hfâ‚ : HasDerivAt fâ‚ fâ‚' x) (hfâ‚‚ : HasDerivAt fâ‚‚ fâ‚‚' x) :\n    HasDerivAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚', fâ‚‚') x :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"HasStrictDerivAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœâ´ : NontriviallyNormedField ð•œ\nF : Type v\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nfâ‚ : ð•œ â†’ F\nfâ‚' : F\nx : ð•œ\nG : Type w\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ð•œ G\nfâ‚‚ : ð•œ â†’ G\nfâ‚‚' : G\nhfâ‚ : HasStrictDerivAt fâ‚ fâ‚' x\nhfâ‚‚ : HasStrictDerivAt fâ‚‚ fâ‚‚' x\nâŠ¢ HasStrictDerivAt (fun x => { fst := fâ‚ x, snd := fâ‚‚ x }) { fst := fâ‚', snd := fâ‚‚' } x","decl":"nonrec theorem HasStrictDerivAt.prod (hfâ‚ : HasStrictDerivAt fâ‚ fâ‚' x)\n    (hfâ‚‚ : HasStrictDerivAt fâ‚‚ fâ‚‚' x) : HasStrictDerivAt (fun x => (fâ‚ x, fâ‚‚ x)) (fâ‚', fâ‚‚') x :=\n  hfâ‚.prod hfâ‚‚\n\n"}
{"name":"hasStrictDerivAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nÏ†' : (i : Î¹) â†’ E' i\nâŠ¢ Iff (HasStrictDerivAt Ï† Ï†' x) (âˆ€ (i : Î¹), HasStrictDerivAt (fun x => Ï† x i) (Ï†' i) x)","decl":"@[simp]\ntheorem hasStrictDerivAt_pi :\n    HasStrictDerivAt Ï† Ï†' x â†” âˆ€ i, HasStrictDerivAt (fun x => Ï† x i) (Ï†' i) x :=\n  hasStrictFDerivAt_pi'\n\n"}
{"name":"hasDerivAtFilter_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\nL : Filter ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nÏ†' : (i : Î¹) â†’ E' i\nâŠ¢ Iff (HasDerivAtFilter Ï† Ï†' x L) (âˆ€ (i : Î¹), HasDerivAtFilter (fun x => Ï† x i) (Ï†' i) x L)","decl":"@[simp]\ntheorem hasDerivAtFilter_pi :\n    HasDerivAtFilter Ï† Ï†' x L â†” âˆ€ i, HasDerivAtFilter (fun x => Ï† x i) (Ï†' i) x L :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasDerivAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nÏ†' : (i : Î¹) â†’ E' i\nâŠ¢ Iff (HasDerivAt Ï† Ï†' x) (âˆ€ (i : Î¹), HasDerivAt (fun x => Ï† x i) (Ï†' i) x)","decl":"theorem hasDerivAt_pi : HasDerivAt Ï† Ï†' x â†” âˆ€ i, HasDerivAt (fun x => Ï† x i) (Ï†' i) x :=\n  hasDerivAtFilter_pi\n\n"}
{"name":"hasDerivWithinAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\ns : Set ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nÏ†' : (i : Î¹) â†’ E' i\nâŠ¢ Iff (HasDerivWithinAt Ï† Ï†' s x) (âˆ€ (i : Î¹), HasDerivWithinAt (fun x => Ï† x i) (Ï†' i) s x)","decl":"theorem hasDerivWithinAt_pi :\n    HasDerivWithinAt Ï† Ï†' s x â†” âˆ€ i, HasDerivWithinAt (fun x => Ï† x i) (Ï†' i) s x :=\n  hasDerivAtFilter_pi\n\n"}
{"name":"derivWithin_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\ns : Set ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nh : âˆ€ (i : Î¹), DifferentiableWithinAt ð•œ (fun x => Ï† x i) s x\nâŠ¢ Eq (derivWithin Ï† s x) fun i => derivWithin (fun x => Ï† x i) s x","decl":"theorem derivWithin_pi (h : âˆ€ i, DifferentiableWithinAt ð•œ (fun x => Ï† x i) s x) :\n    derivWithin Ï† s x = fun i => derivWithin (fun x => Ï† x i) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  Â· exact (hasDerivWithinAt_pi.2 fun i => (h i).hasDerivWithinAt).derivWithin hxs\n  Â· simp only [derivWithin_zero_of_isolated hxs]\n    rfl\n\n"}
{"name":"deriv_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ³ : NontriviallyNormedField ð•œ\nx : ð•œ\nÎ¹ : Type u_1\ninstâœÂ² : Fintype Î¹\nE' : Î¹ â†’ Type u_2\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (E' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ð•œ (E' i)\nÏ† : ð•œ â†’ (i : Î¹) â†’ E' i\nh : âˆ€ (i : Î¹), DifferentiableAt ð•œ (fun x => Ï† x i) x\nâŠ¢ Eq (deriv Ï† x) fun i => deriv (fun x => Ï† x i) x","decl":"theorem deriv_pi (h : âˆ€ i, DifferentiableAt ð•œ (fun x => Ï† x i) x) :\n    deriv Ï† x = fun i => deriv (fun x => Ï† x i) x :=\n  (hasDerivAt_pi.2 fun i => (h i).hasDerivAt).deriv\n\n"}
{"name":"hasStrictDerivAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : (i : Fin n.succ) â†’ F' i\nâŠ¢ Iff (HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x) (And (HasStrictDerivAt Ï† (Ï†' 0) x) (HasStrictDerivAt Ï†s (fun i => Ï†' i.succ) x))","decl":"theorem hasStrictDerivAt_finCons {Ï†' : Î  i, F' i} :\n    HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x â†”\n      HasStrictDerivAt Ï† (Ï†' 0) x âˆ§ HasStrictDerivAt Ï†s (fun i => Ï†' i.succ) x :=\n  hasStrictFDerivAt_finCons\n\n"}
{"name":"hasStrictDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x) (And (HasStrictDerivAt Ï† Ï†' x) (HasStrictDerivAt Ï†s Ï†s' x))","decl":"/-- A variant of `hasStrictDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasStrictDerivAt_finCons' {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)} :\n    HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x â†”\n      HasStrictDerivAt Ï† Ï†' x âˆ§ HasStrictDerivAt Ï†s Ï†s' x :=\n  hasStrictDerivAt_finCons\n\n"}
{"name":"HasStrictDerivAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nh : HasStrictDerivAt Ï† Ï†' x\nhs : HasStrictDerivAt Ï†s Ï†s' x\nâŠ¢ HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x","decl":"theorem HasStrictDerivAt.finCons {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)}\n    (h : HasStrictDerivAt Ï† Ï†' x) (hs : HasStrictDerivAt Ï†s Ï†s' x) :\n    HasStrictDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x :=\n  hasStrictDerivAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasDerivAtFilter_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : (i : Fin n.succ) â†’ F' i\nl : Filter ð•œ\nâŠ¢ Iff (HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x l) (And (HasDerivAtFilter Ï† (Ï†' 0) x l) (HasDerivAtFilter Ï†s (fun i => Ï†' i.succ) x l))","decl":"theorem hasDerivAtFilter_finCons {Ï†' : Î  i, F' i} {l : Filter ð•œ} :\n    HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x l â†”\n      HasDerivAtFilter Ï† (Ï†' 0) x l âˆ§ HasDerivAtFilter Ï†s (fun i => Ï†' i.succ) x l :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasDerivAtFilter_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nl : Filter ð•œ\nâŠ¢ Iff (HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x l) (And (HasDerivAtFilter Ï† Ï†' x l) (HasDerivAtFilter Ï†s Ï†s' x l))","decl":"/-- A variant of `hasDerivAtFilter_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivAtFilter_finCons' {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)} {l : Filter ð•œ} :\n    HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x l â†”\n      HasDerivAtFilter Ï† Ï†' x l âˆ§ HasDerivAtFilter Ï†s Ï†s' x l :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"HasDerivAtFilter.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nl : Filter ð•œ\nh : HasDerivAtFilter Ï† Ï†' x l\nhs : HasDerivAtFilter Ï†s Ï†s' x l\nâŠ¢ HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x l","decl":"theorem HasDerivAtFilter.finCons {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)} {l : Filter ð•œ}\n    (h : HasDerivAtFilter Ï† Ï†' x l) (hs : HasDerivAtFilter Ï†s Ï†s' x l) :\n    HasDerivAtFilter (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x l :=\n  hasDerivAtFilter_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasDerivAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : (i : Fin n.succ) â†’ F' i\nâŠ¢ Iff (HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x) (And (HasDerivAt Ï† (Ï†' 0) x) (HasDerivAt Ï†s (fun i => Ï†' i.succ) x))","decl":"theorem hasDerivAt_finCons {Ï†' : Î  i, F' i} :\n    HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' x â†”\n      HasDerivAt Ï† (Ï†' 0) x âˆ§ HasDerivAt Ï†s (fun i => Ï†' i.succ) x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"hasDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x) (And (HasDerivAt Ï† Ï†' x) (HasDerivAt Ï†s Ï†s' x))","decl":"/-- A variant of `hasDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivAt_finCons' {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)} :\n    HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x â†”\n      HasDerivAt Ï† Ï†' x âˆ§ HasDerivAt Ï†s Ï†s' x :=\n  hasDerivAt_finCons\n\n"}
{"name":"HasDerivAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nh : HasDerivAt Ï† Ï†' x\nhs : HasDerivAt Ï†s Ï†s' x\nâŠ¢ HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x","decl":"theorem HasDerivAt.finCons {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)}\n    (h : HasDerivAt Ï† Ï†' x) (hs : HasDerivAt Ï†s Ï†s' x) :\n    HasDerivAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') x :=\n  hasDerivAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n"}
{"name":"hasDerivWithinAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\ns : Set ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : (i : Fin n.succ) â†’ F' i\nâŠ¢ Iff (HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' s x) (And (HasDerivWithinAt Ï† (Ï†' 0) s x) (HasDerivWithinAt Ï†s (fun i => Ï†' i.succ) s x))","decl":"theorem hasDerivWithinAt_finCons {Ï†' : Î  i, F' i} :\n    HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) Ï†' s x â†”\n      HasDerivWithinAt Ï† (Ï†' 0) s x âˆ§ HasDerivWithinAt Ï†s (fun i => Ï†' i.succ) s x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"hasDerivWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\ns : Set ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nâŠ¢ Iff (HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') s x) (And (HasDerivWithinAt Ï† Ï†' s x) (HasDerivWithinAt Ï†s Ï†s' s x))","decl":"/-- A variant of `hasDerivWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivWithinAt_finCons' {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)} :\n    HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') s x â†”\n      HasDerivWithinAt Ï† Ï†' s x âˆ§ HasDerivWithinAt Ï†s Ï†s' s x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"HasDerivWithinAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"ð•œ : Type u\ninstâœÂ² : NontriviallyNormedField ð•œ\nx : ð•œ\ns : Set ð•œ\nn : Nat\nF' : Fin n.succ â†’ Type u_1\ninstâœÂ¹ : (i : Fin n.succ) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Fin n.succ) â†’ NormedSpace ð•œ (F' i)\nÏ† : ð•œ â†’ F' 0\nÏ†s : ð•œ â†’ (i : Fin n) â†’ F' i.succ\nÏ†' : F' 0\nÏ†s' : (i : Fin n) â†’ F' i.succ\nh : HasDerivWithinAt Ï† Ï†' s x\nhs : HasDerivWithinAt Ï†s Ï†s' s x\nâŠ¢ HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') s x","decl":"theorem HasDerivWithinAt.finCons {Ï†' : F' 0} {Ï†s' : Î  i, F' (Fin.succ i)}\n    (h : HasDerivWithinAt Ï† Ï†' s x) (hs : HasDerivWithinAt Ï†s Ï†s' s x) :\n    HasDerivWithinAt (fun x => Fin.cons (Ï† x) (Ï†s x)) (Fin.cons Ï†' Ï†s') s x :=\n  hasDerivWithinAt_finCons'.mpr âŸ¨h, hsâŸ©\n\n-- TODO: write the `Fin.cons` versions of `derivWithin_pi` and `deriv_pi`\n\n"}
