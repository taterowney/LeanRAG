{"name":"HasDerivAtFilter.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nf₁ : 𝕜 → F\nf₁' : F\nx : 𝕜\nL : Filter 𝕜\nG : Type w\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : 𝕜 → G\nf₂' : G\nhf₁ : HasDerivAtFilter f₁ f₁' x L\nhf₂ : HasDerivAtFilter f₂ f₂' x L\n⊢ HasDerivAtFilter (fun x => { fst := f₁ x, snd := f₂ x }) { fst := f₁', snd := f₂' } x L","decl":"nonrec theorem HasDerivAtFilter.prod (hf₁ : HasDerivAtFilter f₁ f₁' x L)\n    (hf₂ : HasDerivAtFilter f₂ f₂' x L) : HasDerivAtFilter (fun x => (f₁ x, f₂ x)) (f₁', f₂') x L :=\n  hf₁.prod hf₂\n\n"}
{"name":"HasDerivWithinAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nf₁ : 𝕜 → F\nf₁' : F\nx : 𝕜\ns : Set 𝕜\nG : Type w\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : 𝕜 → G\nf₂' : G\nhf₁ : HasDerivWithinAt f₁ f₁' s x\nhf₂ : HasDerivWithinAt f₂ f₂' s x\n⊢ HasDerivWithinAt (fun x => { fst := f₁ x, snd := f₂ x }) { fst := f₁', snd := f₂' } s x","decl":"nonrec theorem HasDerivWithinAt.prod (hf₁ : HasDerivWithinAt f₁ f₁' s x)\n    (hf₂ : HasDerivWithinAt f₂ f₂' s x) : HasDerivWithinAt (fun x => (f₁ x, f₂ x)) (f₁', f₂') s x :=\n  hf₁.prod hf₂\n\n"}
{"name":"HasDerivAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nf₁ : 𝕜 → F\nf₁' : F\nx : 𝕜\nG : Type w\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : 𝕜 → G\nf₂' : G\nhf₁ : HasDerivAt f₁ f₁' x\nhf₂ : HasDerivAt f₂ f₂' x\n⊢ HasDerivAt (fun x => { fst := f₁ x, snd := f₂ x }) { fst := f₁', snd := f₂' } x","decl":"nonrec theorem HasDerivAt.prod (hf₁ : HasDerivAt f₁ f₁' x) (hf₂ : HasDerivAt f₂ f₂' x) :\n    HasDerivAt (fun x => (f₁ x, f₂ x)) (f₁', f₂') x :=\n  hf₁.prod hf₂\n\n"}
{"name":"HasStrictDerivAt.prod","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type v\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nf₁ : 𝕜 → F\nf₁' : F\nx : 𝕜\nG : Type w\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf₂ : 𝕜 → G\nf₂' : G\nhf₁ : HasStrictDerivAt f₁ f₁' x\nhf₂ : HasStrictDerivAt f₂ f₂' x\n⊢ HasStrictDerivAt (fun x => { fst := f₁ x, snd := f₂ x }) { fst := f₁', snd := f₂' } x","decl":"nonrec theorem HasStrictDerivAt.prod (hf₁ : HasStrictDerivAt f₁ f₁' x)\n    (hf₂ : HasStrictDerivAt f₂ f₂' x) : HasStrictDerivAt (fun x => (f₁ x, f₂ x)) (f₁', f₂') x :=\n  hf₁.prod hf₂\n\n"}
{"name":"hasStrictDerivAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nφ' : (i : ι) → E' i\n⊢ Iff (HasStrictDerivAt φ φ' x) (∀ (i : ι), HasStrictDerivAt (fun x => φ x i) (φ' i) x)","decl":"@[simp]\ntheorem hasStrictDerivAt_pi :\n    HasStrictDerivAt φ φ' x ↔ ∀ i, HasStrictDerivAt (fun x => φ x i) (φ' i) x :=\n  hasStrictFDerivAt_pi'\n\n"}
{"name":"hasDerivAtFilter_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nL : Filter 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nφ' : (i : ι) → E' i\n⊢ Iff (HasDerivAtFilter φ φ' x L) (∀ (i : ι), HasDerivAtFilter (fun x => φ x i) (φ' i) x L)","decl":"@[simp]\ntheorem hasDerivAtFilter_pi :\n    HasDerivAtFilter φ φ' x L ↔ ∀ i, HasDerivAtFilter (fun x => φ x i) (φ' i) x L :=\n  hasFDerivAtFilter_pi'\n\n"}
{"name":"hasDerivAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nφ' : (i : ι) → E' i\n⊢ Iff (HasDerivAt φ φ' x) (∀ (i : ι), HasDerivAt (fun x => φ x i) (φ' i) x)","decl":"theorem hasDerivAt_pi : HasDerivAt φ φ' x ↔ ∀ i, HasDerivAt (fun x => φ x i) (φ' i) x :=\n  hasDerivAtFilter_pi\n\n"}
{"name":"hasDerivWithinAt_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nφ' : (i : ι) → E' i\n⊢ Iff (HasDerivWithinAt φ φ' s x) (∀ (i : ι), HasDerivWithinAt (fun x => φ x i) (φ' i) s x)","decl":"theorem hasDerivWithinAt_pi :\n    HasDerivWithinAt φ φ' s x ↔ ∀ i, HasDerivWithinAt (fun x => φ x i) (φ' i) s x :=\n  hasDerivAtFilter_pi\n\n"}
{"name":"derivWithin_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nh : ∀ (i : ι), DifferentiableWithinAt 𝕜 (fun x => φ x i) s x\n⊢ Eq (derivWithin φ s x) fun i => derivWithin (fun x => φ x i) s x","decl":"theorem derivWithin_pi (h : ∀ i, DifferentiableWithinAt 𝕜 (fun x => φ x i) s x) :\n    derivWithin φ s x = fun i => derivWithin (fun x => φ x i) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hasDerivWithinAt_pi.2 fun i => (h i).hasDerivWithinAt).derivWithin hxs\n  · simp only [derivWithin_zero_of_isolated hxs]\n    rfl\n\n"}
{"name":"deriv_pi","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝³ : NontriviallyNormedField 𝕜\nx : 𝕜\nι : Type u_1\ninst✝² : Fintype ι\nE' : ι → Type u_2\ninst✝¹ : (i : ι) → NormedAddCommGroup (E' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (E' i)\nφ : 𝕜 → (i : ι) → E' i\nh : ∀ (i : ι), DifferentiableAt 𝕜 (fun x => φ x i) x\n⊢ Eq (deriv φ x) fun i => deriv (fun x => φ x i) x","decl":"theorem deriv_pi (h : ∀ i, DifferentiableAt 𝕜 (fun x => φ x i) x) :\n    deriv φ x = fun i => deriv (fun x => φ x i) x :=\n  (hasDerivAt_pi.2 fun i => (h i).hasDerivAt).deriv\n\n"}
{"name":"hasStrictDerivAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : (i : Fin n.succ) → F' i\n⊢ Iff (HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x) (And (HasStrictDerivAt φ (φ' 0) x) (HasStrictDerivAt φs (fun i => φ' i.succ) x))","decl":"theorem hasStrictDerivAt_finCons {φ' : Π i, F' i} :\n    HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x ↔\n      HasStrictDerivAt φ (φ' 0) x ∧ HasStrictDerivAt φs (fun i => φ' i.succ) x :=\n  hasStrictFDerivAt_finCons\n\n"}
{"name":"hasStrictDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\n⊢ Iff (HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x) (And (HasStrictDerivAt φ φ' x) (HasStrictDerivAt φs φs' x))","decl":"/-- A variant of `hasStrictDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasStrictDerivAt_finCons' {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)} :\n    HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x ↔\n      HasStrictDerivAt φ φ' x ∧ HasStrictDerivAt φs φs' x :=\n  hasStrictDerivAt_finCons\n\n"}
{"name":"HasStrictDerivAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\nh : HasStrictDerivAt φ φ' x\nhs : HasStrictDerivAt φs φs' x\n⊢ HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x","decl":"theorem HasStrictDerivAt.finCons {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)}\n    (h : HasStrictDerivAt φ φ' x) (hs : HasStrictDerivAt φs φs' x) :\n    HasStrictDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x :=\n  hasStrictDerivAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasDerivAtFilter_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : (i : Fin n.succ) → F' i\nl : Filter 𝕜\n⊢ Iff (HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) φ' x l) (And (HasDerivAtFilter φ (φ' 0) x l) (HasDerivAtFilter φs (fun i => φ' i.succ) x l))","decl":"theorem hasDerivAtFilter_finCons {φ' : Π i, F' i} {l : Filter 𝕜} :\n    HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) φ' x l ↔\n      HasDerivAtFilter φ (φ' 0) x l ∧ HasDerivAtFilter φs (fun i => φ' i.succ) x l :=\n  hasFDerivAtFilter_finCons\n\n"}
{"name":"hasDerivAtFilter_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\nl : Filter 𝕜\n⊢ Iff (HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x l) (And (HasDerivAtFilter φ φ' x l) (HasDerivAtFilter φs φs' x l))","decl":"/-- A variant of `hasDerivAtFilter_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivAtFilter_finCons' {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)} {l : Filter 𝕜} :\n    HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x l ↔\n      HasDerivAtFilter φ φ' x l ∧ HasDerivAtFilter φs φs' x l :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"HasDerivAtFilter.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\nl : Filter 𝕜\nh : HasDerivAtFilter φ φ' x l\nhs : HasDerivAtFilter φs φs' x l\n⊢ HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x l","decl":"theorem HasDerivAtFilter.finCons {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)} {l : Filter 𝕜}\n    (h : HasDerivAtFilter φ φ' x l) (hs : HasDerivAtFilter φs φs' x l) :\n    HasDerivAtFilter (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x l :=\n  hasDerivAtFilter_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasDerivAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : (i : Fin n.succ) → F' i\n⊢ Iff (HasDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x) (And (HasDerivAt φ (φ' 0) x) (HasDerivAt φs (fun i => φ' i.succ) x))","decl":"theorem hasDerivAt_finCons {φ' : Π i, F' i} :\n    HasDerivAt (fun x => Fin.cons (φ x) (φs x)) φ' x ↔\n      HasDerivAt φ (φ' 0) x ∧ HasDerivAt φs (fun i => φ' i.succ) x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"hasDerivAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\n⊢ Iff (HasDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x) (And (HasDerivAt φ φ' x) (HasDerivAt φs φs' x))","decl":"/-- A variant of `hasDerivAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivAt_finCons' {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)} :\n    HasDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x ↔\n      HasDerivAt φ φ' x ∧ HasDerivAt φs φs' x :=\n  hasDerivAt_finCons\n\n"}
{"name":"HasDerivAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\nh : HasDerivAt φ φ' x\nhs : HasDerivAt φs φs' x\n⊢ HasDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x","decl":"theorem HasDerivAt.finCons {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)}\n    (h : HasDerivAt φ φ' x) (hs : HasDerivAt φs φs' x) :\n    HasDerivAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') x :=\n  hasDerivAt_finCons'.mpr ⟨h, hs⟩\n\n"}
{"name":"hasDerivWithinAt_finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : (i : Fin n.succ) → F' i\n⊢ Iff (HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) φ' s x) (And (HasDerivWithinAt φ (φ' 0) s x) (HasDerivWithinAt φs (fun i => φ' i.succ) s x))","decl":"theorem hasDerivWithinAt_finCons {φ' : Π i, F' i} :\n    HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) φ' s x ↔\n      HasDerivWithinAt φ (φ' 0) s x ∧ HasDerivWithinAt φs (fun i => φ' i.succ) s x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"hasDerivWithinAt_finCons'","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\n⊢ Iff (HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') s x) (And (HasDerivWithinAt φ φ' s x) (HasDerivWithinAt φs φs' s x))","decl":"/-- A variant of `hasDerivWithinAt_finCons` where the derivative variables are free on the RHS\ninstead. -/\ntheorem hasDerivWithinAt_finCons' {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)} :\n    HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') s x ↔\n      HasDerivWithinAt φ φ' s x ∧ HasDerivWithinAt φs φs' s x :=\n  hasDerivAtFilter_finCons\n\n"}
{"name":"HasDerivWithinAt.finCons","module":"Mathlib.Analysis.Calculus.Deriv.Prod","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nn : Nat\nF' : Fin n.succ → Type u_1\ninst✝¹ : (i : Fin n.succ) → NormedAddCommGroup (F' i)\ninst✝ : (i : Fin n.succ) → NormedSpace 𝕜 (F' i)\nφ : 𝕜 → F' 0\nφs : 𝕜 → (i : Fin n) → F' i.succ\nφ' : F' 0\nφs' : (i : Fin n) → F' i.succ\nh : HasDerivWithinAt φ φ' s x\nhs : HasDerivWithinAt φs φs' s x\n⊢ HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') s x","decl":"theorem HasDerivWithinAt.finCons {φ' : F' 0} {φs' : Π i, F' (Fin.succ i)}\n    (h : HasDerivWithinAt φ φ' s x) (hs : HasDerivWithinAt φs φs' s x) :\n    HasDerivWithinAt (fun x => Fin.cons (φ x) (φs x)) (Fin.cons φ' φs') s x :=\n  hasDerivWithinAt_finCons'.mpr ⟨h, hs⟩\n\n-- TODO: write the `Fin.cons` versions of `derivWithin_pi` and `deriv_pi`\n\n"}
