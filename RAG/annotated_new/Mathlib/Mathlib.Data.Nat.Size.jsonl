{"name":"Nat.shiftLeft_eq_mul_pow","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\n⊢ Eq (HShiftLeft.hShiftLeft m n) (HMul.hMul m (HPow.hPow 2 n))","decl":"theorem shiftLeft_eq_mul_pow (m) : ∀ n, m <<< n = m * 2 ^ n := shiftLeft_eq _\n\n"}
{"name":"Nat.shiftLeft'_tt_eq_mul_pow","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\n⊢ Eq (HAdd.hAdd (Nat.shiftLeft' Bool.true m n) 1) (HMul.hMul (HAdd.hAdd m 1) (HPow.hPow 2 n))","decl":"theorem shiftLeft'_tt_eq_mul_pow (m) : ∀ n, shiftLeft' true m n + 1 = (m + 1) * 2 ^ n\n  | 0 => by simp [shiftLeft', pow_zero, Nat.one_mul]\n  | k + 1 => by\n    rw [shiftLeft', bit_val, Bool.toNat_true, add_assoc, ← Nat.mul_add_one,\n      shiftLeft'_tt_eq_mul_pow m k, mul_left_comm, mul_comm 2, pow_succ]\n\n"}
{"name":"Nat.shiftLeft'_ne_zero_left","module":"Mathlib.Data.Nat.Size","initialProofState":"b : Bool\nm : Nat\nh : Ne m 0\nn : Nat\n⊢ Ne (Nat.shiftLeft' b m n) 0","decl":"theorem shiftLeft'_ne_zero_left (b) {m} (h : m ≠ 0) (n) : shiftLeft' b m n ≠ 0 := by\n  induction n <;> simp [bit_ne_zero, shiftLeft', *]\n\n"}
{"name":"Nat.shiftLeft'_tt_ne_zero","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\na✝ : Ne n 0\n⊢ Ne (Nat.shiftLeft' Bool.true m n) 0","decl":"theorem shiftLeft'_tt_ne_zero (m) : ∀ {n}, (n ≠ 0) → shiftLeft' true m n ≠ 0\n  | 0, h => absurd rfl h\n  | succ _, _ => by dsimp [shiftLeft', bit]; omega\n\n"}
{"name":"Nat.size_zero","module":"Mathlib.Data.Nat.Size","initialProofState":"⊢ Eq (Nat.size 0) 0","decl":"@[simp]\ntheorem size_zero : size 0 = 0 := by simp [size]\n\n"}
{"name":"Nat.size_bit","module":"Mathlib.Data.Nat.Size","initialProofState":"b : Bool\nn : Nat\nh : Ne (Nat.bit b n) 0\n⊢ Eq (Nat.bit b n).size n.size.succ","decl":"@[simp]\ntheorem size_bit {b n} (h : bit b n ≠ 0) : size (bit b n) = succ (size n) := by\n  unfold size\n  conv =>\n    lhs\n    rw [binaryRec]\n    simp [h]\n\n"}
{"name":"Nat.size_one","module":"Mathlib.Data.Nat.Size","initialProofState":"⊢ Eq (Nat.size 1) 1","decl":"@[simp]\ntheorem size_one : size 1 = 1 :=\n  show size (bit true 0) = 1 by rw [size_bit, size_zero]; exact Nat.one_ne_zero\n\n"}
{"name":"Nat.size_shiftLeft'","module":"Mathlib.Data.Nat.Size","initialProofState":"b : Bool\nm n : Nat\nh : Ne (Nat.shiftLeft' b m n) 0\n⊢ Eq (Nat.shiftLeft' b m n).size (HAdd.hAdd m.size n)","decl":"@[simp]\ntheorem size_shiftLeft' {b m n} (h : shiftLeft' b m n ≠ 0) :\n    size (shiftLeft' b m n) = size m + n := by\n  induction n with\n  | zero => simp [shiftLeft']\n  | succ n IH =>\n    simp only [shiftLeft', ne_eq] at h ⊢\n    rw [size_bit h, Nat.add_succ]\n    by_cases s0 : shiftLeft' b m n = 0\n    case neg => rw [IH s0]\n    rw [s0] at h ⊢\n    cases b; · exact absurd rfl h\n    have : shiftLeft' true m n + 1 = 1 := congr_arg (· + 1) s0\n    rw [shiftLeft'_tt_eq_mul_pow] at this\n    obtain rfl := succ.inj (eq_one_of_dvd_one ⟨_, this.symm⟩)\n    simp only [zero_add, one_mul] at this\n    obtain rfl : n = 0 := not_ne_iff.1 fun hn ↦ ne_of_gt (Nat.one_lt_pow hn (by decide)) this\n    rw [add_zero]\n\n-- TODO: decide whether `Nat.shiftLeft_eq` (which rewrites the LHS into a power) should be a simp\n-- lemma; it was not in mathlib3. Until then, tell the simpNF linter to ignore the issue.\n"}
{"name":"Nat.size_shiftLeft","module":"Mathlib.Data.Nat.Size","initialProofState":"m : Nat\nh : Ne m 0\nn : Nat\n⊢ Eq (HShiftLeft.hShiftLeft m n).size (HAdd.hAdd m.size n)","decl":"@[simp, nolint simpNF]\ntheorem size_shiftLeft {m} (h : m ≠ 0) (n) : size (m <<< n) = size m + n := by\n  simp only [size_shiftLeft' (shiftLeft'_ne_zero_left _ h _), ← shiftLeft'_false]\n\n"}
{"name":"Nat.lt_size_self","module":"Mathlib.Data.Nat.Size","initialProofState":"n : Nat\n⊢ LT.lt n (HPow.hPow 2 n.size)","decl":"theorem lt_size_self (n : ℕ) : n < 2 ^ size n := by\n  rw [← one_shiftLeft]\n  have : ∀ {n}, n = 0 → n < 1 <<< (size n) := by simp\n  refine binaryRec ?_ ?_ n\n  · apply this rfl\n  intro b n IH\n  by_cases h : bit b n = 0\n  · apply this h\n  rw [size_bit h, shiftLeft_succ, shiftLeft_eq, one_mul]\n  cases b <;> dsimp [bit] <;> omega\n\n"}
{"name":"Nat.size_le","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\n⊢ Iff (LE.le m.size n) (LT.lt m (HPow.hPow 2 n))","decl":"theorem size_le {m n : ℕ} : size m ≤ n ↔ m < 2 ^ n :=\n  ⟨fun h => lt_of_lt_of_le (lt_size_self _) (pow_le_pow_of_le_right (by decide) h), by\n    rw [← one_shiftLeft]\n    induction m using binaryRec generalizing n with\n    | z => simp\n    | f b m IH =>\n      intro h\n      by_cases e : bit b m = 0\n      · simp [e]\n      rw [size_bit e]\n      cases n with\n      | zero => exact e.elim (Nat.eq_zero_of_le_zero (le_of_lt_succ h))\n      | succ n =>\n        apply succ_le_succ (IH _)\n        apply Nat.lt_of_mul_lt_mul_left (a := 2)\n        simp only [shiftLeft_succ] at *\n        refine lt_of_le_of_lt ?_ h\n        cases b <;> dsimp [bit] <;> omega⟩\n\n"}
{"name":"Nat.lt_size","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m n.size) (LE.le (HPow.hPow 2 m) n)","decl":"theorem lt_size {m n : ℕ} : m < size n ↔ 2 ^ m ≤ n := by\n  rw [← not_lt, Decidable.iff_not_comm, not_lt, size_le]\n\n"}
{"name":"Nat.size_pos","module":"Mathlib.Data.Nat.Size","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 n.size) (LT.lt 0 n)","decl":"theorem size_pos {n : ℕ} : 0 < size n ↔ 0 < n := by rw [lt_size]; rfl\n\n"}
{"name":"Nat.size_eq_zero","module":"Mathlib.Data.Nat.Size","initialProofState":"n : Nat\n⊢ Iff (Eq n.size 0) (Eq n 0)","decl":"theorem size_eq_zero {n : ℕ} : size n = 0 ↔ n = 0 := by\n  simpa [Nat.pos_iff_ne_zero, not_iff_not] using size_pos\n\n"}
{"name":"Nat.size_pow","module":"Mathlib.Data.Nat.Size","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow 2 n).size (HAdd.hAdd n 1)","decl":"theorem size_pow {n : ℕ} : size (2 ^ n) = n + 1 :=\n  le_antisymm (size_le.2 <| Nat.pow_lt_pow_right (by decide) (lt_succ_self _))\n    (lt_size.2 <| le_rfl)\n\n"}
{"name":"Nat.size_le_size","module":"Mathlib.Data.Nat.Size","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ LE.le m.size n.size","decl":"theorem size_le_size {m n : ℕ} (h : m ≤ n) : size m ≤ size n :=\n  size_le.2 <| lt_of_le_of_lt h (lt_size_self _)\n\n"}
{"name":"Nat.size_eq_bits_len","module":"Mathlib.Data.Nat.Size","initialProofState":"n : Nat\n⊢ Eq n.bits.length n.size","decl":"theorem size_eq_bits_len (n : ℕ) : n.bits.length = n.size := by\n  induction n using Nat.binaryRec' with\n  | z => simp\n  | f _ _ h ih =>\n    rw [size_bit, bits_append_bit _ _ h]\n    · simp [ih]\n    · simpa [bit_eq_zero_iff]\n\n"}
