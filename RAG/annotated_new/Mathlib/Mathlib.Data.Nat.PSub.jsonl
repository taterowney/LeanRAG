{"name":"Nat.ppred_zero","module":"Mathlib.Data.Nat.PSub","initialProofState":"⊢ Eq (Nat.ppred 0) Option.none","decl":"@[simp]\ntheorem ppred_zero : ppred 0 = none := rfl\n\n"}
{"name":"Nat.ppred_succ","module":"Mathlib.Data.Nat.PSub","initialProofState":"n : Nat\n⊢ Eq n.succ.ppred (Option.some n)","decl":"@[simp]\ntheorem ppred_succ {n : ℕ} : ppred (succ n) = some n := rfl\n\n"}
{"name":"Nat.psub_zero","module":"Mathlib.Data.Nat.PSub","initialProofState":"m : Nat\n⊢ Eq (m.psub 0) (Option.some m)","decl":"@[simp]\ntheorem psub_zero {m : ℕ} : psub m 0 = some m := rfl\n\n"}
{"name":"Nat.psub_succ","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\n⊢ Eq (m.psub n.succ) (Bind.bind (m.psub n) Nat.ppred)","decl":"@[simp]\ntheorem psub_succ {m n : ℕ} : psub m (succ n) = psub m n >>= ppred := rfl\n\n"}
{"name":"Nat.pred_eq_ppred","module":"Mathlib.Data.Nat.PSub","initialProofState":"n : Nat\n⊢ Eq n.pred (n.ppred.getD 0)","decl":"theorem pred_eq_ppred (n : ℕ) : pred n = (ppred n).getD 0 := by cases n <;> rfl\n\n"}
{"name":"Nat.sub_eq_psub","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\n⊢ Eq (HSub.hSub m n) ((m.psub n).getD 0)","decl":"theorem sub_eq_psub (m : ℕ) : ∀ n, m - n = (psub m n).getD 0\n  | 0 => rfl\n  | n + 1 => (pred_eq_ppred (m - n)).trans <| by rw [sub_eq_psub m n, psub]; cases psub m n <;> rfl\n\n"}
{"name":"Nat.ppred_eq_some","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\n⊢ Iff (Eq n.ppred (Option.some m)) (Eq m.succ n)","decl":"@[simp]\ntheorem ppred_eq_some {m : ℕ} : ∀ {n}, ppred n = some m ↔ succ m = n\n  | 0 => by constructor <;> intro h <;> contradiction\n  | n + 1 => by constructor <;> intro h <;> injection h <;> subst m <;> rfl\n\n-- Porting note: `contradiction` required an `intro` for the goals\n-- `ppred (n + 1) = none → n + 1 = 0` and `n + 1 = 0 → ppred (n + 1) = none`\n\n"}
{"name":"Nat.ppred_eq_none","module":"Mathlib.Data.Nat.PSub","initialProofState":"n : Nat\n⊢ Iff (Eq n.ppred Option.none) (Eq n 0)","decl":"@[simp]\ntheorem ppred_eq_none : ∀ {n : ℕ}, ppred n = none ↔ n = 0\n  | 0 => by simp\n  | n + 1 => by constructor <;> intro <;> contradiction\n\n"}
{"name":"Nat.psub_eq_some","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n k : Nat\n⊢ Iff (Eq (m.psub n) (Option.some k)) (Eq (HAdd.hAdd k n) m)","decl":"theorem psub_eq_some {m : ℕ} : ∀ {n k}, psub m n = some k ↔ k + n = m\n  | 0, k => by simp [eq_comm]\n  | n + 1, k => by\n    apply Option.bind_eq_some.trans\n    simp only [psub_eq_some, ppred_eq_some]\n    simp [add_comm, add_left_comm]\n\n"}
{"name":"Nat.psub_eq_none","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\n⊢ Iff (Eq (m.psub n) Option.none) (LT.lt m n)","decl":"theorem psub_eq_none {m n : ℕ} : psub m n = none ↔ m < n := by\n  rcases s : psub m n <;> simp [eq_comm]\n  · refine lt_of_not_ge fun h => ?_\n    obtain ⟨k, e⟩ := le.dest h\n    injection s.symm.trans (psub_eq_some.2 <| (add_comm _ _).trans e)\n  · rw [← psub_eq_some.1 s]\n    apply Nat.le_add_left\n\n"}
{"name":"Nat.ppred_eq_pred","module":"Mathlib.Data.Nat.PSub","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq n.ppred (Option.some n.pred)","decl":"theorem ppred_eq_pred {n} (h : 0 < n) : ppred n = some (pred n) :=\n  ppred_eq_some.2 <| succ_pred_eq_of_pos h\n\n"}
{"name":"Nat.psub_eq_sub","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Eq (m.psub n) (Option.some (HSub.hSub m n))","decl":"theorem psub_eq_sub {m n} (h : n ≤ m) : psub m n = some (m - n) :=\n  psub_eq_some.2 <| Nat.sub_add_cancel h\n\n-- Porting note: we only have the simp lemma `Option.bind_some` which uses `Option.bind` not `>>=`\n"}
{"name":"Nat.psub_add","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n k : Nat\n⊢ Eq (m.psub (HAdd.hAdd n k)) (Bind.bind (m.psub n) fun __do_lift => __do_lift.psub k)","decl":"theorem psub_add (m n k) :\n    psub m (n + k) = (do psub (← psub m n) k) := by\n    induction k with\n    | zero => simp only [zero_eq, add_zero, psub_zero, Option.bind_eq_bind, Option.bind_some]\n    | succ n ih => simp only [ih, add_succ, psub_succ, bind_assoc]\n\n"}
{"name":"Nat.psub'_eq_psub","module":"Mathlib.Data.Nat.PSub","initialProofState":"m n : Nat\n⊢ Eq (m.psub' n) (m.psub n)","decl":"theorem psub'_eq_psub (m n) : psub' m n = psub m n := by\n  rw [psub']\n  split_ifs with h\n  · exact (psub_eq_sub h).symm\n  · exact (psub_eq_none.2 (not_le.1 h)).symm\n\n"}
