{"name":"AddCon.mk.sizeOf_spec","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝¹ : Add M\ninst✝ : SizeOf M\ntoSetoid : Setoid M\nadd' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HAdd.hAdd w y) (HAdd.hAdd x z)\n⊢ Eq (SizeOf.sizeOf { toSetoid := toSetoid, add' := add' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSetoid))","decl":"/-- A congruence relation on a type with an addition is an equivalence relation which\n    preserves addition. -/\nstructure AddCon [Add M] extends Setoid M where\n  /-- Additive congruence relations are closed under addition -/\n  add' : ∀ {w x y z}, r w x → r y z → r (w + y) (x + z)\n\n"}
{"name":"AddCon.mk.injEq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\ntoSetoid✝ : Setoid M\nadd'✝ : ∀ {w x y z : M}, toSetoid✝ w x → toSetoid✝ y z → toSetoid✝ (HAdd.hAdd w y) (HAdd.hAdd x z)\ntoSetoid : Setoid M\nadd' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HAdd.hAdd w y) (HAdd.hAdd x z)\n⊢ Eq (Eq { toSetoid := toSetoid✝, add' := add'✝ } { toSetoid := toSetoid, add' := add' }) (Eq toSetoid✝ toSetoid)","decl":"/-- A congruence relation on a type with an addition is an equivalence relation which\n    preserves addition. -/\nstructure AddCon [Add M] extends Setoid M where\n  /-- Additive congruence relations are closed under addition -/\n  add' : ∀ {w x y z}, r w x → r y z → r (w + y) (x + z)\n\n"}
{"name":"AddCon.add'","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nself : AddCon M\nw x y z : M\na✝¹ : self.toSetoid w x\na✝ : self.toSetoid y z\n⊢ self.toSetoid (HAdd.hAdd w y) (HAdd.hAdd x z)","decl":"/-- A congruence relation on a type with an addition is an equivalence relation which\n    preserves addition. -/\nstructure AddCon [Add M] extends Setoid M where\n  /-- Additive congruence relations are closed under addition -/\n  add' : ∀ {w x y z}, r w x → r y z → r (w + y) (x + z)\n\n"}
{"name":"AddCon.mk.inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\ntoSetoid✝ : Setoid M\nadd'✝ : ∀ {w x y z : M}, toSetoid✝ w x → toSetoid✝ y z → toSetoid✝ (HAdd.hAdd w y) (HAdd.hAdd x z)\ntoSetoid : Setoid M\nadd' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HAdd.hAdd w y) (HAdd.hAdd x z)\nx✝ : Eq { toSetoid := toSetoid✝, add' := add'✝ } { toSetoid := toSetoid, add' := add' }\n⊢ Eq toSetoid✝ toSetoid","decl":"/-- A congruence relation on a type with an addition is an equivalence relation which\n    preserves addition. -/\nstructure AddCon [Add M] extends Setoid M where\n  /-- Additive congruence relations are closed under addition -/\n  add' : ∀ {w x y z}, r w x → r y z → r (w + y) (x + z)\n\n"}
{"name":"Con.mul'","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nself : Con M\nw x y z : M\na✝¹ : self.toSetoid w x\na✝ : self.toSetoid y z\n⊢ self.toSetoid (HMul.hMul w y) (HMul.hMul x z)","decl":"/-- A congruence relation on a type with a multiplication is an equivalence relation which\n    preserves multiplication. -/\n@[to_additive AddCon]\nstructure Con [Mul M] extends Setoid M where\n  /-- Congruence relations are closed under multiplication -/\n  mul' : ∀ {w x y z}, r w x → r y z → r (w * y) (x * z)\n\n"}
{"name":"Con.mk.sizeOf_spec","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝¹ : Mul M\ninst✝ : SizeOf M\ntoSetoid : Setoid M\nmul' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HMul.hMul w y) (HMul.hMul x z)\n⊢ Eq (SizeOf.sizeOf { toSetoid := toSetoid, mul' := mul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSetoid))","decl":"/-- A congruence relation on a type with a multiplication is an equivalence relation which\n    preserves multiplication. -/\n@[to_additive AddCon]\nstructure Con [Mul M] extends Setoid M where\n  /-- Congruence relations are closed under multiplication -/\n  mul' : ∀ {w x y z}, r w x → r y z → r (w * y) (x * z)\n\n"}
{"name":"Con.mk.inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\ntoSetoid✝ : Setoid M\nmul'✝ : ∀ {w x y z : M}, toSetoid✝ w x → toSetoid✝ y z → toSetoid✝ (HMul.hMul w y) (HMul.hMul x z)\ntoSetoid : Setoid M\nmul' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HMul.hMul w y) (HMul.hMul x z)\nx✝ : Eq { toSetoid := toSetoid✝, mul' := mul'✝ } { toSetoid := toSetoid, mul' := mul' }\n⊢ Eq toSetoid✝ toSetoid","decl":"/-- A congruence relation on a type with a multiplication is an equivalence relation which\n    preserves multiplication. -/\n@[to_additive AddCon]\nstructure Con [Mul M] extends Setoid M where\n  /-- Congruence relations are closed under multiplication -/\n  mul' : ∀ {w x y z}, r w x → r y z → r (w * y) (x * z)\n\n"}
{"name":"Con.mk.injEq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\ntoSetoid✝ : Setoid M\nmul'✝ : ∀ {w x y z : M}, toSetoid✝ w x → toSetoid✝ y z → toSetoid✝ (HMul.hMul w y) (HMul.hMul x z)\ntoSetoid : Setoid M\nmul' : ∀ {w x y z : M}, toSetoid w x → toSetoid y z → toSetoid (HMul.hMul w y) (HMul.hMul x z)\n⊢ Eq (Eq { toSetoid := toSetoid✝, mul' := mul'✝ } { toSetoid := toSetoid, mul' := mul' }) (Eq toSetoid✝ toSetoid)","decl":"/-- A congruence relation on a type with a multiplication is an equivalence relation which\n    preserves multiplication. -/\n@[to_additive AddCon]\nstructure Con [Mul M] extends Setoid M where\n  /-- Congruence relations are closed under multiplication -/\n  mul' : ∀ {w x y z}, r w x → r y z → r (w * y) (x * z)\n\n"}
{"name":"Con.rel_eq_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\n⊢ Eq ⇑c.toSetoid ⇑c","decl":"@[to_additive (attr := simp)]\ntheorem rel_eq_coe (c : Con M) : c.r = c :=\n  rfl\n\n"}
{"name":"AddCon.rel_eq_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\n⊢ Eq ⇑c.toSetoid ⇑c","decl":"@[to_additive (attr := simp)]\ntheorem rel_eq_coe (c : Con M) : c.r = c :=\n  rfl\n\n"}
{"name":"Con.refl","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nx : M\n⊢ c x x","decl":"/-- Congruence relations are reflexive. -/\n@[to_additive \"Additive congruence relations are reflexive.\"]\nprotected theorem refl (x) : c x x :=\n  c.toSetoid.refl' x\n\n"}
{"name":"AddCon.refl","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nx : M\n⊢ c x x","decl":"/-- Congruence relations are reflexive. -/\n@[to_additive \"Additive congruence relations are reflexive.\"]\nprotected theorem refl (x) : c x x :=\n  c.toSetoid.refl' x\n\n"}
{"name":"AddCon.symm","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nx y : M\na✝ : c x y\n⊢ c y x","decl":"/-- Congruence relations are symmetric. -/\n@[to_additive \"Additive congruence relations are symmetric.\"]\nprotected theorem symm {x y} : c x y → c y x := c.toSetoid.symm'\n\n"}
{"name":"Con.symm","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nx y : M\na✝ : c x y\n⊢ c y x","decl":"/-- Congruence relations are symmetric. -/\n@[to_additive \"Additive congruence relations are symmetric.\"]\nprotected theorem symm {x y} : c x y → c y x := c.toSetoid.symm'\n\n"}
{"name":"AddCon.trans","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nx y z : M\na✝¹ : c x y\na✝ : c y z\n⊢ c x z","decl":"/-- Congruence relations are transitive. -/\n@[to_additive \"Additive congruence relations are transitive.\"]\nprotected theorem trans {x y z} : c x y → c y z → c x z := c.toSetoid.trans'\n\n"}
{"name":"Con.trans","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nx y z : M\na✝¹ : c x y\na✝ : c y z\n⊢ c x z","decl":"/-- Congruence relations are transitive. -/\n@[to_additive \"Additive congruence relations are transitive.\"]\nprotected theorem trans {x y z} : c x y → c y z → c x z := c.toSetoid.trans'\n\n"}
{"name":"AddCon.add","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nw x y z : M\na✝¹ : c w x\na✝ : c y z\n⊢ c (HAdd.hAdd w y) (HAdd.hAdd x z)","decl":"/-- Multiplicative congruence relations preserve multiplication. -/\n@[to_additive \"Additive congruence relations preserve addition.\"]\nprotected theorem mul {w x y z} : c w x → c y z → c (w * y) (x * z) := c.mul'\n\n"}
{"name":"Con.mul","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nw x y z : M\na✝¹ : c w x\na✝ : c y z\n⊢ c (HMul.hMul w y) (HMul.hMul x z)","decl":"/-- Multiplicative congruence relations preserve multiplication. -/\n@[to_additive \"Additive congruence relations preserve addition.\"]\nprotected theorem mul {w x y z} : c w x → c y z → c (w * y) (x * z) := c.mul'\n\n"}
{"name":"AddCon.rel_mk","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\ns : Setoid M\nh : ∀ {w x y z : M}, s w x → s y z → s (HAdd.hAdd w y) (HAdd.hAdd x z)\na b : M\n⊢ Iff ({ toSetoid := s, add' := h } a b) (s a b)","decl":"@[to_additive (attr := simp)]\ntheorem rel_mk {s : Setoid M} {h a b} : Con.mk s h a b ↔ r a b :=\n  Iff.rfl\n\n"}
{"name":"Con.rel_mk","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\ns : Setoid M\nh : ∀ {w x y z : M}, s w x → s y z → s (HMul.hMul w y) (HMul.hMul x z)\na b : M\n⊢ Iff ({ toSetoid := s, mul' := h } a b) (s a b)","decl":"@[to_additive (attr := simp)]\ntheorem rel_mk {s : Setoid M} {h a b} : Con.mk s h a b ↔ r a b :=\n  Iff.rfl\n\n"}
{"name":"Con.ext'","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\nH : Eq ⇑c ⇑d\n⊢ Eq c d","decl":"/-- The map sending a congruence relation to its underlying binary relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying binary relation\nis injective.\"]\ntheorem ext' {c d : Con M} (H : ⇑c = ⇑d) : c = d := DFunLike.coe_injective H\n\n"}
{"name":"AddCon.ext'","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\nH : Eq ⇑c ⇑d\n⊢ Eq c d","decl":"/-- The map sending a congruence relation to its underlying binary relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying binary relation\nis injective.\"]\ntheorem ext' {c d : Con M} (H : ⇑c = ⇑d) : c = d := DFunLike.coe_injective H\n\n"}
{"name":"AddCon.ext_iff","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Iff (Eq c d) (∀ (x y : M), Iff (c x y) (d x y))","decl":"/-- Extensionality rule for congruence relations. -/\n@[to_additive (attr := ext) \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : ∀ x y, c x y ↔ d x y) : c = d :=\n  ext' <| by ext; apply H\n\n"}
{"name":"Con.ext_iff","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Iff (Eq c d) (∀ (x y : M), Iff (c x y) (d x y))","decl":"/-- Extensionality rule for congruence relations. -/\n@[to_additive (attr := ext) \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : ∀ x y, c x y ↔ d x y) : c = d :=\n  ext' <| by ext; apply H\n\n"}
{"name":"Con.ext","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\nH : ∀ (x y : M), Iff (c x y) (d x y)\n⊢ Eq c d","decl":"/-- Extensionality rule for congruence relations. -/\n@[to_additive (attr := ext) \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : ∀ x y, c x y ↔ d x y) : c = d :=\n  ext' <| by ext; apply H\n\n"}
{"name":"AddCon.ext","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\nH : ∀ (x y : M), Iff (c x y) (d x y)\n⊢ Eq c d","decl":"/-- Extensionality rule for congruence relations. -/\n@[to_additive (attr := ext) \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : ∀ x y, c x y ↔ d x y) : c = d :=\n  ext' <| by ext; apply H\n\n"}
{"name":"AddCon.toSetoid_inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\nH : Eq c.toSetoid d.toSetoid\n⊢ Eq c d","decl":"/-- The map sending a congruence relation to its underlying equivalence relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying equivalence\nrelation is injective.\"]\ntheorem toSetoid_inj {c d : Con M} (H : c.toSetoid = d.toSetoid) : c = d :=\n  ext <| Setoid.ext_iff.1 H\n\n"}
{"name":"Con.toSetoid_inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\nH : Eq c.toSetoid d.toSetoid\n⊢ Eq c d","decl":"/-- The map sending a congruence relation to its underlying equivalence relation is injective. -/\n@[to_additive \"The map sending an additive congruence relation to its underlying equivalence\nrelation is injective.\"]\ntheorem toSetoid_inj {c d : Con M} (H : c.toSetoid = d.toSetoid) : c = d :=\n  ext <| Setoid.ext_iff.1 H\n\n"}
{"name":"AddCon.coe_inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Iff (Eq ⇑c ⇑d) (Eq c d)","decl":"/-- Two congruence relations are equal iff their underlying binary relations are equal. -/\n@[to_additive \"Two additive congruence relations are equal iff their underlying binary relations\nare equal.\"]\ntheorem coe_inj {c d : Con M} : ⇑c = ⇑d ↔ c = d := DFunLike.coe_injective.eq_iff\n\n"}
{"name":"Con.coe_inj","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Iff (Eq ⇑c ⇑d) (Eq c d)","decl":"/-- Two congruence relations are equal iff their underlying binary relations are equal. -/\n@[to_additive \"Two additive congruence relations are equal iff their underlying binary relations\nare equal.\"]\ntheorem coe_inj {c d : Con M} : ⇑c = ⇑d ↔ c = d := DFunLike.coe_injective.eq_iff\n\n"}
{"name":"Con.quot_mk_eq_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_4\ninst✝ : Mul M\nc : Con M\nx : M\n⊢ Eq (Quot.mk (⇑c) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem quot_mk_eq_coe {M : Type*} [Mul M] (c : Con M) (x : M) : Quot.mk c x = (x : c.Quotient) :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore `elab_as_elim`\n"}
{"name":"AddCon.quot_mk_eq_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_4\ninst✝ : Add M\nc : AddCon M\nx : M\n⊢ Eq (Quot.mk (⇑c) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem quot_mk_eq_coe {M : Type*} [Mul M] (c : Con M) (x : M) : Quot.mk c x = (x : c.Quotient) :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: restore `elab_as_elim`\n"}
{"name":"Con.hrec_on₂_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\ncM : Con M\ncN : Con N\nφ : cM.Quotient → cN.Quotient → Sort u_4\na : M\nb : N\nf : (x : M) → (y : N) → φ ↑x ↑y\nh : ∀ (x : M) (y : N) (x' : M) (y' : N), cM x x' → cN y y' → HEq (f x y) (f x' y')\n⊢ Eq (Con.hrecOn₂ (↑a) (↑b) f h) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem hrec_on₂_coe {cM : Con M} {cN : Con N} {φ : cM.Quotient → cN.Quotient → Sort*} (a : M)\n    (b : N) (f : ∀ (x : M) (y : N), φ x y)\n    (h : ∀ x y x' y', cM x x' → cN y y' → HEq (f x y) (f x' y')) :\n    Con.hrecOn₂ (↑a) (↑b) f h = f a b :=\n  rfl\n\n"}
{"name":"AddCon.hrec_on₂_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\ncM : AddCon M\ncN : AddCon N\nφ : cM.Quotient → cN.Quotient → Sort u_4\na : M\nb : N\nf : (x : M) → (y : N) → φ ↑x ↑y\nh : ∀ (x : M) (y : N) (x' : M) (y' : N), cM x x' → cN y y' → HEq (f x y) (f x' y')\n⊢ Eq (AddCon.hrecOn₂ (↑a) (↑b) f h) (f a b)","decl":"@[to_additive (attr := simp)]\ntheorem hrec_on₂_coe {cM : Con M} {cN : Con N} {φ : cM.Quotient → cN.Quotient → Sort*} (a : M)\n    (b : N) (f : ∀ (x : M) (y : N), φ x y)\n    (h : ∀ x y x' y', cM x x' → cN y y' → HEq (f x y) (f x' y')) :\n    Con.hrecOn₂ (↑a) (↑b) f h = f a b :=\n  rfl\n\n"}
{"name":"Con.induction_on","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nC : c.Quotient → Prop\nq : c.Quotient\nH : ∀ (x : M), C ↑x\n⊢ C q","decl":"/-- The inductive principle used to prove propositions about the elements of a quotient by a\n    congruence relation. -/\n@[to_additive (attr := elab_as_elim) \"The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation.\"]\nprotected theorem induction_on {C : c.Quotient → Prop} (q : c.Quotient) (H : ∀ x : M, C x) : C q :=\n  Quotient.inductionOn' q H\n\n"}
{"name":"AddCon.induction_on","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nC : c.Quotient → Prop\nq : c.Quotient\nH : ∀ (x : M), C ↑x\n⊢ C q","decl":"/-- The inductive principle used to prove propositions about the elements of a quotient by a\n    congruence relation. -/\n@[to_additive (attr := elab_as_elim) \"The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation.\"]\nprotected theorem induction_on {C : c.Quotient → Prop} (q : c.Quotient) (H : ∀ x : M, C x) : C q :=\n  Quotient.inductionOn' q H\n\n"}
{"name":"AddCon.induction_on₂","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nc : AddCon M\nd : AddCon N\nC : c.Quotient → d.Quotient → Prop\np : c.Quotient\nq : d.Quotient\nH : ∀ (x : M) (y : N), C ↑x ↑y\n⊢ C p q","decl":"/-- A version of `Con.induction_on` for predicates which take two arguments. -/\n@[to_additive (attr := elab_as_elim) \"A version of `AddCon.induction_on` for predicates which take\ntwo arguments.\"]\nprotected theorem induction_on₂ {d : Con N} {C : c.Quotient → d.Quotient → Prop} (p : c.Quotient)\n    (q : d.Quotient) (H : ∀ (x : M) (y : N), C x y) : C p q :=\n  Quotient.inductionOn₂' p q H\n\n"}
{"name":"Con.induction_on₂","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nc : Con M\nd : Con N\nC : c.Quotient → d.Quotient → Prop\np : c.Quotient\nq : d.Quotient\nH : ∀ (x : M) (y : N), C ↑x ↑y\n⊢ C p q","decl":"/-- A version of `Con.induction_on` for predicates which take two arguments. -/\n@[to_additive (attr := elab_as_elim) \"A version of `AddCon.induction_on` for predicates which take\ntwo arguments.\"]\nprotected theorem induction_on₂ {d : Con N} {C : c.Quotient → d.Quotient → Prop} (p : c.Quotient)\n    (q : d.Quotient) (H : ∀ (x : M) (y : N), C x y) : C p q :=\n  Quotient.inductionOn₂' p q H\n\n"}
{"name":"Con.eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\na b : M\n⊢ Iff (Eq ↑a ↑b) (c a b)","decl":"/-- Two elements are related by a congruence relation `c` iff they are represented by the same\n    element of the quotient by `c`. -/\n@[to_additive (attr := simp) \"Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`.\"]\nprotected theorem eq {a b : M} : (a : c.Quotient) = (b : c.Quotient) ↔ c a b :=\n  Quotient.eq''\n\n"}
{"name":"AddCon.eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\na b : M\n⊢ Iff (Eq ↑a ↑b) (c a b)","decl":"/-- Two elements are related by a congruence relation `c` iff they are represented by the same\n    element of the quotient by `c`. -/\n@[to_additive (attr := simp) \"Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`.\"]\nprotected theorem eq {a b : M} : (a : c.Quotient) = (b : c.Quotient) ↔ c a b :=\n  Quotient.eq''\n\n"}
{"name":"AddCon.add_ker_mk_eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\n⊢ Eq (AddCon.addKer AddCon.toQuotient ⋯) c","decl":"/-- The kernel of the quotient map induced by a congruence relation `c` equals `c`. -/\n@[to_additive (attr := simp) \"The kernel of the quotient map induced by an additive congruence\nrelation `c` equals `c`.\"]\ntheorem mul_ker_mk_eq : (mulKer ((↑) : M → c.Quotient) fun _ _ => rfl) = c :=\n  ext fun _ _ => Quotient.eq''\n\n"}
{"name":"Con.mul_ker_mk_eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\n⊢ Eq (Con.mulKer Con.toQuotient ⋯) c","decl":"/-- The kernel of the quotient map induced by a congruence relation `c` equals `c`. -/\n@[to_additive (attr := simp) \"The kernel of the quotient map induced by an additive congruence\nrelation `c` equals `c`.\"]\ntheorem mul_ker_mk_eq : (mulKer ((↑) : M → c.Quotient) fun _ _ => rfl) = c :=\n  ext fun _ _ => Quotient.eq''\n\n"}
{"name":"Con.coe_mul","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\nx y : M\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\n    definition). -/\n@[to_additive (attr := simp) \"The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition).\"]\ntheorem coe_mul (x y : M) : (↑(x * y) : c.Quotient) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"AddCon.coe_add","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\nx y : M\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"/-- The coercion to the quotient of a congruence relation commutes with multiplication (by\n    definition). -/\n@[to_additive (attr := simp) \"The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition).\"]\ntheorem coe_mul (x y : M) : (↑(x * y) : c.Quotient) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"Con.liftOn_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nβ : Sort u_4\nc : Con M\nf : M → β\nh : ∀ (a b : M), c a b → Eq (f a) (f b)\nx : M\n⊢ Eq (Con.liftOn (↑x) f h) (f x)","decl":"/-- Definition of the function on the quotient by a congruence relation `c` induced by a function\n    that is constant on `c`'s equivalence classes. -/\n@[to_additive (attr := simp) \"Definition of the function on the quotient by an additive congruence\nrelation `c` induced by a function that is constant on `c`'s equivalence classes.\"]\nprotected theorem liftOn_coe {β} (c : Con M) (f : M → β) (h : ∀ a b, c a b → f a = f b) (x : M) :\n    Con.liftOn (x : c.Quotient) f h = f x :=\n  rfl\n\n-- The complete lattice of congruence relations on a type\n"}
{"name":"AddCon.liftOn_coe","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nβ : Sort u_4\nc : AddCon M\nf : M → β\nh : ∀ (a b : M), c a b → Eq (f a) (f b)\nx : M\n⊢ Eq (AddCon.liftOn (↑x) f h) (f x)","decl":"/-- Definition of the function on the quotient by a congruence relation `c` induced by a function\n    that is constant on `c`'s equivalence classes. -/\n@[to_additive (attr := simp) \"Definition of the function on the quotient by an additive congruence\nrelation `c` induced by a function that is constant on `c`'s equivalence classes.\"]\nprotected theorem liftOn_coe {β} (c : Con M) (f : M → β) (h : ∀ a b, c a b → f a = f b) (x : M) :\n    Con.liftOn (x : c.Quotient) f h = f x :=\n  rfl\n\n-- The complete lattice of congruence relations on a type\n"}
{"name":"Con.le_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Iff (LE.le c d) (∀ {x y : M}, c x y → d x y)","decl":"/-- Definition of `≤` for congruence relations. -/\n@[to_additive \"Definition of `≤` for additive congruence relations.\"]\ntheorem le_def {c d : Con M} : c ≤ d ↔ ∀ {x y}, c x y → d x y :=\n  Iff.rfl\n\n"}
{"name":"AddCon.le_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Iff (LE.le c d) (∀ {x y : M}, c x y → d x y)","decl":"/-- Definition of `≤` for congruence relations. -/\n@[to_additive \"Definition of `≤` for additive congruence relations.\"]\ntheorem le_def {c d : Con M} : c ≤ d ↔ ∀ {x y}, c x y → d x y :=\n  Iff.rfl\n\n"}
{"name":"Con.sInf_toSetoid","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Con M)\n⊢ Eq (InfSet.sInf S).toSetoid (InfSet.sInf (Set.image Con.toSetoid S))","decl":"/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying equivalence relation. -/\n@[to_additive \"The infimum of a set of additive congruence relations is the same as the infimum of\nthe set's image under the map to the underlying equivalence relation.\"]\ntheorem sInf_toSetoid (S : Set (Con M)) : (sInf S).toSetoid = sInf (toSetoid '' S) :=\n  Setoid.ext fun x y =>\n    ⟨fun h r ⟨c, hS, hr⟩ => by rw [← hr]; exact h c hS, fun h c hS => h c.toSetoid ⟨c, hS, rfl⟩⟩\n\n"}
{"name":"AddCon.sInf_toSetoid","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddCon M)\n⊢ Eq (InfSet.sInf S).toSetoid (InfSet.sInf (Set.image AddCon.toSetoid S))","decl":"/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying equivalence relation. -/\n@[to_additive \"The infimum of a set of additive congruence relations is the same as the infimum of\nthe set's image under the map to the underlying equivalence relation.\"]\ntheorem sInf_toSetoid (S : Set (Con M)) : (sInf S).toSetoid = sInf (toSetoid '' S) :=\n  Setoid.ext fun x y =>\n    ⟨fun h r ⟨c, hS, hr⟩ => by rw [← hr]; exact h c hS, fun h c hS => h c.toSetoid ⟨c, hS, rfl⟩⟩\n\n"}
{"name":"AddCon.coe_sInf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddCon M)\n⊢ Eq (⇑(InfSet.sInf S)) (InfSet.sInf (Set.image DFunLike.coe S))","decl":"/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying binary relation. -/\n@[to_additive (attr := simp, norm_cast)\n  \"The infimum of a set of additive congruence relations is the same as the infimum\n  of the set's image under the map to the underlying binary relation.\"]\ntheorem coe_sInf (S : Set (Con M)) :\n    ⇑(sInf S) = sInf ((⇑) '' S) := by\n  ext\n  simp only [sInf_image, iInf_apply, iInf_Prop_eq]\n  rfl\n\n"}
{"name":"Con.coe_sInf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Con M)\n⊢ Eq (⇑(InfSet.sInf S)) (InfSet.sInf (Set.image DFunLike.coe S))","decl":"/-- The infimum of a set of congruence relations is the same as the infimum of the set's image\n    under the map to the underlying binary relation. -/\n@[to_additive (attr := simp, norm_cast)\n  \"The infimum of a set of additive congruence relations is the same as the infimum\n  of the set's image under the map to the underlying binary relation.\"]\ntheorem coe_sInf (S : Set (Con M)) :\n    ⇑(sInf S) = sInf ((⇑) '' S) := by\n  ext\n  simp only [sInf_image, iInf_apply, iInf_Prop_eq]\n  rfl\n\n"}
{"name":"AddCon.coe_iInf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nι : Sort u_4\nf : ι → AddCon M\n⊢ Eq (⇑(iInf f)) (iInf fun i => ⇑(f i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} (f : ι → Con M) : ⇑(iInf f) = ⨅ i, ⇑(f i) := by\n  rw [iInf, coe_sInf, ← Set.range_comp, sInf_range, Function.comp_def]\n\n"}
{"name":"Con.coe_iInf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nι : Sort u_4\nf : ι → Con M\n⊢ Eq (⇑(iInf f)) (iInf fun i => ⇑(f i))","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {ι : Sort*} (f : ι → Con M) : ⇑(iInf f) = ⨅ i, ⇑(f i) := by\n  rw [iInf, coe_sInf, ← Set.range_comp, sInf_range, Function.comp_def]\n\n"}
{"name":"AddCon.coe_inf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Eq (⇑(Min.min c d)) (Min.min ⇑c ⇑d)","decl":"/-- The infimum of two congruence relations equals the infimum of the underlying binary\n    operations. -/\n@[to_additive (attr := simp, norm_cast)\n  \"The infimum of two additive congruence relations equals the infimum of the underlying binary\n  operations.\"]\ntheorem coe_inf {c d : Con M} : ⇑(c ⊓ d) = ⇑c ⊓ ⇑d :=\n  rfl\n\n"}
{"name":"Con.coe_inf","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Eq (⇑(Min.min c d)) (Min.min ⇑c ⇑d)","decl":"/-- The infimum of two congruence relations equals the infimum of the underlying binary\n    operations. -/\n@[to_additive (attr := simp, norm_cast)\n  \"The infimum of two additive congruence relations equals the infimum of the underlying binary\n  operations.\"]\ntheorem coe_inf {c d : Con M} : ⇑(c ⊓ d) = ⇑c ⊓ ⇑d :=\n  rfl\n\n"}
{"name":"Con.inf_iff_and","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\nx y : M\n⊢ Iff ((Min.min c d) x y) (And (c x y) (d x y))","decl":"/-- Definition of the infimum of two congruence relations. -/\n@[to_additive \"Definition of the infimum of two additive congruence relations.\"]\ntheorem inf_iff_and {c d : Con M} {x y} : (c ⊓ d) x y ↔ c x y ∧ d x y :=\n  Iff.rfl\n\n"}
{"name":"AddCon.inf_iff_and","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\nx y : M\n⊢ Iff ((Min.min c d) x y) (And (c x y) (d x y))","decl":"/-- Definition of the infimum of two congruence relations. -/\n@[to_additive \"Definition of the infimum of two additive congruence relations.\"]\ntheorem inf_iff_and {c d : Con M} {x y} : (c ⊓ d) x y ↔ c x y ∧ d x y :=\n  Iff.rfl\n\n"}
{"name":"Con.conGen_eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nr : M → M → Prop\n⊢ Eq (conGen r) (InfSet.sInf (setOf fun s => ∀ (x y : M), r x y → s x y))","decl":"/-- The inductively defined smallest congruence relation containing a binary relation `r` equals\n    the infimum of the set of congruence relations containing `r`. -/\n@[to_additive addConGen_eq \"The inductively defined smallest additive congruence relation\ncontaining a binary relation `r` equals the infimum of the set of additive congruence relations\ncontaining `r`.\"]\ntheorem conGen_eq (r : M → M → Prop) : conGen r = sInf { s : Con M | ∀ x y, r x y → s x y } :=\n  le_antisymm\n    (le_sInf (fun s hs x y (hxy : (conGen r) x y) =>\n      show s x y by\n        apply ConGen.Rel.recOn (motive := fun x y _ => s x y) hxy\n        · exact fun x y h => hs x y h\n        · exact s.refl'\n        · exact fun _ => s.symm'\n        · exact fun _ _ => s.trans'\n        · exact fun _ _ => s.mul))\n    (sInf_le ConGen.Rel.of)\n\n"}
{"name":"AddCon.addConGen_eq","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nr : M → M → Prop\n⊢ Eq (addConGen r) (InfSet.sInf (setOf fun s => ∀ (x y : M), r x y → s x y))","decl":"/-- The inductively defined smallest congruence relation containing a binary relation `r` equals\n    the infimum of the set of congruence relations containing `r`. -/\n@[to_additive addConGen_eq \"The inductively defined smallest additive congruence relation\ncontaining a binary relation `r` equals the infimum of the set of additive congruence relations\ncontaining `r`.\"]\ntheorem conGen_eq (r : M → M → Prop) : conGen r = sInf { s : Con M | ∀ x y, r x y → s x y } :=\n  le_antisymm\n    (le_sInf (fun s hs x y (hxy : (conGen r) x y) =>\n      show s x y by\n        apply ConGen.Rel.recOn (motive := fun x y _ => s x y) hxy\n        · exact fun x y h => hs x y h\n        · exact s.refl'\n        · exact fun _ => s.symm'\n        · exact fun _ _ => s.trans'\n        · exact fun _ _ => s.mul))\n    (sInf_le ConGen.Rel.of)\n\n"}
{"name":"Con.conGen_le","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nr : M → M → Prop\nc : Con M\nh : ∀ (x y : M), r x y → c x y\n⊢ LE.le (conGen r) c","decl":"/-- The smallest congruence relation containing a binary relation `r` is contained in any\n    congruence relation containing `r`. -/\n@[to_additive addConGen_le \"The smallest additive congruence relation containing a binary\nrelation `r` is contained in any additive congruence relation containing `r`.\"]\ntheorem conGen_le {r : M → M → Prop} {c : Con M} (h : ∀ x y, r x y → c x y) :\n    conGen r ≤ c := by rw [conGen_eq]; exact sInf_le h\n\n"}
{"name":"AddCon.addConGen_le","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nr : M → M → Prop\nc : AddCon M\nh : ∀ (x y : M), r x y → c x y\n⊢ LE.le (addConGen r) c","decl":"/-- The smallest congruence relation containing a binary relation `r` is contained in any\n    congruence relation containing `r`. -/\n@[to_additive addConGen_le \"The smallest additive congruence relation containing a binary\nrelation `r` is contained in any additive congruence relation containing `r`.\"]\ntheorem conGen_le {r : M → M → Prop} {c : Con M} (h : ∀ x y, r x y → c x y) :\n    conGen r ≤ c := by rw [conGen_eq]; exact sInf_le h\n\n"}
{"name":"AddCon.addConGen_mono","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nr s : M → M → Prop\nh : ∀ (x y : M), r x y → s x y\n⊢ LE.le (addConGen r) (addConGen s)","decl":"/-- Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation\n    containing `s` contains the smallest congruence relation containing `r`. -/\n@[to_additive addConGen_mono \"Given binary relations `r, s` with `r` contained in `s`, the\nsmallest additive congruence relation containing `s` contains the smallest additive congruence\nrelation containing `r`.\"]\ntheorem conGen_mono {r s : M → M → Prop} (h : ∀ x y, r x y → s x y) : conGen r ≤ conGen s :=\n  conGen_le fun x y hr => ConGen.Rel.of _ _ <| h x y hr\n\n"}
{"name":"Con.conGen_mono","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nr s : M → M → Prop\nh : ∀ (x y : M), r x y → s x y\n⊢ LE.le (conGen r) (conGen s)","decl":"/-- Given binary relations `r, s` with `r` contained in `s`, the smallest congruence relation\n    containing `s` contains the smallest congruence relation containing `r`. -/\n@[to_additive addConGen_mono \"Given binary relations `r, s` with `r` contained in `s`, the\nsmallest additive congruence relation containing `s` contains the smallest additive congruence\nrelation containing `r`.\"]\ntheorem conGen_mono {r s : M → M → Prop} (h : ∀ x y, r x y → s x y) : conGen r ≤ conGen s :=\n  conGen_le fun x y hr => ConGen.Rel.of _ _ <| h x y hr\n\n"}
{"name":"AddCon.addConGen_of_addCon","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc : AddCon M\n⊢ Eq (addConGen ⇑c) c","decl":"/-- Congruence relations equal the smallest congruence relation in which they are contained. -/\n@[to_additive (attr := simp) addConGen_of_addCon \"Additive congruence relations equal the smallest\nadditive congruence relation in which they are contained.\"]\ntheorem conGen_of_con (c : Con M) : conGen c = c :=\n  le_antisymm (by rw [conGen_eq]; exact sInf_le fun _ _ => id) ConGen.Rel.of\n\n"}
{"name":"Con.conGen_of_con","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc : Con M\n⊢ Eq (conGen ⇑c) c","decl":"/-- Congruence relations equal the smallest congruence relation in which they are contained. -/\n@[to_additive (attr := simp) addConGen_of_addCon \"Additive congruence relations equal the smallest\nadditive congruence relation in which they are contained.\"]\ntheorem conGen_of_con (c : Con M) : conGen c = c :=\n  le_antisymm (by rw [conGen_eq]; exact sInf_le fun _ _ => id) ConGen.Rel.of\n\n"}
{"name":"AddCon.addConGen_idem","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nr : M → M → Prop\n⊢ Eq (addConGen ⇑(addConGen r)) (addConGen r)","decl":"/-- The map sending a binary relation to the smallest congruence relation in which it is\n    contained is idempotent. -/\n@[to_additive addConGen_idem \"The map sending a binary relation to the smallest additive\ncongruence relation in which it is contained is idempotent.\"]\ntheorem conGen_idem (r : M → M → Prop) : conGen (conGen r) = conGen r := by simp\n\n"}
{"name":"Con.conGen_idem","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nr : M → M → Prop\n⊢ Eq (conGen ⇑(conGen r)) (conGen r)","decl":"/-- The map sending a binary relation to the smallest congruence relation in which it is\n    contained is idempotent. -/\n@[to_additive addConGen_idem \"The map sending a binary relation to the smallest additive\ncongruence relation in which it is contained is idempotent.\"]\ntheorem conGen_idem (r : M → M → Prop) : conGen (conGen r) = conGen r := by simp\n\n"}
{"name":"AddCon.sup_eq_addConGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Eq (Max.max c d) (addConGen fun x y => Or (c x y) (d x y))","decl":"/-- The supremum of congruence relations `c, d` equals the smallest congruence relation containing\n    the binary relation '`x` is related to `y` by `c` or `d`'. -/\n@[to_additive sup_eq_addConGen \"The supremum of additive congruence relations `c, d` equals the\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\nby `c` or `d`'.\"]\ntheorem sup_eq_conGen (c d : Con M) : c ⊔ d = conGen fun x y => c x y ∨ d x y := by\n  rw [conGen_eq]\n  apply congr_arg sInf\n  simp only [le_def, or_imp, ← forall_and]\n\n"}
{"name":"Con.sup_eq_conGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Eq (Max.max c d) (conGen fun x y => Or (c x y) (d x y))","decl":"/-- The supremum of congruence relations `c, d` equals the smallest congruence relation containing\n    the binary relation '`x` is related to `y` by `c` or `d`'. -/\n@[to_additive sup_eq_addConGen \"The supremum of additive congruence relations `c, d` equals the\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\nby `c` or `d`'.\"]\ntheorem sup_eq_conGen (c d : Con M) : c ⊔ d = conGen fun x y => c x y ∨ d x y := by\n  rw [conGen_eq]\n  apply congr_arg sInf\n  simp only [le_def, or_imp, ← forall_and]\n\n"}
{"name":"Con.sup_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nc d : Con M\n⊢ Eq (Max.max c d) (conGen (Max.max ⇑c ⇑d))","decl":"/-- The supremum of two congruence relations equals the smallest congruence relation containing\n    the supremum of the underlying binary operations. -/\n@[to_additive \"The supremum of two additive congruence relations equals the smallest additive\ncongruence relation containing the supremum of the underlying binary operations.\"]\ntheorem sup_def {c d : Con M} : c ⊔ d = conGen (⇑c ⊔ ⇑d) := by rw [sup_eq_conGen]; rfl\n\n"}
{"name":"AddCon.sup_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nc d : AddCon M\n⊢ Eq (Max.max c d) (addConGen (Max.max ⇑c ⇑d))","decl":"/-- The supremum of two congruence relations equals the smallest congruence relation containing\n    the supremum of the underlying binary operations. -/\n@[to_additive \"The supremum of two additive congruence relations equals the smallest additive\ncongruence relation containing the supremum of the underlying binary operations.\"]\ntheorem sup_def {c d : Con M} : c ⊔ d = conGen (⇑c ⊔ ⇑d) := by rw [sup_eq_conGen]; rfl\n\n"}
{"name":"Con.sSup_eq_conGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Con M)\n⊢ Eq (SupSet.sSup S) (conGen fun x y => Exists fun c => And (Membership.mem S c) (c x y))","decl":"/-- The supremum of a set of congruence relations `S` equals the smallest congruence relation\n    containing the binary relation 'there exists `c ∈ S` such that `x` is related to `y` by\n    `c`'. -/\n@[to_additive sSup_eq_addConGen \"The supremum of a set of additive congruence relations `S` equals\nthe smallest additive congruence relation containing the binary relation 'there exists `c ∈ S`\nsuch that `x` is related to `y` by `c`'.\"]\ntheorem sSup_eq_conGen (S : Set (Con M)) :\n    sSup S = conGen fun x y => ∃ c : Con M, c ∈ S ∧ c x y := by\n  rw [conGen_eq]\n  apply congr_arg sInf\n  ext\n  exact ⟨fun h _ _ ⟨r, hr⟩ => h hr.1 hr.2, fun h r hS _ _ hr => h _ _ ⟨r, hS, hr⟩⟩\n\n"}
{"name":"AddCon.sSup_eq_addConGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddCon M)\n⊢ Eq (SupSet.sSup S) (addConGen fun x y => Exists fun c => And (Membership.mem S c) (c x y))","decl":"/-- The supremum of a set of congruence relations `S` equals the smallest congruence relation\n    containing the binary relation 'there exists `c ∈ S` such that `x` is related to `y` by\n    `c`'. -/\n@[to_additive sSup_eq_addConGen \"The supremum of a set of additive congruence relations `S` equals\nthe smallest additive congruence relation containing the binary relation 'there exists `c ∈ S`\nsuch that `x` is related to `y` by `c`'.\"]\ntheorem sSup_eq_conGen (S : Set (Con M)) :\n    sSup S = conGen fun x y => ∃ c : Con M, c ∈ S ∧ c x y := by\n  rw [conGen_eq]\n  apply congr_arg sInf\n  ext\n  exact ⟨fun h _ _ ⟨r, hr⟩ => h hr.1 hr.2, fun h r hS _ _ hr => h _ _ ⟨r, hS, hr⟩⟩\n\n"}
{"name":"AddCon.sSup_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Add M\nS : Set (AddCon M)\n⊢ Eq (SupSet.sSup S) (addConGen (SupSet.sSup (Set.image DFunLike.coe S)))","decl":"/-- The supremum of a set of congruence relations is the same as the smallest congruence relation\n    containing the supremum of the set's image under the map to the underlying binary relation. -/\n@[to_additive \"The supremum of a set of additive congruence relations is the same as the smallest\nadditive congruence relation containing the supremum of the set's image under the map to the\nunderlying binary relation.\"]\ntheorem sSup_def {S : Set (Con M)} :\n    sSup S = conGen (sSup ((⇑) '' S)) := by\n  rw [sSup_eq_conGen, sSup_image]\n  congr with (x y)\n  simp only [sSup_image, iSup_apply, iSup_Prop_eq, exists_prop, rel_eq_coe]\n\n"}
{"name":"Con.sSup_def","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Mul M\nS : Set (Con M)\n⊢ Eq (SupSet.sSup S) (conGen (SupSet.sSup (Set.image DFunLike.coe S)))","decl":"/-- The supremum of a set of congruence relations is the same as the smallest congruence relation\n    containing the supremum of the set's image under the map to the underlying binary relation. -/\n@[to_additive \"The supremum of a set of additive congruence relations is the same as the smallest\nadditive congruence relation containing the supremum of the set's image under the map to the\nunderlying binary relation.\"]\ntheorem sSup_def {S : Set (Con M)} :\n    sSup S = conGen (sSup ((⇑) '' S)) := by\n  rw [sSup_eq_conGen, sSup_image]\n  congr with (x y)\n  simp only [sSup_image, iSup_apply, iSup_Prop_eq, exists_prop, rel_eq_coe]\n\n"}
{"name":"Con.mapOfSurjective_eq_mapGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nc : Con M\nf : M → N\nH : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nh : LE.le (Con.mulKer f H) c\nhf : Function.Surjective f\n⊢ Eq (c.mapGen f) (c.mapOfSurjective f H h hf)","decl":"/-- A specialization of 'the smallest congruence relation containing a congruence relation `c`\n    equals `c`'. -/\n@[to_additive \"A specialization of 'the smallest additive congruence relation containing\nan additive congruence relation `c` equals `c`'.\"]\ntheorem mapOfSurjective_eq_mapGen {c : Con M} {f : M → N} (H : ∀ x y, f (x * y) = f x * f y)\n    (h : mulKer f H ≤ c) (hf : Surjective f) : c.mapGen f = c.mapOfSurjective f H h hf := by\n  rw [← conGen_of_con (c.mapOfSurjective f H h hf)]; rfl\n\n"}
{"name":"AddCon.mapOfSurjective_eq_mapGen","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nc : AddCon M\nf : M → N\nH : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh : LE.le (AddCon.addKer f H) c\nhf : Function.Surjective f\n⊢ Eq (c.mapGen f) (c.mapOfSurjective f H h hf)","decl":"/-- A specialization of 'the smallest congruence relation containing a congruence relation `c`\n    equals `c`'. -/\n@[to_additive \"A specialization of 'the smallest additive congruence relation containing\nan additive congruence relation `c` equals `c`'.\"]\ntheorem mapOfSurjective_eq_mapGen {c : Con M} {f : M → N} (H : ∀ x y, f (x * y) = f x * f y)\n    (h : mulKer f H ≤ c) (hf : Surjective f) : c.mapGen f = c.mapOfSurjective f H h hf := by\n  rw [← conGen_of_con (c.mapOfSurjective f H h hf)]; rfl\n\n"}
{"name":"AddCon.comap_rel","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Add M\ninst✝ : Add N\nf : M → N\nH : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nc : AddCon N\nx y : M\n⊢ Iff ((AddCon.comap f H c) x y) (c (f x) (f y))","decl":"@[to_additive (attr := simp)]\ntheorem comap_rel {f : M → N} (H : ∀ x y, f (x * y) = f x * f y) {c : Con N} {x y : M} :\n    comap f H c x y ↔ c (f x) (f y) :=\n  Iff.rfl\n\n"}
{"name":"Con.comap_rel","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : M → N\nH : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\nc : Con N\nx y : M\n⊢ Iff ((Con.comap f H c) x y) (c (f x) (f y))","decl":"@[to_additive (attr := simp)]\ntheorem comap_rel {f : M → N} (H : ∀ x y, f (x * y) = f x * f y) {c : Con N} {x y : M} :\n    comap f H c x y ↔ c (f x) (f y) :=\n  Iff.rfl\n\n"}
{"name":"Con.coe_one","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nc : Con M\n⊢ Eq (↑1) 1","decl":"/-- The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the\n    monoid's 1. -/\n@[to_additive (attr := simp) \"The 0 of the quotient of an `AddMonoid` by an additive congruence\nrelation is the equivalence class of the `AddMonoid`'s 0.\"]\ntheorem coe_one : ((1 : M) : c.Quotient) = 1 :=\n  rfl\n\n"}
{"name":"AddCon.coe_zero","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nc : AddCon M\n⊢ Eq (↑0) 0","decl":"/-- The 1 of the quotient of a monoid by a congruence relation is the equivalence class of the\n    monoid's 1. -/\n@[to_additive (attr := simp) \"The 0 of the quotient of an `AddMonoid` by an additive congruence\nrelation is the equivalence class of the `AddMonoid`'s 0.\"]\ntheorem coe_one : ((1 : M) : c.Quotient) = 1 :=\n  rfl\n\n"}
{"name":"Con.pow","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_4\ninst✝ : Monoid M\nc : Con M\nn : Nat\nw x : M\na✝ : c w x\n⊢ c (HPow.hPow w n) (HPow.hPow x n)","decl":"/-- Multiplicative congruence relations preserve natural powers. -/\n@[to_additive \"Additive congruence relations preserve natural scaling.\"]\nprotected theorem pow {M : Type*} [Monoid M] (c : Con M) :\n    ∀ (n : ℕ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | 0, w, x, _ => by simpa using c.refl _\n  | Nat.succ n, w, x, h => by simpa [pow_succ] using c.mul (Con.pow c n h) h\n\n"}
{"name":"AddCon.nsmul","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_4\ninst✝ : AddMonoid M\nc : AddCon M\nn : Nat\nw x : M\na✝ : c w x\n⊢ c (HSMul.hSMul n w) (HSMul.hSMul n x)","decl":"/-- Multiplicative congruence relations preserve natural powers. -/\n@[to_additive \"Additive congruence relations preserve natural scaling.\"]\nprotected theorem pow {M : Type*} [Monoid M] (c : Con M) :\n    ∀ (n : ℕ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | 0, w, x, _ => by simpa using c.refl _\n  | Nat.succ n, w, x, h => by simpa [pow_succ] using c.mul (Con.pow c n h) h\n\n"}
{"name":"Con.map_of_mul_left_rel_one","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nc : Con M\nf : M → M\nhf : ∀ (x : M), c (HMul.hMul (f x) x) 1\nx y : M\nh : c x y\n⊢ c (f x) (f y)","decl":"/-- Sometimes, a group is defined as a quotient of a monoid by a congruence relation.\nUsually, the inverse operation is defined as `Setoid.map f _` for some `f`.\nThis lemma allows to avoid code duplication in the definition of the inverse operation:\ninstead of proving both `∀ x y, c x y → c (f x) (f y)` (to define the operation)\nand `∀ x, c (f x * x) 1` (to prove the group laws), one can only prove the latter. -/\n@[to_additive \"Sometimes, an additive group is defined as a quotient of a monoid\n  by an additive congruence relation.\n  Usually, the inverse operation is defined as `Setoid.map f _` for some `f`.\n  This lemma allows to avoid code duplication in the definition of the inverse operation:\n  instead of proving both `∀ x y, c x y → c (f x) (f y)` (to define the operation)\n  and `∀ x, c (f x + x) 0` (to prove the group laws), one can only prove the latter.\"]\ntheorem map_of_mul_left_rel_one [Monoid M] (c : Con M)\n    (f : M → M) (hf : ∀ x, c (f x * x) 1) {x y} (h : c x y) : c (f x) (f y) := by\n  simp only [← Con.eq, coe_one, coe_mul] at *\n  have hf' : ∀ x : M, (x : c.Quotient) * f x = 1 := fun x ↦\n    calc\n      (x : c.Quotient) * f x = f (f x) * f x * (x * f x) := by simp [hf]\n      _ = f (f x) * (f x * x) * f x := by ac_rfl\n      _ = 1 := by simp [hf]\n  have : (⟨_, _, hf' x, hf x⟩ : c.Quotientˣ) = ⟨_, _, hf' y, hf y⟩ := Units.ext h\n  exact congr_arg Units.inv this\n\n"}
{"name":"AddCon.map_of_add_left_rel_zero","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nc : AddCon M\nf : M → M\nhf : ∀ (x : M), c (HAdd.hAdd (f x) x) 0\nx y : M\nh : c x y\n⊢ c (f x) (f y)","decl":"/-- Sometimes, a group is defined as a quotient of a monoid by a congruence relation.\nUsually, the inverse operation is defined as `Setoid.map f _` for some `f`.\nThis lemma allows to avoid code duplication in the definition of the inverse operation:\ninstead of proving both `∀ x y, c x y → c (f x) (f y)` (to define the operation)\nand `∀ x, c (f x * x) 1` (to prove the group laws), one can only prove the latter. -/\n@[to_additive \"Sometimes, an additive group is defined as a quotient of a monoid\n  by an additive congruence relation.\n  Usually, the inverse operation is defined as `Setoid.map f _` for some `f`.\n  This lemma allows to avoid code duplication in the definition of the inverse operation:\n  instead of proving both `∀ x y, c x y → c (f x) (f y)` (to define the operation)\n  and `∀ x, c (f x + x) 0` (to prove the group laws), one can only prove the latter.\"]\ntheorem map_of_mul_left_rel_one [Monoid M] (c : Con M)\n    (f : M → M) (hf : ∀ x, c (f x * x) 1) {x y} (h : c x y) : c (f x) (f y) := by\n  simp only [← Con.eq, coe_one, coe_mul] at *\n  have hf' : ∀ x : M, (x : c.Quotient) * f x = 1 := fun x ↦\n    calc\n      (x : c.Quotient) * f x = f (f x) * f x * (x * f x) := by simp [hf]\n      _ = f (f x) * (f x * x) * f x := by ac_rfl\n      _ = 1 := by simp [hf]\n  have : (⟨_, _, hf' x, hf x⟩ : c.Quotientˣ) = ⟨_, _, hf' y, hf y⟩ := Units.ext h\n  exact congr_arg Units.inv this\n\n"}
{"name":"AddCon.neg","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddGroup M\nc : AddCon M\nx y : M\nh : c x y\n⊢ c (Neg.neg x) (Neg.neg y)","decl":"/-- Multiplicative congruence relations preserve inversion. -/\n@[to_additive \"Additive congruence relations preserve negation.\"]\nprotected theorem inv {x y} (h : c x y) : c x⁻¹ y⁻¹ :=\n  c.map_of_mul_left_rel_one Inv.inv (fun x => by simp only [inv_mul_cancel, c.refl 1]) h\n\n"}
{"name":"Con.inv","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Group M\nc : Con M\nx y : M\nh : c x y\n⊢ c (Inv.inv x) (Inv.inv y)","decl":"/-- Multiplicative congruence relations preserve inversion. -/\n@[to_additive \"Additive congruence relations preserve negation.\"]\nprotected theorem inv {x y} (h : c x y) : c x⁻¹ y⁻¹ :=\n  c.map_of_mul_left_rel_one Inv.inv (fun x => by simp only [inv_mul_cancel, c.refl 1]) h\n\n"}
{"name":"Con.div","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Group M\nc : Con M\nw x y z : M\na✝¹ : c w x\na✝ : c y z\n⊢ c (HDiv.hDiv w y) (HDiv.hDiv x z)","decl":"/-- Multiplicative congruence relations preserve division. -/\n@[to_additive \"Additive congruence relations preserve subtraction.\"]\nprotected theorem div : ∀ {w x y z}, c w x → c y z → c (w / y) (x / z) := @fun w x y z h1 h2 => by\n  simpa only [div_eq_mul_inv] using c.mul h1 (c.inv h2)\n\n"}
{"name":"AddCon.sub","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddGroup M\nc : AddCon M\nw x y z : M\na✝¹ : c w x\na✝ : c y z\n⊢ c (HSub.hSub w y) (HSub.hSub x z)","decl":"/-- Multiplicative congruence relations preserve division. -/\n@[to_additive \"Additive congruence relations preserve subtraction.\"]\nprotected theorem div : ∀ {w x y z}, c w x → c y z → c (w / y) (x / z) := @fun w x y z h1 h2 => by\n  simpa only [div_eq_mul_inv] using c.mul h1 (c.inv h2)\n\n"}
{"name":"Con.zpow","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Group M\nc : Con M\nn : Int\nw x : M\na✝ : c w x\n⊢ c (HPow.hPow w n) (HPow.hPow x n)","decl":"/-- Multiplicative congruence relations preserve integer powers. -/\n@[to_additive \"Additive congruence relations preserve integer scaling.\"]\nprotected theorem zpow : ∀ (n : ℤ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | Int.ofNat n, w, x, h => by simpa only [zpow_natCast, Int.ofNat_eq_coe] using c.pow n h\n  | Int.negSucc n, w, x, h => by simpa only [zpow_negSucc] using c.inv (c.pow _ h)\n\n"}
{"name":"AddCon.zsmul","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddGroup M\nc : AddCon M\nn : Int\nw x : M\na✝ : c w x\n⊢ c (HSMul.hSMul n w) (HSMul.hSMul n x)","decl":"/-- Multiplicative congruence relations preserve integer powers. -/\n@[to_additive \"Additive congruence relations preserve integer scaling.\"]\nprotected theorem zpow : ∀ (n : ℤ) {w x}, c w x → c (w ^ n) (x ^ n)\n  | Int.ofNat n, w, x, h => by simpa only [zpow_natCast, Int.ofNat_eq_coe] using c.pow n h\n  | Int.negSucc n, w, x, h => by simpa only [zpow_negSucc] using c.inv (c.pow _ h)\n\n"}
{"name":"Con.liftOnUnits_mk","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nα : Type u_4\ninst✝ : Monoid M\nc : Con M\nf : (x y : M) → c (HMul.hMul x y) 1 → c (HMul.hMul y x) 1 → α\nHf : ∀ (x y : M) (hxy : c (HMul.hMul x y) 1) (hyx : c (HMul.hMul y x) 1) (x' y' : M) (hxy' : c (HMul.hMul x' y') 1) (hyx' : c (HMul.hMul y' x') 1), c x x' → c y y' → Eq (f x y hxy hyx) (f x' y' hxy' hyx')\nx y : M\nhxy : Eq (HMul.hMul ↑x ↑y) 1\nhyx : Eq (HMul.hMul ↑y ↑x) 1\n⊢ Eq (Con.liftOnUnits { val := ↑x, inv := ↑y, val_inv := hxy, inv_val := hyx } f Hf) (f x y ⋯ ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem liftOnUnits_mk (f : ∀ x y : M, c (x * y) 1 → c (y * x) 1 → α)\n    (Hf : ∀ x y hxy hyx x' y' hxy' hyx', c x x' → c y y' → f x y hxy hyx = f x' y' hxy' hyx')\n    (x y : M) (hxy hyx) :\n    liftOnUnits ⟨(x : c.Quotient), y, hxy, hyx⟩ f Hf = f x y (c.eq.1 hxy) (c.eq.1 hyx) :=\n  rfl\n\n"}
{"name":"AddCon.liftOnAddUnits_mk","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\nα : Type u_4\ninst✝ : AddMonoid M\nc : AddCon M\nf : (x y : M) → c (HAdd.hAdd x y) 0 → c (HAdd.hAdd y x) 0 → α\nHf : ∀ (x y : M) (hxy : c (HAdd.hAdd x y) 0) (hyx : c (HAdd.hAdd y x) 0) (x' y' : M) (hxy' : c (HAdd.hAdd x' y') 0) (hyx' : c (HAdd.hAdd y' x') 0), c x x' → c y y' → Eq (f x y hxy hyx) (f x' y' hxy' hyx')\nx y : M\nhxy : Eq (HAdd.hAdd ↑x ↑y) 0\nhyx : Eq (HAdd.hAdd ↑y ↑x) 0\n⊢ Eq (AddCon.liftOnAddUnits { val := ↑x, neg := ↑y, val_neg := hxy, neg_val := hyx } f Hf) (f x y ⋯ ⋯)","decl":"@[to_additive (attr := simp)]\ntheorem liftOnUnits_mk (f : ∀ x y : M, c (x * y) 1 → c (y * x) 1 → α)\n    (Hf : ∀ x y hxy hyx x' y' hxy' hyx', c x x' → c y y' → f x y hxy hyx = f x' y' hxy' hyx')\n    (x y : M) (hxy hyx) :\n    liftOnUnits ⟨(x : c.Quotient), y, hxy, hyx⟩ f Hf = f x y (c.eq.1 hxy) (c.eq.1 hyx) :=\n  rfl\n\n"}
{"name":"AddCon.induction_on_addUnits","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nc : AddCon M\np : AddUnits c.Quotient → Prop\nu : AddUnits c.Quotient\nH : ∀ (x y : M) (hxy : c (HAdd.hAdd x y) 0) (hyx : c (HAdd.hAdd y x) 0), p { val := ↑x, neg := ↑y, val_neg := ⋯, neg_val := ⋯ }\n⊢ p u","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on_units {p : Units c.Quotient → Prop} (u : Units c.Quotient)\n    (H : ∀ (x y : M) (hxy : c (x * y) 1) (hyx : c (y * x) 1), p ⟨x, y, c.eq.2 hxy, c.eq.2 hyx⟩) :\n    p u := by\n  rcases u with ⟨⟨x⟩, ⟨y⟩, h₁, h₂⟩\n  exact H x y (c.eq.1 h₁) (c.eq.1 h₂)\n\n"}
{"name":"Con.induction_on_units","module":"Mathlib.GroupTheory.Congruence.Defs","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nc : Con M\np : Units c.Quotient → Prop\nu : Units c.Quotient\nH : ∀ (x y : M) (hxy : c (HMul.hMul x y) 1) (hyx : c (HMul.hMul y x) 1), p { val := ↑x, inv := ↑y, val_inv := ⋯, inv_val := ⋯ }\n⊢ p u","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_on_units {p : Units c.Quotient → Prop} (u : Units c.Quotient)\n    (H : ∀ (x y : M) (hxy : c (x * y) 1) (hyx : c (y * x) 1), p ⟨x, y, c.eq.2 hxy, c.eq.2 hyx⟩) :\n    p u := by\n  rcases u with ⟨⟨x⟩, ⟨y⟩, h₁, h₂⟩\n  exact H x y (c.eq.1 h₁) (c.eq.1 h₂)\n\n"}
