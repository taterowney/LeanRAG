{"name":"CategoryTheory.Limits.HasCountableLimits.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nself : CategoryTheory.Limits.HasCountableLimits C\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.CountableCategory J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"/--\nA category has all countable limits if every functor `J ⥤ C` with a `CountableCategory J`\ninstance and `J : Type` has a limit.\n-/\nclass HasCountableLimits : Prop where\n  /-- `C` has all limits over any type `J` whose objects and morphisms lie in the same universe\n  and which has countably many objects and morphisms -/\n  out (J : Type) [SmallCategory J] [CountableCategory J] : HasLimitsOfShape J C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasCountableLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableLimits C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"instance (priority := 100) hasFiniteLimits_of_hasCountableLimits [HasCountableLimits C] :\n    HasFiniteLimits C where\n  out J := HasCountableLimits.out J\n\n"}
{"name":"CategoryTheory.Limits.hasCountableLimits_of_hasLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasCountableLimits C","decl":"instance (priority := 100) hasCountableLimits_of_hasLimits [HasLimits C] :\n    HasCountableLimits C where\n  out := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instHasLimitsOfShapeOfCountableCategoryOfHasCountableLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\ninst✝² : CategoryTheory.Category.{v, u_2} J\ninst✝¹ : CategoryTheory.CountableCategory J\ninst✝ : CategoryTheory.Limits.HasCountableLimits C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"universe v in\ninstance [Category.{v} J] [CountableCategory J] [HasCountableLimits C] : HasLimitsOfShape J C :=\n  have : HasLimitsOfShape (HomAsType J) C := HasCountableLimits.out (HomAsType J)\n  hasLimitsOfShape_of_equivalence (homAsTypeEquiv J)\n\n"}
{"name":"CategoryTheory.Limits.HasCountableProducts.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nself : CategoryTheory.Limits.HasCountableProducts C\nJ : Type\ninst✝ : Countable J\n⊢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"/-- A category has countable products if it has all products indexed by countable types. -/\nclass HasCountableProducts where\n  out (J : Type) [Countable J] : HasProductsOfShape J C\n\n"}
{"name":"CategoryTheory.Limits.instHasProductsOfShapeOfHasCountableProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\ninst✝¹ : Countable J\ninst✝ : CategoryTheory.Limits.HasCountableProducts C\n⊢ CategoryTheory.Limits.HasProductsOfShape J C","decl":"instance [HasCountableProducts C] : HasProductsOfShape J C :=\n  have : Countable (Shrink.{0} J) := Countable.of_equiv _ (equivShrink.{0} J)\n  have : HasLimitsOfShape (Discrete (Shrink.{0} J)) C := HasCountableProducts.out _\n  hasLimitsOfShape_of_equivalence (Discrete.equivalence (equivShrink.{0} J)).symm\n\n"}
{"name":"CategoryTheory.Limits.hasCountableProducts_of_hasProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasProducts C\n⊢ CategoryTheory.Limits.HasCountableProducts C","decl":"instance (priority := 100) hasCountableProducts_of_hasProducts [HasProducts C] :\n    HasCountableProducts C where\n  out _ :=\n    have : HasProducts.{0} C := has_smallest_products_of_hasProducts\n    inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasCountableProducts_of_hasCountableLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableLimits C\n⊢ CategoryTheory.Limits.HasCountableProducts C","decl":"instance (priority := 100) hasCountableProducts_of_hasCountableLimits [HasCountableLimits C] :\n    HasCountableProducts C where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteProducts_of_hasCountableProducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableProducts C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"instance (priority := 100) hasFiniteProducts_of_hasCountableProducts [HasCountableProducts C] :\n    HasFiniteProducts C where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.HasCountableColimits.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nself : CategoryTheory.Limits.HasCountableColimits C\nJ : Type\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.CountableCategory J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/--\nA category has all countable colimits if every functor `J ⥤ C` with a `CountableCategory J`\ninstance and `J : Type` has a colimit.\n-/\nclass HasCountableColimits : Prop where\n  /-- `C` has all limits over any type `J` whose objects and morphisms lie in the same universe\n  and which has countably many objects and morphisms -/\n  out (J : Type) [SmallCategory J] [CountableCategory J] : HasColimitsOfShape J C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasCountableColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableColimits C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"instance (priority := 100) hasFiniteColimits_of_hasCountableColimits [HasCountableColimits C] :\n    HasFiniteColimits C where\n  out J := HasCountableColimits.out J\n\n"}
{"name":"CategoryTheory.Limits.hasCountableColimits_of_hasColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasCountableColimits C","decl":"instance (priority := 100) hasCountableColimits_of_hasColimits [HasColimits C] :\n    HasCountableColimits C where\n  out := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instHasColimitsOfShapeOfCountableCategoryOfHasCountableColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\ninst✝² : CategoryTheory.Category.{v, u_2} J\ninst✝¹ : CategoryTheory.CountableCategory J\ninst✝ : CategoryTheory.Limits.HasCountableColimits C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"universe v in\ninstance [Category.{v} J] [CountableCategory J] [HasCountableColimits C] : HasColimitsOfShape J C :=\n  have : HasColimitsOfShape (HomAsType J) C := HasCountableColimits.out (HomAsType J)\n  hasColimitsOfShape_of_equivalence (homAsTypeEquiv J)\n\n"}
{"name":"CategoryTheory.Limits.HasCountableCoproducts.out","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nself : CategoryTheory.Limits.HasCountableCoproducts C\nJ : Type\ninst✝ : Countable J\n⊢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"/-- A category has countable coproducts if it has all coproducts indexed by countable types. -/\nclass HasCountableCoproducts where\n  out (J : Type) [Countable J] : HasCoproductsOfShape J C\n\n"}
{"name":"CategoryTheory.Limits.hasCountableCoproducts_of_hasCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Limits.HasCoproducts C\n⊢ CategoryTheory.Limits.HasCountableCoproducts C","decl":"instance (priority := 100) hasCountableCoproducts_of_hasCoproducts [HasCoproducts C] :\n    HasCountableCoproducts C where\n  out _ :=\n    have : HasCoproducts.{0} C := has_smallest_coproducts_of_hasCoproducts\n    inferInstance\n\n"}
{"name":"CategoryTheory.Limits.instHasCoproductsOfShapeOfHasCountableCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nJ : Type u_2\ninst✝¹ : Countable J\ninst✝ : CategoryTheory.Limits.HasCountableCoproducts C\n⊢ CategoryTheory.Limits.HasCoproductsOfShape J C","decl":"instance [HasCountableCoproducts C] : HasCoproductsOfShape J C :=\n  have : Countable (Shrink.{0} J) := Countable.of_equiv _ (equivShrink.{0} J)\n  have : HasColimitsOfShape (Discrete (Shrink.{0} J)) C := HasCountableCoproducts.out _\n  hasColimitsOfShape_of_equivalence (Discrete.equivalence (equivShrink.{0} J)).symm\n\n"}
{"name":"CategoryTheory.Limits.hasCountableCoproducts_of_hasCountableColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableColimits C\n⊢ CategoryTheory.Limits.HasCountableCoproducts C","decl":"instance (priority := 100) hasCountableCoproducts_of_hasCountableColimits [HasCountableColimits C] :\n    HasCountableCoproducts C where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteCoproducts_of_hasCountableCoproducts","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Limits.HasCountableCoproducts C\n⊢ CategoryTheory.Limits.HasFiniteCoproducts C","decl":"instance (priority := 100) hasFiniteCoproducts_of_hasCountableCoproducts\n    [HasCountableCoproducts C] : HasFiniteCoproducts C where\n  out _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.IsFiltered.sequentialFunctor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsFiltered J\n⊢ Monotone (CategoryTheory.Limits.IsFiltered.sequentialFunctor_obj J)","decl":"theorem sequentialFunctor_map : Monotone (sequentialFunctor_obj J) :=\n  monotone_nat_of_le_succ fun n ↦\n    leOfHom (IsFilteredOrEmpty.cocone_objs ((exists_surjective_nat _).choose n)\n      (sequentialFunctor_obj J n)).choose_spec.choose_spec.choose\n\n"}
{"name":"CategoryTheory.Limits.IsFiltered.sequentialFunctor_final_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsFiltered J\nj : J\n⊢ Exists fun n => LE.le j (CategoryTheory.Limits.IsFiltered.sequentialFunctor_obj J n)","decl":"theorem sequentialFunctor_final_aux (j : J) : ∃ (n : ℕ), j ≤ sequentialFunctor_obj J n := by\n  obtain ⟨m, h⟩ := (exists_surjective_nat _).choose_spec j\n  refine ⟨m + 1, ?_⟩\n  simpa only [h] using leOfHom (IsFilteredOrEmpty.cocone_objs ((exists_surjective_nat _).choose m)\n    (sequentialFunctor_obj J m)).choose_spec.choose\n\n"}
{"name":"CategoryTheory.Limits.IsFiltered.sequentialFunctor_final","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsFiltered J\n⊢ (CategoryTheory.Limits.IsFiltered.sequentialFunctor J).Final","decl":"instance sequentialFunctor_final : (sequentialFunctor J).Final where\n  out d := by\n    obtain ⟨n, (g : d ≤ (sequentialFunctor J).obj n)⟩ := sequentialFunctor_final_aux J d\n    have : Nonempty (StructuredArrow d (sequentialFunctor J)) :=\n      ⟨StructuredArrow.mk (homOfLE g)⟩\n    apply isConnected_of_zigzag\n    refine fun i j ↦ ⟨[j], ?_⟩\n    simp only [List.chain_cons, Zag, List.Chain.nil, and_true, ne_eq, not_false_eq_true,\n      List.getLast_cons, not_true_eq_false, List.getLast_singleton', reduceCtorEq]\n    clear! C\n    wlog h : j.right ≤ i.right\n    · exact or_comm.1 (this J d n g inferInstance j i (le_of_lt (not_le.mp h)))\n    · right\n      exact ⟨StructuredArrow.homMk (homOfLE h) rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.IsCofiltered.sequentialFunctor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ Antitone (CategoryTheory.Limits.IsCofiltered.sequentialFunctor_obj J)","decl":"theorem sequentialFunctor_map : Antitone (sequentialFunctor_obj J) :=\n  antitone_nat_of_succ_le fun n ↦\n    leOfHom (IsCofilteredOrEmpty.cone_objs ((exists_surjective_nat _).choose n)\n      (sequentialFunctor_obj J n)).choose_spec.choose_spec.choose\n\n"}
{"name":"CategoryTheory.Limits.IsCofiltered.sequentialFunctor_initial_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\nj : J\n⊢ Exists fun n => LE.le (CategoryTheory.Limits.IsCofiltered.sequentialFunctor_obj J n) j","decl":"theorem sequentialFunctor_initial_aux (j : J) : ∃ (n : ℕ), sequentialFunctor_obj J n ≤ j := by\n  obtain ⟨m, h⟩ := (exists_surjective_nat _).choose_spec j\n  refine ⟨m + 1, ?_⟩\n  simpa only [h] using leOfHom (IsCofilteredOrEmpty.cone_objs ((exists_surjective_nat _).choose m)\n    (sequentialFunctor_obj J m)).choose_spec.choose\n\n"}
{"name":"CategoryTheory.Limits.IsCofiltered.sequentialFunctor_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ (CategoryTheory.Limits.IsCofiltered.sequentialFunctor J).Initial","decl":"instance sequentialFunctor_initial : (sequentialFunctor J).Initial where\n  out d := by\n    obtain ⟨n, (g : (sequentialFunctor J).obj ⟨n⟩ ≤ d)⟩ := sequentialFunctor_initial_aux J d\n    have : Nonempty (CostructuredArrow (sequentialFunctor J) d) :=\n      ⟨CostructuredArrow.mk (homOfLE g)⟩\n    apply isConnected_of_zigzag\n    refine fun i j ↦ ⟨[j], ?_⟩\n    simp only [List.chain_cons, Zag, List.Chain.nil, and_true, ne_eq, not_false_eq_true,\n      List.getLast_cons, not_true_eq_false, List.getLast_singleton', reduceCtorEq]\n    clear! C\n    wlog h : (unop i.left) ≤ (unop j.left)\n    · exact or_comm.1 (this J d n g inferInstance j i (le_of_lt (not_le.mp h)))\n    · right\n      exact ⟨CostructuredArrow.homMk (homOfLE h).op rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.sequentialFunctor_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ Antitone (CategoryTheory.Limits.IsCofiltered.sequentialFunctor_obj J)","decl":"@[deprecated (since := \"2024-11-01\")] alias sequentialFunctor_map :=\n  IsCofiltered.sequentialFunctor_map\n"}
{"name":"CategoryTheory.Limits.sequentialFunctor_initial_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\nj : J\n⊢ Exists fun n => LE.le (CategoryTheory.Limits.IsCofiltered.sequentialFunctor_obj J n) j","decl":"@[deprecated (since := \"2024-11-01\")] alias sequentialFunctor_initial_aux :=\n  IsCofiltered.sequentialFunctor_initial_aux\n"}
{"name":"CategoryTheory.Limits.sequentialFunctor_initial","module":"Mathlib.CategoryTheory.Limits.Shapes.Countable","initialProofState":"J : Type u_2\ninst✝² : Countable J\ninst✝¹ : Preorder J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ (CategoryTheory.Limits.IsCofiltered.sequentialFunctor J).Initial","decl":"@[deprecated (since := \"2024-11-01\")] alias sequentialFunctor_initial :=\n  IsCofiltered.sequentialFunctor_initial\n"}
