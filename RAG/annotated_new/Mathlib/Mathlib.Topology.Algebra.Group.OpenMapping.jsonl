{"name":"smul_singleton_mem_nhds_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Åπ : TopologicalSpace G\ninst‚úù‚Å∏ : TopologicalSpace X\ninst‚úù‚Å∑ : Group G\ninst‚úù‚Å∂ : TopologicalGroup G\ninst‚úù‚Åµ : MulAction G X\ninst‚úù‚Å¥ : SigmaCompactSpace G\ninst‚úù¬≥ : BaireSpace X\ninst‚úù¬≤ : T2Space X\ninst‚úù¬π : ContinuousSMul G X\ninst‚úù : MulAction.IsPretransitive G X\nU : Set G\nhU : Membership.mem (nhds 1) U\nx : X\n‚ä¢ Membership.mem (nhds x) (HSMul.hSMul U (Singleton.singleton x))","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open around the identity. It follows in `isOpenMap_smul_of_sigmaCompact` that it\nis open around any point. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open around zero. It follows in\n`isOpenMap_vadd_of_sigmaCompact` that it is open around any point.\"]\ntheorem smul_singleton_mem_nhds_of_sigmaCompact\n    {U : Set G} (hU : U ‚àà ùìù 1) (x : X) : U ‚Ä¢ {x} ‚àà ùìù x := by\n  /- Consider a small closed neighborhood `V` of the identity. Then the group is covered by\n  countably many translates of `V`, say `g·µ¢ V`. Let also `K‚Çô` be a sequence of compact sets covering\n  the space. Then the image of `K‚Çô ‚à© g·µ¢ V` in the orbit is compact, and their unions covers the\n  space. By Baire, one of them has nonempty interior. Then `g·µ¢ V ‚Ä¢ x` has nonempty interior, and\n  so does `V ‚Ä¢ x`. Its interior contains a point `g' x` with `g' ‚àà V`. Then `g'‚Åª¬π ‚Ä¢ V ‚Ä¢ x` contains\n  a neighborhood of `x`, and it is included in `V‚Åª¬π ‚Ä¢ V ‚Ä¢ x`, which is itself contained in `U ‚Ä¢ x`\n  if `V` is small enough. -/\n  obtain ‚ü®V, V_mem, V_closed, V_symm, VU‚ü© : ‚àÉ V ‚àà ùìù (1 : G), IsClosed V ‚àß V‚Åª¬π = V ‚àß V * V ‚äÜ U :=\n    exists_closed_nhds_one_inv_eq_mul_subset hU\n  obtain ‚ü®s, s_count, hs‚ü© : ‚àÉ (s : Set G), s.Countable ‚àß ‚ãÉ g ‚àà s, g ‚Ä¢ V = univ :=\n    countable_cover_nhds_of_sigmaCompact fun _ ‚Ü¶ by simpa\n  let K : ‚Ñï ‚Üí Set G := compactCovering G\n  let F : ‚Ñï √ó s ‚Üí Set X := fun p ‚Ü¶ (K p.1 ‚à© (p.2 : G) ‚Ä¢ V) ‚Ä¢ ({x} : Set X)\n  obtain ‚ü®‚ü®n, ‚ü®g, hg‚ü©‚ü©, hi‚ü© : ‚àÉ i, (interior (F i)).Nonempty := by\n    have : Nonempty X := ‚ü®x‚ü©\n    have : Encodable s := Countable.toEncodable s_count\n    apply nonempty_interior_of_iUnion_of_closed\n    ¬∑ rintro ‚ü®n, ‚ü®g, hg‚ü©‚ü©\n      apply IsCompact.isClosed\n      suffices H : IsCompact ((fun (g : G) ‚Ü¶ g ‚Ä¢ x) '' (K n ‚à© g ‚Ä¢ V)) by\n        simpa only [F, smul_singleton] using H\n      apply IsCompact.image\n      ¬∑ exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)\n      ¬∑ exact continuous_id.smul continuous_const\n    ¬∑ apply eq_univ_iff_forall.2 (fun y ‚Ü¶ ?_)\n      obtain ‚ü®h, rfl‚ü© : ‚àÉ h, h ‚Ä¢ x = y := exists_smul_eq G x y\n      obtain ‚ü®n, hn‚ü© : ‚àÉ n, h ‚àà K n := exists_mem_compactCovering h\n      obtain ‚ü®g, gs, hg‚ü© : ‚àÉ g ‚àà s, h ‚àà g ‚Ä¢ V := exists_set_mem_of_union_eq_top s _ hs _\n      simp only [F, smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists,\n        Subtype.exists, exists_prop]\n      exact ‚ü®n, g, gs, h, ‚ü®hn, hg‚ü©, rfl‚ü©\n  have I : (interior ((g ‚Ä¢ V) ‚Ä¢ {x})).Nonempty := by\n    apply hi.mono\n    apply interior_mono\n    exact smul_subset_smul_right inter_subset_right\n  obtain ‚ü®y, hy‚ü© : (interior (V ‚Ä¢ ({x} : Set X))).Nonempty := by\n    rw [smul_assoc, interior_smul] at I\n    exact smul_set_nonempty.1 I\n  obtain ‚ü®g', hg', rfl‚ü© : ‚àÉ g' ‚àà V, g' ‚Ä¢ x = y := by simpa using interior_subset hy\n  have J : (g' ‚Åª¬π ‚Ä¢ V) ‚Ä¢ {x} ‚àà ùìù x := by\n    apply mem_interior_iff_mem_nhds.1\n    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]\n  have : (g'‚Åª¬π ‚Ä¢ V) ‚Ä¢ {x} ‚äÜ U ‚Ä¢ ({x} : Set X) := by\n    apply smul_subset_smul_right\n    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_\n    rw [V_symm]\n    exact VU\n  exact Filter.mem_of_superset J this\n\n"}
{"name":"vadd_singleton_mem_nhds_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Åπ : TopologicalSpace G\ninst‚úù‚Å∏ : TopologicalSpace X\ninst‚úù‚Å∑ : AddGroup G\ninst‚úù‚Å∂ : TopologicalAddGroup G\ninst‚úù‚Åµ : AddAction G X\ninst‚úù‚Å¥ : SigmaCompactSpace G\ninst‚úù¬≥ : BaireSpace X\ninst‚úù¬≤ : T2Space X\ninst‚úù¬π : ContinuousVAdd G X\ninst‚úù : AddAction.IsPretransitive G X\nU : Set G\nhU : Membership.mem (nhds 0) U\nx : X\n‚ä¢ Membership.mem (nhds x) (HVAdd.hVAdd U (Singleton.singleton x))","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open around the identity. It follows in `isOpenMap_smul_of_sigmaCompact` that it\nis open around any point. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open around zero. It follows in\n`isOpenMap_vadd_of_sigmaCompact` that it is open around any point.\"]\ntheorem smul_singleton_mem_nhds_of_sigmaCompact\n    {U : Set G} (hU : U ‚àà ùìù 1) (x : X) : U ‚Ä¢ {x} ‚àà ùìù x := by\n  /- Consider a small closed neighborhood `V` of the identity. Then the group is covered by\n  countably many translates of `V`, say `g·µ¢ V`. Let also `K‚Çô` be a sequence of compact sets covering\n  the space. Then the image of `K‚Çô ‚à© g·µ¢ V` in the orbit is compact, and their unions covers the\n  space. By Baire, one of them has nonempty interior. Then `g·µ¢ V ‚Ä¢ x` has nonempty interior, and\n  so does `V ‚Ä¢ x`. Its interior contains a point `g' x` with `g' ‚àà V`. Then `g'‚Åª¬π ‚Ä¢ V ‚Ä¢ x` contains\n  a neighborhood of `x`, and it is included in `V‚Åª¬π ‚Ä¢ V ‚Ä¢ x`, which is itself contained in `U ‚Ä¢ x`\n  if `V` is small enough. -/\n  obtain ‚ü®V, V_mem, V_closed, V_symm, VU‚ü© : ‚àÉ V ‚àà ùìù (1 : G), IsClosed V ‚àß V‚Åª¬π = V ‚àß V * V ‚äÜ U :=\n    exists_closed_nhds_one_inv_eq_mul_subset hU\n  obtain ‚ü®s, s_count, hs‚ü© : ‚àÉ (s : Set G), s.Countable ‚àß ‚ãÉ g ‚àà s, g ‚Ä¢ V = univ :=\n    countable_cover_nhds_of_sigmaCompact fun _ ‚Ü¶ by simpa\n  let K : ‚Ñï ‚Üí Set G := compactCovering G\n  let F : ‚Ñï √ó s ‚Üí Set X := fun p ‚Ü¶ (K p.1 ‚à© (p.2 : G) ‚Ä¢ V) ‚Ä¢ ({x} : Set X)\n  obtain ‚ü®‚ü®n, ‚ü®g, hg‚ü©‚ü©, hi‚ü© : ‚àÉ i, (interior (F i)).Nonempty := by\n    have : Nonempty X := ‚ü®x‚ü©\n    have : Encodable s := Countable.toEncodable s_count\n    apply nonempty_interior_of_iUnion_of_closed\n    ¬∑ rintro ‚ü®n, ‚ü®g, hg‚ü©‚ü©\n      apply IsCompact.isClosed\n      suffices H : IsCompact ((fun (g : G) ‚Ü¶ g ‚Ä¢ x) '' (K n ‚à© g ‚Ä¢ V)) by\n        simpa only [F, smul_singleton] using H\n      apply IsCompact.image\n      ¬∑ exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)\n      ¬∑ exact continuous_id.smul continuous_const\n    ¬∑ apply eq_univ_iff_forall.2 (fun y ‚Ü¶ ?_)\n      obtain ‚ü®h, rfl‚ü© : ‚àÉ h, h ‚Ä¢ x = y := exists_smul_eq G x y\n      obtain ‚ü®n, hn‚ü© : ‚àÉ n, h ‚àà K n := exists_mem_compactCovering h\n      obtain ‚ü®g, gs, hg‚ü© : ‚àÉ g ‚àà s, h ‚àà g ‚Ä¢ V := exists_set_mem_of_union_eq_top s _ hs _\n      simp only [F, smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists,\n        Subtype.exists, exists_prop]\n      exact ‚ü®n, g, gs, h, ‚ü®hn, hg‚ü©, rfl‚ü©\n  have I : (interior ((g ‚Ä¢ V) ‚Ä¢ {x})).Nonempty := by\n    apply hi.mono\n    apply interior_mono\n    exact smul_subset_smul_right inter_subset_right\n  obtain ‚ü®y, hy‚ü© : (interior (V ‚Ä¢ ({x} : Set X))).Nonempty := by\n    rw [smul_assoc, interior_smul] at I\n    exact smul_set_nonempty.1 I\n  obtain ‚ü®g', hg', rfl‚ü© : ‚àÉ g' ‚àà V, g' ‚Ä¢ x = y := by simpa using interior_subset hy\n  have J : (g' ‚Åª¬π ‚Ä¢ V) ‚Ä¢ {x} ‚àà ùìù x := by\n    apply mem_interior_iff_mem_nhds.1\n    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]\n  have : (g'‚Åª¬π ‚Ä¢ V) ‚Ä¢ {x} ‚äÜ U ‚Ä¢ ({x} : Set X) := by\n    apply smul_subset_smul_right\n    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_\n    rw [V_symm]\n    exact VU\n  exact Filter.mem_of_superset J this\n\n"}
{"name":"isOpenMap_smul_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Åπ : TopologicalSpace G\ninst‚úù‚Å∏ : TopologicalSpace X\ninst‚úù‚Å∑ : Group G\ninst‚úù‚Å∂ : TopologicalGroup G\ninst‚úù‚Åµ : MulAction G X\ninst‚úù‚Å¥ : SigmaCompactSpace G\ninst‚úù¬≥ : BaireSpace X\ninst‚úù¬≤ : T2Space X\ninst‚úù¬π : ContinuousSMul G X\ninst‚úù : MulAction.IsPretransitive G X\nx : X\n‚ä¢ IsOpenMap fun g => HSMul.hSMul g x","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open. This is a version of the open mapping theorem, valid notably for the\naction of a sigma-compact locally compact group on a locally compact space. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open. This is a version of the open mapping theorem, valid\nnotably for the action of a sigma-compact locally compact group on a locally compact space.\"]\ntheorem isOpenMap_smul_of_sigmaCompact (x : X) : IsOpenMap (fun (g : G) ‚Ü¶ g ‚Ä¢ x) := by\n  /- We have already proved the theorem around the basepoint of the orbit, in\n  `smul_singleton_mem_nhds_of_sigmaCompact`. The general statement follows around an arbitrary\n  point by changing basepoints. -/\n  simp_rw [isOpenMap_iff_nhds_le, Filter.le_map_iff]\n  intro g U hU\n  have : (¬∑ ‚Ä¢ x) = (¬∑ ‚Ä¢ (g ‚Ä¢ x)) ‚àò (¬∑ * g‚Åª¬π) := by\n    ext g\n    simp [smul_smul]\n  rw [this, image_comp, ‚Üê smul_singleton]\n  apply smul_singleton_mem_nhds_of_sigmaCompact\n  simpa using isOpenMap_mul_right g‚Åª¬π |>.image_mem_nhds hU\n\n"}
{"name":"isOpenMap_vadd_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst‚úù‚Åπ : TopologicalSpace G\ninst‚úù‚Å∏ : TopologicalSpace X\ninst‚úù‚Å∑ : AddGroup G\ninst‚úù‚Å∂ : TopologicalAddGroup G\ninst‚úù‚Åµ : AddAction G X\ninst‚úù‚Å¥ : SigmaCompactSpace G\ninst‚úù¬≥ : BaireSpace X\ninst‚úù¬≤ : T2Space X\ninst‚úù¬π : ContinuousVAdd G X\ninst‚úù : AddAction.IsPretransitive G X\nx : X\n‚ä¢ IsOpenMap fun g => HVAdd.hVAdd g x","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open. This is a version of the open mapping theorem, valid notably for the\naction of a sigma-compact locally compact group on a locally compact space. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open. This is a version of the open mapping theorem, valid\nnotably for the action of a sigma-compact locally compact group on a locally compact space.\"]\ntheorem isOpenMap_smul_of_sigmaCompact (x : X) : IsOpenMap (fun (g : G) ‚Ü¶ g ‚Ä¢ x) := by\n  /- We have already proved the theorem around the basepoint of the orbit, in\n  `smul_singleton_mem_nhds_of_sigmaCompact`. The general statement follows around an arbitrary\n  point by changing basepoints. -/\n  simp_rw [isOpenMap_iff_nhds_le, Filter.le_map_iff]\n  intro g U hU\n  have : (¬∑ ‚Ä¢ x) = (¬∑ ‚Ä¢ (g ‚Ä¢ x)) ‚àò (¬∑ * g‚Åª¬π) := by\n    ext g\n    simp [smul_smul]\n  rw [this, image_comp, ‚Üê smul_singleton]\n  apply smul_singleton_mem_nhds_of_sigmaCompact\n  simpa using isOpenMap_mul_right g‚Åª¬π |>.image_mem_nhds hU\n\n"}
{"name":"MonoidHom.isOpenMap_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace G\ninst‚úù‚Å∑ : Group G\ninst‚úù‚Å∂ : TopologicalGroup G\ninst‚úù‚Åµ : SigmaCompactSpace G\nH : Type u_3\ninst‚úù‚Å¥ : Group H\ninst‚úù¬≥ : TopologicalSpace H\ninst‚úù¬≤ : BaireSpace H\ninst‚úù¬π : T2Space H\ninst‚úù : ContinuousMul H\nf : MonoidHom G H\nhf : Function.Surjective ‚áëf\nh'f : Continuous ‚áëf\n‚ä¢ IsOpenMap ‚áëf","decl":"/-- A surjective morphism of topological groups is open when the source group is sigma-compact and\nthe target group is a Baire space (for instance a locally compact group). -/\n@[to_additive]\ntheorem MonoidHom.isOpenMap_of_sigmaCompact\n    {H : Type*} [Group H] [TopologicalSpace H] [BaireSpace H] [T2Space H] [ContinuousMul H]\n    (f : G ‚Üí* H) (hf : Function.Surjective f) (h'f : Continuous f) :\n    IsOpenMap f := by\n  let A : MulAction G H := MulAction.compHom _ f\n  have : ContinuousSMul G H := continuousSMul_compHom h'f\n  have : IsPretransitive G H := isPretransitive_compHom hf\n  have : f = (fun (g : G) ‚Ü¶ g ‚Ä¢ (1 : H)) := by simp [A, MulAction.compHom_smul_def]\n  rw [this]\n  exact isOpenMap_smul_of_sigmaCompact _\n"}
{"name":"AddMonoidHom.isOpenMap_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace G\ninst‚úù‚Å∑ : AddGroup G\ninst‚úù‚Å∂ : TopologicalAddGroup G\ninst‚úù‚Åµ : SigmaCompactSpace G\nH : Type u_3\ninst‚úù‚Å¥ : AddGroup H\ninst‚úù¬≥ : TopologicalSpace H\ninst‚úù¬≤ : BaireSpace H\ninst‚úù¬π : T2Space H\ninst‚úù : ContinuousAdd H\nf : AddMonoidHom G H\nhf : Function.Surjective ‚áëf\nh'f : Continuous ‚áëf\n‚ä¢ IsOpenMap ‚áëf","decl":"/-- A surjective morphism of topological groups is open when the source group is sigma-compact and\nthe target group is a Baire space (for instance a locally compact group). -/\n@[to_additive]\ntheorem MonoidHom.isOpenMap_of_sigmaCompact\n    {H : Type*} [Group H] [TopologicalSpace H] [BaireSpace H] [T2Space H] [ContinuousMul H]\n    (f : G ‚Üí* H) (hf : Function.Surjective f) (h'f : Continuous f) :\n    IsOpenMap f := by\n  let A : MulAction G H := MulAction.compHom _ f\n  have : ContinuousSMul G H := continuousSMul_compHom h'f\n  have : IsPretransitive G H := isPretransitive_compHom hf\n  have : f = (fun (g : G) ‚Ü¶ g ‚Ä¢ (1 : H)) := by simp [A, MulAction.compHom_smul_def]\n  rw [this]\n  exact isOpenMap_smul_of_sigmaCompact _\n"}
