{"name":"smul_singleton_mem_nhds_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MulAction G X\ninst✝⁴ : SigmaCompactSpace G\ninst✝³ : BaireSpace X\ninst✝² : T2Space X\ninst✝¹ : ContinuousSMul G X\ninst✝ : MulAction.IsPretransitive G X\nU : Set G\nhU : Membership.mem (nhds 1) U\nx : X\n⊢ Membership.mem (nhds x) (HSMul.hSMul U (Singleton.singleton x))","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open around the identity. It follows in `isOpenMap_smul_of_sigmaCompact` that it\nis open around any point. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open around zero. It follows in\n`isOpenMap_vadd_of_sigmaCompact` that it is open around any point.\"]\ntheorem smul_singleton_mem_nhds_of_sigmaCompact\n    {U : Set G} (hU : U ∈ 𝓝 1) (x : X) : U • {x} ∈ 𝓝 x := by\n  /- Consider a small closed neighborhood `V` of the identity. Then the group is covered by\n  countably many translates of `V`, say `gᵢ V`. Let also `Kₙ` be a sequence of compact sets covering\n  the space. Then the image of `Kₙ ∩ gᵢ V` in the orbit is compact, and their unions covers the\n  space. By Baire, one of them has nonempty interior. Then `gᵢ V • x` has nonempty interior, and\n  so does `V • x`. Its interior contains a point `g' x` with `g' ∈ V`. Then `g'⁻¹ • V • x` contains\n  a neighborhood of `x`, and it is included in `V⁻¹ • V • x`, which is itself contained in `U • x`\n  if `V` is small enough. -/\n  obtain ⟨V, V_mem, V_closed, V_symm, VU⟩ : ∃ V ∈ 𝓝 (1 : G), IsClosed V ∧ V⁻¹ = V ∧ V * V ⊆ U :=\n    exists_closed_nhds_one_inv_eq_mul_subset hU\n  obtain ⟨s, s_count, hs⟩ : ∃ (s : Set G), s.Countable ∧ ⋃ g ∈ s, g • V = univ :=\n    countable_cover_nhds_of_sigmaCompact fun _ ↦ by simpa\n  let K : ℕ → Set G := compactCovering G\n  let F : ℕ × s → Set X := fun p ↦ (K p.1 ∩ (p.2 : G) • V) • ({x} : Set X)\n  obtain ⟨⟨n, ⟨g, hg⟩⟩, hi⟩ : ∃ i, (interior (F i)).Nonempty := by\n    have : Nonempty X := ⟨x⟩\n    have : Encodable s := Countable.toEncodable s_count\n    apply nonempty_interior_of_iUnion_of_closed\n    · rintro ⟨n, ⟨g, hg⟩⟩\n      apply IsCompact.isClosed\n      suffices H : IsCompact ((fun (g : G) ↦ g • x) '' (K n ∩ g • V)) by\n        simpa only [F, smul_singleton] using H\n      apply IsCompact.image\n      · exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)\n      · exact continuous_id.smul continuous_const\n    · apply eq_univ_iff_forall.2 (fun y ↦ ?_)\n      obtain ⟨h, rfl⟩ : ∃ h, h • x = y := exists_smul_eq G x y\n      obtain ⟨n, hn⟩ : ∃ n, h ∈ K n := exists_mem_compactCovering h\n      obtain ⟨g, gs, hg⟩ : ∃ g ∈ s, h ∈ g • V := exists_set_mem_of_union_eq_top s _ hs _\n      simp only [F, smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists,\n        Subtype.exists, exists_prop]\n      exact ⟨n, g, gs, h, ⟨hn, hg⟩, rfl⟩\n  have I : (interior ((g • V) • {x})).Nonempty := by\n    apply hi.mono\n    apply interior_mono\n    exact smul_subset_smul_right inter_subset_right\n  obtain ⟨y, hy⟩ : (interior (V • ({x} : Set X))).Nonempty := by\n    rw [smul_assoc, interior_smul] at I\n    exact smul_set_nonempty.1 I\n  obtain ⟨g', hg', rfl⟩ : ∃ g' ∈ V, g' • x = y := by simpa using interior_subset hy\n  have J : (g' ⁻¹ • V) • {x} ∈ 𝓝 x := by\n    apply mem_interior_iff_mem_nhds.1\n    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]\n  have : (g'⁻¹ • V) • {x} ⊆ U • ({x} : Set X) := by\n    apply smul_subset_smul_right\n    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_\n    rw [V_symm]\n    exact VU\n  exact Filter.mem_of_superset J this\n\n"}
{"name":"vadd_singleton_mem_nhds_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : AddAction G X\ninst✝⁴ : SigmaCompactSpace G\ninst✝³ : BaireSpace X\ninst✝² : T2Space X\ninst✝¹ : ContinuousVAdd G X\ninst✝ : AddAction.IsPretransitive G X\nU : Set G\nhU : Membership.mem (nhds 0) U\nx : X\n⊢ Membership.mem (nhds x) (HVAdd.hVAdd U (Singleton.singleton x))","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open around the identity. It follows in `isOpenMap_smul_of_sigmaCompact` that it\nis open around any point. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open around zero. It follows in\n`isOpenMap_vadd_of_sigmaCompact` that it is open around any point.\"]\ntheorem smul_singleton_mem_nhds_of_sigmaCompact\n    {U : Set G} (hU : U ∈ 𝓝 1) (x : X) : U • {x} ∈ 𝓝 x := by\n  /- Consider a small closed neighborhood `V` of the identity. Then the group is covered by\n  countably many translates of `V`, say `gᵢ V`. Let also `Kₙ` be a sequence of compact sets covering\n  the space. Then the image of `Kₙ ∩ gᵢ V` in the orbit is compact, and their unions covers the\n  space. By Baire, one of them has nonempty interior. Then `gᵢ V • x` has nonempty interior, and\n  so does `V • x`. Its interior contains a point `g' x` with `g' ∈ V`. Then `g'⁻¹ • V • x` contains\n  a neighborhood of `x`, and it is included in `V⁻¹ • V • x`, which is itself contained in `U • x`\n  if `V` is small enough. -/\n  obtain ⟨V, V_mem, V_closed, V_symm, VU⟩ : ∃ V ∈ 𝓝 (1 : G), IsClosed V ∧ V⁻¹ = V ∧ V * V ⊆ U :=\n    exists_closed_nhds_one_inv_eq_mul_subset hU\n  obtain ⟨s, s_count, hs⟩ : ∃ (s : Set G), s.Countable ∧ ⋃ g ∈ s, g • V = univ :=\n    countable_cover_nhds_of_sigmaCompact fun _ ↦ by simpa\n  let K : ℕ → Set G := compactCovering G\n  let F : ℕ × s → Set X := fun p ↦ (K p.1 ∩ (p.2 : G) • V) • ({x} : Set X)\n  obtain ⟨⟨n, ⟨g, hg⟩⟩, hi⟩ : ∃ i, (interior (F i)).Nonempty := by\n    have : Nonempty X := ⟨x⟩\n    have : Encodable s := Countable.toEncodable s_count\n    apply nonempty_interior_of_iUnion_of_closed\n    · rintro ⟨n, ⟨g, hg⟩⟩\n      apply IsCompact.isClosed\n      suffices H : IsCompact ((fun (g : G) ↦ g • x) '' (K n ∩ g • V)) by\n        simpa only [F, smul_singleton] using H\n      apply IsCompact.image\n      · exact (isCompact_compactCovering G n).inter_right (V_closed.smul g)\n      · exact continuous_id.smul continuous_const\n    · apply eq_univ_iff_forall.2 (fun y ↦ ?_)\n      obtain ⟨h, rfl⟩ : ∃ h, h • x = y := exists_smul_eq G x y\n      obtain ⟨n, hn⟩ : ∃ n, h ∈ K n := exists_mem_compactCovering h\n      obtain ⟨g, gs, hg⟩ : ∃ g ∈ s, h ∈ g • V := exists_set_mem_of_union_eq_top s _ hs _\n      simp only [F, smul_singleton, mem_iUnion, mem_image, mem_inter_iff, Prod.exists,\n        Subtype.exists, exists_prop]\n      exact ⟨n, g, gs, h, ⟨hn, hg⟩, rfl⟩\n  have I : (interior ((g • V) • {x})).Nonempty := by\n    apply hi.mono\n    apply interior_mono\n    exact smul_subset_smul_right inter_subset_right\n  obtain ⟨y, hy⟩ : (interior (V • ({x} : Set X))).Nonempty := by\n    rw [smul_assoc, interior_smul] at I\n    exact smul_set_nonempty.1 I\n  obtain ⟨g', hg', rfl⟩ : ∃ g' ∈ V, g' • x = y := by simpa using interior_subset hy\n  have J : (g' ⁻¹ • V) • {x} ∈ 𝓝 x := by\n    apply mem_interior_iff_mem_nhds.1\n    rwa [smul_assoc, interior_smul, mem_inv_smul_set_iff]\n  have : (g'⁻¹ • V) • {x} ⊆ U • ({x} : Set X) := by\n    apply smul_subset_smul_right\n    apply Subset.trans (smul_set_subset_smul (inv_mem_inv.2 hg')) ?_\n    rw [V_symm]\n    exact VU\n  exact Filter.mem_of_superset J this\n\n"}
{"name":"isOpenMap_smul_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : MulAction G X\ninst✝⁴ : SigmaCompactSpace G\ninst✝³ : BaireSpace X\ninst✝² : T2Space X\ninst✝¹ : ContinuousSMul G X\ninst✝ : MulAction.IsPretransitive G X\nx : X\n⊢ IsOpenMap fun g => HSMul.hSMul g x","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open. This is a version of the open mapping theorem, valid notably for the\naction of a sigma-compact locally compact group on a locally compact space. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open. This is a version of the open mapping theorem, valid\nnotably for the action of a sigma-compact locally compact group on a locally compact space.\"]\ntheorem isOpenMap_smul_of_sigmaCompact (x : X) : IsOpenMap (fun (g : G) ↦ g • x) := by\n  /- We have already proved the theorem around the basepoint of the orbit, in\n  `smul_singleton_mem_nhds_of_sigmaCompact`. The general statement follows around an arbitrary\n  point by changing basepoints. -/\n  simp_rw [isOpenMap_iff_nhds_le, Filter.le_map_iff]\n  intro g U hU\n  have : (· • x) = (· • (g • x)) ∘ (· * g⁻¹) := by\n    ext g\n    simp [smul_smul]\n  rw [this, image_comp, ← smul_singleton]\n  apply smul_singleton_mem_nhds_of_sigmaCompact\n  simpa using isOpenMap_mul_right g⁻¹ |>.image_mem_nhds hU\n\n"}
{"name":"isOpenMap_vadd_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\nX : Type u_2\ninst✝⁹ : TopologicalSpace G\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : AddAction G X\ninst✝⁴ : SigmaCompactSpace G\ninst✝³ : BaireSpace X\ninst✝² : T2Space X\ninst✝¹ : ContinuousVAdd G X\ninst✝ : AddAction.IsPretransitive G X\nx : X\n⊢ IsOpenMap fun g => HVAdd.hVAdd g x","decl":"/-- Consider a sigma-compact group acting continuously and transitively on a Baire space. Then\nthe orbit map is open. This is a version of the open mapping theorem, valid notably for the\naction of a sigma-compact locally compact group on a locally compact space. -/\n@[to_additive \"Consider a sigma-compact additive group acting continuously and transitively on a\nBaire space. Then the orbit map is open. This is a version of the open mapping theorem, valid\nnotably for the action of a sigma-compact locally compact group on a locally compact space.\"]\ntheorem isOpenMap_smul_of_sigmaCompact (x : X) : IsOpenMap (fun (g : G) ↦ g • x) := by\n  /- We have already proved the theorem around the basepoint of the orbit, in\n  `smul_singleton_mem_nhds_of_sigmaCompact`. The general statement follows around an arbitrary\n  point by changing basepoints. -/\n  simp_rw [isOpenMap_iff_nhds_le, Filter.le_map_iff]\n  intro g U hU\n  have : (· • x) = (· • (g • x)) ∘ (· * g⁻¹) := by\n    ext g\n    simp [smul_smul]\n  rw [this, image_comp, ← smul_singleton]\n  apply smul_singleton_mem_nhds_of_sigmaCompact\n  simpa using isOpenMap_mul_right g⁻¹ |>.image_mem_nhds hU\n\n"}
{"name":"MonoidHom.isOpenMap_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalGroup G\ninst✝⁵ : SigmaCompactSpace G\nH : Type u_3\ninst✝⁴ : Group H\ninst✝³ : TopologicalSpace H\ninst✝² : BaireSpace H\ninst✝¹ : T2Space H\ninst✝ : ContinuousMul H\nf : MonoidHom G H\nhf : Function.Surjective ⇑f\nh'f : Continuous ⇑f\n⊢ IsOpenMap ⇑f","decl":"/-- A surjective morphism of topological groups is open when the source group is sigma-compact and\nthe target group is a Baire space (for instance a locally compact group). -/\n@[to_additive]\ntheorem MonoidHom.isOpenMap_of_sigmaCompact\n    {H : Type*} [Group H] [TopologicalSpace H] [BaireSpace H] [T2Space H] [ContinuousMul H]\n    (f : G →* H) (hf : Function.Surjective f) (h'f : Continuous f) :\n    IsOpenMap f := by\n  let A : MulAction G H := MulAction.compHom _ f\n  have : ContinuousSMul G H := continuousSMul_compHom h'f\n  have : IsPretransitive G H := isPretransitive_compHom hf\n  have : f = (fun (g : G) ↦ g • (1 : H)) := by simp [A, MulAction.compHom_smul_def]\n  rw [this]\n  exact isOpenMap_smul_of_sigmaCompact _\n"}
{"name":"AddMonoidHom.isOpenMap_of_sigmaCompact","module":"Mathlib.Topology.Algebra.Group.OpenMapping","initialProofState":"G : Type u_1\ninst✝⁸ : TopologicalSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalAddGroup G\ninst✝⁵ : SigmaCompactSpace G\nH : Type u_3\ninst✝⁴ : AddGroup H\ninst✝³ : TopologicalSpace H\ninst✝² : BaireSpace H\ninst✝¹ : T2Space H\ninst✝ : ContinuousAdd H\nf : AddMonoidHom G H\nhf : Function.Surjective ⇑f\nh'f : Continuous ⇑f\n⊢ IsOpenMap ⇑f","decl":"/-- A surjective morphism of topological groups is open when the source group is sigma-compact and\nthe target group is a Baire space (for instance a locally compact group). -/\n@[to_additive]\ntheorem MonoidHom.isOpenMap_of_sigmaCompact\n    {H : Type*} [Group H] [TopologicalSpace H] [BaireSpace H] [T2Space H] [ContinuousMul H]\n    (f : G →* H) (hf : Function.Surjective f) (h'f : Continuous f) :\n    IsOpenMap f := by\n  let A : MulAction G H := MulAction.compHom _ f\n  have : ContinuousSMul G H := continuousSMul_compHom h'f\n  have : IsPretransitive G H := isPretransitive_compHom hf\n  have : f = (fun (g : G) ↦ g • (1 : H)) := by simp [A, MulAction.compHom_smul_def]\n  rw [this]\n  exact isOpenMap_smul_of_sigmaCompact _\n"}
