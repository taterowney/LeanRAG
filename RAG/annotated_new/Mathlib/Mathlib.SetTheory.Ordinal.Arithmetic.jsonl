{"name":"Ordinal.lift_add","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{v}\n⊢ Eq (Ordinal.lift.{u, v} (HAdd.hAdd a b)) (HAdd.hAdd (Ordinal.lift.{u, v} a) (Ordinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_add (a b : Ordinal.{v}) : lift.{u} (a + b) = lift.{u} a + lift.{u} b :=\n  Quotient.inductionOn₂ a b fun ⟨_α, _r, _⟩ ⟨_β, _s, _⟩ =>\n    Quotient.sound\n      ⟨(RelIso.preimage Equiv.ulift _).trans\n          (RelIso.sumLexCongr (RelIso.preimage Equiv.ulift _) (RelIso.preimage Equiv.ulift _)).symm⟩\n\n"}
{"name":"Ordinal.lift_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{v}\n⊢ Eq (Ordinal.lift.{u, v} (Order.succ a)) (Order.succ (Ordinal.lift.{u, v} a))","decl":"@[simp]\ntheorem lift_succ (a : Ordinal.{v}) : lift.{u} (succ a) = succ (lift.{u} a) := by\n  rw [← add_one_eq_succ, lift_add, lift_one]\n  rfl\n\n"}
{"name":"Ordinal.instAddLeftReflectLE","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ AddLeftReflectLE Ordinal.{u}","decl":"instance instAddLeftReflectLE :\n    AddLeftReflectLE Ordinal.{u} where\n  elim c a b := by\n    refine inductionOn₃ a b c fun α r _ β s _ γ t _ ⟨f⟩ ↦ ?_\n    have H₁ a : f (Sum.inl a) = Sum.inl a := by\n      simpa using ((InitialSeg.leAdd t r).trans f).eq (InitialSeg.leAdd t s) a\n    have H₂ a : ∃ b, f (Sum.inr a) = Sum.inr b := by\n      generalize hx : f (Sum.inr a) = x\n      obtain x | x := x\n      · rw [← H₁, f.inj] at hx\n        contradiction\n      · exact ⟨x, rfl⟩\n    choose g hg using H₂\n    refine (RelEmbedding.ofMonotone g fun _ _ h ↦ ?_).ordinal_type_le\n    rwa [← @Sum.lex_inr_inr _ t _ s, ← hg, ← hg, f.map_rel_iff, Sum.lex_inr_inr]\n\n"}
{"name":"Ordinal.instIsLeftCancelAdd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ IsLeftCancelAdd Ordinal.{u_4}","decl":"instance : IsLeftCancelAdd Ordinal where\n  add_left_cancel a b c h := by simpa only [le_antisymm_iff, add_le_add_iff_left] using h\n\n"}
{"name":"Ordinal.add_left_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"@[deprecated add_left_cancel_iff (since := \"2024-12-11\")]\nprotected theorem add_left_cancel (a) {b c : Ordinal} : a + b = a + c ↔ b = c :=\n  add_left_cancel_iff\n\n"}
{"name":"Ordinal.instAddLeftStrictMono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ AddLeftStrictMono Ordinal.{u}","decl":"instance instAddLeftStrictMono : AddLeftStrictMono Ordinal.{u} :=\n  ⟨fun a _b _c ↦ (add_lt_add_iff_left' a).2⟩\n\n"}
{"name":"Ordinal.instAddLeftReflectLT","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ AddLeftReflectLT Ordinal.{u}","decl":"instance instAddLeftReflectLT : AddLeftReflectLT Ordinal.{u} :=\n  ⟨fun a _b _c ↦ (add_lt_add_iff_left' a).1⟩\n\n"}
{"name":"Ordinal.instAddRightReflectLT","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ AddRightReflectLT Ordinal.{u}","decl":"instance instAddRightReflectLT : AddRightReflectLT Ordinal.{u} :=\n  ⟨fun _a _b _c ↦ lt_imp_lt_of_le_imp_le fun h => add_le_add_right h _⟩\n\n"}
{"name":"Ordinal.add_le_add_iff_right","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nn : Nat\n⊢ Iff (LE.le (HAdd.hAdd a ↑n) (HAdd.hAdd b ↑n)) (LE.le a b)","decl":"theorem add_le_add_iff_right {a b : Ordinal} : ∀ n : ℕ, a + n ≤ b + n ↔ a ≤ b\n  | 0 => by simp\n  | n + 1 => by\n    simp only [natCast_succ, add_succ, add_succ, succ_le_succ_iff, add_le_add_iff_right]\n\n"}
{"name":"Ordinal.add_right_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nn : Nat\n⊢ Iff (Eq (HAdd.hAdd a ↑n) (HAdd.hAdd b ↑n)) (Eq a b)","decl":"theorem add_right_cancel {a b : Ordinal} (n : ℕ) : a + n = b + n ↔ a = b := by\n  simp only [le_antisymm_iff, add_le_add_iff_right]\n\n"}
{"name":"Ordinal.add_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"theorem add_eq_zero_iff {a b : Ordinal} : a + b = 0 ↔ a = 0 ∧ b = 0 :=\n  inductionOn₂ a b fun α r _ β s _ => by\n    simp_rw [← type_sum_lex, type_eq_zero_iff_isEmpty]\n    exact isEmpty_sum\n\n"}
{"name":"Ordinal.left_eq_zero_of_add_eq_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"theorem left_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : a = 0 :=\n  (add_eq_zero_iff.1 h).1\n\n"}
{"name":"Ordinal.right_eq_zero_of_add_eq_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : Eq (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"theorem right_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : b = 0 :=\n  (add_eq_zero_iff.1 h).2\n\n"}
{"name":"Ordinal.pred_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Eq (Order.succ o).pred o","decl":"@[simp]\ntheorem pred_succ (o) : pred (succ o) = o := by\n  have h : ∃ a, succ o = succ a := ⟨_, rfl⟩\n  simpa only [pred, dif_pos h] using (succ_injective <| Classical.choose_spec h).symm\n\n"}
{"name":"Ordinal.pred_le_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ LE.le o.pred o","decl":"theorem pred_le_self (o) : pred o ≤ o := by\n  classical\n  exact if h : ∃ a, o = succ a then by\n    let ⟨a, e⟩ := h\n    rw [e, pred_succ]; exact le_succ a\n  else by rw [pred, dif_neg h]\n\n"}
{"name":"Ordinal.pred_eq_iff_not_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Iff (Eq o.pred o) (Not (Exists fun a => Eq o (Order.succ a)))","decl":"theorem pred_eq_iff_not_succ {o} : pred o = o ↔ ¬∃ a, o = succ a :=\n  ⟨fun e ⟨a, e'⟩ => by rw [e', pred_succ] at e; exact (lt_succ a).ne e, fun h => dif_neg h⟩\n\n"}
{"name":"Ordinal.pred_eq_iff_not_succ'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Iff (Eq o.pred o) (∀ (a : Ordinal.{u_4}), Ne o (Order.succ a))","decl":"theorem pred_eq_iff_not_succ' {o} : pred o = o ↔ ∀ a, o ≠ succ a := by\n  simpa using pred_eq_iff_not_succ\n\n"}
{"name":"Ordinal.pred_lt_iff_is_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Iff (LT.lt o.pred o) (Exists fun a => Eq o (Order.succ a))","decl":"theorem pred_lt_iff_is_succ {o} : pred o < o ↔ ∃ a, o = succ a :=\n  Iff.trans (by simp only [le_antisymm_iff, pred_le_self, true_and, not_le])\n    (iff_not_comm.1 pred_eq_iff_not_succ).symm\n\n"}
{"name":"Ordinal.pred_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Eq (Ordinal.pred 0) 0","decl":"@[simp]\ntheorem pred_zero : pred 0 = 0 :=\n  pred_eq_iff_not_succ'.2 fun a => (succ_ne_zero a).symm\n\n"}
{"name":"Ordinal.succ_pred_iff_is_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Iff (Eq (Order.succ o.pred) o) (Exists fun a => Eq o (Order.succ a))","decl":"theorem succ_pred_iff_is_succ {o} : succ (pred o) = o ↔ ∃ a, o = succ a :=\n  ⟨fun e => ⟨_, e.symm⟩, fun ⟨a, e⟩ => by simp only [e, pred_succ]⟩\n\n"}
{"name":"Ordinal.succ_lt_of_not_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o b : Ordinal.{u_4}\nh : Not (Exists fun a => Eq o (Order.succ a))\n⊢ Iff (LT.lt (Order.succ b) o) (LT.lt b o)","decl":"theorem succ_lt_of_not_succ {o b : Ordinal} (h : ¬∃ a, o = succ a) : succ b < o ↔ b < o :=\n  ⟨(lt_succ b).trans, fun l => lt_of_le_of_ne (succ_le_of_lt l) fun e => h ⟨_, e.symm⟩⟩\n\n"}
{"name":"Ordinal.lt_pred","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (LT.lt a b.pred) (LT.lt (Order.succ a) b)","decl":"theorem lt_pred {a b} : a < pred b ↔ succ a < b := by\n  classical\n  exact if h : ∃ a, b = succ a then by\n    let ⟨c, e⟩ := h\n    rw [e, pred_succ, succ_lt_succ_iff]\n  else by simp only [pred, dif_neg h, succ_lt_of_not_succ h]\n\n"}
{"name":"Ordinal.pred_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (LE.le a.pred b) (LE.le a (Order.succ b))","decl":"theorem pred_le {a b} : pred a ≤ b ↔ a ≤ succ b :=\n  le_iff_le_iff_lt_iff_lt.2 lt_pred\n\n"}
{"name":"Ordinal.lift_is_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{v}\n⊢ Iff (Exists fun a => Eq (Ordinal.lift.{u, v} o) (Order.succ a)) (Exists fun a => Eq o (Order.succ a))","decl":"@[simp]\ntheorem lift_is_succ {o : Ordinal.{v}} : (∃ a, lift.{u} o = succ a) ↔ ∃ a, o = succ a :=\n  ⟨fun ⟨a, h⟩ =>\n    let ⟨b, e⟩ := mem_range_lift_of_le <| show a ≤ lift.{u} o from le_of_lt <| h.symm ▸ lt_succ a\n    ⟨b, (lift_inj.{u,v}).1 <| by rw [h, ← e, lift_succ]⟩,\n    fun ⟨a, h⟩ => ⟨lift.{u} a, by simp only [h, lift_succ]⟩⟩\n\n"}
{"name":"Ordinal.lift_pred","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{v}\n⊢ Eq (Ordinal.lift.{u, v} o.pred) (Ordinal.lift.{u, v} o).pred","decl":"@[simp]\ntheorem lift_pred (o : Ordinal.{v}) : lift.{u} (pred o) = pred (lift.{u} o) := by\n  classical\n  exact if h : ∃ a, o = succ a then by cases' h with a e; simp only [e, pred_succ, lift_succ]\n  else by rw [pred_eq_iff_not_succ.2 h, pred_eq_iff_not_succ.2 (mt lift_is_succ.1 h)]\n\n"}
{"name":"Ordinal.isLimit_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Iff o.IsLimit (And (Ne o 0) (Order.IsSuccPrelimit o))","decl":"theorem isLimit_iff {o} : IsLimit o ↔ o ≠ 0 ∧ IsSuccPrelimit o := by\n  simp [IsLimit, IsSuccLimit]\n\n"}
{"name":"Ordinal.IsLimit.isSuccPrelimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Order.IsSuccPrelimit o","decl":"theorem IsLimit.isSuccPrelimit {o} (h : IsLimit o) : IsSuccPrelimit o :=\n  IsSuccLimit.isSuccPrelimit h\n\n"}
{"name":"Ordinal.IsLimit.isSuccLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Order.IsSuccPrelimit o","decl":"@[deprecated IsLimit.isSuccPrelimit (since := \"2024-09-05\")]\nalias IsLimit.isSuccLimit := IsLimit.isSuccPrelimit\n\n"}
{"name":"Ordinal.IsLimit.succ_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o a : Ordinal.{u_4}\nh : o.IsLimit\na✝ : LT.lt a o\n⊢ LT.lt (Order.succ a) o","decl":"theorem IsLimit.succ_lt {o a : Ordinal} (h : IsLimit o) : a < o → succ a < o :=\n  IsSuccLimit.succ_lt h\n\n"}
{"name":"Ordinal.isSuccPrelimit_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Order.IsSuccPrelimit 0","decl":"theorem isSuccPrelimit_zero : IsSuccPrelimit (0 : Ordinal) := isSuccPrelimit_bot\n\n"}
{"name":"Ordinal.isSuccLimit_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Order.IsSuccPrelimit 0","decl":"@[deprecated isSuccPrelimit_zero (since := \"2024-09-05\")]\nalias isSuccLimit_zero := isSuccPrelimit_zero\n\n"}
{"name":"Ordinal.not_zero_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Not (Ordinal.IsLimit 0)","decl":"theorem not_zero_isLimit : ¬IsLimit 0 :=\n  not_isSuccLimit_bot\n\n"}
{"name":"Ordinal.not_succ_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Not (Order.succ o).IsLimit","decl":"theorem not_succ_isLimit (o) : ¬IsLimit (succ o) :=\n  not_isSuccLimit_succ o\n\n"}
{"name":"Ordinal.not_succ_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Not (Exists fun a => Eq o (Order.succ a))","decl":"theorem not_succ_of_isLimit {o} (h : IsLimit o) : ¬∃ a, o = succ a\n  | ⟨a, e⟩ => not_succ_isLimit a (e ▸ h)\n\n"}
{"name":"Ordinal.succ_lt_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o a : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Iff (LT.lt (Order.succ a) o) (LT.lt a o)","decl":"theorem succ_lt_of_isLimit {o a : Ordinal} (h : IsLimit o) : succ a < o ↔ a < o :=\n  IsSuccLimit.succ_lt_iff h\n\n"}
{"name":"Ordinal.le_succ_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\na : Ordinal.{u_4}\n⊢ Iff (LE.le o (Order.succ a)) (LE.le o a)","decl":"theorem le_succ_of_isLimit {o} (h : IsLimit o) {a} : o ≤ succ a ↔ o ≤ a :=\n  le_iff_le_iff_lt_iff_lt.2 <| succ_lt_of_isLimit h\n\n"}
{"name":"Ordinal.limit_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\na : Ordinal.{u_4}\n⊢ Iff (LE.le o a) (∀ (x : Ordinal.{u_4}), LT.lt x o → LE.le x a)","decl":"theorem limit_le {o} (h : IsLimit o) {a} : o ≤ a ↔ ∀ x < o, x ≤ a :=\n  ⟨fun h _x l => l.le.trans h, fun H =>\n    (le_succ_of_isLimit h).1 <| le_of_not_lt fun hn => not_lt_of_le (H _ hn) (lt_succ a)⟩\n\n"}
{"name":"Ordinal.lt_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\na : Ordinal.{u_4}\n⊢ Iff (LT.lt a o) (Exists fun x => And (LT.lt x o) (LT.lt a x))","decl":"theorem lt_limit {o} (h : IsLimit o) {a} : a < o ↔ ∃ x < o, a < x := by\n  -- Porting note: `bex_def` is required.\n  simpa only [not_forall₂, not_le, bex_def] using not_congr (@limit_le _ h a)\n\n"}
{"name":"Ordinal.lift_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{v}\n⊢ Iff (Ordinal.lift.{u, v} o).IsLimit o.IsLimit","decl":"@[simp]\ntheorem lift_isLimit (o : Ordinal.{v}) : IsLimit (lift.{u,v} o) ↔ IsLimit o :=\n  liftInitialSeg.isSuccLimit_apply_iff\n\n"}
{"name":"Ordinal.IsLimit.pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ LT.lt 0 o","decl":"theorem IsLimit.pos {o : Ordinal} (h : IsLimit o) : 0 < o :=\n  IsSuccLimit.bot_lt h\n\n"}
{"name":"Ordinal.IsLimit.ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Ne o 0","decl":"theorem IsLimit.ne_zero {o : Ordinal} (h : IsLimit o) : o ≠ 0 :=\n  h.pos.ne'\n\n"}
{"name":"Ordinal.IsLimit.one_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ LT.lt 1 o","decl":"theorem IsLimit.one_lt {o : Ordinal} (h : IsLimit o) : 1 < o := by\n  simpa only [succ_zero] using h.succ_lt h.pos\n\n"}
{"name":"Ordinal.IsLimit.nat_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\nn : Nat\n⊢ LT.lt (↑n) o","decl":"theorem IsLimit.nat_lt {o : Ordinal} (h : IsLimit o) : ∀ n : ℕ, (n : Ordinal) < o\n  | 0 => h.pos\n  | n + 1 => h.succ_lt (IsLimit.nat_lt h n)\n\n"}
{"name":"Ordinal.zero_or_succ_or_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Or (Eq o 0) (Or (Exists fun a => Eq o (Order.succ a)) o.IsLimit)","decl":"theorem zero_or_succ_or_limit (o : Ordinal) : o = 0 ∨ (∃ a, o = succ a) ∨ IsLimit o := by\n  simpa [eq_comm] using isMin_or_mem_range_succ_or_isSuccLimit o\n\n"}
{"name":"Ordinal.isLimit_of_not_succ_of_ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : Not (Exists fun a => Eq o (Order.succ a))\nh' : Ne o 0\n⊢ o.IsLimit","decl":"theorem isLimit_of_not_succ_of_ne_zero {o : Ordinal} (h : ¬∃ a, o = succ a) (h' : o ≠ 0) :\n    IsLimit o := ((zero_or_succ_or_limit o).resolve_left h').resolve_left h\n\n-- TODO: this is an iff with `IsSuccPrelimit`\n"}
{"name":"Ordinal.IsLimit.sSup_Iio","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Eq (SupSet.sSup (Set.Iio o)) o","decl":"theorem IsLimit.sSup_Iio {o : Ordinal} (h : IsLimit o) : sSup (Iio o) = o := by\n  apply (csSup_le' (fun a ha ↦ le_of_lt ha)).antisymm\n  apply le_of_forall_lt\n  intro a ha\n  exact (lt_succ a).trans_le (le_csSup bddAbove_Iio (h.succ_lt ha))\n\n"}
{"name":"Ordinal.IsLimit.iSup_Iio","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nh : o.IsLimit\n⊢ Eq (iSup fun a => ↑a) o","decl":"theorem IsLimit.iSup_Iio {o : Ordinal} (h : IsLimit o) : ⨆ a : Iio o, a.1 = o := by\n  rw [← sSup_eq_iSup', h.sSup_Iio]\n\n"}
{"name":"Ordinal.limitRecOn_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"C : Ordinal.{u_4} → Sort u_5\nH₁ : C 0\nH₂ : (o : Ordinal.{u_4}) → C o → C (Order.succ o)\nH₃ : (o : Ordinal.{u_4}) → o.IsLimit → ((o' : Ordinal.{u_4}) → LT.lt o' o → C o') → C o\n⊢ Eq (Ordinal.limitRecOn 0 H₁ H₂ H₃) H₁","decl":"@[simp]\ntheorem limitRecOn_zero {C} (H₁ H₂ H₃) : @limitRecOn C 0 H₁ H₂ H₃ = H₁ :=\n  SuccOrder.limitRecOn_isMin _ _ _ isMin_bot\n\n"}
{"name":"Ordinal.limitRecOn_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"C : Ordinal.{u_4} → Sort u_5\no : Ordinal.{u_4}\nH₁ : C 0\nH₂ : (o : Ordinal.{u_4}) → C o → C (Order.succ o)\nH₃ : (o : Ordinal.{u_4}) → o.IsLimit → ((o' : Ordinal.{u_4}) → LT.lt o' o → C o') → C o\n⊢ Eq ((Order.succ o).limitRecOn H₁ H₂ H₃) (H₂ o (o.limitRecOn H₁ H₂ H₃))","decl":"@[simp]\ntheorem limitRecOn_succ {C} (o H₁ H₂ H₃) :\n    @limitRecOn C (succ o) H₁ H₂ H₃ = H₂ o (@limitRecOn C o H₁ H₂ H₃) :=\n  SuccOrder.limitRecOn_succ ..\n\n"}
{"name":"Ordinal.limitRecOn_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"C : Ordinal.{u_4} → Sort u_5\no : Ordinal.{u_4}\nH₁ : C 0\nH₂ : (o : Ordinal.{u_4}) → C o → C (Order.succ o)\nH₃ : (o : Ordinal.{u_4}) → o.IsLimit → ((o' : Ordinal.{u_4}) → LT.lt o' o → C o') → C o\nh : o.IsLimit\n⊢ Eq (o.limitRecOn H₁ H₂ H₃) (H₃ o h fun x _h => x.limitRecOn H₁ H₂ H₃)","decl":"@[simp]\ntheorem limitRecOn_limit {C} (o H₁ H₂ H₃ h) :\n    @limitRecOn C o H₁ H₂ H₃ = H₃ o h fun x _h => @limitRecOn C x H₁ H₂ H₃ :=\n  SuccOrder.limitRecOn_of_isSuccLimit ..\n\n"}
{"name":"Ordinal.boundedLimitRec_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"l : Ordinal.{u_4}\nlLim : l.IsLimit\nC : ↑(Set.Iio l) → Sort u_5\nH₁ : C ⟨0, ⋯⟩\nH₂ : (o : ↑(Set.Iio l)) → C o → C ⟨Order.succ ↑o, ⋯⟩\nH₃ : (o : ↑(Set.Iio l)) → (↑o).IsLimit → ((o' : ↑(Set.Iio l)) → LT.lt o' o → C o') → C o\n⊢ Eq (Ordinal.boundedLimitRecOn lLim ⟨0, ⋯⟩ H₁ H₂ H₃) H₁","decl":"@[simp]\ntheorem boundedLimitRec_zero {l} (lLim : l.IsLimit) {C} (H₁ H₂ H₃) :\n    @boundedLimitRecOn l lLim C ⟨0, lLim.pos⟩ H₁ H₂ H₃ = H₁ := by\n  rw [boundedLimitRecOn, limitRecOn_zero]\n\n"}
{"name":"Ordinal.boundedLimitRec_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"l : Ordinal.{u_4}\nlLim : l.IsLimit\nC : ↑(Set.Iio l) → Sort u_5\no : ↑(Set.Iio l)\nH₁ : C ⟨0, ⋯⟩\nH₂ : (o : ↑(Set.Iio l)) → C o → C ⟨Order.succ ↑o, ⋯⟩\nH₃ : (o : ↑(Set.Iio l)) → (↑o).IsLimit → ((o' : ↑(Set.Iio l)) → LT.lt o' o → C o') → C o\n⊢ Eq (Ordinal.boundedLimitRecOn lLim ⟨Order.succ ↑o, ⋯⟩ H₁ H₂ H₃) (H₂ o (Ordinal.boundedLimitRecOn lLim o H₁ H₂ H₃))","decl":"@[simp]\ntheorem boundedLimitRec_succ {l} (lLim : l.IsLimit) {C} (o H₁ H₂ H₃) :\n    @boundedLimitRecOn l lLim C ⟨succ o.1, lLim.succ_lt o.2⟩ H₁ H₂ H₃ = H₂ o\n    (@boundedLimitRecOn l lLim C o H₁ H₂ H₃) := by\n  rw [boundedLimitRecOn, limitRecOn_succ]\n  rfl\n\n"}
{"name":"Ordinal.boundedLimitRec_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"l : Ordinal.{u_4}\nlLim : l.IsLimit\nC : ↑(Set.Iio l) → Sort u_5\no : ↑(Set.Iio l)\nH₁ : C ⟨0, ⋯⟩\nH₂ : (o : ↑(Set.Iio l)) → C o → C ⟨Order.succ ↑o, ⋯⟩\nH₃ : (o : ↑(Set.Iio l)) → (↑o).IsLimit → ((o' : ↑(Set.Iio l)) → LT.lt o' o → C o') → C o\noLim : (↑o).IsLimit\n⊢ Eq (Ordinal.boundedLimitRecOn lLim o H₁ H₂ H₃) (H₃ o oLim fun x x_1 => Ordinal.boundedLimitRecOn lLim x H₁ H₂ H₃)","decl":"theorem boundedLimitRec_limit {l} (lLim : l.IsLimit) {C} (o H₁ H₂ H₃ oLim) :\n    @boundedLimitRecOn l lLim C o H₁ H₂ H₃ = H₃ o oLim (fun x _ ↦\n    @boundedLimitRecOn l lLim C x H₁ H₂ H₃) := by\n  rw [boundedLimitRecOn, limitRecOn_limit]\n  rfl\n\n"}
{"name":"Ordinal.enum_succ_eq_top","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Eq ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨o, ⋯⟩) Top.top","decl":"theorem enum_succ_eq_top {o : Ordinal} :\n    enum (α := (succ o).toType) (· < ·) ⟨o, type_toType _ ▸ lt_succ o⟩ = ⊤ :=\n  rfl\n\n"}
{"name":"Ordinal.has_succ_of_type_succ_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_4\nr : α → α → Prop\nwo : IsWellOrder α r\nh : ∀ (a : Ordinal.{u_4}), LT.lt a (Ordinal.type r) → LT.lt (Order.succ a) (Ordinal.type r)\nx : α\n⊢ Exists fun y => r x y","decl":"theorem has_succ_of_type_succ_lt {α} {r : α → α → Prop} [wo : IsWellOrder α r]\n    (h : ∀ a < type r, succ a < type r) (x : α) : ∃ y, r x y := by\n  use enum r ⟨succ (typein r x), h _ (typein_lt_type r x)⟩\n  convert enum_lt_enum.mpr _\n  · rw [enum_typein]\n  · rw [Subtype.mk_lt_mk, lt_succ_iff]\n\n"}
{"name":"Ordinal.toType_noMax_of_succ_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nho : ∀ (a : Ordinal.{u_4}), LT.lt a o → LT.lt (Order.succ a) o\n⊢ NoMaxOrder o.toType","decl":"theorem toType_noMax_of_succ_lt {o : Ordinal} (ho : ∀ a < o, succ a < o) : NoMaxOrder o.toType :=\n  ⟨has_succ_of_type_succ_lt (type_toType _ ▸ ho)⟩\n\n"}
{"name":"Ordinal.out_no_max_of_succ_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nho : ∀ (a : Ordinal.{u_4}), LT.lt a o → LT.lt (Order.succ a) o\n⊢ NoMaxOrder o.toType","decl":"@[deprecated toType_noMax_of_succ_lt (since := \"2024-08-26\")]\nalias out_no_max_of_succ_lt := toType_noMax_of_succ_lt\n\n"}
{"name":"Ordinal.bounded_singleton","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nhr : (Ordinal.type r).IsLimit\nx : α\n⊢ Set.Bounded r (Singleton.singleton x)","decl":"theorem bounded_singleton {r : α → α → Prop} [IsWellOrder α r] (hr : (type r).IsLimit) (x) :\n    Bounded r {x} := by\n  refine ⟨enum r ⟨succ (typein r x), hr.succ_lt (typein_lt_type r x)⟩, ?_⟩\n  intro b hb\n  rw [mem_singleton_iff.1 hb]\n  nth_rw 1 [← enum_typein r x]\n  rw [@enum_lt_enum _ r, Subtype.mk_lt_mk]\n  apply lt_succ\n\n"}
{"name":"Ordinal.typein_ordinal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq ((Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding o) (Ordinal.lift.{u + 1, u} o)","decl":"@[simp]\ntheorem typein_ordinal (o : Ordinal.{u}) :\n    @typein Ordinal (· < ·) _ o = Ordinal.lift.{u + 1} o := by\n  refine Quotient.inductionOn o ?_\n  rintro ⟨α, r, wo⟩; apply Quotient.sound\n  constructor; refine ((RelIso.preimage Equiv.ulift r).trans (enum r).symm).symm\n\n"}
{"name":"Ordinal.mk_Iio_ordinal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Cardinal.mk ↑(Set.Iio o)) (Cardinal.lift.{u + 1, u} o.card)","decl":"theorem mk_Iio_ordinal (o : Ordinal.{u}) :\n    #(Iio o) = Cardinal.lift.{u + 1} o.card := by\n  rw [lift_card, ← typein_ordinal]\n  rfl\n\n"}
{"name":"Ordinal.mk_initialSeg","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Cardinal.mk ↑(setOf fun o' => LT.lt o' o)) (Cardinal.lift.{u + 1, u} o.card)","decl":"@[deprecated mk_Iio_ordinal (since := \"2024-09-19\")]\ntheorem mk_initialSeg (o : Ordinal.{u}) :\n    #{ o' : Ordinal | o' < o } = Cardinal.lift.{u + 1} o.card := mk_Iio_ordinal o\n\n\n"}
{"name":"Ordinal.IsNormal.limit_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\no : Ordinal.{u_4}\na✝ : o.IsLimit\na : Ordinal.{u_5}\n⊢ Iff (LE.le (f o) a) (∀ (b : Ordinal.{u_4}), LT.lt b o → LE.le (f b) a)","decl":"theorem IsNormal.limit_le {f} (H : IsNormal f) :\n    ∀ {o}, IsLimit o → ∀ {a}, f o ≤ a ↔ ∀ b < o, f b ≤ a :=\n  @H.2\n\n"}
{"name":"Ordinal.IsNormal.limit_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\no : Ordinal.{u_4}\nh : o.IsLimit\na : Ordinal.{u_5}\n⊢ Iff (LT.lt a (f o)) (Exists fun b => And (LT.lt b o) (LT.lt a (f b)))","decl":"theorem IsNormal.limit_lt {f} (H : IsNormal f) {o} (h : IsLimit o) {a} :\n    a < f o ↔ ∃ b < o, a < f b :=\n  not_iff_not.1 <| by simpa only [exists_prop, not_exists, not_and, not_lt] using H.2 _ h a\n\n"}
{"name":"Ordinal.IsNormal.strictMono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\n⊢ StrictMono f","decl":"theorem IsNormal.strictMono {f} (H : IsNormal f) : StrictMono f := fun a b =>\n  limitRecOn b (Not.elim (not_lt_of_le <| Ordinal.zero_le _))\n    (fun _b IH h =>\n      (lt_or_eq_of_le (le_of_lt_succ h)).elim (fun h => (IH h).trans (H.1 _)) fun e => e ▸ H.1 _)\n    fun _b l _IH h => lt_of_lt_of_le (H.1 a) ((H.2 _ l _).1 le_rfl _ (l.succ_lt h))\n\n"}
{"name":"Ordinal.IsNormal.monotone","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\n⊢ Monotone f","decl":"theorem IsNormal.monotone {f} (H : IsNormal f) : Monotone f :=\n  H.strictMono.monotone\n\n"}
{"name":"Ordinal.isNormal_iff_strictMono_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\n⊢ Iff (Ordinal.IsNormal f) (And (StrictMono f) (∀ (o : Ordinal.{u_4}), o.IsLimit → ∀ (a : Ordinal.{u_5}), (∀ (b : Ordinal.{u_4}), LT.lt b o → LE.le (f b) a) → LE.le (f o) a))","decl":"theorem isNormal_iff_strictMono_limit (f : Ordinal → Ordinal) :\n    IsNormal f ↔ StrictMono f ∧ ∀ o, IsLimit o → ∀ a, (∀ b < o, f b ≤ a) → f o ≤ a :=\n  ⟨fun hf => ⟨hf.strictMono, fun a ha c => (hf.2 a ha c).2⟩, fun ⟨hs, hl⟩ =>\n    ⟨fun a => hs (lt_succ a), fun a ha c =>\n      ⟨fun hac _b hba => ((hs hba).trans_le hac).le, hl a ha c⟩⟩⟩\n\n"}
{"name":"Ordinal.IsNormal.lt_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_4}\n⊢ Iff (LT.lt (f a) (f b)) (LT.lt a b)","decl":"theorem IsNormal.lt_iff {f} (H : IsNormal f) {a b} : f a < f b ↔ a < b :=\n  StrictMono.lt_iff_lt <| H.strictMono\n\n"}
{"name":"Ordinal.IsNormal.le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_4}\n⊢ Iff (LE.le (f a) (f b)) (LE.le a b)","decl":"theorem IsNormal.le_iff {f} (H : IsNormal f) {a b} : f a ≤ f b ↔ a ≤ b :=\n  le_iff_le_iff_lt_iff_lt.2 H.lt_iff\n\n"}
{"name":"Ordinal.IsNormal.inj","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\na b : Ordinal.{u_4}\n⊢ Iff (Eq (f a) (f b)) (Eq a b)","decl":"theorem IsNormal.inj {f} (H : IsNormal f) {a b} : f a = f b ↔ a = b := by\n  simp only [le_antisymm_iff, H.le_iff]\n\n"}
{"name":"Ordinal.IsNormal.id_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_4}\nH : Ordinal.IsNormal f\n⊢ LE.le id f","decl":"theorem IsNormal.id_le {f} (H : IsNormal f) : id ≤ f :=\n  H.strictMono.id_le\n\n"}
{"name":"Ordinal.IsNormal.le_apply","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_4}\nH : Ordinal.IsNormal f\na : Ordinal.{u_4}\n⊢ LE.le a (f a)","decl":"theorem IsNormal.le_apply {f} (H : IsNormal f) {a} : a ≤ f a :=\n  H.strictMono.le_apply\n\n"}
{"name":"Ordinal.IsNormal.self_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_4}\nH : Ordinal.IsNormal f\na : Ordinal.{u_4}\n⊢ LE.le a (f a)","decl":"@[deprecated IsNormal.le_apply (since := \"2024-09-11\")]\ntheorem IsNormal.self_le {f} (H : IsNormal f) (a) : a ≤ f a :=\n  H.strictMono.le_apply\n\n"}
{"name":"Ordinal.IsNormal.le_iff_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_4}\nH : Ordinal.IsNormal f\na : Ordinal.{u_4}\n⊢ Iff (LE.le (f a) a) (Eq (f a) a)","decl":"theorem IsNormal.le_iff_eq {f} (H : IsNormal f) {a} : f a ≤ a ↔ f a = a :=\n  H.le_apply.le_iff_eq\n\n"}
{"name":"Ordinal.IsNormal.le_set","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\no : Ordinal.{u_5}\nH : Ordinal.IsNormal f\np : Set Ordinal.{u_4}\np0 : p.Nonempty\nb : Ordinal.{u_4}\nH₂ : ∀ (o : Ordinal.{u_4}), Iff (LE.le b o) (∀ (a : Ordinal.{u_4}), Membership.mem p a → LE.le a o)\n⊢ Iff (LE.le (f b) o) (∀ (a : Ordinal.{u_4}), Membership.mem p a → LE.le (f a) o)","decl":"theorem IsNormal.le_set {f o} (H : IsNormal f) (p : Set Ordinal) (p0 : p.Nonempty) (b)\n    (H₂ : ∀ o, b ≤ o ↔ ∀ a ∈ p, a ≤ o) : f b ≤ o ↔ ∀ a ∈ p, f a ≤ o :=\n  ⟨fun h _ pa => (H.le_iff.2 ((H₂ _).1 le_rfl _ pa)).trans h, fun h => by\n    -- Porting note: `refine'` didn't work well so `induction` is used\n    induction b using limitRecOn with\n    | H₁ =>\n      cases' p0 with x px\n      have := Ordinal.le_zero.1 ((H₂ _).1 (Ordinal.zero_le _) _ px)\n      rw [this] at px\n      exact h _ px\n    | H₂ S _ =>\n      rcases not_forall₂.1 (mt (H₂ S).2 <| (lt_succ S).not_le) with ⟨a, h₁, h₂⟩\n      exact (H.le_iff.2 <| succ_le_of_lt <| not_le.1 h₂).trans (h _ h₁)\n    | H₃ S L _ =>\n      refine (H.2 _ L _).2 fun a h' => ?_\n      rcases not_forall₂.1 (mt (H₂ a).2 h'.not_le) with ⟨b, h₁, h₂⟩\n      exact (H.le_iff.2 <| (not_le.1 h₂).le).trans (h _ h₁)⟩\n\n"}
{"name":"Ordinal.IsNormal.le_set'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nf : Ordinal.{u_4} → Ordinal.{u_5}\no : Ordinal.{u_5}\nH : Ordinal.IsNormal f\np : Set α\np0 : p.Nonempty\ng : α → Ordinal.{u_4}\nb : Ordinal.{u_4}\nH₂ : ∀ (o : Ordinal.{u_4}), Iff (LE.le b o) (∀ (a : α), Membership.mem p a → LE.le (g a) o)\n⊢ Iff (LE.le (f b) o) (∀ (a : α), Membership.mem p a → LE.le (f (g a)) o)","decl":"theorem IsNormal.le_set' {f o} (H : IsNormal f) (p : Set α) (p0 : p.Nonempty) (g : α → Ordinal) (b)\n    (H₂ : ∀ o, b ≤ o ↔ ∀ a ∈ p, g a ≤ o) : f b ≤ o ↔ ∀ a ∈ p, f (g a) ≤ o := by\n  simpa [H₂] using H.le_set (g '' p) (p0.image g) b\n\n"}
{"name":"Ordinal.IsNormal.refl","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ordinal.IsNormal id","decl":"theorem IsNormal.refl : IsNormal id :=\n  ⟨lt_succ, fun _o l _a => Ordinal.limit_le l⟩\n\n"}
{"name":"Ordinal.IsNormal.trans","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\ng : Ordinal.{u_6} → Ordinal.{u_4}\nH₁ : Ordinal.IsNormal f\nH₂ : Ordinal.IsNormal g\n⊢ Ordinal.IsNormal (Function.comp f g)","decl":"theorem IsNormal.trans {f g} (H₁ : IsNormal f) (H₂ : IsNormal g) : IsNormal (f ∘ g) :=\n  ⟨fun _x => H₁.lt_iff.2 (H₂.1 _), fun o l _a =>\n    H₁.le_set' (· < o) ⟨0, l.pos⟩ g _ fun _c => H₂.2 _ l _⟩\n\n"}
{"name":"Ordinal.IsNormal.isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u_4} → Ordinal.{u_5}\nH : Ordinal.IsNormal f\no : Ordinal.{u_4}\nho : o.IsLimit\n⊢ (f o).IsLimit","decl":"theorem IsNormal.isLimit {f} (H : IsNormal f) {o} (ho : IsLimit o) : IsLimit (f o) := by\n  rw [isLimit_iff, isSuccPrelimit_iff_succ_lt]\n  use (H.lt_iff.2 ho.pos).ne_bot\n  intro a ha\n  obtain ⟨b, hb, hab⟩ := (H.limit_lt ho).1 ha\n  rw [← succ_le_iff] at hab\n  apply hab.trans_lt\n  rwa [H.lt_iff]\n\n"}
{"name":"Ordinal.isNormal_add_right","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Ordinal.IsNormal fun x => HAdd.hAdd a x","decl":"theorem isNormal_add_right (a : Ordinal) : IsNormal (a + ·) :=\n  ⟨fun b => (add_lt_add_iff_left a).2 (lt_succ b), fun _b l _c => add_le_of_limit l⟩\n\n"}
{"name":"Ordinal.add_isNormal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Ordinal.IsNormal fun x => HAdd.hAdd a x","decl":"@[deprecated isNormal_add_right (since := \"2024-10-11\")]\nalias add_isNormal := isNormal_add_right\n\n"}
{"name":"Ordinal.isLimit_add","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝ : b.IsLimit\n⊢ (HAdd.hAdd a b).IsLimit","decl":"theorem isLimit_add (a) {b} : IsLimit b → IsLimit (a + b) :=\n  (isNormal_add_right a).isLimit\n\n"}
{"name":"Ordinal.add_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝ : b.IsLimit\n⊢ (HAdd.hAdd a b).IsLimit","decl":"@[deprecated isLimit_add (since := \"2024-10-11\")]\nalias add_isLimit := isLimit_add\n\n"}
{"name":"Ordinal.IsLimit.add","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝ : b.IsLimit\n⊢ (HAdd.hAdd a b).IsLimit","decl":"alias IsLimit.add := add_isLimit\n\n"}
{"name":"Ordinal.le_add_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ LE.le a (HAdd.hAdd b (HSub.hSub a b))","decl":"theorem le_add_sub (a b : Ordinal) : a ≤ b + (a - b) :=\n  csInf_mem sub_nonempty\n\n"}
{"name":"Ordinal.sub_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Iff (LE.le (HSub.hSub a b) c) (LE.le a (HAdd.hAdd b c))","decl":"theorem sub_le {a b c : Ordinal} : a - b ≤ c ↔ a ≤ b + c :=\n  ⟨fun h => (le_add_sub a b).trans (add_le_add_left h _), fun h => csInf_le' h⟩\n\n"}
{"name":"Ordinal.lt_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Iff (LT.lt a (HSub.hSub b c)) (LT.lt (HAdd.hAdd c a) b)","decl":"theorem lt_sub {a b c : Ordinal} : a < b - c ↔ c + a < b :=\n  lt_iff_lt_of_le_iff_le sub_le\n\n"}
{"name":"Ordinal.add_sub_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) a) b","decl":"theorem add_sub_cancel (a b : Ordinal) : a + b - a = b :=\n  le_antisymm (sub_le.2 <| le_rfl) ((add_le_add_iff_left a).1 <| le_add_sub _ _)\n\n"}
{"name":"Ordinal.sub_eq_of_add_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : Eq (HAdd.hAdd a b) c\n⊢ Eq (HSub.hSub c a) b","decl":"theorem sub_eq_of_add_eq {a b c : Ordinal} (h : a + b = c) : c - a = b :=\n  h ▸ add_sub_cancel _ _\n\n"}
{"name":"Ordinal.sub_le_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ LE.le (HSub.hSub a b) a","decl":"theorem sub_le_self (a b : Ordinal) : a - b ≤ a :=\n  sub_le.2 <| le_add_left _ _\n\n"}
{"name":"Ordinal.add_sub_cancel_of_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : LE.le b a\n⊢ Eq (HAdd.hAdd b (HSub.hSub a b)) a","decl":"protected theorem add_sub_cancel_of_le {a b : Ordinal} (h : b ≤ a) : b + (a - b) = a :=\n  (le_add_sub a b).antisymm'\n    (by\n      rcases zero_or_succ_or_limit (a - b) with (e | ⟨c, e⟩ | l)\n      · simp only [e, add_zero, h]\n      · rw [e, add_succ, succ_le_iff, ← lt_sub, e]\n        exact lt_succ c\n      · exact (add_le_of_limit l).2 fun c l => (lt_sub.1 l).le)\n\n"}
{"name":"Ordinal.le_sub_of_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LE.le b a\n⊢ Iff (LE.le c (HSub.hSub a b)) (LE.le (HAdd.hAdd b c) a)","decl":"theorem le_sub_of_le {a b c : Ordinal} (h : b ≤ a) : c ≤ a - b ↔ b + c ≤ a := by\n  rw [← add_le_add_iff_left b, Ordinal.add_sub_cancel_of_le h]\n\n"}
{"name":"Ordinal.sub_lt_of_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LE.le b a\n⊢ Iff (LT.lt (HSub.hSub a b) c) (LT.lt a (HAdd.hAdd b c))","decl":"theorem sub_lt_of_le {a b c : Ordinal} (h : b ≤ a) : a - b < c ↔ a < b + c :=\n  lt_iff_lt_of_le_iff_le (le_sub_of_le h)\n\n"}
{"name":"Ordinal.existsAddOfLE","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ ExistsAddOfLE Ordinal.{u_4}","decl":"instance existsAddOfLE : ExistsAddOfLE Ordinal :=\n  ⟨fun h => ⟨_, (Ordinal.add_sub_cancel_of_le h).symm⟩⟩\n\n"}
{"name":"Ordinal.sub_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HSub.hSub a 0) a","decl":"@[simp]\ntheorem sub_zero (a : Ordinal) : a - 0 = a := by simpa only [zero_add] using add_sub_cancel 0 a\n\n"}
{"name":"Ordinal.zero_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HSub.hSub 0 a) 0","decl":"@[simp]\ntheorem zero_sub (a : Ordinal) : 0 - a = 0 := by rw [← Ordinal.le_zero]; apply sub_le_self\n\n"}
{"name":"Ordinal.sub_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HSub.hSub a a) 0","decl":"@[simp]\ntheorem sub_self (a : Ordinal) : a - a = 0 := by simpa only [add_zero] using add_sub_cancel a 0\n\n"}
{"name":"Ordinal.sub_eq_zero_iff_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (Eq (HSub.hSub a b) 0) (LE.le a b)","decl":"protected theorem sub_eq_zero_iff_le {a b : Ordinal} : a - b = 0 ↔ a ≤ b :=\n  ⟨fun h => by simpa only [h, add_zero] using le_add_sub a b, fun h => by\n    rwa [← Ordinal.le_zero, sub_le, add_zero]⟩\n\n"}
{"name":"Ordinal.sub_ne_zero_iff_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (Ne (HSub.hSub a b) 0) (LT.lt b a)","decl":"protected theorem sub_ne_zero_iff_lt {a b : Ordinal} : a - b ≠ 0 ↔ b < a := by\n  simpa using Ordinal.sub_eq_zero_iff_le.not\n\n"}
{"name":"Ordinal.sub_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Eq (HSub.hSub (HSub.hSub a b) c) (HSub.hSub a (HAdd.hAdd b c))","decl":"theorem sub_sub (a b c : Ordinal) : a - b - c = a - (b + c) :=\n  eq_of_forall_ge_iff fun d => by rw [sub_le, sub_le, sub_le, add_assoc]\n\n"}
{"name":"Ordinal.add_sub_add_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) (HAdd.hAdd a c)) (HSub.hSub b c)","decl":"@[simp]\ntheorem add_sub_add_cancel (a b c : Ordinal) : a + b - (a + c) = b - c := by\n  rw [← sub_sub, add_sub_cancel]\n\n"}
{"name":"Ordinal.le_sub_of_add_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LE.le (HAdd.hAdd b c) a\n⊢ LE.le c (HSub.hSub a b)","decl":"theorem le_sub_of_add_le {a b c : Ordinal} (h : b + c ≤ a) : c ≤ a - b := by\n  rw [← add_le_add_iff_left b]\n  exact h.trans (le_add_sub a b)\n\n"}
{"name":"Ordinal.sub_lt_of_lt_add","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LT.lt a (HAdd.hAdd b c)\nhc : LT.lt 0 c\n⊢ LT.lt (HSub.hSub a b) c","decl":"theorem sub_lt_of_lt_add {a b c : Ordinal} (h : a < b + c) (hc : 0 < c) : a - b < c := by\n  obtain hab | hba := lt_or_le a b\n  · rwa [Ordinal.sub_eq_zero_iff_le.2 hab.le]\n  · rwa [sub_lt_of_le hba]\n\n"}
{"name":"Ordinal.lt_add_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nhc : Ne c 0\n⊢ Iff (LT.lt a (HAdd.hAdd b c)) (Exists fun d => And (LT.lt d c) (LE.le a (HAdd.hAdd b d)))","decl":"theorem lt_add_iff {a b c : Ordinal} (hc : c ≠ 0) : a < b + c ↔ ∃ d < c, a ≤ b + d := by\n  use fun h ↦ ⟨_, sub_lt_of_lt_add h hc.bot_lt, le_add_sub a b⟩\n  rintro ⟨d, hd, ha⟩\n  exact ha.trans_lt (add_lt_add_left hd b)\n\n"}
{"name":"Ordinal.add_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nhb : Ne b 0\n⊢ Iff (LE.le (HAdd.hAdd a b) c) (∀ (d : Ordinal.{u_4}), LT.lt d b → LT.lt (HAdd.hAdd a d) c)","decl":"theorem add_le_iff {a b c : Ordinal} (hb : b ≠ 0) : a + b ≤ c ↔ ∀ d < b, a + d < c := by\n  simpa using (lt_add_iff hb).not\n\n"}
{"name":"Ordinal.add_le_of_forall_add_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nhb : LT.lt 0 b\nh : ∀ (d : Ordinal.{u_4}), LT.lt d b → LT.lt (HAdd.hAdd a d) c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"@[deprecated add_le_iff (since := \"2024-12-08\")]\ntheorem add_le_of_forall_add_lt {a b c : Ordinal} (hb : 0 < b) (h : ∀ d < b, a + d < c) :\n    a + b ≤ c :=\n  (add_le_iff hb.ne').2 h\n\n"}
{"name":"Ordinal.isLimit_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nha : a.IsLimit\nh : LT.lt b a\n⊢ (HSub.hSub a b).IsLimit","decl":"theorem isLimit_sub {a b} (ha : IsLimit a) (h : b < a) : IsLimit (a - b) := by\n  rw [isLimit_iff, Ordinal.sub_ne_zero_iff_lt, isSuccPrelimit_iff_succ_lt]\n  refine ⟨h, fun c hc ↦ ?_⟩\n  rw [lt_sub] at hc ⊢\n  rw [add_succ]\n  exact ha.succ_lt hc\n\n"}
{"name":"Ordinal.sub_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nha : a.IsLimit\nh : LT.lt b a\n⊢ (HSub.hSub a b).IsLimit","decl":"@[deprecated isLimit_sub (since := \"2024-10-11\")]\nalias sub_isLimit := isLimit_sub\n\n"}
{"name":"Ordinal.type_prod_lex","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α β : Type u\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ Eq (Ordinal.type (Prod.Lex s r)) (HMul.hMul (Ordinal.type r) (Ordinal.type s))","decl":"@[simp]\ntheorem type_prod_lex {α β : Type u} (r : α → α → Prop) (s : β → β → Prop) [IsWellOrder α r]\n    [IsWellOrder β s] : type (Prod.Lex s r) = type r * type s :=\n  rfl\n\n"}
{"name":"Ordinal.noZeroDivisors","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ NoZeroDivisors Ordinal.{u_4}","decl":"instance noZeroDivisors : NoZeroDivisors Ordinal :=\n  ⟨fun {_ _} => mul_eq_zero'.1⟩\n\n"}
{"name":"Ordinal.lift_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{v}\n⊢ Eq (Ordinal.lift.{u, v} (HMul.hMul a b)) (HMul.hMul (Ordinal.lift.{u, v} a) (Ordinal.lift.{u, v} b))","decl":"@[simp]\ntheorem lift_mul (a b : Ordinal.{v}) : lift.{u} (a * b) = lift.{u} a * lift.{u} b :=\n  Quotient.inductionOn₂ a b fun ⟨_α, _r, _⟩ ⟨_β, _s, _⟩ =>\n    Quotient.sound\n      ⟨(RelIso.preimage Equiv.ulift _).trans\n          (RelIso.prodLexCongr (RelIso.preimage Equiv.ulift _)\n              (RelIso.preimage Equiv.ulift _)).symm⟩\n\n"}
{"name":"Ordinal.card_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HMul.hMul a b).card (HMul.hMul a.card b.card)","decl":"@[simp]\ntheorem card_mul (a b) : card (a * b) = card a * card b :=\n  Quotient.inductionOn₂ a b fun ⟨α, _r, _⟩ ⟨β, _s, _⟩ => mul_comm #β #α\n\n"}
{"name":"Ordinal.leftDistribClass","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ LeftDistribClass Ordinal.{u}","decl":"instance leftDistribClass : LeftDistribClass Ordinal.{u} :=\n  ⟨fun a b c =>\n    Quotient.inductionOn₃ a b c fun ⟨α, r, _⟩ ⟨β, s, _⟩ ⟨γ, t, _⟩ =>\n      Quotient.sound\n        ⟨⟨sumProdDistrib _ _ _, by\n          rintro ⟨a₁ | a₁, a₂⟩ ⟨b₁ | b₁, b₂⟩ <;>\n            simp only [Prod.lex_def, Sum.lex_inl_inl, Sum.Lex.sep, Sum.lex_inr_inl, Sum.lex_inr_inr,\n              sumProdDistrib_apply_left, sumProdDistrib_apply_right, reduceCtorEq] <;>\n            -- Porting note: `Sum.inr.inj_iff` is required.\n            simp only [Sum.inl.inj_iff, Sum.inr.inj_iff, true_or, false_and, false_or]⟩⟩⟩\n\n"}
{"name":"Ordinal.mul_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HMul.hMul a (Order.succ b)) (HAdd.hAdd (HMul.hMul a b) a)","decl":"theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a :=\n  mul_add_one a b\n\n"}
{"name":"Ordinal.mulLeftMono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ MulLeftMono Ordinal.{u}","decl":"instance mulLeftMono : MulLeftMono Ordinal.{u} :=\n  ⟨fun c a b =>\n    Quotient.inductionOn₃ a b c fun ⟨α, r, _⟩ ⟨β, s, _⟩ ⟨γ, t, _⟩ ⟨f⟩ => by\n      refine\n        (RelEmbedding.ofMonotone (fun a : α × γ => (f a.1, a.2)) fun a b h => ?_).ordinal_type_le\n      cases' h with a₁ b₁ a₂ b₂ h' a b₁ b₂ h'\n      · exact Prod.Lex.left _ _ (f.toRelEmbedding.map_rel_iff.2 h')\n      · exact Prod.Lex.right _ h'⟩\n\n"}
{"name":"Ordinal.mulRightMono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ MulRightMono Ordinal.{u}","decl":"instance mulRightMono : MulRightMono Ordinal.{u} :=\n  ⟨fun c a b =>\n    Quotient.inductionOn₃ a b c fun ⟨α, r, _⟩ ⟨β, s, _⟩ ⟨γ, t, _⟩ ⟨f⟩ => by\n      refine\n        (RelEmbedding.ofMonotone (fun a : γ × α => (a.1, f a.2)) fun a b h => ?_).ordinal_type_le\n      cases' h with a₁ b₁ a₂ b₂ h' a b₁ b₂ h'\n      · exact Prod.Lex.left _ _ h'\n      · exact Prod.Lex.right _ (f.toRelEmbedding.map_rel_iff.2 h')⟩\n\n"}
{"name":"Ordinal.le_mul_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nhb : LT.lt 0 b\n⊢ LE.le a (HMul.hMul a b)","decl":"theorem le_mul_left (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a ≤ a * b := by\n  convert mul_le_mul_left' (one_le_iff_pos.2 hb) a\n  rw [mul_one a]\n\n"}
{"name":"Ordinal.le_mul_right","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nhb : LT.lt 0 b\n⊢ LE.le a (HMul.hMul b a)","decl":"theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a ≤ b * a := by\n  convert mul_le_mul_right' (one_le_iff_pos.2 hb) a\n  rw [one_mul a]\n\n"}
{"name":"Ordinal.mul_le_of_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : b.IsLimit\n⊢ Iff (LE.le (HMul.hMul a b) c) (∀ (b' : Ordinal.{u_4}), LT.lt b' b → LE.le (HMul.hMul a b') c)","decl":"theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b ≤ c ↔ ∀ b' < b, a * b' ≤ c :=\n  ⟨fun h _ l => (mul_le_mul_left' l.le _).trans h, fun H =>\n    -- Porting note: `induction` tactics are required because of the parser bug.\n    le_of_not_lt <| by\n      induction a using inductionOn with\n      | H α r =>\n        induction b using inductionOn with\n        | H β s =>\n          exact mul_le_of_limit_aux h H⟩\n\n"}
{"name":"Ordinal.isNormal_mul_right","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\nh : LT.lt 0 a\n⊢ Ordinal.IsNormal fun x => HMul.hMul a x","decl":"theorem isNormal_mul_right {a : Ordinal} (h : 0 < a) : IsNormal (a * ·) :=\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed\n  ⟨fun b => by\n      beta_reduce\n      rw [mul_succ]\n      simpa only [add_zero] using (add_lt_add_iff_left (a * b)).2 h,\n    fun _ l _ => mul_le_of_limit l⟩\n\n"}
{"name":"Ordinal.mul_isNormal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\nh : LT.lt 0 a\n⊢ Ordinal.IsNormal fun x => HMul.hMul a x","decl":"@[deprecated isNormal_mul_right (since := \"2024-10-11\")]\nalias mul_isNormal := isNormal_mul_right\n\n"}
{"name":"Ordinal.lt_mul_of_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : c.IsLimit\n⊢ Iff (LT.lt a (HMul.hMul b c)) (Exists fun c' => And (LT.lt c' c) (LT.lt a (HMul.hMul b c')))","decl":"theorem lt_mul_of_limit {a b c : Ordinal} (h : IsLimit c) : a < b * c ↔ ∃ c' < c, a < b * c' := by\n  -- Porting note: `bex_def` is required.\n  simpa only [not_forall₂, not_le, bex_def] using not_congr (@mul_le_of_limit b c a h)\n\n"}
{"name":"Ordinal.mul_lt_mul_iff_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\na0 : LT.lt 0 a\n⊢ Iff (LT.lt (HMul.hMul a b) (HMul.hMul a c)) (LT.lt b c)","decl":"theorem mul_lt_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b < a * c ↔ b < c :=\n  (isNormal_mul_right a0).lt_iff\n\n"}
{"name":"Ordinal.mul_le_mul_iff_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\na0 : LT.lt 0 a\n⊢ Iff (LE.le (HMul.hMul a b) (HMul.hMul a c)) (LE.le b c)","decl":"theorem mul_le_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b ≤ a * c ↔ b ≤ c :=\n  (isNormal_mul_right a0).le_iff\n\n"}
{"name":"Ordinal.mul_lt_mul_of_pos_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LT.lt a b\nc0 : LT.lt 0 c\n⊢ LT.lt (HMul.hMul c a) (HMul.hMul c b)","decl":"theorem mul_lt_mul_of_pos_left {a b c : Ordinal} (h : a < b) (c0 : 0 < c) : c * a < c * b :=\n  (mul_lt_mul_iff_left c0).2 h\n\n"}
{"name":"Ordinal.mul_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh₁ : LT.lt 0 a\nh₂ : LT.lt 0 b\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"theorem mul_pos {a b : Ordinal} (h₁ : 0 < a) (h₂ : 0 < b) : 0 < a * b := by\n  simpa only [mul_zero] using mul_lt_mul_of_pos_left h₂ h₁\n\n"}
{"name":"Ordinal.mul_ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝¹ : Ne a 0\na✝ : Ne b 0\n⊢ Ne (HMul.hMul a b) 0","decl":"theorem mul_ne_zero {a b : Ordinal} : a ≠ 0 → b ≠ 0 → a * b ≠ 0 := by\n  simpa only [Ordinal.pos_iff_ne_zero] using mul_pos\n\n"}
{"name":"Ordinal.le_of_mul_le_mul_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LE.le (HMul.hMul c a) (HMul.hMul c b)\nh0 : LT.lt 0 c\n⊢ LE.le a b","decl":"theorem le_of_mul_le_mul_left {a b c : Ordinal} (h : c * a ≤ c * b) (h0 : 0 < c) : a ≤ b :=\n  le_imp_le_of_lt_imp_lt (fun h' => mul_lt_mul_of_pos_left h' h0) h\n\n"}
{"name":"Ordinal.mul_right_inj","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\na0 : LT.lt 0 a\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"theorem mul_right_inj {a b c : Ordinal} (a0 : 0 < a) : a * b = a * c ↔ b = c :=\n  (isNormal_mul_right a0).inj\n\n"}
{"name":"Ordinal.isLimit_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na0 : LT.lt 0 a\na✝ : b.IsLimit\n⊢ (HMul.hMul a b).IsLimit","decl":"theorem isLimit_mul {a b : Ordinal} (a0 : 0 < a) : IsLimit b → IsLimit (a * b) :=\n  (isNormal_mul_right a0).isLimit\n\n"}
{"name":"Ordinal.mul_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na0 : LT.lt 0 a\na✝ : b.IsLimit\n⊢ (HMul.hMul a b).IsLimit","decl":"@[deprecated isLimit_mul (since := \"2024-10-11\")]\nalias mul_isLimit := isLimit_mul\n\n"}
{"name":"Ordinal.isLimit_mul_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nl : a.IsLimit\nb0 : LT.lt 0 b\n⊢ (HMul.hMul a b).IsLimit","decl":"theorem isLimit_mul_left {a b : Ordinal} (l : IsLimit a) (b0 : 0 < b) : IsLimit (a * b) := by\n  rcases zero_or_succ_or_limit b with (rfl | ⟨b, rfl⟩ | lb)\n  · exact b0.false.elim\n  · rw [mul_succ]\n    exact isLimit_add _ l\n  · exact isLimit_mul l.pos lb\n\n"}
{"name":"Ordinal.mul_isLimit_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nl : a.IsLimit\nb0 : LT.lt 0 b\n⊢ (HMul.hMul a b).IsLimit","decl":"@[deprecated isLimit_mul_left (since := \"2024-10-11\")]\nalias mul_isLimit_left := isLimit_mul_left\n\n"}
{"name":"Ordinal.smul_eq_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\na : Ordinal.{u_4}\n⊢ Eq (HSMul.hSMul n a) (HMul.hMul a ↑n)","decl":"theorem smul_eq_mul : ∀ (n : ℕ) (a : Ordinal), n • a = a * n\n  | 0, a => by rw [zero_nsmul, Nat.cast_zero, mul_zero]\n  | n + 1, a => by rw [succ_nsmul, Nat.cast_add, mul_add, Nat.cast_one, mul_one, smul_eq_mul n]\n\n"}
{"name":"Ordinal.add_mul_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nba : Eq (HAdd.hAdd b a) a\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) (Order.succ c)) (HAdd.hAdd (HMul.hMul a (Order.succ c)) b)","decl":"theorem add_mul_succ {a b : Ordinal} (c) (ba : b + a = a) : (a + b) * succ c = a * succ c + b := by\n  induction c using limitRecOn with\n  | H₁ => simp only [succ_zero, mul_one]\n  | H₂ c IH =>\n    rw [mul_succ, IH, ← add_assoc, add_assoc _ b, ba, ← mul_succ]\n  | H₃ c l IH =>\n    rw [mul_succ, add_mul_limit_aux ba l IH, mul_succ, add_assoc]\n\n"}
{"name":"Ordinal.add_mul_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nba : Eq (HAdd.hAdd b a) a\nl : c.IsLimit\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HMul.hMul a c)","decl":"theorem add_mul_limit {a b c : Ordinal} (ba : b + a = a) (l : IsLimit c) : (a + b) * c = a * c :=\n  add_mul_limit_aux ba l fun c' _ => add_mul_succ c' ba\n\n"}
{"name":"Ordinal.div_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv a 0) 0","decl":"@[simp]\ntheorem div_zero (a : Ordinal) : a / 0 = 0 :=\n  dif_pos rfl\n\n"}
{"name":"Ordinal.lt_mul_succ_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : Ne b 0\n⊢ LT.lt a (HMul.hMul b (Order.succ (HDiv.hDiv a b)))","decl":"theorem lt_mul_succ_div (a) {b : Ordinal} (h : b ≠ 0) : a < b * succ (a / b) := by\n  rw [div_def a h]; exact csInf_mem (div_nonempty h)\n\n"}
{"name":"Ordinal.lt_mul_div_add","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : Ne b 0\n⊢ LT.lt a (HAdd.hAdd (HMul.hMul b (HDiv.hDiv a b)) b)","decl":"theorem lt_mul_div_add (a) {b : Ordinal} (h : b ≠ 0) : a < b * (a / b) + b := by\n  simpa only [mul_succ] using lt_mul_succ_div a h\n\n"}
{"name":"Ordinal.div_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nb0 : Ne b 0\n⊢ Iff (LE.le (HDiv.hDiv a b) c) (LT.lt a (HMul.hMul b (Order.succ c)))","decl":"theorem div_le {a b c : Ordinal} (b0 : b ≠ 0) : a / b ≤ c ↔ a < b * succ c :=\n  ⟨fun h => (lt_mul_succ_div a b0).trans_le (mul_le_mul_left' (succ_le_succ_iff.2 h) _), fun h => by\n    rw [div_def a b0]; exact csInf_le' h⟩\n\n"}
{"name":"Ordinal.lt_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : Ne c 0\n⊢ Iff (LT.lt a (HDiv.hDiv b c)) (LE.le (HMul.hMul c (Order.succ a)) b)","decl":"theorem lt_div {a b c : Ordinal} (h : c ≠ 0) : a < b / c ↔ c * succ a ≤ b := by\n  rw [← not_le, div_le h, not_lt]\n\n"}
{"name":"Ordinal.div_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"b c : Ordinal.{u_4}\nh : Ne c 0\n⊢ Iff (LT.lt 0 (HDiv.hDiv b c)) (LE.le c b)","decl":"theorem div_pos {b c : Ordinal} (h : c ≠ 0) : 0 < b / c ↔ c ≤ b := by simp [lt_div h]\n\n"}
{"name":"Ordinal.le_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nc0 : Ne c 0\n⊢ Iff (LE.le a (HDiv.hDiv b c)) (LE.le (HMul.hMul c a) b)","decl":"theorem le_div {a b c : Ordinal} (c0 : c ≠ 0) : a ≤ b / c ↔ c * a ≤ b := by\n  induction a using limitRecOn with\n  | H₁ => simp only [mul_zero, Ordinal.zero_le]\n  | H₂ _ _ => rw [succ_le_iff, lt_div c0]\n  | H₃ _ h₁ h₂ =>\n    revert h₁ h₂\n    simp +contextual only [mul_le_of_limit, limit_le, forall_true_iff]\n\n"}
{"name":"Ordinal.div_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nb0 : Ne b 0\n⊢ Iff (LT.lt (HDiv.hDiv a b) c) (LT.lt a (HMul.hMul b c))","decl":"theorem div_lt {a b c : Ordinal} (b0 : b ≠ 0) : a / b < c ↔ a < b * c :=\n  lt_iff_lt_of_le_iff_le <| le_div b0\n\n"}
{"name":"Ordinal.div_le_of_le_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : LE.le a (HMul.hMul b c)\n⊢ LE.le (HDiv.hDiv a b) c","decl":"theorem div_le_of_le_mul {a b c : Ordinal} (h : a ≤ b * c) : a / b ≤ c :=\n  if b0 : b = 0 then by simp only [b0, div_zero, Ordinal.zero_le]\n  else\n    (div_le b0).2 <| h.trans_lt <| mul_lt_mul_of_pos_left (lt_succ c) (Ordinal.pos_iff_ne_zero.2 b0)\n\n"}
{"name":"Ordinal.mul_lt_of_lt_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\na✝ : LT.lt a (HDiv.hDiv b c)\n⊢ LT.lt (HMul.hMul c a) b","decl":"theorem mul_lt_of_lt_div {a b c : Ordinal} : a < b / c → c * a < b :=\n  lt_imp_lt_of_le_imp_le div_le_of_le_mul\n\n"}
{"name":"Ordinal.zero_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv 0 a) 0","decl":"@[simp]\ntheorem zero_div (a : Ordinal) : 0 / a = 0 :=\n  Ordinal.le_zero.1 <| div_le_of_le_mul <| Ordinal.zero_le _\n\n"}
{"name":"Ordinal.mul_div_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ LE.le (HMul.hMul b (HDiv.hDiv a b)) a","decl":"theorem mul_div_le (a b : Ordinal) : b * (a / b) ≤ a :=\n  if b0 : b = 0 then by simp only [b0, zero_mul, Ordinal.zero_le] else (le_div b0).1 le_rfl\n\n"}
{"name":"Ordinal.div_le_left","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : LE.le a b\nc : Ordinal.{u_4}\n⊢ LE.le (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"theorem div_le_left {a b : Ordinal} (h : a ≤ b) (c : Ordinal) : a / c ≤ b / c := by\n  obtain rfl | hc := eq_or_ne c 0\n  · rw [div_zero, div_zero]\n  · rw [le_div hc]\n    exact (mul_div_le a c).trans h\n\n"}
{"name":"Ordinal.mul_add_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nb0 : Ne b 0\nc : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv (HAdd.hAdd (HMul.hMul b a) c) b) (HAdd.hAdd a (HDiv.hDiv c b))","decl":"theorem mul_add_div (a) {b : Ordinal} (b0 : b ≠ 0) (c) : (b * a + c) / b = a + c / b := by\n  apply le_antisymm\n  · apply (div_le b0).2\n    rw [mul_succ, mul_add, add_assoc, add_lt_add_iff_left]\n    apply lt_mul_div_add _ b0\n  · rw [le_div b0, mul_add, add_le_add_iff_left]\n    apply mul_div_le\n\n"}
{"name":"Ordinal.div_eq_zero_of_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : LT.lt a b\n⊢ Eq (HDiv.hDiv a b) 0","decl":"theorem div_eq_zero_of_lt {a b : Ordinal} (h : a < b) : a / b = 0 := by\n  rw [← Ordinal.le_zero, div_le <| Ordinal.pos_iff_ne_zero.1 <| (Ordinal.zero_le _).trans_lt h]\n  simpa only [succ_zero, mul_one] using h\n\n"}
{"name":"Ordinal.mul_div_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nb0 : Ne b 0\n⊢ Eq (HDiv.hDiv (HMul.hMul b a) b) a","decl":"@[simp]\ntheorem mul_div_cancel (a) {b : Ordinal} (b0 : b ≠ 0) : b * a / b = a := by\n  simpa only [add_zero, zero_div] using mul_add_div a b0 0\n\n"}
{"name":"Ordinal.mul_add_div_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a c : Ordinal.{u_4}\nhc : LT.lt c a\nb d : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv (HAdd.hAdd (HMul.hMul a b) c) (HMul.hMul a d)) (HDiv.hDiv b d)","decl":"theorem mul_add_div_mul {a c : Ordinal} (hc : c < a) (b d : Ordinal) :\n    (a * b + c) / (a * d) = b / d := by\n  have ha : a ≠ 0 := ((Ordinal.zero_le c).trans_lt hc).ne'\n  obtain rfl | hd := eq_or_ne d 0\n  · rw [mul_zero, div_zero, div_zero]\n  · have H := mul_ne_zero ha hd\n    apply le_antisymm\n    · rw [← lt_succ_iff, div_lt H, mul_assoc]\n      · apply (add_lt_add_left hc _).trans_le\n        rw [← mul_succ]\n        apply mul_le_mul_left'\n        rw [succ_le_iff]\n        exact lt_mul_succ_div b hd\n    · rw [le_div H, mul_assoc]\n      exact (mul_le_mul_left' (mul_div_le b d) a).trans (le_add_right _ c)\n\n"}
{"name":"Ordinal.mul_div_mul_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\nha : Ne a 0\nb c : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv (HMul.hMul a b) (HMul.hMul a c)) (HDiv.hDiv b c)","decl":"theorem mul_div_mul_cancel {a : Ordinal} (ha : a ≠ 0) (b c) : a * b / (a * c) = b / c := by\n  convert mul_add_div_mul (Ordinal.pos_iff_ne_zero.2 ha) b c using 1\n  rw [add_zero]\n\n"}
{"name":"Ordinal.div_one","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HDiv.hDiv a 1) a","decl":"@[simp]\ntheorem div_one (a : Ordinal) : a / 1 = a := by\n  simpa only [one_mul] using mul_div_cancel a Ordinal.one_ne_zero\n\n"}
{"name":"Ordinal.div_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\nh : Ne a 0\n⊢ Eq (HDiv.hDiv a a) 1","decl":"@[simp]\ntheorem div_self {a : Ordinal} (h : a ≠ 0) : a / a = 1 := by\n  simpa only [mul_one] using mul_div_cancel 1 h\n\n"}
{"name":"Ordinal.mul_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_sub (a b c : Ordinal) : a * (b - c) = a * b - a * c :=\n  if a0 : a = 0 then by simp only [a0, zero_mul, sub_self]\n  else\n    eq_of_forall_ge_iff fun d => by rw [sub_le, ← le_div a0, sub_le, ← le_div a0, mul_add_div _ a0]\n\n"}
{"name":"Ordinal.isLimit_add_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (HAdd.hAdd a b).IsLimit (Or b.IsLimit (And (Eq b 0) a.IsLimit))","decl":"theorem isLimit_add_iff {a b} : IsLimit (a + b) ↔ IsLimit b ∨ b = 0 ∧ IsLimit a := by\n  constructor <;> intro h\n  · by_cases h' : b = 0\n    · rw [h', add_zero] at h\n      right\n      exact ⟨h', h⟩\n    left\n    rw [← add_sub_cancel a b]\n    apply isLimit_sub h\n    suffices a + 0 < a + b by simpa only [add_zero] using this\n    rwa [add_lt_add_iff_left, Ordinal.pos_iff_ne_zero]\n  rcases h with (h | ⟨rfl, h⟩)\n  · exact isLimit_add a h\n  · simpa only [add_zero]\n\n"}
{"name":"Ordinal.dvd_add_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\na✝ : Dvd.dvd a b\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b c)) (Dvd.dvd a c)","decl":"theorem dvd_add_iff : ∀ {a b c : Ordinal}, a ∣ b → (a ∣ b + c ↔ a ∣ c)\n  | a, _, c, ⟨b, rfl⟩ =>\n    ⟨fun ⟨d, e⟩ => ⟨d - b, by rw [mul_sub, ← e, add_sub_cancel]⟩, fun ⟨d, e⟩ => by\n      rw [e, ← mul_add]\n      apply dvd_mul_right⟩\n\n"}
{"name":"Ordinal.div_mul_cancel","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝¹ : Ne a 0\na✝ : Dvd.dvd a b\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"theorem div_mul_cancel : ∀ {a b : Ordinal}, a ≠ 0 → a ∣ b → a * (b / a) = b\n  | a, _, a0, ⟨b, rfl⟩ => by rw [mul_div_cancel _ a0]\n\n"}
{"name":"Ordinal.le_of_dvd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\na✝¹ : Ne b 0\na✝ : Dvd.dvd a b\n⊢ LE.le a b","decl":"theorem le_of_dvd : ∀ {a b : Ordinal}, b ≠ 0 → a ∣ b → a ≤ b\n  -- Porting note: `⟨b, rfl⟩ => by` → `⟨b, e⟩ => by subst e`\n  | a, _, b0, ⟨b, e⟩ => by\n    subst e\n    -- Porting note: `Ne` is required.\n    simpa only [mul_one] using\n      mul_le_mul_left'\n        (one_le_iff_ne_zero.2 fun h : b = 0 => by\n          simp only [h, mul_zero, Ne, not_true_eq_false] at b0) a\n\n"}
{"name":"Ordinal.dvd_antisymm","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh₁ : Dvd.dvd a b\nh₂ : Dvd.dvd b a\n⊢ Eq a b","decl":"theorem dvd_antisymm {a b : Ordinal} (h₁ : a ∣ b) (h₂ : b ∣ a) : a = b :=\n  if a0 : a = 0 then by subst a; exact (eq_zero_of_zero_dvd h₁).symm\n  else\n    if b0 : b = 0 then by subst b; exact eq_zero_of_zero_dvd h₂\n    else (le_of_dvd b0 h₁).antisymm (le_of_dvd a0 h₂)\n\n"}
{"name":"Ordinal.isAntisymm","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ IsAntisymm Ordinal.{u_4} fun x1 x2 => Dvd.dvd x1 x2","decl":"instance isAntisymm : IsAntisymm Ordinal (· ∣ ·) :=\n  ⟨@dvd_antisymm⟩\n\n"}
{"name":"Ordinal.mod_def","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HMod.hMod a b) (HSub.hSub a (HMul.hMul b (HDiv.hDiv a b)))","decl":"theorem mod_def (a b : Ordinal) : a % b = a - b * (a / b) :=\n  rfl\n\n"}
{"name":"Ordinal.mod_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ LE.le (HMod.hMod a b) a","decl":"theorem mod_le (a b : Ordinal) : a % b ≤ a :=\n  sub_le_self a _\n\n"}
{"name":"Ordinal.mod_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HMod.hMod a 0) a","decl":"@[simp]\ntheorem mod_zero (a : Ordinal) : a % 0 = a := by simp only [mod_def, div_zero, zero_mul, sub_zero]\n\n"}
{"name":"Ordinal.mod_eq_of_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : LT.lt a b\n⊢ Eq (HMod.hMod a b) a","decl":"theorem mod_eq_of_lt {a b : Ordinal} (h : a < b) : a % b = a := by\n  simp only [mod_def, div_eq_zero_of_lt h, mul_zero, sub_zero]\n\n"}
{"name":"Ordinal.zero_mod","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"b : Ordinal.{u_4}\n⊢ Eq (HMod.hMod 0 b) 0","decl":"@[simp]\ntheorem zero_mod (b : Ordinal) : 0 % b = 0 := by simp only [mod_def, zero_div, mul_zero, sub_self]\n\n"}
{"name":"Ordinal.div_add_mod","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HAdd.hAdd (HMul.hMul b (HDiv.hDiv a b)) (HMod.hMod a b)) a","decl":"theorem div_add_mod (a b : Ordinal) : b * (a / b) + a % b = a :=\n  Ordinal.add_sub_cancel_of_le <| mul_div_le _ _\n\n"}
{"name":"Ordinal.mod_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nh : Ne b 0\n⊢ LT.lt (HMod.hMod a b) b","decl":"theorem mod_lt (a) {b : Ordinal} (h : b ≠ 0) : a % b < b :=\n  (add_lt_add_iff_left (b * (a / b))).1 <| by rw [div_add_mod]; exact lt_mul_div_add a h\n\n"}
{"name":"Ordinal.mod_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HMod.hMod a a) 0","decl":"@[simp]\ntheorem mod_self (a : Ordinal) : a % a = 0 :=\n  if a0 : a = 0 then by simp only [a0, zero_mod]\n  else by simp only [mod_def, div_self a0, mul_one, sub_self]\n\n"}
{"name":"Ordinal.mod_one","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_4}\n⊢ Eq (HMod.hMod a 1) 0","decl":"@[simp]\ntheorem mod_one (a : Ordinal) : a % 1 = 0 := by simp only [mod_def, div_one, one_mul, sub_self]\n\n"}
{"name":"Ordinal.dvd_of_mod_eq_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nH : Eq (HMod.hMod a b) 0\n⊢ Dvd.dvd b a","decl":"theorem dvd_of_mod_eq_zero {a b : Ordinal} (H : a % b = 0) : b ∣ a :=\n  ⟨a / b, by simpa [H] using (div_add_mod a b).symm⟩\n\n"}
{"name":"Ordinal.mod_eq_zero_of_dvd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\nH : Dvd.dvd b a\n⊢ Eq (HMod.hMod a b) 0","decl":"theorem mod_eq_zero_of_dvd {a b : Ordinal} (H : b ∣ a) : a % b = 0 := by\n  rcases H with ⟨c, rfl⟩\n  rcases eq_or_ne b 0 with (rfl | hb)\n  · simp\n  · simp [mod_def, hb]\n\n"}
{"name":"Ordinal.dvd_iff_mod_eq_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Iff (Dvd.dvd b a) (Eq (HMod.hMod a b) 0)","decl":"theorem dvd_iff_mod_eq_zero {a b : Ordinal} : b ∣ a ↔ a % b = 0 :=\n  ⟨mod_eq_zero_of_dvd, dvd_of_mod_eq_zero⟩\n\n"}
{"name":"Ordinal.mul_add_mod_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"x y z : Ordinal.{u_4}\n⊢ Eq (HMod.hMod (HAdd.hAdd (HMul.hMul x y) z) x) (HMod.hMod z x)","decl":"@[simp]\ntheorem mul_add_mod_self (x y z : Ordinal) : (x * y + z) % x = z % x := by\n  rcases eq_or_ne x 0 with rfl | hx\n  · simp\n  · rwa [mod_def, mul_add_div, mul_add, ← sub_sub, add_sub_cancel, mod_def]\n\n"}
{"name":"Ordinal.mul_mod","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"x y : Ordinal.{u_4}\n⊢ Eq (HMod.hMod (HMul.hMul x y) x) 0","decl":"@[simp]\ntheorem mul_mod (x y : Ordinal) : x * y % x = 0 := by\n  simpa using mul_add_mod_self x y 0\n\n"}
{"name":"Ordinal.mul_add_mod_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"w x : Ordinal.{u_4}\nhw : LT.lt w x\ny z : Ordinal.{u_4}\n⊢ Eq (HMod.hMod (HAdd.hAdd (HMul.hMul x y) w) (HMul.hMul x z)) (HAdd.hAdd (HMul.hMul x (HMod.hMod y z)) w)","decl":"theorem mul_add_mod_mul {w x : Ordinal} (hw : w < x) (y z : Ordinal) :\n    (x * y + w) % (x * z) = x * (y % z) + w := by\n  rw [mod_def, mul_add_div_mul hw]\n  apply sub_eq_of_add_eq\n  rw [← add_assoc, mul_assoc, ← mul_add, div_add_mod]\n\n"}
{"name":"Ordinal.mul_mod_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"x y z : Ordinal.{u_4}\n⊢ Eq (HMod.hMod (HMul.hMul x y) (HMul.hMul x z)) (HMul.hMul x (HMod.hMod y z))","decl":"theorem mul_mod_mul (x y z : Ordinal) : (x * y) % (x * z) = x * (y % z) := by\n  obtain rfl | hx := Ordinal.eq_zero_or_pos x\n  · simp\n  · convert mul_add_mod_mul hx y z using 1 <;>\n    rw [add_zero]\n\n"}
{"name":"Ordinal.mod_mod_of_dvd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u_4}\nh : Dvd.dvd c b\n⊢ Eq (HMod.hMod (HMod.hMod a b) c) (HMod.hMod a c)","decl":"theorem mod_mod_of_dvd (a : Ordinal) {b c : Ordinal} (h : c ∣ b) : a % b % c = a % c := by\n  nth_rw 2 [← div_add_mod a b]\n  rcases h with ⟨d, rfl⟩\n  rw [mul_assoc, mul_add_mod_self]\n\n"}
{"name":"Ordinal.mod_mod","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b : Ordinal.{u_4}\n⊢ Eq (HMod.hMod (HMod.hMod a b) b) (HMod.hMod a b)","decl":"@[simp]\ntheorem mod_mod (a b : Ordinal) : a % b % b = a % b :=\n  mod_mod_of_dvd a dvd_rfl\n\n"}
{"name":"Ordinal.bfamilyOfFamily'_typein","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u_4\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nf : ι → α\ni : ι\n⊢ Eq (Ordinal.bfamilyOfFamily' r f ((Ordinal.typein r).toRelEmbedding i) ⋯) (f i)","decl":"@[simp]\ntheorem bfamilyOfFamily'_typein {ι} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α) (i) :\n    bfamilyOfFamily' r f (typein r i) (typein_lt_type r i) = f i := by\n  simp only [bfamilyOfFamily', enum_typein]\n\n"}
{"name":"Ordinal.bfamilyOfFamily_typein","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u_4\nf : ι → α\ni : ι\n⊢ Eq (Ordinal.bfamilyOfFamily f ((Ordinal.typein WellOrderingRel).toRelEmbedding i) ⋯) (f i)","decl":"@[simp]\ntheorem bfamilyOfFamily_typein {ι} (f : ι → α) (i) :\n    bfamilyOfFamily f (typein _ i) (typein_lt_type _ i) = f i :=\n  bfamilyOfFamily'_typein _ f i\n\n"}
{"name":"Ordinal.familyOfBFamily'_enum","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nf : (a : Ordinal.{u}) → LT.lt a o → α\ni : Ordinal.{u}\nhi : LT.lt i o\n⊢ Eq (Ordinal.familyOfBFamily' r ho f ((Ordinal.enum r) ⟨i, ⋯⟩)) (f i hi)","decl":"theorem familyOfBFamily'_enum {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o}\n    (ho : type r = o) (f : ∀ a < o, α) (i hi) :\n    familyOfBFamily' r ho f (enum r ⟨i, by rwa [ho]⟩) = f i hi := by\n  simp only [familyOfBFamily', typein_enum]\n\n"}
{"name":"Ordinal.familyOfBFamily_enum","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → α\ni : Ordinal.{u_4}\nhi : LT.lt i o\n⊢ Eq (o.familyOfBFamily f ((Ordinal.enum fun x1 x2 => LT.lt x1 x2) ⟨i, ⋯⟩)) (f i hi)","decl":"theorem familyOfBFamily_enum (o : Ordinal) (f : ∀ a < o, α) (i hi) :\n    familyOfBFamily o f (enum (α := o.toType) (· < ·) ⟨i, hi.trans_eq (type_toType _).symm⟩)\n    = f i hi :=\n  familyOfBFamily'_enum _ (type_toType o) f _ _\n\n"}
{"name":"Ordinal.mem_brange","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → α\na : α\n⊢ Iff (Membership.mem (o.brange f) a) (Exists fun i => Exists fun hi => Eq (f i hi) a)","decl":"theorem mem_brange {o : Ordinal} {f : ∀ a < o, α} {a} : a ∈ brange o f ↔ ∃ i hi, f i hi = a :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.mem_brange_self","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → α\ni : Ordinal.{u_4}\nhi : LT.lt i o\n⊢ Membership.mem (o.brange f) (f i hi)","decl":"theorem mem_brange_self {o} (f : ∀ a < o, α) (i hi) : f i hi ∈ brange o f :=\n  ⟨i, hi, rfl⟩\n\n"}
{"name":"Ordinal.range_familyOfBFamily'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nf : (a : Ordinal.{u}) → LT.lt a o → α\n⊢ Eq (Set.range (Ordinal.familyOfBFamily' r ho f)) (o.brange f)","decl":"@[simp]\ntheorem range_familyOfBFamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o}\n    (ho : type r = o) (f : ∀ a < o, α) : range (familyOfBFamily' r ho f) = brange o f := by\n  refine Set.ext fun a => ⟨?_, ?_⟩\n  · rintro ⟨b, rfl⟩\n    apply mem_brange_self\n  · rintro ⟨i, hi, rfl⟩\n    exact ⟨_, familyOfBFamily'_enum _ _ _ _ _⟩\n\n"}
{"name":"Ordinal.range_familyOfBFamily","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → α\n⊢ Eq (Set.range (o.familyOfBFamily f)) (o.brange f)","decl":"@[simp]\ntheorem range_familyOfBFamily {o} (f : ∀ a < o, α) : range (familyOfBFamily o f) = brange o f :=\n  range_familyOfBFamily' _ _ f\n\n"}
{"name":"Ordinal.brange_bfamilyOfFamily'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nf : ι → α\n⊢ Eq ((Ordinal.type r).brange (Ordinal.bfamilyOfFamily' r f)) (Set.range f)","decl":"@[simp]\ntheorem brange_bfamilyOfFamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α) :\n    brange _ (bfamilyOfFamily' r f) = range f := by\n  refine Set.ext fun a => ⟨?_, ?_⟩\n  · rintro ⟨i, hi, rfl⟩\n    apply mem_range_self\n  · rintro ⟨b, rfl⟩\n    exact ⟨_, _, bfamilyOfFamily'_typein _ _ _⟩\n\n"}
{"name":"Ordinal.brange_bfamilyOfFamily","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Type u\nf : ι → α\n⊢ Eq ((Ordinal.type WellOrderingRel).brange (Ordinal.bfamilyOfFamily f)) (Set.range f)","decl":"@[simp]\ntheorem brange_bfamilyOfFamily {ι : Type u} (f : ι → α) : brange _ (bfamilyOfFamily f) = range f :=\n  brange_bfamilyOfFamily' _ _\n\n"}
{"name":"Ordinal.brange_const","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\no : Ordinal.{u_4}\nho : Ne o 0\nc : α\n⊢ Eq (o.brange fun x x => c) (Singleton.singleton c)","decl":"@[simp]\ntheorem brange_const {o : Ordinal} (ho : o ≠ 0) {c : α} : (brange o fun _ _ => c) = {c} := by\n  rw [← range_familyOfBFamily]\n  exact @Set.range_const _ o.toType (toType_nonempty_iff_ne_zero.2 ho) c\n\n"}
{"name":"Ordinal.comp_bfamilyOfFamily'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nf : ι → α\ng : α → β\n⊢ Eq (fun i hi => g (Ordinal.bfamilyOfFamily' r f i hi)) (Ordinal.bfamilyOfFamily' r (Function.comp g f))","decl":"theorem comp_bfamilyOfFamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → α)\n    (g : α → β) : (fun i hi => g (bfamilyOfFamily' r f i hi)) = bfamilyOfFamily' r (g ∘ f) :=\n  rfl\n\n"}
{"name":"Ordinal.comp_bfamilyOfFamily","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u\nf : ι → α\ng : α → β\n⊢ Eq (fun i hi => g (Ordinal.bfamilyOfFamily f i hi)) (Ordinal.bfamilyOfFamily (Function.comp g f))","decl":"theorem comp_bfamilyOfFamily {ι : Type u} (f : ι → α) (g : α → β) :\n    (fun i hi => g (bfamilyOfFamily f i hi)) = bfamilyOfFamily (g ∘ f) :=\n  rfl\n\n"}
{"name":"Ordinal.comp_familyOfBFamily'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nf : (a : Ordinal.{u}) → LT.lt a o → α\ng : α → β\n⊢ Eq (Function.comp g (Ordinal.familyOfBFamily' r ho f)) (Ordinal.familyOfBFamily' r ho fun i hi => g (f i hi))","decl":"theorem comp_familyOfBFamily' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o}\n    (ho : type r = o) (f : ∀ a < o, α) (g : α → β) :\n    g ∘ familyOfBFamily' r ho f = familyOfBFamily' r ho fun i hi => g (f i hi) :=\n  rfl\n\n"}
{"name":"Ordinal.comp_familyOfBFamily","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nβ : Type u_2\no : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → α\ng : α → β\n⊢ Eq (Function.comp g (o.familyOfBFamily f)) (o.familyOfBFamily fun i hi => g (f i hi))","decl":"theorem comp_familyOfBFamily {o} (f : ∀ a < o, α) (g : α → β) :\n    g ∘ familyOfBFamily o f = familyOfBFamily o fun i hi => g (f i hi) :=\n  rfl\n\n"}
{"name":"Ordinal.sSup_eq_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Eq (SupSet.sSup (Set.range f)) (Ordinal.sup f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-27\")]\ntheorem sSup_eq_sup {ι : Type u} (f : ι → Ordinal.{max u v}) : sSup (Set.range f) = sup.{_, v} f :=\n  rfl\n\n"}
{"name":"Ordinal.bddAbove_range","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ BddAbove (Set.range f)","decl":"/-- The range of an indexed ordinal function, whose outputs live in a higher universe than the\n    inputs, is always bounded above. See `Ordinal.lsub` for an explicit bound. -/\ntheorem bddAbove_range {ι : Type u} (f : ι → Ordinal.{max u v}) : BddAbove (Set.range f) :=\n  ⟨(iSup (succ ∘ card ∘ f)).ord, by\n    rintro a ⟨i, rfl⟩\n    exact le_of_lt (Cardinal.lt_ord.2 ((lt_succ _).trans_le\n      (le_ciSup (Cardinal.bddAbove_range _) _)))⟩\n\n"}
{"name":"Ordinal.bddAbove_of_small","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\nh : Small.{u, u + 1} ↑s\n⊢ BddAbove s","decl":"theorem bddAbove_of_small (s : Set Ordinal.{u}) [h : Small.{u} s] : BddAbove s := by\n  obtain ⟨a, ha⟩ := bddAbove_range (fun x => ((@equivShrink s h).symm x).val)\n  use a\n  intro b hb\n  simpa using ha (mem_range_self (equivShrink s ⟨b, hb⟩))\n\n"}
{"name":"Ordinal.bddAbove_iff_small","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\n⊢ Iff (BddAbove s) (Small.{u, u + 1} ↑s)","decl":"theorem bddAbove_iff_small {s : Set Ordinal.{u}} : BddAbove s ↔ Small.{u} s :=\n  ⟨fun ⟨a, h⟩ => small_subset <| show s ⊆ Iic a from fun _ hx => h hx, fun _ =>\n    bddAbove_of_small _⟩\n\n"}
{"name":"Ordinal.bddAbove_image","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\nhf : BddAbove s\nf : Ordinal.{u} → Ordinal.{max u v}\n⊢ BddAbove (Set.image f s)","decl":"theorem bddAbove_image {s : Set Ordinal.{u}} (hf : BddAbove s)\n    (f : Ordinal.{u} → Ordinal.{max u v}) : BddAbove (f '' s) := by\n  rw [bddAbove_iff_small] at hf ⊢\n  exact small_lift _\n\n"}
{"name":"Ordinal.bddAbove_range_comp","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{v}\nhf : BddAbove (Set.range f)\ng : Ordinal.{v} → Ordinal.{max v w}\n⊢ BddAbove (Set.range (Function.comp g f))","decl":"theorem bddAbove_range_comp {ι : Type u} {f : ι → Ordinal.{v}} (hf : BddAbove (range f))\n    (g : Ordinal.{v} → Ordinal.{max v w}) : BddAbove (range (g ∘ f)) := by\n  rw [range_comp]\n  exact bddAbove_image hf g\n\n"}
{"name":"Ordinal.le_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{u}\ninst✝ : Small.{u, u_4} ι\ni : ι\n⊢ LE.le (f i) (iSup f)","decl":"/-- `le_ciSup` whenever the input type is small in the output universe. This lemma sometimes\nfails to infer `f` in simple cases and needs it to be given explicitly. -/\nprotected theorem le_iSup {ι} (f : ι → Ordinal.{u}) [Small.{u} ι] : ∀ i, f i ≤ iSup f :=\n  le_ciSup (bddAbove_of_small _)\n\n"}
{"name":"Ordinal.le_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\ni : ι\n⊢ LE.le (f i) (Ordinal.sup f)","decl":"set_option linter.deprecated false in\n@[deprecated Ordinal.le_iSup (since := \"2024-08-27\")]\ntheorem le_sup {ι : Type u} (f : ι → Ordinal.{max u v}) : ∀ i, f i ≤ sup.{_, v} f := fun i =>\n  Ordinal.le_iSup f i\n\n"}
{"name":"Ordinal.iSup_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{u}\na : Ordinal.{u}\ninst✝ : Small.{u, u_4} ι\n⊢ Iff (LE.le (iSup f) a) (∀ (i : ι), LE.le (f i) a)","decl":"/-- `ciSup_le_iff'` whenever the input type is small in the output universe. -/\nprotected theorem iSup_le_iff {ι} {f : ι → Ordinal.{u}} {a : Ordinal.{u}} [Small.{u} ι] :\n    iSup f ≤ a ↔ ∀ i, f i ≤ a :=\n  ciSup_le_iff' (bddAbove_of_small _)\n\n"}
{"name":"Ordinal.sup_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LE.le (Ordinal.sup f) a) (∀ (i : ι), LE.le (f i) a)","decl":"set_option linter.deprecated false in\n@[deprecated Ordinal.iSup_le_iff (since := \"2024-08-27\")]\ntheorem sup_le_iff {ι : Type u} {f : ι → Ordinal.{max u v}} {a} : sup.{_, v} f ≤ a ↔ ∀ i, f i ≤ a :=\n  Ordinal.iSup_le_iff\n\n"}
{"name":"Ordinal.iSup_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Sort u_4\nf : ι → Ordinal.{u_5}\na : Ordinal.{u_5}\na✝ : ∀ (i : ι), LE.le (f i) a\n⊢ LE.le (iSup f) a","decl":"/-- An alias of `ciSup_le'` for discoverability. -/\nprotected theorem iSup_le {ι} {f : ι → Ordinal} {a} :\n    (∀ i, f i ≤ a) → iSup f ≤ a :=\n  ciSup_le'\n\n"}
{"name":"Ordinal.sup_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max u v}\na✝ : ∀ (i : ι), LE.le (f i) a\n⊢ LE.le (Ordinal.sup f) a","decl":"set_option linter.deprecated false in\n@[deprecated Ordinal.iSup_le (since := \"2024-08-27\")]\ntheorem sup_le {ι : Type u} {f : ι → Ordinal.{max u v}} {a} : (∀ i, f i ≤ a) → sup.{_, v} f ≤ a :=\n  Ordinal.iSup_le\n\n"}
{"name":"Ordinal.lt_iSup_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{u}\na : Ordinal.{u}\ninst✝ : Small.{u, u_4} ι\n⊢ Iff (LT.lt a (iSup f)) (Exists fun i => LT.lt a (f i))","decl":"/-- `lt_ciSup_iff'` whenever the input type is small in the output universe. -/\nprotected theorem lt_iSup_iff {ι} {f : ι → Ordinal.{u}} {a : Ordinal.{u}} [Small.{u} ι] :\n    a < iSup f ↔ ∃ i, a < f i :=\n  lt_ciSup_iff' (bddAbove_of_small _)\n\n"}
{"name":"Ordinal.lt_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_1\nι : Sort u_4\ninst✝ : CompleteLinearOrder α\na : α\nf : ι → α\n⊢ Iff (LT.lt a (iSup f)) (Exists fun i => LT.lt a (f i))","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-12\")]\nalias lt_iSup := lt_iSup_iff\n\n"}
{"name":"Ordinal.lt_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LT.lt a (Ordinal.sup f)) (Exists fun i => LT.lt a (f i))","decl":"set_option linter.deprecated false in\n@[deprecated Ordinal.lt_iSup (since := \"2024-08-27\")]\ntheorem lt_sup {ι : Type u} {f : ι → Ordinal.{max u v}} {a} : a < sup.{_, v} f ↔ ∃ i, a < f i := by\n  simpa only [not_forall, not_le] using not_congr (@sup_le_iff.{_, v} _ f a)\n\n"}
{"name":"Ordinal.ne_iSup_iff_lt_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (∀ (i : ι), Ne (f i) (iSup f)) (∀ (i : ι), LT.lt (f i) (iSup f))","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-27\")]\ntheorem ne_iSup_iff_lt_iSup {ι : Type u} {f : ι → Ordinal.{max u v}} :\n    (∀ i, f i ≠ iSup f) ↔ ∀ i, f i < iSup f :=\n  forall_congr' fun i => (Ordinal.le_iSup f i).lt_iff_ne.symm\n\n"}
{"name":"Ordinal.ne_sup_iff_lt_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (∀ (i : ι), Ne (f i) (Ordinal.sup f)) (∀ (i : ι), LT.lt (f i) (Ordinal.sup f))","decl":"set_option linter.deprecated false in\n@[deprecated ne_iSup_iff_lt_iSup (since := \"2024-08-27\")]\ntheorem ne_sup_iff_lt_sup {ι : Type u} {f : ι → Ordinal.{max u v}} :\n    (∀ i, f i ≠ sup.{_, v} f) ↔ ∀ i, f i < sup.{_, v} f :=\n  ne_iSup_iff_lt_iSup\n\n-- TODO: state in terms of `IsSuccLimit`.\n"}
{"name":"Ordinal.succ_lt_iSup_of_ne_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{u}\ninst✝ : Small.{u, u_4} ι\nhf : ∀ (i : ι), Ne (f i) (iSup f)\na : Ordinal.{u}\nhao : LT.lt a (iSup f)\n⊢ LT.lt (Order.succ a) (iSup f)","decl":"theorem succ_lt_iSup_of_ne_iSup {ι} {f : ι → Ordinal.{u}} [Small.{u} ι]\n    (hf : ∀ i, f i ≠ iSup f) {a} (hao : a < iSup f) : succ a < iSup f := by\n  by_contra! hoa\n  exact hao.not_le (Ordinal.iSup_le fun i => le_of_lt_succ <|\n    (lt_of_le_of_ne (Ordinal.le_iSup _ _) (hf i)).trans_le hoa)\n\n"}
{"name":"Ordinal.sup_not_succ_of_ne_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\nhf : ∀ (i : ι), Ne (f i) (Ordinal.sup f)\na : Ordinal.{max u v}\nhao : LT.lt a (Ordinal.sup f)\n⊢ LT.lt (Order.succ a) (Ordinal.sup f)","decl":"set_option linter.deprecated false in\n@[deprecated succ_lt_iSup_of_ne_iSup (since := \"2024-08-27\")]\ntheorem sup_not_succ_of_ne_sup {ι : Type u} {f : ι → Ordinal.{max u v}}\n    (hf : ∀ i, f i ≠ sup.{_, v} f) {a} (hao : a < sup.{_, v} f) : succ a < sup.{_, v} f := by\n  by_contra! hoa\n  exact\n    hao.not_le (sup_le fun i => le_of_lt_succ <| (lt_of_le_of_ne (le_sup _ _) (hf i)).trans_le hoa)\n\n-- TODO: generalize to conditionally complete lattices.\n"}
{"name":"Ordinal.iSup_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{u}\ninst✝ : Small.{u, u_4} ι\n⊢ Iff (Eq (iSup f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"theorem iSup_eq_zero_iff {ι} {f : ι → Ordinal.{u}} [Small.{u} ι] :\n    iSup f = 0 ↔ ∀ i, f i = 0 := by\n  refine\n    ⟨fun h i => ?_, fun h =>\n      le_antisymm (Ordinal.iSup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)⟩\n  rw [← Ordinal.le_zero, ← h]\n  exact Ordinal.le_iSup f i\n\n"}
{"name":"Ordinal.sup_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (Eq (Ordinal.sup f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"set_option linter.deprecated false in\n@[deprecated iSup_eq_zero_iff (since := \"2024-08-27\")]\ntheorem sup_eq_zero_iff {ι : Type u} {f : ι → Ordinal.{max u v}} :\n    sup.{_, v} f = 0 ↔ ∀ i, f i = 0 := by\n  refine\n    ⟨fun h i => ?_, fun h =>\n      le_antisymm (sup_le fun i => Ordinal.le_zero.2 (h i)) (Ordinal.zero_le _)⟩\n  rw [← Ordinal.le_zero, ← h]\n  exact le_sup f i\n\n"}
{"name":"Ordinal.sup_empty","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\ninst✝ : IsEmpty ι\nf : ι → Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.sup f) 0","decl":"set_option linter.deprecated false in\n@[deprecated ciSup_of_empty (since := \"2024-08-27\")]\ntheorem sup_empty {ι} [IsEmpty ι] (f : ι → Ordinal) : sup f = 0 :=\n  ciSup_of_empty f\n\n"}
{"name":"Ordinal.sup_const","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\n_hι : Nonempty ι\no : Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.sup fun x => o) o","decl":"set_option linter.deprecated false in\n@[deprecated ciSup_const (since := \"2024-08-27\")]\ntheorem sup_const {ι} [_hι : Nonempty ι] (o : Ordinal) : (sup fun _ : ι => o) = o :=\n  ciSup_const\n\n"}
{"name":"Ordinal.sup_unique","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\ninst✝ : Unique ι\nf : ι → Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.sup f) (f Inhabited.default)","decl":"set_option linter.deprecated false in\n@[deprecated ciSup_unique (since := \"2024-08-27\")]\ntheorem sup_unique {ι} [Unique ι] (f : ι → Ordinal) : sup f = f default :=\n  ciSup_unique\n\n"}
{"name":"Ordinal.sup_le_of_range_subset","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Ordinal.{max (max u v) w}\ng : ι' → Ordinal.{max (max u v) w}\nh : HasSubset.Subset (Set.range f) (Set.range g)\n⊢ LE.le (Ordinal.sup f) (Ordinal.sup g)","decl":"set_option linter.deprecated false in\n@[deprecated csSup_le_csSup' (since := \"2024-08-27\")]\ntheorem sup_le_of_range_subset {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal}\n    (h : Set.range f ⊆ Set.range g) : sup.{u, max v w} f ≤ sup.{v, max u w} g :=\n  csSup_le_csSup' (bddAbove_range.{v, max u w} _) h\n\n-- TODO: generalize or remove\n"}
{"name":"Ordinal.iSup_eq_of_range_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Sort u_4\nι' : Sort u_5\nf : ι → Ordinal.{u_6}\ng : ι' → Ordinal.{u_6}\nh : Eq (Set.range f) (Set.range g)\n⊢ Eq (iSup f) (iSup g)","decl":"theorem iSup_eq_of_range_eq {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal}\n    (h : Set.range f = Set.range g) : iSup f = iSup g :=\n  congr_arg _ h\n\n"}
{"name":"Ordinal.sup_eq_of_range_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Ordinal.{max u v w}\ng : ι' → Ordinal.{max u v w}\nh : Eq (Set.range f) (Set.range g)\n⊢ Eq (Ordinal.sup f) (Ordinal.sup g)","decl":"set_option linter.deprecated false in\n@[deprecated iSup_eq_of_range_eq (since := \"2024-08-27\")]\ntheorem sup_eq_of_range_eq {ι : Type u} {ι' : Type v}\n    {f : ι → Ordinal.{max u v w}} {g : ι' → Ordinal.{max u v w}}\n    (h : Set.range f = Set.range g) : sup.{u, max v w} f = sup.{v, max u w} g :=\n  Ordinal.iSup_eq_of_range_eq h\n\n"}
{"name":"Ordinal.iSup_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\n⊢ Eq (iSup fun a => Order.succ ↑a) o","decl":"theorem iSup_succ (o : Ordinal) : ⨆ a : Iio o, succ a.1 = o := by\n  apply (le_of_forall_lt _).antisymm'\n  · simp [Ordinal.iSup_le_iff]\n  · exact fun a ha ↦ (lt_succ a).trans_le <| Ordinal.le_iSup (fun x : Iio _ ↦ _) ⟨a, ha⟩\n\n-- TODO: generalize to conditionally complete lattices\n"}
{"name":"Ordinal.iSup_sum","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u_4\nβ : Type u_5\nf : Sum α β → Ordinal.{u}\ninst✝¹ : Small.{u, u_4} α\ninst✝ : Small.{u, u_5} β\n⊢ Eq (iSup f) (Max.max (iSup fun a => f (Sum.inl a)) (iSup fun b => f (Sum.inr b)))","decl":"theorem iSup_sum {α β} (f : α ⊕ β → Ordinal.{u}) [Small.{u} α] [Small.{u} β]:\n    iSup f = max (⨆ a, f (Sum.inl a)) (⨆ b, f (Sum.inr b)) := by\n  apply (Ordinal.iSup_le _).antisymm (max_le _ _)\n  · rintro (i | i)\n    · exact le_max_of_le_left (Ordinal.le_iSup (fun x ↦ f (Sum.inl x)) i)\n    · exact le_max_of_le_right (Ordinal.le_iSup (fun x ↦ f (Sum.inr x)) i)\n  all_goals\n    apply csSup_le_csSup' (bddAbove_of_small _)\n    rintro i ⟨a, rfl⟩\n    apply mem_range_self\n\n"}
{"name":"Ordinal.sup_sum","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u\nβ : Type v\nf : Sum α β → Ordinal.{max (max u v) w}\n⊢ Eq (Ordinal.sup f) (Max.max (Ordinal.sup fun a => f (Sum.inl a)) (Ordinal.sup fun b => f (Sum.inr b)))","decl":"set_option linter.deprecated false in\n@[deprecated iSup_sum (since := \"2024-08-27\")]\ntheorem sup_sum {α : Type u} {β : Type v} (f : α ⊕ β → Ordinal) :\n    sup.{max u v, w} f =\n      max (sup.{u, max v w} fun a => f (Sum.inl a)) (sup.{v, max u w} fun b => f (Sum.inr b)) := by\n  apply (sup_le_iff.2 _).antisymm (max_le_iff.2 ⟨_, _⟩)\n  · rintro (i | i)\n    · exact le_max_of_le_left (le_sup _ i)\n    · exact le_max_of_le_right (le_sup _ i)\n  all_goals\n    apply sup_le_of_range_subset.{_, max u v, w}\n    rintro i ⟨a, rfl⟩\n    apply mem_range_self\n\n"}
{"name":"Ordinal.unbounded_range_of_le_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α β : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : β → α\nh : LE.le (Ordinal.type r) (iSup fun i => (Ordinal.typein r).toRelEmbedding (f i))\n⊢ Set.Unbounded r (Set.range f)","decl":"theorem unbounded_range_of_le_iSup {α β : Type u} (r : α → α → Prop) [IsWellOrder α r] (f : β → α)\n    (h : type r ≤ ⨆ i, typein r (f i)) : Unbounded r (range f) :=\n  (not_bounded_iff _).1 fun ⟨x, hx⟩ =>\n    h.not_lt <| lt_of_le_of_lt\n      (Ordinal.iSup_le fun y => ((typein_lt_typein r).2 <| hx _ <| mem_range_self y).le)\n      (typein_lt_type r x)\n\n"}
{"name":"Ordinal.unbounded_range_of_sup_ge","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α β : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : β → α\nh : LE.le (Ordinal.type r) (Ordinal.sup (Function.comp (⇑(Ordinal.typein r).toRelEmbedding) f))\n⊢ Set.Unbounded r (Set.range f)","decl":"set_option linter.deprecated false in\n@[deprecated unbounded_range_of_le_iSup (since := \"2024-08-27\")]\ntheorem unbounded_range_of_sup_ge {α β : Type u} (r : α → α → Prop) [IsWellOrder α r] (f : β → α)\n    (h : type r ≤ sup.{u, u} (typein r ∘ f)) : Unbounded r (range f) :=\n  unbounded_range_of_le_iSup r f h\n\n"}
{"name":"Ordinal.le_sup_shrink_equiv","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\nhs : Small.{u, u + 1} ↑s\na : Ordinal.{u}\nha : Membership.mem s a\n⊢ LE.le a (Ordinal.sup fun x => ↑((equivShrink ↑s).symm x))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-27\")]\ntheorem le_sup_shrink_equiv {s : Set Ordinal.{u}} (hs : Small.{u} s) (a) (ha : a ∈ s) :\n    a ≤ sup.{u, u} fun x => ((@equivShrink s hs).symm x).val := by\n  convert le_sup.{u, u} (fun x => ((@equivShrink s hs).symm x).val) ((@equivShrink s hs) ⟨a, ha⟩)\n  rw [symm_apply_apply]\n\n"}
{"name":"Ordinal.IsNormal.map_iSup_of_bddAbove","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nH : Ordinal.IsNormal f\nι : Type u_4\ng : ι → Ordinal.{u}\nhg : BddAbove (Set.range g)\ninst✝ : Nonempty ι\n⊢ Eq (f (iSup fun i => g i)) (iSup fun i => f (g i))","decl":"theorem IsNormal.map_iSup_of_bddAbove {f : Ordinal.{u} → Ordinal.{v}} (H : IsNormal f)\n    {ι : Type*} (g : ι → Ordinal.{u}) (hg : BddAbove (range g))\n    [Nonempty ι] : f (⨆ i, g i) = ⨆ i, f (g i) := eq_of_forall_ge_iff fun a ↦ by\n  have := bddAbove_iff_small.mp hg\n  have := univLE_of_injective H.strictMono.injective\n  have := Small.trans_univLE.{u, v} (range g)\n  have hfg : BddAbove (range (f ∘ g)) := bddAbove_iff_small.mpr <| by\n    rw [range_comp]\n    exact small_image f (range g)\n  change _ ↔ ⨆ i, (f ∘ g) i ≤ a\n  rw [ciSup_le_iff hfg, H.le_set' _ Set.univ_nonempty g] <;> simp [ciSup_le_iff hg]\n\n"}
{"name":"Ordinal.IsNormal.map_iSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nH : Ordinal.IsNormal f\nι : Type w\ng : ι → Ordinal.{u}\ninst✝¹ : Small.{u, w} ι\ninst✝ : Nonempty ι\n⊢ Eq (f (iSup fun i => g i)) (iSup fun i => f (g i))","decl":"theorem IsNormal.map_iSup {f : Ordinal.{u} → Ordinal.{v}} (H : IsNormal f)\n    {ι : Type w} (g : ι → Ordinal.{u}) [Small.{u} ι] [Nonempty ι] :\n    f (⨆ i, g i) = ⨆ i, f (g i) :=\n  H.map_iSup_of_bddAbove g (bddAbove_of_small _)\n\n"}
{"name":"Ordinal.IsNormal.map_sSup_of_bddAbove","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nH : Ordinal.IsNormal f\ns : Set Ordinal.{u}\nhs : BddAbove s\nhn : s.Nonempty\n⊢ Eq (f (SupSet.sSup s)) (SupSet.sSup (Set.image f s))","decl":"theorem IsNormal.map_sSup_of_bddAbove {f : Ordinal.{u} → Ordinal.{v}} (H : IsNormal f)\n    {s : Set Ordinal.{u}} (hs : BddAbove s) (hn : s.Nonempty) : f (sSup s) = sSup (f '' s) := by\n  have := hn.to_subtype\n  rw [sSup_eq_iSup', sSup_image', H.map_iSup_of_bddAbove]\n  rwa [Subtype.range_coe_subtype, setOf_mem_eq]\n\n"}
{"name":"Ordinal.IsNormal.map_sSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nH : Ordinal.IsNormal f\ns : Set Ordinal.{u}\nhn : s.Nonempty\ninst✝ : Small.{u, u + 1} ↑s\n⊢ Eq (f (SupSet.sSup s)) (SupSet.sSup (Set.image f s))","decl":"theorem IsNormal.map_sSup {f : Ordinal.{u} → Ordinal.{v}} (H : IsNormal f)\n    {s : Set Ordinal.{u}} (hn : s.Nonempty) [Small.{u} s] : f (sSup s) = sSup (f '' s) :=\n  H.map_sSup_of_bddAbove (bddAbove_of_small s) hn\n\n"}
{"name":"Ordinal.IsNormal.sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{max u v} → Ordinal.{max u w}\nH : Ordinal.IsNormal f\nι : Type u\ng : ι → Ordinal.{max u v}\ninst✝ : Nonempty ι\n⊢ Eq (f (Ordinal.sup g)) (Ordinal.sup (Function.comp f g))","decl":"set_option linter.deprecated false in\n@[deprecated IsNormal.map_iSup (since := \"2024-08-27\")]\ntheorem IsNormal.sup {f : Ordinal.{max u v} → Ordinal.{max u w}} (H : IsNormal f) {ι : Type u}\n    (g : ι → Ordinal.{max u v}) [Nonempty ι] : f (sup.{_, v} g) = sup.{_, w} (f ∘ g) :=\n  H.map_iSup g\n\n"}
{"name":"Ordinal.IsNormal.apply_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nH : Ordinal.IsNormal f\no : Ordinal.{u}\nho : o.IsLimit\n⊢ Eq (f o) (iSup fun a => f ↑a)","decl":"theorem IsNormal.apply_of_isLimit {f : Ordinal.{u} → Ordinal.{v}} (H : IsNormal f) {o : Ordinal}\n    (ho : IsLimit o) : f o = ⨆ a : Iio o, f a := by\n  have : Nonempty (Iio o) := ⟨0, ho.pos⟩\n  rw [← H.map_iSup, ho.iSup_Iio]\n\n"}
{"name":"Ordinal.sup_eq_sSup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\nhs : Small.{u, u + 1} ↑s\n⊢ Eq (Ordinal.sup fun x => ↑((equivShrink ↑s).symm x)) (SupSet.sSup s)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-08-27\")]\ntheorem sup_eq_sSup {s : Set Ordinal.{u}} (hs : Small.{u} s) :\n    (sup.{u, u} fun x => (@equivShrink s hs).symm x) = sSup s :=\n  let hs' := bddAbove_iff_small.2 hs\n  ((csSup_le_iff' hs').2 (le_sup_shrink_equiv hs)).antisymm'\n    (sup_le fun _x => le_csSup hs' (Subtype.mem _))\n\n"}
{"name":"Ordinal.sSup_ord","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Cardinal.{u}\nhs : BddAbove s\n⊢ Eq (SupSet.sSup s).ord (SupSet.sSup (Set.image Cardinal.ord s))","decl":"theorem sSup_ord {s : Set Cardinal.{u}} (hs : BddAbove s) : (sSup s).ord = sSup (ord '' s) :=\n  eq_of_forall_ge_iff fun a => by\n    rw [csSup_le_iff'\n        (bddAbove_iff_small.2 (@small_image _ _ _ s (Cardinal.bddAbove_iff_small.1 hs))),\n      ord_le, csSup_le_iff' hs]\n    simp [ord_le]\n\n"}
{"name":"Ordinal.iSup_ord","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Sort u_4\nf : ι → Cardinal.{u_5}\nhf : BddAbove (Set.range f)\n⊢ Eq (iSup f).ord (iSup fun i => (f i).ord)","decl":"theorem iSup_ord {ι} {f : ι → Cardinal} (hf : BddAbove (range f)) :\n    (iSup f).ord = ⨆ i, (f i).ord := by\n  unfold iSup\n  convert sSup_ord hf\n  -- Porting note: `change` is required.\n  conv_lhs => change range (ord ∘ f)\n  rw [range_comp]\n\n"}
{"name":"Ordinal.lift_card_sInf_compl_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\n⊢ LE.le (Cardinal.lift.{u + 1, u} (InfSet.sInf (HasCompl.compl s)).card) (Cardinal.mk ↑s)","decl":"theorem lift_card_sInf_compl_le (s : Set Ordinal.{u}) :\n    Cardinal.lift.{u + 1} (sInf sᶜ).card ≤ #s := by\n  rw [← mk_Iio_ordinal]\n  refine mk_le_mk_of_subset fun x (hx : x < _) ↦ ?_\n  rw [← not_not_mem]\n  exact not_mem_of_lt_csInf' hx\n\n"}
{"name":"Ordinal.card_sInf_range_compl_le_lift","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (InfSet.sInf (HasCompl.compl (Set.range f))).card (Cardinal.lift.{v, u} (Cardinal.mk ι))","decl":"theorem card_sInf_range_compl_le_lift {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    (sInf (range f)ᶜ).card ≤ Cardinal.lift.{v} #ι := by\n  rw [← Cardinal.lift_le.{max u v + 1}, Cardinal.lift_lift]\n  apply (lift_card_sInf_compl_le _).trans\n  rw [← Cardinal.lift_id'.{u, max u v + 1} #(range _)]\n  exact mk_range_le_lift\n\n"}
{"name":"Ordinal.card_sInf_range_compl_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\n⊢ LE.le (InfSet.sInf (HasCompl.compl (Set.range f))).card (Cardinal.mk ι)","decl":"theorem card_sInf_range_compl_le {ι : Type u} (f : ι → Ordinal.{u}) :\n    (sInf (range f)ᶜ).card ≤ #ι :=\n  Cardinal.lift_id #ι ▸ card_sInf_range_compl_le_lift f\n\n"}
{"name":"Ordinal.sInf_compl_lt_lift_ord_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LT.lt (InfSet.sInf (HasCompl.compl (Set.range f))) (Ordinal.lift.{v, u} (Order.succ (Cardinal.mk ι)).ord)","decl":"theorem sInf_compl_lt_lift_ord_succ {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    sInf (range f)ᶜ < lift.{v} (succ #ι).ord := by\n  rw [lift_ord, Cardinal.lift_succ, ← card_le_iff]\n  exact card_sInf_range_compl_le_lift f\n\n"}
{"name":"Ordinal.sInf_compl_lt_ord_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\n⊢ LT.lt (InfSet.sInf (HasCompl.compl (Set.range f))) (Order.succ (Cardinal.mk ι)).ord","decl":"theorem sInf_compl_lt_ord_succ {ι : Type u} (f : ι → Ordinal.{u}) :\n    sInf (range f)ᶜ < (succ #ι).ord :=\n  lift_id (succ #ι).ord ▸ sInf_compl_lt_lift_ord_succ f\n\n-- TODO: remove `bsup` in favor of `iSup` in a future refactor.\n\n"}
{"name":"Ordinal.sup_eq_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι ι' : Type u\nr : ι → ι → Prop\nr' : ι' → ι' → Prop\ninst✝¹ : IsWellOrder ι r\ninst✝ : IsWellOrder ι' r'\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nho' : Eq (Ordinal.type r') o\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.sup (Ordinal.familyOfBFamily' r ho f)) (Ordinal.sup (Ordinal.familyOfBFamily' r' ho' f))","decl":"set_option linter.deprecated false in\ntheorem sup_eq_sup {ι ι' : Type u} (r : ι → ι → Prop) (r' : ι' → ι' → Prop) [IsWellOrder ι r]\n    [IsWellOrder ι' r'] {o : Ordinal.{u}} (ho : type r = o) (ho' : type r' = o)\n    (f : ∀ a < o, Ordinal.{max u v}) :\n    sup.{_, v} (familyOfBFamily' r ho f) = sup.{_, v} (familyOfBFamily' r' ho' f) :=\n  sup_eq_of_range_eq.{u, u, v} (by simp)\n\n"}
{"name":"Ordinal.sup_eq_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.sup (o.familyOfBFamily f)) (o.bsup f)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem sup_eq_bsup {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    sup.{_, v} (familyOfBFamily o f) = bsup.{_, v} o f :=\n  rfl\n\n"}
{"name":"Ordinal.sup_eq_bsup'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nho : Eq (Ordinal.type r) o\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.sup (Ordinal.familyOfBFamily' r ho f)) (o.bsup f)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem sup_eq_bsup' {o : Ordinal.{u}} {ι} (r : ι → ι → Prop) [IsWellOrder ι r] (ho : type r = o)\n    (f : ∀ a < o, Ordinal.{max u v}) : sup.{_, v} (familyOfBFamily' r ho f) = bsup.{_, v} o f :=\n  sup_eq_sup r _ ho _ f\n\n"}
{"name":"Ordinal.sSup_eq_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (SupSet.sSup (o.brange f)) (o.bsup f)","decl":"theorem sSup_eq_bsup {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    sSup (brange o f) = bsup.{_, v} o f := by\n  congr\n  rw [range_familyOfBFamily]\n\n"}
{"name":"Ordinal.bsup_eq_sup'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type r).bsup (Ordinal.bfamilyOfFamily' r f)) (Ordinal.sup f)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem bsup_eq_sup' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] (f : ι → Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily' r f) = sup.{_, v} f := by\n  simp (config := { unfoldPartialApp := true }) only [← sup_eq_bsup' r, enum_typein,\n    familyOfBFamily', bfamilyOfFamily']\n\n"}
{"name":"Ordinal.bsup_eq_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nr r' : ι → ι → Prop\ninst✝¹ : IsWellOrder ι r\ninst✝ : IsWellOrder ι r'\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type r).bsup (Ordinal.bfamilyOfFamily' r f)) ((Ordinal.type r').bsup (Ordinal.bfamilyOfFamily' r' f))","decl":"theorem bsup_eq_bsup {ι : Type u} (r r' : ι → ι → Prop) [IsWellOrder ι r] [IsWellOrder ι r']\n    (f : ι → Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily' r f) = bsup.{_, v} _ (bfamilyOfFamily' r' f) := by\n  rw [bsup_eq_sup', bsup_eq_sup']\n\n"}
{"name":"Ordinal.bsup_eq_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type WellOrderingRel).bsup (Ordinal.bfamilyOfFamily f)) (Ordinal.sup f)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem bsup_eq_sup {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily f) = sup.{_, v} f :=\n  bsup_eq_sup' _ f\n\n"}
{"name":"Ordinal.bsup_congr","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o₁ o₂ : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o₁ → Ordinal.{max u v}\nho : Eq o₁ o₂\n⊢ Eq (o₁.bsup f) (o₂.bsup fun a h => f a ⋯)","decl":"@[congr]\ntheorem bsup_congr {o₁ o₂ : Ordinal.{u}} (f : ∀ a < o₁, Ordinal.{max u v}) (ho : o₁ = o₂) :\n    bsup.{_, v} o₁ f = bsup.{_, v} o₂ fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n\n"}
{"name":"Ordinal.bsup_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LE.le (o.bsup f) a) (∀ (i : Ordinal.{u}) (h : LT.lt i o), LE.le (f i h) a)","decl":"set_option linter.deprecated false in\ntheorem bsup_le_iff {o f a} : bsup.{u, v} o f ≤ a ↔ ∀ i h, f i h ≤ a :=\n  sup_le_iff.trans\n    ⟨fun h i hi => by\n      rw [← familyOfBFamily_enum o f]\n      exact h _, fun h _ => h _ _⟩\n\n"}
{"name":"Ordinal.bsup_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v}\na : Ordinal.{max u v}\na✝ : ∀ (i : Ordinal.{u}) (h : LT.lt i o), LE.le (f i h) a\n⊢ LE.le (o.bsup f) a","decl":"theorem bsup_le {o : Ordinal} {f : ∀ b < o, Ordinal} {a} :\n    (∀ i h, f i h ≤ a) → bsup.{u, v} o f ≤ a :=\n  bsup_le_iff.2\n\n"}
{"name":"Ordinal.le_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_5 u_4}\ni : Ordinal.{u_4}\nh : LT.lt i o\n⊢ LE.le (f i h) (o.bsup f)","decl":"theorem le_bsup {o} (f : ∀ a < o, Ordinal) (i h) : f i h ≤ bsup o f :=\n  bsup_le_iff.1 le_rfl _ _\n\n"}
{"name":"Ordinal.lt_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LT.lt a (o.bsup f)) (Exists fun i => Exists fun hi => LT.lt a (f i hi))","decl":"theorem lt_bsup {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) {a} :\n    a < bsup.{_, v} o f ↔ ∃ i hi, a < f i hi := by\n  simpa only [not_forall, not_le] using not_congr (@bsup_le_iff.{_, v} _ f a)\n\n"}
{"name":"Ordinal.IsNormal.bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{max u v} → Ordinal.{max u w}\nH : Ordinal.IsNormal f\no : Ordinal.{u}\ng : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\na✝ : Ne o 0\n⊢ Eq (f (o.bsup g)) (o.bsup fun a h => f (g a h))","decl":"set_option linter.deprecated false in\ntheorem IsNormal.bsup {f : Ordinal.{max u v} → Ordinal.{max u w}} (H : IsNormal f)\n    {o : Ordinal.{u}} :\n    ∀ (g : ∀ a < o, Ordinal), o ≠ 0 → f (bsup.{_, v} o g) = bsup.{_, w} o fun a h => f (g a h) :=\n  inductionOn o fun α r _ g h => by\n    haveI := type_ne_zero_iff_nonempty.1 h\n    rw [← sup_eq_bsup' r, IsNormal.sup.{_, v, w} H, ← sup_eq_bsup' r] <;> rfl\n\n"}
{"name":"Ordinal.lt_bsup_of_ne_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Iff (∀ (i : Ordinal.{u}) (h : LT.lt i o), Ne (f i h) (o.bsup f)) (∀ (i : Ordinal.{u}) (h : LT.lt i o), LT.lt (f i h) (o.bsup f))","decl":"theorem lt_bsup_of_ne_bsup {o : Ordinal.{u}} {f : ∀ a < o, Ordinal.{max u v}} :\n    (∀ i h, f i h ≠ bsup.{_, v} o f) ↔ ∀ i h, f i h < bsup.{_, v} o f :=\n  ⟨fun hf _ _ => lt_of_le_of_ne (le_bsup _ _ _) (hf _ _), fun hf _ _ => ne_of_lt (hf _ _)⟩\n\n"}
{"name":"Ordinal.bsup_not_succ_of_ne_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nhf : ∀ {i : Ordinal.{u}} (h : LT.lt i o), Ne (f i h) (o.bsup f)\na : Ordinal.{max u v}\na✝ : LT.lt a (o.bsup f)\n⊢ LT.lt (Order.succ a) (o.bsup f)","decl":"set_option linter.deprecated false in\ntheorem bsup_not_succ_of_ne_bsup {o : Ordinal.{u}} {f : ∀ a < o, Ordinal.{max u v}}\n    (hf : ∀ {i : Ordinal} (h : i < o), f i h ≠ bsup.{_, v} o f) (a) :\n    a < bsup.{_, v} o f → succ a < bsup.{_, v} o f := by\n  rw [← sup_eq_bsup] at *\n  exact sup_not_succ_of_ne_sup fun i => hf _\n\n"}
{"name":"Ordinal.bsup_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_5 u_4}\n⊢ Iff (Eq (o.bsup f) 0) (∀ (i : Ordinal.{u_4}) (hi : LT.lt i o), Eq (f i hi) 0)","decl":"@[simp]\ntheorem bsup_eq_zero_iff {o} {f : ∀ a < o, Ordinal} : bsup o f = 0 ↔ ∀ i hi, f i hi = 0 := by\n  refine\n    ⟨fun h i hi => ?_, fun h =>\n      le_antisymm (bsup_le fun i hi => Ordinal.le_zero.2 (h i hi)) (Ordinal.zero_le _)⟩\n  rw [← Ordinal.le_zero, ← h]\n  exact le_bsup f i hi\n\n"}
{"name":"Ordinal.lt_bsup_of_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\nhf : ∀ {a a' : Ordinal.{u_4}} (ha : LT.lt a o) (ha' : LT.lt a' o), LT.lt a a' → LT.lt (f a ha) (f a' ha')\nho : ∀ (a : Ordinal.{u_4}), LT.lt a o → LT.lt (Order.succ a) o\ni : Ordinal.{u_4}\nh : LT.lt i o\n⊢ LT.lt (f i h) (o.bsup f)","decl":"theorem lt_bsup_of_limit {o : Ordinal} {f : ∀ a < o, Ordinal}\n    (hf : ∀ {a a'} (ha : a < o) (ha' : a' < o), a < a' → f a ha < f a' ha')\n    (ho : ∀ a < o, succ a < o) (i h) : f i h < bsup o f :=\n  (hf _ _ <| lt_succ i).trans_le (le_bsup f (succ i) <| ho _ h)\n\n"}
{"name":"Ordinal.bsup_succ_of_mono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a (Order.succ o) → Ordinal.{max u_4 u_5}\nhf : ∀ {i j : Ordinal.{u_4}} (hi : LT.lt i (Order.succ o)) (hj : LT.lt j (Order.succ o)), LE.le i j → LE.le (f i hi) (f j hj)\n⊢ Eq ((Order.succ o).bsup f) (f o ⋯)","decl":"theorem bsup_succ_of_mono {o : Ordinal} {f : ∀ a < succ o, Ordinal}\n    (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) : bsup _ f = f o (lt_succ o) :=\n  le_antisymm (bsup_le fun _i hi => hf _ _ <| le_of_lt_succ hi) (le_bsup _ _ _)\n\n"}
{"name":"Ordinal.bsup_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : (a : Ordinal.{u_4}) → LT.lt a 0 → Ordinal.{max u_4 u_5}\n⊢ Eq (Ordinal.bsup 0 f) 0","decl":"@[simp]\ntheorem bsup_zero (f : ∀ a < (0 : Ordinal), Ordinal) : bsup 0 f = 0 :=\n  bsup_eq_zero_iff.2 fun i hi => (Ordinal.not_lt_zero i hi).elim\n\n"}
{"name":"Ordinal.bsup_const","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nho : Ne o 0\na : Ordinal.{max u v}\n⊢ Eq (o.bsup fun x x => a) a","decl":"theorem bsup_const {o : Ordinal.{u}} (ho : o ≠ 0) (a : Ordinal.{max u v}) :\n    (bsup.{_, v} o fun _ _ => a) = a :=\n  le_antisymm (bsup_le fun _ _ => le_rfl) (le_bsup _ 0 (Ordinal.pos_iff_ne_zero.2 ho))\n\n"}
{"name":"Ordinal.bsup_one","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : (a : Ordinal.{u_4}) → LT.lt a 1 → Ordinal.{max u_4 u_5}\n⊢ Eq (Ordinal.bsup 1 f) (f 0 ⋯)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem bsup_one (f : ∀ a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one := by\n  simp_rw [← sup_eq_bsup, sup_unique, familyOfBFamily, familyOfBFamily', typein_one_toType]\n\n"}
{"name":"Ordinal.bsup_le_of_brange_subset","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\no' : Ordinal.{v}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max (max u v) w}\ng : (a : Ordinal.{v}) → LT.lt a o' → Ordinal.{max (max u v) w}\nh : HasSubset.Subset (o.brange f) (o'.brange g)\n⊢ LE.le (o.bsup f) (o'.bsup g)","decl":"theorem bsup_le_of_brange_subset {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal}\n    (h : brange o f ⊆ brange o' g) : bsup.{u, max v w} o f ≤ bsup.{v, max u w} o' g :=\n  bsup_le fun i hi => by\n    obtain ⟨j, hj, hj'⟩ := h ⟨i, hi, rfl⟩\n    rw [← hj']\n    apply le_bsup\n\n"}
{"name":"Ordinal.bsup_eq_of_brange_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\no' : Ordinal.{v}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max (max u v) w}\ng : (a : Ordinal.{v}) → LT.lt a o' → Ordinal.{max (max u v) w}\nh : Eq (o.brange f) (o'.brange g)\n⊢ Eq (o.bsup f) (o'.bsup g)","decl":"theorem bsup_eq_of_brange_eq {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal}\n    (h : brange o f = brange o' g) : bsup.{u, max v w} o f = bsup.{v, max u w} o' g :=\n  (bsup_le_of_brange_subset.{u, v, w} h.le).antisymm (bsup_le_of_brange_subset.{v, u, w} h.ge)\n\n"}
{"name":"Ordinal.iSup_eq_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_5 u_4}\n⊢ Eq (iSup fun a => f ↑a ⋯) (o.bsup f)","decl":"set_option linter.deprecated false in\ntheorem iSup_eq_bsup {o} {f : ∀ a < o, Ordinal} : ⨆ a : Iio o, f a.1 a.2 = bsup o f := by\n  simp_rw [Iio, bsup, sup, iSup, range_familyOfBFamily, brange, range, Subtype.exists, mem_setOf]\n\n"}
{"name":"Ordinal.sup_eq_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Eq (Ordinal.sup (Function.comp Order.succ f)) (Ordinal.lsub f)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem sup_eq_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    sup.{_, v} (succ ∘ f) = lsub.{_, v} f :=\n  rfl\n\n"}
{"name":"Ordinal.lsub_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max v u}\n⊢ Iff (LE.le (Ordinal.lsub f) a) (∀ (i : ι), LT.lt (f i) a)","decl":"set_option linter.deprecated false in\ntheorem lsub_le_iff {ι : Type u} {f : ι → Ordinal.{max u v}} {a} :\n    lsub.{_, v} f ≤ a ↔ ∀ i, f i < a := by\n  convert sup_le_iff.{_, v} (f := succ ∘ f) (a := a) using 2\n  -- Porting note: `comp_apply` is required.\n  simp only [comp_apply, succ_le_iff]\n\n"}
{"name":"Ordinal.lsub_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{max u_5 u_4}\na : Ordinal.{max u_5 u_4}\na✝ : ∀ (i : ι), LT.lt (f i) a\n⊢ LE.le (Ordinal.lsub f) a","decl":"theorem lsub_le {ι} {f : ι → Ordinal} {a} : (∀ i, f i < a) → lsub f ≤ a :=\n  lsub_le_iff.2\n\n"}
{"name":"Ordinal.lt_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{max u_5 u_4}\ni : ι\n⊢ LT.lt (f i) (Ordinal.lsub f)","decl":"set_option linter.deprecated false in\ntheorem lt_lsub {ι} (f : ι → Ordinal) (i) : f i < lsub f :=\n  succ_le_iff.1 (le_sup _ i)\n\n"}
{"name":"Ordinal.lt_lsub_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max v u}\n⊢ Iff (LT.lt a (Ordinal.lsub f)) (Exists fun i => LE.le a (f i))","decl":"theorem lt_lsub_iff {ι : Type u} {f : ι → Ordinal.{max u v}} {a} :\n    a < lsub.{_, v} f ↔ ∃ i, a ≤ f i := by\n  simpa only [not_forall, not_lt, not_le] using not_congr (@lsub_le_iff.{_, v} _ f a)\n\n"}
{"name":"Ordinal.sup_le_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (Ordinal.sup f) (Ordinal.lsub f)","decl":"set_option linter.deprecated false in\ntheorem sup_le_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) : sup.{_, v} f ≤ lsub.{_, v} f :=\n  sup_le fun i => (lt_lsub f i).le\n\n"}
{"name":"Ordinal.lsub_le_sup_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (Ordinal.lsub f) (Order.succ (Ordinal.sup f))","decl":"set_option linter.deprecated false in\ntheorem lsub_le_sup_succ {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    lsub.{_, v} f ≤ succ (sup.{_, v} f) :=\n  lsub_le fun i => lt_succ_iff.2 (le_sup f i)\n\n"}
{"name":"Ordinal.sup_eq_lsub_or_sup_succ_eq_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Or (Eq (Ordinal.sup f) (Ordinal.lsub f)) (Eq (Order.succ (Ordinal.sup f)) (Ordinal.lsub f))","decl":"set_option linter.deprecated false in\ntheorem sup_eq_lsub_or_sup_succ_eq_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f ∨ succ (sup.{_, v} f) = lsub.{_, v} f := by\n  cases' eq_or_lt_of_le (sup_le_lsub.{_, v} f) with h h\n  · exact Or.inl h\n  · exact Or.inr ((succ_le_of_lt h).antisymm (lsub_le_sup_succ f))\n\n"}
{"name":"Ordinal.sup_succ_le_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (LE.le (Order.succ (Ordinal.sup f)) (Ordinal.lsub f)) (Exists fun i => Eq (f i) (Ordinal.sup f))","decl":"set_option linter.deprecated false in\ntheorem sup_succ_le_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    succ (sup.{_, v} f) ≤ lsub.{_, v} f ↔ ∃ i, f i = sup.{_, v} f := by\n  refine ⟨fun h => ?_, ?_⟩\n  · by_contra! hf\n    exact (succ_le_iff.1 h).ne ((sup_le_lsub f).antisymm (lsub_le (ne_sup_iff_lt_sup.1 hf)))\n  rintro ⟨_, hf⟩\n  rw [succ_le_iff, ← hf]\n  exact lt_lsub _ _\n\n"}
{"name":"Ordinal.sup_succ_eq_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (Eq (Order.succ (Ordinal.sup f)) (Ordinal.lsub f)) (Exists fun i => Eq (f i) (Ordinal.sup f))","decl":"set_option linter.deprecated false in\ntheorem sup_succ_eq_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    succ (sup.{_, v} f) = lsub.{_, v} f ↔ ∃ i, f i = sup.{_, v} f :=\n  (lsub_le_sup_succ f).le_iff_eq.symm.trans (sup_succ_le_lsub f)\n\n"}
{"name":"Ordinal.sup_eq_lsub_iff_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (Eq (Ordinal.sup f) (Ordinal.lsub f)) (∀ (a : Ordinal.{max v u}), LT.lt a (Ordinal.lsub f) → LT.lt (Order.succ a) (Ordinal.lsub f))","decl":"set_option linter.deprecated false in\ntheorem sup_eq_lsub_iff_succ {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f ↔ ∀ a < lsub.{_, v} f, succ a < lsub.{_, v} f := by\n  refine ⟨fun h => ?_, fun hf => le_antisymm (sup_le_lsub f) (lsub_le fun i => ?_)⟩\n  · rw [← h]\n    exact fun a => sup_not_succ_of_ne_sup fun i => (lsub_le_iff.1 (le_of_eq h.symm) i).ne\n  by_contra! hle\n  have heq := (sup_succ_eq_lsub f).2 ⟨i, le_antisymm (le_sup _ _) hle⟩\n  have :=\n    hf _\n      (by\n        rw [← heq]\n        exact lt_succ (sup f))\n  rw [heq] at this\n  exact this.false\n\n"}
{"name":"Ordinal.sup_eq_lsub_iff_lt_sup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (Eq (Ordinal.sup f) (Ordinal.lsub f)) (∀ (i : ι), LT.lt (f i) (Ordinal.sup f))","decl":"set_option linter.deprecated false in\ntheorem sup_eq_lsub_iff_lt_sup {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f ↔ ∀ i, f i < sup.{_, v} f :=\n  ⟨fun h i => by\n    rw [h]\n    apply lt_lsub, fun h => le_antisymm (sup_le_lsub f) (lsub_le h)⟩\n\n"}
{"name":"Ordinal.lsub_empty","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nh : IsEmpty ι\nf : ι → Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.lsub f) 0","decl":"@[simp]\ntheorem lsub_empty {ι} [h : IsEmpty ι] (f : ι → Ordinal) : lsub f = 0 := by\n  rw [← Ordinal.le_zero, lsub_le_iff]\n  exact h.elim\n\n"}
{"name":"Ordinal.lsub_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nh : Nonempty ι\nf : ι → Ordinal.{max u v}\n⊢ LT.lt 0 (Ordinal.lsub f)","decl":"theorem lsub_pos {ι : Type u} [h : Nonempty ι] (f : ι → Ordinal.{max u v}) : 0 < lsub.{_, v} f :=\n  h.elim fun i => (Ordinal.zero_le _).trans_lt (lt_lsub f i)\n\n"}
{"name":"Ordinal.lsub_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Iff (Eq (Ordinal.lsub f) 0) (IsEmpty ι)","decl":"@[simp]\ntheorem lsub_eq_zero_iff {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    lsub.{_, v} f = 0 ↔ IsEmpty ι := by\n  refine ⟨fun h => ⟨fun i => ?_⟩, fun h => @lsub_empty _ h _⟩\n  have := @lsub_pos.{_, v} _ ⟨i⟩ f\n  rw [h] at this\n  exact this.false\n\n"}
{"name":"Ordinal.lsub_const","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\ninst✝ : Nonempty ι\no : Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.lsub fun x => o) (Order.succ o)","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem lsub_const {ι} [Nonempty ι] (o : Ordinal) : (lsub fun _ : ι => o) = succ o :=\n  sup_const (succ o)\n\n"}
{"name":"Ordinal.lsub_unique","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\ninst✝ : Unique ι\nf : ι → Ordinal.{max u_5 u_4}\n⊢ Eq (Ordinal.lsub f) (Order.succ (f Inhabited.default))","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem lsub_unique {ι} [Unique ι] (f : ι → Ordinal) : lsub f = succ (f default) :=\n  sup_unique _\n\n"}
{"name":"Ordinal.lsub_le_of_range_subset","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Ordinal.{max (max u v) w}\ng : ι' → Ordinal.{max (max u v) w}\nh : HasSubset.Subset (Set.range f) (Set.range g)\n⊢ LE.le (Ordinal.lsub f) (Ordinal.lsub g)","decl":"set_option linter.deprecated false in\ntheorem lsub_le_of_range_subset {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal}\n    (h : Set.range f ⊆ Set.range g) : lsub.{u, max v w} f ≤ lsub.{v, max u w} g :=\n  sup_le_of_range_subset.{u, v, w} (by convert Set.image_subset succ h <;> apply Set.range_comp)\n\n"}
{"name":"Ordinal.lsub_eq_of_range_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nι' : Type v\nf : ι → Ordinal.{max (max u v) w}\ng : ι' → Ordinal.{max (max u v) w}\nh : Eq (Set.range f) (Set.range g)\n⊢ Eq (Ordinal.lsub f) (Ordinal.lsub g)","decl":"theorem lsub_eq_of_range_eq {ι ι'} {f : ι → Ordinal} {g : ι' → Ordinal}\n    (h : Set.range f = Set.range g) : lsub.{u, max v w} f = lsub.{v, max u w} g :=\n  (lsub_le_of_range_subset.{u, v, w} h.le).antisymm (lsub_le_of_range_subset.{v, u, w} h.ge)\n\n"}
{"name":"Ordinal.lsub_sum","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u\nβ : Type v\nf : Sum α β → Ordinal.{max (max u v) w}\n⊢ Eq (Ordinal.lsub f) (Max.max (Ordinal.lsub fun a => f (Sum.inl a)) (Ordinal.lsub fun b => f (Sum.inr b)))","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem lsub_sum {α : Type u} {β : Type v} (f : α ⊕ β → Ordinal) :\n    lsub.{max u v, w} f =\n      max (lsub.{u, max v w} fun a => f (Sum.inl a)) (lsub.{v, max u w} fun b => f (Sum.inr b)) :=\n  sup_sum _\n\n"}
{"name":"Ordinal.lsub_not_mem_range","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Not (Membership.mem (Set.range f) (Ordinal.lsub f))","decl":"theorem lsub_not_mem_range {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    lsub.{_, v} f ∉ Set.range f := fun ⟨i, h⟩ =>\n  h.not_lt (lt_lsub f i)\n\n"}
{"name":"Ordinal.nonempty_compl_range","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ (HasCompl.compl (Set.range f)).Nonempty","decl":"theorem nonempty_compl_range {ι : Type u} (f : ι → Ordinal.{max u v}) : (Set.range f)ᶜ.Nonempty :=\n  ⟨_, lsub_not_mem_range.{_, v} f⟩\n\n"}
{"name":"Ordinal.lsub_typein","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Ordinal.lsub ⇑(Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding) o","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem lsub_typein (o : Ordinal) : lsub.{u, u} (typein (α := o.toType) (· < ·)) = o :=\n  (lsub_le.{u, u} typein_lt_self).antisymm\n    (by\n      by_contra! h\n      -- Porting note: `nth_rw` → `conv_rhs` & `rw`\n      conv_rhs at h => rw [← type_lt o]\n      simpa [typein_enum] using lt_lsub.{u, u} (typein (· < ·)) (enum (· < ·) ⟨_, h⟩))\n\n"}
{"name":"Ordinal.sup_typein_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nho : ∀ (a : Ordinal.{u}), LT.lt a o → LT.lt (Order.succ a) o\n⊢ Eq (Ordinal.sup ⇑(Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding) o","decl":"set_option linter.deprecated false in\ntheorem sup_typein_limit {o : Ordinal} (ho : ∀ a, a < o → succ a < o) :\n    sup.{u, u} (typein ((· < ·) : o.toType → o.toType → Prop)) = o := by\n  -- Porting note: `rwa` → `rw` & `assumption`\n  rw [(sup_eq_lsub_iff_succ.{u, u} (typein (· < ·))).2] <;> rw [lsub_typein o]; assumption\n\n"}
{"name":"Ordinal.sup_typein_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq (Ordinal.sup ⇑(Ordinal.typein fun x1 x2 => LT.lt x1 x2).toRelEmbedding) o","decl":"set_option linter.deprecated false in\n@[simp]\ntheorem sup_typein_succ {o : Ordinal} :\n    sup.{u, u} (typein ((· < ·) : (succ o).toType → (succ o).toType → Prop)) = o := by\n  cases'\n    sup_eq_lsub_or_sup_succ_eq_lsub.{u, u}\n      (typein ((· < ·) : (succ o).toType → (succ o).toType → Prop)) with\n    h h\n  · rw [sup_eq_lsub_iff_succ] at h\n    simp only [lsub_typein] at h\n    exact (h o (lt_succ o)).false.elim\n  rw [← succ_eq_succ_iff, h]\n  apply lsub_typein\n\n"}
{"name":"Ordinal.bsup_eq_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (o.bsup fun a ha => Order.succ (f a ha)) (o.blsub f)","decl":"@[simp]\ntheorem bsup_eq_blsub (o : Ordinal.{u}) (f : ∀ a < o, Ordinal.{max u v}) :\n    (bsup.{_, v} o fun a ha => succ (f a ha)) = blsub.{_, v} o f :=\n  rfl\n\n"}
{"name":"Ordinal.lsub_eq_blsub'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.lsub (Ordinal.familyOfBFamily' r ho f)) (o.blsub f)","decl":"theorem lsub_eq_blsub' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r] {o} (ho : type r = o)\n    (f : ∀ a < o, Ordinal.{max u v}) : lsub.{_, v} (familyOfBFamily' r ho f) = blsub.{_, v} o f :=\n  sup_eq_bsup'.{_, v} r ho fun a ha => succ (f a ha)\n\n"}
{"name":"Ordinal.lsub_eq_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι ι' : Type u\nr : ι → ι → Prop\nr' : ι' → ι' → Prop\ninst✝¹ : IsWellOrder ι r\ninst✝ : IsWellOrder ι' r'\no : Ordinal.{u}\nho : Eq (Ordinal.type r) o\nho' : Eq (Ordinal.type r') o\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.lsub (Ordinal.familyOfBFamily' r ho f)) (Ordinal.lsub (Ordinal.familyOfBFamily' r' ho' f))","decl":"theorem lsub_eq_lsub {ι ι' : Type u} (r : ι → ι → Prop) (r' : ι' → ι' → Prop) [IsWellOrder ι r]\n    [IsWellOrder ι' r'] {o} (ho : type r = o) (ho' : type r' = o)\n    (f : ∀ a < o, Ordinal.{max u v}) :\n    lsub.{_, v} (familyOfBFamily' r ho f) = lsub.{_, v} (familyOfBFamily' r' ho' f) := by\n  rw [lsub_eq_blsub', lsub_eq_blsub']\n\n"}
{"name":"Ordinal.lsub_eq_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Eq (Ordinal.lsub (o.familyOfBFamily f)) (o.blsub f)","decl":"@[simp]\ntheorem lsub_eq_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    lsub.{_, v} (familyOfBFamily o f) = blsub.{_, v} o f :=\n  lsub_eq_blsub' _ _ _\n\n"}
{"name":"Ordinal.blsub_eq_lsub'","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nr : ι → ι → Prop\ninst✝ : IsWellOrder ι r\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type r).blsub (Ordinal.bfamilyOfFamily' r f)) (Ordinal.lsub f)","decl":"@[simp]\ntheorem blsub_eq_lsub' {ι : Type u} (r : ι → ι → Prop) [IsWellOrder ι r]\n    (f : ι → Ordinal.{max u v}) : blsub.{_, v} _ (bfamilyOfFamily' r f) = lsub.{_, v} f :=\n  bsup_eq_sup'.{_, v} r (succ ∘ f)\n\n"}
{"name":"Ordinal.blsub_eq_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nr r' : ι → ι → Prop\ninst✝¹ : IsWellOrder ι r\ninst✝ : IsWellOrder ι r'\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type r).blsub (Ordinal.bfamilyOfFamily' r f)) ((Ordinal.type r').blsub (Ordinal.bfamilyOfFamily' r' f))","decl":"theorem blsub_eq_blsub {ι : Type u} (r r' : ι → ι → Prop) [IsWellOrder ι r] [IsWellOrder ι r']\n    (f : ι → Ordinal.{max u v}) :\n    blsub.{_, v} _ (bfamilyOfFamily' r f) = blsub.{_, v} _ (bfamilyOfFamily' r' f) := by\n  rw [blsub_eq_lsub', blsub_eq_lsub']\n\n"}
{"name":"Ordinal.blsub_eq_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type WellOrderingRel).blsub (Ordinal.bfamilyOfFamily f)) (Ordinal.lsub f)","decl":"@[simp]\ntheorem blsub_eq_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) :\n    blsub.{_, v} _ (bfamilyOfFamily f) = lsub.{_, v} f :=\n  blsub_eq_lsub' _ _\n\n"}
{"name":"Ordinal.blsub_congr","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o₁ o₂ : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o₁ → Ordinal.{max u v}\nho : Eq o₁ o₂\n⊢ Eq (o₁.blsub f) (o₂.blsub fun a h => f a ⋯)","decl":"@[congr]\ntheorem blsub_congr {o₁ o₂ : Ordinal.{u}} (f : ∀ a < o₁, Ordinal.{max u v}) (ho : o₁ = o₂) :\n    blsub.{_, v} o₁ f = blsub.{_, v} o₂ fun a h => f a (h.trans_eq ho.symm) := by\n  subst ho\n  -- Porting note: `rfl` is required.\n  rfl\n\n"}
{"name":"Ordinal.blsub_le_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LE.le (o.blsub f) a) (∀ (i : Ordinal.{u}) (h : LT.lt i o), LT.lt (f i h) a)","decl":"theorem blsub_le_iff {o : Ordinal.{u}} {f : ∀ a < o, Ordinal.{max u v}} {a} :\n    blsub.{_, v} o f ≤ a ↔ ∀ i h, f i h < a := by\n  convert bsup_le_iff.{_, v} (f := fun a ha => succ (f a ha)) (a := a) using 2\n  simp_rw [succ_le_iff]\n\n"}
{"name":"Ordinal.blsub_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (b : Ordinal.{u_4}) → LT.lt b o → Ordinal.{max u_4 u_5}\na : Ordinal.{max u_4 u_5}\na✝ : ∀ (i : Ordinal.{u_4}) (h : LT.lt i o), LT.lt (f i h) a\n⊢ LE.le (o.blsub f) a","decl":"theorem blsub_le {o : Ordinal} {f : ∀ b < o, Ordinal} {a} : (∀ i h, f i h < a) → blsub o f ≤ a :=\n  blsub_le_iff.2\n\n"}
{"name":"Ordinal.lt_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_5 u_4}\ni : Ordinal.{u_4}\nh : LT.lt i o\n⊢ LT.lt (f i h) (o.blsub f)","decl":"theorem lt_blsub {o} (f : ∀ a < o, Ordinal) (i h) : f i h < blsub o f :=\n  blsub_le_iff.1 le_rfl _ _\n\n"}
{"name":"Ordinal.lt_blsub_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (b : Ordinal.{u}) → LT.lt b o → Ordinal.{max u v}\na : Ordinal.{max u v}\n⊢ Iff (LT.lt a (o.blsub f)) (Exists fun i => Exists fun hi => LE.le a (f i hi))","decl":"theorem lt_blsub_iff {o : Ordinal.{u}} {f : ∀ b < o, Ordinal.{max u v}} {a} :\n    a < blsub.{_, v} o f ↔ ∃ i hi, a ≤ f i hi := by\n  simpa only [not_forall, not_lt, not_le] using not_congr (@blsub_le_iff.{_, v} _ f a)\n\n"}
{"name":"Ordinal.bsup_le_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ LE.le (o.bsup f) (o.blsub f)","decl":"theorem bsup_le_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f ≤ blsub.{_, v} o f :=\n  bsup_le fun i h => (lt_blsub f i h).le\n\n"}
{"name":"Ordinal.blsub_le_bsup_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ LE.le (o.blsub f) (Order.succ (o.bsup f))","decl":"theorem blsub_le_bsup_succ {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    blsub.{_, v} o f ≤ succ (bsup.{_, v} o f) :=\n  blsub_le fun i h => lt_succ_iff.2 (le_bsup f i h)\n\n"}
{"name":"Ordinal.bsup_eq_blsub_or_succ_bsup_eq_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Or (Eq (o.bsup f) (o.blsub f)) (Eq (Order.succ (o.bsup f)) (o.blsub f))","decl":"theorem bsup_eq_blsub_or_succ_bsup_eq_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f ∨ succ (bsup.{_, v} o f) = blsub.{_, v} o f := by\n  rw [← sup_eq_bsup, ← lsub_eq_blsub]\n  exact sup_eq_lsub_or_sup_succ_eq_lsub _\n\n"}
{"name":"Ordinal.bsup_succ_le_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Iff (LE.le (Order.succ (o.bsup f)) (o.blsub f)) (Exists fun i => Exists fun hi => Eq (f i hi) (o.bsup f))","decl":"theorem bsup_succ_le_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    succ (bsup.{_, v} o f) ≤ blsub.{_, v} o f ↔ ∃ i hi, f i hi = bsup.{_, v} o f := by\n  refine ⟨fun h => ?_, ?_⟩\n  · by_contra! hf\n    exact\n      ne_of_lt (succ_le_iff.1 h)\n        (le_antisymm (bsup_le_blsub f) (blsub_le (lt_bsup_of_ne_bsup.1 hf)))\n  rintro ⟨_, _, hf⟩\n  rw [succ_le_iff, ← hf]\n  exact lt_blsub _ _ _\n\n"}
{"name":"Ordinal.bsup_succ_eq_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Iff (Eq (Order.succ (o.bsup f)) (o.blsub f)) (Exists fun i => Exists fun hi => Eq (f i hi) (o.bsup f))","decl":"theorem bsup_succ_eq_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    succ (bsup.{_, v} o f) = blsub.{_, v} o f ↔ ∃ i hi, f i hi = bsup.{_, v} o f :=\n  (blsub_le_bsup_succ f).le_iff_eq.symm.trans (bsup_succ_le_blsub f)\n\n"}
{"name":"Ordinal.bsup_eq_blsub_iff_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Iff (Eq (o.bsup f) (o.blsub f)) (∀ (a : Ordinal.{max u v}), LT.lt a (o.blsub f) → LT.lt (Order.succ a) (o.blsub f))","decl":"theorem bsup_eq_blsub_iff_succ {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f ↔ ∀ a < blsub.{_, v} o f, succ a < blsub.{_, v} o f := by\n  rw [← sup_eq_bsup, ← lsub_eq_blsub]\n  apply sup_eq_lsub_iff_succ\n\n"}
{"name":"Ordinal.bsup_eq_blsub_iff_lt_bsup","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ Iff (Eq (o.bsup f) (o.blsub f)) (∀ (i : Ordinal.{u}) (hi : LT.lt i o), LT.lt (f i hi) (o.bsup f))","decl":"theorem bsup_eq_blsub_iff_lt_bsup {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f ↔ ∀ i hi, f i hi < bsup.{_, v} o f :=\n  ⟨fun h i => by\n    rw [h]\n    apply lt_blsub, fun h => le_antisymm (bsup_le_blsub f) (blsub_le h)⟩\n\n"}
{"name":"Ordinal.bsup_eq_blsub_of_lt_succ_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nho : o.IsLimit\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\nhf : ∀ (a : Ordinal.{u}) (ha : LT.lt a o), LT.lt (f a ha) (f (Order.succ a) ⋯)\n⊢ Eq (o.bsup f) (o.blsub f)","decl":"theorem bsup_eq_blsub_of_lt_succ_limit {o : Ordinal.{u}} (ho : IsLimit o)\n    {f : ∀ a < o, Ordinal.{max u v}} (hf : ∀ a ha, f a ha < f (succ a) (ho.succ_lt ha)) :\n    bsup.{_, v} o f = blsub.{_, v} o f := by\n  rw [bsup_eq_blsub_iff_lt_bsup]\n  exact fun i hi => (hf i hi).trans_le (le_bsup f _ _)\n\n"}
{"name":"Ordinal.blsub_succ_of_mono","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a (Order.succ o) → Ordinal.{max u v}\nhf : ∀ {i j : Ordinal.{u}} (hi : LT.lt i (Order.succ o)) (hj : LT.lt j (Order.succ o)), LE.le i j → LE.le (f i hi) (f j hj)\n⊢ Eq ((Order.succ o).blsub f) (Order.succ (f o ⋯))","decl":"theorem blsub_succ_of_mono {o : Ordinal.{u}} {f : ∀ a < succ o, Ordinal.{max u v}}\n    (hf : ∀ {i j} (hi hj), i ≤ j → f i hi ≤ f j hj) : blsub.{_, v} _ f = succ (f o (lt_succ o)) :=\n  bsup_succ_of_mono fun {_ _} hi hj h => succ_le_succ (hf hi hj h)\n\n"}
{"name":"Ordinal.blsub_eq_zero_iff","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_5 u_4}\n⊢ Iff (Eq (o.blsub f) 0) (Eq o 0)","decl":"@[simp]\ntheorem blsub_eq_zero_iff {o} {f : ∀ a < o, Ordinal} : blsub o f = 0 ↔ o = 0 := by\n  rw [← lsub_eq_blsub, lsub_eq_zero_iff]\n  exact toType_empty_iff_eq_zero\n\n-- Porting note: `rwa` → `rw`\n"}
{"name":"Ordinal.blsub_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : (a : Ordinal.{u_4}) → LT.lt a 0 → Ordinal.{max u_4 u_5}\n⊢ Eq (Ordinal.blsub 0 f) 0","decl":"@[simp]\ntheorem blsub_zero (f : ∀ a < (0 : Ordinal), Ordinal) : blsub 0 f = 0 := by rw [blsub_eq_zero_iff]\n\n"}
{"name":"Ordinal.blsub_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nho : LT.lt 0 o\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\n⊢ LT.lt 0 (o.blsub f)","decl":"theorem blsub_pos {o : Ordinal} (ho : 0 < o) (f : ∀ a < o, Ordinal) : 0 < blsub o f :=\n  (Ordinal.zero_le _).trans_lt (lt_blsub f 0 ho)\n\n"}
{"name":"Ordinal.blsub_type","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\nf : (a : Ordinal.{u}) → LT.lt a (Ordinal.type r) → Ordinal.{max u v}\n⊢ Eq ((Ordinal.type r).blsub f) (Ordinal.lsub fun a => f ((Ordinal.typein r).toRelEmbedding a) ⋯)","decl":"theorem blsub_type {α : Type u} (r : α → α → Prop) [IsWellOrder α r]\n    (f : ∀ a < type r, Ordinal.{max u v}) :\n    blsub.{_, v} (type r) f = lsub.{_, v} fun a => f (typein r a) (typein_lt_type _ _) :=\n  eq_of_forall_ge_iff fun o => by\n    rw [blsub_le_iff, lsub_le_iff]\n    exact ⟨fun H b => H _ _, fun H i h => by simpa only [typein_enum] using H (enum r ⟨i, h⟩)⟩\n\n"}
{"name":"Ordinal.blsub_const","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nho : Ne o 0\na : Ordinal.{max u v}\n⊢ Eq (o.blsub fun x x => a) (Order.succ a)","decl":"theorem blsub_const {o : Ordinal} (ho : o ≠ 0) (a : Ordinal) :\n    (blsub.{u, v} o fun _ _ => a) = succ a :=\n  bsup_const.{u, v} ho (succ a)\n\n"}
{"name":"Ordinal.blsub_one","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : (a : Ordinal.{u_4}) → LT.lt a 1 → Ordinal.{max u_4 u_5}\n⊢ Eq (Ordinal.blsub 1 f) (Order.succ (f 0 ⋯))","decl":"@[simp]\ntheorem blsub_one (f : ∀ a < (1 : Ordinal), Ordinal) : blsub 1 f = succ (f 0 zero_lt_one) :=\n  bsup_one _\n\n"}
{"name":"Ordinal.blsub_id","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq (o.blsub fun x x_1 => x) o","decl":"@[simp]\ntheorem blsub_id : ∀ o, (blsub.{u, u} o fun x _ => x) = o :=\n  lsub_typein\n\n"}
{"name":"Ordinal.bsup_id_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\na✝ : ∀ (a : Ordinal.{u}), LT.lt a o → LT.lt (Order.succ a) o\n⊢ Eq (o.bsup fun x x_1 => x) o","decl":"theorem bsup_id_limit {o : Ordinal} : (∀ a < o, succ a < o) → (bsup.{u, u} o fun x _ => x) = o :=\n  sup_typein_limit\n\n"}
{"name":"Ordinal.bsup_id_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\n⊢ Eq ((Order.succ o).bsup fun x x_1 => x) o","decl":"@[simp]\ntheorem bsup_id_succ (o) : (bsup.{u, u} (succ o) fun x _ => x) = o :=\n  sup_typein_succ\n\n"}
{"name":"Ordinal.blsub_le_of_brange_subset","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\no' : Ordinal.{v}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max (max u v) w}\ng : (a : Ordinal.{v}) → LT.lt a o' → Ordinal.{max (max u v) w}\nh : HasSubset.Subset (o.brange f) (o'.brange g)\n⊢ LE.le (o.blsub f) (o'.blsub g)","decl":"theorem blsub_le_of_brange_subset {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal}\n    (h : brange o f ⊆ brange o' g) : blsub.{u, max v w} o f ≤ blsub.{v, max u w} o' g :=\n  bsup_le_of_brange_subset.{u, v, w} fun a ⟨b, hb, hb'⟩ => by\n    obtain ⟨c, hc, hc'⟩ := h ⟨b, hb, rfl⟩\n    simp_rw [← hc'] at hb'\n    exact ⟨c, hc, hb'⟩\n\n"}
{"name":"Ordinal.blsub_eq_of_brange_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\no' : Ordinal.{v}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max (max u v) w}\ng : (a : Ordinal.{v}) → LT.lt a o' → Ordinal.{max (max u v) w}\nh : Eq (setOf fun o_1 => Exists fun i => Exists fun hi => Eq (f i hi) o_1) (setOf fun o => Exists fun i => Exists fun hi => Eq (g i hi) o)\n⊢ Eq (o.blsub f) (o'.blsub g)","decl":"theorem blsub_eq_of_brange_eq {o o'} {f : ∀ a < o, Ordinal} {g : ∀ a < o', Ordinal}\n    (h : { o | ∃ i hi, f i hi = o } = { o | ∃ i hi, g i hi = o }) :\n    blsub.{u, max v w} o f = blsub.{v, max u w} o' g :=\n  (blsub_le_of_brange_subset.{u, v, w} h.le).antisymm (blsub_le_of_brange_subset.{v, u, w} h.ge)\n\n"}
{"name":"Ordinal.bsup_comp","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o o' : Ordinal.{max u v}\nf : (a : Ordinal.{max u v}) → LT.lt a o → Ordinal.{max u v w}\nhf : ∀ {i j : Ordinal.{max u v}} (hi : LT.lt i o) (hj : LT.lt j o), LE.le i j → LE.le (f i hi) (f j hj)\ng : (a : Ordinal.{max u v}) → LT.lt a o' → Ordinal.{max u v}\nhg : Eq (o'.blsub g) o\n⊢ Eq (o'.bsup fun a ha => f (g a ha) ⋯) (o.bsup f)","decl":"theorem bsup_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}\n    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}\n    (hg : blsub.{_, u} o' g = o) :\n    (bsup.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = bsup.{_, w} o f := by\n  apply le_antisymm <;> refine bsup_le fun i hi => ?_\n  · apply le_bsup\n  · rw [← hg, lt_blsub_iff] at hi\n    rcases hi with ⟨j, hj, hj'⟩\n    exact (hf _ _ hj').trans (le_bsup _ _ _)\n\n"}
{"name":"Ordinal.blsub_comp","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o o' : Ordinal.{max u v}\nf : (a : Ordinal.{max u v}) → LT.lt a o → Ordinal.{max u v w}\nhf : ∀ {i j : Ordinal.{max u v}} (hi : LT.lt i o) (hj : LT.lt j o), LE.le i j → LE.le (f i hi) (f j hj)\ng : (a : Ordinal.{max u v}) → LT.lt a o' → Ordinal.{max u v}\nhg : Eq (o'.blsub g) o\n⊢ Eq (o'.blsub fun a ha => f (g a ha) ⋯) (o.blsub f)","decl":"theorem blsub_comp {o o' : Ordinal.{max u v}} {f : ∀ a < o, Ordinal.{max u v w}}\n    (hf : ∀ {i j} (hi) (hj), i ≤ j → f i hi ≤ f j hj) {g : ∀ a < o', Ordinal.{max u v}}\n    (hg : blsub.{_, u} o' g = o) :\n    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [← hg]; apply lt_blsub)) = blsub.{_, w} o f :=\n  @bsup_comp.{u, v, w} o _ (fun a ha => succ (f a ha))\n    (fun {_ _} _ _ h => succ_le_succ_iff.2 (hf _ _ h)) g hg\n\n"}
{"name":"Ordinal.IsNormal.bsup_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{max u v}\nH : Ordinal.IsNormal f\no : Ordinal.{u}\nh : o.IsLimit\n⊢ Eq (o.bsup fun x x_1 => f x) (f o)","decl":"theorem IsNormal.bsup_eq {f : Ordinal.{u} → Ordinal.{max u v}} (H : IsNormal f) {o : Ordinal.{u}}\n    (h : IsLimit o) : (Ordinal.bsup.{_, v} o fun x _ => f x) = f o := by\n  rw [← IsNormal.bsup.{u, u, v} H (fun x _ => x) h.ne_bot, bsup_id_limit fun _ ↦ h.succ_lt]\n\n"}
{"name":"Ordinal.IsNormal.blsub_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{max u v}\nH : Ordinal.IsNormal f\no : Ordinal.{u}\nh : o.IsLimit\n⊢ Eq (o.blsub fun x x_1 => f x) (f o)","decl":"theorem IsNormal.blsub_eq {f : Ordinal.{u} → Ordinal.{max u v}} (H : IsNormal f) {o : Ordinal.{u}}\n    (h : IsLimit o) : (blsub.{_, v} o fun x _ => f x) = f o := by\n  rw [← IsNormal.bsup_eq.{u, v} H h, bsup_eq_blsub_of_lt_succ_limit h]\n  exact fun a _ => H.1 a\n\n"}
{"name":"Ordinal.isNormal_iff_lt_succ_and_bsup_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{max u v}\n⊢ Iff (Ordinal.IsNormal f) (And (∀ (a : Ordinal.{u}), LT.lt (f a) (f (Order.succ a))) (∀ (o : Ordinal.{u}), o.IsLimit → Eq (o.bsup fun x x_1 => f x) (f o)))","decl":"theorem isNormal_iff_lt_succ_and_bsup_eq {f : Ordinal.{u} → Ordinal.{max u v}} :\n    IsNormal f ↔ (∀ a, f a < f (succ a)) ∧ ∀ o, IsLimit o → (bsup.{_, v} o fun x _ => f x) = f o :=\n  ⟨fun h => ⟨h.1, @IsNormal.bsup_eq f h⟩, fun ⟨h₁, h₂⟩ =>\n    ⟨h₁, fun o ho a => by\n      rw [← h₂ o ho]\n      exact bsup_le_iff⟩⟩\n\n"}
{"name":"Ordinal.isNormal_iff_lt_succ_and_blsub_eq","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{max u v}\n⊢ Iff (Ordinal.IsNormal f) (And (∀ (a : Ordinal.{u}), LT.lt (f a) (f (Order.succ a))) (∀ (o : Ordinal.{u}), o.IsLimit → Eq (o.blsub fun x x_1 => f x) (f o)))","decl":"theorem isNormal_iff_lt_succ_and_blsub_eq {f : Ordinal.{u} → Ordinal.{max u v}} :\n    IsNormal f ↔ (∀ a, f a < f (succ a)) ∧\n      ∀ o, IsLimit o → (blsub.{_, v} o fun x _ => f x) = f o := by\n  rw [isNormal_iff_lt_succ_and_bsup_eq.{u, v}, and_congr_right_iff]\n  intro h\n  constructor <;> intro H o ho <;> have := H o ho <;>\n    rwa [← bsup_eq_blsub_of_lt_succ_limit ho fun a _ => h a] at *\n\n"}
{"name":"Ordinal.IsNormal.eq_iff_zero_and_succ","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f g : Ordinal.{u} → Ordinal.{u}\nhf : Ordinal.IsNormal f\nhg : Ordinal.IsNormal g\n⊢ Iff (Eq f g) (And (Eq (f 0) (g 0)) (∀ (a : Ordinal.{u}), Eq (f a) (g a) → Eq (f (Order.succ a)) (g (Order.succ a))))","decl":"theorem IsNormal.eq_iff_zero_and_succ {f g : Ordinal.{u} → Ordinal.{u}} (hf : IsNormal f)\n    (hg : IsNormal g) : f = g ↔ f 0 = g 0 ∧ ∀ a, f a = g a → f (succ a) = g (succ a) :=\n  ⟨fun h => by simp [h], fun ⟨h₁, h₂⟩ =>\n    funext fun a => by\n      induction a using limitRecOn with\n      | H₁ => solve_by_elim\n      | H₂ => solve_by_elim\n      | H₃ _ ho H =>\n        rw [← IsNormal.bsup_eq.{u, u} hf ho, ← IsNormal.bsup_eq.{u, u} hg ho]\n        congr\n        ext b hb\n        exact H b hb⟩\n\n"}
{"name":"Ordinal.lt_blsub₂","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o₁ : Ordinal.{u_4}\no₂ : Ordinal.{u_5}\nop : {a : Ordinal.{u_4}} → LT.lt a o₁ → {b : Ordinal.{u_5}} → LT.lt b o₂ → Ordinal.{max (max u_4 u_5) u_6}\na : Ordinal.{u_4}\nb : Ordinal.{u_5}\nha : LT.lt a o₁\nhb : LT.lt b o₂\n⊢ LT.lt (op ha hb) (o₁.blsub₂ o₂ fun {a} => op)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-11\")]\ntheorem lt_blsub₂ {o₁ o₂ : Ordinal}\n    (op : {a : Ordinal} → (a < o₁) → {b : Ordinal} → (b < o₂) → Ordinal) {a b : Ordinal}\n    (ha : a < o₁) (hb : b < o₂) : op ha hb < blsub₂ o₁ o₂ op := by\n  convert lt_lsub _ (Prod.mk (enum (· < ·) ⟨a, by rwa [type_lt]⟩)\n    (enum (· < ·) ⟨b, by rwa [type_lt]⟩))\n  simp only [typein_enum]\n\n"}
{"name":"Ordinal.mex_not_mem_range","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ Not (Membership.mem (Set.range f) (Ordinal.mex f))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem mex_not_mem_range {ι : Type u} (f : ι → Ordinal.{max u v}) : mex.{_, v} f ∉ Set.range f :=\n  csInf_mem (nonempty_compl_range.{_, v} f)\n\n"}
{"name":"Ordinal.le_mex_of_forall","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\na : Ordinal.{max u v}\nH : ∀ (b : Ordinal.{max u v}), LT.lt b a → Exists fun i => Eq (f i) b\n⊢ LE.le a (Ordinal.mex f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem le_mex_of_forall {ι : Type u} {f : ι → Ordinal.{max u v}} {a : Ordinal}\n    (H : ∀ b < a, ∃ i, f i = b) : a ≤ mex.{_, v} f := by\n  by_contra! h\n  exact mex_not_mem_range f (H _ h)\n\n"}
{"name":"Ordinal.ne_mex","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\ni : ι\n⊢ Ne (f i) (Ordinal.mex f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem ne_mex {ι : Type u} (f : ι → Ordinal.{max u v}) : ∀ i, f i ≠ mex.{_, v} f := by\n  simpa using mex_not_mem_range.{_, v} f\n\n"}
{"name":"Ordinal.mex_le_of_ne","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{max u_5 u_4}\na : Ordinal.{max u_5 u_4}\nha : ∀ (i : ι), Ne (f i) a\n⊢ LE.le (Ordinal.mex f) a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem mex_le_of_ne {ι} {f : ι → Ordinal} {a} (ha : ∀ i, f i ≠ a) : mex f ≤ a :=\n  csInf_le' (by simp [ha])\n\n"}
{"name":"Ordinal.exists_of_lt_mex","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u_4\nf : ι → Ordinal.{max u_5 u_4}\na : Ordinal.{max u_4 u_5}\nha : LT.lt a (Ordinal.mex f)\n⊢ Exists fun i => Eq (f i) a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem exists_of_lt_mex {ι} {f : ι → Ordinal} {a} (ha : a < mex f) : ∃ i, f i = a := by\n  by_contra! ha'\n  exact ha.not_le (mex_le_of_ne ha')\n\n"}
{"name":"Ordinal.mex_le_lsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{max u v}\n⊢ LE.le (Ordinal.mex f) (Ordinal.lsub f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem mex_le_lsub {ι : Type u} (f : ι → Ordinal.{max u v}) : mex.{_, v} f ≤ lsub.{_, v} f :=\n  csInf_le' (lsub_not_mem_range f)\n\n"}
{"name":"Ordinal.mex_monotone","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α β : Type u\nf : α → Ordinal.{max u v}\ng : β → Ordinal.{max u v}\nh : HasSubset.Subset (Set.range f) (Set.range g)\n⊢ LE.le (Ordinal.mex f) (Ordinal.mex g)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem mex_monotone {α β : Type u} {f : α → Ordinal.{max u v}} {g : β → Ordinal.{max u v}}\n    (h : Set.range f ⊆ Set.range g) : mex.{_, v} f ≤ mex.{_, v} g := by\n  refine mex_le_of_ne fun i hi => ?_\n  cases' h ⟨i, rfl⟩ with j hj\n  rw [← hj] at hi\n  exact ne_mex g j hi\n\n"}
{"name":"Ordinal.mex_lt_ord_succ_mk","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"ι : Type u\nf : ι → Ordinal.{u}\n⊢ LT.lt (Ordinal.mex f) (Order.succ (Cardinal.mk ι)).ord","decl":"set_option linter.deprecated false in\n@[deprecated sInf_compl_lt_ord_succ (since := \"2024-09-20\")]\ntheorem mex_lt_ord_succ_mk {ι : Type u} (f : ι → Ordinal.{u}) :\n    mex.{_, u} f < (succ #ι).ord := by\n  by_contra! h\n  apply (lt_succ #ι).not_le\n  have H := fun a => exists_of_lt_mex ((typein_lt_self a).trans_le h)\n  let g : (succ #ι).ord.toType → ι := fun a => Classical.choose (H a)\n  have hg : Injective g := fun a b h' => by\n    have Hf : ∀ x, f (g x) =\n        typein ((· < ·) : (succ #ι).ord.toType → (succ #ι).ord.toType → Prop) x :=\n      fun a => Classical.choose_spec (H a)\n    apply_fun f at h'\n    rwa [Hf, Hf, typein_inj] at h'\n  convert Cardinal.mk_le_of_injective hg\n  rw [Cardinal.mk_ord_toType (succ #ι)]\n\n"}
{"name":"Ordinal.bmex_not_mem_brange","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\n⊢ Not (Membership.mem (o.brange f) (o.bmex f))","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem bmex_not_mem_brange {o : Ordinal} (f : ∀ a < o, Ordinal) : bmex o f ∉ brange o f := by\n  rw [← range_familyOfBFamily]\n  apply mex_not_mem_range\n\n"}
{"name":"Ordinal.le_bmex_of_forall","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\na : Ordinal.{max u_4 u_5}\nH : ∀ (b : Ordinal.{max u_4 u_5}), LT.lt b a → Exists fun i => Exists fun hi => Eq (f i hi) b\n⊢ LE.le a (o.bmex f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem le_bmex_of_forall {o : Ordinal} (f : ∀ a < o, Ordinal) {a : Ordinal}\n    (H : ∀ b < a, ∃ i hi, f i hi = b) : a ≤ bmex o f := by\n  by_contra! h\n  exact bmex_not_mem_brange f (H _ h)\n\n"}
{"name":"Ordinal.ne_bmex","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\ni : Ordinal.{u}\nhi : LT.lt i o\n⊢ Ne (f i hi) (o.bmex f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem ne_bmex {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) {i} (hi) :\n    f i hi ≠ bmex.{_, v} o f := by\n  convert (config := {transparency := .default})\n    ne_mex.{_, v} (familyOfBFamily o f) (enum (α := o.toType) (· < ·) ⟨i, by rwa [type_lt]⟩) using 2\n  -- Porting note: `familyOfBFamily_enum` → `typein_enum`\n  rw [typein_enum]\n\n"}
{"name":"Ordinal.bmex_le_of_ne","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\na : Ordinal.{max u_4 u_5}\nha : ∀ (i : Ordinal.{u_4}) (hi : LT.lt i o), Ne (f i hi) a\n⊢ LE.le (o.bmex f) a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem bmex_le_of_ne {o : Ordinal} {f : ∀ a < o, Ordinal} {a} (ha : ∀ i hi, f i hi ≠ a) :\n    bmex o f ≤ a :=\n  mex_le_of_ne fun _i => ha _ _\n\n"}
{"name":"Ordinal.exists_of_lt_bmex","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_4}\nf : (a : Ordinal.{u_4}) → LT.lt a o → Ordinal.{max u_4 u_5}\na : Ordinal.{max u_5 u_4}\nha : LT.lt a (o.bmex f)\n⊢ Exists fun i => Exists fun hi => Eq (f i hi) a","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem exists_of_lt_bmex {o : Ordinal} {f : ∀ a < o, Ordinal} {a} (ha : a < bmex o f) :\n    ∃ i hi, f i hi = a := by\n  cases' exists_of_lt_mex ha with i hi\n  exact ⟨_, typein_lt_self i, hi⟩\n\n"}
{"name":"Ordinal.bmex_le_blsub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\n⊢ LE.le (o.bmex f) (o.blsub f)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem bmex_le_blsub {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{max u v}) :\n    bmex.{_, v} o f ≤ blsub.{_, v} o f :=\n  mex_le_lsub _\n\n"}
{"name":"Ordinal.bmex_monotone","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o o' : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{max u v}\ng : (a : Ordinal.{u}) → LT.lt a o' → Ordinal.{max u v}\nh : HasSubset.Subset (o.brange f) (o'.brange g)\n⊢ LE.le (o.bmex f) (o'.bmex g)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-20\")]\ntheorem bmex_monotone {o o' : Ordinal.{u}}\n    {f : ∀ a < o, Ordinal.{max u v}} {g : ∀ a < o', Ordinal.{max u v}}\n    (h : brange o f ⊆ brange o' g) : bmex.{_, v} o f ≤ bmex.{_, v} o' g :=\n  mex_monotone (by rwa [range_familyOfBFamily, range_familyOfBFamily])\n\n"}
{"name":"Ordinal.bmex_lt_ord_succ_card","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u}\nf : (a : Ordinal.{u}) → LT.lt a o → Ordinal.{u}\n⊢ LT.lt (o.bmex f) (Order.succ o.card).ord","decl":"set_option linter.deprecated false in\n@[deprecated sInf_compl_lt_ord_succ (since := \"2024-09-20\")]\ntheorem bmex_lt_ord_succ_card {o : Ordinal.{u}} (f : ∀ a < o, Ordinal.{u}) :\n    bmex.{_, u} o f < (succ o.card).ord := by\n  rw [← mk_toType]\n  exact mex_lt_ord_succ_mk (familyOfBFamily o f)\n\n"}
{"name":"not_surjective_of_ordinal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u\nf : α → Ordinal.{u}\n⊢ Not (Function.Surjective f)","decl":"theorem not_surjective_of_ordinal {α : Type u} (f : α → Ordinal.{u}) : ¬Surjective f := fun h =>\n  Ordinal.lsub_not_mem_range.{u, u} f (h _)\n\n"}
{"name":"not_injective_of_ordinal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type u\nf : Ordinal.{u} → α\n⊢ Not (Function.Injective f)","decl":"theorem not_injective_of_ordinal {α : Type u} (f : Ordinal.{u} → α) : ¬Injective f := fun h =>\n  not_surjective_of_ordinal _ (invFun_surjective h)\n\n"}
{"name":"not_surjective_of_ordinal_of_small","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type v\ninst✝ : Small.{u, v} α\nf : α → Ordinal.{u}\n⊢ Not (Function.Surjective f)","decl":"theorem not_surjective_of_ordinal_of_small {α : Type v} [Small.{u} α] (f : α → Ordinal.{u}) :\n    ¬Surjective f := fun h => not_surjective_of_ordinal _ (h.comp (equivShrink _).symm.surjective)\n\n"}
{"name":"not_injective_of_ordinal_of_small","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"α : Type v\ninst✝ : Small.{u, v} α\nf : Ordinal.{u} → α\n⊢ Not (Function.Injective f)","decl":"theorem not_injective_of_ordinal_of_small {α : Type v} [Small.{u} α] (f : Ordinal.{u} → α) :\n    ¬Injective f := fun h => not_injective_of_ordinal _ ((equivShrink _).injective.comp h)\n\n"}
{"name":"not_small_ordinal","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Not (Small.{u, max (u + 1) (v + 1)} Ordinal.{max u v})","decl":"/-- The type of ordinals in universe `u` is not `Small.{u}`. This is the type-theoretic analog of\nthe Burali-Forti paradox. -/\ntheorem not_small_ordinal : ¬Small.{u} Ordinal.{max u v} := fun h =>\n  @not_injective_of_ordinal_of_small _ h _ fun _a _b => Ordinal.lift_inj.{v, u}.1\n\n"}
{"name":"Ordinal.not_bddAbove_compl_of_small","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"s : Set Ordinal.{u}\nhs : Small.{u, u + 1} ↑s\n⊢ Not (BddAbove (HasCompl.compl s))","decl":"theorem Ordinal.not_bddAbove_compl_of_small (s : Set Ordinal.{u}) [hs : Small.{u} s] :\n    ¬BddAbove sᶜ := by\n  rw [bddAbove_iff_small]\n  intro h\n  have := small_union s sᶜ\n  rw [union_compl_self, small_univ_iff] at this\n  exact not_small_ordinal this\n\n"}
{"name":"Ordinal.instCharZero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ CharZero Ordinal.{u_1}","decl":"instance instCharZero : CharZero Ordinal := by\n  refine ⟨fun a b h ↦ ?_⟩\n  rwa [← Cardinal.ord_nat, ← Cardinal.ord_nat, Cardinal.ord_inj, Nat.cast_inj] at h\n\n"}
{"name":"Ordinal.one_add_natCast","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m : Nat\n⊢ Eq (HAdd.hAdd 1 ↑m) ↑(Order.succ m)","decl":"@[simp]\ntheorem one_add_natCast (m : ℕ) : 1 + (m : Ordinal) = succ m := by\n  rw [← Nat.cast_one, ← Nat.cast_add, add_comm]\n  rfl\n\n"}
{"name":"Ordinal.one_add_ofNat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m : Nat\ninst✝ : m.AtLeastTwo\n⊢ Eq (HAdd.hAdd 1 (OfNat.ofNat m)) (Order.succ (OfNat.ofNat m))","decl":"@[simp]\ntheorem one_add_ofNat (m : ℕ) [m.AtLeastTwo] :\n    1 + (ofNat(m) : Ordinal) = Order.succ (OfNat.ofNat m : Ordinal) :=\n  one_add_natCast m\n\n"}
{"name":"Ordinal.natCast_mul","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_mul (m : ℕ) : ∀ n : ℕ, ((m * n : ℕ) : Ordinal) = m * n\n  | 0 => by simp\n  | n + 1 => by rw [Nat.mul_succ, Nat.cast_add, natCast_mul m n, Nat.cast_succ, mul_add_one]\n\n"}
{"name":"Ordinal.natCast_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[deprecated Nat.cast_le (since := \"2024-10-17\")]\ntheorem natCast_le {m n : ℕ} : (m : Ordinal) ≤ n ↔ m ≤ n := Nat.cast_le\n\n"}
{"name":"Ordinal.natCast_inj","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[deprecated Nat.cast_inj (since := \"2024-10-17\")]\ntheorem natCast_inj {m n : ℕ} : (m : Ordinal) = n ↔ m = n := Nat.cast_inj\n\n"}
{"name":"Ordinal.natCast_lt","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[deprecated Nat.cast_lt (since := \"2024-10-17\")]\ntheorem natCast_lt {m n : ℕ} : (m : Ordinal) < n ↔ m < n := Nat.cast_lt\n\n"}
{"name":"Ordinal.natCast_eq_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ Iff (Eq (↑n) 0) (Eq n 0)","decl":"@[deprecated Nat.cast_eq_zero (since := \"2024-10-17\")]\ntheorem natCast_eq_zero {n : ℕ} : (n : Ordinal) = 0 ↔ n = 0 := Nat.cast_eq_zero\n\n"}
{"name":"Ordinal.natCast_ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ Iff (Ne (↑n) 0) (Ne n 0)","decl":"@[deprecated Nat.cast_ne_zero (since := \"2024-10-17\")]\ntheorem natCast_ne_zero {n : ℕ} : (n : Ordinal) ≠ 0 ↔ n ≠ 0 := Nat.cast_ne_zero\n\n"}
{"name":"Ordinal.natCast_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 ↑n) (LT.lt 0 n)","decl":"@[deprecated Nat.cast_pos' (since := \"2024-10-17\")]\ntheorem natCast_pos {n : ℕ} : (0 : Ordinal) < n ↔ 0 < n := Nat.cast_pos'\n\n"}
{"name":"Ordinal.natCast_sub","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_sub (m n : ℕ) : ((m - n : ℕ) : Ordinal) = m - n := by\n  rcases le_total m n with h | h\n  · rw [tsub_eq_zero_iff_le.2 h, Ordinal.sub_eq_zero_iff_le.2 (Nat.cast_le.2 h), Nat.cast_zero]\n  · rw [← add_left_cancel_iff (a := ↑n), ← Nat.cast_add, add_tsub_cancel_of_le h,\n      Ordinal.add_sub_cancel_of_le (Nat.cast_le.2 h)]\n\n"}
{"name":"Ordinal.natCast_div","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Eq (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_div (m n : ℕ) : ((m / n : ℕ) : Ordinal) = m / n := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp\n  · have hn' : (n : Ordinal) ≠ 0 := Nat.cast_ne_zero.2 hn\n    apply le_antisymm\n    · rw [le_div hn', ← natCast_mul, Nat.cast_le, mul_comm]\n      apply Nat.div_mul_le_self\n    · rw [div_le hn', ← add_one_eq_succ, ← Nat.cast_succ, ← natCast_mul, Nat.cast_lt, mul_comm,\n        ← Nat.div_lt_iff_lt_mul (Nat.pos_of_ne_zero hn)]\n      apply Nat.lt_succ_self\n\n"}
{"name":"Ordinal.natCast_mod","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"m n : Nat\n⊢ Eq (↑(HMod.hMod m n)) (HMod.hMod ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_mod (m n : ℕ) : ((m % n : ℕ) : Ordinal) = m % n := by\n  rw [← add_left_cancel_iff, div_add_mod, ← natCast_div, ← natCast_mul, ← Nat.cast_add,\n    Nat.div_add_mod]\n\n"}
{"name":"Ordinal.lift_natCast","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ Eq (Ordinal.lift.{u, v} ↑n) ↑n","decl":"@[simp]\ntheorem lift_natCast : ∀ n : ℕ, lift.{u, v} n = n\n  | 0 => by simp\n  | n + 1 => by simp [lift_natCast n]\n\n"}
{"name":"Ordinal.lift_ofNat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (Ordinal.lift.{u, v} (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem lift_ofNat (n : ℕ) [n.AtLeastTwo] :\n    lift.{u, v} ofNat(n) = OfNat.ofNat n :=\n  lift_natCast n\n\n"}
{"name":"Ordinal.lt_add_of_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a b c : Ordinal.{u}\nh : c.IsLimit\n⊢ Iff (LT.lt a (HAdd.hAdd b c)) (Exists fun c' => And (LT.lt c' c) (LT.lt a (HAdd.hAdd b c')))","decl":"theorem lt_add_of_limit {a b c : Ordinal.{u}} (h : IsLimit c) :\n    a < b + c ↔ ∃ c' < c, a < b + c' := by\n  -- Porting note: `bex_def` is required.\n  rw [← IsNormal.bsup_eq.{u, u} (isNormal_add_right b) h, lt_bsup, bex_def]\n\n"}
{"name":"Ordinal.lt_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt o Ordinal.omega0) (Exists fun n => Eq o ↑n)","decl":"theorem lt_omega0 {o : Ordinal} : o < ω ↔ ∃ n : ℕ, o = n := by\n  simp_rw [← Cardinal.ord_aleph0, Cardinal.lt_ord, lt_aleph0, card_eq_nat]\n\n"}
{"name":"Ordinal.lt_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LT.lt o Ordinal.omega0) (Exists fun n => Eq o ↑n)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias lt_omega := lt_omega0\n\n"}
{"name":"Ordinal.nat_lt_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ LT.lt (↑n) Ordinal.omega0","decl":"theorem nat_lt_omega0 (n : ℕ) : ↑n < ω :=\n  lt_omega0.2 ⟨_, rfl⟩\n\n"}
{"name":"Ordinal.nat_lt_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ LT.lt (↑n) Ordinal.omega0","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias nat_lt_omega := nat_lt_omega0\n\n"}
{"name":"Ordinal.eq_nat_or_omega0_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Or (Exists fun n => Eq o ↑n) (LE.le Ordinal.omega0 o)","decl":"theorem eq_nat_or_omega0_le (o : Ordinal) : (∃ n : ℕ, o = n) ∨ ω ≤ o := by\n  obtain ho | ho := lt_or_le o ω\n  · exact Or.inl <| lt_omega0.1 ho\n  · exact Or.inr ho\n\n"}
{"name":"Ordinal.omega0_pos","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ LT.lt 0 Ordinal.omega0","decl":"theorem omega0_pos : 0 < ω :=\n  nat_lt_omega0 0\n\n"}
{"name":"Ordinal.omega0_ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ne Ordinal.omega0 0","decl":"theorem omega0_ne_zero : ω ≠ 0 :=\n  omega0_pos.ne'\n\n"}
{"name":"Ordinal.omega_ne_zero","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ne Ordinal.omega0 0","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias omega_ne_zero := omega0_ne_zero\n\n"}
{"name":"Ordinal.one_lt_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ LT.lt 1 Ordinal.omega0","decl":"theorem one_lt_omega0 : 1 < ω := by simpa only [Nat.cast_one] using nat_lt_omega0 1\n\n"}
{"name":"Ordinal.one_lt_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ LT.lt 1 Ordinal.omega0","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias one_lt_omega := one_lt_omega0\n\n"}
{"name":"Ordinal.isLimit_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ordinal.omega0.IsLimit","decl":"theorem isLimit_omega0 : IsLimit ω := by\n  rw [isLimit_iff, isSuccPrelimit_iff_succ_lt]\n  refine ⟨omega0_ne_zero, fun o h => ?_⟩\n  obtain ⟨n, rfl⟩ := lt_omega0.1 h\n  exact nat_lt_omega0 (n + 1)\n\n"}
{"name":"Ordinal.omega0_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ordinal.omega0.IsLimit","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\nalias omega0_isLimit := isLimit_omega0\n\n"}
{"name":"Ordinal.omega_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Ordinal.omega0.IsLimit","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias omega_isLimit := isLimit_omega0\n\n"}
{"name":"Ordinal.omega0_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Ordinal.omega0 o) (∀ (n : Nat), LE.le (↑n) o)","decl":"theorem omega0_le {o : Ordinal} : ω ≤ o ↔ ∀ n : ℕ, ↑n ≤ o :=\n  ⟨fun h n => (nat_lt_omega0 _).le.trans h, fun H =>\n    le_of_forall_lt fun a h => by\n      let ⟨n, e⟩ := lt_omega0.1 h\n      rw [e, ← succ_le_iff]; exact H (n + 1)⟩\n\n"}
{"name":"Ordinal.omega_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Iff (LE.le Ordinal.omega0 o) (∀ (n : Nat), LE.le (↑n) o)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias omega_le := omega0_le\n\n"}
{"name":"Ordinal.iSup_natCast","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Eq (iSup Nat.cast) Ordinal.omega0","decl":"@[simp]\ntheorem iSup_natCast : iSup Nat.cast = ω :=\n  (Ordinal.iSup_le fun n => (nat_lt_omega0 n).le).antisymm <| omega0_le.2 <| Ordinal.le_iSup _\n\n"}
{"name":"Ordinal.nat_lt_limit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsLimit\nn : Nat\n⊢ LT.lt (↑n) o","decl":"theorem nat_lt_limit {o} (h : IsLimit o) : ∀ n : ℕ, ↑n < o\n  | 0 => h.pos\n  | n + 1 => h.succ_lt (nat_lt_limit h n)\n\n"}
{"name":"Ordinal.omega0_le_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsLimit\n⊢ LE.le Ordinal.omega0 o","decl":"theorem omega0_le_of_isLimit {o} (h : IsLimit o) : ω ≤ o :=\n  omega0_le.2 fun n => le_of_lt <| nat_lt_limit h n\n\n"}
{"name":"Ordinal.omega_le_of_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : o.IsLimit\n⊢ LE.le Ordinal.omega0 o","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias omega_le_of_isLimit := omega0_le_of_isLimit\n\n"}
{"name":"Ordinal.natCast_add_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (↑n) Ordinal.omega0) Ordinal.omega0","decl":"theorem natCast_add_omega0 (n : ℕ) : n + ω = ω := by\n  refine le_antisymm (le_of_forall_lt fun a ha ↦ ?_) (le_add_left _ _)\n  obtain ⟨b, hb', hb⟩ := (lt_add_iff omega0_ne_zero).1 ha\n  obtain ⟨m, rfl⟩ := lt_omega0.1 hb'\n  apply hb.trans_lt\n  exact_mod_cast nat_lt_omega0 (n + m)\n\n"}
{"name":"Ordinal.one_add_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Eq (HAdd.hAdd 1 Ordinal.omega0) Ordinal.omega0","decl":"theorem one_add_omega0 : 1 + ω = ω :=\n  mod_cast natCast_add_omega0 1\n\n"}
{"name":"Ordinal.one_add_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"⊢ Eq (HAdd.hAdd 1 Ordinal.omega0) Ordinal.omega0","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias one_add_omega := one_add_omega0\n\n"}
{"name":"Ordinal.add_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\nh : LT.lt a Ordinal.omega0\n⊢ Eq (HAdd.hAdd a Ordinal.omega0) Ordinal.omega0","decl":"theorem add_omega0 {a : Ordinal} (h : a < ω) : a + ω = ω := by\n  obtain ⟨n, rfl⟩ := lt_omega0.1 h\n  exact natCast_add_omega0 n\n\n"}
{"name":"Ordinal.add_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\nh : LT.lt a Ordinal.omega0\n⊢ Eq (HAdd.hAdd a Ordinal.omega0) Ordinal.omega0","decl":"@[deprecated (since := \"2024-09-30\")]\nalias add_omega := add_omega0\n\n"}
{"name":"Ordinal.natCast_add_of_omega0_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : LE.le Ordinal.omega0 o\nn : Nat\n⊢ Eq (HAdd.hAdd (↑n) o) o","decl":"@[simp]\ntheorem natCast_add_of_omega0_le {o} (h : ω ≤ o) (n : ℕ) : n + o = o := by\n  rw [← Ordinal.add_sub_cancel_of_le h, ← add_assoc, natCast_add_omega0]\n\n"}
{"name":"Ordinal.one_add_of_omega0_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : LE.le Ordinal.omega0 o\n⊢ Eq (HAdd.hAdd 1 o) o","decl":"@[simp]\ntheorem one_add_of_omega0_le {o} (h : ω ≤ o) : 1 + o = o :=\n  mod_cast natCast_add_of_omega0_le h 1\n\n"}
{"name":"Ordinal.one_add_of_omega_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\nh : LE.le Ordinal.omega0 o\n⊢ Eq (HAdd.hAdd 1 o) o","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias one_add_of_omega_le := one_add_of_omega0_le\n\n"}
{"name":"Ordinal.isLimit_iff_omega0_dvd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff a.IsLimit (And (Ne a 0) (Dvd.dvd Ordinal.omega0 a))","decl":"theorem isLimit_iff_omega0_dvd {a : Ordinal} : IsLimit a ↔ a ≠ 0 ∧ ω ∣ a := by\n  refine ⟨fun l => ⟨l.ne_zero, ⟨a / ω, le_antisymm ?_ (mul_div_le _ _)⟩⟩, fun h => ?_⟩\n  · refine (limit_le l).2 fun x hx => le_of_lt ?_\n    rw [← div_lt omega0_ne_zero, ← succ_le_iff, le_div omega0_ne_zero, mul_succ,\n      add_le_of_limit isLimit_omega0]\n    intro b hb\n    rcases lt_omega0.1 hb with ⟨n, rfl⟩\n    exact\n      (add_le_add_right (mul_div_le _ _) _).trans\n        (lt_sub.1 <| nat_lt_limit (isLimit_sub l hx) _).le\n  · rcases h with ⟨a0, b, rfl⟩\n    refine isLimit_mul_left isLimit_omega0 (Ordinal.pos_iff_ne_zero.2 <| mt ?_ a0)\n    intro e\n    simp only [e, mul_zero]\n\n"}
{"name":"Ordinal.isLimit_iff_omega_dvd","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff a.IsLimit (And (Ne a 0) (Dvd.dvd Ordinal.omega0 a))","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias isLimit_iff_omega_dvd := isLimit_iff_omega0_dvd\n\n"}
{"name":"Ordinal.IsNormal.apply_omega0","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nhf : Ordinal.IsNormal f\n⊢ Eq (iSup fun n => f ↑n) (f Ordinal.omega0)","decl":"theorem IsNormal.apply_omega0 {f : Ordinal.{u} → Ordinal.{v}} (hf : IsNormal f) :\n    ⨆ n : ℕ, f n = f ω := by rw [← iSup_natCast, hf.map_iSup]\n\n"}
{"name":"Ordinal.IsNormal.apply_omega","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"f : Ordinal.{u} → Ordinal.{v}\nhf : Ordinal.IsNormal f\n⊢ Eq (iSup fun n => f ↑n) (f Ordinal.omega0)","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-09-30\")]\nalias IsNormal.apply_omega := IsNormal.apply_omega0\n\n"}
{"name":"Ordinal.iSup_add_nat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (iSup fun n => HAdd.hAdd o ↑n) (HAdd.hAdd o Ordinal.omega0)","decl":"@[simp]\ntheorem iSup_add_nat (o : Ordinal) : ⨆ n : ℕ, o + n = o + ω :=\n  (isNormal_add_right o).apply_omega0\n\n"}
{"name":"Ordinal.sup_add_nat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.sup fun n => HAdd.hAdd o ↑n) (HAdd.hAdd o Ordinal.omega0)","decl":"set_option linter.deprecated false in\n@[deprecated iSup_add_nat (since := \"2024-08-27\")]\ntheorem sup_add_nat (o : Ordinal) : (sup fun n : ℕ => o + n) = o + ω :=\n  (isNormal_add_right o).apply_omega0\n\n"}
{"name":"Ordinal.iSup_mul_nat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (iSup fun n => HMul.hMul o ↑n) (HMul.hMul o Ordinal.omega0)","decl":"@[simp]\ntheorem iSup_mul_nat (o : Ordinal) : ⨆ n : ℕ, o * n = o * ω := by\n  rcases eq_zero_or_pos o with (rfl | ho)\n  · rw [zero_mul]\n    exact iSup_eq_zero_iff.2 fun n => zero_mul (n : Ordinal)\n  · exact (isNormal_mul_right ho).apply_omega0\n\n"}
{"name":"Ordinal.sup_mul_nat","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"o : Ordinal.{u_1}\n⊢ Eq (Ordinal.sup fun n => HMul.hMul o ↑n) (HMul.hMul o Ordinal.omega0)","decl":"set_option linter.deprecated false in\n@[deprecated iSup_add_nat (since := \"2024-08-27\")]\ntheorem sup_mul_nat (o : Ordinal) : (sup fun n : ℕ => o * n) = o * ω := by\n  rcases eq_zero_or_pos o with (rfl | ho)\n  · rw [zero_mul]\n    exact sup_eq_zero_iff.2 fun n => zero_mul (n : Ordinal)\n  · exact (mul_isNormal ho).apply_omega0\n\n"}
{"name":"Cardinal.add_one_of_aleph0_le","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ Eq (HAdd.hAdd c 1) c","decl":"@[simp]\ntheorem add_one_of_aleph0_le {c} (h : ℵ₀ ≤ c) : c + 1 = c := by\n  rw [add_comm, ← card_ord c, ← card_one, ← card_add, one_add_of_omega0_le]\n  rwa [← ord_aleph0, ord_le_ord]\n\n"}
{"name":"Cardinal.isLimit_ord","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nco : LE.le Cardinal.aleph0 c\n⊢ c.ord.IsLimit","decl":"theorem isLimit_ord {c} (co : ℵ₀ ≤ c) : (ord c).IsLimit := by\n  rw [isLimit_iff, isSuccPrelimit_iff_succ_lt]\n  refine ⟨fun h => aleph0_ne_zero ?_, fun a => lt_imp_lt_of_le_imp_le fun h => ?_⟩\n  · rw [← Ordinal.le_zero, ord_le] at h\n    simpa only [card_zero, nonpos_iff_eq_zero] using co.trans h\n  · rw [ord_le] at h ⊢\n    rwa [← @add_one_of_aleph0_le (card a), ← card_succ]\n    rw [← ord_le, ← le_succ_of_isLimit, ord_le]\n    · exact co.trans h\n    · rw [ord_aleph0]\n      exact Ordinal.isLimit_omega0\n\n"}
{"name":"Cardinal.ord_isLimit","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nco : LE.le Cardinal.aleph0 c\n⊢ c.ord.IsLimit","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-10-14\")]\nalias ord_isLimit := isLimit_ord\n\n"}
{"name":"Cardinal.noMaxOrder","module":"Mathlib.SetTheory.Ordinal.Arithmetic","initialProofState":"c : Cardinal.{u_1}\nh : LE.le Cardinal.aleph0 c\n⊢ NoMaxOrder c.ord.toType","decl":"theorem noMaxOrder {c} (h : ℵ₀ ≤ c) : NoMaxOrder c.ord.toType :=\n  toType_noMax_of_succ_lt fun _ ↦ (isLimit_ord h).succ_lt\n\n"}
