{"name":"ProbabilityTheory.IsRatCondKernelCDF.setIntegral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set Œ≤\n_hs : MeasurableSet s\nq : Rat\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict s) fun b => f { fst := a, snd := b } q) ((Œ∫ a) (SProd.sprod s (Set.Iic ‚Üëq))).toReal","decl":"/-- a function `f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù` is called a rational conditional kernel CDF of `Œ∫` with respect\nto `ŒΩ` if is measurable, if `fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù`\nand for all measurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`.\nAlso the `‚Ñö ‚Üí ‚Ñù` function `f (a, b)` should satisfy the properties of a Sieltjes function for\n`(ŒΩ a)`-almost all `b : Œ≤`. -/\nstructure IsRatCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  isRatStieltjesPoint_ae (a : Œ±) : ‚àÄ·µê b ‚àÇ(ŒΩ a), IsRatStieltjesPoint f (a, b)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun b ‚Ü¶ f (a, b) q) (ŒΩ a)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (q : ‚Ñö) :\n    ‚à´ b in s, f (a, b) q ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.isRatStieltjesPoint_ae","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun b => ProbabilityTheory.IsRatStieltjesPoint f { fst := a, snd := b }) (MeasureTheory.ae (ŒΩ a))","decl":"/-- a function `f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù` is called a rational conditional kernel CDF of `Œ∫` with respect\nto `ŒΩ` if is measurable, if `fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù`\nand for all measurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`.\nAlso the `‚Ñö ‚Üí ‚Ñù` function `f (a, b)` should satisfy the properties of a Sieltjes function for\n`(ŒΩ a)`-almost all `b : Œ≤`. -/\nstructure IsRatCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  isRatStieltjesPoint_ae (a : Œ±) : ‚àÄ·µê b ‚àÇ(ŒΩ a), IsRatStieltjesPoint f (a, b)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun b ‚Ü¶ f (a, b) q) (ŒΩ a)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (q : ‚Ñö) :\n    ‚à´ b in s, f (a, b) q ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.integrable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ MeasureTheory.Integrable (fun b => f { fst := a, snd := b } q) (ŒΩ a)","decl":"/-- a function `f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù` is called a rational conditional kernel CDF of `Œ∫` with respect\nto `ŒΩ` if is measurable, if `fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù`\nand for all measurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`.\nAlso the `‚Ñö ‚Üí ‚Ñù` function `f (a, b)` should satisfy the properties of a Sieltjes function for\n`(ŒΩ a)`-almost all `b : Œ≤`. -/\nstructure IsRatCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  isRatStieltjesPoint_ae (a : Œ±) : ‚àÄ·µê b ‚àÇ(ŒΩ a), IsRatStieltjesPoint f (a, b)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun b ‚Ü¶ f (a, b) q) (ŒΩ a)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (q : ‚Ñö) :\n    ‚à´ b in s, f (a, b) q ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.measurable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\n‚ä¢ Measurable f","decl":"/-- a function `f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù` is called a rational conditional kernel CDF of `Œ∫` with respect\nto `ŒΩ` if is measurable, if `fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù`\nand for all measurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`.\nAlso the `‚Ñö ‚Üí ‚Ñù` function `f (a, b)` should satisfy the properties of a Sieltjes function for\n`(ŒΩ a)`-almost all `b : Œ≤`. -/\nstructure IsRatCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  isRatStieltjesPoint_ae (a : Œ±) : ‚àÄ·µê b ‚àÇ(ŒΩ a), IsRatStieltjesPoint f (a, b)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun b ‚Ü¶ f (a, b) q) (ŒΩ a)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (q : ‚Ñö) :\n    ‚à´ b in s, f (a, b) q ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.mono","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun b => Monotone (f { fst := a, snd := b })) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDF.mono (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê b ‚àÇ(ŒΩ a), Monotone (f (a, b)) := by\n  filter_upwards [hf.isRatStieltjesPoint_ae a] with b hb using hb.mono\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.tendsto_atTop_one","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun b => Filter.Tendsto (f { fst := a, snd := b }) Filter.atTop (nhds 1)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDF.tendsto_atTop_one (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê b ‚àÇ(ŒΩ a), Tendsto (f (a, b)) atTop (ùìù 1) := by\n  filter_upwards [hf.isRatStieltjesPoint_ae a] with b hb using hb.tendsto_atTop_one\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.tendsto_atBot_zero","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun b => Filter.Tendsto (f { fst := a, snd := b }) Filter.atBot (nhds 0)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDF.tendsto_atBot_zero (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê b ‚àÇ(ŒΩ a), Tendsto (f (a, b)) atBot (ùìù 0) := by\n  filter_upwards [hf.isRatStieltjesPoint_ae a] with b hb using hb.tendsto_atBot_zero\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDF.iInf_rat_gt_eq","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun b => ‚àÄ (q : Rat), Eq (iInf fun r => f { fst := a, snd := b } ‚Üër) (f { fst := a, snd := b } q)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDF.iInf_rat_gt_eq (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê b ‚àÇ(ŒΩ a), ‚àÄ q, ‚®Ö r : Ioi q, f (a, b) r = f (a, b) q := by\n  filter_upwards [hf.isRatStieltjesPoint_ae a] with b hb using hb.iInf_rat_gt_eq\n\n"}
{"name":"ProbabilityTheory.stieltjesOfMeasurableRat_ae_eq","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ (MeasureTheory.ae (ŒΩ a)).EventuallyEq (fun b => ‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) ‚Üëq) fun b => f { fst := a, snd := b } q","decl":"lemma stieltjesOfMeasurableRat_ae_eq (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) (q : ‚Ñö) :\n    (fun b ‚Ü¶ stieltjesOfMeasurableRat f hf.measurable (a, b) q) =·µê[ŒΩ a] fun b ‚Ü¶ f (a, b) q := by\n  filter_upwards [hf.isRatStieltjesPoint_ae a] with a ha\n  rw [stieltjesOfMeasurableRat_eq, toRatCDF_of_isRatStieltjesPoint ha]\n\n"}
{"name":"ProbabilityTheory.setIntegral_stieltjesOfMeasurableRat_rat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nq : Rat\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict s) fun b => ‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) ‚Üëq) ((Œ∫ a) (SProd.sprod s (Set.Iic ‚Üëq))).toReal","decl":"lemma setIntegral_stieltjesOfMeasurableRat_rat (hf : IsRatCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) (q : ‚Ñö)\n    {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´ b in s, stieltjesOfMeasurableRat f hf.measurable (a, b) q ‚àÇ(ŒΩ a)\n      = (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal := by\n  rw [setIntegral_congr_ae hs (g := fun b ‚Ü¶ f (a, b) q) ?_, hf.setIntegral a hs]\n  filter_upwards [stieltjesOfMeasurableRat_ae_eq hf a q] with b hb using fun _ ‚Ü¶ hb\n\n"}
{"name":"ProbabilityTheory.setLIntegral_stieltjesOfMeasurableRat_rat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nq : Rat\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ENNReal.ofReal (‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) ‚Üëq)) ((Œ∫ a) (SProd.sprod s (Set.Iic ‚Üëq)))","decl":"lemma setLIntegral_stieltjesOfMeasurableRat_rat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (q : ‚Ñö) {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´‚Åª b in s, ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) q) ‚àÇ(ŒΩ a)\n      = Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù)) := by\n  rw [‚Üê ofReal_integral_eq_lintegral_ofReal]\n  ¬∑ rw [setIntegral_stieltjesOfMeasurableRat_rat hf a q hs, ENNReal.ofReal_toReal]\n    exact measure_ne_top _ _\n  ¬∑ refine Integrable.restrict ?_\n    rw [integrable_congr (stieltjesOfMeasurableRat_ae_eq hf a q)]\n    exact hf.integrable a q\n  ¬∑ exact ae_of_all _ (fun x ‚Ü¶ stieltjesOfMeasurableRat_nonneg _ _ _)\n\n"}
{"name":"ProbabilityTheory.setLIntegral_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ENNReal.ofReal (‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) x)) ((Œ∫ a) (SProd.sprod s (Set.Iic x)))","decl":"lemma setLIntegral_stieltjesOfMeasurableRat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´‚Åª b in s, ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) x) ‚àÇ(ŒΩ a)\n      = Œ∫ a (s √óÀ¢ Iic x) := by\n  -- We have the result for `x : ‚Ñö` thanks to `setLIntegral_stieltjesOfMeasurableRat_rat`.\n  -- We use a monotone convergence argument to extend it to the reals.\n  by_cases hœÅ_zero : (ŒΩ a).restrict s = 0\n  ¬∑ rw [hœÅ_zero, lintegral_zero_measure]\n    have ‚ü®q, hq‚ü© := exists_rat_gt x\n    suffices Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù)) = 0 by\n      symm\n      refine measure_mono_null (fun p ‚Ü¶ ?_) this\n      simp only [mem_prod, mem_Iic, and_imp]\n      exact fun h1 h2 ‚Ü¶ ‚ü®h1, h2.trans hq.le‚ü©\n    suffices (Œ∫ a (s √óÀ¢ Iic (q : ‚Ñù))).toReal = 0 by\n      rw [ENNReal.toReal_eq_zero_iff] at this\n      simpa [measure_ne_top] using this\n    rw [‚Üê hf.setIntegral a hs q]\n    simp [hœÅ_zero]\n  have h : ‚à´‚Åª b in s, ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) x) ‚àÇ(ŒΩ a)\n      = ‚à´‚Åª b in s, ‚®Ö r : { r' : ‚Ñö // x < r' },\n        ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) r) ‚àÇ(ŒΩ a) := by\n    congr with b : 1\n    simp_rw [‚Üê measure_stieltjesOfMeasurableRat_Iic]\n    rw [‚Üê Monotone.measure_iInter]\n    ¬∑ congr with y : 1\n      simp only [mem_Iic, mem_iInter, Subtype.forall]\n      refine ‚ü®fun h a ha ‚Ü¶ h.trans ?_, fun h ‚Ü¶ ?_‚ü©\n      ¬∑ exact mod_cast ha.le\n      ¬∑ refine le_of_forall_lt_rat_imp_le fun q hq ‚Ü¶ h q ?_\n        exact mod_cast hq\n    ¬∑ exact fun r r' hrr' ‚Ü¶ Iic_subset_Iic.mpr <| mod_cast hrr'\n    ¬∑ exact fun _ ‚Ü¶ nullMeasurableSet_Iic\n    ¬∑ obtain ‚ü®q, hq‚ü© := exists_rat_gt x\n      exact ‚ü®‚ü®q, hq‚ü©, measure_ne_top _ _‚ü©\n  have h_nonempty : Nonempty { r' : ‚Ñö // x < ‚Üër' } := by\n    obtain ‚ü®r, hrx‚ü© := exists_rat_gt x\n    exact ‚ü®‚ü®r, hrx‚ü©‚ü©\n  rw [h, lintegral_iInf_directed_of_measurable hœÅ_zero fun q : { r' : ‚Ñö // x < ‚Üër' } ‚Ü¶ ?_]\n  rotate_left\n  ¬∑ intro b\n    rw [setLIntegral_stieltjesOfMeasurableRat_rat hf a _ hs]\n    exact measure_ne_top _ _\n  ¬∑ refine Monotone.directed_ge fun i j hij b ‚Ü¶ ?_\n    simp_rw [‚Üê measure_stieltjesOfMeasurableRat_Iic]\n    refine measure_mono (Iic_subset_Iic.mpr ?_)\n    exact mod_cast hij\n  ¬∑ refine Measurable.ennreal_ofReal ?_\n    exact (measurable_stieltjesOfMeasurableRat hf.measurable _).comp measurable_prod_mk_left\n  simp_rw [setLIntegral_stieltjesOfMeasurableRat_rat hf _ _ hs]\n  rw [‚Üê Monotone.measure_iInter]\n  ¬∑ rw [‚Üê prod_iInter]\n    congr with y\n    simp only [mem_iInter, mem_Iic, Subtype.forall, Subtype.coe_mk]\n    exact ‚ü®le_of_forall_lt_rat_imp_le, fun hyx q hq ‚Ü¶ hyx.trans hq.le‚ü©\n  ¬∑ exact fun i j hij ‚Ü¶ prod_mono_right (by gcongr)\n  ¬∑ exact fun i ‚Ü¶ (hs.prod measurableSet_Iic).nullMeasurableSet\n  ¬∑ exact ‚ü®h_nonempty.some, measure_ne_top _ _‚ü©\n\n"}
{"name":"ProbabilityTheory.lintegral_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ Eq (MeasureTheory.lintegral (ŒΩ a) fun b => ENNReal.ofReal (‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) x)) ((Œ∫ a) (SProd.sprod Set.univ (Set.Iic x)))","decl":"lemma lintegral_stieltjesOfMeasurableRat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) :\n    ‚à´‚Åª b, ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) x) ‚àÇ(ŒΩ a)\n      = Œ∫ a (univ √óÀ¢ Iic x) := by\n  rw [‚Üê setLIntegral_univ, setLIntegral_stieltjesOfMeasurableRat hf _ _ MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.integrable_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ MeasureTheory.Integrable (fun b => ‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) x) (ŒΩ a)","decl":"lemma integrable_stieltjesOfMeasurableRat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) :\n    Integrable (fun b ‚Ü¶ stieltjesOfMeasurableRat f hf.measurable (a, b) x) (ŒΩ a) := by\n  have : (fun b ‚Ü¶ stieltjesOfMeasurableRat f hf.measurable (a, b) x)\n      = fun b ‚Ü¶ (ENNReal.ofReal (stieltjesOfMeasurableRat f hf.measurable (a, b) x)).toReal := by\n    ext t\n    rw [ENNReal.toReal_ofReal]\n    exact stieltjesOfMeasurableRat_nonneg _ _ _\n  rw [this]\n  refine integrable_toReal_of_lintegral_ne_top ?_ ?_\n  ¬∑ refine (Measurable.ennreal_ofReal ?_).aemeasurable\n    exact (measurable_stieltjesOfMeasurableRat hf.measurable x).comp measurable_prod_mk_left\n  ¬∑ rw [lintegral_stieltjesOfMeasurableRat hf]\n    exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.setIntegral_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict s) fun b => ‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) x) ((Œ∫ a) (SProd.sprod s (Set.Iic x))).toReal","decl":"lemma setIntegral_stieltjesOfMeasurableRat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´ b in s, stieltjesOfMeasurableRat f hf.measurable (a, b) x ‚àÇ(ŒΩ a)\n      = (Œ∫ a (s √óÀ¢ Iic x)).toReal := by\n  rw [‚Üê ENNReal.ofReal_eq_ofReal_iff, ENNReal.ofReal_toReal]\n  rotate_left\n  ¬∑ exact measure_ne_top _ _\n  ¬∑ exact setIntegral_nonneg hs (fun _ _ ‚Ü¶ stieltjesOfMeasurableRat_nonneg _ _ _)\n  ¬∑ exact ENNReal.toReal_nonneg\n  rw [ofReal_integral_eq_lintegral_ofReal, setLIntegral_stieltjesOfMeasurableRat hf _ _ hs]\n  ¬∑ exact (integrable_stieltjesOfMeasurableRat hf _ _).restrict\n  ¬∑ exact ae_of_all _ (fun _ ‚Ü¶ stieltjesOfMeasurableRat_nonneg _ _ _)\n\n"}
{"name":"ProbabilityTheory.integral_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ Eq (MeasureTheory.integral (ŒΩ a) fun b => ‚Üë(ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ { fst := a, snd := b }) x) ((Œ∫ a) (SProd.sprod Set.univ (Set.Iic x))).toReal","decl":"lemma integral_stieltjesOfMeasurableRat [IsFiniteKernel Œ∫] (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) :\n    ‚à´ b, stieltjesOfMeasurableRat f hf.measurable (a, b) x ‚àÇ(ŒΩ a)\n      = (Œ∫ a (univ √óÀ¢ Iic x)).toReal := by\n  rw [‚Üê setIntegral_univ, setIntegral_stieltjesOfMeasurableRat hf _ _ MeasurableSet.univ]\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_integral_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nseq : Nat ‚Üí Rat\n_hs : Monotone seq\n_hs_tendsto : Filter.Tendsto seq Filter.atTop Filter.atTop\n‚ä¢ Filter.Tendsto (fun m => MeasureTheory.integral (ŒΩ a) fun c => f { fst := a, snd := c } (seq m)) Filter.atTop (nhds ((ŒΩ a) Set.univ).toReal)","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.setIntegral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nA : Set Œ≤\n_hA : MeasurableSet A\nq : Rat\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict A) fun c => f { fst := a, snd := c } q) ((Œ∫ a) (SProd.sprod A (Set.Iic ‚Üëq))).toReal","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.measurable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\n‚ä¢ Measurable f","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.le_one'","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ Filter.Eventually (fun c => LE.le (f { fst := a, snd := c } q) 1) (MeasureTheory.ae (ŒΩ a))","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.nonneg'","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ Filter.Eventually (fun c => LE.le 0 (f { fst := a, snd := c } q)) (MeasureTheory.ae (ŒΩ a))","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.integrable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ MeasureTheory.Integrable (fun c => f { fst := a, snd := c } q) (ŒΩ a)","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.mono'","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nq r : Rat\n_hqr : LE.le q r\n‚ä¢ Filter.Eventually (fun c => LE.le (f { fst := a, snd := c } q) (f { fst := a, snd := c } r)) (MeasureTheory.ae (ŒΩ a))","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_integral_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nseq : Nat ‚Üí Rat\n_hs : Antitone seq\n_hs_tendsto : Filter.Tendsto seq Filter.atTop Filter.atBot\n‚ä¢ Filter.Tendsto (fun m => MeasureTheory.integral (ŒΩ a) fun c => f { fst := a, snd := c } (seq m)) Filter.atTop (nhds 0)","decl":"/-- This property implies `IsRatCondKernelCDF`. The measurability, integrability and integral\nconditions are the same, but the limit properties of `IsRatCondKernelCDF` are replaced by\nlimits of integrals. -/\nstructure IsRatCondKernelCDFAux (f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable : Measurable f\n  mono' (a : Œ±) {q r : ‚Ñö} (_hqr : q ‚â§ r) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ f (a, c) r\n  nonneg' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), 0 ‚â§ f (a, c) q\n  le_one' (a : Œ±) (q : ‚Ñö) : ‚àÄ·µê c ‚àÇ(ŒΩ a), f (a, c) q ‚â§ 1\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atBot (ùìù 0)` but slightly easier\n  to prove in the current applications of this definition (some integral convergence lemmas\n  currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_antitone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Antitone seq)\n    (_hs_tendsto : Tendsto seq atTop atBot) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù 0)\n  /- Same as `Tendsto (fun q : ‚Ñö ‚Ü¶ ‚à´ c, f (a, c) q ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)` but\n  slightly easier to prove in the current applications of this definition (some integral convergence\n  lemmas currently apply only to `‚Ñï`, not `‚Ñö`) -/\n  tendsto_integral_of_monotone (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (_hs : Monotone seq)\n    (_hs_tendsto : Tendsto seq atTop atTop) :\n    Tendsto (fun m ‚Ü¶ ‚à´ c, f (a, c) (seq m) ‚àÇ(ŒΩ a)) atTop (ùìù (ŒΩ a univ).toReal)\n  integrable (a : Œ±) (q : ‚Ñö) : Integrable (fun c ‚Ü¶ f (a, c) q) (ŒΩ a)\n  setIntegral (a : Œ±) {A : Set Œ≤} (_hA : MeasurableSet A) (q : ‚Ñö) :\n    ‚à´ c in A, f (a, c) q ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic ‚Üëq)).toReal\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.measurable_right","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\nq : Rat\n‚ä¢ Measurable fun t => f { fst := a, snd := t } q","decl":"lemma IsRatCondKernelCDFAux.measurable_right (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) (a : Œ±) (q : ‚Ñö) :\n    Measurable (fun t ‚Ü¶ f (a, t) q) := by\n  let h := hf.measurable\n  rw [measurable_pi_iff] at h\n  exact (h q).comp measurable_prod_mk_left\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.mono","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun c => Monotone (f { fst := a, snd := c })) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.mono (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê c ‚àÇ(ŒΩ a), Monotone (f (a, c)) := by\n  unfold Monotone\n  simp_rw [ae_all_iff]\n  exact fun _ _ hqr ‚Ü¶ hf.mono' a hqr\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.nonneg","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun c => ‚àÄ (q : Rat), LE.le 0 (f { fst := a, snd := c } q)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.nonneg (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê c ‚àÇ(ŒΩ a), ‚àÄ q, 0 ‚â§ f (a, c) q := ae_all_iff.mpr <| hf.nonneg' a\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.le_one","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun c => ‚àÄ (q : Rat), LE.le (f { fst := a, snd := c } q) 1) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.le_one (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê c ‚àÇ(ŒΩ a), ‚àÄ q, f (a, c) q ‚â§ 1 := ae_all_iff.mpr <| hf.le_one' a\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_zero_of_antitone","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\nseq : Nat ‚Üí Rat\nhseq : Antitone seq\nhseq_tendsto : Filter.Tendsto seq Filter.atTop Filter.atBot\n‚ä¢ Filter.Eventually (fun c => Filter.Tendsto (fun m => f { fst := a, snd := c } (seq m)) Filter.atTop (nhds 0)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.tendsto_zero_of_antitone (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ)\n    [IsFiniteKernel ŒΩ] (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (hseq : Antitone seq)\n    (hseq_tendsto : Tendsto seq atTop atBot) :\n    ‚àÄ·µê c ‚àÇ(ŒΩ a), Tendsto (fun m ‚Ü¶ f (a, c) (seq m)) atTop (ùìù 0) := by\n  refine tendsto_of_integral_tendsto_of_antitone ?_ (integrable_const _) ?_ ?_ ?_\n  ¬∑ exact fun n ‚Ü¶ hf.integrable a (seq n)\n  ¬∑ rw [integral_zero]\n    exact hf.tendsto_integral_of_antitone a seq hseq hseq_tendsto\n  ¬∑ filter_upwards [hf.mono a] with t ht using fun n m hnm ‚Ü¶ ht (hseq hnm)\n  ¬∑ filter_upwards [hf.nonneg a] with c hc using fun i ‚Ü¶ hc (seq i)\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_one_of_monotone","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\nseq : Nat ‚Üí Rat\nhseq : Monotone seq\nhseq_tendsto : Filter.Tendsto seq Filter.atTop Filter.atTop\n‚ä¢ Filter.Eventually (fun c => Filter.Tendsto (fun m => f { fst := a, snd := c } (seq m)) Filter.atTop (nhds 1)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.tendsto_one_of_monotone (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ)\n    [IsFiniteKernel ŒΩ] (a : Œ±) (seq : ‚Ñï ‚Üí ‚Ñö) (hseq : Monotone seq)\n    (hseq_tendsto : Tendsto seq atTop atTop) :\n    ‚àÄ·µê c ‚àÇ(ŒΩ a), Tendsto (fun m ‚Ü¶ f (a, c) (seq m)) atTop (ùìù 1) := by\n  refine tendsto_of_integral_tendsto_of_monotone ?_ (integrable_const _) ?_ ?_ ?_\n  ¬∑ exact fun n ‚Ü¶ hf.integrable a (seq n)\n  ¬∑ rw [MeasureTheory.integral_const, smul_eq_mul, mul_one]\n    exact hf.tendsto_integral_of_monotone a seq hseq hseq_tendsto\n  ¬∑ filter_upwards [hf.mono a] with t ht using fun n m hnm ‚Ü¶ ht (hseq hnm)\n  ¬∑ filter_upwards [hf.le_one a] with c hc using fun i ‚Ü¶ hc (seq i)\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_atTop_one","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun t => Filter.Tendsto (f { fst := a, snd := t }) Filter.atTop (nhds 1)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.tendsto_atTop_one (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) [IsFiniteKernel ŒΩ]\n    (a : Œ±) :\n    ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (f (a, t)) atTop (ùìù 1) := by\n  suffices ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (fun (n : ‚Ñï) ‚Ü¶ f (a, t) n) atTop (ùìù 1) by\n    filter_upwards [this, hf.mono a] with t ht h_mono\n    rw [tendsto_iff_tendsto_subseq_of_monotone h_mono tendsto_natCast_atTop_atTop]\n    exact ht\n  filter_upwards [hf.tendsto_one_of_monotone a Nat.cast Nat.mono_cast tendsto_natCast_atTop_atTop]\n    with x hx using hx\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.tendsto_atBot_zero","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun t => Filter.Tendsto (f { fst := a, snd := t }) Filter.atBot (nhds 0)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.tendsto_atBot_zero (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) [IsFiniteKernel ŒΩ]\n    (a : Œ±) :\n    ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (f (a, t)) atBot (ùìù 0) := by\n  suffices ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (fun q : ‚Ñö ‚Ü¶ f (a, t) (-q)) atTop (ùìù 0) by\n    filter_upwards [this] with t ht\n    have h_eq_neg : f (a, t) = fun q : ‚Ñö ‚Ü¶ f (a, t) (- -q) := by\n      simp_rw [neg_neg]\n    rw [h_eq_neg]\n    convert ht.comp tendsto_neg_atBot_atTop\n    simp\n  suffices ‚àÄ·µê t ‚àÇ(ŒΩ a), Tendsto (fun (n : ‚Ñï) ‚Ü¶ f (a, t) (-n)) atTop (ùìù 0) by\n    filter_upwards [this, hf.mono a] with t ht h_mono\n    have h_anti : Antitone (fun q ‚Ü¶ f (a, t) (-q)) := h_mono.comp_antitone monotone_id.neg\n    exact (tendsto_iff_tendsto_subseq_of_antitone h_anti tendsto_natCast_atTop_atTop).mpr ht\n  exact hf.tendsto_zero_of_antitone _ _ Nat.mono_cast.neg\n    (tendsto_neg_atBot_iff.mpr tendsto_natCast_atTop_atTop)\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.bddBelow_range","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun t => ‚àÄ (q : Rat), BddBelow (Set.range fun r => f { fst := a, snd := t } ‚Üër)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.bddBelow_range (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) (a : Œ±) :\n    ‚àÄ·µê t ‚àÇ(ŒΩ a), ‚àÄ q : ‚Ñö, BddBelow (range fun (r : Ioi q) ‚Ü¶ f (a, t) r) := by\n  filter_upwards [hf.nonneg a] with c hc\n  refine fun q ‚Ü¶ ‚ü®0, ?_‚ü©\n  simp [mem_lowerBounds, hc]\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.integrable_iInf_rat_gt","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\nq : Rat\n‚ä¢ MeasureTheory.Integrable (fun t => iInf fun r => f { fst := a, snd := t } ‚Üër) (ŒΩ a)","decl":"lemma IsRatCondKernelCDFAux.integrable_iInf_rat_gt (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ)\n    [IsFiniteKernel ŒΩ] (a : Œ±) (q : ‚Ñö) :\n    Integrable (fun t ‚Ü¶ ‚®Ö r : Ioi q, f (a, t) r) (ŒΩ a) := by\n  rw [‚Üê mem‚Ñíp_one_iff_integrable]\n  refine ‚ü®(Measurable.iInf fun i ‚Ü¶ hf.measurable_right a _).aestronglyMeasurable, ?_‚ü©\n  refine (?_ : _ ‚â§ (ŒΩ a univ : ‚Ñù‚â•0‚àû)).trans_lt (measure_lt_top _ _)\n  refine (eLpNorm_le_of_ae_bound (C := 1) ?_).trans (by simp)\n  filter_upwards [hf.bddBelow_range a, hf.nonneg a, hf.le_one a]\n    with t hbdd_below h_nonneg h_le_one\n  rw [Real.norm_eq_abs, abs_of_nonneg]\n  ¬∑ refine ciInf_le_of_le ?_ ?_ ?_\n    ¬∑ exact hbdd_below _\n    ¬∑ exact ‚ü®q + 1, by simp‚ü©\n    ¬∑ exact h_le_one _\n  ¬∑ exact le_ciInf fun r ‚Ü¶ h_nonneg _\n\n"}
{"name":"MeasureTheory.Measure.iInf_rat_gt_prod_Iic","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nmŒ± : MeasurableSpace Œ±\nœÅ : MeasureTheory.Measure (Prod Œ± Real)\ninst‚úù : MeasureTheory.IsFiniteMeasure œÅ\ns : Set Œ±\nhs : MeasurableSet s\nt : Rat\n‚ä¢ Eq (iInf fun r => œÅ (SProd.sprod s (Set.Iic ‚Üë‚Üër))) (œÅ (SProd.sprod s (Set.Iic ‚Üët)))","decl":"lemma _root_.MeasureTheory.Measure.iInf_rat_gt_prod_Iic {œÅ : Measure (Œ± √ó ‚Ñù)} [IsFiniteMeasure œÅ]\n    {s : Set Œ±} (hs : MeasurableSet s) (t : ‚Ñö) :\n    ‚®Ö r : { r' : ‚Ñö // t < r' }, œÅ (s √óÀ¢ Iic (r : ‚Ñù)) = œÅ (s √óÀ¢ Iic (t : ‚Ñù)) := by\n  rw [‚Üê Monotone.measure_iInter]\n  ¬∑ rw [‚Üê prod_iInter]\n    congr with x : 1\n    simp only [mem_iInter, mem_Iic, Subtype.forall, Subtype.coe_mk]\n    refine ‚ü®fun h ‚Ü¶ ?_, fun h a hta ‚Ü¶ h.trans ?_‚ü©\n    ¬∑ refine le_of_forall_lt_rat_imp_le fun q htq ‚Ü¶ h q ?_\n      exact mod_cast htq\n    ¬∑ exact mod_cast hta.le\n  ¬∑ exact fun r r' hrr' ‚Ü¶ prod_mono_right <| by gcongr\n  ¬∑ exact fun _ => (hs.prod measurableSet_Iic).nullMeasurableSet\n  ¬∑ exact ‚ü®‚ü®t + 1, lt_add_one _‚ü©, measure_ne_top œÅ _‚ü©\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.setIntegral_iInf_rat_gt","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù¬π : ProbabilityTheory.IsFiniteKernel Œ∫\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\nq : Rat\nA : Set Œ≤\nhA : MeasurableSet A\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict A) fun t => iInf fun r => f { fst := a, snd := t } ‚Üër) ((Œ∫ a) (SProd.sprod A (Set.Iic ‚Üëq))).toReal","decl":"lemma IsRatCondKernelCDFAux.setIntegral_iInf_rat_gt (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ)\n    [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ] (a : Œ±) (q : ‚Ñö) {A : Set Œ≤} (hA : MeasurableSet A) :\n    ‚à´ t in A, ‚®Ö r : Ioi q, f (a, t) r ‚àÇ(ŒΩ a) = (Œ∫ a (A √óÀ¢ Iic (q : ‚Ñù))).toReal := by\n  refine le_antisymm ?_ ?_\n  ¬∑ have h : ‚àÄ r : Ioi q, ‚à´ t in A, ‚®Ö r' : Ioi q, f (a, t) r' ‚àÇ(ŒΩ a)\n        ‚â§ (Œ∫ a (A √óÀ¢ Iic (r : ‚Ñù))).toReal := by\n      intro r\n      rw [‚Üê hf.setIntegral a hA]\n      refine setIntegral_mono_ae ?_ ?_ ?_\n      ¬∑ exact (hf.integrable_iInf_rat_gt _ _).integrableOn\n      ¬∑ exact (hf.integrable _ _).integrableOn\n      ¬∑ filter_upwards [hf.bddBelow_range a] with t ht using ciInf_le (ht _) r\n    calc ‚à´ t in A, ‚®Ö r : Ioi q, f (a, t) r ‚àÇ(ŒΩ a)\n      ‚â§ ‚®Ö r : Ioi q, (Œ∫ a (A √óÀ¢ Iic (r : ‚Ñù))).toReal := le_ciInf h\n    _ = (Œ∫ a (A √óÀ¢ Iic (q : ‚Ñù))).toReal := by\n        rw [‚Üê Measure.iInf_rat_gt_prod_Iic hA q]\n        exact (ENNReal.toReal_iInf (fun r ‚Ü¶ measure_ne_top _ _)).symm\n  ¬∑ rw [‚Üê hf.setIntegral a hA]\n    refine setIntegral_mono_ae ?_ ?_ ?_\n    ¬∑ exact (hf.integrable _ _).integrableOn\n    ¬∑ exact (hf.integrable_iInf_rat_gt _ _).integrableOn\n    ¬∑ filter_upwards [hf.mono a] with c h_mono using le_ciInf (fun r ‚Ü¶ h_mono (le_of_lt r.prop))\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.iInf_rat_gt_eq","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù¬π : ProbabilityTheory.IsFiniteKernel Œ∫\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun t => ‚àÄ (q : Rat), Eq (iInf fun r => f { fst := a, snd := t } ‚Üër) (f { fst := a, snd := t } q)) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.iInf_rat_gt_eq (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) [IsFiniteKernel Œ∫]\n    [IsFiniteKernel ŒΩ] (a : Œ±) :\n    ‚àÄ·µê t ‚àÇ(ŒΩ a), ‚àÄ q : ‚Ñö, ‚®Ö r : Ioi q, f (a, t) r = f (a, t) q := by\n  rw [ae_all_iff]\n  refine fun q ‚Ü¶ ae_eq_of_forall_setIntegral_eq_of_sigmaFinite (Œº := ŒΩ a) ?_ ?_ ?_\n  ¬∑ exact fun _ _ _ ‚Ü¶ (hf.integrable_iInf_rat_gt _ _).integrableOn\n  ¬∑ exact fun _ _ _ ‚Ü¶ (hf.integrable a _).integrableOn\n  ¬∑ intro s hs _\n    rw [hf.setIntegral _ hs, hf.setIntegral_iInf_rat_gt _ _ hs]\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.isRatStieltjesPoint_ae","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù¬π : ProbabilityTheory.IsFiniteKernel Œ∫\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\na : Œ±\n‚ä¢ Filter.Eventually (fun t => ProbabilityTheory.IsRatStieltjesPoint f { fst := a, snd := t }) (MeasureTheory.ae (ŒΩ a))","decl":"lemma IsRatCondKernelCDFAux.isRatStieltjesPoint_ae (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ)\n    [IsFiniteKernel Œ∫] [IsFiniteKernel ŒΩ] (a : Œ±) :\n    ‚àÄ·µê t ‚àÇ(ŒΩ a), IsRatStieltjesPoint f (a, t) := by\n  filter_upwards [hf.tendsto_atTop_one a, hf.tendsto_atBot_zero a,\n    hf.iInf_rat_gt_eq a, hf.mono a] with t ht_top ht_bot ht_iInf h_mono\n  exact ‚ü®h_mono, ht_top, ht_bot, ht_iInf‚ü©\n\n"}
{"name":"ProbabilityTheory.IsRatCondKernelCDFAux.isRatCondKernelCDF","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDFAux f Œ∫ ŒΩ\ninst‚úù¬π : ProbabilityTheory.IsFiniteKernel Œ∫\ninst‚úù : ProbabilityTheory.IsFiniteKernel ŒΩ\n‚ä¢ ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ","decl":"lemma IsRatCondKernelCDFAux.isRatCondKernelCDF (hf : IsRatCondKernelCDFAux f Œ∫ ŒΩ) [IsFiniteKernel Œ∫]\n    [IsFiniteKernel ŒΩ] :\n    IsRatCondKernelCDF f Œ∫ ŒΩ where\n  measurable := hf.measurable\n  isRatStieltjesPoint_ae := hf.isRatStieltjesPoint_ae\n  integrable := hf.integrable\n  setIntegral := hf.setIntegral\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.setIntegral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set Œ≤\n_hs : MeasurableSet s\nx : Real\n‚ä¢ Eq (MeasureTheory.integral ((ŒΩ a).restrict s) fun b => ‚Üë(f { fst := a, snd := b }) x) ((Œ∫ a) (SProd.sprod s (Set.Iic x))).toReal","decl":"/-- A function `f : Œ± √ó Œ≤ ‚Üí StieltjesFunction` is called a conditional kernel CDF of `Œ∫` with\nrespect to `ŒΩ` if it is measurable, tends to 0 at -‚àû and to 1 at +‚àû for all `p : Œ± √ó Œ≤`,\n`fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù` and for all\nmeasurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`. -/\nstructure IsCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable (x : ‚Ñù) : Measurable fun p ‚Ü¶ f p x\n  integrable (a : Œ±) (x : ‚Ñù) : Integrable (fun b ‚Ü¶ f (a, b) x) (ŒΩ a)\n  tendsto_atTop_one (p : Œ± √ó Œ≤) : Tendsto (f p) atTop (ùìù 1)\n  tendsto_atBot_zero (p : Œ± √ó Œ≤) : Tendsto (f p) atBot (ùìù 0)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.integrable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ MeasureTheory.Integrable (fun b => ‚Üë(f { fst := a, snd := b }) x) (ŒΩ a)","decl":"/-- A function `f : Œ± √ó Œ≤ ‚Üí StieltjesFunction` is called a conditional kernel CDF of `Œ∫` with\nrespect to `ŒΩ` if it is measurable, tends to 0 at -‚àû and to 1 at +‚àû for all `p : Œ± √ó Œ≤`,\n`fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù` and for all\nmeasurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`. -/\nstructure IsCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable (x : ‚Ñù) : Measurable fun p ‚Ü¶ f p x\n  integrable (a : Œ±) (x : ‚Ñù) : Integrable (fun b ‚Ü¶ f (a, b) x) (ŒΩ a)\n  tendsto_atTop_one (p : Œ± √ó Œ≤) : Tendsto (f p) atTop (ùìù 1)\n  tendsto_atBot_zero (p : Œ± √ó Œ≤) : Tendsto (f p) atBot (ùìù 0)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.tendsto_atTop_one","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\n‚ä¢ Filter.Tendsto (‚Üë(f p)) Filter.atTop (nhds 1)","decl":"/-- A function `f : Œ± √ó Œ≤ ‚Üí StieltjesFunction` is called a conditional kernel CDF of `Œ∫` with\nrespect to `ŒΩ` if it is measurable, tends to 0 at -‚àû and to 1 at +‚àû for all `p : Œ± √ó Œ≤`,\n`fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù` and for all\nmeasurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`. -/\nstructure IsCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable (x : ‚Ñù) : Measurable fun p ‚Ü¶ f p x\n  integrable (a : Œ±) (x : ‚Ñù) : Integrable (fun b ‚Ü¶ f (a, b) x) (ŒΩ a)\n  tendsto_atTop_one (p : Œ± √ó Œ≤) : Tendsto (f p) atTop (ùìù 1)\n  tendsto_atBot_zero (p : Œ± √ó Œ≤) : Tendsto (f p) atBot (ùìù 0)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.measurable","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\nx : Real\n‚ä¢ Measurable fun p => ‚Üë(f p) x","decl":"/-- A function `f : Œ± √ó Œ≤ ‚Üí StieltjesFunction` is called a conditional kernel CDF of `Œ∫` with\nrespect to `ŒΩ` if it is measurable, tends to 0 at -‚àû and to 1 at +‚àû for all `p : Œ± √ó Œ≤`,\n`fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù` and for all\nmeasurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`. -/\nstructure IsCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable (x : ‚Ñù) : Measurable fun p ‚Ü¶ f p x\n  integrable (a : Œ±) (x : ‚Ñù) : Integrable (fun b ‚Ü¶ f (a, b) x) (ŒΩ a)\n  tendsto_atTop_one (p : Œ± √ó Œ≤) : Tendsto (f p) atTop (ùìù 1)\n  tendsto_atBot_zero (p : Œ± √ó Œ≤) : Tendsto (f p) atBot (ùìù 0)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.tendsto_atBot_zero","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nself : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\n‚ä¢ Filter.Tendsto (‚Üë(f p)) Filter.atBot (nhds 0)","decl":"/-- A function `f : Œ± √ó Œ≤ ‚Üí StieltjesFunction` is called a conditional kernel CDF of `Œ∫` with\nrespect to `ŒΩ` if it is measurable, tends to 0 at -‚àû and to 1 at +‚àû for all `p : Œ± √ó Œ≤`,\n`fun b ‚Ü¶ f (a, b) x` is `(ŒΩ a)`-integrable for all `a : Œ±` and `x : ‚Ñù` and for all\nmeasurable sets `s : Set Œ≤`, `‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal`. -/\nstructure IsCondKernelCDF (f : Œ± √ó Œ≤ ‚Üí StieltjesFunction) (Œ∫ : Kernel Œ± (Œ≤ √ó ‚Ñù)) (ŒΩ : Kernel Œ± Œ≤) :\n    Prop where\n  measurable (x : ‚Ñù) : Measurable fun p ‚Ü¶ f p x\n  integrable (a : Œ±) (x : ‚Ñù) : Integrable (fun b ‚Ü¶ f (a, b) x) (ŒΩ a)\n  tendsto_atTop_one (p : Œ± √ó Œ≤) : Tendsto (f p) atTop (ùìù 1)\n  tendsto_atBot_zero (p : Œ± √ó Œ≤) : Tendsto (f p) atBot (ùìù 0)\n  setIntegral (a : Œ±) {s : Set Œ≤} (_hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´ b in s, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (s √óÀ¢ Iic x)).toReal\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.nonneg","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\nx : Real\n‚ä¢ LE.le 0 (‚Üë(f p) x)","decl":"lemma IsCondKernelCDF.nonneg (hf : IsCondKernelCDF f Œ∫ ŒΩ) (p : Œ± √ó Œ≤) (x : ‚Ñù) : 0 ‚â§ f p x :=\n  Monotone.le_of_tendsto (f p).mono (hf.tendsto_atBot_zero p) x\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.le_one","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\nx : Real\n‚ä¢ LE.le (‚Üë(f p) x) 1","decl":"lemma IsCondKernelCDF.le_one (hf : IsCondKernelCDF f Œ∫ ŒΩ) (p : Œ± √ó Œ≤) (x : ‚Ñù) : f p x ‚â§ 1 :=\n  Monotone.ge_of_tendsto (f p).mono (hf.tendsto_atTop_one p) x\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.integral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ Eq (MeasureTheory.integral (ŒΩ a) fun b => ‚Üë(f { fst := a, snd := b }) x) ((Œ∫ a) (SProd.sprod Set.univ (Set.Iic x))).toReal","decl":"lemma IsCondKernelCDF.integral\n    {f : Œ± √ó Œ≤ ‚Üí StieltjesFunction} (hf : IsCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) (x : ‚Ñù) :\n    ‚à´ b, f (a, b) x ‚àÇ(ŒΩ a) = (Œ∫ a (univ √óÀ¢ Iic x)).toReal := by\n  rw [‚Üê hf.setIntegral _ MeasurableSet.univ, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.setLIntegral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set Œ≤\nhs : MeasurableSet s\nx : Real\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ENNReal.ofReal (‚Üë(f { fst := a, snd := b }) x)) ((Œ∫ a) (SProd.sprod s (Set.Iic x)))","decl":"lemma IsCondKernelCDF.setLIntegral [IsFiniteKernel Œ∫]\n    {f : Œ± √ó Œ≤ ‚Üí StieltjesFunction} (hf : IsCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) (x : ‚Ñù) :\n    ‚à´‚Åª b in s, ENNReal.ofReal (f (a, b) x) ‚àÇ(ŒΩ a) = Œ∫ a (s √óÀ¢ Iic x) := by\n  rw [‚Üê ofReal_integral_eq_lintegral_ofReal (hf.integrable a x).restrict\n    (ae_of_all _ (fun _ ‚Ü¶ hf.nonneg _ _)), hf.setIntegral a hs x, ENNReal.ofReal_toReal]\n  exact measure_ne_top _ _\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.lintegral","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\n‚ä¢ Eq (MeasureTheory.lintegral (ŒΩ a) fun b => ENNReal.ofReal (‚Üë(f { fst := a, snd := b }) x)) ((Œ∫ a) (SProd.sprod Set.univ (Set.Iic x)))","decl":"lemma IsCondKernelCDF.lintegral [IsFiniteKernel Œ∫]\n    {f : Œ± √ó Œ≤ ‚Üí StieltjesFunction} (hf : IsCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) (x : ‚Ñù) :\n    ‚à´‚Åª b, ENNReal.ofReal (f (a, b) x) ‚àÇ(ŒΩ a) = Œ∫ a (univ √óÀ¢ Iic x) := by\n  rw [‚Üê hf.setLIntegral _ MeasurableSet.univ, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.isCondKernelCDF_stieltjesOfMeasurableRat","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí Rat ‚Üí Real\nhf : ProbabilityTheory.IsRatCondKernelCDF f Œ∫ ŒΩ\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\n‚ä¢ ProbabilityTheory.IsCondKernelCDF (ProbabilityTheory.stieltjesOfMeasurableRat f ‚ãØ) Œ∫ ŒΩ","decl":"lemma isCondKernelCDF_stieltjesOfMeasurableRat {f : Œ± √ó Œ≤ ‚Üí ‚Ñö ‚Üí ‚Ñù} (hf : IsRatCondKernelCDF f Œ∫ ŒΩ)\n    [IsFiniteKernel Œ∫] :\n    IsCondKernelCDF (stieltjesOfMeasurableRat f hf.measurable) Œ∫ ŒΩ where\n  measurable := measurable_stieltjesOfMeasurableRat hf.measurable\n  integrable := integrable_stieltjesOfMeasurableRat hf\n  tendsto_atTop_one := tendsto_stieltjesOfMeasurableRat_atTop hf.measurable\n  tendsto_atBot_zero := tendsto_stieltjesOfMeasurableRat_atBot hf.measurable\n  setIntegral a _ hs x := setIntegral_stieltjesOfMeasurableRat hf a x hs\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.toKernel_apply","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nx‚úù : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\n‚ä¢ Eq ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) p) (f p).measure","decl":"lemma IsCondKernelCDF.toKernel_apply {hf : IsCondKernelCDF f Œ∫ ŒΩ} (p : Œ± √ó Œ≤) :\n    hf.toKernel f p = (f p).measure := rfl\n\n"}
{"name":"ProbabilityTheory.instIsMarkovKernel_toKernel","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nx‚úù : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\n‚ä¢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.IsCondKernelCDF.toKernel f hf)","decl":"instance instIsMarkovKernel_toKernel {hf : IsCondKernelCDF f Œ∫ ŒΩ} :\n    IsMarkovKernel (hf.toKernel f) :=\n  ‚ü®fun _ ‚Ü¶ (f _).isProbabilityMeasure (hf.tendsto_atBot_zero _) (hf.tendsto_atTop_one _)‚ü©\n\n"}
{"name":"ProbabilityTheory.IsCondKernelCDF.toKernel_Iic","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nx‚úù : MeasurableSpace Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\np : Prod Œ± Œ≤\nx : Real\n‚ä¢ Eq (((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) p) (Set.Iic x)) (ENNReal.ofReal (‚Üë(f p) x))","decl":"lemma IsCondKernelCDF.toKernel_Iic {hf : IsCondKernelCDF f Œ∫ ŒΩ} (p : Œ± √ó Œ≤) (x : ‚Ñù) :\n    hf.toKernel f p (Iic x) = ENNReal.ofReal (f p x) := by\n  rw [IsCondKernelCDF.toKernel_apply p, (f p).measure_Iic (hf.tendsto_atBot_zero p)]\n  simp\n\n"}
{"name":"ProbabilityTheory.setLIntegral_toKernel_Iic","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\nx : Real\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) { fst := a, snd := b }) (Set.Iic x)) ((Œ∫ a) (SProd.sprod s (Set.Iic x)))","decl":"lemma setLIntegral_toKernel_Iic [IsFiniteKernel Œ∫] (hf : IsCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) (x : ‚Ñù) {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´‚Åª b in s, hf.toKernel f (a, b) (Iic x) ‚àÇ(ŒΩ a) = Œ∫ a (s √óÀ¢ Iic x) := by\n  simp_rw [IsCondKernelCDF.toKernel_Iic]\n  exact hf.setLIntegral _ hs _\n\n"}
{"name":"ProbabilityTheory.setLIntegral_toKernel_univ","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set Œ≤\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) { fst := a, snd := b }) Set.univ) ((Œ∫ a) (SProd.sprod s Set.univ))","decl":"lemma setLIntegral_toKernel_univ [IsFiniteKernel Œ∫] (hf : IsCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) :\n    ‚à´‚Åª b in s, hf.toKernel f (a, b) univ ‚àÇ(ŒΩ a) = Œ∫ a (s √óÀ¢ univ) := by\n  rw [‚Üê Real.iUnion_Iic_rat, prod_iUnion]\n  have h_dir : Directed (fun x y ‚Ü¶ x ‚äÜ y) fun q : ‚Ñö ‚Ü¶ Iic (q : ‚Ñù) := by\n    refine Monotone.directed_le fun r r' hrr' ‚Ü¶ Iic_subset_Iic.mpr ?_\n    exact mod_cast hrr'\n  have h_dir_prod : Directed (fun x y ‚Ü¶ x ‚äÜ y) fun q : ‚Ñö ‚Ü¶ s √óÀ¢ Iic (q : ‚Ñù) := by\n    refine Monotone.directed_le fun i j hij ‚Ü¶ ?_\n    refine prod_subset_prod_iff.mpr (Or.inl ‚ü®subset_rfl, Iic_subset_Iic.mpr ?_‚ü©)\n    exact mod_cast hij\n  simp_rw [h_dir.measure_iUnion, h_dir_prod.measure_iUnion]\n  rw [lintegral_iSup_directed]\n  ¬∑ simp_rw [setLIntegral_toKernel_Iic hf _ _ hs]\n  ¬∑ refine fun q ‚Ü¶ Measurable.aemeasurable ?_\n    exact (Kernel.measurable_coe _ measurableSet_Iic).comp measurable_prod_mk_left\n  ¬∑ refine Monotone.directed_le fun i j hij t ‚Ü¶ measure_mono (Iic_subset_Iic.mpr ?_)\n    exact mod_cast hij\n\n"}
{"name":"ProbabilityTheory.lintegral_toKernel_univ","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\n‚ä¢ Eq (MeasureTheory.lintegral (ŒΩ a) fun b => ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) { fst := a, snd := b }) Set.univ) ((Œ∫ a) Set.univ)","decl":"lemma lintegral_toKernel_univ [IsFiniteKernel Œ∫] (hf : IsCondKernelCDF f Œ∫ ŒΩ) (a : Œ±) :\n    ‚à´‚Åª b, hf.toKernel f (a, b) univ ‚àÇ(ŒΩ a) = Œ∫ a univ := by\n  rw [‚Üê setLIntegral_univ, setLIntegral_toKernel_univ hf a MeasurableSet.univ, univ_prod_univ]\n\n"}
{"name":"ProbabilityTheory.setLIntegral_toKernel_prod","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set Œ≤\nhs : MeasurableSet s\nt : Set Real\nht : MeasurableSet t\n‚ä¢ Eq (MeasureTheory.lintegral ((ŒΩ a).restrict s) fun b => ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) { fst := a, snd := b }) t) ((Œ∫ a) (SProd.sprod s t))","decl":"lemma setLIntegral_toKernel_prod [IsFiniteKernel Œ∫] (hf : IsCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) {s : Set Œ≤} (hs : MeasurableSet s) {t : Set ‚Ñù} (ht : MeasurableSet t) :\n    ‚à´‚Åª b in s, hf.toKernel f (a, b) t ‚àÇ(ŒΩ a) = Œ∫ a (s √óÀ¢ t) := by\n  -- `setLIntegral_toKernel_Iic` gives the result for `t = Iic x`. These sets form a\n  -- œÄ-system that generates the Borel œÉ-algebra, hence we can get the same equality for any\n  -- measurable set `t`.\n  induction t, ht\n    using MeasurableSpace.induction_on_inter (borel_eq_generateFrom_Iic ‚Ñù) isPiSystem_Iic with\n  | empty => simp only [measure_empty, lintegral_const, zero_mul, prod_empty]\n  | basic t ht =>\n    obtain ‚ü®q, rfl‚ü© := ht\n    exact setLIntegral_toKernel_Iic hf a _ hs\n  | compl t ht iht =>\n    calc ‚à´‚Åª b in s, hf.toKernel f (a, b) t·∂ú ‚àÇ(ŒΩ a)\n      = ‚à´‚Åª b in s, hf.toKernel f (a, b) univ - hf.toKernel f (a, b) t ‚àÇ(ŒΩ a) := by\n          congr with x; rw [measure_compl ht (measure_ne_top (hf.toKernel f (a, x)) _)]\n    _ = ‚à´‚Åª b in s, hf.toKernel f (a, b) univ ‚àÇ(ŒΩ a)\n          - ‚à´‚Åª b in s, hf.toKernel f (a, b) t ‚àÇ(ŒΩ a) := by\n        rw [lintegral_sub]\n        ¬∑ exact (Kernel.measurable_coe (hf.toKernel f) ht).comp measurable_prod_mk_left\n        ¬∑ rw [iht]\n          exact measure_ne_top _ _\n        ¬∑ exact Eventually.of_forall fun a ‚Ü¶ measure_mono (subset_univ _)\n    _ = Œ∫ a (s √óÀ¢ univ) - Œ∫ a (s √óÀ¢ t) := by\n        rw [setLIntegral_toKernel_univ hf a hs, iht]\n    _ = Œ∫ a (s √óÀ¢ t·∂ú) := by\n        rw [‚Üê measure_diff _ (hs.prod ht).nullMeasurableSet (measure_ne_top _ _)]\n        ¬∑ rw [prod_diff_prod, compl_eq_univ_diff]\n          simp only [diff_self, empty_prod, union_empty]\n        ¬∑ rw [prod_subset_prod_iff]\n          exact Or.inl ‚ü®subset_rfl, subset_univ t‚ü©\n  | iUnion f hf_disj hf_meas ihf =>\n    simp_rw [measure_iUnion hf_disj hf_meas]\n    rw [lintegral_tsum, prod_iUnion, measure_iUnion]\n    ¬∑ simp_rw [ihf]\n    ¬∑ exact hf_disj.mono fun i j h ‚Ü¶ h.set_prod_right _ _\n    ¬∑ exact fun i ‚Ü¶ MeasurableSet.prod hs (hf_meas i)\n    ¬∑ exact fun i ‚Ü¶\n        ((Kernel.measurable_coe _ (hf_meas i)).comp measurable_prod_mk_left).aemeasurable.restrict\n\n"}
{"name":"ProbabilityTheory.lintegral_toKernel_mem","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù : ProbabilityTheory.IsFiniteKernel Œ∫\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\na : Œ±\ns : Set (Prod Œ≤ Real)\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.lintegral (ŒΩ a) fun b => ((ProbabilityTheory.IsCondKernelCDF.toKernel f hf) { fst := a, snd := b }) (setOf fun y => Membership.mem s { fst := b, snd := y })) ((Œ∫ a) s)","decl":"open scoped Function in -- required for scoped `on` notation\nlemma lintegral_toKernel_mem [IsFiniteKernel Œ∫] (hf : IsCondKernelCDF f Œ∫ ŒΩ)\n    (a : Œ±) {s : Set (Œ≤ √ó ‚Ñù)} (hs : MeasurableSet s) :\n    ‚à´‚Åª b, hf.toKernel f (a, b) {y | (b, y) ‚àà s} ‚àÇ(ŒΩ a) = Œ∫ a s := by\n  -- `setLIntegral_toKernel_prod` gives the result for sets of the form `t‚ÇÅ √ó t‚ÇÇ`. These\n  -- sets form a œÄ-system that generates the product œÉ-algebra, hence we can get the same equality\n  -- for any measurable set `s`.\n  induction s, hs\n    using MeasurableSpace.induction_on_inter generateFrom_prod.symm isPiSystem_prod with\n  | empty =>\n    simp only [mem_empty_iff_false, setOf_false, measure_empty, lintegral_const, zero_mul]\n  | basic s hs =>\n    rcases hs with ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, rfl‚ü©\n    simp only [mem_setOf_eq] at ht‚ÇÅ ht‚ÇÇ\n    have h_prod_eq_snd : ‚àÄ a ‚àà t‚ÇÅ, {x : ‚Ñù | (a, x) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ} = t‚ÇÇ := by\n      intro a ha\n      simp only [ha, prod_mk_mem_set_prod_eq, true_and, setOf_mem_eq]\n    rw [‚Üê lintegral_add_compl _ ht‚ÇÅ]\n    have h_eq1 : ‚à´‚Åª x in t‚ÇÅ, hf.toKernel f (a, x) {y : ‚Ñù | (x, y) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ} ‚àÇ(ŒΩ a)\n        = ‚à´‚Åª x in t‚ÇÅ, hf.toKernel f (a, x) t‚ÇÇ ‚àÇ(ŒΩ a) := by\n      refine setLIntegral_congr_fun ht‚ÇÅ (Eventually.of_forall fun a ha ‚Ü¶ ?_)\n      rw [h_prod_eq_snd a ha]\n    have h_eq2 :\n        ‚à´‚Åª x in t‚ÇÅ·∂ú, hf.toKernel f (a, x) {y : ‚Ñù | (x, y) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ} ‚àÇ(ŒΩ a) = 0 := by\n      suffices h_eq_zero :\n          ‚àÄ x ‚àà t‚ÇÅ·∂ú, hf.toKernel f (a, x) {y : ‚Ñù | (x, y) ‚àà t‚ÇÅ √óÀ¢ t‚ÇÇ} = 0 by\n        rw [setLIntegral_congr_fun ht‚ÇÅ.compl (Eventually.of_forall h_eq_zero)]\n        simp only [lintegral_const, zero_mul]\n      intro a hat‚ÇÅ\n      rw [mem_compl_iff] at hat‚ÇÅ\n      simp only [hat‚ÇÅ, prod_mk_mem_set_prod_eq, false_and, setOf_false, measure_empty]\n    rw [h_eq1, h_eq2, add_zero]\n    exact setLIntegral_toKernel_prod hf a ht‚ÇÅ ht‚ÇÇ\n  | compl t ht ht_eq =>\n    calc ‚à´‚Åª b, hf.toKernel f (a, b) {y : ‚Ñù | (b, y) ‚àà t·∂ú} ‚àÇ(ŒΩ a)\n      = ‚à´‚Åª b, hf.toKernel f (a, b) {y : ‚Ñù | (b, y) ‚àà t}·∂ú ‚àÇ(ŒΩ a) := rfl\n    _ = ‚à´‚Åª b, hf.toKernel f (a, b) univ\n          - hf.toKernel f (a, b) {y : ‚Ñù | (b, y) ‚àà t} ‚àÇ(ŒΩ a) := by\n        congr with x : 1\n        exact measure_compl (measurable_prod_mk_left ht)\n          (measure_ne_top (hf.toKernel f (a, x)) _)\n    _ = ‚à´‚Åª x, hf.toKernel f (a, x) univ ‚àÇ(ŒΩ a) -\n          ‚à´‚Åª x, hf.toKernel f (a, x) {y : ‚Ñù | (x, y) ‚àà t} ‚àÇ(ŒΩ a) := by\n        have h_le : (fun x ‚Ü¶ hf.toKernel f (a, x) {y : ‚Ñù | (x, y) ‚àà t})\n              ‚â§·µê[ŒΩ a] fun x ‚Ü¶ hf.toKernel f (a, x) univ :=\n          Eventually.of_forall fun _ ‚Ü¶ measure_mono (subset_univ _)\n        rw [lintegral_sub _ _ h_le]\n        ¬∑ exact Kernel.measurable_kernel_prod_mk_left' ht a\n        refine ((lintegral_mono_ae h_le).trans_lt ?_).ne\n        rw [lintegral_toKernel_univ hf]\n        exact measure_lt_top _ univ\n    _ = Œ∫ a univ - Œ∫ a t := by rw [ht_eq, lintegral_toKernel_univ hf]\n    _ = Œ∫ a t·∂ú := (measure_compl ht (measure_ne_top _ _)).symm\n  | iUnion f' hf_disj hf_meas hf_eq =>\n    have h_eq : ‚àÄ a, {x | (a, x) ‚àà ‚ãÉ i, f' i} = ‚ãÉ i, {x | (a, x) ‚àà f' i} := by\n      intro a; ext x; simp only [mem_iUnion, mem_setOf_eq]\n    simp_rw [h_eq]\n    have h_disj : ‚àÄ a, Pairwise (Disjoint on fun i ‚Ü¶ {x | (a, x) ‚àà f' i}) := by\n      intro a i j hij\n      have h_disj := hf_disj hij\n      rw [Function.onFun, disjoint_iff_inter_eq_empty] at h_disj ‚ä¢\n      ext1 x\n      simp only [mem_inter_iff, mem_setOf_eq, mem_empty_iff_false, iff_false]\n      intro h_mem_both\n      suffices (a, x) ‚àà ‚àÖ by rwa [mem_empty_iff_false] at this\n      rwa [‚Üê h_disj, mem_inter_iff]\n    calc ‚à´‚Åª b, hf.toKernel f (a, b) (‚ãÉ i, {y | (b, y) ‚àà f' i}) ‚àÇ(ŒΩ a)\n      = ‚à´‚Åª b, ‚àë' i, hf.toKernel f (a, b) {y | (b, y) ‚àà f' i} ‚àÇ(ŒΩ a) := by\n          congr with x : 1\n          rw [measure_iUnion (h_disj x) fun i ‚Ü¶ measurable_prod_mk_left (hf_meas i)]\n    _ = ‚àë' i, ‚à´‚Åª b, hf.toKernel f (a, b) {y | (b, y) ‚àà f' i} ‚àÇ(ŒΩ a) :=\n          lintegral_tsum fun i ‚Ü¶ (Kernel.measurable_kernel_prod_mk_left' (hf_meas i) a).aemeasurable\n    _ = ‚àë' i, Œ∫ a (f' i) := by simp_rw [hf_eq]\n    _ = Œ∫ a (iUnion f') := (measure_iUnion hf_disj hf_meas).symm\n\n"}
{"name":"ProbabilityTheory.compProd_toKernel","module":"Mathlib.Probability.Kernel.Disintegration.CDFToKernel","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nmŒ± : MeasurableSpace Œ±\nmŒ≤ : MeasurableSpace Œ≤\nŒ∫ : ProbabilityTheory.Kernel Œ± (Prod Œ≤ Real)\nŒΩ : ProbabilityTheory.Kernel Œ± Œ≤\nf : Prod Œ± Œ≤ ‚Üí StieltjesFunction\ninst‚úù¬π : ProbabilityTheory.IsFiniteKernel Œ∫\ninst‚úù : ProbabilityTheory.IsSFiniteKernel ŒΩ\nhf : ProbabilityTheory.IsCondKernelCDF f Œ∫ ŒΩ\n‚ä¢ Eq (ŒΩ.compProd (ProbabilityTheory.IsCondKernelCDF.toKernel f hf)) Œ∫","decl":"lemma compProd_toKernel [IsFiniteKernel Œ∫] [IsSFiniteKernel ŒΩ] (hf : IsCondKernelCDF f Œ∫ ŒΩ) :\n    ŒΩ ‚äó‚Çñ hf.toKernel f = Œ∫ := by\n  ext a s hs\n  rw [Kernel.compProd_apply hs, lintegral_toKernel_mem hf a hs]\n\n"}
