{"name":"CategoryTheory.PreGaloisCategory.has_decomp_connected_components","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nX : C\n⊢ Exists fun ι => Exists fun f => Exists fun g => Exists fun x => And (∀ (i : ι), CategoryTheory.PreGaloisCategory.IsConnected (f i)) (Finite ι)","decl":"/-- In a Galois category, every object is the sum of connected objects. -/\ntheorem has_decomp_connected_components (X : C) :\n    ∃ (ι : Type) (f : ι → C) (g : (i : ι) → f i ⟶ X) (_ : IsColimit (Cofan.mk X g)),\n      (∀ i, IsConnected (f i)) ∧ Finite ι := by\n  let F := GaloisCategory.getFiberFunctor C\n  exact has_decomp_connected_components_aux F (Nat.card <| F.obj X) X rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.has_decomp_connected_components'","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{u₂, u₁} C\ninst✝ : CategoryTheory.GaloisCategory C\nX : C\n⊢ Exists fun ι => Exists fun x => Exists fun f => Exists fun x => ∀ (i : ι), CategoryTheory.PreGaloisCategory.IsConnected (f i)","decl":"/-- In a Galois category, every object is the sum of connected objects. -/\ntheorem has_decomp_connected_components' (X : C) :\n    ∃ (ι : Type) (_ : Finite ι) (f : ι → C) (_ : ∐ f ≅ X), ∀ i, IsConnected (f i) := by\n  obtain ⟨ι, f, g, hl, hc, hf⟩ := has_decomp_connected_components X\n  exact ⟨ι, hf, f, colimit.isoColimitCocone ⟨Cofan.mk X g, hl⟩, hc⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.fiber_in_connected_component","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nx : ↑(F.obj X)\n⊢ Exists fun Y => Exists fun i => Exists fun y => And (Eq (F.map i y) x) (And (CategoryTheory.PreGaloisCategory.IsConnected Y) (CategoryTheory.Mono i))","decl":"/-- Every element in the fiber of `X` lies in some connected component of `X`. -/\nlemma fiber_in_connected_component (X : C) (x : F.obj X) : ∃ (Y : C) (i : Y ⟶ X) (y : F.obj Y),\n    F.map i y = x ∧ IsConnected Y ∧ Mono i := by\n  obtain ⟨ι, f, g, hl, hc, he⟩ := has_decomp_connected_components X\n  have : Fintype ι := Fintype.ofFinite ι\n  let s : Cocone (Discrete.functor f ⋙ F) := F.mapCocone (Cofan.mk X g)\n  let s' : IsColimit s := isColimitOfPreserves F hl\n  obtain ⟨⟨j⟩, z, h⟩ := Concrete.isColimit_exists_rep _ s' x\n  refine ⟨f j, g j, z, ⟨?_, hc j, MonoCoprod.mono_inj _ (Cofan.mk X g) hl j⟩⟩\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.connected_component_unique","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{u₂, u₁} C\ninst✝⁵ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝⁴ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX A B : C\ninst✝³ : CategoryTheory.PreGaloisCategory.IsConnected A\ninst✝² : CategoryTheory.PreGaloisCategory.IsConnected B\na : ↑(F.obj A)\nb : ↑(F.obj B)\ni : Quiver.Hom A X\nj : Quiver.Hom B X\nh : Eq (F.map i a) (F.map j b)\ninst✝¹ : CategoryTheory.Mono i\ninst✝ : CategoryTheory.Mono j\n⊢ Exists fun f => Eq (F.map f.hom a) b","decl":"/-- Up to isomorphism an element of the fiber of `X` only lies in one connected component. -/\nlemma connected_component_unique {X A B : C} [IsConnected A] [IsConnected B] (a : F.obj A)\n    (b : F.obj B) (i : A ⟶ X) (j : B ⟶ X) (h : F.map i a = F.map j b) [Mono i] [Mono j] :\n    ∃ (f : A ≅ B), F.map f.hom a = b := by\n  /- We consider the fiber product of A and B over X. This is a non-empty (because of `h`)\n  subobject of `A` and `B` and hence isomorphic to `A` and `B` by connectedness. -/\n  let Y : C := pullback i j\n  let u : Y ⟶ A := pullback.fst i j\n  let v : Y ⟶ B := pullback.snd i j\n  let G := F ⋙ FintypeCat.incl\n  let e : F.obj Y ≃ { p : F.obj A × F.obj B // F.map i p.1 = F.map j p.2 } :=\n    fiberPullbackEquiv F i j\n  let y : F.obj Y := e.symm ⟨(a, b), h⟩\n  have hn : IsInitial Y → False := not_initial_of_inhabited F y\n  have : IsIso u := IsConnected.noTrivialComponent Y u hn\n  have : IsIso v := IsConnected.noTrivialComponent Y v hn\n  use (asIso u).symm ≪≫ asIso v\n  have hu : G.map u y = a := by\n    simp only [u, G, y, e, ← PreservesPullback.iso_hom_fst G, fiberPullbackEquiv,\n      Iso.toEquiv_comp, Equiv.symm_trans_apply, Iso.toEquiv_symm_fun, types_comp_apply,\n      inv_hom_id_apply]\n    erw [Types.pullbackIsoPullback_inv_fst_apply (F.map i) (F.map j)]\n  have hv : G.map v y = b := by\n    simp only [v, G, y, e, ← PreservesPullback.iso_hom_snd G, fiberPullbackEquiv,\n      Iso.toEquiv_comp, Equiv.symm_trans_apply, Iso.toEquiv_symm_fun, types_comp_apply,\n      inv_hom_id_apply]\n    erw [Types.pullbackIsoPullback_inv_snd_apply (F.map i) (F.map j)]\n  rw [← hu, ← hv]\n  show (F.toPrefunctor.map u ≫ F.toPrefunctor.map _) y = F.toPrefunctor.map v y\n  simp only [← F.map_comp, Iso.trans_hom, Iso.symm_hom, asIso_inv, asIso_hom,\n    IsIso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_galois_representative","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\n⊢ Exists fun A => Exists fun a => And (CategoryTheory.PreGaloisCategory.IsGalois A) (Function.Bijective fun f => F.map f a)","decl":"/-- The fiber of any object in a Galois category is represented by a Galois object. -/\nlemma exists_galois_representative (X : C) : ∃ (A : C) (a : F.obj A),\n    IsGalois A ∧ Function.Bijective (fun (f : A ⟶ X) ↦ F.map f a) := by\n  obtain ⟨A, u, a, h1, h2, h3⟩ := fiber_in_connected_component F (selfProd F X)\n    (mkSelfProdFib F X)\n  use A\n  use a\n  constructor\n  · refine (isGalois_iff_pretransitive F A).mpr ⟨fun x y ↦ ?_⟩\n    obtain ⟨fi1, hfi1⟩ := subobj_selfProd_trans h1 x\n    obtain ⟨fi2, hfi2⟩ := subobj_selfProd_trans h1 y\n    use fi1 ≪≫ fi2.symm\n    show F.map (fi1.hom ≫ fi2.inv) x = y\n    simp only [map_comp, FintypeCat.comp_apply]\n    rw [hfi1, ← hfi2]\n    exact congr_fun (F.mapIso fi2).hom_inv_id y\n  · refine ⟨evaluation_injective_of_isConnected F A X a, ?_⟩\n    intro x\n    use u ≫ Pi.π _ x\n    exact (selfProdProj_fiber h1) x\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_hom_from_galois_of_fiber","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nx : ↑(F.obj X)\n⊢ Exists fun A => Exists fun f => Exists fun a => And (CategoryTheory.PreGaloisCategory.IsGalois A) (Eq (F.map f a) x)","decl":"/-- Any element in the fiber of an object `X` is the evaluation of a morphism from a\nGalois object. -/\nlemma exists_hom_from_galois_of_fiber (X : C) (x : F.obj X) :\n    ∃ (A : C) (f : A ⟶ X) (a : F.obj A), IsGalois A ∧ F.map f a = x := by\n  obtain ⟨A, a, h1, h2⟩ := exists_galois_representative F X\n  obtain ⟨f, hf⟩ := h2.surjective x\n  exact ⟨A, f, a, h1, hf⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_hom_from_galois_of_fiber_nonempty","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\nh : Nonempty ↑(F.obj X)\n⊢ Exists fun A => Exists fun x => CategoryTheory.PreGaloisCategory.IsGalois A","decl":"/-- Any object with non-empty fiber admits a hom from a Galois object. -/\nlemma exists_hom_from_galois_of_fiber_nonempty (X : C) (h : Nonempty (F.obj X)) :\n    ∃ (A : C) (_ : A ⟶ X), IsGalois A := by\n  obtain ⟨x⟩ := h\n  obtain ⟨A, f, a, h1, _⟩ := exists_hom_from_galois_of_fiber F X x\n  exact ⟨A, f, h1⟩\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.exists_hom_from_galois_of_connected","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{u₂, u₁} C\ninst✝² : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝¹ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nX : C\ninst✝ : CategoryTheory.PreGaloisCategory.IsConnected X\n⊢ Exists fun A => Exists fun x => CategoryTheory.PreGaloisCategory.IsGalois A","decl":"include F in\n/-- Any connected object admits a hom from a Galois object. -/\nlemma exists_hom_from_galois_of_connected (X : C) [IsConnected X] :\n    ∃ (A : C) (_ : A ⟶ X), IsGalois A :=\n  exists_hom_from_galois_of_fiber_nonempty F X inferInstance\n\n"}
{"name":"CategoryTheory.PreGaloisCategory.natTrans_ext_of_isGalois","module":"Mathlib.CategoryTheory.Galois.Decomposition","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{u₂, u₁} C\ninst✝¹ : CategoryTheory.GaloisCategory C\nF : CategoryTheory.Functor C FintypeCat\ninst✝ : CategoryTheory.PreGaloisCategory.FiberFunctor F\nG : CategoryTheory.Functor C FintypeCat\nt s : Quiver.Hom F G\nh : ∀ (X : C) [inst : CategoryTheory.PreGaloisCategory.IsGalois X], Eq (t.app X) (s.app X)\n⊢ Eq t s","decl":"/-- To check equality of natural transformations `F ⟶ G`, it suffices to check it on\nGalois objects. -/\nlemma natTrans_ext_of_isGalois {G : C ⥤ FintypeCat.{w}} {t s : F ⟶ G}\n    (h : ∀ (X : C) [IsGalois X], t.app X = s.app X) :\n    t = s := by\n  ext X x\n  obtain ⟨A, f, a, _, rfl⟩ := exists_hom_from_galois_of_fiber F X x\n  rw [FunctorToFintypeCat.naturality, FunctorToFintypeCat.naturality, h A]\n\n"}
