{"name":"Multiset.powersetAux_eq_map_coe","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Multiset.powersetAux l) (List.map Multiset.ofList l.sublists)","decl":"theorem powersetAux_eq_map_coe {l : List α} : powersetAux l = (sublists l).map (↑) :=\n  rfl\n\n"}
{"name":"Multiset.mem_powersetAux","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.powersetAux l) s) (LE.le s ↑l)","decl":"@[simp]\ntheorem mem_powersetAux {l : List α} {s} : s ∈ powersetAux l ↔ s ≤ ↑l :=\n  Quotient.inductionOn s <| by simp [powersetAux_eq_map_coe, Subperm, and_comm]\n\n"}
{"name":"Multiset.powersetAux_perm_powersetAux'","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ (Multiset.powersetAux l).Perm (Multiset.powersetAux' l)","decl":"theorem powersetAux_perm_powersetAux' {l : List α} : powersetAux l ~ powersetAux' l := by\n  rw [powersetAux_eq_map_coe]; exact (sublists_perm_sublists' _).map _\n\n"}
{"name":"Multiset.powersetAux'_nil","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.powersetAux' List.nil) (List.cons 0 List.nil)","decl":"@[simp]\ntheorem powersetAux'_nil : powersetAux' (@nil α) = [0] :=\n  rfl\n\n"}
{"name":"Multiset.powersetAux'_cons","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\na : α\nl : List α\n⊢ Eq (Multiset.powersetAux' (List.cons a l)) (HAppend.hAppend (Multiset.powersetAux' l) (List.map (Multiset.cons a) (Multiset.powersetAux' l)))","decl":"@[simp]\ntheorem powersetAux'_cons (a : α) (l : List α) :\n    powersetAux' (a :: l) = powersetAux' l ++ List.map (cons a) (powersetAux' l) := by\n  simp [powersetAux']\n\n"}
{"name":"Multiset.powerset_aux'_perm","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : l₁.Perm l₂\n⊢ (Multiset.powersetAux' l₁).Perm (Multiset.powersetAux' l₂)","decl":"theorem powerset_aux'_perm {l₁ l₂ : List α} (p : l₁ ~ l₂) : powersetAux' l₁ ~ powersetAux' l₂ := by\n  induction p with\n  | nil => simp\n  | cons _ _ IH =>\n    simp only [powersetAux'_cons]\n    exact IH.append (IH.map _)\n  | swap a b =>\n    simp only [powersetAux'_cons, map_append, List.map_map, append_assoc]\n    apply Perm.append_left\n    rw [← append_assoc, ← append_assoc,\n      (by funext s; simp [cons_swap] : cons b ∘ cons a = cons a ∘ cons b)]\n    exact perm_append_comm.append_right _\n  | trans _ _ IH₁ IH₂ => exact IH₁.trans IH₂\n\n"}
{"name":"Multiset.powersetAux_perm","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : l₁.Perm l₂\n⊢ (Multiset.powersetAux l₁).Perm (Multiset.powersetAux l₂)","decl":"theorem powersetAux_perm {l₁ l₂ : List α} (p : l₁ ~ l₂) : powersetAux l₁ ~ powersetAux l₂ :=\n  powersetAux_perm_powersetAux'.trans <|\n    (powerset_aux'_perm p).trans powersetAux_perm_powersetAux'.symm\n\n--Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): slightly slower implementation due to `map ofList`\n"}
{"name":"Multiset.powerset_coe","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).powerset ↑(List.map Multiset.ofList l.sublists)","decl":"theorem powerset_coe (l : List α) : @powerset α l = ((sublists l).map (↑) : List (Multiset α)) :=\n  congr_arg ((↑) : List (Multiset α) → Multiset (Multiset α)) powersetAux_eq_map_coe\n\n"}
{"name":"Multiset.powerset_coe'","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (↑l).powerset ↑(List.map Multiset.ofList l.sublists')","decl":"@[simp]\ntheorem powerset_coe' (l : List α) : @powerset α l = ((sublists' l).map (↑) : List (Multiset α)) :=\n  Quot.sound powersetAux_perm_powersetAux'\n\n"}
{"name":"Multiset.powerset_zero","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.powerset 0) (Singleton.singleton 0)","decl":"@[simp]\ntheorem powerset_zero : @powerset α 0 = {0} :=\n  rfl\n\n"}
{"name":"Multiset.powerset_cons","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\na : α\ns : Multiset α\n⊢ Eq (Multiset.cons a s).powerset (HAdd.hAdd s.powerset (Multiset.map (Multiset.cons a) s.powerset))","decl":"@[simp]\ntheorem powerset_cons (a : α) (s) : powerset (a ::ₘ s) = powerset s + map (cons a) (powerset s) :=\n  Quotient.inductionOn s fun l => by simp [Function.comp_def]\n\n"}
{"name":"Multiset.mem_powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns t : Multiset α\n⊢ Iff (Membership.mem t.powerset s) (LE.le s t)","decl":"@[simp]\ntheorem mem_powerset {s t : Multiset α} : s ∈ powerset t ↔ s ≤ t :=\n  Quotient.inductionOn₂ s t <| by simp [Subperm, and_comm]\n\n"}
{"name":"Multiset.map_single_le_powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ LE.le (Multiset.map Singleton.singleton s) s.powerset","decl":"theorem map_single_le_powerset (s : Multiset α) : s.map singleton ≤ powerset s :=\n  Quotient.inductionOn s fun l => by\n    simp only [powerset_coe, quot_mk_to_coe, coe_le, map_coe]\n    show l.map (((↑) : List α → Multiset α) ∘ pure) <+~ (sublists l).map (↑)\n    rw [← List.map_map]\n    exact ((map_pure_sublist_sublists _).map _).subperm\n\n"}
{"name":"Multiset.card_powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq s.powerset.card (HPow.hPow 2 s.card)","decl":"@[simp]\ntheorem card_powerset (s : Multiset α) : card (powerset s) = 2 ^ card s :=\n  Quotient.inductionOn s <| by simp\n\n"}
{"name":"Multiset.revzip_powersetAux","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\nx : Prod (Multiset α) (Multiset α)\nh : Membership.mem (Multiset.powersetAux l).revzip x\n⊢ Eq (HAdd.hAdd x.1 x.2) ↑l","decl":"theorem revzip_powersetAux {l : List α} ⦃x⦄ (h : x ∈ revzip (powersetAux l)) : x.1 + x.2 = ↑l := by\n  rw [revzip, powersetAux_eq_map_coe, ← map_reverse, zip_map, ← revzip, List.mem_map] at h\n  simp only [Prod.map_apply, Prod.exists] at h\n  rcases h with ⟨l₁, l₂, h, rfl, rfl⟩\n  exact Quot.sound (revzip_sublists _ _ _ h)\n\n"}
{"name":"Multiset.revzip_powersetAux'","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\nx : Prod (Multiset α) (Multiset α)\nh : Membership.mem (Multiset.powersetAux' l).revzip x\n⊢ Eq (HAdd.hAdd x.1 x.2) ↑l","decl":"theorem revzip_powersetAux' {l : List α} ⦃x⦄ (h : x ∈ revzip (powersetAux' l)) :\n    x.1 + x.2 = ↑l := by\n  rw [revzip, powersetAux', ← map_reverse, zip_map, ← revzip, List.mem_map] at h\n  simp only [Prod.map_apply, Prod.exists] at h\n  rcases h with ⟨l₁, l₂, h, rfl, rfl⟩\n  exact Quot.sound (revzip_sublists' _ _ _ h)\n\n"}
{"name":"Multiset.revzip_powersetAux_lemma","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_2\ninst✝ : DecidableEq α\nl : List α\nl' : List (Multiset α)\nH : ∀ ⦃x : Prod (Multiset α) (Multiset α)⦄, Membership.mem l'.revzip x → Eq (HAdd.hAdd x.1 x.2) ↑l\n⊢ Eq l'.revzip (List.map (fun x => { fst := x, snd := HSub.hSub (↑l) x }) l')","decl":"theorem revzip_powersetAux_lemma {α : Type*} [DecidableEq α] (l : List α) {l' : List (Multiset α)}\n    (H : ∀ ⦃x : _ × _⦄, x ∈ revzip l' → x.1 + x.2 = ↑l) :\n    revzip l' = l'.map fun x => (x, (l : Multiset α) - x) := by\n  have :\n    Forall₂ (fun (p : Multiset α × Multiset α) (s : Multiset α) => p = (s, ↑l - s)) (revzip l')\n      ((revzip l').map Prod.fst) := by\n    rw [forall₂_map_right_iff, forall₂_same]\n    rintro ⟨s, t⟩ h\n    dsimp\n    rw [← H h, add_tsub_cancel_left]\n  rw [← forall₂_eq_eq_eq, forall₂_map_right_iff]\n  simpa using this\n\n"}
{"name":"Multiset.revzip_powersetAux_perm_aux'","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ (Multiset.powersetAux l).revzip.Perm (Multiset.powersetAux' l).revzip","decl":"theorem revzip_powersetAux_perm_aux' {l : List α} :\n    revzip (powersetAux l) ~ revzip (powersetAux' l) := by\n  haveI := Classical.decEq α\n  rw [revzip_powersetAux_lemma l revzip_powersetAux, revzip_powersetAux_lemma l revzip_powersetAux']\n  exact powersetAux_perm_powersetAux'.map _\n\n"}
{"name":"Multiset.revzip_powersetAux_perm","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : l₁.Perm l₂\n⊢ (Multiset.powersetAux l₁).revzip.Perm (Multiset.powersetAux l₂).revzip","decl":"theorem revzip_powersetAux_perm {l₁ l₂ : List α} (p : l₁ ~ l₂) :\n    revzip (powersetAux l₁) ~ revzip (powersetAux l₂) := by\n  haveI := Classical.decEq α\n  simp only [fun l : List α => revzip_powersetAux_lemma l revzip_powersetAux, coe_eq_coe.2 p]\n  exact (powersetAux_perm p).map _\n\n"}
{"name":"Multiset.powersetCardAux_eq_map_coe","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\nl : List α\n⊢ Eq (Multiset.powersetCardAux n l) (List.map Multiset.ofList (List.sublistsLen n l))","decl":"theorem powersetCardAux_eq_map_coe {n} {l : List α} :\n    powersetCardAux n l = (sublistsLen n l).map (↑) := by\n  rw [powersetCardAux, sublistsLenAux_eq, append_nil]\n\n"}
{"name":"Multiset.mem_powersetCardAux","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\nl : List α\ns : Multiset α\n⊢ Iff (Membership.mem (Multiset.powersetCardAux n l) s) (And (LE.le s ↑l) (Eq s.card n))","decl":"@[simp]\ntheorem mem_powersetCardAux {n} {l : List α} {s} : s ∈ powersetCardAux n l ↔ s ≤ ↑l ∧ card s = n :=\n  Quotient.inductionOn s <| by\n    simp only [quot_mk_to_coe, powersetCardAux_eq_map_coe, List.mem_map, mem_sublistsLen,\n      coe_eq_coe, coe_le, Subperm, exists_prop, coe_card]\n    exact fun l₁ =>\n      ⟨fun ⟨l₂, ⟨s, e⟩, p⟩ => ⟨⟨_, p, s⟩, p.symm.length_eq.trans e⟩,\n       fun ⟨⟨l₂, p, s⟩, e⟩ => ⟨_, ⟨s, p.length_eq.trans e⟩, p⟩⟩\n\n"}
{"name":"Multiset.powersetCardAux_zero","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nl : List α\n⊢ Eq (Multiset.powersetCardAux 0 l) (List.cons 0 List.nil)","decl":"@[simp]\ntheorem powersetCardAux_zero (l : List α) : powersetCardAux 0 l = [0] := by\n  simp [powersetCardAux_eq_map_coe]\n\n"}
{"name":"Multiset.powersetCardAux_nil","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\n⊢ Eq (Multiset.powersetCardAux (HAdd.hAdd n 1) List.nil) List.nil","decl":"@[simp]\ntheorem powersetCardAux_nil (n : ℕ) : powersetCardAux (n + 1) (@nil α) = [] :=\n  rfl\n\n"}
{"name":"Multiset.powersetCardAux_cons","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\na : α\nl : List α\n⊢ Eq (Multiset.powersetCardAux (HAdd.hAdd n 1) (List.cons a l)) (HAppend.hAppend (Multiset.powersetCardAux (HAdd.hAdd n 1) l) (List.map (Multiset.cons a) (Multiset.powersetCardAux n l)))","decl":"@[simp]\ntheorem powersetCardAux_cons (n : ℕ) (a : α) (l : List α) :\n    powersetCardAux (n + 1) (a :: l) =\n      powersetCardAux (n + 1) l ++ List.map (cons a) (powersetCardAux n l) := by\n  simp [powersetCardAux_eq_map_coe]\n\n"}
{"name":"Multiset.powersetCardAux_perm","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\nl₁ l₂ : List α\np : l₁.Perm l₂\n⊢ (Multiset.powersetCardAux n l₁).Perm (Multiset.powersetCardAux n l₂)","decl":"theorem powersetCardAux_perm {n} {l₁ l₂ : List α} (p : l₁ ~ l₂) :\n    powersetCardAux n l₁ ~ powersetCardAux n l₂ := by\n  induction' n with n IHn generalizing l₁ l₂\n  · simp\n  induction p with\n  | nil => rfl\n  | cons _ p IH =>\n    simp only [powersetCardAux_cons]\n    exact IH.append ((IHn p).map _)\n  | swap a b =>\n    simp only [powersetCardAux_cons, append_assoc]\n    apply Perm.append_left\n    cases n\n    · simp [Perm.swap]\n    simp only [powersetCardAux_cons, map_append, List.map_map]\n    rw [← append_assoc, ← append_assoc,\n      (by funext s; simp [cons_swap] : cons b ∘ cons a = cons a ∘ cons b)]\n    exact perm_append_comm.append_right _\n  | trans _ _ IH₁ IH₂ => exact IH₁.trans IH₂\n\n"}
{"name":"Multiset.powersetCard_coe'","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\nl : List α\n⊢ Eq (Multiset.powersetCard n ↑l) ↑(Multiset.powersetCardAux n l)","decl":"theorem powersetCard_coe' (n) (l : List α) : @powersetCard α n l = powersetCardAux n l :=\n  rfl\n\n"}
{"name":"Multiset.powersetCard_coe","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\nl : List α\n⊢ Eq (Multiset.powersetCard n ↑l) ↑(List.map Multiset.ofList (List.sublistsLen n l))","decl":"theorem powersetCard_coe (n) (l : List α) :\n    @powersetCard α n l = ((sublistsLen n l).map (↑) : List (Multiset α)) :=\n  congr_arg ((↑) : List (Multiset α) → Multiset (Multiset α)) powersetCardAux_eq_map_coe\n\n"}
{"name":"Multiset.powersetCard_zero_left","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.powersetCard 0 s) (Singleton.singleton 0)","decl":"@[simp]\ntheorem powersetCard_zero_left (s : Multiset α) : powersetCard 0 s = {0} :=\n  Quotient.inductionOn s fun l => by simp [powersetCard_coe']\n\n"}
{"name":"Multiset.powersetCard_zero_right","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\n⊢ Eq (Multiset.powersetCard (HAdd.hAdd n 1) 0) 0","decl":"theorem powersetCard_zero_right (n : ℕ) : @powersetCard α (n + 1) 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.powersetCard_cons","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\na : α\ns : Multiset α\n⊢ Eq (Multiset.powersetCard (HAdd.hAdd n 1) (Multiset.cons a s)) (HAdd.hAdd (Multiset.powersetCard (HAdd.hAdd n 1) s) (Multiset.map (Multiset.cons a) (Multiset.powersetCard n s)))","decl":"@[simp]\ntheorem powersetCard_cons (n : ℕ) (a : α) (s) :\n    powersetCard (n + 1) (a ::ₘ s) = powersetCard (n + 1) s + map (cons a) (powersetCard n s) :=\n  Quotient.inductionOn s fun l => by simp [powersetCard_coe']\n\n"}
{"name":"Multiset.powersetCard_one","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Eq (Multiset.powersetCard 1 s) (Multiset.map Singleton.singleton s)","decl":"theorem powersetCard_one (s : Multiset α) : powersetCard 1 s = s.map singleton :=\n  Quotient.inductionOn s fun l ↦ by\n    simp [powersetCard_coe, sublistsLen_one, map_reverse, Function.comp_def]\n\n"}
{"name":"Multiset.mem_powersetCard","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns t : Multiset α\n⊢ Iff (Membership.mem (Multiset.powersetCard n t) s) (And (LE.le s t) (Eq s.card n))","decl":"@[simp]\ntheorem mem_powersetCard {n : ℕ} {s t : Multiset α} : s ∈ powersetCard n t ↔ s ≤ t ∧ card s = n :=\n  Quotient.inductionOn t fun l => by simp [powersetCard_coe']\n\n"}
{"name":"Multiset.card_powersetCard","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Multiset α\n⊢ Eq (Multiset.powersetCard n s).card (s.card.choose n)","decl":"@[simp]\ntheorem card_powersetCard (n : ℕ) (s : Multiset α) :\n    card (powersetCard n s) = Nat.choose (card s) n :=\n  Quotient.inductionOn s <| by simp [powersetCard_coe]\n\n"}
{"name":"Multiset.powersetCard_le_powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Multiset α\n⊢ LE.le (Multiset.powersetCard n s) s.powerset","decl":"theorem powersetCard_le_powerset (n : ℕ) (s : Multiset α) : powersetCard n s ≤ powerset s :=\n  Quotient.inductionOn s fun l => by\n    simp only [quot_mk_to_coe, powersetCard_coe, powerset_coe', coe_le]\n    exact ((sublistsLen_sublist_sublists' _ _).map _).subperm\n\n"}
{"name":"Multiset.powersetCard_mono","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns t : Multiset α\nh : LE.le s t\n⊢ LE.le (Multiset.powersetCard n s) (Multiset.powersetCard n t)","decl":"theorem powersetCard_mono (n : ℕ) {s t : Multiset α} (h : s ≤ t) :\n    powersetCard n s ≤ powersetCard n t :=\n  leInductionOn h fun {l₁ l₂} h => by\n    simp only [powersetCard_coe, coe_le]\n    exact ((sublistsLen_sublist_of_sublist _ h).map _).subperm\n\n"}
{"name":"Multiset.powersetCard_eq_empty","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_2\nn : Nat\ns : Multiset α\nh : LT.lt s.card n\n⊢ Eq (Multiset.powersetCard n s) 0","decl":"@[simp]\ntheorem powersetCard_eq_empty {α : Type*} (n : ℕ) {s : Multiset α} (h : card s < n) :\n    powersetCard n s = 0 :=\n  card_eq_zero.mp (Nat.choose_eq_zero_of_lt h ▸ card_powersetCard _ _)\n\n"}
{"name":"Multiset.powersetCard_card_add","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\ni : Nat\nhi : LT.lt 0 i\n⊢ Eq (Multiset.powersetCard (HAdd.hAdd s.card i) s) 0","decl":"@[simp]\ntheorem powersetCard_card_add (s : Multiset α) {i : ℕ} (hi : 0 < i) :\n    s.powersetCard (card s + i) = 0 :=\n  powersetCard_eq_empty _ (Nat.lt_add_of_pos_right hi)\n\n"}
{"name":"Multiset.powersetCard_map","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nn : Nat\ns : Multiset α\n⊢ Eq (Multiset.powersetCard n (Multiset.map f s)) (Multiset.map (Multiset.map f) (Multiset.powersetCard n s))","decl":"theorem powersetCard_map {β : Type*} (f : α → β) (n : ℕ) (s : Multiset α) :\n    powersetCard n (s.map f) = (powersetCard n s).map (map f) := by\n  induction' s using Multiset.induction with t s ih generalizing n\n  · cases n <;> simp [powersetCard_zero_left, powersetCard_zero_right]\n  · cases n <;> simp [ih, map_comp_cons]\n\n"}
{"name":"Multiset.pairwise_disjoint_powersetCard","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Pairwise fun i j => Disjoint (Multiset.powersetCard i s) (Multiset.powersetCard j s)","decl":"theorem pairwise_disjoint_powersetCard (s : Multiset α) :\n    _root_.Pairwise fun i j => Disjoint (s.powersetCard i) (s.powersetCard j) :=\n  fun _ _ h ↦ disjoint_left.mpr fun hi hj ↦\n    h ((Multiset.mem_powersetCard.mp hi).2.symm.trans (Multiset.mem_powersetCard.mp hj).2)\n\n"}
{"name":"Multiset.bind_powerset_len","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_2\nS : Multiset α\n⊢ Eq ((Multiset.range (HAdd.hAdd S.card 1)).bind fun k => Multiset.powersetCard k S) S.powerset","decl":"theorem bind_powerset_len {α : Type*} (S : Multiset α) :\n    (bind (Multiset.range (card S + 1)) fun k => S.powersetCard k) = S.powerset := by\n  induction S using Quotient.inductionOn\n  simp_rw [quot_mk_to_coe, powerset_coe', powersetCard_coe, ← coe_range, coe_bind,\n    ← List.map_flatMap, coe_card]\n  exact coe_eq_coe.mpr ((List.range_bind_sublistsLen_perm _).map _)\n\n"}
{"name":"Multiset.nodup_powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\n⊢ Iff s.powerset.Nodup s.Nodup","decl":"@[simp]\ntheorem nodup_powerset {s : Multiset α} : Nodup (powerset s) ↔ Nodup s :=\n  ⟨fun h => (nodup_of_le (map_single_le_powerset _) h).of_map _,\n    Quotient.inductionOn s fun l h => by\n      simp only [quot_mk_to_coe, powerset_coe', coe_nodup]\n      refine (nodup_sublists'.2 h).map_on ?_\n      exact fun x sx y sy e =>\n        (h.perm_iff_eq_of_sublist (mem_sublists'.1 sx) (mem_sublists'.1 sy)).1 (Quotient.exact e)⟩\n\n"}
{"name":"Multiset.Nodup.ofPowerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\na✝ : s.powerset.Nodup\n⊢ s.Nodup","decl":"alias ⟨Nodup.ofPowerset, Nodup.powerset⟩ := nodup_powerset\n\n"}
{"name":"Multiset.Nodup.powerset","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\ns : Multiset α\na✝ : s.Nodup\n⊢ s.powerset.Nodup","decl":"alias ⟨Nodup.ofPowerset, Nodup.powerset⟩ := nodup_powerset\n\n"}
{"name":"Multiset.Nodup.powersetCard","module":"Mathlib.Data.Multiset.Powerset","initialProofState":"α : Type u_1\nn : Nat\ns : Multiset α\nh : s.Nodup\n⊢ (Multiset.powersetCard n s).Nodup","decl":"protected theorem Nodup.powersetCard {n : ℕ} {s : Multiset α} (h : Nodup s) :\n    Nodup (powersetCard n s) :=\n  nodup_of_le (powersetCard_le_powerset _ _) (nodup_powerset.2 h)\n\n"}
