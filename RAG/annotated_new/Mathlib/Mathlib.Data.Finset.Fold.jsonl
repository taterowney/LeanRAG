{"name":"Finset.fold_empty","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\n⊢ Eq (Finset.fold op b f EmptyCollection.emptyCollection) b","decl":"@[simp]\ntheorem fold_empty : (∅ : Finset α).fold op b f = b :=\n  rfl\n\n"}
{"name":"Finset.fold_cons","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\na : α\nh : Not (Membership.mem s a)\n⊢ Eq (Finset.fold op b f (Finset.cons a s h)) (op (f a) (Finset.fold op b f s))","decl":"@[simp]\ntheorem fold_cons (h : a ∉ s) : (cons a s h).fold op b f = f a * s.fold op b f := by\n  dsimp only [fold]\n  rw [cons_val, Multiset.map_cons, fold_cons_left]\n\n"}
{"name":"Finset.fold_insert","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\na : α\ninst✝ : DecidableEq α\nh : Not (Membership.mem s a)\n⊢ Eq (Finset.fold op b f (Insert.insert a s)) (op (f a) (Finset.fold op b f s))","decl":"@[simp]\ntheorem fold_insert [DecidableEq α] (h : a ∉ s) :\n    (insert a s).fold op b f = f a * s.fold op b f := by\n  unfold fold\n  rw [insert_val, ndinsert_of_not_mem h, Multiset.map_cons, fold_cons_left]\n\n"}
{"name":"Finset.fold_singleton","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\na : α\n⊢ Eq (Finset.fold op b f (Singleton.singleton a)) (op (f a) b)","decl":"@[simp]\ntheorem fold_singleton : ({a} : Finset α).fold op b f = f a * b :=\n  rfl\n\n"}
{"name":"Finset.fold_map","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ng : Function.Embedding γ α\ns : Finset γ\n⊢ Eq (Finset.fold op b f (Finset.map g s)) (Finset.fold op b (Function.comp f ⇑g) s)","decl":"@[simp]\ntheorem fold_map {g : γ ↪ α} {s : Finset γ} : (s.map g).fold op b f = s.fold op b (f ∘ g) := by\n  simp only [fold, map, Multiset.map_map]\n\n"}
{"name":"Finset.fold_image","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ninst✝ : DecidableEq α\ng : γ → α\ns : Finset γ\nH : ∀ (x : γ), Membership.mem s x → ∀ (y : γ), Membership.mem s y → Eq (g x) (g y) → Eq x y\n⊢ Eq (Finset.fold op b f (Finset.image g s)) (Finset.fold op b (Function.comp f g) s)","decl":"@[simp]\ntheorem fold_image [DecidableEq α] {g : γ → α} {s : Finset γ}\n    (H : ∀ x ∈ s, ∀ y ∈ s, g x = g y → x = y) : (s.image g).fold op b f = s.fold op b (f ∘ g) := by\n  simp only [fold, image_val_of_injOn H, Multiset.map_map]\n\n"}
{"name":"Finset.fold_congr","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\ng : α → β\nH : ∀ (x : α), Membership.mem s x → Eq (f x) (g x)\n⊢ Eq (Finset.fold op b f s) (Finset.fold op b g s)","decl":"@[congr]\ntheorem fold_congr {g : α → β} (H : ∀ x ∈ s, f x = g x) : s.fold op b f = s.fold op b g := by\n  rw [fold, fold, map_congr rfl H]\n\n"}
{"name":"Finset.fold_op_distrib","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\ns : Finset α\nf g : α → β\nb₁ b₂ : β\n⊢ Eq (Finset.fold op (op b₁ b₂) (fun x => op (f x) (g x)) s) (op (Finset.fold op b₁ f s) (Finset.fold op b₂ g s))","decl":"theorem fold_op_distrib {f g : α → β} {b₁ b₂ : β} :\n    (s.fold op (b₁ * b₂) fun x => f x * g x) = s.fold op b₁ f * s.fold op b₂ g := by\n  simp only [fold, fold_distrib]\n\n"}
{"name":"Finset.fold_const","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nb : β\ns : Finset α\nhd : Decidable (Eq s EmptyCollection.emptyCollection)\nc : β\nh : Eq (op c (op b c)) (op b c)\n⊢ Eq (Finset.fold op b (fun x => c) s) (ite (Eq s EmptyCollection.emptyCollection) b (op b c))","decl":"theorem fold_const [hd : Decidable (s = ∅)] (c : β) (h : op c (op b c) = op b c) :\n    Finset.fold op b (fun _ => c) s = if s = ∅ then b else op b c := by\n  classical\n    induction' s using Finset.induction_on with x s hx IH generalizing hd\n    · simp\n    · simp only [Finset.fold_insert hx, IH, if_false, Finset.insert_ne_empty]\n      split_ifs\n      · rw [hc.comm]\n      · exact h\n\n"}
{"name":"Finset.fold_hom","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\nop' : γ → γ → γ\ninst✝¹ : Std.Commutative op'\ninst✝ : Std.Associative op'\nm : β → γ\nhm : ∀ (x y : β), Eq (m (op x y)) (op' (m x) (m y))\n⊢ Eq (Finset.fold op' (m b) (fun x => m (f x)) s) (m (Finset.fold op b f s))","decl":"theorem fold_hom {op' : γ → γ → γ} [Std.Commutative op'] [Std.Associative op'] {m : β → γ}\n    (hm : ∀ x y, m (op x y) = op' (m x) (m y)) :\n    (s.fold op' (m b) fun x => m (f x)) = m (s.fold op b f) := by\n  rw [fold, fold, ← Multiset.fold_hom op hm, Multiset.map_map]\n  simp only [Function.comp_apply]\n\n"}
{"name":"Finset.fold_disjUnion","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\ns₁ s₂ : Finset α\nb₁ b₂ : β\nh : Disjoint s₁ s₂\n⊢ Eq (Finset.fold op (op b₁ b₂) f (s₁.disjUnion s₂ h)) (op (Finset.fold op b₁ f s₁) (Finset.fold op b₂ f s₂))","decl":"theorem fold_disjUnion {s₁ s₂ : Finset α} {b₁ b₂ : β} (h) :\n    (s₁.disjUnion s₂ h).fold op (b₁ * b₂) f = s₁.fold op b₁ f * s₂.fold op b₂ f :=\n  (congr_arg _ <| Multiset.map_add _ _ _).trans (Multiset.fold_add _ _ _ _ _)\n\n"}
{"name":"Finset.fold_disjiUnion","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nι : Type u_4\ns : Finset ι\nt : ι → Finset α\nb : ι → β\nb₀ : β\nh : (↑s).PairwiseDisjoint t\n⊢ Eq (Finset.fold op (Finset.fold op b₀ b s) f (s.disjiUnion t h)) (Finset.fold op b₀ (fun i => Finset.fold op (b i) f (t i)) s)","decl":"theorem fold_disjiUnion {ι : Type*} {s : Finset ι} {t : ι → Finset α} {b : ι → β} {b₀ : β} (h) :\n    (s.disjiUnion t h).fold op (s.fold op b₀ b) f = s.fold op b₀ fun i => (t i).fold op (b i) f :=\n  (congr_arg _ <| Multiset.map_bind _ _ _).trans (Multiset.fold_bind _ _ _ _ _)\n\n"}
{"name":"Finset.fold_union_inter","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\nb₁ b₂ : β\n⊢ Eq (op (Finset.fold op b₁ f (Union.union s₁ s₂)) (Finset.fold op b₂ f (Inter.inter s₁ s₂))) (op (Finset.fold op b₂ f s₁) (Finset.fold op b₁ f s₂))","decl":"theorem fold_union_inter [DecidableEq α] {s₁ s₂ : Finset α} {b₁ b₂ : β} :\n    ((s₁ ∪ s₂).fold op b₁ f * (s₁ ∩ s₂).fold op b₂ f) = s₁.fold op b₂ f * s₂.fold op b₁ f := by\n  unfold fold\n  rw [← fold_add op, ← Multiset.map_add, union_val, inter_val, union_add_inter, Multiset.map_add,\n    hc.comm, fold_add]\n\n"}
{"name":"Finset.fold_insert_idem","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\na : α\ninst✝ : DecidableEq α\nhi : Std.IdempotentOp op\n⊢ Eq (Finset.fold op b f (Insert.insert a s)) (op (f a) (Finset.fold op b f s))","decl":"@[simp]\ntheorem fold_insert_idem [DecidableEq α] [hi : Std.IdempotentOp op] :\n    (insert a s).fold op b f = f a * s.fold op b f := by\n  by_cases h : a ∈ s\n  · rw [← insert_erase h]\n    simp [← ha.assoc, hi.idempotent]\n  · apply fold_insert h\n\n"}
{"name":"Finset.fold_image_idem","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ninst✝ : DecidableEq α\ng : γ → α\ns : Finset γ\nhi : Std.IdempotentOp op\n⊢ Eq (Finset.fold op b f (Finset.image g s)) (Finset.fold op b (Function.comp f g) s)","decl":"theorem fold_image_idem [DecidableEq α] {g : γ → α} {s : Finset γ} [hi : Std.IdempotentOp op] :\n    (image g s).fold op b f = s.fold op b (f ∘ g) := by\n  induction' s using Finset.cons_induction with x xs hx ih\n  · rw [fold_empty, image_empty, fold_empty]\n  · haveI := Classical.decEq γ\n    rw [fold_cons, cons_eq_insert, image_insert, fold_insert_idem, ih]\n    simp only [Function.comp_apply]\n\n"}
{"name":"Finset.fold_ite'","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\ng : α → β\nhb : Eq (op b b) b\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.fold op b (fun i => ite (p i) (f i) (g i)) s) (op (Finset.fold op b f (Finset.filter p s)) (Finset.fold op b g (Finset.filter (fun i => Not (p i)) s)))","decl":"/-- A stronger version of `Finset.fold_ite`, but relies on\nan explicit proof of idempotency on the seed element, rather\nthan relying on typeclass idempotency over the whole type. -/\ntheorem fold_ite' {g : α → β} (hb : op b b = b) (p : α → Prop) [DecidablePred p] :\n    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =\n      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => ¬p i)) := by\n  classical\n    induction' s using Finset.induction_on with x s hx IH\n    · simp [hb]\n    · simp only [Finset.fold_insert hx]\n      split_ifs with h\n      · have : x ∉ Finset.filter p s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, ha.assoc, IH]\n      · have : x ∉ Finset.filter (fun i => ¬ p i) s := by simp [hx]\n        simp [Finset.filter_insert, h, Finset.fold_insert this, IH, ← ha.assoc, hc.comm]\n\n"}
{"name":"Finset.fold_ite","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\ninst✝¹ : Std.IdempotentOp op\ng : α → β\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.fold op b (fun i => ite (p i) (f i) (g i)) s) (op (Finset.fold op b f (Finset.filter p s)) (Finset.fold op b g (Finset.filter (fun i => Not (p i)) s)))","decl":"/-- A weaker version of `Finset.fold_ite'`,\nrelying on typeclass idempotency over the whole type,\ninstead of solely on the seed element.\nHowever, this is easier to use because it does not generate side goals. -/\ntheorem fold_ite [Std.IdempotentOp op] {g : α → β} (p : α → Prop) [DecidablePred p] :\n    Finset.fold op b (fun i => ite (p i) (f i) (g i)) s =\n      op (Finset.fold op b f (s.filter p)) (Finset.fold op b g (s.filter fun i => ¬p i)) :=\n  fold_ite' (Std.IdempotentOp.idempotent _) _\n\n"}
{"name":"Finset.fold_op_rel_iff_and","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\nr : β → β → Prop\nhr : ∀ {x y z : β}, Iff (r x (op y z)) (And (r x y) (r x z))\nc : β\n⊢ Iff (r c (Finset.fold op b f s)) (And (r c b) (∀ (x : α), Membership.mem s x → r c (f x)))","decl":"theorem fold_op_rel_iff_and {r : β → β → Prop} (hr : ∀ {x y z}, r x (op y z) ↔ r x y ∧ r x z)\n    {c : β} : r c (s.fold op b f) ↔ r c b ∧ ∀ x ∈ s, r c (f x) := by\n  classical\n    induction' s using Finset.induction_on with a s ha IH\n    · simp\n    rw [Finset.fold_insert ha, hr, IH, ← and_assoc, @and_comm (r c (f a)), and_assoc]\n    apply and_congr Iff.rfl\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      intro b hb\n      rw [Finset.mem_insert] at hb\n      rcases hb with (rfl | hb) <;> solve_by_elim\n    · intro h\n      constructor\n      · exact h a (Finset.mem_insert_self _ _)\n      · exact fun b hb => h b <| Finset.mem_insert_of_mem hb\n\n"}
{"name":"Finset.fold_op_rel_iff_or","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : β → β → β\nhc : Std.Commutative op\nha : Std.Associative op\nf : α → β\nb : β\ns : Finset α\nr : β → β → Prop\nhr : ∀ {x y z : β}, Iff (r x (op y z)) (Or (r x y) (r x z))\nc : β\n⊢ Iff (r c (Finset.fold op b f s)) (Or (r c b) (Exists fun x => And (Membership.mem s x) (r c (f x))))","decl":"theorem fold_op_rel_iff_or {r : β → β → Prop} (hr : ∀ {x y z}, r x (op y z) ↔ r x y ∨ r x z)\n    {c : β} : r c (s.fold op b f) ↔ r c b ∨ ∃ x ∈ s, r c (f x) := by\n  classical\n    induction' s using Finset.induction_on with a s ha IH\n    · simp\n    rw [Finset.fold_insert ha, hr, IH, ← or_assoc, @or_comm (r c (f a)), or_assoc]\n    apply or_congr Iff.rfl\n    constructor\n    · rintro (h₁ | ⟨x, hx, h₂⟩)\n      · use a\n        simp [h₁]\n      · refine ⟨x, by simp [hx], h₂⟩\n    · rintro ⟨x, hx, h⟩\n      exact (mem_insert.mp hx).imp (fun hx => by rwa [hx] at h) (fun hx => ⟨x, hx, h⟩)\n\n"}
{"name":"Finset.fold_union_empty_singleton","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.fold (fun x1 x2 => Union.union x1 x2) EmptyCollection.emptyCollection Singleton.singleton s) s","decl":"@[simp]\ntheorem fold_union_empty_singleton [DecidableEq α] (s : Finset α) :\n    Finset.fold (· ∪ ·) ∅ singleton s = s := by\n  induction' s using Finset.induction_on with a s has ih\n  · simp only [fold_empty]\n  · rw [fold_insert has, ih, insert_eq]\n\n"}
{"name":"Finset.fold_sup_bot_singleton","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Finset.fold (fun x1 x2 => Max.max x1 x2) Bot.bot Singleton.singleton s) s","decl":"theorem fold_sup_bot_singleton [DecidableEq α] (s : Finset α) :\n    Finset.fold (· ⊔ ·) ⊥ singleton s = s :=\n  fold_union_empty_singleton s\n\n"}
{"name":"Finset.le_fold_min","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LE.le c (Finset.fold Min.min b f s)) (And (LE.le c b) (∀ (x : α), Membership.mem s x → LE.le c (f x)))","decl":"theorem le_fold_min : c ≤ s.fold min b f ↔ c ≤ b ∧ ∀ x ∈ s, c ≤ f x :=\n  fold_op_rel_iff_and le_min_iff\n\n"}
{"name":"Finset.fold_min_le","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LE.le (Finset.fold Min.min b f s) c) (Or (LE.le b c) (Exists fun x => And (Membership.mem s x) (LE.le (f x) c)))","decl":"theorem fold_min_le : s.fold min b f ≤ c ↔ b ≤ c ∨ ∃ x ∈ s, f x ≤ c := by\n  show _ ≥ _ ↔ _\n  apply fold_op_rel_iff_or\n  intro x y z\n  show _ ≤ _ ↔ _\n  exact min_le_iff\n\n"}
{"name":"Finset.lt_fold_min","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LT.lt c (Finset.fold Min.min b f s)) (And (LT.lt c b) (∀ (x : α), Membership.mem s x → LT.lt c (f x)))","decl":"theorem lt_fold_min : c < s.fold min b f ↔ c < b ∧ ∀ x ∈ s, c < f x :=\n  fold_op_rel_iff_and lt_min_iff\n\n"}
{"name":"Finset.fold_min_lt","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LT.lt (Finset.fold Min.min b f s) c) (Or (LT.lt b c) (Exists fun x => And (Membership.mem s x) (LT.lt (f x) c)))","decl":"theorem fold_min_lt : s.fold min b f < c ↔ b < c ∨ ∃ x ∈ s, f x < c := by\n  show _ > _ ↔ _\n  apply fold_op_rel_iff_or\n  intro x y z\n  show _ < _ ↔ _\n  exact min_lt_iff\n\n"}
{"name":"Finset.fold_max_le","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LE.le (Finset.fold Max.max b f s) c) (And (LE.le b c) (∀ (x : α), Membership.mem s x → LE.le (f x) c))","decl":"theorem fold_max_le : s.fold max b f ≤ c ↔ b ≤ c ∧ ∀ x ∈ s, f x ≤ c := by\n  show _ ≥ _ ↔ _\n  apply fold_op_rel_iff_and\n  intro x y z\n  show _ ≤ _ ↔ _\n  exact max_le_iff\n\n"}
{"name":"Finset.le_fold_max","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LE.le c (Finset.fold Max.max b f s)) (Or (LE.le c b) (Exists fun x => And (Membership.mem s x) (LE.le c (f x))))","decl":"theorem le_fold_max : c ≤ s.fold max b f ↔ c ≤ b ∨ ∃ x ∈ s, c ≤ f x :=\n  fold_op_rel_iff_or le_max_iff\n\n"}
{"name":"Finset.fold_max_lt","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LT.lt (Finset.fold Max.max b f s) c) (And (LT.lt b c) (∀ (x : α), Membership.mem s x → LT.lt (f x) c))","decl":"theorem fold_max_lt : s.fold max b f < c ↔ b < c ∧ ∀ x ∈ s, f x < c := by\n  show _ > _ ↔ _\n  apply fold_op_rel_iff_and\n  intro x y z\n  show _ < _ ↔ _\n  exact max_lt_iff\n\n"}
{"name":"Finset.lt_fold_max","module":"Mathlib.Data.Finset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nb : β\ns : Finset α\ninst✝ : LinearOrder β\nc : β\n⊢ Iff (LT.lt c (Finset.fold Max.max b f s)) (Or (LT.lt c b) (Exists fun x => And (Membership.mem s x) (LT.lt c (f x))))","decl":"theorem lt_fold_max : c < s.fold max b f ↔ c < b ∨ ∃ x ∈ s, c < f x :=\n  fold_op_rel_iff_or lt_max_iff\n\n"}
