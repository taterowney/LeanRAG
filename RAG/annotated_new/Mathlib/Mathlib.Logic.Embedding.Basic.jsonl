{"name":"Function.Embedding.inj'","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nself : Function.Embedding α β\n⊢ Function.Injective self.toFun","decl":"/-- `α ↪ β` is a bundled injective function. -/\nstructure Embedding (α : Sort*) (β : Sort*) where\n  /-- An embedding as a function. Use coercion instead. -/\n  toFun : α → β\n  /-- An embedding is an injective function. Use `Function.Embedding.injective` instead. -/\n  inj' : Injective toFun\n\n"}
{"name":"Function.Embedding.mk.sizeOf_spec","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\ninj' : Function.Injective toFun\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, inj' := inj' }) 1","decl":"/-- `α ↪ β` is a bundled injective function. -/\nstructure Embedding (α : Sort*) (β : Sort*) where\n  /-- An embedding as a function. Use coercion instead. -/\n  toFun : α → β\n  /-- An embedding is an injective function. Use `Function.Embedding.injective` instead. -/\n  inj' : Injective toFun\n\n"}
{"name":"Function.Embedding.mk.injEq","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ntoFun✝ : α → β\ninj'✝ : Function.Injective toFun✝\ntoFun : α → β\ninj' : Function.Injective toFun\n⊢ Eq (Eq { toFun := toFun✝, inj' := inj'✝ } { toFun := toFun, inj' := inj' }) (Eq toFun✝ toFun)","decl":"/-- `α ↪ β` is a bundled injective function. -/\nstructure Embedding (α : Sort*) (β : Sort*) where\n  /-- An embedding as a function. Use coercion instead. -/\n  toFun : α → β\n  /-- An embedding is an injective function. Use `Function.Embedding.injective` instead. -/\n  inj' : Injective toFun\n\n"}
{"name":"Function.Embedding.mk.inj","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ntoFun✝ : α → β\ninj'✝ : Function.Injective toFun✝\ntoFun : α → β\ninj' : Function.Injective toFun\nx✝ : Eq { toFun := toFun✝, inj' := inj'✝ } { toFun := toFun, inj' := inj' }\n⊢ Eq toFun✝ toFun","decl":"/-- `α ↪ β` is a bundled injective function. -/\nstructure Embedding (α : Sort*) (β : Sort*) where\n  /-- An embedding as a function. Use coercion instead. -/\n  toFun : α → β\n  /-- An embedding is an injective function. Use `Function.Embedding.injective` instead. -/\n  inj' : Injective toFun\n\n"}
{"name":"Function.instEmbeddingLikeEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\n⊢ EmbeddingLike (Function.Embedding α β) α β","decl":"instance {α : Sort u} {β : Sort v} : EmbeddingLike (α ↪ β) α β where\n  injective' := Embedding.inj'\n\n"}
{"name":"Function.exists_surjective_iff","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Iff (Exists fun f => Function.Surjective f) (And (Nonempty (α → β)) (Nonempty (Function.Embedding β α)))","decl":"theorem exists_surjective_iff {α β : Sort*} :\n    (∃ f : α → β, Surjective f) ↔ Nonempty (α → β) ∧ Nonempty (β ↪ α) :=\n  ⟨fun ⟨f, h⟩ ↦ ⟨⟨f⟩, ⟨⟨_, injective_surjInv h⟩⟩⟩, fun ⟨h, ⟨e⟩⟩ ↦ (nonempty_fun.mp h).elim\n    (fun _ ↦ ⟨isEmptyElim, (isEmptyElim <| e ·)⟩) fun _ ↦ ⟨_, invFun_surjective e.inj'⟩⟩\n\n"}
{"name":"Function.instCanLiftForallEmbeddingCoeInjective","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ CanLift (α → β) (Function.Embedding α β) DFunLike.coe Function.Injective","decl":"instance {α β : Sort*} : CanLift (α → β) (α ↪ β) (↑) Injective where\n  prf _ h := ⟨⟨_, h⟩, rfl⟩\n\n"}
{"name":"Equiv.coe_toEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\n⊢ Eq ⇑f.toEmbedding ⇑f","decl":"@[simp]\ntheorem Equiv.coe_toEmbedding : (f.toEmbedding : α → β) = f :=\n  rfl\n\n"}
{"name":"Equiv.toEmbedding_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\na : α\n⊢ Eq (f.toEmbedding a) (f a)","decl":"theorem Equiv.toEmbedding_apply (a : α) : f.toEmbedding a = f a :=\n  rfl\n\n"}
{"name":"Equiv.toEmbedding_injective","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\n⊢ Function.Injective Equiv.toEmbedding","decl":"theorem Equiv.toEmbedding_injective : Function.Injective (Equiv.toEmbedding : (α ≃ β) → (α ↪ β)) :=\n  fun _ _ h ↦ by rwa [DFunLike.ext'_iff] at h ⊢\n\n"}
{"name":"Function.Embedding.coe_injective","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Function.Injective fun f => ⇑f","decl":"theorem coe_injective {α β} : @Injective (α ↪ β) (α → β) (fun f ↦ ↑f) :=\n  DFunLike.coe_injective\n\n"}
{"name":"Function.Embedding.ext","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf g : Function.Embedding α β\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {α β} {f g : Embedding α β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Function.Embedding.ext_iff","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf g : Function.Embedding α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext]\ntheorem ext {α β} {f g : Embedding α β} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"Function.Embedding.toFun_eq_coe","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\n⊢ Eq f.toFun ⇑f","decl":"@[simp]\ntheorem toFun_eq_coe {α β} (f : α ↪ β) : toFun f = f :=\n  rfl\n\n"}
{"name":"Function.Embedding.coeFn_mk","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : α → β\ni : Function.Injective f\n⊢ Eq (⇑{ toFun := f, inj' := i }) f","decl":"@[simp]\ntheorem coeFn_mk {α β} (f : α → β) (i) : (@mk _ _ f i : α → β) = f :=\n  rfl\n\n"}
{"name":"Function.Embedding.mk_coe","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\ninj : Function.Injective ⇑f\n⊢ Eq { toFun := ⇑f, inj' := inj } f","decl":"@[simp]\ntheorem mk_coe {α β : Type*} (f : α ↪ β) (inj) : (⟨f, inj⟩ : α ↪ β) = f :=\n  rfl\n\n"}
{"name":"Function.Embedding.injective","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\n⊢ Function.Injective ⇑f","decl":"protected theorem injective {α β} (f : α ↪ β) : Injective f :=\n  EmbeddingLike.injective f\n\n"}
{"name":"Function.Embedding.apply_eq_iff_eq","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\nx y : α\n⊢ Iff (Eq (f x) (f y)) (Eq x y)","decl":"theorem apply_eq_iff_eq {α β} (f : α ↪ β) (x y : α) : f x = f y ↔ x = y :=\n  EmbeddingLike.apply_eq_iff_eq f\n\n"}
{"name":"Function.Embedding.refl_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\na : α\n⊢ Eq ((Function.Embedding.refl α) a) a","decl":"/-- The identity map as a `Function.Embedding`. -/\n@[refl, simps (config := { simpRhs := true })]\nprotected def refl (α : Sort*) : α ↪ α :=\n  ⟨id, injective_id⟩\n\n"}
{"name":"Function.Embedding.trans_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : Function.Embedding α β\ng : Function.Embedding β γ\na✝ : α\n⊢ Eq ((f.trans g) a✝) (g (f a✝))","decl":"/-- Composition of `f : α ↪ β` and `g : β ↪ γ`. -/\n@[trans, simps (config := { simpRhs := true })]\nprotected def trans {α β γ} (f : α ↪ β) (g : β ↪ γ) : α ↪ γ :=\n  ⟨g ∘ f, g.injective.comp f.injective⟩\n\n"}
{"name":"Function.Embedding.mk_id","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\n⊢ Eq { toFun := id, inj' := ⋯ } (Function.Embedding.refl α)","decl":"@[simp] lemma mk_id {α} : mk id injective_id = .refl α := rfl\n\n"}
{"name":"Function.Embedding.mk_trans_mk","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nf : α → β\ng : β → γ\nhf : Function.Injective f\nhg : Function.Injective g\n⊢ Eq ({ toFun := f, inj' := hf }.trans { toFun := g, inj' := hg }) { toFun := Function.comp g f, inj' := ⋯ }","decl":"@[simp] lemma mk_trans_mk {α β γ} (f : α → β) (g : β → γ) (hf hg) :\n    (mk f hf).trans (mk g hg) = mk (g ∘ f) (hg.comp hf) := rfl\n\n"}
{"name":"Function.Embedding.equiv_toEmbedding_trans_symm_toEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ne : Equiv α β\n⊢ Eq (e.toEmbedding.trans e.symm.toEmbedding) (Function.Embedding.refl α)","decl":"@[simp]\ntheorem equiv_toEmbedding_trans_symm_toEmbedding {α β : Sort*} (e : α ≃ β) :\n    e.toEmbedding.trans e.symm.toEmbedding = Embedding.refl _ := by\n  ext\n  simp\n\n"}
{"name":"Function.Embedding.equiv_symm_toEmbedding_trans_toEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\ne : Equiv α β\n⊢ Eq (e.symm.toEmbedding.trans e.toEmbedding) (Function.Embedding.refl β)","decl":"@[simp]\ntheorem equiv_symm_toEmbedding_trans_toEmbedding {α β : Sort*} (e : α ≃ β) :\n    e.symm.toEmbedding.trans e.toEmbedding = Embedding.refl _ := by\n  ext\n  simp\n\n"}
{"name":"Function.Embedding.congr_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nδ : Sort x\ne₁ : Equiv α β\ne₂ : Equiv γ δ\nf : Function.Embedding α γ\n⊢ Eq (⇑(Function.Embedding.congr e₁ e₂ f)) (Function.comp ⇑(f.trans e₂.toEmbedding) ⇑e₁.symm)","decl":"/-- Transfer an embedding along a pair of equivalences. -/\n@[simps! (config := { fullyApplied := false, simpRhs := true })]\nprotected def congr {α : Sort u} {β : Sort v} {γ : Sort w} {δ : Sort x} (e₁ : α ≃ β) (e₂ : γ ≃ δ)\n    (f : α ↪ γ) : β ↪ δ :=\n  (Equiv.toEmbedding e₁.symm).trans (f.trans e₂.toEmbedding)\n\n"}
{"name":"Function.Embedding.setValue_eq","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\na : α\nb : β\ninst✝¹ : (a' : α) → Decidable (Eq a' a)\ninst✝ : (a' : α) → Decidable (Eq (f a') b)\n⊢ Eq ((f.setValue a b) a) b","decl":"@[simp]\ntheorem setValue_eq {α β} (f : α ↪ β) (a : α) (b : β) [∀ a', Decidable (a' = a)]\n    [∀ a', Decidable (f a' = b)] : setValue f a b a = b := by\n  simp [setValue]\n\n"}
{"name":"Function.Embedding.setValue_eq_iff","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\na a' : α\nb : β\ninst✝¹ : (a' : α) → Decidable (Eq a' a)\ninst✝ : (a' : α) → Decidable (Eq (f a') b)\n⊢ Iff (Eq ((f.setValue a b) a') b) (Eq a' a)","decl":"@[simp]\ntheorem setValue_eq_iff {α β} (f : α ↪ β) {a a' : α} {b : β} [∀ a', Decidable (a' = a)]\n    [∀ a', Decidable (f a' = b)] : setValue f a b a' = b ↔ a' = a :=\n  (setValue f a b).injective.eq_iff' <| setValue_eq ..\n\n"}
{"name":"Function.Embedding.setValue_eq_of_ne","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\na : α\nb : β\nc : α\ninst✝¹ : (a' : α) → Decidable (Eq a' a)\ninst✝ : (a' : α) → Decidable (Eq (f a') b)\nhc : Ne c a\nhb : Ne (f c) b\n⊢ Eq ((f.setValue a b) c) (f c)","decl":"lemma setValue_eq_of_ne {α β} {f : α ↪ β} {a : α} {b : β} {c : α} [∀ a', Decidable (a' = a)]\n    [∀ a', Decidable (f a' = b)] (hc : c ≠ a) (hb : f c ≠ b) : setValue f a b c = f c := by\n  simp [setValue, hc, hb]\n\n"}
{"name":"Function.Embedding.setValue_right_apply_eq","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nf : Function.Embedding α β\na c : α\ninst✝¹ : (a' : α) → Decidable (Eq a' a)\ninst✝ : (a' : α) → Decidable (Eq (f a') (f c))\n⊢ Eq ((f.setValue a (f c)) c) (f a)","decl":"@[simp]\nlemma setValue_right_apply_eq {α β} (f : α ↪ β) (a c : α) [∀ a', Decidable (a' = a)]\n    [∀ a', Decidable (f a' = f c)] : setValue f a (f c) c = f a := by\n  simp [setValue]\n\n"}
{"name":"Function.Embedding.some_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\n⊢ Eq (⇑Function.Embedding.some) Option.some","decl":"/-- Embedding into `Option α` using `some`. -/\n@[simps (config := .asFn)]\nprotected def some {α} : α ↪ Option α :=\n  ⟨some, Option.some_injective α⟩\n\n-- Porting note: Lean 4 unfolds coercion `α → Option α` to `some`, so there is no separate\n-- `Function.Embedding.coeOption`.\n\n"}
{"name":"Function.Embedding.optionMap_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Function.Embedding α β\n⊢ Eq (⇑f.optionMap) (Option.map ⇑f)","decl":"/-- A version of `Option.map` for `Function.Embedding`s. -/\n@[simps (config := .asFn)]\ndef optionMap {α β} (f : α ↪ β) : Option α ↪ Option β :=\n  ⟨Option.map f, Option.map_injective f.injective⟩\n\n"}
{"name":"Function.Embedding.coe_subtype","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Eq (⇑(Function.Embedding.subtype p)) Subtype.val","decl":"@[simp]\ntheorem coe_subtype {α} (p : α → Prop) : ↑(subtype p) = Subtype.val :=\n  rfl\n\n"}
{"name":"Function.Embedding.coe_quotientOut","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\ninst✝ : Setoid α\n⊢ Eq (⇑(Function.Embedding.quotientOut α)) Quotient.out","decl":"@[simp]\ntheorem coe_quotientOut (α) [Setoid α] : ↑(quotientOut α) = Quotient.out :=\n  rfl\n\n"}
{"name":"Function.Embedding.sectL_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\na : α\n⊢ Eq ((Function.Embedding.sectL α b) a) { fst := a, snd := b }","decl":"/-- Fixing an element `b : β` gives an embedding `α ↪ α × β`. -/\n@[simps]\ndef sectL (α : Sort _) {β : Sort _} (b : β) : α ↪ α × β :=\n  ⟨fun a => (a, b), fun _ _ h => congr_arg Prod.fst h⟩\n\n"}
{"name":"Function.Embedding.sectR_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\na : α\nβ : Type u_2\nb : β\n⊢ Eq ((Function.Embedding.sectR a β) b) { fst := a, snd := b }","decl":"/-- Fixing an element `a : α` gives an embedding `β ↪ α × β`. -/\n@[simps]\ndef sectR {α : Sort _} (a : α) (β : Sort _) : β ↪ α × β :=\n  ⟨fun b => (a, b), fun _ _ h => congr_arg Prod.snd h⟩\n\n"}
{"name":"Function.Embedding.sectl_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nb : β\na : α\n⊢ Eq ((Function.Embedding.sectL α b) a) { fst := a, snd := b }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectl_apply := sectL_apply\n"}
{"name":"Function.Embedding.sectr_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\na : α\nβ : Type u_2\nb : β\n⊢ Eq ((Function.Embedding.sectR a β) b) { fst := a, snd := b }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectr_apply := sectR_apply\n\n"}
{"name":"Function.Embedding.coe_prodMap","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne₁ : Function.Embedding α β\ne₂ : Function.Embedding γ δ\n⊢ Eq (⇑(e₁.prodMap e₂)) (Prod.map ⇑e₁ ⇑e₂)","decl":"@[simp]\ntheorem coe_prodMap {α β γ δ : Type*} (e₁ : α ↪ β) (e₂ : γ ↪ δ) :\n    e₁.prodMap e₂ = Prod.map e₁ e₂ :=\n  rfl\n\n"}
{"name":"Function.Embedding.coe_sumMap","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\ne₁ : Function.Embedding α β\ne₂ : Function.Embedding γ δ\n⊢ Eq (⇑(e₁.sumMap e₂)) (Sum.map ⇑e₁ ⇑e₂)","decl":"@[simp]\ntheorem coe_sumMap {α β γ δ} (e₁ : α ↪ β) (e₂ : γ ↪ δ) : sumMap e₁ e₂ = Sum.map e₁ e₂ :=\n  rfl\n\n"}
{"name":"Function.Embedding.inl_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nval : α\n⊢ Eq (Function.Embedding.inl val) (Sum.inl val)","decl":"/-- The embedding of `α` into the sum `α ⊕ β`. -/\n@[simps]\ndef inl {α β : Type*} : α ↪ α ⊕ β :=\n  ⟨Sum.inl, fun _ _ => Sum.inl.inj⟩\n\n"}
{"name":"Function.Embedding.inr_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nval : β\n⊢ Eq (Function.Embedding.inr val) (Sum.inr val)","decl":"/-- The embedding of `β` into the sum `α ⊕ β`. -/\n@[simps]\ndef inr {α β : Type*} : β ↪ α ⊕ β :=\n  ⟨Sum.inr, fun _ _ => Sum.inr.inj⟩\n\n"}
{"name":"Function.Embedding.sigmaMk_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_3\na : α\nsnd : β a\n⊢ Eq ((Function.Embedding.sigmaMk a) snd) ⟨a, snd⟩","decl":"/-- `Sigma.mk` as a `Function.Embedding`. -/\n@[simps apply]\ndef sigmaMk (a : α) : β a ↪ Σx, β x :=\n  ⟨Sigma.mk a, sigma_mk_injective⟩\n\n"}
{"name":"Function.Embedding.sigmaMap_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nα' : Type u_2\nβ : α → Type u_3\nβ' : α' → Type u_4\nf : Function.Embedding α α'\ng : (a : α) → Function.Embedding (β a) (β' (f a))\nx : Sigma fun a => β a\n⊢ Eq ((f.sigmaMap g) x) (Sigma.map (⇑f) (fun a => ⇑(g a)) x)","decl":"/-- If `f : α ↪ α'` is an embedding and `g : Π a, β α ↪ β' (f α)` is a family\nof embeddings, then `Sigma.map f g` is an embedding. -/\n@[simps apply]\ndef sigmaMap (f : α ↪ α') (g : ∀ a, β a ↪ β' (f a)) : (Σa, β a) ↪ Σa', β' a' :=\n  ⟨Sigma.map f fun a => g a, f.injective.sigma_map fun a => (g a).injective⟩\n\n"}
{"name":"Function.Embedding.piCongrRight_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nγ : α → Sort u_3\ne : (a : α) → Function.Embedding (β a) (γ a)\nf : (a : α) → β a\na : α\n⊢ Eq ((Function.Embedding.piCongrRight e) f a) ((e a) (f a))","decl":"/-- Define an embedding `(Π a : α, β a) ↪ (Π a : α, γ a)` from a family of embeddings\n`e : Π a, (β a ↪ γ a)`. This embedding sends `f` to `fun a ↦ e a (f a)`. -/\n@[simps]\ndef piCongrRight {α : Sort*} {β γ : α → Sort*} (e : ∀ a, β a ↪ γ a) : (∀ a, β a) ↪ ∀ a, γ a :=\n  ⟨fun f a => e a (f a), fun _ _ h => funext fun a => (e a).injective (congr_fun h a)⟩\n\n"}
{"name":"Function.Embedding.arrowCongrRight_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ne : Function.Embedding α β\nf : γ → α\n⊢ Eq (e.arrowCongrRight f) (Function.comp (⇑e) f)","decl":"@[simp]\ntheorem arrowCongrRight_apply {α : Sort u} {β : Sort v} {γ : Sort w} (e : α ↪ β) (f : γ → α) :\n    arrowCongrRight e f = e ∘ f :=\n  rfl\n\n"}
{"name":"Function.Embedding.swap_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\nx y z : α\n⊢ Eq ((Equiv.swap (f x) (f y)) (f z)) (f ((Equiv.swap x y) z))","decl":"theorem swap_apply {α β : Type*} [DecidableEq α] [DecidableEq β] (f : α ↪ β) (x y z : α) :\n    Equiv.swap (f x) (f y) (f z) = f (Equiv.swap x y z) :=\n  f.injective.swap_apply x y z\n\n"}
{"name":"Function.Embedding.swap_comp","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : Function.Embedding α β\nx y : α\n⊢ Eq (Function.comp ⇑(Equiv.swap (f x) (f y)) ⇑f) (Function.comp ⇑f ⇑(Equiv.swap x y))","decl":"theorem swap_comp {α β : Type*} [DecidableEq α] [DecidableEq β] (f : α ↪ β) (x y : α) :\n    Equiv.swap (f x) (f y) ∘ f = f ∘ Equiv.swap x y :=\n  f.injective.swap_comp x y\n\n"}
{"name":"Equiv.asEmbedding_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"β : Sort u_1\nα : Sort u_2\np : β → Prop\ne : Equiv α (Subtype p)\na✝ : α\n⊢ Eq (e.asEmbedding a✝) ↑(e a✝)","decl":"/-- Given an equivalence to a subtype, produce an embedding to the elements of the corresponding\nset. -/\n@[simps!]\ndef asEmbedding {β α : Sort*} {p : β → Prop} (e : α ≃ Subtype p) : α ↪ β :=\n  e.toEmbedding.trans (subtype p)\n\n"}
{"name":"Equiv.embeddingCongr_apply","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nδ : Sort u_4\nh : Equiv α β\nh' : Equiv γ δ\nf : Function.Embedding α γ\n⊢ Eq ((h.embeddingCongr h') f) (Function.Embedding.congr h h' f)","decl":"/-- If `α₁ ≃ α₂` and `β₁ ≃ β₂`, then the type of embeddings `α₁ ↪ β₁`\nis equivalent to the type of embeddings `α₂ ↪ β₂`. -/\n@[simps apply]\ndef embeddingCongr {α β γ δ : Sort*} (h : α ≃ β) (h' : γ ≃ δ) : (α ↪ γ) ≃ (β ↪ δ) where\n  toFun f := f.congr h h'\n  invFun f := f.congr h.symm h'.symm\n  left_inv x := by\n    ext\n    simp\n  right_inv x := by\n    ext\n    simp\n\n"}
{"name":"Equiv.embeddingCongr_refl","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Eq ((Equiv.refl α).embeddingCongr (Equiv.refl β)) (Equiv.refl (Function.Embedding α β))","decl":"@[simp]\ntheorem embeddingCongr_refl {α β : Sort*} :\n    embeddingCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (α ↪ β) :=\n  rfl\n\n"}
{"name":"Equiv.embeddingCongr_trans","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α₁ : Sort u_1\nβ₁ : Sort u_2\nα₂ : Sort u_3\nβ₂ : Sort u_4\nα₃ : Sort u_5\nβ₃ : Sort u_6\ne₁ : Equiv α₁ α₂\ne₁' : Equiv β₁ β₂\ne₂ : Equiv α₂ α₃\ne₂' : Equiv β₂ β₃\n⊢ Eq ((e₁.trans e₂).embeddingCongr (e₁'.trans e₂')) ((e₁.embeddingCongr e₁').trans (e₂.embeddingCongr e₂'))","decl":"@[simp]\ntheorem embeddingCongr_trans {α₁ β₁ α₂ β₂ α₃ β₃ : Sort*} (e₁ : α₁ ≃ α₂) (e₁' : β₁ ≃ β₂)\n    (e₂ : α₂ ≃ α₃) (e₂' : β₂ ≃ β₃) :\n    embeddingCongr (e₁.trans e₂) (e₁'.trans e₂') =\n      (embeddingCongr e₁ e₁').trans (embeddingCongr e₂ e₂') :=\n  rfl\n\n"}
{"name":"Equiv.embeddingCongr_symm","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α₁ : Sort u_1\nβ₁ : Sort u_2\nα₂ : Sort u_3\nβ₂ : Sort u_4\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\n⊢ Eq (e₁.embeddingCongr e₂).symm (e₁.symm.embeddingCongr e₂.symm)","decl":"@[simp]\ntheorem embeddingCongr_symm {α₁ β₁ α₂ β₂ : Sort*} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) :\n    (embeddingCongr e₁ e₂).symm = embeddingCongr e₁.symm e₂.symm :=\n  rfl\n\n"}
{"name":"Equiv.embeddingCongr_apply_trans","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α₁ : Sort u_1\nβ₁ : Sort u_2\nγ₁ : Sort u_3\nα₂ : Sort u_4\nβ₂ : Sort u_5\nγ₂ : Sort u_6\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\nec : Equiv γ₁ γ₂\nf : Function.Embedding α₁ β₁\ng : Function.Embedding β₁ γ₁\n⊢ Eq ((ea.embeddingCongr ec) (f.trans g)) (((ea.embeddingCongr eb) f).trans ((eb.embeddingCongr ec) g))","decl":"theorem embeddingCongr_apply_trans {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort*} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂)\n    (ec : γ₁ ≃ γ₂) (f : α₁ ↪ β₁) (g : β₁ ↪ γ₁) :\n    Equiv.embeddingCongr ea ec (f.trans g) =\n      (Equiv.embeddingCongr ea eb f).trans (Equiv.embeddingCongr eb ec g) := by\n  ext\n  simp\n\n"}
{"name":"Equiv.refl_toEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.refl α).toEmbedding (Function.Embedding.refl α)","decl":"@[simp]\ntheorem refl_toEmbedding {α : Type*} : (Equiv.refl α).toEmbedding = Embedding.refl α :=\n  rfl\n\n"}
{"name":"Equiv.trans_toEmbedding","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne : Equiv α β\nf : Equiv β γ\n⊢ Eq (e.trans f).toEmbedding (e.toEmbedding.trans f.toEmbedding)","decl":"@[simp]\ntheorem trans_toEmbedding {α β γ : Type*} (e : α ≃ β) (f : β ≃ γ) :\n    (e.trans f).toEmbedding = e.toEmbedding.trans f.toEmbedding :=\n  rfl\n\n"}
{"name":"subtypeOrLeftEmbedding_apply_left","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝ : DecidablePred p\nx : Subtype fun x => Or (p x) (q x)\nhx : p ↑x\n⊢ Eq ((subtypeOrLeftEmbedding p q) x) (Sum.inl ⟨↑x, hx⟩)","decl":"theorem subtypeOrLeftEmbedding_apply_left {p q : α → Prop} [DecidablePred p]\n    (x : { x // p x ∨ q x }) (hx : p x) :\n    subtypeOrLeftEmbedding p q x = Sum.inl ⟨x, hx⟩ :=\n  dif_pos hx\n\n"}
{"name":"subtypeOrLeftEmbedding_apply_right","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝ : DecidablePred p\nx : Subtype fun x => Or (p x) (q x)\nhx : Not (p ↑x)\n⊢ Eq ((subtypeOrLeftEmbedding p q) x) (Sum.inr ⟨↑x, ⋯⟩)","decl":"theorem subtypeOrLeftEmbedding_apply_right {p q : α → Prop} [DecidablePred p]\n    (x : { x // p x ∨ q x }) (hx : ¬p x) :\n    subtypeOrLeftEmbedding p q x = Sum.inr ⟨x, x.prop.resolve_left hx⟩ :=\n  dif_neg hx\n\n"}
{"name":"Subtype.impEmbedding_apply_coe","module":"Mathlib.Logic.Embedding.Basic","initialProofState":"α : Type u_1\np q : α → Prop\nh : ∀ (x : α), p x → q x\nx : Subtype fun x => p x\n⊢ Eq ↑((Subtype.impEmbedding p q h) x) ↑x","decl":"/-- A subtype `{x // p x}` can be injectively sent to into a subtype `{x // q x}`,\nif `p x → q x` for all `x : α`. -/\n@[simps]\ndef Subtype.impEmbedding (p q : α → Prop) (h : ∀ x, p x → q x) : { x // p x } ↪ { x // q x } :=\n  ⟨fun x => ⟨x, h x x.prop⟩, fun x y => by simp [Subtype.ext_iff]⟩\n\n"}
