{"name":"Option.id_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"α : Type u_1\nx : Option α\n⊢ Eq (Option.traverse Pure.pure x) x","decl":"theorem Option.id_traverse {α} (x : Option α) : Option.traverse (pure : α → Id α) x = x := by\n  cases x <;> rfl\n\n"}
{"name":"Option.comp_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F G : Type u → Type u\ninst✝² : Applicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα : Type u_1\nβ γ : Type u\nf : β → F γ\ng : α → G β\nx : Option α\n⊢ Eq (Option.traverse (Function.comp Functor.Comp.mk (Function.comp (fun x => Functor.map f x) g)) x) (Functor.Comp.mk (Functor.map (Option.traverse f) (Option.traverse g x)))","decl":"theorem Option.comp_traverse {α β γ} (f : β → F γ) (g : α → G β) (x : Option α) :\n    Option.traverse (Comp.mk ∘ (f <$> ·) ∘ g) x =\n      Comp.mk (Option.traverse f <$> Option.traverse g x) := by\n  cases x <;> (simp! [functor_norm] <;> rfl)\n\n"}
{"name":"Option.traverse_eq_map_id","module":"Mathlib.Control.Traversable.Instances","initialProofState":"α β : Type u_1\nf : α → β\nx : Option α\n⊢ Eq (Option.traverse (Function.comp Pure.pure f) x) (Pure.pure (Functor.map f x))","decl":"theorem Option.traverse_eq_map_id {α β} (f : α → β) (x : Option α) :\n    Option.traverse ((pure : _ → Id _) ∘ f) x = (pure : _ → Id _) (f <$> x) := by cases x <;> rfl\n\n"}
{"name":"Option.naturality","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative G\nη : ApplicativeTransformation F G\ninst✝ : LawfulApplicative F\nα : Type u_1\nβ : Type u\nf : α → F β\nx : Option α\n⊢ Eq ((fun {α} => η.app α) (Option.traverse f x)) (Option.traverse (Function.comp (fun {α} => η.app α) f) x)","decl":"theorem Option.naturality [LawfulApplicative F] {α β} (f : α → F β) (x : Option α) :\n    η (Option.traverse f x) = Option.traverse (@η _ ∘ f) x := by\n  -- Porting note: added `ApplicativeTransformation` theorems\n  cases' x with x <;> simp! [*, functor_norm, ApplicativeTransformation.preserves_map,\n    ApplicativeTransformation.preserves_seq, ApplicativeTransformation.preserves_pure]\n\n"}
{"name":"instLawfulTraversableOption","module":"Mathlib.Control.Traversable.Instances","initialProofState":"⊢ LawfulTraversable Option","decl":"instance : LawfulTraversable Option :=\n  { show LawfulMonad Option from inferInstance with\n    id_traverse := Option.id_traverse\n    comp_traverse := Option.comp_traverse\n    traverse_eq_map_id := Option.traverse_eq_map_id\n    naturality := fun η _ _ f x => Option.naturality η f x }\n\n"}
{"name":"List.id_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"α : Type u_1\nxs : List α\n⊢ Eq (List.traverse Pure.pure xs) xs","decl":"protected theorem id_traverse {α} (xs : List α) : List.traverse (pure : α → Id α) xs = xs := by\n  induction xs <;> simp! [*, List.traverse, functor_norm]; rfl\n\n"}
{"name":"List.comp_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F G : Type u → Type u\ninst✝² : Applicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα : Type u_1\nβ γ : Type u\nf : β → F γ\ng : α → G β\nx : List α\n⊢ Eq (List.traverse (Function.comp Functor.Comp.mk (Function.comp (fun x => Functor.map f x) g)) x) (Functor.Comp.mk (Functor.map (List.traverse f) (List.traverse g x)))","decl":"protected theorem comp_traverse {α β γ} (f : β → F γ) (g : α → G β) (x : List α) :\n    List.traverse (Comp.mk ∘ (f <$> ·) ∘ g) x =\n    Comp.mk (List.traverse f <$> List.traverse g x) := by\n  induction x <;> simp! [*, functor_norm] <;> rfl\n\n"}
{"name":"List.traverse_eq_map_id","module":"Mathlib.Control.Traversable.Instances","initialProofState":"α β : Type u_1\nf : α → β\nx : List α\n⊢ Eq (List.traverse (Function.comp Pure.pure f) x) (Pure.pure (Functor.map f x))","decl":"protected theorem traverse_eq_map_id {α β} (f : α → β) (x : List α) :\n    List.traverse ((pure : _ → Id _) ∘ f) x = (pure : _ → Id _) (f <$> x) := by\n  induction x <;> simp! [*, functor_norm]; rfl\n\n"}
{"name":"List.naturality","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative G\ninst✝ : LawfulApplicative F\nη : ApplicativeTransformation F G\nα : Type u_1\nβ : Type u\nf : α → F β\nx : List α\n⊢ Eq ((fun {α} => η.app α) (List.traverse f x)) (List.traverse (Function.comp (fun {α} => η.app α) f) x)","decl":"protected theorem naturality {α β} (f : α → F β) (x : List α) :\n    η (List.traverse f x) = List.traverse (@η _ ∘ f) x := by\n  -- Porting note: added `ApplicativeTransformation` theorems\n  induction x <;> simp! [*, functor_norm, ApplicativeTransformation.preserves_map,\n    ApplicativeTransformation.preserves_seq, ApplicativeTransformation.preserves_pure]\n\n"}
{"name":"List.instLawfulTraversable","module":"Mathlib.Control.Traversable.Instances","initialProofState":"⊢ LawfulTraversable List","decl":"instance : LawfulTraversable.{u} List :=\n  { show LawfulMonad List from inferInstance with\n    id_traverse := List.id_traverse\n    comp_traverse := List.comp_traverse\n    traverse_eq_map_id := List.traverse_eq_map_id\n    naturality := List.naturality }\n\n"}
{"name":"List.traverse_nil","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F : Type u → Type u\ninst✝ : Applicative F\nα' β' : Type u\nf : α' → F β'\n⊢ Eq (Traversable.traverse f List.nil) (Pure.pure List.nil)","decl":"@[simp]\ntheorem traverse_nil : traverse f ([] : List α') = (pure [] : F (List β')) :=\n  rfl\n\n"}
{"name":"List.traverse_cons","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F : Type u → Type u\ninst✝ : Applicative F\nα' β' : Type u\nf : α' → F β'\na : α'\nl : List α'\n⊢ Eq (Traversable.traverse f (List.cons a l)) (Seq.seq (Functor.map (fun x1 x2 => List.cons x1 x2) (f a)) fun x => Traversable.traverse f l)","decl":"@[simp]\ntheorem traverse_cons (a : α') (l : List α') :\n    traverse f (a :: l) = (· :: ·) <$> f a <*> traverse f l :=\n  rfl\n\n"}
{"name":"List.traverse_append","module":"Mathlib.Control.Traversable.Instances","initialProofState":"F : Type u → Type u\ninst✝¹ : Applicative F\nα' β' : Type u\nf : α' → F β'\ninst✝ : LawfulApplicative F\nas bs : List α'\n⊢ Eq (Traversable.traverse f (HAppend.hAppend as bs)) (Seq.seq (Functor.map (fun x1 x2 => HAppend.hAppend x1 x2) (Traversable.traverse f as)) fun x => Traversable.traverse f bs)","decl":"@[simp]\ntheorem traverse_append :\n    ∀ as bs : List α', traverse f (as ++ bs) = (· ++ ·) <$> traverse f as <*> traverse f bs\n  | [], bs => by simp [functor_norm]\n  | a :: as, bs => by simp [traverse_append as bs, functor_norm]; congr\n\n"}
{"name":"List.mem_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"α' β' : Type u\nf : α' → Set β'\nl : List α'\nn : List β'\n⊢ Iff (Membership.mem (Traversable.traverse f l) n) (List.Forall₂ (fun b a => Membership.mem (f a) b) n l)","decl":"theorem mem_traverse {f : α' → Set β'} :\n    ∀ (l : List α') (n : List β'), n ∈ traverse f l ↔ Forall₂ (fun b a => b ∈ f a) n l\n  | [], [] => by simp\n  | a :: as, [] => by simp\n  | [], b :: bs => by simp\n  | a :: as, b :: bs => by simp [mem_traverse as bs]\n\n"}
{"name":"Sum.traverse_map","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ : Type u\nG : Type u → Type u\ninst✝ : Applicative G\nα β γ : Type u\ng : α → β\nf : β → G γ\nx : Sum σ α\n⊢ Eq (Sum.traverse f (Functor.map g x)) (Sum.traverse (Function.comp f g) x)","decl":"protected theorem traverse_map {α β γ : Type u} (g : α → β) (f : β → G γ) (x : σ ⊕ α) :\n    Sum.traverse f (g <$> x) = Sum.traverse (f ∘ g) x := by\n  cases x <;> simp [Sum.traverse, id_map, functor_norm] <;> rfl\n\n"}
{"name":"Sum.id_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ α : Type u_1\nx : Sum σ α\n⊢ Eq (Sum.traverse Pure.pure x) x","decl":"protected theorem id_traverse {σ α} (x : σ ⊕ α) :\n    Sum.traverse (pure : α → Id α) x = x := by cases x <;> rfl\n\n"}
{"name":"Sum.comp_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ : Type u\nF G : Type u → Type u\ninst✝² : Applicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β γ : Type u\nf : β → F γ\ng : α → G β\nx : Sum σ α\n⊢ Eq (Sum.traverse (Function.comp Functor.Comp.mk (Function.comp (fun x => Functor.map f x) g)) x) (Functor.Comp.mk (Functor.map (Sum.traverse f) (Sum.traverse g x)))","decl":"protected theorem comp_traverse {α β γ : Type u} (f : β → F γ) (g : α → G β) (x : σ ⊕ α) :\n    Sum.traverse (Comp.mk ∘ (f <$> ·) ∘ g) x =\n    Comp.mk.{u} (Sum.traverse f <$> Sum.traverse g x) := by\n  cases x <;> (simp! [Sum.traverse, map_id, functor_norm] <;> rfl)\n\n"}
{"name":"Sum.traverse_eq_map_id","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ α β : Type u\nf : α → β\nx : Sum σ α\n⊢ Eq (Sum.traverse (Function.comp Pure.pure f) x) (Pure.pure (Functor.map f x))","decl":"protected theorem traverse_eq_map_id {α β} (f : α → β) (x : σ ⊕ α) :\n    Sum.traverse ((pure : _ → Id _) ∘ f) x = (pure : _ → Id _) (f <$> x) := by\n  induction x <;> simp! [*, functor_norm] <;> rfl\n\n"}
{"name":"Sum.map_traverse","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ : Type u\nG : Type u → Type u\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα : Type u_1\nβ γ : Type u\ng : α → G β\nf : β → γ\nx : Sum σ α\n⊢ Eq (Functor.map (fun x => Functor.map f x) (Sum.traverse g x)) (Sum.traverse (fun x => Functor.map f (g x)) x)","decl":"protected theorem map_traverse {α β γ} (g : α → G β) (f : β → γ) (x : σ ⊕ α) :\n    (f <$> ·) <$> Sum.traverse g x = Sum.traverse (f <$> g ·) x := by\n  cases x <;> simp [Sum.traverse, id_map, functor_norm] <;> congr\n\n"}
{"name":"Sum.naturality","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ : Type u\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative G\ninst✝ : LawfulApplicative F\nη : ApplicativeTransformation F G\nα : Type u_1\nβ : Type u\nf : α → F β\nx : Sum σ α\n⊢ Eq ((fun {α} => η.app α) (Sum.traverse f x)) (Sum.traverse (Function.comp (fun {α} => η.app α) f) x)","decl":"protected theorem naturality {α β} (f : α → F β) (x : σ ⊕ α) :\n    η (Sum.traverse f x) = Sum.traverse (@η _ ∘ f) x := by\n  -- Porting note: added `ApplicativeTransformation` theorems\n  cases x <;> simp! [Sum.traverse, functor_norm, ApplicativeTransformation.preserves_map,\n    ApplicativeTransformation.preserves_seq, ApplicativeTransformation.preserves_pure]\n\n"}
{"name":"Sum.instLawfulTraversable","module":"Mathlib.Control.Traversable.Instances","initialProofState":"σ : Type u\n⊢ LawfulTraversable (Sum σ)","decl":"instance {σ : Type u} : LawfulTraversable.{u} (Sum σ) :=\n  { show LawfulMonad (Sum σ) from inferInstance with\n    id_traverse := Sum.id_traverse\n    comp_traverse := Sum.comp_traverse\n    traverse_eq_map_id := Sum.traverse_eq_map_id\n    naturality := Sum.naturality }\n\n"}
