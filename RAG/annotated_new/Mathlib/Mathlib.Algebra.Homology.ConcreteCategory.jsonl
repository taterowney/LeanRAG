{"name":"HomologicalComplex.i_cyclesMk","module":"Mathlib.Algebra.Homology.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.HasForget₂ C Ab\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : (CategoryTheory.forget₂ C Ab).Additive\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nι : Type u_1\nc : ComplexShape ι\nK : HomologicalComplex C c\ni : ι\nx : ↑((CategoryTheory.forget₂ C Ab).obj (K.X i))\nj : ι\nhj : Eq (c.next i) j\nhx : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (K.d i j))) x) 0\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (K.iCycles i))) (K.cyclesMk x j hj hx)) x","decl":"@[simp]\nlemma i_cyclesMk {i : ι} (x : (forget₂ C Ab).obj (K.X i)) (j : ι) (hj : c.next i = j)\n    (hx : ((forget₂ C Ab).map (K.d i j)) x = 0) :\n    ((forget₂ C Ab).map (K.iCycles i)) (K.cyclesMk x j hj hx) = x := by\n  subst hj\n  apply (K.sc i).i_cyclesMk\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_apply'","module":"Mathlib.Algebra.Homology.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.HasForget₂ C Ab\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : (CategoryTheory.forget₂ C Ab).Additive\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nι : Type u_1\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nx₃ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₃.homology i))\nx₂ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₂.opcycles i))\nx₁ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₁.cycles j))\nh₂ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (HomologicalComplex.opcyclesMap S.g i))) x₂) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₃.homologyι i))) x₃)\nh₁ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (HomologicalComplex.cyclesMap S.f j))) x₁) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₂.opcyclesToCycles i j))) x₂)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (hS.δ i j hij))) x₃) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₁.homologyπ j))) x₁)","decl":"lemma δ_apply' (x₃ : (forget₂ C Ab).obj (S.X₃.homology i))\n    (x₂ : (forget₂ C Ab).obj (S.X₂.opcycles i))\n    (x₁ : (forget₂ C Ab).obj (S.X₁.cycles j))\n    (h₂ : (forget₂ C Ab).map (HomologicalComplex.opcyclesMap S.g i) x₂ =\n      (forget₂ C Ab).map (S.X₃.homologyι i) x₃)\n    (h₁ : (forget₂ C Ab).map (HomologicalComplex.cyclesMap S.f j) x₁ =\n      (forget₂ C Ab).map (S.X₂.opcyclesToCycles i j) x₂) :\n    (forget₂ C Ab).map (hS.δ i j hij) x₃ = (forget₂ C Ab).map (S.X₁.homologyπ j) x₁ :=\n  (HomologicalComplex.HomologySequence.snakeInput hS i j hij).δ_apply' x₃ x₂ x₁ h₂ h₁\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_apply","module":"Mathlib.Algebra.Homology.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.HasForget₂ C Ab\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : (CategoryTheory.forget₂ C Ab).Additive\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nι : Type u_1\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nx₃ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₃.X i))\nhx₃ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₃.d i j))) x₃) 0\nx₂ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₂.X i))\nhx₂ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.g.f i))) x₂) x₃\nx₁ : ↑((CategoryTheory.forget₂ C Ab).obj (S.X₁.X j))\nhx₁ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.f.f j))) x₁) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₂.d i j))) x₂)\nk : ι\nhk : Eq (c.next j) k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (hS.δ i j hij))) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₃.homologyπ i))) (S.X₃.cyclesMk x₃ j ⋯ hx₃))) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map (S.X₁.homologyπ j))) (S.X₁.cyclesMk x₁ k hk ⋯))","decl":"lemma δ_apply (x₃ : (forget₂ C Ab).obj (S.X₃.X i))\n    (hx₃ : (forget₂ C Ab).map (S.X₃.d i j) x₃ = 0)\n    (x₂ : (forget₂ C Ab).obj (S.X₂.X i)) (hx₂ : (forget₂ C Ab).map (S.g.f i) x₂ = x₃)\n    (x₁ : (forget₂ C Ab).obj (S.X₁.X j))\n    (hx₁ : (forget₂ C Ab).map (S.f.f j) x₁ = (forget₂ C Ab).map (S.X₂.d i j) x₂)\n    (k : ι) (hk : c.next j = k) :\n    (forget₂ C Ab).map (hS.δ i j hij)\n      ((forget₂ C Ab).map (S.X₃.homologyπ i) (S.X₃.cyclesMk x₃ j (c.next_eq' hij) hx₃)) =\n        (forget₂ C Ab).map (S.X₁.homologyπ j) (S.X₁.cyclesMk x₁ k hk (by\n          have := hS.mono_f\n          apply (Preadditive.mono_iff_injective (S.f.f k)).1 inferInstance\n          -- Since `C` is only a `HasForget`, not a `ConcreteCategory` (for now),\n          -- we need to rewrite everything to `HasForget`.\n          have : ∀ {X Y : Ab} (f : X ⟶ Y), (f : X → Y) =\n            @DFunLike.coe _ _ _ (HasForget.toFunLike _ _ _) f := by intros; ext; rfl\n          rw [this, this, ← forget₂_comp_apply, ← HomologicalComplex.Hom.comm, forget₂_comp_apply,\n            ← this, ← this, hx₁, this, this,\n            ← forget₂_comp_apply, HomologicalComplex.d_comp_d, Functor.map_zero, ← this, ← this,\n            map_zero]; rfl)) := by\n  -- Since `C` is only a `HasForget`, not a `ConcreteCategory` (for now),\n  -- we need to rewrite everything to `HasForget`.\n  have : ∀ {X Y : Ab} (f : X ⟶ Y), (f : X → Y) =\n  @DFunLike.coe _ _ _ (HasForget.toFunLike _ _ _) f := by intros; ext; rfl\n  refine hS.δ_apply' i j hij _ ((forget₂ C Ab).map (S.X₂.pOpcycles i) x₂) _ ?_ ?_\n  · rw [this, this, ← forget₂_comp_apply, this, this, ← forget₂_comp_apply,\n      HomologicalComplex.p_opcyclesMap, Functor.map_comp, CategoryTheory.comp_apply,\n      HomologicalComplex.homology_π_ι, forget₂_comp_apply, ← this, ← this, hx₂, ← this,\n      HomologicalComplex.i_cyclesMk]\n  · apply (Preadditive.mono_iff_injective (S.X₂.iCycles j)).1 inferInstance\n    conv_lhs =>\n      rw [this, this, ← forget₂_comp_apply, HomologicalComplex.cyclesMap_i, forget₂_comp_apply,\n        ← this ((forget₂ C Ab).map (S.X₁.iCycles j)), HomologicalComplex.i_cyclesMk, ← this, hx₁]\n    conv_rhs =>\n      rw [this, this, ← forget₂_comp_apply, this, ← forget₂_comp_apply,\n        HomologicalComplex.pOpcycles_opcyclesToCycles_assoc, HomologicalComplex.toCycles_i, ← this]\n\n"}
