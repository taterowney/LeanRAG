{"name":"fwdDiff_add","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf g : M → G\n⊢ Eq (fwdDiff h (HAdd.hAdd f g)) (HAdd.hAdd (fwdDiff h f) (fwdDiff h g))","decl":"@[simp] lemma fwdDiff_add (h : M) (f g : M → G) :\n    Δ_[h] (f + g) = Δ_[h] f + Δ_[h] g :=\n  add_sub_add_comm ..\n\n"}
{"name":"fwdDiff_const","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\ng : G\n⊢ Eq (fwdDiff h fun x => g) fun x => 0","decl":"@[simp] lemma fwdDiff_const (g : G) : Δ_[h] (fun _ ↦ g : M → G) = fun _ ↦ 0 :=\n  funext fun _ ↦ sub_self g\n\n"}
{"name":"fwdDiff_smul","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup G\nh : M\nR : Type\ninst✝¹ : Ring R\ninst✝ : Module R G\nf : M → R\ng : M → G\n⊢ Eq (fwdDiff h (HSMul.hSMul f g)) (HAdd.hAdd (HAdd.hAdd (HSMul.hSMul (fwdDiff h f) g) (HSMul.hSMul f (fwdDiff h g))) (HSMul.hSMul (fwdDiff h f) (fwdDiff h g)))","decl":"lemma fwdDiff_smul {R : Type} [Ring R] [Module R G] (f : M → R) (g : M → G) :\n    Δ_[h] (f • g) = Δ_[h] f • g + f • Δ_[h] g + Δ_[h] f • Δ_[h] g := by\n  ext y\n  simp only [fwdDiff, Pi.smul_apply', Pi.add_apply, smul_sub, sub_smul]\n  abel\n\n-- Note `fwdDiff_const_smul` is more general than `fwdDiff_smul` since it allows `R` to be a\n-- semiring, rather than a ring; in particular `R = ℕ` is allowed.\n"}
{"name":"fwdDiff_const_smul","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup G\nh : M\nR : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Module R G\nr : R\nf : M → G\n⊢ Eq (fwdDiff h (HSMul.hSMul r f)) (HSMul.hSMul r (fwdDiff h f))","decl":"@[simp] lemma fwdDiff_const_smul {R : Type*} [Semiring R] [Module R G] (r : R) (f : M → G) :\n    Δ_[h] (r • f) = r • Δ_[h] f :=\n  funext fun _ ↦ (smul_sub ..).symm\n\n"}
{"name":"fwdDiff_smul_const","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup G\nh : M\nR : Type\ninst✝¹ : Ring R\ninst✝ : Module R G\nf : M → R\ng : G\n⊢ Eq (fwdDiff h fun y => HSMul.hSMul (f y) g) (HSMul.hSMul (fwdDiff h f) fun x => g)","decl":"@[simp] lemma fwdDiff_smul_const {R : Type} [Ring R] [Module R G] (f : M → R) (g : G) :\n    Δ_[h] (fun y ↦ f y • g) = Δ_[h] f • fun _ ↦ g := by\n  ext y\n  simp only [fwdDiff, Pi.smul_apply', sub_smul]\n\n"}
{"name":"fwdDiff_aux.fwdDiffₗ_apply","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf : M → G\na✝ : M\n⊢ Eq ((fwdDiff_aux.fwdDiffₗ M G h) f a✝) (fwdDiff h f a✝)","decl":"variable (M G) in\n/-- Linear-endomorphism version of the forward difference operator. -/\n@[simps]\ndef fwdDiffₗ  : Module.End ℤ (M → G) where\n  toFun := fwdDiff h\n  map_add' := fwdDiff_add h\n  map_smul' := fwdDiff_const_smul h\n\n"}
{"name":"fwdDiff_aux.coe_fwdDiffₗ","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\n⊢ Eq (⇑(fwdDiff_aux.fwdDiffₗ M G h)) (fwdDiff h)","decl":"lemma coe_fwdDiffₗ : ↑(fwdDiffₗ M G h) = fwdDiff h := rfl\n\n"}
{"name":"fwdDiff_aux.coe_fwdDiffₗ_pow","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nn : Nat\n⊢ Eq (⇑(HPow.hPow (fwdDiff_aux.fwdDiffₗ M G h) n)) (Nat.iterate (fwdDiff h) n)","decl":"lemma coe_fwdDiffₗ_pow (n : ℕ) : ↑(fwdDiffₗ M G h ^ n) = (fwdDiff h)^[n] := by\n  ext; rw [LinearMap.pow_apply, coe_fwdDiffₗ]\n\n"}
{"name":"fwdDiff_aux.shiftₗ_apply","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf : M → G\ny : M\n⊢ Eq ((fwdDiff_aux.shiftₗ M G h) f y) (f (HAdd.hAdd y h))","decl":"lemma shiftₗ_apply (f : M → G) (y : M) : shiftₗ M G h f y = f (y + h) := by\n  rw [shiftₗ, LinearMap.add_apply, Pi.add_apply, LinearMap.one_apply, fwdDiffₗ_apply, fwdDiff,\n    sub_add_cancel]\n\n"}
{"name":"fwdDiff_aux.shiftₗ_pow_apply","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf : M → G\nk : Nat\ny : M\n⊢ Eq ((HPow.hPow (fwdDiff_aux.shiftₗ M G h) k) f y) (f (HAdd.hAdd y (HSMul.hSMul k h)))","decl":"lemma shiftₗ_pow_apply (f : M → G) (k : ℕ) (y : M) : (shiftₗ M G h ^ k) f y = f (y + k • h) := by\n  induction' k with k IH generalizing f\n  · simp only [pow_zero, LinearMap.one_apply, cast_zero, add_zero, zero_smul]\n  · simp only [pow_add, pow_one, LinearMap.mul_apply, IH (shiftₗ M G h f), shiftₗ_apply, add_assoc,\n      add_nsmul, one_smul]\n\n"}
{"name":"fwdDiff_finset_sum","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nα : Type u_3\ns : Finset α\nf : α → M → G\n⊢ Eq (fwdDiff h (s.sum fun k => f k)) (s.sum fun k => fwdDiff h (f k))","decl":"@[simp] lemma fwdDiff_finset_sum {α : Type*} (s : Finset α) (f : α → M → G) :\n    Δ_[h] (∑ k ∈ s, f k) = ∑ k ∈ s, Δ_[h] (f k) :=\n  map_sum (fwdDiffₗ M G h) f s\n\n"}
{"name":"fwdDiff_iter_add","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf g : M → G\nn : Nat\n⊢ Eq (Nat.iterate (fwdDiff h) n (HAdd.hAdd f g)) (HAdd.hAdd (Nat.iterate (fwdDiff h) n f) (Nat.iterate (fwdDiff h) n g))","decl":"@[simp] lemma fwdDiff_iter_add (f g : M → G) (n : ℕ) :\n    Δ_[h]^[n] (f + g) = Δ_[h]^[n] f + Δ_[h]^[n] g := by\n  simpa only [coe_fwdDiffₗ_pow] using map_add (fwdDiffₗ M G h ^ n) f g\n\n"}
{"name":"fwdDiff_iter_const_smul","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommGroup G\nh : M\nR : Type u_3\ninst✝¹ : Semiring R\ninst✝ : Module R G\nr : R\nf : M → G\nn : Nat\n⊢ Eq (Nat.iterate (fwdDiff h) n (HSMul.hSMul r f)) (HSMul.hSMul r (Nat.iterate (fwdDiff h) n f))","decl":"@[simp] lemma fwdDiff_iter_const_smul {R : Type*} [Semiring R] [Module R G]\n    (r : R) (f : M → G) (n : ℕ) : Δ_[h]^[n] (r • f) = r • Δ_[h]^[n] f := by\n  induction' n with n IH generalizing f\n  · simp only [iterate_zero, id_eq]\n  · simp only [iterate_succ_apply, fwdDiff_const_smul, IH]\n\n"}
{"name":"fwdDiff_iter_finset_sum","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nα : Type u_3\ns : Finset α\nf : α → M → G\nn : Nat\n⊢ Eq (Nat.iterate (fwdDiff h) n (s.sum fun k => f k)) (s.sum fun k => Nat.iterate (fwdDiff h) n (f k))","decl":"@[simp] lemma fwdDiff_iter_finset_sum {α : Type*} (s : Finset α) (f : α → M → G) (n : ℕ) :\n    Δ_[h]^[n] (∑ k ∈ s, f k) = ∑ k ∈ s, Δ_[h]^[n] (f k) := by\n  simpa only [coe_fwdDiffₗ_pow] using map_sum (fwdDiffₗ M G h ^ n) f s\n\n"}
{"name":"fwdDiff_iter_eq_sum_shift","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf : M → G\nn : Nat\ny : M\n⊢ Eq (Nat.iterate (fwdDiff h) n f y) ((Finset.range (HAdd.hAdd n 1)).sum fun k => HSMul.hSMul (HMul.hMul (HPow.hPow (-1) (HSub.hSub n k)) ↑(n.choose k)) (f (HAdd.hAdd y (HSMul.hSMul k h))))","decl":"/--\nExpress the `n`-th forward difference of `f` at `y` in terms of the values `f (y + k)`, for\n`0 ≤ k ≤ n`.\n-/\ntheorem fwdDiff_iter_eq_sum_shift (f : M → G) (n : ℕ) (y : M) :\n    Δ_[h]^[n] f y = ∑ k ∈ range (n + 1), ((-1 : ℤ) ^ (n - k) * n.choose k) • f (y + k • h) := by\n  -- rewrite in terms of `(shiftₗ - 1) ^ n`\n  have : fwdDiffₗ M G h = shiftₗ M G h - 1 := by simp only [shiftₗ, add_sub_cancel_right]\n  rw [← coe_fwdDiffₗ, this, ← LinearMap.pow_apply]\n  -- use binomial theorem `Commute.add_pow` to expand this\n  have : Commute (shiftₗ M G h) (-1) := (Commute.one_right _).neg_right\n  convert congr_fun (LinearMap.congr_fun (this.add_pow n) f) y using 3\n  · simp only [sub_eq_add_neg]\n  · rw [LinearMap.sum_apply, sum_apply]\n    congr 1 with k\n    have : ((-1) ^ (n - k) * n.choose k : Module.End ℤ (M → G))\n              = ↑((-1) ^ (n - k) * n.choose k : ℤ) := by norm_cast\n    rw [mul_assoc, LinearMap.mul_apply, this, Module.End.intCast_apply, LinearMap.map_smul,\n      Pi.smul_apply, shiftₗ_pow_apply]\n\n"}
{"name":"shift_eq_sum_fwdDiff_iter","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"M : Type u_1\nG : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommGroup G\nh : M\nf : M → G\nn : Nat\ny : M\n⊢ Eq (f (HAdd.hAdd y (HSMul.hSMul n h))) ((Finset.range (HAdd.hAdd n 1)).sum fun k => HSMul.hSMul (n.choose k) (Nat.iterate (fwdDiff h) k f y))","decl":"/--\n**Gregory-Newton formula** expressing `f (y + n • h)` in terms of the iterated forward differences\nof `f` at `y`.\n-/\ntheorem shift_eq_sum_fwdDiff_iter (f : M → G) (n : ℕ) (y : M) :\n    f (y + n • h) = ∑ k ∈ range (n + 1), n.choose k • Δ_[h]^[k] f y := by\n  convert congr_fun (LinearMap.congr_fun\n      ((Commute.one_right (fwdDiffₗ M G h)).add_pow n) f) y using 1\n  · rw [← shiftₗ_pow_apply h f, shiftₗ]\n  · simp only [LinearMap.sum_apply, sum_apply, one_pow, mul_one, LinearMap.mul_apply,\n      Module.End.natCast_apply, map_nsmul, Pi.smul_apply, LinearMap.pow_apply, coe_fwdDiffₗ]\n\n"}
{"name":"fwdDiff_choose","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"j : Nat\n⊢ Eq (fwdDiff 1 fun x => ↑(x.choose (HAdd.hAdd j 1))) fun x => ↑(x.choose j)","decl":"lemma fwdDiff_choose (j : ℕ) : Δ_[1] (fun x ↦ x.choose (j + 1) : ℕ → ℤ) = fun x ↦ x.choose j := by\n  ext n\n  simp only [fwdDiff, choose_succ_succ' n j, cast_add, add_sub_cancel_right]\n\n"}
{"name":"fwdDiff_iter_choose","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"j k : Nat\n⊢ Eq (Nat.iterate (fwdDiff 1) k fun x => ↑(x.choose (HAdd.hAdd k j))) fun x => ↑(x.choose j)","decl":"lemma fwdDiff_iter_choose (j k : ℕ) :\n    Δ_[1]^[k] (fun x ↦ x.choose (k + j) : ℕ → ℤ) = fun x ↦ x.choose j := by\n  induction' k with k IH generalizing j\n  · simp only [zero_add, iterate_zero, id_eq]\n  · simp only [Function.iterate_succ_apply', add_assoc, add_comm 1 j, IH, fwdDiff_choose]\n\n"}
{"name":"fwdDiff_iter_choose_zero","module":"Mathlib.Algebra.Group.ForwardDiff","initialProofState":"m n : Nat\n⊢ Eq (Nat.iterate (fwdDiff 1) n (fun x => ↑(x.choose m)) 0) (ite (Eq n m) 1 0)","decl":"lemma fwdDiff_iter_choose_zero (m n : ℕ) :\n    Δ_[1]^[n] (fun x ↦ x.choose m : ℕ → ℤ) 0 = if n = m then 1 else 0 := by\n  rcases lt_trichotomy m n with hmn | rfl | hnm\n  · rcases Nat.exists_eq_add_of_lt hmn with ⟨k, rfl⟩\n    simp_rw [hmn.ne', if_false, (by ring : m + k + 1 = k + 1 + m), iterate_add_apply,\n      add_zero m ▸ fwdDiff_iter_choose 0 m, choose_zero_right, iterate_one, cast_one, fwdDiff_const,\n      fwdDiff_iter_eq_sum_shift, smul_zero, sum_const_zero]\n  · simp only [if_true, add_zero m ▸ fwdDiff_iter_choose 0 m, choose_zero_right, cast_one]\n  · rcases Nat.exists_eq_add_of_lt hnm with ⟨k, rfl⟩\n    simp_rw [hnm.ne, if_false, add_assoc n k 1, fwdDiff_iter_choose, choose_zero_succ, cast_zero]\n\n"}
