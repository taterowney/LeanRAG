{"name":"instT2SpacePontryaginDual","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\n⊢ T2Space (PontryaginDual A)","decl":"instance : T2Space (PontryaginDual A) :=\n  (inferInstance : T2Space (ContinuousMonoidHom A Circle))\n\n-- Porting note: instance is now noncomputable\n"}
{"name":"instTopologicalGroupPontryaginDual","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\n⊢ TopologicalGroup (PontryaginDual A)","decl":"instance : TopologicalGroup (PontryaginDual A) :=\n  (inferInstance : TopologicalGroup (ContinuousMonoidHom A Circle))\n\n-- Porting note: instance is now noncomputable\n"}
{"name":"instLocallyCompactSpacePontryaginDual","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"H : Type u_5\ninst✝² : Group H\ninst✝¹ : TopologicalSpace H\ninst✝ : LocallyCompactSpace H\n⊢ LocallyCompactSpace (PontryaginDual H)","decl":"instance [LocallyCompactSpace H] : LocallyCompactSpace (PontryaginDual H) := by\n  let Vn : ℕ → Set Circle :=\n    fun n ↦ Circle.exp '' { x | |x| < Real.pi / 2 ^ (n + 1)}\n  have hVn : ∀ n x, x ∈ Vn n ↔ |Complex.arg x| < Real.pi / 2 ^ (n + 1) := by\n    refine fun n x ↦ ⟨?_, fun hx ↦ ⟨Complex.arg x, hx, Circle.exp_arg x⟩⟩\n    rintro ⟨t, ht : |t| < _, rfl⟩\n    have ht' := ht.trans_le (div_le_self Real.pi_nonneg (one_le_pow₀ one_le_two))\n    rwa [Circle.arg_exp (neg_lt_of_abs_lt ht') (lt_of_abs_lt ht').le]\n  refine ContinuousMonoidHom.locallyCompactSpace_of_hasBasis Vn ?_ ?_\n  · intro n x h1 h2\n    rw [hVn] at h1 h2 ⊢\n    rwa [Circle.coe_mul, Complex.arg_mul x.coe_ne_zero x.coe_ne_zero,\n      ← two_mul, abs_mul, abs_two, ← lt_div_iff₀' two_pos, div_div, ← pow_succ] at h2\n    apply Set.Ioo_subset_Ioc_self\n    rw [← two_mul, Set.mem_Ioo, ← abs_lt, abs_mul, abs_two, ← lt_div_iff₀' two_pos]\n    exact h1.trans_le\n      (div_le_div_of_nonneg_left Real.pi_nonneg two_pos (le_self_pow₀ one_le_two n.succ_ne_zero))\n  · rw [← Circle.exp_zero, ← isLocalHomeomorph_circleExp.map_nhds_eq 0]\n    refine ((nhds_basis_zero_abs_sub_lt ℝ).to_hasBasis\n        (fun x hx ↦ ⟨Nat.ceil (Real.pi / x), trivial, fun t ht ↦ ?_⟩)\n          fun k _ ↦ ⟨Real.pi / 2 ^ (k + 1), by positivity, le_rfl⟩).map Circle.exp\n    rw [Set.mem_setOf_eq] at ht ⊢\n    refine lt_of_lt_of_le ht ?_\n    rw [div_le_iff₀' (pow_pos two_pos _), ← div_le_iff₀ hx]\n    refine (Nat.le_ceil (Real.pi / x)).trans ?_\n    exact_mod_cast (Nat.le_succ _).trans Nat.lt_two_pow_self.le\n\n"}
{"name":"PontryaginDual.instContinuousMapClass","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\n⊢ ContinuousMapClass (PontryaginDual A) A Circle","decl":"noncomputable instance instContinuousMapClass : ContinuousMapClass (PontryaginDual A) A Circle :=\n  ContinuousMonoidHom.instContinuousMapClass\n\n"}
{"name":"PontryaginDual.instMonoidHomClass","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\n⊢ MonoidHomClass (PontryaginDual A) A Circle","decl":"noncomputable instance instMonoidHomClass : MonoidHomClass (PontryaginDual A) A Circle :=\n  ContinuousMonoidHom.instMonoidHomClass\n\n"}
{"name":"PontryaginDual.map_apply","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf : ContinuousMonoidHom A B\nx : PontryaginDual B\ny : A\n⊢ Eq (((PontryaginDual.map f) x) y) (x (f y))","decl":"@[simp]\ntheorem map_apply (f : ContinuousMonoidHom A B) (x : PontryaginDual B) (y : A) :\n    map f x y = x (f y) :=\n  rfl\n\n"}
{"name":"PontryaginDual.map_one","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Eq (PontryaginDual.map (ContinuousMonoidHom.one A B)) (ContinuousMonoidHom.one (PontryaginDual B) (PontryaginDual A))","decl":"@[simp]\ntheorem map_one : map (one A B) = one (PontryaginDual B) (PontryaginDual A) :=\n  ext fun x => ext (fun _y => OneHomClass.map_one x)\n\n"}
{"name":"PontryaginDual.map_comp","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\ng : ContinuousMonoidHom B C\nf : ContinuousMonoidHom A B\n⊢ Eq (PontryaginDual.map (g.comp f)) ((PontryaginDual.map f).comp (PontryaginDual.map g))","decl":"@[simp]\ntheorem map_comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) :\n    map (comp g f) = ContinuousMonoidHom.comp (map f) (map g) :=\n  ext fun _x => ext fun _y => rfl\n\n"}
{"name":"PontryaginDual.map_mul","module":"Mathlib.Topology.Algebra.PontryaginDual","initialProofState":"A : Type u_1\nG : Type u_4\ninst✝⁴ : Monoid A\ninst✝³ : CommGroup G\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf g : ContinuousMonoidHom A G\n⊢ Eq (PontryaginDual.map (HMul.hMul f g)) (HMul.hMul (PontryaginDual.map f) (PontryaginDual.map g))","decl":"@[simp]\nnonrec theorem map_mul (f g : ContinuousMonoidHom A G) : map (f * g) = map f * map g :=\n  ext fun x => ext fun y => map_mul x (f y) (g y)\n\n"}
