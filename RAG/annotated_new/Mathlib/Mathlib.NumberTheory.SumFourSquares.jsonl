{"name":"euler_four_squares","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b c d x y z w : R\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow (HSub.hSub (HSub.hSub (HSub.hSub (HMul.hMul a x) (HMul.hMul b y)) (HMul.hMul c z)) (HMul.hMul d w)) 2) (HPow.hPow (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul a y) (HMul.hMul b x)) (HMul.hMul c w)) (HMul.hMul d z)) 2)) (HPow.hPow (HAdd.hAdd (HAdd.hAdd (HSub.hSub (HMul.hMul a z) (HMul.hMul b w)) (HMul.hMul c x)) (HMul.hMul d y)) 2)) (HPow.hPow (HAdd.hAdd (HSub.hSub (HAdd.hAdd (HMul.hMul a w) (HMul.hMul b z)) (HMul.hMul c y)) (HMul.hMul d x)) 2)) (HMul.hMul (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HPow.hPow c 2)) (HPow.hPow d 2)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2)) (HPow.hPow z 2)) (HPow.hPow w 2)))","decl":"/-- **Euler's four-square identity**. -/\ntheorem euler_four_squares {R : Type*} [CommRing R] (a b c d x y z w : R) :\n    (a * x - b * y - c * z - d * w) ^ 2 + (a * y + b * x + c * w - d * z) ^ 2 +\n      (a * z - b * w + c * x + d * y) ^ 2 + (a * w + b * z - c * y + d * x) ^ 2 =\n      (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) := by ring\n\n"}
{"name":"Nat.euler_four_squares","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"a b c d x y z w : Nat\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow (HSub.hSub (HSub.hSub (HSub.hSub (HMul.hMul ↑a ↑x) (HMul.hMul ↑b ↑y)) (HMul.hMul ↑c ↑z)) (HMul.hMul ↑d ↑w)).natAbs 2) (HPow.hPow (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HMul.hMul ↑a ↑y) (HMul.hMul ↑b ↑x)) (HMul.hMul ↑c ↑w)) (HMul.hMul ↑d ↑z)).natAbs 2)) (HPow.hPow (HAdd.hAdd (HAdd.hAdd (HSub.hSub (HMul.hMul ↑a ↑z) (HMul.hMul ↑b ↑w)) (HMul.hMul ↑c ↑x)) (HMul.hMul ↑d ↑y)).natAbs 2)) (HPow.hPow (HAdd.hAdd (HSub.hSub (HAdd.hAdd (HMul.hMul ↑a ↑w) (HMul.hMul ↑b ↑z)) (HMul.hMul ↑c ↑y)) (HMul.hMul ↑d ↑x)).natAbs 2)) (HMul.hMul (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HPow.hPow c 2)) (HPow.hPow d 2)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2)) (HPow.hPow z 2)) (HPow.hPow w 2)))","decl":"/-- **Euler's four-square identity**, a version for natural numbers. -/\ntheorem Nat.euler_four_squares (a b c d x y z w : ℕ) :\n    ((a : ℤ) * x - b * y - c * z - d * w).natAbs ^ 2 +\n      ((a : ℤ) * y + b * x + c * w - d * z).natAbs ^ 2 +\n      ((a : ℤ) * z - b * w + c * x + d * y).natAbs ^ 2 +\n      ((a : ℤ) * w + b * z - c * y + d * x).natAbs ^ 2 =\n      (a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2) * (x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) := by\n  rw [← Int.natCast_inj]\n  push_cast\n  simp only [sq_abs, _root_.euler_four_squares]\n\n"}
{"name":"Int.sq_add_sq_of_two_mul_sq_add_sq","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"m x y : Int\nh : Eq (HMul.hMul 2 m) (HAdd.hAdd (HPow.hPow x 2) (HPow.hPow y 2))\n⊢ Eq m (HAdd.hAdd (HPow.hPow (HDiv.hDiv (HSub.hSub x y) 2) 2) (HPow.hPow (HDiv.hDiv (HAdd.hAdd x y) 2) 2))","decl":"theorem sq_add_sq_of_two_mul_sq_add_sq {m x y : ℤ} (h : 2 * m = x ^ 2 + y ^ 2) :\n    m = ((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2 :=\n  have : Even (x ^ 2 + y ^ 2) := by simp [← h, even_mul]\n  have hxaddy : Even (x + y) := by simpa [sq, parity_simps]\n  have hxsuby : Even (x - y) := by simpa [sq, parity_simps]\n  mul_right_injective₀ (show (2 * 2 : ℤ) ≠ 0 by decide) <|\n    calc\n      2 * 2 * m = (x - y) ^ 2 + (x + y) ^ 2 := by rw [mul_assoc, h]; ring\n      _ = (2 * ((x - y) / 2)) ^ 2 + (2 * ((x + y) / 2)) ^ 2 := by\n        rw [even_iff_two_dvd] at hxsuby hxaddy\n        rw [Int.mul_ediv_cancel' hxsuby, Int.mul_ediv_cancel' hxaddy]\n      _ = 2 * 2 * (((x - y) / 2) ^ 2 + ((x + y) / 2) ^ 2) := by\n        set_option simprocs false in\n        simp [mul_add, pow_succ, mul_comm, mul_assoc, mul_left_comm]\n\n"}
{"name":"Int.lt_of_sum_four_squares_eq_mul","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"a b c d k m : Nat\nh : Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HPow.hPow c 2)) (HPow.hPow d 2)) (HMul.hMul k m)\nha : LT.lt (HMul.hMul 2 a) m\nhb : LT.lt (HMul.hMul 2 b) m\nhc : LT.lt (HMul.hMul 2 c) m\nhd : LT.lt (HMul.hMul 2 d) m\n⊢ LT.lt k m","decl":"theorem lt_of_sum_four_squares_eq_mul {a b c d k m : ℕ}\n    (h : a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = k * m)\n    (ha : 2 * a < m) (hb : 2 * b < m) (hc : 2 * c < m) (hd : 2 * d < m) :\n    k < m := by\n  refine _root_.lt_of_mul_lt_mul_right\n    (_root_.lt_of_mul_lt_mul_left ?_ (zero_le (2 ^ 2))) (zero_le m)\n  calc\n    2 ^ 2 * (k * ↑m) = ∑ i : Fin 4, (2 * ![a, b, c, d] i) ^ 2 := by\n      simp [← h, Fin.sum_univ_succ, mul_add, mul_pow, add_assoc]\n    _ < ∑ _i : Fin 4, m ^ 2 := Finset.sum_lt_sum_of_nonempty Finset.univ_nonempty fun i _ ↦ by\n      refine Nat.pow_lt_pow_left ?_ two_ne_zero\n      fin_cases i <;> assumption\n    _ = 2 ^ 2 * (m * m) := by simp; ring\n\n"}
{"name":"Int.exists_sq_add_sq_add_one_eq_mul","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Exists fun a => Exists fun b => Exists fun k => And (LT.lt 0 k) (And (LT.lt k p) (Eq (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) 1) (HMul.hMul k p)))","decl":"theorem exists_sq_add_sq_add_one_eq_mul (p : ℕ) [hp : Fact p.Prime] :\n    ∃ (a b k : ℕ), 0 < k ∧ k < p ∧ a ^ 2 + b ^ 2 + 1 = k * p := by\n  rcases hp.1.eq_two_or_odd' with (rfl | hodd)\n  · use 1, 0, 1; simp\n  rcases Nat.sq_add_sq_zmodEq p (-1) with ⟨a, b, ha, hb, hab⟩\n  rcases Int.modEq_iff_dvd.1 hab.symm with ⟨k, hk⟩\n  rw [sub_neg_eq_add, mul_comm] at hk\n  have hk₀ : 0 < k := by\n    refine pos_of_mul_pos_left ?_ (Nat.cast_nonneg p)\n    rw [← hk]\n    positivity\n  lift k to ℕ using hk₀.le\n  refine ⟨a, b, k, Nat.cast_pos.1 hk₀, ?_, mod_cast hk⟩\n  replace hk : a ^ 2 + b ^ 2 + 1 ^ 2 + 0 ^ 2 = k * p := mod_cast hk\n  refine lt_of_sum_four_squares_eq_mul hk ?_ ?_ ?_ ?_\n  · exact (mul_le_mul' le_rfl ha).trans_lt (Nat.mul_div_lt_iff_not_dvd.2 hodd.not_two_dvd_nat)\n  · exact (mul_le_mul' le_rfl hb).trans_lt (Nat.mul_div_lt_iff_not_dvd.2 hodd.not_two_dvd_nat)\n  · exact lt_of_le_of_ne hp.1.two_le (hodd.ne_two_of_dvd_nat (dvd_refl _)).symm\n  · exact hp.1.pos\n\n"}
{"name":"Nat.Prime.sum_four_squares","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Exists fun a => Exists fun b => Exists fun c => Exists fun d => Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HPow.hPow c 2)) (HPow.hPow d 2)) p","decl":"/-- Lagrange's **four squares theorem** for a prime number. Use `Nat.sum_four_squares` instead. -/\nprotected theorem Prime.sum_four_squares {p : ℕ} (hp : p.Prime) :\n    ∃ a b c d : ℕ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = p := by\n  classical\n  have := Fact.mk hp\n  -- Find `a`, `b`, `c`, `d`, `0 < m < p` such that `a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = m * p`\n  have natAbs_iff {a b c d : ℤ} {k : ℕ} :\n      a.natAbs ^ 2 + b.natAbs ^ 2 + c.natAbs ^ 2 + d.natAbs ^ 2 = k ↔\n        a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = k := by\n    rw [← @Nat.cast_inj ℤ]; push_cast [sq_abs]; rfl\n  have hm : ∃ m < p, 0 < m ∧ ∃ a b c d : ℕ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = m * p := by\n    obtain ⟨a, b, k, hk₀, hkp, hk⟩ := exists_sq_add_sq_add_one_eq_mul p\n    refine ⟨k, hkp, hk₀, a, b, 1, 0, ?_⟩\n    simpa\n  -- Take the minimal possible `m`\n  rcases Nat.findX hm with ⟨m, ⟨hmp, hm₀, a, b, c, d, habcd⟩, hmin⟩\n  -- If `m = 1`, then we are done\n  rcases (Nat.one_le_iff_ne_zero.2 hm₀.ne').eq_or_gt with rfl | hm₁\n  · use a, b, c, d; simpa using habcd\n  -- Otherwise, let us find a contradiction\n  exfalso\n  have : NeZero m := ⟨hm₀.ne'⟩\n  by_cases hm : 2 ∣ m\n  · -- If `m` is an even number, then `(m / 2) * p` can be represented as a sum of four squares\n    rcases hm with ⟨m, rfl⟩\n    rw [mul_pos_iff_of_pos_left two_pos] at hm₀\n    have hm₂ : m < 2 * m := by simpa [two_mul]\n    apply_fun (Nat.cast : ℕ → ℤ) at habcd\n    push_cast [mul_assoc] at habcd\n    obtain ⟨_, _, _, _, h⟩ := sum_four_squares_of_two_mul_sum_four_squares habcd\n    exact hmin m hm₂ ⟨hm₂.trans hmp, hm₀, _, _, _, _, natAbs_iff.2 h⟩\n  · -- For each `x` in `a`, `b`, `c`, `d`, take a number `f x ≡ x [ZMOD m]` with least possible\n    -- absolute value\n    obtain ⟨f, hf_lt, hf_mod⟩ :\n        ∃ f : ℕ → ℤ, (∀ x, 2 * (f x).natAbs < m) ∧ ∀ x, (f x : ZMod m) = x := by\n      refine ⟨fun x ↦ (x : ZMod m).valMinAbs, fun x ↦ ?_, fun x ↦ (x : ZMod m).coe_valMinAbs⟩\n      exact (mul_le_mul' le_rfl (x : ZMod m).natAbs_valMinAbs_le).trans_lt\n        (Nat.mul_div_lt_iff_not_dvd.2 hm)\n    -- Since `|f x| ^ 2 = (f x) ^ 2 ≡ x ^ 2 [ZMOD m]`, we have\n    -- `m ∣ |f a| ^ 2 + |f b| ^ 2 + |f c| ^ 2 + |f d| ^ 2`\n    obtain ⟨r, hr⟩ :\n        m ∣ (f a).natAbs ^ 2 + (f b).natAbs ^ 2 + (f c).natAbs ^ 2 + (f d).natAbs ^ 2 := by\n      simp only [← Int.natCast_dvd_natCast, ← ZMod.intCast_zmod_eq_zero_iff_dvd]\n      push_cast [hf_mod, sq_abs]\n      norm_cast\n      simp [habcd]\n    -- The quotient `r` is not zero, because otherwise `f a = f b = f c = f d = 0`, hence\n    -- `m` divides each `a`, `b`, `c`, `d`, thus `m ∣ p` which is impossible.\n    rcases (zero_le r).eq_or_gt with rfl | hr₀\n    · replace hr : f a = 0 ∧ f b = 0 ∧ f c = 0 ∧ f d = 0 := by simpa [and_assoc] using hr\n      obtain ⟨⟨a, rfl⟩, ⟨b, rfl⟩, ⟨c, rfl⟩, ⟨d, rfl⟩⟩ : m ∣ a ∧ m ∣ b ∧ m ∣ c ∧ m ∣ d := by\n        simp only [← ZMod.natCast_zmod_eq_zero_iff_dvd, ← hf_mod, hr, Int.cast_zero, and_self]\n      have : m * m ∣ m * p := habcd ▸ ⟨a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2, by ring⟩\n      rw [mul_dvd_mul_iff_left hm₀.ne'] at this\n      exact (hp.eq_one_or_self_of_dvd _ this).elim hm₁.ne' hmp.ne\n    -- Since `2 * |f x| < m` for each `x ∈ {a, b, c, d}`, we have `r < m`\n    have hrm : r < m := by\n      rw [mul_comm] at hr\n      apply lt_of_sum_four_squares_eq_mul hr <;> apply hf_lt\n    -- Now it suffices to represent `r * p` as a sum of four squares\n    -- More precisely, we will represent `(m * r) * (m * p)` as a sum of squares of four numbers,\n    -- each of them is divisible by `m`\n    rsuffices ⟨w, x, y, z, hw, hx, hy, hz, h⟩ : ∃ w x y z : ℤ, ↑m ∣ w ∧ ↑m ∣ x ∧ ↑m ∣ y ∧ ↑m ∣ z ∧\n      w ^ 2 + x ^ 2 + y ^ 2 + z ^ 2 = ↑(m * r) * ↑(m * p)\n    · have : (w / m) ^ 2 + (x / m) ^ 2 + (y / m) ^ 2 + (z / m) ^ 2 = ↑(r * p) := by\n        refine mul_left_cancel₀ (pow_ne_zero 2 (Nat.cast_ne_zero.2 hm₀.ne')) ?_\n        conv_rhs => rw [← Nat.cast_pow, ← Nat.cast_mul, sq m, mul_mul_mul_comm, Nat.cast_mul, ← h]\n        simp only [mul_add, ← mul_pow, Int.mul_ediv_cancel', *]\n      rw [← natAbs_iff] at this\n      exact hmin r hrm ⟨hrm.trans hmp, hr₀, _, _, _, _, this⟩\n    -- To do the last step, we apply the Euler's four square identity once more\n    replace hr : (f b) ^ 2 + (f a) ^ 2 + (f d) ^ 2 + (-f c) ^ 2 = ↑(m * r) := by\n      rw [← natAbs_iff, natAbs_neg, ← hr]\n      ac_rfl\n    have := congr_arg₂ (· * Nat.cast ·) hr habcd\n    simp only [← _root_.euler_four_squares, Nat.cast_add, Nat.cast_pow] at this\n    refine ⟨_, _, _, _, ?_, ?_, ?_, ?_, this⟩\n    · simp [← ZMod.intCast_zmod_eq_zero_iff_dvd, hf_mod, mul_comm]\n    · suffices ((a : ZMod m) ^ 2 + (b : ZMod m) ^ 2 + (c : ZMod m) ^ 2 + (d : ZMod m) ^ 2) = 0 by\n        simpa [← ZMod.intCast_zmod_eq_zero_iff_dvd, hf_mod, sq, add_comm, add_assoc,\n          add_left_comm] using this\n      norm_cast\n      simp [habcd]\n    · simp [← ZMod.intCast_zmod_eq_zero_iff_dvd, hf_mod, mul_comm]\n    · simp [← ZMod.intCast_zmod_eq_zero_iff_dvd, hf_mod, mul_comm]\n\n"}
{"name":"Nat.sum_four_squares","module":"Mathlib.NumberTheory.SumFourSquares","initialProofState":"n : Nat\n⊢ Exists fun a => Exists fun b => Exists fun c => Exists fun d => Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) (HPow.hPow c 2)) (HPow.hPow d 2)) n","decl":"/-- **Four squares theorem** -/\ntheorem sum_four_squares (n : ℕ) : ∃ a b c d : ℕ, a ^ 2 + b ^ 2 + c ^ 2 + d ^ 2 = n := by\n  -- The proof is by induction on prime factorization. The case of prime `n` was proved above,\n  -- the inductive step follows from `Nat.euler_four_squares`.\n  induction n using Nat.recOnMul with\n  | h0 => exact ⟨0, 0, 0, 0, rfl⟩\n  | h1 => exact ⟨1, 0, 0, 0, rfl⟩\n  | hp p hp => exact hp.sum_four_squares\n  | h m n hm hn =>\n    rcases hm with ⟨a, b, c, d, rfl⟩\n    rcases hn with ⟨w, x, y, z, rfl⟩\n    exact ⟨_, _, _, _, euler_four_squares _ _ _ _ _ _ _ _⟩\n\n"}
