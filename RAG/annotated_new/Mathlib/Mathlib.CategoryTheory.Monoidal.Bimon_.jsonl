{"name":"Bimon_Class.one_comul'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.comul) Mon_Class.one","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) := by aesop_cat\n  one_comul' : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := by aesop_cat\n  mul_counit' : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := by aesop_cat\n  one_counit' : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.mul_comul'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M M M M) (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul)))","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) := by aesop_cat\n  one_comul' : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := by aesop_cat\n  mul_counit' : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := by aesop_cat\n  one_counit' : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.mul_counit'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.counit) Comon_Class.counit","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) := by aesop_cat\n  one_comul' : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := by aesop_cat\n  mul_counit' : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := by aesop_cat\n  one_counit' : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.one_counit'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.counit) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) := by aesop_cat\n  one_comul' : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := by aesop_cat\n  mul_counit' : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := by aesop_cat\n  one_counit' : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.one_comul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp Mon_Class.one h)","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_counit'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_comul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M M M M) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul) h)))","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.one_counit'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) h","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M M M M) (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul)))","decl":"@[reassoc (attr := simp)]\ntheorem mul_comul (M : C) [Bimon_Class M] :\n    Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) :=\n  mul_comul'\n\n"}
{"name":"Bimon_Class.mul_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorŒº M M M M) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul) h)))","decl":"@[reassoc (attr := simp)]\ntheorem mul_comul (M : C) [Bimon_Class M] :\n    Œº[M] ‚â´ Œî[M] = (Œî[M] ‚äó Œî[M]) ‚â´ tensorŒº M M M M ‚â´ (Œº[M] ‚äó Œº[M]) :=\n  mul_comul'\n\n"}
{"name":"Bimon_Class.one_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.comul) Mon_Class.one","decl":"@[reassoc (attr := simp)]\ntheorem one_comul (M : C) [Bimon_Class M] : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := one_comul'\n\n"}
{"name":"Bimon_Class.one_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp Mon_Class.one h)","decl":"@[reassoc (attr := simp)]\ntheorem one_comul (M : C) [Bimon_Class M] : Œ∑[M] ‚â´ Œî[M] = Œ∑[M ‚äó M] := one_comul'\n\n"}
{"name":"Bimon_Class.mul_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.counit) Comon_Class.counit","decl":"@[reassoc (attr := simp)]\ntheorem mul_counit (M : C) [Bimon_Class M] : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := mul_counit'\n\n"}
{"name":"Bimon_Class.mul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)","decl":"@[reassoc (attr := simp)]\ntheorem mul_counit (M : C) [Bimon_Class M] : Œº[M] ‚â´ Œµ[M] = Œµ[M ‚äó M] := mul_counit'\n\n"}
{"name":"Bimon_Class.one_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) h","decl":"@[reassoc (attr := simp)]\ntheorem one_counit (M : C) [Bimon_Class M] : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := one_counit'\n\n"}
{"name":"Bimon_Class.one_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.MonoidalCategory C\ninst‚úù¬π : CategoryTheory.BraidedCategory C\nM : C\ninst‚úù : Bimon_Class M\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.counit) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[reassoc (attr := simp)]\ntheorem one_counit (M : C) [Bimon_Class M] : Œ∑[M] ‚â´ Œµ[M] = ùüô (ùüô_ C) := one_counit'\n\n"}
{"name":"IsBimon_Hom.toIsComon_Hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.BraidedCategory C\nM N : C\ninst‚úù¬π : Bimon_Class M\ninst‚úù : Bimon_Class N\nf : Quiver.Hom M N\nself : IsBimon_Hom f\n‚ä¢ IsComon_Hom f","decl":"/-- The property that a morphism between bimonoid objects is a bimonoid morphism. -/\nclass IsBimon_Hom {M N : C} [Bimon_Class M] [Bimon_Class N] (f : M ‚ü∂ N) extends\n    IsMon_Hom f, IsComon_Hom f : Prop\n\n"}
{"name":"IsBimon_Hom.toIsMon_Hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.BraidedCategory C\nM N : C\ninst‚úù¬π : Bimon_Class M\ninst‚úù : Bimon_Class N\nf : Quiver.Hom M N\nself : IsBimon_Hom f\n‚ä¢ IsMon_Hom f","decl":"/-- The property that a morphism between bimonoid objects is a bimonoid morphism. -/\nclass IsBimon_Hom {M N : C} [Bimon_Class M] [Bimon_Class N] (f : M ‚ü∂ N) extends\n    IsMon_Hom f, IsComon_Hom f : Prop\n\n"}
{"name":"Bimon_.ext","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Bimon_ C\nf g : Quiver.Hom X Y\nw : Eq f.hom.hom g.hom.hom\n‚ä¢ Eq f g","decl":"@[ext] lemma ext {X Y : Bimon_ C} {f g : X ‚ü∂ Y} (w : f.hom.hom = g.hom.hom) : f = g :=\n  Comon_.Hom.ext (Mon_.Hom.ext w)\n\n"}
{"name":"Bimon_.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX Y : Bimon_ C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.hom.hom g.hom.hom)","decl":"@[ext] lemma ext {X Y : Bimon_ C} {f g : X ‚ü∂ Y} (w : f.hom.hom = g.hom.hom) : f = g :=\n  Comon_.Hom.ext (Mon_.Hom.ext w)\n\n"}
{"name":"Bimon_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp] theorem id_hom' (M : Bimon_ C) : Comon_.Hom.hom (ùüô M) = ùüô M.X := rfl\n\n"}
{"name":"Bimon_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N K : Bimon_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Bimon_ C} (f : M ‚ü∂ N) (g : N ‚ü∂ K) : (f ‚â´ g).hom = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"Bimon_.toMon_forget","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq ((Bimon_.toMon_ C).comp (Mon_.forget C)) (Bimon_.forget C)","decl":"@[simp]\ntheorem toMon_forget : toMon_ C ‚ãô Mon_.forget C = forget C := rfl\n\n"}
{"name":"Bimon_.toComon__obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n‚ä¢ Eq ((Bimon_.toComon_ C).obj A).X A.X.X","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ‚•§ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__obj_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n‚ä¢ Eq ((Bimon_.toComon_ C).obj A).counit A.counit.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ‚•§ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù Y‚úù : Comon_ (Mon_ C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Bimon_.toComon_ C).map f).hom f.hom.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ‚•§ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__obj_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n‚ä¢ Eq ((Bimon_.toComon_ C).obj A).comul A.comul.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ‚•§ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon_forget","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq ((Bimon_.toComon_ C).comp (Comon_.forget C)) (Bimon_.forget C)","decl":"@[simp]\ntheorem toComon_forget : toComon_ C ‚ãô Comon_.forget C = forget C := rfl\n\n"}
{"name":"Bimon_.toMon_Comon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (Bimon_.toMon_Comon_obj C M).X ((Bimon_.toComon_ C).obj M)","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon_obj_one_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (Bimon_.toMon_Comon_obj C M).one.hom M.X.one","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon_obj_mul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (Bimon_.toMon_Comon_obj C M).mul.hom M.X.mul","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù Y‚úù : Bimon_ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Bimon_.toMon_Comon_ C).map f).hom ((Bimon_.toComon_ C).map f)","decl":"/-- The forward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef toMon_Comon_ : Bimon_ C ‚•§ Mon_ (Comon_ C) where\n  obj := toMon_Comon_obj C\n  map f :=\n  { hom := (toComon_ C).map f }\n\n"}
{"name":"Bimon_.toMon_Comon__obj","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq ((Bimon_.toMon_Comon_ C).obj M) (Bimon_.toMon_Comon_obj C M)","decl":"/-- The forward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef toMon_Comon_ : Bimon_ C ‚•§ Mon_ (Comon_ C) where\n  obj := toMon_Comon_obj C\n  map f :=\n  { hom := (toComon_ C).map f }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n‚ä¢ Eq (Bimon_.ofMon_Comon_obj C M).X ((Comon_.forget C).mapMon.obj M)","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_Œº] }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n‚ä¢ Eq (Bimon_.ofMon_Comon_obj C M).comul.hom M.X.comul","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_Œº] }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n‚ä¢ Eq (Bimon_.ofMon_Comon_obj C M).counit.hom M.X.counit","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_Œº] }\n\n"}
{"name":"Bimon_.ofMon_Comon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nX‚úù Y‚úù : Mon_ (Comon_ C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Bimon_.ofMon_Comon_ C).map f).hom ((Comon_.forget C).mapMon.map f)","decl":"/-- The backward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_ : Mon_ (Comon_ C) ‚•§ Bimon_ C where\n  obj := ofMon_Comon_obj C\n  map f :=\n  { hom := (Comon_.forget C).mapMon.map f }\n\n"}
{"name":"Bimon_.ofMon_Comon__obj","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n‚ä¢ Eq ((Bimon_.ofMon_Comon_ C).obj M) (Bimon_.ofMon_Comon_obj C M)","decl":"/-- The backward direction of `Comon_ (Mon_ C) ‚âå Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_ : Mon_ (Comon_ C) ‚•§ Bimon_ C where\n  obj := ofMon_Comon_obj C\n  map f :=\n  { hom := (Comon_.forget C).mapMon.map f }\n\n"}
{"name":"Bimon_.trivial_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (Bimon_.trivial C).comul.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (Bimon_.trivial C).counit.hom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (Bimon_.trivial C).X.X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_mul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (Bimon_.trivial C).X.mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_one","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\n‚ä¢ Eq (Bimon_.trivial C).X.one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivialTo_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n‚ä¢ Eq (Bimon_.trivialTo C A).hom Inhabited.default","decl":"/-- The bimonoid morphism from the trivial bimonoid to any bimonoid. -/\n@[simps]\ndef trivialTo (A : Bimon_ C) : trivial C ‚ü∂ A :=\n  { hom := (default : Mon_.trivial C ‚ü∂ A.X), }\n\n"}
{"name":"Bimon_.trivial_to_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n‚ä¢ Eq (Bimon_.trivialTo C A).hom Inhabited.default","decl":"@[deprecated (since := \"2024-12-07\")] alias trivial_to_hom := trivialTo_hom\n\n"}
{"name":"Bimon_.toTrivial_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n‚ä¢ Eq (Bimon_.toTrivial C A).hom A.counit","decl":"/-- The bimonoid morphism from any bimonoid to the trivial bimonoid. -/\n@[simps!]\ndef toTrivial (A : Bimon_ C) : A ‚ü∂ trivial C :=\n  (default : @Quiver.Hom (Comon_ (Mon_ C)) _ A (Comon_.trivial (Mon_ C)))\n\n"}
{"name":"Bimon_.to_trivial_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n‚ä¢ Eq (Bimon_.toTrivial C A).hom A.counit","decl":"@[deprecated (since := \"2024-12-07\")] alias to_trivial_hom := toTrivial_hom\n\n"}
{"name":"Bimon_.one_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.X.one (CategoryTheory.CategoryStruct.comp M.comul.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.one M.X.one) h))","decl":"@[reassoc]\ntheorem one_comul (M : Bimon_ C) :\n    M.X.one ‚â´ M.comul.hom = (Œª_ _).inv ‚â´ (M.X.one ‚äó M.X.one) := by\n  simp\n\n"}
{"name":"Bimon_.one_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.X.one M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.one M.X.one))","decl":"@[reassoc]\ntheorem one_comul (M : Bimon_ C) :\n    M.X.one ‚â´ M.comul.hom = (Œª_ _).inv ‚â´ (M.X.one ‚äó M.X.one) := by\n  simp\n\n"}
{"name":"Bimon_.mul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.X.mul (CategoryTheory.CategoryStruct.comp M.counit.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit.hom M.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit.X).hom h))","decl":"@[reassoc]\ntheorem mul_counit (M : Bimon_ C) :\n    M.X.mul ‚â´ M.counit.hom = (M.counit.hom ‚äó M.counit.hom) ‚â´ (Œª_ _).hom := by\n  simp\n\n"}
{"name":"Bimon_.mul_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.X.mul M.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit.hom M.counit.hom) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit.X).hom)","decl":"@[reassoc]\ntheorem mul_counit (M : Bimon_ C) :\n    M.X.mul ‚â´ M.counit.hom = (M.counit.hom ‚äó M.counit.hom) ‚â´ (Œª_ _).hom := by\n  simp\n\n"}
{"name":"Bimon_.compatibility_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.comul.hom M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding M.X.X M.X.X).hom M.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.mul M.X.mul) h))))))) (CategoryTheory.CategoryStruct.comp M.X.mul (CategoryTheory.CategoryStruct.comp M.comul.hom h))","decl":"/-- Compatibility of the monoid and comonoid structures, in terms of morphisms in `C`. -/\n@[reassoc (attr := simp)] theorem compatibility (M : Bimon_ C) :\n    (M.comul.hom ‚äó M.comul.hom) ‚â´\n      (Œ±_ _ _ (M.X.X ‚äó M.X.X)).hom ‚â´ M.X.X ‚óÅ (Œ±_ _ _ _).inv ‚â´\n      M.X.X ‚óÅ (Œ≤_ M.X.X M.X.X).hom ‚ñ∑ M.X.X ‚â´\n      M.X.X ‚óÅ (Œ±_ _ _ _).hom ‚â´ (Œ±_ _ _ _).inv ‚â´\n      (M.X.mul ‚äó M.X.mul) =\n    M.X.mul ‚â´ M.comul.hom := by\n  have := (Mon_.Hom.mul_hom M.comul).symm\n  simpa [-Mon_.Hom.mul_hom, tensorŒº] using this\n\n"}
{"name":"Bimon_.compatibility","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.comul.hom M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding M.X.X M.X.X).hom M.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.mul M.X.mul))))))) (CategoryTheory.CategoryStruct.comp M.X.mul M.comul.hom)","decl":"/-- Compatibility of the monoid and comonoid structures, in terms of morphisms in `C`. -/\n@[reassoc (attr := simp)] theorem compatibility (M : Bimon_ C) :\n    (M.comul.hom ‚äó M.comul.hom) ‚â´\n      (Œ±_ _ _ (M.X.X ‚äó M.X.X)).hom ‚â´ M.X.X ‚óÅ (Œ±_ _ _ _).inv ‚â´\n      M.X.X ‚óÅ (Œ≤_ M.X.X M.X.X).hom ‚ñ∑ M.X.X ‚â´\n      M.X.X ‚óÅ (Œ±_ _ _ _).hom ‚â´ (Œ±_ _ _ _).inv ‚â´\n      (M.X.mul ‚äó M.X.mul) =\n    M.X.mul ‚â´ M.comul.hom := by\n  have := (Mon_.Hom.mul_hom M.comul).symm\n  simpa [-Mon_.Hom.mul_hom, tensorŒº] using this\n\n"}
{"name":"Bimon_.comul_counit_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X CategoryTheory.MonoidalCategoryStruct.tensorUnit.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.counit.hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X.X).inv h)","decl":"@[reassoc (attr := simp)] theorem comul_counit_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (_ ‚óÅ M.counit.hom) = (œÅ_ _).inv := by\n  simpa [- Comon_.comul_counit] using congr_arg Mon_.Hom.hom M.comul_counit\n\n"}
{"name":"Bimon_.comul_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.counit.hom)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X.X).inv","decl":"@[reassoc (attr := simp)] theorem comul_counit_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (_ ‚óÅ M.counit.hom) = (œÅ_ _).inv := by\n  simpa [- Comon_.comul_counit] using congr_arg Mon_.Hom.hom M.comul_counit\n\n"}
{"name":"Bimon_.counit_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.counit.hom M.X.X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X.X).inv","decl":"@[reassoc (attr := simp)] theorem counit_comul_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.counit.hom ‚ñ∑ _) = (Œª_ _).inv := by\n  simpa [- Comon_.counit_comul] using congr_arg Mon_.Hom.hom M.counit_comul\n\n"}
{"name":"Bimon_.counit_comul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit.X M.X.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.counit.hom M.X.X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X.X).inv h)","decl":"@[reassoc (attr := simp)] theorem counit_comul_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.counit.hom ‚ñ∑ _) = (Œª_ _).inv := by\n  simpa [- Comon_.counit_comul] using congr_arg Mon_.Hom.hom M.counit_comul\n\n"}
{"name":"Bimon_.comul_assoc_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom h)))","decl":"@[reassoc (attr := simp)] theorem comul_assoc_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.X.X ‚óÅ M.comul.hom) =\n      M.comul.hom ‚â´ (M.comul.hom ‚ñ∑ M.X.X) ‚â´ (Œ±_ M.X.X M.X.X M.X.X).hom := by\n  simpa [- Comon_.comul_assoc] using congr_arg Mon_.Hom.hom M.comul_assoc\n\n"}
{"name":"Bimon_.comul_assoc_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom))","decl":"@[reassoc (attr := simp)] theorem comul_assoc_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.X.X ‚óÅ M.comul.hom) =\n      M.comul.hom ‚â´ (M.comul.hom ‚ñ∑ M.X.X) ‚â´ (Œ±_ M.X.X M.X.X M.X.X).hom := by\n  simpa [- Comon_.comul_assoc] using congr_arg Mon_.Hom.hom M.comul_assoc\n\n"}
{"name":"Bimon_.comul_assoc_flip_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv))","decl":"@[reassoc] theorem comul_assoc_flip_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.comul.hom ‚ñ∑ M.X.X) =\n      M.comul.hom ‚â´ (M.X.X ‚óÅ M.comul.hom) ‚â´ (Œ±_ M.X.X M.X.X M.X.X).inv := by\n  simp\n\n"}
{"name":"Bimon_.comul_assoc_flip_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X M.X.X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv h)))","decl":"@[reassoc] theorem comul_assoc_flip_hom (M : Bimon_ C) :\n    M.comul.hom ‚â´ (M.comul.hom ‚ñ∑ M.X.X) =\n      M.comul.hom ‚â´ (M.X.X ‚óÅ M.comul.hom) ‚â´ (Œ±_ M.X.X M.X.X M.X.X).inv := by\n  simp\n\n"}
{"name":"Bimon_.hom_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom N.comul.hom) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom.hom f.hom.hom))","decl":"@[reassoc] theorem hom_comul_hom {M N : Bimon_ C} (f : M ‚ü∂ N) :\n    f.hom.hom ‚â´ N.comul.hom = M.comul.hom ‚â´ (f.hom.hom ‚äó f.hom.hom) := by\n  simpa [- Comon_.Hom.hom_comul] using congr_arg Mon_.Hom.hom f.hom_comul\n\n"}
{"name":"Bimon_.hom_comul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj N.X N.X).X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom (CategoryTheory.CategoryStruct.comp N.comul.hom h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom.hom f.hom.hom) h))","decl":"@[reassoc] theorem hom_comul_hom {M N : Bimon_ C} (f : M ‚ü∂ N) :\n    f.hom.hom ‚â´ N.comul.hom = M.comul.hom ‚â´ (f.hom.hom ‚äó f.hom.hom) := by\n  simpa [- Comon_.Hom.hom_comul] using congr_arg Mon_.Hom.hom f.hom_comul\n\n"}
{"name":"Bimon_.hom_counit_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom (CategoryTheory.CategoryStruct.comp N.counit.hom h)) (CategoryTheory.CategoryStruct.comp M.counit.hom h)","decl":"@[reassoc] theorem hom_counit_hom {M N : Bimon_ C} (f : M ‚ü∂ N) :\n    f.hom.hom ‚â´ N.counit.hom = M.counit.hom := by\n  simpa [- Comon_.Hom.hom_counit] using congr_arg Mon_.Hom.hom f.hom_counit\n\n"}
{"name":"Bimon_.hom_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom N.counit.hom) M.counit.hom","decl":"@[reassoc] theorem hom_counit_hom {M N : Bimon_ C} (f : M ‚ü∂ N) :\n    f.hom.hom ‚â´ N.counit.hom = M.counit.hom := by\n  simpa [- Comon_.Hom.hom_counit] using congr_arg Mon_.Hom.hom f.hom_counit\n\n"}
