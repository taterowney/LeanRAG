{"name":"Bimon_Class.one_comul'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.comul) Mon_Class.one","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) := by aesop_cat\n  one_comul' : η[M] ≫ Δ[M] = η[M ⊗ M] := by aesop_cat\n  mul_counit' : μ[M] ≫ ε[M] = ε[M ⊗ M] := by aesop_cat\n  one_counit' : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.mul_comul'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ M M M M) (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul)))","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) := by aesop_cat\n  one_comul' : η[M] ≫ Δ[M] = η[M ⊗ M] := by aesop_cat\n  mul_counit' : μ[M] ≫ ε[M] = ε[M ⊗ M] := by aesop_cat\n  one_counit' : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.mul_counit'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.counit) Comon_Class.counit","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) := by aesop_cat\n  one_comul' : η[M] ≫ Δ[M] = η[M ⊗ M] := by aesop_cat\n  mul_counit' : μ[M] ≫ ε[M] = ε[M ⊗ M] := by aesop_cat\n  one_counit' : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.one_counit'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.counit) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/--\nA bimonoid object in a braided category `C` is a object that is simultaneously monoid and comonoid\nobjects, and structure morphisms of them satisfy appropriate consistency conditions.\n-/\nclass Bimon_Class (M : C) extends Mon_Class M, Comon_Class M where\n  /- For the names of the conditions below, the unprimed names are reserved for the version where\n  the argument `M` is explicit. -/\n  mul_comul' : μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) := by aesop_cat\n  one_comul' : η[M] ≫ Δ[M] = η[M ⊗ M] := by aesop_cat\n  mul_counit' : μ[M] ≫ ε[M] = ε[M ⊗ M] := by aesop_cat\n  one_counit' : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := by aesop_cat\n\n"}
{"name":"Bimon_Class.one_comul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp Mon_Class.one h)","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_counit'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_comul'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ M M M M) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul) h)))","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.one_counit'_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : C\nself : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) h","decl":"attribute [reassoc] mul_comul' one_comul' mul_counit' one_counit'\n\n"}
{"name":"Bimon_Class.mul_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ M M M M) (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul)))","decl":"@[reassoc (attr := simp)]\ntheorem mul_comul (M : C) [Bimon_Class M] :\n    μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) :=\n  mul_comul'\n\n"}
{"name":"Bimon_Class.mul_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Comon_Class.comul Comon_Class.comul) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategory.tensorμ M M M M) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom Mon_Class.mul Mon_Class.mul) h)))","decl":"@[reassoc (attr := simp)]\ntheorem mul_comul (M : C) [Bimon_Class M] :\n    μ[M] ≫ Δ[M] = (Δ[M] ⊗ Δ[M]) ≫ tensorμ M M M M ≫ (μ[M] ⊗ μ[M]) :=\n  mul_comul'\n\n"}
{"name":"Bimon_Class.one_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.comul) Mon_Class.one","decl":"@[reassoc (attr := simp)]\ntheorem one_comul (M : C) [Bimon_Class M] : η[M] ≫ Δ[M] = η[M ⊗ M] := one_comul'\n\n"}
{"name":"Bimon_Class.one_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M M) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.comul h)) (CategoryTheory.CategoryStruct.comp Mon_Class.one h)","decl":"@[reassoc (attr := simp)]\ntheorem one_comul (M : C) [Bimon_Class M] : η[M] ≫ Δ[M] = η[M ⊗ M] := one_comul'\n\n"}
{"name":"Bimon_Class.mul_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul Comon_Class.counit) Comon_Class.counit","decl":"@[reassoc (attr := simp)]\ntheorem mul_counit (M : C) [Bimon_Class M] : μ[M] ≫ ε[M] = ε[M ⊗ M] := mul_counit'\n\n"}
{"name":"Bimon_Class.mul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.mul (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)","decl":"@[reassoc (attr := simp)]\ntheorem mul_counit (M : C) [Bimon_Class M] : μ[M] ≫ ε[M] = ε[M ⊗ M] := mul_counit'\n\n"}
{"name":"Bimon_Class.one_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one (CategoryTheory.CategoryStruct.comp Comon_Class.counit h)) h","decl":"@[reassoc (attr := simp)]\ntheorem one_counit (M : C) [Bimon_Class M] : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := one_counit'\n\n"}
{"name":"Bimon_Class.one_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.BraidedCategory C\nM : C\ninst✝ : Bimon_Class M\n⊢ Eq (CategoryTheory.CategoryStruct.comp Mon_Class.one Comon_Class.counit) (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"@[reassoc (attr := simp)]\ntheorem one_counit (M : C) [Bimon_Class M] : η[M] ≫ ε[M] = 𝟙 (𝟙_ C) := one_counit'\n\n"}
{"name":"IsBimon_Hom.toIsComon_Hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.BraidedCategory C\nM N : C\ninst✝¹ : Bimon_Class M\ninst✝ : Bimon_Class N\nf : Quiver.Hom M N\nself : IsBimon_Hom f\n⊢ IsComon_Hom f","decl":"/-- The property that a morphism between bimonoid objects is a bimonoid morphism. -/\nclass IsBimon_Hom {M N : C} [Bimon_Class M] [Bimon_Class N] (f : M ⟶ N) extends\n    IsMon_Hom f, IsComon_Hom f : Prop\n\n"}
{"name":"IsBimon_Hom.toIsMon_Hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.BraidedCategory C\nM N : C\ninst✝¹ : Bimon_Class M\ninst✝ : Bimon_Class N\nf : Quiver.Hom M N\nself : IsBimon_Hom f\n⊢ IsMon_Hom f","decl":"/-- The property that a morphism between bimonoid objects is a bimonoid morphism. -/\nclass IsBimon_Hom {M N : C} [Bimon_Class M] [Bimon_Class N] (f : M ⟶ N) extends\n    IsMon_Hom f, IsComon_Hom f : Prop\n\n"}
{"name":"Bimon_.ext","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Bimon_ C\nf g : Quiver.Hom X Y\nw : Eq f.hom.hom g.hom.hom\n⊢ Eq f g","decl":"@[ext] lemma ext {X Y : Bimon_ C} {f g : X ⟶ Y} (w : f.hom.hom = g.hom.hom) : f = g :=\n  Comon_.Hom.ext (Mon_.Hom.ext w)\n\n"}
{"name":"Bimon_.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX Y : Bimon_ C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.hom.hom g.hom.hom)","decl":"@[ext] lemma ext {X Y : Bimon_ C} {f g : X ⟶ Y} (w : f.hom.hom = g.hom.hom) : f = g :=\n  Comon_.Hom.ext (Mon_.Hom.ext w)\n\n"}
{"name":"Bimon_.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp] theorem id_hom' (M : Bimon_ C) : Comon_.Hom.hom (𝟙 M) = 𝟙 M.X := rfl\n\n"}
{"name":"Bimon_.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM N K : Bimon_ C\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Bimon_ C} (f : M ⟶ N) (g : N ⟶ K) : (f ≫ g).hom = f.hom ≫ g.hom :=\n  rfl\n\n"}
{"name":"Bimon_.toMon_forget","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq ((Bimon_.toMon_ C).comp (Mon_.forget C)) (Bimon_.forget C)","decl":"@[simp]\ntheorem toMon_forget : toMon_ C ⋙ Mon_.forget C = forget C := rfl\n\n"}
{"name":"Bimon_.toComon__obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n⊢ Eq ((Bimon_.toComon_ C).obj A).X A.X.X","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ⥤ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__obj_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n⊢ Eq ((Bimon_.toComon_ C).obj A).counit A.counit.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ⥤ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ Y✝ : Comon_ (Mon_ C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Bimon_.toComon_ C).map f).hom f.hom.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ⥤ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon__obj_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Comon_ (Mon_ C)\n⊢ Eq ((Bimon_.toComon_ C).obj A).comul A.comul.hom","decl":"/-- The forgetful functor from bimonoid objects to comonoid objects. -/\n@[simps!]\ndef toComon_ : Bimon_ C ⥤ Comon_ C := (Mon_.forget C).mapComon\n\n"}
{"name":"Bimon_.toComon_forget","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq ((Bimon_.toComon_ C).comp (Comon_.forget C)) (Bimon_.forget C)","decl":"@[simp]\ntheorem toComon_forget : toComon_ C ⋙ Comon_.forget C = forget C := rfl\n\n"}
{"name":"Bimon_.toMon_Comon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (Bimon_.toMon_Comon_obj C M).X ((Bimon_.toComon_ C).obj M)","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon_obj_one_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (Bimon_.toMon_Comon_obj C M).one.hom M.X.one","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon_obj_mul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (Bimon_.toMon_Comon_obj C M).mul.hom M.X.mul","decl":"attribute [simps] toMon_Comon_obj -- We add this after the fact to avoid a timeout.\n\n"}
{"name":"Bimon_.toMon_Comon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ Y✝ : Bimon_ C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Bimon_.toMon_Comon_ C).map f).hom ((Bimon_.toComon_ C).map f)","decl":"/-- The forward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef toMon_Comon_ : Bimon_ C ⥤ Mon_ (Comon_ C) where\n  obj := toMon_Comon_obj C\n  map f :=\n  { hom := (toComon_ C).map f }\n\n"}
{"name":"Bimon_.toMon_Comon__obj","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq ((Bimon_.toMon_Comon_ C).obj M) (Bimon_.toMon_Comon_obj C M)","decl":"/-- The forward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef toMon_Comon_ : Bimon_ C ⥤ Mon_ (Comon_ C) where\n  obj := toMon_Comon_obj C\n  map f :=\n  { hom := (toComon_ C).map f }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n⊢ Eq (Bimon_.ofMon_Comon_obj C M).X ((Comon_.forget C).mapMon.obj M)","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_μ] }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n⊢ Eq (Bimon_.ofMon_Comon_obj C M).comul.hom M.X.comul","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_μ] }\n\n"}
{"name":"Bimon_.ofMon_Comon_obj_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n⊢ Eq (Bimon_.ofMon_Comon_obj C M).counit.hom M.X.counit","decl":"/-- The object level part of the backward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_obj (M : Mon_ (Comon_ C)) : Bimon_ C where\n  X := (Comon_.forget C).mapMon.obj M\n  counit := { hom := M.X.counit }\n  comul :=\n  { hom := M.X.comul,\n    mul_hom := by dsimp; simp [tensor_μ] }\n\n"}
{"name":"Bimon_.ofMon_Comon__map_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nX✝ Y✝ : Mon_ (Comon_ C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Bimon_.ofMon_Comon_ C).map f).hom ((Comon_.forget C).mapMon.map f)","decl":"/-- The backward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_ : Mon_ (Comon_ C) ⥤ Bimon_ C where\n  obj := ofMon_Comon_obj C\n  map f :=\n  { hom := (Comon_.forget C).mapMon.map f }\n\n"}
{"name":"Bimon_.ofMon_Comon__obj","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Mon_ (Comon_ C)\n⊢ Eq ((Bimon_.ofMon_Comon_ C).obj M) (Bimon_.ofMon_Comon_obj C M)","decl":"/-- The backward direction of `Comon_ (Mon_ C) ≌ Mon_ (Comon_ C)` -/\n@[simps]\ndef ofMon_Comon_ : Mon_ (Comon_ C) ⥤ Bimon_ C where\n  obj := ofMon_Comon_obj C\n  map f :=\n  { hom := (Comon_.forget C).mapMon.map f }\n\n"}
{"name":"Bimon_.trivial_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (Bimon_.trivial C).comul.hom (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (Bimon_.trivial C).counit.hom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_X","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (Bimon_.trivial C).X.X CategoryTheory.MonoidalCategoryStruct.tensorUnit","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_mul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (Bimon_.trivial C).X.mul (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).hom","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivial_X_one","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\n⊢ Eq (Bimon_.trivial C).X.one (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)","decl":"/-- The trivial bimonoid object. -/\n@[simps!]\ndef trivial : Bimon_ C := Comon_.trivial (Mon_ C)\n\n"}
{"name":"Bimon_.trivialTo_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n⊢ Eq (Bimon_.trivialTo C A).hom Inhabited.default","decl":"/-- The bimonoid morphism from the trivial bimonoid to any bimonoid. -/\n@[simps]\ndef trivialTo (A : Bimon_ C) : trivial C ⟶ A :=\n  { hom := (default : Mon_.trivial C ⟶ A.X), }\n\n"}
{"name":"Bimon_.trivial_to_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n⊢ Eq (Bimon_.trivialTo C A).hom Inhabited.default","decl":"@[deprecated (since := \"2024-12-07\")] alias trivial_to_hom := trivialTo_hom\n\n"}
{"name":"Bimon_.toTrivial_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n⊢ Eq (Bimon_.toTrivial C A).hom A.counit","decl":"/-- The bimonoid morphism from any bimonoid to the trivial bimonoid. -/\n@[simps!]\ndef toTrivial (A : Bimon_ C) : A ⟶ trivial C :=\n  (default : @Quiver.Hom (Comon_ (Mon_ C)) _ A (Comon_.trivial (Mon_ C)))\n\n"}
{"name":"Bimon_.to_trivial_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nA : Bimon_ C\n⊢ Eq (Bimon_.toTrivial C A).hom A.counit","decl":"@[deprecated (since := \"2024-12-07\")] alias to_trivial_hom := toTrivial_hom\n\n"}
{"name":"Bimon_.one_comul_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.X.one (CategoryTheory.CategoryStruct.comp M.comul.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.one M.X.one) h))","decl":"@[reassoc]\ntheorem one_comul (M : Bimon_ C) :\n    M.X.one ≫ M.comul.hom = (λ_ _).inv ≫ (M.X.one ⊗ M.X.one) := by\n  simp\n\n"}
{"name":"Bimon_.one_comul","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.X.one M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.one M.X.one))","decl":"@[reassoc]\ntheorem one_comul (M : Bimon_ C) :\n    M.X.one ≫ M.comul.hom = (λ_ _).inv ≫ (M.X.one ⊗ M.X.one) := by\n  simp\n\n"}
{"name":"Bimon_.mul_counit_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.X.mul (CategoryTheory.CategoryStruct.comp M.counit.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit.hom M.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit.X).hom h))","decl":"@[reassoc]\ntheorem mul_counit (M : Bimon_ C) :\n    M.X.mul ≫ M.counit.hom = (M.counit.hom ⊗ M.counit.hom) ≫ (λ_ _).hom := by\n  simp\n\n"}
{"name":"Bimon_.mul_counit","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.X.mul M.counit.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.counit.hom M.counit.hom) (CategoryTheory.MonoidalCategoryStruct.leftUnitor CategoryTheory.MonoidalCategoryStruct.tensorUnit.X).hom)","decl":"@[reassoc]\ntheorem mul_counit (M : Bimon_ C) :\n    M.X.mul ≫ M.counit.hom = (M.counit.hom ⊗ M.counit.hom) ≫ (λ_ _).hom := by\n  simp\n\n"}
{"name":"Bimon_.compatibility_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.comul.hom M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding M.X.X M.X.X).hom M.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.mul M.X.mul) h))))))) (CategoryTheory.CategoryStruct.comp M.X.mul (CategoryTheory.CategoryStruct.comp M.comul.hom h))","decl":"/-- Compatibility of the monoid and comonoid structures, in terms of morphisms in `C`. -/\n@[reassoc (attr := simp)] theorem compatibility (M : Bimon_ C) :\n    (M.comul.hom ⊗ M.comul.hom) ≫\n      (α_ _ _ (M.X.X ⊗ M.X.X)).hom ≫ M.X.X ◁ (α_ _ _ _).inv ≫\n      M.X.X ◁ (β_ M.X.X M.X.X).hom ▷ M.X.X ≫\n      M.X.X ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv ≫\n      (M.X.mul ⊗ M.X.mul) =\n    M.X.mul ≫ M.comul.hom := by\n  have := (Mon_.Hom.mul_hom M.comul).symm\n  simpa [-Mon_.Hom.mul_hom, tensorμ] using this\n\n"}
{"name":"Bimon_.compatibility","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom M.comul.hom M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.BraidedCategory.braiding M.X.X M.X.X).hom M.X.X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X M.X.X)).inv (CategoryTheory.MonoidalCategoryStruct.tensorHom M.X.mul M.X.mul))))))) (CategoryTheory.CategoryStruct.comp M.X.mul M.comul.hom)","decl":"/-- Compatibility of the monoid and comonoid structures, in terms of morphisms in `C`. -/\n@[reassoc (attr := simp)] theorem compatibility (M : Bimon_ C) :\n    (M.comul.hom ⊗ M.comul.hom) ≫\n      (α_ _ _ (M.X.X ⊗ M.X.X)).hom ≫ M.X.X ◁ (α_ _ _ _).inv ≫\n      M.X.X ◁ (β_ M.X.X M.X.X).hom ▷ M.X.X ≫\n      M.X.X ◁ (α_ _ _ _).hom ≫ (α_ _ _ _).inv ≫\n      (M.X.mul ⊗ M.X.mul) =\n    M.X.mul ≫ M.comul.hom := by\n  have := (Mon_.Hom.mul_hom M.comul).symm\n  simpa [-Mon_.Hom.mul_hom, tensorμ] using this\n\n"}
{"name":"Bimon_.comul_counit_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X CategoryTheory.MonoidalCategoryStruct.tensorUnit.X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.counit.hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X.X).inv h)","decl":"@[reassoc (attr := simp)] theorem comul_counit_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (_ ◁ M.counit.hom) = (ρ_ _).inv := by\n  simpa [- Comon_.comul_counit] using congr_arg Mon_.Hom.hom M.comul_counit\n\n"}
{"name":"Bimon_.comul_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.counit.hom)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor M.X.X).inv","decl":"@[reassoc (attr := simp)] theorem comul_counit_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (_ ◁ M.counit.hom) = (ρ_ _).inv := by\n  simpa [- Comon_.comul_counit] using congr_arg Mon_.Hom.hom M.comul_counit\n\n"}
{"name":"Bimon_.counit_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.counit.hom M.X.X)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X.X).inv","decl":"@[reassoc (attr := simp)] theorem counit_comul_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.counit.hom ▷ _) = (λ_ _).inv := by\n  simpa [- Comon_.counit_comul] using congr_arg Mon_.Hom.hom M.counit_comul\n\n"}
{"name":"Bimon_.counit_comul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj CategoryTheory.MonoidalCategoryStruct.tensorUnit.X M.X.X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.counit.hom M.X.X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor M.X.X).inv h)","decl":"@[reassoc (attr := simp)] theorem counit_comul_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.counit.hom ▷ _) = (λ_ _).inv := by\n  simpa [- Comon_.counit_comul] using congr_arg Mon_.Hom.hom M.counit_comul\n\n"}
{"name":"Bimon_.comul_assoc_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X.X (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom h)))","decl":"@[reassoc (attr := simp)] theorem comul_assoc_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.X.X ◁ M.comul.hom) =\n      M.comul.hom ≫ (M.comul.hom ▷ M.X.X) ≫ (α_ M.X.X M.X.X M.X.X).hom := by\n  simpa [- Comon_.comul_assoc] using congr_arg Mon_.Hom.hom M.comul_assoc\n\n"}
{"name":"Bimon_.comul_assoc_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).hom))","decl":"@[reassoc (attr := simp)] theorem comul_assoc_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.X.X ◁ M.comul.hom) =\n      M.comul.hom ≫ (M.comul.hom ▷ M.X.X) ≫ (α_ M.X.X M.X.X M.X.X).hom := by\n  simpa [- Comon_.comul_assoc] using congr_arg Mon_.Hom.hom M.comul_assoc\n\n"}
{"name":"Bimon_.comul_assoc_flip_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv))","decl":"@[reassoc] theorem comul_assoc_flip_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.comul.hom ▷ M.X.X) =\n      M.comul.hom ≫ (M.X.X ◁ M.comul.hom) ≫ (α_ M.X.X M.X.X M.X.X).inv := by\n  simp\n\n"}
{"name":"Bimon_.comul_assoc_flip_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM : Bimon_ C\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X M.X).X M.X.X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.comul.hom M.X.X) h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X.X M.comul.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X.X M.X.X M.X.X).inv h)))","decl":"@[reassoc] theorem comul_assoc_flip_hom (M : Bimon_ C) :\n    M.comul.hom ≫ (M.comul.hom ▷ M.X.X) =\n      M.comul.hom ≫ (M.X.X ◁ M.comul.hom) ≫ (α_ M.X.X M.X.X M.X.X).inv := by\n  simp\n\n"}
{"name":"Bimon_.hom_comul_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom N.comul.hom) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom.hom f.hom.hom))","decl":"@[reassoc] theorem hom_comul_hom {M N : Bimon_ C} (f : M ⟶ N) :\n    f.hom.hom ≫ N.comul.hom = M.comul.hom ≫ (f.hom.hom ⊗ f.hom.hom) := by\n  simpa [- Comon_.Hom.hom_comul] using congr_arg Mon_.Hom.hom f.hom_comul\n\n"}
{"name":"Bimon_.hom_comul_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj N.X N.X).X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom (CategoryTheory.CategoryStruct.comp N.comul.hom h)) (CategoryTheory.CategoryStruct.comp M.comul.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f.hom.hom f.hom.hom) h))","decl":"@[reassoc] theorem hom_comul_hom {M N : Bimon_ C} (f : M ⟶ N) :\n    f.hom.hom ≫ N.comul.hom = M.comul.hom ≫ (f.hom.hom ⊗ f.hom.hom) := by\n  simpa [- Comon_.Hom.hom_comul] using congr_arg Mon_.Hom.hom f.hom_comul\n\n"}
{"name":"Bimon_.hom_counit_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\nZ : C\nh : Quiver.Hom CategoryTheory.MonoidalCategoryStruct.tensorUnit.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom (CategoryTheory.CategoryStruct.comp N.counit.hom h)) (CategoryTheory.CategoryStruct.comp M.counit.hom h)","decl":"@[reassoc] theorem hom_counit_hom {M N : Bimon_ C} (f : M ⟶ N) :\n    f.hom.hom ≫ N.counit.hom = M.counit.hom := by\n  simpa [- Comon_.Hom.hom_counit] using congr_arg Mon_.Hom.hom f.hom_counit\n\n"}
{"name":"Bimon_.hom_counit_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimon_","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.BraidedCategory C\nM N : Bimon_ C\nf : Quiver.Hom M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom N.counit.hom) M.counit.hom","decl":"@[reassoc] theorem hom_counit_hom {M N : Bimon_ C} (f : M ⟶ N) :\n    f.hom.hom ≫ N.counit.hom = M.counit.hom := by\n  simpa [- Comon_.Hom.hom_counit] using congr_arg Mon_.Hom.hom f.hom_counit\n\n"}
