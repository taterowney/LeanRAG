{"name":"CategoryTheory.instReflectsIsomorphismsForgetType","module":"Mathlib.CategoryTheory.ConcreteCategory.ReflectsIso","initialProofState":"⊢ (CategoryTheory.forget (Type u)).ReflectsIsomorphisms","decl":"instance : (forget (Type u)).ReflectsIsomorphisms where reflects _ _ _ {i} := i\n\n"}
{"name":"CategoryTheory.reflectsIsomorphisms_forget₂","module":"Mathlib.CategoryTheory.ConcreteCategory.ReflectsIso","initialProofState":"C : Type (u + 1)\ninst✝⁵ : CategoryTheory.Category.{u_1, u + 1} C\ninst✝⁴ : CategoryTheory.HasForget C\nD : Type (u + 1)\ninst✝³ : CategoryTheory.Category.{u_2, u + 1} D\ninst✝² : CategoryTheory.HasForget D\ninst✝¹ : CategoryTheory.HasForget₂ C D\ninst✝ : (CategoryTheory.forget C).ReflectsIsomorphisms\n⊢ (CategoryTheory.forget₂ C D).ReflectsIsomorphisms","decl":"/-- A `forget₂ C D` forgetful functor between concrete categories `C` and `D`\nwhere `forget C` reflects isomorphisms, itself reflects isomorphisms.\n-/\ntheorem reflectsIsomorphisms_forget₂ [HasForget₂ C D] [(forget C).ReflectsIsomorphisms] :\n    (forget₂ C D).ReflectsIsomorphisms :=\n  { reflects := fun X Y f {i} => by\n      haveI i' : IsIso ((forget D).map ((forget₂ C D).map f)) := Functor.map_isIso (forget D) _\n      haveI : IsIso ((forget C).map f) := by\n        have := @HasForget₂.forget_comp C D\n        rwa [← this]\n      apply isIso_of_reflects_iso f (forget C) }\n\n"}
