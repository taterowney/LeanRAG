{"name":"CategoryTheory.Functor.PreservesZeroMorphisms.map_zero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nself : F.PreservesZeroMorphisms\nX Y : C\n⊢ Eq (F.map 0) 0","decl":"/-- A functor preserves zero morphisms if it sends zero morphisms to zero morphisms. -/\nclass PreservesZeroMorphisms (F : C ⥤ D) : Prop where\n  /-- For any pair objects `F (0: X ⟶ Y) = (0 : F X ⟶ F Y)` -/\n  map_zero : ∀ X Y : C, F.map (0 : X ⟶ Y) = 0 := by aesop\n\n"}
{"name":"CategoryTheory.Functor.map_zero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX Y : C\n⊢ Eq (F.map 0) 0","decl":"@[simp]\nprotected theorem map_zero (F : C ⥤ D) [PreservesZeroMorphisms F] (X Y : C) :\n    F.map (0 : X ⟶ Y) = 0 :=\n  PreservesZeroMorphisms.map_zero _ _\n\n"}
{"name":"CategoryTheory.Functor.map_isZero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\nX : C\nhX : CategoryTheory.Limits.IsZero X\n⊢ CategoryTheory.Limits.IsZero (F.obj X)","decl":"lemma map_isZero (F : C ⥤ D) [PreservesZeroMorphisms F] {X : C} (hX : IsZero X) :\n    IsZero (F.obj X) := by\n  simp only [IsZero.iff_id_eq_zero] at hX ⊢\n  rw [← F.map_id, hX, F.map_zero]\n\n"}
{"name":"CategoryTheory.Functor.zero_of_map_zero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.Faithful\nX Y : C\nf : Quiver.Hom X Y\nh : Eq (F.map f) 0\n⊢ Eq f 0","decl":"theorem zero_of_map_zero (F : C ⥤ D) [PreservesZeroMorphisms F] [Faithful F] {X Y : C} (f : X ⟶ Y)\n    (h : F.map f = 0) : f = 0 :=\n  F.map_injective <| h.trans <| Eq.symm <| F.map_zero _ _\n\n"}
{"name":"CategoryTheory.Functor.map_eq_zero_iff","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : F.Faithful\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (Eq (F.map f) 0) (Eq f 0)","decl":"theorem map_eq_zero_iff (F : C ⥤ D) [PreservesZeroMorphisms F] [Faithful F] {X Y : C} {f : X ⟶ Y} :\n    F.map f = 0 ↔ f = 0 :=\n  ⟨F.zero_of_map_zero _, by\n    rintro rfl\n    exact F.map_zero _ _⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.IsLeftAdjoint\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_isLeftAdjoint (F : C ⥤ D) [IsLeftAdjoint F] :\n    PreservesZeroMorphisms F where\n  map_zero X Y := by\n    let adj := Adjunction.ofIsLeftAdjoint F\n    calc\n      F.map (0 : X ⟶ Y) = F.map 0 ≫ F.map (adj.unit.app Y) ≫ adj.counit.app (F.obj Y) := ?_\n      _ = F.map 0 ≫ F.map ((rightAdjoint F).map (0 : F.obj X ⟶ _)) ≫ adj.counit.app (F.obj Y) := ?_\n      _ = 0 := ?_\n    · rw [Adjunction.left_triangle_components]\n      exact (Category.comp_id _).symm\n    · simp only [← Category.assoc, ← F.map_comp, zero_comp]\n    · simp only [Adjunction.counit_naturality, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_isRightAdjoint","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝ : G.IsRightAdjoint\n⊢ G.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_isRightAdjoint (G : C ⥤ D) [IsRightAdjoint G] :\n    PreservesZeroMorphisms G where\n  map_zero X Y := by\n    let adj := Adjunction.ofIsRightAdjoint G\n    calc\n      G.map (0 : X ⟶ Y) = adj.unit.app (G.obj X) ≫ G.map (adj.counit.app X) ≫ G.map 0 := ?_\n      _ = adj.unit.app (G.obj X) ≫ G.map ((leftAdjoint G).map (0 : _ ⟶ G.obj X)) ≫ G.map 0 := ?_\n      _ = 0 := ?_\n    · rw [Adjunction.right_triangle_components_assoc]\n    · simp only [← G.map_comp, comp_zero]\n    · simp only [id_obj, comp_obj, Adjunction.unit_naturality_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_full","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.Full\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_full (F : C ⥤ D) [Full F] :\n    PreservesZeroMorphisms F where\n  map_zero X Y :=\n    calc\n      F.map (0 : X ⟶ Y) = F.map (0 ≫ F.preimage (0 : F.obj Y ⟶ F.obj Y)) := by rw [zero_comp]\n      _ = 0 := by rw [F.map_comp, F.map_preimage, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_comp","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} E\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : G.PreservesZeroMorphisms\n⊢ (F.comp G).PreservesZeroMorphisms","decl":"instance preservesZeroMorphisms_comp (F : C ⥤ D) (G : D ⥤ E)\n    [F.PreservesZeroMorphisms] [G.PreservesZeroMorphisms] :\n    (F ⋙ G).PreservesZeroMorphisms := ⟨by simp⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_iso","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF₁ F₂ : CategoryTheory.Functor C D\ninst✝ : F₁.PreservesZeroMorphisms\ne : CategoryTheory.Iso F₁ F₂\n⊢ F₂.PreservesZeroMorphisms","decl":"lemma preservesZeroMorphisms_of_iso {F₁ F₂ : C ⥤ D} [F₁.PreservesZeroMorphisms] (e : F₁ ≅ F₂) :\n    F₂.PreservesZeroMorphisms where\n  map_zero X Y := by simp only [← cancel_epi (e.hom.app X), ← e.hom.naturality,\n    F₁.map_zero, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_evaluation_obj","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nj : D\n⊢ ((CategoryTheory.evaluation D C).obj j).PreservesZeroMorphisms","decl":"instance preservesZeroMorphisms_evaluation_obj (j : D) :\n    PreservesZeroMorphisms ((evaluation D C).obj j) where\n\n"}
{"name":"CategoryTheory.Functor.instPreservesZeroMorphismsFlipOfObj","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ninst✝ : ∀ (X : C), (F.obj X).PreservesZeroMorphisms\n⊢ F.flip.PreservesZeroMorphisms","decl":"instance (F : C ⥤ D ⥤ E) [∀ X, (F.obj X).PreservesZeroMorphisms] :\n    F.flip.PreservesZeroMorphisms where\n\n"}
{"name":"CategoryTheory.Functor.instPreservesZeroMorphismsObjFlip","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} E\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ninst✝ : F.PreservesZeroMorphisms\nY : D\n⊢ (F.flip.obj Y).PreservesZeroMorphisms","decl":"instance (F : C ⥤ D ⥤ E) [F.PreservesZeroMorphisms] (Y : D) :\n    (F.flip.obj Y).PreservesZeroMorphisms where\n\n"}
{"name":"CategoryTheory.Functor.mapZeroObject_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\n⊢ Eq F.mapZeroObject.inv 0","decl":"/-- A functor that preserves zero morphisms also preserves the zero object. -/\n@[simps]\ndef mapZeroObject [PreservesZeroMorphisms F] : F.obj 0 ≅ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := by rw [← F.map_id, id_zero, F.map_zero, zero_comp]\n  inv_hom_id := by rw [id_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.mapZeroObject_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\n⊢ Eq F.mapZeroObject.hom 0","decl":"/-- A functor that preserves zero morphisms also preserves the zero object. -/\n@[simps]\ndef mapZeroObject [PreservesZeroMorphisms F] : F.obj 0 ≅ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := by rw [← F.map_id, id_zero, F.map_zero, zero_comp]\n  inv_hom_id := by rw [id_zero, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_map_zero_object","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ni : CategoryTheory.Iso (F.obj 0) 0\n⊢ F.PreservesZeroMorphisms","decl":"theorem preservesZeroMorphisms_of_map_zero_object (i : F.obj 0 ≅ 0) : PreservesZeroMorphisms F where\n  map_zero X Y :=\n    calc\n      F.map (0 : X ⟶ Y) = F.map (0 : X ⟶ 0) ≫ F.map 0 := by rw [← Functor.map_comp, comp_zero]\n      _ = F.map 0 ≫ (i.hom ≫ i.inv) ≫ F.map 0 := by rw [Iso.hom_inv_id, Category.id_comp]\n      _ = 0 := by simp only [zero_of_to_zero i.hom, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_preserves_initial_object","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) F\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_preserves_initial_object\n    [PreservesColimit (Functor.empty.{0} C) F] : PreservesZeroMorphisms F :=\n  preservesZeroMorphisms_of_map_zero_object <|\n    F.mapIso HasZeroObject.zeroIsoInitial ≪≫\n      PreservesInitial.iso F ≪≫ HasZeroObject.zeroIsoInitial.symm\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_preserves_terminal_object","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_preserves_terminal_object\n    [PreservesLimit (Functor.empty.{0} C) F] : PreservesZeroMorphisms F :=\n  preservesZeroMorphisms_of_map_zero_object <|\n    F.mapIso HasZeroObject.zeroIsoTerminal ≪≫\n      PreservesTerminal.iso F ≪≫ HasZeroObject.zeroIsoTerminal.symm\n\n"}
{"name":"CategoryTheory.Functor.preservesTerminalObject_of_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) F","decl":"/-- Preserving zero morphisms implies preserving terminal objects. -/\nlemma preservesTerminalObject_of_preservesZeroMorphisms [PreservesZeroMorphisms F] :\n    PreservesLimit (Functor.empty.{0} C) F :=\n  preservesTerminal_of_iso F <|\n    F.mapIso HasZeroObject.zeroIsoTerminal.symm ≪≫ mapZeroObject F ≪≫ HasZeroObject.zeroIsoTerminal\n\n"}
{"name":"CategoryTheory.Functor.preservesInitialObject_of_preservesZeroMorphisms","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesZeroMorphisms\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) F","decl":"/-- Preserving zero morphisms implies preserving terminal objects. -/\nlemma preservesInitialObject_of_preservesZeroMorphisms [PreservesZeroMorphisms F] :\n    PreservesColimit (Functor.empty.{0} C) F :=\n  preservesInitial_of_iso F <|\n    HasZeroObject.zeroIsoInitial.symm ≪≫\n      (mapZeroObject F).symm ≪≫ (F.mapIso HasZeroObject.zeroIsoInitial.symm).symm\n\n"}
{"name":"CategoryTheory.Functor.preservesLimitsOfShape_of_isZero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.Limits.IsZero G\nJ : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J G","decl":"/-- A zero functor preserves limits. -/\nlemma preservesLimitsOfShape_of_isZero : PreservesLimitsOfShape J G where\n  preservesLimit {K} := ⟨fun _ => ⟨by\n    rw [Functor.isZero_iff] at hG\n    exact IsLimit.ofIsZero _ ((K ⋙ G).isZero (fun X ↦ hG _)) (hG _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesColimitsOfShape_of_isZero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.Limits.IsZero G\nJ : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J G","decl":"/-- A zero functor preserves colimits. -/\nlemma preservesColimitsOfShape_of_isZero : PreservesColimitsOfShape J G where\n  preservesColimit {K} := ⟨fun _ => ⟨by\n    rw [Functor.isZero_iff] at hG\n    exact IsColimit.ofIsZero _ ((K ⋙ G).isZero (fun X ↦ hG _)) (hG _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesLimitsOfSize_of_isZero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.Limits.IsZero G\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, v₁, v₂, u₁, u₂} G","decl":"/-- A zero functor preserves limits. -/\nlemma preservesLimitsOfSize_of_isZero : PreservesLimitsOfSize.{v, u} G where\n  preservesLimitsOfShape := G.preservesLimitsOfShape_of_isZero hG _\n\n"}
{"name":"CategoryTheory.Functor.preservesColimitsOfSize_of_isZero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Zero","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.Limits.IsZero G\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, v₁, v₂, u₁, u₂} G","decl":"/-- A zero functor preserves colimits. -/\nlemma preservesColimitsOfSize_of_isZero : PreservesColimitsOfSize.{v, u} G where\n  preservesColimitsOfShape := G.preservesColimitsOfShape_of_isZero hG _\n\n"}
