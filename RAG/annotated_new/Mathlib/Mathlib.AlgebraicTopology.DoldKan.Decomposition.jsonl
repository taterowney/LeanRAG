{"name":"AlgebraicTopology.DoldKan.decomposition_Q","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn q : Nat\n‚ä¢ Eq ((AlgebraicTopology.DoldKan.Q q).f (HAdd.hAdd n 1)) ((Finset.filter (fun i => LT.lt (‚Üëi) q) Finset.univ).sum fun i => CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.DoldKan.P ‚Üëi).f (HAdd.hAdd n 1)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.rev.succ) (X.œÉ i.rev)))","decl":"/-- In each positive degree, this lemma decomposes the idempotent endomorphism\n`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.\nAs `Q q` is the complement projection to `P q`, this implies that in the case of\nsimplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as\n$x = x' + \\sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and\nthe $y_i$ are in degree $n$. -/\ntheorem decomposition_Q (n q : ‚Ñï) :\n    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =\n      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,\n        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) := by\n  induction' q with q hq\n  ¬∑ simp only [Q_zero, HomologicalComplex.zero_f_apply, Nat.not_lt_zero,\n      Finset.filter_False, Finset.sum_empty]\n  ¬∑ by_cases hqn : q + 1 ‚â§ n + 1\n    swap\n    ¬∑ rw [Q_is_eventually_constant (show n + 1 ‚â§ q by omega), hq]\n      congr 1\n      ext ‚ü®x, hx‚ü©\n      simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]\n      omega\n    ¬∑ cases' Nat.le.dest (Nat.succ_le_succ_iff.mp hqn) with a ha\n      rw [Q_succ, HomologicalComplex.sub_f_apply, HomologicalComplex.comp_f, hq]\n      symm\n      conv_rhs => rw [sub_eq_add_neg, add_comm]\n      let q' : Fin (n + 1) := ‚ü®q, Nat.succ_le_iff.mp hqn‚ü©\n      rw [‚Üê @Finset.add_sum_erase _ _ _ _ _ _ q' (by simp [q'])]\n      congr\n      ¬∑ have hnaq' : n = a + q := by omega\n        simp only [Fin.val_mk, (HigherFacesVanish.of_P q n).comp_HœÉ_eq hnaq',\n          q'.rev_eq hnaq', neg_neg]\n        rfl\n      ¬∑ ext ‚ü®i, hi‚ü©\n        simp only [q', Nat.succ_eq_add_one, Nat.lt_succ_iff_lt_or_eq, Finset.mem_univ,\n          forall_true_left, Finset.mem_filter, lt_self_iff_false, or_true, and_self, not_true,\n          Finset.mem_erase, ne_eq, Fin.mk.injEq, true_and]\n        aesop\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.mk.inj","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\na‚úù : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nb‚úù : Fin (HAdd.hAdd n 1) ‚Üí Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\na : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nb : Fin (HAdd.hAdd n 1) ‚Üí Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\nx‚úù : Eq { a := a‚úù, b := b‚úù } { a := a, b := b }\n‚ä¢ And (Eq a‚úù a) (Eq b‚úù b)","decl":"/-- The structure `MorphComponents` is an ad hoc structure that is used in\nthe proof that `N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms. The fields are the data that are needed in order to\nconstruct a morphism `X _[n+1] ‚ü∂ Z` (see `œÜ`) using the decomposition of the\nidentity given by `decomposition_Q n (n+1)`. -/\n@[ext]\nstructure MorphComponents (n : ‚Ñï) (Z : C) where\n  a : X _[n + 1] ‚ü∂ Z\n  b : Fin (n + 1) ‚Üí (X _[n] ‚ü∂ Z)\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.ext","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\nx y : AlgebraicTopology.DoldKan.MorphComponents X n Z\na : Eq x.a y.a\nb : Eq x.b y.b\n‚ä¢ Eq x y","decl":"/-- The structure `MorphComponents` is an ad hoc structure that is used in\nthe proof that `N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms. The fields are the data that are needed in order to\nconstruct a morphism `X _[n+1] ‚ü∂ Z` (see `œÜ`) using the decomposition of the\nidentity given by `decomposition_Q n (n+1)`. -/\n@[ext]\nstructure MorphComponents (n : ‚Ñï) (Z : C) where\n  a : X _[n + 1] ‚ü∂ Z\n  b : Fin (n + 1) ‚Üí (X _[n] ‚ü∂ Z)\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.mk.injEq","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\na‚úù : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nb‚úù : Fin (HAdd.hAdd n 1) ‚Üí Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\na : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nb : Fin (HAdd.hAdd n 1) ‚Üí Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (Eq { a := a‚úù, b := b‚úù } { a := a, b := b }) (And (Eq a‚úù a) (Eq b‚úù b))","decl":"/-- The structure `MorphComponents` is an ad hoc structure that is used in\nthe proof that `N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms. The fields are the data that are needed in order to\nconstruct a morphism `X _[n+1] ‚ü∂ Z` (see `œÜ`) using the decomposition of the\nidentity given by `decomposition_Q n (n+1)`. -/\n@[ext]\nstructure MorphComponents (n : ‚Ñï) (Z : C) where\n  a : X _[n + 1] ‚ü∂ Z\n  b : Fin (n + 1) ‚Üí (X _[n] ‚ü∂ Z)\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.ext_iff","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\nx y : AlgebraicTopology.DoldKan.MorphComponents X n Z\n‚ä¢ Iff (Eq x y) (And (Eq x.a y.a) (Eq x.b y.b))","decl":"/-- The structure `MorphComponents` is an ad hoc structure that is used in\nthe proof that `N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms. The fields are the data that are needed in order to\nconstruct a morphism `X _[n+1] ‚ü∂ Z` (see `œÜ`) using the decomposition of the\nidentity given by `decomposition_Q n (n+1)`. -/\n@[ext]\nstructure MorphComponents (n : ‚Ñï) (Z : C) where\n  a : X _[n + 1] ‚ü∂ Z\n  b : Fin (n + 1) ‚Üí (X _[n] ‚ü∂ Z)\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\ninst‚úù : SizeOf C\na : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nb : Fin (HAdd.hAdd n 1) ‚Üí Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (SizeOf.sizeOf { a := a, b := b }) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- The structure `MorphComponents` is an ad hoc structure that is used in\nthe proof that `N‚ÇÅ : SimplicialObject C ‚•§ Karoubi (ChainComplex C ‚Ñï))`\nreflects isomorphisms. The fields are the data that are needed in order to\nconstruct a morphism `X _[n+1] ‚ü∂ Z` (see `œÜ`) using the decomposition of the\nidentity given by `decomposition_Q n (n+1)`. -/\n@[ext]\nstructure MorphComponents (n : ‚Ñï) (Z : C) where\n  a : X _[n + 1] ‚ü∂ Z\n  b : Fin (n + 1) ‚Üí (X _[n] ‚ü∂ Z)\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.id_b","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((AlgebraicTopology.DoldKan.MorphComponents.id X n).b i) (X.œÉ i)","decl":"/-- the canonical `MorphComponents` whose associated morphism is the identity\n(see `F_id`) thanks to `decomposition_Q n (n+1)` -/\n@[simps]\ndef id : MorphComponents X n (X _[n + 1]) where\n  a := PInfty.f (n + 1)\n  b i := X.œÉ i\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.id_a","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n‚ä¢ Eq (AlgebraicTopology.DoldKan.MorphComponents.id X n).a (AlgebraicTopology.DoldKan.PInfty.f (HAdd.hAdd n 1))","decl":"/-- the canonical `MorphComponents` whose associated morphism is the identity\n(see `F_id`) thanks to `decomposition_Q n (n+1)` -/\n@[simps]\ndef id : MorphComponents X n (X _[n + 1]) where\n  a := PInfty.f (n + 1)\n  b i := X.œÉ i\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.id_œÜ","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\n‚ä¢ Eq (AlgebraicTopology.DoldKan.MorphComponents.id X n).œÜ (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }))","decl":"@[simp]\ntheorem id_œÜ : (id X n).œÜ = ùüô _ := by\n  simp only [‚Üê P_add_Q_f (n + 1) (n + 1), œÜ]\n  congr 1\n  ¬∑ simp only [id, PInfty_f, P_f_idem]\n  ¬∑ exact Eq.trans (by congr; simp) (decomposition_Q n (n + 1)).symm\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.postComp_b","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ Z' : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\nh : Quiver.Hom Z Z'\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((f.postComp h).b i) (CategoryTheory.CategoryStruct.comp (f.b i) h)","decl":"/-- A `MorphComponents` can be postcomposed with a morphism. -/\n@[simps]\ndef postComp : MorphComponents X n Z' where\n  a := f.a ‚â´ h\n  b i := f.b i ‚â´ h\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.postComp_a","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ Z' : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\nh : Quiver.Hom Z Z'\n‚ä¢ Eq (f.postComp h).a (CategoryTheory.CategoryStruct.comp f.a h)","decl":"/-- A `MorphComponents` can be postcomposed with a morphism. -/\n@[simps]\ndef postComp : MorphComponents X n Z' where\n  a := f.a ‚â´ h\n  b i := f.b i ‚â´ h\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.postComp_œÜ","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nZ Z' : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\nh : Quiver.Hom Z Z'\n‚ä¢ Eq (f.postComp h).œÜ (CategoryTheory.CategoryStruct.comp f.œÜ h)","decl":"@[simp]\ntheorem postComp_œÜ : (f.postComp h).œÜ = f.œÜ ‚â´ h := by\n  unfold œÜ postComp\n  simp only [add_comp, sum_comp, assoc]\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.preComp_a","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX X' : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\ng : Quiver.Hom X' X\n‚ä¢ Eq (f.preComp g).a (CategoryTheory.CategoryStruct.comp (g.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) f.a)","decl":"/-- A `MorphComponents` can be precomposed with a morphism of simplicial objects. -/\n@[simps]\ndef preComp : MorphComponents X' n Z where\n  a := g.app (op [n + 1]) ‚â´ f.a\n  b i := g.app (op [n]) ‚â´ f.b i\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.preComp_b","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX X' : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\ng : Quiver.Hom X' X\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((f.preComp g).b i) (CategoryTheory.CategoryStruct.comp (g.app { unop := SimplexCategory.mk n }) (f.b i))","decl":"/-- A `MorphComponents` can be precomposed with a morphism of simplicial objects. -/\n@[simps]\ndef preComp : MorphComponents X' n Z where\n  a := g.app (op [n + 1]) ‚â´ f.a\n  b i := g.app (op [n]) ‚â´ f.b i\n\n"}
{"name":"AlgebraicTopology.DoldKan.MorphComponents.preComp_œÜ","module":"Mathlib.AlgebraicTopology.DoldKan.Decomposition","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX X' : CategoryTheory.SimplicialObject C\nn : Nat\nZ : C\nf : AlgebraicTopology.DoldKan.MorphComponents X n Z\ng : Quiver.Hom X' X\n‚ä¢ Eq (f.preComp g).œÜ (CategoryTheory.CategoryStruct.comp (g.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) f.œÜ)","decl":"@[simp]\ntheorem preComp_œÜ : (f.preComp g).œÜ = g.app (op [n + 1]) ‚â´ f.œÜ := by\n  unfold œÜ preComp\n  simp only [PInfty_f, comp_add]\n  congr 1\n  ¬∑ simp only [P_f_naturality_assoc]\n  ¬∑ simp only [comp_sum, P_f_naturality_assoc, SimplicialObject.Œ¥_naturality_assoc]\n\n"}
