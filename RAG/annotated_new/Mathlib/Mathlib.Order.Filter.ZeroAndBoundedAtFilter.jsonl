{"name":"Filter.zero_zeroAtFilter","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Zero Î²\ninstâœ : TopologicalSpace Î²\nl : Filter Î±\nâŠ¢ l.ZeroAtFilter 0","decl":"theorem zero_zeroAtFilter [Zero Î²] [TopologicalSpace Î²] (l : Filter Î±) :\n    ZeroAtFilter l (0 : Î± â†’ Î²) :=\n  tendsto_const_nhds\n\n"}
{"name":"Filter.ZeroAtFilter.add","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddZeroClass Î²\ninstâœ : ContinuousAdd Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nhf : l.ZeroAtFilter f\nhg : l.ZeroAtFilter g\nâŠ¢ l.ZeroAtFilter (HAdd.hAdd f g)","decl":"nonrec theorem ZeroAtFilter.add [TopologicalSpace Î²] [AddZeroClass Î²] [ContinuousAdd Î²]\n    {l : Filter Î±} {f g : Î± â†’ Î²} (hf : ZeroAtFilter l f) (hg : ZeroAtFilter l g) :\n    ZeroAtFilter l (f + g) := by\n  simpa using hf.add hg\n\n"}
{"name":"Filter.ZeroAtFilter.neg","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : AddGroup Î²\ninstâœ : ContinuousNeg Î²\nl : Filter Î±\nf : Î± â†’ Î²\nhf : l.ZeroAtFilter f\nâŠ¢ l.ZeroAtFilter (Neg.neg f)","decl":"nonrec theorem ZeroAtFilter.neg [TopologicalSpace Î²] [AddGroup Î²] [ContinuousNeg Î²] {l : Filter Î±}\n    {f : Î± â†’ Î²} (hf : ZeroAtFilter l f) : ZeroAtFilter l (-f) := by simpa using hf.neg\n\n"}
{"name":"Filter.ZeroAtFilter.smul","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"ğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : Zero ğ•œ\ninstâœÂ² : Zero Î²\ninstâœÂ¹ : SMulWithZero ğ•œ Î²\ninstâœ : ContinuousConstSMul ğ•œ Î²\nl : Filter Î±\nf : Î± â†’ Î²\nc : ğ•œ\nhf : l.ZeroAtFilter f\nâŠ¢ l.ZeroAtFilter (HSMul.hSMul c f)","decl":"theorem ZeroAtFilter.smul [TopologicalSpace Î²] [Zero ğ•œ] [Zero Î²]\n    [SMulWithZero ğ•œ Î²] [ContinuousConstSMul ğ•œ Î²] {l : Filter Î±} {f : Î± â†’ Î²} (c : ğ•œ)\n    (hf : ZeroAtFilter l f) : ZeroAtFilter l (c â€¢ f) := by simpa using hf.const_smul c\n\n"}
{"name":"Filter.ZeroAtFilter.boundedAtFilter","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SeminormedAddGroup Î²\nl : Filter Î±\nf : Î± â†’ Î²\nhf : l.ZeroAtFilter f\nâŠ¢ l.BoundedAtFilter f","decl":"theorem ZeroAtFilter.boundedAtFilter [SeminormedAddGroup Î²] {l : Filter Î±} {f : Î± â†’ Î²}\n    (hf : ZeroAtFilter l f) : BoundedAtFilter l f :=\n  ((Asymptotics.isLittleO_one_iff _).mpr hf).isBigO\n\n"}
{"name":"Filter.const_boundedAtFilter","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : Norm Î²\nl : Filter Î±\nc : Î²\nâŠ¢ l.BoundedAtFilter (Function.const Î± c)","decl":"theorem const_boundedAtFilter [Norm Î²] (l : Filter Î±) (c : Î²) :\n    BoundedAtFilter l (Function.const Î± c : Î± â†’ Î²) :=\n  Asymptotics.isBigO_const_const c one_ne_zero l\n\n-- TODO(https://github.com/leanprover-community/mathlib4/issues/19288): Remove all Comm in the next\n-- three lemmas. This would require modifying the corresponding general asymptotics lemma.\n"}
{"name":"Filter.BoundedAtFilter.add","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SeminormedAddCommGroup Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nhf : l.BoundedAtFilter f\nhg : l.BoundedAtFilter g\nâŠ¢ l.BoundedAtFilter (HAdd.hAdd f g)","decl":"nonrec theorem BoundedAtFilter.add [SeminormedAddCommGroup Î²] {l : Filter Î±} {f g : Î± â†’ Î²}\n    (hf : BoundedAtFilter l f) (hg : BoundedAtFilter l g) : BoundedAtFilter l (f + g) := by\n  simpa using hf.add hg\n\n"}
{"name":"Filter.BoundedAtFilter.neg","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SeminormedAddCommGroup Î²\nl : Filter Î±\nf : Î± â†’ Î²\nhf : l.BoundedAtFilter f\nâŠ¢ l.BoundedAtFilter (Neg.neg f)","decl":"theorem BoundedAtFilter.neg [SeminormedAddCommGroup Î²] {l : Filter Î±} {f : Î± â†’ Î²}\n    (hf : BoundedAtFilter l f) : BoundedAtFilter l (-f) :=\n  hf.neg_left\n\n"}
{"name":"Filter.BoundedAtFilter.smul","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"ğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup Î²\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nl : Filter Î±\nf : Î± â†’ Î²\nc : ğ•œ\nhf : l.BoundedAtFilter f\nâŠ¢ l.BoundedAtFilter (HSMul.hSMul c f)","decl":"theorem BoundedAtFilter.smul\n    [SeminormedRing ğ•œ] [SeminormedAddCommGroup Î²] [Module ğ•œ Î²] [BoundedSMul ğ•œ Î²]\n    {l : Filter Î±} {f : Î± â†’ Î²} (c : ğ•œ) (hf : BoundedAtFilter l f) : BoundedAtFilter l (c â€¢ f) :=\n  hf.const_smul_left c\n\n"}
{"name":"Filter.BoundedAtFilter.mul","module":"Mathlib.Order.Filter.ZeroAndBoundedAtFilter","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœ : SeminormedRing Î²\nl : Filter Î±\nf g : Î± â†’ Î²\nhf : l.BoundedAtFilter f\nhg : l.BoundedAtFilter g\nâŠ¢ l.BoundedAtFilter (HMul.hMul f g)","decl":"nonrec theorem BoundedAtFilter.mul [SeminormedRing Î²] {l : Filter Î±} {f g : Î± â†’ Î²}\n    (hf : BoundedAtFilter l f) (hg : BoundedAtFilter l g) : BoundedAtFilter l (f * g) := by\n  refine (hf.mul hg).trans ?_\n  convert Asymptotics.isBigO_refl (E := â„) _ l\n  simp\n\n"}
