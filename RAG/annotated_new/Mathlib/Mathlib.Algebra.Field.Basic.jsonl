{"name":"add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b c : K\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem add_div (a b c : K) : (a + b) / c = a / c + b / c := by simp_rw [div_eq_mul_inv, add_mul]\n\n"}
{"name":"div_add_div_same","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b c : K\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv (HAdd.hAdd a b) c)","decl":"@[field_simps]\ntheorem div_add_div_same (a b c : K) : a / c + b / c = (a + b) / c :=\n  (add_div _ _ _).symm\n\n"}
{"name":"same_add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nh : Ne b 0\n⊢ Eq (HDiv.hDiv (HAdd.hAdd b a) b) (HAdd.hAdd 1 (HDiv.hDiv a b))","decl":"theorem same_add_div (h : b ≠ 0) : (b + a) / b = 1 + a / b := by rw [← div_self h, add_div]\n\n"}
{"name":"div_add_same","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nh : Ne b 0\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) b) (HAdd.hAdd (HDiv.hDiv a b) 1)","decl":"theorem div_add_same (h : b ≠ 0) : (a + b) / b = a / b + 1 := by rw [← div_self h, add_div]\n\n"}
{"name":"one_add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nh : Ne b 0\n⊢ Eq (HAdd.hAdd 1 (HDiv.hDiv a b)) (HDiv.hDiv (HAdd.hAdd b a) b)","decl":"theorem one_add_div (h : b ≠ 0) : 1 + a / b = (b + a) / b :=\n  (same_add_div h).symm\n\n"}
{"name":"div_add_one","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nh : Ne b 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a b) 1) (HDiv.hDiv (HAdd.hAdd a b) b)","decl":"theorem div_add_one (h : b ≠ 0) : a / b + 1 = (a + b) / b :=\n  (div_add_same h).symm\n\n"}
{"name":"inv_add_inv'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (Inv.inv a) (Inv.inv b)) (HMul.hMul (HMul.hMul (Inv.inv a) (HAdd.hAdd a b)) (Inv.inv b))","decl":"/-- See `inv_add_inv` for the more convenient version when `K` is commutative. -/\ntheorem inv_add_inv' (ha : a ≠ 0) (hb : b ≠ 0) :\n    a⁻¹ + b⁻¹ = a⁻¹ * (a + b) * b⁻¹ :=\n  let _ := invertibleOfNonzero ha; let _ := invertibleOfNonzero hb; invOf_add_invOf a b\n\n"}
{"name":"one_div_mul_add_mul_one_div_eq_one_div_add_one_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HMul.hMul (HMul.hMul (HDiv.hDiv 1 a) (HAdd.hAdd a b)) (HDiv.hDiv 1 b)) (HAdd.hAdd (HDiv.hDiv 1 a) (HDiv.hDiv 1 b))","decl":"theorem one_div_mul_add_mul_one_div_eq_one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) :\n    1 / a * (a + b) * (1 / b) = 1 / a + 1 / b := by\n  simpa only [one_div] using (inv_add_inv' ha hb).symm\n\n"}
{"name":"add_div_eq_mul_add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\nc a b : K\nhc : Ne c 0\n⊢ Eq (HAdd.hAdd a (HDiv.hDiv b c)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul a c) b) c)","decl":"theorem add_div_eq_mul_add_div (a b : K) (hc : c ≠ 0) : a + b / c = (a * c + b) / c :=\n  (eq_div_iff_mul_eq hc).2 <| by rw [right_distrib, div_mul_cancel₀ _ hc]\n\n"}
{"name":"add_div'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b c : K\nhc : Ne c 0\n⊢ Eq (HAdd.hAdd b (HDiv.hDiv a c)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul b c) a) c)","decl":"@[field_simps]\ntheorem add_div' (a b c : K) (hc : c ≠ 0) : b + a / c = (b * c + a) / c := by\n  rw [add_div, mul_div_cancel_right₀ _ hc]\n\n"}
{"name":"div_add'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b c : K\nhc : Ne c 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a c) b) (HDiv.hDiv (HAdd.hAdd a (HMul.hMul b c)) c)","decl":"@[field_simps]\ntheorem div_add' (a b c : K) (hc : c ≠ 0) : a / c + b = (a + b * c) / c := by\n  rwa [add_comm, add_div', add_comm]\n\n"}
{"name":"Commute.div_add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b c d : K\nhbc : Commute b c\nhbd : Commute b d\nhb : Ne b 0\nhd : Ne d 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HMul.hMul b d))","decl":"protected theorem Commute.div_add_div (hbc : Commute b c) (hbd : Commute b d) (hb : b ≠ 0)\n    (hd : d ≠ 0) : a / b + c / d = (a * d + b * c) / (b * d) := by\n  rw [add_div, mul_div_mul_right _ b hd, hbc.eq, hbd.eq, mul_div_mul_right c d hb]\n\n"}
{"name":"Commute.one_div_add_one_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nhab : Commute a b\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv 1 a) (HDiv.hDiv 1 b)) (HDiv.hDiv (HAdd.hAdd a b) (HMul.hMul a b))","decl":"protected theorem Commute.one_div_add_one_div (hab : Commute a b) (ha : a ≠ 0) (hb : b ≠ 0) :\n    1 / a + 1 / b = (a + b) / (a * b) := by\n  rw [(Commute.one_right a).div_add_div hab ha hb, one_mul, mul_one, add_comm]\n\n"}
{"name":"Commute.inv_add_inv","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionSemiring K\na b : K\nhab : Commute a b\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (Inv.inv a) (Inv.inv b)) (HDiv.hDiv (HAdd.hAdd a b) (HMul.hMul a b))","decl":"protected theorem Commute.inv_add_inv (hab : Commute a b) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a⁻¹ + b⁻¹ = (a + b) / (a * b) := by\n  rw [inv_eq_one_div, inv_eq_one_div, hab.one_div_add_one_div ha hb]\n\n"}
{"name":"div_neg_self","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na : K\nh : Ne a 0\n⊢ Eq (HDiv.hDiv a (Neg.neg a)) (-1)","decl":"@[simp]\ntheorem div_neg_self {a : K} (h : a ≠ 0) : a / -a = -1 := by rw [div_neg_eq_neg_div, div_self h]\n\n"}
{"name":"neg_div_self","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na : K\nh : Ne a 0\n⊢ Eq (HDiv.hDiv (Neg.neg a) a) (-1)","decl":"@[simp]\ntheorem neg_div_self {a : K} (h : a ≠ 0) : -a / a = -1 := by rw [neg_div, div_self h]\n\n"}
{"name":"div_sub_div_same","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b c : K\n⊢ Eq (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c)) (HDiv.hDiv (HSub.hSub a b) c)","decl":"theorem div_sub_div_same (a b c : K) : a / c - b / c = (a - b) / c := by\n  rw [sub_eq_add_neg, ← neg_div, div_add_div_same, sub_eq_add_neg]\n\n"}
{"name":"same_sub_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nh : Ne b 0\n⊢ Eq (HDiv.hDiv (HSub.hSub b a) b) (HSub.hSub 1 (HDiv.hDiv a b))","decl":"theorem same_sub_div {a b : K} (h : b ≠ 0) : (b - a) / b = 1 - a / b := by\n  simpa only [← @div_self _ _ b h] using (div_sub_div_same b a b).symm\n\n"}
{"name":"one_sub_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nh : Ne b 0\n⊢ Eq (HSub.hSub 1 (HDiv.hDiv a b)) (HDiv.hDiv (HSub.hSub b a) b)","decl":"theorem one_sub_div {a b : K} (h : b ≠ 0) : 1 - a / b = (b - a) / b :=\n  (same_sub_div h).symm\n\n"}
{"name":"div_sub_same","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nh : Ne b 0\n⊢ Eq (HDiv.hDiv (HSub.hSub a b) b) (HSub.hSub (HDiv.hDiv a b) 1)","decl":"theorem div_sub_same {a b : K} (h : b ≠ 0) : (a - b) / b = a / b - 1 := by\n  simpa only [← @div_self _ _ b h] using (div_sub_div_same a b b).symm\n\n"}
{"name":"div_sub_one","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nh : Ne b 0\n⊢ Eq (HSub.hSub (HDiv.hDiv a b) 1) (HDiv.hDiv (HSub.hSub a b) b)","decl":"theorem div_sub_one {a b : K} (h : b ≠ 0) : a / b - 1 = (a - b) / b :=\n  (div_sub_same h).symm\n\n"}
{"name":"sub_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b c : K\n⊢ Eq (HDiv.hDiv (HSub.hSub a b) c) (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem sub_div (a b c : K) : (a - b) / c = a / c - b / c :=\n  (div_sub_div_same _ _ _).symm\n\n"}
{"name":"inv_sub_inv'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HSub.hSub (Inv.inv a) (Inv.inv b)) (HMul.hMul (HMul.hMul (Inv.inv a) (HSub.hSub b a)) (Inv.inv b))","decl":"/-- See `inv_sub_inv` for the more convenient version when `K` is commutative. -/\ntheorem inv_sub_inv' {a b : K} (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ - b⁻¹ = a⁻¹ * (b - a) * b⁻¹ :=\n  let _ := invertibleOfNonzero ha; let _ := invertibleOfNonzero hb; invOf_sub_invOf a b\n\n"}
{"name":"one_div_mul_sub_mul_one_div_eq_one_div_add_one_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HMul.hMul (HMul.hMul (HDiv.hDiv 1 a) (HSub.hSub b a)) (HDiv.hDiv 1 b)) (HSub.hSub (HDiv.hDiv 1 a) (HDiv.hDiv 1 b))","decl":"theorem one_div_mul_sub_mul_one_div_eq_one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) :\n    1 / a * (b - a) * (1 / b) = 1 / a - 1 / b := by\n  simpa only [one_div] using (inv_sub_inv' ha hb).symm\n\n-- see Note [lower instance priority]\n"}
{"name":"DivisionRing.isDomain","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\n⊢ IsDomain K","decl":"instance (priority := 100) DivisionRing.isDomain : IsDomain K :=\n  NoZeroDivisors.to_isDomain _\n\n"}
{"name":"Commute.div_sub_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b c d : K\nhbc : Commute b c\nhbd : Commute b d\nhb : Ne b 0\nhd : Ne d 0\n⊢ Eq (HSub.hSub (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HSub.hSub (HMul.hMul a d) (HMul.hMul b c)) (HMul.hMul b d))","decl":"protected theorem Commute.div_sub_div (hbc : Commute b c) (hbd : Commute b d) (hb : b ≠ 0)\n    (hd : d ≠ 0) : a / b - c / d = (a * d - b * c) / (b * d) := by\n  simpa only [mul_neg, neg_div, ← sub_eq_add_neg] using hbc.neg_right.div_add_div hbd hb hd\n\n"}
{"name":"Commute.inv_sub_inv","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : DivisionRing K\na b : K\nhab : Commute a b\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HSub.hSub (Inv.inv a) (Inv.inv b)) (HDiv.hDiv (HSub.hSub b a) (HMul.hMul a b))","decl":"protected theorem Commute.inv_sub_inv (hab : Commute a b) (ha : a ≠ 0) (hb : b ≠ 0) :\n    a⁻¹ - b⁻¹ = (b - a) / (a * b) := by\n  simp only [inv_eq_one_div, (Commute.one_right a).div_sub_div hab ha hb, one_mul, mul_one]\n\n"}
{"name":"div_add_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Semifield K\nb d a c : K\nhb : Ne b 0\nhd : Ne d 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HMul.hMul b d))","decl":"theorem div_add_div (a : K) (c : K) (hb : b ≠ 0) (hd : d ≠ 0) :\n    a / b + c / d = (a * d + b * c) / (b * d) :=\n  (Commute.all b _).div_add_div (Commute.all _ _) hb hd\n\n"}
{"name":"one_div_add_one_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Semifield K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (HDiv.hDiv 1 a) (HDiv.hDiv 1 b)) (HDiv.hDiv (HAdd.hAdd a b) (HMul.hMul a b))","decl":"theorem one_div_add_one_div (ha : a ≠ 0) (hb : b ≠ 0) : 1 / a + 1 / b = (a + b) / (a * b) :=\n  (Commute.all a _).one_div_add_one_div ha hb\n\n"}
{"name":"inv_add_inv","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Semifield K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HAdd.hAdd (Inv.inv a) (Inv.inv b)) (HDiv.hDiv (HAdd.hAdd a b) (HMul.hMul a b))","decl":"theorem inv_add_inv (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ + b⁻¹ = (a + b) / (a * b) :=\n  (Commute.all a _).inv_add_inv ha hb\n\n"}
{"name":"div_sub_div","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\na b c d : K\nhb : Ne b 0\nhd : Ne d 0\n⊢ Eq (HSub.hSub (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HSub.hSub (HMul.hMul a d) (HMul.hMul b c)) (HMul.hMul b d))","decl":"@[field_simps]\ntheorem div_sub_div (a : K) {b : K} (c : K) {d : K} (hb : b ≠ 0) (hd : d ≠ 0) :\n    a / b - c / d = (a * d - b * c) / (b * d) :=\n  (Commute.all b _).div_sub_div (Commute.all _ _) hb hd\n\n"}
{"name":"inv_sub_inv","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\na b : K\nha : Ne a 0\nhb : Ne b 0\n⊢ Eq (HSub.hSub (Inv.inv a) (Inv.inv b)) (HDiv.hDiv (HSub.hSub b a) (HMul.hMul a b))","decl":"theorem inv_sub_inv {a b : K} (ha : a ≠ 0) (hb : b ≠ 0) : a⁻¹ - b⁻¹ = (b - a) / (a * b) := by\n  rw [inv_eq_one_div, inv_eq_one_div, div_sub_div _ _ ha hb, one_mul, mul_one]\n\n"}
{"name":"sub_div'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\na b c : K\nhc : Ne c 0\n⊢ Eq (HSub.hSub b (HDiv.hDiv a c)) (HDiv.hDiv (HSub.hSub (HMul.hMul b c) a) c)","decl":"@[field_simps]\ntheorem sub_div' (a b c : K) (hc : c ≠ 0) : b - a / c = (b * c - a) / c := by\n  simpa using div_sub_div b a one_ne_zero hc\n\n"}
{"name":"div_sub'","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\na b c : K\nhc : Ne c 0\n⊢ Eq (HSub.hSub (HDiv.hDiv a c) b) (HDiv.hDiv (HSub.hSub a (HMul.hMul c b)) c)","decl":"@[field_simps]\ntheorem div_sub' (a b c : K) (hc : c ≠ 0) : a / c - b = (a - c * b) / c := by\n  simpa using div_sub_div a b hc one_ne_zero\n\n-- see Note [lower instance priority]\n"}
{"name":"Field.isDomain","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\n⊢ IsDomain K","decl":"instance (priority := 100) Field.isDomain : IsDomain K :=\n  { DivisionRing.isDomain with }\n\n"}
{"name":"toDual_ratCast","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : RatCast K\nn : Rat\n⊢ Eq (OrderDual.toDual ↑n) ↑n","decl":"@[simp] lemma toDual_ratCast [RatCast K] (n : ℚ) : toDual (n : K) = n := rfl\n\n"}
{"name":"ofDual_ratCast","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : RatCast K\nn : Rat\n⊢ Eq (OrderDual.ofDual ↑n) ↑n","decl":"@[simp] lemma ofDual_ratCast [RatCast K] (n : ℚ) : (ofDual n : K) = n := rfl\n\n"}
{"name":"toLex_ratCast","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : RatCast K\nn : Rat\n⊢ Eq (toLex ↑n) ↑n","decl":"@[simp] lemma toLex_ratCast [RatCast K] (n : ℚ) : toLex (n : K) = n := rfl\n\n"}
{"name":"ofLex_ratCast","module":"Mathlib.Algebra.Field.Basic","initialProofState":"K : Type u_1\ninst✝ : RatCast K\nn : Rat\n⊢ Eq (ofLex ↑n) ↑n","decl":"@[simp] lemma ofLex_ratCast [RatCast K] (n : ℚ) : (ofLex n : K) = n := rfl\n"}
