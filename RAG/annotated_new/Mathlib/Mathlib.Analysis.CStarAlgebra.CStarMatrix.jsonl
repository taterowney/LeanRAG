{"name":"CStarMatrix.ofMatrix_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM : Matrix m n A\ni : m\n⊢ Eq (CStarMatrix.ofMatrix M i) (M i)","decl":"@[simp]\nlemma ofMatrix_apply {M : Matrix m n A} {i : m} : (ofMatrix M) i = M i := rfl\n\n"}
{"name":"CStarMatrix.ofMatrix_symm_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\ni : m\n⊢ Eq (CStarMatrix.ofMatrix.symm M i) (M i)","decl":"@[simp]\nlemma ofMatrix_symm_apply {M : CStarMatrix m n A} {i : m} : (ofMatrix.symm M) i = M i := rfl\n\n"}
{"name":"CStarMatrix.ext_iff","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM N : CStarMatrix m n A\n⊢ Iff (∀ (i : m) (j : n), Eq (M i j) (N i j)) (Eq M N)","decl":"theorem ext_iff {M N : CStarMatrix m n A} : (∀ i j, M i j = N i j) ↔ M = N :=\n  ⟨fun h => funext fun i => funext <| h i, fun h => by simp [h]⟩\n\n"}
{"name":"CStarMatrix.ext","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM₁ M₂ : CStarMatrix m n A\nh : ∀ (i : m) (j : n), Eq (M₁ i j) (M₂ i j)\n⊢ Eq M₁ M₂","decl":"@[ext]\nlemma ext {M₁ M₂ : CStarMatrix m n A} (h : ∀ i j, M₁ i j = M₂ i j) : M₁ = M₂ := ext_iff.mp h\n\n"}
{"name":"CStarMatrix.map_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nB : Type u_4\nM : CStarMatrix m n A\nf : A → B\ni : m\nj : n\n⊢ Eq (M.map f i j) (f (M i j))","decl":"@[simp]\ntheorem map_apply {M : CStarMatrix m n A} {f : A → B} {i : m} {j : n} : M.map f i j = f (M i j) :=\n  rfl\n\n"}
{"name":"CStarMatrix.map_id","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\n⊢ Eq (M.map id) M","decl":"@[simp]\ntheorem map_id (M : CStarMatrix m n A) : M.map id = M := by\n  ext\n  rfl\n\n"}
{"name":"CStarMatrix.map_id'","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\n⊢ Eq (M.map fun x => x) M","decl":"@[simp]\ntheorem map_id' (M : CStarMatrix m n A) : M.map (·) = M := map_id M\n\n"}
{"name":"CStarMatrix.map_map","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nB : Type u_4\nC : Type u_7\nM : Matrix m n A\nf : A → B\ng : B → C\n⊢ Eq ((M.map f).map g) (M.map (Function.comp g f))","decl":"theorem map_map {C : Type*} {M : Matrix m n A} {f : A → B} {g : B → C} :\n    (M.map f).map g = M.map (g ∘ f) := by ext; rfl\n\n"}
{"name":"CStarMatrix.map_injective","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nB : Type u_4\nf : A → B\nhf : Function.Injective f\n⊢ Function.Injective fun M => M.map f","decl":"theorem map_injective {f : A → B} (hf : Function.Injective f) :\n    Function.Injective fun M : CStarMatrix m n A => M.map f := fun _ _ h =>\n  ext fun i j => hf <| ext_iff.mpr h i j\n\n"}
{"name":"CStarMatrix.transpose_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nM : CStarMatrix m n A\ni : n\nj : m\n⊢ Eq (M.transpose i j) (M j i)","decl":"@[simp]\ntheorem transpose_apply (M : CStarMatrix m n A) (i j) : transpose M i j = M j i :=\n  rfl\n\n"}
{"name":"CStarMatrix.instFinite","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_7\nm : Type u_8\ninst✝² : Finite m\ninst✝¹ : Finite n\nα : Type u_9\ninst✝ : Finite α\n⊢ Finite (CStarMatrix m n α)","decl":"instance {n m} [Finite m] [Finite n] (α) [Finite α] :\n    Finite (CStarMatrix m n α) := inferInstanceAs (Finite (m → n → α))\n\n"}
{"name":"CStarMatrix.instSubsingleton","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Subsingleton A\n⊢ Subsingleton (CStarMatrix m n A)","decl":"instance instSubsingleton [Subsingleton A] : Subsingleton (CStarMatrix m n A) :=\n  inferInstanceAs <| Subsingleton <| m → n → A\n\n"}
{"name":"CStarMatrix.instNontrivial","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝² : Nonempty m\ninst✝¹ : Nonempty n\ninst✝ : Nontrivial A\n⊢ Nontrivial (CStarMatrix m n A)","decl":"instance instNontrivial [Nonempty m] [Nonempty n] [Nontrivial A] : Nontrivial (CStarMatrix m n A) :=\n  Function.nontrivial\n\n"}
{"name":"CStarMatrix.instSMulCommClass","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝² : SMul R A\ninst✝¹ : SMul S A\ninst✝ : SMulCommClass R S A\n⊢ SMulCommClass R S (CStarMatrix m n A)","decl":"instance instSMulCommClass [SMul R A] [SMul S A] [SMulCommClass R S A] :\n    SMulCommClass R S (CStarMatrix m n A) :=\n  Pi.smulCommClass\n\n"}
{"name":"CStarMatrix.instIsScalarTower","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\nS : Type u_6\ninst✝³ : SMul R S\ninst✝² : SMul R A\ninst✝¹ : SMul S A\ninst✝ : IsScalarTower R S A\n⊢ IsScalarTower R S (CStarMatrix m n A)","decl":"instance instIsScalarTower [SMul R S] [SMul R A] [SMul S A] [IsScalarTower R S A] :\n    IsScalarTower R S (CStarMatrix m n A) :=\n  Pi.isScalarTower\n\n"}
{"name":"CStarMatrix.instIsCentralScalar","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\ninst✝² : SMul R A\ninst✝¹ : SMul (MulOpposite R) A\ninst✝ : IsCentralScalar R A\n⊢ IsCentralScalar R (CStarMatrix m n A)","decl":"instance instIsCentralScalar [SMul R A] [SMul Rᵐᵒᵖ A] [IsCentralScalar R A] :\n    IsCentralScalar R (CStarMatrix m n A) :=\n  Pi.isCentralScalar\n\n"}
{"name":"CStarMatrix.zero_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Zero A\ni : m\nj : n\n⊢ Eq (0 i j) 0","decl":"@[simp, nolint simpNF]\ntheorem zero_apply [Zero A] (i : m) (j : n) : (0 : CStarMatrix m n A) i j = 0 := rfl\n\n"}
{"name":"CStarMatrix.add_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Add A\nM N : CStarMatrix m n A\ni : m\nj : n\n⊢ Eq (HAdd.hAdd M N i j) (HAdd.hAdd (M i j) (N i j))","decl":"@[simp] theorem add_apply [Add A] (M N : CStarMatrix m n A) (i : m) (j : n) :\n    (M + N) i j = (M i j) + (N i j) := rfl\n\n"}
{"name":"CStarMatrix.smul_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝ : SMul B A\nr : B\nM : Matrix m n A\ni : m\nj : n\n⊢ Eq (HSMul.hSMul r M i j) (HSMul.hSMul r (M i j))","decl":"@[simp] theorem smul_apply [SMul B A] (r : B) (M : Matrix m n A) (i : m) (j : n) :\n    (r • M) i j = r • (M i j) := rfl\n\n"}
{"name":"CStarMatrix.sub_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Sub A\nM N : Matrix m n A\ni : m\nj : n\n⊢ Eq (HSub.hSub M N i j) (HSub.hSub (M i j) (N i j))","decl":"@[simp] theorem sub_apply [Sub A] (M N : Matrix m n A) (i : m) (j : n) :\n    (M - N) i j = (M i j) - (N i j) := rfl\n\n"}
{"name":"CStarMatrix.neg_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Neg A\nM : Matrix m n A\ni : m\nj : n\n⊢ Eq (Neg.neg M i j) (Neg.neg (M i j))","decl":"@[simp] theorem neg_apply [Neg A] (M : Matrix m n A) (i : m) (j : n) :\n    (-M) i j = -(M i j) := rfl\n\n"}
{"name":"CStarMatrix.of_zero","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Zero A\n⊢ Eq (CStarMatrix.ofMatrix 0) 0","decl":"@[simp] theorem of_zero [Zero A] : ofMatrix (0 : Matrix m n A) = 0 := rfl\n\n"}
{"name":"CStarMatrix.of_add_of","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Add A\nf g : Matrix m n A\n⊢ Eq (HAdd.hAdd (CStarMatrix.ofMatrix f) (CStarMatrix.ofMatrix g)) (CStarMatrix.ofMatrix (HAdd.hAdd f g))","decl":"@[simp] theorem of_add_of [Add A] (f g : Matrix m n A) :\n    ofMatrix f + ofMatrix g = ofMatrix (f + g) := rfl\n\n"}
{"name":"CStarMatrix.of_sub_of","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Sub A\nf g : Matrix m n A\n⊢ Eq (HSub.hSub (CStarMatrix.ofMatrix f) (CStarMatrix.ofMatrix g)) (CStarMatrix.ofMatrix (HSub.hSub f g))","decl":"@[simp]\ntheorem of_sub_of [Sub A] (f g : Matrix m n A) : ofMatrix f - ofMatrix g = ofMatrix (f - g) :=\n  rfl\n\n"}
{"name":"CStarMatrix.neg_of","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : Neg A\nf : Matrix m n A\n⊢ Eq (Neg.neg (CStarMatrix.ofMatrix f)) (CStarMatrix.ofMatrix (Neg.neg f))","decl":"@[simp] theorem neg_of [Neg A] (f : Matrix m n A) : -ofMatrix f = ofMatrix (-f) := rfl\n\n"}
{"name":"CStarMatrix.smul_of","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\ninst✝ : SMul R A\nr : R\nf : Matrix m n A\n⊢ Eq (HSMul.hSMul r (CStarMatrix.ofMatrix f)) (CStarMatrix.ofMatrix (HSMul.hSMul r f))","decl":"@[simp] theorem smul_of [SMul R A] (r : R) (f : Matrix m n A) :\n    r • ofMatrix f = ofMatrix (r • f) := rfl\n\n"}
{"name":"CStarMatrix.instStarModule","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\nR : Type u_5\ninst✝³ : Star R\ninst✝² : Star A\ninst✝¹ : SMul R A\ninst✝ : StarModule R A\n⊢ StarModule R (CStarMatrix n n A)","decl":"instance instStarModule [Star R] [Star A] [SMul R A] [StarModule R A] :\n    StarModule R (CStarMatrix n n A) where\n  star_smul := star_smul (A := Matrix n n A)\n\n"}
{"name":"CStarMatrix.one_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝² : Zero A\ninst✝¹ : One A\ninst✝ : DecidableEq n\ni j : n\n⊢ Eq (1 i j) (ite (Eq i j) 1 0)","decl":"theorem one_apply {i j} : (1 : CStarMatrix n n A) i j = if i = j then 1 else 0 := rfl\n\n"}
{"name":"CStarMatrix.one_apply_eq","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝² : Zero A\ninst✝¹ : One A\ninst✝ : DecidableEq n\ni : n\n⊢ Eq (1 i i) 1","decl":"@[simp]\ntheorem one_apply_eq (i) : (1 : CStarMatrix n n A) i i = 1 := Matrix.one_apply_eq _\n\n"}
{"name":"CStarMatrix.one_apply_ne","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝² : Zero A\ninst✝¹ : One A\ninst✝ : DecidableEq n\ni j : n\na✝ : Ne i j\n⊢ Eq (1 i j) 0","decl":"@[simp] theorem one_apply_ne {i j} : i ≠ j → (1 : CStarMatrix n n A) i j = 0 := Matrix.one_apply_ne\n\n"}
{"name":"CStarMatrix.one_apply_ne'","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝² : Zero A\ninst✝¹ : One A\ninst✝ : DecidableEq n\ni j : n\na✝ : Ne j i\n⊢ Eq (1 i j) 0","decl":"theorem one_apply_ne' {i j} : j ≠ i → (1 : CStarMatrix n n A) i j = 0 := Matrix.one_apply_ne'\n\n"}
{"name":"CStarMatrix.mul_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nl : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Mul A\ninst✝ : AddCommMonoid A\nM : CStarMatrix l m A\nN : CStarMatrix m n A\ni : l\nk : n\n⊢ Eq (HMul.hMul M N i k) (Finset.univ.sum fun j => HMul.hMul (M i j) (N j k))","decl":"theorem mul_apply {l : Type*} [Fintype m] [Mul A] [AddCommMonoid A] {M : CStarMatrix l m A}\n    {N : CStarMatrix m n A} {i k} : (M * N) i k = ∑ j, M i j * N j k := rfl\n\n"}
{"name":"CStarMatrix.mul_apply'","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nl : Type u_7\ninst✝² : Fintype m\ninst✝¹ : Mul A\ninst✝ : AddCommMonoid A\nM : CStarMatrix l m A\nN : CStarMatrix m n A\ni : l\nk : n\n⊢ Eq (HMul.hMul M N i k) (dotProduct (fun j => M i j) fun j => N j k)","decl":"theorem mul_apply' {l : Type*} [Fintype m] [Mul A] [AddCommMonoid A] {M : CStarMatrix l m A}\n    {N : CStarMatrix m n A} {i k} : (M * N) i k = (fun j => M i j) ⬝ᵥ fun j => N j k := rfl\n\n"}
{"name":"CStarMatrix.smul_mul","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\nl : Type u_7\ninst✝⁵ : Fintype n\ninst✝⁴ : Monoid R\ninst✝³ : AddCommMonoid A\ninst✝² : Mul A\ninst✝¹ : DistribMulAction R A\ninst✝ : IsScalarTower R A A\na : R\nM : CStarMatrix m n A\nN : CStarMatrix n l A\n⊢ Eq (HMul.hMul (HSMul.hSMul a M) N) (HSMul.hSMul a (HMul.hMul M N))","decl":"@[simp]\ntheorem smul_mul {l : Type*} [Fintype n] [Monoid R] [AddCommMonoid A] [Mul A] [DistribMulAction R A]\n    [IsScalarTower R A A] (a : R) (M : CStarMatrix m n A) (N : CStarMatrix n l A) :\n    (a • M) * N = a • (M * N) := Matrix.smul_mul a M N\n\n"}
{"name":"CStarMatrix.mul_smul","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\nR : Type u_5\nl : Type u_7\ninst✝⁵ : Fintype n\ninst✝⁴ : Monoid R\ninst✝³ : AddCommMonoid A\ninst✝² : Mul A\ninst✝¹ : DistribMulAction R A\ninst✝ : SMulCommClass R A A\nM : Matrix m n A\na : R\nN : Matrix n l A\n⊢ Eq (HMul.hMul M (HSMul.hSMul a N)) (HSMul.hSMul a (HMul.hMul M N))","decl":"theorem mul_smul {l : Type*} [Fintype n] [Monoid R] [AddCommMonoid A] [Mul A] [DistribMulAction R A]\n    [SMulCommClass R A A] (M : Matrix m n A) (a : R) (N : Matrix n l A) :\n    M * (a • N) = a • (M * N) := Matrix.mul_smul M a N\n\n"}
{"name":"CStarMatrix.ofMatrix_eq_ofMatrixStarAlgEquiv","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝³ : Fintype n\ninst✝² : SMul Complex A\ninst✝¹ : Semiring A\ninst✝ : StarRing A\n⊢ Eq ⇑CStarMatrix.ofMatrix ⇑CStarMatrix.ofMatrixStarAlgEquiv","decl":"lemma ofMatrix_eq_ofMatrixStarAlgEquiv [Fintype n] [SMul ℂ A] [Semiring A] [StarRing A] :\n    (ofMatrix : Matrix n n A → CStarMatrix n n A)\n      = (ofMatrixStarAlgEquiv : Matrix n n A → CStarMatrix n n A) := rfl\n\n"}
{"name":"CStarMatrix.toCLM_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\nv : WithCStarModule (n → A)\n⊢ Eq ((CStarMatrix.toCLM M) v) ((WithCStarModule.equiv (m → A)).symm (Matrix.mulVec M v))","decl":"lemma toCLM_apply {M : CStarMatrix m n A} {v : C⋆ᵐᵒᵈ (n → A)} :\n    toCLM M v = (WithCStarModule.equiv _).symm (M.mulVec v) := rfl\n\n"}
{"name":"CStarMatrix.toCLM_apply_eq_sum","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\nv : WithCStarModule (n → A)\n⊢ Eq ((CStarMatrix.toCLM M) v) ((WithCStarModule.equiv (m → A)).symm fun i => Finset.univ.sum fun j => HMul.hMul (M i j) (v j))","decl":"lemma toCLM_apply_eq_sum {M : CStarMatrix m n A} {v : C⋆ᵐᵒᵈ (n → A)} :\n    toCLM M v = (WithCStarModule.equiv _).symm (fun i => ∑ j, M i j * v j) := by\n  ext i\n  simp [toCLM_apply, Matrix.mulVec, dotProduct]\n\n"}
{"name":"CStarMatrix.toCLMNonUnitalAlgHom_eq_toCLM","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix n n A\n⊢ Eq (CStarMatrix.toCLMNonUnitalAlgHom M) (CStarMatrix.toCLM M)","decl":"lemma toCLMNonUnitalAlgHom_eq_toCLM {M : CStarMatrix n n A} :\n    toCLMNonUnitalAlgHom (A := A) M = toCLM M := rfl\n\n"}
{"name":"CStarMatrix.toCLM_apply_single","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : NonUnitalCStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq n\nM : CStarMatrix m n A\nj : n\na : A\n⊢ Eq ((CStarMatrix.toCLM M) ((WithCStarModule.equiv (n → A)).symm (Pi.single j a))) ((WithCStarModule.equiv (m → A)).symm fun i => HMul.hMul (M i j) a)","decl":"open WithCStarModule in\n@[simp high]\nlemma toCLM_apply_single [DecidableEq n] {M : CStarMatrix m n A} {j : n} (a : A) :\n    (toCLM M) (equiv _ |>.symm <| Pi.single j a) = (equiv _).symm (fun i => M i j * a) := by\n  ext\n  simp [toCLM_apply, EmbeddingLike.apply_eq_iff_eq, equiv, Equiv.refl]\n\n"}
{"name":"CStarMatrix.toCLM_apply_single_apply","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : NonUnitalCStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq n\nM : CStarMatrix m n A\ni : m\nj : n\na : A\n⊢ Eq ((CStarMatrix.toCLM M) ((WithCStarModule.equiv (n → A)).symm (Pi.single j a)) i) (HMul.hMul (M i j) a)","decl":"open WithCStarModule in\nlemma toCLM_apply_single_apply [DecidableEq n] {M : CStarMatrix m n A} {i : m} {j : n} (a : A) :\n    (toCLM M) (equiv _ |>.symm <| Pi.single j a) i = M i j * a := by simp\n\n"}
{"name":"CStarMatrix.mul_entry_mul_eq_inner_toCLM","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁶ : Fintype m\ninst✝⁵ : Fintype n\ninst✝⁴ : NonUnitalCStarAlgebra A\ninst✝³ : PartialOrder A\ninst✝² : StarOrderedRing A\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nM : CStarMatrix m n A\ni : m\nj : n\na b : A\n⊢ Eq (HMul.hMul (HMul.hMul (Star.star a) (M i j)) b) (Inner.inner ((WithCStarModule.equiv (m → A)).symm (Pi.single i a)) ((CStarMatrix.toCLM M) ((WithCStarModule.equiv (n → A)).symm (Pi.single j b))))","decl":"open WithCStarModule in\nlemma mul_entry_mul_eq_inner_toCLM [DecidableEq m] [DecidableEq n] {M : CStarMatrix m n A}\n    {i : m} {j : n} (a b : A) :\n    star a * M i j * b\n      = ⟪equiv _ |>.symm (Pi.single i a), toCLM M (equiv _ |>.symm <| Pi.single j b)⟫_A := by\n  simp [mul_assoc, inner_def]\n\n"}
{"name":"CStarMatrix.toCLM_injective","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : NonUnitalCStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq n\n⊢ Function.Injective ⇑CStarMatrix.toCLM","decl":"lemma toCLM_injective [DecidableEq n] : Function.Injective (toCLM (A := A) (m := m) (n := n)) := by\n  rw [injective_iff_map_eq_zero]\n  intro M h\n  ext i j\n  rw [Matrix.zero_apply, ← norm_eq_zero, ← sq_eq_zero_iff, sq, ← CStarRing.norm_self_mul_star,\n    ← toCLM_apply_single_apply]\n  simp [h]\n\n"}
{"name":"CStarMatrix.inner_toCLM_conjTranspose_left","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\nv : WithCStarModule (m → A)\nw : WithCStarModule (n → A)\n⊢ Eq (Inner.inner ((CStarMatrix.toCLM (Matrix.conjTranspose M)) v) w) (Inner.inner v ((CStarMatrix.toCLM M) w))","decl":"open WithCStarModule in\nlemma inner_toCLM_conjTranspose_left {M : CStarMatrix m n A} {v : C⋆ᵐᵒᵈ (m → A)}\n    {w : C⋆ᵐᵒᵈ (n → A)} : ⟪toCLM Mᴴ v, w⟫_A = ⟪v, toCLM M w⟫_A := by\n  simp only [toCLM_apply_eq_sum, pi_inner, equiv_symm_pi_apply, inner_def, Finset.mul_sum,\n    Matrix.conjTranspose_apply, star_sum, star_mul, star_star, Finset.sum_mul]\n  rw [Finset.sum_comm]\n  simp_rw [mul_assoc]\n\n"}
{"name":"CStarMatrix.inner_toCLM_conjTranspose_right","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\nv : WithCStarModule (n → A)\nw : WithCStarModule (m → A)\n⊢ Eq (Inner.inner v ((CStarMatrix.toCLM (Matrix.conjTranspose M)) w)) (Inner.inner ((CStarMatrix.toCLM M) v) w)","decl":"lemma inner_toCLM_conjTranspose_right {M : CStarMatrix m n A} {v : C⋆ᵐᵒᵈ (n → A)}\n    {w : C⋆ᵐᵒᵈ (m → A)} : ⟪v, toCLM Mᴴ w⟫_A = ⟪toCLM M v, w⟫_A := by\n  apply Eq.symm\n  simpa using inner_toCLM_conjTranspose_left (M := Mᴴ) (v := v) (w := w)\n\n"}
{"name":"CStarMatrix.norm_def","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\n⊢ Eq (Norm.norm M) (Norm.norm (CStarMatrix.toCLM M))","decl":"lemma norm_def {M : CStarMatrix m n A} : ‖M‖ = ‖toCLM M‖ := rfl\n\n"}
{"name":"CStarMatrix.norm_def'","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"n : Type u_2\nA : Type u_3\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix n n A\n⊢ Eq (Norm.norm M) (Norm.norm (CStarMatrix.toCLMNonUnitalAlgHom M))","decl":"lemma norm_def' {M : CStarMatrix n n A} : ‖M‖ = ‖toCLMNonUnitalAlgHom (A := A) M‖ := rfl\n\n"}
{"name":"CStarMatrix.normedSpaceCore","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : NonUnitalCStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq n\n⊢ NormedSpace.Core Complex (CStarMatrix m n A)","decl":"set_option maxSynthPendingDepth 2 in\nlemma normedSpaceCore [DecidableEq n]: NormedSpace.Core ℂ (CStarMatrix m n A) where\n  norm_nonneg M := (toCLM M).opNorm_nonneg\n  norm_smul c M := by rw [norm_def, norm_def, map_smul, norm_smul _ (toCLM M)]\n  norm_triangle M₁ M₂ := by simpa [← map_add] using norm_add_le (toCLM M₁) (toCLM M₂)\n  norm_eq_zero_iff := by\n    simpa only [norm_def, norm_eq_zero, ← injective_iff_map_eq_zero'] using toCLM_injective\n\n"}
{"name":"CStarMatrix.norm_entry_le_norm","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : NonUnitalCStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : DecidableEq n\nM : CStarMatrix m n A\ni : m\nj : n\n⊢ LE.le (Norm.norm (M i j)) (Norm.norm M)","decl":"open WithCStarModule in\nlemma norm_entry_le_norm [DecidableEq n] {M : CStarMatrix m n A} {i : m} {j : n} :\n    ‖M i j‖ ≤ ‖M‖ := by\n  suffices ‖M i j‖ * ‖M i j‖ ≤ ‖M‖ * ‖M i j‖ by\n    obtain (h | h) := eq_zero_or_norm_pos (M i j)\n    · set_option maxSynthPendingDepth 2 in\n      simp [h, norm_def]\n    · exact le_of_mul_le_mul_right this h\n  rw [← CStarRing.norm_self_mul_star, ← toCLM_apply_single_apply]\n  apply norm_apply_le_norm _ _ |>.trans\n  apply (toCLM M).le_opNorm _ |>.trans\n  simp [norm_def]\n\n"}
{"name":"CStarMatrix.norm_le_of_forall_inner_le","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝⁴ : Fintype m\ninst✝³ : Fintype n\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nM : CStarMatrix m n A\nC : NNReal\nh : ∀ (v : WithCStarModule (n → A)) (w : WithCStarModule (m → A)), LE.le (Norm.norm (Inner.inner w ((CStarMatrix.toCLM M) v))) (HMul.hMul (HMul.hMul (↑C) (Norm.norm v)) (Norm.norm w))\n⊢ LE.le (Norm.norm M) ↑C","decl":"open CStarModule in\nlemma norm_le_of_forall_inner_le {M : CStarMatrix m n A} {C : ℝ≥0}\n    (h : ∀ v w, ‖⟪w, toCLM M v⟫_A‖ ≤ C * ‖v‖ * ‖w‖) : ‖M‖ ≤ C := by\n  refine (toCLM M).opNorm_le_bound (by simp) fun v ↦ ?_\n  obtain (h₀ | h₀) := (norm_nonneg (toCLM M v)).eq_or_lt\n  · rw [← h₀]\n    positivity\n  · refine le_of_mul_le_mul_right ?_ h₀\n    simpa [← sq, norm_sq_eq] using h ..\n\n"}
{"name":"CStarMatrix.instCompleteSpace","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\n⊢ CompleteSpace (CStarMatrix m n A)","decl":"instance instCompleteSpace : CompleteSpace (CStarMatrix m n A) := Pi.complete _\n"}
{"name":"CStarMatrix.instT2Space","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\n⊢ T2Space (CStarMatrix m n A)","decl":"instance instT2Space : T2Space (CStarMatrix m n A) := Pi.t2Space\n"}
{"name":"CStarMatrix.instT3Space","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\n⊢ T3Space (CStarMatrix m n A)","decl":"instance instT3Space : T3Space (CStarMatrix m n A) := _root_.instT3Space\n\n"}
{"name":"CStarMatrix.instTopologicalAddGroup","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\n⊢ TopologicalAddGroup (CStarMatrix m n A)","decl":"instance instTopologicalAddGroup : TopologicalAddGroup (CStarMatrix m n A) :=\n  Pi.topologicalAddGroup\n\n"}
{"name":"CStarMatrix.instUniformAddGroup","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\n⊢ UniformAddGroup (CStarMatrix m n A)","decl":"instance instUniformAddGroup : UniformAddGroup (CStarMatrix m n A) :=\n  Pi.instUniformAddGroup\n\n"}
{"name":"CStarMatrix.instContinuousSMul","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝³ : NonUnitalCStarAlgebra A\nm : Type u_2\nn : Type u_3\nR : Type u_4\ninst✝² : SMul R A\ninst✝¹ : TopologicalSpace R\ninst✝ : ContinuousSMul R A\n⊢ ContinuousSMul R (CStarMatrix m n A)","decl":"instance instContinuousSMul {R : Type*} [SMul R A] [TopologicalSpace R] [ContinuousSMul R A] :\n    ContinuousSMul R (CStarMatrix m n A) := instContinuousSMulForall\n\n"}
{"name":"CStarMatrix.instCStarRing","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝⁴ : NonUnitalCStarAlgebra A\ninst✝³ : PartialOrder A\ninst✝² : StarOrderedRing A\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ CStarRing (CStarMatrix n n A)","decl":"open ContinuousLinearMap CStarModule in\n/-- Matrices with entries in a C⋆-algebra form a C⋆-algebra. -/\ninstance instCStarRing [DecidableEq n] : CStarRing (CStarMatrix n n A) where\n  norm_mul_self_le M := by\n    have hmain : ‖M‖ ≤ √‖star M * M‖ := by\n      change ‖toCLM M‖ ≤ √‖star M * M‖\n      rw [opNorm_le_iff (by positivity)]\n      intro v\n      rw [norm_eq_sqrt_norm_inner_self, ← inner_toCLM_conjTranspose_right]\n      have h₁ : ‖⟪v, (toCLM Mᴴ) ((toCLM M) v)⟫_A‖ ≤ ‖star M * M‖ * ‖v‖ ^ 2 := calc\n          _ ≤ ‖v‖ * ‖(toCLM Mᴴ) (toCLM M v)‖ := norm_inner_le (C⋆ᵐᵒᵈ (n → A))\n          _ ≤ ‖v‖ * ‖(toCLM Mᴴ).comp (toCLM M)‖ * ‖v‖ := by\n                    rw [mul_assoc]\n                    gcongr\n                    rw [← ContinuousLinearMap.comp_apply]\n                    exact le_opNorm ((toCLM Mᴴ).comp (toCLM M)) v\n          _ = ‖(toCLM Mᴴ).comp (toCLM M)‖ * ‖v‖ ^ 2 := by ring\n          _ = ‖star M * M‖ * ‖v‖ ^ 2 := by\n                    congr\n                    simp only [← toCLMNonUnitalAlgHom_eq_toCLM, Matrix.star_eq_conjTranspose,\n                      map_mul]\n                    rfl\n      have h₂ : ‖v‖ = √(‖v‖ ^ 2) := by simp\n      rw [h₂, ← Real.sqrt_mul]\n      gcongr\n      positivity\n    rw [← pow_two, ← Real.sqrt_le_sqrt_iff (by positivity)]\n    simp [hmain]\n\n"}
{"name":"CStarMatrix.instStarOrderedRing","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"A : Type u_1\ninst✝⁴ : NonUnitalCStarAlgebra A\ninst✝³ : PartialOrder A\ninst✝² : StarOrderedRing A\nn : Type u_3\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ StarOrderedRing (CStarMatrix n n A)","decl":"instance instStarOrderedRing [DecidableEq n] :\n    StarOrderedRing (CStarMatrix n n A) := CStarAlgebra.spectralOrderedRing _\n\n"}
{"name":"CStarMatrix.uniformEmbedding_ofMatrix","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : NonUnitalCStarAlgebra A\n⊢ IsUniformEmbedding ⇑CStarMatrix.ofMatrix","decl":"lemma uniformEmbedding_ofMatrix :\n    IsUniformEmbedding (ofMatrix : Matrix m n A → CStarMatrix m n A) where\n  comap_uniformity := Filter.comap_id'\n  injective := fun ⦃_ _⦄ a ↦ a\n\n"}
{"name":"CStarMatrix.ofMatrix_eq_ofMatrixL","module":"Mathlib.Analysis.CStarAlgebra.CStarMatrix","initialProofState":"m : Type u_1\nn : Type u_2\nA : Type u_3\ninst✝ : NonUnitalCStarAlgebra A\n⊢ Eq ⇑CStarMatrix.ofMatrix ⇑CStarMatrix.ofMatrixL","decl":"lemma ofMatrix_eq_ofMatrixL :\n    (ofMatrix : Matrix m n A → CStarMatrix m n A)\n      = (ofMatrixL : Matrix m n A → CStarMatrix m n A) := rfl\n\n"}
