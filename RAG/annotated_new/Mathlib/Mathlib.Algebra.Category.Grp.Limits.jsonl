{"name":"AddGrp.instSmallElemForallObjCompMonCatForget₂ForgetSections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddGrp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddGrp)).sections\n⊢ Small.{u, max u v} ↑((F.comp (CategoryTheory.forget₂ AddGrp AddMonCat)).comp (CategoryTheory.forget AddMonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ⋙ forget₂ Grp MonCat) ⋙ forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget Grp))\n\n"}
{"name":"Grp.instSmallElemForallObjCompMonCatForget₂ForgetSections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget Grp)).sections\n⊢ Small.{u, max u v} ↑((F.comp (CategoryTheory.forget₂ Grp MonCat)).comp (CategoryTheory.forget MonCat)).sections","decl":"@[to_additive]\ninstance : Small.{u} (Functor.sections ((F ⋙ forget₂ Grp MonCat) ⋙ forget MonCat)) :=\n  inferInstanceAs <| Small.{u} (Functor.sections (F ⋙ forget Grp))\n\n"}
{"name":"Grp.hasLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J Grp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget Grp)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget Grp).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddGrp).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddGrp.hasLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddGrp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddGrp)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget Grp).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddGrp).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddGrp.hasLimit_iff_small_sections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddGrp\n⊢ Iff (CategoryTheory.Limits.HasLimit F) (Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddGrp)).sections)","decl":"/-- A functor `F : J ⥤ Grp.{u}` has a limit iff `(F ⋙ forget Grp).sections` is\n`u`-small. -/\n@[to_additive \"A functor `F : J ⥤ AddGrp.{u}` has a limit iff\n`(F ⋙ forget AddGrp).sections` is `u`-small.\"]\nlemma hasLimit_iff_small_sections :\n    HasLimit F ↔ Small.{u} (F ⋙ forget Grp).sections := by\n  constructor\n  · apply Concrete.small_sections_of_hasLimit\n  · intro\n    infer_instance\n\n"}
{"name":"Grp.hasLimit_iff_small_sections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J Grp\n⊢ Iff (CategoryTheory.Limits.HasLimit F) (Small.{u, max u v} ↑(F.comp (CategoryTheory.forget Grp)).sections)","decl":"/-- A functor `F : J ⥤ Grp.{u}` has a limit iff `(F ⋙ forget Grp).sections` is\n`u`-small. -/\n@[to_additive \"A functor `F : J ⥤ AddGrp.{u}` has a limit iff\n`(F ⋙ forget AddGrp).sections` is `u`-small.\"]\nlemma hasLimit_iff_small_sections :\n    HasLimit F ↔ Small.{u} (F ⋙ forget Grp).sections := by\n  constructor\n  · apply Concrete.small_sections_of_hasLimit\n  · intro\n    infer_instance\n\n"}
{"name":"Grp.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J Grp","decl":"/-- If `J` is `u`-small, `Grp.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddGrp.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J Grp.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"AddGrp.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J AddGrp","decl":"/-- If `J` is `u`-small, `Grp.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddGrp.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J Grp.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"Grp.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} Grp","decl":"/-- The category of groups has all limits. -/\n@[to_additive \"The category of additive groups has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} Grp.{u} where\n  has_limits_of_shape J _ := { }\n\n"}
{"name":"AddGrp.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddGrp","decl":"/-- The category of groups has all limits. -/\n@[to_additive \"The category of additive groups has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} Grp.{u} where\n  has_limits_of_shape J _ := { }\n\n"}
{"name":"AddGrp.hasLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits AddGrp","decl":"@[to_additive]\ninstance hasLimits : HasLimits Grp.{u} :=\n  Grp.hasLimitsOfSize.{u, u}\n\n"}
{"name":"Grp.hasLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits Grp","decl":"@[to_additive]\ninstance hasLimits : HasLimits Grp.{u} :=\n  Grp.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddGrp.forget₂AddMonPreservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ AddGrp AddMonCat)","decl":"/-- The forgetful functor from groups to monoids preserves all limits.\n\nThis means the underlying monoid of a limit can be computed as a limit in the category of monoids.\n-/\n@[to_additive AddGrp.forget₂AddMonPreservesLimitsOfSize\n  \"The forgetful functor from additive groups to additive monoids preserves all limits.\n\n  This means the underlying additive monoid of a limit can be computed as a limit in the category of\n  additive monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget₂Mon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ Grp.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J _} := { }\n\n"}
{"name":"Grp.forget₂Mon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ Grp MonCat)","decl":"/-- The forgetful functor from groups to monoids preserves all limits.\n\nThis means the underlying monoid of a limit can be computed as a limit in the category of monoids.\n-/\n@[to_additive AddGrp.forget₂AddMonPreservesLimitsOfSize\n  \"The forgetful functor from additive groups to additive monoids preserves all limits.\n\n  This means the underlying additive monoid of a limit can be computed as a limit in the category of\n  additive monoids.\",\n  to_additive_relevant_arg 2]\ninstance forget₂Mon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ Grp.{u} MonCat.{u}) where\n  preservesLimitsOfShape {J _} := { }\n\n"}
{"name":"Grp.forget₂Mon_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ Grp MonCat)","decl":"@[to_additive]\ninstance forget₂Mon_preservesLimits :\n  PreservesLimits (forget₂ Grp.{u} MonCat.{u}) :=\n  Grp.forget₂Mon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddGrp.forget₂Mon_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ AddGrp AddMonCat)","decl":"@[to_additive]\ninstance forget₂Mon_preservesLimits :\n  PreservesLimits (forget₂ Grp.{u} MonCat.{u}) :=\n  Grp.forget₂Mon_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddGrp.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddGrp)","decl":"/-- If `J` is `u`-small, the forgetful functor from `Grp.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddGrp.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget Grp.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"Grp.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget Grp)","decl":"/-- If `J` is `u`-small, the forgetful functor from `Grp.{u}` preserves limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddGrp.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget Grp.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"AddGrp.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddGrp)","decl":"/-- The forgetful functor from groups to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive groups to types preserves all limits.\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\ninstance forget_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget Grp.{u}) := inferInstance\n\n"}
{"name":"Grp.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget Grp)","decl":"/-- The forgetful functor from groups to types preserves all limits.\n\nThis means the underlying type of a limit can be computed as a limit in the category of types. -/\n@[to_additive\n  \"The forgetful functor from additive groups to types preserves all limits.\n\n  This means the underlying type of a limit can be computed as a limit in the category of types.\",\n  to_additive_relevant_arg 2]\ninstance forget_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget Grp.{u}) := inferInstance\n\n"}
{"name":"Grp.forget_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget Grp)","decl":"@[to_additive]\ninstance forget_preservesLimits : PreservesLimits (forget Grp.{u}) :=\n  Grp.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddGrp.forget_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddGrp)","decl":"@[to_additive]\ninstance forget_preservesLimits : PreservesLimits (forget Grp.{u}) :=\n  Grp.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommGrp.instReflectsIsomorphismsGrpForget₂","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ (CategoryTheory.forget₂ CommGrp Grp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance : (forget₂ CommGrp.{u} Grp.{u}).ReflectsIsomorphisms :=\n    reflectsIsomorphisms_forget₂ _ _\n\n"}
{"name":"AddCommGrp.instReflectsIsomorphismsAddGrpForget₂","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ (CategoryTheory.forget₂ AddCommGrp AddGrp).ReflectsIsomorphisms","decl":"@[to_additive]\ninstance : (forget₂ CommGrp.{u} Grp.{u}).ReflectsIsomorphisms :=\n    reflectsIsomorphisms_forget₂ _ _\n\n"}
{"name":"CommGrp.hasLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommGrp)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommGrp).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddCommGrp).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddCommGrp.hasLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommGrp\ninst✝ : Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddCommGrp)).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"/-- If `(F ⋙ forget CommGrp).sections` is `u`-small, `F` has a limit. -/\n@[to_additive \"If `(F ⋙ forget AddCommGrp).sections` is `u`-small, `F` has a limit.\"]\ninstance hasLimit : HasLimit F :=\n  HasLimit.mk {\n    cone := limitCone F\n    isLimit := limitConeIsLimit F\n  }\n\n"}
{"name":"AddCommGrp.hasLimit_iff_small_sections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommGrp\n⊢ Iff (CategoryTheory.Limits.HasLimit F) (Small.{u, max u v} ↑(F.comp (CategoryTheory.forget AddCommGrp)).sections)","decl":"/-- A functor `F : J ⥤ CommGrp.{u}` has a limit iff `(F ⋙ forget CommGrp).sections` is\n`u`-small. -/\n@[to_additive \"A functor `F : J ⥤ AddCommGrp.{u}` has a limit iff\n`(F ⋙ forget AddCommGrp).sections` is `u`-small.\"]\nlemma hasLimit_iff_small_sections :\n    HasLimit F ↔ Small.{u} (F ⋙ forget CommGrp).sections := by\n  constructor\n  · apply Concrete.small_sections_of_hasLimit\n  · intro\n    infer_instance\n\n"}
{"name":"CommGrp.hasLimit_iff_small_sections","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\n⊢ Iff (CategoryTheory.Limits.HasLimit F) (Small.{u, max u v} ↑(F.comp (CategoryTheory.forget CommGrp)).sections)","decl":"/-- A functor `F : J ⥤ CommGrp.{u}` has a limit iff `(F ⋙ forget CommGrp).sections` is\n`u`-small. -/\n@[to_additive \"A functor `F : J ⥤ AddCommGrp.{u}` has a limit iff\n`(F ⋙ forget AddCommGrp).sections` is `u`-small.\"]\nlemma hasLimit_iff_small_sections :\n    HasLimit F ↔ Small.{u} (F ⋙ forget CommGrp).sections := by\n  constructor\n  · apply Concrete.small_sections_of_hasLimit\n  · intro\n    infer_instance\n\n"}
{"name":"AddCommGrp.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J AddCommGrp","decl":"/-- If `J` is `u`-small, `CommGrp.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommGrp.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommGrp.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommGrp.hasLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J CommGrp","decl":"/-- If `J` is `u`-small, `CommGrp.{u}` has limits of shape `J`. -/\n@[to_additive \"If `J` is `u`-small, `AddCommGrp.{u}` has limits of shape `J`.\"]\ninstance hasLimitsOfShape [Small.{u} J] : HasLimitsOfShape J CommGrp.{u} where\n  has_limit _ := inferInstance\n\n"}
{"name":"CommGrp.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} CommGrp","decl":"/-- The category of commutative groups has all limits. -/\n@[to_additive \"The category of additive commutative groups has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommGrp.{u}\n  where has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommGrp.hasLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{w, v, u, u + 1} AddCommGrp","decl":"/-- The category of commutative groups has all limits. -/\n@[to_additive \"The category of additive commutative groups has all limits.\",\n  to_additive_relevant_arg 2]\ninstance hasLimitsOfSize [UnivLE.{v, u}] : HasLimitsOfSize.{w, v} CommGrp.{u}\n  where has_limits_of_shape _ _ := { }\n\n"}
{"name":"AddCommGrp.hasLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits AddCommGrp","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommGrp.{u} :=\n  CommGrp.hasLimitsOfSize.{u, u}\n\n"}
{"name":"CommGrp.hasLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.HasLimits CommGrp","decl":"@[to_additive]\ninstance hasLimits : HasLimits CommGrp.{u} :=\n  CommGrp.hasLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommGrp.forget₂AddGroup_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J AddCommGrp\n⊢ CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget₂ AddCommGrp AddGrp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimit :\n    PreservesLimit F (forget₂ CommGrp.{u} Grp.{u}) where\n  preserves {c} hc := ⟨by\n    have : HasLimit (F ⋙ forget₂ CommGrp Grp) := by\n      rw [Grp.hasLimit_iff_small_sections]\n      change Small.{u} (F ⋙ forget CommGrp).sections\n      rw [← CommGrp.hasLimit_iff_small_sections]\n      exact ⟨_, hc⟩\n    exact isLimitOfPreserves _ hc⟩\n\n"}
{"name":"CommGrp.forget₂Group_preservesLimit","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J CommGrp\n⊢ CategoryTheory.Limits.PreservesLimit F (CategoryTheory.forget₂ CommGrp Grp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimit :\n    PreservesLimit F (forget₂ CommGrp.{u} Grp.{u}) where\n  preserves {c} hc := ⟨by\n    have : HasLimit (F ⋙ forget₂ CommGrp Grp) := by\n      rw [Grp.hasLimit_iff_small_sections]\n      change Small.{u} (F ⋙ forget CommGrp).sections\n      rw [← CommGrp.hasLimit_iff_small_sections]\n      exact ⟨_, hc⟩\n    exact isLimitOfPreserves _ hc⟩\n\n"}
{"name":"AddCommGrp.forget₂AddGroup_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget₂ AddCommGrp AddGrp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimitsOfShape :\n    PreservesLimitsOfShape J (forget₂ CommGrp.{u} Grp.{u}) where\n\n"}
{"name":"CommGrp.forget₂Group_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget₂ CommGrp Grp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimitsOfShape :\n    PreservesLimitsOfShape J (forget₂ CommGrp.{u} Grp.{u}) where\n\n"}
{"name":"CommGrp.forget₂Group_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommGrp Grp)","decl":"/-- The forgetful functor from commutative groups to groups preserves all limits.\n(That is, the underlying group could have been computed instead as limits in the category\nof groups.)\n-/\n@[to_additive\n  \"The forgetful functor from additive commutative groups to additive groups preserves all limits.\n  (That is, the underlying group could have been computed instead as limits in the category\n    of additive groups.)\",\n  to_additive_relevant_arg 2]\ninstance forget₂Group_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommGrp.{u} Grp.{u}) where\n\n"}
{"name":"AddCommGrp.forget₂AddGroup_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ AddCommGrp AddGrp)","decl":"/-- The forgetful functor from commutative groups to groups preserves all limits.\n(That is, the underlying group could have been computed instead as limits in the category\nof groups.)\n-/\n@[to_additive\n  \"The forgetful functor from additive commutative groups to additive groups preserves all limits.\n  (That is, the underlying group could have been computed instead as limits in the category\n    of additive groups.)\",\n  to_additive_relevant_arg 2]\ninstance forget₂Group_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommGrp.{u} Grp.{u}) where\n\n"}
{"name":"AddCommGrp.forget₂AddGroup_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ AddCommGrp AddGrp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimits :\n    PreservesLimits (forget₂ CommGrp Grp.{u}) :=\n  CommGrp.forget₂Group_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommGrp.forget₂Group_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ CommGrp Grp)","decl":"@[to_additive]\ninstance forget₂Group_preservesLimits :\n    PreservesLimits (forget₂ CommGrp Grp.{u}) :=\n  CommGrp.forget₂Group_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommGrp.forget₂CommMon_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget₂ CommGrp CommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommGrp.{u}` to `CommMonCat.{u}`\npreserves limits of shape `J`. -/\n@[to_additive AddCommGrp.forget₂AddCommMon_preservesLimitsOfShape\n  \"If `J` is `u`-small, the forgetful functor from `AddCommGrp.{u}`\n  to `AddCommMonCat.{u}` preserves limits of shape `J`.\"]\ninstance forget₂CommMon_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget₂ CommGrp.{u} CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n      (forget₂CommMon_preservesLimitsAux.{v, u} F)\n\n"}
{"name":"AddCommGrp.forget₂AddCommMon_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget₂ AddCommGrp AddCommMonCat)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommGrp.{u}` to `CommMonCat.{u}`\npreserves limits of shape `J`. -/\n@[to_additive AddCommGrp.forget₂AddCommMon_preservesLimitsOfShape\n  \"If `J` is `u`-small, the forgetful functor from `AddCommGrp.{u}`\n  to `AddCommMonCat.{u}` preserves limits of shape `J`.\"]\ninstance forget₂CommMon_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget₂ CommGrp.{u} CommMonCat.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit.{v, u} F)\n      (forget₂CommMon_preservesLimitsAux.{v, u} F)\n\n"}
{"name":"AddCommGrp.forget₂AddCommMon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ AddCommGrp AddCommMonCat)","decl":"/-- The forgetful functor from commutative groups to commutative monoids preserves all limits.\n(That is, the underlying commutative monoids could have been computed instead as limits\nin the category of commutative monoids.)\n-/\n@[to_additive AddCommGrp.forget₂AddCommMon_preservesLimitsOfSize\n  \"The forgetful functor from additive commutative groups to additive commutative monoids\n  preserves all limits. (That is, the underlying additive commutative monoids could have been\n  computed instead as limits in the category of additive commutative monoids.)\"]\ninstance forget₂CommMon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommGrp CommMonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"CommGrp.forget₂CommMon_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"inst✝ : UnivLE.{v, u}\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget₂ CommGrp CommMonCat)","decl":"/-- The forgetful functor from commutative groups to commutative monoids preserves all limits.\n(That is, the underlying commutative monoids could have been computed instead as limits\nin the category of commutative monoids.)\n-/\n@[to_additive AddCommGrp.forget₂AddCommMon_preservesLimitsOfSize\n  \"The forgetful functor from additive commutative groups to additive commutative monoids\n  preserves all limits. (That is, the underlying additive commutative monoids could have been\n  computed instead as limits in the category of additive commutative monoids.)\"]\ninstance forget₂CommMon_preservesLimitsOfSize [UnivLE.{v, u}] :\n    PreservesLimitsOfSize.{w, v} (forget₂ CommGrp CommMonCat.{u}) where\n  preservesLimitsOfShape := { }\n\n"}
{"name":"CommGrp.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget CommGrp)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommGrp.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommGrp.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommGrp.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"AddCommGrp.forget_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.Category.{w, v} J\ninst✝ : Small.{u, v} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (CategoryTheory.forget AddCommGrp)","decl":"/-- If `J` is `u`-small, the forgetful functor from `CommGrp.{u}` preserves limits of\nshape `J`. -/\n@[to_additive \"If `J` is `u`-small, the forgetful functor from `AddCommGrp.{u}`\\n\npreserves limits of shape `J`.\"]\ninstance forget_preservesLimitsOfShape [Small.{u} J] :\n    PreservesLimitsOfShape J (forget CommGrp.{u}) where\n  preservesLimit {F} := preservesLimit_of_preserves_limit_cone (limitConeIsLimit F)\n    (Types.Small.limitConeIsLimit (F ⋙ forget _))\n\n"}
{"name":"CommGrp.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget CommGrp)","decl":"/-- The forgetful functor from commutative groups to types preserves all limits. (That is, the\nunderlying types could have been computed instead as limits in the category of types.)\n-/\n@[to_additive\n  \"The forgetful functor from additive commutative groups to types preserves all limits.\n  (That is, the underlying types could have been computed instead as limits in the category of\n  types.)\"]\ninstance forget_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget CommGrp.{u}) := inferInstance\n\n"}
{"name":"AddCommGrp.forget_preservesLimitsOfSize","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, v, u, u, u + 1, u + 1} (CategoryTheory.forget AddCommGrp)","decl":"/-- The forgetful functor from commutative groups to types preserves all limits. (That is, the\nunderlying types could have been computed instead as limits in the category of types.)\n-/\n@[to_additive\n  \"The forgetful functor from additive commutative groups to types preserves all limits.\n  (That is, the underlying types could have been computed instead as limits in the category of\n  types.)\"]\ninstance forget_preservesLimitsOfSize :\n    PreservesLimitsOfSize.{w, v} (forget CommGrp.{u}) := inferInstance\n\n"}
{"name":"AddCommGrp.forget_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget AddCommGrp)","decl":"noncomputable instance _root_.AddCommGrp.forget_preservesLimits :\n    PreservesLimits (forget AddCommGrp.{u}) :=\n  AddCommGrp.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"CommGrp.forget_preservesLimits","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget CommGrp)","decl":"@[to_additive existing]\nnoncomputable instance forget_preservesLimits : PreservesLimits (forget CommGrp.{u}) :=\n  CommGrp.forget_preservesLimitsOfSize.{u, u}\n\n"}
{"name":"AddCommGrp.kernelIsoKer_hom_comp_subtype","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"G H : AddCommGrp\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AddCommGrp.kernelIsoKer f).hom (AddCommGrp.ofHom (AddCommGrp.Hom.hom f).ker.subtype)) (CategoryTheory.Limits.kernel.ι f)","decl":"@[simp]\ntheorem kernelIsoKer_hom_comp_subtype {G H : AddCommGrp.{u}} (f : G ⟶ H) :\n    (kernelIsoKer f).hom ≫ ofHom (AddSubgroup.subtype f.hom.ker) = kernel.ι f := by ext; rfl\n\n"}
{"name":"AddCommGrp.kernelIsoKer_inv_comp_ι","module":"Mathlib.Algebra.Category.Grp.Limits","initialProofState":"G H : AddCommGrp\nf : Quiver.Hom G H\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AddCommGrp.kernelIsoKer f).inv (CategoryTheory.Limits.kernel.ι f)) (AddCommGrp.ofHom (AddCommGrp.Hom.hom f).ker.subtype)","decl":"@[simp]\ntheorem kernelIsoKer_inv_comp_ι {G H : AddCommGrp.{u}} (f : G ⟶ H) :\n    (kernelIsoKer f).inv ≫ kernel.ι f = ofHom (AddSubgroup.subtype f.hom.ker) := by\n  ext\n  simp [kernelIsoKer]\n\n"}
