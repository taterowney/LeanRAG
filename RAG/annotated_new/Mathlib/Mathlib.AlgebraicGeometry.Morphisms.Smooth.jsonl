{"name":"AlgebraicGeometry.isSmooth_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsSmooth f) (∀ (x : ↑↑X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)).IsStandardSmooth)","decl":"/--\nA morphism of schemes `f : X ⟶ Y` is smooth if for each `x : X` there\nexists an affine open neighborhood `V` of `x` and an affine open neighborhood `U` of\n`f.base x` with `V ≤ f ⁻¹ᵁ U` such that the induced map `Γ(Y, U) ⟶ Γ(X, V)` is\nstandard smooth.\n-/\n@[mk_iff]\nclass IsSmooth : Prop where\n  exists_isStandardSmooth : ∀ (x : X), ∃ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ∈ V.1)\n    (e : V.1 ≤ f ⁻¹ᵁ U.1), IsStandardSmooth.{0, 0} (f.appLE U V e).hom\n\n"}
{"name":"AlgebraicGeometry.IsSmooth.exists_isStandardSmooth","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsSmooth f\nx : ↑↑X.toPresheafedSpace\n⊢ Exists fun U => Exists fun V => Exists fun x => Exists fun e => (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)).IsStandardSmooth","decl":"/--\nA morphism of schemes `f : X ⟶ Y` is smooth if for each `x : X` there\nexists an affine open neighborhood `V` of `x` and an affine open neighborhood `U` of\n`f.base x` with `V ≤ f ⁻¹ᵁ U` such that the induced map `Γ(Y, U) ⟶ Γ(X, V)` is\nstandard smooth.\n-/\n@[mk_iff]\nclass IsSmooth : Prop where\n  exists_isStandardSmooth : ∀ (x : X), ∃ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ∈ V.1)\n    (e : V.1 ≤ f ⁻¹ᵁ U.1), IsStandardSmooth.{0, 0} (f.appLE U V e).hom\n\n"}
{"name":"AlgebraicGeometry.instHasRingHomPropertyIsSmoothLocallyIsStandardSmooth","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"⊢ AlgebraicGeometry.HasRingHomProperty @AlgebraicGeometry.IsSmooth fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmooth","decl":"/-- The property of scheme morphisms `IsSmooth` is associated with the ring\nhomomorphism property `Locally IsStandardSmooth.{0, 0}`. -/\ninstance : HasRingHomProperty @IsSmooth (Locally IsStandardSmooth.{0, 0}) := by\n  apply HasRingHomProperty.locally_of_iff\n  · exact isStandardSmooth_localizationPreserves.away\n  · exact isStandardSmooth_stableUnderCompositionWithLocalizationAway\n  · intro X Y f\n    rw [isSmooth_iff]\n\n"}
{"name":"AlgebraicGeometry.instIsStableUnderCompositionSchemeIsSmooth","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderComposition @AlgebraicGeometry.IsSmooth","decl":"/-- Being smooth is stable under composition. -/\ninstance : MorphismProperty.IsStableUnderComposition @IsSmooth :=\n  HasRingHomProperty.stableUnderComposition <| locally_stableUnderComposition\n    isStandardSmooth_respectsIso isStandardSmooth_localizationPreserves\n      isStandardSmooth_stableUnderComposition\n\n"}
{"name":"AlgebraicGeometry.isSmooth_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsSmooth f\ninst✝ : AlgebraicGeometry.IsSmooth g\n⊢ AlgebraicGeometry.IsSmooth (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- The composition of smooth morphisms is smooth. -/\ninstance isSmooth_comp {Z : Scheme.{u}} (g : Y ⟶ Z) [IsSmooth f] [IsSmooth g] :\n    IsSmooth (f ≫ g) :=\n  MorphismProperty.comp_mem _ f g ‹IsSmooth f› ‹IsSmooth g›\n\n"}
{"name":"AlgebraicGeometry.isSmooth_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange @AlgebraicGeometry.IsSmooth","decl":"/-- Smooth of relative dimension `n` is stable under base change. -/\nlemma isSmooth_isStableUnderBaseChange : MorphismProperty.IsStableUnderBaseChange @IsSmooth :=\n  HasRingHomProperty.isStableUnderBaseChange <| locally_isStableUnderBaseChange\n    isStandardSmooth_respectsIso isStandardSmooth_isStableUnderBaseChange\n\n"}
{"name":"AlgebraicGeometry.IsSmoothOfRelativeDimension.exists_isStandardSmoothOfRelativeDimension","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n : Nat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nself : AlgebraicGeometry.IsSmoothOfRelativeDimension n f\nx : ↑↑X.toPresheafedSpace\n⊢ Exists fun U => Exists fun V => Exists fun x => Exists fun e => RingHom.IsStandardSmoothOfRelativeDimension n (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e))","decl":"/--\nA morphism of schemes `f : X ⟶ Y` is smooth of relative dimension `n` if for each `x : X` there\nexists an affine open neighborhood `V` of `x` and an affine open neighborhood `U` of\n`f.base x` with `V ≤ f ⁻¹ᵁ U` such that the induced map `Γ(Y, U) ⟶ Γ(X, V)` is\nstandard smooth of relative dimension `n`.\n-/\n@[mk_iff]\nclass IsSmoothOfRelativeDimension : Prop where\n  exists_isStandardSmoothOfRelativeDimension : ∀ (x : X), ∃ (U : Y.affineOpens)\n    (V : X.affineOpens) (_ : x ∈ V.1) (e : V.1 ≤ f ⁻¹ᵁ U.1),\n    IsStandardSmoothOfRelativeDimension.{0, 0} n (f.appLE U V e).hom\n\n"}
{"name":"AlgebraicGeometry.isSmoothOfRelativeDimension_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n : Nat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsSmoothOfRelativeDimension n f) (∀ (x : ↑↑X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => RingHom.IsStandardSmoothOfRelativeDimension n (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))","decl":"/--\nA morphism of schemes `f : X ⟶ Y` is smooth of relative dimension `n` if for each `x : X` there\nexists an affine open neighborhood `V` of `x` and an affine open neighborhood `U` of\n`f.base x` with `V ≤ f ⁻¹ᵁ U` such that the induced map `Γ(Y, U) ⟶ Γ(X, V)` is\nstandard smooth of relative dimension `n`.\n-/\n@[mk_iff]\nclass IsSmoothOfRelativeDimension : Prop where\n  exists_isStandardSmoothOfRelativeDimension : ∀ (x : X), ∃ (U : Y.affineOpens)\n    (V : X.affineOpens) (_ : x ∈ V.1) (e : V.1 ≤ f ⁻¹ᵁ U.1),\n    IsStandardSmoothOfRelativeDimension.{0, 0} n (f.appLE U V e).hom\n\n"}
{"name":"AlgebraicGeometry.IsSmoothOfRelativeDimension.isSmooth","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n : Nat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsSmoothOfRelativeDimension n f\n⊢ AlgebraicGeometry.IsSmooth f","decl":"/-- If `f` is smooth of any relative dimension, it is smooth. -/\nlemma IsSmoothOfRelativeDimension.isSmooth [IsSmoothOfRelativeDimension n f] : IsSmooth f where\n  exists_isStandardSmooth x := by\n    obtain ⟨U, V, hx, e, hf⟩ := exists_isStandardSmoothOfRelativeDimension (n := n) (f := f) x\n    exact ⟨U, V, hx, e, hf.isStandardSmooth⟩\n\n"}
{"name":"AlgebraicGeometry.instHasRingHomPropertyIsSmoothOfRelativeDimensionLocallyIsStandardSmoothOfRelativeDimension","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n : Nat\n⊢ AlgebraicGeometry.HasRingHomProperty (@AlgebraicGeometry.IsSmoothOfRelativeDimension n) fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => RingHom.IsStandardSmoothOfRelativeDimension n","decl":"/-- The property of scheme morphisms `IsSmoothOfRelativeDimension n` is associated with the ring\nhomomorphism property `Locally (IsStandardSmoothOfRelativeDimension.{0, 0} n)`. -/\ninstance : HasRingHomProperty (@IsSmoothOfRelativeDimension n)\n    (Locally (IsStandardSmoothOfRelativeDimension.{0, 0} n)) := by\n  apply HasRingHomProperty.locally_of_iff\n  · exact (isStandardSmoothOfRelativeDimension_localizationPreserves n).away\n  · exact isStandardSmoothOfRelativeDimension_stableUnderCompositionWithLocalizationAway n\n  · intro X Y f\n    rw [isSmoothOfRelativeDimension_iff]\n\n"}
{"name":"AlgebraicGeometry.isSmoothOfRelativeDimension_isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n : Nat\n⊢ CategoryTheory.MorphismProperty.IsStableUnderBaseChange (@AlgebraicGeometry.IsSmoothOfRelativeDimension n)","decl":"/-- Smooth of relative dimension `n` is stable under base change. -/\nlemma isSmoothOfRelativeDimension_isStableUnderBaseChange :\n    MorphismProperty.IsStableUnderBaseChange (@IsSmoothOfRelativeDimension n) :=\n  HasRingHomProperty.isStableUnderBaseChange <| locally_isStableUnderBaseChange\n    isStandardSmoothOfRelativeDimension_respectsIso\n    (isStandardSmoothOfRelativeDimension_isStableUnderBaseChange n)\n\n"}
{"name":"AlgebraicGeometry.instIsSmoothOfRelativeDimensionOfNatNatOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsSmoothOfRelativeDimension 0 f","decl":"/-- Open immersions are smooth of relative dimension `0`. -/\ninstance (priority := 900) [IsOpenImmersion f] : IsSmoothOfRelativeDimension 0 f :=\n  HasRingHomProperty.of_isOpenImmersion\n    (locally_holdsForLocalizationAway <|\n      isStandardSmoothOfRelativeDimension_holdsForLocalizationAway).containsIdentities\n\n"}
{"name":"AlgebraicGeometry.instIsSmoothOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsSmooth f","decl":"/-- Open immersions are smooth. -/\ninstance (priority := 900) [IsOpenImmersion f] : IsSmooth f :=\n  IsSmoothOfRelativeDimension.isSmooth 0 f\n\n"}
{"name":"AlgebraicGeometry.isSmoothOfRelativeDimension_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"n m : Nat\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z\nhf : AlgebraicGeometry.IsSmoothOfRelativeDimension n f\nhg : AlgebraicGeometry.IsSmoothOfRelativeDimension m g\n⊢ AlgebraicGeometry.IsSmoothOfRelativeDimension (HAdd.hAdd n m) (CategoryTheory.CategoryStruct.comp f g)","decl":"/-- If `f` is smooth of relative dimension `n` and `g` is smooth of relative dimension\n`m`, then `f ≫ g` is smooth of relative dimension `n + m`. -/\ninstance isSmoothOfRelativeDimension_comp {Z : Scheme.{u}} (g : Y ⟶ Z)\n    [hf : IsSmoothOfRelativeDimension n f] [hg : IsSmoothOfRelativeDimension m g] :\n    IsSmoothOfRelativeDimension (n + m) (f ≫ g) where\n  exists_isStandardSmoothOfRelativeDimension x := by\n    obtain ⟨U₂, V₂, hfx₂, e₂, hf₂⟩ := hg.exists_isStandardSmoothOfRelativeDimension (f.base x)\n    obtain ⟨U₁', V₁', hx₁', e₁', hf₁'⟩ := hf.exists_isStandardSmoothOfRelativeDimension x\n    obtain ⟨r, s, hx₁, e₁, hf₁⟩ := exists_basicOpen_le_appLE_of_appLE_of_isAffine\n      (isStandardSmoothOfRelativeDimension_stableUnderCompositionWithLocalizationAway n).right\n      (isStandardSmoothOfRelativeDimension_localizationPreserves n).away\n      x V₂ U₁' V₁' V₁' hx₁' hx₁' e₁' hf₁' hfx₂\n    have e : X.basicOpen s ≤ (f ≫ g) ⁻¹ᵁ U₂ :=\n      le_trans e₁ <| f.preimage_le_preimage_of_le <| le_trans (Y.basicOpen_le r) e₂\n    have heq : (f ≫ g).appLE U₂ (X.basicOpen s) e = g.appLE U₂ V₂ e₂ ≫\n        CommRingCat.ofHom (algebraMap Γ(Y, V₂) Γ(Y, Y.basicOpen r)) ≫\n          f.appLE (Y.basicOpen r) (X.basicOpen s) e₁ := by\n      rw [RingHom.algebraMap_toAlgebra, CommRingCat.ofHom_hom,\n        g.appLE_map_assoc, Scheme.appLE_comp_appLE]\n    refine ⟨U₂, ⟨X.basicOpen s, V₁'.2.basicOpen s⟩, hx₁, e, heq ▸ ?_⟩\n    apply IsStandardSmoothOfRelativeDimension.comp ?_ hf₂\n    haveI : IsLocalization.Away r Γ(Y, Y.basicOpen r) := V₂.2.isLocalization_basicOpen r\n    exact (isStandardSmoothOfRelativeDimension_stableUnderCompositionWithLocalizationAway n).left\n      _ r _ hf₁\n\n"}
{"name":"AlgebraicGeometry.instIsSmoothOfRelativeDimensionOfNatNatCompScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nZ : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z\ninst✝¹ : AlgebraicGeometry.IsSmoothOfRelativeDimension 0 f\ninst✝ : AlgebraicGeometry.IsSmoothOfRelativeDimension 0 g\n⊢ AlgebraicGeometry.IsSmoothOfRelativeDimension 0 (CategoryTheory.CategoryStruct.comp f g)","decl":"instance {Z : Scheme.{u}} (g : Y ⟶ Z) [IsSmoothOfRelativeDimension 0 f]\n    [IsSmoothOfRelativeDimension 0 g] :\n    IsSmoothOfRelativeDimension 0 (f ≫ g) :=\n  inferInstanceAs <| IsSmoothOfRelativeDimension (0 + 0) (f ≫ g)\n\n"}
{"name":"AlgebraicGeometry.instIsMultiplicativeSchemeIsSmoothOfRelativeDimensionOfNatNat","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"⊢ CategoryTheory.MorphismProperty.IsMultiplicative (@AlgebraicGeometry.IsSmoothOfRelativeDimension 0)","decl":"/-- Smooth of relative dimension `0` is multiplicative. -/\ninstance : MorphismProperty.IsMultiplicative (@IsSmoothOfRelativeDimension 0) where\n  id_mem _ := inferInstance\n  comp_mem _ _ _ _ := inferInstance\n\n"}
{"name":"AlgebraicGeometry.instLocallyOfFinitePresentationOfIsSmooth","module":"Mathlib.AlgebraicGeometry.Morphisms.Smooth","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : AlgebraicGeometry.IsSmooth f\n⊢ AlgebraicGeometry.LocallyOfFinitePresentation f","decl":"/-- Smooth morphisms are locally of finite presentation. -/\ninstance (priority := 100) [hf : IsSmooth f] : LocallyOfFinitePresentation f := by\n  rw [HasRingHomProperty.eq_affineLocally @LocallyOfFinitePresentation]\n  rw [HasRingHomProperty.eq_affineLocally @IsSmooth] at hf\n  refine affineLocally_le (fun hf ↦ ?_) f hf\n  apply RingHom.locally_of_locally (Q := RingHom.FinitePresentation) at hf\n  · rwa [RingHom.locally_iff_of_localizationSpanTarget finitePresentation_respectsIso\n      finitePresentation_ofLocalizationSpanTarget] at hf\n  · introv hf\n    algebraize [f]\n    -- TODO: why is `algebraize` not generating the following instance?\n    haveI : Algebra.IsStandardSmooth R S := hf\n    exact this.finitePresentation\n\n"}
