{"name":"Nat.nth_of_card_le","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nn : Nat\nhn : LE.le hf.toFinset.card n\n⊢ Eq (Nat.nth p n) 0","decl":"theorem nth_of_card_le (hf : (setOf p).Finite) {n : ℕ} (hn : #hf.toFinset ≤ n) :\n    nth p n = 0 := by rw [nth, dif_pos hf, List.getD_eq_default]; rwa [Finset.length_sort]\n\n"}
{"name":"Nat.nth_eq_getD_sort","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nh : (setOf p).Finite\nn : Nat\n⊢ Eq (Nat.nth p n) ((Finset.sort (fun x1 x2 => LE.le x1 x2) h.toFinset).getD n 0)","decl":"theorem nth_eq_getD_sort (h : (setOf p).Finite) (n : ℕ) :\n    nth p n = (h.toFinset.sort (· ≤ ·)).getD n 0 :=\n  dif_pos h\n\n"}
{"name":"Nat.nth_eq_orderEmbOfFin","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nn : Nat\nhn : LT.lt n hf.toFinset.card\n⊢ Eq (Nat.nth p n) ((hf.toFinset.orderEmbOfFin ⋯) ⟨n, hn⟩)","decl":"theorem nth_eq_orderEmbOfFin (hf : (setOf p).Finite) {n : ℕ} (hn : n < #hf.toFinset) :\n    nth p n = hf.toFinset.orderEmbOfFin rfl ⟨n, hn⟩ := by\n  rw [nth_eq_getD_sort hf, Finset.orderEmbOfFin_apply, List.getD_eq_getElem, Fin.getElem_fin]\n\n"}
{"name":"Nat.nth_strictMonoOn","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\n⊢ StrictMonoOn (Nat.nth p) (Set.Iio hf.toFinset.card)","decl":"theorem nth_strictMonoOn (hf : (setOf p).Finite) :\n    StrictMonoOn (nth p) (Set.Iio #hf.toFinset) := by\n  rintro m (hm : m < _) n (hn : n < _) h\n  simp only [nth_eq_orderEmbOfFin, *]\n  exact OrderEmbedding.strictMono _ h\n\n"}
{"name":"Nat.nth_lt_nth_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nm n : Nat\nh : LT.lt m n\nhn : LT.lt n hf.toFinset.card\n⊢ LT.lt (Nat.nth p m) (Nat.nth p n)","decl":"theorem nth_lt_nth_of_lt_card (hf : (setOf p).Finite) {m n : ℕ} (h : m < n)\n    (hn : n < #hf.toFinset) : nth p m < nth p n :=\n  nth_strictMonoOn hf (h.trans hn) hn h\n\n"}
{"name":"Nat.nth_le_nth_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nm n : Nat\nh : LE.le m n\nhn : LT.lt n hf.toFinset.card\n⊢ LE.le (Nat.nth p m) (Nat.nth p n)","decl":"theorem nth_le_nth_of_lt_card (hf : (setOf p).Finite) {m n : ℕ} (h : m ≤ n)\n    (hn : n < #hf.toFinset) : nth p m ≤ nth p n :=\n  (nth_strictMonoOn hf).monotoneOn (h.trans_lt hn) hn h\n\n"}
{"name":"Nat.lt_of_nth_lt_nth_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nm n : Nat\nh : LT.lt (Nat.nth p m) (Nat.nth p n)\nhm : LT.lt m hf.toFinset.card\n⊢ LT.lt m n","decl":"theorem lt_of_nth_lt_nth_of_lt_card (hf : (setOf p).Finite) {m n : ℕ} (h : nth p m < nth p n)\n    (hm : m < #hf.toFinset) : m < n :=\n  not_le.1 fun hle => h.not_le <| nth_le_nth_of_lt_card hf hle hm\n\n"}
{"name":"Nat.le_of_nth_le_nth_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nm n : Nat\nh : LE.le (Nat.nth p m) (Nat.nth p n)\nhm : LT.lt m hf.toFinset.card\n⊢ LE.le m n","decl":"theorem le_of_nth_le_nth_of_lt_card (hf : (setOf p).Finite) {m n : ℕ} (h : nth p m ≤ nth p n)\n    (hm : m < #hf.toFinset) : m ≤ n :=\n  not_lt.1 fun hlt => h.not_lt <| nth_lt_nth_of_lt_card hf hlt hm\n\n"}
{"name":"Nat.nth_injOn","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\n⊢ Set.InjOn (Nat.nth p) (Set.Iio hf.toFinset.card)","decl":"theorem nth_injOn (hf : (setOf p).Finite) : (Set.Iio #hf.toFinset).InjOn (nth p) :=\n  (nth_strictMonoOn hf).injOn\n\n"}
{"name":"Nat.range_nth_of_finite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\n⊢ Eq (Set.range (Nat.nth p)) (Insert.insert 0 (setOf p))","decl":"theorem range_nth_of_finite (hf : (setOf p).Finite) : Set.range (nth p) = insert 0 (setOf p) := by\n  simpa only [← List.getD_eq_getElem?_getD, ← nth_eq_getD_sort hf, mem_sort,\n    Set.Finite.mem_toFinset] using Set.range_list_getD (hf.toFinset.sort (· ≤ ·)) 0\n\n"}
{"name":"Nat.image_nth_Iio_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\n⊢ Eq (Set.image (Nat.nth p) (Set.Iio hf.toFinset.card)) (setOf p)","decl":"@[simp]\ntheorem image_nth_Iio_card (hf : (setOf p).Finite) : nth p '' Set.Iio #hf.toFinset = setOf p :=\n  calc\n    nth p '' Set.Iio #hf.toFinset = Set.range (hf.toFinset.orderEmbOfFin rfl) := by\n      ext x\n      simp only [Set.mem_image, Set.mem_range, Fin.exists_iff, ← nth_eq_orderEmbOfFin hf,\n        Set.mem_Iio, exists_prop]\n    _ = setOf p := by rw [range_orderEmbOfFin, Set.Finite.coe_toFinset]\n\n"}
{"name":"Nat.nth_mem_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nhf : (setOf p).Finite\nhlt : LT.lt n hf.toFinset.card\n⊢ p (Nat.nth p n)","decl":"theorem nth_mem_of_lt_card {n : ℕ} (hf : (setOf p).Finite) (hlt : n < #hf.toFinset) :\n    p (nth p n) :=\n  (image_nth_Iio_card hf).subset <| Set.mem_image_of_mem _ hlt\n\n"}
{"name":"Nat.exists_lt_card_finite_nth_eq","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Finite\nx : Nat\nh : p x\n⊢ Exists fun n => And (LT.lt n hf.toFinset.card) (Eq (Nat.nth p n) x)","decl":"theorem exists_lt_card_finite_nth_eq (hf : (setOf p).Finite) {x} (h : p x) :\n    ∃ n, n < #hf.toFinset ∧ nth p n = x := by\n  rwa [← @Set.mem_setOf_eq _ _ p, ← image_nth_Iio_card hf] at h\n\n"}
{"name":"Nat.nth_apply_eq_orderIsoOfNat","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\nn : Nat\n⊢ Eq (Nat.nth p n) ↑((Nat.Subtype.orderIsoOfNat (setOf p)) n)","decl":"/-- When `s` is an infinite set, `nth` agrees with `Nat.Subtype.orderIsoOfNat`. -/\ntheorem nth_apply_eq_orderIsoOfNat (hf : (setOf p).Infinite) (n : ℕ) :\n    nth p n = @Nat.Subtype.orderIsoOfNat (setOf p) hf.to_subtype n := by rw [nth, dif_neg hf]\n\n"}
{"name":"Nat.nth_eq_orderIsoOfNat","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\n⊢ Eq (Nat.nth p) (Function.comp Subtype.val ⇑(Nat.Subtype.orderIsoOfNat (setOf p)))","decl":"/-- When `s` is an infinite set, `nth` agrees with `Nat.Subtype.orderIsoOfNat`. -/\ntheorem nth_eq_orderIsoOfNat (hf : (setOf p).Infinite) :\n    nth p = (↑) ∘ @Nat.Subtype.orderIsoOfNat (setOf p) hf.to_subtype :=\n  funext <| nth_apply_eq_orderIsoOfNat hf\n\n"}
{"name":"Nat.nth_strictMono","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\n⊢ StrictMono (Nat.nth p)","decl":"theorem nth_strictMono (hf : (setOf p).Infinite) : StrictMono (nth p) := by\n  rw [nth_eq_orderIsoOfNat hf]\n  exact (Subtype.strictMono_coe _).comp (OrderIso.strictMono _)\n\n"}
{"name":"Nat.nth_injective","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\n⊢ Function.Injective (Nat.nth p)","decl":"theorem nth_injective (hf : (setOf p).Infinite) : Function.Injective (nth p) :=\n  (nth_strictMono hf).injective\n\n"}
{"name":"Nat.nth_monotone","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\n⊢ Monotone (Nat.nth p)","decl":"theorem nth_monotone (hf : (setOf p).Infinite) : Monotone (nth p) :=\n  (nth_strictMono hf).monotone\n\n"}
{"name":"Nat.nth_lt_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\nk n : Nat\n⊢ Iff (LT.lt (Nat.nth p k) (Nat.nth p n)) (LT.lt k n)","decl":"theorem nth_lt_nth (hf : (setOf p).Infinite) {k n} : nth p k < nth p n ↔ k < n :=\n  (nth_strictMono hf).lt_iff_lt\n\n"}
{"name":"Nat.nth_le_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\nk n : Nat\n⊢ Iff (LE.le (Nat.nth p k) (Nat.nth p n)) (LE.le k n)","decl":"theorem nth_le_nth (hf : (setOf p).Infinite) {k n} : nth p k ≤ nth p n ↔ k ≤ n :=\n  (nth_strictMono hf).le_iff_le\n\n"}
{"name":"Nat.range_nth_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\n⊢ Eq (Set.range (Nat.nth p)) (setOf p)","decl":"theorem range_nth_of_infinite (hf : (setOf p).Infinite) : Set.range (nth p) = setOf p := by\n  rw [nth_eq_orderIsoOfNat hf]\n  haveI := hf.to_subtype\n  -- Porting note: added `classical`; probably, Lean 3 found instance by unification\n  classical exact Nat.Subtype.coe_comp_ofNat_range\n\n"}
{"name":"Nat.nth_mem_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\nn : Nat\n⊢ p (Nat.nth p n)","decl":"theorem nth_mem_of_infinite (hf : (setOf p).Infinite) (n : ℕ) : p (nth p n) :=\n  Set.range_subset_iff.1 (range_nth_of_infinite hf).le n\n\n"}
{"name":"Nat.exists_lt_card_nth_eq","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nx : Nat\nh : p x\n⊢ Exists fun n => And (∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card) (Eq (Nat.nth p n) x)","decl":"theorem exists_lt_card_nth_eq {x} (h : p x) :\n    ∃ n, (∀ hf : (setOf p).Finite, n < #hf.toFinset) ∧ nth p n = x := by\n  refine (setOf p).finite_or_infinite.elim (fun hf => ?_) fun hf => ?_\n  · rcases exists_lt_card_finite_nth_eq hf h with ⟨n, hn, hx⟩\n    exact ⟨n, fun _ => hn, hx⟩\n  · rw [← @Set.mem_setOf_eq _ _ p, ← range_nth_of_infinite hf] at h\n    rcases h with ⟨n, hx⟩\n    exact ⟨n, fun hf' => absurd hf' hf, hx⟩\n\n"}
{"name":"Nat.subset_range_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\n⊢ HasSubset.Subset (setOf p) (Set.range (Nat.nth p))","decl":"theorem subset_range_nth : setOf p ⊆ Set.range (nth p) := fun x (hx : p x) =>\n  let ⟨n, _, hn⟩ := exists_lt_card_nth_eq hx\n  ⟨n, hn⟩\n\n"}
{"name":"Nat.range_nth_subset","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\n⊢ HasSubset.Subset (Set.range (Nat.nth p)) (Insert.insert 0 (setOf p))","decl":"theorem range_nth_subset : Set.range (nth p) ⊆ insert 0 (setOf p) :=\n  (setOf p).finite_or_infinite.elim (fun h => (range_nth_of_finite h).subset) fun h =>\n    (range_nth_of_infinite h).trans_subset (Set.subset_insert _ _)\n\n"}
{"name":"Nat.nth_mem","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ p (Nat.nth p n)","decl":"theorem nth_mem (n : ℕ) (h : ∀ hf : (setOf p).Finite, n < #hf.toFinset) : p (nth p n) :=\n  (setOf p).finite_or_infinite.elim (fun hf => nth_mem_of_lt_card hf (h hf)) fun h =>\n    nth_mem_of_infinite h n\n\n"}
{"name":"Nat.nth_lt_nth'","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nm n : Nat\nhlt : LT.lt m n\nh : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ LT.lt (Nat.nth p m) (Nat.nth p n)","decl":"theorem nth_lt_nth' {m n : ℕ} (hlt : m < n) (h : ∀ hf : (setOf p).Finite, n < #hf.toFinset) :\n    nth p m < nth p n :=\n  (setOf p).finite_or_infinite.elim (fun hf => nth_lt_nth_of_lt_card hf hlt (h _)) fun hf =>\n    (nth_lt_nth hf).2 hlt\n\n"}
{"name":"Nat.nth_le_nth'","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nm n : Nat\nhle : LE.le m n\nh : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ LE.le (Nat.nth p m) (Nat.nth p n)","decl":"theorem nth_le_nth' {m n : ℕ} (hle : m ≤ n) (h : ∀ hf : (setOf p).Finite, n < #hf.toFinset) :\n    nth p m ≤ nth p n :=\n  (setOf p).finite_or_infinite.elim (fun hf => nth_le_nth_of_lt_card hf hle (h _)) fun hf =>\n    (nth_le_nth hf).2 hle\n\n"}
{"name":"Nat.le_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ LE.le n (Nat.nth p n)","decl":"theorem le_nth {n : ℕ} (h : ∀ hf : (setOf p).Finite, n < #hf.toFinset) : n ≤ nth p n :=\n  (setOf p).finite_or_infinite.elim\n    (fun hf => ((nth_strictMonoOn hf).mono <| Set.Iic_subset_Iio.2 (h _)).Iic_id_le _ le_rfl)\n    fun hf => (nth_strictMono hf).id_le _\n\n"}
{"name":"Nat.isLeast_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ IsLeast (setOf fun i => And (p i) (∀ (k : Nat), LT.lt k n → LT.lt (Nat.nth p k) i)) (Nat.nth p n)","decl":"theorem isLeast_nth {n} (h : ∀ hf : (setOf p).Finite, n < #hf.toFinset) :\n    IsLeast {i | p i ∧ ∀ k < n, nth p k < i} (nth p n) :=\n  ⟨⟨nth_mem n h, fun _k hk => nth_lt_nth' hk h⟩, fun _x hx =>\n    let ⟨k, hk, hkx⟩ := exists_lt_card_nth_eq hx.1\n    (lt_or_le k n).elim (fun hlt => absurd hkx (hx.2 _ hlt).ne) fun hle => hkx ▸ nth_le_nth' hle hk⟩\n\n"}
{"name":"Nat.isLeast_nth_of_lt_card","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nhf : (setOf p).Finite\nhn : LT.lt n hf.toFinset.card\n⊢ IsLeast (setOf fun i => And (p i) (∀ (k : Nat), LT.lt k n → LT.lt (Nat.nth p k) i)) (Nat.nth p n)","decl":"theorem isLeast_nth_of_lt_card {n : ℕ} (hf : (setOf p).Finite) (hn : n < #hf.toFinset) :\n    IsLeast {i | p i ∧ ∀ k < n, nth p k < i} (nth p n) :=\n  isLeast_nth fun _ => hn\n\n"}
{"name":"Nat.isLeast_nth_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nhf : (setOf p).Infinite\nn : Nat\n⊢ IsLeast (setOf fun i => And (p i) (∀ (k : Nat), LT.lt k n → LT.lt (Nat.nth p k) i)) (Nat.nth p n)","decl":"theorem isLeast_nth_of_infinite (hf : (setOf p).Infinite) (n : ℕ) :\n    IsLeast {i | p i ∧ ∀ k < n, nth p k < i} (nth p n) :=\n  isLeast_nth fun h => absurd h hf\n\n"}
{"name":"Nat.nth_eq_sInf","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\n⊢ Eq (Nat.nth p n) (InfSet.sInf (setOf fun x => And (p x) (∀ (k : Nat), LT.lt k n → LT.lt (Nat.nth p k) x)))","decl":"/-- An alternative recursive definition of `Nat.nth`: `Nat.nth s n` is the infimum of `x ∈ s` such\nthat `Nat.nth s k < x` for all `k < n`, if this set is nonempty. We do not assume that the set is\nnonempty because we use the same \"garbage value\" `0` both for `sInf` on `ℕ` and for `Nat.nth s n`\nfor `n ≥ #s`. -/\ntheorem nth_eq_sInf (p : ℕ → Prop) (n : ℕ) : nth p n = sInf {x | p x ∧ ∀ k < n, nth p k < x} := by\n  by_cases hn : ∀ hf : (setOf p).Finite, n < #hf.toFinset\n  · exact (isLeast_nth hn).csInf_eq.symm\n  · push_neg at hn\n    rcases hn with ⟨hf, hn⟩\n    rw [nth_of_card_le _ hn]\n    refine ((congr_arg sInf <| Set.eq_empty_of_forall_not_mem fun k hk => ?_).trans sInf_empty).symm\n    rcases exists_lt_card_nth_eq hk.1 with ⟨k, hlt, rfl⟩\n    exact (hk.2 _ ((hlt hf).trans_le hn)).false\n\n"}
{"name":"Nat.nth_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\n⊢ Eq (Nat.nth p 0) (InfSet.sInf (setOf p))","decl":"theorem nth_zero : nth p 0 = sInf (setOf p) := by rw [nth_eq_sInf]; simp\n\n"}
{"name":"Nat.nth_zero_of_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nh : p 0\n⊢ Eq (Nat.nth p 0) 0","decl":"@[simp]\ntheorem nth_zero_of_zero (h : p 0) : nth p 0 = 0 := by simp [nth_zero, h]\n\n"}
{"name":"Nat.nth_zero_of_exists","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\n⊢ Eq (Nat.nth p 0) (Nat.find h)","decl":"theorem nth_zero_of_exists [DecidablePred p] (h : ∃ n, p n) : nth p 0 = Nat.find h := by\n  rw [nth_zero]; convert Nat.sInf_def h\n\n"}
{"name":"Nat.nth_eq_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\n⊢ Iff (Eq (Nat.nth p n) 0) (Or (And (p 0) (Eq n 0)) (Exists fun hf => LE.le hf.toFinset.card n))","decl":"theorem nth_eq_zero {n} :\n    nth p n = 0 ↔ p 0 ∧ n = 0 ∨ ∃ hf : (setOf p).Finite, #hf.toFinset ≤ n := by\n  refine ⟨fun h => ?_, ?_⟩\n  · simp only [or_iff_not_imp_right, not_exists, not_le]\n    exact fun hn => ⟨h ▸ nth_mem _ hn, nonpos_iff_eq_zero.1 <| h ▸ le_nth hn⟩\n  · rintro (⟨h₀, rfl⟩ | ⟨hf, hle⟩)\n    exacts [nth_zero_of_zero h₀, nth_of_card_le hf hle]\n\n"}
{"name":"Nat.lt_card_toFinset_of_nth_ne_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh : Ne (Nat.nth p n) 0\nhf : (setOf p).Finite\n⊢ LT.lt n hf.toFinset.card","decl":"lemma lt_card_toFinset_of_nth_ne_zero {n : ℕ} (h : nth p n ≠ 0) (hf : (setOf p).Finite) :\n    n < #hf.toFinset := by\n  simp only [ne_eq, nth_eq_zero, not_or, not_exists, not_le] at h\n  exact h.2 hf\n\n"}
{"name":"Nat.nth_mem_of_ne_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh : Ne (Nat.nth p n) 0\n⊢ p (Nat.nth p n)","decl":"lemma nth_mem_of_ne_zero {n : ℕ} (h : nth p n ≠ 0) : p (Nat.nth p n) :=\n  nth_mem n (lt_card_toFinset_of_nth_ne_zero h)\n\n"}
{"name":"Nat.nth_eq_zero_mono","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nh₀ : Not (p 0)\na b : Nat\nhab : LE.le a b\nha : Eq (Nat.nth p a) 0\n⊢ Eq (Nat.nth p b) 0","decl":"theorem nth_eq_zero_mono (h₀ : ¬p 0) {a b : ℕ} (hab : a ≤ b) (ha : nth p a = 0) : nth p b = 0 := by\n  simp only [nth_eq_zero, h₀, false_and, false_or] at ha ⊢\n  exact ha.imp fun hf hle => hle.trans hab\n\n"}
{"name":"Nat.nth_ne_zero_anti","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nh₀ : Not (p 0)\na b : Nat\nhab : LE.le a b\nhb : Ne (Nat.nth p b) 0\n⊢ Ne (Nat.nth p a) 0","decl":"lemma nth_ne_zero_anti (h₀ : ¬p 0) {a b : ℕ} (hab : a ≤ b) (hb : nth p b ≠ 0) : nth p a ≠ 0 :=\n  mt (nth_eq_zero_mono h₀ hab) hb\n\n"}
{"name":"Nat.le_nth_of_lt_nth_succ","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nk a : Nat\nh : LT.lt a (Nat.nth p (HAdd.hAdd k 1))\nha : p a\n⊢ LE.le a (Nat.nth p k)","decl":"theorem le_nth_of_lt_nth_succ {k a : ℕ} (h : a < nth p (k + 1)) (ha : p a) : a ≤ nth p k := by\n  cases' (setOf p).finite_or_infinite with hf hf\n  · rcases exists_lt_card_finite_nth_eq hf ha with ⟨n, hn, rfl⟩\n    cases' lt_or_le (k + 1) #hf.toFinset with hk hk\n    · rwa [(nth_strictMonoOn hf).lt_iff_lt hn hk, Nat.lt_succ_iff,\n        ← (nth_strictMonoOn hf).le_iff_le hn (k.lt_succ_self.trans hk)] at h\n    · rw [nth_of_card_le _ hk] at h\n      exact absurd h (zero_le _).not_lt\n  · rcases subset_range_nth ha with ⟨n, rfl⟩\n    rwa [nth_lt_nth hf, Nat.lt_succ_iff, ← nth_le_nth hf] at h\n\n"}
{"name":"Nat.nth_mem_anti","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\na b : Nat\nhab : LE.le a b\nh : p (Nat.nth p b)\n⊢ p (Nat.nth p a)","decl":"lemma nth_mem_anti {a b : ℕ} (hab : a ≤ b) (h : p (nth p b)) : p (nth p a) := by\n  by_cases h' : ∀ hf : (setOf p).Finite, a < #hf.toFinset\n  · exact nth_mem a h'\n  · simp only [not_forall, not_lt] at h'\n    have h'b : ∃ hf : (setOf p).Finite, #hf.toFinset ≤ b := by\n      rcases h' with ⟨hf, ha⟩\n      exact ⟨hf, ha.trans hab⟩\n    have ha0 : nth p a = 0 := by simp [nth_eq_zero, h']\n    have hb0 : nth p b = 0 := by simp [nth_eq_zero, h'b]\n    rw [ha0]\n    rwa [hb0] at h\n\n"}
{"name":"Nat.nth_comp_of_strictMono","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nf : Nat → Nat\nhf : StrictMono f\nh0 : ∀ (k : Nat), p k → Membership.mem (Set.range f) k\nh : ∀ (hfi : (setOf p).Finite), LT.lt n hfi.toFinset.card\n⊢ Eq (f (Nat.nth (fun i => p (f i)) n)) (Nat.nth p n)","decl":"lemma nth_comp_of_strictMono {n : ℕ} {f : ℕ → ℕ} (hf : StrictMono f)\n    (h0 : ∀ k, p k → k ∈ Set.range f) (h : ∀ hfi : (setOf p).Finite, n < hfi.toFinset.card) :\n    f (nth (fun i ↦ p (f i)) n) = nth p n := by\n  have hs {p' : ℕ → Prop} (h0p' : ∀ k, p' k → k ∈ Set.range f) :\n      f '' {i | p' (f i)} = setOf p' := by\n    ext i\n    refine ⟨fun ⟨_, hi, h⟩ ↦ h ▸ hi, fun he ↦ ?_⟩\n    rcases h0p' _ he with ⟨t, rfl⟩\n    exact ⟨t, he, rfl⟩\n  induction n using Nat.case_strong_induction_on\n  case _ =>\n    simp_rw [nth_zero]\n    replace h := nth_mem _ h\n    rw [← hs h0, ← hf.monotone.map_csInf]\n    rcases h0 _ h with ⟨t, ht⟩\n    exact ⟨t, Set.mem_setOf_eq ▸ ht ▸ h⟩\n  case _ n ih =>\n    repeat nth_rw 1 [nth_eq_sInf]\n    have h0' : ∀ k', (p k' ∧ ∀ k < n + 1, nth p k < k') → k' ∈ Set.range f := fun _ h ↦ h0 _ h.1\n    rw [← hs h0', ← hf.monotone.map_csInf]\n    · convert rfl using 8 with k m' hm\n      nth_rw 2 [← hf.lt_iff_lt]\n      convert Iff.rfl using 2\n      exact ih m' (Nat.lt_add_one_iff.mp hm) fun hfi ↦ hm.trans (h hfi)\n    · rcases h0 _ (nth_mem _ h) with ⟨t, ht⟩\n      exact ⟨t, ht ▸ (nth_mem _ h), fun _ hk ↦ ht ▸ nth_lt_nth' hk h⟩\n\n"}
{"name":"Nat.nth_add","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nm n : Nat\nh0 : ∀ (k : Nat), LT.lt k m → Not (p k)\nh : Ne (Nat.nth p n) 0\n⊢ Eq (HAdd.hAdd (Nat.nth (fun i => p (HAdd.hAdd i m)) n) m) (Nat.nth p n)","decl":"lemma nth_add {m n : ℕ} (h0 : ∀ k < m, ¬p k) (h : nth p n ≠ 0) :\n    nth (fun i ↦ p (i + m)) n + m = nth p n := by\n  refine nth_comp_of_strictMono (strictMono_id.add_const m) (fun k hk ↦ ?_)\n    (fun hf ↦ lt_card_toFinset_of_nth_ne_zero h hf)\n  by_contra hn\n  simp_rw [id_eq, Set.mem_range, eq_comm] at hn\n  exact h0 _ (not_le.mp fun h ↦ hn (le_iff_exists_add'.mp h)) hk\n\n"}
{"name":"Nat.nth_add_eq_sub","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nm n : Nat\nh0 : ∀ (k : Nat), LT.lt k m → Not (p k)\nh : Ne (Nat.nth p n) 0\n⊢ Eq (Nat.nth (fun i => p (HAdd.hAdd i m)) n) (HSub.hSub (Nat.nth p n) m)","decl":"lemma nth_add_eq_sub {m n : ℕ} (h0 : ∀ k < m, ¬p k) (h : nth p n ≠ 0) :\n    nth (fun i ↦ p (i + m)) n = nth p n - m := by\n  rw [← nth_add h0 h, Nat.add_sub_cancel]\n\n"}
{"name":"Nat.nth_add_one","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh0 : Not (p 0)\nh : Ne (Nat.nth p n) 0\n⊢ Eq (HAdd.hAdd (Nat.nth (fun i => p (HAdd.hAdd i 1)) n) 1) (Nat.nth p n)","decl":"lemma nth_add_one {n : ℕ} (h0 : ¬p 0) (h : nth p n ≠ 0) :\n    nth (fun i ↦ p (i + 1)) n + 1 = nth p n :=\n  nth_add (fun _ hk ↦ (lt_one_iff.1 hk ▸ h0)) h\n\n"}
{"name":"Nat.nth_add_one_eq_sub","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nh0 : Not (p 0)\nh : Ne (Nat.nth p n) 0\n⊢ Eq (Nat.nth (fun i => p (HAdd.hAdd i 1)) n) (HSub.hSub (Nat.nth p n) 1)","decl":"lemma nth_add_one_eq_sub {n : ℕ} (h0 : ¬p 0) (h : nth p n ≠ 0) :\n    nth (fun i ↦ p (i + 1)) n = nth p n - 1 :=\n  nth_add_eq_sub (fun _ hk ↦ (lt_one_iff.1 hk ▸ h0)) h\n\n"}
{"name":"Nat.count_nth_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Nat.count p (Nat.nth p 0)) 0","decl":"@[simp]\ntheorem count_nth_zero : count p (nth p 0) = 0 := by\n  rw [count_eq_card_filter_range, card_eq_zero, filter_eq_empty_iff, nth_zero]\n  exact fun n h₁ h₂ => (mem_range.1 h₁).not_le (Nat.sInf_le h₂)\n\n"}
{"name":"Nat.filter_range_nth_subset_insert","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nk : Nat\n⊢ HasSubset.Subset (Finset.filter (fun n => p n) (Finset.range (Nat.nth p (HAdd.hAdd k 1)))) (Insert.insert (Nat.nth p k) (Finset.filter (fun n => p n) (Finset.range (Nat.nth p k))))","decl":"theorem filter_range_nth_subset_insert (k : ℕ) :\n    {n ∈ range (nth p (k + 1)) | p n} ⊆ insert (nth p k) {n ∈ range (nth p k) | p n} := by\n  intro a ha\n  simp only [mem_insert, mem_filter, mem_range] at ha ⊢\n  exact (le_nth_of_lt_nth_succ ha.1 ha.2).eq_or_lt.imp_right fun h => ⟨h, ha.2⟩\n\n"}
{"name":"Nat.filter_range_nth_eq_insert","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nk : Nat\nhlt : ∀ (hf : (setOf p).Finite), LT.lt (HAdd.hAdd k 1) hf.toFinset.card\n⊢ Eq (Finset.filter (fun n => p n) (Finset.range (Nat.nth p (HAdd.hAdd k 1)))) (Insert.insert (Nat.nth p k) (Finset.filter (fun n => p n) (Finset.range (Nat.nth p k))))","decl":"theorem filter_range_nth_eq_insert {k : ℕ}\n    (hlt : ∀ hf : (setOf p).Finite, k + 1 < #hf.toFinset) :\n    {n ∈ range (nth p (k + 1)) | p n} = insert (nth p k) {n ∈ range (nth p k) | p n} := by\n  refine (filter_range_nth_subset_insert p k).antisymm fun a ha => ?_\n  simp only [mem_insert, mem_filter, mem_range] at ha ⊢\n  have : nth p k < nth p (k + 1) := nth_lt_nth' k.lt_succ_self hlt\n  rcases ha with (rfl | ⟨hlt, hpa⟩)\n  · exact ⟨this, nth_mem _ fun hf => k.lt_succ_self.trans (hlt hf)⟩\n  · exact ⟨hlt.trans this, hpa⟩\n\n"}
{"name":"Nat.filter_range_nth_eq_insert_of_finite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhf : (setOf p).Finite\nk : Nat\nhlt : LT.lt (HAdd.hAdd k 1) hf.toFinset.card\n⊢ Eq (Finset.filter (fun n => p n) (Finset.range (Nat.nth p (HAdd.hAdd k 1)))) (Insert.insert (Nat.nth p k) (Finset.filter (fun n => p n) (Finset.range (Nat.nth p k))))","decl":"theorem filter_range_nth_eq_insert_of_finite (hf : (setOf p).Finite) {k : ℕ}\n    (hlt : k + 1 < #hf.toFinset) :\n    {n ∈ range (nth p (k + 1)) | p n} = insert (nth p k) {n ∈ range (nth p k) | p n} :=\n  filter_range_nth_eq_insert fun _ => hlt\n\n"}
{"name":"Nat.filter_range_nth_eq_insert_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\nk : Nat\n⊢ Eq (Finset.filter (fun n => p n) (Finset.range (Nat.nth p (HAdd.hAdd k 1)))) (Insert.insert (Nat.nth p k) (Finset.filter (fun n => p n) (Finset.range (Nat.nth p k))))","decl":"theorem filter_range_nth_eq_insert_of_infinite (hp : (setOf p).Infinite) (k : ℕ) :\n    {n ∈ range (nth p (k + 1)) | p n} = insert (nth p k) {n ∈ range (nth p k) | p n} :=\n  filter_range_nth_eq_insert fun hf => absurd hf hp\n\n"}
{"name":"Nat.count_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhn : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ Eq (Nat.count p (Nat.nth p n)) n","decl":"theorem count_nth {n : ℕ} (hn : ∀ hf : (setOf p).Finite, n < #hf.toFinset) :\n    count p (nth p n) = n := by\n  induction' n with k ihk\n  · exact count_nth_zero _\n  · rw [count_eq_card_filter_range, filter_range_nth_eq_insert hn, card_insert_of_not_mem, ←\n      count_eq_card_filter_range, ihk fun hf => lt_of_succ_lt (hn hf)]\n    simp\n\n"}
{"name":"Nat.count_nth_of_lt_card_finite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhp : (setOf p).Finite\nhlt : LT.lt n hp.toFinset.card\n⊢ Eq (Nat.count p (Nat.nth p n)) n","decl":"theorem count_nth_of_lt_card_finite {n : ℕ} (hp : (setOf p).Finite) (hlt : n < #hp.toFinset) :\n    count p (nth p n) = n :=\n  count_nth fun _ => hlt\n\n"}
{"name":"Nat.count_nth_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\nn : Nat\n⊢ Eq (Nat.count p (Nat.nth p n)) n","decl":"theorem count_nth_of_infinite (hp : (setOf p).Infinite) (n : ℕ) : count p (nth p n) = n :=\n  count_nth fun hf => absurd hf hp\n\n"}
{"name":"Nat.surjective_count_of_infinite_setOf","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : (setOf fun n => p n).Infinite\n⊢ Function.Surjective (Nat.count p)","decl":"theorem surjective_count_of_infinite_setOf (h : {n | p n}.Infinite) :\n    Function.Surjective (Nat.count p) :=\n  fun n => ⟨nth p n, count_nth_of_infinite h n⟩\n\n"}
{"name":"Nat.count_nth_succ","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhn : ∀ (hf : (setOf p).Finite), LT.lt n hf.toFinset.card\n⊢ Eq (Nat.count p (HAdd.hAdd (Nat.nth p n) 1)) (HAdd.hAdd n 1)","decl":"theorem count_nth_succ {n : ℕ} (hn : ∀ hf : (setOf p).Finite, n < #hf.toFinset) :\n    count p (nth p n + 1) = n + 1 := by rw [count_succ, count_nth hn, if_pos (nth_mem _ hn)]\n\n"}
{"name":"Nat.count_nth_succ_of_infinite","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\nn : Nat\n⊢ Eq (Nat.count p (HAdd.hAdd (Nat.nth p n) 1)) (HAdd.hAdd n 1)","decl":"lemma count_nth_succ_of_infinite (hp : (setOf p).Infinite) (n : ℕ) :\n    count p (nth p n + 1) = n + 1 := by\n  rw [count_succ, count_nth_of_infinite hp, if_pos (nth_mem_of_infinite hp _)]\n\n"}
{"name":"Nat.nth_count","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhpn : p n\n⊢ Eq (Nat.nth p (Nat.count p n)) n","decl":"@[simp]\ntheorem nth_count {n : ℕ} (hpn : p n) : nth p (count p n) = n :=\n  have : ∀ hf : (setOf p).Finite, count p n < #hf.toFinset := fun hf => count_lt_card hf hpn\n  count_injective (nth_mem _ this) hpn (count_nth this)\n\n"}
{"name":"Nat.nth_lt_of_lt_count","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn k : Nat\nh : LT.lt k (Nat.count p n)\n⊢ LT.lt (Nat.nth p k) n","decl":"theorem nth_lt_of_lt_count {n k : ℕ} (h : k < count p n) : nth p k < n := by\n  refine (count_monotone p).reflect_lt ?_\n  rwa [count_nth]\n  exact fun hf => h.trans_le (count_le_card hf n)\n\n"}
{"name":"Nat.le_nth_of_count_le","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn k : Nat\nh : LE.le n (Nat.nth p k)\n⊢ LE.le (Nat.count p n) k","decl":"theorem le_nth_of_count_le {n k : ℕ} (h : n ≤ nth p k) : count p n ≤ k :=\n  not_lt.1 fun hlt => h.not_lt <| nth_lt_of_lt_count hlt\n\n"}
{"name":"Nat.count_eq_zero","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nh : Exists fun n => p n\nn : Nat\n⊢ Iff (Eq (Nat.count p n) 0) (LE.le n (Nat.nth p 0))","decl":"protected theorem count_eq_zero (h : ∃ n, p n) {n : ℕ} : count p n = 0 ↔ n ≤ nth p 0 := by\n  rw [nth_zero_of_exists h, le_find_iff h, Nat.count_iff_forall_not]\n\n"}
{"name":"Nat.nth_count_eq_sInf","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Eq (Nat.nth p (Nat.count p n)) (InfSet.sInf (setOf fun i => And (p i) (LE.le n i)))","decl":"theorem nth_count_eq_sInf (n : ℕ) : nth p (count p n) = sInf {i : ℕ | p i ∧ n ≤ i} := by\n  refine (nth_eq_sInf _ _).trans (congr_arg sInf ?_)\n  refine Set.ext fun a => and_congr_right fun hpa => ?_\n  refine ⟨fun h => not_lt.1 fun ha => ?_, fun hn k hk => lt_of_lt_of_le (nth_lt_of_lt_count hk) hn⟩\n  have hn : nth p (count p a) < a := h _ (count_strict_mono hpa ha)\n  rwa [nth_count hpa, lt_self_iff_false] at hn\n\n"}
{"name":"Nat.le_nth_count'","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhpn : Exists fun k => And (p k) (LE.le n k)\n⊢ LE.le n (Nat.nth p (Nat.count p n))","decl":"theorem le_nth_count' {n : ℕ} (hpn : ∃ k, p k ∧ n ≤ k) : n ≤ nth p (count p n) :=\n  (le_csInf hpn fun _ => And.right).trans (nth_count_eq_sInf p n).ge\n\n"}
{"name":"Nat.le_nth_count","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\nn : Nat\n⊢ LE.le n (Nat.nth p (Nat.count p n))","decl":"theorem le_nth_count (hp : (setOf p).Infinite) (n : ℕ) : n ≤ nth p (count p n) :=\n  let ⟨m, hp, hn⟩ := hp.exists_gt n\n  le_nth_count' ⟨m, hp, hn.le⟩\n\n"}
{"name":"Nat.gc_count_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\n⊢ GaloisConnection (Nat.count p) (Nat.nth p)","decl":"theorem gc_count_nth (hp : (setOf p).Infinite) : GaloisConnection (count p) (nth p) :=\n  (giCountNth hp).gc\n\n"}
{"name":"Nat.count_le_iff_le_nth","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\na b : Nat\n⊢ Iff (LE.le (Nat.count p a) b) (LE.le a (Nat.nth p b))","decl":"theorem count_le_iff_le_nth (hp : (setOf p).Infinite) {a b : ℕ} : count p a ≤ b ↔ a ≤ nth p b :=\n  gc_count_nth hp _ _\n\n"}
{"name":"Nat.lt_nth_iff_count_lt","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Infinite\na b : Nat\n⊢ Iff (LT.lt a (Nat.count p b)) (LT.lt (Nat.nth p a) b)","decl":"theorem lt_nth_iff_count_lt (hp : (setOf p).Infinite) {a b : ℕ} : a < count p b ↔ nth p a < b :=\n  (gc_count_nth hp).lt_iff_lt\n\n"}
{"name":"Nat.nth_of_forall","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nhp : ∀ (n' : Nat), LE.le n' n → p n'\n⊢ Eq (Nat.nth p n) n","decl":"theorem nth_of_forall {n : ℕ} (hp : ∀ n' ≤ n, p n') : nth p n = n := by\n  classical nth_rw 1 [← count_of_forall (hp · ·.le), nth_count (hp n le_rfl)]\n\n"}
{"name":"Nat.nth_true","module":"Mathlib.Data.Nat.Nth","initialProofState":"n : Nat\n⊢ Eq (Nat.nth (fun x => True) n) n","decl":"@[simp] theorem nth_true (n : ℕ) : nth (fun _ ↦ True) n = n := nth_of_forall fun _ _ ↦ trivial\n\n"}
{"name":"Nat.nth_of_forall_not","module":"Mathlib.Data.Nat.Nth","initialProofState":"p : Nat → Prop\nn : Nat\nhp : ∀ (n' : Nat), GE.ge n' n → Not (p n')\n⊢ Eq (Nat.nth p n) 0","decl":"theorem nth_of_forall_not {n : ℕ} (hp : ∀ n' ≥ n, ¬p n') : nth p n = 0 := by\n  have : setOf p ⊆ Finset.range n := by\n    intro n' hn'\n    contrapose! hp\n    exact ⟨n', by simpa using hp, Set.mem_setOf.mp hn'⟩\n  rw [nth_of_card_le ((finite_toSet _).subset this)]\n  · refine (Finset.card_le_card ?_).trans_eq (Finset.card_range n)\n    exact Set.Finite.toFinset_subset.mpr this\n\n"}
{"name":"Nat.nth_false","module":"Mathlib.Data.Nat.Nth","initialProofState":"n : Nat\n⊢ Eq (Nat.nth (fun x => False) n) 0","decl":"@[simp] theorem nth_false (n : ℕ) : nth (fun _ ↦ False) n = 0 := nth_of_forall_not fun _ _ ↦ id\n\n"}
