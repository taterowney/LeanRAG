{"name":"NormedSpace.dual_def","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nf : NormedSpace.Dual 𝕜 E\n⊢ Eq (((NormedSpace.inclusionInDoubleDual 𝕜 E) x) f) (f x)","decl":"@[simp]\ntheorem dual_def (x : E) (f : Dual 𝕜 E) : inclusionInDoubleDual 𝕜 E x f = f x :=\n  rfl\n\n"}
{"name":"NormedSpace.inclusionInDoubleDual_norm_eq","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (Norm.norm (NormedSpace.inclusionInDoubleDual 𝕜 E)) (Norm.norm (ContinuousLinearMap.id 𝕜 (NormedSpace.Dual 𝕜 E)))","decl":"theorem inclusionInDoubleDual_norm_eq :\n    ‖inclusionInDoubleDual 𝕜 E‖ = ‖ContinuousLinearMap.id 𝕜 (Dual 𝕜 E)‖ :=\n  ContinuousLinearMap.opNorm_flip _\n\n"}
{"name":"NormedSpace.inclusionInDoubleDual_norm_le","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ LE.le (Norm.norm (NormedSpace.inclusionInDoubleDual 𝕜 E)) 1","decl":"theorem inclusionInDoubleDual_norm_le : ‖inclusionInDoubleDual 𝕜 E‖ ≤ 1 := by\n  rw [inclusionInDoubleDual_norm_eq]\n  exact ContinuousLinearMap.norm_id_le\n\n"}
{"name":"NormedSpace.double_dual_bound","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ LE.le (Norm.norm ((NormedSpace.inclusionInDoubleDual 𝕜 E) x)) (Norm.norm x)","decl":"theorem double_dual_bound (x : E) : ‖(inclusionInDoubleDual 𝕜 E) x‖ ≤ ‖x‖ := by\n  simpa using ContinuousLinearMap.le_of_opNorm_le _ (inclusionInDoubleDual_norm_le 𝕜 E) x\n\n"}
{"name":"NormedSpace.dualPairing_apply","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nv : NormedSpace.Dual 𝕜 E\nx : E\n⊢ Eq (((NormedSpace.dualPairing 𝕜 E) v) x) (v x)","decl":"@[simp]\ntheorem dualPairing_apply {v : Dual 𝕜 E} {x : E} : dualPairing 𝕜 E v x = v x :=\n  rfl\n\n"}
{"name":"NormedSpace.dualPairing_separatingLeft","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ (NormedSpace.dualPairing 𝕜 E).SeparatingLeft","decl":"theorem dualPairing_separatingLeft : (dualPairing 𝕜 E).SeparatingLeft := by\n  rw [LinearMap.separatingLeft_iff_ker_eq_bot, LinearMap.ker_eq_bot]\n  exact ContinuousLinearMap.coe_injective\n\n"}
{"name":"NormedSpace.norm_le_dual_bound","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nM : Real\nhMp : LE.le 0 M\nhM : ∀ (f : NormedSpace.Dual 𝕜 E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm f))\n⊢ LE.le (Norm.norm x) M","decl":"/-- If one controls the norm of every `f x`, then one controls the norm of `x`.\n    Compare `ContinuousLinearMap.opNorm_le_bound`. -/\ntheorem norm_le_dual_bound (x : E) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ f : Dual 𝕜 E, ‖f x‖ ≤ M * ‖f‖) :\n    ‖x‖ ≤ M := by\n  classical\n    by_cases h : x = 0\n    · simp only [h, hMp, norm_zero]\n    · obtain ⟨f, hf₁, hfx⟩ : ∃ f : E →L[𝕜] 𝕜, ‖f‖ = 1 ∧ f x = ‖x‖ := exists_dual_vector 𝕜 x h\n      calc\n        ‖x‖ = ‖(‖x‖ : 𝕜)‖ := RCLike.norm_coe_norm.symm\n        _ = ‖f x‖ := by rw [hfx]\n        _ ≤ M * ‖f‖ := hM f\n        _ = M := by rw [hf₁, mul_one]\n\n"}
{"name":"NormedSpace.eq_zero_of_forall_dual_eq_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nh : ∀ (f : NormedSpace.Dual 𝕜 E), Eq (f x) 0\n⊢ Eq x 0","decl":"theorem eq_zero_of_forall_dual_eq_zero {x : E} (h : ∀ f : Dual 𝕜 E, f x = (0 : 𝕜)) : x = 0 :=\n  norm_le_zero_iff.mp (norm_le_dual_bound 𝕜 x le_rfl fun f => by simp [h f])\n\n"}
{"name":"NormedSpace.eq_zero_iff_forall_dual_eq_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Iff (Eq x 0) (∀ (g : NormedSpace.Dual 𝕜 E), Eq (g x) 0)","decl":"theorem eq_zero_iff_forall_dual_eq_zero (x : E) : x = 0 ↔ ∀ g : Dual 𝕜 E, g x = 0 :=\n  ⟨fun hx => by simp [hx], fun h => eq_zero_of_forall_dual_eq_zero 𝕜 h⟩\n\n"}
{"name":"NormedSpace.eq_iff_forall_dual_eq","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type v\ninst✝² : RCLike 𝕜\nE : Type u\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx y : E\n⊢ Iff (Eq x y) (∀ (g : NormedSpace.Dual 𝕜 E), Eq (g x) (g y))","decl":"/-- See also `geometric_hahn_banach_point_point`. -/\ntheorem eq_iff_forall_dual_eq {x y : E} : x = y ↔ ∀ g : Dual 𝕜 E, g x = g y := by\n  rw [← sub_eq_zero, eq_zero_iff_forall_dual_eq_zero 𝕜 (x - y)]\n  simp [sub_eq_zero]\n\n"}
{"name":"NormedSpace.polarSubmodule_eq_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nm : SubMulAction 𝕜 E\n⊢ Eq (↑(NormedSpace.polarSubmodule 𝕜 m)) (NormedSpace.polar 𝕜 ↑m)","decl":"lemma polarSubmodule_eq_polar (m : SubMulAction 𝕜 E) :\n    (polarSubmodule 𝕜 m : Set (Dual 𝕜 E)) = polar 𝕜 m := rfl\n\n"}
{"name":"NormedSpace.mem_polar_iff","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx' : NormedSpace.Dual 𝕜 E\ns : Set E\n⊢ Iff (Membership.mem (NormedSpace.polar 𝕜 s) x') (∀ (z : E), Membership.mem s z → LE.le (Norm.norm (x' z)) 1)","decl":"theorem mem_polar_iff {x' : Dual 𝕜 E} (s : Set E) : x' ∈ polar 𝕜 s ↔ ∀ z ∈ s, ‖x' z‖ ≤ 1 :=\n  Iff.rfl\n\n"}
{"name":"NormedSpace.polarSubmodule_eq_setOf","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nS : Type u_3\ninst✝¹ : SetLike S E\ninst✝ : SMulMemClass S 𝕜 E\nm : S\n⊢ Eq (↑(NormedSpace.polarSubmodule 𝕜 m)) (setOf fun y => ∀ (x : E), Membership.mem m x → Eq (y x) 0)","decl":"lemma polarSubmodule_eq_setOf {S : Type*} [SetLike S E] [SMulMemClass S 𝕜 E] (m : S) :\n    polarSubmodule 𝕜 m = { y : Dual 𝕜 E | ∀ x ∈ m, y x = 0 } :=\n  (dualPairing 𝕜 E).flip.polar_subMulAction _\n\n"}
{"name":"NormedSpace.mem_polarSubmodule","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nS : Type u_3\ninst✝¹ : SetLike S E\ninst✝ : SMulMemClass S 𝕜 E\nm : S\ny : NormedSpace.Dual 𝕜 E\n⊢ Iff (Membership.mem (NormedSpace.polarSubmodule 𝕜 m) y) (∀ (x : E), Membership.mem m x → Eq (y x) 0)","decl":"lemma mem_polarSubmodule {S : Type*} [SetLike S E] [SMulMemClass S 𝕜 E] (m : S) (y : Dual 𝕜 E) :\n    y ∈ polarSubmodule 𝕜 m ↔ ∀ x ∈ m, y x = 0 := by\n  have := polarSubmodule_eq_setOf 𝕜 m\n  apply_fun (y ∈ ·) at this\n  rwa [propext_iff] at this\n\n"}
{"name":"NormedSpace.zero_mem_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Membership.mem (NormedSpace.polar 𝕜 s) 0","decl":"@[simp]\ntheorem zero_mem_polar (s : Set E) : (0 : Dual 𝕜 E) ∈ polar 𝕜 s :=\n  LinearMap.zero_mem_polar _ s\n\n"}
{"name":"NormedSpace.polar_nonempty","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ (NormedSpace.polar 𝕜 s).Nonempty","decl":"theorem polar_nonempty (s : Set E) : Set.Nonempty (polar 𝕜 s) :=\n  LinearMap.polar_nonempty _ _\n\n"}
{"name":"NormedSpace.polar_univ","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (NormedSpace.polar 𝕜 Set.univ) (Singleton.singleton 0)","decl":"@[simp]\ntheorem polar_univ : polar 𝕜 (univ : Set E) = {(0 : Dual 𝕜 E)} :=\n  (dualPairing 𝕜 E).flip.polar_univ\n    (LinearMap.flip_separatingRight.mpr (dualPairing_separatingLeft 𝕜 E))\n\n"}
{"name":"NormedSpace.isClosed_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ IsClosed (NormedSpace.polar 𝕜 s)","decl":"theorem isClosed_polar (s : Set E) : IsClosed (polar 𝕜 s) := by\n  dsimp only [NormedSpace.polar]\n  simp only [LinearMap.polar_eq_iInter, LinearMap.flip_apply]\n  refine isClosed_biInter fun z _ => ?_\n  exact isClosed_Iic.preimage (ContinuousLinearMap.apply 𝕜 𝕜 z).continuous.norm\n\n"}
{"name":"NormedSpace.polar_closure","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\n⊢ Eq (NormedSpace.polar 𝕜 (closure s)) (NormedSpace.polar 𝕜 s)","decl":"@[simp]\ntheorem polar_closure (s : Set E) : polar 𝕜 (closure s) = polar 𝕜 s :=\n  ((dualPairing 𝕜 E).flip.polar_antitone subset_closure).antisymm <|\n    (dualPairing 𝕜 E).flip.polar_gc.l_le <|\n      closure_minimal ((dualPairing 𝕜 E).flip.polar_gc.le_u_l s) <| by\n        simpa [LinearMap.flip_flip] using\n          (isClosed_polar _ _).preimage (inclusionInDoubleDual 𝕜 E).continuous\n\n"}
{"name":"NormedSpace.smul_mem_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nx' : NormedSpace.Dual 𝕜 E\nc : 𝕜\nhc : ∀ (z : E), Membership.mem s z → LE.le (Norm.norm (x' z)) (Norm.norm c)\n⊢ Membership.mem (NormedSpace.polar 𝕜 s) (HSMul.hSMul (Inv.inv c) x')","decl":"/-- If `x'` is a dual element such that the norms `‖x' z‖` are bounded for `z ∈ s`, then a\nsmall scalar multiple of `x'` is in `polar 𝕜 s`. -/\ntheorem smul_mem_polar {s : Set E} {x' : Dual 𝕜 E} {c : 𝕜} (hc : ∀ z, z ∈ s → ‖x' z‖ ≤ ‖c‖) :\n    c⁻¹ • x' ∈ polar 𝕜 s := by\n  by_cases c_zero : c = 0\n  · simp only [c_zero, inv_zero, zero_smul]\n    exact (dualPairing 𝕜 E).flip.zero_mem_polar _\n  have eq : ∀ z, ‖c⁻¹ • x' z‖ = ‖c⁻¹‖ * ‖x' z‖ := fun z => norm_smul c⁻¹ _\n  have le : ∀ z, z ∈ s → ‖c⁻¹ • x' z‖ ≤ ‖c⁻¹‖ * ‖c‖ := by\n    intro z hzs\n    rw [eq z]\n    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)\n  have cancel : ‖c⁻¹‖ * ‖c‖ = 1 := by\n    simp only [c_zero, norm_eq_zero, Ne, not_false_iff, inv_mul_cancel₀, norm_inv]\n  rwa [cancel] at le\n\n"}
{"name":"NormedSpace.polar_ball_subset_closedBall_div","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nr : Real\nhr : LT.lt 0 r\n⊢ HasSubset.Subset (NormedSpace.polar 𝕜 (Metric.ball 0 r)) (Metric.closedBall 0 (HDiv.hDiv (Norm.norm c) r))","decl":"theorem polar_ball_subset_closedBall_div {c : 𝕜} (hc : 1 < ‖c‖) {r : ℝ} (hr : 0 < r) :\n    polar 𝕜 (ball (0 : E) r) ⊆ closedBall (0 : Dual 𝕜 E) (‖c‖ / r) := by\n  intro x' hx'\n  rw [mem_polar_iff] at hx'\n  simp only [polar, mem_setOf, mem_closedBall_zero_iff, mem_ball_zero_iff] at *\n  have hcr : 0 < ‖c‖ / r := div_pos (zero_lt_one.trans hc) hr\n  refine ContinuousLinearMap.opNorm_le_of_shell hr hcr.le hc fun x h₁ h₂ => ?_\n  calc\n    ‖x' x‖ ≤ 1 := hx' _ h₂\n    _ ≤ ‖c‖ / r * ‖x‖ := (inv_le_iff_one_le_mul₀' hcr).1 (by rwa [inv_div])\n\n"}
{"name":"NormedSpace.closedBall_inv_subset_polar_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\n⊢ HasSubset.Subset (Metric.closedBall 0 (Inv.inv r)) (NormedSpace.polar 𝕜 (Metric.closedBall 0 r))","decl":"theorem closedBall_inv_subset_polar_closedBall {r : ℝ} :\n    closedBall (0 : Dual 𝕜 E) r⁻¹ ⊆ polar 𝕜 (closedBall (0 : E) r) := fun x' hx' x hx =>\n  calc\n    ‖x' x‖ ≤ ‖x'‖ * ‖x‖ := x'.le_opNorm x\n    _ ≤ r⁻¹ * r :=\n      (mul_le_mul (mem_closedBall_zero_iff.1 hx') (mem_closedBall_zero_iff.1 hx) (norm_nonneg _)\n        (dist_nonneg.trans hx'))\n    _ = r / r := inv_mul_eq_div _ _\n    _ ≤ 1 := div_self_le_one r\n\n"}
{"name":"NormedSpace.polar_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_3\nE : Type u_4\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (NormedSpace.polar 𝕜 (Metric.closedBall 0 r)) (Metric.closedBall 0 (Inv.inv r))","decl":"/-- The `polar` of closed ball in a normed space `E` is the closed ball of the dual with\ninverse radius. -/\ntheorem polar_closedBall {𝕜 E : Type*} [RCLike 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] {r : ℝ}\n    (hr : 0 < r) : polar 𝕜 (closedBall (0 : E) r) = closedBall (0 : Dual 𝕜 E) r⁻¹ := by\n  refine Subset.antisymm ?_ (closedBall_inv_subset_polar_closedBall 𝕜)\n  intro x' h\n  simp only [mem_closedBall_zero_iff]\n  refine ContinuousLinearMap.opNorm_le_of_ball hr (inv_nonneg.mpr hr.le) fun z _ => ?_\n  simpa only [one_div] using LinearMap.bound_of_ball_bound' hr 1 x'.toLinearMap h z\n\n"}
{"name":"NormedSpace.polar_ball","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_3\nE : Type u_4\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (NormedSpace.polar 𝕜 (Metric.ball 0 r)) (Metric.closedBall 0 (Inv.inv r))","decl":"theorem polar_ball {𝕜 E : Type*} [RCLike 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] {r : ℝ}\n    (hr : 0 < r) : polar 𝕜 (ball (0 : E) r) = closedBall (0 : Dual 𝕜 E) r⁻¹ := by\n  apply le_antisymm\n  · intro x hx\n    rw [mem_closedBall_zero_iff]\n    apply le_of_forall_gt_imp_ge_of_dense\n    intro a ha\n    rw [← mem_closedBall_zero_iff, ← (mul_div_cancel_left₀ a (Ne.symm (ne_of_lt hr)))]\n    rw [← RCLike.norm_of_nonneg (K := 𝕜) (le_trans zero_le_one\n      (le_of_lt ((inv_lt_iff_one_lt_mul₀' hr).mp ha)))]\n    apply polar_ball_subset_closedBall_div _ hr hx\n    rw [RCLike.norm_of_nonneg (K := 𝕜) (le_trans zero_le_one\n      (le_of_lt ((inv_lt_iff_one_lt_mul₀' hr).mp ha)))]\n    exact (inv_lt_iff_one_lt_mul₀' hr).mp ha\n  · rw [← polar_closedBall hr]\n    exact LinearMap.polar_antitone _ ball_subset_closedBall\n\n"}
{"name":"NormedSpace.isBounded_polar_of_mem_nhds_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\ns_nhd : Membership.mem (nhds 0) s\n⊢ Bornology.IsBounded (NormedSpace.polar 𝕜 s)","decl":"/-- Given a neighborhood `s` of the origin in a normed space `E`, the dual norms\nof all elements of the polar `polar 𝕜 s` are bounded by a constant. -/\ntheorem isBounded_polar_of_mem_nhds_zero {s : Set E} (s_nhd : s ∈ 𝓝 (0 : E)) :\n    IsBounded (polar 𝕜 s) := by\n  obtain ⟨a, ha⟩ : ∃ a : 𝕜, 1 < ‖a‖ := NormedField.exists_one_lt_norm 𝕜\n  obtain ⟨r, r_pos, r_ball⟩ : ∃ r : ℝ, 0 < r ∧ ball 0 r ⊆ s := Metric.mem_nhds_iff.1 s_nhd\n  exact isBounded_closedBall.subset\n    (((dualPairing 𝕜 E).flip.polar_antitone r_ball).trans <|\n      polar_ball_subset_closedBall_div ha r_pos)\n\n"}
{"name":"NormedSpace.polar_empty","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (NormedSpace.polar 𝕜 EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem polar_empty : polar 𝕜 (∅ : Set E) = Set.univ :=\n  LinearMap.polar_empty _\n\n"}
{"name":"NormedSpace.polar_singleton","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\na : E\n⊢ Eq (NormedSpace.polar 𝕜 (Singleton.singleton a)) (setOf fun x => LE.le (Norm.norm (x a)) 1)","decl":"@[simp]\ntheorem polar_singleton {a : E} : polar 𝕜 {a} = { x | ‖x a‖ ≤ 1 } := by\n  simp only [polar, LinearMap.polar_singleton, LinearMap.flip_apply, dualPairing_apply]\n\n"}
{"name":"NormedSpace.mem_polar_singleton","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\na : E\ny : NormedSpace.Dual 𝕜 E\n⊢ Iff (Membership.mem (NormedSpace.polar 𝕜 (Singleton.singleton a)) y) (LE.le (Norm.norm (y a)) 1)","decl":"theorem mem_polar_singleton {a : E} (y : Dual 𝕜 E) : y ∈ polar 𝕜 {a} ↔ ‖y a‖ ≤ 1 := by\n  simp only [polar_singleton, mem_setOf_eq]\n\n"}
{"name":"NormedSpace.polar_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (NormedSpace.polar 𝕜 (Singleton.singleton 0)) Set.univ","decl":"theorem polar_zero : polar 𝕜 ({0} : Set E) = Set.univ :=\n  LinearMap.polar_zero _\n\n"}
{"name":"NormedSpace.sInter_polar_eq_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"𝕜 : Type u_3\nE : Type u_4\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (Set.image (NormedSpace.polar 𝕜) (setOf fun F => And F.Finite (HasSubset.Subset F (Metric.closedBall 0 (Inv.inv r))))).sInter (Metric.closedBall 0 r)","decl":"theorem sInter_polar_eq_closedBall {𝕜 E : Type*} [RCLike 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E]\n    {r : ℝ} (hr : 0 < r) :\n    ⋂₀ (polar 𝕜 '' { F | F.Finite ∧ F ⊆ closedBall (0 : E) r⁻¹ }) = closedBall 0 r := by\n  conv_rhs => rw [← inv_inv r]\n  rw [← polar_closedBall (inv_pos_of_pos hr), polar,\n    (dualPairing 𝕜 E).flip.sInter_polar_finite_subset_eq_polar (closedBall (0 : E) r⁻¹)]\n\n"}
