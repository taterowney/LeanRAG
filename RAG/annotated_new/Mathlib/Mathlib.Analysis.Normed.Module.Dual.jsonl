{"name":"NormedSpace.dual_def","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nf : NormedSpace.Dual ğ•œ E\nâŠ¢ Eq (((NormedSpace.inclusionInDoubleDual ğ•œ E) x) f) (f x)","decl":"@[simp]\ntheorem dual_def (x : E) (f : Dual ğ•œ E) : inclusionInDoubleDual ğ•œ E x f = f x :=\n  rfl\n\n"}
{"name":"NormedSpace.inclusionInDoubleDual_norm_eq","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (Norm.norm (NormedSpace.inclusionInDoubleDual ğ•œ E)) (Norm.norm (ContinuousLinearMap.id ğ•œ (NormedSpace.Dual ğ•œ E)))","decl":"theorem inclusionInDoubleDual_norm_eq :\n    â€–inclusionInDoubleDual ğ•œ Eâ€– = â€–ContinuousLinearMap.id ğ•œ (Dual ğ•œ E)â€– :=\n  ContinuousLinearMap.opNorm_flip _\n\n"}
{"name":"NormedSpace.inclusionInDoubleDual_norm_le","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ LE.le (Norm.norm (NormedSpace.inclusionInDoubleDual ğ•œ E)) 1","decl":"theorem inclusionInDoubleDual_norm_le : â€–inclusionInDoubleDual ğ•œ Eâ€– â‰¤ 1 := by\n  rw [inclusionInDoubleDual_norm_eq]\n  exact ContinuousLinearMap.norm_id_le\n\n"}
{"name":"NormedSpace.double_dual_bound","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ LE.le (Norm.norm ((NormedSpace.inclusionInDoubleDual ğ•œ E) x)) (Norm.norm x)","decl":"theorem double_dual_bound (x : E) : â€–(inclusionInDoubleDual ğ•œ E) xâ€– â‰¤ â€–xâ€– := by\n  simpa using ContinuousLinearMap.le_of_opNorm_le _ (inclusionInDoubleDual_norm_le ğ•œ E) x\n\n"}
{"name":"NormedSpace.dualPairing_apply","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nv : NormedSpace.Dual ğ•œ E\nx : E\nâŠ¢ Eq (((NormedSpace.dualPairing ğ•œ E) v) x) (v x)","decl":"@[simp]\ntheorem dualPairing_apply {v : Dual ğ•œ E} {x : E} : dualPairing ğ•œ E v x = v x :=\n  rfl\n\n"}
{"name":"NormedSpace.dualPairing_separatingLeft","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ (NormedSpace.dualPairing ğ•œ E).SeparatingLeft","decl":"theorem dualPairing_separatingLeft : (dualPairing ğ•œ E).SeparatingLeft := by\n  rw [LinearMap.separatingLeft_iff_ker_eq_bot, LinearMap.ker_eq_bot]\n  exact ContinuousLinearMap.coe_injective\n\n"}
{"name":"NormedSpace.norm_le_dual_bound","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nM : Real\nhMp : LE.le 0 M\nhM : âˆ€ (f : NormedSpace.Dual ğ•œ E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm f))\nâŠ¢ LE.le (Norm.norm x) M","decl":"/-- If one controls the norm of every `f x`, then one controls the norm of `x`.\n    Compare `ContinuousLinearMap.opNorm_le_bound`. -/\ntheorem norm_le_dual_bound (x : E) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ f : Dual ğ•œ E, â€–f xâ€– â‰¤ M * â€–fâ€–) :\n    â€–xâ€– â‰¤ M := by\n  classical\n    by_cases h : x = 0\n    Â· simp only [h, hMp, norm_zero]\n    Â· obtain âŸ¨f, hfâ‚, hfxâŸ© : âˆƒ f : E â†’L[ğ•œ] ğ•œ, â€–fâ€– = 1 âˆ§ f x = â€–xâ€– := exists_dual_vector ğ•œ x h\n      calc\n        â€–xâ€– = â€–(â€–xâ€– : ğ•œ)â€– := RCLike.norm_coe_norm.symm\n        _ = â€–f xâ€– := by rw [hfx]\n        _ â‰¤ M * â€–fâ€– := hM f\n        _ = M := by rw [hfâ‚, mul_one]\n\n"}
{"name":"NormedSpace.eq_zero_of_forall_dual_eq_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nh : âˆ€ (f : NormedSpace.Dual ğ•œ E), Eq (f x) 0\nâŠ¢ Eq x 0","decl":"theorem eq_zero_of_forall_dual_eq_zero {x : E} (h : âˆ€ f : Dual ğ•œ E, f x = (0 : ğ•œ)) : x = 0 :=\n  norm_le_zero_iff.mp (norm_le_dual_bound ğ•œ x le_rfl fun f => by simp [h f])\n\n"}
{"name":"NormedSpace.eq_zero_iff_forall_dual_eq_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nâŠ¢ Iff (Eq x 0) (âˆ€ (g : NormedSpace.Dual ğ•œ E), Eq (g x) 0)","decl":"theorem eq_zero_iff_forall_dual_eq_zero (x : E) : x = 0 â†” âˆ€ g : Dual ğ•œ E, g x = 0 :=\n  âŸ¨fun hx => by simp [hx], fun h => eq_zero_of_forall_dual_eq_zero ğ•œ hâŸ©\n\n"}
{"name":"NormedSpace.eq_iff_forall_dual_eq","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type v\ninstâœÂ² : RCLike ğ•œ\nE : Type u\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx y : E\nâŠ¢ Iff (Eq x y) (âˆ€ (g : NormedSpace.Dual ğ•œ E), Eq (g x) (g y))","decl":"/-- See also `geometric_hahn_banach_point_point`. -/\ntheorem eq_iff_forall_dual_eq {x y : E} : x = y â†” âˆ€ g : Dual ğ•œ E, g x = g y := by\n  rw [â† sub_eq_zero, eq_zero_iff_forall_dual_eq_zero ğ•œ (x - y)]\n  simp [sub_eq_zero]\n\n"}
{"name":"NormedSpace.polarSubmodule_eq_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nm : SubMulAction ğ•œ E\nâŠ¢ Eq (â†‘(NormedSpace.polarSubmodule ğ•œ m)) (NormedSpace.polar ğ•œ â†‘m)","decl":"lemma polarSubmodule_eq_polar (m : SubMulAction ğ•œ E) :\n    (polarSubmodule ğ•œ m : Set (Dual ğ•œ E)) = polar ğ•œ m := rfl\n\n"}
{"name":"NormedSpace.mem_polar_iff","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx' : NormedSpace.Dual ğ•œ E\ns : Set E\nâŠ¢ Iff (Membership.mem (NormedSpace.polar ğ•œ s) x') (âˆ€ (z : E), Membership.mem s z â†’ LE.le (Norm.norm (x' z)) 1)","decl":"theorem mem_polar_iff {x' : Dual ğ•œ E} (s : Set E) : x' âˆˆ polar ğ•œ s â†” âˆ€ z âˆˆ s, â€–x' zâ€– â‰¤ 1 :=\n  Iff.rfl\n\n"}
{"name":"NormedSpace.polarSubmodule_eq_setOf","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nS : Type u_3\ninstâœÂ¹ : SetLike S E\ninstâœ : SMulMemClass S ğ•œ E\nm : S\nâŠ¢ Eq (â†‘(NormedSpace.polarSubmodule ğ•œ m)) (setOf fun y => âˆ€ (x : E), Membership.mem m x â†’ Eq (y x) 0)","decl":"lemma polarSubmodule_eq_setOf {S : Type*} [SetLike S E] [SMulMemClass S ğ•œ E] (m : S) :\n    polarSubmodule ğ•œ m = { y : Dual ğ•œ E | âˆ€ x âˆˆ m, y x = 0 } :=\n  (dualPairing ğ•œ E).flip.polar_subMulAction _\n\n"}
{"name":"NormedSpace.mem_polarSubmodule","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nS : Type u_3\ninstâœÂ¹ : SetLike S E\ninstâœ : SMulMemClass S ğ•œ E\nm : S\ny : NormedSpace.Dual ğ•œ E\nâŠ¢ Iff (Membership.mem (NormedSpace.polarSubmodule ğ•œ m) y) (âˆ€ (x : E), Membership.mem m x â†’ Eq (y x) 0)","decl":"lemma mem_polarSubmodule {S : Type*} [SetLike S E] [SMulMemClass S ğ•œ E] (m : S) (y : Dual ğ•œ E) :\n    y âˆˆ polarSubmodule ğ•œ m â†” âˆ€ x âˆˆ m, y x = 0 := by\n  have := polarSubmodule_eq_setOf ğ•œ m\n  apply_fun (y âˆˆ Â·) at this\n  rwa [propext_iff] at this\n\n"}
{"name":"NormedSpace.zero_mem_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Membership.mem (NormedSpace.polar ğ•œ s) 0","decl":"@[simp]\ntheorem zero_mem_polar (s : Set E) : (0 : Dual ğ•œ E) âˆˆ polar ğ•œ s :=\n  LinearMap.zero_mem_polar _ s\n\n"}
{"name":"NormedSpace.polar_nonempty","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ (NormedSpace.polar ğ•œ s).Nonempty","decl":"theorem polar_nonempty (s : Set E) : Set.Nonempty (polar ğ•œ s) :=\n  LinearMap.polar_nonempty _ _\n\n"}
{"name":"NormedSpace.polar_univ","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (NormedSpace.polar ğ•œ Set.univ) (Singleton.singleton 0)","decl":"@[simp]\ntheorem polar_univ : polar ğ•œ (univ : Set E) = {(0 : Dual ğ•œ E)} :=\n  (dualPairing ğ•œ E).flip.polar_univ\n    (LinearMap.flip_separatingRight.mpr (dualPairing_separatingLeft ğ•œ E))\n\n"}
{"name":"NormedSpace.isClosed_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ IsClosed (NormedSpace.polar ğ•œ s)","decl":"theorem isClosed_polar (s : Set E) : IsClosed (polar ğ•œ s) := by\n  dsimp only [NormedSpace.polar]\n  simp only [LinearMap.polar_eq_iInter, LinearMap.flip_apply]\n  refine isClosed_biInter fun z _ => ?_\n  exact isClosed_Iic.preimage (ContinuousLinearMap.apply ğ•œ ğ•œ z).continuous.norm\n\n"}
{"name":"NormedSpace.polar_closure","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nâŠ¢ Eq (NormedSpace.polar ğ•œ (closure s)) (NormedSpace.polar ğ•œ s)","decl":"@[simp]\ntheorem polar_closure (s : Set E) : polar ğ•œ (closure s) = polar ğ•œ s :=\n  ((dualPairing ğ•œ E).flip.polar_antitone subset_closure).antisymm <|\n    (dualPairing ğ•œ E).flip.polar_gc.l_le <|\n      closure_minimal ((dualPairing ğ•œ E).flip.polar_gc.le_u_l s) <| by\n        simpa [LinearMap.flip_flip] using\n          (isClosed_polar _ _).preimage (inclusionInDoubleDual ğ•œ E).continuous\n\n"}
{"name":"NormedSpace.smul_mem_polar","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nx' : NormedSpace.Dual ğ•œ E\nc : ğ•œ\nhc : âˆ€ (z : E), Membership.mem s z â†’ LE.le (Norm.norm (x' z)) (Norm.norm c)\nâŠ¢ Membership.mem (NormedSpace.polar ğ•œ s) (HSMul.hSMul (Inv.inv c) x')","decl":"/-- If `x'` is a dual element such that the norms `â€–x' zâ€–` are bounded for `z âˆˆ s`, then a\nsmall scalar multiple of `x'` is in `polar ğ•œ s`. -/\ntheorem smul_mem_polar {s : Set E} {x' : Dual ğ•œ E} {c : ğ•œ} (hc : âˆ€ z, z âˆˆ s â†’ â€–x' zâ€– â‰¤ â€–câ€–) :\n    câ»Â¹ â€¢ x' âˆˆ polar ğ•œ s := by\n  by_cases c_zero : c = 0\n  Â· simp only [c_zero, inv_zero, zero_smul]\n    exact (dualPairing ğ•œ E).flip.zero_mem_polar _\n  have eq : âˆ€ z, â€–câ»Â¹ â€¢ x' zâ€– = â€–câ»Â¹â€– * â€–x' zâ€– := fun z => norm_smul câ»Â¹ _\n  have le : âˆ€ z, z âˆˆ s â†’ â€–câ»Â¹ â€¢ x' zâ€– â‰¤ â€–câ»Â¹â€– * â€–câ€– := by\n    intro z hzs\n    rw [eq z]\n    apply mul_le_mul (le_of_eq rfl) (hc z hzs) (norm_nonneg _) (norm_nonneg _)\n  have cancel : â€–câ»Â¹â€– * â€–câ€– = 1 := by\n    simp only [c_zero, norm_eq_zero, Ne, not_false_iff, inv_mul_cancelâ‚€, norm_inv]\n  rwa [cancel] at le\n\n"}
{"name":"NormedSpace.polar_ball_subset_closedBall_div","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nr : Real\nhr : LT.lt 0 r\nâŠ¢ HasSubset.Subset (NormedSpace.polar ğ•œ (Metric.ball 0 r)) (Metric.closedBall 0 (HDiv.hDiv (Norm.norm c) r))","decl":"theorem polar_ball_subset_closedBall_div {c : ğ•œ} (hc : 1 < â€–câ€–) {r : â„} (hr : 0 < r) :\n    polar ğ•œ (ball (0 : E) r) âŠ† closedBall (0 : Dual ğ•œ E) (â€–câ€– / r) := by\n  intro x' hx'\n  rw [mem_polar_iff] at hx'\n  simp only [polar, mem_setOf, mem_closedBall_zero_iff, mem_ball_zero_iff] at *\n  have hcr : 0 < â€–câ€– / r := div_pos (zero_lt_one.trans hc) hr\n  refine ContinuousLinearMap.opNorm_le_of_shell hr hcr.le hc fun x hâ‚ hâ‚‚ => ?_\n  calc\n    â€–x' xâ€– â‰¤ 1 := hx' _ hâ‚‚\n    _ â‰¤ â€–câ€– / r * â€–xâ€– := (inv_le_iff_one_le_mulâ‚€' hcr).1 (by rwa [inv_div])\n\n"}
{"name":"NormedSpace.closedBall_inv_subset_polar_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nâŠ¢ HasSubset.Subset (Metric.closedBall 0 (Inv.inv r)) (NormedSpace.polar ğ•œ (Metric.closedBall 0 r))","decl":"theorem closedBall_inv_subset_polar_closedBall {r : â„} :\n    closedBall (0 : Dual ğ•œ E) râ»Â¹ âŠ† polar ğ•œ (closedBall (0 : E) r) := fun x' hx' x hx =>\n  calc\n    â€–x' xâ€– â‰¤ â€–x'â€– * â€–xâ€– := x'.le_opNorm x\n    _ â‰¤ râ»Â¹ * r :=\n      (mul_le_mul (mem_closedBall_zero_iff.1 hx') (mem_closedBall_zero_iff.1 hx) (norm_nonneg _)\n        (dist_nonneg.trans hx'))\n    _ = r / r := inv_mul_eq_div _ _\n    _ â‰¤ 1 := div_self_le_one r\n\n"}
{"name":"NormedSpace.polar_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_3\nE : Type u_4\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (NormedSpace.polar ğ•œ (Metric.closedBall 0 r)) (Metric.closedBall 0 (Inv.inv r))","decl":"/-- The `polar` of closed ball in a normed space `E` is the closed ball of the dual with\ninverse radius. -/\ntheorem polar_closedBall {ğ•œ E : Type*} [RCLike ğ•œ] [NormedAddCommGroup E] [NormedSpace ğ•œ E] {r : â„}\n    (hr : 0 < r) : polar ğ•œ (closedBall (0 : E) r) = closedBall (0 : Dual ğ•œ E) râ»Â¹ := by\n  refine Subset.antisymm ?_ (closedBall_inv_subset_polar_closedBall ğ•œ)\n  intro x' h\n  simp only [mem_closedBall_zero_iff]\n  refine ContinuousLinearMap.opNorm_le_of_ball hr (inv_nonneg.mpr hr.le) fun z _ => ?_\n  simpa only [one_div] using LinearMap.bound_of_ball_bound' hr 1 x'.toLinearMap h z\n\n"}
{"name":"NormedSpace.polar_ball","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_3\nE : Type u_4\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (NormedSpace.polar ğ•œ (Metric.ball 0 r)) (Metric.closedBall 0 (Inv.inv r))","decl":"theorem polar_ball {ğ•œ E : Type*} [RCLike ğ•œ] [NormedAddCommGroup E] [NormedSpace ğ•œ E] {r : â„}\n    (hr : 0 < r) : polar ğ•œ (ball (0 : E) r) = closedBall (0 : Dual ğ•œ E) râ»Â¹ := by\n  apply le_antisymm\n  Â· intro x hx\n    rw [mem_closedBall_zero_iff]\n    apply le_of_forall_gt_imp_ge_of_dense\n    intro a ha\n    rw [â† mem_closedBall_zero_iff, â† (mul_div_cancel_leftâ‚€ a (Ne.symm (ne_of_lt hr)))]\n    rw [â† RCLike.norm_of_nonneg (K := ğ•œ) (le_trans zero_le_one\n      (le_of_lt ((inv_lt_iff_one_lt_mulâ‚€' hr).mp ha)))]\n    apply polar_ball_subset_closedBall_div _ hr hx\n    rw [RCLike.norm_of_nonneg (K := ğ•œ) (le_trans zero_le_one\n      (le_of_lt ((inv_lt_iff_one_lt_mulâ‚€' hr).mp ha)))]\n    exact (inv_lt_iff_one_lt_mulâ‚€' hr).mp ha\n  Â· rw [â† polar_closedBall hr]\n    exact LinearMap.polar_antitone _ ball_subset_closedBall\n\n"}
{"name":"NormedSpace.isBounded_polar_of_mem_nhds_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\ns_nhd : Membership.mem (nhds 0) s\nâŠ¢ Bornology.IsBounded (NormedSpace.polar ğ•œ s)","decl":"/-- Given a neighborhood `s` of the origin in a normed space `E`, the dual norms\nof all elements of the polar `polar ğ•œ s` are bounded by a constant. -/\ntheorem isBounded_polar_of_mem_nhds_zero {s : Set E} (s_nhd : s âˆˆ ğ“ (0 : E)) :\n    IsBounded (polar ğ•œ s) := by\n  obtain âŸ¨a, haâŸ© : âˆƒ a : ğ•œ, 1 < â€–aâ€– := NormedField.exists_one_lt_norm ğ•œ\n  obtain âŸ¨r, r_pos, r_ballâŸ© : âˆƒ r : â„, 0 < r âˆ§ ball 0 r âŠ† s := Metric.mem_nhds_iff.1 s_nhd\n  exact isBounded_closedBall.subset\n    (((dualPairing ğ•œ E).flip.polar_antitone r_ball).trans <|\n      polar_ball_subset_closedBall_div ha r_pos)\n\n"}
{"name":"NormedSpace.polar_empty","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (NormedSpace.polar ğ•œ EmptyCollection.emptyCollection) Set.univ","decl":"@[simp]\ntheorem polar_empty : polar ğ•œ (âˆ… : Set E) = Set.univ :=\n  LinearMap.polar_empty _\n\n"}
{"name":"NormedSpace.polar_singleton","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\na : E\nâŠ¢ Eq (NormedSpace.polar ğ•œ (Singleton.singleton a)) (setOf fun x => LE.le (Norm.norm (x a)) 1)","decl":"@[simp]\ntheorem polar_singleton {a : E} : polar ğ•œ {a} = { x | â€–x aâ€– â‰¤ 1 } := by\n  simp only [polar, LinearMap.polar_singleton, LinearMap.flip_apply, dualPairing_apply]\n\n"}
{"name":"NormedSpace.mem_polar_singleton","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\na : E\ny : NormedSpace.Dual ğ•œ E\nâŠ¢ Iff (Membership.mem (NormedSpace.polar ğ•œ (Singleton.singleton a)) y) (LE.le (Norm.norm (y a)) 1)","decl":"theorem mem_polar_singleton {a : E} (y : Dual ğ•œ E) : y âˆˆ polar ğ•œ {a} â†” â€–y aâ€– â‰¤ 1 := by\n  simp only [polar_singleton, mem_setOf_eq]\n\n"}
{"name":"NormedSpace.polar_zero","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (NormedSpace.polar ğ•œ (Singleton.singleton 0)) Set.univ","decl":"theorem polar_zero : polar ğ•œ ({0} : Set E) = Set.univ :=\n  LinearMap.polar_zero _\n\n"}
{"name":"NormedSpace.sInter_polar_eq_closedBall","module":"Mathlib.Analysis.Normed.Module.Dual","initialProofState":"ğ•œ : Type u_3\nE : Type u_4\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq (Set.image (NormedSpace.polar ğ•œ) (setOf fun F => And F.Finite (HasSubset.Subset F (Metric.closedBall 0 (Inv.inv r))))).sInter (Metric.closedBall 0 r)","decl":"theorem sInter_polar_eq_closedBall {ğ•œ E : Type*} [RCLike ğ•œ] [NormedAddCommGroup E] [NormedSpace ğ•œ E]\n    {r : â„} (hr : 0 < r) :\n    â‹‚â‚€ (polar ğ•œ '' { F | F.Finite âˆ§ F âŠ† closedBall (0 : E) râ»Â¹ }) = closedBall 0 r := by\n  conv_rhs => rw [â† inv_inv r]\n  rw [â† polar_closedBall (inv_pos_of_pos hr), polar,\n    (dualPairing ğ•œ E).flip.sInter_polar_finite_subset_eq_polar (closedBall (0 : E) râ»Â¹)]\n\n"}
