{"name":"MeasureTheory.Memℒp.integrable_sq","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nh : MeasureTheory.Memℒp f 2 μ\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (f x) 2) μ","decl":"theorem Memℒp.integrable_sq {f : α → ℝ} (h : Memℒp f 2 μ) : Integrable (fun x => f x ^ 2) μ := by\n  simpa [← memℒp_one_iff_integrable] using h.norm_rpow two_ne_zero ENNReal.ofNat_ne_top\n\n"}
{"name":"MeasureTheory.memℒp_two_iff_integrable_sq_norm","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nF : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (MeasureTheory.Memℒp f 2 μ) (MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) 2) μ)","decl":"theorem memℒp_two_iff_integrable_sq_norm {f : α → F} (hf : AEStronglyMeasurable f μ) :\n    Memℒp f 2 μ ↔ Integrable (fun x => ‖f x‖ ^ 2) μ := by\n  rw [← memℒp_one_iff_integrable]\n  convert (memℒp_norm_rpow_iff hf two_ne_zero ENNReal.ofNat_ne_top).symm\n  · simp\n  · rw [div_eq_mul_inv, ENNReal.mul_inv_cancel two_ne_zero ENNReal.ofNat_ne_top]\n\n"}
{"name":"MeasureTheory.memℒp_two_iff_integrable_sq","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (MeasureTheory.Memℒp f 2 μ) (MeasureTheory.Integrable (fun x => HPow.hPow (f x) 2) μ)","decl":"theorem memℒp_two_iff_integrable_sq {f : α → ℝ} (hf : AEStronglyMeasurable f μ) :\n    Memℒp f 2 μ ↔ Integrable (fun x => f x ^ 2) μ := by\n  convert memℒp_two_iff_integrable_sq_norm hf using 3\n  simp\n\n"}
{"name":"MeasureTheory.Memℒp.const_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nc : E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun a => Inner.inner c (f a)) p μ","decl":"theorem Memℒp.const_inner (c : E) {f : α → E} (hf : Memℒp f p μ) : Memℒp (fun a => ⟪c, f a⟫) p μ :=\n  hf.of_le_mul (AEStronglyMeasurable.inner aestronglyMeasurable_const hf.1)\n    (Eventually.of_forall fun _ => norm_inner_le_norm _ _)\n\n"}
{"name":"MeasureTheory.Memℒp.inner_const","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\nc : E\n⊢ MeasureTheory.Memℒp (fun a => Inner.inner (f a) c) p μ","decl":"theorem Memℒp.inner_const {f : α → E} (hf : Memℒp f p μ) (c : E) : Memℒp (fun a => ⟪f a, c⟫) p μ :=\n  hf.of_le_mul (c := ‖c‖) (AEStronglyMeasurable.inner hf.1 aestronglyMeasurable_const)\n    (Eventually.of_forall fun x => by rw [mul_comm]; exact norm_inner_le_norm _ _)\n\n"}
{"name":"MeasureTheory.Integrable.const_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf : α → E\nc : E\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => Inner.inner c (f x)) μ","decl":"@[fun_prop]\ntheorem Integrable.const_inner (c : E) (hf : Integrable f μ) :\n    Integrable (fun x => ⟪c, f x⟫) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢; exact hf.const_inner c\n\n"}
{"name":"MeasureTheory.Integrable.inner_const","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf : α → E\nhf : MeasureTheory.Integrable f μ\nc : E\n⊢ MeasureTheory.Integrable (fun x => Inner.inner (f x) c) μ","decl":"@[fun_prop]\ntheorem Integrable.inner_const (hf : Integrable f μ) (c : E) :\n    Integrable (fun x => ⟪f x, c⟫) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢; exact hf.inner_const c\n\n"}
{"name":"integral_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\ninst✝ : NormedSpace Real E\nf : α → E\nhf : MeasureTheory.Integrable f μ\nc : E\n⊢ Eq (MeasureTheory.integral μ fun x => Inner.inner c (f x)) (Inner.inner c (MeasureTheory.integral μ fun x => f x))","decl":"theorem _root_.integral_inner {f : α → E} (hf : Integrable f μ) (c : E) :\n    ∫ x, ⟪c, f x⟫ ∂μ = ⟪c, ∫ x, f x ∂μ⟫ :=\n  ((innerSL 𝕜 c).restrictScalars ℝ).integral_comp_comm hf\n\n"}
{"name":"integral_eq_zero_of_forall_integral_inner_eq_zero","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\n𝕜 : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : CompleteSpace E\ninst✝ : NormedSpace Real E\nf : α → E\nhf : MeasureTheory.Integrable f μ\nhf_int : ∀ (c : E), Eq (MeasureTheory.integral μ fun x => Inner.inner c (f x)) 0\n⊢ Eq (MeasureTheory.integral μ fun x => f x) 0","decl":"theorem _root_.integral_eq_zero_of_forall_integral_inner_eq_zero (f : α → E) (hf : Integrable f μ)\n    (hf_int : ∀ c : E, ∫ x, ⟪c, f x⟫ ∂μ = 0) : ∫ x, f x ∂μ = 0 := by\n  specialize hf_int (∫ x, f x ∂μ); rwa [integral_inner hf, inner_self_eq_zero] at hf_int\n\n"}
{"name":"MeasureTheory.L2.eLpNorm_rpow_two_norm_lt_top","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nF : Type u_3\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F 2 μ) x\n⊢ LT.lt (MeasureTheory.eLpNorm (fun x => HPow.hPow (Norm.norm (↑↑f x)) 2) 1 μ) Top.top","decl":"theorem eLpNorm_rpow_two_norm_lt_top (f : Lp F 2 μ) :\n    eLpNorm (fun x => ‖f x‖ ^ (2 : ℝ)) 1 μ < ∞ := by\n  have h_two : ENNReal.ofReal (2 : ℝ) = 2 := by simp [zero_le_one]\n  rw [eLpNorm_norm_rpow f zero_lt_two, one_mul, h_two]\n  exact ENNReal.rpow_lt_top_of_nonneg zero_le_two (Lp.eLpNorm_ne_top f)\n\n"}
{"name":"MeasureTheory.L2.eLpNorm_inner_lt_top","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ LT.lt (MeasureTheory.eLpNorm (fun x => Inner.inner (↑↑f x) (↑↑g x)) 1 μ) Top.top","decl":"theorem eLpNorm_inner_lt_top (f g : α →₂[μ] E) : eLpNorm (fun x : α => ⟪f x, g x⟫) 1 μ < ∞ := by\n  have h : ∀ x, ‖⟪f x, g x⟫‖ ≤ ‖‖f x‖ ^ (2 : ℝ) + ‖g x‖ ^ (2 : ℝ)‖ := by\n    intro x\n    rw [← @Nat.cast_two ℝ, Real.rpow_natCast, Real.rpow_natCast]\n    calc\n      ‖⟪f x, g x⟫‖ ≤ ‖f x‖ * ‖g x‖ := norm_inner_le_norm _ _\n      _ ≤ 2 * ‖f x‖ * ‖g x‖ :=\n        (mul_le_mul_of_nonneg_right (le_mul_of_one_le_left (norm_nonneg _) one_le_two)\n          (norm_nonneg _))\n      -- TODO(kmill): the type ascription is getting around an elaboration error\n      _ ≤ ‖(‖f x‖ ^ 2 + ‖g x‖ ^ 2 : ℝ)‖ := (two_mul_le_add_sq _ _).trans (le_abs_self _)\n  refine (eLpNorm_mono_ae (ae_of_all _ h)).trans_lt ((eLpNorm_add_le ?_ ?_ le_rfl).trans_lt ?_)\n  · exact ((Lp.aestronglyMeasurable f).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  · exact ((Lp.aestronglyMeasurable g).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  rw [ENNReal.add_lt_top]\n  exact ⟨eLpNorm_rpow_two_norm_lt_top f, eLpNorm_rpow_two_norm_lt_top g⟩\n\n"}
{"name":"MeasureTheory.L2.inner_def","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ Eq (Inner.inner f g) (MeasureTheory.integral μ fun a => Inner.inner (↑↑f a) (↑↑g a))","decl":"theorem inner_def (f g : α →₂[μ] E) : ⟪f, g⟫ = ∫ a : α, ⟪f a, g a⟫ ∂μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.L2.integral_inner_eq_sq_eLpNorm","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ Eq (MeasureTheory.integral μ fun a => Inner.inner (↑↑f a) (↑↑f a)) ↑(MeasureTheory.lintegral μ fun a => HPow.hPow (↑(NNNorm.nnnorm (↑↑f a))) 2).toReal","decl":"theorem integral_inner_eq_sq_eLpNorm (f : α →₂[μ] E) :\n    ∫ a, ⟪f a, f a⟫ ∂μ = ENNReal.toReal (∫⁻ a, (‖f a‖₊ : ℝ≥0∞) ^ (2 : ℝ) ∂μ) := by\n  simp_rw [inner_self_eq_norm_sq_to_K]\n  norm_cast\n  rw [integral_eq_lintegral_of_nonneg_ae]\n  rotate_left\n  · exact Filter.Eventually.of_forall fun x => sq_nonneg _\n  · exact ((Lp.aestronglyMeasurable f).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  congr\n  ext1 x\n  have h_two : (2 : ℝ) = ((2 : ℕ) : ℝ) := by simp\n  rw [← Real.rpow_natCast _ 2, ← h_two, ←\n    ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) zero_le_two, ofReal_norm_eq_enorm]\n  norm_cast\n\n"}
{"name":"MeasureTheory.L2.mem_L1_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ Membership.mem (MeasureTheory.Lp 𝕜 1 μ) (MeasureTheory.AEEqFun.mk (fun x => Inner.inner (↑↑f x) (↑↑g x)) ⋯)","decl":"theorem mem_L1_inner (f g : α →₂[μ] E) :\n    AEEqFun.mk (fun x => ⟪f x, g x⟫)\n        ((Lp.aestronglyMeasurable f).inner (Lp.aestronglyMeasurable g)) ∈\n      Lp 𝕜 1 μ := by\n  simp_rw [mem_Lp_iff_eLpNorm_lt_top, eLpNorm_aeeqFun]; exact eLpNorm_inner_lt_top f g\n\n"}
{"name":"MeasureTheory.L2.integrable_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ MeasureTheory.Integrable (fun x => Inner.inner (↑↑f x) (↑↑g x)) μ","decl":"theorem integrable_inner (f g : α →₂[μ] E) : Integrable (fun x : α => ⟪f x, g x⟫) μ :=\n  (integrable_congr\n        (AEEqFun.coeFn_mk (fun x => ⟪f x, g x⟫)\n          ((Lp.aestronglyMeasurable f).inner (Lp.aestronglyMeasurable g)))).mp\n    (AEEqFun.integrable_iff_mem_L1.mpr (mem_L1_inner f g))\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_eq_setIntegral_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝³ : RCLike 𝕜\ninst✝² : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace 𝕜 E\ns : Set α\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\nhs : MeasurableSet s\nc : E\nhμs : Ne (μ s) Top.top\n⊢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hμs c) f) (MeasureTheory.integral (μ.restrict s) fun x => Inner.inner c (↑↑f x))","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hμs c` and `f` is\nequal to the integral of the inner product over `s`: `∫ x in s, ⟪c, f x⟫ ∂μ`. -/\ntheorem inner_indicatorConstLp_eq_setIntegral_inner (f : Lp E 2 μ) (hs : MeasurableSet s) (c : E)\n    (hμs : μ s ≠ ∞) : (⟪indicatorConstLp 2 hs hμs c, f⟫ : 𝕜) = ∫ x in s, ⟪c, f x⟫ ∂μ := by\n  rw [inner_def, ← integral_add_compl hs (L2.integrable_inner _ f)]\n  have h_left : (∫ x in s, ⟪(indicatorConstLp 2 hs hμs c) x, f x⟫ ∂μ) = ∫ x in s, ⟪c, f x⟫ ∂μ := by\n    suffices h_ae_eq : ∀ᵐ x ∂μ, x ∈ s → ⟪indicatorConstLp 2 hs hμs c x, f x⟫ = ⟪c, f x⟫ from\n      setIntegral_congr_ae hs h_ae_eq\n    have h_indicator : ∀ᵐ x : α ∂μ, x ∈ s → indicatorConstLp 2 hs hμs c x = c :=\n      indicatorConstLp_coeFn_mem\n    refine h_indicator.mono fun x hx hxs => ?_\n    congr\n    exact hx hxs\n  have h_right : (∫ x in sᶜ, ⟪(indicatorConstLp 2 hs hμs c) x, f x⟫ ∂μ) = 0 := by\n    suffices h_ae_eq : ∀ᵐ x ∂μ, x ∉ s → ⟪indicatorConstLp 2 hs hμs c x, f x⟫ = 0 by\n      simp_rw [← Set.mem_compl_iff] at h_ae_eq\n      suffices h_int_zero :\n          (∫ x in sᶜ, inner (indicatorConstLp 2 hs hμs c x) (f x) ∂μ) = ∫ _ in sᶜ, (0 : 𝕜) ∂μ by\n        rw [h_int_zero]\n        simp\n      exact setIntegral_congr_ae hs.compl h_ae_eq\n    have h_indicator : ∀ᵐ x : α ∂μ, x ∉ s → indicatorConstLp 2 hs hμs c x = 0 :=\n      indicatorConstLp_coeFn_nmem\n    refine h_indicator.mono fun x hx hxs => ?_\n    rw [hx hxs]\n    exact inner_zero_left _\n  rw [h_left, h_right, add_zero]\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_eq_inner_setIntegral","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\nE : Type u_2\n𝕜 : Type u_4\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ns : Set α\ninst✝¹ : CompleteSpace E\ninst✝ : NormedSpace Real E\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nc : E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 μ) x\n⊢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hμs c) f) (Inner.inner c (MeasureTheory.integral (μ.restrict s) fun x => ↑↑f x))","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hμs c` and `f` is\nequal to the inner product of the constant `c` and the integral of `f` over `s`. -/\ntheorem inner_indicatorConstLp_eq_inner_setIntegral [CompleteSpace E] [NormedSpace ℝ E]\n    (hs : MeasurableSet s) (hμs : μ s ≠ ∞) (c : E) (f : Lp E 2 μ) :\n    (⟪indicatorConstLp 2 hs hμs c, f⟫ : 𝕜) = ⟪c, ∫ x in s, f x ∂μ⟫ := by\n  rw [← integral_inner (integrableOn_Lp_of_measure_ne_top f fact_one_le_two_ennreal.elim hμs),\n    L2.inner_indicatorConstLp_eq_setIntegral_inner]\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_one","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\n𝕜 : Type u_4\ninst✝¹ : RCLike 𝕜\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp 𝕜 2 μ) x\n⊢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hμs 1) f) (MeasureTheory.integral (μ.restrict s) fun x => ↑↑f x)","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hμs (1 : 𝕜)` and\na real or complex function `f` is equal to the integral of `f` over `s`. -/\ntheorem inner_indicatorConstLp_one (hs : MeasurableSet s) (hμs : μ s ≠ ∞) (f : Lp 𝕜 2 μ) :\n    ⟪indicatorConstLp 2 hs hμs (1 : 𝕜), f⟫ = ∫ x in s, f x ∂μ := by\n  rw [L2.inner_indicatorConstLp_eq_inner_setIntegral 𝕜 hs hμs (1 : 𝕜) f]; simp\n\n"}
{"name":"MeasureTheory.BoundedContinuousFunction.inner_toLp","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁴ : TopologicalSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : BorelSpace α\ninst✝¹ : RCLike 𝕜\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf g : BoundedContinuousFunction α 𝕜\n⊢ Eq (Inner.inner ((BoundedContinuousFunction.toLp 2 μ 𝕜) f) ((BoundedContinuousFunction.toLp 2 μ 𝕜) g)) (MeasureTheory.integral μ fun x => HMul.hMul ((starRingEnd 𝕜) (f x)) (g x))","decl":"/-- For bounded continuous functions `f`, `g` on a finite-measure topological space `α`, the L^2\ninner product is the integral of their pointwise inner product. -/\ntheorem BoundedContinuousFunction.inner_toLp (f g : α →ᵇ 𝕜) :\n    ⟪BoundedContinuousFunction.toLp (E := 𝕜) 2 μ 𝕜 f,\n        BoundedContinuousFunction.toLp (E := 𝕜) 2 μ 𝕜 g⟫ =\n      ∫ x, conj (f x) * g x ∂μ := by\n  apply integral_congr_ae\n  have hf_ae := f.coeFn_toLp 2 μ 𝕜\n  have hg_ae := g.coeFn_toLp 2 μ 𝕜\n  filter_upwards [hf_ae, hg_ae] with _ hf hg\n  rw [hf, hg]\n  simp\n\n"}
{"name":"MeasureTheory.ContinuousMap.inner_toLp","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"α : Type u_1\n𝕜 : Type u_2\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : MeasurableSpace α\ninst✝³ : BorelSpace α\ninst✝² : RCLike 𝕜\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : CompactSpace α\nf g : ContinuousMap α 𝕜\n⊢ Eq (Inner.inner ((ContinuousMap.toLp 2 μ 𝕜) f) ((ContinuousMap.toLp 2 μ 𝕜) g)) (MeasureTheory.integral μ fun x => HMul.hMul ((starRingEnd 𝕜) (f x)) (g x))","decl":"/-- For continuous functions `f`, `g` on a compact, finite-measure topological space `α`, the L^2\ninner product is the integral of their pointwise inner product. -/\ntheorem ContinuousMap.inner_toLp (f g : C(α, 𝕜)) :\n    ⟪ContinuousMap.toLp (E := 𝕜) 2 μ 𝕜 f, ContinuousMap.toLp (E := 𝕜) 2 μ 𝕜 g⟫ =\n      ∫ x, conj (f x) * g x ∂μ := by\n  apply integral_congr_ae\n  -- Porting note: added explicitly passed arguments\n  have hf_ae := f.coeFn_toLp (p := 2) (𝕜 := 𝕜) μ\n  have hg_ae := g.coeFn_toLp (p := 2) (𝕜 := 𝕜) μ\n  filter_upwards [hf_ae, hg_ae] with _ hf hg\n  rw [hf, hg]\n  simp\n\n"}
