{"name":"MeasureTheory.Memâ„’p.integrable_sq","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh : MeasureTheory.Memâ„’p f 2 Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => HPow.hPow (f x) 2) Î¼","decl":"theorem Memâ„’p.integrable_sq {f : Î± â†’ â„} (h : Memâ„’p f 2 Î¼) : Integrable (fun x => f x ^ 2) Î¼ := by\n  simpa [â† memâ„’p_one_iff_integrable] using h.norm_rpow two_ne_zero ENNReal.ofNat_ne_top\n\n"}
{"name":"MeasureTheory.memâ„’p_two_iff_integrable_sq_norm","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nF : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup F\nf : Î± â†’ F\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Iff (MeasureTheory.Memâ„’p f 2 Î¼) (MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) 2) Î¼)","decl":"theorem memâ„’p_two_iff_integrable_sq_norm {f : Î± â†’ F} (hf : AEStronglyMeasurable f Î¼) :\n    Memâ„’p f 2 Î¼ â†” Integrable (fun x => â€–f xâ€– ^ 2) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable]\n  convert (memâ„’p_norm_rpow_iff hf two_ne_zero ENNReal.ofNat_ne_top).symm\n  Â· simp\n  Â· rw [div_eq_mul_inv, ENNReal.mul_inv_cancel two_ne_zero ENNReal.ofNat_ne_top]\n\n"}
{"name":"MeasureTheory.memâ„’p_two_iff_integrable_sq","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Iff (MeasureTheory.Memâ„’p f 2 Î¼) (MeasureTheory.Integrable (fun x => HPow.hPow (f x) 2) Î¼)","decl":"theorem memâ„’p_two_iff_integrable_sq {f : Î± â†’ â„} (hf : AEStronglyMeasurable f Î¼) :\n    Memâ„’p f 2 Î¼ â†” Integrable (fun x => f x ^ 2) Î¼ := by\n  convert memâ„’p_two_iff_integrable_sq_norm hf using 3\n  simp\n\n"}
{"name":"MeasureTheory.Memâ„’p.const_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\np : ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nc : E\nf : Î± â†’ E\nhf : MeasureTheory.Memâ„’p f p Î¼\nâŠ¢ MeasureTheory.Memâ„’p (fun a => Inner.inner c (f a)) p Î¼","decl":"theorem Memâ„’p.const_inner (c : E) {f : Î± â†’ E} (hf : Memâ„’p f p Î¼) : Memâ„’p (fun a => âŸªc, f aâŸ«) p Î¼ :=\n  hf.of_le_mul (AEStronglyMeasurable.inner aestronglyMeasurable_const hf.1)\n    (Eventually.of_forall fun _ => norm_inner_le_norm _ _)\n\n"}
{"name":"MeasureTheory.Memâ„’p.inner_const","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\np : ENNReal\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf : Î± â†’ E\nhf : MeasureTheory.Memâ„’p f p Î¼\nc : E\nâŠ¢ MeasureTheory.Memâ„’p (fun a => Inner.inner (f a) c) p Î¼","decl":"theorem Memâ„’p.inner_const {f : Î± â†’ E} (hf : Memâ„’p f p Î¼) (c : E) : Memâ„’p (fun a => âŸªf a, câŸ«) p Î¼ :=\n  hf.of_le_mul (c := â€–câ€–) (AEStronglyMeasurable.inner hf.1 aestronglyMeasurable_const)\n    (Eventually.of_forall fun x => by rw [mul_comm]; exact norm_inner_le_norm _ _)\n\n"}
{"name":"MeasureTheory.Integrable.const_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf : Î± â†’ E\nc : E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => Inner.inner c (f x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.const_inner (c : E) (hf : Integrable f Î¼) :\n    Integrable (fun x => âŸªc, f xâŸ«) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢; exact hf.const_inner c\n\n"}
{"name":"MeasureTheory.Integrable.inner_const","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nc : E\nâŠ¢ MeasureTheory.Integrable (fun x => Inner.inner (f x) c) Î¼","decl":"@[fun_prop]\ntheorem Integrable.inner_const (hf : Integrable f Î¼) (c : E) :\n    Integrable (fun x => âŸªf x, câŸ«) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢; exact hf.inner_const c\n\n"}
{"name":"integral_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nc : E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => Inner.inner c (f x)) (Inner.inner c (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem _root_.integral_inner {f : Î± â†’ E} (hf : Integrable f Î¼) (c : E) :\n    âˆ« x, âŸªc, f xâŸ« âˆ‚Î¼ = âŸªc, âˆ« x, f x âˆ‚Î¼âŸ« :=\n  ((innerSL ğ•œ c).restrictScalars â„).integral_comp_comm hf\n\n"}
{"name":"integral_eq_zero_of_forall_integral_inner_eq_zero","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_2\nğ•œ : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhf_int : âˆ€ (c : E), Eq (MeasureTheory.integral Î¼ fun x => Inner.inner c (f x)) 0\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) 0","decl":"theorem _root_.integral_eq_zero_of_forall_integral_inner_eq_zero (f : Î± â†’ E) (hf : Integrable f Î¼)\n    (hf_int : âˆ€ c : E, âˆ« x, âŸªc, f xâŸ« âˆ‚Î¼ = 0) : âˆ« x, f x âˆ‚Î¼ = 0 := by\n  specialize hf_int (âˆ« x, f x âˆ‚Î¼); rwa [integral_inner hf, inner_self_eq_zero] at hf_int\n\n"}
{"name":"MeasureTheory.L2.eLpNorm_rpow_two_norm_lt_top","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup F\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F 2 Î¼) x\nâŠ¢ LT.lt (MeasureTheory.eLpNorm (fun x => HPow.hPow (Norm.norm (â†‘â†‘f x)) 2) 1 Î¼) Top.top","decl":"theorem eLpNorm_rpow_two_norm_lt_top (f : Lp F 2 Î¼) :\n    eLpNorm (fun x => â€–f xâ€– ^ (2 : â„)) 1 Î¼ < âˆ := by\n  have h_two : ENNReal.ofReal (2 : â„) = 2 := by simp [zero_le_one]\n  rw [eLpNorm_norm_rpow f zero_lt_two, one_mul, h_two]\n  exact ENNReal.rpow_lt_top_of_nonneg zero_le_two (Lp.eLpNorm_ne_top f)\n\n"}
{"name":"MeasureTheory.L2.eLpNorm_inner_lt_top","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ LT.lt (MeasureTheory.eLpNorm (fun x => Inner.inner (â†‘â†‘f x) (â†‘â†‘g x)) 1 Î¼) Top.top","decl":"theorem eLpNorm_inner_lt_top (f g : Î± â†’â‚‚[Î¼] E) : eLpNorm (fun x : Î± => âŸªf x, g xâŸ«) 1 Î¼ < âˆ := by\n  have h : âˆ€ x, â€–âŸªf x, g xâŸ«â€– â‰¤ â€–â€–f xâ€– ^ (2 : â„) + â€–g xâ€– ^ (2 : â„)â€– := by\n    intro x\n    rw [â† @Nat.cast_two â„, Real.rpow_natCast, Real.rpow_natCast]\n    calc\n      â€–âŸªf x, g xâŸ«â€– â‰¤ â€–f xâ€– * â€–g xâ€– := norm_inner_le_norm _ _\n      _ â‰¤ 2 * â€–f xâ€– * â€–g xâ€– :=\n        (mul_le_mul_of_nonneg_right (le_mul_of_one_le_left (norm_nonneg _) one_le_two)\n          (norm_nonneg _))\n      -- TODO(kmill): the type ascription is getting around an elaboration error\n      _ â‰¤ â€–(â€–f xâ€– ^ 2 + â€–g xâ€– ^ 2 : â„)â€– := (two_mul_le_add_sq _ _).trans (le_abs_self _)\n  refine (eLpNorm_mono_ae (ae_of_all _ h)).trans_lt ((eLpNorm_add_le ?_ ?_ le_rfl).trans_lt ?_)\n  Â· exact ((Lp.aestronglyMeasurable f).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  Â· exact ((Lp.aestronglyMeasurable g).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  rw [ENNReal.add_lt_top]\n  exact âŸ¨eLpNorm_rpow_two_norm_lt_top f, eLpNorm_rpow_two_norm_lt_top gâŸ©\n\n"}
{"name":"MeasureTheory.L2.inner_def","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ Eq (Inner.inner f g) (MeasureTheory.integral Î¼ fun a => Inner.inner (â†‘â†‘f a) (â†‘â†‘g a))","decl":"theorem inner_def (f g : Î± â†’â‚‚[Î¼] E) : âŸªf, gâŸ« = âˆ« a : Î±, âŸªf a, g aâŸ« âˆ‚Î¼ :=\n  rfl\n\n"}
{"name":"MeasureTheory.L2.integral_inner_eq_sq_eLpNorm","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => Inner.inner (â†‘â†‘f a) (â†‘â†‘f a)) â†‘(MeasureTheory.lintegral Î¼ fun a => HPow.hPow (â†‘(NNNorm.nnnorm (â†‘â†‘f a))) 2).toReal","decl":"theorem integral_inner_eq_sq_eLpNorm (f : Î± â†’â‚‚[Î¼] E) :\n    âˆ« a, âŸªf a, f aâŸ« âˆ‚Î¼ = ENNReal.toReal (âˆ«â» a, (â€–f aâ€–â‚Š : â„â‰¥0âˆ) ^ (2 : â„) âˆ‚Î¼) := by\n  simp_rw [inner_self_eq_norm_sq_to_K]\n  norm_cast\n  rw [integral_eq_lintegral_of_nonneg_ae]\n  rotate_left\n  Â· exact Filter.Eventually.of_forall fun x => sq_nonneg _\n  Â· exact ((Lp.aestronglyMeasurable f).norm.aemeasurable.pow_const _).aestronglyMeasurable\n  congr\n  ext1 x\n  have h_two : (2 : â„) = ((2 : â„•) : â„) := by simp\n  rw [â† Real.rpow_natCast _ 2, â† h_two, â†\n    ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) zero_le_two, ofReal_norm_eq_enorm]\n  norm_cast\n\n"}
{"name":"MeasureTheory.L2.mem_L1_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ Membership.mem (MeasureTheory.Lp ğ•œ 1 Î¼) (MeasureTheory.AEEqFun.mk (fun x => Inner.inner (â†‘â†‘f x) (â†‘â†‘g x)) â‹¯)","decl":"theorem mem_L1_inner (f g : Î± â†’â‚‚[Î¼] E) :\n    AEEqFun.mk (fun x => âŸªf x, g xâŸ«)\n        ((Lp.aestronglyMeasurable f).inner (Lp.aestronglyMeasurable g)) âˆˆ\n      Lp ğ•œ 1 Î¼ := by\n  simp_rw [mem_Lp_iff_eLpNorm_lt_top, eLpNorm_aeeqFun]; exact eLpNorm_inner_lt_top f g\n\n"}
{"name":"MeasureTheory.L2.integrable_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ MeasureTheory.Integrable (fun x => Inner.inner (â†‘â†‘f x) (â†‘â†‘g x)) Î¼","decl":"theorem integrable_inner (f g : Î± â†’â‚‚[Î¼] E) : Integrable (fun x : Î± => âŸªf x, g xâŸ«) Î¼ :=\n  (integrable_congr\n        (AEEqFun.coeFn_mk (fun x => âŸªf x, g xâŸ«)\n          ((Lp.aestronglyMeasurable f).inner (Lp.aestronglyMeasurable g)))).mp\n    (AEEqFun.integrable_iff_mem_L1.mpr (mem_L1_inner f g))\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_eq_setIntegral_inner","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : InnerProductSpace ğ•œ E\ns : Set Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nhs : MeasurableSet s\nc : E\nhÎ¼s : Ne (Î¼ s) Top.top\nâŠ¢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hÎ¼s c) f) (MeasureTheory.integral (Î¼.restrict s) fun x => Inner.inner c (â†‘â†‘f x))","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hÎ¼s c` and `f` is\nequal to the integral of the inner product over `s`: `âˆ« x in s, âŸªc, f xâŸ« âˆ‚Î¼`. -/\ntheorem inner_indicatorConstLp_eq_setIntegral_inner (f : Lp E 2 Î¼) (hs : MeasurableSet s) (c : E)\n    (hÎ¼s : Î¼ s â‰  âˆ) : (âŸªindicatorConstLp 2 hs hÎ¼s c, fâŸ« : ğ•œ) = âˆ« x in s, âŸªc, f xâŸ« âˆ‚Î¼ := by\n  rw [inner_def, â† integral_add_compl hs (L2.integrable_inner _ f)]\n  have h_left : (âˆ« x in s, âŸª(indicatorConstLp 2 hs hÎ¼s c) x, f xâŸ« âˆ‚Î¼) = âˆ« x in s, âŸªc, f xâŸ« âˆ‚Î¼ := by\n    suffices h_ae_eq : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ âŸªindicatorConstLp 2 hs hÎ¼s c x, f xâŸ« = âŸªc, f xâŸ« from\n      setIntegral_congr_ae hs h_ae_eq\n    have h_indicator : âˆ€áµ x : Î± âˆ‚Î¼, x âˆˆ s â†’ indicatorConstLp 2 hs hÎ¼s c x = c :=\n      indicatorConstLp_coeFn_mem\n    refine h_indicator.mono fun x hx hxs => ?_\n    congr\n    exact hx hxs\n  have h_right : (âˆ« x in sá¶œ, âŸª(indicatorConstLp 2 hs hÎ¼s c) x, f xâŸ« âˆ‚Î¼) = 0 := by\n    suffices h_ae_eq : âˆ€áµ x âˆ‚Î¼, x âˆ‰ s â†’ âŸªindicatorConstLp 2 hs hÎ¼s c x, f xâŸ« = 0 by\n      simp_rw [â† Set.mem_compl_iff] at h_ae_eq\n      suffices h_int_zero :\n          (âˆ« x in sá¶œ, inner (indicatorConstLp 2 hs hÎ¼s c x) (f x) âˆ‚Î¼) = âˆ« _ in sá¶œ, (0 : ğ•œ) âˆ‚Î¼ by\n        rw [h_int_zero]\n        simp\n      exact setIntegral_congr_ae hs.compl h_ae_eq\n    have h_indicator : âˆ€áµ x : Î± âˆ‚Î¼, x âˆ‰ s â†’ indicatorConstLp 2 hs hÎ¼s c x = 0 :=\n      indicatorConstLp_coeFn_nmem\n    refine h_indicator.mono fun x hx hxs => ?_\n    rw [hx hxs]\n    exact inner_zero_left _\n  rw [h_left, h_right, add_zero]\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_eq_inner_setIntegral","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ns : Set Î±\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nc : E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 2 Î¼) x\nâŠ¢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hÎ¼s c) f) (Inner.inner c (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x))","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hÎ¼s c` and `f` is\nequal to the inner product of the constant `c` and the integral of `f` over `s`. -/\ntheorem inner_indicatorConstLp_eq_inner_setIntegral [CompleteSpace E] [NormedSpace â„ E]\n    (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ) (c : E) (f : Lp E 2 Î¼) :\n    (âŸªindicatorConstLp 2 hs hÎ¼s c, fâŸ« : ğ•œ) = âŸªc, âˆ« x in s, f x âˆ‚Î¼âŸ« := by\n  rw [â† integral_inner (integrableOn_Lp_of_measure_ne_top f fact_one_le_two_ennreal.elim hÎ¼s),\n    L2.inner_indicatorConstLp_eq_setIntegral_inner]\n\n"}
{"name":"MeasureTheory.L2.inner_indicatorConstLp_one","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nğ•œ : Type u_4\ninstâœÂ¹ : RCLike ğ•œ\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp ğ•œ 2 Î¼) x\nâŠ¢ Eq (Inner.inner (MeasureTheory.indicatorConstLp 2 hs hÎ¼s 1) f) (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x)","decl":"/-- The inner product in `L2` of the indicator of a set `indicatorConstLp 2 hs hÎ¼s (1 : ğ•œ)` and\na real or complex function `f` is equal to the integral of `f` over `s`. -/\ntheorem inner_indicatorConstLp_one (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ) (f : Lp ğ•œ 2 Î¼) :\n    âŸªindicatorConstLp 2 hs hÎ¼s (1 : ğ•œ), fâŸ« = âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [L2.inner_indicatorConstLp_eq_inner_setIntegral ğ•œ hs hÎ¼s (1 : ğ•œ) f]; simp\n\n"}
{"name":"MeasureTheory.BoundedContinuousFunction.inner_toLp","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : MeasurableSpace Î±\ninstâœÂ² : BorelSpace Î±\ninstâœÂ¹ : RCLike ğ•œ\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf g : BoundedContinuousFunction Î± ğ•œ\nâŠ¢ Eq (Inner.inner ((BoundedContinuousFunction.toLp 2 Î¼ ğ•œ) f) ((BoundedContinuousFunction.toLp 2 Î¼ ğ•œ) g)) (MeasureTheory.integral Î¼ fun x => HMul.hMul ((starRingEnd ğ•œ) (f x)) (g x))","decl":"/-- For bounded continuous functions `f`, `g` on a finite-measure topological space `Î±`, the L^2\ninner product is the integral of their pointwise inner product. -/\ntheorem BoundedContinuousFunction.inner_toLp (f g : Î± â†’áµ‡ ğ•œ) :\n    âŸªBoundedContinuousFunction.toLp (E := ğ•œ) 2 Î¼ ğ•œ f,\n        BoundedContinuousFunction.toLp (E := ğ•œ) 2 Î¼ ğ•œ gâŸ« =\n      âˆ« x, conj (f x) * g x âˆ‚Î¼ := by\n  apply integral_congr_ae\n  have hf_ae := f.coeFn_toLp 2 Î¼ ğ•œ\n  have hg_ae := g.coeFn_toLp 2 Î¼ ğ•œ\n  filter_upwards [hf_ae, hg_ae] with _ hf hg\n  rw [hf, hg]\n  simp\n\n"}
{"name":"MeasureTheory.ContinuousMap.inner_toLp","module":"Mathlib.MeasureTheory.Function.L2Space","initialProofState":"Î± : Type u_1\nğ•œ : Type u_2\ninstâœâµ : TopologicalSpace Î±\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : RCLike ğ•œ\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasureTheory.IsFiniteMeasure Î¼\ninstâœ : CompactSpace Î±\nf g : ContinuousMap Î± ğ•œ\nâŠ¢ Eq (Inner.inner ((ContinuousMap.toLp 2 Î¼ ğ•œ) f) ((ContinuousMap.toLp 2 Î¼ ğ•œ) g)) (MeasureTheory.integral Î¼ fun x => HMul.hMul ((starRingEnd ğ•œ) (f x)) (g x))","decl":"/-- For continuous functions `f`, `g` on a compact, finite-measure topological space `Î±`, the L^2\ninner product is the integral of their pointwise inner product. -/\ntheorem ContinuousMap.inner_toLp (f g : C(Î±, ğ•œ)) :\n    âŸªContinuousMap.toLp (E := ğ•œ) 2 Î¼ ğ•œ f, ContinuousMap.toLp (E := ğ•œ) 2 Î¼ ğ•œ gâŸ« =\n      âˆ« x, conj (f x) * g x âˆ‚Î¼ := by\n  apply integral_congr_ae\n  -- Porting note: added explicitly passed arguments\n  have hf_ae := f.coeFn_toLp (p := 2) (ğ•œ := ğ•œ) Î¼\n  have hg_ae := g.coeFn_toLp (p := 2) (ğ•œ := ğ•œ) Î¼\n  filter_upwards [hf_ae, hg_ae] with _ hf hg\n  rw [hf, hg]\n  simp\n\n"}
