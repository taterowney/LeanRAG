{"name":"PresheafOfModules.instHasLimitModuleCatCarrierObjOppositeRingCatCompEvaluationRestrictScalarsHomMap","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\nX Y : Opposite C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.HasLimit (F.comp ((PresheafOfModules.evaluation R Y).comp (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f)))))","decl":"instance {X Y : Cᵒᵖ} (f : X ⟶ Y) :\n    HasLimit (F ⋙ evaluation R Y ⋙ ModuleCat.restrictScalars (R.map f).hom) := by\n  change HasLimit ((F ⋙ evaluation R Y) ⋙ ModuleCat.restrictScalars (R.map f).hom)\n  infer_instance\n\n"}
{"name":"PresheafOfModules.limitPresheafOfModules_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\nX : Opposite C\n⊢ Eq ((PresheafOfModules.limitPresheafOfModules F).obj X) (CategoryTheory.Limits.limit (F.comp (PresheafOfModules.evaluation R X)))","decl":"/-- Given `F : J ⥤ PresheafOfModules.{v} R`, this is the presheaf of modules obtained by\ntaking a limit in the category of modules over `R.obj X` for all `X`. -/\n@[simps]\nnoncomputable def limitPresheafOfModules : PresheafOfModules R where\n  obj X := limit (F ⋙ evaluation R X)\n  map {_ Y} f := limMap (whiskerLeft F (restriction R f)) ≫\n    (preservesLimitIso (ModuleCat.restrictScalars (R.map f).hom) (F ⋙ evaluation R Y)).inv\n  map_id X := by\n    dsimp\n    rw [← cancel_mono (preservesLimitIso _ _).hom, assoc, Iso.inv_hom_id, comp_id]\n    apply limit.hom_ext\n    intro j\n    dsimp\n    simp only [limMap_π, Functor.comp_obj, evaluation_obj, whiskerLeft_app,\n      restriction_app, assoc]\n    erw [preservesLimitIso_hom_π]\n    rw [← ModuleCat.restrictScalarsId'App_inv_naturality, map_id,\n      ModuleCat.restrictScalarsId'_inv_app]\n    dsimp\n  map_comp {X Y Z} f g := by\n    dsimp\n    rw [← cancel_mono (preservesLimitIso _ _).hom, assoc, assoc, assoc, assoc, Iso.inv_hom_id,\n      comp_id]\n    apply limit.hom_ext\n    intro j\n    simp only [Functor.comp_obj, evaluation_obj, limMap_π, whiskerLeft_app, restriction_app,\n      map_comp, ModuleCat.restrictScalarsComp'_inv_app, Functor.map_comp, assoc]\n    erw [preservesLimitIso_hom_π]\n    rw [← ModuleCat.restrictScalarsComp'App_inv_naturality]\n    dsimp\n    rw [← Functor.map_comp_assoc, ← Functor.map_comp_assoc, assoc,\n      preservesLimitIso_inv_π]\n    erw [limMap_π]\n    dsimp\n    simp only [Functor.map_comp, assoc, preservesLimitIso_inv_π_assoc]\n    erw [limMap_π_assoc]\n    dsimp\n\n"}
{"name":"PresheafOfModules.limitPresheafOfModules_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\nx✝ Y : Opposite C\nf : Quiver.Hom x✝ Y\n⊢ Eq ((PresheafOfModules.limitPresheafOfModules F).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap (CategoryTheory.whiskerLeft F (PresheafOfModules.restriction R f))) (CategoryTheory.preservesLimitIso (ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))) (F.comp (PresheafOfModules.evaluation R Y))).inv)","decl":"/-- Given `F : J ⥤ PresheafOfModules.{v} R`, this is the presheaf of modules obtained by\ntaking a limit in the category of modules over `R.obj X` for all `X`. -/\n@[simps]\nnoncomputable def limitPresheafOfModules : PresheafOfModules R where\n  obj X := limit (F ⋙ evaluation R X)\n  map {_ Y} f := limMap (whiskerLeft F (restriction R f)) ≫\n    (preservesLimitIso (ModuleCat.restrictScalars (R.map f).hom) (F ⋙ evaluation R Y)).inv\n  map_id X := by\n    dsimp\n    rw [← cancel_mono (preservesLimitIso _ _).hom, assoc, Iso.inv_hom_id, comp_id]\n    apply limit.hom_ext\n    intro j\n    dsimp\n    simp only [limMap_π, Functor.comp_obj, evaluation_obj, whiskerLeft_app,\n      restriction_app, assoc]\n    erw [preservesLimitIso_hom_π]\n    rw [← ModuleCat.restrictScalarsId'App_inv_naturality, map_id,\n      ModuleCat.restrictScalarsId'_inv_app]\n    dsimp\n  map_comp {X Y Z} f g := by\n    dsimp\n    rw [← cancel_mono (preservesLimitIso _ _).hom, assoc, assoc, assoc, assoc, Iso.inv_hom_id,\n      comp_id]\n    apply limit.hom_ext\n    intro j\n    simp only [Functor.comp_obj, evaluation_obj, limMap_π, whiskerLeft_app, restriction_app,\n      map_comp, ModuleCat.restrictScalarsComp'_inv_app, Functor.map_comp, assoc]\n    erw [preservesLimitIso_hom_π]\n    rw [← ModuleCat.restrictScalarsComp'App_inv_naturality]\n    dsimp\n    rw [← Functor.map_comp_assoc, ← Functor.map_comp_assoc, assoc,\n      preservesLimitIso_inv_π]\n    erw [limMap_π]\n    dsimp\n    simp only [Functor.map_comp, assoc, preservesLimitIso_inv_π_assoc]\n    erw [limMap_π_assoc]\n    dsimp\n\n"}
{"name":"PresheafOfModules.limitCone_pt","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\n⊢ Eq (PresheafOfModules.limitCone F).pt (PresheafOfModules.limitPresheafOfModules F)","decl":"/-- The (limit) cone for `F : J ⥤ PresheafOfModules.{v} R` that is constructed from the limit\nof `F ⋙ evaluation R X` for all `X`. -/\n@[simps]\nnoncomputable def limitCone : Cone F where\n  pt := limitPresheafOfModules F\n  π :=\n    { app := fun j ↦\n        { app := fun X ↦ limit.π (F ⋙ evaluation R X) j\n          naturality := fun {X Y} f ↦ by\n            dsimp\n            simp only [assoc, preservesLimitIso_inv_π]\n            apply limMap_π }\n      naturality := fun {j j'} f ↦ by\n        ext1 X\n        simpa using (limit.w (F ⋙ evaluation R X) f).symm }\n\n"}
{"name":"PresheafOfModules.limitCone_π_app_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\nj : J\nX : Opposite C\n⊢ Eq (((PresheafOfModules.limitCone F).π.app j).app X) (CategoryTheory.Limits.limit.π (F.comp (PresheafOfModules.evaluation R X)) j)","decl":"/-- The (limit) cone for `F : J ⥤ PresheafOfModules.{v} R` that is constructed from the limit\nof `F ⋙ evaluation R X` for all `X`. -/\n@[simps]\nnoncomputable def limitCone : Cone F where\n  pt := limitPresheafOfModules F\n  π :=\n    { app := fun j ↦\n        { app := fun X ↦ limit.π (F ⋙ evaluation R X) j\n          naturality := fun {X Y} f ↦ by\n            dsimp\n            simp only [assoc, preservesLimitIso_inv_π]\n            apply limMap_π }\n      naturality := fun {j j'} f ↦ by\n        ext1 X\n        simpa using (limit.w (F ⋙ evaluation R X) f).symm }\n\n"}
{"name":"PresheafOfModules.hasLimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance hasLimit : HasLimit F := ⟨_, isLimitLimitCone F⟩\n\n"}
{"name":"PresheafOfModules.evaluation_preservesLimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesLimit F (PresheafOfModules.evaluation R X)","decl":"noncomputable instance evaluation_preservesLimit (X : Cᵒᵖ) :\n    PreservesLimit F (evaluation R X) :=\n  preservesLimit_of_preserves_limit_cone (isLimitLimitCone F) (limit.isLimit _)\n\n"}
{"name":"PresheafOfModules.toPresheaf_preservesLimit","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} J\nF : CategoryTheory.Functor J (PresheafOfModules R)\ninst✝ : ∀ (X : Opposite C), Small.{v, max u₂ v} ↑((F.comp (PresheafOfModules.evaluation R X)).comp (CategoryTheory.forget (ModuleCat ↑(R.obj X)))).sections\n⊢ CategoryTheory.Limits.PreservesLimit F (PresheafOfModules.toPresheaf R)","decl":"noncomputable instance toPresheaf_preservesLimit :\n    PreservesLimit F (toPresheaf R) :=\n  preservesLimit_of_preserves_limit_cone (isLimitLimitCone F)\n    (Limits.evaluationJointlyReflectsLimits _\n      (fun X => isLimitOfPreserves (evaluation R X ⋙ forget₂ _ AddCommGrp)\n        (isLimitLimitCone F)))\n\n"}
{"name":"PresheafOfModules.hasLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (PresheafOfModules R)","decl":"instance hasLimitsOfShape : HasLimitsOfShape J (PresheafOfModules.{v} R) where\n\n"}
{"name":"PresheafOfModules.hasLimitsOfSize","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v, v, max u₁ v, max (max (max (v + 1) u) u₁) v₁} (PresheafOfModules R)","decl":"instance hasLimitsOfSize : HasLimitsOfSize.{v, v} (PresheafOfModules.{v} R) where\n\n"}
{"name":"PresheafOfModules.evaluation_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (PresheafOfModules.evaluation R X)","decl":"noncomputable instance evaluation_preservesLimitsOfShape (X : Cᵒᵖ) :\n    PreservesLimitsOfShape J (evaluation R X : PresheafOfModules.{v} R ⥤ _) where\n\n"}
{"name":"PresheafOfModules.toPresheaf_preservesLimitsOfShape","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nJ : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J (PresheafOfModules.toPresheaf R)","decl":"noncomputable instance toPresheaf_preservesLimitsOfShape :\n    PreservesLimitsOfShape J (toPresheaf.{v} R) where\n\n"}
{"name":"PresheafOfModules.hasFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n⊢ CategoryTheory.Limits.HasFiniteLimits (PresheafOfModules R)","decl":"instance hasFiniteLimits : HasFiniteLimits (PresheafOfModules.{v} R) :=\n  ⟨fun _ => inferInstance⟩\n\n"}
{"name":"PresheafOfModules.evaluation_preservesFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (PresheafOfModules.evaluation R X)","decl":"noncomputable instance evaluation_preservesFiniteLimits (X : Cᵒᵖ) :\n    PreservesFiniteLimits (evaluation.{v} R X) where\n\n"}
{"name":"PresheafOfModules.toPresheaf_preservesFiniteLimits","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Limits","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (PresheafOfModules.toPresheaf R)","decl":"noncomputable instance toPresheaf_preservesFiniteLimits :\n    PreservesFiniteLimits (toPresheaf.{v} R) where\n\n"}
