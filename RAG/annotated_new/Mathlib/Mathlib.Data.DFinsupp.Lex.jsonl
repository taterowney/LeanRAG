{"name":"Pi.lex_eq_dfinsupp_lex","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\na b : DFinsupp fun i => α i\n⊢ Eq (Pi.Lex r (fun {i} => s i) ⇑a ⇑b) (DFinsupp.Lex r s a b)","decl":"theorem _root_.Pi.lex_eq_dfinsupp_lex {r : ι → ι → Prop} {s : ∀ i, α i → α i → Prop}\n    (a b : Π₀ i, α i) : Pi.Lex r (s _) (a : ∀ i, α i) b = DFinsupp.Lex r s a b :=\n  rfl\n\n-- Porting note: Updated `s`'s type.\n"}
{"name":"DFinsupp.lex_def","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → Zero (α i)\nr : ι → ι → Prop\ns : (i : ι) → α i → α i → Prop\na b : DFinsupp fun i => α i\n⊢ Iff (DFinsupp.Lex r s a b) (Exists fun j => And (∀ (d : ι), r d j → Eq (a d) (b d)) (s j (a j) (b j)))","decl":"theorem lex_def {r : ι → ι → Prop} {s : ∀ i, α i → α i → Prop} {a b : Π₀ i, α i} :\n    DFinsupp.Lex r s a b ↔ ∃ j, (∀ d, r d j → a d = b d) ∧ s j (a j) (b j) :=\n  Iff.rfl\n\n"}
{"name":"DFinsupp.lex_lt_of_lt_of_preorder","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → Preorder (α i)\nr : ι → ι → Prop\ninst✝ : IsStrictOrder ι r\nx y : DFinsupp fun i => α i\nhlt : LT.lt x y\n⊢ Exists fun i => And (∀ (j : ι), r j i → And (LE.le (x j) (y j)) (LE.le (y j) (x j))) (LT.lt (x i) (y i))","decl":"theorem lex_lt_of_lt_of_preorder [∀ i, Preorder (α i)] (r) [IsStrictOrder ι r] {x y : Π₀ i, α i}\n    (hlt : x < y) : ∃ i, (∀ j, r j i → x j ≤ y j ∧ y j ≤ x j) ∧ x i < y i := by\n  obtain ⟨hle, j, hlt⟩ := Pi.lt_def.1 hlt\n  classical\n  have : (x.neLocus y : Set ι).WellFoundedOn r := (x.neLocus y).finite_toSet.wellFoundedOn\n  obtain ⟨i, hi, hl⟩ := this.has_min { i | x i < y i } ⟨⟨j, mem_neLocus.2 hlt.ne⟩, hlt⟩\n  refine ⟨i, fun k hk ↦ ⟨hle k, ?_⟩, hi⟩\n  exact of_not_not fun h ↦ hl ⟨k, mem_neLocus.2 (ne_of_not_le h).symm⟩ ((hle k).lt_of_not_le h) hk\n\n"}
{"name":"DFinsupp.lex_lt_of_lt","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : (i : ι) → PartialOrder (α i)\nr : ι → ι → Prop\ninst✝ : IsStrictOrder ι r\nx y : DFinsupp fun i => α i\nhlt : LT.lt x y\n⊢ Pi.Lex r (fun {i} x1 x2 => LT.lt x1 x2) ⇑x ⇑y","decl":"theorem lex_lt_of_lt [∀ i, PartialOrder (α i)] (r) [IsStrictOrder ι r] {x y : Π₀ i, α i}\n    (hlt : x < y) : Pi.Lex r (· < ·) x y := by\n  simp_rw [Pi.Lex, le_antisymm_iff]\n  exact lex_lt_of_lt_of_preorder r hlt\n\n"}
{"name":"DFinsupp.Lex.isStrictOrder","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : LinearOrder ι\ninst✝ : (i : ι) → PartialOrder (α i)\n⊢ IsStrictOrder (Lex (DFinsupp fun i => α i)) fun x1 x2 => LT.lt x1 x2","decl":"instance Lex.isStrictOrder [∀ i, PartialOrder (α i)] :\n    IsStrictOrder (Lex (Π₀ i, α i)) (· < ·) where\n  irrefl _ := lt_irrefl (α := Lex (∀ i, α i)) _\n  trans _ _ _ := lt_trans (α := Lex (∀ i, α i))\n\n"}
{"name":"DFinsupp.Lex.decidableLE_def","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : LinearOrder ι\ninst✝ : (i : ι) → LinearOrder (α i)\n⊢ Eq DFinsupp.Lex.decidableLE (DFinsupp.lt_trichotomy_rec (fun {f g} h => Decidable.isTrue ⋯) (fun {f g} h => Decidable.isTrue ⋯) fun {f g} h => Decidable.isFalse ⋯)","decl":"/-- The less-or-equal relation for the lexicographic ordering is decidable. -/\nirreducible_def Lex.decidableLE : DecidableRel (α := Lex (Π₀ i, α i)) (· ≤ ·) :=\n  lt_trichotomy_rec (fun h ↦ isTrue <| Or.inr h)\n    (fun h ↦ isTrue <| Or.inl <| congr_arg _ h)\n    fun h ↦ isFalse fun h' ↦ lt_irrefl _ (h.trans_le h')\n\n"}
{"name":"DFinsupp.Lex.decidableLT_def","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : LinearOrder ι\ninst✝ : (i : ι) → LinearOrder (α i)\n⊢ Eq DFinsupp.Lex.decidableLT (DFinsupp.lt_trichotomy_rec (fun {f g} h => Decidable.isTrue h) (fun {f g} h => Decidable.isFalse ⋯) fun {f g} h => Decidable.isFalse ⋯)","decl":"/-- The less-than relation for the lexicographic ordering is decidable. -/\nirreducible_def Lex.decidableLT : DecidableRel (α := Lex (Π₀ i, α i)) (· < ·) :=\n  lt_trichotomy_rec (fun h ↦ isTrue h) (fun h ↦ isFalse h.not_lt) fun h ↦ isFalse h.asymm\n\n-- Porting note: Added `DecidableEq` for `LinearOrder`.\n"}
{"name":"DFinsupp.toLex_monotone","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : LinearOrder ι\ninst✝ : (i : ι) → PartialOrder (α i)\n⊢ Monotone ⇑toLex","decl":"theorem toLex_monotone : Monotone (@toLex (Π₀ i, α i)) := by\n  intro a b h\n  refine le_of_lt_or_eq (or_iff_not_imp_right.2 fun hne ↦ ?_)\n  classical\n  exact ⟨Finset.min' _ (nonempty_neLocus_iff.2 hne),\n    fun j hj ↦ not_mem_neLocus.1 fun h ↦ (Finset.min'_le _ _ h).not_lt hj,\n    (h _).lt_of_ne (mem_neLocus.1 <| Finset.min'_mem _ _)⟩\n\n"}
{"name":"DFinsupp.lt_of_forall_lt_of_lt","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : (i : ι) → Zero (α i)\ninst✝¹ : LinearOrder ι\ninst✝ : (i : ι) → PartialOrder (α i)\na b : Lex (DFinsupp fun i => α i)\ni : ι\na✝¹ : ∀ (j : ι), LT.lt j i → Eq ((ofLex a) j) ((ofLex b) j)\na✝ : LT.lt ((ofLex a) i) ((ofLex b) i)\n⊢ LT.lt a b","decl":"theorem lt_of_forall_lt_of_lt (a b : Lex (Π₀ i, α i)) (i : ι) :\n    (∀ j < i, ofLex a j = ofLex b j) → ofLex a i < ofLex b i → a < b :=\n  fun h1 h2 ↦ ⟨i, h1, h2⟩\n\n"}
{"name":"DFinsupp.Lex.addLeftStrictMono","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : LinearOrder ι\ninst✝² : (i : ι) → AddMonoid (α i)\ninst✝¹ : (i : ι) → LinearOrder (α i)\ninst✝ : ∀ (i : ι), AddLeftStrictMono (α i)\n⊢ AddLeftStrictMono (Lex (DFinsupp fun i => α i))","decl":"instance Lex.addLeftStrictMono : AddLeftStrictMono (Lex (Π₀ i, α i)) :=\n  ⟨fun _ _ _ ⟨a, lta, ha⟩ ↦ ⟨a, fun j ja ↦ congr_arg _ (lta j ja), add_lt_add_left ha _⟩⟩\n\n"}
{"name":"DFinsupp.Lex.addLeftMono","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : LinearOrder ι\ninst✝² : (i : ι) → AddMonoid (α i)\ninst✝¹ : (i : ι) → LinearOrder (α i)\ninst✝ : ∀ (i : ι), AddLeftStrictMono (α i)\n⊢ AddLeftMono (Lex (DFinsupp fun i => α i))","decl":"instance Lex.addLeftMono : AddLeftMono (Lex (Π₀ i, α i)) :=\n  addLeftMono_of_addLeftStrictMono _\n\n"}
{"name":"DFinsupp.Lex.addRightStrictMono","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : LinearOrder ι\ninst✝² : (i : ι) → AddMonoid (α i)\ninst✝¹ : (i : ι) → LinearOrder (α i)\ninst✝ : ∀ (i : ι), AddRightStrictMono (α i)\n⊢ AddRightStrictMono (Lex (DFinsupp fun i => α i))","decl":"instance Lex.addRightStrictMono : AddRightStrictMono (Lex (Π₀ i, α i)) :=\n  ⟨fun f _ _ ⟨a, lta, ha⟩ ↦\n    ⟨a, fun j ja ↦ congr_arg (· + ofLex f j) (lta j ja), add_lt_add_right ha _⟩⟩\n\n"}
{"name":"DFinsupp.Lex.addRightMono","module":"Mathlib.Data.DFinsupp.Lex","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : LinearOrder ι\ninst✝² : (i : ι) → AddMonoid (α i)\ninst✝¹ : (i : ι) → LinearOrder (α i)\ninst✝ : ∀ (i : ι), AddRightStrictMono (α i)\n⊢ AddRightMono (Lex (DFinsupp fun i => α i))","decl":"instance Lex.addRightMono : AddRightMono (Lex (Π₀ i, α i)) :=\n  addRightMono_of_addRightStrictMono _\n\n"}
