{"name":"CategoryTheory.Grpd.coe_of","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Groupoid C\n⊢ Eq (↑(CategoryTheory.Grpd.of C)) C","decl":"@[simp]\ntheorem coe_of (C : Type u) [Groupoid C] : (of C : Type u) = C :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grpd.forgetToCat_full","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"⊢ CategoryTheory.Grpd.forgetToCat.Full","decl":"instance forgetToCat_full : forgetToCat.Full where map_surjective f := ⟨f, rfl⟩\n\n"}
{"name":"CategoryTheory.Grpd.forgetToCat_faithful","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"⊢ CategoryTheory.Grpd.forgetToCat.Faithful","decl":"instance forgetToCat_faithful : forgetToCat.Faithful where\n\n"}
{"name":"CategoryTheory.Grpd.hom_to_functor","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"C D E : CategoryTheory.Grpd\nf : Quiver.Hom C D\ng : Quiver.Hom D E\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.Functor.comp f g)","decl":"/-- Convert arrows in the category of groupoids to functors,\nwhich sometimes helps in applying simp lemmas -/\ntheorem hom_to_functor {C D E : Grpd.{v, u}} (f : C ⟶ D) (g : D ⟶ E) : f ≫ g = f ⋙ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grpd.id_to_functor","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"C : CategoryTheory.Grpd\n⊢ Eq (CategoryTheory.Functor.id ↑C) (CategoryTheory.CategoryStruct.id C)","decl":"/-- Converts identity in the category of groupoids to the functor identity -/\ntheorem id_to_functor {C : Grpd.{v, u}} : 𝟭 C = 𝟙 C :=\n  rfl\n\n"}
{"name":"CategoryTheory.Grpd.has_pi","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"⊢ CategoryTheory.Limits.HasProducts CategoryTheory.Grpd","decl":"instance has_pi : Limits.HasProducts.{u} Grpd.{u, u} :=\n  Limits.hasProducts_of_limit_fans (by apply piLimitFan) (by apply piLimitFanIsLimit)\n\n"}
{"name":"CategoryTheory.Grpd.piIsoPi_hom_π","module":"Mathlib.CategoryTheory.Category.Grpd","initialProofState":"J : Type u\nf : J → CategoryTheory.Grpd\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Grpd.piIsoPi J f).hom (CategoryTheory.Limits.Pi.π f j)) (CategoryTheory.Pi.eval (fun i => ↑(f i)) j)","decl":"@[simp]\ntheorem piIsoPi_hom_π (J : Type u) (f : J → Grpd.{u, u}) (j : J) :\n    (piIsoPi J f).hom ≫ Limits.Pi.π f j = CategoryTheory.Pi.eval _ j := by\n  simp [piIsoPi]\n  rfl\n\n"}
