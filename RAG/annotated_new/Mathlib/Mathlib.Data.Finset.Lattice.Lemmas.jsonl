{"name":"Finset.disjoint_iff_inter_eq_empty","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Disjoint s t) (Eq (Inter.inter s t) EmptyCollection.emptyCollection)","decl":"theorem disjoint_iff_inter_eq_empty : Disjoint s t ↔ s ∩ t = ∅ :=\n  disjoint_iff\n\n"}
{"name":"Finset.union_empty","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Union.union s EmptyCollection.emptyCollection) s","decl":"@[simp]\ntheorem union_empty (s : Finset α) : s ∪ ∅ = s :=\n  ext fun x => mem_union.trans <| by simp\n\n"}
{"name":"Finset.empty_union","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Union.union EmptyCollection.emptyCollection s) s","decl":"@[simp]\ntheorem empty_union (s : Finset α) : ∅ ∪ s = s :=\n  ext fun x => mem_union.trans <| by simp\n\n"}
{"name":"Finset.Nonempty.inl","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : s.Nonempty\n⊢ (Union.union s t).Nonempty","decl":"@[aesop unsafe apply (rule_sets := [finsetNonempty])]\ntheorem Nonempty.inl {s t : Finset α} (h : s.Nonempty) : (s ∪ t).Nonempty :=\n  h.mono subset_union_left\n\n"}
{"name":"Finset.Nonempty.inr","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\nh : t.Nonempty\n⊢ (Union.union s t).Nonempty","decl":"@[aesop unsafe apply (rule_sets := [finsetNonempty])]\ntheorem Nonempty.inr {s t : Finset α} (h : t.Nonempty) : (s ∪ t).Nonempty :=\n  h.mono subset_union_right\n\n"}
{"name":"Finset.insert_eq","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Insert.insert a s) (Union.union (Singleton.singleton a) s)","decl":"theorem insert_eq (a : α) (s : Finset α) : insert a s = {a} ∪ s :=\n  rfl\n\n"}
{"name":"Finset.insert_union","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (Union.union (Insert.insert a s) t) (Insert.insert a (Union.union s t))","decl":"@[simp]\ntheorem insert_union (a : α) (s t : Finset α) : insert a s ∪ t = insert a (s ∪ t) := by\n  simp only [insert_eq, union_assoc]\n\n"}
{"name":"Finset.union_insert","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (Union.union s (Insert.insert a t)) (Insert.insert a (Union.union s t))","decl":"@[simp]\ntheorem union_insert (a : α) (s t : Finset α) : s ∪ insert a t = insert a (s ∪ t) := by\n  simp only [insert_eq, union_left_comm]\n\n"}
{"name":"Finset.insert_union_distrib","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns t : Finset α\n⊢ Eq (Insert.insert a (Union.union s t)) (Union.union (Insert.insert a s) (Insert.insert a t))","decl":"theorem insert_union_distrib (a : α) (s t : Finset α) :\n    insert a (s ∪ t) = insert a s ∪ insert a t := by\n  simp only [insert_union, union_insert, insert_idem]\n\n"}
{"name":"Finset.induction_on_union","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nP : Finset α → Finset α → Prop\nsymm : ∀ {a b : Finset α}, P a b → P b a\nempty_right : ∀ {a : Finset α}, P a EmptyCollection.emptyCollection\nsingletons : ∀ {a b : α}, P (Singleton.singleton a) (Singleton.singleton b)\nunion_of : ∀ {a b c : Finset α}, P a c → P b c → P (Union.union a b) c\na b : Finset α\n⊢ P a b","decl":"/-- To prove a relation on pairs of `Finset X`, it suffices to show that it is\n  * symmetric,\n  * it holds when one of the `Finset`s is empty,\n  * it holds for pairs of singletons,\n  * if it holds for `[a, c]` and for `[b, c]`, then it holds for `[a ∪ b, c]`.\n-/\ntheorem induction_on_union (P : Finset α → Finset α → Prop) (symm : ∀ {a b}, P a b → P b a)\n    (empty_right : ∀ {a}, P a ∅) (singletons : ∀ {a b}, P {a} {b})\n    (union_of : ∀ {a b c}, P a c → P b c → P (a ∪ b) c) : ∀ a b, P a b := by\n  intro a b\n  refine Finset.induction_on b empty_right fun x s _xs hi => symm ?_\n  rw [Finset.insert_eq]\n  apply union_of _ (symm hi)\n  refine Finset.induction_on a empty_right fun a t _ta hi => symm ?_\n  rw [Finset.insert_eq]\n  exact union_of singletons (symm hi)\n\n"}
{"name":"Finset.inter_empty","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Inter.inter s EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_empty (s : Finset α) : s ∩ ∅ = ∅ :=\n  ext fun _ => mem_inter.trans <| by simp\n\n"}
{"name":"Finset.empty_inter","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Eq (Inter.inter EmptyCollection.emptyCollection s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem empty_inter (s : Finset α) : ∅ ∩ s = ∅ :=\n  ext fun _ => mem_inter.trans <| by simp\n\n"}
{"name":"Finset.insert_inter_of_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\na : α\nh : Membership.mem s₂ a\n⊢ Eq (Inter.inter (Insert.insert a s₁) s₂) (Insert.insert a (Inter.inter s₁ s₂))","decl":"@[simp]\ntheorem insert_inter_of_mem {s₁ s₂ : Finset α} {a : α} (h : a ∈ s₂) :\n    insert a s₁ ∩ s₂ = insert a (s₁ ∩ s₂) :=\n  ext fun x => by\n    have : x = a ∨ x ∈ s₂ ↔ x ∈ s₂ := or_iff_right_of_imp <| by rintro rfl; exact h\n    simp only [mem_inter, mem_insert, or_and_left, this]\n\n"}
{"name":"Finset.inter_insert_of_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\na : α\nh : Membership.mem s₁ a\n⊢ Eq (Inter.inter s₁ (Insert.insert a s₂)) (Insert.insert a (Inter.inter s₁ s₂))","decl":"@[simp]\ntheorem inter_insert_of_mem {s₁ s₂ : Finset α} {a : α} (h : a ∈ s₁) :\n    s₁ ∩ insert a s₂ = insert a (s₁ ∩ s₂) := by rw [inter_comm, insert_inter_of_mem h, inter_comm]\n\n"}
{"name":"Finset.insert_inter_of_not_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\na : α\nh : Not (Membership.mem s₂ a)\n⊢ Eq (Inter.inter (Insert.insert a s₁) s₂) (Inter.inter s₁ s₂)","decl":"@[simp]\ntheorem insert_inter_of_not_mem {s₁ s₂ : Finset α} {a : α} (h : a ∉ s₂) :\n    insert a s₁ ∩ s₂ = s₁ ∩ s₂ :=\n  ext fun x => by\n    have : ¬(x = a ∧ x ∈ s₂) := by rintro ⟨rfl, H⟩; exact h H\n    simp only [mem_inter, mem_insert, or_and_right, this, false_or]\n\n"}
{"name":"Finset.inter_insert_of_not_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns₁ s₂ : Finset α\na : α\nh : Not (Membership.mem s₁ a)\n⊢ Eq (Inter.inter s₁ (Insert.insert a s₂)) (Inter.inter s₁ s₂)","decl":"@[simp]\ntheorem inter_insert_of_not_mem {s₁ s₂ : Finset α} {a : α} (h : a ∉ s₁) :\n    s₁ ∩ insert a s₂ = s₁ ∩ s₂ := by rw [inter_comm, insert_inter_of_not_mem h, inter_comm]\n\n"}
{"name":"Finset.singleton_inter_of_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nH : Membership.mem s a\n⊢ Eq (Inter.inter (Singleton.singleton a) s) (Singleton.singleton a)","decl":"@[simp]\ntheorem singleton_inter_of_mem {a : α} {s : Finset α} (H : a ∈ s) : {a} ∩ s = {a} :=\n  show insert a ∅ ∩ s = insert a ∅ by rw [insert_inter_of_mem H, empty_inter]\n\n"}
{"name":"Finset.singleton_inter_of_not_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nH : Not (Membership.mem s a)\n⊢ Eq (Inter.inter (Singleton.singleton a) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem singleton_inter_of_not_mem {a : α} {s : Finset α} (H : a ∉ s) : {a} ∩ s = ∅ :=\n  eq_empty_of_forall_not_mem <| by\n    simp only [mem_inter, mem_singleton]; rintro x ⟨rfl, h⟩; exact H h\n\n"}
{"name":"Finset.singleton_inter","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Inter.inter (Singleton.singleton a) s) (ite (Membership.mem s a) (Singleton.singleton a) EmptyCollection.emptyCollection)","decl":"lemma singleton_inter {a : α} {s : Finset α} :\n    {a} ∩ s = if a ∈ s then {a} else ∅ := by\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Finset.inter_singleton_of_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Membership.mem s a\n⊢ Eq (Inter.inter s (Singleton.singleton a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem inter_singleton_of_mem {a : α} {s : Finset α} (h : a ∈ s) : s ∩ {a} = {a} := by\n  rw [inter_comm, singleton_inter_of_mem h]\n\n"}
{"name":"Finset.inter_singleton_of_not_mem","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\nh : Not (Membership.mem s a)\n⊢ Eq (Inter.inter s (Singleton.singleton a)) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem inter_singleton_of_not_mem {a : α} {s : Finset α} (h : a ∉ s) : s ∩ {a} = ∅ := by\n  rw [inter_comm, singleton_inter_of_not_mem h]\n\n"}
{"name":"Finset.inter_singleton","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\ns : Finset α\n⊢ Eq (Inter.inter s (Singleton.singleton a)) (ite (Membership.mem s a) (Singleton.singleton a) EmptyCollection.emptyCollection)","decl":"lemma inter_singleton {a : α} {s : Finset α} :\n    s ∩ {a} = if a ∈ s then {a} else ∅ := by\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"Finset.union_eq_empty","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Eq (Union.union s t) EmptyCollection.emptyCollection) (And (Eq s EmptyCollection.emptyCollection) (Eq t EmptyCollection.emptyCollection))","decl":"@[simp] lemma union_eq_empty : s ∪ t = ∅ ↔ s = ∅ ∧ t = ∅ := sup_eq_bot_iff\n"}
{"name":"Finset.union_nonempty","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\n⊢ Iff (Union.union s t).Nonempty (Or s.Nonempty t.Nonempty)","decl":"@[simp] lemma union_nonempty : (s ∪ t).Nonempty ↔ s.Nonempty ∨ t.Nonempty :=\n  mod_cast Set.union_nonempty (α := α) (s := s) (t := t)\n\n"}
{"name":"Finset.insert_union_comm","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns t : Finset α\na : α\n⊢ Eq (Union.union (Insert.insert a s) t) (Union.union s (Insert.insert a t))","decl":"theorem insert_union_comm (s t : Finset α) (a : α) : insert a s ∪ t = s ∪ insert a t := by\n  rw [insert_union, union_insert]\n\n"}
{"name":"List.toFinset_append","module":"Mathlib.Data.Finset.Lattice.Lemmas","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l' : List α\n⊢ Eq (HAppend.hAppend l l').toFinset (Union.union l.toFinset l'.toFinset)","decl":"@[simp]\ntheorem toFinset_append : toFinset (l ++ l') = l.toFinset ∪ l'.toFinset := by\n  induction' l with hd tl hl\n  · simp\n  · simp [hl]\n\n"}
