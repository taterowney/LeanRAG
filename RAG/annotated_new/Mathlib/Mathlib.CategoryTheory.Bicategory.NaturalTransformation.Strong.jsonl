{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (self.app b)) (self.naturality g).hom) (CategoryTheory.CategoryStruct.comp (self.naturality f).hom (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.map₂ η)))","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na : B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (self.app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.app a)).hom (CategoryTheory.Bicategory.rightUnitor (self.app a)).inv))","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (self.app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (self.app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (self.app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.naturality f).hom (G.map g)) (CategoryTheory.Bicategory.associator (self.app a) (G.map f) (G.map g)).hom)))))","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.mk.inj","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\napp✝ : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (app✝ b)) (CategoryTheory.CategoryStruct.comp (app✝ a) (G.map f))\nnaturality_naturality✝ : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app✝ b)) (naturality✝ g).hom) (CategoryTheory.CategoryStruct.comp (naturality✝ f).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.map₂ η)))) _auto✝\nnaturality_id✝ : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app✝ a)).hom (CategoryTheory.Bicategory.rightUnitor (app✝ a)).inv))) _auto✝\nnaturality_comp✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app✝ c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app✝ c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality✝ g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app✝ b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality✝ f).hom (G.map g)) (CategoryTheory.Bicategory.associator (app✝ a) (G.map f) (G.map g)).hom)))))) _auto✝\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (naturality f).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f).hom (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\nx✝ : Eq { app := app✝, naturality := naturality✝, naturality_naturality := naturality_naturality✝, naturality_id := naturality_id✝, naturality_comp := naturality_comp✝ } { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }\n⊢ And (Eq app✝ app) (HEq naturality✝ naturality)","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\napp✝ : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality✝ : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (app✝ b)) (CategoryTheory.CategoryStruct.comp (app✝ a) (G.map f))\nnaturality_naturality✝ : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app✝ b)) (naturality✝ g).hom) (CategoryTheory.CategoryStruct.comp (naturality✝ f).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.map₂ η)))) _auto✝\nnaturality_id✝ : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app✝ a)).hom (CategoryTheory.Bicategory.rightUnitor (app✝ a)).inv))) _auto✝\nnaturality_comp✝ : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality✝ (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (app✝ a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app✝ c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app✝ c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality✝ g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app✝ b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality✝ f).hom (G.map g)) (CategoryTheory.Bicategory.associator (app✝ a) (G.map f) (G.map g)).hom)))))) _auto✝\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (naturality f).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f).hom (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\n⊢ Eq (Eq { app := app✝, naturality := naturality✝, naturality_naturality := naturality_naturality✝, naturality_id := naturality_id✝, naturality_comp := naturality_comp✝ } { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }) (And (Eq app✝ app) (HEq naturality✝ naturality))","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝³ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝² : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\ninst✝¹ : SizeOf B\ninst✝ : SizeOf C\napp : (a : B) → Quiver.Hom (F.obj a) (G.obj a)\nnaturality : {a b : B} → (f : Quiver.Hom a b) → CategoryTheory.Iso (CategoryTheory.CategoryStruct.comp (F.map f) (app b)) (CategoryTheory.CategoryStruct.comp (app a) (G.map f))\nnaturality_naturality : autoParam (∀ {a b : B} {f g : Quiver.Hom a b} (η : Quiver.Hom f g), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (app b)) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (naturality f).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.map₂ η)))) _auto✝\nnaturality_id : autoParam (∀ (a : B), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapId a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (app a)).hom (CategoryTheory.Bicategory.rightUnitor (app a)).inv))) _auto✝\nnaturality_comp : autoParam (∀ {a b c : B} (f : Quiver.Hom a b) (g : Quiver.Hom b c), Eq (CategoryTheory.CategoryStruct.comp (naturality (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.Bicategory.whiskerLeft (app a) (G.mapComp f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (naturality f).hom (G.map g)) (CategoryTheory.Bicategory.associator (app a) (G.map f) (G.map g)).hom)))))) _auto✝\n⊢ Eq (SizeOf.sizeOf { app := app, naturality := naturality, naturality_naturality := naturality_naturality, naturality_id := naturality_id, naturality_comp := naturality_comp }) 1","decl":"/-- A strong natural transformation between oplax functors `F` and `G` is a natural transformation\nthat is \"natural up to 2-isomorphisms\".\n\nMore precisely, it consists of the following:\n* a 1-morphism `η.app a : F.obj a ⟶ G.obj a` for each object `a : B`.\n* a 2-isomorphism `η.naturality f : F.map f ≫ app b ⟶ app a ≫ G.map f` for each 1-morphism\n`f : a ⟶ b`.\n* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the\ncompositions modulo some adjustments of domains and codomains of 2-morphisms.\n-/\nstructure StrongOplaxNatTrans (F G : OplaxFunctor B C) where\n  app (a : B) : F.obj a ⟶ G.obj a\n  naturality {a b : B} (f : a ⟶ b) : F.map f ≫ app b ≅ app a ≫ G.map f\n  naturality_naturality :\n    ∀ {a b : B} {f g : a ⟶ b} (η : f ⟶ g),\n      F.map₂ η ▷ app b ≫ (naturality g).hom = (naturality f).hom ≫ app a ◁ G.map₂ η := by\n    aesop_cat\n  naturality_id :\n    ∀ a : B,\n      (naturality (𝟙 a)).hom ≫ app a ◁ G.mapId a =\n        F.mapId a ▷ app a ≫ (λ_ (app a)).hom ≫ (ρ_ (app a)).inv := by\n    aesop_cat\n  naturality_comp :\n    ∀ {a b c : B} (f : a ⟶ b) (g : b ⟶ c),\n      (naturality (f ≫ g)).hom ≫ app a ◁ G.mapComp f g =\n        F.mapComp f g ▷ app c ≫ (α_ _ _ _).hom ≫ F.map f ◁ (naturality g).hom ≫\n        (α_ _ _ _).inv ≫ (naturality f).hom ▷ G.map g ≫ (α_ _ _ _).hom := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na b : B\nf g : Quiver.Hom a b\nη : Quiver.Hom f g\nZ : Quiver.Hom (F.obj a) (G.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.map₂ η) (self.app b)) (CategoryTheory.CategoryStruct.comp (self.naturality g).hom h)) (CategoryTheory.CategoryStruct.comp (self.naturality f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.map₂ η)) h))","decl":"attribute [reassoc (attr := simp)] StrongOplaxNatTrans.naturality_naturality\n  StrongOplaxNatTrans.naturality_id StrongOplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na b c : B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nZ : Quiver.Hom (F.obj a) (G.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.comp f g)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapComp f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (self.app c)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (self.app c)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (self.naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (self.app b) (G.map g)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (self.naturality f).hom (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (self.app a) (G.map f) (G.map g)).hom h))))))","decl":"attribute [reassoc (attr := simp)] StrongOplaxNatTrans.naturality_naturality\n  StrongOplaxNatTrans.naturality_id StrongOplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nself : CategoryTheory.StrongOplaxNatTrans F G\na : B\nZ : Quiver.Hom (F.obj a) (G.obj a)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (self.app a) (CategoryTheory.CategoryStruct.id (G.obj a))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.naturality (CategoryTheory.CategoryStruct.id a)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (self.app a) (G.mapId a)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (self.app a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (self.app a)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (self.app a)).inv h)))","decl":"attribute [reassoc (attr := simp)] StrongOplaxNatTrans.naturality_naturality\n  StrongOplaxNatTrans.naturality_id StrongOplaxNatTrans.naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.toOplax_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na✝ b✝ : B\nf : Quiver.Hom a✝ b✝\n⊢ Eq (η.toOplax.naturality f) (η.naturality f).hom","decl":"/-- The underlying oplax natural transformation of a strong natural transformation. -/\n@[simps]\ndef toOplax {F G : OplaxFunctor B C} (η : StrongOplaxNatTrans F G) : OplaxNatTrans F G where\n  app := η.app\n  naturality f := (η.naturality f).hom\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.toOplax_app","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na : B\n⊢ Eq (η.toOplax.app a) (η.app a)","decl":"/-- The underlying oplax natural transformation of a strong natural transformation. -/\n@[simps]\ndef toOplax {F G : OplaxFunctor B C} (η : StrongOplaxNatTrans F G) : OplaxNatTrans F G where\n  app := η.app\n  naturality f := (η.naturality f).hom\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.id_naturality_inv","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na✝ b✝ : B\nf : Quiver.Hom a✝ b✝\n⊢ Eq ((CategoryTheory.StrongOplaxNatTrans.id F).naturality f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.leftUnitor (F.map f)).hom (CategoryTheory.Bicategory.rightUnitor (F.map f)).inv)","decl":"/-- The identity strong natural transformation. -/\n@[simps!]\ndef id : StrongOplaxNatTrans F F :=\n  mkOfOplax (OplaxNatTrans.id F) { naturality := fun f ↦ (ρ_ (F.map f)) ≪≫ (λ_ (F.map f)).symm }\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.id_naturality_hom","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na✝ b✝ : B\nf : Quiver.Hom a✝ b✝\n⊢ Eq ((CategoryTheory.StrongOplaxNatTrans.id F).naturality f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.rightUnitor (F.map f)).hom (CategoryTheory.Bicategory.leftUnitor (F.map f)).inv)","decl":"/-- The identity strong natural transformation. -/\n@[simps!]\ndef id : StrongOplaxNatTrans F F :=\n  mkOfOplax (OplaxNatTrans.id F) { naturality := fun f ↦ (ρ_ (F.map f)) ≪≫ (λ_ (F.map f)).symm }\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.id_app","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\na : B\n⊢ Eq ((CategoryTheory.StrongOplaxNatTrans.id F).app a) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"/-- The identity strong natural transformation. -/\n@[simps!]\ndef id : StrongOplaxNatTrans F F :=\n  mkOfOplax (OplaxNatTrans.id F) { naturality := fun f ↦ (ρ_ (F.map f)) ≪≫ (λ_ (F.map f)).symm }\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.id.toOplax","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.OplaxFunctor B C\n⊢ Eq (CategoryTheory.StrongOplaxNatTrans.id F).toOplax (CategoryTheory.OplaxNatTrans.id F)","decl":"@[simp]\nlemma id.toOplax : (id F).toOplax = OplaxNatTrans.id F :=\n  rfl\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na b : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng h : Quiver.Hom a b\nβ : Quiver.Hom g h\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) (θ.app b))) (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality h).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality g).hom) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.map₂ β))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_naturality (f : a' ⟶ G.obj a) {g h : a ⟶ b} (β : g ⟶ h) :\n    f ◁ G.map₂ β ▷ θ.app b ≫ f ◁ (θ.naturality h).hom =\n      f ◁ (θ.naturality g).hom ≫ f ◁ θ.app a ◁ H.map₂ β := by\n  apply θ.toOplax.whiskerLeft_naturality_naturality\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na b : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng h✝ : Quiver.Hom a b\nβ : Quiver.Hom g h✝\nZ : Quiver.Hom a' (H.obj b)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (H.map h✝))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) (θ.app b))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality h✝).hom) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality g).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.map₂ β))) h))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_naturality (f : a' ⟶ G.obj a) {g h : a ⟶ b} (β : g ⟶ h) :\n    f ◁ G.map₂ β ▷ θ.app b ≫ f ◁ (θ.naturality h).hom =\n      f ◁ (θ.naturality g).hom ≫ f ◁ θ.app a ◁ H.map₂ β := by\n  apply θ.toOplax.whiskerLeft_naturality_naturality\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_naturality_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na b : B\na' : C\nf g : Quiver.Hom a b\nβ : Quiver.Hom f g\nh✝ : Quiver.Hom (G.obj b) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (η.app a) (G.map g)) h✝) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.map₂ β) (η.app b)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality g).hom h✝) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map f) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map g) h✝).inv h))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_naturality {f g : a ⟶ b} (β : f ⟶ g) (h : G.obj b ⟶ a') :\n    F.map₂ β ▷ η.app b ▷ h ≫ (η.naturality g).hom ▷ h =\n      (η.naturality f).hom ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.map₂ β ▷ h ≫ (α_ _ _ _).inv := by\n  apply η.toOplax.whiskerRight_naturality_naturality\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_naturality","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na b : B\na' : C\nf g : Quiver.Hom a b\nβ : Quiver.Hom f g\nh : Quiver.Hom (G.obj b) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.map₂ β) (η.app b)) h) (CategoryTheory.Bicategory.whiskerRight (η.naturality g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map f) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.map₂ β) h)) (CategoryTheory.Bicategory.associator (η.app a) (G.map g) h).inv)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_naturality {f g : a ⟶ b} (β : f ⟶ g) (h : G.obj b ⟶ a') :\n    F.map₂ β ▷ η.app b ▷ h ≫ (η.naturality g).hom ▷ h =\n      (η.naturality f).hom ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.map₂ β ▷ h ≫ (α_ _ _ _).inv := by\n  apply η.toOplax.whiskerRight_naturality_naturality\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na b c : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng : Quiver.Hom a b\nh✝ : Quiver.Hom b c\nZ : Quiver.Hom a' (H.obj c)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (CategoryTheory.CategoryStruct.comp (H.map g) (H.map h✝)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.comp g h✝)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapComp g h✝))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapComp g h✝) (θ.app c))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (G.map h✝) (θ.app c)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (G.map g) (θ.naturality h✝).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (θ.app b) (H.map h✝)).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (θ.naturality g).hom (H.map h✝))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (θ.app a) (H.map g) (H.map h✝)).hom) h))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_comp (f : a' ⟶ G.obj a) (g : a ⟶ b) (h : b ⟶ c) :\n    f ◁ (θ.naturality (g ≫ h)).hom ≫ f ◁ θ.app a ◁ H.mapComp g h =\n      f ◁ G.mapComp g h ▷ θ.app c ≫\n        f ◁ (α_ _ _ _).hom ≫\n          f ◁ G.map g ◁ (θ.naturality h).hom ≫\n            f ◁ (α_ _ _ _).inv ≫ f ◁ (θ.naturality g).hom ▷ H.map h ≫ f ◁ (α_ _ _ _).hom := by\n  apply θ.toOplax.whiskerLeft_naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na b c : B\na' : C\nf : Quiver.Hom a' (G.obj a)\ng : Quiver.Hom a b\nh : Quiver.Hom b c\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.comp g h)).hom) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapComp g h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapComp g h) (θ.app c))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (G.map h) (θ.app c)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (G.map g) (θ.naturality h).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (G.map g) (θ.app b) (H.map h)).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (θ.naturality g).hom (H.map h))) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.associator (θ.app a) (H.map g) (H.map h)).hom))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_comp (f : a' ⟶ G.obj a) (g : a ⟶ b) (h : b ⟶ c) :\n    f ◁ (θ.naturality (g ≫ h)).hom ≫ f ◁ θ.app a ◁ H.mapComp g h =\n      f ◁ G.mapComp g h ▷ θ.app c ≫\n        f ◁ (α_ _ _ _).hom ≫\n          f ◁ G.map g ◁ (θ.naturality h).hom ≫\n            f ◁ (α_ _ _ _).inv ≫ f ◁ (θ.naturality g).hom ▷ H.map h ≫ f ◁ (α_ _ _ _).hom := by\n  apply θ.toOplax.whiskerLeft_naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_comp_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na b c : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh✝ : Quiver.Hom (G.obj c) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (η.app a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h✝)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.comp f g)).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.comp f g)) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapComp f g) h✝)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (η.app c)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (η.app c)).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (η.app c)) h✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (η.naturality g).hom h✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (η.app b) (G.map g)) h✝).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (η.app b) (G.map g)).inv h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (η.naturality f).hom (G.map g)) h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (η.app a) (G.map f) (G.map g)).hom h✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h✝).hom h)))))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_comp (f : a ⟶ b) (g : b ⟶ c) (h : G.obj c ⟶ a') :\n    (η.naturality (f ≫ g)).hom ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapComp f g ▷ h =\n      F.mapComp f g ▷ η.app c ▷ h ≫\n        (α_ _ _ _).hom ▷ h ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ (η.naturality g).hom ▷ h ≫\n              (α_ _ _ _).inv ≫\n                (α_ _ _ _).inv ▷ h ≫\n                 (η.naturality f).hom ▷ G.map g ▷ h ≫ (α_ _ _ _).hom ▷ h ≫ (α_ _ _ _).hom := by\n  apply η.toOplax.whiskerRight_naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na b c : B\na' : C\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom (G.obj c) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.comp f g)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.comp f g)) h).hom (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapComp f g) h)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapComp f g) (η.app c)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (F.map g) (η.app c)).hom h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) (η.app c)) h).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (F.map f) (CategoryTheory.Bicategory.whiskerRight (η.naturality g).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (CategoryTheory.CategoryStruct.comp (η.app b) (G.map g)) h).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (F.map f) (η.app b) (G.map g)).inv h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (η.naturality f).hom (G.map g)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.associator (η.app a) (G.map f) (G.map g)).hom h) (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.comp (G.map f) (G.map g)) h).hom))))))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_comp (f : a ⟶ b) (g : b ⟶ c) (h : G.obj c ⟶ a') :\n    (η.naturality (f ≫ g)).hom ▷ h ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapComp f g ▷ h =\n      F.mapComp f g ▷ η.app c ▷ h ≫\n        (α_ _ _ _).hom ▷ h ≫\n          (α_ _ _ _).hom ≫\n            F.map f ◁ (η.naturality g).hom ▷ h ≫\n              (α_ _ _ _).inv ≫\n                (α_ _ _ _).inv ▷ h ≫\n                 (η.naturality f).hom ▷ G.map g ▷ h ≫ (α_ _ _ _).hom ▷ h ≫ (α_ _ _ _).hom := by\n  apply η.toOplax.whiskerRight_naturality_comp\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na : B\na' : C\nf : Quiver.Hom a' (G.obj a)\nZ : Quiver.Hom a' (H.obj a)\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (θ.app a) (CategoryTheory.CategoryStruct.id (H.obj a)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.id a)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapId a))) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapId a) (θ.app a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.leftUnitor (θ.app a)).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.rightUnitor (θ.app a)).inv) h)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_id (f : a' ⟶ G.obj a) :\n    f ◁ (θ.naturality (𝟙 a)).hom ≫ f ◁ θ.app a ◁ H.mapId a =\n      f ◁ G.mapId a ▷ θ.app a ≫ f ◁ (λ_ (θ.app a)).hom ≫ f ◁ (ρ_ (θ.app a)).inv := by\n  apply θ.toOplax.whiskerLeft_naturality_id\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerLeft_naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nG H : CategoryTheory.OplaxFunctor B C\nθ : CategoryTheory.StrongOplaxNatTrans G H\na : B\na' : C\nf : Quiver.Hom a' (G.obj a)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (θ.naturality (CategoryTheory.CategoryStruct.id a)).hom) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerLeft (θ.app a) (H.mapId a)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.whiskerRight (G.mapId a) (θ.app a))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.leftUnitor (θ.app a)).hom) (CategoryTheory.Bicategory.whiskerLeft f (CategoryTheory.Bicategory.rightUnitor (θ.app a)).inv)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_naturality_id (f : a' ⟶ G.obj a) :\n    f ◁ (θ.naturality (𝟙 a)).hom ≫ f ◁ θ.app a ◁ H.mapId a =\n      f ◁ G.mapId a ▷ θ.app a ≫ f ◁ (λ_ (θ.app a)).hom ≫ f ◁ (ρ_ (θ.app a)).inv := by\n  apply θ.toOplax.whiskerLeft_naturality_id\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_id_assoc","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na : B\na' : C\nf : Quiver.Hom (G.obj a) a'\nZ : Quiver.Hom (F.obj a) a'\nh : Quiver.Hom (CategoryTheory.CategoryStruct.comp (η.app a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.id (G.obj a)) f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.id a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.id a)) f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapId a) f)) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (η.app a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.leftUnitor (η.app a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (η.app a)).inv f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.id (G.obj a)) f).hom h))))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_id (f : G.obj a ⟶ a') :\n    (η.naturality (𝟙 a)).hom ▷ f ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapId a ▷ f =\n    F.mapId a ▷ η.app a ▷ f ≫ (λ_ (η.app a)).hom ▷ f ≫ (ρ_ (η.app a)).inv ▷ f ≫\n    (α_ _ _ _).hom := by\n  apply η.toOplax.whiskerRight_naturality_id\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.whiskerRight_naturality_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\na : B\na' : C\nf : Quiver.Hom (G.obj a) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality (CategoryTheory.CategoryStruct.id a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a) (G.map (CategoryTheory.CategoryStruct.id a)) f).hom (CategoryTheory.Bicategory.whiskerLeft (η.app a) (CategoryTheory.Bicategory.whiskerRight (G.mapId a) f)))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.whiskerRight (F.mapId a) (η.app a)) f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.leftUnitor (η.app a)).hom f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (CategoryTheory.Bicategory.rightUnitor (η.app a)).inv f) (CategoryTheory.Bicategory.associator (η.app a) (CategoryTheory.CategoryStruct.id (G.obj a)) f).hom)))","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_naturality_id (f : G.obj a ⟶ a') :\n    (η.naturality (𝟙 a)).hom ▷ f ≫ (α_ _ _ _).hom ≫ η.app a ◁ G.mapId a ▷ f =\n    F.mapId a ▷ η.app a ▷ f ≫ (λ_ (η.app a)).hom ▷ f ≫ (ρ_ (η.app a)).inv ▷ f ≫\n    (α_ _ _ _).hom := by\n  apply η.toOplax.whiskerRight_naturality_id\n\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.vcomp_naturality_inv","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G H : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\nθ : CategoryTheory.StrongOplaxNatTrans G H\na✝ b✝ : B\nf : Quiver.Hom a✝ b✝\n⊢ Eq ((η.vcomp θ).naturality f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a✝) (θ.app a✝) (H.map f)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a✝) (θ.naturality f).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a✝) (G.map f) (θ.app b✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f).inv (θ.app b✝)) (CategoryTheory.Bicategory.associator (F.map f) (η.app b✝) (θ.app b✝)).hom))))","decl":"/-- Vertical composition of strong natural transformations. -/\n@[simps!]\ndef vcomp (η : StrongOplaxNatTrans F G) (θ : StrongOplaxNatTrans G H) : StrongOplaxNatTrans F H :=\n  mkOfOplax (OplaxNatTrans.vcomp η.toOplax θ.toOplax)\n    { naturality := fun {a b} f ↦\n        (α_ _ _ _).symm ≪≫ whiskerRightIso (η.naturality f) (θ.app b) ≪≫\n        (α_ _ _ _) ≪≫ whiskerLeftIso (η.app a) (θ.naturality f) ≪≫ (α_ _ _ _).symm }\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.vcomp_naturality_hom","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G H : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\nθ : CategoryTheory.StrongOplaxNatTrans G H\na✝ b✝ : B\nf : Quiver.Hom a✝ b✝\n⊢ Eq ((η.vcomp θ).naturality f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (F.map f) (η.app b✝) (θ.app b✝)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerRight (η.naturality f).hom (θ.app b✝)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.associator (η.app a✝) (G.map f) (θ.app b✝)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Bicategory.whiskerLeft (η.app a✝) (θ.naturality f).hom) (CategoryTheory.Bicategory.associator (η.app a✝) (θ.app a✝) (H.map f)).inv))))","decl":"/-- Vertical composition of strong natural transformations. -/\n@[simps!]\ndef vcomp (η : StrongOplaxNatTrans F G) (θ : StrongOplaxNatTrans G H) : StrongOplaxNatTrans F H :=\n  mkOfOplax (OplaxNatTrans.vcomp η.toOplax θ.toOplax)\n    { naturality := fun {a b} f ↦\n        (α_ _ _ _).symm ≪≫ whiskerRightIso (η.naturality f) (θ.app b) ≪≫\n        (α_ _ _ _) ≪≫ whiskerLeftIso (η.app a) (θ.naturality f) ≪≫ (α_ _ _ _).symm }\n"}
{"name":"CategoryTheory.StrongOplaxNatTrans.vcomp_app","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF G H : CategoryTheory.OplaxFunctor B C\nη : CategoryTheory.StrongOplaxNatTrans F G\nθ : CategoryTheory.StrongOplaxNatTrans G H\na : B\n⊢ Eq ((η.vcomp θ).app a) (CategoryTheory.CategoryStruct.comp (η.app a) (θ.app a))","decl":"/-- Vertical composition of strong natural transformations. -/\n@[simps!]\ndef vcomp (η : StrongOplaxNatTrans F G) (θ : StrongOplaxNatTrans G H) : StrongOplaxNatTrans F H :=\n  mkOfOplax (OplaxNatTrans.vcomp η.toOplax θ.toOplax)\n    { naturality := fun {a b} f ↦\n        (α_ _ _ _).symm ≪≫ whiskerRightIso (η.naturality f) (θ.app b) ≪≫\n        (α_ _ _ _) ≪≫ whiskerLeftIso (η.app a) (θ.naturality f) ≪≫ (α_ _ _ _).symm }\n"}
{"name":"CategoryTheory.Pseudofunctor.categoryStruct_comp","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nX✝ Y✝ Z✝ : CategoryTheory.Pseudofunctor B C\nη : CategoryTheory.StrongOplaxNatTrans X✝.toOplax Y✝.toOplax\nθ : CategoryTheory.StrongOplaxNatTrans Y✝.toOplax Z✝.toOplax\n⊢ Eq (CategoryTheory.CategoryStruct.comp η θ) (η.vcomp θ)","decl":"@[simps id comp]\ninstance Pseudofunctor.categoryStruct : CategoryStruct (Pseudofunctor B C) where\n  Hom F G := StrongOplaxNatTrans F.toOplax G.toOplax\n  id F := StrongOplaxNatTrans.id F.toOplax\n  comp := StrongOplaxNatTrans.vcomp\n\n\n"}
{"name":"CategoryTheory.Pseudofunctor.categoryStruct_id","module":"Mathlib.CategoryTheory.Bicategory.NaturalTransformation.Strong","initialProofState":"B : Type u₁\ninst✝¹ : CategoryTheory.Bicategory B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : CategoryTheory.Pseudofunctor B C\n⊢ Eq (CategoryTheory.CategoryStruct.id F) (CategoryTheory.StrongOplaxNatTrans.id F.toOplax)","decl":"@[simps id comp]\ninstance Pseudofunctor.categoryStruct : CategoryStruct (Pseudofunctor B C) where\n  Hom F G := StrongOplaxNatTrans F.toOplax G.toOplax\n  id F := StrongOplaxNatTrans.id F.toOplax\n  comp := StrongOplaxNatTrans.vcomp\n\n\n"}
