{"name":"Subgroup.eq_one_of_noncommProd_eq_one_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nf : ι → G\ncomm : (↑s).Pairwise (Function.onFun Commute f)\nK : ι → Subgroup G\nhind : iSupIndep K\nhmem : ∀ (x : ι), Membership.mem s x → Membership.mem (K x) (f x)\nheq1 : Eq (s.noncommProd f comm) 1\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (f i) 1","decl":"/-- `Finset.noncommProd` is “injective” in `f` if `f` maps into independent subgroups.  This\ngeneralizes (one direction of) `Subgroup.disjoint_iff_mul_eq_one`. -/\n@[to_additive \"`Finset.noncommSum` is “injective” in `f` if `f` maps into independent subgroups.\nThis generalizes (one direction of) `AddSubgroup.disjoint_iff_add_eq_zero`. \"]\ntheorem eq_one_of_noncommProd_eq_one_of_iSupIndep {ι : Type*} (s : Finset ι) (f : ι → G) (comm)\n    (K : ι → Subgroup G) (hind : iSupIndep K) (hmem : ∀ x ∈ s, f x ∈ K x)\n    (heq1 : s.noncommProd f comm = 1) : ∀ i ∈ s, f i = 1 := by\n  classical\n    revert heq1\n    induction' s using Finset.induction_on with i s hnmem ih\n    · simp\n    · have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)\n      simp only [Finset.forall_mem_insert] at hmem\n      have hmem_bsupr : s.noncommProd f hcomm ∈ ⨆ i ∈ (s : Set ι), K i := by\n        refine Subgroup.noncommProd_mem _ _ ?_\n        intro x hx\n        have : K x ≤ ⨆ i ∈ (s : Set ι), K i := le_iSup₂ (f := fun i _ => K i) x hx\n        exact this (hmem.2 x hx)\n      intro heq1\n      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1\n      have hnmem' : i ∉ (s : Set ι) := by simpa\n      obtain ⟨heq1i : f i = 1, heq1S : s.noncommProd f _ = 1⟩ :=\n        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1\n      intro i h\n      simp only [Finset.mem_insert] at h\n      rcases h with (rfl | h)\n      · exact heq1i\n      · refine ih hcomm hmem.2 heq1S _ h\n\n"}
{"name":"AddSubgroup.eq_zero_of_noncommSum_eq_zero_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\ns : Finset ι\nf : ι → G\ncomm : (↑s).Pairwise (Function.onFun AddCommute f)\nK : ι → AddSubgroup G\nhind : iSupIndep K\nhmem : ∀ (x : ι), Membership.mem s x → Membership.mem (K x) (f x)\nheq1 : Eq (s.noncommSum f comm) 0\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (f i) 0","decl":"/-- `Finset.noncommProd` is “injective” in `f` if `f` maps into independent subgroups.  This\ngeneralizes (one direction of) `Subgroup.disjoint_iff_mul_eq_one`. -/\n@[to_additive \"`Finset.noncommSum` is “injective” in `f` if `f` maps into independent subgroups.\nThis generalizes (one direction of) `AddSubgroup.disjoint_iff_add_eq_zero`. \"]\ntheorem eq_one_of_noncommProd_eq_one_of_iSupIndep {ι : Type*} (s : Finset ι) (f : ι → G) (comm)\n    (K : ι → Subgroup G) (hind : iSupIndep K) (hmem : ∀ x ∈ s, f x ∈ K x)\n    (heq1 : s.noncommProd f comm = 1) : ∀ i ∈ s, f i = 1 := by\n  classical\n    revert heq1\n    induction' s using Finset.induction_on with i s hnmem ih\n    · simp\n    · have hcomm := comm.mono (Finset.coe_subset.2 <| Finset.subset_insert _ _)\n      simp only [Finset.forall_mem_insert] at hmem\n      have hmem_bsupr : s.noncommProd f hcomm ∈ ⨆ i ∈ (s : Set ι), K i := by\n        refine Subgroup.noncommProd_mem _ _ ?_\n        intro x hx\n        have : K x ≤ ⨆ i ∈ (s : Set ι), K i := le_iSup₂ (f := fun i _ => K i) x hx\n        exact this (hmem.2 x hx)\n      intro heq1\n      rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hnmem] at heq1\n      have hnmem' : i ∉ (s : Set ι) := by simpa\n      obtain ⟨heq1i : f i = 1, heq1S : s.noncommProd f _ = 1⟩ :=\n        Subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_biSup hnmem') hmem.1 hmem_bsupr heq1\n      intro i h\n      simp only [Finset.mem_insert] at h\n      rcases h with (rfl | h)\n      · exact heq1i\n      · refine ih hcomm hmem.2 heq1S _ h\n\n"}
{"name":"Subgroup.eq_one_of_noncommProd_eq_one_of_independent","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\ns : Finset ι\nf : ι → G\ncomm : (↑s).Pairwise (Function.onFun Commute f)\nK : ι → Subgroup G\nhind : iSupIndep K\nhmem : ∀ (x : ι), Membership.mem s x → Membership.mem (K x) (f x)\nheq1 : Eq (s.noncommProd f comm) 1\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (f i) 1","decl":"@[deprecated (since := \"2024-11-24\")]\nalias eq_one_of_noncommProd_eq_one_of_independent := eq_one_of_noncommProd_eq_one_of_iSupIndep\n\n"}
{"name":"MonoidHom.noncommPiCoprod_mulSingle","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝³ : Monoid M\nι : Type u_2\ninst✝² : Fintype ι\nN : ι → Type u_3\ninst✝¹ : (i : ι) → Monoid (N i)\nϕ : (i : ι) → MonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), Commute ((ϕ i) x) ((ϕ j) y)\ninst✝ : DecidableEq ι\ni : ι\ny : N i\n⊢ Eq ((MonoidHom.noncommPiCoprod ϕ hcomm) (Pi.mulSingle i y)) ((ϕ i) y)","decl":"@[to_additive (attr := simp)]\ntheorem noncommPiCoprod_mulSingle [DecidableEq ι] (i : ι) (y : N i) :\n    noncommPiCoprod ϕ hcomm (Pi.mulSingle i y) = ϕ i y := by\n  change Finset.univ.noncommProd (fun j => ϕ j (Pi.mulSingle i y j)) (fun _ _ _ _ h => hcomm h _ _)\n    = ϕ i y\n  rw [← Finset.insert_erase (Finset.mem_univ i)]\n  rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ (Finset.not_mem_erase i _)]\n  rw [Pi.mulSingle_eq_same]\n  rw [Finset.noncommProd_eq_pow_card]\n  · rw [one_pow]\n    exact mul_one _\n  · intro j hj\n    simp only [Finset.mem_erase] at hj\n    simp [hj]\n\n"}
{"name":"AddMonoidHom.noncommPiCoprod_single","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\nι : Type u_2\ninst✝² : Fintype ι\nN : ι → Type u_3\ninst✝¹ : (i : ι) → AddMonoid (N i)\nϕ : (i : ι) → AddMonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), AddCommute ((ϕ i) x) ((ϕ j) y)\ninst✝ : DecidableEq ι\ni : ι\ny : N i\n⊢ Eq ((AddMonoidHom.noncommPiCoprod ϕ hcomm) (Pi.single i y)) ((ϕ i) y)","decl":"@[to_additive (attr := simp)]\ntheorem noncommPiCoprod_mulSingle [DecidableEq ι] (i : ι) (y : N i) :\n    noncommPiCoprod ϕ hcomm (Pi.mulSingle i y) = ϕ i y := by\n  change Finset.univ.noncommProd (fun j => ϕ j (Pi.mulSingle i y j)) (fun _ _ _ _ h => hcomm h _ _)\n    = ϕ i y\n  rw [← Finset.insert_erase (Finset.mem_univ i)]\n  rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ (Finset.not_mem_erase i _)]\n  rw [Pi.mulSingle_eq_same]\n  rw [Finset.noncommProd_eq_pow_card]\n  · rw [one_pow]\n    exact mul_one _\n  · intro j hj\n    simp only [Finset.mem_erase] at hj\n    simp [hj]\n\n"}
{"name":"AddMonoidHom.noncommPiCoprod_mrange","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → AddMonoid (N i)\nϕ : (i : ι) → AddMonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), AddCommute ((ϕ i) x) ((ϕ j) y)\n⊢ Eq (AddMonoidHom.mrange (AddMonoidHom.noncommPiCoprod ϕ hcomm)) (iSup fun i => AddMonoidHom.mrange (ϕ i))","decl":"@[to_additive]\ntheorem noncommPiCoprod_mrange :\n    MonoidHom.mrange (noncommPiCoprod ϕ hcomm) = ⨆ i : ι, MonoidHom.mrange (ϕ i) := by\n  letI := Classical.decEq ι\n  apply le_antisymm\n  · rintro x ⟨f, rfl⟩\n    refine Submonoid.noncommProd_mem _ _ _ (fun _ _ _ _ h => hcomm h _ _) (fun i _ => ?_)\n    apply Submonoid.mem_sSup_of_mem\n    · use i\n    simp\n  · refine iSup_le ?_\n    rintro i x ⟨y, rfl⟩\n    exact ⟨Pi.mulSingle i y, noncommPiCoprod_mulSingle _ _ _⟩\n\n"}
{"name":"MonoidHom.noncommPiCoprod_mrange","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → Monoid (N i)\nϕ : (i : ι) → MonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), Commute ((ϕ i) x) ((ϕ j) y)\n⊢ Eq (MonoidHom.mrange (MonoidHom.noncommPiCoprod ϕ hcomm)) (iSup fun i => MonoidHom.mrange (ϕ i))","decl":"@[to_additive]\ntheorem noncommPiCoprod_mrange :\n    MonoidHom.mrange (noncommPiCoprod ϕ hcomm) = ⨆ i : ι, MonoidHom.mrange (ϕ i) := by\n  letI := Classical.decEq ι\n  apply le_antisymm\n  · rintro x ⟨f, rfl⟩\n    refine Submonoid.noncommProd_mem _ _ _ (fun _ _ _ _ h => hcomm h _ _) (fun i _ => ?_)\n    apply Submonoid.mem_sSup_of_mem\n    · use i\n    simp\n  · refine iSup_le ?_\n    rintro i x ⟨y, rfl⟩\n    exact ⟨Pi.mulSingle i y, noncommPiCoprod_mulSingle _ _ _⟩\n\n"}
{"name":"MonoidHom.commute_noncommPiCoprod","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → Monoid (N i)\nϕ : (i : ι) → MonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), Commute ((ϕ i) x) ((ϕ j) y)\nm : M\ncomm : ∀ (i : ι) (x : N i), Commute m ((ϕ i) x)\nh : (i : ι) → N i\n⊢ Commute m ((MonoidHom.noncommPiCoprod ϕ hcomm) h)","decl":"@[to_additive]\nlemma commute_noncommPiCoprod {m : M}\n    (comm : ∀ i (x : N i), Commute m ((ϕ i x))) (h : (i : ι) → N i) :\n    Commute m (MonoidHom.noncommPiCoprod ϕ hcomm h) := by\n  dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]\n  apply Finset.noncommProd_induction\n  · exact fun x y ↦ Commute.mul_right\n  · exact Commute.one_right _\n  · exact fun x _ ↦ comm x (h x)\n\n"}
{"name":"AddMonoidHom.addCommute_noncommPiCoprod","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → AddMonoid (N i)\nϕ : (i : ι) → AddMonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), AddCommute ((ϕ i) x) ((ϕ j) y)\nm : M\ncomm : ∀ (i : ι) (x : N i), AddCommute m ((ϕ i) x)\nh : (i : ι) → N i\n⊢ AddCommute m ((AddMonoidHom.noncommPiCoprod ϕ hcomm) h)","decl":"@[to_additive]\nlemma commute_noncommPiCoprod {m : M}\n    (comm : ∀ i (x : N i), Commute m ((ϕ i x))) (h : (i : ι) → N i) :\n    Commute m (MonoidHom.noncommPiCoprod ϕ hcomm h) := by\n  dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]\n  apply Finset.noncommProd_induction\n  · exact fun x y ↦ Commute.mul_right\n  · exact Commute.one_right _\n  · exact fun x _ ↦ comm x (h x)\n\n"}
{"name":"AddMonoidHom.noncommPiCoprod_apply","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → AddMonoid (N i)\nϕ : (i : ι) → AddMonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), AddCommute ((ϕ i) x) ((ϕ j) y)\nh : (i : ι) → N i\n⊢ Eq ((AddMonoidHom.noncommPiCoprod ϕ hcomm) h) (Finset.univ.noncommSum (fun i => (ϕ i) (h i)) ⋯)","decl":"@[to_additive]\nlemma noncommPiCoprod_apply (h : (i : ι) → N i) :\n    MonoidHom.noncommPiCoprod ϕ hcomm h = Finset.noncommProd Finset.univ (fun i ↦ ϕ i (h i))\n      (Pairwise.set_pairwise (fun ⦃i j⦄ a ↦ hcomm a (h i) (h j)) _) := by\n  dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]\n\n"}
{"name":"MonoidHom.noncommPiCoprod_apply","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"M : Type u_1\ninst✝² : Monoid M\nι : Type u_2\ninst✝¹ : Fintype ι\nN : ι → Type u_3\ninst✝ : (i : ι) → Monoid (N i)\nϕ : (i : ι) → MonoidHom (N i) M\nhcomm : Pairwise fun i j => ∀ (x : N i) (y : N j), Commute ((ϕ i) x) ((ϕ j) y)\nh : (i : ι) → N i\n⊢ Eq ((MonoidHom.noncommPiCoprod ϕ hcomm) h) (Finset.univ.noncommProd (fun i => (ϕ i) (h i)) ⋯)","decl":"@[to_additive]\nlemma noncommPiCoprod_apply (h : (i : ι) → N i) :\n    MonoidHom.noncommPiCoprod ϕ hcomm h = Finset.noncommProd Finset.univ (fun i ↦ ϕ i (h i))\n      (Pairwise.set_pairwise (fun ⦃i j⦄ a ↦ hcomm a (h i) (h j)) _) := by\n  dsimp only [MonoidHom.noncommPiCoprod, MonoidHom.coe_mk, OneHom.coe_mk]\n\n"}
{"name":"MonoidHom.noncommPiCoprod_range","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : Group G\nι : Type u_2\nH : ι → Type u_3\ninst✝¹ : (i : ι) → Group (H i)\nϕ : (i : ι) → MonoidHom (H i) G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), Commute ((ϕ i) x) ((ϕ j) y)\n⊢ Eq (MonoidHom.noncommPiCoprod ϕ hcomm).range (iSup fun i => (ϕ i).range)","decl":"@[to_additive]\ntheorem noncommPiCoprod_range [Fintype ι]\n    {hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y)} :\n    (noncommPiCoprod ϕ hcomm).range = ⨆ i : ι, (ϕ i).range := by\n  letI := Classical.decEq ι\n  apply le_antisymm\n  · rintro x ⟨f, rfl⟩\n    refine Subgroup.noncommProd_mem _ (fun _ _ _ _ h => hcomm h _ _) ?_\n    intro i _hi\n    apply Subgroup.mem_sSup_of_mem\n    · use i\n    simp\n  · refine iSup_le ?_\n    rintro i x ⟨y, rfl⟩\n    exact ⟨Pi.mulSingle i y, noncommPiCoprod_mulSingle _ _ _⟩\n\n"}
{"name":"AddMonoidHom.noncommPiCoprod_range","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nι : Type u_2\nH : ι → Type u_3\ninst✝¹ : (i : ι) → AddGroup (H i)\nϕ : (i : ι) → AddMonoidHom (H i) G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), AddCommute ((ϕ i) x) ((ϕ j) y)\n⊢ Eq (AddMonoidHom.noncommPiCoprod ϕ hcomm).range (iSup fun i => (ϕ i).range)","decl":"@[to_additive]\ntheorem noncommPiCoprod_range [Fintype ι]\n    {hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y)} :\n    (noncommPiCoprod ϕ hcomm).range = ⨆ i : ι, (ϕ i).range := by\n  letI := Classical.decEq ι\n  apply le_antisymm\n  · rintro x ⟨f, rfl⟩\n    refine Subgroup.noncommProd_mem _ (fun _ _ _ _ h => hcomm h _ _) ?_\n    intro i _hi\n    apply Subgroup.mem_sSup_of_mem\n    · use i\n    simp\n  · refine iSup_le ?_\n    rintro i x ⟨y, rfl⟩\n    exact ⟨Pi.mulSingle i y, noncommPiCoprod_mulSingle _ _ _⟩\n\n"}
{"name":"MonoidHom.injective_noncommPiCoprod_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : Group G\nι : Type u_2\nH : ι → Type u_3\ninst✝¹ : (i : ι) → Group (H i)\nϕ : (i : ι) → MonoidHom (H i) G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), Commute ((ϕ i) x) ((ϕ j) y)\nhind : iSupIndep fun i => (ϕ i).range\nhinj : ∀ (i : ι), Function.Injective ⇑(ϕ i)\n⊢ Function.Injective ⇑(MonoidHom.noncommPiCoprod ϕ hcomm)","decl":"@[to_additive]\ntheorem injective_noncommPiCoprod_of_iSupIndep [Fintype ι]\n    {hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y)}\n    (hind : iSupIndep fun i => (ϕ i).range)\n    (hinj : ∀ i, Function.Injective (ϕ i)) : Function.Injective (noncommPiCoprod ϕ hcomm) := by\n  classical\n    apply (MonoidHom.ker_eq_bot_iff _).mp\n    rw [eq_bot_iff]\n    intro f heq1\n    have : ∀ i, i ∈ Finset.univ → ϕ i (f i) = 1 :=\n      Subgroup.eq_one_of_noncommProd_eq_one_of_iSupIndep _ _ (fun _ _ _ _ h => hcomm h _ _)\n        _ hind (by simp) heq1\n    ext i\n    apply hinj\n    simp [this i (Finset.mem_univ i)]\n\n"}
{"name":"AddMonoidHom.injective_noncommPiCoprod_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nι : Type u_2\nH : ι → Type u_3\ninst✝¹ : (i : ι) → AddGroup (H i)\nϕ : (i : ι) → AddMonoidHom (H i) G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), AddCommute ((ϕ i) x) ((ϕ j) y)\nhind : iSupIndep fun i => (ϕ i).range\nhinj : ∀ (i : ι), Function.Injective ⇑(ϕ i)\n⊢ Function.Injective ⇑(AddMonoidHom.noncommPiCoprod ϕ hcomm)","decl":"@[to_additive]\ntheorem injective_noncommPiCoprod_of_iSupIndep [Fintype ι]\n    {hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y)}\n    (hind : iSupIndep fun i => (ϕ i).range)\n    (hinj : ∀ i, Function.Injective (ϕ i)) : Function.Injective (noncommPiCoprod ϕ hcomm) := by\n  classical\n    apply (MonoidHom.ker_eq_bot_iff _).mp\n    rw [eq_bot_iff]\n    intro f heq1\n    have : ∀ i, i ∈ Finset.univ → ϕ i (f i) = 1 :=\n      Subgroup.eq_one_of_noncommProd_eq_one_of_iSupIndep _ _ (fun _ _ _ _ h => hcomm h _ _)\n        _ hind (by simp) heq1\n    ext i\n    apply hinj\n    simp [this i (Finset.mem_univ i)]\n\n"}
{"name":"MonoidHom.injective_noncommPiCoprod_of_independent","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : Group G\nι : Type u_2\nH : ι → Type u_3\ninst✝¹ : (i : ι) → Group (H i)\nϕ : (i : ι) → MonoidHom (H i) G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), Commute ((ϕ i) x) ((ϕ j) y)\nhind : iSupIndep fun i => (ϕ i).range\nhinj : ∀ (i : ι), Function.Injective ⇑(ϕ i)\n⊢ Function.Injective ⇑(MonoidHom.noncommPiCoprod ϕ hcomm)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias injective_noncommPiCoprod_of_independent := injective_noncommPiCoprod_of_iSupIndep\n\n"}
{"name":"MonoidHom.independent_range_of_coprime_order","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝³ : Group G\nι : Type u_2\nH : ι → Type u_3\ninst✝² : (i : ι) → Group (H i)\nϕ : (i : ι) → MonoidHom (H i) G\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), Commute ((ϕ i) x) ((ϕ j) y)\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Fintype (H i)\nhcoprime : Pairwise fun i j => (Fintype.card (H i)).Coprime (Fintype.card (H j))\n⊢ iSupIndep fun i => (ϕ i).range","decl":"@[to_additive]\ntheorem independent_range_of_coprime_order\n    (hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y))\n    [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : Pairwise fun i j => Nat.Coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    iSupIndep fun i => (ϕ i).range := by\n  cases nonempty_fintype ι\n  letI := Classical.decEq ι\n  rintro i\n  rw [disjoint_iff_inf_le]\n  rintro f ⟨hxi, hxp⟩\n  dsimp at hxi hxp\n  rw [iSup_subtype', ← noncommPiCoprod_range] at hxp\n  rotate_left\n  · intro _ _ hj\n    apply hcomm\n    exact hj ∘ Subtype.ext\n  cases' hxp with g hgf\n  cases' hxi with g' hg'f\n  have hxi : orderOf f ∣ Fintype.card (H i) := by\n    rw [← hg'f]\n    exact (orderOf_map_dvd _ _).trans orderOf_dvd_card\n  have hxp : orderOf f ∣ ∏ j : { j // j ≠ i }, Fintype.card (H j) := by\n    rw [← hgf, ← Fintype.card_pi]\n    exact (orderOf_map_dvd _ _).trans orderOf_dvd_card\n  change f = 1\n  rw [← pow_one f, ← orderOf_dvd_iff_pow_eq_one]\n  -- Porting note: ouch, had to replace an ugly `convert`\n  obtain ⟨c, hc⟩ := Nat.dvd_gcd hxp hxi\n  use c\n  rw [← hc]\n  symm\n  rw [← Nat.coprime_iff_gcd_eq_one, Nat.coprime_fintype_prod_left_iff, Subtype.forall]\n  intro j h\n  exact hcoprime h\n\n"}
{"name":"AddMonoidHom.independent_range_of_coprime_order","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nι : Type u_2\nH : ι → Type u_3\ninst✝² : (i : ι) → AddGroup (H i)\nϕ : (i : ι) → AddMonoidHom (H i) G\nhcomm : Pairwise fun i j => ∀ (x : H i) (y : H j), AddCommute ((ϕ i) x) ((ϕ j) y)\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Fintype (H i)\nhcoprime : Pairwise fun i j => (Fintype.card (H i)).Coprime (Fintype.card (H j))\n⊢ iSupIndep fun i => (ϕ i).range","decl":"@[to_additive]\ntheorem independent_range_of_coprime_order\n    (hcomm : Pairwise fun i j : ι => ∀ (x : H i) (y : H j), Commute (ϕ i x) (ϕ j y))\n    [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : Pairwise fun i j => Nat.Coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    iSupIndep fun i => (ϕ i).range := by\n  cases nonempty_fintype ι\n  letI := Classical.decEq ι\n  rintro i\n  rw [disjoint_iff_inf_le]\n  rintro f ⟨hxi, hxp⟩\n  dsimp at hxi hxp\n  rw [iSup_subtype', ← noncommPiCoprod_range] at hxp\n  rotate_left\n  · intro _ _ hj\n    apply hcomm\n    exact hj ∘ Subtype.ext\n  cases' hxp with g hgf\n  cases' hxi with g' hg'f\n  have hxi : orderOf f ∣ Fintype.card (H i) := by\n    rw [← hg'f]\n    exact (orderOf_map_dvd _ _).trans orderOf_dvd_card\n  have hxp : orderOf f ∣ ∏ j : { j // j ≠ i }, Fintype.card (H j) := by\n    rw [← hgf, ← Fintype.card_pi]\n    exact (orderOf_map_dvd _ _).trans orderOf_dvd_card\n  change f = 1\n  rw [← pow_one f, ← orderOf_dvd_iff_pow_eq_one]\n  -- Porting note: ouch, had to replace an ugly `convert`\n  obtain ⟨c, hc⟩ := Nat.dvd_gcd hxp hxi\n  use c\n  rw [← hc]\n  symm\n  rw [← Nat.coprime_iff_gcd_eq_one, Nat.coprime_fintype_prod_left_iff, Subtype.forall]\n  intro j h\n  exact hcoprime h\n\n"}
{"name":"AddSubgroup.addCommute_subtype_of_addCommute","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\ni j : ι\nhne : Ne i j\nx : Subtype fun x => Membership.mem (H i) x\ny : Subtype fun x => Membership.mem (H j) x\n⊢ AddCommute ((H i).subtype x) ((H j).subtype y)","decl":"@[to_additive]\ntheorem commute_subtype_of_commute\n    (hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y) (i j : ι)\n    (hne : i ≠ j) :\n    ∀ (x : H i) (y : H j), Commute ((H i).subtype x) ((H j).subtype y) := by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  exact hcomm hne x y hx hy\n\n"}
{"name":"Subgroup.commute_subtype_of_commute","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_2\nH : ι → Subgroup G\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\ni j : ι\nhne : Ne i j\nx : Subtype fun x => Membership.mem (H i) x\ny : Subtype fun x => Membership.mem (H j) x\n⊢ Commute ((H i).subtype x) ((H j).subtype y)","decl":"@[to_additive]\ntheorem commute_subtype_of_commute\n    (hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y) (i j : ι)\n    (hne : i ≠ j) :\n    ∀ (x : H i) (y : H j), Commute ((H i).subtype x) ((H j).subtype y) := by\n  rintro ⟨x, hx⟩ ⟨y, hy⟩\n  exact hcomm hne x y hx hy\n\n"}
{"name":"AddSubgroup.independent_of_coprime_order","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Fintype (Subtype fun x => Membership.mem (H i) x)\nhcoprime : Pairwise fun i j => (Fintype.card (Subtype fun x => Membership.mem (H i) x)).Coprime (Fintype.card (Subtype fun x => Membership.mem (H j) x))\n⊢ iSupIndep H","decl":"@[to_additive]\ntheorem independent_of_coprime_order\n    (hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y)\n    [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : Pairwise fun i j => Nat.Coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    iSupIndep H := by\n  simpa using\n    MonoidHom.independent_range_of_coprime_order (fun i => (H i).subtype)\n      (commute_subtype_of_commute hcomm) hcoprime\n\n"}
{"name":"Subgroup.independent_of_coprime_order","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : Group G\nι : Type u_2\nH : ι → Subgroup G\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\ninst✝¹ : Finite ι\ninst✝ : (i : ι) → Fintype (Subtype fun x => Membership.mem (H i) x)\nhcoprime : Pairwise fun i j => (Fintype.card (Subtype fun x => Membership.mem (H i) x)).Coprime (Fintype.card (Subtype fun x => Membership.mem (H j) x))\n⊢ iSupIndep H","decl":"@[to_additive]\ntheorem independent_of_coprime_order\n    (hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y)\n    [Finite ι] [∀ i, Fintype (H i)]\n    (hcoprime : Pairwise fun i j => Nat.Coprime (Fintype.card (H i)) (Fintype.card (H j))) :\n    iSupIndep H := by\n  simpa using\n    MonoidHom.independent_range_of_coprime_order (fun i => (H i).subtype)\n      (commute_subtype_of_commute hcomm) hcoprime\n\n"}
{"name":"AddSubgroup.noncommPiCoprod_single","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\ni : ι\ny : Subtype fun x => Membership.mem (H i) x\n⊢ Eq ((AddSubgroup.noncommPiCoprod hcomm) (Pi.single i y)) ↑y","decl":"@[to_additive (attr := simp)]\ntheorem noncommPiCoprod_mulSingle [DecidableEq ι]\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y}(i : ι) (y : H i) :\n    noncommPiCoprod hcomm (Pi.mulSingle i y) = y := by apply MonoidHom.noncommPiCoprod_mulSingle\n\n"}
{"name":"Subgroup.noncommPiCoprod_mulSingle","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝² : Group G\nι : Type u_2\nH : ι → Subgroup G\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\ni : ι\ny : Subtype fun x => Membership.mem (H i) x\n⊢ Eq ((Subgroup.noncommPiCoprod hcomm) (Pi.mulSingle i y)) ↑y","decl":"@[to_additive (attr := simp)]\ntheorem noncommPiCoprod_mulSingle [DecidableEq ι]\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y}(i : ι) (y : H i) :\n    noncommPiCoprod hcomm (Pi.mulSingle i y) = y := by apply MonoidHom.noncommPiCoprod_mulSingle\n\n"}
{"name":"Subgroup.noncommPiCoprod_range","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\n⊢ Eq (Subgroup.noncommPiCoprod hcomm).range (iSup fun i => H i)","decl":"@[to_additive]\ntheorem noncommPiCoprod_range\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y} :\n    (noncommPiCoprod hcomm).range = ⨆ i : ι, H i := by\n  simp [noncommPiCoprod, MonoidHom.noncommPiCoprod_range]\n\n"}
{"name":"AddSubgroup.noncommPiCoprod_range","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\n⊢ Eq (AddSubgroup.noncommPiCoprod hcomm).range (iSup fun i => H i)","decl":"@[to_additive]\ntheorem noncommPiCoprod_range\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y} :\n    (noncommPiCoprod hcomm).range = ⨆ i : ι, H i := by\n  simp [noncommPiCoprod, MonoidHom.noncommPiCoprod_range]\n\n"}
{"name":"Subgroup.injective_noncommPiCoprod_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\nhind : iSupIndep H\n⊢ Function.Injective ⇑(Subgroup.noncommPiCoprod hcomm)","decl":"@[to_additive]\ntheorem injective_noncommPiCoprod_of_iSupIndep\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y}\n    (hind : iSupIndep H) :\n    Function.Injective (noncommPiCoprod hcomm) := by\n  apply MonoidHom.injective_noncommPiCoprod_of_iSupIndep\n  · simpa using hind\n  · intro i\n    exact Subtype.coe_injective\n\n"}
{"name":"AddSubgroup.injective_noncommPiCoprod_of_iSupIndep","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ninst✝ : Fintype ι\nhcomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\nhind : iSupIndep H\n⊢ Function.Injective ⇑(AddSubgroup.noncommPiCoprod hcomm)","decl":"@[to_additive]\ntheorem injective_noncommPiCoprod_of_iSupIndep\n    {hcomm : Pairwise fun i j : ι => ∀ x y : G, x ∈ H i → y ∈ H j → Commute x y}\n    (hind : iSupIndep H) :\n    Function.Injective (noncommPiCoprod hcomm) := by\n  apply MonoidHom.injective_noncommPiCoprod_of_iSupIndep\n  · simpa using hind\n  · intro i\n    exact Subtype.coe_injective\n\n"}
{"name":"AddSubgroup.noncommPiCoprod_apply","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nι : Type u_2\nH : ι → AddSubgroup G\ninst✝ : Fintype ι\ncomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → AddCommute x y\nu : (i : ι) → Subtype fun x => Membership.mem (H i) x\n⊢ Eq ((AddSubgroup.noncommPiCoprod comm) u) (Finset.univ.noncommSum (fun i => ↑(u i)) ⋯)","decl":"@[to_additive]\ntheorem noncommPiCoprod_apply (comm) (u : (i : ι) → H i) :\n    Subgroup.noncommPiCoprod comm u = Finset.noncommProd Finset.univ (fun i ↦ u i)\n      (fun i _ j _ h ↦ comm h _ _ (u i).prop (u j).prop) := by\n  simp only [Subgroup.noncommPiCoprod, MonoidHom.noncommPiCoprod,\n    coeSubtype, MonoidHom.coe_mk, OneHom.coe_mk]\n\n"}
{"name":"Subgroup.noncommPiCoprod_apply","module":"Mathlib.GroupTheory.NoncommPiCoprod","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nι : Type u_2\nH : ι → Subgroup G\ninst✝ : Fintype ι\ncomm : Pairwise fun i j => ∀ (x y : G), Membership.mem (H i) x → Membership.mem (H j) y → Commute x y\nu : (i : ι) → Subtype fun x => Membership.mem (H i) x\n⊢ Eq ((Subgroup.noncommPiCoprod comm) u) (Finset.univ.noncommProd (fun i => ↑(u i)) ⋯)","decl":"@[to_additive]\ntheorem noncommPiCoprod_apply (comm) (u : (i : ι) → H i) :\n    Subgroup.noncommPiCoprod comm u = Finset.noncommProd Finset.univ (fun i ↦ u i)\n      (fun i _ j _ h ↦ comm h _ _ (u i).prop (u j).prop) := by\n  simp only [Subgroup.noncommPiCoprod, MonoidHom.noncommPiCoprod,\n    coeSubtype, MonoidHom.coe_mk, OneHom.coe_mk]\n\n"}
