{"name":"Metric.isBounded_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\n⊢ Bornology.IsBounded (Metric.closedBall x r)","decl":"/-- Closed balls are bounded -/\ntheorem isBounded_closedBall : IsBounded (closedBall x r) :=\n  isBounded_iff.2 ⟨r + r, fun y hy z hz =>\n    calc dist y z ≤ dist y x + dist z x := dist_triangle_right _ _ _\n    _ ≤ r + r := add_le_add hy hz⟩\n\n"}
{"name":"Metric.isBounded_ball","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\n⊢ Bornology.IsBounded (Metric.ball x r)","decl":"/-- Open balls are bounded -/\ntheorem isBounded_ball : IsBounded (ball x r) :=\n  isBounded_closedBall.subset ball_subset_closedBall\n\n"}
{"name":"Metric.isBounded_sphere","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\n⊢ Bornology.IsBounded (Metric.sphere x r)","decl":"/-- Spheres are bounded -/\ntheorem isBounded_sphere : IsBounded (sphere x r) :=\n  isBounded_closedBall.subset sphere_subset_closedBall\n\n"}
{"name":"Metric.isBounded_iff_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nc : α\n⊢ Iff (Bornology.IsBounded s) (Exists fun r => HasSubset.Subset s (Metric.closedBall c r))","decl":"/-- Given a point, a bounded subset is included in some ball around this point -/\ntheorem isBounded_iff_subset_closedBall (c : α) : IsBounded s ↔ ∃ r, s ⊆ closedBall c r :=\n  ⟨fun h ↦ (isBounded_iff.1 (h.insert c)).imp fun _r hr _x hx ↦ hr (.inr hx) (mem_insert _ _),\n    fun ⟨_r, hr⟩ ↦ isBounded_closedBall.subset hr⟩\n\n"}
{"name":"Bornology.IsBounded.subset_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\nc : α\n⊢ Exists fun r => HasSubset.Subset s (Metric.closedBall c r)","decl":"theorem _root_.Bornology.IsBounded.subset_closedBall (h : IsBounded s) (c : α) :\n    ∃ r, s ⊆ closedBall c r :=\n  (isBounded_iff_subset_closedBall c).1 h\n\n"}
{"name":"Bornology.IsBounded.subset_ball_lt","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\na : Real\nc : α\n⊢ Exists fun r => And (LT.lt a r) (HasSubset.Subset s (Metric.ball c r))","decl":"theorem _root_.Bornology.IsBounded.subset_ball_lt (h : IsBounded s) (a : ℝ) (c : α) :\n    ∃ r, a < r ∧ s ⊆ ball c r :=\n  let ⟨r, hr⟩ := h.subset_closedBall c\n  ⟨max r a + 1, (le_max_right _ _).trans_lt (lt_add_one _), hr.trans <| closedBall_subset_ball <|\n    (le_max_left _ _).trans_lt (lt_add_one _)⟩\n\n"}
{"name":"Bornology.IsBounded.subset_ball","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\nc : α\n⊢ Exists fun r => HasSubset.Subset s (Metric.ball c r)","decl":"theorem _root_.Bornology.IsBounded.subset_ball (h : IsBounded s) (c : α) : ∃ r, s ⊆ ball c r :=\n  (h.subset_ball_lt 0 c).imp fun _ ↦ And.right\n\n"}
{"name":"Metric.isBounded_iff_subset_ball","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nc : α\n⊢ Iff (Bornology.IsBounded s) (Exists fun r => HasSubset.Subset s (Metric.ball c r))","decl":"theorem isBounded_iff_subset_ball (c : α) : IsBounded s ↔ ∃ r, s ⊆ ball c r :=\n  ⟨(IsBounded.subset_ball · c), fun ⟨_r, hr⟩ ↦ isBounded_ball.subset hr⟩\n\n"}
{"name":"Bornology.IsBounded.subset_closedBall_lt","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\na : Real\nc : α\n⊢ Exists fun r => And (LT.lt a r) (HasSubset.Subset s (Metric.closedBall c r))","decl":"theorem _root_.Bornology.IsBounded.subset_closedBall_lt (h : IsBounded s) (a : ℝ) (c : α) :\n    ∃ r, a < r ∧ s ⊆ closedBall c r :=\n  let ⟨r, har, hr⟩ := h.subset_ball_lt a c\n  ⟨r, har, hr.trans ball_subset_closedBall⟩\n\n"}
{"name":"Metric.isBounded_closure_of_isBounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\n⊢ Bornology.IsBounded (closure s)","decl":"theorem isBounded_closure_of_isBounded (h : IsBounded s) : IsBounded (closure s) :=\n  let ⟨C, h⟩ := isBounded_iff.1 h\n  isBounded_iff.2 ⟨C, fun _a ha _b hb => isClosed_Iic.closure_subset <|\n    map_mem_closure₂ continuous_dist ha hb h⟩\n\n"}
{"name":"Bornology.IsBounded.closure","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Bornology.IsBounded s\n⊢ Bornology.IsBounded (closure s)","decl":"protected theorem _root_.Bornology.IsBounded.closure (h : IsBounded s) : IsBounded (closure s) :=\n  isBounded_closure_of_isBounded h\n\n"}
{"name":"Metric.isBounded_closure_iff","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Bornology.IsBounded (closure s)) (Bornology.IsBounded s)","decl":"@[simp]\ntheorem isBounded_closure_iff : IsBounded (closure s) ↔ IsBounded s :=\n  ⟨fun h => h.subset subset_closure, fun h => h.closure⟩\n\n"}
{"name":"Metric.hasBasis_cobounded_compl_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ (Bornology.cobounded α).HasBasis (fun x => True) fun r => HasCompl.compl (Metric.closedBall c r)","decl":"theorem hasBasis_cobounded_compl_closedBall (c : α) :\n    (cobounded α).HasBasis (fun _ ↦ True) (fun r ↦ (closedBall c r)ᶜ) :=\n  ⟨compl_surjective.forall.2 fun _ ↦ (isBounded_iff_subset_closedBall c).trans <| by simp⟩\n\n"}
{"name":"Metric.hasBasis_cobounded_compl_ball","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ (Bornology.cobounded α).HasBasis (fun x => True) fun r => HasCompl.compl (Metric.ball c r)","decl":"theorem hasBasis_cobounded_compl_ball (c : α) :\n    (cobounded α).HasBasis (fun _ ↦ True) (fun r ↦ (ball c r)ᶜ) :=\n  ⟨compl_surjective.forall.2 fun _ ↦ (isBounded_iff_subset_ball c).trans <| by simp⟩\n\n"}
{"name":"Metric.comap_dist_right_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ Eq (Filter.comap (fun x => Dist.dist x c) Filter.atTop) (Bornology.cobounded α)","decl":"@[simp]\ntheorem comap_dist_right_atTop (c : α) : comap (dist · c) atTop = cobounded α :=\n  (atTop_basis.comap _).eq_of_same_basis <| by\n    simpa only [compl_def, mem_ball, not_lt] using hasBasis_cobounded_compl_ball c\n\n"}
{"name":"Metric.comap_dist_left_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ Eq (Filter.comap (Dist.dist c) Filter.atTop) (Bornology.cobounded α)","decl":"@[simp]\ntheorem comap_dist_left_atTop (c : α) : comap (dist c) atTop = cobounded α := by\n  simpa only [dist_comm _ c] using comap_dist_right_atTop c\n\n"}
{"name":"Metric.tendsto_dist_right_atTop_iff","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nc : α\nf : β → α\nl : Filter β\n⊢ Iff (Filter.Tendsto (fun x => Dist.dist (f x) c) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded α))","decl":"@[simp]\ntheorem tendsto_dist_right_atTop_iff (c : α) {f : β → α} {l : Filter β} :\n    Tendsto (fun x ↦ dist (f x) c) l atTop ↔ Tendsto f l (cobounded α) := by\n  rw [← comap_dist_right_atTop c, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Metric.tendsto_dist_left_atTop_iff","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nc : α\nf : β → α\nl : Filter β\n⊢ Iff (Filter.Tendsto (fun x => Dist.dist c (f x)) l Filter.atTop) (Filter.Tendsto f l (Bornology.cobounded α))","decl":"@[simp]\ntheorem tendsto_dist_left_atTop_iff (c : α) {f : β → α} {l : Filter β} :\n    Tendsto (fun x ↦ dist c (f x)) l atTop ↔ Tendsto f l (cobounded α) := by\n  simp only [dist_comm c, tendsto_dist_right_atTop_iff]\n\n"}
{"name":"Metric.tendsto_dist_right_cobounded_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ Filter.Tendsto (fun x => Dist.dist x c) (Bornology.cobounded α) Filter.atTop","decl":"theorem tendsto_dist_right_cobounded_atTop (c : α) : Tendsto (dist · c) (cobounded α) atTop :=\n  tendsto_iff_comap.2 (comap_dist_right_atTop c).ge\n\n"}
{"name":"Metric.tendsto_dist_left_cobounded_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nc : α\n⊢ Filter.Tendsto (Dist.dist c) (Bornology.cobounded α) Filter.atTop","decl":"theorem tendsto_dist_left_cobounded_atTop (c : α) : Tendsto (dist c) (cobounded α) atTop :=\n  tendsto_iff_comap.2 (comap_dist_left_atTop c).ge\n\n"}
{"name":"TotallyBounded.isBounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : TotallyBounded s\n⊢ Bornology.IsBounded s","decl":"/-- A totally bounded set is bounded -/\ntheorem _root_.TotallyBounded.isBounded {s : Set α} (h : TotallyBounded s) : IsBounded s :=\n  -- We cover the totally bounded set by finitely many balls of radius 1,\n  -- and then argue that a finite union of bounded sets is bounded\n  let ⟨_t, fint, subs⟩ := (totallyBounded_iff.mp h) 1 zero_lt_one\n  ((isBounded_biUnion fint).2 fun _ _ => isBounded_ball).subset subs\n\n"}
{"name":"IsCompact.isBounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : IsCompact s\n⊢ Bornology.IsBounded s","decl":"/-- A compact set is bounded -/\ntheorem _root_.IsCompact.isBounded {s : Set α} (h : IsCompact s) : IsBounded s :=\n  -- A compact set is totally bounded, thus bounded\n  h.totallyBounded.isBounded\n\n"}
{"name":"Metric.cobounded_le_cocompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ LE.le (Bornology.cobounded α) (Filter.cocompact α)","decl":"theorem cobounded_le_cocompact : cobounded α ≤ cocompact α :=\n  hasBasis_cocompact.ge_iff.2 fun _s hs ↦ hs.isBounded\n\n"}
{"name":"Metric.isCobounded_iff_closedBall_compl_subset","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nc : α\n⊢ Iff (Bornology.IsCobounded s) (Exists fun r => HasSubset.Subset (HasCompl.compl (Metric.closedBall c r)) s)","decl":"theorem isCobounded_iff_closedBall_compl_subset {s : Set α} (c : α) :\n    IsCobounded s ↔ ∃ (r : ℝ), (Metric.closedBall c r)ᶜ ⊆ s := by\n  rw [← isBounded_compl_iff, isBounded_iff_subset_closedBall c]\n  apply exists_congr\n  intro r\n  rw [compl_subset_comm]\n\n"}
{"name":"Bornology.IsCobounded.closedBall_compl_subset","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : Bornology.IsCobounded s\nc : α\n⊢ Exists fun r => HasSubset.Subset (HasCompl.compl (Metric.closedBall c r)) s","decl":"theorem _root_.Bornology.IsCobounded.closedBall_compl_subset {s : Set α} (hs : IsCobounded s)\n    (c : α) : ∃ (r : ℝ), (Metric.closedBall c r)ᶜ ⊆ s :=\n  (isCobounded_iff_closedBall_compl_subset c).mp hs\n\n"}
{"name":"Metric.closedBall_compl_subset_of_mem_cocompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : Membership.mem (Filter.cocompact α) s\nc : α\n⊢ Exists fun r => HasSubset.Subset (HasCompl.compl (Metric.closedBall c r)) s","decl":"theorem closedBall_compl_subset_of_mem_cocompact {s : Set α} (hs : s ∈ cocompact α) (c : α) :\n    ∃ (r : ℝ), (Metric.closedBall c r)ᶜ ⊆ s :=\n  IsCobounded.closedBall_compl_subset (cobounded_le_cocompact hs) c\n\n"}
{"name":"Metric.mem_cocompact_of_closedBall_compl_subset","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nc : α\nh : Exists fun r => HasSubset.Subset (HasCompl.compl (Metric.closedBall c r)) s\n⊢ Membership.mem (Filter.cocompact α) s","decl":"theorem mem_cocompact_of_closedBall_compl_subset [ProperSpace α] (c : α)\n    (h : ∃ r, (closedBall c r)ᶜ ⊆ s) : s ∈ cocompact α := by\n  rcases h with ⟨r, h⟩\n  rw [Filter.mem_cocompact]\n  exact ⟨closedBall c r, isCompact_closedBall c r, h⟩\n\n"}
{"name":"Metric.mem_cocompact_iff_closedBall_compl_subset","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nc : α\n⊢ Iff (Membership.mem (Filter.cocompact α) s) (Exists fun r => HasSubset.Subset (HasCompl.compl (Metric.closedBall c r)) s)","decl":"theorem mem_cocompact_iff_closedBall_compl_subset [ProperSpace α] (c : α) :\n    s ∈ cocompact α ↔ ∃ r, (closedBall c r)ᶜ ⊆ s :=\n  ⟨(closedBall_compl_subset_of_mem_cocompact · _), mem_cocompact_of_closedBall_compl_subset _⟩\n\n"}
{"name":"Metric.isBounded_range_iff","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\n⊢ Iff (Bornology.IsBounded (Set.range f)) (Exists fun C => ∀ (x y : β), LE.le (Dist.dist (f x) (f y)) C)","decl":"/-- Characterization of the boundedness of the range of a function -/\ntheorem isBounded_range_iff {f : β → α} : IsBounded (range f) ↔ ∃ C, ∀ x y, dist (f x) (f y) ≤ C :=\n  isBounded_iff.trans <| by simp only [forall_mem_range]\n\n"}
{"name":"Metric.isBounded_image_iff","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\ns : Set β\n⊢ Iff (Bornology.IsBounded (Set.image f s)) (Exists fun C => ∀ (x : β), Membership.mem s x → ∀ (y : β), Membership.mem s y → LE.le (Dist.dist (f x) (f y)) C)","decl":"theorem isBounded_image_iff {f : β → α} {s : Set β} :\n    IsBounded (f '' s) ↔ ∃ C, ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ C :=\n  isBounded_iff.trans <| by simp only [forall_mem_image]\n\n"}
{"name":"Metric.isBounded_range_of_tendsto_cofinite_uniformity","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\nhf : Filter.Tendsto (Prod.map f f) (SProd.sprod Filter.cofinite Filter.cofinite) (uniformity α)\n⊢ Bornology.IsBounded (Set.range f)","decl":"theorem isBounded_range_of_tendsto_cofinite_uniformity {f : β → α}\n    (hf : Tendsto (Prod.map f f) (.cofinite ×ˢ .cofinite) (𝓤 α)) : IsBounded (range f) := by\n  rcases (hasBasis_cofinite.prod_self.tendsto_iff uniformity_basis_dist).1 hf 1 zero_lt_one with\n    ⟨s, hsf, hs1⟩\n  rw [← image_union_image_compl_eq_range]\n  refine (hsf.image f).isBounded.union (isBounded_image_iff.2 ⟨1, fun x hx y hy ↦ ?_⟩)\n  exact le_of_lt (hs1 (x, y) ⟨hx, hy⟩)\n\n"}
{"name":"Metric.isBounded_range_of_cauchy_map_cofinite","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\nhf : Cauchy (Filter.map f Filter.cofinite)\n⊢ Bornology.IsBounded (Set.range f)","decl":"theorem isBounded_range_of_cauchy_map_cofinite {f : β → α} (hf : Cauchy (map f cofinite)) :\n    IsBounded (range f) :=\n  isBounded_range_of_tendsto_cofinite_uniformity <| (cauchy_map_iff.1 hf).2\n\n"}
{"name":"CauchySeq.isBounded_range","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : Nat → α\nhf : CauchySeq f\n⊢ Bornology.IsBounded (Set.range f)","decl":"theorem _root_.CauchySeq.isBounded_range {f : ℕ → α} (hf : CauchySeq f) : IsBounded (range f) :=\n  isBounded_range_of_cauchy_map_cofinite <| by rwa [Nat.cofinite_eq_atTop]\n\n"}
{"name":"Metric.isBounded_range_of_tendsto_cofinite","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\na : α\nhf : Filter.Tendsto f Filter.cofinite (nhds a)\n⊢ Bornology.IsBounded (Set.range f)","decl":"theorem isBounded_range_of_tendsto_cofinite {f : β → α} {a : α} (hf : Tendsto f cofinite (𝓝 a)) :\n    IsBounded (range f) :=\n  isBounded_range_of_tendsto_cofinite_uniformity <|\n    (hf.prod_map hf).mono_right <| nhds_prod_eq.symm.trans_le (nhds_le_uniformity a)\n\n"}
{"name":"Metric.isBounded_of_compactSpace","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : CompactSpace α\n⊢ Bornology.IsBounded s","decl":"/-- In a compact space, all sets are bounded -/\ntheorem isBounded_of_compactSpace [CompactSpace α] : IsBounded s :=\n  isCompact_univ.isBounded.subset (subset_univ _)\n\n"}
{"name":"Metric.isBounded_range_of_tendsto","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nu : Nat → α\nx : α\nhu : Filter.Tendsto u Filter.atTop (nhds x)\n⊢ Bornology.IsBounded (Set.range u)","decl":"theorem isBounded_range_of_tendsto (u : ℕ → α) {x : α} (hu : Tendsto u atTop (𝓝 x)) :\n    IsBounded (range u) :=\n  hu.cauchySeq.isBounded_range\n\n"}
{"name":"Metric.disjoint_nhds_cobounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Disjoint (nhds x) (Bornology.cobounded α)","decl":"theorem disjoint_nhds_cobounded (x : α) : Disjoint (𝓝 x) (cobounded α) :=\n  disjoint_of_disjoint_of_mem disjoint_compl_right (ball_mem_nhds _ one_pos) isBounded_ball\n\n"}
{"name":"Metric.disjoint_cobounded_nhds","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Disjoint (Bornology.cobounded α) (nhds x)","decl":"theorem disjoint_cobounded_nhds (x : α) : Disjoint (cobounded α) (𝓝 x) :=\n  (disjoint_nhds_cobounded x).symm\n\n"}
{"name":"Metric.disjoint_nhdsSet_cobounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsCompact s\n⊢ Disjoint (nhdsSet s) (Bornology.cobounded α)","decl":"theorem disjoint_nhdsSet_cobounded {s : Set α} (hs : IsCompact s) : Disjoint (𝓝ˢ s) (cobounded α) :=\n  hs.disjoint_nhdsSet_left.2 fun _ _ ↦ disjoint_nhds_cobounded _\n\n"}
{"name":"Metric.disjoint_cobounded_nhdsSet","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : IsCompact s\n⊢ Disjoint (Bornology.cobounded α) (nhdsSet s)","decl":"theorem disjoint_cobounded_nhdsSet {s : Set α} (hs : IsCompact s) : Disjoint (cobounded α) (𝓝ˢ s) :=\n  (disjoint_nhdsSet_cobounded hs).symm\n\n"}
{"name":"Metric.exists_isBounded_image_of_tendsto","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : PseudoMetricSpace β\nl : Filter α\nf : α → β\nx : β\nhf : Filter.Tendsto f l (nhds x)\n⊢ Exists fun s => And (Membership.mem l s) (Bornology.IsBounded (Set.image f s))","decl":"theorem exists_isBounded_image_of_tendsto {α β : Type*} [PseudoMetricSpace β]\n    {l : Filter α} {f : α → β} {x : β} (hf : Tendsto f l (𝓝 x)) :\n    ∃ s ∈ l, IsBounded (f '' s) :=\n  (l.basis_sets.map f).disjoint_iff_left.mp <| (disjoint_nhds_cobounded x).mono_left hf\n\n"}
{"name":"Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nk s : Set β\nf : β → α\nhk : IsCompact k\nhf : ∀ (x : β), Membership.mem k x → ContinuousWithinAt f s x\n⊢ Exists fun t => And (HasSubset.Subset k t) (And (IsOpen t) (Bornology.IsBounded (Set.image f (Inter.inter t s))))","decl":"/-- If a function is continuous within a set `s` at every point of a compact set `k`, then it is\nbounded on some open neighborhood of `k` in `s`. -/\ntheorem exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt\n    [TopologicalSpace β] {k s : Set β} {f : β → α} (hk : IsCompact k)\n    (hf : ∀ x ∈ k, ContinuousWithinAt f s x) :\n    ∃ t, k ⊆ t ∧ IsOpen t ∧ IsBounded (f '' (t ∩ s)) := by\n  have : Disjoint (𝓝ˢ k ⊓ 𝓟 s) (comap f (cobounded α)) := by\n    rw [disjoint_assoc, inf_comm, hk.disjoint_nhdsSet_left]\n    exact fun x hx ↦ disjoint_left_comm.2 <|\n      tendsto_comap.disjoint (disjoint_cobounded_nhds _) (hf x hx)\n  rcases ((((hasBasis_nhdsSet _).inf_principal _)).disjoint_iff ((basis_sets _).comap _)).1 this\n    with ⟨U, ⟨hUo, hkU⟩, t, ht, hd⟩\n  refine ⟨U, hkU, hUo, (isBounded_compl_iff.2 ht).subset ?_⟩\n  rwa [image_subset_iff, preimage_compl, subset_compl_iff_disjoint_right]\n\n"}
{"name":"Metric.exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nk : Set β\nf : β → α\nhk : IsCompact k\nhf : ∀ (x : β), Membership.mem k x → ContinuousAt f x\n⊢ Exists fun t => And (HasSubset.Subset k t) (And (IsOpen t) (Bornology.IsBounded (Set.image f t)))","decl":"/-- If a function is continuous at every point of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. -/\ntheorem exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt [TopologicalSpace β]\n    {k : Set β} {f : β → α} (hk : IsCompact k) (hf : ∀ x ∈ k, ContinuousAt f x) :\n    ∃ t, k ⊆ t ∧ IsOpen t ∧ IsBounded (f '' t) := by\n  simp_rw [← continuousWithinAt_univ] at hf\n  simpa only [inter_univ] using\n    exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt hk hf\n\n"}
{"name":"Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_continuousOn","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nk s : Set β\nf : β → α\nhk : IsCompact k\nhks : HasSubset.Subset k s\nhf : ContinuousOn f s\n⊢ Exists fun t => And (HasSubset.Subset k t) (And (IsOpen t) (Bornology.IsBounded (Set.image f (Inter.inter t s))))","decl":"/-- If a function is continuous on a set `s` containing a compact set `k`, then it is bounded on\nsome open neighborhood of `k` in `s`. -/\ntheorem exists_isOpen_isBounded_image_inter_of_isCompact_of_continuousOn [TopologicalSpace β]\n    {k s : Set β} {f : β → α} (hk : IsCompact k) (hks : k ⊆ s) (hf : ContinuousOn f s) :\n    ∃ t, k ⊆ t ∧ IsOpen t ∧ IsBounded (f '' (t ∩ s)) :=\n  exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt hk fun x hx =>\n    hf x (hks hx)\n\n"}
{"name":"Metric.exists_isOpen_isBounded_image_of_isCompact_of_continuousOn","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : TopologicalSpace β\nk s : Set β\nf : β → α\nhk : IsCompact k\nhs : IsOpen s\nhks : HasSubset.Subset k s\nhf : ContinuousOn f s\n⊢ Exists fun t => And (HasSubset.Subset k t) (And (IsOpen t) (Bornology.IsBounded (Set.image f t)))","decl":"/-- If a function is continuous on a neighborhood of a compact set `k`, then it is bounded on\nsome open neighborhood of `k`. -/\ntheorem exists_isOpen_isBounded_image_of_isCompact_of_continuousOn [TopologicalSpace β]\n    {k s : Set β} {f : β → α} (hk : IsCompact k) (hs : IsOpen s) (hks : k ⊆ s)\n    (hf : ContinuousOn f s) : ∃ t, k ⊆ t ∧ IsOpen t ∧ IsBounded (f '' t) :=\n  exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt hk fun _x hx =>\n    hf.continuousAt (hs.mem_nhds (hks hx))\n\n"}
{"name":"Metric.isCompact_of_isClosed_isBounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nhc : IsClosed s\nhb : Bornology.IsBounded s\n⊢ IsCompact s","decl":"/-- The **Heine–Borel theorem**: In a proper space, a closed bounded set is compact. -/\ntheorem isCompact_of_isClosed_isBounded [ProperSpace α] (hc : IsClosed s) (hb : IsBounded s) :\n    IsCompact s := by\n  rcases eq_empty_or_nonempty s with (rfl | ⟨x, -⟩)\n  · exact isCompact_empty\n  · rcases hb.subset_closedBall x with ⟨r, hr⟩\n    exact (isCompact_closedBall x r).of_isClosed_subset hc hr\n\n"}
{"name":"Bornology.IsBounded.isCompact_closure","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ns : Set α\ninst✝ : ProperSpace α\nh : Bornology.IsBounded s\n⊢ IsCompact (closure s)","decl":"/-- The **Heine–Borel theorem**: In a proper space, the closure of a bounded set is compact. -/\ntheorem _root_.Bornology.IsBounded.isCompact_closure [ProperSpace α] (h : IsBounded s) :\n    IsCompact (closure s) :=\n  isCompact_of_isClosed_isBounded isClosed_closure h.closure\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: assume `[MetricSpace α]`\n-- instead of `[PseudoMetricSpace α] [T2Space α]`\n"}
{"name":"Metric.isCompact_iff_isClosed_bounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ns : Set α\ninst✝¹ : T2Space α\ninst✝ : ProperSpace α\n⊢ Iff (IsCompact s) (And (IsClosed s) (Bornology.IsBounded s))","decl":"/-- The **Heine–Borel theorem**:\nIn a proper Hausdorff space, a set is compact if and only if it is closed and bounded. -/\ntheorem isCompact_iff_isClosed_bounded [T2Space α] [ProperSpace α] :\n    IsCompact s ↔ IsClosed s ∧ IsBounded s :=\n  ⟨fun h => ⟨h.isClosed, h.isBounded⟩, fun h => isCompact_of_isClosed_isBounded h.1 h.2⟩\n\n"}
{"name":"Metric.compactSpace_iff_isBounded_univ","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\n⊢ Iff (CompactSpace α) (Bornology.IsBounded Set.univ)","decl":"theorem compactSpace_iff_isBounded_univ [ProperSpace α] :\n    CompactSpace α ↔ IsBounded (univ : Set α) :=\n  ⟨@isBounded_of_compactSpace α _ _, fun hb => ⟨isCompact_of_isClosed_isBounded isClosed_univ hb⟩⟩\n\n"}
{"name":"totallyBounded_Icc","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ TotallyBounded (Set.Icc a b)","decl":"theorem _root_.totallyBounded_Icc (a b : α) : TotallyBounded (Icc a b) :=\n  isCompact_Icc.totallyBounded\n\n"}
{"name":"totallyBounded_Ico","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ TotallyBounded (Set.Ico a b)","decl":"theorem _root_.totallyBounded_Ico (a b : α) : TotallyBounded (Ico a b) :=\n  (totallyBounded_Icc a b).subset Ico_subset_Icc_self\n\n"}
{"name":"totallyBounded_Ioc","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ TotallyBounded (Set.Ioc a b)","decl":"theorem _root_.totallyBounded_Ioc (a b : α) : TotallyBounded (Ioc a b) :=\n  (totallyBounded_Icc a b).subset Ioc_subset_Icc_self\n\n"}
{"name":"totallyBounded_Ioo","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ TotallyBounded (Set.Ioo a b)","decl":"theorem _root_.totallyBounded_Ioo (a b : α) : TotallyBounded (Ioo a b) :=\n  (totallyBounded_Icc a b).subset Ioo_subset_Icc_self\n\n"}
{"name":"Metric.isBounded_Icc","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ Bornology.IsBounded (Set.Icc a b)","decl":"theorem isBounded_Icc (a b : α) : IsBounded (Icc a b) :=\n  (totallyBounded_Icc a b).isBounded\n\n"}
{"name":"Metric.isBounded_Ico","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ Bornology.IsBounded (Set.Ico a b)","decl":"theorem isBounded_Ico (a b : α) : IsBounded (Ico a b) :=\n  (totallyBounded_Ico a b).isBounded\n\n"}
{"name":"Metric.isBounded_Ioc","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ Bornology.IsBounded (Set.Ioc a b)","decl":"theorem isBounded_Ioc (a b : α) : IsBounded (Ioc a b) :=\n  (totallyBounded_Ioc a b).isBounded\n\n"}
{"name":"Metric.isBounded_Ioo","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\na b : α\n⊢ Bornology.IsBounded (Set.Ioo a b)","decl":"theorem isBounded_Ioo (a b : α) : IsBounded (Ioo a b) :=\n  (totallyBounded_Ioo a b).isBounded\n\n"}
{"name":"Metric.isBounded_of_bddAbove_of_bddBelow","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Preorder α\ninst✝ : CompactIccSpace α\ns : Set α\nh₁ : BddAbove s\nh₂ : BddBelow s\n⊢ Bornology.IsBounded s","decl":"/-- In a pseudo metric space with a conditionally complete linear order such that the order and the\n    metric structure give the same topology, any order-bounded set is metric-bounded. -/\ntheorem isBounded_of_bddAbove_of_bddBelow {s : Set α} (h₁ : BddAbove s) (h₂ : BddBelow s) :\n    IsBounded s :=\n  let ⟨u, hu⟩ := h₁\n  let ⟨l, hl⟩ := h₂\n  (isBounded_Icc l u).subset (fun _x hx => mem_Icc.mpr ⟨hl hx, hu hx⟩)\n\n"}
{"name":"Metric.diam_nonneg","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ LE.le 0 (Metric.diam s)","decl":"/-- The diameter of a set is always nonnegative -/\ntheorem diam_nonneg : 0 ≤ diam s :=\n  ENNReal.toReal_nonneg\n\n"}
{"name":"Metric.diam_subsingleton","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : s.Subsingleton\n⊢ Eq (Metric.diam s) 0","decl":"theorem diam_subsingleton (hs : s.Subsingleton) : diam s = 0 := by\n  simp only [diam, EMetric.diam_subsingleton hs, ENNReal.zero_toReal]\n\n"}
{"name":"Metric.diam_empty","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ Eq (Metric.diam EmptyCollection.emptyCollection) 0","decl":"/-- The empty set has zero diameter -/\n@[simp]\ntheorem diam_empty : diam (∅ : Set α) = 0 :=\n  diam_subsingleton subsingleton_empty\n\n"}
{"name":"Metric.diam_singleton","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ Eq (Metric.diam (Singleton.singleton x)) 0","decl":"/-- A singleton has zero diameter -/\n@[simp]\ntheorem diam_singleton : diam ({x} : Set α) = 0 :=\n  diam_subsingleton subsingleton_singleton\n\n"}
{"name":"Metric.diam_one","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : One α\n⊢ Eq (Metric.diam 1) 0","decl":"@[to_additive (attr := simp)]\ntheorem diam_one [One α] : diam (1 : Set α) = 0 :=\n  diam_singleton\n\n-- Does not work as a simp-lemma, since {x, y} reduces to (insert y {x})\n"}
{"name":"Metric.diam_zero","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : Zero α\n⊢ Eq (Metric.diam 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem diam_one [One α] : diam (1 : Set α) = 0 :=\n  diam_singleton\n\n-- Does not work as a simp-lemma, since {x, y} reduces to (insert y {x})\n"}
{"name":"Metric.diam_pair","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y : α\n⊢ Eq (Metric.diam (Insert.insert x (Singleton.singleton y))) (Dist.dist x y)","decl":"theorem diam_pair : diam ({x, y} : Set α) = dist x y := by\n  simp only [diam, EMetric.diam_pair, dist_edist]\n\n-- Does not work as a simp-lemma, since {x, y, z} reduces to (insert z (insert y {x}))\n"}
{"name":"Metric.diam_triple","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx y z : α\n⊢ Eq (Metric.diam (Insert.insert x (Insert.insert y (Singleton.singleton z)))) (Max.max (Max.max (Dist.dist x y) (Dist.dist x z)) (Dist.dist y z))","decl":"theorem diam_triple :\n    Metric.diam ({x, y, z} : Set α) = max (max (dist x y) (dist x z)) (dist y z) := by\n  simp only [Metric.diam, EMetric.diam_triple, dist_edist]\n  rw [ENNReal.toReal_max, ENNReal.toReal_max] <;> apply_rules [ne_of_lt, edist_lt_top, max_lt]\n\n"}
{"name":"Metric.ediam_le_of_forall_dist_le","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nC : Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist x y) C\n⊢ LE.le (EMetric.diam s) (ENNReal.ofReal C)","decl":"/-- If the distance between any two points in a set is bounded by some constant `C`,\nthen `ENNReal.ofReal C` bounds the emetric diameter of this set. -/\ntheorem ediam_le_of_forall_dist_le {C : ℝ} (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) :\n    EMetric.diam s ≤ ENNReal.ofReal C :=\n  EMetric.diam_le fun x hx y hy => (edist_dist x y).symm ▸ ENNReal.ofReal_le_ofReal (h x hx y hy)\n\n"}
{"name":"Metric.diam_le_of_forall_dist_le","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nC : Real\nh₀ : LE.le 0 C\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist x y) C\n⊢ LE.le (Metric.diam s) C","decl":"/-- If the distance between any two points in a set is bounded by some non-negative constant,\nthis constant bounds the diameter. -/\ntheorem diam_le_of_forall_dist_le {C : ℝ} (h₀ : 0 ≤ C) (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) :\n    diam s ≤ C :=\n  ENNReal.toReal_le_of_le_ofReal h₀ (ediam_le_of_forall_dist_le h)\n\n"}
{"name":"Metric.diam_le_of_forall_dist_le_of_nonempty","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nhs : s.Nonempty\nC : Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist x y) C\n⊢ LE.le (Metric.diam s) C","decl":"/-- If the distance between any two points in a nonempty set is bounded by some constant,\nthis constant bounds the diameter. -/\ntheorem diam_le_of_forall_dist_le_of_nonempty (hs : s.Nonempty) {C : ℝ}\n    (h : ∀ x ∈ s, ∀ y ∈ s, dist x y ≤ C) : diam s ≤ C :=\n  have h₀ : 0 ≤ C :=\n    let ⟨x, hx⟩ := hs\n    le_trans dist_nonneg (h x hx x hx)\n  diam_le_of_forall_dist_le h₀ h\n\n"}
{"name":"Metric.dist_le_diam_of_mem'","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nh : Ne (EMetric.diam s) Top.top\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (Dist.dist x y) (Metric.diam s)","decl":"/-- The distance between two points in a set is controlled by the diameter of the set. -/\ntheorem dist_le_diam_of_mem' (h : EMetric.diam s ≠ ⊤) (hx : x ∈ s) (hy : y ∈ s) :\n    dist x y ≤ diam s := by\n  rw [diam, dist_edist]\n  exact ENNReal.toReal_mono h <| EMetric.edist_le_diam_of_mem hx hy\n\n"}
{"name":"Metric.isBounded_iff_ediam_ne_top","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Ne (EMetric.diam s) Top.top)","decl":"/-- Characterize the boundedness of a set in terms of the finiteness of its emetric.diameter. -/\ntheorem isBounded_iff_ediam_ne_top : IsBounded s ↔ EMetric.diam s ≠ ⊤ :=\n  isBounded_iff.trans <| Iff.intro\n    (fun ⟨_C, hC⟩ => ne_top_of_le_ne_top ENNReal.ofReal_ne_top <| ediam_le_of_forall_dist_le hC)\n    fun h => ⟨diam s, fun _x hx _y hy => dist_le_diam_of_mem' h hx hy⟩\n\n"}
{"name":"Bornology.IsBounded.ediam_ne_top","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\na✝ : Bornology.IsBounded s\n⊢ Ne (EMetric.diam s) Top.top","decl":"alias ⟨_root_.Bornology.IsBounded.ediam_ne_top, _⟩ := isBounded_iff_ediam_ne_top\n\n"}
{"name":"Metric.ediam_eq_top_iff_unbounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\n⊢ Iff (Eq (EMetric.diam s) Top.top) (Not (Bornology.IsBounded s))","decl":"theorem ediam_eq_top_iff_unbounded : EMetric.diam s = ⊤ ↔ ¬IsBounded s :=\n  isBounded_iff_ediam_ne_top.not_left.symm\n\n"}
{"name":"Metric.ediam_univ_eq_top_iff_noncompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\n⊢ Iff (Eq (EMetric.diam Set.univ) Top.top) (NoncompactSpace α)","decl":"theorem ediam_univ_eq_top_iff_noncompact [ProperSpace α] :\n    EMetric.diam (univ : Set α) = ∞ ↔ NoncompactSpace α := by\n  rw [← not_compactSpace_iff, compactSpace_iff_isBounded_univ, isBounded_iff_ediam_ne_top,\n    Classical.not_not]\n\n"}
{"name":"Metric.ediam_univ_of_noncompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\ninst✝ : NoncompactSpace α\n⊢ Eq (EMetric.diam Set.univ) Top.top","decl":"@[simp]\ntheorem ediam_univ_of_noncompact [ProperSpace α] [NoncompactSpace α] :\n    EMetric.diam (univ : Set α) = ∞ :=\n  ediam_univ_eq_top_iff_noncompact.mpr ‹_›\n\n"}
{"name":"Metric.diam_univ_of_noncompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\ninst✝ : NoncompactSpace α\n⊢ Eq (Metric.diam Set.univ) 0","decl":"@[simp]\ntheorem diam_univ_of_noncompact [ProperSpace α] [NoncompactSpace α] : diam (univ : Set α) = 0 := by\n  simp [diam]\n\n"}
{"name":"Metric.dist_le_diam_of_mem","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nh : Bornology.IsBounded s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ LE.le (Dist.dist x y) (Metric.diam s)","decl":"/-- The distance between two points in a set is controlled by the diameter of the set. -/\ntheorem dist_le_diam_of_mem (h : IsBounded s) (hx : x ∈ s) (hy : y ∈ s) : dist x y ≤ diam s :=\n  dist_le_diam_of_mem' h.ediam_ne_top hx hy\n\n"}
{"name":"Metric.ediam_of_unbounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Not (Bornology.IsBounded s)\n⊢ Eq (EMetric.diam s) Top.top","decl":"theorem ediam_of_unbounded (h : ¬IsBounded s) : EMetric.diam s = ∞ := ediam_eq_top_iff_unbounded.2 h\n\n"}
{"name":"Metric.diam_eq_zero_of_unbounded","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nh : Not (Bornology.IsBounded s)\n⊢ Eq (Metric.diam s) 0","decl":"/-- An unbounded set has zero diameter. If you would prefer to get the value ∞, use `EMetric.diam`.\nThis lemma makes it possible to avoid side conditions in some situations -/\ntheorem diam_eq_zero_of_unbounded (h : ¬IsBounded s) : diam s = 0 := by\n  rw [diam, ediam_of_unbounded h, ENNReal.top_toReal]\n\n"}
{"name":"Metric.diam_mono","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nh : HasSubset.Subset s t\nht : Bornology.IsBounded t\n⊢ LE.le (Metric.diam s) (Metric.diam t)","decl":"/-- If `s ⊆ t`, then the diameter of `s` is bounded by that of `t`, provided `t` is bounded. -/\ntheorem diam_mono {s t : Set α} (h : s ⊆ t) (ht : IsBounded t) : diam s ≤ diam t :=\n  ENNReal.toReal_mono ht.ediam_ne_top <| EMetric.diam_mono h\n\n"}
{"name":"Metric.diam_union","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx y : α\nt : Set α\nxs : Membership.mem s x\nyt : Membership.mem t y\n⊢ LE.le (Metric.diam (Union.union s t)) (HAdd.hAdd (HAdd.hAdd (Metric.diam s) (Dist.dist x y)) (Metric.diam t))","decl":"/-- The diameter of a union is controlled by the sum of the diameters, and the distance between\nany two points in each of the sets. This lemma is true without any side condition, since it is\nobviously true if `s ∪ t` is unbounded. -/\ntheorem diam_union {t : Set α} (xs : x ∈ s) (yt : y ∈ t) :\n    diam (s ∪ t) ≤ diam s + dist x y + diam t := by\n  simp only [diam, dist_edist]\n  refine (ENNReal.toReal_le_add' (EMetric.diam_union xs yt) ?_ ?_).trans\n    (add_le_add_right ENNReal.toReal_add_le _)\n  · simp only [ENNReal.add_eq_top, edist_ne_top, or_false]\n    exact fun h ↦ top_unique <| h ▸ EMetric.diam_mono subset_union_left\n  · exact fun h ↦ top_unique <| h ▸ EMetric.diam_mono subset_union_right\n\n"}
{"name":"Metric.diam_union'","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns t : Set α\nh : (Inter.inter s t).Nonempty\n⊢ LE.le (Metric.diam (Union.union s t)) (HAdd.hAdd (Metric.diam s) (Metric.diam t))","decl":"/-- If two sets intersect, the diameter of the union is bounded by the sum of the diameters. -/\ntheorem diam_union' {t : Set α} (h : (s ∩ t).Nonempty) : diam (s ∪ t) ≤ diam s + diam t := by\n  rcases h with ⟨x, ⟨xs, xt⟩⟩\n  simpa using diam_union xs xt\n\n"}
{"name":"Metric.diam_le_of_subset_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nx : α\nr : Real\nhr : LE.le 0 r\nh : HasSubset.Subset s (Metric.closedBall x r)\n⊢ LE.le (Metric.diam s) (HMul.hMul 2 r)","decl":"theorem diam_le_of_subset_closedBall {r : ℝ} (hr : 0 ≤ r) (h : s ⊆ closedBall x r) :\n    diam s ≤ 2 * r :=\n  diam_le_of_forall_dist_le (mul_nonneg zero_le_two hr) fun a ha b hb =>\n    calc\n      dist a b ≤ dist a x + dist b x := dist_triangle_right _ _ _\n      _ ≤ r + r := add_le_add (h ha) (h hb)\n      _ = 2 * r := by simp [mul_two, mul_comm]\n\n"}
{"name":"Metric.diam_closedBall","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\nh : LE.le 0 r\n⊢ LE.le (Metric.diam (Metric.closedBall x r)) (HMul.hMul 2 r)","decl":"/-- The diameter of a closed ball of radius `r` is at most `2 r`. -/\ntheorem diam_closedBall {r : ℝ} (h : 0 ≤ r) : diam (closedBall x r) ≤ 2 * r :=\n  diam_le_of_subset_closedBall h Subset.rfl\n\n"}
{"name":"Metric.diam_ball","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\nr : Real\nh : LE.le 0 r\n⊢ LE.le (Metric.diam (Metric.ball x r)) (HMul.hMul 2 r)","decl":"/-- The diameter of a ball of radius `r` is at most `2 r`. -/\ntheorem diam_ball {r : ℝ} (h : 0 ≤ r) : diam (ball x r) ≤ 2 * r :=\n  diam_le_of_subset_closedBall h ball_subset_closedBall\n\n"}
{"name":"IsComplete.nonempty_iInter_of_nonempty_biInter","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Nat → Set α\nh0 : IsComplete (s 0)\nhs : ∀ (n : Nat), IsClosed (s n)\nh's : ∀ (n : Nat), Bornology.IsBounded (s n)\nh : ∀ (N : Nat), (Set.iInter fun n => Set.iInter fun h => s n).Nonempty\nh' : Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0)\n⊢ (Set.iInter fun n => s n).Nonempty","decl":"/-- If a family of complete sets with diameter tending to `0` is such that each finite intersection\nis nonempty, then the total intersection is also nonempty. -/\ntheorem _root_.IsComplete.nonempty_iInter_of_nonempty_biInter {s : ℕ → Set α}\n    (h0 : IsComplete (s 0)) (hs : ∀ n, IsClosed (s n)) (h's : ∀ n, IsBounded (s n))\n    (h : ∀ N, (⋂ n ≤ N, s n).Nonempty) (h' : Tendsto (fun n => diam (s n)) atTop (𝓝 0)) :\n    (⋂ n, s n).Nonempty := by\n  let u N := (h N).some\n  have I : ∀ n N, n ≤ N → u N ∈ s n := by\n    intro n N hn\n    apply mem_of_subset_of_mem _ (h N).choose_spec\n    intro x hx\n    simp only [mem_iInter] at hx\n    exact hx n hn\n  have : CauchySeq u := by\n    apply cauchySeq_of_le_tendsto_0 _ _ h'\n    intro m n N hm hn\n    exact dist_le_diam_of_mem (h's N) (I _ _ hm) (I _ _ hn)\n  obtain ⟨x, -, xlim⟩ : ∃ x ∈ s 0, Tendsto (fun n : ℕ => u n) atTop (𝓝 x) :=\n    cauchySeq_tendsto_of_isComplete h0 (fun n => I 0 n (zero_le _)) this\n  refine ⟨x, mem_iInter.2 fun n => ?_⟩\n  apply (hs n).mem_of_tendsto xlim\n  filter_upwards [Ici_mem_atTop n] with p hp\n  exact I n p hp\n\n"}
{"name":"Metric.nonempty_iInter_of_nonempty_biInter","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : CompleteSpace α\ns : Nat → Set α\nhs : ∀ (n : Nat), IsClosed (s n)\nh's : ∀ (n : Nat), Bornology.IsBounded (s n)\nh : ∀ (N : Nat), (Set.iInter fun n => Set.iInter fun h => s n).Nonempty\nh' : Filter.Tendsto (fun n => Metric.diam (s n)) Filter.atTop (nhds 0)\n⊢ (Set.iInter fun n => s n).Nonempty","decl":"/-- In a complete space, if a family of closed sets with diameter tending to `0` is such that each\nfinite intersection is nonempty, then the total intersection is also nonempty. -/\ntheorem nonempty_iInter_of_nonempty_biInter [CompleteSpace α] {s : ℕ → Set α}\n    (hs : ∀ n, IsClosed (s n)) (h's : ∀ n, IsBounded (s n)) (h : ∀ N, (⋂ n ≤ N, s n).Nonempty)\n    (h' : Tendsto (fun n => diam (s n)) atTop (𝓝 0)) : (⋂ n, s n).Nonempty :=\n  (hs 0).isComplete.nonempty_iInter_of_nonempty_biInter hs h's h h'\n\n"}
{"name":"Metric.cobounded_eq_cocompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\n⊢ Eq (Bornology.cobounded α) (Filter.cocompact α)","decl":"theorem Metric.cobounded_eq_cocompact [ProperSpace α] : cobounded α = cocompact α := by\n  nontriviality α; inhabit α\n  exact cobounded_le_cocompact.antisymm <| (hasBasis_cobounded_compl_closedBall default).ge_iff.2\n    fun _ _ ↦ (isCompact_closedBall _ _).compl_mem_cocompact\n\n"}
{"name":"tendsto_dist_right_cocompact_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\nx : α\n⊢ Filter.Tendsto (fun x_1 => Dist.dist x_1 x) (Filter.cocompact α) Filter.atTop","decl":"theorem tendsto_dist_right_cocompact_atTop [ProperSpace α] (x : α) :\n    Tendsto (dist · x) (cocompact α) atTop :=\n  (tendsto_dist_right_cobounded_atTop x).mono_left cobounded_eq_cocompact.ge\n\n"}
{"name":"tendsto_dist_left_cocompact_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\nx : α\n⊢ Filter.Tendsto (Dist.dist x) (Filter.cocompact α) Filter.atTop","decl":"theorem tendsto_dist_left_cocompact_atTop [ProperSpace α] (x : α) :\n    Tendsto (dist x) (cocompact α) atTop :=\n  (tendsto_dist_left_cobounded_atTop x).mono_left cobounded_eq_cocompact.ge\n\n"}
{"name":"comap_dist_left_atTop_eq_cocompact","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝¹ : PseudoMetricSpace α\ninst✝ : ProperSpace α\nx : α\n⊢ Eq (Filter.comap (Dist.dist x) Filter.atTop) (Filter.cocompact α)","decl":"theorem comap_dist_left_atTop_eq_cocompact [ProperSpace α] (x : α) :\n    comap (dist x) atTop = cocompact α := by simp [cobounded_eq_cocompact]\n\n"}
{"name":"tendsto_cocompact_of_tendsto_dist_comp_atTop","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\nβ : Type v\ninst✝ : PseudoMetricSpace α\nf : β → α\nl : Filter β\nx : α\nh : Filter.Tendsto (fun y => Dist.dist (f y) x) l Filter.atTop\n⊢ Filter.Tendsto f l (Filter.cocompact α)","decl":"theorem tendsto_cocompact_of_tendsto_dist_comp_atTop {f : β → α} {l : Filter β} (x : α)\n    (h : Tendsto (fun y => dist (f y) x) l atTop) : Tendsto f l (cocompact α) :=\n  ((tendsto_dist_right_atTop_iff _).1 h).mono_right cobounded_le_cocompact\n\n"}
{"name":"Metric.finite_isBounded_inter_isClosed","module":"Mathlib.Topology.MetricSpace.Bounded","initialProofState":"α : Type u\ninst✝² : PseudoMetricSpace α\ninst✝¹ : ProperSpace α\nK s : Set α\ninst✝ : DiscreteTopology ↑s\nhK : Bornology.IsBounded K\nhs : IsClosed s\n⊢ (Inter.inter K s).Finite","decl":"theorem Metric.finite_isBounded_inter_isClosed [ProperSpace α] {K s : Set α} [DiscreteTopology s]\n    (hK : IsBounded K) (hs : IsClosed s) : Set.Finite (K ∩ s) := by\n  refine Set.Finite.subset (IsCompact.finite ?_ ?_) (Set.inter_subset_inter_left s subset_closure)\n  · exact hK.isCompact_closure.inter_right hs\n  · exact DiscreteTopology.of_subset inferInstance Set.inter_subset_right\n"}
