{"name":"MeasureTheory.Measure.MapLinearEquiv.isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"ğ•œ : Type u_1\nG : Type u_2\nH : Type u_3\ninstâœÂ¹â¹ : MeasurableSpace G\ninstâœÂ¹â¸ : MeasurableSpace H\ninstâœÂ¹â· : NontriviallyNormedField ğ•œ\ninstâœÂ¹â¶ : TopologicalSpace G\ninstâœÂ¹âµ : TopologicalSpace H\ninstâœÂ¹â´ : AddCommGroup G\ninstâœÂ¹Â³ : AddCommGroup H\ninstâœÂ¹Â² : TopologicalAddGroup G\ninstâœÂ¹Â¹ : TopologicalAddGroup H\ninstâœÂ¹â° : Module ğ•œ G\ninstâœâ¹ : Module ğ•œ H\nÎ¼ : MeasureTheory.Measure G\ninstâœâ¸ : Î¼.IsAddHaarMeasure\ninstâœâ· : BorelSpace G\ninstâœâ¶ : BorelSpace H\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : T2Space G\ninstâœÂ³ : FiniteDimensional ğ•œ G\ninstâœÂ² : ContinuousSMul ğ•œ G\ninstâœÂ¹ : ContinuousSMul ğ•œ H\ninstâœ : T2Space H\ne : LinearEquiv (RingHom.id ğ•œ) G H\nâŠ¢ (MeasureTheory.Measure.map (â‡‘e) Î¼).IsAddHaarMeasure","decl":"instance MapLinearEquiv.isAddHaarMeasure (e : G â‰ƒâ‚—[ğ•œ] H) : IsAddHaarMeasure (Î¼.map e) :=\n  e.toContinuousLinearEquiv.isAddHaarMeasure_map _\n\n"}
{"name":"AddMonoidHom.exists_nhds_isBounded","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ¸ : MeasurableSpace G\ninstâœâ· : AddGroup G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalAddGroup G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\ninstâœÂ² : MeasurableSpace H\ninstâœÂ¹ : SeminormedAddGroup H\ninstâœ : OpensMeasurableSpace H\nf : AddMonoidHom G H\nhf : Measurable â‡‘f\nx : G\nâŠ¢ Exists fun s => And (Membership.mem (nhds x) s) (Bornology.IsBounded (Set.image (â‡‘f) s))","decl":"open Metric Bornology in\n@[to_additive]\nlemma _root_.MonoidHom.exists_nhds_isBounded (f : G â†’* H) (hf : Measurable f) (x : G) :\n    âˆƒ s âˆˆ ğ“ x, IsBounded (f '' s) := by\n  let K : PositiveCompacts G := Classical.arbitrary _\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, 0 < haar (interior K âˆ© f â»Â¹' ball 1 n) := by\n    by_contra!\n    simp_rw [nonpos_iff_eq_zero, â† measure_iUnion_null_iff, â† inter_iUnion, â† preimage_iUnion,\n      iUnion_ball_nat, preimage_univ, inter_univ] at this\n    exact this.not_gt <| isOpen_interior.measure_pos _ K.interior_nonempty\n  rw [â† one_mul x, â† op_smul_eq_mul]\n  refine âŸ¨_, smul_mem_nhds_smul _ <| div_mem_nhds_one_of_haar_pos_ne_top haar _\n    (isOpen_interior.measurableSet.inter <| hf measurableSet_ball) hn <|\n      mt (measure_mono_top <| inter_subset_left.trans interior_subset) K.isCompact.measure_ne_top,\n    ?_âŸ©\n  have : Bornology.IsBounded (f '' (interior K âˆ© f â»Â¹' ball 1 n)) :=\n    isBounded_ball.subset <| (image_mono inter_subset_right).trans <| image_preimage_subset _ _\n  rw [image_op_smul_distrib, image_div]\n  exact (this.div this).smul _\n\n"}
{"name":"MonoidHom.exists_nhds_isBounded","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ¸ : MeasurableSpace G\ninstâœâ· : Group G\ninstâœâ¶ : TopologicalSpace G\ninstâœâµ : TopologicalGroup G\ninstâœâ´ : BorelSpace G\ninstâœÂ³ : LocallyCompactSpace G\ninstâœÂ² : MeasurableSpace H\ninstâœÂ¹ : SeminormedGroup H\ninstâœ : OpensMeasurableSpace H\nf : MonoidHom G H\nhf : Measurable â‡‘f\nx : G\nâŠ¢ Exists fun s => And (Membership.mem (nhds x) s) (Bornology.IsBounded (Set.image (â‡‘f) s))","decl":"open Metric Bornology in\n@[to_additive]\nlemma _root_.MonoidHom.exists_nhds_isBounded (f : G â†’* H) (hf : Measurable f) (x : G) :\n    âˆƒ s âˆˆ ğ“ x, IsBounded (f '' s) := by\n  let K : PositiveCompacts G := Classical.arbitrary _\n  obtain âŸ¨n, hnâŸ© : âˆƒ n : â„•, 0 < haar (interior K âˆ© f â»Â¹' ball 1 n) := by\n    by_contra!\n    simp_rw [nonpos_iff_eq_zero, â† measure_iUnion_null_iff, â† inter_iUnion, â† preimage_iUnion,\n      iUnion_ball_nat, preimage_univ, inter_univ] at this\n    exact this.not_gt <| isOpen_interior.measure_pos _ K.interior_nonempty\n  rw [â† one_mul x, â† op_smul_eq_mul]\n  refine âŸ¨_, smul_mem_nhds_smul _ <| div_mem_nhds_one_of_haar_pos_ne_top haar _\n    (isOpen_interior.measurableSet.inter <| hf measurableSet_ball) hn <|\n      mt (measure_mono_top <| inter_subset_left.trans interior_subset) K.isCompact.measure_ne_top,\n    ?_âŸ©\n  have : Bornology.IsBounded (f '' (interior K âˆ© f â»Â¹' ball 1 n)) :=\n    isBounded_ball.subset <| (image_mono inter_subset_right).trans <| image_preimage_subset _ _\n  rw [image_op_smul_distrib, image_div]\n  exact (this.div this).smul _\n\n"}
{"name":"MeasureTheory.Measure.AddMonoidHom.continuous_of_measurable","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : MeasurableSpace G\ninstâœâµ : BorelSpace G\ninstâœâ´ : LocallyCompactSpace G\ninstâœÂ³ : SeminormedAddCommGroup H\ninstâœÂ² : MeasurableSpace H\ninstâœÂ¹ : OpensMeasurableSpace H\ninstâœ : NormedSpace Real H\nf : AddMonoidHom G H\nhf : Measurable â‡‘f\nâŠ¢ Continuous â‡‘f","decl":"/-- A Borel-measurable group hom from a locally compact normed group to a real normed space is\ncontinuous. -/\nlemma AddMonoidHom.continuous_of_measurable {G H : Type*}\n    [SeminormedAddCommGroup G] [MeasurableSpace G] [BorelSpace G] [LocallyCompactSpace G]\n    [SeminormedAddCommGroup H] [MeasurableSpace H] [OpensMeasurableSpace H] [NormedSpace â„ H]\n    (f : G â†’+ H) (hf : Measurable f) : Continuous f :=\n  let âŸ¨_s, hs, hbddâŸ© := f.exists_nhds_isBounded hf 0; f.continuous_of_isBounded_nhds_zero hs hbdd\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (abs (Inv.inv (HPow.hPow R (Module.finrank Real E)))) (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- The integral of `f (R â€¢ x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul (f : E â†’ F) (R : â„) :\n    âˆ« x, f (R â€¢ x) âˆ‚Î¼ = |(R ^ finrank â„ E)â»Â¹| â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  by_cases hF : CompleteSpace F; swap\n  Â· simp [integral, hF]\n  rcases eq_or_ne R 0 with (rfl | hR)\n  Â· simp only [zero_smul, integral_const]\n    rcases Nat.eq_zero_or_pos (finrank â„ E) with (hE | hE)\n    Â· have : Subsingleton E := finrank_zero_iff.1 hE\n      have : f = fun _ => f 0 := by ext x; rw [Subsingleton.elim x 0]\n      conv_rhs => rw [this]\n      simp only [hE, pow_zero, inv_one, abs_one, one_smul, integral_const]\n    Â· have : Nontrivial E := finrank_pos_iff.1 hE\n      simp only [zero_pow hE.ne', measure_univ_of_isAddLeftInvariant, ENNReal.top_toReal, zero_smul,\n        inv_zero, abs_zero]\n  Â· calc\n      (âˆ« x, f (R â€¢ x) âˆ‚Î¼) = âˆ« y, f y âˆ‚Measure.map (fun x => R â€¢ x) Î¼ :=\n        (integral_map_equiv (Homeomorph.smul (isUnit_iff_ne_zero.2 hR).unit).toMeasurableEquiv\n            f).symm\n      _ = |(R ^ finrank â„ E)â»Â¹| â€¢ âˆ« x, f x âˆ‚Î¼ := by\n        simp only [map_addHaar_smul Î¼ hR, integral_smul_measure, ENNReal.toReal_ofReal, abs_nonneg]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\nhR : LE.le 0 R\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (Inv.inv (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- The integral of `f (R â€¢ x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul_of_nonneg (f : E â†’ F) (R : â„) {hR : 0 â‰¤ R} :\n    âˆ« x, f (R â€¢ x) âˆ‚Î¼ = (R ^ finrank â„ E)â»Â¹ â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  rw [integral_comp_smul Î¼ f R, abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR _))]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f (HSMul.hSMul (Inv.inv R) x)) (HSMul.hSMul (abs (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- The integral of `f (Râ»Â¹ â€¢ x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul (f : E â†’ F) (R : â„) :\n    âˆ« x, f (Râ»Â¹ â€¢ x) âˆ‚Î¼ = |R ^ finrank â„ E| â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  rw [integral_comp_smul Î¼ f Râ»Â¹, inv_pow, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\nhR : LE.le 0 R\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f (HSMul.hSMul (Inv.inv R) x)) (HSMul.hSMul (HPow.hPow R (Module.finrank Real E)) (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- The integral of `f (Râ»Â¹ â€¢ x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul_of_nonneg (f : E â†’ F) {R : â„} (hR : 0 â‰¤ R) :\n    âˆ« x, f (Râ»Â¹ â€¢ x) âˆ‚Î¼ = R ^ finrank â„ E â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  rw [integral_comp_inv_smul Î¼ f R, abs_of_nonneg (pow_nonneg hR _)]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\ns : Set E\nhR : Ne R 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (abs (Inv.inv (HPow.hPow R (Module.finrank Real E)))) (MeasureTheory.integral (Î¼.restrict (HSMul.hSMul R s)) fun x => f x))","decl":"theorem setIntegral_comp_smul (f : E â†’ F) {R : â„} (s : Set E) (hR : R â‰  0) :\n    âˆ« x in s, f (R â€¢ x) âˆ‚Î¼ = |(R ^ finrank â„ E)â»Â¹| â€¢ âˆ« x in R â€¢ s, f x âˆ‚Î¼ := by\n  let e : E â‰ƒáµ E := (Homeomorph.smul (Units.mk0 R hR)).toMeasurableEquiv\n  calc\n  âˆ« x in s, f (R â€¢ x) âˆ‚Î¼\n    = âˆ« x in e â»Â¹' (e.symm â»Â¹' s), f (e x) âˆ‚Î¼ := by simp [â† preimage_comp]; rfl\n  _ = âˆ« y in e.symm â»Â¹' s, f y âˆ‚map (fun x â†¦ R â€¢ x) Î¼ := (setIntegral_map_equiv _ _ _).symm\n  _ = |(R ^ finrank â„ E)â»Â¹| â€¢ âˆ« y in e.symm â»Â¹' s, f y âˆ‚Î¼ := by\n    simp [map_addHaar_smul Î¼ hR, integral_smul_measure, ENNReal.toReal_ofReal, abs_nonneg]\n  _ = |(R ^ finrank â„ E)â»Â¹| â€¢ âˆ« x in R â€¢ s, f x âˆ‚Î¼ := by\n    congr\n    ext y\n    rw [mem_smul_set_iff_inv_smul_memâ‚€ hR]\n    rfl\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_comp_smul_of_pos","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : MeasurableSpace E\ninstâœâ´ : BorelSpace E\ninstâœÂ³ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœÂ² : Î¼.IsAddHaarMeasure\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : E â†’ F\nR : Real\ns : Set E\nhR : LT.lt 0 R\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (Inv.inv (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral (Î¼.restrict (HSMul.hSMul R s)) fun x => f x))","decl":"theorem setIntegral_comp_smul_of_pos (f : E â†’ F) {R : â„} (s : Set E) (hR : 0 < R) :\n    âˆ« x in s, f (R â€¢ x) âˆ‚Î¼ = (R ^ finrank â„ E)â»Â¹ â€¢ âˆ« x in R â€¢ s, f x âˆ‚Î¼ := by\n  rw [setIntegral_comp_smul Î¼ f s hR.ne', abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR.le _))]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_mul_left","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ng : Real â†’ F\na : Real\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul a x)) (HSMul.hSMul (abs (Inv.inv a)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_mul_left (g : â„ â†’ F) (a : â„) :\n    (âˆ« x : â„, g (a * x)) = |aâ»Â¹| â€¢ âˆ« y : â„, g y := by\n  simp_rw [â† smul_eq_mul, Measure.integral_comp_smul, Module.finrank_self, pow_one]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_mul_left","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ng : Real â†’ F\na : Real\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul (Inv.inv a) x)) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_inv_mul_left (g : â„ â†’ F) (a : â„) :\n    (âˆ« x : â„, g (aâ»Â¹ * x)) = |a| â€¢ âˆ« y : â„, g y := by\n  simp_rw [â† smul_eq_mul, Measure.integral_comp_inv_smul, Module.finrank_self, pow_one]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_mul_right","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ng : Real â†’ F\na : Real\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul x a)) (HSMul.hSMul (abs (Inv.inv a)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_mul_right (g : â„ â†’ F) (a : â„) :\n    (âˆ« x : â„, g (x * a)) = |aâ»Â¹| â€¢ âˆ« y : â„, g y := by\n  simpa only [mul_comm] using integral_comp_mul_left g a\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_mul_right","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ng : Real â†’ F\na : Real\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul x (Inv.inv a))) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_inv_mul_right (g : â„ â†’ F) (a : â„) :\n    (âˆ« x : â„, g (x * aâ»Â¹)) = |a| â€¢ âˆ« y : â„, g y := by\n  simpa only [mul_comm] using integral_comp_inv_mul_left g a\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_div","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ng : Real â†’ F\na : Real\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HDiv.hDiv x a)) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_div (g : â„ â†’ F) (a : â„) : (âˆ« x : â„, g (x / a)) = |a| â€¢ âˆ« y : â„, g y :=\n  integral_comp_inv_mul_right g a\n\n"}
{"name":"MeasureTheory.integrable_comp_smul_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœâ¶ : NormedAddCommGroup F\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => f (HSMul.hSMul R x)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_comp_smul_iff {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional â„ E] (Î¼ : Measure E) [IsAddHaarMeasure Î¼]\n    (f : E â†’ F) {R : â„} (hR : R â‰  0) : Integrable (fun x => f (R â€¢ x)) Î¼ â†” Integrable f Î¼ := by\n  -- reduce to one-way implication\n  suffices\n    âˆ€ {g : E â†’ F} (_ : Integrable g Î¼) {S : â„} (_ : S â‰  0), Integrable (fun x => g (S â€¢ x)) Î¼ by\n    refine âŸ¨fun hf => ?_, fun hf => this hf hRâŸ©\n    convert this hf (inv_ne_zero hR)\n    rw [â† mul_smul, mul_inv_cancelâ‚€ hR, one_smul]\n  -- now prove\n  intro g hg S hS\n  let t := ((Homeomorph.smul (isUnit_iff_ne_zero.2 hS).unit).toMeasurableEquiv : E â‰ƒáµ E)\n  refine (integrable_map_equiv t g).mp (?_ : Integrable g (map (S â€¢ Â·) Î¼))\n  rwa [map_addHaar_smul Î¼ hS, integrable_smul_measure _ ENNReal.ofReal_ne_top]\n  simpa only [Ne, ENNReal.ofReal_eq_zero, not_le, abs_pos] using inv_ne_zero (pow_ne_zero _ hS)\n\n"}
{"name":"MeasureTheory.Integrable.comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœâ¶ : NormedAddCommGroup F\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : MeasurableSpace E\ninstâœÂ² : BorelSpace E\ninstâœÂ¹ : FiniteDimensional Real E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : E â†’ F\nhf : MeasureTheory.Integrable f Î¼\nR : Real\nhR : Ne R 0\nâŠ¢ MeasureTheory.Integrable (fun x => f (HSMul.hSMul R x)) Î¼","decl":"theorem Integrable.comp_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace â„ E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional â„ E] {Î¼ : Measure E} [IsAddHaarMeasure Î¼]\n    {f : E â†’ F} (hf : Integrable f Î¼) {R : â„} (hR : R â‰  0) : Integrable (fun x => f (R â€¢ x)) Î¼ :=\n  (integrable_comp_smul_iff Î¼ f hR).2 hf\n\n"}
{"name":"MeasureTheory.integrable_comp_mul_left_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => g (HMul.hMul R x)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_mul_left_iff (g : â„ â†’ F) {R : â„} (hR : R â‰  0) :\n    (Integrable fun x => g (R * x)) â†” Integrable g := by\n  simpa only [smul_eq_mul] using integrable_comp_smul_iff volume g hR\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_left'","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\nâŠ¢ MeasureTheory.Integrable (fun x => g (HMul.hMul R x)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_mul_left' {g : â„ â†’ F} (hg : Integrable g) {R : â„} (hR : R â‰  0) :\n    Integrable fun x => g (R * x) :=\n  (integrable_comp_mul_left_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp_mul_right_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => g (HMul.hMul x R)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_mul_right_iff (g : â„ â†’ F) {R : â„} (hR : R â‰  0) :\n    (Integrable fun x => g (x * R)) â†” Integrable g := by\n  simpa only [mul_comm] using integrable_comp_mul_left_iff g hR\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_right'","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\nâŠ¢ MeasureTheory.Integrable (fun x => g (HMul.hMul x R)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_mul_right' {g : â„ â†’ F} (hg : Integrable g) {R : â„} (hR : R â‰  0) :\n    Integrable fun x => g (x * R) :=\n  (integrable_comp_mul_right_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp_div_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nR : Real\nhR : Ne R 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => g (HDiv.hDiv x R)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_div_iff (g : â„ â†’ F) {R : â„} (hR : R â‰  0) :\n    (Integrable fun x => g (x / R)) â†” Integrable g :=\n  integrable_comp_mul_right_iff g (inv_ne_zero hR)\n\n"}
{"name":"MeasureTheory.Integrable.comp_div","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninstâœ : NormedAddCommGroup F\ng : Real â†’ F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\nâŠ¢ MeasureTheory.Integrable (fun x => g (HDiv.hDiv x R)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_div {g : â„ â†’ F} (hg : Integrable g) {R : â„} (hR : R â‰  0) :\n    Integrable fun x => g (x / R) :=\n  (integrable_comp_div_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E' : Type u_2\nF' : Type u_3\nA : Type u_4\ninstâœÂ¹â° : NormedAddCommGroup E'\ninstâœâ¹ : InnerProductSpace Real E'\ninstâœâ¸ : FiniteDimensional Real E'\ninstâœâ· : MeasurableSpace E'\ninstâœâ¶ : BorelSpace E'\ninstâœâµ : NormedAddCommGroup F'\ninstâœâ´ : InnerProductSpace Real F'\ninstâœÂ³ : FiniteDimensional Real F'\ninstâœÂ² : MeasurableSpace F'\ninstâœÂ¹ : BorelSpace F'\nf : LinearIsometryEquiv (RingHom.id Real) E' F'\ninstâœ : NormedAddCommGroup A\ng : F' â†’ A\nâŠ¢ Iff (MeasureTheory.Integrable (Function.comp g â‡‘f) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp (g : F' â†’ A) : Integrable (g âˆ˜ f) â†” Integrable g :=\n  f.measurePreserving.integrable_comp_emb f.toMeasureEquiv.measurableEmbedding\n\n"}
{"name":"MeasureTheory.integral_comp","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E' : Type u_2\nF' : Type u_3\nA : Type u_4\ninstâœÂ¹Â¹ : NormedAddCommGroup E'\ninstâœÂ¹â° : InnerProductSpace Real E'\ninstâœâ¹ : FiniteDimensional Real E'\ninstâœâ¸ : MeasurableSpace E'\ninstâœâ· : BorelSpace E'\ninstâœâ¶ : NormedAddCommGroup F'\ninstâœâµ : InnerProductSpace Real F'\ninstâœâ´ : FiniteDimensional Real F'\ninstâœÂ³ : MeasurableSpace F'\ninstâœÂ² : BorelSpace F'\nf : LinearIsometryEquiv (RingHom.id Real) E' F'\ninstâœÂ¹ : NormedAddCommGroup A\ninstâœ : NormedSpace Real A\ng : F' â†’ A\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (f x)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y)","decl":"theorem integral_comp [NormedSpace â„ A] (g : F' â†’ A) : âˆ« (x : E'), g (f x) = âˆ« (y : F'), g y :=\n  f.measurePreserving.integral_comp' (f := f.toMeasureEquiv) g\n\n"}
