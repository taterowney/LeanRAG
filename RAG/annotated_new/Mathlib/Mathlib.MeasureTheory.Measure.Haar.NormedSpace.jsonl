{"name":"MeasureTheory.Measure.MapLinearEquiv.isAddHaarMeasure","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"𝕜 : Type u_1\nG : Type u_2\nH : Type u_3\ninst✝¹⁹ : MeasurableSpace G\ninst✝¹⁸ : MeasurableSpace H\ninst✝¹⁷ : NontriviallyNormedField 𝕜\ninst✝¹⁶ : TopologicalSpace G\ninst✝¹⁵ : TopologicalSpace H\ninst✝¹⁴ : AddCommGroup G\ninst✝¹³ : AddCommGroup H\ninst✝¹² : TopologicalAddGroup G\ninst✝¹¹ : TopologicalAddGroup H\ninst✝¹⁰ : Module 𝕜 G\ninst✝⁹ : Module 𝕜 H\nμ : MeasureTheory.Measure G\ninst✝⁸ : μ.IsAddHaarMeasure\ninst✝⁷ : BorelSpace G\ninst✝⁶ : BorelSpace H\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : T2Space G\ninst✝³ : FiniteDimensional 𝕜 G\ninst✝² : ContinuousSMul 𝕜 G\ninst✝¹ : ContinuousSMul 𝕜 H\ninst✝ : T2Space H\ne : LinearEquiv (RingHom.id 𝕜) G H\n⊢ (MeasureTheory.Measure.map (⇑e) μ).IsAddHaarMeasure","decl":"instance MapLinearEquiv.isAddHaarMeasure (e : G ≃ₗ[𝕜] H) : IsAddHaarMeasure (μ.map e) :=\n  e.toContinuousLinearEquiv.isAddHaarMeasure_map _\n\n"}
{"name":"AddMonoidHom.exists_nhds_isBounded","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : AddGroup G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalAddGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\ninst✝² : MeasurableSpace H\ninst✝¹ : SeminormedAddGroup H\ninst✝ : OpensMeasurableSpace H\nf : AddMonoidHom G H\nhf : Measurable ⇑f\nx : G\n⊢ Exists fun s => And (Membership.mem (nhds x) s) (Bornology.IsBounded (Set.image (⇑f) s))","decl":"open Metric Bornology in\n@[to_additive]\nlemma _root_.MonoidHom.exists_nhds_isBounded (f : G →* H) (hf : Measurable f) (x : G) :\n    ∃ s ∈ 𝓝 x, IsBounded (f '' s) := by\n  let K : PositiveCompacts G := Classical.arbitrary _\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, 0 < haar (interior K ∩ f ⁻¹' ball 1 n) := by\n    by_contra!\n    simp_rw [nonpos_iff_eq_zero, ← measure_iUnion_null_iff, ← inter_iUnion, ← preimage_iUnion,\n      iUnion_ball_nat, preimage_univ, inter_univ] at this\n    exact this.not_gt <| isOpen_interior.measure_pos _ K.interior_nonempty\n  rw [← one_mul x, ← op_smul_eq_mul]\n  refine ⟨_, smul_mem_nhds_smul _ <| div_mem_nhds_one_of_haar_pos_ne_top haar _\n    (isOpen_interior.measurableSet.inter <| hf measurableSet_ball) hn <|\n      mt (measure_mono_top <| inter_subset_left.trans interior_subset) K.isCompact.measure_ne_top,\n    ?_⟩\n  have : Bornology.IsBounded (f '' (interior K ∩ f ⁻¹' ball 1 n)) :=\n    isBounded_ball.subset <| (image_mono inter_subset_right).trans <| image_preimage_subset _ _\n  rw [image_op_smul_distrib, image_div]\n  exact (this.div this).smul _\n\n"}
{"name":"MonoidHom.exists_nhds_isBounded","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝⁸ : MeasurableSpace G\ninst✝⁷ : Group G\ninst✝⁶ : TopologicalSpace G\ninst✝⁵ : TopologicalGroup G\ninst✝⁴ : BorelSpace G\ninst✝³ : LocallyCompactSpace G\ninst✝² : MeasurableSpace H\ninst✝¹ : SeminormedGroup H\ninst✝ : OpensMeasurableSpace H\nf : MonoidHom G H\nhf : Measurable ⇑f\nx : G\n⊢ Exists fun s => And (Membership.mem (nhds x) s) (Bornology.IsBounded (Set.image (⇑f) s))","decl":"open Metric Bornology in\n@[to_additive]\nlemma _root_.MonoidHom.exists_nhds_isBounded (f : G →* H) (hf : Measurable f) (x : G) :\n    ∃ s ∈ 𝓝 x, IsBounded (f '' s) := by\n  let K : PositiveCompacts G := Classical.arbitrary _\n  obtain ⟨n, hn⟩ : ∃ n : ℕ, 0 < haar (interior K ∩ f ⁻¹' ball 1 n) := by\n    by_contra!\n    simp_rw [nonpos_iff_eq_zero, ← measure_iUnion_null_iff, ← inter_iUnion, ← preimage_iUnion,\n      iUnion_ball_nat, preimage_univ, inter_univ] at this\n    exact this.not_gt <| isOpen_interior.measure_pos _ K.interior_nonempty\n  rw [← one_mul x, ← op_smul_eq_mul]\n  refine ⟨_, smul_mem_nhds_smul _ <| div_mem_nhds_one_of_haar_pos_ne_top haar _\n    (isOpen_interior.measurableSet.inter <| hf measurableSet_ball) hn <|\n      mt (measure_mono_top <| inter_subset_left.trans interior_subset) K.isCompact.measure_ne_top,\n    ?_⟩\n  have : Bornology.IsBounded (f '' (interior K ∩ f ⁻¹' ball 1 n)) :=\n    isBounded_ball.subset <| (image_mono inter_subset_right).trans <| image_preimage_subset _ _\n  rw [image_op_smul_distrib, image_div]\n  exact (this.div this).smul _\n\n"}
{"name":"MeasureTheory.Measure.AddMonoidHom.continuous_of_measurable","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : MeasurableSpace G\ninst✝⁵ : BorelSpace G\ninst✝⁴ : LocallyCompactSpace G\ninst✝³ : SeminormedAddCommGroup H\ninst✝² : MeasurableSpace H\ninst✝¹ : OpensMeasurableSpace H\ninst✝ : NormedSpace Real H\nf : AddMonoidHom G H\nhf : Measurable ⇑f\n⊢ Continuous ⇑f","decl":"/-- A Borel-measurable group hom from a locally compact normed group to a real normed space is\ncontinuous. -/\nlemma AddMonoidHom.continuous_of_measurable {G H : Type*}\n    [SeminormedAddCommGroup G] [MeasurableSpace G] [BorelSpace G] [LocallyCompactSpace G]\n    [SeminormedAddCommGroup H] [MeasurableSpace H] [OpensMeasurableSpace H] [NormedSpace ℝ H]\n    (f : G →+ H) (hf : Measurable f) : Continuous f :=\n  let ⟨_s, hs, hbdd⟩ := f.exists_nhds_isBounded hf 0; f.continuous_of_isBounded_nhds_zero hs hbdd\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (abs (Inv.inv (HPow.hPow R (Module.finrank Real E)))) (MeasureTheory.integral μ fun x => f x))","decl":"/-- The integral of `f (R • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul (f : E → F) (R : ℝ) :\n    ∫ x, f (R • x) ∂μ = |(R ^ finrank ℝ E)⁻¹| • ∫ x, f x ∂μ := by\n  by_cases hF : CompleteSpace F; swap\n  · simp [integral, hF]\n  rcases eq_or_ne R 0 with (rfl | hR)\n  · simp only [zero_smul, integral_const]\n    rcases Nat.eq_zero_or_pos (finrank ℝ E) with (hE | hE)\n    · have : Subsingleton E := finrank_zero_iff.1 hE\n      have : f = fun _ => f 0 := by ext x; rw [Subsingleton.elim x 0]\n      conv_rhs => rw [this]\n      simp only [hE, pow_zero, inv_one, abs_one, one_smul, integral_const]\n    · have : Nontrivial E := finrank_pos_iff.1 hE\n      simp only [zero_pow hE.ne', measure_univ_of_isAddLeftInvariant, ENNReal.top_toReal, zero_smul,\n        inv_zero, abs_zero]\n  · calc\n      (∫ x, f (R • x) ∂μ) = ∫ y, f y ∂Measure.map (fun x => R • x) μ :=\n        (integral_map_equiv (Homeomorph.smul (isUnit_iff_ne_zero.2 hR).unit).toMeasurableEquiv\n            f).symm\n      _ = |(R ^ finrank ℝ E)⁻¹| • ∫ x, f x ∂μ := by\n        simp only [map_addHaar_smul μ hR, integral_smul_measure, ENNReal.toReal_ofReal, abs_nonneg]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\nhR : LE.le 0 R\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (Inv.inv (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral μ fun x => f x))","decl":"/-- The integral of `f (R • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_smul_of_nonneg (f : E → F) (R : ℝ) {hR : 0 ≤ R} :\n    ∫ x, f (R • x) ∂μ = (R ^ finrank ℝ E)⁻¹ • ∫ x, f x ∂μ := by\n  rw [integral_comp_smul μ f R, abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR _))]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSMul.hSMul (Inv.inv R) x)) (HSMul.hSMul (abs (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral μ fun x => f x))","decl":"/-- The integral of `f (R⁻¹ • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul (f : E → F) (R : ℝ) :\n    ∫ x, f (R⁻¹ • x) ∂μ = |R ^ finrank ℝ E| • ∫ x, f x ∂μ := by\n  rw [integral_comp_smul μ f R⁻¹, inv_pow, inv_inv]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_smul_of_nonneg","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\nhR : LE.le 0 R\n⊢ Eq (MeasureTheory.integral μ fun x => f (HSMul.hSMul (Inv.inv R) x)) (HSMul.hSMul (HPow.hPow R (Module.finrank Real E)) (MeasureTheory.integral μ fun x => f x))","decl":"/-- The integral of `f (R⁻¹ • x)` with respect to an additive Haar measure is a multiple of the\nintegral of `f`. The formula we give works even when `f` is not integrable or `R = 0`\nthanks to the convention that a non-integrable function has integral zero. -/\ntheorem integral_comp_inv_smul_of_nonneg (f : E → F) {R : ℝ} (hR : 0 ≤ R) :\n    ∫ x, f (R⁻¹ • x) ∂μ = R ^ finrank ℝ E • ∫ x, f x ∂μ := by\n  rw [integral_comp_inv_smul μ f R, abs_of_nonneg (pow_nonneg hR _)]\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\ns : Set E\nhR : Ne R 0\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (abs (Inv.inv (HPow.hPow R (Module.finrank Real E)))) (MeasureTheory.integral (μ.restrict (HSMul.hSMul R s)) fun x => f x))","decl":"theorem setIntegral_comp_smul (f : E → F) {R : ℝ} (s : Set E) (hR : R ≠ 0) :\n    ∫ x in s, f (R • x) ∂μ = |(R ^ finrank ℝ E)⁻¹| • ∫ x in R • s, f x ∂μ := by\n  let e : E ≃ᵐ E := (Homeomorph.smul (Units.mk0 R hR)).toMeasurableEquiv\n  calc\n  ∫ x in s, f (R • x) ∂μ\n    = ∫ x in e ⁻¹' (e.symm ⁻¹' s), f (e x) ∂μ := by simp [← preimage_comp]; rfl\n  _ = ∫ y in e.symm ⁻¹' s, f y ∂map (fun x ↦ R • x) μ := (setIntegral_map_equiv _ _ _).symm\n  _ = |(R ^ finrank ℝ E)⁻¹| • ∫ y in e.symm ⁻¹' s, f y ∂μ := by\n    simp [map_addHaar_smul μ hR, integral_smul_measure, ENNReal.toReal_ofReal, abs_nonneg]\n  _ = |(R ^ finrank ℝ E)⁻¹| • ∫ x in R • s, f x ∂μ := by\n    congr\n    ext y\n    rw [mem_smul_set_iff_inv_smul_mem₀ hR]\n    rfl\n\n"}
{"name":"MeasureTheory.Measure.setIntegral_comp_smul_of_pos","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : MeasurableSpace E\ninst✝⁴ : BorelSpace E\ninst✝³ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝² : μ.IsAddHaarMeasure\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : E → F\nR : Real\ns : Set E\nhR : LT.lt 0 R\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f (HSMul.hSMul R x)) (HSMul.hSMul (Inv.inv (HPow.hPow R (Module.finrank Real E))) (MeasureTheory.integral (μ.restrict (HSMul.hSMul R s)) fun x => f x))","decl":"theorem setIntegral_comp_smul_of_pos (f : E → F) {R : ℝ} (s : Set E) (hR : 0 < R) :\n    ∫ x in s, f (R • x) ∂μ = (R ^ finrank ℝ E)⁻¹ • ∫ x in R • s, f x ∂μ := by\n  rw [setIntegral_comp_smul μ f s hR.ne', abs_of_nonneg (inv_nonneg.2 (pow_nonneg hR.le _))]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_mul_left","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ng : Real → F\na : Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul a x)) (HSMul.hSMul (abs (Inv.inv a)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_mul_left (g : ℝ → F) (a : ℝ) :\n    (∫ x : ℝ, g (a * x)) = |a⁻¹| • ∫ y : ℝ, g y := by\n  simp_rw [← smul_eq_mul, Measure.integral_comp_smul, Module.finrank_self, pow_one]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_mul_left","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ng : Real → F\na : Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul (Inv.inv a) x)) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_inv_mul_left (g : ℝ → F) (a : ℝ) :\n    (∫ x : ℝ, g (a⁻¹ * x)) = |a| • ∫ y : ℝ, g y := by\n  simp_rw [← smul_eq_mul, Measure.integral_comp_inv_smul, Module.finrank_self, pow_one]\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_mul_right","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ng : Real → F\na : Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul x a)) (HSMul.hSMul (abs (Inv.inv a)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_mul_right (g : ℝ → F) (a : ℝ) :\n    (∫ x : ℝ, g (x * a)) = |a⁻¹| • ∫ y : ℝ, g y := by\n  simpa only [mul_comm] using integral_comp_mul_left g a\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_inv_mul_right","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ng : Real → F\na : Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HMul.hMul x (Inv.inv a))) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_inv_mul_right (g : ℝ → F) (a : ℝ) :\n    (∫ x : ℝ, g (x * a⁻¹)) = |a| • ∫ y : ℝ, g y := by\n  simpa only [mul_comm] using integral_comp_inv_mul_left g a\n\n"}
{"name":"MeasureTheory.Measure.integral_comp_div","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\ng : Real → F\na : Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (HDiv.hDiv x a)) (HSMul.hSMul (abs a) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y))","decl":"theorem integral_comp_div (g : ℝ → F) (a : ℝ) : (∫ x : ℝ, g (x / a)) = |a| • ∫ y : ℝ, g y :=\n  integral_comp_inv_mul_right g a\n\n"}
{"name":"MeasureTheory.integrable_comp_smul_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝⁶ : NormedAddCommGroup F\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nR : Real\nhR : Ne R 0\n⊢ Iff (MeasureTheory.Integrable (fun x => f (HSMul.hSMul R x)) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_comp_smul_iff {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ℝ E] (μ : Measure E) [IsAddHaarMeasure μ]\n    (f : E → F) {R : ℝ} (hR : R ≠ 0) : Integrable (fun x => f (R • x)) μ ↔ Integrable f μ := by\n  -- reduce to one-way implication\n  suffices\n    ∀ {g : E → F} (_ : Integrable g μ) {S : ℝ} (_ : S ≠ 0), Integrable (fun x => g (S • x)) μ by\n    refine ⟨fun hf => ?_, fun hf => this hf hR⟩\n    convert this hf (inv_ne_zero hR)\n    rw [← mul_smul, mul_inv_cancel₀ hR, one_smul]\n  -- now prove\n  intro g hg S hS\n  let t := ((Homeomorph.smul (isUnit_iff_ne_zero.2 hS).unit).toMeasurableEquiv : E ≃ᵐ E)\n  refine (integrable_map_equiv t g).mp (?_ : Integrable g (map (S • ·) μ))\n  rwa [map_addHaar_smul μ hS, integrable_smul_measure _ ENNReal.ofReal_ne_top]\n  simpa only [Ne, ENNReal.ofReal_eq_zero, not_le, abs_pos] using inv_ne_zero (pow_ne_zero _ hS)\n\n"}
{"name":"MeasureTheory.Integrable.comp_smul","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝⁶ : NormedAddCommGroup F\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\ninst✝¹ : FiniteDimensional Real E\nμ : MeasureTheory.Measure E\ninst✝ : μ.IsAddHaarMeasure\nf : E → F\nhf : MeasureTheory.Integrable f μ\nR : Real\nhR : Ne R 0\n⊢ MeasureTheory.Integrable (fun x => f (HSMul.hSMul R x)) μ","decl":"theorem Integrable.comp_smul {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    [MeasurableSpace E] [BorelSpace E] [FiniteDimensional ℝ E] {μ : Measure E} [IsAddHaarMeasure μ]\n    {f : E → F} (hf : Integrable f μ) {R : ℝ} (hR : R ≠ 0) : Integrable (fun x => f (R • x)) μ :=\n  (integrable_comp_smul_iff μ f hR).2 hf\n\n"}
{"name":"MeasureTheory.integrable_comp_mul_left_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nR : Real\nhR : Ne R 0\n⊢ Iff (MeasureTheory.Integrable (fun x => g (HMul.hMul R x)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_mul_left_iff (g : ℝ → F) {R : ℝ} (hR : R ≠ 0) :\n    (Integrable fun x => g (R * x)) ↔ Integrable g := by\n  simpa only [smul_eq_mul] using integrable_comp_smul_iff volume g hR\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_left'","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\n⊢ MeasureTheory.Integrable (fun x => g (HMul.hMul R x)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_mul_left' {g : ℝ → F} (hg : Integrable g) {R : ℝ} (hR : R ≠ 0) :\n    Integrable fun x => g (R * x) :=\n  (integrable_comp_mul_left_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp_mul_right_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nR : Real\nhR : Ne R 0\n⊢ Iff (MeasureTheory.Integrable (fun x => g (HMul.hMul x R)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_mul_right_iff (g : ℝ → F) {R : ℝ} (hR : R ≠ 0) :\n    (Integrable fun x => g (x * R)) ↔ Integrable g := by\n  simpa only [mul_comm] using integrable_comp_mul_left_iff g hR\n\n"}
{"name":"MeasureTheory.Integrable.comp_mul_right'","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\n⊢ MeasureTheory.Integrable (fun x => g (HMul.hMul x R)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_mul_right' {g : ℝ → F} (hg : Integrable g) {R : ℝ} (hR : R ≠ 0) :\n    Integrable fun x => g (x * R) :=\n  (integrable_comp_mul_right_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp_div_iff","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nR : Real\nhR : Ne R 0\n⊢ Iff (MeasureTheory.Integrable (fun x => g (HDiv.hDiv x R)) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp_div_iff (g : ℝ → F) {R : ℝ} (hR : R ≠ 0) :\n    (Integrable fun x => g (x / R)) ↔ Integrable g :=\n  integrable_comp_mul_right_iff g (inv_ne_zero hR)\n\n"}
{"name":"MeasureTheory.Integrable.comp_div","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"F : Type u_1\ninst✝ : NormedAddCommGroup F\ng : Real → F\nhg : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nR : Real\nhR : Ne R 0\n⊢ MeasureTheory.Integrable (fun x => g (HDiv.hDiv x R)) MeasureTheory.MeasureSpace.volume","decl":"theorem Integrable.comp_div {g : ℝ → F} (hg : Integrable g) {R : ℝ} (hR : R ≠ 0) :\n    Integrable fun x => g (x / R) :=\n  (integrable_comp_div_iff g hR).2 hg\n\n"}
{"name":"MeasureTheory.integrable_comp","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E' : Type u_2\nF' : Type u_3\nA : Type u_4\ninst✝¹⁰ : NormedAddCommGroup E'\ninst✝⁹ : InnerProductSpace Real E'\ninst✝⁸ : FiniteDimensional Real E'\ninst✝⁷ : MeasurableSpace E'\ninst✝⁶ : BorelSpace E'\ninst✝⁵ : NormedAddCommGroup F'\ninst✝⁴ : InnerProductSpace Real F'\ninst✝³ : FiniteDimensional Real F'\ninst✝² : MeasurableSpace F'\ninst✝¹ : BorelSpace F'\nf : LinearIsometryEquiv (RingHom.id Real) E' F'\ninst✝ : NormedAddCommGroup A\ng : F' → A\n⊢ Iff (MeasureTheory.Integrable (Function.comp g ⇑f) MeasureTheory.MeasureSpace.volume) (MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume)","decl":"theorem integrable_comp (g : F' → A) : Integrable (g ∘ f) ↔ Integrable g :=\n  f.measurePreserving.integrable_comp_emb f.toMeasureEquiv.measurableEmbedding\n\n"}
{"name":"MeasureTheory.integral_comp","module":"Mathlib.MeasureTheory.Measure.Haar.NormedSpace","initialProofState":"E' : Type u_2\nF' : Type u_3\nA : Type u_4\ninst✝¹¹ : NormedAddCommGroup E'\ninst✝¹⁰ : InnerProductSpace Real E'\ninst✝⁹ : FiniteDimensional Real E'\ninst✝⁸ : MeasurableSpace E'\ninst✝⁷ : BorelSpace E'\ninst✝⁶ : NormedAddCommGroup F'\ninst✝⁵ : InnerProductSpace Real F'\ninst✝⁴ : FiniteDimensional Real F'\ninst✝³ : MeasurableSpace F'\ninst✝² : BorelSpace F'\nf : LinearIsometryEquiv (RingHom.id Real) E' F'\ninst✝¹ : NormedAddCommGroup A\ninst✝ : NormedSpace Real A\ng : F' → A\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => g (f x)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun y => g y)","decl":"theorem integral_comp [NormedSpace ℝ A] (g : F' → A) : ∫ (x : E'), g (f x) = ∫ (y : F'), g y :=\n  f.measurePreserving.integral_comp' (f := f.toMeasureEquiv) g\n\n"}
