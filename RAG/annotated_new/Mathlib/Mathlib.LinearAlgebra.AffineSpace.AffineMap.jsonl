{"name":"AffineMap.mk.injEq","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\ntoFun✝ : P1 → P2\nlinear✝ : LinearMap (RingHom.id k) V1 V2\nmap_vadd'✝ : ∀ (p : P1) (v : V1), Eq (toFun✝ (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear✝ v) (toFun✝ p))\ntoFun : P1 → P2\nlinear : LinearMap (RingHom.id k) V1 V2\nmap_vadd' : ∀ (p : P1) (v : V1), Eq (toFun (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toFun p))\n⊢ Eq (Eq { toFun := toFun✝, linear := linear✝, map_vadd' := map_vadd'✝ } { toFun := toFun, linear := linear, map_vadd' := map_vadd' }) (And (Eq toFun✝ toFun) (Eq linear✝ linear))","decl":"/-- An `AffineMap k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. -/\nstructure AffineMap (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*) [Ring k]\n  [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n  [AffineSpace V2 P2] where\n  toFun : P1 → P2\n  linear : V1 →ₗ[k] V2\n  map_vadd' : ∀ (p : P1) (v : V1), toFun (v +ᵥ p) = linear v +ᵥ toFun p\n\n"}
{"name":"AffineMap.mk.inj","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\ntoFun✝ : P1 → P2\nlinear✝ : LinearMap (RingHom.id k) V1 V2\nmap_vadd'✝ : ∀ (p : P1) (v : V1), Eq (toFun✝ (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear✝ v) (toFun✝ p))\ntoFun : P1 → P2\nlinear : LinearMap (RingHom.id k) V1 V2\nmap_vadd' : ∀ (p : P1) (v : V1), Eq (toFun (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toFun p))\nx✝ : Eq { toFun := toFun✝, linear := linear✝, map_vadd' := map_vadd'✝ } { toFun := toFun, linear := linear, map_vadd' := map_vadd' }\n⊢ And (Eq toFun✝ toFun) (Eq linear✝ linear)","decl":"/-- An `AffineMap k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. -/\nstructure AffineMap (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*) [Ring k]\n  [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n  [AffineSpace V2 P2] where\n  toFun : P1 → P2\n  linear : V1 →ₗ[k] V2\n  map_vadd' : ∀ (p : P1) (v : V1), toFun (v +ᵥ p) = linear v +ᵥ toFun p\n\n"}
{"name":"AffineMap.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝¹¹ : Ring k\ninst✝¹⁰ : AddCommGroup V1\ninst✝⁹ : Module k V1\ninst✝⁸ : AddTorsor V1 P1\ninst✝⁷ : AddCommGroup V2\ninst✝⁶ : Module k V2\ninst✝⁵ : AddTorsor V2 P2\ninst✝⁴ : SizeOf k\ninst✝³ : SizeOf V1\ninst✝² : SizeOf P1\ninst✝¹ : SizeOf V2\ninst✝ : SizeOf P2\ntoFun : P1 → P2\nlinear : LinearMap (RingHom.id k) V1 V2\nmap_vadd' : ∀ (p : P1) (v : V1), Eq (toFun (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (toFun p))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, linear := linear, map_vadd' := map_vadd' }) (HAdd.hAdd 1 (SizeOf.sizeOf linear))","decl":"/-- An `AffineMap k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. -/\nstructure AffineMap (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*) [Ring k]\n  [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n  [AffineSpace V2 P2] where\n  toFun : P1 → P2\n  linear : V1 →ₗ[k] V2\n  map_vadd' : ∀ (p : P1) (v : V1), toFun (v +ᵥ p) = linear v +ᵥ toFun p\n\n"}
{"name":"AffineMap.map_vadd'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nself : AffineMap k P1 P2\np : P1\nv : V1\n⊢ Eq (self.toFun (HVAdd.hVAdd v p)) (HVAdd.hVAdd (self.linear v) (self.toFun p))","decl":"/-- An `AffineMap k P1 P2` (notation: `P1 →ᵃ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. -/\nstructure AffineMap (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*) [Ring k]\n  [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n  [AffineSpace V2 P2] where\n  toFun : P1 → P2\n  linear : V1 →ₗ[k] V2\n  map_vadd' : ∀ (p : P1) (v : V1), toFun (v +ᵥ p) = linear v +ᵥ toFun p\n\n"}
{"name":"LinearMap.coe_toAffineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV₁ : Type u_2\nV₂ : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module k V₂\nf : LinearMap (RingHom.id k) V₁ V₂\n⊢ Eq ⇑f.toAffineMap ⇑f","decl":"@[simp]\ntheorem coe_toAffineMap : ⇑f.toAffineMap = f :=\n  rfl\n\n"}
{"name":"LinearMap.toAffineMap_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV₁ : Type u_2\nV₂ : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V₁\ninst✝² : Module k V₁\ninst✝¹ : AddCommGroup V₂\ninst✝ : Module k V₂\nf : LinearMap (RingHom.id k) V₁ V₂\n⊢ Eq f.toAffineMap.linear f","decl":"@[simp]\ntheorem toAffineMap_linear : f.toAffineMap.linear = f :=\n  rfl\n\n"}
{"name":"AffineMap.coe_mk","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : P1 → P2\nlinear : LinearMap (RingHom.id k) V1 V2\nadd : ∀ (p : P1) (v : V1), Eq (f (HVAdd.hVAdd v p)) (HVAdd.hVAdd (linear v) (f p))\n⊢ Eq (⇑{ toFun := f, linear := linear, map_vadd' := add }) f","decl":"/-- Constructing an affine map and coercing back to a function\nproduces the same map. -/\n@[simp]\ntheorem coe_mk (f : P1 → P2) (linear add) : ((mk f linear add : P1 →ᵃ[k] P2) : P1 → P2) = f :=\n  rfl\n\n"}
{"name":"AffineMap.toFun_eq_coe","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Eq f.toFun ⇑f","decl":"/-- `toFun` is the same as the result of coercing to a function. -/\n@[simp]\ntheorem toFun_eq_coe (f : P1 →ᵃ[k] P2) : f.toFun = ⇑f :=\n  rfl\n\n"}
{"name":"AffineMap.map_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\np : P1\nv : V1\n⊢ Eq (f (HVAdd.hVAdd v p)) (HVAdd.hVAdd (f.linear v) (f p))","decl":"/-- An affine map on the result of adding a vector to a point produces\nthe same result as the linear map applied to that vector, added to the\naffine map applied to that point. -/\n@[simp]\ntheorem map_vadd (f : P1 →ᵃ[k] P2) (p : P1) (v : V1) : f (v +ᵥ p) = f.linear v +ᵥ f p :=\n  f.map_vadd' p v\n\n"}
{"name":"AffineMap.linearMap_vsub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\np1 p2 : P1\n⊢ Eq (f.linear (VSub.vsub p1 p2)) (VSub.vsub (f p1) (f p2))","decl":"/-- The linear map on the result of subtracting two points is the\nresult of subtracting the result of the affine map on those two\npoints. -/\n@[simp]\ntheorem linearMap_vsub (f : P1 →ᵃ[k] P2) (p1 p2 : P1) : f.linear (p1 -ᵥ p2) = f p1 -ᵥ f p2 := by\n  conv_rhs => rw [← vsub_vadd p1 p2, map_vadd, vadd_vsub]\n\n"}
{"name":"AffineMap.ext_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\n⊢ Iff (Eq f g) (∀ (p : P1), Eq (f p) (g p))","decl":"/-- Two affine maps are equal if they coerce to the same function. -/\n@[ext]\ntheorem ext {f g : P1 →ᵃ[k] P2} (h : ∀ p, f p = g p) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AffineMap.ext","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\nh : ∀ (p : P1), Eq (f p) (g p)\n⊢ Eq f g","decl":"/-- Two affine maps are equal if they coerce to the same function. -/\n@[ext]\ntheorem ext {f g : P1 →ᵃ[k] P2} (h : ∀ p, f p = g p) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"AffineMap.coeFn_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Function.Injective DFunLike.coe","decl":"theorem coeFn_injective : @Function.Injective (P1 →ᵃ[k] P2) (P1 → P2) (⇑) :=\n  DFunLike.coe_injective\n\n"}
{"name":"AffineMap.congr_arg","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\nx y : P1\nh : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : P1 →ᵃ[k] P2) {x y : P1} (h : x = y) : f x = f y :=\n  congr_arg _ h\n\n"}
{"name":"AffineMap.congr_fun","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\nh : Eq f g\nx : P1\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : P1 →ᵃ[k] P2} (h : f = g) (x : P1) : f x = g x :=\n  h ▸ rfl\n\n"}
{"name":"AffineMap.ext_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\nh₁ : Eq f.linear g.linear\np : P1\nh₂ : Eq (f p) (g p)\n⊢ Eq f g","decl":"/-- Two affine maps are equal if they have equal linear maps and are equal at some point. -/\ntheorem ext_linear {f g : P1 →ᵃ[k] P2} (h₁ : f.linear = g.linear) {p : P1} (h₂ : f p = g p) :\n    f = g := by\n  ext q\n  have hgl : g.linear (q -ᵥ p) = toFun g ((q -ᵥ p) +ᵥ q) -ᵥ toFun g q := by simp\n  have := f.map_vadd' q (q -ᵥ p)\n  rw [h₁, hgl, toFun_eq_coe, map_vadd, linearMap_vsub, h₂] at this\n  simpa\n\n"}
{"name":"AffineMap.ext_linear_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\n⊢ Iff (Eq f g) (And (Eq f.linear g.linear) (Exists fun p => Eq (f p) (g p)))","decl":"/-- Two affine maps are equal if they have equal linear maps and are equal at some point. -/\ntheorem ext_linear_iff {f g : P1 →ᵃ[k] P2} : f = g ↔ (f.linear = g.linear) ∧ (∃ p, f p = g p) :=\n  ⟨fun h ↦ ⟨congrArg _ h, by inhabit P1; exact default, by rw [h]⟩,\n  fun h ↦ Exists.casesOn h.2 fun _ hp ↦ ext_linear h.1 hp⟩\n\n"}
{"name":"AffineMap.coe_const","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\np : P2\n⊢ Eq (⇑(AffineMap.const k P1 p)) (Function.const P1 p)","decl":"@[simp]\ntheorem coe_const (p : P2) : ⇑(const k P1 p) = Function.const P1 p :=\n  rfl\n\n"}
{"name":"AffineMap.const_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\np : P2\nq : P1\n⊢ Eq ((AffineMap.const k P1 p) q) p","decl":"@[simp]\ntheorem const_apply (p : P2) (q : P1) : (const k P1 p) q = p := rfl\n\n"}
{"name":"AffineMap.const_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\np : P2\n⊢ Eq (AffineMap.const k P1 p).linear 0","decl":"@[simp]\ntheorem const_linear (p : P2) : (const k P1 p).linear = 0 :=\n  rfl\n\n"}
{"name":"AffineMap.linear_eq_zero_iff_exists_const","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Iff (Eq f.linear 0) (Exists fun q => Eq f (AffineMap.const k P1 q))","decl":"theorem linear_eq_zero_iff_exists_const (f : P1 →ᵃ[k] P2) :\n    f.linear = 0 ↔ ∃ q, f = const k P1 q := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · use f (Classical.arbitrary P1)\n    ext\n    rw [coe_const, Function.const_apply, ← @vsub_eq_zero_iff_eq V2, ← f.linearMap_vsub, h,\n      LinearMap.zero_apply]\n  · rcases h with ⟨q, rfl⟩\n    exact const_linear k P1 q\n\n"}
{"name":"AffineMap.nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Nonempty (AffineMap k P1 P2)","decl":"instance nonempty : Nonempty (P1 →ᵃ[k] P2) :=\n  (AddTorsor.nonempty : Nonempty P2).map <| const k P1\n\n"}
{"name":"AffineMap.coe_mk'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : P1 → P2\nf' : LinearMap (RingHom.id k) V1 V2\np : P1\nh : ∀ (p' : P1), Eq (f p') (HVAdd.hVAdd (f' (VSub.vsub p' p)) (f p))\n⊢ Eq (⇑(AffineMap.mk' f f' p h)) f","decl":"@[simp]\ntheorem coe_mk' (f : P1 → P2) (f' : V1 →ₗ[k] V2) (p h) : ⇑(mk' f f' p h) = f :=\n  rfl\n\n"}
{"name":"AffineMap.mk'_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : P1 → P2\nf' : LinearMap (RingHom.id k) V1 V2\np : P1\nh : ∀ (p' : P1), Eq (f p') (HVAdd.hVAdd (f' (VSub.vsub p' p)) (f p))\n⊢ Eq (AffineMap.mk' f f' p h).linear f'","decl":"@[simp]\ntheorem mk'_linear (f : P1 → P2) (f' : V1 →ₗ[k] V2) (p h) : (mk' f f' p h).linear = f' :=\n  rfl\n\n"}
{"name":"AffineMap.coe_smul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V1\ninst✝⁶ : Module k V1\ninst✝⁵ : AddTorsor V1 P1\ninst✝⁴ : AddCommGroup V2\ninst✝³ : Module k V2\nR : Type u_10\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R V2\ninst✝ : SMulCommClass k R V2\nc : R\nf : AffineMap k P1 V2\n⊢ Eq (⇑(HSMul.hSMul c f)) (HSMul.hSMul c ⇑f)","decl":"@[simp, norm_cast]\ntheorem coe_smul (c : R) (f : P1 →ᵃ[k] V2) : ⇑(c • f) = c • ⇑f :=\n  rfl\n\n"}
{"name":"AffineMap.smul_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V1\ninst✝⁶ : Module k V1\ninst✝⁵ : AddTorsor V1 P1\ninst✝⁴ : AddCommGroup V2\ninst✝³ : Module k V2\nR : Type u_10\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R V2\ninst✝ : SMulCommClass k R V2\nt : R\nf : AffineMap k P1 V2\n⊢ Eq (HSMul.hSMul t f).linear (HSMul.hSMul t f.linear)","decl":"@[simp]\ntheorem smul_linear (t : R) (f : P1 →ᵃ[k] V2) : (t • f).linear = t • f.linear :=\n  rfl\n\n"}
{"name":"AffineMap.isCentralScalar","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝¹⁰ : Ring k\ninst✝⁹ : AddCommGroup V1\ninst✝⁸ : Module k V1\ninst✝⁷ : AddTorsor V1 P1\ninst✝⁶ : AddCommGroup V2\ninst✝⁵ : Module k V2\nR : Type u_10\ninst✝⁴ : Monoid R\ninst✝³ : DistribMulAction R V2\ninst✝² : SMulCommClass k R V2\ninst✝¹ : DistribMulAction (MulOpposite R) V2\ninst✝ : IsCentralScalar R V2\n⊢ IsCentralScalar R (AffineMap k P1 V2)","decl":"instance isCentralScalar [DistribMulAction Rᵐᵒᵖ V2] [IsCentralScalar R V2] :\n  IsCentralScalar R (P1 →ᵃ[k] V2) where\n    op_smul_eq_smul _r _x := ext fun _ => op_smul_eq_smul _ _\n\n"}
{"name":"AffineMap.coe_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ⇑(0 : P1 →ᵃ[k] V2) = 0 :=\n  rfl\n\n"}
{"name":"AffineMap.coe_add","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf g : AffineMap k P1 V2\n⊢ Eq (⇑(HAdd.hAdd f g)) (HAdd.hAdd ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_add (f g : P1 →ᵃ[k] V2) : ⇑(f + g) = f + g :=\n  rfl\n\n"}
{"name":"AffineMap.coe_neg","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf : AffineMap k P1 V2\n⊢ Eq (⇑(Neg.neg f)) (Neg.neg ⇑f)","decl":"@[simp, norm_cast]\ntheorem coe_neg (f : P1 →ᵃ[k] V2) : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"AffineMap.coe_sub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf g : AffineMap k P1 V2\n⊢ Eq (⇑(HSub.hSub f g)) (HSub.hSub ⇑f ⇑g)","decl":"@[simp, norm_cast]\ntheorem coe_sub (f g : P1 →ᵃ[k] V2) : ⇑(f - g) = f - g :=\n  rfl\n\n"}
{"name":"AffineMap.zero_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\n⊢ Eq (AffineMap.linear 0) 0","decl":"@[simp]\ntheorem zero_linear : (0 : P1 →ᵃ[k] V2).linear = 0 :=\n  rfl\n\n"}
{"name":"AffineMap.add_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf g : AffineMap k P1 V2\n⊢ Eq (HAdd.hAdd f g).linear (HAdd.hAdd f.linear g.linear)","decl":"@[simp]\ntheorem add_linear (f g : P1 →ᵃ[k] V2) : (f + g).linear = f.linear + g.linear :=\n  rfl\n\n"}
{"name":"AffineMap.sub_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf g : AffineMap k P1 V2\n⊢ Eq (HSub.hSub f g).linear (HSub.hSub f.linear g.linear)","decl":"@[simp]\ntheorem sub_linear (f g : P1 →ᵃ[k] V2) : (f - g).linear = f.linear - g.linear :=\n  rfl\n\n"}
{"name":"AffineMap.neg_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : Module k V1\ninst✝² : AddTorsor V1 P1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf : AffineMap k P1 V2\n⊢ Eq (Neg.neg f).linear (Neg.neg f.linear)","decl":"@[simp]\ntheorem neg_linear (f : P1 →ᵃ[k] V2) : (-f).linear = -f.linear :=\n  rfl\n\n"}
{"name":"AffineMap.vadd_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 V2\ng : AffineMap k P1 P2\np : P1\n⊢ Eq ((HVAdd.hVAdd f g) p) (HVAdd.hVAdd (f p) (g p))","decl":"@[simp]\ntheorem vadd_apply (f : P1 →ᵃ[k] V2) (g : P1 →ᵃ[k] P2) (p : P1) : (f +ᵥ g) p = f p +ᵥ g p :=\n  rfl\n\n"}
{"name":"AffineMap.vsub_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf g : AffineMap k P1 P2\np : P1\n⊢ Eq ((VSub.vsub f g) p) (VSub.vsub (f p) (g p))","decl":"@[simp]\ntheorem vsub_apply (f g : P1 →ᵃ[k] P2) (p : P1) : (f -ᵥ g : P1 →ᵃ[k] V2) p = f p -ᵥ g p :=\n  rfl\n\n"}
{"name":"AffineMap.coe_fst","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Eq (⇑AffineMap.fst) Prod.fst","decl":"@[simp]\ntheorem coe_fst : ⇑(fst : P1 × P2 →ᵃ[k] P1) = Prod.fst :=\n  rfl\n\n"}
{"name":"AffineMap.fst_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Eq AffineMap.fst.linear (LinearMap.fst k V1 V2)","decl":"@[simp]\ntheorem fst_linear : (fst : P1 × P2 →ᵃ[k] P1).linear = LinearMap.fst k V1 V2 :=\n  rfl\n\n"}
{"name":"AffineMap.coe_snd","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Eq (⇑AffineMap.snd) Prod.snd","decl":"@[simp]\ntheorem coe_snd : ⇑(snd : P1 × P2 →ᵃ[k] P2) = Prod.snd :=\n  rfl\n\n"}
{"name":"AffineMap.snd_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\n⊢ Eq AffineMap.snd.linear (LinearMap.snd k V1 V2)","decl":"@[simp]\ntheorem snd_linear : (snd : P1 × P2 →ᵃ[k] P2).linear = LinearMap.snd k V1 V2 :=\n  rfl\n\n"}
{"name":"AffineMap.coe_id","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\n⊢ Eq (⇑(AffineMap.id k P1)) id","decl":"/-- The identity affine map acts as the identity. -/\n@[simp, norm_cast]\ntheorem coe_id : ⇑(id k P1) = _root_.id :=\n  rfl\n\n"}
{"name":"AffineMap.id_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\n⊢ Eq (AffineMap.id k P1).linear LinearMap.id","decl":"@[simp]\ntheorem id_linear : (id k P1).linear = LinearMap.id :=\n  rfl\n\n"}
{"name":"AffineMap.id_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np : P1\n⊢ Eq ((AffineMap.id k P1) p) p","decl":"/-- The identity affine map acts as the identity. -/\ntheorem id_apply (p : P1) : id k P1 p = p :=\n  rfl\n\n"}
{"name":"AffineMap.coe_comp","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V1\ninst✝⁷ : Module k V1\ninst✝⁶ : AddTorsor V1 P1\ninst✝⁵ : AddCommGroup V2\ninst✝⁴ : Module k V2\ninst✝³ : AddTorsor V2 P2\ninst✝² : AddCommGroup V3\ninst✝¹ : Module k V3\ninst✝ : AddTorsor V3 P3\nf : AffineMap k P2 P3\ng : AffineMap k P1 P2\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"/-- Composition of affine maps acts as applying the two functions. -/\n@[simp]\ntheorem coe_comp (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) : ⇑(f.comp g) = f ∘ g :=\n  rfl\n\n"}
{"name":"AffineMap.comp_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V1\ninst✝⁷ : Module k V1\ninst✝⁶ : AddTorsor V1 P1\ninst✝⁵ : AddCommGroup V2\ninst✝⁴ : Module k V2\ninst✝³ : AddTorsor V2 P2\ninst✝² : AddCommGroup V3\ninst✝¹ : Module k V3\ninst✝ : AddTorsor V3 P3\nf : AffineMap k P2 P3\ng : AffineMap k P1 P2\np : P1\n⊢ Eq ((f.comp g) p) (f (g p))","decl":"/-- Composition of affine maps acts as applying the two functions. -/\ntheorem comp_apply (f : P2 →ᵃ[k] P3) (g : P1 →ᵃ[k] P2) (p : P1) : f.comp g p = f (g p) :=\n  rfl\n\n"}
{"name":"AffineMap.comp_id","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Eq (f.comp (AffineMap.id k P1)) f","decl":"@[simp]\ntheorem comp_id (f : P1 →ᵃ[k] P2) : f.comp (id k P1) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineMap.id_comp","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Eq ((AffineMap.id k P2).comp f) f","decl":"@[simp]\ntheorem id_comp (f : P1 →ᵃ[k] P2) : (id k P2).comp f = f :=\n  ext fun _ => rfl\n\n"}
{"name":"AffineMap.comp_assoc","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\nV3 : Type u_6\nP3 : Type u_7\nV4 : Type u_8\nP4 : Type u_9\ninst✝¹² : Ring k\ninst✝¹¹ : AddCommGroup V1\ninst✝¹⁰ : Module k V1\ninst✝⁹ : AddTorsor V1 P1\ninst✝⁸ : AddCommGroup V2\ninst✝⁷ : Module k V2\ninst✝⁶ : AddTorsor V2 P2\ninst✝⁵ : AddCommGroup V3\ninst✝⁴ : Module k V3\ninst✝³ : AddTorsor V3 P3\ninst✝² : AddCommGroup V4\ninst✝¹ : Module k V4\ninst✝ : AddTorsor V4 P4\nf₃₄ : AffineMap k P3 P4\nf₂₃ : AffineMap k P2 P3\nf₁₂ : AffineMap k P1 P2\n⊢ Eq ((f₃₄.comp f₂₃).comp f₁₂) (f₃₄.comp (f₂₃.comp f₁₂))","decl":"theorem comp_assoc (f₃₄ : P3 →ᵃ[k] P4) (f₂₃ : P2 →ᵃ[k] P3) (f₁₂ : P1 →ᵃ[k] P2) :\n    (f₃₄.comp f₂₃).comp f₁₂ = f₃₄.comp (f₂₃.comp f₁₂) :=\n  rfl\n\n"}
{"name":"AffineMap.coe_mul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\nf g : AffineMap k P1 P1\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_mul (f g : P1 →ᵃ[k] P1) : ⇑(f * g) = f ∘ g :=\n  rfl\n\n"}
{"name":"AffineMap.coe_one","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\n⊢ Eq (⇑1) id","decl":"@[simp]\ntheorem coe_one : ⇑(1 : P1 →ᵃ[k] P1) = _root_.id :=\n  rfl\n\n"}
{"name":"AffineMap.linearHom_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\nself : AffineMap k P1 P1\n⊢ Eq (AffineMap.linearHom self) self.linear","decl":"/-- `AffineMap.linear` on endomorphisms is a `MonoidHom`. -/\n@[simps]\ndef linearHom : (P1 →ᵃ[k] P1) →* V1 →ₗ[k] V1 where\n  toFun := linear\n  map_one' := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AffineMap.linear_injective_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Iff (Function.Injective ⇑f.linear) (Function.Injective ⇑f)","decl":"@[simp]\ntheorem linear_injective_iff (f : P1 →ᵃ[k] P2) :\n    Function.Injective f.linear ↔ Function.Injective f := by\n  obtain ⟨p⟩ := (inferInstance : Nonempty P1)\n  have h : ⇑f.linear = (Equiv.vaddConst (f p)).symm ∘ f ∘ Equiv.vaddConst p := by\n    ext v\n    simp [f.map_vadd, vadd_vsub_assoc]\n  rw [h, Equiv.comp_injective, Equiv.injective_comp]\n\n"}
{"name":"AffineMap.linear_surjective_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Iff (Function.Surjective ⇑f.linear) (Function.Surjective ⇑f)","decl":"@[simp]\ntheorem linear_surjective_iff (f : P1 →ᵃ[k] P2) :\n    Function.Surjective f.linear ↔ Function.Surjective f := by\n  obtain ⟨p⟩ := (inferInstance : Nonempty P1)\n  have h : ⇑f.linear = (Equiv.vaddConst (f p)).symm ∘ f ∘ Equiv.vaddConst p := by\n    ext v\n    simp [f.map_vadd, vadd_vsub_assoc]\n  rw [h, Equiv.comp_surjective, Equiv.surjective_comp]\n\n"}
{"name":"AffineMap.linear_bijective_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\n⊢ Iff (Function.Bijective ⇑f.linear) (Function.Bijective ⇑f)","decl":"@[simp]\ntheorem linear_bijective_iff (f : P1 →ᵃ[k] P2) :\n    Function.Bijective f.linear ↔ Function.Bijective f :=\n  and_congr f.linear_injective_iff f.linear_surjective_iff\n\n"}
{"name":"AffineMap.image_vsub_image","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\ns t : Set P1\nf : AffineMap k P1 P2\n⊢ Eq (VSub.vsub (Set.image (⇑f) s) (Set.image (⇑f) t)) (Set.image (⇑f.linear) (VSub.vsub s t))","decl":"theorem image_vsub_image {s t : Set P1} (f : P1 →ᵃ[k] P2) :\n    f '' s -ᵥ f '' t = f.linear '' (s -ᵥ t) := by\n  ext v\n  -- Porting note: `simp` needs `Set.mem_vsub` to be an expression\n  simp only [(Set.mem_vsub), Set.mem_image,\n    exists_exists_and_eq_and, exists_and_left, ← f.linearMap_vsub]\n  constructor\n  · rintro ⟨x, hx, y, hy, hv⟩\n    exact ⟨x -ᵥ y, ⟨x, hx, y, hy, rfl⟩, hv⟩\n  · rintro ⟨-, ⟨x, hx, y, hy, rfl⟩, rfl⟩\n    exact ⟨x, hx, y, hy, rfl⟩\n\n"}
{"name":"AffineMap.coe_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\n⊢ Eq ⇑(AffineMap.lineMap p₀ p₁) fun c => HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p₁ p₀)) p₀","decl":"theorem coe_lineMap (p₀ p₁ : P1) : (lineMap p₀ p₁ : k → P1) = fun c => c • (p₁ -ᵥ p₀) +ᵥ p₀ :=\n  rfl\n\n"}
{"name":"AffineMap.lineMap_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) c) (HVAdd.hVAdd (HSMul.hSMul c (VSub.vsub p₁ p₀)) p₀)","decl":"theorem lineMap_apply (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c = c • (p₁ -ᵥ p₀) +ᵥ p₀ :=\n  rfl\n\n"}
{"name":"AffineMap.lineMap_apply_module'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V1\ninst✝ : Module k V1\np₀ p₁ : V1\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) c) (HAdd.hAdd (HSMul.hSMul c (HSub.hSub p₁ p₀)) p₀)","decl":"theorem lineMap_apply_module' (p₀ p₁ : V1) (c : k) : lineMap p₀ p₁ c = c • (p₁ - p₀) + p₀ :=\n  rfl\n\n"}
{"name":"AffineMap.lineMap_apply_module","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\ninst✝² : Ring k\ninst✝¹ : AddCommGroup V1\ninst✝ : Module k V1\np₀ p₁ : V1\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) c) (HAdd.hAdd (HSMul.hSMul (HSub.hSub 1 c) p₀) (HSMul.hSMul c p₁))","decl":"theorem lineMap_apply_module (p₀ p₁ : V1) (c : k) : lineMap p₀ p₁ c = (1 - c) • p₀ + c • p₁ := by\n  simp [lineMap_apply_module', smul_sub, sub_smul]; abel\n\n"}
{"name":"AffineMap.lineMap_apply_ring'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\ninst✝ : Ring k\na b c : k\n⊢ Eq ((AffineMap.lineMap a b) c) (HAdd.hAdd (HMul.hMul c (HSub.hSub b a)) a)","decl":"theorem lineMap_apply_ring' (a b c : k) : lineMap a b c = c * (b - a) + a :=\n  rfl\n\n"}
{"name":"AffineMap.lineMap_apply_ring","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\ninst✝ : Ring k\na b c : k\n⊢ Eq ((AffineMap.lineMap a b) c) (HAdd.hAdd (HMul.hMul (HSub.hSub 1 c) a) (HMul.hMul c b))","decl":"theorem lineMap_apply_ring (a b c : k) : lineMap a b c = (1 - c) * a + c * b :=\n  lineMap_apply_module a b c\n\n"}
{"name":"AffineMap.lineMap_vadd_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np : P1\nv : V1\nc : k\n⊢ Eq ((AffineMap.lineMap p (HVAdd.hVAdd v p)) c) (HVAdd.hVAdd (HSMul.hSMul c v) p)","decl":"theorem lineMap_vadd_apply (p : P1) (v : V1) (c : k) : lineMap p (v +ᵥ p) c = c • v +ᵥ p := by\n  rw [lineMap_apply, vadd_vsub]\n\n"}
{"name":"AffineMap.lineMap_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\n⊢ Eq (AffineMap.lineMap p₀ p₁).linear (LinearMap.id.smulRight (VSub.vsub p₁ p₀))","decl":"@[simp]\ntheorem lineMap_linear (p₀ p₁ : P1) :\n    (lineMap p₀ p₁ : k →ᵃ[k] P1).linear = LinearMap.id.smulRight (p₁ -ᵥ p₀) :=\n  add_zero _\n\n"}
{"name":"AffineMap.lineMap_same_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np : P1\nc : k\n⊢ Eq ((AffineMap.lineMap p p) c) p","decl":"theorem lineMap_same_apply (p : P1) (c : k) : lineMap p p c = p := by\n  simp [lineMap_apply]\n\n"}
{"name":"AffineMap.lineMap_same","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np : P1\n⊢ Eq (AffineMap.lineMap p p) (AffineMap.const k k p)","decl":"@[simp]\ntheorem lineMap_same (p : P1) : lineMap p p = const k k p :=\n  ext <| lineMap_same_apply p\n\n"}
{"name":"AffineMap.lineMap_apply_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\n⊢ Eq ((AffineMap.lineMap p₀ p₁) 0) p₀","decl":"@[simp]\ntheorem lineMap_apply_zero (p₀ p₁ : P1) : lineMap p₀ p₁ (0 : k) = p₀ := by\n  simp [lineMap_apply]\n\n"}
{"name":"AffineMap.lineMap_apply_one","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\n⊢ Eq ((AffineMap.lineMap p₀ p₁) 1) p₁","decl":"@[simp]\ntheorem lineMap_apply_one (p₀ p₁ : P1) : lineMap p₀ p₁ (1 : k) = p₁ := by\n  simp [lineMap_apply]\n\n"}
{"name":"AffineMap.lineMap_eq_lineMap_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : NoZeroSMulDivisors k V1\np₀ p₁ : P1\nc₁ c₂ : k\n⊢ Iff (Eq ((AffineMap.lineMap p₀ p₁) c₁) ((AffineMap.lineMap p₀ p₁) c₂)) (Or (Eq p₀ p₁) (Eq c₁ c₂))","decl":"@[simp]\ntheorem lineMap_eq_lineMap_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c₁ c₂ : k} :\n    lineMap p₀ p₁ c₁ = lineMap p₀ p₁ c₂ ↔ p₀ = p₁ ∨ c₁ = c₂ := by\n  rw [lineMap_apply, lineMap_apply, ← @vsub_eq_zero_iff_eq V1, vadd_vsub_vadd_cancel_right, ←\n    sub_smul, smul_eq_zero, sub_eq_zero, vsub_eq_zero_iff_eq, or_comm, eq_comm]\n\n"}
{"name":"AffineMap.lineMap_eq_left_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : NoZeroSMulDivisors k V1\np₀ p₁ : P1\nc : k\n⊢ Iff (Eq ((AffineMap.lineMap p₀ p₁) c) p₀) (Or (Eq p₀ p₁) (Eq c 0))","decl":"@[simp]\ntheorem lineMap_eq_left_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c : k} :\n    lineMap p₀ p₁ c = p₀ ↔ p₀ = p₁ ∨ c = 0 := by\n  rw [← @lineMap_eq_lineMap_iff k V1, lineMap_apply_zero]\n\n"}
{"name":"AffineMap.lineMap_eq_right_iff","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : NoZeroSMulDivisors k V1\np₀ p₁ : P1\nc : k\n⊢ Iff (Eq ((AffineMap.lineMap p₀ p₁) c) p₁) (Or (Eq p₀ p₁) (Eq c 1))","decl":"@[simp]\ntheorem lineMap_eq_right_iff [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} {c : k} :\n    lineMap p₀ p₁ c = p₁ ↔ p₀ = p₁ ∨ c = 1 := by\n  rw [← @lineMap_eq_lineMap_iff k V1, lineMap_apply_one]\n\n"}
{"name":"AffineMap.lineMap_injective","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : NoZeroSMulDivisors k V1\np₀ p₁ : P1\nh : Ne p₀ p₁\n⊢ Function.Injective ⇑(AffineMap.lineMap p₀ p₁)","decl":"theorem lineMap_injective [NoZeroSMulDivisors k V1] {p₀ p₁ : P1} (h : p₀ ≠ p₁) :\n    Function.Injective (lineMap p₀ p₁ : k → P1) := fun _c₁ _c₂ hc =>\n  (lineMap_eq_lineMap_iff.mp hc).resolve_left h\n\n"}
{"name":"AffineMap.apply_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\np₀ p₁ : P1\nc : k\n⊢ Eq (f ((AffineMap.lineMap p₀ p₁) c)) ((AffineMap.lineMap (f p₀) (f p₁)) c)","decl":"@[simp]\ntheorem apply_lineMap (f : P1 →ᵃ[k] P2) (p₀ p₁ : P1) (c : k) :\n    f (lineMap p₀ p₁ c) = lineMap (f p₀) (f p₁) c := by\n  simp [lineMap_apply]\n\n"}
{"name":"AffineMap.comp_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\nf : AffineMap k P1 P2\np₀ p₁ : P1\n⊢ Eq (f.comp (AffineMap.lineMap p₀ p₁)) (AffineMap.lineMap (f p₀) (f p₁))","decl":"@[simp]\ntheorem comp_lineMap (f : P1 →ᵃ[k] P2) (p₀ p₁ : P1) :\n    f.comp (lineMap p₀ p₁) = lineMap (f p₀) (f p₁) :=\n  ext <| f.apply_lineMap p₀ p₁\n\n"}
{"name":"AffineMap.fst_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\np₀ p₁ : Prod P1 P2\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) c).1 ((AffineMap.lineMap p₀.1 p₁.1) c)","decl":"@[simp]\ntheorem fst_lineMap (p₀ p₁ : P1 × P2) (c : k) : (lineMap p₀ p₁ c).1 = lineMap p₀.1 p₁.1 c :=\n  fst.apply_lineMap p₀ p₁ c\n\n"}
{"name":"AffineMap.snd_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\nV2 : Type u_4\nP2 : Type u_5\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : Module k V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : AddCommGroup V2\ninst✝¹ : Module k V2\ninst✝ : AddTorsor V2 P2\np₀ p₁ : Prod P1 P2\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) c).2 ((AffineMap.lineMap p₀.2 p₁.2) c)","decl":"@[simp]\ntheorem snd_lineMap (p₀ p₁ : P1 × P2) (c : k) : (lineMap p₀ p₁ c).2 = lineMap p₀.2 p₁.2 c :=\n  snd.apply_lineMap p₀ p₁ c\n\n"}
{"name":"AffineMap.lineMap_symm","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\n⊢ Eq (AffineMap.lineMap p₀ p₁) ((AffineMap.lineMap p₁ p₀).comp (AffineMap.lineMap 1 0))","decl":"theorem lineMap_symm (p₀ p₁ : P1) :\n    lineMap p₀ p₁ = (lineMap p₁ p₀).comp (lineMap (1 : k) (0 : k)) := by\n  rw [comp_lineMap]\n  simp\n\n"}
{"name":"AffineMap.lineMap_apply_one_sub","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq ((AffineMap.lineMap p₀ p₁) (HSub.hSub 1 c)) ((AffineMap.lineMap p₁ p₀) c)","decl":"theorem lineMap_apply_one_sub (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ (1 - c) = lineMap p₁ p₀ c := by\n  rw [lineMap_symm p₀, comp_apply]\n  congr\n  simp [lineMap_apply]\n\n"}
{"name":"AffineMap.lineMap_vsub_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq (VSub.vsub ((AffineMap.lineMap p₀ p₁) c) p₀) (HSMul.hSMul c (VSub.vsub p₁ p₀))","decl":"@[simp]\ntheorem lineMap_vsub_left (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c -ᵥ p₀ = c • (p₁ -ᵥ p₀) :=\n  vadd_vsub _ _\n\n"}
{"name":"AffineMap.left_vsub_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq (VSub.vsub p₀ ((AffineMap.lineMap p₀ p₁) c)) (HSMul.hSMul c (VSub.vsub p₀ p₁))","decl":"@[simp]\ntheorem left_vsub_lineMap (p₀ p₁ : P1) (c : k) : p₀ -ᵥ lineMap p₀ p₁ c = c • (p₀ -ᵥ p₁) := by\n  rw [← neg_vsub_eq_vsub_rev, lineMap_vsub_left, ← smul_neg, neg_vsub_eq_vsub_rev]\n\n"}
{"name":"AffineMap.lineMap_vsub_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq (VSub.vsub ((AffineMap.lineMap p₀ p₁) c) p₁) (HSMul.hSMul (HSub.hSub 1 c) (VSub.vsub p₀ p₁))","decl":"@[simp]\ntheorem lineMap_vsub_right (p₀ p₁ : P1) (c : k) : lineMap p₀ p₁ c -ᵥ p₁ = (1 - c) • (p₀ -ᵥ p₁) := by\n  rw [← lineMap_apply_one_sub, lineMap_vsub_left]\n\n"}
{"name":"AffineMap.right_vsub_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc : k\n⊢ Eq (VSub.vsub p₁ ((AffineMap.lineMap p₀ p₁) c)) (HSMul.hSMul (HSub.hSub 1 c) (VSub.vsub p₁ p₀))","decl":"@[simp]\ntheorem right_vsub_lineMap (p₀ p₁ : P1) (c : k) : p₁ -ᵥ lineMap p₀ p₁ c = (1 - c) • (p₁ -ᵥ p₀) := by\n  rw [← lineMap_apply_one_sub, left_vsub_lineMap]\n\n"}
{"name":"AffineMap.lineMap_vadd_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\nv₁ v₂ : V1\np₁ p₂ : P1\nc : k\n⊢ Eq (HVAdd.hVAdd ((AffineMap.lineMap v₁ v₂) c) ((AffineMap.lineMap p₁ p₂) c)) ((AffineMap.lineMap (HVAdd.hVAdd v₁ p₁) (HVAdd.hVAdd v₂ p₂)) c)","decl":"theorem lineMap_vadd_lineMap (v₁ v₂ : V1) (p₁ p₂ : P1) (c : k) :\n    lineMap v₁ v₂ c +ᵥ lineMap p₁ p₂ c = lineMap (v₁ +ᵥ p₁) (v₂ +ᵥ p₂) c :=\n  ((fst : V1 × P1 →ᵃ[k] V1) +ᵥ (snd : V1 × P1 →ᵃ[k] P1)).apply_lineMap (v₁, p₁) (v₂, p₂) c\n\n"}
{"name":"AffineMap.lineMap_vsub_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₁ p₂ p₃ p₄ : P1\nc : k\n⊢ Eq (VSub.vsub ((AffineMap.lineMap p₁ p₂) c) ((AffineMap.lineMap p₃ p₄) c)) ((AffineMap.lineMap (VSub.vsub p₁ p₃) (VSub.vsub p₂ p₄)) c)","decl":"theorem lineMap_vsub_lineMap (p₁ p₂ p₃ p₄ : P1) (c : k) :\n    lineMap p₁ p₂ c -ᵥ lineMap p₃ p₄ c = lineMap (p₁ -ᵥ p₃) (p₂ -ᵥ p₄) c :=\n  ((fst : P1 × P1 →ᵃ[k] P1) -ᵥ (snd : P1 × P1 →ᵃ[k] P1)).apply_lineMap (_, _) (_, _) c\n\n"}
{"name":"AffineMap.lineMap_lineMap_right","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc d : k\n⊢ Eq ((AffineMap.lineMap p₀ ((AffineMap.lineMap p₀ p₁) c)) d) ((AffineMap.lineMap p₀ p₁) (HMul.hMul d c))","decl":"@[simp] lemma lineMap_lineMap_right (p₀ p₁ : P1) (c d : k) :\n    lineMap p₀ (lineMap p₀ p₁ c) d = lineMap p₀ p₁ (d * c) := by simp [lineMap_apply, mul_smul]\n\n"}
{"name":"AffineMap.lineMap_lineMap_left","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nP1 : Type u_3\ninst✝³ : Ring k\ninst✝² : AddCommGroup V1\ninst✝¹ : Module k V1\ninst✝ : AddTorsor V1 P1\np₀ p₁ : P1\nc d : k\n⊢ Eq ((AffineMap.lineMap ((AffineMap.lineMap p₀ p₁) c) p₁) d) ((AffineMap.lineMap p₀ p₁) (HSub.hSub 1 (HMul.hMul (HSub.hSub 1 d) (HSub.hSub 1 c))))","decl":"@[simp] lemma lineMap_lineMap_left (p₀ p₁ : P1) (c d : k) :\n    lineMap (lineMap p₀ p₁ c) p₁ d = lineMap p₀ p₁ (1 - (1 - d) * (1 - c)) := by\n  simp_rw [lineMap_apply_one_sub, ← lineMap_apply_one_sub p₁, lineMap_lineMap_right]\n\n"}
{"name":"AffineMap.decomp","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nV2 : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf : AffineMap k V1 V2\n⊢ Eq (⇑f) (HAdd.hAdd ⇑f.linear fun x => f 0)","decl":"/-- Decomposition of an affine map in the special case when the point space and vector space\nare the same. -/\ntheorem decomp (f : V1 →ᵃ[k] V2) : (f : V1 → V2) = ⇑f.linear + fun _ => f 0 := by\n  ext x\n  calc\n    f x = f.linear x +ᵥ f 0 := by rw [← f.map_vadd, vadd_eq_add, add_zero]\n    _ = (f.linear + fun _ : V1 => f 0) x := rfl\n\n"}
{"name":"AffineMap.decomp'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\nV1 : Type u_2\nV2 : Type u_4\ninst✝⁴ : Ring k\ninst✝³ : AddCommGroup V1\ninst✝² : Module k V1\ninst✝¹ : AddCommGroup V2\ninst✝ : Module k V2\nf : AffineMap k V1 V2\n⊢ Eq (⇑f.linear) (HSub.hSub ⇑f fun x => f 0)","decl":"/-- Decomposition of an affine map in the special case when the point space and vector space\nare the same. -/\ntheorem decomp' (f : V1 →ᵃ[k] V2) : (f.linear : V1 → V2) = ⇑f - fun _ => f 0 := by\n  rw [decomp]\n  simp only [LinearMap.map_zero, Pi.add_apply, add_sub_cancel_right, zero_add]\n\n"}
{"name":"AffineMap.image_uIcc","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_10\ninst✝ : LinearOrderedField k\nf : AffineMap k k k\na b : k\n⊢ Eq (Set.image (⇑f) (Set.uIcc a b)) (Set.uIcc (f a) (f b))","decl":"theorem image_uIcc {k : Type*} [LinearOrderedField k] (f : k →ᵃ[k] k) (a b : k) :\n    f '' Set.uIcc a b = Set.uIcc (f a) (f b) := by\n  have : ⇑f = (fun x => x + f 0) ∘ fun x => x * (f 1 - f 0) := by\n    ext x\n    change f x = x • (f 1 -ᵥ f 0) +ᵥ f 0\n    rw [← f.linearMap_vsub, ← f.linear.map_smul, ← f.map_vadd]\n    simp only [vsub_eq_sub, add_zero, mul_one, vadd_eq_add, sub_zero, smul_eq_mul]\n  rw [this, Set.image_comp]\n  simp only [Set.image_add_const_uIcc, Set.image_mul_const_uIcc, Function.comp_apply]\n\n"}
{"name":"AffineMap.proj_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\ninst✝³ : Ring k\nι : Type u_10\nV : ι → Type u_11\nP : ι → Type u_12\ninst✝² : (i : ι) → AddCommGroup (V i)\ninst✝¹ : (i : ι) → Module k (V i)\ninst✝ : (i : ι) → AddTorsor (V i) (P i)\ni : ι\nf : (i : ι) → P i\n⊢ Eq ((AffineMap.proj i) f) (f i)","decl":"@[simp]\ntheorem proj_apply (i : ι) (f : ∀ i, P i) : @proj k _ ι V P _ _ _ i f = f i :=\n  rfl\n\n"}
{"name":"AffineMap.proj_linear","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\ninst✝³ : Ring k\nι : Type u_10\nV : ι → Type u_11\nP : ι → Type u_12\ninst✝² : (i : ι) → AddCommGroup (V i)\ninst✝¹ : (i : ι) → Module k (V i)\ninst✝ : (i : ι) → AddTorsor (V i) (P i)\ni : ι\n⊢ Eq (AffineMap.proj i).linear (LinearMap.proj i)","decl":"@[simp]\ntheorem proj_linear (i : ι) : (@proj k _ ι V P _ _ _ i).linear = @LinearMap.proj k ι _ V _ _ i :=\n  rfl\n\n"}
{"name":"AffineMap.pi_lineMap_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_1\ninst✝³ : Ring k\nι : Type u_10\nV : ι → Type u_11\nP : ι → Type u_12\ninst✝² : (i : ι) → AddCommGroup (V i)\ninst✝¹ : (i : ι) → Module k (V i)\ninst✝ : (i : ι) → AddTorsor (V i) (P i)\nf g : (i : ι) → P i\nc : k\ni : ι\n⊢ Eq ((AffineMap.lineMap f g) c i) ((AffineMap.lineMap (f i) (g i)) c)","decl":"theorem pi_lineMap_apply (f g : ∀ i, P i) (c : k) (i : ι) :\n    lineMap f g c i = lineMap (f i) (g i) c :=\n  (proj i : (∀ i, P i) →ᵃ[k] P i).apply_lineMap f g c\n\n"}
{"name":"AffineMap.toConstProdLinearMap_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"R : Type u_1\nk : Type u_2\nV1 : Type u_3\nV2 : Type u_5\ninst✝⁷ : Ring k\ninst✝⁶ : AddCommGroup V1\ninst✝⁵ : AddCommGroup V2\ninst✝⁴ : Module k V1\ninst✝³ : Module k V2\ninst✝² : Semiring R\ninst✝¹ : Module R V2\ninst✝ : SMulCommClass k R V2\nf : AffineMap k V1 V2\n⊢ Eq ((AffineMap.toConstProdLinearMap R) f) { fst := f 0, snd := f.linear }","decl":"/-- The space of affine maps between two modules is linearly equivalent to the product of the\ndomain with the space of linear maps, by taking the value of the affine map at `(0 : V1)` and the\nlinear part.\n\nSee note [bundled maps over different rings]-/\n@[simps]\ndef toConstProdLinearMap : (V1 →ᵃ[k] V2) ≃ₗ[R] V2 × (V1 →ₗ[k] V2) where\n  toFun f := ⟨f 0, f.linear⟩\n  invFun p := p.2.toAffineMap + const k V1 p.1\n  left_inv f := by\n    ext\n    rw [f.decomp]\n    simp [const_apply _ _]  -- Porting note: `simp` needs `_`s to use this lemma\n  right_inv := by\n    rintro ⟨v, f⟩\n    ext <;> simp [const_apply _ _, const_linear _ _]  -- Porting note: `simp` needs `_`s\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"AffineMap.toConstProdLinearMap_symm_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"R : Type u_1\nk : Type u_2\nV1 : Type u_3\nV2 : Type u_5\ninst✝⁷ : Ring k\ninst✝⁶ : AddCommGroup V1\ninst✝⁵ : AddCommGroup V2\ninst✝⁴ : Module k V1\ninst✝³ : Module k V2\ninst✝² : Semiring R\ninst✝¹ : Module R V2\ninst✝ : SMulCommClass k R V2\np : Prod V2 (LinearMap (RingHom.id k) V1 V2)\n⊢ Eq ((AffineMap.toConstProdLinearMap R).symm p) (HAdd.hAdd p.2.toAffineMap (AffineMap.const k V1 p.1))","decl":"/-- The space of affine maps between two modules is linearly equivalent to the product of the\ndomain with the space of linear maps, by taking the value of the affine map at `(0 : V1)` and the\nlinear part.\n\nSee note [bundled maps over different rings]-/\n@[simps]\ndef toConstProdLinearMap : (V1 →ᵃ[k] V2) ≃ₗ[R] V2 × (V1 →ₗ[k] V2) where\n  toFun f := ⟨f 0, f.linear⟩\n  invFun p := p.2.toAffineMap + const k V1 p.1\n  left_inv f := by\n    ext\n    rw [f.decomp]\n    simp [const_apply _ _]  -- Porting note: `simp` needs `_`s to use this lemma\n  right_inv := by\n    rintro ⟨v, f⟩\n    ext <;> simp [const_apply _ _, const_linear _ _]  -- Porting note: `simp` needs `_`s\n  map_add' := by simp\n  map_smul' := by simp\n\n"}
{"name":"AffineMap.pi_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : AddTorsor V1 P1\ninst✝³ : Module k V1\nι : Type u_9\nφv : ι → Type u_10\nφp : ι → Type u_11\ninst✝² : (i : ι) → AddCommGroup (φv i)\ninst✝¹ : (i : ι) → Module k (φv i)\ninst✝ : (i : ι) → AddTorsor (φv i) (φp i)\nfp : (i : ι) → AffineMap k P1 (φp i)\nc : P1\ni : ι\n⊢ Eq ((AffineMap.pi fp) c i) ((fp i) c)","decl":"@[simp]\ntheorem pi_apply (c : P1) (i : ι) : pi fp c i = fp i c :=\n  rfl\n\n"}
{"name":"AffineMap.pi_comp","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\nV3 : Type u_7\nP3 : Type u_8\ninst✝⁹ : Ring k\ninst✝⁸ : AddCommGroup V1\ninst✝⁷ : AddTorsor V1 P1\ninst✝⁶ : AddCommGroup V3\ninst✝⁵ : AddTorsor V3 P3\ninst✝⁴ : Module k V1\ninst✝³ : Module k V3\nι : Type u_9\nφv : ι → Type u_10\nφp : ι → Type u_11\ninst✝² : (i : ι) → AddCommGroup (φv i)\ninst✝¹ : (i : ι) → Module k (φv i)\ninst✝ : (i : ι) → AddTorsor (φv i) (φp i)\nfp : (i : ι) → AffineMap k P1 (φp i)\ng : AffineMap k P3 P1\n⊢ Eq ((AffineMap.pi fp).comp g) (AffineMap.pi fun i => (fp i).comp g)","decl":"theorem pi_comp (g : P3 →ᵃ[k] P1) : (pi fp).comp g = pi (fun i => (fp i).comp g) :=\n  rfl\n\n"}
{"name":"AffineMap.pi_eq_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : Module k V1\nι : Type u_9\nφv : ι → Type u_10\ninst✝¹ : (i : ι) → AddCommGroup (φv i)\ninst✝ : (i : ι) → Module k (φv i)\nfv : (i : ι) → AffineMap k P1 (φv i)\n⊢ Iff (Eq (AffineMap.pi fv) 0) (∀ (i : ι), Eq (fv i) 0)","decl":"theorem pi_eq_zero : pi fv = 0 ↔ ∀ i, fv i = 0 := by\n  simp only [AffineMap.ext_iff, funext_iff, pi_apply]\n  exact forall_comm\n\n"}
{"name":"AffineMap.pi_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝⁵ : Ring k\ninst✝⁴ : AddCommGroup V1\ninst✝³ : AddTorsor V1 P1\ninst✝² : Module k V1\nι : Type u_9\nφv : ι → Type u_10\ninst✝¹ : (i : ι) → AddCommGroup (φv i)\ninst✝ : (i : ι) → Module k (φv i)\n⊢ Eq (AffineMap.pi fun x => 0) 0","decl":"theorem pi_zero : pi (fun _ ↦ 0 : (i : ι) → P1 →ᵃ[k] φv i) = 0 := by\n  ext; rfl\n\n"}
{"name":"AffineMap.proj_pi","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝⁶ : Ring k\ninst✝⁵ : AddCommGroup V1\ninst✝⁴ : AddTorsor V1 P1\ninst✝³ : Module k V1\nι : Type u_9\nφv : ι → Type u_10\nφp : ι → Type u_11\ninst✝² : (i : ι) → AddCommGroup (φv i)\ninst✝¹ : (i : ι) → Module k (φv i)\ninst✝ : (i : ι) → AddTorsor (φv i) (φp i)\nfp : (i : ι) → AffineMap k P1 (φp i)\ni : ι\n⊢ Eq ((AffineMap.proj i).comp (AffineMap.pi fp)) (fp i)","decl":"theorem proj_pi (i : ι) : (proj i).comp (pi fp) = fp i :=\n  ext fun _ => rfl\n"}
{"name":"AffineMap.pi_ext_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV2 : Type u_5\nP2 : Type u_6\ninst✝⁷ : Ring k\ninst✝⁶ : AddCommGroup V2\ninst✝⁵ : AddTorsor V2 P2\ninst✝⁴ : Module k V2\nι : Type u_9\nφv : ι → Type u_10\ninst✝³ : (i : ι) → AddCommGroup (φv i)\ninst✝² : (i : ι) → Module k (φv i)\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nf g : AffineMap k ((i : ι) → φv i) P2\nh : ∀ (i : ι) (x : φv i), Eq (f (Pi.single i x)) (g (Pi.single i x))\nh₂ : Eq (f 0) (g 0)\n⊢ Eq f g","decl":"/-- Two affine maps from a Pi-type of modules `(i : ι) → φv i` are equal if they are equal in their\n  operation on `Pi.single` and at zero. Analogous to `LinearMap.pi_ext`. See also `pi_ext_nonempty`,\n  which instead of agreement at zero requires `Nonempty ι`. -/\ntheorem pi_ext_zero (h : ∀ i x, f (Pi.single i x) = g (Pi.single i x)) (h₂ : f 0 = g 0) :\n    f = g := by\n  apply ext_linear\n  · apply LinearMap.pi_ext\n    intro i x\n    have s₁ := h i x\n    have s₂ := f.map_vadd 0 (Pi.single i x)\n    have s₃ := g.map_vadd 0 (Pi.single i x)\n    rw [vadd_eq_add, add_zero] at s₂ s₃\n    replace h₂ := h i 0\n    simp only [Pi.single_zero] at h₂\n    rwa [s₂, s₃, h₂, vadd_right_cancel_iff] at s₁\n  · exact h₂\n\n"}
{"name":"AffineMap.pi_ext_nonempty","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV2 : Type u_5\nP2 : Type u_6\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V2\ninst✝⁶ : AddTorsor V2 P2\ninst✝⁵ : Module k V2\nι : Type u_9\nφv : ι → Type u_10\ninst✝⁴ : (i : ι) → AddCommGroup (φv i)\ninst✝³ : (i : ι) → Module k (φv i)\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\nf g : AffineMap k ((i : ι) → φv i) P2\ninst✝ : Nonempty ι\nh : ∀ (i : ι) (x : φv i), Eq (f (Pi.single i x)) (g (Pi.single i x))\n⊢ Eq f g","decl":"/-- Two affine maps from a Pi-type of modules `(i : ι) → φv i` are equal if they are equal in their\n  operation on `Pi.single` and `ι` is nonempty.  Analogous to `LinearMap.pi_ext`. See also\n  `pi_ext_zero`, which instead `Nonempty ι` requires agreement at 0.-/\ntheorem pi_ext_nonempty [Nonempty ι] (h : ∀ i x, f (Pi.single i x) = g (Pi.single i x)) :\n    f = g := by\n  apply pi_ext_zero h\n  inhabit ι\n  rw [← Pi.single_zero default]\n  apply h\n\n"}
{"name":"AffineMap.pi_ext_nonempty'","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV2 : Type u_5\nP2 : Type u_6\ninst✝⁸ : Ring k\ninst✝⁷ : AddCommGroup V2\ninst✝⁶ : AddTorsor V2 P2\ninst✝⁵ : Module k V2\nι : Type u_9\nφv : ι → Type u_10\ninst✝⁴ : (i : ι) → AddCommGroup (φv i)\ninst✝³ : (i : ι) → Module k (φv i)\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\nf g : AffineMap k ((i : ι) → φv i) P2\ninst✝ : Nonempty ι\nh : ∀ (i : ι), Eq (f.comp (LinearMap.single k φv i).toAffineMap) (g.comp (LinearMap.single k φv i).toAffineMap)\n⊢ Eq f g","decl":"/-- This is used as the ext lemma instead of `AffineMap.pi_ext_nonempty` for reasons explained in\nnote [partially-applied ext lemmas]. Analogous to `LinearMap.pi_ext'`-/\n@[ext (iff := false)]\ntheorem pi_ext_nonempty' [Nonempty ι] (h : ∀ i, f.comp (LinearMap.single _ _ i).toAffineMap =\n    g.comp (LinearMap.single _ _ i).toAffineMap) : f = g := by\n  refine pi_ext_nonempty fun i x => ?_\n  convert AffineMap.congr_fun (h i) x\n\n"}
{"name":"AffineMap.homothety_def","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr : k\n⊢ Eq (AffineMap.homothety c r) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub (AffineMap.id k P1) (AffineMap.const k P1 c))) (AffineMap.const k P1 c))","decl":"theorem homothety_def (c : P1) (r : k) :\n    homothety c r = r • (id k P1 -ᵥ const k P1 c) +ᵥ const k P1 c :=\n  rfl\n\n"}
{"name":"AffineMap.homothety_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr : k\np : P1\n⊢ Eq ((AffineMap.homothety c r) p) (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p c)) c)","decl":"theorem homothety_apply (c : P1) (r : k) (p : P1) : homothety c r p = r • (p -ᵥ c : V1) +ᵥ c :=\n  rfl\n\n"}
{"name":"AffineMap.homothety_eq_lineMap","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr : k\np : P1\n⊢ Eq ((AffineMap.homothety c r) p) ((AffineMap.lineMap c p) r)","decl":"theorem homothety_eq_lineMap (c : P1) (r : k) (p : P1) : homothety c r p = lineMap c p r :=\n  rfl\n\n"}
{"name":"AffineMap.homothety_one","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\n⊢ Eq (AffineMap.homothety c 1) (AffineMap.id k P1)","decl":"@[simp]\ntheorem homothety_one (c : P1) : homothety c (1 : k) = id k P1 := by\n  ext p\n  simp [homothety_apply]\n\n"}
{"name":"AffineMap.homothety_apply_same","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr : k\n⊢ Eq ((AffineMap.homothety c r) c) c","decl":"@[simp]\ntheorem homothety_apply_same (c : P1) (r : k) : homothety c r c = c :=\n  lineMap_same_apply c r\n\n"}
{"name":"AffineMap.homothety_mul_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr₁ r₂ : k\np : P1\n⊢ Eq ((AffineMap.homothety c (HMul.hMul r₁ r₂)) p) ((AffineMap.homothety c r₁) ((AffineMap.homothety c r₂) p))","decl":"theorem homothety_mul_apply (c : P1) (r₁ r₂ : k) (p : P1) :\n    homothety c (r₁ * r₂) p = homothety c r₁ (homothety c r₂ p) := by\n  simp only [homothety_apply, mul_smul, vadd_vsub]\n\n"}
{"name":"AffineMap.homothety_mul","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr₁ r₂ : k\n⊢ Eq (AffineMap.homothety c (HMul.hMul r₁ r₂)) ((AffineMap.homothety c r₁).comp (AffineMap.homothety c r₂))","decl":"theorem homothety_mul (c : P1) (r₁ r₂ : k) :\n    homothety c (r₁ * r₂) = (homothety c r₁).comp (homothety c r₂) :=\n  ext <| homothety_mul_apply c r₁ r₂\n\n"}
{"name":"AffineMap.homothety_zero","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\n⊢ Eq (AffineMap.homothety c 0) (AffineMap.const k P1 c)","decl":"@[simp]\ntheorem homothety_zero (c : P1) : homothety c (0 : k) = const k P1 c := by\n  ext p\n  simp [homothety_apply]\n\n"}
{"name":"AffineMap.homothety_add","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\nr₁ r₂ : k\n⊢ Eq (AffineMap.homothety c (HAdd.hAdd r₁ r₂)) (HVAdd.hVAdd (HSMul.hSMul r₁ (VSub.vsub (AffineMap.id k P1) (AffineMap.const k P1 c))) (AffineMap.homothety c r₂))","decl":"@[simp]\ntheorem homothety_add (c : P1) (r₁ r₂ : k) :\n    homothety c (r₁ + r₂) = r₁ • (id k P1 -ᵥ const k P1 c) +ᵥ homothety c r₂ := by\n  simp only [homothety_def, add_smul, vadd_vadd]\n\n"}
{"name":"AffineMap.coe_homothetyHom","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\n⊢ Eq (⇑(AffineMap.homothetyHom c)) (AffineMap.homothety c)","decl":"@[simp]\ntheorem coe_homothetyHom (c : P1) : ⇑(homothetyHom c : k →* _) = homothety c :=\n  rfl\n\n"}
{"name":"AffineMap.coe_homothetyAffine","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"k : Type u_2\nV1 : Type u_3\nP1 : Type u_4\ninst✝³ : CommRing k\ninst✝² : AddCommGroup V1\ninst✝¹ : AddTorsor V1 P1\ninst✝ : Module k V1\nc : P1\n⊢ Eq (⇑(AffineMap.homothetyAffine c)) (AffineMap.homothety c)","decl":"@[simp]\ntheorem coe_homothetyAffine (c : P1) : ⇑(homothetyAffine c : k →ᵃ[k] _) = homothety c :=\n  rfl\n\n"}
{"name":"Convex.combo_affine_apply","module":"Mathlib.LinearAlgebra.AffineSpace.AffineMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : Ring 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 F\nx y : E\na b : 𝕜\nf : AffineMap 𝕜 E F\nh : Eq (HAdd.hAdd a b) 1\n⊢ Eq (f (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul b y))) (HAdd.hAdd (HSMul.hSMul a (f x)) (HSMul.hSMul b (f y)))","decl":"/-- Applying an affine map to an affine combination of two points yields an affine combination of\nthe images. -/\ntheorem Convex.combo_affine_apply {x y : E} {a b : 𝕜} {f : E →ᵃ[𝕜] F} (h : a + b = 1) :\n    f (a • x + b • y) = a • f x + b • f y := by\n  simp only [Convex.combo_eq_smul_sub_add h, ← vsub_eq_sub]\n  exact f.apply_lineMap _ _ _\n\n"}
