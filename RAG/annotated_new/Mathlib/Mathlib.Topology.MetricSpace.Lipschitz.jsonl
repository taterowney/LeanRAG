{"name":"lipschitzWith_iff_dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\n⊢ Iff (LipschitzWith K f) (∀ (x y : α), LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y)))","decl":"theorem lipschitzWith_iff_dist_le_mul [PseudoMetricSpace α] [PseudoMetricSpace β] {K : ℝ≥0}\n    {f : α → β} : LipschitzWith K f ↔ ∀ x y, dist (f x) (f y) ≤ K * dist x y := by\n  simp only [LipschitzWith, edist_nndist, dist_nndist]\n  norm_cast\n\n"}
{"name":"LipschitzWith.of_dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\na✝ : ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y))\n⊢ LipschitzWith K f","decl":"alias ⟨LipschitzWith.dist_le_mul, LipschitzWith.of_dist_le_mul⟩ := lipschitzWith_iff_dist_le_mul\n\n"}
{"name":"LipschitzWith.dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\na✝ : LipschitzWith K f\nx y : α\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y))","decl":"alias ⟨LipschitzWith.dist_le_mul, LipschitzWith.of_dist_le_mul⟩ := lipschitzWith_iff_dist_le_mul\n\n"}
{"name":"lipschitzOnWith_iff_dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\ns : Set α\nf : α → β\n⊢ Iff (LipschitzOnWith K f s) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y)))","decl":"theorem lipschitzOnWith_iff_dist_le_mul [PseudoMetricSpace α] [PseudoMetricSpace β] {K : ℝ≥0}\n    {s : Set α} {f : α → β} :\n    LipschitzOnWith K f s ↔ ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ K * dist x y := by\n  simp only [LipschitzOnWith, edist_nndist, dist_nndist]\n  norm_cast\n\n"}
{"name":"LipschitzOnWith.of_dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\ns : Set α\nf : α → β\na✝ : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y))\n⊢ LipschitzOnWith K f s","decl":"alias ⟨LipschitzOnWith.dist_le_mul, LipschitzOnWith.of_dist_le_mul⟩ :=\n  lipschitzOnWith_iff_dist_le_mul\n\n"}
{"name":"LipschitzOnWith.dist_le_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\ns : Set α\nf : α → β\na✝² : LipschitzOnWith K f s\nx : α\na✝¹ : Membership.mem s x\ny : α\na✝ : Membership.mem s y\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) (Dist.dist x y))","decl":"alias ⟨LipschitzOnWith.dist_le_mul, LipschitzOnWith.of_dist_le_mul⟩ :=\n  lipschitzOnWith_iff_dist_le_mul\n\n"}
{"name":"LipschitzWith.of_dist_le'","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nK : Real\nh : ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) (HMul.hMul K (Dist.dist x y))\n⊢ LipschitzWith K.toNNReal f","decl":"protected theorem of_dist_le' {K : ℝ} (h : ∀ x y, dist (f x) (f y) ≤ K * dist x y) :\n    LipschitzWith (Real.toNNReal K) f :=\n  of_dist_le_mul fun x y =>\n    le_trans (h x y) <| by gcongr; apply Real.le_coe_toNNReal\n\n"}
{"name":"LipschitzWith.mk_one","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nh : ∀ (x y : α), LE.le (Dist.dist (f x) (f y)) (Dist.dist x y)\n⊢ LipschitzWith 1 f","decl":"protected theorem mk_one (h : ∀ x y, dist (f x) (f y) ≤ dist x y) : LipschitzWith 1 f :=\n  of_dist_le_mul <| by simpa only [NNReal.coe_one, one_mul] using h\n\n"}
{"name":"LipschitzWith.of_le_add_mul'","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\nK : Real\nh : ∀ (x y : α), LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul K (Dist.dist x y)))\n⊢ LipschitzWith K.toNNReal f","decl":"/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\ndoesn't assume `0≤K`. -/\nprotected theorem of_le_add_mul' {f : α → ℝ} (K : ℝ) (h : ∀ x y, f x ≤ f y + K * dist x y) :\n    LipschitzWith (Real.toNNReal K) f :=\n  have I : ∀ x y, f x - f y ≤ K * dist x y := fun x y => sub_le_iff_le_add'.2 (h x y)\n  LipschitzWith.of_dist_le' fun x y => abs_sub_le_iff.2 ⟨I x y, dist_comm y x ▸ I y x⟩\n\n"}
{"name":"LipschitzWith.of_le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\nK : NNReal\nh : ∀ (x y : α), LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y)))\n⊢ LipschitzWith K f","decl":"/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\nassumes `0≤K`. -/\nprotected theorem of_le_add_mul {f : α → ℝ} (K : ℝ≥0) (h : ∀ x y, f x ≤ f y + K * dist x y) :\n    LipschitzWith K f := by simpa only [Real.toNNReal_coe] using LipschitzWith.of_le_add_mul' K h\n\n"}
{"name":"LipschitzWith.of_le_add","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\nh : ∀ (x y : α), LE.le (f x) (HAdd.hAdd (f y) (Dist.dist x y))\n⊢ LipschitzWith 1 f","decl":"protected theorem of_le_add {f : α → ℝ} (h : ∀ x y, f x ≤ f y + dist x y) : LipschitzWith 1 f :=\n  LipschitzWith.of_le_add_mul 1 <| by simpa only [NNReal.coe_one, one_mul]\n\n"}
{"name":"LipschitzWith.le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\nK : NNReal\nh : LipschitzWith K f\nx y : α\n⊢ LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y)))","decl":"protected theorem le_add_mul {f : α → ℝ} {K : ℝ≥0} (h : LipschitzWith K f) (x y) :\n    f x ≤ f y + K * dist x y :=\n  sub_le_iff_le_add'.1 <| le_trans (le_abs_self _) <| h.dist_le_mul x y\n\n"}
{"name":"LipschitzWith.iff_le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\nK : NNReal\n⊢ Iff (LipschitzWith K f) (∀ (x y : α), LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y))))","decl":"protected theorem iff_le_add_mul {f : α → ℝ} {K : ℝ≥0} :\n    LipschitzWith K f ↔ ∀ x y, f x ≤ f y + K * dist x y :=\n  ⟨LipschitzWith.le_add_mul, LipschitzWith.of_le_add_mul K⟩\n\n"}
{"name":"LipschitzWith.nndist_le","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\nx y : α\n⊢ LE.le (NNDist.nndist (f x) (f y)) (HMul.hMul K (NNDist.nndist x y))","decl":"theorem nndist_le (hf : LipschitzWith K f) (x y : α) : nndist (f x) (f y) ≤ K * nndist x y :=\n  hf.dist_le_mul x y\n\n"}
{"name":"LipschitzWith.dist_le_mul_of_le","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nx y : α\nr : Real\nhf : LipschitzWith K f\nhr : LE.le (Dist.dist x y) r\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (↑K) r)","decl":"theorem dist_le_mul_of_le (hf : LipschitzWith K f) (hr : dist x y ≤ r) : dist (f x) (f y) ≤ K * r :=\n  (hf.dist_le_mul x y).trans <| by gcongr\n\n"}
{"name":"LipschitzWith.mapsTo_closedBall","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\nx : α\nr : Real\n⊢ Set.MapsTo f (Metric.closedBall x r) (Metric.closedBall (f x) (HMul.hMul (↑K) r))","decl":"theorem mapsTo_closedBall (hf : LipschitzWith K f) (x : α) (r : ℝ) :\n    MapsTo f (Metric.closedBall x r) (Metric.closedBall (f x) (K * r)) := fun _y hy =>\n  hf.dist_le_mul_of_le hy\n\n"}
{"name":"LipschitzWith.dist_lt_mul_of_lt","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nx y : α\nr : Real\nhf : LipschitzWith K f\nhK : Ne K 0\nhr : LT.lt (Dist.dist x y) r\n⊢ LT.lt (Dist.dist (f x) (f y)) (HMul.hMul (↑K) r)","decl":"theorem dist_lt_mul_of_lt (hf : LipschitzWith K f) (hK : K ≠ 0) (hr : dist x y < r) :\n    dist (f x) (f y) < K * r :=\n  (hf.dist_le_mul x y).trans_lt <| (mul_lt_mul_left <| NNReal.coe_pos.2 hK.bot_lt).2 hr\n\n"}
{"name":"LipschitzWith.mapsTo_ball","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\nhK : Ne K 0\nx : α\nr : Real\n⊢ Set.MapsTo f (Metric.ball x r) (Metric.ball (f x) (HMul.hMul (↑K) r))","decl":"theorem mapsTo_ball (hf : LipschitzWith K f) (hK : K ≠ 0) (x : α) (r : ℝ) :\n    MapsTo f (Metric.ball x r) (Metric.ball (f x) (K * r)) := fun _y hy =>\n  hf.dist_lt_mul_of_lt hK hy\n\n"}
{"name":"LipschitzWith.coe_toLocallyBoundedMap","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\n⊢ Eq (⇑(LipschitzWith.toLocallyBoundedMap f hf)) f","decl":"@[simp]\ntheorem coe_toLocallyBoundedMap (hf : LipschitzWith K f) : ⇑(hf.toLocallyBoundedMap f) = f :=\n  rfl\n\n"}
{"name":"LipschitzWith.comap_cobounded_le","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\n⊢ LE.le (Filter.comap f (Bornology.cobounded β)) (Bornology.cobounded α)","decl":"theorem comap_cobounded_le (hf : LipschitzWith K f) :\n    comap f (Bornology.cobounded β) ≤ Bornology.cobounded α :=\n  (hf.toLocallyBoundedMap f).2\n\n"}
{"name":"LipschitzWith.isBounded_image","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\ns : Set α\nhs : Bornology.IsBounded s\n⊢ Bornology.IsBounded (Set.image f s)","decl":"/-- The image of a bounded set under a Lipschitz map is bounded. -/\ntheorem isBounded_image (hf : LipschitzWith K f) {s : Set α} (hs : IsBounded s) :\n    IsBounded (f '' s) :=\n  hs.image (toLocallyBoundedMap f hf)\n\n"}
{"name":"LipschitzWith.diam_image_le","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\ns : Set α\nhs : Bornology.IsBounded s\n⊢ LE.le (Metric.diam (Set.image f s)) (HMul.hMul (↑K) (Metric.diam s))","decl":"theorem diam_image_le (hf : LipschitzWith K f) (s : Set α) (hs : IsBounded s) :\n    Metric.diam (f '' s) ≤ K * Metric.diam s :=\n  Metric.diam_le_of_forall_dist_le (mul_nonneg K.coe_nonneg Metric.diam_nonneg) <|\n    forall_mem_image.2 fun _x hx =>\n      forall_mem_image.2 fun _y hy => hf.dist_le_mul_of_le <| Metric.dist_le_diam_of_mem hs hx hy\n\n"}
{"name":"LipschitzWith.dist_left","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ny : α\n⊢ LipschitzWith 1 fun x => Dist.dist x y","decl":"protected theorem dist_left (y : α) : LipschitzWith 1 (dist · y) :=\n  LipschitzWith.mk_one fun _ _ => dist_dist_dist_le_left _ _ _\n\n"}
{"name":"LipschitzWith.dist_right","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nx : α\n⊢ LipschitzWith 1 (Dist.dist x)","decl":"protected theorem dist_right (x : α) : LipschitzWith 1 (dist x) :=\n  LipschitzWith.of_le_add fun _ _ => dist_triangle_right _ _ _\n\n"}
{"name":"LipschitzWith.dist","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\n⊢ LipschitzWith 2 (Function.uncurry Dist.dist)","decl":"protected theorem dist : LipschitzWith 2 (Function.uncurry <| @dist α _) := by\n  rw [← one_add_one_eq_two]\n  exact LipschitzWith.uncurry LipschitzWith.dist_left LipschitzWith.dist_right\n\n"}
{"name":"LipschitzWith.dist_iterate_succ_le_geometric","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nK : NNReal\nf : α → α\nhf : LipschitzWith K f\nx : α\nn : Nat\n⊢ LE.le (Dist.dist (Nat.iterate f n x) (Nat.iterate f (HAdd.hAdd n 1) x)) (HMul.hMul (Dist.dist x (f x)) (HPow.hPow (↑K) n))","decl":"theorem dist_iterate_succ_le_geometric {f : α → α} (hf : LipschitzWith K f) (x n) :\n    dist (f^[n] x) (f^[n + 1] x) ≤ dist x (f x) * (K : ℝ) ^ n := by\n  rw [iterate_succ, mul_comm]\n  simpa only [NNReal.coe_pow] using (hf.iterate n).dist_le_mul x (f x)\n\n"}
{"name":"lipschitzWith_max","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"⊢ LipschitzWith 1 fun p => Max.max p.1 p.2","decl":"theorem _root_.lipschitzWith_max : LipschitzWith 1 fun p : ℝ × ℝ => max p.1 p.2 :=\n  LipschitzWith.of_le_add fun _ _ => sub_le_iff_le_add'.1 <|\n    (le_abs_self _).trans (abs_max_sub_max_le_max _ _ _ _)\n\n"}
{"name":"lipschitzWith_min","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"⊢ LipschitzWith 1 fun p => Min.min p.1 p.2","decl":"theorem _root_.lipschitzWith_min : LipschitzWith 1 fun p : ℝ × ℝ => min p.1 p.2 :=\n  LipschitzWith.of_le_add fun _ _ => sub_le_iff_le_add'.1 <|\n    (le_abs_self _).trans (abs_min_sub_min_le_max _ _ _ _)\n\n"}
{"name":"Real.lipschitzWith_toNNReal","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"⊢ LipschitzWith 1 Real.toNNReal","decl":"lemma _root_.Real.lipschitzWith_toNNReal : LipschitzWith 1 Real.toNNReal := by\n  refine lipschitzWith_iff_dist_le_mul.mpr (fun x y ↦ ?_)\n  simpa only [NNReal.coe_one, dist_prod_same_right, one_mul, Real.dist_eq] using\n    lipschitzWith_iff_dist_le_mul.mp lipschitzWith_max (x, 0) (y, 0)\n\n"}
{"name":"LipschitzWith.cauchySeq_comp","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\nf : α → β\nhf : LipschitzWith K f\nu : Nat → α\nhu : CauchySeq u\n⊢ CauchySeq (Function.comp f u)","decl":"lemma cauchySeq_comp (hf : LipschitzWith K f) {u : ℕ → α} (hu : CauchySeq u) :\n    CauchySeq (f ∘ u) := by\n  rcases cauchySeq_iff_le_tendsto_0.1 hu with ⟨b, b_nonneg, hb, blim⟩\n  refine cauchySeq_iff_le_tendsto_0.2 ⟨fun n ↦ K * b n, ?_, ?_, ?_⟩\n  · exact fun n ↦ mul_nonneg (by positivity) (b_nonneg n)\n  · exact fun n m N hn hm ↦ hf.dist_le_mul_of_le (hb n m N hn hm)\n  · rw [← mul_zero (K : ℝ)]\n    exact blim.const_mul _\n\n"}
{"name":"LipschitzWith.max","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf g : α → Real\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n⊢ LipschitzWith (Max.max Kf Kg) fun x => Max.max (f x) (g x)","decl":"protected theorem max (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => max (f x) (g x) := by\n  simpa only [(· ∘ ·), one_mul] using lipschitzWith_max.comp (hf.prod hg)\n\n"}
{"name":"LipschitzWith.min","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf g : α → Real\nKf Kg : NNReal\nhf : LipschitzWith Kf f\nhg : LipschitzWith Kg g\n⊢ LipschitzWith (Max.max Kf Kg) fun x => Min.min (f x) (g x)","decl":"protected theorem min (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => min (f x) (g x) := by\n  simpa only [(· ∘ ·), one_mul] using lipschitzWith_min.comp (hf.prod hg)\n\n"}
{"name":"LipschitzWith.max_const","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nKf : NNReal\nhf : LipschitzWith Kf f\na : Real\n⊢ LipschitzWith Kf fun x => Max.max (f x) a","decl":"theorem max_const (hf : LipschitzWith Kf f) (a : ℝ) : LipschitzWith Kf fun x => max (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.max (LipschitzWith.const a)\n\n"}
{"name":"LipschitzWith.const_max","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nKf : NNReal\nhf : LipschitzWith Kf f\na : Real\n⊢ LipschitzWith Kf fun x => Max.max a (f x)","decl":"theorem const_max (hf : LipschitzWith Kf f) (a : ℝ) : LipschitzWith Kf fun x => max a (f x) := by\n  simpa only [max_comm] using hf.max_const a\n\n"}
{"name":"LipschitzWith.min_const","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nKf : NNReal\nhf : LipschitzWith Kf f\na : Real\n⊢ LipschitzWith Kf fun x => Min.min (f x) a","decl":"theorem min_const (hf : LipschitzWith Kf f) (a : ℝ) : LipschitzWith Kf fun x => min (f x) a := by\n  simpa only [max_eq_left (zero_le Kf)] using hf.min (LipschitzWith.const a)\n\n"}
{"name":"LipschitzWith.const_min","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nKf : NNReal\nhf : LipschitzWith Kf f\na : Real\n⊢ LipschitzWith Kf fun x => Min.min a (f x)","decl":"theorem const_min (hf : LipschitzWith Kf f) (a : ℝ) : LipschitzWith Kf fun x => min a (f x) := by\n  simpa only [min_comm] using hf.min_const a\n\n"}
{"name":"LipschitzWith.projIcc","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"a b : Real\nh : LE.le a b\n⊢ LipschitzWith 1 (Set.projIcc a b h)","decl":"protected theorem projIcc {a b : ℝ} (h : a ≤ b) : LipschitzWith 1 (projIcc a b h) :=\n  ((LipschitzWith.id.const_min _).const_max _).subtype_mk _\n\n"}
{"name":"LipschitzOnWith.of_dist_le'","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\ns : Set α\nf : α → β\nK : Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist (f x) (f y)) (HMul.hMul K (Dist.dist x y))\n⊢ LipschitzOnWith K.toNNReal f s","decl":"protected theorem of_dist_le' {K : ℝ} (h : ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ K * dist x y) :\n    LipschitzOnWith (Real.toNNReal K) f s :=\n  of_dist_le_mul fun x hx y hy =>\n    le_trans (h x hx y hy) <| by gcongr; apply Real.le_coe_toNNReal\n\n"}
{"name":"LipschitzOnWith.mk_one","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\ns : Set α\nf : α → β\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (Dist.dist (f x) (f y)) (Dist.dist x y)\n⊢ LipschitzOnWith 1 f s","decl":"protected theorem mk_one (h : ∀ x ∈ s, ∀ y ∈ s, dist (f x) (f y) ≤ dist x y) :\n    LipschitzOnWith 1 f s :=\n  of_dist_le_mul <| by simpa only [NNReal.coe_one, one_mul] using h\n\n"}
{"name":"LipschitzOnWith.of_le_add_mul'","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nf : α → Real\nK : Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul K (Dist.dist x y)))\n⊢ LipschitzOnWith K.toNNReal f s","decl":"/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\ndoesn't assume `0≤K`. -/\nprotected theorem of_le_add_mul' {f : α → ℝ} (K : ℝ)\n    (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y) : LipschitzOnWith (Real.toNNReal K) f s :=\n  have I : ∀ x ∈ s, ∀ y ∈ s, f x - f y ≤ K * dist x y := fun x hx y hy =>\n    sub_le_iff_le_add'.2 (h x hx y hy)\n  LipschitzOnWith.of_dist_le' fun x hx y hy =>\n    abs_sub_le_iff.2 ⟨I x hx y hy, dist_comm y x ▸ I y hy x hx⟩\n\n"}
{"name":"LipschitzOnWith.of_le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nf : α → Real\nK : NNReal\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y)))\n⊢ LipschitzOnWith K f s","decl":"/-- For functions to `ℝ`, it suffices to prove `f x ≤ f y + K * dist x y`; this version\nassumes `0≤K`. -/\nprotected theorem of_le_add_mul {f : α → ℝ} (K : ℝ≥0)\n    (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y) : LipschitzOnWith K f s := by\n  simpa only [Real.toNNReal_coe] using LipschitzOnWith.of_le_add_mul' K h\n\n"}
{"name":"LipschitzOnWith.of_le_add","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nf : α → Real\nh : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (f x) (HAdd.hAdd (f y) (Dist.dist x y))\n⊢ LipschitzOnWith 1 f s","decl":"protected theorem of_le_add {f : α → ℝ} (h : ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + dist x y) :\n    LipschitzOnWith 1 f s :=\n  LipschitzOnWith.of_le_add_mul 1 <| by simpa only [NNReal.coe_one, one_mul]\n\n"}
{"name":"LipschitzOnWith.le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nf : α → Real\nK : NNReal\nh : LipschitzOnWith K f s\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\n⊢ LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y)))","decl":"protected theorem le_add_mul {f : α → ℝ} {K : ℝ≥0} (h : LipschitzOnWith K f s) {x : α} (hx : x ∈ s)\n    {y : α} (hy : y ∈ s) : f x ≤ f y + K * dist x y :=\n  sub_le_iff_le_add'.1 <| le_trans (le_abs_self _) <| h.dist_le_mul x hx y hy\n\n"}
{"name":"LipschitzOnWith.iff_le_add_mul","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\ns : Set α\nf : α → Real\nK : NNReal\n⊢ Iff (LipschitzOnWith K f s) (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le (f x) (HAdd.hAdd (f y) (HMul.hMul (↑K) (Dist.dist x y))))","decl":"protected theorem iff_le_add_mul {f : α → ℝ} {K : ℝ≥0} :\n    LipschitzOnWith K f s ↔ ∀ x ∈ s, ∀ y ∈ s, f x ≤ f y + K * dist x y :=\n  ⟨LipschitzOnWith.le_add_mul, LipschitzOnWith.of_le_add_mul K⟩\n\n"}
{"name":"LipschitzOnWith.isBounded_image2","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ninst✝² : PseudoMetricSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : PseudoMetricSpace γ\nf : α → β → γ\nK₁ K₂ : NNReal\ns : Set α\nt : Set β\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\nhf₁ : ∀ (b : β), Membership.mem t b → LipschitzOnWith K₁ (fun a => f a b) s\nhf₂ : ∀ (a : α), Membership.mem s a → LipschitzOnWith K₂ (f a) t\n⊢ Bornology.IsBounded (Set.image2 f s t)","decl":"theorem isBounded_image2 (f : α → β → γ) {K₁ K₂ : ℝ≥0} {s : Set α} {t : Set β}\n    (hs : Bornology.IsBounded s) (ht : Bornology.IsBounded t)\n    (hf₁ : ∀ b ∈ t, LipschitzOnWith K₁ (fun a => f a b) s)\n    (hf₂ : ∀ a ∈ s, LipschitzOnWith K₂ (f a) t) : Bornology.IsBounded (Set.image2 f s t) :=\n  Metric.isBounded_iff_ediam_ne_top.2 <|\n    ne_top_of_le_ne_top\n      (ENNReal.add_ne_top.mpr\n        ⟨ENNReal.mul_ne_top ENNReal.coe_ne_top hs.ediam_ne_top,\n          ENNReal.mul_ne_top ENNReal.coe_ne_top ht.ediam_ne_top⟩)\n      (ediam_image2_le _ _ _ hf₁ hf₂)\n\n"}
{"name":"LipschitzOnWith.cauchySeq_comp","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nK : NNReal\ns : Set α\nf : α → β\nhf : LipschitzOnWith K f s\nu : Nat → α\nhu : CauchySeq u\nh'u : HasSubset.Subset (Set.range u) s\n⊢ CauchySeq (Function.comp f u)","decl":"lemma cauchySeq_comp (hf : LipschitzOnWith K f s)\n    {u : ℕ → α} (hu : CauchySeq u) (h'u : range u ⊆ s) :\n    CauchySeq (f ∘ u) := by\n  rcases cauchySeq_iff_le_tendsto_0.1 hu with ⟨b, b_nonneg, hb, blim⟩\n  refine cauchySeq_iff_le_tendsto_0.2 ⟨fun n ↦ K * b n, ?_, ?_, ?_⟩\n  · exact fun n ↦ mul_nonneg (by positivity) (b_nonneg n)\n  · intro n m N hn hm\n    have A n : u n ∈ s := h'u (mem_range_self _)\n    apply (hf.dist_le_mul _ (A n) _ (A m)).trans\n    exact mul_le_mul_of_nonneg_left (hb n m N hn hm) K.2\n  · rw [← mul_zero (K : ℝ)]\n    exact blim.const_mul _\n\n"}
{"name":"LocallyLipschitz.min","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf g : α → Real\nhf : LocallyLipschitz f\nhg : LocallyLipschitz g\n⊢ LocallyLipschitz fun x => Min.min (f x) (g x)","decl":"/-- The minimum of locally Lipschitz functions is locally Lipschitz. -/\nprotected lemma min (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) :\n    LocallyLipschitz (fun x => min (f x) (g x)) :=\n  lipschitzWith_min.locallyLipschitz.comp (hf.prod hg)\n\n"}
{"name":"LocallyLipschitz.max","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf g : α → Real\nhf : LocallyLipschitz f\nhg : LocallyLipschitz g\n⊢ LocallyLipschitz fun x => Max.max (f x) (g x)","decl":"/-- The maximum of locally Lipschitz functions is locally Lipschitz. -/\nprotected lemma max (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) :\n    LocallyLipschitz (fun x => max (f x) (g x)) :=\n  lipschitzWith_max.locallyLipschitz.comp (hf.prod hg)\n\n"}
{"name":"LocallyLipschitz.max_const","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nhf : LocallyLipschitz f\na : Real\n⊢ LocallyLipschitz fun x => Max.max (f x) a","decl":"theorem max_const (hf : LocallyLipschitz f) (a : ℝ) : LocallyLipschitz fun x => max (f x) a :=\n  hf.max (LocallyLipschitz.const a)\n\n"}
{"name":"LocallyLipschitz.const_max","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nhf : LocallyLipschitz f\na : Real\n⊢ LocallyLipschitz fun x => Max.max a (f x)","decl":"theorem const_max (hf : LocallyLipschitz f) (a : ℝ) : LocallyLipschitz fun x => max a (f x) := by\n  simpa [max_comm] using (hf.max_const a)\n\n"}
{"name":"LocallyLipschitz.min_const","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nhf : LocallyLipschitz f\na : Real\n⊢ LocallyLipschitz fun x => Min.min (f x) a","decl":"theorem min_const (hf : LocallyLipschitz f) (a : ℝ) : LocallyLipschitz fun x => min (f x) a :=\n  hf.min (LocallyLipschitz.const a)\n\n"}
{"name":"LocallyLipschitz.const_min","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoEMetricSpace α\nf : α → Real\nhf : LocallyLipschitz f\na : Real\n⊢ LocallyLipschitz fun x => Min.min a (f x)","decl":"theorem const_min (hf : LocallyLipschitz f) (a : ℝ) : LocallyLipschitz fun x => min a (f x) := by\n  simpa [min_comm] using (hf.min_const a)\n\n"}
{"name":"continuousAt_of_locally_lipschitz","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf : α → β\nx : α\nr : Real\nhr : LT.lt 0 r\nK : Real\nh : ∀ (y : α), LT.lt (Dist.dist y x) r → LE.le (Dist.dist (f y) (f x)) (HMul.hMul K (Dist.dist y x))\n⊢ ContinuousAt f x","decl":"/-- If a function is locally Lipschitz around a point, then it is continuous at this point. -/\ntheorem continuousAt_of_locally_lipschitz {x : α} {r : ℝ} (hr : 0 < r) (K : ℝ)\n    (h : ∀ y, dist y x < r → dist (f y) (f x) ≤ K * dist y x) : ContinuousAt f x := by\n  -- We use `h` to squeeze `dist (f y) (f x)` between `0` and `K * dist y x`\n  refine tendsto_iff_dist_tendsto_zero.2 (squeeze_zero' (Eventually.of_forall fun _ => dist_nonneg)\n    (mem_of_superset (ball_mem_nhds _ hr) h) ?_)\n  -- Then show that `K * dist y x` tends to zero as `y → x`\n  refine (continuous_const.mul (continuous_id.dist continuous_const)).tendsto' _ _ ?_\n  simp\n\n"}
{"name":"LipschitzOnWith.extend_real","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\ninst✝ : PseudoMetricSpace α\nf : α → Real\ns : Set α\nK : NNReal\nhf : LipschitzOnWith K f s\n⊢ Exists fun g => And (LipschitzWith K g) (Set.EqOn f g s)","decl":"/-- A function `f : α → ℝ` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz extension\nto the whole space. -/\ntheorem LipschitzOnWith.extend_real {f : α → ℝ} {s : Set α} {K : ℝ≥0} (hf : LipschitzOnWith K f s) :\n    ∃ g : α → ℝ, LipschitzWith K g ∧ EqOn f g s := by\n  /- An extension is given by `g y = Inf {f x + K * dist y x | x ∈ s}`. Taking `x = y`, one has\n    `g y ≤ f y` for `y ∈ s`, and the other inequality holds because `f` is `K`-Lipschitz, so that it\n    can not counterbalance the growth of `K * dist y x`. One readily checks from the formula that\n    the extended function is also `K`-Lipschitz. -/\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  · exact ⟨fun _ => 0, (LipschitzWith.const _).weaken (zero_le _), eqOn_empty _ _⟩\n  have : Nonempty s := by simp only [hs, nonempty_coe_sort]\n  let g := fun y : α => iInf fun x : s => f x + K * dist y x\n  have B : ∀ y : α, BddBelow (range fun x : s => f x + K * dist y x) := fun y => by\n    rcases hs with ⟨z, hz⟩\n    refine ⟨f z - K * dist y z, ?_⟩\n    rintro w ⟨t, rfl⟩\n    dsimp\n    rw [sub_le_iff_le_add, add_assoc, ← mul_add, add_comm (dist y t)]\n    calc\n      f z ≤ f t + K * dist z t := hf.le_add_mul hz t.2\n      _ ≤ f t + K * (dist y z + dist y t) := by gcongr; apply dist_triangle_left\n  have E : EqOn f g s := fun x hx => by\n    refine le_antisymm (le_ciInf fun y => hf.le_add_mul hx y.2) ?_\n    simpa only [add_zero, Subtype.coe_mk, mul_zero, dist_self] using ciInf_le (B x) ⟨x, hx⟩\n  refine ⟨g, LipschitzWith.of_le_add_mul K fun x y => ?_, E⟩\n  rw [← sub_le_iff_le_add]\n  refine le_ciInf fun z => ?_\n  rw [sub_le_iff_le_add]\n  calc\n    g x ≤ f z + K * dist x z := ciInf_le (B x) _\n    _ ≤ f z + K * dist y z + K * dist x y := by\n      rw [add_assoc, ← mul_add, add_comm (dist y z)]\n      gcongr\n      apply dist_triangle\n\n"}
{"name":"LipschitzOnWith.extend_pi","module":"Mathlib.Topology.MetricSpace.Lipschitz","initialProofState":"α : Type u\nι : Type x\ninst✝¹ : PseudoMetricSpace α\ninst✝ : Fintype ι\nf : α → ι → Real\ns : Set α\nK : NNReal\nhf : LipschitzOnWith K f s\n⊢ Exists fun g => And (LipschitzWith K g) (Set.EqOn f g s)","decl":"/-- A function `f : α → (ι → ℝ)` which is `K`-Lipschitz on a subset `s` admits a `K`-Lipschitz\nextension to the whole space. The same result for the space `ℓ^∞ (ι, ℝ)` over a possibly infinite\ntype `ι` is implemented in `LipschitzOnWith.extend_lp_infty`. -/\ntheorem LipschitzOnWith.extend_pi [Fintype ι] {f : α → ι → ℝ} {s : Set α}\n    {K : ℝ≥0} (hf : LipschitzOnWith K f s) : ∃ g : α → ι → ℝ, LipschitzWith K g ∧ EqOn f g s := by\n  have : ∀ i, ∃ g : α → ℝ, LipschitzWith K g ∧ EqOn (fun x => f x i) g s := fun i => by\n    have : LipschitzOnWith K (fun x : α => f x i) s :=\n      LipschitzOnWith.of_dist_le_mul fun x hx y hy =>\n        (dist_le_pi_dist _ _ i).trans (hf.dist_le_mul x hx y hy)\n    exact this.extend_real\n  choose g hg using this\n  refine ⟨fun x i => g i x, LipschitzWith.of_dist_le_mul fun x y => ?_, fun x hx ↦ ?_⟩\n  · exact (dist_pi_le_iff (mul_nonneg K.2 dist_nonneg)).2 fun i => (hg i).1.dist_le_mul x y\n  · ext1 i\n    exact (hg i).2 hx\n"}
