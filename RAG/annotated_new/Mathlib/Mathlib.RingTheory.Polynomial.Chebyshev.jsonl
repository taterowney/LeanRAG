{"name":"Polynomial.Chebyshev.T.induct","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"motive : Int → Prop\ncase1 : motive 0\ncase2 : motive 1\ncase3 : ∀ (n : Nat), motive (HAdd.hAdd (↑n) 1) → motive ↑n → motive (Int.ofNat n.succ.succ)\ncase4 : ∀ (n : Nat), motive (Neg.neg ↑n) → motive (HAdd.hAdd (Neg.neg ↑n) 1) → motive (Int.negSucc n)\na✝ : Int\n⊢ motive a✝","decl":"/-- Induction principle used for proving facts about Chebyshev polynomials. -/\n@[elab_as_elim]\nprotected theorem induct (motive : ℤ → Prop)\n    (zero : motive 0)\n    (one : motive 1)\n    (add_two : ∀ (n : ℕ), motive (↑n + 1) → motive ↑n → motive (↑n + 2))\n    (neg_add_one : ∀ (n : ℕ), motive (-↑n) → motive (-↑n + 1) → motive (-↑n - 1)) :\n    ∀ (a : ℤ), motive a :=\n  T.induct motive zero one add_two fun n hn hnm => by\n    simpa only [Int.negSucc_eq, neg_add] using neg_add_one n hn hnm\n\n"}
{"name":"Polynomial.Chebyshev.induct","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"motive : Int → Prop\nzero : motive 0\none : motive 1\nadd_two : ∀ (n : Nat), motive (HAdd.hAdd (↑n) 1) → motive ↑n → motive (HAdd.hAdd (↑n) 2)\nneg_add_one : ∀ (n : Nat), motive (Neg.neg ↑n) → motive (HAdd.hAdd (Neg.neg ↑n) 1) → motive (HSub.hSub (Neg.neg ↑n) 1)\na : Int\n⊢ motive a","decl":"/-- Induction principle used for proving facts about Chebyshev polynomials. -/\n@[elab_as_elim]\nprotected theorem induct (motive : ℤ → Prop)\n    (zero : motive 0)\n    (one : motive 1)\n    (add_two : ∀ (n : ℕ), motive (↑n + 1) → motive ↑n → motive (↑n + 2))\n    (neg_add_one : ∀ (n : ℕ), motive (-↑n) → motive (-↑n + 1) → motive (-↑n - 1)) :\n    ∀ (a : ℤ), motive a :=\n  T.induct motive zero one add_two fun n hn hnm => by\n    simpa only [Int.negSucc_eq, neg_add] using neg_add_one n hn hnm\n\n"}
{"name":"Polynomial.Chebyshev.T_add_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.T R (HAdd.hAdd n 1))) (Polynomial.Chebyshev.T R n))","decl":"@[simp]\ntheorem T_add_two : ∀ n, T R (n + 2) = 2 * X * T R (n + 1) - T R n\n  | (k : ℕ) => T.eq_3 R k\n  | -(k + 1 : ℕ) => by linear_combination (norm := (simp [Int.negSucc_eq]; ring_nf)) T.eq_4 R k\n\n"}
{"name":"Polynomial.Chebyshev.T_add_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HAdd.hAdd n 1)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.T R n)) (Polynomial.Chebyshev.T R (HSub.hSub n 1)))","decl":"theorem T_add_one (n : ℤ) : T R (n + 1) = 2 * X * T R n - T R (n - 1) := by\n  linear_combination (norm := ring_nf) T_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.T_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HSub.hSub n 2)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.T R (HSub.hSub n 1))) (Polynomial.Chebyshev.T R n))","decl":"theorem T_sub_two (n : ℤ) : T R (n - 2) = 2 * X * T R (n - 1) - T R n := by\n  linear_combination (norm := ring_nf) T_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.T_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HSub.hSub n 1)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.T R n)) (Polynomial.Chebyshev.T R (HAdd.hAdd n 1)))","decl":"theorem T_sub_one (n : ℤ) : T R (n - 1) = 2 * X * T R n - T R (n + 1) := by\n  linear_combination (norm := ring_nf) T_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.T_eq","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R n) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.T R (HSub.hSub n 1))) (Polynomial.Chebyshev.T R (HSub.hSub n 2)))","decl":"theorem T_eq (n : ℤ) : T R n = 2 * X * T R (n - 1) - T R (n - 2) := by\n  linear_combination (norm := ring_nf) T_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.T_zero","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.T R 0) 1","decl":"@[simp]\ntheorem T_zero : T R 0 = 1 := rfl\n\n"}
{"name":"Polynomial.Chebyshev.T_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.T R 1) Polynomial.X","decl":"@[simp]\ntheorem T_one : T R 1 = X := rfl\n\n"}
{"name":"Polynomial.Chebyshev.T_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.T R (-1)) Polynomial.X","decl":"theorem T_neg_one : T R (-1) = X := show 2 * X * 1 - X = X by ring\n\n"}
{"name":"Polynomial.Chebyshev.T_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.T R 2) (HSub.hSub (HMul.hMul 2 (HPow.hPow Polynomial.X 2)) 1)","decl":"theorem T_two : T R 2 = 2 * X ^ 2 - 1 := by\n  simpa [pow_two, mul_assoc] using T_add_two R 0\n\n"}
{"name":"Polynomial.Chebyshev.T_neg","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (Neg.neg n)) (Polynomial.Chebyshev.T R n)","decl":"@[simp]\ntheorem T_neg (n : ℤ) : T R (-n) = T R n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => rfl\n  | one => show 2 * X * 1 - X = X; ring\n  | add_two n ih1 ih2 =>\n    have h₁ := T_add_two R n\n    have h₂ := T_sub_two R (-n)\n    linear_combination (norm := ring_nf) (2 * (X : R[X])) * ih1 - ih2 - h₁ + h₂\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := T_add_one R n\n    have h₂ := T_sub_one R (-n)\n    linear_combination (norm := ring_nf) (2 * (X : R[X])) * ih1 - ih2 + h₁ - h₂\n\n"}
{"name":"Polynomial.Chebyshev.T_natAbs","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R ↑n.natAbs) (Polynomial.Chebyshev.T R n)","decl":"theorem T_natAbs (n : ℤ) : T R n.natAbs = T R n := by\n  obtain h | h := Int.natAbs_eq n <;> nth_rw 2 [h]; simp\n\n"}
{"name":"Polynomial.Chebyshev.T_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.T R (-2)) (HSub.hSub (HMul.hMul 2 (HPow.hPow Polynomial.X 2)) 1)","decl":"theorem T_neg_two : T R (-2) = 2 * X ^ 2 - 1 := by simp [T_two]\n\n"}
{"name":"Polynomial.Chebyshev.T_eval_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval 1 (Polynomial.Chebyshev.T R n)) 1","decl":"@[simp]\ntheorem T_eval_one (n : ℤ) : (T R n).eval 1 = 1 := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 => simp [T_add_two, ih1, ih2]; norm_num\n  | neg_add_one n ih1 ih2 => simp [T_sub_one, -T_neg, ih1, ih2]; norm_num\n\n"}
{"name":"Polynomial.Chebyshev.T_eval_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval (-1) (Polynomial.Chebyshev.T R n)) ↑↑n.negOnePow","decl":"@[simp]\ntheorem T_eval_neg_one (n : ℤ) : (T R n).eval (-1) = n.negOnePow := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp only [T_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.negOnePow_add, Int.negOnePow_one, Units.val_neg, Int.cast_neg, neg_mul, neg_neg, ih2,\n      Int.negOnePow_def 2]\n    norm_cast\n    norm_num\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [T_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1, neg_mul,\n      ih2, Int.negOnePow_add, Int.negOnePow_one, Units.val_neg, Int.cast_neg, sub_neg_eq_add,\n      Int.negOnePow_sub]\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.U_add_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.U R (HAdd.hAdd n 1))) (Polynomial.Chebyshev.U R n))","decl":"@[simp]\ntheorem U_add_two : ∀ n, U R (n + 2) = 2 * X * U R (n + 1) - U R n\n  | (k : ℕ) => U.eq_3 R k\n  | -(k + 1 : ℕ) => by linear_combination (norm := (simp [Int.negSucc_eq]; ring_nf)) U.eq_4 R k\n\n"}
{"name":"Polynomial.Chebyshev.U_add_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HAdd.hAdd n 1)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.U R n)) (Polynomial.Chebyshev.U R (HSub.hSub n 1)))","decl":"theorem U_add_one (n : ℤ) : U R (n + 1) = 2 * X * U R n - U R (n - 1) := by\n  linear_combination (norm := ring_nf) U_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.U_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HSub.hSub n 2)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.U R (HSub.hSub n 1))) (Polynomial.Chebyshev.U R n))","decl":"theorem U_sub_two (n : ℤ) : U R (n - 2) = 2 * X * U R (n - 1) - U R n := by\n  linear_combination (norm := ring_nf) U_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.U_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HSub.hSub n 1)) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.U R n)) (Polynomial.Chebyshev.U R (HAdd.hAdd n 1)))","decl":"theorem U_sub_one (n : ℤ) : U R (n - 1) = 2 * X * U R n - U R (n + 1) := by\n  linear_combination (norm := ring_nf) U_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.U_eq","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R n) (HSub.hSub (HMul.hMul (HMul.hMul 2 Polynomial.X) (Polynomial.Chebyshev.U R (HSub.hSub n 1))) (Polynomial.Chebyshev.U R (HSub.hSub n 2)))","decl":"theorem U_eq (n : ℤ) : U R n = 2 * X * U R (n - 1) - U R (n - 2) := by\n  linear_combination (norm := ring_nf) U_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.U_zero","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.U R 0) 1","decl":"@[simp]\ntheorem U_zero : U R 0 = 1 := rfl\n\n"}
{"name":"Polynomial.Chebyshev.U_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.U R 1) (HMul.hMul 2 Polynomial.X)","decl":"@[simp]\ntheorem U_one : U R 1 = 2 * X := rfl\n\n"}
{"name":"Polynomial.Chebyshev.U_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.U R (-1)) 0","decl":"@[simp]\ntheorem U_neg_one : U R (-1) = 0 := by simpa using U_sub_one R 0\n\n"}
{"name":"Polynomial.Chebyshev.U_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.U R 2) (HSub.hSub (HMul.hMul 4 (HPow.hPow Polynomial.X 2)) 1)","decl":"theorem U_two : U R 2 = 4 * X ^ 2 - 1 := by\n  have := U_add_two R 0\n  simp only [zero_add, U_one, U_zero] at this\n  linear_combination this\n\n"}
{"name":"Polynomial.Chebyshev.U_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.U R (-2)) (-1)","decl":"@[simp]\ntheorem U_neg_two : U R (-2) = -1 := by\n  simpa [zero_sub, Int.reduceNeg, U_neg_one, mul_zero, U_zero] using U_sub_two R 0\n\n"}
{"name":"Polynomial.Chebyshev.U_neg_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HSub.hSub (Neg.neg n) 1)) (Neg.neg (Polynomial.Chebyshev.U R (HSub.hSub n 1)))","decl":"theorem U_neg_sub_one (n : ℤ) : U R (-n - 1) = -U R (n - 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    have h₁ := U_add_one R n\n    have h₂ := U_sub_two R (-n - 1)\n    linear_combination (norm := ring_nf) 2 * (X : R[X]) * ih1 - ih2 + h₁ + h₂\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := U_eq R n\n    have h₂ := U_sub_two R (-n)\n    linear_combination (norm := ring_nf) 2 * (X : R[X]) * ih1 - ih2 + h₁ + h₂\n\n"}
{"name":"Polynomial.Chebyshev.U_neg","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (Neg.neg n)) (Neg.neg (Polynomial.Chebyshev.U R (HSub.hSub n 2)))","decl":"theorem U_neg (n : ℤ) : U R (-n) = -U R (n - 2) := by simpa [sub_sub] using U_neg_sub_one R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.U_neg_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HSub.hSub (Neg.neg n) 2)) (Neg.neg (Polynomial.Chebyshev.U R n))","decl":"@[simp]\ntheorem U_neg_sub_two (n : ℤ) : U R (-n - 2) = -U R n := by\n  simpa [sub_eq_add_neg, add_comm] using U_neg R (n + 2)\n\n"}
{"name":"Polynomial.Chebyshev.U_eval_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval 1 (Polynomial.Chebyshev.U R n)) (HAdd.hAdd (↑n) 1)","decl":"@[simp]\ntheorem U_eval_one (n : ℤ) : (U R n).eval 1 = n + 1 := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp; norm_num\n  | add_two n ih1 ih2 =>\n    simp only [U_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_one, ih1,\n      Int.cast_add, Int.cast_natCast, Int.cast_one, ih2, Int.cast_ofNat]\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [U_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_one,\n      ih1, Int.cast_neg, Int.cast_natCast, ih2, Int.cast_add, Int.cast_one, Int.cast_sub,\n      sub_add_cancel]\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.U_eval_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval (-1) (Polynomial.Chebyshev.U R n)) (HMul.hMul (↑↑n.negOnePow) (HAdd.hAdd (↑n) 1))","decl":"@[simp]\ntheorem U_eval_neg_one (n : ℤ) : (U R n).eval (-1) = n.negOnePow * (n + 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp; norm_num\n  | add_two n ih1 ih2 =>\n    simp only [U_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.cast_add, Int.cast_natCast, Int.cast_one, neg_mul, ih2, Int.cast_ofNat, Int.negOnePow_add,\n      Int.negOnePow_def 2]\n    norm_cast\n    norm_num\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [U_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.cast_neg, Int.cast_natCast, Int.negOnePow_neg, neg_mul, ih2, Int.cast_add, Int.cast_one,\n      Int.cast_sub, sub_add_cancel, Int.negOnePow_sub, Int.negOnePow_add]\n    norm_cast\n    norm_num\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.U_eq_X_mul_U_add_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.U R (HAdd.hAdd n 1)) (HAdd.hAdd (HMul.hMul Polynomial.X (Polynomial.Chebyshev.U R n)) (Polynomial.Chebyshev.T R (HAdd.hAdd n 1)))","decl":"theorem U_eq_X_mul_U_add_T (n : ℤ) : U R (n + 1) = X * U R n + T R (n + 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp [two_mul]\n  | one => simp [U_two, T_two]; ring\n  | add_two n ih1 ih2 =>\n    have h₁ := U_add_two R (n + 1)\n    have h₂ := U_add_two R n\n    have h₃ := T_add_two R (n + 1)\n    linear_combination (norm := ring_nf) -h₃ - (X : R[X]) * h₂ + h₁ + 2 * (X : R[X]) * ih1 - ih2\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := U_add_two R (-n - 1)\n    have h₂ := U_add_two R (-n)\n    have h₃ := T_add_two R (-n)\n    linear_combination (norm := ring_nf) -h₃ + h₂ - (X : R[X]) * h₁ - ih2 + 2 * (X : R[X]) * ih1\n\n"}
{"name":"Polynomial.Chebyshev.T_eq_U_sub_X_mul_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R n) (HSub.hSub (Polynomial.Chebyshev.U R n) (HMul.hMul Polynomial.X (Polynomial.Chebyshev.U R (HSub.hSub n 1))))","decl":"theorem T_eq_U_sub_X_mul_U (n : ℤ) : T R n = U R n - X * U R (n - 1) := by\n  linear_combination (norm := ring_nf) - U_eq_X_mul_U_add_T R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.T_eq_X_mul_T_sub_pol_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.T R (HAdd.hAdd n 1))) (HMul.hMul (HSub.hSub 1 (HPow.hPow Polynomial.X 2)) (Polynomial.Chebyshev.U R n)))","decl":"theorem T_eq_X_mul_T_sub_pol_U (n : ℤ) : T R (n + 2) = X * T R (n + 1) - (1 - X ^ 2) * U R n := by\n  have h₁ := U_eq_X_mul_U_add_T R n\n  have h₂ := U_eq_X_mul_U_add_T R (n + 1)\n  have h₃ := U_add_two R n\n  linear_combination (norm := ring_nf) h₃ - h₂ + (X : R[X]) * h₁\n\n"}
{"name":"Polynomial.Chebyshev.one_sub_X_sq_mul_U_eq_pol_in_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HMul.hMul (HSub.hSub 1 (HPow.hPow Polynomial.X 2)) (Polynomial.Chebyshev.U R n)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.T R (HAdd.hAdd n 1))) (Polynomial.Chebyshev.T R (HAdd.hAdd n 2)))","decl":"theorem one_sub_X_sq_mul_U_eq_pol_in_T (n : ℤ) :\n    (1 - X ^ 2) * U R n = X * T R (n + 1) - T R (n + 2) := by\n  linear_combination T_eq_X_mul_T_sub_pol_U R n\n\n"}
{"name":"Polynomial.Chebyshev.C_add_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.C R (HAdd.hAdd n 1))) (Polynomial.Chebyshev.C R n))","decl":"@[simp]\ntheorem C_add_two : ∀ n, C R (n + 2) = X * C R (n + 1) - C R n\n  | (k : ℕ) => C.eq_3 R k\n  | -(k + 1 : ℕ) => by linear_combination (norm := (simp [Int.negSucc_eq]; ring_nf)) C.eq_4 R k\n\n"}
{"name":"Polynomial.Chebyshev.C_add_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R (HAdd.hAdd n 1)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.C R n)) (Polynomial.Chebyshev.C R (HSub.hSub n 1)))","decl":"theorem C_add_one (n : ℤ) : C R (n + 1) = X * C R n - C R (n - 1) := by\n  linear_combination (norm := ring_nf) C_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.C_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R (HSub.hSub n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.C R (HSub.hSub n 1))) (Polynomial.Chebyshev.C R n))","decl":"theorem C_sub_two (n : ℤ) : C R (n - 2) = X * C R (n - 1) - C R n := by\n  linear_combination (norm := ring_nf) C_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.C_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R (HSub.hSub n 1)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.C R n)) (Polynomial.Chebyshev.C R (HAdd.hAdd n 1)))","decl":"theorem C_sub_one (n : ℤ) : C R (n - 1) = X * C R n - C R (n + 1) := by\n  linear_combination (norm := ring_nf) C_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.C_eq","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R n) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.C R (HSub.hSub n 1))) (Polynomial.Chebyshev.C R (HSub.hSub n 2)))","decl":"theorem C_eq (n : ℤ) : C R n = X * C R (n - 1) - C R (n - 2) := by\n  linear_combination (norm := ring_nf) C_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.C_zero","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.C R 0) 2","decl":"@[simp]\ntheorem C_zero : C R 0 = 2 := rfl\n\n"}
{"name":"Polynomial.Chebyshev.C_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.C R 1) Polynomial.X","decl":"@[simp]\ntheorem C_one : C R 1 = X := rfl\n\n"}
{"name":"Polynomial.Chebyshev.C_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.C R (-1)) Polynomial.X","decl":"theorem C_neg_one : C R (-1) = X := show X * 2 - X = X by ring\n\n"}
{"name":"Polynomial.Chebyshev.C_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.C R 2) (HSub.hSub (HPow.hPow Polynomial.X 2) 2)","decl":"theorem C_two : C R 2 = X ^ 2 - 2 := by\n  simpa [pow_two, mul_assoc] using C_add_two R 0\n\n"}
{"name":"Polynomial.Chebyshev.C_neg","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R (Neg.neg n)) (Polynomial.Chebyshev.C R n)","decl":"@[simp]\ntheorem C_neg (n : ℤ) : C R (-n) = C R n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => rfl\n  | one => show X * 2 - X = X; ring\n  | add_two n ih1 ih2 =>\n    have h₁ := C_add_two R n\n    have h₂ := C_sub_two R (-n)\n    linear_combination (norm := ring_nf) (X:R[X]) * ih1 - ih2 - h₁ + h₂\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := C_add_one R n\n    have h₂ := C_sub_one R (-n)\n    linear_combination (norm := ring_nf) (X:R[X]) * ih1 - ih2 + h₁ - h₂\n\n"}
{"name":"Polynomial.Chebyshev.C_natAbs","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R ↑n.natAbs) (Polynomial.Chebyshev.C R n)","decl":"theorem C_natAbs (n : ℤ) : C R n.natAbs = C R n := by\n  obtain h | h := Int.natAbs_eq n <;> nth_rw 2 [h]; simp\n\n"}
{"name":"Polynomial.Chebyshev.C_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.C R (-2)) (HSub.hSub (HPow.hPow Polynomial.X 2) 2)","decl":"theorem C_neg_two : C R (-2) = X ^ 2 - 2 := by simp [C_two]\n\n"}
{"name":"Polynomial.Chebyshev.C_comp_two_mul_X","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq ((Polynomial.Chebyshev.C R n).comp (HMul.hMul 2 Polynomial.X)) (HMul.hMul 2 (Polynomial.Chebyshev.T R n))","decl":"theorem C_comp_two_mul_X (n : ℤ) : (C R n).comp (2 * X) = 2 * T R n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp_rw [C_add_two, T_add_two, sub_comp, mul_comp, X_comp, ih1, ih2]\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp_rw [C_sub_one, T_sub_one, sub_comp, mul_comp, X_comp, ih1, ih2]\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.C_eval_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval 2 (Polynomial.Chebyshev.C R n)) 2","decl":"@[simp]\ntheorem C_eval_two (n : ℤ) : (C R n).eval 2 = 2 := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 => simp [C_add_two, ih1, ih2]; norm_num\n  | neg_add_one n ih1 ih2 => simp [C_sub_one, -C_neg, ih1, ih2]; norm_num\n\n"}
{"name":"Polynomial.Chebyshev.C_eval_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval (-2) (Polynomial.Chebyshev.C R n)) (HMul.hMul 2 ↑↑n.negOnePow)","decl":"@[simp]\ntheorem C_eval_neg_two (n : ℤ) : (C R n).eval (-2) = 2 * n.negOnePow := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp only [C_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.negOnePow_add, Int.negOnePow_one, Units.val_neg, Int.cast_neg, neg_mul, neg_neg, ih2,\n      Int.negOnePow_def 2]\n    norm_cast\n    norm_num\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [C_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1, neg_mul,\n      ih2, Int.negOnePow_add, Int.negOnePow_one, Units.val_neg, Int.cast_neg, sub_neg_eq_add,\n      Int.negOnePow_sub]\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.C_eq_two_mul_T_comp_half_mul_X","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R n) (HMul.hMul 2 ((Polynomial.Chebyshev.T R n).comp (HMul.hMul (Polynomial.C (Invertible.invOf 2)) Polynomial.X)))","decl":"theorem C_eq_two_mul_T_comp_half_mul_X [Invertible (2 : R)] (n : ℤ) :\n    C R n = 2 * (T R n).comp (Polynomial.C ⅟2 * X) := by\n  have := congr_arg (·.comp (Polynomial.C ⅟2 * X)) (C_comp_two_mul_X R n)\n  simp_rw [comp_assoc, mul_comp, ofNat_comp, X_comp, ← mul_assoc, ← C_eq_natCast, ← C_mul,\n    Nat.cast_ofNat, mul_invOf_self', map_one, one_mul, comp_X, map_ofNat] at this\n  assumption\n\n"}
{"name":"Polynomial.Chebyshev.T_eq_half_mul_C_comp_two_mul_X","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Int\n⊢ Eq (Polynomial.Chebyshev.T R n) (HMul.hMul (Polynomial.C (Invertible.invOf 2)) ((Polynomial.Chebyshev.C R n).comp (HMul.hMul 2 Polynomial.X)))","decl":"theorem T_eq_half_mul_C_comp_two_mul_X [Invertible (2 : R)] (n : ℤ) :\n    T R n = Polynomial.C ⅟2 * (C R n).comp (2 * X) := by\n  rw [C_comp_two_mul_X, ← mul_assoc, ← map_ofNat Polynomial.C 2, ← map_mul, invOf_mul_self',\n    map_one, one_mul]\n\n"}
{"name":"Polynomial.Chebyshev.S_add_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R (HAdd.hAdd n 1))) (Polynomial.Chebyshev.S R n))","decl":"@[simp]\ntheorem S_add_two : ∀ n, S R (n + 2) = X * S R (n + 1) - S R n\n  | (k : ℕ) => S.eq_3 R k\n  | -(k + 1 : ℕ) => by linear_combination (norm := (simp [Int.negSucc_eq]; ring_nf)) S.eq_4 R k\n\n"}
{"name":"Polynomial.Chebyshev.S_add_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HAdd.hAdd n 1)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R n)) (Polynomial.Chebyshev.S R (HSub.hSub n 1)))","decl":"theorem S_add_one (n : ℤ) : S R (n + 1) = X * S R n - S R (n - 1) := by\n  linear_combination (norm := ring_nf) S_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.S_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HSub.hSub n 2)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R (HSub.hSub n 1))) (Polynomial.Chebyshev.S R n))","decl":"theorem S_sub_two (n : ℤ) : S R (n - 2) = X * S R (n - 1) - S R n := by\n  linear_combination (norm := ring_nf) S_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.S_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HSub.hSub n 1)) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R n)) (Polynomial.Chebyshev.S R (HAdd.hAdd n 1)))","decl":"theorem S_sub_one (n : ℤ) : S R (n - 1) = X * S R n - S R (n + 1) := by\n  linear_combination (norm := ring_nf) S_add_two R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.S_eq","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R n) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R (HSub.hSub n 1))) (Polynomial.Chebyshev.S R (HSub.hSub n 2)))","decl":"theorem S_eq (n : ℤ) : S R n = X * S R (n - 1) - S R (n - 2) := by\n  linear_combination (norm := ring_nf) S_add_two R (n - 2)\n\n"}
{"name":"Polynomial.Chebyshev.S_zero","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.S R 0) 1","decl":"@[simp]\ntheorem S_zero : S R 0 = 1 := rfl\n\n"}
{"name":"Polynomial.Chebyshev.S_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.S R 1) Polynomial.X","decl":"@[simp]\ntheorem S_one : S R 1 = X := rfl\n\n"}
{"name":"Polynomial.Chebyshev.S_neg_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.S R (-1)) 0","decl":"@[simp]\ntheorem S_neg_one : S R (-1) = 0 := by simpa using S_sub_one R 0\n\n"}
{"name":"Polynomial.Chebyshev.S_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.S R 2) (HSub.hSub (HPow.hPow Polynomial.X 2) 1)","decl":"theorem S_two : S R 2 = X ^ 2 - 1 := by\n  have := S_add_two R 0\n  simp only [zero_add, S_one, S_zero] at this\n  linear_combination this\n\n"}
{"name":"Polynomial.Chebyshev.S_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Eq (Polynomial.Chebyshev.S R (-2)) (-1)","decl":"@[simp]\ntheorem S_neg_two : S R (-2) = -1 := by\n  simpa [zero_sub, Int.reduceNeg, S_neg_one, mul_zero, S_zero] using S_sub_two R 0\n\n"}
{"name":"Polynomial.Chebyshev.S_neg_sub_one","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HSub.hSub (Neg.neg n) 1)) (Neg.neg (Polynomial.Chebyshev.S R (HSub.hSub n 1)))","decl":"theorem S_neg_sub_one (n : ℤ) : S R (-n - 1) = -S R (n - 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    have h₁ := S_add_one R n\n    have h₂ := S_sub_two R (-n - 1)\n    linear_combination (norm := ring_nf) (X:R[X]) * ih1 - ih2 + h₁ + h₂\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := S_eq R n\n    have h₂ := S_sub_two R (-n)\n    linear_combination (norm := ring_nf) (X:R[X]) * ih1 - ih2 + h₁ + h₂\n\n"}
{"name":"Polynomial.Chebyshev.S_neg","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (Neg.neg n)) (Neg.neg (Polynomial.Chebyshev.S R (HSub.hSub n 2)))","decl":"theorem S_neg (n : ℤ) : S R (-n) = -S R (n - 2) := by simpa [sub_sub] using S_neg_sub_one R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.S_neg_sub_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R (HSub.hSub (Neg.neg n) 2)) (Neg.neg (Polynomial.Chebyshev.S R n))","decl":"@[simp]\ntheorem S_neg_sub_two (n : ℤ) : S R (-n - 2) = -S R n := by\n  simpa [sub_eq_add_neg, add_comm] using S_neg R (n + 2)\n\n  "}
{"name":"Polynomial.Chebyshev.S_eval_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval 2 (Polynomial.Chebyshev.S R n)) (HAdd.hAdd (↑n) 1)","decl":"@[simp]\ntheorem S_eval_two (n : ℤ) : (S R n).eval 2 = n + 1 := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp; norm_num\n  | add_two n ih1 ih2 =>\n    simp only [S_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_one, ih1,\n      Int.cast_add, Int.cast_natCast, Int.cast_one, ih2, Int.cast_ofNat]\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [S_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_one,\n      ih1, Int.cast_neg, Int.cast_natCast, ih2, Int.cast_add, Int.cast_one, Int.cast_sub,\n      sub_add_cancel]\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.S_eval_neg_two","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.eval (-2) (Polynomial.Chebyshev.S R n)) (HMul.hMul (↑↑n.negOnePow) (HAdd.hAdd (↑n) 1))","decl":"@[simp]\ntheorem S_eval_neg_two (n : ℤ) : (S R n).eval (-2) = n.negOnePow * (n + 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp; norm_num\n  | add_two n ih1 ih2 =>\n    simp only [S_add_two, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.cast_add, Int.cast_natCast, Int.cast_one, neg_mul, ih2, Int.cast_ofNat, Int.negOnePow_add,\n      Int.negOnePow_def 2]\n    norm_cast\n    norm_num\n    ring\n  | neg_add_one n ih1 ih2 =>\n    simp only [S_sub_one, eval_sub, eval_mul, eval_ofNat, eval_X, mul_neg, mul_one, ih1,\n      Int.cast_neg, Int.cast_natCast, Int.negOnePow_neg, neg_mul, ih2, Int.cast_add, Int.cast_one,\n      Int.cast_sub, sub_add_cancel, Int.negOnePow_sub, Int.negOnePow_add]\n    norm_cast\n    norm_num\n    ring\n\n"}
{"name":"Polynomial.Chebyshev.S_comp_two_mul_X","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq ((Polynomial.Chebyshev.S R n).comp (HMul.hMul 2 Polynomial.X)) (Polynomial.Chebyshev.U R n)","decl":"theorem S_comp_two_mul_X (n : ℤ) : (S R n).comp (2 * X) = U R n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 => simp_rw [U_add_two, S_add_two, sub_comp, mul_comp, X_comp, ih1, ih2]\n  | neg_add_one n ih1 ih2 => simp_rw [U_sub_one, S_sub_one, sub_comp, mul_comp, X_comp, ih1, ih2]\n\n"}
{"name":"Polynomial.Chebyshev.S_sq_add_S_sq","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HSub.hSub (HAdd.hAdd (HPow.hPow (Polynomial.Chebyshev.S R n) 2) (HPow.hPow (Polynomial.Chebyshev.S R (HAdd.hAdd n 1)) 2)) (HMul.hMul (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R n)) (Polynomial.Chebyshev.S R (HAdd.hAdd n 1)))) 1","decl":"theorem S_sq_add_S_sq (n : ℤ) : S R n ^ 2 + S R (n + 1) ^ 2 - X * S R n * S R (n + 1) = 1 := by\n  induction n using Int.induction_on with\n  | hz => simp; ring\n  | hp n ih =>\n    have h₁ := S_add_two R n\n    linear_combination (norm := ring_nf) (S R (2 + n) - S R n) * h₁ + ih\n  | hn n ih =>\n    have h₁ := S_sub_one R (-n)\n    linear_combination (norm := ring_nf) (S R (-1 - n) - S R (1 - n)) * h₁ + ih\n\n"}
{"name":"Polynomial.Chebyshev.S_eq_U_comp_half_mul_X","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Invertible 2\nn : Int\n⊢ Eq (Polynomial.Chebyshev.S R n) ((Polynomial.Chebyshev.U R n).comp (HMul.hMul (Polynomial.C (Invertible.invOf 2)) Polynomial.X))","decl":"theorem S_eq_U_comp_half_mul_X [Invertible (2 : R)] (n : ℤ) :\n    S R n = (U R n).comp (Polynomial.C ⅟2 * X) := by\n  have := congr_arg (·.comp (Polynomial.C ⅟2 * X)) (S_comp_two_mul_X R n)\n  simp_rw [comp_assoc, mul_comp, ofNat_comp, X_comp, ← mul_assoc, ← C_eq_natCast, ← C_mul,\n    Nat.cast_ofNat, mul_invOf_self', map_one, one_mul, comp_X] at this\n  assumption\n\n"}
{"name":"Polynomial.Chebyshev.S_eq_X_mul_S_add_C","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HMul.hMul 2 (Polynomial.Chebyshev.S R (HAdd.hAdd n 1))) (HAdd.hAdd (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R n)) (Polynomial.Chebyshev.C R (HAdd.hAdd n 1)))","decl":"theorem S_eq_X_mul_S_add_C (n : ℤ) : 2 * S R (n + 1) = X * S R n + C R (n + 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp [two_mul]\n  | one => simp [S_two, C_two]; ring\n  | add_two n ih1 ih2 =>\n    have h₁ := S_add_two R (n + 1)\n    have h₂ := S_add_two R n\n    have h₃ := C_add_two R (n + 1)\n    linear_combination (norm := ring_nf) -h₃ - (X:R[X]) * h₂ + 2 * h₁ + (X:R[X]) * ih1 - ih2\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := S_add_two R (-n - 1)\n    have h₂ := S_add_two R (-n)\n    have h₃ := C_add_two R (-n)\n    linear_combination (norm := ring_nf) -h₃ + 2 * h₂ - (X:R[X]) * h₁ - ih2 + (X:R[X]) * ih1\n\n"}
{"name":"Polynomial.Chebyshev.C_eq_S_sub_X_mul_S","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.Chebyshev.C R n) (HSub.hSub (HMul.hMul 2 (Polynomial.Chebyshev.S R n)) (HMul.hMul Polynomial.X (Polynomial.Chebyshev.S R (HSub.hSub n 1))))","decl":"theorem C_eq_S_sub_X_mul_S (n : ℤ) : C R n = 2 * S R n - X * S R (n - 1) := by\n  linear_combination (norm := ring_nf) - S_eq_X_mul_S_add_C R (n - 1)\n\n"}
{"name":"Polynomial.Chebyshev.map_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing R'\nf : RingHom R R'\nn : Int\n⊢ Eq (Polynomial.map f (Polynomial.Chebyshev.T R n)) (Polynomial.Chebyshev.T R' n)","decl":"@[simp]\ntheorem map_T (f : R →+* R') (n : ℤ) : map f (T R n) = T R' n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp_rw [T_add_two, Polynomial.map_sub, Polynomial.map_mul, Polynomial.map_ofNat, map_X,\n      ih1, ih2]\n  | neg_add_one n ih1 ih2 =>\n    simp_rw [T_sub_one, Polynomial.map_sub, Polynomial.map_mul, Polynomial.map_ofNat, map_X, ih1,\n      ih2]\n\n"}
{"name":"Polynomial.Chebyshev.map_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing R'\nf : RingHom R R'\nn : Int\n⊢ Eq (Polynomial.map f (Polynomial.Chebyshev.U R n)) (Polynomial.Chebyshev.U R' n)","decl":"@[simp]\ntheorem map_U (f : R →+* R') (n : ℤ) : map f (U R n) = U R' n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp_rw [U_add_two, Polynomial.map_sub, Polynomial.map_mul, Polynomial.map_ofNat, map_X, ih1,\n      ih2]\n  | neg_add_one n ih1 ih2 =>\n    simp_rw [U_sub_one, Polynomial.map_sub, Polynomial.map_mul, Polynomial.map_ofNat, map_X, ih1,\n      ih2]\n\n"}
{"name":"Polynomial.Chebyshev.map_C","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing R'\nf : RingHom R R'\nn : Int\n⊢ Eq (Polynomial.map f (Polynomial.Chebyshev.C R n)) (Polynomial.Chebyshev.C R' n)","decl":"@[simp]\ntheorem map_C (f : R →+* R') (n : ℤ) : map f (C R n) = C R' n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp_rw [C_add_two, Polynomial.map_sub, Polynomial.map_mul, map_X, ih1, ih2]\n  | neg_add_one n ih1 ih2 =>\n    simp_rw [C_sub_one, Polynomial.map_sub, Polynomial.map_mul, map_X, ih1, ih2]\n\n"}
{"name":"Polynomial.Chebyshev.map_S","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing R'\nf : RingHom R R'\nn : Int\n⊢ Eq (Polynomial.map f (Polynomial.Chebyshev.S R n)) (Polynomial.Chebyshev.S R' n)","decl":"@[simp]\ntheorem map_S (f : R →+* R') (n : ℤ) : map f (S R n) = S R' n := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two n ih1 ih2 =>\n    simp_rw [S_add_two, Polynomial.map_sub, Polynomial.map_mul, map_X, ih1, ih2]\n  | neg_add_one n ih1 ih2 =>\n    simp_rw [S_sub_one, Polynomial.map_sub, Polynomial.map_mul, map_X, ih1, ih2]\n\n"}
{"name":"Polynomial.Chebyshev.aeval_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R'\nn : Int\n⊢ Eq ((Polynomial.aeval x) (Polynomial.Chebyshev.T R n)) (Polynomial.eval x (Polynomial.Chebyshev.T R' n))","decl":"@[simp]\ntheorem aeval_T [Algebra R R'] (x : R') (n : ℤ) : aeval x (T R n) = (T R' n).eval x := by\n  rw [aeval_def, eval₂_eq_eval_map, map_T]\n\n"}
{"name":"Polynomial.Chebyshev.aeval_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R'\nn : Int\n⊢ Eq ((Polynomial.aeval x) (Polynomial.Chebyshev.U R n)) (Polynomial.eval x (Polynomial.Chebyshev.U R' n))","decl":"@[simp]\ntheorem aeval_U [Algebra R R'] (x : R') (n : ℤ) : aeval x (U R n) = (U R' n).eval x := by\n  rw [aeval_def, eval₂_eq_eval_map, map_U]\n\n"}
{"name":"Polynomial.Chebyshev.aeval_C","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R'\nn : Int\n⊢ Eq ((Polynomial.aeval x) (Polynomial.Chebyshev.C R n)) (Polynomial.eval x (Polynomial.Chebyshev.C R' n))","decl":"@[simp]\ntheorem aeval_C [Algebra R R'] (x : R') (n : ℤ) : aeval x (C R n) = (C R' n).eval x := by\n  rw [aeval_def, eval₂_eq_eval_map, map_C]\n\n"}
{"name":"Polynomial.Chebyshev.aeval_S","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R'\nn : Int\n⊢ Eq ((Polynomial.aeval x) (Polynomial.Chebyshev.S R n)) (Polynomial.eval x (Polynomial.Chebyshev.S R' n))","decl":"@[simp]\ntheorem aeval_S [Algebra R R'] (x : R') (n : ℤ) : aeval x (S R n) = (S R' n).eval x := by\n  rw [aeval_def, eval₂_eq_eval_map, map_S]\n\n"}
{"name":"Polynomial.Chebyshev.algebraMap_eval_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R\nn : Int\n⊢ Eq ((algebraMap R R') (Polynomial.eval x (Polynomial.Chebyshev.T R n))) (Polynomial.eval ((algebraMap R R') x) (Polynomial.Chebyshev.T R' n))","decl":"@[simp]\ntheorem algebraMap_eval_T [Algebra R R'] (x : R) (n : ℤ) :\n    algebraMap R R' ((T R n).eval x) = (T R' n).eval (algebraMap R R' x) := by\n  rw [← aeval_algebraMap_apply_eq_algebraMap_eval, aeval_T]\n\n"}
{"name":"Polynomial.Chebyshev.algebraMap_eval_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R\nn : Int\n⊢ Eq ((algebraMap R R') (Polynomial.eval x (Polynomial.Chebyshev.U R n))) (Polynomial.eval ((algebraMap R R') x) (Polynomial.Chebyshev.U R' n))","decl":"@[simp]\ntheorem algebraMap_eval_U [Algebra R R'] (x : R) (n : ℤ) :\n    algebraMap R R' ((U R n).eval x) = (U R' n).eval (algebraMap R R' x) := by\n  rw [← aeval_algebraMap_apply_eq_algebraMap_eval, aeval_U]\n\n"}
{"name":"Polynomial.Chebyshev.algebraMap_eval_C","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R\nn : Int\n⊢ Eq ((algebraMap R R') (Polynomial.eval x (Polynomial.Chebyshev.C R n))) (Polynomial.eval ((algebraMap R R') x) (Polynomial.Chebyshev.C R' n))","decl":"@[simp]\ntheorem algebraMap_eval_C [Algebra R R'] (x : R) (n : ℤ) :\n    algebraMap R R' ((C R n).eval x) = (C R' n).eval (algebraMap R R' x) := by\n  rw [← aeval_algebraMap_apply_eq_algebraMap_eval, aeval_C]\n\n"}
{"name":"Polynomial.Chebyshev.algebraMap_eval_S","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\nR' : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing R'\ninst✝ : Algebra R R'\nx : R\nn : Int\n⊢ Eq ((algebraMap R R') (Polynomial.eval x (Polynomial.Chebyshev.S R n))) (Polynomial.eval ((algebraMap R R') x) (Polynomial.Chebyshev.S R' n))","decl":"@[simp]\ntheorem algebraMap_eval_S [Algebra R R'] (x : R) (n : ℤ) :\n    algebraMap R R' ((S R n).eval x) = (S R' n).eval (algebraMap R R' x) := by\n  rw [← aeval_algebraMap_apply_eq_algebraMap_eval, aeval_S]\n\n"}
{"name":"Polynomial.Chebyshev.T_derivative_eq_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (Polynomial.derivative (Polynomial.Chebyshev.T R n)) (HMul.hMul (↑n) (Polynomial.Chebyshev.U R (HSub.hSub n 1)))","decl":"theorem T_derivative_eq_U (n : ℤ) : derivative (T R n) = n * U R (n - 1) := by\n  induction n using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one =>\n    simp [T_two, U_one, derivative_sub, derivative_one, derivative_mul, derivative_X_pow, add_mul]\n  | add_two n ih1 ih2 =>\n    have h₁ := congr_arg derivative (T_add_two R n)\n    have h₂ := U_sub_one R n\n    have h₃ := T_eq_U_sub_X_mul_U R (n + 1)\n    simp only [derivative_sub, derivative_mul, derivative_ofNat, derivative_X] at h₁\n    linear_combination (norm := (push_cast; ring_nf))\n      h₁ - ih2 + 2 * (X : R[X]) * ih1 + 2 * h₃ - n * h₂\n  | neg_add_one n ih1 ih2 =>\n    have h₁ := congr_arg derivative (T_sub_one R (-n))\n    have h₂ := U_sub_two R (-n)\n    have h₃ := T_eq_U_sub_X_mul_U R (-n)\n    simp only [derivative_sub, derivative_mul, derivative_ofNat, derivative_X] at h₁\n    linear_combination (norm := (push_cast; ring_nf))\n      -ih2 + 2 * (X : R[X]) * ih1 + h₁ + 2 * h₃ + (n + 1) * h₂\n\n"}
{"name":"Polynomial.Chebyshev.one_sub_X_sq_mul_derivative_T_eq_poly_in_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HMul.hMul (HSub.hSub 1 (HPow.hPow Polynomial.X 2)) (Polynomial.derivative (Polynomial.Chebyshev.T R (HAdd.hAdd n 1)))) (HMul.hMul (HAdd.hAdd (↑n) 1) (HSub.hSub (Polynomial.Chebyshev.T R n) (HMul.hMul Polynomial.X (Polynomial.Chebyshev.T R (HAdd.hAdd n 1)))))","decl":"theorem one_sub_X_sq_mul_derivative_T_eq_poly_in_T (n : ℤ) :\n    (1 - X ^ 2) * derivative (T R (n + 1)) = (n + 1 : R[X]) * (T R n - X * T R (n + 1)) := by\n  have H₁ := one_sub_X_sq_mul_U_eq_pol_in_T R n\n  have H₂ := T_derivative_eq_U (R := R) (n + 1)\n  have h₁ := T_add_two R n\n  linear_combination (norm := (push_cast; ring_nf))\n    (-n - 1) * h₁ + (-(X : R[X]) ^ 2 + 1) * H₂ + (n + 1) * H₁\n\n"}
{"name":"Polynomial.Chebyshev.add_one_mul_T_eq_poly_in_U","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HMul.hMul (HAdd.hAdd (↑n) 1) (Polynomial.Chebyshev.T R (HAdd.hAdd n 1))) (HSub.hSub (HMul.hMul Polynomial.X (Polynomial.Chebyshev.U R n)) (HMul.hMul (HSub.hSub 1 (HPow.hPow Polynomial.X 2)) (Polynomial.derivative (Polynomial.Chebyshev.U R n))))","decl":"theorem add_one_mul_T_eq_poly_in_U (n : ℤ) :\n    ((n : R[X]) + 1) * T R (n + 1) = X * U R n - (1 - X ^ 2) * derivative (U R n) := by\n  have h₁ := congr_arg derivative <| T_eq_X_mul_T_sub_pol_U R n\n  simp only [derivative_sub, derivative_mul, derivative_X, derivative_one, derivative_X_pow,\n    T_derivative_eq_U, C_eq_natCast] at h₁\n  have h₂ := T_eq_U_sub_X_mul_U R (n + 1)\n  linear_combination (norm := (push_cast; ring_nf))\n    h₁ + (n + 2) * h₂\n\n"}
{"name":"Polynomial.Chebyshev.T_mul_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm k : Int\n⊢ Eq (HMul.hMul (HMul.hMul 2 (Polynomial.Chebyshev.T R m)) (Polynomial.Chebyshev.T R k)) (HAdd.hAdd (Polynomial.Chebyshev.T R (HAdd.hAdd m k)) (Polynomial.Chebyshev.T R (HSub.hSub m k)))","decl":"/-- Twice the product of two Chebyshev `T` polynomials is the sum of two other Chebyshev `T`\npolynomials. -/\ntheorem T_mul_T (m k : ℤ) : 2 * T R m * T R k = T R (m + k) + T R (m - k) := by\n  induction k using Polynomial.Chebyshev.induct with\n  | zero => simp [two_mul]\n  | one => rw [T_add_one, T_one]; ring\n  | add_two k ih1 ih2 =>\n    have h₁ := T_add_two R (m + k)\n    have h₂ := T_sub_two R (m - k)\n    have h₃ := T_add_two R k\n    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X : R[X]) * ih1\n  | neg_add_one k ih1 ih2 =>\n    have h₁ := T_add_two R (m + (-k - 1))\n    have h₂ := T_sub_two R (m - (-k - 1))\n    have h₃ := T_add_two R (-k - 1)\n    linear_combination (norm := ring_nf) 2 * T R m * h₃ - h₂ - h₁ - ih2 + 2 * (X : R[X]) * ih1\n\n"}
{"name":"Polynomial.Chebyshev.mul_T","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm k : Int\n⊢ Eq (HMul.hMul (HMul.hMul 2 (Polynomial.Chebyshev.T R m)) (Polynomial.Chebyshev.T R k)) (HAdd.hAdd (Polynomial.Chebyshev.T R (HAdd.hAdd m k)) (Polynomial.Chebyshev.T R (HSub.hSub m k)))","decl":"@[deprecated (since := \"2024-12-03\")] alias mul_T := T_mul_T\n\n"}
{"name":"Polynomial.Chebyshev.C_mul_C","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm k : Int\n⊢ Eq (HMul.hMul (Polynomial.Chebyshev.C R m) (Polynomial.Chebyshev.C R k)) (HAdd.hAdd (Polynomial.Chebyshev.C R (HAdd.hAdd m k)) (Polynomial.Chebyshev.C R (HSub.hSub m k)))","decl":"/-- The product of two Chebyshev `C` polynomials is the sum of two other Chebyshev `C` polynomials.\n-/\ntheorem C_mul_C (m k : ℤ) : C R m * C R k = C R (m + k) + C R (m - k) := by\n  induction k using Polynomial.Chebyshev.induct with\n  | zero => simp [mul_two]\n  | one => rw [C_add_one, C_one]; ring\n  | add_two k ih1 ih2 =>\n    have h₁ := C_add_two R (m + k)\n    have h₂ := C_sub_two R (m - k)\n    have h₃ := C_add_two R k\n    linear_combination (norm := ring_nf) C R m * h₃ - h₂ - h₁ - ih2 + (X:R[X]) * ih1\n  | neg_add_one k ih1 ih2 =>\n    have h₁ := C_add_two R (m + (-k - 1))\n    have h₂ := C_sub_two R (m - (-k - 1))\n    have h₃ := C_add_two R (-k - 1)\n    linear_combination (norm := ring_nf) C R m * h₃ - h₂ - h₁ - ih2 + (X:R[X]) * ih1\n\n"}
{"name":"Polynomial.Chebyshev.T_mul","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm n : Int\n⊢ Eq (Polynomial.Chebyshev.T R (HMul.hMul m n)) ((Polynomial.Chebyshev.T R m).comp (Polynomial.Chebyshev.T R n))","decl":"/-- The `(m * n)`-th Chebyshev `T` polynomial is the composition of the `m`-th and `n`-th. -/\ntheorem T_mul (m n : ℤ) : T R (m * n) = (T R m).comp (T R n) := by\n  induction m using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two m ih1 ih2 =>\n    have h₁ := T_mul_T R ((m + 1) * n) n\n    have h₂ := congr_arg (comp · (T R n)) <| T_add_two R m\n    simp only [sub_comp, mul_comp, ofNat_comp, X_comp] at h₂\n    linear_combination (norm := ring_nf) -ih2 - h₂ - h₁ + 2 * T R n * ih1\n  | neg_add_one m ih1 ih2 =>\n    have h₁ := T_mul_T R ((-m) * n) n\n    have h₂ := congr_arg (comp · (T R n)) <| T_add_two R (-m - 1)\n    simp only [sub_comp, mul_comp, ofNat_comp, X_comp] at h₂\n    linear_combination (norm := ring_nf) -ih2 - h₂ - h₁ + 2 * T R n * ih1\n\n"}
{"name":"Polynomial.Chebyshev.C_mul","module":"Mathlib.RingTheory.Polynomial.Chebyshev","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nm n : Int\n⊢ Eq (Polynomial.Chebyshev.C R (HMul.hMul m n)) ((Polynomial.Chebyshev.C R m).comp (Polynomial.Chebyshev.C R n))","decl":"/-- The `(m * n)`-th Chebyshev `C` polynomial is the composition of the `m`-th and `n`-th. -/\ntheorem C_mul (m n : ℤ) : C R (m * n) = (C R m).comp (C R n) := by\n  induction m using Polynomial.Chebyshev.induct with\n  | zero => simp\n  | one => simp\n  | add_two m ih1 ih2 =>\n    have h₁ := C_mul_C R ((m + 1) * n) n\n    have h₂ := congr_arg (comp · (C R n)) <| C_add_two R m\n    simp only [sub_comp, mul_comp, X_comp] at h₂\n    linear_combination (norm := ring_nf) -ih2 - h₂ - h₁ + C R n * ih1\n  | neg_add_one m ih1 ih2 =>\n    have h₁ := C_mul_C R ((-m) * n) n\n    have h₂ := congr_arg (comp · (C R n)) <| C_add_two R (-m - 1)\n    simp only [sub_comp, mul_comp, X_comp] at h₂\n    linear_combination (norm := ring_nf) -ih2 - h₂ - h₁ + C R n * ih1\n\n"}
