{"name":"IntermediateField.mk.inj","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ntoSubalgebra✝ : Subalgebra K L\ninv_mem'✝ : ∀ (x : L), Membership.mem toSubalgebra✝.carrier x → Membership.mem toSubalgebra✝.carrier (Inv.inv x)\ntoSubalgebra : Subalgebra K L\ninv_mem' : ∀ (x : L), Membership.mem toSubalgebra.carrier x → Membership.mem toSubalgebra.carrier (Inv.inv x)\nx✝ : Eq { toSubalgebra := toSubalgebra✝, inv_mem' := inv_mem'✝ } { toSubalgebra := toSubalgebra, inv_mem' := inv_mem' }\n⊢ Eq toSubalgebra✝ toSubalgebra","decl":"/-- `S : IntermediateField K L` is a subset of `L` such that there is a field\ntower `L / S / K`. -/\nstructure IntermediateField extends Subalgebra K L where\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"IntermediateField.inv_mem'","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nself : IntermediateField K L\nx : L\na✝ : Membership.mem self.carrier x\n⊢ Membership.mem self.carrier (Inv.inv x)","decl":"/-- `S : IntermediateField K L` is a subset of `L` such that there is a field\ntower `L / S / K`. -/\nstructure IntermediateField extends Subalgebra K L where\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"IntermediateField.mk.injEq","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ntoSubalgebra✝ : Subalgebra K L\ninv_mem'✝ : ∀ (x : L), Membership.mem toSubalgebra✝.carrier x → Membership.mem toSubalgebra✝.carrier (Inv.inv x)\ntoSubalgebra : Subalgebra K L\ninv_mem' : ∀ (x : L), Membership.mem toSubalgebra.carrier x → Membership.mem toSubalgebra.carrier (Inv.inv x)\n⊢ Eq (Eq { toSubalgebra := toSubalgebra✝, inv_mem' := inv_mem'✝ } { toSubalgebra := toSubalgebra, inv_mem' := inv_mem' }) (Eq toSubalgebra✝ toSubalgebra)","decl":"/-- `S : IntermediateField K L` is a subset of `L` such that there is a field\ntower `L / S / K`. -/\nstructure IntermediateField extends Subalgebra K L where\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"IntermediateField.mk.sizeOf_spec","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : SizeOf K\ninst✝ : SizeOf L\ntoSubalgebra : Subalgebra K L\ninv_mem' : ∀ (x : L), Membership.mem toSubalgebra.carrier x → Membership.mem toSubalgebra.carrier (Inv.inv x)\n⊢ Eq (SizeOf.sizeOf { toSubalgebra := toSubalgebra, inv_mem' := inv_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubalgebra))","decl":"/-- `S : IntermediateField K L` is a subset of `L` such that there is a field\ntower `L / S / K`. -/\nstructure IntermediateField extends Subalgebra K L where\n  inv_mem' : ∀ x ∈ carrier, x⁻¹ ∈ carrier\n\n"}
{"name":"IntermediateField.neg_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : L\nhx : Membership.mem S x\n⊢ Membership.mem S (Neg.neg x)","decl":"protected theorem neg_mem {x : L} (hx : x ∈ S) : -x ∈ S := by\n  show -x ∈S.toSubalgebra; simpa\n\n"}
{"name":"IntermediateField.instSubfieldClass","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\n⊢ SubfieldClass (IntermediateField K L) L","decl":"instance : SubfieldClass (IntermediateField K L) L where\n  add_mem {s} := s.add_mem'\n  zero_mem {s} := s.zero_mem'\n  neg_mem {s} := s.neg_mem\n  mul_mem {s} := s.mul_mem'\n  one_mem {s} := s.one_mem'\n  inv_mem {s} := s.inv_mem' _\n\n--@[simp] Porting note (https://github.com/leanprover-community/mathlib4/issues/10618): simp can prove it\n"}
{"name":"IntermediateField.mem_carrier","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ns : IntermediateField K L\nx : L\n⊢ Iff (Membership.mem s.carrier x) (Membership.mem s x)","decl":"theorem mem_carrier {s : IntermediateField K L} {x : L} : x ∈ s.carrier ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.ext_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS T : IntermediateField K L\n⊢ Iff (Eq S T) (∀ (x : L), Iff (Membership.mem S x) (Membership.mem T x))","decl":"/-- Two intermediate fields are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : IntermediateField K L} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"IntermediateField.ext","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS T : IntermediateField K L\nh : ∀ (x : L), Iff (Membership.mem S x) (Membership.mem T x)\n⊢ Eq S T","decl":"/-- Two intermediate fields are equal if they have the same elements. -/\n@[ext]\ntheorem ext {S T : IntermediateField K L} (h : ∀ x, x ∈ S ↔ x ∈ T) : S = T :=\n  SetLike.ext h\n\n"}
{"name":"IntermediateField.coe_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq ↑S.toSubalgebra ↑S","decl":"@[simp]\ntheorem coe_toSubalgebra : (S.toSubalgebra : Set L) = S :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq ↑S.toSubfield ↑S","decl":"@[simp]\ntheorem coe_toSubfield : (S.toSubfield : Set L) = S :=\n  rfl\n\n"}
{"name":"IntermediateField.mem_mk","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ns : Subsemiring L\nhK : ∀ (x : K), Membership.mem s ((algebraMap K L) x)\nhi : ∀ (x : L), Membership.mem { toSubsemiring := s, algebraMap_mem' := hK }.carrier x → Membership.mem { toSubsemiring := s, algebraMap_mem' := hK }.carrier (Inv.inv x)\nx : L\n⊢ Iff (Membership.mem { toSubsemiring := s, algebraMap_mem' := hK, inv_mem' := hi } x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_mk (s : Subsemiring L) (hK : ∀ x, algebraMap K L x ∈ s) (hi) (x : L) :\n    x ∈ IntermediateField.mk (Subalgebra.mk s hK) hi ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.mem_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ns : IntermediateField K L\nx : L\n⊢ Iff (Membership.mem s.toSubalgebra x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_toSubalgebra (s : IntermediateField K L) (x : L) : x ∈ s.toSubalgebra ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.mem_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\ns : IntermediateField K L\nx : L\n⊢ Iff (Membership.mem s.toSubfield x) (Membership.mem s x)","decl":"@[simp]\ntheorem mem_toSubfield (s : IntermediateField K L) (x : L) : x ∈ s.toSubfield ↔ x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.coe_copy","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\ns : Set L\nhs : Eq s ↑S\n⊢ Eq (↑(S.copy s hs)) s","decl":"@[simp]\ntheorem coe_copy (S : IntermediateField K L) (s : Set L) (hs : s = ↑S) :\n    (S.copy s hs : Set L) = s :=\n  rfl\n\n"}
{"name":"IntermediateField.copy_eq","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\ns : Set L\nhs : Eq s ↑S\n⊢ Eq (S.copy s hs) S","decl":"theorem copy_eq (S : IntermediateField K L) (s : Set L) (hs : s = ↑S) : S.copy s hs = S :=\n  SetLike.coe_injective hs\n\n"}
{"name":"IntermediateField.algebraMap_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : K\n⊢ Membership.mem S ((algebraMap K L) x)","decl":"/-- An intermediate field contains the image of the smaller field. -/\ntheorem algebraMap_mem (x : K) : algebraMap K L x ∈ S :=\n  S.algebraMap_mem' x\n\n"}
{"name":"IntermediateField.smul_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\ny : L\na✝ : Membership.mem S y\nx : K\n⊢ Membership.mem S (HSMul.hSMul x y)","decl":"/-- An intermediate field is closed under scalar multiplication. -/\ntheorem smul_mem {y : L} : y ∈ S → ∀ {x : K}, x • y ∈ S :=\n  S.toSubalgebra.smul_mem\n\n"}
{"name":"IntermediateField.one_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Membership.mem S 1","decl":"/-- An intermediate field contains the ring's 1. -/\nprotected theorem one_mem : (1 : L) ∈ S :=\n  one_mem S\n\n"}
{"name":"IntermediateField.zero_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Membership.mem S 0","decl":"/-- An intermediate field contains the ring's 0. -/\nprotected theorem zero_mem : (0 : L) ∈ S :=\n  zero_mem S\n\n"}
{"name":"IntermediateField.mul_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : L\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HMul.hMul x y)","decl":"/-- An intermediate field is closed under multiplication. -/\nprotected theorem mul_mem {x y : L} : x ∈ S → y ∈ S → x * y ∈ S :=\n  mul_mem\n\n"}
{"name":"IntermediateField.add_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : L\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HAdd.hAdd x y)","decl":"/-- An intermediate field is closed under addition. -/\nprotected theorem add_mem {x y : L} : x ∈ S → y ∈ S → x + y ∈ S :=\n  add_mem\n\n"}
{"name":"IntermediateField.sub_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : L\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HSub.hSub x y)","decl":"/-- An intermediate field is closed under subtraction -/\nprotected theorem sub_mem {x y : L} : x ∈ S → y ∈ S → x - y ∈ S :=\n  sub_mem\n\n"}
{"name":"IntermediateField.inv_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : L\na✝ : Membership.mem S x\n⊢ Membership.mem S (Inv.inv x)","decl":"/-- An intermediate field is closed under inverses. -/\nprotected theorem inv_mem {x : L} : x ∈ S → x⁻¹ ∈ S :=\n  inv_mem\n\n"}
{"name":"IntermediateField.div_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : L\na✝¹ : Membership.mem S x\na✝ : Membership.mem S y\n⊢ Membership.mem S (HDiv.hDiv x y)","decl":"/-- An intermediate field is closed under division. -/\nprotected theorem div_mem {x y : L} : x ∈ S → y ∈ S → x / y ∈ S :=\n  div_mem\n\n"}
{"name":"IntermediateField.list_prod_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nl : List L\na✝ : ∀ (x : L), Membership.mem l x → Membership.mem S x\n⊢ Membership.mem S l.prod","decl":"/-- Product of a list of elements in an intermediate_field is in the intermediate_field. -/\nprotected theorem list_prod_mem {l : List L} : (∀ x ∈ l, x ∈ S) → l.prod ∈ S :=\n  list_prod_mem\n\n"}
{"name":"IntermediateField.list_sum_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nl : List L\na✝ : ∀ (x : L), Membership.mem l x → Membership.mem S x\n⊢ Membership.mem S l.sum","decl":"/-- Sum of a list of elements in an intermediate field is in the intermediate_field. -/\nprotected theorem list_sum_mem {l : List L} : (∀ x ∈ l, x ∈ S) → l.sum ∈ S :=\n  list_sum_mem\n\n"}
{"name":"IntermediateField.multiset_prod_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nm : Multiset L\na✝ : ∀ (a : L), Membership.mem m a → Membership.mem S a\n⊢ Membership.mem S m.prod","decl":"/-- Product of a multiset of elements in an intermediate field is in the intermediate_field. -/\nprotected theorem multiset_prod_mem (m : Multiset L) : (∀ a ∈ m, a ∈ S) → m.prod ∈ S :=\n  multiset_prod_mem m\n\n"}
{"name":"IntermediateField.multiset_sum_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nm : Multiset L\na✝ : ∀ (a : L), Membership.mem m a → Membership.mem S a\n⊢ Membership.mem S m.sum","decl":"/-- Sum of a multiset of elements in an `IntermediateField` is in the `IntermediateField`. -/\nprotected theorem multiset_sum_mem (m : Multiset L) : (∀ a ∈ m, a ∈ S) → m.sum ∈ S :=\n  multiset_sum_mem m\n\n"}
{"name":"IntermediateField.prod_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nι : Type u_4\nt : Finset ι\nf : ι → L\nh : ∀ (c : ι), Membership.mem t c → Membership.mem S (f c)\n⊢ Membership.mem S (t.prod fun i => f i)","decl":"/-- Product of elements of an intermediate field indexed by a `Finset` is in the intermediate_field.\n-/\nprotected theorem prod_mem {ι : Type*} {t : Finset ι} {f : ι → L} (h : ∀ c ∈ t, f c ∈ S) :\n    (∏ i ∈ t, f i) ∈ S :=\n  prod_mem h\n\n"}
{"name":"IntermediateField.sum_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nι : Type u_4\nt : Finset ι\nf : ι → L\nh : ∀ (c : ι), Membership.mem t c → Membership.mem S (f c)\n⊢ Membership.mem S (t.sum fun i => f i)","decl":"/-- Sum of elements in an `IntermediateField` indexed by a `Finset` is in the `IntermediateField`.\n-/\nprotected theorem sum_mem {ι : Type*} {t : Finset ι} {f : ι → L} (h : ∀ c ∈ t, f c ∈ S) :\n    (∑ i ∈ t, f i) ∈ S :=\n  sum_mem h\n\n"}
{"name":"IntermediateField.pow_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : L\nhx : Membership.mem S x\nn : Int\n⊢ Membership.mem S (HPow.hPow x n)","decl":"protected theorem pow_mem {x : L} (hx : x ∈ S) (n : ℤ) : x ^ n ∈ S :=\n  zpow_mem hx n\n\n"}
{"name":"IntermediateField.zsmul_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : L\nhx : Membership.mem S x\nn : Int\n⊢ Membership.mem S (HSMul.hSMul n x)","decl":"protected theorem zsmul_mem {x : L} (hx : x ∈ S) (n : ℤ) : n • x ∈ S :=\n  zsmul_mem hx n\n\n"}
{"name":"IntermediateField.intCast_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nn : Int\n⊢ Membership.mem S ↑n","decl":"protected theorem intCast_mem (n : ℤ) : (n : L) ∈ S :=\n  intCast_mem S n\n\n"}
{"name":"IntermediateField.coe_add","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"protected theorem coe_add (x y : S) : (↑(x + y) : L) = ↑x + ↑y :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_neg","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"protected theorem coe_neg (x : S) : (↑(-x) : L) = -↑x :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_mul","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx y : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"protected theorem coe_mul (x y : S) : (↑(x * y) : L) = ↑x * ↑y :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_inv","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"protected theorem coe_inv (x : S) : (↑x⁻¹ : L) = (↑x)⁻¹ :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_zero","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq (↑0) 0","decl":"protected theorem coe_zero : ((0 : S) : L) = 0 :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_one","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq (↑1) 1","decl":"protected theorem coe_one : ((1 : S) : L) = 1 :=\n  rfl\n\n"}
{"name":"IntermediateField.coe_pow","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : Subtype fun x => Membership.mem S x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"protected theorem coe_pow (x : S) (n : ℕ) : (↑(x ^ n : S) : L) = (x : L) ^ n :=\n  SubmonoidClass.coe_pow x n\n\n"}
{"name":"IntermediateField.natCast_mem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nn : Nat\n⊢ Membership.mem S ↑n","decl":"theorem natCast_mem (n : ℕ) : (n : L) ∈ S := by simpa using intCast_mem S n\n\n"}
{"name":"toSubalgebra_toIntermediateField","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : Subalgebra K L\ninv_mem : ∀ (x : L), Membership.mem S x → Membership.mem S (Inv.inv x)\n⊢ Eq (S.toIntermediateField inv_mem).toSubalgebra S","decl":"@[simp]\ntheorem toSubalgebra_toIntermediateField (S : Subalgebra K L) (inv_mem : ∀ x ∈ S, x⁻¹ ∈ S) :\n    (S.toIntermediateField inv_mem).toSubalgebra = S := by\n  ext\n  rfl\n\n"}
{"name":"toIntermediateField_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq (S.toIntermediateField ⋯) S","decl":"@[simp]\ntheorem toIntermediateField_toSubalgebra (S : IntermediateField K L) :\n    (S.toSubalgebra.toIntermediateField fun _ => S.inv_mem) = S := by\n  ext\n  rfl\n\n"}
{"name":"toSubalgebra_toIntermediateField'","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : Subalgebra K L\nhS : IsField (Subtype fun x => Membership.mem S x)\n⊢ Eq (S.toIntermediateField' hS).toSubalgebra S","decl":"@[simp]\ntheorem toSubalgebra_toIntermediateField' (S : Subalgebra K L) (hS : IsField S) :\n    (S.toIntermediateField' hS).toSubalgebra = S := by\n  ext\n  rfl\n\n"}
{"name":"toIntermediateField'_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq (S.toIntermediateField' ⋯) S","decl":"@[simp]\ntheorem toIntermediateField'_toSubalgebra (S : IntermediateField K L) :\n    S.toSubalgebra.toIntermediateField' (Field.toIsField S) = S := by\n  ext\n  rfl\n\n"}
{"name":"IntermediateField.coe_sum","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nS : IntermediateField K L\nι : Type u_4\ninst✝ : Fintype ι\nf : ι → Subtype fun x => Membership.mem S x\n⊢ Eq (↑(Finset.univ.sum fun i => f i)) (Finset.univ.sum fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem coe_sum {ι : Type*} [Fintype ι] (f : ι → S) : (↑(∑ i, f i) : L) = ∑ i, (f i : L) := by\n  classical\n    induction' (Finset.univ : Finset ι) using Finset.induction_on with i s hi H\n    · simp\n    · rw [Finset.sum_insert hi, AddMemClass.coe_add, H, Finset.sum_insert hi]\n\n"}
{"name":"IntermediateField.coe_prod","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nS : IntermediateField K L\nι : Type u_4\ninst✝ : Fintype ι\nf : ι → Subtype fun x => Membership.mem S x\n⊢ Eq (↑(Finset.univ.prod fun i => f i)) (Finset.univ.prod fun i => ↑(f i))","decl":"@[norm_cast]\ntheorem coe_prod {ι : Type*} [Fintype ι] (f : ι → S) : (↑(∏ i, f i) : L) = ∏ i, (f i : L) := by\n  classical\n    induction' (Finset.univ : Finset ι) using Finset.induction_on with i s hi H\n    · simp\n    · rw [Finset.prod_insert hi, MulMemClass.coe_mul, H, Finset.prod_insert hi]\n\n"}
{"name":"IntermediateField.smul_def","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nX : Type u_4\ninst✝ : SMul L X\nF : IntermediateField K L\ng : Subtype fun x => Membership.mem F x\nm : X\n⊢ Eq (HSMul.hSMul g m) (HSMul.hSMul (↑g) m)","decl":"theorem smul_def [SMul L X] {F : IntermediateField K L} (g : F) (m : X) : g • m = (g : L) • m :=\n  rfl\n\n"}
{"name":"IntermediateField.smulCommClass_left","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\nX : Type u_5\nY : Type u_4\ninst✝² : SMul L Y\ninst✝¹ : SMul X Y\ninst✝ : SMulCommClass L X Y\nF : IntermediateField K L\n⊢ SMulCommClass (Subtype fun x => Membership.mem F x) X Y","decl":"instance smulCommClass_left [SMul L Y] [SMul X Y] [SMulCommClass L X Y]\n    (F : IntermediateField K L) : SMulCommClass F X Y :=\n  inferInstanceAs (SMulCommClass F.toSubfield X Y)\n\n"}
{"name":"IntermediateField.smulCommClass_right","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\nX : Type u_4\nY : Type u_5\ninst✝² : SMul X Y\ninst✝¹ : SMul L Y\ninst✝ : SMulCommClass X L Y\nF : IntermediateField K L\n⊢ SMulCommClass X (Subtype fun x => Membership.mem F x) Y","decl":"instance smulCommClass_right [SMul X Y] [SMul L Y] [SMulCommClass X L Y]\n    (F : IntermediateField K L) : SMulCommClass X F Y :=\n  inferInstanceAs (SMulCommClass X F.toSubfield Y)\n\n-- note: giving this instance the default priority may trigger trouble with synthesizing instances\n-- for field extensions with more than one intermediate field. For example, in a field extension\n-- `E/F`, and with `K₁ ≤ K₂` of type `IntermediateField F E`, this instance will cause a search\n-- for `IsScalarTower K₁ K₂ E` to trigger a search for `IsScalarTower E K₂ E` which may\n-- take a long time to fail.\n"}
{"name":"IntermediateField.instIsScalarTowerSubtypeMem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nX : Type u_4\nY : Type u_5\ninst✝³ : SMul X Y\ninst✝² : SMul L X\ninst✝¹ : SMul L Y\ninst✝ : IsScalarTower L X Y\nF : IntermediateField K L\n⊢ IsScalarTower (Subtype fun x => Membership.mem F x) X Y","decl":"/-- Note that this provides `IsScalarTower F K K` which is needed by `smul_mul_assoc`. -/\ninstance (priority := 900) [SMul X Y] [SMul L X] [SMul L Y] [IsScalarTower L X Y]\n    (F : IntermediateField K L) : IsScalarTower F X Y :=\n  inferInstanceAs (IsScalarTower F.toSubfield X Y)\n\n"}
{"name":"IntermediateField.instFaithfulSMulSubtypeMem","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nX : Type u_4\ninst✝¹ : SMul L X\ninst✝ : FaithfulSMul L X\nF : IntermediateField K L\n⊢ FaithfulSMul (Subtype fun x => Membership.mem F x) X","decl":"instance [SMul L X] [FaithfulSMul L X] (F : IntermediateField K L) : FaithfulSMul F X :=\n  inferInstanceAs (FaithfulSMul F.toSubfield X)\n\n"}
{"name":"IntermediateField.isScalarTower","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nS : IntermediateField K L\nR : Type u_4\ninst✝³ : Semiring R\ninst✝² : SMul R K\ninst✝¹ : Module R L\ninst✝ : IsScalarTower R K L\n⊢ IsScalarTower R K (Subtype fun x => Membership.mem S x)","decl":"instance isScalarTower {R} [Semiring R] [SMul R K] [Module R L] [IsScalarTower R K L] :\n    IsScalarTower R K S :=\n  inferInstanceAs (IsScalarTower R K S.toSubalgebra)\n\n"}
{"name":"IntermediateField.coe_smul","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nS : IntermediateField K L\nR : Type u_4\ninst✝³ : Semiring R\ninst✝² : SMul R K\ninst✝¹ : Module R L\ninst✝ : IsScalarTower R K L\nr : R\nx : Subtype fun x => Membership.mem S x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp]\ntheorem coe_smul {R} [Semiring R] [SMul R K] [Module R L] [IsScalarTower R K L] (r : R) (x : S) :\n    ↑(r • x : S) = (r • (x : L)) :=\n  rfl\n\n"}
{"name":"IntermediateField.algebraMap_apply","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : Subtype fun x => Membership.mem S x\n⊢ Eq ((algebraMap (Subtype fun x => Membership.mem S x) L) x) ↑x","decl":"@[simp] lemma algebraMap_apply (x : S) : algebraMap S L x = x := rfl\n\n"}
{"name":"IntermediateField.coe_algebraMap_apply","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : K\n⊢ Eq (↑((algebraMap K (Subtype fun x => Membership.mem S x)) x)) ((algebraMap K L) x)","decl":"@[simp] lemma coe_algebraMap_apply (x : K) : ↑(algebraMap K S x) = algebraMap K L x := rfl\n\n"}
{"name":"IntermediateField.isScalarTower_bot","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nS : IntermediateField K L\nR : Type u_4\ninst✝¹ : Semiring R\ninst✝ : Algebra L R\n⊢ IsScalarTower (Subtype fun x => Membership.mem S x) L R","decl":"instance isScalarTower_bot {R : Type*} [Semiring R] [Algebra L R] : IsScalarTower S L R :=\n  IsScalarTower.subalgebra _ _ _ S.toSubalgebra\n\n"}
{"name":"IntermediateField.isScalarTower_mid","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nS : IntermediateField K L\nR : Type u_4\ninst✝³ : Semiring R\ninst✝² : Algebra L R\ninst✝¹ : Algebra K R\ninst✝ : IsScalarTower K L R\n⊢ IsScalarTower K (Subtype fun x => Membership.mem S x) R","decl":"instance isScalarTower_mid {R : Type*} [Semiring R] [Algebra L R] [Algebra K R]\n    [IsScalarTower K L R] : IsScalarTower K S R :=\n  IsScalarTower.subalgebra' _ _ _ S.toSubalgebra\n\n"}
{"name":"IntermediateField.isScalarTower_mid'","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ IsScalarTower K (Subtype fun x => Membership.mem S x) L","decl":"/-- Specialize `is_scalar_tower_mid` to the common case where the top field is `L` -/\ninstance isScalarTower_mid' : IsScalarTower K S L :=\n  inferInstance\n\n"}
{"name":"IntermediateField.instIsScalarTowerSubtypeMem_1","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nS : IntermediateField K L\nE : Type u_4\ninst✝³ : Field E\ninst✝² : Algebra L E\nT : IntermediateField (Subtype fun x => Membership.mem S x) E\ninst✝¹ : Algebra K E\ninst✝ : IsScalarTower K L E\n⊢ IsScalarTower K (Subtype fun x => Membership.mem S x) (Subtype fun x => Membership.mem T x)","decl":"instance [Algebra K E] [IsScalarTower K L E] : IsScalarTower K S T := T.isScalarTower\n"}
{"name":"IntermediateField.coe_map","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nS : IntermediateField K L\nf : AlgHom K L L'\n⊢ Eq (↑(IntermediateField.map f S)) (Set.image ⇑f ↑S)","decl":"@[simp]\ntheorem coe_map (f : L →ₐ[K] L') : (S.map f : Set L') = f '' S :=\n  rfl\n\n"}
{"name":"IntermediateField.toSubalgebra_map","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nS : IntermediateField K L\nf : AlgHom K L L'\n⊢ Eq (IntermediateField.map f S).toSubalgebra (Subalgebra.map f S.toSubalgebra)","decl":"@[simp]\ntheorem toSubalgebra_map (f : L →ₐ[K] L') : (S.map f).toSubalgebra = S.toSubalgebra.map f :=\n  rfl\n\n"}
{"name":"IntermediateField.toSubfield_map","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nS : IntermediateField K L\nf : AlgHom K L L'\n⊢ Eq (IntermediateField.map f S).toSubfield (Subfield.map (↑f) S.toSubfield)","decl":"@[simp]\ntheorem toSubfield_map (f : L →ₐ[K] L') : (S.map f).toSubfield = S.toSubfield.map f :=\n  rfl\n\n"}
{"name":"IntermediateField.map_map","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_4\nL₁ : Type u_5\nL₂ : Type u_6\nL₃ : Type u_7\ninst✝⁶ : Field K\ninst✝⁵ : Field L₁\ninst✝⁴ : Algebra K L₁\ninst✝³ : Field L₂\ninst✝² : Algebra K L₂\ninst✝¹ : Field L₃\ninst✝ : Algebra K L₃\nE : IntermediateField K L₁\nf : AlgHom K L₁ L₂\ng : AlgHom K L₂ L₃\n⊢ Eq (IntermediateField.map g (IntermediateField.map f E)) (IntermediateField.map (g.comp f) E)","decl":"theorem map_map {K L₁ L₂ L₃ : Type*} [Field K] [Field L₁] [Algebra K L₁] [Field L₂] [Algebra K L₂]\n    [Field L₃] [Algebra K L₃] (E : IntermediateField K L₁) (f : L₁ →ₐ[K] L₂) (g : L₂ →ₐ[K] L₃) :\n    (E.map f).map g = E.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n\n"}
{"name":"IntermediateField.map_mono","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\nS T : IntermediateField K L\nh : LE.le S T\n⊢ LE.le (IntermediateField.map f S) (IntermediateField.map f T)","decl":"theorem map_mono (f : L →ₐ[K] L') {S T : IntermediateField K L} (h : S ≤ T) :\n    S.map f ≤ T.map f :=\n  SetLike.coe_mono (Set.image_subset f h)\n\n"}
{"name":"IntermediateField.map_le_iff_le_comap","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\ns : IntermediateField K L\nt : IntermediateField K L'\n⊢ Iff (LE.le (IntermediateField.map f s) t) (LE.le s (IntermediateField.comap f t))","decl":"theorem map_le_iff_le_comap {f : L →ₐ[K] L'}\n    {s : IntermediateField K L} {t : IntermediateField K L'} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n\n"}
{"name":"IntermediateField.gc_map_comap","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\n⊢ GaloisConnection (IntermediateField.map f) (IntermediateField.comap f)","decl":"theorem gc_map_comap (f : L →ₐ[K] L') : GaloisConnection (map f) (comap f) :=\n  fun _ _ ↦ map_le_iff_le_comap\n\n"}
{"name":"IntermediateField.intermediateFieldMap_apply_coe","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\ne : AlgEquiv K L L'\nE : IntermediateField K L\na : Subtype fun x => Membership.mem E x\n⊢ Eq (↑((IntermediateField.intermediateFieldMap e E) a)) (e ↑a)","decl":"theorem intermediateFieldMap_apply_coe (e : L ≃ₐ[K] L') (E : IntermediateField K L) (a : E) :\n    ↑(intermediateFieldMap e E a) = e a :=\n  rfl\n\n"}
{"name":"IntermediateField.intermediateFieldMap_symm_apply_coe","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\ne : AlgEquiv K L L'\nE : IntermediateField K L\na : Subtype fun x => Membership.mem (IntermediateField.map (↑e) E) x\n⊢ Eq (↑((IntermediateField.intermediateFieldMap e E).symm a)) (e.symm ↑a)","decl":"theorem intermediateFieldMap_symm_apply_coe (e : L ≃ₐ[K] L') (E : IntermediateField K L)\n    (a : E.map e.toAlgHom) : ↑((intermediateFieldMap e E).symm a) = e.symm a :=\n  rfl\n\n"}
{"name":"AlgHom.fieldRange_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\n⊢ Eq f.fieldRange.toSubalgebra f.range","decl":"/-- The range of an algebra homomorphism, as an intermediate field. -/\n@[simps toSubalgebra]\ndef fieldRange : IntermediateField K L' :=\n  { f.range, (f : L →+* L').fieldRange with }\n\n"}
{"name":"AlgHom.coe_fieldRange","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\n⊢ Eq (↑f.fieldRange) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_fieldRange : ↑f.fieldRange = Set.range f :=\n  rfl\n\n"}
{"name":"AlgHom.fieldRange_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\n⊢ Eq f.fieldRange.toSubfield (↑f).fieldRange","decl":"@[simp]\ntheorem fieldRange_toSubfield : f.fieldRange.toSubfield = (f : L →+* L').fieldRange :=\n  rfl\n\n"}
{"name":"AlgHom.mem_fieldRange","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\ny : L'\n⊢ Iff (Membership.mem f.fieldRange y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_fieldRange {y : L'} : y ∈ f.fieldRange ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.coe_val","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq (⇑S.val) Subtype.val","decl":"@[simp]\ntheorem coe_val : ⇑S.val = ((↑) : S → L) :=\n  rfl\n\n"}
{"name":"IntermediateField.val_mk","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\nx : L\nhx : Membership.mem S x\n⊢ Eq (S.val ⟨x, hx⟩) x","decl":"@[simp]\ntheorem val_mk {x : L} (hx : x ∈ S) : S.val ⟨x, hx⟩ = x :=\n  rfl\n\n"}
{"name":"IntermediateField.range_val","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq S.val.range S.toSubalgebra","decl":"theorem range_val : S.val.range = S.toSubalgebra :=\n  S.toSubalgebra.range_val\n\n"}
{"name":"IntermediateField.fieldRange_val","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ Eq S.val.fieldRange S","decl":"@[simp]\ntheorem fieldRange_val : S.val.fieldRange = S :=\n  SetLike.ext' Subtype.range_val\n\n"}
{"name":"IntermediateField.aeval_coe","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K L\nS : IntermediateField K L\nR : Type u_4\ninst✝³ : CommRing R\ninst✝² : Algebra R K\ninst✝¹ : Algebra R L\ninst✝ : IsScalarTower R K L\nx : Subtype fun x => Membership.mem S x\nP : Polynomial R\n⊢ Eq ((Polynomial.aeval ↑x) P) ↑((Polynomial.aeval x) P)","decl":"theorem aeval_coe {R : Type*} [CommRing R] [Algebra R K] [Algebra R L] [IsScalarTower R K L]\n    (x : S) (P : R[X]) : aeval (x : L) P = aeval x P :=\n  aeval_algHom_apply (S.val.restrictScalars R) x P\n\n"}
{"name":"IntermediateField.inclusion_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE F : IntermediateField K L\nhEF : LE.le E F\n⊢ Function.Injective ⇑(IntermediateField.inclusion hEF)","decl":"theorem inclusion_injective {E F : IntermediateField K L} (hEF : E ≤ F) :\n    Function.Injective (inclusion hEF) :=\n  Subalgebra.inclusion_injective hEF\n\n"}
{"name":"IntermediateField.inclusion_self","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE : IntermediateField K L\n⊢ Eq (IntermediateField.inclusion ⋯) (AlgHom.id K (Subtype fun x => Membership.mem E x))","decl":"@[simp]\ntheorem inclusion_self {E : IntermediateField K L} : inclusion (le_refl E) = AlgHom.id K E :=\n  Subalgebra.inclusion_self\n\n"}
{"name":"IntermediateField.inclusion_inclusion","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE F G : IntermediateField K L\nhEF : LE.le E F\nhFG : LE.le F G\nx : Subtype fun x => Membership.mem E x\n⊢ Eq ((IntermediateField.inclusion hFG) ((IntermediateField.inclusion hEF) x)) ((IntermediateField.inclusion ⋯) x)","decl":"@[simp]\ntheorem inclusion_inclusion {E F G : IntermediateField K L} (hEF : E ≤ F) (hFG : F ≤ G) (x : E) :\n    inclusion hFG (inclusion hEF x) = inclusion (le_trans hEF hFG) x :=\n  Subalgebra.inclusion_inclusion hEF hFG x\n\n"}
{"name":"IntermediateField.coe_inclusion","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE F : IntermediateField K L\nhEF : LE.le E F\ne : Subtype fun x => Membership.mem E x\n⊢ Eq ↑((IntermediateField.inclusion hEF) e) ↑e","decl":"@[simp]\ntheorem coe_inclusion {E F : IntermediateField K L} (hEF : E ≤ F) (e : E) :\n    (inclusion hEF e : L) = e :=\n  rfl\n\n"}
{"name":"IntermediateField.toSubalgebra_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\n⊢ Function.Injective IntermediateField.toSubalgebra","decl":"theorem toSubalgebra_injective : Function.Injective (toSubalgebra : IntermediateField K L → _) := by\n  intro _ _ h\n  ext\n  simp_rw [← mem_toSubalgebra, h]\n\n"}
{"name":"IntermediateField.toSubfield_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\n⊢ Function.Injective IntermediateField.toSubfield","decl":"theorem toSubfield_injective : Function.Injective (toSubfield : IntermediateField K L → _) := by\n  intro _ _ h\n  ext\n  simp_rw [← mem_toSubfield, h]\n\n"}
{"name":"IntermediateField.toSubalgebra_inj","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\n⊢ Iff (Eq F.toSubalgebra E.toSubalgebra) (Eq F E)","decl":"@[simp]\ntheorem toSubalgebra_inj : F.toSubalgebra = E.toSubalgebra ↔ F = E := toSubalgebra_injective.eq_iff\n\n"}
{"name":"IntermediateField.toSubalgebra_eq_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\n⊢ Iff (Eq F.toSubalgebra E.toSubalgebra) (Eq F E)","decl":"@[deprecated (since := \"2024-12-29\")] alias toSubalgebra_eq_iff := toSubalgebra_inj\n\n"}
{"name":"IntermediateField.toSubfield_inj","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\n⊢ Iff (Eq F.toSubfield E.toSubfield) (Eq F E)","decl":"@[simp]\ntheorem toSubfield_inj : F.toSubfield = E.toSubfield ↔ F = E := toSubfield_injective.eq_iff\n\n"}
{"name":"IntermediateField.map_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field L'\ninst✝¹ : Algebra K L\ninst✝ : Algebra K L'\nf : AlgHom K L L'\n⊢ Function.Injective (IntermediateField.map f)","decl":"theorem map_injective (f : L →ₐ[K] L') : Function.Injective (map f) := by\n  intro _ _ h\n  rwa [← toSubalgebra_injective.eq_iff, toSubalgebra_map, toSubalgebra_map,\n    (Subalgebra.map_injective f.injective).eq_iff, toSubalgebra_inj] at h\n\n"}
{"name":"IntermediateField.set_range_subset","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ HasSubset.Subset (Set.range ⇑(algebraMap K L)) ↑S","decl":"theorem set_range_subset : Set.range (algebraMap K L) ⊆ S :=\n  S.toSubalgebra.range_subset\n\n"}
{"name":"IntermediateField.fieldRange_le","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : IntermediateField K L\n⊢ LE.le (algebraMap K L).fieldRange S.toSubfield","decl":"theorem fieldRange_le : (algebraMap K L).fieldRange ≤ S.toSubfield := fun x hx =>\n  S.toSubalgebra.range_subset (by rwa [Set.mem_range, ← RingHom.mem_fieldRange])\n\n"}
{"name":"IntermediateField.toSubalgebra_le_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS S' : IntermediateField K L\n⊢ Iff (LE.le S.toSubalgebra S'.toSubalgebra) (LE.le S S')","decl":"@[simp]\ntheorem toSubalgebra_le_toSubalgebra {S S' : IntermediateField K L} :\n    S.toSubalgebra ≤ S'.toSubalgebra ↔ S ≤ S' :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.toSubalgebra_lt_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS S' : IntermediateField K L\n⊢ Iff (LT.lt S.toSubalgebra S'.toSubalgebra) (LT.lt S S')","decl":"@[simp]\ntheorem toSubalgebra_lt_toSubalgebra {S S' : IntermediateField K L} :\n    S.toSubalgebra < S'.toSubalgebra ↔ S < S' :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.lift_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\n⊢ Function.Injective IntermediateField.lift","decl":"theorem lift_injective (F : IntermediateField K L) : Function.Injective F.lift :=\n  map_injective F.val\n\n"}
{"name":"IntermediateField.lift_le","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\nE : IntermediateField K (Subtype fun x => Membership.mem F x)\n⊢ LE.le (IntermediateField.lift E) F","decl":"theorem lift_le {F : IntermediateField K L} (E : IntermediateField K F) : lift E ≤ F := by\n  rintro _ ⟨x, _, rfl⟩\n  exact x.2\n\n"}
{"name":"IntermediateField.mem_lift","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\nE : IntermediateField K (Subtype fun x => Membership.mem F x)\nx : Subtype fun x => Membership.mem F x\n⊢ Iff (Membership.mem (IntermediateField.lift E) ↑x) (Membership.mem E x)","decl":"theorem mem_lift {F : IntermediateField K L} {E : IntermediateField K F} (x : F) :\n    x.1 ∈ lift E ↔ x ∈ E :=\n  Subtype.val_injective.mem_set_image\n\n"}
{"name":"IntermediateField.liftAlgEquiv_apply","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE : IntermediateField K L\nF : IntermediateField K (Subtype fun x => Membership.mem E x)\nx : Subtype fun x => Membership.mem F x\n⊢ Eq ↑((IntermediateField.liftAlgEquiv F) x) ↑↑x","decl":"lemma liftAlgEquiv_apply {E : IntermediateField K L} (F : IntermediateField K E) (x : F) :\n    (liftAlgEquiv F x).1 = x := rfl\n\n"}
{"name":"IntermediateField.coe_restrictScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field L'\ninst✝³ : Algebra K L\ninst✝² : Algebra K L'\ninst✝¹ : Algebra L' L\ninst✝ : IsScalarTower K L' L\nE : IntermediateField L' L\n⊢ Eq ↑(IntermediateField.restrictScalars K E) ↑E","decl":"@[simp]\ntheorem coe_restrictScalars {E : IntermediateField L' L} :\n    (restrictScalars K E : Set L) = (E : Set L) :=\n  rfl\n\n"}
{"name":"IntermediateField.restrictScalars_toSubalgebra","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field L'\ninst✝³ : Algebra K L\ninst✝² : Algebra K L'\ninst✝¹ : Algebra L' L\ninst✝ : IsScalarTower K L' L\nE : IntermediateField L' L\n⊢ Eq (IntermediateField.restrictScalars K E).toSubalgebra (Subalgebra.restrictScalars K E.toSubalgebra)","decl":"@[simp]\ntheorem restrictScalars_toSubalgebra {E : IntermediateField L' L} :\n    (E.restrictScalars K).toSubalgebra = E.toSubalgebra.restrictScalars K :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"IntermediateField.restrictScalars_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field L'\ninst✝³ : Algebra K L\ninst✝² : Algebra K L'\ninst✝¹ : Algebra L' L\ninst✝ : IsScalarTower K L' L\nE : IntermediateField L' L\n⊢ Eq (IntermediateField.restrictScalars K E).toSubfield E.toSubfield","decl":"@[simp]\ntheorem restrictScalars_toSubfield {E : IntermediateField L' L} :\n    (E.restrictScalars K).toSubfield = E.toSubfield :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"IntermediateField.mem_restrictScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field L'\ninst✝³ : Algebra K L\ninst✝² : Algebra K L'\ninst✝¹ : Algebra L' L\ninst✝ : IsScalarTower K L' L\nE : IntermediateField L' L\nx : L\n⊢ Iff (Membership.mem (IntermediateField.restrictScalars K E) x) (Membership.mem E x)","decl":"@[simp]\ntheorem mem_restrictScalars {E : IntermediateField L' L} {x : L} :\n    x ∈ restrictScalars K E ↔ x ∈ E :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.restrictScalars_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field L'\ninst✝³ : Algebra K L\ninst✝² : Algebra K L'\ninst✝¹ : Algebra L' L\ninst✝ : IsScalarTower K L' L\n⊢ Function.Injective (IntermediateField.restrictScalars K)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars K : IntermediateField L' L → IntermediateField K L) :=\n  fun U V H => ext fun x => by rw [← mem_restrictScalars K, H, mem_restrictScalars]\n\n"}
{"name":"Subfield.coe_extendScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E : Subfield L\nh : LE.le F E\n⊢ Eq ↑(Subfield.extendScalars h) ↑E","decl":"@[simp]\ntheorem coe_extendScalars : (extendScalars h : Set L) = (E : Set L) := rfl\n\n"}
{"name":"Subfield.extendScalars_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E : Subfield L\nh : LE.le F E\n⊢ Eq (Subfield.extendScalars h).toSubfield E","decl":"@[simp]\ntheorem extendScalars_toSubfield : (extendScalars h).toSubfield = E := SetLike.coe_injective rfl\n\n"}
{"name":"Subfield.mem_extendScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E : Subfield L\nh : LE.le F E\nx : L\n⊢ Iff (Membership.mem (Subfield.extendScalars h) x) (Membership.mem E x)","decl":"@[simp]\ntheorem mem_extendScalars : x ∈ extendScalars h ↔ x ∈ E := Iff.rfl\n\n"}
{"name":"Subfield.extendScalars_le_extendScalars_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E E' : Subfield L\nh : LE.le F E\nh' : LE.le F E'\n⊢ Iff (LE.le (Subfield.extendScalars h) (Subfield.extendScalars h')) (LE.le E E')","decl":"theorem extendScalars_le_extendScalars_iff : extendScalars h ≤ extendScalars h' ↔ E ≤ E' := Iff.rfl\n\n"}
{"name":"Subfield.extendScalars_le_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E : Subfield L\nh : LE.le F E\nE' : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Iff (LE.le (Subfield.extendScalars h) E') (LE.le E E'.toSubfield)","decl":"theorem extendScalars_le_iff (E' : IntermediateField F L) :\n    extendScalars h ≤ E' ↔ E ≤ E'.toSubfield := Iff.rfl\n\n"}
{"name":"Subfield.le_extendScalars_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF E : Subfield L\nh : LE.le F E\nE' : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Iff (LE.le E' (Subfield.extendScalars h)) (LE.le E'.toSubfield E)","decl":"theorem le_extendScalars_iff (E' : IntermediateField F L) :\n    E' ≤ extendScalars h ↔ E'.toSubfield ≤ E := Iff.rfl\n\n"}
{"name":"Subfield.extendScalars.orderIso_apply","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF : Subfield L\nE : Subtype fun E => LE.le F E\n⊢ Eq ((Subfield.extendScalars.orderIso F) E) (Subfield.extendScalars ⋯)","decl":"/-- `Subfield.extendScalars.orderIso` bundles `Subfield.extendScalars`\ninto an order isomorphism from\n`{ E : Subfield L // F ≤ E }` to `IntermediateField F L`. Its inverse is\n`IntermediateField.toSubfield`. -/\n@[simps]\ndef extendScalars.orderIso :\n    { E : Subfield L // F ≤ E } ≃o IntermediateField F L where\n  toFun E := extendScalars E.2\n  invFun E := ⟨E.toSubfield, fun x hx ↦ E.algebraMap_mem ⟨x, hx⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' {E E'} := by\n    simp only [Equiv.coe_fn_mk]\n    exact extendScalars_le_extendScalars_iff _ _\n\n"}
{"name":"Subfield.extendScalars.orderIso_symm_apply_coe","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF : Subfield L\nE : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Eq (↑((RelIso.symm (Subfield.extendScalars.orderIso F)) E)) E.toSubfield","decl":"/-- `Subfield.extendScalars.orderIso` bundles `Subfield.extendScalars`\ninto an order isomorphism from\n`{ E : Subfield L // F ≤ E }` to `IntermediateField F L`. Its inverse is\n`IntermediateField.toSubfield`. -/\n@[simps]\ndef extendScalars.orderIso :\n    { E : Subfield L // F ≤ E } ≃o IntermediateField F L where\n  toFun E := extendScalars E.2\n  invFun E := ⟨E.toSubfield, fun x hx ↦ E.algebraMap_mem ⟨x, hx⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' {E E'} := by\n    simp only [Equiv.coe_fn_mk]\n    exact extendScalars_le_extendScalars_iff _ _\n\n"}
{"name":"Subfield.extendScalars_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"L : Type u_2\ninst✝ : Field L\nF : Subfield L\n⊢ Function.Injective fun E => Subfield.extendScalars ⋯","decl":"theorem extendScalars_injective :\n    Function.Injective fun E : { E : Subfield L // F ≤ E } ↦ extendScalars E.2 :=\n  (extendScalars.orderIso F).injective\n\n"}
{"name":"IntermediateField.coe_extendScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\n⊢ Eq ↑(IntermediateField.extendScalars h) ↑E","decl":"@[simp]\ntheorem coe_extendScalars : (extendScalars h : Set L) = (E : Set L) := rfl\n\n"}
{"name":"IntermediateField.extendScalars_toSubfield","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\n⊢ Eq (IntermediateField.extendScalars h).toSubfield E.toSubfield","decl":"@[simp]\ntheorem extendScalars_toSubfield : (extendScalars h).toSubfield = E.toSubfield :=\n  SetLike.coe_injective rfl\n\n"}
{"name":"IntermediateField.mem_extendScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\nx : L\n⊢ Iff (Membership.mem (IntermediateField.extendScalars h) x) (Membership.mem E x)","decl":"@[simp]\ntheorem mem_extendScalars : x ∈ extendScalars h ↔ x ∈ E := Iff.rfl\n\n"}
{"name":"IntermediateField.extendScalars_restrictScalars","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\n⊢ Eq (IntermediateField.restrictScalars K (IntermediateField.extendScalars h)) E","decl":"@[simp]\ntheorem extendScalars_restrictScalars : (extendScalars h).restrictScalars K = E := rfl\n\n"}
{"name":"IntermediateField.extendScalars_le_extendScalars_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E E' : IntermediateField K L\nh : LE.le F E\nh' : LE.le F E'\n⊢ Iff (LE.le (IntermediateField.extendScalars h) (IntermediateField.extendScalars h')) (LE.le E E')","decl":"theorem extendScalars_le_extendScalars_iff : extendScalars h ≤ extendScalars h' ↔ E ≤ E' := Iff.rfl\n\n"}
{"name":"IntermediateField.extendScalars_le_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\nE' : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Iff (LE.le (IntermediateField.extendScalars h) E') (LE.le E (IntermediateField.restrictScalars K E'))","decl":"theorem extendScalars_le_iff (E' : IntermediateField F L) :\n    extendScalars h ≤ E' ↔ E ≤ E'.restrictScalars K := Iff.rfl\n\n"}
{"name":"IntermediateField.le_extendScalars_iff","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\nE' : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Iff (LE.le E' (IntermediateField.extendScalars h)) (LE.le (IntermediateField.restrictScalars K E') E)","decl":"theorem le_extendScalars_iff (E' : IntermediateField F L) :\n    E' ≤ extendScalars h ↔ E'.restrictScalars K ≤ E := Iff.rfl\n\n"}
{"name":"IntermediateField.extendScalars.orderIso_apply","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\nE : Subtype fun E => LE.le F E\n⊢ Eq ((IntermediateField.extendScalars.orderIso F) E) (IntermediateField.extendScalars ⋯)","decl":"/-- `IntermediateField.extendScalars.orderIso` bundles `IntermediateField.extendScalars`\ninto an order isomorphism from\n`{ E : IntermediateField K L // F ≤ E }` to `IntermediateField F L`. Its inverse is\n`IntermediateField.restrictScalars`. -/\n@[simps]\ndef extendScalars.orderIso : { E : IntermediateField K L // F ≤ E } ≃o IntermediateField F L where\n  toFun E := extendScalars E.2\n  invFun E := ⟨E.restrictScalars K, fun x hx ↦ E.algebraMap_mem ⟨x, hx⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' {E E'} := by\n    simp only [Equiv.coe_fn_mk]\n    exact extendScalars_le_extendScalars_iff _ _\n\n"}
{"name":"IntermediateField.extendScalars.orderIso_symm_apply_coe","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\nE : IntermediateField (Subtype fun x => Membership.mem F x) L\n⊢ Eq (↑((RelIso.symm (IntermediateField.extendScalars.orderIso F)) E)) (IntermediateField.restrictScalars K E)","decl":"/-- `IntermediateField.extendScalars.orderIso` bundles `IntermediateField.extendScalars`\ninto an order isomorphism from\n`{ E : IntermediateField K L // F ≤ E }` to `IntermediateField F L`. Its inverse is\n`IntermediateField.restrictScalars`. -/\n@[simps]\ndef extendScalars.orderIso : { E : IntermediateField K L // F ≤ E } ≃o IntermediateField F L where\n  toFun E := extendScalars E.2\n  invFun E := ⟨E.restrictScalars K, fun x hx ↦ E.algebraMap_mem ⟨x, hx⟩⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' {E E'} := by\n    simp only [Equiv.coe_fn_mk]\n    exact extendScalars_le_extendScalars_iff _ _\n\n"}
{"name":"IntermediateField.extendScalars_injective","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF : IntermediateField K L\n⊢ Function.Injective fun E => IntermediateField.extendScalars ⋯","decl":"theorem extendScalars_injective :\n    Function.Injective fun E : { E : IntermediateField K L // F ≤ E } ↦ extendScalars E.2 :=\n  (extendScalars.orderIso F).injective\n\n"}
{"name":"IntermediateField.mem_restrict","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\nx : Subtype fun x => Membership.mem E x\n⊢ Iff (Membership.mem (IntermediateField.restrict h) x) (Membership.mem F ↑x)","decl":"theorem mem_restrict (x : E) : x ∈ restrict h ↔ x.1 ∈ F :=\n  Set.ext_iff.mp (Set.range_inclusion h) x\n\n"}
{"name":"IntermediateField.lift_restrict","module":"Mathlib.FieldTheory.IntermediateField.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nF E : IntermediateField K L\nh : LE.le F E\n⊢ Eq (IntermediateField.lift (IntermediateField.restrict h)) F","decl":"@[simp]\ntheorem lift_restrict : lift (restrict h) = F := by\n  ext x\n  refine ⟨fun hx ↦ ?_, fun hx ↦ ?_⟩\n  · let y : E := ⟨x, lift_le (restrict h) hx⟩\n    exact (mem_restrict h y).1 ((mem_lift y).1 hx)\n  · let y : E := ⟨x, h hx⟩\n    exact (mem_lift y).2 ((mem_restrict h y).2 hx)\n\n"}
