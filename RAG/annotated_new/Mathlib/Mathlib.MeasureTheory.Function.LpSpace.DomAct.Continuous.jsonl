{"name":"MeasureTheory.Lp.instContinuousVAddDomAddAct","module":"Mathlib.MeasureTheory.Function.LpSpace.DomAct.Continuous","initialProofState":"X : Type u_1\nM : Type u_2\nE : Type u_3\ninst✝¹³ : TopologicalSpace X\ninst✝¹² : R1Space X\ninst✝¹¹ : MeasurableSpace X\ninst✝¹⁰ : BorelSpace X\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : MeasurableSpace M\ninst✝⁷ : OpensMeasurableSpace M\ninst✝⁶ : VAdd M X\ninst✝⁵ : ContinuousVAdd M X\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure X\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : μ.InnerRegularCompactLTTop\ninst✝¹ : MeasureTheory.VAddInvariantMeasure M X μ\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nhp : Fact (Ne p Top.top)\n⊢ ContinuousVAdd (DomAddAct M) (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"@[to_additive]\ninstance Lp.instContinuousSMulDomMulAct : ContinuousSMul Mᵈᵐᵃ (Lp E p μ) where\n  continuous_smul :=\n    let g : C(Mᵈᵐᵃ × Lp E p μ, C(X, X)) :=\n      (ContinuousMap.mk (fun a : M × X ↦ a.1 • a.2) continuous_smul).curry.comp <|\n        .comp (.mk DomMulAct.mk.symm) ContinuousMap.fst\n    continuous_snd.compMeasurePreservingLp g.continuous _ Fact.out\n\n"}
{"name":"MeasureTheory.Lp.instContinuousSMulDomMulAct","module":"Mathlib.MeasureTheory.Function.LpSpace.DomAct.Continuous","initialProofState":"X : Type u_1\nM : Type u_2\nE : Type u_3\ninst✝¹³ : TopologicalSpace X\ninst✝¹² : R1Space X\ninst✝¹¹ : MeasurableSpace X\ninst✝¹⁰ : BorelSpace X\ninst✝⁹ : TopologicalSpace M\ninst✝⁸ : MeasurableSpace M\ninst✝⁷ : OpensMeasurableSpace M\ninst✝⁶ : SMul M X\ninst✝⁵ : ContinuousSMul M X\ninst✝⁴ : NormedAddCommGroup E\nμ : MeasureTheory.Measure X\ninst✝³ : MeasureTheory.IsLocallyFiniteMeasure μ\ninst✝² : μ.InnerRegularCompactLTTop\ninst✝¹ : MeasureTheory.SMulInvariantMeasure M X μ\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nhp : Fact (Ne p Top.top)\n⊢ ContinuousSMul (DomMulAct M) (Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x)","decl":"@[to_additive]\ninstance Lp.instContinuousSMulDomMulAct : ContinuousSMul Mᵈᵐᵃ (Lp E p μ) where\n  continuous_smul :=\n    let g : C(Mᵈᵐᵃ × Lp E p μ, C(X, X)) :=\n      (ContinuousMap.mk (fun a : M × X ↦ a.1 • a.2) continuous_smul).curry.comp <|\n        .comp (.mk DomMulAct.mk.symm) ContinuousMap.fst\n    continuous_snd.compMeasurePreservingLp g.continuous _ Fact.out\n\n"}
