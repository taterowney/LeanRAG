{"name":"AddCommGroup.modEq_refl","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\n⊢ AddCommGroup.ModEq p a a","decl":"@[refl, simp]\ntheorem modEq_refl (a : α) : a ≡ a [PMOD p] :=\n  ⟨0, by simp⟩\n\n"}
{"name":"AddCommGroup.modEq_rfl","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\n⊢ AddCommGroup.ModEq p a a","decl":"theorem modEq_rfl : a ≡ a [PMOD p] :=\n  modEq_refl _\n\n"}
{"name":"AddCommGroup.modEq_comm","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p a b) (AddCommGroup.ModEq p b a)","decl":"theorem modEq_comm : a ≡ b [PMOD p] ↔ b ≡ a [PMOD p] :=\n  (Equiv.neg _).exists_congr_left.trans <| by simp [ModEq, ← neg_eq_iff_eq_neg]\n\n"}
{"name":"AddCommGroup.ModEq.symm","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p b a","decl":"alias ⟨ModEq.symm, _⟩ := modEq_comm\n\n"}
{"name":"AddCommGroup.ModEq.trans","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\na✝¹ : AddCommGroup.ModEq p a b\na✝ : AddCommGroup.ModEq p b c\n⊢ AddCommGroup.ModEq p a c","decl":"@[trans]\ntheorem ModEq.trans : a ≡ b [PMOD p] → b ≡ c [PMOD p] → a ≡ c [PMOD p] := fun ⟨m, hm⟩ ⟨n, hn⟩ =>\n  ⟨m + n, by simp [add_smul, ← hm, ← hn]⟩\n\n"}
{"name":"AddCommGroup.instIsReflModEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np : α\n⊢ IsRefl α (AddCommGroup.ModEq p)","decl":"instance : IsRefl _ (ModEq p) :=\n  ⟨modEq_refl⟩\n\n"}
{"name":"AddCommGroup.neg_modEq_neg","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p (Neg.neg a) (Neg.neg b)) (AddCommGroup.ModEq p a b)","decl":"@[simp]\ntheorem neg_modEq_neg : -a ≡ -b [PMOD p] ↔ a ≡ b [PMOD p] :=\n  modEq_comm.trans <| by simp [ModEq, neg_add_eq_sub]\n\n"}
{"name":"AddCommGroup.ModEq.of_neg","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\na✝ : AddCommGroup.ModEq p (Neg.neg a) (Neg.neg b)\n⊢ AddCommGroup.ModEq p a b","decl":"alias ⟨ModEq.of_neg, ModEq.neg⟩ := neg_modEq_neg\n\n"}
{"name":"AddCommGroup.ModEq.neg","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (Neg.neg a) (Neg.neg b)","decl":"alias ⟨ModEq.of_neg, ModEq.neg⟩ := neg_modEq_neg\n\n"}
{"name":"AddCommGroup.modEq_neg","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq (Neg.neg p) a b) (AddCommGroup.ModEq p a b)","decl":"@[simp]\ntheorem modEq_neg : a ≡ b [PMOD -p] ↔ a ≡ b [PMOD p] :=\n  modEq_comm.trans <| by simp [ModEq, ← neg_eq_iff_eq_neg]\n\n"}
{"name":"AddCommGroup.ModEq.neg'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq (Neg.neg p) a b","decl":"alias ⟨ModEq.of_neg', ModEq.neg'⟩ := modEq_neg\n\n"}
{"name":"AddCommGroup.ModEq.of_neg'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\na✝ : AddCommGroup.ModEq (Neg.neg p) a b\n⊢ AddCommGroup.ModEq p a b","decl":"alias ⟨ModEq.of_neg', ModEq.neg'⟩ := modEq_neg\n\n"}
{"name":"AddCommGroup.modEq_sub","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\na b : α\n⊢ AddCommGroup.ModEq (HSub.hSub b a) a b","decl":"theorem modEq_sub (a b : α) : a ≡ b [PMOD b - a] :=\n  ⟨1, (one_smul _ _).symm⟩\n\n"}
{"name":"AddCommGroup.modEq_zero","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\na b : α\n⊢ Iff (AddCommGroup.ModEq 0 a b) (Eq a b)","decl":"@[simp]\ntheorem modEq_zero : a ≡ b [PMOD 0] ↔ a = b := by simp [ModEq, sub_eq_zero, eq_comm]\n\n"}
{"name":"AddCommGroup.self_modEq_zero","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np : α\n⊢ AddCommGroup.ModEq p p 0","decl":"@[simp]\ntheorem self_modEq_zero : p ≡ 0 [PMOD p] :=\n  ⟨-1, by simp⟩\n\n"}
{"name":"AddCommGroup.zsmul_modEq_zero","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np : α\nz : Int\n⊢ AddCommGroup.ModEq p (HSMul.hSMul z p) 0","decl":"@[simp]\ntheorem zsmul_modEq_zero (z : ℤ) : z • p ≡ 0 [PMOD p] :=\n  ⟨-z, by simp⟩\n\n"}
{"name":"AddCommGroup.add_zsmul_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\nz : Int\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a (HSMul.hSMul z p)) a","decl":"theorem add_zsmul_modEq (z : ℤ) : a + z • p ≡ a [PMOD p] :=\n  ⟨-z, by simp⟩\n\n"}
{"name":"AddCommGroup.zsmul_add_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\nz : Int\n⊢ AddCommGroup.ModEq p (HAdd.hAdd (HSMul.hSMul z p) a) a","decl":"theorem zsmul_add_modEq (z : ℤ) : z • p + a ≡ a [PMOD p] :=\n  ⟨-z, by simp [← sub_sub]⟩\n\n"}
{"name":"AddCommGroup.add_nsmul_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\nn : Nat\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a (HSMul.hSMul n p)) a","decl":"theorem add_nsmul_modEq (n : ℕ) : a + n • p ≡ a [PMOD p] :=\n  ⟨-n, by simp⟩\n\n"}
{"name":"AddCommGroup.nsmul_add_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a : α\nn : Nat\n⊢ AddCommGroup.ModEq p (HAdd.hAdd (HSMul.hSMul n p) a) a","decl":"theorem nsmul_add_modEq (n : ℕ) : n • p + a ≡ a [PMOD p] :=\n  ⟨-n, by simp [← sub_sub]⟩\n\n"}
{"name":"AddCommGroup.ModEq.add_zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nz : Int\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a (HSMul.hSMul z p)) b","decl":"protected theorem add_zsmul (z : ℤ) : a ≡ b [PMOD p] → a + z • p ≡ b [PMOD p] :=\n  (add_zsmul_modEq _).trans\n\n"}
{"name":"AddCommGroup.ModEq.zsmul_add","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nz : Int\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd (HSMul.hSMul z p) a) b","decl":"protected theorem zsmul_add (z : ℤ) : a ≡ b [PMOD p] → z • p + a ≡ b [PMOD p] :=\n  (zsmul_add_modEq _).trans\n\n"}
{"name":"AddCommGroup.ModEq.add_nsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nn : Nat\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a (HSMul.hSMul n p)) b","decl":"protected theorem add_nsmul (n : ℕ) : a ≡ b [PMOD p] → a + n • p ≡ b [PMOD p] :=\n  (add_nsmul_modEq _).trans\n\n"}
{"name":"AddCommGroup.ModEq.nsmul_add","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nn : Nat\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd (HSMul.hSMul n p) a) b","decl":"protected theorem nsmul_add (n : ℕ) : a ≡ b [PMOD p] → n • p + a ≡ b [PMOD p] :=\n  (nsmul_add_modEq _).trans\n\n"}
{"name":"AddCommGroup.ModEq.of_zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nz : Int\na✝ : AddCommGroup.ModEq (HSMul.hSMul z p) a b\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem of_zsmul : a ≡ b [PMOD z • p] → a ≡ b [PMOD p] := fun ⟨m, hm⟩ =>\n  ⟨m * z, by rwa [mul_smul]⟩\n\n"}
{"name":"AddCommGroup.ModEq.of_nsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nn : Nat\na✝ : AddCommGroup.ModEq (HSMul.hSMul n p) a b\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem of_nsmul : a ≡ b [PMOD n • p] → a ≡ b [PMOD p] := fun ⟨m, hm⟩ =>\n  ⟨m * n, by rwa [mul_smul, natCast_zsmul]⟩\n\n"}
{"name":"AddCommGroup.ModEq.zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nz : Int\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq (HSMul.hSMul z p) (HSMul.hSMul z a) (HSMul.hSMul z b)","decl":"protected theorem zsmul : a ≡ b [PMOD p] → z • a ≡ z • b [PMOD z • p] :=\n  Exists.imp fun m hm => by rw [← smul_sub, hm, smul_comm]\n\n"}
{"name":"AddCommGroup.ModEq.nsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\nn : Nat\na✝ : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq (HSMul.hSMul n p) (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"protected theorem nsmul : a ≡ b [PMOD p] → n • a ≡ n • b [PMOD n • p] :=\n  Exists.imp fun m hm => by rw [← smul_sub, hm, smul_comm]\n\n"}
{"name":"AddCommGroup.zsmul_modEq_zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\np a b : α\nz : Int\ninst✝ : NoZeroSMulDivisors Int α\nhn : Ne z 0\n⊢ Iff (AddCommGroup.ModEq (HSMul.hSMul z p) (HSMul.hSMul z a) (HSMul.hSMul z b)) (AddCommGroup.ModEq p a b)","decl":"@[simp]\ntheorem zsmul_modEq_zsmul [NoZeroSMulDivisors ℤ α] (hn : z ≠ 0) :\n    z • a ≡ z • b [PMOD z • p] ↔ a ≡ b [PMOD p] :=\n  exists_congr fun m => by rw [← smul_sub, smul_comm, smul_right_inj hn]\n\n"}
{"name":"AddCommGroup.nsmul_modEq_nsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\np a b : α\nn : Nat\ninst✝ : NoZeroSMulDivisors Nat α\nhn : Ne n 0\n⊢ Iff (AddCommGroup.ModEq (HSMul.hSMul n p) (HSMul.hSMul n a) (HSMul.hSMul n b)) (AddCommGroup.ModEq p a b)","decl":"@[simp]\ntheorem nsmul_modEq_nsmul [NoZeroSMulDivisors ℕ α] (hn : n ≠ 0) :\n    n • a ≡ n • b [PMOD n • p] ↔ a ≡ b [PMOD p] :=\n  exists_congr fun m => by rw [← smul_sub, smul_comm, smul_right_inj hn]\n\n"}
{"name":"AddCommGroup.ModEq.zsmul_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\np a b : α\nz : Int\ninst✝ : NoZeroSMulDivisors Int α\nhn : Ne z 0\na✝ : AddCommGroup.ModEq (HSMul.hSMul z p) (HSMul.hSMul z a) (HSMul.hSMul z b)\n⊢ AddCommGroup.ModEq p a b","decl":"alias ⟨ModEq.zsmul_cancel, _⟩ := zsmul_modEq_zsmul\n\n"}
{"name":"AddCommGroup.ModEq.nsmul_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroup α\np a b : α\nn : Nat\ninst✝ : NoZeroSMulDivisors Nat α\nhn : Ne n 0\na✝ : AddCommGroup.ModEq (HSMul.hSMul n p) (HSMul.hSMul n a) (HSMul.hSMul n b)\n⊢ AddCommGroup.ModEq p a b","decl":"alias ⟨ModEq.nsmul_cancel, _⟩ := nsmul_modEq_nsmul\n\n"}
{"name":"AddCommGroup.ModEq.add_iff_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝ : AddCommGroup.ModEq p a₁ b₁\n⊢ Iff (AddCommGroup.ModEq p (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂)) (AddCommGroup.ModEq p a₂ b₂)","decl":"@[simp]\nprotected theorem add_iff_left :\n    a₁ ≡ b₁ [PMOD p] → (a₁ + a₂ ≡ b₁ + b₂ [PMOD p] ↔ a₂ ≡ b₂ [PMOD p]) := fun ⟨m, hm⟩ =>\n  (Equiv.addLeft m).symm.exists_congr_left.trans <| by simp [add_sub_add_comm, hm, add_smul, ModEq]\n\n"}
{"name":"AddCommGroup.ModEq.add_iff_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝ : AddCommGroup.ModEq p a₂ b₂\n⊢ Iff (AddCommGroup.ModEq p (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂)) (AddCommGroup.ModEq p a₁ b₁)","decl":"@[simp]\nprotected theorem add_iff_right :\n    a₂ ≡ b₂ [PMOD p] → (a₁ + a₂ ≡ b₁ + b₂ [PMOD p] ↔ a₁ ≡ b₁ [PMOD p]) := fun ⟨m, hm⟩ =>\n  (Equiv.addRight m).symm.exists_congr_left.trans <| by simp [add_sub_add_comm, hm, add_smul, ModEq]\n\n"}
{"name":"AddCommGroup.ModEq.sub_iff_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝ : AddCommGroup.ModEq p a₁ b₁\n⊢ Iff (AddCommGroup.ModEq p (HSub.hSub a₁ a₂) (HSub.hSub b₁ b₂)) (AddCommGroup.ModEq p a₂ b₂)","decl":"@[simp]\nprotected theorem sub_iff_left :\n    a₁ ≡ b₁ [PMOD p] → (a₁ - a₂ ≡ b₁ - b₂ [PMOD p] ↔ a₂ ≡ b₂ [PMOD p]) := fun ⟨m, hm⟩ =>\n  (Equiv.subLeft m).symm.exists_congr_left.trans <| by simp [sub_sub_sub_comm, hm, sub_smul, ModEq]\n\n"}
{"name":"AddCommGroup.ModEq.sub_iff_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝ : AddCommGroup.ModEq p a₂ b₂\n⊢ Iff (AddCommGroup.ModEq p (HSub.hSub a₁ a₂) (HSub.hSub b₁ b₂)) (AddCommGroup.ModEq p a₁ b₁)","decl":"@[simp]\nprotected theorem sub_iff_right :\n    a₂ ≡ b₂ [PMOD p] → (a₁ - a₂ ≡ b₁ - b₂ [PMOD p] ↔ a₁ ≡ b₁ [PMOD p]) := fun ⟨m, hm⟩ =>\n  (Equiv.subRight m).symm.exists_congr_left.trans <| by simp [sub_sub_sub_comm, hm, sub_smul, ModEq]\n\n"}
{"name":"AddCommGroup.ModEq.add_left_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₁ b₁\na✝ : AddCommGroup.ModEq p (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂)\n⊢ AddCommGroup.ModEq p a₂ b₂","decl":"protected alias ⟨add_left_cancel, add⟩ := ModEq.add_iff_left\n\n"}
{"name":"AddCommGroup.ModEq.add","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₁ b₁\na✝ : AddCommGroup.ModEq p a₂ b₂\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂)","decl":"protected alias ⟨add_left_cancel, add⟩ := ModEq.add_iff_left\n\n"}
{"name":"AddCommGroup.ModEq.add_right_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₂ b₂\na✝ : AddCommGroup.ModEq p (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂)\n⊢ AddCommGroup.ModEq p a₁ b₁","decl":"protected alias ⟨add_right_cancel, _⟩ := ModEq.add_iff_right\n\n"}
{"name":"AddCommGroup.ModEq.sub","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₁ b₁\na✝ : AddCommGroup.ModEq p a₂ b₂\n⊢ AddCommGroup.ModEq p (HSub.hSub a₁ a₂) (HSub.hSub b₁ b₂)","decl":"protected alias ⟨sub_left_cancel, sub⟩ := ModEq.sub_iff_left\n\n"}
{"name":"AddCommGroup.ModEq.sub_left_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₁ b₁\na✝ : AddCommGroup.ModEq p (HSub.hSub a₁ a₂) (HSub.hSub b₁ b₂)\n⊢ AddCommGroup.ModEq p a₂ b₂","decl":"protected alias ⟨sub_left_cancel, sub⟩ := ModEq.sub_iff_left\n\n"}
{"name":"AddCommGroup.ModEq.sub_right_cancel","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a₁ a₂ b₁ b₂ : α\na✝¹ : AddCommGroup.ModEq p a₂ b₂\na✝ : AddCommGroup.ModEq p (HSub.hSub a₁ a₂) (HSub.hSub b₁ b₂)\n⊢ AddCommGroup.ModEq p a₁ b₁","decl":"protected alias ⟨sub_right_cancel, _⟩ := ModEq.sub_iff_right\n\n"}
{"name":"AddCommGroup.ModEq.add_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\nh : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd c a) (HAdd.hAdd c b)","decl":"protected theorem add_left (c : α) (h : a ≡ b [PMOD p]) : c + a ≡ c + b [PMOD p] :=\n  modEq_rfl.add h\n\n"}
{"name":"AddCommGroup.ModEq.sub_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\nh : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HSub.hSub c a) (HSub.hSub c b)","decl":"protected theorem sub_left (c : α) (h : a ≡ b [PMOD p]) : c - a ≡ c - b [PMOD p] :=\n  modEq_rfl.sub h\n\n"}
{"name":"AddCommGroup.ModEq.add_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\nh : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HAdd.hAdd a c) (HAdd.hAdd b c)","decl":"protected theorem add_right (c : α) (h : a ≡ b [PMOD p]) : a + c ≡ b + c [PMOD p] :=\n  h.add modEq_rfl\n\n"}
{"name":"AddCommGroup.ModEq.sub_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\nh : AddCommGroup.ModEq p a b\n⊢ AddCommGroup.ModEq p (HSub.hSub a c) (HSub.hSub b c)","decl":"protected theorem sub_right (c : α) (h : a ≡ b [PMOD p]) : a - c ≡ b - c [PMOD p] :=\n  h.sub modEq_rfl\n\n"}
{"name":"AddCommGroup.ModEq.add_left_cancel'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\na✝ : AddCommGroup.ModEq p (HAdd.hAdd c a) (HAdd.hAdd c b)\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem add_left_cancel' (c : α) : c + a ≡ c + b [PMOD p] → a ≡ b [PMOD p] :=\n  modEq_rfl.add_left_cancel\n\n"}
{"name":"AddCommGroup.ModEq.add_right_cancel'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\na✝ : AddCommGroup.ModEq p (HAdd.hAdd a c) (HAdd.hAdd b c)\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem add_right_cancel' (c : α) : a + c ≡ b + c [PMOD p] → a ≡ b [PMOD p] :=\n  modEq_rfl.add_right_cancel\n\n"}
{"name":"AddCommGroup.ModEq.sub_left_cancel'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\na✝ : AddCommGroup.ModEq p (HSub.hSub c a) (HSub.hSub c b)\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem sub_left_cancel' (c : α) : c - a ≡ c - b [PMOD p] → a ≡ b [PMOD p] :=\n  modEq_rfl.sub_left_cancel\n\n"}
{"name":"AddCommGroup.ModEq.sub_right_cancel'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\na✝ : AddCommGroup.ModEq p (HSub.hSub a c) (HSub.hSub b c)\n⊢ AddCommGroup.ModEq p a b","decl":"protected theorem sub_right_cancel' (c : α) : a - c ≡ b - c [PMOD p] → a ≡ b [PMOD p] :=\n  modEq_rfl.sub_right_cancel\n\n"}
{"name":"AddCommGroup.modEq_sub_iff_add_modEq'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\n⊢ Iff (AddCommGroup.ModEq p a (HSub.hSub b c)) (AddCommGroup.ModEq p (HAdd.hAdd c a) b)","decl":"theorem modEq_sub_iff_add_modEq' : a ≡ b - c [PMOD p] ↔ c + a ≡ b [PMOD p] := by\n  simp [ModEq, sub_sub]\n\n"}
{"name":"AddCommGroup.modEq_sub_iff_add_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\n⊢ Iff (AddCommGroup.ModEq p a (HSub.hSub b c)) (AddCommGroup.ModEq p (HAdd.hAdd a c) b)","decl":"theorem modEq_sub_iff_add_modEq : a ≡ b - c [PMOD p] ↔ a + c ≡ b [PMOD p] :=\n  modEq_sub_iff_add_modEq'.trans <| by rw [add_comm]\n\n"}
{"name":"AddCommGroup.sub_modEq_iff_modEq_add'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\n⊢ Iff (AddCommGroup.ModEq p (HSub.hSub a b) c) (AddCommGroup.ModEq p a (HAdd.hAdd b c))","decl":"theorem sub_modEq_iff_modEq_add' : a - b ≡ c [PMOD p] ↔ a ≡ b + c [PMOD p] :=\n  modEq_comm.trans <| modEq_sub_iff_add_modEq'.trans modEq_comm\n\n"}
{"name":"AddCommGroup.sub_modEq_iff_modEq_add","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b c : α\n⊢ Iff (AddCommGroup.ModEq p (HSub.hSub a b) c) (AddCommGroup.ModEq p a (HAdd.hAdd c b))","decl":"theorem sub_modEq_iff_modEq_add : a - b ≡ c [PMOD p] ↔ a ≡ c + b [PMOD p] :=\n  modEq_comm.trans <| modEq_sub_iff_add_modEq.trans modEq_comm\n\n"}
{"name":"AddCommGroup.sub_modEq_zero","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p (HSub.hSub a b) 0) (AddCommGroup.ModEq p a b)","decl":"@[simp]\ntheorem sub_modEq_zero : a - b ≡ 0 [PMOD p] ↔ a ≡ b [PMOD p] := by simp [sub_modEq_iff_modEq_add]\n\n"}
{"name":"AddCommGroup.add_modEq_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p (HAdd.hAdd a b) a) (AddCommGroup.ModEq p b 0)","decl":"@[simp]\ntheorem add_modEq_left : a + b ≡ a [PMOD p] ↔ b ≡ 0 [PMOD p] := by simp [← modEq_sub_iff_add_modEq']\n\n"}
{"name":"AddCommGroup.add_modEq_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p (HAdd.hAdd a b) b) (AddCommGroup.ModEq p a 0)","decl":"@[simp]\ntheorem add_modEq_right : a + b ≡ b [PMOD p] ↔ a ≡ 0 [PMOD p] := by simp [← modEq_sub_iff_add_modEq]\n\n"}
{"name":"AddCommGroup.modEq_iff_eq_add_zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p a b) (Exists fun z => Eq b (HAdd.hAdd a (HSMul.hSMul z p)))","decl":"theorem modEq_iff_eq_add_zsmul : a ≡ b [PMOD p] ↔ ∃ z : ℤ, b = a + z • p := by\n  simp_rw [ModEq, sub_eq_iff_eq_add']\n\n"}
{"name":"AddCommGroup.not_modEq_iff_ne_add_zsmul","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (Not (AddCommGroup.ModEq p a b)) (∀ (z : Int), Ne b (HAdd.hAdd a (HSMul.hSMul z p)))","decl":"theorem not_modEq_iff_ne_add_zsmul : ¬a ≡ b [PMOD p] ↔ ∀ z : ℤ, b ≠ a + z • p := by\n  rw [modEq_iff_eq_add_zsmul, not_exists]\n\n"}
{"name":"AddCommGroup.modEq_iff_eq_mod_zmultiples","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (AddCommGroup.ModEq p a b) (Eq ↑b ↑a)","decl":"theorem modEq_iff_eq_mod_zmultiples : a ≡ b [PMOD p] ↔ (b : α ⧸ AddSubgroup.zmultiples p) = a := by\n  simp_rw [modEq_iff_eq_add_zsmul, QuotientAddGroup.eq_iff_sub_mem, AddSubgroup.mem_zmultiples_iff,\n    eq_sub_iff_add_eq', eq_comm]\n\n"}
{"name":"AddCommGroup.not_modEq_iff_ne_mod_zmultiples","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : AddCommGroup α\np a b : α\n⊢ Iff (Not (AddCommGroup.ModEq p a b)) (Ne ↑b ↑a)","decl":"theorem not_modEq_iff_ne_mod_zmultiples :\n    ¬a ≡ b [PMOD p] ↔ (b : α ⧸ AddSubgroup.zmultiples p) ≠ a :=\n  modEq_iff_eq_mod_zmultiples.not\n\n"}
{"name":"AddCommGroup.modEq_iff_int_modEq","module":"Mathlib.Algebra.ModEq","initialProofState":"a b z : Int\n⊢ Iff (AddCommGroup.ModEq z a b) (z.ModEq a b)","decl":"@[simp]\ntheorem modEq_iff_int_modEq {a b z : ℤ} : a ≡ b [PMOD z] ↔ a ≡ b [ZMOD z] := by\n  simp [ModEq, dvd_iff_exists_eq_mul_left, Int.modEq_iff_dvd]\n\n"}
{"name":"AddCommGroup.intCast_modEq_intCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b z : Int\n⊢ Iff (AddCommGroup.ModEq ↑z ↑a ↑b) (AddCommGroup.ModEq z a b)","decl":"@[simp, norm_cast]\ntheorem intCast_modEq_intCast {a b z : ℤ} : a ≡ b [PMOD (z : α)] ↔ a ≡ b [PMOD z] := by\n  simp_rw [ModEq, ← Int.cast_mul_eq_zsmul_cast]\n  norm_cast\n\n"}
{"name":"AddCommGroup.intCast_modEq_intCast'","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b : Int\nn : Nat\n⊢ Iff (AddCommGroup.ModEq ↑n ↑a ↑b) (AddCommGroup.ModEq (↑n) a b)","decl":"@[simp, norm_cast]\nlemma intCast_modEq_intCast' {a b : ℤ} {n : ℕ} : a ≡ b [PMOD (n : α)] ↔ a ≡ b [PMOD (n : ℤ)] := by\n  simpa using intCast_modEq_intCast (α := α) (z := n)\n\n"}
{"name":"AddCommGroup.natCast_modEq_natCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b n : Nat\n⊢ Iff (AddCommGroup.ModEq ↑n ↑a ↑b) (n.ModEq a b)","decl":"@[simp, norm_cast]\ntheorem natCast_modEq_natCast {a b n : ℕ} : a ≡ b [PMOD (n : α)] ↔ a ≡ b [MOD n] := by\n  simp_rw [← Int.natCast_modEq_iff, ← modEq_iff_int_modEq, ← @intCast_modEq_intCast α,\n    Int.cast_natCast]\n\n"}
{"name":"AddCommGroup.ModEq.intCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b z : Int\na✝ : AddCommGroup.ModEq z a b\n⊢ AddCommGroup.ModEq ↑z ↑a ↑b","decl":"alias ⟨ModEq.of_intCast, ModEq.intCast⟩ := intCast_modEq_intCast\n\n"}
{"name":"AddCommGroup.ModEq.of_intCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b z : Int\na✝ : AddCommGroup.ModEq ↑z ↑a ↑b\n⊢ AddCommGroup.ModEq z a b","decl":"alias ⟨ModEq.of_intCast, ModEq.intCast⟩ := intCast_modEq_intCast\n\n"}
{"name":"Nat.ModEq.of_natCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b n : Nat\na✝ : AddCommGroup.ModEq ↑n ↑a ↑b\n⊢ n.ModEq a b","decl":"alias ⟨_root_.Nat.ModEq.of_natCast, ModEq.natCast⟩ := natCast_modEq_natCast\n\n"}
{"name":"AddCommGroup.ModEq.natCast","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝¹ : AddCommGroupWithOne α\ninst✝ : CharZero α\na b n : Nat\na✝ : n.ModEq a b\n⊢ AddCommGroup.ModEq ↑n ↑a ↑b","decl":"alias ⟨_root_.Nat.ModEq.of_natCast, ModEq.natCast⟩ := natCast_modEq_natCast\n\n"}
{"name":"AddCommGroup.div_modEq_div","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\na b c p : α\nhc : Ne c 0\n⊢ Iff (AddCommGroup.ModEq p (HDiv.hDiv a c) (HDiv.hDiv b c)) (AddCommGroup.ModEq (HMul.hMul p c) a b)","decl":"@[simp] lemma div_modEq_div (hc : c ≠ 0) : a / c ≡ b / c [PMOD p] ↔ a ≡ b [PMOD (p * c)] := by\n  simp [ModEq, ← sub_div, div_eq_iff hc, mul_assoc]\n\n"}
{"name":"AddCommGroup.mul_modEq_mul_right","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : DivisionRing α\na b c p : α\nhc : Ne c 0\n⊢ Iff (AddCommGroup.ModEq p (HMul.hMul a c) (HMul.hMul b c)) (AddCommGroup.ModEq (HDiv.hDiv p c) a b)","decl":"@[simp] lemma mul_modEq_mul_right (hc : c ≠ 0) : a * c ≡ b * c [PMOD p] ↔ a ≡ b [PMOD (p / c)] := by\n  rw [div_eq_mul_inv, ← div_modEq_div (inv_ne_zero hc), div_inv_eq_mul, div_inv_eq_mul]\n\n"}
{"name":"AddCommGroup.mul_modEq_mul_left","module":"Mathlib.Algebra.ModEq","initialProofState":"α : Type u_1\ninst✝ : Field α\na b c p : α\nhc : Ne c 0\n⊢ Iff (AddCommGroup.ModEq p (HMul.hMul c a) (HMul.hMul c b)) (AddCommGroup.ModEq (HDiv.hDiv p c) a b)","decl":"@[simp] lemma mul_modEq_mul_left (hc : c ≠ 0) : c * a ≡ c * b [PMOD p] ↔ a ≡ b [PMOD (p / c)] := by\n  simp [mul_comm c, hc]\n\n"}
