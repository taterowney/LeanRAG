{"name":"Fin.map_valEmbedding_univ","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\n⊢ Eq (Finset.map Fin.valEmbedding Finset.univ) (Finset.Iio n)","decl":"theorem map_valEmbedding_univ : (Finset.univ : Finset (Fin n)).map Fin.valEmbedding = Iio n := by\n  ext\n  simp [orderIsoSubtype.symm.surjective.exists, OrderIso.symm]\n\n"}
{"name":"Fin.Ioi_zero_eq_map","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\n⊢ Eq (Finset.Ioi 0) (Finset.map (Fin.succEmb n) Finset.univ)","decl":"@[simp]\ntheorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmb _) :=\n  coe_injective <| by ext; simp [pos_iff_ne_zero]\n\n"}
{"name":"Fin.Iio_last_eq_map","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\n⊢ Eq (Finset.Iio (Fin.last n)) (Finset.map Fin.castSuccEmb Finset.univ)","decl":"@[simp]\ntheorem Iio_last_eq_map : Iio (Fin.last n) = Finset.univ.map Fin.castSuccEmb :=\n  coe_injective <| by ext; simp [lt_def]\n\n"}
{"name":"Fin.Ioi_succ","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Finset.Ioi i.succ) (Finset.map (Fin.succEmb n) (Finset.Ioi i))","decl":"@[simp]\ntheorem Ioi_succ (i : Fin n) : Ioi i.succ = (Ioi i).map (Fin.succEmb _) := by\n  ext i\n  simp only [mem_filter, mem_Ioi, mem_map, mem_univ, Function.Embedding.coeFn_mk, exists_true_left]\n  constructor\n  · refine cases ?_ ?_ i\n    · rintro ⟨⟨⟩⟩\n    · intro i hi\n      exact ⟨i, succ_lt_succ_iff.mp hi, rfl⟩\n  · rintro ⟨i, hi, rfl⟩\n    simpa\n\n"}
{"name":"Fin.Iio_castSucc","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (Finset.Iio i.castSucc) (Finset.map Fin.castSuccEmb (Finset.Iio i))","decl":"@[simp]\ntheorem Iio_castSucc (i : Fin n) : Iio (castSucc i) = (Iio i).map Fin.castSuccEmb := by\n  apply Finset.map_injective Fin.valEmbedding\n  rw [Finset.map_map, Fin.map_valEmbedding_Iio]\n  exact (Fin.map_valEmbedding_Iio i).symm\n\n"}
{"name":"Fin.card_filter_univ_succ","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1) → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter (fun x => p x) Finset.univ).card (ite (p 0) (HAdd.hAdd (Finset.filter (fun x => p x.succ) Finset.univ).card 1) (Finset.filter (fun x => p x.succ) Finset.univ).card)","decl":"theorem card_filter_univ_succ (p : Fin (n + 1) → Prop) [DecidablePred p] :\n    #{x | p x} = if p 0 then #{x | p (.succ x)} + 1 else #{x | p (.succ x)} := by\n  rw [Fin.univ_succ, filter_cons, apply_ite Finset.card, card_cons, filter_map, card_map]; rfl\n\n"}
{"name":"Fin.card_filter_univ_succ'","module":"Mathlib.Data.Fintype.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1) → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter (fun x => p x) Finset.univ).card (HAdd.hAdd (ite (p 0) 1 0) (Finset.filter (fun x => p x.succ) Finset.univ).card)","decl":"theorem card_filter_univ_succ' (p : Fin (n + 1) → Prop) [DecidablePred p] :\n    #{x | p x} = ite (p 0) 1 0 + #{x | p (.succ x)}:= by\n  rw [card_filter_univ_succ]; split_ifs <;> simp [add_comm]\n\n"}
{"name":"Fin.card_filter_univ_eq_vector_get_eq_count","module":"Mathlib.Data.Fintype.Fin","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : DecidableEq α\na : α\nv : List.Vector α n\n⊢ Eq (Finset.filter (fun i => Eq (v.get i) a) Finset.univ).card (List.count a v.toList)","decl":"theorem card_filter_univ_eq_vector_get_eq_count [DecidableEq α] (a : α) (v : List.Vector α n) :\n    #{i | v.get i = a} = v.toList.count a := by\n  induction' v with n x xs hxs\n  · simp\n  · simp_rw [card_filter_univ_succ', Vector.get_cons_zero, Vector.toList_cons, Vector.get_cons_succ,\n      hxs, List.count_cons, add_comm (ite (x = a) 1 0), beq_iff_eq]\n\n"}
