{"name":"Matrix.isDiag_diagonal","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Zero α\ninst✝ : DecidableEq n\nd : n → α\n⊢ (Matrix.diagonal d).IsDiag","decl":"@[simp]\ntheorem isDiag_diagonal [Zero α] [DecidableEq n] (d : n → α) : (diagonal d).IsDiag := fun _ _ =>\n  Matrix.diagonal_apply_ne _\n\n"}
{"name":"Matrix.IsDiag.diagonal_diag","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Zero α\ninst✝ : DecidableEq n\nA : Matrix n n α\nh : A.IsDiag\n⊢ Eq (Matrix.diagonal A.diag) A","decl":"/-- Diagonal matrices are generated by the `Matrix.diagonal` of their `Matrix.diag`. -/\ntheorem IsDiag.diagonal_diag [Zero α] [DecidableEq n] {A : Matrix n n α} (h : A.IsDiag) :\n    diagonal (diag A) = A :=\n  ext fun i j => by\n    obtain rfl | hij := Decidable.eq_or_ne i j\n    · rw [diagonal_apply_eq, diag]\n    · rw [diagonal_apply_ne _ hij, h hij]\n\n"}
{"name":"Matrix.isDiag_iff_diagonal_diag","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Zero α\ninst✝ : DecidableEq n\nA : Matrix n n α\n⊢ Iff A.IsDiag (Eq (Matrix.diagonal A.diag) A)","decl":"/-- `Matrix.IsDiag.diagonal_diag` as an iff. -/\ntheorem isDiag_iff_diagonal_diag [Zero α] [DecidableEq n] (A : Matrix n n α) :\n    A.IsDiag ↔ diagonal (diag A) = A :=\n  ⟨IsDiag.diagonal_diag, fun hd => hd ▸ isDiag_diagonal (diag A)⟩\n\n"}
{"name":"Matrix.isDiag_of_subsingleton","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Zero α\ninst✝ : Subsingleton n\nA : Matrix n n α\n⊢ A.IsDiag","decl":"/-- Every matrix indexed by a subsingleton is diagonal. -/\ntheorem isDiag_of_subsingleton [Zero α] [Subsingleton n] (A : Matrix n n α) : A.IsDiag :=\n  fun i j h => (h <| Subsingleton.elim i j).elim\n\n"}
{"name":"Matrix.isDiag_zero","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Zero α\n⊢ Matrix.IsDiag 0","decl":"/-- Every zero matrix is diagonal. -/\n@[simp]\ntheorem isDiag_zero [Zero α] : (0 : Matrix n n α).IsDiag := fun _ _ _ => rfl\n\n"}
{"name":"Matrix.isDiag_one","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Zero α\ninst✝ : One α\n⊢ Matrix.IsDiag 1","decl":"/-- Every identity matrix is diagonal. -/\n@[simp]\ntheorem isDiag_one [DecidableEq n] [Zero α] [One α] : (1 : Matrix n n α).IsDiag := fun _ _ =>\n  one_apply_ne\n\n"}
{"name":"Matrix.IsDiag.map","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Type u_4\ninst✝¹ : Zero α\ninst✝ : Zero β\nA : Matrix n n α\nha : A.IsDiag\nf : α → β\nhf : Eq (f 0) 0\n⊢ (A.map f).IsDiag","decl":"theorem IsDiag.map [Zero α] [Zero β] {A : Matrix n n α} (ha : A.IsDiag) {f : α → β} (hf : f 0 = 0) :\n    (A.map f).IsDiag := by\n  intro i j h\n  simp [ha h, hf]\n\n"}
{"name":"Matrix.IsDiag.neg","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : AddGroup α\nA : Matrix n n α\nha : A.IsDiag\n⊢ (Neg.neg A).IsDiag","decl":"theorem IsDiag.neg [AddGroup α] {A : Matrix n n α} (ha : A.IsDiag) : (-A).IsDiag := by\n  intro i j h\n  simp [ha h]\n\n"}
{"name":"Matrix.isDiag_neg_iff","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : AddGroup α\nA : Matrix n n α\n⊢ Iff (Neg.neg A).IsDiag A.IsDiag","decl":"@[simp]\ntheorem isDiag_neg_iff [AddGroup α] {A : Matrix n n α} : (-A).IsDiag ↔ A.IsDiag :=\n  ⟨fun ha _ _ h => neg_eq_zero.1 (ha h), IsDiag.neg⟩\n\n"}
{"name":"Matrix.IsDiag.add","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : AddZeroClass α\nA B : Matrix n n α\nha : A.IsDiag\nhb : B.IsDiag\n⊢ (HAdd.hAdd A B).IsDiag","decl":"theorem IsDiag.add [AddZeroClass α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A + B).IsDiag := by\n  intro i j h\n  simp [ha h, hb h]\n\n"}
{"name":"Matrix.IsDiag.sub","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : AddGroup α\nA B : Matrix n n α\nha : A.IsDiag\nhb : B.IsDiag\n⊢ (HSub.hSub A B).IsDiag","decl":"theorem IsDiag.sub [AddGroup α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) :\n    (A - B).IsDiag := by\n  intro i j h\n  simp [ha h, hb h]\n\n"}
{"name":"Matrix.IsDiag.smul","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nR : Type u_3\nn : Type u_4\ninst✝² : Monoid R\ninst✝¹ : AddMonoid α\ninst✝ : DistribMulAction R α\nk : R\nA : Matrix n n α\nha : A.IsDiag\n⊢ (HSMul.hSMul k A).IsDiag","decl":"theorem IsDiag.smul [Monoid R] [AddMonoid α] [DistribMulAction R α] (k : R) {A : Matrix n n α}\n    (ha : A.IsDiag) : (k • A).IsDiag := by\n  intro i j h\n  simp [ha h]\n\n"}
{"name":"Matrix.isDiag_smul_one","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_6\ninst✝¹ : Semiring α\ninst✝ : DecidableEq n\nk : α\n⊢ (HSMul.hSMul k 1).IsDiag","decl":"@[simp]\ntheorem isDiag_smul_one (n) [Semiring α] [DecidableEq n] (k : α) :\n    (k • (1 : Matrix n n α)).IsDiag :=\n  isDiag_one.smul k\n\n"}
{"name":"Matrix.IsDiag.transpose","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Zero α\nA : Matrix n n α\nha : A.IsDiag\n⊢ A.transpose.IsDiag","decl":"theorem IsDiag.transpose [Zero α] {A : Matrix n n α} (ha : A.IsDiag) : Aᵀ.IsDiag := fun _ _ h =>\n  ha h.symm\n\n"}
{"name":"Matrix.isDiag_transpose_iff","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Zero α\nA : Matrix n n α\n⊢ Iff A.transpose.IsDiag A.IsDiag","decl":"@[simp]\ntheorem isDiag_transpose_iff [Zero α] {A : Matrix n n α} : Aᵀ.IsDiag ↔ A.IsDiag :=\n  ⟨IsDiag.transpose, IsDiag.transpose⟩\n\n"}
{"name":"Matrix.IsDiag.conjTranspose","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nA : Matrix n n α\nha : A.IsDiag\n⊢ A.conjTranspose.IsDiag","decl":"theorem IsDiag.conjTranspose [Semiring α] [StarRing α] {A : Matrix n n α} (ha : A.IsDiag) :\n    Aᴴ.IsDiag :=\n  ha.transpose.map (star_zero _)\n\n"}
{"name":"Matrix.isDiag_conjTranspose_iff","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝¹ : Semiring α\ninst✝ : StarRing α\nA : Matrix n n α\n⊢ Iff A.conjTranspose.IsDiag A.IsDiag","decl":"@[simp]\ntheorem isDiag_conjTranspose_iff [Semiring α] [StarRing α] {A : Matrix n n α} :\n    Aᴴ.IsDiag ↔ A.IsDiag :=\n  ⟨fun ha => by\n    convert ha.conjTranspose\n    simp, IsDiag.conjTranspose⟩\n\n"}
{"name":"Matrix.IsDiag.submatrix","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝ : Zero α\nA : Matrix n n α\nha : A.IsDiag\nf : m → n\nhf : Function.Injective f\n⊢ (A.submatrix f f).IsDiag","decl":"theorem IsDiag.submatrix [Zero α] {A : Matrix n n α} (ha : A.IsDiag) {f : m → n}\n    (hf : Injective f) : (A.submatrix f f).IsDiag := fun _ _ h => ha (hf.ne h)\n\n"}
{"name":"Matrix.IsDiag.kronecker","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝ : MulZeroClass α\nA : Matrix m m α\nB : Matrix n n α\nhA : A.IsDiag\nhB : B.IsDiag\n⊢ (Matrix.kroneckerMap (fun x1 x2 => HMul.hMul x1 x2) A B).IsDiag","decl":"/-- `(A ⊗ B).IsDiag` if both `A` and `B` are diagonal. -/\ntheorem IsDiag.kronecker [MulZeroClass α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.IsDiag)\n    (hB : B.IsDiag) : (A ⊗ₖ B).IsDiag := by\n  rintro ⟨a, b⟩ ⟨c, d⟩ h\n  simp only [Prod.mk.inj_iff, Ne, not_and_or] at h\n  cases' h with hac hbd\n  · simp [hA hac]\n  · simp [hB hbd]\n\n"}
{"name":"Matrix.IsDiag.isSymm","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\ninst✝ : Zero α\nA : Matrix n n α\nh : A.IsDiag\n⊢ A.IsSymm","decl":"theorem IsDiag.isSymm [Zero α] {A : Matrix n n α} (h : A.IsDiag) : A.IsSymm := by\n  ext i j\n  by_cases g : i = j; · rw [g, transpose_apply]\n  simp [h g, h (Ne.symm g)]\n\n"}
{"name":"Matrix.IsDiag.fromBlocks","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝ : Zero α\nA : Matrix m m α\nD : Matrix n n α\nha : A.IsDiag\nhd : D.IsDiag\n⊢ (Matrix.fromBlocks A 0 0 D).IsDiag","decl":"/-- The block matrix `A.fromBlocks 0 0 D` is diagonal if `A` and `D` are diagonal. -/\ntheorem IsDiag.fromBlocks [Zero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.IsDiag)\n    (hd : D.IsDiag) : (A.fromBlocks 0 0 D).IsDiag := by\n  rintro (i | i) (j | j) hij\n  · exact ha (ne_of_apply_ne _ hij)\n  · rfl\n  · rfl\n  · exact hd (ne_of_apply_ne _ hij)\n\n"}
{"name":"Matrix.isDiag_fromBlocks_iff","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝ : Zero α\nA : Matrix m m α\nB : Matrix m n α\nC : Matrix n m α\nD : Matrix n n α\n⊢ Iff (Matrix.fromBlocks A B C D).IsDiag (And A.IsDiag (And (Eq B 0) (And (Eq C 0) D.IsDiag)))","decl":"/-- This is the `iff` version of `Matrix.IsDiag.fromBlocks`. -/\ntheorem isDiag_fromBlocks_iff [Zero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α}\n    {D : Matrix n n α} : (A.fromBlocks B C D).IsDiag ↔ A.IsDiag ∧ B = 0 ∧ C = 0 ∧ D.IsDiag := by\n  constructor\n  · intro h\n    refine ⟨fun i j hij => ?_, ext fun i j => ?_, ext fun i j => ?_, fun i j hij => ?_⟩\n    · exact h (Sum.inl_injective.ne hij)\n    · exact h Sum.inl_ne_inr\n    · exact h Sum.inr_ne_inl\n    · exact h (Sum.inr_injective.ne hij)\n  · rintro ⟨ha, hb, hc, hd⟩\n    convert IsDiag.fromBlocks ha hd\n\n"}
{"name":"Matrix.IsDiag.fromBlocks_of_isSymm","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝ : Zero α\nA : Matrix m m α\nC : Matrix n m α\nD : Matrix n n α\nh : (Matrix.fromBlocks A 0 C D).IsSymm\nha : A.IsDiag\nhd : D.IsDiag\n⊢ (Matrix.fromBlocks A 0 C D).IsDiag","decl":"/-- A symmetric block matrix `A.fromBlocks B C D` is diagonal\n    if `A` and `D` are diagonal and `B` is `0`. -/\ntheorem IsDiag.fromBlocks_of_isSymm [Zero α] {A : Matrix m m α} {C : Matrix n m α}\n    {D : Matrix n n α} (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) :\n    (A.fromBlocks 0 C D).IsDiag := by\n  rw [← (isSymm_fromBlocks_iff.1 h).2.1]\n  exact ha.fromBlocks hd\n\n"}
{"name":"Matrix.mul_transpose_self_isDiag_iff_hasOrthogonalRows","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝² : Fintype n\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nA : Matrix m n α\n⊢ Iff (HMul.hMul A A.transpose).IsDiag A.HasOrthogonalRows","decl":"theorem mul_transpose_self_isDiag_iff_hasOrthogonalRows [Fintype n] [Mul α] [AddCommMonoid α]\n    {A : Matrix m n α} : (A * Aᵀ).IsDiag ↔ A.HasOrthogonalRows :=\n  Iff.rfl\n\n"}
{"name":"Matrix.transpose_mul_self_isDiag_iff_hasOrthogonalCols","module":"Mathlib.LinearAlgebra.Matrix.IsDiag","initialProofState":"α : Type u_1\nn : Type u_4\nm : Type u_5\ninst✝² : Fintype m\ninst✝¹ : Mul α\ninst✝ : AddCommMonoid α\nA : Matrix m n α\n⊢ Iff (HMul.hMul A.transpose A).IsDiag A.HasOrthogonalCols","decl":"theorem transpose_mul_self_isDiag_iff_hasOrthogonalCols [Fintype m] [Mul α] [AddCommMonoid α]\n    {A : Matrix m n α} : (Aᵀ * A).IsDiag ↔ A.HasOrthogonalCols :=\n  Iff.rfl\n\n"}
