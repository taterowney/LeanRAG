{"name":"HomologicalComplex₂.hasTotal_of_iso","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_5, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\ne : CategoryTheory.Iso K L\nc₁₂ : ComplexShape I₁₂\ninst✝¹ : TotalComplexShape c₁ c₂ c₁₂\ninst✝ : K.HasTotal c₁₂\n⊢ L.HasTotal c₁₂","decl":"include e in\nvariable {K L} in\nlemma hasTotal_of_iso [K.HasTotal c₁₂] : L.HasTotal c₁₂ :=\n  GradedObject.hasMap_of_iso (GradedObject.isoMk K.toGradedObject L.toGradedObject\n    (fun ⟨i₁, i₂⟩ =>\n      (HomologicalComplex.eval _ _ i₁ ⋙ HomologicalComplex.eval _ _ i₂).mapIso e)) _\n\n"}
{"name":"HomologicalComplex₂.d₁_eq_zero","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh : Not (c₁.Rel i₁ (c₁.next i₁))\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) 0","decl":"lemma d₁_eq_zero (h : ¬ c₁.Rel i₁ (c₁.next i₁)) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = 0 := by\n  dsimp [d₁]\n  rw [K.shape_f _ _ h, zero_comp, smul_zero]\n\n"}
{"name":"HomologicalComplex₂.d₂_eq_zero","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh : Not (c₂.Rel i₂ (c₂.next i₂))\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) 0","decl":"lemma d₂_eq_zero (h : ¬ c₂.Rel i₂ (c₂.next i₂)) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = 0 := by\n  dsimp [d₂]\n  rw [HomologicalComplex.shape _ _ _ h, zero_comp, smul_zero]\n\n"}
{"name":"HomologicalComplex₂.totalAux.d₁_eq'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\ni₁₂ : I₁₂\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (K.toGradedObject.ιMapObjOrZero (c₁.π c₂ c₁₂) { fst := i₁', snd := i₂ } i₁₂)))","decl":"lemma d₁_eq' {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.d i₁ i₁').f i₂ ≫\n      K.toGradedObject.ιMapObjOrZero (ComplexShape.π c₁ c₂ c₁₂) ⟨i₁', i₂⟩ i₁₂) := by\n  obtain rfl := c₁.next_eq' h\n  rfl\n\n"}
{"name":"HomologicalComplex₂.totalAux.d₁_eq","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\ni₁₂ : I₁₂\nh' : Eq (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ }) i₁₂\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) { fst := i₁', snd := i₂ } i₁₂ h')))","decl":"lemma d₁_eq {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁', i₂⟩ = i₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.d i₁ i₁').f i₂ ≫\n      K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) ⟨i₁', i₂⟩ i₁₂ h') := by\n  rw [d₁_eq' K c₁₂ h i₂ i₁₂, K.toGradedObject.ιMapObjOrZero_eq]\n\n"}
{"name":"HomologicalComplex₂.totalAux.d₂_eq'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\ni₁₂ : I₁₂\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (K.toGradedObject.ιMapObjOrZero (c₁.π c₂ c₁₂) { fst := i₁, snd := i₂' } i₁₂)))","decl":"lemma d₂_eq' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.X i₁).d i₂ i₂' ≫\n    K.toGradedObject.ιMapObjOrZero (ComplexShape.π c₁ c₂ c₁₂) ⟨i₁, i₂'⟩ i₁₂) := by\n  obtain rfl := c₂.next_eq' h\n  rfl\n\n"}
{"name":"HomologicalComplex₂.totalAux.d₂_eq","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\ni₁₂ : I₁₂\nh' : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' }) i₁₂\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) { fst := i₁, snd := i₂' } i₁₂ h')))","decl":"lemma d₂_eq (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ = i₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.X i₁).d i₂ i₂' ≫\n    K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) ⟨i₁, i₂'⟩ i₁₂ h') := by\n  rw [d₂_eq' K c₁₂ i₁ h i₁₂, K.toGradedObject.ιMapObjOrZero_eq]\n\n"}
{"name":"HomologicalComplex₂.d₁_eq_zero'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\ni₁₂ : I₁₂\nh' : Ne (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ }) i₁₂\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) 0","decl":"lemma d₁_eq_zero' {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁', i₂⟩ ≠ i₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = 0 := by\n  rw [totalAux.d₁_eq' K c₁₂ h i₂ i₁₂, K.toGradedObject.ιMapObjOrZero_eq_zero, comp_zero, smul_zero]\n  exact h'\n\n"}
{"name":"HomologicalComplex₂.d₂_eq_zero'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\ni₁₂ : I₁₂\nh' : Ne (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' }) i₁₂\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) 0","decl":"lemma d₂_eq_zero' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ ≠ i₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = 0 := by\n  rw [totalAux.d₂_eq' K c₁₂ i₁ h i₁₂, K.toGradedObject.ιMapObjOrZero_eq_zero, comp_zero, smul_zero]\n  exact h'\n\n"}
{"name":"HomologicalComplex₂.totalAux.ιMapObj_D₁_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni : Prod I₁ I₂\nh✝ : Eq (c₁.π c₂ c₁₂ i) i₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) i i₁₂ h✝) (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.d₁ c₁₂ i.1 i.2 i₁₂') h)","decl":"@[reassoc (attr := simp)]\nlemma ιMapObj_D₁ (i₁₂ i₁₂' : I₁₂) (i : I₁ × I₂) (h : ComplexShape.π c₁ c₂ c₁₂ i = i₁₂) :\n    K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) i i₁₂ h ≫ K.D₁ c₁₂ i₁₂ i₁₂' =\n      K.d₁ c₁₂ i.1 i.2 i₁₂' := by\n  simp [D₁]\n\n"}
{"name":"HomologicalComplex₂.totalAux.ιMapObj_D₁","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni : Prod I₁ I₂\nh : Eq (c₁.π c₂ c₁₂ i) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) i i₁₂ h) (K.D₁ c₁₂ i₁₂ i₁₂')) (K.d₁ c₁₂ i.1 i.2 i₁₂')","decl":"@[reassoc (attr := simp)]\nlemma ιMapObj_D₁ (i₁₂ i₁₂' : I₁₂) (i : I₁ × I₂) (h : ComplexShape.π c₁ c₂ c₁₂ i = i₁₂) :\n    K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) i i₁₂ h ≫ K.D₁ c₁₂ i₁₂ i₁₂' =\n      K.d₁ c₁₂ i.1 i.2 i₁₂' := by\n  simp [D₁]\n\n"}
{"name":"HomologicalComplex₂.totalAux.ιMapObj_D₂_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni : Prod I₁ I₂\nh✝ : Eq (c₁.π c₂ c₁₂ i) i₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) i i₁₂ h✝) (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.d₂ c₁₂ i.1 i.2 i₁₂') h)","decl":"@[reassoc (attr := simp)]\nlemma ιMapObj_D₂ (i₁₂ i₁₂' : I₁₂) (i : I₁ × I₂) (h : ComplexShape.π c₁ c₂ c₁₂ i = i₁₂) :\n    K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) i i₁₂ h ≫ K.D₂ c₁₂ i₁₂ i₁₂' =\n      K.d₂ c₁₂ i.1 i.2 i₁₂' := by\n  simp [D₂]\n\n"}
{"name":"HomologicalComplex₂.totalAux.ιMapObj_D₂","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni : Prod I₁ I₂\nh : Eq (c₁.π c₂ c₁₂ i) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.toGradedObject.ιMapObj (c₁.π c₂ c₁₂) i i₁₂ h) (K.D₂ c₁₂ i₁₂ i₁₂')) (K.d₂ c₁₂ i.1 i.2 i₁₂')","decl":"@[reassoc (attr := simp)]\nlemma ιMapObj_D₂ (i₁₂ i₁₂' : I₁₂) (i : I₁ × I₂) (h : ComplexShape.π c₁ c₂ c₁₂ i = i₁₂) :\n    K.toGradedObject.ιMapObj (ComplexShape.π c₁ c₂ c₁₂) i i₁₂ h ≫ K.D₂ c₁₂ i₁₂ i₁₂' =\n      K.d₂ c₁₂ i.1 i.2 i₁₂' := by\n  simp [D₂]\n\n"}
{"name":"HomologicalComplex₂.D₁_shape","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\nh₁₂ : Not (c₁₂.Rel i₁₂ i₁₂')\n⊢ Eq (K.D₁ c₁₂ i₁₂ i₁₂') 0","decl":"lemma D₁_shape (i₁₂ i₁₂' : I₁₂) (h₁₂ : ¬ c₁₂.Rel i₁₂ i₁₂') : K.D₁ c₁₂ i₁₂ i₁₂' = 0 := by\n  ext ⟨i₁, i₂⟩ h\n  simp only [totalAux.ιMapObj_D₁, comp_zero]\n  by_cases h₁ : c₁.Rel i₁ (c₁.next i₁)\n  · rw [K.d₁_eq_zero' c₁₂ h₁ i₂ i₁₂']\n    intro h₂\n    exact h₁₂ (by simpa only [← h, ← h₂] using ComplexShape.rel_π₁ c₂ c₁₂ h₁ i₂)\n  · exact d₁_eq_zero _ _ _ _ _ h₁\n\n"}
{"name":"HomologicalComplex₂.D₂_shape","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\nh₁₂ : Not (c₁₂.Rel i₁₂ i₁₂')\n⊢ Eq (K.D₂ c₁₂ i₁₂ i₁₂') 0","decl":"lemma D₂_shape (i₁₂ i₁₂' : I₁₂) (h₁₂ : ¬ c₁₂.Rel i₁₂ i₁₂') : K.D₂ c₁₂ i₁₂ i₁₂' = 0 := by\n  ext ⟨i₁, i₂⟩ h\n  simp only [totalAux.ιMapObj_D₂, comp_zero]\n  by_cases h₂ : c₂.Rel i₂ (c₂.next i₂)\n  · rw [K.d₂_eq_zero' c₁₂ i₁ h₂ i₁₂']\n    intro h₁\n    exact h₁₂ (by simpa only [← h, ← h₁] using ComplexShape.rel_π₂ c₁ c₁₂ i₁ h₂)\n  · exact d₂_eq_zero _ _ _ _ _ h₂\n\n"}
{"name":"HomologicalComplex₂.D₁_D₁","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (K.D₁ c₁₂ i₁₂' i₁₂'')) 0","decl":"@[reassoc (attr := simp)]\nlemma D₁_D₁ (i₁₂ i₁₂' i₁₂'' : I₁₂) : K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' = 0 := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₁_assoc, comp_zero]\n      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)\n      · rw [totalAux.d₁_eq K c₁₂ h₃ i₂ i₁₂']; swap\n        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁]\n        by_cases h₄ : c₁.Rel (c₁.next i₁) (c₁.next (c₁.next i₁))\n        · rw [totalAux.d₁_eq K c₁₂ h₄ i₂ i₁₂'', Linear.comp_units_smul,\n            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]\n          rw [← ComplexShape.next_π₁ c₂ c₁₂ h₄, ← ComplexShape.next_π₁ c₂ c₁₂ h₃,\n            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]\n        · rw [K.d₁_eq_zero _ _ _ _ h₄, comp_zero, smul_zero]\n      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp]\n    · rw [K.D₁_shape c₁₂ _ _ h₂, comp_zero]\n  · rw [K.D₁_shape c₁₂ _ _ h₁, zero_comp]\n\n"}
{"name":"HomologicalComplex₂.D₁_D₁_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂' i₁₂'') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma D₁_D₁ (i₁₂ i₁₂' i₁₂'' : I₁₂) : K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' = 0 := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₁_assoc, comp_zero]\n      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)\n      · rw [totalAux.d₁_eq K c₁₂ h₃ i₂ i₁₂']; swap\n        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁]\n        by_cases h₄ : c₁.Rel (c₁.next i₁) (c₁.next (c₁.next i₁))\n        · rw [totalAux.d₁_eq K c₁₂ h₄ i₂ i₁₂'', Linear.comp_units_smul,\n            d_f_comp_d_f_assoc, zero_comp, smul_zero, smul_zero]\n          rw [← ComplexShape.next_π₁ c₂ c₁₂ h₄, ← ComplexShape.next_π₁ c₂ c₁₂ h₃,\n            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]\n        · rw [K.d₁_eq_zero _ _ _ _ h₄, comp_zero, smul_zero]\n      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp]\n    · rw [K.D₁_shape c₁₂ _ _ h₂, comp_zero]\n  · rw [K.D₁_shape c₁₂ _ _ h₁, zero_comp]\n\n"}
{"name":"HomologicalComplex₂.D₂_D₂","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (K.D₂ c₁₂ i₁₂' i₁₂'')) 0","decl":"@[reassoc (attr := simp)]\nlemma D₂_D₂ (i₁₂ i₁₂' i₁₂'' : I₁₂) : K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' = 0 := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₂_assoc, comp_zero]\n      by_cases h₃ : c₂.Rel i₂ (c₂.next i₂)\n      · rw [totalAux.d₂_eq K c₁₂ i₁ h₃ i₁₂']; swap\n        · rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₃, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₂]\n        by_cases h₄ : c₂.Rel (c₂.next i₂) (c₂.next (c₂.next i₂))\n        · rw [totalAux.d₂_eq K c₁₂ i₁ h₄ i₁₂'', Linear.comp_units_smul,\n            HomologicalComplex.d_comp_d_assoc, zero_comp, smul_zero, smul_zero]\n          rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄, ← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₃,\n            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]\n        · rw [K.d₂_eq_zero c₁₂ _ _ _ h₄, comp_zero, smul_zero]\n      · rw [K.d₂_eq_zero c₁₂ _ _ _ h₃, zero_comp]\n    · rw [K.D₂_shape c₁₂ _ _ h₂, comp_zero]\n  · rw [K.D₂_shape c₁₂ _ _ h₁, zero_comp]\n\n"}
{"name":"HomologicalComplex₂.D₂_D₂_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂' i₁₂'') h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma D₂_D₂ (i₁₂ i₁₂' i₁₂'' : I₁₂) : K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' = 0 := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₂_assoc, comp_zero]\n      by_cases h₃ : c₂.Rel i₂ (c₂.next i₂)\n      · rw [totalAux.d₂_eq K c₁₂ i₁ h₃ i₁₂']; swap\n        · rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₃, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₂]\n        by_cases h₄ : c₂.Rel (c₂.next i₂) (c₂.next (c₂.next i₂))\n        · rw [totalAux.d₂_eq K c₁₂ i₁ h₄ i₁₂'', Linear.comp_units_smul,\n            HomologicalComplex.d_comp_d_assoc, zero_comp, smul_zero, smul_zero]\n          rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄, ← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₃,\n            h, c₁₂.next_eq' h₁, c₁₂.next_eq' h₂]\n        · rw [K.d₂_eq_zero c₁₂ _ _ _ h₄, comp_zero, smul_zero]\n      · rw [K.d₂_eq_zero c₁₂ _ _ _ h₃, zero_comp]\n    · rw [K.D₂_shape c₁₂ _ _ h₂, comp_zero]\n  · rw [K.D₂_shape c₁₂ _ _ h₁, zero_comp]\n\n"}
{"name":"HomologicalComplex₂.D₂_D₁_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂' i₁₂'') h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (K.D₂ c₁₂ i₁₂' i₁₂''))) h)","decl":"@[reassoc (attr := simp)]\nlemma D₂_D₁ (i₁₂ i₁₂' i₁₂'' : I₁₂) :\n    K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' = - K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₂_assoc, comp_neg, totalAux.ιMapObj_D₁_assoc]\n      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)\n      · rw [totalAux.d₁_eq K c₁₂ h₃ i₂ i₁₂']; swap\n        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₂]\n        by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n        · have h₅ : ComplexShape.π c₁ c₂ c₁₂ (i₁, c₂.next i₂) = i₁₂' := by\n            rw [← c₁₂.next_eq' h₁, ← h, ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄]\n          have h₆ : ComplexShape.π c₁ c₂ c₁₂ (c₁.next i₁, c₂.next i₂) = i₁₂'' := by\n            rw [← c₁₂.next_eq' h₂, ← ComplexShape.next_π₁ c₂ c₁₂ h₃, h₅]\n          simp only [totalAux.d₂_eq K c₁₂ _ h₄ _ h₅, totalAux.d₂_eq K c₁₂ _ h₄ _ h₆,\n            Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁, Linear.comp_units_smul,\n            totalAux.d₁_eq K c₁₂ h₃ _ _ h₆, HomologicalComplex.Hom.comm_assoc, smul_smul,\n            ComplexShape.ε₂_ε₁ c₁₂ h₃ h₄, neg_mul, Units.neg_smul]\n        · simp only [K.d₂_eq_zero c₁₂ _ _ _ h₄, zero_comp, comp_zero, smul_zero, neg_zero]\n      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp, neg_zero]\n        by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n        · rw [totalAux.d₂_eq K c₁₂ i₁ h₄ i₁₂']; swap\n          · rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄, ← c₁₂.next_eq' h₁, h]\n          simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁]\n          rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, comp_zero, smul_zero]\n        · rw [K.d₂_eq_zero c₁₂ _ _ _ h₄, zero_comp]\n    · rw [K.D₁_shape c₁₂ _ _ h₂, K.D₂_shape c₁₂ _ _ h₂, comp_zero, comp_zero, neg_zero]\n  · rw [K.D₁_shape c₁₂ _ _ h₁, K.D₂_shape c₁₂ _ _ h₁, zero_comp, zero_comp, neg_zero]\n\n"}
{"name":"HomologicalComplex₂.D₂_D₁","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (K.D₁ c₁₂ i₁₂' i₁₂'')) (Neg.neg (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (K.D₂ c₁₂ i₁₂' i₁₂'')))","decl":"@[reassoc (attr := simp)]\nlemma D₂_D₁ (i₁₂ i₁₂' i₁₂'' : I₁₂) :\n    K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' = - K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' := by\n  by_cases h₁ : c₁₂.Rel i₁₂ i₁₂'\n  · by_cases h₂ : c₁₂.Rel i₁₂' i₁₂''\n    · ext ⟨i₁, i₂⟩ h\n      simp only [totalAux.ιMapObj_D₂_assoc, comp_neg, totalAux.ιMapObj_D₁_assoc]\n      by_cases h₃ : c₁.Rel i₁ (c₁.next i₁)\n      · rw [totalAux.d₁_eq K c₁₂ h₃ i₂ i₁₂']; swap\n        · rw [← ComplexShape.next_π₁ c₂ c₁₂ h₃ i₂, ← c₁₂.next_eq' h₁, h]\n        simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₂]\n        by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n        · have h₅ : ComplexShape.π c₁ c₂ c₁₂ (i₁, c₂.next i₂) = i₁₂' := by\n            rw [← c₁₂.next_eq' h₁, ← h, ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄]\n          have h₆ : ComplexShape.π c₁ c₂ c₁₂ (c₁.next i₁, c₂.next i₂) = i₁₂'' := by\n            rw [← c₁₂.next_eq' h₂, ← ComplexShape.next_π₁ c₂ c₁₂ h₃, h₅]\n          simp only [totalAux.d₂_eq K c₁₂ _ h₄ _ h₅, totalAux.d₂_eq K c₁₂ _ h₄ _ h₆,\n            Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁, Linear.comp_units_smul,\n            totalAux.d₁_eq K c₁₂ h₃ _ _ h₆, HomologicalComplex.Hom.comm_assoc, smul_smul,\n            ComplexShape.ε₂_ε₁ c₁₂ h₃ h₄, neg_mul, Units.neg_smul]\n        · simp only [K.d₂_eq_zero c₁₂ _ _ _ h₄, zero_comp, comp_zero, smul_zero, neg_zero]\n      · rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, zero_comp, neg_zero]\n        by_cases h₄ : c₂.Rel i₂ (c₂.next i₂)\n        · rw [totalAux.d₂_eq K c₁₂ i₁ h₄ i₁₂']; swap\n          · rw [← ComplexShape.next_π₂ c₁ c₁₂ i₁ h₄, ← c₁₂.next_eq' h₁, h]\n          simp only [Linear.units_smul_comp, assoc, totalAux.ιMapObj_D₁]\n          rw [K.d₁_eq_zero c₁₂ _ _ _ h₃, comp_zero, smul_zero]\n        · rw [K.d₂_eq_zero c₁₂ _ _ _ h₄, zero_comp]\n    · rw [K.D₁_shape c₁₂ _ _ h₂, K.D₂_shape c₁₂ _ _ h₂, comp_zero, comp_zero, neg_zero]\n  · rw [K.D₁_shape c₁₂ _ _ h₁, K.D₂_shape c₁₂ _ _ h₁, zero_comp, zero_comp, neg_zero]\n\n"}
{"name":"HomologicalComplex₂.D₁_D₂_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂'') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂' i₁₂'') h)) (CategoryTheory.CategoryStruct.comp (Neg.neg (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (K.D₁ c₁₂ i₁₂' i₁₂''))) h)","decl":"@[reassoc]\nlemma D₁_D₂ (i₁₂ i₁₂' i₁₂'' : I₁₂) :\n    K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' = - K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' := by simp\n\n"}
{"name":"HomologicalComplex₂.D₁_D₂","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' i₁₂'' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (K.D₂ c₁₂ i₁₂' i₁₂'')) (Neg.neg (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (K.D₁ c₁₂ i₁₂' i₁₂'')))","decl":"@[reassoc]\nlemma D₁_D₂ (i₁₂ i₁₂' i₁₂'' : I₁₂) :\n    K.D₁ c₁₂ i₁₂ i₁₂' ≫ K.D₂ c₁₂ i₁₂' i₁₂'' = - K.D₂ c₁₂ i₁₂ i₁₂' ≫ K.D₁ c₁₂ i₁₂' i₁₂'' := by simp\n\n"}
{"name":"HomologicalComplex₂.total_d","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\n⊢ Eq ((K.total c₁₂).d i₁₂ i₁₂') (HAdd.hAdd (K.D₁ c₁₂ i₁₂ i₁₂') (K.D₂ c₁₂ i₁₂ i₁₂'))","decl":"/-- The total complex of a bicomplex. -/\n@[simps (config := .lemmasOnly) d]\nnoncomputable def total : HomologicalComplex C c₁₂ where\n  X := K.toGradedObject.mapObj (ComplexShape.π c₁ c₂ c₁₂)\n  d i₁₂ i₁₂' := K.D₁ c₁₂ i₁₂ i₁₂' + K.D₂ c₁₂ i₁₂ i₁₂'\n  shape i₁₂ i₁₂' h₁₂ := by\n    dsimp\n    rw [K.D₁_shape c₁₂ _ _ h₁₂, K.D₂_shape c₁₂ _ _ h₁₂, zero_add]\n\n"}
{"name":"HomologicalComplex₂.XXIsoOfEq_hom_ιTotal","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nx₁ y₁ : I₁\nh₁ : Eq x₁ y₁\nx₂ y₂ : I₂\nh₂ : Eq x₂ y₂\ni₁₂ : I₁₂\nh : Eq (c₁.π c₂ c₁₂ { fst := y₁, snd := y₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.XXIsoOfEq C c₁ c₂ K h₁ h₂).hom (K.ιTotal c₁₂ y₁ y₂ i₁₂ h)) (K.ιTotal c₁₂ x₁ x₂ i₁₂ ⋯)","decl":"@[reassoc (attr := simp)]\nlemma XXIsoOfEq_hom_ιTotal {x₁ y₁ : I₁} (h₁ : x₁ = y₁) {x₂ y₂ : I₂} (h₂ : x₂ = y₂)\n    (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (y₁, y₂) = i₁₂) :\n    (K.XXIsoOfEq _ _ _ h₁ h₂).hom ≫ K.ιTotal c₁₂ y₁ y₂ i₁₂ h =\n      K.ιTotal c₁₂ x₁ x₂ i₁₂ (by rw [h₁, h₂, h]) := by\n  subst h₁ h₂\n  simp\n\n"}
{"name":"HomologicalComplex₂.XXIsoOfEq_hom_ιTotal_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nx₁ y₁ : I₁\nh₁ : Eq x₁ y₁\nx₂ y₂ : I₂\nh₂ : Eq x₂ y₂\ni₁₂ : I₁₂\nh✝ : Eq (c₁.π c₂ c₁₂ { fst := y₁, snd := y₂ }) i₁₂\nZ : C\nh : Quiver.Hom ((K.total c₁₂).X i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.XXIsoOfEq C c₁ c₂ K h₁ h₂).hom (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ y₁ y₂ i₁₂ h✝) h)) (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ x₁ x₂ i₁₂ ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma XXIsoOfEq_hom_ιTotal {x₁ y₁ : I₁} (h₁ : x₁ = y₁) {x₂ y₂ : I₂} (h₂ : x₂ = y₂)\n    (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (y₁, y₂) = i₁₂) :\n    (K.XXIsoOfEq _ _ _ h₁ h₂).hom ≫ K.ιTotal c₁₂ y₁ y₂ i₁₂ h =\n      K.ιTotal c₁₂ x₁ x₂ i₁₂ (by rw [h₁, h₂, h]) := by\n  subst h₁ h₂\n  simp\n\n"}
{"name":"HomologicalComplex₂.XXIsoOfEq_inv_ιTotal","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nx₁ y₁ : I₁\nh₁ : Eq x₁ y₁\nx₂ y₂ : I₂\nh₂ : Eq x₂ y₂\ni₁₂ : I₁₂\nh : Eq (c₁.π c₂ c₁₂ { fst := x₁, snd := x₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.XXIsoOfEq C c₁ c₂ K h₁ h₂).inv (K.ιTotal c₁₂ x₁ x₂ i₁₂ h)) (K.ιTotal c₁₂ y₁ y₂ i₁₂ ⋯)","decl":"@[reassoc (attr := simp)]\nlemma XXIsoOfEq_inv_ιTotal {x₁ y₁ : I₁} (h₁ : x₁ = y₁) {x₂ y₂ : I₂} (h₂ : x₂ = y₂)\n    (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (x₁, x₂) = i₁₂) :\n    (K.XXIsoOfEq _ _ _ h₁ h₂).inv ≫ K.ιTotal c₁₂ x₁ x₂ i₁₂ h =\n      K.ιTotal c₁₂ y₁ y₂ i₁₂ (by rw [← h, h₁, h₂]) := by\n  subst h₁ h₂\n  simp\n\n"}
{"name":"HomologicalComplex₂.XXIsoOfEq_inv_ιTotal_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nx₁ y₁ : I₁\nh₁ : Eq x₁ y₁\nx₂ y₂ : I₂\nh₂ : Eq x₂ y₂\ni₁₂ : I₁₂\nh✝ : Eq (c₁.π c₂ c₁₂ { fst := x₁, snd := x₂ }) i₁₂\nZ : C\nh : Quiver.Hom ((K.total c₁₂).X i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.XXIsoOfEq C c₁ c₂ K h₁ h₂).inv (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ x₁ x₂ i₁₂ h✝) h)) (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ y₁ y₂ i₁₂ ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma XXIsoOfEq_inv_ιTotal {x₁ y₁ : I₁} (h₁ : x₁ = y₁) {x₂ y₂ : I₂} (h₂ : x₂ = y₂)\n    (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (x₁, x₂) = i₁₂) :\n    (K.XXIsoOfEq _ _ _ h₁ h₂).inv ≫ K.ιTotal c₁₂ x₁ x₂ i₁₂ h =\n      K.ιTotal c₁₂ y₁ y₂ i₁₂ (by rw [← h, h₁, h₂]) := by\n  subst h₁ h₂\n  simp\n\n"}
{"name":"HomologicalComplex₂.ιTotalOrZero_eq","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂) (K.ιTotal c₁₂ i₁ i₂ i₁₂ h)","decl":"lemma ιTotalOrZero_eq (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂)\n    (h : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂) :\n    K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ = K.ιTotal c₁₂ i₁ i₂ i₁₂ h := dif_pos h\n\n"}
{"name":"HomologicalComplex₂.ιTotalOrZero_eq_zero","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh : Ne (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂) 0","decl":"lemma ιTotalOrZero_eq_zero (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂)\n    (h : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) ≠ i₁₂) :\n    K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ = 0 := dif_neg h\n\n"}
{"name":"HomologicalComplex₂.ι_D₁_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni₁ : I₁\ni₂ : I₂\nh✝ : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h✝) (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.d₁ c₁₂ i₁ i₂ i₁₂') h)","decl":"@[reassoc (attr := simp)]\nlemma ι_D₁ (i₁₂ i₁₂' : I₁₂) (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ K.D₁ c₁₂ i₁₂ i₁₂' =\n      K.d₁ c₁₂ i₁ i₂ i₁₂' := by\n  apply totalAux.ιMapObj_D₁\n\n"}
{"name":"HomologicalComplex₂.ι_D₁","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni₁ : I₁\ni₂ : I₂\nh : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h) (K.D₁ c₁₂ i₁₂ i₁₂')) (K.d₁ c₁₂ i₁ i₂ i₁₂')","decl":"@[reassoc (attr := simp)]\nlemma ι_D₁ (i₁₂ i₁₂' : I₁₂) (i₁ : I₁) (i₂ : I₂) (h : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ K.D₁ c₁₂ i₁₂ i₁₂' =\n      K.d₁ c₁₂ i₁ i₂ i₁₂' := by\n  apply totalAux.ιMapObj_D₁\n\n"}
{"name":"HomologicalComplex₂.ι_D₂","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni₁ : I₁\ni₂ : I₂\nh : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h) (K.D₂ c₁₂ i₁₂ i₁₂')) (K.d₂ c₁₂ i₁ i₂ i₁₂')","decl":"@[reassoc (attr := simp)]\nlemma ι_D₂ (i₁₂ i₁₂' : I₁₂) (i₁ : I₁) (i₂ : I₂)\n    (h : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ K.D₂ c₁₂ i₁₂ i₁₂' =\n      K.d₂ c₁₂ i₁ i₂ i₁₂' := by\n  apply totalAux.ιMapObj_D₂\n\n"}
{"name":"HomologicalComplex₂.ι_D₂_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\ni₁ : I₁\ni₂ : I₂\nh✝ : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\nZ : C\nh : Quiver.Hom (K.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h✝) (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.d₂ c₁₂ i₁ i₂ i₁₂') h)","decl":"@[reassoc (attr := simp)]\nlemma ι_D₂ (i₁₂ i₁₂' : I₁₂) (i₁ : I₁) (i₂ : I₂)\n    (h : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂⟩ = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ K.D₂ c₁₂ i₁₂ i₁₂' =\n      K.d₂ c₁₂ i₁ i₂ i₁₂' := by\n  apply totalAux.ιMapObj_D₂\n\n"}
{"name":"HomologicalComplex₂.d₁_eq'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\ni₁₂ : I₁₂\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (K.ιTotalOrZero c₁₂ i₁' i₂ i₁₂)))","decl":"lemma d₁_eq' {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.d i₁ i₁').f i₂ ≫\n      K.ιTotalOrZero c₁₂ i₁' i₂ i₁₂) :=\n  totalAux.d₁_eq' _ _ h _ _\n\n"}
{"name":"HomologicalComplex₂.d₁_eq","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ i₁' : I₁\nh : c₁.Rel i₁ i₁'\ni₂ : I₂\ni₁₂ : I₁₂\nh' : Eq (c₁.π c₂ c₁₂ { fst := i₁', snd := i₂ }) i₁₂\n⊢ Eq (K.d₁ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₁ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.d i₁ i₁').f i₂) (K.ιTotal c₁₂ i₁' i₂ i₁₂ h')))","decl":"lemma d₁_eq {i₁ i₁' : I₁} (h : c₁.Rel i₁ i₁') (i₂ : I₂) (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁', i₂⟩ = i₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₁ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.d i₁ i₁').f i₂ ≫\n      K.ιTotal c₁₂ i₁' i₂ i₁₂ h') :=\n  totalAux.d₁_eq _ _ h _ _ _\n\n"}
{"name":"HomologicalComplex₂.d₂_eq'","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\ni₁₂ : I₁₂\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (K.ιTotalOrZero c₁₂ i₁ i₂' i₁₂)))","decl":"lemma d₂_eq' (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.X i₁).d i₂ i₂' ≫\n    K.ιTotalOrZero c₁₂ i₁ i₂' i₁₂) :=\n  totalAux.d₂_eq' _ _ _ h _\n\n"}
{"name":"HomologicalComplex₂.d₂_eq","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\ni₁ : I₁\ni₂ i₂' : I₂\nh : c₂.Rel i₂ i₂'\ni₁₂ : I₁₂\nh' : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂' }) i₁₂\n⊢ Eq (K.d₂ c₁₂ i₁ i₂ i₁₂) (HSMul.hSMul (c₁.ε₂ c₂ c₁₂ { fst := i₁, snd := i₂ }) (CategoryTheory.CategoryStruct.comp ((K.X i₁).d i₂ i₂') (K.ιTotal c₁₂ i₁ i₂' i₁₂ h')))","decl":"lemma d₂_eq (i₁ : I₁) {i₂ i₂' : I₂} (h : c₂.Rel i₂ i₂') (i₁₂ : I₁₂)\n    (h' : ComplexShape.π c₁ c₂ c₁₂ ⟨i₁, i₂'⟩ = i₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ = ComplexShape.ε₂ c₁ c₂ c₁₂ ⟨i₁, i₂⟩ • ((K.X i₁).d i₂ i₂' ≫\n    K.ιTotal c₁₂ i₁ i₂' i₁₂ h') :=\n  totalAux.d₂_eq _ _ _ h _ _\n\n"}
{"name":"HomologicalComplex₂.ι_totalDesc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nA : C\ni₁₂ : I₁₂\nf : (i₁ : I₁) → (i₂ : I₂) → Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂ → Quiver.Hom ((K.X i₁).X i₂) A\ni₁ : I₁\ni₂ : I₂\nhi : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) (K.totalDesc f)) (f i₁ i₂ hi)","decl":"@[reassoc (attr := simp)]\nlemma ι_totalDesc (i₁ : I₁) (i₂ : I₂) (hi : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ K.totalDesc f = f i₁ i₂ hi := by\n  simp [totalDesc, ιTotal]\n\n"}
{"name":"HomologicalComplex₂.ι_totalDesc_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nA : C\ni₁₂ : I₁₂\nf : (i₁ : I₁) → (i₂ : I₂) → Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂ → Quiver.Hom ((K.X i₁).X i₂) A\ni₁ : I₁\ni₂ : I₂\nhi : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) (CategoryTheory.CategoryStruct.comp (K.totalDesc f) h)) (CategoryTheory.CategoryStruct.comp (f i₁ i₂ hi) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_totalDesc (i₁ : I₁) (i₂ : I₂) (hi : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ K.totalDesc f = f i₁ i₂ hi := by\n  simp [totalDesc, ιTotal]\n\n"}
{"name":"HomologicalComplex₂.total.hom_ext_iff","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nA : C\ni₁₂ : I₁₂\nf g : Quiver.Hom ((K.total c₁₂).X i₁₂) A\n⊢ Iff (Eq f g) (∀ (i₁ : I₁) (i₂ : I₂) (hi : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂), Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) f) (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) g))","decl":"@[ext]\nlemma hom_ext {A : C} {i₁₂ : I₁₂} {f g : (K.total c₁₂).X i₁₂ ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (hi : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂),\n      K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ f = K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ g) : f = g := by\n  apply GradedObject.mapObj_ext\n  rintro ⟨i₁, i₂⟩ hi\n  exact h i₁ i₂ hi\n\n"}
{"name":"HomologicalComplex₂.total.hom_ext","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\nA : C\ni₁₂ : I₁₂\nf g : Quiver.Hom ((K.total c₁₂).X i₁₂) A\nh : ∀ (i₁ : I₁) (i₂ : I₂) (hi : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂), Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) f) (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ hi) g)\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {A : C} {i₁₂ : I₁₂} {f g : (K.total c₁₂).X i₁₂ ⟶ A}\n    (h : ∀ (i₁ : I₁) (i₂ : I₂) (hi : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂),\n      K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ f = K.ιTotal c₁₂ i₁ i₂ i₁₂ hi ≫ g) : f = g := by\n  apply GradedObject.mapObj_ext\n  rintro ⟨i₁, i₂⟩ hi\n  exact h i₁ i₂ hi\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.d₁_mapMap_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nZ : C\nh : Quiver.Hom (L.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d₁ c₁₂ i₁ i₂ i₁₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) h)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (CategoryTheory.CategoryStruct.comp (L.d₁ c₁₂ i₁ i₂ i₁₂) h))","decl":"@[reassoc (attr := simp)]\nlemma d₁_mapMap (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ =\n    (φ.f i₁).f i₂ ≫ L.d₁ c₁₂ i₁ i₂ i₁₂ := by\n  by_cases h : c₁.Rel i₁ (c₁.next i₁)\n  · simp [totalAux.d₁_eq' _ c₁₂ h]\n  · simp [d₁_eq_zero _ c₁₂ i₁ i₂ i₁₂ h]\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.d₁_mapMap","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d₁ c₁₂ i₁ i₂ i₁₂) (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (L.d₁ c₁₂ i₁ i₂ i₁₂))","decl":"@[reassoc (attr := simp)]\nlemma d₁_mapMap (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₁ c₁₂ i₁ i₂ i₁₂ ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ =\n    (φ.f i₁).f i₂ ≫ L.d₁ c₁₂ i₁ i₂ i₁₂ := by\n  by_cases h : c₁.Rel i₁ (c₁.next i₁)\n  · simp [totalAux.d₁_eq' _ c₁₂ h]\n  · simp [d₁_eq_zero _ c₁₂ i₁ i₂ i₁₂ h]\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.d₂_mapMap","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d₂ c₁₂ i₁ i₂ i₁₂) (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (L.d₂ c₁₂ i₁ i₂ i₁₂))","decl":"@[reassoc (attr := simp)]\nlemma d₂_mapMap (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ =\n    (φ.f i₁).f i₂ ≫ L.d₂ c₁₂ i₁ i₂ i₁₂ := by\n  by_cases h : c₂.Rel i₂ (c₂.next i₂)\n  · simp [totalAux.d₂_eq' _ c₁₂ i₁ h]\n  · simp [d₂_eq_zero _ c₁₂ i₁ i₂ i₁₂ h]\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.d₂_mapMap_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nZ : C\nh : Quiver.Hom (L.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.d₂ c₁₂ i₁ i₂ i₁₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) h)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (CategoryTheory.CategoryStruct.comp (L.d₂ c₁₂ i₁ i₂ i₁₂) h))","decl":"@[reassoc (attr := simp)]\nlemma d₂_mapMap (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.d₂ c₁₂ i₁ i₂ i₁₂ ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ =\n    (φ.f i₁).f i₂ ≫ L.d₂ c₁₂ i₁ i₂ i₁₂ := by\n  by_cases h : c₂.Rel i₂ (c₂.next i₂)\n  · simp [totalAux.d₂_eq' _ c₁₂ i₁ h]\n  · simp [d₂_eq_zero _ c₁₂ i₁ i₂ i₁₂ h]\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.mapMap_D₁","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) (L.D₁ c₁₂ i₁₂ i₁₂')) (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂'))","decl":"@[reassoc]\nlemma mapMap_D₁ (i₁₂ i₁₂' : I₁₂) :\n    GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ ≫ L.D₁ c₁₂ i₁₂ i₁₂' =\n      K.D₁ c₁₂ i₁₂ i₁₂' ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂' := by\n  aesop_cat\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.mapMap_D₁_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\nZ : C\nh : Quiver.Hom (L.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) (CategoryTheory.CategoryStruct.comp (L.D₁ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.D₁ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂') h))","decl":"@[reassoc]\nlemma mapMap_D₁ (i₁₂ i₁₂' : I₁₂) :\n    GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ ≫ L.D₁ c₁₂ i₁₂ i₁₂' =\n      K.D₁ c₁₂ i₁₂ i₁₂' ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂' := by\n  aesop_cat\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.mapMap_D₂_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\nZ : C\nh : Quiver.Hom (L.toGradedObject.mapObj (c₁.π c₂ c₁₂) i₁₂') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) (CategoryTheory.CategoryStruct.comp (L.D₂ c₁₂ i₁₂ i₁₂') h)) (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂') h))","decl":"@[reassoc]\nlemma mapMap_D₂ (i₁₂ i₁₂' : I₁₂) :\n    GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ ≫ L.D₂ c₁₂ i₁₂ i₁₂' =\n      K.D₂ c₁₂ i₁₂ i₁₂' ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂' := by\n  aesop_cat\n\n"}
{"name":"HomologicalComplex₂.total.mapAux.mapMap_D₂","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁₂ i₁₂' : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂) (L.D₂ c₁₂ i₁₂ i₁₂')) (CategoryTheory.CategoryStruct.comp (K.D₂ c₁₂ i₁₂ i₁₂') (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂) i₁₂'))","decl":"@[reassoc]\nlemma mapMap_D₂ (i₁₂ i₁₂' : I₁₂) :\n    GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂ ≫ L.D₂ c₁₂ i₁₂ i₁₂' =\n      K.D₂ c₁₂ i₁₂ i₁₂' ≫ GradedObject.mapMap (toGradedObjectMap φ) _ i₁₂' := by\n  aesop_cat\n\n"}
{"name":"HomologicalComplex₂.total.forget_map","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\n⊢ Eq ((HomologicalComplex.forget C c₁₂).map (HomologicalComplex₂.total.map φ c₁₂)) (CategoryTheory.GradedObject.mapMap (HomologicalComplex₂.toGradedObjectMap φ) (c₁.π c₂ c₁₂))","decl":"@[simp]\nlemma forget_map :\n    (HomologicalComplex.forget C c₁₂).map (map φ c₁₂) =\n      GradedObject.mapMap (toGradedObjectMap φ) _ := rfl\n\n"}
{"name":"HomologicalComplex₂.total.map_id","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK : HomologicalComplex₂ C c₁ c₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : K.HasTotal c₁₂\n⊢ Eq (HomologicalComplex₂.total.map (CategoryTheory.CategoryStruct.id K) c₁₂) (CategoryTheory.CategoryStruct.id (K.total c₁₂))","decl":"variable (K) in\n@[simp]\nlemma map_id : map (𝟙 K) c₁₂ = 𝟙 _ := by\n  apply (HomologicalComplex.forget _ _).map_injective\n  apply GradedObject.mapMap_id\n\n"}
{"name":"HomologicalComplex₂.total.map_comp_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L M : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nψ : Quiver.Hom L M\nc₁₂ : ComplexShape I₁₂\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : DecidableEq I₁₂\ninst✝² : K.HasTotal c₁₂\ninst✝¹ : L.HasTotal c₁₂\ninst✝ : M.HasTotal c₁₂\nZ : HomologicalComplex C c₁₂\nh : Quiver.Hom (M.total c₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map (CategoryTheory.CategoryStruct.comp φ ψ) c₁₂) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map φ c₁₂) (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map ψ c₁₂) h))","decl":"@[simp, reassoc]\nlemma map_comp : map (φ ≫ ψ) c₁₂ = map φ c₁₂ ≫ map ψ c₁₂ := by\n  apply (HomologicalComplex.forget _ _).map_injective\n  exact GradedObject.mapMap_comp (toGradedObjectMap φ) (toGradedObjectMap ψ) _\n\n"}
{"name":"HomologicalComplex₂.total.map_comp","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L M : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nψ : Quiver.Hom L M\nc₁₂ : ComplexShape I₁₂\ninst✝⁴ : TotalComplexShape c₁ c₂ c₁₂\ninst✝³ : DecidableEq I₁₂\ninst✝² : K.HasTotal c₁₂\ninst✝¹ : L.HasTotal c₁₂\ninst✝ : M.HasTotal c₁₂\n⊢ Eq (HomologicalComplex₂.total.map (CategoryTheory.CategoryStruct.comp φ ψ) c₁₂) (CategoryTheory.CategoryStruct.comp (HomologicalComplex₂.total.map φ c₁₂) (HomologicalComplex₂.total.map ψ c₁₂))","decl":"@[simp, reassoc]\nlemma map_comp : map (φ ≫ ψ) c₁₂ = map φ c₁₂ ≫ map ψ c₁₂ := by\n  apply (HomologicalComplex.forget _ _).map_injective\n  exact GradedObject.mapMap_comp (toGradedObjectMap φ) (toGradedObjectMap ψ) _\n\n"}
{"name":"HomologicalComplex₂.total.mapIso_inv","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\ne : CategoryTheory.Iso K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\n⊢ Eq (HomologicalComplex₂.total.mapIso e c₁₂).inv (HomologicalComplex₂.total.map e.inv c₁₂)","decl":"/-- The isomorphism `K.total c₁₂ ≅ L.total c₁₂` of homological complexes induced\nby an isomorphism of bicomplexes `K ≅ L`. -/\n@[simps]\nnoncomputable def mapIso : K.total c₁₂ ≅ L.total c₁₂ where\n  hom := map e.hom _\n  inv := map e.inv _\n  hom_inv_id := by rw [← map_comp, e.hom_inv_id, map_id]\n  inv_hom_id := by rw [← map_comp, e.inv_hom_id, map_id]\n\n"}
{"name":"HomologicalComplex₂.total.mapIso_hom","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\ne : CategoryTheory.Iso K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\n⊢ Eq (HomologicalComplex₂.total.mapIso e c₁₂).hom (HomologicalComplex₂.total.map e.hom c₁₂)","decl":"/-- The isomorphism `K.total c₁₂ ≅ L.total c₁₂` of homological complexes induced\nby an isomorphism of bicomplexes `K ≅ L`. -/\n@[simps]\nnoncomputable def mapIso : K.total c₁₂ ≅ L.total c₁₂ where\n  hom := map e.hom _\n  inv := map e.inv _\n  hom_inv_id := by rw [← map_comp, e.hom_inv_id, map_id]\n  inv_hom_id := by rw [← map_comp, e.inv_hom_id, map_id]\n\n"}
{"name":"HomologicalComplex₂.ιTotal_map_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh✝ : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\nZ : C\nh : Quiver.Hom ((L.total c₁₂).X i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h✝) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex₂.total.map φ c₁₂).f i₁₂) h)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (CategoryTheory.CategoryStruct.comp (L.ιTotal c₁₂ i₁ i₂ i₁₂ h✝) h))","decl":"@[reassoc (attr := simp)]\nlemma ιTotal_map (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ (total.map φ c₁₂).f i₁₂ =\n      (φ.f i₁).f i₂ ≫ L.ιTotal c₁₂ i₁ i₂ i₁₂ h := by\n  simp [total.map, ιTotal]\n\n"}
{"name":"HomologicalComplex₂.ιTotal_map","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nh : Eq (c₁.π c₂ c₁₂ { fst := i₁, snd := i₂ }) i₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotal c₁₂ i₁ i₂ i₁₂ h) ((HomologicalComplex₂.total.map φ c₁₂).f i₁₂)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (L.ιTotal c₁₂ i₁ i₂ i₁₂ h))","decl":"@[reassoc (attr := simp)]\nlemma ιTotal_map (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) (h : ComplexShape.π c₁ c₂ c₁₂ (i₁, i₂) = i₁₂) :\n    K.ιTotal c₁₂ i₁ i₂ i₁₂ h ≫ (total.map φ c₁₂).f i₁₂ =\n      (φ.f i₁).f i₂ ≫ L.ιTotal c₁₂ i₁ i₂ i₁₂ h := by\n  simp [total.map, ιTotal]\n\n"}
{"name":"HomologicalComplex₂.ιTotalOrZero_map","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂) ((HomologicalComplex₂.total.map φ c₁₂).f i₁₂)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (L.ιTotalOrZero c₁₂ i₁ i₂ i₁₂))","decl":"@[reassoc (attr := simp)]\nlemma ιTotalOrZero_map (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ ≫ (total.map φ c₁₂).f i₁₂ =\n      (φ.f i₁).f i₂ ≫ L.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ := by\n  simp [total.map, ιTotalOrZero]\n\n"}
{"name":"HomologicalComplex₂.ιTotalOrZero_map_assoc","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nK L : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom K L\nc₁₂ : ComplexShape I₁₂\ninst✝³ : TotalComplexShape c₁ c₂ c₁₂\ninst✝² : DecidableEq I₁₂\ninst✝¹ : K.HasTotal c₁₂\ninst✝ : L.HasTotal c₁₂\ni₁ : I₁\ni₂ : I₂\ni₁₂ : I₁₂\nZ : C\nh : Quiver.Hom ((L.total c₁₂).X i₁₂) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex₂.total.map φ c₁₂).f i₁₂) h)) (CategoryTheory.CategoryStruct.comp ((φ.f i₁).f i₂) (CategoryTheory.CategoryStruct.comp (L.ιTotalOrZero c₁₂ i₁ i₂ i₁₂) h))","decl":"@[reassoc (attr := simp)]\nlemma ιTotalOrZero_map (i₁ : I₁) (i₂ : I₂) (i₁₂ : I₁₂) :\n    K.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ ≫ (total.map φ c₁₂).f i₁₂ =\n      (φ.f i₁).f i₂ ≫ L.ιTotalOrZero c₁₂ i₁ i₂ i₁₂ := by\n  simp [total.map, ιTotalOrZero]\n\n"}
{"name":"HomologicalComplex₂.totalFunctor_map","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : ∀ (K : HomologicalComplex₂ C c₁ c₂), K.HasTotal c₁₂\nX✝ Y✝ : HomologicalComplex₂ C c₁ c₂\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((HomologicalComplex₂.totalFunctor C c₁ c₂ c₁₂).map φ) (HomologicalComplex₂.total.map φ c₁₂)","decl":"/-- The functor which sends a bicomplex to its total complex. -/\n@[simps]\nnoncomputable def totalFunctor :\n    HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂ where\n  obj K := K.total c₁₂\n  map φ := total.map φ c₁₂\n\n"}
{"name":"HomologicalComplex₂.totalFunctor_obj","module":"Mathlib.Algebra.Homology.TotalComplex","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nI₁ : Type u_2\nI₂ : Type u_3\nI₁₂ : Type u_4\nc₁ : ComplexShape I₁\nc₂ : ComplexShape I₂\nc₁₂ : ComplexShape I₁₂\ninst✝² : TotalComplexShape c₁ c₂ c₁₂\ninst✝¹ : DecidableEq I₁₂\ninst✝ : ∀ (K : HomologicalComplex₂ C c₁ c₂), K.HasTotal c₁₂\nK : HomologicalComplex₂ C c₁ c₂\n⊢ Eq ((HomologicalComplex₂.totalFunctor C c₁ c₂ c₁₂).obj K) (K.total c₁₂)","decl":"/-- The functor which sends a bicomplex to its total complex. -/\n@[simps]\nnoncomputable def totalFunctor :\n    HomologicalComplex₂ C c₁ c₂ ⥤ HomologicalComplex C c₁₂ where\n  obj K := K.total c₁₂\n  map φ := total.map φ c₁₂\n\n"}
