{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Î´_eq_zero_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nj : Fin (HAdd.hAdd n 2)\nhjâ‚ : Ne j 0\nhjâ‚‚ : LE.le (HAdd.hAdd n 2) (HAdd.hAdd (â†‘j) q)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.CategoryStruct.comp (X.Î´ j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem comp_Î´_eq_zero {Y : C} {n : â„•} {q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†)\n    (j : Fin (n + 2)) (hjâ‚ : j â‰  0) (hjâ‚‚ : n + 2 â‰¤ (j : â„•) + q) : Ï† â‰« X.Î´ j = 0 := by\n  obtain âŸ¨i, rflâŸ© := Fin.eq_succ_of_ne_zero hjâ‚\n  apply v i\n  simp only [Fin.val_succ] at hjâ‚‚\n  omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Î´_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nj : Fin (HAdd.hAdd n 2)\nhjâ‚ : Ne j 0\nhjâ‚‚ : LE.le (HAdd.hAdd n 2) (HAdd.hAdd (â†‘j) q)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† (X.Î´ j)) 0","decl":"@[reassoc]\ntheorem comp_Î´_eq_zero {Y : C} {n : â„•} {q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†)\n    (j : Fin (n + 2)) (hjâ‚ : j â‰  0) (hjâ‚‚ : n + 2 â‰¤ (j : â„•) + q) : Ï† â‰« X.Î´ j = 0 := by\n  obtain âŸ¨i, rflâŸ© := Fin.eq_succ_of_ne_zero hjâ‚\n  apply v i\n  simp only [Fin.val_succ] at hjâ‚‚\n  omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.of_succ","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd q 1) Ï†\nâŠ¢ AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†","decl":"theorem of_succ {Y : C} {n q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish (q + 1) Ï†) :\n    HigherFacesVanish q Ï† := fun j hj => v j (by simpa only [â† add_assoc] using le_add_right hj)\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.of_comp","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY Z : C\nq n : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nf : Quiver.Hom Z Y\nâŠ¢ AlgebraicTopology.DoldKan.HigherFacesVanish q (CategoryTheory.CategoryStruct.comp f Ï†)","decl":"theorem of_comp {Y Z : C} {q n : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†) (f : Z âŸ¶ Y) :\n    HigherFacesVanish q (f â‰« Ï†) := fun j hj => by rw [assoc, v j hj, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_HÏƒ_eq","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn a q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nhnaq : Eq n (HAdd.hAdd a q)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† ((AlgebraicTopology.DoldKan.HÏƒ q).f (HAdd.hAdd n 1))) (Neg.neg (CategoryTheory.CategoryStruct.comp Ï† (CategoryTheory.CategoryStruct.comp (X.Î´ âŸ¨HAdd.hAdd a 1, â‹¯âŸ©) (X.Ïƒ âŸ¨a, â‹¯âŸ©))))","decl":"theorem comp_HÏƒ_eq {Y : C} {n a q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†)\n    (hnaq : n = a + q) :\n    Ï† â‰« (HÏƒ q).f (n + 1) =\n      -Ï† â‰« X.Î´ âŸ¨a + 1, Nat.succ_lt_succ (Nat.lt_succ_iff.mpr (Nat.le.intro hnaq.symm))âŸ© â‰«\n        X.Ïƒ âŸ¨a, Nat.lt_succ_iff.mpr (Nat.le.intro hnaq.symm)âŸ© := by\n  have hnaq_shift : âˆ€ d : â„•, n + d = a + d + q := by\n    intro d\n    rw [add_assoc, add_comm d, â† add_assoc, hnaq]\n  rw [HÏƒ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl),\n    hÏƒ'_eq hnaq (c_mk (n + 1) n rfl), hÏƒ'_eq (hnaq_shift 1) (c_mk (n + 2) (n + 1) rfl)]\n  simp only [AlternatingFaceMapComplex.obj_d_eq, eqToHom_refl, comp_id, comp_sum, sum_comp,\n    comp_add]\n  simp only [comp_zsmul, zsmul_comp, â† assoc, â† mul_zsmul]\n  -- cleaning up the first sum\n  rw [â† Fin.sum_congr' _ (hnaq_shift 2).symm, Fin.sum_trunc]\n  swap\n  Â· rintro âŸ¨k, hkâŸ©\n    suffices Ï† â‰« X.Î´ (âŸ¨a + 2 + k, by omegaâŸ© : Fin (n + 2)) = 0 by\n      simp only [this, Fin.natAdd_mk, Fin.cast_mk, zero_comp, smul_zero]\n    convert v âŸ¨a + k + 1, by omegaâŸ© (by rw [Fin.val_mk]; omega)\n    dsimp\n    omega\n  -- cleaning up the second sum\n  rw [â† Fin.sum_congr' _ (hnaq_shift 3).symm, @Fin.sum_trunc _ _ (a + 3)]\n  swap\n  Â· rintro âŸ¨k, hkâŸ©\n    rw [assoc, X.Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]\n    Â· simp only [Fin.lt_iff_val_lt_val]\n      dsimp [Fin.natAdd, Fin.cast]\n      omega\n    Â· intro h\n      rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n      dsimp [Fin.cast] at h\n      omega\n    Â· dsimp [Fin.cast, Fin.pred]\n      rw [Nat.add_right_comm, Nat.add_sub_assoc (by norm_num : 1 â‰¤ 3)]\n      omega\n  simp only [assoc]\n  conv_lhs =>\n    congr\n    Â· rw [Fin.sum_univ_castSucc]\n    Â· rw [Fin.sum_univ_castSucc, Fin.sum_univ_castSucc]\n  dsimp [Fin.cast, Fin.castLE, Fin.castLT]\n  /- the purpose of the following `simplif` is to create three subgoals in order\n      to finish the proof -/\n  have simplif :\n    âˆ€ a b c d e f : Y âŸ¶ X _[n + 1], b = f â†’ d + e = 0 â†’ c + a = 0 â†’ a + b + (c + d + e) = f := by\n    intro a b c d e f h1 h2 h3\n    rw [add_assoc c d e, h2, add_zero, add_comm a, add_assoc, add_comm a, h3, add_zero, h1]\n  apply simplif\n  Â· -- b = f\n    rw [â† pow_add, Odd.neg_one_pow, neg_smul, one_zsmul]\n    exact âŸ¨a, by omegaâŸ©\n  Â· -- d + e = 0\n    rw [X.Î´_comp_Ïƒ_self' (Fin.castSucc_mk _ _ _).symm,\n      X.Î´_comp_Ïƒ_succ' (Fin.succ_mk _ _ _).symm]\n    simp only [comp_id, pow_add _ (a + 1) 1, pow_one, mul_neg, mul_one, neg_mul, neg_smul,\n      add_neg_cancel]\n  Â· -- c + a = 0\n    rw [â† Finset.sum_add_distrib]\n    apply Finset.sum_eq_zero\n    rintro âŸ¨i, hiâŸ© _\n    simp only\n    have hia : (âŸ¨i, by omegaâŸ© : Fin (n + 2)) â‰¤\n        Fin.castSucc (âŸ¨a, by omegaâŸ© : Fin (n + 1)) := by\n      rw [Fin.le_iff_val_le_val]\n      dsimp\n      omega\n    erw [Î´_comp_Ïƒ_of_le X hia, add_eq_zero_iff_eq_neg, â† neg_zsmul]\n    congr 2\n    ring\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_HÏƒ_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nhqn : LT.lt n q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Ï† ((AlgebraicTopology.DoldKan.HÏƒ q).f (HAdd.hAdd n 1))) 0","decl":"theorem comp_HÏƒ_eq_zero {Y : C} {n q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†)\n    (hqn : n < q) : Ï† â‰« (HÏƒ q).f (n + 1) = 0 := by\n  simp only [HÏƒ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]\n  rw [hÏƒ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]\n  by_cases hqn' : n + 1 < q\n  Â· rw [hÏƒ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]\n  Â· simp only [hÏƒ'_eq (show n + 1 = 0 + q by omega) (c_mk (n + 2) (n + 1) rfl), pow_zero,\n      Fin.mk_zero, one_zsmul, eqToHom_refl, comp_id, comp_sum,\n      AlternatingFaceMapComplex.obj_d_eq]\n    rw [â† Fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by omega), Fin.sum_trunc]\n    Â· simp only [Fin.sum_univ_castSucc, Fin.sum_univ_zero, zero_add, Fin.last, Fin.castLE_mk,\n        Fin.cast_mk, Fin.castSucc_mk]\n      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one,\n        neg_smul, comp_neg]\n      erw [Î´_comp_Ïƒ_self, Î´_comp_Ïƒ_succ, add_neg_cancel]\n    Â· intro j\n      dsimp [Fin.cast, Fin.castLE, Fin.castLT]\n      rw [comp_zsmul, comp_zsmul, Î´_comp_Ïƒ_of_gt', v.comp_Î´_eq_zero_assoc, zero_comp, zsmul_zero]\n      Â· simp only [Fin.lt_iff_val_lt_val]\n        dsimp [Fin.succ]\n        omega\n      Â· intro h\n        simp only [Fin.pred, Fin.subNat, Fin.ext_iff, Nat.succ_add_sub_one,\n          Fin.val_zero, add_eq_zero, false_and, reduceCtorEq] at h\n      Â· simp only [Fin.pred, Fin.subNat, Nat.pred_eq_sub_one, Nat.succ_add_sub_one]\n        omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.induction","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nÏ† : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q Ï†\nâŠ¢ AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd q 1) (CategoryTheory.CategoryStruct.comp Ï† ((HAdd.hAdd (CategoryTheory.CategoryStruct.id (AlgebraicTopology.AlternatingFaceMapComplex.obj X)) (AlgebraicTopology.DoldKan.HÏƒ q)).f (HAdd.hAdd n 1)))","decl":"theorem induction {Y : C} {n q : â„•} {Ï† : Y âŸ¶ X _[n + 1]} (v : HigherFacesVanish q Ï†) :\n    HigherFacesVanish (q + 1) (Ï† â‰« (ğŸ™ _ + HÏƒ q).f (n + 1)) := by\n  intro j hjâ‚\n  dsimp\n  simp only [comp_add, add_comp, comp_id]\n  -- when n < q, the result follows immediately from the assumption\n  by_cases hqn : n < q\n  Â· rw [v.comp_HÏƒ_eq_zero hqn, zero_comp, add_zero, v j (by omega)]\n  -- we now assume that nâ‰¥q, and write n=a+q\n  cases' Nat.le.dest (not_lt.mp hqn) with a ha\n  rw [v.comp_HÏƒ_eq (show n = a + q by omega), neg_comp, add_neg_eq_zero, assoc, assoc]\n  cases' n with m hm\n  -- the boundary case n=0\n  Â· simp only [Nat.eq_zero_of_add_eq_zero_left ha, Fin.eq_zero j, Fin.mk_zero, Fin.mk_one,\n      Î´_comp_Ïƒ_succ, comp_id]\n    rfl\n  -- in the other case, we need to write n as m+1\n  -- then, we first consider the particular case j = a\n  by_cases hjâ‚‚ : a = (j : â„•)\n  Â· simp only [hjâ‚‚, Fin.eta, Î´_comp_Ïƒ_succ, comp_id]\n    rfl\n  -- now, we assume j â‰  a (i.e. a < j)\n  have haj : a < j := (Ne.le_iff_lt hjâ‚‚).mp (by omega)\n  have ham : a â‰¤ m := by omega\n  rw [X.Î´_comp_Ïƒ_of_gt', j.pred_succ]\n  swap\n  Â· rw [Fin.lt_iff_val_lt_val]\n    simpa only [Fin.val_mk, Fin.val_succ, add_lt_add_iff_right] using haj\n  obtain _ | ham'' := ham.lt_or_eq\n  Â· -- case where `a<m`\n    rw [â† X.Î´_comp_Î´''_assoc]\n    swap\n    Â· rw [Fin.le_iff_val_le_val]\n      dsimp\n      omega\n    simp only [â† assoc, v j (by omega), zero_comp]\n  Â· -- in the last case, a=m, q=1 and j=a+1\n    rw [X.Î´_comp_Î´_self'_assoc]\n    swap\n    Â· ext\n      cases j\n      dsimp\n      dsimp only [Nat.succ_eq_add_one] at *\n      omega\n    simp only [â† assoc, v j (by omega), zero_comp]\n\n"}
