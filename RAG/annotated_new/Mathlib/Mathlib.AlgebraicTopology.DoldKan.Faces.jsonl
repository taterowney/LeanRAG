{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_δ_eq_zero_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nj : Fin (HAdd.hAdd n 2)\nhj₁ : Ne j 0\nhj₂ : LE.le (HAdd.hAdd n 2) (HAdd.hAdd (↑j) q)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (X.δ j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\ntheorem comp_δ_eq_zero {Y : C} {n : ℕ} {q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)\n    (j : Fin (n + 2)) (hj₁ : j ≠ 0) (hj₂ : n + 2 ≤ (j : ℕ) + q) : φ ≫ X.δ j = 0 := by\n  obtain ⟨i, rfl⟩ := Fin.eq_succ_of_ne_zero hj₁\n  apply v i\n  simp only [Fin.val_succ] at hj₂\n  omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_δ_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nj : Fin (HAdd.hAdd n 2)\nhj₁ : Ne j 0\nhj₂ : LE.le (HAdd.hAdd n 2) (HAdd.hAdd (↑j) q)\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ (X.δ j)) 0","decl":"@[reassoc]\ntheorem comp_δ_eq_zero {Y : C} {n : ℕ} {q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)\n    (j : Fin (n + 2)) (hj₁ : j ≠ 0) (hj₂ : n + 2 ≤ (j : ℕ) + q) : φ ≫ X.δ j = 0 := by\n  obtain ⟨i, rfl⟩ := Fin.eq_succ_of_ne_zero hj₁\n  apply v i\n  simp only [Fin.val_succ] at hj₂\n  omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.of_succ","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd q 1) φ\n⊢ AlgebraicTopology.DoldKan.HigherFacesVanish q φ","decl":"theorem of_succ {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish (q + 1) φ) :\n    HigherFacesVanish q φ := fun j hj => v j (by simpa only [← add_assoc] using le_add_right hj)\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.of_comp","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY Z : C\nq n : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nf : Quiver.Hom Z Y\n⊢ AlgebraicTopology.DoldKan.HigherFacesVanish q (CategoryTheory.CategoryStruct.comp f φ)","decl":"theorem of_comp {Y Z : C} {q n : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ) (f : Z ⟶ Y) :\n    HigherFacesVanish q (f ≫ φ) := fun j hj => by rw [assoc, v j hj, comp_zero]\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Hσ_eq","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn a q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nhnaq : Eq n (HAdd.hAdd a q)\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ ((AlgebraicTopology.DoldKan.Hσ q).f (HAdd.hAdd n 1))) (Neg.neg (CategoryTheory.CategoryStruct.comp φ (CategoryTheory.CategoryStruct.comp (X.δ ⟨HAdd.hAdd a 1, ⋯⟩) (X.σ ⟨a, ⋯⟩))))","decl":"theorem comp_Hσ_eq {Y : C} {n a q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)\n    (hnaq : n = a + q) :\n    φ ≫ (Hσ q).f (n + 1) =\n      -φ ≫ X.δ ⟨a + 1, Nat.succ_lt_succ (Nat.lt_succ_iff.mpr (Nat.le.intro hnaq.symm))⟩ ≫\n        X.σ ⟨a, Nat.lt_succ_iff.mpr (Nat.le.intro hnaq.symm)⟩ := by\n  have hnaq_shift : ∀ d : ℕ, n + d = a + d + q := by\n    intro d\n    rw [add_assoc, add_comm d, ← add_assoc, hnaq]\n  rw [Hσ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl),\n    hσ'_eq hnaq (c_mk (n + 1) n rfl), hσ'_eq (hnaq_shift 1) (c_mk (n + 2) (n + 1) rfl)]\n  simp only [AlternatingFaceMapComplex.obj_d_eq, eqToHom_refl, comp_id, comp_sum, sum_comp,\n    comp_add]\n  simp only [comp_zsmul, zsmul_comp, ← assoc, ← mul_zsmul]\n  -- cleaning up the first sum\n  rw [← Fin.sum_congr' _ (hnaq_shift 2).symm, Fin.sum_trunc]\n  swap\n  · rintro ⟨k, hk⟩\n    suffices φ ≫ X.δ (⟨a + 2 + k, by omega⟩ : Fin (n + 2)) = 0 by\n      simp only [this, Fin.natAdd_mk, Fin.cast_mk, zero_comp, smul_zero]\n    convert v ⟨a + k + 1, by omega⟩ (by rw [Fin.val_mk]; omega)\n    dsimp\n    omega\n  -- cleaning up the second sum\n  rw [← Fin.sum_congr' _ (hnaq_shift 3).symm, @Fin.sum_trunc _ _ (a + 3)]\n  swap\n  · rintro ⟨k, hk⟩\n    rw [assoc, X.δ_comp_σ_of_gt', v.comp_δ_eq_zero_assoc, zero_comp, zsmul_zero]\n    · simp only [Fin.lt_iff_val_lt_val]\n      dsimp [Fin.natAdd, Fin.cast]\n      omega\n    · intro h\n      rw [Fin.pred_eq_iff_eq_succ, Fin.ext_iff] at h\n      dsimp [Fin.cast] at h\n      omega\n    · dsimp [Fin.cast, Fin.pred]\n      rw [Nat.add_right_comm, Nat.add_sub_assoc (by norm_num : 1 ≤ 3)]\n      omega\n  simp only [assoc]\n  conv_lhs =>\n    congr\n    · rw [Fin.sum_univ_castSucc]\n    · rw [Fin.sum_univ_castSucc, Fin.sum_univ_castSucc]\n  dsimp [Fin.cast, Fin.castLE, Fin.castLT]\n  /- the purpose of the following `simplif` is to create three subgoals in order\n      to finish the proof -/\n  have simplif :\n    ∀ a b c d e f : Y ⟶ X _[n + 1], b = f → d + e = 0 → c + a = 0 → a + b + (c + d + e) = f := by\n    intro a b c d e f h1 h2 h3\n    rw [add_assoc c d e, h2, add_zero, add_comm a, add_assoc, add_comm a, h3, add_zero, h1]\n  apply simplif\n  · -- b = f\n    rw [← pow_add, Odd.neg_one_pow, neg_smul, one_zsmul]\n    exact ⟨a, by omega⟩\n  · -- d + e = 0\n    rw [X.δ_comp_σ_self' (Fin.castSucc_mk _ _ _).symm,\n      X.δ_comp_σ_succ' (Fin.succ_mk _ _ _).symm]\n    simp only [comp_id, pow_add _ (a + 1) 1, pow_one, mul_neg, mul_one, neg_mul, neg_smul,\n      add_neg_cancel]\n  · -- c + a = 0\n    rw [← Finset.sum_add_distrib]\n    apply Finset.sum_eq_zero\n    rintro ⟨i, hi⟩ _\n    simp only\n    have hia : (⟨i, by omega⟩ : Fin (n + 2)) ≤\n        Fin.castSucc (⟨a, by omega⟩ : Fin (n + 1)) := by\n      rw [Fin.le_iff_val_le_val]\n      dsimp\n      omega\n    erw [δ_comp_σ_of_le X hia, add_eq_zero_iff_eq_neg, ← neg_zsmul]\n    congr 2\n    ring\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.comp_Hσ_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\nhqn : LT.lt n q\n⊢ Eq (CategoryTheory.CategoryStruct.comp φ ((AlgebraicTopology.DoldKan.Hσ q).f (HAdd.hAdd n 1))) 0","decl":"theorem comp_Hσ_eq_zero {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ)\n    (hqn : n < q) : φ ≫ (Hσ q).f (n + 1) = 0 := by\n  simp only [Hσ, Homotopy.nullHomotopicMap'_f (c_mk (n + 2) (n + 1) rfl) (c_mk (n + 1) n rfl)]\n  rw [hσ'_eq_zero hqn (c_mk (n + 1) n rfl), comp_zero, zero_add]\n  by_cases hqn' : n + 1 < q\n  · rw [hσ'_eq_zero hqn' (c_mk (n + 2) (n + 1) rfl), zero_comp, comp_zero]\n  · simp only [hσ'_eq (show n + 1 = 0 + q by omega) (c_mk (n + 2) (n + 1) rfl), pow_zero,\n      Fin.mk_zero, one_zsmul, eqToHom_refl, comp_id, comp_sum,\n      AlternatingFaceMapComplex.obj_d_eq]\n    rw [← Fin.sum_congr' _ (show 2 + (n + 1) = n + 1 + 2 by omega), Fin.sum_trunc]\n    · simp only [Fin.sum_univ_castSucc, Fin.sum_univ_zero, zero_add, Fin.last, Fin.castLE_mk,\n        Fin.cast_mk, Fin.castSucc_mk]\n      simp only [Fin.mk_zero, Fin.val_zero, pow_zero, one_zsmul, Fin.mk_one, Fin.val_one, pow_one,\n        neg_smul, comp_neg]\n      erw [δ_comp_σ_self, δ_comp_σ_succ, add_neg_cancel]\n    · intro j\n      dsimp [Fin.cast, Fin.castLE, Fin.castLT]\n      rw [comp_zsmul, comp_zsmul, δ_comp_σ_of_gt', v.comp_δ_eq_zero_assoc, zero_comp, zsmul_zero]\n      · simp only [Fin.lt_iff_val_lt_val]\n        dsimp [Fin.succ]\n        omega\n      · intro h\n        simp only [Fin.pred, Fin.subNat, Fin.ext_iff, Nat.succ_add_sub_one,\n          Fin.val_zero, add_eq_zero, false_and, reduceCtorEq] at h\n      · simp only [Fin.pred, Fin.subNat, Nat.pred_eq_sub_one, Nat.succ_add_sub_one]\n        omega\n\n"}
{"name":"AlgebraicTopology.DoldKan.HigherFacesVanish.induction","module":"Mathlib.AlgebraicTopology.DoldKan.Faces","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\nY : C\nn q : Nat\nφ : Quiver.Hom Y (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\nv : AlgebraicTopology.DoldKan.HigherFacesVanish q φ\n⊢ AlgebraicTopology.DoldKan.HigherFacesVanish (HAdd.hAdd q 1) (CategoryTheory.CategoryStruct.comp φ ((HAdd.hAdd (CategoryTheory.CategoryStruct.id (AlgebraicTopology.AlternatingFaceMapComplex.obj X)) (AlgebraicTopology.DoldKan.Hσ q)).f (HAdd.hAdd n 1)))","decl":"theorem induction {Y : C} {n q : ℕ} {φ : Y ⟶ X _[n + 1]} (v : HigherFacesVanish q φ) :\n    HigherFacesVanish (q + 1) (φ ≫ (𝟙 _ + Hσ q).f (n + 1)) := by\n  intro j hj₁\n  dsimp\n  simp only [comp_add, add_comp, comp_id]\n  -- when n < q, the result follows immediately from the assumption\n  by_cases hqn : n < q\n  · rw [v.comp_Hσ_eq_zero hqn, zero_comp, add_zero, v j (by omega)]\n  -- we now assume that n≥q, and write n=a+q\n  cases' Nat.le.dest (not_lt.mp hqn) with a ha\n  rw [v.comp_Hσ_eq (show n = a + q by omega), neg_comp, add_neg_eq_zero, assoc, assoc]\n  cases' n with m hm\n  -- the boundary case n=0\n  · simp only [Nat.eq_zero_of_add_eq_zero_left ha, Fin.eq_zero j, Fin.mk_zero, Fin.mk_one,\n      δ_comp_σ_succ, comp_id]\n    rfl\n  -- in the other case, we need to write n as m+1\n  -- then, we first consider the particular case j = a\n  by_cases hj₂ : a = (j : ℕ)\n  · simp only [hj₂, Fin.eta, δ_comp_σ_succ, comp_id]\n    rfl\n  -- now, we assume j ≠ a (i.e. a < j)\n  have haj : a < j := (Ne.le_iff_lt hj₂).mp (by omega)\n  have ham : a ≤ m := by omega\n  rw [X.δ_comp_σ_of_gt', j.pred_succ]\n  swap\n  · rw [Fin.lt_iff_val_lt_val]\n    simpa only [Fin.val_mk, Fin.val_succ, add_lt_add_iff_right] using haj\n  obtain _ | ham'' := ham.lt_or_eq\n  · -- case where `a<m`\n    rw [← X.δ_comp_δ''_assoc]\n    swap\n    · rw [Fin.le_iff_val_le_val]\n      dsimp\n      omega\n    simp only [← assoc, v j (by omega), zero_comp]\n  · -- in the last case, a=m, q=1 and j=a+1\n    rw [X.δ_comp_δ_self'_assoc]\n    swap\n    · ext\n      cases j\n      dsimp\n      dsimp only [Nat.succ_eq_add_one] at *\n      omega\n    simp only [← assoc, v j (by omega), zero_comp]\n\n"}
