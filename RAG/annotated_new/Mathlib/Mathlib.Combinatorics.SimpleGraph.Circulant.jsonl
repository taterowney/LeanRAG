{"name":"SimpleGraph.circulantGraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\na b : G\n⊢ Eq ((SimpleGraph.circulantGraph s).Adj a b) (And (Not (Eq a b)) (Or (Membership.mem s (HSub.hSub a b)) (Membership.mem s (HSub.hSub b a))))","decl":"/-- Circulant graph over additive group `G` with jumps `s` -/\n@[simps!]\ndef circulantGraph {G : Type*} [AddGroup G] (s : Set G) : SimpleGraph G :=\n  fromRel (· - · ∈ s)\n\n"}
{"name":"SimpleGraph.circulantGraph_eq_erase_zero","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\n⊢ Eq (SimpleGraph.circulantGraph s) (SimpleGraph.circulantGraph (SDiff.sdiff s (Singleton.singleton 0)))","decl":"theorem circulantGraph_eq_erase_zero : circulantGraph s = circulantGraph (s \\ {0}) := by\n  ext (u v : G)\n  simp only [circulantGraph, fromRel_adj, and_congr_right_iff]\n  intro (h : u ≠ v)\n  apply Iff.intro\n  · intro h1\n    cases h1 with\n      | inl h1 => exact Or.inl ⟨h1, sub_ne_zero_of_ne h⟩\n      | inr h1 => exact Or.inr ⟨h1, sub_ne_zero_of_ne h.symm⟩\n  · intro h1\n    cases h1 with\n      | inl h1 => exact Or.inl h1.left\n      | inr h1 => exact Or.inr h1.left\n\n"}
{"name":"SimpleGraph.circulantGraph_eq_symm","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\n⊢ Eq (SimpleGraph.circulantGraph s) (SimpleGraph.circulantGraph (Union.union s (Neg.neg s)))","decl":"theorem circulantGraph_eq_symm : circulantGraph s = circulantGraph (s ∪ (-s)) := by\n  ext (u v : G)\n  simp only [circulantGraph, fromRel_adj, Set.mem_union, Set.mem_neg, neg_sub, and_congr_right_iff,\n    iff_self_or]\n  intro _ h\n  exact Or.symm h\n\n"}
{"name":"SimpleGraph.circulantGraph_adj_translate","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ns : Set G\nu v d : G\n⊢ Iff ((SimpleGraph.circulantGraph s).Adj (HAdd.hAdd u d) (HAdd.hAdd v d)) ((SimpleGraph.circulantGraph s).Adj u v)","decl":"theorem circulantGraph_adj_translate {s : Set G} {u v d : G} :\n    (circulantGraph s).Adj (u + d) (v + d) ↔ (circulantGraph s).Adj u v := by simp\n\n"}
{"name":"SimpleGraph.cycleGraph_zero_adj","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"u v : Fin 0\n⊢ Not ((SimpleGraph.cycleGraph 0).Adj u v)","decl":"theorem cycleGraph_zero_adj {u v : Fin 0} : ¬(cycleGraph 0).Adj u v := id\n\n"}
{"name":"SimpleGraph.cycleGraph_zero_eq_bot","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 0) Bot.bot","decl":"theorem cycleGraph_zero_eq_bot : cycleGraph 0 = ⊥ := Subsingleton.elim _ _\n"}
{"name":"SimpleGraph.cycleGraph_one_eq_bot","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 1) Bot.bot","decl":"theorem cycleGraph_one_eq_bot : cycleGraph 1 = ⊥ := Subsingleton.elim _ _\n"}
{"name":"SimpleGraph.cycleGraph_zero_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 0) Top.top","decl":"theorem cycleGraph_zero_eq_top : cycleGraph 0 = ⊤ := Subsingleton.elim _ _\n"}
{"name":"SimpleGraph.cycleGraph_one_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 1) Top.top","decl":"theorem cycleGraph_one_eq_top : cycleGraph 1 = ⊤ := Subsingleton.elim _ _\n\n"}
{"name":"SimpleGraph.cycleGraph_two_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 2) Top.top","decl":"theorem cycleGraph_two_eq_top : cycleGraph 2 = ⊤ := by\n  simp only [SimpleGraph.ext_iff, funext_iff]\n  decide\n\n"}
{"name":"SimpleGraph.cycleGraph_three_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"⊢ Eq (SimpleGraph.cycleGraph 3) Top.top","decl":"theorem cycleGraph_three_eq_top : cycleGraph 3 = ⊤ := by\n  simp only [SimpleGraph.ext_iff, funext_iff]\n  decide\n\n"}
{"name":"SimpleGraph.cycleGraph_one_adj","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"u v : Fin 1\n⊢ Not ((SimpleGraph.cycleGraph 1).Adj u v)","decl":"theorem cycleGraph_one_adj {u v : Fin 1} : ¬(cycleGraph 1).Adj u v := by\n  rw [cycleGraph_one_eq_bot]\n  exact id\n\n"}
{"name":"SimpleGraph.cycleGraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nu v : Fin (HAdd.hAdd n 2)\n⊢ Iff ((SimpleGraph.cycleGraph (HAdd.hAdd n 2)).Adj u v) (Or (Eq (HSub.hSub u v) 1) (Eq (HSub.hSub v u) 1))","decl":"theorem cycleGraph_adj {n : ℕ} {u v : Fin (n + 2)} :\n    (cycleGraph (n + 2)).Adj u v ↔ u - v = 1 ∨ v - u = 1 := by\n  simp only [cycleGraph, circulantGraph_adj, Set.mem_singleton_iff, and_iff_right_iff_imp]\n  intro _ _\n  simp_all\n\n"}
{"name":"SimpleGraph.cycleGraph_adj'","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nu v : Fin n\n⊢ Iff ((SimpleGraph.cycleGraph n).Adj u v) (Or (Eq (↑(HSub.hSub u v)) 1) (Eq (↑(HSub.hSub v u)) 1))","decl":"theorem cycleGraph_adj' {n : ℕ} {u v : Fin n} :\n    (cycleGraph n).Adj u v ↔ (u - v).val = 1 ∨ (v - u).val = 1 := by\n  match n with\n  | 0 => exact u.elim0\n  | 1 => simp [cycleGraph_one_adj]\n  | n + 2 => simp [cycleGraph_adj, Fin.ext_iff]\n\n"}
{"name":"SimpleGraph.cycleGraph_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nv : Fin (HAdd.hAdd n 2)\n⊢ Eq ((SimpleGraph.cycleGraph (HAdd.hAdd n 2)).neighborSet v) (Insert.insert (HSub.hSub v 1) (Singleton.singleton (HAdd.hAdd v 1)))","decl":"theorem cycleGraph_neighborSet {n : ℕ} {v : Fin (n + 2)} :\n    (cycleGraph (n + 2)).neighborSet v = {v - 1, v + 1} := by\n  ext w\n  simp only [mem_neighborSet, Set.mem_insert_iff, Set.mem_singleton_iff]\n  rw [cycleGraph_adj, sub_eq_iff_eq_add', sub_eq_iff_eq_add', eq_sub_iff_add_eq, eq_comm]\n\n"}
{"name":"SimpleGraph.cycleGraph_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nv : Fin (HAdd.hAdd n 2)\n⊢ Eq ((SimpleGraph.cycleGraph (HAdd.hAdd n 2)).neighborFinset v) (Insert.insert (HSub.hSub v 1) (Singleton.singleton (HAdd.hAdd v 1)))","decl":"theorem cycleGraph_neighborFinset {n : ℕ} {v : Fin (n + 2)} :\n    (cycleGraph (n + 2)).neighborFinset v = {v - 1, v + 1} := by\n  simp [neighborFinset, cycleGraph_neighborSet]\n\n"}
{"name":"SimpleGraph.cycleGraph_degree_two_le","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nv : Fin (HAdd.hAdd n 2)\n⊢ Eq ((SimpleGraph.cycleGraph (HAdd.hAdd n 2)).degree v) (Insert.insert (HSub.hSub v 1) (Singleton.singleton (HAdd.hAdd v 1))).card","decl":"theorem cycleGraph_degree_two_le {n : ℕ} {v : Fin (n + 2)} :\n    (cycleGraph (n + 2)).degree v = Finset.card {v - 1, v + 1} := by\n  rw [SimpleGraph.degree, cycleGraph_neighborFinset]\n\n"}
{"name":"SimpleGraph.cycleGraph_degree_three_le","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\nv : Fin (HAdd.hAdd n 3)\n⊢ Eq ((SimpleGraph.cycleGraph (HAdd.hAdd n 3)).degree v) 2","decl":"theorem cycleGraph_degree_three_le {n : ℕ} {v : Fin (n + 3)} :\n    (cycleGraph (n + 3)).degree v = 2 := by\n  rw [cycleGraph_degree_two_le, Finset.card_pair]\n  simp only [ne_eq, sub_eq_iff_eq_add, add_assoc v, self_eq_add_right]\n  exact ne_of_beq_false rfl\n\n"}
{"name":"SimpleGraph.pathGraph_le_cycleGraph","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\n⊢ LE.le (SimpleGraph.pathGraph n) (SimpleGraph.cycleGraph n)","decl":"theorem pathGraph_le_cycleGraph {n : ℕ} : pathGraph n ≤ cycleGraph n := by\n  match n with\n  | 0 | 1 => simp\n  | n + 2 =>\n    intro u v h\n    rw [pathGraph_adj] at h\n    rw [cycleGraph_adj']\n    cases h with\n    | inl h | inr h =>\n      simp [Fin.coe_sub_iff_le.mpr (Nat.lt_of_succ_le h.le).le, Nat.eq_sub_of_add_eq' h]\n\n"}
{"name":"SimpleGraph.cycleGraph_preconnected","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\n⊢ (SimpleGraph.cycleGraph n).Preconnected","decl":"theorem cycleGraph_preconnected {n : ℕ} : (cycleGraph n).Preconnected :=\n  (pathGraph_preconnected n).mono pathGraph_le_cycleGraph\n\n"}
{"name":"SimpleGraph.cycleGraph_connected","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\n⊢ (SimpleGraph.cycleGraph (HAdd.hAdd n 1)).Connected","decl":"theorem cycleGraph_connected {n : ℕ} : (cycleGraph (n + 1)).Connected :=\n  (pathGraph_connected n).mono pathGraph_le_cycleGraph\n\n"}
{"name":"SimpleGraph.cycleGraph_EulerianCircuit_length","module":"Mathlib.Combinatorics.SimpleGraph.Circulant","initialProofState":"n : Nat\n⊢ Eq (SimpleGraph.cycleGraph_EulerianCircuit n).length (HAdd.hAdd n 3)","decl":"theorem cycleGraph_EulerianCircuit_length {n : ℕ} :\n    (cycleGraph_EulerianCircuit n).length = n + 3 := by\n  unfold cycleGraph_EulerianCircuit\n  simp [cycleGraph_EulerianCircuit_cons_length]\n\n"}
