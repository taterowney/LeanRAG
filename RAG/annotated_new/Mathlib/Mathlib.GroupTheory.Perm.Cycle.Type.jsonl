{"name":"Equiv.Perm.cycleType_def","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq σ.cycleType (Multiset.map (Function.comp Finset.card Equiv.Perm.support) σ.cycleFactorsFinset.val)","decl":"theorem cycleType_def (σ : Perm α) :\n    σ.cycleType = σ.cycleFactorsFinset.1.map (Finset.card ∘ support) :=\n  rfl\n\n"}
{"name":"Equiv.Perm.cycleType_eq'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\ns : Finset (Equiv.Perm α)\nh1 : ∀ (f : Equiv.Perm α), Membership.mem s f → f.IsCycle\nh2 : (↑s).Pairwise Equiv.Perm.Disjoint\nh0 : Eq (s.noncommProd id ⋯) σ\n⊢ Eq σ.cycleType (Multiset.map (Function.comp Finset.card Equiv.Perm.support) s.val)","decl":"theorem cycleType_eq' {σ : Perm α} (s : Finset (Perm α)) (h1 : ∀ f : Perm α, f ∈ s → f.IsCycle)\n    (h2 : (s : Set (Perm α)).Pairwise Disjoint)\n    (h0 : s.noncommProd id (h2.imp fun _ _ => Disjoint.commute) = σ) :\n    σ.cycleType = s.1.map (Finset.card ∘ support) := by\n  rw [cycleType_def]\n  congr\n  rw [cycleFactorsFinset_eq_finset]\n  exact ⟨h1, h2, h0⟩\n\n"}
{"name":"Equiv.Perm.cycleType_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nl : List (Equiv.Perm α)\nh0 : Eq l.prod σ\nh1 : ∀ (σ : Equiv.Perm α), Membership.mem l σ → σ.IsCycle\nh2 : List.Pairwise Equiv.Perm.Disjoint l\n⊢ Eq σ.cycleType ↑(List.map (Function.comp Finset.card Equiv.Perm.support) l)","decl":"theorem cycleType_eq {σ : Perm α} (l : List (Perm α)) (h0 : l.prod = σ)\n    (h1 : ∀ σ : Perm α, σ ∈ l → σ.IsCycle) (h2 : l.Pairwise Disjoint) :\n    σ.cycleType = l.map (Finset.card ∘ support) := by\n  have hl : l.Nodup := nodup_of_pairwise_disjoint_cycles h1 h2\n  rw [cycleType_eq' l.toFinset]\n  · simp [List.dedup_eq_self.mpr hl, Function.comp_def]\n  · simpa using h1\n  · simpa [hl] using h2\n  · simp [hl, h0]\n\n"}
{"name":"Equiv.Perm.CycleType.count_def","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nn : Nat\n⊢ Eq (Multiset.count n σ.cycleType) (Fintype.card (Subtype fun c => Eq (↑c).support.card n))","decl":"theorem CycleType.count_def {σ : Perm α} (n : ℕ) :\n    σ.cycleType.count n =\n      Fintype.card {c : σ.cycleFactorsFinset // (c : Perm α).support.card = n } := by\n  -- work on the LHS\n  rw [cycleType, Multiset.count_eq_card_filter_eq]\n  -- rewrite the `Fintype.card` as a `Finset.card`\n  rw [Fintype.subtype_card, Finset.univ_eq_attach, Finset.filter_attach',\n    Finset.card_map, Finset.card_attach]\n  simp only [Function.comp_apply, Finset.card, Finset.filter_val,\n    Multiset.filter_map, Multiset.card_map]\n  congr 1\n  apply Multiset.filter_congr\n  intro d h\n  simp only [Function.comp_apply, eq_comm, Finset.mem_val.mp h, exists_const]\n\n"}
{"name":"Equiv.Perm.cycleType_eq_zero","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Iff (Eq σ.cycleType 0) (Eq σ 1)","decl":"@[simp] -- Porting note: new attr\ntheorem cycleType_eq_zero {σ : Perm α} : σ.cycleType = 0 ↔ σ = 1 := by\n  simp [cycleType_def, cycleFactorsFinset_eq_empty_iff]\n\n"}
{"name":"Equiv.Perm.cycleType_one","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n⊢ Eq (Equiv.Perm.cycleType 1) 0","decl":"@[simp] -- Porting note: new attr\ntheorem cycleType_one : (1 : Perm α).cycleType = 0 := cycleType_eq_zero.2 rfl\n\n"}
{"name":"Equiv.Perm.card_cycleType_eq_zero","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Iff (Eq σ.cycleType.card 0) (Eq σ 1)","decl":"theorem card_cycleType_eq_zero {σ : Perm α} : Multiset.card σ.cycleType = 0 ↔ σ = 1 := by\n  rw [card_eq_zero, cycleType_eq_zero]\n\n"}
{"name":"Equiv.Perm.card_cycleType_pos","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Iff (LT.lt 0 σ.cycleType.card) (Ne σ 1)","decl":"theorem card_cycleType_pos {σ : Perm α} : 0 < Multiset.card σ.cycleType ↔ σ ≠ 1 :=\n  pos_iff_ne_zero.trans card_cycleType_eq_zero.not\n\n"}
{"name":"Equiv.Perm.two_le_of_mem_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nn : Nat\nh : Membership.mem σ.cycleType n\n⊢ LE.le 2 n","decl":"theorem two_le_of_mem_cycleType {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycleType) : 2 ≤ n := by\n  simp only [cycleType_def, ← Finset.mem_def, Function.comp_apply, Multiset.mem_map,\n    mem_cycleFactorsFinset_iff] at h\n  obtain ⟨_, ⟨hc, -⟩, rfl⟩ := h\n  exact hc.two_le_card_support\n\n"}
{"name":"Equiv.Perm.one_lt_of_mem_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nn : Nat\nh : Membership.mem σ.cycleType n\n⊢ LT.lt 1 n","decl":"theorem one_lt_of_mem_cycleType {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycleType) : 1 < n :=\n  two_le_of_mem_cycleType h\n\n"}
{"name":"Equiv.Perm.IsCycle.cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nhσ : σ.IsCycle\n⊢ Eq σ.cycleType ↑(List.cons σ.support.card List.nil)","decl":"theorem IsCycle.cycleType {σ : Perm α} (hσ : IsCycle σ) : σ.cycleType = [σ.support.card] :=\n  cycleType_eq [σ] (mul_one σ) (fun _τ hτ => (congr_arg IsCycle (List.mem_singleton.mp hτ)).mpr hσ)\n    (List.pairwise_singleton Disjoint σ)\n\n"}
{"name":"Equiv.Perm.card_cycleType_eq_one","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Iff (Eq σ.cycleType.card 1) σ.IsCycle","decl":"theorem card_cycleType_eq_one {σ : Perm α} : Multiset.card σ.cycleType = 1 ↔ σ.IsCycle := by\n  rw [card_eq_one]\n  simp_rw [cycleType_def, Multiset.map_eq_singleton, ← Finset.singleton_val, Finset.val_inj,\n    cycleFactorsFinset_eq_singleton_iff]\n  constructor\n  · rintro ⟨_, _, ⟨h, -⟩, -⟩\n    exact h\n  · intro h\n    use σ.support.card, σ\n    simp [h]\n\n"}
{"name":"Equiv.Perm.Disjoint.cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\nh : σ.Disjoint τ\n⊢ Eq (HMul.hMul σ τ).cycleType (HAdd.hAdd σ.cycleType τ.cycleType)","decl":"theorem Disjoint.cycleType {σ τ : Perm α} (h : Disjoint σ τ) :\n    (σ * τ).cycleType = σ.cycleType + τ.cycleType := by\n  rw [cycleType_def, cycleType_def, cycleType_def, h.cycleFactorsFinset_mul_eq_union, ←\n    Multiset.map_add, Finset.union_val, Multiset.add_eq_union_iff_disjoint.mpr _]\n  exact Finset.disjoint_val.2 h.disjoint_cycleFactorsFinset\n\n"}
{"name":"Equiv.Perm.cycleType_inv","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq (Inv.inv σ).cycleType σ.cycleType","decl":"@[simp] -- Porting note: new attr\ntheorem cycleType_inv (σ : Perm α) : σ⁻¹.cycleType = σ.cycleType :=\n  cycle_induction_on (P := fun τ : Perm α => τ⁻¹.cycleType = τ.cycleType) σ rfl\n    (fun σ hσ => by simp only [hσ.cycleType, hσ.inv.cycleType, support_inv])\n    fun σ τ hστ _ hσ hτ => by\n      simp only [mul_inv_rev, hστ.cycleType, hστ.symm.inv_left.inv_right.cycleType, hσ, hτ,\n        add_comm]\n\n"}
{"name":"Equiv.Perm.cycleType_conj","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\n⊢ Eq (HMul.hMul (HMul.hMul τ σ) (Inv.inv τ)).cycleType σ.cycleType","decl":"@[simp] -- Porting note: new attr\ntheorem cycleType_conj {σ τ : Perm α} : (τ * σ * τ⁻¹).cycleType = σ.cycleType := by\n  induction σ using cycle_induction_on with\n  | base_one => simp\n  | base_cycles σ hσ => rw [hσ.cycleType, hσ.conj.cycleType, card_support_conj]\n  | induction_disjoint σ π hd _ hσ hπ =>\n    rw [← conj_mul, hd.cycleType, (hd.conj _).cycleType, hσ, hπ]\n\n"}
{"name":"Equiv.Perm.sum_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq σ.cycleType.sum σ.support.card","decl":"theorem sum_cycleType (σ : Perm α) : σ.cycleType.sum = σ.support.card := by\n  induction σ using cycle_induction_on with\n  | base_one => simp\n  | base_cycles σ hσ => rw [hσ.cycleType, sum_coe, List.sum_singleton]\n  | induction_disjoint σ τ hd _ hσ hτ => rw [hd.cycleType, sum_add, hσ, hτ, hd.card_support_mul]\n\n"}
{"name":"Equiv.Perm.card_fixedPoints","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq (Fintype.card ↑(Function.fixedPoints ⇑σ)) (HSub.hSub (Fintype.card α) σ.cycleType.sum)","decl":"theorem card_fixedPoints (σ : Equiv.Perm α) :\n    Fintype.card (Function.fixedPoints σ) = Fintype.card α - σ.cycleType.sum := by\n  rw [Equiv.Perm.sum_cycleType, ← Finset.card_compl, Fintype.card_ofFinset]\n  congr; aesop\n\n"}
{"name":"Equiv.Perm.sign_of_cycleType'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign σ) (Multiset.map (fun n => Neg.neg (HPow.hPow (-1) n)) σ.cycleType).prod","decl":"theorem sign_of_cycleType' (σ : Perm α) :\n    sign σ = (σ.cycleType.map fun n => -(-1 : ℤˣ) ^ n).prod := by\n  induction σ using cycle_induction_on with\n  | base_one => simp\n  | base_cycles σ hσ => simp [hσ.cycleType, hσ.sign]\n  | induction_disjoint σ τ hd _ hσ hτ => simp [hσ, hτ, hd.cycleType]\n\n"}
{"name":"Equiv.Perm.sign_of_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\n⊢ Eq (Equiv.Perm.sign f) (HPow.hPow (-1) (HAdd.hAdd f.cycleType.sum f.cycleType.card))","decl":"theorem sign_of_cycleType (f : Perm α) :\n    sign f = (-1 : ℤˣ) ^ (f.cycleType.sum + Multiset.card f.cycleType) := by\n  rw [sign_of_cycleType']\n  induction' f.cycleType using Multiset.induction_on with a s ihs\n  · rfl\n  · rw [Multiset.map_cons, Multiset.prod_cons, Multiset.sum_cons, Multiset.card_cons, ihs]\n    simp only [pow_add, pow_one, mul_neg_one, neg_mul, mul_neg, mul_assoc, mul_one]\n\n"}
{"name":"Equiv.Perm.lcm_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq σ.cycleType.lcm (orderOf σ)","decl":"@[simp] -- Porting note: new attr\ntheorem lcm_cycleType (σ : Perm α) : σ.cycleType.lcm = orderOf σ := by\n  induction σ using cycle_induction_on with\n  | base_one => simp\n  | base_cycles σ hσ => simp [hσ.cycleType, hσ.orderOf]\n  | induction_disjoint σ τ hd _ hσ hτ => simp [hd.cycleType, hd.orderOf, lcm_eq_nat_lcm, hσ, hτ]\n\n"}
{"name":"Equiv.Perm.dvd_of_mem_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nn : Nat\nh : Membership.mem σ.cycleType n\n⊢ Dvd.dvd n (orderOf σ)","decl":"theorem dvd_of_mem_cycleType {σ : Perm α} {n : ℕ} (h : n ∈ σ.cycleType) : n ∣ orderOf σ := by\n  rw [← lcm_cycleType]\n  exact dvd_lcm h\n\n"}
{"name":"Equiv.Perm.orderOf_cycleOf_dvd_orderOf","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx : α\n⊢ Dvd.dvd (orderOf (f.cycleOf x)) (orderOf f)","decl":"theorem orderOf_cycleOf_dvd_orderOf (f : Perm α) (x : α) : orderOf (cycleOf f x) ∣ orderOf f := by\n  by_cases hx : f x = x\n  · rw [← cycleOf_eq_one_iff] at hx\n    simp [hx]\n  · refine dvd_of_mem_cycleType ?_\n    rw [cycleType, Multiset.mem_map]\n    refine ⟨f.cycleOf x, ?_, ?_⟩\n    · rwa [← Finset.mem_def, cycleOf_mem_cycleFactorsFinset_iff, mem_support]\n    · simp [(isCycle_cycleOf _ hx).orderOf]\n\n"}
{"name":"Equiv.Perm.two_dvd_card_support","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nhσ : Eq (HPow.hPow σ 2) 1\n⊢ Dvd.dvd 2 σ.support.card","decl":"theorem two_dvd_card_support {σ : Perm α} (hσ : σ ^ 2 = 1) : 2 ∣ σ.support.card :=\n  (congr_arg (Dvd.dvd 2) σ.sum_cycleType).mp\n    (Multiset.dvd_sum fun n hn => by\n      rw [_root_.le_antisymm\n          (Nat.le_of_dvd zero_lt_two <|\n            (dvd_of_mem_cycleType hn).trans <| orderOf_dvd_of_pow_eq_one hσ)\n          (two_le_of_mem_cycleType hn)])\n\n"}
{"name":"Equiv.Perm.cycleType_prime_order","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nhσ : Nat.Prime (orderOf σ)\n⊢ Exists fun n => Eq σ.cycleType (Multiset.replicate (HAdd.hAdd n 1) (orderOf σ))","decl":"theorem cycleType_prime_order {σ : Perm α} (hσ : (orderOf σ).Prime) :\n    ∃ n : ℕ, σ.cycleType = Multiset.replicate (n + 1) (orderOf σ) := by\n  refine ⟨Multiset.card σ.cycleType - 1, eq_replicate.2 ⟨?_, fun n hn ↦ ?_⟩⟩\n  · rw [tsub_add_cancel_of_le]\n    rw [Nat.succ_le_iff, card_cycleType_pos, Ne, ← orderOf_eq_one_iff]\n    exact hσ.ne_one\n  · exact (hσ.eq_one_or_self_of_dvd n (dvd_of_mem_cycleType hn)).resolve_left\n      (one_lt_of_mem_cycleType hn).ne'\n\n"}
{"name":"Equiv.Perm.isCycle_of_prime_order","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh1 : Nat.Prime (orderOf σ)\nh2 : LT.lt σ.support.card (HMul.hMul 2 (orderOf σ))\n⊢ σ.IsCycle","decl":"theorem isCycle_of_prime_order {σ : Perm α} (h1 : (orderOf σ).Prime)\n    (h2 : σ.support.card < 2 * orderOf σ) : σ.IsCycle := by\n  obtain ⟨n, hn⟩ := cycleType_prime_order h1\n  rw [← σ.sum_cycleType, hn, Multiset.sum_replicate, nsmul_eq_mul, Nat.cast_id,\n    mul_lt_mul_right (orderOf_pos σ), Nat.succ_lt_succ_iff, Nat.lt_succ_iff, Nat.le_zero] at h2\n  rw [← card_cycleType_eq_one, hn, card_replicate, h2]\n\n"}
{"name":"Equiv.Perm.cycleType_le_of_mem_cycleFactorsFinset","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf g : Equiv.Perm α\nhf : Membership.mem g.cycleFactorsFinset f\n⊢ LE.le f.cycleType g.cycleType","decl":"theorem cycleType_le_of_mem_cycleFactorsFinset {f g : Perm α} (hf : f ∈ g.cycleFactorsFinset) :\n    f.cycleType ≤ g.cycleType := by\n  have hf' := mem_cycleFactorsFinset_iff.1 hf\n  rw [cycleType_def, cycleType_def, hf'.left.cycleFactorsFinset_eq_singleton]\n  refine map_le_map ?_\n  simpa only [Finset.singleton_val, singleton_le, Finset.mem_val] using hf\n\n"}
{"name":"Equiv.Perm.Disjoint.cycleType_mul","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf g : Equiv.Perm α\nh : f.Disjoint g\n⊢ Eq (HMul.hMul f g).cycleType (HAdd.hAdd f.cycleType g.cycleType)","decl":"theorem Disjoint.cycleType_mul {f g : Perm α} (h : f.Disjoint g) :\n    (f * g).cycleType = f.cycleType + g.cycleType := by\n  simp only [Perm.cycleType]\n  rw [h.cycleFactorsFinset_mul_eq_union]\n  simp only [Finset.union_val, Function.comp_apply]\n  rw [← Multiset.add_eq_union_iff_disjoint.mpr _, Multiset.map_add]\n  simp only [Finset.disjoint_val, Disjoint.disjoint_cycleFactorsFinset h]\n\n"}
{"name":"Equiv.Perm.Disjoint.cycleType_noncommProd","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nι : Type u_2\nk : ι → Equiv.Perm α\ns : Finset ι\nhs : (↑s).Pairwise fun i j => (k i).Disjoint (k j)\nhs' : optParam ((↑s).Pairwise fun i j => Commute (k i) (k j)) ⋯\n⊢ Eq (s.noncommProd k hs').cycleType (s.sum fun i => (k i).cycleType)","decl":"theorem Disjoint.cycleType_noncommProd {ι : Type*} {k : ι → Perm α} {s : Finset ι}\n    (hs : Set.Pairwise s fun i j ↦ Disjoint (k i) (k j))\n    (hs' : Set.Pairwise s fun i j ↦ Commute (k i) (k j) :=\n      hs.imp (fun _ _ ↦ Perm.Disjoint.commute)) :\n    (s.noncommProd k hs').cycleType = s.sum fun i ↦ (k i).cycleType := by\n  classical\n  induction s using Finset.induction_on with\n  | empty => simp\n  | @insert i s hi hrec =>\n    have hs' : (s : Set ι).Pairwise fun i j ↦ Disjoint (k i) (k j) :=\n      hs.mono (by simp only [Finset.coe_insert, Set.subset_insert])\n    rw [Finset.noncommProd_insert_of_not_mem _ _ _ _ hi, Finset.sum_insert hi]\n    rw [Equiv.Perm.Disjoint.cycleType_mul, hrec hs']\n    apply disjoint_noncommProd_right\n    intro j hj\n    apply hs _ _ (ne_of_mem_of_not_mem hj hi).symm <;>\n      simp only [Finset.coe_insert, Set.mem_insert_iff, Finset.mem_coe, hj, or_true, true_or]\n\n\n"}
{"name":"Equiv.Perm.cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf g : Equiv.Perm α\nhf : Membership.mem g.cycleFactorsFinset f\n⊢ Eq (HMul.hMul g (Inv.inv f)).cycleType (HSub.hSub g.cycleType f.cycleType)","decl":"theorem cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub\n    {f g : Perm α} (hf : f ∈ g.cycleFactorsFinset) :\n    (g * f⁻¹).cycleType = g.cycleType - f.cycleType :=\n  add_right_cancel (b := f.cycleType) <| by\n    rw [← (disjoint_mul_inv_of_mem_cycleFactorsFinset hf).cycleType, inv_mul_cancel_right,\n      tsub_add_cancel_of_le (cycleType_le_of_mem_cycleFactorsFinset hf)]\n\n"}
{"name":"Equiv.Perm.isConj_of_cycleType_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\nh : Eq σ.cycleType τ.cycleType\n⊢ IsConj σ τ","decl":"theorem isConj_of_cycleType_eq {σ τ : Perm α} (h : cycleType σ = cycleType τ) : IsConj σ τ := by\n  induction σ using cycle_induction_on generalizing τ with\n  | base_one =>\n    rw [cycleType_one, eq_comm, cycleType_eq_zero] at h\n    rw [h]\n  | base_cycles σ hσ =>\n    have hτ := card_cycleType_eq_one.2 hσ\n    rw [h, card_cycleType_eq_one] at hτ\n    apply hσ.isConj hτ\n    rw [hσ.cycleType, hτ.cycleType, coe_eq_coe, List.singleton_perm] at h\n    exact List.singleton_injective h\n  | induction_disjoint σ π hd hc hσ hπ =>\n    rw [hd.cycleType] at h\n    have h' : σ.support.card ∈ τ.cycleType := by\n      simp [← h, hc.cycleType]\n    obtain ⟨σ', hσ'l, hσ'⟩ := Multiset.mem_map.mp h'\n    have key : IsConj (σ' * τ * σ'⁻¹) τ := (isConj_iff.2 ⟨σ', rfl⟩).symm\n    refine IsConj.trans ?_ key\n    rw [mul_assoc]\n    have hs : σ.cycleType = σ'.cycleType := by\n      rw [← Finset.mem_def, mem_cycleFactorsFinset_iff] at hσ'l\n      rw [hc.cycleType, ← hσ', hσ'l.left.cycleType]; rfl\n    refine hd.isConj_mul (hσ hs) (hπ ?_) ?_\n    · rw [cycleType_mul_inv_mem_cycleFactorsFinset_eq_sub, ← h, add_comm, hs,\n        add_tsub_cancel_right]\n      rwa [Finset.mem_def]\n    · exact (disjoint_mul_inv_of_mem_cycleFactorsFinset hσ'l).symm\n\n"}
{"name":"Equiv.Perm.isConj_iff_cycleType_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\n⊢ Iff (IsConj σ τ) (Eq σ.cycleType τ.cycleType)","decl":"theorem isConj_iff_cycleType_eq {σ τ : Perm α} : IsConj σ τ ↔ σ.cycleType = τ.cycleType :=\n  ⟨fun h => by\n    obtain ⟨π, rfl⟩ := isConj_iff.1 h\n    rw [cycleType_conj], isConj_of_cycleType_eq⟩\n\n"}
{"name":"Equiv.Perm.cycleType_extendDomain","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝⁴ : Fintype α\ninst✝³ : DecidableEq α\nβ : Type u_2\ninst✝² : Fintype β\ninst✝¹ : DecidableEq β\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ng : Equiv.Perm α\n⊢ Eq (g.extendDomain f).cycleType g.cycleType","decl":"@[simp]\ntheorem cycleType_extendDomain {β : Type*} [Fintype β] [DecidableEq β] {p : β → Prop}\n    [DecidablePred p] (f : α ≃ Subtype p) {g : Perm α} :\n    cycleType (g.extendDomain f) = cycleType g := by\n  induction g using cycle_induction_on with\n  | base_one => rw [extendDomain_one, cycleType_one, cycleType_one]\n  | base_cycles σ hσ =>\n    rw [(hσ.extendDomain f).cycleType, hσ.cycleType, card_support_extend_domain]\n  | induction_disjoint σ τ hd _ hσ hτ =>\n    rw [hd.cycleType, ← extendDomain_mul, (hd.extendDomain f).cycleType, hσ, hτ]\n\n"}
{"name":"Equiv.Perm.cycleType_ofSubtype","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\np : α → Prop\ninst✝ : DecidablePred p\ng : Equiv.Perm (Subtype p)\n⊢ Eq (Equiv.Perm.ofSubtype g).cycleType g.cycleType","decl":"theorem cycleType_ofSubtype {p : α → Prop} [DecidablePred p] {g : Perm (Subtype p)} :\n    cycleType (ofSubtype g) = cycleType g :=\n  cycleType_extendDomain (Equiv.refl (Subtype p))\n\n"}
{"name":"Equiv.Perm.mem_cycleType_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nn : Nat\nσ : Equiv.Perm α\n⊢ Iff (Membership.mem σ.cycleType n) (Exists fun c => Exists fun τ => And (Eq σ (HMul.hMul c τ)) (And (c.Disjoint τ) (And c.IsCycle (Eq c.support.card n))))","decl":"theorem mem_cycleType_iff {n : ℕ} {σ : Perm α} :\n    n ∈ cycleType σ ↔ ∃ c τ, σ = c * τ ∧ Disjoint c τ ∧ IsCycle c ∧ c.support.card = n := by\n  constructor\n  · intro h\n    obtain ⟨l, rfl, hlc, hld⟩ := truncCycleFactors σ\n    rw [cycleType_eq _ rfl hlc hld, Multiset.mem_coe, List.mem_map] at h\n    obtain ⟨c, cl, rfl⟩ := h\n    rw [(List.perm_cons_erase cl).pairwise_iff @(Disjoint.symmetric)] at hld\n    refine ⟨c, (l.erase c).prod, ?_, ?_, hlc _ cl, rfl⟩\n    · rw [← List.prod_cons, (List.perm_cons_erase cl).symm.prod_eq' (hld.imp Disjoint.commute)]\n    · exact disjoint_prod_right _ fun g => List.rel_of_pairwise_cons hld\n  · rintro ⟨c, t, rfl, hd, hc, rfl⟩\n    simp [hd.cycleType, hc.cycleType]\n\n"}
{"name":"Equiv.Perm.le_card_support_of_mem_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nn : Nat\nσ : Equiv.Perm α\nh : Membership.mem σ.cycleType n\n⊢ LE.le n σ.support.card","decl":"theorem le_card_support_of_mem_cycleType {n : ℕ} {σ : Perm α} (h : n ∈ cycleType σ) :\n    n ≤ σ.support.card :=\n  (le_sum_of_mem h).trans (le_of_eq σ.sum_cycleType)\n\n"}
{"name":"Equiv.Perm.cycleType_of_card_le_mem_cycleType_add_two","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nn : Nat\ng : Equiv.Perm α\nhn2 : LT.lt (Fintype.card α) (HAdd.hAdd n 2)\nhng : Membership.mem g.cycleType n\n⊢ Eq g.cycleType (Singleton.singleton n)","decl":"theorem cycleType_of_card_le_mem_cycleType_add_two {n : ℕ} {g : Perm α}\n    (hn2 : Fintype.card α < n + 2) (hng : n ∈ g.cycleType) : g.cycleType = {n} := by\n  obtain ⟨c, g', rfl, hd, hc, rfl⟩ := mem_cycleType_iff.1 hng\n  suffices g'1 : g' = 1 by\n    rw [hd.cycleType, hc.cycleType, coe_singleton, g'1, cycleType_one, add_zero]\n  contrapose! hn2 with g'1\n  apply le_trans _ (c * g').support.card_le_univ\n  rw [hd.card_support_mul]\n  exact add_le_add_left (two_le_card_support_of_ne_one g'1) _\n\n"}
{"name":"Equiv.Perm.card_compl_support_modEq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\np n : Nat\nhp : Fact (Nat.Prime p)\nσ : Equiv.Perm α\nhσ : Eq (HPow.hPow σ (HPow.hPow p n)) 1\n⊢ p.ModEq (HasCompl.compl σ.support).card (Fintype.card α)","decl":"theorem card_compl_support_modEq [DecidableEq α] {p n : ℕ} [hp : Fact p.Prime] {σ : Perm α}\n    (hσ : σ ^ p ^ n = 1) : σ.supportᶜ.card ≡ Fintype.card α [MOD p] := by\n  rw [Nat.modEq_iff_dvd', ← Finset.card_compl, compl_compl, ← sum_cycleType]\n  · refine Multiset.dvd_sum fun k hk => ?_\n    obtain ⟨m, -, hm⟩ := (Nat.dvd_prime_pow hp.out).mp (orderOf_dvd_of_pow_eq_one hσ)\n    obtain ⟨l, -, rfl⟩ := (Nat.dvd_prime_pow hp.out).mp\n      ((congr_arg _ hm).mp (dvd_of_mem_cycleType hk))\n    exact dvd_pow_self _ fun h => (one_lt_of_mem_cycleType hk).ne <| by rw [h, pow_zero]\n  · exact Finset.card_le_univ _\n\n"}
{"name":"Equiv.Perm.card_fixedPoints_modEq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Function.End α\np n : Nat\nhp : Fact (Nat.Prime p)\nhf : Eq (HPow.hPow f (HPow.hPow p n)) 1\n⊢ p.ModEq (Fintype.card α) (Fintype.card ↑(Function.fixedPoints f))","decl":"open Function in\n/-- The number of fixed points of a `p ^ n`-th root of the identity function over a finite set\nand the set's cardinality have the same residue modulo `p`, where `p` is a prime. -/\ntheorem card_fixedPoints_modEq [DecidableEq α] {f : Function.End α} {p n : ℕ}\n    [hp : Fact p.Prime] (hf : f ^ p ^ n = 1) :\n    Fintype.card α ≡ Fintype.card f.fixedPoints [MOD p] := by\n  let σ : α ≃ α := ⟨f, f ^ (p ^ n - 1),\n    leftInverse_iff_comp.mpr ((pow_sub_mul_pow f (Nat.one_le_pow n p hp.out.pos)).trans hf),\n    leftInverse_iff_comp.mpr ((pow_mul_pow_sub f (Nat.one_le_pow n p hp.out.pos)).trans hf)⟩\n  have hσ : σ ^ p ^ n = 1 := by\n    rw [DFunLike.ext'_iff, coe_pow]\n    exact (hom_coe_pow (fun g : Function.End α ↦ g) rfl (fun g h ↦ rfl) f (p ^ n)).symm.trans hf\n  suffices Fintype.card f.fixedPoints = (support σ)ᶜ.card from\n    this ▸ (card_compl_support_modEq hσ).symm\n  suffices f.fixedPoints = (support σ)ᶜ by\n    simp only [this]; apply Fintype.card_coe\n  simp [σ, Set.ext_iff, IsFixedPt]\n\n"}
{"name":"Equiv.Perm.exists_fixed_point_of_prime","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝ : Fintype α\np n : Nat\nhp : Fact (Nat.Prime p)\nhα : Not (Dvd.dvd p (Fintype.card α))\nσ : Equiv.Perm α\nhσ : Eq (HPow.hPow σ (HPow.hPow p n)) 1\n⊢ Exists fun a => Eq (σ a) a","decl":"theorem exists_fixed_point_of_prime {p n : ℕ} [hp : Fact p.Prime] (hα : ¬p ∣ Fintype.card α)\n    {σ : Perm α} (hσ : σ ^ p ^ n = 1) : ∃ a : α, σ a = a := by\n  classical\n    contrapose! hα\n    simp_rw [← mem_support, ← Finset.eq_univ_iff_forall] at hα\n    exact Nat.modEq_zero_iff_dvd.1 ((congr_arg _ (Finset.card_eq_zero.2 (compl_eq_bot.2 hα))).mp\n      (card_compl_support_modEq hσ).symm)\n\n"}
{"name":"Equiv.Perm.exists_fixed_point_of_prime'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝ : Fintype α\np n : Nat\nhp : Fact (Nat.Prime p)\nhα : Dvd.dvd p (Fintype.card α)\nσ : Equiv.Perm α\nhσ : Eq (HPow.hPow σ (HPow.hPow p n)) 1\na : α\nha : Eq (σ a) a\n⊢ Exists fun b => And (Eq (σ b) b) (Ne b a)","decl":"theorem exists_fixed_point_of_prime' {p n : ℕ} [hp : Fact p.Prime] (hα : p ∣ Fintype.card α)\n    {σ : Perm α} (hσ : σ ^ p ^ n = 1) {a : α} (ha : σ a = a) : ∃ b : α, σ b = b ∧ b ≠ a := by\n  classical\n    have h : ∀ b : α, b ∈ σ.supportᶜ ↔ σ b = b := fun b => by\n      rw [Finset.mem_compl, mem_support, Classical.not_not]\n    obtain ⟨b, hb1, hb2⟩ := Finset.exists_ne_of_one_lt_card (hp.out.one_lt.trans_le\n      (Nat.le_of_dvd (Finset.card_pos.mpr ⟨a, (h a).mpr ha⟩) (Nat.modEq_zero_iff_dvd.mp\n        ((card_compl_support_modEq hσ).trans (Nat.modEq_zero_iff_dvd.mpr hα))))) a\n    exact ⟨b, (h b).mp hb1, hb2⟩\n\n"}
{"name":"Equiv.Perm.isCycle_of_prime_order'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nσ : Equiv.Perm α\nh1 : Nat.Prime (orderOf σ)\nh2 : LT.lt (Fintype.card α) (HMul.hMul 2 (orderOf σ))\n⊢ σ.IsCycle","decl":"theorem isCycle_of_prime_order' {σ : Perm α} (h1 : (orderOf σ).Prime)\n    (h2 : Fintype.card α < 2 * orderOf σ) : σ.IsCycle := by\n  classical exact isCycle_of_prime_order h1 (lt_of_le_of_lt σ.support.card_le_univ h2)\n\n"}
{"name":"Equiv.Perm.isCycle_of_prime_order''","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nσ : Equiv.Perm α\nh1 : Nat.Prime (Fintype.card α)\nh2 : Eq (orderOf σ) (Fintype.card α)\n⊢ σ.IsCycle","decl":"theorem isCycle_of_prime_order'' {σ : Perm α} (h1 : (Fintype.card α).Prime)\n    (h2 : orderOf σ = Fintype.card α) : σ.IsCycle :=\n  isCycle_of_prime_order' ((congr_arg Nat.Prime h2).mpr h1) <| by\n    rw [← one_mul (Fintype.card α), ← h2, mul_lt_mul_right (orderOf_pos σ)]\n    exact one_lt_two\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.mem_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : List.Vector G n\n⊢ Iff (Membership.mem (Equiv.Perm.vectorsProdEqOne G n) v) (Eq v.toList.prod 1)","decl":"theorem mem_iff {n : ℕ} (v : List.Vector G n) : v ∈ vectorsProdEqOne G n ↔ v.toList.prod = 1 :=\n  Iff.rfl\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.zero_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Eq (Equiv.Perm.vectorsProdEqOne G 0) (Singleton.singleton List.Vector.nil)","decl":"theorem zero_eq : vectorsProdEqOne G 0 = {Vector.nil} :=\n  Set.eq_singleton_iff_unique_mem.mpr ⟨Eq.refl (1 : G), fun v _ => v.eq_nil⟩\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.one_eq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\n⊢ Eq (Equiv.Perm.vectorsProdEqOne G 1) (Singleton.singleton (List.Vector.cons 1 List.Vector.nil))","decl":"theorem one_eq : vectorsProdEqOne G 1 = {Vector.nil.cons 1} := by\n  simp_rw [Set.eq_singleton_iff_unique_mem, mem_iff, List.Vector.toList_singleton,\n    List.prod_singleton, List.Vector.head_cons, true_and]\n  exact fun v hv => v.cons_head_tail.symm.trans (congr_arg₂ Vector.cons hv v.tail.eq_nil)\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.vectorEquiv_symm_apply","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : ↑(Equiv.Perm.vectorsProdEqOne G (HAdd.hAdd n 1))\n⊢ Eq ((Equiv.Perm.VectorsProdEqOne.vectorEquiv G n).symm v) (↑v).tail","decl":"/-- Given a vector `v` of length `n`, make a vector of length `n + 1` whose product is `1`,\nby appending the inverse of the product of `v`. -/\n@[simps]\ndef vectorEquiv : List.Vector G n ≃ vectorsProdEqOne G (n + 1) where\n  toFun v := ⟨v.toList.prod⁻¹ ::ᵥ v, by\n    rw [mem_iff, Vector.toList_cons, List.prod_cons, inv_mul_cancel]⟩\n  invFun v := v.1.tail\n  left_inv v := v.tail_cons v.toList.prod⁻¹\n  right_inv v := Subtype.ext <|\n    calc\n      v.1.tail.toList.prod⁻¹ ::ᵥ v.1.tail = v.1.head ::ᵥ v.1.tail :=\n        congr_arg (· ::ᵥ v.1.tail) <| Eq.symm <| eq_inv_of_mul_eq_one_left <| by\n          rw [← List.prod_cons, ← Vector.toList_cons, v.1.cons_head_tail]\n          exact v.2\n      _ = v.1 := v.1.cons_head_tail\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.vectorEquiv_apply_coe","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : List.Vector G n\n⊢ Eq (↑((Equiv.Perm.VectorsProdEqOne.vectorEquiv G n) v)) (List.Vector.cons (Inv.inv v.toList.prod) v)","decl":"/-- Given a vector `v` of length `n`, make a vector of length `n + 1` whose product is `1`,\nby appending the inverse of the product of `v`. -/\n@[simps]\ndef vectorEquiv : List.Vector G n ≃ vectorsProdEqOne G (n + 1) where\n  toFun v := ⟨v.toList.prod⁻¹ ::ᵥ v, by\n    rw [mem_iff, Vector.toList_cons, List.prod_cons, inv_mul_cancel]⟩\n  invFun v := v.1.tail\n  left_inv v := v.tail_cons v.toList.prod⁻¹\n  right_inv v := Subtype.ext <|\n    calc\n      v.1.tail.toList.prod⁻¹ ::ᵥ v.1.tail = v.1.head ::ᵥ v.1.tail :=\n        congr_arg (· ::ᵥ v.1.tail) <| Eq.symm <| eq_inv_of_mul_eq_one_left <| by\n          rw [← List.prod_cons, ← Vector.toList_cons, v.1.cons_head_tail]\n          exact v.2\n      _ = v.1 := v.1.cons_head_tail\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.card","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝¹ : Group G\nn : Nat\ninst✝ : Fintype G\n⊢ Eq (Fintype.card ↑(Equiv.Perm.vectorsProdEqOne G n)) (HPow.hPow (Fintype.card G) (HSub.hSub n 1))","decl":"theorem card [Fintype G] : Fintype.card (vectorsProdEqOne G n) = Fintype.card G ^ (n - 1) :=\n  (Fintype.card_congr (equivVector G n)).trans (card_vector (n - 1))\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.rotate_zero","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : ↑(Equiv.Perm.vectorsProdEqOne G n)\n⊢ Eq (Equiv.Perm.VectorsProdEqOne.rotate v 0) v","decl":"theorem rotate_zero : rotate v 0 = v :=\n  Subtype.ext (Subtype.ext v.1.1.rotate_zero)\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.rotate_rotate","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : ↑(Equiv.Perm.vectorsProdEqOne G n)\nj k : Nat\n⊢ Eq (Equiv.Perm.VectorsProdEqOne.rotate (Equiv.Perm.VectorsProdEqOne.rotate v j) k) (Equiv.Perm.VectorsProdEqOne.rotate v (HAdd.hAdd j k))","decl":"theorem rotate_rotate : rotate (rotate v j) k = rotate v (j + k) :=\n  Subtype.ext (Subtype.ext (v.1.1.rotate_rotate j k))\n\n"}
{"name":"Equiv.Perm.VectorsProdEqOne.rotate_length","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_2\ninst✝ : Group G\nn : Nat\nv : ↑(Equiv.Perm.vectorsProdEqOne G n)\n⊢ Eq (Equiv.Perm.VectorsProdEqOne.rotate v n) v","decl":"theorem rotate_length : rotate v n = v :=\n  Subtype.ext (Subtype.ext ((congr_arg _ v.1.2.symm).trans v.1.1.rotate_length))\n\n"}
{"name":"exists_prime_orderOf_dvd_card","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Fintype G\np : Nat\nhp : Fact (Nat.Prime p)\nhdvd : Dvd.dvd p (Fintype.card G)\n⊢ Exists fun x => Eq (orderOf x) p","decl":"/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\ntheorem _root_.exists_prime_orderOf_dvd_card {G : Type*} [Group G] [Fintype G] (p : ℕ)\n    [hp : Fact p.Prime] (hdvd : p ∣ Fintype.card G) : ∃ x : G, orderOf x = p := by\n  have hp' : p - 1 ≠ 0 := mt tsub_eq_zero_iff_le.mp (not_le_of_lt hp.out.one_lt)\n  have Scard :=\n    calc\n      p ∣ Fintype.card G ^ (p - 1) := hdvd.trans (dvd_pow (dvd_refl _) hp')\n      _ = Fintype.card (vectorsProdEqOne G p) := (VectorsProdEqOne.card G p).symm\n  let f : ℕ → vectorsProdEqOne G p → vectorsProdEqOne G p := fun k v =>\n    VectorsProdEqOne.rotate v k\n  have hf1 : ∀ v, f 0 v = v := VectorsProdEqOne.rotate_zero\n  have hf2 : ∀ j k v, f k (f j v) = f (j + k) v := fun j k v =>\n    VectorsProdEqOne.rotate_rotate v j k\n  have hf3 : ∀ v, f p v = v := VectorsProdEqOne.rotate_length\n  let σ :=\n    Equiv.mk (f 1) (f (p - 1)) (fun s => by rw [hf2, add_tsub_cancel_of_le hp.out.one_lt.le, hf3])\n      fun s => by rw [hf2, tsub_add_cancel_of_le hp.out.one_lt.le, hf3]\n  have hσ : ∀ k v, (σ ^ k) v = f k v := fun k =>\n    Nat.rec (fun v => (hf1 v).symm) (fun k hk v => by\n      rw [pow_succ, Perm.mul_apply, hk (σ v), Nat.succ_eq_one_add, ← hf2 1 k]\n      simp only [σ, coe_fn_mk]) k\n  replace hσ : σ ^ p ^ 1 = 1 := Perm.ext fun v => by rw [pow_one, hσ, hf3, one_apply]\n  let v₀ : vectorsProdEqOne G p :=\n    ⟨Vector.replicate p 1, (List.prod_replicate p 1).trans (one_pow p)⟩\n  have hv₀ : σ v₀ = v₀ := Subtype.ext (Subtype.ext (List.rotate_replicate (1 : G) p 1))\n  obtain ⟨v, hv1, hv2⟩ := exists_fixed_point_of_prime' Scard hσ hv₀\n  refine\n    Exists.imp (fun g hg => orderOf_eq_prime ?_ fun hg' => hv2 ?_)\n      (List.rotate_one_eq_self_iff_eq_replicate.mp (Subtype.ext_iff.mp (Subtype.ext_iff.mp hv1)))\n  · rw [← List.prod_replicate, ← v.1.2, ← hg, show v.val.val.prod = 1 from v.2]\n  · rw [Subtype.ext_iff_val, Subtype.ext_iff_val, hg, hg', v.1.2]\n    simp only [v₀, Vector.replicate]\n\n-- TODO: Make the `Finite` version of this theorem the default\n"}
{"name":"exists_prime_addOrderOf_dvd_card","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_3\ninst✝² : AddGroup G\ninst✝¹ : Fintype G\np : Nat\ninst✝ : Fact (Nat.Prime p)\nhdvd : Dvd.dvd p (Fintype.card G)\n⊢ Exists fun x => Eq (addOrderOf x) p","decl":"/-- For every prime `p` dividing the order of a finite additive group `G` there exists an element of\norder `p` in `G`. This is the additive version of Cauchy's theorem. -/\ntheorem _root_.exists_prime_addOrderOf_dvd_card {G : Type*} [AddGroup G] [Fintype G] (p : ℕ)\n    [Fact p.Prime] (hdvd : p ∣ Fintype.card G) : ∃ x : G, addOrderOf x = p :=\n  @exists_prime_orderOf_dvd_card (Multiplicative G) _ _ _ _ (by convert hdvd)\n\n"}
{"name":"exists_prime_addOrderOf_dvd_card'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_3\ninst✝¹ : AddGroup G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nhdvd : Dvd.dvd p (Nat.card G)\n⊢ Exists fun x => Eq (addOrderOf x) p","decl":"/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\n@[to_additive]\ntheorem _root_.exists_prime_orderOf_dvd_card' {G : Type*} [Group G] [Finite G] (p : ℕ)\n    [hp : Fact p.Prime] (hdvd : p ∣ Nat.card G) : ∃ x : G, orderOf x = p := by\n  have := Fintype.ofFinite G\n  rw [Nat.card_eq_fintype_card] at hdvd\n  exact exists_prime_orderOf_dvd_card p hdvd\n\n"}
{"name":"exists_prime_orderOf_dvd_card'","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"G : Type u_3\ninst✝¹ : Group G\ninst✝ : Finite G\np : Nat\nhp : Fact (Nat.Prime p)\nhdvd : Dvd.dvd p (Nat.card G)\n⊢ Exists fun x => Eq (orderOf x) p","decl":"/-- For every prime `p` dividing the order of a finite group `G` there exists an element of order\n`p` in `G`. This is known as Cauchy's theorem. -/\n@[to_additive]\ntheorem _root_.exists_prime_orderOf_dvd_card' {G : Type*} [Group G] [Finite G] (p : ℕ)\n    [hp : Fact p.Prime] (hdvd : p ∣ Nat.card G) : ∃ x : G, orderOf x = p := by\n  have := Fintype.ofFinite G\n  rw [Nat.card_eq_fintype_card] at hdvd\n  exact exists_prime_orderOf_dvd_card p hdvd\n\n"}
{"name":"Equiv.Perm.subgroup_eq_top_of_swap_mem","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nH : Subgroup (Equiv.Perm α)\nd : DecidablePred fun x => Membership.mem H x\nτ : Equiv.Perm α\nh0 : Nat.Prime (Fintype.card α)\nh1 : Dvd.dvd (Fintype.card α) (Fintype.card (Subtype fun x => Membership.mem H x))\nh2 : Membership.mem H τ\nh3 : τ.IsSwap\n⊢ Eq H Top.top","decl":"theorem subgroup_eq_top_of_swap_mem [DecidableEq α] {H : Subgroup (Perm α)}\n    [d : DecidablePred (· ∈ H)] {τ : Perm α} (h0 : (Fintype.card α).Prime)\n    (h1 : Fintype.card α ∣ Fintype.card H) (h2 : τ ∈ H) (h3 : IsSwap τ) : H = ⊤ := by\n  haveI : Fact (Fintype.card α).Prime := ⟨h0⟩\n  obtain ⟨σ, hσ⟩ := exists_prime_orderOf_dvd_card (Fintype.card α) h1\n  have hσ1 : orderOf (σ : Perm α) = Fintype.card α := (Subgroup.orderOf_coe σ).trans hσ\n  have hσ2 : IsCycle ↑σ := isCycle_of_prime_order'' h0 hσ1\n  have hσ3 : (σ : Perm α).support = ⊤ :=\n    Finset.eq_univ_of_card (σ : Perm α).support (hσ2.orderOf.symm.trans hσ1)\n  have hσ4 : Subgroup.closure {↑σ, τ} = ⊤ := closure_prime_cycle_swap h0 hσ2 hσ3 h3\n  rw [eq_top_iff, ← hσ4, Subgroup.closure_le, Set.insert_subset_iff, Set.singleton_subset_iff]\n  exact ⟨Subtype.mem σ, h2⟩\n\n"}
{"name":"Equiv.Perm.parts_partition","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq σ.partition.parts (HAdd.hAdd σ.cycleType (Multiset.replicate (HSub.hSub (Fintype.card α) σ.support.card) 1))","decl":"theorem parts_partition {σ : Perm α} :\n    σ.partition.parts = σ.cycleType + Multiset.replicate (Fintype.card α - σ.support.card) 1 :=\n  rfl\n\n"}
{"name":"Equiv.Perm.filter_parts_partition_eq_cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Eq (Multiset.filter (fun n => LE.le 2 n) σ.partition.parts) σ.cycleType","decl":"theorem filter_parts_partition_eq_cycleType {σ : Perm α} :\n    ((partition σ).parts.filter fun n => 2 ≤ n) = σ.cycleType := by\n  rw [parts_partition, filter_add, Multiset.filter_eq_self.2 fun _ => two_le_of_mem_cycleType,\n    Multiset.filter_eq_nil.2 fun a h => ?_, add_zero]\n  rw [Multiset.eq_of_mem_replicate h]\n  decide\n\n"}
{"name":"Equiv.Perm.partition_eq_of_isConj","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\n⊢ Iff (IsConj σ τ) (Eq σ.partition τ.partition)","decl":"theorem partition_eq_of_isConj {σ τ : Perm α} : IsConj σ τ ↔ σ.partition = τ.partition := by\n  rw [isConj_iff_cycleType_eq]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rw [Nat.Partition.ext_iff, parts_partition, parts_partition, ← sum_cycleType, ← sum_cycleType,\n      h]\n  · rw [← filter_parts_partition_eq_cycleType, ← filter_parts_partition_eq_cycleType, h]\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.cycleType","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh : σ.IsThreeCycle\n⊢ Eq σ.cycleType (Singleton.singleton 3)","decl":"theorem cycleType (h : IsThreeCycle σ) : σ.cycleType = {3} :=\n  h\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.card_support","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh : σ.IsThreeCycle\n⊢ Eq σ.support.card 3","decl":"theorem card_support (h : IsThreeCycle σ) : σ.support.card = 3 := by\n  rw [← sum_cycleType, h.cycleType, Multiset.sum_singleton]\n\n"}
{"name":"card_support_eq_three_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\n⊢ Iff (Eq σ.support.card 3) σ.IsThreeCycle","decl":"theorem _root_.card_support_eq_three_iff : σ.support.card = 3 ↔ σ.IsThreeCycle := by\n  refine ⟨fun h => ?_, IsThreeCycle.card_support⟩\n  by_cases h0 : σ.cycleType = 0\n  · rw [← sum_cycleType, h0, sum_zero] at h\n    exact (ne_of_lt zero_lt_three h).elim\n  obtain ⟨n, hn⟩ := exists_mem_of_ne_zero h0\n  by_cases h1 : σ.cycleType.erase n = 0\n  · rw [← sum_cycleType, ← cons_erase hn, h1, cons_zero, Multiset.sum_singleton] at h\n    rw [IsThreeCycle, ← cons_erase hn, h1, h, ← cons_zero]\n  obtain ⟨m, hm⟩ := exists_mem_of_ne_zero h1\n  rw [← sum_cycleType, ← cons_erase hn, ← cons_erase hm, Multiset.sum_cons, Multiset.sum_cons] at h\n  have : ∀ {k}, 2 ≤ m → 2 ≤ n → n + (m + k) = 3 → False := by omega\n  cases this (two_le_of_mem_cycleType (mem_of_mem_erase hm)) (two_le_of_mem_cycleType hn) h\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.isCycle","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh : σ.IsThreeCycle\n⊢ σ.IsCycle","decl":"theorem isCycle (h : IsThreeCycle σ) : IsCycle σ := by\n  rw [← card_cycleType_eq_one, h.cycleType, card_singleton]\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.sign","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ : Equiv.Perm α\nh : σ.IsThreeCycle\n⊢ Eq (Equiv.Perm.sign σ) 1","decl":"theorem sign (h : IsThreeCycle σ) : sign σ = 1 := by\n  rw [Equiv.Perm.sign_of_cycleType, h.cycleType]\n  rfl\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.inv","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nh : f.IsThreeCycle\n⊢ (Inv.inv f).IsThreeCycle","decl":"theorem inv {f : Perm α} (h : IsThreeCycle f) : IsThreeCycle f⁻¹ := by\n  rwa [IsThreeCycle, cycleType_inv]\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.inv_iff","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nf : Equiv.Perm α\n⊢ Iff (Inv.inv f).IsThreeCycle f.IsThreeCycle","decl":"@[simp]\ntheorem inv_iff {f : Perm α} : IsThreeCycle f⁻¹ ↔ IsThreeCycle f :=\n  ⟨by\n    rw [← inv_inv f]\n    apply inv, inv⟩\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.orderOf","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng : Equiv.Perm α\nht : g.IsThreeCycle\n⊢ Eq (orderOf g) 3","decl":"theorem orderOf {g : Perm α} (ht : IsThreeCycle g) : orderOf g = 3 := by\n  rw [← lcm_cycleType, ht.cycleType, Multiset.lcm_singleton, normalize_eq]\n\n"}
{"name":"Equiv.Perm.IsThreeCycle.isThreeCycle_sq","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ng : Equiv.Perm α\nht : g.IsThreeCycle\n⊢ (HMul.hMul g g).IsThreeCycle","decl":"theorem isThreeCycle_sq {g : Perm α} (ht : IsThreeCycle g) : IsThreeCycle (g * g) := by\n  rw [← pow_two, ← card_support_eq_three_iff, support_pow_coprime, ht.card_support]\n  rw [ht.orderOf]\n  norm_num\n\n"}
{"name":"Equiv.Perm.isThreeCycle_swap_mul_swap_same","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na b c : α\nab : Ne a b\nac : Ne a c\nbc : Ne b c\n⊢ (HMul.hMul (Equiv.swap a b) (Equiv.swap a c)).IsThreeCycle","decl":"theorem isThreeCycle_swap_mul_swap_same {a b c : α} (ab : a ≠ b) (ac : a ≠ c) (bc : b ≠ c) :\n    IsThreeCycle (swap a b * swap a c) := by\n  suffices h : support (swap a b * swap a c) = {a, b, c} by\n    rw [← card_support_eq_three_iff, h]\n    simp [ab, ac, bc]\n  apply le_antisymm ((support_mul_le _ _).trans fun x => _) fun x hx => ?_\n  · simp [ab, ac, bc]\n  · simp only [Finset.mem_insert, Finset.mem_singleton] at hx\n    rw [mem_support]\n    simp only [Perm.coe_mul, Function.comp_apply, Ne]\n    obtain rfl | rfl | rfl := hx\n    · rw [swap_apply_left, swap_apply_of_ne_of_ne ac.symm bc.symm]\n      exact ac.symm\n    · rw [swap_apply_of_ne_of_ne ab.symm bc, swap_apply_right]\n      exact ab\n    · rw [swap_apply_right, swap_apply_left]\n      exact bc\n\n"}
{"name":"Equiv.Perm.swap_mul_swap_same_mem_closure_three_cycles","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\na b c : α\nab : Ne a b\nac : Ne a c\n⊢ Membership.mem (Subgroup.closure (setOf fun σ => σ.IsThreeCycle)) (HMul.hMul (Equiv.swap a b) (Equiv.swap a c))","decl":"theorem swap_mul_swap_same_mem_closure_three_cycles {a b c : α} (ab : a ≠ b) (ac : a ≠ c) :\n    swap a b * swap a c ∈ closure { σ : Perm α | IsThreeCycle σ } := by\n  by_cases bc : b = c\n  · subst bc\n    simp [one_mem]\n  exact subset_closure (isThreeCycle_swap_mul_swap_same ab ac bc)\n\n"}
{"name":"Equiv.Perm.IsSwap.mul_mem_closure_three_cycles","module":"Mathlib.GroupTheory.Perm.Cycle.Type","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\nσ τ : Equiv.Perm α\nhσ : σ.IsSwap\nhτ : τ.IsSwap\n⊢ Membership.mem (Subgroup.closure (setOf fun σ => σ.IsThreeCycle)) (HMul.hMul σ τ)","decl":"theorem IsSwap.mul_mem_closure_three_cycles {σ τ : Perm α} (hσ : IsSwap σ) (hτ : IsSwap τ) :\n    σ * τ ∈ closure { σ : Perm α | IsThreeCycle σ } := by\n  obtain ⟨a, b, ab, rfl⟩ := hσ\n  obtain ⟨c, d, cd, rfl⟩ := hτ\n  by_cases ac : a = c\n  · subst ac\n    exact swap_mul_swap_same_mem_closure_three_cycles ab cd\n  have h' : swap a b * swap c d = swap a b * swap a c * (swap c a * swap c d) := by\n    simp [swap_comm c a, mul_assoc]\n  rw [h']\n  exact\n    mul_mem (swap_mul_swap_same_mem_closure_three_cycles ab ac)\n      (swap_mul_swap_same_mem_closure_three_cycles (Ne.symm ac) cd)\n\n"}
