{"name":"List.count_not_add_count","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nb : Bool\n⊢ Eq (HAdd.hAdd (List.count b.not l) (List.count b l)) l.length","decl":"@[simp]\ntheorem count_not_add_count (l : List Bool) (b : Bool) : count (!b) l + count b l = length l := by\n  -- Porting note: Proof re-written\n  -- Old proof: simp only [length_eq_countP_add_countP (Eq (!b)), Bool.not_not_eq, count]\n  simp only [length_eq_countP_add_countP (· == !b), count, add_right_inj]\n  suffices (fun x => x == b) = (fun a => decide ¬(a == !b) = true) by rw [this]\n  ext x; cases x <;> cases b <;> rfl\n\n"}
{"name":"List.count_add_count_not","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nb : Bool\n⊢ Eq (HAdd.hAdd (List.count b l) (List.count b.not l)) l.length","decl":"@[simp]\ntheorem count_add_count_not (l : List Bool) (b : Bool) : count b l + count (!b) l = length l := by\n  rw [add_comm, count_not_add_count]\n\n"}
{"name":"List.count_false_add_count_true","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\n⊢ Eq (HAdd.hAdd (List.count Bool.false l) (List.count Bool.true l)) l.length","decl":"@[simp]\ntheorem count_false_add_count_true (l : List Bool) : count false l + count true l = length l :=\n  count_not_add_count l true\n\n"}
{"name":"List.count_true_add_count_false","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\n⊢ Eq (HAdd.hAdd (List.count Bool.true l) (List.count Bool.false l)) l.length","decl":"@[simp]\ntheorem count_true_add_count_false (l : List Bool) : count true l + count false l = length l :=\n  count_not_add_count l false\n\n"}
{"name":"List.Chain.count_not","module":"Mathlib.Data.Bool.Count","initialProofState":"b : Bool\nl : List Bool\na✝ : List.Chain (fun x1 x2 => Ne x1 x2) b l\n⊢ Eq (List.count b.not l) (HAdd.hAdd (List.count b l) (HMod.hMod l.length 2))","decl":"theorem Chain.count_not :\n    ∀ {b : Bool} {l : List Bool}, Chain (· ≠ ·) b l → count (!b) l = count b l + length l % 2\n  | _, [], _h => rfl\n  | b, x :: l, h => by\n    obtain rfl : b = !x := Bool.eq_not_iff.2 (rel_of_chain_cons h)\n    rw [Bool.not_not, count_cons_self, count_cons_of_ne x.not_ne_self,\n      Chain.count_not (chain_of_chain_cons h), length, add_assoc, Nat.mod_two_add_succ_mod_two]\n\n"}
{"name":"List.Chain'.count_not_eq_count","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nh2 : Even l.length\nb : Bool\n⊢ Eq (List.count b.not l) (List.count b l)","decl":"theorem count_not_eq_count (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) (b : Bool) :\n    count (!b) l = count b l := by\n  cases' l with x l\n  · rfl\n  rw [length_cons, Nat.even_add_one, Nat.not_even_iff] at h2\n  suffices count (!x) (x :: l) = count x (x :: l) by\n    -- Porting note: old proof is\n    -- cases b <;> cases x <;> try exact this;\n    cases b <;> cases x <;>\n    revert this <;> simp only [Bool.not_false, Bool.not_true] <;> intro this <;>\n    (try exact this) <;> exact this.symm\n  rw [count_cons_of_ne x.not_ne_self, hl.count_not, h2, count_cons_self]\n\n"}
{"name":"List.Chain'.count_false_eq_count_true","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nh2 : Even l.length\n⊢ Eq (List.count Bool.false l) (List.count Bool.true l)","decl":"theorem count_false_eq_count_true (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) :\n    count false l = count true l :=\n  hl.count_not_eq_count h2 true\n\n"}
{"name":"List.Chain'.count_not_le_count_add_one","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nb : Bool\n⊢ LE.le (List.count b.not l) (HAdd.hAdd (List.count b l) 1)","decl":"theorem count_not_le_count_add_one (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    count (!b) l ≤ count b l + 1 := by\n  cases' l with x l\n  · exact zero_le _\n  obtain rfl | rfl : b = x ∨ b = !x := by simp only [Bool.eq_not_iff, em]\n  · rw [count_cons_of_ne b.not_ne_self, count_cons_self, hl.count_not, add_assoc]\n    exact add_le_add_left (Nat.mod_lt _ two_pos).le _\n  · rw [Bool.not_not, count_cons_self, count_cons_of_ne x.not_ne_self, hl.count_not]\n    exact add_le_add_right (le_add_right le_rfl) _\n\n"}
{"name":"List.Chain'.count_false_le_count_true_add_one","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\n⊢ LE.le (List.count Bool.false l) (HAdd.hAdd (List.count Bool.true l) 1)","decl":"theorem count_false_le_count_true_add_one (hl : Chain' (· ≠ ·) l) :\n    count false l ≤ count true l + 1 :=\n  hl.count_not_le_count_add_one true\n\n"}
{"name":"List.Chain'.count_true_le_count_false_add_one","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\n⊢ LE.le (List.count Bool.true l) (HAdd.hAdd (List.count Bool.false l) 1)","decl":"theorem count_true_le_count_false_add_one (hl : Chain' (· ≠ ·) l) :\n    count true l ≤ count false l + 1 :=\n  hl.count_not_le_count_add_one false\n\n"}
{"name":"List.Chain'.two_mul_count_bool_of_even","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nh2 : Even l.length\nb : Bool\n⊢ Eq (HMul.hMul 2 (List.count b l)) l.length","decl":"theorem two_mul_count_bool_of_even (hl : Chain' (· ≠ ·) l) (h2 : Even (length l)) (b : Bool) :\n    2 * count b l = length l := by\n  rw [← count_not_add_count l b, hl.count_not_eq_count h2, two_mul]\n\n"}
{"name":"List.Chain'.two_mul_count_bool_eq_ite","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nb : Bool\n⊢ Eq (HMul.hMul 2 (List.count b l)) (ite (Even l.length) l.length (ite (Eq (BEq.beq (Option.some b) l.head?) Bool.true) (HAdd.hAdd l.length 1) (HSub.hSub l.length 1)))","decl":"theorem two_mul_count_bool_eq_ite (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    2 * count b l =\n      if Even (length l) then length l else\n      if Option.some b == l.head? then length l + 1 else length l - 1 := by\n  by_cases h2 : Even (length l)\n  · rw [if_pos h2, hl.two_mul_count_bool_of_even h2]\n  · cases' l with x l\n    · exact (h2 .zero).elim\n    simp only [if_neg h2, count_cons, mul_add, head?, Option.mem_some_iff, @eq_comm _ x]\n    rw [length_cons, Nat.even_add_one, not_not] at h2\n    replace hl : l.Chain' (· ≠ ·) := hl.tail\n    rw [hl.two_mul_count_bool_of_even h2]\n    cases b <;> cases x <;> split_ifs <;> simp <;> contradiction\n\n"}
{"name":"List.Chain'.length_sub_one_le_two_mul_count_bool","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nb : Bool\n⊢ LE.le (HSub.hSub l.length 1) (HMul.hMul 2 (List.count b l))","decl":"theorem length_sub_one_le_two_mul_count_bool (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    length l - 1 ≤ 2 * count b l := by\n  rw [hl.two_mul_count_bool_eq_ite]\n  split_ifs <;> simp [le_tsub_add, Nat.le_succ_of_le]\n\n"}
{"name":"List.Chain'.length_div_two_le_count_bool","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nb : Bool\n⊢ LE.le (HDiv.hDiv l.length 2) (List.count b l)","decl":"theorem length_div_two_le_count_bool (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    length l / 2 ≤ count b l := by\n  rw [Nat.div_le_iff_le_mul_add_pred two_pos, ← tsub_le_iff_right]\n  exact length_sub_one_le_two_mul_count_bool hl b\n\n"}
{"name":"List.Chain'.two_mul_count_bool_le_length_add_one","module":"Mathlib.Data.Bool.Count","initialProofState":"l : List Bool\nhl : List.Chain' (fun x1 x2 => Ne x1 x2) l\nb : Bool\n⊢ LE.le (HMul.hMul 2 (List.count b l)) (HAdd.hAdd l.length 1)","decl":"theorem two_mul_count_bool_le_length_add_one (hl : Chain' (· ≠ ·) l) (b : Bool) :\n    2 * count b l ≤ length l + 1 := by\n  rw [hl.two_mul_count_bool_eq_ite]\n  split_ifs <;> simp [Nat.le_succ_of_le]\n\n"}
