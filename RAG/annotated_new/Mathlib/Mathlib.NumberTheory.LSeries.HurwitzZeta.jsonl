{"name":"HurwitzZeta.hurwitzZetaEven_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\n‚ä¢ Eq (HurwitzZeta.hurwitzZetaEven a s) (HDiv.hDiv (HAdd.hAdd (HurwitzZeta.hurwitzZeta a s) (HurwitzZeta.hurwitzZeta (Neg.neg a) s)) 2)","decl":"lemma hurwitzZetaEven_eq (a : UnitAddCircle) (s : ‚ÑÇ) :\n    hurwitzZetaEven a s = (hurwitzZeta a s + hurwitzZeta (-a) s) / 2 := by\n  simp only [hurwitzZeta, hurwitzZetaEven_neg, hurwitzZetaOdd_neg]\n  ring_nf\n\n"}
{"name":"HurwitzZeta.hurwitzZetaOdd_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\n‚ä¢ Eq (HurwitzZeta.hurwitzZetaOdd a s) (HDiv.hDiv (HSub.hSub (HurwitzZeta.hurwitzZeta a s) (HurwitzZeta.hurwitzZeta (Neg.neg a) s)) 2)","decl":"lemma hurwitzZetaOdd_eq (a : UnitAddCircle) (s : ‚ÑÇ) :\n    hurwitzZetaOdd a s = (hurwitzZeta a s - hurwitzZeta (-a) s) / 2 := by\n  simp only [hurwitzZeta, hurwitzZetaEven_neg, hurwitzZetaOdd_neg]\n  ring_nf\n\n"}
{"name":"HurwitzZeta.differentiableAt_hurwitzZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : Ne s 1\n‚ä¢ DifferentiableAt Complex (HurwitzZeta.hurwitzZeta a) s","decl":"/-- The Hurwitz zeta function is differentiable away from `s = 1`. -/\nlemma differentiableAt_hurwitzZeta (a : UnitAddCircle) {s : ‚ÑÇ} (hs : s ‚â† 1) :\n    DifferentiableAt ‚ÑÇ (hurwitzZeta a) s :=\n  (differentiableAt_hurwitzZetaEven a hs).add (differentiable_hurwitzZetaOdd a s)\n\n"}
{"name":"HurwitzZeta.hasSum_hurwitzZeta_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : Real\nha : Membership.mem (Set.Icc 0 1) a\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ HasSum (fun n => HDiv.hDiv 1 (HPow.hPow (HAdd.hAdd ‚Üën ‚Üëa) s)) (HurwitzZeta.hurwitzZeta (‚Üëa) s)","decl":"/-- Formula for `hurwitzZeta s` as a Dirichlet series in the convergence range. We\nrestrict to `a ‚àà Icc 0 1` to simplify the statement. -/\nlemma hasSum_hurwitzZeta_of_one_lt_re {a : ‚Ñù} (ha : a ‚àà Icc 0 1) {s : ‚ÑÇ} (hs : 1 < re s) :\n    HasSum (fun n : ‚Ñï ‚Ü¶ 1 / (n + a : ‚ÑÇ) ^ s) (hurwitzZeta a s) := by\n  convert (hasSum_nat_hurwitzZetaEven_of_mem_Icc ha hs).add\n      (hasSum_nat_hurwitzZetaOdd_of_mem_Icc ha hs) using 1\n  ext1 n\n  -- plain `ring_nf` works here, but the following is faster:\n  apply show ‚àÄ (x y : ‚ÑÇ), x = (x + y) / 2 + (x - y) / 2 by intros; ring\n\n"}
{"name":"HurwitzZeta.hurwitzZeta_residue_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\n‚ä¢ Filter.Tendsto (fun s => HMul.hMul (HSub.hSub s 1) (HurwitzZeta.hurwitzZeta a s)) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds 1)","decl":"/-- The residue of the Hurwitz zeta function at `s = 1` is `1`. -/\nlemma hurwitzZeta_residue_one (a : UnitAddCircle) :\n    Tendsto (fun s ‚Ü¶ (s - 1) * hurwitzZeta a s) (ùìù[‚â†] 1) (ùìù 1) := by\n  simp only [hurwitzZeta, mul_add, (by simp : ùìù (1 : ‚ÑÇ) = ùìù (1 + (1 - 1) * hurwitzZetaOdd a 1))]\n  refine (hurwitzZetaEven_residue_one a).add ((Tendsto.mul ?_ ?_).mono_left nhdsWithin_le_nhds)\n  exacts [tendsto_id.sub_const _, (differentiable_hurwitzZetaOdd a).continuous.tendsto _]\n\n"}
{"name":"HurwitzZeta.differentiableAt_hurwitzZeta_sub_one_div","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\n‚ä¢ DifferentiableAt Complex (fun s => HSub.hSub (HurwitzZeta.hurwitzZeta a s) (HDiv.hDiv (HDiv.hDiv 1 (HSub.hSub s 1)) s.Gamma‚Ñù)) 1","decl":"lemma differentiableAt_hurwitzZeta_sub_one_div (a : UnitAddCircle) :\n    DifferentiableAt ‚ÑÇ (fun s ‚Ü¶ hurwitzZeta a s - 1 / (s - 1) / Gamma‚Ñù s) 1 := by\n  simp only [hurwitzZeta, add_sub_right_comm]\n  exact (differentiableAt_hurwitzZetaEven_sub_one_div a).add (differentiable_hurwitzZetaOdd a 1)\n\n"}
{"name":"HurwitzZeta.tendsto_hurwitzZeta_sub_one_div_nhds_one","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\n‚ä¢ Filter.Tendsto (fun s => HSub.hSub (HurwitzZeta.hurwitzZeta a s) (HDiv.hDiv (HDiv.hDiv 1 (HSub.hSub s 1)) s.Gamma‚Ñù)) (nhds 1) (nhds (HurwitzZeta.hurwitzZeta a 1))","decl":"/-- Expression for `hurwitzZeta a 1` as a limit. (Mathematically `hurwitzZeta a 1` is\nundefined, but our construction assigns some value to it; this lemma is mostly of interest for\ndetermining what that value is). -/\nlemma tendsto_hurwitzZeta_sub_one_div_nhds_one (a : UnitAddCircle) :\n    Tendsto (fun s ‚Ü¶ hurwitzZeta a s - 1 / (s - 1) / Gamma‚Ñù s) (ùìù 1) (ùìù (hurwitzZeta a 1)) := by\n  simp only [hurwitzZeta, add_sub_right_comm]\n  refine (tendsto_hurwitzZetaEven_sub_one_div_nhds_one a).add\n    (differentiable_hurwitzZetaOdd a 1).continuousAt.tendsto\n\n"}
{"name":"HurwitzZeta.differentiable_hurwitzZeta_sub_hurwitzZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a b : UnitAddCircle\n‚ä¢ Differentiable Complex fun s => HSub.hSub (HurwitzZeta.hurwitzZeta a s) (HurwitzZeta.hurwitzZeta b s)","decl":"/-- The difference of two Hurwitz zeta functions is differentiable everywhere. -/\nlemma differentiable_hurwitzZeta_sub_hurwitzZeta (a b : UnitAddCircle) :\n    Differentiable ‚ÑÇ (fun s ‚Ü¶ hurwitzZeta a s - hurwitzZeta b s) := by\n  simp only [hurwitzZeta, add_sub_add_comm]\n  refine (differentiable_hurwitzZetaEven_sub_hurwitzZetaEven a b).add (.sub ?_ ?_)\n  all_goals apply differentiable_hurwitzZetaOdd\n\n"}
{"name":"HurwitzZeta.cosZeta_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\n‚ä¢ Eq (HurwitzZeta.cosZeta a s) (HDiv.hDiv (HAdd.hAdd (HurwitzZeta.expZeta a s) (HurwitzZeta.expZeta (Neg.neg a) s)) 2)","decl":"lemma cosZeta_eq (a : UnitAddCircle) (s : ‚ÑÇ) :\n    cosZeta a s = (expZeta a s + expZeta (-a) s) / 2 := by\n  rw [expZeta, expZeta, cosZeta_neg, sinZeta_neg]\n  ring_nf\n\n"}
{"name":"HurwitzZeta.sinZeta_eq","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\n‚ä¢ Eq (HurwitzZeta.sinZeta a s) (HDiv.hDiv (HSub.hSub (HurwitzZeta.expZeta a s) (HurwitzZeta.expZeta (Neg.neg a) s)) (HMul.hMul 2 Complex.I))","decl":"lemma sinZeta_eq (a : UnitAddCircle) (s : ‚ÑÇ) :\n    sinZeta a s = (expZeta a s - expZeta (-a) s) / (2 * I) := by\n  rw [expZeta, expZeta, cosZeta_neg, sinZeta_neg]\n  field_simp\n  ring_nf\n\n"}
{"name":"HurwitzZeta.hasSum_expZeta_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ HasSum (fun n => HDiv.hDiv (Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üëa) ‚Üën)) (HPow.hPow (‚Üën) s)) (HurwitzZeta.expZeta (‚Üëa) s)","decl":"lemma hasSum_expZeta_of_one_lt_re (a : ‚Ñù) {s : ‚ÑÇ} (hs : 1 < re s) :\n    HasSum (fun n : ‚Ñï ‚Ü¶ cexp (2 * œÄ * I * a * n) / n ^ s) (expZeta a s) := by\n  convert (hasSum_nat_cosZeta a hs).add ((hasSum_nat_sinZeta a hs).mul_left I) using 1\n  ext1 n\n  simp only [mul_right_comm _ I, ‚Üê cos_add_sin_I, push_cast]\n  rw [add_div, mul_div, mul_comm _ I]\n\n"}
{"name":"HurwitzZeta.differentiableAt_expZeta","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : Or (Ne s 1) (Ne a 0)\n‚ä¢ DifferentiableAt Complex (HurwitzZeta.expZeta a) s","decl":"lemma differentiableAt_expZeta (a : UnitAddCircle) (s : ‚ÑÇ) (hs : s ‚â† 1 ‚à® a ‚â† 0) :\n    DifferentiableAt ‚ÑÇ (expZeta a) s := by\n  apply DifferentiableAt.add\n  ¬∑ exact differentiableAt_cosZeta a hs\n  ¬∑ apply (differentiableAt_const _).mul (differentiableAt_sinZeta a s)\n\n"}
{"name":"HurwitzZeta.differentiable_expZeta_of_ne_zero","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\nha : Ne a 0\n‚ä¢ Differentiable Complex (HurwitzZeta.expZeta a)","decl":"/-- If `a ‚â† 0` then the exponential zeta function is analytic everywhere. -/\nlemma differentiable_expZeta_of_ne_zero {a : UnitAddCircle} (ha : a ‚â† 0) :\n    Differentiable ‚ÑÇ (expZeta a) :=\n  (differentiableAt_expZeta a ¬∑ (Or.inr ha))\n\n"}
{"name":"HurwitzZeta.LSeriesHasSum_exp","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : Real\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ LSeriesHasSum (fun x => Complex.exp (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) ‚Üëa) ‚Üëx)) s (HurwitzZeta.expZeta (‚Üëa) s)","decl":"/-- Reformulation of `hasSum_expZeta_of_one_lt_re` using `LSeriesHasSum`. -/\nlemma LSeriesHasSum_exp (a : ‚Ñù) {s : ‚ÑÇ} (hs : 1 < re s) :\n    LSeriesHasSum (cexp <| 2 * œÄ * I * a * ¬∑) s (expZeta a s) :=\n  (hasSum_expZeta_of_one_lt_re a hs).congr_fun\n    (LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs) _)\n\n"}
{"name":"HurwitzZeta.hurwitzZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ‚àÄ (n : Nat), Ne s (Neg.neg ‚Üën)\nhs' : Or (Ne a 0) (Ne s 1)\n‚ä¢ Eq (HurwitzZeta.hurwitzZeta a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 ‚ÜëReal.pi) (Neg.neg s)) (Complex.Gamma s)) (HAdd.hAdd (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) Complex.I) s) 2)) (HurwitzZeta.expZeta a s)) (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (‚ÜëReal.pi) Complex.I) s) 2)) (HurwitzZeta.expZeta (Neg.neg a) s))))","decl":"lemma hurwitzZeta_one_sub (a : UnitAddCircle) {s : ‚ÑÇ}\n    (hs : ‚àÄ (n : ‚Ñï), s ‚â† -n) (hs' : a ‚â† 0 ‚à® s ‚â† 1) :\n    hurwitzZeta a (1 - s) = (2 * œÄ) ^ (-s) * Gamma s *\n    (exp (-œÄ * I * s / 2) * expZeta a s + exp (œÄ * I * s / 2) * expZeta (-a) s) := by\n  rw [hurwitzZeta, hurwitzZetaEven_one_sub a hs hs', hurwitzZetaOdd_one_sub a hs,\n    expZeta, expZeta, Complex.cos, Complex.sin, sinZeta_neg, cosZeta_neg]\n  rw [show ‚ÜëœÄ * I * s / 2 = ‚ÜëœÄ * s / 2 * I by ring,\n    show -‚ÜëœÄ * I * s / 2 = -(‚ÜëœÄ * s / 2) * I by ring]\n  -- these `generalize` commands are not strictly needed for the `ring_nf` call to succeed, but\n  -- make it run faster:\n  generalize (2 * œÄ : ‚ÑÇ) ^ (-s) = x\n  generalize (‚ÜëœÄ * s / 2 * I).exp = y\n  generalize (-(‚ÜëœÄ * s / 2) * I).exp = z\n  ring_nf\n\n"}
{"name":"HurwitzZeta.expZeta_one_sub","module":"Mathlib.NumberTheory.LSeries.HurwitzZeta","initialProofState":"a : UnitAddCircle\ns : Complex\nhs : ‚àÄ (n : Nat), Ne s (HSub.hSub 1 ‚Üën)\n‚ä¢ Eq (HurwitzZeta.expZeta a (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HPow.hPow (HMul.hMul 2 ‚ÜëReal.pi) (Neg.neg s)) (Complex.Gamma s)) (HAdd.hAdd (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (‚ÜëReal.pi) Complex.I) s) 2)) (HurwitzZeta.hurwitzZeta a s)) (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) Complex.I) s) 2)) (HurwitzZeta.hurwitzZeta (Neg.neg a) s))))","decl":"/-- Functional equation for the exponential zeta function. -/\nlemma expZeta_one_sub (a : UnitAddCircle) {s : ‚ÑÇ} (hs : ‚àÄ (n : ‚Ñï), s ‚â† 1 - n) :\n    expZeta a (1 - s) = (2 * œÄ) ^ (-s) * Gamma s *\n    (exp (œÄ * I * s / 2) * hurwitzZeta a s + exp (-œÄ * I * s / 2) * hurwitzZeta (-a) s) := by\n  have hs' (n : ‚Ñï) : s ‚â† -‚Üën := by\n    convert hs (n + 1) using 1\n    push_cast\n    ring\n  rw [expZeta, cosZeta_one_sub a hs, sinZeta_one_sub a hs', hurwitzZeta, hurwitzZeta,\n    hurwitzZetaEven_neg, hurwitzZetaOdd_neg, Complex.cos, Complex.sin]\n  rw [show ‚ÜëœÄ * I * s / 2 = ‚ÜëœÄ * s / 2 * I by ring,\n    show -‚ÜëœÄ * I * s / 2 = -(‚ÜëœÄ * s / 2) * I by ring]\n  -- these `generalize` commands are not strictly needed for the `ring_nf` call to succeed, but\n  -- make it run faster:\n  generalize (2 * œÄ : ‚ÑÇ) ^ (-s) = x\n  generalize (‚ÜëœÄ * s / 2 * I).exp = y\n  generalize (-(‚ÜëœÄ * s / 2) * I).exp = z\n  ring_nf\n  rw [I_sq]\n  ring_nf\n\n"}
