{"name":"IsGδ.compl_singleton","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\nx : X\ninst✝ : T1Space X\n⊢ IsGδ (HasCompl.compl (Singleton.singleton x))","decl":"theorem IsGδ.compl_singleton (x : X) [T1Space X] : IsGδ ({x}ᶜ : Set X) :=\n  isOpen_compl_singleton.isGδ\n\n\n"}
{"name":"Set.Countable.isGδ_compl","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : T1Space X\nhs : s.Countable\n⊢ IsGδ (HasCompl.compl s)","decl":"theorem Set.Countable.isGδ_compl {s : Set X} [T1Space X] (hs : s.Countable) : IsGδ sᶜ := by\n  rw [← biUnion_of_singleton s, compl_iUnion₂]\n  exact .biInter hs fun x _ => .compl_singleton x\n\n"}
{"name":"Set.Finite.isGδ_compl","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : T1Space X\nhs : s.Finite\n⊢ IsGδ (HasCompl.compl s)","decl":"theorem Set.Finite.isGδ_compl {s : Set X} [T1Space X] (hs : s.Finite) : IsGδ sᶜ :=\n  hs.countable.isGδ_compl\n\n"}
{"name":"Set.Subsingleton.isGδ_compl","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ns : Set X\ninst✝ : T1Space X\nhs : s.Subsingleton\n⊢ IsGδ (HasCompl.compl s)","decl":"theorem Set.Subsingleton.isGδ_compl {s : Set X} [T1Space X] (hs : s.Subsingleton) : IsGδ sᶜ :=\n  hs.finite.isGδ_compl\n\n"}
{"name":"Finset.isGδ_compl","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T1Space X\ns : Finset X\n⊢ IsGδ (HasCompl.compl ↑s)","decl":"theorem Finset.isGδ_compl [T1Space X] (s : Finset X) : IsGδ (sᶜ : Set X) :=\n  s.finite_toSet.isGδ_compl\n\n"}
{"name":"IsGδ.singleton","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : FirstCountableTopology X\ninst✝ : T1Space X\nx : X\n⊢ IsGδ (Singleton.singleton x)","decl":"protected theorem IsGδ.singleton [FirstCountableTopology X] [T1Space X] (x : X) :\n    IsGδ ({x} : Set X) := by\n  rcases (nhds_basis_opens x).exists_antitone_subbasis with ⟨U, hU, h_basis⟩\n  rw [← biInter_basis_nhds h_basis.toHasBasis]\n  exact .biInter (to_countable _) fun n _ => (hU n).2.isGδ\n\n\n"}
{"name":"Set.Finite.isGδ","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝² : TopologicalSpace X\ninst✝¹ : FirstCountableTopology X\ns : Set X\ninst✝ : T1Space X\nhs : s.Finite\n⊢ IsGδ s","decl":"theorem Set.Finite.isGδ [FirstCountableTopology X] {s : Set X} [T1Space X] (hs : s.Finite) :\n    IsGδ s :=\n  Finite.induction_on _ hs .empty fun _ _ ↦ .union (.singleton _)\n\n\n"}
{"name":"PerfectlyNormalSpace.closed_gdelta","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : PerfectlyNormalSpace X\nh : Set X\na✝ : IsClosed h\n⊢ IsGδ h","decl":"/-- A topological space `X` is a *perfectly normal space* provided it is normal and\nclosed sets are Gδ. -/\nclass PerfectlyNormalSpace (X : Type u) [TopologicalSpace X] extends NormalSpace X : Prop where\n    closed_gdelta : ∀ ⦃h : Set X⦄, IsClosed h → IsGδ h\n\n"}
{"name":"PerfectlyNormalSpace.toNormalSpace","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : PerfectlyNormalSpace X\n⊢ NormalSpace X","decl":"/-- A topological space `X` is a *perfectly normal space* provided it is normal and\nclosed sets are Gδ. -/\nclass PerfectlyNormalSpace (X : Type u) [TopologicalSpace X] extends NormalSpace X : Prop where\n    closed_gdelta : ∀ ⦃h : Set X⦄, IsClosed h → IsGδ h\n\n"}
{"name":"Disjoint.hasSeparatingCover_closed_gdelta_right","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ns t : Set X\ninst✝ : NormalSpace X\nst_dis : Disjoint s t\nt_cl : IsClosed t\nt_gd : IsGδ t\n⊢ HasSeparatingCover s t","decl":"/-- Lemma that allows the easy conclusion that perfectly normal spaces are completely normal. -/\ntheorem Disjoint.hasSeparatingCover_closed_gdelta_right {s t : Set X} [NormalSpace X]\n    (st_dis : Disjoint s t) (t_cl : IsClosed t) (t_gd : IsGδ t) : HasSeparatingCover s t := by\n  obtain ⟨T, T_open, T_count, T_int⟩ := t_gd\n  rcases T.eq_empty_or_nonempty with rfl | T_nonempty\n  · rw [T_int, sInter_empty] at st_dis\n    rw [(s.disjoint_univ).mp st_dis]\n    exact t.hasSeparatingCover_empty_left\n  obtain ⟨g, g_surj⟩ := T_count.exists_surjective T_nonempty\n  choose g' g'_open clt_sub_g' clg'_sub_g using fun n ↦ by\n    apply normal_exists_closure_subset t_cl (T_open (g n).1 (g n).2)\n    rw [T_int]\n    exact sInter_subset_of_mem (g n).2\n  have clg'_int : t = ⋂ i, closure (g' i) := by\n    apply (subset_iInter fun n ↦ (clt_sub_g' n).trans subset_closure).antisymm\n    rw [T_int]\n    refine subset_sInter fun t tinT ↦ ?_\n    obtain ⟨n, gn⟩ := g_surj ⟨t, tinT⟩\n    refine iInter_subset_of_subset n <| (clg'_sub_g n).trans ?_\n    rw [gn]\n  use fun n ↦ (closure (g' n))ᶜ\n  constructor\n  · rw [← compl_iInter, subset_compl_comm, ← clg'_int]\n    exact st_dis.subset_compl_left\n  · refine fun n ↦ ⟨isOpen_compl_iff.mpr isClosed_closure, ?_⟩\n    simp only [closure_compl, disjoint_compl_left_iff_subset]\n    rw [← closure_eq_iff_isClosed.mpr t_cl] at clt_sub_g'\n    exact subset_closure.trans <| (clt_sub_g' n).trans <| (g'_open n).subset_interior_closure\n\n"}
{"name":"PerfectlyNormalSpace.toCompletelyNormalSpace","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : PerfectlyNormalSpace X\n⊢ CompletelyNormalSpace X","decl":"instance (priority := 100) PerfectlyNormalSpace.toCompletelyNormalSpace\n    [PerfectlyNormalSpace X] : CompletelyNormalSpace X where\n  completely_normal _ _ hd₁ hd₂ := separatedNhds_iff_disjoint.mp <|\n    hasSeparatingCovers_iff_separatedNhds.mp\n      ⟨(hd₂.hasSeparatingCover_closed_gdelta_right isClosed_closure <|\n         closed_gdelta isClosed_closure).mono (fun ⦃_⦄ a ↦ a) subset_closure,\n       ((Disjoint.symm hd₁).hasSeparatingCover_closed_gdelta_right isClosed_closure <|\n         closed_gdelta isClosed_closure).mono (fun ⦃_⦄ a ↦ a) subset_closure⟩\n\n"}
{"name":"T6Space.toT1Space","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : T6Space X\n⊢ T1Space X","decl":"/-- A T₆ space is a perfectly normal T₁ space. -/\nclass T6Space (X : Type u) [TopologicalSpace X] extends T1Space X, PerfectlyNormalSpace X : Prop\n\n-- see Note [lower instance priority]\n"}
{"name":"T6Space.toPerfectlyNormalSpace","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : T6Space X\n⊢ PerfectlyNormalSpace X","decl":"/-- A T₆ space is a perfectly normal T₁ space. -/\nclass T6Space (X : Type u) [TopologicalSpace X] extends T1Space X, PerfectlyNormalSpace X : Prop\n\n-- see Note [lower instance priority]\n"}
{"name":"T6Space.toT5Space","module":"Mathlib.Topology.Separation.GDelta","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : T6Space X\n⊢ T5Space X","decl":"/-- A `T₆` space is a `T₅` space. -/\ninstance (priority := 100) T6Space.toT5Space [T6Space X] : T5Space X where\n  -- follows from type-class inference\n"}
