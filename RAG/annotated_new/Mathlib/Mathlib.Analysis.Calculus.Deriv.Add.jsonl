{"name":"HasDerivAtFilter.add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nL : Filter 𝕜\nhf : HasDerivAtFilter f f' x L\nhg : HasDerivAtFilter g g' x L\n⊢ HasDerivAtFilter (fun y => HAdd.hAdd (f y) (g y)) (HAdd.hAdd f' g') x L","decl":"nonrec theorem HasDerivAtFilter.add (hf : HasDerivAtFilter f f' x L)\n    (hg : HasDerivAtFilter g g' x L) : HasDerivAtFilter (fun y => f y + g y) (f' + g') x L := by\n  simpa using (hf.add hg).hasDerivAtFilter\n\n"}
{"name":"HasStrictDerivAt.add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nhf : HasStrictDerivAt f f' x\nhg : HasStrictDerivAt g g' x\n⊢ HasStrictDerivAt (fun y => HAdd.hAdd (f y) (g y)) (HAdd.hAdd f' g') x","decl":"nonrec theorem HasStrictDerivAt.add (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\n    HasStrictDerivAt (fun y => f y + g y) (f' + g') x := by simpa using (hf.add hg).hasStrictDerivAt\n\n"}
{"name":"HasDerivWithinAt.add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\ns : Set 𝕜\nhf : HasDerivWithinAt f f' s x\nhg : HasDerivWithinAt g g' s x\n⊢ HasDerivWithinAt (fun y => HAdd.hAdd (f y) (g y)) (HAdd.hAdd f' g') s x","decl":"nonrec theorem HasDerivWithinAt.add (hf : HasDerivWithinAt f f' s x)\n    (hg : HasDerivWithinAt g g' s x) : HasDerivWithinAt (fun y => f y + g y) (f' + g') s x :=\n  hf.add hg\n\n"}
{"name":"HasDerivAt.add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nhf : HasDerivAt f f' x\nhg : HasDerivAt g g' x\n⊢ HasDerivAt (fun x => HAdd.hAdd (f x) (g x)) (HAdd.hAdd f' g') x","decl":"nonrec theorem HasDerivAt.add (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x) :\n    HasDerivAt (fun x => f x + g x) (f' + g') x :=\n  hf.add hg\n\n"}
{"name":"derivWithin_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nhf : DifferentiableWithinAt 𝕜 f s x\nhg : DifferentiableWithinAt 𝕜 g s x\n⊢ Eq (derivWithin (fun y => HAdd.hAdd (f y) (g y)) s x) (HAdd.hAdd (derivWithin f s x) (derivWithin g s x))","decl":"theorem derivWithin_add (hf : DifferentiableWithinAt 𝕜 f s x)\n    (hg : DifferentiableWithinAt 𝕜 g s x) :\n    derivWithin (fun y => f y + g y) s x = derivWithin f s x + derivWithin g s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hf.hasDerivWithinAt.add hg.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nx : 𝕜\nhf : DifferentiableAt 𝕜 f x\nhg : DifferentiableAt 𝕜 g x\n⊢ Eq (deriv (fun y => HAdd.hAdd (f y) (g y)) x) (HAdd.hAdd (deriv f x) (deriv g x))","decl":"@[simp]\ntheorem deriv_add (hf : DifferentiableAt 𝕜 f x) (hg : DifferentiableAt 𝕜 g x) :\n    deriv (fun y => f y + g y) x = deriv f x + deriv g x :=\n  (hf.hasDerivAt.add hg.hasDerivAt).deriv\n\n"}
{"name":"HasStrictDerivAt.add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nc : F\nhf : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun y => HAdd.hAdd (f y) c) f' x","decl":"theorem HasStrictDerivAt.add_const (c : F) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y ↦ f y + c) f' x :=\n  add_zero f' ▸ hf.add (hasStrictDerivAt_const x c)\n\n"}
{"name":"HasDerivAtFilter.add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nhf : HasDerivAtFilter f f' x L\nc : F\n⊢ HasDerivAtFilter (fun y => HAdd.hAdd (f y) c) f' x L","decl":"theorem HasDerivAtFilter.add_const (hf : HasDerivAtFilter f f' x L) (c : F) :\n    HasDerivAtFilter (fun y => f y + c) f' x L :=\n  add_zero f' ▸ hf.add (hasDerivAtFilter_const x L c)\n\n"}
{"name":"HasDerivWithinAt.add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nhf : HasDerivWithinAt f f' s x\nc : F\n⊢ HasDerivWithinAt (fun y => HAdd.hAdd (f y) c) f' s x","decl":"nonrec theorem HasDerivWithinAt.add_const (hf : HasDerivWithinAt f f' s x) (c : F) :\n    HasDerivWithinAt (fun y => f y + c) f' s x :=\n  hf.add_const c\n\n"}
{"name":"HasDerivAt.add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nhf : HasDerivAt f f' x\nc : F\n⊢ HasDerivAt (fun x => HAdd.hAdd (f x) c) f' x","decl":"nonrec theorem HasDerivAt.add_const (hf : HasDerivAt f f' x) (c : F) :\n    HasDerivAt (fun x => f x + c) f' x :=\n  hf.add_const c\n\n"}
{"name":"derivWithin_add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nc : F\n⊢ Eq (derivWithin (fun y => HAdd.hAdd (f y) c) s x) (derivWithin f s x)","decl":"theorem derivWithin_add_const (c : F) :\n    derivWithin (fun y => f y + c) s x = derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp only [derivWithin, fderivWithin_add_const hxs]\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nc : F\n⊢ Eq (deriv (fun y => HAdd.hAdd (f y) c) x) (deriv f x)","decl":"theorem deriv_add_const (c : F) : deriv (fun y => f y + c) x = deriv f x := by\n  simp only [deriv, fderiv_add_const]\n\n"}
{"name":"deriv_add_const'","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nc : F\n⊢ Eq (deriv fun y => HAdd.hAdd (f y) c) (deriv f)","decl":"@[simp]\ntheorem deriv_add_const' (c : F) : (deriv fun y => f y + c) = deriv f :=\n  funext fun _ => deriv_add_const c\n\n"}
{"name":"HasStrictDerivAt.const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nc : F\nhf : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun y => HAdd.hAdd c (f y)) f' x","decl":"theorem HasStrictDerivAt.const_add (c : F) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun y ↦ c + f y) f' x :=\n  zero_add f' ▸ (hasStrictDerivAt_const x c).add hf\n\n"}
{"name":"HasDerivAtFilter.const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nc : F\nhf : HasDerivAtFilter f f' x L\n⊢ HasDerivAtFilter (fun y => HAdd.hAdd c (f y)) f' x L","decl":"theorem HasDerivAtFilter.const_add (c : F) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun y => c + f y) f' x L :=\n  zero_add f' ▸ (hasDerivAtFilter_const x L c).add hf\n\n"}
{"name":"HasDerivWithinAt.const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nc : F\nhf : HasDerivWithinAt f f' s x\n⊢ HasDerivWithinAt (fun y => HAdd.hAdd c (f y)) f' s x","decl":"nonrec theorem HasDerivWithinAt.const_add (c : F) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun y => c + f y) f' s x :=\n  hf.const_add c\n\n"}
{"name":"HasDerivAt.const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nc : F\nhf : HasDerivAt f f' x\n⊢ HasDerivAt (fun x => HAdd.hAdd c (f x)) f' x","decl":"nonrec theorem HasDerivAt.const_add (c : F) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun x => c + f x) f' x :=\n  hf.const_add c\n\n"}
{"name":"derivWithin_const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nc : F\n⊢ Eq (derivWithin (fun y => HAdd.hAdd c (f y)) s x) (derivWithin f s x)","decl":"theorem derivWithin_const_add (c : F) :\n    derivWithin (fun y => c + f y) s x = derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp only [derivWithin, fderivWithin_const_add hxs]\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nc : F\n⊢ Eq (deriv (fun y => HAdd.hAdd c (f y)) x) (deriv f x)","decl":"theorem deriv_const_add (c : F) : deriv (fun y => c + f y) x = deriv f x := by\n  simp only [deriv, fderiv_const_add]\n\n"}
{"name":"deriv_const_add'","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nc : F\n⊢ Eq (deriv fun y => HAdd.hAdd c (f y)) (deriv f)","decl":"@[simp]\ntheorem deriv_const_add' (c : F) : (deriv fun y => c + f y) = deriv f :=\n  funext fun _ => deriv_const_add c\n\n"}
{"name":"differentiableAt_comp_const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => f (HAdd.hAdd b x)) a) (DifferentiableAt 𝕜 f (HAdd.hAdd b a))","decl":"lemma differentiableAt_comp_const_add {a b : 𝕜} :\n    DifferentiableAt 𝕜 (fun x ↦ f (b + x)) a ↔ DifferentiableAt 𝕜 f (b + a) := by\n  refine ⟨fun H ↦ ?_, fun H ↦ H.comp _ (differentiable_id.const_add _).differentiableAt⟩\n  convert DifferentiableAt.comp (b + a) (by simpa)\n    (differentiable_id.const_add (-b)).differentiableAt\n  ext\n  simp\n\n"}
{"name":"differentiableAt_comp_add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => f (HAdd.hAdd x b)) a) (DifferentiableAt 𝕜 f (HAdd.hAdd a b))","decl":"lemma differentiableAt_comp_add_const {a b : 𝕜} :\n    DifferentiableAt 𝕜 (fun x ↦ f (x + b)) a ↔ DifferentiableAt 𝕜 f (a + b) := by\n  simpa [add_comm b] using differentiableAt_comp_const_add (f := f) (b := b)\n\n"}
{"name":"differentiableAt_iff_comp_const_add","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 f a) (DifferentiableAt 𝕜 (fun x => f (HAdd.hAdd b x)) (HAdd.hAdd (Neg.neg b) a))","decl":"lemma differentiableAt_iff_comp_const_add {a b : 𝕜} :\n    DifferentiableAt 𝕜 f a ↔ DifferentiableAt 𝕜 (fun x ↦ f (b + x)) (-b + a) := by\n  simp [differentiableAt_comp_const_add]\n\n"}
{"name":"differentiableAt_iff_comp_add_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 f a) (DifferentiableAt 𝕜 (fun x => f (HAdd.hAdd x b)) (HSub.hSub a b))","decl":"lemma differentiableAt_iff_comp_add_const {a b : 𝕜} :\n    DifferentiableAt 𝕜 f a ↔ DifferentiableAt 𝕜 (fun x ↦ f (x + b)) (a - b) := by\n  simp [differentiableAt_comp_add_const]\n\n"}
{"name":"HasDerivAtFilter.sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\nL : Filter 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nA' : ι → F\nh : ∀ (i : ι), Membership.mem u i → HasDerivAtFilter (A i) (A' i) x L\n⊢ HasDerivAtFilter (fun y => u.sum fun i => A i y) (u.sum fun i => A' i) x L","decl":"theorem HasDerivAtFilter.sum (h : ∀ i ∈ u, HasDerivAtFilter (A i) (A' i) x L) :\n    HasDerivAtFilter (fun y => ∑ i ∈ u, A i y) (∑ i ∈ u, A' i) x L := by\n  simpa [ContinuousLinearMap.sum_apply] using (HasFDerivAtFilter.sum h).hasDerivAtFilter\n\n"}
{"name":"HasStrictDerivAt.sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nA' : ι → F\nh : ∀ (i : ι), Membership.mem u i → HasStrictDerivAt (A i) (A' i) x\n⊢ HasStrictDerivAt (fun y => u.sum fun i => A i y) (u.sum fun i => A' i) x","decl":"theorem HasStrictDerivAt.sum (h : ∀ i ∈ u, HasStrictDerivAt (A i) (A' i) x) :\n    HasStrictDerivAt (fun y => ∑ i ∈ u, A i y) (∑ i ∈ u, A' i) x := by\n  simpa [ContinuousLinearMap.sum_apply] using (HasStrictFDerivAt.sum h).hasStrictDerivAt\n\n"}
{"name":"HasDerivWithinAt.sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nA' : ι → F\nh : ∀ (i : ι), Membership.mem u i → HasDerivWithinAt (A i) (A' i) s x\n⊢ HasDerivWithinAt (fun y => u.sum fun i => A i y) (u.sum fun i => A' i) s x","decl":"theorem HasDerivWithinAt.sum (h : ∀ i ∈ u, HasDerivWithinAt (A i) (A' i) s x) :\n    HasDerivWithinAt (fun y => ∑ i ∈ u, A i y) (∑ i ∈ u, A' i) s x :=\n  HasDerivAtFilter.sum h\n\n"}
{"name":"HasDerivAt.sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nA' : ι → F\nh : ∀ (i : ι), Membership.mem u i → HasDerivAt (A i) (A' i) x\n⊢ HasDerivAt (fun y => u.sum fun i => A i y) (u.sum fun i => A' i) x","decl":"theorem HasDerivAt.sum (h : ∀ i ∈ u, HasDerivAt (A i) (A' i) x) :\n    HasDerivAt (fun y => ∑ i ∈ u, A i y) (∑ i ∈ u, A' i) x :=\n  HasDerivAtFilter.sum h\n\n"}
{"name":"derivWithin_sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\ns : Set 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nh : ∀ (i : ι), Membership.mem u i → DifferentiableWithinAt 𝕜 (A i) s x\n⊢ Eq (derivWithin (fun y => u.sum fun i => A i y) s x) (u.sum fun i => derivWithin (A i) s x)","decl":"theorem derivWithin_sum (h : ∀ i ∈ u, DifferentiableWithinAt 𝕜 (A i) s x) :\n    derivWithin (fun y => ∑ i ∈ u, A i y) s x = ∑ i ∈ u, derivWithin (A i) s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (HasDerivWithinAt.sum fun i hi => (h i hi).hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_sum","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : 𝕜\nι : Type u_1\nu : Finset ι\nA : ι → 𝕜 → F\nh : ∀ (i : ι), Membership.mem u i → DifferentiableAt 𝕜 (A i) x\n⊢ Eq (deriv (fun y => u.sum fun i => A i y) x) (u.sum fun i => deriv (A i) x)","decl":"@[simp]\ntheorem deriv_sum (h : ∀ i ∈ u, DifferentiableAt 𝕜 (A i) x) :\n    deriv (fun y => ∑ i ∈ u, A i y) x = ∑ i ∈ u, deriv (A i) x :=\n  (HasDerivAt.sum fun i hi => (h i hi).hasDerivAt).deriv\n\n"}
{"name":"HasDerivAtFilter.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nh : HasDerivAtFilter f f' x L\n⊢ HasDerivAtFilter (fun x => Neg.neg (f x)) (Neg.neg f') x L","decl":"nonrec theorem HasDerivAtFilter.neg (h : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun x => -f x) (-f') x L := by simpa using h.neg.hasDerivAtFilter\n\n"}
{"name":"HasDerivWithinAt.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nh : HasDerivWithinAt f f' s x\n⊢ HasDerivWithinAt (fun x => Neg.neg (f x)) (Neg.neg f') s x","decl":"nonrec theorem HasDerivWithinAt.neg (h : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun x => -f x) (-f') s x :=\n  h.neg\n\n"}
{"name":"HasDerivAt.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nh : HasDerivAt f f' x\n⊢ HasDerivAt (fun x => Neg.neg (f x)) (Neg.neg f') x","decl":"nonrec theorem HasDerivAt.neg (h : HasDerivAt f f' x) : HasDerivAt (fun x => -f x) (-f') x :=\n  h.neg\n\n"}
{"name":"HasStrictDerivAt.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nh : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun x => Neg.neg (f x)) (Neg.neg f') x","decl":"nonrec theorem HasStrictDerivAt.neg (h : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun x => -f x) (-f') x := by simpa using h.neg.hasStrictDerivAt\n\n"}
{"name":"derivWithin.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\n⊢ Eq (derivWithin (fun y => Neg.neg (f y)) s x) (Neg.neg (derivWithin f s x))","decl":"theorem derivWithin.neg : derivWithin (fun y => -f y) s x = -derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp only [derivWithin, fderivWithin_neg hxs, ContinuousLinearMap.neg_apply]\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv.neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\n⊢ Eq (deriv (fun y => Neg.neg (f y)) x) (Neg.neg (deriv f x))","decl":"theorem deriv.neg : deriv (fun y => -f y) x = -deriv f x := by\n  simp only [deriv, fderiv_neg, ContinuousLinearMap.neg_apply]\n\n"}
{"name":"deriv.neg'","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\n⊢ Eq (deriv fun y => Neg.neg (f y)) fun x => Neg.neg (deriv f x)","decl":"@[simp]\ntheorem deriv.neg' : (deriv fun y => -f y) = fun x => -deriv f x :=\n  funext fun _ => deriv.neg\n\n"}
{"name":"hasDerivAtFilter_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\nL : Filter 𝕜\n⊢ HasDerivAtFilter Neg.neg (-1) x L","decl":"theorem hasDerivAtFilter_neg : HasDerivAtFilter Neg.neg (-1) x L :=\n  HasDerivAtFilter.neg <| hasDerivAtFilter_id _ _\n\n"}
{"name":"hasDerivWithinAt_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\n⊢ HasDerivWithinAt Neg.neg (-1) s x","decl":"theorem hasDerivWithinAt_neg : HasDerivWithinAt Neg.neg (-1) s x :=\n  hasDerivAtFilter_neg _ _\n\n"}
{"name":"hasDerivAt_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ HasDerivAt Neg.neg (-1) x","decl":"theorem hasDerivAt_neg : HasDerivAt Neg.neg (-1) x :=\n  hasDerivAtFilter_neg _ _\n\n"}
{"name":"hasDerivAt_neg'","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ HasDerivAt (fun x => Neg.neg x) (-1) x","decl":"theorem hasDerivAt_neg' : HasDerivAt (fun x => -x) (-1) x :=\n  hasDerivAtFilter_neg _ _\n\n"}
{"name":"hasStrictDerivAt_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ HasStrictDerivAt Neg.neg (-1) x","decl":"theorem hasStrictDerivAt_neg : HasStrictDerivAt Neg.neg (-1) x :=\n  HasStrictDerivAt.neg <| hasStrictDerivAt_id _\n\n"}
{"name":"deriv_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Eq (deriv Neg.neg x) (-1)","decl":"theorem deriv_neg : deriv Neg.neg x = -1 :=\n  HasDerivAt.deriv (hasDerivAt_neg x)\n\n"}
{"name":"deriv_neg'","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Eq (deriv Neg.neg) fun x => -1","decl":"@[simp]\ntheorem deriv_neg' : deriv (Neg.neg : 𝕜 → 𝕜) = fun _ => -1 :=\n  funext deriv_neg\n\n"}
{"name":"deriv_neg''","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ Eq (deriv (fun x => Neg.neg x) x) (-1)","decl":"@[simp]\ntheorem deriv_neg'' : deriv (fun x : 𝕜 => -x) x = -1 :=\n  deriv_neg x\n\n"}
{"name":"derivWithin_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\ns : Set 𝕜\nhxs : UniqueDiffWithinAt 𝕜 s x\n⊢ Eq (derivWithin Neg.neg s x) (-1)","decl":"theorem derivWithin_neg (hxs : UniqueDiffWithinAt 𝕜 s x) : derivWithin Neg.neg s x = -1 :=\n  (hasDerivWithinAt_neg x s).derivWithin hxs\n\n"}
{"name":"differentiable_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\n⊢ Differentiable 𝕜 Neg.neg","decl":"theorem differentiable_neg : Differentiable 𝕜 (Neg.neg : 𝕜 → 𝕜) :=\n  Differentiable.neg differentiable_id\n\n"}
{"name":"differentiableOn_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝ : NontriviallyNormedField 𝕜\ns : Set 𝕜\n⊢ DifferentiableOn 𝕜 Neg.neg s","decl":"theorem differentiableOn_neg : DifferentiableOn 𝕜 (Neg.neg : 𝕜 → 𝕜) s :=\n  DifferentiableOn.neg differentiableOn_id\n\n"}
{"name":"differentiableAt_comp_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => f (Neg.neg x)) a) (DifferentiableAt 𝕜 f (Neg.neg a))","decl":"lemma differentiableAt_comp_neg {a : 𝕜} :\n    DifferentiableAt 𝕜 (fun x ↦ f (-x)) a ↔ DifferentiableAt 𝕜 f (-a) := by\n  refine ⟨fun H ↦ ?_, fun H ↦ H.comp a differentiable_neg.differentiableAt⟩\n  convert ((neg_neg a).symm ▸ H).comp (-a) differentiable_neg.differentiableAt\n  ext\n  simp only [Function.comp_apply, neg_neg]\n\n"}
{"name":"differentiableAt_iff_comp_neg","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 f a) (DifferentiableAt 𝕜 (fun x => f (Neg.neg x)) (Neg.neg a))","decl":"lemma differentiableAt_iff_comp_neg {a : 𝕜} :\n    DifferentiableAt 𝕜 f a ↔ DifferentiableAt 𝕜 (fun x ↦ f (-x)) (-a) := by\n  simp_rw [← differentiableAt_comp_neg, neg_neg]\n\n"}
{"name":"HasDerivAtFilter.sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nL : Filter 𝕜\nhf : HasDerivAtFilter f f' x L\nhg : HasDerivAtFilter g g' x L\n⊢ HasDerivAtFilter (fun x => HSub.hSub (f x) (g x)) (HSub.hSub f' g') x L","decl":"theorem HasDerivAtFilter.sub (hf : HasDerivAtFilter f f' x L) (hg : HasDerivAtFilter g g' x L) :\n    HasDerivAtFilter (fun x => f x - g x) (f' - g') x L := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"HasDerivWithinAt.sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\ns : Set 𝕜\nhf : HasDerivWithinAt f f' s x\nhg : HasDerivWithinAt g g' s x\n⊢ HasDerivWithinAt (fun x => HSub.hSub (f x) (g x)) (HSub.hSub f' g') s x","decl":"nonrec theorem HasDerivWithinAt.sub (hf : HasDerivWithinAt f f' s x)\n    (hg : HasDerivWithinAt g g' s x) : HasDerivWithinAt (fun x => f x - g x) (f' - g') s x :=\n  hf.sub hg\n\n"}
{"name":"HasDerivAt.sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nhf : HasDerivAt f f' x\nhg : HasDerivAt g g' x\n⊢ HasDerivAt (fun x => HSub.hSub (f x) (g x)) (HSub.hSub f' g') x","decl":"nonrec theorem HasDerivAt.sub (hf : HasDerivAt f f' x) (hg : HasDerivAt g g' x) :\n    HasDerivAt (fun x => f x - g x) (f' - g') x :=\n  hf.sub hg\n\n"}
{"name":"HasStrictDerivAt.sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nf' g' : F\nx : 𝕜\nhf : HasStrictDerivAt f f' x\nhg : HasStrictDerivAt g g' x\n⊢ HasStrictDerivAt (fun x => HSub.hSub (f x) (g x)) (HSub.hSub f' g') x","decl":"theorem HasStrictDerivAt.sub (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\n    HasStrictDerivAt (fun x => f x - g x) (f' - g') x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"derivWithin_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nhf : DifferentiableWithinAt 𝕜 f s x\nhg : DifferentiableWithinAt 𝕜 g s x\n⊢ Eq (derivWithin (fun y => HSub.hSub (f y) (g y)) s x) (HSub.hSub (derivWithin f s x) (derivWithin g s x))","decl":"theorem derivWithin_sub (hf : DifferentiableWithinAt 𝕜 f s x)\n    (hg : DifferentiableWithinAt 𝕜 g s x) :\n    derivWithin (fun y => f y - g y) s x = derivWithin f s x - derivWithin g s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · exact (hf.hasDerivWithinAt.sub hg.hasDerivWithinAt).derivWithin hxs\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf g : 𝕜 → F\nx : 𝕜\nhf : DifferentiableAt 𝕜 f x\nhg : DifferentiableAt 𝕜 g x\n⊢ Eq (deriv (fun y => HSub.hSub (f y) (g y)) x) (HSub.hSub (deriv f x) (deriv g x))","decl":"@[simp]\ntheorem deriv_sub (hf : DifferentiableAt 𝕜 f x) (hg : DifferentiableAt 𝕜 g x) :\n    deriv (fun y => f y - g y) x = deriv f x - deriv g x :=\n  (hf.hasDerivAt.sub hg.hasDerivAt).deriv\n\n"}
{"name":"HasDerivAtFilter.sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nhf : HasDerivAtFilter f f' x L\nc : F\n⊢ HasDerivAtFilter (fun x => HSub.hSub (f x) c) f' x L","decl":"theorem HasDerivAtFilter.sub_const (hf : HasDerivAtFilter f f' x L) (c : F) :\n    HasDerivAtFilter (fun x => f x - c) f' x L := by\n  simpa only [sub_eq_add_neg] using hf.add_const (-c)\n\n"}
{"name":"HasDerivWithinAt.sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nhf : HasDerivWithinAt f f' s x\nc : F\n⊢ HasDerivWithinAt (fun x => HSub.hSub (f x) c) f' s x","decl":"nonrec theorem HasDerivWithinAt.sub_const (hf : HasDerivWithinAt f f' s x) (c : F) :\n    HasDerivWithinAt (fun x => f x - c) f' s x :=\n  hf.sub_const c\n\n"}
{"name":"HasDerivAt.sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nhf : HasDerivAt f f' x\nc : F\n⊢ HasDerivAt (fun x => HSub.hSub (f x) c) f' x","decl":"nonrec theorem HasDerivAt.sub_const (hf : HasDerivAt f f' x) (c : F) :\n    HasDerivAt (fun x => f x - c) f' x :=\n  hf.sub_const c\n\n"}
{"name":"derivWithin_sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nc : F\n⊢ Eq (derivWithin (fun y => HSub.hSub (f y) c) s x) (derivWithin f s x)","decl":"theorem derivWithin_sub_const (c : F) :\n    derivWithin (fun y => f y - c) s x = derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp only [derivWithin, fderivWithin_sub_const hxs]\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nc : F\n⊢ Eq (deriv (fun y => HSub.hSub (f y) c) x) (deriv f x)","decl":"theorem deriv_sub_const (c : F) : deriv (fun y => f y - c) x = deriv f x := by\n  simp only [deriv, fderiv_sub_const]\n\n"}
{"name":"HasDerivAtFilter.const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nL : Filter 𝕜\nc : F\nhf : HasDerivAtFilter f f' x L\n⊢ HasDerivAtFilter (fun x => HSub.hSub c (f x)) (Neg.neg f') x L","decl":"theorem HasDerivAtFilter.const_sub (c : F) (hf : HasDerivAtFilter f f' x L) :\n    HasDerivAtFilter (fun x => c - f x) (-f') x L := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c\n\n"}
{"name":"HasDerivWithinAt.const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\ns : Set 𝕜\nc : F\nhf : HasDerivWithinAt f f' s x\n⊢ HasDerivWithinAt (fun x => HSub.hSub c (f x)) (Neg.neg f') s x","decl":"nonrec theorem HasDerivWithinAt.const_sub (c : F) (hf : HasDerivWithinAt f f' s x) :\n    HasDerivWithinAt (fun x => c - f x) (-f') s x :=\n  hf.const_sub c\n\n"}
{"name":"HasStrictDerivAt.const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nc : F\nhf : HasStrictDerivAt f f' x\n⊢ HasStrictDerivAt (fun x => HSub.hSub c (f x)) (Neg.neg f') x","decl":"theorem HasStrictDerivAt.const_sub (c : F) (hf : HasStrictDerivAt f f' x) :\n    HasStrictDerivAt (fun x => c - f x) (-f') x := by\n  simpa only [sub_eq_add_neg] using hf.neg.const_add c\n\n"}
{"name":"HasDerivAt.const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nf' : F\nx : 𝕜\nc : F\nhf : HasDerivAt f f' x\n⊢ HasDerivAt (fun x => HSub.hSub c (f x)) (Neg.neg f') x","decl":"nonrec theorem HasDerivAt.const_sub (c : F) (hf : HasDerivAt f f' x) :\n    HasDerivAt (fun x => c - f x) (-f') x :=\n  hf.const_sub c\n\n"}
{"name":"derivWithin_const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\ns : Set 𝕜\nc : F\n⊢ Eq (derivWithin (fun y => HSub.hSub c (f y)) s x) (Neg.neg (derivWithin f s x))","decl":"theorem derivWithin_const_sub (c : F) :\n    derivWithin (fun y => c - f y) s x = -derivWithin f s x := by\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs\n  · simp [derivWithin, fderivWithin_const_sub hxs]\n  · simp [derivWithin_zero_of_isolated hxs]\n\n"}
{"name":"deriv_const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\nx : 𝕜\nc : F\n⊢ Eq (deriv (fun y => HSub.hSub c (f y)) x) (Neg.neg (deriv f x))","decl":"theorem deriv_const_sub (c : F) : deriv (fun y => c - f y) x = -deriv f x := by\n  simp only [← derivWithin_univ, derivWithin_const_sub]\n\n"}
{"name":"differentiableAt_comp_sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => f (HSub.hSub x b)) a) (DifferentiableAt 𝕜 f (HSub.hSub a b))","decl":"lemma differentiableAt_comp_sub_const {a b : 𝕜} :\n    DifferentiableAt 𝕜 (fun x ↦ f (x - b)) a ↔ DifferentiableAt 𝕜 f (a - b) := by\n  simp [sub_eq_add_neg, differentiableAt_comp_add_const]\n\n"}
{"name":"differentiableAt_comp_const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 (fun x => f (HSub.hSub b x)) a) (DifferentiableAt 𝕜 f (HSub.hSub b a))","decl":"lemma differentiableAt_comp_const_sub {a b : 𝕜} :\n    DifferentiableAt 𝕜 (fun x ↦ f (b - x)) a ↔ DifferentiableAt 𝕜 f (b - a) := by\n  refine ⟨fun H ↦ ?_, fun H ↦ H.comp a (differentiable_id.const_sub _).differentiableAt⟩\n  convert ((sub_sub_cancel _ a).symm ▸ H).comp (b - a)\n    (differentiable_id.const_sub _).differentiableAt\n  ext\n  simp\n\n"}
{"name":"differentiableAt_iff_comp_sub_const","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 f a) (DifferentiableAt 𝕜 (fun x => f (HSub.hSub x b)) (HAdd.hAdd a b))","decl":"lemma differentiableAt_iff_comp_sub_const {a b : 𝕜} :\n    DifferentiableAt 𝕜 f a ↔ DifferentiableAt 𝕜 (fun x ↦ f (x - b)) (a + b) := by\n  simp [sub_eq_add_neg, differentiableAt_comp_add_const]\n\n"}
{"name":"differentiableAt_iff_comp_const_sub","module":"Mathlib.Analysis.Calculus.Deriv.Add","initialProofState":"𝕜 : Type u\ninst✝² : NontriviallyNormedField 𝕜\nF : Type v\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : 𝕜 → F\na b : 𝕜\n⊢ Iff (DifferentiableAt 𝕜 f a) (DifferentiableAt 𝕜 (fun x => f (HSub.hSub b x)) (HSub.hSub b a))","decl":"lemma differentiableAt_iff_comp_const_sub {a b : 𝕜} :\n    DifferentiableAt 𝕜 f a ↔ DifferentiableAt 𝕜 (fun x ↦ f (b - x)) (b - a) := by\n  simp [differentiableAt_comp_const_sub]\n\n"}
