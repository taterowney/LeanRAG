{"name":"IsGÎ´.setOf_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ IsGÎ´ (setOf fun x => Irrational x)","decl":"protected theorem IsGÎ´.setOf_irrational : IsGÎ´ { x | Irrational x } :=\n  (countable_range _).isGÎ´_compl\n\n\n"}
{"name":"dense_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ Dense (setOf fun x => Irrational x)","decl":"theorem dense_irrational : Dense { x : â„ | Irrational x } := by\n  refine Real.isTopologicalBasis_Ioo_rat.dense_iff.2 ?_\n  simp only [mem_iUnion, mem_singleton_iff, exists_prop, forall_exists_index, and_imp]\n  rintro _ a b hlt rfl _\n  rw [inter_comm]\n  exact exists_irrational_btwn (Rat.cast_lt.2 hlt)\n\n"}
{"name":"eventually_residual_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ Filter.Eventually (fun x => Irrational x) (residual Real)","decl":"theorem eventually_residual_irrational : âˆ€á¶  x in residual â„, Irrational x :=\n  residual_of_dense_GÎ´ .setOf_irrational dense_irrational\n\n"}
{"name":"Irrational.instOrderTopologySubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ OrderTopology (Subtype fun x => Irrational x)","decl":"instance : OrderTopology { x // Irrational x } :=\n  induced_orderTopology _ Iff.rfl <| @fun _ _ hlt =>\n    let âŸ¨z, hz, hxz, hzyâŸ© := exists_irrational_btwn hlt\n    âŸ¨âŸ¨z, hzâŸ©, hxz, hzyâŸ©\n\n"}
{"name":"Irrational.instNoMaxOrderSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ NoMaxOrder (Subtype fun x => Irrational x)","decl":"instance : NoMaxOrder { x // Irrational x } :=\n  âŸ¨fun âŸ¨x, hxâŸ© => âŸ¨âŸ¨x + (1 : â„•), hx.add_nat 1âŸ©, by simpâŸ©âŸ©\n\n"}
{"name":"Irrational.instNoMinOrderSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ NoMinOrder (Subtype fun x => Irrational x)","decl":"instance : NoMinOrder { x // Irrational x } :=\n  âŸ¨fun âŸ¨x, hxâŸ© => âŸ¨âŸ¨x - (1 : â„•), hx.sub_nat 1âŸ©, by simpâŸ©âŸ©\n\n"}
{"name":"Irrational.instDenselyOrderedSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"âŠ¢ DenselyOrdered (Subtype fun x => Irrational x)","decl":"instance : DenselyOrdered { x // Irrational x } :=\n  âŸ¨fun _ _ hlt =>\n    let âŸ¨z, hz, hxz, hzyâŸ© := exists_irrational_btwn hlt\n    âŸ¨âŸ¨z, hzâŸ©, hxz, hzyâŸ©âŸ©\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_div","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\nâŠ¢ Filter.Eventually (fun Îµ => âˆ€ (m : Int), LE.le Îµ (Dist.dist x (HDiv.hDiv â†‘m â†‘n))) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_div (hx : Irrational x) (n : â„•) :\n    âˆ€á¶  Îµ : â„ in ð“ 0, âˆ€ m : â„¤, Îµ â‰¤ dist x (m / n) := by\n  have A : IsClosed (range (fun m => (n : â„)â»Â¹ * m : â„¤ â†’ â„)) :=\n    ((isClosedMap_smulâ‚€ (nâ»Â¹ : â„)).comp Int.isClosedEmbedding_coe_real.isClosedMap).isClosed_range\n  have B : x âˆ‰ range (fun m => (n : â„)â»Â¹ * m : â„¤ â†’ â„) := by\n    rintro âŸ¨m, rflâŸ©\n    simp at hx\n  rcases Metric.mem_nhds_iff.1 (A.isOpen_compl.mem_nhds B) with âŸ¨Îµ, Îµ0, hÎµâŸ©\n  refine (ge_mem_nhds Îµ0).mono fun Î´ hÎ´ m => not_lt.1 fun hlt => ?_\n  rw [dist_comm] at hlt\n  refine hÎµ (ball_subset_ball hÎ´ hlt) âŸ¨m, ?_âŸ©\n  simp [div_eq_inv_mul]\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_div_of_denom_le","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\nâŠ¢ Filter.Eventually (fun Îµ => âˆ€ (k : Nat), LE.le k n â†’ âˆ€ (m : Int), LE.le Îµ (Dist.dist x (HDiv.hDiv â†‘m â†‘k))) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_div_of_denom_le (hx : Irrational x) (n : â„•) :\n    âˆ€á¶  Îµ : â„ in ð“ 0, âˆ€ k â‰¤ n, âˆ€ (m : â„¤), Îµ â‰¤ dist x (m / k) :=\n  (finite_le_nat n).eventually_all.2 fun k _ => hx.eventually_forall_le_dist_cast_div k\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_rat_of_den_le","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\nâŠ¢ Filter.Eventually (fun Îµ => âˆ€ (r : Rat), LE.le r.den n â†’ LE.le Îµ (Dist.dist x â†‘r)) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_rat_of_den_le (hx : Irrational x) (n : â„•) :\n    âˆ€á¶  Îµ : â„ in ð“ 0, âˆ€ r : â„š, r.den â‰¤ n â†’ Îµ â‰¤ dist x r :=\n  (hx.eventually_forall_le_dist_cast_div_of_denom_le n).mono fun Îµ H r hr => by\n    simpa only [Rat.cast_def] using H r.den hr r.num\n\n"}
