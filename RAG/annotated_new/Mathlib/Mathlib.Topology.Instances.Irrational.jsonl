{"name":"IsGδ.setOf_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ IsGδ (setOf fun x => Irrational x)","decl":"protected theorem IsGδ.setOf_irrational : IsGδ { x | Irrational x } :=\n  (countable_range _).isGδ_compl\n\n\n"}
{"name":"dense_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ Dense (setOf fun x => Irrational x)","decl":"theorem dense_irrational : Dense { x : ℝ | Irrational x } := by\n  refine Real.isTopologicalBasis_Ioo_rat.dense_iff.2 ?_\n  simp only [mem_iUnion, mem_singleton_iff, exists_prop, forall_exists_index, and_imp]\n  rintro _ a b hlt rfl _\n  rw [inter_comm]\n  exact exists_irrational_btwn (Rat.cast_lt.2 hlt)\n\n"}
{"name":"eventually_residual_irrational","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ Filter.Eventually (fun x => Irrational x) (residual Real)","decl":"theorem eventually_residual_irrational : ∀ᶠ x in residual ℝ, Irrational x :=\n  residual_of_dense_Gδ .setOf_irrational dense_irrational\n\n"}
{"name":"Irrational.instOrderTopologySubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ OrderTopology (Subtype fun x => Irrational x)","decl":"instance : OrderTopology { x // Irrational x } :=\n  induced_orderTopology _ Iff.rfl <| @fun _ _ hlt =>\n    let ⟨z, hz, hxz, hzy⟩ := exists_irrational_btwn hlt\n    ⟨⟨z, hz⟩, hxz, hzy⟩\n\n"}
{"name":"Irrational.instNoMaxOrderSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ NoMaxOrder (Subtype fun x => Irrational x)","decl":"instance : NoMaxOrder { x // Irrational x } :=\n  ⟨fun ⟨x, hx⟩ => ⟨⟨x + (1 : ℕ), hx.add_nat 1⟩, by simp⟩⟩\n\n"}
{"name":"Irrational.instNoMinOrderSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ NoMinOrder (Subtype fun x => Irrational x)","decl":"instance : NoMinOrder { x // Irrational x } :=\n  ⟨fun ⟨x, hx⟩ => ⟨⟨x - (1 : ℕ), hx.sub_nat 1⟩, by simp⟩⟩\n\n"}
{"name":"Irrational.instDenselyOrderedSubtypeReal","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"⊢ DenselyOrdered (Subtype fun x => Irrational x)","decl":"instance : DenselyOrdered { x // Irrational x } :=\n  ⟨fun _ _ hlt =>\n    let ⟨z, hz, hxz, hzy⟩ := exists_irrational_btwn hlt\n    ⟨⟨z, hz⟩, hxz, hzy⟩⟩\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_div","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\n⊢ Filter.Eventually (fun ε => ∀ (m : Int), LE.le ε (Dist.dist x (HDiv.hDiv ↑m ↑n))) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_div (hx : Irrational x) (n : ℕ) :\n    ∀ᶠ ε : ℝ in 𝓝 0, ∀ m : ℤ, ε ≤ dist x (m / n) := by\n  have A : IsClosed (range (fun m => (n : ℝ)⁻¹ * m : ℤ → ℝ)) :=\n    ((isClosedMap_smul₀ (n⁻¹ : ℝ)).comp Int.isClosedEmbedding_coe_real.isClosedMap).isClosed_range\n  have B : x ∉ range (fun m => (n : ℝ)⁻¹ * m : ℤ → ℝ) := by\n    rintro ⟨m, rfl⟩\n    simp at hx\n  rcases Metric.mem_nhds_iff.1 (A.isOpen_compl.mem_nhds B) with ⟨ε, ε0, hε⟩\n  refine (ge_mem_nhds ε0).mono fun δ hδ m => not_lt.1 fun hlt => ?_\n  rw [dist_comm] at hlt\n  refine hε (ball_subset_ball hδ hlt) ⟨m, ?_⟩\n  simp [div_eq_inv_mul]\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_div_of_denom_le","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\n⊢ Filter.Eventually (fun ε => ∀ (k : Nat), LE.le k n → ∀ (m : Int), LE.le ε (Dist.dist x (HDiv.hDiv ↑m ↑k))) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_div_of_denom_le (hx : Irrational x) (n : ℕ) :\n    ∀ᶠ ε : ℝ in 𝓝 0, ∀ k ≤ n, ∀ (m : ℤ), ε ≤ dist x (m / k) :=\n  (finite_le_nat n).eventually_all.2 fun k _ => hx.eventually_forall_le_dist_cast_div k\n\n"}
{"name":"Irrational.eventually_forall_le_dist_cast_rat_of_den_le","module":"Mathlib.Topology.Instances.Irrational","initialProofState":"x : Real\nhx : Irrational x\nn : Nat\n⊢ Filter.Eventually (fun ε => ∀ (r : Rat), LE.le r.den n → LE.le ε (Dist.dist x ↑r)) (nhds 0)","decl":"theorem eventually_forall_le_dist_cast_rat_of_den_le (hx : Irrational x) (n : ℕ) :\n    ∀ᶠ ε : ℝ in 𝓝 0, ∀ r : ℚ, r.den ≤ n → ε ≤ dist x r :=\n  (hx.eventually_forall_le_dist_cast_div_of_denom_le n).mono fun ε H r hr => by\n    simpa only [Rat.cast_def] using H r.den hr r.num\n\n"}
