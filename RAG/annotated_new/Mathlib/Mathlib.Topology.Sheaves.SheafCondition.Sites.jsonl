{"name":"TopCat.Presheaf.coveringOfPresieve_apply","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\nR : CategoryTheory.Presieve U\nf : Sigma fun V => Subtype fun f => R f\n‚ä¢ Eq (TopCat.Presheaf.coveringOfPresieve U R f) f.fst","decl":"@[simp]\ntheorem coveringOfPresieve_apply (U : Opens X) (R : Presieve U) (f : Œ£V, { f : V ‚ü∂ U // R f }) :\n    coveringOfPresieve U R f = f.1 := rfl\n\n"}
{"name":"TopCat.Presheaf.coveringOfPresieve.iSup_eq_of_mem_grothendieck","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\nR : CategoryTheory.Presieve U\nhR : Membership.mem ((Opens.grothendieckTopology ‚ÜëX) U) (CategoryTheory.Sieve.generate R)\n‚ä¢ Eq (iSup (TopCat.Presheaf.coveringOfPresieve U R)) U","decl":"/-- If `R` is a presieve in the grothendieck topology on `Opens X`, the covering family associated\nto `R` really is _covering_, i.e. the union of all open sets equals `U`.\n-/\ntheorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R ‚àà Opens.grothendieckTopology X U) :\n    iSup (coveringOfPresieve U R) = U := by\n  apply le_antisymm\n  ¬∑ refine iSup_le ?_\n    intro f\n    exact f.2.1.le\n  intro x hxU\n  rw [Opens.coe_iSup, Set.mem_iUnion]\n  obtain ‚ü®V, iVU, ‚ü®W, iVW, iWU, hiWU, -‚ü©, hxV‚ü© := hR x hxU\n  exact ‚ü®‚ü®W, ‚ü®iWU, hiWU‚ü©‚ü©, iVW.le hxV‚ü©\n\n"}
{"name":"TopCat.Presheaf.covering_presieve_eq_self","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nY : TopologicalSpace.Opens ‚ÜëX\nR : CategoryTheory.Presieve Y\n‚ä¢ Eq (TopCat.Presheaf.presieveOfCoveringAux (TopCat.Presheaf.coveringOfPresieve Y R) Y) R","decl":"/-- Given a presieve `R` on `Y`, if we take its associated family of opens via\n    `coveringOfPresieve` (which may not cover `Y` if `R` is not covering), and take\n    the presieve on `Y` associated to the family of opens via `presieveOfCoveringAux`,\n    then we get back the original presieve `R`. -/\n@[simp]\ntheorem covering_presieve_eq_self {Y : Opens X} (R : Presieve Y) :\n    presieveOfCoveringAux (coveringOfPresieve Y R) Y = R := by\n  funext Z\n  ext f\n  exact ‚ü®fun ‚ü®‚ü®_, f', h‚ü©, rfl‚ü© => by rwa [Subsingleton.elim f f'], fun h => ‚ü®‚ü®Z, f, h‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"TopCat.Presheaf.presieveOfCovering.mem_grothendieckTopology","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nŒπ : Type v\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Membership.mem ((Opens.grothendieckTopology ‚ÜëX) (iSup U)) (CategoryTheory.Sieve.generate (TopCat.Presheaf.presieveOfCovering U))","decl":"/-- The sieve generated by `presieveOfCovering U` is a member of the grothendieck topology.\n-/\ntheorem mem_grothendieckTopology :\n    Sieve.generate (presieveOfCovering U) ‚àà Opens.grothendieckTopology X (iSup U) := by\n  intro x hx\n  obtain ‚ü®i, hxi‚ü© := Opens.mem_iSup.mp hx\n  exact ‚ü®U i, Opens.leSupr U i, ‚ü®U i, ùüô _, Opens.leSupr U i, ‚ü®i, rfl‚ü©, Category.id_comp _‚ü©, hxi‚ü©\n\n"}
{"name":"TopCat.Presheaf.presieveOfCovering.indexOfHom_spec","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nŒπ : Type v\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nf : Sigma fun V => Subtype fun f => TopCat.Presheaf.presieveOfCovering U f\n‚ä¢ Eq f.fst (U (TopCat.Presheaf.presieveOfCovering.indexOfHom U f))","decl":"theorem indexOfHom_spec (f : Œ£V, { f : V ‚ü∂ iSup U // presieveOfCovering U f }) :\n    f.1 = U (indexOfHom U f) :=\n  f.2.2.choose_spec\n\n"}
{"name":"TopCat.Opens.coverDense_iff_isBasis","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nŒπ : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} Œπ\nB : CategoryTheory.Functor Œπ (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Iff (B.IsCoverDense (Opens.grothendieckTopology ‚ÜëX)) (TopologicalSpace.Opens.IsBasis (Set.range B.obj))","decl":"theorem coverDense_iff_isBasis [Category Œπ] (B : Œπ ‚•§ Opens X) :\n    B.IsCoverDense (Opens.grothendieckTopology X) ‚Üî Opens.IsBasis (Set.range B.obj) := by\n  rw [Opens.isBasis_iff_nbhd]\n  constructor\n  ¬∑ intro hd U x hx; rcases hd.1 U x hx with ‚ü®V, f, ‚ü®i, f‚ÇÅ, f‚ÇÇ, _‚ü©, hV‚ü©\n    exact ‚ü®B.obj i, ‚ü®i, rfl‚ü©, f‚ÇÅ.le hV, f‚ÇÇ.le‚ü©\n  intro hb; constructor; intro U x hx; rcases hb hx with ‚ü®_, ‚ü®i, rfl‚ü©, hx, hi‚ü©\n  exact ‚ü®B.obj i, ‚ü®‚ü®hi‚ü©‚ü©, ‚ü®‚ü®i, ùüô _, ‚ü®‚ü®hi‚ü©‚ü©, rfl‚ü©‚ü©, hx‚ü©\n\n"}
{"name":"TopCat.Opens.coverDense_inducedFunctor","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X : TopCat\nŒπ : Type u_1\nB : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nh : TopologicalSpace.Opens.IsBasis (Set.range B)\n‚ä¢ (CategoryTheory.inducedFunctor B).IsCoverDense (Opens.grothendieckTopology ‚ÜëX)","decl":"theorem coverDense_inducedFunctor {B : Œπ ‚Üí Opens X} (h : Opens.IsBasis (Set.range B)) :\n    (inducedFunctor B).IsCoverDense (Opens.grothendieckTopology X)  :=\n  (coverDense_iff_isBasis _).2 h\n\n"}
{"name":"Topology.IsOpenEmbedding.compatiblePreserving","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ CategoryTheory.CompatiblePreserving (Opens.grothendieckTopology ‚ÜëY) ‚ãØ.functor","decl":"theorem Topology.IsOpenEmbedding.compatiblePreserving (hf : IsOpenEmbedding f) :\n    CompatiblePreserving (Opens.grothendieckTopology Y) hf.isOpenMap.functor := by\n  haveI : Mono f := (TopCat.mono_iff_injective f).mpr hf.injective\n  apply compatiblePreservingOfDownwardsClosed\n  intro U V i\n  refine ‚ü®(Opens.map f).obj V, eqToIso <| Opens.ext <| Set.image_preimage_eq_of_subset fun x h ‚Ü¶ ?_‚ü©\n  obtain ‚ü®_, _, rfl‚ü© := i.le h\n  exact ‚ü®_, rfl‚ü©\n\n"}
{"name":"OpenEmbedding.compatiblePreserving","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ CategoryTheory.CompatiblePreserving (Opens.grothendieckTopology ‚ÜëY) ‚ãØ.functor","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.compatiblePreserving := IsOpenEmbedding.compatiblePreserving\n\n"}
{"name":"IsOpenMap.coverPreserving","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap ‚áëf\n‚ä¢ CategoryTheory.CoverPreserving (Opens.grothendieckTopology ‚ÜëX) (Opens.grothendieckTopology ‚ÜëY) hf.functor","decl":"theorem IsOpenMap.coverPreserving (hf : IsOpenMap f) :\n    CoverPreserving (Opens.grothendieckTopology X) (Opens.grothendieckTopology Y) hf.functor := by\n  constructor\n  rintro U S hU _ ‚ü®x, hx, rfl‚ü©\n  obtain ‚ü®V, i, hV, hxV‚ü© := hU x hx\n  exact ‚ü®_, hf.functor.map i, ‚ü®_, i, ùüô _, hV, rfl‚ü©, Set.mem_image_of_mem f hxV‚ü©\n\n\n"}
{"name":"Topology.IsOpenEmbedding.functor_isContinuous","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nh : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ ‚ãØ.functor.IsContinuous (Opens.grothendieckTopology ‚ÜëX) (Opens.grothendieckTopology ‚ÜëY)","decl":"lemma Topology.IsOpenEmbedding.functor_isContinuous (h : IsOpenEmbedding f) :\n    h.isOpenMap.functor.IsContinuous (Opens.grothendieckTopology X)\n      (Opens.grothendieckTopology Y) := by\n  apply Functor.isContinuous_of_coverPreserving\n  ¬∑ exact h.compatiblePreserving\n  ¬∑ exact h.isOpenMap.coverPreserving\n\n"}
{"name":"OpenEmbedding.functor_isContinuous","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nh : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ ‚ãØ.functor.IsContinuous (Opens.grothendieckTopology ‚ÜëX) (Opens.grothendieckTopology ‚ÜëY)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.functor_isContinuous := IsOpenEmbedding.functor_isContinuous\n\n"}
{"name":"TopCat.Presheaf.isSheaf_of_isOpenEmbedding","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nh : Topology.IsOpenEmbedding ‚áëf\nhF : F.IsSheaf\n‚ä¢ TopCat.Presheaf.IsSheaf (‚ãØ.functor.op.comp F)","decl":"theorem TopCat.Presheaf.isSheaf_of_isOpenEmbedding (h : IsOpenEmbedding f) (hF : F.IsSheaf) :\n    IsSheaf (h.isOpenMap.functor.op ‚ãô F) := by\n  have := h.functor_isContinuous\n  exact Functor.op_comp_isSheaf _ _ _ ‚ü®_, hF‚ü©\n\n"}
{"name":"TopCat.Presheaf.isSheaf_of_openEmbedding","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nh : Topology.IsOpenEmbedding ‚áëf\nhF : F.IsSheaf\n‚ä¢ TopCat.Presheaf.IsSheaf (‚ãØ.functor.op.comp F)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias TopCat.Presheaf.isSheaf_of_openEmbedding := TopCat.Presheaf.isSheaf_of_isOpenEmbedding\n\n"}
{"name":"instRepresentablyFlatOpensŒ±TopologicalSpaceMap","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.RepresentablyFlat (TopologicalSpace.Opens.map f)","decl":"instance : RepresentablyFlat (Opens.map f) := by\n  constructor\n  intro U\n  refine @IsCofiltered.mk _ _ ?_ ?_\n  ¬∑ constructor\n    ¬∑ intro V W\n      exact ‚ü®‚ü®‚ü®PUnit.unit‚ü©, V.right ‚äì W.right, homOfLE <| le_inf V.hom.le W.hom.le‚ü©,\n        StructuredArrow.homMk (homOfLE inf_le_left),\n        StructuredArrow.homMk (homOfLE inf_le_right), trivial‚ü©\n    ¬∑ exact fun _ _ _ _ ‚Ü¶ ‚ü®_, ùüô _, by simp [eq_iff_true_of_subsingleton]‚ü©\n  ¬∑ exact ‚ü®StructuredArrow.mk <| show U ‚ü∂ (Opens.map f).obj ‚ä§ from homOfLE le_top‚ü©\n\n"}
{"name":"compatiblePreserving_opens_map","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.CompatiblePreserving (Opens.grothendieckTopology ‚ÜëX) (TopologicalSpace.Opens.map f)","decl":"theorem compatiblePreserving_opens_map :\n    CompatiblePreserving (Opens.grothendieckTopology X) (Opens.map f) :=\n  compatiblePreservingOfFlat _ _\n\n"}
{"name":"coverPreserving_opens_map","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.CoverPreserving (Opens.grothendieckTopology ‚ÜëY) (Opens.grothendieckTopology ‚ÜëX) (TopologicalSpace.Opens.map f)","decl":"theorem coverPreserving_opens_map : CoverPreserving (Opens.grothendieckTopology Y)\n    (Opens.grothendieckTopology X) (Opens.map f) := by\n  constructor\n  intro U S hS x hx\n  obtain ‚ü®V, i, hi, hxV‚ü© := hS (f x) hx\n  exact ‚ü®_, (Opens.map f).map i, ‚ü®_, _, ùüô _, hi, Subsingleton.elim _ _‚ü©, hxV‚ü©\n\n"}
{"name":"instIsContinuousOpensŒ±TopologicalSpaceMapGrothendieckTopology","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\n‚ä¢ (TopologicalSpace.Opens.map f).IsContinuous (Opens.grothendieckTopology ‚ÜëY) (Opens.grothendieckTopology ‚ÜëX)","decl":"instance : (Opens.map f).IsContinuous (Opens.grothendieckTopology Y)\n    (Opens.grothendieckTopology X) := by\n  apply Functor.isContinuous_of_coverPreserving\n  ¬∑ exact compatiblePreserving_opens_map f\n  ¬∑ exact coverPreserving_opens_map f\n\n"}
{"name":"TopCat.Sheaf.extend_hom_app","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nŒπ : Type u_1\nB : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nF : TopCat.Presheaf C X\nF' : TopCat.Sheaf C X\nh : TopologicalSpace.Opens.IsBasis (Set.range B)\nŒ± : Quiver.Hom ((CategoryTheory.inducedFunctor B).op.comp F) ((CategoryTheory.inducedFunctor B).op.comp F'.val)\ni : Œπ\n‚ä¢ Eq (((TopCat.Sheaf.restrictHomEquivHom F F' h) Œ±).app { unop := B i }) (Œ±.app { unop := i })","decl":"@[simp]\ntheorem extend_hom_app (h : Opens.IsBasis (Set.range B))\n    (Œ± : (inducedFunctor B).op ‚ãô F ‚ü∂ (inducedFunctor B).op ‚ãô F'.1) (i : Œπ) :\n    (restrictHomEquivHom F F' h Œ±).app (op (B i)) = Œ±.app (op i) := by\n  nth_rw 2 [‚Üê (restrictHomEquivHom F F' h).left_inv Œ±]\n  rfl\n\n"}
{"name":"TopCat.Sheaf.hom_ext","module":"Mathlib.Topology.Sheaves.SheafCondition.Sites","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : TopCat\nŒπ : Type u_1\nB : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nF : TopCat.Presheaf C X\nF' : TopCat.Sheaf C X\nh : TopologicalSpace.Opens.IsBasis (Set.range B)\nŒ± Œ≤ : Quiver.Hom F F'.val\nhe : ‚àÄ (i : Œπ), Eq (Œ±.app { unop := B i }) (Œ≤.app { unop := B i })\n‚ä¢ Eq Œ± Œ≤","decl":"theorem hom_ext (h : Opens.IsBasis (Set.range B))\n    {Œ± Œ≤ : F ‚ü∂ F'.1} (he : ‚àÄ i, Œ±.app (op (B i)) = Œ≤.app (op (B i))) : Œ± = Œ≤ := by\n  apply (restrictHomEquivHom F F' h).symm.injective\n  ext i\n  exact he i.unop\n\n"}
