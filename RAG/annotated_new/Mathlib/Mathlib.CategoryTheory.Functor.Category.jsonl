{"name":"CategoryTheory.NatTrans.ext'_iff","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G : CategoryTheory.Functor C D\nÎ± Î² : Quiver.Hom F G\nâŠ¢ Iff (Eq Î± Î²) (Eq Î±.app Î².app)","decl":"@[ext]\ntheorem ext' {Î± Î² : F âŸ¶ G} (w : Î±.app = Î².app) : Î± = Î² := NatTrans.ext w\n\n"}
{"name":"CategoryTheory.NatTrans.ext'","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G : CategoryTheory.Functor C D\nÎ± Î² : Quiver.Hom F G\nw : Eq Î±.app Î².app\nâŠ¢ Eq Î± Î²","decl":"@[ext]\ntheorem ext' {Î± Î² : F âŸ¶ G} (w : Î±.app = Î².app) : Î± = Î² := NatTrans.ext w\n\n"}
{"name":"CategoryTheory.NatTrans.vcomp_eq_comp","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G H : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom G H\nâŠ¢ Eq (CategoryTheory.NatTrans.vcomp Î± Î²) (CategoryTheory.CategoryStruct.comp Î± Î²)","decl":"@[simp]\ntheorem vcomp_eq_comp (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) : vcomp Î± Î² = Î± â‰« Î² := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.vcomp_app'","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G H : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom G H\nX : C\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp Î± Î²).app X) (CategoryTheory.CategoryStruct.comp (Î±.app X) (Î².app X))","decl":"theorem vcomp_app' (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) (X : C) : (Î± â‰« Î²).app X = Î±.app X â‰« Î².app X := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.congr_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G : CategoryTheory.Functor C D\nÎ± Î² : Quiver.Hom F G\nh : Eq Î± Î²\nX : C\nâŠ¢ Eq (Î±.app X) (Î².app X)","decl":"theorem congr_app {Î± Î² : F âŸ¶ G} (h : Î± = Î²) (X : C) : Î±.app X = Î².app X := by rw [h]\n\n"}
{"name":"CategoryTheory.NatTrans.id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nX : C\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp]\ntheorem id_app (F : C â¥¤ D) (X : C) : (ğŸ™ F : F âŸ¶ F).app X = ğŸ™ (F.obj X) := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.comp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G H : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom G H\nX : C\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp Î± Î²).app X) (CategoryTheory.CategoryStruct.comp (Î±.app X) (Î².app X))","decl":"@[simp]\ntheorem comp_app {F G H : C â¥¤ D} (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) (X : C) :\n    (Î± â‰« Î²).app X = Î±.app X â‰« Î².app X := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.comp_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G H : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom G H\nX : C\nZ : D\nh : Quiver.Hom (H.obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp Î± Î²).app X) h) (CategoryTheory.CategoryStruct.comp (Î±.app X) (CategoryTheory.CategoryStruct.comp (Î².app X) h))","decl":"attribute [reassoc] comp_app\n\n"}
{"name":"CategoryTheory.NatTrans.app_naturality_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nX : C\nY Zâœ : D\nf : Quiver.Hom Y Zâœ\nZ : E\nh : Quiver.Hom ((G.obj X).obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj X).map f) (CategoryTheory.CategoryStruct.comp ((T.app X).app Zâœ) h)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Y) (CategoryTheory.CategoryStruct.comp ((G.obj X).map f) h))","decl":"@[reassoc]\ntheorem app_naturality {F G : C â¥¤ D â¥¤ E} (T : F âŸ¶ G) (X : C) {Y Z : D} (f : Y âŸ¶ Z) :\n    (F.obj X).map f â‰« (T.app X).app Z = (T.app X).app Y â‰« (G.obj X).map f :=\n  (T.app X).naturality f\n\n"}
{"name":"CategoryTheory.NatTrans.app_naturality","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nX : C\nY Z : D\nf : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj X).map f) ((T.app X).app Z)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Y) ((G.obj X).map f))","decl":"@[reassoc]\ntheorem app_naturality {F G : C â¥¤ D â¥¤ E} (T : F âŸ¶ G) (X : C) {Y Z : D} (f : Y âŸ¶ Z) :\n    (F.obj X).map f â‰« (T.app X).app Z = (T.app X).app Y â‰« (G.obj X).map f :=\n  (T.app X).naturality f\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nZâœ : D\nX Y : C\nf : Quiver.Hom X Y\nZ : E\nh : Quiver.Hom ((G.obj Y).obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map f).app Zâœ) (CategoryTheory.CategoryStruct.comp ((T.app Y).app Zâœ) h)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Zâœ) (CategoryTheory.CategoryStruct.comp ((G.map f).app Zâœ) h))","decl":"@[reassoc]\ntheorem naturality_app {F G : C â¥¤ D â¥¤ E} (T : F âŸ¶ G) (Z : D) {X Y : C} (f : X âŸ¶ Y) :\n    (F.map f).app Z â‰« (T.app Y).app Z = (T.app X).app Z â‰« (G.map f).app Z :=\n  congr_fun (congr_arg app (T.naturality f)) Z\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nZ : D\nX Y : C\nf : Quiver.Hom X Y\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map f).app Z) ((T.app Y).app Z)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Z) ((G.map f).app Z))","decl":"@[reassoc]\ntheorem naturality_app {F G : C â¥¤ D â¥¤ E} (T : F âŸ¶ G) (Z : D) {X Y : C} (f : X âŸ¶ Y) :\n    (F.map f).app Z â‰« (T.app Y).app Z = (T.app X).app Z â‰« (G.map f).app Z :=\n  congr_fun (congr_arg app (T.naturality f)) Z\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nE' : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\nÎ± : Quiver.Hom F G\nXâ‚ Yâ‚ : C\nf : Quiver.Hom Xâ‚ Yâ‚\nXâ‚‚ : D\nXâ‚ƒ : E\nZ : E'\nh : Quiver.Hom (((G.obj Yâ‚).obj Xâ‚‚).obj Xâ‚ƒ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((F.map f).app Xâ‚‚).app Xâ‚ƒ) (CategoryTheory.CategoryStruct.comp (((Î±.app Yâ‚).app Xâ‚‚).app Xâ‚ƒ) h)) (CategoryTheory.CategoryStruct.comp (((Î±.app Xâ‚).app Xâ‚‚).app Xâ‚ƒ) (CategoryTheory.CategoryStruct.comp (((G.map f).app Xâ‚‚).app Xâ‚ƒ) h))","decl":"@[reassoc]\ntheorem naturality_app_app {F G : C â¥¤ D â¥¤ E â¥¤ E'}\n    (Î± : F âŸ¶ G) {Xâ‚ Yâ‚ : C} (f : Xâ‚ âŸ¶ Yâ‚) (Xâ‚‚ : D) (Xâ‚ƒ : E) :\n    ((F.map f).app Xâ‚‚).app Xâ‚ƒ â‰« ((Î±.app Yâ‚).app Xâ‚‚).app Xâ‚ƒ =\n      ((Î±.app Xâ‚).app Xâ‚‚).app Xâ‚ƒ â‰« ((G.map f).app Xâ‚‚).app Xâ‚ƒ :=\n  congr_app (NatTrans.naturality_app Î± Xâ‚‚ f) Xâ‚ƒ\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nE' : Type uâ‚„\ninstâœ : CategoryTheory.Category.{vâ‚„, uâ‚„} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\nÎ± : Quiver.Hom F G\nXâ‚ Yâ‚ : C\nf : Quiver.Hom Xâ‚ Yâ‚\nXâ‚‚ : D\nXâ‚ƒ : E\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (((F.map f).app Xâ‚‚).app Xâ‚ƒ) (((Î±.app Yâ‚).app Xâ‚‚).app Xâ‚ƒ)) (CategoryTheory.CategoryStruct.comp (((Î±.app Xâ‚).app Xâ‚‚).app Xâ‚ƒ) (((G.map f).app Xâ‚‚).app Xâ‚ƒ))","decl":"@[reassoc]\ntheorem naturality_app_app {F G : C â¥¤ D â¥¤ E â¥¤ E'}\n    (Î± : F âŸ¶ G) {Xâ‚ Yâ‚ : C} (f : Xâ‚ âŸ¶ Yâ‚) (Xâ‚‚ : D) (Xâ‚ƒ : E) :\n    ((F.map f).app Xâ‚‚).app Xâ‚ƒ â‰« ((Î±.app Yâ‚).app Xâ‚‚).app Xâ‚ƒ =\n      ((Î±.app Xâ‚).app Xâ‚‚).app Xâ‚ƒ â‰« ((G.map f).app Xâ‚‚).app Xâ‚ƒ :=\n  congr_app (NatTrans.naturality_app Î± Xâ‚‚ f) Xâ‚ƒ\n\n"}
{"name":"CategoryTheory.NatTrans.mono_of_mono_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\ninstâœ : âˆ€ (X : C), CategoryTheory.Mono (Î±.app X)\nâŠ¢ CategoryTheory.Mono Î±","decl":"/-- A natural transformation is a monomorphism if each component is. -/\ntheorem mono_of_mono_app (Î± : F âŸ¶ G) [âˆ€ X : C, Mono (Î±.app X)] : Mono Î± :=\n  âŸ¨fun g h eq => by\n    ext X\n    rw [â† cancel_mono (Î±.app X), â† comp_app, eq, comp_app]âŸ©\n\n"}
{"name":"CategoryTheory.NatTrans.epi_of_epi_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF G : CategoryTheory.Functor C D\nÎ± : Quiver.Hom F G\ninstâœ : âˆ€ (X : C), CategoryTheory.Epi (Î±.app X)\nâŠ¢ CategoryTheory.Epi Î±","decl":"/-- A natural transformation is an epimorphism if each component is. -/\ntheorem epi_of_epi_app (Î± : F âŸ¶ G) [âˆ€ X : C, Epi (Î±.app X)] : Epi Î± :=\n  âŸ¨fun g h eq => by\n    ext X\n    rw [â† cancel_epi (Î±.app X), â† comp_app, eq, comp_app]âŸ©\n\n"}
{"name":"CategoryTheory.NatTrans.id_comm","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nÎ± Î² : Quiver.Hom (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Î± Î²) (CategoryTheory.CategoryStruct.comp Î² Î±)","decl":"/-- The monoid of natural transformations of the identity is commutative.-/\nlemma id_comm (Î± Î² : (ğŸ­ C) âŸ¶ (ğŸ­ C)) : Î± â‰« Î² = Î² â‰« Î± := by\n  ext X\n  exact (Î±.naturality (Î².app X)).symm\n\n"}
{"name":"CategoryTheory.NatTrans.hcomp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C D\nH I : CategoryTheory.Functor D E\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom H I\nX : C\nâŠ¢ Eq ((CategoryTheory.NatTrans.hcomp Î± Î²).app X) (CategoryTheory.CategoryStruct.comp (Î².app (F.obj X)) (I.map (Î±.app X)))","decl":"/-- `hcomp Î± Î²` is the horizontal composition of natural transformations. -/\n@[simps]\ndef hcomp {H I : D â¥¤ E} (Î± : F âŸ¶ G) (Î² : H âŸ¶ I) : F â‹™ H âŸ¶ G â‹™ I where\n  app := fun X : C => Î².app (F.obj X) â‰« I.map (Î±.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, â† assoc, naturality, assoc, â† map_comp I, naturality,\n      map_comp, assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.hcomp_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor D E\nÎ± : Quiver.Hom F G\nX : C\nâŠ¢ Eq ((CategoryTheory.NatTrans.hcomp Î± (CategoryTheory.CategoryStruct.id H)).app X) (H.map (Î±.app X))","decl":"theorem hcomp_id_app {H : D â¥¤ E} (Î± : F âŸ¶ G) (X : C) : (Î± â—« ğŸ™ H).app X = H.map (Î±.app X) := by\n  simp\n\n"}
{"name":"CategoryTheory.NatTrans.id_hcomp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor E C\nÎ± : Quiver.Hom F G\nX : E\nâŠ¢ Eq ((CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id H) Î±).app X) (Î±.app (H.obj X))","decl":"theorem id_hcomp_app {H : E â¥¤ C} (Î± : F âŸ¶ G) (X : E) : (ğŸ™ H â—« Î±).app X = Î±.app _ := by simp\n\n-- Note that we don't yet prove a `hcomp_assoc` lemma here: even stating it is painful, because we\n-- need to use associativity of functor composition. (It's true without the explicit associator,\n-- because functor composition is definitionally associative,\n-- but relying on the definitional equality causes bad problems with elaboration later.)\n"}
{"name":"CategoryTheory.NatTrans.exchange","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF G H : CategoryTheory.Functor C D\nI J K : CategoryTheory.Functor D E\nÎ± : Quiver.Hom F G\nÎ² : Quiver.Hom G H\nÎ³ : Quiver.Hom I J\nÎ´ : Quiver.Hom J K\nâŠ¢ Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.comp Î± Î²) (CategoryTheory.CategoryStruct.comp Î³ Î´)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.hcomp Î± Î³) (CategoryTheory.NatTrans.hcomp Î² Î´))","decl":"theorem exchange {I J K : D â¥¤ E} (Î± : F âŸ¶ G) (Î² : G âŸ¶ H) (Î³ : I âŸ¶ J) (Î´ : J âŸ¶ K) :\n    (Î± â‰« Î²) â—« (Î³ â‰« Î´) = (Î± â—« Î³) â‰« Î² â—« Î´ := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.flip_map_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nXâœ Yâœ : D\nf : Quiver.Hom Xâœ Yâœ\nj : C\nâŠ¢ Eq ((F.flip.map f).app j) ((F.obj j).map f)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C â¥¤ D â¥¤ E) : D â¥¤ C â¥¤ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.Functor.flip_obj_obj","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nk : D\nj : C\nâŠ¢ Eq ((F.flip.obj k).obj j) ((F.obj j).obj k)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C â¥¤ D â¥¤ E) : D â¥¤ C â¥¤ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.Functor.flip_obj_map","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nk : D\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((F.flip.obj k).map f) ((F.map f).app k)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C â¥¤ D â¥¤ E) : D â¥¤ C â¥¤ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.flipFunctor_obj","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nâŠ¢ Eq ((CategoryTheory.flipFunctor C D E).obj F) F.flip","decl":"variable (C D E) in\n/-- The functor `(C â¥¤ D â¥¤ E) â¥¤ D â¥¤ C â¥¤ E` which flips the variables. -/\n@[simps]\ndef flipFunctor : (C â¥¤ D â¥¤ E) â¥¤ D â¥¤ C â¥¤ E where\n  obj F := F.flip\n  map {Fâ‚ Fâ‚‚} Ï† :=\n    { app := fun Y =>\n        { app := fun X => (Ï†.app X).app Y\n          naturality := fun Xâ‚ Xâ‚‚ f => by\n            dsimp\n            simp only [â† NatTrans.comp_app, naturality] } }\n\n"}
{"name":"CategoryTheory.flipFunctor_map_app_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nFâ‚ Fâ‚‚ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nÏ† : Quiver.Hom Fâ‚ Fâ‚‚\nY : D\nX : C\nâŠ¢ Eq ((((CategoryTheory.flipFunctor C D E).map Ï†).app Y).app X) ((Ï†.app X).app Y)","decl":"variable (C D E) in\n/-- The functor `(C â¥¤ D â¥¤ E) â¥¤ D â¥¤ C â¥¤ E` which flips the variables. -/\n@[simps]\ndef flipFunctor : (C â¥¤ D â¥¤ E) â¥¤ D â¥¤ C â¥¤ E where\n  obj F := F.flip\n  map {Fâ‚ Fâ‚‚} Ï† :=\n    { app := fun Y =>\n        { app := fun X => (Ï†.app X).app Y\n          naturality := fun Xâ‚ Xâ‚‚ f => by\n            dsimp\n            simp only [â† NatTrans.comp_app, naturality] } }\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZâœ : D\nZ : E\nh : Quiver.Hom ((F.obj X).obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Zâœ) (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Zâœ) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem map_hom_inv_id_app {X Y : C} (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (Z : D) :\n    (F.map e.hom).app Z â‰« (F.map e.inv).app Z = ğŸ™ _ := by\n  simp [â† NatTrans.comp_app, â† Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Z) ((F.map e.inv).app Z)) (CategoryTheory.CategoryStruct.id ((F.obj X).obj Z))","decl":"@[reassoc (attr := simp)]\ntheorem map_hom_inv_id_app {X Y : C} (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (Z : D) :\n    (F.map e.hom).app Z â‰« (F.map e.inv).app Z = ğŸ™ _ := by\n  simp [â† NatTrans.comp_app, â† Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Z) ((F.map e.hom).app Z)) (CategoryTheory.CategoryStruct.id ((F.obj Y).obj Z))","decl":"@[reassoc (attr := simp)]\ntheorem map_inv_hom_id_app {X Y : C} (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (Z : D) :\n    (F.map e.inv).app Z â‰« (F.map e.hom).app Z = ğŸ™ _ := by\n  simp [â† NatTrans.comp_app, â† Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZâœ : D\nZ : E\nh : Quiver.Hom ((F.obj Y).obj Zâœ) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Zâœ) (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Zâœ) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem map_inv_hom_id_app {X Y : C} (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (Z : D) :\n    (F.map e.inv).app Z â‰« (F.map e.hom).app Z = ğŸ™ _ := by\n  simp [â† NatTrans.comp_app, â† Functor.map_comp]\n\n"}
