{"name":"CategoryTheory.NatTrans.ext'_iff","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± Œ≤ : Quiver.Hom F G\n‚ä¢ Iff (Eq Œ± Œ≤) (Eq Œ±.app Œ≤.app)","decl":"@[ext]\ntheorem ext' {Œ± Œ≤ : F ‚ü∂ G} (w : Œ±.app = Œ≤.app) : Œ± = Œ≤ := NatTrans.ext w\n\n"}
{"name":"CategoryTheory.NatTrans.ext'","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± Œ≤ : Quiver.Hom F G\nw : Eq Œ±.app Œ≤.app\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext]\ntheorem ext' {Œ± Œ≤ : F ‚ü∂ G} (w : Œ±.app = Œ≤.app) : Œ± = Œ≤ := NatTrans.ext w\n\n"}
{"name":"CategoryTheory.NatTrans.vcomp_eq_comp","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.NatTrans.vcomp Œ± Œ≤) (CategoryTheory.CategoryStruct.comp Œ± Œ≤)","decl":"@[simp]\ntheorem vcomp_eq_comp (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) : vcomp Œ± Œ≤ = Œ± ‚â´ Œ≤ := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.vcomp_app'","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : C\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (Œ≤.app X))","decl":"theorem vcomp_app' (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (X : C) : (Œ± ‚â´ Œ≤).app X = Œ±.app X ‚â´ Œ≤.app X := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.congr_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± Œ≤ : Quiver.Hom F G\nh : Eq Œ± Œ≤\nX : C\n‚ä¢ Eq (Œ±.app X) (Œ≤.app X)","decl":"theorem congr_app {Œ± Œ≤ : F ‚ü∂ G} (h : Œ± = Œ≤) (X : C) : Œ±.app X = Œ≤.app X := by rw [h]\n\n"}
{"name":"CategoryTheory.NatTrans.id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simp]\ntheorem id_app (F : C ‚•§ D) (X : C) : (ùüô F : F ‚ü∂ F).app X = ùüô (F.obj X) := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.comp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : C\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (Œ≤.app X))","decl":"@[simp]\ntheorem comp_app {F G H : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (X : C) :\n    (Œ± ‚â´ Œ≤).app X = Œ±.app X ‚â´ Œ≤.app X := rfl\n\n"}
{"name":"CategoryTheory.NatTrans.comp_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nX : C\nZ : D\nh : Quiver.Hom (H.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) h) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (CategoryTheory.CategoryStruct.comp (Œ≤.app X) h))","decl":"attribute [reassoc] comp_app\n\n"}
{"name":"CategoryTheory.NatTrans.app_naturality_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nX : C\nY Z‚úù : D\nf : Quiver.Hom Y Z‚úù\nZ : E\nh : Quiver.Hom ((G.obj X).obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj X).map f) (CategoryTheory.CategoryStruct.comp ((T.app X).app Z‚úù) h)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Y) (CategoryTheory.CategoryStruct.comp ((G.obj X).map f) h))","decl":"@[reassoc]\ntheorem app_naturality {F G : C ‚•§ D ‚•§ E} (T : F ‚ü∂ G) (X : C) {Y Z : D} (f : Y ‚ü∂ Z) :\n    (F.obj X).map f ‚â´ (T.app X).app Z = (T.app X).app Y ‚â´ (G.obj X).map f :=\n  (T.app X).naturality f\n\n"}
{"name":"CategoryTheory.NatTrans.app_naturality","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nX : C\nY Z : D\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.obj X).map f) ((T.app X).app Z)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Y) ((G.obj X).map f))","decl":"@[reassoc]\ntheorem app_naturality {F G : C ‚•§ D ‚•§ E} (T : F ‚ü∂ G) (X : C) {Y Z : D} (f : Y ‚ü∂ Z) :\n    (F.obj X).map f ‚â´ (T.app X).app Z = (T.app X).app Y ‚â´ (G.obj X).map f :=\n  (T.app X).naturality f\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nZ‚úù : D\nX Y : C\nf : Quiver.Hom X Y\nZ : E\nh : Quiver.Hom ((G.obj Y).obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map f).app Z‚úù) (CategoryTheory.CategoryStruct.comp ((T.app Y).app Z‚úù) h)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Z‚úù) (CategoryTheory.CategoryStruct.comp ((G.map f).app Z‚úù) h))","decl":"@[reassoc]\ntheorem naturality_app {F G : C ‚•§ D ‚•§ E} (T : F ‚ü∂ G) (Z : D) {X Y : C} (f : X ‚ü∂ Y) :\n    (F.map f).app Z ‚â´ (T.app Y).app Z = (T.app X).app Z ‚â´ (G.map f).app Z :=\n  congr_fun (congr_arg app (T.naturality f)) Z\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nT : Quiver.Hom F G\nZ : D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map f).app Z) ((T.app Y).app Z)) (CategoryTheory.CategoryStruct.comp ((T.app X).app Z) ((G.map f).app Z))","decl":"@[reassoc]\ntheorem naturality_app {F G : C ‚•§ D ‚•§ E} (T : F ‚ü∂ G) (Z : D) {X Y : C} (f : X ‚ü∂ Y) :\n    (F.map f).app Z ‚â´ (T.app Y).app Z = (T.app X).app Z ‚â´ (G.map f).app Z :=\n  congr_fun (congr_arg app (T.naturality f)) Z\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\nŒ± : Quiver.Hom F G\nX‚ÇÅ Y‚ÇÅ : C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ : D\nX‚ÇÉ : E\nZ : E'\nh : Quiver.Hom (((G.obj Y‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((F.map f).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.comp (((Œ±.app Y‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) h)) (CategoryTheory.CategoryStruct.comp (((Œ±.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.comp (((G.map f).app X‚ÇÇ).app X‚ÇÉ) h))","decl":"@[reassoc]\ntheorem naturality_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'}\n    (Œ± : F ‚ü∂ G) {X‚ÇÅ Y‚ÇÅ : C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((F.map f).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((Œ±.app Y‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ =\n      ((Œ±.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((G.map f).app X‚ÇÇ).app X‚ÇÉ :=\n  congr_app (NatTrans.naturality_app Œ± X‚ÇÇ f) X‚ÇÉ\n\n"}
{"name":"CategoryTheory.NatTrans.naturality_app_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\nŒ± : Quiver.Hom F G\nX‚ÇÅ Y‚ÇÅ : C\nf : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nX‚ÇÇ : D\nX‚ÇÉ : E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((F.map f).app X‚ÇÇ).app X‚ÇÉ) (((Œ±.app Y‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ)) (CategoryTheory.CategoryStruct.comp (((Œ±.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (((G.map f).app X‚ÇÇ).app X‚ÇÉ))","decl":"@[reassoc]\ntheorem naturality_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'}\n    (Œ± : F ‚ü∂ G) {X‚ÇÅ Y‚ÇÅ : C} (f : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((F.map f).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((Œ±.app Y‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ =\n      ((Œ±.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((G.map f).app X‚ÇÇ).app X‚ÇÉ :=\n  congr_app (NatTrans.naturality_app Œ± X‚ÇÇ f) X‚ÇÉ\n\n"}
{"name":"CategoryTheory.NatTrans.mono_of_mono_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Mono (Œ±.app X)\n‚ä¢ CategoryTheory.Mono Œ±","decl":"/-- A natural transformation is a monomorphism if each component is. -/\ntheorem mono_of_mono_app (Œ± : F ‚ü∂ G) [‚àÄ X : C, Mono (Œ±.app X)] : Mono Œ± :=\n  ‚ü®fun g h eq => by\n    ext X\n    rw [‚Üê cancel_mono (Œ±.app X), ‚Üê comp_app, eq, comp_app]‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.epi_of_epi_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\ninst‚úù : ‚àÄ (X : C), CategoryTheory.Epi (Œ±.app X)\n‚ä¢ CategoryTheory.Epi Œ±","decl":"/-- A natural transformation is an epimorphism if each component is. -/\ntheorem epi_of_epi_app (Œ± : F ‚ü∂ G) [‚àÄ X : C, Epi (Œ±.app X)] : Epi Œ± :=\n  ‚ü®fun g h eq => by\n    ext X\n    rw [‚Üê cancel_epi (Œ±.app X), ‚Üê comp_app, eq, comp_app]‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.id_comm","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ± Œ≤ : Quiver.Hom (CategoryTheory.Functor.id C) (CategoryTheory.Functor.id C)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ± Œ≤) (CategoryTheory.CategoryStruct.comp Œ≤ Œ±)","decl":"/-- The monoid of natural transformations of the identity is commutative.-/\nlemma id_comm (Œ± Œ≤ : (ùü≠ C) ‚ü∂ (ùü≠ C)) : Œ± ‚â´ Œ≤ = Œ≤ ‚â´ Œ± := by\n  ext X\n  exact (Œ±.naturality (Œ≤.app X)).symm\n\n"}
{"name":"CategoryTheory.NatTrans.hcomp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH I : CategoryTheory.Functor D E\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom H I\nX : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.hcomp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ≤.app (F.obj X)) (I.map (Œ±.app X)))","decl":"/-- `hcomp Œ± Œ≤` is the horizontal composition of natural transformations. -/\n@[simps]\ndef hcomp {H I : D ‚•§ E} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) : F ‚ãô H ‚ü∂ G ‚ãô I where\n  app := fun X : C => Œ≤.app (F.obj X) ‚â´ I.map (Œ±.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, ‚Üê assoc, naturality, assoc, ‚Üê map_comp I, naturality,\n      map_comp, assoc]\n\n"}
{"name":"CategoryTheory.NatTrans.hcomp_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor D E\nŒ± : Quiver.Hom F G\nX : C\n‚ä¢ Eq ((CategoryTheory.NatTrans.hcomp Œ± (CategoryTheory.CategoryStruct.id H)).app X) (H.map (Œ±.app X))","decl":"theorem hcomp_id_app {H : D ‚•§ E} (Œ± : F ‚ü∂ G) (X : C) : (Œ± ‚ó´ ùüô H).app X = H.map (Œ±.app X) := by\n  simp\n\n"}
{"name":"CategoryTheory.NatTrans.id_hcomp_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH : CategoryTheory.Functor E C\nŒ± : Quiver.Hom F G\nX : E\n‚ä¢ Eq ((CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id H) Œ±).app X) (Œ±.app (H.obj X))","decl":"theorem id_hcomp_app {H : E ‚•§ C} (Œ± : F ‚ü∂ G) (X : E) : (ùüô H ‚ó´ Œ±).app X = Œ±.app _ := by simp\n\n-- Note that we don't yet prove a `hcomp_assoc` lemma here: even stating it is painful, because we\n-- need to use associativity of functor composition. (It's true without the explicit associator,\n-- because functor composition is definitionally associative,\n-- but relying on the definitional equality causes bad problems with elaboration later.)\n"}
{"name":"CategoryTheory.NatTrans.exchange","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G H : CategoryTheory.Functor C D\nI J K : CategoryTheory.Functor D E\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\nŒ≥ : Quiver.Hom I J\nŒ¥ : Quiver.Hom J K\n‚ä¢ Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.comp Œ± Œ≤) (CategoryTheory.CategoryStruct.comp Œ≥ Œ¥)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.hcomp Œ± Œ≥) (CategoryTheory.NatTrans.hcomp Œ≤ Œ¥))","decl":"theorem exchange {I J K : D ‚•§ E} (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) (Œ≥ : I ‚ü∂ J) (Œ¥ : J ‚ü∂ K) :\n    (Œ± ‚â´ Œ≤) ‚ó´ (Œ≥ ‚â´ Œ¥) = (Œ± ‚ó´ Œ≥) ‚â´ Œ≤ ‚ó´ Œ¥ := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.flip_map_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\nj : C\n‚ä¢ Eq ((F.flip.map f).app j) ((F.obj j).map f)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C ‚•§ D ‚•§ E) : D ‚•§ C ‚•§ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.Functor.flip_obj_obj","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nk : D\nj : C\n‚ä¢ Eq ((F.flip.obj k).obj j) ((F.obj j).obj k)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C ‚•§ D ‚•§ E) : D ‚•§ C ‚•§ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.Functor.flip_obj_map","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nk : D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.flip.obj k).map f) ((F.map f).app k)","decl":"/-- Flip the arguments of a bifunctor. See also `Currying.lean`. -/\n@[simps]\nprotected def flip (F : C ‚•§ D ‚•§ E) : D ‚•§ C ‚•§ E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }\n\n"}
{"name":"CategoryTheory.flipFunctor_obj","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\n‚ä¢ Eq ((CategoryTheory.flipFunctor C D E).obj F) F.flip","decl":"variable (C D E) in\n/-- The functor `(C ‚•§ D ‚•§ E) ‚•§ D ‚•§ C ‚•§ E` which flips the variables. -/\n@[simps]\ndef flipFunctor : (C ‚•§ D ‚•§ E) ‚•§ D ‚•§ C ‚•§ E where\n  obj F := F.flip\n  map {F‚ÇÅ F‚ÇÇ} œÜ :=\n    { app := fun Y =>\n        { app := fun X => (œÜ.app X).app Y\n          naturality := fun X‚ÇÅ X‚ÇÇ f => by\n            dsimp\n            simp only [‚Üê NatTrans.comp_app, naturality] } }\n\n"}
{"name":"CategoryTheory.flipFunctor_map_app_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nœÜ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nY : D\nX : C\n‚ä¢ Eq ((((CategoryTheory.flipFunctor C D E).map œÜ).app Y).app X) ((œÜ.app X).app Y)","decl":"variable (C D E) in\n/-- The functor `(C ‚•§ D ‚•§ E) ‚•§ D ‚•§ C ‚•§ E` which flips the variables. -/\n@[simps]\ndef flipFunctor : (C ‚•§ D ‚•§ E) ‚•§ D ‚•§ C ‚•§ E where\n  obj F := F.flip\n  map {F‚ÇÅ F‚ÇÇ} œÜ :=\n    { app := fun Y =>\n        { app := fun X => (œÜ.app X).app Y\n          naturality := fun X‚ÇÅ X‚ÇÇ f => by\n            dsimp\n            simp only [‚Üê NatTrans.comp_app, naturality] } }\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ‚úù : D\nZ : E\nh : Quiver.Hom ((F.obj X).obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Z‚úù) (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Z‚úù) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem map_hom_inv_id_app {X Y : C} (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (Z : D) :\n    (F.map e.hom).app Z ‚â´ (F.map e.inv).app Z = ùüô _ := by\n  simp [‚Üê NatTrans.comp_app, ‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Z) ((F.map e.inv).app Z)) (CategoryTheory.CategoryStruct.id ((F.obj X).obj Z))","decl":"@[reassoc (attr := simp)]\ntheorem map_hom_inv_id_app {X Y : C} (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (Z : D) :\n    (F.map e.hom).app Z ‚â´ (F.map e.inv).app Z = ùüô _ := by\n  simp [‚Üê NatTrans.comp_app, ‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_app","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Z) ((F.map e.hom).app Z)) (CategoryTheory.CategoryStruct.id ((F.obj Y).obj Z))","decl":"@[reassoc (attr := simp)]\ntheorem map_inv_hom_id_app {X Y : C} (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (Z : D) :\n    (F.map e.inv).app Z ‚â´ (F.map e.hom).app Z = ùüô _ := by\n  simp [‚Üê NatTrans.comp_app, ‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.Functor.Category","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX Y : C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nZ‚úù : D\nZ : E\nh : Quiver.Hom ((F.obj Y).obj Z‚úù) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map e.inv).app Z‚úù) (CategoryTheory.CategoryStruct.comp ((F.map e.hom).app Z‚úù) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem map_inv_hom_id_app {X Y : C} (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (Z : D) :\n    (F.map e.inv).app Z ‚â´ (F.map e.hom).app Z = ùüô _ := by\n  simp [‚Üê NatTrans.comp_app, ‚Üê Functor.map_comp]\n\n"}
