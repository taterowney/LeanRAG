{"name":"Int.instCharZero","module":"Mathlib.Algebra.Ring.Int.Defs","initialProofState":"⊢ CharZero Int","decl":"instance instCharZero : CharZero ℤ where cast_injective _ _ := ofNat.inj\n\n"}
{"name":"Int.instMulDivCancelClass","module":"Mathlib.Algebra.Ring.Int.Defs","initialProofState":"⊢ MulDivCancelClass Int","decl":"instance instMulDivCancelClass : MulDivCancelClass ℤ where mul_div_cancel _ _ := mul_ediv_cancel _\n\n"}
{"name":"Int.cast_mul","module":"Mathlib.Algebra.Ring.Int.Defs","initialProofState":"α : Type u_1\ninst✝ : NonAssocRing α\nm n : Int\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\nlemma cast_mul {α : Type*} [NonAssocRing α] : ∀ m n, ((m * n : ℤ) : α) = m * n := fun m => by\n  obtain ⟨m, rfl | rfl⟩ := Int.eq_nat_or_neg m\n  · induction m with\n    | zero => simp\n    | succ m ih => simp_all [add_mul]\n  · induction m with\n    | zero => simp\n    | succ m ih => simp_all [add_mul]\n\n"}
{"name":"Int.cast_pow","module":"Mathlib.Algebra.Ring.Int.Defs","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Int\nm : Nat\n⊢ Eq (↑(HPow.hPow n m)) (HPow.hPow (↑n) m)","decl":"@[simp, norm_cast] lemma cast_pow {R : Type*} [Ring R] (n : ℤ) (m : ℕ) :\n    ↑(n ^ m) = (n ^ m : R) := by\n  induction' m with m ih <;> simp [_root_.pow_succ, *]\n\n"}
