{"name":"LinearMap.extendTo𝕜'_apply","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : AddCommGroup F\ninst✝² : Module Real F\ninst✝¹ : Module 𝕜 F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : LinearMap (RingHom.id Real) F Real\nx : F\n⊢ Eq (fr.extendTo𝕜' x) (HSub.hSub (↑(fr x)) (HMul.hMul RCLike.I ↑(fr (HSMul.hSMul RCLike.I x))))","decl":"theorem extendTo𝕜'_apply (fr : F →ₗ[ℝ] ℝ) (x : F) :\n    fr.extendTo𝕜' x = (fr x : 𝕜) - (I : 𝕜) * (fr ((I : 𝕜) • x) : 𝕜) := rfl\n\n"}
{"name":"LinearMap.extendTo𝕜'_apply_re","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : AddCommGroup F\ninst✝² : Module Real F\ninst✝¹ : Module 𝕜 F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : LinearMap (RingHom.id Real) F Real\nx : F\n⊢ Eq (RCLike.re (fr.extendTo𝕜' x)) (fr x)","decl":"@[simp]\ntheorem extendTo𝕜'_apply_re (fr : F →ₗ[ℝ] ℝ) (x : F) : re (fr.extendTo𝕜' x : 𝕜) = fr x := by\n  simp only [extendTo𝕜'_apply, map_sub, zero_mul, mul_zero, sub_zero,\n    rclike_simps]\n\n"}
{"name":"LinearMap.norm_extendTo𝕜'_apply_sq","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : AddCommGroup F\ninst✝² : Module Real F\ninst✝¹ : Module 𝕜 F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : LinearMap (RingHom.id Real) F Real\nx : F\n⊢ Eq (HPow.hPow (Norm.norm (fr.extendTo𝕜' x)) 2) (fr (HSMul.hSMul ((starRingEnd 𝕜) (fr.extendTo𝕜' x)) x))","decl":"theorem norm_extendTo𝕜'_apply_sq (fr : F →ₗ[ℝ] ℝ) (x : F) :\n    ‖(fr.extendTo𝕜' x : 𝕜)‖ ^ 2 = fr (conj (fr.extendTo𝕜' x : 𝕜) • x) :=\n  calc\n    ‖(fr.extendTo𝕜' x : 𝕜)‖ ^ 2 = re (conj (fr.extendTo𝕜' x) * fr.extendTo𝕜' x : 𝕜) := by\n      rw [RCLike.conj_mul, ← ofReal_pow, ofReal_re]\n    _ = fr (conj (fr.extendTo𝕜' x : 𝕜) • x) := by\n      rw [← smul_eq_mul, ← map_smul, extendTo𝕜'_apply_re]\n\n"}
{"name":"ContinuousLinearMap.norm_extendTo𝕜'_bound","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedSpace Real F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : ContinuousLinearMap (RingHom.id Real) F Real\nx : F\n⊢ LE.le (Norm.norm ((↑fr).extendTo𝕜' x)) (HMul.hMul (Norm.norm fr) (Norm.norm x))","decl":"/-- The norm of the extension is bounded by `‖fr‖`. -/\ntheorem norm_extendTo𝕜'_bound (fr : F →L[ℝ] ℝ) (x : F) :\n    ‖(fr.toLinearMap.extendTo𝕜' x : 𝕜)‖ ≤ ‖fr‖ * ‖x‖ := by\n  set lm : F →ₗ[𝕜] 𝕜 := fr.toLinearMap.extendTo𝕜'\n  by_cases h : lm x = 0\n  · rw [h, norm_zero]\n    apply mul_nonneg <;> exact norm_nonneg _\n  rw [← mul_le_mul_left (norm_pos_iff.2 h), ← sq]\n  calc\n    ‖lm x‖ ^ 2 = fr (conj (lm x : 𝕜) • x) := fr.toLinearMap.norm_extendTo𝕜'_apply_sq x\n    _ ≤ ‖fr (conj (lm x : 𝕜) • x)‖ := le_abs_self _\n    _ ≤ ‖fr‖ * ‖conj (lm x : 𝕜) • x‖ := le_opNorm _ _\n    _ = ‖(lm x : 𝕜)‖ * (‖fr‖ * ‖x‖) := by rw [norm_smul, norm_conj, mul_left_comm]\n\n"}
{"name":"ContinuousLinearMap.extendTo𝕜'_apply","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedSpace Real F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : ContinuousLinearMap (RingHom.id Real) F Real\nx : F\n⊢ Eq (fr.extendTo𝕜' x) (HSub.hSub (↑(fr x)) (HMul.hMul RCLike.I ↑(fr (HSMul.hSMul RCLike.I x))))","decl":"theorem extendTo𝕜'_apply (fr : F →L[ℝ] ℝ) (x : F) :\n    fr.extendTo𝕜' x = (fr x : 𝕜) - (I : 𝕜) * (fr ((I : 𝕜) • x) : 𝕜) := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_extendTo𝕜'","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : RCLike 𝕜\nF : Type u_2\ninst✝³ : SeminormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedSpace Real F\ninst✝ : IsScalarTower Real 𝕜 F\nfr : ContinuousLinearMap (RingHom.id Real) F Real\n⊢ Eq (Norm.norm fr.extendTo𝕜') (Norm.norm fr)","decl":"@[simp]\ntheorem norm_extendTo𝕜' (fr : F →L[ℝ] ℝ) : ‖(fr.extendTo𝕜' : F →L[𝕜] 𝕜)‖ = ‖fr‖ :=\n  le_antisymm (LinearMap.mkContinuous_norm_le _ (norm_nonneg _) _) <|\n    opNorm_le_bound _ (norm_nonneg _) fun x =>\n      calc\n        ‖fr x‖ = ‖re (fr.extendTo𝕜' x : 𝕜)‖ := congr_arg norm (fr.extendTo𝕜'_apply_re x).symm\n        _ ≤ ‖(fr.extendTo𝕜' x : 𝕜)‖ := abs_re_le_norm _\n        _ ≤ ‖(fr.extendTo𝕜' : F →L[𝕜] 𝕜)‖ * ‖x‖ := le_opNorm _ _\n\n"}
{"name":"LinearMap.extendTo𝕜_apply","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nF : Type u_2\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nfr : LinearMap (RingHom.id Real) (RestrictScalars Real 𝕜 F) Real\nx : F\n⊢ Eq (fr.extendTo𝕜 x) (HSub.hSub (↑(fr x)) (HMul.hMul RCLike.I ↑(fr (HSMul.hSMul RCLike.I x))))","decl":"theorem LinearMap.extendTo𝕜_apply (fr : RestrictScalars ℝ 𝕜 F →ₗ[ℝ] ℝ) (x : F) :\n    fr.extendTo𝕜 x = (fr x : 𝕜) - (I : 𝕜) * (fr ((I : 𝕜) • x) : 𝕜) := rfl\n\n"}
{"name":"ContinuousLinearMap.extendTo𝕜_apply","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nF : Type u_2\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nfr : ContinuousLinearMap (RingHom.id Real) (RestrictScalars Real 𝕜 F) Real\nx : F\n⊢ Eq (fr.extendTo𝕜 x) (HSub.hSub (↑(fr x)) (HMul.hMul RCLike.I ↑(fr (HSMul.hSMul RCLike.I x))))","decl":"theorem ContinuousLinearMap.extendTo𝕜_apply (fr : RestrictScalars ℝ 𝕜 F →L[ℝ] ℝ) (x : F) :\n    fr.extendTo𝕜 x = (fr x : 𝕜) - (I : 𝕜) * (fr ((I : 𝕜) • x) : 𝕜) := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_extendTo𝕜","module":"Mathlib.Analysis.NormedSpace.Extend","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nF : Type u_2\ninst✝¹ : SeminormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nfr : ContinuousLinearMap (RingHom.id Real) (RestrictScalars Real 𝕜 F) Real\n⊢ Eq (Norm.norm fr.extendTo𝕜) (Norm.norm fr)","decl":"@[simp]\ntheorem ContinuousLinearMap.norm_extendTo𝕜 (fr : RestrictScalars ℝ 𝕜 F →L[ℝ] ℝ) :\n    ‖fr.extendTo𝕜‖ = ‖fr‖ :=\n  fr.norm_extendTo𝕜'\n"}
