{"name":"Nat.choose_zero_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.choose 0) 1","decl":"@[simp]\ntheorem choose_zero_right (n : ℕ) : choose n 0 = 1 := by cases n <;> rfl\n\n"}
{"name":"Nat.choose_zero_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.choose 0 k.succ) 0","decl":"@[simp]\ntheorem choose_zero_succ (k : ℕ) : choose 0 (succ k) = 0 :=\n  rfl\n\n"}
{"name":"Nat.choose_succ_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.succ.choose k.succ) (HAdd.hAdd (n.choose k) (n.choose k.succ))","decl":"theorem choose_succ_succ (n k : ℕ) : choose (succ n) (succ k) = choose n k + choose n (succ k) :=\n  rfl\n\n"}
{"name":"Nat.choose_succ_succ'","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n 1).choose (HAdd.hAdd k 1)) (HAdd.hAdd (n.choose k) (n.choose (HAdd.hAdd k 1)))","decl":"theorem choose_succ_succ' (n k : ℕ) : choose (n + 1) (k + 1) = choose n k + choose n (k + 1) :=\n  rfl\n\n"}
{"name":"Nat.choose_succ_left","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhk : LT.lt 0 k\n⊢ Eq ((HAdd.hAdd n 1).choose k) (HAdd.hAdd (n.choose (HSub.hSub k 1)) (n.choose k))","decl":"theorem choose_succ_left (n k : ℕ) (hk : 0 < k) :\n    choose (n + 1) k = choose n (k - 1) + choose n k := by\n  obtain ⟨l, rfl⟩ : ∃ l, k = l + 1 := Nat.exists_eq_add_of_le' hk\n  rfl\n\n"}
{"name":"Nat.choose_succ_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhn : LT.lt 0 n\n⊢ Eq (n.choose (HAdd.hAdd k 1)) (HAdd.hAdd ((HSub.hSub n 1).choose k) ((HSub.hSub n 1).choose (HAdd.hAdd k 1)))","decl":"theorem choose_succ_right (n k : ℕ) (hn : 0 < n) :\n    choose n (k + 1) = choose (n - 1) k + choose (n - 1) (k + 1) := by\n  obtain ⟨l, rfl⟩ : ∃ l, n = l + 1 := Nat.exists_eq_add_of_le' hn\n  rfl\n\n"}
{"name":"Nat.choose_eq_choose_pred_add","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhn : LT.lt 0 n\nhk : LT.lt 0 k\n⊢ Eq (n.choose k) (HAdd.hAdd ((HSub.hSub n 1).choose (HSub.hSub k 1)) ((HSub.hSub n 1).choose k))","decl":"theorem choose_eq_choose_pred_add {n k : ℕ} (hn : 0 < n) (hk : 0 < k) :\n    choose n k = choose (n - 1) (k - 1) + choose (n - 1) k := by\n  obtain ⟨l, rfl⟩ : ∃ l, k = l + 1 := Nat.exists_eq_add_of_le' hk\n  rw [choose_succ_right _ _ hn, Nat.add_one_sub_one]\n\n"}
{"name":"Nat.choose_eq_zero_of_lt","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\na✝ : LT.lt n k\n⊢ Eq (n.choose k) 0","decl":"theorem choose_eq_zero_of_lt : ∀ {n k}, n < k → choose n k = 0\n  | _, 0, hk => absurd hk (Nat.not_lt_zero _)\n  | 0, _ + 1, _ => choose_zero_succ _\n  | n + 1, k + 1, hk => by\n    have hnk : n < k := lt_of_succ_lt_succ hk\n    have hnk1 : n < k + 1 := lt_of_succ_lt hk\n    rw [choose_succ_succ, choose_eq_zero_of_lt hnk, choose_eq_zero_of_lt hnk1]\n\n"}
{"name":"Nat.choose_self","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.choose n) 1","decl":"@[simp]\ntheorem choose_self (n : ℕ) : choose n n = 1 := by\n  induction n <;> simp [*, choose, choose_eq_zero_of_lt (lt_succ_self _)]\n\n"}
{"name":"Nat.choose_succ_self","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.choose n.succ) 0","decl":"@[simp]\ntheorem choose_succ_self (n : ℕ) : choose n (succ n) = 0 :=\n  choose_eq_zero_of_lt (lt_succ_self _)\n\n"}
{"name":"Nat.choose_one_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.choose 1) n","decl":"@[simp]\nlemma choose_one_right (n : ℕ) : choose n 1 = n := by induction n <;> simp [*, choose, Nat.add_comm]\n\n-- The `n+1`-st triangle number is `n` more than the `n`-th triangle number\n"}
{"name":"Nat.triangle_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (HDiv.hDiv (HMul.hMul (HAdd.hAdd n 1) (HSub.hSub (HAdd.hAdd n 1) 1)) 2) (HAdd.hAdd (HDiv.hDiv (HMul.hMul n (HSub.hSub n 1)) 2) n)","decl":"theorem triangle_succ (n : ℕ) : (n + 1) * (n + 1 - 1) / 2 = n * (n - 1) / 2 + n := by\n  rw [← add_mul_div_left, Nat.mul_comm 2 n, ← Nat.mul_add, Nat.add_sub_cancel, Nat.mul_comm]\n  cases n <;> rfl; apply zero_lt_succ\n\n"}
{"name":"Nat.choose_two_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.choose 2) (HDiv.hDiv (HMul.hMul n (HSub.hSub n 1)) 2)","decl":"/-- `choose n 2` is the `n`-th triangle number. -/\ntheorem choose_two_right (n : ℕ) : choose n 2 = n * (n - 1) / 2 := by\n  induction' n with n ih\n  · simp\n  · rw [triangle_succ n, choose, ih]\n    simp [Nat.add_comm]\n\n"}
{"name":"Nat.choose_pos","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\na✝ : LE.le k n\n⊢ LT.lt 0 (n.choose k)","decl":"theorem choose_pos : ∀ {n k}, k ≤ n → 0 < choose n k\n  | 0, _, hk => by rw [Nat.eq_zero_of_le_zero hk]; decide\n  | n + 1, 0, _ => by simp\n  | _ + 1, _ + 1, hk => Nat.add_pos_left (choose_pos (le_of_succ_le_succ hk)) _\n\n"}
{"name":"Nat.choose_eq_zero_iff","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Iff (Eq (n.choose k) 0) (LT.lt n k)","decl":"theorem choose_eq_zero_iff {n k : ℕ} : n.choose k = 0 ↔ n < k :=\n  ⟨fun h => lt_of_not_ge (mt Nat.choose_pos h.symm.not_lt), Nat.choose_eq_zero_of_lt⟩\n\n"}
{"name":"Nat.succ_mul_choose_eq","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul n.succ (n.choose k)) (HMul.hMul (n.succ.choose k.succ) k.succ)","decl":"theorem succ_mul_choose_eq : ∀ n k, succ n * choose n k = choose (succ n) (succ k) * succ k\n  | 0, 0 => by decide\n  | 0, k + 1 => by simp [choose]\n  | n + 1, 0 => by simp [choose, mul_succ, Nat.add_comm]\n  | n + 1, k + 1 => by\n    rw [choose_succ_succ (succ n) (succ k), Nat.add_mul, ← succ_mul_choose_eq n, mul_succ, ←\n      succ_mul_choose_eq n, Nat.add_right_comm, ← Nat.mul_add, ← choose_succ_succ, ← succ_mul]\n\n"}
{"name":"Nat.choose_mul_factorial_mul_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\na✝ : LE.le k n\n⊢ Eq (HMul.hMul (HMul.hMul (n.choose k) k.factorial) (HSub.hSub n k).factorial) n.factorial","decl":"theorem choose_mul_factorial_mul_factorial : ∀ {n k}, k ≤ n → choose n k * k ! * (n - k)! = n !\n  | 0, _, hk => by simp [Nat.eq_zero_of_le_zero hk]\n  | n + 1, 0, _ => by simp\n  | n + 1, succ k, hk => by\n    rcases lt_or_eq_of_le hk with hk₁ | hk₁\n    · have h : choose n k * k.succ ! * (n - k)! = (k + 1) * n ! := by\n        rw [← choose_mul_factorial_mul_factorial (le_of_succ_le_succ hk)]\n        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]\n      have h₁ : (n - k)! = (n - k) * (n - k.succ)! := by\n        rw [← succ_sub_succ, succ_sub (le_of_lt_succ hk₁), factorial_succ]\n      have h₂ : choose n (succ k) * k.succ ! * ((n - k) * (n - k.succ)!) = (n - k) * n ! := by\n        rw [← choose_mul_factorial_mul_factorial (le_of_lt_succ hk₁)]\n        simp [factorial_succ, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc]\n      have h₃ : k * n ! ≤ n * n ! := Nat.mul_le_mul_right _ (le_of_succ_le_succ hk)\n      rw [choose_succ_succ, Nat.add_mul, Nat.add_mul, succ_sub_succ, h, h₁, h₂, Nat.add_mul,\n        Nat.mul_sub_right_distrib, factorial_succ, ← Nat.add_sub_assoc h₃, Nat.add_assoc,\n        ← Nat.add_mul, Nat.add_sub_cancel_left, Nat.add_comm]\n    · rw [hk₁]; simp [hk₁, Nat.mul_comm, choose, Nat.sub_self]\n\n"}
{"name":"Nat.choose_mul","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k s : Nat\nhkn : LE.le k n\nhsk : LE.le s k\n⊢ Eq (HMul.hMul (n.choose k) (k.choose s)) (HMul.hMul (n.choose s) ((HSub.hSub n s).choose (HSub.hSub k s)))","decl":"theorem choose_mul {n k s : ℕ} (hkn : k ≤ n) (hsk : s ≤ k) :\n    n.choose k * k.choose s = n.choose s * (n - s).choose (k - s) :=\n  have h : 0 < (n - k)! * (k - s)! * s ! := by apply_rules [factorial_pos, Nat.mul_pos]\n  Nat.mul_right_cancel h <|\n  calc\n    n.choose k * k.choose s * ((n - k)! * (k - s)! * s !) =\n        n.choose k * (k.choose s * s ! * (k - s)!) * (n - k)! := by\n      rw [Nat.mul_assoc, Nat.mul_assoc, Nat.mul_assoc, Nat.mul_assoc _ s !, Nat.mul_assoc,\n        Nat.mul_comm (n - k)!, Nat.mul_comm s !]\n    _ = n ! := by\n      rw [choose_mul_factorial_mul_factorial hsk, choose_mul_factorial_mul_factorial hkn]\n    _ = n.choose s * s ! * ((n - s).choose (k - s) * (k - s)! * (n - s - (k - s))!) := by\n      rw [choose_mul_factorial_mul_factorial (Nat.sub_le_sub_right hkn _),\n        choose_mul_factorial_mul_factorial (hsk.trans hkn)]\n    _ = n.choose s * (n - s).choose (k - s) * ((n - k)! * (k - s)! * s !) := by\n      rw [Nat.sub_sub_sub_cancel_right hsk, Nat.mul_assoc, Nat.mul_left_comm s !, Nat.mul_assoc,\n        Nat.mul_comm (k - s)!, Nat.mul_comm s !, Nat.mul_right_comm, ← Nat.mul_assoc]\n\n"}
{"name":"Nat.choose_eq_factorial_div_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhk : LE.le k n\n⊢ Eq (n.choose k) (HDiv.hDiv n.factorial (HMul.hMul k.factorial (HSub.hSub n k).factorial))","decl":"theorem choose_eq_factorial_div_factorial {n k : ℕ} (hk : k ≤ n) :\n    choose n k = n ! / (k ! * (n - k)!) := by\n  rw [← choose_mul_factorial_mul_factorial hk, Nat.mul_assoc]\n  exact (mul_div_left _ (Nat.mul_pos (factorial_pos _) (factorial_pos _))).symm\n\n"}
{"name":"Nat.add_choose","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"i j : Nat\n⊢ Eq ((HAdd.hAdd i j).choose j) (HDiv.hDiv (HAdd.hAdd i j).factorial (HMul.hMul i.factorial j.factorial))","decl":"theorem add_choose (i j : ℕ) : (i + j).choose j = (i + j)! / (i ! * j !) := by\n  rw [choose_eq_factorial_div_factorial (Nat.le_add_left j i), Nat.add_sub_cancel_right,\n    Nat.mul_comm]\n\n"}
{"name":"Nat.add_choose_mul_factorial_mul_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"i j : Nat\n⊢ Eq (HMul.hMul (HMul.hMul ((HAdd.hAdd i j).choose j) i.factorial) j.factorial) (HAdd.hAdd i j).factorial","decl":"theorem add_choose_mul_factorial_mul_factorial (i j : ℕ) :\n    (i + j).choose j * i ! * j ! = (i + j)! := by\n  rw [← choose_mul_factorial_mul_factorial (Nat.le_add_left _ _), Nat.add_sub_cancel_right,\n    Nat.mul_right_comm]\n\n"}
{"name":"Nat.factorial_mul_factorial_dvd_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhk : LE.le k n\n⊢ Dvd.dvd (HMul.hMul k.factorial (HSub.hSub n k).factorial) n.factorial","decl":"theorem factorial_mul_factorial_dvd_factorial {n k : ℕ} (hk : k ≤ n) : k ! * (n - k)! ∣ n ! := by\n  rw [← choose_mul_factorial_mul_factorial hk, Nat.mul_assoc]; exact Nat.dvd_mul_left _ _\n\n"}
{"name":"Nat.factorial_mul_factorial_dvd_factorial_add","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"i j : Nat\n⊢ Dvd.dvd (HMul.hMul i.factorial j.factorial) (HAdd.hAdd i j).factorial","decl":"theorem factorial_mul_factorial_dvd_factorial_add (i j : ℕ) : i ! * j ! ∣ (i + j)! := by\n  suffices i ! * (i + j - i) ! ∣ (i + j)! by\n    rwa [Nat.add_sub_cancel_left i j] at this\n  exact factorial_mul_factorial_dvd_factorial (Nat.le_add_right _ _)\n\n"}
{"name":"Nat.choose_symm","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\nhk : LE.le k n\n⊢ Eq (n.choose (HSub.hSub n k)) (n.choose k)","decl":"@[simp]\ntheorem choose_symm {n k : ℕ} (hk : k ≤ n) : choose n (n - k) = choose n k := by\n  rw [choose_eq_factorial_div_factorial hk, choose_eq_factorial_div_factorial (Nat.sub_le _ _),\n    Nat.sub_sub_self hk, Nat.mul_comm]\n\n"}
{"name":"Nat.choose_symm_of_eq_add","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n a b : Nat\nh : Eq n (HAdd.hAdd a b)\n⊢ Eq (n.choose a) (n.choose b)","decl":"theorem choose_symm_of_eq_add {n a b : ℕ} (h : n = a + b) : Nat.choose n a = Nat.choose n b := by\n  suffices choose n (n - b) = choose n b by\n    rw [h, Nat.add_sub_cancel_right] at this; rwa [h]\n  exact choose_symm (h ▸ le_add_left _ _)\n\n"}
{"name":"Nat.choose_symm_add","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"a b : Nat\n⊢ Eq ((HAdd.hAdd a b).choose a) ((HAdd.hAdd a b).choose b)","decl":"theorem choose_symm_add {a b : ℕ} : choose (a + b) a = choose (a + b) b :=\n  choose_symm_of_eq_add rfl\n\n"}
{"name":"Nat.choose_symm_half","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"m : Nat\n⊢ Eq ((HAdd.hAdd (HMul.hMul 2 m) 1).choose (HAdd.hAdd m 1)) ((HAdd.hAdd (HMul.hMul 2 m) 1).choose m)","decl":"theorem choose_symm_half (m : ℕ) : choose (2 * m + 1) (m + 1) = choose (2 * m + 1) m := by\n  apply choose_symm_of_eq_add\n  rw [Nat.add_comm m 1, Nat.add_assoc 1 m m, Nat.add_comm (2 * m) 1, Nat.two_mul m]\n\n"}
{"name":"Nat.choose_succ_right_eq","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul (n.choose (HAdd.hAdd k 1)) (HAdd.hAdd k 1)) (HMul.hMul (n.choose k) (HSub.hSub n k))","decl":"theorem choose_succ_right_eq (n k : ℕ) : choose n (k + 1) * (k + 1) = choose n k * (n - k) := by\n  have e : (n + 1) * choose n k = choose n (k + 1) * (k + 1) + choose n k * (k + 1) := by\n    rw [← Nat.add_mul, Nat.add_comm (choose _ _), ← choose_succ_succ, succ_mul_choose_eq]\n  rw [← Nat.sub_eq_of_eq_add e, Nat.mul_comm, ← Nat.mul_sub_left_distrib, Nat.add_sub_add_right]\n\n"}
{"name":"Nat.choose_succ_self_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq ((HAdd.hAdd n 1).choose n) (HAdd.hAdd n 1)","decl":"@[simp]\ntheorem choose_succ_self_right : ∀ n : ℕ, (n + 1).choose n = n + 1\n  | 0 => rfl\n  | n + 1 => by rw [choose_succ_succ, choose_succ_self_right n, choose_self]\n\n"}
{"name":"Nat.choose_mul_succ_eq","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul (n.choose k) (HAdd.hAdd n 1)) (HMul.hMul ((HAdd.hAdd n 1).choose k) (HSub.hSub (HAdd.hAdd n 1) k))","decl":"theorem choose_mul_succ_eq (n k : ℕ) : n.choose k * (n + 1) = (n + 1).choose k * (n + 1 - k) := by\n  cases k with\n  | zero => simp\n  | succ k =>\n    obtain hk | hk := le_or_lt (k + 1) (n + 1)\n    · rw [choose_succ_succ, Nat.add_mul, succ_sub_succ, ← choose_succ_right_eq, ← succ_sub_succ,\n        Nat.mul_sub_left_distrib, Nat.add_sub_cancel' (Nat.mul_le_mul_left _ hk)]\n    · rw [choose_eq_zero_of_lt hk, choose_eq_zero_of_lt (n.lt_succ_self.trans hk), Nat.zero_mul,\n        Nat.zero_mul]\n\n"}
{"name":"Nat.ascFactorial_eq_factorial_mul_choose","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n 1).ascFactorial k) (HMul.hMul k.factorial ((HAdd.hAdd n k).choose k))","decl":"theorem ascFactorial_eq_factorial_mul_choose (n k : ℕ) :\n    (n + 1).ascFactorial k = k ! * (n + k).choose k := by\n  rw [Nat.mul_comm]\n  apply Nat.mul_right_cancel (n + k - k).factorial_pos\n  rw [choose_mul_factorial_mul_factorial <| Nat.le_add_left k n, Nat.add_sub_cancel_right,\n    ← factorial_mul_ascFactorial, Nat.mul_comm]\n\n"}
{"name":"Nat.ascFactorial_eq_factorial_mul_choose'","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.ascFactorial k) (HMul.hMul k.factorial ((HSub.hSub (HAdd.hAdd n k) 1).choose k))","decl":"theorem ascFactorial_eq_factorial_mul_choose' (n k : ℕ) :\n    n.ascFactorial k = k ! * (n + k - 1).choose k := by\n  cases n\n  · cases k\n    · rw [ascFactorial_zero, choose_zero_right, factorial_zero, Nat.mul_one]\n    · simp only [zero_ascFactorial, zero_eq, Nat.zero_add, succ_sub_succ_eq_sub,\n        Nat.le_zero_eq, Nat.sub_zero, choose_succ_self, Nat.mul_zero]\n  rw [ascFactorial_eq_factorial_mul_choose]\n  simp only [succ_add_sub_one]\n\n"}
{"name":"Nat.factorial_dvd_ascFactorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Dvd.dvd k.factorial (n.ascFactorial k)","decl":"theorem factorial_dvd_ascFactorial (n k : ℕ) : k ! ∣ n.ascFactorial k :=\n  ⟨(n + k - 1).choose k, ascFactorial_eq_factorial_mul_choose' _ _⟩\n\n"}
{"name":"Nat.choose_eq_asc_factorial_div_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n k).choose k) (HDiv.hDiv ((HAdd.hAdd n 1).ascFactorial k) k.factorial)","decl":"theorem choose_eq_asc_factorial_div_factorial (n k : ℕ) :\n    (n + k).choose k = (n + 1).ascFactorial k / k ! := by\n  apply Nat.mul_left_cancel k.factorial_pos\n  rw [← ascFactorial_eq_factorial_mul_choose]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_ascFactorial _ _).symm\n\n"}
{"name":"Nat.choose_eq_asc_factorial_div_factorial'","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HSub.hSub (HAdd.hAdd n k) 1).choose k) (HDiv.hDiv (n.ascFactorial k) k.factorial)","decl":"theorem choose_eq_asc_factorial_div_factorial' (n k : ℕ) :\n    (n + k - 1).choose k = n.ascFactorial k / k ! :=\n  Nat.eq_div_of_mul_eq_right k.factorial_ne_zero (ascFactorial_eq_factorial_mul_choose' _ _).symm\n\n"}
{"name":"Nat.descFactorial_eq_factorial_mul_choose","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.descFactorial k) (HMul.hMul k.factorial (n.choose k))","decl":"theorem descFactorial_eq_factorial_mul_choose (n k : ℕ) : n.descFactorial k = k ! * n.choose k := by\n  obtain h | h := Nat.lt_or_ge n k\n  · rw [descFactorial_eq_zero_iff_lt.2 h, choose_eq_zero_of_lt h, Nat.mul_zero]\n  rw [Nat.mul_comm]\n  apply Nat.mul_right_cancel (n - k).factorial_pos\n  rw [choose_mul_factorial_mul_factorial h, ← factorial_mul_descFactorial h, Nat.mul_comm]\n\n"}
{"name":"Nat.factorial_dvd_descFactorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Dvd.dvd k.factorial (n.descFactorial k)","decl":"theorem factorial_dvd_descFactorial (n k : ℕ) : k ! ∣ n.descFactorial k :=\n  ⟨n.choose k, descFactorial_eq_factorial_mul_choose _ _⟩\n\n"}
{"name":"Nat.choose_eq_descFactorial_div_factorial","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.choose k) (HDiv.hDiv (n.descFactorial k) k.factorial)","decl":"theorem choose_eq_descFactorial_div_factorial (n k : ℕ) : n.choose k = n.descFactorial k / k ! :=\n  Nat.eq_div_of_mul_eq_right k.factorial_ne_zero (descFactorial_eq_factorial_mul_choose _ _).symm\n\n"}
{"name":"Nat.choose_eq_fast_choose","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"⊢ Eq Nat.choose Nat.fast_choose","decl":"@[csimp] lemma choose_eq_fast_choose : Nat.choose = fast_choose :=\n  funext (fun _ => funext (Nat.choose_eq_descFactorial_div_factorial _))\n\n\n"}
{"name":"Nat.choose_le_succ_of_lt_half_left","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"r n : Nat\nh : LT.lt r (HDiv.hDiv n 2)\n⊢ LE.le (n.choose r) (n.choose (HAdd.hAdd r 1))","decl":"/-- Show that `Nat.choose` is increasing for small values of the right argument. -/\ntheorem choose_le_succ_of_lt_half_left {r n : ℕ} (h : r < n / 2) :\n    choose n r ≤ choose n (r + 1) := by\n  refine Nat.le_of_mul_le_mul_right ?_ (Nat.sub_pos_of_lt (h.trans_le (n.div_le_self 2)))\n  rw [← choose_succ_right_eq]\n  apply Nat.mul_le_mul_left\n  rw [← Nat.lt_iff_add_one_le, Nat.lt_sub_iff_add_lt, ← Nat.mul_two]\n  exact lt_of_lt_of_le (Nat.mul_lt_mul_of_pos_right h Nat.zero_lt_two) (n.div_mul_le_self 2)\n\n"}
{"name":"Nat.choose_le_middle","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"r n : Nat\n⊢ LE.le (n.choose r) (n.choose (HDiv.hDiv n 2))","decl":"/-- `choose n r` is maximised when `r` is `n/2`. -/\ntheorem choose_le_middle (r n : ℕ) : choose n r ≤ choose n (n / 2) := by\n  cases' le_or_gt r n with b b\n  · rcases le_or_lt r (n / 2) with a | h\n    · apply choose_le_middle_of_le_half_left a\n    · rw [← choose_symm b]\n      apply choose_le_middle_of_le_half_left\n      rw [div_lt_iff_lt_mul Nat.zero_lt_two] at h\n      rw [le_div_iff_mul_le Nat.zero_lt_two, Nat.mul_sub_right_distrib, Nat.sub_le_iff_le_add,\n        ← Nat.sub_le_iff_le_add', Nat.mul_two, Nat.add_sub_cancel]\n      exact le_of_lt h\n  · rw [choose_eq_zero_of_lt b]\n    apply zero_le\n\n"}
{"name":"Nat.choose_le_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"a c : Nat\n⊢ LE.le (a.choose c) (a.succ.choose c)","decl":"theorem choose_le_succ (a c : ℕ) : choose a c ≤ choose a.succ c := by\n  cases c <;> simp [Nat.choose_succ_succ]\n\n"}
{"name":"Nat.choose_le_add","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"a b c : Nat\n⊢ LE.le (a.choose c) ((HAdd.hAdd a b).choose c)","decl":"theorem choose_le_add (a b c : ℕ) : choose a c ≤ choose (a + b) c := by\n  induction' b with b_n b_ih\n  · simp\n  exact le_trans b_ih (choose_le_succ (a + b_n) c)\n\n"}
{"name":"Nat.choose_le_choose","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"a b c : Nat\nh : LE.le a b\n⊢ LE.le (a.choose c) (b.choose c)","decl":"theorem choose_le_choose {a b : ℕ} (c : ℕ) (h : a ≤ b) : choose a c ≤ choose b c :=\n  Nat.add_sub_cancel' h ▸ choose_le_add a (b - a) c\n\n"}
{"name":"Nat.choose_mono","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"b : Nat\n⊢ Monotone fun a => a.choose b","decl":"theorem choose_mono (b : ℕ) : Monotone fun a => choose a b := fun _ _ => choose_le_choose b\n\n"}
{"name":"Nat.multichoose_zero_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.multichoose 0) 1","decl":"@[simp]\ntheorem multichoose_zero_right (n : ℕ) : multichoose n 0 = 1 := by cases n <;> simp [multichoose]\n\n"}
{"name":"Nat.multichoose_zero_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.multichoose 0 (HAdd.hAdd k 1)) 0","decl":"@[simp]\ntheorem multichoose_zero_succ (k : ℕ) : multichoose 0 (k + 1) = 0 := by simp [multichoose]\n\n"}
{"name":"Nat.multichoose_succ_succ","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n 1).multichoose (HAdd.hAdd k 1)) (HAdd.hAdd (n.multichoose (HAdd.hAdd k 1)) ((HAdd.hAdd n 1).multichoose k))","decl":"theorem multichoose_succ_succ (n k : ℕ) :\n    multichoose (n + 1) (k + 1) = multichoose n (k + 1) + multichoose (n + 1) k := by\n  simp [multichoose]\n\n"}
{"name":"Nat.multichoose_one","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.multichoose 1 k) 1","decl":"@[simp]\ntheorem multichoose_one (k : ℕ) : multichoose 1 k = 1 := by\n  induction' k with k IH; · simp\n  simp [multichoose_succ_succ 0 k, IH]\n\n"}
{"name":"Nat.multichoose_two","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.multichoose 2 k) (HAdd.hAdd k 1)","decl":"@[simp]\ntheorem multichoose_two (k : ℕ) : multichoose 2 k = k + 1 := by\n  induction' k with k IH; · simp\n  rw [multichoose, IH]\n  simp [Nat.add_comm]\n\n"}
{"name":"Nat.multichoose_one_right","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n : Nat\n⊢ Eq (n.multichoose 1) n","decl":"@[simp]\ntheorem multichoose_one_right (n : ℕ) : multichoose n 1 = n := by\n  induction' n with n IH; · simp\n  simp [multichoose_succ_succ n 0, IH]\n\n"}
{"name":"Nat.multichoose_eq","module":"Mathlib.Data.Nat.Choose.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.multichoose k) ((HSub.hSub (HAdd.hAdd n k) 1).choose k)","decl":"theorem multichoose_eq : ∀ n k : ℕ, multichoose n k = (n + k - 1).choose k\n  | _, 0 => by simp\n  | 0, k + 1 => by simp\n  | n + 1, k + 1 => by\n    have : n + (k + 1) < (n + 1) + (k + 1) := Nat.add_lt_add_right (Nat.lt_succ_self _) _\n    have : (n + 1) + k < (n + 1) + (k + 1) := Nat.add_lt_add_left (Nat.lt_succ_self _) _\n    rw [multichoose_succ_succ, Nat.add_comm, Nat.succ_add_sub_one, ← Nat.add_assoc,\n      Nat.choose_succ_succ]\n    simp [multichoose_eq n (k+1), multichoose_eq (n+1) k]\n\n"}
