{"name":"Filter.smallSets_eq_generate","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Eq f.smallSets (Filter.generate (Set.image Set.powerset f.sets))","decl":"theorem smallSets_eq_generate {f : Filter Î±} : f.smallSets = generate (powerset '' f.sets) := by\n  simp_rw [generate_eq_biInf, smallSets, iInf_image, Filter.lift', Filter.lift, Function.comp_apply,\n    Filter.mem_sets]\n\n-- TODO: get more properties from the adjunction?\n-- TODO: is there a general way to get a lower adjoint for the lift of an upper adjoint?\n"}
{"name":"Filter.bind_smallSets_gc","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nâŠ¢ GaloisConnection (fun L => L.bind Filter.principal) Filter.smallSets","decl":"theorem bind_smallSets_gc :\n    GaloisConnection (fun L : Filter (Set Î±) â†¦ L.bind principal) smallSets := by\n  intro L l\n  simp_rw [smallSets_eq_generate, le_generate_iff, image_subset_iff]\n  rfl\n\n"}
{"name":"Filter.HasBasis.smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_3\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nh : l.HasBasis p s\nâŠ¢ l.smallSets.HasBasis p fun i => (s i).powerset","decl":"protected theorem HasBasis.smallSets {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} (h : HasBasis l p s) :\n    HasBasis l.smallSets p fun i => ð’« s i :=\n  h.lift' monotone_powerset\n\n"}
{"name":"Filter.hasBasis_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\nâŠ¢ l.smallSets.HasBasis (fun t => Membership.mem l t) Set.powerset","decl":"theorem hasBasis_smallSets (l : Filter Î±) :\n    HasBasis l.smallSets (fun t : Set Î± => t âˆˆ l) powerset :=\n  l.basis_sets.smallSets\n\n"}
{"name":"Filter.Eventually.exists_mem_basis_of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_3\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nP : Set Î± â†’ Prop\nhâ‚ : Filter.Eventually (fun t => P t) l.smallSets\nhâ‚‚ : l.HasBasis p s\nâŠ¢ Exists fun i => And (p i) (P (s i))","decl":"theorem Eventually.exists_mem_basis_of_smallSets {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {P : Set Î± â†’ Prop}\n    (hâ‚ : âˆ€á¶  t in l.smallSets, P t) (hâ‚‚ : HasBasis l p s) : âˆƒ i, p i âˆ§ P (s i) :=\n  (hâ‚‚.smallSets.eventually_iff.mp hâ‚).imp fun _i âŸ¨hpi, hiâŸ© â†¦ âŸ¨hpi, hi Subset.rflâŸ©\n\n"}
{"name":"Filter.Frequently.smallSets_of_forall_mem_basis","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_3\nl : Filter Î±\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nP : Set Î± â†’ Prop\nhâ‚ : âˆ€ (i : Î¹), p i â†’ P (s i)\nhâ‚‚ : l.HasBasis p s\nâŠ¢ Filter.Frequently (fun t => P t) l.smallSets","decl":"theorem Frequently.smallSets_of_forall_mem_basis {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {P : Set Î± â†’ Prop}\n    (hâ‚ : âˆ€ i, p i â†’ P (s i)) (hâ‚‚ : HasBasis l p s) : âˆƒá¶  t in l.smallSets, P t :=\n  hâ‚‚.smallSets.frequently_iff.mpr fun _ hi => âŸ¨_, Subset.rfl, hâ‚ _ hiâŸ©\n\n"}
{"name":"Filter.Eventually.exists_mem_of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Set Î± â†’ Prop\nh : Filter.Eventually (fun t => p t) l.smallSets\nâŠ¢ Exists fun s => And (Membership.mem l s) (p s)","decl":"theorem Eventually.exists_mem_of_smallSets {p : Set Î± â†’ Prop}\n    (h : âˆ€á¶  t in l.smallSets, p t) : âˆƒ s âˆˆ l, p s :=\n  h.exists_mem_basis_of_smallSets l.basis_sets\n\n"}
{"name":"Filter.tendsto_smallSets_iff","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nf : Î± â†’ Set Î²\nâŠ¢ Iff (Filter.Tendsto f la lb.smallSets) (âˆ€ (t : Set Î²), Membership.mem lb t â†’ Filter.Eventually (fun x => HasSubset.Subset (f x) t) la)","decl":"/-- `g` converges to `f.smallSets` if for all `s âˆˆ f`, eventually we have `g x âŠ† s`. -/\ntheorem tendsto_smallSets_iff {f : Î± â†’ Set Î²} :\n    Tendsto f la lb.smallSets â†” âˆ€ t âˆˆ lb, âˆ€á¶  x in la, f x âŠ† t :=\n  (hasBasis_smallSets lb).tendsto_right_iff\n\n"}
{"name":"Filter.eventually_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Set Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun s => p s) l.smallSets) (Exists fun s => And (Membership.mem l s) (âˆ€ (t : Set Î±), HasSubset.Subset t s â†’ p t))","decl":"theorem eventually_smallSets {p : Set Î± â†’ Prop} :\n    (âˆ€á¶  s in l.smallSets, p s) â†” âˆƒ s âˆˆ l, âˆ€ t, t âŠ† s â†’ p t :=\n  eventually_lift'_iff monotone_powerset\n\n"}
{"name":"Filter.eventually_smallSets'","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Set Î± â†’ Prop\nhp : âˆ€ â¦ƒs t : Set Î±â¦„, HasSubset.Subset s t â†’ p t â†’ p s\nâŠ¢ Iff (Filter.Eventually (fun s => p s) l.smallSets) (Exists fun s => And (Membership.mem l s) (p s))","decl":"theorem eventually_smallSets' {p : Set Î± â†’ Prop} (hp : âˆ€ â¦ƒs tâ¦„, s âŠ† t â†’ p t â†’ p s) :\n    (âˆ€á¶  s in l.smallSets, p s) â†” âˆƒ s âˆˆ l, p s :=\n  eventually_smallSets.trans <|\n    exists_congr fun s => Iff.rfl.and âŸ¨fun H => H s Subset.rfl, fun hs _t ht => hp ht hsâŸ©\n\n"}
{"name":"Filter.frequently_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Set Î± â†’ Prop\nâŠ¢ Iff (Filter.Frequently (fun s => p s) l.smallSets) (âˆ€ (t : Set Î±), Membership.mem l t â†’ Exists fun s => And (HasSubset.Subset s t) (p s))","decl":"theorem frequently_smallSets {p : Set Î± â†’ Prop} :\n    (âˆƒá¶  s in l.smallSets, p s) â†” âˆ€ t âˆˆ l, âˆƒ s, s âŠ† t âˆ§ p s :=\n  l.hasBasis_smallSets.frequently_iff\n\n"}
{"name":"Filter.frequently_smallSets_mem","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\nâŠ¢ Filter.Frequently (fun s => Membership.mem l s) l.smallSets","decl":"theorem frequently_smallSets_mem (l : Filter Î±) : âˆƒá¶  s in l.smallSets, s âˆˆ l :=\n  frequently_smallSets.2 fun t ht => âŸ¨t, Subset.rfl, htâŸ©\n\n"}
{"name":"Filter.tendsto_image_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (Filter.Tendsto (fun x => Set.image f x) la.smallSets lb.smallSets) (Filter.Tendsto f la lb)","decl":"@[simp]\nlemma tendsto_image_smallSets {f : Î± â†’ Î²} :\n    Tendsto (f '' Â·) la.smallSets lb.smallSets â†” Tendsto f la lb := by\n  rw [tendsto_smallSets_iff]\n  refine forallâ‚‚_congr fun u hu â†¦ ?_\n  rw [eventually_smallSets' fun s t hst ht â†¦ (image_subset _ hst).trans ht]\n  simp only [image_subset_iff, exists_mem_subset_iff, mem_map]\n\n"}
{"name":"Filter.Tendsto.image_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\nf : Î± â†’ Î²\naâœ : Filter.Tendsto f la lb\nâŠ¢ Filter.Tendsto (fun x => Set.image f x) la.smallSets lb.smallSets","decl":"alias âŸ¨_, Tendsto.image_smallSetsâŸ© := tendsto_image_smallSets\n\n"}
{"name":"Filter.HasAntitoneBasis.tendsto_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\nÎ¹ : Type u_4\ninstâœ : Preorder Î¹\ns : Î¹ â†’ Set Î±\nhl : l.HasAntitoneBasis s\nâŠ¢ Filter.Tendsto s Filter.atTop l.smallSets","decl":"theorem HasAntitoneBasis.tendsto_smallSets {Î¹} [Preorder Î¹] {s : Î¹ â†’ Set Î±}\n    (hl : l.HasAntitoneBasis s) : Tendsto s atTop l.smallSets :=\n  tendsto_smallSets_iff.2 fun _t ht => hl.eventually_subset ht\n\n"}
{"name":"Filter.monotone_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nâŠ¢ Monotone Filter.smallSets","decl":"@[mono]\ntheorem monotone_smallSets : Monotone (@smallSets Î±) :=\n  monotone_lift' monotone_id monotone_const\n\n"}
{"name":"Filter.smallSets_bot","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nâŠ¢ Eq Bot.bot.smallSets (Pure.pure EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem smallSets_bot : (âŠ¥ : Filter Î±).smallSets = pure âˆ… := by\n  rw [smallSets, lift'_bot, powerset_empty, principal_singleton]\n  exact monotone_powerset\n\n"}
{"name":"Filter.smallSets_top","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nâŠ¢ Eq Top.top.smallSets Top.top","decl":"@[simp]\ntheorem smallSets_top : (âŠ¤ : Filter Î±).smallSets = âŠ¤ := by\n  rw [smallSets, lift'_top, powerset_univ, principal_univ]\n\n"}
{"name":"Filter.smallSets_principal","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\ns : Set Î±\nâŠ¢ Eq (Filter.principal s).smallSets (Filter.principal s.powerset)","decl":"@[simp]\ntheorem smallSets_principal (s : Set Î±) : (ð“Ÿ s).smallSets = ð“Ÿ (ð’« s) :=\n  lift'_principal monotone_powerset\n\n"}
{"name":"Filter.smallSets_comap_eq_comap_image","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap f l).smallSets (Filter.comap (Set.image f) l.smallSets)","decl":"theorem smallSets_comap_eq_comap_image (l : Filter Î²) (f : Î± â†’ Î²) :\n    (comap f l).smallSets = comap (image f) l.smallSets := by\n  refine (gc_map_comap _).u_comm_of_l_comm (gc_map_comap _) bind_smallSets_gc bind_smallSets_gc ?_\n  simp [Function.comp_def, map_bind, bind_map]\n\n"}
{"name":"Filter.smallSets_comap","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î²\nf : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap f l).smallSets (l.lift' (Function.comp Set.powerset (Set.preimage f)))","decl":"theorem smallSets_comap (l : Filter Î²) (f : Î± â†’ Î²) :\n    (comap f l).smallSets = l.lift' (powerset âˆ˜ preimage f) :=\n  comap_lift'_eq2 monotone_powerset\n\n"}
{"name":"Filter.comap_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nl : Filter Î²\nf : Î± â†’ Set Î²\nâŠ¢ Eq (Filter.comap f l.smallSets) (l.lift' (Function.comp (Set.preimage f) Set.powerset))","decl":"theorem comap_smallSets (l : Filter Î²) (f : Î± â†’ Set Î²) :\n    comap f l.smallSets = l.lift' (preimage f âˆ˜ powerset) :=\n  comap_lift'_eq\n\n"}
{"name":"Filter.smallSets_iInf","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ¹ : Sort u_3\nf : Î¹ â†’ Filter Î±\nâŠ¢ Eq (iInf f).smallSets (iInf fun i => (f i).smallSets)","decl":"theorem smallSets_iInf {f : Î¹ â†’ Filter Î±} : (iInf f).smallSets = â¨… i, (f i).smallSets :=\n  lift'_iInf_of_map_univ (powerset_inter _ _) powerset_univ\n\n"}
{"name":"Filter.smallSets_inf","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nlâ‚ lâ‚‚ : Filter Î±\nâŠ¢ Eq (Min.min lâ‚ lâ‚‚).smallSets (Min.min lâ‚.smallSets lâ‚‚.smallSets)","decl":"theorem smallSets_inf (lâ‚ lâ‚‚ : Filter Î±) : (lâ‚ âŠ“ lâ‚‚).smallSets = lâ‚.smallSets âŠ“ lâ‚‚.smallSets :=\n  lift'_inf _ _ powerset_inter\n\n"}
{"name":"Filter.smallSets_neBot","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\nâŠ¢ l.smallSets.NeBot","decl":"instance smallSets_neBot (l : Filter Î±) : NeBot l.smallSets := by\n  refine (lift'_neBot_iff ?_).2 fun _ _ => powerset_nonempty\n  exact monotone_powerset\n\n"}
{"name":"Filter.Tendsto.smallSets_mono","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\ns t : Î± â†’ Set Î²\nht : Filter.Tendsto t la lb.smallSets\nhst : Filter.Eventually (fun x => HasSubset.Subset (s x) (t x)) la\nâŠ¢ Filter.Tendsto s la lb.smallSets","decl":"theorem Tendsto.smallSets_mono {s t : Î± â†’ Set Î²} (ht : Tendsto t la lb.smallSets)\n    (hst : âˆ€á¶  x in la, s x âŠ† t x) : Tendsto s la lb.smallSets := by\n  rw [tendsto_smallSets_iff] at ht âŠ¢\n  exact fun u hu => (ht u hu).mp (hst.mono fun _ hst ht => hst.trans ht)\n\n"}
{"name":"Filter.Tendsto.of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nla : Filter Î±\nlb : Filter Î²\ns : Î± â†’ Set Î²\nf : Î± â†’ Î²\nhs : Filter.Tendsto s la lb.smallSets\nhf : Filter.Eventually (fun x => Membership.mem (s x) (f x)) la\nâŠ¢ Filter.Tendsto f la lb","decl":"/-- Generalized **squeeze theorem** (also known as **sandwich theorem**). If `s : Î± â†’ Set Î²` is a\nfamily of sets that tends to `Filter.smallSets lb` along `la` and `f : Î± â†’ Î²` is a function such\nthat `f x âˆˆ s x` eventually along `la`, then `f` tends to `lb` along `la`.\n\nIf `s x` is the closed interval `[g x, h x]` for some functions `g`, `h` that tend to the same limit\n`ð“ y`, then we obtain the standard squeeze theorem, see\n`tendsto_of_tendsto_of_tendsto_of_le_of_le'`. -/\ntheorem Tendsto.of_smallSets {s : Î± â†’ Set Î²} {f : Î± â†’ Î²} (hs : Tendsto s la lb.smallSets)\n    (hf : âˆ€á¶  x in la, f x âˆˆ s x) : Tendsto f la lb := fun t ht =>\n  hf.mp <| (tendsto_smallSets_iff.mp hs t ht).mono fun _ hâ‚ hâ‚‚ => hâ‚ hâ‚‚\n\n"}
{"name":"Filter.eventually_smallSets_eventually","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl l' : Filter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun s => Filter.Eventually (fun x => Membership.mem s x â†’ p x) l') l.smallSets) (Filter.Eventually (fun x => p x) (Min.min l l'))","decl":"@[simp]\ntheorem eventually_smallSets_eventually {p : Î± â†’ Prop} :\n    (âˆ€á¶  s in l.smallSets, âˆ€á¶  x in l', x âˆˆ s â†’ p x) â†” âˆ€á¶  x in l âŠ“ l', p x :=\n  calc\n    _ â†” âˆƒ s âˆˆ l, âˆ€á¶  x in l', x âˆˆ s â†’ p x :=\n      eventually_smallSets' fun _ _ hst ht => ht.mono fun _ hx hs => hx (hst hs)\n    _ â†” âˆƒ s âˆˆ l, âˆƒ t âˆˆ l', âˆ€ x, x âˆˆ t â†’ x âˆˆ s â†’ p x := by simp only [eventually_iff_exists_mem]\n    _ â†” âˆ€á¶  x in l âŠ“ l', p x := by simp only [eventually_inf, and_comm, mem_inter_iff, â† and_imp]\n\n"}
{"name":"Filter.eventually_smallSets_forall","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Î± â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun s => âˆ€ (x : Î±), Membership.mem s x â†’ p x) l.smallSets) (Filter.Eventually (fun x => p x) l)","decl":"@[simp]\ntheorem eventually_smallSets_forall {p : Î± â†’ Prop} :\n    (âˆ€á¶  s in l.smallSets, âˆ€ x âˆˆ s, p x) â†” âˆ€á¶  x in l, p x := by\n  simpa only [inf_top_eq, eventually_top] using @eventually_smallSets_eventually Î± l âŠ¤ p\n\n"}
{"name":"Filter.Eventually.smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Î± â†’ Prop\naâœ : Filter.Eventually (fun x => p x) l\nâŠ¢ Filter.Eventually (fun s => âˆ€ (x : Î±), Membership.mem s x â†’ p x) l.smallSets","decl":"alias âŸ¨Eventually.of_smallSets, Eventually.smallSetsâŸ© := eventually_smallSets_forall\n\n"}
{"name":"Filter.Eventually.of_smallSets","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\np : Î± â†’ Prop\naâœ : Filter.Eventually (fun s => âˆ€ (x : Î±), Membership.mem s x â†’ p x) l.smallSets\nâŠ¢ Filter.Eventually (fun x => p x) l","decl":"alias âŸ¨Eventually.of_smallSets, Eventually.smallSetsâŸ© := eventually_smallSets_forall\n\n"}
{"name":"Filter.eventually_smallSets_subset","module":"Mathlib.Order.Filter.SmallSets","initialProofState":"Î± : Type u_1\nl : Filter Î±\ns : Set Î±\nâŠ¢ Iff (Filter.Eventually (fun t => HasSubset.Subset t s) l.smallSets) (Membership.mem l s)","decl":"@[simp]\ntheorem eventually_smallSets_subset {s : Set Î±} : (âˆ€á¶  t in l.smallSets, t âŠ† s) â†” s âˆˆ l :=\n  eventually_smallSets_forall\n\n"}
